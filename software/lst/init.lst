0001   0000             .include "lib/kernel.exp"
0001+  0000             sys_break        .EQU  $0000
0002+  0000             sys_rtc          .EQU  $0001
0003+  0000             sys_ide          .EQU  $0002
0004+  0000             sys_io           .EQU  $0003
0005+  0000             sys_filesystem   .EQU  $0004
0006+  0000             sys_spawn_proc   .EQU  $0005
0007+  0000             sys_list         .EQU  $0006
0008+  0000             sys_datetime     .EQU  $0007
0009+  0000             sys_reboot       .EQU  $0008
0010+  0000             sys_pause_proc   .EQU  $0009
0011+  0000             sys_resume_proc  .EQU  $000a
0012+  0000             sys_terminate_proc .EQU  $000b
0013+  0000             sys_system       .EQU  $000c
0014+  0000             text_org         .EQU  $0400
0002   0000             
0003   0000             STACK_BEGIN:	.equ $F7FF	; beginning of stack
0004   0000             
0005   0400             .org text_org			; origin at 1024
0006   0400             
0007   0400             shell_main:	
0008   0400 FD 49 FF F7 	mov bp, STACK_BEGIN
0009   0404 FD 47 FF F7 	mov sp, STACK_BEGIN
0010   0408             
0011   0408 3B 19 04    	mov d, s_prompt_init
0012   040B 07 68 06    	call _puts
0013   040E             
0014   040E 3B 27 04    	mov d, s_prompt_shell
0015   0411 07 68 06    	call _puts
0016   0414 3B 45 04    	mov d, s_shell_path
0017   0417 05 05       	syscall sys_spawn_proc
0018   0419             
0019   0419 69 6E 69 74 s_prompt_init:	.db "init started\n", 0
0019   041D 20 73 74 61 
0019   0421 72 74 65 64 
0019   0425 0A 00 
0020   0427 4C 61 75 6E s_prompt_shell:	.db "Launching a shell session...\n", 0
0020   042B 63 68 69 6E 
0020   042F 67 20 61 20 
0020   0433 73 68 65 6C 
0020   0437 6C 20 73 65 
0020   043B 73 73 69 6F 
0020   043F 6E 2E 2E 2E 
0020   0443 0A 00 
0021   0445 2F 75 73 72 s_shell_path:	  .db "/usr/bin/shell", 0
0021   0449 2F 62 69 6E 
0021   044D 2F 73 68 65 
0021   0451 6C 6C 00 
0022   0454             
0023   0454             .include "lib/stdio.asm"
0001+  0454             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0454             ; stdio.s
0003+  0454             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0454             .include "lib/string.asm"
0001++ 0454             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0454             ; string.s
0003++ 0454             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0454             
0005++ 0454             
0006++ 0454             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0454             ; _strrev
0008++ 0454             ; reverse a string
0009++ 0454             ; D = string address
0010++ 0454             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0454             ; 01234
0012++ 0454             _strrev:
0013++ 0454 4B          	pusha
0014++ 0455 07 9B 04    	call _strlen	; length in C
0015++ 0458 12          	mov a, c
0016++ 0459 AF 01 00    	cmp a, 1
0017++ 045C D0 76 04    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 045F 7D          	dec a
0019++ 0460 FD 4E       	mov si, d	; beginning of string
0020++ 0462 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0464 59          	add d, a	; end of string
0022++ 0465 12          	mov a, c
0023++ 0466 FD 9B       	shr a		; divide by 2
0024++ 0468 39          	mov c, a	; C now counts the steps
0025++ 0469             _strrev_L0:
0026++ 0469 32          	mov bl, [d]	; save load right-side char into BL
0027++ 046A F6          	lodsb		; load left-side char into AL; increase SI
0028++ 046B 3E          	mov [d], al	; store left char into right side
0029++ 046C 1B          	mov al, bl
0030++ 046D F7          	stosb		; store right-side char into left-side; increase DI
0031++ 046E 7E          	dec c
0032++ 046F 7F          	dec d
0033++ 0470 C2 00 00    	cmp c, 0
0034++ 0473 C7 69 04    	jne _strrev_L0
0035++ 0476             _strrev_end:
0036++ 0476 4C          	popa
0037++ 0477 09          	ret
0038++ 0478             	
0039++ 0478             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0478             ; _strchr
0041++ 0478             ; search string in D for char in AL
0042++ 0478             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0478             _strchr:
0044++ 0478             _strchr_L0:
0045++ 0478 32          	mov bl, [d]
0046++ 0479 C1 00       	cmp bl, 0
0047++ 047B C6 86 04    	je _strchr_end
0048++ 047E BA          	cmp al, bl
0049++ 047F C6 86 04    	je _strchr_end
0050++ 0482 79          	inc d
0051++ 0483 0A 78 04    	jmp _strchr_L0
0052++ 0486             _strchr_end:
0053++ 0486 1B          	mov al, bl
0054++ 0487 09          	ret
0055++ 0488             
0056++ 0488             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0488             ; _strstr
0058++ 0488             ; find sub-string
0059++ 0488             ; str1 in SI
0060++ 0488             ; str2 in DI
0061++ 0488             ; SI points to end of source string
0062++ 0488             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0488             _strstr:
0064++ 0488 DB          	push al
0065++ 0489 DA          	push d
0066++ 048A E3          	push di
0067++ 048B             _strstr_loop:
0068++ 048B F3          	cmpsb					; compare a byte of the strings
0069++ 048C C7 97 04    	jne _strstr_ret
0070++ 048F FC 00 00    	lea d, [di + 0]
0071++ 0492 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0494 C7 8B 04    	jne _strstr_loop				; equal chars but not at end
0073++ 0497             _strstr_ret:
0074++ 0497 F0          	pop di
0075++ 0498 E7          	pop d
0076++ 0499 E8          	pop al
0077++ 049A 09          	ret
0078++ 049B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 049B             ; length of null terminated string
0080++ 049B             ; result in C
0081++ 049B             ; pointer in D
0082++ 049B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 049B             _strlen:
0084++ 049B DA          	push d
0085++ 049C 38 00 00    	mov c, 0
0086++ 049F             _strlen_L1:
0087++ 049F BD 00       	cmp byte [d], 0
0088++ 04A1 C6 A9 04    	je _strlen_ret
0089++ 04A4 79          	inc d
0090++ 04A5 78          	inc c
0091++ 04A6 0A 9F 04    	jmp _strlen_L1
0092++ 04A9             _strlen_ret:
0093++ 04A9 E7          	pop d
0094++ 04AA 09          	ret
0095++ 04AB             
0096++ 04AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04AB             ; STRCMP
0098++ 04AB             ; compare two strings
0099++ 04AB             ; str1 in SI
0100++ 04AB             ; str2 in DI
0101++ 04AB             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04AB             _strcmp:
0104++ 04AB DB          	push al
0105++ 04AC DA          	push d
0106++ 04AD E3          	push di
0107++ 04AE E2          	push si
0108++ 04AF             _strcmp_loop:
0109++ 04AF F3          	cmpsb					; compare a byte of the strings
0110++ 04B0 C7 BB 04    	jne _strcmp_ret
0111++ 04B3 FB FF FF    	lea d, [si +- 1]
0112++ 04B6 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04B8 C7 AF 04    	jne _strcmp_loop				; equal chars but not at end
0114++ 04BB             _strcmp_ret:
0115++ 04BB EF          	pop si
0116++ 04BC F0          	pop di
0117++ 04BD E7          	pop d
0118++ 04BE E8          	pop al
0119++ 04BF 09          	ret
0120++ 04C0             
0121++ 04C0             
0122++ 04C0             ; STRCPY
0123++ 04C0             ; copy null terminated string from SI to DI
0124++ 04C0             ; source in SI
0125++ 04C0             ; destination in DI
0126++ 04C0             _strcpy:
0127++ 04C0 E2          	push si
0128++ 04C1 E3          	push di
0129++ 04C2 DB          	push al
0130++ 04C3             _strcpy_L1:
0131++ 04C3 F6          	lodsb
0132++ 04C4 F7          	stosb
0133++ 04C5 B9 00       	cmp al, 0
0134++ 04C7 C7 C3 04    	jne _strcpy_L1
0135++ 04CA             _strcpy_end:
0136++ 04CA E8          	pop al
0137++ 04CB F0          	pop di
0138++ 04CC EF          	pop si
0139++ 04CD 09          	ret
0140++ 04CE             
0141++ 04CE             ; STRCAT
0142++ 04CE             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04CE             ; source in SI
0144++ 04CE             ; destination in DI
0145++ 04CE             _strcat:
0146++ 04CE E2          	push si
0147++ 04CF E3          	push di
0148++ 04D0 D7          	push a
0149++ 04D1 DA          	push d
0150++ 04D2 50          	mov a, di
0151++ 04D3 3C          	mov d, a
0152++ 04D4             _strcat_goto_end_L1:
0153++ 04D4 BD 00       	cmp byte[d], 0
0154++ 04D6 C6 DD 04    	je _strcat_start
0155++ 04D9 79          	inc d
0156++ 04DA 0A D4 04    	jmp _strcat_goto_end_L1
0157++ 04DD             _strcat_start:
0158++ 04DD FD 50       	mov di, d
0159++ 04DF             _strcat_L1:
0160++ 04DF F6          	lodsb
0161++ 04E0 F7          	stosb
0162++ 04E1 B9 00       	cmp al, 0
0163++ 04E3 C7 DF 04    	jne _strcat_L1
0164++ 04E6             _strcat_end:
0165++ 04E6 E7          	pop d
0166++ 04E7 E4          	pop a
0167++ 04E8 F0          	pop di
0168++ 04E9 EF          	pop si
0169++ 04EA 09          	ret
0170++ 04EB             
0171++ 04EB             
0005+  04EB             
0006+  04EB             
0007+  04EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  04EB             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  04EB             ; ASCII in BL
0010+  04EB             ; result in AL
0011+  04EB             ; ascii for F = 0100 0110
0012+  04EB             ; ascii for 9 = 0011 1001
0013+  04EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  04EB             hex_ascii_encode:
0015+  04EB 1B            mov al, bl
0016+  04EC 93 40         test al, $40        ; test if letter or number
0017+  04EE C7 F4 04      jnz hex_letter
0018+  04F1 87 0F         and al, $0F        ; get number
0019+  04F3 09            ret
0020+  04F4             hex_letter:
0021+  04F4 87 0F         and al, $0F        ; get letter
0022+  04F6 6A 09         add al, 9
0023+  04F8 09            ret
0024+  04F9             
0025+  04F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  04F9             ; ATOI
0027+  04F9             ; 2 letter hex string in B
0028+  04F9             ; 8bit integer returned in AL
0029+  04F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  04F9             _atoi:
0031+  04F9 D8            push b
0032+  04FA 07 EB 04      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  04FD 30            mov bl, bh
0034+  04FE DB            push al          ; save a
0035+  04FF 07 EB 04      call hex_ascii_encode
0036+  0502 EA            pop bl  
0037+  0503 FD 9E 04      shl al, 4
0038+  0506 8C            or al, bl
0039+  0507 E5            pop b
0040+  0508 09            ret  
0041+  0509             
0042+  0509             
0043+  0509             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0509             ; scanf
0045+  0509             ; no need for explanations!
0046+  0509             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0509             scanf:
0048+  0509 09            ret
0049+  050A             
0050+  050A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  050A             ; ITOA
0052+  050A             ; 8bit value in BL
0053+  050A             ; 2 byte ASCII result in A
0054+  050A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  050A             _itoa:
0056+  050A DA            push d
0057+  050B D8            push b
0058+  050C A7 00         mov bh, 0
0059+  050E FD A4 04      shr bl, 4  
0060+  0511 74            mov d, b
0061+  0512 1F A4 07      mov al, [d + s_hex_digits]
0062+  0515 23            mov ah, al
0063+  0516               
0064+  0516 E5            pop b
0065+  0517 D8            push b
0066+  0518 A7 00         mov bh, 0
0067+  051A FD 87 0F      and bl, $0F
0068+  051D 74            mov d, b
0069+  051E 1F A4 07      mov al, [d + s_hex_digits]
0070+  0521 E5            pop b
0071+  0522 E7            pop d
0072+  0523 09            ret
0073+  0524             
0074+  0524             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0524             ; HEX STRING TO BINARY
0076+  0524             ; di = destination address
0077+  0524             ; si = source
0078+  0524             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0524             _hex_to_int:
0080+  0524             _hex_to_int_L1:
0081+  0524 F6            lodsb          ; load from [SI] to AL
0082+  0525 B9 00         cmp al, 0        ; check if ASCII 0
0083+  0527 C6 34 05      jz _hex_to_int_ret
0084+  052A 36            mov bh, al
0085+  052B F6            lodsb
0086+  052C 2F            mov bl, al
0087+  052D 07 F9 04      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0530 F7            stosb          ; store AL to [DI]
0089+  0531 0A 24 05      jmp _hex_to_int_L1
0090+  0534             _hex_to_int_ret:
0091+  0534 09            ret    
0092+  0535             
0093+  0535             
0094+  0535             
0095+  0535             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0535             ; GETCHAR
0097+  0535             ; char in ah
0098+  0535             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0535             getch:
0100+  0535 DB            push al
0101+  0536             getch_retry:
0102+  0536 19 01         mov al, 1
0103+  0538 05 03         syscall sys_io      ; receive in AH
0104+  053A E8            pop al
0105+  053B 09            ret
0106+  053C             
0107+  053C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  053C             ; PUTCHAR
0109+  053C             ; char in ah
0110+  053C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  053C             _putchar:
0112+  053C DB            push al
0113+  053D 19 00         mov al, 0
0114+  053F 05 03         syscall sys_io      ; char in AH
0115+  0541 E8            pop al
0116+  0542 09            ret
0117+  0543             
0118+  0543             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0543             ;; INPUT A STRING
0120+  0543             ;; terminates with null
0121+  0543             ;; pointer in D
0122+  0543             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0543             _gets:
0124+  0543 D7            push a
0125+  0544 DA            push d
0126+  0545             _gets_loop:
0127+  0545 19 01         mov al, 1
0128+  0547 05 03         syscall sys_io      ; receive in AH
0129+  0549 76 1B         cmp ah, 27
0130+  054B C6 6C 05      je _gets_ansi_esc
0131+  054E 76 0A         cmp ah, $0A        ; LF
0132+  0550 C6 C8 05      je _gets_end
0133+  0553 76 0D         cmp ah, $0D        ; CR
0134+  0555 C6 C8 05      je _gets_end
0135+  0558 76 5C         cmp ah, $5C        ; '\\'
0136+  055A C6 8E 05      je _gets_escape
0137+  055D 76 08         cmp ah, $08      ; check for backspace
0138+  055F C6 68 05      je _gets_backspace
0139+  0562 1A            mov al, ah
0140+  0563 3E            mov [d], al
0141+  0564 79            inc d
0142+  0565 0A 45 05      jmp _gets_loop
0143+  0568             _gets_backspace:
0144+  0568 7F            dec d
0145+  0569 0A 45 05      jmp _gets_loop
0146+  056C             _gets_ansi_esc:
0147+  056C 19 01         mov al, 1
0148+  056E 05 03         syscall sys_io        ; receive in AH without echo
0149+  0570 76 5B         cmp ah, '['
0150+  0572 C7 45 05      jne _gets_loop
0151+  0575 19 01         mov al, 1
0152+  0577 05 03         syscall sys_io          ; receive in AH without echo
0153+  0579 76 44         cmp ah, 'D'
0154+  057B C6 86 05      je _gets_left_arrow
0155+  057E 76 43         cmp ah, 'C'
0156+  0580 C6 8A 05      je _gets_right_arrow
0157+  0583 0A 45 05      jmp _gets_loop
0158+  0586             _gets_left_arrow:
0159+  0586 7F            dec d
0160+  0587 0A 45 05      jmp _gets_loop
0161+  058A             _gets_right_arrow:
0162+  058A 79            inc d
0163+  058B 0A 45 05      jmp _gets_loop
0164+  058E             _gets_escape:
0165+  058E 19 01         mov al, 1
0166+  0590 05 03         syscall sys_io      ; receive in AH
0167+  0592 76 6E         cmp ah, 'n'
0168+  0594 C6 B3 05      je _gets_LF
0169+  0597 76 72         cmp ah, 'r'
0170+  0599 C6 BA 05      je _gets_CR
0171+  059C 76 30         cmp ah, '0'
0172+  059E C6 C1 05      je _gets_NULL
0173+  05A1 76 5C         cmp ah, $5C  ; '\'
0174+  05A3 C6 AC 05      je _gets_slash
0175+  05A6 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  05A7 3E            mov [d], al
0177+  05A8 79            inc d
0178+  05A9 0A 45 05      jmp _gets_loop
0179+  05AC             _gets_slash:
0180+  05AC 19 5C         mov al, $5C
0181+  05AE 3E            mov [d], al
0182+  05AF 79            inc d
0183+  05B0 0A 45 05      jmp _gets_loop
0184+  05B3             _gets_LF:
0185+  05B3 19 0A         mov al, $0A
0186+  05B5 3E            mov [d], al
0187+  05B6 79            inc d
0188+  05B7 0A 45 05      jmp _gets_loop
0189+  05BA             _gets_CR:
0190+  05BA 19 0D         mov al, $0D
0191+  05BC 3E            mov [d], al
0192+  05BD 79            inc d
0193+  05BE 0A 45 05      jmp _gets_loop
0194+  05C1             _gets_NULL:
0195+  05C1 19 00         mov al, $00
0196+  05C3 3E            mov [d], al
0197+  05C4 79            inc d
0198+  05C5 0A 45 05      jmp _gets_loop
0199+  05C8             _gets_end:
0200+  05C8 19 00         mov al, 0
0201+  05CA 3E            mov [d], al        ; terminate string
0202+  05CB E7            pop d
0203+  05CC E4            pop a
0204+  05CD 09            ret
0205+  05CE             
0206+  05CE             
0207+  05CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  05CE             ;; INPUT TEXT
0209+  05CE             ;; terminated with CTRL+D
0210+  05CE             ;; pointer in D
0211+  05CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  05CE             _gettxt:
0213+  05CE D7            push a
0214+  05CF DA            push d
0215+  05D0             _gettxt_loop:
0216+  05D0 19 01         mov al, 1
0217+  05D2 05 03         syscall sys_io      ; receive in AH
0218+  05D4 76 04         cmp ah, 4      ; EOT
0219+  05D6 C6 0F 06      je _gettxt_end
0220+  05D9 76 08         cmp ah, $08      ; check for backspace
0221+  05DB C6 0B 06      je _gettxt_backspace
0222+  05DE 76 5C         cmp ah, $5C        ; '\'
0223+  05E0 C6 E9 05      je _gettxt_escape
0224+  05E3 1A            mov al, ah
0225+  05E4 3E            mov [d], al
0226+  05E5 79            inc d
0227+  05E6 0A D0 05      jmp _gettxt_loop
0228+  05E9             _gettxt_escape:
0229+  05E9 19 01         mov al, 1
0230+  05EB 05 03         syscall sys_io      ; receive in AH
0231+  05ED 76 6E         cmp ah, 'n'
0232+  05EF C6 FD 05      je _gettxt_LF
0233+  05F2 76 72         cmp ah, 'r'
0234+  05F4 C6 04 06      je _gettxt_CR
0235+  05F7 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  05F8 3E            mov [d], al
0237+  05F9 79            inc d
0238+  05FA 0A D0 05      jmp _gettxt_loop
0239+  05FD             _gettxt_LF:
0240+  05FD 19 0A         mov al, $0A
0241+  05FF 3E            mov [d], al
0242+  0600 79            inc d
0243+  0601 0A D0 05      jmp _gettxt_loop
0244+  0604             _gettxt_CR:
0245+  0604 19 0D         mov al, $0D
0246+  0606 3E            mov [d], al
0247+  0607 79            inc d
0248+  0608 0A D0 05      jmp _gettxt_loop
0249+  060B             _gettxt_backspace:
0250+  060B 7F            dec d
0251+  060C 0A D0 05      jmp _gettxt_loop
0252+  060F             _gettxt_end:
0253+  060F 19 00         mov al, 0
0254+  0611 3E            mov [d], al        ; terminate string
0255+  0612 E7            pop d
0256+  0613 E4            pop a
0257+  0614 09            ret
0258+  0615             
0259+  0615             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  0615             ; PRINT NEW LINE
0261+  0615             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  0615             printnl:
0263+  0615 D7            push a
0264+  0616 10 00 0A      mov a, $0A00
0265+  0619 05 03         syscall sys_io
0266+  061B 10 00 0D      mov a, $0D00
0267+  061E 05 03         syscall sys_io
0268+  0620 E4            pop a
0269+  0621 09            ret
0270+  0622             
0271+  0622             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  0622             ; _strtoint
0273+  0622             ; 4 digit hex string number in d
0274+  0622             ; integer returned in A
0275+  0622             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0622             _strtointx:
0277+  0622 D8            push b
0278+  0623 32            mov bl, [d]
0279+  0624 37            mov bh, bl
0280+  0625 33 01 00      mov bl, [d + 1]
0281+  0628 07 F9 04      call _atoi        ; convert to int in AL
0282+  062B 23            mov ah, al        ; move to AH
0283+  062C 33 02 00      mov bl, [d + 2]
0284+  062F 37            mov bh, bl
0285+  0630 33 03 00      mov bl, [d + 3]
0286+  0633 07 F9 04      call _atoi        ; convert to int in AL
0287+  0636 E5            pop b
0288+  0637 09            ret
0289+  0638             
0290+  0638             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  0638             ; _strtoint
0292+  0638             ; 5 digit base10 string number in d
0293+  0638             ; integer returned in A
0294+  0638             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  0638             _strtoint:
0296+  0638 E2            push si
0297+  0639 D8            push b
0298+  063A D9            push c
0299+  063B DA            push d
0300+  063C 07 9B 04      call _strlen      ; get string length in C
0301+  063F 7E            dec c
0302+  0640 FD 4E         mov si, d
0303+  0642 12            mov a, c
0304+  0643 FD 99         shl a
0305+  0645 3B BC 07      mov d, table_power
0306+  0648 59            add d, a
0307+  0649 38 00 00      mov c, 0
0308+  064C             _strtoint_L0:
0309+  064C F6            lodsb      ; load ASCII to al
0310+  064D B9 00         cmp al, 0
0311+  064F C6 62 06      je _strtoint_end
0312+  0652 6F 30         sub al, $30    ; make into integer
0313+  0654 22 00         mov ah, 0
0314+  0656 2A            mov b, [d]
0315+  0657 AC            mul a, b      ; result in B since it fits in 16bits
0316+  0658 11            mov a, b
0317+  0659 28            mov b, c
0318+  065A 54            add a, b
0319+  065B 39            mov c, a
0320+  065C 63 02 00      sub d, 2
0321+  065F 0A 4C 06      jmp _strtoint_L0
0322+  0662             _strtoint_end:
0323+  0662 12            mov a, c
0324+  0663 E7            pop d
0325+  0664 E6            pop c
0326+  0665 E5            pop b
0327+  0666 EF            pop si
0328+  0667 09            ret
0329+  0668             
0330+  0668             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  0668             ; PRINT NULL TERMINATED STRING
0332+  0668             ; pointer in D
0333+  0668             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  0668             _puts:
0335+  0668 D7            push a
0336+  0669 DA            push d
0337+  066A             _puts_L1:
0338+  066A 1E            mov al, [d]
0339+  066B B9 00         cmp al, 0
0340+  066D C6 79 06      jz _puts_END
0341+  0670 23            mov ah, al
0342+  0671 19 00         mov al, 0
0343+  0673 05 03         syscall sys_io
0344+  0675 79            inc d
0345+  0676 0A 6A 06      jmp _puts_L1
0346+  0679             _puts_END:
0347+  0679 E7            pop d
0348+  067A E4            pop a
0349+  067B 09            ret
0350+  067C             
0351+  067C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  067C             ; PRINT N SIZE STRING
0353+  067C             ; pointer in D
0354+  067C             ; size in C
0355+  067C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  067C             _putsn:
0357+  067C DB            push al
0358+  067D DA            push d
0359+  067E D9            push c
0360+  067F             _putsn_L0:
0361+  067F 1E            mov al, [d]
0362+  0680 23            mov ah, al
0363+  0681 19 00         mov al, 0
0364+  0683 05 03         syscall sys_io
0365+  0685 79            inc d
0366+  0686 7E            dec c  
0367+  0687 C2 00 00      cmp c, 0
0368+  068A C7 7F 06      jne _putsn_L0
0369+  068D             _putsn_end:
0370+  068D E6            pop c
0371+  068E E7            pop d
0372+  068F E8            pop al
0373+  0690 09            ret
0374+  0691             
0375+  0691             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  0691             ; print 16bit decimal number
0377+  0691             ; input number in A
0378+  0691             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0691             print_u16d:
0380+  0691 D7            push a
0381+  0692 D8            push b
0382+  0693 FD D8         push g
0383+  0695 26 10 27      mov b, 10000
0384+  0698 AE            div a, b      ; get 10000's coeff.
0385+  0699 07 BD 06      call print_number
0386+  069C 11            mov a, b
0387+  069D 26 E8 03      mov b, 1000
0388+  06A0 AE            div a, b      ; get 1000's coeff.
0389+  06A1 07 BD 06      call print_number
0390+  06A4 11            mov a, b
0391+  06A5 26 64 00      mov b, 100
0392+  06A8 AE            div a, b
0393+  06A9 07 BD 06      call print_number
0394+  06AC 11            mov a, b
0395+  06AD 26 0A 00      mov b, 10
0396+  06B0 AE            div a, b
0397+  06B1 07 BD 06      call print_number
0398+  06B4 1B            mov al, bl      ; 1's coeff in bl
0399+  06B5 07 BD 06      call print_number
0400+  06B8 FD F1         pop g
0401+  06BA E5            pop b
0402+  06BB E4            pop a
0403+  06BC 09            ret
0404+  06BD             
0405+  06BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  06BD             ; print AL
0407+  06BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  06BD             print_number:
0409+  06BD 6A 30         add al, $30
0410+  06BF 23            mov ah, al
0411+  06C0 07 3C 05      call _putchar
0412+  06C3 09            ret
0413+  06C4             
0414+  06C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  06C4             ; PRINT 16BIT HEX INTEGER
0416+  06C4             ; integer value in reg B
0417+  06C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  06C4             print_u16x:
0419+  06C4 D7            push a
0420+  06C5 D8            push b
0421+  06C6 DD            push bl
0422+  06C7 30            mov bl, bh
0423+  06C8 07 0A 05      call _itoa        ; convert bh to char in A
0424+  06CB 2F            mov bl, al        ; save al
0425+  06CC 19 00         mov al, 0
0426+  06CE 05 03         syscall sys_io        ; display AH
0427+  06D0 24            mov ah, bl        ; retrieve al
0428+  06D1 19 00         mov al, 0
0429+  06D3 05 03         syscall sys_io        ; display AL
0430+  06D5             
0431+  06D5 EA            pop bl
0432+  06D6 07 0A 05      call _itoa        ; convert bh to char in A
0433+  06D9 2F            mov bl, al        ; save al
0434+  06DA 19 00         mov al, 0
0435+  06DC 05 03         syscall sys_io        ; display AH
0436+  06DE 24            mov ah, bl        ; retrieve al
0437+  06DF 19 00         mov al, 0
0438+  06E1 05 03         syscall sys_io        ; display AL
0439+  06E3             
0440+  06E3 E5            pop b
0441+  06E4 E4            pop a
0442+  06E5 09            ret
0443+  06E6             
0444+  06E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  06E6             ; INPUT 16BIT HEX INTEGER
0446+  06E6             ; read 16bit integer into A
0447+  06E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  06E6             scan_u16x:
0449+  06E6 F8 10 00      enter 16
0450+  06E9 D8            push b
0451+  06EA DA            push d
0452+  06EB             
0453+  06EB FA F1 FF      lea d, [bp + -15]
0454+  06EE 07 43 05      call _gets        ; get number
0455+  06F1             
0456+  06F1 32            mov bl, [d]
0457+  06F2 37            mov bh, bl
0458+  06F3 33 01 00      mov bl, [d + 1]
0459+  06F6 07 F9 04      call _atoi        ; convert to int in AL
0460+  06F9 23            mov ah, al        ; move to AH
0461+  06FA             
0462+  06FA 33 02 00      mov bl, [d + 2]
0463+  06FD 37            mov bh, bl
0464+  06FE 33 03 00      mov bl, [d + 3]
0465+  0701 07 F9 04      call _atoi        ; convert to int in AL
0466+  0704             
0467+  0704 E7            pop d
0468+  0705 E5            pop b
0469+  0706 F9            leave
0470+  0707 09            ret
0471+  0708             
0472+  0708             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  0708             ; PRINT 8bit HEX INTEGER
0474+  0708             ; integer value in reg bl
0475+  0708             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0708             print_u8x:
0477+  0708 D7            push a
0478+  0709 DD            push bl
0479+  070A             
0480+  070A 07 0A 05      call _itoa        ; convert bl to char in A
0481+  070D 2F            mov bl, al        ; save al
0482+  070E 19 00         mov al, 0
0483+  0710 05 03         syscall sys_io        ; display AH
0484+  0712 24            mov ah, bl        ; retrieve al
0485+  0713 19 00         mov al, 0
0486+  0715 05 03         syscall sys_io        ; display AL
0487+  0717             
0488+  0717 EA            pop bl
0489+  0718 E4            pop a
0490+  0719 09            ret
0491+  071A             
0492+  071A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  071A             ; print 8bit decimal unsigned number
0494+  071A             ; input number in AL
0495+  071A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  071A             print_u8d:
0497+  071A D7            push a
0498+  071B D8            push b
0499+  071C FD D8         push g
0500+  071E 22 00         mov ah, 0
0501+  0720 26 64 00      mov b, 100
0502+  0723 AE            div a, b
0503+  0724 D8            push b      ; save remainder
0504+  0725 B9 00         cmp al, 0
0505+  0727 C6 31 07      je skip100
0506+  072A 6A 30         add al, $30
0507+  072C 23            mov ah, al
0508+  072D 19 00         mov al, 0
0509+  072F 05 03         syscall sys_io  ; print coeff
0510+  0731             skip100:
0511+  0731 E4            pop a
0512+  0732 22 00         mov ah, 0
0513+  0734 26 0A 00      mov b, 10
0514+  0737 AE            div a, b
0515+  0738 D8            push b      ; save remainder
0516+  0739 B9 00         cmp al, 0
0517+  073B C6 45 07      je skip10
0518+  073E 6A 30         add al, $30
0519+  0740 23            mov ah, al
0520+  0741 19 00         mov al, 0
0521+  0743 05 03         syscall sys_io  ; print coeff
0522+  0745             skip10:
0523+  0745 E4            pop a
0524+  0746 1B            mov al, bl
0525+  0747 6A 30         add al, $30
0526+  0749 23            mov ah, al
0527+  074A 19 00         mov al, 0
0528+  074C 05 03         syscall sys_io  ; print coeff
0529+  074E FD F1         pop g
0530+  0750 E5            pop b
0531+  0751 E4            pop a
0532+  0752 09            ret
0533+  0753             
0534+  0753             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  0753             ; INPUT 8BIT HEX INTEGER
0536+  0753             ; read 8bit integer into AL
0537+  0753             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  0753             scan_u8x:
0539+  0753 F8 04 00      enter 4
0540+  0756 D8            push b
0541+  0757 DA            push d
0542+  0758             
0543+  0758 FA FD FF      lea d, [bp + -3]
0544+  075B 07 43 05      call _gets        ; get number
0545+  075E             
0546+  075E 32            mov bl, [d]
0547+  075F 37            mov bh, bl
0548+  0760 33 01 00      mov bl, [d + 1]
0549+  0763 07 F9 04      call _atoi        ; convert to int in AL
0550+  0766             
0551+  0766 E7            pop d
0552+  0767 E5            pop b
0553+  0768 F9            leave
0554+  0769 09            ret
0555+  076A             
0556+  076A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  076A             ; input decimal number
0558+  076A             ; result in A
0559+  076A             ; 655'\0'
0560+  076A             ; low--------high
0561+  076A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  076A             scan_u16d:
0563+  076A F8 08 00      enter 8
0564+  076D E2            push si
0565+  076E D8            push b
0566+  076F D9            push c
0567+  0770 DA            push d
0568+  0771 FA F9 FF      lea d, [bp +- 7]
0569+  0774 07 43 05      call _gets
0570+  0777 07 9B 04      call _strlen      ; get string length in C
0571+  077A 7E            dec c
0572+  077B FD 4E         mov si, d
0573+  077D 12            mov a, c
0574+  077E FD 99         shl a
0575+  0780 3B BC 07      mov d, table_power
0576+  0783 59            add d, a
0577+  0784 38 00 00      mov c, 0
0578+  0787             mul_loop:
0579+  0787 F6            lodsb      ; load ASCII to al
0580+  0788 B9 00         cmp al, 0
0581+  078A C6 9D 07      je mul_exit
0582+  078D 6F 30         sub al, $30    ; make into integer
0583+  078F 22 00         mov ah, 0
0584+  0791 2A            mov b, [d]
0585+  0792 AC            mul a, b      ; result in B since it fits in 16bits
0586+  0793 11            mov a, b
0587+  0794 28            mov b, c
0588+  0795 54            add a, b
0589+  0796 39            mov c, a
0590+  0797 63 02 00      sub d, 2
0591+  079A 0A 87 07      jmp mul_loop
0592+  079D             mul_exit:
0593+  079D 12            mov a, c
0594+  079E E7            pop d
0595+  079F E6            pop c
0596+  07A0 E5            pop b
0597+  07A1 EF            pop si
0598+  07A2 F9            leave
0599+  07A3 09            ret
0600+  07A4             
0601+  07A4             
0602+  07A4 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  07A8 34 35 36 37 
0602+  07AC 38 39 41 42 
0602+  07B0 43 44 45 46 
0603+  07B4 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  07B8 1B 5B 48 00 
0604+  07BC             
0605+  07BC             table_power:
0606+  07BC 01 00         .dw 1
0607+  07BE 0A 00         .dw 10
0608+  07C0 64 00         .dw 100
0609+  07C2 E8 03         .dw 1000
0610+  07C4 10 27         .dw 100000024   07C6             
0025   07C6             .end
tasm: Number of errors = 0
