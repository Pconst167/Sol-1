0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             ; Memory Map
0005   0000             ; ------------------------------------------------------------------------------------------------------------------;
0006   0000             ; 0000    ROM BEGIN
0007   0000             ; ....
0008   0000             ; 7FFF    ROM END
0009   0000             ;
0010   0000             ; 8000    RAM begin
0011   0000             ; ....
0012   0000             ; F7FF    Stack root
0013   0000             ; ------------------------------------------------------------------------------------------------------------------;
0014   0000             ; I/O MAP
0015   0000             ; ------------------------------------------------------------------------------------------------------------------;
0016   0000             ; FF80    UART 0              (16550)
0017   0000             ; FF90    UART 1              (16550)
0018   0000             ; FFA0    RTC                 (M48T02)
0019   0000             ; FFB0    PIO 0               (8255)
0020   0000             ; FFC0    5.25" Floppy Drive Block
0021   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0022   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0023   0000             ;   - FFC2      FDC         (WD1770 Floppy Drive Controller) 
0024   0000             ;      
0025   0000             ; FFD0    IDE                 (Compact Flash / PATA)
0026   0000             ; FFE0    Timer               (8253)
0027   0000             ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             XON               .equ $11
0050   0000             XOFF              .equ $13
0051   0000             
0052   0000             _ide_BASE         .equ $FFD0            ; IDE BASE
0053   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0054   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0055   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0056   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0057   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0058   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0059   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0060   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0061   0000             
0062   0000             _7SEG_DISPLAY     .equ $FFB0            ; BIOS POST CODE HEX DISPLAY (2 DIGITS) (CONNECTED TO PIO A)
0063   0000             _BIOS_POST_CTRL   .equ $FFB3            ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0064   0000             _PIO_A            .equ $FFB0    
0065   0000             _PIO_B            .equ $FFB1
0066   0000             _PIO_C            .equ $FFB2
0067   0000             _PIO_CONTROL      .equ $FFB3            ; PIO CONTROL PORT
0068   0000             
0069   0000             _TIMER_C_0        .equ $FFE0            ; TIMER COUNTER 0
0070   0000             _TIMER_C_1        .equ $FFE1            ; TIMER COUNTER 1
0071   0000             _TIMER_C_2        .equ $FFE2            ; TIMER COUNTER 2
0072   0000             _TIMER_CTRL       .equ $FFE3            ; TIMER CONTROL REGISTER
0073   0000             
0074   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0075   0000             FIFO_SIZE         .equ 1024
0076   0000             
0077   0000             text_org          .equ $400
0078   0000             ; ------------------------------------------------------------------------------------------------------------------;
0079   0000             
0080   0000             
0081   0000             ; For the next iteration:
0082   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0083   0000             ; inode-table format:
0084   0000             ;  file-type(f, d)
0085   0000             ;  permissons
0086   0000             ;  link-count
0087   0000             ;  filesize
0088   0000             ;  time-stamps
0089   0000             ;  15 data block pointers
0090   0000             ;  single-indirect pointer
0091   0000             
0092   0000             ; FILE ENTRY ATTRIBUTES
0093   0000             ; filename (24)
0094   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0095   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0096   0000             ; size (2)             : filesize
0097   0000             ; day (1)           
0098   0000             ; month (1)
0099   0000             ; year (1)
0100   0000             ; packet size = 32 bytes  : total packet size in bytes
0101   0000             
0102   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0103   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0104   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0105   0000             FST_NBR_DIRECTORIES     .equ 64
0106   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0107   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0108   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0109   0000             FST_LBA_START           .equ 32
0110   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0111   0000             
0112   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0113   0000             FS_SECTORS_PER_FILE     .equ 32         ; the first sector is always a header with a NULL parameter (first byte)
0114   0000                                                     ; so that we know which blocks are free or taken
0115   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0116   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0117   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0118   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0119   0000             
0120   0000             root_id:                .equ FST_LBA_START
0121   0000             
0122   0000             ; ------------------------------------------------------------------------------------------------------------------;
0123   0000             ; GLOBAL SYSTEM VARIABLES
0124   0000             ; ------------------------------------------------------------------------------------------------------------------;
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; IRQ Table
0128   0000             ; Highest priority at lowest address
0129   0000             ; ------------------------------------------------------------------------------------------------------------------;
0130   0000 3A 00       .dw int_0_fdc
0131   0002 3B 00       .dw int_1
0132   0004 3C 00       .dw int_2
0133   0006 3D 00       .dw int_3
0134   0008 3E 00       .dw int_4
0135   000A 3F 00       .dw int_5
0136   000C 40 00       .dw int_6
0137   000E 8C 00       .dw int_7_uart0
0138   0010             
0139   0010             ; ------------------------------------------------------------------------------------------------------------------;
0140   0010             ; Reset Vector
0141   0010             ; ------------------------------------------------------------------------------------------------------------------;
0142   0010 80 0F       .dw kernel_reset_vector
0143   0012             
0144   0012             ; ------------------------------------------------------------------------------------------------------------------;
0145   0012             ; Exception Vector Table
0146   0012             ; Total of 7 entries, starting at address $0012
0147   0012             ; ------------------------------------------------------------------------------------------------------------------;
0148   0012 78 01       .dw trap_privilege
0149   0014 95 02       .dw trap_div_zero
0150   0016 A2 02       .dw trap_undef_opcode
0151   0018 00 00       .dw 0
0152   001A 00 00       .dw 0
0153   001C 00 00       .dw 0
0154   001E 00 00       .dw 0
0155   0020             
0156   0020             ; ------------------------------------------------------------------------------------------------------------------;
0157   0020             ; System Call Vector Table
0158   0020             ; Starts at address $0020
0159   0020             ; ------------------------------------------------------------------------------------------------------------------;
0160   0020 84 01       .dw syscall_break
0161   0022 A3 02       .dw syscall_rtc
0162   0024 DD 03       .dw syscall_ide
0163   0026 B8 04       .dw syscall_io
0164   0028 75 05       .dw syscall_file_system
0165   002A CD 0E       .dw syscall_create_proc
0166   002C 3D 01       .dw syscall_list_procs
0167   002E D5 02       .dw syscall_datetime
0168   0030 F9 00       .dw syscall_reboot
0169   0032 97 0E       .dw syscall_pause_proc
0170   0034 05 01       .dw syscall_resume_proc
0171   0036 54 0E       .dw syscall_terminate_proc
0172   0038 CB 00       .dw syscall_system
0173   003A             
0174   003A             ; ------------------------------------------------------------------------------------------------------------------;
0175   003A             ; System Call Aliases
0176   003A             ; ------------------------------------------------------------------------------------------------------------------;
0177   003A             sys_break            .equ 0
0178   003A             sys_rtc              .equ 1
0179   003A             sys_ide              .equ 2
0180   003A             sys_io               .equ 3
0181   003A             sys_filesystem       .equ 4
0182   003A             sys_create_proc      .equ 5
0183   003A             sys_list_proc        .equ 6
0184   003A             sys_datetime         .equ 7
0185   003A             sys_reboot           .equ 8
0186   003A             sys_pause_proc       .equ 9
0187   003A             sys_resume_proc      .equ 10
0188   003A             sys_terminate_proc   .equ 11
0189   003A             sys_system           .equ 12
0190   003A             
0191   003A             ; ------------------------------------------------------------------------------------------------------------------;
0192   003A             ; Alias Exports
0193   003A             ; ------------------------------------------------------------------------------------------------------------------;
0194   003A             .export text_org
0195   003A             .export sys_break
0196   003A             .export sys_rtc
0197   003A             .export sys_ide
0198   003A             .export sys_io
0199   003A             .export sys_filesystem
0200   003A             .export sys_create_proc
0201   003A             .export sys_list_proc
0202   003A             .export sys_datetime
0203   003A             .export sys_reboot
0204   003A             .export sys_pause_proc
0205   003A             .export sys_resume_proc
0206   003A             .export sys_terminate_proc
0207   003A             .export sys_system
0208   003A             
0209   003A             ; ------------------------------------------------------------------------------------------------------------------;
0210   003A             ; IRQs' Code Block
0211   003A             ; ------------------------------------------------------------------------------------------------------------------;
0212   003A             ; 5.25" Floppy Drive Controller IRQ
0213   003A             int_0_fdc:
0214   003A 06            sysret
0215   003B             int_1:
0216   003B 06            sysret
0217   003C             int_2:
0218   003C 06            sysret
0219   003D             int_3:
0220   003D 06            sysret
0221   003E             int_4:
0222   003E 06            sysret
0223   003F             int_5:
0224   003F 06            sysret
0225   0040             
0226   0040             ; ------------------------------------------------------------------------------------------------------------------;
0227   0040             ; Process Swapping
0228   0040             ; ------------------------------------------------------------------------------------------------------------------;
0229   0040             int_6:  
0230   0040 4B            pusha ; save all registers into kernel stack
0231   0041 22 00         mov ah, 0
0232   0043 1D FB 16      mov al, [active_proc_index]
0233   0046 FD 99         shl a              ; x2
0234   0048 B7 4A 0F      mov a, [proc_table_convert + a]  ; get process state start index
0235   004B 4F            mov di, a
0236   004C 48            mov a, sp
0237   004D 77            inc a
0238   004E 4D            mov si, a
0239   004F 38 14 00      mov c, 20
0240   0052 FD F5         rep movsb          ; save process state!
0241   0054             ; restore kernel stack position to point before interrupt arrived
0242   0054 51 14 00      add sp, 20
0243   0057             ; now load next process in queue
0244   0057 1D FB 16      mov al, [active_proc_index]
0245   005A 31 FA 16      mov bl, [nbr_active_procs]
0246   005D BA            cmp al, bl
0247   005E C6 65 00      je int6_cycle_back
0248   0061 7A            inc al            ; next process is next in the series
0249   0062 0A 67 00      jmp int6_continue
0250   0065             int6_cycle_back:
0251   0065 19 01         mov al, 1        ; next process = process 1
0252   0067             int6_continue:
0253   0067 3D FB 16      mov [active_proc_index], al    ; set next active proc
0254   006A             
0255   006A             ; calculate LUT entry for next process
0256   006A 22 00         mov ah, 0
0257   006C FD 99         shl a              ; x2
0258   006E B7 4A 0F      mov a, [proc_table_convert + a]    ; get process state start index  
0259   0071               
0260   0071 4D            mov si, a            ; source is proc state block
0261   0072 48            mov a, sp
0262   0073 5F 13 00      sub a, 19
0263   0076 4F            mov di, a            ; destination is kernel stack
0264   0077             ; restore SP
0265   0077 7D            dec a
0266   0078 47            mov sp, a
0267   0079 38 14 00      mov c, 20
0268   007C FD F5         rep movsb
0269   007E             ; set VM process
0270   007E 1D FB 16      mov al, [active_proc_index]
0271   0081 01            setptb
0272   0082 F2 E0 FF 00   mov byte[_TIMER_C_0], 0        ; load counter 0 low byte
0273   0086 F2 E0 FF 10   mov byte[_TIMER_C_0], $10        ; load counter 0 high byte
0274   008A 4C            popa
0275   008B 06            sysret
0276   008C             
0277   008C             ; ------------------------------------------------------------------------------------------------------------------;
0278   008C             ; UART0 Interrupt
0279   008C             ; ------------------------------------------------------------------------------------------------------------------;
0280   008C             int_7_uart0:
0281   008C D7            push a
0282   008D DA            push d
0283   008E E1            pushf
0284   008F 14 00 17      mov a, [fifo_in]
0285   0092 3C            mov d, a
0286   0093 1D 80 FF      mov al, [_UART0_DATA]  ; get character
0287   0096 B9 03         cmp al, $03        ; CTRL-C
0288   0098 C6 B5 00      je CTRLC
0289   009B B9 1A         cmp al, $1A        ; CTRL-Z
0290   009D C6 BB 00      je CTRLZ
0291   00A0 3E            mov [d], al        ; add to fifo
0292   00A1 14 00 17      mov a, [fifo_in]
0293   00A4 77            inc a
0294   00A5 AF FF 21      cmp a, fifo + FIFO_SIZE         ; check if pointer reached the end of the fifo
0295   00A8 C7 AE 00      jne int_7_continue
0296   00AB 10 FF 1D      mov a, fifo  
0297   00AE             int_7_continue:  
0298   00AE 42 00 17      mov [fifo_in], a      ; update fifo pointer
0299   00B1 EE            popf
0300   00B2 E7            pop d
0301   00B3 E4            pop a  
0302   00B4 06            sysret
0303   00B5             CTRLC:
0304   00B5 51 05 00      add sp, 5
0305   00B8 0A 54 0E      jmp syscall_terminate_proc
0306   00BB             CTRLZ:
0307   00BB EE            popf
0308   00BC E7            pop d
0309   00BD E4            pop a
0310   00BE 0A 97 0E      jmp syscall_pause_proc    ; pause current process and go back to the shell
0311   00C1             
0312   00C1             
0313   00C1             ; ------------------------------------------------------------------------------------------------------------------;
0314   00C1             ; System Syscalls
0315   00C1             ; ------------------------------------------------------------------------------------------------------------------;
0316   00C1             system_jmptbl:
0317   00C1 F7 00         .dw system_uname
0318   00C3 F8 00         .dw system_whoami
0319   00C5 F4 00         .dw system_setparam
0320   00C7 D1 00         .dw system_bootloader_install
0321   00C9 CF 00         .dw system_getparam
0322   00CB             syscall_system:
0323   00CB FD 0A C1 00   jmp [system_jmptbl + al]
0324   00CF             
0325   00CF             ; param register address in register d
0326   00CF             ; param value in register bl
0327   00CF             system_getparam:
0328   00CF 32            mov bl, [d]
0329   00D0 06            sysret
0330   00D1             
0331   00D1             ; kernel LBA address in 'b'
0332   00D1             system_bootloader_install:
0333   00D1 D8            push b
0334   00D2 26 00 00      mov b, 0
0335   00D5 38 00 00      mov c, 0
0336   00D8 22 01         mov ah, $01                 ; 1 sector
0337   00DA 3B FF 23      mov d, transient_area
0338   00DD 07 27 04      call ide_read_sect          ; read sector
0339   00E0 E5            pop b
0340   00E1 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0341   00E5 26 00 00      mov b, 0
0342   00E8 38 00 00      mov c, 0
0343   00EB 22 01         mov ah, $01                 ; 1 sector
0344   00ED 3B FF 23      mov d, transient_area
0345   00F0 07 4D 04      call ide_write_sect         ; write sector
0346   00F3 06            sysret
0347   00F4             
0348   00F4             ; param register address in register d
0349   00F4             ; param value in register bl
0350   00F4             system_setparam:
0351   00F4 FD 3E         mov [d], bl
0352   00F6 06            sysret
0353   00F7             
0354   00F7             system_uname:
0355   00F7 06            sysret
0356   00F8             
0357   00F8             system_whoami:
0358   00F8 06            sysret
0359   00F9             
0360   00F9             ; REBOOT SYSTEM
0361   00F9             syscall_reboot:
0362   00F9 FD D7 FF FF   push word $FFFF 
0363   00FD FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0364   0100 FD D7 C0 01   push word BIOS_RESET_VECTOR    ; and then push RESET VECTOR of the shell to the stack
0365   0104 06            sysret
0366   0105             
0367   0105             ;------------------------------------------------------------------------------------------------------;;
0368   0105             ; switch to another process
0369   0105             ; inputs:
0370   0105             ; AL = new process number
0371   0105             ;------------------------------------------------------------------------------------------------------;;
0372   0105             syscall_resume_proc:
0373   0105 FD 78         mov g, a                            ; save the process number
0374   0107 4B            pusha                               ; save all registers into kernel stack
0375   0108 22 00         mov ah, 0
0376   010A 1D FB 16      mov al, [active_proc_index]
0377   010D FD 99         shl a              ; x2
0378   010F B7 4A 0F      mov a, [proc_table_convert + a]     ; get process state start index
0379   0112 4F            mov di, a
0380   0113 48            mov a, sp
0381   0114 77            inc a
0382   0115 4D            mov si, a
0383   0116 38 14 00      mov c, 20
0384   0119 FD F5         rep movsb                           ; save process state!
0385   011B             ; restore kernel stack position to point before interrupt arrived
0386   011B 51 14 00      add sp, 20
0387   011E             ; now load the new process number!
0388   011E FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0389   0120 3D FB 16      mov [active_proc_index], al         ; set new active proc
0390   0123             ; calculate LUT entry for next process
0391   0123 22 00         mov ah, 0
0392   0125 FD 99         shl a                               ; x2
0393   0127 B7 4A 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0394   012A 4D            mov si, a                           ; source is proc state block
0395   012B 48            mov a, sp
0396   012C 5F 13 00      sub a, 19
0397   012F 4F            mov di, a                           ; destination is kernel stack
0398   0130             ; restore SP
0399   0130 7D            dec a
0400   0131 47            mov sp, a
0401   0132 38 14 00      mov c, 20
0402   0135 FD F5         rep movsb
0403   0137             ; set VM process
0404   0137 1D FB 16      mov al, [active_proc_index]
0405   013A 01            setptb
0406   013B 4C            popa
0407   013C 06            sysret
0408   013D             
0409   013D             syscall_list_procs:
0410   013D 3B 23 17      mov d, s_ps_header
0411   0140 07 CA 11      call _puts
0412   0143 3B 70 19      mov d, proc_availab_table + 1
0413   0146 38 01 00      mov c, 1
0414   0149             list_procs_L0:  
0415   0149 BD 01         cmp byte[d], 1
0416   014B C7 6F 01      jne list_procs_next
0417   014E 2D            mov b, d
0418   014F 61 6F 19      sub b, proc_availab_table
0419   0152 FD 9F 05      shl b, 5
0420   0155 DA            push d
0421   0156 D8            push b
0422   0157 28            mov b, c
0423   0158 07 6A 12      call print_u8x
0424   015B 22 20         mov ah, ' '
0425   015D 07 9E 10      call _putchar
0426   0160 07 9E 10      call _putchar
0427   0163 E5            pop b
0428   0164 74            mov d, b
0429   0165 58 7F 19      add d, proc_names
0430   0168 07 CA 11      call _puts
0431   016B 07 77 11      call printnl
0432   016E E7            pop d
0433   016F             list_procs_next:
0434   016F 79            inc d
0435   0170 78            inc c
0436   0171 C2 09 00      cmp c, 9
0437   0174 C7 49 01      jne list_procs_L0
0438   0177             list_procs_end:
0439   0177 06            sysret
0440   0178             
0441   0178             ; ------------------------------------------------------------------------------------------------------------------;
0442   0178             ; Exceptions' Code Block
0443   0178             ; ------------------------------------------------------------------------------------------------------------------;
0444   0178             ; Privilege
0445   0178             ; ------------------------------------------------------------------------------------------------------------------;
0446   0178             trap_privilege:
0447   0178 0A F9 00      jmp syscall_reboot
0448   017B DA            push d
0449   017C 3B 72 17      mov d, s_priviledge
0450   017F 07 CA 11      call _puts
0451   0182 E7            pop d
0452   0183 06            sysret
0453   0184             
0454   0184             ; ------------------------------------------------------------------------------------------------------------------;
0455   0184             ; Breakpoint
0456   0184             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0457   0184             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0458   0184             ; ------------------------------------------------------------------------------------------------------------------;
0459   0184             syscall_break:
0460   0184 4B            pusha
0461   0185             syscall_break_prompt:
0462   0185 3B 3F 02      mov d, s_break1
0463   0188 07 CA 11      call _puts
0464   018B 07 77 11      call printnl
0465   018E 07 CC 12      call scan_u16d
0466   0191 AF 00 00      cmp a, 0
0467   0194 C6 9F 01      je syscall_break_regs
0468   0197 AF 01 00      cmp a, 1
0469   019A C6 C2 01      je syscall_break_mem
0470   019D             syscall_break_end:  
0471   019D 4C            popa
0472   019E 06            sysret
0473   019F             syscall_break_regs:
0474   019F 48            mov a, sp
0475   01A0 53 0E 00      add a, 14               ; back-track 7 registers
0476   01A3 3C            mov d, a
0477   01A4 3A 07         mov cl, 7
0478   01A6             syscall_regs_L0:
0479   01A6 2A            mov b, [d]
0480   01A7 FD AB         swp b
0481   01A9 07 26 12      call print_u16x         ; print register value
0482   01AC 07 77 11      call printnl
0483   01AF 63 02 00      sub d, 2
0484   01B2 71 01         sub cl, 1
0485   01B4 C3 00         cmp cl, 0
0486   01B6 C7 A6 01      jne syscall_regs_L0
0487   01B9 0A 85 01      jmp syscall_break_prompt
0488   01BC 07 77 11      call printnl
0489   01BF 0A 85 01      jmp syscall_break_prompt
0490   01C2             syscall_break_mem:
0491   01C2 07 77 11      call printnl
0492   01C5 07 48 12      call scan_u16x
0493   01C8 4D            mov si, a               ; data source from user space
0494   01C9 FD 4F FF 21   mov di, scrap_sector    ; destination in kernel space
0495   01CD 38 00 02      mov c, 512
0496   01D0 04            load                    ; transfer data to kernel space!
0497   01D1 3B FF 21      mov d, scrap_sector     ; dump pointer in d
0498   01D4 38 00 00      mov c, 0
0499   01D7             dump_loop:
0500   01D7 84            mov al, cl
0501   01D8 87 0F         and al, $0F
0502   01DA C6 28 02      jz print_base
0503   01DD             back:
0504   01DD 1E            mov al, [d]             ; read byte
0505   01DE 2F            mov bl, al
0506   01DF 07 6A 12      call print_u8x
0507   01E2 10 00 20      mov a, $2000
0508   01E5 05 03         syscall sys_io          ; space
0509   01E7 84            mov al, cl
0510   01E8 87 0F         and al, $0F
0511   01EA B9 0F         cmp al, $0F
0512   01EC C6 FD 01      je print_ascii
0513   01EF             back1:
0514   01EF 79            inc d
0515   01F0 78            inc c
0516   01F1 C2 00 02      cmp c, 512
0517   01F4 C7 D7 01      jne dump_loop
0518   01F7 07 77 11      call printnl
0519   01FA 0A 85 01      jmp syscall_break_prompt  ; go to syscall_break return point
0520   01FD             print_ascii:
0521   01FD 10 00 20      mov a, $2000
0522   0200 05 03         syscall sys_io
0523   0202 63 10 00      sub d, 16
0524   0205 26 10 00      mov b, 16
0525   0208             print_ascii_L:
0526   0208 79            inc d
0527   0209 1E            mov al, [d]               ; read byte
0528   020A B9 20         cmp al, $20
0529   020C C8 14 02      jlu dot
0530   020F B9 7E         cmp al, $7E
0531   0211 D0 1C 02      jleu ascii
0532   0214             dot:
0533   0214 10 00 2E      mov a, $2E00
0534   0217 05 03         syscall sys_io
0535   0219 0A 21 02      jmp ascii_continue
0536   021C             ascii:
0537   021C 23            mov ah, al
0538   021D 19 00         mov al, 0
0539   021F 05 03         syscall sys_io
0540   0221             ascii_continue:
0541   0221 FD A9 08 02   loopb print_ascii_L
0542   0225 0A EF 01      jmp back1
0543   0228             print_base:
0544   0228 07 77 11      call printnl
0545   022B 2D            mov b, d
0546   022C 61 FF 21      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0547   022F 07 26 12      call print_u16x          ; display row
0548   0232 10 00 3A      mov a, $3A00
0549   0235 05 03         syscall sys_io
0550   0237 10 00 20      mov a, $2000
0551   023A 05 03         syscall sys_io
0552   023C 0A DD 01      jmp back
0553   023F             
0554   023F             s_break1:  
0555   023F 0A 44 65 62   .db "\nDebugger entry point.\n"
0555   0243 75 67 67 65 
0555   0247 72 20 65 6E 
0555   024B 74 72 79 20 
0555   024F 70 6F 69 6E 
0555   0253 74 2E 0A 
0556   0256 30 2E 20 53   .db "0. Show Registers\n"
0556   025A 68 6F 77 20 
0556   025E 52 65 67 69 
0556   0262 73 74 65 72 
0556   0266 73 0A 
0557   0268 31 2E 20 53   .db "1. Show 512B RAM block\n"
0557   026C 68 6F 77 20 
0557   0270 35 31 32 42 
0557   0274 20 52 41 4D 
0557   0278 20 62 6C 6F 
0557   027C 63 6B 0A 
0558   027F 32 2E 20 43   .db "2. Continue Execution", 0
0558   0283 6F 6E 74 69 
0558   0287 6E 75 65 20 
0558   028B 45 78 65 63 
0558   028F 75 74 69 6F 
0558   0293 6E 00 
0559   0295             
0560   0295             ; ------------------------------------------------------------------------------------------------------------------;
0561   0295             ; Divide by Zero
0562   0295             ; ------------------------------------------------------------------------------------------------------------------;
0563   0295             trap_div_zero:
0564   0295 D7            push a
0565   0296 DA            push d
0566   0297 E1            pushf
0567   0298 3B 89 17      mov d, s_divzero
0568   029B 07 CA 11      call _puts
0569   029E EE            popf
0570   029F E7            pop d
0571   02A0 E4            pop a
0572   02A1 06            sysret ; enable interrupts
0573   02A2             
0574   02A2             ; ------------------------------------------------------------------------------------------------------------------;
0575   02A2             ; Undefined Opcode
0576   02A2             ; ------------------------------------------------------------------------------------------------------------------;
0577   02A2             trap_undef_opcode:
0578   02A2 06            sysret
0579   02A3             
0580   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0581   02A3             ; RTC Services Syscall
0582   02A3             ; RTC I/O bank = FFA0 to FFAF
0583   02A3             ; FFA0 to FFA7 is scratch RAM
0584   02A3             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0585   02A3             ; al = 0..6 -> get
0586   02A3             ; al = 7..D -> set
0587   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0588   02A3             syscall_rtc:
0589   02A3 DB            push al
0590   02A4 DA            push d
0591   02A5 B9 06         cmp al, 6
0592   02A7 D1 BC 02      jgu syscall_rtc_set
0593   02AA             syscall_rtc_get:
0594   02AA 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0595   02AC 22 FF         mov ah, $FF    
0596   02AE 3C            mov d, a                ; get to FFA9 + offset
0597   02AF F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0598   02B3 1E            mov al, [d]             ; get data
0599   02B4 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0600   02B8 23            mov ah, al
0601   02B9 E7            pop d
0602   02BA E8            pop al
0603   02BB 06            sysret
0604   02BC             syscall_rtc_set:
0605   02BC DD            push bl
0606   02BD 99            mov bl, ah              ; set data asIDE
0607   02BE 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0608   02C0 22 FF         mov ah, $FF    
0609   02C2 3C            mov d, a                ; get to FFA9 + offset
0610   02C3 1B            mov al, bl              ; get data back
0611   02C4 F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0612   02C8 3E            mov [d], al             ; set data
0613   02C9 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0614   02CD EA            pop bl
0615   02CE E7            pop d
0616   02CF E8            pop al
0617   02D0 06            sysret
0618   02D1             
0619   02D1             datetime_serv_tbl:
0620   02D1 D9 02         .dw print_date
0621   02D3 4D 03         .dw set_date
0622   02D5             syscall_datetime:
0623   02D5 FD 0A D1 02   jmp [datetime_serv_tbl + al]      
0624   02D9             print_date:
0625   02D9 10 00 0D      mov a, $0D00           ; print carriage return char
0626   02DC 19 03         mov al, 3
0627   02DE 05 01         syscall sys_rtc        ; get week
0628   02E0 1A            mov al, ah
0629   02E1 22 00         mov ah, 0
0630   02E3 FD 9D 02      shl a, 2          
0631   02E6 3B 13 18      mov d, s_week
0632   02E9 59            add d, a
0633   02EA 07 CA 11      call _puts
0634   02ED 10 00 20      mov a, $2000
0635   02F0 05 03         syscall sys_io         ; display ' '
0636   02F2 19 04         mov al, 4
0637   02F4 05 01         syscall sys_rtc        ; get day
0638   02F6 99            mov bl, ah
0639   02F7 07 6A 12      call print_u8x
0640   02FA 10 00 20      mov a, $2000
0641   02FD 05 03         syscall sys_io         ; display ' '
0642   02FF             ; there is a problem with the month displaying
0643   02FF             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0644   02FF             ; even though it is to be understood as BCD.
0645   02FF             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0646   02FF 19 05         mov al, 05
0647   0301 05 01         syscall sys_rtc        ; get month
0648   0303 1A            mov al, ah
0649   0304 22 00         mov ah, 0
0650   0306 FD 9D 02      shl a, 2          
0651   0309 3B DF 17      mov d, s_months
0652   030C 59            add d, a
0653   030D 07 CA 11      call _puts
0654   0310 10 00 20      mov a, $2000
0655   0313 05 03         syscall sys_io         ; display ' '
0656   0315 2E 20         mov bl, $20
0657   0317 07 6A 12      call print_u8x         ; print 20 for year prefix
0658   031A 19 06         mov al, 06
0659   031C 05 01         syscall sys_rtc        ; get year
0660   031E 99            mov bl, ah
0661   031F 07 6A 12      call print_u8x
0662   0322 10 00 20      mov a, $2000  
0663   0325 05 03         syscall sys_io         ; display ' '
0664   0327 19 02         mov al, 2
0665   0329 05 01         syscall sys_rtc        ; get hours
0666   032B 99            mov bl, ah
0667   032C 07 6A 12      call print_u8x
0668   032F 10 00 3A      mov a, $3A00    
0669   0332 05 03         syscall sys_io         ; display ':'
0670   0334 19 01         mov al, 01
0671   0336 05 01         syscall sys_rtc        ; get minutes
0672   0338 99            mov bl, ah
0673   0339 07 6A 12      call print_u8x
0674   033C 10 00 3A      mov a, $3A00  
0675   033F 05 03         syscall sys_io         ; display ':'
0676   0341 19 00         mov al, 0
0677   0343 05 01         syscall sys_rtc        ; get seconds
0678   0345 99            mov bl, ah
0679   0346 07 6A 12      call print_u8x
0680   0349 07 77 11      call printnl
0681   034C 06            sysret
0682   034D             set_date:
0683   034D 3B A4 17      mov d, s_set_year
0684   0350 07 CA 11      call _puts
0685   0353 07 B5 12      call scan_u8x          ; read integer into A
0686   0356 FD 9D 08      shl a, 8               ; only AL used, move to AH
0687   0359 19 0D         mov al, 0Dh            ; set RTC year
0688   035B 05 01         syscall sys_rtc        ; set RTC
0689   035D 3B AB 17      mov d, s_set_month
0690   0360 07 CA 11      call _puts
0691   0363 07 B5 12      call scan_u8x          ; read integer into A
0692   0366 FD 9D 08      shl a, 8               ; only AL used, move to AH
0693   0369 19 0C         mov al, 0Ch            ; set RTC month
0694   036B 05 01         syscall sys_rtc        ; set RTC
0695   036D 3B B3 17      mov d, s_set_day
0696   0370 07 CA 11      call _puts
0697   0373 07 B5 12      call scan_u8x          ; read integer into A
0698   0376 FD 9D 08      shl a, 8               ; only AL used, move to AH
0699   0379 19 0B         mov al, 0Bh            ; set RTC month
0700   037B 05 01         syscall sys_rtc        ; set RTC
0701   037D 3B B9 17      mov d, s_set_week
0702   0380 07 CA 11      call _puts
0703   0383 07 B5 12      call scan_u8x          ; read integer into A
0704   0386 FD 9D 08      shl a, 8               ; only AL used, move to AH
0705   0389 19 0A         mov al, 0Ah            ; set RTC month
0706   038B 05 01         syscall sys_rtc        ; set RTC
0707   038D 3B C3 17      mov d, s_set_hours
0708   0390 07 CA 11      call _puts
0709   0393 07 B5 12      call scan_u8x          ; read integer into A
0710   0396 FD 9D 08      shl a, 8               ; only AL used, move to AH
0711   0399 19 09         mov al, 09h            ; set RTC month
0712   039B 05 01         syscall sys_rtc        ; set RTC
0713   039D 3B CB 17      mov d, s_set_minutes
0714   03A0 07 CA 11      call _puts
0715   03A3 07 B5 12      call scan_u8x          ; read integer into A
0716   03A6 FD 9D 08      shl a, 8               ; only AL used, move to AH
0717   03A9 19 08         mov al, 08h            ; set RTC month
0718   03AB 05 01         syscall sys_rtc        ; set RTC
0719   03AD 3B D5 17      mov d, s_set_seconds
0720   03B0 07 CA 11      call _puts
0721   03B3 07 B5 12      call scan_u8x          ; read integer into A
0722   03B6 FD 9D 08      shl a, 8               ; only AL used, move to AH
0723   03B9 19 07         mov al, 07h            ; set RTC month
0724   03BB 05 01         syscall sys_rtc        ; set RTC
0725   03BD 06            sysret
0726   03BE             
0727   03BE             ; ------------------------------------------------------------------------------------------------------------------;
0728   03BE             ; IDE Services Syscall
0729   03BE             ; al = option
0730   03BE             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0731   03BE             ; IDE read/write sector
0732   03BE             ; 512 bytes
0733   03BE             ; User buffer pointer in D
0734   03BE             ; AH = number of sectors
0735   03BE             ; CB = LBA bytes 3..0
0736   03BE             ; ------------------------------------------------------------------------------------------------------------------;
0737   03BE 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0737   03C2 73 63 61 6C 
0737   03C6 6C 5F 69 64 
0737   03CA 65 20 63 61 
0737   03CE 6C 6C 65 64 
0737   03D2 3A 20 00 
0738   03D5             ide_serv_tbl:
0739   03D5 FC 03         .dw ide_reset
0740   03D7 10 04         .dw ide_sleep
0741   03D9 1F 04         .dw ide_read_sect_wrapper
0742   03DB 23 04         .dw ide_write_sect_wrapper
0743   03DD             syscall_ide:
0744   03DD DD            push bl
0745   03DE 31 F3 16      mov bl, [sys_debug_mode]
0746   03E1               ; debug block
0747   03E1 C1 00         cmp bl, 0
0748   03E3 EA            pop bl
0749   03E4 C6 F8 03      je syscall_ide_jmp
0750   03E7 DA            push d
0751   03E8 DD            push bl
0752   03E9 3B BE 03      mov d, s_syscall_ide_dbg0
0753   03EC 07 CA 11      call _puts
0754   03EF 2F            mov bl, al
0755   03F0 07 6A 12      call print_u8x
0756   03F3 07 77 11      call printnl
0757   03F6 EA            pop bl
0758   03F7 E7            pop d
0759   03F8             syscall_ide_jmp:
0760   03F8 FD 0A D5 03   jmp [ide_serv_tbl + al]    
0761   03FC               
0762   03FC             ide_reset:      
0763   03FC F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0764   0400 07 A9 04      call ide_wait                   ; wait for IDE ready             
0765   0403 F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0766   0407 F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0767   040B F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0768   040F 06            sysret
0769   0410             ide_sleep:
0770   0410 07 A9 04      call ide_wait                   ; wait for IDE ready             
0771   0413 F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0772   0417 F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0773   041B 07 A9 04      call ide_wait                   ; wait for IDE ready
0774   041E 06            sysret
0775   041F             ide_read_sect_wrapper:
0776   041F 07 27 04      call ide_read_sect
0777   0422 06            sysret
0778   0423             ide_write_sect_wrapper:
0779   0423 07 4D 04      call ide_write_sect
0780   0426 06            sysret
0781   0427             ide_read_sect:
0782   0427 1A            mov al, ah
0783   0428 24            mov ah, bl
0784   0429 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0785   042C 1C            mov al, bh
0786   042D 3D D4 FF      mov [_ide_R4], al
0787   0430 12            mov a, c
0788   0431 3D D5 FF      mov [_ide_R5], al
0789   0434 1A            mov al, ah
0790   0435 87 0F         and al, %00001111
0791   0437 8B E0         or al, %11100000                ; mode lba, master
0792   0439 3D D6 FF      mov [_ide_R6], al
0793   043C             ide_read_sect_wait:
0794   043C 1D D7 FF      mov al, [_ide_R7]  
0795   043F 87 80         and al, $80                     ; BUSY FLAG
0796   0441 C7 3C 04      jnz ide_read_sect_wait
0797   0444 19 20         mov al, $20
0798   0446 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0799   0449 07 73 04      call ide_read  
0800   044C 09            ret
0801   044D             ide_write_sect:
0802   044D 1A            mov al, ah
0803   044E 24            mov ah, bl
0804   044F 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0805   0452 1C            mov al, bh
0806   0453 3D D4 FF      mov [_ide_R4], al
0807   0456 12            mov a, c
0808   0457 3D D5 FF      mov [_ide_R5], al
0809   045A 1A            mov al, ah
0810   045B 87 0F         and al, %00001111
0811   045D 8B E0         or al, %11100000                ; mode lba, master
0812   045F 3D D6 FF      mov [_ide_R6], al
0813   0462             ide_write_sect_wait:
0814   0462 1D D7 FF      mov al, [_ide_R7]  
0815   0465 87 80         and al, $80                     ; BUSY FLAG
0816   0467 C7 62 04      jnz ide_write_sect_wait
0817   046A 19 30         mov al, $30
0818   046C 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0819   046F 07 8E 04      call ide_write      
0820   0472 09            ret
0821   0473             
0822   0473             ;----------------------------------------------------------------------------------------------------;
0823   0473             ; READ IDE DATA
0824   0473             ; pointer in D
0825   0473             ;----------------------------------------------------------------------------------------------------;
0826   0473             ide_read:
0827   0473 DA            push d
0828   0474             ide_read_loop:
0829   0474 1D D7 FF      mov al, [_ide_R7]  
0830   0477 87 80         and al, 80h                     ; BUSY FLAG
0831   0479 C7 74 04      jnz ide_read_loop               ; wait loop
0832   047C 1D D7 FF      mov al, [_ide_R7]
0833   047F 87 08         and al, %00001000               ; DRQ FLAG
0834   0481 C6 8C 04      jz ide_read_end
0835   0484 1D D0 FF      mov al, [_ide_R0]
0836   0487 3E            mov [d], al
0837   0488 79            inc d
0838   0489 0A 74 04      jmp ide_read_loop
0839   048C             ide_read_end:
0840   048C E7            pop d
0841   048D 09            ret
0842   048E             
0843   048E             ;----------------------------------------------------------------------------------------------------;
0844   048E             ; WRITE IDE DATA
0845   048E             ; data pointer in D
0846   048E             ;----------------------------------------------------------------------------------------------------;
0847   048E             ide_write:
0848   048E DA            push d
0849   048F             ide_write_loop:
0850   048F 1D D7 FF      mov al, [_ide_R7]  
0851   0492 87 80         and al, 80h             ; BUSY FLAG
0852   0494 C7 8F 04      jnz ide_write_loop      ; wait loop
0853   0497 1D D7 FF      mov al, [_ide_R7]
0854   049A 87 08         and al, %00001000       ; DRQ FLAG
0855   049C C6 A7 04      jz ide_write_end
0856   049F 1E            mov al, [d]
0857   04A0 3D D0 FF      mov [_ide_R0], al
0858   04A3 79            inc d 
0859   04A4 0A 8F 04      jmp ide_write_loop
0860   04A7             ide_write_end:
0861   04A7 E7            pop d
0862   04A8 09            ret
0863   04A9             
0864   04A9             ;----------------------------------------------------------------------------------------------------;
0865   04A9             ; wait for IDE to be ready
0866   04A9             ;----------------------------------------------------------------------------------------------------;
0867   04A9             ide_wait:
0868   04A9 1D D7 FF      mov al, [_ide_R7]  
0869   04AC 87 80         and al, 80h        ; BUSY FLAG
0870   04AE C7 A9 04      jnz ide_wait
0871   04B1 09            ret
0872   04B2             
0873   04B2             ;----------------------------------------------------------------------------------------------------;
0874   04B2             ; IO Syscall
0875   04B2             ;----------------------------------------------------------------------------------------------------;
0876   04B2             ; Baud  Divisor
0877   04B2             ; 50    2304
0878   04B2             ; 110   1047
0879   04B2             ; 300    384
0880   04B2             ; 600    192
0881   04B2             ; 1200    96
0882   04B2             ; 9600    12
0883   04B2             ; 19200    6
0884   04B2             ; 38400    3
0885   04B2             syscall_io_jmp:
0886   04B2 E5 04         .dw syscall_io_putchar
0887   04B4 F2 04         .dw syscall_io_getch
0888   04B6 BC 04         .dw syscall_io_uart_setup
0889   04B8             syscall_io:
0890   04B8 FD 0A B2 04   jmp [syscall_io_jmp + al]
0891   04BC             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0892   04BC             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0893   04BC             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0894   04BC             syscall_io_uart_setup:
0895   04BC 1D F5 16      mov al, [sys_uart0_lcr]
0896   04BF 8B 80         or al, $80                ; set DLAB access bit
0897   04C1 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0898   04C4 1D F8 16      mov al, [sys_uart0_div0]
0899   04C7 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0900   04CA 1D F9 16      mov al, [sys_uart0_div1]
0901   04CD 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0902   04D0             
0903   04D0 1D F5 16      mov al, [sys_uart0_lcr]
0904   04D3 87 7F         and al, $7F               ; clear DLAB access bit 
0905   04D5 3D 83 FF      mov [_UART0_LCR], al
0906   04D8 1D F6 16      mov al, [sys_uart0_inten]
0907   04DB 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0908   04DE 1D F7 16      mov al, [sys_uart0_fifoen]
0909   04E1 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0910   04E4 06            sysret
0911   04E5             
0912   04E5             ; char in ah
0913   04E5             syscall_io_putchar:
0914   04E5             syscall_io_putchar_L0:
0915   04E5 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0916   04E8 87 20         and al, $20
0917   04EA C6 E5 04      jz syscall_io_putchar_L0    
0918   04ED 1A            mov al, ah
0919   04EE 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0920   04F1 06            sysret
0921   04F2             
0922   04F2             ; char in ah
0923   04F2             ; al = sucess code
0924   04F2             syscall_io_getch:
0925   04F2 D8            push b
0926   04F3 DA            push d
0927   04F4 FD 0C         sti
0928   04F6             syscall_io_getch_L0:  
0929   04F6 14 02 17      mov a, [fifo_out]
0930   04F9 29 00 17      mov b, [fifo_in]
0931   04FC B0            cmp a, b
0932   04FD C6 F6 04      je syscall_io_getch_L0
0933   0500 3C            mov d, a
0934   0501 77            inc a
0935   0502 AF FF 21      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
0936   0505 C7 0B 05      jne syscall_io_getch_cont
0937   0508 10 FF 1D      mov a, fifo  
0938   050B             syscall_io_getch_cont:  
0939   050B 42 02 17      mov [fifo_out], a             ; update fifo pointer
0940   050E 1E            mov al, [d]                   ; get char
0941   050F 23            mov ah, al
0942   0510 1D F4 16      mov al, [sys_echo_on]
0943   0513 B9 01         cmp al, 1
0944   0515 C7 24 05      jne syscall_io_getch_noecho 
0945   0518             ; here we just echo the char back to the console
0946   0518             syscall_io_getch_echo_L0:
0947   0518 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0948   051B 87 20         and al, $20                 ; isolate Transmitter Empty
0949   051D C6 18 05      jz syscall_io_getch_echo_L0
0950   0520 1A            mov al, ah
0951   0521 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0952   0524             syscall_io_getch_noecho:
0953   0524 19 01         mov al, 1                    ; AL = 1 means a char successfully received
0954   0526 E7            pop d
0955   0527 E5            pop b
0956   0528 06            sysret
0957   0529             
0958   0529             ;------------------------------------------------------------------------------------------------------;
0959   0529             ; FILE SYSTEM DATA
0960   0529             ;------------------------------------------------------------------------------------------------------;
0961   0529             ; infor for : IDE SERVICES INTERRUPT
0962   0529             ; IDE read/write 512-byte sector
0963   0529             ; al = option
0964   0529             ; user buffer pointer in D
0965   0529             ; AH = number of sectors
0966   0529             ; CB = LBA bytes 3..0  
0967   0529             ;------------------------------------------------------------------------------------------------------;
0968   0529             ; FILE SYSTEM DATA STRUCTURE
0969   0529             ;------------------------------------------------------------------------------------------------------;
0970   0529             ; for a directory we have the header first, followed by metadata
0971   0529             ; header 1 sector (512 bytes)
0972   0529             ; metadata 1 sector (512 bytes)
0973   0529             ; HEADER ENTRIES:
0974   0529             ; filename (64)
0975   0529             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0976   0529             ;
0977   0529             ; metadata entries:
0978   0529             ; filename (24)
0979   0529             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
0980   0529             ; LBA (2)
0981   0529             ; size (2)
0982   0529             ; day (1)
0983   0529             ; month (1)
0984   0529             ; year (1)
0985   0529             ; packet size = 32 bytes
0986   0529             ;
0987   0529             ; first directory on disk is the root directory '/'
0988   0529             file_system_jmptbl:
0989   0529 94 05         .dw fs_mkfs                   ; 0
0990   052B 00 00         .dw 0                         ; 1
0991   052D F6 05         .dw fs_mkdir                  ; 2
0992   052F 6F 09         .dw fs_cd                     ; 3
0993   0531 76 09         .dw fs_ls                     ; 4
0994   0533 EC 0A         .dw fs_mktxt                  ; 5
0995   0535 B7 0B         .dw fs_mkbin                  ; 6
0996   0537 7E 0C         .dw fs_pwd                    ; 7
0997   0539 9B 0C         .dw fs_cat                    ; 8
0998   053B F7 0C         .dw fs_rmdir                  ; 9
0999   053D 53 0D         .dw fs_rm                     ; 10
1000   053F 47 0A         .dw fs_starcom                ; 11
1001   0541 00 00         .dw 0                         ; 12
1002   0543 00 00         .dw 0                         ; 13
1003   0545 9C 05         .dw fs_chmod                  ; 14
1004   0547 BB 0D         .dw fs_mv                     ; 15
1005   0549 95 05         .dw fs_cd_root                ; 16
1006   054B 6B 09         .dw fs_get_curr_dirID         ; 17
1007   054D 47 07         .dw fs_dir_id_to_path         ; 18
1008   054F AD 07         .dw fs_path_to_dir_id_user    ; 19
1009   0551 C7 08         .dw fs_load_from_path_user    ; 20  
1010   0553 37 08         .dw fs_filepath_exists_user   ; 21
1011   0555             
1012   0555 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1012   0559 79 73 63 61 
1012   055D 6C 6C 5F 66 
1012   0561 69 6C 65 5F 
1012   0565 73 79 73 74 
1012   0569 65 6D 20 63 
1012   056D 61 6C 6C 65 
1012   0571 64 3A 20 00 
1013   0575             syscall_file_system:
1014   0575 DD            push bl
1015   0576 31 F3 16      mov bl, [sys_debug_mode]
1016   0579               ; debug block
1017   0579 C1 00         cmp bl, 0
1018   057B EA            pop bl
1019   057C C6 90 05      je syscall_filesystem_jmp
1020   057F DA            push d
1021   0580 DD            push bl
1022   0581 3B 55 05      mov d, s_syscall_fs_dbg0
1023   0584 07 CA 11      call _puts
1024   0587 2F            mov bl, al
1025   0588 07 6A 12      call print_u8x
1026   058B 07 77 11      call printnl
1027   058E EA            pop bl
1028   058F E7            pop d
1029   0590             syscall_filesystem_jmp:
1030   0590 FD 0A 29 05   jmp [file_system_jmptbl + al]
1031   0594             
1032   0594             fs_mkfs:  
1033   0594 06            sysret  
1034   0595               
1035   0595             fs_cd_root:
1036   0595 10 20 00      mov a, root_id
1037   0598 42 04 17      mov [current_dir_id], a      ; set current directory LBA to ROOT
1038   059B 06            sysret  
1039   059C             
1040   059C             ; filename in D (userspace data)
1041   059C             ; permission in BL
1042   059C             fs_chmod:
1043   059C DD            push bl
1044   059D FD 4E         mov si, d
1045   059F FD 4F FF 1B   mov di, user_data
1046   05A3 38 80 00      mov c, 128
1047   05A6 04            load                        ; load filename from user-space
1048   05A7 14 04 17      mov a, [current_dir_id]
1049   05AA 77            inc a                       ; metadata sector
1050   05AB 27            mov b, a
1051   05AC 38 00 00      mov c, 0                    ; upper LBA = 0
1052   05AF 22 01         mov ah, $01                  ; 1 sector
1053   05B1 3B FF 23      mov d, transient_area
1054   05B4 07 27 04      call ide_read_sect          ; read directory
1055   05B7 FD 10         cla
1056   05B9 42 FC 16      mov [index], a              ; reset file counter
1057   05BC             fs_chmod_L1:
1058   05BC FD 4E         mov si, d
1059   05BE FD 4F FF 1B   mov di, user_data
1060   05C2 07 0D 10      call _strcmp
1061   05C5 C6 DC 05      je fs_chmod_found_entry
1062   05C8 58 20 00      add d, 32
1063   05CB 14 FC 16      mov a, [index]
1064   05CE 77            inc a
1065   05CF 42 FC 16      mov [index], a
1066   05D2 AF 10 00      cmp a, FST_FILES_PER_DIR
1067   05D5 C7 BC 05      jne fs_chmod_L1
1068   05D8 EA            pop bl
1069   05D9 0A F5 05      jmp fs_chmod_not_found
1070   05DC             fs_chmod_found_entry:  
1071   05DC FD 79         mov g, b                    ; save LBA
1072   05DE EA            pop bl                      ; retrieve saved permission value
1073   05DF 1F 18 00      mov al, [d + 24]            ; read file permissions
1074   05E2 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1075   05E4 8C            or al, bl                   ; set new permissions
1076   05E5 3F 18 00      mov [d + 24], al            ; write new permissions
1077   05E8 38 00 00      mov c, 0
1078   05EB 3B FF 23      mov d, transient_area
1079   05EE 22 01         mov ah, $01                 ; disk write 1 sect
1080   05F0 FD 27         mov b, g                    ; retrieve LBA
1081   05F2 07 4D 04      call ide_write_sect         ; write sector
1082   05F5             fs_chmod_not_found:
1083   05F5 06            sysret
1084   05F6             
1085   05F6             ;------------------------------------------------------------------------------------------------------;
1086   05F6             ; CREATE NEW DIRECTORY
1087   05F6             ;------------------------------------------------------------------------------------------------------;
1088   05F6             ; search list for NULL name entry. add new directory to list
1089   05F6             fs_mkdir:
1090   05F6 FD 4E         mov si, d
1091   05F8 FD 4F FF 1B   mov di, user_data
1092   05FC 38 00 02      mov c, 512
1093   05FF 04            load                        ; load data from user-space
1094   0600 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1095   0603                                           ; when checking for NULL name, since root has a NULL name)
1096   0603 38 00 00      mov c, 0                    ; upper LBA = 0
1097   0606             fs_mkdir_L1:  
1098   0606 22 01         mov ah, $01                  ; 1 sector
1099   0608 3B FF 23      mov d, transient_area
1100   060B 07 27 04      call ide_read_sect          ; read sector
1101   060E BD 00         cmp byte[d], 0              ; check for NULL
1102   0610 C6 19 06      je fs_mkdir_found_null
1103   0613 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1104   0616 0A 06 06      jmp fs_mkdir_L1
1105   0619             fs_mkdir_found_null:
1106   0619             ;create header file by grabbing dir name from parameter
1107   0619 D8            push b                      ; save new directory's LBA
1108   061A 38 40 00      mov c, 64
1109   061D FD 4D FF 1B   mov si, user_data
1110   0621 FD 4F FF 23   mov di, transient_area
1111   0625 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1112   0627 14 04 17      mov a, [current_dir_id]
1113   062A 42 3F 24      mov [transient_area + 64], a    ; store parent directory LBA
1114   062D 19 00         mov al, 0
1115   062F FD 4F FF 25   mov di, transient_area + 512
1116   0633 38 00 02      mov c, 512
1117   0636 FD F7         rep stosb                       ; clean buffer
1118   0638 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1119   063B             ; write directory entry sectors
1120   063B 3B FF 23      mov d, transient_area
1121   063E 22 02         mov ah, $02                     ; disk write, 2 sectors
1122   0640 07 4D 04      call ide_write_sect             ; write sector
1123   0643             ; now we need to add the new directory to the list, insIDE the current directory
1124   0643 14 04 17      mov a, [current_dir_id]
1125   0646 53 01 00      add a, 1
1126   0649 27            mov b, a                        ; metadata sector
1127   064A 38 00 00      mov c, 0
1128   064D FD 79         mov g, b                        ; save LBA
1129   064F 3B FF 23      mov d, transient_area
1130   0652 22 01         mov ah, $01                  ; 1 sector
1131   0654 07 27 04      call ide_read_sect              ; read metadata sector
1132   0657             fs_mkdir_L2:
1133   0657 BD 00         cmp byte[d], 0
1134   0659 C6 62 06      je fs_mkdir_found_null2
1135   065C 58 20 00      add d, FST_ENTRY_SIZE
1136   065F 0A 57 06      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1137   0662             fs_mkdir_found_null2:
1138   0662 FD 4D FF 1B   mov si, user_data
1139   0666 FD 50         mov di, d
1140   0668 07 22 10      call _strcpy                    ; copy directory name
1141   066B 58 18 00      add d, 24                       ; goto ATTRIBUTES
1142   066E 19 0B         mov al, %00001011               ; directory, no execute, write, read
1143   0670 3E            mov [d], al      
1144   0671 79            inc d
1145   0672 E5            pop b
1146   0673 D8            push b                          ; push LBA back
1147   0674 FD 43         mov [d], b                      ; save LBA
1148   0676             ; set file creation date  
1149   0676 58 04 00      add d, 4
1150   0679 19 04         mov al, 4
1151   067B 05 01         syscall sys_rtc
1152   067D 1A            mov al, ah
1153   067E 3E            mov [d], al                     ; set day
1154   067F 79            inc d
1155   0680 19 05         mov al, 5
1156   0682 05 01         syscall sys_rtc
1157   0684 1A            mov al, ah
1158   0685 3E            mov [d], al                     ; set month
1159   0686 79            inc d
1160   0687 19 06         mov al, 6
1161   0689 05 01         syscall sys_rtc
1162   068B 1A            mov al, ah
1163   068C 3E            mov [d], al                     ; set year
1164   068D             ; write sector into disk for new directory entry
1165   068D FD 27         mov b, g
1166   068F 38 00 00      mov c, 0
1167   0692 3B FF 23      mov d, transient_area
1168   0695 22 01         mov ah, $01                     ; disk write, 1 sector
1169   0697 07 4D 04      call ide_write_sect             ; write sector
1170   069A             
1171   069A             ; after adding the new directory's information to its parent directory's list
1172   069A             ; we need to now enter the new directory, and to it add two new directories!
1173   069A             ; which directories do we need to add ? '..' and '.' are the directories needed.
1174   069A             ; importantly, note that these two new directories are only entries in the list
1175   069A             ; and do not have actual physical entries in the disk as real directories.
1176   069A             ; i.e. they only exist as list entries in the new directory created so that
1177   069A             ; the new directory can reference its parent and itself.
1178   069A             ; We need to add both '..' and '.'
1179   069A             ; this first section is for '..' and on the section below we do the same for '.'
1180   069A E4            pop a                         ; retrieve the new directory's LBA  
1181   069B D7            push a                        ; and save again
1182   069C 53 01 00      add a, 1
1183   069F 27            mov b, a                      ; metadata sector
1184   06A0 38 00 00      mov c, 0
1185   06A3 FD 79         mov g, b                      ; save LBA
1186   06A5 3B FF 23      mov d, transient_area
1187   06A8 22 01         mov ah, $01                  ; 1 sector
1188   06AA 07 27 04      call ide_read_sect            ; read metadata sector
1189   06AD             fs_mkdir_L3:
1190   06AD BD 00         cmp byte[d], 0
1191   06AF C6 B8 06      je fs_mkdir_found_null3
1192   06B2 58 20 00      add d, FST_ENTRY_SIZE
1193   06B5 0A AD 06      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1194   06B8             fs_mkdir_found_null3:
1195   06B8 FD 4D 14 17   mov si, s_parent_dir
1196   06BC FD 50         mov di, d
1197   06BE 07 22 10      call _strcpy                  ; copy directory name
1198   06C1 58 18 00      add d, 24                     ; goto ATTRIBUTES
1199   06C4 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1200   06C6 3E            mov [d], al      
1201   06C7 79            inc d
1202   06C8 29 04 17      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1203   06CB FD 43         mov [d], b                    ; save LBA
1204   06CD             ; set file creation date  
1205   06CD 58 04 00      add d, 4
1206   06D0 19 04         mov al, 4
1207   06D2 05 01         syscall sys_rtc
1208   06D4 1A            mov al, ah
1209   06D5 3E            mov [d], al                   ; set day
1210   06D6 79            inc d
1211   06D7 19 05         mov al, 5
1212   06D9 05 01         syscall sys_rtc
1213   06DB 1A            mov al, ah
1214   06DC 3E            mov [d], al                   ; set month
1215   06DD 79            inc d
1216   06DE 19 06         mov al, 6
1217   06E0 05 01         syscall sys_rtc
1218   06E2 1A            mov al, ah
1219   06E3 3E            mov [d], al                   ; set year
1220   06E4             ; write sector into disk for new directory entry
1221   06E4 FD 27         mov b, g
1222   06E6 38 00 00      mov c, 0
1223   06E9 3B FF 23      mov d, transient_area
1224   06EC 22 01         mov ah, $01                   ; disk write, 1 sector
1225   06EE 07 4D 04      call ide_write_sect           ; write sector
1226   06F1             ;;;;;;;;;;;;;
1227   06F1             ; like we did above for '..', we need to now add the '.' directory to the list.
1228   06F1             ;------------------------------------------------------------------------------------------------------;
1229   06F1 E4            pop a                         ; retrieve the new directory's LBA  
1230   06F2 D7            push a
1231   06F3 53 01 00      add a, 1
1232   06F6 27            mov b, a                      ; metadata sector
1233   06F7 38 00 00      mov c, 0
1234   06FA FD 79         mov g, b                      ; save LBA
1235   06FC 3B FF 23      mov d, transient_area
1236   06FF 22 01         mov ah, $01                  ; 1 sector
1237   0701 07 27 04      call ide_read_sect            ; read metadata sector
1238   0704             fs_mkdir_L4:
1239   0704 BD 00         cmp byte[d], 0
1240   0706 C6 0F 07      je fs_mkdir_found_null4
1241   0709 58 20 00      add d, FST_ENTRY_SIZE
1242   070C 0A 04 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1243   070F             fs_mkdir_found_null4:
1244   070F FD 4D 17 17   mov si, s_current_dir
1245   0713 FD 50         mov di, d
1246   0715 07 22 10      call _strcpy                  ; copy directory name
1247   0718 58 18 00      add d, 24                     ; goto ATTRIBUTES
1248   071B 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1249   071D 3E            mov [d], al      
1250   071E 79            inc d
1251   071F E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1252   0720 FD 43         mov [d], b                    ; save LBA
1253   0722             ; set file creation date  
1254   0722 58 04 00      add d, 4
1255   0725 19 04         mov al, 4
1256   0727 05 01         syscall sys_rtc
1257   0729 1A            mov al, ah
1258   072A 3E            mov [d], al                   ; set day
1259   072B 79            inc d
1260   072C 19 05         mov al, 5
1261   072E 05 01         syscall sys_rtc
1262   0730 1A            mov al, ah
1263   0731 3E            mov [d], al                   ; set month
1264   0732 79            inc d
1265   0733 19 06         mov al, 6
1266   0735 05 01         syscall sys_rtc
1267   0737 1A            mov al, ah
1268   0738 3E            mov [d], al                   ; set year
1269   0739             ; write sector into disk for new directory entry
1270   0739 FD 27         mov b, g
1271   073B 38 00 00      mov c, 0
1272   073E 3B FF 23      mov d, transient_area
1273   0741 22 01         mov ah, $01                   ; disk write, 1 sector
1274   0743 07 4D 04      call ide_write_sect           ; write sector
1275   0746             fs_mkdir_end:
1276   0746 06            sysret
1277   0747             
1278   0747             ;------------------------------------------------------------------------------------------------------;
1279   0747             ; get path from a given directory dirID
1280   0747             ; pseudo code:
1281   0747             ;  fs_dir_id_to_path(int dirID, char *D){
1282   0747             ;    if(dirID == 0){
1283   0747             ;      reverse path in D;
1284   0747             ;      return;
1285   0747             ;    }
1286   0747             ;    else{
1287   0747             ;      copy directory name to end of D;
1288   0747             ;      add '/' to end of D;
1289   0747             ;      parentID = get parent directory ID;
1290   0747             ;      fs_dir_id_to_path(parentID, D);
1291   0747             ;    }
1292   0747             ;  }
1293   0747             ; A = dirID
1294   0747             ; D = generated path string pointer
1295   0747             ;------------------------------------------------------------------------------------------------------;
1296   0747             ; sample path: /usr/bin
1297   0747             fs_dir_id_to_path:
1298   0747 3B 7F 1B      mov d, filename
1299   074A 19 00         mov al, 0
1300   074C 3E            mov [d], al                     ; initialize path string 
1301   074D 14 04 17      mov a, [current_dir_id]
1302   0750 07 5D 07      call fs_dir_id_to_path_E0
1303   0753 3B 7F 1B      mov d, filename
1304   0756 07 B6 0F      call _strrev
1305   0759 07 CA 11      call _puts
1306   075C 06            sysret
1307   075D             fs_dir_id_to_path_E0:
1308   075D 07 7C 07      call get_dirname_from_dirID
1309   0760 FD 4D 19 17   mov si, s_fslash
1310   0764 FD 50         mov di, d
1311   0766 07 30 10      call _strcat                    ; add '/' to end of path
1312   0769 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1313   076C C6 7B 07      je fs_dir_id_to_path_root
1314   076F 07 99 07      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1315   0772 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1316   0775 C6 7B 07      je fs_dir_id_to_path_root
1317   0778 07 5D 07      call fs_dir_id_to_path_E0     ; recursively call itself
1318   077B             fs_dir_id_to_path_root:
1319   077B 09            ret
1320   077C             
1321   077C             ;------------------------------------------------------------------------------------------------------;
1322   077C             ; in_puts:
1323   077C             ; A = directory ID
1324   077C             ; out_puts:
1325   077C             ; D = pointer to directory name string
1326   077C             ;------------------------------------------------------------------------------------------------------;
1327   077C             get_dirname_from_dirID:
1328   077C D7            push a
1329   077D D8            push b
1330   077E DA            push d
1331   077F 27            mov b, a
1332   0780 38 00 00      mov c, 0                      ; upper LBA = 0
1333   0783 22 01         mov ah, $01                  ; 1 sector
1334   0785 3B FF 21      mov d, transient_area - 512
1335   0788 07 27 04      call ide_read_sect            ; read directory
1336   078B 07 B6 0F      call _strrev                  ; reverse dir name before copying
1337   078E FD 4E         mov si, d
1338   0790 E7            pop d                         ; destination address = D value pushed at beginning
1339   0791 FD 50         mov di, d
1340   0793 07 30 10      call _strcat                  ; copy filename to D
1341   0796 E5            pop b
1342   0797 E4            pop a
1343   0798 09            ret
1344   0799             
1345   0799             ;------------------------------------------------------------------------------------------------------;
1346   0799             ; in_puts:
1347   0799             ; A = directory ID
1348   0799             ; out_puts:
1349   0799             ; A = parent directory ID
1350   0799             ;------------------------------------------------------------------------------------------------------;
1351   0799             get_parentID_from_dirID:
1352   0799 D8            push b
1353   079A DA            push d
1354   079B 27            mov b, a
1355   079C 38 00 00      mov c, 0                      ; upper LBA = 0
1356   079F 22 01         mov ah, $01                  ; 1 sector
1357   07A1 3B FF 21      mov d, transient_area - 512
1358   07A4 07 27 04      call ide_read_sect            ; read directory
1359   07A7 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1360   07AA E7            pop d
1361   07AB E5            pop b
1362   07AC 09            ret
1363   07AD             
1364   07AD             ;------------------------------------------------------------------------------------------------------;
1365   07AD             ; get dirID from a given path string
1366   07AD             ; in_puts:
1367   07AD             ; D = path pointer 
1368   07AD             ; out_puts:
1369   07AD             ; A = dirID
1370   07AD             ; if dir non existent, A = FFFF (fail code)
1371   07AD             ; /usr/local/bin    - absolute
1372   07AD             ; local/bin/games    - relative
1373   07AD             ;------------------------------------------------------------------------------------------------------;
1374   07AD             fs_path_to_dir_id_user:
1375   07AD FD 4E         mov si, d
1376   07AF FD 4F FF 1B   mov di, user_data
1377   07B3 38 00 02      mov c, 512
1378   07B6 04            load
1379   07B7 07 BB 07      call get_dirID_from_path
1380   07BA 06            sysret
1381   07BB             get_dirID_from_path:
1382   07BB 26 FF 1B      mov b, user_data
1383   07BE FD 42 EF 15   mov [prog], b                  ; token pointer set to path string
1384   07C2 07 50 14      call get_token
1385   07C5 31 F2 15      mov bl, [tok]
1386   07C8 C1 01         cmp bl, TOK_FSLASH
1387   07CA C6 D6 07      je get_dirID_from_path_abs 
1388   07CD 14 04 17      mov a, [current_dir_id]
1389   07D0 07 D6 15      call _putback
1390   07D3 0A D9 07      jmp get_dirID_from_path_E0
1391   07D6             get_dirID_from_path_abs:
1392   07D6 10 20 00      mov a, root_id
1393   07D9             get_dirID_from_path_E0:
1394   07D9 07 50 14      call get_token
1395   07DC 31 F1 15      mov bl, [toktyp]
1396   07DF C1 00         cmp bl, TOKTYP_IDENTIFIER
1397   07E1 C7 32 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1398   07E4             
1399   07E4 FD 4D F3 15   mov si, tokstr
1400   07E8 FD 4F 7F 1B   mov di, filename
1401   07EC 07 22 10      call _strcpy        
1402   07EF 77            inc a                         ; metadata sector
1403   07F0 27            mov b, a
1404   07F1 38 00 00      mov c, 0                      ; upper LBA = 0
1405   07F4 22 01         mov ah, $01                  ; 1 sector
1406   07F6 3B FF 23      mov d, transient_area
1407   07F9 07 27 04      call ide_read_sect            ; read directory
1408   07FC FD 10         cla
1409   07FE 42 FC 16      mov [index], a
1410   0801             get_dirID_from_path_L1:
1411   0801 FD 4E         mov si, d
1412   0803 FD 4F 7F 1B   mov di, filename
1413   0807 07 0D 10      call _strcmp
1414   080A C6 20 08      je get_dirID_from_path_name_equal  
1415   080D 58 20 00      add d, 32
1416   0810 14 FC 16      mov a, [index]
1417   0813 77            inc a
1418   0814 42 FC 16      mov [index], a
1419   0817 AF 10 00      cmp a, FST_FILES_PER_DIR
1420   081A C6 33 08      je get_dirID_from_path_fail
1421   081D 0A 01 08      jmp get_dirID_from_path_L1
1422   0820             get_dirID_from_path_name_equal:
1423   0820 58 19 00      add d, 25           
1424   0823 15            mov a, [d]                    ; set result register A = dirID
1425   0824 07 50 14      call get_token
1426   0827 31 F2 15      mov bl, [tok]
1427   082A C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1428   082C C6 D9 07      je get_dirID_from_path_E0
1429   082F 07 D6 15      call _putback
1430   0832             get_dirID_from_path_end:
1431   0832 09            ret
1432   0833             get_dirID_from_path_fail:
1433   0833 10 FF FF      mov A, $FFFF
1434   0836 09            ret
1435   0837             
1436   0837             
1437   0837             ;------------------------------------------------------------------------------------------------------;
1438   0837             ; check if file exists by a given path string
1439   0837             ; in_puts:
1440   0837             ; D = path pointer 
1441   0837             ; OUTPUTS:
1442   0837             ; A = success code, if file exists gives LBA, else, give 0
1443   0837             ; /usr/local/bin/ed
1444   0837             ;------------------------------------------------------------------------------------------------------;
1445   0837             fs_filepath_exists_user:
1446   0837 FD 4E         mov si, d
1447   0839 FD 4F FF 1B   mov di, user_data
1448   083D 38 00 02      mov c, 512
1449   0840 04            load
1450   0841 07 45 08      call file_exists_by_path
1451   0844 06            sysret
1452   0845             file_exists_by_path:
1453   0845 26 FF 1B      mov b, user_data
1454   0848 FD 42 EF 15   mov [prog], b                   ; token pointer set to path string
1455   084C 07 50 14      call get_token
1456   084F 31 F2 15      mov bl, [tok]
1457   0852 C1 01         cmp bl, TOK_FSLASH
1458   0854 C6 60 08      je  file_exists_by_path_abs
1459   0857 14 04 17      mov a, [current_dir_id]
1460   085A 07 D6 15      call _putback
1461   085D 0A 63 08      jmp file_exists_by_path_E0
1462   0860             file_exists_by_path_abs:
1463   0860 10 20 00      mov a, root_id
1464   0863             file_exists_by_path_E0:
1465   0863 07 50 14      call get_token
1466   0866 31 F1 15      mov bl, [toktyp]
1467   0869 C1 00         cmp bl, TOKTYP_IDENTIFIER
1468   086B C7 C3 08      jne file_exists_by_path_end     ; check if there are tokens after '/'
1469   086E FD 4D F3 15   mov si, tokstr
1470   0872 FD 4F 7F 1B   mov di, filename
1471   0876 07 22 10      call _strcpy        
1472   0879 77            inc a                           ; metadata sector
1473   087A 27            mov b, a
1474   087B 38 00 00      mov c, 0                        ; upper LBA = 0
1475   087E 22 01         mov ah, $01                  ; 1 sector
1476   0880 3B FF 23      mov d, transient_area
1477   0883 07 27 04      call ide_read_sect              ; read directory
1478   0886 FD 10         cla
1479   0888 42 FC 16      mov [index], a
1480   088B             file_exists_by_path_L1:
1481   088B FD 4E         mov si, d
1482   088D FD 4F 7F 1B   mov di, filename
1483   0891 07 0D 10      call _strcmp
1484   0894 C6 AA 08      je   file_exists_by_path_name_equal
1485   0897 58 20 00      add d, 32
1486   089A 14 FC 16      mov a, [index]
1487   089D 77            inc a
1488   089E 42 FC 16      mov [index], a
1489   08A1 AF 10 00      cmp a, FST_FILES_PER_DIR
1490   08A4 C6 C3 08      je file_exists_by_path_end
1491   08A7 0A 8B 08      jmp file_exists_by_path_L1
1492   08AA             file_exists_by_path_name_equal:
1493   08AA 33 18 00      mov bl, [d + 24]
1494   08AD FD 87 38      and bl, %00111000               ; directory flag
1495   08B0 C1 08         cmp bl, %00001000               ; is dir?
1496   08B2 C6 B9 08      je file_exists_by_path_isdir;
1497   08B5             ; entry is a file
1498   08B5 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1499   08B8 09            ret
1500   08B9             file_exists_by_path_isdir:
1501   08B9 58 19 00      add d, 25           
1502   08BC 15            mov a, [d]                      ; set result register A = dirID
1503   08BD 07 50 14      call get_token
1504   08C0 0A 63 08      jmp file_exists_by_path_E0
1505   08C3             file_exists_by_path_end:
1506   08C3 10 00 00      mov a, 0                        ; return 0 because file was not found
1507   08C6 09            ret
1508   08C7             
1509   08C7             ;------------------------------------------------------------------------------------------------------;
1510   08C7             ; load file data from a given path string
1511   08C7             ; inputs:
1512   08C7             ; D = path pointer 
1513   08C7             ; DI = userspace program data destination
1514   08C7             ; /usr/local/bin/ed
1515   08C7             ; ./ed
1516   08C7             ;------------------------------------------------------------------------------------------------------;
1517   08C7             fs_load_from_path_user:
1518   08C7 E3            push di
1519   08C8 FD 4E         mov si, d
1520   08CA FD 4F FF 1B   mov di, user_data
1521   08CE 38 00 02      mov c, 512
1522   08D1 04            load
1523   08D2 07 DF 08      call loadfile_from_path
1524   08D5 F0            pop di
1525   08D6 FD 4D FF 23   mov si, transient_area
1526   08DA 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1527   08DD 03            store
1528   08DE 06            sysret
1529   08DF             loadfile_from_path:
1530   08DF 26 FF 1B      mov b, user_data
1531   08E2 FD 42 EF 15   mov [prog], b                 ; token pointer set to path string
1532   08E6 07 50 14      call get_token
1533   08E9 31 F2 15      mov bl, [tok]
1534   08EC C1 01         cmp bl, TOK_FSLASH
1535   08EE C6 FA 08      je loadfile_from_path_abs 
1536   08F1 14 04 17      mov a, [current_dir_id]
1537   08F4 07 D6 15      call _putback
1538   08F7 0A FD 08      jmp loadfile_from_path_E0
1539   08FA             loadfile_from_path_abs:
1540   08FA 10 20 00      mov a, root_id
1541   08FD             loadfile_from_path_E0:
1542   08FD 07 50 14      call get_token
1543   0900 31 F1 15      mov bl, [toktyp]
1544   0903 C1 00         cmp bl, TOKTYP_IDENTIFIER
1545   0905 C7 6A 09      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1546   0908 FD 4D F3 15   mov si, tokstr
1547   090C FD 4F 7F 1B   mov di, filename
1548   0910 07 22 10      call _strcpy        
1549   0913 77            inc a                         ; metadata sector
1550   0914 27            mov b, a
1551   0915 38 00 00      mov c, 0                      ; upper LBA = 0
1552   0918 22 01         mov ah, $01                  ; 1 sector
1553   091A 3B FF 23      mov d, transient_area
1554   091D 07 27 04      call ide_read_sect            ; read directory
1555   0920 FD 10         cla
1556   0922 42 FC 16      mov [index], a
1557   0925             loadfile_from_path_L1:
1558   0925 FD 4E         mov si, d
1559   0927 FD 4F 7F 1B   mov di, filename
1560   092B 07 0D 10      call _strcmp
1561   092E C6 44 09      je loadfile_from_path_name_equal  
1562   0931 58 20 00      add d, 32
1563   0934 14 FC 16      mov a, [index]
1564   0937 77            inc a
1565   0938 42 FC 16      mov [index], a
1566   093B AF 10 00      cmp a, FST_FILES_PER_DIR
1567   093E C6 6A 09      je loadfile_from_path_end
1568   0941 0A 25 09      jmp loadfile_from_path_L1
1569   0944             loadfile_from_path_name_equal:
1570   0944 33 18 00      mov bl, [d + 24]
1571   0947 FD 87 38      and bl, %00111000             ; directory flag
1572   094A C1 08         cmp bl, %00001000             ; is dir?
1573   094C C6 60 09      je loadfile_isdirectory  
1574   094F             ; entry is a file
1575   094F 2B 19 00      mov b, [d + 25]               ; get LBA
1576   0952 FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1577   0954 3B FF 23      mov d, transient_area
1578   0957 38 00 00      mov c, 0
1579   095A 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1580   095C 07 27 04      call ide_read_sect            ; read sector
1581   095F 09            ret
1582   0960             loadfile_isdirectory:
1583   0960 58 19 00      add d, 25           
1584   0963 15            mov a, [d]                    ; set result register A = dirID
1585   0964 07 50 14      call get_token
1586   0967 0A FD 08      jmp loadfile_from_path_E0
1587   096A             loadfile_from_path_end:
1588   096A 09            ret
1589   096B             
1590   096B             ;------------------------------------------------------------------------------------------------------;
1591   096B             ; return the ID of the current directory
1592   096B             ; ID returned in B
1593   096B             ;------------------------------------------------------------------------------------------------------;
1594   096B             fs_get_curr_dirID:
1595   096B 29 04 17      mov b, [current_dir_id]
1596   096E 06            sysret
1597   096F             
1598   096F             ;------------------------------------------------------------------------------------------------------;
1599   096F             ; CD
1600   096F             ;------------------------------------------------------------------------------------------------------;
1601   096F             ; new dirID in B
1602   096F             fs_cd:
1603   096F FD 42 04 17   mov [current_dir_id], b
1604   0973 06            sysret  
1605   0974             
1606   0974             ;------------------------------------------------------------------------------------------------------;
1607   0974             ; LS
1608   0974             ; dirID in B
1609   0974             ;------------------------------------------------------------------------------------------------------;
1610   0974 00 00       ls_count:       .dw 0
1611   0976             fs_ls:
1612   0976 FD 77         inc b                        ; metadata sector
1613   0978 38 00 00      mov c, 0                     ; upper LBA = 0
1614   097B 22 01         mov ah, $01                  ; 1 sector
1615   097D 3B FF 23      mov d, transient_area
1616   0980 07 27 04      call ide_read_sect           ; read directory
1617   0983 FD 10         cla
1618   0985 42 FC 16      mov [index], a               ; reset entry index
1619   0988 3D 74 09      mov [ls_count], al           ; reset item count
1620   098B             fs_ls_L1:
1621   098B BD 00         cmp byte [d], 0              ; check for NULL
1622   098D C6 24 0A      je fs_ls_next
1623   0990             fs_ls_non_null:
1624   0990 1D 74 09      mov al, [ls_count]
1625   0993 7A            inc al
1626   0994 3D 74 09      mov [ls_count], al           ; increment item count
1627   0997 1F 18 00      mov al, [d + 24]
1628   099A 87 38         and al, %00111000
1629   099C FD A2 03      shr al, 3
1630   099F 22 00         mov ah, 0                    ; file type
1631   09A1 B7 20 17      mov a, [a + file_type]      
1632   09A4 23            mov ah, al
1633   09A5 07 9E 10      call _putchar
1634   09A8 1F 18 00      mov al, [d + 24]
1635   09AB 87 01         and al, %00000001
1636   09AD 22 00         mov ah, 0
1637   09AF B7 1B 17      mov a, [a + file_attrib]     ; read
1638   09B2 23            mov ah, al
1639   09B3 07 9E 10      call _putchar
1640   09B6 1F 18 00      mov al, [d + 24]
1641   09B9 87 02         and al, %00000010
1642   09BB 22 00         mov ah, 0
1643   09BD B7 1B 17      mov a, [a + file_attrib]     ; write
1644   09C0 23            mov ah, al
1645   09C1 07 9E 10      call _putchar
1646   09C4 1F 18 00      mov al, [d + 24]
1647   09C7 87 04         and al, %00000100
1648   09C9 22 00         mov ah, 0
1649   09CB B7 1B 17      mov a, [a + file_attrib]     ; execute
1650   09CE 23            mov ah, al
1651   09CF 07 9E 10      call _putchar
1652   09D2 22 20         mov ah, $20
1653   09D4 07 9E 10      call _putchar  
1654   09D7 2B 1B 00      mov b, [d + 27]
1655   09DA 07 26 12      call print_u16x              ; filesize
1656   09DD 22 20         mov ah, $20
1657   09DF 07 9E 10      call _putchar  
1658   09E2 2B 19 00      mov b, [d + 25]
1659   09E5 07 26 12      call print_u16x              ; dirID / LBA
1660   09E8 22 20         mov ah, $20
1661   09EA 07 9E 10      call _putchar
1662   09ED             ; print date
1663   09ED 33 1D 00      mov bl, [d + 29]             ; day
1664   09F0 07 6A 12      call print_u8x
1665   09F3 22 20         mov ah, $20
1666   09F5 07 9E 10      call _putchar  
1667   09F8 1F 1E 00      mov al, [d + 30]             ; month
1668   09FB FD 9E 02      shl al, 2
1669   09FE DA            push d
1670   09FF 3B DF 17      mov d, s_months
1671   0A02 22 00         mov ah, 0
1672   0A04 59            add d, a
1673   0A05 07 CA 11      call _puts
1674   0A08 E7            pop d
1675   0A09 22 20         mov ah, $20
1676   0A0B 07 9E 10      call _putchar
1677   0A0E 2E 20         mov bl, $20
1678   0A10 07 6A 12      call print_u8x
1679   0A13 33 1F 00      mov bl, [d + 31]             ; year
1680   0A16 07 6A 12      call print_u8x  
1681   0A19 22 20         mov ah, $20
1682   0A1B 07 9E 10      call _putchar  
1683   0A1E 07 CA 11      call _puts                   ; print filename  
1684   0A21 07 77 11      call printnl
1685   0A24             fs_ls_next:
1686   0A24 14 FC 16      mov a, [index]
1687   0A27 77            inc a
1688   0A28 42 FC 16      mov [index], a
1689   0A2B AF 10 00      cmp a, FST_FILES_PER_DIR
1690   0A2E C6 37 0A      je fs_ls_end
1691   0A31 58 20 00      add d, 32      
1692   0A34 0A 8B 09      jmp fs_ls_L1  
1693   0A37             fs_ls_end:
1694   0A37 3B 30 17      mov d, s_ls_total
1695   0A3A 07 CA 11      call _puts
1696   0A3D 1D 74 09      mov al, [ls_count]
1697   0A40 07 7C 12      call print_u8d
1698   0A43 07 77 11      call printnl
1699   0A46 06            sysret
1700   0A47             
1701   0A47             
1702   0A47             ; file structure:
1703   0A47             ; 512 bytes header
1704   0A47             ; header used to tell whether the block is free
1705   0A47             ;------------------------------------------------------------------------------------------------------;
1706   0A47             ; CREATE NEW TEXTFILE
1707   0A47             ;------------------------------------------------------------------------------------------------------;
1708   0A47             ; d = content pointer in user space
1709   0A47             ; c = file size
1710   0A47             fs_starcom:
1711   0A47 FD 4E       	mov si, d
1712   0A49 FD 4F FF 23 	mov di, transient_area
1713   0A4D 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1714   0A50 04          	load					; load data from user-space
1715   0A51 07 D2 0A    	call fs_find_empty_block	; look for empty data blocks
1716   0A54 D8          	push b				; save empty block LBA
1717   0A55 FD 79         mov g, b
1718   0A57             ;create header file by grabbing file name from parameter	
1719   0A57 3B FF 25    	mov d, transient_area + 512			; pointer to file contents
1720   0A5A D9          	push c							; save length
1721   0A5B 19 01       	mov al, 1
1722   0A5D 3D FF 23    	mov [transient_area], al					; mark sectors as USED (not NULL)
1723   0A60 3B FF 23    	mov d, transient_area
1724   0A63 12            mov a, c
1725   0A64 26 00 02      mov b, 512
1726   0A67 AE            div a, b
1727   0A68 FD 77         inc b         ; inc b as the division will most likely have a remainder
1728   0A6A 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1729   0A6B 38 00 00    	mov c, 0      ; lba 
1730   0A6E FD 27         mov b, g      ; lba 
1731   0A70 07 4D 04    	call ide_write_sect			; write sectors
1732   0A73             ; now we add the file to the current directory!
1733   0A73             fs_starcom_add_to_dir:	
1734   0A73 14 04 17    	mov a, [current_dir_id]
1735   0A76 77          	inc a
1736   0A77 27          	mov b, a					; metadata sector
1737   0A78 38 00 00    	mov c, 0
1738   0A7B FD 79       	mov g, b					; save LBA
1739   0A7D 3B FF 21    	mov d, scrap_sector
1740   0A80 22 01       	mov ah, $01			  ; 1 sector
1741   0A82 07 27 04    	call ide_read_sect		; read metadata sector
1742   0A85             fs_starcom_add_to_dir_L2:
1743   0A85 BD 00       	cmp byte[d], 0
1744   0A87 C6 90 0A    	je fs_starcom_add_to_dir_null
1745   0A8A 58 20 00    	add d, FST_ENTRY_SIZE
1746   0A8D 0A 85 0A    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1747   0A90             fs_starcom_add_to_dir_null:
1748   0A90 FD 4D 00 24 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1749   0A94 FD 50       	mov di, d
1750   0A96 07 22 10    	call _strcpy			; copy file name
1751   0A99 58 18 00    	add d, 24			; skip name
1752   0A9C 19 07       	mov al, %00000111	; type=file, execute, write, read
1753   0A9E 3E          	mov [d], al			
1754   0A9F 58 03 00    	add d, 3
1755   0AA2 E4          	pop a
1756   0AA3 5F 00 02      sub a, 512
1757   0AA6 43          	mov [d], a ; file size
1758   0AA7 63 02 00    	sub d, 2
1759   0AAA E5          	pop b				; get file LBA
1760   0AAB FD 43       	mov [d], b			; save LBA	
1761   0AAD             ; set file creation date	
1762   0AAD 58 04 00    	add d, 4
1763   0AB0 19 04       	mov al, 4
1764   0AB2 05 01       	syscall sys_rtc
1765   0AB4 1A          	mov al, ah
1766   0AB5 3E          	mov [d], al			; set day
1767   0AB6 79          	inc d
1768   0AB7 19 05       	mov al, 5
1769   0AB9 05 01       	syscall sys_rtc
1770   0ABB 1A          	mov al, ah
1771   0ABC 3E          	mov [d], al			; set month
1772   0ABD 79          	inc d
1773   0ABE 19 06       	mov al, 6
1774   0AC0 05 01       	syscall sys_rtc
1775   0AC2 1A          	mov al, ah
1776   0AC3 3E          	mov [d], al			; set year
1777   0AC4             ; write sector into disk for new directory entry
1778   0AC4 FD 27       	mov b, g
1779   0AC6 38 00 00    	mov c, 0
1780   0AC9 3B FF 21    	mov d, scrap_sector
1781   0ACC 22 01       	mov ah, $01			; disk write, 1 sector
1782   0ACE 07 4D 04    	call ide_write_sect		; write sector
1783   0AD1 06          	sysret
1784   0AD2             
1785   0AD2             ;------------------------------------------------------------------------------------------------------;
1786   0AD2             ; finds an empty data block
1787   0AD2             ; block LBA returned in B
1788   0AD2             ;------------------------------------------------------------------------------------------------------;
1789   0AD2             fs_find_empty_block:
1790   0AD2 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1791   0AD5 38 00 00      mov c, 0                ; upper LBA = 0
1792   0AD8             fs_find_empty_block_L1:  
1793   0AD8 22 01         mov ah, $01                  ; 1 sector
1794   0ADA 3B FF 21      mov d, transient_area - 512
1795   0ADD 07 27 04      call ide_read_sect      ; read sector
1796   0AE0 BD 00         cmp byte [d], 0
1797   0AE2 C6 EB 0A      je fs_find_empty_block_found_null
1798   0AE5 55 20 00      add b, FS_SECTORS_PER_FILE
1799   0AE8 0A D8 0A      jmp fs_find_empty_block_L1
1800   0AEB             fs_find_empty_block_found_null:
1801   0AEB 09            ret
1802   0AEC             
1803   0AEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1804   0AEC             ;; CREATE NEW TEXTFILE
1805   0AEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1806   0AEC             ; search for first null block
1807   0AEC             fs_mktxt:
1808   0AEC FD 4E       	mov si, d
1809   0AEE FD 4F FF 1B 	mov di, user_data
1810   0AF2 38 00 01    	mov c, 256
1811   0AF5 04          	load					; load data from user-space
1812   0AF6             	
1813   0AF6 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1814   0AF9 38 00 00    	mov c, 0						; reset LBA to 0
1815   0AFC             fs_mktxt_L1:	
1816   0AFC 10 02 01    	mov a, $0102			; disk read
1817   0AFF 3B FF 23    	mov d, transient_area
1818   0B02 05 02       	syscall sys_ide ; read sector
1819   0B04 1E          	mov al, [d]
1820   0B05 B9 00       	cmp al, 0			; check for NULL
1821   0B07 C6 10 0B    	je fs_mktxt_found_null
1822   0B0A 55 20 00    	add b, FS_SECTORS_PER_FILE
1823   0B0D 0A FC 0A    	jmp fs_mktxt_L1
1824   0B10             fs_mktxt_found_null:
1825   0B10 D8          	push b				; save LBA
1826   0B11             ;create header file by grabbing file name from parameter	
1827   0B11 3B 11 17    	mov d, s_dataentry
1828   0B14 07 CA 11    	call _puts
1829   0B17 3B FF 25    	mov d, transient_area + 512			; pointer to file contents
1830   0B1A 07 30 11    	call _gettxt
1831   0B1D 07 FD 0F    	call _strlen						; get length of file
1832   0B20 D9          	push c							; save length
1833   0B21 19 01       	mov al, 1
1834   0B23 3D FF 23    	mov [transient_area], al					; mark sectors as USED (not NULL)
1835   0B26 10 00 00    	mov a, 0
1836   0B29 42 FC 16    	mov [index], a
1837   0B2C 3B FF 23    	mov d, transient_area
1838   0B2F 13          	mov a, d
1839   0B30 42 FE 16    	mov [buffer_addr], a
1840   0B33             fs_mktxt_L2:
1841   0B33 38 00 00    	mov c, 0
1842   0B36 10 03 01    	mov a, $0103			; disk write, 1 sector
1843   0B39 05 02       	syscall sys_ide		; write sector
1844   0B3B 14 FC 16    	mov a, [index]
1845   0B3E 77          	inc a
1846   0B3F 42 FC 16    	mov [index], a
1847   0B42 AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1848   0B45 C6 57 0B    	je fs_mktxt_add_to_dir
1849   0B48 FD 77       	inc b
1850   0B4A 14 FE 16    	mov a, [buffer_addr]
1851   0B4D 53 00 02    	add a, 512
1852   0B50 42 FE 16    	mov [buffer_addr], a
1853   0B53 3C          	mov d, a
1854   0B54 0A 33 0B    	jmp fs_mktxt_L2
1855   0B57             ; now we add the file to the current directory!
1856   0B57             fs_mktxt_add_to_dir:	
1857   0B57 14 04 17    	mov a, [current_dir_id]
1858   0B5A 77          	inc a
1859   0B5B 27          	mov b, a					; metadata sector
1860   0B5C 38 00 00    	mov c, 0
1861   0B5F FD 79       	mov g, b					; save LBA
1862   0B61 3B FF 23    	mov d, transient_area
1863   0B64 10 02 01    	mov a, $0102			; disk read
1864   0B67 05 02       	syscall sys_ide		; read metadata sector
1865   0B69             fs_mktxt_add_to_dir_L2:
1866   0B69 1E          	mov al, [d]
1867   0B6A B9 00       	cmp al, 0
1868   0B6C C6 75 0B    	je fs_mktxt_add_to_dir_null
1869   0B6F 58 20 00    	add d, FST_ENTRY_SIZE
1870   0B72 0A 69 0B    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1871   0B75             fs_mktxt_add_to_dir_null:
1872   0B75 FD 4D FF 1B 	mov si, user_data
1873   0B79 FD 50       	mov di, d
1874   0B7B 07 22 10    	call _strcpy			; copy file name
1875   0B7E 58 18 00    	add d, 24			; skip name
1876   0B81 19 06       	mov al, %00000110		; no execute, write, read, not directory
1877   0B83 3E          	mov [d], al			
1878   0B84 58 03 00    	add d, 3
1879   0B87 E4          	pop a
1880   0B88 43          	mov [d], a
1881   0B89 63 02 00    	sub d, 2
1882   0B8C E5          	pop b				; get file LBA
1883   0B8D FD 43       	mov [d], b			; save LBA	
1884   0B8F             	
1885   0B8F             	; set file creation date	
1886   0B8F 58 04 00    	add d, 4
1887   0B92 19 04       	mov al, 4
1888   0B94 05 01       	syscall sys_rtc
1889   0B96 1A          	mov al, ah
1890   0B97 3E          	mov [d], al			; set day
1891   0B98             	
1892   0B98 79          	inc d
1893   0B99 19 05       	mov al, 5
1894   0B9B 05 01       	syscall sys_rtc
1895   0B9D 1A          	mov al, ah
1896   0B9E 3E          	mov [d], al			; set month
1897   0B9F             	
1898   0B9F 79          	inc d
1899   0BA0 19 06       	mov al, 6
1900   0BA2 05 01       	syscall sys_rtc
1901   0BA4 1A          	mov al, ah
1902   0BA5 3E          	mov [d], al			; set year
1903   0BA6             	
1904   0BA6             ; write sector into disk for new directory entry
1905   0BA6 FD 27       	mov b, g
1906   0BA8 38 00 00    	mov c, 0
1907   0BAB 3B FF 23    	mov d, transient_area
1908   0BAE 10 03 01    	mov a, $0103			; disk write, 1 sector
1909   0BB1 05 02       	syscall sys_ide		; write sector
1910   0BB3 07 77 11    	call printnl
1911   0BB6 06          	sysret
1912   0BB7             
1913   0BB7             
1914   0BB7             
1915   0BB7             ;------------------------------------------------------------------------------------------------------;
1916   0BB7             ; CREATE NEW BINARY FILE
1917   0BB7             ;------------------------------------------------------------------------------------------------------;
1918   0BB7             ; search for first null block
1919   0BB7             fs_mkbin:
1920   0BB7 19 00         mov al, 0
1921   0BB9 3D F4 16      mov [sys_echo_on], al ; disable echo
1922   0BBC FD 4E         mov si, d
1923   0BBE FD 4F FF 1B   mov di, user_data
1924   0BC2 38 00 02      mov c, 512
1925   0BC5 04            load                          ; load data from user-space
1926   0BC6 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
1927   0BC9 38 00 00      mov c, 0                      ; upper LBA = 0
1928   0BCC             fs_mkbin_L1:  
1929   0BCC 22 01         mov ah, $01                  ; 1 sector
1930   0BCE 3B FF 23      mov d, transient_area
1931   0BD1 07 27 04      call ide_read_sect            ; read sector
1932   0BD4 BD 00         cmp byte[d], 0                ; check for NULL
1933   0BD6 C6 DF 0B      je fs_mkbin_found_null
1934   0BD9 55 20 00      add b, FS_SECTORS_PER_FILE
1935   0BDC 0A CC 0B      jmp fs_mkbin_L1
1936   0BDF             fs_mkbin_found_null:
1937   0BDF D8            push b                        ; save LBA
1938   0BE0             ;create header file by grabbing file name from parameter
1939   0BE0 FD 4F FF 25   mov di, transient_area + 512  ; pointer to file contents
1940   0BE4 07 5A 0F      call _load_hex                ; load binary hex
1941   0BE7 D9            push c                        ; save size (nbr of bytes)
1942   0BE8 19 01         mov al, 1
1943   0BEA 3D FF 23      mov [transient_area], al      ; mark sectors as USED (not NULL)
1944   0BED FD 10         cla
1945   0BEF 42 FC 16      mov [index], a
1946   0BF2 3B FF 23      mov d, transient_area
1947   0BF5 13            mov a, d
1948   0BF6 42 FE 16      mov [buffer_addr], a
1949   0BF9             fs_mkbin_L2:
1950   0BF9 38 00 00      mov c, 0
1951   0BFC 22 01         mov ah, $01                   ; disk write, 1 sector
1952   0BFE 07 4D 04      call ide_write_sect           ; write sector
1953   0C01 14 FC 16      mov a, [index]
1954   0C04 77            inc a
1955   0C05 42 FC 16      mov [index], a
1956   0C08 AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
1957   0C0B C6 1D 0C      je fs_mkbin_add_to_dir
1958   0C0E FD 77         inc b
1959   0C10 14 FE 16      mov a, [buffer_addr]
1960   0C13 53 00 02      add a, 512
1961   0C16 42 FE 16      mov [buffer_addr], a
1962   0C19 3C            mov d, a
1963   0C1A 0A F9 0B      jmp fs_mkbin_L2
1964   0C1D             ; now we add the file to the current directory!
1965   0C1D             fs_mkbin_add_to_dir:  
1966   0C1D 14 04 17      mov a, [current_dir_id]
1967   0C20 77            inc a
1968   0C21 27            mov b, a                      ; metadata sector
1969   0C22 38 00 00      mov c, 0
1970   0C25 FD 79         mov g, b                      ; save LBA
1971   0C27 3B FF 23      mov d, transient_area
1972   0C2A 22 01         mov ah, $01                  ; 1 sector
1973   0C2C 07 27 04      call ide_read_sect            ; read metadata sector
1974   0C2F             fs_mkbin_add_to_dir_L2:
1975   0C2F BD 00         cmp byte[d], 0
1976   0C31 C6 3A 0C      je fs_mkbin_add_to_dir_null
1977   0C34 58 20 00      add d, FST_ENTRY_SIZE
1978   0C37 0A 2F 0C      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1979   0C3A             fs_mkbin_add_to_dir_null:
1980   0C3A FD 4D FF 1B   mov si, user_data
1981   0C3E FD 50         mov di, d
1982   0C40 07 22 10      call _strcpy                  ; copy file name
1983   0C43 58 18 00      add d, 24                     ; skip name
1984   0C46 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
1985   0C48 3E            mov [d], al
1986   0C49 58 03 00      add d, 3
1987   0C4C E4            pop a
1988   0C4D 43            mov [d], a
1989   0C4E 63 02 00      sub d, 2
1990   0C51 E5            pop b                         ; get file LBA
1991   0C52 FD 43         mov [d], b                    ; save LBA
1992   0C54               ; set file creation date  
1993   0C54 58 04 00      add d, 4
1994   0C57 19 04         mov al, 4
1995   0C59 05 01         syscall sys_rtc
1996   0C5B 1A            mov al, ah
1997   0C5C 3E            mov [d], al                   ; set day
1998   0C5D 79            inc d
1999   0C5E 19 05         mov al, 5
2000   0C60 05 01         syscall sys_rtc
2001   0C62 1A            mov al, ah
2002   0C63 3E            mov [d], al                   ; set month
2003   0C64 79            inc d
2004   0C65 19 06         mov al, 6
2005   0C67 05 01         syscall sys_rtc
2006   0C69 1A            mov al, ah
2007   0C6A 3E            mov [d], al                   ; set year
2008   0C6B             ; write sector into disk for new directory entry
2009   0C6B FD 27         mov b, g
2010   0C6D 38 00 00      mov c, 0
2011   0C70 3B FF 23      mov d, transient_area
2012   0C73 22 01         mov ah, $01                   ; disk write, 1 sector
2013   0C75 07 4D 04      call ide_write_sect           ; write sector
2014   0C78 19 01         mov al, 1
2015   0C7A 3D F4 16      mov [sys_echo_on], al ; enable echo
2016   0C7D 06            sysret
2017   0C7E             
2018   0C7E             ;------------------------------------------------------------------------------------------------------;
2019   0C7E             ; PWD - PRINT WORKING DIRECTORY
2020   0C7E             ;------------------------------------------------------------------------------------------------------;    
2021   0C7E             fs_pwd:
2022   0C7E 3B 7F 1B      mov d, filename
2023   0C81 19 00         mov al, 0
2024   0C83 3E            mov [d], al                   ; initialize path string 
2025   0C84 14 04 17      mov a, [current_dir_id]
2026   0C87 07 5D 07      call fs_dir_id_to_path_E0
2027   0C8A 3B 7F 1B      mov d, filename
2028   0C8D 07 B6 0F      call _strrev
2029   0C90 07 CA 11      call _puts
2030   0C93 07 77 11      call printnl
2031   0C96 06            sysret
2032   0C97             
2033   0C97             ;------------------------------------------------------------------------------------------------------;
2034   0C97             ; get current directory LBA
2035   0C97             ; A: returned LBA
2036   0C97             ;------------------------------------------------------------------------------------------------------;
2037   0C97             cmd_get_curr_dir_LBA:
2038   0C97 14 04 17      mov a, [current_dir_id]
2039   0C9A 06            sysret
2040   0C9B             
2041   0C9B             ;------------------------------------------------------------------------------------------------------;
2042   0C9B             ; CAT
2043   0C9B             ; userspace destination data pointer in D
2044   0C9B             ; filename starts at D, but is overwritten after the read is made
2045   0C9B             ;------------------------------------------------------------------------------------------------------;:
2046   0C9B             fs_cat:
2047   0C9B DA            push d                              ; save userspace file data destination
2048   0C9C FD 4E         mov si, d
2049   0C9E FD 4F FF 1B   mov di, user_data
2050   0CA2 38 00 02      mov c, 512
2051   0CA5 04            load                                ; copy filename from user-space
2052   0CA6 29 04 17      mov b, [current_dir_id]
2053   0CA9 FD 77         inc b                               ; metadata sector
2054   0CAB 38 00 00      mov c, 0                            ; upper LBA = 0
2055   0CAE 22 01         mov ah, $01                  ; 1 sector
2056   0CB0 3B FF 21      mov d, transient_area-512
2057   0CB3 07 27 04      call ide_read_sect                  ; read directory
2058   0CB6 FD 10         cla
2059   0CB8 42 FC 16      mov [index], a                      ; reset file counter
2060   0CBB             fs_cat_L1:
2061   0CBB FD 4E         mov si, d
2062   0CBD FD 4F FF 1B   mov di, user_data
2063   0CC1 07 0D 10      call _strcmp
2064   0CC4 C6 DA 0C      je fs_cat_found_entry
2065   0CC7 58 20 00      add d, 32
2066   0CCA 14 FC 16      mov a, [index]
2067   0CCD 77            inc a
2068   0CCE 42 FC 16      mov [index], a
2069   0CD1 AF 10 00      cmp a, FST_FILES_PER_DIR
2070   0CD4 C6 F5 0C      je fs_cat_not_found
2071   0CD7 0A BB 0C      jmp fs_cat_L1
2072   0CDA             fs_cat_found_entry:
2073   0CDA 58 19 00      add d, 25                           ; get to dirID of file in disk
2074   0CDD 2A            mov b, [d]                          ; get LBA
2075   0CDE FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2076   0CE0 3B FF 23      mov d, transient_area  
2077   0CE3 38 00 00      mov c, 0
2078   0CE6 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2079   0CE8 07 27 04      call ide_read_sect                  ; read sectors
2080   0CEB F0            pop di                              ; write userspace file data destination to DI
2081   0CEC FD 4D FF 23   mov si, transient_area              ; data origin
2082   0CF0 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2083   0CF3 03            store
2084   0CF4 06            sysret
2085   0CF5             fs_cat_not_found:
2086   0CF5 E7            pop d
2087   0CF6 06            sysret
2088   0CF7             
2089   0CF7             ;------------------------------------------------------------------------------------------------------;
2090   0CF7             ; RMDIR - remove DIR by dirID
2091   0CF7             ;------------------------------------------------------------------------------------------------------;
2092   0CF7             ; deletes a directory entry in the given directory's file list 
2093   0CF7             ; also deletes the actual directory entry in the FST
2094   0CF7             ; synopsis: rmdir /usr/local/testdir
2095   0CF7             ; B = dirID
2096   0CF7             fs_rmdir:
2097   0CF7 FD 79         mov g, b
2098   0CF9 11            mov a, b
2099   0CFA 07 99 07      call get_parentID_from_dirID  ; now get the directory's parent, in A
2100   0CFD D7            push a                        ; save dirID
2101   0CFE             ; search for directory's entry in the parent's directory then and delete it
2102   0CFE 77            inc a                         ; metadata sector
2103   0CFF 27            mov b, a
2104   0D00 38 00 00      mov c, 0                      ; upper LBA = 0
2105   0D03 22 01         mov ah, $01          ;
2106   0D05 3B FF 23      mov d, transient_area
2107   0D08 07 27 04      call ide_read_sect            ; read directory
2108   0D0B FD 10         cla
2109   0D0D 42 FC 16      mov [index], a                ; reset file counter
2110   0D10 FD 27         mov b, g                      ; retrieve directory's dirID
2111   0D12             fs_rmdir_L1:
2112   0D12 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2113   0D15 B0            cmp a, b                      ; compare dirID's to find the directory
2114   0D16 C6 2C 0D      je fs_rmdir_found_entry
2115   0D19 58 20 00      add d, 32
2116   0D1C 14 FC 16      mov a, [index]
2117   0D1F 77            inc a
2118   0D20 42 FC 16      mov [index], a
2119   0D23 AF 10 00      cmp a, FST_FILES_PER_DIR
2120   0D26 C6 51 0D      je fs_rmdir_not_found
2121   0D29 0A 12 0D      jmp fs_rmdir_L1
2122   0D2C             fs_rmdir_found_entry:
2123   0D2C FD 10         cla
2124   0D2E 3E            mov [d], al                   ; make filename NULL
2125   0D2F 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2126   0D32 E5            pop b
2127   0D33 FD 77         inc b                         ; metadata sector
2128   0D35 38 00 00      mov c, 0                      ; upper LBA = 0
2129   0D38 22 01         mov ah, $01          ; 
2130   0D3A 3B FF 23      mov d, transient_area
2131   0D3D 07 4D 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2132   0D40             
2133   0D40 FD 27         mov b, g
2134   0D42 3B FF 23      mov d, transient_area  
2135   0D45 FD 10         cla
2136   0D47 3E            mov [d], al                   ; make directory's name header NULL for re-use
2137   0D48 38 00 00      mov c, 0
2138   0D4B 22 01         mov ah, $01                   ; disk write 1 sect
2139   0D4D 07 4D 04      call ide_write_sect           ; delete directory given by dirID in B
2140   0D50 06            sysret
2141   0D51             fs_rmdir_not_found:
2142   0D51 E5            pop b
2143   0D52 06            sysret
2144   0D53             
2145   0D53             ;------------------------------------------------------------------------------------------------------;
2146   0D53             ; RM - remove file
2147   0D53             ;------------------------------------------------------------------------------------------------------;
2148   0D53             ; frees up the data sectors for the file further down the disk
2149   0D53             ; deletes file entry in the directory's file list 
2150   0D53             fs_rm:
2151   0D53 FD 4E         mov si, d
2152   0D55 FD 4F FF 1B   mov di, user_data
2153   0D59 38 00 02      mov c, 512
2154   0D5C 04            load                          ; load data from user-space
2155   0D5D 14 04 17      mov a, [current_dir_id]
2156   0D60 77            inc a                         ; metadata sector
2157   0D61 27            mov b, a
2158   0D62 38 00 00      mov c, 0                      ; upper LBA = 0
2159   0D65 22 01         mov ah, $01                  ; 1 sector
2160   0D67 3B FF 23      mov d, transient_area
2161   0D6A 07 27 04      call ide_read_sect            ; read directory
2162   0D6D 10 00 00      mov a, 0
2163   0D70 42 FC 16      mov [index], a                ; reset file counter
2164   0D73             fs_rm_L1:
2165   0D73 FD 4E         mov si, d
2166   0D75 FD 4F FF 1B   mov di, user_data
2167   0D79 07 0D 10      call _strcmp
2168   0D7C C6 92 0D      je fs_rm_found_entry
2169   0D7F 58 20 00      add d, 32
2170   0D82 14 FC 16      mov a, [index]
2171   0D85 77            inc a
2172   0D86 42 FC 16      mov [index], a
2173   0D89 AF 10 00      cmp a, FST_FILES_PER_DIR
2174   0D8C C6 BA 0D      je fs_rm_not_found
2175   0D8F 0A 73 0D      jmp fs_rm_L1
2176   0D92             fs_rm_found_entry:
2177   0D92 2B 19 00      mov b, [d + 25]               ; get LBA
2178   0D95 FD 79         mov g, b                      ; save LBA
2179   0D97 19 00         mov al, 0
2180   0D99 3E            mov [d], al                   ; make file entry NULL
2181   0D9A 14 04 17      mov a, [current_dir_id]
2182   0D9D 77            inc a                         ; metadata sector
2183   0D9E 27            mov b, a
2184   0D9F 38 00 00      mov c, 0                      ; upper LBA = 0
2185   0DA2 22 01         mov ah, $01                   ; disk write
2186   0DA4 3B FF 23      mov d, transient_area
2187   0DA7 07 4D 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2188   0DAA 3B FF 23      mov d, transient_area  
2189   0DAD 19 00         mov al, 0
2190   0DAF 3E            mov [d], al                   ; make file's data header NULL for re-use
2191   0DB0 38 00 00      mov c, 0
2192   0DB3 FD 27         mov b, g                      ; get data header LBA
2193   0DB5 22 01         mov ah, $01                   ; disk write 1 sect
2194   0DB7 07 4D 04      call ide_write_sect           ; write sector
2195   0DBA             fs_rm_not_found:  
2196   0DBA 06            sysret  
2197   0DBB             
2198   0DBB             ;------------------------------------------------------------------------------------------------------;
2199   0DBB             ; mv - move / change file name
2200   0DBB             ;------------------------------------------------------------------------------------------------------;
2201   0DBB             fs_mv:
2202   0DBB FD 4E         mov si, d
2203   0DBD FD 4F FF 1B   mov di, user_data
2204   0DC1 38 00 02      mov c, 512
2205   0DC4 04            load                          ; load data from user-space
2206   0DC5 14 04 17      mov a, [current_dir_id]
2207   0DC8 77            inc a                         ; metadata sector
2208   0DC9 27            mov b, a  
2209   0DCA 38 00 00      mov c, 0                      ; upper LBA = 0
2210   0DCD 22 01         mov ah, $01                  ; 1 sector
2211   0DCF 3B FF 23      mov d, transient_area
2212   0DD2 07 27 04      call ide_read_sect            ; read directory
2213   0DD5 FD 10         cla
2214   0DD7 42 FC 16      mov [index], a                ; reset file counter
2215   0DDA             fs_mv_L1:
2216   0DDA FD 4E         mov si, d
2217   0DDC FD 4F FF 1B   mov di, user_data
2218   0DE0 07 0D 10      call _strcmp
2219   0DE3 C6 F9 0D      je fs_mv_found_entry
2220   0DE6 58 20 00      add d, 32
2221   0DE9 14 FC 16      mov a, [index]
2222   0DEC 77            inc a
2223   0DED 42 FC 16      mov [index], a
2224   0DF0 AF 10 00      cmp a, FST_FILES_PER_DIR
2225   0DF3 C6 2B 0E      je fs_mv_not_found
2226   0DF6 0A DA 0D      jmp fs_mv_L1
2227   0DF9             fs_mv_found_entry:  
2228   0DF9 DA            push d
2229   0DFA FD 4D 7F 1C   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2230   0DFE FD 50         mov di, d
2231   0E00 07 22 10      call _strcpy  
2232   0E03 38 00 00      mov c, 0
2233   0E06 3B FF 23      mov d, transient_area
2234   0E09 22 01         mov ah, $01                   ; disk write 1 sect
2235   0E0B 07 4D 04      call ide_write_sect           ; write sector
2236   0E0E E7            pop d
2237   0E0F             ;; need to check whether its a dir or a file here ;;;
2238   0E0F 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2239   0E12 22 01         mov ah, $01
2240   0E14 3B FF 23      mov d, transient_area
2241   0E17 38 00 00      mov c, 0
2242   0E1A 07 27 04      call ide_read_sect            ; read directory entry
2243   0E1D FD 4D 7F 1C   mov si, user_data + 128
2244   0E21 FD 50         mov di, d
2245   0E23 07 22 10      call _strcpy                  ; change directory's name
2246   0E26 22 01         mov ah, $01
2247   0E28 07 4D 04      call ide_write_sect           ; rewrite directory back to disk
2248   0E2B             fs_mv_not_found:
2249   0E2B 06            sysret
2250   0E2C             
2251   0E2C             
2252   0E2C             ;----------------------------------------------------------------------------------------------------;
2253   0E2C             ; Process Index in A
2254   0E2C             ;----------------------------------------------------------------------------------------------------;
2255   0E2C             find_free_proc:
2256   0E2C FD 4D 70 19   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2257   0E30             find_free_proc_L0:
2258   0E30 F6            lodsb                               ; get process state
2259   0E31 B9 00         cmp al, 0
2260   0E33 C6 39 0E      je find_free_proc_free              ; if free, jump
2261   0E36 0A 30 0E      jmp find_free_proc_L0               ; else, goto next
2262   0E39             find_free_proc_free:
2263   0E39 4E            mov a, si
2264   0E3A 5F 70 19      sub a, 1 + proc_availab_table       ; get process index
2265   0E3D 09            ret
2266   0E3E               
2267   0E3E             
2268   0E3E             ;----------------------------------------------------------------------------------------------------;
2269   0E3E             ; Process Index in AL
2270   0E3E             ;----------------------------------------------------------------------------------------------------;
2271   0E3E             proc_memory_map:
2272   0E3E 22 00         mov ah, 0
2273   0E40 27            mov b, a                      ; page in BL, 0 in BH
2274   0E41 FD 9D 05      shl a, 5                      ; multiply by 32
2275   0E44 39            mov c, a                      ; save in C
2276   0E45 57 20 00      add c, 32
2277   0E48             proc_memory_map_L0:
2278   0E48 02            pagemap
2279   0E49 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2280   0E4C 53 01 00      add a, 1                      ; increase both 
2281   0E4F B1            cmp a, c                      ; check to see if we reached the end of memory
2282   0E50 C7 48 0E      jne proc_memory_map_L0
2283   0E53 09            ret
2284   0E54               
2285   0E54             
2286   0E54             syscall_terminate_proc:
2287   0E54 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2288   0E57                                                    ; since they will not be used for anything here.
2289   0E57 1D FB 16      mov al, [active_proc_index]
2290   0E5A 22 00         mov ah, 0  
2291   0E5C FD 9D 05      shl a, 5                             ; x32
2292   0E5F 53 7F 19      add a, proc_names
2293   0E62 3C            mov d, a
2294   0E63 19 00         mov al, 0
2295   0E65 3E            mov [d], al                           ; nullify process name
2296   0E66             
2297   0E66 1D FB 16      mov al, [active_proc_index]
2298   0E69 22 00         mov ah, 0  
2299   0E6B 3C            mov d, a
2300   0E6C 19 00         mov al, 0
2301   0E6E 3F 6F 19      mov [d + proc_availab_table], al    ; make process empty again
2302   0E71               
2303   0E71 1D FA 16      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2304   0E74 80            dec al
2305   0E75 3D FA 16      mov [nbr_active_procs], al
2306   0E78             
2307   0E78             ; now load the shell process again
2308   0E78 19 02         mov al, 2                           ; next process = process 2 = shell
2309   0E7A 3D FB 16      mov [active_proc_index], al         ; set next active proc
2310   0E7D             
2311   0E7D             ; calculate LUT entry for next process
2312   0E7D 22 00         mov ah, 0
2313   0E7F FD 99         shl a                               ; x2
2314   0E81 B7 4A 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2315   0E84               
2316   0E84 4D            mov si, a                           ; source is proc state block
2317   0E85 48            mov a, sp
2318   0E86 5F 13 00      sub a, 19
2319   0E89 4F            mov di, a                           ; destination is kernel stack
2320   0E8A             ; restore SP
2321   0E8A 7D            dec a
2322   0E8B 47            mov sp, a
2323   0E8C 38 14 00      mov c, 20
2324   0E8F FD F5         rep movsb
2325   0E91             ; set VM process
2326   0E91 1D FB 16      mov al, [active_proc_index]
2327   0E94 01            setptb
2328   0E95                 
2329   0E95 4C            popa
2330   0E96 06            sysret
2331   0E97             
2332   0E97             syscall_pause_proc:
2333   0E97             ; save all registers into kernel stack
2334   0E97 4B            pusha
2335   0E98 22 00         mov ah, 0
2336   0E9A 1D FB 16      mov al, [active_proc_index]
2337   0E9D FD 99         shl a              ; x2
2338   0E9F B7 4A 0F      mov a, [proc_table_convert + a]   ; get process state start index
2339   0EA2                 
2340   0EA2 4F            mov di, a
2341   0EA3 48            mov a, sp
2342   0EA4 77            inc a
2343   0EA5 4D            mov si, a
2344   0EA6 38 14 00      mov c, 20
2345   0EA9 FD F5         rep movsb                         ; save process state!
2346   0EAB             ; restore kernel stack position to point before interrupt arrived
2347   0EAB 51 14 00      add sp, 20
2348   0EAE             ; now load the shell process again
2349   0EAE 19 02         mov al, 2                         ; next process = process 2 = shell
2350   0EB0 3D FB 16      mov [active_proc_index], al       ; set next active proc
2351   0EB3             
2352   0EB3             ; calculate LUT entry for next process
2353   0EB3 22 00         mov ah, 0
2354   0EB5 FD 99         shl a                             ; x2
2355   0EB7 B7 4A 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2356   0EBA               
2357   0EBA 4D            mov si, a                         ; source is proc state block
2358   0EBB 48            mov a, sp
2359   0EBC 5F 13 00      sub a, 19
2360   0EBF 4F            mov di, a                         ; destination is kernel stack
2361   0EC0             ; restore SP
2362   0EC0 7D            dec a
2363   0EC1 47            mov sp, a
2364   0EC2 38 14 00      mov c, 20
2365   0EC5 FD F5         rep movsb
2366   0EC7             ; set VM process
2367   0EC7 1D FB 16      mov al, [active_proc_index]
2368   0ECA 01            setptb
2369   0ECB                 
2370   0ECB 4C            popa
2371   0ECC 06            sysret
2372   0ECD             
2373   0ECD             ;----------------------------------------------------------------------------------------------------;
2374   0ECD             ; create a new process
2375   0ECD             ; D = path of the process file to be createed
2376   0ECD             ; B = arguments ptr
2377   0ECD             ;----------------------------------------------------------------------------------------------------;
2378   0ECD             syscall_create_proc:
2379   0ECD             ; we save the active process first  
2380   0ECD 4B            pusha
2381   0ECE 22 00         mov ah, 0
2382   0ED0 1D FB 16      mov al, [active_proc_index]
2383   0ED3 FD 99         shl a              ; x2
2384   0ED5 B7 4A 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2385   0ED8               
2386   0ED8 4F            mov di, a
2387   0ED9 48            mov a, sp
2388   0EDA 77            inc a
2389   0EDB 4D            mov si, a
2390   0EDC 38 14 00      mov c, 20
2391   0EDF FD F5         rep movsb                          ; save process state!
2392   0EE1             ; restore kernel stack position to point before interrupt arrived
2393   0EE1 51 14 00      add sp, 20
2394   0EE4               
2395   0EE4 FD 4E         mov si, d                          ; copy the file path
2396   0EE6 FD 4F FF 1B   mov di, user_data
2397   0EEA 38 00 02      mov c, 512
2398   0EED 04            load
2399   0EEE 11            mov a, b
2400   0EEF 4D            mov si, a                          ; copy the arguments
2401   0EF0 FD 4F FF 21   mov di, scrap_sector
2402   0EF4 38 00 02      mov c, 512
2403   0EF7 04            load
2404   0EF8 07 DF 08      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2405   0EFB                                                  ; the file data is loaded into transient_area
2406   0EFB             ; now we allocate a new process  
2407   0EFB 07 2C 0E      call find_free_proc                ; index in A
2408   0EFE 01            setptb 
2409   0EFF 07 3E 0E      call proc_memory_map               ; map process memory pages
2410   0F02             ; copy arguments into process's memory
2411   0F02 FD 4D FF 21   mov si, scrap_sector
2412   0F06 FD 4F 00 00   mov di, 0
2413   0F0A 38 00 02      mov c, 512
2414   0F0D 03            store
2415   0F0E             ; now copy process binary data into process's memory
2416   0F0E FD 4D FF 23   mov si, transient_area
2417   0F12 FD 4F 00 04   mov di, text_org              ; code origin address for all user processes
2418   0F16 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2419   0F19 03            store                              ; copy process data
2420   0F1A                 
2421   0F1A 07 2C 0E      call find_free_proc                ; index in A
2422   0F1D 3D FB 16      mov [active_proc_index], al        ; set new active process
2423   0F20 FD 9D 05      shl a, 5                           ; x32
2424   0F23 53 7F 19      add a, proc_names
2425   0F26 4F            mov di, a
2426   0F27 FD 4D FF 1B   mov si, user_data                  ; copy and store process filename
2427   0F2B 07 22 10      call _strcpy
2428   0F2E               
2429   0F2E 07 2C 0E      call find_free_proc                ; index in A
2430   0F31 3C            mov d, a
2431   0F32 19 01         mov al, 1
2432   0F34 3F 6F 19      mov [d + proc_availab_table], al   ; make process busy
2433   0F37               
2434   0F37 1D FA 16      mov al, [nbr_active_procs]         ; increase nbr of active processes
2435   0F3A 7A            inc al
2436   0F3B 3D FA 16      mov [nbr_active_procs], al
2437   0F3E             ; launch process
2438   0F3E FD D7 FF FF   push word $FFFF 
2439   0F42 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2440   0F45 FD D7 00 04   push word text_org
2441   0F49 06            sysret
2442   0F4A             
2443   0F4A             proc_table_convert:
2444   0F4A 2F 18         .dw proc_state_table + 0
2445   0F4C 43 18         .dw proc_state_table + 20
2446   0F4E 57 18         .dw proc_state_table + 40
2447   0F50 6B 18         .dw proc_state_table + 60
2448   0F52 7F 18         .dw proc_state_table + 80
2449   0F54 93 18         .dw proc_state_table + 100
2450   0F56 A7 18         .dw proc_state_table + 120
2451   0F58 BB 18         .dw proc_state_table + 140
2452   0F5A               
2453   0F5A             ;----------------------------------------------------------------------------------------------;
2454   0F5A             ; GET HEX FILE
2455   0F5A             ; di = destination address
2456   0F5A             ; return length in bytes in C
2457   0F5A             ;----------------------------------------------------------------------------------------------;
2458   0F5A             _load_hex:
2459   0F5A D7            push a
2460   0F5B D8            push b
2461   0F5C DA            push d
2462   0F5D E2            push si
2463   0F5E E3            push di
2464   0F5F 38 00 00      mov c, 0
2465   0F62 50            mov a, di
2466   0F63 3C            mov d, a          ; start of string data block
2467   0F64 07 A5 10      call _gets        ; get program string
2468   0F67               ;call _puts        ; reprint to screen
2469   0F67 4D            mov si, a
2470   0F68             __load_hex_loop:
2471   0F68 F6            lodsb             ; load from [SI] to AL
2472   0F69 B9 00         cmp al, 0         ; check if ASCII 0
2473   0F6B C6 79 0F      jz __load_hex_ret
2474   0F6E 36            mov bh, al
2475   0F6F F6            lodsb
2476   0F70 2F            mov bl, al
2477   0F71 07 5B 10      call _atoi        ; convert ASCII byte in B to int (to AL)
2478   0F74 F7            stosb             ; store AL to [DI]
2479   0F75 78            inc c
2480   0F76 0A 68 0F      jmp __load_hex_loop
2481   0F79             __load_hex_ret:
2482   0F79 F0            pop di
2483   0F7A EF            pop si
2484   0F7B E7            pop d
2485   0F7C E5            pop b
2486   0F7D E4            pop a
2487   0F7E 09            ret
2488   0F7F             
2489   0F7F             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2490   0F7F             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2491   0F7F             ; for each entry insIDE DIRECTORY:
2492   0F7F             ;  if entry is a file:
2493   0F7F             ;    compare filename to searched filename
2494   0F7F             ;    if filenames are the same, print filename
2495   0F7F             ;  else if entry is a directory:
2496   0F7F             ;    cd to the given directory
2497   0F7F             ;    recursively call cmd_find
2498   0F7F             ;    cd outsIDE previous directory
2499   0F7F             ;  if current entry == last entry, return
2500   0F7F             ; endfor
2501   0F7F             f_find:
2502   0F7F 09            ret
2503   0F80             
2504   0F80             
2505   0F80             ; ---------------------------------------------------------------------
2506   0F80             ; KERNEL RESET VECTOR
2507   0F80             ; ---------------------------------------------------------------------
2508   0F80             kernel_reset_vector:  
2509   0F80 FD 49 FF F7   mov bp, STACK_BEGIN
2510   0F84 FD 47 FF F7   mov sp, STACK_BEGIN
2511   0F88               
2512   0F88 19 80         mov al, %10000000
2513   0F8A FD 0F         stomsk                        ; mask out timer interrupt for now (only allow UART to interrupt)
2514   0F8C FD 0C         sti  
2515   0F8E             
2516   0F8E 0C            lodstat
2517   0F8F 87 DF         and al, %11011111             ; disable display register loading
2518   0F91 0D            stostat
2519   0F92               
2520   0F92             ; reset fifo pointers
2521   0F92 10 FF 1D      mov a, fifo
2522   0F95 3B 00 17      mov d, fifo_in
2523   0F98 43            mov [d], a
2524   0F99 3B 02 17      mov d, fifo_out
2525   0F9C 43            mov [d], a  
2526   0F9D 19 02         mov al, 2
2527   0F9F 05 03         syscall sys_io                ; enable uart in interrupt mode
2528   0FA1               
2529   0FA1 3B 46 17      mov d, s_kernel_started
2530   0FA4 07 CA 11      call _puts
2531   0FA7             
2532   0FA7 19 10         mov al, 16
2533   0FA9 05 04         syscall sys_filesystem        ; set root dirID
2534   0FAB             
2535   0FAB 3B 63 17      mov d, s_prompt_init
2536   0FAE 07 CA 11      call _puts
2537   0FB1 3B 06 17      mov d, s_init_path
2538   0FB4 05 05         syscall sys_create_proc              ; launch init as a new process
2539   0FB6             
2540   0FB6             
2541   0FB6             ; FILE INCLUDES
2542   0FB6             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  0FB6             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0FB6             IDE_buffer       .EQU  $8204
0003+  0FB6             boot_origin      .EQU  $8004
0004+  0FB6             bios_uart        .EQU  $0002
0005+  0FB6             bios_ide         .EQU  $0003
2543   0FB6             .include "lib/stdio.asm"
0001+  0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0FB6             ; stdio.s
0003+  0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0FB6             .include "lib/string.asm"
0001++ 0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0FB6             ; string.s
0003++ 0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0FB6             
0005++ 0FB6             
0006++ 0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0FB6             ; _strrev
0008++ 0FB6             ; reverse a string
0009++ 0FB6             ; D = string address
0010++ 0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0FB6             ; 01234
0012++ 0FB6             _strrev:
0013++ 0FB6 4B          	pusha
0014++ 0FB7 07 FD 0F    	call _strlen	; length in C
0015++ 0FBA 12          	mov a, c
0016++ 0FBB AF 01 00    	cmp a, 1
0017++ 0FBE D0 D8 0F    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0FC1 7D          	dec a
0019++ 0FC2 FD 4E       	mov si, d	; beginning of string
0020++ 0FC4 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0FC6 59          	add d, a	; end of string
0022++ 0FC7 12          	mov a, c
0023++ 0FC8 FD 9B       	shr a		; divide by 2
0024++ 0FCA 39          	mov c, a	; C now counts the steps
0025++ 0FCB             _strrev_L0:
0026++ 0FCB 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0FCC F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0FCD 3E          	mov [d], al	; store left char into right side
0029++ 0FCE 1B          	mov al, bl
0030++ 0FCF F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0FD0 7E          	dec c
0032++ 0FD1 7F          	dec d
0033++ 0FD2 C2 00 00    	cmp c, 0
0034++ 0FD5 C7 CB 0F    	jne _strrev_L0
0035++ 0FD8             _strrev_end:
0036++ 0FD8 4C          	popa
0037++ 0FD9 09          	ret
0038++ 0FDA             	
0039++ 0FDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0FDA             ; _strchr
0041++ 0FDA             ; search string in D for char in AL
0042++ 0FDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0FDA             _strchr:
0044++ 0FDA             _strchr_L0:
0045++ 0FDA 32          	mov bl, [d]
0046++ 0FDB C1 00       	cmp bl, 0
0047++ 0FDD C6 E8 0F    	je _strchr_end
0048++ 0FE0 BA          	cmp al, bl
0049++ 0FE1 C6 E8 0F    	je _strchr_end
0050++ 0FE4 79          	inc d
0051++ 0FE5 0A DA 0F    	jmp _strchr_L0
0052++ 0FE8             _strchr_end:
0053++ 0FE8 1B          	mov al, bl
0054++ 0FE9 09          	ret
0055++ 0FEA             
0056++ 0FEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0FEA             ; _strstr
0058++ 0FEA             ; find sub-string
0059++ 0FEA             ; str1 in SI
0060++ 0FEA             ; str2 in DI
0061++ 0FEA             ; SI points to end of source string
0062++ 0FEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0FEA             _strstr:
0064++ 0FEA DB          	push al
0065++ 0FEB DA          	push d
0066++ 0FEC E3          	push di
0067++ 0FED             _strstr_loop:
0068++ 0FED F3          	cmpsb					; compare a byte of the strings
0069++ 0FEE C7 F9 0F    	jne _strstr_ret
0070++ 0FF1 FC 00 00    	lea d, [di + 0]
0071++ 0FF4 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0FF6 C7 ED 0F    	jne _strstr_loop				; equal chars but not at end
0073++ 0FF9             _strstr_ret:
0074++ 0FF9 F0          	pop di
0075++ 0FFA E7          	pop d
0076++ 0FFB E8          	pop al
0077++ 0FFC 09          	ret
0078++ 0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0FFD             ; length of null terminated string
0080++ 0FFD             ; result in C
0081++ 0FFD             ; pointer in D
0082++ 0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0FFD             _strlen:
0084++ 0FFD DA          	push d
0085++ 0FFE 38 00 00    	mov c, 0
0086++ 1001             _strlen_L1:
0087++ 1001 BD 00       	cmp byte [d], 0
0088++ 1003 C6 0B 10    	je _strlen_ret
0089++ 1006 79          	inc d
0090++ 1007 78          	inc c
0091++ 1008 0A 01 10    	jmp _strlen_L1
0092++ 100B             _strlen_ret:
0093++ 100B E7          	pop d
0094++ 100C 09          	ret
0095++ 100D             
0096++ 100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 100D             ; STRCMP
0098++ 100D             ; compare two strings
0099++ 100D             ; str1 in SI
0100++ 100D             ; str2 in DI
0101++ 100D             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 100D             _strcmp:
0104++ 100D DB          	push al
0105++ 100E DA          	push d
0106++ 100F E3          	push di
0107++ 1010 E2          	push si
0108++ 1011             _strcmp_loop:
0109++ 1011 F3          	cmpsb					; compare a byte of the strings
0110++ 1012 C7 1D 10    	jne _strcmp_ret
0111++ 1015 FB FF FF    	lea d, [si +- 1]
0112++ 1018 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 101A C7 11 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 101D             _strcmp_ret:
0115++ 101D EF          	pop si
0116++ 101E F0          	pop di
0117++ 101F E7          	pop d
0118++ 1020 E8          	pop al
0119++ 1021 09          	ret
0120++ 1022             
0121++ 1022             
0122++ 1022             ; STRCPY
0123++ 1022             ; copy null terminated string from SI to DI
0124++ 1022             ; source in SI
0125++ 1022             ; destination in DI
0126++ 1022             _strcpy:
0127++ 1022 E2          	push si
0128++ 1023 E3          	push di
0129++ 1024 DB          	push al
0130++ 1025             _strcpy_L1:
0131++ 1025 F6          	lodsb
0132++ 1026 F7          	stosb
0133++ 1027 B9 00       	cmp al, 0
0134++ 1029 C7 25 10    	jne _strcpy_L1
0135++ 102C             _strcpy_end:
0136++ 102C E8          	pop al
0137++ 102D F0          	pop di
0138++ 102E EF          	pop si
0139++ 102F 09          	ret
0140++ 1030             
0141++ 1030             ; STRCAT
0142++ 1030             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1030             ; source in SI
0144++ 1030             ; destination in DI
0145++ 1030             _strcat:
0146++ 1030 E2          	push si
0147++ 1031 E3          	push di
0148++ 1032 D7          	push a
0149++ 1033 DA          	push d
0150++ 1034 50          	mov a, di
0151++ 1035 3C          	mov d, a
0152++ 1036             _strcat_goto_end_L1:
0153++ 1036 BD 00       	cmp byte[d], 0
0154++ 1038 C6 3F 10    	je _strcat_start
0155++ 103B 79          	inc d
0156++ 103C 0A 36 10    	jmp _strcat_goto_end_L1
0157++ 103F             _strcat_start:
0158++ 103F FD 50       	mov di, d
0159++ 1041             _strcat_L1:
0160++ 1041 F6          	lodsb
0161++ 1042 F7          	stosb
0162++ 1043 B9 00       	cmp al, 0
0163++ 1045 C7 41 10    	jne _strcat_L1
0164++ 1048             _strcat_end:
0165++ 1048 E7          	pop d
0166++ 1049 E4          	pop a
0167++ 104A F0          	pop di
0168++ 104B EF          	pop si
0169++ 104C 09          	ret
0170++ 104D             
0171++ 104D             
0005+  104D             
0006+  104D             
0007+  104D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  104D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  104D             ; ASCII in BL
0010+  104D             ; result in AL
0011+  104D             ; ascii for F = 0100 0110
0012+  104D             ; ascii for 9 = 0011 1001
0013+  104D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  104D             hex_ascii_encode:
0015+  104D 1B            mov al, bl
0016+  104E 93 40         test al, $40        ; test if letter or number
0017+  1050 C7 56 10      jnz hex_letter
0018+  1053 87 0F         and al, $0F        ; get number
0019+  1055 09            ret
0020+  1056             hex_letter:
0021+  1056 87 0F         and al, $0F        ; get letter
0022+  1058 6A 09         add al, 9
0023+  105A 09            ret
0024+  105B             
0025+  105B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  105B             ; ATOI
0027+  105B             ; 2 letter hex string in B
0028+  105B             ; 8bit integer returned in AL
0029+  105B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  105B             _atoi:
0031+  105B D8            push b
0032+  105C 07 4D 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  105F 30            mov bl, bh
0034+  1060 DB            push al          ; save a
0035+  1061 07 4D 10      call hex_ascii_encode
0036+  1064 EA            pop bl  
0037+  1065 FD 9E 04      shl al, 4
0038+  1068 8C            or al, bl
0039+  1069 E5            pop b
0040+  106A 09            ret  
0041+  106B             
0042+  106B             
0043+  106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  106B             ; scanf
0045+  106B             ; no need for explanations!
0046+  106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  106B             scanf:
0048+  106B 09            ret
0049+  106C             
0050+  106C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  106C             ; ITOA
0052+  106C             ; 8bit value in BL
0053+  106C             ; 2 byte ASCII result in A
0054+  106C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  106C             _itoa:
0056+  106C DA            push d
0057+  106D D8            push b
0058+  106E A7 00         mov bh, 0
0059+  1070 FD A4 04      shr bl, 4  
0060+  1073 74            mov d, b
0061+  1074 1F 06 13      mov al, [d + s_hex_digits]
0062+  1077 23            mov ah, al
0063+  1078               
0064+  1078 E5            pop b
0065+  1079 D8            push b
0066+  107A A7 00         mov bh, 0
0067+  107C FD 87 0F      and bl, $0F
0068+  107F 74            mov d, b
0069+  1080 1F 06 13      mov al, [d + s_hex_digits]
0070+  1083 E5            pop b
0071+  1084 E7            pop d
0072+  1085 09            ret
0073+  1086             
0074+  1086             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1086             ; HEX STRING TO BINARY
0076+  1086             ; di = destination address
0077+  1086             ; si = source
0078+  1086             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1086             _hex_to_int:
0080+  1086             _hex_to_int_L1:
0081+  1086 F6            lodsb          ; load from [SI] to AL
0082+  1087 B9 00         cmp al, 0        ; check if ASCII 0
0083+  1089 C6 96 10      jz _hex_to_int_ret
0084+  108C 36            mov bh, al
0085+  108D F6            lodsb
0086+  108E 2F            mov bl, al
0087+  108F 07 5B 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  1092 F7            stosb          ; store AL to [DI]
0089+  1093 0A 86 10      jmp _hex_to_int_L1
0090+  1096             _hex_to_int_ret:
0091+  1096 09            ret    
0092+  1097             
0093+  1097             
0094+  1097             
0095+  1097             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1097             ; GETCHAR
0097+  1097             ; char in ah
0098+  1097             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1097             getch:
0100+  1097 DB            push al
0101+  1098             getch_retry:
0102+  1098 19 01         mov al, 1
0103+  109A 05 03         syscall sys_io      ; receive in AH
0104+  109C E8            pop al
0105+  109D 09            ret
0106+  109E             
0107+  109E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  109E             ; PUTCHAR
0109+  109E             ; char in ah
0110+  109E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  109E             _putchar:
0112+  109E DB            push al
0113+  109F 19 00         mov al, 0
0114+  10A1 05 03         syscall sys_io      ; char in AH
0115+  10A3 E8            pop al
0116+  10A4 09            ret
0117+  10A5             
0118+  10A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  10A5             ;; INPUT A STRING
0120+  10A5             ;; terminates with null
0121+  10A5             ;; pointer in D
0122+  10A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  10A5             _gets:
0124+  10A5 D7            push a
0125+  10A6 DA            push d
0126+  10A7             _gets_loop:
0127+  10A7 19 01         mov al, 1
0128+  10A9 05 03         syscall sys_io      ; receive in AH
0129+  10AB 76 1B         cmp ah, 27
0130+  10AD C6 CE 10      je _gets_ansi_esc
0131+  10B0 76 0A         cmp ah, $0A        ; LF
0132+  10B2 C6 2A 11      je _gets_end
0133+  10B5 76 0D         cmp ah, $0D        ; CR
0134+  10B7 C6 2A 11      je _gets_end
0135+  10BA 76 5C         cmp ah, $5C        ; '\\'
0136+  10BC C6 F0 10      je _gets_escape
0137+  10BF 76 08         cmp ah, $08      ; check for backspace
0138+  10C1 C6 CA 10      je _gets_backspace
0139+  10C4 1A            mov al, ah
0140+  10C5 3E            mov [d], al
0141+  10C6 79            inc d
0142+  10C7 0A A7 10      jmp _gets_loop
0143+  10CA             _gets_backspace:
0144+  10CA 7F            dec d
0145+  10CB 0A A7 10      jmp _gets_loop
0146+  10CE             _gets_ansi_esc:
0147+  10CE 19 01         mov al, 1
0148+  10D0 05 03         syscall sys_io        ; receive in AH without echo
0149+  10D2 76 5B         cmp ah, '['
0150+  10D4 C7 A7 10      jne _gets_loop
0151+  10D7 19 01         mov al, 1
0152+  10D9 05 03         syscall sys_io          ; receive in AH without echo
0153+  10DB 76 44         cmp ah, 'D'
0154+  10DD C6 E8 10      je _gets_left_arrow
0155+  10E0 76 43         cmp ah, 'C'
0156+  10E2 C6 EC 10      je _gets_right_arrow
0157+  10E5 0A A7 10      jmp _gets_loop
0158+  10E8             _gets_left_arrow:
0159+  10E8 7F            dec d
0160+  10E9 0A A7 10      jmp _gets_loop
0161+  10EC             _gets_right_arrow:
0162+  10EC 79            inc d
0163+  10ED 0A A7 10      jmp _gets_loop
0164+  10F0             _gets_escape:
0165+  10F0 19 01         mov al, 1
0166+  10F2 05 03         syscall sys_io      ; receive in AH
0167+  10F4 76 6E         cmp ah, 'n'
0168+  10F6 C6 15 11      je _gets_LF
0169+  10F9 76 72         cmp ah, 'r'
0170+  10FB C6 1C 11      je _gets_CR
0171+  10FE 76 30         cmp ah, '0'
0172+  1100 C6 23 11      je _gets_NULL
0173+  1103 76 5C         cmp ah, $5C  ; '\'
0174+  1105 C6 0E 11      je _gets_slash
0175+  1108 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  1109 3E            mov [d], al
0177+  110A 79            inc d
0178+  110B 0A A7 10      jmp _gets_loop
0179+  110E             _gets_slash:
0180+  110E 19 5C         mov al, $5C
0181+  1110 3E            mov [d], al
0182+  1111 79            inc d
0183+  1112 0A A7 10      jmp _gets_loop
0184+  1115             _gets_LF:
0185+  1115 19 0A         mov al, $0A
0186+  1117 3E            mov [d], al
0187+  1118 79            inc d
0188+  1119 0A A7 10      jmp _gets_loop
0189+  111C             _gets_CR:
0190+  111C 19 0D         mov al, $0D
0191+  111E 3E            mov [d], al
0192+  111F 79            inc d
0193+  1120 0A A7 10      jmp _gets_loop
0194+  1123             _gets_NULL:
0195+  1123 19 00         mov al, $00
0196+  1125 3E            mov [d], al
0197+  1126 79            inc d
0198+  1127 0A A7 10      jmp _gets_loop
0199+  112A             _gets_end:
0200+  112A 19 00         mov al, 0
0201+  112C 3E            mov [d], al        ; terminate string
0202+  112D E7            pop d
0203+  112E E4            pop a
0204+  112F 09            ret
0205+  1130             
0206+  1130             
0207+  1130             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1130             ;; INPUT TEXT
0209+  1130             ;; terminated with CTRL+D
0210+  1130             ;; pointer in D
0211+  1130             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1130             _gettxt:
0213+  1130 D7            push a
0214+  1131 DA            push d
0215+  1132             _gettxt_loop:
0216+  1132 19 01         mov al, 1
0217+  1134 05 03         syscall sys_io      ; receive in AH
0218+  1136 76 04         cmp ah, 4      ; EOT
0219+  1138 C6 71 11      je _gettxt_end
0220+  113B 76 08         cmp ah, $08      ; check for backspace
0221+  113D C6 6D 11      je _gettxt_backspace
0222+  1140 76 5C         cmp ah, $5C        ; '\'
0223+  1142 C6 4B 11      je _gettxt_escape
0224+  1145 1A            mov al, ah
0225+  1146 3E            mov [d], al
0226+  1147 79            inc d
0227+  1148 0A 32 11      jmp _gettxt_loop
0228+  114B             _gettxt_escape:
0229+  114B 19 01         mov al, 1
0230+  114D 05 03         syscall sys_io      ; receive in AH
0231+  114F 76 6E         cmp ah, 'n'
0232+  1151 C6 5F 11      je _gettxt_LF
0233+  1154 76 72         cmp ah, 'r'
0234+  1156 C6 66 11      je _gettxt_CR
0235+  1159 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  115A 3E            mov [d], al
0237+  115B 79            inc d
0238+  115C 0A 32 11      jmp _gettxt_loop
0239+  115F             _gettxt_LF:
0240+  115F 19 0A         mov al, $0A
0241+  1161 3E            mov [d], al
0242+  1162 79            inc d
0243+  1163 0A 32 11      jmp _gettxt_loop
0244+  1166             _gettxt_CR:
0245+  1166 19 0D         mov al, $0D
0246+  1168 3E            mov [d], al
0247+  1169 79            inc d
0248+  116A 0A 32 11      jmp _gettxt_loop
0249+  116D             _gettxt_backspace:
0250+  116D 7F            dec d
0251+  116E 0A 32 11      jmp _gettxt_loop
0252+  1171             _gettxt_end:
0253+  1171 19 00         mov al, 0
0254+  1173 3E            mov [d], al        ; terminate string
0255+  1174 E7            pop d
0256+  1175 E4            pop a
0257+  1176 09            ret
0258+  1177             
0259+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  1177             ; PRINT NEW LINE
0261+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  1177             printnl:
0263+  1177 D7            push a
0264+  1178 10 00 0A      mov a, $0A00
0265+  117B 05 03         syscall sys_io
0266+  117D 10 00 0D      mov a, $0D00
0267+  1180 05 03         syscall sys_io
0268+  1182 E4            pop a
0269+  1183 09            ret
0270+  1184             
0271+  1184             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  1184             ; _strtoint
0273+  1184             ; 4 digit hex string number in d
0274+  1184             ; integer returned in A
0275+  1184             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1184             _strtointx:
0277+  1184 D8            push b
0278+  1185 32            mov bl, [d]
0279+  1186 37            mov bh, bl
0280+  1187 33 01 00      mov bl, [d + 1]
0281+  118A 07 5B 10      call _atoi        ; convert to int in AL
0282+  118D 23            mov ah, al        ; move to AH
0283+  118E 33 02 00      mov bl, [d + 2]
0284+  1191 37            mov bh, bl
0285+  1192 33 03 00      mov bl, [d + 3]
0286+  1195 07 5B 10      call _atoi        ; convert to int in AL
0287+  1198 E5            pop b
0288+  1199 09            ret
0289+  119A             
0290+  119A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  119A             ; _strtoint
0292+  119A             ; 5 digit base10 string number in d
0293+  119A             ; integer returned in A
0294+  119A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  119A             _strtoint:
0296+  119A E2            push si
0297+  119B D8            push b
0298+  119C D9            push c
0299+  119D DA            push d
0300+  119E 07 FD 0F      call _strlen      ; get string length in C
0301+  11A1 7E            dec c
0302+  11A2 FD 4E         mov si, d
0303+  11A4 12            mov a, c
0304+  11A5 FD 99         shl a
0305+  11A7 3B 1E 13      mov d, table_power
0306+  11AA 59            add d, a
0307+  11AB 38 00 00      mov c, 0
0308+  11AE             _strtoint_L0:
0309+  11AE F6            lodsb      ; load ASCII to al
0310+  11AF B9 00         cmp al, 0
0311+  11B1 C6 C4 11      je _strtoint_end
0312+  11B4 6F 30         sub al, $30    ; make into integer
0313+  11B6 22 00         mov ah, 0
0314+  11B8 2A            mov b, [d]
0315+  11B9 AC            mul a, b      ; result in B since it fits in 16bits
0316+  11BA 11            mov a, b
0317+  11BB 28            mov b, c
0318+  11BC 54            add a, b
0319+  11BD 39            mov c, a
0320+  11BE 63 02 00      sub d, 2
0321+  11C1 0A AE 11      jmp _strtoint_L0
0322+  11C4             _strtoint_end:
0323+  11C4 12            mov a, c
0324+  11C5 E7            pop d
0325+  11C6 E6            pop c
0326+  11C7 E5            pop b
0327+  11C8 EF            pop si
0328+  11C9 09            ret
0329+  11CA             
0330+  11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  11CA             ; PRINT NULL TERMINATED STRING
0332+  11CA             ; pointer in D
0333+  11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  11CA             _puts:
0335+  11CA D7            push a
0336+  11CB DA            push d
0337+  11CC             _puts_L1:
0338+  11CC 1E            mov al, [d]
0339+  11CD B9 00         cmp al, 0
0340+  11CF C6 DB 11      jz _puts_END
0341+  11D2 23            mov ah, al
0342+  11D3 19 00         mov al, 0
0343+  11D5 05 03         syscall sys_io
0344+  11D7 79            inc d
0345+  11D8 0A CC 11      jmp _puts_L1
0346+  11DB             _puts_END:
0347+  11DB E7            pop d
0348+  11DC E4            pop a
0349+  11DD 09            ret
0350+  11DE             
0351+  11DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  11DE             ; PRINT N SIZE STRING
0353+  11DE             ; pointer in D
0354+  11DE             ; size in C
0355+  11DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  11DE             _putsn:
0357+  11DE DB            push al
0358+  11DF DA            push d
0359+  11E0 D9            push c
0360+  11E1             _putsn_L0:
0361+  11E1 1E            mov al, [d]
0362+  11E2 23            mov ah, al
0363+  11E3 19 00         mov al, 0
0364+  11E5 05 03         syscall sys_io
0365+  11E7 79            inc d
0366+  11E8 7E            dec c  
0367+  11E9 C2 00 00      cmp c, 0
0368+  11EC C7 E1 11      jne _putsn_L0
0369+  11EF             _putsn_end:
0370+  11EF E6            pop c
0371+  11F0 E7            pop d
0372+  11F1 E8            pop al
0373+  11F2 09            ret
0374+  11F3             
0375+  11F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  11F3             ; print 16bit decimal number
0377+  11F3             ; input number in A
0378+  11F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  11F3             print_u16d:
0380+  11F3 D7            push a
0381+  11F4 D8            push b
0382+  11F5 FD D8         push g
0383+  11F7 26 10 27      mov b, 10000
0384+  11FA AE            div a, b      ; get 10000's coeff.
0385+  11FB 07 1F 12      call print_number
0386+  11FE 11            mov a, b
0387+  11FF 26 E8 03      mov b, 1000
0388+  1202 AE            div a, b      ; get 1000's coeff.
0389+  1203 07 1F 12      call print_number
0390+  1206 11            mov a, b
0391+  1207 26 64 00      mov b, 100
0392+  120A AE            div a, b
0393+  120B 07 1F 12      call print_number
0394+  120E 11            mov a, b
0395+  120F 26 0A 00      mov b, 10
0396+  1212 AE            div a, b
0397+  1213 07 1F 12      call print_number
0398+  1216 1B            mov al, bl      ; 1's coeff in bl
0399+  1217 07 1F 12      call print_number
0400+  121A FD F1         pop g
0401+  121C E5            pop b
0402+  121D E4            pop a
0403+  121E 09            ret
0404+  121F             
0405+  121F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  121F             ; print AL
0407+  121F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  121F             print_number:
0409+  121F 6A 30         add al, $30
0410+  1221 23            mov ah, al
0411+  1222 07 9E 10      call _putchar
0412+  1225 09            ret
0413+  1226             
0414+  1226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  1226             ; PRINT 16BIT HEX INTEGER
0416+  1226             ; integer value in reg B
0417+  1226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  1226             print_u16x:
0419+  1226 D7            push a
0420+  1227 D8            push b
0421+  1228 DD            push bl
0422+  1229 30            mov bl, bh
0423+  122A 07 6C 10      call _itoa        ; convert bh to char in A
0424+  122D 2F            mov bl, al        ; save al
0425+  122E 19 00         mov al, 0
0426+  1230 05 03         syscall sys_io        ; display AH
0427+  1232 24            mov ah, bl        ; retrieve al
0428+  1233 19 00         mov al, 0
0429+  1235 05 03         syscall sys_io        ; display AL
0430+  1237             
0431+  1237 EA            pop bl
0432+  1238 07 6C 10      call _itoa        ; convert bh to char in A
0433+  123B 2F            mov bl, al        ; save al
0434+  123C 19 00         mov al, 0
0435+  123E 05 03         syscall sys_io        ; display AH
0436+  1240 24            mov ah, bl        ; retrieve al
0437+  1241 19 00         mov al, 0
0438+  1243 05 03         syscall sys_io        ; display AL
0439+  1245             
0440+  1245 E5            pop b
0441+  1246 E4            pop a
0442+  1247 09            ret
0443+  1248             
0444+  1248             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  1248             ; INPUT 16BIT HEX INTEGER
0446+  1248             ; read 16bit integer into A
0447+  1248             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  1248             scan_u16x:
0449+  1248 F8 10 00      enter 16
0450+  124B D8            push b
0451+  124C DA            push d
0452+  124D             
0453+  124D FA F1 FF      lea d, [bp + -15]
0454+  1250 07 A5 10      call _gets        ; get number
0455+  1253             
0456+  1253 32            mov bl, [d]
0457+  1254 37            mov bh, bl
0458+  1255 33 01 00      mov bl, [d + 1]
0459+  1258 07 5B 10      call _atoi        ; convert to int in AL
0460+  125B 23            mov ah, al        ; move to AH
0461+  125C             
0462+  125C 33 02 00      mov bl, [d + 2]
0463+  125F 37            mov bh, bl
0464+  1260 33 03 00      mov bl, [d + 3]
0465+  1263 07 5B 10      call _atoi        ; convert to int in AL
0466+  1266             
0467+  1266 E7            pop d
0468+  1267 E5            pop b
0469+  1268 F9            leave
0470+  1269 09            ret
0471+  126A             
0472+  126A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  126A             ; PRINT 8bit HEX INTEGER
0474+  126A             ; integer value in reg bl
0475+  126A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  126A             print_u8x:
0477+  126A D7            push a
0478+  126B DD            push bl
0479+  126C             
0480+  126C 07 6C 10      call _itoa        ; convert bl to char in A
0481+  126F 2F            mov bl, al        ; save al
0482+  1270 19 00         mov al, 0
0483+  1272 05 03         syscall sys_io        ; display AH
0484+  1274 24            mov ah, bl        ; retrieve al
0485+  1275 19 00         mov al, 0
0486+  1277 05 03         syscall sys_io        ; display AL
0487+  1279             
0488+  1279 EA            pop bl
0489+  127A E4            pop a
0490+  127B 09            ret
0491+  127C             
0492+  127C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  127C             ; print 8bit decimal unsigned number
0494+  127C             ; input number in AL
0495+  127C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  127C             print_u8d:
0497+  127C D7            push a
0498+  127D D8            push b
0499+  127E FD D8         push g
0500+  1280 22 00         mov ah, 0
0501+  1282 26 64 00      mov b, 100
0502+  1285 AE            div a, b
0503+  1286 D8            push b      ; save remainder
0504+  1287 B9 00         cmp al, 0
0505+  1289 C6 93 12      je skip100
0506+  128C 6A 30         add al, $30
0507+  128E 23            mov ah, al
0508+  128F 19 00         mov al, 0
0509+  1291 05 03         syscall sys_io  ; print coeff
0510+  1293             skip100:
0511+  1293 E4            pop a
0512+  1294 22 00         mov ah, 0
0513+  1296 26 0A 00      mov b, 10
0514+  1299 AE            div a, b
0515+  129A D8            push b      ; save remainder
0516+  129B B9 00         cmp al, 0
0517+  129D C6 A7 12      je skip10
0518+  12A0 6A 30         add al, $30
0519+  12A2 23            mov ah, al
0520+  12A3 19 00         mov al, 0
0521+  12A5 05 03         syscall sys_io  ; print coeff
0522+  12A7             skip10:
0523+  12A7 E4            pop a
0524+  12A8 1B            mov al, bl
0525+  12A9 6A 30         add al, $30
0526+  12AB 23            mov ah, al
0527+  12AC 19 00         mov al, 0
0528+  12AE 05 03         syscall sys_io  ; print coeff
0529+  12B0 FD F1         pop g
0530+  12B2 E5            pop b
0531+  12B3 E4            pop a
0532+  12B4 09            ret
0533+  12B5             
0534+  12B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  12B5             ; INPUT 8BIT HEX INTEGER
0536+  12B5             ; read 8bit integer into AL
0537+  12B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  12B5             scan_u8x:
0539+  12B5 F8 04 00      enter 4
0540+  12B8 D8            push b
0541+  12B9 DA            push d
0542+  12BA             
0543+  12BA FA FD FF      lea d, [bp + -3]
0544+  12BD 07 A5 10      call _gets        ; get number
0545+  12C0             
0546+  12C0 32            mov bl, [d]
0547+  12C1 37            mov bh, bl
0548+  12C2 33 01 00      mov bl, [d + 1]
0549+  12C5 07 5B 10      call _atoi        ; convert to int in AL
0550+  12C8             
0551+  12C8 E7            pop d
0552+  12C9 E5            pop b
0553+  12CA F9            leave
0554+  12CB 09            ret
0555+  12CC             
0556+  12CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  12CC             ; input decimal number
0558+  12CC             ; result in A
0559+  12CC             ; 655'\0'
0560+  12CC             ; low--------high
0561+  12CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  12CC             scan_u16d:
0563+  12CC F8 08 00      enter 8
0564+  12CF E2            push si
0565+  12D0 D8            push b
0566+  12D1 D9            push c
0567+  12D2 DA            push d
0568+  12D3 FA F9 FF      lea d, [bp +- 7]
0569+  12D6 07 A5 10      call _gets
0570+  12D9 07 FD 0F      call _strlen      ; get string length in C
0571+  12DC 7E            dec c
0572+  12DD FD 4E         mov si, d
0573+  12DF 12            mov a, c
0574+  12E0 FD 99         shl a
0575+  12E2 3B 1E 13      mov d, table_power
0576+  12E5 59            add d, a
0577+  12E6 38 00 00      mov c, 0
0578+  12E9             mul_loop:
0579+  12E9 F6            lodsb      ; load ASCII to al
0580+  12EA B9 00         cmp al, 0
0581+  12EC C6 FF 12      je mul_exit
0582+  12EF 6F 30         sub al, $30    ; make into integer
0583+  12F1 22 00         mov ah, 0
0584+  12F3 2A            mov b, [d]
0585+  12F4 AC            mul a, b      ; result in B since it fits in 16bits
0586+  12F5 11            mov a, b
0587+  12F6 28            mov b, c
0588+  12F7 54            add a, b
0589+  12F8 39            mov c, a
0590+  12F9 63 02 00      sub d, 2
0591+  12FC 0A E9 12      jmp mul_loop
0592+  12FF             mul_exit:
0593+  12FF 12            mov a, c
0594+  1300 E7            pop d
0595+  1301 E6            pop c
0596+  1302 E5            pop b
0597+  1303 EF            pop si
0598+  1304 F9            leave
0599+  1305 09            ret
0600+  1306             
0601+  1306             
0602+  1306 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  130A 34 35 36 37 
0602+  130E 38 39 41 42 
0602+  1312 43 44 45 46 
0603+  1316 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  131A 1B 5B 48 00 
0604+  131E             
0605+  131E             table_power:
0606+  131E 01 00         .dw 1
0607+  1320 0A 00         .dw 10
0608+  1322 64 00         .dw 100
0609+  1324 E8 03         .dw 1000
0610+  1326 10 27         .dw 100002544   1328             .include "lib/ctype.asm"
0001+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1328             ; ctype.s
0003+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1328             
0005+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  1328             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  1328             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  1328             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  1328             ;; characters are supported.
0010+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  1328             ;; _isalnum 
0012+  1328             ;; _isalpha 
0013+  1328             ;; islower 
0014+  1328             ;; isupper 
0015+  1328             ;; _isdigit 
0016+  1328             ;; isxdigit
0017+  1328             ;; iscntrl 
0018+  1328             ;; isgraph 
0019+  1328             ;; _isspace 
0020+  1328             ;; isblank 
0021+  1328             ;; isprint 
0022+  1328             ;; ispunct 
0023+  1328             ;; tolower 
0024+  1328             ;; toupper
0025+  1328             
0026+  1328             
0027+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  1328             ;; IS ALPHANUMERIC
0029+  1328             ;; sets ZF according with result
0030+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  1328             _isalnum:
0032+  1328 07 45 13    	call _isalpha
0033+  132B C6 31 13    	je _isalnum_exit
0034+  132E 07 32 13    	call _isdigit
0035+  1331             _isalnum_exit:
0036+  1331 09          	ret	
0037+  1332             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1332             ;; IS DIGIT
0039+  1332             ;; sets ZF according with result
0040+  1332             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1332             _isdigit:
0042+  1332 DB          	push al
0043+  1333 B9 30       	cmp al, '0'
0044+  1335 C8 41 13    	jlu _isdigit_false
0045+  1338 B9 39       	cmp al, '9'
0046+  133A D1 41 13    	jgu _isdigit_false
0047+  133D 87 00       	and al, 0	; set ZF
0048+  133F E8          	pop al
0049+  1340 09          	ret
0050+  1341             _isdigit_false:
0051+  1341 8B 01       	or al, 1	; clear ZF
0052+  1343 E8          	pop al
0053+  1344 09          	ret	
0054+  1345             	
0055+  1345             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1345             ;; IS ALPHA
0057+  1345             ;; sets ZF according with result
0058+  1345             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1345             _isalpha:
0060+  1345 DB          	push al
0061+  1346 B9 5F       	cmp al, '_'
0062+  1348 C6 68 13    	je _isalpha_true
0063+  134B B9 2E       	cmp al, '.'
0064+  134D C6 68 13    	je _isalpha_true
0065+  1350 B9 41       	cmp al, 'A'
0066+  1352 C8 64 13    	jlu _isalpha_false
0067+  1355 B9 7A       	cmp al, 'z'
0068+  1357 D1 64 13    	jgu _isalpha_false
0069+  135A B9 5A       	cmp al, 'Z'
0070+  135C D0 68 13    	jleu _isalpha_true
0071+  135F B9 61       	cmp al, 'a'
0072+  1361 C9 68 13    	jgeu _isalpha_true
0073+  1364             _isalpha_false:
0074+  1364 8B 01       	or al, 1	; clear ZF
0075+  1366 E8          	pop al
0076+  1367 09          	ret
0077+  1368             _isalpha_true:
0078+  1368 87 00       	and al, 0	; set ZF
0079+  136A E8          	pop al
0080+  136B 09          	ret
0081+  136C             
0082+  136C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  136C             ;; IS PATH-ALPHA
0084+  136C             ;; sets ZF according with result
0085+  136C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  136C             ispath:
0087+  136C DB          	push al
0088+  136D 07 32 13    	call _isdigit
0089+  1370 C6 9A 13    	je ispath_true
0090+  1373 B9 5F       	cmp al, '_'
0091+  1375 C6 9A 13    	je ispath_true
0092+  1378 B9 2F       	cmp al, '/'
0093+  137A C6 9A 13    	je ispath_true
0094+  137D B9 2E       	cmp al, '.'
0095+  137F C6 9A 13    	je ispath_true
0096+  1382 B9 41       	cmp al, 'A'
0097+  1384 C8 96 13    	jlu ispath_false
0098+  1387 B9 7A       	cmp al, 'z'
0099+  1389 D1 96 13    	jgu ispath_false
0100+  138C B9 5A       	cmp al, 'Z'
0101+  138E D0 9A 13    	jleu ispath_true
0102+  1391 B9 61       	cmp al, 'a'
0103+  1393 C9 9A 13    	jgeu ispath_true
0104+  1396             ispath_false:
0105+  1396 8B 01       	or al, 1	; clear ZF
0106+  1398 E8          	pop al
0107+  1399 09          	ret
0108+  139A             ispath_true:
0109+  139A 87 00       	and al, 0	; set ZF
0110+  139C E8          	pop al
0111+  139D 09          	ret
0112+  139E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  139E             ;; IS SPACE
0114+  139E             ;; sets ZF according with result
0115+  139E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  139E             _isspace:
0117+  139E B9 20       	cmp al, $20		; ' '
0118+  13A0 C6 B4 13    	je _isspace_exit
0119+  13A3 B9 09       	cmp al, $09		; '\t'
0120+  13A5 C6 B4 13    	je _isspace_exit
0121+  13A8 B9 0A       	cmp al, $0A		; '\n'
0122+  13AA C6 B4 13    	je _isspace_exit
0123+  13AD B9 0D       	cmp al, $0D		; '\r'
0124+  13AF C6 B4 13    	je _isspace_exit
0125+  13B2 B9 0B       	cmp al, $0B		; '\v'
0126+  13B4             _isspace_exit:
0127+  13B4 09          	ret	
0128+  13B5             
0129+  13B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  13B5             ; TO LOWER
0131+  13B5             ; input in AL
0132+  13B5             ; output in AL
0133+  13B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  13B5             _to_lower:
0135+  13B5 B9 5A       	cmp al, 'Z'
0136+  13B7 D1 BC 13    	jgu _to_lower_ret
0137+  13BA 6A 20       	add al, $20				; convert to lower case
0138+  13BC             _to_lower_ret:
0139+  13BC 09          	ret
0140+  13BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  13BD             ; TO UPPER
0142+  13BD             ; input in AL
0143+  13BD             ; output in AL
0144+  13BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  13BD             _to_upper:
0146+  13BD B9 61       	cmp al, 'a'
0147+  13BF C8 C4 13    	jlu _to_upper_ret
0148+  13C2 6F 20       	sub al, $20			; convert to upper case
0149+  13C4             _to_upper_ret:
0150+  13C4 09          	ret
0151+  13C5             
2545   13C5             .include "lib/token.asm"
0001+  13C5             TOKTYP_IDENTIFIER  .equ 0
0002+  13C5             TOKTYP_KEYWORD     .equ 1
0003+  13C5             TOKTYP_DELIMITER   .equ 2
0004+  13C5             TOKTYP_STRING      .equ 3
0005+  13C5             TOKTYP_CHAR        .equ 4
0006+  13C5             TOKTYP_NUMERIC     .equ 5
0007+  13C5             TOKTYP_END         .equ 6
0008+  13C5             
0009+  13C5             TOK_NULL           .equ 0
0010+  13C5             TOK_FSLASH         .equ 1
0011+  13C5             TOK_TIMES          .equ 2
0012+  13C5             TOK_PLUS           .equ 3
0013+  13C5             TOK_MINUS          .equ 4
0014+  13C5             TOK_DOT            .equ 5
0015+  13C5             TOK_SEMI           .equ 6
0016+  13C5             TOK_ANGLE          .equ 7
0017+  13C5             TOK_TILDE          .equ 8
0018+  13C5             TOK_EQUAL          .equ 9
0019+  13C5             TOK_COLON          .equ 10
0020+  13C5             TOK_COMMA          .equ 11
0021+  13C5             
0022+  13C5             TOK_END            .equ 20
0023+  13C5             
0024+  13C5             
0025+  13C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  13C5             ;; read a full command argment from shell input buffer
0027+  13C5             ;; argument is written into tokstr
0028+  13C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  13C5             get_arg:
0030+  13C5 D7            push a
0031+  13C6 E2            push si
0032+  13C7 E3            push di
0033+  13C8 19 00         mov al, 0
0034+  13CA 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0035+  13CD 14 EF 15      mov a, [prog]
0036+  13D0 4D            mov si, a
0037+  13D1 FD 4F F3 15   mov di, tokstr
0038+  13D5             get_arg_skip_spaces:
0039+  13D5 F6            lodsb
0040+  13D6 07 9E 13      call _isspace
0041+  13D9 C6 D5 13      je get_arg_skip_spaces
0042+  13DC             get_arg_L0:
0043+  13DC B9 3B         cmp al, $3B        ; check if is ';'
0044+  13DE C6 EB 13      je get_arg_end
0045+  13E1 B9 00         cmp al, 0
0046+  13E3 C6 EB 13      je get_arg_end      ; check if end of input
0047+  13E6 F7            stosb
0048+  13E7 F6            lodsb
0049+  13E8 0A DC 13      jmp get_arg_L0
0050+  13EB             get_arg_end:
0051+  13EB 19 00         mov al, 0
0052+  13ED F7            stosb
0053+  13EE D5 01 00      sub si, 1
0054+  13F1 4E            mov a, si
0055+  13F2 42 EF 15      mov [prog], a    ; update pointer
0056+  13F5 F0            pop di
0057+  13F6 EF            pop si
0058+  13F7 E4            pop a
0059+  13F8 09            ret
0060+  13F9             
0061+  13F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  13F9             ;; read a path formation from shell input buffer
0063+  13F9             ;; path is written into tokstr
0064+  13F9             ;; /usr/bin
0065+  13F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  13F9             get_path:
0067+  13F9 D7            push a
0068+  13FA E2            push si
0069+  13FB E3            push di
0070+  13FC 19 00         mov al, 0
0071+  13FE 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0072+  1401 14 EF 15      mov a, [prog]
0073+  1404 4D            mov si, a
0074+  1405 FD 4F F3 15   mov di, tokstr
0075+  1409             get_path_skip_spaces:
0076+  1409 F6            lodsb
0077+  140A 07 9E 13      call _isspace
0078+  140D C6 09 14      je get_path_skip_spaces
0079+  1410             get_path_is_pathchar:
0080+  1410 F7            stosb
0081+  1411 F6            lodsb
0082+  1412 07 28 13      call _isalnum      ;check if is alphanumeric
0083+  1415 C6 10 14      je get_path_is_pathchar
0084+  1418 B9 2F         cmp al, '/'        ; check if is '/'
0085+  141A C6 10 14      je get_path_is_pathchar
0086+  141D 19 00         mov al, 0
0087+  141F F7            stosb
0088+  1420 D5 01 00      sub si, 1
0089+  1423 4E            mov a, si
0090+  1424 42 EF 15      mov [prog], a    ; update pointer
0091+  1427             get_path_end:
0092+  1427 F0            pop di
0093+  1428 EF            pop si
0094+  1429 E4            pop a
0095+  142A 09            ret
0096+  142B             
0097+  142B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  142B             ;; read a line
0099+  142B             ;; line is written into tokstr
0100+  142B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  142B             get_line:
0102+  142B D7            push a
0103+  142C E2            push si
0104+  142D E3            push di
0105+  142E 19 00         mov al, 0
0106+  1430 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0107+  1433 14 EF 15      mov a, [prog]
0108+  1436 4D            mov si, a
0109+  1437 FD 4F F3 15   mov di, tokstr
0110+  143B             get_line_L0:
0111+  143B F6            lodsb
0112+  143C B9 0A         cmp al, $0A    ; check for new line
0113+  143E C6 45 14      je get_line_exit
0114+  1441 F7            stosb
0115+  1442 0A 3B 14      jmp get_line_L0
0116+  1445             get_line_exit:
0117+  1445 19 00         mov al, 0
0118+  1447 F7            stosb
0119+  1448 4E            mov a, si
0120+  1449 42 EF 15      mov [prog], a    ; update pointer
0121+  144C F0            pop di
0122+  144D EF            pop si
0123+  144E E4            pop a
0124+  144F 09            ret
0125+  1450             
0126+  1450             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1450             ;; token parser
0128+  1450             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1450             get_token:
0130+  1450 D7            push a
0131+  1451 DA            push d
0132+  1452 E2            push si
0133+  1453 E3            push di
0134+  1454 19 00         mov al, 0
0135+  1456 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0136+  1459 19 00         mov al, TOK_NULL
0137+  145B 3D F2 15      mov [tok], al        ; nullify token
0138+  145E 14 EF 15      mov a, [prog]
0139+  1461 4D            mov si, a
0140+  1462 FD 4F F3 15   mov di, tokstr
0141+  1466             get_tok_skip_spaces:
0142+  1466 F6            lodsb
0143+  1467 07 9E 13      call _isspace
0144+  146A C6 66 14      je get_tok_skip_spaces
0145+  146D B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  146F C6 54 15      je get_token_end
0147+  1472 B9 23         cmp al, '#'      ; comments!
0148+  1474 C6 82 15      je get_tok_comment
0149+  1477 07 28 13      call _isalnum
0150+  147A C6 61 15      jz is_alphanumeric
0151+  147D             ; other token types
0152+  147D             get_token_slash:
0153+  147D B9 2F         cmp al, '/'        ; check if '/'
0154+  147F C7 97 14      jne get_token_minus
0155+  1482 F7            stosb          ; store '/' into token string
0156+  1483 19 00         mov al, 0
0157+  1485 F7            stosb          ; terminate token string
0158+  1486 19 01         mov al, TOK_FSLASH
0159+  1488 3D F2 15      mov [tok], al      
0160+  148B 19 02         mov al, TOKTYP_DELIMITER
0161+  148D 3D F1 15      mov [toktyp], al
0162+  1490 4E            mov a, si
0163+  1491 42 EF 15      mov [prog], a    ; update pointer
0164+  1494 0A 7D 15      jmp get_token_return
0165+  1497             get_token_minus:
0166+  1497 B9 2D         cmp al, '-'        ; check if '-'
0167+  1499 C7 B1 14      jne get_token_comma
0168+  149C F7            stosb          ; store '-' into token string
0169+  149D 19 00         mov al, 0
0170+  149F F7            stosb          ; terminate token string
0171+  14A0 19 04         mov al, TOK_MINUS
0172+  14A2 3D F2 15      mov [tok], al      
0173+  14A5 19 02         mov al, TOKTYP_DELIMITER
0174+  14A7 3D F1 15      mov [toktyp], al
0175+  14AA 4E            mov a, si
0176+  14AB 42 EF 15      mov [prog], a    ; update pointer
0177+  14AE 0A 7D 15      jmp get_token_return
0178+  14B1             get_token_comma:
0179+  14B1 B9 2C         cmp al, ','        ; check if ','
0180+  14B3 C7 CB 14      jne get_token_semi
0181+  14B6 F7            stosb          ; store ',' into token string
0182+  14B7 19 00         mov al, 0
0183+  14B9 F7            stosb          ; terminate token string
0184+  14BA 19 0B         mov al, TOK_COMMA
0185+  14BC 3D F2 15      mov [tok], al      
0186+  14BF 19 02         mov al, TOKTYP_DELIMITER
0187+  14C1 3D F1 15      mov [toktyp], al
0188+  14C4 4E            mov a, si
0189+  14C5 42 EF 15      mov [prog], a    ; update pointer
0190+  14C8 0A 7D 15      jmp get_token_return
0191+  14CB             get_token_semi:
0192+  14CB B9 3B         cmp al, $3B        ; check if ';'
0193+  14CD C7 E5 14      jne get_token_colon
0194+  14D0 F7            stosb          ; store ';' into token string
0195+  14D1 19 00         mov al, 0
0196+  14D3 F7            stosb          ; terminate token string
0197+  14D4 19 06         mov al, TOK_SEMI
0198+  14D6 3D F2 15      mov [tok], al      
0199+  14D9 19 02         mov al, TOKTYP_DELIMITER
0200+  14DB 3D F1 15      mov [toktyp], al
0201+  14DE 4E            mov a, si
0202+  14DF 42 EF 15      mov [prog], a    ; update pointer
0203+  14E2 0A 7D 15      jmp get_token_return
0204+  14E5             get_token_colon:
0205+  14E5 B9 3A         cmp al, $3A        ; check if ':'
0206+  14E7 C7 FF 14      jne get_token_angle
0207+  14EA F7            stosb          ; store ':' into token string
0208+  14EB 19 00         mov al, 0
0209+  14ED F7            stosb          ; terminate token string
0210+  14EE 19 0A         mov al, TOK_COLON
0211+  14F0 3D F2 15      mov [tok], al      
0212+  14F3 19 02         mov al, TOKTYP_DELIMITER
0213+  14F5 3D F1 15      mov [toktyp], al
0214+  14F8 4E            mov a, si
0215+  14F9 42 EF 15      mov [prog], a    ; update pointer
0216+  14FC 0A 7D 15      jmp get_token_return
0217+  14FF             get_token_angle:
0218+  14FF B9 3E         cmp al, $3E        ; check if '>'
0219+  1501 C7 19 15      jne get_token_tilde
0220+  1504 F7            stosb          ; store '>' into token string
0221+  1505 19 00         mov al, 0
0222+  1507 F7            stosb          ; terminate token string
0223+  1508 19 07         mov al, TOK_ANGLE
0224+  150A 3D F2 15      mov [tok], al      
0225+  150D 19 02         mov al, TOKTYP_DELIMITER
0226+  150F 3D F1 15      mov [toktyp], al
0227+  1512 4E            mov a, si
0228+  1513 42 EF 15      mov [prog], a    ; update pointer
0229+  1516 0A 7D 15      jmp get_token_return
0230+  1519             get_token_tilde:
0231+  1519 B9 7E         cmp al, '~'        ; check if '~'
0232+  151B C7 33 15      jne get_token_equal
0233+  151E F7            stosb          ; store '~' into token string
0234+  151F 19 00         mov al, 0
0235+  1521 F7            stosb          ; terminate token string
0236+  1522 19 08         mov al, TOK_TILDE
0237+  1524 3D F2 15      mov [tok], al      
0238+  1527 19 02         mov al, TOKTYP_DELIMITER
0239+  1529 3D F1 15      mov [toktyp], al
0240+  152C 4E            mov a, si
0241+  152D 42 EF 15      mov [prog], a    ; update pointer
0242+  1530 0A 7D 15      jmp get_token_return
0243+  1533             get_token_equal:
0244+  1533 B9 3D         cmp al, '='        ; check if '='
0245+  1535 C7 4D 15      jne get_token_skip
0246+  1538 F7            stosb          ; store '=' into token string
0247+  1539 19 00         mov al, 0
0248+  153B F7            stosb          ; terminate token string
0249+  153C 19 09         mov al, TOK_EQUAL
0250+  153E 3D F2 15      mov [tok], al      
0251+  1541 19 02         mov al, TOKTYP_DELIMITER
0252+  1543 3D F1 15      mov [toktyp], al
0253+  1546 4E            mov a, si
0254+  1547 42 EF 15      mov [prog], a    ; update pointer
0255+  154A 0A 7D 15      jmp get_token_return
0256+  154D             get_token_skip:
0257+  154D 4E            mov a, si
0258+  154E 42 EF 15      mov [prog], a    ; update pointer
0259+  1551 0A 7D 15      jmp get_token_return
0260+  1554             get_token_end:        ; end of file token
0261+  1554 19 14         mov al, TOK_END
0262+  1556 3D F2 15      mov [tok], al
0263+  1559 19 06         mov al, TOKTYP_END
0264+  155B 3D F1 15      mov [toktyp], al
0265+  155E 0A 7D 15      jmp get_token_return
0266+  1561             is_alphanumeric:
0267+  1561 F7            stosb
0268+  1562 F6            lodsb
0269+  1563 07 28 13      call _isalnum      ;check if is alphanumeric
0270+  1566 C6 61 15      jz is_alphanumeric
0271+  1569 B9 2E         cmp al, $2E        ; check if is '.'
0272+  156B C6 61 15      je is_alphanumeric
0273+  156E 19 00         mov al, 0
0274+  1570 F7            stosb
0275+  1571 19 00         mov al, TOKTYP_IDENTIFIER
0276+  1573 3D F1 15      mov [toktyp], al
0277+  1576 D5 01 00      sub si, 1
0278+  1579 4E            mov a, si
0279+  157A 42 EF 15      mov [prog], a    ; update pointer
0280+  157D             get_token_return:
0281+  157D F0            pop di
0282+  157E EF            pop si
0283+  157F E7            pop d
0284+  1580 E4            pop a
0285+  1581 09            ret
0286+  1582             get_tok_comment:
0287+  1582 F6            lodsb
0288+  1583 B9 0A         cmp al, $0A      ; new line
0289+  1585 C7 82 15      jne get_tok_comment
0290+  1588 0A 66 14      jmp get_tok_skip_spaces
0291+  158B             
0292+  158B             
0293+  158B             get_number:
0294+  158B D7            push a
0295+  158C DA            push d
0296+  158D E2            push si
0297+  158E E3            push di
0298+  158F 19 00         mov al, 0
0299+  1591 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0300+  1594 19 00         mov al, TOK_NULL
0301+  1596 3D F2 15      mov [tok], al        ; nullify token
0302+  1599 14 EF 15      mov a, [prog]
0303+  159C 4D            mov si, a
0304+  159D FD 4F F3 15   mov di, tokstr
0305+  15A1             get_number_skip_spaces:
0306+  15A1 F6            lodsb
0307+  15A2 07 9E 13      call _isspace
0308+  15A5 C6 A1 15      je get_number_skip_spaces
0309+  15A8 B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  15AA C7 BA 15      jne get_number_L0
0311+  15AD 19 14         mov al, TOK_END
0312+  15AF 3D F2 15      mov [tok], al
0313+  15B2 19 06         mov al, TOKTYP_END
0314+  15B4 3D F1 15      mov [toktyp], al
0315+  15B7 0A D1 15      jmp get_number_return
0316+  15BA             get_number_L0:
0317+  15BA F7            stosb
0318+  15BB F6            lodsb
0319+  15BC 07 32 13      call _isdigit      ;check if is numeric
0320+  15BF C6 BA 15      jz get_number_L0
0321+  15C2 19 00         mov al, 0
0322+  15C4 F7            stosb
0323+  15C5 19 05         mov al, TOKTYP_NUMERIC
0324+  15C7 3D F1 15      mov [toktyp], al
0325+  15CA D5 01 00      sub si, 1
0326+  15CD 4E            mov a, si
0327+  15CE 42 EF 15      mov [prog], a    ; update pointer
0328+  15D1             get_number_return:
0329+  15D1 F0            pop di
0330+  15D2 EF            pop si
0331+  15D3 E7            pop d
0332+  15D4 E4            pop a
0333+  15D5 09            ret
0334+  15D6             
0335+  15D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  15D6             ;; PUT BACK TOKEN
0337+  15D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  15D6             _putback:
0339+  15D6 D7            push a
0340+  15D7 E2            push si
0341+  15D8 FD 4D F3 15   mov si, tokstr  
0342+  15DC             _putback_loop:
0343+  15DC F6            lodsb
0344+  15DD B9 00         cmp al, 0
0345+  15DF C6 EC 15      je _putback_end
0346+  15E2 14 EF 15      mov a, [prog]
0347+  15E5 7D            dec a
0348+  15E6 42 EF 15      mov [prog], a      ; update pointer
0349+  15E9 0A DC 15      jmp _putback_loop
0350+  15EC             _putback_end:
0351+  15EC EF            pop si
0352+  15ED E4            pop a
0353+  15EE 09            ret
0354+  15EF             
0355+  15EF             
0356+  15EF             
0357+  15EF             
0358+  15EF 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  15F1             
0360+  15F1 00          toktyp:    .db 0          ; token type symbol
0361+  15F2 00          tok:       .db 0          ; current token symbol
0362+  15F3 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  15F7 00 00 00 00 
0362+  15FB 00 00 00 00 
0362+  15FF 00 00 00 00 
0362+  1603 00 00 00 00 
0362+  1607 00 00 00 00 
0362+  160B 00 00 00 00 
0362+  160F 00 00 00 00 
0362+  1613 00 00 00 00 
0362+  1617 00 00 00 00 
0362+  161B 00 00 00 00 
0362+  161F 00 00 00 00 
0362+  1623 00 00 00 00 
0362+  1627 00 00 00 00 
0362+  162B 00 00 00 00 
0362+  162F 00 00 00 00 
0362+  1633 00 00 00 00 
0362+  1637 00 00 00 00 
0362+  163B 00 00 00 00 
0362+  163F 00 00 00 00 
0362+  1643 00 00 00 00 
0362+  1647 00 00 00 00 
0362+  164B 00 00 00 00 
0362+  164F 00 00 00 00 
0362+  1653 00 00 00 00 
0362+  1657 00 00 00 00 
0362+  165B 00 00 00 00 
0362+  165F 00 00 00 00 
0362+  1663 00 00 00 00 
0362+  1667 00 00 00 00 
0362+  166B 00 00 00 00 
0362+  166F 00 00 00 00 
0362+  1673 00 00 00 00 
0362+  1677 00 00 00 00 
0362+  167B 00 00 00 00 
0362+  167F 00 00 00 00 
0362+  1683 00 00 00 00 
0362+  1687 00 00 00 00 
0362+  168B 00 00 00 00 
0362+  168F 00 00 00 00 
0362+  1693 00 00 00 00 
0362+  1697 00 00 00 00 
0362+  169B 00 00 00 00 
0362+  169F 00 00 00 00 
0362+  16A3 00 00 00 00 
0362+  16A7 00 00 00 00 
0362+  16AB 00 00 00 00 
0362+  16AF 00 00 00 00 
0362+  16B3 00 00 00 00 
0362+  16B7 00 00 00 00 
0362+  16BB 00 00 00 00 
0362+  16BF 00 00 00 00 
0362+  16C3 00 00 00 00 
0362+  16C7 00 00 00 00 
0362+  16CB 00 00 00 00 
0362+  16CF 00 00 00 00 
0362+  16D3 00 00 00 00 
0362+  16D7 00 00 00 00 
0362+  16DB 00 00 00 00 
0362+  16DF 00 00 00 00 
0362+  16E3 00 00 00 00 
0362+  16E7 00 00 00 00 
0362+  16EB 00 00 00 00 
0362+  16EF 00 00 00 00 
2546   16F3             
2547   16F3             ; kernel parameters
2548   16F3 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2549   16F4 01          sys_echo_on:        .db 1
2550   16F5 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2551   16F6 01          sys_uart0_inten:    .db 1
2552   16F7 00          sys_uart0_fifoen:   .db 0
2553   16F8 0C          sys_uart0_div0:     .db 12  ;
2554   16F9 00          sys_uart0_div1:     .db 0   ; default baud = 9600
2555   16FA             ; Baud  Divisor
2556   16FA             ; 50    2304
2557   16FA             ; 110   1047
2558   16FA             ; 300    384
2559   16FA             ; 600    192
2560   16FA             ; 1200    96
2561   16FA             ; 9600    12
2562   16FA             ; 19200    6
2563   16FA             ; 38400    3
2564   16FA             
2565   16FA 00          nbr_active_procs:   .db 0
2566   16FB 01          active_proc_index:  .db 1
2567   16FC             
2568   16FC 00 00       index:              .dw 0
2569   16FE 00 00       buffer_addr:        .dw 0
2570   1700             
2571   1700 FF 1D       fifo_in:            .dw fifo
2572   1702 FF 1D       fifo_out:           .dw fifo
2573   1704             
2574   1704             ; file system variables
2575   1704 00 00       current_dir_id:     .dw 0     ; keep dirID of current directory
2576   1706 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2576   170A 6E 2F 69 6E 
2576   170E 69 74 00 
2577   1711             
2578   1711 3E 20 00    s_dataentry:        .db "> ", 0
2579   1714 2E 2E 00    s_parent_dir:       .db "..", 0
2580   1717 2E 00       s_current_dir:      .db ".", 0
2581   1719 2F 00       s_fslash:           .db "/", 0
2582   171B 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2582   171F 78 
2583   1720 2D 64 63    file_type:          .db "-dc"
2584   1723 50 49 44 20 s_ps_header:        .db "PID COMMAND\n", 0
2584   1727 43 4F 4D 4D 
2584   172B 41 4E 44 0A 
2584   172F 00 
2585   1730 54 6F 74 61 s_ls_total:         .db "Total: ", 0
2585   1734 6C 3A 20 00 
2586   1738             
2587   1738 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2587   173C 20 65 6E 61 
2587   1740 62 6C 65 64 
2587   1744 0A 00 
2588   1746 6B 65 72 6E s_kernel_started:   .db "kernel started(version 1.0)\n", 0
2588   174A 65 6C 20 73 
2588   174E 74 61 72 74 
2588   1752 65 64 28 76 
2588   1756 65 72 73 69 
2588   175A 6F 6E 20 31 
2588   175E 2E 30 29 0A 
2588   1762 00 
2589   1763 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2589   1767 74 69 6E 67 
2589   176B 20 69 6E 69 
2589   176F 74 0A 00 
2590   1772 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2590   1776 65 70 74 69 
2590   177A 6F 6E 3A 20 
2590   177E 70 72 69 76 
2590   1782 69 6C 65 67 
2590   1786 65 0A 00 
2591   1789 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2591   178D 65 70 74 69 
2591   1791 6F 6E 3A 20 
2591   1795 7A 65 72 6F 
2591   1799 20 64 69 76 
2591   179D 69 73 69 6F 
2591   17A1 6E 0A 00 
2592   17A4             
2593   17A4 59 65 61 72 s_set_year:         .db "Year: ", 0
2593   17A8 3A 20 00 
2594   17AB 4D 6F 6E 74 s_set_month:        .db "Month: ", 0
2594   17AF 68 3A 20 00 
2595   17B3 44 61 79 3A s_set_day:          .db "Day: ", 0
2595   17B7 20 00 
2596   17B9 57 65 65 6B s_set_week:         .db "Weekday: ", 0
2596   17BD 64 61 79 3A 
2596   17C1 20 00 
2597   17C3 48 6F 75 72 s_set_hours:        .db "Hours: ", 0
2597   17C7 73 3A 20 00 
2598   17CB 4D 69 6E 75 s_set_minutes:      .db "Minutes: ", 0
2598   17CF 74 65 73 3A 
2598   17D3 20 00 
2599   17D5 53 65 63 6F s_set_seconds:      .db "Seconds: ", 0
2599   17D9 6E 64 73 3A 
2599   17DD 20 00 
2600   17DF             s_months:      
2601   17DF 20 20 20 00   .db "   ", 0
2602   17E3 4A 61 6E 00   .db "Jan", 0
2603   17E7 46 65 62 00   .db "Feb", 0
2604   17EB 4D 61 72 00   .db "Mar", 0
2605   17EF 41 70 72 00   .db "Apr", 0
2606   17F3 4D 61 79 00   .db "May", 0
2607   17F7 4A 75 6E 00   .db "Jun", 0
2608   17FB 4A 75 6C 00   .db "Jul", 0
2609   17FF 41 75 67 00   .db "Aug", 0
2610   1803 53 65 70 00   .db "Sep", 0
2611   1807 4F 63 74 00   .db "Oct", 0
2612   180B 4E 6F 76 00   .db "Nov", 0
2613   180F 44 65 63 00   .db "Dec", 0
2614   1813             
2615   1813             s_week:        
2616   1813 53 75 6E 00   .db "Sun", 0 
2617   1817 4D 6F 6E 00   .db "Mon", 0 
2618   181B 54 75 65 00   .db "Tue", 0 
2619   181F 57 65 64 00   .db "Wed", 0 
2620   1823 54 68 75 00   .db "Thu", 0 
2621   1827 46 72 69 00   .db "Fri", 0 
2622   182B 53 61 74 00   .db "Sat", 0
2623   182F             
2624   182F 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2624   1833 00 00 00 00 
2624   1837 00 00 00 00 
2624   183B 00 00 00 00 
2624   183F 00 00 00 00 
2624   1843 00 00 00 00 
2624   1847 00 00 00 00 
2624   184B 00 00 00 00 
2624   184F 00 00 00 00 
2624   1853 00 00 00 00 
2624   1857 00 00 00 00 
2624   185B 00 00 00 00 
2624   185F 00 00 00 00 
2624   1863 00 00 00 00 
2624   1867 00 00 00 00 
2624   186B 00 00 00 00 
2624   186F 00 00 00 00 
2624   1873 00 00 00 00 
2624   1877 00 00 00 00 
2624   187B 00 00 00 00 
2624   187F 00 00 00 00 
2624   1883 00 00 00 00 
2624   1887 00 00 00 00 
2624   188B 00 00 00 00 
2624   188F 00 00 00 00 
2624   1893 00 00 00 00 
2624   1897 00 00 00 00 
2624   189B 00 00 00 00 
2624   189F 00 00 00 00 
2624   18A3 00 00 00 00 
2624   18A7 00 00 00 00 
2624   18AB 00 00 00 00 
2624   18AF 00 00 00 00 
2624   18B3 00 00 00 00 
2624   18B7 00 00 00 00 
2624   18BB 00 00 00 00 
2624   18BF 00 00 00 00 
2624   18C3 00 00 00 00 
2624   18C7 00 00 00 00 
2624   18CB 00 00 00 00 
2624   18CF 00 00 00 00 
2624   18D3 00 00 00 00 
2624   18D7 00 00 00 00 
2624   18DB 00 00 00 00 
2624   18DF 00 00 00 00 
2624   18E3 00 00 00 00 
2624   18E7 00 00 00 00 
2624   18EB 00 00 00 00 
2624   18EF 00 00 00 00 
2624   18F3 00 00 00 00 
2624   18F7 00 00 00 00 
2624   18FB 00 00 00 00 
2624   18FF 00 00 00 00 
2624   1903 00 00 00 00 
2624   1907 00 00 00 00 
2624   190B 00 00 00 00 
2624   190F 00 00 00 00 
2624   1913 00 00 00 00 
2624   1917 00 00 00 00 
2624   191B 00 00 00 00 
2624   191F 00 00 00 00 
2624   1923 00 00 00 00 
2624   1927 00 00 00 00 
2624   192B 00 00 00 00 
2624   192F 00 00 00 00 
2624   1933 00 00 00 00 
2624   1937 00 00 00 00 
2624   193B 00 00 00 00 
2624   193F 00 00 00 00 
2624   1943 00 00 00 00 
2624   1947 00 00 00 00 
2624   194B 00 00 00 00 
2624   194F 00 00 00 00 
2624   1953 00 00 00 00 
2624   1957 00 00 00 00 
2624   195B 00 00 00 00 
2624   195F 00 00 00 00 
2624   1963 00 00 00 00 
2624   1967 00 00 00 00 
2624   196B 00 00 00 00 
2625   196F 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2625   1973 00 00 00 00 
2625   1977 00 00 00 00 
2625   197B 00 00 00 00 
2626   197F 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2626   1983 00 00 00 00 
2626   1987 00 00 00 00 
2626   198B 00 00 00 00 
2626   198F 00 00 00 00 
2626   1993 00 00 00 00 
2626   1997 00 00 00 00 
2626   199B 00 00 00 00 
2626   199F 00 00 00 00 
2626   19A3 00 00 00 00 
2626   19A7 00 00 00 00 
2626   19AB 00 00 00 00 
2626   19AF 00 00 00 00 
2626   19B3 00 00 00 00 
2626   19B7 00 00 00 00 
2626   19BB 00 00 00 00 
2626   19BF 00 00 00 00 
2626   19C3 00 00 00 00 
2626   19C7 00 00 00 00 
2626   19CB 00 00 00 00 
2626   19CF 00 00 00 00 
2626   19D3 00 00 00 00 
2626   19D7 00 00 00 00 
2626   19DB 00 00 00 00 
2626   19DF 00 00 00 00 
2626   19E3 00 00 00 00 
2626   19E7 00 00 00 00 
2626   19EB 00 00 00 00 
2626   19EF 00 00 00 00 
2626   19F3 00 00 00 00 
2626   19F7 00 00 00 00 
2626   19FB 00 00 00 00 
2626   19FF 00 00 00 00 
2626   1A03 00 00 00 00 
2626   1A07 00 00 00 00 
2626   1A0B 00 00 00 00 
2626   1A0F 00 00 00 00 
2626   1A13 00 00 00 00 
2626   1A17 00 00 00 00 
2626   1A1B 00 00 00 00 
2626   1A1F 00 00 00 00 
2626   1A23 00 00 00 00 
2626   1A27 00 00 00 00 
2626   1A2B 00 00 00 00 
2626   1A2F 00 00 00 00 
2626   1A33 00 00 00 00 
2626   1A37 00 00 00 00 
2626   1A3B 00 00 00 00 
2626   1A3F 00 00 00 00 
2626   1A43 00 00 00 00 
2626   1A47 00 00 00 00 
2626   1A4B 00 00 00 00 
2626   1A4F 00 00 00 00 
2626   1A53 00 00 00 00 
2626   1A57 00 00 00 00 
2626   1A5B 00 00 00 00 
2626   1A5F 00 00 00 00 
2626   1A63 00 00 00 00 
2626   1A67 00 00 00 00 
2626   1A6B 00 00 00 00 
2626   1A6F 00 00 00 00 
2626   1A73 00 00 00 00 
2626   1A77 00 00 00 00 
2626   1A7B 00 00 00 00 
2626   1A7F 00 00 00 00 
2626   1A83 00 00 00 00 
2626   1A87 00 00 00 00 
2626   1A8B 00 00 00 00 
2626   1A8F 00 00 00 00 
2626   1A93 00 00 00 00 
2626   1A97 00 00 00 00 
2626   1A9B 00 00 00 00 
2626   1A9F 00 00 00 00 
2626   1AA3 00 00 00 00 
2626   1AA7 00 00 00 00 
2626   1AAB 00 00 00 00 
2626   1AAF 00 00 00 00 
2626   1AB3 00 00 00 00 
2626   1AB7 00 00 00 00 
2626   1ABB 00 00 00 00 
2626   1ABF 00 00 00 00 
2626   1AC3 00 00 00 00 
2626   1AC7 00 00 00 00 
2626   1ACB 00 00 00 00 
2626   1ACF 00 00 00 00 
2626   1AD3 00 00 00 00 
2626   1AD7 00 00 00 00 
2626   1ADB 00 00 00 00 
2626   1ADF 00 00 00 00 
2626   1AE3 00 00 00 00 
2626   1AE7 00 00 00 00 
2626   1AEB 00 00 00 00 
2626   1AEF 00 00 00 00 
2626   1AF3 00 00 00 00 
2626   1AF7 00 00 00 00 
2626   1AFB 00 00 00 00 
2626   1AFF 00 00 00 00 
2626   1B03 00 00 00 00 
2626   1B07 00 00 00 00 
2626   1B0B 00 00 00 00 
2626   1B0F 00 00 00 00 
2626   1B13 00 00 00 00 
2626   1B17 00 00 00 00 
2626   1B1B 00 00 00 00 
2626   1B1F 00 00 00 00 
2626   1B23 00 00 00 00 
2626   1B27 00 00 00 00 
2626   1B2B 00 00 00 00 
2626   1B2F 00 00 00 00 
2626   1B33 00 00 00 00 
2626   1B37 00 00 00 00 
2626   1B3B 00 00 00 00 
2626   1B3F 00 00 00 00 
2626   1B43 00 00 00 00 
2626   1B47 00 00 00 00 
2626   1B4B 00 00 00 00 
2626   1B4F 00 00 00 00 
2626   1B53 00 00 00 00 
2626   1B57 00 00 00 00 
2626   1B5B 00 00 00 00 
2626   1B5F 00 00 00 00 
2626   1B63 00 00 00 00 
2626   1B67 00 00 00 00 
2626   1B6B 00 00 00 00 
2626   1B6F 00 00 00 00 
2626   1B73 00 00 00 00 
2626   1B77 00 00 00 00 
2626   1B7B 00 00 00 00 
2627   1B7F 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2627   1B83 00 00 00 00 
2627   1B87 00 00 00 00 
2627   1B8B 00 00 00 00 
2627   1B8F 00 00 00 00 
2627   1B93 00 00 00 00 
2627   1B97 00 00 00 00 
2627   1B9B 00 00 00 00 
2627   1B9F 00 00 00 00 
2627   1BA3 00 00 00 00 
2627   1BA7 00 00 00 00 
2627   1BAB 00 00 00 00 
2627   1BAF 00 00 00 00 
2627   1BB3 00 00 00 00 
2627   1BB7 00 00 00 00 
2627   1BBB 00 00 00 00 
2627   1BBF 00 00 00 00 
2627   1BC3 00 00 00 00 
2627   1BC7 00 00 00 00 
2627   1BCB 00 00 00 00 
2627   1BCF 00 00 00 00 
2627   1BD3 00 00 00 00 
2627   1BD7 00 00 00 00 
2627   1BDB 00 00 00 00 
2627   1BDF 00 00 00 00 
2627   1BE3 00 00 00 00 
2627   1BE7 00 00 00 00 
2627   1BEB 00 00 00 00 
2627   1BEF 00 00 00 00 
2627   1BF3 00 00 00 00 
2627   1BF7 00 00 00 00 
2627   1BFB 00 00 00 00 
2628   1BFF 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2628   1C03 00 00 00 00 
2628   1C07 00 00 00 00 
2628   1C0B 00 00 00 00 
2628   1C0F 00 00 00 00 
2628   1C13 00 00 00 00 
2628   1C17 00 00 00 00 
2628   1C1B 00 00 00 00 
2628   1C1F 00 00 00 00 
2628   1C23 00 00 00 00 
2628   1C27 00 00 00 00 
2628   1C2B 00 00 00 00 
2628   1C2F 00 00 00 00 
2628   1C33 00 00 00 00 
2628   1C37 00 00 00 00 
2628   1C3B 00 00 00 00 
2628   1C3F 00 00 00 00 
2628   1C43 00 00 00 00 
2628   1C47 00 00 00 00 
2628   1C4B 00 00 00 00 
2628   1C4F 00 00 00 00 
2628   1C53 00 00 00 00 
2628   1C57 00 00 00 00 
2628   1C5B 00 00 00 00 
2628   1C5F 00 00 00 00 
2628   1C63 00 00 00 00 
2628   1C67 00 00 00 00 
2628   1C6B 00 00 00 00 
2628   1C6F 00 00 00 00 
2628   1C73 00 00 00 00 
2628   1C77 00 00 00 00 
2628   1C7B 00 00 00 00 
2628   1C7F 00 00 00 00 
2628   1C83 00 00 00 00 
2628   1C87 00 00 00 00 
2628   1C8B 00 00 00 00 
2628   1C8F 00 00 00 00 
2628   1C93 00 00 00 00 
2628   1C97 00 00 00 00 
2628   1C9B 00 00 00 00 
2628   1C9F 00 00 00 00 
2628   1CA3 00 00 00 00 
2628   1CA7 00 00 00 00 
2628   1CAB 00 00 00 00 
2628   1CAF 00 00 00 00 
2628   1CB3 00 00 00 00 
2628   1CB7 00 00 00 00 
2628   1CBB 00 00 00 00 
2628   1CBF 00 00 00 00 
2628   1CC3 00 00 00 00 
2628   1CC7 00 00 00 00 
2628   1CCB 00 00 00 00 
2628   1CCF 00 00 00 00 
2628   1CD3 00 00 00 00 
2628   1CD7 00 00 00 00 
2628   1CDB 00 00 00 00 
2628   1CDF 00 00 00 00 
2628   1CE3 00 00 00 00 
2628   1CE7 00 00 00 00 
2628   1CEB 00 00 00 00 
2628   1CEF 00 00 00 00 
2628   1CF3 00 00 00 00 
2628   1CF7 00 00 00 00 
2628   1CFB 00 00 00 00 
2628   1CFF 00 00 00 00 
2628   1D03 00 00 00 00 
2628   1D07 00 00 00 00 
2628   1D0B 00 00 00 00 
2628   1D0F 00 00 00 00 
2628   1D13 00 00 00 00 
2628   1D17 00 00 00 00 
2628   1D1B 00 00 00 00 
2628   1D1F 00 00 00 00 
2628   1D23 00 00 00 00 
2628   1D27 00 00 00 00 
2628   1D2B 00 00 00 00 
2628   1D2F 00 00 00 00 
2628   1D33 00 00 00 00 
2628   1D37 00 00 00 00 
2628   1D3B 00 00 00 00 
2628   1D3F 00 00 00 00 
2628   1D43 00 00 00 00 
2628   1D47 00 00 00 00 
2628   1D4B 00 00 00 00 
2628   1D4F 00 00 00 00 
2628   1D53 00 00 00 00 
2628   1D57 00 00 00 00 
2628   1D5B 00 00 00 00 
2628   1D5F 00 00 00 00 
2628   1D63 00 00 00 00 
2628   1D67 00 00 00 00 
2628   1D6B 00 00 00 00 
2628   1D6F 00 00 00 00 
2628   1D73 00 00 00 00 
2628   1D77 00 00 00 00 
2628   1D7B 00 00 00 00 
2628   1D7F 00 00 00 00 
2628   1D83 00 00 00 00 
2628   1D87 00 00 00 00 
2628   1D8B 00 00 00 00 
2628   1D8F 00 00 00 00 
2628   1D93 00 00 00 00 
2628   1D97 00 00 00 00 
2628   1D9B 00 00 00 00 
2628   1D9F 00 00 00 00 
2628   1DA3 00 00 00 00 
2628   1DA7 00 00 00 00 
2628   1DAB 00 00 00 00 
2628   1DAF 00 00 00 00 
2628   1DB3 00 00 00 00 
2628   1DB7 00 00 00 00 
2628   1DBB 00 00 00 00 
2628   1DBF 00 00 00 00 
2628   1DC3 00 00 00 00 
2628   1DC7 00 00 00 00 
2628   1DCB 00 00 00 00 
2628   1DCF 00 00 00 00 
2628   1DD3 00 00 00 00 
2628   1DD7 00 00 00 00 
2628   1DDB 00 00 00 00 
2628   1DDF 00 00 00 00 
2628   1DE3 00 00 00 00 
2628   1DE7 00 00 00 00 
2628   1DEB 00 00 00 00 
2628   1DEF 00 00 00 00 
2628   1DF3 00 00 00 00 
2628   1DF7 00 00 00 00 
2628   1DFB 00 00 00 00 
2629   1DFF FF FF FF FF fifo:               .fill FIFO_SIZE
2629   1E03 FF FF FF FF 
2629   1E07 FF FF FF FF 
2629   1E0B FF FF FF FF 
2629   1E0F FF FF FF FF 
2629   1E13 FF FF FF FF 
2629   1E17 FF FF FF FF 
2629   1E1B FF FF FF FF 
2629   1E1F FF FF FF FF 
2629   1E23 FF FF FF FF 
2629   1E27 FF FF FF FF 
2629   1E2B FF FF FF FF 
2629   1E2F FF FF FF FF 
2629   1E33 FF FF FF FF 
2629   1E37 FF FF FF FF 
2629   1E3B FF FF FF FF 
2629   1E3F FF FF FF FF 
2629   1E43 FF FF FF FF 
2629   1E47 FF FF FF FF 
2629   1E4B FF FF FF FF 
2629   1E4F FF FF FF FF 
2629   1E53 FF FF FF FF 
2629   1E57 FF FF FF FF 
2629   1E5B FF FF FF FF 
2629   1E5F FF FF FF FF 
2629   1E63 FF FF FF FF 
2629   1E67 FF FF FF FF 
2629   1E6B FF FF FF FF 
2629   1E6F FF FF FF FF 
2629   1E73 FF FF FF FF 
2629   1E77 FF FF FF FF 
2629   1E7B FF FF FF FF 
2629   1E7F FF FF FF FF 
2629   1E83 FF FF FF FF 
2629   1E87 FF FF FF FF 
2629   1E8B FF FF FF FF 
2629   1E8F FF FF FF FF 
2629   1E93 FF FF FF FF 
2629   1E97 FF FF FF FF 
2629   1E9B FF FF FF FF 
2629   1E9F FF FF FF FF 
2629   1EA3 FF FF FF FF 
2629   1EA7 FF FF FF FF 
2629   1EAB FF FF FF FF 
2629   1EAF FF FF FF FF 
2629   1EB3 FF FF FF FF 
2629   1EB7 FF FF FF FF 
2629   1EBB FF FF FF FF 
2629   1EBF FF FF FF FF 
2629   1EC3 FF FF FF FF 
2629   1EC7 FF FF FF FF 
2629   1ECB FF FF FF FF 
2629   1ECF FF FF FF FF 
2629   1ED3 FF FF FF FF 
2629   1ED7 FF FF FF FF 
2629   1EDB FF FF FF FF 
2629   1EDF FF FF FF FF 
2629   1EE3 FF FF FF FF 
2629   1EE7 FF FF FF FF 
2629   1EEB FF FF FF FF 
2629   1EEF FF FF FF FF 
2629   1EF3 FF FF FF FF 
2629   1EF7 FF FF FF FF 
2629   1EFB FF FF FF FF 
2629   1EFF FF FF FF FF 
2629   1F03 FF FF FF FF 
2629   1F07 FF FF FF FF 
2629   1F0B FF FF FF FF 
2629   1F0F FF FF FF FF 
2629   1F13 FF FF FF FF 
2629   1F17 FF FF FF FF 
2629   1F1B FF FF FF FF 
2629   1F1F FF FF FF FF 
2629   1F23 FF FF FF FF 
2629   1F27 FF FF FF FF 
2629   1F2B FF FF FF FF 
2629   1F2F FF FF FF FF 
2629   1F33 FF FF FF FF 
2629   1F37 FF FF FF FF 
2629   1F3B FF FF FF FF 
2629   1F3F FF FF FF FF 
2629   1F43 FF FF FF FF 
2629   1F47 FF FF FF FF 
2629   1F4B FF FF FF FF 
2629   1F4F FF FF FF FF 
2629   1F53 FF FF FF FF 
2629   1F57 FF FF FF FF 
2629   1F5B FF FF FF FF 
2629   1F5F FF FF FF FF 
2629   1F63 FF FF FF FF 
2629   1F67 FF FF FF FF 
2629   1F6B FF FF FF FF 
2629   1F6F FF FF FF FF 
2629   1F73 FF FF FF FF 
2629   1F77 FF FF FF FF 
2629   1F7B FF FF FF FF 
2629   1F7F FF FF FF FF 
2629   1F83 FF FF FF FF 
2629   1F87 FF FF FF FF 
2629   1F8B FF FF FF FF 
2629   1F8F FF FF FF FF 
2629   1F93 FF FF FF FF 
2629   1F97 FF FF FF FF 
2629   1F9B FF FF FF FF 
2629   1F9F FF FF FF FF 
2629   1FA3 FF FF FF FF 
2629   1FA7 FF FF FF FF 
2629   1FAB FF FF FF FF 
2629   1FAF FF FF FF FF 
2629   1FB3 FF FF FF FF 
2629   1FB7 FF FF FF FF 
2629   1FBB FF FF FF FF 
2629   1FBF FF FF FF FF 
2629   1FC3 FF FF FF FF 
2629   1FC7 FF FF FF FF 
2629   1FCB FF FF FF FF 
2629   1FCF FF FF FF FF 
2629   1FD3 FF FF FF FF 
2629   1FD7 FF FF FF FF 
2629   1FDB FF FF FF FF 
2629   1FDF FF FF FF FF 
2629   1FE3 FF FF FF FF 
2629   1FE7 FF FF FF FF 
2629   1FEB FF FF FF FF 
2629   1FEF FF FF FF FF 
2629   1FF3 FF FF FF FF 
2629   1FF7 FF FF FF FF 
2629   1FFB FF FF FF FF 
2629   1FFF FF FF FF FF 
2629   2003 FF FF FF FF 
2629   2007 FF FF FF FF 
2629   200B FF FF FF FF 
2629   200F FF FF FF FF 
2629   2013 FF FF FF FF 
2629   2017 FF FF FF FF 
2629   201B FF FF FF FF 
2629   201F FF FF FF FF 
2629   2023 FF FF FF FF 
2629   2027 FF FF FF FF 
2629   202B FF FF FF FF 
2629   202F FF FF FF FF 
2629   2033 FF FF FF FF 
2629   2037 FF FF FF FF 
2629   203B FF FF FF FF 
2629   203F FF FF FF FF 
2629   2043 FF FF FF FF 
2629   2047 FF FF FF FF 
2629   204B FF FF FF FF 
2629   204F FF FF FF FF 
2629   2053 FF FF FF FF 
2629   2057 FF FF FF FF 
2629   205B FF FF FF FF 
2629   205F FF FF FF FF 
2629   2063 FF FF FF FF 
2629   2067 FF FF FF FF 
2629   206B FF FF FF FF 
2629   206F FF FF FF FF 
2629   2073 FF FF FF FF 
2629   2077 FF FF FF FF 
2629   207B FF FF FF FF 
2629   207F FF FF FF FF 
2629   2083 FF FF FF FF 
2629   2087 FF FF FF FF 
2629   208B FF FF FF FF 
2629   208F FF FF FF FF 
2629   2093 FF FF FF FF 
2629   2097 FF FF FF FF 
2629   209B FF FF FF FF 
2629   209F FF FF FF FF 
2629   20A3 FF FF FF FF 
2629   20A7 FF FF FF FF 
2629   20AB FF FF FF FF 
2629   20AF FF FF FF FF 
2629   20B3 FF FF FF FF 
2629   20B7 FF FF FF FF 
2629   20BB FF FF FF FF 
2629   20BF FF FF FF FF 
2629   20C3 FF FF FF FF 
2629   20C7 FF FF FF FF 
2629   20CB FF FF FF FF 
2629   20CF FF FF FF FF 
2629   20D3 FF FF FF FF 
2629   20D7 FF FF FF FF 
2629   20DB FF FF FF FF 
2629   20DF FF FF FF FF 
2629   20E3 FF FF FF FF 
2629   20E7 FF FF FF FF 
2629   20EB FF FF FF FF 
2629   20EF FF FF FF FF 
2629   20F3 FF FF FF FF 
2629   20F7 FF FF FF FF 
2629   20FB FF FF FF FF 
2629   20FF FF FF FF FF 
2629   2103 FF FF FF FF 
2629   2107 FF FF FF FF 
2629   210B FF FF FF FF 
2629   210F FF FF FF FF 
2629   2113 FF FF FF FF 
2629   2117 FF FF FF FF 
2629   211B FF FF FF FF 
2629   211F FF FF FF FF 
2629   2123 FF FF FF FF 
2629   2127 FF FF FF FF 
2629   212B FF FF FF FF 
2629   212F FF FF FF FF 
2629   2133 FF FF FF FF 
2629   2137 FF FF FF FF 
2629   213B FF FF FF FF 
2629   213F FF FF FF FF 
2629   2143 FF FF FF FF 
2629   2147 FF FF FF FF 
2629   214B FF FF FF FF 
2629   214F FF FF FF FF 
2629   2153 FF FF FF FF 
2629   2157 FF FF FF FF 
2629   215B FF FF FF FF 
2629   215F FF FF FF FF 
2629   2163 FF FF FF FF 
2629   2167 FF FF FF FF 
2629   216B FF FF FF FF 
2629   216F FF FF FF FF 
2629   2173 FF FF FF FF 
2629   2177 FF FF FF FF 
2629   217B FF FF FF FF 
2629   217F FF FF FF FF 
2629   2183 FF FF FF FF 
2629   2187 FF FF FF FF 
2629   218B FF FF FF FF 
2629   218F FF FF FF FF 
2629   2193 FF FF FF FF 
2629   2197 FF FF FF FF 
2629   219B FF FF FF FF 
2629   219F FF FF FF FF 
2629   21A3 FF FF FF FF 
2629   21A7 FF FF FF FF 
2629   21AB FF FF FF FF 
2629   21AF FF FF FF FF 
2629   21B3 FF FF FF FF 
2629   21B7 FF FF FF FF 
2629   21BB FF FF FF FF 
2629   21BF FF FF FF FF 
2629   21C3 FF FF FF FF 
2629   21C7 FF FF FF FF 
2629   21CB FF FF FF FF 
2629   21CF FF FF FF FF 
2629   21D3 FF FF FF FF 
2629   21D7 FF FF FF FF 
2629   21DB FF FF FF FF 
2629   21DF FF FF FF FF 
2629   21E3 FF FF FF FF 
2629   21E7 FF FF FF FF 
2629   21EB FF FF FF FF 
2629   21EF FF FF FF FF 
2629   21F3 FF FF FF FF 
2629   21F7 FF FF FF FF 
2629   21FB FF FF FF FF 
2630   21FF             
2631   21FF FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2631   2203 FF FF FF FF 
2631   2207 FF FF FF FF 
2631   220B FF FF FF FF 
2631   220F FF FF FF FF 
2631   2213 FF FF FF FF 
2631   2217 FF FF FF FF 
2631   221B FF FF FF FF 
2631   221F FF FF FF FF 
2631   2223 FF FF FF FF 
2631   2227 FF FF FF FF 
2631   222B FF FF FF FF 
2631   222F FF FF FF FF 
2631   2233 FF FF FF FF 
2631   2237 FF FF FF FF 
2631   223B FF FF FF FF 
2631   223F FF FF FF FF 
2631   2243 FF FF FF FF 
2631   2247 FF FF FF FF 
2631   224B FF FF FF FF 
2631   224F FF FF FF FF 
2631   2253 FF FF FF FF 
2631   2257 FF FF FF FF 
2631   225B FF FF FF FF 
2631   225F FF FF FF FF 
2631   2263 FF FF FF FF 
2631   2267 FF FF FF FF 
2631   226B FF FF FF FF 
2631   226F FF FF FF FF 
2631   2273 FF FF FF FF 
2631   2277 FF FF FF FF 
2631   227B FF FF FF FF 
2631   227F FF FF FF FF 
2631   2283 FF FF FF FF 
2631   2287 FF FF FF FF 
2631   228B FF FF FF FF 
2631   228F FF FF FF FF 
2631   2293 FF FF FF FF 
2631   2297 FF FF FF FF 
2631   229B FF FF FF FF 
2631   229F FF FF FF FF 
2631   22A3 FF FF FF FF 
2631   22A7 FF FF FF FF 
2631   22AB FF FF FF FF 
2631   22AF FF FF FF FF 
2631   22B3 FF FF FF FF 
2631   22B7 FF FF FF FF 
2631   22BB FF FF FF FF 
2631   22BF FF FF FF FF 
2631   22C3 FF FF FF FF 
2631   22C7 FF FF FF FF 
2631   22CB FF FF FF FF 
2631   22CF FF FF FF FF 
2631   22D3 FF FF FF FF 
2631   22D7 FF FF FF FF 
2631   22DB FF FF FF FF 
2631   22DF FF FF FF FF 
2631   22E3 FF FF FF FF 
2631   22E7 FF FF FF FF 
2631   22EB FF FF FF FF 
2631   22EF FF FF FF FF 
2631   22F3 FF FF FF FF 
2631   22F7 FF FF FF FF 
2631   22FB FF FF FF FF 
2631   22FF FF FF FF FF 
2631   2303 FF FF FF FF 
2631   2307 FF FF FF FF 
2631   230B FF FF FF FF 
2631   230F FF FF FF FF 
2631   2313 FF FF FF FF 
2631   2317 FF FF FF FF 
2631   231B FF FF FF FF 
2631   231F FF FF FF FF 
2631   2323 FF FF FF FF 
2631   2327 FF FF FF FF 
2631   232B FF FF FF FF 
2631   232F FF FF FF FF 
2631   2333 FF FF FF FF 
2631   2337 FF FF FF FF 
2631   233B FF FF FF FF 
2631   233F FF FF FF FF 
2631   2343 FF FF FF FF 
2631   2347 FF FF FF FF 
2631   234B FF FF FF FF 
2631   234F FF FF FF FF 
2631   2353 FF FF FF FF 
2631   2357 FF FF FF FF 
2631   235B FF FF FF FF 
2631   235F FF FF FF FF 
2631   2363 FF FF FF FF 
2631   2367 FF FF FF FF 
2631   236B FF FF FF FF 
2631   236F FF FF FF FF 
2631   2373 FF FF FF FF 
2631   2377 FF FF FF FF 
2631   237B FF FF FF FF 
2631   237F FF FF FF FF 
2631   2383 FF FF FF FF 
2631   2387 FF FF FF FF 
2631   238B FF FF FF FF 
2631   238F FF FF FF FF 
2631   2393 FF FF FF FF 
2631   2397 FF FF FF FF 
2631   239B FF FF FF FF 
2631   239F FF FF FF FF 
2631   23A3 FF FF FF FF 
2631   23A7 FF FF FF FF 
2631   23AB FF FF FF FF 
2631   23AF FF FF FF FF 
2631   23B3 FF FF FF FF 
2631   23B7 FF FF FF FF 
2631   23BB FF FF FF FF 
2631   23BF FF FF FF FF 
2631   23C3 FF FF FF FF 
2631   23C7 FF FF FF FF 
2631   23CB FF FF FF FF 
2631   23CF FF FF FF FF 
2631   23D3 FF FF FF FF 
2631   23D7 FF FF FF FF 
2631   23DB FF FF FF FF 
2631   23DF FF FF FF FF 
2631   23E3 FF FF FF FF 
2631   23E7 FF FF FF FF 
2631   23EB FF FF FF FF 
2631   23EF FF FF FF FF 
2631   23F3 FF FF FF FF 
2631   23F7 FF FF FF FF 
2631   23FB FF FF FF FF 
2632   23FF 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2633   2400             
2634   2400             
2635   2400             .end
tasm: Number of errors = 0
