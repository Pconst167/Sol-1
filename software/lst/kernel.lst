0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             ; Memory Map
0005   0000             ; ------------------------------------------------------------------------------------------------------------------;
0006   0000             ; 0000    ROM BEGIN
0007   0000             ; ....
0008   0000             ; 7FFF    ROM END
0009   0000             ;
0010   0000             ; 8000    RAM begin
0011   0000             ; ....
0012   0000             ; F7FF    Stack root
0013   0000             ; ------------------------------------------------------------------------------------------------------------------;
0014   0000             ; I/O MAP
0015   0000             ; ------------------------------------------------------------------------------------------------------------------;
0016   0000             ; FF80    UART 0              (16550)
0017   0000             ; FF90    UART 1              (16550)
0018   0000             ; FFA0    RTC                 (M48T02)
0019   0000             ; FFB0    PIO 0               (8255)
0020   0000             ; FFC0    5.25" Floppy Drive Block
0021   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0022   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0023   0000             ;   - FFC2      FDC         (WD1770 Floppy Drive Controller) 
0024   0000             ;      
0025   0000             ; FFD0    IDE                 (Compact Flash / PATA)
0026   0000             ; FFE0    Timer               (8253)
0027   0000             ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             XON               .equ $11
0050   0000             XOFF              .equ $13
0051   0000             
0052   0000             _ide_BASE         .equ $FFD0            ; IDE BASE
0053   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0054   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0055   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0056   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0057   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0058   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0059   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0060   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0061   0000             
0062   0000             _7SEG_DISPLAY     .equ $FFB0            ; BIOS POST CODE HEX DISPLAY (2 DIGITS) (CONNECTED TO PIO A)
0063   0000             _BIOS_POST_CTRL   .equ $FFB3            ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0064   0000             _PIO_A            .equ $FFB0    
0065   0000             _PIO_B            .equ $FFB1
0066   0000             _PIO_C            .equ $FFB2
0067   0000             _PIO_CONTROL      .equ $FFB3            ; PIO CONTROL PORT
0068   0000             
0069   0000             _TIMER_C_0        .equ $FFE0            ; TIMER COUNTER 0
0070   0000             _TIMER_C_1        .equ $FFE1            ; TIMER COUNTER 1
0071   0000             _TIMER_C_2        .equ $FFE2            ; TIMER COUNTER 2
0072   0000             _TIMER_CTRL       .equ $FFE3            ; TIMER CONTROL REGISTER
0073   0000             
0074   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0075   0000             FIFO_SIZE         .equ 1024
0076   0000             
0077   0000             text_org          .equ $400
0078   0000             ; ------------------------------------------------------------------------------------------------------------------;
0079   0000             
0080   0000             
0081   0000             ; For the next iteration:
0082   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0083   0000             ; inode-table format:
0084   0000             ;  file-type(f, d)
0085   0000             ;  permissons
0086   0000             ;  link-count
0087   0000             ;  filesize
0088   0000             ;  time-stamps
0089   0000             ;  15 data block pointers
0090   0000             ;  single-indirect pointer
0091   0000             
0092   0000             ; FILE ENTRY ATTRIBUTES
0093   0000             ; filename (24)
0094   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0095   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0096   0000             ; size (2)             : filesize
0097   0000             ; day (1)           
0098   0000             ; month (1)
0099   0000             ; year (1)
0100   0000             ; packet size = 32 bytes  : total packet size in bytes
0101   0000             
0102   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0103   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0104   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0105   0000             FST_NBR_DIRECTORIES     .equ 64
0106   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0107   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0108   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0109   0000             FST_LBA_START           .equ 32
0110   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0111   0000             
0112   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0113   0000             FS_SECTORS_PER_FILE     .equ 32         ; the first sector is always a header with a NULL parameter (first byte)
0114   0000                                                     ; so that we know which blocks are free or taken
0115   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0116   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0117   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0118   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0119   0000             
0120   0000             root_id:                .equ FST_LBA_START
0121   0000             
0122   0000             ; ------------------------------------------------------------------------------------------------------------------;
0123   0000             ; GLOBAL SYSTEM VARIABLES
0124   0000             ; ------------------------------------------------------------------------------------------------------------------;
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; IRQ Table
0128   0000             ; Highest priority at lowest address
0129   0000             ; ------------------------------------------------------------------------------------------------------------------;
0130   0000 3A 00       .dw int_0_fdc
0131   0002 3B 00       .dw int_1
0132   0004 3C 00       .dw int_2
0133   0006 3D 00       .dw int_3
0134   0008 3E 00       .dw int_4
0135   000A 3F 00       .dw int_5
0136   000C 40 00       .dw int_6
0137   000E 8C 00       .dw int_7_uart0
0138   0010             
0139   0010             ; ------------------------------------------------------------------------------------------------------------------;
0140   0010             ; Reset Vector
0141   0010             ; ------------------------------------------------------------------------------------------------------------------;
0142   0010 80 0F       .dw kernel_reset_vector
0143   0012             
0144   0012             ; ------------------------------------------------------------------------------------------------------------------;
0145   0012             ; Exception Vector Table
0146   0012             ; Total of 7 entries, starting at address $0012
0147   0012             ; ------------------------------------------------------------------------------------------------------------------;
0148   0012 78 01       .dw trap_privilege
0149   0014 95 02       .dw trap_div_zero
0150   0016 A2 02       .dw trap_undef_opcode
0151   0018 00 00       .dw 0
0152   001A 00 00       .dw 0
0153   001C 00 00       .dw 0
0154   001E 00 00       .dw 0
0155   0020             
0156   0020             ; ------------------------------------------------------------------------------------------------------------------;
0157   0020             ; System Call Vector Table
0158   0020             ; Starts at address $0020
0159   0020             ; ------------------------------------------------------------------------------------------------------------------;
0160   0020 84 01       .dw syscall_break
0161   0022 A3 02       .dw syscall_rtc
0162   0024 DD 03       .dw syscall_ide
0163   0026 B8 04       .dw syscall_io
0164   0028 75 05       .dw syscall_file_system
0165   002A CD 0E       .dw syscall_create_proc
0166   002C 3D 01       .dw syscall_list_procs
0167   002E D5 02       .dw syscall_datetime
0168   0030 F9 00       .dw syscall_reboot
0169   0032 97 0E       .dw syscall_pause_proc
0170   0034 05 01       .dw syscall_resume_proc
0171   0036 54 0E       .dw syscall_terminate_proc
0172   0038 CB 00       .dw syscall_system
0173   003A             
0174   003A             ; ------------------------------------------------------------------------------------------------------------------;
0175   003A             ; System Call Aliases
0176   003A             ; ------------------------------------------------------------------------------------------------------------------;
0177   003A             sys_break            .equ 0
0178   003A             sys_rtc              .equ 1
0179   003A             sys_ide              .equ 2
0180   003A             sys_io               .equ 3
0181   003A             sys_filesystem       .equ 4
0182   003A             sys_create_proc      .equ 5
0183   003A             sys_list_proc        .equ 6
0184   003A             sys_datetime         .equ 7
0185   003A             sys_reboot           .equ 8
0186   003A             sys_pause_proc       .equ 9
0187   003A             sys_resume_proc      .equ 10
0188   003A             sys_terminate_proc   .equ 11
0189   003A             sys_system           .equ 12
0190   003A             
0191   003A             ; ------------------------------------------------------------------------------------------------------------------;
0192   003A             ; Alias Exports
0193   003A             ; ------------------------------------------------------------------------------------------------------------------;
0194   003A             .export text_org
0195   003A             .export sys_break
0196   003A             .export sys_rtc
0197   003A             .export sys_ide
0198   003A             .export sys_io
0199   003A             .export sys_filesystem
0200   003A             .export sys_create_proc
0201   003A             .export sys_list_proc
0202   003A             .export sys_datetime
0203   003A             .export sys_reboot
0204   003A             .export sys_pause_proc
0205   003A             .export sys_resume_proc
0206   003A             .export sys_terminate_proc
0207   003A             .export sys_system
0208   003A             
0209   003A             ; ------------------------------------------------------------------------------------------------------------------;
0210   003A             ; IRQs' Code Block
0211   003A             ; ------------------------------------------------------------------------------------------------------------------;
0212   003A             ; 5.25" Floppy Drive Controller IRQ
0213   003A             int_0_fdc:
0214   003A 06            sysret
0215   003B             int_1:
0216   003B 06            sysret
0217   003C             int_2:
0218   003C 06            sysret
0219   003D             int_3:
0220   003D 06            sysret
0221   003E             int_4:
0222   003E 06            sysret
0223   003F             int_5:
0224   003F 06            sysret
0225   0040             
0226   0040             ; ------------------------------------------------------------------------------------------------------------------;
0227   0040             ; Process Swapping
0228   0040             ; ------------------------------------------------------------------------------------------------------------------;
0229   0040             int_6:  
0230   0040 4B            pusha ; save all registers into kernel stack
0231   0041 22 00         mov ah, 0
0232   0043 1D FB 16      mov al, [active_proc_index]
0233   0046 FD 99         shl a              ; x2
0234   0048 B7 4A 0F      mov a, [proc_table_convert + a]  ; get process state start index
0235   004B 4F            mov di, a
0236   004C 48            mov a, sp
0237   004D 77            inc a
0238   004E 4D            mov si, a
0239   004F 38 14 00      mov c, 20
0240   0052 FD F5         rep movsb          ; save process state!
0241   0054             ; restore kernel stack position to point before interrupt arrived
0242   0054 51 14 00      add sp, 20
0243   0057             ; now load next process in queue
0244   0057 1D FB 16      mov al, [active_proc_index]
0245   005A 31 FA 16      mov bl, [nbr_active_procs]
0246   005D BA            cmp al, bl
0247   005E C6 65 00      je int6_cycle_back
0248   0061 7A            inc al            ; next process is next in the series
0249   0062 0A 67 00      jmp int6_continue
0250   0065             int6_cycle_back:
0251   0065 19 01         mov al, 1        ; next process = process 1
0252   0067             int6_continue:
0253   0067 3D FB 16      mov [active_proc_index], al    ; set next active proc
0254   006A             
0255   006A             ; calculate LUT entry for next process
0256   006A 22 00         mov ah, 0
0257   006C FD 99         shl a              ; x2
0258   006E B7 4A 0F      mov a, [proc_table_convert + a]    ; get process state start index  
0259   0071               
0260   0071 4D            mov si, a            ; source is proc state block
0261   0072 48            mov a, sp
0262   0073 5F 13 00      sub a, 19
0263   0076 4F            mov di, a            ; destination is kernel stack
0264   0077             ; restore SP
0265   0077 7D            dec a
0266   0078 47            mov sp, a
0267   0079 38 14 00      mov c, 20
0268   007C FD F5         rep movsb
0269   007E             ; set VM process
0270   007E 1D FB 16      mov al, [active_proc_index]
0271   0081 01            setptb
0272   0082 F2 E0 FF 00   mov byte[_TIMER_C_0], 0        ; load counter 0 low byte
0273   0086 F2 E0 FF 10   mov byte[_TIMER_C_0], $10        ; load counter 0 high byte
0274   008A 4C            popa
0275   008B 06            sysret
0276   008C             
0277   008C             ; ------------------------------------------------------------------------------------------------------------------;
0278   008C             ; UART0 Interrupt
0279   008C             ; ------------------------------------------------------------------------------------------------------------------;
0280   008C             int_7_uart0:
0281   008C D7            push a
0282   008D DA            push d
0283   008E E1            pushf
0284   008F 14 00 17      mov a, [fifo_in]
0285   0092 3C            mov d, a
0286   0093 1D 80 FF      mov al, [_UART0_DATA]  ; get character
0287   0096 B9 03         cmp al, $03        ; CTRL-C
0288   0098 C6 B5 00      je CTRLC
0289   009B B9 1A         cmp al, $1A        ; CTRL-Z
0290   009D C6 BB 00      je CTRLZ
0291   00A0 3E            mov [d], al        ; add to fifo
0292   00A1 14 00 17      mov a, [fifo_in]
0293   00A4 77            inc a
0294   00A5 AF FF 21      cmp a, fifo + FIFO_SIZE         ; check if pointer reached the end of the fifo
0295   00A8 C7 AE 00      jne int_7_continue
0296   00AB 10 FF 1D      mov a, fifo  
0297   00AE             int_7_continue:  
0298   00AE 42 00 17      mov [fifo_in], a      ; update fifo pointer
0299   00B1 EE            popf
0300   00B2 E7            pop d
0301   00B3 E4            pop a  
0302   00B4 06            sysret
0303   00B5             CTRLC:
0304   00B5 51 05 00      add sp, 5
0305   00B8 0A 54 0E      jmp syscall_terminate_proc
0306   00BB             CTRLZ:
0307   00BB EE            popf
0308   00BC E7            pop d
0309   00BD E4            pop a
0310   00BE 0A 97 0E      jmp syscall_pause_proc    ; pause current process and go back to the shell
0311   00C1             
0312   00C1             
0313   00C1             
0314   00C1             ; ------------------------------------------------------------------------------------------------------------------;
0315   00C1             ; System Syscalls
0316   00C1             ; ------------------------------------------------------------------------------------------------------------------;
0317   00C1             system_jmptbl:
0318   00C1 F7 00         .dw system_uname
0319   00C3 F8 00         .dw system_whoami
0320   00C5 F4 00         .dw system_setparam
0321   00C7 D1 00         .dw system_bootloader_install
0322   00C9 CF 00         .dw system_getparam
0323   00CB             syscall_system:
0324   00CB FD 0A C1 00   jmp [system_jmptbl + al]
0325   00CF             
0326   00CF             ; param register address in register d
0327   00CF             ; param value in register bl
0328   00CF             system_getparam:
0329   00CF 32            mov bl, [d]
0330   00D0 06            sysret
0331   00D1             
0332   00D1             ; kernel LBA address in 'b'
0333   00D1             system_bootloader_install:
0334   00D1 D8            push b
0335   00D2 26 00 00      mov b, 0
0336   00D5 38 00 00      mov c, 0
0337   00D8 22 01         mov ah, $01                 ; 1 sector
0338   00DA 3B FF 23      mov d, transient_area
0339   00DD 07 27 04      call ide_read_sect          ; read sector
0340   00E0 E5            pop b
0341   00E1 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0342   00E5 26 00 00      mov b, 0
0343   00E8 38 00 00      mov c, 0
0344   00EB 22 01         mov ah, $01                 ; 1 sector
0345   00ED 3B FF 23      mov d, transient_area
0346   00F0 07 4D 04      call ide_write_sect         ; write sector
0347   00F3 06            sysret
0348   00F4             
0349   00F4             ; param register address in register d
0350   00F4             ; param value in register bl
0351   00F4             system_setparam:
0352   00F4 FD 3E         mov [d], bl
0353   00F6 06            sysret
0354   00F7             
0355   00F7             system_uname:
0356   00F7 06            sysret
0357   00F8             
0358   00F8             system_whoami:
0359   00F8 06            sysret
0360   00F9             
0361   00F9             ; REBOOT SYSTEM
0362   00F9             syscall_reboot:
0363   00F9 FD D7 FF FF   push word $FFFF 
0364   00FD FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0365   0100 FD D7 C0 01   push word BIOS_RESET_VECTOR    ; and then push RESET VECTOR of the shell to the stack
0366   0104 06            sysret
0367   0105             
0368   0105             ;------------------------------------------------------------------------------------------------------;;
0369   0105             ; switch to another process
0370   0105             ; inputs:
0371   0105             ; AL = new process number
0372   0105             ;------------------------------------------------------------------------------------------------------;;
0373   0105             syscall_resume_proc:
0374   0105 FD 78         mov g, a                            ; save the process number
0375   0107 4B            pusha                               ; save all registers into kernel stack
0376   0108 22 00         mov ah, 0
0377   010A 1D FB 16      mov al, [active_proc_index]
0378   010D FD 99         shl a              ; x2
0379   010F B7 4A 0F      mov a, [proc_table_convert + a]     ; get process state start index
0380   0112 4F            mov di, a
0381   0113 48            mov a, sp
0382   0114 77            inc a
0383   0115 4D            mov si, a
0384   0116 38 14 00      mov c, 20
0385   0119 FD F5         rep movsb                           ; save process state!
0386   011B             ; restore kernel stack position to point before interrupt arrived
0387   011B 51 14 00      add sp, 20
0388   011E             ; now load the new process number!
0389   011E FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0390   0120 3D FB 16      mov [active_proc_index], al         ; set new active proc
0391   0123             ; calculate LUT entry for next process
0392   0123 22 00         mov ah, 0
0393   0125 FD 99         shl a                               ; x2
0394   0127 B7 4A 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0395   012A 4D            mov si, a                           ; source is proc state block
0396   012B 48            mov a, sp
0397   012C 5F 13 00      sub a, 19
0398   012F 4F            mov di, a                           ; destination is kernel stack
0399   0130             ; restore SP
0400   0130 7D            dec a
0401   0131 47            mov sp, a
0402   0132 38 14 00      mov c, 20
0403   0135 FD F5         rep movsb
0404   0137             ; set VM process
0405   0137 1D FB 16      mov al, [active_proc_index]
0406   013A 01            setptb
0407   013B 4C            popa
0408   013C 06            sysret
0409   013D             
0410   013D             syscall_list_procs:
0411   013D 3B 23 17      mov d, s_ps_header
0412   0140 07 CA 11      call _puts
0413   0143 3B 70 19      mov d, proc_availab_table + 1
0414   0146 38 01 00      mov c, 1
0415   0149             list_procs_L0:  
0416   0149 BD 01         cmp byte[d], 1
0417   014B C7 6F 01      jne list_procs_next
0418   014E 2D            mov b, d
0419   014F 61 6F 19      sub b, proc_availab_table
0420   0152 FD 9F 05      shl b, 5
0421   0155 DA            push d
0422   0156 D8            push b
0423   0157 28            mov b, c
0424   0158 07 6A 12      call print_u8x
0425   015B 22 20         mov ah, ' '
0426   015D 07 9E 10      call _putchar
0427   0160 07 9E 10      call _putchar
0428   0163 E5            pop b
0429   0164 74            mov d, b
0430   0165 58 7F 19      add d, proc_names
0431   0168 07 CA 11      call _puts
0432   016B 07 77 11      call printnl
0433   016E E7            pop d
0434   016F             list_procs_next:
0435   016F 79            inc d
0436   0170 78            inc c
0437   0171 C2 09 00      cmp c, 9
0438   0174 C7 49 01      jne list_procs_L0
0439   0177             list_procs_end:
0440   0177 06            sysret
0441   0178             
0442   0178             ; ------------------------------------------------------------------------------------------------------------------;
0443   0178             ; Exceptions' Code Block
0444   0178             ; ------------------------------------------------------------------------------------------------------------------;
0445   0178             ; Privilege
0446   0178             ; ------------------------------------------------------------------------------------------------------------------;
0447   0178             trap_privilege:
0448   0178 0A F9 00      jmp syscall_reboot
0449   017B DA            push d
0450   017C 3B 72 17      mov d, s_priviledge
0451   017F 07 CA 11      call _puts
0452   0182 E7            pop d
0453   0183 06            sysret
0454   0184             
0455   0184             ; ------------------------------------------------------------------------------------------------------------------;
0456   0184             ; Breakpoint
0457   0184             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0458   0184             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0459   0184             ; ------------------------------------------------------------------------------------------------------------------;
0460   0184             syscall_break:
0461   0184 4B            pusha
0462   0185             syscall_break_prompt:
0463   0185 3B 3F 02      mov d, s_break1
0464   0188 07 CA 11      call _puts
0465   018B 07 77 11      call printnl
0466   018E 07 CC 12      call scan_u16d
0467   0191 AF 00 00      cmp a, 0
0468   0194 C6 9F 01      je syscall_break_regs
0469   0197 AF 01 00      cmp a, 1
0470   019A C6 C2 01      je syscall_break_mem
0471   019D             syscall_break_end:  
0472   019D 4C            popa
0473   019E 06            sysret
0474   019F             syscall_break_regs:
0475   019F 48            mov a, sp
0476   01A0 53 0E 00      add a, 14               ; back-track 7 registers
0477   01A3 3C            mov d, a
0478   01A4 3A 07         mov cl, 7
0479   01A6             syscall_regs_L0:
0480   01A6 2A            mov b, [d]
0481   01A7 FD AB         swp b
0482   01A9 07 26 12      call print_u16x         ; print register value
0483   01AC 07 77 11      call printnl
0484   01AF 63 02 00      sub d, 2
0485   01B2 71 01         sub cl, 1
0486   01B4 C3 00         cmp cl, 0
0487   01B6 C7 A6 01      jne syscall_regs_L0
0488   01B9 0A 85 01      jmp syscall_break_prompt
0489   01BC 07 77 11      call printnl
0490   01BF 0A 85 01      jmp syscall_break_prompt
0491   01C2             syscall_break_mem:
0492   01C2 07 77 11      call printnl
0493   01C5 07 48 12      call scan_u16x
0494   01C8 4D            mov si, a               ; data source from user space
0495   01C9 FD 4F FF 21   mov di, scrap_sector    ; destination in kernel space
0496   01CD 38 00 02      mov c, 512
0497   01D0 04            load                    ; transfer data to kernel space!
0498   01D1 3B FF 21      mov d, scrap_sector     ; dump pointer in d
0499   01D4 38 00 00      mov c, 0
0500   01D7             dump_loop:
0501   01D7 84            mov al, cl
0502   01D8 87 0F         and al, $0F
0503   01DA C6 28 02      jz print_base
0504   01DD             back:
0505   01DD 1E            mov al, [d]             ; read byte
0506   01DE 2F            mov bl, al
0507   01DF 07 6A 12      call print_u8x
0508   01E2 10 00 20      mov a, $2000
0509   01E5 05 03         syscall sys_io          ; space
0510   01E7 84            mov al, cl
0511   01E8 87 0F         and al, $0F
0512   01EA B9 0F         cmp al, $0F
0513   01EC C6 FD 01      je print_ascii
0514   01EF             back1:
0515   01EF 79            inc d
0516   01F0 78            inc c
0517   01F1 C2 00 02      cmp c, 512
0518   01F4 C7 D7 01      jne dump_loop
0519   01F7 07 77 11      call printnl
0520   01FA 0A 85 01      jmp syscall_break_prompt  ; go to syscall_break return point
0521   01FD             print_ascii:
0522   01FD 10 00 20      mov a, $2000
0523   0200 05 03         syscall sys_io
0524   0202 63 10 00      sub d, 16
0525   0205 26 10 00      mov b, 16
0526   0208             print_ascii_L:
0527   0208 79            inc d
0528   0209 1E            mov al, [d]               ; read byte
0529   020A B9 20         cmp al, $20
0530   020C C8 14 02      jlu dot
0531   020F B9 7E         cmp al, $7E
0532   0211 D0 1C 02      jleu ascii
0533   0214             dot:
0534   0214 10 00 2E      mov a, $2E00
0535   0217 05 03         syscall sys_io
0536   0219 0A 21 02      jmp ascii_continue
0537   021C             ascii:
0538   021C 23            mov ah, al
0539   021D 19 00         mov al, 0
0540   021F 05 03         syscall sys_io
0541   0221             ascii_continue:
0542   0221 FD A9 08 02   loopb print_ascii_L
0543   0225 0A EF 01      jmp back1
0544   0228             print_base:
0545   0228 07 77 11      call printnl
0546   022B 2D            mov b, d
0547   022C 61 FF 21      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0548   022F 07 26 12      call print_u16x          ; display row
0549   0232 10 00 3A      mov a, $3A00
0550   0235 05 03         syscall sys_io
0551   0237 10 00 20      mov a, $2000
0552   023A 05 03         syscall sys_io
0553   023C 0A DD 01      jmp back
0554   023F             
0555   023F             s_break1:  
0556   023F 0A 44 65 62   .db "\nDebugger entry point.\n"
0556   0243 75 67 67 65 
0556   0247 72 20 65 6E 
0556   024B 74 72 79 20 
0556   024F 70 6F 69 6E 
0556   0253 74 2E 0A 
0557   0256 30 2E 20 53   .db "0. Show Registers\n"
0557   025A 68 6F 77 20 
0557   025E 52 65 67 69 
0557   0262 73 74 65 72 
0557   0266 73 0A 
0558   0268 31 2E 20 53   .db "1. Show 512B RAM block\n"
0558   026C 68 6F 77 20 
0558   0270 35 31 32 42 
0558   0274 20 52 41 4D 
0558   0278 20 62 6C 6F 
0558   027C 63 6B 0A 
0559   027F 32 2E 20 43   .db "2. Continue Execution", 0
0559   0283 6F 6E 74 69 
0559   0287 6E 75 65 20 
0559   028B 45 78 65 63 
0559   028F 75 74 69 6F 
0559   0293 6E 00 
0560   0295             
0561   0295             ; ------------------------------------------------------------------------------------------------------------------;
0562   0295             ; Divide by Zero
0563   0295             ; ------------------------------------------------------------------------------------------------------------------;
0564   0295             trap_div_zero:
0565   0295 D7            push a
0566   0296 DA            push d
0567   0297 E1            pushf
0568   0298 3B 89 17      mov d, s_divzero
0569   029B 07 CA 11      call _puts
0570   029E EE            popf
0571   029F E7            pop d
0572   02A0 E4            pop a
0573   02A1 06            sysret ; enable interrupts
0574   02A2             
0575   02A2             ; ------------------------------------------------------------------------------------------------------------------;
0576   02A2             ; Undefined Opcode
0577   02A2             ; ------------------------------------------------------------------------------------------------------------------;
0578   02A2             trap_undef_opcode:
0579   02A2 06            sysret
0580   02A3             
0581   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0582   02A3             ; RTC Services Syscall
0583   02A3             ; RTC I/O bank = FFA0 to FFAF
0584   02A3             ; FFA0 to FFA7 is scratch RAM
0585   02A3             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0586   02A3             ; al = 0..6 -> get
0587   02A3             ; al = 7..D -> set
0588   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0589   02A3             syscall_rtc:
0590   02A3 DB            push al
0591   02A4 DA            push d
0592   02A5 B9 06         cmp al, 6
0593   02A7 D1 BC 02      jgu syscall_rtc_set
0594   02AA             syscall_rtc_get:
0595   02AA 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0596   02AC 22 FF         mov ah, $FF    
0597   02AE 3C            mov d, a                ; get to FFA9 + offset
0598   02AF F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0599   02B3 1E            mov al, [d]             ; get data
0600   02B4 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0601   02B8 23            mov ah, al
0602   02B9 E7            pop d
0603   02BA E8            pop al
0604   02BB 06            sysret
0605   02BC             syscall_rtc_set:
0606   02BC DD            push bl
0607   02BD 99            mov bl, ah              ; set data asIDE
0608   02BE 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0609   02C0 22 FF         mov ah, $FF    
0610   02C2 3C            mov d, a                ; get to FFA9 + offset
0611   02C3 1B            mov al, bl              ; get data back
0612   02C4 F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0613   02C8 3E            mov [d], al             ; set data
0614   02C9 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0615   02CD EA            pop bl
0616   02CE E7            pop d
0617   02CF E8            pop al
0618   02D0 06            sysret
0619   02D1             
0620   02D1             datetime_serv_tbl:
0621   02D1 D9 02         .dw print_date
0622   02D3 4D 03         .dw set_date
0623   02D5             syscall_datetime:
0624   02D5 FD 0A D1 02   jmp [datetime_serv_tbl + al]      
0625   02D9             print_date:
0626   02D9 10 00 0D      mov a, $0D00           ; print carriage return char
0627   02DC 19 03         mov al, 3
0628   02DE 05 01         syscall sys_rtc        ; get week
0629   02E0 1A            mov al, ah
0630   02E1 22 00         mov ah, 0
0631   02E3 FD 9D 02      shl a, 2          
0632   02E6 3B 13 18      mov d, s_week
0633   02E9 59            add d, a
0634   02EA 07 CA 11      call _puts
0635   02ED 10 00 20      mov a, $2000
0636   02F0 05 03         syscall sys_io         ; display ' '
0637   02F2 19 04         mov al, 4
0638   02F4 05 01         syscall sys_rtc        ; get day
0639   02F6 99            mov bl, ah
0640   02F7 07 6A 12      call print_u8x
0641   02FA 10 00 20      mov a, $2000
0642   02FD 05 03         syscall sys_io         ; display ' '
0643   02FF             ; there is a problem with the month displaying
0644   02FF             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0645   02FF             ; even though it is to be understood as BCD.
0646   02FF             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0647   02FF 19 05         mov al, 05
0648   0301 05 01         syscall sys_rtc        ; get month
0649   0303 1A            mov al, ah
0650   0304 22 00         mov ah, 0
0651   0306 FD 9D 02      shl a, 2          
0652   0309 3B DF 17      mov d, s_months
0653   030C 59            add d, a
0654   030D 07 CA 11      call _puts
0655   0310 10 00 20      mov a, $2000
0656   0313 05 03         syscall sys_io         ; display ' '
0657   0315 2E 20         mov bl, $20
0658   0317 07 6A 12      call print_u8x         ; print 20 for year prefix
0659   031A 19 06         mov al, 06
0660   031C 05 01         syscall sys_rtc        ; get year
0661   031E 99            mov bl, ah
0662   031F 07 6A 12      call print_u8x
0663   0322 10 00 20      mov a, $2000  
0664   0325 05 03         syscall sys_io         ; display ' '
0665   0327 19 02         mov al, 2
0666   0329 05 01         syscall sys_rtc        ; get hours
0667   032B 99            mov bl, ah
0668   032C 07 6A 12      call print_u8x
0669   032F 10 00 3A      mov a, $3A00    
0670   0332 05 03         syscall sys_io         ; display ':'
0671   0334 19 01         mov al, 01
0672   0336 05 01         syscall sys_rtc        ; get minutes
0673   0338 99            mov bl, ah
0674   0339 07 6A 12      call print_u8x
0675   033C 10 00 3A      mov a, $3A00  
0676   033F 05 03         syscall sys_io         ; display ':'
0677   0341 19 00         mov al, 0
0678   0343 05 01         syscall sys_rtc        ; get seconds
0679   0345 99            mov bl, ah
0680   0346 07 6A 12      call print_u8x
0681   0349 07 77 11      call printnl
0682   034C 06            sysret
0683   034D             set_date:
0684   034D 3B A4 17      mov d, s_set_year
0685   0350 07 CA 11      call _puts
0686   0353 07 B5 12      call scan_u8x          ; read integer into A
0687   0356 FD 9D 08      shl a, 8               ; only AL used, move to AH
0688   0359 19 0D         mov al, 0Dh            ; set RTC year
0689   035B 05 01         syscall sys_rtc        ; set RTC
0690   035D 3B AB 17      mov d, s_set_month
0691   0360 07 CA 11      call _puts
0692   0363 07 B5 12      call scan_u8x          ; read integer into A
0693   0366 FD 9D 08      shl a, 8               ; only AL used, move to AH
0694   0369 19 0C         mov al, 0Ch            ; set RTC month
0695   036B 05 01         syscall sys_rtc        ; set RTC
0696   036D 3B B3 17      mov d, s_set_day
0697   0370 07 CA 11      call _puts
0698   0373 07 B5 12      call scan_u8x          ; read integer into A
0699   0376 FD 9D 08      shl a, 8               ; only AL used, move to AH
0700   0379 19 0B         mov al, 0Bh            ; set RTC month
0701   037B 05 01         syscall sys_rtc        ; set RTC
0702   037D 3B B9 17      mov d, s_set_week
0703   0380 07 CA 11      call _puts
0704   0383 07 B5 12      call scan_u8x          ; read integer into A
0705   0386 FD 9D 08      shl a, 8               ; only AL used, move to AH
0706   0389 19 0A         mov al, 0Ah            ; set RTC month
0707   038B 05 01         syscall sys_rtc        ; set RTC
0708   038D 3B C3 17      mov d, s_set_hours
0709   0390 07 CA 11      call _puts
0710   0393 07 B5 12      call scan_u8x          ; read integer into A
0711   0396 FD 9D 08      shl a, 8               ; only AL used, move to AH
0712   0399 19 09         mov al, 09h            ; set RTC month
0713   039B 05 01         syscall sys_rtc        ; set RTC
0714   039D 3B CB 17      mov d, s_set_minutes
0715   03A0 07 CA 11      call _puts
0716   03A3 07 B5 12      call scan_u8x          ; read integer into A
0717   03A6 FD 9D 08      shl a, 8               ; only AL used, move to AH
0718   03A9 19 08         mov al, 08h            ; set RTC month
0719   03AB 05 01         syscall sys_rtc        ; set RTC
0720   03AD 3B D5 17      mov d, s_set_seconds
0721   03B0 07 CA 11      call _puts
0722   03B3 07 B5 12      call scan_u8x          ; read integer into A
0723   03B6 FD 9D 08      shl a, 8               ; only AL used, move to AH
0724   03B9 19 07         mov al, 07h            ; set RTC month
0725   03BB 05 01         syscall sys_rtc        ; set RTC
0726   03BD 06            sysret
0727   03BE             
0728   03BE             ; ------------------------------------------------------------------------------------------------------------------;
0729   03BE             ; IDE Services Syscall
0730   03BE             ; al = option
0731   03BE             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0732   03BE             ; IDE read/write sector
0733   03BE             ; 512 bytes
0734   03BE             ; User buffer pointer in D
0735   03BE             ; AH = number of sectors
0736   03BE             ; CB = LBA bytes 3..0
0737   03BE             ; ------------------------------------------------------------------------------------------------------------------;
0738   03BE 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0738   03C2 73 63 61 6C 
0738   03C6 6C 5F 69 64 
0738   03CA 65 20 63 61 
0738   03CE 6C 6C 65 64 
0738   03D2 3A 20 00 
0739   03D5             ide_serv_tbl:
0740   03D5 FC 03         .dw ide_reset
0741   03D7 10 04         .dw ide_sleep
0742   03D9 1F 04         .dw ide_read_sect_wrapper
0743   03DB 23 04         .dw ide_write_sect_wrapper
0744   03DD             syscall_ide:
0745   03DD DD            push bl
0746   03DE 31 F3 16      mov bl, [sys_debug_mode]
0747   03E1               ; debug block
0748   03E1 C1 00         cmp bl, 0
0749   03E3 EA            pop bl
0750   03E4 C6 F8 03      je syscall_ide_jmp
0751   03E7 DA            push d
0752   03E8 DD            push bl
0753   03E9 3B BE 03      mov d, s_syscall_ide_dbg0
0754   03EC 07 CA 11      call _puts
0755   03EF 2F            mov bl, al
0756   03F0 07 6A 12      call print_u8x
0757   03F3 07 77 11      call printnl
0758   03F6 EA            pop bl
0759   03F7 E7            pop d
0760   03F8             syscall_ide_jmp:
0761   03F8 FD 0A D5 03   jmp [ide_serv_tbl + al]    
0762   03FC               
0763   03FC             ide_reset:      
0764   03FC F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0765   0400 07 A9 04      call ide_wait                   ; wait for IDE ready             
0766   0403 F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0767   0407 F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0768   040B F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0769   040F 06            sysret
0770   0410             ide_sleep:
0771   0410 07 A9 04      call ide_wait                   ; wait for IDE ready             
0772   0413 F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0773   0417 F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0774   041B 07 A9 04      call ide_wait                   ; wait for IDE ready
0775   041E 06            sysret
0776   041F             ide_read_sect_wrapper:
0777   041F 07 27 04      call ide_read_sect
0778   0422 06            sysret
0779   0423             ide_write_sect_wrapper:
0780   0423 07 4D 04      call ide_write_sect
0781   0426 06            sysret
0782   0427             ide_read_sect:
0783   0427 1A            mov al, ah
0784   0428 24            mov ah, bl
0785   0429 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0786   042C 1C            mov al, bh
0787   042D 3D D4 FF      mov [_ide_R4], al
0788   0430 12            mov a, c
0789   0431 3D D5 FF      mov [_ide_R5], al
0790   0434 1A            mov al, ah
0791   0435 87 0F         and al, %00001111
0792   0437 8B E0         or al, %11100000                ; mode lba, master
0793   0439 3D D6 FF      mov [_ide_R6], al
0794   043C             ide_read_sect_wait:
0795   043C 1D D7 FF      mov al, [_ide_R7]  
0796   043F 87 80         and al, $80                     ; BUSY FLAG
0797   0441 C7 3C 04      jnz ide_read_sect_wait
0798   0444 19 20         mov al, $20
0799   0446 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0800   0449 07 73 04      call ide_read  
0801   044C 09            ret
0802   044D             ide_write_sect:
0803   044D 1A            mov al, ah
0804   044E 24            mov ah, bl
0805   044F 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0806   0452 1C            mov al, bh
0807   0453 3D D4 FF      mov [_ide_R4], al
0808   0456 12            mov a, c
0809   0457 3D D5 FF      mov [_ide_R5], al
0810   045A 1A            mov al, ah
0811   045B 87 0F         and al, %00001111
0812   045D 8B E0         or al, %11100000                ; mode lba, master
0813   045F 3D D6 FF      mov [_ide_R6], al
0814   0462             ide_write_sect_wait:
0815   0462 1D D7 FF      mov al, [_ide_R7]  
0816   0465 87 80         and al, $80                     ; BUSY FLAG
0817   0467 C7 62 04      jnz ide_write_sect_wait
0818   046A 19 30         mov al, $30
0819   046C 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0820   046F 07 8E 04      call ide_write      
0821   0472 09            ret
0822   0473             
0823   0473             ;----------------------------------------------------------------------------------------------------;
0824   0473             ; READ IDE DATA
0825   0473             ; pointer in D
0826   0473             ;----------------------------------------------------------------------------------------------------;
0827   0473             ide_read:
0828   0473 DA            push d
0829   0474             ide_read_loop:
0830   0474 1D D7 FF      mov al, [_ide_R7]  
0831   0477 87 80         and al, 80h                     ; BUSY FLAG
0832   0479 C7 74 04      jnz ide_read_loop               ; wait loop
0833   047C 1D D7 FF      mov al, [_ide_R7]
0834   047F 87 08         and al, %00001000               ; DRQ FLAG
0835   0481 C6 8C 04      jz ide_read_end
0836   0484 1D D0 FF      mov al, [_ide_R0]
0837   0487 3E            mov [d], al
0838   0488 79            inc d
0839   0489 0A 74 04      jmp ide_read_loop
0840   048C             ide_read_end:
0841   048C E7            pop d
0842   048D 09            ret
0843   048E             
0844   048E             ;----------------------------------------------------------------------------------------------------;
0845   048E             ; WRITE IDE DATA
0846   048E             ; data pointer in D
0847   048E             ;----------------------------------------------------------------------------------------------------;
0848   048E             ide_write:
0849   048E DA            push d
0850   048F             ide_write_loop:
0851   048F 1D D7 FF      mov al, [_ide_R7]  
0852   0492 87 80         and al, 80h             ; BUSY FLAG
0853   0494 C7 8F 04      jnz ide_write_loop      ; wait loop
0854   0497 1D D7 FF      mov al, [_ide_R7]
0855   049A 87 08         and al, %00001000       ; DRQ FLAG
0856   049C C6 A7 04      jz ide_write_end
0857   049F 1E            mov al, [d]
0858   04A0 3D D0 FF      mov [_ide_R0], al
0859   04A3 79            inc d 
0860   04A4 0A 8F 04      jmp ide_write_loop
0861   04A7             ide_write_end:
0862   04A7 E7            pop d
0863   04A8 09            ret
0864   04A9             
0865   04A9             ;----------------------------------------------------------------------------------------------------;
0866   04A9             ; wait for IDE to be ready
0867   04A9             ;----------------------------------------------------------------------------------------------------;
0868   04A9             ide_wait:
0869   04A9 1D D7 FF      mov al, [_ide_R7]  
0870   04AC 87 80         and al, 80h        ; BUSY FLAG
0871   04AE C7 A9 04      jnz ide_wait
0872   04B1 09            ret
0873   04B2             
0874   04B2             ;----------------------------------------------------------------------------------------------------;
0875   04B2             ; IO Syscall
0876   04B2             ;----------------------------------------------------------------------------------------------------;
0877   04B2             ; Baud  Divisor
0878   04B2             ; 50    2304
0879   04B2             ; 110   1047
0880   04B2             ; 300    384
0881   04B2             ; 600    192
0882   04B2             ; 1200    96
0883   04B2             ; 9600    12
0884   04B2             ; 19200    6
0885   04B2             ; 38400    3
0886   04B2             syscall_io_jmp:
0887   04B2 E5 04         .dw syscall_io_putchar
0888   04B4 F2 04         .dw syscall_io_getch
0889   04B6 BC 04         .dw syscall_io_uart_setup
0890   04B8             syscall_io:
0891   04B8 FD 0A B2 04   jmp [syscall_io_jmp + al]
0892   04BC             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0893   04BC             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0894   04BC             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0895   04BC             syscall_io_uart_setup:
0896   04BC 1D F5 16      mov al, [sys_uart0_lcr]
0897   04BF 8B 80         or al, $80                ; set DLAB access bit
0898   04C1 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0899   04C4 1D F8 16      mov al, [sys_uart0_div0]
0900   04C7 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0901   04CA 1D F9 16      mov al, [sys_uart0_div1]
0902   04CD 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0903   04D0             
0904   04D0 1D F5 16      mov al, [sys_uart0_lcr]
0905   04D3 87 7F         and al, $7F               ; clear DLAB access bit 
0906   04D5 3D 83 FF      mov [_UART0_LCR], al
0907   04D8 1D F6 16      mov al, [sys_uart0_inten]
0908   04DB 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0909   04DE 1D F7 16      mov al, [sys_uart0_fifoen]
0910   04E1 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0911   04E4 06            sysret
0912   04E5             
0913   04E5             ; char in ah
0914   04E5             syscall_io_putchar:
0915   04E5             syscall_io_putchar_L0:
0916   04E5 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0917   04E8 87 20         and al, $20
0918   04EA C6 E5 04      jz syscall_io_putchar_L0    
0919   04ED 1A            mov al, ah
0920   04EE 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0921   04F1 06            sysret
0922   04F2             
0923   04F2             ; char in ah
0924   04F2             ; al = sucess code
0925   04F2             syscall_io_getch:
0926   04F2 D8            push b
0927   04F3 DA            push d
0928   04F4 FD 0C         sti
0929   04F6             syscall_io_getch_L0:  
0930   04F6 14 02 17      mov a, [fifo_out]
0931   04F9 29 00 17      mov b, [fifo_in]
0932   04FC B0            cmp a, b
0933   04FD C6 F6 04      je syscall_io_getch_L0
0934   0500 3C            mov d, a
0935   0501 77            inc a
0936   0502 AF FF 21      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
0937   0505 C7 0B 05      jne syscall_io_getch_cont
0938   0508 10 FF 1D      mov a, fifo  
0939   050B             syscall_io_getch_cont:  
0940   050B 42 02 17      mov [fifo_out], a             ; update fifo pointer
0941   050E 1E            mov al, [d]                   ; get char
0942   050F 23            mov ah, al
0943   0510 1D F4 16      mov al, [sys_echo_on]
0944   0513 B9 01         cmp al, 1
0945   0515 C7 24 05      jne syscall_io_getch_noecho 
0946   0518             ; here we just echo the char back to the console
0947   0518             syscall_io_getch_echo_L0:
0948   0518 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0949   051B 87 20         and al, $20                 ; isolate Transmitter Empty
0950   051D C6 18 05      jz syscall_io_getch_echo_L0
0951   0520 1A            mov al, ah
0952   0521 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0953   0524             syscall_io_getch_noecho:
0954   0524 19 01         mov al, 1                    ; AL = 1 means a char successfully received
0955   0526 E7            pop d
0956   0527 E5            pop b
0957   0528 06            sysret
0958   0529             
0959   0529             ;------------------------------------------------------------------------------------------------------;
0960   0529             ; FILE SYSTEM DATA
0961   0529             ;------------------------------------------------------------------------------------------------------;
0962   0529             ; infor for : IDE SERVICES INTERRUPT
0963   0529             ; IDE read/write 512-byte sector
0964   0529             ; al = option
0965   0529             ; user buffer pointer in D
0966   0529             ; AH = number of sectors
0967   0529             ; CB = LBA bytes 3..0  
0968   0529             ;------------------------------------------------------------------------------------------------------;
0969   0529             ; FILE SYSTEM DATA STRUCTURE
0970   0529             ;------------------------------------------------------------------------------------------------------;
0971   0529             ; for a directory we have the header first, followed by metadata
0972   0529             ; header 1 sector (512 bytes)
0973   0529             ; metadata 1 sector (512 bytes)
0974   0529             ; HEADER ENTRIES:
0975   0529             ; filename (64)
0976   0529             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0977   0529             ;
0978   0529             ; metadata entries:
0979   0529             ; filename (24)
0980   0529             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
0981   0529             ; LBA (2)
0982   0529             ; size (2)
0983   0529             ; day (1)
0984   0529             ; month (1)
0985   0529             ; year (1)
0986   0529             ; packet size = 32 bytes
0987   0529             ;
0988   0529             ; first directory on disk is the root directory '/'
0989   0529             file_system_jmptbl:
0990   0529 94 05         .dw fs_mkfs                   ; 0
0991   052B 00 00         .dw 0                         ; 1
0992   052D F6 05         .dw fs_mkdir                  ; 2
0993   052F 6F 09         .dw fs_cd                     ; 3
0994   0531 76 09         .dw fs_ls                     ; 4
0995   0533 EC 0A         .dw fs_mktxt                  ; 5
0996   0535 B7 0B         .dw fs_mkbin                  ; 6
0997   0537 7E 0C         .dw fs_pwd                    ; 7
0998   0539 9B 0C         .dw fs_cat                    ; 8
0999   053B F7 0C         .dw fs_rmdir                  ; 9
1000   053D 53 0D         .dw fs_rm                     ; 10
1001   053F 47 0A         .dw fs_starcom                ; 11
1002   0541 00 00         .dw 0                         ; 12
1003   0543 00 00         .dw 0                         ; 13
1004   0545 9C 05         .dw fs_chmod                  ; 14
1005   0547 BB 0D         .dw fs_mv                     ; 15
1006   0549 95 05         .dw fs_cd_root                ; 16
1007   054B 6B 09         .dw fs_get_curr_dirID         ; 17
1008   054D 47 07         .dw fs_dir_id_to_path         ; 18
1009   054F AD 07         .dw fs_path_to_dir_id_user    ; 19
1010   0551 C7 08         .dw fs_load_from_path_user    ; 20  
1011   0553 37 08         .dw fs_filepath_exists_user   ; 21
1012   0555             
1013   0555 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1013   0559 79 73 63 61 
1013   055D 6C 6C 5F 66 
1013   0561 69 6C 65 5F 
1013   0565 73 79 73 74 
1013   0569 65 6D 20 63 
1013   056D 61 6C 6C 65 
1013   0571 64 3A 20 00 
1014   0575             syscall_file_system:
1015   0575 DD            push bl
1016   0576 31 F3 16      mov bl, [sys_debug_mode]
1017   0579               ; debug block
1018   0579 C1 00         cmp bl, 0
1019   057B EA            pop bl
1020   057C C6 90 05      je syscall_filesystem_jmp
1021   057F DA            push d
1022   0580 DD            push bl
1023   0581 3B 55 05      mov d, s_syscall_fs_dbg0
1024   0584 07 CA 11      call _puts
1025   0587 2F            mov bl, al
1026   0588 07 6A 12      call print_u8x
1027   058B 07 77 11      call printnl
1028   058E EA            pop bl
1029   058F E7            pop d
1030   0590             syscall_filesystem_jmp:
1031   0590 FD 0A 29 05   jmp [file_system_jmptbl + al]
1032   0594             
1033   0594             fs_mkfs:  
1034   0594 06            sysret  
1035   0595               
1036   0595             fs_cd_root:
1037   0595 10 20 00      mov a, root_id
1038   0598 42 04 17      mov [current_dir_id], a      ; set current directory LBA to ROOT
1039   059B 06            sysret  
1040   059C             
1041   059C             ; filename in D (userspace data)
1042   059C             ; permission in BL
1043   059C             fs_chmod:
1044   059C DD            push bl
1045   059D FD 4E         mov si, d
1046   059F FD 4F FF 1B   mov di, user_data
1047   05A3 38 80 00      mov c, 128
1048   05A6 04            load                        ; load filename from user-space
1049   05A7 14 04 17      mov a, [current_dir_id]
1050   05AA 77            inc a                       ; metadata sector
1051   05AB 27            mov b, a
1052   05AC 38 00 00      mov c, 0                    ; upper LBA = 0
1053   05AF 22 01         mov ah, $01                  ; 1 sector
1054   05B1 3B FF 23      mov d, transient_area
1055   05B4 07 27 04      call ide_read_sect          ; read directory
1056   05B7 FD 10         cla
1057   05B9 42 FC 16      mov [index], a              ; reset file counter
1058   05BC             fs_chmod_L1:
1059   05BC FD 4E         mov si, d
1060   05BE FD 4F FF 1B   mov di, user_data
1061   05C2 07 0D 10      call _strcmp
1062   05C5 C6 DC 05      je fs_chmod_found_entry
1063   05C8 58 20 00      add d, 32
1064   05CB 14 FC 16      mov a, [index]
1065   05CE 77            inc a
1066   05CF 42 FC 16      mov [index], a
1067   05D2 AF 10 00      cmp a, FST_FILES_PER_DIR
1068   05D5 C7 BC 05      jne fs_chmod_L1
1069   05D8 EA            pop bl
1070   05D9 0A F5 05      jmp fs_chmod_not_found
1071   05DC             fs_chmod_found_entry:  
1072   05DC FD 79         mov g, b                    ; save LBA
1073   05DE EA            pop bl                      ; retrieve saved permission value
1074   05DF 1F 18 00      mov al, [d + 24]            ; read file permissions
1075   05E2 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1076   05E4 8C            or al, bl                   ; set new permissions
1077   05E5 3F 18 00      mov [d + 24], al            ; write new permissions
1078   05E8 38 00 00      mov c, 0
1079   05EB 3B FF 23      mov d, transient_area
1080   05EE 22 01         mov ah, $01                 ; disk write 1 sect
1081   05F0 FD 27         mov b, g                    ; retrieve LBA
1082   05F2 07 4D 04      call ide_write_sect         ; write sector
1083   05F5             fs_chmod_not_found:
1084   05F5 06            sysret
1085   05F6             
1086   05F6             ;------------------------------------------------------------------------------------------------------;
1087   05F6             ; CREATE NEW DIRECTORY
1088   05F6             ;------------------------------------------------------------------------------------------------------;
1089   05F6             ; search list for NULL name entry. add new directory to list
1090   05F6             fs_mkdir:
1091   05F6 FD 4E         mov si, d
1092   05F8 FD 4F FF 1B   mov di, user_data
1093   05FC 38 00 02      mov c, 512
1094   05FF 04            load                        ; load data from user-space
1095   0600 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1096   0603                                           ; when checking for NULL name, since root has a NULL name)
1097   0603 38 00 00      mov c, 0                    ; upper LBA = 0
1098   0606             fs_mkdir_L1:  
1099   0606 22 01         mov ah, $01                  ; 1 sector
1100   0608 3B FF 23      mov d, transient_area
1101   060B 07 27 04      call ide_read_sect          ; read sector
1102   060E BD 00         cmp byte[d], 0              ; check for NULL
1103   0610 C6 19 06      je fs_mkdir_found_null
1104   0613 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1105   0616 0A 06 06      jmp fs_mkdir_L1
1106   0619             fs_mkdir_found_null:
1107   0619             ;create header file by grabbing dir name from parameter
1108   0619 D8            push b                      ; save new directory's LBA
1109   061A 38 40 00      mov c, 64
1110   061D FD 4D FF 1B   mov si, user_data
1111   0621 FD 4F FF 23   mov di, transient_area
1112   0625 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1113   0627 14 04 17      mov a, [current_dir_id]
1114   062A 42 3F 24      mov [transient_area + 64], a    ; store parent directory LBA
1115   062D 19 00         mov al, 0
1116   062F FD 4F FF 25   mov di, transient_area + 512
1117   0633 38 00 02      mov c, 512
1118   0636 FD F7         rep stosb                       ; clean buffer
1119   0638 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1120   063B             ; write directory entry sectors
1121   063B 3B FF 23      mov d, transient_area
1122   063E 22 02         mov ah, $02                     ; disk write, 2 sectors
1123   0640 07 4D 04      call ide_write_sect             ; write sector
1124   0643             ; now we need to add the new directory to the list, insIDE the current directory
1125   0643 14 04 17      mov a, [current_dir_id]
1126   0646 53 01 00      add a, 1
1127   0649 27            mov b, a                        ; metadata sector
1128   064A 38 00 00      mov c, 0
1129   064D FD 79         mov g, b                        ; save LBA
1130   064F 3B FF 23      mov d, transient_area
1131   0652 22 01         mov ah, $01                  ; 1 sector
1132   0654 07 27 04      call ide_read_sect              ; read metadata sector
1133   0657             fs_mkdir_L2:
1134   0657 BD 00         cmp byte[d], 0
1135   0659 C6 62 06      je fs_mkdir_found_null2
1136   065C 58 20 00      add d, FST_ENTRY_SIZE
1137   065F 0A 57 06      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1138   0662             fs_mkdir_found_null2:
1139   0662 FD 4D FF 1B   mov si, user_data
1140   0666 FD 50         mov di, d
1141   0668 07 22 10      call _strcpy                    ; copy directory name
1142   066B 58 18 00      add d, 24                       ; goto ATTRIBUTES
1143   066E 19 0B         mov al, %00001011               ; directory, no execute, write, read
1144   0670 3E            mov [d], al      
1145   0671 79            inc d
1146   0672 E5            pop b
1147   0673 D8            push b                          ; push LBA back
1148   0674 FD 43         mov [d], b                      ; save LBA
1149   0676             ; set file creation date  
1150   0676 58 04 00      add d, 4
1151   0679 19 04         mov al, 4
1152   067B 05 01         syscall sys_rtc
1153   067D 1A            mov al, ah
1154   067E 3E            mov [d], al                     ; set day
1155   067F 79            inc d
1156   0680 19 05         mov al, 5
1157   0682 05 01         syscall sys_rtc
1158   0684 1A            mov al, ah
1159   0685 3E            mov [d], al                     ; set month
1160   0686 79            inc d
1161   0687 19 06         mov al, 6
1162   0689 05 01         syscall sys_rtc
1163   068B 1A            mov al, ah
1164   068C 3E            mov [d], al                     ; set year
1165   068D             ; write sector into disk for new directory entry
1166   068D FD 27         mov b, g
1167   068F 38 00 00      mov c, 0
1168   0692 3B FF 23      mov d, transient_area
1169   0695 22 01         mov ah, $01                     ; disk write, 1 sector
1170   0697 07 4D 04      call ide_write_sect             ; write sector
1171   069A             
1172   069A             ; after adding the new directory's information to its parent directory's list
1173   069A             ; we need to now enter the new directory, and to it add two new directories!
1174   069A             ; which directories do we need to add ? '..' and '.' are the directories needed.
1175   069A             ; importantly, note that these two new directories are only entries in the list
1176   069A             ; and do not have actual physical entries in the disk as real directories.
1177   069A             ; i.e. they only exist as list entries in the new directory created so that
1178   069A             ; the new directory can reference its parent and itself.
1179   069A             ; We need to add both '..' and '.'
1180   069A             ; this first section is for '..' and on the section below we do the same for '.'
1181   069A E4            pop a                         ; retrieve the new directory's LBA  
1182   069B D7            push a                        ; and save again
1183   069C 53 01 00      add a, 1
1184   069F 27            mov b, a                      ; metadata sector
1185   06A0 38 00 00      mov c, 0
1186   06A3 FD 79         mov g, b                      ; save LBA
1187   06A5 3B FF 23      mov d, transient_area
1188   06A8 22 01         mov ah, $01                  ; 1 sector
1189   06AA 07 27 04      call ide_read_sect            ; read metadata sector
1190   06AD             fs_mkdir_L3:
1191   06AD BD 00         cmp byte[d], 0
1192   06AF C6 B8 06      je fs_mkdir_found_null3
1193   06B2 58 20 00      add d, FST_ENTRY_SIZE
1194   06B5 0A AD 06      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1195   06B8             fs_mkdir_found_null3:
1196   06B8 FD 4D 14 17   mov si, s_parent_dir
1197   06BC FD 50         mov di, d
1198   06BE 07 22 10      call _strcpy                  ; copy directory name
1199   06C1 58 18 00      add d, 24                     ; goto ATTRIBUTES
1200   06C4 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1201   06C6 3E            mov [d], al      
1202   06C7 79            inc d
1203   06C8 29 04 17      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1204   06CB FD 43         mov [d], b                    ; save LBA
1205   06CD             ; set file creation date  
1206   06CD 58 04 00      add d, 4
1207   06D0 19 04         mov al, 4
1208   06D2 05 01         syscall sys_rtc
1209   06D4 1A            mov al, ah
1210   06D5 3E            mov [d], al                   ; set day
1211   06D6 79            inc d
1212   06D7 19 05         mov al, 5
1213   06D9 05 01         syscall sys_rtc
1214   06DB 1A            mov al, ah
1215   06DC 3E            mov [d], al                   ; set month
1216   06DD 79            inc d
1217   06DE 19 06         mov al, 6
1218   06E0 05 01         syscall sys_rtc
1219   06E2 1A            mov al, ah
1220   06E3 3E            mov [d], al                   ; set year
1221   06E4             ; write sector into disk for new directory entry
1222   06E4 FD 27         mov b, g
1223   06E6 38 00 00      mov c, 0
1224   06E9 3B FF 23      mov d, transient_area
1225   06EC 22 01         mov ah, $01                   ; disk write, 1 sector
1226   06EE 07 4D 04      call ide_write_sect           ; write sector
1227   06F1             ;;;;;;;;;;;;;
1228   06F1             ; like we did above for '..', we need to now add the '.' directory to the list.
1229   06F1             ;------------------------------------------------------------------------------------------------------;
1230   06F1 E4            pop a                         ; retrieve the new directory's LBA  
1231   06F2 D7            push a
1232   06F3 53 01 00      add a, 1
1233   06F6 27            mov b, a                      ; metadata sector
1234   06F7 38 00 00      mov c, 0
1235   06FA FD 79         mov g, b                      ; save LBA
1236   06FC 3B FF 23      mov d, transient_area
1237   06FF 22 01         mov ah, $01                  ; 1 sector
1238   0701 07 27 04      call ide_read_sect            ; read metadata sector
1239   0704             fs_mkdir_L4:
1240   0704 BD 00         cmp byte[d], 0
1241   0706 C6 0F 07      je fs_mkdir_found_null4
1242   0709 58 20 00      add d, FST_ENTRY_SIZE
1243   070C 0A 04 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1244   070F             fs_mkdir_found_null4:
1245   070F FD 4D 17 17   mov si, s_current_dir
1246   0713 FD 50         mov di, d
1247   0715 07 22 10      call _strcpy                  ; copy directory name
1248   0718 58 18 00      add d, 24                     ; goto ATTRIBUTES
1249   071B 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1250   071D 3E            mov [d], al      
1251   071E 79            inc d
1252   071F E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1253   0720 FD 43         mov [d], b                    ; save LBA
1254   0722             ; set file creation date  
1255   0722 58 04 00      add d, 4
1256   0725 19 04         mov al, 4
1257   0727 05 01         syscall sys_rtc
1258   0729 1A            mov al, ah
1259   072A 3E            mov [d], al                   ; set day
1260   072B 79            inc d
1261   072C 19 05         mov al, 5
1262   072E 05 01         syscall sys_rtc
1263   0730 1A            mov al, ah
1264   0731 3E            mov [d], al                   ; set month
1265   0732 79            inc d
1266   0733 19 06         mov al, 6
1267   0735 05 01         syscall sys_rtc
1268   0737 1A            mov al, ah
1269   0738 3E            mov [d], al                   ; set year
1270   0739             ; write sector into disk for new directory entry
1271   0739 FD 27         mov b, g
1272   073B 38 00 00      mov c, 0
1273   073E 3B FF 23      mov d, transient_area
1274   0741 22 01         mov ah, $01                   ; disk write, 1 sector
1275   0743 07 4D 04      call ide_write_sect           ; write sector
1276   0746             fs_mkdir_end:
1277   0746 06            sysret
1278   0747             
1279   0747             ;------------------------------------------------------------------------------------------------------;
1280   0747             ; get path from a given directory dirID
1281   0747             ; pseudo code:
1282   0747             ;  fs_dir_id_to_path(int dirID, char *D){
1283   0747             ;    if(dirID == 0){
1284   0747             ;      reverse path in D;
1285   0747             ;      return;
1286   0747             ;    }
1287   0747             ;    else{
1288   0747             ;      copy directory name to end of D;
1289   0747             ;      add '/' to end of D;
1290   0747             ;      parentID = get parent directory ID;
1291   0747             ;      fs_dir_id_to_path(parentID, D);
1292   0747             ;    }
1293   0747             ;  }
1294   0747             ; A = dirID
1295   0747             ; D = generated path string pointer
1296   0747             ;------------------------------------------------------------------------------------------------------;
1297   0747             ; sample path: /usr/bin
1298   0747             fs_dir_id_to_path:
1299   0747 3B 7F 1B      mov d, filename
1300   074A 19 00         mov al, 0
1301   074C 3E            mov [d], al                     ; initialize path string 
1302   074D 14 04 17      mov a, [current_dir_id]
1303   0750 07 5D 07      call fs_dir_id_to_path_E0
1304   0753 3B 7F 1B      mov d, filename
1305   0756 07 B6 0F      call _strrev
1306   0759 07 CA 11      call _puts
1307   075C 06            sysret
1308   075D             fs_dir_id_to_path_E0:
1309   075D 07 7C 07      call get_dirname_from_dirID
1310   0760 FD 4D 19 17   mov si, s_fslash
1311   0764 FD 50         mov di, d
1312   0766 07 30 10      call _strcat                    ; add '/' to end of path
1313   0769 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1314   076C C6 7B 07      je fs_dir_id_to_path_root
1315   076F 07 99 07      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1316   0772 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1317   0775 C6 7B 07      je fs_dir_id_to_path_root
1318   0778 07 5D 07      call fs_dir_id_to_path_E0     ; recursively call itself
1319   077B             fs_dir_id_to_path_root:
1320   077B 09            ret
1321   077C             
1322   077C             ;------------------------------------------------------------------------------------------------------;
1323   077C             ; in_puts:
1324   077C             ; A = directory ID
1325   077C             ; out_puts:
1326   077C             ; D = pointer to directory name string
1327   077C             ;------------------------------------------------------------------------------------------------------;
1328   077C             get_dirname_from_dirID:
1329   077C D7            push a
1330   077D D8            push b
1331   077E DA            push d
1332   077F 27            mov b, a
1333   0780 38 00 00      mov c, 0                      ; upper LBA = 0
1334   0783 22 01         mov ah, $01                  ; 1 sector
1335   0785 3B FF 21      mov d, transient_area - 512
1336   0788 07 27 04      call ide_read_sect            ; read directory
1337   078B 07 B6 0F      call _strrev                  ; reverse dir name before copying
1338   078E FD 4E         mov si, d
1339   0790 E7            pop d                         ; destination address = D value pushed at beginning
1340   0791 FD 50         mov di, d
1341   0793 07 30 10      call _strcat                  ; copy filename to D
1342   0796 E5            pop b
1343   0797 E4            pop a
1344   0798 09            ret
1345   0799             
1346   0799             ;------------------------------------------------------------------------------------------------------;
1347   0799             ; in_puts:
1348   0799             ; A = directory ID
1349   0799             ; out_puts:
1350   0799             ; A = parent directory ID
1351   0799             ;------------------------------------------------------------------------------------------------------;
1352   0799             get_parentID_from_dirID:
1353   0799 D8            push b
1354   079A DA            push d
1355   079B 27            mov b, a
1356   079C 38 00 00      mov c, 0                      ; upper LBA = 0
1357   079F 22 01         mov ah, $01                  ; 1 sector
1358   07A1 3B FF 21      mov d, transient_area - 512
1359   07A4 07 27 04      call ide_read_sect            ; read directory
1360   07A7 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1361   07AA E7            pop d
1362   07AB E5            pop b
1363   07AC 09            ret
1364   07AD             
1365   07AD             ;------------------------------------------------------------------------------------------------------;
1366   07AD             ; get dirID from a given path string
1367   07AD             ; in_puts:
1368   07AD             ; D = path pointer 
1369   07AD             ; out_puts:
1370   07AD             ; A = dirID
1371   07AD             ; if dir non existent, A = FFFF (fail code)
1372   07AD             ; /usr/local/bin    - absolute
1373   07AD             ; local/bin/games    - relative
1374   07AD             ;------------------------------------------------------------------------------------------------------;
1375   07AD             fs_path_to_dir_id_user:
1376   07AD FD 4E         mov si, d
1377   07AF FD 4F FF 1B   mov di, user_data
1378   07B3 38 00 02      mov c, 512
1379   07B6 04            load
1380   07B7 07 BB 07      call get_dirID_from_path
1381   07BA 06            sysret
1382   07BB             get_dirID_from_path:
1383   07BB 26 FF 1B      mov b, user_data
1384   07BE FD 42 EF 15   mov [prog], b                  ; token pointer set to path string
1385   07C2 07 50 14      call get_token
1386   07C5 31 F2 15      mov bl, [tok]
1387   07C8 C1 01         cmp bl, TOK_FSLASH
1388   07CA C6 D6 07      je get_dirID_from_path_abs 
1389   07CD 14 04 17      mov a, [current_dir_id]
1390   07D0 07 D6 15      call _putback
1391   07D3 0A D9 07      jmp get_dirID_from_path_E0
1392   07D6             get_dirID_from_path_abs:
1393   07D6 10 20 00      mov a, root_id
1394   07D9             get_dirID_from_path_E0:
1395   07D9 07 50 14      call get_token
1396   07DC 31 F1 15      mov bl, [toktyp]
1397   07DF C1 00         cmp bl, TOKTYP_IDENTIFIER
1398   07E1 C7 32 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1399   07E4             
1400   07E4 FD 4D F3 15   mov si, tokstr
1401   07E8 FD 4F 7F 1B   mov di, filename
1402   07EC 07 22 10      call _strcpy        
1403   07EF 77            inc a                         ; metadata sector
1404   07F0 27            mov b, a
1405   07F1 38 00 00      mov c, 0                      ; upper LBA = 0
1406   07F4 22 01         mov ah, $01                  ; 1 sector
1407   07F6 3B FF 23      mov d, transient_area
1408   07F9 07 27 04      call ide_read_sect            ; read directory
1409   07FC FD 10         cla
1410   07FE 42 FC 16      mov [index], a
1411   0801             get_dirID_from_path_L1:
1412   0801 FD 4E         mov si, d
1413   0803 FD 4F 7F 1B   mov di, filename
1414   0807 07 0D 10      call _strcmp
1415   080A C6 20 08      je get_dirID_from_path_name_equal  
1416   080D 58 20 00      add d, 32
1417   0810 14 FC 16      mov a, [index]
1418   0813 77            inc a
1419   0814 42 FC 16      mov [index], a
1420   0817 AF 10 00      cmp a, FST_FILES_PER_DIR
1421   081A C6 33 08      je get_dirID_from_path_fail
1422   081D 0A 01 08      jmp get_dirID_from_path_L1
1423   0820             get_dirID_from_path_name_equal:
1424   0820 58 19 00      add d, 25           
1425   0823 15            mov a, [d]                    ; set result register A = dirID
1426   0824 07 50 14      call get_token
1427   0827 31 F2 15      mov bl, [tok]
1428   082A C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1429   082C C6 D9 07      je get_dirID_from_path_E0
1430   082F 07 D6 15      call _putback
1431   0832             get_dirID_from_path_end:
1432   0832 09            ret
1433   0833             get_dirID_from_path_fail:
1434   0833 10 FF FF      mov A, $FFFF
1435   0836 09            ret
1436   0837             
1437   0837             
1438   0837             ;------------------------------------------------------------------------------------------------------;
1439   0837             ; check if file exists by a given path string
1440   0837             ; in_puts:
1441   0837             ; D = path pointer 
1442   0837             ; OUTPUTS:
1443   0837             ; A = success code, if file exists gives LBA, else, give 0
1444   0837             ; /usr/local/bin/ed
1445   0837             ;------------------------------------------------------------------------------------------------------;
1446   0837             fs_filepath_exists_user:
1447   0837 FD 4E         mov si, d
1448   0839 FD 4F FF 1B   mov di, user_data
1449   083D 38 00 02      mov c, 512
1450   0840 04            load
1451   0841 07 45 08      call file_exists_by_path
1452   0844 06            sysret
1453   0845             file_exists_by_path:
1454   0845 26 FF 1B      mov b, user_data
1455   0848 FD 42 EF 15   mov [prog], b                   ; token pointer set to path string
1456   084C 07 50 14      call get_token
1457   084F 31 F2 15      mov bl, [tok]
1458   0852 C1 01         cmp bl, TOK_FSLASH
1459   0854 C6 60 08      je  file_exists_by_path_abs
1460   0857 14 04 17      mov a, [current_dir_id]
1461   085A 07 D6 15      call _putback
1462   085D 0A 63 08      jmp file_exists_by_path_E0
1463   0860             file_exists_by_path_abs:
1464   0860 10 20 00      mov a, root_id
1465   0863             file_exists_by_path_E0:
1466   0863 07 50 14      call get_token
1467   0866 31 F1 15      mov bl, [toktyp]
1468   0869 C1 00         cmp bl, TOKTYP_IDENTIFIER
1469   086B C7 C3 08      jne file_exists_by_path_end     ; check if there are tokens after '/'
1470   086E FD 4D F3 15   mov si, tokstr
1471   0872 FD 4F 7F 1B   mov di, filename
1472   0876 07 22 10      call _strcpy        
1473   0879 77            inc a                           ; metadata sector
1474   087A 27            mov b, a
1475   087B 38 00 00      mov c, 0                        ; upper LBA = 0
1476   087E 22 01         mov ah, $01                  ; 1 sector
1477   0880 3B FF 23      mov d, transient_area
1478   0883 07 27 04      call ide_read_sect              ; read directory
1479   0886 FD 10         cla
1480   0888 42 FC 16      mov [index], a
1481   088B             file_exists_by_path_L1:
1482   088B FD 4E         mov si, d
1483   088D FD 4F 7F 1B   mov di, filename
1484   0891 07 0D 10      call _strcmp
1485   0894 C6 AA 08      je   file_exists_by_path_name_equal
1486   0897 58 20 00      add d, 32
1487   089A 14 FC 16      mov a, [index]
1488   089D 77            inc a
1489   089E 42 FC 16      mov [index], a
1490   08A1 AF 10 00      cmp a, FST_FILES_PER_DIR
1491   08A4 C6 C3 08      je file_exists_by_path_end
1492   08A7 0A 8B 08      jmp file_exists_by_path_L1
1493   08AA             file_exists_by_path_name_equal:
1494   08AA 33 18 00      mov bl, [d + 24]
1495   08AD FD 87 38      and bl, %00111000               ; directory flag
1496   08B0 C1 08         cmp bl, %00001000               ; is dir?
1497   08B2 C6 B9 08      je file_exists_by_path_isdir;
1498   08B5             ; entry is a file
1499   08B5 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1500   08B8 09            ret
1501   08B9             file_exists_by_path_isdir:
1502   08B9 58 19 00      add d, 25           
1503   08BC 15            mov a, [d]                      ; set result register A = dirID
1504   08BD 07 50 14      call get_token
1505   08C0 0A 63 08      jmp file_exists_by_path_E0
1506   08C3             file_exists_by_path_end:
1507   08C3 10 00 00      mov a, 0                        ; return 0 because file was not found
1508   08C6 09            ret
1509   08C7             
1510   08C7             ;------------------------------------------------------------------------------------------------------;
1511   08C7             ; load file data from a given path string
1512   08C7             ; inputs:
1513   08C7             ; D = path pointer 
1514   08C7             ; DI = userspace program data destination
1515   08C7             ; /usr/local/bin/ed
1516   08C7             ; ./ed
1517   08C7             ;------------------------------------------------------------------------------------------------------;
1518   08C7             fs_load_from_path_user:
1519   08C7 E3            push di
1520   08C8 FD 4E         mov si, d
1521   08CA FD 4F FF 1B   mov di, user_data
1522   08CE 38 00 02      mov c, 512
1523   08D1 04            load
1524   08D2 07 DF 08      call loadfile_from_path
1525   08D5 F0            pop di
1526   08D6 FD 4D FF 23   mov si, transient_area
1527   08DA 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1528   08DD 03            store
1529   08DE 06            sysret
1530   08DF             loadfile_from_path:
1531   08DF 26 FF 1B      mov b, user_data
1532   08E2 FD 42 EF 15   mov [prog], b                 ; token pointer set to path string
1533   08E6 07 50 14      call get_token
1534   08E9 31 F2 15      mov bl, [tok]
1535   08EC C1 01         cmp bl, TOK_FSLASH
1536   08EE C6 FA 08      je loadfile_from_path_abs 
1537   08F1 14 04 17      mov a, [current_dir_id]
1538   08F4 07 D6 15      call _putback
1539   08F7 0A FD 08      jmp loadfile_from_path_E0
1540   08FA             loadfile_from_path_abs:
1541   08FA 10 20 00      mov a, root_id
1542   08FD             loadfile_from_path_E0:
1543   08FD 07 50 14      call get_token
1544   0900 31 F1 15      mov bl, [toktyp]
1545   0903 C1 00         cmp bl, TOKTYP_IDENTIFIER
1546   0905 C7 6A 09      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1547   0908 FD 4D F3 15   mov si, tokstr
1548   090C FD 4F 7F 1B   mov di, filename
1549   0910 07 22 10      call _strcpy        
1550   0913 77            inc a                         ; metadata sector
1551   0914 27            mov b, a
1552   0915 38 00 00      mov c, 0                      ; upper LBA = 0
1553   0918 22 01         mov ah, $01                  ; 1 sector
1554   091A 3B FF 23      mov d, transient_area
1555   091D 07 27 04      call ide_read_sect            ; read directory
1556   0920 FD 10         cla
1557   0922 42 FC 16      mov [index], a
1558   0925             loadfile_from_path_L1:
1559   0925 FD 4E         mov si, d
1560   0927 FD 4F 7F 1B   mov di, filename
1561   092B 07 0D 10      call _strcmp
1562   092E C6 44 09      je loadfile_from_path_name_equal  
1563   0931 58 20 00      add d, 32
1564   0934 14 FC 16      mov a, [index]
1565   0937 77            inc a
1566   0938 42 FC 16      mov [index], a
1567   093B AF 10 00      cmp a, FST_FILES_PER_DIR
1568   093E C6 6A 09      je loadfile_from_path_end
1569   0941 0A 25 09      jmp loadfile_from_path_L1
1570   0944             loadfile_from_path_name_equal:
1571   0944 33 18 00      mov bl, [d + 24]
1572   0947 FD 87 38      and bl, %00111000             ; directory flag
1573   094A C1 08         cmp bl, %00001000             ; is dir?
1574   094C C6 60 09      je loadfile_isdirectory  
1575   094F             ; entry is a file
1576   094F 2B 19 00      mov b, [d + 25]               ; get LBA
1577   0952 FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1578   0954 3B FF 23      mov d, transient_area
1579   0957 38 00 00      mov c, 0
1580   095A 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1581   095C 07 27 04      call ide_read_sect            ; read sector
1582   095F 09            ret
1583   0960             loadfile_isdirectory:
1584   0960 58 19 00      add d, 25           
1585   0963 15            mov a, [d]                    ; set result register A = dirID
1586   0964 07 50 14      call get_token
1587   0967 0A FD 08      jmp loadfile_from_path_E0
1588   096A             loadfile_from_path_end:
1589   096A 09            ret
1590   096B             
1591   096B             ;------------------------------------------------------------------------------------------------------;
1592   096B             ; return the ID of the current directory
1593   096B             ; ID returned in B
1594   096B             ;------------------------------------------------------------------------------------------------------;
1595   096B             fs_get_curr_dirID:
1596   096B 29 04 17      mov b, [current_dir_id]
1597   096E 06            sysret
1598   096F             
1599   096F             ;------------------------------------------------------------------------------------------------------;
1600   096F             ; CD
1601   096F             ;------------------------------------------------------------------------------------------------------;
1602   096F             ; new dirID in B
1603   096F             fs_cd:
1604   096F FD 42 04 17   mov [current_dir_id], b
1605   0973 06            sysret  
1606   0974             
1607   0974             ;------------------------------------------------------------------------------------------------------;
1608   0974             ; LS
1609   0974             ; dirID in B
1610   0974             ;------------------------------------------------------------------------------------------------------;
1611   0974 00 00       ls_count:       .dw 0
1612   0976             fs_ls:
1613   0976 FD 77         inc b                        ; metadata sector
1614   0978 38 00 00      mov c, 0                     ; upper LBA = 0
1615   097B 22 01         mov ah, $01                  ; 1 sector
1616   097D 3B FF 23      mov d, transient_area
1617   0980 07 27 04      call ide_read_sect           ; read directory
1618   0983 FD 10         cla
1619   0985 42 FC 16      mov [index], a               ; reset entry index
1620   0988 3D 74 09      mov [ls_count], al           ; reset item count
1621   098B             fs_ls_L1:
1622   098B BD 00         cmp byte [d], 0              ; check for NULL
1623   098D C6 24 0A      je fs_ls_next
1624   0990             fs_ls_non_null:
1625   0990 1D 74 09      mov al, [ls_count]
1626   0993 7A            inc al
1627   0994 3D 74 09      mov [ls_count], al           ; increment item count
1628   0997 1F 18 00      mov al, [d + 24]
1629   099A 87 38         and al, %00111000
1630   099C FD A2 03      shr al, 3
1631   099F 22 00         mov ah, 0                    ; file type
1632   09A1 B7 20 17      mov a, [a + file_type]      
1633   09A4 23            mov ah, al
1634   09A5 07 9E 10      call _putchar
1635   09A8 1F 18 00      mov al, [d + 24]
1636   09AB 87 01         and al, %00000001
1637   09AD 22 00         mov ah, 0
1638   09AF B7 1B 17      mov a, [a + file_attrib]     ; read
1639   09B2 23            mov ah, al
1640   09B3 07 9E 10      call _putchar
1641   09B6 1F 18 00      mov al, [d + 24]
1642   09B9 87 02         and al, %00000010
1643   09BB 22 00         mov ah, 0
1644   09BD B7 1B 17      mov a, [a + file_attrib]     ; write
1645   09C0 23            mov ah, al
1646   09C1 07 9E 10      call _putchar
1647   09C4 1F 18 00      mov al, [d + 24]
1648   09C7 87 04         and al, %00000100
1649   09C9 22 00         mov ah, 0
1650   09CB B7 1B 17      mov a, [a + file_attrib]     ; execute
1651   09CE 23            mov ah, al
1652   09CF 07 9E 10      call _putchar
1653   09D2 22 20         mov ah, $20
1654   09D4 07 9E 10      call _putchar  
1655   09D7 2B 1B 00      mov b, [d + 27]
1656   09DA 07 26 12      call print_u16x              ; filesize
1657   09DD 22 20         mov ah, $20
1658   09DF 07 9E 10      call _putchar  
1659   09E2 2B 19 00      mov b, [d + 25]
1660   09E5 07 26 12      call print_u16x              ; dirID / LBA
1661   09E8 22 20         mov ah, $20
1662   09EA 07 9E 10      call _putchar
1663   09ED             ; print date
1664   09ED 33 1D 00      mov bl, [d + 29]             ; day
1665   09F0 07 6A 12      call print_u8x
1666   09F3 22 20         mov ah, $20
1667   09F5 07 9E 10      call _putchar  
1668   09F8 1F 1E 00      mov al, [d + 30]             ; month
1669   09FB FD 9E 02      shl al, 2
1670   09FE DA            push d
1671   09FF 3B DF 17      mov d, s_months
1672   0A02 22 00         mov ah, 0
1673   0A04 59            add d, a
1674   0A05 07 CA 11      call _puts
1675   0A08 E7            pop d
1676   0A09 22 20         mov ah, $20
1677   0A0B 07 9E 10      call _putchar
1678   0A0E 2E 20         mov bl, $20
1679   0A10 07 6A 12      call print_u8x
1680   0A13 33 1F 00      mov bl, [d + 31]             ; year
1681   0A16 07 6A 12      call print_u8x  
1682   0A19 22 20         mov ah, $20
1683   0A1B 07 9E 10      call _putchar  
1684   0A1E 07 CA 11      call _puts                   ; print filename  
1685   0A21 07 77 11      call printnl
1686   0A24             fs_ls_next:
1687   0A24 14 FC 16      mov a, [index]
1688   0A27 77            inc a
1689   0A28 42 FC 16      mov [index], a
1690   0A2B AF 10 00      cmp a, FST_FILES_PER_DIR
1691   0A2E C6 37 0A      je fs_ls_end
1692   0A31 58 20 00      add d, 32      
1693   0A34 0A 8B 09      jmp fs_ls_L1  
1694   0A37             fs_ls_end:
1695   0A37 3B 30 17      mov d, s_ls_total
1696   0A3A 07 CA 11      call _puts
1697   0A3D 1D 74 09      mov al, [ls_count]
1698   0A40 07 7C 12      call print_u8d
1699   0A43 07 77 11      call printnl
1700   0A46 06            sysret
1701   0A47             
1702   0A47             
1703   0A47             ; file structure:
1704   0A47             ; 512 bytes header
1705   0A47             ; header used to tell whether the block is free
1706   0A47             ;------------------------------------------------------------------------------------------------------;
1707   0A47             ; CREATE NEW TEXTFILE
1708   0A47             ;------------------------------------------------------------------------------------------------------;
1709   0A47             ; d = content pointer in user space
1710   0A47             ; c = file size
1711   0A47             fs_starcom:
1712   0A47 FD 4E       	mov si, d
1713   0A49 FD 4F FF 23 	mov di, transient_area
1714   0A4D 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1715   0A50 04          	load					; load data from user-space
1716   0A51 07 D2 0A    	call fs_find_empty_block	; look for empty data blocks
1717   0A54 D8          	push b				; save empty block LBA
1718   0A55 FD 79         mov g, b
1719   0A57             ;create header file by grabbing file name from parameter	
1720   0A57 3B FF 25    	mov d, transient_area + 512			; pointer to file contents
1721   0A5A D9          	push c							; save length
1722   0A5B 19 01       	mov al, 1
1723   0A5D 3D FF 23    	mov [transient_area], al					; mark sectors as USED (not NULL)
1724   0A60 3B FF 23    	mov d, transient_area
1725   0A63 12            mov a, c
1726   0A64 26 00 02      mov b, 512
1727   0A67 AE            div a, b
1728   0A68 FD 77         inc b         ; inc b as the division will most likely have a remainder
1729   0A6A 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1730   0A6B 38 00 00    	mov c, 0      ; lba 
1731   0A6E FD 27         mov b, g      ; lba 
1732   0A70 07 4D 04    	call ide_write_sect			; write sectors
1733   0A73             ; now we add the file to the current directory!
1734   0A73             fs_starcom_add_to_dir:	
1735   0A73 14 04 17    	mov a, [current_dir_id]
1736   0A76 77          	inc a
1737   0A77 27          	mov b, a					; metadata sector
1738   0A78 38 00 00    	mov c, 0
1739   0A7B FD 79       	mov g, b					; save LBA
1740   0A7D 3B FF 21    	mov d, scrap_sector
1741   0A80 22 01       	mov ah, $01			  ; 1 sector
1742   0A82 07 27 04    	call ide_read_sect		; read metadata sector
1743   0A85             fs_starcom_add_to_dir_L2:
1744   0A85 BD 00       	cmp byte[d], 0
1745   0A87 C6 90 0A    	je fs_starcom_add_to_dir_null
1746   0A8A 58 20 00    	add d, FST_ENTRY_SIZE
1747   0A8D 0A 85 0A    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1748   0A90             fs_starcom_add_to_dir_null:
1749   0A90 FD 4D 00 24 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1750   0A94 FD 50       	mov di, d
1751   0A96 07 22 10    	call _strcpy			; copy file name
1752   0A99 58 18 00    	add d, 24			; skip name
1753   0A9C 19 07       	mov al, %00000111	; type=file, execute, write, read
1754   0A9E 3E          	mov [d], al			
1755   0A9F 58 03 00    	add d, 3
1756   0AA2 E4          	pop a
1757   0AA3 5F 00 02      sub a, 512
1758   0AA6 43          	mov [d], a ; file size
1759   0AA7 63 02 00    	sub d, 2
1760   0AAA E5          	pop b				; get file LBA
1761   0AAB FD 43       	mov [d], b			; save LBA	
1762   0AAD             ; set file creation date	
1763   0AAD 58 04 00    	add d, 4
1764   0AB0 19 04       	mov al, 4
1765   0AB2 05 01       	syscall sys_rtc
1766   0AB4 1A          	mov al, ah
1767   0AB5 3E          	mov [d], al			; set day
1768   0AB6 79          	inc d
1769   0AB7 19 05       	mov al, 5
1770   0AB9 05 01       	syscall sys_rtc
1771   0ABB 1A          	mov al, ah
1772   0ABC 3E          	mov [d], al			; set month
1773   0ABD 79          	inc d
1774   0ABE 19 06       	mov al, 6
1775   0AC0 05 01       	syscall sys_rtc
1776   0AC2 1A          	mov al, ah
1777   0AC3 3E          	mov [d], al			; set year
1778   0AC4             ; write sector into disk for new directory entry
1779   0AC4 FD 27       	mov b, g
1780   0AC6 38 00 00    	mov c, 0
1781   0AC9 3B FF 21    	mov d, scrap_sector
1782   0ACC 22 01       	mov ah, $01			; disk write, 1 sector
1783   0ACE 07 4D 04    	call ide_write_sect		; write sector
1784   0AD1 06          	sysret
1785   0AD2             
1786   0AD2             ;------------------------------------------------------------------------------------------------------;
1787   0AD2             ; finds an empty data block
1788   0AD2             ; block LBA returned in B
1789   0AD2             ;------------------------------------------------------------------------------------------------------;
1790   0AD2             fs_find_empty_block:
1791   0AD2 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1792   0AD5 38 00 00      mov c, 0                ; upper LBA = 0
1793   0AD8             fs_find_empty_block_L1:  
1794   0AD8 22 01         mov ah, $01                  ; 1 sector
1795   0ADA 3B FF 21      mov d, transient_area - 512
1796   0ADD 07 27 04      call ide_read_sect      ; read sector
1797   0AE0 BD 00         cmp byte [d], 0
1798   0AE2 C6 EB 0A      je fs_find_empty_block_found_null
1799   0AE5 55 20 00      add b, FS_SECTORS_PER_FILE
1800   0AE8 0A D8 0A      jmp fs_find_empty_block_L1
1801   0AEB             fs_find_empty_block_found_null:
1802   0AEB 09            ret
1803   0AEC             
1804   0AEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1805   0AEC             ;; CREATE NEW TEXTFILE
1806   0AEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1807   0AEC             ; search for first null block
1808   0AEC             fs_mktxt:
1809   0AEC FD 4E       	mov si, d
1810   0AEE FD 4F FF 1B 	mov di, user_data
1811   0AF2 38 00 01    	mov c, 256
1812   0AF5 04          	load					; load data from user-space
1813   0AF6             	
1814   0AF6 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1815   0AF9 38 00 00    	mov c, 0						; reset LBA to 0
1816   0AFC             fs_mktxt_L1:	
1817   0AFC 10 02 01    	mov a, $0102			; disk read
1818   0AFF 3B FF 23    	mov d, transient_area
1819   0B02 05 02       	syscall sys_ide ; read sector
1820   0B04 1E          	mov al, [d]
1821   0B05 B9 00       	cmp al, 0			; check for NULL
1822   0B07 C6 10 0B    	je fs_mktxt_found_null
1823   0B0A 55 20 00    	add b, FS_SECTORS_PER_FILE
1824   0B0D 0A FC 0A    	jmp fs_mktxt_L1
1825   0B10             fs_mktxt_found_null:
1826   0B10 D8          	push b				; save LBA
1827   0B11             ;create header file by grabbing file name from parameter	
1828   0B11 3B 11 17    	mov d, s_dataentry
1829   0B14 07 CA 11    	call _puts
1830   0B17 3B FF 25    	mov d, transient_area + 512			; pointer to file contents
1831   0B1A 07 30 11    	call _gettxt
1832   0B1D 07 FD 0F    	call _strlen						; get length of file
1833   0B20 D9          	push c							; save length
1834   0B21 19 01       	mov al, 1
1835   0B23 3D FF 23    	mov [transient_area], al					; mark sectors as USED (not NULL)
1836   0B26 10 00 00    	mov a, 0
1837   0B29 42 FC 16    	mov [index], a
1838   0B2C 3B FF 23    	mov d, transient_area
1839   0B2F 13          	mov a, d
1840   0B30 42 FE 16    	mov [buffer_addr], a
1841   0B33             fs_mktxt_L2:
1842   0B33 38 00 00    	mov c, 0
1843   0B36 10 03 01    	mov a, $0103			; disk write, 1 sector
1844   0B39 05 02       	syscall sys_ide		; write sector
1845   0B3B 14 FC 16    	mov a, [index]
1846   0B3E 77          	inc a
1847   0B3F 42 FC 16    	mov [index], a
1848   0B42 AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1849   0B45 C6 57 0B    	je fs_mktxt_add_to_dir
1850   0B48 FD 77       	inc b
1851   0B4A 14 FE 16    	mov a, [buffer_addr]
1852   0B4D 53 00 02    	add a, 512
1853   0B50 42 FE 16    	mov [buffer_addr], a
1854   0B53 3C          	mov d, a
1855   0B54 0A 33 0B    	jmp fs_mktxt_L2
1856   0B57             ; now we add the file to the current directory!
1857   0B57             fs_mktxt_add_to_dir:	
1858   0B57 14 04 17    	mov a, [current_dir_id]
1859   0B5A 77          	inc a
1860   0B5B 27          	mov b, a					; metadata sector
1861   0B5C 38 00 00    	mov c, 0
1862   0B5F FD 79       	mov g, b					; save LBA
1863   0B61 3B FF 23    	mov d, transient_area
1864   0B64 10 02 01    	mov a, $0102			; disk read
1865   0B67 05 02       	syscall sys_ide		; read metadata sector
1866   0B69             fs_mktxt_add_to_dir_L2:
1867   0B69 1E          	mov al, [d]
1868   0B6A B9 00       	cmp al, 0
1869   0B6C C6 75 0B    	je fs_mktxt_add_to_dir_null
1870   0B6F 58 20 00    	add d, FST_ENTRY_SIZE
1871   0B72 0A 69 0B    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1872   0B75             fs_mktxt_add_to_dir_null:
1873   0B75 FD 4D FF 1B 	mov si, user_data
1874   0B79 FD 50       	mov di, d
1875   0B7B 07 22 10    	call _strcpy			; copy file name
1876   0B7E 58 18 00    	add d, 24			; skip name
1877   0B81 19 06       	mov al, %00000110		; no execute, write, read, not directory
1878   0B83 3E          	mov [d], al			
1879   0B84 58 03 00    	add d, 3
1880   0B87 E4          	pop a
1881   0B88 43          	mov [d], a
1882   0B89 63 02 00    	sub d, 2
1883   0B8C E5          	pop b				; get file LBA
1884   0B8D FD 43       	mov [d], b			; save LBA	
1885   0B8F             	
1886   0B8F             	; set file creation date	
1887   0B8F 58 04 00    	add d, 4
1888   0B92 19 04       	mov al, 4
1889   0B94 05 01       	syscall sys_rtc
1890   0B96 1A          	mov al, ah
1891   0B97 3E          	mov [d], al			; set day
1892   0B98             	
1893   0B98 79          	inc d
1894   0B99 19 05       	mov al, 5
1895   0B9B 05 01       	syscall sys_rtc
1896   0B9D 1A          	mov al, ah
1897   0B9E 3E          	mov [d], al			; set month
1898   0B9F             	
1899   0B9F 79          	inc d
1900   0BA0 19 06       	mov al, 6
1901   0BA2 05 01       	syscall sys_rtc
1902   0BA4 1A          	mov al, ah
1903   0BA5 3E          	mov [d], al			; set year
1904   0BA6             	
1905   0BA6             ; write sector into disk for new directory entry
1906   0BA6 FD 27       	mov b, g
1907   0BA8 38 00 00    	mov c, 0
1908   0BAB 3B FF 23    	mov d, transient_area
1909   0BAE 10 03 01    	mov a, $0103			; disk write, 1 sector
1910   0BB1 05 02       	syscall sys_ide		; write sector
1911   0BB3 07 77 11    	call printnl
1912   0BB6 06          	sysret
1913   0BB7             
1914   0BB7             
1915   0BB7             
1916   0BB7             ;------------------------------------------------------------------------------------------------------;
1917   0BB7             ; CREATE NEW BINARY FILE
1918   0BB7             ;------------------------------------------------------------------------------------------------------;
1919   0BB7             ; search for first null block
1920   0BB7             fs_mkbin:
1921   0BB7 19 00         mov al, 0
1922   0BB9 3D F4 16      mov [sys_echo_on], al ; disable echo
1923   0BBC FD 4E         mov si, d
1924   0BBE FD 4F FF 1B   mov di, user_data
1925   0BC2 38 00 02      mov c, 512
1926   0BC5 04            load                          ; load data from user-space
1927   0BC6 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
1928   0BC9 38 00 00      mov c, 0                      ; upper LBA = 0
1929   0BCC             fs_mkbin_L1:  
1930   0BCC 22 01         mov ah, $01                  ; 1 sector
1931   0BCE 3B FF 23      mov d, transient_area
1932   0BD1 07 27 04      call ide_read_sect            ; read sector
1933   0BD4 BD 00         cmp byte[d], 0                ; check for NULL
1934   0BD6 C6 DF 0B      je fs_mkbin_found_null
1935   0BD9 55 20 00      add b, FS_SECTORS_PER_FILE
1936   0BDC 0A CC 0B      jmp fs_mkbin_L1
1937   0BDF             fs_mkbin_found_null:
1938   0BDF D8            push b                        ; save LBA
1939   0BE0             ;create header file by grabbing file name from parameter
1940   0BE0 FD 4F FF 25   mov di, transient_area + 512  ; pointer to file contents
1941   0BE4 07 5A 0F      call _load_hex                ; load binary hex
1942   0BE7 D9            push c                        ; save size (nbr of bytes)
1943   0BE8 19 01         mov al, 1
1944   0BEA 3D FF 23      mov [transient_area], al      ; mark sectors as USED (not NULL)
1945   0BED FD 10         cla
1946   0BEF 42 FC 16      mov [index], a
1947   0BF2 3B FF 23      mov d, transient_area
1948   0BF5 13            mov a, d
1949   0BF6 42 FE 16      mov [buffer_addr], a
1950   0BF9             fs_mkbin_L2:
1951   0BF9 38 00 00      mov c, 0
1952   0BFC 22 01         mov ah, $01                   ; disk write, 1 sector
1953   0BFE 07 4D 04      call ide_write_sect           ; write sector
1954   0C01 14 FC 16      mov a, [index]
1955   0C04 77            inc a
1956   0C05 42 FC 16      mov [index], a
1957   0C08 AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
1958   0C0B C6 1D 0C      je fs_mkbin_add_to_dir
1959   0C0E FD 77         inc b
1960   0C10 14 FE 16      mov a, [buffer_addr]
1961   0C13 53 00 02      add a, 512
1962   0C16 42 FE 16      mov [buffer_addr], a
1963   0C19 3C            mov d, a
1964   0C1A 0A F9 0B      jmp fs_mkbin_L2
1965   0C1D             ; now we add the file to the current directory!
1966   0C1D             fs_mkbin_add_to_dir:  
1967   0C1D 14 04 17      mov a, [current_dir_id]
1968   0C20 77            inc a
1969   0C21 27            mov b, a                      ; metadata sector
1970   0C22 38 00 00      mov c, 0
1971   0C25 FD 79         mov g, b                      ; save LBA
1972   0C27 3B FF 23      mov d, transient_area
1973   0C2A 22 01         mov ah, $01                  ; 1 sector
1974   0C2C 07 27 04      call ide_read_sect            ; read metadata sector
1975   0C2F             fs_mkbin_add_to_dir_L2:
1976   0C2F BD 00         cmp byte[d], 0
1977   0C31 C6 3A 0C      je fs_mkbin_add_to_dir_null
1978   0C34 58 20 00      add d, FST_ENTRY_SIZE
1979   0C37 0A 2F 0C      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1980   0C3A             fs_mkbin_add_to_dir_null:
1981   0C3A FD 4D FF 1B   mov si, user_data
1982   0C3E FD 50         mov di, d
1983   0C40 07 22 10      call _strcpy                  ; copy file name
1984   0C43 58 18 00      add d, 24                     ; skip name
1985   0C46 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
1986   0C48 3E            mov [d], al
1987   0C49 58 03 00      add d, 3
1988   0C4C E4            pop a
1989   0C4D 43            mov [d], a
1990   0C4E 63 02 00      sub d, 2
1991   0C51 E5            pop b                         ; get file LBA
1992   0C52 FD 43         mov [d], b                    ; save LBA
1993   0C54               ; set file creation date  
1994   0C54 58 04 00      add d, 4
1995   0C57 19 04         mov al, 4
1996   0C59 05 01         syscall sys_rtc
1997   0C5B 1A            mov al, ah
1998   0C5C 3E            mov [d], al                   ; set day
1999   0C5D 79            inc d
2000   0C5E 19 05         mov al, 5
2001   0C60 05 01         syscall sys_rtc
2002   0C62 1A            mov al, ah
2003   0C63 3E            mov [d], al                   ; set month
2004   0C64 79            inc d
2005   0C65 19 06         mov al, 6
2006   0C67 05 01         syscall sys_rtc
2007   0C69 1A            mov al, ah
2008   0C6A 3E            mov [d], al                   ; set year
2009   0C6B             ; write sector into disk for new directory entry
2010   0C6B FD 27         mov b, g
2011   0C6D 38 00 00      mov c, 0
2012   0C70 3B FF 23      mov d, transient_area
2013   0C73 22 01         mov ah, $01                   ; disk write, 1 sector
2014   0C75 07 4D 04      call ide_write_sect           ; write sector
2015   0C78 19 01         mov al, 1
2016   0C7A 3D F4 16      mov [sys_echo_on], al ; enable echo
2017   0C7D 06            sysret
2018   0C7E             
2019   0C7E             ;------------------------------------------------------------------------------------------------------;
2020   0C7E             ; PWD - PRINT WORKING DIRECTORY
2021   0C7E             ;------------------------------------------------------------------------------------------------------;    
2022   0C7E             fs_pwd:
2023   0C7E 3B 7F 1B      mov d, filename
2024   0C81 19 00         mov al, 0
2025   0C83 3E            mov [d], al                   ; initialize path string 
2026   0C84 14 04 17      mov a, [current_dir_id]
2027   0C87 07 5D 07      call fs_dir_id_to_path_E0
2028   0C8A 3B 7F 1B      mov d, filename
2029   0C8D 07 B6 0F      call _strrev
2030   0C90 07 CA 11      call _puts
2031   0C93 07 77 11      call printnl
2032   0C96 06            sysret
2033   0C97             
2034   0C97             ;------------------------------------------------------------------------------------------------------;
2035   0C97             ; get current directory LBA
2036   0C97             ; A: returned LBA
2037   0C97             ;------------------------------------------------------------------------------------------------------;
2038   0C97             cmd_get_curr_dir_LBA:
2039   0C97 14 04 17      mov a, [current_dir_id]
2040   0C9A 06            sysret
2041   0C9B             
2042   0C9B             ;------------------------------------------------------------------------------------------------------;
2043   0C9B             ; CAT
2044   0C9B             ; userspace destination data pointer in D
2045   0C9B             ; filename starts at D, but is overwritten after the read is made
2046   0C9B             ;------------------------------------------------------------------------------------------------------;:
2047   0C9B             fs_cat:
2048   0C9B DA            push d                              ; save userspace file data destination
2049   0C9C FD 4E         mov si, d
2050   0C9E FD 4F FF 1B   mov di, user_data
2051   0CA2 38 00 02      mov c, 512
2052   0CA5 04            load                                ; copy filename from user-space
2053   0CA6 29 04 17      mov b, [current_dir_id]
2054   0CA9 FD 77         inc b                               ; metadata sector
2055   0CAB 38 00 00      mov c, 0                            ; upper LBA = 0
2056   0CAE 22 01         mov ah, $01                  ; 1 sector
2057   0CB0 3B FF 21      mov d, transient_area-512
2058   0CB3 07 27 04      call ide_read_sect                  ; read directory
2059   0CB6 FD 10         cla
2060   0CB8 42 FC 16      mov [index], a                      ; reset file counter
2061   0CBB             fs_cat_L1:
2062   0CBB FD 4E         mov si, d
2063   0CBD FD 4F FF 1B   mov di, user_data
2064   0CC1 07 0D 10      call _strcmp
2065   0CC4 C6 DA 0C      je fs_cat_found_entry
2066   0CC7 58 20 00      add d, 32
2067   0CCA 14 FC 16      mov a, [index]
2068   0CCD 77            inc a
2069   0CCE 42 FC 16      mov [index], a
2070   0CD1 AF 10 00      cmp a, FST_FILES_PER_DIR
2071   0CD4 C6 F5 0C      je fs_cat_not_found
2072   0CD7 0A BB 0C      jmp fs_cat_L1
2073   0CDA             fs_cat_found_entry:
2074   0CDA 58 19 00      add d, 25                           ; get to dirID of file in disk
2075   0CDD 2A            mov b, [d]                          ; get LBA
2076   0CDE FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2077   0CE0 3B FF 23      mov d, transient_area  
2078   0CE3 38 00 00      mov c, 0
2079   0CE6 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2080   0CE8 07 27 04      call ide_read_sect                  ; read sectors
2081   0CEB F0            pop di                              ; write userspace file data destination to DI
2082   0CEC FD 4D FF 23   mov si, transient_area              ; data origin
2083   0CF0 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2084   0CF3 03            store
2085   0CF4 06            sysret
2086   0CF5             fs_cat_not_found:
2087   0CF5 E7            pop d
2088   0CF6 06            sysret
2089   0CF7             
2090   0CF7             ;------------------------------------------------------------------------------------------------------;
2091   0CF7             ; RMDIR - remove DIR by dirID
2092   0CF7             ;------------------------------------------------------------------------------------------------------;
2093   0CF7             ; deletes a directory entry in the given directory's file list 
2094   0CF7             ; also deletes the actual directory entry in the FST
2095   0CF7             ; synopsis: rmdir /usr/local/testdir
2096   0CF7             ; B = dirID
2097   0CF7             fs_rmdir:
2098   0CF7 FD 79         mov g, b
2099   0CF9 11            mov a, b
2100   0CFA 07 99 07      call get_parentID_from_dirID  ; now get the directory's parent, in A
2101   0CFD D7            push a                        ; save dirID
2102   0CFE             ; search for directory's entry in the parent's directory then and delete it
2103   0CFE 77            inc a                         ; metadata sector
2104   0CFF 27            mov b, a
2105   0D00 38 00 00      mov c, 0                      ; upper LBA = 0
2106   0D03 22 01         mov ah, $01          ;
2107   0D05 3B FF 23      mov d, transient_area
2108   0D08 07 27 04      call ide_read_sect            ; read directory
2109   0D0B FD 10         cla
2110   0D0D 42 FC 16      mov [index], a                ; reset file counter
2111   0D10 FD 27         mov b, g                      ; retrieve directory's dirID
2112   0D12             fs_rmdir_L1:
2113   0D12 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2114   0D15 B0            cmp a, b                      ; compare dirID's to find the directory
2115   0D16 C6 2C 0D      je fs_rmdir_found_entry
2116   0D19 58 20 00      add d, 32
2117   0D1C 14 FC 16      mov a, [index]
2118   0D1F 77            inc a
2119   0D20 42 FC 16      mov [index], a
2120   0D23 AF 10 00      cmp a, FST_FILES_PER_DIR
2121   0D26 C6 51 0D      je fs_rmdir_not_found
2122   0D29 0A 12 0D      jmp fs_rmdir_L1
2123   0D2C             fs_rmdir_found_entry:
2124   0D2C FD 10         cla
2125   0D2E 3E            mov [d], al                   ; make filename NULL
2126   0D2F 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2127   0D32 E5            pop b
2128   0D33 FD 77         inc b                         ; metadata sector
2129   0D35 38 00 00      mov c, 0                      ; upper LBA = 0
2130   0D38 22 01         mov ah, $01          ; 
2131   0D3A 3B FF 23      mov d, transient_area
2132   0D3D 07 4D 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2133   0D40             
2134   0D40 FD 27         mov b, g
2135   0D42 3B FF 23      mov d, transient_area  
2136   0D45 FD 10         cla
2137   0D47 3E            mov [d], al                   ; make directory's name header NULL for re-use
2138   0D48 38 00 00      mov c, 0
2139   0D4B 22 01         mov ah, $01                   ; disk write 1 sect
2140   0D4D 07 4D 04      call ide_write_sect           ; delete directory given by dirID in B
2141   0D50 06            sysret
2142   0D51             fs_rmdir_not_found:
2143   0D51 E5            pop b
2144   0D52 06            sysret
2145   0D53             
2146   0D53             ;------------------------------------------------------------------------------------------------------;
2147   0D53             ; RM - remove file
2148   0D53             ;------------------------------------------------------------------------------------------------------;
2149   0D53             ; frees up the data sectors for the file further down the disk
2150   0D53             ; deletes file entry in the directory's file list 
2151   0D53             fs_rm:
2152   0D53 FD 4E         mov si, d
2153   0D55 FD 4F FF 1B   mov di, user_data
2154   0D59 38 00 02      mov c, 512
2155   0D5C 04            load                          ; load data from user-space
2156   0D5D 14 04 17      mov a, [current_dir_id]
2157   0D60 77            inc a                         ; metadata sector
2158   0D61 27            mov b, a
2159   0D62 38 00 00      mov c, 0                      ; upper LBA = 0
2160   0D65 22 01         mov ah, $01                  ; 1 sector
2161   0D67 3B FF 23      mov d, transient_area
2162   0D6A 07 27 04      call ide_read_sect            ; read directory
2163   0D6D 10 00 00      mov a, 0
2164   0D70 42 FC 16      mov [index], a                ; reset file counter
2165   0D73             fs_rm_L1:
2166   0D73 FD 4E         mov si, d
2167   0D75 FD 4F FF 1B   mov di, user_data
2168   0D79 07 0D 10      call _strcmp
2169   0D7C C6 92 0D      je fs_rm_found_entry
2170   0D7F 58 20 00      add d, 32
2171   0D82 14 FC 16      mov a, [index]
2172   0D85 77            inc a
2173   0D86 42 FC 16      mov [index], a
2174   0D89 AF 10 00      cmp a, FST_FILES_PER_DIR
2175   0D8C C6 BA 0D      je fs_rm_not_found
2176   0D8F 0A 73 0D      jmp fs_rm_L1
2177   0D92             fs_rm_found_entry:
2178   0D92 2B 19 00      mov b, [d + 25]               ; get LBA
2179   0D95 FD 79         mov g, b                      ; save LBA
2180   0D97 19 00         mov al, 0
2181   0D99 3E            mov [d], al                   ; make file entry NULL
2182   0D9A 14 04 17      mov a, [current_dir_id]
2183   0D9D 77            inc a                         ; metadata sector
2184   0D9E 27            mov b, a
2185   0D9F 38 00 00      mov c, 0                      ; upper LBA = 0
2186   0DA2 22 01         mov ah, $01                   ; disk write
2187   0DA4 3B FF 23      mov d, transient_area
2188   0DA7 07 4D 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2189   0DAA 3B FF 23      mov d, transient_area  
2190   0DAD 19 00         mov al, 0
2191   0DAF 3E            mov [d], al                   ; make file's data header NULL for re-use
2192   0DB0 38 00 00      mov c, 0
2193   0DB3 FD 27         mov b, g                      ; get data header LBA
2194   0DB5 22 01         mov ah, $01                   ; disk write 1 sect
2195   0DB7 07 4D 04      call ide_write_sect           ; write sector
2196   0DBA             fs_rm_not_found:  
2197   0DBA 06            sysret  
2198   0DBB             
2199   0DBB             ;------------------------------------------------------------------------------------------------------;
2200   0DBB             ; mv - move / change file name
2201   0DBB             ;------------------------------------------------------------------------------------------------------;
2202   0DBB             fs_mv:
2203   0DBB FD 4E         mov si, d
2204   0DBD FD 4F FF 1B   mov di, user_data
2205   0DC1 38 00 02      mov c, 512
2206   0DC4 04            load                          ; load data from user-space
2207   0DC5 14 04 17      mov a, [current_dir_id]
2208   0DC8 77            inc a                         ; metadata sector
2209   0DC9 27            mov b, a  
2210   0DCA 38 00 00      mov c, 0                      ; upper LBA = 0
2211   0DCD 22 01         mov ah, $01                  ; 1 sector
2212   0DCF 3B FF 23      mov d, transient_area
2213   0DD2 07 27 04      call ide_read_sect            ; read directory
2214   0DD5 FD 10         cla
2215   0DD7 42 FC 16      mov [index], a                ; reset file counter
2216   0DDA             fs_mv_L1:
2217   0DDA FD 4E         mov si, d
2218   0DDC FD 4F FF 1B   mov di, user_data
2219   0DE0 07 0D 10      call _strcmp
2220   0DE3 C6 F9 0D      je fs_mv_found_entry
2221   0DE6 58 20 00      add d, 32
2222   0DE9 14 FC 16      mov a, [index]
2223   0DEC 77            inc a
2224   0DED 42 FC 16      mov [index], a
2225   0DF0 AF 10 00      cmp a, FST_FILES_PER_DIR
2226   0DF3 C6 2B 0E      je fs_mv_not_found
2227   0DF6 0A DA 0D      jmp fs_mv_L1
2228   0DF9             fs_mv_found_entry:  
2229   0DF9 DA            push d
2230   0DFA FD 4D 7F 1C   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2231   0DFE FD 50         mov di, d
2232   0E00 07 22 10      call _strcpy  
2233   0E03 38 00 00      mov c, 0
2234   0E06 3B FF 23      mov d, transient_area
2235   0E09 22 01         mov ah, $01                   ; disk write 1 sect
2236   0E0B 07 4D 04      call ide_write_sect           ; write sector
2237   0E0E E7            pop d
2238   0E0F             ;; need to check whether its a dir or a file here ;;;
2239   0E0F 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2240   0E12 22 01         mov ah, $01
2241   0E14 3B FF 23      mov d, transient_area
2242   0E17 38 00 00      mov c, 0
2243   0E1A 07 27 04      call ide_read_sect            ; read directory entry
2244   0E1D FD 4D 7F 1C   mov si, user_data + 128
2245   0E21 FD 50         mov di, d
2246   0E23 07 22 10      call _strcpy                  ; change directory's name
2247   0E26 22 01         mov ah, $01
2248   0E28 07 4D 04      call ide_write_sect           ; rewrite directory back to disk
2249   0E2B             fs_mv_not_found:
2250   0E2B 06            sysret
2251   0E2C             
2252   0E2C             
2253   0E2C             ;----------------------------------------------------------------------------------------------------;
2254   0E2C             ; Process Index in A
2255   0E2C             ;----------------------------------------------------------------------------------------------------;
2256   0E2C             find_free_proc:
2257   0E2C FD 4D 70 19   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2258   0E30             find_free_proc_L0:
2259   0E30 F6            lodsb                               ; get process state
2260   0E31 B9 00         cmp al, 0
2261   0E33 C6 39 0E      je find_free_proc_free              ; if free, jump
2262   0E36 0A 30 0E      jmp find_free_proc_L0               ; else, goto next
2263   0E39             find_free_proc_free:
2264   0E39 4E            mov a, si
2265   0E3A 5F 70 19      sub a, 1 + proc_availab_table       ; get process index
2266   0E3D 09            ret
2267   0E3E               
2268   0E3E             
2269   0E3E             ;----------------------------------------------------------------------------------------------------;
2270   0E3E             ; Process Index in AL
2271   0E3E             ;----------------------------------------------------------------------------------------------------;
2272   0E3E             proc_memory_map:
2273   0E3E 22 00         mov ah, 0
2274   0E40 27            mov b, a                      ; page in BL, 0 in BH
2275   0E41 FD 9D 05      shl a, 5                      ; multiply by 32
2276   0E44 39            mov c, a                      ; save in C
2277   0E45 57 20 00      add c, 32
2278   0E48             proc_memory_map_L0:
2279   0E48 02            pagemap
2280   0E49 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2281   0E4C 53 01 00      add a, 1                      ; increase both 
2282   0E4F B1            cmp a, c                      ; check to see if we reached the end of memory
2283   0E50 C7 48 0E      jne proc_memory_map_L0
2284   0E53 09            ret
2285   0E54               
2286   0E54             
2287   0E54             syscall_terminate_proc:
2288   0E54 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2289   0E57                                                    ; since they will not be used for anything here.
2290   0E57 1D FB 16      mov al, [active_proc_index]
2291   0E5A 22 00         mov ah, 0  
2292   0E5C FD 9D 05      shl a, 5                             ; x32
2293   0E5F 53 7F 19      add a, proc_names
2294   0E62 3C            mov d, a
2295   0E63 19 00         mov al, 0
2296   0E65 3E            mov [d], al                           ; nullify process name
2297   0E66             
2298   0E66 1D FB 16      mov al, [active_proc_index]
2299   0E69 22 00         mov ah, 0  
2300   0E6B 3C            mov d, a
2301   0E6C 19 00         mov al, 0
2302   0E6E 3F 6F 19      mov [d + proc_availab_table], al    ; make process empty again
2303   0E71               
2304   0E71 1D FA 16      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2305   0E74 80            dec al
2306   0E75 3D FA 16      mov [nbr_active_procs], al
2307   0E78             
2308   0E78             ; now load the shell process again
2309   0E78 19 02         mov al, 2                           ; next process = process 2 = shell
2310   0E7A 3D FB 16      mov [active_proc_index], al         ; set next active proc
2311   0E7D             
2312   0E7D             ; calculate LUT entry for next process
2313   0E7D 22 00         mov ah, 0
2314   0E7F FD 99         shl a                               ; x2
2315   0E81 B7 4A 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2316   0E84               
2317   0E84 4D            mov si, a                           ; source is proc state block
2318   0E85 48            mov a, sp
2319   0E86 5F 13 00      sub a, 19
2320   0E89 4F            mov di, a                           ; destination is kernel stack
2321   0E8A             ; restore SP
2322   0E8A 7D            dec a
2323   0E8B 47            mov sp, a
2324   0E8C 38 14 00      mov c, 20
2325   0E8F FD F5         rep movsb
2326   0E91             ; set VM process
2327   0E91 1D FB 16      mov al, [active_proc_index]
2328   0E94 01            setptb
2329   0E95                 
2330   0E95 4C            popa
2331   0E96 06            sysret
2332   0E97             
2333   0E97             syscall_pause_proc:
2334   0E97             ; save all registers into kernel stack
2335   0E97 4B            pusha
2336   0E98 22 00         mov ah, 0
2337   0E9A 1D FB 16      mov al, [active_proc_index]
2338   0E9D FD 99         shl a              ; x2
2339   0E9F B7 4A 0F      mov a, [proc_table_convert + a]   ; get process state start index
2340   0EA2                 
2341   0EA2 4F            mov di, a
2342   0EA3 48            mov a, sp
2343   0EA4 77            inc a
2344   0EA5 4D            mov si, a
2345   0EA6 38 14 00      mov c, 20
2346   0EA9 FD F5         rep movsb                         ; save process state!
2347   0EAB             ; restore kernel stack position to point before interrupt arrived
2348   0EAB 51 14 00      add sp, 20
2349   0EAE             ; now load the shell process again
2350   0EAE 19 02         mov al, 2                         ; next process = process 2 = shell
2351   0EB0 3D FB 16      mov [active_proc_index], al       ; set next active proc
2352   0EB3             
2353   0EB3             ; calculate LUT entry for next process
2354   0EB3 22 00         mov ah, 0
2355   0EB5 FD 99         shl a                             ; x2
2356   0EB7 B7 4A 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2357   0EBA               
2358   0EBA 4D            mov si, a                         ; source is proc state block
2359   0EBB 48            mov a, sp
2360   0EBC 5F 13 00      sub a, 19
2361   0EBF 4F            mov di, a                         ; destination is kernel stack
2362   0EC0             ; restore SP
2363   0EC0 7D            dec a
2364   0EC1 47            mov sp, a
2365   0EC2 38 14 00      mov c, 20
2366   0EC5 FD F5         rep movsb
2367   0EC7             ; set VM process
2368   0EC7 1D FB 16      mov al, [active_proc_index]
2369   0ECA 01            setptb
2370   0ECB                 
2371   0ECB 4C            popa
2372   0ECC 06            sysret
2373   0ECD             
2374   0ECD             ;----------------------------------------------------------------------------------------------------;
2375   0ECD             ; create a new process
2376   0ECD             ; D = path of the process file to be createed
2377   0ECD             ; B = arguments ptr
2378   0ECD             ;----------------------------------------------------------------------------------------------------;
2379   0ECD             syscall_create_proc:
2380   0ECD             ; we save the active process first  
2381   0ECD 4B            pusha
2382   0ECE 22 00         mov ah, 0
2383   0ED0 1D FB 16      mov al, [active_proc_index]
2384   0ED3 FD 99         shl a              ; x2
2385   0ED5 B7 4A 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2386   0ED8               
2387   0ED8 4F            mov di, a
2388   0ED9 48            mov a, sp
2389   0EDA 77            inc a
2390   0EDB 4D            mov si, a
2391   0EDC 38 14 00      mov c, 20
2392   0EDF FD F5         rep movsb                          ; save process state!
2393   0EE1             ; restore kernel stack position to point before interrupt arrived
2394   0EE1 51 14 00      add sp, 20
2395   0EE4               
2396   0EE4 FD 4E         mov si, d                          ; copy the file path
2397   0EE6 FD 4F FF 1B   mov di, user_data
2398   0EEA 38 00 02      mov c, 512
2399   0EED 04            load
2400   0EEE 11            mov a, b
2401   0EEF 4D            mov si, a                          ; copy the arguments
2402   0EF0 FD 4F FF 21   mov di, scrap_sector
2403   0EF4 38 00 02      mov c, 512
2404   0EF7 04            load
2405   0EF8 07 DF 08      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2406   0EFB                                                  ; the file data is loaded into transient_area
2407   0EFB             ; now we allocate a new process  
2408   0EFB 07 2C 0E      call find_free_proc                ; index in A
2409   0EFE 01            setptb 
2410   0EFF 07 3E 0E      call proc_memory_map               ; map process memory pages
2411   0F02             ; copy arguments into process's memory
2412   0F02 FD 4D FF 21   mov si, scrap_sector
2413   0F06 FD 4F 00 00   mov di, 0
2414   0F0A 38 00 02      mov c, 512
2415   0F0D 03            store
2416   0F0E             ; now copy process binary data into process's memory
2417   0F0E FD 4D FF 23   mov si, transient_area
2418   0F12 FD 4F 00 04   mov di, text_org              ; code origin address for all user processes
2419   0F16 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2420   0F19 03            store                              ; copy process data
2421   0F1A                 
2422   0F1A 07 2C 0E      call find_free_proc                ; index in A
2423   0F1D 3D FB 16      mov [active_proc_index], al        ; set new active process
2424   0F20 FD 9D 05      shl a, 5                           ; x32
2425   0F23 53 7F 19      add a, proc_names
2426   0F26 4F            mov di, a
2427   0F27 FD 4D FF 1B   mov si, user_data                  ; copy and store process filename
2428   0F2B 07 22 10      call _strcpy
2429   0F2E               
2430   0F2E 07 2C 0E      call find_free_proc                ; index in A
2431   0F31 3C            mov d, a
2432   0F32 19 01         mov al, 1
2433   0F34 3F 6F 19      mov [d + proc_availab_table], al   ; make process busy
2434   0F37               
2435   0F37 1D FA 16      mov al, [nbr_active_procs]         ; increase nbr of active processes
2436   0F3A 7A            inc al
2437   0F3B 3D FA 16      mov [nbr_active_procs], al
2438   0F3E             ; launch process
2439   0F3E FD D7 FF FF   push word $FFFF 
2440   0F42 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2441   0F45 FD D7 00 04   push word text_org
2442   0F49 06            sysret
2443   0F4A             
2444   0F4A             proc_table_convert:
2445   0F4A 2F 18         .dw proc_state_table + 0
2446   0F4C 43 18         .dw proc_state_table + 20
2447   0F4E 57 18         .dw proc_state_table + 40
2448   0F50 6B 18         .dw proc_state_table + 60
2449   0F52 7F 18         .dw proc_state_table + 80
2450   0F54 93 18         .dw proc_state_table + 100
2451   0F56 A7 18         .dw proc_state_table + 120
2452   0F58 BB 18         .dw proc_state_table + 140
2453   0F5A               
2454   0F5A             ;----------------------------------------------------------------------------------------------;
2455   0F5A             ; GET HEX FILE
2456   0F5A             ; di = destination address
2457   0F5A             ; return length in bytes in C
2458   0F5A             ;----------------------------------------------------------------------------------------------;
2459   0F5A             _load_hex:
2460   0F5A D7            push a
2461   0F5B D8            push b
2462   0F5C DA            push d
2463   0F5D E2            push si
2464   0F5E E3            push di
2465   0F5F 38 00 00      mov c, 0
2466   0F62 50            mov a, di
2467   0F63 3C            mov d, a          ; start of string data block
2468   0F64 07 A5 10      call _gets        ; get program string
2469   0F67               ;call _puts        ; reprint to screen
2470   0F67 4D            mov si, a
2471   0F68             __load_hex_loop:
2472   0F68 F6            lodsb             ; load from [SI] to AL
2473   0F69 B9 00         cmp al, 0         ; check if ASCII 0
2474   0F6B C6 79 0F      jz __load_hex_ret
2475   0F6E 36            mov bh, al
2476   0F6F F6            lodsb
2477   0F70 2F            mov bl, al
2478   0F71 07 5B 10      call _atoi        ; convert ASCII byte in B to int (to AL)
2479   0F74 F7            stosb             ; store AL to [DI]
2480   0F75 78            inc c
2481   0F76 0A 68 0F      jmp __load_hex_loop
2482   0F79             __load_hex_ret:
2483   0F79 F0            pop di
2484   0F7A EF            pop si
2485   0F7B E7            pop d
2486   0F7C E5            pop b
2487   0F7D E4            pop a
2488   0F7E 09            ret
2489   0F7F             
2490   0F7F             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2491   0F7F             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2492   0F7F             ; for each entry insIDE DIRECTORY:
2493   0F7F             ;  if entry is a file:
2494   0F7F             ;    compare filename to searched filename
2495   0F7F             ;    if filenames are the same, print filename
2496   0F7F             ;  else if entry is a directory:
2497   0F7F             ;    cd to the given directory
2498   0F7F             ;    recursively call cmd_find
2499   0F7F             ;    cd outsIDE previous directory
2500   0F7F             ;  if current entry == last entry, return
2501   0F7F             ; endfor
2502   0F7F             f_find:
2503   0F7F 09            ret
2504   0F80             
2505   0F80             
2506   0F80             ; ---------------------------------------------------------------------
2507   0F80             ; KERNEL RESET VECTOR
2508   0F80             ; ---------------------------------------------------------------------
2509   0F80             kernel_reset_vector:  
2510   0F80 FD 49 FF F7   mov bp, STACK_BEGIN
2511   0F84 FD 47 FF F7   mov sp, STACK_BEGIN
2512   0F88               
2513   0F88 19 80         mov al, %10000000
2514   0F8A FD 0F         stomsk                        ; mask out timer interrupt for now (only allow UART to interrupt)
2515   0F8C FD 0C         sti  
2516   0F8E             
2517   0F8E 0C            lodstat
2518   0F8F 87 DF         and al, %11011111             ; disable display register loading
2519   0F91 0D            stostat
2520   0F92               
2521   0F92             ; reset fifo pointers
2522   0F92 10 FF 1D      mov a, fifo
2523   0F95 3B 00 17      mov d, fifo_in
2524   0F98 43            mov [d], a
2525   0F99 3B 02 17      mov d, fifo_out
2526   0F9C 43            mov [d], a  
2527   0F9D 19 02         mov al, 2
2528   0F9F 05 03         syscall sys_io                ; enable uart in interrupt mode
2529   0FA1               
2530   0FA1 3B 46 17      mov d, s_kernel_started
2531   0FA4 07 CA 11      call _puts
2532   0FA7             
2533   0FA7 19 10         mov al, 16
2534   0FA9 05 04         syscall sys_filesystem        ; set root dirID
2535   0FAB             
2536   0FAB 3B 63 17      mov d, s_prompt_init
2537   0FAE 07 CA 11      call _puts
2538   0FB1 3B 06 17      mov d, s_init_path
2539   0FB4 05 05         syscall sys_create_proc              ; launch init as a new process
2540   0FB6             
2541   0FB6             
2542   0FB6             ; FILE INCLUDES
2543   0FB6             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  0FB6             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0FB6             IDE_buffer       .EQU  $8204
0003+  0FB6             boot_origin      .EQU  $8004
0004+  0FB6             bios_uart        .EQU  $0002
0005+  0FB6             bios_ide         .EQU  $0003
2544   0FB6             .include "lib/stdio.asm"
0001+  0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0FB6             ; stdio.s
0003+  0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0FB6             .include "lib/string.asm"
0001++ 0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0FB6             ; string.s
0003++ 0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0FB6             
0005++ 0FB6             
0006++ 0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0FB6             ; _strrev
0008++ 0FB6             ; reverse a string
0009++ 0FB6             ; D = string address
0010++ 0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0FB6             ; 01234
0012++ 0FB6             _strrev:
0013++ 0FB6 4B          	pusha
0014++ 0FB7 07 FD 0F    	call _strlen	; length in C
0015++ 0FBA 12          	mov a, c
0016++ 0FBB AF 01 00    	cmp a, 1
0017++ 0FBE D0 D8 0F    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0FC1 7D          	dec a
0019++ 0FC2 FD 4E       	mov si, d	; beginning of string
0020++ 0FC4 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0FC6 59          	add d, a	; end of string
0022++ 0FC7 12          	mov a, c
0023++ 0FC8 FD 9B       	shr a		; divide by 2
0024++ 0FCA 39          	mov c, a	; C now counts the steps
0025++ 0FCB             _strrev_L0:
0026++ 0FCB 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0FCC F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0FCD 3E          	mov [d], al	; store left char into right side
0029++ 0FCE 1B          	mov al, bl
0030++ 0FCF F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0FD0 7E          	dec c
0032++ 0FD1 7F          	dec d
0033++ 0FD2 C2 00 00    	cmp c, 0
0034++ 0FD5 C7 CB 0F    	jne _strrev_L0
0035++ 0FD8             _strrev_end:
0036++ 0FD8 4C          	popa
0037++ 0FD9 09          	ret
0038++ 0FDA             	
0039++ 0FDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0FDA             ; _strchr
0041++ 0FDA             ; search string in D for char in AL
0042++ 0FDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0FDA             _strchr:
0044++ 0FDA             _strchr_L0:
0045++ 0FDA 32          	mov bl, [d]
0046++ 0FDB C1 00       	cmp bl, 0
0047++ 0FDD C6 E8 0F    	je _strchr_end
0048++ 0FE0 BA          	cmp al, bl
0049++ 0FE1 C6 E8 0F    	je _strchr_end
0050++ 0FE4 79          	inc d
0051++ 0FE5 0A DA 0F    	jmp _strchr_L0
0052++ 0FE8             _strchr_end:
0053++ 0FE8 1B          	mov al, bl
0054++ 0FE9 09          	ret
0055++ 0FEA             
0056++ 0FEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0FEA             ; _strstr
0058++ 0FEA             ; find sub-string
0059++ 0FEA             ; str1 in SI
0060++ 0FEA             ; str2 in DI
0061++ 0FEA             ; SI points to end of source string
0062++ 0FEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0FEA             _strstr:
0064++ 0FEA DB          	push al
0065++ 0FEB DA          	push d
0066++ 0FEC E3          	push di
0067++ 0FED             _strstr_loop:
0068++ 0FED F3          	cmpsb					; compare a byte of the strings
0069++ 0FEE C7 F9 0F    	jne _strstr_ret
0070++ 0FF1 FC 00 00    	lea d, [di + 0]
0071++ 0FF4 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0FF6 C7 ED 0F    	jne _strstr_loop				; equal chars but not at end
0073++ 0FF9             _strstr_ret:
0074++ 0FF9 F0          	pop di
0075++ 0FFA E7          	pop d
0076++ 0FFB E8          	pop al
0077++ 0FFC 09          	ret
0078++ 0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0FFD             ; length of null terminated string
0080++ 0FFD             ; result in C
0081++ 0FFD             ; pointer in D
0082++ 0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0FFD             _strlen:
0084++ 0FFD DA          	push d
0085++ 0FFE 38 00 00    	mov c, 0
0086++ 1001             _strlen_L1:
0087++ 1001 BD 00       	cmp byte [d], 0
0088++ 1003 C6 0B 10    	je _strlen_ret
0089++ 1006 79          	inc d
0090++ 1007 78          	inc c
0091++ 1008 0A 01 10    	jmp _strlen_L1
0092++ 100B             _strlen_ret:
0093++ 100B E7          	pop d
0094++ 100C 09          	ret
0095++ 100D             
0096++ 100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 100D             ; STRCMP
0098++ 100D             ; compare two strings
0099++ 100D             ; str1 in SI
0100++ 100D             ; str2 in DI
0101++ 100D             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 100D             _strcmp:
0104++ 100D DB          	push al
0105++ 100E DA          	push d
0106++ 100F E3          	push di
0107++ 1010 E2          	push si
0108++ 1011             _strcmp_loop:
0109++ 1011 F3          	cmpsb					; compare a byte of the strings
0110++ 1012 C7 1D 10    	jne _strcmp_ret
0111++ 1015 FB FF FF    	lea d, [si +- 1]
0112++ 1018 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 101A C7 11 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 101D             _strcmp_ret:
0115++ 101D EF          	pop si
0116++ 101E F0          	pop di
0117++ 101F E7          	pop d
0118++ 1020 E8          	pop al
0119++ 1021 09          	ret
0120++ 1022             
0121++ 1022             
0122++ 1022             ; STRCPY
0123++ 1022             ; copy null terminated string from SI to DI
0124++ 1022             ; source in SI
0125++ 1022             ; destination in DI
0126++ 1022             _strcpy:
0127++ 1022 E2          	push si
0128++ 1023 E3          	push di
0129++ 1024 DB          	push al
0130++ 1025             _strcpy_L1:
0131++ 1025 F6          	lodsb
0132++ 1026 F7          	stosb
0133++ 1027 B9 00       	cmp al, 0
0134++ 1029 C7 25 10    	jne _strcpy_L1
0135++ 102C             _strcpy_end:
0136++ 102C E8          	pop al
0137++ 102D F0          	pop di
0138++ 102E EF          	pop si
0139++ 102F 09          	ret
0140++ 1030             
0141++ 1030             ; STRCAT
0142++ 1030             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1030             ; source in SI
0144++ 1030             ; destination in DI
0145++ 1030             _strcat:
0146++ 1030 E2          	push si
0147++ 1031 E3          	push di
0148++ 1032 D7          	push a
0149++ 1033 DA          	push d
0150++ 1034 50          	mov a, di
0151++ 1035 3C          	mov d, a
0152++ 1036             _strcat_goto_end_L1:
0153++ 1036 BD 00       	cmp byte[d], 0
0154++ 1038 C6 3F 10    	je _strcat_start
0155++ 103B 79          	inc d
0156++ 103C 0A 36 10    	jmp _strcat_goto_end_L1
0157++ 103F             _strcat_start:
0158++ 103F FD 50       	mov di, d
0159++ 1041             _strcat_L1:
0160++ 1041 F6          	lodsb
0161++ 1042 F7          	stosb
0162++ 1043 B9 00       	cmp al, 0
0163++ 1045 C7 41 10    	jne _strcat_L1
0164++ 1048             _strcat_end:
0165++ 1048 E7          	pop d
0166++ 1049 E4          	pop a
0167++ 104A F0          	pop di
0168++ 104B EF          	pop si
0169++ 104C 09          	ret
0170++ 104D             
0171++ 104D             
0005+  104D             
0006+  104D             
0007+  104D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  104D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  104D             ; ASCII in BL
0010+  104D             ; result in AL
0011+  104D             ; ascii for F = 0100 0110
0012+  104D             ; ascii for 9 = 0011 1001
0013+  104D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  104D             hex_ascii_encode:
0015+  104D 1B            mov al, bl
0016+  104E 93 40         test al, $40        ; test if letter or number
0017+  1050 C7 56 10      jnz hex_letter
0018+  1053 87 0F         and al, $0F        ; get number
0019+  1055 09            ret
0020+  1056             hex_letter:
0021+  1056 87 0F         and al, $0F        ; get letter
0022+  1058 6A 09         add al, 9
0023+  105A 09            ret
0024+  105B             
0025+  105B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  105B             ; ATOI
0027+  105B             ; 2 letter hex string in B
0028+  105B             ; 8bit integer returned in AL
0029+  105B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  105B             _atoi:
0031+  105B D8            push b
0032+  105C 07 4D 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  105F 30            mov bl, bh
0034+  1060 DB            push al          ; save a
0035+  1061 07 4D 10      call hex_ascii_encode
0036+  1064 EA            pop bl  
0037+  1065 FD 9E 04      shl al, 4
0038+  1068 8C            or al, bl
0039+  1069 E5            pop b
0040+  106A 09            ret  
0041+  106B             
0042+  106B             
0043+  106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  106B             ; scanf
0045+  106B             ; no need for explanations!
0046+  106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  106B             scanf:
0048+  106B 09            ret
0049+  106C             
0050+  106C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  106C             ; ITOA
0052+  106C             ; 8bit value in BL
0053+  106C             ; 2 byte ASCII result in A
0054+  106C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  106C             _itoa:
0056+  106C DA            push d
0057+  106D D8            push b
0058+  106E A7 00         mov bh, 0
0059+  1070 FD A4 04      shr bl, 4  
0060+  1073 74            mov d, b
0061+  1074 1F 06 13      mov al, [d + s_hex_digits]
0062+  1077 23            mov ah, al
0063+  1078               
0064+  1078 E5            pop b
0065+  1079 D8            push b
0066+  107A A7 00         mov bh, 0
0067+  107C FD 87 0F      and bl, $0F
0068+  107F 74            mov d, b
0069+  1080 1F 06 13      mov al, [d + s_hex_digits]
0070+  1083 E5            pop b
0071+  1084 E7            pop d
0072+  1085 09            ret
0073+  1086             
0074+  1086             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1086             ; HEX STRING TO BINARY
0076+  1086             ; di = destination address
0077+  1086             ; si = source
0078+  1086             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1086             _hex_to_int:
0080+  1086             _hex_to_int_L1:
0081+  1086 F6            lodsb          ; load from [SI] to AL
0082+  1087 B9 00         cmp al, 0        ; check if ASCII 0
0083+  1089 C6 96 10      jz _hex_to_int_ret
0084+  108C 36            mov bh, al
0085+  108D F6            lodsb
0086+  108E 2F            mov bl, al
0087+  108F 07 5B 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  1092 F7            stosb          ; store AL to [DI]
0089+  1093 0A 86 10      jmp _hex_to_int_L1
0090+  1096             _hex_to_int_ret:
0091+  1096 09            ret    
0092+  1097             
0093+  1097             
0094+  1097             
0095+  1097             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1097             ; GETCHAR
0097+  1097             ; char in ah
0098+  1097             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1097             getch:
0100+  1097 DB            push al
0101+  1098             getch_retry:
0102+  1098 19 01         mov al, 1
0103+  109A 05 03         syscall sys_io      ; receive in AH
0104+  109C E8            pop al
0105+  109D 09            ret
0106+  109E             
0107+  109E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  109E             ; PUTCHAR
0109+  109E             ; char in ah
0110+  109E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  109E             _putchar:
0112+  109E DB            push al
0113+  109F 19 00         mov al, 0
0114+  10A1 05 03         syscall sys_io      ; char in AH
0115+  10A3 E8            pop al
0116+  10A4 09            ret
0117+  10A5             
0118+  10A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  10A5             ;; INPUT A STRING
0120+  10A5             ;; terminates with null
0121+  10A5             ;; pointer in D
0122+  10A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  10A5             _gets:
0124+  10A5 D7            push a
0125+  10A6 DA            push d
0126+  10A7             _gets_loop:
0127+  10A7 19 01         mov al, 1
0128+  10A9 05 03         syscall sys_io      ; receive in AH
0129+  10AB 76 1B         cmp ah, 27
0130+  10AD C6 CE 10      je _gets_ansi_esc
0131+  10B0 76 0A         cmp ah, $0A        ; LF
0132+  10B2 C6 2A 11      je _gets_end
0133+  10B5 76 0D         cmp ah, $0D        ; CR
0134+  10B7 C6 2A 11      je _gets_end
0135+  10BA 76 5C         cmp ah, $5C        ; '\\'
0136+  10BC C6 F0 10      je _gets_escape
0137+  10BF 76 08         cmp ah, $08      ; check for backspace
0138+  10C1 C6 CA 10      je _gets_backspace
0139+  10C4 1A            mov al, ah
0140+  10C5 3E            mov [d], al
0141+  10C6 79            inc d
0142+  10C7 0A A7 10      jmp _gets_loop
0143+  10CA             _gets_backspace:
0144+  10CA 7F            dec d
0145+  10CB 0A A7 10      jmp _gets_loop
0146+  10CE             _gets_ansi_esc:
0147+  10CE 19 01         mov al, 1
0148+  10D0 05 03         syscall sys_io        ; receive in AH without echo
0149+  10D2 76 5B         cmp ah, '['
0150+  10D4 C7 A7 10      jne _gets_loop
0151+  10D7 19 01         mov al, 1
0152+  10D9 05 03         syscall sys_io          ; receive in AH without echo
0153+  10DB 76 44         cmp ah, 'D'
0154+  10DD C6 E8 10      je _gets_left_arrow
0155+  10E0 76 43         cmp ah, 'C'
0156+  10E2 C6 EC 10      je _gets_right_arrow
0157+  10E5 0A A7 10      jmp _gets_loop
0158+  10E8             _gets_left_arrow:
0159+  10E8 7F            dec d
0160+  10E9 0A A7 10      jmp _gets_loop
0161+  10EC             _gets_right_arrow:
0162+  10EC 79            inc d
0163+  10ED 0A A7 10      jmp _gets_loop
0164+  10F0             _gets_escape:
0165+  10F0 19 01         mov al, 1
0166+  10F2 05 03         syscall sys_io      ; receive in AH
0167+  10F4 76 6E         cmp ah, 'n'
0168+  10F6 C6 15 11      je _gets_LF
0169+  10F9 76 72         cmp ah, 'r'
0170+  10FB C6 1C 11      je _gets_CR
0171+  10FE 76 30         cmp ah, '0'
0172+  1100 C6 23 11      je _gets_NULL
0173+  1103 76 5C         cmp ah, $5C  ; '\'
0174+  1105 C6 0E 11      je _gets_slash
0175+  1108 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  1109 3E            mov [d], al
0177+  110A 79            inc d
0178+  110B 0A A7 10      jmp _gets_loop
0179+  110E             _gets_slash:
0180+  110E 19 5C         mov al, $5C
0181+  1110 3E            mov [d], al
0182+  1111 79            inc d
0183+  1112 0A A7 10      jmp _gets_loop
0184+  1115             _gets_LF:
0185+  1115 19 0A         mov al, $0A
0186+  1117 3E            mov [d], al
0187+  1118 79            inc d
0188+  1119 0A A7 10      jmp _gets_loop
0189+  111C             _gets_CR:
0190+  111C 19 0D         mov al, $0D
0191+  111E 3E            mov [d], al
0192+  111F 79            inc d
0193+  1120 0A A7 10      jmp _gets_loop
0194+  1123             _gets_NULL:
0195+  1123 19 00         mov al, $00
0196+  1125 3E            mov [d], al
0197+  1126 79            inc d
0198+  1127 0A A7 10      jmp _gets_loop
0199+  112A             _gets_end:
0200+  112A 19 00         mov al, 0
0201+  112C 3E            mov [d], al        ; terminate string
0202+  112D E7            pop d
0203+  112E E4            pop a
0204+  112F 09            ret
0205+  1130             
0206+  1130             
0207+  1130             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1130             ;; INPUT TEXT
0209+  1130             ;; terminated with CTRL+D
0210+  1130             ;; pointer in D
0211+  1130             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1130             _gettxt:
0213+  1130 D7            push a
0214+  1131 DA            push d
0215+  1132             _gettxt_loop:
0216+  1132 19 01         mov al, 1
0217+  1134 05 03         syscall sys_io      ; receive in AH
0218+  1136 76 04         cmp ah, 4      ; EOT
0219+  1138 C6 71 11      je _gettxt_end
0220+  113B 76 08         cmp ah, $08      ; check for backspace
0221+  113D C6 6D 11      je _gettxt_backspace
0222+  1140 76 5C         cmp ah, $5C        ; '\'
0223+  1142 C6 4B 11      je _gettxt_escape
0224+  1145 1A            mov al, ah
0225+  1146 3E            mov [d], al
0226+  1147 79            inc d
0227+  1148 0A 32 11      jmp _gettxt_loop
0228+  114B             _gettxt_escape:
0229+  114B 19 01         mov al, 1
0230+  114D 05 03         syscall sys_io      ; receive in AH
0231+  114F 76 6E         cmp ah, 'n'
0232+  1151 C6 5F 11      je _gettxt_LF
0233+  1154 76 72         cmp ah, 'r'
0234+  1156 C6 66 11      je _gettxt_CR
0235+  1159 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  115A 3E            mov [d], al
0237+  115B 79            inc d
0238+  115C 0A 32 11      jmp _gettxt_loop
0239+  115F             _gettxt_LF:
0240+  115F 19 0A         mov al, $0A
0241+  1161 3E            mov [d], al
0242+  1162 79            inc d
0243+  1163 0A 32 11      jmp _gettxt_loop
0244+  1166             _gettxt_CR:
0245+  1166 19 0D         mov al, $0D
0246+  1168 3E            mov [d], al
0247+  1169 79            inc d
0248+  116A 0A 32 11      jmp _gettxt_loop
0249+  116D             _gettxt_backspace:
0250+  116D 7F            dec d
0251+  116E 0A 32 11      jmp _gettxt_loop
0252+  1171             _gettxt_end:
0253+  1171 19 00         mov al, 0
0254+  1173 3E            mov [d], al        ; terminate string
0255+  1174 E7            pop d
0256+  1175 E4            pop a
0257+  1176 09            ret
0258+  1177             
0259+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  1177             ; PRINT NEW LINE
0261+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  1177             printnl:
0263+  1177 D7            push a
0264+  1178 10 00 0A      mov a, $0A00
0265+  117B 05 03         syscall sys_io
0266+  117D 10 00 0D      mov a, $0D00
0267+  1180 05 03         syscall sys_io
0268+  1182 E4            pop a
0269+  1183 09            ret
0270+  1184             
0271+  1184             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  1184             ; _strtoint
0273+  1184             ; 4 digit hex string number in d
0274+  1184             ; integer returned in A
0275+  1184             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1184             _strtointx:
0277+  1184 D8            push b
0278+  1185 32            mov bl, [d]
0279+  1186 37            mov bh, bl
0280+  1187 33 01 00      mov bl, [d + 1]
0281+  118A 07 5B 10      call _atoi        ; convert to int in AL
0282+  118D 23            mov ah, al        ; move to AH
0283+  118E 33 02 00      mov bl, [d + 2]
0284+  1191 37            mov bh, bl
0285+  1192 33 03 00      mov bl, [d + 3]
0286+  1195 07 5B 10      call _atoi        ; convert to int in AL
0287+  1198 E5            pop b
0288+  1199 09            ret
0289+  119A             
0290+  119A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  119A             ; _strtoint
0292+  119A             ; 5 digit base10 string number in d
0293+  119A             ; integer returned in A
0294+  119A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  119A             _strtoint:
0296+  119A E2            push si
0297+  119B D8            push b
0298+  119C D9            push c
0299+  119D DA            push d
0300+  119E 07 FD 0F      call _strlen      ; get string length in C
0301+  11A1 7E            dec c
0302+  11A2 FD 4E         mov si, d
0303+  11A4 12            mov a, c
0304+  11A5 FD 99         shl a
0305+  11A7 3B 1E 13      mov d, table_power
0306+  11AA 59            add d, a
0307+  11AB 38 00 00      mov c, 0
0308+  11AE             _strtoint_L0:
0309+  11AE F6            lodsb      ; load ASCII to al
0310+  11AF B9 00         cmp al, 0
0311+  11B1 C6 C4 11      je _strtoint_end
0312+  11B4 6F 30         sub al, $30    ; make into integer
0313+  11B6 22 00         mov ah, 0
0314+  11B8 2A            mov b, [d]
0315+  11B9 AC            mul a, b      ; result in B since it fits in 16bits
0316+  11BA 11            mov a, b
0317+  11BB 28            mov b, c
0318+  11BC 54            add a, b
0319+  11BD 39            mov c, a
0320+  11BE 63 02 00      sub d, 2
0321+  11C1 0A AE 11      jmp _strtoint_L0
0322+  11C4             _strtoint_end:
0323+  11C4 12            mov a, c
0324+  11C5 E7            pop d
0325+  11C6 E6            pop c
0326+  11C7 E5            pop b
0327+  11C8 EF            pop si
0328+  11C9 09            ret
0329+  11CA             
0330+  11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  11CA             ; PRINT NULL TERMINATED STRING
0332+  11CA             ; pointer in D
0333+  11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  11CA             _puts:
0335+  11CA D7            push a
0336+  11CB DA            push d
0337+  11CC             _puts_L1:
0338+  11CC 1E            mov al, [d]
0339+  11CD B9 00         cmp al, 0
0340+  11CF C6 DB 11      jz _puts_END
0341+  11D2 23            mov ah, al
0342+  11D3 19 00         mov al, 0
0343+  11D5 05 03         syscall sys_io
0344+  11D7 79            inc d
0345+  11D8 0A CC 11      jmp _puts_L1
0346+  11DB             _puts_END:
0347+  11DB E7            pop d
0348+  11DC E4            pop a
0349+  11DD 09            ret
0350+  11DE             
0351+  11DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  11DE             ; PRINT N SIZE STRING
0353+  11DE             ; pointer in D
0354+  11DE             ; size in C
0355+  11DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  11DE             _putsn:
0357+  11DE DB            push al
0358+  11DF DA            push d
0359+  11E0 D9            push c
0360+  11E1             _putsn_L0:
0361+  11E1 1E            mov al, [d]
0362+  11E2 23            mov ah, al
0363+  11E3 19 00         mov al, 0
0364+  11E5 05 03         syscall sys_io
0365+  11E7 79            inc d
0366+  11E8 7E            dec c  
0367+  11E9 C2 00 00      cmp c, 0
0368+  11EC C7 E1 11      jne _putsn_L0
0369+  11EF             _putsn_end:
0370+  11EF E6            pop c
0371+  11F0 E7            pop d
0372+  11F1 E8            pop al
0373+  11F2 09            ret
0374+  11F3             
0375+  11F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  11F3             ; print 16bit decimal number
0377+  11F3             ; input number in A
0378+  11F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  11F3             print_u16d:
0380+  11F3 D7            push a
0381+  11F4 D8            push b
0382+  11F5 FD D8         push g
0383+  11F7 26 10 27      mov b, 10000
0384+  11FA AE            div a, b      ; get 10000's coeff.
0385+  11FB 07 1F 12      call print_number
0386+  11FE 11            mov a, b
0387+  11FF 26 E8 03      mov b, 1000
0388+  1202 AE            div a, b      ; get 1000's coeff.
0389+  1203 07 1F 12      call print_number
0390+  1206 11            mov a, b
0391+  1207 26 64 00      mov b, 100
0392+  120A AE            div a, b
0393+  120B 07 1F 12      call print_number
0394+  120E 11            mov a, b
0395+  120F 26 0A 00      mov b, 10
0396+  1212 AE            div a, b
0397+  1213 07 1F 12      call print_number
0398+  1216 1B            mov al, bl      ; 1's coeff in bl
0399+  1217 07 1F 12      call print_number
0400+  121A FD F1         pop g
0401+  121C E5            pop b
0402+  121D E4            pop a
0403+  121E 09            ret
0404+  121F             
0405+  121F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  121F             ; print AL
0407+  121F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  121F             print_number:
0409+  121F 6A 30         add al, $30
0410+  1221 23            mov ah, al
0411+  1222 07 9E 10      call _putchar
0412+  1225 09            ret
0413+  1226             
0414+  1226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  1226             ; PRINT 16BIT HEX INTEGER
0416+  1226             ; integer value in reg B
0417+  1226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  1226             print_u16x:
0419+  1226 D7            push a
0420+  1227 D8            push b
0421+  1228 DD            push bl
0422+  1229 30            mov bl, bh
0423+  122A 07 6C 10      call _itoa        ; convert bh to char in A
0424+  122D 2F            mov bl, al        ; save al
0425+  122E 19 00         mov al, 0
0426+  1230 05 03         syscall sys_io        ; display AH
0427+  1232 24            mov ah, bl        ; retrieve al
0428+  1233 19 00         mov al, 0
0429+  1235 05 03         syscall sys_io        ; display AL
0430+  1237             
0431+  1237 EA            pop bl
0432+  1238 07 6C 10      call _itoa        ; convert bh to char in A
0433+  123B 2F            mov bl, al        ; save al
0434+  123C 19 00         mov al, 0
0435+  123E 05 03         syscall sys_io        ; display AH
0436+  1240 24            mov ah, bl        ; retrieve al
0437+  1241 19 00         mov al, 0
0438+  1243 05 03         syscall sys_io        ; display AL
0439+  1245             
0440+  1245 E5            pop b
0441+  1246 E4            pop a
0442+  1247 09            ret
0443+  1248             
0444+  1248             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  1248             ; INPUT 16BIT HEX INTEGER
0446+  1248             ; read 16bit integer into A
0447+  1248             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  1248             scan_u16x:
0449+  1248 F8 10 00      enter 16
0450+  124B D8            push b
0451+  124C DA            push d
0452+  124D             
0453+  124D FA F1 FF      lea d, [bp + -15]
0454+  1250 07 A5 10      call _gets        ; get number
0455+  1253             
0456+  1253 32            mov bl, [d]
0457+  1254 37            mov bh, bl
0458+  1255 33 01 00      mov bl, [d + 1]
0459+  1258 07 5B 10      call _atoi        ; convert to int in AL
0460+  125B 23            mov ah, al        ; move to AH
0461+  125C             
0462+  125C 33 02 00      mov bl, [d + 2]
0463+  125F 37            mov bh, bl
0464+  1260 33 03 00      mov bl, [d + 3]
0465+  1263 07 5B 10      call _atoi        ; convert to int in AL
0466+  1266             
0467+  1266 E7            pop d
0468+  1267 E5            pop b
0469+  1268 F9            leave
0470+  1269 09            ret
0471+  126A             
0472+  126A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  126A             ; PRINT 8bit HEX INTEGER
0474+  126A             ; integer value in reg bl
0475+  126A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  126A             print_u8x:
0477+  126A D7            push a
0478+  126B DD            push bl
0479+  126C             
0480+  126C 07 6C 10      call _itoa        ; convert bl to char in A
0481+  126F 2F            mov bl, al        ; save al
0482+  1270 19 00         mov al, 0
0483+  1272 05 03         syscall sys_io        ; display AH
0484+  1274 24            mov ah, bl        ; retrieve al
0485+  1275 19 00         mov al, 0
0486+  1277 05 03         syscall sys_io        ; display AL
0487+  1279             
0488+  1279 EA            pop bl
0489+  127A E4            pop a
0490+  127B 09            ret
0491+  127C             
0492+  127C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  127C             ; print 8bit decimal unsigned number
0494+  127C             ; input number in AL
0495+  127C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  127C             print_u8d:
0497+  127C D7            push a
0498+  127D D8            push b
0499+  127E FD D8         push g
0500+  1280 22 00         mov ah, 0
0501+  1282 26 64 00      mov b, 100
0502+  1285 AE            div a, b
0503+  1286 D8            push b      ; save remainder
0504+  1287 B9 00         cmp al, 0
0505+  1289 C6 93 12      je skip100
0506+  128C 6A 30         add al, $30
0507+  128E 23            mov ah, al
0508+  128F 19 00         mov al, 0
0509+  1291 05 03         syscall sys_io  ; print coeff
0510+  1293             skip100:
0511+  1293 E4            pop a
0512+  1294 22 00         mov ah, 0
0513+  1296 26 0A 00      mov b, 10
0514+  1299 AE            div a, b
0515+  129A D8            push b      ; save remainder
0516+  129B B9 00         cmp al, 0
0517+  129D C6 A7 12      je skip10
0518+  12A0 6A 30         add al, $30
0519+  12A2 23            mov ah, al
0520+  12A3 19 00         mov al, 0
0521+  12A5 05 03         syscall sys_io  ; print coeff
0522+  12A7             skip10:
0523+  12A7 E4            pop a
0524+  12A8 1B            mov al, bl
0525+  12A9 6A 30         add al, $30
0526+  12AB 23            mov ah, al
0527+  12AC 19 00         mov al, 0
0528+  12AE 05 03         syscall sys_io  ; print coeff
0529+  12B0 FD F1         pop g
0530+  12B2 E5            pop b
0531+  12B3 E4            pop a
0532+  12B4 09            ret
0533+  12B5             
0534+  12B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  12B5             ; INPUT 8BIT HEX INTEGER
0536+  12B5             ; read 8bit integer into AL
0537+  12B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  12B5             scan_u8x:
0539+  12B5 F8 04 00      enter 4
0540+  12B8 D8            push b
0541+  12B9 DA            push d
0542+  12BA             
0543+  12BA FA FD FF      lea d, [bp + -3]
0544+  12BD 07 A5 10      call _gets        ; get number
0545+  12C0             
0546+  12C0 32            mov bl, [d]
0547+  12C1 37            mov bh, bl
0548+  12C2 33 01 00      mov bl, [d + 1]
0549+  12C5 07 5B 10      call _atoi        ; convert to int in AL
0550+  12C8             
0551+  12C8 E7            pop d
0552+  12C9 E5            pop b
0553+  12CA F9            leave
0554+  12CB 09            ret
0555+  12CC             
0556+  12CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  12CC             ; input decimal number
0558+  12CC             ; result in A
0559+  12CC             ; 655'\0'
0560+  12CC             ; low--------high
0561+  12CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  12CC             scan_u16d:
0563+  12CC F8 08 00      enter 8
0564+  12CF E2            push si
0565+  12D0 D8            push b
0566+  12D1 D9            push c
0567+  12D2 DA            push d
0568+  12D3 FA F9 FF      lea d, [bp +- 7]
0569+  12D6 07 A5 10      call _gets
0570+  12D9 07 FD 0F      call _strlen      ; get string length in C
0571+  12DC 7E            dec c
0572+  12DD FD 4E         mov si, d
0573+  12DF 12            mov a, c
0574+  12E0 FD 99         shl a
0575+  12E2 3B 1E 13      mov d, table_power
0576+  12E5 59            add d, a
0577+  12E6 38 00 00      mov c, 0
0578+  12E9             mul_loop:
0579+  12E9 F6            lodsb      ; load ASCII to al
0580+  12EA B9 00         cmp al, 0
0581+  12EC C6 FF 12      je mul_exit
0582+  12EF 6F 30         sub al, $30    ; make into integer
0583+  12F1 22 00         mov ah, 0
0584+  12F3 2A            mov b, [d]
0585+  12F4 AC            mul a, b      ; result in B since it fits in 16bits
0586+  12F5 11            mov a, b
0587+  12F6 28            mov b, c
0588+  12F7 54            add a, b
0589+  12F8 39            mov c, a
0590+  12F9 63 02 00      sub d, 2
0591+  12FC 0A E9 12      jmp mul_loop
0592+  12FF             mul_exit:
0593+  12FF 12            mov a, c
0594+  1300 E7            pop d
0595+  1301 E6            pop c
0596+  1302 E5            pop b
0597+  1303 EF            pop si
0598+  1304 F9            leave
0599+  1305 09            ret
0600+  1306             
0601+  1306             
0602+  1306 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  130A 34 35 36 37 
0602+  130E 38 39 41 42 
0602+  1312 43 44 45 46 
0603+  1316 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  131A 1B 5B 48 00 
0604+  131E             
0605+  131E             table_power:
0606+  131E 01 00         .dw 1
0607+  1320 0A 00         .dw 10
0608+  1322 64 00         .dw 100
0609+  1324 E8 03         .dw 1000
0610+  1326 10 27         .dw 100002545   1328             .include "lib/ctype.asm"
0001+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1328             ; ctype.s
0003+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1328             
0005+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  1328             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  1328             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  1328             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  1328             ;; characters are supported.
0010+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  1328             ;; _isalnum 
0012+  1328             ;; _isalpha 
0013+  1328             ;; islower 
0014+  1328             ;; isupper 
0015+  1328             ;; _isdigit 
0016+  1328             ;; isxdigit
0017+  1328             ;; iscntrl 
0018+  1328             ;; isgraph 
0019+  1328             ;; _isspace 
0020+  1328             ;; isblank 
0021+  1328             ;; isprint 
0022+  1328             ;; ispunct 
0023+  1328             ;; tolower 
0024+  1328             ;; toupper
0025+  1328             
0026+  1328             
0027+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  1328             ;; IS ALPHANUMERIC
0029+  1328             ;; sets ZF according with result
0030+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  1328             _isalnum:
0032+  1328 07 45 13    	call _isalpha
0033+  132B C6 31 13    	je _isalnum_exit
0034+  132E 07 32 13    	call _isdigit
0035+  1331             _isalnum_exit:
0036+  1331 09          	ret	
0037+  1332             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1332             ;; IS DIGIT
0039+  1332             ;; sets ZF according with result
0040+  1332             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1332             _isdigit:
0042+  1332 DB          	push al
0043+  1333 B9 30       	cmp al, '0'
0044+  1335 C8 41 13    	jlu _isdigit_false
0045+  1338 B9 39       	cmp al, '9'
0046+  133A D1 41 13    	jgu _isdigit_false
0047+  133D 87 00       	and al, 0	; set ZF
0048+  133F E8          	pop al
0049+  1340 09          	ret
0050+  1341             _isdigit_false:
0051+  1341 8B 01       	or al, 1	; clear ZF
0052+  1343 E8          	pop al
0053+  1344 09          	ret	
0054+  1345             	
0055+  1345             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1345             ;; IS ALPHA
0057+  1345             ;; sets ZF according with result
0058+  1345             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1345             _isalpha:
0060+  1345 DB          	push al
0061+  1346 B9 5F       	cmp al, '_'
0062+  1348 C6 68 13    	je _isalpha_true
0063+  134B B9 2E       	cmp al, '.'
0064+  134D C6 68 13    	je _isalpha_true
0065+  1350 B9 41       	cmp al, 'A'
0066+  1352 C8 64 13    	jlu _isalpha_false
0067+  1355 B9 7A       	cmp al, 'z'
0068+  1357 D1 64 13    	jgu _isalpha_false
0069+  135A B9 5A       	cmp al, 'Z'
0070+  135C D0 68 13    	jleu _isalpha_true
0071+  135F B9 61       	cmp al, 'a'
0072+  1361 C9 68 13    	jgeu _isalpha_true
0073+  1364             _isalpha_false:
0074+  1364 8B 01       	or al, 1	; clear ZF
0075+  1366 E8          	pop al
0076+  1367 09          	ret
0077+  1368             _isalpha_true:
0078+  1368 87 00       	and al, 0	; set ZF
0079+  136A E8          	pop al
0080+  136B 09          	ret
0081+  136C             
0082+  136C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  136C             ;; IS PATH-ALPHA
0084+  136C             ;; sets ZF according with result
0085+  136C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  136C             ispath:
0087+  136C DB          	push al
0088+  136D 07 32 13    	call _isdigit
0089+  1370 C6 9A 13    	je ispath_true
0090+  1373 B9 5F       	cmp al, '_'
0091+  1375 C6 9A 13    	je ispath_true
0092+  1378 B9 2F       	cmp al, '/'
0093+  137A C6 9A 13    	je ispath_true
0094+  137D B9 2E       	cmp al, '.'
0095+  137F C6 9A 13    	je ispath_true
0096+  1382 B9 41       	cmp al, 'A'
0097+  1384 C8 96 13    	jlu ispath_false
0098+  1387 B9 7A       	cmp al, 'z'
0099+  1389 D1 96 13    	jgu ispath_false
0100+  138C B9 5A       	cmp al, 'Z'
0101+  138E D0 9A 13    	jleu ispath_true
0102+  1391 B9 61       	cmp al, 'a'
0103+  1393 C9 9A 13    	jgeu ispath_true
0104+  1396             ispath_false:
0105+  1396 8B 01       	or al, 1	; clear ZF
0106+  1398 E8          	pop al
0107+  1399 09          	ret
0108+  139A             ispath_true:
0109+  139A 87 00       	and al, 0	; set ZF
0110+  139C E8          	pop al
0111+  139D 09          	ret
0112+  139E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  139E             ;; IS SPACE
0114+  139E             ;; sets ZF according with result
0115+  139E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  139E             _isspace:
0117+  139E B9 20       	cmp al, $20		; ' '
0118+  13A0 C6 B4 13    	je _isspace_exit
0119+  13A3 B9 09       	cmp al, $09		; '\t'
0120+  13A5 C6 B4 13    	je _isspace_exit
0121+  13A8 B9 0A       	cmp al, $0A		; '\n'
0122+  13AA C6 B4 13    	je _isspace_exit
0123+  13AD B9 0D       	cmp al, $0D		; '\r'
0124+  13AF C6 B4 13    	je _isspace_exit
0125+  13B2 B9 0B       	cmp al, $0B		; '\v'
0126+  13B4             _isspace_exit:
0127+  13B4 09          	ret	
0128+  13B5             
0129+  13B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  13B5             ; TO LOWER
0131+  13B5             ; input in AL
0132+  13B5             ; output in AL
0133+  13B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  13B5             _to_lower:
0135+  13B5 B9 5A       	cmp al, 'Z'
0136+  13B7 D1 BC 13    	jgu _to_lower_ret
0137+  13BA 6A 20       	add al, $20				; convert to lower case
0138+  13BC             _to_lower_ret:
0139+  13BC 09          	ret
0140+  13BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  13BD             ; TO UPPER
0142+  13BD             ; input in AL
0143+  13BD             ; output in AL
0144+  13BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  13BD             _to_upper:
0146+  13BD B9 61       	cmp al, 'a'
0147+  13BF C8 C4 13    	jlu _to_upper_ret
0148+  13C2 6F 20       	sub al, $20			; convert to upper case
0149+  13C4             _to_upper_ret:
0150+  13C4 09          	ret
0151+  13C5             
2546   13C5             .include "lib/token.asm"
0001+  13C5             TOKTYP_IDENTIFIER  .equ 0
0002+  13C5             TOKTYP_KEYWORD     .equ 1
0003+  13C5             TOKTYP_DELIMITER   .equ 2
0004+  13C5             TOKTYP_STRING      .equ 3
0005+  13C5             TOKTYP_CHAR        .equ 4
0006+  13C5             TOKTYP_NUMERIC     .equ 5
0007+  13C5             TOKTYP_END         .equ 6
0008+  13C5             
0009+  13C5             TOK_NULL           .equ 0
0010+  13C5             TOK_FSLASH         .equ 1
0011+  13C5             TOK_TIMES          .equ 2
0012+  13C5             TOK_PLUS           .equ 3
0013+  13C5             TOK_MINUS          .equ 4
0014+  13C5             TOK_DOT            .equ 5
0015+  13C5             TOK_SEMI           .equ 6
0016+  13C5             TOK_ANGLE          .equ 7
0017+  13C5             TOK_TILDE          .equ 8
0018+  13C5             TOK_EQUAL          .equ 9
0019+  13C5             TOK_COLON          .equ 10
0020+  13C5             TOK_COMMA          .equ 11
0021+  13C5             
0022+  13C5             TOK_END            .equ 20
0023+  13C5             
0024+  13C5             
0025+  13C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  13C5             ;; read a full command argment from shell input buffer
0027+  13C5             ;; argument is written into tokstr
0028+  13C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  13C5             get_arg:
0030+  13C5 D7            push a
0031+  13C6 E2            push si
0032+  13C7 E3            push di
0033+  13C8 19 00         mov al, 0
0034+  13CA 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0035+  13CD 14 EF 15      mov a, [prog]
0036+  13D0 4D            mov si, a
0037+  13D1 FD 4F F3 15   mov di, tokstr
0038+  13D5             get_arg_skip_spaces:
0039+  13D5 F6            lodsb
0040+  13D6 07 9E 13      call _isspace
0041+  13D9 C6 D5 13      je get_arg_skip_spaces
0042+  13DC             get_arg_L0:
0043+  13DC B9 3B         cmp al, $3B        ; check if is ';'
0044+  13DE C6 EB 13      je get_arg_end
0045+  13E1 B9 00         cmp al, 0
0046+  13E3 C6 EB 13      je get_arg_end      ; check if end of input
0047+  13E6 F7            stosb
0048+  13E7 F6            lodsb
0049+  13E8 0A DC 13      jmp get_arg_L0
0050+  13EB             get_arg_end:
0051+  13EB 19 00         mov al, 0
0052+  13ED F7            stosb
0053+  13EE D5 01 00      sub si, 1
0054+  13F1 4E            mov a, si
0055+  13F2 42 EF 15      mov [prog], a    ; update pointer
0056+  13F5 F0            pop di
0057+  13F6 EF            pop si
0058+  13F7 E4            pop a
0059+  13F8 09            ret
0060+  13F9             
0061+  13F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  13F9             ;; read a path formation from shell input buffer
0063+  13F9             ;; path is written into tokstr
0064+  13F9             ;; /usr/bin
0065+  13F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  13F9             get_path:
0067+  13F9 D7            push a
0068+  13FA E2            push si
0069+  13FB E3            push di
0070+  13FC 19 00         mov al, 0
0071+  13FE 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0072+  1401 14 EF 15      mov a, [prog]
0073+  1404 4D            mov si, a
0074+  1405 FD 4F F3 15   mov di, tokstr
0075+  1409             get_path_skip_spaces:
0076+  1409 F6            lodsb
0077+  140A 07 9E 13      call _isspace
0078+  140D C6 09 14      je get_path_skip_spaces
0079+  1410             get_path_is_pathchar:
0080+  1410 F7            stosb
0081+  1411 F6            lodsb
0082+  1412 07 28 13      call _isalnum      ;check if is alphanumeric
0083+  1415 C6 10 14      je get_path_is_pathchar
0084+  1418 B9 2F         cmp al, '/'        ; check if is '/'
0085+  141A C6 10 14      je get_path_is_pathchar
0086+  141D 19 00         mov al, 0
0087+  141F F7            stosb
0088+  1420 D5 01 00      sub si, 1
0089+  1423 4E            mov a, si
0090+  1424 42 EF 15      mov [prog], a    ; update pointer
0091+  1427             get_path_end:
0092+  1427 F0            pop di
0093+  1428 EF            pop si
0094+  1429 E4            pop a
0095+  142A 09            ret
0096+  142B             
0097+  142B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  142B             ;; read a line
0099+  142B             ;; line is written into tokstr
0100+  142B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  142B             get_line:
0102+  142B D7            push a
0103+  142C E2            push si
0104+  142D E3            push di
0105+  142E 19 00         mov al, 0
0106+  1430 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0107+  1433 14 EF 15      mov a, [prog]
0108+  1436 4D            mov si, a
0109+  1437 FD 4F F3 15   mov di, tokstr
0110+  143B             get_line_L0:
0111+  143B F6            lodsb
0112+  143C B9 0A         cmp al, $0A    ; check for new line
0113+  143E C6 45 14      je get_line_exit
0114+  1441 F7            stosb
0115+  1442 0A 3B 14      jmp get_line_L0
0116+  1445             get_line_exit:
0117+  1445 19 00         mov al, 0
0118+  1447 F7            stosb
0119+  1448 4E            mov a, si
0120+  1449 42 EF 15      mov [prog], a    ; update pointer
0121+  144C F0            pop di
0122+  144D EF            pop si
0123+  144E E4            pop a
0124+  144F 09            ret
0125+  1450             
0126+  1450             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1450             ;; token parser
0128+  1450             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1450             get_token:
0130+  1450 D7            push a
0131+  1451 DA            push d
0132+  1452 E2            push si
0133+  1453 E3            push di
0134+  1454 19 00         mov al, 0
0135+  1456 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0136+  1459 19 00         mov al, TOK_NULL
0137+  145B 3D F2 15      mov [tok], al        ; nullify token
0138+  145E 14 EF 15      mov a, [prog]
0139+  1461 4D            mov si, a
0140+  1462 FD 4F F3 15   mov di, tokstr
0141+  1466             get_tok_skip_spaces:
0142+  1466 F6            lodsb
0143+  1467 07 9E 13      call _isspace
0144+  146A C6 66 14      je get_tok_skip_spaces
0145+  146D B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  146F C6 54 15      je get_token_end
0147+  1472 B9 23         cmp al, '#'      ; comments!
0148+  1474 C6 82 15      je get_tok_comment
0149+  1477 07 28 13      call _isalnum
0150+  147A C6 61 15      jz is_alphanumeric
0151+  147D             ; other token types
0152+  147D             get_token_slash:
0153+  147D B9 2F         cmp al, '/'        ; check if '/'
0154+  147F C7 97 14      jne get_token_minus
0155+  1482 F7            stosb          ; store '/' into token string
0156+  1483 19 00         mov al, 0
0157+  1485 F7            stosb          ; terminate token string
0158+  1486 19 01         mov al, TOK_FSLASH
0159+  1488 3D F2 15      mov [tok], al      
0160+  148B 19 02         mov al, TOKTYP_DELIMITER
0161+  148D 3D F1 15      mov [toktyp], al
0162+  1490 4E            mov a, si
0163+  1491 42 EF 15      mov [prog], a    ; update pointer
0164+  1494 0A 7D 15      jmp get_token_return
0165+  1497             get_token_minus:
0166+  1497 B9 2D         cmp al, '-'        ; check if '-'
0167+  1499 C7 B1 14      jne get_token_comma
0168+  149C F7            stosb          ; store '-' into token string
0169+  149D 19 00         mov al, 0
0170+  149F F7            stosb          ; terminate token string
0171+  14A0 19 04         mov al, TOK_MINUS
0172+  14A2 3D F2 15      mov [tok], al      
0173+  14A5 19 02         mov al, TOKTYP_DELIMITER
0174+  14A7 3D F1 15      mov [toktyp], al
0175+  14AA 4E            mov a, si
0176+  14AB 42 EF 15      mov [prog], a    ; update pointer
0177+  14AE 0A 7D 15      jmp get_token_return
0178+  14B1             get_token_comma:
0179+  14B1 B9 2C         cmp al, ','        ; check if ','
0180+  14B3 C7 CB 14      jne get_token_semi
0181+  14B6 F7            stosb          ; store ',' into token string
0182+  14B7 19 00         mov al, 0
0183+  14B9 F7            stosb          ; terminate token string
0184+  14BA 19 0B         mov al, TOK_COMMA
0185+  14BC 3D F2 15      mov [tok], al      
0186+  14BF 19 02         mov al, TOKTYP_DELIMITER
0187+  14C1 3D F1 15      mov [toktyp], al
0188+  14C4 4E            mov a, si
0189+  14C5 42 EF 15      mov [prog], a    ; update pointer
0190+  14C8 0A 7D 15      jmp get_token_return
0191+  14CB             get_token_semi:
0192+  14CB B9 3B         cmp al, $3B        ; check if ';'
0193+  14CD C7 E5 14      jne get_token_colon
0194+  14D0 F7            stosb          ; store ';' into token string
0195+  14D1 19 00         mov al, 0
0196+  14D3 F7            stosb          ; terminate token string
0197+  14D4 19 06         mov al, TOK_SEMI
0198+  14D6 3D F2 15      mov [tok], al      
0199+  14D9 19 02         mov al, TOKTYP_DELIMITER
0200+  14DB 3D F1 15      mov [toktyp], al
0201+  14DE 4E            mov a, si
0202+  14DF 42 EF 15      mov [prog], a    ; update pointer
0203+  14E2 0A 7D 15      jmp get_token_return
0204+  14E5             get_token_colon:
0205+  14E5 B9 3A         cmp al, $3A        ; check if ':'
0206+  14E7 C7 FF 14      jne get_token_angle
0207+  14EA F7            stosb          ; store ':' into token string
0208+  14EB 19 00         mov al, 0
0209+  14ED F7            stosb          ; terminate token string
0210+  14EE 19 0A         mov al, TOK_COLON
0211+  14F0 3D F2 15      mov [tok], al      
0212+  14F3 19 02         mov al, TOKTYP_DELIMITER
0213+  14F5 3D F1 15      mov [toktyp], al
0214+  14F8 4E            mov a, si
0215+  14F9 42 EF 15      mov [prog], a    ; update pointer
0216+  14FC 0A 7D 15      jmp get_token_return
0217+  14FF             get_token_angle:
0218+  14FF B9 3E         cmp al, $3E        ; check if '>'
0219+  1501 C7 19 15      jne get_token_tilde
0220+  1504 F7            stosb          ; store '>' into token string
0221+  1505 19 00         mov al, 0
0222+  1507 F7            stosb          ; terminate token string
0223+  1508 19 07         mov al, TOK_ANGLE
0224+  150A 3D F2 15      mov [tok], al      
0225+  150D 19 02         mov al, TOKTYP_DELIMITER
0226+  150F 3D F1 15      mov [toktyp], al
0227+  1512 4E            mov a, si
0228+  1513 42 EF 15      mov [prog], a    ; update pointer
0229+  1516 0A 7D 15      jmp get_token_return
0230+  1519             get_token_tilde:
0231+  1519 B9 7E         cmp al, '~'        ; check if '~'
0232+  151B C7 33 15      jne get_token_equal
0233+  151E F7            stosb          ; store '~' into token string
0234+  151F 19 00         mov al, 0
0235+  1521 F7            stosb          ; terminate token string
0236+  1522 19 08         mov al, TOK_TILDE
0237+  1524 3D F2 15      mov [tok], al      
0238+  1527 19 02         mov al, TOKTYP_DELIMITER
0239+  1529 3D F1 15      mov [toktyp], al
0240+  152C 4E            mov a, si
0241+  152D 42 EF 15      mov [prog], a    ; update pointer
0242+  1530 0A 7D 15      jmp get_token_return
0243+  1533             get_token_equal:
0244+  1533 B9 3D         cmp al, '='        ; check if '='
0245+  1535 C7 4D 15      jne get_token_skip
0246+  1538 F7            stosb          ; store '=' into token string
0247+  1539 19 00         mov al, 0
0248+  153B F7            stosb          ; terminate token string
0249+  153C 19 09         mov al, TOK_EQUAL
0250+  153E 3D F2 15      mov [tok], al      
0251+  1541 19 02         mov al, TOKTYP_DELIMITER
0252+  1543 3D F1 15      mov [toktyp], al
0253+  1546 4E            mov a, si
0254+  1547 42 EF 15      mov [prog], a    ; update pointer
0255+  154A 0A 7D 15      jmp get_token_return
0256+  154D             get_token_skip:
0257+  154D 4E            mov a, si
0258+  154E 42 EF 15      mov [prog], a    ; update pointer
0259+  1551 0A 7D 15      jmp get_token_return
0260+  1554             get_token_end:        ; end of file token
0261+  1554 19 14         mov al, TOK_END
0262+  1556 3D F2 15      mov [tok], al
0263+  1559 19 06         mov al, TOKTYP_END
0264+  155B 3D F1 15      mov [toktyp], al
0265+  155E 0A 7D 15      jmp get_token_return
0266+  1561             is_alphanumeric:
0267+  1561 F7            stosb
0268+  1562 F6            lodsb
0269+  1563 07 28 13      call _isalnum      ;check if is alphanumeric
0270+  1566 C6 61 15      jz is_alphanumeric
0271+  1569 B9 2E         cmp al, $2E        ; check if is '.'
0272+  156B C6 61 15      je is_alphanumeric
0273+  156E 19 00         mov al, 0
0274+  1570 F7            stosb
0275+  1571 19 00         mov al, TOKTYP_IDENTIFIER
0276+  1573 3D F1 15      mov [toktyp], al
0277+  1576 D5 01 00      sub si, 1
0278+  1579 4E            mov a, si
0279+  157A 42 EF 15      mov [prog], a    ; update pointer
0280+  157D             get_token_return:
0281+  157D F0            pop di
0282+  157E EF            pop si
0283+  157F E7            pop d
0284+  1580 E4            pop a
0285+  1581 09            ret
0286+  1582             get_tok_comment:
0287+  1582 F6            lodsb
0288+  1583 B9 0A         cmp al, $0A      ; new line
0289+  1585 C7 82 15      jne get_tok_comment
0290+  1588 0A 66 14      jmp get_tok_skip_spaces
0291+  158B             
0292+  158B             
0293+  158B             get_number:
0294+  158B D7            push a
0295+  158C DA            push d
0296+  158D E2            push si
0297+  158E E3            push di
0298+  158F 19 00         mov al, 0
0299+  1591 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0300+  1594 19 00         mov al, TOK_NULL
0301+  1596 3D F2 15      mov [tok], al        ; nullify token
0302+  1599 14 EF 15      mov a, [prog]
0303+  159C 4D            mov si, a
0304+  159D FD 4F F3 15   mov di, tokstr
0305+  15A1             get_number_skip_spaces:
0306+  15A1 F6            lodsb
0307+  15A2 07 9E 13      call _isspace
0308+  15A5 C6 A1 15      je get_number_skip_spaces
0309+  15A8 B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  15AA C7 BA 15      jne get_number_L0
0311+  15AD 19 14         mov al, TOK_END
0312+  15AF 3D F2 15      mov [tok], al
0313+  15B2 19 06         mov al, TOKTYP_END
0314+  15B4 3D F1 15      mov [toktyp], al
0315+  15B7 0A D1 15      jmp get_number_return
0316+  15BA             get_number_L0:
0317+  15BA F7            stosb
0318+  15BB F6            lodsb
0319+  15BC 07 32 13      call _isdigit      ;check if is numeric
0320+  15BF C6 BA 15      jz get_number_L0
0321+  15C2 19 00         mov al, 0
0322+  15C4 F7            stosb
0323+  15C5 19 05         mov al, TOKTYP_NUMERIC
0324+  15C7 3D F1 15      mov [toktyp], al
0325+  15CA D5 01 00      sub si, 1
0326+  15CD 4E            mov a, si
0327+  15CE 42 EF 15      mov [prog], a    ; update pointer
0328+  15D1             get_number_return:
0329+  15D1 F0            pop di
0330+  15D2 EF            pop si
0331+  15D3 E7            pop d
0332+  15D4 E4            pop a
0333+  15D5 09            ret
0334+  15D6             
0335+  15D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  15D6             ;; PUT BACK TOKEN
0337+  15D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  15D6             _putback:
0339+  15D6 D7            push a
0340+  15D7 E2            push si
0341+  15D8 FD 4D F3 15   mov si, tokstr  
0342+  15DC             _putback_loop:
0343+  15DC F6            lodsb
0344+  15DD B9 00         cmp al, 0
0345+  15DF C6 EC 15      je _putback_end
0346+  15E2 14 EF 15      mov a, [prog]
0347+  15E5 7D            dec a
0348+  15E6 42 EF 15      mov [prog], a      ; update pointer
0349+  15E9 0A DC 15      jmp _putback_loop
0350+  15EC             _putback_end:
0351+  15EC EF            pop si
0352+  15ED E4            pop a
0353+  15EE 09            ret
0354+  15EF             
0355+  15EF             
0356+  15EF             
0357+  15EF             
0358+  15EF 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  15F1             
0360+  15F1 00          toktyp:    .db 0          ; token type symbol
0361+  15F2 00          tok:       .db 0          ; current token symbol
0362+  15F3 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  15F7 00 00 00 00 
0362+  15FB 00 00 00 00 
0362+  15FF 00 00 00 00 
0362+  1603 00 00 00 00 
0362+  1607 00 00 00 00 
0362+  160B 00 00 00 00 
0362+  160F 00 00 00 00 
0362+  1613 00 00 00 00 
0362+  1617 00 00 00 00 
0362+  161B 00 00 00 00 
0362+  161F 00 00 00 00 
0362+  1623 00 00 00 00 
0362+  1627 00 00 00 00 
0362+  162B 00 00 00 00 
0362+  162F 00 00 00 00 
0362+  1633 00 00 00 00 
0362+  1637 00 00 00 00 
0362+  163B 00 00 00 00 
0362+  163F 00 00 00 00 
0362+  1643 00 00 00 00 
0362+  1647 00 00 00 00 
0362+  164B 00 00 00 00 
0362+  164F 00 00 00 00 
0362+  1653 00 00 00 00 
0362+  1657 00 00 00 00 
0362+  165B 00 00 00 00 
0362+  165F 00 00 00 00 
0362+  1663 00 00 00 00 
0362+  1667 00 00 00 00 
0362+  166B 00 00 00 00 
0362+  166F 00 00 00 00 
0362+  1673 00 00 00 00 
0362+  1677 00 00 00 00 
0362+  167B 00 00 00 00 
0362+  167F 00 00 00 00 
0362+  1683 00 00 00 00 
0362+  1687 00 00 00 00 
0362+  168B 00 00 00 00 
0362+  168F 00 00 00 00 
0362+  1693 00 00 00 00 
0362+  1697 00 00 00 00 
0362+  169B 00 00 00 00 
0362+  169F 00 00 00 00 
0362+  16A3 00 00 00 00 
0362+  16A7 00 00 00 00 
0362+  16AB 00 00 00 00 
0362+  16AF 00 00 00 00 
0362+  16B3 00 00 00 00 
0362+  16B7 00 00 00 00 
0362+  16BB 00 00 00 00 
0362+  16BF 00 00 00 00 
0362+  16C3 00 00 00 00 
0362+  16C7 00 00 00 00 
0362+  16CB 00 00 00 00 
0362+  16CF 00 00 00 00 
0362+  16D3 00 00 00 00 
0362+  16D7 00 00 00 00 
0362+  16DB 00 00 00 00 
0362+  16DF 00 00 00 00 
0362+  16E3 00 00 00 00 
0362+  16E7 00 00 00 00 
0362+  16EB 00 00 00 00 
0362+  16EF 00 00 00 00 
2547   16F3             
2548   16F3             ; kernel parameters
2549   16F3 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2550   16F4 01          sys_echo_on:        .db 1
2551   16F5 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2552   16F6 01          sys_uart0_inten:    .db 1
2553   16F7 00          sys_uart0_fifoen:   .db 0
2554   16F8 0C          sys_uart0_div0:     .db 12  ;
2555   16F9 00          sys_uart0_div1:     .db 0   ; default baud = 9600
2556   16FA             ; Baud  Divisor
2557   16FA             ; 50    2304
2558   16FA             ; 110   1047
2559   16FA             ; 300    384
2560   16FA             ; 600    192
2561   16FA             ; 1200    96
2562   16FA             ; 9600    12
2563   16FA             ; 19200    6
2564   16FA             ; 38400    3
2565   16FA             
2566   16FA 00          nbr_active_procs:   .db 0
2567   16FB 01          active_proc_index:  .db 1
2568   16FC             
2569   16FC 00 00       index:              .dw 0
2570   16FE 00 00       buffer_addr:        .dw 0
2571   1700             
2572   1700 FF 1D       fifo_in:            .dw fifo
2573   1702 FF 1D       fifo_out:           .dw fifo
2574   1704             
2575   1704             ; file system variables
2576   1704 00 00       current_dir_id:     .dw 0     ; keep dirID of current directory
2577   1706 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2577   170A 6E 2F 69 6E 
2577   170E 69 74 00 
2578   1711             
2579   1711 3E 20 00    s_dataentry:        .db "> ", 0
2580   1714 2E 2E 00    s_parent_dir:       .db "..", 0
2581   1717 2E 00       s_current_dir:      .db ".", 0
2582   1719 2F 00       s_fslash:           .db "/", 0
2583   171B 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2583   171F 78 
2584   1720 2D 64 63    file_type:          .db "-dc"
2585   1723 50 49 44 20 s_ps_header:        .db "PID COMMAND\n", 0
2585   1727 43 4F 4D 4D 
2585   172B 41 4E 44 0A 
2585   172F 00 
2586   1730 54 6F 74 61 s_ls_total:         .db "Total: ", 0
2586   1734 6C 3A 20 00 
2587   1738             
2588   1738 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2588   173C 20 65 6E 61 
2588   1740 62 6C 65 64 
2588   1744 0A 00 
2589   1746 6B 65 72 6E s_kernel_started:   .db "kernel started(version 1.0)\n", 0
2589   174A 65 6C 20 73 
2589   174E 74 61 72 74 
2589   1752 65 64 28 76 
2589   1756 65 72 73 69 
2589   175A 6F 6E 20 31 
2589   175E 2E 30 29 0A 
2589   1762 00 
2590   1763 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2590   1767 74 69 6E 67 
2590   176B 20 69 6E 69 
2590   176F 74 0A 00 
2591   1772 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2591   1776 65 70 74 69 
2591   177A 6F 6E 3A 20 
2591   177E 70 72 69 76 
2591   1782 69 6C 65 67 
2591   1786 65 0A 00 
2592   1789 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2592   178D 65 70 74 69 
2592   1791 6F 6E 3A 20 
2592   1795 7A 65 72 6F 
2592   1799 20 64 69 76 
2592   179D 69 73 69 6F 
2592   17A1 6E 0A 00 
2593   17A4             
2594   17A4 59 65 61 72 s_set_year:         .db "Year: ", 0
2594   17A8 3A 20 00 
2595   17AB 4D 6F 6E 74 s_set_month:        .db "Month: ", 0
2595   17AF 68 3A 20 00 
2596   17B3 44 61 79 3A s_set_day:          .db "Day: ", 0
2596   17B7 20 00 
2597   17B9 57 65 65 6B s_set_week:         .db "Weekday: ", 0
2597   17BD 64 61 79 3A 
2597   17C1 20 00 
2598   17C3 48 6F 75 72 s_set_hours:        .db "Hours: ", 0
2598   17C7 73 3A 20 00 
2599   17CB 4D 69 6E 75 s_set_minutes:      .db "Minutes: ", 0
2599   17CF 74 65 73 3A 
2599   17D3 20 00 
2600   17D5 53 65 63 6F s_set_seconds:      .db "Seconds: ", 0
2600   17D9 6E 64 73 3A 
2600   17DD 20 00 
2601   17DF             s_months:      
2602   17DF 20 20 20 00   .db "   ", 0
2603   17E3 4A 61 6E 00   .db "Jan", 0
2604   17E7 46 65 62 00   .db "Feb", 0
2605   17EB 4D 61 72 00   .db "Mar", 0
2606   17EF 41 70 72 00   .db "Apr", 0
2607   17F3 4D 61 79 00   .db "May", 0
2608   17F7 4A 75 6E 00   .db "Jun", 0
2609   17FB 4A 75 6C 00   .db "Jul", 0
2610   17FF 41 75 67 00   .db "Aug", 0
2611   1803 53 65 70 00   .db "Sep", 0
2612   1807 4F 63 74 00   .db "Oct", 0
2613   180B 4E 6F 76 00   .db "Nov", 0
2614   180F 44 65 63 00   .db "Dec", 0
2615   1813             
2616   1813             s_week:        
2617   1813 53 75 6E 00   .db "Sun", 0 
2618   1817 4D 6F 6E 00   .db "Mon", 0 
2619   181B 54 75 65 00   .db "Tue", 0 
2620   181F 57 65 64 00   .db "Wed", 0 
2621   1823 54 68 75 00   .db "Thu", 0 
2622   1827 46 72 69 00   .db "Fri", 0 
2623   182B 53 61 74 00   .db "Sat", 0
2624   182F             
2625   182F 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2625   1833 00 00 00 00 
2625   1837 00 00 00 00 
2625   183B 00 00 00 00 
2625   183F 00 00 00 00 
2625   1843 00 00 00 00 
2625   1847 00 00 00 00 
2625   184B 00 00 00 00 
2625   184F 00 00 00 00 
2625   1853 00 00 00 00 
2625   1857 00 00 00 00 
2625   185B 00 00 00 00 
2625   185F 00 00 00 00 
2625   1863 00 00 00 00 
2625   1867 00 00 00 00 
2625   186B 00 00 00 00 
2625   186F 00 00 00 00 
2625   1873 00 00 00 00 
2625   1877 00 00 00 00 
2625   187B 00 00 00 00 
2625   187F 00 00 00 00 
2625   1883 00 00 00 00 
2625   1887 00 00 00 00 
2625   188B 00 00 00 00 
2625   188F 00 00 00 00 
2625   1893 00 00 00 00 
2625   1897 00 00 00 00 
2625   189B 00 00 00 00 
2625   189F 00 00 00 00 
2625   18A3 00 00 00 00 
2625   18A7 00 00 00 00 
2625   18AB 00 00 00 00 
2625   18AF 00 00 00 00 
2625   18B3 00 00 00 00 
2625   18B7 00 00 00 00 
2625   18BB 00 00 00 00 
2625   18BF 00 00 00 00 
2625   18C3 00 00 00 00 
2625   18C7 00 00 00 00 
2625   18CB 00 00 00 00 
2625   18CF 00 00 00 00 
2625   18D3 00 00 00 00 
2625   18D7 00 00 00 00 
2625   18DB 00 00 00 00 
2625   18DF 00 00 00 00 
2625   18E3 00 00 00 00 
2625   18E7 00 00 00 00 
2625   18EB 00 00 00 00 
2625   18EF 00 00 00 00 
2625   18F3 00 00 00 00 
2625   18F7 00 00 00 00 
2625   18FB 00 00 00 00 
2625   18FF 00 00 00 00 
2625   1903 00 00 00 00 
2625   1907 00 00 00 00 
2625   190B 00 00 00 00 
2625   190F 00 00 00 00 
2625   1913 00 00 00 00 
2625   1917 00 00 00 00 
2625   191B 00 00 00 00 
2625   191F 00 00 00 00 
2625   1923 00 00 00 00 
2625   1927 00 00 00 00 
2625   192B 00 00 00 00 
2625   192F 00 00 00 00 
2625   1933 00 00 00 00 
2625   1937 00 00 00 00 
2625   193B 00 00 00 00 
2625   193F 00 00 00 00 
2625   1943 00 00 00 00 
2625   1947 00 00 00 00 
2625   194B 00 00 00 00 
2625   194F 00 00 00 00 
2625   1953 00 00 00 00 
2625   1957 00 00 00 00 
2625   195B 00 00 00 00 
2625   195F 00 00 00 00 
2625   1963 00 00 00 00 
2625   1967 00 00 00 00 
2625   196B 00 00 00 00 
2626   196F 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2626   1973 00 00 00 00 
2626   1977 00 00 00 00 
2626   197B 00 00 00 00 
2627   197F 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2627   1983 00 00 00 00 
2627   1987 00 00 00 00 
2627   198B 00 00 00 00 
2627   198F 00 00 00 00 
2627   1993 00 00 00 00 
2627   1997 00 00 00 00 
2627   199B 00 00 00 00 
2627   199F 00 00 00 00 
2627   19A3 00 00 00 00 
2627   19A7 00 00 00 00 
2627   19AB 00 00 00 00 
2627   19AF 00 00 00 00 
2627   19B3 00 00 00 00 
2627   19B7 00 00 00 00 
2627   19BB 00 00 00 00 
2627   19BF 00 00 00 00 
2627   19C3 00 00 00 00 
2627   19C7 00 00 00 00 
2627   19CB 00 00 00 00 
2627   19CF 00 00 00 00 
2627   19D3 00 00 00 00 
2627   19D7 00 00 00 00 
2627   19DB 00 00 00 00 
2627   19DF 00 00 00 00 
2627   19E3 00 00 00 00 
2627   19E7 00 00 00 00 
2627   19EB 00 00 00 00 
2627   19EF 00 00 00 00 
2627   19F3 00 00 00 00 
2627   19F7 00 00 00 00 
2627   19FB 00 00 00 00 
2627   19FF 00 00 00 00 
2627   1A03 00 00 00 00 
2627   1A07 00 00 00 00 
2627   1A0B 00 00 00 00 
2627   1A0F 00 00 00 00 
2627   1A13 00 00 00 00 
2627   1A17 00 00 00 00 
2627   1A1B 00 00 00 00 
2627   1A1F 00 00 00 00 
2627   1A23 00 00 00 00 
2627   1A27 00 00 00 00 
2627   1A2B 00 00 00 00 
2627   1A2F 00 00 00 00 
2627   1A33 00 00 00 00 
2627   1A37 00 00 00 00 
2627   1A3B 00 00 00 00 
2627   1A3F 00 00 00 00 
2627   1A43 00 00 00 00 
2627   1A47 00 00 00 00 
2627   1A4B 00 00 00 00 
2627   1A4F 00 00 00 00 
2627   1A53 00 00 00 00 
2627   1A57 00 00 00 00 
2627   1A5B 00 00 00 00 
2627   1A5F 00 00 00 00 
2627   1A63 00 00 00 00 
2627   1A67 00 00 00 00 
2627   1A6B 00 00 00 00 
2627   1A6F 00 00 00 00 
2627   1A73 00 00 00 00 
2627   1A77 00 00 00 00 
2627   1A7B 00 00 00 00 
2627   1A7F 00 00 00 00 
2627   1A83 00 00 00 00 
2627   1A87 00 00 00 00 
2627   1A8B 00 00 00 00 
2627   1A8F 00 00 00 00 
2627   1A93 00 00 00 00 
2627   1A97 00 00 00 00 
2627   1A9B 00 00 00 00 
2627   1A9F 00 00 00 00 
2627   1AA3 00 00 00 00 
2627   1AA7 00 00 00 00 
2627   1AAB 00 00 00 00 
2627   1AAF 00 00 00 00 
2627   1AB3 00 00 00 00 
2627   1AB7 00 00 00 00 
2627   1ABB 00 00 00 00 
2627   1ABF 00 00 00 00 
2627   1AC3 00 00 00 00 
2627   1AC7 00 00 00 00 
2627   1ACB 00 00 00 00 
2627   1ACF 00 00 00 00 
2627   1AD3 00 00 00 00 
2627   1AD7 00 00 00 00 
2627   1ADB 00 00 00 00 
2627   1ADF 00 00 00 00 
2627   1AE3 00 00 00 00 
2627   1AE7 00 00 00 00 
2627   1AEB 00 00 00 00 
2627   1AEF 00 00 00 00 
2627   1AF3 00 00 00 00 
2627   1AF7 00 00 00 00 
2627   1AFB 00 00 00 00 
2627   1AFF 00 00 00 00 
2627   1B03 00 00 00 00 
2627   1B07 00 00 00 00 
2627   1B0B 00 00 00 00 
2627   1B0F 00 00 00 00 
2627   1B13 00 00 00 00 
2627   1B17 00 00 00 00 
2627   1B1B 00 00 00 00 
2627   1B1F 00 00 00 00 
2627   1B23 00 00 00 00 
2627   1B27 00 00 00 00 
2627   1B2B 00 00 00 00 
2627   1B2F 00 00 00 00 
2627   1B33 00 00 00 00 
2627   1B37 00 00 00 00 
2627   1B3B 00 00 00 00 
2627   1B3F 00 00 00 00 
2627   1B43 00 00 00 00 
2627   1B47 00 00 00 00 
2627   1B4B 00 00 00 00 
2627   1B4F 00 00 00 00 
2627   1B53 00 00 00 00 
2627   1B57 00 00 00 00 
2627   1B5B 00 00 00 00 
2627   1B5F 00 00 00 00 
2627   1B63 00 00 00 00 
2627   1B67 00 00 00 00 
2627   1B6B 00 00 00 00 
2627   1B6F 00 00 00 00 
2627   1B73 00 00 00 00 
2627   1B77 00 00 00 00 
2627   1B7B 00 00 00 00 
2628   1B7F 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2628   1B83 00 00 00 00 
2628   1B87 00 00 00 00 
2628   1B8B 00 00 00 00 
2628   1B8F 00 00 00 00 
2628   1B93 00 00 00 00 
2628   1B97 00 00 00 00 
2628   1B9B 00 00 00 00 
2628   1B9F 00 00 00 00 
2628   1BA3 00 00 00 00 
2628   1BA7 00 00 00 00 
2628   1BAB 00 00 00 00 
2628   1BAF 00 00 00 00 
2628   1BB3 00 00 00 00 
2628   1BB7 00 00 00 00 
2628   1BBB 00 00 00 00 
2628   1BBF 00 00 00 00 
2628   1BC3 00 00 00 00 
2628   1BC7 00 00 00 00 
2628   1BCB 00 00 00 00 
2628   1BCF 00 00 00 00 
2628   1BD3 00 00 00 00 
2628   1BD7 00 00 00 00 
2628   1BDB 00 00 00 00 
2628   1BDF 00 00 00 00 
2628   1BE3 00 00 00 00 
2628   1BE7 00 00 00 00 
2628   1BEB 00 00 00 00 
2628   1BEF 00 00 00 00 
2628   1BF3 00 00 00 00 
2628   1BF7 00 00 00 00 
2628   1BFB 00 00 00 00 
2629   1BFF 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2629   1C03 00 00 00 00 
2629   1C07 00 00 00 00 
2629   1C0B 00 00 00 00 
2629   1C0F 00 00 00 00 
2629   1C13 00 00 00 00 
2629   1C17 00 00 00 00 
2629   1C1B 00 00 00 00 
2629   1C1F 00 00 00 00 
2629   1C23 00 00 00 00 
2629   1C27 00 00 00 00 
2629   1C2B 00 00 00 00 
2629   1C2F 00 00 00 00 
2629   1C33 00 00 00 00 
2629   1C37 00 00 00 00 
2629   1C3B 00 00 00 00 
2629   1C3F 00 00 00 00 
2629   1C43 00 00 00 00 
2629   1C47 00 00 00 00 
2629   1C4B 00 00 00 00 
2629   1C4F 00 00 00 00 
2629   1C53 00 00 00 00 
2629   1C57 00 00 00 00 
2629   1C5B 00 00 00 00 
2629   1C5F 00 00 00 00 
2629   1C63 00 00 00 00 
2629   1C67 00 00 00 00 
2629   1C6B 00 00 00 00 
2629   1C6F 00 00 00 00 
2629   1C73 00 00 00 00 
2629   1C77 00 00 00 00 
2629   1C7B 00 00 00 00 
2629   1C7F 00 00 00 00 
2629   1C83 00 00 00 00 
2629   1C87 00 00 00 00 
2629   1C8B 00 00 00 00 
2629   1C8F 00 00 00 00 
2629   1C93 00 00 00 00 
2629   1C97 00 00 00 00 
2629   1C9B 00 00 00 00 
2629   1C9F 00 00 00 00 
2629   1CA3 00 00 00 00 
2629   1CA7 00 00 00 00 
2629   1CAB 00 00 00 00 
2629   1CAF 00 00 00 00 
2629   1CB3 00 00 00 00 
2629   1CB7 00 00 00 00 
2629   1CBB 00 00 00 00 
2629   1CBF 00 00 00 00 
2629   1CC3 00 00 00 00 
2629   1CC7 00 00 00 00 
2629   1CCB 00 00 00 00 
2629   1CCF 00 00 00 00 
2629   1CD3 00 00 00 00 
2629   1CD7 00 00 00 00 
2629   1CDB 00 00 00 00 
2629   1CDF 00 00 00 00 
2629   1CE3 00 00 00 00 
2629   1CE7 00 00 00 00 
2629   1CEB 00 00 00 00 
2629   1CEF 00 00 00 00 
2629   1CF3 00 00 00 00 
2629   1CF7 00 00 00 00 
2629   1CFB 00 00 00 00 
2629   1CFF 00 00 00 00 
2629   1D03 00 00 00 00 
2629   1D07 00 00 00 00 
2629   1D0B 00 00 00 00 
2629   1D0F 00 00 00 00 
2629   1D13 00 00 00 00 
2629   1D17 00 00 00 00 
2629   1D1B 00 00 00 00 
2629   1D1F 00 00 00 00 
2629   1D23 00 00 00 00 
2629   1D27 00 00 00 00 
2629   1D2B 00 00 00 00 
2629   1D2F 00 00 00 00 
2629   1D33 00 00 00 00 
2629   1D37 00 00 00 00 
2629   1D3B 00 00 00 00 
2629   1D3F 00 00 00 00 
2629   1D43 00 00 00 00 
2629   1D47 00 00 00 00 
2629   1D4B 00 00 00 00 
2629   1D4F 00 00 00 00 
2629   1D53 00 00 00 00 
2629   1D57 00 00 00 00 
2629   1D5B 00 00 00 00 
2629   1D5F 00 00 00 00 
2629   1D63 00 00 00 00 
2629   1D67 00 00 00 00 
2629   1D6B 00 00 00 00 
2629   1D6F 00 00 00 00 
2629   1D73 00 00 00 00 
2629   1D77 00 00 00 00 
2629   1D7B 00 00 00 00 
2629   1D7F 00 00 00 00 
2629   1D83 00 00 00 00 
2629   1D87 00 00 00 00 
2629   1D8B 00 00 00 00 
2629   1D8F 00 00 00 00 
2629   1D93 00 00 00 00 
2629   1D97 00 00 00 00 
2629   1D9B 00 00 00 00 
2629   1D9F 00 00 00 00 
2629   1DA3 00 00 00 00 
2629   1DA7 00 00 00 00 
2629   1DAB 00 00 00 00 
2629   1DAF 00 00 00 00 
2629   1DB3 00 00 00 00 
2629   1DB7 00 00 00 00 
2629   1DBB 00 00 00 00 
2629   1DBF 00 00 00 00 
2629   1DC3 00 00 00 00 
2629   1DC7 00 00 00 00 
2629   1DCB 00 00 00 00 
2629   1DCF 00 00 00 00 
2629   1DD3 00 00 00 00 
2629   1DD7 00 00 00 00 
2629   1DDB 00 00 00 00 
2629   1DDF 00 00 00 00 
2629   1DE3 00 00 00 00 
2629   1DE7 00 00 00 00 
2629   1DEB 00 00 00 00 
2629   1DEF 00 00 00 00 
2629   1DF3 00 00 00 00 
2629   1DF7 00 00 00 00 
2629   1DFB 00 00 00 00 
2630   1DFF FF FF FF FF fifo:               .fill FIFO_SIZE
2630   1E03 FF FF FF FF 
2630   1E07 FF FF FF FF 
2630   1E0B FF FF FF FF 
2630   1E0F FF FF FF FF 
2630   1E13 FF FF FF FF 
2630   1E17 FF FF FF FF 
2630   1E1B FF FF FF FF 
2630   1E1F FF FF FF FF 
2630   1E23 FF FF FF FF 
2630   1E27 FF FF FF FF 
2630   1E2B FF FF FF FF 
2630   1E2F FF FF FF FF 
2630   1E33 FF FF FF FF 
2630   1E37 FF FF FF FF 
2630   1E3B FF FF FF FF 
2630   1E3F FF FF FF FF 
2630   1E43 FF FF FF FF 
2630   1E47 FF FF FF FF 
2630   1E4B FF FF FF FF 
2630   1E4F FF FF FF FF 
2630   1E53 FF FF FF FF 
2630   1E57 FF FF FF FF 
2630   1E5B FF FF FF FF 
2630   1E5F FF FF FF FF 
2630   1E63 FF FF FF FF 
2630   1E67 FF FF FF FF 
2630   1E6B FF FF FF FF 
2630   1E6F FF FF FF FF 
2630   1E73 FF FF FF FF 
2630   1E77 FF FF FF FF 
2630   1E7B FF FF FF FF 
2630   1E7F FF FF FF FF 
2630   1E83 FF FF FF FF 
2630   1E87 FF FF FF FF 
2630   1E8B FF FF FF FF 
2630   1E8F FF FF FF FF 
2630   1E93 FF FF FF FF 
2630   1E97 FF FF FF FF 
2630   1E9B FF FF FF FF 
2630   1E9F FF FF FF FF 
2630   1EA3 FF FF FF FF 
2630   1EA7 FF FF FF FF 
2630   1EAB FF FF FF FF 
2630   1EAF FF FF FF FF 
2630   1EB3 FF FF FF FF 
2630   1EB7 FF FF FF FF 
2630   1EBB FF FF FF FF 
2630   1EBF FF FF FF FF 
2630   1EC3 FF FF FF FF 
2630   1EC7 FF FF FF FF 
2630   1ECB FF FF FF FF 
2630   1ECF FF FF FF FF 
2630   1ED3 FF FF FF FF 
2630   1ED7 FF FF FF FF 
2630   1EDB FF FF FF FF 
2630   1EDF FF FF FF FF 
2630   1EE3 FF FF FF FF 
2630   1EE7 FF FF FF FF 
2630   1EEB FF FF FF FF 
2630   1EEF FF FF FF FF 
2630   1EF3 FF FF FF FF 
2630   1EF7 FF FF FF FF 
2630   1EFB FF FF FF FF 
2630   1EFF FF FF FF FF 
2630   1F03 FF FF FF FF 
2630   1F07 FF FF FF FF 
2630   1F0B FF FF FF FF 
2630   1F0F FF FF FF FF 
2630   1F13 FF FF FF FF 
2630   1F17 FF FF FF FF 
2630   1F1B FF FF FF FF 
2630   1F1F FF FF FF FF 
2630   1F23 FF FF FF FF 
2630   1F27 FF FF FF FF 
2630   1F2B FF FF FF FF 
2630   1F2F FF FF FF FF 
2630   1F33 FF FF FF FF 
2630   1F37 FF FF FF FF 
2630   1F3B FF FF FF FF 
2630   1F3F FF FF FF FF 
2630   1F43 FF FF FF FF 
2630   1F47 FF FF FF FF 
2630   1F4B FF FF FF FF 
2630   1F4F FF FF FF FF 
2630   1F53 FF FF FF FF 
2630   1F57 FF FF FF FF 
2630   1F5B FF FF FF FF 
2630   1F5F FF FF FF FF 
2630   1F63 FF FF FF FF 
2630   1F67 FF FF FF FF 
2630   1F6B FF FF FF FF 
2630   1F6F FF FF FF FF 
2630   1F73 FF FF FF FF 
2630   1F77 FF FF FF FF 
2630   1F7B FF FF FF FF 
2630   1F7F FF FF FF FF 
2630   1F83 FF FF FF FF 
2630   1F87 FF FF FF FF 
2630   1F8B FF FF FF FF 
2630   1F8F FF FF FF FF 
2630   1F93 FF FF FF FF 
2630   1F97 FF FF FF FF 
2630   1F9B FF FF FF FF 
2630   1F9F FF FF FF FF 
2630   1FA3 FF FF FF FF 
2630   1FA7 FF FF FF FF 
2630   1FAB FF FF FF FF 
2630   1FAF FF FF FF FF 
2630   1FB3 FF FF FF FF 
2630   1FB7 FF FF FF FF 
2630   1FBB FF FF FF FF 
2630   1FBF FF FF FF FF 
2630   1FC3 FF FF FF FF 
2630   1FC7 FF FF FF FF 
2630   1FCB FF FF FF FF 
2630   1FCF FF FF FF FF 
2630   1FD3 FF FF FF FF 
2630   1FD7 FF FF FF FF 
2630   1FDB FF FF FF FF 
2630   1FDF FF FF FF FF 
2630   1FE3 FF FF FF FF 
2630   1FE7 FF FF FF FF 
2630   1FEB FF FF FF FF 
2630   1FEF FF FF FF FF 
2630   1FF3 FF FF FF FF 
2630   1FF7 FF FF FF FF 
2630   1FFB FF FF FF FF 
2630   1FFF FF FF FF FF 
2630   2003 FF FF FF FF 
2630   2007 FF FF FF FF 
2630   200B FF FF FF FF 
2630   200F FF FF FF FF 
2630   2013 FF FF FF FF 
2630   2017 FF FF FF FF 
2630   201B FF FF FF FF 
2630   201F FF FF FF FF 
2630   2023 FF FF FF FF 
2630   2027 FF FF FF FF 
2630   202B FF FF FF FF 
2630   202F FF FF FF FF 
2630   2033 FF FF FF FF 
2630   2037 FF FF FF FF 
2630   203B FF FF FF FF 
2630   203F FF FF FF FF 
2630   2043 FF FF FF FF 
2630   2047 FF FF FF FF 
2630   204B FF FF FF FF 
2630   204F FF FF FF FF 
2630   2053 FF FF FF FF 
2630   2057 FF FF FF FF 
2630   205B FF FF FF FF 
2630   205F FF FF FF FF 
2630   2063 FF FF FF FF 
2630   2067 FF FF FF FF 
2630   206B FF FF FF FF 
2630   206F FF FF FF FF 
2630   2073 FF FF FF FF 
2630   2077 FF FF FF FF 
2630   207B FF FF FF FF 
2630   207F FF FF FF FF 
2630   2083 FF FF FF FF 
2630   2087 FF FF FF FF 
2630   208B FF FF FF FF 
2630   208F FF FF FF FF 
2630   2093 FF FF FF FF 
2630   2097 FF FF FF FF 
2630   209B FF FF FF FF 
2630   209F FF FF FF FF 
2630   20A3 FF FF FF FF 
2630   20A7 FF FF FF FF 
2630   20AB FF FF FF FF 
2630   20AF FF FF FF FF 
2630   20B3 FF FF FF FF 
2630   20B7 FF FF FF FF 
2630   20BB FF FF FF FF 
2630   20BF FF FF FF FF 
2630   20C3 FF FF FF FF 
2630   20C7 FF FF FF FF 
2630   20CB FF FF FF FF 
2630   20CF FF FF FF FF 
2630   20D3 FF FF FF FF 
2630   20D7 FF FF FF FF 
2630   20DB FF FF FF FF 
2630   20DF FF FF FF FF 
2630   20E3 FF FF FF FF 
2630   20E7 FF FF FF FF 
2630   20EB FF FF FF FF 
2630   20EF FF FF FF FF 
2630   20F3 FF FF FF FF 
2630   20F7 FF FF FF FF 
2630   20FB FF FF FF FF 
2630   20FF FF FF FF FF 
2630   2103 FF FF FF FF 
2630   2107 FF FF FF FF 
2630   210B FF FF FF FF 
2630   210F FF FF FF FF 
2630   2113 FF FF FF FF 
2630   2117 FF FF FF FF 
2630   211B FF FF FF FF 
2630   211F FF FF FF FF 
2630   2123 FF FF FF FF 
2630   2127 FF FF FF FF 
2630   212B FF FF FF FF 
2630   212F FF FF FF FF 
2630   2133 FF FF FF FF 
2630   2137 FF FF FF FF 
2630   213B FF FF FF FF 
2630   213F FF FF FF FF 
2630   2143 FF FF FF FF 
2630   2147 FF FF FF FF 
2630   214B FF FF FF FF 
2630   214F FF FF FF FF 
2630   2153 FF FF FF FF 
2630   2157 FF FF FF FF 
2630   215B FF FF FF FF 
2630   215F FF FF FF FF 
2630   2163 FF FF FF FF 
2630   2167 FF FF FF FF 
2630   216B FF FF FF FF 
2630   216F FF FF FF FF 
2630   2173 FF FF FF FF 
2630   2177 FF FF FF FF 
2630   217B FF FF FF FF 
2630   217F FF FF FF FF 
2630   2183 FF FF FF FF 
2630   2187 FF FF FF FF 
2630   218B FF FF FF FF 
2630   218F FF FF FF FF 
2630   2193 FF FF FF FF 
2630   2197 FF FF FF FF 
2630   219B FF FF FF FF 
2630   219F FF FF FF FF 
2630   21A3 FF FF FF FF 
2630   21A7 FF FF FF FF 
2630   21AB FF FF FF FF 
2630   21AF FF FF FF FF 
2630   21B3 FF FF FF FF 
2630   21B7 FF FF FF FF 
2630   21BB FF FF FF FF 
2630   21BF FF FF FF FF 
2630   21C3 FF FF FF FF 
2630   21C7 FF FF FF FF 
2630   21CB FF FF FF FF 
2630   21CF FF FF FF FF 
2630   21D3 FF FF FF FF 
2630   21D7 FF FF FF FF 
2630   21DB FF FF FF FF 
2630   21DF FF FF FF FF 
2630   21E3 FF FF FF FF 
2630   21E7 FF FF FF FF 
2630   21EB FF FF FF FF 
2630   21EF FF FF FF FF 
2630   21F3 FF FF FF FF 
2630   21F7 FF FF FF FF 
2630   21FB FF FF FF FF 
2631   21FF             
2632   21FF FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2632   2203 FF FF FF FF 
2632   2207 FF FF FF FF 
2632   220B FF FF FF FF 
2632   220F FF FF FF FF 
2632   2213 FF FF FF FF 
2632   2217 FF FF FF FF 
2632   221B FF FF FF FF 
2632   221F FF FF FF FF 
2632   2223 FF FF FF FF 
2632   2227 FF FF FF FF 
2632   222B FF FF FF FF 
2632   222F FF FF FF FF 
2632   2233 FF FF FF FF 
2632   2237 FF FF FF FF 
2632   223B FF FF FF FF 
2632   223F FF FF FF FF 
2632   2243 FF FF FF FF 
2632   2247 FF FF FF FF 
2632   224B FF FF FF FF 
2632   224F FF FF FF FF 
2632   2253 FF FF FF FF 
2632   2257 FF FF FF FF 
2632   225B FF FF FF FF 
2632   225F FF FF FF FF 
2632   2263 FF FF FF FF 
2632   2267 FF FF FF FF 
2632   226B FF FF FF FF 
2632   226F FF FF FF FF 
2632   2273 FF FF FF FF 
2632   2277 FF FF FF FF 
2632   227B FF FF FF FF 
2632   227F FF FF FF FF 
2632   2283 FF FF FF FF 
2632   2287 FF FF FF FF 
2632   228B FF FF FF FF 
2632   228F FF FF FF FF 
2632   2293 FF FF FF FF 
2632   2297 FF FF FF FF 
2632   229B FF FF FF FF 
2632   229F FF FF FF FF 
2632   22A3 FF FF FF FF 
2632   22A7 FF FF FF FF 
2632   22AB FF FF FF FF 
2632   22AF FF FF FF FF 
2632   22B3 FF FF FF FF 
2632   22B7 FF FF FF FF 
2632   22BB FF FF FF FF 
2632   22BF FF FF FF FF 
2632   22C3 FF FF FF FF 
2632   22C7 FF FF FF FF 
2632   22CB FF FF FF FF 
2632   22CF FF FF FF FF 
2632   22D3 FF FF FF FF 
2632   22D7 FF FF FF FF 
2632   22DB FF FF FF FF 
2632   22DF FF FF FF FF 
2632   22E3 FF FF FF FF 
2632   22E7 FF FF FF FF 
2632   22EB FF FF FF FF 
2632   22EF FF FF FF FF 
2632   22F3 FF FF FF FF 
2632   22F7 FF FF FF FF 
2632   22FB FF FF FF FF 
2632   22FF FF FF FF FF 
2632   2303 FF FF FF FF 
2632   2307 FF FF FF FF 
2632   230B FF FF FF FF 
2632   230F FF FF FF FF 
2632   2313 FF FF FF FF 
2632   2317 FF FF FF FF 
2632   231B FF FF FF FF 
2632   231F FF FF FF FF 
2632   2323 FF FF FF FF 
2632   2327 FF FF FF FF 
2632   232B FF FF FF FF 
2632   232F FF FF FF FF 
2632   2333 FF FF FF FF 
2632   2337 FF FF FF FF 
2632   233B FF FF FF FF 
2632   233F FF FF FF FF 
2632   2343 FF FF FF FF 
2632   2347 FF FF FF FF 
2632   234B FF FF FF FF 
2632   234F FF FF FF FF 
2632   2353 FF FF FF FF 
2632   2357 FF FF FF FF 
2632   235B FF FF FF FF 
2632   235F FF FF FF FF 
2632   2363 FF FF FF FF 
2632   2367 FF FF FF FF 
2632   236B FF FF FF FF 
2632   236F FF FF FF FF 
2632   2373 FF FF FF FF 
2632   2377 FF FF FF FF 
2632   237B FF FF FF FF 
2632   237F FF FF FF FF 
2632   2383 FF FF FF FF 
2632   2387 FF FF FF FF 
2632   238B FF FF FF FF 
2632   238F FF FF FF FF 
2632   2393 FF FF FF FF 
2632   2397 FF FF FF FF 
2632   239B FF FF FF FF 
2632   239F FF FF FF FF 
2632   23A3 FF FF FF FF 
2632   23A7 FF FF FF FF 
2632   23AB FF FF FF FF 
2632   23AF FF FF FF FF 
2632   23B3 FF FF FF FF 
2632   23B7 FF FF FF FF 
2632   23BB FF FF FF FF 
2632   23BF FF FF FF FF 
2632   23C3 FF FF FF FF 
2632   23C7 FF FF FF FF 
2632   23CB FF FF FF FF 
2632   23CF FF FF FF FF 
2632   23D3 FF FF FF FF 
2632   23D7 FF FF FF FF 
2632   23DB FF FF FF FF 
2632   23DF FF FF FF FF 
2632   23E3 FF FF FF FF 
2632   23E7 FF FF FF FF 
2632   23EB FF FF FF FF 
2632   23EF FF FF FF FF 
2632   23F3 FF FF FF FF 
2632   23F7 FF FF FF FF 
2632   23FB FF FF FF FF 
2633   23FF 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2634   2400             
2635   2400             
2636   2400             .end
tasm: Number of errors = 0
