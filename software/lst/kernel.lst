0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             ; Memory Map
0005   0000             ; ------------------------------------------------------------------------------------------------------------------;
0006   0000             ; 0000    ROM BEGIN
0007   0000             ; ....
0008   0000             ; 7FFF    ROM END
0009   0000             ;
0010   0000             ; 8000    RAM begin
0011   0000             ; ....
0012   0000             ; F7FF    Stack root
0013   0000             ; ------------------------------------------------------------------------------------------------------------------;
0014   0000             ; I/O MAP
0015   0000             ; ------------------------------------------------------------------------------------------------------------------;
0016   0000             ; FF80    UART 0    (16550)
0017   0000             ; FF90    UART 1    (16550)
0018   0000             ; FFA0    RTC       (M48T02)
0019   0000             ; FFB0    PIO 0     (8255)
0020   0000             ; FFC0    PIO 1     (8255)
0021   0000             ; FFD0    IDE       (Compact Flash / PATA)
0022   0000             ; FFE0    Timer     (8253)
0023   0000             ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0024   0000             ; ------------------------------------------------------------------------------------------------------------------;
0025   0000             
0026   0000             ; ------------------------------------------------------------------------------------------------------------------;
0027   0000             ; System Constants
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             _UART0_DATA       .equ $FF80            ; data
0030   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0031   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0032   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0033   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0034   0000             _UART0_LCR        .equ $FF83            ; line control register
0035   0000             _UART0_LSR        .equ $FF85            ; line status register
0036   0000             
0037   0000             _UART1_DATA       .equ $FF90            ; data
0038   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0039   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0040   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0041   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0042   0000             _UART1_LCR        .equ $FF93            ; line control register
0043   0000             _UART1_LSR        .equ $FF95            ; line status register
0044   0000             
0045   0000             XON               .equ $11
0046   0000             XOFF              .equ $13
0047   0000             
0048   0000             _ide_BASE         .equ $FFD0            ; IDE BASE
0049   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0050   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0051   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0052   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0053   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0054   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0055   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0056   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0057   0000             
0058   0000             _7SEG_DISPLAY     .equ $FFB0            ; BIOS POST CODE HEX DISPLAY (2 DIGITS)
0059   0000             _BIOS_POST_CTRL   .equ $FFB3            ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0060   0000             _PIO_A            .equ $FFB0    
0061   0000             _PIO_B            .equ $FFB1
0062   0000             _PIO_C            .equ $FFB2
0063   0000             _PIO_CONTROL      .equ $FFB3            ; PIO CONTROL PORT
0064   0000             
0065   0000             _TIMER_C_0        .equ $FFE0            ; TIMER COUNTER 0
0066   0000             _TIMER_C_1        .equ $FFE1            ; TIMER COUNTER 1
0067   0000             _TIMER_C_2        .equ $FFE2            ; TIMER COUNTER 2
0068   0000             _TIMER_CTRL       .equ $FFE3            ; TIMER CONTROL REGISTER
0069   0000             
0070   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0071   0000             FIFO_SIZE         .equ 1024
0072   0000             
0073   0000             text_org          .equ $400
0074   0000             ; ------------------------------------------------------------------------------------------------------------------;
0075   0000             
0076   0000             
0077   0000             ; For the next iteration:
0078   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0079   0000             ; inode-table format:
0080   0000             ;  file-type(f, d)
0081   0000             ;  permissons
0082   0000             ;  link-count
0083   0000             ;  filesize
0084   0000             ;  time-stamps
0085   0000             ;  15 data block pointers
0086   0000             ;  single-indirect pointer
0087   0000             
0088   0000             ; FILE ENTRY ATTRIBUTES
0089   0000             ; filename (24)
0090   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0091   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0092   0000             ; size (2)             : filesize
0093   0000             ; day (1)           
0094   0000             ; month (1)
0095   0000             ; year (1)
0096   0000             ; packet size = 32 bytes  : total packet size in bytes
0097   0000             
0098   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0099   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0100   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0101   0000             FST_NBR_DIRECTORIES     .equ 64
0102   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0103   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0104   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0105   0000             FST_LBA_START           .equ 32
0106   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0107   0000             
0108   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0109   0000             FS_SECTORS_PER_FILE     .equ 32         ; the first sector is always a header with a NULL parameter (first byte)
0110   0000                                                     ; so that we know which blocks are free or taken
0111   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0112   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0113   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0114   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0115   0000             
0116   0000             root_id:                .equ FST_LBA_START
0117   0000             
0118   0000             ; ------------------------------------------------------------------------------------------------------------------;
0119   0000             ; GLOBAL SYSTEM VARIABLES
0120   0000             ; ------------------------------------------------------------------------------------------------------------------;
0121   0000             
0122   0000             ; ------------------------------------------------------------------------------------------------------------------;
0123   0000             ; IRQ Table
0124   0000             ; Highest priority at lowest address
0125   0000             ; ------------------------------------------------------------------------------------------------------------------;
0126   0000 3A 00       .dw int_0
0127   0002 3B 00       .dw int_1
0128   0004 3C 00       .dw int_2
0129   0006 3D 00       .dw int_3
0130   0008 3E 00       .dw int_4
0131   000A 3F 00       .dw int_5
0132   000C 40 00       .dw int_6
0133   000E 8C 00       .dw int_7
0134   0010             
0135   0010             ; ------------------------------------------------------------------------------------------------------------------;
0136   0010             ; Reset Vector
0137   0010             ; ------------------------------------------------------------------------------------------------------------------;
0138   0010 2C 0E       .dw kernel_reset_vector
0139   0012             
0140   0012             ; ------------------------------------------------------------------------------------------------------------------;
0141   0012             ; Exception Vector Table
0142   0012             ; Total of 7 entries, starting at address $0012
0143   0012             ; ------------------------------------------------------------------------------------------------------------------;
0144   0012 78 01       .dw trap_privilege
0145   0014 95 02       .dw trap_div_zero
0146   0016 A2 02       .dw trap_undef_opcode
0147   0018 00 00       .dw 0
0148   001A 00 00       .dw 0
0149   001C 00 00       .dw 0
0150   001E 00 00       .dw 0
0151   0020             
0152   0020             ; ------------------------------------------------------------------------------------------------------------------;
0153   0020             ; System Call Vector Table
0154   0020             ; Starts at address $0020
0155   0020             ; ------------------------------------------------------------------------------------------------------------------;
0156   0020 84 01       .dw syscall_break
0157   0022 A3 02       .dw syscall_rtc
0158   0024 DD 03       .dw syscall_ide
0159   0026 B8 04       .dw syscall_io
0160   0028 75 05       .dw syscall_file_system
0161   002A 03 0F       .dw syscall_spawn_proc
0162   002C 3D 01       .dw syscall_list_procs
0163   002E D5 02       .dw syscall_datetime
0164   0030 F9 00       .dw syscall_reboot
0165   0032 CD 0E       .dw syscall_pause_proc
0166   0034 05 01       .dw syscall_resume_proc
0167   0036 8A 0E       .dw syscall_terminate_proc
0168   0038 CB 00       .dw syscall_system
0169   003A             
0170   003A             ; ------------------------------------------------------------------------------------------------------------------;
0171   003A             ; System Call Aliases
0172   003A             ; ------------------------------------------------------------------------------------------------------------------;
0173   003A             sys_break            .equ 0
0174   003A             sys_rtc              .equ 1
0175   003A             sys_ide              .equ 2
0176   003A             sys_io               .equ 3
0177   003A             sys_filesystem       .equ 4
0178   003A             sys_spawn_proc       .equ 5
0179   003A             sys_list             .equ 6
0180   003A             sys_datetime         .equ 7
0181   003A             sys_reboot           .equ 8
0182   003A             sys_pause_proc       .equ 9
0183   003A             sys_resume_proc      .equ 10
0184   003A             sys_terminate_proc   .equ 11
0185   003A             sys_system           .equ 12
0186   003A             
0187   003A             ; ------------------------------------------------------------------------------------------------------------------;
0188   003A             ; Alias Exports
0189   003A             ; ------------------------------------------------------------------------------------------------------------------;
0190   003A             .export text_org
0191   003A             .export sys_break
0192   003A             .export sys_ide
0193   003A             .export sys_io
0194   003A             .export sys_filesystem
0195   003A             .export sys_spawn_proc
0196   003A             .export sys_list
0197   003A             .export sys_rtc
0198   003A             .export sys_datetime
0199   003A             .export sys_reboot
0200   003A             .export sys_pause_proc
0201   003A             .export sys_resume_proc
0202   003A             .export sys_terminate_proc
0203   003A             .export sys_system
0204   003A             
0205   003A             ; ------------------------------------------------------------------------------------------------------------------;
0206   003A             ; IRQs' Code Block
0207   003A             ; ------------------------------------------------------------------------------------------------------------------;
0208   003A             int_0:
0209   003A 06            sysret
0210   003B             int_1:
0211   003B 06            sysret
0212   003C             int_2:
0213   003C 06            sysret
0214   003D             int_3:
0215   003D 06            sysret
0216   003E             int_4:
0217   003E 06            sysret
0218   003F             int_5:
0219   003F 06            sysret
0220   0040             
0221   0040             ; ------------------------------------------------------------------------------------------------------------------;
0222   0040             ; Process Swapping
0223   0040             ; ------------------------------------------------------------------------------------------------------------------;
0224   0040             int_6:  
0225   0040 4B            pusha ; save all registers into kernel stack
0226   0041 22 00         mov ah, 0
0227   0043 1D FE 16      mov al, [active_proc_index]
0228   0046 FD 99         shl a              ; x2
0229   0048 B7 80 0F      mov a, [proc_table_convert + a]  ; get process state start index
0230   004B 4F            mov di, a
0231   004C 48            mov a, sp
0232   004D 77            inc a
0233   004E 4D            mov si, a
0234   004F 38 14 00      mov c, 20
0235   0052 FD F5         rep movsb          ; save process state!
0236   0054             ; restore kernel stack position to point before interrupt arrived
0237   0054 51 14 00      add sp, 20
0238   0057             ; now load next process in queue
0239   0057 1D FE 16      mov al, [active_proc_index]
0240   005A 31 FD 16      mov bl, [nbr_active_procs]
0241   005D BA            cmp al, bl
0242   005E C6 65 00      je int6_cycle_back
0243   0061 7A            inc al            ; next process is next in the series
0244   0062 0A 67 00      jmp int6_continue
0245   0065             int6_cycle_back:
0246   0065 19 01         mov al, 1        ; next process = process 1
0247   0067             int6_continue:
0248   0067 3D FE 16      mov [active_proc_index], al    ; set next active proc
0249   006A             
0250   006A             ; calculate LUT entry for next process
0251   006A 22 00         mov ah, 0
0252   006C FD 99         shl a              ; x2
0253   006E B7 80 0F      mov a, [proc_table_convert + a]    ; get process state start index  
0254   0071               
0255   0071 4D            mov si, a            ; source is proc state block
0256   0072 48            mov a, sp
0257   0073 5F 13 00      sub a, 19
0258   0076 4F            mov di, a            ; destination is kernel stack
0259   0077             ; restore SP
0260   0077 7D            dec a
0261   0078 47            mov sp, a
0262   0079 38 14 00      mov c, 20
0263   007C FD F5         rep movsb
0264   007E             ; set VM process
0265   007E 1D FE 16      mov al, [active_proc_index]
0266   0081 01            setptb
0267   0082 F2 E0 FF 00   mov byte[_TIMER_C_0], 0        ; load counter 0 low byte
0268   0086 F2 E0 FF 10   mov byte[_TIMER_C_0], $10        ; load counter 0 high byte
0269   008A 4C            popa
0270   008B 06            sysret
0271   008C             
0272   008C             ; ------------------------------------------------------------------------------------------------------------------;
0273   008C             ; UART0 Interrupt
0274   008C             ; ------------------------------------------------------------------------------------------------------------------;
0275   008C             int_7:
0276   008C D7            push a
0277   008D DA            push d
0278   008E E1            pushf
0279   008F 14 03 17      mov a, [fifo_in]
0280   0092 3C            mov d, a
0281   0093 1D 80 FF      mov al, [_UART0_DATA]  ; get character
0282   0096 B9 03         cmp al, $03        ; CTRL-C
0283   0098 C6 B5 00      je CTRLC
0284   009B B9 1A         cmp al, $1A        ; CTRL-Z
0285   009D C6 BB 00      je CTRLZ
0286   00A0 3E            mov [d], al        ; add to fifo
0287   00A1 14 03 17      mov a, [fifo_in]
0288   00A4 77            inc a
0289   00A5 AF F5 21      cmp a, fifo + FIFO_SIZE         ; check if pointer reached the end of the fifo
0290   00A8 C7 AE 00      jne int_7_continue
0291   00AB 10 F5 1D      mov a, fifo  
0292   00AE             int_7_continue:  
0293   00AE 42 03 17      mov [fifo_in], a      ; update fifo pointer
0294   00B1 EE            popf
0295   00B2 E7            pop d
0296   00B3 E4            pop a  
0297   00B4 06            sysret
0298   00B5             CTRLC:
0299   00B5 51 05 00      add sp, 5
0300   00B8 0A 8A 0E      jmp syscall_terminate_proc
0301   00BB             CTRLZ:
0302   00BB EE            popf
0303   00BC E7            pop d
0304   00BD E4            pop a
0305   00BE 0A CD 0E      jmp syscall_pause_proc    ; pause current process and go back to the shell
0306   00C1             
0307   00C1             ; ------------------------------------------------------------------------------------------------------------------;
0308   00C1             ; System Syscalls
0309   00C1             ; ------------------------------------------------------------------------------------------------------------------;
0310   00C1             system_jmptbl:
0311   00C1 F7 00         .dw system_uname
0312   00C3 F8 00         .dw system_whoami
0313   00C5 F4 00         .dw system_setparam
0314   00C7 D1 00         .dw system_bootloader_install
0315   00C9 CF 00         .dw system_getparam
0316   00CB             syscall_system:
0317   00CB FD 0A C1 00   jmp [system_jmptbl + al]
0318   00CF             
0319   00CF             ; param register address in register d
0320   00CF             ; param value in register bl
0321   00CF             system_getparam:
0322   00CF 32            mov bl, [d]
0323   00D0 06            sysret
0324   00D1             
0325   00D1             ; kernel LBA address in 'b'
0326   00D1             system_bootloader_install:
0327   00D1 D8            push b
0328   00D2 26 00 00      mov b, 0
0329   00D5 38 00 00      mov c, 0
0330   00D8 22 01         mov ah, $01                 ; 1 sector
0331   00DA 3B F5 23      mov d, transient_area
0332   00DD 07 27 04      call ide_read_sect          ; read sector
0333   00E0 E5            pop b
0334   00E1 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0335   00E5 26 00 00      mov b, 0
0336   00E8 38 00 00      mov c, 0
0337   00EB 22 01         mov ah, $01                 ; 1 sector
0338   00ED 3B F5 23      mov d, transient_area
0339   00F0 07 4D 04      call ide_write_sect         ; write sector
0340   00F3 06            sysret
0341   00F4             
0342   00F4             ; param register address in register d
0343   00F4             ; param value in register bl
0344   00F4             system_setparam:
0345   00F4 FD 3E         mov [d], bl
0346   00F6 06            sysret
0347   00F7             
0348   00F7             system_uname:
0349   00F7 06            sysret
0350   00F8             
0351   00F8             system_whoami:
0352   00F8 06            sysret
0353   00F9             
0354   00F9             ; REBOOT SYSTEM
0355   00F9             syscall_reboot:
0356   00F9 FD D7 FF FF   push word $FFFF 
0357   00FD FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0358   0100 FD D7 C0 01   push word BIOS_RESET_VECTOR    ; and then push RESET VECTOR of the shell to the stack
0359   0104 06            sysret
0360   0105             
0361   0105             ;------------------------------------------------------------------------------------------------------;;
0362   0105             ; switch to another process
0363   0105             ; inputs:
0364   0105             ; AL = new process number
0365   0105             ;------------------------------------------------------------------------------------------------------;;
0366   0105             syscall_resume_proc:
0367   0105 FD 78         mov g, a                            ; save the process number
0368   0107 4B            pusha                               ; save all registers into kernel stack
0369   0108 22 00         mov ah, 0
0370   010A 1D FE 16      mov al, [active_proc_index]
0371   010D FD 99         shl a              ; x2
0372   010F B7 80 0F      mov a, [proc_table_convert + a]     ; get process state start index
0373   0112 4F            mov di, a
0374   0113 48            mov a, sp
0375   0114 77            inc a
0376   0115 4D            mov si, a
0377   0116 38 14 00      mov c, 20
0378   0119 FD F5         rep movsb                           ; save process state!
0379   011B             ; restore kernel stack position to point before interrupt arrived
0380   011B 51 14 00      add sp, 20
0381   011E             ; now load the new process number!
0382   011E FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0383   0120 3D FE 16      mov [active_proc_index], al         ; set new active proc
0384   0123             ; calculate LUT entry for next process
0385   0123 22 00         mov ah, 0
0386   0125 FD 99         shl a                               ; x2
0387   0127 B7 80 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0388   012A 4D            mov si, a                           ; source is proc state block
0389   012B 48            mov a, sp
0390   012C 5F 13 00      sub a, 19
0391   012F 4F            mov di, a                           ; destination is kernel stack
0392   0130             ; restore SP
0393   0130 7D            dec a
0394   0131 47            mov sp, a
0395   0132 38 14 00      mov c, 20
0396   0135 FD F5         rep movsb
0397   0137             ; set VM process
0398   0137 1D FE 16      mov al, [active_proc_index]
0399   013A 01            setptb
0400   013B 4C            popa
0401   013C 06            sysret
0402   013D             
0403   013D             syscall_list_procs:
0404   013D 3B 26 17      mov d, s_ps_header
0405   0140 07 CD 11      call _puts
0406   0143 3B 66 19      mov d, proc_availab_table + 1
0407   0146 38 01 00      mov c, 1
0408   0149             list_procs_L0:  
0409   0149 BD 01         cmp byte[d], 1
0410   014B C7 6F 01      jne list_procs_next
0411   014E 2D            mov b, d
0412   014F 61 65 19      sub b, proc_availab_table
0413   0152 FD 9F 05      shl b, 5
0414   0155 DA            push d
0415   0156 D8            push b
0416   0157 28            mov b, c
0417   0158 07 6D 12      call print_u8x
0418   015B 22 20         mov ah, ' '
0419   015D 07 A1 10      call _putchar
0420   0160 07 A1 10      call _putchar
0421   0163 E5            pop b
0422   0164 74            mov d, b
0423   0165 58 75 19      add d, proc_names
0424   0168 07 CD 11      call _puts
0425   016B 07 7A 11      call printnl
0426   016E E7            pop d
0427   016F             list_procs_next:
0428   016F 79            inc d
0429   0170 78            inc c
0430   0171 C2 09 00      cmp c, 9
0431   0174 C7 49 01      jne list_procs_L0
0432   0177             list_procs_end:
0433   0177 06            sysret
0434   0178             
0435   0178             ; ------------------------------------------------------------------------------------------------------------------;
0436   0178             ; Exceptions' Code Block
0437   0178             ; ------------------------------------------------------------------------------------------------------------------;
0438   0178             ; Privilege
0439   0178             ; ------------------------------------------------------------------------------------------------------------------;
0440   0178             trap_privilege:
0441   0178 0A F9 00      jmp syscall_reboot
0442   017B DA            push d
0443   017C 3B 68 17      mov d, s_priviledge
0444   017F 07 CD 11      call _puts
0445   0182 E7            pop d
0446   0183 06            sysret
0447   0184             
0448   0184             ; ------------------------------------------------------------------------------------------------------------------;
0449   0184             ; Breakpoint
0450   0184             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0451   0184             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0452   0184             ; ------------------------------------------------------------------------------------------------------------------;
0453   0184             syscall_break:
0454   0184 4B            pusha
0455   0185             syscall_break_prompt:
0456   0185 3B 3F 02      mov d, s_break1
0457   0188 07 CD 11      call _puts
0458   018B 07 7A 11      call printnl
0459   018E 07 CF 12      call scan_u16d
0460   0191 AF 00 00      cmp a, 0
0461   0194 C6 9F 01      je syscall_break_regs
0462   0197 AF 01 00      cmp a, 1
0463   019A C6 C2 01      je syscall_break_mem
0464   019D             syscall_break_end:  
0465   019D 4C            popa
0466   019E 06            sysret
0467   019F             syscall_break_regs:
0468   019F 48            mov a, sp
0469   01A0 53 0E 00      add a, 14               ; back-track 7 registers
0470   01A3 3C            mov d, a
0471   01A4 3A 07         mov cl, 7
0472   01A6             syscall_regs_L0:
0473   01A6 2A            mov b, [d]
0474   01A7 FD AB         swp b
0475   01A9 07 29 12      call print_u16x         ; print register value
0476   01AC 07 7A 11      call printnl
0477   01AF 63 02 00      sub d, 2
0478   01B2 71 01         sub cl, 1
0479   01B4 C3 00         cmp cl, 0
0480   01B6 C7 A6 01      jne syscall_regs_L0
0481   01B9 0A 85 01      jmp syscall_break_prompt
0482   01BC 07 7A 11      call printnl
0483   01BF 0A 85 01      jmp syscall_break_prompt
0484   01C2             syscall_break_mem:
0485   01C2 07 7A 11      call printnl
0486   01C5 07 4B 12      call scan_u16x
0487   01C8 4D            mov si, a               ; data source from user space
0488   01C9 FD 4F F5 21   mov di, scrap_sector    ; destination in kernel space
0489   01CD 38 00 02      mov c, 512
0490   01D0 04            load                    ; transfer data to kernel space!
0491   01D1 3B F5 21      mov d, scrap_sector     ; dump pointer in d
0492   01D4 38 00 00      mov c, 0
0493   01D7             dump_loop:
0494   01D7 84            mov al, cl
0495   01D8 87 0F         and al, $0F
0496   01DA C6 28 02      jz print_base
0497   01DD             back:
0498   01DD 1E            mov al, [d]             ; read byte
0499   01DE 2F            mov bl, al
0500   01DF 07 6D 12      call print_u8x
0501   01E2 10 00 20      mov a, $2000
0502   01E5 05 03         syscall sys_io          ; space
0503   01E7 84            mov al, cl
0504   01E8 87 0F         and al, $0F
0505   01EA B9 0F         cmp al, $0F
0506   01EC C6 FD 01      je print_ascii
0507   01EF             back1:
0508   01EF 79            inc d
0509   01F0 78            inc c
0510   01F1 C2 00 02      cmp c, 512
0511   01F4 C7 D7 01      jne dump_loop
0512   01F7 07 7A 11      call printnl
0513   01FA 0A 85 01      jmp syscall_break_prompt  ; go to syscall_break return point
0514   01FD             print_ascii:
0515   01FD 10 00 20      mov a, $2000
0516   0200 05 03         syscall sys_io
0517   0202 63 10 00      sub d, 16
0518   0205 26 10 00      mov b, 16
0519   0208             print_ascii_L:
0520   0208 79            inc d
0521   0209 1E            mov al, [d]               ; read byte
0522   020A B9 20         cmp al, $20
0523   020C C8 14 02      jlu dot
0524   020F B9 7E         cmp al, $7E
0525   0211 D0 1C 02      jleu ascii
0526   0214             dot:
0527   0214 10 00 2E      mov a, $2E00
0528   0217 05 03         syscall sys_io
0529   0219 0A 21 02      jmp ascii_continue
0530   021C             ascii:
0531   021C 23            mov ah, al
0532   021D 19 00         mov al, 0
0533   021F 05 03         syscall sys_io
0534   0221             ascii_continue:
0535   0221 FD A9 08 02   loopb print_ascii_L
0536   0225 0A EF 01      jmp back1
0537   0228             print_base:
0538   0228 07 7A 11      call printnl
0539   022B 2D            mov b, d
0540   022C 61 F5 21      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0541   022F 07 29 12      call print_u16x          ; display row
0542   0232 10 00 3A      mov a, $3A00
0543   0235 05 03         syscall sys_io
0544   0237 10 00 20      mov a, $2000
0545   023A 05 03         syscall sys_io
0546   023C 0A DD 01      jmp back
0547   023F             
0548   023F             s_break1:  
0549   023F 0A 44 65 62   .db "\nDebugger entry point.\n"
0549   0243 75 67 67 65 
0549   0247 72 20 65 6E 
0549   024B 74 72 79 20 
0549   024F 70 6F 69 6E 
0549   0253 74 2E 0A 
0550   0256 30 2E 20 53   .db "0. Show Registers\n"
0550   025A 68 6F 77 20 
0550   025E 52 65 67 69 
0550   0262 73 74 65 72 
0550   0266 73 0A 
0551   0268 31 2E 20 53   .db "1. Show 512B RAM block\n"
0551   026C 68 6F 77 20 
0551   0270 35 31 32 42 
0551   0274 20 52 41 4D 
0551   0278 20 62 6C 6F 
0551   027C 63 6B 0A 
0552   027F 32 2E 20 43   .db "2. Continue Execution", 0
0552   0283 6F 6E 74 69 
0552   0287 6E 75 65 20 
0552   028B 45 78 65 63 
0552   028F 75 74 69 6F 
0552   0293 6E 00 
0553   0295             
0554   0295             ; ------------------------------------------------------------------------------------------------------------------;
0555   0295             ; Divide by Zero
0556   0295             ; ------------------------------------------------------------------------------------------------------------------;
0557   0295             trap_div_zero:
0558   0295 D7            push a
0559   0296 DA            push d
0560   0297 E1            pushf
0561   0298 3B 7F 17      mov d, s_divzero
0562   029B 07 CD 11      call _puts
0563   029E EE            popf
0564   029F E7            pop d
0565   02A0 E4            pop a
0566   02A1 06            sysret ; enable interrupts
0567   02A2             
0568   02A2             ; ------------------------------------------------------------------------------------------------------------------;
0569   02A2             ; Undefined Opcode
0570   02A2             ; ------------------------------------------------------------------------------------------------------------------;
0571   02A2             trap_undef_opcode:
0572   02A2 06            sysret
0573   02A3             
0574   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0575   02A3             ; RTC Services Syscall
0576   02A3             ; RTC I/O bank = FFA0 to FFAF
0577   02A3             ; FFA0 to FFA7 is scratch RAM
0578   02A3             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0579   02A3             ; al = 0..6 -> get
0580   02A3             ; al = 7..D -> set
0581   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0582   02A3             syscall_rtc:
0583   02A3 DB            push al
0584   02A4 DA            push d
0585   02A5 B9 06         cmp al, 6
0586   02A7 D1 BC 02      jgu syscall_rtc_set
0587   02AA             syscall_rtc_get:
0588   02AA 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0589   02AC 22 FF         mov ah, $FF    
0590   02AE 3C            mov d, a                ; get to FFA9 + offset
0591   02AF F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0592   02B3 1E            mov al, [d]             ; get data
0593   02B4 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0594   02B8 23            mov ah, al
0595   02B9 E7            pop d
0596   02BA E8            pop al
0597   02BB 06            sysret
0598   02BC             syscall_rtc_set:
0599   02BC DD            push bl
0600   02BD 99            mov bl, ah              ; set data asIDE
0601   02BE 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0602   02C0 22 FF         mov ah, $FF    
0603   02C2 3C            mov d, a                ; get to FFA9 + offset
0604   02C3 1B            mov al, bl              ; get data back
0605   02C4 F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0606   02C8 3E            mov [d], al             ; set data
0607   02C9 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0608   02CD EA            pop bl
0609   02CE E7            pop d
0610   02CF E8            pop al
0611   02D0 06            sysret
0612   02D1             
0613   02D1             datetime_serv_tbl:
0614   02D1 D9 02         .dw print_date
0615   02D3 4D 03         .dw set_date
0616   02D5             syscall_datetime:
0617   02D5 FD 0A D1 02   jmp [datetime_serv_tbl + al]      
0618   02D9             print_date:
0619   02D9 10 00 0D      mov a, $0D00           ; print carriage return char
0620   02DC 19 03         mov al, 3
0621   02DE 05 01         syscall sys_rtc        ; get week
0622   02E0 1A            mov al, ah
0623   02E1 22 00         mov ah, 0
0624   02E3 FD 9D 02      shl a, 2          
0625   02E6 3B 09 18      mov d, s_week
0626   02E9 59            add d, a
0627   02EA 07 CD 11      call _puts
0628   02ED 10 00 20      mov a, $2000
0629   02F0 05 03         syscall sys_io         ; display ' '
0630   02F2 19 04         mov al, 4
0631   02F4 05 01         syscall sys_rtc        ; get day
0632   02F6 99            mov bl, ah
0633   02F7 07 6D 12      call print_u8x
0634   02FA 10 00 20      mov a, $2000
0635   02FD 05 03         syscall sys_io         ; display ' '
0636   02FF             ; there is a problem with the month displaying
0637   02FF             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0638   02FF             ; even though it is to be understood as BCD.
0639   02FF             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0640   02FF 19 05         mov al, 05
0641   0301 05 01         syscall sys_rtc        ; get month
0642   0303 1A            mov al, ah
0643   0304 22 00         mov ah, 0
0644   0306 FD 9D 02      shl a, 2          
0645   0309 3B D5 17      mov d, s_months
0646   030C 59            add d, a
0647   030D 07 CD 11      call _puts
0648   0310 10 00 20      mov a, $2000
0649   0313 05 03         syscall sys_io         ; display ' '
0650   0315 2E 20         mov bl, $20
0651   0317 07 6D 12      call print_u8x         ; print 20 for year prefix
0652   031A 19 06         mov al, 06
0653   031C 05 01         syscall sys_rtc        ; get year
0654   031E 99            mov bl, ah
0655   031F 07 6D 12      call print_u8x
0656   0322 10 00 20      mov a, $2000  
0657   0325 05 03         syscall sys_io         ; display ' '
0658   0327 19 02         mov al, 2
0659   0329 05 01         syscall sys_rtc        ; get hours
0660   032B 99            mov bl, ah
0661   032C 07 6D 12      call print_u8x
0662   032F 10 00 3A      mov a, $3A00    
0663   0332 05 03         syscall sys_io         ; display ':'
0664   0334 19 01         mov al, 01
0665   0336 05 01         syscall sys_rtc        ; get minutes
0666   0338 99            mov bl, ah
0667   0339 07 6D 12      call print_u8x
0668   033C 10 00 3A      mov a, $3A00  
0669   033F 05 03         syscall sys_io         ; display ':'
0670   0341 19 00         mov al, 0
0671   0343 05 01         syscall sys_rtc        ; get seconds
0672   0345 99            mov bl, ah
0673   0346 07 6D 12      call print_u8x
0674   0349 07 7A 11      call printnl
0675   034C 06            sysret
0676   034D             set_date:
0677   034D 3B 9A 17      mov d, s_set_year
0678   0350 07 CD 11      call _puts
0679   0353 07 B8 12      call scan_u8x          ; read integer into A
0680   0356 FD 9D 08      shl a, 8               ; only AL used, move to AH
0681   0359 19 0D         mov al, 0Dh            ; set RTC year
0682   035B 05 01         syscall sys_rtc        ; set RTC
0683   035D 3B A1 17      mov d, s_set_month
0684   0360 07 CD 11      call _puts
0685   0363 07 B8 12      call scan_u8x          ; read integer into A
0686   0366 FD 9D 08      shl a, 8               ; only AL used, move to AH
0687   0369 19 0C         mov al, 0Ch            ; set RTC month
0688   036B 05 01         syscall sys_rtc        ; set RTC
0689   036D 3B A9 17      mov d, s_set_day
0690   0370 07 CD 11      call _puts
0691   0373 07 B8 12      call scan_u8x          ; read integer into A
0692   0376 FD 9D 08      shl a, 8               ; only AL used, move to AH
0693   0379 19 0B         mov al, 0Bh            ; set RTC month
0694   037B 05 01         syscall sys_rtc        ; set RTC
0695   037D 3B AF 17      mov d, s_set_week
0696   0380 07 CD 11      call _puts
0697   0383 07 B8 12      call scan_u8x          ; read integer into A
0698   0386 FD 9D 08      shl a, 8               ; only AL used, move to AH
0699   0389 19 0A         mov al, 0Ah            ; set RTC month
0700   038B 05 01         syscall sys_rtc        ; set RTC
0701   038D 3B B9 17      mov d, s_set_hours
0702   0390 07 CD 11      call _puts
0703   0393 07 B8 12      call scan_u8x          ; read integer into A
0704   0396 FD 9D 08      shl a, 8               ; only AL used, move to AH
0705   0399 19 09         mov al, 09h            ; set RTC month
0706   039B 05 01         syscall sys_rtc        ; set RTC
0707   039D 3B C1 17      mov d, s_set_minutes
0708   03A0 07 CD 11      call _puts
0709   03A3 07 B8 12      call scan_u8x          ; read integer into A
0710   03A6 FD 9D 08      shl a, 8               ; only AL used, move to AH
0711   03A9 19 08         mov al, 08h            ; set RTC month
0712   03AB 05 01         syscall sys_rtc        ; set RTC
0713   03AD 3B CB 17      mov d, s_set_seconds
0714   03B0 07 CD 11      call _puts
0715   03B3 07 B8 12      call scan_u8x          ; read integer into A
0716   03B6 FD 9D 08      shl a, 8               ; only AL used, move to AH
0717   03B9 19 07         mov al, 07h            ; set RTC month
0718   03BB 05 01         syscall sys_rtc        ; set RTC
0719   03BD 06            sysret
0720   03BE             
0721   03BE             ; ------------------------------------------------------------------------------------------------------------------;
0722   03BE             ; IDE Services Syscall
0723   03BE             ; al = option
0724   03BE             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0725   03BE             ; IDE read/write sector
0726   03BE             ; 512 bytes
0727   03BE             ; User buffer pointer in D
0728   03BE             ; AH = number of sectors
0729   03BE             ; CB = LBA bytes 3..0
0730   03BE             ; ------------------------------------------------------------------------------------------------------------------;
0731   03BE 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0731   03C2 73 63 61 6C 
0731   03C6 6C 5F 69 64 
0731   03CA 65 20 63 61 
0731   03CE 6C 6C 65 64 
0731   03D2 3A 20 00 
0732   03D5             ide_serv_tbl:
0733   03D5 FC 03         .dw ide_reset
0734   03D7 10 04         .dw ide_sleep
0735   03D9 1F 04         .dw ide_read_sect_wrapper
0736   03DB 23 04         .dw ide_write_sect_wrapper
0737   03DD             syscall_ide:
0738   03DD DD            push bl
0739   03DE 31 F6 16      mov bl, [sys_debug_mode]
0740   03E1               ; debug block
0741   03E1 C1 00         cmp bl, 0
0742   03E3 EA            pop bl
0743   03E4 C6 F8 03      je syscall_ide_jmp
0744   03E7 DA            push d
0745   03E8 DD            push bl
0746   03E9 3B BE 03      mov d, s_syscall_ide_dbg0
0747   03EC 07 CD 11      call _puts
0748   03EF 2F            mov bl, al
0749   03F0 07 6D 12      call print_u8x
0750   03F3 07 7A 11      call printnl
0751   03F6 EA            pop bl
0752   03F7 E7            pop d
0753   03F8             syscall_ide_jmp:
0754   03F8 FD 0A D5 03   jmp [ide_serv_tbl + al]    
0755   03FC               
0756   03FC             ide_reset:      
0757   03FC F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0758   0400 07 A9 04      call ide_wait                   ; wait for IDE ready             
0759   0403 F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0760   0407 F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0761   040B F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0762   040F 06            sysret
0763   0410             ide_sleep:
0764   0410 07 A9 04      call ide_wait                   ; wait for IDE ready             
0765   0413 F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0766   0417 F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0767   041B 07 A9 04      call ide_wait                   ; wait for IDE ready
0768   041E 06            sysret
0769   041F             ide_read_sect_wrapper:
0770   041F 07 27 04      call ide_read_sect
0771   0422 06            sysret
0772   0423             ide_write_sect_wrapper:
0773   0423 07 4D 04      call ide_write_sect
0774   0426 06            sysret
0775   0427             ide_read_sect:
0776   0427 1A            mov al, ah
0777   0428 24            mov ah, bl
0778   0429 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0779   042C 1C            mov al, bh
0780   042D 3D D4 FF      mov [_ide_R4], al
0781   0430 12            mov a, c
0782   0431 3D D5 FF      mov [_ide_R5], al
0783   0434 1A            mov al, ah
0784   0435 87 0F         and al, %00001111
0785   0437 8B E0         or al, %11100000                ; mode lba, master
0786   0439 3D D6 FF      mov [_ide_R6], al
0787   043C             ide_read_sect_wait:
0788   043C 1D D7 FF      mov al, [_ide_R7]  
0789   043F 87 80         and al, $80                     ; BUSY FLAG
0790   0441 C7 3C 04      jnz ide_read_sect_wait
0791   0444 19 20         mov al, $20
0792   0446 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0793   0449 07 73 04      call ide_read  
0794   044C 09            ret
0795   044D             ide_write_sect:
0796   044D 1A            mov al, ah
0797   044E 24            mov ah, bl
0798   044F 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0799   0452 1C            mov al, bh
0800   0453 3D D4 FF      mov [_ide_R4], al
0801   0456 12            mov a, c
0802   0457 3D D5 FF      mov [_ide_R5], al
0803   045A 1A            mov al, ah
0804   045B 87 0F         and al, %00001111
0805   045D 8B E0         or al, %11100000                ; mode lba, master
0806   045F 3D D6 FF      mov [_ide_R6], al
0807   0462             ide_write_sect_wait:
0808   0462 1D D7 FF      mov al, [_ide_R7]  
0809   0465 87 80         and al, $80                     ; BUSY FLAG
0810   0467 C7 62 04      jnz ide_write_sect_wait
0811   046A 19 30         mov al, $30
0812   046C 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0813   046F 07 8E 04      call ide_write      
0814   0472 09            ret
0815   0473             
0816   0473             ;----------------------------------------------------------------------------------------------------;
0817   0473             ; READ IDE DATA
0818   0473             ; pointer in D
0819   0473             ;----------------------------------------------------------------------------------------------------;
0820   0473             ide_read:
0821   0473 DA            push d
0822   0474             ide_read_loop:
0823   0474 1D D7 FF      mov al, [_ide_R7]  
0824   0477 87 80         and al, 80h                     ; BUSY FLAG
0825   0479 C7 74 04      jnz ide_read_loop               ; wait loop
0826   047C 1D D7 FF      mov al, [_ide_R7]
0827   047F 87 08         and al, %00001000               ; DRQ FLAG
0828   0481 C6 8C 04      jz ide_read_end
0829   0484 1D D0 FF      mov al, [_ide_R0]
0830   0487 3E            mov [d], al
0831   0488 79            inc d
0832   0489 0A 74 04      jmp ide_read_loop
0833   048C             ide_read_end:
0834   048C E7            pop d
0835   048D 09            ret
0836   048E             
0837   048E             ;----------------------------------------------------------------------------------------------------;
0838   048E             ; WRITE IDE DATA
0839   048E             ; data pointer in D
0840   048E             ;----------------------------------------------------------------------------------------------------;
0841   048E             ide_write:
0842   048E DA            push d
0843   048F             ide_write_loop:
0844   048F 1D D7 FF      mov al, [_ide_R7]  
0845   0492 87 80         and al, 80h             ; BUSY FLAG
0846   0494 C7 8F 04      jnz ide_write_loop      ; wait loop
0847   0497 1D D7 FF      mov al, [_ide_R7]
0848   049A 87 08         and al, %00001000       ; DRQ FLAG
0849   049C C6 A7 04      jz ide_write_end
0850   049F 1E            mov al, [d]
0851   04A0 3D D0 FF      mov [_ide_R0], al
0852   04A3 79            inc d 
0853   04A4 0A 8F 04      jmp ide_write_loop
0854   04A7             ide_write_end:
0855   04A7 E7            pop d
0856   04A8 09            ret
0857   04A9             
0858   04A9             ;----------------------------------------------------------------------------------------------------;
0859   04A9             ; wait for IDE to be ready
0860   04A9             ;----------------------------------------------------------------------------------------------------;
0861   04A9             ide_wait:
0862   04A9 1D D7 FF      mov al, [_ide_R7]  
0863   04AC 87 80         and al, 80h        ; BUSY FLAG
0864   04AE C7 A9 04      jnz ide_wait
0865   04B1 09            ret
0866   04B2             
0867   04B2             ;----------------------------------------------------------------------------------------------------;
0868   04B2             ; IO Syscall
0869   04B2             ;----------------------------------------------------------------------------------------------------;
0870   04B2             ; Baud  Divisor
0871   04B2             ; 50    2304
0872   04B2             ; 110   1047
0873   04B2             ; 300    384
0874   04B2             ; 600    192
0875   04B2             ; 1200    96
0876   04B2             ; 9600    12
0877   04B2             ; 19200    6
0878   04B2             ; 38400    3
0879   04B2             syscall_io_jmp:
0880   04B2 E5 04         .dw syscall_io_putchar
0881   04B4 F2 04         .dw syscall_io_getch
0882   04B6 BC 04         .dw syscall_io_uart_setup
0883   04B8             syscall_io:
0884   04B8 FD 0A B2 04   jmp [syscall_io_jmp + al]
0885   04BC             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0886   04BC             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0887   04BC             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0888   04BC             syscall_io_uart_setup:
0889   04BC 1D F8 16      mov al, [sys_uart0_lcr]
0890   04BF 8B 80         or al, $80                ; set DLAB access bit
0891   04C1 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0892   04C4 1D FB 16      mov al, [sys_uart0_div0]
0893   04C7 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0894   04CA 1D FC 16      mov al, [sys_uart0_div1]
0895   04CD 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0896   04D0             
0897   04D0 1D F8 16      mov al, [sys_uart0_lcr]
0898   04D3 87 7F         and al, $7F               ; clear DLAB access bit 
0899   04D5 3D 83 FF      mov [_UART0_LCR], al
0900   04D8 1D F9 16      mov al, [sys_uart0_inten]
0901   04DB 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0902   04DE 1D FA 16      mov al, [sys_uart0_fifoen]
0903   04E1 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0904   04E4 06            sysret
0905   04E5             
0906   04E5             ; char in ah
0907   04E5             syscall_io_putchar:
0908   04E5             syscall_io_putchar_L0:
0909   04E5 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0910   04E8 87 20         and al, $20
0911   04EA C6 E5 04      jz syscall_io_putchar_L0    
0912   04ED 1A            mov al, ah
0913   04EE 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0914   04F1 06            sysret
0915   04F2             
0916   04F2             ; char in ah
0917   04F2             ; al = sucess code
0918   04F2             syscall_io_getch:
0919   04F2 D8            push b
0920   04F3 DA            push d
0921   04F4 FD 0C         sti
0922   04F6             syscall_io_getch_L0:  
0923   04F6 14 05 17      mov a, [fifo_out]
0924   04F9 29 03 17      mov b, [fifo_in]
0925   04FC B0            cmp a, b
0926   04FD C6 F6 04      je syscall_io_getch_L0
0927   0500 3C            mov d, a
0928   0501 77            inc a
0929   0502 AF F5 21      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
0930   0505 C7 0B 05      jne syscall_io_getch_cont
0931   0508 10 F5 1D      mov a, fifo  
0932   050B             syscall_io_getch_cont:  
0933   050B 42 05 17      mov [fifo_out], a             ; update fifo pointer
0934   050E 1E            mov al, [d]                   ; get char
0935   050F 23            mov ah, al
0936   0510 1D F7 16      mov al, [sys_echo_on]
0937   0513 B9 01         cmp al, 1
0938   0515 C7 24 05      jne syscall_io_getch_noecho 
0939   0518             ; here we just echo the char back to the console
0940   0518             syscall_io_getch_echo_L0:
0941   0518 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0942   051B 87 20         and al, $20                 ; isolate Transmitter Empty
0943   051D C6 18 05      jz syscall_io_getch_echo_L0
0944   0520 1A            mov al, ah
0945   0521 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0946   0524             syscall_io_getch_noecho:
0947   0524 19 01         mov al, 1                    ; AL = 1 means a char successfully received
0948   0526 E7            pop d
0949   0527 E5            pop b
0950   0528 06            sysret
0951   0529             
0952   0529             ;------------------------------------------------------------------------------------------------------;
0953   0529             ; FILE SYSTEM DATA
0954   0529             ;------------------------------------------------------------------------------------------------------;
0955   0529             ; infor for : IDE SERVICES INTERRUPT
0956   0529             ; IDE read/write 512-byte sector
0957   0529             ; al = option
0958   0529             ; user buffer pointer in D
0959   0529             ; AH = number of sectors
0960   0529             ; CB = LBA bytes 3..0  
0961   0529             ;------------------------------------------------------------------------------------------------------;
0962   0529             ; FILE SYSTEM DATA STRUCTURE
0963   0529             ;------------------------------------------------------------------------------------------------------;
0964   0529             ; for a directory we have the header first, followed by metadata
0965   0529             ; header 1 sector (512 bytes)
0966   0529             ; metadata 1 sector (512 bytes)
0967   0529             ; HEADER ENTRIES:
0968   0529             ; filename (64)
0969   0529             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0970   0529             ;
0971   0529             ; metadata entries:
0972   0529             ; filename (24)
0973   0529             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
0974   0529             ; LBA (2)
0975   0529             ; size (2)
0976   0529             ; day (1)
0977   0529             ; month (1)
0978   0529             ; year (1)
0979   0529             ; packet size = 32 bytes
0980   0529             ;
0981   0529             ; first directory on disk is the root directory '/'
0982   0529             file_system_jmptbl:
0983   0529 94 05         .dw fs_mkfs                   ; 0
0984   052B 00 00         .dw 0                         ; 1
0985   052D F6 05         .dw fs_mkdir                  ; 2
0986   052F 6F 09         .dw fs_cd                     ; 3
0987   0531 76 09         .dw fs_ls                     ; 4
0988   0533 EC 0A         .dw fs_mktxt                  ; 5
0989   0535 B7 0B         .dw fs_mkbin                  ; 6
0990   0537 7E 0C         .dw fs_pwd                    ; 7
0991   0539 9B 0C         .dw fs_cat                    ; 8
0992   053B F7 0C         .dw fs_rmdir                  ; 9
0993   053D 53 0D         .dw fs_rm                     ; 10
0994   053F 47 0A         .dw fs_starcom                ; 11
0995   0541 00 00         .dw 0                         ; 12
0996   0543 00 00         .dw 0                         ; 13
0997   0545 9C 05         .dw fs_chmod                  ; 14
0998   0547 BB 0D         .dw fs_mv                     ; 15
0999   0549 95 05         .dw fs_cd_root                ; 16
1000   054B 6B 09         .dw fs_get_curr_dirID         ; 17
1001   054D 47 07         .dw fs_dir_id_to_path         ; 18
1002   054F AD 07         .dw fs_path_to_dir_id_user    ; 19
1003   0551 C7 08         .dw fs_load_from_path_user    ; 20  
1004   0553 37 08         .dw fs_filepath_exists_user   ; 21
1005   0555             
1006   0555 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1006   0559 79 73 63 61 
1006   055D 6C 6C 5F 66 
1006   0561 69 6C 65 5F 
1006   0565 73 79 73 74 
1006   0569 65 6D 20 63 
1006   056D 61 6C 6C 65 
1006   0571 64 3A 20 00 
1007   0575             syscall_file_system:
1008   0575 DD            push bl
1009   0576 31 F6 16      mov bl, [sys_debug_mode]
1010   0579               ; debug block
1011   0579 C1 00         cmp bl, 0
1012   057B EA            pop bl
1013   057C C6 90 05      je syscall_filesystem_jmp
1014   057F DA            push d
1015   0580 DD            push bl
1016   0581 3B 55 05      mov d, s_syscall_fs_dbg0
1017   0584 07 CD 11      call _puts
1018   0587 2F            mov bl, al
1019   0588 07 6D 12      call print_u8x
1020   058B 07 7A 11      call printnl
1021   058E EA            pop bl
1022   058F E7            pop d
1023   0590             syscall_filesystem_jmp:
1024   0590 FD 0A 29 05   jmp [file_system_jmptbl + al]
1025   0594             
1026   0594             fs_mkfs:  
1027   0594 06            sysret  
1028   0595               
1029   0595             fs_cd_root:
1030   0595 10 20 00      mov a, root_id
1031   0598 42 07 17      mov [current_dir_id], a      ; set current directory LBA to ROOT
1032   059B 06            sysret  
1033   059C             
1034   059C             ; filename in D (userspace data)
1035   059C             ; permission in BL
1036   059C             fs_chmod:
1037   059C DD            push bl
1038   059D FD 4E         mov si, d
1039   059F FD 4F F5 1B   mov di, user_data
1040   05A3 38 80 00      mov c, 128
1041   05A6 04            load                        ; load filename from user-space
1042   05A7 14 07 17      mov a, [current_dir_id]
1043   05AA 77            inc a                       ; metadata sector
1044   05AB 27            mov b, a
1045   05AC 38 00 00      mov c, 0                    ; upper LBA = 0
1046   05AF 22 01         mov ah, $01                  ; 1 sector
1047   05B1 3B F5 23      mov d, transient_area
1048   05B4 07 27 04      call ide_read_sect          ; read directory
1049   05B7 FD 10         cla
1050   05B9 42 FF 16      mov [index], a              ; reset file counter
1051   05BC             fs_chmod_L1:
1052   05BC FD 4E         mov si, d
1053   05BE FD 4F F5 1B   mov di, user_data
1054   05C2 07 10 10      call _strcmp
1055   05C5 C6 DC 05      je fs_chmod_found_entry
1056   05C8 58 20 00      add d, 32
1057   05CB 14 FF 16      mov a, [index]
1058   05CE 77            inc a
1059   05CF 42 FF 16      mov [index], a
1060   05D2 AF 10 00      cmp a, FST_FILES_PER_DIR
1061   05D5 C7 BC 05      jne fs_chmod_L1
1062   05D8 EA            pop bl
1063   05D9 0A F5 05      jmp fs_chmod_not_found
1064   05DC             fs_chmod_found_entry:  
1065   05DC FD 79         mov g, b                    ; save LBA
1066   05DE EA            pop bl                      ; retrieve saved permission value
1067   05DF 1F 18 00      mov al, [d + 24]            ; read file permissions
1068   05E2 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1069   05E4 8C            or al, bl                   ; set new permissions
1070   05E5 3F 18 00      mov [d + 24], al            ; write new permissions
1071   05E8 38 00 00      mov c, 0
1072   05EB 3B F5 23      mov d, transient_area
1073   05EE 22 01         mov ah, $01                 ; disk write 1 sect
1074   05F0 FD 27         mov b, g                    ; retrieve LBA
1075   05F2 07 4D 04      call ide_write_sect         ; write sector
1076   05F5             fs_chmod_not_found:
1077   05F5 06            sysret
1078   05F6             
1079   05F6             ;------------------------------------------------------------------------------------------------------;
1080   05F6             ; CREATE NEW DIRECTORY
1081   05F6             ;------------------------------------------------------------------------------------------------------;
1082   05F6             ; search list for NULL name entry. add new directory to list
1083   05F6             fs_mkdir:
1084   05F6 FD 4E         mov si, d
1085   05F8 FD 4F F5 1B   mov di, user_data
1086   05FC 38 00 02      mov c, 512
1087   05FF 04            load                        ; load data from user-space
1088   0600 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1089   0603                                           ; when checking for NULL name, since root has a NULL name)
1090   0603 38 00 00      mov c, 0                    ; upper LBA = 0
1091   0606             fs_mkdir_L1:  
1092   0606 22 01         mov ah, $01                  ; 1 sector
1093   0608 3B F5 23      mov d, transient_area
1094   060B 07 27 04      call ide_read_sect          ; read sector
1095   060E BD 00         cmp byte[d], 0              ; check for NULL
1096   0610 C6 19 06      je fs_mkdir_found_null
1097   0613 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1098   0616 0A 06 06      jmp fs_mkdir_L1
1099   0619             fs_mkdir_found_null:
1100   0619             ;create header file by grabbing dir name from parameter
1101   0619 D8            push b                      ; save new directory's LBA
1102   061A 38 40 00      mov c, 64
1103   061D FD 4D F5 1B   mov si, user_data
1104   0621 FD 4F F5 23   mov di, transient_area
1105   0625 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1106   0627 14 07 17      mov a, [current_dir_id]
1107   062A 42 35 24      mov [transient_area + 64], a    ; store parent directory LBA
1108   062D 19 00         mov al, 0
1109   062F FD 4F F5 25   mov di, transient_area + 512
1110   0633 38 00 02      mov c, 512
1111   0636 FD F7         rep stosb                       ; clean buffer
1112   0638 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1113   063B             ; write directory entry sectors
1114   063B 3B F5 23      mov d, transient_area
1115   063E 22 02         mov ah, $02                     ; disk write, 2 sectors
1116   0640 07 4D 04      call ide_write_sect             ; write sector
1117   0643             ; now we need to add the new directory to the list, insIDE the current directory
1118   0643 14 07 17      mov a, [current_dir_id]
1119   0646 53 01 00      add a, 1
1120   0649 27            mov b, a                        ; metadata sector
1121   064A 38 00 00      mov c, 0
1122   064D FD 79         mov g, b                        ; save LBA
1123   064F 3B F5 23      mov d, transient_area
1124   0652 22 01         mov ah, $01                  ; 1 sector
1125   0654 07 27 04      call ide_read_sect              ; read metadata sector
1126   0657             fs_mkdir_L2:
1127   0657 BD 00         cmp byte[d], 0
1128   0659 C6 62 06      je fs_mkdir_found_null2
1129   065C 58 20 00      add d, FST_ENTRY_SIZE
1130   065F 0A 57 06      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1131   0662             fs_mkdir_found_null2:
1132   0662 FD 4D F5 1B   mov si, user_data
1133   0666 FD 50         mov di, d
1134   0668 07 25 10      call _strcpy                    ; copy directory name
1135   066B 58 18 00      add d, 24                       ; goto ATTRIBUTES
1136   066E 19 0B         mov al, %00001011               ; directory, no execute, write, read
1137   0670 3E            mov [d], al      
1138   0671 79            inc d
1139   0672 E5            pop b
1140   0673 D8            push b                          ; push LBA back
1141   0674 FD 43         mov [d], b                      ; save LBA
1142   0676             ; set file creation date  
1143   0676 58 04 00      add d, 4
1144   0679 19 04         mov al, 4
1145   067B 05 01         syscall sys_rtc
1146   067D 1A            mov al, ah
1147   067E 3E            mov [d], al                     ; set day
1148   067F 79            inc d
1149   0680 19 05         mov al, 5
1150   0682 05 01         syscall sys_rtc
1151   0684 1A            mov al, ah
1152   0685 3E            mov [d], al                     ; set month
1153   0686 79            inc d
1154   0687 19 06         mov al, 6
1155   0689 05 01         syscall sys_rtc
1156   068B 1A            mov al, ah
1157   068C 3E            mov [d], al                     ; set year
1158   068D             ; write sector into disk for new directory entry
1159   068D FD 27         mov b, g
1160   068F 38 00 00      mov c, 0
1161   0692 3B F5 23      mov d, transient_area
1162   0695 22 01         mov ah, $01                     ; disk write, 1 sector
1163   0697 07 4D 04      call ide_write_sect             ; write sector
1164   069A             
1165   069A             ; after adding the new directory's information to its parent directory's list
1166   069A             ; we need to now enter the new directory, and to it add two new directories!
1167   069A             ; which directories do we need to add ? '..' and '.' are the directories needed.
1168   069A             ; importantly, note that these two new directories are only entries in the list
1169   069A             ; and do not have actual physical entries in the disk as real directories.
1170   069A             ; i.e. they only exist as list entries in the new directory created so that
1171   069A             ; the new directory can reference its parent and itself.
1172   069A             ; We need to add both '..' and '.'
1173   069A             ; this first section is for '..' and on the section below we do the same for '.'
1174   069A E4            pop a                         ; retrieve the new directory's LBA  
1175   069B D7            push a                        ; and save again
1176   069C 53 01 00      add a, 1
1177   069F 27            mov b, a                      ; metadata sector
1178   06A0 38 00 00      mov c, 0
1179   06A3 FD 79         mov g, b                      ; save LBA
1180   06A5 3B F5 23      mov d, transient_area
1181   06A8 22 01         mov ah, $01                  ; 1 sector
1182   06AA 07 27 04      call ide_read_sect            ; read metadata sector
1183   06AD             fs_mkdir_L3:
1184   06AD BD 00         cmp byte[d], 0
1185   06AF C6 B8 06      je fs_mkdir_found_null3
1186   06B2 58 20 00      add d, FST_ENTRY_SIZE
1187   06B5 0A AD 06      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1188   06B8             fs_mkdir_found_null3:
1189   06B8 FD 4D 17 17   mov si, s_parent_dir
1190   06BC FD 50         mov di, d
1191   06BE 07 25 10      call _strcpy                  ; copy directory name
1192   06C1 58 18 00      add d, 24                     ; goto ATTRIBUTES
1193   06C4 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1194   06C6 3E            mov [d], al      
1195   06C7 79            inc d
1196   06C8 29 07 17      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1197   06CB FD 43         mov [d], b                    ; save LBA
1198   06CD             ; set file creation date  
1199   06CD 58 04 00      add d, 4
1200   06D0 19 04         mov al, 4
1201   06D2 05 01         syscall sys_rtc
1202   06D4 1A            mov al, ah
1203   06D5 3E            mov [d], al                   ; set day
1204   06D6 79            inc d
1205   06D7 19 05         mov al, 5
1206   06D9 05 01         syscall sys_rtc
1207   06DB 1A            mov al, ah
1208   06DC 3E            mov [d], al                   ; set month
1209   06DD 79            inc d
1210   06DE 19 06         mov al, 6
1211   06E0 05 01         syscall sys_rtc
1212   06E2 1A            mov al, ah
1213   06E3 3E            mov [d], al                   ; set year
1214   06E4             ; write sector into disk for new directory entry
1215   06E4 FD 27         mov b, g
1216   06E6 38 00 00      mov c, 0
1217   06E9 3B F5 23      mov d, transient_area
1218   06EC 22 01         mov ah, $01                   ; disk write, 1 sector
1219   06EE 07 4D 04      call ide_write_sect           ; write sector
1220   06F1             ;;;;;;;;;;;;;
1221   06F1             ; like we did above for '..', we need to now add the '.' directory to the list.
1222   06F1             ;------------------------------------------------------------------------------------------------------;
1223   06F1 E4            pop a                         ; retrieve the new directory's LBA  
1224   06F2 D7            push a
1225   06F3 53 01 00      add a, 1
1226   06F6 27            mov b, a                      ; metadata sector
1227   06F7 38 00 00      mov c, 0
1228   06FA FD 79         mov g, b                      ; save LBA
1229   06FC 3B F5 23      mov d, transient_area
1230   06FF 22 01         mov ah, $01                  ; 1 sector
1231   0701 07 27 04      call ide_read_sect            ; read metadata sector
1232   0704             fs_mkdir_L4:
1233   0704 BD 00         cmp byte[d], 0
1234   0706 C6 0F 07      je fs_mkdir_found_null4
1235   0709 58 20 00      add d, FST_ENTRY_SIZE
1236   070C 0A 04 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1237   070F             fs_mkdir_found_null4:
1238   070F FD 4D 1A 17   mov si, s_current_dir
1239   0713 FD 50         mov di, d
1240   0715 07 25 10      call _strcpy                  ; copy directory name
1241   0718 58 18 00      add d, 24                     ; goto ATTRIBUTES
1242   071B 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1243   071D 3E            mov [d], al      
1244   071E 79            inc d
1245   071F E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1246   0720 FD 43         mov [d], b                    ; save LBA
1247   0722             ; set file creation date  
1248   0722 58 04 00      add d, 4
1249   0725 19 04         mov al, 4
1250   0727 05 01         syscall sys_rtc
1251   0729 1A            mov al, ah
1252   072A 3E            mov [d], al                   ; set day
1253   072B 79            inc d
1254   072C 19 05         mov al, 5
1255   072E 05 01         syscall sys_rtc
1256   0730 1A            mov al, ah
1257   0731 3E            mov [d], al                   ; set month
1258   0732 79            inc d
1259   0733 19 06         mov al, 6
1260   0735 05 01         syscall sys_rtc
1261   0737 1A            mov al, ah
1262   0738 3E            mov [d], al                   ; set year
1263   0739             ; write sector into disk for new directory entry
1264   0739 FD 27         mov b, g
1265   073B 38 00 00      mov c, 0
1266   073E 3B F5 23      mov d, transient_area
1267   0741 22 01         mov ah, $01                   ; disk write, 1 sector
1268   0743 07 4D 04      call ide_write_sect           ; write sector
1269   0746             fs_mkdir_end:
1270   0746 06            sysret
1271   0747             
1272   0747             ;------------------------------------------------------------------------------------------------------;
1273   0747             ; get path from a given directory dirID
1274   0747             ; pseudo code:
1275   0747             ;  fs_dir_id_to_path(int dirID, char *D){
1276   0747             ;    if(dirID == 0){
1277   0747             ;      reverse path in D;
1278   0747             ;      return;
1279   0747             ;    }
1280   0747             ;    else{
1281   0747             ;      copy directory name to end of D;
1282   0747             ;      add '/' to end of D;
1283   0747             ;      parentID = get parent directory ID;
1284   0747             ;      fs_dir_id_to_path(parentID, D);
1285   0747             ;    }
1286   0747             ;  }
1287   0747             ; A = dirID
1288   0747             ; D = generated path string pointer
1289   0747             ;------------------------------------------------------------------------------------------------------;
1290   0747             ; sample path: /usr/bin
1291   0747             fs_dir_id_to_path:
1292   0747 3B 75 1B      mov d, filename
1293   074A 19 00         mov al, 0
1294   074C 3E            mov [d], al                     ; initialize path string 
1295   074D 14 07 17      mov a, [current_dir_id]
1296   0750 07 5D 07      call fs_dir_id_to_path_E0
1297   0753 3B 75 1B      mov d, filename
1298   0756 07 B9 0F      call _strrev
1299   0759 07 CD 11      call _puts
1300   075C 06            sysret
1301   075D             fs_dir_id_to_path_E0:
1302   075D 07 7C 07      call get_dirname_from_dirID
1303   0760 FD 4D 1C 17   mov si, s_fslash
1304   0764 FD 50         mov di, d
1305   0766 07 33 10      call _strcat                    ; add '/' to end of path
1306   0769 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1307   076C C6 7B 07      je fs_dir_id_to_path_root
1308   076F 07 99 07      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1309   0772 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1310   0775 C6 7B 07      je fs_dir_id_to_path_root
1311   0778 07 5D 07      call fs_dir_id_to_path_E0     ; recursively call itself
1312   077B             fs_dir_id_to_path_root:
1313   077B 09            ret
1314   077C             
1315   077C             ;------------------------------------------------------------------------------------------------------;
1316   077C             ; in_puts:
1317   077C             ; A = directory ID
1318   077C             ; out_puts:
1319   077C             ; D = pointer to directory name string
1320   077C             ;------------------------------------------------------------------------------------------------------;
1321   077C             get_dirname_from_dirID:
1322   077C D7            push a
1323   077D D8            push b
1324   077E DA            push d
1325   077F 27            mov b, a
1326   0780 38 00 00      mov c, 0                      ; upper LBA = 0
1327   0783 22 01         mov ah, $01                  ; 1 sector
1328   0785 3B F5 21      mov d, transient_area - 512
1329   0788 07 27 04      call ide_read_sect            ; read directory
1330   078B 07 B9 0F      call _strrev                  ; reverse dir name before copying
1331   078E FD 4E         mov si, d
1332   0790 E7            pop d                         ; destination address = D value pushed at beginning
1333   0791 FD 50         mov di, d
1334   0793 07 33 10      call _strcat                  ; copy filename to D
1335   0796 E5            pop b
1336   0797 E4            pop a
1337   0798 09            ret
1338   0799             
1339   0799             ;------------------------------------------------------------------------------------------------------;
1340   0799             ; in_puts:
1341   0799             ; A = directory ID
1342   0799             ; out_puts:
1343   0799             ; A = parent directory ID
1344   0799             ;------------------------------------------------------------------------------------------------------;
1345   0799             get_parentID_from_dirID:
1346   0799 D8            push b
1347   079A DA            push d
1348   079B 27            mov b, a
1349   079C 38 00 00      mov c, 0                      ; upper LBA = 0
1350   079F 22 01         mov ah, $01                  ; 1 sector
1351   07A1 3B F5 21      mov d, transient_area - 512
1352   07A4 07 27 04      call ide_read_sect            ; read directory
1353   07A7 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1354   07AA E7            pop d
1355   07AB E5            pop b
1356   07AC 09            ret
1357   07AD             
1358   07AD             ;------------------------------------------------------------------------------------------------------;
1359   07AD             ; get dirID from a given path string
1360   07AD             ; in_puts:
1361   07AD             ; D = path pointer 
1362   07AD             ; out_puts:
1363   07AD             ; A = dirID
1364   07AD             ; if dir non existent, A = FFFF (fail code)
1365   07AD             ; /usr/local/bin    - absolute
1366   07AD             ; local/bin/games    - relative
1367   07AD             ;------------------------------------------------------------------------------------------------------;
1368   07AD             fs_path_to_dir_id_user:
1369   07AD FD 4E         mov si, d
1370   07AF FD 4F F5 1B   mov di, user_data
1371   07B3 38 00 02      mov c, 512
1372   07B6 04            load
1373   07B7 07 BB 07      call get_dirID_from_path
1374   07BA 06            sysret
1375   07BB             get_dirID_from_path:
1376   07BB 26 F5 1B      mov b, user_data
1377   07BE FD 42 F2 15   mov [prog], b                  ; token pointer set to path string
1378   07C2 07 53 14      call get_token
1379   07C5 31 F5 15      mov bl, [tok]
1380   07C8 C1 01         cmp bl, TOK_FSLASH
1381   07CA C6 D6 07      je get_dirID_from_path_abs 
1382   07CD 14 07 17      mov a, [current_dir_id]
1383   07D0 07 D9 15      call _putback
1384   07D3 0A D9 07      jmp get_dirID_from_path_E0
1385   07D6             get_dirID_from_path_abs:
1386   07D6 10 20 00      mov a, root_id
1387   07D9             get_dirID_from_path_E0:
1388   07D9 07 53 14      call get_token
1389   07DC 31 F4 15      mov bl, [toktyp]
1390   07DF C1 00         cmp bl, TOKTYP_IDENTIFIER
1391   07E1 C7 32 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1392   07E4             
1393   07E4 FD 4D F6 15   mov si, tokstr
1394   07E8 FD 4F 75 1B   mov di, filename
1395   07EC 07 25 10      call _strcpy        
1396   07EF 77            inc a                         ; metadata sector
1397   07F0 27            mov b, a
1398   07F1 38 00 00      mov c, 0                      ; upper LBA = 0
1399   07F4 22 01         mov ah, $01                  ; 1 sector
1400   07F6 3B F5 23      mov d, transient_area
1401   07F9 07 27 04      call ide_read_sect            ; read directory
1402   07FC FD 10         cla
1403   07FE 42 FF 16      mov [index], a
1404   0801             get_dirID_from_path_L1:
1405   0801 FD 4E         mov si, d
1406   0803 FD 4F 75 1B   mov di, filename
1407   0807 07 10 10      call _strcmp
1408   080A C6 20 08      je get_dirID_from_path_name_equal  
1409   080D 58 20 00      add d, 32
1410   0810 14 FF 16      mov a, [index]
1411   0813 77            inc a
1412   0814 42 FF 16      mov [index], a
1413   0817 AF 10 00      cmp a, FST_FILES_PER_DIR
1414   081A C6 33 08      je get_dirID_from_path_fail
1415   081D 0A 01 08      jmp get_dirID_from_path_L1
1416   0820             get_dirID_from_path_name_equal:
1417   0820 58 19 00      add d, 25           
1418   0823 15            mov a, [d]                    ; set result register A = dirID
1419   0824 07 53 14      call get_token
1420   0827 31 F5 15      mov bl, [tok]
1421   082A C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1422   082C C6 D9 07      je get_dirID_from_path_E0
1423   082F 07 D9 15      call _putback
1424   0832             get_dirID_from_path_end:
1425   0832 09            ret
1426   0833             get_dirID_from_path_fail:
1427   0833 10 FF FF      mov A, $FFFF
1428   0836 09            ret
1429   0837             
1430   0837             
1431   0837             ;------------------------------------------------------------------------------------------------------;
1432   0837             ; check if file exists by a given path string
1433   0837             ; in_puts:
1434   0837             ; D = path pointer 
1435   0837             ; OUTPUTS:
1436   0837             ; A = success code, if file exists gives LBA, else, give 0
1437   0837             ; /usr/local/bin/ed
1438   0837             ;------------------------------------------------------------------------------------------------------;
1439   0837             fs_filepath_exists_user:
1440   0837 FD 4E         mov si, d
1441   0839 FD 4F F5 1B   mov di, user_data
1442   083D 38 00 02      mov c, 512
1443   0840 04            load
1444   0841 07 45 08      call file_exists_by_path
1445   0844 06            sysret
1446   0845             file_exists_by_path:
1447   0845 26 F5 1B      mov b, user_data
1448   0848 FD 42 F2 15   mov [prog], b                   ; token pointer set to path string
1449   084C 07 53 14      call get_token
1450   084F 31 F5 15      mov bl, [tok]
1451   0852 C1 01         cmp bl, TOK_FSLASH
1452   0854 C6 60 08      je  file_exists_by_path_abs
1453   0857 14 07 17      mov a, [current_dir_id]
1454   085A 07 D9 15      call _putback
1455   085D 0A 63 08      jmp file_exists_by_path_E0
1456   0860             file_exists_by_path_abs:
1457   0860 10 20 00      mov a, root_id
1458   0863             file_exists_by_path_E0:
1459   0863 07 53 14      call get_token
1460   0866 31 F4 15      mov bl, [toktyp]
1461   0869 C1 00         cmp bl, TOKTYP_IDENTIFIER
1462   086B C7 C3 08      jne file_exists_by_path_end     ; check if there are tokens after '/'
1463   086E FD 4D F6 15   mov si, tokstr
1464   0872 FD 4F 75 1B   mov di, filename
1465   0876 07 25 10      call _strcpy        
1466   0879 77            inc a                           ; metadata sector
1467   087A 27            mov b, a
1468   087B 38 00 00      mov c, 0                        ; upper LBA = 0
1469   087E 22 01         mov ah, $01                  ; 1 sector
1470   0880 3B F5 23      mov d, transient_area
1471   0883 07 27 04      call ide_read_sect              ; read directory
1472   0886 FD 10         cla
1473   0888 42 FF 16      mov [index], a
1474   088B             file_exists_by_path_L1:
1475   088B FD 4E         mov si, d
1476   088D FD 4F 75 1B   mov di, filename
1477   0891 07 10 10      call _strcmp
1478   0894 C6 AA 08      je   file_exists_by_path_name_equal
1479   0897 58 20 00      add d, 32
1480   089A 14 FF 16      mov a, [index]
1481   089D 77            inc a
1482   089E 42 FF 16      mov [index], a
1483   08A1 AF 10 00      cmp a, FST_FILES_PER_DIR
1484   08A4 C6 C3 08      je file_exists_by_path_end
1485   08A7 0A 8B 08      jmp file_exists_by_path_L1
1486   08AA             file_exists_by_path_name_equal:
1487   08AA 33 18 00      mov bl, [d + 24]
1488   08AD FD 87 38      and bl, %00111000               ; directory flag
1489   08B0 C1 08         cmp bl, %00001000               ; is dir?
1490   08B2 C6 B9 08      je file_exists_by_path_isdir;
1491   08B5             ; entry is a file
1492   08B5 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1493   08B8 09            ret
1494   08B9             file_exists_by_path_isdir:
1495   08B9 58 19 00      add d, 25           
1496   08BC 15            mov a, [d]                      ; set result register A = dirID
1497   08BD 07 53 14      call get_token
1498   08C0 0A 63 08      jmp file_exists_by_path_E0
1499   08C3             file_exists_by_path_end:
1500   08C3 10 00 00      mov a, 0                        ; return 0 because file was not found
1501   08C6 09            ret
1502   08C7             
1503   08C7             ;------------------------------------------------------------------------------------------------------;
1504   08C7             ; load file data from a given path string
1505   08C7             ; inputs:
1506   08C7             ; D = path pointer 
1507   08C7             ; DI = userspace program data destination
1508   08C7             ; /usr/local/bin/ed
1509   08C7             ; ./ed
1510   08C7             ;------------------------------------------------------------------------------------------------------;
1511   08C7             fs_load_from_path_user:
1512   08C7 E3            push di
1513   08C8 FD 4E         mov si, d
1514   08CA FD 4F F5 1B   mov di, user_data
1515   08CE 38 00 02      mov c, 512
1516   08D1 04            load
1517   08D2 07 DF 08      call loadfile_from_path
1518   08D5 F0            pop di
1519   08D6 FD 4D F5 23   mov si, transient_area
1520   08DA 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1521   08DD 03            store
1522   08DE 06            sysret
1523   08DF             loadfile_from_path:
1524   08DF 26 F5 1B      mov b, user_data
1525   08E2 FD 42 F2 15   mov [prog], b                 ; token pointer set to path string
1526   08E6 07 53 14      call get_token
1527   08E9 31 F5 15      mov bl, [tok]
1528   08EC C1 01         cmp bl, TOK_FSLASH
1529   08EE C6 FA 08      je loadfile_from_path_abs 
1530   08F1 14 07 17      mov a, [current_dir_id]
1531   08F4 07 D9 15      call _putback
1532   08F7 0A FD 08      jmp loadfile_from_path_E0
1533   08FA             loadfile_from_path_abs:
1534   08FA 10 20 00      mov a, root_id
1535   08FD             loadfile_from_path_E0:
1536   08FD 07 53 14      call get_token
1537   0900 31 F4 15      mov bl, [toktyp]
1538   0903 C1 00         cmp bl, TOKTYP_IDENTIFIER
1539   0905 C7 6A 09      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1540   0908 FD 4D F6 15   mov si, tokstr
1541   090C FD 4F 75 1B   mov di, filename
1542   0910 07 25 10      call _strcpy        
1543   0913 77            inc a                         ; metadata sector
1544   0914 27            mov b, a
1545   0915 38 00 00      mov c, 0                      ; upper LBA = 0
1546   0918 22 01         mov ah, $01                  ; 1 sector
1547   091A 3B F5 23      mov d, transient_area
1548   091D 07 27 04      call ide_read_sect            ; read directory
1549   0920 FD 10         cla
1550   0922 42 FF 16      mov [index], a
1551   0925             loadfile_from_path_L1:
1552   0925 FD 4E         mov si, d
1553   0927 FD 4F 75 1B   mov di, filename
1554   092B 07 10 10      call _strcmp
1555   092E C6 44 09      je loadfile_from_path_name_equal  
1556   0931 58 20 00      add d, 32
1557   0934 14 FF 16      mov a, [index]
1558   0937 77            inc a
1559   0938 42 FF 16      mov [index], a
1560   093B AF 10 00      cmp a, FST_FILES_PER_DIR
1561   093E C6 6A 09      je loadfile_from_path_end
1562   0941 0A 25 09      jmp loadfile_from_path_L1
1563   0944             loadfile_from_path_name_equal:
1564   0944 33 18 00      mov bl, [d + 24]
1565   0947 FD 87 38      and bl, %00111000             ; directory flag
1566   094A C1 08         cmp bl, %00001000             ; is dir?
1567   094C C6 60 09      je loadfile_isdirectory  
1568   094F             ; entry is a file
1569   094F 2B 19 00      mov b, [d + 25]               ; get LBA
1570   0952 FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1571   0954 3B F5 23      mov d, transient_area
1572   0957 38 00 00      mov c, 0
1573   095A 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1574   095C 07 27 04      call ide_read_sect            ; read sector
1575   095F 09            ret
1576   0960             loadfile_isdirectory:
1577   0960 58 19 00      add d, 25           
1578   0963 15            mov a, [d]                    ; set result register A = dirID
1579   0964 07 53 14      call get_token
1580   0967 0A FD 08      jmp loadfile_from_path_E0
1581   096A             loadfile_from_path_end:
1582   096A 09            ret
1583   096B             
1584   096B             ;------------------------------------------------------------------------------------------------------;
1585   096B             ; return the ID of the current directory
1586   096B             ; ID returned in B
1587   096B             ;------------------------------------------------------------------------------------------------------;
1588   096B             fs_get_curr_dirID:
1589   096B 29 07 17      mov b, [current_dir_id]
1590   096E 06            sysret
1591   096F             
1592   096F             ;------------------------------------------------------------------------------------------------------;
1593   096F             ; CD
1594   096F             ;------------------------------------------------------------------------------------------------------;
1595   096F             ; new dirID in B
1596   096F             fs_cd:
1597   096F FD 42 07 17   mov [current_dir_id], b
1598   0973 06            sysret  
1599   0974             
1600   0974             ;------------------------------------------------------------------------------------------------------;
1601   0974             ; LS
1602   0974             ; dirID in B
1603   0974             ;------------------------------------------------------------------------------------------------------;
1604   0974 00 00       ls_count:       .dw 0
1605   0976             fs_ls:
1606   0976 FD 77         inc b                        ; metadata sector
1607   0978 38 00 00      mov c, 0                     ; upper LBA = 0
1608   097B 22 01         mov ah, $01                  ; 1 sector
1609   097D 3B F5 23      mov d, transient_area
1610   0980 07 27 04      call ide_read_sect           ; read directory
1611   0983 FD 10         cla
1612   0985 42 FF 16      mov [index], a               ; reset entry index
1613   0988 3D 74 09      mov [ls_count], al           ; reset item count
1614   098B             fs_ls_L1:
1615   098B BD 00         cmp byte [d], 0              ; check for NULL
1616   098D C6 24 0A      je fs_ls_next
1617   0990             fs_ls_non_null:
1618   0990 1D 74 09      mov al, [ls_count]
1619   0993 7A            inc al
1620   0994 3D 74 09      mov [ls_count], al           ; increment item count
1621   0997 1F 18 00      mov al, [d + 24]
1622   099A 87 38         and al, %00111000
1623   099C FD A2 03      shr al, 3
1624   099F 22 00         mov ah, 0                    ; file type
1625   09A1 B7 23 17      mov a, [a + file_type]      
1626   09A4 23            mov ah, al
1627   09A5 07 A1 10      call _putchar
1628   09A8 1F 18 00      mov al, [d + 24]
1629   09AB 87 01         and al, %00000001
1630   09AD 22 00         mov ah, 0
1631   09AF B7 1E 17      mov a, [a + file_attrib]     ; read
1632   09B2 23            mov ah, al
1633   09B3 07 A1 10      call _putchar
1634   09B6 1F 18 00      mov al, [d + 24]
1635   09B9 87 02         and al, %00000010
1636   09BB 22 00         mov ah, 0
1637   09BD B7 1E 17      mov a, [a + file_attrib]     ; write
1638   09C0 23            mov ah, al
1639   09C1 07 A1 10      call _putchar
1640   09C4 1F 18 00      mov al, [d + 24]
1641   09C7 87 04         and al, %00000100
1642   09C9 22 00         mov ah, 0
1643   09CB B7 1E 17      mov a, [a + file_attrib]     ; execute
1644   09CE 23            mov ah, al
1645   09CF 07 A1 10      call _putchar
1646   09D2 22 20         mov ah, $20
1647   09D4 07 A1 10      call _putchar  
1648   09D7 2B 1B 00      mov b, [d + 27]
1649   09DA 07 29 12      call print_u16x              ; filesize
1650   09DD 22 20         mov ah, $20
1651   09DF 07 A1 10      call _putchar  
1652   09E2 2B 19 00      mov b, [d + 25]
1653   09E5 07 29 12      call print_u16x              ; dirID / LBA
1654   09E8 22 20         mov ah, $20
1655   09EA 07 A1 10      call _putchar
1656   09ED             ; print date
1657   09ED 33 1D 00      mov bl, [d + 29]             ; day
1658   09F0 07 6D 12      call print_u8x
1659   09F3 22 20         mov ah, $20
1660   09F5 07 A1 10      call _putchar  
1661   09F8 1F 1E 00      mov al, [d + 30]             ; month
1662   09FB FD 9E 02      shl al, 2
1663   09FE DA            push d
1664   09FF 3B D5 17      mov d, s_months
1665   0A02 22 00         mov ah, 0
1666   0A04 59            add d, a
1667   0A05 07 CD 11      call _puts
1668   0A08 E7            pop d
1669   0A09 22 20         mov ah, $20
1670   0A0B 07 A1 10      call _putchar
1671   0A0E 2E 20         mov bl, $20
1672   0A10 07 6D 12      call print_u8x
1673   0A13 33 1F 00      mov bl, [d + 31]             ; year
1674   0A16 07 6D 12      call print_u8x  
1675   0A19 22 20         mov ah, $20
1676   0A1B 07 A1 10      call _putchar  
1677   0A1E 07 CD 11      call _puts                   ; print filename  
1678   0A21 07 7A 11      call printnl
1679   0A24             fs_ls_next:
1680   0A24 14 FF 16      mov a, [index]
1681   0A27 77            inc a
1682   0A28 42 FF 16      mov [index], a
1683   0A2B AF 10 00      cmp a, FST_FILES_PER_DIR
1684   0A2E C6 37 0A      je fs_ls_end
1685   0A31 58 20 00      add d, 32      
1686   0A34 0A 8B 09      jmp fs_ls_L1  
1687   0A37             fs_ls_end:
1688   0A37 3B 33 17      mov d, s_ls_total
1689   0A3A 07 CD 11      call _puts
1690   0A3D 1D 74 09      mov al, [ls_count]
1691   0A40 07 7F 12      call print_u8d
1692   0A43 07 7A 11      call printnl
1693   0A46 06            sysret
1694   0A47             
1695   0A47             
1696   0A47             ; file structure:
1697   0A47             ; 512 bytes header
1698   0A47             ; header used to tell whether the block is free
1699   0A47             ;------------------------------------------------------------------------------------------------------;
1700   0A47             ; CREATE NEW TEXTFILE
1701   0A47             ;------------------------------------------------------------------------------------------------------;
1702   0A47             ; d = content pointer in user space
1703   0A47             ; c = file size
1704   0A47             fs_starcom:
1705   0A47 FD 4E       	mov si, d
1706   0A49 FD 4F F5 23 	mov di, transient_area
1707   0A4D 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1708   0A50 04          	load					; load data from user-space
1709   0A51 07 D2 0A    	call fs_find_empty_block	; look for empty data blocks
1710   0A54 D8          	push b				; save empty block LBA
1711   0A55 FD 79         mov g, b
1712   0A57             ;create header file by grabbing file name from parameter	
1713   0A57 3B F5 25    	mov d, transient_area + 512			; pointer to file contents
1714   0A5A D9          	push c							; save length
1715   0A5B 19 01       	mov al, 1
1716   0A5D 3D F5 23    	mov [transient_area], al					; mark sectors as USED (not NULL)
1717   0A60 3B F5 23    	mov d, transient_area
1718   0A63 12            mov a, c
1719   0A64 26 00 02      mov b, 512
1720   0A67 AE            div a, b
1721   0A68 FD 77         inc b         ; inc b as the division will most likely have a remainder
1722   0A6A 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1723   0A6B 38 00 00    	mov c, 0      ; lba 
1724   0A6E FD 27         mov b, g      ; lba 
1725   0A70 07 4D 04    	call ide_write_sect			; write sectors
1726   0A73             ; now we add the file to the current directory!
1727   0A73             fs_starcom_add_to_dir:	
1728   0A73 14 07 17    	mov a, [current_dir_id]
1729   0A76 77          	inc a
1730   0A77 27          	mov b, a					; metadata sector
1731   0A78 38 00 00    	mov c, 0
1732   0A7B FD 79       	mov g, b					; save LBA
1733   0A7D 3B F5 21    	mov d, scrap_sector
1734   0A80 22 01       	mov ah, $01			  ; 1 sector
1735   0A82 07 27 04    	call ide_read_sect		; read metadata sector
1736   0A85             fs_starcom_add_to_dir_L2:
1737   0A85 BD 00       	cmp byte[d], 0
1738   0A87 C6 90 0A    	je fs_starcom_add_to_dir_null
1739   0A8A 58 20 00    	add d, FST_ENTRY_SIZE
1740   0A8D 0A 85 0A    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1741   0A90             fs_starcom_add_to_dir_null:
1742   0A90 FD 4D F6 23 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1743   0A94 FD 50       	mov di, d
1744   0A96 07 25 10    	call _strcpy			; copy file name
1745   0A99 58 18 00    	add d, 24			; skip name
1746   0A9C 19 07       	mov al, %00000111	; type=file, execute, write, read
1747   0A9E 3E          	mov [d], al			
1748   0A9F 58 03 00    	add d, 3
1749   0AA2 E4          	pop a
1750   0AA3 5F 00 02      sub a, 512
1751   0AA6 43          	mov [d], a ; file size
1752   0AA7 63 02 00    	sub d, 2
1753   0AAA E5          	pop b				; get file LBA
1754   0AAB FD 43       	mov [d], b			; save LBA	
1755   0AAD             ; set file creation date	
1756   0AAD 58 04 00    	add d, 4
1757   0AB0 19 04       	mov al, 4
1758   0AB2 05 01       	syscall sys_rtc
1759   0AB4 1A          	mov al, ah
1760   0AB5 3E          	mov [d], al			; set day
1761   0AB6 79          	inc d
1762   0AB7 19 05       	mov al, 5
1763   0AB9 05 01       	syscall sys_rtc
1764   0ABB 1A          	mov al, ah
1765   0ABC 3E          	mov [d], al			; set month
1766   0ABD 79          	inc d
1767   0ABE 19 06       	mov al, 6
1768   0AC0 05 01       	syscall sys_rtc
1769   0AC2 1A          	mov al, ah
1770   0AC3 3E          	mov [d], al			; set year
1771   0AC4             ; write sector into disk for new directory entry
1772   0AC4 FD 27       	mov b, g
1773   0AC6 38 00 00    	mov c, 0
1774   0AC9 3B F5 21    	mov d, scrap_sector
1775   0ACC 22 01       	mov ah, $01			; disk write, 1 sector
1776   0ACE 07 4D 04    	call ide_write_sect		; write sector
1777   0AD1 06          	sysret
1778   0AD2             
1779   0AD2             ;------------------------------------------------------------------------------------------------------;
1780   0AD2             ; finds an empty data block
1781   0AD2             ; block LBA returned in B
1782   0AD2             ;------------------------------------------------------------------------------------------------------;
1783   0AD2             fs_find_empty_block:
1784   0AD2 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1785   0AD5 38 00 00      mov c, 0                ; upper LBA = 0
1786   0AD8             fs_find_empty_block_L1:  
1787   0AD8 22 01         mov ah, $01                  ; 1 sector
1788   0ADA 3B F5 21      mov d, transient_area - 512
1789   0ADD 07 27 04      call ide_read_sect      ; read sector
1790   0AE0 BD 00         cmp byte [d], 0
1791   0AE2 C6 EB 0A      je fs_find_empty_block_found_null
1792   0AE5 55 20 00      add b, FS_SECTORS_PER_FILE
1793   0AE8 0A D8 0A      jmp fs_find_empty_block_L1
1794   0AEB             fs_find_empty_block_found_null:
1795   0AEB 09            ret
1796   0AEC             
1797   0AEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1798   0AEC             ;; CREATE NEW TEXTFILE
1799   0AEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1800   0AEC             ; search for first null block
1801   0AEC             fs_mktxt:
1802   0AEC FD 4E       	mov si, d
1803   0AEE FD 4F F5 1B 	mov di, user_data
1804   0AF2 38 00 01    	mov c, 256
1805   0AF5 04          	load					; load data from user-space
1806   0AF6             	
1807   0AF6 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1808   0AF9 38 00 00    	mov c, 0						; reset LBA to 0
1809   0AFC             fs_mktxt_L1:	
1810   0AFC 10 02 01    	mov a, $0102			; disk read
1811   0AFF 3B F5 23    	mov d, transient_area
1812   0B02 05 02       	syscall sys_ide ; read sector
1813   0B04 1E          	mov al, [d]
1814   0B05 B9 00       	cmp al, 0			; check for NULL
1815   0B07 C6 10 0B    	je fs_mktxt_found_null
1816   0B0A 55 20 00    	add b, FS_SECTORS_PER_FILE
1817   0B0D 0A FC 0A    	jmp fs_mktxt_L1
1818   0B10             fs_mktxt_found_null:
1819   0B10 D8          	push b				; save LBA
1820   0B11             ;create header file by grabbing file name from parameter	
1821   0B11 3B 14 17    	mov d, s_dataentry
1822   0B14 07 CD 11    	call _puts
1823   0B17 3B F5 25    	mov d, transient_area + 512			; pointer to file contents
1824   0B1A 07 A8 10    	call _gets
1825   0B1D 07 00 10    	call _strlen						; get length of file
1826   0B20 D9          	push c							; save length
1827   0B21 19 01       	mov al, 1
1828   0B23 3D F5 23    	mov [transient_area], al					; mark sectors as USED (not NULL)
1829   0B26 10 00 00    	mov a, 0
1830   0B29 42 FF 16    	mov [index], a
1831   0B2C 3B F5 23    	mov d, transient_area
1832   0B2F 13          	mov a, d
1833   0B30 42 01 17    	mov [buffer_addr], a
1834   0B33             fs_mktxt_L2:
1835   0B33 38 00 00    	mov c, 0
1836   0B36 10 03 01    	mov a, $0103			; disk write, 1 sector
1837   0B39 05 02       	syscall sys_ide		; write sector
1838   0B3B 14 FF 16    	mov a, [index]
1839   0B3E 77          	inc a
1840   0B3F 42 FF 16    	mov [index], a
1841   0B42 AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1842   0B45 C6 57 0B    	je fs_mktxt_add_to_dir
1843   0B48 FD 77       	inc b
1844   0B4A 14 01 17    	mov a, [buffer_addr]
1845   0B4D 53 00 02    	add a, 512
1846   0B50 42 01 17    	mov [buffer_addr], a
1847   0B53 3C          	mov d, a
1848   0B54 0A 33 0B    	jmp fs_mktxt_L2
1849   0B57             ; now we add the file to the current directory!
1850   0B57             fs_mktxt_add_to_dir:	
1851   0B57 14 07 17    	mov a, [current_dir_id]
1852   0B5A 77          	inc a
1853   0B5B 27          	mov b, a					; metadata sector
1854   0B5C 38 00 00    	mov c, 0
1855   0B5F FD 79       	mov g, b					; save LBA
1856   0B61 3B F5 23    	mov d, transient_area
1857   0B64 10 02 01    	mov a, $0102			; disk read
1858   0B67 05 02       	syscall sys_ide		; read metadata sector
1859   0B69             fs_mktxt_add_to_dir_L2:
1860   0B69 1E          	mov al, [d]
1861   0B6A B9 00       	cmp al, 0
1862   0B6C C6 75 0B    	je fs_mktxt_add_to_dir_null
1863   0B6F 58 20 00    	add d, FST_ENTRY_SIZE
1864   0B72 0A 69 0B    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1865   0B75             fs_mktxt_add_to_dir_null:
1866   0B75 FD 4D F5 1B 	mov si, user_data
1867   0B79 FD 50       	mov di, d
1868   0B7B 07 25 10    	call _strcpy			; copy file name
1869   0B7E 58 18 00    	add d, 24			; skip name
1870   0B81 19 06       	mov al, %00000110		; no execute, write, read, not directory
1871   0B83 3E          	mov [d], al			
1872   0B84 58 03 00    	add d, 3
1873   0B87 E4          	pop a
1874   0B88 43          	mov [d], a
1875   0B89 63 02 00    	sub d, 2
1876   0B8C E5          	pop b				; get file LBA
1877   0B8D FD 43       	mov [d], b			; save LBA	
1878   0B8F             	
1879   0B8F             	; set file creation date	
1880   0B8F 58 04 00    	add d, 4
1881   0B92 19 04       	mov al, 4
1882   0B94 05 01       	syscall sys_rtc
1883   0B96 1A          	mov al, ah
1884   0B97 3E          	mov [d], al			; set day
1885   0B98             	
1886   0B98 79          	inc d
1887   0B99 19 05       	mov al, 5
1888   0B9B 05 01       	syscall sys_rtc
1889   0B9D 1A          	mov al, ah
1890   0B9E 3E          	mov [d], al			; set month
1891   0B9F             	
1892   0B9F 79          	inc d
1893   0BA0 19 06       	mov al, 6
1894   0BA2 05 01       	syscall sys_rtc
1895   0BA4 1A          	mov al, ah
1896   0BA5 3E          	mov [d], al			; set year
1897   0BA6             	
1898   0BA6             ; write sector into disk for new directory entry
1899   0BA6 FD 27       	mov b, g
1900   0BA8 38 00 00    	mov c, 0
1901   0BAB 3B F5 23    	mov d, transient_area
1902   0BAE 10 03 01    	mov a, $0103			; disk write, 1 sector
1903   0BB1 05 02       	syscall sys_ide		; write sector
1904   0BB3 07 7A 11    	call printnl
1905   0BB6 06          	sysret
1906   0BB7             
1907   0BB7             
1908   0BB7             
1909   0BB7             ;------------------------------------------------------------------------------------------------------;
1910   0BB7             ; CREATE NEW BINARY FILE
1911   0BB7             ;------------------------------------------------------------------------------------------------------;
1912   0BB7             ; search for first null block
1913   0BB7             fs_mkbin:
1914   0BB7 19 00         mov al, 0
1915   0BB9 3D F7 16      mov [sys_echo_on], al ; disable echo
1916   0BBC FD 4E         mov si, d
1917   0BBE FD 4F F5 1B   mov di, user_data
1918   0BC2 38 00 02      mov c, 512
1919   0BC5 04            load                          ; load data from user-space
1920   0BC6 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
1921   0BC9 38 00 00      mov c, 0                      ; upper LBA = 0
1922   0BCC             fs_mkbin_L1:  
1923   0BCC 22 01         mov ah, $01                  ; 1 sector
1924   0BCE 3B F5 23      mov d, transient_area
1925   0BD1 07 27 04      call ide_read_sect            ; read sector
1926   0BD4 BD 00         cmp byte[d], 0                ; check for NULL
1927   0BD6 C6 DF 0B      je fs_mkbin_found_null
1928   0BD9 55 20 00      add b, FS_SECTORS_PER_FILE
1929   0BDC 0A CC 0B      jmp fs_mkbin_L1
1930   0BDF             fs_mkbin_found_null:
1931   0BDF D8            push b                        ; save LBA
1932   0BE0             ;create header file by grabbing file name from parameter
1933   0BE0 FD 4F F5 25   mov di, transient_area + 512  ; pointer to file contents
1934   0BE4 07 90 0F      call _load_hex                ; load binary hex
1935   0BE7 D9            push c                        ; save size (nbr of bytes)
1936   0BE8 19 01         mov al, 1
1937   0BEA 3D F5 23      mov [transient_area], al      ; mark sectors as USED (not NULL)
1938   0BED FD 10         cla
1939   0BEF 42 FF 16      mov [index], a
1940   0BF2 3B F5 23      mov d, transient_area
1941   0BF5 13            mov a, d
1942   0BF6 42 01 17      mov [buffer_addr], a
1943   0BF9             fs_mkbin_L2:
1944   0BF9 38 00 00      mov c, 0
1945   0BFC 22 01         mov ah, $01                   ; disk write, 1 sector
1946   0BFE 07 4D 04      call ide_write_sect           ; write sector
1947   0C01 14 FF 16      mov a, [index]
1948   0C04 77            inc a
1949   0C05 42 FF 16      mov [index], a
1950   0C08 AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
1951   0C0B C6 1D 0C      je fs_mkbin_add_to_dir
1952   0C0E FD 77         inc b
1953   0C10 14 01 17      mov a, [buffer_addr]
1954   0C13 53 00 02      add a, 512
1955   0C16 42 01 17      mov [buffer_addr], a
1956   0C19 3C            mov d, a
1957   0C1A 0A F9 0B      jmp fs_mkbin_L2
1958   0C1D             ; now we add the file to the current directory!
1959   0C1D             fs_mkbin_add_to_dir:  
1960   0C1D 14 07 17      mov a, [current_dir_id]
1961   0C20 77            inc a
1962   0C21 27            mov b, a                      ; metadata sector
1963   0C22 38 00 00      mov c, 0
1964   0C25 FD 79         mov g, b                      ; save LBA
1965   0C27 3B F5 23      mov d, transient_area
1966   0C2A 22 01         mov ah, $01                  ; 1 sector
1967   0C2C 07 27 04      call ide_read_sect            ; read metadata sector
1968   0C2F             fs_mkbin_add_to_dir_L2:
1969   0C2F BD 00         cmp byte[d], 0
1970   0C31 C6 3A 0C      je fs_mkbin_add_to_dir_null
1971   0C34 58 20 00      add d, FST_ENTRY_SIZE
1972   0C37 0A 2F 0C      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1973   0C3A             fs_mkbin_add_to_dir_null:
1974   0C3A FD 4D F5 1B   mov si, user_data
1975   0C3E FD 50         mov di, d
1976   0C40 07 25 10      call _strcpy                  ; copy file name
1977   0C43 58 18 00      add d, 24                     ; skip name
1978   0C46 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
1979   0C48 3E            mov [d], al
1980   0C49 58 03 00      add d, 3
1981   0C4C E4            pop a
1982   0C4D 43            mov [d], a
1983   0C4E 63 02 00      sub d, 2
1984   0C51 E5            pop b                         ; get file LBA
1985   0C52 FD 43         mov [d], b                    ; save LBA
1986   0C54               ; set file creation date  
1987   0C54 58 04 00      add d, 4
1988   0C57 19 04         mov al, 4
1989   0C59 05 01         syscall sys_rtc
1990   0C5B 1A            mov al, ah
1991   0C5C 3E            mov [d], al                   ; set day
1992   0C5D 79            inc d
1993   0C5E 19 05         mov al, 5
1994   0C60 05 01         syscall sys_rtc
1995   0C62 1A            mov al, ah
1996   0C63 3E            mov [d], al                   ; set month
1997   0C64 79            inc d
1998   0C65 19 06         mov al, 6
1999   0C67 05 01         syscall sys_rtc
2000   0C69 1A            mov al, ah
2001   0C6A 3E            mov [d], al                   ; set year
2002   0C6B             ; write sector into disk for new directory entry
2003   0C6B FD 27         mov b, g
2004   0C6D 38 00 00      mov c, 0
2005   0C70 3B F5 23      mov d, transient_area
2006   0C73 22 01         mov ah, $01                   ; disk write, 1 sector
2007   0C75 07 4D 04      call ide_write_sect           ; write sector
2008   0C78 19 01         mov al, 1
2009   0C7A 3D F7 16      mov [sys_echo_on], al ; enable echo
2010   0C7D 06            sysret
2011   0C7E             
2012   0C7E             ;------------------------------------------------------------------------------------------------------;
2013   0C7E             ; PWD - PRINT WORKING DIRECTORY
2014   0C7E             ;------------------------------------------------------------------------------------------------------;    
2015   0C7E             fs_pwd:
2016   0C7E 3B 75 1B      mov d, filename
2017   0C81 19 00         mov al, 0
2018   0C83 3E            mov [d], al                   ; initialize path string 
2019   0C84 14 07 17      mov a, [current_dir_id]
2020   0C87 07 5D 07      call fs_dir_id_to_path_E0
2021   0C8A 3B 75 1B      mov d, filename
2022   0C8D 07 B9 0F      call _strrev
2023   0C90 07 CD 11      call _puts
2024   0C93 07 7A 11      call printnl
2025   0C96 06            sysret
2026   0C97             
2027   0C97             ;------------------------------------------------------------------------------------------------------;
2028   0C97             ; get current directory LBA
2029   0C97             ; A: returned LBA
2030   0C97             ;------------------------------------------------------------------------------------------------------;
2031   0C97             cmd_get_curr_dir_LBA:
2032   0C97 14 07 17      mov a, [current_dir_id]
2033   0C9A 06            sysret
2034   0C9B             
2035   0C9B             ;------------------------------------------------------------------------------------------------------;
2036   0C9B             ; CAT
2037   0C9B             ; userspace destination data pointer in D
2038   0C9B             ; filename starts at D, but is overwritten after the read is made
2039   0C9B             ;------------------------------------------------------------------------------------------------------;:
2040   0C9B             fs_cat:
2041   0C9B DA            push d                              ; save userspace file data destination
2042   0C9C FD 4E         mov si, d
2043   0C9E FD 4F F5 1B   mov di, user_data
2044   0CA2 38 00 02      mov c, 512
2045   0CA5 04            load                                ; copy filename from user-space
2046   0CA6 29 07 17      mov b, [current_dir_id]
2047   0CA9 FD 77         inc b                               ; metadata sector
2048   0CAB 38 00 00      mov c, 0                            ; upper LBA = 0
2049   0CAE 22 01         mov ah, $01                  ; 1 sector
2050   0CB0 3B F5 21      mov d, transient_area-512
2051   0CB3 07 27 04      call ide_read_sect                  ; read directory
2052   0CB6 FD 10         cla
2053   0CB8 42 FF 16      mov [index], a                      ; reset file counter
2054   0CBB             fs_cat_L1:
2055   0CBB FD 4E         mov si, d
2056   0CBD FD 4F F5 1B   mov di, user_data
2057   0CC1 07 10 10      call _strcmp
2058   0CC4 C6 DA 0C      je fs_cat_found_entry
2059   0CC7 58 20 00      add d, 32
2060   0CCA 14 FF 16      mov a, [index]
2061   0CCD 77            inc a
2062   0CCE 42 FF 16      mov [index], a
2063   0CD1 AF 10 00      cmp a, FST_FILES_PER_DIR
2064   0CD4 C6 F5 0C      je fs_cat_not_found
2065   0CD7 0A BB 0C      jmp fs_cat_L1
2066   0CDA             fs_cat_found_entry:
2067   0CDA 58 19 00      add d, 25                           ; get to dirID of file in disk
2068   0CDD 2A            mov b, [d]                          ; get LBA
2069   0CDE FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2070   0CE0 3B F5 23      mov d, transient_area  
2071   0CE3 38 00 00      mov c, 0
2072   0CE6 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2073   0CE8 07 27 04      call ide_read_sect                  ; read sectors
2074   0CEB F0            pop di                              ; write userspace file data destination to DI
2075   0CEC FD 4D F5 23   mov si, transient_area              ; data origin
2076   0CF0 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2077   0CF3 03            store
2078   0CF4 06            sysret
2079   0CF5             fs_cat_not_found:
2080   0CF5 E7            pop d
2081   0CF6 06            sysret
2082   0CF7             
2083   0CF7             ;------------------------------------------------------------------------------------------------------;
2084   0CF7             ; RMDIR - remove DIR by dirID
2085   0CF7             ;------------------------------------------------------------------------------------------------------;
2086   0CF7             ; deletes a directory entry in the given directory's file list 
2087   0CF7             ; also deletes the actual directory entry in the FST
2088   0CF7             ; synopsis: rmdir /usr/local/testdir
2089   0CF7             ; B = dirID
2090   0CF7             fs_rmdir:
2091   0CF7 FD 79         mov g, b
2092   0CF9 11            mov a, b
2093   0CFA 07 99 07      call get_parentID_from_dirID  ; now get the directory's parent, in A
2094   0CFD D7            push a                        ; save dirID
2095   0CFE             ; search for directory's entry in the parent's directory then and delete it
2096   0CFE 77            inc a                         ; metadata sector
2097   0CFF 27            mov b, a
2098   0D00 38 00 00      mov c, 0                      ; upper LBA = 0
2099   0D03 22 01         mov ah, $01          ;
2100   0D05 3B F5 23      mov d, transient_area
2101   0D08 07 27 04      call ide_read_sect            ; read directory
2102   0D0B FD 10         cla
2103   0D0D 42 FF 16      mov [index], a                ; reset file counter
2104   0D10 FD 27         mov b, g                      ; retrieve directory's dirID
2105   0D12             fs_rmdir_L1:
2106   0D12 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2107   0D15 B0            cmp a, b                      ; compare dirID's to find the directory
2108   0D16 C6 2C 0D      je fs_rmdir_found_entry
2109   0D19 58 20 00      add d, 32
2110   0D1C 14 FF 16      mov a, [index]
2111   0D1F 77            inc a
2112   0D20 42 FF 16      mov [index], a
2113   0D23 AF 10 00      cmp a, FST_FILES_PER_DIR
2114   0D26 C6 51 0D      je fs_rmdir_not_found
2115   0D29 0A 12 0D      jmp fs_rmdir_L1
2116   0D2C             fs_rmdir_found_entry:
2117   0D2C FD 10         cla
2118   0D2E 3E            mov [d], al                   ; make filename NULL
2119   0D2F 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2120   0D32 E5            pop b
2121   0D33 FD 77         inc b                         ; metadata sector
2122   0D35 38 00 00      mov c, 0                      ; upper LBA = 0
2123   0D38 22 01         mov ah, $01          ; 
2124   0D3A 3B F5 23      mov d, transient_area
2125   0D3D 07 4D 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2126   0D40             
2127   0D40 FD 27         mov b, g
2128   0D42 3B F5 23      mov d, transient_area  
2129   0D45 FD 10         cla
2130   0D47 3E            mov [d], al                   ; make directory's name header NULL for re-use
2131   0D48 38 00 00      mov c, 0
2132   0D4B 22 01         mov ah, $01                   ; disk write 1 sect
2133   0D4D 07 4D 04      call ide_write_sect           ; delete directory given by dirID in B
2134   0D50 06            sysret
2135   0D51             fs_rmdir_not_found:
2136   0D51 E5            pop b
2137   0D52 06            sysret
2138   0D53             
2139   0D53             ;------------------------------------------------------------------------------------------------------;
2140   0D53             ; RM - remove file
2141   0D53             ;------------------------------------------------------------------------------------------------------;
2142   0D53             ; frees up the data sectors for the file further down the disk
2143   0D53             ; deletes file entry in the directory's file list 
2144   0D53             fs_rm:
2145   0D53 FD 4E         mov si, d
2146   0D55 FD 4F F5 1B   mov di, user_data
2147   0D59 38 00 02      mov c, 512
2148   0D5C 04            load                          ; load data from user-space
2149   0D5D 14 07 17      mov a, [current_dir_id]
2150   0D60 77            inc a                         ; metadata sector
2151   0D61 27            mov b, a
2152   0D62 38 00 00      mov c, 0                      ; upper LBA = 0
2153   0D65 22 01         mov ah, $01                  ; 1 sector
2154   0D67 3B F5 23      mov d, transient_area
2155   0D6A 07 27 04      call ide_read_sect            ; read directory
2156   0D6D 10 00 00      mov a, 0
2157   0D70 42 FF 16      mov [index], a                ; reset file counter
2158   0D73             fs_rm_L1:
2159   0D73 FD 4E         mov si, d
2160   0D75 FD 4F F5 1B   mov di, user_data
2161   0D79 07 10 10      call _strcmp
2162   0D7C C6 92 0D      je fs_rm_found_entry
2163   0D7F 58 20 00      add d, 32
2164   0D82 14 FF 16      mov a, [index]
2165   0D85 77            inc a
2166   0D86 42 FF 16      mov [index], a
2167   0D89 AF 10 00      cmp a, FST_FILES_PER_DIR
2168   0D8C C6 BA 0D      je fs_rm_not_found
2169   0D8F 0A 73 0D      jmp fs_rm_L1
2170   0D92             fs_rm_found_entry:
2171   0D92 2B 19 00      mov b, [d + 25]               ; get LBA
2172   0D95 FD 79         mov g, b                      ; save LBA
2173   0D97 19 00         mov al, 0
2174   0D99 3E            mov [d], al                   ; make file entry NULL
2175   0D9A 14 07 17      mov a, [current_dir_id]
2176   0D9D 77            inc a                         ; metadata sector
2177   0D9E 27            mov b, a
2178   0D9F 38 00 00      mov c, 0                      ; upper LBA = 0
2179   0DA2 22 01         mov ah, $01                   ; disk write
2180   0DA4 3B F5 23      mov d, transient_area
2181   0DA7 07 4D 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2182   0DAA 3B F5 23      mov d, transient_area  
2183   0DAD 19 00         mov al, 0
2184   0DAF 3E            mov [d], al                   ; make file's data header NULL for re-use
2185   0DB0 38 00 00      mov c, 0
2186   0DB3 FD 27         mov b, g                      ; get data header LBA
2187   0DB5 22 01         mov ah, $01                   ; disk write 1 sect
2188   0DB7 07 4D 04      call ide_write_sect           ; write sector
2189   0DBA             fs_rm_not_found:  
2190   0DBA 06            sysret  
2191   0DBB             
2192   0DBB             ;------------------------------------------------------------------------------------------------------;
2193   0DBB             ; mv - move / change file name
2194   0DBB             ;------------------------------------------------------------------------------------------------------;
2195   0DBB             fs_mv:
2196   0DBB FD 4E         mov si, d
2197   0DBD FD 4F F5 1B   mov di, user_data
2198   0DC1 38 00 02      mov c, 512
2199   0DC4 04            load                          ; load data from user-space
2200   0DC5 14 07 17      mov a, [current_dir_id]
2201   0DC8 77            inc a                         ; metadata sector
2202   0DC9 27            mov b, a  
2203   0DCA 38 00 00      mov c, 0                      ; upper LBA = 0
2204   0DCD 22 01         mov ah, $01                  ; 1 sector
2205   0DCF 3B F5 23      mov d, transient_area
2206   0DD2 07 27 04      call ide_read_sect            ; read directory
2207   0DD5 FD 10         cla
2208   0DD7 42 FF 16      mov [index], a                ; reset file counter
2209   0DDA             fs_mv_L1:
2210   0DDA FD 4E         mov si, d
2211   0DDC FD 4F F5 1B   mov di, user_data
2212   0DE0 07 10 10      call _strcmp
2213   0DE3 C6 F9 0D      je fs_mv_found_entry
2214   0DE6 58 20 00      add d, 32
2215   0DE9 14 FF 16      mov a, [index]
2216   0DEC 77            inc a
2217   0DED 42 FF 16      mov [index], a
2218   0DF0 AF 10 00      cmp a, FST_FILES_PER_DIR
2219   0DF3 C6 2B 0E      je fs_mv_not_found
2220   0DF6 0A DA 0D      jmp fs_mv_L1
2221   0DF9             fs_mv_found_entry:  
2222   0DF9 DA            push d
2223   0DFA FD 4D 75 1C   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2224   0DFE FD 50         mov di, d
2225   0E00 07 25 10      call _strcpy  
2226   0E03 38 00 00      mov c, 0
2227   0E06 3B F5 23      mov d, transient_area
2228   0E09 22 01         mov ah, $01                   ; disk write 1 sect
2229   0E0B 07 4D 04      call ide_write_sect           ; write sector
2230   0E0E E7            pop d
2231   0E0F             ;; need to check whether its a dir or a file here ;;;
2232   0E0F 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2233   0E12 22 01         mov ah, $01
2234   0E14 3B F5 23      mov d, transient_area
2235   0E17 38 00 00      mov c, 0
2236   0E1A 07 27 04      call ide_read_sect            ; read directory entry
2237   0E1D FD 4D 75 1C   mov si, user_data + 128
2238   0E21 FD 50         mov di, d
2239   0E23 07 25 10      call _strcpy                  ; change directory's name
2240   0E26 22 01         mov ah, $01
2241   0E28 07 4D 04      call ide_write_sect           ; rewrite directory back to disk
2242   0E2B             fs_mv_not_found:
2243   0E2B 06            sysret
2244   0E2C             
2245   0E2C             kernel_reset_vector:  
2246   0E2C FD 49 FF F7   mov bp, STACK_BEGIN
2247   0E30 FD 47 FF F7   mov sp, STACK_BEGIN
2248   0E34               
2249   0E34 19 80         mov al, %10000000
2250   0E36 FD 0F         stomsk                        ; mask out timer interrupt for now (only allow UART to interrupt)
2251   0E38 FD 0C         sti  
2252   0E3A             
2253   0E3A 0C            lodstat
2254   0E3B 87 DF         and al, %11011111             ; disable display register loading
2255   0E3D 0D            stostat
2256   0E3E               
2257   0E3E             ; reset fifo pointers
2258   0E3E 10 F5 1D      mov a, fifo
2259   0E41 3B 03 17      mov d, fifo_in
2260   0E44 43            mov [d], a
2261   0E45 3B 05 17      mov d, fifo_out
2262   0E48 43            mov [d], a  
2263   0E49 19 02         mov al, 2
2264   0E4B 05 03         syscall sys_io                ; enable uart in interrupt mode
2265   0E4D               
2266   0E4D 3B 49 17      mov d, s_kernel_started
2267   0E50 07 CD 11      call _puts
2268   0E53             
2269   0E53 19 10         mov al, 16
2270   0E55 05 04         syscall sys_filesystem        ; set root dirID
2271   0E57             
2272   0E57 3B 59 17      mov d, s_prompt_init
2273   0E5A 07 CD 11      call _puts
2274   0E5D 3B 09 17      mov d, s_init_path
2275   0E60 05 05         syscall sys_spawn_proc              ; launch init as a new process
2276   0E62             
2277   0E62             ;----------------------------------------------------------------------------------------------------;
2278   0E62             ; Process Index in A
2279   0E62             ;----------------------------------------------------------------------------------------------------;
2280   0E62             find_free_proc:
2281   0E62 FD 4D 66 19   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2282   0E66             find_free_proc_L0:
2283   0E66 F6            lodsb                               ; get process state
2284   0E67 B9 00         cmp al, 0
2285   0E69 C6 6F 0E      je find_free_proc_free              ; if free, jump
2286   0E6C 0A 66 0E      jmp find_free_proc_L0               ; else, goto next
2287   0E6F             find_free_proc_free:
2288   0E6F 4E            mov a, si
2289   0E70 5F 66 19      sub a, 1 + proc_availab_table       ; get process index
2290   0E73 09            ret
2291   0E74               
2292   0E74             
2293   0E74             ;----------------------------------------------------------------------------------------------------;
2294   0E74             ; Process Index in AL
2295   0E74             ;----------------------------------------------------------------------------------------------------;
2296   0E74             proc_memory_map:
2297   0E74 22 00         mov ah, 0
2298   0E76 27            mov b, a                      ; page in BL, 0 in BH
2299   0E77 FD 9D 05      shl a, 5                      ; multiply by 32
2300   0E7A 39            mov c, a                      ; save in C
2301   0E7B 57 20 00      add c, 32
2302   0E7E             proc_memory_map_L0:
2303   0E7E 02            pagemap
2304   0E7F 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2305   0E82 53 01 00      add a, 1                      ; increase both 
2306   0E85 B1            cmp a, c                      ; check to see if we reached the end of memory
2307   0E86 C7 7E 0E      jne proc_memory_map_L0
2308   0E89 09            ret
2309   0E8A               
2310   0E8A             
2311   0E8A             syscall_terminate_proc:
2312   0E8A 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2313   0E8D                                                    ; since they will not be used for anything here.
2314   0E8D 1D FE 16      mov al, [active_proc_index]
2315   0E90 22 00         mov ah, 0  
2316   0E92 FD 9D 05      shl a, 5                             ; x32
2317   0E95 53 75 19      add a, proc_names
2318   0E98 3C            mov d, a
2319   0E99 19 00         mov al, 0
2320   0E9B 3E            mov [d], al                           ; nullify process name
2321   0E9C             
2322   0E9C 1D FE 16      mov al, [active_proc_index]
2323   0E9F 22 00         mov ah, 0  
2324   0EA1 3C            mov d, a
2325   0EA2 19 00         mov al, 0
2326   0EA4 3F 65 19      mov [d + proc_availab_table], al    ; make process empty again
2327   0EA7               
2328   0EA7 1D FD 16      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2329   0EAA 80            dec al
2330   0EAB 3D FD 16      mov [nbr_active_procs], al
2331   0EAE             
2332   0EAE             ; now load the shell process again
2333   0EAE 19 02         mov al, 2                           ; next process = process 2 = shell
2334   0EB0 3D FE 16      mov [active_proc_index], al         ; set next active proc
2335   0EB3             
2336   0EB3             ; calculate LUT entry for next process
2337   0EB3 22 00         mov ah, 0
2338   0EB5 FD 99         shl a                               ; x2
2339   0EB7 B7 80 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2340   0EBA               
2341   0EBA 4D            mov si, a                           ; source is proc state block
2342   0EBB 48            mov a, sp
2343   0EBC 5F 13 00      sub a, 19
2344   0EBF 4F            mov di, a                           ; destination is kernel stack
2345   0EC0             ; restore SP
2346   0EC0 7D            dec a
2347   0EC1 47            mov sp, a
2348   0EC2 38 14 00      mov c, 20
2349   0EC5 FD F5         rep movsb
2350   0EC7             ; set VM process
2351   0EC7 1D FE 16      mov al, [active_proc_index]
2352   0ECA 01            setptb
2353   0ECB                 
2354   0ECB 4C            popa
2355   0ECC 06            sysret
2356   0ECD             
2357   0ECD             syscall_pause_proc:
2358   0ECD             ; save all registers into kernel stack
2359   0ECD 4B            pusha
2360   0ECE 22 00         mov ah, 0
2361   0ED0 1D FE 16      mov al, [active_proc_index]
2362   0ED3 FD 99         shl a              ; x2
2363   0ED5 B7 80 0F      mov a, [proc_table_convert + a]   ; get process state start index
2364   0ED8                 
2365   0ED8 4F            mov di, a
2366   0ED9 48            mov a, sp
2367   0EDA 77            inc a
2368   0EDB 4D            mov si, a
2369   0EDC 38 14 00      mov c, 20
2370   0EDF FD F5         rep movsb                         ; save process state!
2371   0EE1             ; restore kernel stack position to point before interrupt arrived
2372   0EE1 51 14 00      add sp, 20
2373   0EE4             ; now load the shell process again
2374   0EE4 19 02         mov al, 2                         ; next process = process 2 = shell
2375   0EE6 3D FE 16      mov [active_proc_index], al       ; set next active proc
2376   0EE9             
2377   0EE9             ; calculate LUT entry for next process
2378   0EE9 22 00         mov ah, 0
2379   0EEB FD 99         shl a                             ; x2
2380   0EED B7 80 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2381   0EF0               
2382   0EF0 4D            mov si, a                         ; source is proc state block
2383   0EF1 48            mov a, sp
2384   0EF2 5F 13 00      sub a, 19
2385   0EF5 4F            mov di, a                         ; destination is kernel stack
2386   0EF6             ; restore SP
2387   0EF6 7D            dec a
2388   0EF7 47            mov sp, a
2389   0EF8 38 14 00      mov c, 20
2390   0EFB FD F5         rep movsb
2391   0EFD             ; set VM process
2392   0EFD 1D FE 16      mov al, [active_proc_index]
2393   0F00 01            setptb
2394   0F01                 
2395   0F01 4C            popa
2396   0F02 06            sysret
2397   0F03             
2398   0F03             ;----------------------------------------------------------------------------------------------------;
2399   0F03             ; spawn a new process
2400   0F03             ; D = path of the process file to be spawned
2401   0F03             ; B = arguments ptr
2402   0F03             ;----------------------------------------------------------------------------------------------------;
2403   0F03             syscall_spawn_proc:
2404   0F03             ; we save the active process first  
2405   0F03 4B            pusha
2406   0F04 22 00         mov ah, 0
2407   0F06 1D FE 16      mov al, [active_proc_index]
2408   0F09 FD 99         shl a              ; x2
2409   0F0B B7 80 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2410   0F0E               
2411   0F0E 4F            mov di, a
2412   0F0F 48            mov a, sp
2413   0F10 77            inc a
2414   0F11 4D            mov si, a
2415   0F12 38 14 00      mov c, 20
2416   0F15 FD F5         rep movsb                          ; save process state!
2417   0F17             ; restore kernel stack position to point before interrupt arrived
2418   0F17 51 14 00      add sp, 20
2419   0F1A               
2420   0F1A FD 4E         mov si, d                          ; copy the file path
2421   0F1C FD 4F F5 1B   mov di, user_data
2422   0F20 38 00 02      mov c, 512
2423   0F23 04            load
2424   0F24 11            mov a, b
2425   0F25 4D            mov si, a                          ; copy the arguments
2426   0F26 FD 4F F5 21   mov di, scrap_sector
2427   0F2A 38 00 02      mov c, 512
2428   0F2D 04            load
2429   0F2E 07 DF 08      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2430   0F31                                                  ; the file data is loaded into transient_area
2431   0F31             ; now we allocate a new process  
2432   0F31 07 62 0E      call find_free_proc                ; index in A
2433   0F34 01            setptb 
2434   0F35 07 74 0E      call proc_memory_map               ; map process memory pages
2435   0F38             ; copy arguments into process's memory
2436   0F38 FD 4D F5 21   mov si, scrap_sector
2437   0F3C FD 4F 00 00   mov di, 0
2438   0F40 38 00 02      mov c, 512
2439   0F43 03            store
2440   0F44             ; now copy process binary data into process's memory
2441   0F44 FD 4D F5 23   mov si, transient_area
2442   0F48 FD 4F 00 04   mov di, text_org              ; code origin address for all user processes
2443   0F4C 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2444   0F4F 03            store                              ; copy process data
2445   0F50                 
2446   0F50 07 62 0E      call find_free_proc                ; index in A
2447   0F53 3D FE 16      mov [active_proc_index], al        ; set new active process
2448   0F56 FD 9D 05      shl a, 5                           ; x32
2449   0F59 53 75 19      add a, proc_names
2450   0F5C 4F            mov di, a
2451   0F5D FD 4D F5 1B   mov si, user_data                  ; copy and store process filename
2452   0F61 07 25 10      call _strcpy
2453   0F64               
2454   0F64 07 62 0E      call find_free_proc                ; index in A
2455   0F67 3C            mov d, a
2456   0F68 19 01         mov al, 1
2457   0F6A 3F 65 19      mov [d + proc_availab_table], al   ; make process busy
2458   0F6D               
2459   0F6D 1D FD 16      mov al, [nbr_active_procs]         ; increase nbr of active processes
2460   0F70 7A            inc al
2461   0F71 3D FD 16      mov [nbr_active_procs], al
2462   0F74             ; launch process
2463   0F74 FD D7 FF FF   push word $FFFF 
2464   0F78 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2465   0F7B FD D7 00 04   push word text_org
2466   0F7F 06            sysret
2467   0F80             
2468   0F80             proc_table_convert:
2469   0F80 25 18         .dw proc_state_table + 0
2470   0F82 39 18         .dw proc_state_table + 20
2471   0F84 4D 18         .dw proc_state_table + 40
2472   0F86 61 18         .dw proc_state_table + 60
2473   0F88 75 18         .dw proc_state_table + 80
2474   0F8A 89 18         .dw proc_state_table + 100
2475   0F8C 9D 18         .dw proc_state_table + 120
2476   0F8E B1 18         .dw proc_state_table + 140
2477   0F90               
2478   0F90             ;----------------------------------------------------------------------------------------------;
2479   0F90             ; GET HEX FILE
2480   0F90             ; di = destination address
2481   0F90             ; return length in bytes in C
2482   0F90             ;----------------------------------------------------------------------------------------------;
2483   0F90             _load_hex:
2484   0F90 D7            push a
2485   0F91 D8            push b
2486   0F92 DA            push d
2487   0F93 E2            push si
2488   0F94 E3            push di
2489   0F95 38 00 00      mov c, 0
2490   0F98 50            mov a, di
2491   0F99 3C            mov d, a          ; start of string data block
2492   0F9A 07 A8 10      call _gets        ; get program string
2493   0F9D 07 CD 11      call _puts        ; reprint to screen
2494   0FA0 4D            mov si, a
2495   0FA1             __load_hex_loop:
2496   0FA1 F6            lodsb             ; load from [SI] to AL
2497   0FA2 B9 00         cmp al, 0         ; check if ASCII 0
2498   0FA4 C6 B2 0F      jz __load_hex_ret
2499   0FA7 36            mov bh, al
2500   0FA8 F6            lodsb
2501   0FA9 2F            mov bl, al
2502   0FAA 07 5E 10      call _atoi        ; convert ASCII byte in B to int (to AL)
2503   0FAD F7            stosb             ; store AL to [DI]
2504   0FAE 78            inc c
2505   0FAF 0A A1 0F      jmp __load_hex_loop
2506   0FB2             __load_hex_ret:
2507   0FB2 F0            pop di
2508   0FB3 EF            pop si
2509   0FB4 E7            pop d
2510   0FB5 E5            pop b
2511   0FB6 E4            pop a
2512   0FB7 09            ret
2513   0FB8             
2514   0FB8             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2515   0FB8             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2516   0FB8             ; for each entry insIDE DIRECTORY:
2517   0FB8             ;  if entry is a file:
2518   0FB8             ;    compare filename to searched filename
2519   0FB8             ;    if filenames are the same, print filename
2520   0FB8             ;  else if entry is a directory:
2521   0FB8             ;    cd to the given directory
2522   0FB8             ;    recursively call cmd_find
2523   0FB8             ;    cd outsIDE previous directory
2524   0FB8             ;  if current entry == last entry, return
2525   0FB8             ; endfor
2526   0FB8             f_find:
2527   0FB8 09            ret
2528   0FB9             
2529   0FB9             ; FILE INCLUDES
2530   0FB9             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  0FB9             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0FB9             IDE_buffer       .EQU  $8204
0003+  0FB9             boot_origin      .EQU  $8004
0004+  0FB9             bios_uart        .EQU  $0002
0005+  0FB9             bios_ide         .EQU  $0003
2531   0FB9             .include "lib/stdio.asm"
0001+  0FB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0FB9             ; stdio.s
0003+  0FB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0FB9             .include "lib/string.asm"
0001++ 0FB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0FB9             ; string.s
0003++ 0FB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0FB9             
0005++ 0FB9             
0006++ 0FB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0FB9             ; _strrev
0008++ 0FB9             ; reverse a string
0009++ 0FB9             ; D = string address
0010++ 0FB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0FB9             ; 01234
0012++ 0FB9             _strrev:
0013++ 0FB9 4B          	pusha
0014++ 0FBA 07 00 10    	call _strlen	; length in C
0015++ 0FBD 12          	mov a, c
0016++ 0FBE AF 01 00    	cmp a, 1
0017++ 0FC1 D0 DB 0F    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0FC4 7D          	dec a
0019++ 0FC5 FD 4E       	mov si, d	; beginning of string
0020++ 0FC7 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0FC9 59          	add d, a	; end of string
0022++ 0FCA 12          	mov a, c
0023++ 0FCB FD 9B       	shr a		; divide by 2
0024++ 0FCD 39          	mov c, a	; C now counts the steps
0025++ 0FCE             _strrev_L0:
0026++ 0FCE 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0FCF F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0FD0 3E          	mov [d], al	; store left char into right side
0029++ 0FD1 1B          	mov al, bl
0030++ 0FD2 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0FD3 7E          	dec c
0032++ 0FD4 7F          	dec d
0033++ 0FD5 C2 00 00    	cmp c, 0
0034++ 0FD8 C7 CE 0F    	jne _strrev_L0
0035++ 0FDB             _strrev_end:
0036++ 0FDB 4C          	popa
0037++ 0FDC 09          	ret
0038++ 0FDD             	
0039++ 0FDD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0FDD             ; _strchr
0041++ 0FDD             ; search string in D for char in AL
0042++ 0FDD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0FDD             _strchr:
0044++ 0FDD             _strchr_L0:
0045++ 0FDD 32          	mov bl, [d]
0046++ 0FDE C1 00       	cmp bl, 0
0047++ 0FE0 C6 EB 0F    	je _strchr_end
0048++ 0FE3 BA          	cmp al, bl
0049++ 0FE4 C6 EB 0F    	je _strchr_end
0050++ 0FE7 79          	inc d
0051++ 0FE8 0A DD 0F    	jmp _strchr_L0
0052++ 0FEB             _strchr_end:
0053++ 0FEB 1B          	mov al, bl
0054++ 0FEC 09          	ret
0055++ 0FED             
0056++ 0FED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0FED             ; _strstr
0058++ 0FED             ; find sub-string
0059++ 0FED             ; str1 in SI
0060++ 0FED             ; str2 in DI
0061++ 0FED             ; SI points to end of source string
0062++ 0FED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0FED             _strstr:
0064++ 0FED DB          	push al
0065++ 0FEE DA          	push d
0066++ 0FEF E3          	push di
0067++ 0FF0             _strstr_loop:
0068++ 0FF0 F3          	cmpsb					; compare a byte of the strings
0069++ 0FF1 C7 FC 0F    	jne _strstr_ret
0070++ 0FF4 FC 00 00    	lea d, [di + 0]
0071++ 0FF7 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0FF9 C7 F0 0F    	jne _strstr_loop				; equal chars but not at end
0073++ 0FFC             _strstr_ret:
0074++ 0FFC F0          	pop di
0075++ 0FFD E7          	pop d
0076++ 0FFE E8          	pop al
0077++ 0FFF 09          	ret
0078++ 1000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1000             ; length of null terminated string
0080++ 1000             ; result in C
0081++ 1000             ; pointer in D
0082++ 1000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1000             _strlen:
0084++ 1000 DA          	push d
0085++ 1001 38 00 00    	mov c, 0
0086++ 1004             _strlen_L1:
0087++ 1004 BD 00       	cmp byte [d], 0
0088++ 1006 C6 0E 10    	je _strlen_ret
0089++ 1009 79          	inc d
0090++ 100A 78          	inc c
0091++ 100B 0A 04 10    	jmp _strlen_L1
0092++ 100E             _strlen_ret:
0093++ 100E E7          	pop d
0094++ 100F 09          	ret
0095++ 1010             
0096++ 1010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1010             ; STRCMP
0098++ 1010             ; compare two strings
0099++ 1010             ; str1 in SI
0100++ 1010             ; str2 in DI
0101++ 1010             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1010             _strcmp:
0104++ 1010 DB          	push al
0105++ 1011 DA          	push d
0106++ 1012 E3          	push di
0107++ 1013 E2          	push si
0108++ 1014             _strcmp_loop:
0109++ 1014 F3          	cmpsb					; compare a byte of the strings
0110++ 1015 C7 20 10    	jne _strcmp_ret
0111++ 1018 FB FF FF    	lea d, [si +- 1]
0112++ 101B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 101D C7 14 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1020             _strcmp_ret:
0115++ 1020 EF          	pop si
0116++ 1021 F0          	pop di
0117++ 1022 E7          	pop d
0118++ 1023 E8          	pop al
0119++ 1024 09          	ret
0120++ 1025             
0121++ 1025             
0122++ 1025             ; STRCPY
0123++ 1025             ; copy null terminated string from SI to DI
0124++ 1025             ; source in SI
0125++ 1025             ; destination in DI
0126++ 1025             _strcpy:
0127++ 1025 E2          	push si
0128++ 1026 E3          	push di
0129++ 1027 DB          	push al
0130++ 1028             _strcpy_L1:
0131++ 1028 F6          	lodsb
0132++ 1029 F7          	stosb
0133++ 102A B9 00       	cmp al, 0
0134++ 102C C7 28 10    	jne _strcpy_L1
0135++ 102F             _strcpy_end:
0136++ 102F E8          	pop al
0137++ 1030 F0          	pop di
0138++ 1031 EF          	pop si
0139++ 1032 09          	ret
0140++ 1033             
0141++ 1033             ; STRCAT
0142++ 1033             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1033             ; source in SI
0144++ 1033             ; destination in DI
0145++ 1033             _strcat:
0146++ 1033 E2          	push si
0147++ 1034 E3          	push di
0148++ 1035 D7          	push a
0149++ 1036 DA          	push d
0150++ 1037 50          	mov a, di
0151++ 1038 3C          	mov d, a
0152++ 1039             _strcat_goto_end_L1:
0153++ 1039 BD 00       	cmp byte[d], 0
0154++ 103B C6 42 10    	je _strcat_start
0155++ 103E 79          	inc d
0156++ 103F 0A 39 10    	jmp _strcat_goto_end_L1
0157++ 1042             _strcat_start:
0158++ 1042 FD 50       	mov di, d
0159++ 1044             _strcat_L1:
0160++ 1044 F6          	lodsb
0161++ 1045 F7          	stosb
0162++ 1046 B9 00       	cmp al, 0
0163++ 1048 C7 44 10    	jne _strcat_L1
0164++ 104B             _strcat_end:
0165++ 104B E7          	pop d
0166++ 104C E4          	pop a
0167++ 104D F0          	pop di
0168++ 104E EF          	pop si
0169++ 104F 09          	ret
0170++ 1050             
0171++ 1050             
0005+  1050             
0006+  1050             
0007+  1050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1050             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  1050             ; ASCII in BL
0010+  1050             ; result in AL
0011+  1050             ; ascii for F = 0100 0110
0012+  1050             ; ascii for 9 = 0011 1001
0013+  1050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1050             hex_ascii_encode:
0015+  1050 1B            mov al, bl
0016+  1051 93 40         test al, $40        ; test if letter or number
0017+  1053 C7 59 10      jnz hex_letter
0018+  1056 87 0F         and al, $0F        ; get number
0019+  1058 09            ret
0020+  1059             hex_letter:
0021+  1059 87 0F         and al, $0F        ; get letter
0022+  105B 6A 09         add al, 9
0023+  105D 09            ret
0024+  105E             
0025+  105E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  105E             ; ATOI
0027+  105E             ; 2 letter hex string in B
0028+  105E             ; 8bit integer returned in AL
0029+  105E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  105E             _atoi:
0031+  105E D8            push b
0032+  105F 07 50 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  1062 30            mov bl, bh
0034+  1063 DB            push al          ; save a
0035+  1064 07 50 10      call hex_ascii_encode
0036+  1067 EA            pop bl  
0037+  1068 FD 9E 04      shl al, 4
0038+  106B 8C            or al, bl
0039+  106C E5            pop b
0040+  106D 09            ret  
0041+  106E             
0042+  106E             
0043+  106E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  106E             ; scanf
0045+  106E             ; no need for explanations!
0046+  106E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  106E             scanf:
0048+  106E 09            ret
0049+  106F             
0050+  106F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  106F             ; ITOA
0052+  106F             ; 8bit value in BL
0053+  106F             ; 2 byte ASCII result in A
0054+  106F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  106F             _itoa:
0056+  106F DA            push d
0057+  1070 D8            push b
0058+  1071 A7 00         mov bh, 0
0059+  1073 FD A4 04      shr bl, 4  
0060+  1076 74            mov d, b
0061+  1077 1F 09 13      mov al, [d + s_hex_digits]
0062+  107A 23            mov ah, al
0063+  107B               
0064+  107B E5            pop b
0065+  107C D8            push b
0066+  107D A7 00         mov bh, 0
0067+  107F FD 87 0F      and bl, $0F
0068+  1082 74            mov d, b
0069+  1083 1F 09 13      mov al, [d + s_hex_digits]
0070+  1086 E5            pop b
0071+  1087 E7            pop d
0072+  1088 09            ret
0073+  1089             
0074+  1089             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1089             ; HEX STRING TO BINARY
0076+  1089             ; di = destination address
0077+  1089             ; si = source
0078+  1089             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1089             _hex_to_int:
0080+  1089             _hex_to_int_L1:
0081+  1089 F6            lodsb          ; load from [SI] to AL
0082+  108A B9 00         cmp al, 0        ; check if ASCII 0
0083+  108C C6 99 10      jz _hex_to_int_ret
0084+  108F 36            mov bh, al
0085+  1090 F6            lodsb
0086+  1091 2F            mov bl, al
0087+  1092 07 5E 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  1095 F7            stosb          ; store AL to [DI]
0089+  1096 0A 89 10      jmp _hex_to_int_L1
0090+  1099             _hex_to_int_ret:
0091+  1099 09            ret    
0092+  109A             
0093+  109A             
0094+  109A             
0095+  109A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  109A             ; GETCHAR
0097+  109A             ; char in ah
0098+  109A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  109A             getch:
0100+  109A DB            push al
0101+  109B             getch_retry:
0102+  109B 19 01         mov al, 1
0103+  109D 05 03         syscall sys_io      ; receive in AH
0104+  109F E8            pop al
0105+  10A0 09            ret
0106+  10A1             
0107+  10A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  10A1             ; PUTCHAR
0109+  10A1             ; char in ah
0110+  10A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  10A1             _putchar:
0112+  10A1 DB            push al
0113+  10A2 19 00         mov al, 0
0114+  10A4 05 03         syscall sys_io      ; char in AH
0115+  10A6 E8            pop al
0116+  10A7 09            ret
0117+  10A8             
0118+  10A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  10A8             ;; INPUT A STRING
0120+  10A8             ;; terminates with null
0121+  10A8             ;; pointer in D
0122+  10A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  10A8             _gets:
0124+  10A8 D7            push a
0125+  10A9 DA            push d
0126+  10AA             _gets_loop:
0127+  10AA 19 01         mov al, 1
0128+  10AC 05 03         syscall sys_io      ; receive in AH
0129+  10AE 76 1B         cmp ah, 27
0130+  10B0 C6 D1 10      je _gets_ansi_esc
0131+  10B3 76 0A         cmp ah, $0A        ; LF
0132+  10B5 C6 2D 11      je _gets_end
0133+  10B8 76 0D         cmp ah, $0D        ; CR
0134+  10BA C6 2D 11      je _gets_end
0135+  10BD 76 5C         cmp ah, $5C        ; '\\'
0136+  10BF C6 F3 10      je _gets_escape
0137+  10C2 76 08         cmp ah, $08      ; check for backspace
0138+  10C4 C6 CD 10      je _gets_backspace
0139+  10C7 1A            mov al, ah
0140+  10C8 3E            mov [d], al
0141+  10C9 79            inc d
0142+  10CA 0A AA 10      jmp _gets_loop
0143+  10CD             _gets_backspace:
0144+  10CD 7F            dec d
0145+  10CE 0A AA 10      jmp _gets_loop
0146+  10D1             _gets_ansi_esc:
0147+  10D1 19 01         mov al, 1
0148+  10D3 05 03         syscall sys_io        ; receive in AH without echo
0149+  10D5 76 5B         cmp ah, '['
0150+  10D7 C7 AA 10      jne _gets_loop
0151+  10DA 19 01         mov al, 1
0152+  10DC 05 03         syscall sys_io          ; receive in AH without echo
0153+  10DE 76 44         cmp ah, 'D'
0154+  10E0 C6 EB 10      je _gets_left_arrow
0155+  10E3 76 43         cmp ah, 'C'
0156+  10E5 C6 EF 10      je _gets_right_arrow
0157+  10E8 0A AA 10      jmp _gets_loop
0158+  10EB             _gets_left_arrow:
0159+  10EB 7F            dec d
0160+  10EC 0A AA 10      jmp _gets_loop
0161+  10EF             _gets_right_arrow:
0162+  10EF 79            inc d
0163+  10F0 0A AA 10      jmp _gets_loop
0164+  10F3             _gets_escape:
0165+  10F3 19 01         mov al, 1
0166+  10F5 05 03         syscall sys_io      ; receive in AH
0167+  10F7 76 6E         cmp ah, 'n'
0168+  10F9 C6 18 11      je _gets_LF
0169+  10FC 76 72         cmp ah, 'r'
0170+  10FE C6 1F 11      je _gets_CR
0171+  1101 76 30         cmp ah, '0'
0172+  1103 C6 26 11      je _gets_NULL
0173+  1106 76 5C         cmp ah, $5C  ; '\'
0174+  1108 C6 11 11      je _gets_slash
0175+  110B 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  110C 3E            mov [d], al
0177+  110D 79            inc d
0178+  110E 0A AA 10      jmp _gets_loop
0179+  1111             _gets_slash:
0180+  1111 19 5C         mov al, $5C
0181+  1113 3E            mov [d], al
0182+  1114 79            inc d
0183+  1115 0A AA 10      jmp _gets_loop
0184+  1118             _gets_LF:
0185+  1118 19 0A         mov al, $0A
0186+  111A 3E            mov [d], al
0187+  111B 79            inc d
0188+  111C 0A AA 10      jmp _gets_loop
0189+  111F             _gets_CR:
0190+  111F 19 0D         mov al, $0D
0191+  1121 3E            mov [d], al
0192+  1122 79            inc d
0193+  1123 0A AA 10      jmp _gets_loop
0194+  1126             _gets_NULL:
0195+  1126 19 00         mov al, $00
0196+  1128 3E            mov [d], al
0197+  1129 79            inc d
0198+  112A 0A AA 10      jmp _gets_loop
0199+  112D             _gets_end:
0200+  112D 19 00         mov al, 0
0201+  112F 3E            mov [d], al        ; terminate string
0202+  1130 E7            pop d
0203+  1131 E4            pop a
0204+  1132 09            ret
0205+  1133             
0206+  1133             
0207+  1133             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1133             ;; INPUT TEXT
0209+  1133             ;; terminated with CTRL+D
0210+  1133             ;; pointer in D
0211+  1133             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1133             _gettxt:
0213+  1133 D7            push a
0214+  1134 DA            push d
0215+  1135             _gettxt_loop:
0216+  1135 19 01         mov al, 1
0217+  1137 05 03         syscall sys_io      ; receive in AH
0218+  1139 76 04         cmp ah, 4      ; EOT
0219+  113B C6 74 11      je _gettxt_end
0220+  113E 76 08         cmp ah, $08      ; check for backspace
0221+  1140 C6 70 11      je _gettxt_backspace
0222+  1143 76 5C         cmp ah, $5C        ; '\'
0223+  1145 C6 4E 11      je _gettxt_escape
0224+  1148 1A            mov al, ah
0225+  1149 3E            mov [d], al
0226+  114A 79            inc d
0227+  114B 0A 35 11      jmp _gettxt_loop
0228+  114E             _gettxt_escape:
0229+  114E 19 01         mov al, 1
0230+  1150 05 03         syscall sys_io      ; receive in AH
0231+  1152 76 6E         cmp ah, 'n'
0232+  1154 C6 62 11      je _gettxt_LF
0233+  1157 76 72         cmp ah, 'r'
0234+  1159 C6 69 11      je _gettxt_CR
0235+  115C 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  115D 3E            mov [d], al
0237+  115E 79            inc d
0238+  115F 0A 35 11      jmp _gettxt_loop
0239+  1162             _gettxt_LF:
0240+  1162 19 0A         mov al, $0A
0241+  1164 3E            mov [d], al
0242+  1165 79            inc d
0243+  1166 0A 35 11      jmp _gettxt_loop
0244+  1169             _gettxt_CR:
0245+  1169 19 0D         mov al, $0D
0246+  116B 3E            mov [d], al
0247+  116C 79            inc d
0248+  116D 0A 35 11      jmp _gettxt_loop
0249+  1170             _gettxt_backspace:
0250+  1170 7F            dec d
0251+  1171 0A 35 11      jmp _gettxt_loop
0252+  1174             _gettxt_end:
0253+  1174 19 00         mov al, 0
0254+  1176 3E            mov [d], al        ; terminate string
0255+  1177 E7            pop d
0256+  1178 E4            pop a
0257+  1179 09            ret
0258+  117A             
0259+  117A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  117A             ; PRINT NEW LINE
0261+  117A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  117A             printnl:
0263+  117A D7            push a
0264+  117B 10 00 0A      mov a, $0A00
0265+  117E 05 03         syscall sys_io
0266+  1180 10 00 0D      mov a, $0D00
0267+  1183 05 03         syscall sys_io
0268+  1185 E4            pop a
0269+  1186 09            ret
0270+  1187             
0271+  1187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  1187             ; _strtoint
0273+  1187             ; 4 digit hex string number in d
0274+  1187             ; integer returned in A
0275+  1187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1187             _strtointx:
0277+  1187 D8            push b
0278+  1188 32            mov bl, [d]
0279+  1189 37            mov bh, bl
0280+  118A 33 01 00      mov bl, [d + 1]
0281+  118D 07 5E 10      call _atoi        ; convert to int in AL
0282+  1190 23            mov ah, al        ; move to AH
0283+  1191 33 02 00      mov bl, [d + 2]
0284+  1194 37            mov bh, bl
0285+  1195 33 03 00      mov bl, [d + 3]
0286+  1198 07 5E 10      call _atoi        ; convert to int in AL
0287+  119B E5            pop b
0288+  119C 09            ret
0289+  119D             
0290+  119D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  119D             ; _strtoint
0292+  119D             ; 5 digit base10 string number in d
0293+  119D             ; integer returned in A
0294+  119D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  119D             _strtoint:
0296+  119D E2            push si
0297+  119E D8            push b
0298+  119F D9            push c
0299+  11A0 DA            push d
0300+  11A1 07 00 10      call _strlen      ; get string length in C
0301+  11A4 7E            dec c
0302+  11A5 FD 4E         mov si, d
0303+  11A7 12            mov a, c
0304+  11A8 FD 99         shl a
0305+  11AA 3B 21 13      mov d, table_power
0306+  11AD 59            add d, a
0307+  11AE 38 00 00      mov c, 0
0308+  11B1             _strtoint_L0:
0309+  11B1 F6            lodsb      ; load ASCII to al
0310+  11B2 B9 00         cmp al, 0
0311+  11B4 C6 C7 11      je _strtoint_end
0312+  11B7 6F 30         sub al, $30    ; make into integer
0313+  11B9 22 00         mov ah, 0
0314+  11BB 2A            mov b, [d]
0315+  11BC AC            mul a, b      ; result in B since it fits in 16bits
0316+  11BD 11            mov a, b
0317+  11BE 28            mov b, c
0318+  11BF 54            add a, b
0319+  11C0 39            mov c, a
0320+  11C1 63 02 00      sub d, 2
0321+  11C4 0A B1 11      jmp _strtoint_L0
0322+  11C7             _strtoint_end:
0323+  11C7 12            mov a, c
0324+  11C8 E7            pop d
0325+  11C9 E6            pop c
0326+  11CA E5            pop b
0327+  11CB EF            pop si
0328+  11CC 09            ret
0329+  11CD             
0330+  11CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  11CD             ; PRINT NULL TERMINATED STRING
0332+  11CD             ; pointer in D
0333+  11CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  11CD             _puts:
0335+  11CD D7            push a
0336+  11CE DA            push d
0337+  11CF             _puts_L1:
0338+  11CF 1E            mov al, [d]
0339+  11D0 B9 00         cmp al, 0
0340+  11D2 C6 DE 11      jz _puts_END
0341+  11D5 23            mov ah, al
0342+  11D6 19 00         mov al, 0
0343+  11D8 05 03         syscall sys_io
0344+  11DA 79            inc d
0345+  11DB 0A CF 11      jmp _puts_L1
0346+  11DE             _puts_END:
0347+  11DE E7            pop d
0348+  11DF E4            pop a
0349+  11E0 09            ret
0350+  11E1             
0351+  11E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  11E1             ; PRINT N SIZE STRING
0353+  11E1             ; pointer in D
0354+  11E1             ; size in C
0355+  11E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  11E1             _putsn:
0357+  11E1 DB            push al
0358+  11E2 DA            push d
0359+  11E3 D9            push c
0360+  11E4             _putsn_L0:
0361+  11E4 1E            mov al, [d]
0362+  11E5 23            mov ah, al
0363+  11E6 19 00         mov al, 0
0364+  11E8 05 03         syscall sys_io
0365+  11EA 79            inc d
0366+  11EB 7E            dec c  
0367+  11EC C2 00 00      cmp c, 0
0368+  11EF C7 E4 11      jne _putsn_L0
0369+  11F2             _putsn_end:
0370+  11F2 E6            pop c
0371+  11F3 E7            pop d
0372+  11F4 E8            pop al
0373+  11F5 09            ret
0374+  11F6             
0375+  11F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  11F6             ; print 16bit decimal number
0377+  11F6             ; input number in A
0378+  11F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  11F6             print_u16d:
0380+  11F6 D7            push a
0381+  11F7 D8            push b
0382+  11F8 FD D8         push g
0383+  11FA 26 10 27      mov b, 10000
0384+  11FD AE            div a, b      ; get 10000's coeff.
0385+  11FE 07 22 12      call print_number
0386+  1201 11            mov a, b
0387+  1202 26 E8 03      mov b, 1000
0388+  1205 AE            div a, b      ; get 1000's coeff.
0389+  1206 07 22 12      call print_number
0390+  1209 11            mov a, b
0391+  120A 26 64 00      mov b, 100
0392+  120D AE            div a, b
0393+  120E 07 22 12      call print_number
0394+  1211 11            mov a, b
0395+  1212 26 0A 00      mov b, 10
0396+  1215 AE            div a, b
0397+  1216 07 22 12      call print_number
0398+  1219 1B            mov al, bl      ; 1's coeff in bl
0399+  121A 07 22 12      call print_number
0400+  121D FD F1         pop g
0401+  121F E5            pop b
0402+  1220 E4            pop a
0403+  1221 09            ret
0404+  1222             
0405+  1222             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1222             ; print AL
0407+  1222             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1222             print_number:
0409+  1222 6A 30         add al, $30
0410+  1224 23            mov ah, al
0411+  1225 07 A1 10      call _putchar
0412+  1228 09            ret
0413+  1229             
0414+  1229             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  1229             ; PRINT 16BIT HEX INTEGER
0416+  1229             ; integer value in reg B
0417+  1229             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  1229             print_u16x:
0419+  1229 D7            push a
0420+  122A D8            push b
0421+  122B DD            push bl
0422+  122C 30            mov bl, bh
0423+  122D 07 6F 10      call _itoa        ; convert bh to char in A
0424+  1230 2F            mov bl, al        ; save al
0425+  1231 19 00         mov al, 0
0426+  1233 05 03         syscall sys_io        ; display AH
0427+  1235 24            mov ah, bl        ; retrieve al
0428+  1236 19 00         mov al, 0
0429+  1238 05 03         syscall sys_io        ; display AL
0430+  123A             
0431+  123A EA            pop bl
0432+  123B 07 6F 10      call _itoa        ; convert bh to char in A
0433+  123E 2F            mov bl, al        ; save al
0434+  123F 19 00         mov al, 0
0435+  1241 05 03         syscall sys_io        ; display AH
0436+  1243 24            mov ah, bl        ; retrieve al
0437+  1244 19 00         mov al, 0
0438+  1246 05 03         syscall sys_io        ; display AL
0439+  1248             
0440+  1248 E5            pop b
0441+  1249 E4            pop a
0442+  124A 09            ret
0443+  124B             
0444+  124B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  124B             ; INPUT 16BIT HEX INTEGER
0446+  124B             ; read 16bit integer into A
0447+  124B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  124B             scan_u16x:
0449+  124B F8 10 00      enter 16
0450+  124E D8            push b
0451+  124F DA            push d
0452+  1250             
0453+  1250 FA F1 FF      lea d, [bp + -15]
0454+  1253 07 A8 10      call _gets        ; get number
0455+  1256             
0456+  1256 32            mov bl, [d]
0457+  1257 37            mov bh, bl
0458+  1258 33 01 00      mov bl, [d + 1]
0459+  125B 07 5E 10      call _atoi        ; convert to int in AL
0460+  125E 23            mov ah, al        ; move to AH
0461+  125F             
0462+  125F 33 02 00      mov bl, [d + 2]
0463+  1262 37            mov bh, bl
0464+  1263 33 03 00      mov bl, [d + 3]
0465+  1266 07 5E 10      call _atoi        ; convert to int in AL
0466+  1269             
0467+  1269 E7            pop d
0468+  126A E5            pop b
0469+  126B F9            leave
0470+  126C 09            ret
0471+  126D             
0472+  126D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  126D             ; PRINT 8bit HEX INTEGER
0474+  126D             ; integer value in reg bl
0475+  126D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  126D             print_u8x:
0477+  126D D7            push a
0478+  126E DD            push bl
0479+  126F             
0480+  126F 07 6F 10      call _itoa        ; convert bl to char in A
0481+  1272 2F            mov bl, al        ; save al
0482+  1273 19 00         mov al, 0
0483+  1275 05 03         syscall sys_io        ; display AH
0484+  1277 24            mov ah, bl        ; retrieve al
0485+  1278 19 00         mov al, 0
0486+  127A 05 03         syscall sys_io        ; display AL
0487+  127C             
0488+  127C EA            pop bl
0489+  127D E4            pop a
0490+  127E 09            ret
0491+  127F             
0492+  127F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  127F             ; print 8bit decimal unsigned number
0494+  127F             ; input number in AL
0495+  127F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  127F             print_u8d:
0497+  127F D7            push a
0498+  1280 D8            push b
0499+  1281 FD D8         push g
0500+  1283 22 00         mov ah, 0
0501+  1285 26 64 00      mov b, 100
0502+  1288 AE            div a, b
0503+  1289 D8            push b      ; save remainder
0504+  128A B9 00         cmp al, 0
0505+  128C C6 96 12      je skip100
0506+  128F 6A 30         add al, $30
0507+  1291 23            mov ah, al
0508+  1292 19 00         mov al, 0
0509+  1294 05 03         syscall sys_io  ; print coeff
0510+  1296             skip100:
0511+  1296 E4            pop a
0512+  1297 22 00         mov ah, 0
0513+  1299 26 0A 00      mov b, 10
0514+  129C AE            div a, b
0515+  129D D8            push b      ; save remainder
0516+  129E B9 00         cmp al, 0
0517+  12A0 C6 AA 12      je skip10
0518+  12A3 6A 30         add al, $30
0519+  12A5 23            mov ah, al
0520+  12A6 19 00         mov al, 0
0521+  12A8 05 03         syscall sys_io  ; print coeff
0522+  12AA             skip10:
0523+  12AA E4            pop a
0524+  12AB 1B            mov al, bl
0525+  12AC 6A 30         add al, $30
0526+  12AE 23            mov ah, al
0527+  12AF 19 00         mov al, 0
0528+  12B1 05 03         syscall sys_io  ; print coeff
0529+  12B3 FD F1         pop g
0530+  12B5 E5            pop b
0531+  12B6 E4            pop a
0532+  12B7 09            ret
0533+  12B8             
0534+  12B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  12B8             ; INPUT 8BIT HEX INTEGER
0536+  12B8             ; read 8bit integer into AL
0537+  12B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  12B8             scan_u8x:
0539+  12B8 F8 04 00      enter 4
0540+  12BB D8            push b
0541+  12BC DA            push d
0542+  12BD             
0543+  12BD FA FD FF      lea d, [bp + -3]
0544+  12C0 07 A8 10      call _gets        ; get number
0545+  12C3             
0546+  12C3 32            mov bl, [d]
0547+  12C4 37            mov bh, bl
0548+  12C5 33 01 00      mov bl, [d + 1]
0549+  12C8 07 5E 10      call _atoi        ; convert to int in AL
0550+  12CB             
0551+  12CB E7            pop d
0552+  12CC E5            pop b
0553+  12CD F9            leave
0554+  12CE 09            ret
0555+  12CF             
0556+  12CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  12CF             ; input decimal number
0558+  12CF             ; result in A
0559+  12CF             ; 655'\0'
0560+  12CF             ; low--------high
0561+  12CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  12CF             scan_u16d:
0563+  12CF F8 08 00      enter 8
0564+  12D2 E2            push si
0565+  12D3 D8            push b
0566+  12D4 D9            push c
0567+  12D5 DA            push d
0568+  12D6 FA F9 FF      lea d, [bp +- 7]
0569+  12D9 07 A8 10      call _gets
0570+  12DC 07 00 10      call _strlen      ; get string length in C
0571+  12DF 7E            dec c
0572+  12E0 FD 4E         mov si, d
0573+  12E2 12            mov a, c
0574+  12E3 FD 99         shl a
0575+  12E5 3B 21 13      mov d, table_power
0576+  12E8 59            add d, a
0577+  12E9 38 00 00      mov c, 0
0578+  12EC             mul_loop:
0579+  12EC F6            lodsb      ; load ASCII to al
0580+  12ED B9 00         cmp al, 0
0581+  12EF C6 02 13      je mul_exit
0582+  12F2 6F 30         sub al, $30    ; make into integer
0583+  12F4 22 00         mov ah, 0
0584+  12F6 2A            mov b, [d]
0585+  12F7 AC            mul a, b      ; result in B since it fits in 16bits
0586+  12F8 11            mov a, b
0587+  12F9 28            mov b, c
0588+  12FA 54            add a, b
0589+  12FB 39            mov c, a
0590+  12FC 63 02 00      sub d, 2
0591+  12FF 0A EC 12      jmp mul_loop
0592+  1302             mul_exit:
0593+  1302 12            mov a, c
0594+  1303 E7            pop d
0595+  1304 E6            pop c
0596+  1305 E5            pop b
0597+  1306 EF            pop si
0598+  1307 F9            leave
0599+  1308 09            ret
0600+  1309             
0601+  1309             
0602+  1309 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  130D 34 35 36 37 
0602+  1311 38 39 41 42 
0602+  1315 43 44 45 46 
0603+  1319 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  131D 1B 5B 48 00 
0604+  1321             
0605+  1321             table_power:
0606+  1321 01 00         .dw 1
0607+  1323 0A 00         .dw 10
0608+  1325 64 00         .dw 100
0609+  1327 E8 03         .dw 1000
0610+  1329 10 27         .dw 100002532   132B             .include "lib/ctype.asm"
0001+  132B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  132B             ; ctype.s
0003+  132B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  132B             
0005+  132B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  132B             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  132B             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  132B             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  132B             ;; characters are supported.
0010+  132B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  132B             ;; _isalnum 
0012+  132B             ;; _isalpha 
0013+  132B             ;; islower 
0014+  132B             ;; isupper 
0015+  132B             ;; _isdigit 
0016+  132B             ;; isxdigit
0017+  132B             ;; iscntrl 
0018+  132B             ;; isgraph 
0019+  132B             ;; _isspace 
0020+  132B             ;; isblank 
0021+  132B             ;; isprint 
0022+  132B             ;; ispunct 
0023+  132B             ;; tolower 
0024+  132B             ;; toupper
0025+  132B             
0026+  132B             
0027+  132B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  132B             ;; IS ALPHANUMERIC
0029+  132B             ;; sets ZF according with result
0030+  132B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  132B             _isalnum:
0032+  132B 07 48 13    	call _isalpha
0033+  132E C6 34 13    	je _isalnum_exit
0034+  1331 07 35 13    	call _isdigit
0035+  1334             _isalnum_exit:
0036+  1334 09          	ret	
0037+  1335             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1335             ;; IS DIGIT
0039+  1335             ;; sets ZF according with result
0040+  1335             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1335             _isdigit:
0042+  1335 DB          	push al
0043+  1336 B9 30       	cmp al, '0'
0044+  1338 C8 44 13    	jlu _isdigit_false
0045+  133B B9 39       	cmp al, '9'
0046+  133D D1 44 13    	jgu _isdigit_false
0047+  1340 87 00       	and al, 0	; set ZF
0048+  1342 E8          	pop al
0049+  1343 09          	ret
0050+  1344             _isdigit_false:
0051+  1344 8B 01       	or al, 1	; clear ZF
0052+  1346 E8          	pop al
0053+  1347 09          	ret	
0054+  1348             	
0055+  1348             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1348             ;; IS ALPHA
0057+  1348             ;; sets ZF according with result
0058+  1348             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1348             _isalpha:
0060+  1348 DB          	push al
0061+  1349 B9 5F       	cmp al, '_'
0062+  134B C6 6B 13    	je _isalpha_true
0063+  134E B9 2E       	cmp al, '.'
0064+  1350 C6 6B 13    	je _isalpha_true
0065+  1353 B9 41       	cmp al, 'A'
0066+  1355 C8 67 13    	jlu _isalpha_false
0067+  1358 B9 7A       	cmp al, 'z'
0068+  135A D1 67 13    	jgu _isalpha_false
0069+  135D B9 5A       	cmp al, 'Z'
0070+  135F D0 6B 13    	jleu _isalpha_true
0071+  1362 B9 61       	cmp al, 'a'
0072+  1364 C9 6B 13    	jgeu _isalpha_true
0073+  1367             _isalpha_false:
0074+  1367 8B 01       	or al, 1	; clear ZF
0075+  1369 E8          	pop al
0076+  136A 09          	ret
0077+  136B             _isalpha_true:
0078+  136B 87 00       	and al, 0	; set ZF
0079+  136D E8          	pop al
0080+  136E 09          	ret
0081+  136F             
0082+  136F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  136F             ;; IS PATH-ALPHA
0084+  136F             ;; sets ZF according with result
0085+  136F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  136F             ispath:
0087+  136F DB          	push al
0088+  1370 07 35 13    	call _isdigit
0089+  1373 C6 9D 13    	je ispath_true
0090+  1376 B9 5F       	cmp al, '_'
0091+  1378 C6 9D 13    	je ispath_true
0092+  137B B9 2F       	cmp al, '/'
0093+  137D C6 9D 13    	je ispath_true
0094+  1380 B9 2E       	cmp al, '.'
0095+  1382 C6 9D 13    	je ispath_true
0096+  1385 B9 41       	cmp al, 'A'
0097+  1387 C8 99 13    	jlu ispath_false
0098+  138A B9 7A       	cmp al, 'z'
0099+  138C D1 99 13    	jgu ispath_false
0100+  138F B9 5A       	cmp al, 'Z'
0101+  1391 D0 9D 13    	jleu ispath_true
0102+  1394 B9 61       	cmp al, 'a'
0103+  1396 C9 9D 13    	jgeu ispath_true
0104+  1399             ispath_false:
0105+  1399 8B 01       	or al, 1	; clear ZF
0106+  139B E8          	pop al
0107+  139C 09          	ret
0108+  139D             ispath_true:
0109+  139D 87 00       	and al, 0	; set ZF
0110+  139F E8          	pop al
0111+  13A0 09          	ret
0112+  13A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  13A1             ;; IS SPACE
0114+  13A1             ;; sets ZF according with result
0115+  13A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  13A1             _isspace:
0117+  13A1 B9 20       	cmp al, $20		; ' '
0118+  13A3 C6 B7 13    	je _isspace_exit
0119+  13A6 B9 09       	cmp al, $09		; '\t'
0120+  13A8 C6 B7 13    	je _isspace_exit
0121+  13AB B9 0A       	cmp al, $0A		; '\n'
0122+  13AD C6 B7 13    	je _isspace_exit
0123+  13B0 B9 0D       	cmp al, $0D		; '\r'
0124+  13B2 C6 B7 13    	je _isspace_exit
0125+  13B5 B9 0B       	cmp al, $0B		; '\v'
0126+  13B7             _isspace_exit:
0127+  13B7 09          	ret	
0128+  13B8             
0129+  13B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  13B8             ; TO LOWER
0131+  13B8             ; input in AL
0132+  13B8             ; output in AL
0133+  13B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  13B8             _to_lower:
0135+  13B8 B9 5A       	cmp al, 'Z'
0136+  13BA D1 BF 13    	jgu _to_lower_ret
0137+  13BD 6A 20       	add al, $20				; convert to lower case
0138+  13BF             _to_lower_ret:
0139+  13BF 09          	ret
0140+  13C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  13C0             ; TO UPPER
0142+  13C0             ; input in AL
0143+  13C0             ; output in AL
0144+  13C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  13C0             _to_upper:
0146+  13C0 B9 61       	cmp al, 'a'
0147+  13C2 C8 C7 13    	jlu _to_upper_ret
0148+  13C5 6F 20       	sub al, $20			; convert to upper case
0149+  13C7             _to_upper_ret:
0150+  13C7 09          	ret
0151+  13C8             
2533   13C8             .include "lib/token.asm"
0001+  13C8             TOKTYP_IDENTIFIER  .equ 0
0002+  13C8             TOKTYP_KEYWORD     .equ 1
0003+  13C8             TOKTYP_DELIMITER   .equ 2
0004+  13C8             TOKTYP_STRING      .equ 3
0005+  13C8             TOKTYP_CHAR        .equ 4
0006+  13C8             TOKTYP_NUMERIC     .equ 5
0007+  13C8             TOKTYP_END         .equ 6
0008+  13C8             
0009+  13C8             TOK_NULL           .equ 0
0010+  13C8             TOK_FSLASH         .equ 1
0011+  13C8             TOK_TIMES          .equ 2
0012+  13C8             TOK_PLUS           .equ 3
0013+  13C8             TOK_MINUS          .equ 4
0014+  13C8             TOK_DOT            .equ 5
0015+  13C8             TOK_SEMI           .equ 6
0016+  13C8             TOK_ANGLE          .equ 7
0017+  13C8             TOK_TILDE          .equ 8
0018+  13C8             TOK_EQUAL          .equ 9
0019+  13C8             TOK_COLON          .equ 10
0020+  13C8             TOK_COMMA          .equ 11
0021+  13C8             
0022+  13C8             TOK_END            .equ 20
0023+  13C8             
0024+  13C8             
0025+  13C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  13C8             ;; read a full command argment from shell input buffer
0027+  13C8             ;; argument is written into tokstr
0028+  13C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  13C8             get_arg:
0030+  13C8 D7            push a
0031+  13C9 E2            push si
0032+  13CA E3            push di
0033+  13CB 19 00         mov al, 0
0034+  13CD 3D F6 15      mov [tokstr], al      ; nullify tokstr string
0035+  13D0 14 F2 15      mov a, [prog]
0036+  13D3 4D            mov si, a
0037+  13D4 FD 4F F6 15   mov di, tokstr
0038+  13D8             get_arg_skip_spaces:
0039+  13D8 F6            lodsb
0040+  13D9 07 A1 13      call _isspace
0041+  13DC C6 D8 13      je get_arg_skip_spaces
0042+  13DF             get_arg_L0:
0043+  13DF B9 3B         cmp al, $3B        ; check if is ';'
0044+  13E1 C6 EE 13      je get_arg_end
0045+  13E4 B9 00         cmp al, 0
0046+  13E6 C6 EE 13      je get_arg_end      ; check if end of input
0047+  13E9 F7            stosb
0048+  13EA F6            lodsb
0049+  13EB 0A DF 13      jmp get_arg_L0
0050+  13EE             get_arg_end:
0051+  13EE 19 00         mov al, 0
0052+  13F0 F7            stosb
0053+  13F1 D5 01 00      sub si, 1
0054+  13F4 4E            mov a, si
0055+  13F5 42 F2 15      mov [prog], a    ; update pointer
0056+  13F8 F0            pop di
0057+  13F9 EF            pop si
0058+  13FA E4            pop a
0059+  13FB 09            ret
0060+  13FC             
0061+  13FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  13FC             ;; read a path formation from shell input buffer
0063+  13FC             ;; path is written into tokstr
0064+  13FC             ;; /usr/bin
0065+  13FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  13FC             get_path:
0067+  13FC D7            push a
0068+  13FD E2            push si
0069+  13FE E3            push di
0070+  13FF 19 00         mov al, 0
0071+  1401 3D F6 15      mov [tokstr], al      ; nullify tokstr string
0072+  1404 14 F2 15      mov a, [prog]
0073+  1407 4D            mov si, a
0074+  1408 FD 4F F6 15   mov di, tokstr
0075+  140C             get_path_skip_spaces:
0076+  140C F6            lodsb
0077+  140D 07 A1 13      call _isspace
0078+  1410 C6 0C 14      je get_path_skip_spaces
0079+  1413             get_path_is_pathchar:
0080+  1413 F7            stosb
0081+  1414 F6            lodsb
0082+  1415 07 2B 13      call _isalnum      ;check if is alphanumeric
0083+  1418 C6 13 14      je get_path_is_pathchar
0084+  141B B9 2F         cmp al, '/'        ; check if is '/'
0085+  141D C6 13 14      je get_path_is_pathchar
0086+  1420 19 00         mov al, 0
0087+  1422 F7            stosb
0088+  1423 D5 01 00      sub si, 1
0089+  1426 4E            mov a, si
0090+  1427 42 F2 15      mov [prog], a    ; update pointer
0091+  142A             get_path_end:
0092+  142A F0            pop di
0093+  142B EF            pop si
0094+  142C E4            pop a
0095+  142D 09            ret
0096+  142E             
0097+  142E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  142E             ;; read a line
0099+  142E             ;; line is written into tokstr
0100+  142E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  142E             get_line:
0102+  142E D7            push a
0103+  142F E2            push si
0104+  1430 E3            push di
0105+  1431 19 00         mov al, 0
0106+  1433 3D F6 15      mov [tokstr], al      ; nullify tokstr string
0107+  1436 14 F2 15      mov a, [prog]
0108+  1439 4D            mov si, a
0109+  143A FD 4F F6 15   mov di, tokstr
0110+  143E             get_line_L0:
0111+  143E F6            lodsb
0112+  143F B9 0A         cmp al, $0A    ; check for new line
0113+  1441 C6 48 14      je get_line_exit
0114+  1444 F7            stosb
0115+  1445 0A 3E 14      jmp get_line_L0
0116+  1448             get_line_exit:
0117+  1448 19 00         mov al, 0
0118+  144A F7            stosb
0119+  144B 4E            mov a, si
0120+  144C 42 F2 15      mov [prog], a    ; update pointer
0121+  144F F0            pop di
0122+  1450 EF            pop si
0123+  1451 E4            pop a
0124+  1452 09            ret
0125+  1453             
0126+  1453             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1453             ;; token parser
0128+  1453             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1453             get_token:
0130+  1453 D7            push a
0131+  1454 DA            push d
0132+  1455 E2            push si
0133+  1456 E3            push di
0134+  1457 19 00         mov al, 0
0135+  1459 3D F6 15      mov [tokstr], al      ; nullify tokstr string
0136+  145C 19 00         mov al, TOK_NULL
0137+  145E 3D F5 15      mov [tok], al        ; nullify token
0138+  1461 14 F2 15      mov a, [prog]
0139+  1464 4D            mov si, a
0140+  1465 FD 4F F6 15   mov di, tokstr
0141+  1469             get_tok_skip_spaces:
0142+  1469 F6            lodsb
0143+  146A 07 A1 13      call _isspace
0144+  146D C6 69 14      je get_tok_skip_spaces
0145+  1470 B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  1472 C6 57 15      je get_token_end
0147+  1475 B9 23         cmp al, '#'      ; comments!
0148+  1477 C6 85 15      je get_tok_comment
0149+  147A 07 2B 13      call _isalnum
0150+  147D C6 64 15      jz is_alphanumeric
0151+  1480             ; other token types
0152+  1480             get_token_slash:
0153+  1480 B9 2F         cmp al, '/'        ; check if '/'
0154+  1482 C7 9A 14      jne get_token_minus
0155+  1485 F7            stosb          ; store '/' into token string
0156+  1486 19 00         mov al, 0
0157+  1488 F7            stosb          ; terminate token string
0158+  1489 19 01         mov al, TOK_FSLASH
0159+  148B 3D F5 15      mov [tok], al      
0160+  148E 19 02         mov al, TOKTYP_DELIMITER
0161+  1490 3D F4 15      mov [toktyp], al
0162+  1493 4E            mov a, si
0163+  1494 42 F2 15      mov [prog], a    ; update pointer
0164+  1497 0A 80 15      jmp get_token_return
0165+  149A             get_token_minus:
0166+  149A B9 2D         cmp al, '-'        ; check if '-'
0167+  149C C7 B4 14      jne get_token_comma
0168+  149F F7            stosb          ; store '-' into token string
0169+  14A0 19 00         mov al, 0
0170+  14A2 F7            stosb          ; terminate token string
0171+  14A3 19 04         mov al, TOK_MINUS
0172+  14A5 3D F5 15      mov [tok], al      
0173+  14A8 19 02         mov al, TOKTYP_DELIMITER
0174+  14AA 3D F4 15      mov [toktyp], al
0175+  14AD 4E            mov a, si
0176+  14AE 42 F2 15      mov [prog], a    ; update pointer
0177+  14B1 0A 80 15      jmp get_token_return
0178+  14B4             get_token_comma:
0179+  14B4 B9 2C         cmp al, ','        ; check if ','
0180+  14B6 C7 CE 14      jne get_token_semi
0181+  14B9 F7            stosb          ; store ',' into token string
0182+  14BA 19 00         mov al, 0
0183+  14BC F7            stosb          ; terminate token string
0184+  14BD 19 0B         mov al, TOK_COMMA
0185+  14BF 3D F5 15      mov [tok], al      
0186+  14C2 19 02         mov al, TOKTYP_DELIMITER
0187+  14C4 3D F4 15      mov [toktyp], al
0188+  14C7 4E            mov a, si
0189+  14C8 42 F2 15      mov [prog], a    ; update pointer
0190+  14CB 0A 80 15      jmp get_token_return
0191+  14CE             get_token_semi:
0192+  14CE B9 3B         cmp al, $3B        ; check if ';'
0193+  14D0 C7 E8 14      jne get_token_colon
0194+  14D3 F7            stosb          ; store ';' into token string
0195+  14D4 19 00         mov al, 0
0196+  14D6 F7            stosb          ; terminate token string
0197+  14D7 19 06         mov al, TOK_SEMI
0198+  14D9 3D F5 15      mov [tok], al      
0199+  14DC 19 02         mov al, TOKTYP_DELIMITER
0200+  14DE 3D F4 15      mov [toktyp], al
0201+  14E1 4E            mov a, si
0202+  14E2 42 F2 15      mov [prog], a    ; update pointer
0203+  14E5 0A 80 15      jmp get_token_return
0204+  14E8             get_token_colon:
0205+  14E8 B9 3A         cmp al, $3A        ; check if ':'
0206+  14EA C7 02 15      jne get_token_angle
0207+  14ED F7            stosb          ; store ':' into token string
0208+  14EE 19 00         mov al, 0
0209+  14F0 F7            stosb          ; terminate token string
0210+  14F1 19 0A         mov al, TOK_COLON
0211+  14F3 3D F5 15      mov [tok], al      
0212+  14F6 19 02         mov al, TOKTYP_DELIMITER
0213+  14F8 3D F4 15      mov [toktyp], al
0214+  14FB 4E            mov a, si
0215+  14FC 42 F2 15      mov [prog], a    ; update pointer
0216+  14FF 0A 80 15      jmp get_token_return
0217+  1502             get_token_angle:
0218+  1502 B9 3E         cmp al, $3E        ; check if '>'
0219+  1504 C7 1C 15      jne get_token_tilde
0220+  1507 F7            stosb          ; store '>' into token string
0221+  1508 19 00         mov al, 0
0222+  150A F7            stosb          ; terminate token string
0223+  150B 19 07         mov al, TOK_ANGLE
0224+  150D 3D F5 15      mov [tok], al      
0225+  1510 19 02         mov al, TOKTYP_DELIMITER
0226+  1512 3D F4 15      mov [toktyp], al
0227+  1515 4E            mov a, si
0228+  1516 42 F2 15      mov [prog], a    ; update pointer
0229+  1519 0A 80 15      jmp get_token_return
0230+  151C             get_token_tilde:
0231+  151C B9 7E         cmp al, '~'        ; check if '~'
0232+  151E C7 36 15      jne get_token_equal
0233+  1521 F7            stosb          ; store '~' into token string
0234+  1522 19 00         mov al, 0
0235+  1524 F7            stosb          ; terminate token string
0236+  1525 19 08         mov al, TOK_TILDE
0237+  1527 3D F5 15      mov [tok], al      
0238+  152A 19 02         mov al, TOKTYP_DELIMITER
0239+  152C 3D F4 15      mov [toktyp], al
0240+  152F 4E            mov a, si
0241+  1530 42 F2 15      mov [prog], a    ; update pointer
0242+  1533 0A 80 15      jmp get_token_return
0243+  1536             get_token_equal:
0244+  1536 B9 3D         cmp al, '='        ; check if '='
0245+  1538 C7 50 15      jne get_token_skip
0246+  153B F7            stosb          ; store '=' into token string
0247+  153C 19 00         mov al, 0
0248+  153E F7            stosb          ; terminate token string
0249+  153F 19 09         mov al, TOK_EQUAL
0250+  1541 3D F5 15      mov [tok], al      
0251+  1544 19 02         mov al, TOKTYP_DELIMITER
0252+  1546 3D F4 15      mov [toktyp], al
0253+  1549 4E            mov a, si
0254+  154A 42 F2 15      mov [prog], a    ; update pointer
0255+  154D 0A 80 15      jmp get_token_return
0256+  1550             get_token_skip:
0257+  1550 4E            mov a, si
0258+  1551 42 F2 15      mov [prog], a    ; update pointer
0259+  1554 0A 80 15      jmp get_token_return
0260+  1557             get_token_end:        ; end of file token
0261+  1557 19 14         mov al, TOK_END
0262+  1559 3D F5 15      mov [tok], al
0263+  155C 19 06         mov al, TOKTYP_END
0264+  155E 3D F4 15      mov [toktyp], al
0265+  1561 0A 80 15      jmp get_token_return
0266+  1564             is_alphanumeric:
0267+  1564 F7            stosb
0268+  1565 F6            lodsb
0269+  1566 07 2B 13      call _isalnum      ;check if is alphanumeric
0270+  1569 C6 64 15      jz is_alphanumeric
0271+  156C B9 2E         cmp al, $2E        ; check if is '.'
0272+  156E C6 64 15      je is_alphanumeric
0273+  1571 19 00         mov al, 0
0274+  1573 F7            stosb
0275+  1574 19 00         mov al, TOKTYP_IDENTIFIER
0276+  1576 3D F4 15      mov [toktyp], al
0277+  1579 D5 01 00      sub si, 1
0278+  157C 4E            mov a, si
0279+  157D 42 F2 15      mov [prog], a    ; update pointer
0280+  1580             get_token_return:
0281+  1580 F0            pop di
0282+  1581 EF            pop si
0283+  1582 E7            pop d
0284+  1583 E4            pop a
0285+  1584 09            ret
0286+  1585             get_tok_comment:
0287+  1585 F6            lodsb
0288+  1586 B9 0A         cmp al, $0A      ; new line
0289+  1588 C7 85 15      jne get_tok_comment
0290+  158B 0A 69 14      jmp get_tok_skip_spaces
0291+  158E             
0292+  158E             
0293+  158E             get_number:
0294+  158E D7            push a
0295+  158F DA            push d
0296+  1590 E2            push si
0297+  1591 E3            push di
0298+  1592 19 00         mov al, 0
0299+  1594 3D F6 15      mov [tokstr], al      ; nullify tokstr string
0300+  1597 19 00         mov al, TOK_NULL
0301+  1599 3D F5 15      mov [tok], al        ; nullify token
0302+  159C 14 F2 15      mov a, [prog]
0303+  159F 4D            mov si, a
0304+  15A0 FD 4F F6 15   mov di, tokstr
0305+  15A4             get_number_skip_spaces:
0306+  15A4 F6            lodsb
0307+  15A5 07 A1 13      call _isspace
0308+  15A8 C6 A4 15      je get_number_skip_spaces
0309+  15AB B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  15AD C7 BD 15      jne get_number_L0
0311+  15B0 19 14         mov al, TOK_END
0312+  15B2 3D F5 15      mov [tok], al
0313+  15B5 19 06         mov al, TOKTYP_END
0314+  15B7 3D F4 15      mov [toktyp], al
0315+  15BA 0A D4 15      jmp get_number_return
0316+  15BD             get_number_L0:
0317+  15BD F7            stosb
0318+  15BE F6            lodsb
0319+  15BF 07 35 13      call _isdigit      ;check if is numeric
0320+  15C2 C6 BD 15      jz get_number_L0
0321+  15C5 19 00         mov al, 0
0322+  15C7 F7            stosb
0323+  15C8 19 05         mov al, TOKTYP_NUMERIC
0324+  15CA 3D F4 15      mov [toktyp], al
0325+  15CD D5 01 00      sub si, 1
0326+  15D0 4E            mov a, si
0327+  15D1 42 F2 15      mov [prog], a    ; update pointer
0328+  15D4             get_number_return:
0329+  15D4 F0            pop di
0330+  15D5 EF            pop si
0331+  15D6 E7            pop d
0332+  15D7 E4            pop a
0333+  15D8 09            ret
0334+  15D9             
0335+  15D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  15D9             ;; PUT BACK TOKEN
0337+  15D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  15D9             _putback:
0339+  15D9 D7            push a
0340+  15DA E2            push si
0341+  15DB FD 4D F6 15   mov si, tokstr  
0342+  15DF             _putback_loop:
0343+  15DF F6            lodsb
0344+  15E0 B9 00         cmp al, 0
0345+  15E2 C6 EF 15      je _putback_end
0346+  15E5 14 F2 15      mov a, [prog]
0347+  15E8 7D            dec a
0348+  15E9 42 F2 15      mov [prog], a      ; update pointer
0349+  15EC 0A DF 15      jmp _putback_loop
0350+  15EF             _putback_end:
0351+  15EF EF            pop si
0352+  15F0 E4            pop a
0353+  15F1 09            ret
0354+  15F2             
0355+  15F2             
0356+  15F2             
0357+  15F2             
0358+  15F2 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  15F4             
0360+  15F4 00          toktyp:    .db 0          ; token type symbol
0361+  15F5 00          tok:       .db 0          ; current token symbol
0362+  15F6 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  15FA 00 00 00 00 
0362+  15FE 00 00 00 00 
0362+  1602 00 00 00 00 
0362+  1606 00 00 00 00 
0362+  160A 00 00 00 00 
0362+  160E 00 00 00 00 
0362+  1612 00 00 00 00 
0362+  1616 00 00 00 00 
0362+  161A 00 00 00 00 
0362+  161E 00 00 00 00 
0362+  1622 00 00 00 00 
0362+  1626 00 00 00 00 
0362+  162A 00 00 00 00 
0362+  162E 00 00 00 00 
0362+  1632 00 00 00 00 
0362+  1636 00 00 00 00 
0362+  163A 00 00 00 00 
0362+  163E 00 00 00 00 
0362+  1642 00 00 00 00 
0362+  1646 00 00 00 00 
0362+  164A 00 00 00 00 
0362+  164E 00 00 00 00 
0362+  1652 00 00 00 00 
0362+  1656 00 00 00 00 
0362+  165A 00 00 00 00 
0362+  165E 00 00 00 00 
0362+  1662 00 00 00 00 
0362+  1666 00 00 00 00 
0362+  166A 00 00 00 00 
0362+  166E 00 00 00 00 
0362+  1672 00 00 00 00 
0362+  1676 00 00 00 00 
0362+  167A 00 00 00 00 
0362+  167E 00 00 00 00 
0362+  1682 00 00 00 00 
0362+  1686 00 00 00 00 
0362+  168A 00 00 00 00 
0362+  168E 00 00 00 00 
0362+  1692 00 00 00 00 
0362+  1696 00 00 00 00 
0362+  169A 00 00 00 00 
0362+  169E 00 00 00 00 
0362+  16A2 00 00 00 00 
0362+  16A6 00 00 00 00 
0362+  16AA 00 00 00 00 
0362+  16AE 00 00 00 00 
0362+  16B2 00 00 00 00 
0362+  16B6 00 00 00 00 
0362+  16BA 00 00 00 00 
0362+  16BE 00 00 00 00 
0362+  16C2 00 00 00 00 
0362+  16C6 00 00 00 00 
0362+  16CA 00 00 00 00 
0362+  16CE 00 00 00 00 
0362+  16D2 00 00 00 00 
0362+  16D6 00 00 00 00 
0362+  16DA 00 00 00 00 
0362+  16DE 00 00 00 00 
0362+  16E2 00 00 00 00 
0362+  16E6 00 00 00 00 
0362+  16EA 00 00 00 00 
0362+  16EE 00 00 00 00 
0362+  16F2 00 00 00 00 
2534   16F6             
2535   16F6             ; Kernel parameters
2536   16F6 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2537   16F7 01          sys_echo_on:        .db 1
2538   16F8 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2539   16F9 01          sys_uart0_inten:    .db 1
2540   16FA 00          sys_uart0_fifoen:   .db 0
2541   16FB 0C          sys_uart0_div0:     .db 12  ;
2542   16FC 00          sys_uart0_div1:     .db 0   ; default baud = 9600
2543   16FD             
2544   16FD 00          nbr_active_procs:   .db 0
2545   16FE 01          active_proc_index:  .db 1
2546   16FF             
2547   16FF 00 00       index:              .dw 0
2548   1701 00 00       buffer_addr:        .dw 0
2549   1703             
2550   1703 F5 1D       fifo_in:            .dw fifo
2551   1705 F5 1D       fifo_out:           .dw fifo
2552   1707             
2553   1707             ; file system variables
2554   1707 00 00       current_dir_id:     .dw 0     ; keep dirID of current directory
2555   1709 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2555   170D 6E 2F 69 6E 
2555   1711 69 74 00 
2556   1714             
2557   1714 3E 20 00    s_dataentry:        .db "> ", 0
2558   1717 2E 2E 00    s_parent_dir:       .db "..", 0
2559   171A 2E 00       s_current_dir:      .db ".", 0
2560   171C 2F 00       s_fslash:           .db "/", 0
2561   171E 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2561   1722 78 
2562   1723 2D 64 63    file_type:          .db "-dc"
2563   1726 50 49 44 20 s_ps_header:        .db "PID COMMAND\n", 0
2563   172A 43 4F 4D 4D 
2563   172E 41 4E 44 0A 
2563   1732 00 
2564   1733 54 6F 74 61 s_ls_total:         .db "Total: ", 0
2564   1737 6C 3A 20 00 
2565   173B             
2566   173B 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2566   173F 20 65 6E 61 
2566   1743 62 6C 65 64 
2566   1747 0A 00 
2567   1749 6B 65 72 6E s_kernel_started:   .db "kernel started\n", 0
2567   174D 65 6C 20 73 
2567   1751 74 61 72 74 
2567   1755 65 64 0A 00 
2568   1759 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2568   175D 74 69 6E 67 
2568   1761 20 69 6E 69 
2568   1765 74 0A 00 
2569   1768 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2569   176C 65 70 74 69 
2569   1770 6F 6E 3A 20 
2569   1774 70 72 69 76 
2569   1778 69 6C 65 67 
2569   177C 65 0A 00 
2570   177F 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2570   1783 65 70 74 69 
2570   1787 6F 6E 3A 20 
2570   178B 7A 65 72 6F 
2570   178F 20 64 69 76 
2570   1793 69 73 69 6F 
2570   1797 6E 0A 00 
2571   179A             
2572   179A 59 65 61 72 s_set_year:         .db "Year: ", 0
2572   179E 3A 20 00 
2573   17A1 4D 6F 6E 74 s_set_month:        .db "Month: ", 0
2573   17A5 68 3A 20 00 
2574   17A9 44 61 79 3A s_set_day:          .db "Day: ", 0
2574   17AD 20 00 
2575   17AF 57 65 65 6B s_set_week:         .db "Weekday: ", 0
2575   17B3 64 61 79 3A 
2575   17B7 20 00 
2576   17B9 48 6F 75 72 s_set_hours:        .db "Hours: ", 0
2576   17BD 73 3A 20 00 
2577   17C1 4D 69 6E 75 s_set_minutes:      .db "Minutes: ", 0
2577   17C5 74 65 73 3A 
2577   17C9 20 00 
2578   17CB 53 65 63 6F s_set_seconds:      .db "Seconds: ", 0
2578   17CF 6E 64 73 3A 
2578   17D3 20 00 
2579   17D5             s_months:      
2580   17D5 20 20 20 00   .db "   ", 0
2581   17D9 4A 61 6E 00   .db "Jan", 0
2582   17DD 46 65 62 00   .db "Feb", 0
2583   17E1 4D 61 72 00   .db "Mar", 0
2584   17E5 41 70 72 00   .db "Apr", 0
2585   17E9 4D 61 79 00   .db "May", 0
2586   17ED 4A 75 6E 00   .db "Jun", 0
2587   17F1 4A 75 6C 00   .db "Jul", 0
2588   17F5 41 75 67 00   .db "Aug", 0
2589   17F9 53 65 70 00   .db "Sep", 0
2590   17FD 4F 63 74 00   .db "Oct", 0
2591   1801 4E 6F 76 00   .db "Nov", 0
2592   1805 44 65 63 00   .db "Dec", 0
2593   1809             
2594   1809             s_week:        
2595   1809 53 75 6E 00   .db "Sun", 0 
2596   180D 4D 6F 6E 00   .db "Mon", 0 
2597   1811 54 75 65 00   .db "Tue", 0 
2598   1815 57 65 64 00   .db "Wed", 0 
2599   1819 54 68 75 00   .db "Thu", 0 
2600   181D 46 72 69 00   .db "Fri", 0 
2601   1821 53 61 74 00   .db "Sat", 0
2602   1825             
2603   1825 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2603   1829 00 00 00 00 
2603   182D 00 00 00 00 
2603   1831 00 00 00 00 
2603   1835 00 00 00 00 
2603   1839 00 00 00 00 
2603   183D 00 00 00 00 
2603   1841 00 00 00 00 
2603   1845 00 00 00 00 
2603   1849 00 00 00 00 
2603   184D 00 00 00 00 
2603   1851 00 00 00 00 
2603   1855 00 00 00 00 
2603   1859 00 00 00 00 
2603   185D 00 00 00 00 
2603   1861 00 00 00 00 
2603   1865 00 00 00 00 
2603   1869 00 00 00 00 
2603   186D 00 00 00 00 
2603   1871 00 00 00 00 
2603   1875 00 00 00 00 
2603   1879 00 00 00 00 
2603   187D 00 00 00 00 
2603   1881 00 00 00 00 
2603   1885 00 00 00 00 
2603   1889 00 00 00 00 
2603   188D 00 00 00 00 
2603   1891 00 00 00 00 
2603   1895 00 00 00 00 
2603   1899 00 00 00 00 
2603   189D 00 00 00 00 
2603   18A1 00 00 00 00 
2603   18A5 00 00 00 00 
2603   18A9 00 00 00 00 
2603   18AD 00 00 00 00 
2603   18B1 00 00 00 00 
2603   18B5 00 00 00 00 
2603   18B9 00 00 00 00 
2603   18BD 00 00 00 00 
2603   18C1 00 00 00 00 
2603   18C5 00 00 00 00 
2603   18C9 00 00 00 00 
2603   18CD 00 00 00 00 
2603   18D1 00 00 00 00 
2603   18D5 00 00 00 00 
2603   18D9 00 00 00 00 
2603   18DD 00 00 00 00 
2603   18E1 00 00 00 00 
2603   18E5 00 00 00 00 
2603   18E9 00 00 00 00 
2603   18ED 00 00 00 00 
2603   18F1 00 00 00 00 
2603   18F5 00 00 00 00 
2603   18F9 00 00 00 00 
2603   18FD 00 00 00 00 
2603   1901 00 00 00 00 
2603   1905 00 00 00 00 
2603   1909 00 00 00 00 
2603   190D 00 00 00 00 
2603   1911 00 00 00 00 
2603   1915 00 00 00 00 
2603   1919 00 00 00 00 
2603   191D 00 00 00 00 
2603   1921 00 00 00 00 
2603   1925 00 00 00 00 
2603   1929 00 00 00 00 
2603   192D 00 00 00 00 
2603   1931 00 00 00 00 
2603   1935 00 00 00 00 
2603   1939 00 00 00 00 
2603   193D 00 00 00 00 
2603   1941 00 00 00 00 
2603   1945 00 00 00 00 
2603   1949 00 00 00 00 
2603   194D 00 00 00 00 
2603   1951 00 00 00 00 
2603   1955 00 00 00 00 
2603   1959 00 00 00 00 
2603   195D 00 00 00 00 
2603   1961 00 00 00 00 
2604   1965 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2604   1969 00 00 00 00 
2604   196D 00 00 00 00 
2604   1971 00 00 00 00 
2605   1975 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2605   1979 00 00 00 00 
2605   197D 00 00 00 00 
2605   1981 00 00 00 00 
2605   1985 00 00 00 00 
2605   1989 00 00 00 00 
2605   198D 00 00 00 00 
2605   1991 00 00 00 00 
2605   1995 00 00 00 00 
2605   1999 00 00 00 00 
2605   199D 00 00 00 00 
2605   19A1 00 00 00 00 
2605   19A5 00 00 00 00 
2605   19A9 00 00 00 00 
2605   19AD 00 00 00 00 
2605   19B1 00 00 00 00 
2605   19B5 00 00 00 00 
2605   19B9 00 00 00 00 
2605   19BD 00 00 00 00 
2605   19C1 00 00 00 00 
2605   19C5 00 00 00 00 
2605   19C9 00 00 00 00 
2605   19CD 00 00 00 00 
2605   19D1 00 00 00 00 
2605   19D5 00 00 00 00 
2605   19D9 00 00 00 00 
2605   19DD 00 00 00 00 
2605   19E1 00 00 00 00 
2605   19E5 00 00 00 00 
2605   19E9 00 00 00 00 
2605   19ED 00 00 00 00 
2605   19F1 00 00 00 00 
2605   19F5 00 00 00 00 
2605   19F9 00 00 00 00 
2605   19FD 00 00 00 00 
2605   1A01 00 00 00 00 
2605   1A05 00 00 00 00 
2605   1A09 00 00 00 00 
2605   1A0D 00 00 00 00 
2605   1A11 00 00 00 00 
2605   1A15 00 00 00 00 
2605   1A19 00 00 00 00 
2605   1A1D 00 00 00 00 
2605   1A21 00 00 00 00 
2605   1A25 00 00 00 00 
2605   1A29 00 00 00 00 
2605   1A2D 00 00 00 00 
2605   1A31 00 00 00 00 
2605   1A35 00 00 00 00 
2605   1A39 00 00 00 00 
2605   1A3D 00 00 00 00 
2605   1A41 00 00 00 00 
2605   1A45 00 00 00 00 
2605   1A49 00 00 00 00 
2605   1A4D 00 00 00 00 
2605   1A51 00 00 00 00 
2605   1A55 00 00 00 00 
2605   1A59 00 00 00 00 
2605   1A5D 00 00 00 00 
2605   1A61 00 00 00 00 
2605   1A65 00 00 00 00 
2605   1A69 00 00 00 00 
2605   1A6D 00 00 00 00 
2605   1A71 00 00 00 00 
2605   1A75 00 00 00 00 
2605   1A79 00 00 00 00 
2605   1A7D 00 00 00 00 
2605   1A81 00 00 00 00 
2605   1A85 00 00 00 00 
2605   1A89 00 00 00 00 
2605   1A8D 00 00 00 00 
2605   1A91 00 00 00 00 
2605   1A95 00 00 00 00 
2605   1A99 00 00 00 00 
2605   1A9D 00 00 00 00 
2605   1AA1 00 00 00 00 
2605   1AA5 00 00 00 00 
2605   1AA9 00 00 00 00 
2605   1AAD 00 00 00 00 
2605   1AB1 00 00 00 00 
2605   1AB5 00 00 00 00 
2605   1AB9 00 00 00 00 
2605   1ABD 00 00 00 00 
2605   1AC1 00 00 00 00 
2605   1AC5 00 00 00 00 
2605   1AC9 00 00 00 00 
2605   1ACD 00 00 00 00 
2605   1AD1 00 00 00 00 
2605   1AD5 00 00 00 00 
2605   1AD9 00 00 00 00 
2605   1ADD 00 00 00 00 
2605   1AE1 00 00 00 00 
2605   1AE5 00 00 00 00 
2605   1AE9 00 00 00 00 
2605   1AED 00 00 00 00 
2605   1AF1 00 00 00 00 
2605   1AF5 00 00 00 00 
2605   1AF9 00 00 00 00 
2605   1AFD 00 00 00 00 
2605   1B01 00 00 00 00 
2605   1B05 00 00 00 00 
2605   1B09 00 00 00 00 
2605   1B0D 00 00 00 00 
2605   1B11 00 00 00 00 
2605   1B15 00 00 00 00 
2605   1B19 00 00 00 00 
2605   1B1D 00 00 00 00 
2605   1B21 00 00 00 00 
2605   1B25 00 00 00 00 
2605   1B29 00 00 00 00 
2605   1B2D 00 00 00 00 
2605   1B31 00 00 00 00 
2605   1B35 00 00 00 00 
2605   1B39 00 00 00 00 
2605   1B3D 00 00 00 00 
2605   1B41 00 00 00 00 
2605   1B45 00 00 00 00 
2605   1B49 00 00 00 00 
2605   1B4D 00 00 00 00 
2605   1B51 00 00 00 00 
2605   1B55 00 00 00 00 
2605   1B59 00 00 00 00 
2605   1B5D 00 00 00 00 
2605   1B61 00 00 00 00 
2605   1B65 00 00 00 00 
2605   1B69 00 00 00 00 
2605   1B6D 00 00 00 00 
2605   1B71 00 00 00 00 
2606   1B75 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2606   1B79 00 00 00 00 
2606   1B7D 00 00 00 00 
2606   1B81 00 00 00 00 
2606   1B85 00 00 00 00 
2606   1B89 00 00 00 00 
2606   1B8D 00 00 00 00 
2606   1B91 00 00 00 00 
2606   1B95 00 00 00 00 
2606   1B99 00 00 00 00 
2606   1B9D 00 00 00 00 
2606   1BA1 00 00 00 00 
2606   1BA5 00 00 00 00 
2606   1BA9 00 00 00 00 
2606   1BAD 00 00 00 00 
2606   1BB1 00 00 00 00 
2606   1BB5 00 00 00 00 
2606   1BB9 00 00 00 00 
2606   1BBD 00 00 00 00 
2606   1BC1 00 00 00 00 
2606   1BC5 00 00 00 00 
2606   1BC9 00 00 00 00 
2606   1BCD 00 00 00 00 
2606   1BD1 00 00 00 00 
2606   1BD5 00 00 00 00 
2606   1BD9 00 00 00 00 
2606   1BDD 00 00 00 00 
2606   1BE1 00 00 00 00 
2606   1BE5 00 00 00 00 
2606   1BE9 00 00 00 00 
2606   1BED 00 00 00 00 
2606   1BF1 00 00 00 00 
2607   1BF5 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2607   1BF9 00 00 00 00 
2607   1BFD 00 00 00 00 
2607   1C01 00 00 00 00 
2607   1C05 00 00 00 00 
2607   1C09 00 00 00 00 
2607   1C0D 00 00 00 00 
2607   1C11 00 00 00 00 
2607   1C15 00 00 00 00 
2607   1C19 00 00 00 00 
2607   1C1D 00 00 00 00 
2607   1C21 00 00 00 00 
2607   1C25 00 00 00 00 
2607   1C29 00 00 00 00 
2607   1C2D 00 00 00 00 
2607   1C31 00 00 00 00 
2607   1C35 00 00 00 00 
2607   1C39 00 00 00 00 
2607   1C3D 00 00 00 00 
2607   1C41 00 00 00 00 
2607   1C45 00 00 00 00 
2607   1C49 00 00 00 00 
2607   1C4D 00 00 00 00 
2607   1C51 00 00 00 00 
2607   1C55 00 00 00 00 
2607   1C59 00 00 00 00 
2607   1C5D 00 00 00 00 
2607   1C61 00 00 00 00 
2607   1C65 00 00 00 00 
2607   1C69 00 00 00 00 
2607   1C6D 00 00 00 00 
2607   1C71 00 00 00 00 
2607   1C75 00 00 00 00 
2607   1C79 00 00 00 00 
2607   1C7D 00 00 00 00 
2607   1C81 00 00 00 00 
2607   1C85 00 00 00 00 
2607   1C89 00 00 00 00 
2607   1C8D 00 00 00 00 
2607   1C91 00 00 00 00 
2607   1C95 00 00 00 00 
2607   1C99 00 00 00 00 
2607   1C9D 00 00 00 00 
2607   1CA1 00 00 00 00 
2607   1CA5 00 00 00 00 
2607   1CA9 00 00 00 00 
2607   1CAD 00 00 00 00 
2607   1CB1 00 00 00 00 
2607   1CB5 00 00 00 00 
2607   1CB9 00 00 00 00 
2607   1CBD 00 00 00 00 
2607   1CC1 00 00 00 00 
2607   1CC5 00 00 00 00 
2607   1CC9 00 00 00 00 
2607   1CCD 00 00 00 00 
2607   1CD1 00 00 00 00 
2607   1CD5 00 00 00 00 
2607   1CD9 00 00 00 00 
2607   1CDD 00 00 00 00 
2607   1CE1 00 00 00 00 
2607   1CE5 00 00 00 00 
2607   1CE9 00 00 00 00 
2607   1CED 00 00 00 00 
2607   1CF1 00 00 00 00 
2607   1CF5 00 00 00 00 
2607   1CF9 00 00 00 00 
2607   1CFD 00 00 00 00 
2607   1D01 00 00 00 00 
2607   1D05 00 00 00 00 
2607   1D09 00 00 00 00 
2607   1D0D 00 00 00 00 
2607   1D11 00 00 00 00 
2607   1D15 00 00 00 00 
2607   1D19 00 00 00 00 
2607   1D1D 00 00 00 00 
2607   1D21 00 00 00 00 
2607   1D25 00 00 00 00 
2607   1D29 00 00 00 00 
2607   1D2D 00 00 00 00 
2607   1D31 00 00 00 00 
2607   1D35 00 00 00 00 
2607   1D39 00 00 00 00 
2607   1D3D 00 00 00 00 
2607   1D41 00 00 00 00 
2607   1D45 00 00 00 00 
2607   1D49 00 00 00 00 
2607   1D4D 00 00 00 00 
2607   1D51 00 00 00 00 
2607   1D55 00 00 00 00 
2607   1D59 00 00 00 00 
2607   1D5D 00 00 00 00 
2607   1D61 00 00 00 00 
2607   1D65 00 00 00 00 
2607   1D69 00 00 00 00 
2607   1D6D 00 00 00 00 
2607   1D71 00 00 00 00 
2607   1D75 00 00 00 00 
2607   1D79 00 00 00 00 
2607   1D7D 00 00 00 00 
2607   1D81 00 00 00 00 
2607   1D85 00 00 00 00 
2607   1D89 00 00 00 00 
2607   1D8D 00 00 00 00 
2607   1D91 00 00 00 00 
2607   1D95 00 00 00 00 
2607   1D99 00 00 00 00 
2607   1D9D 00 00 00 00 
2607   1DA1 00 00 00 00 
2607   1DA5 00 00 00 00 
2607   1DA9 00 00 00 00 
2607   1DAD 00 00 00 00 
2607   1DB1 00 00 00 00 
2607   1DB5 00 00 00 00 
2607   1DB9 00 00 00 00 
2607   1DBD 00 00 00 00 
2607   1DC1 00 00 00 00 
2607   1DC5 00 00 00 00 
2607   1DC9 00 00 00 00 
2607   1DCD 00 00 00 00 
2607   1DD1 00 00 00 00 
2607   1DD5 00 00 00 00 
2607   1DD9 00 00 00 00 
2607   1DDD 00 00 00 00 
2607   1DE1 00 00 00 00 
2607   1DE5 00 00 00 00 
2607   1DE9 00 00 00 00 
2607   1DED 00 00 00 00 
2607   1DF1 00 00 00 00 
2608   1DF5 FF FF FF FF fifo:               .fill FIFO_SIZE
2608   1DF9 FF FF FF FF 
2608   1DFD FF FF FF FF 
2608   1E01 FF FF FF FF 
2608   1E05 FF FF FF FF 
2608   1E09 FF FF FF FF 
2608   1E0D FF FF FF FF 
2608   1E11 FF FF FF FF 
2608   1E15 FF FF FF FF 
2608   1E19 FF FF FF FF 
2608   1E1D FF FF FF FF 
2608   1E21 FF FF FF FF 
2608   1E25 FF FF FF FF 
2608   1E29 FF FF FF FF 
2608   1E2D FF FF FF FF 
2608   1E31 FF FF FF FF 
2608   1E35 FF FF FF FF 
2608   1E39 FF FF FF FF 
2608   1E3D FF FF FF FF 
2608   1E41 FF FF FF FF 
2608   1E45 FF FF FF FF 
2608   1E49 FF FF FF FF 
2608   1E4D FF FF FF FF 
2608   1E51 FF FF FF FF 
2608   1E55 FF FF FF FF 
2608   1E59 FF FF FF FF 
2608   1E5D FF FF FF FF 
2608   1E61 FF FF FF FF 
2608   1E65 FF FF FF FF 
2608   1E69 FF FF FF FF 
2608   1E6D FF FF FF FF 
2608   1E71 FF FF FF FF 
2608   1E75 FF FF FF FF 
2608   1E79 FF FF FF FF 
2608   1E7D FF FF FF FF 
2608   1E81 FF FF FF FF 
2608   1E85 FF FF FF FF 
2608   1E89 FF FF FF FF 
2608   1E8D FF FF FF FF 
2608   1E91 FF FF FF FF 
2608   1E95 FF FF FF FF 
2608   1E99 FF FF FF FF 
2608   1E9D FF FF FF FF 
2608   1EA1 FF FF FF FF 
2608   1EA5 FF FF FF FF 
2608   1EA9 FF FF FF FF 
2608   1EAD FF FF FF FF 
2608   1EB1 FF FF FF FF 
2608   1EB5 FF FF FF FF 
2608   1EB9 FF FF FF FF 
2608   1EBD FF FF FF FF 
2608   1EC1 FF FF FF FF 
2608   1EC5 FF FF FF FF 
2608   1EC9 FF FF FF FF 
2608   1ECD FF FF FF FF 
2608   1ED1 FF FF FF FF 
2608   1ED5 FF FF FF FF 
2608   1ED9 FF FF FF FF 
2608   1EDD FF FF FF FF 
2608   1EE1 FF FF FF FF 
2608   1EE5 FF FF FF FF 
2608   1EE9 FF FF FF FF 
2608   1EED FF FF FF FF 
2608   1EF1 FF FF FF FF 
2608   1EF5 FF FF FF FF 
2608   1EF9 FF FF FF FF 
2608   1EFD FF FF FF FF 
2608   1F01 FF FF FF FF 
2608   1F05 FF FF FF FF 
2608   1F09 FF FF FF FF 
2608   1F0D FF FF FF FF 
2608   1F11 FF FF FF FF 
2608   1F15 FF FF FF FF 
2608   1F19 FF FF FF FF 
2608   1F1D FF FF FF FF 
2608   1F21 FF FF FF FF 
2608   1F25 FF FF FF FF 
2608   1F29 FF FF FF FF 
2608   1F2D FF FF FF FF 
2608   1F31 FF FF FF FF 
2608   1F35 FF FF FF FF 
2608   1F39 FF FF FF FF 
2608   1F3D FF FF FF FF 
2608   1F41 FF FF FF FF 
2608   1F45 FF FF FF FF 
2608   1F49 FF FF FF FF 
2608   1F4D FF FF FF FF 
2608   1F51 FF FF FF FF 
2608   1F55 FF FF FF FF 
2608   1F59 FF FF FF FF 
2608   1F5D FF FF FF FF 
2608   1F61 FF FF FF FF 
2608   1F65 FF FF FF FF 
2608   1F69 FF FF FF FF 
2608   1F6D FF FF FF FF 
2608   1F71 FF FF FF FF 
2608   1F75 FF FF FF FF 
2608   1F79 FF FF FF FF 
2608   1F7D FF FF FF FF 
2608   1F81 FF FF FF FF 
2608   1F85 FF FF FF FF 
2608   1F89 FF FF FF FF 
2608   1F8D FF FF FF FF 
2608   1F91 FF FF FF FF 
2608   1F95 FF FF FF FF 
2608   1F99 FF FF FF FF 
2608   1F9D FF FF FF FF 
2608   1FA1 FF FF FF FF 
2608   1FA5 FF FF FF FF 
2608   1FA9 FF FF FF FF 
2608   1FAD FF FF FF FF 
2608   1FB1 FF FF FF FF 
2608   1FB5 FF FF FF FF 
2608   1FB9 FF FF FF FF 
2608   1FBD FF FF FF FF 
2608   1FC1 FF FF FF FF 
2608   1FC5 FF FF FF FF 
2608   1FC9 FF FF FF FF 
2608   1FCD FF FF FF FF 
2608   1FD1 FF FF FF FF 
2608   1FD5 FF FF FF FF 
2608   1FD9 FF FF FF FF 
2608   1FDD FF FF FF FF 
2608   1FE1 FF FF FF FF 
2608   1FE5 FF FF FF FF 
2608   1FE9 FF FF FF FF 
2608   1FED FF FF FF FF 
2608   1FF1 FF FF FF FF 
2608   1FF5 FF FF FF FF 
2608   1FF9 FF FF FF FF 
2608   1FFD FF FF FF FF 
2608   2001 FF FF FF FF 
2608   2005 FF FF FF FF 
2608   2009 FF FF FF FF 
2608   200D FF FF FF FF 
2608   2011 FF FF FF FF 
2608   2015 FF FF FF FF 
2608   2019 FF FF FF FF 
2608   201D FF FF FF FF 
2608   2021 FF FF FF FF 
2608   2025 FF FF FF FF 
2608   2029 FF FF FF FF 
2608   202D FF FF FF FF 
2608   2031 FF FF FF FF 
2608   2035 FF FF FF FF 
2608   2039 FF FF FF FF 
2608   203D FF FF FF FF 
2608   2041 FF FF FF FF 
2608   2045 FF FF FF FF 
2608   2049 FF FF FF FF 
2608   204D FF FF FF FF 
2608   2051 FF FF FF FF 
2608   2055 FF FF FF FF 
2608   2059 FF FF FF FF 
2608   205D FF FF FF FF 
2608   2061 FF FF FF FF 
2608   2065 FF FF FF FF 
2608   2069 FF FF FF FF 
2608   206D FF FF FF FF 
2608   2071 FF FF FF FF 
2608   2075 FF FF FF FF 
2608   2079 FF FF FF FF 
2608   207D FF FF FF FF 
2608   2081 FF FF FF FF 
2608   2085 FF FF FF FF 
2608   2089 FF FF FF FF 
2608   208D FF FF FF FF 
2608   2091 FF FF FF FF 
2608   2095 FF FF FF FF 
2608   2099 FF FF FF FF 
2608   209D FF FF FF FF 
2608   20A1 FF FF FF FF 
2608   20A5 FF FF FF FF 
2608   20A9 FF FF FF FF 
2608   20AD FF FF FF FF 
2608   20B1 FF FF FF FF 
2608   20B5 FF FF FF FF 
2608   20B9 FF FF FF FF 
2608   20BD FF FF FF FF 
2608   20C1 FF FF FF FF 
2608   20C5 FF FF FF FF 
2608   20C9 FF FF FF FF 
2608   20CD FF FF FF FF 
2608   20D1 FF FF FF FF 
2608   20D5 FF FF FF FF 
2608   20D9 FF FF FF FF 
2608   20DD FF FF FF FF 
2608   20E1 FF FF FF FF 
2608   20E5 FF FF FF FF 
2608   20E9 FF FF FF FF 
2608   20ED FF FF FF FF 
2608   20F1 FF FF FF FF 
2608   20F5 FF FF FF FF 
2608   20F9 FF FF FF FF 
2608   20FD FF FF FF FF 
2608   2101 FF FF FF FF 
2608   2105 FF FF FF FF 
2608   2109 FF FF FF FF 
2608   210D FF FF FF FF 
2608   2111 FF FF FF FF 
2608   2115 FF FF FF FF 
2608   2119 FF FF FF FF 
2608   211D FF FF FF FF 
2608   2121 FF FF FF FF 
2608   2125 FF FF FF FF 
2608   2129 FF FF FF FF 
2608   212D FF FF FF FF 
2608   2131 FF FF FF FF 
2608   2135 FF FF FF FF 
2608   2139 FF FF FF FF 
2608   213D FF FF FF FF 
2608   2141 FF FF FF FF 
2608   2145 FF FF FF FF 
2608   2149 FF FF FF FF 
2608   214D FF FF FF FF 
2608   2151 FF FF FF FF 
2608   2155 FF FF FF FF 
2608   2159 FF FF FF FF 
2608   215D FF FF FF FF 
2608   2161 FF FF FF FF 
2608   2165 FF FF FF FF 
2608   2169 FF FF FF FF 
2608   216D FF FF FF FF 
2608   2171 FF FF FF FF 
2608   2175 FF FF FF FF 
2608   2179 FF FF FF FF 
2608   217D FF FF FF FF 
2608   2181 FF FF FF FF 
2608   2185 FF FF FF FF 
2608   2189 FF FF FF FF 
2608   218D FF FF FF FF 
2608   2191 FF FF FF FF 
2608   2195 FF FF FF FF 
2608   2199 FF FF FF FF 
2608   219D FF FF FF FF 
2608   21A1 FF FF FF FF 
2608   21A5 FF FF FF FF 
2608   21A9 FF FF FF FF 
2608   21AD FF FF FF FF 
2608   21B1 FF FF FF FF 
2608   21B5 FF FF FF FF 
2608   21B9 FF FF FF FF 
2608   21BD FF FF FF FF 
2608   21C1 FF FF FF FF 
2608   21C5 FF FF FF FF 
2608   21C9 FF FF FF FF 
2608   21CD FF FF FF FF 
2608   21D1 FF FF FF FF 
2608   21D5 FF FF FF FF 
2608   21D9 FF FF FF FF 
2608   21DD FF FF FF FF 
2608   21E1 FF FF FF FF 
2608   21E5 FF FF FF FF 
2608   21E9 FF FF FF FF 
2608   21ED FF FF FF FF 
2608   21F1 FF FF FF FF 
2609   21F5             
2610   21F5 FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2610   21F9 FF FF FF FF 
2610   21FD FF FF FF FF 
2610   2201 FF FF FF FF 
2610   2205 FF FF FF FF 
2610   2209 FF FF FF FF 
2610   220D FF FF FF FF 
2610   2211 FF FF FF FF 
2610   2215 FF FF FF FF 
2610   2219 FF FF FF FF 
2610   221D FF FF FF FF 
2610   2221 FF FF FF FF 
2610   2225 FF FF FF FF 
2610   2229 FF FF FF FF 
2610   222D FF FF FF FF 
2610   2231 FF FF FF FF 
2610   2235 FF FF FF FF 
2610   2239 FF FF FF FF 
2610   223D FF FF FF FF 
2610   2241 FF FF FF FF 
2610   2245 FF FF FF FF 
2610   2249 FF FF FF FF 
2610   224D FF FF FF FF 
2610   2251 FF FF FF FF 
2610   2255 FF FF FF FF 
2610   2259 FF FF FF FF 
2610   225D FF FF FF FF 
2610   2261 FF FF FF FF 
2610   2265 FF FF FF FF 
2610   2269 FF FF FF FF 
2610   226D FF FF FF FF 
2610   2271 FF FF FF FF 
2610   2275 FF FF FF FF 
2610   2279 FF FF FF FF 
2610   227D FF FF FF FF 
2610   2281 FF FF FF FF 
2610   2285 FF FF FF FF 
2610   2289 FF FF FF FF 
2610   228D FF FF FF FF 
2610   2291 FF FF FF FF 
2610   2295 FF FF FF FF 
2610   2299 FF FF FF FF 
2610   229D FF FF FF FF 
2610   22A1 FF FF FF FF 
2610   22A5 FF FF FF FF 
2610   22A9 FF FF FF FF 
2610   22AD FF FF FF FF 
2610   22B1 FF FF FF FF 
2610   22B5 FF FF FF FF 
2610   22B9 FF FF FF FF 
2610   22BD FF FF FF FF 
2610   22C1 FF FF FF FF 
2610   22C5 FF FF FF FF 
2610   22C9 FF FF FF FF 
2610   22CD FF FF FF FF 
2610   22D1 FF FF FF FF 
2610   22D5 FF FF FF FF 
2610   22D9 FF FF FF FF 
2610   22DD FF FF FF FF 
2610   22E1 FF FF FF FF 
2610   22E5 FF FF FF FF 
2610   22E9 FF FF FF FF 
2610   22ED FF FF FF FF 
2610   22F1 FF FF FF FF 
2610   22F5 FF FF FF FF 
2610   22F9 FF FF FF FF 
2610   22FD FF FF FF FF 
2610   2301 FF FF FF FF 
2610   2305 FF FF FF FF 
2610   2309 FF FF FF FF 
2610   230D FF FF FF FF 
2610   2311 FF FF FF FF 
2610   2315 FF FF FF FF 
2610   2319 FF FF FF FF 
2610   231D FF FF FF FF 
2610   2321 FF FF FF FF 
2610   2325 FF FF FF FF 
2610   2329 FF FF FF FF 
2610   232D FF FF FF FF 
2610   2331 FF FF FF FF 
2610   2335 FF FF FF FF 
2610   2339 FF FF FF FF 
2610   233D FF FF FF FF 
2610   2341 FF FF FF FF 
2610   2345 FF FF FF FF 
2610   2349 FF FF FF FF 
2610   234D FF FF FF FF 
2610   2351 FF FF FF FF 
2610   2355 FF FF FF FF 
2610   2359 FF FF FF FF 
2610   235D FF FF FF FF 
2610   2361 FF FF FF FF 
2610   2365 FF FF FF FF 
2610   2369 FF FF FF FF 
2610   236D FF FF FF FF 
2610   2371 FF FF FF FF 
2610   2375 FF FF FF FF 
2610   2379 FF FF FF FF 
2610   237D FF FF FF FF 
2610   2381 FF FF FF FF 
2610   2385 FF FF FF FF 
2610   2389 FF FF FF FF 
2610   238D FF FF FF FF 
2610   2391 FF FF FF FF 
2610   2395 FF FF FF FF 
2610   2399 FF FF FF FF 
2610   239D FF FF FF FF 
2610   23A1 FF FF FF FF 
2610   23A5 FF FF FF FF 
2610   23A9 FF FF FF FF 
2610   23AD FF FF FF FF 
2610   23B1 FF FF FF FF 
2610   23B5 FF FF FF FF 
2610   23B9 FF FF FF FF 
2610   23BD FF FF FF FF 
2610   23C1 FF FF FF FF 
2610   23C5 FF FF FF FF 
2610   23C9 FF FF FF FF 
2610   23CD FF FF FF FF 
2610   23D1 FF FF FF FF 
2610   23D5 FF FF FF FF 
2610   23D9 FF FF FF FF 
2610   23DD FF FF FF FF 
2610   23E1 FF FF FF FF 
2610   23E5 FF FF FF FF 
2610   23E9 FF FF FF FF 
2610   23ED FF FF FF FF 
2610   23F1 FF FF FF FF 
2611   23F5 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2612   23F6             
2613   23F6             
2614   23F6             .end
tasm: Number of errors = 0
