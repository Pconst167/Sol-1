0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             ; Memory Map
0005   0000             ; ------------------------------------------------------------------------------------------------------------------;
0006   0000             ; 0000    ROM BEGIN
0007   0000             ; ....
0008   0000             ; 7FFF    ROM END
0009   0000             ;
0010   0000             ; 8000    RAM begin
0011   0000             ; ....
0012   0000             ; F7FF    Stack root
0013   0000             ; ------------------------------------------------------------------------------------------------------------------;
0014   0000             ; I/O MAP
0015   0000             ; ------------------------------------------------------------------------------------------------------------------;
0016   0000             ; FF80    UART 0              (16550)
0017   0000             ; FF90    UART 1              (16550)
0018   0000             ; FFA0    RTC                 (M48T02)
0019   0000             ; FFB0    PIO 0               (8255)
0020   0000             ; FFC0    5.25" Floppy Drive Block
0021   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0022   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0023   0000             ;   - FFC8      WD1770 Status/Command    
0024   0000             ;   - FFC9      WD1770 Track Register
0025   0000             ;   - FFCA      WD1770 Sector Register
0026   0000             ;   - FFCB      WD1770 Data Register
0027   0000             ;      
0028   0000             ; FFD0    IDE                 (Compact Flash / PATA)
0029   0000             ; FFE0    Timer               (8253)
0030   0000             ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0031   0000             ; ------------------------------------------------------------------------------------------------------------------;
0032   0000             
0033   0000             ; ------------------------------------------------------------------------------------------------------------------;
0034   0000             ; System Constants
0035   0000             ; ------------------------------------------------------------------------------------------------------------------;
0036   0000             _UART0_DATA       .equ $FF80            ; data
0037   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0038   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0039   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0040   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0041   0000             _UART0_LCR        .equ $FF83            ; line control register
0042   0000             _UART0_LSR        .equ $FF85            ; line status register
0043   0000             
0044   0000             _UART1_DATA       .equ $FF90            ; data
0045   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0046   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0047   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0048   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0049   0000             _UART1_LCR        .equ $FF93            ; line control register
0050   0000             _UART1_LSR        .equ $FF95            ; line status register
0051   0000             
0052   0000             XON               .equ $11
0053   0000             XOFF              .equ $13
0054   0000             
0055   0000             _ide_BASE         .equ $FFD0            ; IDE BASE
0056   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0057   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0058   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0059   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0060   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0061   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0062   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0063   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0064   0000             
0065   0000             _7SEG_DISPLAY     .equ $FFB0            ; BIOS POST CODE HEX DISPLAY (2 DIGITS) (CONNECTED TO PIO A)
0066   0000             _BIOS_POST_CTRL   .equ $FFB3            ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0067   0000             _PIO_A            .equ $FFB0    
0068   0000             _PIO_B            .equ $FFB1
0069   0000             _PIO_C            .equ $FFB2
0070   0000             _PIO_CONTROL      .equ $FFB3            ; PIO CONTROL PORT
0071   0000             
0072   0000             _FDC_CONFIG       .equ $FFC0 
0073   0000             _FDC_STATUS_1     .equ $FFC1
0074   0000             _FDC_WD_STAT_CMD  .equ $FFC8
0075   0000             _FDC_WD_TRACK     .equ $FFC9
0076   0000             _FDC_WD_SECTOR    .equ $FFCA
0077   0000             _FDC_WD_DATA      .equ $FFCB
0078   0000             
0079   0000             _TIMER_C_0        .equ $FFE0            ; TIMER COUNTER 0
0080   0000             _TIMER_C_1        .equ $FFE1            ; TIMER COUNTER 1
0081   0000             _TIMER_C_2        .equ $FFE2            ; TIMER COUNTER 2
0082   0000             _TIMER_CTRL       .equ $FFE3            ; TIMER CONTROL REGISTER
0083   0000             
0084   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0085   0000             FIFO_SIZE         .equ 1024
0086   0000             
0087   0000             text_org          .equ $400
0088   0000             ; ------------------------------------------------------------------------------------------------------------------;
0089   0000             
0090   0000             
0091   0000             ; For the next iteration:
0092   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0093   0000             ; inode-table format:
0094   0000             ;  file-type(f, d)
0095   0000             ;  permissons
0096   0000             ;  link-count
0097   0000             ;  filesize
0098   0000             ;  time-stamps
0099   0000             ;  15 data block pointers
0100   0000             ;  single-indirect pointer
0101   0000             
0102   0000             ; FILE ENTRY ATTRIBUTES
0103   0000             ; filename (24)
0104   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0105   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0106   0000             ; size (2)             : filesize
0107   0000             ; day (1)           
0108   0000             ; month (1)
0109   0000             ; year (1)
0110   0000             ; packet size = 32 bytes  : total packet size in bytes
0111   0000             
0112   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0113   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0114   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0115   0000             FST_NBR_DIRECTORIES     .equ 64
0116   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0117   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0118   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0119   0000             FST_LBA_START           .equ 32
0120   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0121   0000             
0122   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0123   0000             FS_SECTORS_PER_FILE     .equ 32         ; the first sector is always a header with a NULL parameter (first byte)
0124   0000                                                     ; so that we know which blocks are free or taken
0125   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0126   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0127   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0128   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0129   0000             
0130   0000             root_id:                .equ FST_LBA_START
0131   0000             
0132   0000             ; ------------------------------------------------------------------------------------------------------------------;
0133   0000             ; GLOBAL SYSTEM VARIABLES
0134   0000             ; ------------------------------------------------------------------------------------------------------------------;
0135   0000             
0136   0000             ; ------------------------------------------------------------------------------------------------------------------;
0137   0000             ; IRQ Table
0138   0000             ; Highest priority at lowest address
0139   0000             ; ------------------------------------------------------------------------------------------------------------------;
0140   0000 3C 00       .dw int_0_fdc
0141   0002 43 00       .dw int_1
0142   0004 44 00       .dw int_2
0143   0006 45 00       .dw int_3
0144   0008 46 00       .dw int_4
0145   000A 47 00       .dw int_5
0146   000C 59 00       .dw int_6
0147   000E A5 00       .dw int_7_uart0
0148   0010             
0149   0010             ; ------------------------------------------------------------------------------------------------------------------;
0150   0010             ; Reset Vector
0151   0010             ; ------------------------------------------------------------------------------------------------------------------;
0152   0010 C7 0F       .dw kernel_reset_vector
0153   0012             
0154   0012             ; ------------------------------------------------------------------------------------------------------------------;
0155   0012             ; Exception Vector Table
0156   0012             ; Total of 7 entries, starting at address $0012
0157   0012             ; ------------------------------------------------------------------------------------------------------------------;
0158   0012 BF 01       .dw trap_privilege
0159   0014 DC 02       .dw trap_div_zero
0160   0016 E9 02       .dw trap_undef_opcode
0161   0018 00 00       .dw 0
0162   001A 00 00       .dw 0
0163   001C 00 00       .dw 0
0164   001E 00 00       .dw 0
0165   0020             
0166   0020             ; ------------------------------------------------------------------------------------------------------------------;
0167   0020             ; System Call Vector Table
0168   0020             ; Starts at address $0020
0169   0020             ; ------------------------------------------------------------------------------------------------------------------;
0170   0020 CB 01       .dw syscall_break
0171   0022 EA 02       .dw syscall_rtc
0172   0024 24 04       .dw syscall_ide
0173   0026 FF 04       .dw syscall_io
0174   0028 BC 05       .dw syscall_file_system
0175   002A 14 0F       .dw syscall_create_proc
0176   002C 84 01       .dw syscall_list_procs
0177   002E 1C 03       .dw syscall_datetime
0178   0030 40 01       .dw syscall_reboot
0179   0032 DE 0E       .dw syscall_pause_proc
0180   0034 4C 01       .dw syscall_resume_proc
0181   0036 9B 0E       .dw syscall_terminate_proc
0182   0038 E4 00       .dw syscall_system
0183   003A 14 01       .dw syscall_fdc
0184   003C             
0185   003C             ; ------------------------------------------------------------------------------------------------------------------;
0186   003C             ; System Call Aliases
0187   003C             ; ------------------------------------------------------------------------------------------------------------------;
0188   003C             sys_break            .equ 0
0189   003C             sys_rtc              .equ 1
0190   003C             sys_ide              .equ 2
0191   003C             sys_io               .equ 3
0192   003C             sys_filesystem       .equ 4
0193   003C             sys_create_proc      .equ 5
0194   003C             sys_list_proc        .equ 6
0195   003C             sys_datetime         .equ 7
0196   003C             sys_reboot           .equ 8
0197   003C             sys_pause_proc       .equ 9
0198   003C             sys_resume_proc      .equ 10
0199   003C             sys_terminate_proc   .equ 11
0200   003C             sys_system           .equ 12
0201   003C             sys_fdc              .equ 13
0202   003C             
0203   003C             ; ------------------------------------------------------------------------------------------------------------------;
0204   003C             ; Alias Exports
0205   003C             ; ------------------------------------------------------------------------------------------------------------------;
0206   003C             .export text_org
0207   003C             .export sys_break
0208   003C             .export sys_rtc
0209   003C             .export sys_ide
0210   003C             .export sys_io
0211   003C             .export sys_filesystem
0212   003C             .export sys_create_proc
0213   003C             .export sys_list_proc
0214   003C             .export sys_datetime
0215   003C             .export sys_reboot
0216   003C             .export sys_pause_proc
0217   003C             .export sys_resume_proc
0218   003C             .export sys_terminate_proc
0219   003C             .export sys_system
0220   003C             .export sys_fdc
0221   003C             
0222   003C             ; ------------------------------------------------------------------------------------------------------------------;
0223   003C             ; IRQs' Code Block
0224   003C             ; ------------------------------------------------------------------------------------------------------------------;
0225   003C             ; 5.25" Floppy Drive Controller IRQ
0226   003C             int_0_fdc:
0227   003C 3B 48 00      mov d, s_fdc_irq
0228   003F 07 11 12      call _puts
0229   0042 06            sysret
0230   0043             int_1:
0231   0043 06            sysret
0232   0044             int_2:
0233   0044 06            sysret
0234   0045             int_3:
0235   0045 06            sysret
0236   0046             int_4:
0237   0046 06            sysret
0238   0047             int_5:
0239   0047 06            sysret
0240   0048             
0241   0048 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
0241   004C 30 20 45 78 
0241   0050 65 63 75 74 
0241   0054 65 64 2E 0A 
0241   0058 00 
0242   0059             
0243   0059             ; ------------------------------------------------------------------------------------------------------------------;
0244   0059             ; Process Swapping
0245   0059             ; ------------------------------------------------------------------------------------------------------------------;
0246   0059             int_6:  
0247   0059 4B            pusha ; save all registers into kernel stack
0248   005A 22 00         mov ah, 0
0249   005C 1D 42 17      mov al, [active_proc_index]
0250   005F FD 99         shl a              ; x2
0251   0061 B7 91 0F      mov a, [proc_table_convert + a]  ; get process state start index
0252   0064 4F            mov di, a
0253   0065 48            mov a, sp
0254   0066 77            inc a
0255   0067 4D            mov si, a
0256   0068 38 14 00      mov c, 20
0257   006B FD F5         rep movsb          ; save process state!
0258   006D             ; restore kernel stack position to point before interrupt arrived
0259   006D 51 14 00      add sp, 20
0260   0070             ; now load next process in queue
0261   0070 1D 42 17      mov al, [active_proc_index]
0262   0073 31 41 17      mov bl, [nbr_active_procs]
0263   0076 BA            cmp al, bl
0264   0077 C6 7E 00      je int6_cycle_back
0265   007A 7A            inc al            ; next process is next in the series
0266   007B 0A 80 00      jmp int6_continue
0267   007E             int6_cycle_back:
0268   007E 19 01         mov al, 1        ; next process = process 1
0269   0080             int6_continue:
0270   0080 3D 42 17      mov [active_proc_index], al    ; set next active proc
0271   0083             
0272   0083             ; calculate LUT entry for next process
0273   0083 22 00         mov ah, 0
0274   0085 FD 99         shl a              ; x2
0275   0087 B7 91 0F      mov a, [proc_table_convert + a]    ; get process state start index  
0276   008A               
0277   008A 4D            mov si, a            ; source is proc state block
0278   008B 48            mov a, sp
0279   008C 5F 13 00      sub a, 19
0280   008F 4F            mov di, a            ; destination is kernel stack
0281   0090             ; restore SP
0282   0090 7D            dec a
0283   0091 47            mov sp, a
0284   0092 38 14 00      mov c, 20
0285   0095 FD F5         rep movsb
0286   0097             ; set VM process
0287   0097 1D 42 17      mov al, [active_proc_index]
0288   009A 01            setptb
0289   009B F2 E0 FF 00   mov byte[_TIMER_C_0], 0        ; load counter 0 low byte
0290   009F F2 E0 FF 10   mov byte[_TIMER_C_0], $10        ; load counter 0 high byte
0291   00A3 4C            popa
0292   00A4 06            sysret
0293   00A5             
0294   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0295   00A5             ; UART0 Interrupt
0296   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0297   00A5             int_7_uart0:
0298   00A5 D7            push a
0299   00A6 DA            push d
0300   00A7 E1            pushf
0301   00A8 14 47 17      mov a, [fifo_in]
0302   00AB 3C            mov d, a
0303   00AC 1D 80 FF      mov al, [_UART0_DATA]  ; get character
0304   00AF B9 03         cmp al, $03        ; CTRL-C
0305   00B1 C6 CE 00      je CTRLC
0306   00B4 B9 1A         cmp al, $1A        ; CTRL-Z
0307   00B6 C6 D4 00      je CTRLZ
0308   00B9 3E            mov [d], al        ; add to fifo
0309   00BA 14 47 17      mov a, [fifo_in]
0310   00BD 77            inc a
0311   00BE AF 88 24      cmp a, fifo + FIFO_SIZE         ; check if pointer reached the end of the fifo
0312   00C1 C7 C7 00      jne int_7_continue
0313   00C4 10 88 20      mov a, fifo  
0314   00C7             int_7_continue:  
0315   00C7 42 47 17      mov [fifo_in], a      ; update fifo pointer
0316   00CA EE            popf
0317   00CB E7            pop d
0318   00CC E4            pop a  
0319   00CD 06            sysret
0320   00CE             CTRLC:
0321   00CE 51 05 00      add sp, 5
0322   00D1 0A 9B 0E      jmp syscall_terminate_proc
0323   00D4             CTRLZ:
0324   00D4 EE            popf
0325   00D5 E7            pop d
0326   00D6 E4            pop a
0327   00D7 0A DE 0E      jmp syscall_pause_proc    ; pause current process and go back to the shell
0328   00DA             
0329   00DA             
0330   00DA             
0331   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0332   00DA             ; System Syscalls
0333   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0334   00DA             system_jmptbl:
0335   00DA 10 01         .dw system_uname
0336   00DC 11 01         .dw system_whoami
0337   00DE 0D 01         .dw system_setparam
0338   00E0 EA 00         .dw system_bootloader_install
0339   00E2 E8 00         .dw system_getparam
0340   00E4             syscall_system:
0341   00E4 FD 0A DA 00   jmp [system_jmptbl + al]
0342   00E8             
0343   00E8             ; param register address in register d
0344   00E8             ; param value in register bl
0345   00E8             system_getparam:
0346   00E8 32            mov bl, [d]
0347   00E9 06            sysret
0348   00EA             
0349   00EA             ; kernel LBA address in 'b'
0350   00EA             system_bootloader_install:
0351   00EA D8            push b
0352   00EB 26 00 00      mov b, 0
0353   00EE 38 00 00      mov c, 0
0354   00F1 22 01         mov ah, $01                 ; 1 sector
0355   00F3 3B 88 26      mov d, transient_area
0356   00F6 07 6E 04      call ide_read_sect          ; read sector
0357   00F9 E5            pop b
0358   00FA FD 44 FE 01   mov [d + 510], b            ; update LBA address
0359   00FE 26 00 00      mov b, 0
0360   0101 38 00 00      mov c, 0
0361   0104 22 01         mov ah, $01                 ; 1 sector
0362   0106 3B 88 26      mov d, transient_area
0363   0109 07 94 04      call ide_write_sect         ; write sector
0364   010C 06            sysret
0365   010D             
0366   010D             ; param register address in register d
0367   010D             ; param value in register bl
0368   010D             system_setparam:
0369   010D FD 3E         mov [d], bl
0370   010F 06            sysret
0371   0110             
0372   0110             system_uname:
0373   0110 06            sysret
0374   0111             
0375   0111             system_whoami:
0376   0111 06            sysret
0377   0112             
0378   0112             ; fdc_40_FF:     .fill 40,  $FF  ; or 00                                                                                
0379   0112             ; fdc_6_00_0:    .fill 6,   $00  ;                                                                            <--|        
0380   0112             ; fdc_id_fe:     .fill 1,   $FE  ; ID Address Mark                                                               |        
0381   0112             ; fdc_track:     .fill 1,   $00  ; Track Number                                                                  |                    
0382   0112             ; fdc_side:      .fill 1,   $00  ; Side Number 00 or 01                                                          |                
0383   0112             ; fdc_sector:    .fill 1,   $01  ; Sector Number  1 through 10                                                   |                              
0384   0112             ; fdc_length:    .fill 1,   $00  ; Sector Length                                                                 |                        
0385   0112             ; fdc_2_crc_0:   .fill 1,   $F7  ; 2 CRC's Written                                                               | Write 16 times                 
0386   0112             ; fdc_11_ff:     .fill 11,  $FF  ; or 00                                                                         |                      
0387   0112             ; fdc_6_00_1:    .fill 6,   $00  ;                                                                               |                        
0388   0112             ; fdc_data_addr: .fill 1,   $FB  ; Data Address Mark                                                             |                                  
0389   0112             ; fdc_data:      .fill 128, $E5  ; Data (IBM uses E5)                                                            |                                      
0390   0112             ; fdc_2_crc_1:   .fill 1,   $F7  ; 2 CRC's Written                                                               |                                                        
0391   0112             ; fdc_10_ff:     .fill 10,  $FF  ; or 00                                                                      <--|                                                  
0392   0112             ; fdc_369_ff:    .fill 369, $FF  ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0393   0112             ; ***************************************************************************************************************
0394   0112             ; _FDC_CONFIG       .equ $FFC0 
0395   0112             ; _FDC_STATUS_1     .equ $FFC1
0396   0112             ; _FDC_WD_STAT_CMD  .equ $FFC8
0397   0112             ; _FDC_WD_TRACK     .equ $FFC9
0398   0112             ; _FDC_WD_SECTOR    .equ $FFCA
0399   0112             ; _FDC_WD_DATA      .equ $FFCB
0400   0112             fdc_jmptbl:
0401   0112 18 01         .dw syscall_fdc_format
0402   0114             syscall_fdc:
0403   0114 FD 0A 12 01   jmp [fdc_jmptbl + al]
0404   0118             
0405   0118             syscall_fdc_format:
0406   0118             fdc_wait_busy:
0407   0118 1D C8 FF      mov al, [_FDC_WD_STAT_CMD] ; read wd1770 status register
0408   011B 87 01         and al, $01                ; busy bit
0409   011D C7 18 01      jnz fdc_wait_busy
0410   0120             
0411   0120 FD 4D 76 18   mov si, fdc_40_FF
0412   0124 38 D1 00      mov c, 209
0413   0127             fdc_format_loop:
0414   0127             fdc_drq_loop:
0415   0127 3B C1 FF      mov d, _FDC_STATUS_1
0416   012A 1E            mov al, [d]
0417   012B 87 01         and al, $01               ; check drq bit
0418   012D C6 27 01      jz fdc_drq_loop
0419   0130 F6            lodsb                     ; load format byte
0420   0131 3B CB FF      mov d, _FDC_WD_DATA       ; data register
0421   0134 3E            mov [d], al               ; send data byte to wd1770
0422   0135 7E            dec c
0423   0136 3B A7 18      mov d, fdc_sector
0424   0139 1E            mov al, [d]
0425   013A 7A            inc al
0426   013B 3E            mov [d], al
0427   013C C7 27 01      jnz fdc_format_loop       ; continue formatting
0428   013F             
0429   013F             
0430   013F 06            sysret
0431   0140             
0432   0140             
0433   0140             ; REBOOT SYSTEM
0434   0140             syscall_reboot:
0435   0140 FD D7 FF FF   push word $FFFF 
0436   0144 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0437   0147 FD D7 C0 01   push word BIOS_RESET_VECTOR    ; and then push RESET VECTOR of the shell to the stack
0438   014B 06            sysret
0439   014C             
0440   014C             ;------------------------------------------------------------------------------------------------------;;
0441   014C             ; switch to another process
0442   014C             ; inputs:
0443   014C             ; AL = new process number
0444   014C             ;------------------------------------------------------------------------------------------------------;;
0445   014C             syscall_resume_proc:
0446   014C FD 78         mov g, a                            ; save the process number
0447   014E 4B            pusha                               ; save all registers into kernel stack
0448   014F 22 00         mov ah, 0
0449   0151 1D 42 17      mov al, [active_proc_index]
0450   0154 FD 99         shl a              ; x2
0451   0156 B7 91 0F      mov a, [proc_table_convert + a]     ; get process state start index
0452   0159 4F            mov di, a
0453   015A 48            mov a, sp
0454   015B 77            inc a
0455   015C 4D            mov si, a
0456   015D 38 14 00      mov c, 20
0457   0160 FD F5         rep movsb                           ; save process state!
0458   0162             ; restore kernel stack position to point before interrupt arrived
0459   0162 51 14 00      add sp, 20
0460   0165             ; now load the new process number!
0461   0165 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0462   0167 3D 42 17      mov [active_proc_index], al         ; set new active proc
0463   016A             ; calculate LUT entry for next process
0464   016A 22 00         mov ah, 0
0465   016C FD 99         shl a                               ; x2
0466   016E B7 91 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0467   0171 4D            mov si, a                           ; source is proc state block
0468   0172 48            mov a, sp
0469   0173 5F 13 00      sub a, 19
0470   0176 4F            mov di, a                           ; destination is kernel stack
0471   0177             ; restore SP
0472   0177 7D            dec a
0473   0178 47            mov sp, a
0474   0179 38 14 00      mov c, 20
0475   017C FD F5         rep movsb
0476   017E             ; set VM process
0477   017E 1D 42 17      mov al, [active_proc_index]
0478   0181 01            setptb
0479   0182 4C            popa
0480   0183 06            sysret
0481   0184             
0482   0184             syscall_list_procs:
0483   0184 3B 6A 17      mov d, s_ps_header
0484   0187 07 11 12      call _puts
0485   018A 3B F9 1B      mov d, proc_availab_table + 1
0486   018D 38 01 00      mov c, 1
0487   0190             list_procs_L0:  
0488   0190 BD 01         cmp byte[d], 1
0489   0192 C7 B6 01      jne list_procs_next
0490   0195 2D            mov b, d
0491   0196 61 F8 1B      sub b, proc_availab_table
0492   0199 FD 9F 05      shl b, 5
0493   019C DA            push d
0494   019D D8            push b
0495   019E 28            mov b, c
0496   019F 07 B1 12      call print_u8x
0497   01A2 22 20         mov ah, ' '
0498   01A4 07 E5 10      call _putchar
0499   01A7 07 E5 10      call _putchar
0500   01AA E5            pop b
0501   01AB 74            mov d, b
0502   01AC 58 08 1C      add d, proc_names
0503   01AF 07 11 12      call _puts
0504   01B2 07 BE 11      call printnl
0505   01B5 E7            pop d
0506   01B6             list_procs_next:
0507   01B6 79            inc d
0508   01B7 78            inc c
0509   01B8 C2 09 00      cmp c, 9
0510   01BB C7 90 01      jne list_procs_L0
0511   01BE             list_procs_end:
0512   01BE 06            sysret
0513   01BF             
0514   01BF             ; ------------------------------------------------------------------------------------------------------------------;
0515   01BF             ; Exceptions' Code Block
0516   01BF             ; ------------------------------------------------------------------------------------------------------------------;
0517   01BF             ; Privilege
0518   01BF             ; ------------------------------------------------------------------------------------------------------------------;
0519   01BF             trap_privilege:
0520   01BF 0A 40 01      jmp syscall_reboot
0521   01C2 DA            push d
0522   01C3 3B B9 17      mov d, s_priviledge
0523   01C6 07 11 12      call _puts
0524   01C9 E7            pop d
0525   01CA 06            sysret
0526   01CB             
0527   01CB             ; ------------------------------------------------------------------------------------------------------------------;
0528   01CB             ; Breakpoint
0529   01CB             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0530   01CB             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0531   01CB             ; ------------------------------------------------------------------------------------------------------------------;
0532   01CB             syscall_break:
0533   01CB 4B            pusha
0534   01CC             syscall_break_prompt:
0535   01CC 3B 86 02      mov d, s_break1
0536   01CF 07 11 12      call _puts
0537   01D2 07 BE 11      call printnl
0538   01D5 07 13 13      call scan_u16d
0539   01D8 AF 00 00      cmp a, 0
0540   01DB C6 E6 01      je syscall_break_regs
0541   01DE AF 01 00      cmp a, 1
0542   01E1 C6 09 02      je syscall_break_mem
0543   01E4             syscall_break_end:  
0544   01E4 4C            popa
0545   01E5 06            sysret
0546   01E6             syscall_break_regs:
0547   01E6 48            mov a, sp
0548   01E7 53 0E 00      add a, 14               ; back-track 7 registers
0549   01EA 3C            mov d, a
0550   01EB 3A 07         mov cl, 7
0551   01ED             syscall_regs_L0:
0552   01ED 2A            mov b, [d]
0553   01EE FD AB         swp b
0554   01F0 07 6D 12      call print_u16x         ; print register value
0555   01F3 07 BE 11      call printnl
0556   01F6 63 02 00      sub d, 2
0557   01F9 71 01         sub cl, 1
0558   01FB C3 00         cmp cl, 0
0559   01FD C7 ED 01      jne syscall_regs_L0
0560   0200 0A CC 01      jmp syscall_break_prompt
0561   0203 07 BE 11      call printnl
0562   0206 0A CC 01      jmp syscall_break_prompt
0563   0209             syscall_break_mem:
0564   0209 07 BE 11      call printnl
0565   020C 07 8F 12      call scan_u16x
0566   020F 4D            mov si, a               ; data source from user space
0567   0210 FD 4F 88 24   mov di, scrap_sector    ; destination in kernel space
0568   0214 38 00 02      mov c, 512
0569   0217 04            load                    ; transfer data to kernel space!
0570   0218 3B 88 24      mov d, scrap_sector     ; dump pointer in d
0571   021B 38 00 00      mov c, 0
0572   021E             dump_loop:
0573   021E 84            mov al, cl
0574   021F 87 0F         and al, $0F
0575   0221 C6 6F 02      jz print_base
0576   0224             back:
0577   0224 1E            mov al, [d]             ; read byte
0578   0225 2F            mov bl, al
0579   0226 07 B1 12      call print_u8x
0580   0229 10 00 20      mov a, $2000
0581   022C 05 03         syscall sys_io          ; space
0582   022E 84            mov al, cl
0583   022F 87 0F         and al, $0F
0584   0231 B9 0F         cmp al, $0F
0585   0233 C6 44 02      je print_ascii
0586   0236             back1:
0587   0236 79            inc d
0588   0237 78            inc c
0589   0238 C2 00 02      cmp c, 512
0590   023B C7 1E 02      jne dump_loop
0591   023E 07 BE 11      call printnl
0592   0241 0A CC 01      jmp syscall_break_prompt  ; go to syscall_break return point
0593   0244             print_ascii:
0594   0244 10 00 20      mov a, $2000
0595   0247 05 03         syscall sys_io
0596   0249 63 10 00      sub d, 16
0597   024C 26 10 00      mov b, 16
0598   024F             print_ascii_L:
0599   024F 79            inc d
0600   0250 1E            mov al, [d]               ; read byte
0601   0251 B9 20         cmp al, $20
0602   0253 C8 5B 02      jlu dot
0603   0256 B9 7E         cmp al, $7E
0604   0258 D0 63 02      jleu ascii
0605   025B             dot:
0606   025B 10 00 2E      mov a, $2E00
0607   025E 05 03         syscall sys_io
0608   0260 0A 68 02      jmp ascii_continue
0609   0263             ascii:
0610   0263 23            mov ah, al
0611   0264 19 00         mov al, 0
0612   0266 05 03         syscall sys_io
0613   0268             ascii_continue:
0614   0268 FD A9 4F 02   loopb print_ascii_L
0615   026C 0A 36 02      jmp back1
0616   026F             print_base:
0617   026F 07 BE 11      call printnl
0618   0272 2D            mov b, d
0619   0273 61 88 24      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0620   0276 07 6D 12      call print_u16x          ; display row
0621   0279 10 00 3A      mov a, $3A00
0622   027C 05 03         syscall sys_io
0623   027E 10 00 20      mov a, $2000
0624   0281 05 03         syscall sys_io
0625   0283 0A 24 02      jmp back
0626   0286             
0627   0286             s_break1:  
0628   0286 0A 44 65 62   .db "\nDebugger entry point.\n"
0628   028A 75 67 67 65 
0628   028E 72 20 65 6E 
0628   0292 74 72 79 20 
0628   0296 70 6F 69 6E 
0628   029A 74 2E 0A 
0629   029D 30 2E 20 53   .db "0. Show Registers\n"
0629   02A1 68 6F 77 20 
0629   02A5 52 65 67 69 
0629   02A9 73 74 65 72 
0629   02AD 73 0A 
0630   02AF 31 2E 20 53   .db "1. Show 512B RAM block\n"
0630   02B3 68 6F 77 20 
0630   02B7 35 31 32 42 
0630   02BB 20 52 41 4D 
0630   02BF 20 62 6C 6F 
0630   02C3 63 6B 0A 
0631   02C6 32 2E 20 43   .db "2. Continue Execution", 0
0631   02CA 6F 6E 74 69 
0631   02CE 6E 75 65 20 
0631   02D2 45 78 65 63 
0631   02D6 75 74 69 6F 
0631   02DA 6E 00 
0632   02DC             
0633   02DC             ; ------------------------------------------------------------------------------------------------------------------;
0634   02DC             ; Divide by Zero
0635   02DC             ; ------------------------------------------------------------------------------------------------------------------;
0636   02DC             trap_div_zero:
0637   02DC D7            push a
0638   02DD DA            push d
0639   02DE E1            pushf
0640   02DF 3B D0 17      mov d, s_divzero
0641   02E2 07 11 12      call _puts
0642   02E5 EE            popf
0643   02E6 E7            pop d
0644   02E7 E4            pop a
0645   02E8 06            sysret ; enable interrupts
0646   02E9             
0647   02E9             ; ------------------------------------------------------------------------------------------------------------------;
0648   02E9             ; Undefined Opcode
0649   02E9             ; ------------------------------------------------------------------------------------------------------------------;
0650   02E9             trap_undef_opcode:
0651   02E9 06            sysret
0652   02EA             
0653   02EA             ; ------------------------------------------------------------------------------------------------------------------;
0654   02EA             ; RTC Services Syscall
0655   02EA             ; RTC I/O bank = FFA0 to FFAF
0656   02EA             ; FFA0 to FFA7 is scratch RAM
0657   02EA             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0658   02EA             ; al = 0..6 -> get
0659   02EA             ; al = 7..D -> set
0660   02EA             ; ------------------------------------------------------------------------------------------------------------------;
0661   02EA             syscall_rtc:
0662   02EA DB            push al
0663   02EB DA            push d
0664   02EC B9 06         cmp al, 6
0665   02EE D1 03 03      jgu syscall_rtc_set
0666   02F1             syscall_rtc_get:
0667   02F1 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0668   02F3 22 FF         mov ah, $FF    
0669   02F5 3C            mov d, a                ; get to FFA9 + offset
0670   02F6 F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0671   02FA 1E            mov al, [d]             ; get data
0672   02FB F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0673   02FF 23            mov ah, al
0674   0300 E7            pop d
0675   0301 E8            pop al
0676   0302 06            sysret
0677   0303             syscall_rtc_set:
0678   0303 DD            push bl
0679   0304 99            mov bl, ah              ; set data asIDE
0680   0305 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0681   0307 22 FF         mov ah, $FF    
0682   0309 3C            mov d, a                ; get to FFA9 + offset
0683   030A 1B            mov al, bl              ; get data back
0684   030B F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0685   030F 3E            mov [d], al             ; set data
0686   0310 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0687   0314 EA            pop bl
0688   0315 E7            pop d
0689   0316 E8            pop al
0690   0317 06            sysret
0691   0318             
0692   0318             datetime_serv_tbl:
0693   0318 20 03         .dw print_date
0694   031A 94 03         .dw set_date
0695   031C             syscall_datetime:
0696   031C FD 0A 18 03   jmp [datetime_serv_tbl + al]      
0697   0320             print_date:
0698   0320 10 00 0D      mov a, $0D00           ; print carriage return char
0699   0323 19 03         mov al, 3
0700   0325 05 01         syscall sys_rtc        ; get week
0701   0327 1A            mov al, ah
0702   0328 22 00         mov ah, 0
0703   032A FD 9D 02      shl a, 2          
0704   032D 3B 5A 18      mov d, s_week
0705   0330 59            add d, a
0706   0331 07 11 12      call _puts
0707   0334 10 00 20      mov a, $2000
0708   0337 05 03         syscall sys_io         ; display ' '
0709   0339 19 04         mov al, 4
0710   033B 05 01         syscall sys_rtc        ; get day
0711   033D 99            mov bl, ah
0712   033E 07 B1 12      call print_u8x
0713   0341 10 00 20      mov a, $2000
0714   0344 05 03         syscall sys_io         ; display ' '
0715   0346             ; there is a problem with the month displaying
0716   0346             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0717   0346             ; even though it is to be understood as BCD.
0718   0346             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0719   0346 19 05         mov al, 05
0720   0348 05 01         syscall sys_rtc        ; get month
0721   034A 1A            mov al, ah
0722   034B 22 00         mov ah, 0
0723   034D FD 9D 02      shl a, 2          
0724   0350 3B 26 18      mov d, s_months
0725   0353 59            add d, a
0726   0354 07 11 12      call _puts
0727   0357 10 00 20      mov a, $2000
0728   035A 05 03         syscall sys_io         ; display ' '
0729   035C 2E 20         mov bl, $20
0730   035E 07 B1 12      call print_u8x         ; print 20 for year prefix
0731   0361 19 06         mov al, 06
0732   0363 05 01         syscall sys_rtc        ; get year
0733   0365 99            mov bl, ah
0734   0366 07 B1 12      call print_u8x
0735   0369 10 00 20      mov a, $2000  
0736   036C 05 03         syscall sys_io         ; display ' '
0737   036E 19 02         mov al, 2
0738   0370 05 01         syscall sys_rtc        ; get hours
0739   0372 99            mov bl, ah
0740   0373 07 B1 12      call print_u8x
0741   0376 10 00 3A      mov a, $3A00    
0742   0379 05 03         syscall sys_io         ; display ':'
0743   037B 19 01         mov al, 01
0744   037D 05 01         syscall sys_rtc        ; get minutes
0745   037F 99            mov bl, ah
0746   0380 07 B1 12      call print_u8x
0747   0383 10 00 3A      mov a, $3A00  
0748   0386 05 03         syscall sys_io         ; display ':'
0749   0388 19 00         mov al, 0
0750   038A 05 01         syscall sys_rtc        ; get seconds
0751   038C 99            mov bl, ah
0752   038D 07 B1 12      call print_u8x
0753   0390 07 BE 11      call printnl
0754   0393 06            sysret
0755   0394             set_date:
0756   0394 3B EB 17      mov d, s_set_year
0757   0397 07 11 12      call _puts
0758   039A 07 FC 12      call scan_u8x          ; read integer into A
0759   039D FD 9D 08      shl a, 8               ; only AL used, move to AH
0760   03A0 19 0D         mov al, 0Dh            ; set RTC year
0761   03A2 05 01         syscall sys_rtc        ; set RTC
0762   03A4 3B F2 17      mov d, s_set_month
0763   03A7 07 11 12      call _puts
0764   03AA 07 FC 12      call scan_u8x          ; read integer into A
0765   03AD FD 9D 08      shl a, 8               ; only AL used, move to AH
0766   03B0 19 0C         mov al, 0Ch            ; set RTC month
0767   03B2 05 01         syscall sys_rtc        ; set RTC
0768   03B4 3B FA 17      mov d, s_set_day
0769   03B7 07 11 12      call _puts
0770   03BA 07 FC 12      call scan_u8x          ; read integer into A
0771   03BD FD 9D 08      shl a, 8               ; only AL used, move to AH
0772   03C0 19 0B         mov al, 0Bh            ; set RTC month
0773   03C2 05 01         syscall sys_rtc        ; set RTC
0774   03C4 3B 00 18      mov d, s_set_week
0775   03C7 07 11 12      call _puts
0776   03CA 07 FC 12      call scan_u8x          ; read integer into A
0777   03CD FD 9D 08      shl a, 8               ; only AL used, move to AH
0778   03D0 19 0A         mov al, 0Ah            ; set RTC month
0779   03D2 05 01         syscall sys_rtc        ; set RTC
0780   03D4 3B 0A 18      mov d, s_set_hours
0781   03D7 07 11 12      call _puts
0782   03DA 07 FC 12      call scan_u8x          ; read integer into A
0783   03DD FD 9D 08      shl a, 8               ; only AL used, move to AH
0784   03E0 19 09         mov al, 09h            ; set RTC month
0785   03E2 05 01         syscall sys_rtc        ; set RTC
0786   03E4 3B 12 18      mov d, s_set_minutes
0787   03E7 07 11 12      call _puts
0788   03EA 07 FC 12      call scan_u8x          ; read integer into A
0789   03ED FD 9D 08      shl a, 8               ; only AL used, move to AH
0790   03F0 19 08         mov al, 08h            ; set RTC month
0791   03F2 05 01         syscall sys_rtc        ; set RTC
0792   03F4 3B 1C 18      mov d, s_set_seconds
0793   03F7 07 11 12      call _puts
0794   03FA 07 FC 12      call scan_u8x          ; read integer into A
0795   03FD FD 9D 08      shl a, 8               ; only AL used, move to AH
0796   0400 19 07         mov al, 07h            ; set RTC month
0797   0402 05 01         syscall sys_rtc        ; set RTC
0798   0404 06            sysret
0799   0405             
0800   0405             ; ------------------------------------------------------------------------------------------------------------------;
0801   0405             ; IDE Services Syscall
0802   0405             ; al = option
0803   0405             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0804   0405             ; IDE read/write sector
0805   0405             ; 512 bytes
0806   0405             ; User buffer pointer in D
0807   0405             ; AH = number of sectors
0808   0405             ; CB = LBA bytes 3..0
0809   0405             ; ------------------------------------------------------------------------------------------------------------------;
0810   0405 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0810   0409 73 63 61 6C 
0810   040D 6C 5F 69 64 
0810   0411 65 20 63 61 
0810   0415 6C 6C 65 64 
0810   0419 3A 20 00 
0811   041C             ide_serv_tbl:
0812   041C 43 04         .dw ide_reset
0813   041E 57 04         .dw ide_sleep
0814   0420 66 04         .dw ide_read_sect_wrapper
0815   0422 6A 04         .dw ide_write_sect_wrapper
0816   0424             syscall_ide:
0817   0424 DD            push bl
0818   0425 31 3A 17      mov bl, [sys_debug_mode]
0819   0428               ; debug block
0820   0428 C1 00         cmp bl, 0
0821   042A EA            pop bl
0822   042B C6 3F 04      je syscall_ide_jmp
0823   042E DA            push d
0824   042F DD            push bl
0825   0430 3B 05 04      mov d, s_syscall_ide_dbg0
0826   0433 07 11 12      call _puts
0827   0436 2F            mov bl, al
0828   0437 07 B1 12      call print_u8x
0829   043A 07 BE 11      call printnl
0830   043D EA            pop bl
0831   043E E7            pop d
0832   043F             syscall_ide_jmp:
0833   043F FD 0A 1C 04   jmp [ide_serv_tbl + al]    
0834   0443               
0835   0443             ide_reset:      
0836   0443 F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0837   0447 07 F0 04      call ide_wait                   ; wait for IDE ready             
0838   044A F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0839   044E F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0840   0452 F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0841   0456 06            sysret
0842   0457             ide_sleep:
0843   0457 07 F0 04      call ide_wait                   ; wait for IDE ready             
0844   045A F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0845   045E F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0846   0462 07 F0 04      call ide_wait                   ; wait for IDE ready
0847   0465 06            sysret
0848   0466             ide_read_sect_wrapper:
0849   0466 07 6E 04      call ide_read_sect
0850   0469 06            sysret
0851   046A             ide_write_sect_wrapper:
0852   046A 07 94 04      call ide_write_sect
0853   046D 06            sysret
0854   046E             ide_read_sect:
0855   046E 1A            mov al, ah
0856   046F 24            mov ah, bl
0857   0470 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0858   0473 1C            mov al, bh
0859   0474 3D D4 FF      mov [_ide_R4], al
0860   0477 12            mov a, c
0861   0478 3D D5 FF      mov [_ide_R5], al
0862   047B 1A            mov al, ah
0863   047C 87 0F         and al, %00001111
0864   047E 8B E0         or al, %11100000                ; mode lba, master
0865   0480 3D D6 FF      mov [_ide_R6], al
0866   0483             ide_read_sect_wait:
0867   0483 1D D7 FF      mov al, [_ide_R7]  
0868   0486 87 80         and al, $80                     ; BUSY FLAG
0869   0488 C7 83 04      jnz ide_read_sect_wait
0870   048B 19 20         mov al, $20
0871   048D 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0872   0490 07 BA 04      call ide_read  
0873   0493 09            ret
0874   0494             ide_write_sect:
0875   0494 1A            mov al, ah
0876   0495 24            mov ah, bl
0877   0496 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0878   0499 1C            mov al, bh
0879   049A 3D D4 FF      mov [_ide_R4], al
0880   049D 12            mov a, c
0881   049E 3D D5 FF      mov [_ide_R5], al
0882   04A1 1A            mov al, ah
0883   04A2 87 0F         and al, %00001111
0884   04A4 8B E0         or al, %11100000                ; mode lba, master
0885   04A6 3D D6 FF      mov [_ide_R6], al
0886   04A9             ide_write_sect_wait:
0887   04A9 1D D7 FF      mov al, [_ide_R7]  
0888   04AC 87 80         and al, $80                     ; BUSY FLAG
0889   04AE C7 A9 04      jnz ide_write_sect_wait
0890   04B1 19 30         mov al, $30
0891   04B3 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0892   04B6 07 D5 04      call ide_write      
0893   04B9 09            ret
0894   04BA             
0895   04BA             ;----------------------------------------------------------------------------------------------------;
0896   04BA             ; READ IDE DATA
0897   04BA             ; pointer in D
0898   04BA             ;----------------------------------------------------------------------------------------------------;
0899   04BA             ide_read:
0900   04BA DA            push d
0901   04BB             ide_read_loop:
0902   04BB 1D D7 FF      mov al, [_ide_R7]  
0903   04BE 87 80         and al, 80h                     ; BUSY FLAG
0904   04C0 C7 BB 04      jnz ide_read_loop               ; wait loop
0905   04C3 1D D7 FF      mov al, [_ide_R7]
0906   04C6 87 08         and al, %00001000               ; DRQ FLAG
0907   04C8 C6 D3 04      jz ide_read_end
0908   04CB 1D D0 FF      mov al, [_ide_R0]
0909   04CE 3E            mov [d], al
0910   04CF 79            inc d
0911   04D0 0A BB 04      jmp ide_read_loop
0912   04D3             ide_read_end:
0913   04D3 E7            pop d
0914   04D4 09            ret
0915   04D5             
0916   04D5             ;----------------------------------------------------------------------------------------------------;
0917   04D5             ; WRITE IDE DATA
0918   04D5             ; data pointer in D
0919   04D5             ;----------------------------------------------------------------------------------------------------;
0920   04D5             ide_write:
0921   04D5 DA            push d
0922   04D6             ide_write_loop:
0923   04D6 1D D7 FF      mov al, [_ide_R7]  
0924   04D9 87 80         and al, 80h             ; BUSY FLAG
0925   04DB C7 D6 04      jnz ide_write_loop      ; wait loop
0926   04DE 1D D7 FF      mov al, [_ide_R7]
0927   04E1 87 08         and al, %00001000       ; DRQ FLAG
0928   04E3 C6 EE 04      jz ide_write_end
0929   04E6 1E            mov al, [d]
0930   04E7 3D D0 FF      mov [_ide_R0], al
0931   04EA 79            inc d 
0932   04EB 0A D6 04      jmp ide_write_loop
0933   04EE             ide_write_end:
0934   04EE E7            pop d
0935   04EF 09            ret
0936   04F0             
0937   04F0             ;----------------------------------------------------------------------------------------------------;
0938   04F0             ; wait for IDE to be ready
0939   04F0             ;----------------------------------------------------------------------------------------------------;
0940   04F0             ide_wait:
0941   04F0 1D D7 FF      mov al, [_ide_R7]  
0942   04F3 87 80         and al, 80h        ; BUSY FLAG
0943   04F5 C7 F0 04      jnz ide_wait
0944   04F8 09            ret
0945   04F9             
0946   04F9             ;----------------------------------------------------------------------------------------------------;
0947   04F9             ; IO Syscall
0948   04F9             ;----------------------------------------------------------------------------------------------------;
0949   04F9             ; Baud  Divisor
0950   04F9             ; 50    2304
0951   04F9             ; 110   1047
0952   04F9             ; 300    384
0953   04F9             ; 600    192
0954   04F9             ; 1200    96
0955   04F9             ; 9600    12
0956   04F9             ; 19200    6
0957   04F9             ; 38400    3
0958   04F9             syscall_io_jmp:
0959   04F9 2C 05         .dw syscall_io_putchar
0960   04FB 39 05         .dw syscall_io_getch
0961   04FD 03 05         .dw syscall_io_uart_setup
0962   04FF             syscall_io:
0963   04FF FD 0A F9 04   jmp [syscall_io_jmp + al]
0964   0503             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0965   0503             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0966   0503             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0967   0503             syscall_io_uart_setup:
0968   0503 1D 3C 17      mov al, [sys_uart0_lcr]
0969   0506 8B 80         or al, $80                ; set DLAB access bit
0970   0508 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0971   050B 1D 3F 17      mov al, [sys_uart0_div0]
0972   050E 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0973   0511 1D 40 17      mov al, [sys_uart0_div1]
0974   0514 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0975   0517             
0976   0517 1D 3C 17      mov al, [sys_uart0_lcr]
0977   051A 87 7F         and al, $7F               ; clear DLAB access bit 
0978   051C 3D 83 FF      mov [_UART0_LCR], al
0979   051F 1D 3D 17      mov al, [sys_uart0_inten]
0980   0522 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0981   0525 1D 3E 17      mov al, [sys_uart0_fifoen]
0982   0528 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0983   052B 06            sysret
0984   052C             
0985   052C             ; char in ah
0986   052C             syscall_io_putchar:
0987   052C             syscall_io_putchar_L0:
0988   052C 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0989   052F 87 20         and al, $20
0990   0531 C6 2C 05      jz syscall_io_putchar_L0    
0991   0534 1A            mov al, ah
0992   0535 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0993   0538 06            sysret
0994   0539             
0995   0539             ; char in ah
0996   0539             ; al = sucess code
0997   0539             syscall_io_getch:
0998   0539 D8            push b
0999   053A DA            push d
1000   053B FD 0C         sti
1001   053D             syscall_io_getch_L0:  
1002   053D 14 49 17      mov a, [fifo_out]
1003   0540 29 47 17      mov b, [fifo_in]
1004   0543 B0            cmp a, b
1005   0544 C6 3D 05      je syscall_io_getch_L0
1006   0547 3C            mov d, a
1007   0548 77            inc a
1008   0549 AF 88 24      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
1009   054C C7 52 05      jne syscall_io_getch_cont
1010   054F 10 88 20      mov a, fifo  
1011   0552             syscall_io_getch_cont:  
1012   0552 42 49 17      mov [fifo_out], a             ; update fifo pointer
1013   0555 1E            mov al, [d]                   ; get char
1014   0556 23            mov ah, al
1015   0557 1D 3B 17      mov al, [sys_echo_on]
1016   055A B9 01         cmp al, 1
1017   055C C7 6B 05      jne syscall_io_getch_noecho 
1018   055F             ; here we just echo the char back to the console
1019   055F             syscall_io_getch_echo_L0:
1020   055F 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1021   0562 87 20         and al, $20                 ; isolate Transmitter Empty
1022   0564 C6 5F 05      jz syscall_io_getch_echo_L0
1023   0567 1A            mov al, ah
1024   0568 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1025   056B             syscall_io_getch_noecho:
1026   056B 19 01         mov al, 1                    ; AL = 1 means a char successfully received
1027   056D E7            pop d
1028   056E E5            pop b
1029   056F 06            sysret
1030   0570             
1031   0570             ;------------------------------------------------------------------------------------------------------;
1032   0570             ; FILE SYSTEM DATA
1033   0570             ;------------------------------------------------------------------------------------------------------;
1034   0570             ; infor for : IDE SERVICES INTERRUPT
1035   0570             ; IDE read/write 512-byte sector
1036   0570             ; al = option
1037   0570             ; user buffer pointer in D
1038   0570             ; AH = number of sectors
1039   0570             ; CB = LBA bytes 3..0  
1040   0570             ;------------------------------------------------------------------------------------------------------;
1041   0570             ; FILE SYSTEM DATA STRUCTURE
1042   0570             ;------------------------------------------------------------------------------------------------------;
1043   0570             ; for a directory we have the header first, followed by metadata
1044   0570             ; header 1 sector (512 bytes)
1045   0570             ; metadata 1 sector (512 bytes)
1046   0570             ; HEADER ENTRIES:
1047   0570             ; filename (64)
1048   0570             ; parent dir LBA (2) -  to be used for faster backwards navigation...
1049   0570             ;
1050   0570             ; metadata entries:
1051   0570             ; filename (24)
1052   0570             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1053   0570             ; LBA (2)
1054   0570             ; size (2)
1055   0570             ; day (1)
1056   0570             ; month (1)
1057   0570             ; year (1)
1058   0570             ; packet size = 32 bytes
1059   0570             ;
1060   0570             ; first directory on disk is the root directory '/'
1061   0570             file_system_jmptbl:
1062   0570 DB 05         .dw fs_mkfs                   ; 0
1063   0572 00 00         .dw 0                         ; 1
1064   0574 3D 06         .dw fs_mkdir                  ; 2
1065   0576 B6 09         .dw fs_cd                     ; 3
1066   0578 BD 09         .dw fs_ls                     ; 4
1067   057A 33 0B         .dw fs_mktxt                  ; 5
1068   057C FE 0B         .dw fs_mkbin                  ; 6
1069   057E C5 0C         .dw fs_pwd                    ; 7
1070   0580 E2 0C         .dw fs_cat                    ; 8
1071   0582 3E 0D         .dw fs_rmdir                  ; 9
1072   0584 9A 0D         .dw fs_rm                     ; 10
1073   0586 8E 0A         .dw fs_starcom                ; 11
1074   0588 00 00         .dw 0                         ; 12
1075   058A 00 00         .dw 0                         ; 13
1076   058C E3 05         .dw fs_chmod                  ; 14
1077   058E 02 0E         .dw fs_mv                     ; 15
1078   0590 DC 05         .dw fs_cd_root                ; 16
1079   0592 B2 09         .dw fs_get_curr_dirID         ; 17
1080   0594 8E 07         .dw fs_dir_id_to_path         ; 18
1081   0596 F4 07         .dw fs_path_to_dir_id_user    ; 19
1082   0598 0E 09         .dw fs_load_from_path_user    ; 20  
1083   059A 7E 08         .dw fs_filepath_exists_user   ; 21
1084   059C             
1085   059C 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1085   05A0 79 73 63 61 
1085   05A4 6C 6C 5F 66 
1085   05A8 69 6C 65 5F 
1085   05AC 73 79 73 74 
1085   05B0 65 6D 20 63 
1085   05B4 61 6C 6C 65 
1085   05B8 64 3A 20 00 
1086   05BC             syscall_file_system:
1087   05BC DD            push bl
1088   05BD 31 3A 17      mov bl, [sys_debug_mode]
1089   05C0               ; debug block
1090   05C0 C1 00         cmp bl, 0
1091   05C2 EA            pop bl
1092   05C3 C6 D7 05      je syscall_filesystem_jmp
1093   05C6 DA            push d
1094   05C7 DD            push bl
1095   05C8 3B 9C 05      mov d, s_syscall_fs_dbg0
1096   05CB 07 11 12      call _puts
1097   05CE 2F            mov bl, al
1098   05CF 07 B1 12      call print_u8x
1099   05D2 07 BE 11      call printnl
1100   05D5 EA            pop bl
1101   05D6 E7            pop d
1102   05D7             syscall_filesystem_jmp:
1103   05D7 FD 0A 70 05   jmp [file_system_jmptbl + al]
1104   05DB             
1105   05DB             fs_mkfs:  
1106   05DB 06            sysret  
1107   05DC               
1108   05DC             fs_cd_root:
1109   05DC 10 20 00      mov a, root_id
1110   05DF 42 4B 17      mov [current_dir_id], a      ; set current directory LBA to ROOT
1111   05E2 06            sysret  
1112   05E3             
1113   05E3             ; filename in D (userspace data)
1114   05E3             ; permission in BL
1115   05E3             fs_chmod:
1116   05E3 DD            push bl
1117   05E4 FD 4E         mov si, d
1118   05E6 FD 4F 88 1E   mov di, user_data
1119   05EA 38 80 00      mov c, 128
1120   05ED 04            load                        ; load filename from user-space
1121   05EE 14 4B 17      mov a, [current_dir_id]
1122   05F1 77            inc a                       ; metadata sector
1123   05F2 27            mov b, a
1124   05F3 38 00 00      mov c, 0                    ; upper LBA = 0
1125   05F6 22 01         mov ah, $01                  ; 1 sector
1126   05F8 3B 88 26      mov d, transient_area
1127   05FB 07 6E 04      call ide_read_sect          ; read directory
1128   05FE FD 10         cla
1129   0600 42 43 17      mov [index], a              ; reset file counter
1130   0603             fs_chmod_L1:
1131   0603 FD 4E         mov si, d
1132   0605 FD 4F 88 1E   mov di, user_data
1133   0609 07 54 10      call _strcmp
1134   060C C6 23 06      je fs_chmod_found_entry
1135   060F 58 20 00      add d, 32
1136   0612 14 43 17      mov a, [index]
1137   0615 77            inc a
1138   0616 42 43 17      mov [index], a
1139   0619 AF 10 00      cmp a, FST_FILES_PER_DIR
1140   061C C7 03 06      jne fs_chmod_L1
1141   061F EA            pop bl
1142   0620 0A 3C 06      jmp fs_chmod_not_found
1143   0623             fs_chmod_found_entry:  
1144   0623 FD 79         mov g, b                    ; save LBA
1145   0625 EA            pop bl                      ; retrieve saved permission value
1146   0626 1F 18 00      mov al, [d + 24]            ; read file permissions
1147   0629 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1148   062B 8C            or al, bl                   ; set new permissions
1149   062C 3F 18 00      mov [d + 24], al            ; write new permissions
1150   062F 38 00 00      mov c, 0
1151   0632 3B 88 26      mov d, transient_area
1152   0635 22 01         mov ah, $01                 ; disk write 1 sect
1153   0637 FD 27         mov b, g                    ; retrieve LBA
1154   0639 07 94 04      call ide_write_sect         ; write sector
1155   063C             fs_chmod_not_found:
1156   063C 06            sysret
1157   063D             
1158   063D             ;------------------------------------------------------------------------------------------------------;
1159   063D             ; CREATE NEW DIRECTORY
1160   063D             ;------------------------------------------------------------------------------------------------------;
1161   063D             ; search list for NULL name entry. add new directory to list
1162   063D             fs_mkdir:
1163   063D FD 4E         mov si, d
1164   063F FD 4F 88 1E   mov di, user_data
1165   0643 38 00 02      mov c, 512
1166   0646 04            load                        ; load data from user-space
1167   0647 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1168   064A                                           ; when checking for NULL name, since root has a NULL name)
1169   064A 38 00 00      mov c, 0                    ; upper LBA = 0
1170   064D             fs_mkdir_L1:  
1171   064D 22 01         mov ah, $01                  ; 1 sector
1172   064F 3B 88 26      mov d, transient_area
1173   0652 07 6E 04      call ide_read_sect          ; read sector
1174   0655 BD 00         cmp byte[d], 0              ; check for NULL
1175   0657 C6 60 06      je fs_mkdir_found_null
1176   065A 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1177   065D 0A 4D 06      jmp fs_mkdir_L1
1178   0660             fs_mkdir_found_null:
1179   0660             ;create header file by grabbing dir name from parameter
1180   0660 D8            push b                      ; save new directory's LBA
1181   0661 38 40 00      mov c, 64
1182   0664 FD 4D 88 1E   mov si, user_data
1183   0668 FD 4F 88 26   mov di, transient_area
1184   066C FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1185   066E 14 4B 17      mov a, [current_dir_id]
1186   0671 42 C8 26      mov [transient_area + 64], a    ; store parent directory LBA
1187   0674 19 00         mov al, 0
1188   0676 FD 4F 88 28   mov di, transient_area + 512
1189   067A 38 00 02      mov c, 512
1190   067D FD F7         rep stosb                       ; clean buffer
1191   067F 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1192   0682             ; write directory entry sectors
1193   0682 3B 88 26      mov d, transient_area
1194   0685 22 02         mov ah, $02                     ; disk write, 2 sectors
1195   0687 07 94 04      call ide_write_sect             ; write sector
1196   068A             ; now we need to add the new directory to the list, insIDE the current directory
1197   068A 14 4B 17      mov a, [current_dir_id]
1198   068D 53 01 00      add a, 1
1199   0690 27            mov b, a                        ; metadata sector
1200   0691 38 00 00      mov c, 0
1201   0694 FD 79         mov g, b                        ; save LBA
1202   0696 3B 88 26      mov d, transient_area
1203   0699 22 01         mov ah, $01                  ; 1 sector
1204   069B 07 6E 04      call ide_read_sect              ; read metadata sector
1205   069E             fs_mkdir_L2:
1206   069E BD 00         cmp byte[d], 0
1207   06A0 C6 A9 06      je fs_mkdir_found_null2
1208   06A3 58 20 00      add d, FST_ENTRY_SIZE
1209   06A6 0A 9E 06      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1210   06A9             fs_mkdir_found_null2:
1211   06A9 FD 4D 88 1E   mov si, user_data
1212   06AD FD 50         mov di, d
1213   06AF 07 69 10      call _strcpy                    ; copy directory name
1214   06B2 58 18 00      add d, 24                       ; goto ATTRIBUTES
1215   06B5 19 0B         mov al, %00001011               ; directory, no execute, write, read
1216   06B7 3E            mov [d], al      
1217   06B8 79            inc d
1218   06B9 E5            pop b
1219   06BA D8            push b                          ; push LBA back
1220   06BB FD 43         mov [d], b                      ; save LBA
1221   06BD             ; set file creation date  
1222   06BD 58 04 00      add d, 4
1223   06C0 19 04         mov al, 4
1224   06C2 05 01         syscall sys_rtc
1225   06C4 1A            mov al, ah
1226   06C5 3E            mov [d], al                     ; set day
1227   06C6 79            inc d
1228   06C7 19 05         mov al, 5
1229   06C9 05 01         syscall sys_rtc
1230   06CB 1A            mov al, ah
1231   06CC 3E            mov [d], al                     ; set month
1232   06CD 79            inc d
1233   06CE 19 06         mov al, 6
1234   06D0 05 01         syscall sys_rtc
1235   06D2 1A            mov al, ah
1236   06D3 3E            mov [d], al                     ; set year
1237   06D4             ; write sector into disk for new directory entry
1238   06D4 FD 27         mov b, g
1239   06D6 38 00 00      mov c, 0
1240   06D9 3B 88 26      mov d, transient_area
1241   06DC 22 01         mov ah, $01                     ; disk write, 1 sector
1242   06DE 07 94 04      call ide_write_sect             ; write sector
1243   06E1             
1244   06E1             ; after adding the new directory's information to its parent directory's list
1245   06E1             ; we need to now enter the new directory, and to it add two new directories!
1246   06E1             ; which directories do we need to add ? '..' and '.' are the directories needed.
1247   06E1             ; importantly, note that these two new directories are only entries in the list
1248   06E1             ; and do not have actual physical entries in the disk as real directories.
1249   06E1             ; i.e. they only exist as list entries in the new directory created so that
1250   06E1             ; the new directory can reference its parent and itself.
1251   06E1             ; We need to add both '..' and '.'
1252   06E1             ; this first section is for '..' and on the section below we do the same for '.'
1253   06E1 E4            pop a                         ; retrieve the new directory's LBA  
1254   06E2 D7            push a                        ; and save again
1255   06E3 53 01 00      add a, 1
1256   06E6 27            mov b, a                      ; metadata sector
1257   06E7 38 00 00      mov c, 0
1258   06EA FD 79         mov g, b                      ; save LBA
1259   06EC 3B 88 26      mov d, transient_area
1260   06EF 22 01         mov ah, $01                  ; 1 sector
1261   06F1 07 6E 04      call ide_read_sect            ; read metadata sector
1262   06F4             fs_mkdir_L3:
1263   06F4 BD 00         cmp byte[d], 0
1264   06F6 C6 FF 06      je fs_mkdir_found_null3
1265   06F9 58 20 00      add d, FST_ENTRY_SIZE
1266   06FC 0A F4 06      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1267   06FF             fs_mkdir_found_null3:
1268   06FF FD 4D 5B 17   mov si, s_parent_dir
1269   0703 FD 50         mov di, d
1270   0705 07 69 10      call _strcpy                  ; copy directory name
1271   0708 58 18 00      add d, 24                     ; goto ATTRIBUTES
1272   070B 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1273   070D 3E            mov [d], al      
1274   070E 79            inc d
1275   070F 29 4B 17      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1276   0712 FD 43         mov [d], b                    ; save LBA
1277   0714             ; set file creation date  
1278   0714 58 04 00      add d, 4
1279   0717 19 04         mov al, 4
1280   0719 05 01         syscall sys_rtc
1281   071B 1A            mov al, ah
1282   071C 3E            mov [d], al                   ; set day
1283   071D 79            inc d
1284   071E 19 05         mov al, 5
1285   0720 05 01         syscall sys_rtc
1286   0722 1A            mov al, ah
1287   0723 3E            mov [d], al                   ; set month
1288   0724 79            inc d
1289   0725 19 06         mov al, 6
1290   0727 05 01         syscall sys_rtc
1291   0729 1A            mov al, ah
1292   072A 3E            mov [d], al                   ; set year
1293   072B             ; write sector into disk for new directory entry
1294   072B FD 27         mov b, g
1295   072D 38 00 00      mov c, 0
1296   0730 3B 88 26      mov d, transient_area
1297   0733 22 01         mov ah, $01                   ; disk write, 1 sector
1298   0735 07 94 04      call ide_write_sect           ; write sector
1299   0738             ;;;;;;;;;;;;;
1300   0738             ; like we did above for '..', we need to now add the '.' directory to the list.
1301   0738             ;------------------------------------------------------------------------------------------------------;
1302   0738 E4            pop a                         ; retrieve the new directory's LBA  
1303   0739 D7            push a
1304   073A 53 01 00      add a, 1
1305   073D 27            mov b, a                      ; metadata sector
1306   073E 38 00 00      mov c, 0
1307   0741 FD 79         mov g, b                      ; save LBA
1308   0743 3B 88 26      mov d, transient_area
1309   0746 22 01         mov ah, $01                  ; 1 sector
1310   0748 07 6E 04      call ide_read_sect            ; read metadata sector
1311   074B             fs_mkdir_L4:
1312   074B BD 00         cmp byte[d], 0
1313   074D C6 56 07      je fs_mkdir_found_null4
1314   0750 58 20 00      add d, FST_ENTRY_SIZE
1315   0753 0A 4B 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1316   0756             fs_mkdir_found_null4:
1317   0756 FD 4D 5E 17   mov si, s_current_dir
1318   075A FD 50         mov di, d
1319   075C 07 69 10      call _strcpy                  ; copy directory name
1320   075F 58 18 00      add d, 24                     ; goto ATTRIBUTES
1321   0762 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1322   0764 3E            mov [d], al      
1323   0765 79            inc d
1324   0766 E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1325   0767 FD 43         mov [d], b                    ; save LBA
1326   0769             ; set file creation date  
1327   0769 58 04 00      add d, 4
1328   076C 19 04         mov al, 4
1329   076E 05 01         syscall sys_rtc
1330   0770 1A            mov al, ah
1331   0771 3E            mov [d], al                   ; set day
1332   0772 79            inc d
1333   0773 19 05         mov al, 5
1334   0775 05 01         syscall sys_rtc
1335   0777 1A            mov al, ah
1336   0778 3E            mov [d], al                   ; set month
1337   0779 79            inc d
1338   077A 19 06         mov al, 6
1339   077C 05 01         syscall sys_rtc
1340   077E 1A            mov al, ah
1341   077F 3E            mov [d], al                   ; set year
1342   0780             ; write sector into disk for new directory entry
1343   0780 FD 27         mov b, g
1344   0782 38 00 00      mov c, 0
1345   0785 3B 88 26      mov d, transient_area
1346   0788 22 01         mov ah, $01                   ; disk write, 1 sector
1347   078A 07 94 04      call ide_write_sect           ; write sector
1348   078D             fs_mkdir_end:
1349   078D 06            sysret
1350   078E             
1351   078E             ;------------------------------------------------------------------------------------------------------;
1352   078E             ; get path from a given directory dirID
1353   078E             ; pseudo code:
1354   078E             ;  fs_dir_id_to_path(int dirID, char *D){
1355   078E             ;    if(dirID == 0){
1356   078E             ;      reverse path in D;
1357   078E             ;      return;
1358   078E             ;    }
1359   078E             ;    else{
1360   078E             ;      copy directory name to end of D;
1361   078E             ;      add '/' to end of D;
1362   078E             ;      parentID = get parent directory ID;
1363   078E             ;      fs_dir_id_to_path(parentID, D);
1364   078E             ;    }
1365   078E             ;  }
1366   078E             ; A = dirID
1367   078E             ; D = generated path string pointer
1368   078E             ;------------------------------------------------------------------------------------------------------;
1369   078E             ; sample path: /usr/bin
1370   078E             fs_dir_id_to_path:
1371   078E 3B 08 1E      mov d, filename
1372   0791 19 00         mov al, 0
1373   0793 3E            mov [d], al                     ; initialize path string 
1374   0794 14 4B 17      mov a, [current_dir_id]
1375   0797 07 A4 07      call fs_dir_id_to_path_E0
1376   079A 3B 08 1E      mov d, filename
1377   079D 07 FD 0F      call _strrev
1378   07A0 07 11 12      call _puts
1379   07A3 06            sysret
1380   07A4             fs_dir_id_to_path_E0:
1381   07A4 07 C3 07      call get_dirname_from_dirID
1382   07A7 FD 4D 60 17   mov si, s_fslash
1383   07AB FD 50         mov di, d
1384   07AD 07 77 10      call _strcat                    ; add '/' to end of path
1385   07B0 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1386   07B3 C6 C2 07      je fs_dir_id_to_path_root
1387   07B6 07 E0 07      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1388   07B9 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1389   07BC C6 C2 07      je fs_dir_id_to_path_root
1390   07BF 07 A4 07      call fs_dir_id_to_path_E0     ; recursively call itself
1391   07C2             fs_dir_id_to_path_root:
1392   07C2 09            ret
1393   07C3             
1394   07C3             ;------------------------------------------------------------------------------------------------------;
1395   07C3             ; in_puts:
1396   07C3             ; A = directory ID
1397   07C3             ; out_puts:
1398   07C3             ; D = pointer to directory name string
1399   07C3             ;------------------------------------------------------------------------------------------------------;
1400   07C3             get_dirname_from_dirID:
1401   07C3 D7            push a
1402   07C4 D8            push b
1403   07C5 DA            push d
1404   07C6 27            mov b, a
1405   07C7 38 00 00      mov c, 0                      ; upper LBA = 0
1406   07CA 22 01         mov ah, $01                  ; 1 sector
1407   07CC 3B 88 24      mov d, transient_area - 512
1408   07CF 07 6E 04      call ide_read_sect            ; read directory
1409   07D2 07 FD 0F      call _strrev                  ; reverse dir name before copying
1410   07D5 FD 4E         mov si, d
1411   07D7 E7            pop d                         ; destination address = D value pushed at beginning
1412   07D8 FD 50         mov di, d
1413   07DA 07 77 10      call _strcat                  ; copy filename to D
1414   07DD E5            pop b
1415   07DE E4            pop a
1416   07DF 09            ret
1417   07E0             
1418   07E0             ;------------------------------------------------------------------------------------------------------;
1419   07E0             ; in_puts:
1420   07E0             ; A = directory ID
1421   07E0             ; out_puts:
1422   07E0             ; A = parent directory ID
1423   07E0             ;------------------------------------------------------------------------------------------------------;
1424   07E0             get_parentID_from_dirID:
1425   07E0 D8            push b
1426   07E1 DA            push d
1427   07E2 27            mov b, a
1428   07E3 38 00 00      mov c, 0                      ; upper LBA = 0
1429   07E6 22 01         mov ah, $01                  ; 1 sector
1430   07E8 3B 88 24      mov d, transient_area - 512
1431   07EB 07 6E 04      call ide_read_sect            ; read directory
1432   07EE 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1433   07F1 E7            pop d
1434   07F2 E5            pop b
1435   07F3 09            ret
1436   07F4             
1437   07F4             ;------------------------------------------------------------------------------------------------------;
1438   07F4             ; get dirID from a given path string
1439   07F4             ; in_puts:
1440   07F4             ; D = path pointer 
1441   07F4             ; out_puts:
1442   07F4             ; A = dirID
1443   07F4             ; if dir non existent, A = FFFF (fail code)
1444   07F4             ; /usr/local/bin    - absolute
1445   07F4             ; local/bin/games    - relative
1446   07F4             ;------------------------------------------------------------------------------------------------------;
1447   07F4             fs_path_to_dir_id_user:
1448   07F4 FD 4E         mov si, d
1449   07F6 FD 4F 88 1E   mov di, user_data
1450   07FA 38 00 02      mov c, 512
1451   07FD 04            load
1452   07FE 07 02 08      call get_dirID_from_path
1453   0801 06            sysret
1454   0802             get_dirID_from_path:
1455   0802 26 88 1E      mov b, user_data
1456   0805 FD 42 36 16   mov [prog], b                  ; token pointer set to path string
1457   0809 07 97 14      call get_token
1458   080C 31 39 16      mov bl, [tok]
1459   080F C1 01         cmp bl, TOK_FSLASH
1460   0811 C6 1D 08      je get_dirID_from_path_abs 
1461   0814 14 4B 17      mov a, [current_dir_id]
1462   0817 07 1D 16      call _putback
1463   081A 0A 20 08      jmp get_dirID_from_path_E0
1464   081D             get_dirID_from_path_abs:
1465   081D 10 20 00      mov a, root_id
1466   0820             get_dirID_from_path_E0:
1467   0820 07 97 14      call get_token
1468   0823 31 38 16      mov bl, [toktyp]
1469   0826 C1 00         cmp bl, TOKTYP_IDENTIFIER
1470   0828 C7 79 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1471   082B             
1472   082B FD 4D 3A 16   mov si, tokstr
1473   082F FD 4F 08 1E   mov di, filename
1474   0833 07 69 10      call _strcpy        
1475   0836 77            inc a                         ; metadata sector
1476   0837 27            mov b, a
1477   0838 38 00 00      mov c, 0                      ; upper LBA = 0
1478   083B 22 01         mov ah, $01                  ; 1 sector
1479   083D 3B 88 26      mov d, transient_area
1480   0840 07 6E 04      call ide_read_sect            ; read directory
1481   0843 FD 10         cla
1482   0845 42 43 17      mov [index], a
1483   0848             get_dirID_from_path_L1:
1484   0848 FD 4E         mov si, d
1485   084A FD 4F 08 1E   mov di, filename
1486   084E 07 54 10      call _strcmp
1487   0851 C6 67 08      je get_dirID_from_path_name_equal  
1488   0854 58 20 00      add d, 32
1489   0857 14 43 17      mov a, [index]
1490   085A 77            inc a
1491   085B 42 43 17      mov [index], a
1492   085E AF 10 00      cmp a, FST_FILES_PER_DIR
1493   0861 C6 7A 08      je get_dirID_from_path_fail
1494   0864 0A 48 08      jmp get_dirID_from_path_L1
1495   0867             get_dirID_from_path_name_equal:
1496   0867 58 19 00      add d, 25           
1497   086A 15            mov a, [d]                    ; set result register A = dirID
1498   086B 07 97 14      call get_token
1499   086E 31 39 16      mov bl, [tok]
1500   0871 C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1501   0873 C6 20 08      je get_dirID_from_path_E0
1502   0876 07 1D 16      call _putback
1503   0879             get_dirID_from_path_end:
1504   0879 09            ret
1505   087A             get_dirID_from_path_fail:
1506   087A 10 FF FF      mov A, $FFFF
1507   087D 09            ret
1508   087E             
1509   087E             
1510   087E             ;------------------------------------------------------------------------------------------------------;
1511   087E             ; check if file exists by a given path string
1512   087E             ; in_puts:
1513   087E             ; D = path pointer 
1514   087E             ; OUTPUTS:
1515   087E             ; A = success code, if file exists gives LBA, else, give 0
1516   087E             ; /usr/local/bin/ed
1517   087E             ;------------------------------------------------------------------------------------------------------;
1518   087E             fs_filepath_exists_user:
1519   087E FD 4E         mov si, d
1520   0880 FD 4F 88 1E   mov di, user_data
1521   0884 38 00 02      mov c, 512
1522   0887 04            load
1523   0888 07 8C 08      call file_exists_by_path
1524   088B 06            sysret
1525   088C             file_exists_by_path:
1526   088C 26 88 1E      mov b, user_data
1527   088F FD 42 36 16   mov [prog], b                   ; token pointer set to path string
1528   0893 07 97 14      call get_token
1529   0896 31 39 16      mov bl, [tok]
1530   0899 C1 01         cmp bl, TOK_FSLASH
1531   089B C6 A7 08      je  file_exists_by_path_abs
1532   089E 14 4B 17      mov a, [current_dir_id]
1533   08A1 07 1D 16      call _putback
1534   08A4 0A AA 08      jmp file_exists_by_path_E0
1535   08A7             file_exists_by_path_abs:
1536   08A7 10 20 00      mov a, root_id
1537   08AA             file_exists_by_path_E0:
1538   08AA 07 97 14      call get_token
1539   08AD 31 38 16      mov bl, [toktyp]
1540   08B0 C1 00         cmp bl, TOKTYP_IDENTIFIER
1541   08B2 C7 0A 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1542   08B5 FD 4D 3A 16   mov si, tokstr
1543   08B9 FD 4F 08 1E   mov di, filename
1544   08BD 07 69 10      call _strcpy        
1545   08C0 77            inc a                           ; metadata sector
1546   08C1 27            mov b, a
1547   08C2 38 00 00      mov c, 0                        ; upper LBA = 0
1548   08C5 22 01         mov ah, $01                  ; 1 sector
1549   08C7 3B 88 26      mov d, transient_area
1550   08CA 07 6E 04      call ide_read_sect              ; read directory
1551   08CD FD 10         cla
1552   08CF 42 43 17      mov [index], a
1553   08D2             file_exists_by_path_L1:
1554   08D2 FD 4E         mov si, d
1555   08D4 FD 4F 08 1E   mov di, filename
1556   08D8 07 54 10      call _strcmp
1557   08DB C6 F1 08      je   file_exists_by_path_name_equal
1558   08DE 58 20 00      add d, 32
1559   08E1 14 43 17      mov a, [index]
1560   08E4 77            inc a
1561   08E5 42 43 17      mov [index], a
1562   08E8 AF 10 00      cmp a, FST_FILES_PER_DIR
1563   08EB C6 0A 09      je file_exists_by_path_end
1564   08EE 0A D2 08      jmp file_exists_by_path_L1
1565   08F1             file_exists_by_path_name_equal:
1566   08F1 33 18 00      mov bl, [d + 24]
1567   08F4 FD 87 38      and bl, %00111000               ; directory flag
1568   08F7 C1 08         cmp bl, %00001000               ; is dir?
1569   08F9 C6 00 09      je file_exists_by_path_isdir;
1570   08FC             ; entry is a file
1571   08FC 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1572   08FF 09            ret
1573   0900             file_exists_by_path_isdir:
1574   0900 58 19 00      add d, 25           
1575   0903 15            mov a, [d]                      ; set result register A = dirID
1576   0904 07 97 14      call get_token
1577   0907 0A AA 08      jmp file_exists_by_path_E0
1578   090A             file_exists_by_path_end:
1579   090A 10 00 00      mov a, 0                        ; return 0 because file was not found
1580   090D 09            ret
1581   090E             
1582   090E             ;------------------------------------------------------------------------------------------------------;
1583   090E             ; load file data from a given path string
1584   090E             ; inputs:
1585   090E             ; D = path pointer 
1586   090E             ; DI = userspace program data destination
1587   090E             ; /usr/local/bin/ed
1588   090E             ; ./ed
1589   090E             ;------------------------------------------------------------------------------------------------------;
1590   090E             fs_load_from_path_user:
1591   090E E3            push di
1592   090F FD 4E         mov si, d
1593   0911 FD 4F 88 1E   mov di, user_data
1594   0915 38 00 02      mov c, 512
1595   0918 04            load
1596   0919 07 26 09      call loadfile_from_path
1597   091C F0            pop di
1598   091D FD 4D 88 26   mov si, transient_area
1599   0921 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1600   0924 03            store
1601   0925 06            sysret
1602   0926             loadfile_from_path:
1603   0926 26 88 1E      mov b, user_data
1604   0929 FD 42 36 16   mov [prog], b                 ; token pointer set to path string
1605   092D 07 97 14      call get_token
1606   0930 31 39 16      mov bl, [tok]
1607   0933 C1 01         cmp bl, TOK_FSLASH
1608   0935 C6 41 09      je loadfile_from_path_abs 
1609   0938 14 4B 17      mov a, [current_dir_id]
1610   093B 07 1D 16      call _putback
1611   093E 0A 44 09      jmp loadfile_from_path_E0
1612   0941             loadfile_from_path_abs:
1613   0941 10 20 00      mov a, root_id
1614   0944             loadfile_from_path_E0:
1615   0944 07 97 14      call get_token
1616   0947 31 38 16      mov bl, [toktyp]
1617   094A C1 00         cmp bl, TOKTYP_IDENTIFIER
1618   094C C7 B1 09      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1619   094F FD 4D 3A 16   mov si, tokstr
1620   0953 FD 4F 08 1E   mov di, filename
1621   0957 07 69 10      call _strcpy        
1622   095A 77            inc a                         ; metadata sector
1623   095B 27            mov b, a
1624   095C 38 00 00      mov c, 0                      ; upper LBA = 0
1625   095F 22 01         mov ah, $01                  ; 1 sector
1626   0961 3B 88 26      mov d, transient_area
1627   0964 07 6E 04      call ide_read_sect            ; read directory
1628   0967 FD 10         cla
1629   0969 42 43 17      mov [index], a
1630   096C             loadfile_from_path_L1:
1631   096C FD 4E         mov si, d
1632   096E FD 4F 08 1E   mov di, filename
1633   0972 07 54 10      call _strcmp
1634   0975 C6 8B 09      je loadfile_from_path_name_equal  
1635   0978 58 20 00      add d, 32
1636   097B 14 43 17      mov a, [index]
1637   097E 77            inc a
1638   097F 42 43 17      mov [index], a
1639   0982 AF 10 00      cmp a, FST_FILES_PER_DIR
1640   0985 C6 B1 09      je loadfile_from_path_end
1641   0988 0A 6C 09      jmp loadfile_from_path_L1
1642   098B             loadfile_from_path_name_equal:
1643   098B 33 18 00      mov bl, [d + 24]
1644   098E FD 87 38      and bl, %00111000             ; directory flag
1645   0991 C1 08         cmp bl, %00001000             ; is dir?
1646   0993 C6 A7 09      je loadfile_isdirectory  
1647   0996             ; entry is a file
1648   0996 2B 19 00      mov b, [d + 25]               ; get LBA
1649   0999 FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1650   099B 3B 88 26      mov d, transient_area
1651   099E 38 00 00      mov c, 0
1652   09A1 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1653   09A3 07 6E 04      call ide_read_sect            ; read sector
1654   09A6 09            ret
1655   09A7             loadfile_isdirectory:
1656   09A7 58 19 00      add d, 25           
1657   09AA 15            mov a, [d]                    ; set result register A = dirID
1658   09AB 07 97 14      call get_token
1659   09AE 0A 44 09      jmp loadfile_from_path_E0
1660   09B1             loadfile_from_path_end:
1661   09B1 09            ret
1662   09B2             
1663   09B2             ;------------------------------------------------------------------------------------------------------;
1664   09B2             ; return the ID of the current directory
1665   09B2             ; ID returned in B
1666   09B2             ;------------------------------------------------------------------------------------------------------;
1667   09B2             fs_get_curr_dirID:
1668   09B2 29 4B 17      mov b, [current_dir_id]
1669   09B5 06            sysret
1670   09B6             
1671   09B6             ;------------------------------------------------------------------------------------------------------;
1672   09B6             ; CD
1673   09B6             ;------------------------------------------------------------------------------------------------------;
1674   09B6             ; new dirID in B
1675   09B6             fs_cd:
1676   09B6 FD 42 4B 17   mov [current_dir_id], b
1677   09BA 06            sysret  
1678   09BB             
1679   09BB             ;------------------------------------------------------------------------------------------------------;
1680   09BB             ; LS
1681   09BB             ; dirID in B
1682   09BB             ;------------------------------------------------------------------------------------------------------;
1683   09BB 00 00       ls_count:       .dw 0
1684   09BD             fs_ls:
1685   09BD FD 77         inc b                        ; metadata sector
1686   09BF 38 00 00      mov c, 0                     ; upper LBA = 0
1687   09C2 22 01         mov ah, $01                  ; 1 sector
1688   09C4 3B 88 26      mov d, transient_area
1689   09C7 07 6E 04      call ide_read_sect           ; read directory
1690   09CA FD 10         cla
1691   09CC 42 43 17      mov [index], a               ; reset entry index
1692   09CF 3D BB 09      mov [ls_count], al           ; reset item count
1693   09D2             fs_ls_L1:
1694   09D2 BD 00         cmp byte [d], 0              ; check for NULL
1695   09D4 C6 6B 0A      je fs_ls_next
1696   09D7             fs_ls_non_null:
1697   09D7 1D BB 09      mov al, [ls_count]
1698   09DA 7A            inc al
1699   09DB 3D BB 09      mov [ls_count], al           ; increment item count
1700   09DE 1F 18 00      mov al, [d + 24]
1701   09E1 87 38         and al, %00111000
1702   09E3 FD A2 03      shr al, 3
1703   09E6 22 00         mov ah, 0                    ; file type
1704   09E8 B7 67 17      mov a, [a + file_type]      
1705   09EB 23            mov ah, al
1706   09EC 07 E5 10      call _putchar
1707   09EF 1F 18 00      mov al, [d + 24]
1708   09F2 87 01         and al, %00000001
1709   09F4 22 00         mov ah, 0
1710   09F6 B7 62 17      mov a, [a + file_attrib]     ; read
1711   09F9 23            mov ah, al
1712   09FA 07 E5 10      call _putchar
1713   09FD 1F 18 00      mov al, [d + 24]
1714   0A00 87 02         and al, %00000010
1715   0A02 22 00         mov ah, 0
1716   0A04 B7 62 17      mov a, [a + file_attrib]     ; write
1717   0A07 23            mov ah, al
1718   0A08 07 E5 10      call _putchar
1719   0A0B 1F 18 00      mov al, [d + 24]
1720   0A0E 87 04         and al, %00000100
1721   0A10 22 00         mov ah, 0
1722   0A12 B7 62 17      mov a, [a + file_attrib]     ; execute
1723   0A15 23            mov ah, al
1724   0A16 07 E5 10      call _putchar
1725   0A19 22 20         mov ah, $20
1726   0A1B 07 E5 10      call _putchar  
1727   0A1E 2B 1B 00      mov b, [d + 27]
1728   0A21 07 6D 12      call print_u16x              ; filesize
1729   0A24 22 20         mov ah, $20
1730   0A26 07 E5 10      call _putchar  
1731   0A29 2B 19 00      mov b, [d + 25]
1732   0A2C 07 6D 12      call print_u16x              ; dirID / LBA
1733   0A2F 22 20         mov ah, $20
1734   0A31 07 E5 10      call _putchar
1735   0A34             ; print date
1736   0A34 33 1D 00      mov bl, [d + 29]             ; day
1737   0A37 07 B1 12      call print_u8x
1738   0A3A 22 20         mov ah, $20
1739   0A3C 07 E5 10      call _putchar  
1740   0A3F 1F 1E 00      mov al, [d + 30]             ; month
1741   0A42 FD 9E 02      shl al, 2
1742   0A45 DA            push d
1743   0A46 3B 26 18      mov d, s_months
1744   0A49 22 00         mov ah, 0
1745   0A4B 59            add d, a
1746   0A4C 07 11 12      call _puts
1747   0A4F E7            pop d
1748   0A50 22 20         mov ah, $20
1749   0A52 07 E5 10      call _putchar
1750   0A55 2E 20         mov bl, $20
1751   0A57 07 B1 12      call print_u8x
1752   0A5A 33 1F 00      mov bl, [d + 31]             ; year
1753   0A5D 07 B1 12      call print_u8x  
1754   0A60 22 20         mov ah, $20
1755   0A62 07 E5 10      call _putchar  
1756   0A65 07 11 12      call _puts                   ; print filename  
1757   0A68 07 BE 11      call printnl
1758   0A6B             fs_ls_next:
1759   0A6B 14 43 17      mov a, [index]
1760   0A6E 77            inc a
1761   0A6F 42 43 17      mov [index], a
1762   0A72 AF 10 00      cmp a, FST_FILES_PER_DIR
1763   0A75 C6 7E 0A      je fs_ls_end
1764   0A78 58 20 00      add d, 32      
1765   0A7B 0A D2 09      jmp fs_ls_L1  
1766   0A7E             fs_ls_end:
1767   0A7E 3B 77 17      mov d, s_ls_total
1768   0A81 07 11 12      call _puts
1769   0A84 1D BB 09      mov al, [ls_count]
1770   0A87 07 C3 12      call print_u8d
1771   0A8A 07 BE 11      call printnl
1772   0A8D 06            sysret
1773   0A8E             
1774   0A8E             
1775   0A8E             ; file structure:
1776   0A8E             ; 512 bytes header
1777   0A8E             ; header used to tell whether the block is free
1778   0A8E             ;------------------------------------------------------------------------------------------------------;
1779   0A8E             ; CREATE NEW TEXTFILE
1780   0A8E             ;------------------------------------------------------------------------------------------------------;
1781   0A8E             ; d = content pointer in user space
1782   0A8E             ; c = file size
1783   0A8E             fs_starcom:
1784   0A8E FD 4E       	mov si, d
1785   0A90 FD 4F 88 26 	mov di, transient_area
1786   0A94 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1787   0A97 04          	load					; load data from user-space
1788   0A98 07 19 0B    	call fs_find_empty_block	; look for empty data blocks
1789   0A9B D8          	push b				; save empty block LBA
1790   0A9C FD 79         mov g, b
1791   0A9E             ;create header file by grabbing file name from parameter	
1792   0A9E 3B 88 28    	mov d, transient_area + 512			; pointer to file contents
1793   0AA1 D9          	push c							; save length
1794   0AA2 19 01       	mov al, 1
1795   0AA4 3D 88 26    	mov [transient_area], al					; mark sectors as USED (not NULL)
1796   0AA7 3B 88 26    	mov d, transient_area
1797   0AAA 12            mov a, c
1798   0AAB 26 00 02      mov b, 512
1799   0AAE AE            div a, b
1800   0AAF FD 77         inc b         ; inc b as the division will most likely have a remainder
1801   0AB1 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1802   0AB2 38 00 00    	mov c, 0      ; lba 
1803   0AB5 FD 27         mov b, g      ; lba 
1804   0AB7 07 94 04    	call ide_write_sect			; write sectors
1805   0ABA             ; now we add the file to the current directory!
1806   0ABA             fs_starcom_add_to_dir:	
1807   0ABA 14 4B 17    	mov a, [current_dir_id]
1808   0ABD 77          	inc a
1809   0ABE 27          	mov b, a					; metadata sector
1810   0ABF 38 00 00    	mov c, 0
1811   0AC2 FD 79       	mov g, b					; save LBA
1812   0AC4 3B 88 24    	mov d, scrap_sector
1813   0AC7 22 01       	mov ah, $01			  ; 1 sector
1814   0AC9 07 6E 04    	call ide_read_sect		; read metadata sector
1815   0ACC             fs_starcom_add_to_dir_L2:
1816   0ACC BD 00       	cmp byte[d], 0
1817   0ACE C6 D7 0A    	je fs_starcom_add_to_dir_null
1818   0AD1 58 20 00    	add d, FST_ENTRY_SIZE
1819   0AD4 0A CC 0A    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1820   0AD7             fs_starcom_add_to_dir_null:
1821   0AD7 FD 4D 89 26 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1822   0ADB FD 50       	mov di, d
1823   0ADD 07 69 10    	call _strcpy			; copy file name
1824   0AE0 58 18 00    	add d, 24			; skip name
1825   0AE3 19 07       	mov al, %00000111	; type=file, execute, write, read
1826   0AE5 3E          	mov [d], al			
1827   0AE6 58 03 00    	add d, 3
1828   0AE9 E4          	pop a
1829   0AEA 5F 00 02      sub a, 512
1830   0AED 43          	mov [d], a ; file size
1831   0AEE 63 02 00    	sub d, 2
1832   0AF1 E5          	pop b				; get file LBA
1833   0AF2 FD 43       	mov [d], b			; save LBA	
1834   0AF4             ; set file creation date	
1835   0AF4 58 04 00    	add d, 4
1836   0AF7 19 04       	mov al, 4
1837   0AF9 05 01       	syscall sys_rtc
1838   0AFB 1A          	mov al, ah
1839   0AFC 3E          	mov [d], al			; set day
1840   0AFD 79          	inc d
1841   0AFE 19 05       	mov al, 5
1842   0B00 05 01       	syscall sys_rtc
1843   0B02 1A          	mov al, ah
1844   0B03 3E          	mov [d], al			; set month
1845   0B04 79          	inc d
1846   0B05 19 06       	mov al, 6
1847   0B07 05 01       	syscall sys_rtc
1848   0B09 1A          	mov al, ah
1849   0B0A 3E          	mov [d], al			; set year
1850   0B0B             ; write sector into disk for new directory entry
1851   0B0B FD 27       	mov b, g
1852   0B0D 38 00 00    	mov c, 0
1853   0B10 3B 88 24    	mov d, scrap_sector
1854   0B13 22 01       	mov ah, $01			; disk write, 1 sector
1855   0B15 07 94 04    	call ide_write_sect		; write sector
1856   0B18 06          	sysret
1857   0B19             
1858   0B19             ;------------------------------------------------------------------------------------------------------;
1859   0B19             ; finds an empty data block
1860   0B19             ; block LBA returned in B
1861   0B19             ;------------------------------------------------------------------------------------------------------;
1862   0B19             fs_find_empty_block:
1863   0B19 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1864   0B1C 38 00 00      mov c, 0                ; upper LBA = 0
1865   0B1F             fs_find_empty_block_L1:  
1866   0B1F 22 01         mov ah, $01                  ; 1 sector
1867   0B21 3B 88 24      mov d, transient_area - 512
1868   0B24 07 6E 04      call ide_read_sect      ; read sector
1869   0B27 BD 00         cmp byte [d], 0
1870   0B29 C6 32 0B      je fs_find_empty_block_found_null
1871   0B2C 55 20 00      add b, FS_SECTORS_PER_FILE
1872   0B2F 0A 1F 0B      jmp fs_find_empty_block_L1
1873   0B32             fs_find_empty_block_found_null:
1874   0B32 09            ret
1875   0B33             
1876   0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1877   0B33             ;; CREATE NEW TEXTFILE
1878   0B33             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1879   0B33             ; search for first null block
1880   0B33             fs_mktxt:
1881   0B33 FD 4E       	mov si, d
1882   0B35 FD 4F 88 1E 	mov di, user_data
1883   0B39 38 00 01    	mov c, 256
1884   0B3C 04          	load					; load data from user-space
1885   0B3D             	
1886   0B3D 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1887   0B40 38 00 00    	mov c, 0						; reset LBA to 0
1888   0B43             fs_mktxt_L1:	
1889   0B43 10 02 01    	mov a, $0102			; disk read
1890   0B46 3B 88 26    	mov d, transient_area
1891   0B49 05 02       	syscall sys_ide ; read sector
1892   0B4B 1E          	mov al, [d]
1893   0B4C B9 00       	cmp al, 0			; check for NULL
1894   0B4E C6 57 0B    	je fs_mktxt_found_null
1895   0B51 55 20 00    	add b, FS_SECTORS_PER_FILE
1896   0B54 0A 43 0B    	jmp fs_mktxt_L1
1897   0B57             fs_mktxt_found_null:
1898   0B57 D8          	push b				; save LBA
1899   0B58             ;create header file by grabbing file name from parameter	
1900   0B58 3B 58 17    	mov d, s_dataentry
1901   0B5B 07 11 12    	call _puts
1902   0B5E 3B 88 28    	mov d, transient_area + 512			; pointer to file contents
1903   0B61 07 77 11    	call _gettxt
1904   0B64 07 44 10    	call _strlen						; get length of file
1905   0B67 D9          	push c							; save length
1906   0B68 19 01       	mov al, 1
1907   0B6A 3D 88 26    	mov [transient_area], al					; mark sectors as USED (not NULL)
1908   0B6D 10 00 00    	mov a, 0
1909   0B70 42 43 17    	mov [index], a
1910   0B73 3B 88 26    	mov d, transient_area
1911   0B76 13          	mov a, d
1912   0B77 42 45 17    	mov [buffer_addr], a
1913   0B7A             fs_mktxt_L2:
1914   0B7A 38 00 00    	mov c, 0
1915   0B7D 10 03 01    	mov a, $0103			; disk write, 1 sector
1916   0B80 05 02       	syscall sys_ide		; write sector
1917   0B82 14 43 17    	mov a, [index]
1918   0B85 77          	inc a
1919   0B86 42 43 17    	mov [index], a
1920   0B89 AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1921   0B8C C6 9E 0B    	je fs_mktxt_add_to_dir
1922   0B8F FD 77       	inc b
1923   0B91 14 45 17    	mov a, [buffer_addr]
1924   0B94 53 00 02    	add a, 512
1925   0B97 42 45 17    	mov [buffer_addr], a
1926   0B9A 3C          	mov d, a
1927   0B9B 0A 7A 0B    	jmp fs_mktxt_L2
1928   0B9E             ; now we add the file to the current directory!
1929   0B9E             fs_mktxt_add_to_dir:	
1930   0B9E 14 4B 17    	mov a, [current_dir_id]
1931   0BA1 77          	inc a
1932   0BA2 27          	mov b, a					; metadata sector
1933   0BA3 38 00 00    	mov c, 0
1934   0BA6 FD 79       	mov g, b					; save LBA
1935   0BA8 3B 88 26    	mov d, transient_area
1936   0BAB 10 02 01    	mov a, $0102			; disk read
1937   0BAE 05 02       	syscall sys_ide		; read metadata sector
1938   0BB0             fs_mktxt_add_to_dir_L2:
1939   0BB0 1E          	mov al, [d]
1940   0BB1 B9 00       	cmp al, 0
1941   0BB3 C6 BC 0B    	je fs_mktxt_add_to_dir_null
1942   0BB6 58 20 00    	add d, FST_ENTRY_SIZE
1943   0BB9 0A B0 0B    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1944   0BBC             fs_mktxt_add_to_dir_null:
1945   0BBC FD 4D 88 1E 	mov si, user_data
1946   0BC0 FD 50       	mov di, d
1947   0BC2 07 69 10    	call _strcpy			; copy file name
1948   0BC5 58 18 00    	add d, 24			; skip name
1949   0BC8 19 06       	mov al, %00000110		; no execute, write, read, not directory
1950   0BCA 3E          	mov [d], al			
1951   0BCB 58 03 00    	add d, 3
1952   0BCE E4          	pop a
1953   0BCF 43          	mov [d], a
1954   0BD0 63 02 00    	sub d, 2
1955   0BD3 E5          	pop b				; get file LBA
1956   0BD4 FD 43       	mov [d], b			; save LBA	
1957   0BD6             	
1958   0BD6             	; set file creation date	
1959   0BD6 58 04 00    	add d, 4
1960   0BD9 19 04       	mov al, 4
1961   0BDB 05 01       	syscall sys_rtc
1962   0BDD 1A          	mov al, ah
1963   0BDE 3E          	mov [d], al			; set day
1964   0BDF             	
1965   0BDF 79          	inc d
1966   0BE0 19 05       	mov al, 5
1967   0BE2 05 01       	syscall sys_rtc
1968   0BE4 1A          	mov al, ah
1969   0BE5 3E          	mov [d], al			; set month
1970   0BE6             	
1971   0BE6 79          	inc d
1972   0BE7 19 06       	mov al, 6
1973   0BE9 05 01       	syscall sys_rtc
1974   0BEB 1A          	mov al, ah
1975   0BEC 3E          	mov [d], al			; set year
1976   0BED             	
1977   0BED             ; write sector into disk for new directory entry
1978   0BED FD 27       	mov b, g
1979   0BEF 38 00 00    	mov c, 0
1980   0BF2 3B 88 26    	mov d, transient_area
1981   0BF5 10 03 01    	mov a, $0103			; disk write, 1 sector
1982   0BF8 05 02       	syscall sys_ide		; write sector
1983   0BFA 07 BE 11    	call printnl
1984   0BFD 06          	sysret
1985   0BFE             
1986   0BFE             
1987   0BFE             
1988   0BFE             ;------------------------------------------------------------------------------------------------------;
1989   0BFE             ; CREATE NEW BINARY FILE
1990   0BFE             ;------------------------------------------------------------------------------------------------------;
1991   0BFE             ; search for first null block
1992   0BFE             fs_mkbin:
1993   0BFE 19 00         mov al, 0
1994   0C00 3D 3B 17      mov [sys_echo_on], al ; disable echo
1995   0C03 FD 4E         mov si, d
1996   0C05 FD 4F 88 1E   mov di, user_data
1997   0C09 38 00 02      mov c, 512
1998   0C0C 04            load                          ; load data from user-space
1999   0C0D 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
2000   0C10 38 00 00      mov c, 0                      ; upper LBA = 0
2001   0C13             fs_mkbin_L1:  
2002   0C13 22 01         mov ah, $01                  ; 1 sector
2003   0C15 3B 88 26      mov d, transient_area
2004   0C18 07 6E 04      call ide_read_sect            ; read sector
2005   0C1B BD 00         cmp byte[d], 0                ; check for NULL
2006   0C1D C6 26 0C      je fs_mkbin_found_null
2007   0C20 55 20 00      add b, FS_SECTORS_PER_FILE
2008   0C23 0A 13 0C      jmp fs_mkbin_L1
2009   0C26             fs_mkbin_found_null:
2010   0C26 D8            push b                        ; save LBA
2011   0C27             ;create header file by grabbing file name from parameter
2012   0C27 FD 4F 88 28   mov di, transient_area + 512  ; pointer to file contents
2013   0C2B 07 A1 0F      call _load_hex                ; load binary hex
2014   0C2E D9            push c                        ; save size (nbr of bytes)
2015   0C2F 19 01         mov al, 1
2016   0C31 3D 88 26      mov [transient_area], al      ; mark sectors as USED (not NULL)
2017   0C34 FD 10         cla
2018   0C36 42 43 17      mov [index], a
2019   0C39 3B 88 26      mov d, transient_area
2020   0C3C 13            mov a, d
2021   0C3D 42 45 17      mov [buffer_addr], a
2022   0C40             fs_mkbin_L2:
2023   0C40 38 00 00      mov c, 0
2024   0C43 22 01         mov ah, $01                   ; disk write, 1 sector
2025   0C45 07 94 04      call ide_write_sect           ; write sector
2026   0C48 14 43 17      mov a, [index]
2027   0C4B 77            inc a
2028   0C4C 42 43 17      mov [index], a
2029   0C4F AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
2030   0C52 C6 64 0C      je fs_mkbin_add_to_dir
2031   0C55 FD 77         inc b
2032   0C57 14 45 17      mov a, [buffer_addr]
2033   0C5A 53 00 02      add a, 512
2034   0C5D 42 45 17      mov [buffer_addr], a
2035   0C60 3C            mov d, a
2036   0C61 0A 40 0C      jmp fs_mkbin_L2
2037   0C64             ; now we add the file to the current directory!
2038   0C64             fs_mkbin_add_to_dir:  
2039   0C64 14 4B 17      mov a, [current_dir_id]
2040   0C67 77            inc a
2041   0C68 27            mov b, a                      ; metadata sector
2042   0C69 38 00 00      mov c, 0
2043   0C6C FD 79         mov g, b                      ; save LBA
2044   0C6E 3B 88 26      mov d, transient_area
2045   0C71 22 01         mov ah, $01                  ; 1 sector
2046   0C73 07 6E 04      call ide_read_sect            ; read metadata sector
2047   0C76             fs_mkbin_add_to_dir_L2:
2048   0C76 BD 00         cmp byte[d], 0
2049   0C78 C6 81 0C      je fs_mkbin_add_to_dir_null
2050   0C7B 58 20 00      add d, FST_ENTRY_SIZE
2051   0C7E 0A 76 0C      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
2052   0C81             fs_mkbin_add_to_dir_null:
2053   0C81 FD 4D 88 1E   mov si, user_data
2054   0C85 FD 50         mov di, d
2055   0C87 07 69 10      call _strcpy                  ; copy file name
2056   0C8A 58 18 00      add d, 24                     ; skip name
2057   0C8D 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2058   0C8F 3E            mov [d], al
2059   0C90 58 03 00      add d, 3
2060   0C93 E4            pop a
2061   0C94 43            mov [d], a
2062   0C95 63 02 00      sub d, 2
2063   0C98 E5            pop b                         ; get file LBA
2064   0C99 FD 43         mov [d], b                    ; save LBA
2065   0C9B               ; set file creation date  
2066   0C9B 58 04 00      add d, 4
2067   0C9E 19 04         mov al, 4
2068   0CA0 05 01         syscall sys_rtc
2069   0CA2 1A            mov al, ah
2070   0CA3 3E            mov [d], al                   ; set day
2071   0CA4 79            inc d
2072   0CA5 19 05         mov al, 5
2073   0CA7 05 01         syscall sys_rtc
2074   0CA9 1A            mov al, ah
2075   0CAA 3E            mov [d], al                   ; set month
2076   0CAB 79            inc d
2077   0CAC 19 06         mov al, 6
2078   0CAE 05 01         syscall sys_rtc
2079   0CB0 1A            mov al, ah
2080   0CB1 3E            mov [d], al                   ; set year
2081   0CB2             ; write sector into disk for new directory entry
2082   0CB2 FD 27         mov b, g
2083   0CB4 38 00 00      mov c, 0
2084   0CB7 3B 88 26      mov d, transient_area
2085   0CBA 22 01         mov ah, $01                   ; disk write, 1 sector
2086   0CBC 07 94 04      call ide_write_sect           ; write sector
2087   0CBF 19 01         mov al, 1
2088   0CC1 3D 3B 17      mov [sys_echo_on], al ; enable echo
2089   0CC4 06            sysret
2090   0CC5             
2091   0CC5             ;------------------------------------------------------------------------------------------------------;
2092   0CC5             ; PWD - PRINT WORKING DIRECTORY
2093   0CC5             ;------------------------------------------------------------------------------------------------------;    
2094   0CC5             fs_pwd:
2095   0CC5 3B 08 1E      mov d, filename
2096   0CC8 19 00         mov al, 0
2097   0CCA 3E            mov [d], al                   ; initialize path string 
2098   0CCB 14 4B 17      mov a, [current_dir_id]
2099   0CCE 07 A4 07      call fs_dir_id_to_path_E0
2100   0CD1 3B 08 1E      mov d, filename
2101   0CD4 07 FD 0F      call _strrev
2102   0CD7 07 11 12      call _puts
2103   0CDA 07 BE 11      call printnl
2104   0CDD 06            sysret
2105   0CDE             
2106   0CDE             ;------------------------------------------------------------------------------------------------------;
2107   0CDE             ; get current directory LBA
2108   0CDE             ; A: returned LBA
2109   0CDE             ;------------------------------------------------------------------------------------------------------;
2110   0CDE             cmd_get_curr_dir_LBA:
2111   0CDE 14 4B 17      mov a, [current_dir_id]
2112   0CE1 06            sysret
2113   0CE2             
2114   0CE2             ;------------------------------------------------------------------------------------------------------;
2115   0CE2             ; CAT
2116   0CE2             ; userspace destination data pointer in D
2117   0CE2             ; filename starts at D, but is overwritten after the read is made
2118   0CE2             ;------------------------------------------------------------------------------------------------------;:
2119   0CE2             fs_cat:
2120   0CE2 DA            push d                              ; save userspace file data destination
2121   0CE3 FD 4E         mov si, d
2122   0CE5 FD 4F 88 1E   mov di, user_data
2123   0CE9 38 00 02      mov c, 512
2124   0CEC 04            load                                ; copy filename from user-space
2125   0CED 29 4B 17      mov b, [current_dir_id]
2126   0CF0 FD 77         inc b                               ; metadata sector
2127   0CF2 38 00 00      mov c, 0                            ; upper LBA = 0
2128   0CF5 22 01         mov ah, $01                  ; 1 sector
2129   0CF7 3B 88 24      mov d, transient_area-512
2130   0CFA 07 6E 04      call ide_read_sect                  ; read directory
2131   0CFD FD 10         cla
2132   0CFF 42 43 17      mov [index], a                      ; reset file counter
2133   0D02             fs_cat_L1:
2134   0D02 FD 4E         mov si, d
2135   0D04 FD 4F 88 1E   mov di, user_data
2136   0D08 07 54 10      call _strcmp
2137   0D0B C6 21 0D      je fs_cat_found_entry
2138   0D0E 58 20 00      add d, 32
2139   0D11 14 43 17      mov a, [index]
2140   0D14 77            inc a
2141   0D15 42 43 17      mov [index], a
2142   0D18 AF 10 00      cmp a, FST_FILES_PER_DIR
2143   0D1B C6 3C 0D      je fs_cat_not_found
2144   0D1E 0A 02 0D      jmp fs_cat_L1
2145   0D21             fs_cat_found_entry:
2146   0D21 58 19 00      add d, 25                           ; get to dirID of file in disk
2147   0D24 2A            mov b, [d]                          ; get LBA
2148   0D25 FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2149   0D27 3B 88 26      mov d, transient_area  
2150   0D2A 38 00 00      mov c, 0
2151   0D2D 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2152   0D2F 07 6E 04      call ide_read_sect                  ; read sectors
2153   0D32 F0            pop di                              ; write userspace file data destination to DI
2154   0D33 FD 4D 88 26   mov si, transient_area              ; data origin
2155   0D37 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2156   0D3A 03            store
2157   0D3B 06            sysret
2158   0D3C             fs_cat_not_found:
2159   0D3C E7            pop d
2160   0D3D 06            sysret
2161   0D3E             
2162   0D3E             ;------------------------------------------------------------------------------------------------------;
2163   0D3E             ; RMDIR - remove DIR by dirID
2164   0D3E             ;------------------------------------------------------------------------------------------------------;
2165   0D3E             ; deletes a directory entry in the given directory's file list 
2166   0D3E             ; also deletes the actual directory entry in the FST
2167   0D3E             ; synopsis: rmdir /usr/local/testdir
2168   0D3E             ; B = dirID
2169   0D3E             fs_rmdir:
2170   0D3E FD 79         mov g, b
2171   0D40 11            mov a, b
2172   0D41 07 E0 07      call get_parentID_from_dirID  ; now get the directory's parent, in A
2173   0D44 D7            push a                        ; save dirID
2174   0D45             ; search for directory's entry in the parent's directory then and delete it
2175   0D45 77            inc a                         ; metadata sector
2176   0D46 27            mov b, a
2177   0D47 38 00 00      mov c, 0                      ; upper LBA = 0
2178   0D4A 22 01         mov ah, $01          ;
2179   0D4C 3B 88 26      mov d, transient_area
2180   0D4F 07 6E 04      call ide_read_sect            ; read directory
2181   0D52 FD 10         cla
2182   0D54 42 43 17      mov [index], a                ; reset file counter
2183   0D57 FD 27         mov b, g                      ; retrieve directory's dirID
2184   0D59             fs_rmdir_L1:
2185   0D59 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2186   0D5C B0            cmp a, b                      ; compare dirID's to find the directory
2187   0D5D C6 73 0D      je fs_rmdir_found_entry
2188   0D60 58 20 00      add d, 32
2189   0D63 14 43 17      mov a, [index]
2190   0D66 77            inc a
2191   0D67 42 43 17      mov [index], a
2192   0D6A AF 10 00      cmp a, FST_FILES_PER_DIR
2193   0D6D C6 98 0D      je fs_rmdir_not_found
2194   0D70 0A 59 0D      jmp fs_rmdir_L1
2195   0D73             fs_rmdir_found_entry:
2196   0D73 FD 10         cla
2197   0D75 3E            mov [d], al                   ; make filename NULL
2198   0D76 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2199   0D79 E5            pop b
2200   0D7A FD 77         inc b                         ; metadata sector
2201   0D7C 38 00 00      mov c, 0                      ; upper LBA = 0
2202   0D7F 22 01         mov ah, $01          ; 
2203   0D81 3B 88 26      mov d, transient_area
2204   0D84 07 94 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2205   0D87             
2206   0D87 FD 27         mov b, g
2207   0D89 3B 88 26      mov d, transient_area  
2208   0D8C FD 10         cla
2209   0D8E 3E            mov [d], al                   ; make directory's name header NULL for re-use
2210   0D8F 38 00 00      mov c, 0
2211   0D92 22 01         mov ah, $01                   ; disk write 1 sect
2212   0D94 07 94 04      call ide_write_sect           ; delete directory given by dirID in B
2213   0D97 06            sysret
2214   0D98             fs_rmdir_not_found:
2215   0D98 E5            pop b
2216   0D99 06            sysret
2217   0D9A             
2218   0D9A             ;------------------------------------------------------------------------------------------------------;
2219   0D9A             ; RM - remove file
2220   0D9A             ;------------------------------------------------------------------------------------------------------;
2221   0D9A             ; frees up the data sectors for the file further down the disk
2222   0D9A             ; deletes file entry in the directory's file list 
2223   0D9A             fs_rm:
2224   0D9A FD 4E         mov si, d
2225   0D9C FD 4F 88 1E   mov di, user_data
2226   0DA0 38 00 02      mov c, 512
2227   0DA3 04            load                          ; load data from user-space
2228   0DA4 14 4B 17      mov a, [current_dir_id]
2229   0DA7 77            inc a                         ; metadata sector
2230   0DA8 27            mov b, a
2231   0DA9 38 00 00      mov c, 0                      ; upper LBA = 0
2232   0DAC 22 01         mov ah, $01                  ; 1 sector
2233   0DAE 3B 88 26      mov d, transient_area
2234   0DB1 07 6E 04      call ide_read_sect            ; read directory
2235   0DB4 10 00 00      mov a, 0
2236   0DB7 42 43 17      mov [index], a                ; reset file counter
2237   0DBA             fs_rm_L1:
2238   0DBA FD 4E         mov si, d
2239   0DBC FD 4F 88 1E   mov di, user_data
2240   0DC0 07 54 10      call _strcmp
2241   0DC3 C6 D9 0D      je fs_rm_found_entry
2242   0DC6 58 20 00      add d, 32
2243   0DC9 14 43 17      mov a, [index]
2244   0DCC 77            inc a
2245   0DCD 42 43 17      mov [index], a
2246   0DD0 AF 10 00      cmp a, FST_FILES_PER_DIR
2247   0DD3 C6 01 0E      je fs_rm_not_found
2248   0DD6 0A BA 0D      jmp fs_rm_L1
2249   0DD9             fs_rm_found_entry:
2250   0DD9 2B 19 00      mov b, [d + 25]               ; get LBA
2251   0DDC FD 79         mov g, b                      ; save LBA
2252   0DDE 19 00         mov al, 0
2253   0DE0 3E            mov [d], al                   ; make file entry NULL
2254   0DE1 14 4B 17      mov a, [current_dir_id]
2255   0DE4 77            inc a                         ; metadata sector
2256   0DE5 27            mov b, a
2257   0DE6 38 00 00      mov c, 0                      ; upper LBA = 0
2258   0DE9 22 01         mov ah, $01                   ; disk write
2259   0DEB 3B 88 26      mov d, transient_area
2260   0DEE 07 94 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2261   0DF1 3B 88 26      mov d, transient_area  
2262   0DF4 19 00         mov al, 0
2263   0DF6 3E            mov [d], al                   ; make file's data header NULL for re-use
2264   0DF7 38 00 00      mov c, 0
2265   0DFA FD 27         mov b, g                      ; get data header LBA
2266   0DFC 22 01         mov ah, $01                   ; disk write 1 sect
2267   0DFE 07 94 04      call ide_write_sect           ; write sector
2268   0E01             fs_rm_not_found:  
2269   0E01 06            sysret  
2270   0E02             
2271   0E02             ;------------------------------------------------------------------------------------------------------;
2272   0E02             ; mv - move / change file name
2273   0E02             ;------------------------------------------------------------------------------------------------------;
2274   0E02             fs_mv:
2275   0E02 FD 4E         mov si, d
2276   0E04 FD 4F 88 1E   mov di, user_data
2277   0E08 38 00 02      mov c, 512
2278   0E0B 04            load                          ; load data from user-space
2279   0E0C 14 4B 17      mov a, [current_dir_id]
2280   0E0F 77            inc a                         ; metadata sector
2281   0E10 27            mov b, a  
2282   0E11 38 00 00      mov c, 0                      ; upper LBA = 0
2283   0E14 22 01         mov ah, $01                  ; 1 sector
2284   0E16 3B 88 26      mov d, transient_area
2285   0E19 07 6E 04      call ide_read_sect            ; read directory
2286   0E1C FD 10         cla
2287   0E1E 42 43 17      mov [index], a                ; reset file counter
2288   0E21             fs_mv_L1:
2289   0E21 FD 4E         mov si, d
2290   0E23 FD 4F 88 1E   mov di, user_data
2291   0E27 07 54 10      call _strcmp
2292   0E2A C6 40 0E      je fs_mv_found_entry
2293   0E2D 58 20 00      add d, 32
2294   0E30 14 43 17      mov a, [index]
2295   0E33 77            inc a
2296   0E34 42 43 17      mov [index], a
2297   0E37 AF 10 00      cmp a, FST_FILES_PER_DIR
2298   0E3A C6 72 0E      je fs_mv_not_found
2299   0E3D 0A 21 0E      jmp fs_mv_L1
2300   0E40             fs_mv_found_entry:  
2301   0E40 DA            push d
2302   0E41 FD 4D 08 1F   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2303   0E45 FD 50         mov di, d
2304   0E47 07 69 10      call _strcpy  
2305   0E4A 38 00 00      mov c, 0
2306   0E4D 3B 88 26      mov d, transient_area
2307   0E50 22 01         mov ah, $01                   ; disk write 1 sect
2308   0E52 07 94 04      call ide_write_sect           ; write sector
2309   0E55 E7            pop d
2310   0E56             ;; need to check whether its a dir or a file here ;;;
2311   0E56 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2312   0E59 22 01         mov ah, $01
2313   0E5B 3B 88 26      mov d, transient_area
2314   0E5E 38 00 00      mov c, 0
2315   0E61 07 6E 04      call ide_read_sect            ; read directory entry
2316   0E64 FD 4D 08 1F   mov si, user_data + 128
2317   0E68 FD 50         mov di, d
2318   0E6A 07 69 10      call _strcpy                  ; change directory's name
2319   0E6D 22 01         mov ah, $01
2320   0E6F 07 94 04      call ide_write_sect           ; rewrite directory back to disk
2321   0E72             fs_mv_not_found:
2322   0E72 06            sysret
2323   0E73             
2324   0E73             
2325   0E73             ;----------------------------------------------------------------------------------------------------;
2326   0E73             ; Process Index in A
2327   0E73             ;----------------------------------------------------------------------------------------------------;
2328   0E73             find_free_proc:
2329   0E73 FD 4D F9 1B   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2330   0E77             find_free_proc_L0:
2331   0E77 F6            lodsb                               ; get process state
2332   0E78 B9 00         cmp al, 0
2333   0E7A C6 80 0E      je find_free_proc_free              ; if free, jump
2334   0E7D 0A 77 0E      jmp find_free_proc_L0               ; else, goto next
2335   0E80             find_free_proc_free:
2336   0E80 4E            mov a, si
2337   0E81 5F F9 1B      sub a, 1 + proc_availab_table       ; get process index
2338   0E84 09            ret
2339   0E85               
2340   0E85             
2341   0E85             ;----------------------------------------------------------------------------------------------------;
2342   0E85             ; Process Index in AL
2343   0E85             ;----------------------------------------------------------------------------------------------------;
2344   0E85             proc_memory_map:
2345   0E85 22 00         mov ah, 0
2346   0E87 27            mov b, a                      ; page in BL, 0 in BH
2347   0E88 FD 9D 05      shl a, 5                      ; multiply by 32
2348   0E8B 39            mov c, a                      ; save in C
2349   0E8C 57 20 00      add c, 32
2350   0E8F             proc_memory_map_L0:
2351   0E8F 02            pagemap
2352   0E90 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2353   0E93 53 01 00      add a, 1                      ; increase both 
2354   0E96 B1            cmp a, c                      ; check to see if we reached the end of memory
2355   0E97 C7 8F 0E      jne proc_memory_map_L0
2356   0E9A 09            ret
2357   0E9B               
2358   0E9B             
2359   0E9B             syscall_terminate_proc:
2360   0E9B 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2361   0E9E                                                    ; since they will not be used for anything here.
2362   0E9E 1D 42 17      mov al, [active_proc_index]
2363   0EA1 22 00         mov ah, 0  
2364   0EA3 FD 9D 05      shl a, 5                             ; x32
2365   0EA6 53 08 1C      add a, proc_names
2366   0EA9 3C            mov d, a
2367   0EAA 19 00         mov al, 0
2368   0EAC 3E            mov [d], al                           ; nullify process name
2369   0EAD             
2370   0EAD 1D 42 17      mov al, [active_proc_index]
2371   0EB0 22 00         mov ah, 0  
2372   0EB2 3C            mov d, a
2373   0EB3 19 00         mov al, 0
2374   0EB5 3F F8 1B      mov [d + proc_availab_table], al    ; make process empty again
2375   0EB8               
2376   0EB8 1D 41 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2377   0EBB 80            dec al
2378   0EBC 3D 41 17      mov [nbr_active_procs], al
2379   0EBF             
2380   0EBF             ; now load the shell process again
2381   0EBF 19 02         mov al, 2                           ; next process = process 2 = shell
2382   0EC1 3D 42 17      mov [active_proc_index], al         ; set next active proc
2383   0EC4             
2384   0EC4             ; calculate LUT entry for next process
2385   0EC4 22 00         mov ah, 0
2386   0EC6 FD 99         shl a                               ; x2
2387   0EC8 B7 91 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2388   0ECB               
2389   0ECB 4D            mov si, a                           ; source is proc state block
2390   0ECC 48            mov a, sp
2391   0ECD 5F 13 00      sub a, 19
2392   0ED0 4F            mov di, a                           ; destination is kernel stack
2393   0ED1             ; restore SP
2394   0ED1 7D            dec a
2395   0ED2 47            mov sp, a
2396   0ED3 38 14 00      mov c, 20
2397   0ED6 FD F5         rep movsb
2398   0ED8             ; set VM process
2399   0ED8 1D 42 17      mov al, [active_proc_index]
2400   0EDB 01            setptb
2401   0EDC                 
2402   0EDC 4C            popa
2403   0EDD 06            sysret
2404   0EDE             
2405   0EDE             syscall_pause_proc:
2406   0EDE             ; save all registers into kernel stack
2407   0EDE 4B            pusha
2408   0EDF 22 00         mov ah, 0
2409   0EE1 1D 42 17      mov al, [active_proc_index]
2410   0EE4 FD 99         shl a              ; x2
2411   0EE6 B7 91 0F      mov a, [proc_table_convert + a]   ; get process state start index
2412   0EE9                 
2413   0EE9 4F            mov di, a
2414   0EEA 48            mov a, sp
2415   0EEB 77            inc a
2416   0EEC 4D            mov si, a
2417   0EED 38 14 00      mov c, 20
2418   0EF0 FD F5         rep movsb                         ; save process state!
2419   0EF2             ; restore kernel stack position to point before interrupt arrived
2420   0EF2 51 14 00      add sp, 20
2421   0EF5             ; now load the shell process again
2422   0EF5 19 02         mov al, 2                         ; next process = process 2 = shell
2423   0EF7 3D 42 17      mov [active_proc_index], al       ; set next active proc
2424   0EFA             
2425   0EFA             ; calculate LUT entry for next process
2426   0EFA 22 00         mov ah, 0
2427   0EFC FD 99         shl a                             ; x2
2428   0EFE B7 91 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2429   0F01               
2430   0F01 4D            mov si, a                         ; source is proc state block
2431   0F02 48            mov a, sp
2432   0F03 5F 13 00      sub a, 19
2433   0F06 4F            mov di, a                         ; destination is kernel stack
2434   0F07             ; restore SP
2435   0F07 7D            dec a
2436   0F08 47            mov sp, a
2437   0F09 38 14 00      mov c, 20
2438   0F0C FD F5         rep movsb
2439   0F0E             ; set VM process
2440   0F0E 1D 42 17      mov al, [active_proc_index]
2441   0F11 01            setptb
2442   0F12                 
2443   0F12 4C            popa
2444   0F13 06            sysret
2445   0F14             
2446   0F14             ;----------------------------------------------------------------------------------------------------;
2447   0F14             ; create a new process
2448   0F14             ; D = path of the process file to be createed
2449   0F14             ; B = arguments ptr
2450   0F14             ;----------------------------------------------------------------------------------------------------;
2451   0F14             syscall_create_proc:
2452   0F14             ; we save the active process first  
2453   0F14 4B            pusha
2454   0F15 22 00         mov ah, 0
2455   0F17 1D 42 17      mov al, [active_proc_index]
2456   0F1A FD 99         shl a              ; x2
2457   0F1C B7 91 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2458   0F1F               
2459   0F1F 4F            mov di, a
2460   0F20 48            mov a, sp
2461   0F21 77            inc a
2462   0F22 4D            mov si, a
2463   0F23 38 14 00      mov c, 20
2464   0F26 FD F5         rep movsb                          ; save process state!
2465   0F28             ; restore kernel stack position to point before interrupt arrived
2466   0F28 51 14 00      add sp, 20
2467   0F2B               
2468   0F2B FD 4E         mov si, d                          ; copy the file path
2469   0F2D FD 4F 88 1E   mov di, user_data
2470   0F31 38 00 02      mov c, 512
2471   0F34 04            load
2472   0F35 11            mov a, b
2473   0F36 4D            mov si, a                          ; copy the arguments
2474   0F37 FD 4F 88 24   mov di, scrap_sector
2475   0F3B 38 00 02      mov c, 512
2476   0F3E 04            load
2477   0F3F 07 26 09      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2478   0F42                                                  ; the file data is loaded into transient_area
2479   0F42             ; now we allocate a new process  
2480   0F42 07 73 0E      call find_free_proc                ; index in A
2481   0F45 01            setptb 
2482   0F46 07 85 0E      call proc_memory_map               ; map process memory pages
2483   0F49             ; copy arguments into process's memory
2484   0F49 FD 4D 88 24   mov si, scrap_sector
2485   0F4D FD 4F 00 00   mov di, 0
2486   0F51 38 00 02      mov c, 512
2487   0F54 03            store
2488   0F55             ; now copy process binary data into process's memory
2489   0F55 FD 4D 88 26   mov si, transient_area
2490   0F59 FD 4F 00 04   mov di, text_org              ; code origin address for all user processes
2491   0F5D 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2492   0F60 03            store                              ; copy process data
2493   0F61                 
2494   0F61 07 73 0E      call find_free_proc                ; index in A
2495   0F64 3D 42 17      mov [active_proc_index], al        ; set new active process
2496   0F67 FD 9D 05      shl a, 5                           ; x32
2497   0F6A 53 08 1C      add a, proc_names
2498   0F6D 4F            mov di, a
2499   0F6E FD 4D 88 1E   mov si, user_data                  ; copy and store process filename
2500   0F72 07 69 10      call _strcpy
2501   0F75               
2502   0F75 07 73 0E      call find_free_proc                ; index in A
2503   0F78 3C            mov d, a
2504   0F79 19 01         mov al, 1
2505   0F7B 3F F8 1B      mov [d + proc_availab_table], al   ; make process busy
2506   0F7E               
2507   0F7E 1D 41 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2508   0F81 7A            inc al
2509   0F82 3D 41 17      mov [nbr_active_procs], al
2510   0F85             ; launch process
2511   0F85 FD D7 FF FF   push word $FFFF 
2512   0F89 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2513   0F8C FD D7 00 04   push word text_org
2514   0F90 06            sysret
2515   0F91             
2516   0F91             proc_table_convert:
2517   0F91 B8 1A         .dw proc_state_table + 0
2518   0F93 CC 1A         .dw proc_state_table + 20
2519   0F95 E0 1A         .dw proc_state_table + 40
2520   0F97 F4 1A         .dw proc_state_table + 60
2521   0F99 08 1B         .dw proc_state_table + 80
2522   0F9B 1C 1B         .dw proc_state_table + 100
2523   0F9D 30 1B         .dw proc_state_table + 120
2524   0F9F 44 1B         .dw proc_state_table + 140
2525   0FA1               
2526   0FA1             ;----------------------------------------------------------------------------------------------;
2527   0FA1             ; GET HEX FILE
2528   0FA1             ; di = destination address
2529   0FA1             ; return length in bytes in C
2530   0FA1             ;----------------------------------------------------------------------------------------------;
2531   0FA1             _load_hex:
2532   0FA1 D7            push a
2533   0FA2 D8            push b
2534   0FA3 DA            push d
2535   0FA4 E2            push si
2536   0FA5 E3            push di
2537   0FA6 38 00 00      mov c, 0
2538   0FA9 50            mov a, di
2539   0FAA 3C            mov d, a          ; start of string data block
2540   0FAB 07 EC 10      call _gets        ; get program string
2541   0FAE               ;call _puts        ; reprint to screen
2542   0FAE 4D            mov si, a
2543   0FAF             __load_hex_loop:
2544   0FAF F6            lodsb             ; load from [SI] to AL
2545   0FB0 B9 00         cmp al, 0         ; check if ASCII 0
2546   0FB2 C6 C0 0F      jz __load_hex_ret
2547   0FB5 36            mov bh, al
2548   0FB6 F6            lodsb
2549   0FB7 2F            mov bl, al
2550   0FB8 07 A2 10      call _atoi        ; convert ASCII byte in B to int (to AL)
2551   0FBB F7            stosb             ; store AL to [DI]
2552   0FBC 78            inc c
2553   0FBD 0A AF 0F      jmp __load_hex_loop
2554   0FC0             __load_hex_ret:
2555   0FC0 F0            pop di
2556   0FC1 EF            pop si
2557   0FC2 E7            pop d
2558   0FC3 E5            pop b
2559   0FC4 E4            pop a
2560   0FC5 09            ret
2561   0FC6             
2562   0FC6             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2563   0FC6             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2564   0FC6             ; for each entry insIDE DIRECTORY:
2565   0FC6             ;  if entry is a file:
2566   0FC6             ;    compare filename to searched filename
2567   0FC6             ;    if filenames are the same, print filename
2568   0FC6             ;  else if entry is a directory:
2569   0FC6             ;    cd to the given directory
2570   0FC6             ;    recursively call cmd_find
2571   0FC6             ;    cd outsIDE previous directory
2572   0FC6             ;  if current entry == last entry, return
2573   0FC6             ; endfor
2574   0FC6             f_find:
2575   0FC6 09            ret
2576   0FC7             
2577   0FC7             
2578   0FC7             ; ---------------------------------------------------------------------
2579   0FC7             ; KERNEL RESET VECTOR
2580   0FC7             ; ---------------------------------------------------------------------
2581   0FC7             kernel_reset_vector:  
2582   0FC7 FD 49 FF F7   mov bp, STACK_BEGIN
2583   0FCB FD 47 FF F7   mov sp, STACK_BEGIN
2584   0FCF               
2585   0FCF 19 81         mov al, %10000001
2586   0FD1 FD 0F         stomsk                        ; mask out timer interrupt for now (only allow UART to interrupt)
2587   0FD3 FD 0C         sti  
2588   0FD5             
2589   0FD5 0C            lodstat
2590   0FD6 87 DF         and al, %11011111             ; disable display register loading
2591   0FD8 0D            stostat
2592   0FD9               
2593   0FD9             ; reset fifo pointers
2594   0FD9 10 88 20      mov a, fifo
2595   0FDC 3B 47 17      mov d, fifo_in
2596   0FDF 43            mov [d], a
2597   0FE0 3B 49 17      mov d, fifo_out
2598   0FE3 43            mov [d], a  
2599   0FE4 19 02         mov al, 2
2600   0FE6 05 03         syscall sys_io                ; enable uart in interrupt mode
2601   0FE8               
2602   0FE8 3B 8D 17      mov d, s_kernel_started
2603   0FEB 07 11 12      call _puts
2604   0FEE             
2605   0FEE 19 10         mov al, 16
2606   0FF0 05 04         syscall sys_filesystem        ; set root dirID
2607   0FF2             
2608   0FF2 3B AA 17      mov d, s_prompt_init
2609   0FF5 07 11 12      call _puts
2610   0FF8 3B 4D 17      mov d, s_init_path
2611   0FFB 05 05         syscall sys_create_proc              ; launch init as a new process
2612   0FFD             
2613   0FFD             
2614   0FFD             ; FILE INCLUDES
2615   0FFD             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  0FFD             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0FFD             IDE_buffer       .EQU  $8204
0003+  0FFD             boot_origin      .EQU  $8004
0004+  0FFD             bios_uart        .EQU  $0002
0005+  0FFD             bios_ide         .EQU  $0003
2616   0FFD             .include "lib/stdio.asm"
0001+  0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0FFD             ; stdio.s
0003+  0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0FFD             .include "lib/string.asm"
0001++ 0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0FFD             ; string.s
0003++ 0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0FFD             
0005++ 0FFD             
0006++ 0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0FFD             ; _strrev
0008++ 0FFD             ; reverse a string
0009++ 0FFD             ; D = string address
0010++ 0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0FFD             ; 01234
0012++ 0FFD             _strrev:
0013++ 0FFD 4B          	pusha
0014++ 0FFE 07 44 10    	call _strlen	; length in C
0015++ 1001 12          	mov a, c
0016++ 1002 AF 01 00    	cmp a, 1
0017++ 1005 D0 1F 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1008 7D          	dec a
0019++ 1009 FD 4E       	mov si, d	; beginning of string
0020++ 100B FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 100D 59          	add d, a	; end of string
0022++ 100E 12          	mov a, c
0023++ 100F FD 9B       	shr a		; divide by 2
0024++ 1011 39          	mov c, a	; C now counts the steps
0025++ 1012             _strrev_L0:
0026++ 1012 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1013 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1014 3E          	mov [d], al	; store left char into right side
0029++ 1015 1B          	mov al, bl
0030++ 1016 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1017 7E          	dec c
0032++ 1018 7F          	dec d
0033++ 1019 C2 00 00    	cmp c, 0
0034++ 101C C7 12 10    	jne _strrev_L0
0035++ 101F             _strrev_end:
0036++ 101F 4C          	popa
0037++ 1020 09          	ret
0038++ 1021             	
0039++ 1021             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1021             ; _strchr
0041++ 1021             ; search string in D for char in AL
0042++ 1021             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1021             _strchr:
0044++ 1021             _strchr_L0:
0045++ 1021 32          	mov bl, [d]
0046++ 1022 C1 00       	cmp bl, 0
0047++ 1024 C6 2F 10    	je _strchr_end
0048++ 1027 BA          	cmp al, bl
0049++ 1028 C6 2F 10    	je _strchr_end
0050++ 102B 79          	inc d
0051++ 102C 0A 21 10    	jmp _strchr_L0
0052++ 102F             _strchr_end:
0053++ 102F 1B          	mov al, bl
0054++ 1030 09          	ret
0055++ 1031             
0056++ 1031             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1031             ; _strstr
0058++ 1031             ; find sub-string
0059++ 1031             ; str1 in SI
0060++ 1031             ; str2 in DI
0061++ 1031             ; SI points to end of source string
0062++ 1031             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1031             _strstr:
0064++ 1031 DB          	push al
0065++ 1032 DA          	push d
0066++ 1033 E3          	push di
0067++ 1034             _strstr_loop:
0068++ 1034 F3          	cmpsb					; compare a byte of the strings
0069++ 1035 C7 40 10    	jne _strstr_ret
0070++ 1038 FC 00 00    	lea d, [di + 0]
0071++ 103B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 103D C7 34 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1040             _strstr_ret:
0074++ 1040 F0          	pop di
0075++ 1041 E7          	pop d
0076++ 1042 E8          	pop al
0077++ 1043 09          	ret
0078++ 1044             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1044             ; length of null terminated string
0080++ 1044             ; result in C
0081++ 1044             ; pointer in D
0082++ 1044             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1044             _strlen:
0084++ 1044 DA          	push d
0085++ 1045 38 00 00    	mov c, 0
0086++ 1048             _strlen_L1:
0087++ 1048 BD 00       	cmp byte [d], 0
0088++ 104A C6 52 10    	je _strlen_ret
0089++ 104D 79          	inc d
0090++ 104E 78          	inc c
0091++ 104F 0A 48 10    	jmp _strlen_L1
0092++ 1052             _strlen_ret:
0093++ 1052 E7          	pop d
0094++ 1053 09          	ret
0095++ 1054             
0096++ 1054             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1054             ; STRCMP
0098++ 1054             ; compare two strings
0099++ 1054             ; str1 in SI
0100++ 1054             ; str2 in DI
0101++ 1054             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1054             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1054             _strcmp:
0104++ 1054 DB          	push al
0105++ 1055 DA          	push d
0106++ 1056 E3          	push di
0107++ 1057 E2          	push si
0108++ 1058             _strcmp_loop:
0109++ 1058 F3          	cmpsb					; compare a byte of the strings
0110++ 1059 C7 64 10    	jne _strcmp_ret
0111++ 105C FB FF FF    	lea d, [si +- 1]
0112++ 105F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1061 C7 58 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1064             _strcmp_ret:
0115++ 1064 EF          	pop si
0116++ 1065 F0          	pop di
0117++ 1066 E7          	pop d
0118++ 1067 E8          	pop al
0119++ 1068 09          	ret
0120++ 1069             
0121++ 1069             
0122++ 1069             ; STRCPY
0123++ 1069             ; copy null terminated string from SI to DI
0124++ 1069             ; source in SI
0125++ 1069             ; destination in DI
0126++ 1069             _strcpy:
0127++ 1069 E2          	push si
0128++ 106A E3          	push di
0129++ 106B DB          	push al
0130++ 106C             _strcpy_L1:
0131++ 106C F6          	lodsb
0132++ 106D F7          	stosb
0133++ 106E B9 00       	cmp al, 0
0134++ 1070 C7 6C 10    	jne _strcpy_L1
0135++ 1073             _strcpy_end:
0136++ 1073 E8          	pop al
0137++ 1074 F0          	pop di
0138++ 1075 EF          	pop si
0139++ 1076 09          	ret
0140++ 1077             
0141++ 1077             ; STRCAT
0142++ 1077             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1077             ; source in SI
0144++ 1077             ; destination in DI
0145++ 1077             _strcat:
0146++ 1077 E2          	push si
0147++ 1078 E3          	push di
0148++ 1079 D7          	push a
0149++ 107A DA          	push d
0150++ 107B 50          	mov a, di
0151++ 107C 3C          	mov d, a
0152++ 107D             _strcat_goto_end_L1:
0153++ 107D BD 00       	cmp byte[d], 0
0154++ 107F C6 86 10    	je _strcat_start
0155++ 1082 79          	inc d
0156++ 1083 0A 7D 10    	jmp _strcat_goto_end_L1
0157++ 1086             _strcat_start:
0158++ 1086 FD 50       	mov di, d
0159++ 1088             _strcat_L1:
0160++ 1088 F6          	lodsb
0161++ 1089 F7          	stosb
0162++ 108A B9 00       	cmp al, 0
0163++ 108C C7 88 10    	jne _strcat_L1
0164++ 108F             _strcat_end:
0165++ 108F E7          	pop d
0166++ 1090 E4          	pop a
0167++ 1091 F0          	pop di
0168++ 1092 EF          	pop si
0169++ 1093 09          	ret
0170++ 1094             
0171++ 1094             
0005+  1094             
0006+  1094             
0007+  1094             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1094             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  1094             ; ASCII in BL
0010+  1094             ; result in AL
0011+  1094             ; ascii for F = 0100 0110
0012+  1094             ; ascii for 9 = 0011 1001
0013+  1094             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1094             hex_ascii_encode:
0015+  1094 1B            mov al, bl
0016+  1095 93 40         test al, $40        ; test if letter or number
0017+  1097 C7 9D 10      jnz hex_letter
0018+  109A 87 0F         and al, $0F        ; get number
0019+  109C 09            ret
0020+  109D             hex_letter:
0021+  109D 87 0F         and al, $0F        ; get letter
0022+  109F 6A 09         add al, 9
0023+  10A1 09            ret
0024+  10A2             
0025+  10A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  10A2             ; ATOI
0027+  10A2             ; 2 letter hex string in B
0028+  10A2             ; 8bit integer returned in AL
0029+  10A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  10A2             _atoi:
0031+  10A2 D8            push b
0032+  10A3 07 94 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  10A6 30            mov bl, bh
0034+  10A7 DB            push al          ; save a
0035+  10A8 07 94 10      call hex_ascii_encode
0036+  10AB EA            pop bl  
0037+  10AC FD 9E 04      shl al, 4
0038+  10AF 8C            or al, bl
0039+  10B0 E5            pop b
0040+  10B1 09            ret  
0041+  10B2             
0042+  10B2             
0043+  10B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  10B2             ; scanf
0045+  10B2             ; no need for explanations!
0046+  10B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  10B2             scanf:
0048+  10B2 09            ret
0049+  10B3             
0050+  10B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  10B3             ; ITOA
0052+  10B3             ; 8bit value in BL
0053+  10B3             ; 2 byte ASCII result in A
0054+  10B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  10B3             _itoa:
0056+  10B3 DA            push d
0057+  10B4 D8            push b
0058+  10B5 A7 00         mov bh, 0
0059+  10B7 FD A4 04      shr bl, 4  
0060+  10BA 74            mov d, b
0061+  10BB 1F 4D 13      mov al, [d + s_hex_digits]
0062+  10BE 23            mov ah, al
0063+  10BF               
0064+  10BF E5            pop b
0065+  10C0 D8            push b
0066+  10C1 A7 00         mov bh, 0
0067+  10C3 FD 87 0F      and bl, $0F
0068+  10C6 74            mov d, b
0069+  10C7 1F 4D 13      mov al, [d + s_hex_digits]
0070+  10CA E5            pop b
0071+  10CB E7            pop d
0072+  10CC 09            ret
0073+  10CD             
0074+  10CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  10CD             ; HEX STRING TO BINARY
0076+  10CD             ; di = destination address
0077+  10CD             ; si = source
0078+  10CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  10CD             _hex_to_int:
0080+  10CD             _hex_to_int_L1:
0081+  10CD F6            lodsb          ; load from [SI] to AL
0082+  10CE B9 00         cmp al, 0        ; check if ASCII 0
0083+  10D0 C6 DD 10      jz _hex_to_int_ret
0084+  10D3 36            mov bh, al
0085+  10D4 F6            lodsb
0086+  10D5 2F            mov bl, al
0087+  10D6 07 A2 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  10D9 F7            stosb          ; store AL to [DI]
0089+  10DA 0A CD 10      jmp _hex_to_int_L1
0090+  10DD             _hex_to_int_ret:
0091+  10DD 09            ret    
0092+  10DE             
0093+  10DE             
0094+  10DE             
0095+  10DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  10DE             ; GETCHAR
0097+  10DE             ; char in ah
0098+  10DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  10DE             getch:
0100+  10DE DB            push al
0101+  10DF             getch_retry:
0102+  10DF 19 01         mov al, 1
0103+  10E1 05 03         syscall sys_io      ; receive in AH
0104+  10E3 E8            pop al
0105+  10E4 09            ret
0106+  10E5             
0107+  10E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  10E5             ; PUTCHAR
0109+  10E5             ; char in ah
0110+  10E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  10E5             _putchar:
0112+  10E5 DB            push al
0113+  10E6 19 00         mov al, 0
0114+  10E8 05 03         syscall sys_io      ; char in AH
0115+  10EA E8            pop al
0116+  10EB 09            ret
0117+  10EC             
0118+  10EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  10EC             ;; INPUT A STRING
0120+  10EC             ;; terminates with null
0121+  10EC             ;; pointer in D
0122+  10EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  10EC             _gets:
0124+  10EC D7            push a
0125+  10ED DA            push d
0126+  10EE             _gets_loop:
0127+  10EE 19 01         mov al, 1
0128+  10F0 05 03         syscall sys_io      ; receive in AH
0129+  10F2 76 1B         cmp ah, 27
0130+  10F4 C6 15 11      je _gets_ansi_esc
0131+  10F7 76 0A         cmp ah, $0A        ; LF
0132+  10F9 C6 71 11      je _gets_end
0133+  10FC 76 0D         cmp ah, $0D        ; CR
0134+  10FE C6 71 11      je _gets_end
0135+  1101 76 5C         cmp ah, $5C        ; '\\'
0136+  1103 C6 37 11      je _gets_escape
0137+  1106 76 08         cmp ah, $08      ; check for backspace
0138+  1108 C6 11 11      je _gets_backspace
0139+  110B 1A            mov al, ah
0140+  110C 3E            mov [d], al
0141+  110D 79            inc d
0142+  110E 0A EE 10      jmp _gets_loop
0143+  1111             _gets_backspace:
0144+  1111 7F            dec d
0145+  1112 0A EE 10      jmp _gets_loop
0146+  1115             _gets_ansi_esc:
0147+  1115 19 01         mov al, 1
0148+  1117 05 03         syscall sys_io        ; receive in AH without echo
0149+  1119 76 5B         cmp ah, '['
0150+  111B C7 EE 10      jne _gets_loop
0151+  111E 19 01         mov al, 1
0152+  1120 05 03         syscall sys_io          ; receive in AH without echo
0153+  1122 76 44         cmp ah, 'D'
0154+  1124 C6 2F 11      je _gets_left_arrow
0155+  1127 76 43         cmp ah, 'C'
0156+  1129 C6 33 11      je _gets_right_arrow
0157+  112C 0A EE 10      jmp _gets_loop
0158+  112F             _gets_left_arrow:
0159+  112F 7F            dec d
0160+  1130 0A EE 10      jmp _gets_loop
0161+  1133             _gets_right_arrow:
0162+  1133 79            inc d
0163+  1134 0A EE 10      jmp _gets_loop
0164+  1137             _gets_escape:
0165+  1137 19 01         mov al, 1
0166+  1139 05 03         syscall sys_io      ; receive in AH
0167+  113B 76 6E         cmp ah, 'n'
0168+  113D C6 5C 11      je _gets_LF
0169+  1140 76 72         cmp ah, 'r'
0170+  1142 C6 63 11      je _gets_CR
0171+  1145 76 30         cmp ah, '0'
0172+  1147 C6 6A 11      je _gets_NULL
0173+  114A 76 5C         cmp ah, $5C  ; '\'
0174+  114C C6 55 11      je _gets_slash
0175+  114F 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  1150 3E            mov [d], al
0177+  1151 79            inc d
0178+  1152 0A EE 10      jmp _gets_loop
0179+  1155             _gets_slash:
0180+  1155 19 5C         mov al, $5C
0181+  1157 3E            mov [d], al
0182+  1158 79            inc d
0183+  1159 0A EE 10      jmp _gets_loop
0184+  115C             _gets_LF:
0185+  115C 19 0A         mov al, $0A
0186+  115E 3E            mov [d], al
0187+  115F 79            inc d
0188+  1160 0A EE 10      jmp _gets_loop
0189+  1163             _gets_CR:
0190+  1163 19 0D         mov al, $0D
0191+  1165 3E            mov [d], al
0192+  1166 79            inc d
0193+  1167 0A EE 10      jmp _gets_loop
0194+  116A             _gets_NULL:
0195+  116A 19 00         mov al, $00
0196+  116C 3E            mov [d], al
0197+  116D 79            inc d
0198+  116E 0A EE 10      jmp _gets_loop
0199+  1171             _gets_end:
0200+  1171 19 00         mov al, 0
0201+  1173 3E            mov [d], al        ; terminate string
0202+  1174 E7            pop d
0203+  1175 E4            pop a
0204+  1176 09            ret
0205+  1177             
0206+  1177             
0207+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1177             ;; INPUT TEXT
0209+  1177             ;; terminated with CTRL+D
0210+  1177             ;; pointer in D
0211+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1177             _gettxt:
0213+  1177 D7            push a
0214+  1178 DA            push d
0215+  1179             _gettxt_loop:
0216+  1179 19 01         mov al, 1
0217+  117B 05 03         syscall sys_io      ; receive in AH
0218+  117D 76 04         cmp ah, 4      ; EOT
0219+  117F C6 B8 11      je _gettxt_end
0220+  1182 76 08         cmp ah, $08      ; check for backspace
0221+  1184 C6 B4 11      je _gettxt_backspace
0222+  1187 76 5C         cmp ah, $5C        ; '\'
0223+  1189 C6 92 11      je _gettxt_escape
0224+  118C 1A            mov al, ah
0225+  118D 3E            mov [d], al
0226+  118E 79            inc d
0227+  118F 0A 79 11      jmp _gettxt_loop
0228+  1192             _gettxt_escape:
0229+  1192 19 01         mov al, 1
0230+  1194 05 03         syscall sys_io      ; receive in AH
0231+  1196 76 6E         cmp ah, 'n'
0232+  1198 C6 A6 11      je _gettxt_LF
0233+  119B 76 72         cmp ah, 'r'
0234+  119D C6 AD 11      je _gettxt_CR
0235+  11A0 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  11A1 3E            mov [d], al
0237+  11A2 79            inc d
0238+  11A3 0A 79 11      jmp _gettxt_loop
0239+  11A6             _gettxt_LF:
0240+  11A6 19 0A         mov al, $0A
0241+  11A8 3E            mov [d], al
0242+  11A9 79            inc d
0243+  11AA 0A 79 11      jmp _gettxt_loop
0244+  11AD             _gettxt_CR:
0245+  11AD 19 0D         mov al, $0D
0246+  11AF 3E            mov [d], al
0247+  11B0 79            inc d
0248+  11B1 0A 79 11      jmp _gettxt_loop
0249+  11B4             _gettxt_backspace:
0250+  11B4 7F            dec d
0251+  11B5 0A 79 11      jmp _gettxt_loop
0252+  11B8             _gettxt_end:
0253+  11B8 19 00         mov al, 0
0254+  11BA 3E            mov [d], al        ; terminate string
0255+  11BB E7            pop d
0256+  11BC E4            pop a
0257+  11BD 09            ret
0258+  11BE             
0259+  11BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  11BE             ; PRINT NEW LINE
0261+  11BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  11BE             printnl:
0263+  11BE D7            push a
0264+  11BF 10 00 0A      mov a, $0A00
0265+  11C2 05 03         syscall sys_io
0266+  11C4 10 00 0D      mov a, $0D00
0267+  11C7 05 03         syscall sys_io
0268+  11C9 E4            pop a
0269+  11CA 09            ret
0270+  11CB             
0271+  11CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  11CB             ; _strtoint
0273+  11CB             ; 4 digit hex string number in d
0274+  11CB             ; integer returned in A
0275+  11CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  11CB             _strtointx:
0277+  11CB D8            push b
0278+  11CC 32            mov bl, [d]
0279+  11CD 37            mov bh, bl
0280+  11CE 33 01 00      mov bl, [d + 1]
0281+  11D1 07 A2 10      call _atoi        ; convert to int in AL
0282+  11D4 23            mov ah, al        ; move to AH
0283+  11D5 33 02 00      mov bl, [d + 2]
0284+  11D8 37            mov bh, bl
0285+  11D9 33 03 00      mov bl, [d + 3]
0286+  11DC 07 A2 10      call _atoi        ; convert to int in AL
0287+  11DF E5            pop b
0288+  11E0 09            ret
0289+  11E1             
0290+  11E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  11E1             ; _strtoint
0292+  11E1             ; 5 digit base10 string number in d
0293+  11E1             ; integer returned in A
0294+  11E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  11E1             _strtoint:
0296+  11E1 E2            push si
0297+  11E2 D8            push b
0298+  11E3 D9            push c
0299+  11E4 DA            push d
0300+  11E5 07 44 10      call _strlen      ; get string length in C
0301+  11E8 7E            dec c
0302+  11E9 FD 4E         mov si, d
0303+  11EB 12            mov a, c
0304+  11EC FD 99         shl a
0305+  11EE 3B 65 13      mov d, table_power
0306+  11F1 59            add d, a
0307+  11F2 38 00 00      mov c, 0
0308+  11F5             _strtoint_L0:
0309+  11F5 F6            lodsb      ; load ASCII to al
0310+  11F6 B9 00         cmp al, 0
0311+  11F8 C6 0B 12      je _strtoint_end
0312+  11FB 6F 30         sub al, $30    ; make into integer
0313+  11FD 22 00         mov ah, 0
0314+  11FF 2A            mov b, [d]
0315+  1200 AC            mul a, b      ; result in B since it fits in 16bits
0316+  1201 11            mov a, b
0317+  1202 28            mov b, c
0318+  1203 54            add a, b
0319+  1204 39            mov c, a
0320+  1205 63 02 00      sub d, 2
0321+  1208 0A F5 11      jmp _strtoint_L0
0322+  120B             _strtoint_end:
0323+  120B 12            mov a, c
0324+  120C E7            pop d
0325+  120D E6            pop c
0326+  120E E5            pop b
0327+  120F EF            pop si
0328+  1210 09            ret
0329+  1211             
0330+  1211             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1211             ; PRINT NULL TERMINATED STRING
0332+  1211             ; pointer in D
0333+  1211             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1211             _puts:
0335+  1211 D7            push a
0336+  1212 DA            push d
0337+  1213             _puts_L1:
0338+  1213 1E            mov al, [d]
0339+  1214 B9 00         cmp al, 0
0340+  1216 C6 22 12      jz _puts_END
0341+  1219 23            mov ah, al
0342+  121A 19 00         mov al, 0
0343+  121C 05 03         syscall sys_io
0344+  121E 79            inc d
0345+  121F 0A 13 12      jmp _puts_L1
0346+  1222             _puts_END:
0347+  1222 E7            pop d
0348+  1223 E4            pop a
0349+  1224 09            ret
0350+  1225             
0351+  1225             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  1225             ; PRINT N SIZE STRING
0353+  1225             ; pointer in D
0354+  1225             ; size in C
0355+  1225             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  1225             _putsn:
0357+  1225 DB            push al
0358+  1226 DA            push d
0359+  1227 D9            push c
0360+  1228             _putsn_L0:
0361+  1228 1E            mov al, [d]
0362+  1229 23            mov ah, al
0363+  122A 19 00         mov al, 0
0364+  122C 05 03         syscall sys_io
0365+  122E 79            inc d
0366+  122F 7E            dec c  
0367+  1230 C2 00 00      cmp c, 0
0368+  1233 C7 28 12      jne _putsn_L0
0369+  1236             _putsn_end:
0370+  1236 E6            pop c
0371+  1237 E7            pop d
0372+  1238 E8            pop al
0373+  1239 09            ret
0374+  123A             
0375+  123A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  123A             ; print 16bit decimal number
0377+  123A             ; input number in A
0378+  123A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  123A             print_u16d:
0380+  123A D7            push a
0381+  123B D8            push b
0382+  123C FD D8         push g
0383+  123E 26 10 27      mov b, 10000
0384+  1241 AE            div a, b      ; get 10000's coeff.
0385+  1242 07 66 12      call print_number
0386+  1245 11            mov a, b
0387+  1246 26 E8 03      mov b, 1000
0388+  1249 AE            div a, b      ; get 1000's coeff.
0389+  124A 07 66 12      call print_number
0390+  124D 11            mov a, b
0391+  124E 26 64 00      mov b, 100
0392+  1251 AE            div a, b
0393+  1252 07 66 12      call print_number
0394+  1255 11            mov a, b
0395+  1256 26 0A 00      mov b, 10
0396+  1259 AE            div a, b
0397+  125A 07 66 12      call print_number
0398+  125D 1B            mov al, bl      ; 1's coeff in bl
0399+  125E 07 66 12      call print_number
0400+  1261 FD F1         pop g
0401+  1263 E5            pop b
0402+  1264 E4            pop a
0403+  1265 09            ret
0404+  1266             
0405+  1266             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1266             ; print AL
0407+  1266             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1266             print_number:
0409+  1266 6A 30         add al, $30
0410+  1268 23            mov ah, al
0411+  1269 07 E5 10      call _putchar
0412+  126C 09            ret
0413+  126D             
0414+  126D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  126D             ; PRINT 16BIT HEX INTEGER
0416+  126D             ; integer value in reg B
0417+  126D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  126D             print_u16x:
0419+  126D D7            push a
0420+  126E D8            push b
0421+  126F DD            push bl
0422+  1270 30            mov bl, bh
0423+  1271 07 B3 10      call _itoa        ; convert bh to char in A
0424+  1274 2F            mov bl, al        ; save al
0425+  1275 19 00         mov al, 0
0426+  1277 05 03         syscall sys_io        ; display AH
0427+  1279 24            mov ah, bl        ; retrieve al
0428+  127A 19 00         mov al, 0
0429+  127C 05 03         syscall sys_io        ; display AL
0430+  127E             
0431+  127E EA            pop bl
0432+  127F 07 B3 10      call _itoa        ; convert bh to char in A
0433+  1282 2F            mov bl, al        ; save al
0434+  1283 19 00         mov al, 0
0435+  1285 05 03         syscall sys_io        ; display AH
0436+  1287 24            mov ah, bl        ; retrieve al
0437+  1288 19 00         mov al, 0
0438+  128A 05 03         syscall sys_io        ; display AL
0439+  128C             
0440+  128C E5            pop b
0441+  128D E4            pop a
0442+  128E 09            ret
0443+  128F             
0444+  128F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  128F             ; INPUT 16BIT HEX INTEGER
0446+  128F             ; read 16bit integer into A
0447+  128F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  128F             scan_u16x:
0449+  128F F8 10 00      enter 16
0450+  1292 D8            push b
0451+  1293 DA            push d
0452+  1294             
0453+  1294 FA F1 FF      lea d, [bp + -15]
0454+  1297 07 EC 10      call _gets        ; get number
0455+  129A             
0456+  129A 32            mov bl, [d]
0457+  129B 37            mov bh, bl
0458+  129C 33 01 00      mov bl, [d + 1]
0459+  129F 07 A2 10      call _atoi        ; convert to int in AL
0460+  12A2 23            mov ah, al        ; move to AH
0461+  12A3             
0462+  12A3 33 02 00      mov bl, [d + 2]
0463+  12A6 37            mov bh, bl
0464+  12A7 33 03 00      mov bl, [d + 3]
0465+  12AA 07 A2 10      call _atoi        ; convert to int in AL
0466+  12AD             
0467+  12AD E7            pop d
0468+  12AE E5            pop b
0469+  12AF F9            leave
0470+  12B0 09            ret
0471+  12B1             
0472+  12B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  12B1             ; PRINT 8bit HEX INTEGER
0474+  12B1             ; integer value in reg bl
0475+  12B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  12B1             print_u8x:
0477+  12B1 D7            push a
0478+  12B2 DD            push bl
0479+  12B3             
0480+  12B3 07 B3 10      call _itoa        ; convert bl to char in A
0481+  12B6 2F            mov bl, al        ; save al
0482+  12B7 19 00         mov al, 0
0483+  12B9 05 03         syscall sys_io        ; display AH
0484+  12BB 24            mov ah, bl        ; retrieve al
0485+  12BC 19 00         mov al, 0
0486+  12BE 05 03         syscall sys_io        ; display AL
0487+  12C0             
0488+  12C0 EA            pop bl
0489+  12C1 E4            pop a
0490+  12C2 09            ret
0491+  12C3             
0492+  12C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  12C3             ; print 8bit decimal unsigned number
0494+  12C3             ; input number in AL
0495+  12C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  12C3             print_u8d:
0497+  12C3 D7            push a
0498+  12C4 D8            push b
0499+  12C5 FD D8         push g
0500+  12C7 22 00         mov ah, 0
0501+  12C9 26 64 00      mov b, 100
0502+  12CC AE            div a, b
0503+  12CD D8            push b      ; save remainder
0504+  12CE B9 00         cmp al, 0
0505+  12D0 C6 DA 12      je skip100
0506+  12D3 6A 30         add al, $30
0507+  12D5 23            mov ah, al
0508+  12D6 19 00         mov al, 0
0509+  12D8 05 03         syscall sys_io  ; print coeff
0510+  12DA             skip100:
0511+  12DA E4            pop a
0512+  12DB 22 00         mov ah, 0
0513+  12DD 26 0A 00      mov b, 10
0514+  12E0 AE            div a, b
0515+  12E1 D8            push b      ; save remainder
0516+  12E2 B9 00         cmp al, 0
0517+  12E4 C6 EE 12      je skip10
0518+  12E7 6A 30         add al, $30
0519+  12E9 23            mov ah, al
0520+  12EA 19 00         mov al, 0
0521+  12EC 05 03         syscall sys_io  ; print coeff
0522+  12EE             skip10:
0523+  12EE E4            pop a
0524+  12EF 1B            mov al, bl
0525+  12F0 6A 30         add al, $30
0526+  12F2 23            mov ah, al
0527+  12F3 19 00         mov al, 0
0528+  12F5 05 03         syscall sys_io  ; print coeff
0529+  12F7 FD F1         pop g
0530+  12F9 E5            pop b
0531+  12FA E4            pop a
0532+  12FB 09            ret
0533+  12FC             
0534+  12FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  12FC             ; INPUT 8BIT HEX INTEGER
0536+  12FC             ; read 8bit integer into AL
0537+  12FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  12FC             scan_u8x:
0539+  12FC F8 04 00      enter 4
0540+  12FF D8            push b
0541+  1300 DA            push d
0542+  1301             
0543+  1301 FA FD FF      lea d, [bp + -3]
0544+  1304 07 EC 10      call _gets        ; get number
0545+  1307             
0546+  1307 32            mov bl, [d]
0547+  1308 37            mov bh, bl
0548+  1309 33 01 00      mov bl, [d + 1]
0549+  130C 07 A2 10      call _atoi        ; convert to int in AL
0550+  130F             
0551+  130F E7            pop d
0552+  1310 E5            pop b
0553+  1311 F9            leave
0554+  1312 09            ret
0555+  1313             
0556+  1313             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1313             ; input decimal number
0558+  1313             ; result in A
0559+  1313             ; 655'\0'
0560+  1313             ; low--------high
0561+  1313             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1313             scan_u16d:
0563+  1313 F8 08 00      enter 8
0564+  1316 E2            push si
0565+  1317 D8            push b
0566+  1318 D9            push c
0567+  1319 DA            push d
0568+  131A FA F9 FF      lea d, [bp +- 7]
0569+  131D 07 EC 10      call _gets
0570+  1320 07 44 10      call _strlen      ; get string length in C
0571+  1323 7E            dec c
0572+  1324 FD 4E         mov si, d
0573+  1326 12            mov a, c
0574+  1327 FD 99         shl a
0575+  1329 3B 65 13      mov d, table_power
0576+  132C 59            add d, a
0577+  132D 38 00 00      mov c, 0
0578+  1330             mul_loop:
0579+  1330 F6            lodsb      ; load ASCII to al
0580+  1331 B9 00         cmp al, 0
0581+  1333 C6 46 13      je mul_exit
0582+  1336 6F 30         sub al, $30    ; make into integer
0583+  1338 22 00         mov ah, 0
0584+  133A 2A            mov b, [d]
0585+  133B AC            mul a, b      ; result in B since it fits in 16bits
0586+  133C 11            mov a, b
0587+  133D 28            mov b, c
0588+  133E 54            add a, b
0589+  133F 39            mov c, a
0590+  1340 63 02 00      sub d, 2
0591+  1343 0A 30 13      jmp mul_loop
0592+  1346             mul_exit:
0593+  1346 12            mov a, c
0594+  1347 E7            pop d
0595+  1348 E6            pop c
0596+  1349 E5            pop b
0597+  134A EF            pop si
0598+  134B F9            leave
0599+  134C 09            ret
0600+  134D             
0601+  134D             
0602+  134D 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  1351 34 35 36 37 
0602+  1355 38 39 41 42 
0602+  1359 43 44 45 46 
0603+  135D 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  1361 1B 5B 48 00 
0604+  1365             
0605+  1365             table_power:
0606+  1365 01 00         .dw 1
0607+  1367 0A 00         .dw 10
0608+  1369 64 00         .dw 100
0609+  136B E8 03         .dw 1000
0610+  136D 10 27         .dw 100002617   136F             .include "lib/ctype.asm"
0001+  136F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  136F             ; ctype.s
0003+  136F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  136F             
0005+  136F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  136F             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  136F             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  136F             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  136F             ;; characters are supported.
0010+  136F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  136F             ;; _isalnum 
0012+  136F             ;; _isalpha 
0013+  136F             ;; islower 
0014+  136F             ;; isupper 
0015+  136F             ;; _isdigit 
0016+  136F             ;; isxdigit
0017+  136F             ;; iscntrl 
0018+  136F             ;; isgraph 
0019+  136F             ;; _isspace 
0020+  136F             ;; isblank 
0021+  136F             ;; isprint 
0022+  136F             ;; ispunct 
0023+  136F             ;; tolower 
0024+  136F             ;; toupper
0025+  136F             
0026+  136F             
0027+  136F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  136F             ;; IS ALPHANUMERIC
0029+  136F             ;; sets ZF according with result
0030+  136F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  136F             _isalnum:
0032+  136F 07 8C 13    	call _isalpha
0033+  1372 C6 78 13    	je _isalnum_exit
0034+  1375 07 79 13    	call _isdigit
0035+  1378             _isalnum_exit:
0036+  1378 09          	ret	
0037+  1379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1379             ;; IS DIGIT
0039+  1379             ;; sets ZF according with result
0040+  1379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1379             _isdigit:
0042+  1379 DB          	push al
0043+  137A B9 30       	cmp al, '0'
0044+  137C C8 88 13    	jlu _isdigit_false
0045+  137F B9 39       	cmp al, '9'
0046+  1381 D1 88 13    	jgu _isdigit_false
0047+  1384 87 00       	and al, 0	; set ZF
0048+  1386 E8          	pop al
0049+  1387 09          	ret
0050+  1388             _isdigit_false:
0051+  1388 8B 01       	or al, 1	; clear ZF
0052+  138A E8          	pop al
0053+  138B 09          	ret	
0054+  138C             	
0055+  138C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  138C             ;; IS ALPHA
0057+  138C             ;; sets ZF according with result
0058+  138C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  138C             _isalpha:
0060+  138C DB          	push al
0061+  138D B9 5F       	cmp al, '_'
0062+  138F C6 AF 13    	je _isalpha_true
0063+  1392 B9 2E       	cmp al, '.'
0064+  1394 C6 AF 13    	je _isalpha_true
0065+  1397 B9 41       	cmp al, 'A'
0066+  1399 C8 AB 13    	jlu _isalpha_false
0067+  139C B9 7A       	cmp al, 'z'
0068+  139E D1 AB 13    	jgu _isalpha_false
0069+  13A1 B9 5A       	cmp al, 'Z'
0070+  13A3 D0 AF 13    	jleu _isalpha_true
0071+  13A6 B9 61       	cmp al, 'a'
0072+  13A8 C9 AF 13    	jgeu _isalpha_true
0073+  13AB             _isalpha_false:
0074+  13AB 8B 01       	or al, 1	; clear ZF
0075+  13AD E8          	pop al
0076+  13AE 09          	ret
0077+  13AF             _isalpha_true:
0078+  13AF 87 00       	and al, 0	; set ZF
0079+  13B1 E8          	pop al
0080+  13B2 09          	ret
0081+  13B3             
0082+  13B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  13B3             ;; IS PATH-ALPHA
0084+  13B3             ;; sets ZF according with result
0085+  13B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  13B3             ispath:
0087+  13B3 DB          	push al
0088+  13B4 07 79 13    	call _isdigit
0089+  13B7 C6 E1 13    	je ispath_true
0090+  13BA B9 5F       	cmp al, '_'
0091+  13BC C6 E1 13    	je ispath_true
0092+  13BF B9 2F       	cmp al, '/'
0093+  13C1 C6 E1 13    	je ispath_true
0094+  13C4 B9 2E       	cmp al, '.'
0095+  13C6 C6 E1 13    	je ispath_true
0096+  13C9 B9 41       	cmp al, 'A'
0097+  13CB C8 DD 13    	jlu ispath_false
0098+  13CE B9 7A       	cmp al, 'z'
0099+  13D0 D1 DD 13    	jgu ispath_false
0100+  13D3 B9 5A       	cmp al, 'Z'
0101+  13D5 D0 E1 13    	jleu ispath_true
0102+  13D8 B9 61       	cmp al, 'a'
0103+  13DA C9 E1 13    	jgeu ispath_true
0104+  13DD             ispath_false:
0105+  13DD 8B 01       	or al, 1	; clear ZF
0106+  13DF E8          	pop al
0107+  13E0 09          	ret
0108+  13E1             ispath_true:
0109+  13E1 87 00       	and al, 0	; set ZF
0110+  13E3 E8          	pop al
0111+  13E4 09          	ret
0112+  13E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  13E5             ;; IS SPACE
0114+  13E5             ;; sets ZF according with result
0115+  13E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  13E5             _isspace:
0117+  13E5 B9 20       	cmp al, $20		; ' '
0118+  13E7 C6 FB 13    	je _isspace_exit
0119+  13EA B9 09       	cmp al, $09		; '\t'
0120+  13EC C6 FB 13    	je _isspace_exit
0121+  13EF B9 0A       	cmp al, $0A		; '\n'
0122+  13F1 C6 FB 13    	je _isspace_exit
0123+  13F4 B9 0D       	cmp al, $0D		; '\r'
0124+  13F6 C6 FB 13    	je _isspace_exit
0125+  13F9 B9 0B       	cmp al, $0B		; '\v'
0126+  13FB             _isspace_exit:
0127+  13FB 09          	ret	
0128+  13FC             
0129+  13FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  13FC             ; TO LOWER
0131+  13FC             ; input in AL
0132+  13FC             ; output in AL
0133+  13FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  13FC             _to_lower:
0135+  13FC B9 5A       	cmp al, 'Z'
0136+  13FE D1 03 14    	jgu _to_lower_ret
0137+  1401 6A 20       	add al, $20				; convert to lower case
0138+  1403             _to_lower_ret:
0139+  1403 09          	ret
0140+  1404             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1404             ; TO UPPER
0142+  1404             ; input in AL
0143+  1404             ; output in AL
0144+  1404             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1404             _to_upper:
0146+  1404 B9 61       	cmp al, 'a'
0147+  1406 C8 0B 14    	jlu _to_upper_ret
0148+  1409 6F 20       	sub al, $20			; convert to upper case
0149+  140B             _to_upper_ret:
0150+  140B 09          	ret
0151+  140C             
2618   140C             .include "lib/token.asm"
0001+  140C             TOKTYP_IDENTIFIER  .equ 0
0002+  140C             TOKTYP_KEYWORD     .equ 1
0003+  140C             TOKTYP_DELIMITER   .equ 2
0004+  140C             TOKTYP_STRING      .equ 3
0005+  140C             TOKTYP_CHAR        .equ 4
0006+  140C             TOKTYP_NUMERIC     .equ 5
0007+  140C             TOKTYP_END         .equ 6
0008+  140C             
0009+  140C             TOK_NULL           .equ 0
0010+  140C             TOK_FSLASH         .equ 1
0011+  140C             TOK_TIMES          .equ 2
0012+  140C             TOK_PLUS           .equ 3
0013+  140C             TOK_MINUS          .equ 4
0014+  140C             TOK_DOT            .equ 5
0015+  140C             TOK_SEMI           .equ 6
0016+  140C             TOK_ANGLE          .equ 7
0017+  140C             TOK_TILDE          .equ 8
0018+  140C             TOK_EQUAL          .equ 9
0019+  140C             TOK_COLON          .equ 10
0020+  140C             TOK_COMMA          .equ 11
0021+  140C             
0022+  140C             TOK_END            .equ 20
0023+  140C             
0024+  140C             
0025+  140C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  140C             ;; read a full command argment from shell input buffer
0027+  140C             ;; argument is written into tokstr
0028+  140C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  140C             get_arg:
0030+  140C D7            push a
0031+  140D E2            push si
0032+  140E E3            push di
0033+  140F 19 00         mov al, 0
0034+  1411 3D 3A 16      mov [tokstr], al      ; nullify tokstr string
0035+  1414 14 36 16      mov a, [prog]
0036+  1417 4D            mov si, a
0037+  1418 FD 4F 3A 16   mov di, tokstr
0038+  141C             get_arg_skip_spaces:
0039+  141C F6            lodsb
0040+  141D 07 E5 13      call _isspace
0041+  1420 C6 1C 14      je get_arg_skip_spaces
0042+  1423             get_arg_L0:
0043+  1423 B9 3B         cmp al, $3B        ; check if is ';'
0044+  1425 C6 32 14      je get_arg_end
0045+  1428 B9 00         cmp al, 0
0046+  142A C6 32 14      je get_arg_end      ; check if end of input
0047+  142D F7            stosb
0048+  142E F6            lodsb
0049+  142F 0A 23 14      jmp get_arg_L0
0050+  1432             get_arg_end:
0051+  1432 19 00         mov al, 0
0052+  1434 F7            stosb
0053+  1435 D5 01 00      sub si, 1
0054+  1438 4E            mov a, si
0055+  1439 42 36 16      mov [prog], a    ; update pointer
0056+  143C F0            pop di
0057+  143D EF            pop si
0058+  143E E4            pop a
0059+  143F 09            ret
0060+  1440             
0061+  1440             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  1440             ;; read a path formation from shell input buffer
0063+  1440             ;; path is written into tokstr
0064+  1440             ;; /usr/bin
0065+  1440             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  1440             get_path:
0067+  1440 D7            push a
0068+  1441 E2            push si
0069+  1442 E3            push di
0070+  1443 19 00         mov al, 0
0071+  1445 3D 3A 16      mov [tokstr], al      ; nullify tokstr string
0072+  1448 14 36 16      mov a, [prog]
0073+  144B 4D            mov si, a
0074+  144C FD 4F 3A 16   mov di, tokstr
0075+  1450             get_path_skip_spaces:
0076+  1450 F6            lodsb
0077+  1451 07 E5 13      call _isspace
0078+  1454 C6 50 14      je get_path_skip_spaces
0079+  1457             get_path_is_pathchar:
0080+  1457 F7            stosb
0081+  1458 F6            lodsb
0082+  1459 07 6F 13      call _isalnum      ;check if is alphanumeric
0083+  145C C6 57 14      je get_path_is_pathchar
0084+  145F B9 2F         cmp al, '/'        ; check if is '/'
0085+  1461 C6 57 14      je get_path_is_pathchar
0086+  1464 19 00         mov al, 0
0087+  1466 F7            stosb
0088+  1467 D5 01 00      sub si, 1
0089+  146A 4E            mov a, si
0090+  146B 42 36 16      mov [prog], a    ; update pointer
0091+  146E             get_path_end:
0092+  146E F0            pop di
0093+  146F EF            pop si
0094+  1470 E4            pop a
0095+  1471 09            ret
0096+  1472             
0097+  1472             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  1472             ;; read a line
0099+  1472             ;; line is written into tokstr
0100+  1472             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  1472             get_line:
0102+  1472 D7            push a
0103+  1473 E2            push si
0104+  1474 E3            push di
0105+  1475 19 00         mov al, 0
0106+  1477 3D 3A 16      mov [tokstr], al      ; nullify tokstr string
0107+  147A 14 36 16      mov a, [prog]
0108+  147D 4D            mov si, a
0109+  147E FD 4F 3A 16   mov di, tokstr
0110+  1482             get_line_L0:
0111+  1482 F6            lodsb
0112+  1483 B9 0A         cmp al, $0A    ; check for new line
0113+  1485 C6 8C 14      je get_line_exit
0114+  1488 F7            stosb
0115+  1489 0A 82 14      jmp get_line_L0
0116+  148C             get_line_exit:
0117+  148C 19 00         mov al, 0
0118+  148E F7            stosb
0119+  148F 4E            mov a, si
0120+  1490 42 36 16      mov [prog], a    ; update pointer
0121+  1493 F0            pop di
0122+  1494 EF            pop si
0123+  1495 E4            pop a
0124+  1496 09            ret
0125+  1497             
0126+  1497             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1497             ;; token parser
0128+  1497             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1497             get_token:
0130+  1497 D7            push a
0131+  1498 DA            push d
0132+  1499 E2            push si
0133+  149A E3            push di
0134+  149B 19 00         mov al, 0
0135+  149D 3D 3A 16      mov [tokstr], al      ; nullify tokstr string
0136+  14A0 19 00         mov al, TOK_NULL
0137+  14A2 3D 39 16      mov [tok], al        ; nullify token
0138+  14A5 14 36 16      mov a, [prog]
0139+  14A8 4D            mov si, a
0140+  14A9 FD 4F 3A 16   mov di, tokstr
0141+  14AD             get_tok_skip_spaces:
0142+  14AD F6            lodsb
0143+  14AE 07 E5 13      call _isspace
0144+  14B1 C6 AD 14      je get_tok_skip_spaces
0145+  14B4 B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  14B6 C6 9B 15      je get_token_end
0147+  14B9 B9 23         cmp al, '#'      ; comments!
0148+  14BB C6 C9 15      je get_tok_comment
0149+  14BE 07 6F 13      call _isalnum
0150+  14C1 C6 A8 15      jz is_alphanumeric
0151+  14C4             ; other token types
0152+  14C4             get_token_slash:
0153+  14C4 B9 2F         cmp al, '/'        ; check if '/'
0154+  14C6 C7 DE 14      jne get_token_minus
0155+  14C9 F7            stosb          ; store '/' into token string
0156+  14CA 19 00         mov al, 0
0157+  14CC F7            stosb          ; terminate token string
0158+  14CD 19 01         mov al, TOK_FSLASH
0159+  14CF 3D 39 16      mov [tok], al      
0160+  14D2 19 02         mov al, TOKTYP_DELIMITER
0161+  14D4 3D 38 16      mov [toktyp], al
0162+  14D7 4E            mov a, si
0163+  14D8 42 36 16      mov [prog], a    ; update pointer
0164+  14DB 0A C4 15      jmp get_token_return
0165+  14DE             get_token_minus:
0166+  14DE B9 2D         cmp al, '-'        ; check if '-'
0167+  14E0 C7 F8 14      jne get_token_comma
0168+  14E3 F7            stosb          ; store '-' into token string
0169+  14E4 19 00         mov al, 0
0170+  14E6 F7            stosb          ; terminate token string
0171+  14E7 19 04         mov al, TOK_MINUS
0172+  14E9 3D 39 16      mov [tok], al      
0173+  14EC 19 02         mov al, TOKTYP_DELIMITER
0174+  14EE 3D 38 16      mov [toktyp], al
0175+  14F1 4E            mov a, si
0176+  14F2 42 36 16      mov [prog], a    ; update pointer
0177+  14F5 0A C4 15      jmp get_token_return
0178+  14F8             get_token_comma:
0179+  14F8 B9 2C         cmp al, ','        ; check if ','
0180+  14FA C7 12 15      jne get_token_semi
0181+  14FD F7            stosb          ; store ',' into token string
0182+  14FE 19 00         mov al, 0
0183+  1500 F7            stosb          ; terminate token string
0184+  1501 19 0B         mov al, TOK_COMMA
0185+  1503 3D 39 16      mov [tok], al      
0186+  1506 19 02         mov al, TOKTYP_DELIMITER
0187+  1508 3D 38 16      mov [toktyp], al
0188+  150B 4E            mov a, si
0189+  150C 42 36 16      mov [prog], a    ; update pointer
0190+  150F 0A C4 15      jmp get_token_return
0191+  1512             get_token_semi:
0192+  1512 B9 3B         cmp al, $3B        ; check if ';'
0193+  1514 C7 2C 15      jne get_token_colon
0194+  1517 F7            stosb          ; store ';' into token string
0195+  1518 19 00         mov al, 0
0196+  151A F7            stosb          ; terminate token string
0197+  151B 19 06         mov al, TOK_SEMI
0198+  151D 3D 39 16      mov [tok], al      
0199+  1520 19 02         mov al, TOKTYP_DELIMITER
0200+  1522 3D 38 16      mov [toktyp], al
0201+  1525 4E            mov a, si
0202+  1526 42 36 16      mov [prog], a    ; update pointer
0203+  1529 0A C4 15      jmp get_token_return
0204+  152C             get_token_colon:
0205+  152C B9 3A         cmp al, $3A        ; check if ':'
0206+  152E C7 46 15      jne get_token_angle
0207+  1531 F7            stosb          ; store ':' into token string
0208+  1532 19 00         mov al, 0
0209+  1534 F7            stosb          ; terminate token string
0210+  1535 19 0A         mov al, TOK_COLON
0211+  1537 3D 39 16      mov [tok], al      
0212+  153A 19 02         mov al, TOKTYP_DELIMITER
0213+  153C 3D 38 16      mov [toktyp], al
0214+  153F 4E            mov a, si
0215+  1540 42 36 16      mov [prog], a    ; update pointer
0216+  1543 0A C4 15      jmp get_token_return
0217+  1546             get_token_angle:
0218+  1546 B9 3E         cmp al, $3E        ; check if '>'
0219+  1548 C7 60 15      jne get_token_tilde
0220+  154B F7            stosb          ; store '>' into token string
0221+  154C 19 00         mov al, 0
0222+  154E F7            stosb          ; terminate token string
0223+  154F 19 07         mov al, TOK_ANGLE
0224+  1551 3D 39 16      mov [tok], al      
0225+  1554 19 02         mov al, TOKTYP_DELIMITER
0226+  1556 3D 38 16      mov [toktyp], al
0227+  1559 4E            mov a, si
0228+  155A 42 36 16      mov [prog], a    ; update pointer
0229+  155D 0A C4 15      jmp get_token_return
0230+  1560             get_token_tilde:
0231+  1560 B9 7E         cmp al, '~'        ; check if '~'
0232+  1562 C7 7A 15      jne get_token_equal
0233+  1565 F7            stosb          ; store '~' into token string
0234+  1566 19 00         mov al, 0
0235+  1568 F7            stosb          ; terminate token string
0236+  1569 19 08         mov al, TOK_TILDE
0237+  156B 3D 39 16      mov [tok], al      
0238+  156E 19 02         mov al, TOKTYP_DELIMITER
0239+  1570 3D 38 16      mov [toktyp], al
0240+  1573 4E            mov a, si
0241+  1574 42 36 16      mov [prog], a    ; update pointer
0242+  1577 0A C4 15      jmp get_token_return
0243+  157A             get_token_equal:
0244+  157A B9 3D         cmp al, '='        ; check if '='
0245+  157C C7 94 15      jne get_token_skip
0246+  157F F7            stosb          ; store '=' into token string
0247+  1580 19 00         mov al, 0
0248+  1582 F7            stosb          ; terminate token string
0249+  1583 19 09         mov al, TOK_EQUAL
0250+  1585 3D 39 16      mov [tok], al      
0251+  1588 19 02         mov al, TOKTYP_DELIMITER
0252+  158A 3D 38 16      mov [toktyp], al
0253+  158D 4E            mov a, si
0254+  158E 42 36 16      mov [prog], a    ; update pointer
0255+  1591 0A C4 15      jmp get_token_return
0256+  1594             get_token_skip:
0257+  1594 4E            mov a, si
0258+  1595 42 36 16      mov [prog], a    ; update pointer
0259+  1598 0A C4 15      jmp get_token_return
0260+  159B             get_token_end:        ; end of file token
0261+  159B 19 14         mov al, TOK_END
0262+  159D 3D 39 16      mov [tok], al
0263+  15A0 19 06         mov al, TOKTYP_END
0264+  15A2 3D 38 16      mov [toktyp], al
0265+  15A5 0A C4 15      jmp get_token_return
0266+  15A8             is_alphanumeric:
0267+  15A8 F7            stosb
0268+  15A9 F6            lodsb
0269+  15AA 07 6F 13      call _isalnum      ;check if is alphanumeric
0270+  15AD C6 A8 15      jz is_alphanumeric
0271+  15B0 B9 2E         cmp al, $2E        ; check if is '.'
0272+  15B2 C6 A8 15      je is_alphanumeric
0273+  15B5 19 00         mov al, 0
0274+  15B7 F7            stosb
0275+  15B8 19 00         mov al, TOKTYP_IDENTIFIER
0276+  15BA 3D 38 16      mov [toktyp], al
0277+  15BD D5 01 00      sub si, 1
0278+  15C0 4E            mov a, si
0279+  15C1 42 36 16      mov [prog], a    ; update pointer
0280+  15C4             get_token_return:
0281+  15C4 F0            pop di
0282+  15C5 EF            pop si
0283+  15C6 E7            pop d
0284+  15C7 E4            pop a
0285+  15C8 09            ret
0286+  15C9             get_tok_comment:
0287+  15C9 F6            lodsb
0288+  15CA B9 0A         cmp al, $0A      ; new line
0289+  15CC C7 C9 15      jne get_tok_comment
0290+  15CF 0A AD 14      jmp get_tok_skip_spaces
0291+  15D2             
0292+  15D2             
0293+  15D2             get_number:
0294+  15D2 D7            push a
0295+  15D3 DA            push d
0296+  15D4 E2            push si
0297+  15D5 E3            push di
0298+  15D6 19 00         mov al, 0
0299+  15D8 3D 3A 16      mov [tokstr], al      ; nullify tokstr string
0300+  15DB 19 00         mov al, TOK_NULL
0301+  15DD 3D 39 16      mov [tok], al        ; nullify token
0302+  15E0 14 36 16      mov a, [prog]
0303+  15E3 4D            mov si, a
0304+  15E4 FD 4F 3A 16   mov di, tokstr
0305+  15E8             get_number_skip_spaces:
0306+  15E8 F6            lodsb
0307+  15E9 07 E5 13      call _isspace
0308+  15EC C6 E8 15      je get_number_skip_spaces
0309+  15EF B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  15F1 C7 01 16      jne get_number_L0
0311+  15F4 19 14         mov al, TOK_END
0312+  15F6 3D 39 16      mov [tok], al
0313+  15F9 19 06         mov al, TOKTYP_END
0314+  15FB 3D 38 16      mov [toktyp], al
0315+  15FE 0A 18 16      jmp get_number_return
0316+  1601             get_number_L0:
0317+  1601 F7            stosb
0318+  1602 F6            lodsb
0319+  1603 07 79 13      call _isdigit      ;check if is numeric
0320+  1606 C6 01 16      jz get_number_L0
0321+  1609 19 00         mov al, 0
0322+  160B F7            stosb
0323+  160C 19 05         mov al, TOKTYP_NUMERIC
0324+  160E 3D 38 16      mov [toktyp], al
0325+  1611 D5 01 00      sub si, 1
0326+  1614 4E            mov a, si
0327+  1615 42 36 16      mov [prog], a    ; update pointer
0328+  1618             get_number_return:
0329+  1618 F0            pop di
0330+  1619 EF            pop si
0331+  161A E7            pop d
0332+  161B E4            pop a
0333+  161C 09            ret
0334+  161D             
0335+  161D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  161D             ;; PUT BACK TOKEN
0337+  161D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  161D             _putback:
0339+  161D D7            push a
0340+  161E E2            push si
0341+  161F FD 4D 3A 16   mov si, tokstr  
0342+  1623             _putback_loop:
0343+  1623 F6            lodsb
0344+  1624 B9 00         cmp al, 0
0345+  1626 C6 33 16      je _putback_end
0346+  1629 14 36 16      mov a, [prog]
0347+  162C 7D            dec a
0348+  162D 42 36 16      mov [prog], a      ; update pointer
0349+  1630 0A 23 16      jmp _putback_loop
0350+  1633             _putback_end:
0351+  1633 EF            pop si
0352+  1634 E4            pop a
0353+  1635 09            ret
0354+  1636             
0355+  1636             
0356+  1636             
0357+  1636             
0358+  1636 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1638             
0360+  1638 00          toktyp:    .db 0          ; token type symbol
0361+  1639 00          tok:       .db 0          ; current token symbol
0362+  163A 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  163E 00 00 00 00 
0362+  1642 00 00 00 00 
0362+  1646 00 00 00 00 
0362+  164A 00 00 00 00 
0362+  164E 00 00 00 00 
0362+  1652 00 00 00 00 
0362+  1656 00 00 00 00 
0362+  165A 00 00 00 00 
0362+  165E 00 00 00 00 
0362+  1662 00 00 00 00 
0362+  1666 00 00 00 00 
0362+  166A 00 00 00 00 
0362+  166E 00 00 00 00 
0362+  1672 00 00 00 00 
0362+  1676 00 00 00 00 
0362+  167A 00 00 00 00 
0362+  167E 00 00 00 00 
0362+  1682 00 00 00 00 
0362+  1686 00 00 00 00 
0362+  168A 00 00 00 00 
0362+  168E 00 00 00 00 
0362+  1692 00 00 00 00 
0362+  1696 00 00 00 00 
0362+  169A 00 00 00 00 
0362+  169E 00 00 00 00 
0362+  16A2 00 00 00 00 
0362+  16A6 00 00 00 00 
0362+  16AA 00 00 00 00 
0362+  16AE 00 00 00 00 
0362+  16B2 00 00 00 00 
0362+  16B6 00 00 00 00 
0362+  16BA 00 00 00 00 
0362+  16BE 00 00 00 00 
0362+  16C2 00 00 00 00 
0362+  16C6 00 00 00 00 
0362+  16CA 00 00 00 00 
0362+  16CE 00 00 00 00 
0362+  16D2 00 00 00 00 
0362+  16D6 00 00 00 00 
0362+  16DA 00 00 00 00 
0362+  16DE 00 00 00 00 
0362+  16E2 00 00 00 00 
0362+  16E6 00 00 00 00 
0362+  16EA 00 00 00 00 
0362+  16EE 00 00 00 00 
0362+  16F2 00 00 00 00 
0362+  16F6 00 00 00 00 
0362+  16FA 00 00 00 00 
0362+  16FE 00 00 00 00 
0362+  1702 00 00 00 00 
0362+  1706 00 00 00 00 
0362+  170A 00 00 00 00 
0362+  170E 00 00 00 00 
0362+  1712 00 00 00 00 
0362+  1716 00 00 00 00 
0362+  171A 00 00 00 00 
0362+  171E 00 00 00 00 
0362+  1722 00 00 00 00 
0362+  1726 00 00 00 00 
0362+  172A 00 00 00 00 
0362+  172E 00 00 00 00 
0362+  1732 00 00 00 00 
0362+  1736 00 00 00 00 
2619   173A             
2620   173A             ; kernel parameters
2621   173A 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2622   173B 01          sys_echo_on:        .db 1
2623   173C 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2624   173D 01          sys_uart0_inten:    .db 1
2625   173E 00          sys_uart0_fifoen:   .db 0
2626   173F 0C          sys_uart0_div0:     .db 12  ;
2627   1740 00          sys_uart0_div1:     .db 0   ; default baud = 9600
2628   1741             ; Baud  Divisor
2629   1741             ; 50    2304
2630   1741             ; 110   1047
2631   1741             ; 300    384
2632   1741             ; 600    192
2633   1741             ; 1200    96
2634   1741             ; 9600    12
2635   1741             ; 19200    6
2636   1741             ; 38400    3
2637   1741             
2638   1741 00          nbr_active_procs:   .db 0
2639   1742 01          active_proc_index:  .db 1
2640   1743             
2641   1743 00 00       index:              .dw 0
2642   1745 00 00       buffer_addr:        .dw 0
2643   1747             
2644   1747 88 20       fifo_in:            .dw fifo
2645   1749 88 20       fifo_out:           .dw fifo
2646   174B             
2647   174B             ; file system variables
2648   174B 00 00       current_dir_id:     .dw 0     ; keep dirID of current directory
2649   174D 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2649   1751 6E 2F 69 6E 
2649   1755 69 74 00 
2650   1758             
2651   1758 3E 20 00    s_dataentry:        .db "> ", 0
2652   175B 2E 2E 00    s_parent_dir:       .db "..", 0
2653   175E 2E 00       s_current_dir:      .db ".", 0
2654   1760 2F 00       s_fslash:           .db "/", 0
2655   1762 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2655   1766 78 
2656   1767 2D 64 63    file_type:          .db "-dc"
2657   176A 50 49 44 20 s_ps_header:        .db "PID COMMAND\n", 0
2657   176E 43 4F 4D 4D 
2657   1772 41 4E 44 0A 
2657   1776 00 
2658   1777 54 6F 74 61 s_ls_total:         .db "Total: ", 0
2658   177B 6C 3A 20 00 
2659   177F             
2660   177F 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2660   1783 20 65 6E 61 
2660   1787 62 6C 65 64 
2660   178B 0A 00 
2661   178D 6B 65 72 6E s_kernel_started:   .db "kernel started(version 1.0)\n", 0
2661   1791 65 6C 20 73 
2661   1795 74 61 72 74 
2661   1799 65 64 28 76 
2661   179D 65 72 73 69 
2661   17A1 6F 6E 20 31 
2661   17A5 2E 30 29 0A 
2661   17A9 00 
2662   17AA 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2662   17AE 74 69 6E 67 
2662   17B2 20 69 6E 69 
2662   17B6 74 0A 00 
2663   17B9 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2663   17BD 65 70 74 69 
2663   17C1 6F 6E 3A 20 
2663   17C5 70 72 69 76 
2663   17C9 69 6C 65 67 
2663   17CD 65 0A 00 
2664   17D0 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2664   17D4 65 70 74 69 
2664   17D8 6F 6E 3A 20 
2664   17DC 7A 65 72 6F 
2664   17E0 20 64 69 76 
2664   17E4 69 73 69 6F 
2664   17E8 6E 0A 00 
2665   17EB             
2666   17EB 59 65 61 72 s_set_year:         .db "Year: ", 0
2666   17EF 3A 20 00 
2667   17F2 4D 6F 6E 74 s_set_month:        .db "Month: ", 0
2667   17F6 68 3A 20 00 
2668   17FA 44 61 79 3A s_set_day:          .db "Day: ", 0
2668   17FE 20 00 
2669   1800 57 65 65 6B s_set_week:         .db "Weekday: ", 0
2669   1804 64 61 79 3A 
2669   1808 20 00 
2670   180A 48 6F 75 72 s_set_hours:        .db "Hours: ", 0
2670   180E 73 3A 20 00 
2671   1812 4D 69 6E 75 s_set_minutes:      .db "Minutes: ", 0
2671   1816 74 65 73 3A 
2671   181A 20 00 
2672   181C 53 65 63 6F s_set_seconds:      .db "Seconds: ", 0
2672   1820 6E 64 73 3A 
2672   1824 20 00 
2673   1826             s_months:      
2674   1826 20 20 20 00   .db "   ", 0
2675   182A 4A 61 6E 00   .db "Jan", 0
2676   182E 46 65 62 00   .db "Feb", 0
2677   1832 4D 61 72 00   .db "Mar", 0
2678   1836 41 70 72 00   .db "Apr", 0
2679   183A 4D 61 79 00   .db "May", 0
2680   183E 4A 75 6E 00   .db "Jun", 0
2681   1842 4A 75 6C 00   .db "Jul", 0
2682   1846 41 75 67 00   .db "Aug", 0
2683   184A 53 65 70 00   .db "Sep", 0
2684   184E 4F 63 74 00   .db "Oct", 0
2685   1852 4E 6F 76 00   .db "Nov", 0
2686   1856 44 65 63 00   .db "Dec", 0
2687   185A             
2688   185A             s_week:        
2689   185A 53 75 6E 00   .db "Sun", 0 
2690   185E 4D 6F 6E 00   .db "Mon", 0 
2691   1862 54 75 65 00   .db "Tue", 0 
2692   1866 57 65 64 00   .db "Wed", 0 
2693   186A 54 68 75 00   .db "Thu", 0 
2694   186E 46 72 69 00   .db "Fri", 0 
2695   1872 53 61 74 00   .db "Sat", 0
2696   1876             
2697   1876             ; This is the format of a sector for the 128 byte per sector format.
2698   1876             ; Write the bracketed data 16 times per track.
2699   1876             ; The recommended single-density format with 128
2700   1876             ; bytes/sector is shown. In order to format a diskette,
2701   1876             ; the user issues the Write Track Command, and loads
2702   1876             ; the Data Register with the following values. For every
2703   1876             ; byte to be written, there is one Data Request.
2704   1876             fdc_128_bytes_per_sect:                                                                       
2705   1876 FF FF FF FF fdc_40_FF:     .fill 40,  $FF  ; or 00                                                                                
2705   187A FF FF FF FF 
2705   187E FF FF FF FF 
2705   1882 FF FF FF FF 
2705   1886 FF FF FF FF 
2705   188A FF FF FF FF 
2705   188E FF FF FF FF 
2705   1892 FF FF FF FF 
2705   1896 FF FF FF FF 
2705   189A FF FF FF FF 
2706   189E 00 00 00 00 fdc_6_00_0:    .fill 6,   $00  ;                                                                            <--|        
2706   18A2 00 00 
2707   18A4 FE          fdc_id_fe:     .fill 1,   $FE  ; ID Address Mark                                                               |        
2708   18A5 00          fdc_track:     .fill 1,   $00  ; Track Number                                                                  |                    
2709   18A6 00          fdc_side:      .fill 1,   $00  ; Side Number 00 or 01                                                          |                
2710   18A7 01          fdc_sector:    .fill 1,   $01  ; Sector Number  1 through 10                                                   |                              
2711   18A8 00          fdc_length:    .fill 1,   $00  ; Sector Length                                                                 |                        
2712   18A9 F7          fdc_2_crc_0:   .fill 1,   $F7  ; 2 CRC's Written                                                               | Write 16 times                 
2713   18AA FF FF FF FF fdc_11_ff:     .fill 11,  $FF  ; or 00                                                                         |                      
2713   18AE FF FF FF FF 
2713   18B2 FF FF FF 
2714   18B5 00 00 00 00 fdc_6_00_1:    .fill 6,   $00  ;                                                                               |                        
2714   18B9 00 00 
2715   18BB FB          fdc_data_addr: .fill 1,   $FB  ; Data Address Mark                                                             |                                  
2716   18BC E5 E5 E5 E5 fdc_data:      .fill 128, $E5  ; Data (IBM uses E5)                                                            |                                      
2716   18C0 E5 E5 E5 E5 
2716   18C4 E5 E5 E5 E5 
2716   18C8 E5 E5 E5 E5 
2716   18CC E5 E5 E5 E5 
2716   18D0 E5 E5 E5 E5 
2716   18D4 E5 E5 E5 E5 
2716   18D8 E5 E5 E5 E5 
2716   18DC E5 E5 E5 E5 
2716   18E0 E5 E5 E5 E5 
2716   18E4 E5 E5 E5 E5 
2716   18E8 E5 E5 E5 E5 
2716   18EC E5 E5 E5 E5 
2716   18F0 E5 E5 E5 E5 
2716   18F4 E5 E5 E5 E5 
2716   18F8 E5 E5 E5 E5 
2716   18FC E5 E5 E5 E5 
2716   1900 E5 E5 E5 E5 
2716   1904 E5 E5 E5 E5 
2716   1908 E5 E5 E5 E5 
2716   190C E5 E5 E5 E5 
2716   1910 E5 E5 E5 E5 
2716   1914 E5 E5 E5 E5 
2716   1918 E5 E5 E5 E5 
2716   191C E5 E5 E5 E5 
2716   1920 E5 E5 E5 E5 
2716   1924 E5 E5 E5 E5 
2716   1928 E5 E5 E5 E5 
2716   192C E5 E5 E5 E5 
2716   1930 E5 E5 E5 E5 
2716   1934 E5 E5 E5 E5 
2716   1938 E5 E5 E5 E5 
2717   193C F7          fdc_2_crc_1:   .fill 1,   $F7  ; 2 CRC's Written                                                               |                                                        
2718   193D FF FF FF FF fdc_10_ff:     .fill 10,  $FF  ; or 00                                                                      <--|                                                  
2718   1941 FF FF FF FF 
2718   1945 FF FF 
2719   1947 FF FF FF FF fdc_369_ff:    .fill 369, $FF  ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
2719   194B FF FF FF FF 
2719   194F FF FF FF FF 
2719   1953 FF FF FF FF 
2719   1957 FF FF FF FF 
2719   195B FF FF FF FF 
2719   195F FF FF FF FF 
2719   1963 FF FF FF FF 
2719   1967 FF FF FF FF 
2719   196B FF FF FF FF 
2719   196F FF FF FF FF 
2719   1973 FF FF FF FF 
2719   1977 FF FF FF FF 
2719   197B FF FF FF FF 
2719   197F FF FF FF FF 
2719   1983 FF FF FF FF 
2719   1987 FF FF FF FF 
2719   198B FF FF FF FF 
2719   198F FF FF FF FF 
2719   1993 FF FF FF FF 
2719   1997 FF FF FF FF 
2719   199B FF FF FF FF 
2719   199F FF FF FF FF 
2719   19A3 FF FF FF FF 
2719   19A7 FF FF FF FF 
2719   19AB FF FF FF FF 
2719   19AF FF FF FF FF 
2719   19B3 FF FF FF FF 
2719   19B7 FF FF FF FF 
2719   19BB FF FF FF FF 
2719   19BF FF FF FF FF 
2719   19C3 FF FF FF FF 
2719   19C7 FF FF FF FF 
2719   19CB FF FF FF FF 
2719   19CF FF FF FF FF 
2719   19D3 FF FF FF FF 
2719   19D7 FF FF FF FF 
2719   19DB FF FF FF FF 
2719   19DF FF FF FF FF 
2719   19E3 FF FF FF FF 
2719   19E7 FF FF FF FF 
2719   19EB FF FF FF FF 
2719   19EF FF FF FF FF 
2719   19F3 FF FF FF FF 
2719   19F7 FF FF FF FF 
2719   19FB FF FF FF FF 
2719   19FF FF FF FF FF 
2719   1A03 FF FF FF FF 
2719   1A07 FF FF FF FF 
2719   1A0B FF FF FF FF 
2719   1A0F FF FF FF FF 
2719   1A13 FF FF FF FF 
2719   1A17 FF FF FF FF 
2719   1A1B FF FF FF FF 
2719   1A1F FF FF FF FF 
2719   1A23 FF FF FF FF 
2719   1A27 FF FF FF FF 
2719   1A2B FF FF FF FF 
2719   1A2F FF FF FF FF 
2719   1A33 FF FF FF FF 
2719   1A37 FF FF FF FF 
2719   1A3B FF FF FF FF 
2719   1A3F FF FF FF FF 
2719   1A43 FF FF FF FF 
2719   1A47 FF FF FF FF 
2719   1A4B FF FF FF FF 
2719   1A4F FF FF FF FF 
2719   1A53 FF FF FF FF 
2719   1A57 FF FF FF FF 
2719   1A5B FF FF FF FF 
2719   1A5F FF FF FF FF 
2719   1A63 FF FF FF FF 
2719   1A67 FF FF FF FF 
2719   1A6B FF FF FF FF 
2719   1A6F FF FF FF FF 
2719   1A73 FF FF FF FF 
2719   1A77 FF FF FF FF 
2719   1A7B FF FF FF FF 
2719   1A7F FF FF FF FF 
2719   1A83 FF FF FF FF 
2719   1A87 FF FF FF FF 
2719   1A8B FF FF FF FF 
2719   1A8F FF FF FF FF 
2719   1A93 FF FF FF FF 
2719   1A97 FF FF FF FF 
2719   1A9B FF FF FF FF 
2719   1A9F FF FF FF FF 
2719   1AA3 FF FF FF FF 
2719   1AA7 FF FF FF FF 
2719   1AAB FF FF FF FF 
2719   1AAF FF FF FF FF 
2719   1AB3 FF FF FF FF 
2719   1AB7 FF 
2720   1AB8             
2721   1AB8 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2721   1ABC 00 00 00 00 
2721   1AC0 00 00 00 00 
2721   1AC4 00 00 00 00 
2721   1AC8 00 00 00 00 
2721   1ACC 00 00 00 00 
2721   1AD0 00 00 00 00 
2721   1AD4 00 00 00 00 
2721   1AD8 00 00 00 00 
2721   1ADC 00 00 00 00 
2721   1AE0 00 00 00 00 
2721   1AE4 00 00 00 00 
2721   1AE8 00 00 00 00 
2721   1AEC 00 00 00 00 
2721   1AF0 00 00 00 00 
2721   1AF4 00 00 00 00 
2721   1AF8 00 00 00 00 
2721   1AFC 00 00 00 00 
2721   1B00 00 00 00 00 
2721   1B04 00 00 00 00 
2721   1B08 00 00 00 00 
2721   1B0C 00 00 00 00 
2721   1B10 00 00 00 00 
2721   1B14 00 00 00 00 
2721   1B18 00 00 00 00 
2721   1B1C 00 00 00 00 
2721   1B20 00 00 00 00 
2721   1B24 00 00 00 00 
2721   1B28 00 00 00 00 
2721   1B2C 00 00 00 00 
2721   1B30 00 00 00 00 
2721   1B34 00 00 00 00 
2721   1B38 00 00 00 00 
2721   1B3C 00 00 00 00 
2721   1B40 00 00 00 00 
2721   1B44 00 00 00 00 
2721   1B48 00 00 00 00 
2721   1B4C 00 00 00 00 
2721   1B50 00 00 00 00 
2721   1B54 00 00 00 00 
2721   1B58 00 00 00 00 
2721   1B5C 00 00 00 00 
2721   1B60 00 00 00 00 
2721   1B64 00 00 00 00 
2721   1B68 00 00 00 00 
2721   1B6C 00 00 00 00 
2721   1B70 00 00 00 00 
2721   1B74 00 00 00 00 
2721   1B78 00 00 00 00 
2721   1B7C 00 00 00 00 
2721   1B80 00 00 00 00 
2721   1B84 00 00 00 00 
2721   1B88 00 00 00 00 
2721   1B8C 00 00 00 00 
2721   1B90 00 00 00 00 
2721   1B94 00 00 00 00 
2721   1B98 00 00 00 00 
2721   1B9C 00 00 00 00 
2721   1BA0 00 00 00 00 
2721   1BA4 00 00 00 00 
2721   1BA8 00 00 00 00 
2721   1BAC 00 00 00 00 
2721   1BB0 00 00 00 00 
2721   1BB4 00 00 00 00 
2721   1BB8 00 00 00 00 
2721   1BBC 00 00 00 00 
2721   1BC0 00 00 00 00 
2721   1BC4 00 00 00 00 
2721   1BC8 00 00 00 00 
2721   1BCC 00 00 00 00 
2721   1BD0 00 00 00 00 
2721   1BD4 00 00 00 00 
2721   1BD8 00 00 00 00 
2721   1BDC 00 00 00 00 
2721   1BE0 00 00 00 00 
2721   1BE4 00 00 00 00 
2721   1BE8 00 00 00 00 
2721   1BEC 00 00 00 00 
2721   1BF0 00 00 00 00 
2721   1BF4 00 00 00 00 
2722   1BF8 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2722   1BFC 00 00 00 00 
2722   1C00 00 00 00 00 
2722   1C04 00 00 00 00 
2723   1C08 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2723   1C0C 00 00 00 00 
2723   1C10 00 00 00 00 
2723   1C14 00 00 00 00 
2723   1C18 00 00 00 00 
2723   1C1C 00 00 00 00 
2723   1C20 00 00 00 00 
2723   1C24 00 00 00 00 
2723   1C28 00 00 00 00 
2723   1C2C 00 00 00 00 
2723   1C30 00 00 00 00 
2723   1C34 00 00 00 00 
2723   1C38 00 00 00 00 
2723   1C3C 00 00 00 00 
2723   1C40 00 00 00 00 
2723   1C44 00 00 00 00 
2723   1C48 00 00 00 00 
2723   1C4C 00 00 00 00 
2723   1C50 00 00 00 00 
2723   1C54 00 00 00 00 
2723   1C58 00 00 00 00 
2723   1C5C 00 00 00 00 
2723   1C60 00 00 00 00 
2723   1C64 00 00 00 00 
2723   1C68 00 00 00 00 
2723   1C6C 00 00 00 00 
2723   1C70 00 00 00 00 
2723   1C74 00 00 00 00 
2723   1C78 00 00 00 00 
2723   1C7C 00 00 00 00 
2723   1C80 00 00 00 00 
2723   1C84 00 00 00 00 
2723   1C88 00 00 00 00 
2723   1C8C 00 00 00 00 
2723   1C90 00 00 00 00 
2723   1C94 00 00 00 00 
2723   1C98 00 00 00 00 
2723   1C9C 00 00 00 00 
2723   1CA0 00 00 00 00 
2723   1CA4 00 00 00 00 
2723   1CA8 00 00 00 00 
2723   1CAC 00 00 00 00 
2723   1CB0 00 00 00 00 
2723   1CB4 00 00 00 00 
2723   1CB8 00 00 00 00 
2723   1CBC 00 00 00 00 
2723   1CC0 00 00 00 00 
2723   1CC4 00 00 00 00 
2723   1CC8 00 00 00 00 
2723   1CCC 00 00 00 00 
2723   1CD0 00 00 00 00 
2723   1CD4 00 00 00 00 
2723   1CD8 00 00 00 00 
2723   1CDC 00 00 00 00 
2723   1CE0 00 00 00 00 
2723   1CE4 00 00 00 00 
2723   1CE8 00 00 00 00 
2723   1CEC 00 00 00 00 
2723   1CF0 00 00 00 00 
2723   1CF4 00 00 00 00 
2723   1CF8 00 00 00 00 
2723   1CFC 00 00 00 00 
2723   1D00 00 00 00 00 
2723   1D04 00 00 00 00 
2723   1D08 00 00 00 00 
2723   1D0C 00 00 00 00 
2723   1D10 00 00 00 00 
2723   1D14 00 00 00 00 
2723   1D18 00 00 00 00 
2723   1D1C 00 00 00 00 
2723   1D20 00 00 00 00 
2723   1D24 00 00 00 00 
2723   1D28 00 00 00 00 
2723   1D2C 00 00 00 00 
2723   1D30 00 00 00 00 
2723   1D34 00 00 00 00 
2723   1D38 00 00 00 00 
2723   1D3C 00 00 00 00 
2723   1D40 00 00 00 00 
2723   1D44 00 00 00 00 
2723   1D48 00 00 00 00 
2723   1D4C 00 00 00 00 
2723   1D50 00 00 00 00 
2723   1D54 00 00 00 00 
2723   1D58 00 00 00 00 
2723   1D5C 00 00 00 00 
2723   1D60 00 00 00 00 
2723   1D64 00 00 00 00 
2723   1D68 00 00 00 00 
2723   1D6C 00 00 00 00 
2723   1D70 00 00 00 00 
2723   1D74 00 00 00 00 
2723   1D78 00 00 00 00 
2723   1D7C 00 00 00 00 
2723   1D80 00 00 00 00 
2723   1D84 00 00 00 00 
2723   1D88 00 00 00 00 
2723   1D8C 00 00 00 00 
2723   1D90 00 00 00 00 
2723   1D94 00 00 00 00 
2723   1D98 00 00 00 00 
2723   1D9C 00 00 00 00 
2723   1DA0 00 00 00 00 
2723   1DA4 00 00 00 00 
2723   1DA8 00 00 00 00 
2723   1DAC 00 00 00 00 
2723   1DB0 00 00 00 00 
2723   1DB4 00 00 00 00 
2723   1DB8 00 00 00 00 
2723   1DBC 00 00 00 00 
2723   1DC0 00 00 00 00 
2723   1DC4 00 00 00 00 
2723   1DC8 00 00 00 00 
2723   1DCC 00 00 00 00 
2723   1DD0 00 00 00 00 
2723   1DD4 00 00 00 00 
2723   1DD8 00 00 00 00 
2723   1DDC 00 00 00 00 
2723   1DE0 00 00 00 00 
2723   1DE4 00 00 00 00 
2723   1DE8 00 00 00 00 
2723   1DEC 00 00 00 00 
2723   1DF0 00 00 00 00 
2723   1DF4 00 00 00 00 
2723   1DF8 00 00 00 00 
2723   1DFC 00 00 00 00 
2723   1E00 00 00 00 00 
2723   1E04 00 00 00 00 
2724   1E08 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2724   1E0C 00 00 00 00 
2724   1E10 00 00 00 00 
2724   1E14 00 00 00 00 
2724   1E18 00 00 00 00 
2724   1E1C 00 00 00 00 
2724   1E20 00 00 00 00 
2724   1E24 00 00 00 00 
2724   1E28 00 00 00 00 
2724   1E2C 00 00 00 00 
2724   1E30 00 00 00 00 
2724   1E34 00 00 00 00 
2724   1E38 00 00 00 00 
2724   1E3C 00 00 00 00 
2724   1E40 00 00 00 00 
2724   1E44 00 00 00 00 
2724   1E48 00 00 00 00 
2724   1E4C 00 00 00 00 
2724   1E50 00 00 00 00 
2724   1E54 00 00 00 00 
2724   1E58 00 00 00 00 
2724   1E5C 00 00 00 00 
2724   1E60 00 00 00 00 
2724   1E64 00 00 00 00 
2724   1E68 00 00 00 00 
2724   1E6C 00 00 00 00 
2724   1E70 00 00 00 00 
2724   1E74 00 00 00 00 
2724   1E78 00 00 00 00 
2724   1E7C 00 00 00 00 
2724   1E80 00 00 00 00 
2724   1E84 00 00 00 00 
2725   1E88 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2725   1E8C 00 00 00 00 
2725   1E90 00 00 00 00 
2725   1E94 00 00 00 00 
2725   1E98 00 00 00 00 
2725   1E9C 00 00 00 00 
2725   1EA0 00 00 00 00 
2725   1EA4 00 00 00 00 
2725   1EA8 00 00 00 00 
2725   1EAC 00 00 00 00 
2725   1EB0 00 00 00 00 
2725   1EB4 00 00 00 00 
2725   1EB8 00 00 00 00 
2725   1EBC 00 00 00 00 
2725   1EC0 00 00 00 00 
2725   1EC4 00 00 00 00 
2725   1EC8 00 00 00 00 
2725   1ECC 00 00 00 00 
2725   1ED0 00 00 00 00 
2725   1ED4 00 00 00 00 
2725   1ED8 00 00 00 00 
2725   1EDC 00 00 00 00 
2725   1EE0 00 00 00 00 
2725   1EE4 00 00 00 00 
2725   1EE8 00 00 00 00 
2725   1EEC 00 00 00 00 
2725   1EF0 00 00 00 00 
2725   1EF4 00 00 00 00 
2725   1EF8 00 00 00 00 
2725   1EFC 00 00 00 00 
2725   1F00 00 00 00 00 
2725   1F04 00 00 00 00 
2725   1F08 00 00 00 00 
2725   1F0C 00 00 00 00 
2725   1F10 00 00 00 00 
2725   1F14 00 00 00 00 
2725   1F18 00 00 00 00 
2725   1F1C 00 00 00 00 
2725   1F20 00 00 00 00 
2725   1F24 00 00 00 00 
2725   1F28 00 00 00 00 
2725   1F2C 00 00 00 00 
2725   1F30 00 00 00 00 
2725   1F34 00 00 00 00 
2725   1F38 00 00 00 00 
2725   1F3C 00 00 00 00 
2725   1F40 00 00 00 00 
2725   1F44 00 00 00 00 
2725   1F48 00 00 00 00 
2725   1F4C 00 00 00 00 
2725   1F50 00 00 00 00 
2725   1F54 00 00 00 00 
2725   1F58 00 00 00 00 
2725   1F5C 00 00 00 00 
2725   1F60 00 00 00 00 
2725   1F64 00 00 00 00 
2725   1F68 00 00 00 00 
2725   1F6C 00 00 00 00 
2725   1F70 00 00 00 00 
2725   1F74 00 00 00 00 
2725   1F78 00 00 00 00 
2725   1F7C 00 00 00 00 
2725   1F80 00 00 00 00 
2725   1F84 00 00 00 00 
2725   1F88 00 00 00 00 
2725   1F8C 00 00 00 00 
2725   1F90 00 00 00 00 
2725   1F94 00 00 00 00 
2725   1F98 00 00 00 00 
2725   1F9C 00 00 00 00 
2725   1FA0 00 00 00 00 
2725   1FA4 00 00 00 00 
2725   1FA8 00 00 00 00 
2725   1FAC 00 00 00 00 
2725   1FB0 00 00 00 00 
2725   1FB4 00 00 00 00 
2725   1FB8 00 00 00 00 
2725   1FBC 00 00 00 00 
2725   1FC0 00 00 00 00 
2725   1FC4 00 00 00 00 
2725   1FC8 00 00 00 00 
2725   1FCC 00 00 00 00 
2725   1FD0 00 00 00 00 
2725   1FD4 00 00 00 00 
2725   1FD8 00 00 00 00 
2725   1FDC 00 00 00 00 
2725   1FE0 00 00 00 00 
2725   1FE4 00 00 00 00 
2725   1FE8 00 00 00 00 
2725   1FEC 00 00 00 00 
2725   1FF0 00 00 00 00 
2725   1FF4 00 00 00 00 
2725   1FF8 00 00 00 00 
2725   1FFC 00 00 00 00 
2725   2000 00 00 00 00 
2725   2004 00 00 00 00 
2725   2008 00 00 00 00 
2725   200C 00 00 00 00 
2725   2010 00 00 00 00 
2725   2014 00 00 00 00 
2725   2018 00 00 00 00 
2725   201C 00 00 00 00 
2725   2020 00 00 00 00 
2725   2024 00 00 00 00 
2725   2028 00 00 00 00 
2725   202C 00 00 00 00 
2725   2030 00 00 00 00 
2725   2034 00 00 00 00 
2725   2038 00 00 00 00 
2725   203C 00 00 00 00 
2725   2040 00 00 00 00 
2725   2044 00 00 00 00 
2725   2048 00 00 00 00 
2725   204C 00 00 00 00 
2725   2050 00 00 00 00 
2725   2054 00 00 00 00 
2725   2058 00 00 00 00 
2725   205C 00 00 00 00 
2725   2060 00 00 00 00 
2725   2064 00 00 00 00 
2725   2068 00 00 00 00 
2725   206C 00 00 00 00 
2725   2070 00 00 00 00 
2725   2074 00 00 00 00 
2725   2078 00 00 00 00 
2725   207C 00 00 00 00 
2725   2080 00 00 00 00 
2725   2084 00 00 00 00 
2726   2088 FF FF FF FF fifo:               .fill FIFO_SIZE
2726   208C FF FF FF FF 
2726   2090 FF FF FF FF 
2726   2094 FF FF FF FF 
2726   2098 FF FF FF FF 
2726   209C FF FF FF FF 
2726   20A0 FF FF FF FF 
2726   20A4 FF FF FF FF 
2726   20A8 FF FF FF FF 
2726   20AC FF FF FF FF 
2726   20B0 FF FF FF FF 
2726   20B4 FF FF FF FF 
2726   20B8 FF FF FF FF 
2726   20BC FF FF FF FF 
2726   20C0 FF FF FF FF 
2726   20C4 FF FF FF FF 
2726   20C8 FF FF FF FF 
2726   20CC FF FF FF FF 
2726   20D0 FF FF FF FF 
2726   20D4 FF FF FF FF 
2726   20D8 FF FF FF FF 
2726   20DC FF FF FF FF 
2726   20E0 FF FF FF FF 
2726   20E4 FF FF FF FF 
2726   20E8 FF FF FF FF 
2726   20EC FF FF FF FF 
2726   20F0 FF FF FF FF 
2726   20F4 FF FF FF FF 
2726   20F8 FF FF FF FF 
2726   20FC FF FF FF FF 
2726   2100 FF FF FF FF 
2726   2104 FF FF FF FF 
2726   2108 FF FF FF FF 
2726   210C FF FF FF FF 
2726   2110 FF FF FF FF 
2726   2114 FF FF FF FF 
2726   2118 FF FF FF FF 
2726   211C FF FF FF FF 
2726   2120 FF FF FF FF 
2726   2124 FF FF FF FF 
2726   2128 FF FF FF FF 
2726   212C FF FF FF FF 
2726   2130 FF FF FF FF 
2726   2134 FF FF FF FF 
2726   2138 FF FF FF FF 
2726   213C FF FF FF FF 
2726   2140 FF FF FF FF 
2726   2144 FF FF FF FF 
2726   2148 FF FF FF FF 
2726   214C FF FF FF FF 
2726   2150 FF FF FF FF 
2726   2154 FF FF FF FF 
2726   2158 FF FF FF FF 
2726   215C FF FF FF FF 
2726   2160 FF FF FF FF 
2726   2164 FF FF FF FF 
2726   2168 FF FF FF FF 
2726   216C FF FF FF FF 
2726   2170 FF FF FF FF 
2726   2174 FF FF FF FF 
2726   2178 FF FF FF FF 
2726   217C FF FF FF FF 
2726   2180 FF FF FF FF 
2726   2184 FF FF FF FF 
2726   2188 FF FF FF FF 
2726   218C FF FF FF FF 
2726   2190 FF FF FF FF 
2726   2194 FF FF FF FF 
2726   2198 FF FF FF FF 
2726   219C FF FF FF FF 
2726   21A0 FF FF FF FF 
2726   21A4 FF FF FF FF 
2726   21A8 FF FF FF FF 
2726   21AC FF FF FF FF 
2726   21B0 FF FF FF FF 
2726   21B4 FF FF FF FF 
2726   21B8 FF FF FF FF 
2726   21BC FF FF FF FF 
2726   21C0 FF FF FF FF 
2726   21C4 FF FF FF FF 
2726   21C8 FF FF FF FF 
2726   21CC FF FF FF FF 
2726   21D0 FF FF FF FF 
2726   21D4 FF FF FF FF 
2726   21D8 FF FF FF FF 
2726   21DC FF FF FF FF 
2726   21E0 FF FF FF FF 
2726   21E4 FF FF FF FF 
2726   21E8 FF FF FF FF 
2726   21EC FF FF FF FF 
2726   21F0 FF FF FF FF 
2726   21F4 FF FF FF FF 
2726   21F8 FF FF FF FF 
2726   21FC FF FF FF FF 
2726   2200 FF FF FF FF 
2726   2204 FF FF FF FF 
2726   2208 FF FF FF FF 
2726   220C FF FF FF FF 
2726   2210 FF FF FF FF 
2726   2214 FF FF FF FF 
2726   2218 FF FF FF FF 
2726   221C FF FF FF FF 
2726   2220 FF FF FF FF 
2726   2224 FF FF FF FF 
2726   2228 FF FF FF FF 
2726   222C FF FF FF FF 
2726   2230 FF FF FF FF 
2726   2234 FF FF FF FF 
2726   2238 FF FF FF FF 
2726   223C FF FF FF FF 
2726   2240 FF FF FF FF 
2726   2244 FF FF FF FF 
2726   2248 FF FF FF FF 
2726   224C FF FF FF FF 
2726   2250 FF FF FF FF 
2726   2254 FF FF FF FF 
2726   2258 FF FF FF FF 
2726   225C FF FF FF FF 
2726   2260 FF FF FF FF 
2726   2264 FF FF FF FF 
2726   2268 FF FF FF FF 
2726   226C FF FF FF FF 
2726   2270 FF FF FF FF 
2726   2274 FF FF FF FF 
2726   2278 FF FF FF FF 
2726   227C FF FF FF FF 
2726   2280 FF FF FF FF 
2726   2284 FF FF FF FF 
2726   2288 FF FF FF FF 
2726   228C FF FF FF FF 
2726   2290 FF FF FF FF 
2726   2294 FF FF FF FF 
2726   2298 FF FF FF FF 
2726   229C FF FF FF FF 
2726   22A0 FF FF FF FF 
2726   22A4 FF FF FF FF 
2726   22A8 FF FF FF FF 
2726   22AC FF FF FF FF 
2726   22B0 FF FF FF FF 
2726   22B4 FF FF FF FF 
2726   22B8 FF FF FF FF 
2726   22BC FF FF FF FF 
2726   22C0 FF FF FF FF 
2726   22C4 FF FF FF FF 
2726   22C8 FF FF FF FF 
2726   22CC FF FF FF FF 
2726   22D0 FF FF FF FF 
2726   22D4 FF FF FF FF 
2726   22D8 FF FF FF FF 
2726   22DC FF FF FF FF 
2726   22E0 FF FF FF FF 
2726   22E4 FF FF FF FF 
2726   22E8 FF FF FF FF 
2726   22EC FF FF FF FF 
2726   22F0 FF FF FF FF 
2726   22F4 FF FF FF FF 
2726   22F8 FF FF FF FF 
2726   22FC FF FF FF FF 
2726   2300 FF FF FF FF 
2726   2304 FF FF FF FF 
2726   2308 FF FF FF FF 
2726   230C FF FF FF FF 
2726   2310 FF FF FF FF 
2726   2314 FF FF FF FF 
2726   2318 FF FF FF FF 
2726   231C FF FF FF FF 
2726   2320 FF FF FF FF 
2726   2324 FF FF FF FF 
2726   2328 FF FF FF FF 
2726   232C FF FF FF FF 
2726   2330 FF FF FF FF 
2726   2334 FF FF FF FF 
2726   2338 FF FF FF FF 
2726   233C FF FF FF FF 
2726   2340 FF FF FF FF 
2726   2344 FF FF FF FF 
2726   2348 FF FF FF FF 
2726   234C FF FF FF FF 
2726   2350 FF FF FF FF 
2726   2354 FF FF FF FF 
2726   2358 FF FF FF FF 
2726   235C FF FF FF FF 
2726   2360 FF FF FF FF 
2726   2364 FF FF FF FF 
2726   2368 FF FF FF FF 
2726   236C FF FF FF FF 
2726   2370 FF FF FF FF 
2726   2374 FF FF FF FF 
2726   2378 FF FF FF FF 
2726   237C FF FF FF FF 
2726   2380 FF FF FF FF 
2726   2384 FF FF FF FF 
2726   2388 FF FF FF FF 
2726   238C FF FF FF FF 
2726   2390 FF FF FF FF 
2726   2394 FF FF FF FF 
2726   2398 FF FF FF FF 
2726   239C FF FF FF FF 
2726   23A0 FF FF FF FF 
2726   23A4 FF FF FF FF 
2726   23A8 FF FF FF FF 
2726   23AC FF FF FF FF 
2726   23B0 FF FF FF FF 
2726   23B4 FF FF FF FF 
2726   23B8 FF FF FF FF 
2726   23BC FF FF FF FF 
2726   23C0 FF FF FF FF 
2726   23C4 FF FF FF FF 
2726   23C8 FF FF FF FF 
2726   23CC FF FF FF FF 
2726   23D0 FF FF FF FF 
2726   23D4 FF FF FF FF 
2726   23D8 FF FF FF FF 
2726   23DC FF FF FF FF 
2726   23E0 FF FF FF FF 
2726   23E4 FF FF FF FF 
2726   23E8 FF FF FF FF 
2726   23EC FF FF FF FF 
2726   23F0 FF FF FF FF 
2726   23F4 FF FF FF FF 
2726   23F8 FF FF FF FF 
2726   23FC FF FF FF FF 
2726   2400 FF FF FF FF 
2726   2404 FF FF FF FF 
2726   2408 FF FF FF FF 
2726   240C FF FF FF FF 
2726   2410 FF FF FF FF 
2726   2414 FF FF FF FF 
2726   2418 FF FF FF FF 
2726   241C FF FF FF FF 
2726   2420 FF FF FF FF 
2726   2424 FF FF FF FF 
2726   2428 FF FF FF FF 
2726   242C FF FF FF FF 
2726   2430 FF FF FF FF 
2726   2434 FF FF FF FF 
2726   2438 FF FF FF FF 
2726   243C FF FF FF FF 
2726   2440 FF FF FF FF 
2726   2444 FF FF FF FF 
2726   2448 FF FF FF FF 
2726   244C FF FF FF FF 
2726   2450 FF FF FF FF 
2726   2454 FF FF FF FF 
2726   2458 FF FF FF FF 
2726   245C FF FF FF FF 
2726   2460 FF FF FF FF 
2726   2464 FF FF FF FF 
2726   2468 FF FF FF FF 
2726   246C FF FF FF FF 
2726   2470 FF FF FF FF 
2726   2474 FF FF FF FF 
2726   2478 FF FF FF FF 
2726   247C FF FF FF FF 
2726   2480 FF FF FF FF 
2726   2484 FF FF FF FF 
2727   2488             
2728   2488 FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2728   248C FF FF FF FF 
2728   2490 FF FF FF FF 
2728   2494 FF FF FF FF 
2728   2498 FF FF FF FF 
2728   249C FF FF FF FF 
2728   24A0 FF FF FF FF 
2728   24A4 FF FF FF FF 
2728   24A8 FF FF FF FF 
2728   24AC FF FF FF FF 
2728   24B0 FF FF FF FF 
2728   24B4 FF FF FF FF 
2728   24B8 FF FF FF FF 
2728   24BC FF FF FF FF 
2728   24C0 FF FF FF FF 
2728   24C4 FF FF FF FF 
2728   24C8 FF FF FF FF 
2728   24CC FF FF FF FF 
2728   24D0 FF FF FF FF 
2728   24D4 FF FF FF FF 
2728   24D8 FF FF FF FF 
2728   24DC FF FF FF FF 
2728   24E0 FF FF FF FF 
2728   24E4 FF FF FF FF 
2728   24E8 FF FF FF FF 
2728   24EC FF FF FF FF 
2728   24F0 FF FF FF FF 
2728   24F4 FF FF FF FF 
2728   24F8 FF FF FF FF 
2728   24FC FF FF FF FF 
2728   2500 FF FF FF FF 
2728   2504 FF FF FF FF 
2728   2508 FF FF FF FF 
2728   250C FF FF FF FF 
2728   2510 FF FF FF FF 
2728   2514 FF FF FF FF 
2728   2518 FF FF FF FF 
2728   251C FF FF FF FF 
2728   2520 FF FF FF FF 
2728   2524 FF FF FF FF 
2728   2528 FF FF FF FF 
2728   252C FF FF FF FF 
2728   2530 FF FF FF FF 
2728   2534 FF FF FF FF 
2728   2538 FF FF FF FF 
2728   253C FF FF FF FF 
2728   2540 FF FF FF FF 
2728   2544 FF FF FF FF 
2728   2548 FF FF FF FF 
2728   254C FF FF FF FF 
2728   2550 FF FF FF FF 
2728   2554 FF FF FF FF 
2728   2558 FF FF FF FF 
2728   255C FF FF FF FF 
2728   2560 FF FF FF FF 
2728   2564 FF FF FF FF 
2728   2568 FF FF FF FF 
2728   256C FF FF FF FF 
2728   2570 FF FF FF FF 
2728   2574 FF FF FF FF 
2728   2578 FF FF FF FF 
2728   257C FF FF FF FF 
2728   2580 FF FF FF FF 
2728   2584 FF FF FF FF 
2728   2588 FF FF FF FF 
2728   258C FF FF FF FF 
2728   2590 FF FF FF FF 
2728   2594 FF FF FF FF 
2728   2598 FF FF FF FF 
2728   259C FF FF FF FF 
2728   25A0 FF FF FF FF 
2728   25A4 FF FF FF FF 
2728   25A8 FF FF FF FF 
2728   25AC FF FF FF FF 
2728   25B0 FF FF FF FF 
2728   25B4 FF FF FF FF 
2728   25B8 FF FF FF FF 
2728   25BC FF FF FF FF 
2728   25C0 FF FF FF FF 
2728   25C4 FF FF FF FF 
2728   25C8 FF FF FF FF 
2728   25CC FF FF FF FF 
2728   25D0 FF FF FF FF 
2728   25D4 FF FF FF FF 
2728   25D8 FF FF FF FF 
2728   25DC FF FF FF FF 
2728   25E0 FF FF FF FF 
2728   25E4 FF FF FF FF 
2728   25E8 FF FF FF FF 
2728   25EC FF FF FF FF 
2728   25F0 FF FF FF FF 
2728   25F4 FF FF FF FF 
2728   25F8 FF FF FF FF 
2728   25FC FF FF FF FF 
2728   2600 FF FF FF FF 
2728   2604 FF FF FF FF 
2728   2608 FF FF FF FF 
2728   260C FF FF FF FF 
2728   2610 FF FF FF FF 
2728   2614 FF FF FF FF 
2728   2618 FF FF FF FF 
2728   261C FF FF FF FF 
2728   2620 FF FF FF FF 
2728   2624 FF FF FF FF 
2728   2628 FF FF FF FF 
2728   262C FF FF FF FF 
2728   2630 FF FF FF FF 
2728   2634 FF FF FF FF 
2728   2638 FF FF FF FF 
2728   263C FF FF FF FF 
2728   2640 FF FF FF FF 
2728   2644 FF FF FF FF 
2728   2648 FF FF FF FF 
2728   264C FF FF FF FF 
2728   2650 FF FF FF FF 
2728   2654 FF FF FF FF 
2728   2658 FF FF FF FF 
2728   265C FF FF FF FF 
2728   2660 FF FF FF FF 
2728   2664 FF FF FF FF 
2728   2668 FF FF FF FF 
2728   266C FF FF FF FF 
2728   2670 FF FF FF FF 
2728   2674 FF FF FF FF 
2728   2678 FF FF FF FF 
2728   267C FF FF FF FF 
2728   2680 FF FF FF FF 
2728   2684 FF FF FF FF 
2729   2688 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2730   2689             
2731   2689             
2732   2689             .end
tasm: Number of errors = 0
