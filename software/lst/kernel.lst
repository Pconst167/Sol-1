0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             ; Memory Map
0005   0000             ; ------------------------------------------------------------------------------------------------------------------;
0006   0000             ; 0000    ROM BEGIN
0007   0000             ; ....
0008   0000             ; 7FFF    ROM END
0009   0000             ;
0010   0000             ; 8000    RAM begin
0011   0000             ; ....
0012   0000             ; F7FF    Stack root
0013   0000             ; ------------------------------------------------------------------------------------------------------------------;
0014   0000             ; I/O MAP
0015   0000             ; ------------------------------------------------------------------------------------------------------------------;
0016   0000             ; FF80    UART 0    (16550)
0017   0000             ; FF90    UART 1    (16550)
0018   0000             ; FFA0    RTC       (M48T02)
0019   0000             ; FFB0    PIO 0     (8255)
0020   0000             ; FFC0    PIO 1     (8255)
0021   0000             ; FFD0    IDE       (Compact Flash / PATA)
0022   0000             ; FFE0    Timer     (8253)
0023   0000             ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0024   0000             ; ------------------------------------------------------------------------------------------------------------------;
0025   0000             
0026   0000             ; ------------------------------------------------------------------------------------------------------------------;
0027   0000             ; System Constants
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             _UART0_DATA       .equ $FF80            ; data
0030   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0031   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0032   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0033   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0034   0000             _UART0_LCR        .equ $FF83            ; line control register
0035   0000             _UART0_LSR        .equ $FF85            ; line status register
0036   0000             
0037   0000             _UART1_DATA       .equ $FF90            ; data
0038   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0039   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0040   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0041   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0042   0000             _UART1_LCR        .equ $FF93            ; line control register
0043   0000             _UART1_LSR        .equ $FF95            ; line status register
0044   0000             
0045   0000             XON               .equ $11
0046   0000             XOFF              .equ $13
0047   0000             
0048   0000             _ide_BASE         .equ $FFD0            ; IDE BASE
0049   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0050   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0051   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0052   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0053   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0054   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0055   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0056   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0057   0000             
0058   0000             _7SEG_DISPLAY     .equ $FFB0            ; BIOS POST CODE HEX DISPLAY (2 DIGITS) (CONNECTED TO PIO A)
0059   0000             _BIOS_POST_CTRL   .equ $FFB3            ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0060   0000             _PIO_A            .equ $FFB0    
0061   0000             _PIO_B            .equ $FFB1
0062   0000             _PIO_C            .equ $FFB2
0063   0000             _PIO_CONTROL      .equ $FFB3            ; PIO CONTROL PORT
0064   0000             
0065   0000             _TIMER_C_0        .equ $FFE0            ; TIMER COUNTER 0
0066   0000             _TIMER_C_1        .equ $FFE1            ; TIMER COUNTER 1
0067   0000             _TIMER_C_2        .equ $FFE2            ; TIMER COUNTER 2
0068   0000             _TIMER_CTRL       .equ $FFE3            ; TIMER CONTROL REGISTER
0069   0000             
0070   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0071   0000             FIFO_SIZE         .equ 1024
0072   0000             
0073   0000             text_org          .equ $400
0074   0000             ; ------------------------------------------------------------------------------------------------------------------;
0075   0000             
0076   0000             
0077   0000             ; For the next iteration:
0078   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0079   0000             ; inode-table format:
0080   0000             ;  file-type(f, d)
0081   0000             ;  permissons
0082   0000             ;  link-count
0083   0000             ;  filesize
0084   0000             ;  time-stamps
0085   0000             ;  15 data block pointers
0086   0000             ;  single-indirect pointer
0087   0000             
0088   0000             ; FILE ENTRY ATTRIBUTES
0089   0000             ; filename (24)
0090   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0091   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0092   0000             ; size (2)             : filesize
0093   0000             ; day (1)           
0094   0000             ; month (1)
0095   0000             ; year (1)
0096   0000             ; packet size = 32 bytes  : total packet size in bytes
0097   0000             
0098   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0099   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0100   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0101   0000             FST_NBR_DIRECTORIES     .equ 64
0102   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0103   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0104   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0105   0000             FST_LBA_START           .equ 32
0106   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0107   0000             
0108   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0109   0000             FS_SECTORS_PER_FILE     .equ 32         ; the first sector is always a header with a NULL parameter (first byte)
0110   0000                                                     ; so that we know which blocks are free or taken
0111   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0112   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0113   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0114   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0115   0000             
0116   0000             root_id:                .equ FST_LBA_START
0117   0000             
0118   0000             ; ------------------------------------------------------------------------------------------------------------------;
0119   0000             ; GLOBAL SYSTEM VARIABLES
0120   0000             ; ------------------------------------------------------------------------------------------------------------------;
0121   0000             
0122   0000             ; ------------------------------------------------------------------------------------------------------------------;
0123   0000             ; IRQ Table
0124   0000             ; Highest priority at lowest address
0125   0000             ; ------------------------------------------------------------------------------------------------------------------;
0126   0000 3A 00       .dw int_0
0127   0002 3B 00       .dw int_1
0128   0004 3C 00       .dw int_2
0129   0006 3D 00       .dw int_3
0130   0008 3E 00       .dw int_4
0131   000A 3F 00       .dw int_5
0132   000C 40 00       .dw int_6
0133   000E 8C 00       .dw int_7
0134   0010             
0135   0010             ; ------------------------------------------------------------------------------------------------------------------;
0136   0010             ; Reset Vector
0137   0010             ; ------------------------------------------------------------------------------------------------------------------;
0138   0010 2C 0E       .dw kernel_reset_vector
0139   0012             
0140   0012             ; ------------------------------------------------------------------------------------------------------------------;
0141   0012             ; Exception Vector Table
0142   0012             ; Total of 7 entries, starting at address $0012
0143   0012             ; ------------------------------------------------------------------------------------------------------------------;
0144   0012 78 01       .dw trap_privilege
0145   0014 95 02       .dw trap_div_zero
0146   0016 A2 02       .dw trap_undef_opcode
0147   0018 00 00       .dw 0
0148   001A 00 00       .dw 0
0149   001C 00 00       .dw 0
0150   001E 00 00       .dw 0
0151   0020             
0152   0020             ; ------------------------------------------------------------------------------------------------------------------;
0153   0020             ; System Call Vector Table
0154   0020             ; Starts at address $0020
0155   0020             ; ------------------------------------------------------------------------------------------------------------------;
0156   0020 84 01       .dw syscall_break
0157   0022 A3 02       .dw syscall_rtc
0158   0024 DD 03       .dw syscall_ide
0159   0026 B8 04       .dw syscall_io
0160   0028 75 05       .dw syscall_file_system
0161   002A 03 0F       .dw syscall_spawn_proc
0162   002C 3D 01       .dw syscall_list_procs
0163   002E D5 02       .dw syscall_datetime
0164   0030 F9 00       .dw syscall_reboot
0165   0032 CD 0E       .dw syscall_pause_proc
0166   0034 05 01       .dw syscall_resume_proc
0167   0036 8A 0E       .dw syscall_terminate_proc
0168   0038 CB 00       .dw syscall_system
0169   003A             
0170   003A             ; ------------------------------------------------------------------------------------------------------------------;
0171   003A             ; System Call Aliases
0172   003A             ; ------------------------------------------------------------------------------------------------------------------;
0173   003A             sys_break            .equ 0
0174   003A             sys_rtc              .equ 1
0175   003A             sys_ide              .equ 2
0176   003A             sys_io               .equ 3
0177   003A             sys_filesystem       .equ 4
0178   003A             sys_spawn_proc       .equ 5
0179   003A             sys_list             .equ 6
0180   003A             sys_datetime         .equ 7
0181   003A             sys_reboot           .equ 8
0182   003A             sys_pause_proc       .equ 9
0183   003A             sys_resume_proc      .equ 10
0184   003A             sys_terminate_proc   .equ 11
0185   003A             sys_system           .equ 12
0186   003A             
0187   003A             ; ------------------------------------------------------------------------------------------------------------------;
0188   003A             ; Alias Exports
0189   003A             ; ------------------------------------------------------------------------------------------------------------------;
0190   003A             .export text_org
0191   003A             .export sys_break
0192   003A             .export sys_ide
0193   003A             .export sys_io
0194   003A             .export sys_filesystem
0195   003A             .export sys_spawn_proc
0196   003A             .export sys_list
0197   003A             .export sys_rtc
0198   003A             .export sys_datetime
0199   003A             .export sys_reboot
0200   003A             .export sys_pause_proc
0201   003A             .export sys_resume_proc
0202   003A             .export sys_terminate_proc
0203   003A             .export sys_system
0204   003A             
0205   003A             ; ------------------------------------------------------------------------------------------------------------------;
0206   003A             ; IRQs' Code Block
0207   003A             ; ------------------------------------------------------------------------------------------------------------------;
0208   003A             int_0:
0209   003A 06            sysret
0210   003B             int_1:
0211   003B 06            sysret
0212   003C             int_2:
0213   003C 06            sysret
0214   003D             int_3:
0215   003D 06            sysret
0216   003E             int_4:
0217   003E 06            sysret
0218   003F             int_5:
0219   003F 06            sysret
0220   0040             
0221   0040             ; ------------------------------------------------------------------------------------------------------------------;
0222   0040             ; Process Swapping
0223   0040             ; ------------------------------------------------------------------------------------------------------------------;
0224   0040             int_6:  
0225   0040 4B            pusha ; save all registers into kernel stack
0226   0041 22 00         mov ah, 0
0227   0043 1D FB 16      mov al, [active_proc_index]
0228   0046 FD 99         shl a              ; x2
0229   0048 B7 80 0F      mov a, [proc_table_convert + a]  ; get process state start index
0230   004B 4F            mov di, a
0231   004C 48            mov a, sp
0232   004D 77            inc a
0233   004E 4D            mov si, a
0234   004F 38 14 00      mov c, 20
0235   0052 FD F5         rep movsb          ; save process state!
0236   0054             ; restore kernel stack position to point before interrupt arrived
0237   0054 51 14 00      add sp, 20
0238   0057             ; now load next process in queue
0239   0057 1D FB 16      mov al, [active_proc_index]
0240   005A 31 FA 16      mov bl, [nbr_active_procs]
0241   005D BA            cmp al, bl
0242   005E C6 65 00      je int6_cycle_back
0243   0061 7A            inc al            ; next process is next in the series
0244   0062 0A 67 00      jmp int6_continue
0245   0065             int6_cycle_back:
0246   0065 19 01         mov al, 1        ; next process = process 1
0247   0067             int6_continue:
0248   0067 3D FB 16      mov [active_proc_index], al    ; set next active proc
0249   006A             
0250   006A             ; calculate LUT entry for next process
0251   006A 22 00         mov ah, 0
0252   006C FD 99         shl a              ; x2
0253   006E B7 80 0F      mov a, [proc_table_convert + a]    ; get process state start index  
0254   0071               
0255   0071 4D            mov si, a            ; source is proc state block
0256   0072 48            mov a, sp
0257   0073 5F 13 00      sub a, 19
0258   0076 4F            mov di, a            ; destination is kernel stack
0259   0077             ; restore SP
0260   0077 7D            dec a
0261   0078 47            mov sp, a
0262   0079 38 14 00      mov c, 20
0263   007C FD F5         rep movsb
0264   007E             ; set VM process
0265   007E 1D FB 16      mov al, [active_proc_index]
0266   0081 01            setptb
0267   0082 F2 E0 FF 00   mov byte[_TIMER_C_0], 0        ; load counter 0 low byte
0268   0086 F2 E0 FF 10   mov byte[_TIMER_C_0], $10        ; load counter 0 high byte
0269   008A 4C            popa
0270   008B 06            sysret
0271   008C             
0272   008C             ; ------------------------------------------------------------------------------------------------------------------;
0273   008C             ; UART0 Interrupt
0274   008C             ; ------------------------------------------------------------------------------------------------------------------;
0275   008C             int_7:
0276   008C D7            push a
0277   008D DA            push d
0278   008E E1            pushf
0279   008F 14 00 17      mov a, [fifo_in]
0280   0092 3C            mov d, a
0281   0093 1D 80 FF      mov al, [_UART0_DATA]  ; get character
0282   0096 B9 03         cmp al, $03        ; CTRL-C
0283   0098 C6 B5 00      je CTRLC
0284   009B B9 1A         cmp al, $1A        ; CTRL-Z
0285   009D C6 BB 00      je CTRLZ
0286   00A0 3E            mov [d], al        ; add to fifo
0287   00A1 14 00 17      mov a, [fifo_in]
0288   00A4 77            inc a
0289   00A5 AF FF 21      cmp a, fifo + FIFO_SIZE         ; check if pointer reached the end of the fifo
0290   00A8 C7 AE 00      jne int_7_continue
0291   00AB 10 FF 1D      mov a, fifo  
0292   00AE             int_7_continue:  
0293   00AE 42 00 17      mov [fifo_in], a      ; update fifo pointer
0294   00B1 EE            popf
0295   00B2 E7            pop d
0296   00B3 E4            pop a  
0297   00B4 06            sysret
0298   00B5             CTRLC:
0299   00B5 51 05 00      add sp, 5
0300   00B8 0A 8A 0E      jmp syscall_terminate_proc
0301   00BB             CTRLZ:
0302   00BB EE            popf
0303   00BC E7            pop d
0304   00BD E4            pop a
0305   00BE 0A CD 0E      jmp syscall_pause_proc    ; pause current process and go back to the shell
0306   00C1             
0307   00C1             ; ------------------------------------------------------------------------------------------------------------------;
0308   00C1             ; System Syscalls
0309   00C1             ; ------------------------------------------------------------------------------------------------------------------;
0310   00C1             system_jmptbl:
0311   00C1 F7 00         .dw system_uname
0312   00C3 F8 00         .dw system_whoami
0313   00C5 F4 00         .dw system_setparam
0314   00C7 D1 00         .dw system_bootloader_install
0315   00C9 CF 00         .dw system_getparam
0316   00CB             syscall_system:
0317   00CB FD 0A C1 00   jmp [system_jmptbl + al]
0318   00CF             
0319   00CF             ; param register address in register d
0320   00CF             ; param value in register bl
0321   00CF             system_getparam:
0322   00CF 32            mov bl, [d]
0323   00D0 06            sysret
0324   00D1             
0325   00D1             ; kernel LBA address in 'b'
0326   00D1             system_bootloader_install:
0327   00D1 D8            push b
0328   00D2 26 00 00      mov b, 0
0329   00D5 38 00 00      mov c, 0
0330   00D8 22 01         mov ah, $01                 ; 1 sector
0331   00DA 3B FF 23      mov d, transient_area
0332   00DD 07 27 04      call ide_read_sect          ; read sector
0333   00E0 E5            pop b
0334   00E1 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0335   00E5 26 00 00      mov b, 0
0336   00E8 38 00 00      mov c, 0
0337   00EB 22 01         mov ah, $01                 ; 1 sector
0338   00ED 3B FF 23      mov d, transient_area
0339   00F0 07 4D 04      call ide_write_sect         ; write sector
0340   00F3 06            sysret
0341   00F4             
0342   00F4             ; param register address in register d
0343   00F4             ; param value in register bl
0344   00F4             system_setparam:
0345   00F4 FD 3E         mov [d], bl
0346   00F6 06            sysret
0347   00F7             
0348   00F7             system_uname:
0349   00F7 06            sysret
0350   00F8             
0351   00F8             system_whoami:
0352   00F8 06            sysret
0353   00F9             
0354   00F9             ; REBOOT SYSTEM
0355   00F9             syscall_reboot:
0356   00F9 FD D7 FF FF   push word $FFFF 
0357   00FD FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0358   0100 FD D7 C0 01   push word BIOS_RESET_VECTOR    ; and then push RESET VECTOR of the shell to the stack
0359   0104 06            sysret
0360   0105             
0361   0105             ;------------------------------------------------------------------------------------------------------;;
0362   0105             ; switch to another process
0363   0105             ; inputs:
0364   0105             ; AL = new process number
0365   0105             ;------------------------------------------------------------------------------------------------------;;
0366   0105             syscall_resume_proc:
0367   0105 FD 78         mov g, a                            ; save the process number
0368   0107 4B            pusha                               ; save all registers into kernel stack
0369   0108 22 00         mov ah, 0
0370   010A 1D FB 16      mov al, [active_proc_index]
0371   010D FD 99         shl a              ; x2
0372   010F B7 80 0F      mov a, [proc_table_convert + a]     ; get process state start index
0373   0112 4F            mov di, a
0374   0113 48            mov a, sp
0375   0114 77            inc a
0376   0115 4D            mov si, a
0377   0116 38 14 00      mov c, 20
0378   0119 FD F5         rep movsb                           ; save process state!
0379   011B             ; restore kernel stack position to point before interrupt arrived
0380   011B 51 14 00      add sp, 20
0381   011E             ; now load the new process number!
0382   011E FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0383   0120 3D FB 16      mov [active_proc_index], al         ; set new active proc
0384   0123             ; calculate LUT entry for next process
0385   0123 22 00         mov ah, 0
0386   0125 FD 99         shl a                               ; x2
0387   0127 B7 80 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0388   012A 4D            mov si, a                           ; source is proc state block
0389   012B 48            mov a, sp
0390   012C 5F 13 00      sub a, 19
0391   012F 4F            mov di, a                           ; destination is kernel stack
0392   0130             ; restore SP
0393   0130 7D            dec a
0394   0131 47            mov sp, a
0395   0132 38 14 00      mov c, 20
0396   0135 FD F5         rep movsb
0397   0137             ; set VM process
0398   0137 1D FB 16      mov al, [active_proc_index]
0399   013A 01            setptb
0400   013B 4C            popa
0401   013C 06            sysret
0402   013D             
0403   013D             syscall_list_procs:
0404   013D 3B 23 17      mov d, s_ps_header
0405   0140 07 CA 11      call _puts
0406   0143 3B 70 19      mov d, proc_availab_table + 1
0407   0146 38 01 00      mov c, 1
0408   0149             list_procs_L0:  
0409   0149 BD 01         cmp byte[d], 1
0410   014B C7 6F 01      jne list_procs_next
0411   014E 2D            mov b, d
0412   014F 61 6F 19      sub b, proc_availab_table
0413   0152 FD 9F 05      shl b, 5
0414   0155 DA            push d
0415   0156 D8            push b
0416   0157 28            mov b, c
0417   0158 07 6A 12      call print_u8x
0418   015B 22 20         mov ah, ' '
0419   015D 07 9E 10      call _putchar
0420   0160 07 9E 10      call _putchar
0421   0163 E5            pop b
0422   0164 74            mov d, b
0423   0165 58 7F 19      add d, proc_names
0424   0168 07 CA 11      call _puts
0425   016B 07 77 11      call printnl
0426   016E E7            pop d
0427   016F             list_procs_next:
0428   016F 79            inc d
0429   0170 78            inc c
0430   0171 C2 09 00      cmp c, 9
0431   0174 C7 49 01      jne list_procs_L0
0432   0177             list_procs_end:
0433   0177 06            sysret
0434   0178             
0435   0178             ; ------------------------------------------------------------------------------------------------------------------;
0436   0178             ; Exceptions' Code Block
0437   0178             ; ------------------------------------------------------------------------------------------------------------------;
0438   0178             ; Privilege
0439   0178             ; ------------------------------------------------------------------------------------------------------------------;
0440   0178             trap_privilege:
0441   0178 0A F9 00      jmp syscall_reboot
0442   017B DA            push d
0443   017C 3B 72 17      mov d, s_priviledge
0444   017F 07 CA 11      call _puts
0445   0182 E7            pop d
0446   0183 06            sysret
0447   0184             
0448   0184             ; ------------------------------------------------------------------------------------------------------------------;
0449   0184             ; Breakpoint
0450   0184             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0451   0184             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0452   0184             ; ------------------------------------------------------------------------------------------------------------------;
0453   0184             syscall_break:
0454   0184 4B            pusha
0455   0185             syscall_break_prompt:
0456   0185 3B 3F 02      mov d, s_break1
0457   0188 07 CA 11      call _puts
0458   018B 07 77 11      call printnl
0459   018E 07 CC 12      call scan_u16d
0460   0191 AF 00 00      cmp a, 0
0461   0194 C6 9F 01      je syscall_break_regs
0462   0197 AF 01 00      cmp a, 1
0463   019A C6 C2 01      je syscall_break_mem
0464   019D             syscall_break_end:  
0465   019D 4C            popa
0466   019E 06            sysret
0467   019F             syscall_break_regs:
0468   019F 48            mov a, sp
0469   01A0 53 0E 00      add a, 14               ; back-track 7 registers
0470   01A3 3C            mov d, a
0471   01A4 3A 07         mov cl, 7
0472   01A6             syscall_regs_L0:
0473   01A6 2A            mov b, [d]
0474   01A7 FD AB         swp b
0475   01A9 07 26 12      call print_u16x         ; print register value
0476   01AC 07 77 11      call printnl
0477   01AF 63 02 00      sub d, 2
0478   01B2 71 01         sub cl, 1
0479   01B4 C3 00         cmp cl, 0
0480   01B6 C7 A6 01      jne syscall_regs_L0
0481   01B9 0A 85 01      jmp syscall_break_prompt
0482   01BC 07 77 11      call printnl
0483   01BF 0A 85 01      jmp syscall_break_prompt
0484   01C2             syscall_break_mem:
0485   01C2 07 77 11      call printnl
0486   01C5 07 48 12      call scan_u16x
0487   01C8 4D            mov si, a               ; data source from user space
0488   01C9 FD 4F FF 21   mov di, scrap_sector    ; destination in kernel space
0489   01CD 38 00 02      mov c, 512
0490   01D0 04            load                    ; transfer data to kernel space!
0491   01D1 3B FF 21      mov d, scrap_sector     ; dump pointer in d
0492   01D4 38 00 00      mov c, 0
0493   01D7             dump_loop:
0494   01D7 84            mov al, cl
0495   01D8 87 0F         and al, $0F
0496   01DA C6 28 02      jz print_base
0497   01DD             back:
0498   01DD 1E            mov al, [d]             ; read byte
0499   01DE 2F            mov bl, al
0500   01DF 07 6A 12      call print_u8x
0501   01E2 10 00 20      mov a, $2000
0502   01E5 05 03         syscall sys_io          ; space
0503   01E7 84            mov al, cl
0504   01E8 87 0F         and al, $0F
0505   01EA B9 0F         cmp al, $0F
0506   01EC C6 FD 01      je print_ascii
0507   01EF             back1:
0508   01EF 79            inc d
0509   01F0 78            inc c
0510   01F1 C2 00 02      cmp c, 512
0511   01F4 C7 D7 01      jne dump_loop
0512   01F7 07 77 11      call printnl
0513   01FA 0A 85 01      jmp syscall_break_prompt  ; go to syscall_break return point
0514   01FD             print_ascii:
0515   01FD 10 00 20      mov a, $2000
0516   0200 05 03         syscall sys_io
0517   0202 63 10 00      sub d, 16
0518   0205 26 10 00      mov b, 16
0519   0208             print_ascii_L:
0520   0208 79            inc d
0521   0209 1E            mov al, [d]               ; read byte
0522   020A B9 20         cmp al, $20
0523   020C C8 14 02      jlu dot
0524   020F B9 7E         cmp al, $7E
0525   0211 D0 1C 02      jleu ascii
0526   0214             dot:
0527   0214 10 00 2E      mov a, $2E00
0528   0217 05 03         syscall sys_io
0529   0219 0A 21 02      jmp ascii_continue
0530   021C             ascii:
0531   021C 23            mov ah, al
0532   021D 19 00         mov al, 0
0533   021F 05 03         syscall sys_io
0534   0221             ascii_continue:
0535   0221 FD A9 08 02   loopb print_ascii_L
0536   0225 0A EF 01      jmp back1
0537   0228             print_base:
0538   0228 07 77 11      call printnl
0539   022B 2D            mov b, d
0540   022C 61 FF 21      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0541   022F 07 26 12      call print_u16x          ; display row
0542   0232 10 00 3A      mov a, $3A00
0543   0235 05 03         syscall sys_io
0544   0237 10 00 20      mov a, $2000
0545   023A 05 03         syscall sys_io
0546   023C 0A DD 01      jmp back
0547   023F             
0548   023F             s_break1:  
0549   023F 0A 44 65 62   .db "\nDebugger entry point.\n"
0549   0243 75 67 67 65 
0549   0247 72 20 65 6E 
0549   024B 74 72 79 20 
0549   024F 70 6F 69 6E 
0549   0253 74 2E 0A 
0550   0256 30 2E 20 53   .db "0. Show Registers\n"
0550   025A 68 6F 77 20 
0550   025E 52 65 67 69 
0550   0262 73 74 65 72 
0550   0266 73 0A 
0551   0268 31 2E 20 53   .db "1. Show 512B RAM block\n"
0551   026C 68 6F 77 20 
0551   0270 35 31 32 42 
0551   0274 20 52 41 4D 
0551   0278 20 62 6C 6F 
0551   027C 63 6B 0A 
0552   027F 32 2E 20 43   .db "2. Continue Execution", 0
0552   0283 6F 6E 74 69 
0552   0287 6E 75 65 20 
0552   028B 45 78 65 63 
0552   028F 75 74 69 6F 
0552   0293 6E 00 
0553   0295             
0554   0295             ; ------------------------------------------------------------------------------------------------------------------;
0555   0295             ; Divide by Zero
0556   0295             ; ------------------------------------------------------------------------------------------------------------------;
0557   0295             trap_div_zero:
0558   0295 D7            push a
0559   0296 DA            push d
0560   0297 E1            pushf
0561   0298 3B 89 17      mov d, s_divzero
0562   029B 07 CA 11      call _puts
0563   029E EE            popf
0564   029F E7            pop d
0565   02A0 E4            pop a
0566   02A1 06            sysret ; enable interrupts
0567   02A2             
0568   02A2             ; ------------------------------------------------------------------------------------------------------------------;
0569   02A2             ; Undefined Opcode
0570   02A2             ; ------------------------------------------------------------------------------------------------------------------;
0571   02A2             trap_undef_opcode:
0572   02A2 06            sysret
0573   02A3             
0574   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0575   02A3             ; RTC Services Syscall
0576   02A3             ; RTC I/O bank = FFA0 to FFAF
0577   02A3             ; FFA0 to FFA7 is scratch RAM
0578   02A3             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0579   02A3             ; al = 0..6 -> get
0580   02A3             ; al = 7..D -> set
0581   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0582   02A3             syscall_rtc:
0583   02A3 DB            push al
0584   02A4 DA            push d
0585   02A5 B9 06         cmp al, 6
0586   02A7 D1 BC 02      jgu syscall_rtc_set
0587   02AA             syscall_rtc_get:
0588   02AA 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0589   02AC 22 FF         mov ah, $FF    
0590   02AE 3C            mov d, a                ; get to FFA9 + offset
0591   02AF F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0592   02B3 1E            mov al, [d]             ; get data
0593   02B4 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0594   02B8 23            mov ah, al
0595   02B9 E7            pop d
0596   02BA E8            pop al
0597   02BB 06            sysret
0598   02BC             syscall_rtc_set:
0599   02BC DD            push bl
0600   02BD 99            mov bl, ah              ; set data asIDE
0601   02BE 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0602   02C0 22 FF         mov ah, $FF    
0603   02C2 3C            mov d, a                ; get to FFA9 + offset
0604   02C3 1B            mov al, bl              ; get data back
0605   02C4 F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0606   02C8 3E            mov [d], al             ; set data
0607   02C9 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0608   02CD EA            pop bl
0609   02CE E7            pop d
0610   02CF E8            pop al
0611   02D0 06            sysret
0612   02D1             
0613   02D1             datetime_serv_tbl:
0614   02D1 D9 02         .dw print_date
0615   02D3 4D 03         .dw set_date
0616   02D5             syscall_datetime:
0617   02D5 FD 0A D1 02   jmp [datetime_serv_tbl + al]      
0618   02D9             print_date:
0619   02D9 10 00 0D      mov a, $0D00           ; print carriage return char
0620   02DC 19 03         mov al, 3
0621   02DE 05 01         syscall sys_rtc        ; get week
0622   02E0 1A            mov al, ah
0623   02E1 22 00         mov ah, 0
0624   02E3 FD 9D 02      shl a, 2          
0625   02E6 3B 13 18      mov d, s_week
0626   02E9 59            add d, a
0627   02EA 07 CA 11      call _puts
0628   02ED 10 00 20      mov a, $2000
0629   02F0 05 03         syscall sys_io         ; display ' '
0630   02F2 19 04         mov al, 4
0631   02F4 05 01         syscall sys_rtc        ; get day
0632   02F6 99            mov bl, ah
0633   02F7 07 6A 12      call print_u8x
0634   02FA 10 00 20      mov a, $2000
0635   02FD 05 03         syscall sys_io         ; display ' '
0636   02FF             ; there is a problem with the month displaying
0637   02FF             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0638   02FF             ; even though it is to be understood as BCD.
0639   02FF             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0640   02FF 19 05         mov al, 05
0641   0301 05 01         syscall sys_rtc        ; get month
0642   0303 1A            mov al, ah
0643   0304 22 00         mov ah, 0
0644   0306 FD 9D 02      shl a, 2          
0645   0309 3B DF 17      mov d, s_months
0646   030C 59            add d, a
0647   030D 07 CA 11      call _puts
0648   0310 10 00 20      mov a, $2000
0649   0313 05 03         syscall sys_io         ; display ' '
0650   0315 2E 20         mov bl, $20
0651   0317 07 6A 12      call print_u8x         ; print 20 for year prefix
0652   031A 19 06         mov al, 06
0653   031C 05 01         syscall sys_rtc        ; get year
0654   031E 99            mov bl, ah
0655   031F 07 6A 12      call print_u8x
0656   0322 10 00 20      mov a, $2000  
0657   0325 05 03         syscall sys_io         ; display ' '
0658   0327 19 02         mov al, 2
0659   0329 05 01         syscall sys_rtc        ; get hours
0660   032B 99            mov bl, ah
0661   032C 07 6A 12      call print_u8x
0662   032F 10 00 3A      mov a, $3A00    
0663   0332 05 03         syscall sys_io         ; display ':'
0664   0334 19 01         mov al, 01
0665   0336 05 01         syscall sys_rtc        ; get minutes
0666   0338 99            mov bl, ah
0667   0339 07 6A 12      call print_u8x
0668   033C 10 00 3A      mov a, $3A00  
0669   033F 05 03         syscall sys_io         ; display ':'
0670   0341 19 00         mov al, 0
0671   0343 05 01         syscall sys_rtc        ; get seconds
0672   0345 99            mov bl, ah
0673   0346 07 6A 12      call print_u8x
0674   0349 07 77 11      call printnl
0675   034C 06            sysret
0676   034D             set_date:
0677   034D 3B A4 17      mov d, s_set_year
0678   0350 07 CA 11      call _puts
0679   0353 07 B5 12      call scan_u8x          ; read integer into A
0680   0356 FD 9D 08      shl a, 8               ; only AL used, move to AH
0681   0359 19 0D         mov al, 0Dh            ; set RTC year
0682   035B 05 01         syscall sys_rtc        ; set RTC
0683   035D 3B AB 17      mov d, s_set_month
0684   0360 07 CA 11      call _puts
0685   0363 07 B5 12      call scan_u8x          ; read integer into A
0686   0366 FD 9D 08      shl a, 8               ; only AL used, move to AH
0687   0369 19 0C         mov al, 0Ch            ; set RTC month
0688   036B 05 01         syscall sys_rtc        ; set RTC
0689   036D 3B B3 17      mov d, s_set_day
0690   0370 07 CA 11      call _puts
0691   0373 07 B5 12      call scan_u8x          ; read integer into A
0692   0376 FD 9D 08      shl a, 8               ; only AL used, move to AH
0693   0379 19 0B         mov al, 0Bh            ; set RTC month
0694   037B 05 01         syscall sys_rtc        ; set RTC
0695   037D 3B B9 17      mov d, s_set_week
0696   0380 07 CA 11      call _puts
0697   0383 07 B5 12      call scan_u8x          ; read integer into A
0698   0386 FD 9D 08      shl a, 8               ; only AL used, move to AH
0699   0389 19 0A         mov al, 0Ah            ; set RTC month
0700   038B 05 01         syscall sys_rtc        ; set RTC
0701   038D 3B C3 17      mov d, s_set_hours
0702   0390 07 CA 11      call _puts
0703   0393 07 B5 12      call scan_u8x          ; read integer into A
0704   0396 FD 9D 08      shl a, 8               ; only AL used, move to AH
0705   0399 19 09         mov al, 09h            ; set RTC month
0706   039B 05 01         syscall sys_rtc        ; set RTC
0707   039D 3B CB 17      mov d, s_set_minutes
0708   03A0 07 CA 11      call _puts
0709   03A3 07 B5 12      call scan_u8x          ; read integer into A
0710   03A6 FD 9D 08      shl a, 8               ; only AL used, move to AH
0711   03A9 19 08         mov al, 08h            ; set RTC month
0712   03AB 05 01         syscall sys_rtc        ; set RTC
0713   03AD 3B D5 17      mov d, s_set_seconds
0714   03B0 07 CA 11      call _puts
0715   03B3 07 B5 12      call scan_u8x          ; read integer into A
0716   03B6 FD 9D 08      shl a, 8               ; only AL used, move to AH
0717   03B9 19 07         mov al, 07h            ; set RTC month
0718   03BB 05 01         syscall sys_rtc        ; set RTC
0719   03BD 06            sysret
0720   03BE             
0721   03BE             ; ------------------------------------------------------------------------------------------------------------------;
0722   03BE             ; IDE Services Syscall
0723   03BE             ; al = option
0724   03BE             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0725   03BE             ; IDE read/write sector
0726   03BE             ; 512 bytes
0727   03BE             ; User buffer pointer in D
0728   03BE             ; AH = number of sectors
0729   03BE             ; CB = LBA bytes 3..0
0730   03BE             ; ------------------------------------------------------------------------------------------------------------------;
0731   03BE 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0731   03C2 73 63 61 6C 
0731   03C6 6C 5F 69 64 
0731   03CA 65 20 63 61 
0731   03CE 6C 6C 65 64 
0731   03D2 3A 20 00 
0732   03D5             ide_serv_tbl:
0733   03D5 FC 03         .dw ide_reset
0734   03D7 10 04         .dw ide_sleep
0735   03D9 1F 04         .dw ide_read_sect_wrapper
0736   03DB 23 04         .dw ide_write_sect_wrapper
0737   03DD             syscall_ide:
0738   03DD DD            push bl
0739   03DE 31 F3 16      mov bl, [sys_debug_mode]
0740   03E1               ; debug block
0741   03E1 C1 00         cmp bl, 0
0742   03E3 EA            pop bl
0743   03E4 C6 F8 03      je syscall_ide_jmp
0744   03E7 DA            push d
0745   03E8 DD            push bl
0746   03E9 3B BE 03      mov d, s_syscall_ide_dbg0
0747   03EC 07 CA 11      call _puts
0748   03EF 2F            mov bl, al
0749   03F0 07 6A 12      call print_u8x
0750   03F3 07 77 11      call printnl
0751   03F6 EA            pop bl
0752   03F7 E7            pop d
0753   03F8             syscall_ide_jmp:
0754   03F8 FD 0A D5 03   jmp [ide_serv_tbl + al]    
0755   03FC               
0756   03FC             ide_reset:      
0757   03FC F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0758   0400 07 A9 04      call ide_wait                   ; wait for IDE ready             
0759   0403 F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0760   0407 F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0761   040B F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0762   040F 06            sysret
0763   0410             ide_sleep:
0764   0410 07 A9 04      call ide_wait                   ; wait for IDE ready             
0765   0413 F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0766   0417 F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0767   041B 07 A9 04      call ide_wait                   ; wait for IDE ready
0768   041E 06            sysret
0769   041F             ide_read_sect_wrapper:
0770   041F 07 27 04      call ide_read_sect
0771   0422 06            sysret
0772   0423             ide_write_sect_wrapper:
0773   0423 07 4D 04      call ide_write_sect
0774   0426 06            sysret
0775   0427             ide_read_sect:
0776   0427 1A            mov al, ah
0777   0428 24            mov ah, bl
0778   0429 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0779   042C 1C            mov al, bh
0780   042D 3D D4 FF      mov [_ide_R4], al
0781   0430 12            mov a, c
0782   0431 3D D5 FF      mov [_ide_R5], al
0783   0434 1A            mov al, ah
0784   0435 87 0F         and al, %00001111
0785   0437 8B E0         or al, %11100000                ; mode lba, master
0786   0439 3D D6 FF      mov [_ide_R6], al
0787   043C             ide_read_sect_wait:
0788   043C 1D D7 FF      mov al, [_ide_R7]  
0789   043F 87 80         and al, $80                     ; BUSY FLAG
0790   0441 C7 3C 04      jnz ide_read_sect_wait
0791   0444 19 20         mov al, $20
0792   0446 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0793   0449 07 73 04      call ide_read  
0794   044C 09            ret
0795   044D             ide_write_sect:
0796   044D 1A            mov al, ah
0797   044E 24            mov ah, bl
0798   044F 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0799   0452 1C            mov al, bh
0800   0453 3D D4 FF      mov [_ide_R4], al
0801   0456 12            mov a, c
0802   0457 3D D5 FF      mov [_ide_R5], al
0803   045A 1A            mov al, ah
0804   045B 87 0F         and al, %00001111
0805   045D 8B E0         or al, %11100000                ; mode lba, master
0806   045F 3D D6 FF      mov [_ide_R6], al
0807   0462             ide_write_sect_wait:
0808   0462 1D D7 FF      mov al, [_ide_R7]  
0809   0465 87 80         and al, $80                     ; BUSY FLAG
0810   0467 C7 62 04      jnz ide_write_sect_wait
0811   046A 19 30         mov al, $30
0812   046C 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0813   046F 07 8E 04      call ide_write      
0814   0472 09            ret
0815   0473             
0816   0473             ;----------------------------------------------------------------------------------------------------;
0817   0473             ; READ IDE DATA
0818   0473             ; pointer in D
0819   0473             ;----------------------------------------------------------------------------------------------------;
0820   0473             ide_read:
0821   0473 DA            push d
0822   0474             ide_read_loop:
0823   0474 1D D7 FF      mov al, [_ide_R7]  
0824   0477 87 80         and al, 80h                     ; BUSY FLAG
0825   0479 C7 74 04      jnz ide_read_loop               ; wait loop
0826   047C 1D D7 FF      mov al, [_ide_R7]
0827   047F 87 08         and al, %00001000               ; DRQ FLAG
0828   0481 C6 8C 04      jz ide_read_end
0829   0484 1D D0 FF      mov al, [_ide_R0]
0830   0487 3E            mov [d], al
0831   0488 79            inc d
0832   0489 0A 74 04      jmp ide_read_loop
0833   048C             ide_read_end:
0834   048C E7            pop d
0835   048D 09            ret
0836   048E             
0837   048E             ;----------------------------------------------------------------------------------------------------;
0838   048E             ; WRITE IDE DATA
0839   048E             ; data pointer in D
0840   048E             ;----------------------------------------------------------------------------------------------------;
0841   048E             ide_write:
0842   048E DA            push d
0843   048F             ide_write_loop:
0844   048F 1D D7 FF      mov al, [_ide_R7]  
0845   0492 87 80         and al, 80h             ; BUSY FLAG
0846   0494 C7 8F 04      jnz ide_write_loop      ; wait loop
0847   0497 1D D7 FF      mov al, [_ide_R7]
0848   049A 87 08         and al, %00001000       ; DRQ FLAG
0849   049C C6 A7 04      jz ide_write_end
0850   049F 1E            mov al, [d]
0851   04A0 3D D0 FF      mov [_ide_R0], al
0852   04A3 79            inc d 
0853   04A4 0A 8F 04      jmp ide_write_loop
0854   04A7             ide_write_end:
0855   04A7 E7            pop d
0856   04A8 09            ret
0857   04A9             
0858   04A9             ;----------------------------------------------------------------------------------------------------;
0859   04A9             ; wait for IDE to be ready
0860   04A9             ;----------------------------------------------------------------------------------------------------;
0861   04A9             ide_wait:
0862   04A9 1D D7 FF      mov al, [_ide_R7]  
0863   04AC 87 80         and al, 80h        ; BUSY FLAG
0864   04AE C7 A9 04      jnz ide_wait
0865   04B1 09            ret
0866   04B2             
0867   04B2             ;----------------------------------------------------------------------------------------------------;
0868   04B2             ; IO Syscall
0869   04B2             ;----------------------------------------------------------------------------------------------------;
0870   04B2             ; Baud  Divisor
0871   04B2             ; 50    2304
0872   04B2             ; 110   1047
0873   04B2             ; 300    384
0874   04B2             ; 600    192
0875   04B2             ; 1200    96
0876   04B2             ; 9600    12
0877   04B2             ; 19200    6
0878   04B2             ; 38400    3
0879   04B2             syscall_io_jmp:
0880   04B2 E5 04         .dw syscall_io_putchar
0881   04B4 F2 04         .dw syscall_io_getch
0882   04B6 BC 04         .dw syscall_io_uart_setup
0883   04B8             syscall_io:
0884   04B8 FD 0A B2 04   jmp [syscall_io_jmp + al]
0885   04BC             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0886   04BC             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0887   04BC             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0888   04BC             syscall_io_uart_setup:
0889   04BC 1D F5 16      mov al, [sys_uart0_lcr]
0890   04BF 8B 80         or al, $80                ; set DLAB access bit
0891   04C1 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0892   04C4 1D F8 16      mov al, [sys_uart0_div0]
0893   04C7 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0894   04CA 1D F9 16      mov al, [sys_uart0_div1]
0895   04CD 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0896   04D0             
0897   04D0 1D F5 16      mov al, [sys_uart0_lcr]
0898   04D3 87 7F         and al, $7F               ; clear DLAB access bit 
0899   04D5 3D 83 FF      mov [_UART0_LCR], al
0900   04D8 1D F6 16      mov al, [sys_uart0_inten]
0901   04DB 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0902   04DE 1D F7 16      mov al, [sys_uart0_fifoen]
0903   04E1 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0904   04E4 06            sysret
0905   04E5             
0906   04E5             ; char in ah
0907   04E5             syscall_io_putchar:
0908   04E5             syscall_io_putchar_L0:
0909   04E5 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0910   04E8 87 20         and al, $20
0911   04EA C6 E5 04      jz syscall_io_putchar_L0    
0912   04ED 1A            mov al, ah
0913   04EE 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0914   04F1 06            sysret
0915   04F2             
0916   04F2             ; char in ah
0917   04F2             ; al = sucess code
0918   04F2             syscall_io_getch:
0919   04F2 D8            push b
0920   04F3 DA            push d
0921   04F4 FD 0C         sti
0922   04F6             syscall_io_getch_L0:  
0923   04F6 14 02 17      mov a, [fifo_out]
0924   04F9 29 00 17      mov b, [fifo_in]
0925   04FC B0            cmp a, b
0926   04FD C6 F6 04      je syscall_io_getch_L0
0927   0500 3C            mov d, a
0928   0501 77            inc a
0929   0502 AF FF 21      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
0930   0505 C7 0B 05      jne syscall_io_getch_cont
0931   0508 10 FF 1D      mov a, fifo  
0932   050B             syscall_io_getch_cont:  
0933   050B 42 02 17      mov [fifo_out], a             ; update fifo pointer
0934   050E 1E            mov al, [d]                   ; get char
0935   050F 23            mov ah, al
0936   0510 1D F4 16      mov al, [sys_echo_on]
0937   0513 B9 01         cmp al, 1
0938   0515 C7 24 05      jne syscall_io_getch_noecho 
0939   0518             ; here we just echo the char back to the console
0940   0518             syscall_io_getch_echo_L0:
0941   0518 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0942   051B 87 20         and al, $20                 ; isolate Transmitter Empty
0943   051D C6 18 05      jz syscall_io_getch_echo_L0
0944   0520 1A            mov al, ah
0945   0521 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0946   0524             syscall_io_getch_noecho:
0947   0524 19 01         mov al, 1                    ; AL = 1 means a char successfully received
0948   0526 E7            pop d
0949   0527 E5            pop b
0950   0528 06            sysret
0951   0529             
0952   0529             ;------------------------------------------------------------------------------------------------------;
0953   0529             ; FILE SYSTEM DATA
0954   0529             ;------------------------------------------------------------------------------------------------------;
0955   0529             ; infor for : IDE SERVICES INTERRUPT
0956   0529             ; IDE read/write 512-byte sector
0957   0529             ; al = option
0958   0529             ; user buffer pointer in D
0959   0529             ; AH = number of sectors
0960   0529             ; CB = LBA bytes 3..0  
0961   0529             ;------------------------------------------------------------------------------------------------------;
0962   0529             ; FILE SYSTEM DATA STRUCTURE
0963   0529             ;------------------------------------------------------------------------------------------------------;
0964   0529             ; for a directory we have the header first, followed by metadata
0965   0529             ; header 1 sector (512 bytes)
0966   0529             ; metadata 1 sector (512 bytes)
0967   0529             ; HEADER ENTRIES:
0968   0529             ; filename (64)
0969   0529             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0970   0529             ;
0971   0529             ; metadata entries:
0972   0529             ; filename (24)
0973   0529             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
0974   0529             ; LBA (2)
0975   0529             ; size (2)
0976   0529             ; day (1)
0977   0529             ; month (1)
0978   0529             ; year (1)
0979   0529             ; packet size = 32 bytes
0980   0529             ;
0981   0529             ; first directory on disk is the root directory '/'
0982   0529             file_system_jmptbl:
0983   0529 94 05         .dw fs_mkfs                   ; 0
0984   052B 00 00         .dw 0                         ; 1
0985   052D F6 05         .dw fs_mkdir                  ; 2
0986   052F 6F 09         .dw fs_cd                     ; 3
0987   0531 76 09         .dw fs_ls                     ; 4
0988   0533 EC 0A         .dw fs_mktxt                  ; 5
0989   0535 B7 0B         .dw fs_mkbin                  ; 6
0990   0537 7E 0C         .dw fs_pwd                    ; 7
0991   0539 9B 0C         .dw fs_cat                    ; 8
0992   053B F7 0C         .dw fs_rmdir                  ; 9
0993   053D 53 0D         .dw fs_rm                     ; 10
0994   053F 47 0A         .dw fs_starcom                ; 11
0995   0541 00 00         .dw 0                         ; 12
0996   0543 00 00         .dw 0                         ; 13
0997   0545 9C 05         .dw fs_chmod                  ; 14
0998   0547 BB 0D         .dw fs_mv                     ; 15
0999   0549 95 05         .dw fs_cd_root                ; 16
1000   054B 6B 09         .dw fs_get_curr_dirID         ; 17
1001   054D 47 07         .dw fs_dir_id_to_path         ; 18
1002   054F AD 07         .dw fs_path_to_dir_id_user    ; 19
1003   0551 C7 08         .dw fs_load_from_path_user    ; 20  
1004   0553 37 08         .dw fs_filepath_exists_user   ; 21
1005   0555             
1006   0555 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1006   0559 79 73 63 61 
1006   055D 6C 6C 5F 66 
1006   0561 69 6C 65 5F 
1006   0565 73 79 73 74 
1006   0569 65 6D 20 63 
1006   056D 61 6C 6C 65 
1006   0571 64 3A 20 00 
1007   0575             syscall_file_system:
1008   0575 DD            push bl
1009   0576 31 F3 16      mov bl, [sys_debug_mode]
1010   0579               ; debug block
1011   0579 C1 00         cmp bl, 0
1012   057B EA            pop bl
1013   057C C6 90 05      je syscall_filesystem_jmp
1014   057F DA            push d
1015   0580 DD            push bl
1016   0581 3B 55 05      mov d, s_syscall_fs_dbg0
1017   0584 07 CA 11      call _puts
1018   0587 2F            mov bl, al
1019   0588 07 6A 12      call print_u8x
1020   058B 07 77 11      call printnl
1021   058E EA            pop bl
1022   058F E7            pop d
1023   0590             syscall_filesystem_jmp:
1024   0590 FD 0A 29 05   jmp [file_system_jmptbl + al]
1025   0594             
1026   0594             fs_mkfs:  
1027   0594 06            sysret  
1028   0595               
1029   0595             fs_cd_root:
1030   0595 10 20 00      mov a, root_id
1031   0598 42 04 17      mov [current_dir_id], a      ; set current directory LBA to ROOT
1032   059B 06            sysret  
1033   059C             
1034   059C             ; filename in D (userspace data)
1035   059C             ; permission in BL
1036   059C             fs_chmod:
1037   059C DD            push bl
1038   059D FD 4E         mov si, d
1039   059F FD 4F FF 1B   mov di, user_data
1040   05A3 38 80 00      mov c, 128
1041   05A6 04            load                        ; load filename from user-space
1042   05A7 14 04 17      mov a, [current_dir_id]
1043   05AA 77            inc a                       ; metadata sector
1044   05AB 27            mov b, a
1045   05AC 38 00 00      mov c, 0                    ; upper LBA = 0
1046   05AF 22 01         mov ah, $01                  ; 1 sector
1047   05B1 3B FF 23      mov d, transient_area
1048   05B4 07 27 04      call ide_read_sect          ; read directory
1049   05B7 FD 10         cla
1050   05B9 42 FC 16      mov [index], a              ; reset file counter
1051   05BC             fs_chmod_L1:
1052   05BC FD 4E         mov si, d
1053   05BE FD 4F FF 1B   mov di, user_data
1054   05C2 07 0D 10      call _strcmp
1055   05C5 C6 DC 05      je fs_chmod_found_entry
1056   05C8 58 20 00      add d, 32
1057   05CB 14 FC 16      mov a, [index]
1058   05CE 77            inc a
1059   05CF 42 FC 16      mov [index], a
1060   05D2 AF 10 00      cmp a, FST_FILES_PER_DIR
1061   05D5 C7 BC 05      jne fs_chmod_L1
1062   05D8 EA            pop bl
1063   05D9 0A F5 05      jmp fs_chmod_not_found
1064   05DC             fs_chmod_found_entry:  
1065   05DC FD 79         mov g, b                    ; save LBA
1066   05DE EA            pop bl                      ; retrieve saved permission value
1067   05DF 1F 18 00      mov al, [d + 24]            ; read file permissions
1068   05E2 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1069   05E4 8C            or al, bl                   ; set new permissions
1070   05E5 3F 18 00      mov [d + 24], al            ; write new permissions
1071   05E8 38 00 00      mov c, 0
1072   05EB 3B FF 23      mov d, transient_area
1073   05EE 22 01         mov ah, $01                 ; disk write 1 sect
1074   05F0 FD 27         mov b, g                    ; retrieve LBA
1075   05F2 07 4D 04      call ide_write_sect         ; write sector
1076   05F5             fs_chmod_not_found:
1077   05F5 06            sysret
1078   05F6             
1079   05F6             ;------------------------------------------------------------------------------------------------------;
1080   05F6             ; CREATE NEW DIRECTORY
1081   05F6             ;------------------------------------------------------------------------------------------------------;
1082   05F6             ; search list for NULL name entry. add new directory to list
1083   05F6             fs_mkdir:
1084   05F6 FD 4E         mov si, d
1085   05F8 FD 4F FF 1B   mov di, user_data
1086   05FC 38 00 02      mov c, 512
1087   05FF 04            load                        ; load data from user-space
1088   0600 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1089   0603                                           ; when checking for NULL name, since root has a NULL name)
1090   0603 38 00 00      mov c, 0                    ; upper LBA = 0
1091   0606             fs_mkdir_L1:  
1092   0606 22 01         mov ah, $01                  ; 1 sector
1093   0608 3B FF 23      mov d, transient_area
1094   060B 07 27 04      call ide_read_sect          ; read sector
1095   060E BD 00         cmp byte[d], 0              ; check for NULL
1096   0610 C6 19 06      je fs_mkdir_found_null
1097   0613 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1098   0616 0A 06 06      jmp fs_mkdir_L1
1099   0619             fs_mkdir_found_null:
1100   0619             ;create header file by grabbing dir name from parameter
1101   0619 D8            push b                      ; save new directory's LBA
1102   061A 38 40 00      mov c, 64
1103   061D FD 4D FF 1B   mov si, user_data
1104   0621 FD 4F FF 23   mov di, transient_area
1105   0625 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1106   0627 14 04 17      mov a, [current_dir_id]
1107   062A 42 3F 24      mov [transient_area + 64], a    ; store parent directory LBA
1108   062D 19 00         mov al, 0
1109   062F FD 4F FF 25   mov di, transient_area + 512
1110   0633 38 00 02      mov c, 512
1111   0636 FD F7         rep stosb                       ; clean buffer
1112   0638 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1113   063B             ; write directory entry sectors
1114   063B 3B FF 23      mov d, transient_area
1115   063E 22 02         mov ah, $02                     ; disk write, 2 sectors
1116   0640 07 4D 04      call ide_write_sect             ; write sector
1117   0643             ; now we need to add the new directory to the list, insIDE the current directory
1118   0643 14 04 17      mov a, [current_dir_id]
1119   0646 53 01 00      add a, 1
1120   0649 27            mov b, a                        ; metadata sector
1121   064A 38 00 00      mov c, 0
1122   064D FD 79         mov g, b                        ; save LBA
1123   064F 3B FF 23      mov d, transient_area
1124   0652 22 01         mov ah, $01                  ; 1 sector
1125   0654 07 27 04      call ide_read_sect              ; read metadata sector
1126   0657             fs_mkdir_L2:
1127   0657 BD 00         cmp byte[d], 0
1128   0659 C6 62 06      je fs_mkdir_found_null2
1129   065C 58 20 00      add d, FST_ENTRY_SIZE
1130   065F 0A 57 06      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1131   0662             fs_mkdir_found_null2:
1132   0662 FD 4D FF 1B   mov si, user_data
1133   0666 FD 50         mov di, d
1134   0668 07 22 10      call _strcpy                    ; copy directory name
1135   066B 58 18 00      add d, 24                       ; goto ATTRIBUTES
1136   066E 19 0B         mov al, %00001011               ; directory, no execute, write, read
1137   0670 3E            mov [d], al      
1138   0671 79            inc d
1139   0672 E5            pop b
1140   0673 D8            push b                          ; push LBA back
1141   0674 FD 43         mov [d], b                      ; save LBA
1142   0676             ; set file creation date  
1143   0676 58 04 00      add d, 4
1144   0679 19 04         mov al, 4
1145   067B 05 01         syscall sys_rtc
1146   067D 1A            mov al, ah
1147   067E 3E            mov [d], al                     ; set day
1148   067F 79            inc d
1149   0680 19 05         mov al, 5
1150   0682 05 01         syscall sys_rtc
1151   0684 1A            mov al, ah
1152   0685 3E            mov [d], al                     ; set month
1153   0686 79            inc d
1154   0687 19 06         mov al, 6
1155   0689 05 01         syscall sys_rtc
1156   068B 1A            mov al, ah
1157   068C 3E            mov [d], al                     ; set year
1158   068D             ; write sector into disk for new directory entry
1159   068D FD 27         mov b, g
1160   068F 38 00 00      mov c, 0
1161   0692 3B FF 23      mov d, transient_area
1162   0695 22 01         mov ah, $01                     ; disk write, 1 sector
1163   0697 07 4D 04      call ide_write_sect             ; write sector
1164   069A             
1165   069A             ; after adding the new directory's information to its parent directory's list
1166   069A             ; we need to now enter the new directory, and to it add two new directories!
1167   069A             ; which directories do we need to add ? '..' and '.' are the directories needed.
1168   069A             ; importantly, note that these two new directories are only entries in the list
1169   069A             ; and do not have actual physical entries in the disk as real directories.
1170   069A             ; i.e. they only exist as list entries in the new directory created so that
1171   069A             ; the new directory can reference its parent and itself.
1172   069A             ; We need to add both '..' and '.'
1173   069A             ; this first section is for '..' and on the section below we do the same for '.'
1174   069A E4            pop a                         ; retrieve the new directory's LBA  
1175   069B D7            push a                        ; and save again
1176   069C 53 01 00      add a, 1
1177   069F 27            mov b, a                      ; metadata sector
1178   06A0 38 00 00      mov c, 0
1179   06A3 FD 79         mov g, b                      ; save LBA
1180   06A5 3B FF 23      mov d, transient_area
1181   06A8 22 01         mov ah, $01                  ; 1 sector
1182   06AA 07 27 04      call ide_read_sect            ; read metadata sector
1183   06AD             fs_mkdir_L3:
1184   06AD BD 00         cmp byte[d], 0
1185   06AF C6 B8 06      je fs_mkdir_found_null3
1186   06B2 58 20 00      add d, FST_ENTRY_SIZE
1187   06B5 0A AD 06      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1188   06B8             fs_mkdir_found_null3:
1189   06B8 FD 4D 14 17   mov si, s_parent_dir
1190   06BC FD 50         mov di, d
1191   06BE 07 22 10      call _strcpy                  ; copy directory name
1192   06C1 58 18 00      add d, 24                     ; goto ATTRIBUTES
1193   06C4 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1194   06C6 3E            mov [d], al      
1195   06C7 79            inc d
1196   06C8 29 04 17      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1197   06CB FD 43         mov [d], b                    ; save LBA
1198   06CD             ; set file creation date  
1199   06CD 58 04 00      add d, 4
1200   06D0 19 04         mov al, 4
1201   06D2 05 01         syscall sys_rtc
1202   06D4 1A            mov al, ah
1203   06D5 3E            mov [d], al                   ; set day
1204   06D6 79            inc d
1205   06D7 19 05         mov al, 5
1206   06D9 05 01         syscall sys_rtc
1207   06DB 1A            mov al, ah
1208   06DC 3E            mov [d], al                   ; set month
1209   06DD 79            inc d
1210   06DE 19 06         mov al, 6
1211   06E0 05 01         syscall sys_rtc
1212   06E2 1A            mov al, ah
1213   06E3 3E            mov [d], al                   ; set year
1214   06E4             ; write sector into disk for new directory entry
1215   06E4 FD 27         mov b, g
1216   06E6 38 00 00      mov c, 0
1217   06E9 3B FF 23      mov d, transient_area
1218   06EC 22 01         mov ah, $01                   ; disk write, 1 sector
1219   06EE 07 4D 04      call ide_write_sect           ; write sector
1220   06F1             ;;;;;;;;;;;;;
1221   06F1             ; like we did above for '..', we need to now add the '.' directory to the list.
1222   06F1             ;------------------------------------------------------------------------------------------------------;
1223   06F1 E4            pop a                         ; retrieve the new directory's LBA  
1224   06F2 D7            push a
1225   06F3 53 01 00      add a, 1
1226   06F6 27            mov b, a                      ; metadata sector
1227   06F7 38 00 00      mov c, 0
1228   06FA FD 79         mov g, b                      ; save LBA
1229   06FC 3B FF 23      mov d, transient_area
1230   06FF 22 01         mov ah, $01                  ; 1 sector
1231   0701 07 27 04      call ide_read_sect            ; read metadata sector
1232   0704             fs_mkdir_L4:
1233   0704 BD 00         cmp byte[d], 0
1234   0706 C6 0F 07      je fs_mkdir_found_null4
1235   0709 58 20 00      add d, FST_ENTRY_SIZE
1236   070C 0A 04 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1237   070F             fs_mkdir_found_null4:
1238   070F FD 4D 17 17   mov si, s_current_dir
1239   0713 FD 50         mov di, d
1240   0715 07 22 10      call _strcpy                  ; copy directory name
1241   0718 58 18 00      add d, 24                     ; goto ATTRIBUTES
1242   071B 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1243   071D 3E            mov [d], al      
1244   071E 79            inc d
1245   071F E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1246   0720 FD 43         mov [d], b                    ; save LBA
1247   0722             ; set file creation date  
1248   0722 58 04 00      add d, 4
1249   0725 19 04         mov al, 4
1250   0727 05 01         syscall sys_rtc
1251   0729 1A            mov al, ah
1252   072A 3E            mov [d], al                   ; set day
1253   072B 79            inc d
1254   072C 19 05         mov al, 5
1255   072E 05 01         syscall sys_rtc
1256   0730 1A            mov al, ah
1257   0731 3E            mov [d], al                   ; set month
1258   0732 79            inc d
1259   0733 19 06         mov al, 6
1260   0735 05 01         syscall sys_rtc
1261   0737 1A            mov al, ah
1262   0738 3E            mov [d], al                   ; set year
1263   0739             ; write sector into disk for new directory entry
1264   0739 FD 27         mov b, g
1265   073B 38 00 00      mov c, 0
1266   073E 3B FF 23      mov d, transient_area
1267   0741 22 01         mov ah, $01                   ; disk write, 1 sector
1268   0743 07 4D 04      call ide_write_sect           ; write sector
1269   0746             fs_mkdir_end:
1270   0746 06            sysret
1271   0747             
1272   0747             ;------------------------------------------------------------------------------------------------------;
1273   0747             ; get path from a given directory dirID
1274   0747             ; pseudo code:
1275   0747             ;  fs_dir_id_to_path(int dirID, char *D){
1276   0747             ;    if(dirID == 0){
1277   0747             ;      reverse path in D;
1278   0747             ;      return;
1279   0747             ;    }
1280   0747             ;    else{
1281   0747             ;      copy directory name to end of D;
1282   0747             ;      add '/' to end of D;
1283   0747             ;      parentID = get parent directory ID;
1284   0747             ;      fs_dir_id_to_path(parentID, D);
1285   0747             ;    }
1286   0747             ;  }
1287   0747             ; A = dirID
1288   0747             ; D = generated path string pointer
1289   0747             ;------------------------------------------------------------------------------------------------------;
1290   0747             ; sample path: /usr/bin
1291   0747             fs_dir_id_to_path:
1292   0747 3B 7F 1B      mov d, filename
1293   074A 19 00         mov al, 0
1294   074C 3E            mov [d], al                     ; initialize path string 
1295   074D 14 04 17      mov a, [current_dir_id]
1296   0750 07 5D 07      call fs_dir_id_to_path_E0
1297   0753 3B 7F 1B      mov d, filename
1298   0756 07 B6 0F      call _strrev
1299   0759 07 CA 11      call _puts
1300   075C 06            sysret
1301   075D             fs_dir_id_to_path_E0:
1302   075D 07 7C 07      call get_dirname_from_dirID
1303   0760 FD 4D 19 17   mov si, s_fslash
1304   0764 FD 50         mov di, d
1305   0766 07 30 10      call _strcat                    ; add '/' to end of path
1306   0769 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1307   076C C6 7B 07      je fs_dir_id_to_path_root
1308   076F 07 99 07      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1309   0772 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1310   0775 C6 7B 07      je fs_dir_id_to_path_root
1311   0778 07 5D 07      call fs_dir_id_to_path_E0     ; recursively call itself
1312   077B             fs_dir_id_to_path_root:
1313   077B 09            ret
1314   077C             
1315   077C             ;------------------------------------------------------------------------------------------------------;
1316   077C             ; in_puts:
1317   077C             ; A = directory ID
1318   077C             ; out_puts:
1319   077C             ; D = pointer to directory name string
1320   077C             ;------------------------------------------------------------------------------------------------------;
1321   077C             get_dirname_from_dirID:
1322   077C D7            push a
1323   077D D8            push b
1324   077E DA            push d
1325   077F 27            mov b, a
1326   0780 38 00 00      mov c, 0                      ; upper LBA = 0
1327   0783 22 01         mov ah, $01                  ; 1 sector
1328   0785 3B FF 21      mov d, transient_area - 512
1329   0788 07 27 04      call ide_read_sect            ; read directory
1330   078B 07 B6 0F      call _strrev                  ; reverse dir name before copying
1331   078E FD 4E         mov si, d
1332   0790 E7            pop d                         ; destination address = D value pushed at beginning
1333   0791 FD 50         mov di, d
1334   0793 07 30 10      call _strcat                  ; copy filename to D
1335   0796 E5            pop b
1336   0797 E4            pop a
1337   0798 09            ret
1338   0799             
1339   0799             ;------------------------------------------------------------------------------------------------------;
1340   0799             ; in_puts:
1341   0799             ; A = directory ID
1342   0799             ; out_puts:
1343   0799             ; A = parent directory ID
1344   0799             ;------------------------------------------------------------------------------------------------------;
1345   0799             get_parentID_from_dirID:
1346   0799 D8            push b
1347   079A DA            push d
1348   079B 27            mov b, a
1349   079C 38 00 00      mov c, 0                      ; upper LBA = 0
1350   079F 22 01         mov ah, $01                  ; 1 sector
1351   07A1 3B FF 21      mov d, transient_area - 512
1352   07A4 07 27 04      call ide_read_sect            ; read directory
1353   07A7 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1354   07AA E7            pop d
1355   07AB E5            pop b
1356   07AC 09            ret
1357   07AD             
1358   07AD             ;------------------------------------------------------------------------------------------------------;
1359   07AD             ; get dirID from a given path string
1360   07AD             ; in_puts:
1361   07AD             ; D = path pointer 
1362   07AD             ; out_puts:
1363   07AD             ; A = dirID
1364   07AD             ; if dir non existent, A = FFFF (fail code)
1365   07AD             ; /usr/local/bin    - absolute
1366   07AD             ; local/bin/games    - relative
1367   07AD             ;------------------------------------------------------------------------------------------------------;
1368   07AD             fs_path_to_dir_id_user:
1369   07AD FD 4E         mov si, d
1370   07AF FD 4F FF 1B   mov di, user_data
1371   07B3 38 00 02      mov c, 512
1372   07B6 04            load
1373   07B7 07 BB 07      call get_dirID_from_path
1374   07BA 06            sysret
1375   07BB             get_dirID_from_path:
1376   07BB 26 FF 1B      mov b, user_data
1377   07BE FD 42 EF 15   mov [prog], b                  ; token pointer set to path string
1378   07C2 07 50 14      call get_token
1379   07C5 31 F2 15      mov bl, [tok]
1380   07C8 C1 01         cmp bl, TOK_FSLASH
1381   07CA C6 D6 07      je get_dirID_from_path_abs 
1382   07CD 14 04 17      mov a, [current_dir_id]
1383   07D0 07 D6 15      call _putback
1384   07D3 0A D9 07      jmp get_dirID_from_path_E0
1385   07D6             get_dirID_from_path_abs:
1386   07D6 10 20 00      mov a, root_id
1387   07D9             get_dirID_from_path_E0:
1388   07D9 07 50 14      call get_token
1389   07DC 31 F1 15      mov bl, [toktyp]
1390   07DF C1 00         cmp bl, TOKTYP_IDENTIFIER
1391   07E1 C7 32 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1392   07E4             
1393   07E4 FD 4D F3 15   mov si, tokstr
1394   07E8 FD 4F 7F 1B   mov di, filename
1395   07EC 07 22 10      call _strcpy        
1396   07EF 77            inc a                         ; metadata sector
1397   07F0 27            mov b, a
1398   07F1 38 00 00      mov c, 0                      ; upper LBA = 0
1399   07F4 22 01         mov ah, $01                  ; 1 sector
1400   07F6 3B FF 23      mov d, transient_area
1401   07F9 07 27 04      call ide_read_sect            ; read directory
1402   07FC FD 10         cla
1403   07FE 42 FC 16      mov [index], a
1404   0801             get_dirID_from_path_L1:
1405   0801 FD 4E         mov si, d
1406   0803 FD 4F 7F 1B   mov di, filename
1407   0807 07 0D 10      call _strcmp
1408   080A C6 20 08      je get_dirID_from_path_name_equal  
1409   080D 58 20 00      add d, 32
1410   0810 14 FC 16      mov a, [index]
1411   0813 77            inc a
1412   0814 42 FC 16      mov [index], a
1413   0817 AF 10 00      cmp a, FST_FILES_PER_DIR
1414   081A C6 33 08      je get_dirID_from_path_fail
1415   081D 0A 01 08      jmp get_dirID_from_path_L1
1416   0820             get_dirID_from_path_name_equal:
1417   0820 58 19 00      add d, 25           
1418   0823 15            mov a, [d]                    ; set result register A = dirID
1419   0824 07 50 14      call get_token
1420   0827 31 F2 15      mov bl, [tok]
1421   082A C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1422   082C C6 D9 07      je get_dirID_from_path_E0
1423   082F 07 D6 15      call _putback
1424   0832             get_dirID_from_path_end:
1425   0832 09            ret
1426   0833             get_dirID_from_path_fail:
1427   0833 10 FF FF      mov A, $FFFF
1428   0836 09            ret
1429   0837             
1430   0837             
1431   0837             ;------------------------------------------------------------------------------------------------------;
1432   0837             ; check if file exists by a given path string
1433   0837             ; in_puts:
1434   0837             ; D = path pointer 
1435   0837             ; OUTPUTS:
1436   0837             ; A = success code, if file exists gives LBA, else, give 0
1437   0837             ; /usr/local/bin/ed
1438   0837             ;------------------------------------------------------------------------------------------------------;
1439   0837             fs_filepath_exists_user:
1440   0837 FD 4E         mov si, d
1441   0839 FD 4F FF 1B   mov di, user_data
1442   083D 38 00 02      mov c, 512
1443   0840 04            load
1444   0841 07 45 08      call file_exists_by_path
1445   0844 06            sysret
1446   0845             file_exists_by_path:
1447   0845 26 FF 1B      mov b, user_data
1448   0848 FD 42 EF 15   mov [prog], b                   ; token pointer set to path string
1449   084C 07 50 14      call get_token
1450   084F 31 F2 15      mov bl, [tok]
1451   0852 C1 01         cmp bl, TOK_FSLASH
1452   0854 C6 60 08      je  file_exists_by_path_abs
1453   0857 14 04 17      mov a, [current_dir_id]
1454   085A 07 D6 15      call _putback
1455   085D 0A 63 08      jmp file_exists_by_path_E0
1456   0860             file_exists_by_path_abs:
1457   0860 10 20 00      mov a, root_id
1458   0863             file_exists_by_path_E0:
1459   0863 07 50 14      call get_token
1460   0866 31 F1 15      mov bl, [toktyp]
1461   0869 C1 00         cmp bl, TOKTYP_IDENTIFIER
1462   086B C7 C3 08      jne file_exists_by_path_end     ; check if there are tokens after '/'
1463   086E FD 4D F3 15   mov si, tokstr
1464   0872 FD 4F 7F 1B   mov di, filename
1465   0876 07 22 10      call _strcpy        
1466   0879 77            inc a                           ; metadata sector
1467   087A 27            mov b, a
1468   087B 38 00 00      mov c, 0                        ; upper LBA = 0
1469   087E 22 01         mov ah, $01                  ; 1 sector
1470   0880 3B FF 23      mov d, transient_area
1471   0883 07 27 04      call ide_read_sect              ; read directory
1472   0886 FD 10         cla
1473   0888 42 FC 16      mov [index], a
1474   088B             file_exists_by_path_L1:
1475   088B FD 4E         mov si, d
1476   088D FD 4F 7F 1B   mov di, filename
1477   0891 07 0D 10      call _strcmp
1478   0894 C6 AA 08      je   file_exists_by_path_name_equal
1479   0897 58 20 00      add d, 32
1480   089A 14 FC 16      mov a, [index]
1481   089D 77            inc a
1482   089E 42 FC 16      mov [index], a
1483   08A1 AF 10 00      cmp a, FST_FILES_PER_DIR
1484   08A4 C6 C3 08      je file_exists_by_path_end
1485   08A7 0A 8B 08      jmp file_exists_by_path_L1
1486   08AA             file_exists_by_path_name_equal:
1487   08AA 33 18 00      mov bl, [d + 24]
1488   08AD FD 87 38      and bl, %00111000               ; directory flag
1489   08B0 C1 08         cmp bl, %00001000               ; is dir?
1490   08B2 C6 B9 08      je file_exists_by_path_isdir;
1491   08B5             ; entry is a file
1492   08B5 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1493   08B8 09            ret
1494   08B9             file_exists_by_path_isdir:
1495   08B9 58 19 00      add d, 25           
1496   08BC 15            mov a, [d]                      ; set result register A = dirID
1497   08BD 07 50 14      call get_token
1498   08C0 0A 63 08      jmp file_exists_by_path_E0
1499   08C3             file_exists_by_path_end:
1500   08C3 10 00 00      mov a, 0                        ; return 0 because file was not found
1501   08C6 09            ret
1502   08C7             
1503   08C7             ;------------------------------------------------------------------------------------------------------;
1504   08C7             ; load file data from a given path string
1505   08C7             ; inputs:
1506   08C7             ; D = path pointer 
1507   08C7             ; DI = userspace program data destination
1508   08C7             ; /usr/local/bin/ed
1509   08C7             ; ./ed
1510   08C7             ;------------------------------------------------------------------------------------------------------;
1511   08C7             fs_load_from_path_user:
1512   08C7 E3            push di
1513   08C8 FD 4E         mov si, d
1514   08CA FD 4F FF 1B   mov di, user_data
1515   08CE 38 00 02      mov c, 512
1516   08D1 04            load
1517   08D2 07 DF 08      call loadfile_from_path
1518   08D5 F0            pop di
1519   08D6 FD 4D FF 23   mov si, transient_area
1520   08DA 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1521   08DD 03            store
1522   08DE 06            sysret
1523   08DF             loadfile_from_path:
1524   08DF 26 FF 1B      mov b, user_data
1525   08E2 FD 42 EF 15   mov [prog], b                 ; token pointer set to path string
1526   08E6 07 50 14      call get_token
1527   08E9 31 F2 15      mov bl, [tok]
1528   08EC C1 01         cmp bl, TOK_FSLASH
1529   08EE C6 FA 08      je loadfile_from_path_abs 
1530   08F1 14 04 17      mov a, [current_dir_id]
1531   08F4 07 D6 15      call _putback
1532   08F7 0A FD 08      jmp loadfile_from_path_E0
1533   08FA             loadfile_from_path_abs:
1534   08FA 10 20 00      mov a, root_id
1535   08FD             loadfile_from_path_E0:
1536   08FD 07 50 14      call get_token
1537   0900 31 F1 15      mov bl, [toktyp]
1538   0903 C1 00         cmp bl, TOKTYP_IDENTIFIER
1539   0905 C7 6A 09      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1540   0908 FD 4D F3 15   mov si, tokstr
1541   090C FD 4F 7F 1B   mov di, filename
1542   0910 07 22 10      call _strcpy        
1543   0913 77            inc a                         ; metadata sector
1544   0914 27            mov b, a
1545   0915 38 00 00      mov c, 0                      ; upper LBA = 0
1546   0918 22 01         mov ah, $01                  ; 1 sector
1547   091A 3B FF 23      mov d, transient_area
1548   091D 07 27 04      call ide_read_sect            ; read directory
1549   0920 FD 10         cla
1550   0922 42 FC 16      mov [index], a
1551   0925             loadfile_from_path_L1:
1552   0925 FD 4E         mov si, d
1553   0927 FD 4F 7F 1B   mov di, filename
1554   092B 07 0D 10      call _strcmp
1555   092E C6 44 09      je loadfile_from_path_name_equal  
1556   0931 58 20 00      add d, 32
1557   0934 14 FC 16      mov a, [index]
1558   0937 77            inc a
1559   0938 42 FC 16      mov [index], a
1560   093B AF 10 00      cmp a, FST_FILES_PER_DIR
1561   093E C6 6A 09      je loadfile_from_path_end
1562   0941 0A 25 09      jmp loadfile_from_path_L1
1563   0944             loadfile_from_path_name_equal:
1564   0944 33 18 00      mov bl, [d + 24]
1565   0947 FD 87 38      and bl, %00111000             ; directory flag
1566   094A C1 08         cmp bl, %00001000             ; is dir?
1567   094C C6 60 09      je loadfile_isdirectory  
1568   094F             ; entry is a file
1569   094F 2B 19 00      mov b, [d + 25]               ; get LBA
1570   0952 FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1571   0954 3B FF 23      mov d, transient_area
1572   0957 38 00 00      mov c, 0
1573   095A 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1574   095C 07 27 04      call ide_read_sect            ; read sector
1575   095F 09            ret
1576   0960             loadfile_isdirectory:
1577   0960 58 19 00      add d, 25           
1578   0963 15            mov a, [d]                    ; set result register A = dirID
1579   0964 07 50 14      call get_token
1580   0967 0A FD 08      jmp loadfile_from_path_E0
1581   096A             loadfile_from_path_end:
1582   096A 09            ret
1583   096B             
1584   096B             ;------------------------------------------------------------------------------------------------------;
1585   096B             ; return the ID of the current directory
1586   096B             ; ID returned in B
1587   096B             ;------------------------------------------------------------------------------------------------------;
1588   096B             fs_get_curr_dirID:
1589   096B 29 04 17      mov b, [current_dir_id]
1590   096E 06            sysret
1591   096F             
1592   096F             ;------------------------------------------------------------------------------------------------------;
1593   096F             ; CD
1594   096F             ;------------------------------------------------------------------------------------------------------;
1595   096F             ; new dirID in B
1596   096F             fs_cd:
1597   096F FD 42 04 17   mov [current_dir_id], b
1598   0973 06            sysret  
1599   0974             
1600   0974             ;------------------------------------------------------------------------------------------------------;
1601   0974             ; LS
1602   0974             ; dirID in B
1603   0974             ;------------------------------------------------------------------------------------------------------;
1604   0974 00 00       ls_count:       .dw 0
1605   0976             fs_ls:
1606   0976 FD 77         inc b                        ; metadata sector
1607   0978 38 00 00      mov c, 0                     ; upper LBA = 0
1608   097B 22 01         mov ah, $01                  ; 1 sector
1609   097D 3B FF 23      mov d, transient_area
1610   0980 07 27 04      call ide_read_sect           ; read directory
1611   0983 FD 10         cla
1612   0985 42 FC 16      mov [index], a               ; reset entry index
1613   0988 3D 74 09      mov [ls_count], al           ; reset item count
1614   098B             fs_ls_L1:
1615   098B BD 00         cmp byte [d], 0              ; check for NULL
1616   098D C6 24 0A      je fs_ls_next
1617   0990             fs_ls_non_null:
1618   0990 1D 74 09      mov al, [ls_count]
1619   0993 7A            inc al
1620   0994 3D 74 09      mov [ls_count], al           ; increment item count
1621   0997 1F 18 00      mov al, [d + 24]
1622   099A 87 38         and al, %00111000
1623   099C FD A2 03      shr al, 3
1624   099F 22 00         mov ah, 0                    ; file type
1625   09A1 B7 20 17      mov a, [a + file_type]      
1626   09A4 23            mov ah, al
1627   09A5 07 9E 10      call _putchar
1628   09A8 1F 18 00      mov al, [d + 24]
1629   09AB 87 01         and al, %00000001
1630   09AD 22 00         mov ah, 0
1631   09AF B7 1B 17      mov a, [a + file_attrib]     ; read
1632   09B2 23            mov ah, al
1633   09B3 07 9E 10      call _putchar
1634   09B6 1F 18 00      mov al, [d + 24]
1635   09B9 87 02         and al, %00000010
1636   09BB 22 00         mov ah, 0
1637   09BD B7 1B 17      mov a, [a + file_attrib]     ; write
1638   09C0 23            mov ah, al
1639   09C1 07 9E 10      call _putchar
1640   09C4 1F 18 00      mov al, [d + 24]
1641   09C7 87 04         and al, %00000100
1642   09C9 22 00         mov ah, 0
1643   09CB B7 1B 17      mov a, [a + file_attrib]     ; execute
1644   09CE 23            mov ah, al
1645   09CF 07 9E 10      call _putchar
1646   09D2 22 20         mov ah, $20
1647   09D4 07 9E 10      call _putchar  
1648   09D7 2B 1B 00      mov b, [d + 27]
1649   09DA 07 26 12      call print_u16x              ; filesize
1650   09DD 22 20         mov ah, $20
1651   09DF 07 9E 10      call _putchar  
1652   09E2 2B 19 00      mov b, [d + 25]
1653   09E5 07 26 12      call print_u16x              ; dirID / LBA
1654   09E8 22 20         mov ah, $20
1655   09EA 07 9E 10      call _putchar
1656   09ED             ; print date
1657   09ED 33 1D 00      mov bl, [d + 29]             ; day
1658   09F0 07 6A 12      call print_u8x
1659   09F3 22 20         mov ah, $20
1660   09F5 07 9E 10      call _putchar  
1661   09F8 1F 1E 00      mov al, [d + 30]             ; month
1662   09FB FD 9E 02      shl al, 2
1663   09FE DA            push d
1664   09FF 3B DF 17      mov d, s_months
1665   0A02 22 00         mov ah, 0
1666   0A04 59            add d, a
1667   0A05 07 CA 11      call _puts
1668   0A08 E7            pop d
1669   0A09 22 20         mov ah, $20
1670   0A0B 07 9E 10      call _putchar
1671   0A0E 2E 20         mov bl, $20
1672   0A10 07 6A 12      call print_u8x
1673   0A13 33 1F 00      mov bl, [d + 31]             ; year
1674   0A16 07 6A 12      call print_u8x  
1675   0A19 22 20         mov ah, $20
1676   0A1B 07 9E 10      call _putchar  
1677   0A1E 07 CA 11      call _puts                   ; print filename  
1678   0A21 07 77 11      call printnl
1679   0A24             fs_ls_next:
1680   0A24 14 FC 16      mov a, [index]
1681   0A27 77            inc a
1682   0A28 42 FC 16      mov [index], a
1683   0A2B AF 10 00      cmp a, FST_FILES_PER_DIR
1684   0A2E C6 37 0A      je fs_ls_end
1685   0A31 58 20 00      add d, 32      
1686   0A34 0A 8B 09      jmp fs_ls_L1  
1687   0A37             fs_ls_end:
1688   0A37 3B 30 17      mov d, s_ls_total
1689   0A3A 07 CA 11      call _puts
1690   0A3D 1D 74 09      mov al, [ls_count]
1691   0A40 07 7C 12      call print_u8d
1692   0A43 07 77 11      call printnl
1693   0A46 06            sysret
1694   0A47             
1695   0A47             
1696   0A47             ; file structure:
1697   0A47             ; 512 bytes header
1698   0A47             ; header used to tell whether the block is free
1699   0A47             ;------------------------------------------------------------------------------------------------------;
1700   0A47             ; CREATE NEW TEXTFILE
1701   0A47             ;------------------------------------------------------------------------------------------------------;
1702   0A47             ; d = content pointer in user space
1703   0A47             ; c = file size
1704   0A47             fs_starcom:
1705   0A47 FD 4E       	mov si, d
1706   0A49 FD 4F FF 23 	mov di, transient_area
1707   0A4D 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1708   0A50 04          	load					; load data from user-space
1709   0A51 07 D2 0A    	call fs_find_empty_block	; look for empty data blocks
1710   0A54 D8          	push b				; save empty block LBA
1711   0A55 FD 79         mov g, b
1712   0A57             ;create header file by grabbing file name from parameter	
1713   0A57 3B FF 25    	mov d, transient_area + 512			; pointer to file contents
1714   0A5A D9          	push c							; save length
1715   0A5B 19 01       	mov al, 1
1716   0A5D 3D FF 23    	mov [transient_area], al					; mark sectors as USED (not NULL)
1717   0A60 3B FF 23    	mov d, transient_area
1718   0A63 12            mov a, c
1719   0A64 26 00 02      mov b, 512
1720   0A67 AE            div a, b
1721   0A68 FD 77         inc b         ; inc b as the division will most likely have a remainder
1722   0A6A 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1723   0A6B 38 00 00    	mov c, 0      ; lba 
1724   0A6E FD 27         mov b, g      ; lba 
1725   0A70 07 4D 04    	call ide_write_sect			; write sectors
1726   0A73             ; now we add the file to the current directory!
1727   0A73             fs_starcom_add_to_dir:	
1728   0A73 14 04 17    	mov a, [current_dir_id]
1729   0A76 77          	inc a
1730   0A77 27          	mov b, a					; metadata sector
1731   0A78 38 00 00    	mov c, 0
1732   0A7B FD 79       	mov g, b					; save LBA
1733   0A7D 3B FF 21    	mov d, scrap_sector
1734   0A80 22 01       	mov ah, $01			  ; 1 sector
1735   0A82 07 27 04    	call ide_read_sect		; read metadata sector
1736   0A85             fs_starcom_add_to_dir_L2:
1737   0A85 BD 00       	cmp byte[d], 0
1738   0A87 C6 90 0A    	je fs_starcom_add_to_dir_null
1739   0A8A 58 20 00    	add d, FST_ENTRY_SIZE
1740   0A8D 0A 85 0A    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1741   0A90             fs_starcom_add_to_dir_null:
1742   0A90 FD 4D 00 24 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1743   0A94 FD 50       	mov di, d
1744   0A96 07 22 10    	call _strcpy			; copy file name
1745   0A99 58 18 00    	add d, 24			; skip name
1746   0A9C 19 07       	mov al, %00000111	; type=file, execute, write, read
1747   0A9E 3E          	mov [d], al			
1748   0A9F 58 03 00    	add d, 3
1749   0AA2 E4          	pop a
1750   0AA3 5F 00 02      sub a, 512
1751   0AA6 43          	mov [d], a ; file size
1752   0AA7 63 02 00    	sub d, 2
1753   0AAA E5          	pop b				; get file LBA
1754   0AAB FD 43       	mov [d], b			; save LBA	
1755   0AAD             ; set file creation date	
1756   0AAD 58 04 00    	add d, 4
1757   0AB0 19 04       	mov al, 4
1758   0AB2 05 01       	syscall sys_rtc
1759   0AB4 1A          	mov al, ah
1760   0AB5 3E          	mov [d], al			; set day
1761   0AB6 79          	inc d
1762   0AB7 19 05       	mov al, 5
1763   0AB9 05 01       	syscall sys_rtc
1764   0ABB 1A          	mov al, ah
1765   0ABC 3E          	mov [d], al			; set month
1766   0ABD 79          	inc d
1767   0ABE 19 06       	mov al, 6
1768   0AC0 05 01       	syscall sys_rtc
1769   0AC2 1A          	mov al, ah
1770   0AC3 3E          	mov [d], al			; set year
1771   0AC4             ; write sector into disk for new directory entry
1772   0AC4 FD 27       	mov b, g
1773   0AC6 38 00 00    	mov c, 0
1774   0AC9 3B FF 21    	mov d, scrap_sector
1775   0ACC 22 01       	mov ah, $01			; disk write, 1 sector
1776   0ACE 07 4D 04    	call ide_write_sect		; write sector
1777   0AD1 06          	sysret
1778   0AD2             
1779   0AD2             ;------------------------------------------------------------------------------------------------------;
1780   0AD2             ; finds an empty data block
1781   0AD2             ; block LBA returned in B
1782   0AD2             ;------------------------------------------------------------------------------------------------------;
1783   0AD2             fs_find_empty_block:
1784   0AD2 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1785   0AD5 38 00 00      mov c, 0                ; upper LBA = 0
1786   0AD8             fs_find_empty_block_L1:  
1787   0AD8 22 01         mov ah, $01                  ; 1 sector
1788   0ADA 3B FF 21      mov d, transient_area - 512
1789   0ADD 07 27 04      call ide_read_sect      ; read sector
1790   0AE0 BD 00         cmp byte [d], 0
1791   0AE2 C6 EB 0A      je fs_find_empty_block_found_null
1792   0AE5 55 20 00      add b, FS_SECTORS_PER_FILE
1793   0AE8 0A D8 0A      jmp fs_find_empty_block_L1
1794   0AEB             fs_find_empty_block_found_null:
1795   0AEB 09            ret
1796   0AEC             
1797   0AEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1798   0AEC             ;; CREATE NEW TEXTFILE
1799   0AEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1800   0AEC             ; search for first null block
1801   0AEC             fs_mktxt:
1802   0AEC FD 4E       	mov si, d
1803   0AEE FD 4F FF 1B 	mov di, user_data
1804   0AF2 38 00 01    	mov c, 256
1805   0AF5 04          	load					; load data from user-space
1806   0AF6             	
1807   0AF6 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1808   0AF9 38 00 00    	mov c, 0						; reset LBA to 0
1809   0AFC             fs_mktxt_L1:	
1810   0AFC 10 02 01    	mov a, $0102			; disk read
1811   0AFF 3B FF 23    	mov d, transient_area
1812   0B02 05 02       	syscall sys_ide ; read sector
1813   0B04 1E          	mov al, [d]
1814   0B05 B9 00       	cmp al, 0			; check for NULL
1815   0B07 C6 10 0B    	je fs_mktxt_found_null
1816   0B0A 55 20 00    	add b, FS_SECTORS_PER_FILE
1817   0B0D 0A FC 0A    	jmp fs_mktxt_L1
1818   0B10             fs_mktxt_found_null:
1819   0B10 D8          	push b				; save LBA
1820   0B11             ;create header file by grabbing file name from parameter	
1821   0B11 3B 11 17    	mov d, s_dataentry
1822   0B14 07 CA 11    	call _puts
1823   0B17 3B FF 25    	mov d, transient_area + 512			; pointer to file contents
1824   0B1A 07 A5 10    	call _gets
1825   0B1D 07 FD 0F    	call _strlen						; get length of file
1826   0B20 D9          	push c							; save length
1827   0B21 19 01       	mov al, 1
1828   0B23 3D FF 23    	mov [transient_area], al					; mark sectors as USED (not NULL)
1829   0B26 10 00 00    	mov a, 0
1830   0B29 42 FC 16    	mov [index], a
1831   0B2C 3B FF 23    	mov d, transient_area
1832   0B2F 13          	mov a, d
1833   0B30 42 FE 16    	mov [buffer_addr], a
1834   0B33             fs_mktxt_L2:
1835   0B33 38 00 00    	mov c, 0
1836   0B36 10 03 01    	mov a, $0103			; disk write, 1 sector
1837   0B39 05 02       	syscall sys_ide		; write sector
1838   0B3B 14 FC 16    	mov a, [index]
1839   0B3E 77          	inc a
1840   0B3F 42 FC 16    	mov [index], a
1841   0B42 AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1842   0B45 C6 57 0B    	je fs_mktxt_add_to_dir
1843   0B48 FD 77       	inc b
1844   0B4A 14 FE 16    	mov a, [buffer_addr]
1845   0B4D 53 00 02    	add a, 512
1846   0B50 42 FE 16    	mov [buffer_addr], a
1847   0B53 3C          	mov d, a
1848   0B54 0A 33 0B    	jmp fs_mktxt_L2
1849   0B57             ; now we add the file to the current directory!
1850   0B57             fs_mktxt_add_to_dir:	
1851   0B57 14 04 17    	mov a, [current_dir_id]
1852   0B5A 77          	inc a
1853   0B5B 27          	mov b, a					; metadata sector
1854   0B5C 38 00 00    	mov c, 0
1855   0B5F FD 79       	mov g, b					; save LBA
1856   0B61 3B FF 23    	mov d, transient_area
1857   0B64 10 02 01    	mov a, $0102			; disk read
1858   0B67 05 02       	syscall sys_ide		; read metadata sector
1859   0B69             fs_mktxt_add_to_dir_L2:
1860   0B69 1E          	mov al, [d]
1861   0B6A B9 00       	cmp al, 0
1862   0B6C C6 75 0B    	je fs_mktxt_add_to_dir_null
1863   0B6F 58 20 00    	add d, FST_ENTRY_SIZE
1864   0B72 0A 69 0B    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1865   0B75             fs_mktxt_add_to_dir_null:
1866   0B75 FD 4D FF 1B 	mov si, user_data
1867   0B79 FD 50       	mov di, d
1868   0B7B 07 22 10    	call _strcpy			; copy file name
1869   0B7E 58 18 00    	add d, 24			; skip name
1870   0B81 19 06       	mov al, %00000110		; no execute, write, read, not directory
1871   0B83 3E          	mov [d], al			
1872   0B84 58 03 00    	add d, 3
1873   0B87 E4          	pop a
1874   0B88 43          	mov [d], a
1875   0B89 63 02 00    	sub d, 2
1876   0B8C E5          	pop b				; get file LBA
1877   0B8D FD 43       	mov [d], b			; save LBA	
1878   0B8F             	
1879   0B8F             	; set file creation date	
1880   0B8F 58 04 00    	add d, 4
1881   0B92 19 04       	mov al, 4
1882   0B94 05 01       	syscall sys_rtc
1883   0B96 1A          	mov al, ah
1884   0B97 3E          	mov [d], al			; set day
1885   0B98             	
1886   0B98 79          	inc d
1887   0B99 19 05       	mov al, 5
1888   0B9B 05 01       	syscall sys_rtc
1889   0B9D 1A          	mov al, ah
1890   0B9E 3E          	mov [d], al			; set month
1891   0B9F             	
1892   0B9F 79          	inc d
1893   0BA0 19 06       	mov al, 6
1894   0BA2 05 01       	syscall sys_rtc
1895   0BA4 1A          	mov al, ah
1896   0BA5 3E          	mov [d], al			; set year
1897   0BA6             	
1898   0BA6             ; write sector into disk for new directory entry
1899   0BA6 FD 27       	mov b, g
1900   0BA8 38 00 00    	mov c, 0
1901   0BAB 3B FF 23    	mov d, transient_area
1902   0BAE 10 03 01    	mov a, $0103			; disk write, 1 sector
1903   0BB1 05 02       	syscall sys_ide		; write sector
1904   0BB3 07 77 11    	call printnl
1905   0BB6 06          	sysret
1906   0BB7             
1907   0BB7             
1908   0BB7             
1909   0BB7             ;------------------------------------------------------------------------------------------------------;
1910   0BB7             ; CREATE NEW BINARY FILE
1911   0BB7             ;------------------------------------------------------------------------------------------------------;
1912   0BB7             ; search for first null block
1913   0BB7             fs_mkbin:
1914   0BB7 19 00         mov al, 0
1915   0BB9 3D F4 16      mov [sys_echo_on], al ; disable echo
1916   0BBC FD 4E         mov si, d
1917   0BBE FD 4F FF 1B   mov di, user_data
1918   0BC2 38 00 02      mov c, 512
1919   0BC5 04            load                          ; load data from user-space
1920   0BC6 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
1921   0BC9 38 00 00      mov c, 0                      ; upper LBA = 0
1922   0BCC             fs_mkbin_L1:  
1923   0BCC 22 01         mov ah, $01                  ; 1 sector
1924   0BCE 3B FF 23      mov d, transient_area
1925   0BD1 07 27 04      call ide_read_sect            ; read sector
1926   0BD4 BD 00         cmp byte[d], 0                ; check for NULL
1927   0BD6 C6 DF 0B      je fs_mkbin_found_null
1928   0BD9 55 20 00      add b, FS_SECTORS_PER_FILE
1929   0BDC 0A CC 0B      jmp fs_mkbin_L1
1930   0BDF             fs_mkbin_found_null:
1931   0BDF D8            push b                        ; save LBA
1932   0BE0             ;create header file by grabbing file name from parameter
1933   0BE0 FD 4F FF 25   mov di, transient_area + 512  ; pointer to file contents
1934   0BE4 07 90 0F      call _load_hex                ; load binary hex
1935   0BE7 D9            push c                        ; save size (nbr of bytes)
1936   0BE8 19 01         mov al, 1
1937   0BEA 3D FF 23      mov [transient_area], al      ; mark sectors as USED (not NULL)
1938   0BED FD 10         cla
1939   0BEF 42 FC 16      mov [index], a
1940   0BF2 3B FF 23      mov d, transient_area
1941   0BF5 13            mov a, d
1942   0BF6 42 FE 16      mov [buffer_addr], a
1943   0BF9             fs_mkbin_L2:
1944   0BF9 38 00 00      mov c, 0
1945   0BFC 22 01         mov ah, $01                   ; disk write, 1 sector
1946   0BFE 07 4D 04      call ide_write_sect           ; write sector
1947   0C01 14 FC 16      mov a, [index]
1948   0C04 77            inc a
1949   0C05 42 FC 16      mov [index], a
1950   0C08 AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
1951   0C0B C6 1D 0C      je fs_mkbin_add_to_dir
1952   0C0E FD 77         inc b
1953   0C10 14 FE 16      mov a, [buffer_addr]
1954   0C13 53 00 02      add a, 512
1955   0C16 42 FE 16      mov [buffer_addr], a
1956   0C19 3C            mov d, a
1957   0C1A 0A F9 0B      jmp fs_mkbin_L2
1958   0C1D             ; now we add the file to the current directory!
1959   0C1D             fs_mkbin_add_to_dir:  
1960   0C1D 14 04 17      mov a, [current_dir_id]
1961   0C20 77            inc a
1962   0C21 27            mov b, a                      ; metadata sector
1963   0C22 38 00 00      mov c, 0
1964   0C25 FD 79         mov g, b                      ; save LBA
1965   0C27 3B FF 23      mov d, transient_area
1966   0C2A 22 01         mov ah, $01                  ; 1 sector
1967   0C2C 07 27 04      call ide_read_sect            ; read metadata sector
1968   0C2F             fs_mkbin_add_to_dir_L2:
1969   0C2F BD 00         cmp byte[d], 0
1970   0C31 C6 3A 0C      je fs_mkbin_add_to_dir_null
1971   0C34 58 20 00      add d, FST_ENTRY_SIZE
1972   0C37 0A 2F 0C      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1973   0C3A             fs_mkbin_add_to_dir_null:
1974   0C3A FD 4D FF 1B   mov si, user_data
1975   0C3E FD 50         mov di, d
1976   0C40 07 22 10      call _strcpy                  ; copy file name
1977   0C43 58 18 00      add d, 24                     ; skip name
1978   0C46 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
1979   0C48 3E            mov [d], al
1980   0C49 58 03 00      add d, 3
1981   0C4C E4            pop a
1982   0C4D 43            mov [d], a
1983   0C4E 63 02 00      sub d, 2
1984   0C51 E5            pop b                         ; get file LBA
1985   0C52 FD 43         mov [d], b                    ; save LBA
1986   0C54               ; set file creation date  
1987   0C54 58 04 00      add d, 4
1988   0C57 19 04         mov al, 4
1989   0C59 05 01         syscall sys_rtc
1990   0C5B 1A            mov al, ah
1991   0C5C 3E            mov [d], al                   ; set day
1992   0C5D 79            inc d
1993   0C5E 19 05         mov al, 5
1994   0C60 05 01         syscall sys_rtc
1995   0C62 1A            mov al, ah
1996   0C63 3E            mov [d], al                   ; set month
1997   0C64 79            inc d
1998   0C65 19 06         mov al, 6
1999   0C67 05 01         syscall sys_rtc
2000   0C69 1A            mov al, ah
2001   0C6A 3E            mov [d], al                   ; set year
2002   0C6B             ; write sector into disk for new directory entry
2003   0C6B FD 27         mov b, g
2004   0C6D 38 00 00      mov c, 0
2005   0C70 3B FF 23      mov d, transient_area
2006   0C73 22 01         mov ah, $01                   ; disk write, 1 sector
2007   0C75 07 4D 04      call ide_write_sect           ; write sector
2008   0C78 19 01         mov al, 1
2009   0C7A 3D F4 16      mov [sys_echo_on], al ; enable echo
2010   0C7D 06            sysret
2011   0C7E             
2012   0C7E             ;------------------------------------------------------------------------------------------------------;
2013   0C7E             ; PWD - PRINT WORKING DIRECTORY
2014   0C7E             ;------------------------------------------------------------------------------------------------------;    
2015   0C7E             fs_pwd:
2016   0C7E 3B 7F 1B      mov d, filename
2017   0C81 19 00         mov al, 0
2018   0C83 3E            mov [d], al                   ; initialize path string 
2019   0C84 14 04 17      mov a, [current_dir_id]
2020   0C87 07 5D 07      call fs_dir_id_to_path_E0
2021   0C8A 3B 7F 1B      mov d, filename
2022   0C8D 07 B6 0F      call _strrev
2023   0C90 07 CA 11      call _puts
2024   0C93 07 77 11      call printnl
2025   0C96 06            sysret
2026   0C97             
2027   0C97             ;------------------------------------------------------------------------------------------------------;
2028   0C97             ; get current directory LBA
2029   0C97             ; A: returned LBA
2030   0C97             ;------------------------------------------------------------------------------------------------------;
2031   0C97             cmd_get_curr_dir_LBA:
2032   0C97 14 04 17      mov a, [current_dir_id]
2033   0C9A 06            sysret
2034   0C9B             
2035   0C9B             ;------------------------------------------------------------------------------------------------------;
2036   0C9B             ; CAT
2037   0C9B             ; userspace destination data pointer in D
2038   0C9B             ; filename starts at D, but is overwritten after the read is made
2039   0C9B             ;------------------------------------------------------------------------------------------------------;:
2040   0C9B             fs_cat:
2041   0C9B DA            push d                              ; save userspace file data destination
2042   0C9C FD 4E         mov si, d
2043   0C9E FD 4F FF 1B   mov di, user_data
2044   0CA2 38 00 02      mov c, 512
2045   0CA5 04            load                                ; copy filename from user-space
2046   0CA6 29 04 17      mov b, [current_dir_id]
2047   0CA9 FD 77         inc b                               ; metadata sector
2048   0CAB 38 00 00      mov c, 0                            ; upper LBA = 0
2049   0CAE 22 01         mov ah, $01                  ; 1 sector
2050   0CB0 3B FF 21      mov d, transient_area-512
2051   0CB3 07 27 04      call ide_read_sect                  ; read directory
2052   0CB6 FD 10         cla
2053   0CB8 42 FC 16      mov [index], a                      ; reset file counter
2054   0CBB             fs_cat_L1:
2055   0CBB FD 4E         mov si, d
2056   0CBD FD 4F FF 1B   mov di, user_data
2057   0CC1 07 0D 10      call _strcmp
2058   0CC4 C6 DA 0C      je fs_cat_found_entry
2059   0CC7 58 20 00      add d, 32
2060   0CCA 14 FC 16      mov a, [index]
2061   0CCD 77            inc a
2062   0CCE 42 FC 16      mov [index], a
2063   0CD1 AF 10 00      cmp a, FST_FILES_PER_DIR
2064   0CD4 C6 F5 0C      je fs_cat_not_found
2065   0CD7 0A BB 0C      jmp fs_cat_L1
2066   0CDA             fs_cat_found_entry:
2067   0CDA 58 19 00      add d, 25                           ; get to dirID of file in disk
2068   0CDD 2A            mov b, [d]                          ; get LBA
2069   0CDE FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2070   0CE0 3B FF 23      mov d, transient_area  
2071   0CE3 38 00 00      mov c, 0
2072   0CE6 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2073   0CE8 07 27 04      call ide_read_sect                  ; read sectors
2074   0CEB F0            pop di                              ; write userspace file data destination to DI
2075   0CEC FD 4D FF 23   mov si, transient_area              ; data origin
2076   0CF0 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2077   0CF3 03            store
2078   0CF4 06            sysret
2079   0CF5             fs_cat_not_found:
2080   0CF5 E7            pop d
2081   0CF6 06            sysret
2082   0CF7             
2083   0CF7             ;------------------------------------------------------------------------------------------------------;
2084   0CF7             ; RMDIR - remove DIR by dirID
2085   0CF7             ;------------------------------------------------------------------------------------------------------;
2086   0CF7             ; deletes a directory entry in the given directory's file list 
2087   0CF7             ; also deletes the actual directory entry in the FST
2088   0CF7             ; synopsis: rmdir /usr/local/testdir
2089   0CF7             ; B = dirID
2090   0CF7             fs_rmdir:
2091   0CF7 FD 79         mov g, b
2092   0CF9 11            mov a, b
2093   0CFA 07 99 07      call get_parentID_from_dirID  ; now get the directory's parent, in A
2094   0CFD D7            push a                        ; save dirID
2095   0CFE             ; search for directory's entry in the parent's directory then and delete it
2096   0CFE 77            inc a                         ; metadata sector
2097   0CFF 27            mov b, a
2098   0D00 38 00 00      mov c, 0                      ; upper LBA = 0
2099   0D03 22 01         mov ah, $01          ;
2100   0D05 3B FF 23      mov d, transient_area
2101   0D08 07 27 04      call ide_read_sect            ; read directory
2102   0D0B FD 10         cla
2103   0D0D 42 FC 16      mov [index], a                ; reset file counter
2104   0D10 FD 27         mov b, g                      ; retrieve directory's dirID
2105   0D12             fs_rmdir_L1:
2106   0D12 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2107   0D15 B0            cmp a, b                      ; compare dirID's to find the directory
2108   0D16 C6 2C 0D      je fs_rmdir_found_entry
2109   0D19 58 20 00      add d, 32
2110   0D1C 14 FC 16      mov a, [index]
2111   0D1F 77            inc a
2112   0D20 42 FC 16      mov [index], a
2113   0D23 AF 10 00      cmp a, FST_FILES_PER_DIR
2114   0D26 C6 51 0D      je fs_rmdir_not_found
2115   0D29 0A 12 0D      jmp fs_rmdir_L1
2116   0D2C             fs_rmdir_found_entry:
2117   0D2C FD 10         cla
2118   0D2E 3E            mov [d], al                   ; make filename NULL
2119   0D2F 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2120   0D32 E5            pop b
2121   0D33 FD 77         inc b                         ; metadata sector
2122   0D35 38 00 00      mov c, 0                      ; upper LBA = 0
2123   0D38 22 01         mov ah, $01          ; 
2124   0D3A 3B FF 23      mov d, transient_area
2125   0D3D 07 4D 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2126   0D40             
2127   0D40 FD 27         mov b, g
2128   0D42 3B FF 23      mov d, transient_area  
2129   0D45 FD 10         cla
2130   0D47 3E            mov [d], al                   ; make directory's name header NULL for re-use
2131   0D48 38 00 00      mov c, 0
2132   0D4B 22 01         mov ah, $01                   ; disk write 1 sect
2133   0D4D 07 4D 04      call ide_write_sect           ; delete directory given by dirID in B
2134   0D50 06            sysret
2135   0D51             fs_rmdir_not_found:
2136   0D51 E5            pop b
2137   0D52 06            sysret
2138   0D53             
2139   0D53             ;------------------------------------------------------------------------------------------------------;
2140   0D53             ; RM - remove file
2141   0D53             ;------------------------------------------------------------------------------------------------------;
2142   0D53             ; frees up the data sectors for the file further down the disk
2143   0D53             ; deletes file entry in the directory's file list 
2144   0D53             fs_rm:
2145   0D53 FD 4E         mov si, d
2146   0D55 FD 4F FF 1B   mov di, user_data
2147   0D59 38 00 02      mov c, 512
2148   0D5C 04            load                          ; load data from user-space
2149   0D5D 14 04 17      mov a, [current_dir_id]
2150   0D60 77            inc a                         ; metadata sector
2151   0D61 27            mov b, a
2152   0D62 38 00 00      mov c, 0                      ; upper LBA = 0
2153   0D65 22 01         mov ah, $01                  ; 1 sector
2154   0D67 3B FF 23      mov d, transient_area
2155   0D6A 07 27 04      call ide_read_sect            ; read directory
2156   0D6D 10 00 00      mov a, 0
2157   0D70 42 FC 16      mov [index], a                ; reset file counter
2158   0D73             fs_rm_L1:
2159   0D73 FD 4E         mov si, d
2160   0D75 FD 4F FF 1B   mov di, user_data
2161   0D79 07 0D 10      call _strcmp
2162   0D7C C6 92 0D      je fs_rm_found_entry
2163   0D7F 58 20 00      add d, 32
2164   0D82 14 FC 16      mov a, [index]
2165   0D85 77            inc a
2166   0D86 42 FC 16      mov [index], a
2167   0D89 AF 10 00      cmp a, FST_FILES_PER_DIR
2168   0D8C C6 BA 0D      je fs_rm_not_found
2169   0D8F 0A 73 0D      jmp fs_rm_L1
2170   0D92             fs_rm_found_entry:
2171   0D92 2B 19 00      mov b, [d + 25]               ; get LBA
2172   0D95 FD 79         mov g, b                      ; save LBA
2173   0D97 19 00         mov al, 0
2174   0D99 3E            mov [d], al                   ; make file entry NULL
2175   0D9A 14 04 17      mov a, [current_dir_id]
2176   0D9D 77            inc a                         ; metadata sector
2177   0D9E 27            mov b, a
2178   0D9F 38 00 00      mov c, 0                      ; upper LBA = 0
2179   0DA2 22 01         mov ah, $01                   ; disk write
2180   0DA4 3B FF 23      mov d, transient_area
2181   0DA7 07 4D 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2182   0DAA 3B FF 23      mov d, transient_area  
2183   0DAD 19 00         mov al, 0
2184   0DAF 3E            mov [d], al                   ; make file's data header NULL for re-use
2185   0DB0 38 00 00      mov c, 0
2186   0DB3 FD 27         mov b, g                      ; get data header LBA
2187   0DB5 22 01         mov ah, $01                   ; disk write 1 sect
2188   0DB7 07 4D 04      call ide_write_sect           ; write sector
2189   0DBA             fs_rm_not_found:  
2190   0DBA 06            sysret  
2191   0DBB             
2192   0DBB             ;------------------------------------------------------------------------------------------------------;
2193   0DBB             ; mv - move / change file name
2194   0DBB             ;------------------------------------------------------------------------------------------------------;
2195   0DBB             fs_mv:
2196   0DBB FD 4E         mov si, d
2197   0DBD FD 4F FF 1B   mov di, user_data
2198   0DC1 38 00 02      mov c, 512
2199   0DC4 04            load                          ; load data from user-space
2200   0DC5 14 04 17      mov a, [current_dir_id]
2201   0DC8 77            inc a                         ; metadata sector
2202   0DC9 27            mov b, a  
2203   0DCA 38 00 00      mov c, 0                      ; upper LBA = 0
2204   0DCD 22 01         mov ah, $01                  ; 1 sector
2205   0DCF 3B FF 23      mov d, transient_area
2206   0DD2 07 27 04      call ide_read_sect            ; read directory
2207   0DD5 FD 10         cla
2208   0DD7 42 FC 16      mov [index], a                ; reset file counter
2209   0DDA             fs_mv_L1:
2210   0DDA FD 4E         mov si, d
2211   0DDC FD 4F FF 1B   mov di, user_data
2212   0DE0 07 0D 10      call _strcmp
2213   0DE3 C6 F9 0D      je fs_mv_found_entry
2214   0DE6 58 20 00      add d, 32
2215   0DE9 14 FC 16      mov a, [index]
2216   0DEC 77            inc a
2217   0DED 42 FC 16      mov [index], a
2218   0DF0 AF 10 00      cmp a, FST_FILES_PER_DIR
2219   0DF3 C6 2B 0E      je fs_mv_not_found
2220   0DF6 0A DA 0D      jmp fs_mv_L1
2221   0DF9             fs_mv_found_entry:  
2222   0DF9 DA            push d
2223   0DFA FD 4D 7F 1C   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2224   0DFE FD 50         mov di, d
2225   0E00 07 22 10      call _strcpy  
2226   0E03 38 00 00      mov c, 0
2227   0E06 3B FF 23      mov d, transient_area
2228   0E09 22 01         mov ah, $01                   ; disk write 1 sect
2229   0E0B 07 4D 04      call ide_write_sect           ; write sector
2230   0E0E E7            pop d
2231   0E0F             ;; need to check whether its a dir or a file here ;;;
2232   0E0F 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2233   0E12 22 01         mov ah, $01
2234   0E14 3B FF 23      mov d, transient_area
2235   0E17 38 00 00      mov c, 0
2236   0E1A 07 27 04      call ide_read_sect            ; read directory entry
2237   0E1D FD 4D 7F 1C   mov si, user_data + 128
2238   0E21 FD 50         mov di, d
2239   0E23 07 22 10      call _strcpy                  ; change directory's name
2240   0E26 22 01         mov ah, $01
2241   0E28 07 4D 04      call ide_write_sect           ; rewrite directory back to disk
2242   0E2B             fs_mv_not_found:
2243   0E2B 06            sysret
2244   0E2C             
2245   0E2C             kernel_reset_vector:  
2246   0E2C FD 49 FF F7   mov bp, STACK_BEGIN
2247   0E30 FD 47 FF F7   mov sp, STACK_BEGIN
2248   0E34               
2249   0E34 19 80         mov al, %10000000
2250   0E36 FD 0F         stomsk                        ; mask out timer interrupt for now (only allow UART to interrupt)
2251   0E38 FD 0C         sti  
2252   0E3A             
2253   0E3A 0C            lodstat
2254   0E3B 87 DF         and al, %11011111             ; disable display register loading
2255   0E3D 0D            stostat
2256   0E3E               
2257   0E3E             ; reset fifo pointers
2258   0E3E 10 FF 1D      mov a, fifo
2259   0E41 3B 00 17      mov d, fifo_in
2260   0E44 43            mov [d], a
2261   0E45 3B 02 17      mov d, fifo_out
2262   0E48 43            mov [d], a  
2263   0E49 19 02         mov al, 2
2264   0E4B 05 03         syscall sys_io                ; enable uart in interrupt mode
2265   0E4D               
2266   0E4D 3B 46 17      mov d, s_kernel_started
2267   0E50 07 CA 11      call _puts
2268   0E53             
2269   0E53 19 10         mov al, 16
2270   0E55 05 04         syscall sys_filesystem        ; set root dirID
2271   0E57             
2272   0E57 3B 63 17      mov d, s_prompt_init
2273   0E5A 07 CA 11      call _puts
2274   0E5D 3B 06 17      mov d, s_init_path
2275   0E60 05 05         syscall sys_spawn_proc              ; launch init as a new process
2276   0E62             
2277   0E62             ;----------------------------------------------------------------------------------------------------;
2278   0E62             ; Process Index in A
2279   0E62             ;----------------------------------------------------------------------------------------------------;
2280   0E62             find_free_proc:
2281   0E62 FD 4D 70 19   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2282   0E66             find_free_proc_L0:
2283   0E66 F6            lodsb                               ; get process state
2284   0E67 B9 00         cmp al, 0
2285   0E69 C6 6F 0E      je find_free_proc_free              ; if free, jump
2286   0E6C 0A 66 0E      jmp find_free_proc_L0               ; else, goto next
2287   0E6F             find_free_proc_free:
2288   0E6F 4E            mov a, si
2289   0E70 5F 70 19      sub a, 1 + proc_availab_table       ; get process index
2290   0E73 09            ret
2291   0E74               
2292   0E74             
2293   0E74             ;----------------------------------------------------------------------------------------------------;
2294   0E74             ; Process Index in AL
2295   0E74             ;----------------------------------------------------------------------------------------------------;
2296   0E74             proc_memory_map:
2297   0E74 22 00         mov ah, 0
2298   0E76 27            mov b, a                      ; page in BL, 0 in BH
2299   0E77 FD 9D 05      shl a, 5                      ; multiply by 32
2300   0E7A 39            mov c, a                      ; save in C
2301   0E7B 57 20 00      add c, 32
2302   0E7E             proc_memory_map_L0:
2303   0E7E 02            pagemap
2304   0E7F 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2305   0E82 53 01 00      add a, 1                      ; increase both 
2306   0E85 B1            cmp a, c                      ; check to see if we reached the end of memory
2307   0E86 C7 7E 0E      jne proc_memory_map_L0
2308   0E89 09            ret
2309   0E8A               
2310   0E8A             
2311   0E8A             syscall_terminate_proc:
2312   0E8A 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2313   0E8D                                                    ; since they will not be used for anything here.
2314   0E8D 1D FB 16      mov al, [active_proc_index]
2315   0E90 22 00         mov ah, 0  
2316   0E92 FD 9D 05      shl a, 5                             ; x32
2317   0E95 53 7F 19      add a, proc_names
2318   0E98 3C            mov d, a
2319   0E99 19 00         mov al, 0
2320   0E9B 3E            mov [d], al                           ; nullify process name
2321   0E9C             
2322   0E9C 1D FB 16      mov al, [active_proc_index]
2323   0E9F 22 00         mov ah, 0  
2324   0EA1 3C            mov d, a
2325   0EA2 19 00         mov al, 0
2326   0EA4 3F 6F 19      mov [d + proc_availab_table], al    ; make process empty again
2327   0EA7               
2328   0EA7 1D FA 16      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2329   0EAA 80            dec al
2330   0EAB 3D FA 16      mov [nbr_active_procs], al
2331   0EAE             
2332   0EAE             ; now load the shell process again
2333   0EAE 19 02         mov al, 2                           ; next process = process 2 = shell
2334   0EB0 3D FB 16      mov [active_proc_index], al         ; set next active proc
2335   0EB3             
2336   0EB3             ; calculate LUT entry for next process
2337   0EB3 22 00         mov ah, 0
2338   0EB5 FD 99         shl a                               ; x2
2339   0EB7 B7 80 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2340   0EBA               
2341   0EBA 4D            mov si, a                           ; source is proc state block
2342   0EBB 48            mov a, sp
2343   0EBC 5F 13 00      sub a, 19
2344   0EBF 4F            mov di, a                           ; destination is kernel stack
2345   0EC0             ; restore SP
2346   0EC0 7D            dec a
2347   0EC1 47            mov sp, a
2348   0EC2 38 14 00      mov c, 20
2349   0EC5 FD F5         rep movsb
2350   0EC7             ; set VM process
2351   0EC7 1D FB 16      mov al, [active_proc_index]
2352   0ECA 01            setptb
2353   0ECB                 
2354   0ECB 4C            popa
2355   0ECC 06            sysret
2356   0ECD             
2357   0ECD             syscall_pause_proc:
2358   0ECD             ; save all registers into kernel stack
2359   0ECD 4B            pusha
2360   0ECE 22 00         mov ah, 0
2361   0ED0 1D FB 16      mov al, [active_proc_index]
2362   0ED3 FD 99         shl a              ; x2
2363   0ED5 B7 80 0F      mov a, [proc_table_convert + a]   ; get process state start index
2364   0ED8                 
2365   0ED8 4F            mov di, a
2366   0ED9 48            mov a, sp
2367   0EDA 77            inc a
2368   0EDB 4D            mov si, a
2369   0EDC 38 14 00      mov c, 20
2370   0EDF FD F5         rep movsb                         ; save process state!
2371   0EE1             ; restore kernel stack position to point before interrupt arrived
2372   0EE1 51 14 00      add sp, 20
2373   0EE4             ; now load the shell process again
2374   0EE4 19 02         mov al, 2                         ; next process = process 2 = shell
2375   0EE6 3D FB 16      mov [active_proc_index], al       ; set next active proc
2376   0EE9             
2377   0EE9             ; calculate LUT entry for next process
2378   0EE9 22 00         mov ah, 0
2379   0EEB FD 99         shl a                             ; x2
2380   0EED B7 80 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2381   0EF0               
2382   0EF0 4D            mov si, a                         ; source is proc state block
2383   0EF1 48            mov a, sp
2384   0EF2 5F 13 00      sub a, 19
2385   0EF5 4F            mov di, a                         ; destination is kernel stack
2386   0EF6             ; restore SP
2387   0EF6 7D            dec a
2388   0EF7 47            mov sp, a
2389   0EF8 38 14 00      mov c, 20
2390   0EFB FD F5         rep movsb
2391   0EFD             ; set VM process
2392   0EFD 1D FB 16      mov al, [active_proc_index]
2393   0F00 01            setptb
2394   0F01                 
2395   0F01 4C            popa
2396   0F02 06            sysret
2397   0F03             
2398   0F03             ;----------------------------------------------------------------------------------------------------;
2399   0F03             ; spawn a new process
2400   0F03             ; D = path of the process file to be spawned
2401   0F03             ; B = arguments ptr
2402   0F03             ;----------------------------------------------------------------------------------------------------;
2403   0F03             syscall_spawn_proc:
2404   0F03             ; we save the active process first  
2405   0F03 4B            pusha
2406   0F04 22 00         mov ah, 0
2407   0F06 1D FB 16      mov al, [active_proc_index]
2408   0F09 FD 99         shl a              ; x2
2409   0F0B B7 80 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2410   0F0E               
2411   0F0E 4F            mov di, a
2412   0F0F 48            mov a, sp
2413   0F10 77            inc a
2414   0F11 4D            mov si, a
2415   0F12 38 14 00      mov c, 20
2416   0F15 FD F5         rep movsb                          ; save process state!
2417   0F17             ; restore kernel stack position to point before interrupt arrived
2418   0F17 51 14 00      add sp, 20
2419   0F1A               
2420   0F1A FD 4E         mov si, d                          ; copy the file path
2421   0F1C FD 4F FF 1B   mov di, user_data
2422   0F20 38 00 02      mov c, 512
2423   0F23 04            load
2424   0F24 11            mov a, b
2425   0F25 4D            mov si, a                          ; copy the arguments
2426   0F26 FD 4F FF 21   mov di, scrap_sector
2427   0F2A 38 00 02      mov c, 512
2428   0F2D 04            load
2429   0F2E 07 DF 08      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2430   0F31                                                  ; the file data is loaded into transient_area
2431   0F31             ; now we allocate a new process  
2432   0F31 07 62 0E      call find_free_proc                ; index in A
2433   0F34 01            setptb 
2434   0F35 07 74 0E      call proc_memory_map               ; map process memory pages
2435   0F38             ; copy arguments into process's memory
2436   0F38 FD 4D FF 21   mov si, scrap_sector
2437   0F3C FD 4F 00 00   mov di, 0
2438   0F40 38 00 02      mov c, 512
2439   0F43 03            store
2440   0F44             ; now copy process binary data into process's memory
2441   0F44 FD 4D FF 23   mov si, transient_area
2442   0F48 FD 4F 00 04   mov di, text_org              ; code origin address for all user processes
2443   0F4C 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2444   0F4F 03            store                              ; copy process data
2445   0F50                 
2446   0F50 07 62 0E      call find_free_proc                ; index in A
2447   0F53 3D FB 16      mov [active_proc_index], al        ; set new active process
2448   0F56 FD 9D 05      shl a, 5                           ; x32
2449   0F59 53 7F 19      add a, proc_names
2450   0F5C 4F            mov di, a
2451   0F5D FD 4D FF 1B   mov si, user_data                  ; copy and store process filename
2452   0F61 07 22 10      call _strcpy
2453   0F64               
2454   0F64 07 62 0E      call find_free_proc                ; index in A
2455   0F67 3C            mov d, a
2456   0F68 19 01         mov al, 1
2457   0F6A 3F 6F 19      mov [d + proc_availab_table], al   ; make process busy
2458   0F6D               
2459   0F6D 1D FA 16      mov al, [nbr_active_procs]         ; increase nbr of active processes
2460   0F70 7A            inc al
2461   0F71 3D FA 16      mov [nbr_active_procs], al
2462   0F74             ; launch process
2463   0F74 FD D7 FF FF   push word $FFFF 
2464   0F78 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2465   0F7B FD D7 00 04   push word text_org
2466   0F7F 06            sysret
2467   0F80             
2468   0F80             proc_table_convert:
2469   0F80 2F 18         .dw proc_state_table + 0
2470   0F82 43 18         .dw proc_state_table + 20
2471   0F84 57 18         .dw proc_state_table + 40
2472   0F86 6B 18         .dw proc_state_table + 60
2473   0F88 7F 18         .dw proc_state_table + 80
2474   0F8A 93 18         .dw proc_state_table + 100
2475   0F8C A7 18         .dw proc_state_table + 120
2476   0F8E BB 18         .dw proc_state_table + 140
2477   0F90               
2478   0F90             ;----------------------------------------------------------------------------------------------;
2479   0F90             ; GET HEX FILE
2480   0F90             ; di = destination address
2481   0F90             ; return length in bytes in C
2482   0F90             ;----------------------------------------------------------------------------------------------;
2483   0F90             _load_hex:
2484   0F90 D7            push a
2485   0F91 D8            push b
2486   0F92 DA            push d
2487   0F93 E2            push si
2488   0F94 E3            push di
2489   0F95 38 00 00      mov c, 0
2490   0F98 50            mov a, di
2491   0F99 3C            mov d, a          ; start of string data block
2492   0F9A 07 A5 10      call _gets        ; get program string
2493   0F9D               ;call _puts        ; reprint to screen
2494   0F9D 4D            mov si, a
2495   0F9E             __load_hex_loop:
2496   0F9E F6            lodsb             ; load from [SI] to AL
2497   0F9F B9 00         cmp al, 0         ; check if ASCII 0
2498   0FA1 C6 AF 0F      jz __load_hex_ret
2499   0FA4 36            mov bh, al
2500   0FA5 F6            lodsb
2501   0FA6 2F            mov bl, al
2502   0FA7 07 5B 10      call _atoi        ; convert ASCII byte in B to int (to AL)
2503   0FAA F7            stosb             ; store AL to [DI]
2504   0FAB 78            inc c
2505   0FAC 0A 9E 0F      jmp __load_hex_loop
2506   0FAF             __load_hex_ret:
2507   0FAF F0            pop di
2508   0FB0 EF            pop si
2509   0FB1 E7            pop d
2510   0FB2 E5            pop b
2511   0FB3 E4            pop a
2512   0FB4 09            ret
2513   0FB5             
2514   0FB5             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2515   0FB5             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2516   0FB5             ; for each entry insIDE DIRECTORY:
2517   0FB5             ;  if entry is a file:
2518   0FB5             ;    compare filename to searched filename
2519   0FB5             ;    if filenames are the same, print filename
2520   0FB5             ;  else if entry is a directory:
2521   0FB5             ;    cd to the given directory
2522   0FB5             ;    recursively call cmd_find
2523   0FB5             ;    cd outsIDE previous directory
2524   0FB5             ;  if current entry == last entry, return
2525   0FB5             ; endfor
2526   0FB5             f_find:
2527   0FB5 09            ret
2528   0FB6             
2529   0FB6             ; FILE INCLUDES
2530   0FB6             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  0FB6             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0FB6             IDE_buffer       .EQU  $8204
0003+  0FB6             boot_origin      .EQU  $8004
0004+  0FB6             bios_uart        .EQU  $0002
0005+  0FB6             bios_ide         .EQU  $0003
2531   0FB6             .include "lib/stdio.asm"
0001+  0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0FB6             ; stdio.s
0003+  0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0FB6             .include "lib/string.asm"
0001++ 0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0FB6             ; string.s
0003++ 0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0FB6             
0005++ 0FB6             
0006++ 0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0FB6             ; _strrev
0008++ 0FB6             ; reverse a string
0009++ 0FB6             ; D = string address
0010++ 0FB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0FB6             ; 01234
0012++ 0FB6             _strrev:
0013++ 0FB6 4B          	pusha
0014++ 0FB7 07 FD 0F    	call _strlen	; length in C
0015++ 0FBA 12          	mov a, c
0016++ 0FBB AF 01 00    	cmp a, 1
0017++ 0FBE D0 D8 0F    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0FC1 7D          	dec a
0019++ 0FC2 FD 4E       	mov si, d	; beginning of string
0020++ 0FC4 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0FC6 59          	add d, a	; end of string
0022++ 0FC7 12          	mov a, c
0023++ 0FC8 FD 9B       	shr a		; divide by 2
0024++ 0FCA 39          	mov c, a	; C now counts the steps
0025++ 0FCB             _strrev_L0:
0026++ 0FCB 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0FCC F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0FCD 3E          	mov [d], al	; store left char into right side
0029++ 0FCE 1B          	mov al, bl
0030++ 0FCF F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0FD0 7E          	dec c
0032++ 0FD1 7F          	dec d
0033++ 0FD2 C2 00 00    	cmp c, 0
0034++ 0FD5 C7 CB 0F    	jne _strrev_L0
0035++ 0FD8             _strrev_end:
0036++ 0FD8 4C          	popa
0037++ 0FD9 09          	ret
0038++ 0FDA             	
0039++ 0FDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0FDA             ; _strchr
0041++ 0FDA             ; search string in D for char in AL
0042++ 0FDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0FDA             _strchr:
0044++ 0FDA             _strchr_L0:
0045++ 0FDA 32          	mov bl, [d]
0046++ 0FDB C1 00       	cmp bl, 0
0047++ 0FDD C6 E8 0F    	je _strchr_end
0048++ 0FE0 BA          	cmp al, bl
0049++ 0FE1 C6 E8 0F    	je _strchr_end
0050++ 0FE4 79          	inc d
0051++ 0FE5 0A DA 0F    	jmp _strchr_L0
0052++ 0FE8             _strchr_end:
0053++ 0FE8 1B          	mov al, bl
0054++ 0FE9 09          	ret
0055++ 0FEA             
0056++ 0FEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0FEA             ; _strstr
0058++ 0FEA             ; find sub-string
0059++ 0FEA             ; str1 in SI
0060++ 0FEA             ; str2 in DI
0061++ 0FEA             ; SI points to end of source string
0062++ 0FEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0FEA             _strstr:
0064++ 0FEA DB          	push al
0065++ 0FEB DA          	push d
0066++ 0FEC E3          	push di
0067++ 0FED             _strstr_loop:
0068++ 0FED F3          	cmpsb					; compare a byte of the strings
0069++ 0FEE C7 F9 0F    	jne _strstr_ret
0070++ 0FF1 FC 00 00    	lea d, [di + 0]
0071++ 0FF4 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0FF6 C7 ED 0F    	jne _strstr_loop				; equal chars but not at end
0073++ 0FF9             _strstr_ret:
0074++ 0FF9 F0          	pop di
0075++ 0FFA E7          	pop d
0076++ 0FFB E8          	pop al
0077++ 0FFC 09          	ret
0078++ 0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0FFD             ; length of null terminated string
0080++ 0FFD             ; result in C
0081++ 0FFD             ; pointer in D
0082++ 0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0FFD             _strlen:
0084++ 0FFD DA          	push d
0085++ 0FFE 38 00 00    	mov c, 0
0086++ 1001             _strlen_L1:
0087++ 1001 BD 00       	cmp byte [d], 0
0088++ 1003 C6 0B 10    	je _strlen_ret
0089++ 1006 79          	inc d
0090++ 1007 78          	inc c
0091++ 1008 0A 01 10    	jmp _strlen_L1
0092++ 100B             _strlen_ret:
0093++ 100B E7          	pop d
0094++ 100C 09          	ret
0095++ 100D             
0096++ 100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 100D             ; STRCMP
0098++ 100D             ; compare two strings
0099++ 100D             ; str1 in SI
0100++ 100D             ; str2 in DI
0101++ 100D             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 100D             _strcmp:
0104++ 100D DB          	push al
0105++ 100E DA          	push d
0106++ 100F E3          	push di
0107++ 1010 E2          	push si
0108++ 1011             _strcmp_loop:
0109++ 1011 F3          	cmpsb					; compare a byte of the strings
0110++ 1012 C7 1D 10    	jne _strcmp_ret
0111++ 1015 FB FF FF    	lea d, [si +- 1]
0112++ 1018 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 101A C7 11 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 101D             _strcmp_ret:
0115++ 101D EF          	pop si
0116++ 101E F0          	pop di
0117++ 101F E7          	pop d
0118++ 1020 E8          	pop al
0119++ 1021 09          	ret
0120++ 1022             
0121++ 1022             
0122++ 1022             ; STRCPY
0123++ 1022             ; copy null terminated string from SI to DI
0124++ 1022             ; source in SI
0125++ 1022             ; destination in DI
0126++ 1022             _strcpy:
0127++ 1022 E2          	push si
0128++ 1023 E3          	push di
0129++ 1024 DB          	push al
0130++ 1025             _strcpy_L1:
0131++ 1025 F6          	lodsb
0132++ 1026 F7          	stosb
0133++ 1027 B9 00       	cmp al, 0
0134++ 1029 C7 25 10    	jne _strcpy_L1
0135++ 102C             _strcpy_end:
0136++ 102C E8          	pop al
0137++ 102D F0          	pop di
0138++ 102E EF          	pop si
0139++ 102F 09          	ret
0140++ 1030             
0141++ 1030             ; STRCAT
0142++ 1030             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1030             ; source in SI
0144++ 1030             ; destination in DI
0145++ 1030             _strcat:
0146++ 1030 E2          	push si
0147++ 1031 E3          	push di
0148++ 1032 D7          	push a
0149++ 1033 DA          	push d
0150++ 1034 50          	mov a, di
0151++ 1035 3C          	mov d, a
0152++ 1036             _strcat_goto_end_L1:
0153++ 1036 BD 00       	cmp byte[d], 0
0154++ 1038 C6 3F 10    	je _strcat_start
0155++ 103B 79          	inc d
0156++ 103C 0A 36 10    	jmp _strcat_goto_end_L1
0157++ 103F             _strcat_start:
0158++ 103F FD 50       	mov di, d
0159++ 1041             _strcat_L1:
0160++ 1041 F6          	lodsb
0161++ 1042 F7          	stosb
0162++ 1043 B9 00       	cmp al, 0
0163++ 1045 C7 41 10    	jne _strcat_L1
0164++ 1048             _strcat_end:
0165++ 1048 E7          	pop d
0166++ 1049 E4          	pop a
0167++ 104A F0          	pop di
0168++ 104B EF          	pop si
0169++ 104C 09          	ret
0170++ 104D             
0171++ 104D             
0005+  104D             
0006+  104D             
0007+  104D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  104D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  104D             ; ASCII in BL
0010+  104D             ; result in AL
0011+  104D             ; ascii for F = 0100 0110
0012+  104D             ; ascii for 9 = 0011 1001
0013+  104D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  104D             hex_ascii_encode:
0015+  104D 1B            mov al, bl
0016+  104E 93 40         test al, $40        ; test if letter or number
0017+  1050 C7 56 10      jnz hex_letter
0018+  1053 87 0F         and al, $0F        ; get number
0019+  1055 09            ret
0020+  1056             hex_letter:
0021+  1056 87 0F         and al, $0F        ; get letter
0022+  1058 6A 09         add al, 9
0023+  105A 09            ret
0024+  105B             
0025+  105B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  105B             ; ATOI
0027+  105B             ; 2 letter hex string in B
0028+  105B             ; 8bit integer returned in AL
0029+  105B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  105B             _atoi:
0031+  105B D8            push b
0032+  105C 07 4D 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  105F 30            mov bl, bh
0034+  1060 DB            push al          ; save a
0035+  1061 07 4D 10      call hex_ascii_encode
0036+  1064 EA            pop bl  
0037+  1065 FD 9E 04      shl al, 4
0038+  1068 8C            or al, bl
0039+  1069 E5            pop b
0040+  106A 09            ret  
0041+  106B             
0042+  106B             
0043+  106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  106B             ; scanf
0045+  106B             ; no need for explanations!
0046+  106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  106B             scanf:
0048+  106B 09            ret
0049+  106C             
0050+  106C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  106C             ; ITOA
0052+  106C             ; 8bit value in BL
0053+  106C             ; 2 byte ASCII result in A
0054+  106C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  106C             _itoa:
0056+  106C DA            push d
0057+  106D D8            push b
0058+  106E A7 00         mov bh, 0
0059+  1070 FD A4 04      shr bl, 4  
0060+  1073 74            mov d, b
0061+  1074 1F 06 13      mov al, [d + s_hex_digits]
0062+  1077 23            mov ah, al
0063+  1078               
0064+  1078 E5            pop b
0065+  1079 D8            push b
0066+  107A A7 00         mov bh, 0
0067+  107C FD 87 0F      and bl, $0F
0068+  107F 74            mov d, b
0069+  1080 1F 06 13      mov al, [d + s_hex_digits]
0070+  1083 E5            pop b
0071+  1084 E7            pop d
0072+  1085 09            ret
0073+  1086             
0074+  1086             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1086             ; HEX STRING TO BINARY
0076+  1086             ; di = destination address
0077+  1086             ; si = source
0078+  1086             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1086             _hex_to_int:
0080+  1086             _hex_to_int_L1:
0081+  1086 F6            lodsb          ; load from [SI] to AL
0082+  1087 B9 00         cmp al, 0        ; check if ASCII 0
0083+  1089 C6 96 10      jz _hex_to_int_ret
0084+  108C 36            mov bh, al
0085+  108D F6            lodsb
0086+  108E 2F            mov bl, al
0087+  108F 07 5B 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  1092 F7            stosb          ; store AL to [DI]
0089+  1093 0A 86 10      jmp _hex_to_int_L1
0090+  1096             _hex_to_int_ret:
0091+  1096 09            ret    
0092+  1097             
0093+  1097             
0094+  1097             
0095+  1097             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1097             ; GETCHAR
0097+  1097             ; char in ah
0098+  1097             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1097             getch:
0100+  1097 DB            push al
0101+  1098             getch_retry:
0102+  1098 19 01         mov al, 1
0103+  109A 05 03         syscall sys_io      ; receive in AH
0104+  109C E8            pop al
0105+  109D 09            ret
0106+  109E             
0107+  109E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  109E             ; PUTCHAR
0109+  109E             ; char in ah
0110+  109E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  109E             _putchar:
0112+  109E DB            push al
0113+  109F 19 00         mov al, 0
0114+  10A1 05 03         syscall sys_io      ; char in AH
0115+  10A3 E8            pop al
0116+  10A4 09            ret
0117+  10A5             
0118+  10A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  10A5             ;; INPUT A STRING
0120+  10A5             ;; terminates with null
0121+  10A5             ;; pointer in D
0122+  10A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  10A5             _gets:
0124+  10A5 D7            push a
0125+  10A6 DA            push d
0126+  10A7             _gets_loop:
0127+  10A7 19 01         mov al, 1
0128+  10A9 05 03         syscall sys_io      ; receive in AH
0129+  10AB 76 1B         cmp ah, 27
0130+  10AD C6 CE 10      je _gets_ansi_esc
0131+  10B0 76 0A         cmp ah, $0A        ; LF
0132+  10B2 C6 2A 11      je _gets_end
0133+  10B5 76 0D         cmp ah, $0D        ; CR
0134+  10B7 C6 2A 11      je _gets_end
0135+  10BA 76 5C         cmp ah, $5C        ; '\\'
0136+  10BC C6 F0 10      je _gets_escape
0137+  10BF 76 08         cmp ah, $08      ; check for backspace
0138+  10C1 C6 CA 10      je _gets_backspace
0139+  10C4 1A            mov al, ah
0140+  10C5 3E            mov [d], al
0141+  10C6 79            inc d
0142+  10C7 0A A7 10      jmp _gets_loop
0143+  10CA             _gets_backspace:
0144+  10CA 7F            dec d
0145+  10CB 0A A7 10      jmp _gets_loop
0146+  10CE             _gets_ansi_esc:
0147+  10CE 19 01         mov al, 1
0148+  10D0 05 03         syscall sys_io        ; receive in AH without echo
0149+  10D2 76 5B         cmp ah, '['
0150+  10D4 C7 A7 10      jne _gets_loop
0151+  10D7 19 01         mov al, 1
0152+  10D9 05 03         syscall sys_io          ; receive in AH without echo
0153+  10DB 76 44         cmp ah, 'D'
0154+  10DD C6 E8 10      je _gets_left_arrow
0155+  10E0 76 43         cmp ah, 'C'
0156+  10E2 C6 EC 10      je _gets_right_arrow
0157+  10E5 0A A7 10      jmp _gets_loop
0158+  10E8             _gets_left_arrow:
0159+  10E8 7F            dec d
0160+  10E9 0A A7 10      jmp _gets_loop
0161+  10EC             _gets_right_arrow:
0162+  10EC 79            inc d
0163+  10ED 0A A7 10      jmp _gets_loop
0164+  10F0             _gets_escape:
0165+  10F0 19 01         mov al, 1
0166+  10F2 05 03         syscall sys_io      ; receive in AH
0167+  10F4 76 6E         cmp ah, 'n'
0168+  10F6 C6 15 11      je _gets_LF
0169+  10F9 76 72         cmp ah, 'r'
0170+  10FB C6 1C 11      je _gets_CR
0171+  10FE 76 30         cmp ah, '0'
0172+  1100 C6 23 11      je _gets_NULL
0173+  1103 76 5C         cmp ah, $5C  ; '\'
0174+  1105 C6 0E 11      je _gets_slash
0175+  1108 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  1109 3E            mov [d], al
0177+  110A 79            inc d
0178+  110B 0A A7 10      jmp _gets_loop
0179+  110E             _gets_slash:
0180+  110E 19 5C         mov al, $5C
0181+  1110 3E            mov [d], al
0182+  1111 79            inc d
0183+  1112 0A A7 10      jmp _gets_loop
0184+  1115             _gets_LF:
0185+  1115 19 0A         mov al, $0A
0186+  1117 3E            mov [d], al
0187+  1118 79            inc d
0188+  1119 0A A7 10      jmp _gets_loop
0189+  111C             _gets_CR:
0190+  111C 19 0D         mov al, $0D
0191+  111E 3E            mov [d], al
0192+  111F 79            inc d
0193+  1120 0A A7 10      jmp _gets_loop
0194+  1123             _gets_NULL:
0195+  1123 19 00         mov al, $00
0196+  1125 3E            mov [d], al
0197+  1126 79            inc d
0198+  1127 0A A7 10      jmp _gets_loop
0199+  112A             _gets_end:
0200+  112A 19 00         mov al, 0
0201+  112C 3E            mov [d], al        ; terminate string
0202+  112D E7            pop d
0203+  112E E4            pop a
0204+  112F 09            ret
0205+  1130             
0206+  1130             
0207+  1130             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1130             ;; INPUT TEXT
0209+  1130             ;; terminated with CTRL+D
0210+  1130             ;; pointer in D
0211+  1130             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1130             _gettxt:
0213+  1130 D7            push a
0214+  1131 DA            push d
0215+  1132             _gettxt_loop:
0216+  1132 19 01         mov al, 1
0217+  1134 05 03         syscall sys_io      ; receive in AH
0218+  1136 76 04         cmp ah, 4      ; EOT
0219+  1138 C6 71 11      je _gettxt_end
0220+  113B 76 08         cmp ah, $08      ; check for backspace
0221+  113D C6 6D 11      je _gettxt_backspace
0222+  1140 76 5C         cmp ah, $5C        ; '\'
0223+  1142 C6 4B 11      je _gettxt_escape
0224+  1145 1A            mov al, ah
0225+  1146 3E            mov [d], al
0226+  1147 79            inc d
0227+  1148 0A 32 11      jmp _gettxt_loop
0228+  114B             _gettxt_escape:
0229+  114B 19 01         mov al, 1
0230+  114D 05 03         syscall sys_io      ; receive in AH
0231+  114F 76 6E         cmp ah, 'n'
0232+  1151 C6 5F 11      je _gettxt_LF
0233+  1154 76 72         cmp ah, 'r'
0234+  1156 C6 66 11      je _gettxt_CR
0235+  1159 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  115A 3E            mov [d], al
0237+  115B 79            inc d
0238+  115C 0A 32 11      jmp _gettxt_loop
0239+  115F             _gettxt_LF:
0240+  115F 19 0A         mov al, $0A
0241+  1161 3E            mov [d], al
0242+  1162 79            inc d
0243+  1163 0A 32 11      jmp _gettxt_loop
0244+  1166             _gettxt_CR:
0245+  1166 19 0D         mov al, $0D
0246+  1168 3E            mov [d], al
0247+  1169 79            inc d
0248+  116A 0A 32 11      jmp _gettxt_loop
0249+  116D             _gettxt_backspace:
0250+  116D 7F            dec d
0251+  116E 0A 32 11      jmp _gettxt_loop
0252+  1171             _gettxt_end:
0253+  1171 19 00         mov al, 0
0254+  1173 3E            mov [d], al        ; terminate string
0255+  1174 E7            pop d
0256+  1175 E4            pop a
0257+  1176 09            ret
0258+  1177             
0259+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  1177             ; PRINT NEW LINE
0261+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  1177             printnl:
0263+  1177 D7            push a
0264+  1178 10 00 0A      mov a, $0A00
0265+  117B 05 03         syscall sys_io
0266+  117D 10 00 0D      mov a, $0D00
0267+  1180 05 03         syscall sys_io
0268+  1182 E4            pop a
0269+  1183 09            ret
0270+  1184             
0271+  1184             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  1184             ; _strtoint
0273+  1184             ; 4 digit hex string number in d
0274+  1184             ; integer returned in A
0275+  1184             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1184             _strtointx:
0277+  1184 D8            push b
0278+  1185 32            mov bl, [d]
0279+  1186 37            mov bh, bl
0280+  1187 33 01 00      mov bl, [d + 1]
0281+  118A 07 5B 10      call _atoi        ; convert to int in AL
0282+  118D 23            mov ah, al        ; move to AH
0283+  118E 33 02 00      mov bl, [d + 2]
0284+  1191 37            mov bh, bl
0285+  1192 33 03 00      mov bl, [d + 3]
0286+  1195 07 5B 10      call _atoi        ; convert to int in AL
0287+  1198 E5            pop b
0288+  1199 09            ret
0289+  119A             
0290+  119A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  119A             ; _strtoint
0292+  119A             ; 5 digit base10 string number in d
0293+  119A             ; integer returned in A
0294+  119A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  119A             _strtoint:
0296+  119A E2            push si
0297+  119B D8            push b
0298+  119C D9            push c
0299+  119D DA            push d
0300+  119E 07 FD 0F      call _strlen      ; get string length in C
0301+  11A1 7E            dec c
0302+  11A2 FD 4E         mov si, d
0303+  11A4 12            mov a, c
0304+  11A5 FD 99         shl a
0305+  11A7 3B 1E 13      mov d, table_power
0306+  11AA 59            add d, a
0307+  11AB 38 00 00      mov c, 0
0308+  11AE             _strtoint_L0:
0309+  11AE F6            lodsb      ; load ASCII to al
0310+  11AF B9 00         cmp al, 0
0311+  11B1 C6 C4 11      je _strtoint_end
0312+  11B4 6F 30         sub al, $30    ; make into integer
0313+  11B6 22 00         mov ah, 0
0314+  11B8 2A            mov b, [d]
0315+  11B9 AC            mul a, b      ; result in B since it fits in 16bits
0316+  11BA 11            mov a, b
0317+  11BB 28            mov b, c
0318+  11BC 54            add a, b
0319+  11BD 39            mov c, a
0320+  11BE 63 02 00      sub d, 2
0321+  11C1 0A AE 11      jmp _strtoint_L0
0322+  11C4             _strtoint_end:
0323+  11C4 12            mov a, c
0324+  11C5 E7            pop d
0325+  11C6 E6            pop c
0326+  11C7 E5            pop b
0327+  11C8 EF            pop si
0328+  11C9 09            ret
0329+  11CA             
0330+  11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  11CA             ; PRINT NULL TERMINATED STRING
0332+  11CA             ; pointer in D
0333+  11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  11CA             _puts:
0335+  11CA D7            push a
0336+  11CB DA            push d
0337+  11CC             _puts_L1:
0338+  11CC 1E            mov al, [d]
0339+  11CD B9 00         cmp al, 0
0340+  11CF C6 DB 11      jz _puts_END
0341+  11D2 23            mov ah, al
0342+  11D3 19 00         mov al, 0
0343+  11D5 05 03         syscall sys_io
0344+  11D7 79            inc d
0345+  11D8 0A CC 11      jmp _puts_L1
0346+  11DB             _puts_END:
0347+  11DB E7            pop d
0348+  11DC E4            pop a
0349+  11DD 09            ret
0350+  11DE             
0351+  11DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  11DE             ; PRINT N SIZE STRING
0353+  11DE             ; pointer in D
0354+  11DE             ; size in C
0355+  11DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  11DE             _putsn:
0357+  11DE DB            push al
0358+  11DF DA            push d
0359+  11E0 D9            push c
0360+  11E1             _putsn_L0:
0361+  11E1 1E            mov al, [d]
0362+  11E2 23            mov ah, al
0363+  11E3 19 00         mov al, 0
0364+  11E5 05 03         syscall sys_io
0365+  11E7 79            inc d
0366+  11E8 7E            dec c  
0367+  11E9 C2 00 00      cmp c, 0
0368+  11EC C7 E1 11      jne _putsn_L0
0369+  11EF             _putsn_end:
0370+  11EF E6            pop c
0371+  11F0 E7            pop d
0372+  11F1 E8            pop al
0373+  11F2 09            ret
0374+  11F3             
0375+  11F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  11F3             ; print 16bit decimal number
0377+  11F3             ; input number in A
0378+  11F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  11F3             print_u16d:
0380+  11F3 D7            push a
0381+  11F4 D8            push b
0382+  11F5 FD D8         push g
0383+  11F7 26 10 27      mov b, 10000
0384+  11FA AE            div a, b      ; get 10000's coeff.
0385+  11FB 07 1F 12      call print_number
0386+  11FE 11            mov a, b
0387+  11FF 26 E8 03      mov b, 1000
0388+  1202 AE            div a, b      ; get 1000's coeff.
0389+  1203 07 1F 12      call print_number
0390+  1206 11            mov a, b
0391+  1207 26 64 00      mov b, 100
0392+  120A AE            div a, b
0393+  120B 07 1F 12      call print_number
0394+  120E 11            mov a, b
0395+  120F 26 0A 00      mov b, 10
0396+  1212 AE            div a, b
0397+  1213 07 1F 12      call print_number
0398+  1216 1B            mov al, bl      ; 1's coeff in bl
0399+  1217 07 1F 12      call print_number
0400+  121A FD F1         pop g
0401+  121C E5            pop b
0402+  121D E4            pop a
0403+  121E 09            ret
0404+  121F             
0405+  121F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  121F             ; print AL
0407+  121F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  121F             print_number:
0409+  121F 6A 30         add al, $30
0410+  1221 23            mov ah, al
0411+  1222 07 9E 10      call _putchar
0412+  1225 09            ret
0413+  1226             
0414+  1226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  1226             ; PRINT 16BIT HEX INTEGER
0416+  1226             ; integer value in reg B
0417+  1226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  1226             print_u16x:
0419+  1226 D7            push a
0420+  1227 D8            push b
0421+  1228 DD            push bl
0422+  1229 30            mov bl, bh
0423+  122A 07 6C 10      call _itoa        ; convert bh to char in A
0424+  122D 2F            mov bl, al        ; save al
0425+  122E 19 00         mov al, 0
0426+  1230 05 03         syscall sys_io        ; display AH
0427+  1232 24            mov ah, bl        ; retrieve al
0428+  1233 19 00         mov al, 0
0429+  1235 05 03         syscall sys_io        ; display AL
0430+  1237             
0431+  1237 EA            pop bl
0432+  1238 07 6C 10      call _itoa        ; convert bh to char in A
0433+  123B 2F            mov bl, al        ; save al
0434+  123C 19 00         mov al, 0
0435+  123E 05 03         syscall sys_io        ; display AH
0436+  1240 24            mov ah, bl        ; retrieve al
0437+  1241 19 00         mov al, 0
0438+  1243 05 03         syscall sys_io        ; display AL
0439+  1245             
0440+  1245 E5            pop b
0441+  1246 E4            pop a
0442+  1247 09            ret
0443+  1248             
0444+  1248             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  1248             ; INPUT 16BIT HEX INTEGER
0446+  1248             ; read 16bit integer into A
0447+  1248             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  1248             scan_u16x:
0449+  1248 F8 10 00      enter 16
0450+  124B D8            push b
0451+  124C DA            push d
0452+  124D             
0453+  124D FA F1 FF      lea d, [bp + -15]
0454+  1250 07 A5 10      call _gets        ; get number
0455+  1253             
0456+  1253 32            mov bl, [d]
0457+  1254 37            mov bh, bl
0458+  1255 33 01 00      mov bl, [d + 1]
0459+  1258 07 5B 10      call _atoi        ; convert to int in AL
0460+  125B 23            mov ah, al        ; move to AH
0461+  125C             
0462+  125C 33 02 00      mov bl, [d + 2]
0463+  125F 37            mov bh, bl
0464+  1260 33 03 00      mov bl, [d + 3]
0465+  1263 07 5B 10      call _atoi        ; convert to int in AL
0466+  1266             
0467+  1266 E7            pop d
0468+  1267 E5            pop b
0469+  1268 F9            leave
0470+  1269 09            ret
0471+  126A             
0472+  126A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  126A             ; PRINT 8bit HEX INTEGER
0474+  126A             ; integer value in reg bl
0475+  126A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  126A             print_u8x:
0477+  126A D7            push a
0478+  126B DD            push bl
0479+  126C             
0480+  126C 07 6C 10      call _itoa        ; convert bl to char in A
0481+  126F 2F            mov bl, al        ; save al
0482+  1270 19 00         mov al, 0
0483+  1272 05 03         syscall sys_io        ; display AH
0484+  1274 24            mov ah, bl        ; retrieve al
0485+  1275 19 00         mov al, 0
0486+  1277 05 03         syscall sys_io        ; display AL
0487+  1279             
0488+  1279 EA            pop bl
0489+  127A E4            pop a
0490+  127B 09            ret
0491+  127C             
0492+  127C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  127C             ; print 8bit decimal unsigned number
0494+  127C             ; input number in AL
0495+  127C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  127C             print_u8d:
0497+  127C D7            push a
0498+  127D D8            push b
0499+  127E FD D8         push g
0500+  1280 22 00         mov ah, 0
0501+  1282 26 64 00      mov b, 100
0502+  1285 AE            div a, b
0503+  1286 D8            push b      ; save remainder
0504+  1287 B9 00         cmp al, 0
0505+  1289 C6 93 12      je skip100
0506+  128C 6A 30         add al, $30
0507+  128E 23            mov ah, al
0508+  128F 19 00         mov al, 0
0509+  1291 05 03         syscall sys_io  ; print coeff
0510+  1293             skip100:
0511+  1293 E4            pop a
0512+  1294 22 00         mov ah, 0
0513+  1296 26 0A 00      mov b, 10
0514+  1299 AE            div a, b
0515+  129A D8            push b      ; save remainder
0516+  129B B9 00         cmp al, 0
0517+  129D C6 A7 12      je skip10
0518+  12A0 6A 30         add al, $30
0519+  12A2 23            mov ah, al
0520+  12A3 19 00         mov al, 0
0521+  12A5 05 03         syscall sys_io  ; print coeff
0522+  12A7             skip10:
0523+  12A7 E4            pop a
0524+  12A8 1B            mov al, bl
0525+  12A9 6A 30         add al, $30
0526+  12AB 23            mov ah, al
0527+  12AC 19 00         mov al, 0
0528+  12AE 05 03         syscall sys_io  ; print coeff
0529+  12B0 FD F1         pop g
0530+  12B2 E5            pop b
0531+  12B3 E4            pop a
0532+  12B4 09            ret
0533+  12B5             
0534+  12B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  12B5             ; INPUT 8BIT HEX INTEGER
0536+  12B5             ; read 8bit integer into AL
0537+  12B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  12B5             scan_u8x:
0539+  12B5 F8 04 00      enter 4
0540+  12B8 D8            push b
0541+  12B9 DA            push d
0542+  12BA             
0543+  12BA FA FD FF      lea d, [bp + -3]
0544+  12BD 07 A5 10      call _gets        ; get number
0545+  12C0             
0546+  12C0 32            mov bl, [d]
0547+  12C1 37            mov bh, bl
0548+  12C2 33 01 00      mov bl, [d + 1]
0549+  12C5 07 5B 10      call _atoi        ; convert to int in AL
0550+  12C8             
0551+  12C8 E7            pop d
0552+  12C9 E5            pop b
0553+  12CA F9            leave
0554+  12CB 09            ret
0555+  12CC             
0556+  12CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  12CC             ; input decimal number
0558+  12CC             ; result in A
0559+  12CC             ; 655'\0'
0560+  12CC             ; low--------high
0561+  12CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  12CC             scan_u16d:
0563+  12CC F8 08 00      enter 8
0564+  12CF E2            push si
0565+  12D0 D8            push b
0566+  12D1 D9            push c
0567+  12D2 DA            push d
0568+  12D3 FA F9 FF      lea d, [bp +- 7]
0569+  12D6 07 A5 10      call _gets
0570+  12D9 07 FD 0F      call _strlen      ; get string length in C
0571+  12DC 7E            dec c
0572+  12DD FD 4E         mov si, d
0573+  12DF 12            mov a, c
0574+  12E0 FD 99         shl a
0575+  12E2 3B 1E 13      mov d, table_power
0576+  12E5 59            add d, a
0577+  12E6 38 00 00      mov c, 0
0578+  12E9             mul_loop:
0579+  12E9 F6            lodsb      ; load ASCII to al
0580+  12EA B9 00         cmp al, 0
0581+  12EC C6 FF 12      je mul_exit
0582+  12EF 6F 30         sub al, $30    ; make into integer
0583+  12F1 22 00         mov ah, 0
0584+  12F3 2A            mov b, [d]
0585+  12F4 AC            mul a, b      ; result in B since it fits in 16bits
0586+  12F5 11            mov a, b
0587+  12F6 28            mov b, c
0588+  12F7 54            add a, b
0589+  12F8 39            mov c, a
0590+  12F9 63 02 00      sub d, 2
0591+  12FC 0A E9 12      jmp mul_loop
0592+  12FF             mul_exit:
0593+  12FF 12            mov a, c
0594+  1300 E7            pop d
0595+  1301 E6            pop c
0596+  1302 E5            pop b
0597+  1303 EF            pop si
0598+  1304 F9            leave
0599+  1305 09            ret
0600+  1306             
0601+  1306             
0602+  1306 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  130A 34 35 36 37 
0602+  130E 38 39 41 42 
0602+  1312 43 44 45 46 
0603+  1316 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  131A 1B 5B 48 00 
0604+  131E             
0605+  131E             table_power:
0606+  131E 01 00         .dw 1
0607+  1320 0A 00         .dw 10
0608+  1322 64 00         .dw 100
0609+  1324 E8 03         .dw 1000
0610+  1326 10 27         .dw 100002532   1328             .include "lib/ctype.asm"
0001+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1328             ; ctype.s
0003+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1328             
0005+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  1328             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  1328             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  1328             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  1328             ;; characters are supported.
0010+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  1328             ;; _isalnum 
0012+  1328             ;; _isalpha 
0013+  1328             ;; islower 
0014+  1328             ;; isupper 
0015+  1328             ;; _isdigit 
0016+  1328             ;; isxdigit
0017+  1328             ;; iscntrl 
0018+  1328             ;; isgraph 
0019+  1328             ;; _isspace 
0020+  1328             ;; isblank 
0021+  1328             ;; isprint 
0022+  1328             ;; ispunct 
0023+  1328             ;; tolower 
0024+  1328             ;; toupper
0025+  1328             
0026+  1328             
0027+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  1328             ;; IS ALPHANUMERIC
0029+  1328             ;; sets ZF according with result
0030+  1328             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  1328             _isalnum:
0032+  1328 07 45 13    	call _isalpha
0033+  132B C6 31 13    	je _isalnum_exit
0034+  132E 07 32 13    	call _isdigit
0035+  1331             _isalnum_exit:
0036+  1331 09          	ret	
0037+  1332             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1332             ;; IS DIGIT
0039+  1332             ;; sets ZF according with result
0040+  1332             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1332             _isdigit:
0042+  1332 DB          	push al
0043+  1333 B9 30       	cmp al, '0'
0044+  1335 C8 41 13    	jlu _isdigit_false
0045+  1338 B9 39       	cmp al, '9'
0046+  133A D1 41 13    	jgu _isdigit_false
0047+  133D 87 00       	and al, 0	; set ZF
0048+  133F E8          	pop al
0049+  1340 09          	ret
0050+  1341             _isdigit_false:
0051+  1341 8B 01       	or al, 1	; clear ZF
0052+  1343 E8          	pop al
0053+  1344 09          	ret	
0054+  1345             	
0055+  1345             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1345             ;; IS ALPHA
0057+  1345             ;; sets ZF according with result
0058+  1345             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1345             _isalpha:
0060+  1345 DB          	push al
0061+  1346 B9 5F       	cmp al, '_'
0062+  1348 C6 68 13    	je _isalpha_true
0063+  134B B9 2E       	cmp al, '.'
0064+  134D C6 68 13    	je _isalpha_true
0065+  1350 B9 41       	cmp al, 'A'
0066+  1352 C8 64 13    	jlu _isalpha_false
0067+  1355 B9 7A       	cmp al, 'z'
0068+  1357 D1 64 13    	jgu _isalpha_false
0069+  135A B9 5A       	cmp al, 'Z'
0070+  135C D0 68 13    	jleu _isalpha_true
0071+  135F B9 61       	cmp al, 'a'
0072+  1361 C9 68 13    	jgeu _isalpha_true
0073+  1364             _isalpha_false:
0074+  1364 8B 01       	or al, 1	; clear ZF
0075+  1366 E8          	pop al
0076+  1367 09          	ret
0077+  1368             _isalpha_true:
0078+  1368 87 00       	and al, 0	; set ZF
0079+  136A E8          	pop al
0080+  136B 09          	ret
0081+  136C             
0082+  136C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  136C             ;; IS PATH-ALPHA
0084+  136C             ;; sets ZF according with result
0085+  136C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  136C             ispath:
0087+  136C DB          	push al
0088+  136D 07 32 13    	call _isdigit
0089+  1370 C6 9A 13    	je ispath_true
0090+  1373 B9 5F       	cmp al, '_'
0091+  1375 C6 9A 13    	je ispath_true
0092+  1378 B9 2F       	cmp al, '/'
0093+  137A C6 9A 13    	je ispath_true
0094+  137D B9 2E       	cmp al, '.'
0095+  137F C6 9A 13    	je ispath_true
0096+  1382 B9 41       	cmp al, 'A'
0097+  1384 C8 96 13    	jlu ispath_false
0098+  1387 B9 7A       	cmp al, 'z'
0099+  1389 D1 96 13    	jgu ispath_false
0100+  138C B9 5A       	cmp al, 'Z'
0101+  138E D0 9A 13    	jleu ispath_true
0102+  1391 B9 61       	cmp al, 'a'
0103+  1393 C9 9A 13    	jgeu ispath_true
0104+  1396             ispath_false:
0105+  1396 8B 01       	or al, 1	; clear ZF
0106+  1398 E8          	pop al
0107+  1399 09          	ret
0108+  139A             ispath_true:
0109+  139A 87 00       	and al, 0	; set ZF
0110+  139C E8          	pop al
0111+  139D 09          	ret
0112+  139E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  139E             ;; IS SPACE
0114+  139E             ;; sets ZF according with result
0115+  139E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  139E             _isspace:
0117+  139E B9 20       	cmp al, $20		; ' '
0118+  13A0 C6 B4 13    	je _isspace_exit
0119+  13A3 B9 09       	cmp al, $09		; '\t'
0120+  13A5 C6 B4 13    	je _isspace_exit
0121+  13A8 B9 0A       	cmp al, $0A		; '\n'
0122+  13AA C6 B4 13    	je _isspace_exit
0123+  13AD B9 0D       	cmp al, $0D		; '\r'
0124+  13AF C6 B4 13    	je _isspace_exit
0125+  13B2 B9 0B       	cmp al, $0B		; '\v'
0126+  13B4             _isspace_exit:
0127+  13B4 09          	ret	
0128+  13B5             
0129+  13B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  13B5             ; TO LOWER
0131+  13B5             ; input in AL
0132+  13B5             ; output in AL
0133+  13B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  13B5             _to_lower:
0135+  13B5 B9 5A       	cmp al, 'Z'
0136+  13B7 D1 BC 13    	jgu _to_lower_ret
0137+  13BA 6A 20       	add al, $20				; convert to lower case
0138+  13BC             _to_lower_ret:
0139+  13BC 09          	ret
0140+  13BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  13BD             ; TO UPPER
0142+  13BD             ; input in AL
0143+  13BD             ; output in AL
0144+  13BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  13BD             _to_upper:
0146+  13BD B9 61       	cmp al, 'a'
0147+  13BF C8 C4 13    	jlu _to_upper_ret
0148+  13C2 6F 20       	sub al, $20			; convert to upper case
0149+  13C4             _to_upper_ret:
0150+  13C4 09          	ret
0151+  13C5             
2533   13C5             .include "lib/token.asm"
0001+  13C5             TOKTYP_IDENTIFIER  .equ 0
0002+  13C5             TOKTYP_KEYWORD     .equ 1
0003+  13C5             TOKTYP_DELIMITER   .equ 2
0004+  13C5             TOKTYP_STRING      .equ 3
0005+  13C5             TOKTYP_CHAR        .equ 4
0006+  13C5             TOKTYP_NUMERIC     .equ 5
0007+  13C5             TOKTYP_END         .equ 6
0008+  13C5             
0009+  13C5             TOK_NULL           .equ 0
0010+  13C5             TOK_FSLASH         .equ 1
0011+  13C5             TOK_TIMES          .equ 2
0012+  13C5             TOK_PLUS           .equ 3
0013+  13C5             TOK_MINUS          .equ 4
0014+  13C5             TOK_DOT            .equ 5
0015+  13C5             TOK_SEMI           .equ 6
0016+  13C5             TOK_ANGLE          .equ 7
0017+  13C5             TOK_TILDE          .equ 8
0018+  13C5             TOK_EQUAL          .equ 9
0019+  13C5             TOK_COLON          .equ 10
0020+  13C5             TOK_COMMA          .equ 11
0021+  13C5             
0022+  13C5             TOK_END            .equ 20
0023+  13C5             
0024+  13C5             
0025+  13C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  13C5             ;; read a full command argment from shell input buffer
0027+  13C5             ;; argument is written into tokstr
0028+  13C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  13C5             get_arg:
0030+  13C5 D7            push a
0031+  13C6 E2            push si
0032+  13C7 E3            push di
0033+  13C8 19 00         mov al, 0
0034+  13CA 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0035+  13CD 14 EF 15      mov a, [prog]
0036+  13D0 4D            mov si, a
0037+  13D1 FD 4F F3 15   mov di, tokstr
0038+  13D5             get_arg_skip_spaces:
0039+  13D5 F6            lodsb
0040+  13D6 07 9E 13      call _isspace
0041+  13D9 C6 D5 13      je get_arg_skip_spaces
0042+  13DC             get_arg_L0:
0043+  13DC B9 3B         cmp al, $3B        ; check if is ';'
0044+  13DE C6 EB 13      je get_arg_end
0045+  13E1 B9 00         cmp al, 0
0046+  13E3 C6 EB 13      je get_arg_end      ; check if end of input
0047+  13E6 F7            stosb
0048+  13E7 F6            lodsb
0049+  13E8 0A DC 13      jmp get_arg_L0
0050+  13EB             get_arg_end:
0051+  13EB 19 00         mov al, 0
0052+  13ED F7            stosb
0053+  13EE D5 01 00      sub si, 1
0054+  13F1 4E            mov a, si
0055+  13F2 42 EF 15      mov [prog], a    ; update pointer
0056+  13F5 F0            pop di
0057+  13F6 EF            pop si
0058+  13F7 E4            pop a
0059+  13F8 09            ret
0060+  13F9             
0061+  13F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  13F9             ;; read a path formation from shell input buffer
0063+  13F9             ;; path is written into tokstr
0064+  13F9             ;; /usr/bin
0065+  13F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  13F9             get_path:
0067+  13F9 D7            push a
0068+  13FA E2            push si
0069+  13FB E3            push di
0070+  13FC 19 00         mov al, 0
0071+  13FE 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0072+  1401 14 EF 15      mov a, [prog]
0073+  1404 4D            mov si, a
0074+  1405 FD 4F F3 15   mov di, tokstr
0075+  1409             get_path_skip_spaces:
0076+  1409 F6            lodsb
0077+  140A 07 9E 13      call _isspace
0078+  140D C6 09 14      je get_path_skip_spaces
0079+  1410             get_path_is_pathchar:
0080+  1410 F7            stosb
0081+  1411 F6            lodsb
0082+  1412 07 28 13      call _isalnum      ;check if is alphanumeric
0083+  1415 C6 10 14      je get_path_is_pathchar
0084+  1418 B9 2F         cmp al, '/'        ; check if is '/'
0085+  141A C6 10 14      je get_path_is_pathchar
0086+  141D 19 00         mov al, 0
0087+  141F F7            stosb
0088+  1420 D5 01 00      sub si, 1
0089+  1423 4E            mov a, si
0090+  1424 42 EF 15      mov [prog], a    ; update pointer
0091+  1427             get_path_end:
0092+  1427 F0            pop di
0093+  1428 EF            pop si
0094+  1429 E4            pop a
0095+  142A 09            ret
0096+  142B             
0097+  142B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  142B             ;; read a line
0099+  142B             ;; line is written into tokstr
0100+  142B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  142B             get_line:
0102+  142B D7            push a
0103+  142C E2            push si
0104+  142D E3            push di
0105+  142E 19 00         mov al, 0
0106+  1430 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0107+  1433 14 EF 15      mov a, [prog]
0108+  1436 4D            mov si, a
0109+  1437 FD 4F F3 15   mov di, tokstr
0110+  143B             get_line_L0:
0111+  143B F6            lodsb
0112+  143C B9 0A         cmp al, $0A    ; check for new line
0113+  143E C6 45 14      je get_line_exit
0114+  1441 F7            stosb
0115+  1442 0A 3B 14      jmp get_line_L0
0116+  1445             get_line_exit:
0117+  1445 19 00         mov al, 0
0118+  1447 F7            stosb
0119+  1448 4E            mov a, si
0120+  1449 42 EF 15      mov [prog], a    ; update pointer
0121+  144C F0            pop di
0122+  144D EF            pop si
0123+  144E E4            pop a
0124+  144F 09            ret
0125+  1450             
0126+  1450             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1450             ;; token parser
0128+  1450             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1450             get_token:
0130+  1450 D7            push a
0131+  1451 DA            push d
0132+  1452 E2            push si
0133+  1453 E3            push di
0134+  1454 19 00         mov al, 0
0135+  1456 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0136+  1459 19 00         mov al, TOK_NULL
0137+  145B 3D F2 15      mov [tok], al        ; nullify token
0138+  145E 14 EF 15      mov a, [prog]
0139+  1461 4D            mov si, a
0140+  1462 FD 4F F3 15   mov di, tokstr
0141+  1466             get_tok_skip_spaces:
0142+  1466 F6            lodsb
0143+  1467 07 9E 13      call _isspace
0144+  146A C6 66 14      je get_tok_skip_spaces
0145+  146D B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  146F C6 54 15      je get_token_end
0147+  1472 B9 23         cmp al, '#'      ; comments!
0148+  1474 C6 82 15      je get_tok_comment
0149+  1477 07 28 13      call _isalnum
0150+  147A C6 61 15      jz is_alphanumeric
0151+  147D             ; other token types
0152+  147D             get_token_slash:
0153+  147D B9 2F         cmp al, '/'        ; check if '/'
0154+  147F C7 97 14      jne get_token_minus
0155+  1482 F7            stosb          ; store '/' into token string
0156+  1483 19 00         mov al, 0
0157+  1485 F7            stosb          ; terminate token string
0158+  1486 19 01         mov al, TOK_FSLASH
0159+  1488 3D F2 15      mov [tok], al      
0160+  148B 19 02         mov al, TOKTYP_DELIMITER
0161+  148D 3D F1 15      mov [toktyp], al
0162+  1490 4E            mov a, si
0163+  1491 42 EF 15      mov [prog], a    ; update pointer
0164+  1494 0A 7D 15      jmp get_token_return
0165+  1497             get_token_minus:
0166+  1497 B9 2D         cmp al, '-'        ; check if '-'
0167+  1499 C7 B1 14      jne get_token_comma
0168+  149C F7            stosb          ; store '-' into token string
0169+  149D 19 00         mov al, 0
0170+  149F F7            stosb          ; terminate token string
0171+  14A0 19 04         mov al, TOK_MINUS
0172+  14A2 3D F2 15      mov [tok], al      
0173+  14A5 19 02         mov al, TOKTYP_DELIMITER
0174+  14A7 3D F1 15      mov [toktyp], al
0175+  14AA 4E            mov a, si
0176+  14AB 42 EF 15      mov [prog], a    ; update pointer
0177+  14AE 0A 7D 15      jmp get_token_return
0178+  14B1             get_token_comma:
0179+  14B1 B9 2C         cmp al, ','        ; check if ','
0180+  14B3 C7 CB 14      jne get_token_semi
0181+  14B6 F7            stosb          ; store ',' into token string
0182+  14B7 19 00         mov al, 0
0183+  14B9 F7            stosb          ; terminate token string
0184+  14BA 19 0B         mov al, TOK_COMMA
0185+  14BC 3D F2 15      mov [tok], al      
0186+  14BF 19 02         mov al, TOKTYP_DELIMITER
0187+  14C1 3D F1 15      mov [toktyp], al
0188+  14C4 4E            mov a, si
0189+  14C5 42 EF 15      mov [prog], a    ; update pointer
0190+  14C8 0A 7D 15      jmp get_token_return
0191+  14CB             get_token_semi:
0192+  14CB B9 3B         cmp al, $3B        ; check if ';'
0193+  14CD C7 E5 14      jne get_token_colon
0194+  14D0 F7            stosb          ; store ';' into token string
0195+  14D1 19 00         mov al, 0
0196+  14D3 F7            stosb          ; terminate token string
0197+  14D4 19 06         mov al, TOK_SEMI
0198+  14D6 3D F2 15      mov [tok], al      
0199+  14D9 19 02         mov al, TOKTYP_DELIMITER
0200+  14DB 3D F1 15      mov [toktyp], al
0201+  14DE 4E            mov a, si
0202+  14DF 42 EF 15      mov [prog], a    ; update pointer
0203+  14E2 0A 7D 15      jmp get_token_return
0204+  14E5             get_token_colon:
0205+  14E5 B9 3A         cmp al, $3A        ; check if ':'
0206+  14E7 C7 FF 14      jne get_token_angle
0207+  14EA F7            stosb          ; store ':' into token string
0208+  14EB 19 00         mov al, 0
0209+  14ED F7            stosb          ; terminate token string
0210+  14EE 19 0A         mov al, TOK_COLON
0211+  14F0 3D F2 15      mov [tok], al      
0212+  14F3 19 02         mov al, TOKTYP_DELIMITER
0213+  14F5 3D F1 15      mov [toktyp], al
0214+  14F8 4E            mov a, si
0215+  14F9 42 EF 15      mov [prog], a    ; update pointer
0216+  14FC 0A 7D 15      jmp get_token_return
0217+  14FF             get_token_angle:
0218+  14FF B9 3E         cmp al, $3E        ; check if '>'
0219+  1501 C7 19 15      jne get_token_tilde
0220+  1504 F7            stosb          ; store '>' into token string
0221+  1505 19 00         mov al, 0
0222+  1507 F7            stosb          ; terminate token string
0223+  1508 19 07         mov al, TOK_ANGLE
0224+  150A 3D F2 15      mov [tok], al      
0225+  150D 19 02         mov al, TOKTYP_DELIMITER
0226+  150F 3D F1 15      mov [toktyp], al
0227+  1512 4E            mov a, si
0228+  1513 42 EF 15      mov [prog], a    ; update pointer
0229+  1516 0A 7D 15      jmp get_token_return
0230+  1519             get_token_tilde:
0231+  1519 B9 7E         cmp al, '~'        ; check if '~'
0232+  151B C7 33 15      jne get_token_equal
0233+  151E F7            stosb          ; store '~' into token string
0234+  151F 19 00         mov al, 0
0235+  1521 F7            stosb          ; terminate token string
0236+  1522 19 08         mov al, TOK_TILDE
0237+  1524 3D F2 15      mov [tok], al      
0238+  1527 19 02         mov al, TOKTYP_DELIMITER
0239+  1529 3D F1 15      mov [toktyp], al
0240+  152C 4E            mov a, si
0241+  152D 42 EF 15      mov [prog], a    ; update pointer
0242+  1530 0A 7D 15      jmp get_token_return
0243+  1533             get_token_equal:
0244+  1533 B9 3D         cmp al, '='        ; check if '='
0245+  1535 C7 4D 15      jne get_token_skip
0246+  1538 F7            stosb          ; store '=' into token string
0247+  1539 19 00         mov al, 0
0248+  153B F7            stosb          ; terminate token string
0249+  153C 19 09         mov al, TOK_EQUAL
0250+  153E 3D F2 15      mov [tok], al      
0251+  1541 19 02         mov al, TOKTYP_DELIMITER
0252+  1543 3D F1 15      mov [toktyp], al
0253+  1546 4E            mov a, si
0254+  1547 42 EF 15      mov [prog], a    ; update pointer
0255+  154A 0A 7D 15      jmp get_token_return
0256+  154D             get_token_skip:
0257+  154D 4E            mov a, si
0258+  154E 42 EF 15      mov [prog], a    ; update pointer
0259+  1551 0A 7D 15      jmp get_token_return
0260+  1554             get_token_end:        ; end of file token
0261+  1554 19 14         mov al, TOK_END
0262+  1556 3D F2 15      mov [tok], al
0263+  1559 19 06         mov al, TOKTYP_END
0264+  155B 3D F1 15      mov [toktyp], al
0265+  155E 0A 7D 15      jmp get_token_return
0266+  1561             is_alphanumeric:
0267+  1561 F7            stosb
0268+  1562 F6            lodsb
0269+  1563 07 28 13      call _isalnum      ;check if is alphanumeric
0270+  1566 C6 61 15      jz is_alphanumeric
0271+  1569 B9 2E         cmp al, $2E        ; check if is '.'
0272+  156B C6 61 15      je is_alphanumeric
0273+  156E 19 00         mov al, 0
0274+  1570 F7            stosb
0275+  1571 19 00         mov al, TOKTYP_IDENTIFIER
0276+  1573 3D F1 15      mov [toktyp], al
0277+  1576 D5 01 00      sub si, 1
0278+  1579 4E            mov a, si
0279+  157A 42 EF 15      mov [prog], a    ; update pointer
0280+  157D             get_token_return:
0281+  157D F0            pop di
0282+  157E EF            pop si
0283+  157F E7            pop d
0284+  1580 E4            pop a
0285+  1581 09            ret
0286+  1582             get_tok_comment:
0287+  1582 F6            lodsb
0288+  1583 B9 0A         cmp al, $0A      ; new line
0289+  1585 C7 82 15      jne get_tok_comment
0290+  1588 0A 66 14      jmp get_tok_skip_spaces
0291+  158B             
0292+  158B             
0293+  158B             get_number:
0294+  158B D7            push a
0295+  158C DA            push d
0296+  158D E2            push si
0297+  158E E3            push di
0298+  158F 19 00         mov al, 0
0299+  1591 3D F3 15      mov [tokstr], al      ; nullify tokstr string
0300+  1594 19 00         mov al, TOK_NULL
0301+  1596 3D F2 15      mov [tok], al        ; nullify token
0302+  1599 14 EF 15      mov a, [prog]
0303+  159C 4D            mov si, a
0304+  159D FD 4F F3 15   mov di, tokstr
0305+  15A1             get_number_skip_spaces:
0306+  15A1 F6            lodsb
0307+  15A2 07 9E 13      call _isspace
0308+  15A5 C6 A1 15      je get_number_skip_spaces
0309+  15A8 B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  15AA C7 BA 15      jne get_number_L0
0311+  15AD 19 14         mov al, TOK_END
0312+  15AF 3D F2 15      mov [tok], al
0313+  15B2 19 06         mov al, TOKTYP_END
0314+  15B4 3D F1 15      mov [toktyp], al
0315+  15B7 0A D1 15      jmp get_number_return
0316+  15BA             get_number_L0:
0317+  15BA F7            stosb
0318+  15BB F6            lodsb
0319+  15BC 07 32 13      call _isdigit      ;check if is numeric
0320+  15BF C6 BA 15      jz get_number_L0
0321+  15C2 19 00         mov al, 0
0322+  15C4 F7            stosb
0323+  15C5 19 05         mov al, TOKTYP_NUMERIC
0324+  15C7 3D F1 15      mov [toktyp], al
0325+  15CA D5 01 00      sub si, 1
0326+  15CD 4E            mov a, si
0327+  15CE 42 EF 15      mov [prog], a    ; update pointer
0328+  15D1             get_number_return:
0329+  15D1 F0            pop di
0330+  15D2 EF            pop si
0331+  15D3 E7            pop d
0332+  15D4 E4            pop a
0333+  15D5 09            ret
0334+  15D6             
0335+  15D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  15D6             ;; PUT BACK TOKEN
0337+  15D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  15D6             _putback:
0339+  15D6 D7            push a
0340+  15D7 E2            push si
0341+  15D8 FD 4D F3 15   mov si, tokstr  
0342+  15DC             _putback_loop:
0343+  15DC F6            lodsb
0344+  15DD B9 00         cmp al, 0
0345+  15DF C6 EC 15      je _putback_end
0346+  15E2 14 EF 15      mov a, [prog]
0347+  15E5 7D            dec a
0348+  15E6 42 EF 15      mov [prog], a      ; update pointer
0349+  15E9 0A DC 15      jmp _putback_loop
0350+  15EC             _putback_end:
0351+  15EC EF            pop si
0352+  15ED E4            pop a
0353+  15EE 09            ret
0354+  15EF             
0355+  15EF             
0356+  15EF             
0357+  15EF             
0358+  15EF 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  15F1             
0360+  15F1 00          toktyp:    .db 0          ; token type symbol
0361+  15F2 00          tok:       .db 0          ; current token symbol
0362+  15F3 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  15F7 00 00 00 00 
0362+  15FB 00 00 00 00 
0362+  15FF 00 00 00 00 
0362+  1603 00 00 00 00 
0362+  1607 00 00 00 00 
0362+  160B 00 00 00 00 
0362+  160F 00 00 00 00 
0362+  1613 00 00 00 00 
0362+  1617 00 00 00 00 
0362+  161B 00 00 00 00 
0362+  161F 00 00 00 00 
0362+  1623 00 00 00 00 
0362+  1627 00 00 00 00 
0362+  162B 00 00 00 00 
0362+  162F 00 00 00 00 
0362+  1633 00 00 00 00 
0362+  1637 00 00 00 00 
0362+  163B 00 00 00 00 
0362+  163F 00 00 00 00 
0362+  1643 00 00 00 00 
0362+  1647 00 00 00 00 
0362+  164B 00 00 00 00 
0362+  164F 00 00 00 00 
0362+  1653 00 00 00 00 
0362+  1657 00 00 00 00 
0362+  165B 00 00 00 00 
0362+  165F 00 00 00 00 
0362+  1663 00 00 00 00 
0362+  1667 00 00 00 00 
0362+  166B 00 00 00 00 
0362+  166F 00 00 00 00 
0362+  1673 00 00 00 00 
0362+  1677 00 00 00 00 
0362+  167B 00 00 00 00 
0362+  167F 00 00 00 00 
0362+  1683 00 00 00 00 
0362+  1687 00 00 00 00 
0362+  168B 00 00 00 00 
0362+  168F 00 00 00 00 
0362+  1693 00 00 00 00 
0362+  1697 00 00 00 00 
0362+  169B 00 00 00 00 
0362+  169F 00 00 00 00 
0362+  16A3 00 00 00 00 
0362+  16A7 00 00 00 00 
0362+  16AB 00 00 00 00 
0362+  16AF 00 00 00 00 
0362+  16B3 00 00 00 00 
0362+  16B7 00 00 00 00 
0362+  16BB 00 00 00 00 
0362+  16BF 00 00 00 00 
0362+  16C3 00 00 00 00 
0362+  16C7 00 00 00 00 
0362+  16CB 00 00 00 00 
0362+  16CF 00 00 00 00 
0362+  16D3 00 00 00 00 
0362+  16D7 00 00 00 00 
0362+  16DB 00 00 00 00 
0362+  16DF 00 00 00 00 
0362+  16E3 00 00 00 00 
0362+  16E7 00 00 00 00 
0362+  16EB 00 00 00 00 
0362+  16EF 00 00 00 00 
2534   16F3             
2535   16F3             ; kernel parameters
2536   16F3 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2537   16F4 01          sys_echo_on:        .db 1
2538   16F5 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2539   16F6 01          sys_uart0_inten:    .db 1
2540   16F7 00          sys_uart0_fifoen:   .db 0
2541   16F8 06          sys_uart0_div0:     .db 6  ;
2542   16F9 00          sys_uart0_div1:     .db 0   ; default baud = 19200
2543   16FA             
2544   16FA 00          nbr_active_procs:   .db 0
2545   16FB 01          active_proc_index:  .db 1
2546   16FC             
2547   16FC 00 00       index:              .dw 0
2548   16FE 00 00       buffer_addr:        .dw 0
2549   1700             
2550   1700 FF 1D       fifo_in:            .dw fifo
2551   1702 FF 1D       fifo_out:           .dw fifo
2552   1704             
2553   1704             ; file system variables
2554   1704 00 00       current_dir_id:     .dw 0     ; keep dirID of current directory
2555   1706 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2555   170A 6E 2F 69 6E 
2555   170E 69 74 00 
2556   1711             
2557   1711 3E 20 00    s_dataentry:        .db "> ", 0
2558   1714 2E 2E 00    s_parent_dir:       .db "..", 0
2559   1717 2E 00       s_current_dir:      .db ".", 0
2560   1719 2F 00       s_fslash:           .db "/", 0
2561   171B 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2561   171F 78 
2562   1720 2D 64 63    file_type:          .db "-dc"
2563   1723 50 49 44 20 s_ps_header:        .db "PID COMMAND\n", 0
2563   1727 43 4F 4D 4D 
2563   172B 41 4E 44 0A 
2563   172F 00 
2564   1730 54 6F 74 61 s_ls_total:         .db "Total: ", 0
2564   1734 6C 3A 20 00 
2565   1738             
2566   1738 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2566   173C 20 65 6E 61 
2566   1740 62 6C 65 64 
2566   1744 0A 00 
2567   1746 6B 65 72 6E s_kernel_started:   .db "kernel started(version 1.0)\n", 0
2567   174A 65 6C 20 73 
2567   174E 74 61 72 74 
2567   1752 65 64 28 76 
2567   1756 65 72 73 69 
2567   175A 6F 6E 20 31 
2567   175E 2E 30 29 0A 
2567   1762 00 
2568   1763 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2568   1767 74 69 6E 67 
2568   176B 20 69 6E 69 
2568   176F 74 0A 00 
2569   1772 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2569   1776 65 70 74 69 
2569   177A 6F 6E 3A 20 
2569   177E 70 72 69 76 
2569   1782 69 6C 65 67 
2569   1786 65 0A 00 
2570   1789 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2570   178D 65 70 74 69 
2570   1791 6F 6E 3A 20 
2570   1795 7A 65 72 6F 
2570   1799 20 64 69 76 
2570   179D 69 73 69 6F 
2570   17A1 6E 0A 00 
2571   17A4             
2572   17A4 59 65 61 72 s_set_year:         .db "Year: ", 0
2572   17A8 3A 20 00 
2573   17AB 4D 6F 6E 74 s_set_month:        .db "Month: ", 0
2573   17AF 68 3A 20 00 
2574   17B3 44 61 79 3A s_set_day:          .db "Day: ", 0
2574   17B7 20 00 
2575   17B9 57 65 65 6B s_set_week:         .db "Weekday: ", 0
2575   17BD 64 61 79 3A 
2575   17C1 20 00 
2576   17C3 48 6F 75 72 s_set_hours:        .db "Hours: ", 0
2576   17C7 73 3A 20 00 
2577   17CB 4D 69 6E 75 s_set_minutes:      .db "Minutes: ", 0
2577   17CF 74 65 73 3A 
2577   17D3 20 00 
2578   17D5 53 65 63 6F s_set_seconds:      .db "Seconds: ", 0
2578   17D9 6E 64 73 3A 
2578   17DD 20 00 
2579   17DF             s_months:      
2580   17DF 20 20 20 00   .db "   ", 0
2581   17E3 4A 61 6E 00   .db "Jan", 0
2582   17E7 46 65 62 00   .db "Feb", 0
2583   17EB 4D 61 72 00   .db "Mar", 0
2584   17EF 41 70 72 00   .db "Apr", 0
2585   17F3 4D 61 79 00   .db "May", 0
2586   17F7 4A 75 6E 00   .db "Jun", 0
2587   17FB 4A 75 6C 00   .db "Jul", 0
2588   17FF 41 75 67 00   .db "Aug", 0
2589   1803 53 65 70 00   .db "Sep", 0
2590   1807 4F 63 74 00   .db "Oct", 0
2591   180B 4E 6F 76 00   .db "Nov", 0
2592   180F 44 65 63 00   .db "Dec", 0
2593   1813             
2594   1813             s_week:        
2595   1813 53 75 6E 00   .db "Sun", 0 
2596   1817 4D 6F 6E 00   .db "Mon", 0 
2597   181B 54 75 65 00   .db "Tue", 0 
2598   181F 57 65 64 00   .db "Wed", 0 
2599   1823 54 68 75 00   .db "Thu", 0 
2600   1827 46 72 69 00   .db "Fri", 0 
2601   182B 53 61 74 00   .db "Sat", 0
2602   182F             
2603   182F 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2603   1833 00 00 00 00 
2603   1837 00 00 00 00 
2603   183B 00 00 00 00 
2603   183F 00 00 00 00 
2603   1843 00 00 00 00 
2603   1847 00 00 00 00 
2603   184B 00 00 00 00 
2603   184F 00 00 00 00 
2603   1853 00 00 00 00 
2603   1857 00 00 00 00 
2603   185B 00 00 00 00 
2603   185F 00 00 00 00 
2603   1863 00 00 00 00 
2603   1867 00 00 00 00 
2603   186B 00 00 00 00 
2603   186F 00 00 00 00 
2603   1873 00 00 00 00 
2603   1877 00 00 00 00 
2603   187B 00 00 00 00 
2603   187F 00 00 00 00 
2603   1883 00 00 00 00 
2603   1887 00 00 00 00 
2603   188B 00 00 00 00 
2603   188F 00 00 00 00 
2603   1893 00 00 00 00 
2603   1897 00 00 00 00 
2603   189B 00 00 00 00 
2603   189F 00 00 00 00 
2603   18A3 00 00 00 00 
2603   18A7 00 00 00 00 
2603   18AB 00 00 00 00 
2603   18AF 00 00 00 00 
2603   18B3 00 00 00 00 
2603   18B7 00 00 00 00 
2603   18BB 00 00 00 00 
2603   18BF 00 00 00 00 
2603   18C3 00 00 00 00 
2603   18C7 00 00 00 00 
2603   18CB 00 00 00 00 
2603   18CF 00 00 00 00 
2603   18D3 00 00 00 00 
2603   18D7 00 00 00 00 
2603   18DB 00 00 00 00 
2603   18DF 00 00 00 00 
2603   18E3 00 00 00 00 
2603   18E7 00 00 00 00 
2603   18EB 00 00 00 00 
2603   18EF 00 00 00 00 
2603   18F3 00 00 00 00 
2603   18F7 00 00 00 00 
2603   18FB 00 00 00 00 
2603   18FF 00 00 00 00 
2603   1903 00 00 00 00 
2603   1907 00 00 00 00 
2603   190B 00 00 00 00 
2603   190F 00 00 00 00 
2603   1913 00 00 00 00 
2603   1917 00 00 00 00 
2603   191B 00 00 00 00 
2603   191F 00 00 00 00 
2603   1923 00 00 00 00 
2603   1927 00 00 00 00 
2603   192B 00 00 00 00 
2603   192F 00 00 00 00 
2603   1933 00 00 00 00 
2603   1937 00 00 00 00 
2603   193B 00 00 00 00 
2603   193F 00 00 00 00 
2603   1943 00 00 00 00 
2603   1947 00 00 00 00 
2603   194B 00 00 00 00 
2603   194F 00 00 00 00 
2603   1953 00 00 00 00 
2603   1957 00 00 00 00 
2603   195B 00 00 00 00 
2603   195F 00 00 00 00 
2603   1963 00 00 00 00 
2603   1967 00 00 00 00 
2603   196B 00 00 00 00 
2604   196F 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2604   1973 00 00 00 00 
2604   1977 00 00 00 00 
2604   197B 00 00 00 00 
2605   197F 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2605   1983 00 00 00 00 
2605   1987 00 00 00 00 
2605   198B 00 00 00 00 
2605   198F 00 00 00 00 
2605   1993 00 00 00 00 
2605   1997 00 00 00 00 
2605   199B 00 00 00 00 
2605   199F 00 00 00 00 
2605   19A3 00 00 00 00 
2605   19A7 00 00 00 00 
2605   19AB 00 00 00 00 
2605   19AF 00 00 00 00 
2605   19B3 00 00 00 00 
2605   19B7 00 00 00 00 
2605   19BB 00 00 00 00 
2605   19BF 00 00 00 00 
2605   19C3 00 00 00 00 
2605   19C7 00 00 00 00 
2605   19CB 00 00 00 00 
2605   19CF 00 00 00 00 
2605   19D3 00 00 00 00 
2605   19D7 00 00 00 00 
2605   19DB 00 00 00 00 
2605   19DF 00 00 00 00 
2605   19E3 00 00 00 00 
2605   19E7 00 00 00 00 
2605   19EB 00 00 00 00 
2605   19EF 00 00 00 00 
2605   19F3 00 00 00 00 
2605   19F7 00 00 00 00 
2605   19FB 00 00 00 00 
2605   19FF 00 00 00 00 
2605   1A03 00 00 00 00 
2605   1A07 00 00 00 00 
2605   1A0B 00 00 00 00 
2605   1A0F 00 00 00 00 
2605   1A13 00 00 00 00 
2605   1A17 00 00 00 00 
2605   1A1B 00 00 00 00 
2605   1A1F 00 00 00 00 
2605   1A23 00 00 00 00 
2605   1A27 00 00 00 00 
2605   1A2B 00 00 00 00 
2605   1A2F 00 00 00 00 
2605   1A33 00 00 00 00 
2605   1A37 00 00 00 00 
2605   1A3B 00 00 00 00 
2605   1A3F 00 00 00 00 
2605   1A43 00 00 00 00 
2605   1A47 00 00 00 00 
2605   1A4B 00 00 00 00 
2605   1A4F 00 00 00 00 
2605   1A53 00 00 00 00 
2605   1A57 00 00 00 00 
2605   1A5B 00 00 00 00 
2605   1A5F 00 00 00 00 
2605   1A63 00 00 00 00 
2605   1A67 00 00 00 00 
2605   1A6B 00 00 00 00 
2605   1A6F 00 00 00 00 
2605   1A73 00 00 00 00 
2605   1A77 00 00 00 00 
2605   1A7B 00 00 00 00 
2605   1A7F 00 00 00 00 
2605   1A83 00 00 00 00 
2605   1A87 00 00 00 00 
2605   1A8B 00 00 00 00 
2605   1A8F 00 00 00 00 
2605   1A93 00 00 00 00 
2605   1A97 00 00 00 00 
2605   1A9B 00 00 00 00 
2605   1A9F 00 00 00 00 
2605   1AA3 00 00 00 00 
2605   1AA7 00 00 00 00 
2605   1AAB 00 00 00 00 
2605   1AAF 00 00 00 00 
2605   1AB3 00 00 00 00 
2605   1AB7 00 00 00 00 
2605   1ABB 00 00 00 00 
2605   1ABF 00 00 00 00 
2605   1AC3 00 00 00 00 
2605   1AC7 00 00 00 00 
2605   1ACB 00 00 00 00 
2605   1ACF 00 00 00 00 
2605   1AD3 00 00 00 00 
2605   1AD7 00 00 00 00 
2605   1ADB 00 00 00 00 
2605   1ADF 00 00 00 00 
2605   1AE3 00 00 00 00 
2605   1AE7 00 00 00 00 
2605   1AEB 00 00 00 00 
2605   1AEF 00 00 00 00 
2605   1AF3 00 00 00 00 
2605   1AF7 00 00 00 00 
2605   1AFB 00 00 00 00 
2605   1AFF 00 00 00 00 
2605   1B03 00 00 00 00 
2605   1B07 00 00 00 00 
2605   1B0B 00 00 00 00 
2605   1B0F 00 00 00 00 
2605   1B13 00 00 00 00 
2605   1B17 00 00 00 00 
2605   1B1B 00 00 00 00 
2605   1B1F 00 00 00 00 
2605   1B23 00 00 00 00 
2605   1B27 00 00 00 00 
2605   1B2B 00 00 00 00 
2605   1B2F 00 00 00 00 
2605   1B33 00 00 00 00 
2605   1B37 00 00 00 00 
2605   1B3B 00 00 00 00 
2605   1B3F 00 00 00 00 
2605   1B43 00 00 00 00 
2605   1B47 00 00 00 00 
2605   1B4B 00 00 00 00 
2605   1B4F 00 00 00 00 
2605   1B53 00 00 00 00 
2605   1B57 00 00 00 00 
2605   1B5B 00 00 00 00 
2605   1B5F 00 00 00 00 
2605   1B63 00 00 00 00 
2605   1B67 00 00 00 00 
2605   1B6B 00 00 00 00 
2605   1B6F 00 00 00 00 
2605   1B73 00 00 00 00 
2605   1B77 00 00 00 00 
2605   1B7B 00 00 00 00 
2606   1B7F 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2606   1B83 00 00 00 00 
2606   1B87 00 00 00 00 
2606   1B8B 00 00 00 00 
2606   1B8F 00 00 00 00 
2606   1B93 00 00 00 00 
2606   1B97 00 00 00 00 
2606   1B9B 00 00 00 00 
2606   1B9F 00 00 00 00 
2606   1BA3 00 00 00 00 
2606   1BA7 00 00 00 00 
2606   1BAB 00 00 00 00 
2606   1BAF 00 00 00 00 
2606   1BB3 00 00 00 00 
2606   1BB7 00 00 00 00 
2606   1BBB 00 00 00 00 
2606   1BBF 00 00 00 00 
2606   1BC3 00 00 00 00 
2606   1BC7 00 00 00 00 
2606   1BCB 00 00 00 00 
2606   1BCF 00 00 00 00 
2606   1BD3 00 00 00 00 
2606   1BD7 00 00 00 00 
2606   1BDB 00 00 00 00 
2606   1BDF 00 00 00 00 
2606   1BE3 00 00 00 00 
2606   1BE7 00 00 00 00 
2606   1BEB 00 00 00 00 
2606   1BEF 00 00 00 00 
2606   1BF3 00 00 00 00 
2606   1BF7 00 00 00 00 
2606   1BFB 00 00 00 00 
2607   1BFF 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2607   1C03 00 00 00 00 
2607   1C07 00 00 00 00 
2607   1C0B 00 00 00 00 
2607   1C0F 00 00 00 00 
2607   1C13 00 00 00 00 
2607   1C17 00 00 00 00 
2607   1C1B 00 00 00 00 
2607   1C1F 00 00 00 00 
2607   1C23 00 00 00 00 
2607   1C27 00 00 00 00 
2607   1C2B 00 00 00 00 
2607   1C2F 00 00 00 00 
2607   1C33 00 00 00 00 
2607   1C37 00 00 00 00 
2607   1C3B 00 00 00 00 
2607   1C3F 00 00 00 00 
2607   1C43 00 00 00 00 
2607   1C47 00 00 00 00 
2607   1C4B 00 00 00 00 
2607   1C4F 00 00 00 00 
2607   1C53 00 00 00 00 
2607   1C57 00 00 00 00 
2607   1C5B 00 00 00 00 
2607   1C5F 00 00 00 00 
2607   1C63 00 00 00 00 
2607   1C67 00 00 00 00 
2607   1C6B 00 00 00 00 
2607   1C6F 00 00 00 00 
2607   1C73 00 00 00 00 
2607   1C77 00 00 00 00 
2607   1C7B 00 00 00 00 
2607   1C7F 00 00 00 00 
2607   1C83 00 00 00 00 
2607   1C87 00 00 00 00 
2607   1C8B 00 00 00 00 
2607   1C8F 00 00 00 00 
2607   1C93 00 00 00 00 
2607   1C97 00 00 00 00 
2607   1C9B 00 00 00 00 
2607   1C9F 00 00 00 00 
2607   1CA3 00 00 00 00 
2607   1CA7 00 00 00 00 
2607   1CAB 00 00 00 00 
2607   1CAF 00 00 00 00 
2607   1CB3 00 00 00 00 
2607   1CB7 00 00 00 00 
2607   1CBB 00 00 00 00 
2607   1CBF 00 00 00 00 
2607   1CC3 00 00 00 00 
2607   1CC7 00 00 00 00 
2607   1CCB 00 00 00 00 
2607   1CCF 00 00 00 00 
2607   1CD3 00 00 00 00 
2607   1CD7 00 00 00 00 
2607   1CDB 00 00 00 00 
2607   1CDF 00 00 00 00 
2607   1CE3 00 00 00 00 
2607   1CE7 00 00 00 00 
2607   1CEB 00 00 00 00 
2607   1CEF 00 00 00 00 
2607   1CF3 00 00 00 00 
2607   1CF7 00 00 00 00 
2607   1CFB 00 00 00 00 
2607   1CFF 00 00 00 00 
2607   1D03 00 00 00 00 
2607   1D07 00 00 00 00 
2607   1D0B 00 00 00 00 
2607   1D0F 00 00 00 00 
2607   1D13 00 00 00 00 
2607   1D17 00 00 00 00 
2607   1D1B 00 00 00 00 
2607   1D1F 00 00 00 00 
2607   1D23 00 00 00 00 
2607   1D27 00 00 00 00 
2607   1D2B 00 00 00 00 
2607   1D2F 00 00 00 00 
2607   1D33 00 00 00 00 
2607   1D37 00 00 00 00 
2607   1D3B 00 00 00 00 
2607   1D3F 00 00 00 00 
2607   1D43 00 00 00 00 
2607   1D47 00 00 00 00 
2607   1D4B 00 00 00 00 
2607   1D4F 00 00 00 00 
2607   1D53 00 00 00 00 
2607   1D57 00 00 00 00 
2607   1D5B 00 00 00 00 
2607   1D5F 00 00 00 00 
2607   1D63 00 00 00 00 
2607   1D67 00 00 00 00 
2607   1D6B 00 00 00 00 
2607   1D6F 00 00 00 00 
2607   1D73 00 00 00 00 
2607   1D77 00 00 00 00 
2607   1D7B 00 00 00 00 
2607   1D7F 00 00 00 00 
2607   1D83 00 00 00 00 
2607   1D87 00 00 00 00 
2607   1D8B 00 00 00 00 
2607   1D8F 00 00 00 00 
2607   1D93 00 00 00 00 
2607   1D97 00 00 00 00 
2607   1D9B 00 00 00 00 
2607   1D9F 00 00 00 00 
2607   1DA3 00 00 00 00 
2607   1DA7 00 00 00 00 
2607   1DAB 00 00 00 00 
2607   1DAF 00 00 00 00 
2607   1DB3 00 00 00 00 
2607   1DB7 00 00 00 00 
2607   1DBB 00 00 00 00 
2607   1DBF 00 00 00 00 
2607   1DC3 00 00 00 00 
2607   1DC7 00 00 00 00 
2607   1DCB 00 00 00 00 
2607   1DCF 00 00 00 00 
2607   1DD3 00 00 00 00 
2607   1DD7 00 00 00 00 
2607   1DDB 00 00 00 00 
2607   1DDF 00 00 00 00 
2607   1DE3 00 00 00 00 
2607   1DE7 00 00 00 00 
2607   1DEB 00 00 00 00 
2607   1DEF 00 00 00 00 
2607   1DF3 00 00 00 00 
2607   1DF7 00 00 00 00 
2607   1DFB 00 00 00 00 
2608   1DFF FF FF FF FF fifo:               .fill FIFO_SIZE
2608   1E03 FF FF FF FF 
2608   1E07 FF FF FF FF 
2608   1E0B FF FF FF FF 
2608   1E0F FF FF FF FF 
2608   1E13 FF FF FF FF 
2608   1E17 FF FF FF FF 
2608   1E1B FF FF FF FF 
2608   1E1F FF FF FF FF 
2608   1E23 FF FF FF FF 
2608   1E27 FF FF FF FF 
2608   1E2B FF FF FF FF 
2608   1E2F FF FF FF FF 
2608   1E33 FF FF FF FF 
2608   1E37 FF FF FF FF 
2608   1E3B FF FF FF FF 
2608   1E3F FF FF FF FF 
2608   1E43 FF FF FF FF 
2608   1E47 FF FF FF FF 
2608   1E4B FF FF FF FF 
2608   1E4F FF FF FF FF 
2608   1E53 FF FF FF FF 
2608   1E57 FF FF FF FF 
2608   1E5B FF FF FF FF 
2608   1E5F FF FF FF FF 
2608   1E63 FF FF FF FF 
2608   1E67 FF FF FF FF 
2608   1E6B FF FF FF FF 
2608   1E6F FF FF FF FF 
2608   1E73 FF FF FF FF 
2608   1E77 FF FF FF FF 
2608   1E7B FF FF FF FF 
2608   1E7F FF FF FF FF 
2608   1E83 FF FF FF FF 
2608   1E87 FF FF FF FF 
2608   1E8B FF FF FF FF 
2608   1E8F FF FF FF FF 
2608   1E93 FF FF FF FF 
2608   1E97 FF FF FF FF 
2608   1E9B FF FF FF FF 
2608   1E9F FF FF FF FF 
2608   1EA3 FF FF FF FF 
2608   1EA7 FF FF FF FF 
2608   1EAB FF FF FF FF 
2608   1EAF FF FF FF FF 
2608   1EB3 FF FF FF FF 
2608   1EB7 FF FF FF FF 
2608   1EBB FF FF FF FF 
2608   1EBF FF FF FF FF 
2608   1EC3 FF FF FF FF 
2608   1EC7 FF FF FF FF 
2608   1ECB FF FF FF FF 
2608   1ECF FF FF FF FF 
2608   1ED3 FF FF FF FF 
2608   1ED7 FF FF FF FF 
2608   1EDB FF FF FF FF 
2608   1EDF FF FF FF FF 
2608   1EE3 FF FF FF FF 
2608   1EE7 FF FF FF FF 
2608   1EEB FF FF FF FF 
2608   1EEF FF FF FF FF 
2608   1EF3 FF FF FF FF 
2608   1EF7 FF FF FF FF 
2608   1EFB FF FF FF FF 
2608   1EFF FF FF FF FF 
2608   1F03 FF FF FF FF 
2608   1F07 FF FF FF FF 
2608   1F0B FF FF FF FF 
2608   1F0F FF FF FF FF 
2608   1F13 FF FF FF FF 
2608   1F17 FF FF FF FF 
2608   1F1B FF FF FF FF 
2608   1F1F FF FF FF FF 
2608   1F23 FF FF FF FF 
2608   1F27 FF FF FF FF 
2608   1F2B FF FF FF FF 
2608   1F2F FF FF FF FF 
2608   1F33 FF FF FF FF 
2608   1F37 FF FF FF FF 
2608   1F3B FF FF FF FF 
2608   1F3F FF FF FF FF 
2608   1F43 FF FF FF FF 
2608   1F47 FF FF FF FF 
2608   1F4B FF FF FF FF 
2608   1F4F FF FF FF FF 
2608   1F53 FF FF FF FF 
2608   1F57 FF FF FF FF 
2608   1F5B FF FF FF FF 
2608   1F5F FF FF FF FF 
2608   1F63 FF FF FF FF 
2608   1F67 FF FF FF FF 
2608   1F6B FF FF FF FF 
2608   1F6F FF FF FF FF 
2608   1F73 FF FF FF FF 
2608   1F77 FF FF FF FF 
2608   1F7B FF FF FF FF 
2608   1F7F FF FF FF FF 
2608   1F83 FF FF FF FF 
2608   1F87 FF FF FF FF 
2608   1F8B FF FF FF FF 
2608   1F8F FF FF FF FF 
2608   1F93 FF FF FF FF 
2608   1F97 FF FF FF FF 
2608   1F9B FF FF FF FF 
2608   1F9F FF FF FF FF 
2608   1FA3 FF FF FF FF 
2608   1FA7 FF FF FF FF 
2608   1FAB FF FF FF FF 
2608   1FAF FF FF FF FF 
2608   1FB3 FF FF FF FF 
2608   1FB7 FF FF FF FF 
2608   1FBB FF FF FF FF 
2608   1FBF FF FF FF FF 
2608   1FC3 FF FF FF FF 
2608   1FC7 FF FF FF FF 
2608   1FCB FF FF FF FF 
2608   1FCF FF FF FF FF 
2608   1FD3 FF FF FF FF 
2608   1FD7 FF FF FF FF 
2608   1FDB FF FF FF FF 
2608   1FDF FF FF FF FF 
2608   1FE3 FF FF FF FF 
2608   1FE7 FF FF FF FF 
2608   1FEB FF FF FF FF 
2608   1FEF FF FF FF FF 
2608   1FF3 FF FF FF FF 
2608   1FF7 FF FF FF FF 
2608   1FFB FF FF FF FF 
2608   1FFF FF FF FF FF 
2608   2003 FF FF FF FF 
2608   2007 FF FF FF FF 
2608   200B FF FF FF FF 
2608   200F FF FF FF FF 
2608   2013 FF FF FF FF 
2608   2017 FF FF FF FF 
2608   201B FF FF FF FF 
2608   201F FF FF FF FF 
2608   2023 FF FF FF FF 
2608   2027 FF FF FF FF 
2608   202B FF FF FF FF 
2608   202F FF FF FF FF 
2608   2033 FF FF FF FF 
2608   2037 FF FF FF FF 
2608   203B FF FF FF FF 
2608   203F FF FF FF FF 
2608   2043 FF FF FF FF 
2608   2047 FF FF FF FF 
2608   204B FF FF FF FF 
2608   204F FF FF FF FF 
2608   2053 FF FF FF FF 
2608   2057 FF FF FF FF 
2608   205B FF FF FF FF 
2608   205F FF FF FF FF 
2608   2063 FF FF FF FF 
2608   2067 FF FF FF FF 
2608   206B FF FF FF FF 
2608   206F FF FF FF FF 
2608   2073 FF FF FF FF 
2608   2077 FF FF FF FF 
2608   207B FF FF FF FF 
2608   207F FF FF FF FF 
2608   2083 FF FF FF FF 
2608   2087 FF FF FF FF 
2608   208B FF FF FF FF 
2608   208F FF FF FF FF 
2608   2093 FF FF FF FF 
2608   2097 FF FF FF FF 
2608   209B FF FF FF FF 
2608   209F FF FF FF FF 
2608   20A3 FF FF FF FF 
2608   20A7 FF FF FF FF 
2608   20AB FF FF FF FF 
2608   20AF FF FF FF FF 
2608   20B3 FF FF FF FF 
2608   20B7 FF FF FF FF 
2608   20BB FF FF FF FF 
2608   20BF FF FF FF FF 
2608   20C3 FF FF FF FF 
2608   20C7 FF FF FF FF 
2608   20CB FF FF FF FF 
2608   20CF FF FF FF FF 
2608   20D3 FF FF FF FF 
2608   20D7 FF FF FF FF 
2608   20DB FF FF FF FF 
2608   20DF FF FF FF FF 
2608   20E3 FF FF FF FF 
2608   20E7 FF FF FF FF 
2608   20EB FF FF FF FF 
2608   20EF FF FF FF FF 
2608   20F3 FF FF FF FF 
2608   20F7 FF FF FF FF 
2608   20FB FF FF FF FF 
2608   20FF FF FF FF FF 
2608   2103 FF FF FF FF 
2608   2107 FF FF FF FF 
2608   210B FF FF FF FF 
2608   210F FF FF FF FF 
2608   2113 FF FF FF FF 
2608   2117 FF FF FF FF 
2608   211B FF FF FF FF 
2608   211F FF FF FF FF 
2608   2123 FF FF FF FF 
2608   2127 FF FF FF FF 
2608   212B FF FF FF FF 
2608   212F FF FF FF FF 
2608   2133 FF FF FF FF 
2608   2137 FF FF FF FF 
2608   213B FF FF FF FF 
2608   213F FF FF FF FF 
2608   2143 FF FF FF FF 
2608   2147 FF FF FF FF 
2608   214B FF FF FF FF 
2608   214F FF FF FF FF 
2608   2153 FF FF FF FF 
2608   2157 FF FF FF FF 
2608   215B FF FF FF FF 
2608   215F FF FF FF FF 
2608   2163 FF FF FF FF 
2608   2167 FF FF FF FF 
2608   216B FF FF FF FF 
2608   216F FF FF FF FF 
2608   2173 FF FF FF FF 
2608   2177 FF FF FF FF 
2608   217B FF FF FF FF 
2608   217F FF FF FF FF 
2608   2183 FF FF FF FF 
2608   2187 FF FF FF FF 
2608   218B FF FF FF FF 
2608   218F FF FF FF FF 
2608   2193 FF FF FF FF 
2608   2197 FF FF FF FF 
2608   219B FF FF FF FF 
2608   219F FF FF FF FF 
2608   21A3 FF FF FF FF 
2608   21A7 FF FF FF FF 
2608   21AB FF FF FF FF 
2608   21AF FF FF FF FF 
2608   21B3 FF FF FF FF 
2608   21B7 FF FF FF FF 
2608   21BB FF FF FF FF 
2608   21BF FF FF FF FF 
2608   21C3 FF FF FF FF 
2608   21C7 FF FF FF FF 
2608   21CB FF FF FF FF 
2608   21CF FF FF FF FF 
2608   21D3 FF FF FF FF 
2608   21D7 FF FF FF FF 
2608   21DB FF FF FF FF 
2608   21DF FF FF FF FF 
2608   21E3 FF FF FF FF 
2608   21E7 FF FF FF FF 
2608   21EB FF FF FF FF 
2608   21EF FF FF FF FF 
2608   21F3 FF FF FF FF 
2608   21F7 FF FF FF FF 
2608   21FB FF FF FF FF 
2609   21FF             
2610   21FF FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2610   2203 FF FF FF FF 
2610   2207 FF FF FF FF 
2610   220B FF FF FF FF 
2610   220F FF FF FF FF 
2610   2213 FF FF FF FF 
2610   2217 FF FF FF FF 
2610   221B FF FF FF FF 
2610   221F FF FF FF FF 
2610   2223 FF FF FF FF 
2610   2227 FF FF FF FF 
2610   222B FF FF FF FF 
2610   222F FF FF FF FF 
2610   2233 FF FF FF FF 
2610   2237 FF FF FF FF 
2610   223B FF FF FF FF 
2610   223F FF FF FF FF 
2610   2243 FF FF FF FF 
2610   2247 FF FF FF FF 
2610   224B FF FF FF FF 
2610   224F FF FF FF FF 
2610   2253 FF FF FF FF 
2610   2257 FF FF FF FF 
2610   225B FF FF FF FF 
2610   225F FF FF FF FF 
2610   2263 FF FF FF FF 
2610   2267 FF FF FF FF 
2610   226B FF FF FF FF 
2610   226F FF FF FF FF 
2610   2273 FF FF FF FF 
2610   2277 FF FF FF FF 
2610   227B FF FF FF FF 
2610   227F FF FF FF FF 
2610   2283 FF FF FF FF 
2610   2287 FF FF FF FF 
2610   228B FF FF FF FF 
2610   228F FF FF FF FF 
2610   2293 FF FF FF FF 
2610   2297 FF FF FF FF 
2610   229B FF FF FF FF 
2610   229F FF FF FF FF 
2610   22A3 FF FF FF FF 
2610   22A7 FF FF FF FF 
2610   22AB FF FF FF FF 
2610   22AF FF FF FF FF 
2610   22B3 FF FF FF FF 
2610   22B7 FF FF FF FF 
2610   22BB FF FF FF FF 
2610   22BF FF FF FF FF 
2610   22C3 FF FF FF FF 
2610   22C7 FF FF FF FF 
2610   22CB FF FF FF FF 
2610   22CF FF FF FF FF 
2610   22D3 FF FF FF FF 
2610   22D7 FF FF FF FF 
2610   22DB FF FF FF FF 
2610   22DF FF FF FF FF 
2610   22E3 FF FF FF FF 
2610   22E7 FF FF FF FF 
2610   22EB FF FF FF FF 
2610   22EF FF FF FF FF 
2610   22F3 FF FF FF FF 
2610   22F7 FF FF FF FF 
2610   22FB FF FF FF FF 
2610   22FF FF FF FF FF 
2610   2303 FF FF FF FF 
2610   2307 FF FF FF FF 
2610   230B FF FF FF FF 
2610   230F FF FF FF FF 
2610   2313 FF FF FF FF 
2610   2317 FF FF FF FF 
2610   231B FF FF FF FF 
2610   231F FF FF FF FF 
2610   2323 FF FF FF FF 
2610   2327 FF FF FF FF 
2610   232B FF FF FF FF 
2610   232F FF FF FF FF 
2610   2333 FF FF FF FF 
2610   2337 FF FF FF FF 
2610   233B FF FF FF FF 
2610   233F FF FF FF FF 
2610   2343 FF FF FF FF 
2610   2347 FF FF FF FF 
2610   234B FF FF FF FF 
2610   234F FF FF FF FF 
2610   2353 FF FF FF FF 
2610   2357 FF FF FF FF 
2610   235B FF FF FF FF 
2610   235F FF FF FF FF 
2610   2363 FF FF FF FF 
2610   2367 FF FF FF FF 
2610   236B FF FF FF FF 
2610   236F FF FF FF FF 
2610   2373 FF FF FF FF 
2610   2377 FF FF FF FF 
2610   237B FF FF FF FF 
2610   237F FF FF FF FF 
2610   2383 FF FF FF FF 
2610   2387 FF FF FF FF 
2610   238B FF FF FF FF 
2610   238F FF FF FF FF 
2610   2393 FF FF FF FF 
2610   2397 FF FF FF FF 
2610   239B FF FF FF FF 
2610   239F FF FF FF FF 
2610   23A3 FF FF FF FF 
2610   23A7 FF FF FF FF 
2610   23AB FF FF FF FF 
2610   23AF FF FF FF FF 
2610   23B3 FF FF FF FF 
2610   23B7 FF FF FF FF 
2610   23BB FF FF FF FF 
2610   23BF FF FF FF FF 
2610   23C3 FF FF FF FF 
2610   23C7 FF FF FF FF 
2610   23CB FF FF FF FF 
2610   23CF FF FF FF FF 
2610   23D3 FF FF FF FF 
2610   23D7 FF FF FF FF 
2610   23DB FF FF FF FF 
2610   23DF FF FF FF FF 
2610   23E3 FF FF FF FF 
2610   23E7 FF FF FF FF 
2610   23EB FF FF FF FF 
2610   23EF FF FF FF FF 
2610   23F3 FF FF FF FF 
2610   23F7 FF FF FF FF 
2610   23FB FF FF FF FF 
2611   23FF 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2612   2400             
2613   2400             
2614   2400             .end
tasm: Number of errors = 0
