0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             ; Memory Map
0005   0000             ; ------------------------------------------------------------------------------------------------------------------;
0006   0000             ; 0000    ROM BEGIN
0007   0000             ; ....
0008   0000             ; 7FFF    ROM END
0009   0000             ;
0010   0000             ; 8000    RAM begin
0011   0000             ; ....
0012   0000             ; F7FF    Stack root
0013   0000             ; ------------------------------------------------------------------------------------------------------------------;
0014   0000             ; I/O MAP
0015   0000             ; ------------------------------------------------------------------------------------------------------------------;
0016   0000             ; FF80    UART 0              (16550)
0017   0000             ; FF90    UART 1              (16550)
0018   0000             ; FFA0    RTC                 (M48T02)
0019   0000             ; FFB0    PIO 0               (8255)
0020   0000             ; FFC0    5.25" Floppy Drive Block
0021   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0022   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0023   0000             ;   - FFC8      WD1770 Status/Command    
0024   0000             ;   - FFC9      WD1770 Track Register
0025   0000             ;   - FFCA      WD1770 Sector Register
0026   0000             ;   - FFCB      WD1770 Data Register
0027   0000             ;      
0028   0000             ; FFD0    IDE                 (Compact Flash / PATA)
0029   0000             ; FFE0    Timer               (8253)
0030   0000             ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0031   0000             ; ------------------------------------------------------------------------------------------------------------------;
0032   0000             
0033   0000             ; ------------------------------------------------------------------------------------------------------------------;
0034   0000             ; System Constants
0035   0000             ; ------------------------------------------------------------------------------------------------------------------;
0036   0000             _UART0_DATA       .equ $FF80            ; data
0037   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0038   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0039   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0040   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0041   0000             _UART0_LCR        .equ $FF83            ; line control register
0042   0000             _UART0_LSR        .equ $FF85            ; line status register
0043   0000             
0044   0000             _UART1_DATA       .equ $FF90            ; data
0045   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0046   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0047   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0048   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0049   0000             _UART1_LCR        .equ $FF93            ; line control register
0050   0000             _UART1_LSR        .equ $FF95            ; line status register
0051   0000             
0052   0000             XON               .equ $11
0053   0000             XOFF              .equ $13
0054   0000             
0055   0000             _ide_BASE         .equ $FFD0            ; IDE BASE
0056   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0057   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0058   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0059   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0060   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0061   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0062   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0063   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0064   0000             
0065   0000             _7SEG_DISPLAY     .equ $FFB0            ; BIOS POST CODE HEX DISPLAY (2 DIGITS) (CONNECTED TO PIO A)
0066   0000             _BIOS_POST_CTRL   .equ $FFB3            ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0067   0000             _PIO_A            .equ $FFB0    
0068   0000             _PIO_B            .equ $FFB1
0069   0000             _PIO_C            .equ $FFB2
0070   0000             _PIO_CONTROL      .equ $FFB3            ; PIO CONTROL PORT
0071   0000             
0072   0000             _FDC_CONFIG       .equ $FFC0 
0073   0000             _FDC_STATUS_1     .equ $FFC1
0074   0000             _FDC_WD_STAT_CMD  .equ $FFC8
0075   0000             _FDC_WD_TRACK     .equ $FFC9
0076   0000             _FDC_WD_SECTOR    .equ $FFCA
0077   0000             _FDC_WD_DATA      .equ $FFCB
0078   0000             
0079   0000             _TIMER_C_0        .equ $FFE0            ; TIMER COUNTER 0
0080   0000             _TIMER_C_1        .equ $FFE1            ; TIMER COUNTER 1
0081   0000             _TIMER_C_2        .equ $FFE2            ; TIMER COUNTER 2
0082   0000             _TIMER_CTRL       .equ $FFE3            ; TIMER CONTROL REGISTER
0083   0000             
0084   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0085   0000             FIFO_SIZE         .equ 1024
0086   0000             
0087   0000             text_org          .equ $400
0088   0000             ; ------------------------------------------------------------------------------------------------------------------;
0089   0000             
0090   0000             
0091   0000             ; For the next iteration:
0092   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0093   0000             ; inode-table format:
0094   0000             ;  file-type(f, d)
0095   0000             ;  permissons
0096   0000             ;  link-count
0097   0000             ;  filesize
0098   0000             ;  time-stamps
0099   0000             ;  15 data block pointers
0100   0000             ;  single-indirect pointer
0101   0000             
0102   0000             ; FILE ENTRY ATTRIBUTES
0103   0000             ; filename (24)
0104   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0105   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0106   0000             ; size (2)             : filesize
0107   0000             ; day (1)           
0108   0000             ; month (1)
0109   0000             ; year (1)
0110   0000             ; packet size = 32 bytes  : total packet size in bytes
0111   0000             
0112   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0113   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0114   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0115   0000             FST_NBR_DIRECTORIES     .equ 64
0116   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0117   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0118   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0119   0000             FST_LBA_START           .equ 32
0120   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0121   0000             
0122   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0123   0000             FS_SECTORS_PER_FILE     .equ 32         ; the first sector is always a header with a NULL parameter (first byte)
0124   0000                                                     ; so that we know which blocks are free or taken
0125   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0126   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0127   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0128   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0129   0000             
0130   0000             root_id:                .equ FST_LBA_START
0131   0000             
0132   0000             ; ------------------------------------------------------------------------------------------------------------------;
0133   0000             ; GLOBAL SYSTEM VARIABLES
0134   0000             ; ------------------------------------------------------------------------------------------------------------------;
0135   0000             
0136   0000             ; ------------------------------------------------------------------------------------------------------------------;
0137   0000             ; IRQ Table
0138   0000             ; Highest priority at lowest address
0139   0000             ; ------------------------------------------------------------------------------------------------------------------;
0140   0000 3C 00       .dw int_0_fdc
0141   0002 43 00       .dw int_1
0142   0004 44 00       .dw int_2
0143   0006 45 00       .dw int_3
0144   0008 46 00       .dw int_4
0145   000A 47 00       .dw int_5
0146   000C 59 00       .dw int_6
0147   000E A5 00       .dw int_7_uart0
0148   0010             
0149   0010             ; ------------------------------------------------------------------------------------------------------------------;
0150   0010             ; Reset Vector
0151   0010             ; ------------------------------------------------------------------------------------------------------------------;
0152   0010 FB 0F       .dw kernel_reset_vector
0153   0012             
0154   0012             ; ------------------------------------------------------------------------------------------------------------------;
0155   0012             ; Exception Vector Table
0156   0012             ; Total of 7 entries, starting at address $0012
0157   0012             ; ------------------------------------------------------------------------------------------------------------------;
0158   0012 F3 01       .dw trap_privilege
0159   0014 10 03       .dw trap_div_zero
0160   0016 1D 03       .dw trap_undef_opcode
0161   0018 00 00       .dw 0
0162   001A 00 00       .dw 0
0163   001C 00 00       .dw 0
0164   001E 00 00       .dw 0
0165   0020             
0166   0020             ; ------------------------------------------------------------------------------------------------------------------;
0167   0020             ; System Call Vector Table
0168   0020             ; Starts at address $0020
0169   0020             ; ------------------------------------------------------------------------------------------------------------------;
0170   0020 FF 01       .dw syscall_break
0171   0022 1E 03       .dw syscall_rtc
0172   0024 58 04       .dw syscall_ide
0173   0026 33 05       .dw syscall_io
0174   0028 F0 05       .dw syscall_file_system
0175   002A 48 0F       .dw syscall_create_proc
0176   002C B8 01       .dw syscall_list_procs
0177   002E 50 03       .dw syscall_datetime
0178   0030 74 01       .dw syscall_reboot
0179   0032 12 0F       .dw syscall_pause_proc
0180   0034 80 01       .dw syscall_resume_proc
0181   0036 CF 0E       .dw syscall_terminate_proc
0182   0038 E4 00       .dw syscall_system
0183   003A 14 01       .dw syscall_fdc
0184   003C             
0185   003C             ; ------------------------------------------------------------------------------------------------------------------;
0186   003C             ; System Call Aliases
0187   003C             ; ------------------------------------------------------------------------------------------------------------------;
0188   003C             sys_break            .equ 0
0189   003C             sys_rtc              .equ 1
0190   003C             sys_ide              .equ 2
0191   003C             sys_io               .equ 3
0192   003C             sys_filesystem       .equ 4
0193   003C             sys_create_proc      .equ 5
0194   003C             sys_list_proc        .equ 6
0195   003C             sys_datetime         .equ 7
0196   003C             sys_reboot           .equ 8
0197   003C             sys_pause_proc       .equ 9
0198   003C             sys_resume_proc      .equ 10
0199   003C             sys_terminate_proc   .equ 11
0200   003C             sys_system           .equ 12
0201   003C             sys_fdc              .equ 13
0202   003C             
0203   003C             ; ------------------------------------------------------------------------------------------------------------------;
0204   003C             ; Alias Exports
0205   003C             ; ------------------------------------------------------------------------------------------------------------------;
0206   003C             .export text_org
0207   003C             .export sys_break
0208   003C             .export sys_rtc
0209   003C             .export sys_ide
0210   003C             .export sys_io
0211   003C             .export sys_filesystem
0212   003C             .export sys_create_proc
0213   003C             .export sys_list_proc
0214   003C             .export sys_datetime
0215   003C             .export sys_reboot
0216   003C             .export sys_pause_proc
0217   003C             .export sys_resume_proc
0218   003C             .export sys_terminate_proc
0219   003C             .export sys_system
0220   003C             .export sys_fdc
0221   003C             
0222   003C             ; ------------------------------------------------------------------------------------------------------------------;
0223   003C             ; IRQs' Code Block
0224   003C             ; ------------------------------------------------------------------------------------------------------------------;
0225   003C             ; 5.25" Floppy Drive Controller IRQ
0226   003C             int_0_fdc:
0227   003C 3B 48 00      mov d, s_fdc_irq
0228   003F 07 45 12      call _puts
0229   0042 06            sysret
0230   0043             int_1:
0231   0043 06            sysret
0232   0044             int_2:
0233   0044 06            sysret
0234   0045             int_3:
0235   0045 06            sysret
0236   0046             int_4:
0237   0046 06            sysret
0238   0047             int_5:
0239   0047 06            sysret
0240   0048             
0241   0048 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
0241   004C 30 20 45 78 
0241   0050 65 63 75 74 
0241   0054 65 64 2E 0A 
0241   0058 00 
0242   0059             
0243   0059             ; ------------------------------------------------------------------------------------------------------------------;
0244   0059             ; Process Swapping
0245   0059             ; ------------------------------------------------------------------------------------------------------------------;
0246   0059             int_6:  
0247   0059 4B            pusha ; save all registers into kernel stack
0248   005A 22 00         mov ah, 0
0249   005C 1D 76 17      mov al, [active_proc_index]
0250   005F FD 99         shl a              ; x2
0251   0061 B7 C5 0F      mov a, [proc_table_convert + a]  ; get process state start index
0252   0064 4F            mov di, a
0253   0065 48            mov a, sp
0254   0066 77            inc a
0255   0067 4D            mov si, a
0256   0068 38 14 00      mov c, 20
0257   006B FD F5         rep movsb          ; save process state!
0258   006D             ; restore kernel stack position to point before interrupt arrived
0259   006D 51 14 00      add sp, 20
0260   0070             ; now load next process in queue
0261   0070 1D 76 17      mov al, [active_proc_index]
0262   0073 31 75 17      mov bl, [nbr_active_procs]
0263   0076 BA            cmp al, bl
0264   0077 C6 7E 00      je int6_cycle_back
0265   007A 7A            inc al            ; next process is next in the series
0266   007B 0A 80 00      jmp int6_continue
0267   007E             int6_cycle_back:
0268   007E 19 01         mov al, 1        ; next process = process 1
0269   0080             int6_continue:
0270   0080 3D 76 17      mov [active_proc_index], al    ; set next active proc
0271   0083             
0272   0083             ; calculate LUT entry for next process
0273   0083 22 00         mov ah, 0
0274   0085 FD 99         shl a              ; x2
0275   0087 B7 C5 0F      mov a, [proc_table_convert + a]    ; get process state start index  
0276   008A               
0277   008A 4D            mov si, a            ; source is proc state block
0278   008B 48            mov a, sp
0279   008C 5F 13 00      sub a, 19
0280   008F 4F            mov di, a            ; destination is kernel stack
0281   0090             ; restore SP
0282   0090 7D            dec a
0283   0091 47            mov sp, a
0284   0092 38 14 00      mov c, 20
0285   0095 FD F5         rep movsb
0286   0097             ; set VM process
0287   0097 1D 76 17      mov al, [active_proc_index]
0288   009A 01            setptb
0289   009B F2 E0 FF 00   mov byte[_TIMER_C_0], 0        ; load counter 0 low byte
0290   009F F2 E0 FF 10   mov byte[_TIMER_C_0], $10        ; load counter 0 high byte
0291   00A3 4C            popa
0292   00A4 06            sysret
0293   00A5             
0294   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0295   00A5             ; UART0 Interrupt
0296   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0297   00A5             int_7_uart0:
0298   00A5 D7            push a
0299   00A6 DA            push d
0300   00A7 E1            pushf
0301   00A8 14 7B 17      mov a, [fifo_in]
0302   00AB 3C            mov d, a
0303   00AC 1D 80 FF      mov al, [_UART0_DATA]  ; get character
0304   00AF B9 03         cmp al, $03        ; CTRL-C
0305   00B1 C6 CE 00      je CTRLC
0306   00B4 B9 1A         cmp al, $1A        ; CTRL-Z
0307   00B6 C6 D4 00      je CTRLZ
0308   00B9 3E            mov [d], al        ; add to fifo
0309   00BA 14 7B 17      mov a, [fifo_in]
0310   00BD 77            inc a
0311   00BE AF BC 24      cmp a, fifo + FIFO_SIZE         ; check if pointer reached the end of the fifo
0312   00C1 C7 C7 00      jne int_7_continue
0313   00C4 10 BC 20      mov a, fifo  
0314   00C7             int_7_continue:  
0315   00C7 42 7B 17      mov [fifo_in], a      ; update fifo pointer
0316   00CA EE            popf
0317   00CB E7            pop d
0318   00CC E4            pop a  
0319   00CD 06            sysret
0320   00CE             CTRLC:
0321   00CE 51 05 00      add sp, 5
0322   00D1 0A CF 0E      jmp syscall_terminate_proc
0323   00D4             CTRLZ:
0324   00D4 EE            popf
0325   00D5 E7            pop d
0326   00D6 E4            pop a
0327   00D7 0A 12 0F      jmp syscall_pause_proc    ; pause current process and go back to the shell
0328   00DA             
0329   00DA             
0330   00DA             
0331   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0332   00DA             ; System Syscalls
0333   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0334   00DA             system_jmptbl:
0335   00DA 10 01         .dw system_uname
0336   00DC 11 01         .dw system_whoami
0337   00DE 0D 01         .dw system_setparam
0338   00E0 EA 00         .dw system_bootloader_install
0339   00E2 E8 00         .dw system_getparam
0340   00E4             syscall_system:
0341   00E4 FD 0A DA 00   jmp [system_jmptbl + al]
0342   00E8             
0343   00E8             ; param register address in register d
0344   00E8             ; param value in register bl
0345   00E8             system_getparam:
0346   00E8 32            mov bl, [d]
0347   00E9 06            sysret
0348   00EA             
0349   00EA             ; kernel LBA address in 'b'
0350   00EA             system_bootloader_install:
0351   00EA D8            push b
0352   00EB 26 00 00      mov b, 0
0353   00EE 38 00 00      mov c, 0
0354   00F1 22 01         mov ah, $01                 ; 1 sector
0355   00F3 3B BC 26      mov d, transient_area
0356   00F6 07 A2 04      call ide_read_sect          ; read sector
0357   00F9 E5            pop b
0358   00FA FD 44 FE 01   mov [d + 510], b            ; update LBA address
0359   00FE 26 00 00      mov b, 0
0360   0101 38 00 00      mov c, 0
0361   0104 22 01         mov ah, $01                 ; 1 sector
0362   0106 3B BC 26      mov d, transient_area
0363   0109 07 C8 04      call ide_write_sect         ; write sector
0364   010C 06            sysret
0365   010D             
0366   010D             ; param register address in register d
0367   010D             ; param value in register bl
0368   010D             system_setparam:
0369   010D FD 3E         mov [d], bl
0370   010F 06            sysret
0371   0110             
0372   0110             system_uname:
0373   0110 06            sysret
0374   0111             
0375   0111             system_whoami:
0376   0111 06            sysret
0377   0112             
0378   0112             
0379   0112             ; the floppy control below is not yet tested. it needs to be tested.
0380   0112             ; fdc_40_FF:     .fill 40,  $FF  ; or 00                                                                                
0381   0112             ; fdc_6_00_0:    .fill 6,   $00  ;                                                                            <--|        
0382   0112             ; fdc_id_fe:     .fill 1,   $FE  ; ID Address Mark                                                               |        
0383   0112             ; fdc_track:     .fill 1,   $00  ; Track Number                                                                  |                    
0384   0112             ; fdc_side:      .fill 1,   $00  ; Side Number 00 or 01                                                          |                
0385   0112             ; fdc_sector:    .fill 1,   $01  ; Sector Number  1 through 10                                                   |                              
0386   0112             ; fdc_length:    .fill 1,   $00  ; Sector Length                                                                 |                        
0387   0112             ; fdc_2_crc_0:   .fill 1,   $F7  ; 2 CRC's Written                                                               | Write 16 times                 
0388   0112             ; fdc_11_ff:     .fill 11,  $FF  ; or 00                                                                         |                      
0389   0112             ; fdc_6_00_1:    .fill 6,   $00  ;                                                                               |                        
0390   0112             ; fdc_data_addr: .fill 1,   $FB  ; Data Address Mark                                                             |                                  
0391   0112             ; fdc_data:      .fill 128, $E5  ; Data (IBM uses E5)                                                            |                                      
0392   0112             ; fdc_2_crc_1:   .fill 1,   $F7  ; 2 CRC's Written                                                               |                                                        
0393   0112             ; fdc_10_ff:     .fill 10,  $FF  ; or 00                                                                      <--|                                                  
0394   0112             ; fdc_369_ff:    .fill 369, $FF  ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0395   0112             ; ***************************************************************************************************************
0396   0112             ; _FDC_CONFIG       .equ $FFC0 
0397   0112             ; _FDC_STATUS_1     .equ $FFC1
0398   0112             ; _FDC_WD_STAT_CMD  .equ $FFC8
0399   0112             ; _FDC_WD_TRACK     .equ $FFC9
0400   0112             ; _FDC_WD_SECTOR    .equ $FFCA
0401   0112             ; _FDC_WD_DATA      .equ $FFCB
0402   0112             fdc_jmptbl:
0403   0112 18 01         .dw syscall_fdc_format
0404   0114             syscall_fdc:
0405   0114 FD 0A 12 01   jmp [fdc_jmptbl + al]
0406   0118             
0407   0118             syscall_fdc_format:
0408   0118 FD 22 FF 00   mov g, $FF
0409   011C             fdc_wait_busy:
0410   011C 1D C8 FF      mov al, [_FDC_WD_STAT_CMD] ; read wd1770 status register
0411   011F 87 01         and al, $01                ; busy bit
0412   0121 C7 1C 01      jnz fdc_wait_busy
0413   0124             
0414   0124 FD 4D AA 18   mov si, fdc_40_FF
0415   0128 38 D1 00      mov c, 209
0416   012B             fdc_sector_loop:
0417   012B             fdc_drq_loop:
0418   012B 3B C1 FF      mov d, _FDC_STATUS_1
0419   012E 1E            mov al, [d]
0420   012F 87 01         and al, $01               ; check drq bit
0421   0131 C6 2B 01      jz fdc_drq_loop
0422   0134 F6            lodsb                     ; load format byte
0423   0135 3B CB FF      mov d, _FDC_WD_DATA       ; data register
0424   0138 3E            mov [d], al               ; send data byte to wd1770
0425   0139 7E            dec c
0426   013A C7 2B 01      jnz fdc_sector_loop
0427   013D 3B DB 18      mov d, fdc_sector
0428   0140 32            mov bl, [d]
0429   0141 FD 77         inc b
0430   0143 FD 3E         mov [d], bl
0431   0145 C1 0B         cmp bl, 11
0432   0147 C7 2B 01      jne fdc_sector_loop       ; continue formatting
0433   014A             
0434   014A             ; here all the sectors have been written. now fill in remaining of the track until wd1770 interrupts out
0435   014A             fdc_drq_loop_fill:
0436   014A 3B C1 FF      mov d, _FDC_STATUS_1
0437   014D 1E            mov al, [d]
0438   014E 87 01         and al, $01               ; check drq bit
0439   0150 C6 4A 01      jz fdc_drq_loop_fill
0440   0153 3B CB FF      mov d, _FDC_WD_DATA       ; data register
0441   0156 FD 1A         mov al, gl
0442   0158 3E            mov [d], al               ; send data byte to wd1770
0443   0159 0C            lodstat
0444   015A 1A            mov al, ah
0445   015B 87 01         and al, $01
0446   015D C6 4A 01      jz fdc_drq_loop_fill
0447   0160             
0448   0160             
0449   0160             
0450   0160 06            sysret
0451   0161             
0452   0161 0A 46 6F 72 s_format_done: .db "\nFormatting done.\n", 0
0452   0165 6D 61 74 74 
0452   0169 69 6E 67 20 
0452   016D 64 6F 6E 65 
0452   0171 2E 0A 00 
0453   0174             
0454   0174             ; REBOOT SYSTEM
0455   0174             syscall_reboot:
0456   0174 FD D7 FF FF   push word $FFFF 
0457   0178 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0458   017B FD D7 C0 01   push word BIOS_RESET_VECTOR    ; and then push RESET VECTOR of the shell to the stack
0459   017F 06            sysret
0460   0180             
0461   0180             ;------------------------------------------------------------------------------------------------------;;
0462   0180             ; switch to another process
0463   0180             ; inputs:
0464   0180             ; AL = new process number
0465   0180             ;------------------------------------------------------------------------------------------------------;;
0466   0180             syscall_resume_proc:
0467   0180 FD 78         mov g, a                            ; save the process number
0468   0182 4B            pusha                               ; save all registers into kernel stack
0469   0183 22 00         mov ah, 0
0470   0185 1D 76 17      mov al, [active_proc_index]
0471   0188 FD 99         shl a              ; x2
0472   018A B7 C5 0F      mov a, [proc_table_convert + a]     ; get process state start index
0473   018D 4F            mov di, a
0474   018E 48            mov a, sp
0475   018F 77            inc a
0476   0190 4D            mov si, a
0477   0191 38 14 00      mov c, 20
0478   0194 FD F5         rep movsb                           ; save process state!
0479   0196             ; restore kernel stack position to point before interrupt arrived
0480   0196 51 14 00      add sp, 20
0481   0199             ; now load the new process number!
0482   0199 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0483   019B 3D 76 17      mov [active_proc_index], al         ; set new active proc
0484   019E             ; calculate LUT entry for next process
0485   019E 22 00         mov ah, 0
0486   01A0 FD 99         shl a                               ; x2
0487   01A2 B7 C5 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0488   01A5 4D            mov si, a                           ; source is proc state block
0489   01A6 48            mov a, sp
0490   01A7 5F 13 00      sub a, 19
0491   01AA 4F            mov di, a                           ; destination is kernel stack
0492   01AB             ; restore SP
0493   01AB 7D            dec a
0494   01AC 47            mov sp, a
0495   01AD 38 14 00      mov c, 20
0496   01B0 FD F5         rep movsb
0497   01B2             ; set VM process
0498   01B2 1D 76 17      mov al, [active_proc_index]
0499   01B5 01            setptb
0500   01B6 4C            popa
0501   01B7 06            sysret
0502   01B8             
0503   01B8             syscall_list_procs:
0504   01B8 3B 9E 17      mov d, s_ps_header
0505   01BB 07 45 12      call _puts
0506   01BE 3B 2D 1C      mov d, proc_availab_table + 1
0507   01C1 38 01 00      mov c, 1
0508   01C4             list_procs_L0:  
0509   01C4 BD 01         cmp byte[d], 1
0510   01C6 C7 EA 01      jne list_procs_next
0511   01C9 2D            mov b, d
0512   01CA 61 2C 1C      sub b, proc_availab_table
0513   01CD FD 9F 05      shl b, 5
0514   01D0 DA            push d
0515   01D1 D8            push b
0516   01D2 28            mov b, c
0517   01D3 07 E5 12      call print_u8x
0518   01D6 22 20         mov ah, ' '
0519   01D8 07 19 11      call _putchar
0520   01DB 07 19 11      call _putchar
0521   01DE E5            pop b
0522   01DF 74            mov d, b
0523   01E0 58 3C 1C      add d, proc_names
0524   01E3 07 45 12      call _puts
0525   01E6 07 F2 11      call printnl
0526   01E9 E7            pop d
0527   01EA             list_procs_next:
0528   01EA 79            inc d
0529   01EB 78            inc c
0530   01EC C2 09 00      cmp c, 9
0531   01EF C7 C4 01      jne list_procs_L0
0532   01F2             list_procs_end:
0533   01F2 06            sysret
0534   01F3             
0535   01F3             ; ------------------------------------------------------------------------------------------------------------------;
0536   01F3             ; Exceptions' Code Block
0537   01F3             ; ------------------------------------------------------------------------------------------------------------------;
0538   01F3             ; Privilege
0539   01F3             ; ------------------------------------------------------------------------------------------------------------------;
0540   01F3             trap_privilege:
0541   01F3 0A 74 01      jmp syscall_reboot
0542   01F6 DA            push d
0543   01F7 3B ED 17      mov d, s_priviledge
0544   01FA 07 45 12      call _puts
0545   01FD E7            pop d
0546   01FE 06            sysret
0547   01FF             
0548   01FF             ; ------------------------------------------------------------------------------------------------------------------;
0549   01FF             ; Breakpoint
0550   01FF             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0551   01FF             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0552   01FF             ; ------------------------------------------------------------------------------------------------------------------;
0553   01FF             syscall_break:
0554   01FF 4B            pusha
0555   0200             syscall_break_prompt:
0556   0200 3B BA 02      mov d, s_break1
0557   0203 07 45 12      call _puts
0558   0206 07 F2 11      call printnl
0559   0209 07 47 13      call scan_u16d
0560   020C AF 00 00      cmp a, 0
0561   020F C6 1A 02      je syscall_break_regs
0562   0212 AF 01 00      cmp a, 1
0563   0215 C6 3D 02      je syscall_break_mem
0564   0218             syscall_break_end:  
0565   0218 4C            popa
0566   0219 06            sysret
0567   021A             syscall_break_regs:
0568   021A 48            mov a, sp
0569   021B 53 0E 00      add a, 14               ; back-track 7 registers
0570   021E 3C            mov d, a
0571   021F 3A 07         mov cl, 7
0572   0221             syscall_regs_L0:
0573   0221 2A            mov b, [d]
0574   0222 FD AB         swp b
0575   0224 07 A1 12      call print_u16x         ; print register value
0576   0227 07 F2 11      call printnl
0577   022A 63 02 00      sub d, 2
0578   022D 71 01         sub cl, 1
0579   022F C3 00         cmp cl, 0
0580   0231 C7 21 02      jne syscall_regs_L0
0581   0234 0A 00 02      jmp syscall_break_prompt
0582   0237 07 F2 11      call printnl
0583   023A 0A 00 02      jmp syscall_break_prompt
0584   023D             syscall_break_mem:
0585   023D 07 F2 11      call printnl
0586   0240 07 C3 12      call scan_u16x
0587   0243 4D            mov si, a               ; data source from user space
0588   0244 FD 4F BC 24   mov di, scrap_sector    ; destination in kernel space
0589   0248 38 00 02      mov c, 512
0590   024B 04            load                    ; transfer data to kernel space!
0591   024C 3B BC 24      mov d, scrap_sector     ; dump pointer in d
0592   024F 38 00 00      mov c, 0
0593   0252             dump_loop:
0594   0252 84            mov al, cl
0595   0253 87 0F         and al, $0F
0596   0255 C6 A3 02      jz print_base
0597   0258             back:
0598   0258 1E            mov al, [d]             ; read byte
0599   0259 2F            mov bl, al
0600   025A 07 E5 12      call print_u8x
0601   025D 10 00 20      mov a, $2000
0602   0260 05 03         syscall sys_io          ; space
0603   0262 84            mov al, cl
0604   0263 87 0F         and al, $0F
0605   0265 B9 0F         cmp al, $0F
0606   0267 C6 78 02      je print_ascii
0607   026A             back1:
0608   026A 79            inc d
0609   026B 78            inc c
0610   026C C2 00 02      cmp c, 512
0611   026F C7 52 02      jne dump_loop
0612   0272 07 F2 11      call printnl
0613   0275 0A 00 02      jmp syscall_break_prompt  ; go to syscall_break return point
0614   0278             print_ascii:
0615   0278 10 00 20      mov a, $2000
0616   027B 05 03         syscall sys_io
0617   027D 63 10 00      sub d, 16
0618   0280 26 10 00      mov b, 16
0619   0283             print_ascii_L:
0620   0283 79            inc d
0621   0284 1E            mov al, [d]               ; read byte
0622   0285 B9 20         cmp al, $20
0623   0287 C8 8F 02      jlu dot
0624   028A B9 7E         cmp al, $7E
0625   028C D0 97 02      jleu ascii
0626   028F             dot:
0627   028F 10 00 2E      mov a, $2E00
0628   0292 05 03         syscall sys_io
0629   0294 0A 9C 02      jmp ascii_continue
0630   0297             ascii:
0631   0297 23            mov ah, al
0632   0298 19 00         mov al, 0
0633   029A 05 03         syscall sys_io
0634   029C             ascii_continue:
0635   029C FD A9 83 02   loopb print_ascii_L
0636   02A0 0A 6A 02      jmp back1
0637   02A3             print_base:
0638   02A3 07 F2 11      call printnl
0639   02A6 2D            mov b, d
0640   02A7 61 BC 24      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0641   02AA 07 A1 12      call print_u16x          ; display row
0642   02AD 10 00 3A      mov a, $3A00
0643   02B0 05 03         syscall sys_io
0644   02B2 10 00 20      mov a, $2000
0645   02B5 05 03         syscall sys_io
0646   02B7 0A 58 02      jmp back
0647   02BA             
0648   02BA             s_break1:  
0649   02BA 0A 44 65 62   .db "\nDebugger entry point.\n"
0649   02BE 75 67 67 65 
0649   02C2 72 20 65 6E 
0649   02C6 74 72 79 20 
0649   02CA 70 6F 69 6E 
0649   02CE 74 2E 0A 
0650   02D1 30 2E 20 53   .db "0. Show Registers\n"
0650   02D5 68 6F 77 20 
0650   02D9 52 65 67 69 
0650   02DD 73 74 65 72 
0650   02E1 73 0A 
0651   02E3 31 2E 20 53   .db "1. Show 512B RAM block\n"
0651   02E7 68 6F 77 20 
0651   02EB 35 31 32 42 
0651   02EF 20 52 41 4D 
0651   02F3 20 62 6C 6F 
0651   02F7 63 6B 0A 
0652   02FA 32 2E 20 43   .db "2. Continue Execution", 0
0652   02FE 6F 6E 74 69 
0652   0302 6E 75 65 20 
0652   0306 45 78 65 63 
0652   030A 75 74 69 6F 
0652   030E 6E 00 
0653   0310             
0654   0310             ; ------------------------------------------------------------------------------------------------------------------;
0655   0310             ; Divide by Zero
0656   0310             ; ------------------------------------------------------------------------------------------------------------------;
0657   0310             trap_div_zero:
0658   0310 D7            push a
0659   0311 DA            push d
0660   0312 E1            pushf
0661   0313 3B 04 18      mov d, s_divzero
0662   0316 07 45 12      call _puts
0663   0319 EE            popf
0664   031A E7            pop d
0665   031B E4            pop a
0666   031C 06            sysret ; enable interrupts
0667   031D             
0668   031D             ; ------------------------------------------------------------------------------------------------------------------;
0669   031D             ; Undefined Opcode
0670   031D             ; ------------------------------------------------------------------------------------------------------------------;
0671   031D             trap_undef_opcode:
0672   031D 06            sysret
0673   031E             
0674   031E             ; ------------------------------------------------------------------------------------------------------------------;
0675   031E             ; RTC Services Syscall
0676   031E             ; RTC I/O bank = FFA0 to FFAF
0677   031E             ; FFA0 to FFA7 is scratch RAM
0678   031E             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0679   031E             ; al = 0..6 -> get
0680   031E             ; al = 7..D -> set
0681   031E             ; ------------------------------------------------------------------------------------------------------------------;
0682   031E             syscall_rtc:
0683   031E DB            push al
0684   031F DA            push d
0685   0320 B9 06         cmp al, 6
0686   0322 D1 37 03      jgu syscall_rtc_set
0687   0325             syscall_rtc_get:
0688   0325 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0689   0327 22 FF         mov ah, $FF    
0690   0329 3C            mov d, a                ; get to FFA9 + offset
0691   032A F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0692   032E 1E            mov al, [d]             ; get data
0693   032F F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0694   0333 23            mov ah, al
0695   0334 E7            pop d
0696   0335 E8            pop al
0697   0336 06            sysret
0698   0337             syscall_rtc_set:
0699   0337 DD            push bl
0700   0338 99            mov bl, ah              ; set data asIDE
0701   0339 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0702   033B 22 FF         mov ah, $FF    
0703   033D 3C            mov d, a                ; get to FFA9 + offset
0704   033E 1B            mov al, bl              ; get data back
0705   033F F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0706   0343 3E            mov [d], al             ; set data
0707   0344 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0708   0348 EA            pop bl
0709   0349 E7            pop d
0710   034A E8            pop al
0711   034B 06            sysret
0712   034C             
0713   034C             datetime_serv_tbl:
0714   034C 54 03         .dw print_date
0715   034E C8 03         .dw set_date
0716   0350             syscall_datetime:
0717   0350 FD 0A 4C 03   jmp [datetime_serv_tbl + al]      
0718   0354             print_date:
0719   0354 10 00 0D      mov a, $0D00           ; print carriage return char
0720   0357 19 03         mov al, 3
0721   0359 05 01         syscall sys_rtc        ; get week
0722   035B 1A            mov al, ah
0723   035C 22 00         mov ah, 0
0724   035E FD 9D 02      shl a, 2          
0725   0361 3B 8E 18      mov d, s_week
0726   0364 59            add d, a
0727   0365 07 45 12      call _puts
0728   0368 10 00 20      mov a, $2000
0729   036B 05 03         syscall sys_io         ; display ' '
0730   036D 19 04         mov al, 4
0731   036F 05 01         syscall sys_rtc        ; get day
0732   0371 99            mov bl, ah
0733   0372 07 E5 12      call print_u8x
0734   0375 10 00 20      mov a, $2000
0735   0378 05 03         syscall sys_io         ; display ' '
0736   037A             ; there is a problem with the month displaying
0737   037A             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0738   037A             ; even though it is to be understood as BCD.
0739   037A             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0740   037A 19 05         mov al, 05
0741   037C 05 01         syscall sys_rtc        ; get month
0742   037E 1A            mov al, ah
0743   037F 22 00         mov ah, 0
0744   0381 FD 9D 02      shl a, 2          
0745   0384 3B 5A 18      mov d, s_months
0746   0387 59            add d, a
0747   0388 07 45 12      call _puts
0748   038B 10 00 20      mov a, $2000
0749   038E 05 03         syscall sys_io         ; display ' '
0750   0390 2E 20         mov bl, $20
0751   0392 07 E5 12      call print_u8x         ; print 20 for year prefix
0752   0395 19 06         mov al, 06
0753   0397 05 01         syscall sys_rtc        ; get year
0754   0399 99            mov bl, ah
0755   039A 07 E5 12      call print_u8x
0756   039D 10 00 20      mov a, $2000  
0757   03A0 05 03         syscall sys_io         ; display ' '
0758   03A2 19 02         mov al, 2
0759   03A4 05 01         syscall sys_rtc        ; get hours
0760   03A6 99            mov bl, ah
0761   03A7 07 E5 12      call print_u8x
0762   03AA 10 00 3A      mov a, $3A00    
0763   03AD 05 03         syscall sys_io         ; display ':'
0764   03AF 19 01         mov al, 01
0765   03B1 05 01         syscall sys_rtc        ; get minutes
0766   03B3 99            mov bl, ah
0767   03B4 07 E5 12      call print_u8x
0768   03B7 10 00 3A      mov a, $3A00  
0769   03BA 05 03         syscall sys_io         ; display ':'
0770   03BC 19 00         mov al, 0
0771   03BE 05 01         syscall sys_rtc        ; get seconds
0772   03C0 99            mov bl, ah
0773   03C1 07 E5 12      call print_u8x
0774   03C4 07 F2 11      call printnl
0775   03C7 06            sysret
0776   03C8             set_date:
0777   03C8 3B 1F 18      mov d, s_set_year
0778   03CB 07 45 12      call _puts
0779   03CE 07 30 13      call scan_u8x          ; read integer into A
0780   03D1 FD 9D 08      shl a, 8               ; only AL used, move to AH
0781   03D4 19 0D         mov al, 0Dh            ; set RTC year
0782   03D6 05 01         syscall sys_rtc        ; set RTC
0783   03D8 3B 26 18      mov d, s_set_month
0784   03DB 07 45 12      call _puts
0785   03DE 07 30 13      call scan_u8x          ; read integer into A
0786   03E1 FD 9D 08      shl a, 8               ; only AL used, move to AH
0787   03E4 19 0C         mov al, 0Ch            ; set RTC month
0788   03E6 05 01         syscall sys_rtc        ; set RTC
0789   03E8 3B 2E 18      mov d, s_set_day
0790   03EB 07 45 12      call _puts
0791   03EE 07 30 13      call scan_u8x          ; read integer into A
0792   03F1 FD 9D 08      shl a, 8               ; only AL used, move to AH
0793   03F4 19 0B         mov al, 0Bh            ; set RTC month
0794   03F6 05 01         syscall sys_rtc        ; set RTC
0795   03F8 3B 34 18      mov d, s_set_week
0796   03FB 07 45 12      call _puts
0797   03FE 07 30 13      call scan_u8x          ; read integer into A
0798   0401 FD 9D 08      shl a, 8               ; only AL used, move to AH
0799   0404 19 0A         mov al, 0Ah            ; set RTC month
0800   0406 05 01         syscall sys_rtc        ; set RTC
0801   0408 3B 3E 18      mov d, s_set_hours
0802   040B 07 45 12      call _puts
0803   040E 07 30 13      call scan_u8x          ; read integer into A
0804   0411 FD 9D 08      shl a, 8               ; only AL used, move to AH
0805   0414 19 09         mov al, 09h            ; set RTC month
0806   0416 05 01         syscall sys_rtc        ; set RTC
0807   0418 3B 46 18      mov d, s_set_minutes
0808   041B 07 45 12      call _puts
0809   041E 07 30 13      call scan_u8x          ; read integer into A
0810   0421 FD 9D 08      shl a, 8               ; only AL used, move to AH
0811   0424 19 08         mov al, 08h            ; set RTC month
0812   0426 05 01         syscall sys_rtc        ; set RTC
0813   0428 3B 50 18      mov d, s_set_seconds
0814   042B 07 45 12      call _puts
0815   042E 07 30 13      call scan_u8x          ; read integer into A
0816   0431 FD 9D 08      shl a, 8               ; only AL used, move to AH
0817   0434 19 07         mov al, 07h            ; set RTC month
0818   0436 05 01         syscall sys_rtc        ; set RTC
0819   0438 06            sysret
0820   0439             
0821   0439             ; ------------------------------------------------------------------------------------------------------------------;
0822   0439             ; IDE Services Syscall
0823   0439             ; al = option
0824   0439             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0825   0439             ; IDE read/write sector
0826   0439             ; 512 bytes
0827   0439             ; User buffer pointer in D
0828   0439             ; AH = number of sectors
0829   0439             ; CB = LBA bytes 3..0
0830   0439             ; ------------------------------------------------------------------------------------------------------------------;
0831   0439 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0831   043D 73 63 61 6C 
0831   0441 6C 5F 69 64 
0831   0445 65 20 63 61 
0831   0449 6C 6C 65 64 
0831   044D 3A 20 00 
0832   0450             ide_serv_tbl:
0833   0450 77 04         .dw ide_reset
0834   0452 8B 04         .dw ide_sleep
0835   0454 9A 04         .dw ide_read_sect_wrapper
0836   0456 9E 04         .dw ide_write_sect_wrapper
0837   0458             syscall_ide:
0838   0458 DD            push bl
0839   0459 31 6E 17      mov bl, [sys_debug_mode]
0840   045C               ; debug block
0841   045C C1 00         cmp bl, 0
0842   045E EA            pop bl
0843   045F C6 73 04      je syscall_ide_jmp
0844   0462 DA            push d
0845   0463 DD            push bl
0846   0464 3B 39 04      mov d, s_syscall_ide_dbg0
0847   0467 07 45 12      call _puts
0848   046A 2F            mov bl, al
0849   046B 07 E5 12      call print_u8x
0850   046E 07 F2 11      call printnl
0851   0471 EA            pop bl
0852   0472 E7            pop d
0853   0473             syscall_ide_jmp:
0854   0473 FD 0A 50 04   jmp [ide_serv_tbl + al]    
0855   0477               
0856   0477             ide_reset:      
0857   0477 F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0858   047B 07 24 05      call ide_wait                   ; wait for IDE ready             
0859   047E F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0860   0482 F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0861   0486 F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0862   048A 06            sysret
0863   048B             ide_sleep:
0864   048B 07 24 05      call ide_wait                   ; wait for IDE ready             
0865   048E F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0866   0492 F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0867   0496 07 24 05      call ide_wait                   ; wait for IDE ready
0868   0499 06            sysret
0869   049A             ide_read_sect_wrapper:
0870   049A 07 A2 04      call ide_read_sect
0871   049D 06            sysret
0872   049E             ide_write_sect_wrapper:
0873   049E 07 C8 04      call ide_write_sect
0874   04A1 06            sysret
0875   04A2             ide_read_sect:
0876   04A2 1A            mov al, ah
0877   04A3 24            mov ah, bl
0878   04A4 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0879   04A7 1C            mov al, bh
0880   04A8 3D D4 FF      mov [_ide_R4], al
0881   04AB 12            mov a, c
0882   04AC 3D D5 FF      mov [_ide_R5], al
0883   04AF 1A            mov al, ah
0884   04B0 87 0F         and al, %00001111
0885   04B2 8B E0         or al, %11100000                ; mode lba, master
0886   04B4 3D D6 FF      mov [_ide_R6], al
0887   04B7             ide_read_sect_wait:
0888   04B7 1D D7 FF      mov al, [_ide_R7]  
0889   04BA 87 80         and al, $80                     ; BUSY FLAG
0890   04BC C7 B7 04      jnz ide_read_sect_wait
0891   04BF 19 20         mov al, $20
0892   04C1 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0893   04C4 07 EE 04      call ide_read  
0894   04C7 09            ret
0895   04C8             ide_write_sect:
0896   04C8 1A            mov al, ah
0897   04C9 24            mov ah, bl
0898   04CA 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0899   04CD 1C            mov al, bh
0900   04CE 3D D4 FF      mov [_ide_R4], al
0901   04D1 12            mov a, c
0902   04D2 3D D5 FF      mov [_ide_R5], al
0903   04D5 1A            mov al, ah
0904   04D6 87 0F         and al, %00001111
0905   04D8 8B E0         or al, %11100000                ; mode lba, master
0906   04DA 3D D6 FF      mov [_ide_R6], al
0907   04DD             ide_write_sect_wait:
0908   04DD 1D D7 FF      mov al, [_ide_R7]  
0909   04E0 87 80         and al, $80                     ; BUSY FLAG
0910   04E2 C7 DD 04      jnz ide_write_sect_wait
0911   04E5 19 30         mov al, $30
0912   04E7 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0913   04EA 07 09 05      call ide_write      
0914   04ED 09            ret
0915   04EE             
0916   04EE             ;----------------------------------------------------------------------------------------------------;
0917   04EE             ; READ IDE DATA
0918   04EE             ; pointer in D
0919   04EE             ;----------------------------------------------------------------------------------------------------;
0920   04EE             ide_read:
0921   04EE DA            push d
0922   04EF             ide_read_loop:
0923   04EF 1D D7 FF      mov al, [_ide_R7]  
0924   04F2 87 80         and al, 80h                     ; BUSY FLAG
0925   04F4 C7 EF 04      jnz ide_read_loop               ; wait loop
0926   04F7 1D D7 FF      mov al, [_ide_R7]
0927   04FA 87 08         and al, %00001000               ; DRQ FLAG
0928   04FC C6 07 05      jz ide_read_end
0929   04FF 1D D0 FF      mov al, [_ide_R0]
0930   0502 3E            mov [d], al
0931   0503 79            inc d
0932   0504 0A EF 04      jmp ide_read_loop
0933   0507             ide_read_end:
0934   0507 E7            pop d
0935   0508 09            ret
0936   0509             
0937   0509             ;----------------------------------------------------------------------------------------------------;
0938   0509             ; WRITE IDE DATA
0939   0509             ; data pointer in D
0940   0509             ;----------------------------------------------------------------------------------------------------;
0941   0509             ide_write:
0942   0509 DA            push d
0943   050A             ide_write_loop:
0944   050A 1D D7 FF      mov al, [_ide_R7]  
0945   050D 87 80         and al, 80h             ; BUSY FLAG
0946   050F C7 0A 05      jnz ide_write_loop      ; wait loop
0947   0512 1D D7 FF      mov al, [_ide_R7]
0948   0515 87 08         and al, %00001000       ; DRQ FLAG
0949   0517 C6 22 05      jz ide_write_end
0950   051A 1E            mov al, [d]
0951   051B 3D D0 FF      mov [_ide_R0], al
0952   051E 79            inc d 
0953   051F 0A 0A 05      jmp ide_write_loop
0954   0522             ide_write_end:
0955   0522 E7            pop d
0956   0523 09            ret
0957   0524             
0958   0524             ;----------------------------------------------------------------------------------------------------;
0959   0524             ; wait for IDE to be ready
0960   0524             ;----------------------------------------------------------------------------------------------------;
0961   0524             ide_wait:
0962   0524 1D D7 FF      mov al, [_ide_R7]  
0963   0527 87 80         and al, 80h        ; BUSY FLAG
0964   0529 C7 24 05      jnz ide_wait
0965   052C 09            ret
0966   052D             
0967   052D             ;----------------------------------------------------------------------------------------------------;
0968   052D             ; IO Syscall
0969   052D             ;----------------------------------------------------------------------------------------------------;
0970   052D             ; Baud  Divisor
0971   052D             ; 50    2304
0972   052D             ; 110   1047
0973   052D             ; 300    384
0974   052D             ; 600    192
0975   052D             ; 1200    96
0976   052D             ; 9600    12
0977   052D             ; 19200    6
0978   052D             ; 38400    3
0979   052D             syscall_io_jmp:
0980   052D 60 05         .dw syscall_io_putchar
0981   052F 6D 05         .dw syscall_io_getch
0982   0531 37 05         .dw syscall_io_uart_setup
0983   0533             syscall_io:
0984   0533 FD 0A 2D 05   jmp [syscall_io_jmp + al]
0985   0537             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0986   0537             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0987   0537             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0988   0537             syscall_io_uart_setup:
0989   0537 1D 70 17      mov al, [sys_uart0_lcr]
0990   053A 8B 80         or al, $80                ; set DLAB access bit
0991   053C 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0992   053F 1D 73 17      mov al, [sys_uart0_div0]
0993   0542 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0994   0545 1D 74 17      mov al, [sys_uart0_div1]
0995   0548 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0996   054B             
0997   054B 1D 70 17      mov al, [sys_uart0_lcr]
0998   054E 87 7F         and al, $7F               ; clear DLAB access bit 
0999   0550 3D 83 FF      mov [_UART0_LCR], al
1000   0553 1D 71 17      mov al, [sys_uart0_inten]
1001   0556 3D 81 FF      mov [_UART0_IER], al      ; interrupts
1002   0559 1D 72 17      mov al, [sys_uart0_fifoen]
1003   055C 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
1004   055F 06            sysret
1005   0560             
1006   0560             ; char in ah
1007   0560             syscall_io_putchar:
1008   0560             syscall_io_putchar_L0:
1009   0560 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1010   0563 87 20         and al, $20
1011   0565 C6 60 05      jz syscall_io_putchar_L0    
1012   0568 1A            mov al, ah
1013   0569 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1014   056C 06            sysret
1015   056D             
1016   056D             ; char in ah
1017   056D             ; al = sucess code
1018   056D             syscall_io_getch:
1019   056D D8            push b
1020   056E DA            push d
1021   056F FD 0C         sti
1022   0571             syscall_io_getch_L0:  
1023   0571 14 7D 17      mov a, [fifo_out]
1024   0574 29 7B 17      mov b, [fifo_in]
1025   0577 B0            cmp a, b
1026   0578 C6 71 05      je syscall_io_getch_L0
1027   057B 3C            mov d, a
1028   057C 77            inc a
1029   057D AF BC 24      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
1030   0580 C7 86 05      jne syscall_io_getch_cont
1031   0583 10 BC 20      mov a, fifo  
1032   0586             syscall_io_getch_cont:  
1033   0586 42 7D 17      mov [fifo_out], a             ; update fifo pointer
1034   0589 1E            mov al, [d]                   ; get char
1035   058A 23            mov ah, al
1036   058B 1D 6F 17      mov al, [sys_echo_on]
1037   058E B9 01         cmp al, 1
1038   0590 C7 9F 05      jne syscall_io_getch_noecho 
1039   0593             ; here we just echo the char back to the console
1040   0593             syscall_io_getch_echo_L0:
1041   0593 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1042   0596 87 20         and al, $20                 ; isolate Transmitter Empty
1043   0598 C6 93 05      jz syscall_io_getch_echo_L0
1044   059B 1A            mov al, ah
1045   059C 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1046   059F             syscall_io_getch_noecho:
1047   059F 19 01         mov al, 1                    ; AL = 1 means a char successfully received
1048   05A1 E7            pop d
1049   05A2 E5            pop b
1050   05A3 06            sysret
1051   05A4             
1052   05A4             ;------------------------------------------------------------------------------------------------------;
1053   05A4             ; FILE SYSTEM DATA
1054   05A4             ;------------------------------------------------------------------------------------------------------;
1055   05A4             ; infor for : IDE SERVICES INTERRUPT
1056   05A4             ; IDE read/write 512-byte sector
1057   05A4             ; al = option
1058   05A4             ; user buffer pointer in D
1059   05A4             ; AH = number of sectors
1060   05A4             ; CB = LBA bytes 3..0  
1061   05A4             ;------------------------------------------------------------------------------------------------------;
1062   05A4             ; FILE SYSTEM DATA STRUCTURE
1063   05A4             ;------------------------------------------------------------------------------------------------------;
1064   05A4             ; for a directory we have the header first, followed by metadata
1065   05A4             ; header 1 sector (512 bytes)
1066   05A4             ; metadata 1 sector (512 bytes)
1067   05A4             ; HEADER ENTRIES:
1068   05A4             ; filename (64)
1069   05A4             ; parent dir LBA (2) -  to be used for faster backwards navigation...
1070   05A4             ;
1071   05A4             ; metadata entries:
1072   05A4             ; filename (24)
1073   05A4             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1074   05A4             ; LBA (2)
1075   05A4             ; size (2)
1076   05A4             ; day (1)
1077   05A4             ; month (1)
1078   05A4             ; year (1)
1079   05A4             ; packet size = 32 bytes
1080   05A4             ;
1081   05A4             ; first directory on disk is the root directory '/'
1082   05A4             file_system_jmptbl:
1083   05A4 0F 06         .dw fs_mkfs                   ; 0
1084   05A6 00 00         .dw 0                         ; 1
1085   05A8 71 06         .dw fs_mkdir                  ; 2
1086   05AA EA 09         .dw fs_cd                     ; 3
1087   05AC F1 09         .dw fs_ls                     ; 4
1088   05AE 67 0B         .dw fs_mktxt                  ; 5
1089   05B0 32 0C         .dw fs_mkbin                  ; 6
1090   05B2 F9 0C         .dw fs_pwd                    ; 7
1091   05B4 16 0D         .dw fs_cat                    ; 8
1092   05B6 72 0D         .dw fs_rmdir                  ; 9
1093   05B8 CE 0D         .dw fs_rm                     ; 10
1094   05BA C2 0A         .dw fs_starcom                ; 11
1095   05BC 00 00         .dw 0                         ; 12
1096   05BE 00 00         .dw 0                         ; 13
1097   05C0 17 06         .dw fs_chmod                  ; 14
1098   05C2 36 0E         .dw fs_mv                     ; 15
1099   05C4 10 06         .dw fs_cd_root                ; 16
1100   05C6 E6 09         .dw fs_get_curr_dirID         ; 17
1101   05C8 C2 07         .dw fs_dir_id_to_path         ; 18
1102   05CA 28 08         .dw fs_path_to_dir_id_user    ; 19
1103   05CC 42 09         .dw fs_load_from_path_user    ; 20  
1104   05CE B2 08         .dw fs_filepath_exists_user   ; 21
1105   05D0             
1106   05D0 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1106   05D4 79 73 63 61 
1106   05D8 6C 6C 5F 66 
1106   05DC 69 6C 65 5F 
1106   05E0 73 79 73 74 
1106   05E4 65 6D 20 63 
1106   05E8 61 6C 6C 65 
1106   05EC 64 3A 20 00 
1107   05F0             syscall_file_system:
1108   05F0 DD            push bl
1109   05F1 31 6E 17      mov bl, [sys_debug_mode]
1110   05F4               ; debug block
1111   05F4 C1 00         cmp bl, 0
1112   05F6 EA            pop bl
1113   05F7 C6 0B 06      je syscall_filesystem_jmp
1114   05FA DA            push d
1115   05FB DD            push bl
1116   05FC 3B D0 05      mov d, s_syscall_fs_dbg0
1117   05FF 07 45 12      call _puts
1118   0602 2F            mov bl, al
1119   0603 07 E5 12      call print_u8x
1120   0606 07 F2 11      call printnl
1121   0609 EA            pop bl
1122   060A E7            pop d
1123   060B             syscall_filesystem_jmp:
1124   060B FD 0A A4 05   jmp [file_system_jmptbl + al]
1125   060F             
1126   060F             fs_mkfs:  
1127   060F 06            sysret  
1128   0610               
1129   0610             fs_cd_root:
1130   0610 10 20 00      mov a, root_id
1131   0613 42 7F 17      mov [current_dir_id], a      ; set current directory LBA to ROOT
1132   0616 06            sysret  
1133   0617             
1134   0617             ; filename in D (userspace data)
1135   0617             ; permission in BL
1136   0617             fs_chmod:
1137   0617 DD            push bl
1138   0618 FD 4E         mov si, d
1139   061A FD 4F BC 1E   mov di, user_data
1140   061E 38 80 00      mov c, 128
1141   0621 04            load                        ; load filename from user-space
1142   0622 14 7F 17      mov a, [current_dir_id]
1143   0625 77            inc a                       ; metadata sector
1144   0626 27            mov b, a
1145   0627 38 00 00      mov c, 0                    ; upper LBA = 0
1146   062A 22 01         mov ah, $01                  ; 1 sector
1147   062C 3B BC 26      mov d, transient_area
1148   062F 07 A2 04      call ide_read_sect          ; read directory
1149   0632 FD 10         cla
1150   0634 42 77 17      mov [index], a              ; reset file counter
1151   0637             fs_chmod_L1:
1152   0637 FD 4E         mov si, d
1153   0639 FD 4F BC 1E   mov di, user_data
1154   063D 07 88 10      call _strcmp
1155   0640 C6 57 06      je fs_chmod_found_entry
1156   0643 58 20 00      add d, 32
1157   0646 14 77 17      mov a, [index]
1158   0649 77            inc a
1159   064A 42 77 17      mov [index], a
1160   064D AF 10 00      cmp a, FST_FILES_PER_DIR
1161   0650 C7 37 06      jne fs_chmod_L1
1162   0653 EA            pop bl
1163   0654 0A 70 06      jmp fs_chmod_not_found
1164   0657             fs_chmod_found_entry:  
1165   0657 FD 79         mov g, b                    ; save LBA
1166   0659 EA            pop bl                      ; retrieve saved permission value
1167   065A 1F 18 00      mov al, [d + 24]            ; read file permissions
1168   065D 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1169   065F 8C            or al, bl                   ; set new permissions
1170   0660 3F 18 00      mov [d + 24], al            ; write new permissions
1171   0663 38 00 00      mov c, 0
1172   0666 3B BC 26      mov d, transient_area
1173   0669 22 01         mov ah, $01                 ; disk write 1 sect
1174   066B FD 27         mov b, g                    ; retrieve LBA
1175   066D 07 C8 04      call ide_write_sect         ; write sector
1176   0670             fs_chmod_not_found:
1177   0670 06            sysret
1178   0671             
1179   0671             ;------------------------------------------------------------------------------------------------------;
1180   0671             ; CREATE NEW DIRECTORY
1181   0671             ;------------------------------------------------------------------------------------------------------;
1182   0671             ; search list for NULL name entry. add new directory to list
1183   0671             fs_mkdir:
1184   0671 FD 4E         mov si, d
1185   0673 FD 4F BC 1E   mov di, user_data
1186   0677 38 00 02      mov c, 512
1187   067A 04            load                        ; load data from user-space
1188   067B 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1189   067E                                           ; when checking for NULL name, since root has a NULL name)
1190   067E 38 00 00      mov c, 0                    ; upper LBA = 0
1191   0681             fs_mkdir_L1:  
1192   0681 22 01         mov ah, $01                  ; 1 sector
1193   0683 3B BC 26      mov d, transient_area
1194   0686 07 A2 04      call ide_read_sect          ; read sector
1195   0689 BD 00         cmp byte[d], 0              ; check for NULL
1196   068B C6 94 06      je fs_mkdir_found_null
1197   068E 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1198   0691 0A 81 06      jmp fs_mkdir_L1
1199   0694             fs_mkdir_found_null:
1200   0694             ;create header file by grabbing dir name from parameter
1201   0694 D8            push b                      ; save new directory's LBA
1202   0695 38 40 00      mov c, 64
1203   0698 FD 4D BC 1E   mov si, user_data
1204   069C FD 4F BC 26   mov di, transient_area
1205   06A0 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1206   06A2 14 7F 17      mov a, [current_dir_id]
1207   06A5 42 FC 26      mov [transient_area + 64], a    ; store parent directory LBA
1208   06A8 19 00         mov al, 0
1209   06AA FD 4F BC 28   mov di, transient_area + 512
1210   06AE 38 00 02      mov c, 512
1211   06B1 FD F7         rep stosb                       ; clean buffer
1212   06B3 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1213   06B6             ; write directory entry sectors
1214   06B6 3B BC 26      mov d, transient_area
1215   06B9 22 02         mov ah, $02                     ; disk write, 2 sectors
1216   06BB 07 C8 04      call ide_write_sect             ; write sector
1217   06BE             ; now we need to add the new directory to the list, insIDE the current directory
1218   06BE 14 7F 17      mov a, [current_dir_id]
1219   06C1 53 01 00      add a, 1
1220   06C4 27            mov b, a                        ; metadata sector
1221   06C5 38 00 00      mov c, 0
1222   06C8 FD 79         mov g, b                        ; save LBA
1223   06CA 3B BC 26      mov d, transient_area
1224   06CD 22 01         mov ah, $01                  ; 1 sector
1225   06CF 07 A2 04      call ide_read_sect              ; read metadata sector
1226   06D2             fs_mkdir_L2:
1227   06D2 BD 00         cmp byte[d], 0
1228   06D4 C6 DD 06      je fs_mkdir_found_null2
1229   06D7 58 20 00      add d, FST_ENTRY_SIZE
1230   06DA 0A D2 06      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1231   06DD             fs_mkdir_found_null2:
1232   06DD FD 4D BC 1E   mov si, user_data
1233   06E1 FD 50         mov di, d
1234   06E3 07 9D 10      call _strcpy                    ; copy directory name
1235   06E6 58 18 00      add d, 24                       ; goto ATTRIBUTES
1236   06E9 19 0B         mov al, %00001011               ; directory, no execute, write, read
1237   06EB 3E            mov [d], al      
1238   06EC 79            inc d
1239   06ED E5            pop b
1240   06EE D8            push b                          ; push LBA back
1241   06EF FD 43         mov [d], b                      ; save LBA
1242   06F1             ; set file creation date  
1243   06F1 58 04 00      add d, 4
1244   06F4 19 04         mov al, 4
1245   06F6 05 01         syscall sys_rtc
1246   06F8 1A            mov al, ah
1247   06F9 3E            mov [d], al                     ; set day
1248   06FA 79            inc d
1249   06FB 19 05         mov al, 5
1250   06FD 05 01         syscall sys_rtc
1251   06FF 1A            mov al, ah
1252   0700 3E            mov [d], al                     ; set month
1253   0701 79            inc d
1254   0702 19 06         mov al, 6
1255   0704 05 01         syscall sys_rtc
1256   0706 1A            mov al, ah
1257   0707 3E            mov [d], al                     ; set year
1258   0708             ; write sector into disk for new directory entry
1259   0708 FD 27         mov b, g
1260   070A 38 00 00      mov c, 0
1261   070D 3B BC 26      mov d, transient_area
1262   0710 22 01         mov ah, $01                     ; disk write, 1 sector
1263   0712 07 C8 04      call ide_write_sect             ; write sector
1264   0715             
1265   0715             ; after adding the new directory's information to its parent directory's list
1266   0715             ; we need to now enter the new directory, and to it add two new directories!
1267   0715             ; which directories do we need to add ? '..' and '.' are the directories needed.
1268   0715             ; importantly, note that these two new directories are only entries in the list
1269   0715             ; and do not have actual physical entries in the disk as real directories.
1270   0715             ; i.e. they only exist as list entries in the new directory created so that
1271   0715             ; the new directory can reference its parent and itself.
1272   0715             ; We need to add both '..' and '.'
1273   0715             ; this first section is for '..' and on the section below we do the same for '.'
1274   0715 E4            pop a                         ; retrieve the new directory's LBA  
1275   0716 D7            push a                        ; and save again
1276   0717 53 01 00      add a, 1
1277   071A 27            mov b, a                      ; metadata sector
1278   071B 38 00 00      mov c, 0
1279   071E FD 79         mov g, b                      ; save LBA
1280   0720 3B BC 26      mov d, transient_area
1281   0723 22 01         mov ah, $01                  ; 1 sector
1282   0725 07 A2 04      call ide_read_sect            ; read metadata sector
1283   0728             fs_mkdir_L3:
1284   0728 BD 00         cmp byte[d], 0
1285   072A C6 33 07      je fs_mkdir_found_null3
1286   072D 58 20 00      add d, FST_ENTRY_SIZE
1287   0730 0A 28 07      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1288   0733             fs_mkdir_found_null3:
1289   0733 FD 4D 8F 17   mov si, s_parent_dir
1290   0737 FD 50         mov di, d
1291   0739 07 9D 10      call _strcpy                  ; copy directory name
1292   073C 58 18 00      add d, 24                     ; goto ATTRIBUTES
1293   073F 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1294   0741 3E            mov [d], al      
1295   0742 79            inc d
1296   0743 29 7F 17      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1297   0746 FD 43         mov [d], b                    ; save LBA
1298   0748             ; set file creation date  
1299   0748 58 04 00      add d, 4
1300   074B 19 04         mov al, 4
1301   074D 05 01         syscall sys_rtc
1302   074F 1A            mov al, ah
1303   0750 3E            mov [d], al                   ; set day
1304   0751 79            inc d
1305   0752 19 05         mov al, 5
1306   0754 05 01         syscall sys_rtc
1307   0756 1A            mov al, ah
1308   0757 3E            mov [d], al                   ; set month
1309   0758 79            inc d
1310   0759 19 06         mov al, 6
1311   075B 05 01         syscall sys_rtc
1312   075D 1A            mov al, ah
1313   075E 3E            mov [d], al                   ; set year
1314   075F             ; write sector into disk for new directory entry
1315   075F FD 27         mov b, g
1316   0761 38 00 00      mov c, 0
1317   0764 3B BC 26      mov d, transient_area
1318   0767 22 01         mov ah, $01                   ; disk write, 1 sector
1319   0769 07 C8 04      call ide_write_sect           ; write sector
1320   076C             ;;;;;;;;;;;;;
1321   076C             ; like we did above for '..', we need to now add the '.' directory to the list.
1322   076C             ;------------------------------------------------------------------------------------------------------;
1323   076C E4            pop a                         ; retrieve the new directory's LBA  
1324   076D D7            push a
1325   076E 53 01 00      add a, 1
1326   0771 27            mov b, a                      ; metadata sector
1327   0772 38 00 00      mov c, 0
1328   0775 FD 79         mov g, b                      ; save LBA
1329   0777 3B BC 26      mov d, transient_area
1330   077A 22 01         mov ah, $01                  ; 1 sector
1331   077C 07 A2 04      call ide_read_sect            ; read metadata sector
1332   077F             fs_mkdir_L4:
1333   077F BD 00         cmp byte[d], 0
1334   0781 C6 8A 07      je fs_mkdir_found_null4
1335   0784 58 20 00      add d, FST_ENTRY_SIZE
1336   0787 0A 7F 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1337   078A             fs_mkdir_found_null4:
1338   078A FD 4D 92 17   mov si, s_current_dir
1339   078E FD 50         mov di, d
1340   0790 07 9D 10      call _strcpy                  ; copy directory name
1341   0793 58 18 00      add d, 24                     ; goto ATTRIBUTES
1342   0796 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1343   0798 3E            mov [d], al      
1344   0799 79            inc d
1345   079A E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1346   079B FD 43         mov [d], b                    ; save LBA
1347   079D             ; set file creation date  
1348   079D 58 04 00      add d, 4
1349   07A0 19 04         mov al, 4
1350   07A2 05 01         syscall sys_rtc
1351   07A4 1A            mov al, ah
1352   07A5 3E            mov [d], al                   ; set day
1353   07A6 79            inc d
1354   07A7 19 05         mov al, 5
1355   07A9 05 01         syscall sys_rtc
1356   07AB 1A            mov al, ah
1357   07AC 3E            mov [d], al                   ; set month
1358   07AD 79            inc d
1359   07AE 19 06         mov al, 6
1360   07B0 05 01         syscall sys_rtc
1361   07B2 1A            mov al, ah
1362   07B3 3E            mov [d], al                   ; set year
1363   07B4             ; write sector into disk for new directory entry
1364   07B4 FD 27         mov b, g
1365   07B6 38 00 00      mov c, 0
1366   07B9 3B BC 26      mov d, transient_area
1367   07BC 22 01         mov ah, $01                   ; disk write, 1 sector
1368   07BE 07 C8 04      call ide_write_sect           ; write sector
1369   07C1             fs_mkdir_end:
1370   07C1 06            sysret
1371   07C2             
1372   07C2             ;------------------------------------------------------------------------------------------------------;
1373   07C2             ; get path from a given directory dirID
1374   07C2             ; pseudo code:
1375   07C2             ;  fs_dir_id_to_path(int dirID, char *D){
1376   07C2             ;    if(dirID == 0){
1377   07C2             ;      reverse path in D;
1378   07C2             ;      return;
1379   07C2             ;    }
1380   07C2             ;    else{
1381   07C2             ;      copy directory name to end of D;
1382   07C2             ;      add '/' to end of D;
1383   07C2             ;      parentID = get parent directory ID;
1384   07C2             ;      fs_dir_id_to_path(parentID, D);
1385   07C2             ;    }
1386   07C2             ;  }
1387   07C2             ; A = dirID
1388   07C2             ; D = generated path string pointer
1389   07C2             ;------------------------------------------------------------------------------------------------------;
1390   07C2             ; sample path: /usr/bin
1391   07C2             fs_dir_id_to_path:
1392   07C2 3B 3C 1E      mov d, filename
1393   07C5 19 00         mov al, 0
1394   07C7 3E            mov [d], al                     ; initialize path string 
1395   07C8 14 7F 17      mov a, [current_dir_id]
1396   07CB 07 D8 07      call fs_dir_id_to_path_E0
1397   07CE 3B 3C 1E      mov d, filename
1398   07D1 07 31 10      call _strrev
1399   07D4 07 45 12      call _puts
1400   07D7 06            sysret
1401   07D8             fs_dir_id_to_path_E0:
1402   07D8 07 F7 07      call get_dirname_from_dirID
1403   07DB FD 4D 94 17   mov si, s_fslash
1404   07DF FD 50         mov di, d
1405   07E1 07 AB 10      call _strcat                    ; add '/' to end of path
1406   07E4 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1407   07E7 C6 F6 07      je fs_dir_id_to_path_root
1408   07EA 07 14 08      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1409   07ED AF 20 00      cmp a, root_id               ; check if we are at the root directory
1410   07F0 C6 F6 07      je fs_dir_id_to_path_root
1411   07F3 07 D8 07      call fs_dir_id_to_path_E0     ; recursively call itself
1412   07F6             fs_dir_id_to_path_root:
1413   07F6 09            ret
1414   07F7             
1415   07F7             ;------------------------------------------------------------------------------------------------------;
1416   07F7             ; in_puts:
1417   07F7             ; A = directory ID
1418   07F7             ; out_puts:
1419   07F7             ; D = pointer to directory name string
1420   07F7             ;------------------------------------------------------------------------------------------------------;
1421   07F7             get_dirname_from_dirID:
1422   07F7 D7            push a
1423   07F8 D8            push b
1424   07F9 DA            push d
1425   07FA 27            mov b, a
1426   07FB 38 00 00      mov c, 0                      ; upper LBA = 0
1427   07FE 22 01         mov ah, $01                  ; 1 sector
1428   0800 3B BC 24      mov d, transient_area - 512
1429   0803 07 A2 04      call ide_read_sect            ; read directory
1430   0806 07 31 10      call _strrev                  ; reverse dir name before copying
1431   0809 FD 4E         mov si, d
1432   080B E7            pop d                         ; destination address = D value pushed at beginning
1433   080C FD 50         mov di, d
1434   080E 07 AB 10      call _strcat                  ; copy filename to D
1435   0811 E5            pop b
1436   0812 E4            pop a
1437   0813 09            ret
1438   0814             
1439   0814             ;------------------------------------------------------------------------------------------------------;
1440   0814             ; in_puts:
1441   0814             ; A = directory ID
1442   0814             ; out_puts:
1443   0814             ; A = parent directory ID
1444   0814             ;------------------------------------------------------------------------------------------------------;
1445   0814             get_parentID_from_dirID:
1446   0814 D8            push b
1447   0815 DA            push d
1448   0816 27            mov b, a
1449   0817 38 00 00      mov c, 0                      ; upper LBA = 0
1450   081A 22 01         mov ah, $01                  ; 1 sector
1451   081C 3B BC 24      mov d, transient_area - 512
1452   081F 07 A2 04      call ide_read_sect            ; read directory
1453   0822 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1454   0825 E7            pop d
1455   0826 E5            pop b
1456   0827 09            ret
1457   0828             
1458   0828             ;------------------------------------------------------------------------------------------------------;
1459   0828             ; get dirID from a given path string
1460   0828             ; in_puts:
1461   0828             ; D = path pointer 
1462   0828             ; out_puts:
1463   0828             ; A = dirID
1464   0828             ; if dir non existent, A = FFFF (fail code)
1465   0828             ; /usr/local/bin    - absolute
1466   0828             ; local/bin/games    - relative
1467   0828             ;------------------------------------------------------------------------------------------------------;
1468   0828             fs_path_to_dir_id_user:
1469   0828 FD 4E         mov si, d
1470   082A FD 4F BC 1E   mov di, user_data
1471   082E 38 00 02      mov c, 512
1472   0831 04            load
1473   0832 07 36 08      call get_dirID_from_path
1474   0835 06            sysret
1475   0836             get_dirID_from_path:
1476   0836 26 BC 1E      mov b, user_data
1477   0839 FD 42 6A 16   mov [prog], b                  ; token pointer set to path string
1478   083D 07 CB 14      call get_token
1479   0840 31 6D 16      mov bl, [tok]
1480   0843 C1 01         cmp bl, TOK_FSLASH
1481   0845 C6 51 08      je get_dirID_from_path_abs 
1482   0848 14 7F 17      mov a, [current_dir_id]
1483   084B 07 51 16      call _putback
1484   084E 0A 54 08      jmp get_dirID_from_path_E0
1485   0851             get_dirID_from_path_abs:
1486   0851 10 20 00      mov a, root_id
1487   0854             get_dirID_from_path_E0:
1488   0854 07 CB 14      call get_token
1489   0857 31 6C 16      mov bl, [toktyp]
1490   085A C1 00         cmp bl, TOKTYP_IDENTIFIER
1491   085C C7 AD 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1492   085F             
1493   085F FD 4D 6E 16   mov si, tokstr
1494   0863 FD 4F 3C 1E   mov di, filename
1495   0867 07 9D 10      call _strcpy        
1496   086A 77            inc a                         ; metadata sector
1497   086B 27            mov b, a
1498   086C 38 00 00      mov c, 0                      ; upper LBA = 0
1499   086F 22 01         mov ah, $01                  ; 1 sector
1500   0871 3B BC 26      mov d, transient_area
1501   0874 07 A2 04      call ide_read_sect            ; read directory
1502   0877 FD 10         cla
1503   0879 42 77 17      mov [index], a
1504   087C             get_dirID_from_path_L1:
1505   087C FD 4E         mov si, d
1506   087E FD 4F 3C 1E   mov di, filename
1507   0882 07 88 10      call _strcmp
1508   0885 C6 9B 08      je get_dirID_from_path_name_equal  
1509   0888 58 20 00      add d, 32
1510   088B 14 77 17      mov a, [index]
1511   088E 77            inc a
1512   088F 42 77 17      mov [index], a
1513   0892 AF 10 00      cmp a, FST_FILES_PER_DIR
1514   0895 C6 AE 08      je get_dirID_from_path_fail
1515   0898 0A 7C 08      jmp get_dirID_from_path_L1
1516   089B             get_dirID_from_path_name_equal:
1517   089B 58 19 00      add d, 25           
1518   089E 15            mov a, [d]                    ; set result register A = dirID
1519   089F 07 CB 14      call get_token
1520   08A2 31 6D 16      mov bl, [tok]
1521   08A5 C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1522   08A7 C6 54 08      je get_dirID_from_path_E0
1523   08AA 07 51 16      call _putback
1524   08AD             get_dirID_from_path_end:
1525   08AD 09            ret
1526   08AE             get_dirID_from_path_fail:
1527   08AE 10 FF FF      mov A, $FFFF
1528   08B1 09            ret
1529   08B2             
1530   08B2             
1531   08B2             ;------------------------------------------------------------------------------------------------------;
1532   08B2             ; check if file exists by a given path string
1533   08B2             ; in_puts:
1534   08B2             ; D = path pointer 
1535   08B2             ; OUTPUTS:
1536   08B2             ; A = success code, if file exists gives LBA, else, give 0
1537   08B2             ; /usr/local/bin/ed
1538   08B2             ;------------------------------------------------------------------------------------------------------;
1539   08B2             fs_filepath_exists_user:
1540   08B2 FD 4E         mov si, d
1541   08B4 FD 4F BC 1E   mov di, user_data
1542   08B8 38 00 02      mov c, 512
1543   08BB 04            load
1544   08BC 07 C0 08      call file_exists_by_path
1545   08BF 06            sysret
1546   08C0             file_exists_by_path:
1547   08C0 26 BC 1E      mov b, user_data
1548   08C3 FD 42 6A 16   mov [prog], b                   ; token pointer set to path string
1549   08C7 07 CB 14      call get_token
1550   08CA 31 6D 16      mov bl, [tok]
1551   08CD C1 01         cmp bl, TOK_FSLASH
1552   08CF C6 DB 08      je  file_exists_by_path_abs
1553   08D2 14 7F 17      mov a, [current_dir_id]
1554   08D5 07 51 16      call _putback
1555   08D8 0A DE 08      jmp file_exists_by_path_E0
1556   08DB             file_exists_by_path_abs:
1557   08DB 10 20 00      mov a, root_id
1558   08DE             file_exists_by_path_E0:
1559   08DE 07 CB 14      call get_token
1560   08E1 31 6C 16      mov bl, [toktyp]
1561   08E4 C1 00         cmp bl, TOKTYP_IDENTIFIER
1562   08E6 C7 3E 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1563   08E9 FD 4D 6E 16   mov si, tokstr
1564   08ED FD 4F 3C 1E   mov di, filename
1565   08F1 07 9D 10      call _strcpy        
1566   08F4 77            inc a                           ; metadata sector
1567   08F5 27            mov b, a
1568   08F6 38 00 00      mov c, 0                        ; upper LBA = 0
1569   08F9 22 01         mov ah, $01                  ; 1 sector
1570   08FB 3B BC 26      mov d, transient_area
1571   08FE 07 A2 04      call ide_read_sect              ; read directory
1572   0901 FD 10         cla
1573   0903 42 77 17      mov [index], a
1574   0906             file_exists_by_path_L1:
1575   0906 FD 4E         mov si, d
1576   0908 FD 4F 3C 1E   mov di, filename
1577   090C 07 88 10      call _strcmp
1578   090F C6 25 09      je   file_exists_by_path_name_equal
1579   0912 58 20 00      add d, 32
1580   0915 14 77 17      mov a, [index]
1581   0918 77            inc a
1582   0919 42 77 17      mov [index], a
1583   091C AF 10 00      cmp a, FST_FILES_PER_DIR
1584   091F C6 3E 09      je file_exists_by_path_end
1585   0922 0A 06 09      jmp file_exists_by_path_L1
1586   0925             file_exists_by_path_name_equal:
1587   0925 33 18 00      mov bl, [d + 24]
1588   0928 FD 87 38      and bl, %00111000               ; directory flag
1589   092B C1 08         cmp bl, %00001000               ; is dir?
1590   092D C6 34 09      je file_exists_by_path_isdir;
1591   0930             ; entry is a file
1592   0930 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1593   0933 09            ret
1594   0934             file_exists_by_path_isdir:
1595   0934 58 19 00      add d, 25           
1596   0937 15            mov a, [d]                      ; set result register A = dirID
1597   0938 07 CB 14      call get_token
1598   093B 0A DE 08      jmp file_exists_by_path_E0
1599   093E             file_exists_by_path_end:
1600   093E 10 00 00      mov a, 0                        ; return 0 because file was not found
1601   0941 09            ret
1602   0942             
1603   0942             ;------------------------------------------------------------------------------------------------------;
1604   0942             ; load file data from a given path string
1605   0942             ; inputs:
1606   0942             ; D = path pointer 
1607   0942             ; DI = userspace program data destination
1608   0942             ; /usr/local/bin/ed
1609   0942             ; ./ed
1610   0942             ;------------------------------------------------------------------------------------------------------;
1611   0942             fs_load_from_path_user:
1612   0942 E3            push di
1613   0943 FD 4E         mov si, d
1614   0945 FD 4F BC 1E   mov di, user_data
1615   0949 38 00 02      mov c, 512
1616   094C 04            load
1617   094D 07 5A 09      call loadfile_from_path
1618   0950 F0            pop di
1619   0951 FD 4D BC 26   mov si, transient_area
1620   0955 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1621   0958 03            store
1622   0959 06            sysret
1623   095A             loadfile_from_path:
1624   095A 26 BC 1E      mov b, user_data
1625   095D FD 42 6A 16   mov [prog], b                 ; token pointer set to path string
1626   0961 07 CB 14      call get_token
1627   0964 31 6D 16      mov bl, [tok]
1628   0967 C1 01         cmp bl, TOK_FSLASH
1629   0969 C6 75 09      je loadfile_from_path_abs 
1630   096C 14 7F 17      mov a, [current_dir_id]
1631   096F 07 51 16      call _putback
1632   0972 0A 78 09      jmp loadfile_from_path_E0
1633   0975             loadfile_from_path_abs:
1634   0975 10 20 00      mov a, root_id
1635   0978             loadfile_from_path_E0:
1636   0978 07 CB 14      call get_token
1637   097B 31 6C 16      mov bl, [toktyp]
1638   097E C1 00         cmp bl, TOKTYP_IDENTIFIER
1639   0980 C7 E5 09      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1640   0983 FD 4D 6E 16   mov si, tokstr
1641   0987 FD 4F 3C 1E   mov di, filename
1642   098B 07 9D 10      call _strcpy        
1643   098E 77            inc a                         ; metadata sector
1644   098F 27            mov b, a
1645   0990 38 00 00      mov c, 0                      ; upper LBA = 0
1646   0993 22 01         mov ah, $01                  ; 1 sector
1647   0995 3B BC 26      mov d, transient_area
1648   0998 07 A2 04      call ide_read_sect            ; read directory
1649   099B FD 10         cla
1650   099D 42 77 17      mov [index], a
1651   09A0             loadfile_from_path_L1:
1652   09A0 FD 4E         mov si, d
1653   09A2 FD 4F 3C 1E   mov di, filename
1654   09A6 07 88 10      call _strcmp
1655   09A9 C6 BF 09      je loadfile_from_path_name_equal  
1656   09AC 58 20 00      add d, 32
1657   09AF 14 77 17      mov a, [index]
1658   09B2 77            inc a
1659   09B3 42 77 17      mov [index], a
1660   09B6 AF 10 00      cmp a, FST_FILES_PER_DIR
1661   09B9 C6 E5 09      je loadfile_from_path_end
1662   09BC 0A A0 09      jmp loadfile_from_path_L1
1663   09BF             loadfile_from_path_name_equal:
1664   09BF 33 18 00      mov bl, [d + 24]
1665   09C2 FD 87 38      and bl, %00111000             ; directory flag
1666   09C5 C1 08         cmp bl, %00001000             ; is dir?
1667   09C7 C6 DB 09      je loadfile_isdirectory  
1668   09CA             ; entry is a file
1669   09CA 2B 19 00      mov b, [d + 25]               ; get LBA
1670   09CD FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1671   09CF 3B BC 26      mov d, transient_area
1672   09D2 38 00 00      mov c, 0
1673   09D5 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1674   09D7 07 A2 04      call ide_read_sect            ; read sector
1675   09DA 09            ret
1676   09DB             loadfile_isdirectory:
1677   09DB 58 19 00      add d, 25           
1678   09DE 15            mov a, [d]                    ; set result register A = dirID
1679   09DF 07 CB 14      call get_token
1680   09E2 0A 78 09      jmp loadfile_from_path_E0
1681   09E5             loadfile_from_path_end:
1682   09E5 09            ret
1683   09E6             
1684   09E6             ;------------------------------------------------------------------------------------------------------;
1685   09E6             ; return the ID of the current directory
1686   09E6             ; ID returned in B
1687   09E6             ;------------------------------------------------------------------------------------------------------;
1688   09E6             fs_get_curr_dirID:
1689   09E6 29 7F 17      mov b, [current_dir_id]
1690   09E9 06            sysret
1691   09EA             
1692   09EA             ;------------------------------------------------------------------------------------------------------;
1693   09EA             ; CD
1694   09EA             ;------------------------------------------------------------------------------------------------------;
1695   09EA             ; new dirID in B
1696   09EA             fs_cd:
1697   09EA FD 42 7F 17   mov [current_dir_id], b
1698   09EE 06            sysret  
1699   09EF             
1700   09EF             ;------------------------------------------------------------------------------------------------------;
1701   09EF             ; LS
1702   09EF             ; dirID in B
1703   09EF             ;------------------------------------------------------------------------------------------------------;
1704   09EF 00 00       ls_count:       .dw 0
1705   09F1             fs_ls:
1706   09F1 FD 77         inc b                        ; metadata sector
1707   09F3 38 00 00      mov c, 0                     ; upper LBA = 0
1708   09F6 22 01         mov ah, $01                  ; 1 sector
1709   09F8 3B BC 26      mov d, transient_area
1710   09FB 07 A2 04      call ide_read_sect           ; read directory
1711   09FE FD 10         cla
1712   0A00 42 77 17      mov [index], a               ; reset entry index
1713   0A03 3D EF 09      mov [ls_count], al           ; reset item count
1714   0A06             fs_ls_L1:
1715   0A06 BD 00         cmp byte [d], 0              ; check for NULL
1716   0A08 C6 9F 0A      je fs_ls_next
1717   0A0B             fs_ls_non_null:
1718   0A0B 1D EF 09      mov al, [ls_count]
1719   0A0E 7A            inc al
1720   0A0F 3D EF 09      mov [ls_count], al           ; increment item count
1721   0A12 1F 18 00      mov al, [d + 24]
1722   0A15 87 38         and al, %00111000
1723   0A17 FD A2 03      shr al, 3
1724   0A1A 22 00         mov ah, 0                    ; file type
1725   0A1C B7 9B 17      mov a, [a + file_type]      
1726   0A1F 23            mov ah, al
1727   0A20 07 19 11      call _putchar
1728   0A23 1F 18 00      mov al, [d + 24]
1729   0A26 87 01         and al, %00000001
1730   0A28 22 00         mov ah, 0
1731   0A2A B7 96 17      mov a, [a + file_attrib]     ; read
1732   0A2D 23            mov ah, al
1733   0A2E 07 19 11      call _putchar
1734   0A31 1F 18 00      mov al, [d + 24]
1735   0A34 87 02         and al, %00000010
1736   0A36 22 00         mov ah, 0
1737   0A38 B7 96 17      mov a, [a + file_attrib]     ; write
1738   0A3B 23            mov ah, al
1739   0A3C 07 19 11      call _putchar
1740   0A3F 1F 18 00      mov al, [d + 24]
1741   0A42 87 04         and al, %00000100
1742   0A44 22 00         mov ah, 0
1743   0A46 B7 96 17      mov a, [a + file_attrib]     ; execute
1744   0A49 23            mov ah, al
1745   0A4A 07 19 11      call _putchar
1746   0A4D 22 20         mov ah, $20
1747   0A4F 07 19 11      call _putchar  
1748   0A52 2B 1B 00      mov b, [d + 27]
1749   0A55 07 A1 12      call print_u16x              ; filesize
1750   0A58 22 20         mov ah, $20
1751   0A5A 07 19 11      call _putchar  
1752   0A5D 2B 19 00      mov b, [d + 25]
1753   0A60 07 A1 12      call print_u16x              ; dirID / LBA
1754   0A63 22 20         mov ah, $20
1755   0A65 07 19 11      call _putchar
1756   0A68             ; print date
1757   0A68 33 1D 00      mov bl, [d + 29]             ; day
1758   0A6B 07 E5 12      call print_u8x
1759   0A6E 22 20         mov ah, $20
1760   0A70 07 19 11      call _putchar  
1761   0A73 1F 1E 00      mov al, [d + 30]             ; month
1762   0A76 FD 9E 02      shl al, 2
1763   0A79 DA            push d
1764   0A7A 3B 5A 18      mov d, s_months
1765   0A7D 22 00         mov ah, 0
1766   0A7F 59            add d, a
1767   0A80 07 45 12      call _puts
1768   0A83 E7            pop d
1769   0A84 22 20         mov ah, $20
1770   0A86 07 19 11      call _putchar
1771   0A89 2E 20         mov bl, $20
1772   0A8B 07 E5 12      call print_u8x
1773   0A8E 33 1F 00      mov bl, [d + 31]             ; year
1774   0A91 07 E5 12      call print_u8x  
1775   0A94 22 20         mov ah, $20
1776   0A96 07 19 11      call _putchar  
1777   0A99 07 45 12      call _puts                   ; print filename  
1778   0A9C 07 F2 11      call printnl
1779   0A9F             fs_ls_next:
1780   0A9F 14 77 17      mov a, [index]
1781   0AA2 77            inc a
1782   0AA3 42 77 17      mov [index], a
1783   0AA6 AF 10 00      cmp a, FST_FILES_PER_DIR
1784   0AA9 C6 B2 0A      je fs_ls_end
1785   0AAC 58 20 00      add d, 32      
1786   0AAF 0A 06 0A      jmp fs_ls_L1  
1787   0AB2             fs_ls_end:
1788   0AB2 3B AB 17      mov d, s_ls_total
1789   0AB5 07 45 12      call _puts
1790   0AB8 1D EF 09      mov al, [ls_count]
1791   0ABB 07 F7 12      call print_u8d
1792   0ABE 07 F2 11      call printnl
1793   0AC1 06            sysret
1794   0AC2             
1795   0AC2             
1796   0AC2             ; file structure:
1797   0AC2             ; 512 bytes header
1798   0AC2             ; header used to tell whether the block is free
1799   0AC2             ;------------------------------------------------------------------------------------------------------;
1800   0AC2             ; CREATE NEW TEXTFILE
1801   0AC2             ;------------------------------------------------------------------------------------------------------;
1802   0AC2             ; d = content pointer in user space
1803   0AC2             ; c = file size
1804   0AC2             fs_starcom:
1805   0AC2 FD 4E       	mov si, d
1806   0AC4 FD 4F BC 26 	mov di, transient_area
1807   0AC8 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1808   0ACB 04          	load					; load data from user-space
1809   0ACC 07 4D 0B    	call fs_find_empty_block	; look for empty data blocks
1810   0ACF D8          	push b				; save empty block LBA
1811   0AD0 FD 79         mov g, b
1812   0AD2             ;create header file by grabbing file name from parameter	
1813   0AD2 3B BC 28    	mov d, transient_area + 512			; pointer to file contents
1814   0AD5 D9          	push c							; save length
1815   0AD6 19 01       	mov al, 1
1816   0AD8 3D BC 26    	mov [transient_area], al					; mark sectors as USED (not NULL)
1817   0ADB 3B BC 26    	mov d, transient_area
1818   0ADE 12            mov a, c
1819   0ADF 26 00 02      mov b, 512
1820   0AE2 AE            div a, b
1821   0AE3 FD 77         inc b         ; inc b as the division will most likely have a remainder
1822   0AE5 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1823   0AE6 38 00 00    	mov c, 0      ; lba 
1824   0AE9 FD 27         mov b, g      ; lba 
1825   0AEB 07 C8 04    	call ide_write_sect			; write sectors
1826   0AEE             ; now we add the file to the current directory!
1827   0AEE             fs_starcom_add_to_dir:	
1828   0AEE 14 7F 17    	mov a, [current_dir_id]
1829   0AF1 77          	inc a
1830   0AF2 27          	mov b, a					; metadata sector
1831   0AF3 38 00 00    	mov c, 0
1832   0AF6 FD 79       	mov g, b					; save LBA
1833   0AF8 3B BC 24    	mov d, scrap_sector
1834   0AFB 22 01       	mov ah, $01			  ; 1 sector
1835   0AFD 07 A2 04    	call ide_read_sect		; read metadata sector
1836   0B00             fs_starcom_add_to_dir_L2:
1837   0B00 BD 00       	cmp byte[d], 0
1838   0B02 C6 0B 0B    	je fs_starcom_add_to_dir_null
1839   0B05 58 20 00    	add d, FST_ENTRY_SIZE
1840   0B08 0A 00 0B    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1841   0B0B             fs_starcom_add_to_dir_null:
1842   0B0B FD 4D BD 26 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1843   0B0F FD 50       	mov di, d
1844   0B11 07 9D 10    	call _strcpy			; copy file name
1845   0B14 58 18 00    	add d, 24			; skip name
1846   0B17 19 07       	mov al, %00000111	; type=file, execute, write, read
1847   0B19 3E          	mov [d], al			
1848   0B1A 58 03 00    	add d, 3
1849   0B1D E4          	pop a
1850   0B1E 5F 00 02      sub a, 512
1851   0B21 43          	mov [d], a ; file size
1852   0B22 63 02 00    	sub d, 2
1853   0B25 E5          	pop b				; get file LBA
1854   0B26 FD 43       	mov [d], b			; save LBA	
1855   0B28             ; set file creation date	
1856   0B28 58 04 00    	add d, 4
1857   0B2B 19 04       	mov al, 4
1858   0B2D 05 01       	syscall sys_rtc
1859   0B2F 1A          	mov al, ah
1860   0B30 3E          	mov [d], al			; set day
1861   0B31 79          	inc d
1862   0B32 19 05       	mov al, 5
1863   0B34 05 01       	syscall sys_rtc
1864   0B36 1A          	mov al, ah
1865   0B37 3E          	mov [d], al			; set month
1866   0B38 79          	inc d
1867   0B39 19 06       	mov al, 6
1868   0B3B 05 01       	syscall sys_rtc
1869   0B3D 1A          	mov al, ah
1870   0B3E 3E          	mov [d], al			; set year
1871   0B3F             ; write sector into disk for new directory entry
1872   0B3F FD 27       	mov b, g
1873   0B41 38 00 00    	mov c, 0
1874   0B44 3B BC 24    	mov d, scrap_sector
1875   0B47 22 01       	mov ah, $01			; disk write, 1 sector
1876   0B49 07 C8 04    	call ide_write_sect		; write sector
1877   0B4C 06          	sysret
1878   0B4D             
1879   0B4D             ;------------------------------------------------------------------------------------------------------;
1880   0B4D             ; finds an empty data block
1881   0B4D             ; block LBA returned in B
1882   0B4D             ;------------------------------------------------------------------------------------------------------;
1883   0B4D             fs_find_empty_block:
1884   0B4D 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1885   0B50 38 00 00      mov c, 0                ; upper LBA = 0
1886   0B53             fs_find_empty_block_L1:  
1887   0B53 22 01         mov ah, $01                  ; 1 sector
1888   0B55 3B BC 24      mov d, transient_area - 512
1889   0B58 07 A2 04      call ide_read_sect      ; read sector
1890   0B5B BD 00         cmp byte [d], 0
1891   0B5D C6 66 0B      je fs_find_empty_block_found_null
1892   0B60 55 20 00      add b, FS_SECTORS_PER_FILE
1893   0B63 0A 53 0B      jmp fs_find_empty_block_L1
1894   0B66             fs_find_empty_block_found_null:
1895   0B66 09            ret
1896   0B67             
1897   0B67             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1898   0B67             ;; CREATE NEW TEXTFILE
1899   0B67             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1900   0B67             ; search for first null block
1901   0B67             fs_mktxt:
1902   0B67 FD 4E       	mov si, d
1903   0B69 FD 4F BC 1E 	mov di, user_data
1904   0B6D 38 00 01    	mov c, 256
1905   0B70 04          	load					; load data from user-space
1906   0B71             	
1907   0B71 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1908   0B74 38 00 00    	mov c, 0						; reset LBA to 0
1909   0B77             fs_mktxt_L1:	
1910   0B77 10 02 01    	mov a, $0102			; disk read
1911   0B7A 3B BC 26    	mov d, transient_area
1912   0B7D 05 02       	syscall sys_ide ; read sector
1913   0B7F 1E          	mov al, [d]
1914   0B80 B9 00       	cmp al, 0			; check for NULL
1915   0B82 C6 8B 0B    	je fs_mktxt_found_null
1916   0B85 55 20 00    	add b, FS_SECTORS_PER_FILE
1917   0B88 0A 77 0B    	jmp fs_mktxt_L1
1918   0B8B             fs_mktxt_found_null:
1919   0B8B D8          	push b				; save LBA
1920   0B8C             ;create header file by grabbing file name from parameter	
1921   0B8C 3B 8C 17    	mov d, s_dataentry
1922   0B8F 07 45 12    	call _puts
1923   0B92 3B BC 28    	mov d, transient_area + 512			; pointer to file contents
1924   0B95 07 AB 11    	call _gettxt
1925   0B98 07 78 10    	call _strlen						; get length of file
1926   0B9B D9          	push c							; save length
1927   0B9C 19 01       	mov al, 1
1928   0B9E 3D BC 26    	mov [transient_area], al					; mark sectors as USED (not NULL)
1929   0BA1 10 00 00    	mov a, 0
1930   0BA4 42 77 17    	mov [index], a
1931   0BA7 3B BC 26    	mov d, transient_area
1932   0BAA 13          	mov a, d
1933   0BAB 42 79 17    	mov [buffer_addr], a
1934   0BAE             fs_mktxt_L2:
1935   0BAE 38 00 00    	mov c, 0
1936   0BB1 10 03 01    	mov a, $0103			; disk write, 1 sector
1937   0BB4 05 02       	syscall sys_ide		; write sector
1938   0BB6 14 77 17    	mov a, [index]
1939   0BB9 77          	inc a
1940   0BBA 42 77 17    	mov [index], a
1941   0BBD AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1942   0BC0 C6 D2 0B    	je fs_mktxt_add_to_dir
1943   0BC3 FD 77       	inc b
1944   0BC5 14 79 17    	mov a, [buffer_addr]
1945   0BC8 53 00 02    	add a, 512
1946   0BCB 42 79 17    	mov [buffer_addr], a
1947   0BCE 3C          	mov d, a
1948   0BCF 0A AE 0B    	jmp fs_mktxt_L2
1949   0BD2             ; now we add the file to the current directory!
1950   0BD2             fs_mktxt_add_to_dir:	
1951   0BD2 14 7F 17    	mov a, [current_dir_id]
1952   0BD5 77          	inc a
1953   0BD6 27          	mov b, a					; metadata sector
1954   0BD7 38 00 00    	mov c, 0
1955   0BDA FD 79       	mov g, b					; save LBA
1956   0BDC 3B BC 26    	mov d, transient_area
1957   0BDF 10 02 01    	mov a, $0102			; disk read
1958   0BE2 05 02       	syscall sys_ide		; read metadata sector
1959   0BE4             fs_mktxt_add_to_dir_L2:
1960   0BE4 1E          	mov al, [d]
1961   0BE5 B9 00       	cmp al, 0
1962   0BE7 C6 F0 0B    	je fs_mktxt_add_to_dir_null
1963   0BEA 58 20 00    	add d, FST_ENTRY_SIZE
1964   0BED 0A E4 0B    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1965   0BF0             fs_mktxt_add_to_dir_null:
1966   0BF0 FD 4D BC 1E 	mov si, user_data
1967   0BF4 FD 50       	mov di, d
1968   0BF6 07 9D 10    	call _strcpy			; copy file name
1969   0BF9 58 18 00    	add d, 24			; skip name
1970   0BFC 19 06       	mov al, %00000110		; no execute, write, read, not directory
1971   0BFE 3E          	mov [d], al			
1972   0BFF 58 03 00    	add d, 3
1973   0C02 E4          	pop a
1974   0C03 43          	mov [d], a
1975   0C04 63 02 00    	sub d, 2
1976   0C07 E5          	pop b				; get file LBA
1977   0C08 FD 43       	mov [d], b			; save LBA	
1978   0C0A             	
1979   0C0A             	; set file creation date	
1980   0C0A 58 04 00    	add d, 4
1981   0C0D 19 04       	mov al, 4
1982   0C0F 05 01       	syscall sys_rtc
1983   0C11 1A          	mov al, ah
1984   0C12 3E          	mov [d], al			; set day
1985   0C13             	
1986   0C13 79          	inc d
1987   0C14 19 05       	mov al, 5
1988   0C16 05 01       	syscall sys_rtc
1989   0C18 1A          	mov al, ah
1990   0C19 3E          	mov [d], al			; set month
1991   0C1A             	
1992   0C1A 79          	inc d
1993   0C1B 19 06       	mov al, 6
1994   0C1D 05 01       	syscall sys_rtc
1995   0C1F 1A          	mov al, ah
1996   0C20 3E          	mov [d], al			; set year
1997   0C21             	
1998   0C21             ; write sector into disk for new directory entry
1999   0C21 FD 27       	mov b, g
2000   0C23 38 00 00    	mov c, 0
2001   0C26 3B BC 26    	mov d, transient_area
2002   0C29 10 03 01    	mov a, $0103			; disk write, 1 sector
2003   0C2C 05 02       	syscall sys_ide		; write sector
2004   0C2E 07 F2 11    	call printnl
2005   0C31 06          	sysret
2006   0C32             
2007   0C32             
2008   0C32             
2009   0C32             ;------------------------------------------------------------------------------------------------------;
2010   0C32             ; CREATE NEW BINARY FILE
2011   0C32             ;------------------------------------------------------------------------------------------------------;
2012   0C32             ; search for first null block
2013   0C32             fs_mkbin:
2014   0C32 19 00         mov al, 0
2015   0C34 3D 6F 17      mov [sys_echo_on], al ; disable echo
2016   0C37 FD 4E         mov si, d
2017   0C39 FD 4F BC 1E   mov di, user_data
2018   0C3D 38 00 02      mov c, 512
2019   0C40 04            load                          ; load data from user-space
2020   0C41 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
2021   0C44 38 00 00      mov c, 0                      ; upper LBA = 0
2022   0C47             fs_mkbin_L1:  
2023   0C47 22 01         mov ah, $01                  ; 1 sector
2024   0C49 3B BC 26      mov d, transient_area
2025   0C4C 07 A2 04      call ide_read_sect            ; read sector
2026   0C4F BD 00         cmp byte[d], 0                ; check for NULL
2027   0C51 C6 5A 0C      je fs_mkbin_found_null
2028   0C54 55 20 00      add b, FS_SECTORS_PER_FILE
2029   0C57 0A 47 0C      jmp fs_mkbin_L1
2030   0C5A             fs_mkbin_found_null:
2031   0C5A D8            push b                        ; save LBA
2032   0C5B             ;create header file by grabbing file name from parameter
2033   0C5B FD 4F BC 28   mov di, transient_area + 512  ; pointer to file contents
2034   0C5F 07 D5 0F      call _load_hex                ; load binary hex
2035   0C62 D9            push c                        ; save size (nbr of bytes)
2036   0C63 19 01         mov al, 1
2037   0C65 3D BC 26      mov [transient_area], al      ; mark sectors as USED (not NULL)
2038   0C68 FD 10         cla
2039   0C6A 42 77 17      mov [index], a
2040   0C6D 3B BC 26      mov d, transient_area
2041   0C70 13            mov a, d
2042   0C71 42 79 17      mov [buffer_addr], a
2043   0C74             fs_mkbin_L2:
2044   0C74 38 00 00      mov c, 0
2045   0C77 22 01         mov ah, $01                   ; disk write, 1 sector
2046   0C79 07 C8 04      call ide_write_sect           ; write sector
2047   0C7C 14 77 17      mov a, [index]
2048   0C7F 77            inc a
2049   0C80 42 77 17      mov [index], a
2050   0C83 AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
2051   0C86 C6 98 0C      je fs_mkbin_add_to_dir
2052   0C89 FD 77         inc b
2053   0C8B 14 79 17      mov a, [buffer_addr]
2054   0C8E 53 00 02      add a, 512
2055   0C91 42 79 17      mov [buffer_addr], a
2056   0C94 3C            mov d, a
2057   0C95 0A 74 0C      jmp fs_mkbin_L2
2058   0C98             ; now we add the file to the current directory!
2059   0C98             fs_mkbin_add_to_dir:  
2060   0C98 14 7F 17      mov a, [current_dir_id]
2061   0C9B 77            inc a
2062   0C9C 27            mov b, a                      ; metadata sector
2063   0C9D 38 00 00      mov c, 0
2064   0CA0 FD 79         mov g, b                      ; save LBA
2065   0CA2 3B BC 26      mov d, transient_area
2066   0CA5 22 01         mov ah, $01                  ; 1 sector
2067   0CA7 07 A2 04      call ide_read_sect            ; read metadata sector
2068   0CAA             fs_mkbin_add_to_dir_L2:
2069   0CAA BD 00         cmp byte[d], 0
2070   0CAC C6 B5 0C      je fs_mkbin_add_to_dir_null
2071   0CAF 58 20 00      add d, FST_ENTRY_SIZE
2072   0CB2 0A AA 0C      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
2073   0CB5             fs_mkbin_add_to_dir_null:
2074   0CB5 FD 4D BC 1E   mov si, user_data
2075   0CB9 FD 50         mov di, d
2076   0CBB 07 9D 10      call _strcpy                  ; copy file name
2077   0CBE 58 18 00      add d, 24                     ; skip name
2078   0CC1 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2079   0CC3 3E            mov [d], al
2080   0CC4 58 03 00      add d, 3
2081   0CC7 E4            pop a
2082   0CC8 43            mov [d], a
2083   0CC9 63 02 00      sub d, 2
2084   0CCC E5            pop b                         ; get file LBA
2085   0CCD FD 43         mov [d], b                    ; save LBA
2086   0CCF               ; set file creation date  
2087   0CCF 58 04 00      add d, 4
2088   0CD2 19 04         mov al, 4
2089   0CD4 05 01         syscall sys_rtc
2090   0CD6 1A            mov al, ah
2091   0CD7 3E            mov [d], al                   ; set day
2092   0CD8 79            inc d
2093   0CD9 19 05         mov al, 5
2094   0CDB 05 01         syscall sys_rtc
2095   0CDD 1A            mov al, ah
2096   0CDE 3E            mov [d], al                   ; set month
2097   0CDF 79            inc d
2098   0CE0 19 06         mov al, 6
2099   0CE2 05 01         syscall sys_rtc
2100   0CE4 1A            mov al, ah
2101   0CE5 3E            mov [d], al                   ; set year
2102   0CE6             ; write sector into disk for new directory entry
2103   0CE6 FD 27         mov b, g
2104   0CE8 38 00 00      mov c, 0
2105   0CEB 3B BC 26      mov d, transient_area
2106   0CEE 22 01         mov ah, $01                   ; disk write, 1 sector
2107   0CF0 07 C8 04      call ide_write_sect           ; write sector
2108   0CF3 19 01         mov al, 1
2109   0CF5 3D 6F 17      mov [sys_echo_on], al ; enable echo
2110   0CF8 06            sysret
2111   0CF9             
2112   0CF9             ;------------------------------------------------------------------------------------------------------;
2113   0CF9             ; PWD - PRINT WORKING DIRECTORY
2114   0CF9             ;------------------------------------------------------------------------------------------------------;    
2115   0CF9             fs_pwd:
2116   0CF9 3B 3C 1E      mov d, filename
2117   0CFC 19 00         mov al, 0
2118   0CFE 3E            mov [d], al                   ; initialize path string 
2119   0CFF 14 7F 17      mov a, [current_dir_id]
2120   0D02 07 D8 07      call fs_dir_id_to_path_E0
2121   0D05 3B 3C 1E      mov d, filename
2122   0D08 07 31 10      call _strrev
2123   0D0B 07 45 12      call _puts
2124   0D0E 07 F2 11      call printnl
2125   0D11 06            sysret
2126   0D12             
2127   0D12             ;------------------------------------------------------------------------------------------------------;
2128   0D12             ; get current directory LBA
2129   0D12             ; A: returned LBA
2130   0D12             ;------------------------------------------------------------------------------------------------------;
2131   0D12             cmd_get_curr_dir_LBA:
2132   0D12 14 7F 17      mov a, [current_dir_id]
2133   0D15 06            sysret
2134   0D16             
2135   0D16             ;------------------------------------------------------------------------------------------------------;
2136   0D16             ; CAT
2137   0D16             ; userspace destination data pointer in D
2138   0D16             ; filename starts at D, but is overwritten after the read is made
2139   0D16             ;------------------------------------------------------------------------------------------------------;:
2140   0D16             fs_cat:
2141   0D16 DA            push d                              ; save userspace file data destination
2142   0D17 FD 4E         mov si, d
2143   0D19 FD 4F BC 1E   mov di, user_data
2144   0D1D 38 00 02      mov c, 512
2145   0D20 04            load                                ; copy filename from user-space
2146   0D21 29 7F 17      mov b, [current_dir_id]
2147   0D24 FD 77         inc b                               ; metadata sector
2148   0D26 38 00 00      mov c, 0                            ; upper LBA = 0
2149   0D29 22 01         mov ah, $01                  ; 1 sector
2150   0D2B 3B BC 24      mov d, transient_area-512
2151   0D2E 07 A2 04      call ide_read_sect                  ; read directory
2152   0D31 FD 10         cla
2153   0D33 42 77 17      mov [index], a                      ; reset file counter
2154   0D36             fs_cat_L1:
2155   0D36 FD 4E         mov si, d
2156   0D38 FD 4F BC 1E   mov di, user_data
2157   0D3C 07 88 10      call _strcmp
2158   0D3F C6 55 0D      je fs_cat_found_entry
2159   0D42 58 20 00      add d, 32
2160   0D45 14 77 17      mov a, [index]
2161   0D48 77            inc a
2162   0D49 42 77 17      mov [index], a
2163   0D4C AF 10 00      cmp a, FST_FILES_PER_DIR
2164   0D4F C6 70 0D      je fs_cat_not_found
2165   0D52 0A 36 0D      jmp fs_cat_L1
2166   0D55             fs_cat_found_entry:
2167   0D55 58 19 00      add d, 25                           ; get to dirID of file in disk
2168   0D58 2A            mov b, [d]                          ; get LBA
2169   0D59 FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2170   0D5B 3B BC 26      mov d, transient_area  
2171   0D5E 38 00 00      mov c, 0
2172   0D61 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2173   0D63 07 A2 04      call ide_read_sect                  ; read sectors
2174   0D66 F0            pop di                              ; write userspace file data destination to DI
2175   0D67 FD 4D BC 26   mov si, transient_area              ; data origin
2176   0D6B 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2177   0D6E 03            store
2178   0D6F 06            sysret
2179   0D70             fs_cat_not_found:
2180   0D70 E7            pop d
2181   0D71 06            sysret
2182   0D72             
2183   0D72             ;------------------------------------------------------------------------------------------------------;
2184   0D72             ; RMDIR - remove DIR by dirID
2185   0D72             ;------------------------------------------------------------------------------------------------------;
2186   0D72             ; deletes a directory entry in the given directory's file list 
2187   0D72             ; also deletes the actual directory entry in the FST
2188   0D72             ; synopsis: rmdir /usr/local/testdir
2189   0D72             ; B = dirID
2190   0D72             fs_rmdir:
2191   0D72 FD 79         mov g, b
2192   0D74 11            mov a, b
2193   0D75 07 14 08      call get_parentID_from_dirID  ; now get the directory's parent, in A
2194   0D78 D7            push a                        ; save dirID
2195   0D79             ; search for directory's entry in the parent's directory then and delete it
2196   0D79 77            inc a                         ; metadata sector
2197   0D7A 27            mov b, a
2198   0D7B 38 00 00      mov c, 0                      ; upper LBA = 0
2199   0D7E 22 01         mov ah, $01          ;
2200   0D80 3B BC 26      mov d, transient_area
2201   0D83 07 A2 04      call ide_read_sect            ; read directory
2202   0D86 FD 10         cla
2203   0D88 42 77 17      mov [index], a                ; reset file counter
2204   0D8B FD 27         mov b, g                      ; retrieve directory's dirID
2205   0D8D             fs_rmdir_L1:
2206   0D8D 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2207   0D90 B0            cmp a, b                      ; compare dirID's to find the directory
2208   0D91 C6 A7 0D      je fs_rmdir_found_entry
2209   0D94 58 20 00      add d, 32
2210   0D97 14 77 17      mov a, [index]
2211   0D9A 77            inc a
2212   0D9B 42 77 17      mov [index], a
2213   0D9E AF 10 00      cmp a, FST_FILES_PER_DIR
2214   0DA1 C6 CC 0D      je fs_rmdir_not_found
2215   0DA4 0A 8D 0D      jmp fs_rmdir_L1
2216   0DA7             fs_rmdir_found_entry:
2217   0DA7 FD 10         cla
2218   0DA9 3E            mov [d], al                   ; make filename NULL
2219   0DAA 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2220   0DAD E5            pop b
2221   0DAE FD 77         inc b                         ; metadata sector
2222   0DB0 38 00 00      mov c, 0                      ; upper LBA = 0
2223   0DB3 22 01         mov ah, $01          ; 
2224   0DB5 3B BC 26      mov d, transient_area
2225   0DB8 07 C8 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2226   0DBB             
2227   0DBB FD 27         mov b, g
2228   0DBD 3B BC 26      mov d, transient_area  
2229   0DC0 FD 10         cla
2230   0DC2 3E            mov [d], al                   ; make directory's name header NULL for re-use
2231   0DC3 38 00 00      mov c, 0
2232   0DC6 22 01         mov ah, $01                   ; disk write 1 sect
2233   0DC8 07 C8 04      call ide_write_sect           ; delete directory given by dirID in B
2234   0DCB 06            sysret
2235   0DCC             fs_rmdir_not_found:
2236   0DCC E5            pop b
2237   0DCD 06            sysret
2238   0DCE             
2239   0DCE             ;------------------------------------------------------------------------------------------------------;
2240   0DCE             ; RM - remove file
2241   0DCE             ;------------------------------------------------------------------------------------------------------;
2242   0DCE             ; frees up the data sectors for the file further down the disk
2243   0DCE             ; deletes file entry in the directory's file list 
2244   0DCE             fs_rm:
2245   0DCE FD 4E         mov si, d
2246   0DD0 FD 4F BC 1E   mov di, user_data
2247   0DD4 38 00 02      mov c, 512
2248   0DD7 04            load                          ; load data from user-space
2249   0DD8 14 7F 17      mov a, [current_dir_id]
2250   0DDB 77            inc a                         ; metadata sector
2251   0DDC 27            mov b, a
2252   0DDD 38 00 00      mov c, 0                      ; upper LBA = 0
2253   0DE0 22 01         mov ah, $01                  ; 1 sector
2254   0DE2 3B BC 26      mov d, transient_area
2255   0DE5 07 A2 04      call ide_read_sect            ; read directory
2256   0DE8 10 00 00      mov a, 0
2257   0DEB 42 77 17      mov [index], a                ; reset file counter
2258   0DEE             fs_rm_L1:
2259   0DEE FD 4E         mov si, d
2260   0DF0 FD 4F BC 1E   mov di, user_data
2261   0DF4 07 88 10      call _strcmp
2262   0DF7 C6 0D 0E      je fs_rm_found_entry
2263   0DFA 58 20 00      add d, 32
2264   0DFD 14 77 17      mov a, [index]
2265   0E00 77            inc a
2266   0E01 42 77 17      mov [index], a
2267   0E04 AF 10 00      cmp a, FST_FILES_PER_DIR
2268   0E07 C6 35 0E      je fs_rm_not_found
2269   0E0A 0A EE 0D      jmp fs_rm_L1
2270   0E0D             fs_rm_found_entry:
2271   0E0D 2B 19 00      mov b, [d + 25]               ; get LBA
2272   0E10 FD 79         mov g, b                      ; save LBA
2273   0E12 19 00         mov al, 0
2274   0E14 3E            mov [d], al                   ; make file entry NULL
2275   0E15 14 7F 17      mov a, [current_dir_id]
2276   0E18 77            inc a                         ; metadata sector
2277   0E19 27            mov b, a
2278   0E1A 38 00 00      mov c, 0                      ; upper LBA = 0
2279   0E1D 22 01         mov ah, $01                   ; disk write
2280   0E1F 3B BC 26      mov d, transient_area
2281   0E22 07 C8 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2282   0E25 3B BC 26      mov d, transient_area  
2283   0E28 19 00         mov al, 0
2284   0E2A 3E            mov [d], al                   ; make file's data header NULL for re-use
2285   0E2B 38 00 00      mov c, 0
2286   0E2E FD 27         mov b, g                      ; get data header LBA
2287   0E30 22 01         mov ah, $01                   ; disk write 1 sect
2288   0E32 07 C8 04      call ide_write_sect           ; write sector
2289   0E35             fs_rm_not_found:  
2290   0E35 06            sysret  
2291   0E36             
2292   0E36             ;------------------------------------------------------------------------------------------------------;
2293   0E36             ; mv - move / change file name
2294   0E36             ;------------------------------------------------------------------------------------------------------;
2295   0E36             fs_mv:
2296   0E36 FD 4E         mov si, d
2297   0E38 FD 4F BC 1E   mov di, user_data
2298   0E3C 38 00 02      mov c, 512
2299   0E3F 04            load                          ; load data from user-space
2300   0E40 14 7F 17      mov a, [current_dir_id]
2301   0E43 77            inc a                         ; metadata sector
2302   0E44 27            mov b, a  
2303   0E45 38 00 00      mov c, 0                      ; upper LBA = 0
2304   0E48 22 01         mov ah, $01                  ; 1 sector
2305   0E4A 3B BC 26      mov d, transient_area
2306   0E4D 07 A2 04      call ide_read_sect            ; read directory
2307   0E50 FD 10         cla
2308   0E52 42 77 17      mov [index], a                ; reset file counter
2309   0E55             fs_mv_L1:
2310   0E55 FD 4E         mov si, d
2311   0E57 FD 4F BC 1E   mov di, user_data
2312   0E5B 07 88 10      call _strcmp
2313   0E5E C6 74 0E      je fs_mv_found_entry
2314   0E61 58 20 00      add d, 32
2315   0E64 14 77 17      mov a, [index]
2316   0E67 77            inc a
2317   0E68 42 77 17      mov [index], a
2318   0E6B AF 10 00      cmp a, FST_FILES_PER_DIR
2319   0E6E C6 A6 0E      je fs_mv_not_found
2320   0E71 0A 55 0E      jmp fs_mv_L1
2321   0E74             fs_mv_found_entry:  
2322   0E74 DA            push d
2323   0E75 FD 4D 3C 1F   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2324   0E79 FD 50         mov di, d
2325   0E7B 07 9D 10      call _strcpy  
2326   0E7E 38 00 00      mov c, 0
2327   0E81 3B BC 26      mov d, transient_area
2328   0E84 22 01         mov ah, $01                   ; disk write 1 sect
2329   0E86 07 C8 04      call ide_write_sect           ; write sector
2330   0E89 E7            pop d
2331   0E8A             ;; need to check whether its a dir or a file here ;;;
2332   0E8A 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2333   0E8D 22 01         mov ah, $01
2334   0E8F 3B BC 26      mov d, transient_area
2335   0E92 38 00 00      mov c, 0
2336   0E95 07 A2 04      call ide_read_sect            ; read directory entry
2337   0E98 FD 4D 3C 1F   mov si, user_data + 128
2338   0E9C FD 50         mov di, d
2339   0E9E 07 9D 10      call _strcpy                  ; change directory's name
2340   0EA1 22 01         mov ah, $01
2341   0EA3 07 C8 04      call ide_write_sect           ; rewrite directory back to disk
2342   0EA6             fs_mv_not_found:
2343   0EA6 06            sysret
2344   0EA7             
2345   0EA7             
2346   0EA7             ;----------------------------------------------------------------------------------------------------;
2347   0EA7             ; Process Index in A
2348   0EA7             ;----------------------------------------------------------------------------------------------------;
2349   0EA7             find_free_proc:
2350   0EA7 FD 4D 2D 1C   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2351   0EAB             find_free_proc_L0:
2352   0EAB F6            lodsb                               ; get process state
2353   0EAC B9 00         cmp al, 0
2354   0EAE C6 B4 0E      je find_free_proc_free              ; if free, jump
2355   0EB1 0A AB 0E      jmp find_free_proc_L0               ; else, goto next
2356   0EB4             find_free_proc_free:
2357   0EB4 4E            mov a, si
2358   0EB5 5F 2D 1C      sub a, 1 + proc_availab_table       ; get process index
2359   0EB8 09            ret
2360   0EB9               
2361   0EB9             
2362   0EB9             ;----------------------------------------------------------------------------------------------------;
2363   0EB9             ; Process Index in AL
2364   0EB9             ;----------------------------------------------------------------------------------------------------;
2365   0EB9             proc_memory_map:
2366   0EB9 22 00         mov ah, 0
2367   0EBB 27            mov b, a                      ; page in BL, 0 in BH
2368   0EBC FD 9D 05      shl a, 5                      ; multiply by 32
2369   0EBF 39            mov c, a                      ; save in C
2370   0EC0 57 20 00      add c, 32
2371   0EC3             proc_memory_map_L0:
2372   0EC3 02            pagemap
2373   0EC4 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2374   0EC7 53 01 00      add a, 1                      ; increase both 
2375   0ECA B1            cmp a, c                      ; check to see if we reached the end of memory
2376   0ECB C7 C3 0E      jne proc_memory_map_L0
2377   0ECE 09            ret
2378   0ECF               
2379   0ECF             
2380   0ECF             syscall_terminate_proc:
2381   0ECF 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2382   0ED2                                                    ; since they will not be used for anything here.
2383   0ED2 1D 76 17      mov al, [active_proc_index]
2384   0ED5 22 00         mov ah, 0  
2385   0ED7 FD 9D 05      shl a, 5                             ; x32
2386   0EDA 53 3C 1C      add a, proc_names
2387   0EDD 3C            mov d, a
2388   0EDE 19 00         mov al, 0
2389   0EE0 3E            mov [d], al                           ; nullify process name
2390   0EE1             
2391   0EE1 1D 76 17      mov al, [active_proc_index]
2392   0EE4 22 00         mov ah, 0  
2393   0EE6 3C            mov d, a
2394   0EE7 19 00         mov al, 0
2395   0EE9 3F 2C 1C      mov [d + proc_availab_table], al    ; make process empty again
2396   0EEC               
2397   0EEC 1D 75 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2398   0EEF 80            dec al
2399   0EF0 3D 75 17      mov [nbr_active_procs], al
2400   0EF3             
2401   0EF3             ; now load the shell process again
2402   0EF3 19 02         mov al, 2                           ; next process = process 2 = shell
2403   0EF5 3D 76 17      mov [active_proc_index], al         ; set next active proc
2404   0EF8             
2405   0EF8             ; calculate LUT entry for next process
2406   0EF8 22 00         mov ah, 0
2407   0EFA FD 99         shl a                               ; x2
2408   0EFC B7 C5 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2409   0EFF               
2410   0EFF 4D            mov si, a                           ; source is proc state block
2411   0F00 48            mov a, sp
2412   0F01 5F 13 00      sub a, 19
2413   0F04 4F            mov di, a                           ; destination is kernel stack
2414   0F05             ; restore SP
2415   0F05 7D            dec a
2416   0F06 47            mov sp, a
2417   0F07 38 14 00      mov c, 20
2418   0F0A FD F5         rep movsb
2419   0F0C             ; set VM process
2420   0F0C 1D 76 17      mov al, [active_proc_index]
2421   0F0F 01            setptb
2422   0F10                 
2423   0F10 4C            popa
2424   0F11 06            sysret
2425   0F12             
2426   0F12             syscall_pause_proc:
2427   0F12             ; save all registers into kernel stack
2428   0F12 4B            pusha
2429   0F13 22 00         mov ah, 0
2430   0F15 1D 76 17      mov al, [active_proc_index]
2431   0F18 FD 99         shl a              ; x2
2432   0F1A B7 C5 0F      mov a, [proc_table_convert + a]   ; get process state start index
2433   0F1D                 
2434   0F1D 4F            mov di, a
2435   0F1E 48            mov a, sp
2436   0F1F 77            inc a
2437   0F20 4D            mov si, a
2438   0F21 38 14 00      mov c, 20
2439   0F24 FD F5         rep movsb                         ; save process state!
2440   0F26             ; restore kernel stack position to point before interrupt arrived
2441   0F26 51 14 00      add sp, 20
2442   0F29             ; now load the shell process again
2443   0F29 19 02         mov al, 2                         ; next process = process 2 = shell
2444   0F2B 3D 76 17      mov [active_proc_index], al       ; set next active proc
2445   0F2E             
2446   0F2E             ; calculate LUT entry for next process
2447   0F2E 22 00         mov ah, 0
2448   0F30 FD 99         shl a                             ; x2
2449   0F32 B7 C5 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2450   0F35               
2451   0F35 4D            mov si, a                         ; source is proc state block
2452   0F36 48            mov a, sp
2453   0F37 5F 13 00      sub a, 19
2454   0F3A 4F            mov di, a                         ; destination is kernel stack
2455   0F3B             ; restore SP
2456   0F3B 7D            dec a
2457   0F3C 47            mov sp, a
2458   0F3D 38 14 00      mov c, 20
2459   0F40 FD F5         rep movsb
2460   0F42             ; set VM process
2461   0F42 1D 76 17      mov al, [active_proc_index]
2462   0F45 01            setptb
2463   0F46                 
2464   0F46 4C            popa
2465   0F47 06            sysret
2466   0F48             
2467   0F48             ;----------------------------------------------------------------------------------------------------;
2468   0F48             ; create a new process
2469   0F48             ; D = path of the process file to be createed
2470   0F48             ; B = arguments ptr
2471   0F48             ;----------------------------------------------------------------------------------------------------;
2472   0F48             syscall_create_proc:
2473   0F48             ; we save the active process first  
2474   0F48 4B            pusha
2475   0F49 22 00         mov ah, 0
2476   0F4B 1D 76 17      mov al, [active_proc_index]
2477   0F4E FD 99         shl a              ; x2
2478   0F50 B7 C5 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2479   0F53               
2480   0F53 4F            mov di, a
2481   0F54 48            mov a, sp
2482   0F55 77            inc a
2483   0F56 4D            mov si, a
2484   0F57 38 14 00      mov c, 20
2485   0F5A FD F5         rep movsb                          ; save process state!
2486   0F5C             ; restore kernel stack position to point before interrupt arrived
2487   0F5C 51 14 00      add sp, 20
2488   0F5F               
2489   0F5F FD 4E         mov si, d                          ; copy the file path
2490   0F61 FD 4F BC 1E   mov di, user_data
2491   0F65 38 00 02      mov c, 512
2492   0F68 04            load
2493   0F69 11            mov a, b
2494   0F6A 4D            mov si, a                          ; copy the arguments
2495   0F6B FD 4F BC 24   mov di, scrap_sector
2496   0F6F 38 00 02      mov c, 512
2497   0F72 04            load
2498   0F73 07 5A 09      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2499   0F76                                                  ; the file data is loaded into transient_area
2500   0F76             ; now we allocate a new process  
2501   0F76 07 A7 0E      call find_free_proc                ; index in A
2502   0F79 01            setptb 
2503   0F7A 07 B9 0E      call proc_memory_map               ; map process memory pages
2504   0F7D             ; copy arguments into process's memory
2505   0F7D FD 4D BC 24   mov si, scrap_sector
2506   0F81 FD 4F 00 00   mov di, 0
2507   0F85 38 00 02      mov c, 512
2508   0F88 03            store
2509   0F89             ; now copy process binary data into process's memory
2510   0F89 FD 4D BC 26   mov si, transient_area
2511   0F8D FD 4F 00 04   mov di, text_org              ; code origin address for all user processes
2512   0F91 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2513   0F94 03            store                              ; copy process data
2514   0F95                 
2515   0F95 07 A7 0E      call find_free_proc                ; index in A
2516   0F98 3D 76 17      mov [active_proc_index], al        ; set new active process
2517   0F9B FD 9D 05      shl a, 5                           ; x32
2518   0F9E 53 3C 1C      add a, proc_names
2519   0FA1 4F            mov di, a
2520   0FA2 FD 4D BC 1E   mov si, user_data                  ; copy and store process filename
2521   0FA6 07 9D 10      call _strcpy
2522   0FA9               
2523   0FA9 07 A7 0E      call find_free_proc                ; index in A
2524   0FAC 3C            mov d, a
2525   0FAD 19 01         mov al, 1
2526   0FAF 3F 2C 1C      mov [d + proc_availab_table], al   ; make process busy
2527   0FB2               
2528   0FB2 1D 75 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2529   0FB5 7A            inc al
2530   0FB6 3D 75 17      mov [nbr_active_procs], al
2531   0FB9             ; launch process
2532   0FB9 FD D7 FF FF   push word $FFFF 
2533   0FBD FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2534   0FC0 FD D7 00 04   push word text_org
2535   0FC4 06            sysret
2536   0FC5             
2537   0FC5             proc_table_convert:
2538   0FC5 EC 1A         .dw proc_state_table + 0
2539   0FC7 00 1B         .dw proc_state_table + 20
2540   0FC9 14 1B         .dw proc_state_table + 40
2541   0FCB 28 1B         .dw proc_state_table + 60
2542   0FCD 3C 1B         .dw proc_state_table + 80
2543   0FCF 50 1B         .dw proc_state_table + 100
2544   0FD1 64 1B         .dw proc_state_table + 120
2545   0FD3 78 1B         .dw proc_state_table + 140
2546   0FD5               
2547   0FD5             ;----------------------------------------------------------------------------------------------;
2548   0FD5             ; GET HEX FILE
2549   0FD5             ; di = destination address
2550   0FD5             ; return length in bytes in C
2551   0FD5             ;----------------------------------------------------------------------------------------------;
2552   0FD5             _load_hex:
2553   0FD5 D7            push a
2554   0FD6 D8            push b
2555   0FD7 DA            push d
2556   0FD8 E2            push si
2557   0FD9 E3            push di
2558   0FDA 38 00 00      mov c, 0
2559   0FDD 50            mov a, di
2560   0FDE 3C            mov d, a          ; start of string data block
2561   0FDF 07 20 11      call _gets        ; get program string
2562   0FE2               ;call _puts        ; reprint to screen
2563   0FE2 4D            mov si, a
2564   0FE3             __load_hex_loop:
2565   0FE3 F6            lodsb             ; load from [SI] to AL
2566   0FE4 B9 00         cmp al, 0         ; check if ASCII 0
2567   0FE6 C6 F4 0F      jz __load_hex_ret
2568   0FE9 36            mov bh, al
2569   0FEA F6            lodsb
2570   0FEB 2F            mov bl, al
2571   0FEC 07 D6 10      call _atoi        ; convert ASCII byte in B to int (to AL)
2572   0FEF F7            stosb             ; store AL to [DI]
2573   0FF0 78            inc c
2574   0FF1 0A E3 0F      jmp __load_hex_loop
2575   0FF4             __load_hex_ret:
2576   0FF4 F0            pop di
2577   0FF5 EF            pop si
2578   0FF6 E7            pop d
2579   0FF7 E5            pop b
2580   0FF8 E4            pop a
2581   0FF9 09            ret
2582   0FFA             
2583   0FFA             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2584   0FFA             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2585   0FFA             ; for each entry insIDE DIRECTORY:
2586   0FFA             ;  if entry is a file:
2587   0FFA             ;    compare filename to searched filename
2588   0FFA             ;    if filenames are the same, print filename
2589   0FFA             ;  else if entry is a directory:
2590   0FFA             ;    cd to the given directory
2591   0FFA             ;    recursively call cmd_find
2592   0FFA             ;    cd outsIDE previous directory
2593   0FFA             ;  if current entry == last entry, return
2594   0FFA             ; endfor
2595   0FFA             f_find:
2596   0FFA 09            ret
2597   0FFB             
2598   0FFB             
2599   0FFB             ; ---------------------------------------------------------------------
2600   0FFB             ; KERNEL RESET VECTOR
2601   0FFB             ; ---------------------------------------------------------------------
2602   0FFB             kernel_reset_vector:  
2603   0FFB FD 49 FF F7   mov bp, STACK_BEGIN
2604   0FFF FD 47 FF F7   mov sp, STACK_BEGIN
2605   1003               
2606   1003 19 81         mov al, %10000001
2607   1005 FD 0F         stomsk                        ; mask out timer interrupt for now (only allow UART to interrupt)
2608   1007 FD 0C         sti  
2609   1009             
2610   1009 0C            lodstat
2611   100A 87 DF         and al, %11011111             ; disable display register loading
2612   100C 0D            stostat
2613   100D               
2614   100D             ; reset fifo pointers
2615   100D 10 BC 20      mov a, fifo
2616   1010 3B 7B 17      mov d, fifo_in
2617   1013 43            mov [d], a
2618   1014 3B 7D 17      mov d, fifo_out
2619   1017 43            mov [d], a  
2620   1018 19 02         mov al, 2
2621   101A 05 03         syscall sys_io                ; enable uart in interrupt mode
2622   101C               
2623   101C 3B C1 17      mov d, s_kernel_started
2624   101F 07 45 12      call _puts
2625   1022             
2626   1022 19 10         mov al, 16
2627   1024 05 04         syscall sys_filesystem        ; set root dirID
2628   1026             
2629   1026 3B DE 17      mov d, s_prompt_init
2630   1029 07 45 12      call _puts
2631   102C 3B 81 17      mov d, s_init_path
2632   102F 05 05         syscall sys_create_proc              ; launch init as a new process
2633   1031             
2634   1031             
2635   1031             ; FILE INCLUDES
2636   1031             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  1031             BIOS_RESET_VECTOR .EQU  $01c0
0002+  1031             IDE_buffer       .EQU  $8204
0003+  1031             boot_origin      .EQU  $8004
0004+  1031             bios_uart        .EQU  $0002
0005+  1031             bios_ide         .EQU  $0003
2637   1031             .include "lib/stdio.asm"
0001+  1031             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1031             ; stdio.s
0003+  1031             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1031             .include "lib/string.asm"
0001++ 1031             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1031             ; string.s
0003++ 1031             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1031             
0005++ 1031             
0006++ 1031             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1031             ; _strrev
0008++ 1031             ; reverse a string
0009++ 1031             ; D = string address
0010++ 1031             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1031             ; 01234
0012++ 1031             _strrev:
0013++ 1031 4B          	pusha
0014++ 1032 07 78 10    	call _strlen	; length in C
0015++ 1035 12          	mov a, c
0016++ 1036 AF 01 00    	cmp a, 1
0017++ 1039 D0 53 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 103C 7D          	dec a
0019++ 103D FD 4E       	mov si, d	; beginning of string
0020++ 103F FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1041 59          	add d, a	; end of string
0022++ 1042 12          	mov a, c
0023++ 1043 FD 9B       	shr a		; divide by 2
0024++ 1045 39          	mov c, a	; C now counts the steps
0025++ 1046             _strrev_L0:
0026++ 1046 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1047 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1048 3E          	mov [d], al	; store left char into right side
0029++ 1049 1B          	mov al, bl
0030++ 104A F7          	stosb		; store right-side char into left-side; increase DI
0031++ 104B 7E          	dec c
0032++ 104C 7F          	dec d
0033++ 104D C2 00 00    	cmp c, 0
0034++ 1050 C7 46 10    	jne _strrev_L0
0035++ 1053             _strrev_end:
0036++ 1053 4C          	popa
0037++ 1054 09          	ret
0038++ 1055             	
0039++ 1055             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1055             ; _strchr
0041++ 1055             ; search string in D for char in AL
0042++ 1055             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1055             _strchr:
0044++ 1055             _strchr_L0:
0045++ 1055 32          	mov bl, [d]
0046++ 1056 C1 00       	cmp bl, 0
0047++ 1058 C6 63 10    	je _strchr_end
0048++ 105B BA          	cmp al, bl
0049++ 105C C6 63 10    	je _strchr_end
0050++ 105F 79          	inc d
0051++ 1060 0A 55 10    	jmp _strchr_L0
0052++ 1063             _strchr_end:
0053++ 1063 1B          	mov al, bl
0054++ 1064 09          	ret
0055++ 1065             
0056++ 1065             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1065             ; _strstr
0058++ 1065             ; find sub-string
0059++ 1065             ; str1 in SI
0060++ 1065             ; str2 in DI
0061++ 1065             ; SI points to end of source string
0062++ 1065             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1065             _strstr:
0064++ 1065 DB          	push al
0065++ 1066 DA          	push d
0066++ 1067 E3          	push di
0067++ 1068             _strstr_loop:
0068++ 1068 F3          	cmpsb					; compare a byte of the strings
0069++ 1069 C7 74 10    	jne _strstr_ret
0070++ 106C FC 00 00    	lea d, [di + 0]
0071++ 106F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1071 C7 68 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1074             _strstr_ret:
0074++ 1074 F0          	pop di
0075++ 1075 E7          	pop d
0076++ 1076 E8          	pop al
0077++ 1077 09          	ret
0078++ 1078             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1078             ; length of null terminated string
0080++ 1078             ; result in C
0081++ 1078             ; pointer in D
0082++ 1078             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1078             _strlen:
0084++ 1078 DA          	push d
0085++ 1079 38 00 00    	mov c, 0
0086++ 107C             _strlen_L1:
0087++ 107C BD 00       	cmp byte [d], 0
0088++ 107E C6 86 10    	je _strlen_ret
0089++ 1081 79          	inc d
0090++ 1082 78          	inc c
0091++ 1083 0A 7C 10    	jmp _strlen_L1
0092++ 1086             _strlen_ret:
0093++ 1086 E7          	pop d
0094++ 1087 09          	ret
0095++ 1088             
0096++ 1088             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1088             ; STRCMP
0098++ 1088             ; compare two strings
0099++ 1088             ; str1 in SI
0100++ 1088             ; str2 in DI
0101++ 1088             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1088             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1088             _strcmp:
0104++ 1088 DB          	push al
0105++ 1089 DA          	push d
0106++ 108A E3          	push di
0107++ 108B E2          	push si
0108++ 108C             _strcmp_loop:
0109++ 108C F3          	cmpsb					; compare a byte of the strings
0110++ 108D C7 98 10    	jne _strcmp_ret
0111++ 1090 FB FF FF    	lea d, [si +- 1]
0112++ 1093 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1095 C7 8C 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1098             _strcmp_ret:
0115++ 1098 EF          	pop si
0116++ 1099 F0          	pop di
0117++ 109A E7          	pop d
0118++ 109B E8          	pop al
0119++ 109C 09          	ret
0120++ 109D             
0121++ 109D             
0122++ 109D             ; STRCPY
0123++ 109D             ; copy null terminated string from SI to DI
0124++ 109D             ; source in SI
0125++ 109D             ; destination in DI
0126++ 109D             _strcpy:
0127++ 109D E2          	push si
0128++ 109E E3          	push di
0129++ 109F DB          	push al
0130++ 10A0             _strcpy_L1:
0131++ 10A0 F6          	lodsb
0132++ 10A1 F7          	stosb
0133++ 10A2 B9 00       	cmp al, 0
0134++ 10A4 C7 A0 10    	jne _strcpy_L1
0135++ 10A7             _strcpy_end:
0136++ 10A7 E8          	pop al
0137++ 10A8 F0          	pop di
0138++ 10A9 EF          	pop si
0139++ 10AA 09          	ret
0140++ 10AB             
0141++ 10AB             ; STRCAT
0142++ 10AB             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 10AB             ; source in SI
0144++ 10AB             ; destination in DI
0145++ 10AB             _strcat:
0146++ 10AB E2          	push si
0147++ 10AC E3          	push di
0148++ 10AD D7          	push a
0149++ 10AE DA          	push d
0150++ 10AF 50          	mov a, di
0151++ 10B0 3C          	mov d, a
0152++ 10B1             _strcat_goto_end_L1:
0153++ 10B1 BD 00       	cmp byte[d], 0
0154++ 10B3 C6 BA 10    	je _strcat_start
0155++ 10B6 79          	inc d
0156++ 10B7 0A B1 10    	jmp _strcat_goto_end_L1
0157++ 10BA             _strcat_start:
0158++ 10BA FD 50       	mov di, d
0159++ 10BC             _strcat_L1:
0160++ 10BC F6          	lodsb
0161++ 10BD F7          	stosb
0162++ 10BE B9 00       	cmp al, 0
0163++ 10C0 C7 BC 10    	jne _strcat_L1
0164++ 10C3             _strcat_end:
0165++ 10C3 E7          	pop d
0166++ 10C4 E4          	pop a
0167++ 10C5 F0          	pop di
0168++ 10C6 EF          	pop si
0169++ 10C7 09          	ret
0170++ 10C8             
0171++ 10C8             
0005+  10C8             
0006+  10C8             
0007+  10C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  10C8             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  10C8             ; ASCII in BL
0010+  10C8             ; result in AL
0011+  10C8             ; ascii for F = 0100 0110
0012+  10C8             ; ascii for 9 = 0011 1001
0013+  10C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  10C8             hex_ascii_encode:
0015+  10C8 1B            mov al, bl
0016+  10C9 93 40         test al, $40        ; test if letter or number
0017+  10CB C7 D1 10      jnz hex_letter
0018+  10CE 87 0F         and al, $0F        ; get number
0019+  10D0 09            ret
0020+  10D1             hex_letter:
0021+  10D1 87 0F         and al, $0F        ; get letter
0022+  10D3 6A 09         add al, 9
0023+  10D5 09            ret
0024+  10D6             
0025+  10D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  10D6             ; ATOI
0027+  10D6             ; 2 letter hex string in B
0028+  10D6             ; 8bit integer returned in AL
0029+  10D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  10D6             _atoi:
0031+  10D6 D8            push b
0032+  10D7 07 C8 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  10DA 30            mov bl, bh
0034+  10DB DB            push al          ; save a
0035+  10DC 07 C8 10      call hex_ascii_encode
0036+  10DF EA            pop bl  
0037+  10E0 FD 9E 04      shl al, 4
0038+  10E3 8C            or al, bl
0039+  10E4 E5            pop b
0040+  10E5 09            ret  
0041+  10E6             
0042+  10E6             
0043+  10E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  10E6             ; scanf
0045+  10E6             ; no need for explanations!
0046+  10E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  10E6             scanf:
0048+  10E6 09            ret
0049+  10E7             
0050+  10E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  10E7             ; ITOA
0052+  10E7             ; 8bit value in BL
0053+  10E7             ; 2 byte ASCII result in A
0054+  10E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  10E7             _itoa:
0056+  10E7 DA            push d
0057+  10E8 D8            push b
0058+  10E9 A7 00         mov bh, 0
0059+  10EB FD A4 04      shr bl, 4  
0060+  10EE 74            mov d, b
0061+  10EF 1F 81 13      mov al, [d + s_hex_digits]
0062+  10F2 23            mov ah, al
0063+  10F3               
0064+  10F3 E5            pop b
0065+  10F4 D8            push b
0066+  10F5 A7 00         mov bh, 0
0067+  10F7 FD 87 0F      and bl, $0F
0068+  10FA 74            mov d, b
0069+  10FB 1F 81 13      mov al, [d + s_hex_digits]
0070+  10FE E5            pop b
0071+  10FF E7            pop d
0072+  1100 09            ret
0073+  1101             
0074+  1101             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1101             ; HEX STRING TO BINARY
0076+  1101             ; di = destination address
0077+  1101             ; si = source
0078+  1101             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1101             _hex_to_int:
0080+  1101             _hex_to_int_L1:
0081+  1101 F6            lodsb          ; load from [SI] to AL
0082+  1102 B9 00         cmp al, 0        ; check if ASCII 0
0083+  1104 C6 11 11      jz _hex_to_int_ret
0084+  1107 36            mov bh, al
0085+  1108 F6            lodsb
0086+  1109 2F            mov bl, al
0087+  110A 07 D6 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  110D F7            stosb          ; store AL to [DI]
0089+  110E 0A 01 11      jmp _hex_to_int_L1
0090+  1111             _hex_to_int_ret:
0091+  1111 09            ret    
0092+  1112             
0093+  1112             
0094+  1112             
0095+  1112             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1112             ; GETCHAR
0097+  1112             ; char in ah
0098+  1112             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1112             getch:
0100+  1112 DB            push al
0101+  1113             getch_retry:
0102+  1113 19 01         mov al, 1
0103+  1115 05 03         syscall sys_io      ; receive in AH
0104+  1117 E8            pop al
0105+  1118 09            ret
0106+  1119             
0107+  1119             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  1119             ; PUTCHAR
0109+  1119             ; char in ah
0110+  1119             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  1119             _putchar:
0112+  1119 DB            push al
0113+  111A 19 00         mov al, 0
0114+  111C 05 03         syscall sys_io      ; char in AH
0115+  111E E8            pop al
0116+  111F 09            ret
0117+  1120             
0118+  1120             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1120             ;; INPUT A STRING
0120+  1120             ;; terminates with null
0121+  1120             ;; pointer in D
0122+  1120             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1120             _gets:
0124+  1120 D7            push a
0125+  1121 DA            push d
0126+  1122             _gets_loop:
0127+  1122 19 01         mov al, 1
0128+  1124 05 03         syscall sys_io      ; receive in AH
0129+  1126 76 1B         cmp ah, 27
0130+  1128 C6 49 11      je _gets_ansi_esc
0131+  112B 76 0A         cmp ah, $0A        ; LF
0132+  112D C6 A5 11      je _gets_end
0133+  1130 76 0D         cmp ah, $0D        ; CR
0134+  1132 C6 A5 11      je _gets_end
0135+  1135 76 5C         cmp ah, $5C        ; '\\'
0136+  1137 C6 6B 11      je _gets_escape
0137+  113A 76 08         cmp ah, $08      ; check for backspace
0138+  113C C6 45 11      je _gets_backspace
0139+  113F 1A            mov al, ah
0140+  1140 3E            mov [d], al
0141+  1141 79            inc d
0142+  1142 0A 22 11      jmp _gets_loop
0143+  1145             _gets_backspace:
0144+  1145 7F            dec d
0145+  1146 0A 22 11      jmp _gets_loop
0146+  1149             _gets_ansi_esc:
0147+  1149 19 01         mov al, 1
0148+  114B 05 03         syscall sys_io        ; receive in AH without echo
0149+  114D 76 5B         cmp ah, '['
0150+  114F C7 22 11      jne _gets_loop
0151+  1152 19 01         mov al, 1
0152+  1154 05 03         syscall sys_io          ; receive in AH without echo
0153+  1156 76 44         cmp ah, 'D'
0154+  1158 C6 63 11      je _gets_left_arrow
0155+  115B 76 43         cmp ah, 'C'
0156+  115D C6 67 11      je _gets_right_arrow
0157+  1160 0A 22 11      jmp _gets_loop
0158+  1163             _gets_left_arrow:
0159+  1163 7F            dec d
0160+  1164 0A 22 11      jmp _gets_loop
0161+  1167             _gets_right_arrow:
0162+  1167 79            inc d
0163+  1168 0A 22 11      jmp _gets_loop
0164+  116B             _gets_escape:
0165+  116B 19 01         mov al, 1
0166+  116D 05 03         syscall sys_io      ; receive in AH
0167+  116F 76 6E         cmp ah, 'n'
0168+  1171 C6 90 11      je _gets_LF
0169+  1174 76 72         cmp ah, 'r'
0170+  1176 C6 97 11      je _gets_CR
0171+  1179 76 30         cmp ah, '0'
0172+  117B C6 9E 11      je _gets_NULL
0173+  117E 76 5C         cmp ah, $5C  ; '\'
0174+  1180 C6 89 11      je _gets_slash
0175+  1183 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  1184 3E            mov [d], al
0177+  1185 79            inc d
0178+  1186 0A 22 11      jmp _gets_loop
0179+  1189             _gets_slash:
0180+  1189 19 5C         mov al, $5C
0181+  118B 3E            mov [d], al
0182+  118C 79            inc d
0183+  118D 0A 22 11      jmp _gets_loop
0184+  1190             _gets_LF:
0185+  1190 19 0A         mov al, $0A
0186+  1192 3E            mov [d], al
0187+  1193 79            inc d
0188+  1194 0A 22 11      jmp _gets_loop
0189+  1197             _gets_CR:
0190+  1197 19 0D         mov al, $0D
0191+  1199 3E            mov [d], al
0192+  119A 79            inc d
0193+  119B 0A 22 11      jmp _gets_loop
0194+  119E             _gets_NULL:
0195+  119E 19 00         mov al, $00
0196+  11A0 3E            mov [d], al
0197+  11A1 79            inc d
0198+  11A2 0A 22 11      jmp _gets_loop
0199+  11A5             _gets_end:
0200+  11A5 19 00         mov al, 0
0201+  11A7 3E            mov [d], al        ; terminate string
0202+  11A8 E7            pop d
0203+  11A9 E4            pop a
0204+  11AA 09            ret
0205+  11AB             
0206+  11AB             
0207+  11AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  11AB             ;; INPUT TEXT
0209+  11AB             ;; terminated with CTRL+D
0210+  11AB             ;; pointer in D
0211+  11AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  11AB             _gettxt:
0213+  11AB D7            push a
0214+  11AC DA            push d
0215+  11AD             _gettxt_loop:
0216+  11AD 19 01         mov al, 1
0217+  11AF 05 03         syscall sys_io      ; receive in AH
0218+  11B1 76 04         cmp ah, 4      ; EOT
0219+  11B3 C6 EC 11      je _gettxt_end
0220+  11B6 76 08         cmp ah, $08      ; check for backspace
0221+  11B8 C6 E8 11      je _gettxt_backspace
0222+  11BB 76 5C         cmp ah, $5C        ; '\'
0223+  11BD C6 C6 11      je _gettxt_escape
0224+  11C0 1A            mov al, ah
0225+  11C1 3E            mov [d], al
0226+  11C2 79            inc d
0227+  11C3 0A AD 11      jmp _gettxt_loop
0228+  11C6             _gettxt_escape:
0229+  11C6 19 01         mov al, 1
0230+  11C8 05 03         syscall sys_io      ; receive in AH
0231+  11CA 76 6E         cmp ah, 'n'
0232+  11CC C6 DA 11      je _gettxt_LF
0233+  11CF 76 72         cmp ah, 'r'
0234+  11D1 C6 E1 11      je _gettxt_CR
0235+  11D4 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  11D5 3E            mov [d], al
0237+  11D6 79            inc d
0238+  11D7 0A AD 11      jmp _gettxt_loop
0239+  11DA             _gettxt_LF:
0240+  11DA 19 0A         mov al, $0A
0241+  11DC 3E            mov [d], al
0242+  11DD 79            inc d
0243+  11DE 0A AD 11      jmp _gettxt_loop
0244+  11E1             _gettxt_CR:
0245+  11E1 19 0D         mov al, $0D
0246+  11E3 3E            mov [d], al
0247+  11E4 79            inc d
0248+  11E5 0A AD 11      jmp _gettxt_loop
0249+  11E8             _gettxt_backspace:
0250+  11E8 7F            dec d
0251+  11E9 0A AD 11      jmp _gettxt_loop
0252+  11EC             _gettxt_end:
0253+  11EC 19 00         mov al, 0
0254+  11EE 3E            mov [d], al        ; terminate string
0255+  11EF E7            pop d
0256+  11F0 E4            pop a
0257+  11F1 09            ret
0258+  11F2             
0259+  11F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  11F2             ; PRINT NEW LINE
0261+  11F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  11F2             printnl:
0263+  11F2 D7            push a
0264+  11F3 10 00 0A      mov a, $0A00
0265+  11F6 05 03         syscall sys_io
0266+  11F8 10 00 0D      mov a, $0D00
0267+  11FB 05 03         syscall sys_io
0268+  11FD E4            pop a
0269+  11FE 09            ret
0270+  11FF             
0271+  11FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  11FF             ; _strtoint
0273+  11FF             ; 4 digit hex string number in d
0274+  11FF             ; integer returned in A
0275+  11FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  11FF             _strtointx:
0277+  11FF D8            push b
0278+  1200 32            mov bl, [d]
0279+  1201 37            mov bh, bl
0280+  1202 33 01 00      mov bl, [d + 1]
0281+  1205 07 D6 10      call _atoi        ; convert to int in AL
0282+  1208 23            mov ah, al        ; move to AH
0283+  1209 33 02 00      mov bl, [d + 2]
0284+  120C 37            mov bh, bl
0285+  120D 33 03 00      mov bl, [d + 3]
0286+  1210 07 D6 10      call _atoi        ; convert to int in AL
0287+  1213 E5            pop b
0288+  1214 09            ret
0289+  1215             
0290+  1215             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1215             ; _strtoint
0292+  1215             ; 5 digit base10 string number in d
0293+  1215             ; integer returned in A
0294+  1215             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1215             _strtoint:
0296+  1215 E2            push si
0297+  1216 D8            push b
0298+  1217 D9            push c
0299+  1218 DA            push d
0300+  1219 07 78 10      call _strlen      ; get string length in C
0301+  121C 7E            dec c
0302+  121D FD 4E         mov si, d
0303+  121F 12            mov a, c
0304+  1220 FD 99         shl a
0305+  1222 3B 99 13      mov d, table_power
0306+  1225 59            add d, a
0307+  1226 38 00 00      mov c, 0
0308+  1229             _strtoint_L0:
0309+  1229 F6            lodsb      ; load ASCII to al
0310+  122A B9 00         cmp al, 0
0311+  122C C6 3F 12      je _strtoint_end
0312+  122F 6F 30         sub al, $30    ; make into integer
0313+  1231 22 00         mov ah, 0
0314+  1233 2A            mov b, [d]
0315+  1234 AC            mul a, b      ; result in B since it fits in 16bits
0316+  1235 11            mov a, b
0317+  1236 28            mov b, c
0318+  1237 54            add a, b
0319+  1238 39            mov c, a
0320+  1239 63 02 00      sub d, 2
0321+  123C 0A 29 12      jmp _strtoint_L0
0322+  123F             _strtoint_end:
0323+  123F 12            mov a, c
0324+  1240 E7            pop d
0325+  1241 E6            pop c
0326+  1242 E5            pop b
0327+  1243 EF            pop si
0328+  1244 09            ret
0329+  1245             
0330+  1245             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1245             ; PRINT NULL TERMINATED STRING
0332+  1245             ; pointer in D
0333+  1245             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1245             _puts:
0335+  1245 D7            push a
0336+  1246 DA            push d
0337+  1247             _puts_L1:
0338+  1247 1E            mov al, [d]
0339+  1248 B9 00         cmp al, 0
0340+  124A C6 56 12      jz _puts_END
0341+  124D 23            mov ah, al
0342+  124E 19 00         mov al, 0
0343+  1250 05 03         syscall sys_io
0344+  1252 79            inc d
0345+  1253 0A 47 12      jmp _puts_L1
0346+  1256             _puts_END:
0347+  1256 E7            pop d
0348+  1257 E4            pop a
0349+  1258 09            ret
0350+  1259             
0351+  1259             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  1259             ; PRINT N SIZE STRING
0353+  1259             ; pointer in D
0354+  1259             ; size in C
0355+  1259             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  1259             _putsn:
0357+  1259 DB            push al
0358+  125A DA            push d
0359+  125B D9            push c
0360+  125C             _putsn_L0:
0361+  125C 1E            mov al, [d]
0362+  125D 23            mov ah, al
0363+  125E 19 00         mov al, 0
0364+  1260 05 03         syscall sys_io
0365+  1262 79            inc d
0366+  1263 7E            dec c  
0367+  1264 C2 00 00      cmp c, 0
0368+  1267 C7 5C 12      jne _putsn_L0
0369+  126A             _putsn_end:
0370+  126A E6            pop c
0371+  126B E7            pop d
0372+  126C E8            pop al
0373+  126D 09            ret
0374+  126E             
0375+  126E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  126E             ; print 16bit decimal number
0377+  126E             ; input number in A
0378+  126E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  126E             print_u16d:
0380+  126E D7            push a
0381+  126F D8            push b
0382+  1270 FD D8         push g
0383+  1272 26 10 27      mov b, 10000
0384+  1275 AE            div a, b      ; get 10000's coeff.
0385+  1276 07 9A 12      call print_number
0386+  1279 11            mov a, b
0387+  127A 26 E8 03      mov b, 1000
0388+  127D AE            div a, b      ; get 1000's coeff.
0389+  127E 07 9A 12      call print_number
0390+  1281 11            mov a, b
0391+  1282 26 64 00      mov b, 100
0392+  1285 AE            div a, b
0393+  1286 07 9A 12      call print_number
0394+  1289 11            mov a, b
0395+  128A 26 0A 00      mov b, 10
0396+  128D AE            div a, b
0397+  128E 07 9A 12      call print_number
0398+  1291 1B            mov al, bl      ; 1's coeff in bl
0399+  1292 07 9A 12      call print_number
0400+  1295 FD F1         pop g
0401+  1297 E5            pop b
0402+  1298 E4            pop a
0403+  1299 09            ret
0404+  129A             
0405+  129A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  129A             ; print AL
0407+  129A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  129A             print_number:
0409+  129A 6A 30         add al, $30
0410+  129C 23            mov ah, al
0411+  129D 07 19 11      call _putchar
0412+  12A0 09            ret
0413+  12A1             
0414+  12A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  12A1             ; PRINT 16BIT HEX INTEGER
0416+  12A1             ; integer value in reg B
0417+  12A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  12A1             print_u16x:
0419+  12A1 D7            push a
0420+  12A2 D8            push b
0421+  12A3 DD            push bl
0422+  12A4 30            mov bl, bh
0423+  12A5 07 E7 10      call _itoa        ; convert bh to char in A
0424+  12A8 2F            mov bl, al        ; save al
0425+  12A9 19 00         mov al, 0
0426+  12AB 05 03         syscall sys_io        ; display AH
0427+  12AD 24            mov ah, bl        ; retrieve al
0428+  12AE 19 00         mov al, 0
0429+  12B0 05 03         syscall sys_io        ; display AL
0430+  12B2             
0431+  12B2 EA            pop bl
0432+  12B3 07 E7 10      call _itoa        ; convert bh to char in A
0433+  12B6 2F            mov bl, al        ; save al
0434+  12B7 19 00         mov al, 0
0435+  12B9 05 03         syscall sys_io        ; display AH
0436+  12BB 24            mov ah, bl        ; retrieve al
0437+  12BC 19 00         mov al, 0
0438+  12BE 05 03         syscall sys_io        ; display AL
0439+  12C0             
0440+  12C0 E5            pop b
0441+  12C1 E4            pop a
0442+  12C2 09            ret
0443+  12C3             
0444+  12C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  12C3             ; INPUT 16BIT HEX INTEGER
0446+  12C3             ; read 16bit integer into A
0447+  12C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  12C3             scan_u16x:
0449+  12C3 F8 10 00      enter 16
0450+  12C6 D8            push b
0451+  12C7 DA            push d
0452+  12C8             
0453+  12C8 FA F1 FF      lea d, [bp + -15]
0454+  12CB 07 20 11      call _gets        ; get number
0455+  12CE             
0456+  12CE 32            mov bl, [d]
0457+  12CF 37            mov bh, bl
0458+  12D0 33 01 00      mov bl, [d + 1]
0459+  12D3 07 D6 10      call _atoi        ; convert to int in AL
0460+  12D6 23            mov ah, al        ; move to AH
0461+  12D7             
0462+  12D7 33 02 00      mov bl, [d + 2]
0463+  12DA 37            mov bh, bl
0464+  12DB 33 03 00      mov bl, [d + 3]
0465+  12DE 07 D6 10      call _atoi        ; convert to int in AL
0466+  12E1             
0467+  12E1 E7            pop d
0468+  12E2 E5            pop b
0469+  12E3 F9            leave
0470+  12E4 09            ret
0471+  12E5             
0472+  12E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  12E5             ; PRINT 8bit HEX INTEGER
0474+  12E5             ; integer value in reg bl
0475+  12E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  12E5             print_u8x:
0477+  12E5 D7            push a
0478+  12E6 DD            push bl
0479+  12E7             
0480+  12E7 07 E7 10      call _itoa        ; convert bl to char in A
0481+  12EA 2F            mov bl, al        ; save al
0482+  12EB 19 00         mov al, 0
0483+  12ED 05 03         syscall sys_io        ; display AH
0484+  12EF 24            mov ah, bl        ; retrieve al
0485+  12F0 19 00         mov al, 0
0486+  12F2 05 03         syscall sys_io        ; display AL
0487+  12F4             
0488+  12F4 EA            pop bl
0489+  12F5 E4            pop a
0490+  12F6 09            ret
0491+  12F7             
0492+  12F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  12F7             ; print 8bit decimal unsigned number
0494+  12F7             ; input number in AL
0495+  12F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  12F7             print_u8d:
0497+  12F7 D7            push a
0498+  12F8 D8            push b
0499+  12F9 FD D8         push g
0500+  12FB 22 00         mov ah, 0
0501+  12FD 26 64 00      mov b, 100
0502+  1300 AE            div a, b
0503+  1301 D8            push b      ; save remainder
0504+  1302 B9 00         cmp al, 0
0505+  1304 C6 0E 13      je skip100
0506+  1307 6A 30         add al, $30
0507+  1309 23            mov ah, al
0508+  130A 19 00         mov al, 0
0509+  130C 05 03         syscall sys_io  ; print coeff
0510+  130E             skip100:
0511+  130E E4            pop a
0512+  130F 22 00         mov ah, 0
0513+  1311 26 0A 00      mov b, 10
0514+  1314 AE            div a, b
0515+  1315 D8            push b      ; save remainder
0516+  1316 B9 00         cmp al, 0
0517+  1318 C6 22 13      je skip10
0518+  131B 6A 30         add al, $30
0519+  131D 23            mov ah, al
0520+  131E 19 00         mov al, 0
0521+  1320 05 03         syscall sys_io  ; print coeff
0522+  1322             skip10:
0523+  1322 E4            pop a
0524+  1323 1B            mov al, bl
0525+  1324 6A 30         add al, $30
0526+  1326 23            mov ah, al
0527+  1327 19 00         mov al, 0
0528+  1329 05 03         syscall sys_io  ; print coeff
0529+  132B FD F1         pop g
0530+  132D E5            pop b
0531+  132E E4            pop a
0532+  132F 09            ret
0533+  1330             
0534+  1330             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  1330             ; INPUT 8BIT HEX INTEGER
0536+  1330             ; read 8bit integer into AL
0537+  1330             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  1330             scan_u8x:
0539+  1330 F8 04 00      enter 4
0540+  1333 D8            push b
0541+  1334 DA            push d
0542+  1335             
0543+  1335 FA FD FF      lea d, [bp + -3]
0544+  1338 07 20 11      call _gets        ; get number
0545+  133B             
0546+  133B 32            mov bl, [d]
0547+  133C 37            mov bh, bl
0548+  133D 33 01 00      mov bl, [d + 1]
0549+  1340 07 D6 10      call _atoi        ; convert to int in AL
0550+  1343             
0551+  1343 E7            pop d
0552+  1344 E5            pop b
0553+  1345 F9            leave
0554+  1346 09            ret
0555+  1347             
0556+  1347             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1347             ; input decimal number
0558+  1347             ; result in A
0559+  1347             ; 655'\0'
0560+  1347             ; low--------high
0561+  1347             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1347             scan_u16d:
0563+  1347 F8 08 00      enter 8
0564+  134A E2            push si
0565+  134B D8            push b
0566+  134C D9            push c
0567+  134D DA            push d
0568+  134E FA F9 FF      lea d, [bp +- 7]
0569+  1351 07 20 11      call _gets
0570+  1354 07 78 10      call _strlen      ; get string length in C
0571+  1357 7E            dec c
0572+  1358 FD 4E         mov si, d
0573+  135A 12            mov a, c
0574+  135B FD 99         shl a
0575+  135D 3B 99 13      mov d, table_power
0576+  1360 59            add d, a
0577+  1361 38 00 00      mov c, 0
0578+  1364             mul_loop:
0579+  1364 F6            lodsb      ; load ASCII to al
0580+  1365 B9 00         cmp al, 0
0581+  1367 C6 7A 13      je mul_exit
0582+  136A 6F 30         sub al, $30    ; make into integer
0583+  136C 22 00         mov ah, 0
0584+  136E 2A            mov b, [d]
0585+  136F AC            mul a, b      ; result in B since it fits in 16bits
0586+  1370 11            mov a, b
0587+  1371 28            mov b, c
0588+  1372 54            add a, b
0589+  1373 39            mov c, a
0590+  1374 63 02 00      sub d, 2
0591+  1377 0A 64 13      jmp mul_loop
0592+  137A             mul_exit:
0593+  137A 12            mov a, c
0594+  137B E7            pop d
0595+  137C E6            pop c
0596+  137D E5            pop b
0597+  137E EF            pop si
0598+  137F F9            leave
0599+  1380 09            ret
0600+  1381             
0601+  1381             
0602+  1381 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  1385 34 35 36 37 
0602+  1389 38 39 41 42 
0602+  138D 43 44 45 46 
0603+  1391 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  1395 1B 5B 48 00 
0604+  1399             
0605+  1399             table_power:
0606+  1399 01 00         .dw 1
0607+  139B 0A 00         .dw 10
0608+  139D 64 00         .dw 100
0609+  139F E8 03         .dw 1000
0610+  13A1 10 27         .dw 100002638   13A3             .include "lib/ctype.asm"
0001+  13A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  13A3             ; ctype.s
0003+  13A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  13A3             
0005+  13A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  13A3             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  13A3             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  13A3             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  13A3             ;; characters are supported.
0010+  13A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  13A3             ;; _isalnum 
0012+  13A3             ;; _isalpha 
0013+  13A3             ;; islower 
0014+  13A3             ;; isupper 
0015+  13A3             ;; _isdigit 
0016+  13A3             ;; isxdigit
0017+  13A3             ;; iscntrl 
0018+  13A3             ;; isgraph 
0019+  13A3             ;; _isspace 
0020+  13A3             ;; isblank 
0021+  13A3             ;; isprint 
0022+  13A3             ;; ispunct 
0023+  13A3             ;; tolower 
0024+  13A3             ;; toupper
0025+  13A3             
0026+  13A3             
0027+  13A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  13A3             ;; IS ALPHANUMERIC
0029+  13A3             ;; sets ZF according with result
0030+  13A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  13A3             _isalnum:
0032+  13A3 07 C0 13    	call _isalpha
0033+  13A6 C6 AC 13    	je _isalnum_exit
0034+  13A9 07 AD 13    	call _isdigit
0035+  13AC             _isalnum_exit:
0036+  13AC 09          	ret	
0037+  13AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  13AD             ;; IS DIGIT
0039+  13AD             ;; sets ZF according with result
0040+  13AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  13AD             _isdigit:
0042+  13AD DB          	push al
0043+  13AE B9 30       	cmp al, '0'
0044+  13B0 C8 BC 13    	jlu _isdigit_false
0045+  13B3 B9 39       	cmp al, '9'
0046+  13B5 D1 BC 13    	jgu _isdigit_false
0047+  13B8 87 00       	and al, 0	; set ZF
0048+  13BA E8          	pop al
0049+  13BB 09          	ret
0050+  13BC             _isdigit_false:
0051+  13BC 8B 01       	or al, 1	; clear ZF
0052+  13BE E8          	pop al
0053+  13BF 09          	ret	
0054+  13C0             	
0055+  13C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  13C0             ;; IS ALPHA
0057+  13C0             ;; sets ZF according with result
0058+  13C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  13C0             _isalpha:
0060+  13C0 DB          	push al
0061+  13C1 B9 5F       	cmp al, '_'
0062+  13C3 C6 E3 13    	je _isalpha_true
0063+  13C6 B9 2E       	cmp al, '.'
0064+  13C8 C6 E3 13    	je _isalpha_true
0065+  13CB B9 41       	cmp al, 'A'
0066+  13CD C8 DF 13    	jlu _isalpha_false
0067+  13D0 B9 7A       	cmp al, 'z'
0068+  13D2 D1 DF 13    	jgu _isalpha_false
0069+  13D5 B9 5A       	cmp al, 'Z'
0070+  13D7 D0 E3 13    	jleu _isalpha_true
0071+  13DA B9 61       	cmp al, 'a'
0072+  13DC C9 E3 13    	jgeu _isalpha_true
0073+  13DF             _isalpha_false:
0074+  13DF 8B 01       	or al, 1	; clear ZF
0075+  13E1 E8          	pop al
0076+  13E2 09          	ret
0077+  13E3             _isalpha_true:
0078+  13E3 87 00       	and al, 0	; set ZF
0079+  13E5 E8          	pop al
0080+  13E6 09          	ret
0081+  13E7             
0082+  13E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  13E7             ;; IS PATH-ALPHA
0084+  13E7             ;; sets ZF according with result
0085+  13E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  13E7             ispath:
0087+  13E7 DB          	push al
0088+  13E8 07 AD 13    	call _isdigit
0089+  13EB C6 15 14    	je ispath_true
0090+  13EE B9 5F       	cmp al, '_'
0091+  13F0 C6 15 14    	je ispath_true
0092+  13F3 B9 2F       	cmp al, '/'
0093+  13F5 C6 15 14    	je ispath_true
0094+  13F8 B9 2E       	cmp al, '.'
0095+  13FA C6 15 14    	je ispath_true
0096+  13FD B9 41       	cmp al, 'A'
0097+  13FF C8 11 14    	jlu ispath_false
0098+  1402 B9 7A       	cmp al, 'z'
0099+  1404 D1 11 14    	jgu ispath_false
0100+  1407 B9 5A       	cmp al, 'Z'
0101+  1409 D0 15 14    	jleu ispath_true
0102+  140C B9 61       	cmp al, 'a'
0103+  140E C9 15 14    	jgeu ispath_true
0104+  1411             ispath_false:
0105+  1411 8B 01       	or al, 1	; clear ZF
0106+  1413 E8          	pop al
0107+  1414 09          	ret
0108+  1415             ispath_true:
0109+  1415 87 00       	and al, 0	; set ZF
0110+  1417 E8          	pop al
0111+  1418 09          	ret
0112+  1419             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  1419             ;; IS SPACE
0114+  1419             ;; sets ZF according with result
0115+  1419             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  1419             _isspace:
0117+  1419 B9 20       	cmp al, $20		; ' '
0118+  141B C6 2F 14    	je _isspace_exit
0119+  141E B9 09       	cmp al, $09		; '\t'
0120+  1420 C6 2F 14    	je _isspace_exit
0121+  1423 B9 0A       	cmp al, $0A		; '\n'
0122+  1425 C6 2F 14    	je _isspace_exit
0123+  1428 B9 0D       	cmp al, $0D		; '\r'
0124+  142A C6 2F 14    	je _isspace_exit
0125+  142D B9 0B       	cmp al, $0B		; '\v'
0126+  142F             _isspace_exit:
0127+  142F 09          	ret	
0128+  1430             
0129+  1430             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1430             ; TO LOWER
0131+  1430             ; input in AL
0132+  1430             ; output in AL
0133+  1430             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  1430             _to_lower:
0135+  1430 B9 5A       	cmp al, 'Z'
0136+  1432 D1 37 14    	jgu _to_lower_ret
0137+  1435 6A 20       	add al, $20				; convert to lower case
0138+  1437             _to_lower_ret:
0139+  1437 09          	ret
0140+  1438             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1438             ; TO UPPER
0142+  1438             ; input in AL
0143+  1438             ; output in AL
0144+  1438             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1438             _to_upper:
0146+  1438 B9 61       	cmp al, 'a'
0147+  143A C8 3F 14    	jlu _to_upper_ret
0148+  143D 6F 20       	sub al, $20			; convert to upper case
0149+  143F             _to_upper_ret:
0150+  143F 09          	ret
0151+  1440             
2639   1440             .include "lib/token.asm"
0001+  1440             TOKTYP_IDENTIFIER  .equ 0
0002+  1440             TOKTYP_KEYWORD     .equ 1
0003+  1440             TOKTYP_DELIMITER   .equ 2
0004+  1440             TOKTYP_STRING      .equ 3
0005+  1440             TOKTYP_CHAR        .equ 4
0006+  1440             TOKTYP_NUMERIC     .equ 5
0007+  1440             TOKTYP_END         .equ 6
0008+  1440             
0009+  1440             TOK_NULL           .equ 0
0010+  1440             TOK_FSLASH         .equ 1
0011+  1440             TOK_TIMES          .equ 2
0012+  1440             TOK_PLUS           .equ 3
0013+  1440             TOK_MINUS          .equ 4
0014+  1440             TOK_DOT            .equ 5
0015+  1440             TOK_SEMI           .equ 6
0016+  1440             TOK_ANGLE          .equ 7
0017+  1440             TOK_TILDE          .equ 8
0018+  1440             TOK_EQUAL          .equ 9
0019+  1440             TOK_COLON          .equ 10
0020+  1440             TOK_COMMA          .equ 11
0021+  1440             
0022+  1440             TOK_END            .equ 20
0023+  1440             
0024+  1440             
0025+  1440             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1440             ;; read a full command argment from shell input buffer
0027+  1440             ;; argument is written into tokstr
0028+  1440             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1440             get_arg:
0030+  1440 D7            push a
0031+  1441 E2            push si
0032+  1442 E3            push di
0033+  1443 19 00         mov al, 0
0034+  1445 3D 6E 16      mov [tokstr], al      ; nullify tokstr string
0035+  1448 14 6A 16      mov a, [prog]
0036+  144B 4D            mov si, a
0037+  144C FD 4F 6E 16   mov di, tokstr
0038+  1450             get_arg_skip_spaces:
0039+  1450 F6            lodsb
0040+  1451 07 19 14      call _isspace
0041+  1454 C6 50 14      je get_arg_skip_spaces
0042+  1457             get_arg_L0:
0043+  1457 B9 3B         cmp al, $3B        ; check if is ';'
0044+  1459 C6 66 14      je get_arg_end
0045+  145C B9 00         cmp al, 0
0046+  145E C6 66 14      je get_arg_end      ; check if end of input
0047+  1461 F7            stosb
0048+  1462 F6            lodsb
0049+  1463 0A 57 14      jmp get_arg_L0
0050+  1466             get_arg_end:
0051+  1466 19 00         mov al, 0
0052+  1468 F7            stosb
0053+  1469 D5 01 00      sub si, 1
0054+  146C 4E            mov a, si
0055+  146D 42 6A 16      mov [prog], a    ; update pointer
0056+  1470 F0            pop di
0057+  1471 EF            pop si
0058+  1472 E4            pop a
0059+  1473 09            ret
0060+  1474             
0061+  1474             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  1474             ;; read a path formation from shell input buffer
0063+  1474             ;; path is written into tokstr
0064+  1474             ;; /usr/bin
0065+  1474             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  1474             get_path:
0067+  1474 D7            push a
0068+  1475 E2            push si
0069+  1476 E3            push di
0070+  1477 19 00         mov al, 0
0071+  1479 3D 6E 16      mov [tokstr], al      ; nullify tokstr string
0072+  147C 14 6A 16      mov a, [prog]
0073+  147F 4D            mov si, a
0074+  1480 FD 4F 6E 16   mov di, tokstr
0075+  1484             get_path_skip_spaces:
0076+  1484 F6            lodsb
0077+  1485 07 19 14      call _isspace
0078+  1488 C6 84 14      je get_path_skip_spaces
0079+  148B             get_path_is_pathchar:
0080+  148B F7            stosb
0081+  148C F6            lodsb
0082+  148D 07 A3 13      call _isalnum      ;check if is alphanumeric
0083+  1490 C6 8B 14      je get_path_is_pathchar
0084+  1493 B9 2F         cmp al, '/'        ; check if is '/'
0085+  1495 C6 8B 14      je get_path_is_pathchar
0086+  1498 19 00         mov al, 0
0087+  149A F7            stosb
0088+  149B D5 01 00      sub si, 1
0089+  149E 4E            mov a, si
0090+  149F 42 6A 16      mov [prog], a    ; update pointer
0091+  14A2             get_path_end:
0092+  14A2 F0            pop di
0093+  14A3 EF            pop si
0094+  14A4 E4            pop a
0095+  14A5 09            ret
0096+  14A6             
0097+  14A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  14A6             ;; read a line
0099+  14A6             ;; line is written into tokstr
0100+  14A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  14A6             get_line:
0102+  14A6 D7            push a
0103+  14A7 E2            push si
0104+  14A8 E3            push di
0105+  14A9 19 00         mov al, 0
0106+  14AB 3D 6E 16      mov [tokstr], al      ; nullify tokstr string
0107+  14AE 14 6A 16      mov a, [prog]
0108+  14B1 4D            mov si, a
0109+  14B2 FD 4F 6E 16   mov di, tokstr
0110+  14B6             get_line_L0:
0111+  14B6 F6            lodsb
0112+  14B7 B9 0A         cmp al, $0A    ; check for new line
0113+  14B9 C6 C0 14      je get_line_exit
0114+  14BC F7            stosb
0115+  14BD 0A B6 14      jmp get_line_L0
0116+  14C0             get_line_exit:
0117+  14C0 19 00         mov al, 0
0118+  14C2 F7            stosb
0119+  14C3 4E            mov a, si
0120+  14C4 42 6A 16      mov [prog], a    ; update pointer
0121+  14C7 F0            pop di
0122+  14C8 EF            pop si
0123+  14C9 E4            pop a
0124+  14CA 09            ret
0125+  14CB             
0126+  14CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  14CB             ;; token parser
0128+  14CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  14CB             get_token:
0130+  14CB D7            push a
0131+  14CC DA            push d
0132+  14CD E2            push si
0133+  14CE E3            push di
0134+  14CF 19 00         mov al, 0
0135+  14D1 3D 6E 16      mov [tokstr], al      ; nullify tokstr string
0136+  14D4 19 00         mov al, TOK_NULL
0137+  14D6 3D 6D 16      mov [tok], al        ; nullify token
0138+  14D9 14 6A 16      mov a, [prog]
0139+  14DC 4D            mov si, a
0140+  14DD FD 4F 6E 16   mov di, tokstr
0141+  14E1             get_tok_skip_spaces:
0142+  14E1 F6            lodsb
0143+  14E2 07 19 14      call _isspace
0144+  14E5 C6 E1 14      je get_tok_skip_spaces
0145+  14E8 B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  14EA C6 CF 15      je get_token_end
0147+  14ED B9 23         cmp al, '#'      ; comments!
0148+  14EF C6 FD 15      je get_tok_comment
0149+  14F2 07 A3 13      call _isalnum
0150+  14F5 C6 DC 15      jz is_alphanumeric
0151+  14F8             ; other token types
0152+  14F8             get_token_slash:
0153+  14F8 B9 2F         cmp al, '/'        ; check if '/'
0154+  14FA C7 12 15      jne get_token_minus
0155+  14FD F7            stosb          ; store '/' into token string
0156+  14FE 19 00         mov al, 0
0157+  1500 F7            stosb          ; terminate token string
0158+  1501 19 01         mov al, TOK_FSLASH
0159+  1503 3D 6D 16      mov [tok], al      
0160+  1506 19 02         mov al, TOKTYP_DELIMITER
0161+  1508 3D 6C 16      mov [toktyp], al
0162+  150B 4E            mov a, si
0163+  150C 42 6A 16      mov [prog], a    ; update pointer
0164+  150F 0A F8 15      jmp get_token_return
0165+  1512             get_token_minus:
0166+  1512 B9 2D         cmp al, '-'        ; check if '-'
0167+  1514 C7 2C 15      jne get_token_comma
0168+  1517 F7            stosb          ; store '-' into token string
0169+  1518 19 00         mov al, 0
0170+  151A F7            stosb          ; terminate token string
0171+  151B 19 04         mov al, TOK_MINUS
0172+  151D 3D 6D 16      mov [tok], al      
0173+  1520 19 02         mov al, TOKTYP_DELIMITER
0174+  1522 3D 6C 16      mov [toktyp], al
0175+  1525 4E            mov a, si
0176+  1526 42 6A 16      mov [prog], a    ; update pointer
0177+  1529 0A F8 15      jmp get_token_return
0178+  152C             get_token_comma:
0179+  152C B9 2C         cmp al, ','        ; check if ','
0180+  152E C7 46 15      jne get_token_semi
0181+  1531 F7            stosb          ; store ',' into token string
0182+  1532 19 00         mov al, 0
0183+  1534 F7            stosb          ; terminate token string
0184+  1535 19 0B         mov al, TOK_COMMA
0185+  1537 3D 6D 16      mov [tok], al      
0186+  153A 19 02         mov al, TOKTYP_DELIMITER
0187+  153C 3D 6C 16      mov [toktyp], al
0188+  153F 4E            mov a, si
0189+  1540 42 6A 16      mov [prog], a    ; update pointer
0190+  1543 0A F8 15      jmp get_token_return
0191+  1546             get_token_semi:
0192+  1546 B9 3B         cmp al, $3B        ; check if ';'
0193+  1548 C7 60 15      jne get_token_colon
0194+  154B F7            stosb          ; store ';' into token string
0195+  154C 19 00         mov al, 0
0196+  154E F7            stosb          ; terminate token string
0197+  154F 19 06         mov al, TOK_SEMI
0198+  1551 3D 6D 16      mov [tok], al      
0199+  1554 19 02         mov al, TOKTYP_DELIMITER
0200+  1556 3D 6C 16      mov [toktyp], al
0201+  1559 4E            mov a, si
0202+  155A 42 6A 16      mov [prog], a    ; update pointer
0203+  155D 0A F8 15      jmp get_token_return
0204+  1560             get_token_colon:
0205+  1560 B9 3A         cmp al, $3A        ; check if ':'
0206+  1562 C7 7A 15      jne get_token_angle
0207+  1565 F7            stosb          ; store ':' into token string
0208+  1566 19 00         mov al, 0
0209+  1568 F7            stosb          ; terminate token string
0210+  1569 19 0A         mov al, TOK_COLON
0211+  156B 3D 6D 16      mov [tok], al      
0212+  156E 19 02         mov al, TOKTYP_DELIMITER
0213+  1570 3D 6C 16      mov [toktyp], al
0214+  1573 4E            mov a, si
0215+  1574 42 6A 16      mov [prog], a    ; update pointer
0216+  1577 0A F8 15      jmp get_token_return
0217+  157A             get_token_angle:
0218+  157A B9 3E         cmp al, $3E        ; check if '>'
0219+  157C C7 94 15      jne get_token_tilde
0220+  157F F7            stosb          ; store '>' into token string
0221+  1580 19 00         mov al, 0
0222+  1582 F7            stosb          ; terminate token string
0223+  1583 19 07         mov al, TOK_ANGLE
0224+  1585 3D 6D 16      mov [tok], al      
0225+  1588 19 02         mov al, TOKTYP_DELIMITER
0226+  158A 3D 6C 16      mov [toktyp], al
0227+  158D 4E            mov a, si
0228+  158E 42 6A 16      mov [prog], a    ; update pointer
0229+  1591 0A F8 15      jmp get_token_return
0230+  1594             get_token_tilde:
0231+  1594 B9 7E         cmp al, '~'        ; check if '~'
0232+  1596 C7 AE 15      jne get_token_equal
0233+  1599 F7            stosb          ; store '~' into token string
0234+  159A 19 00         mov al, 0
0235+  159C F7            stosb          ; terminate token string
0236+  159D 19 08         mov al, TOK_TILDE
0237+  159F 3D 6D 16      mov [tok], al      
0238+  15A2 19 02         mov al, TOKTYP_DELIMITER
0239+  15A4 3D 6C 16      mov [toktyp], al
0240+  15A7 4E            mov a, si
0241+  15A8 42 6A 16      mov [prog], a    ; update pointer
0242+  15AB 0A F8 15      jmp get_token_return
0243+  15AE             get_token_equal:
0244+  15AE B9 3D         cmp al, '='        ; check if '='
0245+  15B0 C7 C8 15      jne get_token_skip
0246+  15B3 F7            stosb          ; store '=' into token string
0247+  15B4 19 00         mov al, 0
0248+  15B6 F7            stosb          ; terminate token string
0249+  15B7 19 09         mov al, TOK_EQUAL
0250+  15B9 3D 6D 16      mov [tok], al      
0251+  15BC 19 02         mov al, TOKTYP_DELIMITER
0252+  15BE 3D 6C 16      mov [toktyp], al
0253+  15C1 4E            mov a, si
0254+  15C2 42 6A 16      mov [prog], a    ; update pointer
0255+  15C5 0A F8 15      jmp get_token_return
0256+  15C8             get_token_skip:
0257+  15C8 4E            mov a, si
0258+  15C9 42 6A 16      mov [prog], a    ; update pointer
0259+  15CC 0A F8 15      jmp get_token_return
0260+  15CF             get_token_end:        ; end of file token
0261+  15CF 19 14         mov al, TOK_END
0262+  15D1 3D 6D 16      mov [tok], al
0263+  15D4 19 06         mov al, TOKTYP_END
0264+  15D6 3D 6C 16      mov [toktyp], al
0265+  15D9 0A F8 15      jmp get_token_return
0266+  15DC             is_alphanumeric:
0267+  15DC F7            stosb
0268+  15DD F6            lodsb
0269+  15DE 07 A3 13      call _isalnum      ;check if is alphanumeric
0270+  15E1 C6 DC 15      jz is_alphanumeric
0271+  15E4 B9 2E         cmp al, $2E        ; check if is '.'
0272+  15E6 C6 DC 15      je is_alphanumeric
0273+  15E9 19 00         mov al, 0
0274+  15EB F7            stosb
0275+  15EC 19 00         mov al, TOKTYP_IDENTIFIER
0276+  15EE 3D 6C 16      mov [toktyp], al
0277+  15F1 D5 01 00      sub si, 1
0278+  15F4 4E            mov a, si
0279+  15F5 42 6A 16      mov [prog], a    ; update pointer
0280+  15F8             get_token_return:
0281+  15F8 F0            pop di
0282+  15F9 EF            pop si
0283+  15FA E7            pop d
0284+  15FB E4            pop a
0285+  15FC 09            ret
0286+  15FD             get_tok_comment:
0287+  15FD F6            lodsb
0288+  15FE B9 0A         cmp al, $0A      ; new line
0289+  1600 C7 FD 15      jne get_tok_comment
0290+  1603 0A E1 14      jmp get_tok_skip_spaces
0291+  1606             
0292+  1606             
0293+  1606             get_number:
0294+  1606 D7            push a
0295+  1607 DA            push d
0296+  1608 E2            push si
0297+  1609 E3            push di
0298+  160A 19 00         mov al, 0
0299+  160C 3D 6E 16      mov [tokstr], al      ; nullify tokstr string
0300+  160F 19 00         mov al, TOK_NULL
0301+  1611 3D 6D 16      mov [tok], al        ; nullify token
0302+  1614 14 6A 16      mov a, [prog]
0303+  1617 4D            mov si, a
0304+  1618 FD 4F 6E 16   mov di, tokstr
0305+  161C             get_number_skip_spaces:
0306+  161C F6            lodsb
0307+  161D 07 19 14      call _isspace
0308+  1620 C6 1C 16      je get_number_skip_spaces
0309+  1623 B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  1625 C7 35 16      jne get_number_L0
0311+  1628 19 14         mov al, TOK_END
0312+  162A 3D 6D 16      mov [tok], al
0313+  162D 19 06         mov al, TOKTYP_END
0314+  162F 3D 6C 16      mov [toktyp], al
0315+  1632 0A 4C 16      jmp get_number_return
0316+  1635             get_number_L0:
0317+  1635 F7            stosb
0318+  1636 F6            lodsb
0319+  1637 07 AD 13      call _isdigit      ;check if is numeric
0320+  163A C6 35 16      jz get_number_L0
0321+  163D 19 00         mov al, 0
0322+  163F F7            stosb
0323+  1640 19 05         mov al, TOKTYP_NUMERIC
0324+  1642 3D 6C 16      mov [toktyp], al
0325+  1645 D5 01 00      sub si, 1
0326+  1648 4E            mov a, si
0327+  1649 42 6A 16      mov [prog], a    ; update pointer
0328+  164C             get_number_return:
0329+  164C F0            pop di
0330+  164D EF            pop si
0331+  164E E7            pop d
0332+  164F E4            pop a
0333+  1650 09            ret
0334+  1651             
0335+  1651             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1651             ;; PUT BACK TOKEN
0337+  1651             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  1651             _putback:
0339+  1651 D7            push a
0340+  1652 E2            push si
0341+  1653 FD 4D 6E 16   mov si, tokstr  
0342+  1657             _putback_loop:
0343+  1657 F6            lodsb
0344+  1658 B9 00         cmp al, 0
0345+  165A C6 67 16      je _putback_end
0346+  165D 14 6A 16      mov a, [prog]
0347+  1660 7D            dec a
0348+  1661 42 6A 16      mov [prog], a      ; update pointer
0349+  1664 0A 57 16      jmp _putback_loop
0350+  1667             _putback_end:
0351+  1667 EF            pop si
0352+  1668 E4            pop a
0353+  1669 09            ret
0354+  166A             
0355+  166A             
0356+  166A             
0357+  166A             
0358+  166A 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  166C             
0360+  166C 00          toktyp:    .db 0          ; token type symbol
0361+  166D 00          tok:       .db 0          ; current token symbol
0362+  166E 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  1672 00 00 00 00 
0362+  1676 00 00 00 00 
0362+  167A 00 00 00 00 
0362+  167E 00 00 00 00 
0362+  1682 00 00 00 00 
0362+  1686 00 00 00 00 
0362+  168A 00 00 00 00 
0362+  168E 00 00 00 00 
0362+  1692 00 00 00 00 
0362+  1696 00 00 00 00 
0362+  169A 00 00 00 00 
0362+  169E 00 00 00 00 
0362+  16A2 00 00 00 00 
0362+  16A6 00 00 00 00 
0362+  16AA 00 00 00 00 
0362+  16AE 00 00 00 00 
0362+  16B2 00 00 00 00 
0362+  16B6 00 00 00 00 
0362+  16BA 00 00 00 00 
0362+  16BE 00 00 00 00 
0362+  16C2 00 00 00 00 
0362+  16C6 00 00 00 00 
0362+  16CA 00 00 00 00 
0362+  16CE 00 00 00 00 
0362+  16D2 00 00 00 00 
0362+  16D6 00 00 00 00 
0362+  16DA 00 00 00 00 
0362+  16DE 00 00 00 00 
0362+  16E2 00 00 00 00 
0362+  16E6 00 00 00 00 
0362+  16EA 00 00 00 00 
0362+  16EE 00 00 00 00 
0362+  16F2 00 00 00 00 
0362+  16F6 00 00 00 00 
0362+  16FA 00 00 00 00 
0362+  16FE 00 00 00 00 
0362+  1702 00 00 00 00 
0362+  1706 00 00 00 00 
0362+  170A 00 00 00 00 
0362+  170E 00 00 00 00 
0362+  1712 00 00 00 00 
0362+  1716 00 00 00 00 
0362+  171A 00 00 00 00 
0362+  171E 00 00 00 00 
0362+  1722 00 00 00 00 
0362+  1726 00 00 00 00 
0362+  172A 00 00 00 00 
0362+  172E 00 00 00 00 
0362+  1732 00 00 00 00 
0362+  1736 00 00 00 00 
0362+  173A 00 00 00 00 
0362+  173E 00 00 00 00 
0362+  1742 00 00 00 00 
0362+  1746 00 00 00 00 
0362+  174A 00 00 00 00 
0362+  174E 00 00 00 00 
0362+  1752 00 00 00 00 
0362+  1756 00 00 00 00 
0362+  175A 00 00 00 00 
0362+  175E 00 00 00 00 
0362+  1762 00 00 00 00 
0362+  1766 00 00 00 00 
0362+  176A 00 00 00 00 
2640   176E             
2641   176E             ; kernel parameters
2642   176E 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2643   176F 01          sys_echo_on:        .db 1
2644   1770 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2645   1771 01          sys_uart0_inten:    .db 1
2646   1772 00          sys_uart0_fifoen:   .db 0
2647   1773 0C          sys_uart0_div0:     .db 12  ;
2648   1774 00          sys_uart0_div1:     .db 0   ; default baud = 9600
2649   1775             ; Baud  Divisor
2650   1775             ; 50    2304
2651   1775             ; 110   1047
2652   1775             ; 300    384
2653   1775             ; 600    192
2654   1775             ; 1200    96
2655   1775             ; 9600    12
2656   1775             ; 19200    6
2657   1775             ; 38400    3
2658   1775             
2659   1775 00          nbr_active_procs:   .db 0
2660   1776 01          active_proc_index:  .db 1
2661   1777             
2662   1777 00 00       index:              .dw 0
2663   1779 00 00       buffer_addr:        .dw 0
2664   177B             
2665   177B BC 20       fifo_in:            .dw fifo
2666   177D BC 20       fifo_out:           .dw fifo
2667   177F             
2668   177F             ; file system variables
2669   177F 00 00       current_dir_id:     .dw 0     ; keep dirID of current directory
2670   1781 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2670   1785 6E 2F 69 6E 
2670   1789 69 74 00 
2671   178C             
2672   178C 3E 20 00    s_dataentry:        .db "> ", 0
2673   178F 2E 2E 00    s_parent_dir:       .db "..", 0
2674   1792 2E 00       s_current_dir:      .db ".", 0
2675   1794 2F 00       s_fslash:           .db "/", 0
2676   1796 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2676   179A 78 
2677   179B 2D 64 63    file_type:          .db "-dc"
2678   179E 50 49 44 20 s_ps_header:        .db "PID COMMAND\n", 0
2678   17A2 43 4F 4D 4D 
2678   17A6 41 4E 44 0A 
2678   17AA 00 
2679   17AB 54 6F 74 61 s_ls_total:         .db "Total: ", 0
2679   17AF 6C 3A 20 00 
2680   17B3             
2681   17B3 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2681   17B7 20 65 6E 61 
2681   17BB 62 6C 65 64 
2681   17BF 0A 00 
2682   17C1 6B 65 72 6E s_kernel_started:   .db "kernel started(version 1.0)\n", 0
2682   17C5 65 6C 20 73 
2682   17C9 74 61 72 74 
2682   17CD 65 64 28 76 
2682   17D1 65 72 73 69 
2682   17D5 6F 6E 20 31 
2682   17D9 2E 30 29 0A 
2682   17DD 00 
2683   17DE 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2683   17E2 74 69 6E 67 
2683   17E6 20 69 6E 69 
2683   17EA 74 0A 00 
2684   17ED 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2684   17F1 65 70 74 69 
2684   17F5 6F 6E 3A 20 
2684   17F9 70 72 69 76 
2684   17FD 69 6C 65 67 
2684   1801 65 0A 00 
2685   1804 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2685   1808 65 70 74 69 
2685   180C 6F 6E 3A 20 
2685   1810 7A 65 72 6F 
2685   1814 20 64 69 76 
2685   1818 69 73 69 6F 
2685   181C 6E 0A 00 
2686   181F             
2687   181F 59 65 61 72 s_set_year:         .db "Year: ", 0
2687   1823 3A 20 00 
2688   1826 4D 6F 6E 74 s_set_month:        .db "Month: ", 0
2688   182A 68 3A 20 00 
2689   182E 44 61 79 3A s_set_day:          .db "Day: ", 0
2689   1832 20 00 
2690   1834 57 65 65 6B s_set_week:         .db "Weekday: ", 0
2690   1838 64 61 79 3A 
2690   183C 20 00 
2691   183E 48 6F 75 72 s_set_hours:        .db "Hours: ", 0
2691   1842 73 3A 20 00 
2692   1846 4D 69 6E 75 s_set_minutes:      .db "Minutes: ", 0
2692   184A 74 65 73 3A 
2692   184E 20 00 
2693   1850 53 65 63 6F s_set_seconds:      .db "Seconds: ", 0
2693   1854 6E 64 73 3A 
2693   1858 20 00 
2694   185A             s_months:      
2695   185A 20 20 20 00   .db "   ", 0
2696   185E 4A 61 6E 00   .db "Jan", 0
2697   1862 46 65 62 00   .db "Feb", 0
2698   1866 4D 61 72 00   .db "Mar", 0
2699   186A 41 70 72 00   .db "Apr", 0
2700   186E 4D 61 79 00   .db "May", 0
2701   1872 4A 75 6E 00   .db "Jun", 0
2702   1876 4A 75 6C 00   .db "Jul", 0
2703   187A 41 75 67 00   .db "Aug", 0
2704   187E 53 65 70 00   .db "Sep", 0
2705   1882 4F 63 74 00   .db "Oct", 0
2706   1886 4E 6F 76 00   .db "Nov", 0
2707   188A 44 65 63 00   .db "Dec", 0
2708   188E             
2709   188E             s_week:        
2710   188E 53 75 6E 00   .db "Sun", 0 
2711   1892 4D 6F 6E 00   .db "Mon", 0 
2712   1896 54 75 65 00   .db "Tue", 0 
2713   189A 57 65 64 00   .db "Wed", 0 
2714   189E 54 68 75 00   .db "Thu", 0 
2715   18A2 46 72 69 00   .db "Fri", 0 
2716   18A6 53 61 74 00   .db "Sat", 0
2717   18AA             
2718   18AA             ; This is the format of a sector for the 128 byte per sector format.
2719   18AA             ; Write the bracketed data 16 times per track.
2720   18AA             ; The recommended single-density format with 128
2721   18AA             ; bytes/sector is shown. In order to format a diskette,
2722   18AA             ; the user issues the Write Track Command, and loads
2723   18AA             ; the Data Register with the following values. For every
2724   18AA             ; byte to be written, there is one Data Request.
2725   18AA             fdc_128_bytes_per_sect:                                                                       
2726   18AA FF FF FF FF fdc_40_FF:     .fill 40,  $FF  ; or 00                                                                                
2726   18AE FF FF FF FF 
2726   18B2 FF FF FF FF 
2726   18B6 FF FF FF FF 
2726   18BA FF FF FF FF 
2726   18BE FF FF FF FF 
2726   18C2 FF FF FF FF 
2726   18C6 FF FF FF FF 
2726   18CA FF FF FF FF 
2726   18CE FF FF FF FF 
2727   18D2 00 00 00 00 fdc_6_00_0:    .fill 6,   $00  ;                                                                            <--|        
2727   18D6 00 00 
2728   18D8 FE          fdc_id_fe:     .fill 1,   $FE  ; ID Address Mark                                                               |        
2729   18D9 00          fdc_track:     .fill 1,   $00  ; Track Number                                                                  |                    
2730   18DA 00          fdc_side:      .fill 1,   $00  ; Side Number 00 or 01                                                          |                
2731   18DB 01          fdc_sector:    .fill 1,   $01  ; Sector Number  1 through 10                                                   |                              
2732   18DC 00          fdc_length:    .fill 1,   $00  ; Sector Length                                                                 |                        
2733   18DD F7          fdc_2_crc_0:   .fill 1,   $F7  ; 2 CRC's Written                                                               | Write 16 times                 
2734   18DE FF FF FF FF fdc_11_ff:     .fill 11,  $FF  ; or 00                                                                         |                      
2734   18E2 FF FF FF FF 
2734   18E6 FF FF FF 
2735   18E9 00 00 00 00 fdc_6_00_1:    .fill 6,   $00  ;                                                                               |                        
2735   18ED 00 00 
2736   18EF FB          fdc_data_addr: .fill 1,   $FB  ; Data Address Mark                                                             |                                  
2737   18F0 E5 E5 E5 E5 fdc_data:      .fill 128, $E5  ; Data (IBM uses E5)                                                            |                                      
2737   18F4 E5 E5 E5 E5 
2737   18F8 E5 E5 E5 E5 
2737   18FC E5 E5 E5 E5 
2737   1900 E5 E5 E5 E5 
2737   1904 E5 E5 E5 E5 
2737   1908 E5 E5 E5 E5 
2737   190C E5 E5 E5 E5 
2737   1910 E5 E5 E5 E5 
2737   1914 E5 E5 E5 E5 
2737   1918 E5 E5 E5 E5 
2737   191C E5 E5 E5 E5 
2737   1920 E5 E5 E5 E5 
2737   1924 E5 E5 E5 E5 
2737   1928 E5 E5 E5 E5 
2737   192C E5 E5 E5 E5 
2737   1930 E5 E5 E5 E5 
2737   1934 E5 E5 E5 E5 
2737   1938 E5 E5 E5 E5 
2737   193C E5 E5 E5 E5 
2737   1940 E5 E5 E5 E5 
2737   1944 E5 E5 E5 E5 
2737   1948 E5 E5 E5 E5 
2737   194C E5 E5 E5 E5 
2737   1950 E5 E5 E5 E5 
2737   1954 E5 E5 E5 E5 
2737   1958 E5 E5 E5 E5 
2737   195C E5 E5 E5 E5 
2737   1960 E5 E5 E5 E5 
2737   1964 E5 E5 E5 E5 
2737   1968 E5 E5 E5 E5 
2737   196C E5 E5 E5 E5 
2738   1970 F7          fdc_2_crc_1:   .fill 1,   $F7  ; 2 CRC's Written                                                               |                                                        
2739   1971 FF FF FF FF fdc_10_ff:     .fill 10,  $FF  ; or 00                                                                      <--|                                                  
2739   1975 FF FF FF FF 
2739   1979 FF FF 
2740   197B FF FF FF FF fdc_369_ff:    .fill 369, $FF  ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
2740   197F FF FF FF FF 
2740   1983 FF FF FF FF 
2740   1987 FF FF FF FF 
2740   198B FF FF FF FF 
2740   198F FF FF FF FF 
2740   1993 FF FF FF FF 
2740   1997 FF FF FF FF 
2740   199B FF FF FF FF 
2740   199F FF FF FF FF 
2740   19A3 FF FF FF FF 
2740   19A7 FF FF FF FF 
2740   19AB FF FF FF FF 
2740   19AF FF FF FF FF 
2740   19B3 FF FF FF FF 
2740   19B7 FF FF FF FF 
2740   19BB FF FF FF FF 
2740   19BF FF FF FF FF 
2740   19C3 FF FF FF FF 
2740   19C7 FF FF FF FF 
2740   19CB FF FF FF FF 
2740   19CF FF FF FF FF 
2740   19D3 FF FF FF FF 
2740   19D7 FF FF FF FF 
2740   19DB FF FF FF FF 
2740   19DF FF FF FF FF 
2740   19E3 FF FF FF FF 
2740   19E7 FF FF FF FF 
2740   19EB FF FF FF FF 
2740   19EF FF FF FF FF 
2740   19F3 FF FF FF FF 
2740   19F7 FF FF FF FF 
2740   19FB FF FF FF FF 
2740   19FF FF FF FF FF 
2740   1A03 FF FF FF FF 
2740   1A07 FF FF FF FF 
2740   1A0B FF FF FF FF 
2740   1A0F FF FF FF FF 
2740   1A13 FF FF FF FF 
2740   1A17 FF FF FF FF 
2740   1A1B FF FF FF FF 
2740   1A1F FF FF FF FF 
2740   1A23 FF FF FF FF 
2740   1A27 FF FF FF FF 
2740   1A2B FF FF FF FF 
2740   1A2F FF FF FF FF 
2740   1A33 FF FF FF FF 
2740   1A37 FF FF FF FF 
2740   1A3B FF FF FF FF 
2740   1A3F FF FF FF FF 
2740   1A43 FF FF FF FF 
2740   1A47 FF FF FF FF 
2740   1A4B FF FF FF FF 
2740   1A4F FF FF FF FF 
2740   1A53 FF FF FF FF 
2740   1A57 FF FF FF FF 
2740   1A5B FF FF FF FF 
2740   1A5F FF FF FF FF 
2740   1A63 FF FF FF FF 
2740   1A67 FF FF FF FF 
2740   1A6B FF FF FF FF 
2740   1A6F FF FF FF FF 
2740   1A73 FF FF FF FF 
2740   1A77 FF FF FF FF 
2740   1A7B FF FF FF FF 
2740   1A7F FF FF FF FF 
2740   1A83 FF FF FF FF 
2740   1A87 FF FF FF FF 
2740   1A8B FF FF FF FF 
2740   1A8F FF FF FF FF 
2740   1A93 FF FF FF FF 
2740   1A97 FF FF FF FF 
2740   1A9B FF FF FF FF 
2740   1A9F FF FF FF FF 
2740   1AA3 FF FF FF FF 
2740   1AA7 FF FF FF FF 
2740   1AAB FF FF FF FF 
2740   1AAF FF FF FF FF 
2740   1AB3 FF FF FF FF 
2740   1AB7 FF FF FF FF 
2740   1ABB FF FF FF FF 
2740   1ABF FF FF FF FF 
2740   1AC3 FF FF FF FF 
2740   1AC7 FF FF FF FF 
2740   1ACB FF FF FF FF 
2740   1ACF FF FF FF FF 
2740   1AD3 FF FF FF FF 
2740   1AD7 FF FF FF FF 
2740   1ADB FF FF FF FF 
2740   1ADF FF FF FF FF 
2740   1AE3 FF FF FF FF 
2740   1AE7 FF FF FF FF 
2740   1AEB FF 
2741   1AEC             
2742   1AEC 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2742   1AF0 00 00 00 00 
2742   1AF4 00 00 00 00 
2742   1AF8 00 00 00 00 
2742   1AFC 00 00 00 00 
2742   1B00 00 00 00 00 
2742   1B04 00 00 00 00 
2742   1B08 00 00 00 00 
2742   1B0C 00 00 00 00 
2742   1B10 00 00 00 00 
2742   1B14 00 00 00 00 
2742   1B18 00 00 00 00 
2742   1B1C 00 00 00 00 
2742   1B20 00 00 00 00 
2742   1B24 00 00 00 00 
2742   1B28 00 00 00 00 
2742   1B2C 00 00 00 00 
2742   1B30 00 00 00 00 
2742   1B34 00 00 00 00 
2742   1B38 00 00 00 00 
2742   1B3C 00 00 00 00 
2742   1B40 00 00 00 00 
2742   1B44 00 00 00 00 
2742   1B48 00 00 00 00 
2742   1B4C 00 00 00 00 
2742   1B50 00 00 00 00 
2742   1B54 00 00 00 00 
2742   1B58 00 00 00 00 
2742   1B5C 00 00 00 00 
2742   1B60 00 00 00 00 
2742   1B64 00 00 00 00 
2742   1B68 00 00 00 00 
2742   1B6C 00 00 00 00 
2742   1B70 00 00 00 00 
2742   1B74 00 00 00 00 
2742   1B78 00 00 00 00 
2742   1B7C 00 00 00 00 
2742   1B80 00 00 00 00 
2742   1B84 00 00 00 00 
2742   1B88 00 00 00 00 
2742   1B8C 00 00 00 00 
2742   1B90 00 00 00 00 
2742   1B94 00 00 00 00 
2742   1B98 00 00 00 00 
2742   1B9C 00 00 00 00 
2742   1BA0 00 00 00 00 
2742   1BA4 00 00 00 00 
2742   1BA8 00 00 00 00 
2742   1BAC 00 00 00 00 
2742   1BB0 00 00 00 00 
2742   1BB4 00 00 00 00 
2742   1BB8 00 00 00 00 
2742   1BBC 00 00 00 00 
2742   1BC0 00 00 00 00 
2742   1BC4 00 00 00 00 
2742   1BC8 00 00 00 00 
2742   1BCC 00 00 00 00 
2742   1BD0 00 00 00 00 
2742   1BD4 00 00 00 00 
2742   1BD8 00 00 00 00 
2742   1BDC 00 00 00 00 
2742   1BE0 00 00 00 00 
2742   1BE4 00 00 00 00 
2742   1BE8 00 00 00 00 
2742   1BEC 00 00 00 00 
2742   1BF0 00 00 00 00 
2742   1BF4 00 00 00 00 
2742   1BF8 00 00 00 00 
2742   1BFC 00 00 00 00 
2742   1C00 00 00 00 00 
2742   1C04 00 00 00 00 
2742   1C08 00 00 00 00 
2742   1C0C 00 00 00 00 
2742   1C10 00 00 00 00 
2742   1C14 00 00 00 00 
2742   1C18 00 00 00 00 
2742   1C1C 00 00 00 00 
2742   1C20 00 00 00 00 
2742   1C24 00 00 00 00 
2742   1C28 00 00 00 00 
2743   1C2C 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2743   1C30 00 00 00 00 
2743   1C34 00 00 00 00 
2743   1C38 00 00 00 00 
2744   1C3C 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2744   1C40 00 00 00 00 
2744   1C44 00 00 00 00 
2744   1C48 00 00 00 00 
2744   1C4C 00 00 00 00 
2744   1C50 00 00 00 00 
2744   1C54 00 00 00 00 
2744   1C58 00 00 00 00 
2744   1C5C 00 00 00 00 
2744   1C60 00 00 00 00 
2744   1C64 00 00 00 00 
2744   1C68 00 00 00 00 
2744   1C6C 00 00 00 00 
2744   1C70 00 00 00 00 
2744   1C74 00 00 00 00 
2744   1C78 00 00 00 00 
2744   1C7C 00 00 00 00 
2744   1C80 00 00 00 00 
2744   1C84 00 00 00 00 
2744   1C88 00 00 00 00 
2744   1C8C 00 00 00 00 
2744   1C90 00 00 00 00 
2744   1C94 00 00 00 00 
2744   1C98 00 00 00 00 
2744   1C9C 00 00 00 00 
2744   1CA0 00 00 00 00 
2744   1CA4 00 00 00 00 
2744   1CA8 00 00 00 00 
2744   1CAC 00 00 00 00 
2744   1CB0 00 00 00 00 
2744   1CB4 00 00 00 00 
2744   1CB8 00 00 00 00 
2744   1CBC 00 00 00 00 
2744   1CC0 00 00 00 00 
2744   1CC4 00 00 00 00 
2744   1CC8 00 00 00 00 
2744   1CCC 00 00 00 00 
2744   1CD0 00 00 00 00 
2744   1CD4 00 00 00 00 
2744   1CD8 00 00 00 00 
2744   1CDC 00 00 00 00 
2744   1CE0 00 00 00 00 
2744   1CE4 00 00 00 00 
2744   1CE8 00 00 00 00 
2744   1CEC 00 00 00 00 
2744   1CF0 00 00 00 00 
2744   1CF4 00 00 00 00 
2744   1CF8 00 00 00 00 
2744   1CFC 00 00 00 00 
2744   1D00 00 00 00 00 
2744   1D04 00 00 00 00 
2744   1D08 00 00 00 00 
2744   1D0C 00 00 00 00 
2744   1D10 00 00 00 00 
2744   1D14 00 00 00 00 
2744   1D18 00 00 00 00 
2744   1D1C 00 00 00 00 
2744   1D20 00 00 00 00 
2744   1D24 00 00 00 00 
2744   1D28 00 00 00 00 
2744   1D2C 00 00 00 00 
2744   1D30 00 00 00 00 
2744   1D34 00 00 00 00 
2744   1D38 00 00 00 00 
2744   1D3C 00 00 00 00 
2744   1D40 00 00 00 00 
2744   1D44 00 00 00 00 
2744   1D48 00 00 00 00 
2744   1D4C 00 00 00 00 
2744   1D50 00 00 00 00 
2744   1D54 00 00 00 00 
2744   1D58 00 00 00 00 
2744   1D5C 00 00 00 00 
2744   1D60 00 00 00 00 
2744   1D64 00 00 00 00 
2744   1D68 00 00 00 00 
2744   1D6C 00 00 00 00 
2744   1D70 00 00 00 00 
2744   1D74 00 00 00 00 
2744   1D78 00 00 00 00 
2744   1D7C 00 00 00 00 
2744   1D80 00 00 00 00 
2744   1D84 00 00 00 00 
2744   1D88 00 00 00 00 
2744   1D8C 00 00 00 00 
2744   1D90 00 00 00 00 
2744   1D94 00 00 00 00 
2744   1D98 00 00 00 00 
2744   1D9C 00 00 00 00 
2744   1DA0 00 00 00 00 
2744   1DA4 00 00 00 00 
2744   1DA8 00 00 00 00 
2744   1DAC 00 00 00 00 
2744   1DB0 00 00 00 00 
2744   1DB4 00 00 00 00 
2744   1DB8 00 00 00 00 
2744   1DBC 00 00 00 00 
2744   1DC0 00 00 00 00 
2744   1DC4 00 00 00 00 
2744   1DC8 00 00 00 00 
2744   1DCC 00 00 00 00 
2744   1DD0 00 00 00 00 
2744   1DD4 00 00 00 00 
2744   1DD8 00 00 00 00 
2744   1DDC 00 00 00 00 
2744   1DE0 00 00 00 00 
2744   1DE4 00 00 00 00 
2744   1DE8 00 00 00 00 
2744   1DEC 00 00 00 00 
2744   1DF0 00 00 00 00 
2744   1DF4 00 00 00 00 
2744   1DF8 00 00 00 00 
2744   1DFC 00 00 00 00 
2744   1E00 00 00 00 00 
2744   1E04 00 00 00 00 
2744   1E08 00 00 00 00 
2744   1E0C 00 00 00 00 
2744   1E10 00 00 00 00 
2744   1E14 00 00 00 00 
2744   1E18 00 00 00 00 
2744   1E1C 00 00 00 00 
2744   1E20 00 00 00 00 
2744   1E24 00 00 00 00 
2744   1E28 00 00 00 00 
2744   1E2C 00 00 00 00 
2744   1E30 00 00 00 00 
2744   1E34 00 00 00 00 
2744   1E38 00 00 00 00 
2745   1E3C 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2745   1E40 00 00 00 00 
2745   1E44 00 00 00 00 
2745   1E48 00 00 00 00 
2745   1E4C 00 00 00 00 
2745   1E50 00 00 00 00 
2745   1E54 00 00 00 00 
2745   1E58 00 00 00 00 
2745   1E5C 00 00 00 00 
2745   1E60 00 00 00 00 
2745   1E64 00 00 00 00 
2745   1E68 00 00 00 00 
2745   1E6C 00 00 00 00 
2745   1E70 00 00 00 00 
2745   1E74 00 00 00 00 
2745   1E78 00 00 00 00 
2745   1E7C 00 00 00 00 
2745   1E80 00 00 00 00 
2745   1E84 00 00 00 00 
2745   1E88 00 00 00 00 
2745   1E8C 00 00 00 00 
2745   1E90 00 00 00 00 
2745   1E94 00 00 00 00 
2745   1E98 00 00 00 00 
2745   1E9C 00 00 00 00 
2745   1EA0 00 00 00 00 
2745   1EA4 00 00 00 00 
2745   1EA8 00 00 00 00 
2745   1EAC 00 00 00 00 
2745   1EB0 00 00 00 00 
2745   1EB4 00 00 00 00 
2745   1EB8 00 00 00 00 
2746   1EBC 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2746   1EC0 00 00 00 00 
2746   1EC4 00 00 00 00 
2746   1EC8 00 00 00 00 
2746   1ECC 00 00 00 00 
2746   1ED0 00 00 00 00 
2746   1ED4 00 00 00 00 
2746   1ED8 00 00 00 00 
2746   1EDC 00 00 00 00 
2746   1EE0 00 00 00 00 
2746   1EE4 00 00 00 00 
2746   1EE8 00 00 00 00 
2746   1EEC 00 00 00 00 
2746   1EF0 00 00 00 00 
2746   1EF4 00 00 00 00 
2746   1EF8 00 00 00 00 
2746   1EFC 00 00 00 00 
2746   1F00 00 00 00 00 
2746   1F04 00 00 00 00 
2746   1F08 00 00 00 00 
2746   1F0C 00 00 00 00 
2746   1F10 00 00 00 00 
2746   1F14 00 00 00 00 
2746   1F18 00 00 00 00 
2746   1F1C 00 00 00 00 
2746   1F20 00 00 00 00 
2746   1F24 00 00 00 00 
2746   1F28 00 00 00 00 
2746   1F2C 00 00 00 00 
2746   1F30 00 00 00 00 
2746   1F34 00 00 00 00 
2746   1F38 00 00 00 00 
2746   1F3C 00 00 00 00 
2746   1F40 00 00 00 00 
2746   1F44 00 00 00 00 
2746   1F48 00 00 00 00 
2746   1F4C 00 00 00 00 
2746   1F50 00 00 00 00 
2746   1F54 00 00 00 00 
2746   1F58 00 00 00 00 
2746   1F5C 00 00 00 00 
2746   1F60 00 00 00 00 
2746   1F64 00 00 00 00 
2746   1F68 00 00 00 00 
2746   1F6C 00 00 00 00 
2746   1F70 00 00 00 00 
2746   1F74 00 00 00 00 
2746   1F78 00 00 00 00 
2746   1F7C 00 00 00 00 
2746   1F80 00 00 00 00 
2746   1F84 00 00 00 00 
2746   1F88 00 00 00 00 
2746   1F8C 00 00 00 00 
2746   1F90 00 00 00 00 
2746   1F94 00 00 00 00 
2746   1F98 00 00 00 00 
2746   1F9C 00 00 00 00 
2746   1FA0 00 00 00 00 
2746   1FA4 00 00 00 00 
2746   1FA8 00 00 00 00 
2746   1FAC 00 00 00 00 
2746   1FB0 00 00 00 00 
2746   1FB4 00 00 00 00 
2746   1FB8 00 00 00 00 
2746   1FBC 00 00 00 00 
2746   1FC0 00 00 00 00 
2746   1FC4 00 00 00 00 
2746   1FC8 00 00 00 00 
2746   1FCC 00 00 00 00 
2746   1FD0 00 00 00 00 
2746   1FD4 00 00 00 00 
2746   1FD8 00 00 00 00 
2746   1FDC 00 00 00 00 
2746   1FE0 00 00 00 00 
2746   1FE4 00 00 00 00 
2746   1FE8 00 00 00 00 
2746   1FEC 00 00 00 00 
2746   1FF0 00 00 00 00 
2746   1FF4 00 00 00 00 
2746   1FF8 00 00 00 00 
2746   1FFC 00 00 00 00 
2746   2000 00 00 00 00 
2746   2004 00 00 00 00 
2746   2008 00 00 00 00 
2746   200C 00 00 00 00 
2746   2010 00 00 00 00 
2746   2014 00 00 00 00 
2746   2018 00 00 00 00 
2746   201C 00 00 00 00 
2746   2020 00 00 00 00 
2746   2024 00 00 00 00 
2746   2028 00 00 00 00 
2746   202C 00 00 00 00 
2746   2030 00 00 00 00 
2746   2034 00 00 00 00 
2746   2038 00 00 00 00 
2746   203C 00 00 00 00 
2746   2040 00 00 00 00 
2746   2044 00 00 00 00 
2746   2048 00 00 00 00 
2746   204C 00 00 00 00 
2746   2050 00 00 00 00 
2746   2054 00 00 00 00 
2746   2058 00 00 00 00 
2746   205C 00 00 00 00 
2746   2060 00 00 00 00 
2746   2064 00 00 00 00 
2746   2068 00 00 00 00 
2746   206C 00 00 00 00 
2746   2070 00 00 00 00 
2746   2074 00 00 00 00 
2746   2078 00 00 00 00 
2746   207C 00 00 00 00 
2746   2080 00 00 00 00 
2746   2084 00 00 00 00 
2746   2088 00 00 00 00 
2746   208C 00 00 00 00 
2746   2090 00 00 00 00 
2746   2094 00 00 00 00 
2746   2098 00 00 00 00 
2746   209C 00 00 00 00 
2746   20A0 00 00 00 00 
2746   20A4 00 00 00 00 
2746   20A8 00 00 00 00 
2746   20AC 00 00 00 00 
2746   20B0 00 00 00 00 
2746   20B4 00 00 00 00 
2746   20B8 00 00 00 00 
2747   20BC FF FF FF FF fifo:               .fill FIFO_SIZE
2747   20C0 FF FF FF FF 
2747   20C4 FF FF FF FF 
2747   20C8 FF FF FF FF 
2747   20CC FF FF FF FF 
2747   20D0 FF FF FF FF 
2747   20D4 FF FF FF FF 
2747   20D8 FF FF FF FF 
2747   20DC FF FF FF FF 
2747   20E0 FF FF FF FF 
2747   20E4 FF FF FF FF 
2747   20E8 FF FF FF FF 
2747   20EC FF FF FF FF 
2747   20F0 FF FF FF FF 
2747   20F4 FF FF FF FF 
2747   20F8 FF FF FF FF 
2747   20FC FF FF FF FF 
2747   2100 FF FF FF FF 
2747   2104 FF FF FF FF 
2747   2108 FF FF FF FF 
2747   210C FF FF FF FF 
2747   2110 FF FF FF FF 
2747   2114 FF FF FF FF 
2747   2118 FF FF FF FF 
2747   211C FF FF FF FF 
2747   2120 FF FF FF FF 
2747   2124 FF FF FF FF 
2747   2128 FF FF FF FF 
2747   212C FF FF FF FF 
2747   2130 FF FF FF FF 
2747   2134 FF FF FF FF 
2747   2138 FF FF FF FF 
2747   213C FF FF FF FF 
2747   2140 FF FF FF FF 
2747   2144 FF FF FF FF 
2747   2148 FF FF FF FF 
2747   214C FF FF FF FF 
2747   2150 FF FF FF FF 
2747   2154 FF FF FF FF 
2747   2158 FF FF FF FF 
2747   215C FF FF FF FF 
2747   2160 FF FF FF FF 
2747   2164 FF FF FF FF 
2747   2168 FF FF FF FF 
2747   216C FF FF FF FF 
2747   2170 FF FF FF FF 
2747   2174 FF FF FF FF 
2747   2178 FF FF FF FF 
2747   217C FF FF FF FF 
2747   2180 FF FF FF FF 
2747   2184 FF FF FF FF 
2747   2188 FF FF FF FF 
2747   218C FF FF FF FF 
2747   2190 FF FF FF FF 
2747   2194 FF FF FF FF 
2747   2198 FF FF FF FF 
2747   219C FF FF FF FF 
2747   21A0 FF FF FF FF 
2747   21A4 FF FF FF FF 
2747   21A8 FF FF FF FF 
2747   21AC FF FF FF FF 
2747   21B0 FF FF FF FF 
2747   21B4 FF FF FF FF 
2747   21B8 FF FF FF FF 
2747   21BC FF FF FF FF 
2747   21C0 FF FF FF FF 
2747   21C4 FF FF FF FF 
2747   21C8 FF FF FF FF 
2747   21CC FF FF FF FF 
2747   21D0 FF FF FF FF 
2747   21D4 FF FF FF FF 
2747   21D8 FF FF FF FF 
2747   21DC FF FF FF FF 
2747   21E0 FF FF FF FF 
2747   21E4 FF FF FF FF 
2747   21E8 FF FF FF FF 
2747   21EC FF FF FF FF 
2747   21F0 FF FF FF FF 
2747   21F4 FF FF FF FF 
2747   21F8 FF FF FF FF 
2747   21FC FF FF FF FF 
2747   2200 FF FF FF FF 
2747   2204 FF FF FF FF 
2747   2208 FF FF FF FF 
2747   220C FF FF FF FF 
2747   2210 FF FF FF FF 
2747   2214 FF FF FF FF 
2747   2218 FF FF FF FF 
2747   221C FF FF FF FF 
2747   2220 FF FF FF FF 
2747   2224 FF FF FF FF 
2747   2228 FF FF FF FF 
2747   222C FF FF FF FF 
2747   2230 FF FF FF FF 
2747   2234 FF FF FF FF 
2747   2238 FF FF FF FF 
2747   223C FF FF FF FF 
2747   2240 FF FF FF FF 
2747   2244 FF FF FF FF 
2747   2248 FF FF FF FF 
2747   224C FF FF FF FF 
2747   2250 FF FF FF FF 
2747   2254 FF FF FF FF 
2747   2258 FF FF FF FF 
2747   225C FF FF FF FF 
2747   2260 FF FF FF FF 
2747   2264 FF FF FF FF 
2747   2268 FF FF FF FF 
2747   226C FF FF FF FF 
2747   2270 FF FF FF FF 
2747   2274 FF FF FF FF 
2747   2278 FF FF FF FF 
2747   227C FF FF FF FF 
2747   2280 FF FF FF FF 
2747   2284 FF FF FF FF 
2747   2288 FF FF FF FF 
2747   228C FF FF FF FF 
2747   2290 FF FF FF FF 
2747   2294 FF FF FF FF 
2747   2298 FF FF FF FF 
2747   229C FF FF FF FF 
2747   22A0 FF FF FF FF 
2747   22A4 FF FF FF FF 
2747   22A8 FF FF FF FF 
2747   22AC FF FF FF FF 
2747   22B0 FF FF FF FF 
2747   22B4 FF FF FF FF 
2747   22B8 FF FF FF FF 
2747   22BC FF FF FF FF 
2747   22C0 FF FF FF FF 
2747   22C4 FF FF FF FF 
2747   22C8 FF FF FF FF 
2747   22CC FF FF FF FF 
2747   22D0 FF FF FF FF 
2747   22D4 FF FF FF FF 
2747   22D8 FF FF FF FF 
2747   22DC FF FF FF FF 
2747   22E0 FF FF FF FF 
2747   22E4 FF FF FF FF 
2747   22E8 FF FF FF FF 
2747   22EC FF FF FF FF 
2747   22F0 FF FF FF FF 
2747   22F4 FF FF FF FF 
2747   22F8 FF FF FF FF 
2747   22FC FF FF FF FF 
2747   2300 FF FF FF FF 
2747   2304 FF FF FF FF 
2747   2308 FF FF FF FF 
2747   230C FF FF FF FF 
2747   2310 FF FF FF FF 
2747   2314 FF FF FF FF 
2747   2318 FF FF FF FF 
2747   231C FF FF FF FF 
2747   2320 FF FF FF FF 
2747   2324 FF FF FF FF 
2747   2328 FF FF FF FF 
2747   232C FF FF FF FF 
2747   2330 FF FF FF FF 
2747   2334 FF FF FF FF 
2747   2338 FF FF FF FF 
2747   233C FF FF FF FF 
2747   2340 FF FF FF FF 
2747   2344 FF FF FF FF 
2747   2348 FF FF FF FF 
2747   234C FF FF FF FF 
2747   2350 FF FF FF FF 
2747   2354 FF FF FF FF 
2747   2358 FF FF FF FF 
2747   235C FF FF FF FF 
2747   2360 FF FF FF FF 
2747   2364 FF FF FF FF 
2747   2368 FF FF FF FF 
2747   236C FF FF FF FF 
2747   2370 FF FF FF FF 
2747   2374 FF FF FF FF 
2747   2378 FF FF FF FF 
2747   237C FF FF FF FF 
2747   2380 FF FF FF FF 
2747   2384 FF FF FF FF 
2747   2388 FF FF FF FF 
2747   238C FF FF FF FF 
2747   2390 FF FF FF FF 
2747   2394 FF FF FF FF 
2747   2398 FF FF FF FF 
2747   239C FF FF FF FF 
2747   23A0 FF FF FF FF 
2747   23A4 FF FF FF FF 
2747   23A8 FF FF FF FF 
2747   23AC FF FF FF FF 
2747   23B0 FF FF FF FF 
2747   23B4 FF FF FF FF 
2747   23B8 FF FF FF FF 
2747   23BC FF FF FF FF 
2747   23C0 FF FF FF FF 
2747   23C4 FF FF FF FF 
2747   23C8 FF FF FF FF 
2747   23CC FF FF FF FF 
2747   23D0 FF FF FF FF 
2747   23D4 FF FF FF FF 
2747   23D8 FF FF FF FF 
2747   23DC FF FF FF FF 
2747   23E0 FF FF FF FF 
2747   23E4 FF FF FF FF 
2747   23E8 FF FF FF FF 
2747   23EC FF FF FF FF 
2747   23F0 FF FF FF FF 
2747   23F4 FF FF FF FF 
2747   23F8 FF FF FF FF 
2747   23FC FF FF FF FF 
2747   2400 FF FF FF FF 
2747   2404 FF FF FF FF 
2747   2408 FF FF FF FF 
2747   240C FF FF FF FF 
2747   2410 FF FF FF FF 
2747   2414 FF FF FF FF 
2747   2418 FF FF FF FF 
2747   241C FF FF FF FF 
2747   2420 FF FF FF FF 
2747   2424 FF FF FF FF 
2747   2428 FF FF FF FF 
2747   242C FF FF FF FF 
2747   2430 FF FF FF FF 
2747   2434 FF FF FF FF 
2747   2438 FF FF FF FF 
2747   243C FF FF FF FF 
2747   2440 FF FF FF FF 
2747   2444 FF FF FF FF 
2747   2448 FF FF FF FF 
2747   244C FF FF FF FF 
2747   2450 FF FF FF FF 
2747   2454 FF FF FF FF 
2747   2458 FF FF FF FF 
2747   245C FF FF FF FF 
2747   2460 FF FF FF FF 
2747   2464 FF FF FF FF 
2747   2468 FF FF FF FF 
2747   246C FF FF FF FF 
2747   2470 FF FF FF FF 
2747   2474 FF FF FF FF 
2747   2478 FF FF FF FF 
2747   247C FF FF FF FF 
2747   2480 FF FF FF FF 
2747   2484 FF FF FF FF 
2747   2488 FF FF FF FF 
2747   248C FF FF FF FF 
2747   2490 FF FF FF FF 
2747   2494 FF FF FF FF 
2747   2498 FF FF FF FF 
2747   249C FF FF FF FF 
2747   24A0 FF FF FF FF 
2747   24A4 FF FF FF FF 
2747   24A8 FF FF FF FF 
2747   24AC FF FF FF FF 
2747   24B0 FF FF FF FF 
2747   24B4 FF FF FF FF 
2747   24B8 FF FF FF FF 
2748   24BC             
2749   24BC FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2749   24C0 FF FF FF FF 
2749   24C4 FF FF FF FF 
2749   24C8 FF FF FF FF 
2749   24CC FF FF FF FF 
2749   24D0 FF FF FF FF 
2749   24D4 FF FF FF FF 
2749   24D8 FF FF FF FF 
2749   24DC FF FF FF FF 
2749   24E0 FF FF FF FF 
2749   24E4 FF FF FF FF 
2749   24E8 FF FF FF FF 
2749   24EC FF FF FF FF 
2749   24F0 FF FF FF FF 
2749   24F4 FF FF FF FF 
2749   24F8 FF FF FF FF 
2749   24FC FF FF FF FF 
2749   2500 FF FF FF FF 
2749   2504 FF FF FF FF 
2749   2508 FF FF FF FF 
2749   250C FF FF FF FF 
2749   2510 FF FF FF FF 
2749   2514 FF FF FF FF 
2749   2518 FF FF FF FF 
2749   251C FF FF FF FF 
2749   2520 FF FF FF FF 
2749   2524 FF FF FF FF 
2749   2528 FF FF FF FF 
2749   252C FF FF FF FF 
2749   2530 FF FF FF FF 
2749   2534 FF FF FF FF 
2749   2538 FF FF FF FF 
2749   253C FF FF FF FF 
2749   2540 FF FF FF FF 
2749   2544 FF FF FF FF 
2749   2548 FF FF FF FF 
2749   254C FF FF FF FF 
2749   2550 FF FF FF FF 
2749   2554 FF FF FF FF 
2749   2558 FF FF FF FF 
2749   255C FF FF FF FF 
2749   2560 FF FF FF FF 
2749   2564 FF FF FF FF 
2749   2568 FF FF FF FF 
2749   256C FF FF FF FF 
2749   2570 FF FF FF FF 
2749   2574 FF FF FF FF 
2749   2578 FF FF FF FF 
2749   257C FF FF FF FF 
2749   2580 FF FF FF FF 
2749   2584 FF FF FF FF 
2749   2588 FF FF FF FF 
2749   258C FF FF FF FF 
2749   2590 FF FF FF FF 
2749   2594 FF FF FF FF 
2749   2598 FF FF FF FF 
2749   259C FF FF FF FF 
2749   25A0 FF FF FF FF 
2749   25A4 FF FF FF FF 
2749   25A8 FF FF FF FF 
2749   25AC FF FF FF FF 
2749   25B0 FF FF FF FF 
2749   25B4 FF FF FF FF 
2749   25B8 FF FF FF FF 
2749   25BC FF FF FF FF 
2749   25C0 FF FF FF FF 
2749   25C4 FF FF FF FF 
2749   25C8 FF FF FF FF 
2749   25CC FF FF FF FF 
2749   25D0 FF FF FF FF 
2749   25D4 FF FF FF FF 
2749   25D8 FF FF FF FF 
2749   25DC FF FF FF FF 
2749   25E0 FF FF FF FF 
2749   25E4 FF FF FF FF 
2749   25E8 FF FF FF FF 
2749   25EC FF FF FF FF 
2749   25F0 FF FF FF FF 
2749   25F4 FF FF FF FF 
2749   25F8 FF FF FF FF 
2749   25FC FF FF FF FF 
2749   2600 FF FF FF FF 
2749   2604 FF FF FF FF 
2749   2608 FF FF FF FF 
2749   260C FF FF FF FF 
2749   2610 FF FF FF FF 
2749   2614 FF FF FF FF 
2749   2618 FF FF FF FF 
2749   261C FF FF FF FF 
2749   2620 FF FF FF FF 
2749   2624 FF FF FF FF 
2749   2628 FF FF FF FF 
2749   262C FF FF FF FF 
2749   2630 FF FF FF FF 
2749   2634 FF FF FF FF 
2749   2638 FF FF FF FF 
2749   263C FF FF FF FF 
2749   2640 FF FF FF FF 
2749   2644 FF FF FF FF 
2749   2648 FF FF FF FF 
2749   264C FF FF FF FF 
2749   2650 FF FF FF FF 
2749   2654 FF FF FF FF 
2749   2658 FF FF FF FF 
2749   265C FF FF FF FF 
2749   2660 FF FF FF FF 
2749   2664 FF FF FF FF 
2749   2668 FF FF FF FF 
2749   266C FF FF FF FF 
2749   2670 FF FF FF FF 
2749   2674 FF FF FF FF 
2749   2678 FF FF FF FF 
2749   267C FF FF FF FF 
2749   2680 FF FF FF FF 
2749   2684 FF FF FF FF 
2749   2688 FF FF FF FF 
2749   268C FF FF FF FF 
2749   2690 FF FF FF FF 
2749   2694 FF FF FF FF 
2749   2698 FF FF FF FF 
2749   269C FF FF FF FF 
2749   26A0 FF FF FF FF 
2749   26A4 FF FF FF FF 
2749   26A8 FF FF FF FF 
2749   26AC FF FF FF FF 
2749   26B0 FF FF FF FF 
2749   26B4 FF FF FF FF 
2749   26B8 FF FF FF FF 
2750   26BC 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2751   26BD             
2752   26BD             
2753   26BD             .end
tasm: Number of errors = 0
