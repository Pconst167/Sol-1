0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             ; Memory Map
0005   0000             ; ------------------------------------------------------------------------------------------------------------------;
0006   0000             ; 0000    ROM BEGIN
0007   0000             ; ....
0008   0000             ; 7FFF    ROM END
0009   0000             ;
0010   0000             ; 8000    RAM begin
0011   0000             ; ....
0012   0000             ; F7FF    Stack root
0013   0000             ; ------------------------------------------------------------------------------------------------------------------;
0014   0000             ; I/O MAP
0015   0000             ; ------------------------------------------------------------------------------------------------------------------;
0016   0000             ; FF80    UART 0              (16550)
0017   0000             ; FF90    UART 1              (16550)
0018   0000             ; FFA0    RTC                 (M48T02)
0019   0000             ; FFB0    PIO 0               (8255)
0020   0000             ; FFC0    5.25" Floppy Drive Block
0021   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0022   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0023   0000             ;   - FFC8      WD1770 Status/Command    
0024   0000             ;   - FFC9      WD1770 Track Register
0025   0000             ;   - FFCA      WD1770 Sector Register
0026   0000             ;   - FFCB      WD1770 Data Register
0027   0000             ;      
0028   0000             ; FFD0    IDE                 (Compact Flash / PATA)
0029   0000             ; FFE0    Timer               (8253)
0030   0000             ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0031   0000             ; ------------------------------------------------------------------------------------------------------------------;
0032   0000             
0033   0000             ; ------------------------------------------------------------------------------------------------------------------;
0034   0000             ; System Constants
0035   0000             ; ------------------------------------------------------------------------------------------------------------------;
0036   0000             _UART0_DATA       .equ $FF80            ; data
0037   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0038   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0039   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0040   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0041   0000             _UART0_LCR        .equ $FF83            ; line control register
0042   0000             _UART0_LSR        .equ $FF85            ; line status register
0043   0000             
0044   0000             _UART1_DATA       .equ $FF90            ; data
0045   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0046   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0047   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0048   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0049   0000             _UART1_LCR        .equ $FF93            ; line control register
0050   0000             _UART1_LSR        .equ $FF95            ; line status register
0051   0000             
0052   0000             XON               .equ $11
0053   0000             XOFF              .equ $13
0054   0000             
0055   0000             _ide_BASE         .equ $FFD0            ; IDE BASE
0056   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0057   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0058   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0059   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0060   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0061   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0062   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0063   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0064   0000             
0065   0000             _7SEG_DISPLAY     .equ $FFB0            ; BIOS POST CODE HEX DISPLAY (2 DIGITS) (CONNECTED TO PIO A)
0066   0000             _BIOS_POST_CTRL   .equ $FFB3            ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0067   0000             _PIO_A            .equ $FFB0    
0068   0000             _PIO_B            .equ $FFB1
0069   0000             _PIO_C            .equ $FFB2
0070   0000             _PIO_CONTROL      .equ $FFB3            ; PIO CONTROL PORT
0071   0000             
0072   0000             _FDC_CONFIG       .equ $FFC0 
0073   0000             _FDC_STATUS_1     .equ $FFC1
0074   0000             _FDC_WD_STAT_CMD  .equ $FFC8
0075   0000             _FDC_WD_TRACK     .equ $FFC9
0076   0000             _FDC_WD_SECTOR    .equ $FFCA
0077   0000             _FDC_WD_DATA      .equ $FFCB
0078   0000             
0079   0000             _TIMER_C_0        .equ $FFE0            ; TIMER COUNTER 0
0080   0000             _TIMER_C_1        .equ $FFE1            ; TIMER COUNTER 1
0081   0000             _TIMER_C_2        .equ $FFE2            ; TIMER COUNTER 2
0082   0000             _TIMER_CTRL       .equ $FFE3            ; TIMER CONTROL REGISTER
0083   0000             
0084   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0085   0000             FIFO_SIZE         .equ 1024
0086   0000             
0087   0000             text_org          .equ $400
0088   0000             ; ------------------------------------------------------------------------------------------------------------------;
0089   0000             
0090   0000             
0091   0000             ; For the next iteration:
0092   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0093   0000             ; inode-table format:
0094   0000             ;  file-type(f, d)
0095   0000             ;  permissons
0096   0000             ;  link-count
0097   0000             ;  filesize
0098   0000             ;  time-stamps
0099   0000             ;  15 data block pointers
0100   0000             ;  single-indirect pointer
0101   0000             
0102   0000             ; FILE ENTRY ATTRIBUTES
0103   0000             ; filename (24)
0104   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0105   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0106   0000             ; size (2)             : filesize
0107   0000             ; day (1)           
0108   0000             ; month (1)
0109   0000             ; year (1)
0110   0000             ; packet size = 32 bytes  : total packet size in bytes
0111   0000             
0112   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0113   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0114   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0115   0000             FST_NBR_DIRECTORIES     .equ 64
0116   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0117   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0118   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0119   0000             FST_LBA_START           .equ 32
0120   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0121   0000             
0122   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0123   0000             FS_SECTORS_PER_FILE     .equ 32         ; the first sector is always a header with a NULL parameter (first byte)
0124   0000                                                     ; so that we know which blocks are free or taken
0125   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0126   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0127   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0128   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0129   0000             
0130   0000             root_id:                .equ FST_LBA_START
0131   0000             
0132   0000             ; ------------------------------------------------------------------------------------------------------------------;
0133   0000             ; GLOBAL SYSTEM VARIABLES
0134   0000             ; ------------------------------------------------------------------------------------------------------------------;
0135   0000             
0136   0000             ; ------------------------------------------------------------------------------------------------------------------;
0137   0000             ; IRQ Table
0138   0000             ; Highest priority at lowest address
0139   0000             ; ------------------------------------------------------------------------------------------------------------------;
0140   0000 3C 00       .dw int_0_fdc
0141   0002 43 00       .dw int_1
0142   0004 44 00       .dw int_2
0143   0006 45 00       .dw int_3
0144   0008 46 00       .dw int_4
0145   000A 47 00       .dw int_5
0146   000C 59 00       .dw int_6
0147   000E A5 00       .dw int_7_uart0
0148   0010             
0149   0010             ; ------------------------------------------------------------------------------------------------------------------;
0150   0010             ; Reset Vector
0151   0010             ; ------------------------------------------------------------------------------------------------------------------;
0152   0010 E8 0F       .dw kernel_reset_vector
0153   0012             
0154   0012             ; ------------------------------------------------------------------------------------------------------------------;
0155   0012             ; Exception Vector Table
0156   0012             ; Total of 7 entries, starting at address $0012
0157   0012             ; ------------------------------------------------------------------------------------------------------------------;
0158   0012 E0 01       .dw trap_privilege
0159   0014 FD 02       .dw trap_div_zero
0160   0016 0A 03       .dw trap_undef_opcode
0161   0018 00 00       .dw 0
0162   001A 00 00       .dw 0
0163   001C 00 00       .dw 0
0164   001E 00 00       .dw 0
0165   0020             
0166   0020             ; ------------------------------------------------------------------------------------------------------------------;
0167   0020             ; System Call Vector Table
0168   0020             ; Starts at address $0020
0169   0020             ; ------------------------------------------------------------------------------------------------------------------;
0170   0020 EC 01       .dw syscall_break
0171   0022 0B 03       .dw syscall_rtc
0172   0024 45 04       .dw syscall_ide
0173   0026 20 05       .dw syscall_io
0174   0028 DD 05       .dw syscall_file_system
0175   002A 35 0F       .dw syscall_create_proc
0176   002C A5 01       .dw syscall_list_procs
0177   002E 3D 03       .dw syscall_datetime
0178   0030 61 01       .dw syscall_reboot
0179   0032 FF 0E       .dw syscall_pause_proc
0180   0034 6D 01       .dw syscall_resume_proc
0181   0036 BC 0E       .dw syscall_terminate_proc
0182   0038 E4 00       .dw syscall_system
0183   003A 14 01       .dw syscall_fdc
0184   003C             
0185   003C             ; ------------------------------------------------------------------------------------------------------------------;
0186   003C             ; System Call Aliases
0187   003C             ; ------------------------------------------------------------------------------------------------------------------;
0188   003C             sys_break            .equ 0
0189   003C             sys_rtc              .equ 1
0190   003C             sys_ide              .equ 2
0191   003C             sys_io               .equ 3
0192   003C             sys_filesystem       .equ 4
0193   003C             sys_create_proc      .equ 5
0194   003C             sys_list_proc        .equ 6
0195   003C             sys_datetime         .equ 7
0196   003C             sys_reboot           .equ 8
0197   003C             sys_pause_proc       .equ 9
0198   003C             sys_resume_proc      .equ 10
0199   003C             sys_terminate_proc   .equ 11
0200   003C             sys_system           .equ 12
0201   003C             sys_fdc              .equ 13
0202   003C             
0203   003C             ; ------------------------------------------------------------------------------------------------------------------;
0204   003C             ; Alias Exports
0205   003C             ; ------------------------------------------------------------------------------------------------------------------;
0206   003C             .export text_org
0207   003C             .export sys_break
0208   003C             .export sys_rtc
0209   003C             .export sys_ide
0210   003C             .export sys_io
0211   003C             .export sys_filesystem
0212   003C             .export sys_create_proc
0213   003C             .export sys_list_proc
0214   003C             .export sys_datetime
0215   003C             .export sys_reboot
0216   003C             .export sys_pause_proc
0217   003C             .export sys_resume_proc
0218   003C             .export sys_terminate_proc
0219   003C             .export sys_system
0220   003C             .export sys_fdc
0221   003C             
0222   003C             ; ------------------------------------------------------------------------------------------------------------------;
0223   003C             ; IRQs' Code Block
0224   003C             ; ------------------------------------------------------------------------------------------------------------------;
0225   003C             ; 5.25" Floppy Drive Controller IRQ
0226   003C             int_0_fdc:
0227   003C 3B 48 00      mov d, s_fdc_irq
0228   003F 07 32 12      call _puts
0229   0042 06            sysret
0230   0043             int_1:
0231   0043 06            sysret
0232   0044             int_2:
0233   0044 06            sysret
0234   0045             int_3:
0235   0045 06            sysret
0236   0046             int_4:
0237   0046 06            sysret
0238   0047             int_5:
0239   0047 06            sysret
0240   0048             
0241   0048 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
0241   004C 30 20 45 78 
0241   0050 65 63 75 74 
0241   0054 65 64 2E 0A 
0241   0058 00 
0242   0059             
0243   0059             ; ------------------------------------------------------------------------------------------------------------------;
0244   0059             ; Process Swapping
0245   0059             ; ------------------------------------------------------------------------------------------------------------------;
0246   0059             int_6:  
0247   0059 4B            pusha ; save all registers into kernel stack
0248   005A 22 00         mov ah, 0
0249   005C 1D 63 17      mov al, [active_proc_index]
0250   005F FD 99         shl a              ; x2
0251   0061 B7 B2 0F      mov a, [proc_table_convert + a]  ; get process state start index
0252   0064 4F            mov di, a
0253   0065 48            mov a, sp
0254   0066 77            inc a
0255   0067 4D            mov si, a
0256   0068 38 14 00      mov c, 20
0257   006B FD F5         rep movsb          ; save process state!
0258   006D             ; restore kernel stack position to point before interrupt arrived
0259   006D 51 14 00      add sp, 20
0260   0070             ; now load next process in queue
0261   0070 1D 63 17      mov al, [active_proc_index]
0262   0073 31 62 17      mov bl, [nbr_active_procs]
0263   0076 BA            cmp al, bl
0264   0077 C6 7E 00      je int6_cycle_back
0265   007A 7A            inc al            ; next process is next in the series
0266   007B 0A 80 00      jmp int6_continue
0267   007E             int6_cycle_back:
0268   007E 19 01         mov al, 1        ; next process = process 1
0269   0080             int6_continue:
0270   0080 3D 63 17      mov [active_proc_index], al    ; set next active proc
0271   0083             
0272   0083             ; calculate LUT entry for next process
0273   0083 22 00         mov ah, 0
0274   0085 FD 99         shl a              ; x2
0275   0087 B7 B2 0F      mov a, [proc_table_convert + a]    ; get process state start index  
0276   008A               
0277   008A 4D            mov si, a            ; source is proc state block
0278   008B 48            mov a, sp
0279   008C 5F 13 00      sub a, 19
0280   008F 4F            mov di, a            ; destination is kernel stack
0281   0090             ; restore SP
0282   0090 7D            dec a
0283   0091 47            mov sp, a
0284   0092 38 14 00      mov c, 20
0285   0095 FD F5         rep movsb
0286   0097             ; set VM process
0287   0097 1D 63 17      mov al, [active_proc_index]
0288   009A 01            setptb
0289   009B F2 E0 FF 00   mov byte[_TIMER_C_0], 0        ; load counter 0 low byte
0290   009F F2 E0 FF 10   mov byte[_TIMER_C_0], $10        ; load counter 0 high byte
0291   00A3 4C            popa
0292   00A4 06            sysret
0293   00A5             
0294   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0295   00A5             ; UART0 Interrupt
0296   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0297   00A5             int_7_uart0:
0298   00A5 D7            push a
0299   00A6 DA            push d
0300   00A7 E1            pushf
0301   00A8 14 68 17      mov a, [fifo_in]
0302   00AB 3C            mov d, a
0303   00AC 1D 80 FF      mov al, [_UART0_DATA]  ; get character
0304   00AF B9 03         cmp al, $03        ; CTRL-C
0305   00B1 C6 CE 00      je CTRLC
0306   00B4 B9 1A         cmp al, $1A        ; CTRL-Z
0307   00B6 C6 D4 00      je CTRLZ
0308   00B9 3E            mov [d], al        ; add to fifo
0309   00BA 14 68 17      mov a, [fifo_in]
0310   00BD 77            inc a
0311   00BE AF A9 24      cmp a, fifo + FIFO_SIZE         ; check if pointer reached the end of the fifo
0312   00C1 C7 C7 00      jne int_7_continue
0313   00C4 10 A9 20      mov a, fifo  
0314   00C7             int_7_continue:  
0315   00C7 42 68 17      mov [fifo_in], a      ; update fifo pointer
0316   00CA EE            popf
0317   00CB E7            pop d
0318   00CC E4            pop a  
0319   00CD 06            sysret
0320   00CE             CTRLC:
0321   00CE 51 05 00      add sp, 5
0322   00D1 0A BC 0E      jmp syscall_terminate_proc
0323   00D4             CTRLZ:
0324   00D4 EE            popf
0325   00D5 E7            pop d
0326   00D6 E4            pop a
0327   00D7 0A FF 0E      jmp syscall_pause_proc    ; pause current process and go back to the shell
0328   00DA             
0329   00DA             
0330   00DA             
0331   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0332   00DA             ; System Syscalls
0333   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0334   00DA             system_jmptbl:
0335   00DA 10 01         .dw system_uname
0336   00DC 11 01         .dw system_whoami
0337   00DE 0D 01         .dw system_setparam
0338   00E0 EA 00         .dw system_bootloader_install
0339   00E2 E8 00         .dw system_getparam
0340   00E4             syscall_system:
0341   00E4 FD 0A DA 00   jmp [system_jmptbl + al]
0342   00E8             
0343   00E8             ; param register address in register d
0344   00E8             ; param value in register bl
0345   00E8             system_getparam:
0346   00E8 32            mov bl, [d]
0347   00E9 06            sysret
0348   00EA             
0349   00EA             ; kernel LBA address in 'b'
0350   00EA             system_bootloader_install:
0351   00EA D8            push b
0352   00EB 26 00 00      mov b, 0
0353   00EE 38 00 00      mov c, 0
0354   00F1 22 01         mov ah, $01                 ; 1 sector
0355   00F3 3B A9 26      mov d, transient_area
0356   00F6 07 8F 04      call ide_read_sect          ; read sector
0357   00F9 E5            pop b
0358   00FA FD 44 FE 01   mov [d + 510], b            ; update LBA address
0359   00FE 26 00 00      mov b, 0
0360   0101 38 00 00      mov c, 0
0361   0104 22 01         mov ah, $01                 ; 1 sector
0362   0106 3B A9 26      mov d, transient_area
0363   0109 07 B5 04      call ide_write_sect         ; write sector
0364   010C 06            sysret
0365   010D             
0366   010D             ; param register address in register d
0367   010D             ; param value in register bl
0368   010D             system_setparam:
0369   010D FD 3E         mov [d], bl
0370   010F 06            sysret
0371   0110             
0372   0110             system_uname:
0373   0110 06            sysret
0374   0111             
0375   0111             system_whoami:
0376   0111 06            sysret
0377   0112             
0378   0112             ; fdc_40_FF:     .fill 40,  $FF  ; or 00                                                                                
0379   0112             ; fdc_6_00_0:    .fill 6,   $00  ;                                                                            <--|        
0380   0112             ; fdc_id_fe:     .fill 1,   $FE  ; ID Address Mark                                                               |        
0381   0112             ; fdc_track:     .fill 1,   $00  ; Track Number                                                                  |                    
0382   0112             ; fdc_side:      .fill 1,   $00  ; Side Number 00 or 01                                                          |                
0383   0112             ; fdc_sector:    .fill 1,   $01  ; Sector Number  1 through 10                                                   |                              
0384   0112             ; fdc_length:    .fill 1,   $00  ; Sector Length                                                                 |                        
0385   0112             ; fdc_2_crc_0:   .fill 1,   $F7  ; 2 CRC's Written                                                               | Write 16 times                 
0386   0112             ; fdc_11_ff:     .fill 11,  $FF  ; or 00                                                                         |                      
0387   0112             ; fdc_6_00_1:    .fill 6,   $00  ;                                                                               |                        
0388   0112             ; fdc_data_addr: .fill 1,   $FB  ; Data Address Mark                                                             |                                  
0389   0112             ; fdc_data:      .fill 128, $E5  ; Data (IBM uses E5)                                                            |                                      
0390   0112             ; fdc_2_crc_1:   .fill 1,   $F7  ; 2 CRC's Written                                                               |                                                        
0391   0112             ; fdc_10_ff:     .fill 10,  $FF  ; or 00                                                                      <--|                                                  
0392   0112             ; fdc_369_ff:    .fill 369, $FF  ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0393   0112             ; ***************************************************************************************************************
0394   0112             ; _FDC_CONFIG       .equ $FFC0 
0395   0112             ; _FDC_STATUS_1     .equ $FFC1
0396   0112             ; _FDC_WD_STAT_CMD  .equ $FFC8
0397   0112             ; _FDC_WD_TRACK     .equ $FFC9
0398   0112             ; _FDC_WD_SECTOR    .equ $FFCA
0399   0112             ; _FDC_WD_DATA      .equ $FFCB
0400   0112             fdc_jmptbl:
0401   0112 18 01         .dw syscall_fdc_format
0402   0114             syscall_fdc:
0403   0114 FD 0A 12 01   jmp [fdc_jmptbl + al]
0404   0118             
0405   0118             syscall_fdc_format:
0406   0118 FD 22 FF 00   mov g, $FF
0407   011C             fdc_wait_busy:
0408   011C 1D C8 FF      mov al, [_FDC_WD_STAT_CMD] ; read wd1770 status register
0409   011F 87 01         and al, $01                ; busy bit
0410   0121 C7 1C 01      jnz fdc_wait_busy
0411   0124             
0412   0124 FD 4D 97 18   mov si, fdc_40_FF
0413   0128 38 D1 00      mov c, 209
0414   012B             fdc_sector_loop:
0415   012B             fdc_drq_loop:
0416   012B 3B C1 FF      mov d, _FDC_STATUS_1
0417   012E 1E            mov al, [d]
0418   012F 87 01         and al, $01               ; check drq bit
0419   0131 C6 2B 01      jz fdc_drq_loop
0420   0134 F6            lodsb                     ; load format byte
0421   0135 3B CB FF      mov d, _FDC_WD_DATA       ; data register
0422   0138 3E            mov [d], al               ; send data byte to wd1770
0423   0139 7E            dec c
0424   013A C7 2B 01      jnz fdc_sector_loop
0425   013D 3B C8 18      mov d, fdc_sector
0426   0140 32            mov bl, [d]
0427   0141 FD 77         inc b
0428   0143 FD 3E         mov [d], bl
0429   0145 C1 0B         cmp bl, 11
0430   0147 C7 2B 01      jne fdc_sector_loop       ; continue formatting
0431   014A             
0432   014A             ; here all the sectors have been written. now fill in remaining od the sonze until wd1770 interrupts out
0433   014A             fdc_drq_loop_fill:
0434   014A 3B C1 FF      mov d, _FDC_STATUS_1
0435   014D 1E            mov al, [d]
0436   014E 87 01         and al, $01               ; check drq bit
0437   0150 C6 4A 01      jz fdc_drq_loop_fill
0438   0153 3B CB FF      mov d, _FDC_WD_DATA       ; data register
0439   0156 FD 12         mov a, g
0440   0158 3E            mov [d], al               ; send data byte to wd1770
0441   0159 0C            lodstat
0442   015A 1A            mov al, ah
0443   015B 87 01         and al, $01
0444   015D C6 4A 01      jz fdc_drq_loop_fill
0445   0160             
0446   0160 06            sysret
0447   0161             
0448   0161             
0449   0161             ; REBOOT SYSTEM
0450   0161             syscall_reboot:
0451   0161 FD D7 FF FF   push word $FFFF 
0452   0165 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0453   0168 FD D7 C0 01   push word BIOS_RESET_VECTOR    ; and then push RESET VECTOR of the shell to the stack
0454   016C 06            sysret
0455   016D             
0456   016D             ;------------------------------------------------------------------------------------------------------;;
0457   016D             ; switch to another process
0458   016D             ; inputs:
0459   016D             ; AL = new process number
0460   016D             ;------------------------------------------------------------------------------------------------------;;
0461   016D             syscall_resume_proc:
0462   016D FD 78         mov g, a                            ; save the process number
0463   016F 4B            pusha                               ; save all registers into kernel stack
0464   0170 22 00         mov ah, 0
0465   0172 1D 63 17      mov al, [active_proc_index]
0466   0175 FD 99         shl a              ; x2
0467   0177 B7 B2 0F      mov a, [proc_table_convert + a]     ; get process state start index
0468   017A 4F            mov di, a
0469   017B 48            mov a, sp
0470   017C 77            inc a
0471   017D 4D            mov si, a
0472   017E 38 14 00      mov c, 20
0473   0181 FD F5         rep movsb                           ; save process state!
0474   0183             ; restore kernel stack position to point before interrupt arrived
0475   0183 51 14 00      add sp, 20
0476   0186             ; now load the new process number!
0477   0186 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0478   0188 3D 63 17      mov [active_proc_index], al         ; set new active proc
0479   018B             ; calculate LUT entry for next process
0480   018B 22 00         mov ah, 0
0481   018D FD 99         shl a                               ; x2
0482   018F B7 B2 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0483   0192 4D            mov si, a                           ; source is proc state block
0484   0193 48            mov a, sp
0485   0194 5F 13 00      sub a, 19
0486   0197 4F            mov di, a                           ; destination is kernel stack
0487   0198             ; restore SP
0488   0198 7D            dec a
0489   0199 47            mov sp, a
0490   019A 38 14 00      mov c, 20
0491   019D FD F5         rep movsb
0492   019F             ; set VM process
0493   019F 1D 63 17      mov al, [active_proc_index]
0494   01A2 01            setptb
0495   01A3 4C            popa
0496   01A4 06            sysret
0497   01A5             
0498   01A5             syscall_list_procs:
0499   01A5 3B 8B 17      mov d, s_ps_header
0500   01A8 07 32 12      call _puts
0501   01AB 3B 1A 1C      mov d, proc_availab_table + 1
0502   01AE 38 01 00      mov c, 1
0503   01B1             list_procs_L0:  
0504   01B1 BD 01         cmp byte[d], 1
0505   01B3 C7 D7 01      jne list_procs_next
0506   01B6 2D            mov b, d
0507   01B7 61 19 1C      sub b, proc_availab_table
0508   01BA FD 9F 05      shl b, 5
0509   01BD DA            push d
0510   01BE D8            push b
0511   01BF 28            mov b, c
0512   01C0 07 D2 12      call print_u8x
0513   01C3 22 20         mov ah, ' '
0514   01C5 07 06 11      call _putchar
0515   01C8 07 06 11      call _putchar
0516   01CB E5            pop b
0517   01CC 74            mov d, b
0518   01CD 58 29 1C      add d, proc_names
0519   01D0 07 32 12      call _puts
0520   01D3 07 DF 11      call printnl
0521   01D6 E7            pop d
0522   01D7             list_procs_next:
0523   01D7 79            inc d
0524   01D8 78            inc c
0525   01D9 C2 09 00      cmp c, 9
0526   01DC C7 B1 01      jne list_procs_L0
0527   01DF             list_procs_end:
0528   01DF 06            sysret
0529   01E0             
0530   01E0             ; ------------------------------------------------------------------------------------------------------------------;
0531   01E0             ; Exceptions' Code Block
0532   01E0             ; ------------------------------------------------------------------------------------------------------------------;
0533   01E0             ; Privilege
0534   01E0             ; ------------------------------------------------------------------------------------------------------------------;
0535   01E0             trap_privilege:
0536   01E0 0A 61 01      jmp syscall_reboot
0537   01E3 DA            push d
0538   01E4 3B DA 17      mov d, s_priviledge
0539   01E7 07 32 12      call _puts
0540   01EA E7            pop d
0541   01EB 06            sysret
0542   01EC             
0543   01EC             ; ------------------------------------------------------------------------------------------------------------------;
0544   01EC             ; Breakpoint
0545   01EC             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0546   01EC             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0547   01EC             ; ------------------------------------------------------------------------------------------------------------------;
0548   01EC             syscall_break:
0549   01EC 4B            pusha
0550   01ED             syscall_break_prompt:
0551   01ED 3B A7 02      mov d, s_break1
0552   01F0 07 32 12      call _puts
0553   01F3 07 DF 11      call printnl
0554   01F6 07 34 13      call scan_u16d
0555   01F9 AF 00 00      cmp a, 0
0556   01FC C6 07 02      je syscall_break_regs
0557   01FF AF 01 00      cmp a, 1
0558   0202 C6 2A 02      je syscall_break_mem
0559   0205             syscall_break_end:  
0560   0205 4C            popa
0561   0206 06            sysret
0562   0207             syscall_break_regs:
0563   0207 48            mov a, sp
0564   0208 53 0E 00      add a, 14               ; back-track 7 registers
0565   020B 3C            mov d, a
0566   020C 3A 07         mov cl, 7
0567   020E             syscall_regs_L0:
0568   020E 2A            mov b, [d]
0569   020F FD AB         swp b
0570   0211 07 8E 12      call print_u16x         ; print register value
0571   0214 07 DF 11      call printnl
0572   0217 63 02 00      sub d, 2
0573   021A 71 01         sub cl, 1
0574   021C C3 00         cmp cl, 0
0575   021E C7 0E 02      jne syscall_regs_L0
0576   0221 0A ED 01      jmp syscall_break_prompt
0577   0224 07 DF 11      call printnl
0578   0227 0A ED 01      jmp syscall_break_prompt
0579   022A             syscall_break_mem:
0580   022A 07 DF 11      call printnl
0581   022D 07 B0 12      call scan_u16x
0582   0230 4D            mov si, a               ; data source from user space
0583   0231 FD 4F A9 24   mov di, scrap_sector    ; destination in kernel space
0584   0235 38 00 02      mov c, 512
0585   0238 04            load                    ; transfer data to kernel space!
0586   0239 3B A9 24      mov d, scrap_sector     ; dump pointer in d
0587   023C 38 00 00      mov c, 0
0588   023F             dump_loop:
0589   023F 84            mov al, cl
0590   0240 87 0F         and al, $0F
0591   0242 C6 90 02      jz print_base
0592   0245             back:
0593   0245 1E            mov al, [d]             ; read byte
0594   0246 2F            mov bl, al
0595   0247 07 D2 12      call print_u8x
0596   024A 10 00 20      mov a, $2000
0597   024D 05 03         syscall sys_io          ; space
0598   024F 84            mov al, cl
0599   0250 87 0F         and al, $0F
0600   0252 B9 0F         cmp al, $0F
0601   0254 C6 65 02      je print_ascii
0602   0257             back1:
0603   0257 79            inc d
0604   0258 78            inc c
0605   0259 C2 00 02      cmp c, 512
0606   025C C7 3F 02      jne dump_loop
0607   025F 07 DF 11      call printnl
0608   0262 0A ED 01      jmp syscall_break_prompt  ; go to syscall_break return point
0609   0265             print_ascii:
0610   0265 10 00 20      mov a, $2000
0611   0268 05 03         syscall sys_io
0612   026A 63 10 00      sub d, 16
0613   026D 26 10 00      mov b, 16
0614   0270             print_ascii_L:
0615   0270 79            inc d
0616   0271 1E            mov al, [d]               ; read byte
0617   0272 B9 20         cmp al, $20
0618   0274 C8 7C 02      jlu dot
0619   0277 B9 7E         cmp al, $7E
0620   0279 D0 84 02      jleu ascii
0621   027C             dot:
0622   027C 10 00 2E      mov a, $2E00
0623   027F 05 03         syscall sys_io
0624   0281 0A 89 02      jmp ascii_continue
0625   0284             ascii:
0626   0284 23            mov ah, al
0627   0285 19 00         mov al, 0
0628   0287 05 03         syscall sys_io
0629   0289             ascii_continue:
0630   0289 FD A9 70 02   loopb print_ascii_L
0631   028D 0A 57 02      jmp back1
0632   0290             print_base:
0633   0290 07 DF 11      call printnl
0634   0293 2D            mov b, d
0635   0294 61 A9 24      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0636   0297 07 8E 12      call print_u16x          ; display row
0637   029A 10 00 3A      mov a, $3A00
0638   029D 05 03         syscall sys_io
0639   029F 10 00 20      mov a, $2000
0640   02A2 05 03         syscall sys_io
0641   02A4 0A 45 02      jmp back
0642   02A7             
0643   02A7             s_break1:  
0644   02A7 0A 44 65 62   .db "\nDebugger entry point.\n"
0644   02AB 75 67 67 65 
0644   02AF 72 20 65 6E 
0644   02B3 74 72 79 20 
0644   02B7 70 6F 69 6E 
0644   02BB 74 2E 0A 
0645   02BE 30 2E 20 53   .db "0. Show Registers\n"
0645   02C2 68 6F 77 20 
0645   02C6 52 65 67 69 
0645   02CA 73 74 65 72 
0645   02CE 73 0A 
0646   02D0 31 2E 20 53   .db "1. Show 512B RAM block\n"
0646   02D4 68 6F 77 20 
0646   02D8 35 31 32 42 
0646   02DC 20 52 41 4D 
0646   02E0 20 62 6C 6F 
0646   02E4 63 6B 0A 
0647   02E7 32 2E 20 43   .db "2. Continue Execution", 0
0647   02EB 6F 6E 74 69 
0647   02EF 6E 75 65 20 
0647   02F3 45 78 65 63 
0647   02F7 75 74 69 6F 
0647   02FB 6E 00 
0648   02FD             
0649   02FD             ; ------------------------------------------------------------------------------------------------------------------;
0650   02FD             ; Divide by Zero
0651   02FD             ; ------------------------------------------------------------------------------------------------------------------;
0652   02FD             trap_div_zero:
0653   02FD D7            push a
0654   02FE DA            push d
0655   02FF E1            pushf
0656   0300 3B F1 17      mov d, s_divzero
0657   0303 07 32 12      call _puts
0658   0306 EE            popf
0659   0307 E7            pop d
0660   0308 E4            pop a
0661   0309 06            sysret ; enable interrupts
0662   030A             
0663   030A             ; ------------------------------------------------------------------------------------------------------------------;
0664   030A             ; Undefined Opcode
0665   030A             ; ------------------------------------------------------------------------------------------------------------------;
0666   030A             trap_undef_opcode:
0667   030A 06            sysret
0668   030B             
0669   030B             ; ------------------------------------------------------------------------------------------------------------------;
0670   030B             ; RTC Services Syscall
0671   030B             ; RTC I/O bank = FFA0 to FFAF
0672   030B             ; FFA0 to FFA7 is scratch RAM
0673   030B             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0674   030B             ; al = 0..6 -> get
0675   030B             ; al = 7..D -> set
0676   030B             ; ------------------------------------------------------------------------------------------------------------------;
0677   030B             syscall_rtc:
0678   030B DB            push al
0679   030C DA            push d
0680   030D B9 06         cmp al, 6
0681   030F D1 24 03      jgu syscall_rtc_set
0682   0312             syscall_rtc_get:
0683   0312 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0684   0314 22 FF         mov ah, $FF    
0685   0316 3C            mov d, a                ; get to FFA9 + offset
0686   0317 F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0687   031B 1E            mov al, [d]             ; get data
0688   031C F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0689   0320 23            mov ah, al
0690   0321 E7            pop d
0691   0322 E8            pop al
0692   0323 06            sysret
0693   0324             syscall_rtc_set:
0694   0324 DD            push bl
0695   0325 99            mov bl, ah              ; set data asIDE
0696   0326 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0697   0328 22 FF         mov ah, $FF    
0698   032A 3C            mov d, a                ; get to FFA9 + offset
0699   032B 1B            mov al, bl              ; get data back
0700   032C F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0701   0330 3E            mov [d], al             ; set data
0702   0331 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0703   0335 EA            pop bl
0704   0336 E7            pop d
0705   0337 E8            pop al
0706   0338 06            sysret
0707   0339             
0708   0339             datetime_serv_tbl:
0709   0339 41 03         .dw print_date
0710   033B B5 03         .dw set_date
0711   033D             syscall_datetime:
0712   033D FD 0A 39 03   jmp [datetime_serv_tbl + al]      
0713   0341             print_date:
0714   0341 10 00 0D      mov a, $0D00           ; print carriage return char
0715   0344 19 03         mov al, 3
0716   0346 05 01         syscall sys_rtc        ; get week
0717   0348 1A            mov al, ah
0718   0349 22 00         mov ah, 0
0719   034B FD 9D 02      shl a, 2          
0720   034E 3B 7B 18      mov d, s_week
0721   0351 59            add d, a
0722   0352 07 32 12      call _puts
0723   0355 10 00 20      mov a, $2000
0724   0358 05 03         syscall sys_io         ; display ' '
0725   035A 19 04         mov al, 4
0726   035C 05 01         syscall sys_rtc        ; get day
0727   035E 99            mov bl, ah
0728   035F 07 D2 12      call print_u8x
0729   0362 10 00 20      mov a, $2000
0730   0365 05 03         syscall sys_io         ; display ' '
0731   0367             ; there is a problem with the month displaying
0732   0367             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0733   0367             ; even though it is to be understood as BCD.
0734   0367             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0735   0367 19 05         mov al, 05
0736   0369 05 01         syscall sys_rtc        ; get month
0737   036B 1A            mov al, ah
0738   036C 22 00         mov ah, 0
0739   036E FD 9D 02      shl a, 2          
0740   0371 3B 47 18      mov d, s_months
0741   0374 59            add d, a
0742   0375 07 32 12      call _puts
0743   0378 10 00 20      mov a, $2000
0744   037B 05 03         syscall sys_io         ; display ' '
0745   037D 2E 20         mov bl, $20
0746   037F 07 D2 12      call print_u8x         ; print 20 for year prefix
0747   0382 19 06         mov al, 06
0748   0384 05 01         syscall sys_rtc        ; get year
0749   0386 99            mov bl, ah
0750   0387 07 D2 12      call print_u8x
0751   038A 10 00 20      mov a, $2000  
0752   038D 05 03         syscall sys_io         ; display ' '
0753   038F 19 02         mov al, 2
0754   0391 05 01         syscall sys_rtc        ; get hours
0755   0393 99            mov bl, ah
0756   0394 07 D2 12      call print_u8x
0757   0397 10 00 3A      mov a, $3A00    
0758   039A 05 03         syscall sys_io         ; display ':'
0759   039C 19 01         mov al, 01
0760   039E 05 01         syscall sys_rtc        ; get minutes
0761   03A0 99            mov bl, ah
0762   03A1 07 D2 12      call print_u8x
0763   03A4 10 00 3A      mov a, $3A00  
0764   03A7 05 03         syscall sys_io         ; display ':'
0765   03A9 19 00         mov al, 0
0766   03AB 05 01         syscall sys_rtc        ; get seconds
0767   03AD 99            mov bl, ah
0768   03AE 07 D2 12      call print_u8x
0769   03B1 07 DF 11      call printnl
0770   03B4 06            sysret
0771   03B5             set_date:
0772   03B5 3B 0C 18      mov d, s_set_year
0773   03B8 07 32 12      call _puts
0774   03BB 07 1D 13      call scan_u8x          ; read integer into A
0775   03BE FD 9D 08      shl a, 8               ; only AL used, move to AH
0776   03C1 19 0D         mov al, 0Dh            ; set RTC year
0777   03C3 05 01         syscall sys_rtc        ; set RTC
0778   03C5 3B 13 18      mov d, s_set_month
0779   03C8 07 32 12      call _puts
0780   03CB 07 1D 13      call scan_u8x          ; read integer into A
0781   03CE FD 9D 08      shl a, 8               ; only AL used, move to AH
0782   03D1 19 0C         mov al, 0Ch            ; set RTC month
0783   03D3 05 01         syscall sys_rtc        ; set RTC
0784   03D5 3B 1B 18      mov d, s_set_day
0785   03D8 07 32 12      call _puts
0786   03DB 07 1D 13      call scan_u8x          ; read integer into A
0787   03DE FD 9D 08      shl a, 8               ; only AL used, move to AH
0788   03E1 19 0B         mov al, 0Bh            ; set RTC month
0789   03E3 05 01         syscall sys_rtc        ; set RTC
0790   03E5 3B 21 18      mov d, s_set_week
0791   03E8 07 32 12      call _puts
0792   03EB 07 1D 13      call scan_u8x          ; read integer into A
0793   03EE FD 9D 08      shl a, 8               ; only AL used, move to AH
0794   03F1 19 0A         mov al, 0Ah            ; set RTC month
0795   03F3 05 01         syscall sys_rtc        ; set RTC
0796   03F5 3B 2B 18      mov d, s_set_hours
0797   03F8 07 32 12      call _puts
0798   03FB 07 1D 13      call scan_u8x          ; read integer into A
0799   03FE FD 9D 08      shl a, 8               ; only AL used, move to AH
0800   0401 19 09         mov al, 09h            ; set RTC month
0801   0403 05 01         syscall sys_rtc        ; set RTC
0802   0405 3B 33 18      mov d, s_set_minutes
0803   0408 07 32 12      call _puts
0804   040B 07 1D 13      call scan_u8x          ; read integer into A
0805   040E FD 9D 08      shl a, 8               ; only AL used, move to AH
0806   0411 19 08         mov al, 08h            ; set RTC month
0807   0413 05 01         syscall sys_rtc        ; set RTC
0808   0415 3B 3D 18      mov d, s_set_seconds
0809   0418 07 32 12      call _puts
0810   041B 07 1D 13      call scan_u8x          ; read integer into A
0811   041E FD 9D 08      shl a, 8               ; only AL used, move to AH
0812   0421 19 07         mov al, 07h            ; set RTC month
0813   0423 05 01         syscall sys_rtc        ; set RTC
0814   0425 06            sysret
0815   0426             
0816   0426             ; ------------------------------------------------------------------------------------------------------------------;
0817   0426             ; IDE Services Syscall
0818   0426             ; al = option
0819   0426             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0820   0426             ; IDE read/write sector
0821   0426             ; 512 bytes
0822   0426             ; User buffer pointer in D
0823   0426             ; AH = number of sectors
0824   0426             ; CB = LBA bytes 3..0
0825   0426             ; ------------------------------------------------------------------------------------------------------------------;
0826   0426 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0826   042A 73 63 61 6C 
0826   042E 6C 5F 69 64 
0826   0432 65 20 63 61 
0826   0436 6C 6C 65 64 
0826   043A 3A 20 00 
0827   043D             ide_serv_tbl:
0828   043D 64 04         .dw ide_reset
0829   043F 78 04         .dw ide_sleep
0830   0441 87 04         .dw ide_read_sect_wrapper
0831   0443 8B 04         .dw ide_write_sect_wrapper
0832   0445             syscall_ide:
0833   0445 DD            push bl
0834   0446 31 5B 17      mov bl, [sys_debug_mode]
0835   0449               ; debug block
0836   0449 C1 00         cmp bl, 0
0837   044B EA            pop bl
0838   044C C6 60 04      je syscall_ide_jmp
0839   044F DA            push d
0840   0450 DD            push bl
0841   0451 3B 26 04      mov d, s_syscall_ide_dbg0
0842   0454 07 32 12      call _puts
0843   0457 2F            mov bl, al
0844   0458 07 D2 12      call print_u8x
0845   045B 07 DF 11      call printnl
0846   045E EA            pop bl
0847   045F E7            pop d
0848   0460             syscall_ide_jmp:
0849   0460 FD 0A 3D 04   jmp [ide_serv_tbl + al]    
0850   0464               
0851   0464             ide_reset:      
0852   0464 F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0853   0468 07 11 05      call ide_wait                   ; wait for IDE ready             
0854   046B F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0855   046F F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0856   0473 F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0857   0477 06            sysret
0858   0478             ide_sleep:
0859   0478 07 11 05      call ide_wait                   ; wait for IDE ready             
0860   047B F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0861   047F F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0862   0483 07 11 05      call ide_wait                   ; wait for IDE ready
0863   0486 06            sysret
0864   0487             ide_read_sect_wrapper:
0865   0487 07 8F 04      call ide_read_sect
0866   048A 06            sysret
0867   048B             ide_write_sect_wrapper:
0868   048B 07 B5 04      call ide_write_sect
0869   048E 06            sysret
0870   048F             ide_read_sect:
0871   048F 1A            mov al, ah
0872   0490 24            mov ah, bl
0873   0491 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0874   0494 1C            mov al, bh
0875   0495 3D D4 FF      mov [_ide_R4], al
0876   0498 12            mov a, c
0877   0499 3D D5 FF      mov [_ide_R5], al
0878   049C 1A            mov al, ah
0879   049D 87 0F         and al, %00001111
0880   049F 8B E0         or al, %11100000                ; mode lba, master
0881   04A1 3D D6 FF      mov [_ide_R6], al
0882   04A4             ide_read_sect_wait:
0883   04A4 1D D7 FF      mov al, [_ide_R7]  
0884   04A7 87 80         and al, $80                     ; BUSY FLAG
0885   04A9 C7 A4 04      jnz ide_read_sect_wait
0886   04AC 19 20         mov al, $20
0887   04AE 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0888   04B1 07 DB 04      call ide_read  
0889   04B4 09            ret
0890   04B5             ide_write_sect:
0891   04B5 1A            mov al, ah
0892   04B6 24            mov ah, bl
0893   04B7 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0894   04BA 1C            mov al, bh
0895   04BB 3D D4 FF      mov [_ide_R4], al
0896   04BE 12            mov a, c
0897   04BF 3D D5 FF      mov [_ide_R5], al
0898   04C2 1A            mov al, ah
0899   04C3 87 0F         and al, %00001111
0900   04C5 8B E0         or al, %11100000                ; mode lba, master
0901   04C7 3D D6 FF      mov [_ide_R6], al
0902   04CA             ide_write_sect_wait:
0903   04CA 1D D7 FF      mov al, [_ide_R7]  
0904   04CD 87 80         and al, $80                     ; BUSY FLAG
0905   04CF C7 CA 04      jnz ide_write_sect_wait
0906   04D2 19 30         mov al, $30
0907   04D4 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0908   04D7 07 F6 04      call ide_write      
0909   04DA 09            ret
0910   04DB             
0911   04DB             ;----------------------------------------------------------------------------------------------------;
0912   04DB             ; READ IDE DATA
0913   04DB             ; pointer in D
0914   04DB             ;----------------------------------------------------------------------------------------------------;
0915   04DB             ide_read:
0916   04DB DA            push d
0917   04DC             ide_read_loop:
0918   04DC 1D D7 FF      mov al, [_ide_R7]  
0919   04DF 87 80         and al, 80h                     ; BUSY FLAG
0920   04E1 C7 DC 04      jnz ide_read_loop               ; wait loop
0921   04E4 1D D7 FF      mov al, [_ide_R7]
0922   04E7 87 08         and al, %00001000               ; DRQ FLAG
0923   04E9 C6 F4 04      jz ide_read_end
0924   04EC 1D D0 FF      mov al, [_ide_R0]
0925   04EF 3E            mov [d], al
0926   04F0 79            inc d
0927   04F1 0A DC 04      jmp ide_read_loop
0928   04F4             ide_read_end:
0929   04F4 E7            pop d
0930   04F5 09            ret
0931   04F6             
0932   04F6             ;----------------------------------------------------------------------------------------------------;
0933   04F6             ; WRITE IDE DATA
0934   04F6             ; data pointer in D
0935   04F6             ;----------------------------------------------------------------------------------------------------;
0936   04F6             ide_write:
0937   04F6 DA            push d
0938   04F7             ide_write_loop:
0939   04F7 1D D7 FF      mov al, [_ide_R7]  
0940   04FA 87 80         and al, 80h             ; BUSY FLAG
0941   04FC C7 F7 04      jnz ide_write_loop      ; wait loop
0942   04FF 1D D7 FF      mov al, [_ide_R7]
0943   0502 87 08         and al, %00001000       ; DRQ FLAG
0944   0504 C6 0F 05      jz ide_write_end
0945   0507 1E            mov al, [d]
0946   0508 3D D0 FF      mov [_ide_R0], al
0947   050B 79            inc d 
0948   050C 0A F7 04      jmp ide_write_loop
0949   050F             ide_write_end:
0950   050F E7            pop d
0951   0510 09            ret
0952   0511             
0953   0511             ;----------------------------------------------------------------------------------------------------;
0954   0511             ; wait for IDE to be ready
0955   0511             ;----------------------------------------------------------------------------------------------------;
0956   0511             ide_wait:
0957   0511 1D D7 FF      mov al, [_ide_R7]  
0958   0514 87 80         and al, 80h        ; BUSY FLAG
0959   0516 C7 11 05      jnz ide_wait
0960   0519 09            ret
0961   051A             
0962   051A             ;----------------------------------------------------------------------------------------------------;
0963   051A             ; IO Syscall
0964   051A             ;----------------------------------------------------------------------------------------------------;
0965   051A             ; Baud  Divisor
0966   051A             ; 50    2304
0967   051A             ; 110   1047
0968   051A             ; 300    384
0969   051A             ; 600    192
0970   051A             ; 1200    96
0971   051A             ; 9600    12
0972   051A             ; 19200    6
0973   051A             ; 38400    3
0974   051A             syscall_io_jmp:
0975   051A 4D 05         .dw syscall_io_putchar
0976   051C 5A 05         .dw syscall_io_getch
0977   051E 24 05         .dw syscall_io_uart_setup
0978   0520             syscall_io:
0979   0520 FD 0A 1A 05   jmp [syscall_io_jmp + al]
0980   0524             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0981   0524             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0982   0524             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0983   0524             syscall_io_uart_setup:
0984   0524 1D 5D 17      mov al, [sys_uart0_lcr]
0985   0527 8B 80         or al, $80                ; set DLAB access bit
0986   0529 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0987   052C 1D 60 17      mov al, [sys_uart0_div0]
0988   052F 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0989   0532 1D 61 17      mov al, [sys_uart0_div1]
0990   0535 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0991   0538             
0992   0538 1D 5D 17      mov al, [sys_uart0_lcr]
0993   053B 87 7F         and al, $7F               ; clear DLAB access bit 
0994   053D 3D 83 FF      mov [_UART0_LCR], al
0995   0540 1D 5E 17      mov al, [sys_uart0_inten]
0996   0543 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0997   0546 1D 5F 17      mov al, [sys_uart0_fifoen]
0998   0549 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0999   054C 06            sysret
1000   054D             
1001   054D             ; char in ah
1002   054D             syscall_io_putchar:
1003   054D             syscall_io_putchar_L0:
1004   054D 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1005   0550 87 20         and al, $20
1006   0552 C6 4D 05      jz syscall_io_putchar_L0    
1007   0555 1A            mov al, ah
1008   0556 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1009   0559 06            sysret
1010   055A             
1011   055A             ; char in ah
1012   055A             ; al = sucess code
1013   055A             syscall_io_getch:
1014   055A D8            push b
1015   055B DA            push d
1016   055C FD 0C         sti
1017   055E             syscall_io_getch_L0:  
1018   055E 14 6A 17      mov a, [fifo_out]
1019   0561 29 68 17      mov b, [fifo_in]
1020   0564 B0            cmp a, b
1021   0565 C6 5E 05      je syscall_io_getch_L0
1022   0568 3C            mov d, a
1023   0569 77            inc a
1024   056A AF A9 24      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
1025   056D C7 73 05      jne syscall_io_getch_cont
1026   0570 10 A9 20      mov a, fifo  
1027   0573             syscall_io_getch_cont:  
1028   0573 42 6A 17      mov [fifo_out], a             ; update fifo pointer
1029   0576 1E            mov al, [d]                   ; get char
1030   0577 23            mov ah, al
1031   0578 1D 5C 17      mov al, [sys_echo_on]
1032   057B B9 01         cmp al, 1
1033   057D C7 8C 05      jne syscall_io_getch_noecho 
1034   0580             ; here we just echo the char back to the console
1035   0580             syscall_io_getch_echo_L0:
1036   0580 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1037   0583 87 20         and al, $20                 ; isolate Transmitter Empty
1038   0585 C6 80 05      jz syscall_io_getch_echo_L0
1039   0588 1A            mov al, ah
1040   0589 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1041   058C             syscall_io_getch_noecho:
1042   058C 19 01         mov al, 1                    ; AL = 1 means a char successfully received
1043   058E E7            pop d
1044   058F E5            pop b
1045   0590 06            sysret
1046   0591             
1047   0591             ;------------------------------------------------------------------------------------------------------;
1048   0591             ; FILE SYSTEM DATA
1049   0591             ;------------------------------------------------------------------------------------------------------;
1050   0591             ; infor for : IDE SERVICES INTERRUPT
1051   0591             ; IDE read/write 512-byte sector
1052   0591             ; al = option
1053   0591             ; user buffer pointer in D
1054   0591             ; AH = number of sectors
1055   0591             ; CB = LBA bytes 3..0  
1056   0591             ;------------------------------------------------------------------------------------------------------;
1057   0591             ; FILE SYSTEM DATA STRUCTURE
1058   0591             ;------------------------------------------------------------------------------------------------------;
1059   0591             ; for a directory we have the header first, followed by metadata
1060   0591             ; header 1 sector (512 bytes)
1061   0591             ; metadata 1 sector (512 bytes)
1062   0591             ; HEADER ENTRIES:
1063   0591             ; filename (64)
1064   0591             ; parent dir LBA (2) -  to be used for faster backwards navigation...
1065   0591             ;
1066   0591             ; metadata entries:
1067   0591             ; filename (24)
1068   0591             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1069   0591             ; LBA (2)
1070   0591             ; size (2)
1071   0591             ; day (1)
1072   0591             ; month (1)
1073   0591             ; year (1)
1074   0591             ; packet size = 32 bytes
1075   0591             ;
1076   0591             ; first directory on disk is the root directory '/'
1077   0591             file_system_jmptbl:
1078   0591 FC 05         .dw fs_mkfs                   ; 0
1079   0593 00 00         .dw 0                         ; 1
1080   0595 5E 06         .dw fs_mkdir                  ; 2
1081   0597 D7 09         .dw fs_cd                     ; 3
1082   0599 DE 09         .dw fs_ls                     ; 4
1083   059B 54 0B         .dw fs_mktxt                  ; 5
1084   059D 1F 0C         .dw fs_mkbin                  ; 6
1085   059F E6 0C         .dw fs_pwd                    ; 7
1086   05A1 03 0D         .dw fs_cat                    ; 8
1087   05A3 5F 0D         .dw fs_rmdir                  ; 9
1088   05A5 BB 0D         .dw fs_rm                     ; 10
1089   05A7 AF 0A         .dw fs_starcom                ; 11
1090   05A9 00 00         .dw 0                         ; 12
1091   05AB 00 00         .dw 0                         ; 13
1092   05AD 04 06         .dw fs_chmod                  ; 14
1093   05AF 23 0E         .dw fs_mv                     ; 15
1094   05B1 FD 05         .dw fs_cd_root                ; 16
1095   05B3 D3 09         .dw fs_get_curr_dirID         ; 17
1096   05B5 AF 07         .dw fs_dir_id_to_path         ; 18
1097   05B7 15 08         .dw fs_path_to_dir_id_user    ; 19
1098   05B9 2F 09         .dw fs_load_from_path_user    ; 20  
1099   05BB 9F 08         .dw fs_filepath_exists_user   ; 21
1100   05BD             
1101   05BD 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1101   05C1 79 73 63 61 
1101   05C5 6C 6C 5F 66 
1101   05C9 69 6C 65 5F 
1101   05CD 73 79 73 74 
1101   05D1 65 6D 20 63 
1101   05D5 61 6C 6C 65 
1101   05D9 64 3A 20 00 
1102   05DD             syscall_file_system:
1103   05DD DD            push bl
1104   05DE 31 5B 17      mov bl, [sys_debug_mode]
1105   05E1               ; debug block
1106   05E1 C1 00         cmp bl, 0
1107   05E3 EA            pop bl
1108   05E4 C6 F8 05      je syscall_filesystem_jmp
1109   05E7 DA            push d
1110   05E8 DD            push bl
1111   05E9 3B BD 05      mov d, s_syscall_fs_dbg0
1112   05EC 07 32 12      call _puts
1113   05EF 2F            mov bl, al
1114   05F0 07 D2 12      call print_u8x
1115   05F3 07 DF 11      call printnl
1116   05F6 EA            pop bl
1117   05F7 E7            pop d
1118   05F8             syscall_filesystem_jmp:
1119   05F8 FD 0A 91 05   jmp [file_system_jmptbl + al]
1120   05FC             
1121   05FC             fs_mkfs:  
1122   05FC 06            sysret  
1123   05FD               
1124   05FD             fs_cd_root:
1125   05FD 10 20 00      mov a, root_id
1126   0600 42 6C 17      mov [current_dir_id], a      ; set current directory LBA to ROOT
1127   0603 06            sysret  
1128   0604             
1129   0604             ; filename in D (userspace data)
1130   0604             ; permission in BL
1131   0604             fs_chmod:
1132   0604 DD            push bl
1133   0605 FD 4E         mov si, d
1134   0607 FD 4F A9 1E   mov di, user_data
1135   060B 38 80 00      mov c, 128
1136   060E 04            load                        ; load filename from user-space
1137   060F 14 6C 17      mov a, [current_dir_id]
1138   0612 77            inc a                       ; metadata sector
1139   0613 27            mov b, a
1140   0614 38 00 00      mov c, 0                    ; upper LBA = 0
1141   0617 22 01         mov ah, $01                  ; 1 sector
1142   0619 3B A9 26      mov d, transient_area
1143   061C 07 8F 04      call ide_read_sect          ; read directory
1144   061F FD 10         cla
1145   0621 42 64 17      mov [index], a              ; reset file counter
1146   0624             fs_chmod_L1:
1147   0624 FD 4E         mov si, d
1148   0626 FD 4F A9 1E   mov di, user_data
1149   062A 07 75 10      call _strcmp
1150   062D C6 44 06      je fs_chmod_found_entry
1151   0630 58 20 00      add d, 32
1152   0633 14 64 17      mov a, [index]
1153   0636 77            inc a
1154   0637 42 64 17      mov [index], a
1155   063A AF 10 00      cmp a, FST_FILES_PER_DIR
1156   063D C7 24 06      jne fs_chmod_L1
1157   0640 EA            pop bl
1158   0641 0A 5D 06      jmp fs_chmod_not_found
1159   0644             fs_chmod_found_entry:  
1160   0644 FD 79         mov g, b                    ; save LBA
1161   0646 EA            pop bl                      ; retrieve saved permission value
1162   0647 1F 18 00      mov al, [d + 24]            ; read file permissions
1163   064A 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1164   064C 8C            or al, bl                   ; set new permissions
1165   064D 3F 18 00      mov [d + 24], al            ; write new permissions
1166   0650 38 00 00      mov c, 0
1167   0653 3B A9 26      mov d, transient_area
1168   0656 22 01         mov ah, $01                 ; disk write 1 sect
1169   0658 FD 27         mov b, g                    ; retrieve LBA
1170   065A 07 B5 04      call ide_write_sect         ; write sector
1171   065D             fs_chmod_not_found:
1172   065D 06            sysret
1173   065E             
1174   065E             ;------------------------------------------------------------------------------------------------------;
1175   065E             ; CREATE NEW DIRECTORY
1176   065E             ;------------------------------------------------------------------------------------------------------;
1177   065E             ; search list for NULL name entry. add new directory to list
1178   065E             fs_mkdir:
1179   065E FD 4E         mov si, d
1180   0660 FD 4F A9 1E   mov di, user_data
1181   0664 38 00 02      mov c, 512
1182   0667 04            load                        ; load data from user-space
1183   0668 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1184   066B                                           ; when checking for NULL name, since root has a NULL name)
1185   066B 38 00 00      mov c, 0                    ; upper LBA = 0
1186   066E             fs_mkdir_L1:  
1187   066E 22 01         mov ah, $01                  ; 1 sector
1188   0670 3B A9 26      mov d, transient_area
1189   0673 07 8F 04      call ide_read_sect          ; read sector
1190   0676 BD 00         cmp byte[d], 0              ; check for NULL
1191   0678 C6 81 06      je fs_mkdir_found_null
1192   067B 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1193   067E 0A 6E 06      jmp fs_mkdir_L1
1194   0681             fs_mkdir_found_null:
1195   0681             ;create header file by grabbing dir name from parameter
1196   0681 D8            push b                      ; save new directory's LBA
1197   0682 38 40 00      mov c, 64
1198   0685 FD 4D A9 1E   mov si, user_data
1199   0689 FD 4F A9 26   mov di, transient_area
1200   068D FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1201   068F 14 6C 17      mov a, [current_dir_id]
1202   0692 42 E9 26      mov [transient_area + 64], a    ; store parent directory LBA
1203   0695 19 00         mov al, 0
1204   0697 FD 4F A9 28   mov di, transient_area + 512
1205   069B 38 00 02      mov c, 512
1206   069E FD F7         rep stosb                       ; clean buffer
1207   06A0 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1208   06A3             ; write directory entry sectors
1209   06A3 3B A9 26      mov d, transient_area
1210   06A6 22 02         mov ah, $02                     ; disk write, 2 sectors
1211   06A8 07 B5 04      call ide_write_sect             ; write sector
1212   06AB             ; now we need to add the new directory to the list, insIDE the current directory
1213   06AB 14 6C 17      mov a, [current_dir_id]
1214   06AE 53 01 00      add a, 1
1215   06B1 27            mov b, a                        ; metadata sector
1216   06B2 38 00 00      mov c, 0
1217   06B5 FD 79         mov g, b                        ; save LBA
1218   06B7 3B A9 26      mov d, transient_area
1219   06BA 22 01         mov ah, $01                  ; 1 sector
1220   06BC 07 8F 04      call ide_read_sect              ; read metadata sector
1221   06BF             fs_mkdir_L2:
1222   06BF BD 00         cmp byte[d], 0
1223   06C1 C6 CA 06      je fs_mkdir_found_null2
1224   06C4 58 20 00      add d, FST_ENTRY_SIZE
1225   06C7 0A BF 06      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1226   06CA             fs_mkdir_found_null2:
1227   06CA FD 4D A9 1E   mov si, user_data
1228   06CE FD 50         mov di, d
1229   06D0 07 8A 10      call _strcpy                    ; copy directory name
1230   06D3 58 18 00      add d, 24                       ; goto ATTRIBUTES
1231   06D6 19 0B         mov al, %00001011               ; directory, no execute, write, read
1232   06D8 3E            mov [d], al      
1233   06D9 79            inc d
1234   06DA E5            pop b
1235   06DB D8            push b                          ; push LBA back
1236   06DC FD 43         mov [d], b                      ; save LBA
1237   06DE             ; set file creation date  
1238   06DE 58 04 00      add d, 4
1239   06E1 19 04         mov al, 4
1240   06E3 05 01         syscall sys_rtc
1241   06E5 1A            mov al, ah
1242   06E6 3E            mov [d], al                     ; set day
1243   06E7 79            inc d
1244   06E8 19 05         mov al, 5
1245   06EA 05 01         syscall sys_rtc
1246   06EC 1A            mov al, ah
1247   06ED 3E            mov [d], al                     ; set month
1248   06EE 79            inc d
1249   06EF 19 06         mov al, 6
1250   06F1 05 01         syscall sys_rtc
1251   06F3 1A            mov al, ah
1252   06F4 3E            mov [d], al                     ; set year
1253   06F5             ; write sector into disk for new directory entry
1254   06F5 FD 27         mov b, g
1255   06F7 38 00 00      mov c, 0
1256   06FA 3B A9 26      mov d, transient_area
1257   06FD 22 01         mov ah, $01                     ; disk write, 1 sector
1258   06FF 07 B5 04      call ide_write_sect             ; write sector
1259   0702             
1260   0702             ; after adding the new directory's information to its parent directory's list
1261   0702             ; we need to now enter the new directory, and to it add two new directories!
1262   0702             ; which directories do we need to add ? '..' and '.' are the directories needed.
1263   0702             ; importantly, note that these two new directories are only entries in the list
1264   0702             ; and do not have actual physical entries in the disk as real directories.
1265   0702             ; i.e. they only exist as list entries in the new directory created so that
1266   0702             ; the new directory can reference its parent and itself.
1267   0702             ; We need to add both '..' and '.'
1268   0702             ; this first section is for '..' and on the section below we do the same for '.'
1269   0702 E4            pop a                         ; retrieve the new directory's LBA  
1270   0703 D7            push a                        ; and save again
1271   0704 53 01 00      add a, 1
1272   0707 27            mov b, a                      ; metadata sector
1273   0708 38 00 00      mov c, 0
1274   070B FD 79         mov g, b                      ; save LBA
1275   070D 3B A9 26      mov d, transient_area
1276   0710 22 01         mov ah, $01                  ; 1 sector
1277   0712 07 8F 04      call ide_read_sect            ; read metadata sector
1278   0715             fs_mkdir_L3:
1279   0715 BD 00         cmp byte[d], 0
1280   0717 C6 20 07      je fs_mkdir_found_null3
1281   071A 58 20 00      add d, FST_ENTRY_SIZE
1282   071D 0A 15 07      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1283   0720             fs_mkdir_found_null3:
1284   0720 FD 4D 7C 17   mov si, s_parent_dir
1285   0724 FD 50         mov di, d
1286   0726 07 8A 10      call _strcpy                  ; copy directory name
1287   0729 58 18 00      add d, 24                     ; goto ATTRIBUTES
1288   072C 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1289   072E 3E            mov [d], al      
1290   072F 79            inc d
1291   0730 29 6C 17      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1292   0733 FD 43         mov [d], b                    ; save LBA
1293   0735             ; set file creation date  
1294   0735 58 04 00      add d, 4
1295   0738 19 04         mov al, 4
1296   073A 05 01         syscall sys_rtc
1297   073C 1A            mov al, ah
1298   073D 3E            mov [d], al                   ; set day
1299   073E 79            inc d
1300   073F 19 05         mov al, 5
1301   0741 05 01         syscall sys_rtc
1302   0743 1A            mov al, ah
1303   0744 3E            mov [d], al                   ; set month
1304   0745 79            inc d
1305   0746 19 06         mov al, 6
1306   0748 05 01         syscall sys_rtc
1307   074A 1A            mov al, ah
1308   074B 3E            mov [d], al                   ; set year
1309   074C             ; write sector into disk for new directory entry
1310   074C FD 27         mov b, g
1311   074E 38 00 00      mov c, 0
1312   0751 3B A9 26      mov d, transient_area
1313   0754 22 01         mov ah, $01                   ; disk write, 1 sector
1314   0756 07 B5 04      call ide_write_sect           ; write sector
1315   0759             ;;;;;;;;;;;;;
1316   0759             ; like we did above for '..', we need to now add the '.' directory to the list.
1317   0759             ;------------------------------------------------------------------------------------------------------;
1318   0759 E4            pop a                         ; retrieve the new directory's LBA  
1319   075A D7            push a
1320   075B 53 01 00      add a, 1
1321   075E 27            mov b, a                      ; metadata sector
1322   075F 38 00 00      mov c, 0
1323   0762 FD 79         mov g, b                      ; save LBA
1324   0764 3B A9 26      mov d, transient_area
1325   0767 22 01         mov ah, $01                  ; 1 sector
1326   0769 07 8F 04      call ide_read_sect            ; read metadata sector
1327   076C             fs_mkdir_L4:
1328   076C BD 00         cmp byte[d], 0
1329   076E C6 77 07      je fs_mkdir_found_null4
1330   0771 58 20 00      add d, FST_ENTRY_SIZE
1331   0774 0A 6C 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1332   0777             fs_mkdir_found_null4:
1333   0777 FD 4D 7F 17   mov si, s_current_dir
1334   077B FD 50         mov di, d
1335   077D 07 8A 10      call _strcpy                  ; copy directory name
1336   0780 58 18 00      add d, 24                     ; goto ATTRIBUTES
1337   0783 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1338   0785 3E            mov [d], al      
1339   0786 79            inc d
1340   0787 E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1341   0788 FD 43         mov [d], b                    ; save LBA
1342   078A             ; set file creation date  
1343   078A 58 04 00      add d, 4
1344   078D 19 04         mov al, 4
1345   078F 05 01         syscall sys_rtc
1346   0791 1A            mov al, ah
1347   0792 3E            mov [d], al                   ; set day
1348   0793 79            inc d
1349   0794 19 05         mov al, 5
1350   0796 05 01         syscall sys_rtc
1351   0798 1A            mov al, ah
1352   0799 3E            mov [d], al                   ; set month
1353   079A 79            inc d
1354   079B 19 06         mov al, 6
1355   079D 05 01         syscall sys_rtc
1356   079F 1A            mov al, ah
1357   07A0 3E            mov [d], al                   ; set year
1358   07A1             ; write sector into disk for new directory entry
1359   07A1 FD 27         mov b, g
1360   07A3 38 00 00      mov c, 0
1361   07A6 3B A9 26      mov d, transient_area
1362   07A9 22 01         mov ah, $01                   ; disk write, 1 sector
1363   07AB 07 B5 04      call ide_write_sect           ; write sector
1364   07AE             fs_mkdir_end:
1365   07AE 06            sysret
1366   07AF             
1367   07AF             ;------------------------------------------------------------------------------------------------------;
1368   07AF             ; get path from a given directory dirID
1369   07AF             ; pseudo code:
1370   07AF             ;  fs_dir_id_to_path(int dirID, char *D){
1371   07AF             ;    if(dirID == 0){
1372   07AF             ;      reverse path in D;
1373   07AF             ;      return;
1374   07AF             ;    }
1375   07AF             ;    else{
1376   07AF             ;      copy directory name to end of D;
1377   07AF             ;      add '/' to end of D;
1378   07AF             ;      parentID = get parent directory ID;
1379   07AF             ;      fs_dir_id_to_path(parentID, D);
1380   07AF             ;    }
1381   07AF             ;  }
1382   07AF             ; A = dirID
1383   07AF             ; D = generated path string pointer
1384   07AF             ;------------------------------------------------------------------------------------------------------;
1385   07AF             ; sample path: /usr/bin
1386   07AF             fs_dir_id_to_path:
1387   07AF 3B 29 1E      mov d, filename
1388   07B2 19 00         mov al, 0
1389   07B4 3E            mov [d], al                     ; initialize path string 
1390   07B5 14 6C 17      mov a, [current_dir_id]
1391   07B8 07 C5 07      call fs_dir_id_to_path_E0
1392   07BB 3B 29 1E      mov d, filename
1393   07BE 07 1E 10      call _strrev
1394   07C1 07 32 12      call _puts
1395   07C4 06            sysret
1396   07C5             fs_dir_id_to_path_E0:
1397   07C5 07 E4 07      call get_dirname_from_dirID
1398   07C8 FD 4D 81 17   mov si, s_fslash
1399   07CC FD 50         mov di, d
1400   07CE 07 98 10      call _strcat                    ; add '/' to end of path
1401   07D1 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1402   07D4 C6 E3 07      je fs_dir_id_to_path_root
1403   07D7 07 01 08      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1404   07DA AF 20 00      cmp a, root_id               ; check if we are at the root directory
1405   07DD C6 E3 07      je fs_dir_id_to_path_root
1406   07E0 07 C5 07      call fs_dir_id_to_path_E0     ; recursively call itself
1407   07E3             fs_dir_id_to_path_root:
1408   07E3 09            ret
1409   07E4             
1410   07E4             ;------------------------------------------------------------------------------------------------------;
1411   07E4             ; in_puts:
1412   07E4             ; A = directory ID
1413   07E4             ; out_puts:
1414   07E4             ; D = pointer to directory name string
1415   07E4             ;------------------------------------------------------------------------------------------------------;
1416   07E4             get_dirname_from_dirID:
1417   07E4 D7            push a
1418   07E5 D8            push b
1419   07E6 DA            push d
1420   07E7 27            mov b, a
1421   07E8 38 00 00      mov c, 0                      ; upper LBA = 0
1422   07EB 22 01         mov ah, $01                  ; 1 sector
1423   07ED 3B A9 24      mov d, transient_area - 512
1424   07F0 07 8F 04      call ide_read_sect            ; read directory
1425   07F3 07 1E 10      call _strrev                  ; reverse dir name before copying
1426   07F6 FD 4E         mov si, d
1427   07F8 E7            pop d                         ; destination address = D value pushed at beginning
1428   07F9 FD 50         mov di, d
1429   07FB 07 98 10      call _strcat                  ; copy filename to D
1430   07FE E5            pop b
1431   07FF E4            pop a
1432   0800 09            ret
1433   0801             
1434   0801             ;------------------------------------------------------------------------------------------------------;
1435   0801             ; in_puts:
1436   0801             ; A = directory ID
1437   0801             ; out_puts:
1438   0801             ; A = parent directory ID
1439   0801             ;------------------------------------------------------------------------------------------------------;
1440   0801             get_parentID_from_dirID:
1441   0801 D8            push b
1442   0802 DA            push d
1443   0803 27            mov b, a
1444   0804 38 00 00      mov c, 0                      ; upper LBA = 0
1445   0807 22 01         mov ah, $01                  ; 1 sector
1446   0809 3B A9 24      mov d, transient_area - 512
1447   080C 07 8F 04      call ide_read_sect            ; read directory
1448   080F 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1449   0812 E7            pop d
1450   0813 E5            pop b
1451   0814 09            ret
1452   0815             
1453   0815             ;------------------------------------------------------------------------------------------------------;
1454   0815             ; get dirID from a given path string
1455   0815             ; in_puts:
1456   0815             ; D = path pointer 
1457   0815             ; out_puts:
1458   0815             ; A = dirID
1459   0815             ; if dir non existent, A = FFFF (fail code)
1460   0815             ; /usr/local/bin    - absolute
1461   0815             ; local/bin/games    - relative
1462   0815             ;------------------------------------------------------------------------------------------------------;
1463   0815             fs_path_to_dir_id_user:
1464   0815 FD 4E         mov si, d
1465   0817 FD 4F A9 1E   mov di, user_data
1466   081B 38 00 02      mov c, 512
1467   081E 04            load
1468   081F 07 23 08      call get_dirID_from_path
1469   0822 06            sysret
1470   0823             get_dirID_from_path:
1471   0823 26 A9 1E      mov b, user_data
1472   0826 FD 42 57 16   mov [prog], b                  ; token pointer set to path string
1473   082A 07 B8 14      call get_token
1474   082D 31 5A 16      mov bl, [tok]
1475   0830 C1 01         cmp bl, TOK_FSLASH
1476   0832 C6 3E 08      je get_dirID_from_path_abs 
1477   0835 14 6C 17      mov a, [current_dir_id]
1478   0838 07 3E 16      call _putback
1479   083B 0A 41 08      jmp get_dirID_from_path_E0
1480   083E             get_dirID_from_path_abs:
1481   083E 10 20 00      mov a, root_id
1482   0841             get_dirID_from_path_E0:
1483   0841 07 B8 14      call get_token
1484   0844 31 59 16      mov bl, [toktyp]
1485   0847 C1 00         cmp bl, TOKTYP_IDENTIFIER
1486   0849 C7 9A 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1487   084C             
1488   084C FD 4D 5B 16   mov si, tokstr
1489   0850 FD 4F 29 1E   mov di, filename
1490   0854 07 8A 10      call _strcpy        
1491   0857 77            inc a                         ; metadata sector
1492   0858 27            mov b, a
1493   0859 38 00 00      mov c, 0                      ; upper LBA = 0
1494   085C 22 01         mov ah, $01                  ; 1 sector
1495   085E 3B A9 26      mov d, transient_area
1496   0861 07 8F 04      call ide_read_sect            ; read directory
1497   0864 FD 10         cla
1498   0866 42 64 17      mov [index], a
1499   0869             get_dirID_from_path_L1:
1500   0869 FD 4E         mov si, d
1501   086B FD 4F 29 1E   mov di, filename
1502   086F 07 75 10      call _strcmp
1503   0872 C6 88 08      je get_dirID_from_path_name_equal  
1504   0875 58 20 00      add d, 32
1505   0878 14 64 17      mov a, [index]
1506   087B 77            inc a
1507   087C 42 64 17      mov [index], a
1508   087F AF 10 00      cmp a, FST_FILES_PER_DIR
1509   0882 C6 9B 08      je get_dirID_from_path_fail
1510   0885 0A 69 08      jmp get_dirID_from_path_L1
1511   0888             get_dirID_from_path_name_equal:
1512   0888 58 19 00      add d, 25           
1513   088B 15            mov a, [d]                    ; set result register A = dirID
1514   088C 07 B8 14      call get_token
1515   088F 31 5A 16      mov bl, [tok]
1516   0892 C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1517   0894 C6 41 08      je get_dirID_from_path_E0
1518   0897 07 3E 16      call _putback
1519   089A             get_dirID_from_path_end:
1520   089A 09            ret
1521   089B             get_dirID_from_path_fail:
1522   089B 10 FF FF      mov A, $FFFF
1523   089E 09            ret
1524   089F             
1525   089F             
1526   089F             ;------------------------------------------------------------------------------------------------------;
1527   089F             ; check if file exists by a given path string
1528   089F             ; in_puts:
1529   089F             ; D = path pointer 
1530   089F             ; OUTPUTS:
1531   089F             ; A = success code, if file exists gives LBA, else, give 0
1532   089F             ; /usr/local/bin/ed
1533   089F             ;------------------------------------------------------------------------------------------------------;
1534   089F             fs_filepath_exists_user:
1535   089F FD 4E         mov si, d
1536   08A1 FD 4F A9 1E   mov di, user_data
1537   08A5 38 00 02      mov c, 512
1538   08A8 04            load
1539   08A9 07 AD 08      call file_exists_by_path
1540   08AC 06            sysret
1541   08AD             file_exists_by_path:
1542   08AD 26 A9 1E      mov b, user_data
1543   08B0 FD 42 57 16   mov [prog], b                   ; token pointer set to path string
1544   08B4 07 B8 14      call get_token
1545   08B7 31 5A 16      mov bl, [tok]
1546   08BA C1 01         cmp bl, TOK_FSLASH
1547   08BC C6 C8 08      je  file_exists_by_path_abs
1548   08BF 14 6C 17      mov a, [current_dir_id]
1549   08C2 07 3E 16      call _putback
1550   08C5 0A CB 08      jmp file_exists_by_path_E0
1551   08C8             file_exists_by_path_abs:
1552   08C8 10 20 00      mov a, root_id
1553   08CB             file_exists_by_path_E0:
1554   08CB 07 B8 14      call get_token
1555   08CE 31 59 16      mov bl, [toktyp]
1556   08D1 C1 00         cmp bl, TOKTYP_IDENTIFIER
1557   08D3 C7 2B 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1558   08D6 FD 4D 5B 16   mov si, tokstr
1559   08DA FD 4F 29 1E   mov di, filename
1560   08DE 07 8A 10      call _strcpy        
1561   08E1 77            inc a                           ; metadata sector
1562   08E2 27            mov b, a
1563   08E3 38 00 00      mov c, 0                        ; upper LBA = 0
1564   08E6 22 01         mov ah, $01                  ; 1 sector
1565   08E8 3B A9 26      mov d, transient_area
1566   08EB 07 8F 04      call ide_read_sect              ; read directory
1567   08EE FD 10         cla
1568   08F0 42 64 17      mov [index], a
1569   08F3             file_exists_by_path_L1:
1570   08F3 FD 4E         mov si, d
1571   08F5 FD 4F 29 1E   mov di, filename
1572   08F9 07 75 10      call _strcmp
1573   08FC C6 12 09      je   file_exists_by_path_name_equal
1574   08FF 58 20 00      add d, 32
1575   0902 14 64 17      mov a, [index]
1576   0905 77            inc a
1577   0906 42 64 17      mov [index], a
1578   0909 AF 10 00      cmp a, FST_FILES_PER_DIR
1579   090C C6 2B 09      je file_exists_by_path_end
1580   090F 0A F3 08      jmp file_exists_by_path_L1
1581   0912             file_exists_by_path_name_equal:
1582   0912 33 18 00      mov bl, [d + 24]
1583   0915 FD 87 38      and bl, %00111000               ; directory flag
1584   0918 C1 08         cmp bl, %00001000               ; is dir?
1585   091A C6 21 09      je file_exists_by_path_isdir;
1586   091D             ; entry is a file
1587   091D 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1588   0920 09            ret
1589   0921             file_exists_by_path_isdir:
1590   0921 58 19 00      add d, 25           
1591   0924 15            mov a, [d]                      ; set result register A = dirID
1592   0925 07 B8 14      call get_token
1593   0928 0A CB 08      jmp file_exists_by_path_E0
1594   092B             file_exists_by_path_end:
1595   092B 10 00 00      mov a, 0                        ; return 0 because file was not found
1596   092E 09            ret
1597   092F             
1598   092F             ;------------------------------------------------------------------------------------------------------;
1599   092F             ; load file data from a given path string
1600   092F             ; inputs:
1601   092F             ; D = path pointer 
1602   092F             ; DI = userspace program data destination
1603   092F             ; /usr/local/bin/ed
1604   092F             ; ./ed
1605   092F             ;------------------------------------------------------------------------------------------------------;
1606   092F             fs_load_from_path_user:
1607   092F E3            push di
1608   0930 FD 4E         mov si, d
1609   0932 FD 4F A9 1E   mov di, user_data
1610   0936 38 00 02      mov c, 512
1611   0939 04            load
1612   093A 07 47 09      call loadfile_from_path
1613   093D F0            pop di
1614   093E FD 4D A9 26   mov si, transient_area
1615   0942 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1616   0945 03            store
1617   0946 06            sysret
1618   0947             loadfile_from_path:
1619   0947 26 A9 1E      mov b, user_data
1620   094A FD 42 57 16   mov [prog], b                 ; token pointer set to path string
1621   094E 07 B8 14      call get_token
1622   0951 31 5A 16      mov bl, [tok]
1623   0954 C1 01         cmp bl, TOK_FSLASH
1624   0956 C6 62 09      je loadfile_from_path_abs 
1625   0959 14 6C 17      mov a, [current_dir_id]
1626   095C 07 3E 16      call _putback
1627   095F 0A 65 09      jmp loadfile_from_path_E0
1628   0962             loadfile_from_path_abs:
1629   0962 10 20 00      mov a, root_id
1630   0965             loadfile_from_path_E0:
1631   0965 07 B8 14      call get_token
1632   0968 31 59 16      mov bl, [toktyp]
1633   096B C1 00         cmp bl, TOKTYP_IDENTIFIER
1634   096D C7 D2 09      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1635   0970 FD 4D 5B 16   mov si, tokstr
1636   0974 FD 4F 29 1E   mov di, filename
1637   0978 07 8A 10      call _strcpy        
1638   097B 77            inc a                         ; metadata sector
1639   097C 27            mov b, a
1640   097D 38 00 00      mov c, 0                      ; upper LBA = 0
1641   0980 22 01         mov ah, $01                  ; 1 sector
1642   0982 3B A9 26      mov d, transient_area
1643   0985 07 8F 04      call ide_read_sect            ; read directory
1644   0988 FD 10         cla
1645   098A 42 64 17      mov [index], a
1646   098D             loadfile_from_path_L1:
1647   098D FD 4E         mov si, d
1648   098F FD 4F 29 1E   mov di, filename
1649   0993 07 75 10      call _strcmp
1650   0996 C6 AC 09      je loadfile_from_path_name_equal  
1651   0999 58 20 00      add d, 32
1652   099C 14 64 17      mov a, [index]
1653   099F 77            inc a
1654   09A0 42 64 17      mov [index], a
1655   09A3 AF 10 00      cmp a, FST_FILES_PER_DIR
1656   09A6 C6 D2 09      je loadfile_from_path_end
1657   09A9 0A 8D 09      jmp loadfile_from_path_L1
1658   09AC             loadfile_from_path_name_equal:
1659   09AC 33 18 00      mov bl, [d + 24]
1660   09AF FD 87 38      and bl, %00111000             ; directory flag
1661   09B2 C1 08         cmp bl, %00001000             ; is dir?
1662   09B4 C6 C8 09      je loadfile_isdirectory  
1663   09B7             ; entry is a file
1664   09B7 2B 19 00      mov b, [d + 25]               ; get LBA
1665   09BA FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1666   09BC 3B A9 26      mov d, transient_area
1667   09BF 38 00 00      mov c, 0
1668   09C2 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1669   09C4 07 8F 04      call ide_read_sect            ; read sector
1670   09C7 09            ret
1671   09C8             loadfile_isdirectory:
1672   09C8 58 19 00      add d, 25           
1673   09CB 15            mov a, [d]                    ; set result register A = dirID
1674   09CC 07 B8 14      call get_token
1675   09CF 0A 65 09      jmp loadfile_from_path_E0
1676   09D2             loadfile_from_path_end:
1677   09D2 09            ret
1678   09D3             
1679   09D3             ;------------------------------------------------------------------------------------------------------;
1680   09D3             ; return the ID of the current directory
1681   09D3             ; ID returned in B
1682   09D3             ;------------------------------------------------------------------------------------------------------;
1683   09D3             fs_get_curr_dirID:
1684   09D3 29 6C 17      mov b, [current_dir_id]
1685   09D6 06            sysret
1686   09D7             
1687   09D7             ;------------------------------------------------------------------------------------------------------;
1688   09D7             ; CD
1689   09D7             ;------------------------------------------------------------------------------------------------------;
1690   09D7             ; new dirID in B
1691   09D7             fs_cd:
1692   09D7 FD 42 6C 17   mov [current_dir_id], b
1693   09DB 06            sysret  
1694   09DC             
1695   09DC             ;------------------------------------------------------------------------------------------------------;
1696   09DC             ; LS
1697   09DC             ; dirID in B
1698   09DC             ;------------------------------------------------------------------------------------------------------;
1699   09DC 00 00       ls_count:       .dw 0
1700   09DE             fs_ls:
1701   09DE FD 77         inc b                        ; metadata sector
1702   09E0 38 00 00      mov c, 0                     ; upper LBA = 0
1703   09E3 22 01         mov ah, $01                  ; 1 sector
1704   09E5 3B A9 26      mov d, transient_area
1705   09E8 07 8F 04      call ide_read_sect           ; read directory
1706   09EB FD 10         cla
1707   09ED 42 64 17      mov [index], a               ; reset entry index
1708   09F0 3D DC 09      mov [ls_count], al           ; reset item count
1709   09F3             fs_ls_L1:
1710   09F3 BD 00         cmp byte [d], 0              ; check for NULL
1711   09F5 C6 8C 0A      je fs_ls_next
1712   09F8             fs_ls_non_null:
1713   09F8 1D DC 09      mov al, [ls_count]
1714   09FB 7A            inc al
1715   09FC 3D DC 09      mov [ls_count], al           ; increment item count
1716   09FF 1F 18 00      mov al, [d + 24]
1717   0A02 87 38         and al, %00111000
1718   0A04 FD A2 03      shr al, 3
1719   0A07 22 00         mov ah, 0                    ; file type
1720   0A09 B7 88 17      mov a, [a + file_type]      
1721   0A0C 23            mov ah, al
1722   0A0D 07 06 11      call _putchar
1723   0A10 1F 18 00      mov al, [d + 24]
1724   0A13 87 01         and al, %00000001
1725   0A15 22 00         mov ah, 0
1726   0A17 B7 83 17      mov a, [a + file_attrib]     ; read
1727   0A1A 23            mov ah, al
1728   0A1B 07 06 11      call _putchar
1729   0A1E 1F 18 00      mov al, [d + 24]
1730   0A21 87 02         and al, %00000010
1731   0A23 22 00         mov ah, 0
1732   0A25 B7 83 17      mov a, [a + file_attrib]     ; write
1733   0A28 23            mov ah, al
1734   0A29 07 06 11      call _putchar
1735   0A2C 1F 18 00      mov al, [d + 24]
1736   0A2F 87 04         and al, %00000100
1737   0A31 22 00         mov ah, 0
1738   0A33 B7 83 17      mov a, [a + file_attrib]     ; execute
1739   0A36 23            mov ah, al
1740   0A37 07 06 11      call _putchar
1741   0A3A 22 20         mov ah, $20
1742   0A3C 07 06 11      call _putchar  
1743   0A3F 2B 1B 00      mov b, [d + 27]
1744   0A42 07 8E 12      call print_u16x              ; filesize
1745   0A45 22 20         mov ah, $20
1746   0A47 07 06 11      call _putchar  
1747   0A4A 2B 19 00      mov b, [d + 25]
1748   0A4D 07 8E 12      call print_u16x              ; dirID / LBA
1749   0A50 22 20         mov ah, $20
1750   0A52 07 06 11      call _putchar
1751   0A55             ; print date
1752   0A55 33 1D 00      mov bl, [d + 29]             ; day
1753   0A58 07 D2 12      call print_u8x
1754   0A5B 22 20         mov ah, $20
1755   0A5D 07 06 11      call _putchar  
1756   0A60 1F 1E 00      mov al, [d + 30]             ; month
1757   0A63 FD 9E 02      shl al, 2
1758   0A66 DA            push d
1759   0A67 3B 47 18      mov d, s_months
1760   0A6A 22 00         mov ah, 0
1761   0A6C 59            add d, a
1762   0A6D 07 32 12      call _puts
1763   0A70 E7            pop d
1764   0A71 22 20         mov ah, $20
1765   0A73 07 06 11      call _putchar
1766   0A76 2E 20         mov bl, $20
1767   0A78 07 D2 12      call print_u8x
1768   0A7B 33 1F 00      mov bl, [d + 31]             ; year
1769   0A7E 07 D2 12      call print_u8x  
1770   0A81 22 20         mov ah, $20
1771   0A83 07 06 11      call _putchar  
1772   0A86 07 32 12      call _puts                   ; print filename  
1773   0A89 07 DF 11      call printnl
1774   0A8C             fs_ls_next:
1775   0A8C 14 64 17      mov a, [index]
1776   0A8F 77            inc a
1777   0A90 42 64 17      mov [index], a
1778   0A93 AF 10 00      cmp a, FST_FILES_PER_DIR
1779   0A96 C6 9F 0A      je fs_ls_end
1780   0A99 58 20 00      add d, 32      
1781   0A9C 0A F3 09      jmp fs_ls_L1  
1782   0A9F             fs_ls_end:
1783   0A9F 3B 98 17      mov d, s_ls_total
1784   0AA2 07 32 12      call _puts
1785   0AA5 1D DC 09      mov al, [ls_count]
1786   0AA8 07 E4 12      call print_u8d
1787   0AAB 07 DF 11      call printnl
1788   0AAE 06            sysret
1789   0AAF             
1790   0AAF             
1791   0AAF             ; file structure:
1792   0AAF             ; 512 bytes header
1793   0AAF             ; header used to tell whether the block is free
1794   0AAF             ;------------------------------------------------------------------------------------------------------;
1795   0AAF             ; CREATE NEW TEXTFILE
1796   0AAF             ;------------------------------------------------------------------------------------------------------;
1797   0AAF             ; d = content pointer in user space
1798   0AAF             ; c = file size
1799   0AAF             fs_starcom:
1800   0AAF FD 4E       	mov si, d
1801   0AB1 FD 4F A9 26 	mov di, transient_area
1802   0AB5 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1803   0AB8 04          	load					; load data from user-space
1804   0AB9 07 3A 0B    	call fs_find_empty_block	; look for empty data blocks
1805   0ABC D8          	push b				; save empty block LBA
1806   0ABD FD 79         mov g, b
1807   0ABF             ;create header file by grabbing file name from parameter	
1808   0ABF 3B A9 28    	mov d, transient_area + 512			; pointer to file contents
1809   0AC2 D9          	push c							; save length
1810   0AC3 19 01       	mov al, 1
1811   0AC5 3D A9 26    	mov [transient_area], al					; mark sectors as USED (not NULL)
1812   0AC8 3B A9 26    	mov d, transient_area
1813   0ACB 12            mov a, c
1814   0ACC 26 00 02      mov b, 512
1815   0ACF AE            div a, b
1816   0AD0 FD 77         inc b         ; inc b as the division will most likely have a remainder
1817   0AD2 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1818   0AD3 38 00 00    	mov c, 0      ; lba 
1819   0AD6 FD 27         mov b, g      ; lba 
1820   0AD8 07 B5 04    	call ide_write_sect			; write sectors
1821   0ADB             ; now we add the file to the current directory!
1822   0ADB             fs_starcom_add_to_dir:	
1823   0ADB 14 6C 17    	mov a, [current_dir_id]
1824   0ADE 77          	inc a
1825   0ADF 27          	mov b, a					; metadata sector
1826   0AE0 38 00 00    	mov c, 0
1827   0AE3 FD 79       	mov g, b					; save LBA
1828   0AE5 3B A9 24    	mov d, scrap_sector
1829   0AE8 22 01       	mov ah, $01			  ; 1 sector
1830   0AEA 07 8F 04    	call ide_read_sect		; read metadata sector
1831   0AED             fs_starcom_add_to_dir_L2:
1832   0AED BD 00       	cmp byte[d], 0
1833   0AEF C6 F8 0A    	je fs_starcom_add_to_dir_null
1834   0AF2 58 20 00    	add d, FST_ENTRY_SIZE
1835   0AF5 0A ED 0A    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1836   0AF8             fs_starcom_add_to_dir_null:
1837   0AF8 FD 4D AA 26 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1838   0AFC FD 50       	mov di, d
1839   0AFE 07 8A 10    	call _strcpy			; copy file name
1840   0B01 58 18 00    	add d, 24			; skip name
1841   0B04 19 07       	mov al, %00000111	; type=file, execute, write, read
1842   0B06 3E          	mov [d], al			
1843   0B07 58 03 00    	add d, 3
1844   0B0A E4          	pop a
1845   0B0B 5F 00 02      sub a, 512
1846   0B0E 43          	mov [d], a ; file size
1847   0B0F 63 02 00    	sub d, 2
1848   0B12 E5          	pop b				; get file LBA
1849   0B13 FD 43       	mov [d], b			; save LBA	
1850   0B15             ; set file creation date	
1851   0B15 58 04 00    	add d, 4
1852   0B18 19 04       	mov al, 4
1853   0B1A 05 01       	syscall sys_rtc
1854   0B1C 1A          	mov al, ah
1855   0B1D 3E          	mov [d], al			; set day
1856   0B1E 79          	inc d
1857   0B1F 19 05       	mov al, 5
1858   0B21 05 01       	syscall sys_rtc
1859   0B23 1A          	mov al, ah
1860   0B24 3E          	mov [d], al			; set month
1861   0B25 79          	inc d
1862   0B26 19 06       	mov al, 6
1863   0B28 05 01       	syscall sys_rtc
1864   0B2A 1A          	mov al, ah
1865   0B2B 3E          	mov [d], al			; set year
1866   0B2C             ; write sector into disk for new directory entry
1867   0B2C FD 27       	mov b, g
1868   0B2E 38 00 00    	mov c, 0
1869   0B31 3B A9 24    	mov d, scrap_sector
1870   0B34 22 01       	mov ah, $01			; disk write, 1 sector
1871   0B36 07 B5 04    	call ide_write_sect		; write sector
1872   0B39 06          	sysret
1873   0B3A             
1874   0B3A             ;------------------------------------------------------------------------------------------------------;
1875   0B3A             ; finds an empty data block
1876   0B3A             ; block LBA returned in B
1877   0B3A             ;------------------------------------------------------------------------------------------------------;
1878   0B3A             fs_find_empty_block:
1879   0B3A 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1880   0B3D 38 00 00      mov c, 0                ; upper LBA = 0
1881   0B40             fs_find_empty_block_L1:  
1882   0B40 22 01         mov ah, $01                  ; 1 sector
1883   0B42 3B A9 24      mov d, transient_area - 512
1884   0B45 07 8F 04      call ide_read_sect      ; read sector
1885   0B48 BD 00         cmp byte [d], 0
1886   0B4A C6 53 0B      je fs_find_empty_block_found_null
1887   0B4D 55 20 00      add b, FS_SECTORS_PER_FILE
1888   0B50 0A 40 0B      jmp fs_find_empty_block_L1
1889   0B53             fs_find_empty_block_found_null:
1890   0B53 09            ret
1891   0B54             
1892   0B54             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1893   0B54             ;; CREATE NEW TEXTFILE
1894   0B54             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1895   0B54             ; search for first null block
1896   0B54             fs_mktxt:
1897   0B54 FD 4E       	mov si, d
1898   0B56 FD 4F A9 1E 	mov di, user_data
1899   0B5A 38 00 01    	mov c, 256
1900   0B5D 04          	load					; load data from user-space
1901   0B5E             	
1902   0B5E 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1903   0B61 38 00 00    	mov c, 0						; reset LBA to 0
1904   0B64             fs_mktxt_L1:	
1905   0B64 10 02 01    	mov a, $0102			; disk read
1906   0B67 3B A9 26    	mov d, transient_area
1907   0B6A 05 02       	syscall sys_ide ; read sector
1908   0B6C 1E          	mov al, [d]
1909   0B6D B9 00       	cmp al, 0			; check for NULL
1910   0B6F C6 78 0B    	je fs_mktxt_found_null
1911   0B72 55 20 00    	add b, FS_SECTORS_PER_FILE
1912   0B75 0A 64 0B    	jmp fs_mktxt_L1
1913   0B78             fs_mktxt_found_null:
1914   0B78 D8          	push b				; save LBA
1915   0B79             ;create header file by grabbing file name from parameter	
1916   0B79 3B 79 17    	mov d, s_dataentry
1917   0B7C 07 32 12    	call _puts
1918   0B7F 3B A9 28    	mov d, transient_area + 512			; pointer to file contents
1919   0B82 07 98 11    	call _gettxt
1920   0B85 07 65 10    	call _strlen						; get length of file
1921   0B88 D9          	push c							; save length
1922   0B89 19 01       	mov al, 1
1923   0B8B 3D A9 26    	mov [transient_area], al					; mark sectors as USED (not NULL)
1924   0B8E 10 00 00    	mov a, 0
1925   0B91 42 64 17    	mov [index], a
1926   0B94 3B A9 26    	mov d, transient_area
1927   0B97 13          	mov a, d
1928   0B98 42 66 17    	mov [buffer_addr], a
1929   0B9B             fs_mktxt_L2:
1930   0B9B 38 00 00    	mov c, 0
1931   0B9E 10 03 01    	mov a, $0103			; disk write, 1 sector
1932   0BA1 05 02       	syscall sys_ide		; write sector
1933   0BA3 14 64 17    	mov a, [index]
1934   0BA6 77          	inc a
1935   0BA7 42 64 17    	mov [index], a
1936   0BAA AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1937   0BAD C6 BF 0B    	je fs_mktxt_add_to_dir
1938   0BB0 FD 77       	inc b
1939   0BB2 14 66 17    	mov a, [buffer_addr]
1940   0BB5 53 00 02    	add a, 512
1941   0BB8 42 66 17    	mov [buffer_addr], a
1942   0BBB 3C          	mov d, a
1943   0BBC 0A 9B 0B    	jmp fs_mktxt_L2
1944   0BBF             ; now we add the file to the current directory!
1945   0BBF             fs_mktxt_add_to_dir:	
1946   0BBF 14 6C 17    	mov a, [current_dir_id]
1947   0BC2 77          	inc a
1948   0BC3 27          	mov b, a					; metadata sector
1949   0BC4 38 00 00    	mov c, 0
1950   0BC7 FD 79       	mov g, b					; save LBA
1951   0BC9 3B A9 26    	mov d, transient_area
1952   0BCC 10 02 01    	mov a, $0102			; disk read
1953   0BCF 05 02       	syscall sys_ide		; read metadata sector
1954   0BD1             fs_mktxt_add_to_dir_L2:
1955   0BD1 1E          	mov al, [d]
1956   0BD2 B9 00       	cmp al, 0
1957   0BD4 C6 DD 0B    	je fs_mktxt_add_to_dir_null
1958   0BD7 58 20 00    	add d, FST_ENTRY_SIZE
1959   0BDA 0A D1 0B    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1960   0BDD             fs_mktxt_add_to_dir_null:
1961   0BDD FD 4D A9 1E 	mov si, user_data
1962   0BE1 FD 50       	mov di, d
1963   0BE3 07 8A 10    	call _strcpy			; copy file name
1964   0BE6 58 18 00    	add d, 24			; skip name
1965   0BE9 19 06       	mov al, %00000110		; no execute, write, read, not directory
1966   0BEB 3E          	mov [d], al			
1967   0BEC 58 03 00    	add d, 3
1968   0BEF E4          	pop a
1969   0BF0 43          	mov [d], a
1970   0BF1 63 02 00    	sub d, 2
1971   0BF4 E5          	pop b				; get file LBA
1972   0BF5 FD 43       	mov [d], b			; save LBA	
1973   0BF7             	
1974   0BF7             	; set file creation date	
1975   0BF7 58 04 00    	add d, 4
1976   0BFA 19 04       	mov al, 4
1977   0BFC 05 01       	syscall sys_rtc
1978   0BFE 1A          	mov al, ah
1979   0BFF 3E          	mov [d], al			; set day
1980   0C00             	
1981   0C00 79          	inc d
1982   0C01 19 05       	mov al, 5
1983   0C03 05 01       	syscall sys_rtc
1984   0C05 1A          	mov al, ah
1985   0C06 3E          	mov [d], al			; set month
1986   0C07             	
1987   0C07 79          	inc d
1988   0C08 19 06       	mov al, 6
1989   0C0A 05 01       	syscall sys_rtc
1990   0C0C 1A          	mov al, ah
1991   0C0D 3E          	mov [d], al			; set year
1992   0C0E             	
1993   0C0E             ; write sector into disk for new directory entry
1994   0C0E FD 27       	mov b, g
1995   0C10 38 00 00    	mov c, 0
1996   0C13 3B A9 26    	mov d, transient_area
1997   0C16 10 03 01    	mov a, $0103			; disk write, 1 sector
1998   0C19 05 02       	syscall sys_ide		; write sector
1999   0C1B 07 DF 11    	call printnl
2000   0C1E 06          	sysret
2001   0C1F             
2002   0C1F             
2003   0C1F             
2004   0C1F             ;------------------------------------------------------------------------------------------------------;
2005   0C1F             ; CREATE NEW BINARY FILE
2006   0C1F             ;------------------------------------------------------------------------------------------------------;
2007   0C1F             ; search for first null block
2008   0C1F             fs_mkbin:
2009   0C1F 19 00         mov al, 0
2010   0C21 3D 5C 17      mov [sys_echo_on], al ; disable echo
2011   0C24 FD 4E         mov si, d
2012   0C26 FD 4F A9 1E   mov di, user_data
2013   0C2A 38 00 02      mov c, 512
2014   0C2D 04            load                          ; load data from user-space
2015   0C2E 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
2016   0C31 38 00 00      mov c, 0                      ; upper LBA = 0
2017   0C34             fs_mkbin_L1:  
2018   0C34 22 01         mov ah, $01                  ; 1 sector
2019   0C36 3B A9 26      mov d, transient_area
2020   0C39 07 8F 04      call ide_read_sect            ; read sector
2021   0C3C BD 00         cmp byte[d], 0                ; check for NULL
2022   0C3E C6 47 0C      je fs_mkbin_found_null
2023   0C41 55 20 00      add b, FS_SECTORS_PER_FILE
2024   0C44 0A 34 0C      jmp fs_mkbin_L1
2025   0C47             fs_mkbin_found_null:
2026   0C47 D8            push b                        ; save LBA
2027   0C48             ;create header file by grabbing file name from parameter
2028   0C48 FD 4F A9 28   mov di, transient_area + 512  ; pointer to file contents
2029   0C4C 07 C2 0F      call _load_hex                ; load binary hex
2030   0C4F D9            push c                        ; save size (nbr of bytes)
2031   0C50 19 01         mov al, 1
2032   0C52 3D A9 26      mov [transient_area], al      ; mark sectors as USED (not NULL)
2033   0C55 FD 10         cla
2034   0C57 42 64 17      mov [index], a
2035   0C5A 3B A9 26      mov d, transient_area
2036   0C5D 13            mov a, d
2037   0C5E 42 66 17      mov [buffer_addr], a
2038   0C61             fs_mkbin_L2:
2039   0C61 38 00 00      mov c, 0
2040   0C64 22 01         mov ah, $01                   ; disk write, 1 sector
2041   0C66 07 B5 04      call ide_write_sect           ; write sector
2042   0C69 14 64 17      mov a, [index]
2043   0C6C 77            inc a
2044   0C6D 42 64 17      mov [index], a
2045   0C70 AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
2046   0C73 C6 85 0C      je fs_mkbin_add_to_dir
2047   0C76 FD 77         inc b
2048   0C78 14 66 17      mov a, [buffer_addr]
2049   0C7B 53 00 02      add a, 512
2050   0C7E 42 66 17      mov [buffer_addr], a
2051   0C81 3C            mov d, a
2052   0C82 0A 61 0C      jmp fs_mkbin_L2
2053   0C85             ; now we add the file to the current directory!
2054   0C85             fs_mkbin_add_to_dir:  
2055   0C85 14 6C 17      mov a, [current_dir_id]
2056   0C88 77            inc a
2057   0C89 27            mov b, a                      ; metadata sector
2058   0C8A 38 00 00      mov c, 0
2059   0C8D FD 79         mov g, b                      ; save LBA
2060   0C8F 3B A9 26      mov d, transient_area
2061   0C92 22 01         mov ah, $01                  ; 1 sector
2062   0C94 07 8F 04      call ide_read_sect            ; read metadata sector
2063   0C97             fs_mkbin_add_to_dir_L2:
2064   0C97 BD 00         cmp byte[d], 0
2065   0C99 C6 A2 0C      je fs_mkbin_add_to_dir_null
2066   0C9C 58 20 00      add d, FST_ENTRY_SIZE
2067   0C9F 0A 97 0C      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
2068   0CA2             fs_mkbin_add_to_dir_null:
2069   0CA2 FD 4D A9 1E   mov si, user_data
2070   0CA6 FD 50         mov di, d
2071   0CA8 07 8A 10      call _strcpy                  ; copy file name
2072   0CAB 58 18 00      add d, 24                     ; skip name
2073   0CAE 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2074   0CB0 3E            mov [d], al
2075   0CB1 58 03 00      add d, 3
2076   0CB4 E4            pop a
2077   0CB5 43            mov [d], a
2078   0CB6 63 02 00      sub d, 2
2079   0CB9 E5            pop b                         ; get file LBA
2080   0CBA FD 43         mov [d], b                    ; save LBA
2081   0CBC               ; set file creation date  
2082   0CBC 58 04 00      add d, 4
2083   0CBF 19 04         mov al, 4
2084   0CC1 05 01         syscall sys_rtc
2085   0CC3 1A            mov al, ah
2086   0CC4 3E            mov [d], al                   ; set day
2087   0CC5 79            inc d
2088   0CC6 19 05         mov al, 5
2089   0CC8 05 01         syscall sys_rtc
2090   0CCA 1A            mov al, ah
2091   0CCB 3E            mov [d], al                   ; set month
2092   0CCC 79            inc d
2093   0CCD 19 06         mov al, 6
2094   0CCF 05 01         syscall sys_rtc
2095   0CD1 1A            mov al, ah
2096   0CD2 3E            mov [d], al                   ; set year
2097   0CD3             ; write sector into disk for new directory entry
2098   0CD3 FD 27         mov b, g
2099   0CD5 38 00 00      mov c, 0
2100   0CD8 3B A9 26      mov d, transient_area
2101   0CDB 22 01         mov ah, $01                   ; disk write, 1 sector
2102   0CDD 07 B5 04      call ide_write_sect           ; write sector
2103   0CE0 19 01         mov al, 1
2104   0CE2 3D 5C 17      mov [sys_echo_on], al ; enable echo
2105   0CE5 06            sysret
2106   0CE6             
2107   0CE6             ;------------------------------------------------------------------------------------------------------;
2108   0CE6             ; PWD - PRINT WORKING DIRECTORY
2109   0CE6             ;------------------------------------------------------------------------------------------------------;    
2110   0CE6             fs_pwd:
2111   0CE6 3B 29 1E      mov d, filename
2112   0CE9 19 00         mov al, 0
2113   0CEB 3E            mov [d], al                   ; initialize path string 
2114   0CEC 14 6C 17      mov a, [current_dir_id]
2115   0CEF 07 C5 07      call fs_dir_id_to_path_E0
2116   0CF2 3B 29 1E      mov d, filename
2117   0CF5 07 1E 10      call _strrev
2118   0CF8 07 32 12      call _puts
2119   0CFB 07 DF 11      call printnl
2120   0CFE 06            sysret
2121   0CFF             
2122   0CFF             ;------------------------------------------------------------------------------------------------------;
2123   0CFF             ; get current directory LBA
2124   0CFF             ; A: returned LBA
2125   0CFF             ;------------------------------------------------------------------------------------------------------;
2126   0CFF             cmd_get_curr_dir_LBA:
2127   0CFF 14 6C 17      mov a, [current_dir_id]
2128   0D02 06            sysret
2129   0D03             
2130   0D03             ;------------------------------------------------------------------------------------------------------;
2131   0D03             ; CAT
2132   0D03             ; userspace destination data pointer in D
2133   0D03             ; filename starts at D, but is overwritten after the read is made
2134   0D03             ;------------------------------------------------------------------------------------------------------;:
2135   0D03             fs_cat:
2136   0D03 DA            push d                              ; save userspace file data destination
2137   0D04 FD 4E         mov si, d
2138   0D06 FD 4F A9 1E   mov di, user_data
2139   0D0A 38 00 02      mov c, 512
2140   0D0D 04            load                                ; copy filename from user-space
2141   0D0E 29 6C 17      mov b, [current_dir_id]
2142   0D11 FD 77         inc b                               ; metadata sector
2143   0D13 38 00 00      mov c, 0                            ; upper LBA = 0
2144   0D16 22 01         mov ah, $01                  ; 1 sector
2145   0D18 3B A9 24      mov d, transient_area-512
2146   0D1B 07 8F 04      call ide_read_sect                  ; read directory
2147   0D1E FD 10         cla
2148   0D20 42 64 17      mov [index], a                      ; reset file counter
2149   0D23             fs_cat_L1:
2150   0D23 FD 4E         mov si, d
2151   0D25 FD 4F A9 1E   mov di, user_data
2152   0D29 07 75 10      call _strcmp
2153   0D2C C6 42 0D      je fs_cat_found_entry
2154   0D2F 58 20 00      add d, 32
2155   0D32 14 64 17      mov a, [index]
2156   0D35 77            inc a
2157   0D36 42 64 17      mov [index], a
2158   0D39 AF 10 00      cmp a, FST_FILES_PER_DIR
2159   0D3C C6 5D 0D      je fs_cat_not_found
2160   0D3F 0A 23 0D      jmp fs_cat_L1
2161   0D42             fs_cat_found_entry:
2162   0D42 58 19 00      add d, 25                           ; get to dirID of file in disk
2163   0D45 2A            mov b, [d]                          ; get LBA
2164   0D46 FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2165   0D48 3B A9 26      mov d, transient_area  
2166   0D4B 38 00 00      mov c, 0
2167   0D4E 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2168   0D50 07 8F 04      call ide_read_sect                  ; read sectors
2169   0D53 F0            pop di                              ; write userspace file data destination to DI
2170   0D54 FD 4D A9 26   mov si, transient_area              ; data origin
2171   0D58 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2172   0D5B 03            store
2173   0D5C 06            sysret
2174   0D5D             fs_cat_not_found:
2175   0D5D E7            pop d
2176   0D5E 06            sysret
2177   0D5F             
2178   0D5F             ;------------------------------------------------------------------------------------------------------;
2179   0D5F             ; RMDIR - remove DIR by dirID
2180   0D5F             ;------------------------------------------------------------------------------------------------------;
2181   0D5F             ; deletes a directory entry in the given directory's file list 
2182   0D5F             ; also deletes the actual directory entry in the FST
2183   0D5F             ; synopsis: rmdir /usr/local/testdir
2184   0D5F             ; B = dirID
2185   0D5F             fs_rmdir:
2186   0D5F FD 79         mov g, b
2187   0D61 11            mov a, b
2188   0D62 07 01 08      call get_parentID_from_dirID  ; now get the directory's parent, in A
2189   0D65 D7            push a                        ; save dirID
2190   0D66             ; search for directory's entry in the parent's directory then and delete it
2191   0D66 77            inc a                         ; metadata sector
2192   0D67 27            mov b, a
2193   0D68 38 00 00      mov c, 0                      ; upper LBA = 0
2194   0D6B 22 01         mov ah, $01          ;
2195   0D6D 3B A9 26      mov d, transient_area
2196   0D70 07 8F 04      call ide_read_sect            ; read directory
2197   0D73 FD 10         cla
2198   0D75 42 64 17      mov [index], a                ; reset file counter
2199   0D78 FD 27         mov b, g                      ; retrieve directory's dirID
2200   0D7A             fs_rmdir_L1:
2201   0D7A 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2202   0D7D B0            cmp a, b                      ; compare dirID's to find the directory
2203   0D7E C6 94 0D      je fs_rmdir_found_entry
2204   0D81 58 20 00      add d, 32
2205   0D84 14 64 17      mov a, [index]
2206   0D87 77            inc a
2207   0D88 42 64 17      mov [index], a
2208   0D8B AF 10 00      cmp a, FST_FILES_PER_DIR
2209   0D8E C6 B9 0D      je fs_rmdir_not_found
2210   0D91 0A 7A 0D      jmp fs_rmdir_L1
2211   0D94             fs_rmdir_found_entry:
2212   0D94 FD 10         cla
2213   0D96 3E            mov [d], al                   ; make filename NULL
2214   0D97 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2215   0D9A E5            pop b
2216   0D9B FD 77         inc b                         ; metadata sector
2217   0D9D 38 00 00      mov c, 0                      ; upper LBA = 0
2218   0DA0 22 01         mov ah, $01          ; 
2219   0DA2 3B A9 26      mov d, transient_area
2220   0DA5 07 B5 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2221   0DA8             
2222   0DA8 FD 27         mov b, g
2223   0DAA 3B A9 26      mov d, transient_area  
2224   0DAD FD 10         cla
2225   0DAF 3E            mov [d], al                   ; make directory's name header NULL for re-use
2226   0DB0 38 00 00      mov c, 0
2227   0DB3 22 01         mov ah, $01                   ; disk write 1 sect
2228   0DB5 07 B5 04      call ide_write_sect           ; delete directory given by dirID in B
2229   0DB8 06            sysret
2230   0DB9             fs_rmdir_not_found:
2231   0DB9 E5            pop b
2232   0DBA 06            sysret
2233   0DBB             
2234   0DBB             ;------------------------------------------------------------------------------------------------------;
2235   0DBB             ; RM - remove file
2236   0DBB             ;------------------------------------------------------------------------------------------------------;
2237   0DBB             ; frees up the data sectors for the file further down the disk
2238   0DBB             ; deletes file entry in the directory's file list 
2239   0DBB             fs_rm:
2240   0DBB FD 4E         mov si, d
2241   0DBD FD 4F A9 1E   mov di, user_data
2242   0DC1 38 00 02      mov c, 512
2243   0DC4 04            load                          ; load data from user-space
2244   0DC5 14 6C 17      mov a, [current_dir_id]
2245   0DC8 77            inc a                         ; metadata sector
2246   0DC9 27            mov b, a
2247   0DCA 38 00 00      mov c, 0                      ; upper LBA = 0
2248   0DCD 22 01         mov ah, $01                  ; 1 sector
2249   0DCF 3B A9 26      mov d, transient_area
2250   0DD2 07 8F 04      call ide_read_sect            ; read directory
2251   0DD5 10 00 00      mov a, 0
2252   0DD8 42 64 17      mov [index], a                ; reset file counter
2253   0DDB             fs_rm_L1:
2254   0DDB FD 4E         mov si, d
2255   0DDD FD 4F A9 1E   mov di, user_data
2256   0DE1 07 75 10      call _strcmp
2257   0DE4 C6 FA 0D      je fs_rm_found_entry
2258   0DE7 58 20 00      add d, 32
2259   0DEA 14 64 17      mov a, [index]
2260   0DED 77            inc a
2261   0DEE 42 64 17      mov [index], a
2262   0DF1 AF 10 00      cmp a, FST_FILES_PER_DIR
2263   0DF4 C6 22 0E      je fs_rm_not_found
2264   0DF7 0A DB 0D      jmp fs_rm_L1
2265   0DFA             fs_rm_found_entry:
2266   0DFA 2B 19 00      mov b, [d + 25]               ; get LBA
2267   0DFD FD 79         mov g, b                      ; save LBA
2268   0DFF 19 00         mov al, 0
2269   0E01 3E            mov [d], al                   ; make file entry NULL
2270   0E02 14 6C 17      mov a, [current_dir_id]
2271   0E05 77            inc a                         ; metadata sector
2272   0E06 27            mov b, a
2273   0E07 38 00 00      mov c, 0                      ; upper LBA = 0
2274   0E0A 22 01         mov ah, $01                   ; disk write
2275   0E0C 3B A9 26      mov d, transient_area
2276   0E0F 07 B5 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2277   0E12 3B A9 26      mov d, transient_area  
2278   0E15 19 00         mov al, 0
2279   0E17 3E            mov [d], al                   ; make file's data header NULL for re-use
2280   0E18 38 00 00      mov c, 0
2281   0E1B FD 27         mov b, g                      ; get data header LBA
2282   0E1D 22 01         mov ah, $01                   ; disk write 1 sect
2283   0E1F 07 B5 04      call ide_write_sect           ; write sector
2284   0E22             fs_rm_not_found:  
2285   0E22 06            sysret  
2286   0E23             
2287   0E23             ;------------------------------------------------------------------------------------------------------;
2288   0E23             ; mv - move / change file name
2289   0E23             ;------------------------------------------------------------------------------------------------------;
2290   0E23             fs_mv:
2291   0E23 FD 4E         mov si, d
2292   0E25 FD 4F A9 1E   mov di, user_data
2293   0E29 38 00 02      mov c, 512
2294   0E2C 04            load                          ; load data from user-space
2295   0E2D 14 6C 17      mov a, [current_dir_id]
2296   0E30 77            inc a                         ; metadata sector
2297   0E31 27            mov b, a  
2298   0E32 38 00 00      mov c, 0                      ; upper LBA = 0
2299   0E35 22 01         mov ah, $01                  ; 1 sector
2300   0E37 3B A9 26      mov d, transient_area
2301   0E3A 07 8F 04      call ide_read_sect            ; read directory
2302   0E3D FD 10         cla
2303   0E3F 42 64 17      mov [index], a                ; reset file counter
2304   0E42             fs_mv_L1:
2305   0E42 FD 4E         mov si, d
2306   0E44 FD 4F A9 1E   mov di, user_data
2307   0E48 07 75 10      call _strcmp
2308   0E4B C6 61 0E      je fs_mv_found_entry
2309   0E4E 58 20 00      add d, 32
2310   0E51 14 64 17      mov a, [index]
2311   0E54 77            inc a
2312   0E55 42 64 17      mov [index], a
2313   0E58 AF 10 00      cmp a, FST_FILES_PER_DIR
2314   0E5B C6 93 0E      je fs_mv_not_found
2315   0E5E 0A 42 0E      jmp fs_mv_L1
2316   0E61             fs_mv_found_entry:  
2317   0E61 DA            push d
2318   0E62 FD 4D 29 1F   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2319   0E66 FD 50         mov di, d
2320   0E68 07 8A 10      call _strcpy  
2321   0E6B 38 00 00      mov c, 0
2322   0E6E 3B A9 26      mov d, transient_area
2323   0E71 22 01         mov ah, $01                   ; disk write 1 sect
2324   0E73 07 B5 04      call ide_write_sect           ; write sector
2325   0E76 E7            pop d
2326   0E77             ;; need to check whether its a dir or a file here ;;;
2327   0E77 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2328   0E7A 22 01         mov ah, $01
2329   0E7C 3B A9 26      mov d, transient_area
2330   0E7F 38 00 00      mov c, 0
2331   0E82 07 8F 04      call ide_read_sect            ; read directory entry
2332   0E85 FD 4D 29 1F   mov si, user_data + 128
2333   0E89 FD 50         mov di, d
2334   0E8B 07 8A 10      call _strcpy                  ; change directory's name
2335   0E8E 22 01         mov ah, $01
2336   0E90 07 B5 04      call ide_write_sect           ; rewrite directory back to disk
2337   0E93             fs_mv_not_found:
2338   0E93 06            sysret
2339   0E94             
2340   0E94             
2341   0E94             ;----------------------------------------------------------------------------------------------------;
2342   0E94             ; Process Index in A
2343   0E94             ;----------------------------------------------------------------------------------------------------;
2344   0E94             find_free_proc:
2345   0E94 FD 4D 1A 1C   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2346   0E98             find_free_proc_L0:
2347   0E98 F6            lodsb                               ; get process state
2348   0E99 B9 00         cmp al, 0
2349   0E9B C6 A1 0E      je find_free_proc_free              ; if free, jump
2350   0E9E 0A 98 0E      jmp find_free_proc_L0               ; else, goto next
2351   0EA1             find_free_proc_free:
2352   0EA1 4E            mov a, si
2353   0EA2 5F 1A 1C      sub a, 1 + proc_availab_table       ; get process index
2354   0EA5 09            ret
2355   0EA6               
2356   0EA6             
2357   0EA6             ;----------------------------------------------------------------------------------------------------;
2358   0EA6             ; Process Index in AL
2359   0EA6             ;----------------------------------------------------------------------------------------------------;
2360   0EA6             proc_memory_map:
2361   0EA6 22 00         mov ah, 0
2362   0EA8 27            mov b, a                      ; page in BL, 0 in BH
2363   0EA9 FD 9D 05      shl a, 5                      ; multiply by 32
2364   0EAC 39            mov c, a                      ; save in C
2365   0EAD 57 20 00      add c, 32
2366   0EB0             proc_memory_map_L0:
2367   0EB0 02            pagemap
2368   0EB1 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2369   0EB4 53 01 00      add a, 1                      ; increase both 
2370   0EB7 B1            cmp a, c                      ; check to see if we reached the end of memory
2371   0EB8 C7 B0 0E      jne proc_memory_map_L0
2372   0EBB 09            ret
2373   0EBC               
2374   0EBC             
2375   0EBC             syscall_terminate_proc:
2376   0EBC 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2377   0EBF                                                    ; since they will not be used for anything here.
2378   0EBF 1D 63 17      mov al, [active_proc_index]
2379   0EC2 22 00         mov ah, 0  
2380   0EC4 FD 9D 05      shl a, 5                             ; x32
2381   0EC7 53 29 1C      add a, proc_names
2382   0ECA 3C            mov d, a
2383   0ECB 19 00         mov al, 0
2384   0ECD 3E            mov [d], al                           ; nullify process name
2385   0ECE             
2386   0ECE 1D 63 17      mov al, [active_proc_index]
2387   0ED1 22 00         mov ah, 0  
2388   0ED3 3C            mov d, a
2389   0ED4 19 00         mov al, 0
2390   0ED6 3F 19 1C      mov [d + proc_availab_table], al    ; make process empty again
2391   0ED9               
2392   0ED9 1D 62 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2393   0EDC 80            dec al
2394   0EDD 3D 62 17      mov [nbr_active_procs], al
2395   0EE0             
2396   0EE0             ; now load the shell process again
2397   0EE0 19 02         mov al, 2                           ; next process = process 2 = shell
2398   0EE2 3D 63 17      mov [active_proc_index], al         ; set next active proc
2399   0EE5             
2400   0EE5             ; calculate LUT entry for next process
2401   0EE5 22 00         mov ah, 0
2402   0EE7 FD 99         shl a                               ; x2
2403   0EE9 B7 B2 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2404   0EEC               
2405   0EEC 4D            mov si, a                           ; source is proc state block
2406   0EED 48            mov a, sp
2407   0EEE 5F 13 00      sub a, 19
2408   0EF1 4F            mov di, a                           ; destination is kernel stack
2409   0EF2             ; restore SP
2410   0EF2 7D            dec a
2411   0EF3 47            mov sp, a
2412   0EF4 38 14 00      mov c, 20
2413   0EF7 FD F5         rep movsb
2414   0EF9             ; set VM process
2415   0EF9 1D 63 17      mov al, [active_proc_index]
2416   0EFC 01            setptb
2417   0EFD                 
2418   0EFD 4C            popa
2419   0EFE 06            sysret
2420   0EFF             
2421   0EFF             syscall_pause_proc:
2422   0EFF             ; save all registers into kernel stack
2423   0EFF 4B            pusha
2424   0F00 22 00         mov ah, 0
2425   0F02 1D 63 17      mov al, [active_proc_index]
2426   0F05 FD 99         shl a              ; x2
2427   0F07 B7 B2 0F      mov a, [proc_table_convert + a]   ; get process state start index
2428   0F0A                 
2429   0F0A 4F            mov di, a
2430   0F0B 48            mov a, sp
2431   0F0C 77            inc a
2432   0F0D 4D            mov si, a
2433   0F0E 38 14 00      mov c, 20
2434   0F11 FD F5         rep movsb                         ; save process state!
2435   0F13             ; restore kernel stack position to point before interrupt arrived
2436   0F13 51 14 00      add sp, 20
2437   0F16             ; now load the shell process again
2438   0F16 19 02         mov al, 2                         ; next process = process 2 = shell
2439   0F18 3D 63 17      mov [active_proc_index], al       ; set next active proc
2440   0F1B             
2441   0F1B             ; calculate LUT entry for next process
2442   0F1B 22 00         mov ah, 0
2443   0F1D FD 99         shl a                             ; x2
2444   0F1F B7 B2 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2445   0F22               
2446   0F22 4D            mov si, a                         ; source is proc state block
2447   0F23 48            mov a, sp
2448   0F24 5F 13 00      sub a, 19
2449   0F27 4F            mov di, a                         ; destination is kernel stack
2450   0F28             ; restore SP
2451   0F28 7D            dec a
2452   0F29 47            mov sp, a
2453   0F2A 38 14 00      mov c, 20
2454   0F2D FD F5         rep movsb
2455   0F2F             ; set VM process
2456   0F2F 1D 63 17      mov al, [active_proc_index]
2457   0F32 01            setptb
2458   0F33                 
2459   0F33 4C            popa
2460   0F34 06            sysret
2461   0F35             
2462   0F35             ;----------------------------------------------------------------------------------------------------;
2463   0F35             ; create a new process
2464   0F35             ; D = path of the process file to be createed
2465   0F35             ; B = arguments ptr
2466   0F35             ;----------------------------------------------------------------------------------------------------;
2467   0F35             syscall_create_proc:
2468   0F35             ; we save the active process first  
2469   0F35 4B            pusha
2470   0F36 22 00         mov ah, 0
2471   0F38 1D 63 17      mov al, [active_proc_index]
2472   0F3B FD 99         shl a              ; x2
2473   0F3D B7 B2 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2474   0F40               
2475   0F40 4F            mov di, a
2476   0F41 48            mov a, sp
2477   0F42 77            inc a
2478   0F43 4D            mov si, a
2479   0F44 38 14 00      mov c, 20
2480   0F47 FD F5         rep movsb                          ; save process state!
2481   0F49             ; restore kernel stack position to point before interrupt arrived
2482   0F49 51 14 00      add sp, 20
2483   0F4C               
2484   0F4C FD 4E         mov si, d                          ; copy the file path
2485   0F4E FD 4F A9 1E   mov di, user_data
2486   0F52 38 00 02      mov c, 512
2487   0F55 04            load
2488   0F56 11            mov a, b
2489   0F57 4D            mov si, a                          ; copy the arguments
2490   0F58 FD 4F A9 24   mov di, scrap_sector
2491   0F5C 38 00 02      mov c, 512
2492   0F5F 04            load
2493   0F60 07 47 09      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2494   0F63                                                  ; the file data is loaded into transient_area
2495   0F63             ; now we allocate a new process  
2496   0F63 07 94 0E      call find_free_proc                ; index in A
2497   0F66 01            setptb 
2498   0F67 07 A6 0E      call proc_memory_map               ; map process memory pages
2499   0F6A             ; copy arguments into process's memory
2500   0F6A FD 4D A9 24   mov si, scrap_sector
2501   0F6E FD 4F 00 00   mov di, 0
2502   0F72 38 00 02      mov c, 512
2503   0F75 03            store
2504   0F76             ; now copy process binary data into process's memory
2505   0F76 FD 4D A9 26   mov si, transient_area
2506   0F7A FD 4F 00 04   mov di, text_org              ; code origin address for all user processes
2507   0F7E 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2508   0F81 03            store                              ; copy process data
2509   0F82                 
2510   0F82 07 94 0E      call find_free_proc                ; index in A
2511   0F85 3D 63 17      mov [active_proc_index], al        ; set new active process
2512   0F88 FD 9D 05      shl a, 5                           ; x32
2513   0F8B 53 29 1C      add a, proc_names
2514   0F8E 4F            mov di, a
2515   0F8F FD 4D A9 1E   mov si, user_data                  ; copy and store process filename
2516   0F93 07 8A 10      call _strcpy
2517   0F96               
2518   0F96 07 94 0E      call find_free_proc                ; index in A
2519   0F99 3C            mov d, a
2520   0F9A 19 01         mov al, 1
2521   0F9C 3F 19 1C      mov [d + proc_availab_table], al   ; make process busy
2522   0F9F               
2523   0F9F 1D 62 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2524   0FA2 7A            inc al
2525   0FA3 3D 62 17      mov [nbr_active_procs], al
2526   0FA6             ; launch process
2527   0FA6 FD D7 FF FF   push word $FFFF 
2528   0FAA FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2529   0FAD FD D7 00 04   push word text_org
2530   0FB1 06            sysret
2531   0FB2             
2532   0FB2             proc_table_convert:
2533   0FB2 D9 1A         .dw proc_state_table + 0
2534   0FB4 ED 1A         .dw proc_state_table + 20
2535   0FB6 01 1B         .dw proc_state_table + 40
2536   0FB8 15 1B         .dw proc_state_table + 60
2537   0FBA 29 1B         .dw proc_state_table + 80
2538   0FBC 3D 1B         .dw proc_state_table + 100
2539   0FBE 51 1B         .dw proc_state_table + 120
2540   0FC0 65 1B         .dw proc_state_table + 140
2541   0FC2               
2542   0FC2             ;----------------------------------------------------------------------------------------------;
2543   0FC2             ; GET HEX FILE
2544   0FC2             ; di = destination address
2545   0FC2             ; return length in bytes in C
2546   0FC2             ;----------------------------------------------------------------------------------------------;
2547   0FC2             _load_hex:
2548   0FC2 D7            push a
2549   0FC3 D8            push b
2550   0FC4 DA            push d
2551   0FC5 E2            push si
2552   0FC6 E3            push di
2553   0FC7 38 00 00      mov c, 0
2554   0FCA 50            mov a, di
2555   0FCB 3C            mov d, a          ; start of string data block
2556   0FCC 07 0D 11      call _gets        ; get program string
2557   0FCF               ;call _puts        ; reprint to screen
2558   0FCF 4D            mov si, a
2559   0FD0             __load_hex_loop:
2560   0FD0 F6            lodsb             ; load from [SI] to AL
2561   0FD1 B9 00         cmp al, 0         ; check if ASCII 0
2562   0FD3 C6 E1 0F      jz __load_hex_ret
2563   0FD6 36            mov bh, al
2564   0FD7 F6            lodsb
2565   0FD8 2F            mov bl, al
2566   0FD9 07 C3 10      call _atoi        ; convert ASCII byte in B to int (to AL)
2567   0FDC F7            stosb             ; store AL to [DI]
2568   0FDD 78            inc c
2569   0FDE 0A D0 0F      jmp __load_hex_loop
2570   0FE1             __load_hex_ret:
2571   0FE1 F0            pop di
2572   0FE2 EF            pop si
2573   0FE3 E7            pop d
2574   0FE4 E5            pop b
2575   0FE5 E4            pop a
2576   0FE6 09            ret
2577   0FE7             
2578   0FE7             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2579   0FE7             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2580   0FE7             ; for each entry insIDE DIRECTORY:
2581   0FE7             ;  if entry is a file:
2582   0FE7             ;    compare filename to searched filename
2583   0FE7             ;    if filenames are the same, print filename
2584   0FE7             ;  else if entry is a directory:
2585   0FE7             ;    cd to the given directory
2586   0FE7             ;    recursively call cmd_find
2587   0FE7             ;    cd outsIDE previous directory
2588   0FE7             ;  if current entry == last entry, return
2589   0FE7             ; endfor
2590   0FE7             f_find:
2591   0FE7 09            ret
2592   0FE8             
2593   0FE8             
2594   0FE8             ; ---------------------------------------------------------------------
2595   0FE8             ; KERNEL RESET VECTOR
2596   0FE8             ; ---------------------------------------------------------------------
2597   0FE8             kernel_reset_vector:  
2598   0FE8 FD 49 FF F7   mov bp, STACK_BEGIN
2599   0FEC FD 47 FF F7   mov sp, STACK_BEGIN
2600   0FF0               
2601   0FF0 19 81         mov al, %10000001
2602   0FF2 FD 0F         stomsk                        ; mask out timer interrupt for now (only allow UART to interrupt)
2603   0FF4 FD 0C         sti  
2604   0FF6             
2605   0FF6 0C            lodstat
2606   0FF7 87 DF         and al, %11011111             ; disable display register loading
2607   0FF9 0D            stostat
2608   0FFA               
2609   0FFA             ; reset fifo pointers
2610   0FFA 10 A9 20      mov a, fifo
2611   0FFD 3B 68 17      mov d, fifo_in
2612   1000 43            mov [d], a
2613   1001 3B 6A 17      mov d, fifo_out
2614   1004 43            mov [d], a  
2615   1005 19 02         mov al, 2
2616   1007 05 03         syscall sys_io                ; enable uart in interrupt mode
2617   1009               
2618   1009 3B AE 17      mov d, s_kernel_started
2619   100C 07 32 12      call _puts
2620   100F             
2621   100F 19 10         mov al, 16
2622   1011 05 04         syscall sys_filesystem        ; set root dirID
2623   1013             
2624   1013 3B CB 17      mov d, s_prompt_init
2625   1016 07 32 12      call _puts
2626   1019 3B 6E 17      mov d, s_init_path
2627   101C 05 05         syscall sys_create_proc              ; launch init as a new process
2628   101E             
2629   101E             
2630   101E             ; FILE INCLUDES
2631   101E             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  101E             BIOS_RESET_VECTOR .EQU  $01c0
0002+  101E             IDE_buffer       .EQU  $8204
0003+  101E             boot_origin      .EQU  $8004
0004+  101E             bios_uart        .EQU  $0002
0005+  101E             bios_ide         .EQU  $0003
2632   101E             .include "lib/stdio.asm"
0001+  101E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  101E             ; stdio.s
0003+  101E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  101E             .include "lib/string.asm"
0001++ 101E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 101E             ; string.s
0003++ 101E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 101E             
0005++ 101E             
0006++ 101E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 101E             ; _strrev
0008++ 101E             ; reverse a string
0009++ 101E             ; D = string address
0010++ 101E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 101E             ; 01234
0012++ 101E             _strrev:
0013++ 101E 4B          	pusha
0014++ 101F 07 65 10    	call _strlen	; length in C
0015++ 1022 12          	mov a, c
0016++ 1023 AF 01 00    	cmp a, 1
0017++ 1026 D0 40 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1029 7D          	dec a
0019++ 102A FD 4E       	mov si, d	; beginning of string
0020++ 102C FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 102E 59          	add d, a	; end of string
0022++ 102F 12          	mov a, c
0023++ 1030 FD 9B       	shr a		; divide by 2
0024++ 1032 39          	mov c, a	; C now counts the steps
0025++ 1033             _strrev_L0:
0026++ 1033 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1034 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1035 3E          	mov [d], al	; store left char into right side
0029++ 1036 1B          	mov al, bl
0030++ 1037 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1038 7E          	dec c
0032++ 1039 7F          	dec d
0033++ 103A C2 00 00    	cmp c, 0
0034++ 103D C7 33 10    	jne _strrev_L0
0035++ 1040             _strrev_end:
0036++ 1040 4C          	popa
0037++ 1041 09          	ret
0038++ 1042             	
0039++ 1042             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1042             ; _strchr
0041++ 1042             ; search string in D for char in AL
0042++ 1042             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1042             _strchr:
0044++ 1042             _strchr_L0:
0045++ 1042 32          	mov bl, [d]
0046++ 1043 C1 00       	cmp bl, 0
0047++ 1045 C6 50 10    	je _strchr_end
0048++ 1048 BA          	cmp al, bl
0049++ 1049 C6 50 10    	je _strchr_end
0050++ 104C 79          	inc d
0051++ 104D 0A 42 10    	jmp _strchr_L0
0052++ 1050             _strchr_end:
0053++ 1050 1B          	mov al, bl
0054++ 1051 09          	ret
0055++ 1052             
0056++ 1052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1052             ; _strstr
0058++ 1052             ; find sub-string
0059++ 1052             ; str1 in SI
0060++ 1052             ; str2 in DI
0061++ 1052             ; SI points to end of source string
0062++ 1052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1052             _strstr:
0064++ 1052 DB          	push al
0065++ 1053 DA          	push d
0066++ 1054 E3          	push di
0067++ 1055             _strstr_loop:
0068++ 1055 F3          	cmpsb					; compare a byte of the strings
0069++ 1056 C7 61 10    	jne _strstr_ret
0070++ 1059 FC 00 00    	lea d, [di + 0]
0071++ 105C BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 105E C7 55 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1061             _strstr_ret:
0074++ 1061 F0          	pop di
0075++ 1062 E7          	pop d
0076++ 1063 E8          	pop al
0077++ 1064 09          	ret
0078++ 1065             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1065             ; length of null terminated string
0080++ 1065             ; result in C
0081++ 1065             ; pointer in D
0082++ 1065             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1065             _strlen:
0084++ 1065 DA          	push d
0085++ 1066 38 00 00    	mov c, 0
0086++ 1069             _strlen_L1:
0087++ 1069 BD 00       	cmp byte [d], 0
0088++ 106B C6 73 10    	je _strlen_ret
0089++ 106E 79          	inc d
0090++ 106F 78          	inc c
0091++ 1070 0A 69 10    	jmp _strlen_L1
0092++ 1073             _strlen_ret:
0093++ 1073 E7          	pop d
0094++ 1074 09          	ret
0095++ 1075             
0096++ 1075             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1075             ; STRCMP
0098++ 1075             ; compare two strings
0099++ 1075             ; str1 in SI
0100++ 1075             ; str2 in DI
0101++ 1075             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1075             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1075             _strcmp:
0104++ 1075 DB          	push al
0105++ 1076 DA          	push d
0106++ 1077 E3          	push di
0107++ 1078 E2          	push si
0108++ 1079             _strcmp_loop:
0109++ 1079 F3          	cmpsb					; compare a byte of the strings
0110++ 107A C7 85 10    	jne _strcmp_ret
0111++ 107D FB FF FF    	lea d, [si +- 1]
0112++ 1080 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1082 C7 79 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1085             _strcmp_ret:
0115++ 1085 EF          	pop si
0116++ 1086 F0          	pop di
0117++ 1087 E7          	pop d
0118++ 1088 E8          	pop al
0119++ 1089 09          	ret
0120++ 108A             
0121++ 108A             
0122++ 108A             ; STRCPY
0123++ 108A             ; copy null terminated string from SI to DI
0124++ 108A             ; source in SI
0125++ 108A             ; destination in DI
0126++ 108A             _strcpy:
0127++ 108A E2          	push si
0128++ 108B E3          	push di
0129++ 108C DB          	push al
0130++ 108D             _strcpy_L1:
0131++ 108D F6          	lodsb
0132++ 108E F7          	stosb
0133++ 108F B9 00       	cmp al, 0
0134++ 1091 C7 8D 10    	jne _strcpy_L1
0135++ 1094             _strcpy_end:
0136++ 1094 E8          	pop al
0137++ 1095 F0          	pop di
0138++ 1096 EF          	pop si
0139++ 1097 09          	ret
0140++ 1098             
0141++ 1098             ; STRCAT
0142++ 1098             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1098             ; source in SI
0144++ 1098             ; destination in DI
0145++ 1098             _strcat:
0146++ 1098 E2          	push si
0147++ 1099 E3          	push di
0148++ 109A D7          	push a
0149++ 109B DA          	push d
0150++ 109C 50          	mov a, di
0151++ 109D 3C          	mov d, a
0152++ 109E             _strcat_goto_end_L1:
0153++ 109E BD 00       	cmp byte[d], 0
0154++ 10A0 C6 A7 10    	je _strcat_start
0155++ 10A3 79          	inc d
0156++ 10A4 0A 9E 10    	jmp _strcat_goto_end_L1
0157++ 10A7             _strcat_start:
0158++ 10A7 FD 50       	mov di, d
0159++ 10A9             _strcat_L1:
0160++ 10A9 F6          	lodsb
0161++ 10AA F7          	stosb
0162++ 10AB B9 00       	cmp al, 0
0163++ 10AD C7 A9 10    	jne _strcat_L1
0164++ 10B0             _strcat_end:
0165++ 10B0 E7          	pop d
0166++ 10B1 E4          	pop a
0167++ 10B2 F0          	pop di
0168++ 10B3 EF          	pop si
0169++ 10B4 09          	ret
0170++ 10B5             
0171++ 10B5             
0005+  10B5             
0006+  10B5             
0007+  10B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  10B5             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  10B5             ; ASCII in BL
0010+  10B5             ; result in AL
0011+  10B5             ; ascii for F = 0100 0110
0012+  10B5             ; ascii for 9 = 0011 1001
0013+  10B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  10B5             hex_ascii_encode:
0015+  10B5 1B            mov al, bl
0016+  10B6 93 40         test al, $40        ; test if letter or number
0017+  10B8 C7 BE 10      jnz hex_letter
0018+  10BB 87 0F         and al, $0F        ; get number
0019+  10BD 09            ret
0020+  10BE             hex_letter:
0021+  10BE 87 0F         and al, $0F        ; get letter
0022+  10C0 6A 09         add al, 9
0023+  10C2 09            ret
0024+  10C3             
0025+  10C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  10C3             ; ATOI
0027+  10C3             ; 2 letter hex string in B
0028+  10C3             ; 8bit integer returned in AL
0029+  10C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  10C3             _atoi:
0031+  10C3 D8            push b
0032+  10C4 07 B5 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  10C7 30            mov bl, bh
0034+  10C8 DB            push al          ; save a
0035+  10C9 07 B5 10      call hex_ascii_encode
0036+  10CC EA            pop bl  
0037+  10CD FD 9E 04      shl al, 4
0038+  10D0 8C            or al, bl
0039+  10D1 E5            pop b
0040+  10D2 09            ret  
0041+  10D3             
0042+  10D3             
0043+  10D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  10D3             ; scanf
0045+  10D3             ; no need for explanations!
0046+  10D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  10D3             scanf:
0048+  10D3 09            ret
0049+  10D4             
0050+  10D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  10D4             ; ITOA
0052+  10D4             ; 8bit value in BL
0053+  10D4             ; 2 byte ASCII result in A
0054+  10D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  10D4             _itoa:
0056+  10D4 DA            push d
0057+  10D5 D8            push b
0058+  10D6 A7 00         mov bh, 0
0059+  10D8 FD A4 04      shr bl, 4  
0060+  10DB 74            mov d, b
0061+  10DC 1F 6E 13      mov al, [d + s_hex_digits]
0062+  10DF 23            mov ah, al
0063+  10E0               
0064+  10E0 E5            pop b
0065+  10E1 D8            push b
0066+  10E2 A7 00         mov bh, 0
0067+  10E4 FD 87 0F      and bl, $0F
0068+  10E7 74            mov d, b
0069+  10E8 1F 6E 13      mov al, [d + s_hex_digits]
0070+  10EB E5            pop b
0071+  10EC E7            pop d
0072+  10ED 09            ret
0073+  10EE             
0074+  10EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  10EE             ; HEX STRING TO BINARY
0076+  10EE             ; di = destination address
0077+  10EE             ; si = source
0078+  10EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  10EE             _hex_to_int:
0080+  10EE             _hex_to_int_L1:
0081+  10EE F6            lodsb          ; load from [SI] to AL
0082+  10EF B9 00         cmp al, 0        ; check if ASCII 0
0083+  10F1 C6 FE 10      jz _hex_to_int_ret
0084+  10F4 36            mov bh, al
0085+  10F5 F6            lodsb
0086+  10F6 2F            mov bl, al
0087+  10F7 07 C3 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  10FA F7            stosb          ; store AL to [DI]
0089+  10FB 0A EE 10      jmp _hex_to_int_L1
0090+  10FE             _hex_to_int_ret:
0091+  10FE 09            ret    
0092+  10FF             
0093+  10FF             
0094+  10FF             
0095+  10FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  10FF             ; GETCHAR
0097+  10FF             ; char in ah
0098+  10FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  10FF             getch:
0100+  10FF DB            push al
0101+  1100             getch_retry:
0102+  1100 19 01         mov al, 1
0103+  1102 05 03         syscall sys_io      ; receive in AH
0104+  1104 E8            pop al
0105+  1105 09            ret
0106+  1106             
0107+  1106             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  1106             ; PUTCHAR
0109+  1106             ; char in ah
0110+  1106             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  1106             _putchar:
0112+  1106 DB            push al
0113+  1107 19 00         mov al, 0
0114+  1109 05 03         syscall sys_io      ; char in AH
0115+  110B E8            pop al
0116+  110C 09            ret
0117+  110D             
0118+  110D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  110D             ;; INPUT A STRING
0120+  110D             ;; terminates with null
0121+  110D             ;; pointer in D
0122+  110D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  110D             _gets:
0124+  110D D7            push a
0125+  110E DA            push d
0126+  110F             _gets_loop:
0127+  110F 19 01         mov al, 1
0128+  1111 05 03         syscall sys_io      ; receive in AH
0129+  1113 76 1B         cmp ah, 27
0130+  1115 C6 36 11      je _gets_ansi_esc
0131+  1118 76 0A         cmp ah, $0A        ; LF
0132+  111A C6 92 11      je _gets_end
0133+  111D 76 0D         cmp ah, $0D        ; CR
0134+  111F C6 92 11      je _gets_end
0135+  1122 76 5C         cmp ah, $5C        ; '\\'
0136+  1124 C6 58 11      je _gets_escape
0137+  1127 76 08         cmp ah, $08      ; check for backspace
0138+  1129 C6 32 11      je _gets_backspace
0139+  112C 1A            mov al, ah
0140+  112D 3E            mov [d], al
0141+  112E 79            inc d
0142+  112F 0A 0F 11      jmp _gets_loop
0143+  1132             _gets_backspace:
0144+  1132 7F            dec d
0145+  1133 0A 0F 11      jmp _gets_loop
0146+  1136             _gets_ansi_esc:
0147+  1136 19 01         mov al, 1
0148+  1138 05 03         syscall sys_io        ; receive in AH without echo
0149+  113A 76 5B         cmp ah, '['
0150+  113C C7 0F 11      jne _gets_loop
0151+  113F 19 01         mov al, 1
0152+  1141 05 03         syscall sys_io          ; receive in AH without echo
0153+  1143 76 44         cmp ah, 'D'
0154+  1145 C6 50 11      je _gets_left_arrow
0155+  1148 76 43         cmp ah, 'C'
0156+  114A C6 54 11      je _gets_right_arrow
0157+  114D 0A 0F 11      jmp _gets_loop
0158+  1150             _gets_left_arrow:
0159+  1150 7F            dec d
0160+  1151 0A 0F 11      jmp _gets_loop
0161+  1154             _gets_right_arrow:
0162+  1154 79            inc d
0163+  1155 0A 0F 11      jmp _gets_loop
0164+  1158             _gets_escape:
0165+  1158 19 01         mov al, 1
0166+  115A 05 03         syscall sys_io      ; receive in AH
0167+  115C 76 6E         cmp ah, 'n'
0168+  115E C6 7D 11      je _gets_LF
0169+  1161 76 72         cmp ah, 'r'
0170+  1163 C6 84 11      je _gets_CR
0171+  1166 76 30         cmp ah, '0'
0172+  1168 C6 8B 11      je _gets_NULL
0173+  116B 76 5C         cmp ah, $5C  ; '\'
0174+  116D C6 76 11      je _gets_slash
0175+  1170 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  1171 3E            mov [d], al
0177+  1172 79            inc d
0178+  1173 0A 0F 11      jmp _gets_loop
0179+  1176             _gets_slash:
0180+  1176 19 5C         mov al, $5C
0181+  1178 3E            mov [d], al
0182+  1179 79            inc d
0183+  117A 0A 0F 11      jmp _gets_loop
0184+  117D             _gets_LF:
0185+  117D 19 0A         mov al, $0A
0186+  117F 3E            mov [d], al
0187+  1180 79            inc d
0188+  1181 0A 0F 11      jmp _gets_loop
0189+  1184             _gets_CR:
0190+  1184 19 0D         mov al, $0D
0191+  1186 3E            mov [d], al
0192+  1187 79            inc d
0193+  1188 0A 0F 11      jmp _gets_loop
0194+  118B             _gets_NULL:
0195+  118B 19 00         mov al, $00
0196+  118D 3E            mov [d], al
0197+  118E 79            inc d
0198+  118F 0A 0F 11      jmp _gets_loop
0199+  1192             _gets_end:
0200+  1192 19 00         mov al, 0
0201+  1194 3E            mov [d], al        ; terminate string
0202+  1195 E7            pop d
0203+  1196 E4            pop a
0204+  1197 09            ret
0205+  1198             
0206+  1198             
0207+  1198             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1198             ;; INPUT TEXT
0209+  1198             ;; terminated with CTRL+D
0210+  1198             ;; pointer in D
0211+  1198             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1198             _gettxt:
0213+  1198 D7            push a
0214+  1199 DA            push d
0215+  119A             _gettxt_loop:
0216+  119A 19 01         mov al, 1
0217+  119C 05 03         syscall sys_io      ; receive in AH
0218+  119E 76 04         cmp ah, 4      ; EOT
0219+  11A0 C6 D9 11      je _gettxt_end
0220+  11A3 76 08         cmp ah, $08      ; check for backspace
0221+  11A5 C6 D5 11      je _gettxt_backspace
0222+  11A8 76 5C         cmp ah, $5C        ; '\'
0223+  11AA C6 B3 11      je _gettxt_escape
0224+  11AD 1A            mov al, ah
0225+  11AE 3E            mov [d], al
0226+  11AF 79            inc d
0227+  11B0 0A 9A 11      jmp _gettxt_loop
0228+  11B3             _gettxt_escape:
0229+  11B3 19 01         mov al, 1
0230+  11B5 05 03         syscall sys_io      ; receive in AH
0231+  11B7 76 6E         cmp ah, 'n'
0232+  11B9 C6 C7 11      je _gettxt_LF
0233+  11BC 76 72         cmp ah, 'r'
0234+  11BE C6 CE 11      je _gettxt_CR
0235+  11C1 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  11C2 3E            mov [d], al
0237+  11C3 79            inc d
0238+  11C4 0A 9A 11      jmp _gettxt_loop
0239+  11C7             _gettxt_LF:
0240+  11C7 19 0A         mov al, $0A
0241+  11C9 3E            mov [d], al
0242+  11CA 79            inc d
0243+  11CB 0A 9A 11      jmp _gettxt_loop
0244+  11CE             _gettxt_CR:
0245+  11CE 19 0D         mov al, $0D
0246+  11D0 3E            mov [d], al
0247+  11D1 79            inc d
0248+  11D2 0A 9A 11      jmp _gettxt_loop
0249+  11D5             _gettxt_backspace:
0250+  11D5 7F            dec d
0251+  11D6 0A 9A 11      jmp _gettxt_loop
0252+  11D9             _gettxt_end:
0253+  11D9 19 00         mov al, 0
0254+  11DB 3E            mov [d], al        ; terminate string
0255+  11DC E7            pop d
0256+  11DD E4            pop a
0257+  11DE 09            ret
0258+  11DF             
0259+  11DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  11DF             ; PRINT NEW LINE
0261+  11DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  11DF             printnl:
0263+  11DF D7            push a
0264+  11E0 10 00 0A      mov a, $0A00
0265+  11E3 05 03         syscall sys_io
0266+  11E5 10 00 0D      mov a, $0D00
0267+  11E8 05 03         syscall sys_io
0268+  11EA E4            pop a
0269+  11EB 09            ret
0270+  11EC             
0271+  11EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  11EC             ; _strtoint
0273+  11EC             ; 4 digit hex string number in d
0274+  11EC             ; integer returned in A
0275+  11EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  11EC             _strtointx:
0277+  11EC D8            push b
0278+  11ED 32            mov bl, [d]
0279+  11EE 37            mov bh, bl
0280+  11EF 33 01 00      mov bl, [d + 1]
0281+  11F2 07 C3 10      call _atoi        ; convert to int in AL
0282+  11F5 23            mov ah, al        ; move to AH
0283+  11F6 33 02 00      mov bl, [d + 2]
0284+  11F9 37            mov bh, bl
0285+  11FA 33 03 00      mov bl, [d + 3]
0286+  11FD 07 C3 10      call _atoi        ; convert to int in AL
0287+  1200 E5            pop b
0288+  1201 09            ret
0289+  1202             
0290+  1202             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1202             ; _strtoint
0292+  1202             ; 5 digit base10 string number in d
0293+  1202             ; integer returned in A
0294+  1202             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1202             _strtoint:
0296+  1202 E2            push si
0297+  1203 D8            push b
0298+  1204 D9            push c
0299+  1205 DA            push d
0300+  1206 07 65 10      call _strlen      ; get string length in C
0301+  1209 7E            dec c
0302+  120A FD 4E         mov si, d
0303+  120C 12            mov a, c
0304+  120D FD 99         shl a
0305+  120F 3B 86 13      mov d, table_power
0306+  1212 59            add d, a
0307+  1213 38 00 00      mov c, 0
0308+  1216             _strtoint_L0:
0309+  1216 F6            lodsb      ; load ASCII to al
0310+  1217 B9 00         cmp al, 0
0311+  1219 C6 2C 12      je _strtoint_end
0312+  121C 6F 30         sub al, $30    ; make into integer
0313+  121E 22 00         mov ah, 0
0314+  1220 2A            mov b, [d]
0315+  1221 AC            mul a, b      ; result in B since it fits in 16bits
0316+  1222 11            mov a, b
0317+  1223 28            mov b, c
0318+  1224 54            add a, b
0319+  1225 39            mov c, a
0320+  1226 63 02 00      sub d, 2
0321+  1229 0A 16 12      jmp _strtoint_L0
0322+  122C             _strtoint_end:
0323+  122C 12            mov a, c
0324+  122D E7            pop d
0325+  122E E6            pop c
0326+  122F E5            pop b
0327+  1230 EF            pop si
0328+  1231 09            ret
0329+  1232             
0330+  1232             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1232             ; PRINT NULL TERMINATED STRING
0332+  1232             ; pointer in D
0333+  1232             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1232             _puts:
0335+  1232 D7            push a
0336+  1233 DA            push d
0337+  1234             _puts_L1:
0338+  1234 1E            mov al, [d]
0339+  1235 B9 00         cmp al, 0
0340+  1237 C6 43 12      jz _puts_END
0341+  123A 23            mov ah, al
0342+  123B 19 00         mov al, 0
0343+  123D 05 03         syscall sys_io
0344+  123F 79            inc d
0345+  1240 0A 34 12      jmp _puts_L1
0346+  1243             _puts_END:
0347+  1243 E7            pop d
0348+  1244 E4            pop a
0349+  1245 09            ret
0350+  1246             
0351+  1246             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  1246             ; PRINT N SIZE STRING
0353+  1246             ; pointer in D
0354+  1246             ; size in C
0355+  1246             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  1246             _putsn:
0357+  1246 DB            push al
0358+  1247 DA            push d
0359+  1248 D9            push c
0360+  1249             _putsn_L0:
0361+  1249 1E            mov al, [d]
0362+  124A 23            mov ah, al
0363+  124B 19 00         mov al, 0
0364+  124D 05 03         syscall sys_io
0365+  124F 79            inc d
0366+  1250 7E            dec c  
0367+  1251 C2 00 00      cmp c, 0
0368+  1254 C7 49 12      jne _putsn_L0
0369+  1257             _putsn_end:
0370+  1257 E6            pop c
0371+  1258 E7            pop d
0372+  1259 E8            pop al
0373+  125A 09            ret
0374+  125B             
0375+  125B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  125B             ; print 16bit decimal number
0377+  125B             ; input number in A
0378+  125B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  125B             print_u16d:
0380+  125B D7            push a
0381+  125C D8            push b
0382+  125D FD D8         push g
0383+  125F 26 10 27      mov b, 10000
0384+  1262 AE            div a, b      ; get 10000's coeff.
0385+  1263 07 87 12      call print_number
0386+  1266 11            mov a, b
0387+  1267 26 E8 03      mov b, 1000
0388+  126A AE            div a, b      ; get 1000's coeff.
0389+  126B 07 87 12      call print_number
0390+  126E 11            mov a, b
0391+  126F 26 64 00      mov b, 100
0392+  1272 AE            div a, b
0393+  1273 07 87 12      call print_number
0394+  1276 11            mov a, b
0395+  1277 26 0A 00      mov b, 10
0396+  127A AE            div a, b
0397+  127B 07 87 12      call print_number
0398+  127E 1B            mov al, bl      ; 1's coeff in bl
0399+  127F 07 87 12      call print_number
0400+  1282 FD F1         pop g
0401+  1284 E5            pop b
0402+  1285 E4            pop a
0403+  1286 09            ret
0404+  1287             
0405+  1287             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1287             ; print AL
0407+  1287             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1287             print_number:
0409+  1287 6A 30         add al, $30
0410+  1289 23            mov ah, al
0411+  128A 07 06 11      call _putchar
0412+  128D 09            ret
0413+  128E             
0414+  128E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  128E             ; PRINT 16BIT HEX INTEGER
0416+  128E             ; integer value in reg B
0417+  128E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  128E             print_u16x:
0419+  128E D7            push a
0420+  128F D8            push b
0421+  1290 DD            push bl
0422+  1291 30            mov bl, bh
0423+  1292 07 D4 10      call _itoa        ; convert bh to char in A
0424+  1295 2F            mov bl, al        ; save al
0425+  1296 19 00         mov al, 0
0426+  1298 05 03         syscall sys_io        ; display AH
0427+  129A 24            mov ah, bl        ; retrieve al
0428+  129B 19 00         mov al, 0
0429+  129D 05 03         syscall sys_io        ; display AL
0430+  129F             
0431+  129F EA            pop bl
0432+  12A0 07 D4 10      call _itoa        ; convert bh to char in A
0433+  12A3 2F            mov bl, al        ; save al
0434+  12A4 19 00         mov al, 0
0435+  12A6 05 03         syscall sys_io        ; display AH
0436+  12A8 24            mov ah, bl        ; retrieve al
0437+  12A9 19 00         mov al, 0
0438+  12AB 05 03         syscall sys_io        ; display AL
0439+  12AD             
0440+  12AD E5            pop b
0441+  12AE E4            pop a
0442+  12AF 09            ret
0443+  12B0             
0444+  12B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  12B0             ; INPUT 16BIT HEX INTEGER
0446+  12B0             ; read 16bit integer into A
0447+  12B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  12B0             scan_u16x:
0449+  12B0 F8 10 00      enter 16
0450+  12B3 D8            push b
0451+  12B4 DA            push d
0452+  12B5             
0453+  12B5 FA F1 FF      lea d, [bp + -15]
0454+  12B8 07 0D 11      call _gets        ; get number
0455+  12BB             
0456+  12BB 32            mov bl, [d]
0457+  12BC 37            mov bh, bl
0458+  12BD 33 01 00      mov bl, [d + 1]
0459+  12C0 07 C3 10      call _atoi        ; convert to int in AL
0460+  12C3 23            mov ah, al        ; move to AH
0461+  12C4             
0462+  12C4 33 02 00      mov bl, [d + 2]
0463+  12C7 37            mov bh, bl
0464+  12C8 33 03 00      mov bl, [d + 3]
0465+  12CB 07 C3 10      call _atoi        ; convert to int in AL
0466+  12CE             
0467+  12CE E7            pop d
0468+  12CF E5            pop b
0469+  12D0 F9            leave
0470+  12D1 09            ret
0471+  12D2             
0472+  12D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  12D2             ; PRINT 8bit HEX INTEGER
0474+  12D2             ; integer value in reg bl
0475+  12D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  12D2             print_u8x:
0477+  12D2 D7            push a
0478+  12D3 DD            push bl
0479+  12D4             
0480+  12D4 07 D4 10      call _itoa        ; convert bl to char in A
0481+  12D7 2F            mov bl, al        ; save al
0482+  12D8 19 00         mov al, 0
0483+  12DA 05 03         syscall sys_io        ; display AH
0484+  12DC 24            mov ah, bl        ; retrieve al
0485+  12DD 19 00         mov al, 0
0486+  12DF 05 03         syscall sys_io        ; display AL
0487+  12E1             
0488+  12E1 EA            pop bl
0489+  12E2 E4            pop a
0490+  12E3 09            ret
0491+  12E4             
0492+  12E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  12E4             ; print 8bit decimal unsigned number
0494+  12E4             ; input number in AL
0495+  12E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  12E4             print_u8d:
0497+  12E4 D7            push a
0498+  12E5 D8            push b
0499+  12E6 FD D8         push g
0500+  12E8 22 00         mov ah, 0
0501+  12EA 26 64 00      mov b, 100
0502+  12ED AE            div a, b
0503+  12EE D8            push b      ; save remainder
0504+  12EF B9 00         cmp al, 0
0505+  12F1 C6 FB 12      je skip100
0506+  12F4 6A 30         add al, $30
0507+  12F6 23            mov ah, al
0508+  12F7 19 00         mov al, 0
0509+  12F9 05 03         syscall sys_io  ; print coeff
0510+  12FB             skip100:
0511+  12FB E4            pop a
0512+  12FC 22 00         mov ah, 0
0513+  12FE 26 0A 00      mov b, 10
0514+  1301 AE            div a, b
0515+  1302 D8            push b      ; save remainder
0516+  1303 B9 00         cmp al, 0
0517+  1305 C6 0F 13      je skip10
0518+  1308 6A 30         add al, $30
0519+  130A 23            mov ah, al
0520+  130B 19 00         mov al, 0
0521+  130D 05 03         syscall sys_io  ; print coeff
0522+  130F             skip10:
0523+  130F E4            pop a
0524+  1310 1B            mov al, bl
0525+  1311 6A 30         add al, $30
0526+  1313 23            mov ah, al
0527+  1314 19 00         mov al, 0
0528+  1316 05 03         syscall sys_io  ; print coeff
0529+  1318 FD F1         pop g
0530+  131A E5            pop b
0531+  131B E4            pop a
0532+  131C 09            ret
0533+  131D             
0534+  131D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  131D             ; INPUT 8BIT HEX INTEGER
0536+  131D             ; read 8bit integer into AL
0537+  131D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  131D             scan_u8x:
0539+  131D F8 04 00      enter 4
0540+  1320 D8            push b
0541+  1321 DA            push d
0542+  1322             
0543+  1322 FA FD FF      lea d, [bp + -3]
0544+  1325 07 0D 11      call _gets        ; get number
0545+  1328             
0546+  1328 32            mov bl, [d]
0547+  1329 37            mov bh, bl
0548+  132A 33 01 00      mov bl, [d + 1]
0549+  132D 07 C3 10      call _atoi        ; convert to int in AL
0550+  1330             
0551+  1330 E7            pop d
0552+  1331 E5            pop b
0553+  1332 F9            leave
0554+  1333 09            ret
0555+  1334             
0556+  1334             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1334             ; input decimal number
0558+  1334             ; result in A
0559+  1334             ; 655'\0'
0560+  1334             ; low--------high
0561+  1334             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1334             scan_u16d:
0563+  1334 F8 08 00      enter 8
0564+  1337 E2            push si
0565+  1338 D8            push b
0566+  1339 D9            push c
0567+  133A DA            push d
0568+  133B FA F9 FF      lea d, [bp +- 7]
0569+  133E 07 0D 11      call _gets
0570+  1341 07 65 10      call _strlen      ; get string length in C
0571+  1344 7E            dec c
0572+  1345 FD 4E         mov si, d
0573+  1347 12            mov a, c
0574+  1348 FD 99         shl a
0575+  134A 3B 86 13      mov d, table_power
0576+  134D 59            add d, a
0577+  134E 38 00 00      mov c, 0
0578+  1351             mul_loop:
0579+  1351 F6            lodsb      ; load ASCII to al
0580+  1352 B9 00         cmp al, 0
0581+  1354 C6 67 13      je mul_exit
0582+  1357 6F 30         sub al, $30    ; make into integer
0583+  1359 22 00         mov ah, 0
0584+  135B 2A            mov b, [d]
0585+  135C AC            mul a, b      ; result in B since it fits in 16bits
0586+  135D 11            mov a, b
0587+  135E 28            mov b, c
0588+  135F 54            add a, b
0589+  1360 39            mov c, a
0590+  1361 63 02 00      sub d, 2
0591+  1364 0A 51 13      jmp mul_loop
0592+  1367             mul_exit:
0593+  1367 12            mov a, c
0594+  1368 E7            pop d
0595+  1369 E6            pop c
0596+  136A E5            pop b
0597+  136B EF            pop si
0598+  136C F9            leave
0599+  136D 09            ret
0600+  136E             
0601+  136E             
0602+  136E 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  1372 34 35 36 37 
0602+  1376 38 39 41 42 
0602+  137A 43 44 45 46 
0603+  137E 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  1382 1B 5B 48 00 
0604+  1386             
0605+  1386             table_power:
0606+  1386 01 00         .dw 1
0607+  1388 0A 00         .dw 10
0608+  138A 64 00         .dw 100
0609+  138C E8 03         .dw 1000
0610+  138E 10 27         .dw 100002633   1390             .include "lib/ctype.asm"
0001+  1390             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1390             ; ctype.s
0003+  1390             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1390             
0005+  1390             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  1390             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  1390             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  1390             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  1390             ;; characters are supported.
0010+  1390             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  1390             ;; _isalnum 
0012+  1390             ;; _isalpha 
0013+  1390             ;; islower 
0014+  1390             ;; isupper 
0015+  1390             ;; _isdigit 
0016+  1390             ;; isxdigit
0017+  1390             ;; iscntrl 
0018+  1390             ;; isgraph 
0019+  1390             ;; _isspace 
0020+  1390             ;; isblank 
0021+  1390             ;; isprint 
0022+  1390             ;; ispunct 
0023+  1390             ;; tolower 
0024+  1390             ;; toupper
0025+  1390             
0026+  1390             
0027+  1390             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  1390             ;; IS ALPHANUMERIC
0029+  1390             ;; sets ZF according with result
0030+  1390             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  1390             _isalnum:
0032+  1390 07 AD 13    	call _isalpha
0033+  1393 C6 99 13    	je _isalnum_exit
0034+  1396 07 9A 13    	call _isdigit
0035+  1399             _isalnum_exit:
0036+  1399 09          	ret	
0037+  139A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  139A             ;; IS DIGIT
0039+  139A             ;; sets ZF according with result
0040+  139A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  139A             _isdigit:
0042+  139A DB          	push al
0043+  139B B9 30       	cmp al, '0'
0044+  139D C8 A9 13    	jlu _isdigit_false
0045+  13A0 B9 39       	cmp al, '9'
0046+  13A2 D1 A9 13    	jgu _isdigit_false
0047+  13A5 87 00       	and al, 0	; set ZF
0048+  13A7 E8          	pop al
0049+  13A8 09          	ret
0050+  13A9             _isdigit_false:
0051+  13A9 8B 01       	or al, 1	; clear ZF
0052+  13AB E8          	pop al
0053+  13AC 09          	ret	
0054+  13AD             	
0055+  13AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  13AD             ;; IS ALPHA
0057+  13AD             ;; sets ZF according with result
0058+  13AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  13AD             _isalpha:
0060+  13AD DB          	push al
0061+  13AE B9 5F       	cmp al, '_'
0062+  13B0 C6 D0 13    	je _isalpha_true
0063+  13B3 B9 2E       	cmp al, '.'
0064+  13B5 C6 D0 13    	je _isalpha_true
0065+  13B8 B9 41       	cmp al, 'A'
0066+  13BA C8 CC 13    	jlu _isalpha_false
0067+  13BD B9 7A       	cmp al, 'z'
0068+  13BF D1 CC 13    	jgu _isalpha_false
0069+  13C2 B9 5A       	cmp al, 'Z'
0070+  13C4 D0 D0 13    	jleu _isalpha_true
0071+  13C7 B9 61       	cmp al, 'a'
0072+  13C9 C9 D0 13    	jgeu _isalpha_true
0073+  13CC             _isalpha_false:
0074+  13CC 8B 01       	or al, 1	; clear ZF
0075+  13CE E8          	pop al
0076+  13CF 09          	ret
0077+  13D0             _isalpha_true:
0078+  13D0 87 00       	and al, 0	; set ZF
0079+  13D2 E8          	pop al
0080+  13D3 09          	ret
0081+  13D4             
0082+  13D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  13D4             ;; IS PATH-ALPHA
0084+  13D4             ;; sets ZF according with result
0085+  13D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  13D4             ispath:
0087+  13D4 DB          	push al
0088+  13D5 07 9A 13    	call _isdigit
0089+  13D8 C6 02 14    	je ispath_true
0090+  13DB B9 5F       	cmp al, '_'
0091+  13DD C6 02 14    	je ispath_true
0092+  13E0 B9 2F       	cmp al, '/'
0093+  13E2 C6 02 14    	je ispath_true
0094+  13E5 B9 2E       	cmp al, '.'
0095+  13E7 C6 02 14    	je ispath_true
0096+  13EA B9 41       	cmp al, 'A'
0097+  13EC C8 FE 13    	jlu ispath_false
0098+  13EF B9 7A       	cmp al, 'z'
0099+  13F1 D1 FE 13    	jgu ispath_false
0100+  13F4 B9 5A       	cmp al, 'Z'
0101+  13F6 D0 02 14    	jleu ispath_true
0102+  13F9 B9 61       	cmp al, 'a'
0103+  13FB C9 02 14    	jgeu ispath_true
0104+  13FE             ispath_false:
0105+  13FE 8B 01       	or al, 1	; clear ZF
0106+  1400 E8          	pop al
0107+  1401 09          	ret
0108+  1402             ispath_true:
0109+  1402 87 00       	and al, 0	; set ZF
0110+  1404 E8          	pop al
0111+  1405 09          	ret
0112+  1406             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  1406             ;; IS SPACE
0114+  1406             ;; sets ZF according with result
0115+  1406             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  1406             _isspace:
0117+  1406 B9 20       	cmp al, $20		; ' '
0118+  1408 C6 1C 14    	je _isspace_exit
0119+  140B B9 09       	cmp al, $09		; '\t'
0120+  140D C6 1C 14    	je _isspace_exit
0121+  1410 B9 0A       	cmp al, $0A		; '\n'
0122+  1412 C6 1C 14    	je _isspace_exit
0123+  1415 B9 0D       	cmp al, $0D		; '\r'
0124+  1417 C6 1C 14    	je _isspace_exit
0125+  141A B9 0B       	cmp al, $0B		; '\v'
0126+  141C             _isspace_exit:
0127+  141C 09          	ret	
0128+  141D             
0129+  141D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  141D             ; TO LOWER
0131+  141D             ; input in AL
0132+  141D             ; output in AL
0133+  141D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  141D             _to_lower:
0135+  141D B9 5A       	cmp al, 'Z'
0136+  141F D1 24 14    	jgu _to_lower_ret
0137+  1422 6A 20       	add al, $20				; convert to lower case
0138+  1424             _to_lower_ret:
0139+  1424 09          	ret
0140+  1425             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1425             ; TO UPPER
0142+  1425             ; input in AL
0143+  1425             ; output in AL
0144+  1425             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1425             _to_upper:
0146+  1425 B9 61       	cmp al, 'a'
0147+  1427 C8 2C 14    	jlu _to_upper_ret
0148+  142A 6F 20       	sub al, $20			; convert to upper case
0149+  142C             _to_upper_ret:
0150+  142C 09          	ret
0151+  142D             
2634   142D             .include "lib/token.asm"
0001+  142D             TOKTYP_IDENTIFIER  .equ 0
0002+  142D             TOKTYP_KEYWORD     .equ 1
0003+  142D             TOKTYP_DELIMITER   .equ 2
0004+  142D             TOKTYP_STRING      .equ 3
0005+  142D             TOKTYP_CHAR        .equ 4
0006+  142D             TOKTYP_NUMERIC     .equ 5
0007+  142D             TOKTYP_END         .equ 6
0008+  142D             
0009+  142D             TOK_NULL           .equ 0
0010+  142D             TOK_FSLASH         .equ 1
0011+  142D             TOK_TIMES          .equ 2
0012+  142D             TOK_PLUS           .equ 3
0013+  142D             TOK_MINUS          .equ 4
0014+  142D             TOK_DOT            .equ 5
0015+  142D             TOK_SEMI           .equ 6
0016+  142D             TOK_ANGLE          .equ 7
0017+  142D             TOK_TILDE          .equ 8
0018+  142D             TOK_EQUAL          .equ 9
0019+  142D             TOK_COLON          .equ 10
0020+  142D             TOK_COMMA          .equ 11
0021+  142D             
0022+  142D             TOK_END            .equ 20
0023+  142D             
0024+  142D             
0025+  142D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  142D             ;; read a full command argment from shell input buffer
0027+  142D             ;; argument is written into tokstr
0028+  142D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  142D             get_arg:
0030+  142D D7            push a
0031+  142E E2            push si
0032+  142F E3            push di
0033+  1430 19 00         mov al, 0
0034+  1432 3D 5B 16      mov [tokstr], al      ; nullify tokstr string
0035+  1435 14 57 16      mov a, [prog]
0036+  1438 4D            mov si, a
0037+  1439 FD 4F 5B 16   mov di, tokstr
0038+  143D             get_arg_skip_spaces:
0039+  143D F6            lodsb
0040+  143E 07 06 14      call _isspace
0041+  1441 C6 3D 14      je get_arg_skip_spaces
0042+  1444             get_arg_L0:
0043+  1444 B9 3B         cmp al, $3B        ; check if is ';'
0044+  1446 C6 53 14      je get_arg_end
0045+  1449 B9 00         cmp al, 0
0046+  144B C6 53 14      je get_arg_end      ; check if end of input
0047+  144E F7            stosb
0048+  144F F6            lodsb
0049+  1450 0A 44 14      jmp get_arg_L0
0050+  1453             get_arg_end:
0051+  1453 19 00         mov al, 0
0052+  1455 F7            stosb
0053+  1456 D5 01 00      sub si, 1
0054+  1459 4E            mov a, si
0055+  145A 42 57 16      mov [prog], a    ; update pointer
0056+  145D F0            pop di
0057+  145E EF            pop si
0058+  145F E4            pop a
0059+  1460 09            ret
0060+  1461             
0061+  1461             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  1461             ;; read a path formation from shell input buffer
0063+  1461             ;; path is written into tokstr
0064+  1461             ;; /usr/bin
0065+  1461             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  1461             get_path:
0067+  1461 D7            push a
0068+  1462 E2            push si
0069+  1463 E3            push di
0070+  1464 19 00         mov al, 0
0071+  1466 3D 5B 16      mov [tokstr], al      ; nullify tokstr string
0072+  1469 14 57 16      mov a, [prog]
0073+  146C 4D            mov si, a
0074+  146D FD 4F 5B 16   mov di, tokstr
0075+  1471             get_path_skip_spaces:
0076+  1471 F6            lodsb
0077+  1472 07 06 14      call _isspace
0078+  1475 C6 71 14      je get_path_skip_spaces
0079+  1478             get_path_is_pathchar:
0080+  1478 F7            stosb
0081+  1479 F6            lodsb
0082+  147A 07 90 13      call _isalnum      ;check if is alphanumeric
0083+  147D C6 78 14      je get_path_is_pathchar
0084+  1480 B9 2F         cmp al, '/'        ; check if is '/'
0085+  1482 C6 78 14      je get_path_is_pathchar
0086+  1485 19 00         mov al, 0
0087+  1487 F7            stosb
0088+  1488 D5 01 00      sub si, 1
0089+  148B 4E            mov a, si
0090+  148C 42 57 16      mov [prog], a    ; update pointer
0091+  148F             get_path_end:
0092+  148F F0            pop di
0093+  1490 EF            pop si
0094+  1491 E4            pop a
0095+  1492 09            ret
0096+  1493             
0097+  1493             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  1493             ;; read a line
0099+  1493             ;; line is written into tokstr
0100+  1493             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  1493             get_line:
0102+  1493 D7            push a
0103+  1494 E2            push si
0104+  1495 E3            push di
0105+  1496 19 00         mov al, 0
0106+  1498 3D 5B 16      mov [tokstr], al      ; nullify tokstr string
0107+  149B 14 57 16      mov a, [prog]
0108+  149E 4D            mov si, a
0109+  149F FD 4F 5B 16   mov di, tokstr
0110+  14A3             get_line_L0:
0111+  14A3 F6            lodsb
0112+  14A4 B9 0A         cmp al, $0A    ; check for new line
0113+  14A6 C6 AD 14      je get_line_exit
0114+  14A9 F7            stosb
0115+  14AA 0A A3 14      jmp get_line_L0
0116+  14AD             get_line_exit:
0117+  14AD 19 00         mov al, 0
0118+  14AF F7            stosb
0119+  14B0 4E            mov a, si
0120+  14B1 42 57 16      mov [prog], a    ; update pointer
0121+  14B4 F0            pop di
0122+  14B5 EF            pop si
0123+  14B6 E4            pop a
0124+  14B7 09            ret
0125+  14B8             
0126+  14B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  14B8             ;; token parser
0128+  14B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  14B8             get_token:
0130+  14B8 D7            push a
0131+  14B9 DA            push d
0132+  14BA E2            push si
0133+  14BB E3            push di
0134+  14BC 19 00         mov al, 0
0135+  14BE 3D 5B 16      mov [tokstr], al      ; nullify tokstr string
0136+  14C1 19 00         mov al, TOK_NULL
0137+  14C3 3D 5A 16      mov [tok], al        ; nullify token
0138+  14C6 14 57 16      mov a, [prog]
0139+  14C9 4D            mov si, a
0140+  14CA FD 4F 5B 16   mov di, tokstr
0141+  14CE             get_tok_skip_spaces:
0142+  14CE F6            lodsb
0143+  14CF 07 06 14      call _isspace
0144+  14D2 C6 CE 14      je get_tok_skip_spaces
0145+  14D5 B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  14D7 C6 BC 15      je get_token_end
0147+  14DA B9 23         cmp al, '#'      ; comments!
0148+  14DC C6 EA 15      je get_tok_comment
0149+  14DF 07 90 13      call _isalnum
0150+  14E2 C6 C9 15      jz is_alphanumeric
0151+  14E5             ; other token types
0152+  14E5             get_token_slash:
0153+  14E5 B9 2F         cmp al, '/'        ; check if '/'
0154+  14E7 C7 FF 14      jne get_token_minus
0155+  14EA F7            stosb          ; store '/' into token string
0156+  14EB 19 00         mov al, 0
0157+  14ED F7            stosb          ; terminate token string
0158+  14EE 19 01         mov al, TOK_FSLASH
0159+  14F0 3D 5A 16      mov [tok], al      
0160+  14F3 19 02         mov al, TOKTYP_DELIMITER
0161+  14F5 3D 59 16      mov [toktyp], al
0162+  14F8 4E            mov a, si
0163+  14F9 42 57 16      mov [prog], a    ; update pointer
0164+  14FC 0A E5 15      jmp get_token_return
0165+  14FF             get_token_minus:
0166+  14FF B9 2D         cmp al, '-'        ; check if '-'
0167+  1501 C7 19 15      jne get_token_comma
0168+  1504 F7            stosb          ; store '-' into token string
0169+  1505 19 00         mov al, 0
0170+  1507 F7            stosb          ; terminate token string
0171+  1508 19 04         mov al, TOK_MINUS
0172+  150A 3D 5A 16      mov [tok], al      
0173+  150D 19 02         mov al, TOKTYP_DELIMITER
0174+  150F 3D 59 16      mov [toktyp], al
0175+  1512 4E            mov a, si
0176+  1513 42 57 16      mov [prog], a    ; update pointer
0177+  1516 0A E5 15      jmp get_token_return
0178+  1519             get_token_comma:
0179+  1519 B9 2C         cmp al, ','        ; check if ','
0180+  151B C7 33 15      jne get_token_semi
0181+  151E F7            stosb          ; store ',' into token string
0182+  151F 19 00         mov al, 0
0183+  1521 F7            stosb          ; terminate token string
0184+  1522 19 0B         mov al, TOK_COMMA
0185+  1524 3D 5A 16      mov [tok], al      
0186+  1527 19 02         mov al, TOKTYP_DELIMITER
0187+  1529 3D 59 16      mov [toktyp], al
0188+  152C 4E            mov a, si
0189+  152D 42 57 16      mov [prog], a    ; update pointer
0190+  1530 0A E5 15      jmp get_token_return
0191+  1533             get_token_semi:
0192+  1533 B9 3B         cmp al, $3B        ; check if ';'
0193+  1535 C7 4D 15      jne get_token_colon
0194+  1538 F7            stosb          ; store ';' into token string
0195+  1539 19 00         mov al, 0
0196+  153B F7            stosb          ; terminate token string
0197+  153C 19 06         mov al, TOK_SEMI
0198+  153E 3D 5A 16      mov [tok], al      
0199+  1541 19 02         mov al, TOKTYP_DELIMITER
0200+  1543 3D 59 16      mov [toktyp], al
0201+  1546 4E            mov a, si
0202+  1547 42 57 16      mov [prog], a    ; update pointer
0203+  154A 0A E5 15      jmp get_token_return
0204+  154D             get_token_colon:
0205+  154D B9 3A         cmp al, $3A        ; check if ':'
0206+  154F C7 67 15      jne get_token_angle
0207+  1552 F7            stosb          ; store ':' into token string
0208+  1553 19 00         mov al, 0
0209+  1555 F7            stosb          ; terminate token string
0210+  1556 19 0A         mov al, TOK_COLON
0211+  1558 3D 5A 16      mov [tok], al      
0212+  155B 19 02         mov al, TOKTYP_DELIMITER
0213+  155D 3D 59 16      mov [toktyp], al
0214+  1560 4E            mov a, si
0215+  1561 42 57 16      mov [prog], a    ; update pointer
0216+  1564 0A E5 15      jmp get_token_return
0217+  1567             get_token_angle:
0218+  1567 B9 3E         cmp al, $3E        ; check if '>'
0219+  1569 C7 81 15      jne get_token_tilde
0220+  156C F7            stosb          ; store '>' into token string
0221+  156D 19 00         mov al, 0
0222+  156F F7            stosb          ; terminate token string
0223+  1570 19 07         mov al, TOK_ANGLE
0224+  1572 3D 5A 16      mov [tok], al      
0225+  1575 19 02         mov al, TOKTYP_DELIMITER
0226+  1577 3D 59 16      mov [toktyp], al
0227+  157A 4E            mov a, si
0228+  157B 42 57 16      mov [prog], a    ; update pointer
0229+  157E 0A E5 15      jmp get_token_return
0230+  1581             get_token_tilde:
0231+  1581 B9 7E         cmp al, '~'        ; check if '~'
0232+  1583 C7 9B 15      jne get_token_equal
0233+  1586 F7            stosb          ; store '~' into token string
0234+  1587 19 00         mov al, 0
0235+  1589 F7            stosb          ; terminate token string
0236+  158A 19 08         mov al, TOK_TILDE
0237+  158C 3D 5A 16      mov [tok], al      
0238+  158F 19 02         mov al, TOKTYP_DELIMITER
0239+  1591 3D 59 16      mov [toktyp], al
0240+  1594 4E            mov a, si
0241+  1595 42 57 16      mov [prog], a    ; update pointer
0242+  1598 0A E5 15      jmp get_token_return
0243+  159B             get_token_equal:
0244+  159B B9 3D         cmp al, '='        ; check if '='
0245+  159D C7 B5 15      jne get_token_skip
0246+  15A0 F7            stosb          ; store '=' into token string
0247+  15A1 19 00         mov al, 0
0248+  15A3 F7            stosb          ; terminate token string
0249+  15A4 19 09         mov al, TOK_EQUAL
0250+  15A6 3D 5A 16      mov [tok], al      
0251+  15A9 19 02         mov al, TOKTYP_DELIMITER
0252+  15AB 3D 59 16      mov [toktyp], al
0253+  15AE 4E            mov a, si
0254+  15AF 42 57 16      mov [prog], a    ; update pointer
0255+  15B2 0A E5 15      jmp get_token_return
0256+  15B5             get_token_skip:
0257+  15B5 4E            mov a, si
0258+  15B6 42 57 16      mov [prog], a    ; update pointer
0259+  15B9 0A E5 15      jmp get_token_return
0260+  15BC             get_token_end:        ; end of file token
0261+  15BC 19 14         mov al, TOK_END
0262+  15BE 3D 5A 16      mov [tok], al
0263+  15C1 19 06         mov al, TOKTYP_END
0264+  15C3 3D 59 16      mov [toktyp], al
0265+  15C6 0A E5 15      jmp get_token_return
0266+  15C9             is_alphanumeric:
0267+  15C9 F7            stosb
0268+  15CA F6            lodsb
0269+  15CB 07 90 13      call _isalnum      ;check if is alphanumeric
0270+  15CE C6 C9 15      jz is_alphanumeric
0271+  15D1 B9 2E         cmp al, $2E        ; check if is '.'
0272+  15D3 C6 C9 15      je is_alphanumeric
0273+  15D6 19 00         mov al, 0
0274+  15D8 F7            stosb
0275+  15D9 19 00         mov al, TOKTYP_IDENTIFIER
0276+  15DB 3D 59 16      mov [toktyp], al
0277+  15DE D5 01 00      sub si, 1
0278+  15E1 4E            mov a, si
0279+  15E2 42 57 16      mov [prog], a    ; update pointer
0280+  15E5             get_token_return:
0281+  15E5 F0            pop di
0282+  15E6 EF            pop si
0283+  15E7 E7            pop d
0284+  15E8 E4            pop a
0285+  15E9 09            ret
0286+  15EA             get_tok_comment:
0287+  15EA F6            lodsb
0288+  15EB B9 0A         cmp al, $0A      ; new line
0289+  15ED C7 EA 15      jne get_tok_comment
0290+  15F0 0A CE 14      jmp get_tok_skip_spaces
0291+  15F3             
0292+  15F3             
0293+  15F3             get_number:
0294+  15F3 D7            push a
0295+  15F4 DA            push d
0296+  15F5 E2            push si
0297+  15F6 E3            push di
0298+  15F7 19 00         mov al, 0
0299+  15F9 3D 5B 16      mov [tokstr], al      ; nullify tokstr string
0300+  15FC 19 00         mov al, TOK_NULL
0301+  15FE 3D 5A 16      mov [tok], al        ; nullify token
0302+  1601 14 57 16      mov a, [prog]
0303+  1604 4D            mov si, a
0304+  1605 FD 4F 5B 16   mov di, tokstr
0305+  1609             get_number_skip_spaces:
0306+  1609 F6            lodsb
0307+  160A 07 06 14      call _isspace
0308+  160D C6 09 16      je get_number_skip_spaces
0309+  1610 B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  1612 C7 22 16      jne get_number_L0
0311+  1615 19 14         mov al, TOK_END
0312+  1617 3D 5A 16      mov [tok], al
0313+  161A 19 06         mov al, TOKTYP_END
0314+  161C 3D 59 16      mov [toktyp], al
0315+  161F 0A 39 16      jmp get_number_return
0316+  1622             get_number_L0:
0317+  1622 F7            stosb
0318+  1623 F6            lodsb
0319+  1624 07 9A 13      call _isdigit      ;check if is numeric
0320+  1627 C6 22 16      jz get_number_L0
0321+  162A 19 00         mov al, 0
0322+  162C F7            stosb
0323+  162D 19 05         mov al, TOKTYP_NUMERIC
0324+  162F 3D 59 16      mov [toktyp], al
0325+  1632 D5 01 00      sub si, 1
0326+  1635 4E            mov a, si
0327+  1636 42 57 16      mov [prog], a    ; update pointer
0328+  1639             get_number_return:
0329+  1639 F0            pop di
0330+  163A EF            pop si
0331+  163B E7            pop d
0332+  163C E4            pop a
0333+  163D 09            ret
0334+  163E             
0335+  163E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  163E             ;; PUT BACK TOKEN
0337+  163E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  163E             _putback:
0339+  163E D7            push a
0340+  163F E2            push si
0341+  1640 FD 4D 5B 16   mov si, tokstr  
0342+  1644             _putback_loop:
0343+  1644 F6            lodsb
0344+  1645 B9 00         cmp al, 0
0345+  1647 C6 54 16      je _putback_end
0346+  164A 14 57 16      mov a, [prog]
0347+  164D 7D            dec a
0348+  164E 42 57 16      mov [prog], a      ; update pointer
0349+  1651 0A 44 16      jmp _putback_loop
0350+  1654             _putback_end:
0351+  1654 EF            pop si
0352+  1655 E4            pop a
0353+  1656 09            ret
0354+  1657             
0355+  1657             
0356+  1657             
0357+  1657             
0358+  1657 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1659             
0360+  1659 00          toktyp:    .db 0          ; token type symbol
0361+  165A 00          tok:       .db 0          ; current token symbol
0362+  165B 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  165F 00 00 00 00 
0362+  1663 00 00 00 00 
0362+  1667 00 00 00 00 
0362+  166B 00 00 00 00 
0362+  166F 00 00 00 00 
0362+  1673 00 00 00 00 
0362+  1677 00 00 00 00 
0362+  167B 00 00 00 00 
0362+  167F 00 00 00 00 
0362+  1683 00 00 00 00 
0362+  1687 00 00 00 00 
0362+  168B 00 00 00 00 
0362+  168F 00 00 00 00 
0362+  1693 00 00 00 00 
0362+  1697 00 00 00 00 
0362+  169B 00 00 00 00 
0362+  169F 00 00 00 00 
0362+  16A3 00 00 00 00 
0362+  16A7 00 00 00 00 
0362+  16AB 00 00 00 00 
0362+  16AF 00 00 00 00 
0362+  16B3 00 00 00 00 
0362+  16B7 00 00 00 00 
0362+  16BB 00 00 00 00 
0362+  16BF 00 00 00 00 
0362+  16C3 00 00 00 00 
0362+  16C7 00 00 00 00 
0362+  16CB 00 00 00 00 
0362+  16CF 00 00 00 00 
0362+  16D3 00 00 00 00 
0362+  16D7 00 00 00 00 
0362+  16DB 00 00 00 00 
0362+  16DF 00 00 00 00 
0362+  16E3 00 00 00 00 
0362+  16E7 00 00 00 00 
0362+  16EB 00 00 00 00 
0362+  16EF 00 00 00 00 
0362+  16F3 00 00 00 00 
0362+  16F7 00 00 00 00 
0362+  16FB 00 00 00 00 
0362+  16FF 00 00 00 00 
0362+  1703 00 00 00 00 
0362+  1707 00 00 00 00 
0362+  170B 00 00 00 00 
0362+  170F 00 00 00 00 
0362+  1713 00 00 00 00 
0362+  1717 00 00 00 00 
0362+  171B 00 00 00 00 
0362+  171F 00 00 00 00 
0362+  1723 00 00 00 00 
0362+  1727 00 00 00 00 
0362+  172B 00 00 00 00 
0362+  172F 00 00 00 00 
0362+  1733 00 00 00 00 
0362+  1737 00 00 00 00 
0362+  173B 00 00 00 00 
0362+  173F 00 00 00 00 
0362+  1743 00 00 00 00 
0362+  1747 00 00 00 00 
0362+  174B 00 00 00 00 
0362+  174F 00 00 00 00 
0362+  1753 00 00 00 00 
0362+  1757 00 00 00 00 
2635   175B             
2636   175B             ; kernel parameters
2637   175B 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2638   175C 01          sys_echo_on:        .db 1
2639   175D 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2640   175E 01          sys_uart0_inten:    .db 1
2641   175F 00          sys_uart0_fifoen:   .db 0
2642   1760 0C          sys_uart0_div0:     .db 12  ;
2643   1761 00          sys_uart0_div1:     .db 0   ; default baud = 9600
2644   1762             ; Baud  Divisor
2645   1762             ; 50    2304
2646   1762             ; 110   1047
2647   1762             ; 300    384
2648   1762             ; 600    192
2649   1762             ; 1200    96
2650   1762             ; 9600    12
2651   1762             ; 19200    6
2652   1762             ; 38400    3
2653   1762             
2654   1762 00          nbr_active_procs:   .db 0
2655   1763 01          active_proc_index:  .db 1
2656   1764             
2657   1764 00 00       index:              .dw 0
2658   1766 00 00       buffer_addr:        .dw 0
2659   1768             
2660   1768 A9 20       fifo_in:            .dw fifo
2661   176A A9 20       fifo_out:           .dw fifo
2662   176C             
2663   176C             ; file system variables
2664   176C 00 00       current_dir_id:     .dw 0     ; keep dirID of current directory
2665   176E 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2665   1772 6E 2F 69 6E 
2665   1776 69 74 00 
2666   1779             
2667   1779 3E 20 00    s_dataentry:        .db "> ", 0
2668   177C 2E 2E 00    s_parent_dir:       .db "..", 0
2669   177F 2E 00       s_current_dir:      .db ".", 0
2670   1781 2F 00       s_fslash:           .db "/", 0
2671   1783 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2671   1787 78 
2672   1788 2D 64 63    file_type:          .db "-dc"
2673   178B 50 49 44 20 s_ps_header:        .db "PID COMMAND\n", 0
2673   178F 43 4F 4D 4D 
2673   1793 41 4E 44 0A 
2673   1797 00 
2674   1798 54 6F 74 61 s_ls_total:         .db "Total: ", 0
2674   179C 6C 3A 20 00 
2675   17A0             
2676   17A0 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2676   17A4 20 65 6E 61 
2676   17A8 62 6C 65 64 
2676   17AC 0A 00 
2677   17AE 6B 65 72 6E s_kernel_started:   .db "kernel started(version 1.0)\n", 0
2677   17B2 65 6C 20 73 
2677   17B6 74 61 72 74 
2677   17BA 65 64 28 76 
2677   17BE 65 72 73 69 
2677   17C2 6F 6E 20 31 
2677   17C6 2E 30 29 0A 
2677   17CA 00 
2678   17CB 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2678   17CF 74 69 6E 67 
2678   17D3 20 69 6E 69 
2678   17D7 74 0A 00 
2679   17DA 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2679   17DE 65 70 74 69 
2679   17E2 6F 6E 3A 20 
2679   17E6 70 72 69 76 
2679   17EA 69 6C 65 67 
2679   17EE 65 0A 00 
2680   17F1 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2680   17F5 65 70 74 69 
2680   17F9 6F 6E 3A 20 
2680   17FD 7A 65 72 6F 
2680   1801 20 64 69 76 
2680   1805 69 73 69 6F 
2680   1809 6E 0A 00 
2681   180C             
2682   180C 59 65 61 72 s_set_year:         .db "Year: ", 0
2682   1810 3A 20 00 
2683   1813 4D 6F 6E 74 s_set_month:        .db "Month: ", 0
2683   1817 68 3A 20 00 
2684   181B 44 61 79 3A s_set_day:          .db "Day: ", 0
2684   181F 20 00 
2685   1821 57 65 65 6B s_set_week:         .db "Weekday: ", 0
2685   1825 64 61 79 3A 
2685   1829 20 00 
2686   182B 48 6F 75 72 s_set_hours:        .db "Hours: ", 0
2686   182F 73 3A 20 00 
2687   1833 4D 69 6E 75 s_set_minutes:      .db "Minutes: ", 0
2687   1837 74 65 73 3A 
2687   183B 20 00 
2688   183D 53 65 63 6F s_set_seconds:      .db "Seconds: ", 0
2688   1841 6E 64 73 3A 
2688   1845 20 00 
2689   1847             s_months:      
2690   1847 20 20 20 00   .db "   ", 0
2691   184B 4A 61 6E 00   .db "Jan", 0
2692   184F 46 65 62 00   .db "Feb", 0
2693   1853 4D 61 72 00   .db "Mar", 0
2694   1857 41 70 72 00   .db "Apr", 0
2695   185B 4D 61 79 00   .db "May", 0
2696   185F 4A 75 6E 00   .db "Jun", 0
2697   1863 4A 75 6C 00   .db "Jul", 0
2698   1867 41 75 67 00   .db "Aug", 0
2699   186B 53 65 70 00   .db "Sep", 0
2700   186F 4F 63 74 00   .db "Oct", 0
2701   1873 4E 6F 76 00   .db "Nov", 0
2702   1877 44 65 63 00   .db "Dec", 0
2703   187B             
2704   187B             s_week:        
2705   187B 53 75 6E 00   .db "Sun", 0 
2706   187F 4D 6F 6E 00   .db "Mon", 0 
2707   1883 54 75 65 00   .db "Tue", 0 
2708   1887 57 65 64 00   .db "Wed", 0 
2709   188B 54 68 75 00   .db "Thu", 0 
2710   188F 46 72 69 00   .db "Fri", 0 
2711   1893 53 61 74 00   .db "Sat", 0
2712   1897             
2713   1897             ; This is the format of a sector for the 128 byte per sector format.
2714   1897             ; Write the bracketed data 16 times per track.
2715   1897             ; The recommended single-density format with 128
2716   1897             ; bytes/sector is shown. In order to format a diskette,
2717   1897             ; the user issues the Write Track Command, and loads
2718   1897             ; the Data Register with the following values. For every
2719   1897             ; byte to be written, there is one Data Request.
2720   1897             fdc_128_bytes_per_sect:                                                                       
2721   1897 FF FF FF FF fdc_40_FF:     .fill 40,  $FF  ; or 00                                                                                
2721   189B FF FF FF FF 
2721   189F FF FF FF FF 
2721   18A3 FF FF FF FF 
2721   18A7 FF FF FF FF 
2721   18AB FF FF FF FF 
2721   18AF FF FF FF FF 
2721   18B3 FF FF FF FF 
2721   18B7 FF FF FF FF 
2721   18BB FF FF FF FF 
2722   18BF 00 00 00 00 fdc_6_00_0:    .fill 6,   $00  ;                                                                            <--|        
2722   18C3 00 00 
2723   18C5 FE          fdc_id_fe:     .fill 1,   $FE  ; ID Address Mark                                                               |        
2724   18C6 00          fdc_track:     .fill 1,   $00  ; Track Number                                                                  |                    
2725   18C7 00          fdc_side:      .fill 1,   $00  ; Side Number 00 or 01                                                          |                
2726   18C8 01          fdc_sector:    .fill 1,   $01  ; Sector Number  1 through 10                                                   |                              
2727   18C9 00          fdc_length:    .fill 1,   $00  ; Sector Length                                                                 |                        
2728   18CA F7          fdc_2_crc_0:   .fill 1,   $F7  ; 2 CRC's Written                                                               | Write 16 times                 
2729   18CB FF FF FF FF fdc_11_ff:     .fill 11,  $FF  ; or 00                                                                         |                      
2729   18CF FF FF FF FF 
2729   18D3 FF FF FF 
2730   18D6 00 00 00 00 fdc_6_00_1:    .fill 6,   $00  ;                                                                               |                        
2730   18DA 00 00 
2731   18DC FB          fdc_data_addr: .fill 1,   $FB  ; Data Address Mark                                                             |                                  
2732   18DD E5 E5 E5 E5 fdc_data:      .fill 128, $E5  ; Data (IBM uses E5)                                                            |                                      
2732   18E1 E5 E5 E5 E5 
2732   18E5 E5 E5 E5 E5 
2732   18E9 E5 E5 E5 E5 
2732   18ED E5 E5 E5 E5 
2732   18F1 E5 E5 E5 E5 
2732   18F5 E5 E5 E5 E5 
2732   18F9 E5 E5 E5 E5 
2732   18FD E5 E5 E5 E5 
2732   1901 E5 E5 E5 E5 
2732   1905 E5 E5 E5 E5 
2732   1909 E5 E5 E5 E5 
2732   190D E5 E5 E5 E5 
2732   1911 E5 E5 E5 E5 
2732   1915 E5 E5 E5 E5 
2732   1919 E5 E5 E5 E5 
2732   191D E5 E5 E5 E5 
2732   1921 E5 E5 E5 E5 
2732   1925 E5 E5 E5 E5 
2732   1929 E5 E5 E5 E5 
2732   192D E5 E5 E5 E5 
2732   1931 E5 E5 E5 E5 
2732   1935 E5 E5 E5 E5 
2732   1939 E5 E5 E5 E5 
2732   193D E5 E5 E5 E5 
2732   1941 E5 E5 E5 E5 
2732   1945 E5 E5 E5 E5 
2732   1949 E5 E5 E5 E5 
2732   194D E5 E5 E5 E5 
2732   1951 E5 E5 E5 E5 
2732   1955 E5 E5 E5 E5 
2732   1959 E5 E5 E5 E5 
2733   195D F7          fdc_2_crc_1:   .fill 1,   $F7  ; 2 CRC's Written                                                               |                                                        
2734   195E FF FF FF FF fdc_10_ff:     .fill 10,  $FF  ; or 00                                                                      <--|                                                  
2734   1962 FF FF FF FF 
2734   1966 FF FF 
2735   1968 FF FF FF FF fdc_369_ff:    .fill 369, $FF  ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
2735   196C FF FF FF FF 
2735   1970 FF FF FF FF 
2735   1974 FF FF FF FF 
2735   1978 FF FF FF FF 
2735   197C FF FF FF FF 
2735   1980 FF FF FF FF 
2735   1984 FF FF FF FF 
2735   1988 FF FF FF FF 
2735   198C FF FF FF FF 
2735   1990 FF FF FF FF 
2735   1994 FF FF FF FF 
2735   1998 FF FF FF FF 
2735   199C FF FF FF FF 
2735   19A0 FF FF FF FF 
2735   19A4 FF FF FF FF 
2735   19A8 FF FF FF FF 
2735   19AC FF FF FF FF 
2735   19B0 FF FF FF FF 
2735   19B4 FF FF FF FF 
2735   19B8 FF FF FF FF 
2735   19BC FF FF FF FF 
2735   19C0 FF FF FF FF 
2735   19C4 FF FF FF FF 
2735   19C8 FF FF FF FF 
2735   19CC FF FF FF FF 
2735   19D0 FF FF FF FF 
2735   19D4 FF FF FF FF 
2735   19D8 FF FF FF FF 
2735   19DC FF FF FF FF 
2735   19E0 FF FF FF FF 
2735   19E4 FF FF FF FF 
2735   19E8 FF FF FF FF 
2735   19EC FF FF FF FF 
2735   19F0 FF FF FF FF 
2735   19F4 FF FF FF FF 
2735   19F8 FF FF FF FF 
2735   19FC FF FF FF FF 
2735   1A00 FF FF FF FF 
2735   1A04 FF FF FF FF 
2735   1A08 FF FF FF FF 
2735   1A0C FF FF FF FF 
2735   1A10 FF FF FF FF 
2735   1A14 FF FF FF FF 
2735   1A18 FF FF FF FF 
2735   1A1C FF FF FF FF 
2735   1A20 FF FF FF FF 
2735   1A24 FF FF FF FF 
2735   1A28 FF FF FF FF 
2735   1A2C FF FF FF FF 
2735   1A30 FF FF FF FF 
2735   1A34 FF FF FF FF 
2735   1A38 FF FF FF FF 
2735   1A3C FF FF FF FF 
2735   1A40 FF FF FF FF 
2735   1A44 FF FF FF FF 
2735   1A48 FF FF FF FF 
2735   1A4C FF FF FF FF 
2735   1A50 FF FF FF FF 
2735   1A54 FF FF FF FF 
2735   1A58 FF FF FF FF 
2735   1A5C FF FF FF FF 
2735   1A60 FF FF FF FF 
2735   1A64 FF FF FF FF 
2735   1A68 FF FF FF FF 
2735   1A6C FF FF FF FF 
2735   1A70 FF FF FF FF 
2735   1A74 FF FF FF FF 
2735   1A78 FF FF FF FF 
2735   1A7C FF FF FF FF 
2735   1A80 FF FF FF FF 
2735   1A84 FF FF FF FF 
2735   1A88 FF FF FF FF 
2735   1A8C FF FF FF FF 
2735   1A90 FF FF FF FF 
2735   1A94 FF FF FF FF 
2735   1A98 FF FF FF FF 
2735   1A9C FF FF FF FF 
2735   1AA0 FF FF FF FF 
2735   1AA4 FF FF FF FF 
2735   1AA8 FF FF FF FF 
2735   1AAC FF FF FF FF 
2735   1AB0 FF FF FF FF 
2735   1AB4 FF FF FF FF 
2735   1AB8 FF FF FF FF 
2735   1ABC FF FF FF FF 
2735   1AC0 FF FF FF FF 
2735   1AC4 FF FF FF FF 
2735   1AC8 FF FF FF FF 
2735   1ACC FF FF FF FF 
2735   1AD0 FF FF FF FF 
2735   1AD4 FF FF FF FF 
2735   1AD8 FF 
2736   1AD9             
2737   1AD9 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2737   1ADD 00 00 00 00 
2737   1AE1 00 00 00 00 
2737   1AE5 00 00 00 00 
2737   1AE9 00 00 00 00 
2737   1AED 00 00 00 00 
2737   1AF1 00 00 00 00 
2737   1AF5 00 00 00 00 
2737   1AF9 00 00 00 00 
2737   1AFD 00 00 00 00 
2737   1B01 00 00 00 00 
2737   1B05 00 00 00 00 
2737   1B09 00 00 00 00 
2737   1B0D 00 00 00 00 
2737   1B11 00 00 00 00 
2737   1B15 00 00 00 00 
2737   1B19 00 00 00 00 
2737   1B1D 00 00 00 00 
2737   1B21 00 00 00 00 
2737   1B25 00 00 00 00 
2737   1B29 00 00 00 00 
2737   1B2D 00 00 00 00 
2737   1B31 00 00 00 00 
2737   1B35 00 00 00 00 
2737   1B39 00 00 00 00 
2737   1B3D 00 00 00 00 
2737   1B41 00 00 00 00 
2737   1B45 00 00 00 00 
2737   1B49 00 00 00 00 
2737   1B4D 00 00 00 00 
2737   1B51 00 00 00 00 
2737   1B55 00 00 00 00 
2737   1B59 00 00 00 00 
2737   1B5D 00 00 00 00 
2737   1B61 00 00 00 00 
2737   1B65 00 00 00 00 
2737   1B69 00 00 00 00 
2737   1B6D 00 00 00 00 
2737   1B71 00 00 00 00 
2737   1B75 00 00 00 00 
2737   1B79 00 00 00 00 
2737   1B7D 00 00 00 00 
2737   1B81 00 00 00 00 
2737   1B85 00 00 00 00 
2737   1B89 00 00 00 00 
2737   1B8D 00 00 00 00 
2737   1B91 00 00 00 00 
2737   1B95 00 00 00 00 
2737   1B99 00 00 00 00 
2737   1B9D 00 00 00 00 
2737   1BA1 00 00 00 00 
2737   1BA5 00 00 00 00 
2737   1BA9 00 00 00 00 
2737   1BAD 00 00 00 00 
2737   1BB1 00 00 00 00 
2737   1BB5 00 00 00 00 
2737   1BB9 00 00 00 00 
2737   1BBD 00 00 00 00 
2737   1BC1 00 00 00 00 
2737   1BC5 00 00 00 00 
2737   1BC9 00 00 00 00 
2737   1BCD 00 00 00 00 
2737   1BD1 00 00 00 00 
2737   1BD5 00 00 00 00 
2737   1BD9 00 00 00 00 
2737   1BDD 00 00 00 00 
2737   1BE1 00 00 00 00 
2737   1BE5 00 00 00 00 
2737   1BE9 00 00 00 00 
2737   1BED 00 00 00 00 
2737   1BF1 00 00 00 00 
2737   1BF5 00 00 00 00 
2737   1BF9 00 00 00 00 
2737   1BFD 00 00 00 00 
2737   1C01 00 00 00 00 
2737   1C05 00 00 00 00 
2737   1C09 00 00 00 00 
2737   1C0D 00 00 00 00 
2737   1C11 00 00 00 00 
2737   1C15 00 00 00 00 
2738   1C19 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2738   1C1D 00 00 00 00 
2738   1C21 00 00 00 00 
2738   1C25 00 00 00 00 
2739   1C29 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2739   1C2D 00 00 00 00 
2739   1C31 00 00 00 00 
2739   1C35 00 00 00 00 
2739   1C39 00 00 00 00 
2739   1C3D 00 00 00 00 
2739   1C41 00 00 00 00 
2739   1C45 00 00 00 00 
2739   1C49 00 00 00 00 
2739   1C4D 00 00 00 00 
2739   1C51 00 00 00 00 
2739   1C55 00 00 00 00 
2739   1C59 00 00 00 00 
2739   1C5D 00 00 00 00 
2739   1C61 00 00 00 00 
2739   1C65 00 00 00 00 
2739   1C69 00 00 00 00 
2739   1C6D 00 00 00 00 
2739   1C71 00 00 00 00 
2739   1C75 00 00 00 00 
2739   1C79 00 00 00 00 
2739   1C7D 00 00 00 00 
2739   1C81 00 00 00 00 
2739   1C85 00 00 00 00 
2739   1C89 00 00 00 00 
2739   1C8D 00 00 00 00 
2739   1C91 00 00 00 00 
2739   1C95 00 00 00 00 
2739   1C99 00 00 00 00 
2739   1C9D 00 00 00 00 
2739   1CA1 00 00 00 00 
2739   1CA5 00 00 00 00 
2739   1CA9 00 00 00 00 
2739   1CAD 00 00 00 00 
2739   1CB1 00 00 00 00 
2739   1CB5 00 00 00 00 
2739   1CB9 00 00 00 00 
2739   1CBD 00 00 00 00 
2739   1CC1 00 00 00 00 
2739   1CC5 00 00 00 00 
2739   1CC9 00 00 00 00 
2739   1CCD 00 00 00 00 
2739   1CD1 00 00 00 00 
2739   1CD5 00 00 00 00 
2739   1CD9 00 00 00 00 
2739   1CDD 00 00 00 00 
2739   1CE1 00 00 00 00 
2739   1CE5 00 00 00 00 
2739   1CE9 00 00 00 00 
2739   1CED 00 00 00 00 
2739   1CF1 00 00 00 00 
2739   1CF5 00 00 00 00 
2739   1CF9 00 00 00 00 
2739   1CFD 00 00 00 00 
2739   1D01 00 00 00 00 
2739   1D05 00 00 00 00 
2739   1D09 00 00 00 00 
2739   1D0D 00 00 00 00 
2739   1D11 00 00 00 00 
2739   1D15 00 00 00 00 
2739   1D19 00 00 00 00 
2739   1D1D 00 00 00 00 
2739   1D21 00 00 00 00 
2739   1D25 00 00 00 00 
2739   1D29 00 00 00 00 
2739   1D2D 00 00 00 00 
2739   1D31 00 00 00 00 
2739   1D35 00 00 00 00 
2739   1D39 00 00 00 00 
2739   1D3D 00 00 00 00 
2739   1D41 00 00 00 00 
2739   1D45 00 00 00 00 
2739   1D49 00 00 00 00 
2739   1D4D 00 00 00 00 
2739   1D51 00 00 00 00 
2739   1D55 00 00 00 00 
2739   1D59 00 00 00 00 
2739   1D5D 00 00 00 00 
2739   1D61 00 00 00 00 
2739   1D65 00 00 00 00 
2739   1D69 00 00 00 00 
2739   1D6D 00 00 00 00 
2739   1D71 00 00 00 00 
2739   1D75 00 00 00 00 
2739   1D79 00 00 00 00 
2739   1D7D 00 00 00 00 
2739   1D81 00 00 00 00 
2739   1D85 00 00 00 00 
2739   1D89 00 00 00 00 
2739   1D8D 00 00 00 00 
2739   1D91 00 00 00 00 
2739   1D95 00 00 00 00 
2739   1D99 00 00 00 00 
2739   1D9D 00 00 00 00 
2739   1DA1 00 00 00 00 
2739   1DA5 00 00 00 00 
2739   1DA9 00 00 00 00 
2739   1DAD 00 00 00 00 
2739   1DB1 00 00 00 00 
2739   1DB5 00 00 00 00 
2739   1DB9 00 00 00 00 
2739   1DBD 00 00 00 00 
2739   1DC1 00 00 00 00 
2739   1DC5 00 00 00 00 
2739   1DC9 00 00 00 00 
2739   1DCD 00 00 00 00 
2739   1DD1 00 00 00 00 
2739   1DD5 00 00 00 00 
2739   1DD9 00 00 00 00 
2739   1DDD 00 00 00 00 
2739   1DE1 00 00 00 00 
2739   1DE5 00 00 00 00 
2739   1DE9 00 00 00 00 
2739   1DED 00 00 00 00 
2739   1DF1 00 00 00 00 
2739   1DF5 00 00 00 00 
2739   1DF9 00 00 00 00 
2739   1DFD 00 00 00 00 
2739   1E01 00 00 00 00 
2739   1E05 00 00 00 00 
2739   1E09 00 00 00 00 
2739   1E0D 00 00 00 00 
2739   1E11 00 00 00 00 
2739   1E15 00 00 00 00 
2739   1E19 00 00 00 00 
2739   1E1D 00 00 00 00 
2739   1E21 00 00 00 00 
2739   1E25 00 00 00 00 
2740   1E29 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2740   1E2D 00 00 00 00 
2740   1E31 00 00 00 00 
2740   1E35 00 00 00 00 
2740   1E39 00 00 00 00 
2740   1E3D 00 00 00 00 
2740   1E41 00 00 00 00 
2740   1E45 00 00 00 00 
2740   1E49 00 00 00 00 
2740   1E4D 00 00 00 00 
2740   1E51 00 00 00 00 
2740   1E55 00 00 00 00 
2740   1E59 00 00 00 00 
2740   1E5D 00 00 00 00 
2740   1E61 00 00 00 00 
2740   1E65 00 00 00 00 
2740   1E69 00 00 00 00 
2740   1E6D 00 00 00 00 
2740   1E71 00 00 00 00 
2740   1E75 00 00 00 00 
2740   1E79 00 00 00 00 
2740   1E7D 00 00 00 00 
2740   1E81 00 00 00 00 
2740   1E85 00 00 00 00 
2740   1E89 00 00 00 00 
2740   1E8D 00 00 00 00 
2740   1E91 00 00 00 00 
2740   1E95 00 00 00 00 
2740   1E99 00 00 00 00 
2740   1E9D 00 00 00 00 
2740   1EA1 00 00 00 00 
2740   1EA5 00 00 00 00 
2741   1EA9 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2741   1EAD 00 00 00 00 
2741   1EB1 00 00 00 00 
2741   1EB5 00 00 00 00 
2741   1EB9 00 00 00 00 
2741   1EBD 00 00 00 00 
2741   1EC1 00 00 00 00 
2741   1EC5 00 00 00 00 
2741   1EC9 00 00 00 00 
2741   1ECD 00 00 00 00 
2741   1ED1 00 00 00 00 
2741   1ED5 00 00 00 00 
2741   1ED9 00 00 00 00 
2741   1EDD 00 00 00 00 
2741   1EE1 00 00 00 00 
2741   1EE5 00 00 00 00 
2741   1EE9 00 00 00 00 
2741   1EED 00 00 00 00 
2741   1EF1 00 00 00 00 
2741   1EF5 00 00 00 00 
2741   1EF9 00 00 00 00 
2741   1EFD 00 00 00 00 
2741   1F01 00 00 00 00 
2741   1F05 00 00 00 00 
2741   1F09 00 00 00 00 
2741   1F0D 00 00 00 00 
2741   1F11 00 00 00 00 
2741   1F15 00 00 00 00 
2741   1F19 00 00 00 00 
2741   1F1D 00 00 00 00 
2741   1F21 00 00 00 00 
2741   1F25 00 00 00 00 
2741   1F29 00 00 00 00 
2741   1F2D 00 00 00 00 
2741   1F31 00 00 00 00 
2741   1F35 00 00 00 00 
2741   1F39 00 00 00 00 
2741   1F3D 00 00 00 00 
2741   1F41 00 00 00 00 
2741   1F45 00 00 00 00 
2741   1F49 00 00 00 00 
2741   1F4D 00 00 00 00 
2741   1F51 00 00 00 00 
2741   1F55 00 00 00 00 
2741   1F59 00 00 00 00 
2741   1F5D 00 00 00 00 
2741   1F61 00 00 00 00 
2741   1F65 00 00 00 00 
2741   1F69 00 00 00 00 
2741   1F6D 00 00 00 00 
2741   1F71 00 00 00 00 
2741   1F75 00 00 00 00 
2741   1F79 00 00 00 00 
2741   1F7D 00 00 00 00 
2741   1F81 00 00 00 00 
2741   1F85 00 00 00 00 
2741   1F89 00 00 00 00 
2741   1F8D 00 00 00 00 
2741   1F91 00 00 00 00 
2741   1F95 00 00 00 00 
2741   1F99 00 00 00 00 
2741   1F9D 00 00 00 00 
2741   1FA1 00 00 00 00 
2741   1FA5 00 00 00 00 
2741   1FA9 00 00 00 00 
2741   1FAD 00 00 00 00 
2741   1FB1 00 00 00 00 
2741   1FB5 00 00 00 00 
2741   1FB9 00 00 00 00 
2741   1FBD 00 00 00 00 
2741   1FC1 00 00 00 00 
2741   1FC5 00 00 00 00 
2741   1FC9 00 00 00 00 
2741   1FCD 00 00 00 00 
2741   1FD1 00 00 00 00 
2741   1FD5 00 00 00 00 
2741   1FD9 00 00 00 00 
2741   1FDD 00 00 00 00 
2741   1FE1 00 00 00 00 
2741   1FE5 00 00 00 00 
2741   1FE9 00 00 00 00 
2741   1FED 00 00 00 00 
2741   1FF1 00 00 00 00 
2741   1FF5 00 00 00 00 
2741   1FF9 00 00 00 00 
2741   1FFD 00 00 00 00 
2741   2001 00 00 00 00 
2741   2005 00 00 00 00 
2741   2009 00 00 00 00 
2741   200D 00 00 00 00 
2741   2011 00 00 00 00 
2741   2015 00 00 00 00 
2741   2019 00 00 00 00 
2741   201D 00 00 00 00 
2741   2021 00 00 00 00 
2741   2025 00 00 00 00 
2741   2029 00 00 00 00 
2741   202D 00 00 00 00 
2741   2031 00 00 00 00 
2741   2035 00 00 00 00 
2741   2039 00 00 00 00 
2741   203D 00 00 00 00 
2741   2041 00 00 00 00 
2741   2045 00 00 00 00 
2741   2049 00 00 00 00 
2741   204D 00 00 00 00 
2741   2051 00 00 00 00 
2741   2055 00 00 00 00 
2741   2059 00 00 00 00 
2741   205D 00 00 00 00 
2741   2061 00 00 00 00 
2741   2065 00 00 00 00 
2741   2069 00 00 00 00 
2741   206D 00 00 00 00 
2741   2071 00 00 00 00 
2741   2075 00 00 00 00 
2741   2079 00 00 00 00 
2741   207D 00 00 00 00 
2741   2081 00 00 00 00 
2741   2085 00 00 00 00 
2741   2089 00 00 00 00 
2741   208D 00 00 00 00 
2741   2091 00 00 00 00 
2741   2095 00 00 00 00 
2741   2099 00 00 00 00 
2741   209D 00 00 00 00 
2741   20A1 00 00 00 00 
2741   20A5 00 00 00 00 
2742   20A9 FF FF FF FF fifo:               .fill FIFO_SIZE
2742   20AD FF FF FF FF 
2742   20B1 FF FF FF FF 
2742   20B5 FF FF FF FF 
2742   20B9 FF FF FF FF 
2742   20BD FF FF FF FF 
2742   20C1 FF FF FF FF 
2742   20C5 FF FF FF FF 
2742   20C9 FF FF FF FF 
2742   20CD FF FF FF FF 
2742   20D1 FF FF FF FF 
2742   20D5 FF FF FF FF 
2742   20D9 FF FF FF FF 
2742   20DD FF FF FF FF 
2742   20E1 FF FF FF FF 
2742   20E5 FF FF FF FF 
2742   20E9 FF FF FF FF 
2742   20ED FF FF FF FF 
2742   20F1 FF FF FF FF 
2742   20F5 FF FF FF FF 
2742   20F9 FF FF FF FF 
2742   20FD FF FF FF FF 
2742   2101 FF FF FF FF 
2742   2105 FF FF FF FF 
2742   2109 FF FF FF FF 
2742   210D FF FF FF FF 
2742   2111 FF FF FF FF 
2742   2115 FF FF FF FF 
2742   2119 FF FF FF FF 
2742   211D FF FF FF FF 
2742   2121 FF FF FF FF 
2742   2125 FF FF FF FF 
2742   2129 FF FF FF FF 
2742   212D FF FF FF FF 
2742   2131 FF FF FF FF 
2742   2135 FF FF FF FF 
2742   2139 FF FF FF FF 
2742   213D FF FF FF FF 
2742   2141 FF FF FF FF 
2742   2145 FF FF FF FF 
2742   2149 FF FF FF FF 
2742   214D FF FF FF FF 
2742   2151 FF FF FF FF 
2742   2155 FF FF FF FF 
2742   2159 FF FF FF FF 
2742   215D FF FF FF FF 
2742   2161 FF FF FF FF 
2742   2165 FF FF FF FF 
2742   2169 FF FF FF FF 
2742   216D FF FF FF FF 
2742   2171 FF FF FF FF 
2742   2175 FF FF FF FF 
2742   2179 FF FF FF FF 
2742   217D FF FF FF FF 
2742   2181 FF FF FF FF 
2742   2185 FF FF FF FF 
2742   2189 FF FF FF FF 
2742   218D FF FF FF FF 
2742   2191 FF FF FF FF 
2742   2195 FF FF FF FF 
2742   2199 FF FF FF FF 
2742   219D FF FF FF FF 
2742   21A1 FF FF FF FF 
2742   21A5 FF FF FF FF 
2742   21A9 FF FF FF FF 
2742   21AD FF FF FF FF 
2742   21B1 FF FF FF FF 
2742   21B5 FF FF FF FF 
2742   21B9 FF FF FF FF 
2742   21BD FF FF FF FF 
2742   21C1 FF FF FF FF 
2742   21C5 FF FF FF FF 
2742   21C9 FF FF FF FF 
2742   21CD FF FF FF FF 
2742   21D1 FF FF FF FF 
2742   21D5 FF FF FF FF 
2742   21D9 FF FF FF FF 
2742   21DD FF FF FF FF 
2742   21E1 FF FF FF FF 
2742   21E5 FF FF FF FF 
2742   21E9 FF FF FF FF 
2742   21ED FF FF FF FF 
2742   21F1 FF FF FF FF 
2742   21F5 FF FF FF FF 
2742   21F9 FF FF FF FF 
2742   21FD FF FF FF FF 
2742   2201 FF FF FF FF 
2742   2205 FF FF FF FF 
2742   2209 FF FF FF FF 
2742   220D FF FF FF FF 
2742   2211 FF FF FF FF 
2742   2215 FF FF FF FF 
2742   2219 FF FF FF FF 
2742   221D FF FF FF FF 
2742   2221 FF FF FF FF 
2742   2225 FF FF FF FF 
2742   2229 FF FF FF FF 
2742   222D FF FF FF FF 
2742   2231 FF FF FF FF 
2742   2235 FF FF FF FF 
2742   2239 FF FF FF FF 
2742   223D FF FF FF FF 
2742   2241 FF FF FF FF 
2742   2245 FF FF FF FF 
2742   2249 FF FF FF FF 
2742   224D FF FF FF FF 
2742   2251 FF FF FF FF 
2742   2255 FF FF FF FF 
2742   2259 FF FF FF FF 
2742   225D FF FF FF FF 
2742   2261 FF FF FF FF 
2742   2265 FF FF FF FF 
2742   2269 FF FF FF FF 
2742   226D FF FF FF FF 
2742   2271 FF FF FF FF 
2742   2275 FF FF FF FF 
2742   2279 FF FF FF FF 
2742   227D FF FF FF FF 
2742   2281 FF FF FF FF 
2742   2285 FF FF FF FF 
2742   2289 FF FF FF FF 
2742   228D FF FF FF FF 
2742   2291 FF FF FF FF 
2742   2295 FF FF FF FF 
2742   2299 FF FF FF FF 
2742   229D FF FF FF FF 
2742   22A1 FF FF FF FF 
2742   22A5 FF FF FF FF 
2742   22A9 FF FF FF FF 
2742   22AD FF FF FF FF 
2742   22B1 FF FF FF FF 
2742   22B5 FF FF FF FF 
2742   22B9 FF FF FF FF 
2742   22BD FF FF FF FF 
2742   22C1 FF FF FF FF 
2742   22C5 FF FF FF FF 
2742   22C9 FF FF FF FF 
2742   22CD FF FF FF FF 
2742   22D1 FF FF FF FF 
2742   22D5 FF FF FF FF 
2742   22D9 FF FF FF FF 
2742   22DD FF FF FF FF 
2742   22E1 FF FF FF FF 
2742   22E5 FF FF FF FF 
2742   22E9 FF FF FF FF 
2742   22ED FF FF FF FF 
2742   22F1 FF FF FF FF 
2742   22F5 FF FF FF FF 
2742   22F9 FF FF FF FF 
2742   22FD FF FF FF FF 
2742   2301 FF FF FF FF 
2742   2305 FF FF FF FF 
2742   2309 FF FF FF FF 
2742   230D FF FF FF FF 
2742   2311 FF FF FF FF 
2742   2315 FF FF FF FF 
2742   2319 FF FF FF FF 
2742   231D FF FF FF FF 
2742   2321 FF FF FF FF 
2742   2325 FF FF FF FF 
2742   2329 FF FF FF FF 
2742   232D FF FF FF FF 
2742   2331 FF FF FF FF 
2742   2335 FF FF FF FF 
2742   2339 FF FF FF FF 
2742   233D FF FF FF FF 
2742   2341 FF FF FF FF 
2742   2345 FF FF FF FF 
2742   2349 FF FF FF FF 
2742   234D FF FF FF FF 
2742   2351 FF FF FF FF 
2742   2355 FF FF FF FF 
2742   2359 FF FF FF FF 
2742   235D FF FF FF FF 
2742   2361 FF FF FF FF 
2742   2365 FF FF FF FF 
2742   2369 FF FF FF FF 
2742   236D FF FF FF FF 
2742   2371 FF FF FF FF 
2742   2375 FF FF FF FF 
2742   2379 FF FF FF FF 
2742   237D FF FF FF FF 
2742   2381 FF FF FF FF 
2742   2385 FF FF FF FF 
2742   2389 FF FF FF FF 
2742   238D FF FF FF FF 
2742   2391 FF FF FF FF 
2742   2395 FF FF FF FF 
2742   2399 FF FF FF FF 
2742   239D FF FF FF FF 
2742   23A1 FF FF FF FF 
2742   23A5 FF FF FF FF 
2742   23A9 FF FF FF FF 
2742   23AD FF FF FF FF 
2742   23B1 FF FF FF FF 
2742   23B5 FF FF FF FF 
2742   23B9 FF FF FF FF 
2742   23BD FF FF FF FF 
2742   23C1 FF FF FF FF 
2742   23C5 FF FF FF FF 
2742   23C9 FF FF FF FF 
2742   23CD FF FF FF FF 
2742   23D1 FF FF FF FF 
2742   23D5 FF FF FF FF 
2742   23D9 FF FF FF FF 
2742   23DD FF FF FF FF 
2742   23E1 FF FF FF FF 
2742   23E5 FF FF FF FF 
2742   23E9 FF FF FF FF 
2742   23ED FF FF FF FF 
2742   23F1 FF FF FF FF 
2742   23F5 FF FF FF FF 
2742   23F9 FF FF FF FF 
2742   23FD FF FF FF FF 
2742   2401 FF FF FF FF 
2742   2405 FF FF FF FF 
2742   2409 FF FF FF FF 
2742   240D FF FF FF FF 
2742   2411 FF FF FF FF 
2742   2415 FF FF FF FF 
2742   2419 FF FF FF FF 
2742   241D FF FF FF FF 
2742   2421 FF FF FF FF 
2742   2425 FF FF FF FF 
2742   2429 FF FF FF FF 
2742   242D FF FF FF FF 
2742   2431 FF FF FF FF 
2742   2435 FF FF FF FF 
2742   2439 FF FF FF FF 
2742   243D FF FF FF FF 
2742   2441 FF FF FF FF 
2742   2445 FF FF FF FF 
2742   2449 FF FF FF FF 
2742   244D FF FF FF FF 
2742   2451 FF FF FF FF 
2742   2455 FF FF FF FF 
2742   2459 FF FF FF FF 
2742   245D FF FF FF FF 
2742   2461 FF FF FF FF 
2742   2465 FF FF FF FF 
2742   2469 FF FF FF FF 
2742   246D FF FF FF FF 
2742   2471 FF FF FF FF 
2742   2475 FF FF FF FF 
2742   2479 FF FF FF FF 
2742   247D FF FF FF FF 
2742   2481 FF FF FF FF 
2742   2485 FF FF FF FF 
2742   2489 FF FF FF FF 
2742   248D FF FF FF FF 
2742   2491 FF FF FF FF 
2742   2495 FF FF FF FF 
2742   2499 FF FF FF FF 
2742   249D FF FF FF FF 
2742   24A1 FF FF FF FF 
2742   24A5 FF FF FF FF 
2743   24A9             
2744   24A9 FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2744   24AD FF FF FF FF 
2744   24B1 FF FF FF FF 
2744   24B5 FF FF FF FF 
2744   24B9 FF FF FF FF 
2744   24BD FF FF FF FF 
2744   24C1 FF FF FF FF 
2744   24C5 FF FF FF FF 
2744   24C9 FF FF FF FF 
2744   24CD FF FF FF FF 
2744   24D1 FF FF FF FF 
2744   24D5 FF FF FF FF 
2744   24D9 FF FF FF FF 
2744   24DD FF FF FF FF 
2744   24E1 FF FF FF FF 
2744   24E5 FF FF FF FF 
2744   24E9 FF FF FF FF 
2744   24ED FF FF FF FF 
2744   24F1 FF FF FF FF 
2744   24F5 FF FF FF FF 
2744   24F9 FF FF FF FF 
2744   24FD FF FF FF FF 
2744   2501 FF FF FF FF 
2744   2505 FF FF FF FF 
2744   2509 FF FF FF FF 
2744   250D FF FF FF FF 
2744   2511 FF FF FF FF 
2744   2515 FF FF FF FF 
2744   2519 FF FF FF FF 
2744   251D FF FF FF FF 
2744   2521 FF FF FF FF 
2744   2525 FF FF FF FF 
2744   2529 FF FF FF FF 
2744   252D FF FF FF FF 
2744   2531 FF FF FF FF 
2744   2535 FF FF FF FF 
2744   2539 FF FF FF FF 
2744   253D FF FF FF FF 
2744   2541 FF FF FF FF 
2744   2545 FF FF FF FF 
2744   2549 FF FF FF FF 
2744   254D FF FF FF FF 
2744   2551 FF FF FF FF 
2744   2555 FF FF FF FF 
2744   2559 FF FF FF FF 
2744   255D FF FF FF FF 
2744   2561 FF FF FF FF 
2744   2565 FF FF FF FF 
2744   2569 FF FF FF FF 
2744   256D FF FF FF FF 
2744   2571 FF FF FF FF 
2744   2575 FF FF FF FF 
2744   2579 FF FF FF FF 
2744   257D FF FF FF FF 
2744   2581 FF FF FF FF 
2744   2585 FF FF FF FF 
2744   2589 FF FF FF FF 
2744   258D FF FF FF FF 
2744   2591 FF FF FF FF 
2744   2595 FF FF FF FF 
2744   2599 FF FF FF FF 
2744   259D FF FF FF FF 
2744   25A1 FF FF FF FF 
2744   25A5 FF FF FF FF 
2744   25A9 FF FF FF FF 
2744   25AD FF FF FF FF 
2744   25B1 FF FF FF FF 
2744   25B5 FF FF FF FF 
2744   25B9 FF FF FF FF 
2744   25BD FF FF FF FF 
2744   25C1 FF FF FF FF 
2744   25C5 FF FF FF FF 
2744   25C9 FF FF FF FF 
2744   25CD FF FF FF FF 
2744   25D1 FF FF FF FF 
2744   25D5 FF FF FF FF 
2744   25D9 FF FF FF FF 
2744   25DD FF FF FF FF 
2744   25E1 FF FF FF FF 
2744   25E5 FF FF FF FF 
2744   25E9 FF FF FF FF 
2744   25ED FF FF FF FF 
2744   25F1 FF FF FF FF 
2744   25F5 FF FF FF FF 
2744   25F9 FF FF FF FF 
2744   25FD FF FF FF FF 
2744   2601 FF FF FF FF 
2744   2605 FF FF FF FF 
2744   2609 FF FF FF FF 
2744   260D FF FF FF FF 
2744   2611 FF FF FF FF 
2744   2615 FF FF FF FF 
2744   2619 FF FF FF FF 
2744   261D FF FF FF FF 
2744   2621 FF FF FF FF 
2744   2625 FF FF FF FF 
2744   2629 FF FF FF FF 
2744   262D FF FF FF FF 
2744   2631 FF FF FF FF 
2744   2635 FF FF FF FF 
2744   2639 FF FF FF FF 
2744   263D FF FF FF FF 
2744   2641 FF FF FF FF 
2744   2645 FF FF FF FF 
2744   2649 FF FF FF FF 
2744   264D FF FF FF FF 
2744   2651 FF FF FF FF 
2744   2655 FF FF FF FF 
2744   2659 FF FF FF FF 
2744   265D FF FF FF FF 
2744   2661 FF FF FF FF 
2744   2665 FF FF FF FF 
2744   2669 FF FF FF FF 
2744   266D FF FF FF FF 
2744   2671 FF FF FF FF 
2744   2675 FF FF FF FF 
2744   2679 FF FF FF FF 
2744   267D FF FF FF FF 
2744   2681 FF FF FF FF 
2744   2685 FF FF FF FF 
2744   2689 FF FF FF FF 
2744   268D FF FF FF FF 
2744   2691 FF FF FF FF 
2744   2695 FF FF FF FF 
2744   2699 FF FF FF FF 
2744   269D FF FF FF FF 
2744   26A1 FF FF FF FF 
2744   26A5 FF FF FF FF 
2745   26A9 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2746   26AA             
2747   26AA             
2748   26AA             .end
tasm: Number of errors = 0
