0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             ; Memory Map
0005   0000             ; ------------------------------------------------------------------------------------------------------------------;
0006   0000             ; 0000    ROM BEGIN
0007   0000             ; ....
0008   0000             ; 7FFF    ROM END
0009   0000             ;
0010   0000             ; 8000    RAM begin
0011   0000             ; ....
0012   0000             ; F7FF    Stack root
0013   0000             ; ------------------------------------------------------------------------------------------------------------------;
0014   0000             ; I/O MAP
0015   0000             ; ------------------------------------------------------------------------------------------------------------------;
0016   0000             ; FF80    UART 0    (16550)
0017   0000             ; FF90    UART 1    (16550)
0018   0000             ; FFA0    RTC       (M48T02)
0019   0000             ; FFB0    PIO 0     (8255)
0020   0000             ; FFC0    PIO 1     (8255)
0021   0000             ; FFD0    IDE       (Compact Flash / PATA)
0022   0000             ; FFE0    Timer     (8253)
0023   0000             ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0024   0000             ; ------------------------------------------------------------------------------------------------------------------;
0025   0000             
0026   0000             ; ------------------------------------------------------------------------------------------------------------------;
0027   0000             ; System Constants
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             _UART0_DATA       .equ $FF80            ; data
0030   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0031   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0032   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0033   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0034   0000             _UART0_LCR        .equ $FF83            ; line control register
0035   0000             _UART0_LSR        .equ $FF85            ; line status register
0036   0000             
0037   0000             _UART1_DATA       .equ $FF90            ; data
0038   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0039   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0040   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0041   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0042   0000             _UART1_LCR        .equ $FF93            ; line control register
0043   0000             _UART1_LSR        .equ $FF95            ; line status register
0044   0000             
0045   0000             XON               .equ $11
0046   0000             XOFF              .equ $13
0047   0000             
0048   0000             _ide_BASE         .equ $FFD0            ; IDE BASE
0049   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0050   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0051   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0052   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0053   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0054   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0055   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0056   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0057   0000             
0058   0000             _7SEG_DISPLAY     .equ $FFB0            ; BIOS POST CODE HEX DISPLAY (2 DIGITS)
0059   0000             _BIOS_POST_CTRL   .equ $FFB3            ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0060   0000             _PIO_A            .equ $FFB0    
0061   0000             _PIO_B            .equ $FFB1
0062   0000             _PIO_C            .equ $FFB2
0063   0000             _PIO_CONTROL      .equ $FFB3            ; PIO CONTROL PORT
0064   0000             
0065   0000             _TIMER_C_0        .equ $FFE0            ; TIMER COUNTER 0
0066   0000             _TIMER_C_1        .equ $FFE1            ; TIMER COUNTER 1
0067   0000             _TIMER_C_2        .equ $FFE2            ; TIMER COUNTER 2
0068   0000             _TIMER_CTRL       .equ $FFE3            ; TIMER CONTROL REGISTER
0069   0000             
0070   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0071   0000             FIFO_SIZE         .equ 1024
0072   0000             
0073   0000             text_org          .equ $400
0074   0000             ; ------------------------------------------------------------------------------------------------------------------;
0075   0000             
0076   0000             
0077   0000             ; For the next iteration:
0078   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0079   0000             ; inode-table format:
0080   0000             ;  file-type(f, d)
0081   0000             ;  permissons
0082   0000             ;  link-count
0083   0000             ;  filesize
0084   0000             ;  time-stamps
0085   0000             ;  15 data block pointers
0086   0000             ;  single-indirect pointer
0087   0000             
0088   0000             ; FILE ENTRY ATTRIBUTES
0089   0000             ; filename (24)
0090   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0091   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0092   0000             ; size (2)             : filesize
0093   0000             ; day (1)           
0094   0000             ; month (1)
0095   0000             ; year (1)
0096   0000             ; packet size = 32 bytes  : total packet size in bytes
0097   0000             
0098   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0099   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0100   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0101   0000             FST_NBR_DIRECTORIES     .equ 64
0102   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0103   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0104   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0105   0000             FST_LBA_START           .equ 32
0106   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0107   0000             
0108   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0109   0000             FS_SECTORS_PER_FILE     .equ 32         ; the first sector is always a header with a NULL parameter (first byte)
0110   0000                                                     ; so that we know which blocks are free or taken
0111   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0112   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0113   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0114   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0115   0000             
0116   0000             root_id:                .equ FST_LBA_START
0117   0000             
0118   0000             ; ------------------------------------------------------------------------------------------------------------------;
0119   0000             ; GLOBAL SYSTEM VARIABLES
0120   0000             ; ------------------------------------------------------------------------------------------------------------------;
0121   0000             
0122   0000             ; ------------------------------------------------------------------------------------------------------------------;
0123   0000             ; IRQ Table
0124   0000             ; Highest priority at lowest address
0125   0000             ; ------------------------------------------------------------------------------------------------------------------;
0126   0000 3A 00       .dw int_0
0127   0002 3B 00       .dw int_1
0128   0004 3C 00       .dw int_2
0129   0006 3D 00       .dw int_3
0130   0008 3E 00       .dw int_4
0131   000A 3F 00       .dw int_5
0132   000C 40 00       .dw int_6
0133   000E 8C 00       .dw int_7
0134   0010             
0135   0010             ; ------------------------------------------------------------------------------------------------------------------;
0136   0010             ; Reset Vector
0137   0010             ; ------------------------------------------------------------------------------------------------------------------;
0138   0010 61 0D       .dw kernel_reset_vector
0139   0012             
0140   0012             ; ------------------------------------------------------------------------------------------------------------------;
0141   0012             ; Exception Vector Table
0142   0012             ; Total of 7 entries, starting at address $0012
0143   0012             ; ------------------------------------------------------------------------------------------------------------------;
0144   0012 78 01       .dw trap_privilege
0145   0014 95 02       .dw trap_div_zero
0146   0016 A2 02       .dw trap_undef_opcode
0147   0018 00 00       .dw 0
0148   001A 00 00       .dw 0
0149   001C 00 00       .dw 0
0150   001E 00 00       .dw 0
0151   0020             
0152   0020             ; ------------------------------------------------------------------------------------------------------------------;
0153   0020             ; System Call Vector Table
0154   0020             ; Starts at address $0020
0155   0020             ; ------------------------------------------------------------------------------------------------------------------;
0156   0020 84 01       .dw syscall_break
0157   0022 A3 02       .dw syscall_rtc
0158   0024 DD 03       .dw syscall_ide
0159   0026 B8 04       .dw syscall_io
0160   0028 75 05       .dw syscall_file_system
0161   002A 38 0E       .dw syscall_spawn_proc
0162   002C 3D 01       .dw syscall_list_procs
0163   002E D5 02       .dw syscall_datetime
0164   0030 F9 00       .dw syscall_reboot
0165   0032 02 0E       .dw syscall_pause_proc
0166   0034 05 01       .dw syscall_resume_proc
0167   0036 BF 0D       .dw syscall_terminate_proc
0168   0038 CB 00       .dw syscall_system
0169   003A             
0170   003A             ; ------------------------------------------------------------------------------------------------------------------;
0171   003A             ; System Call Aliases
0172   003A             ; ------------------------------------------------------------------------------------------------------------------;
0173   003A             sys_break            .equ 0
0174   003A             sys_rtc              .equ 1
0175   003A             sys_ide              .equ 2
0176   003A             sys_io               .equ 3
0177   003A             sys_filesystem       .equ 4
0178   003A             sys_spawn_proc       .equ 5
0179   003A             sys_list             .equ 6
0180   003A             sys_datetime         .equ 7
0181   003A             sys_reboot           .equ 8
0182   003A             sys_pause_proc       .equ 9
0183   003A             sys_resume_proc      .equ 10
0184   003A             sys_terminate_proc   .equ 11
0185   003A             sys_system           .equ 12
0186   003A             
0187   003A             ; ------------------------------------------------------------------------------------------------------------------;
0188   003A             ; Alias Exports
0189   003A             ; ------------------------------------------------------------------------------------------------------------------;
0190   003A             .export text_org
0191   003A             .export sys_break
0192   003A             .export sys_ide
0193   003A             .export sys_io
0194   003A             .export sys_filesystem
0195   003A             .export sys_spawn_proc
0196   003A             .export sys_list
0197   003A             .export sys_rtc
0198   003A             .export sys_datetime
0199   003A             .export sys_reboot
0200   003A             .export sys_pause_proc
0201   003A             .export sys_resume_proc
0202   003A             .export sys_terminate_proc
0203   003A             .export sys_system
0204   003A             
0205   003A             ; ------------------------------------------------------------------------------------------------------------------;
0206   003A             ; IRQs' Code Block
0207   003A             ; ------------------------------------------------------------------------------------------------------------------;
0208   003A             int_0:
0209   003A 06            sysret
0210   003B             int_1:
0211   003B 06            sysret
0212   003C             int_2:
0213   003C 06            sysret
0214   003D             int_3:
0215   003D 06            sysret
0216   003E             int_4:
0217   003E 06            sysret
0218   003F             int_5:
0219   003F 06            sysret
0220   0040             
0221   0040             ; ------------------------------------------------------------------------------------------------------------------;
0222   0040             ; Process Swapping
0223   0040             ; ------------------------------------------------------------------------------------------------------------------;
0224   0040             int_6:  
0225   0040 4B            pusha ; save all registers into kernel stack
0226   0041 22 00         mov ah, 0
0227   0043 1D 30 16      mov al, [active_proc_index]
0228   0046 FD 99         shl a              ; x2
0229   0048 B7 B5 0E      mov a, [proc_table_convert + a]  ; get process state start index
0230   004B 4F            mov di, a
0231   004C 48            mov a, sp
0232   004D 77            inc a
0233   004E 4D            mov si, a
0234   004F 38 14 00      mov c, 20
0235   0052 FD F5         rep movsb          ; save process state!
0236   0054             ; restore kernel stack position to point before interrupt arrived
0237   0054 51 14 00      add sp, 20
0238   0057             ; now load next process in queue
0239   0057 1D 30 16      mov al, [active_proc_index]
0240   005A 31 2F 16      mov bl, [nbr_active_procs]
0241   005D BA            cmp al, bl
0242   005E C6 65 00      je int6_cycle_back
0243   0061 7A            inc al            ; next process is next in the series
0244   0062 0A 67 00      jmp int6_continue
0245   0065             int6_cycle_back:
0246   0065 19 01         mov al, 1        ; next process = process 1
0247   0067             int6_continue:
0248   0067 3D 30 16      mov [active_proc_index], al    ; set next active proc
0249   006A             
0250   006A             ; calculate LUT entry for next process
0251   006A 22 00         mov ah, 0
0252   006C FD 99         shl a              ; x2
0253   006E B7 B5 0E      mov a, [proc_table_convert + a]    ; get process state start index  
0254   0071               
0255   0071 4D            mov si, a            ; source is proc state block
0256   0072 48            mov a, sp
0257   0073 5F 13 00      sub a, 19
0258   0076 4F            mov di, a            ; destination is kernel stack
0259   0077             ; restore SP
0260   0077 7D            dec a
0261   0078 47            mov sp, a
0262   0079 38 14 00      mov c, 20
0263   007C FD F5         rep movsb
0264   007E             ; set VM process
0265   007E 1D 30 16      mov al, [active_proc_index]
0266   0081 01            setptb
0267   0082 F2 E0 FF 00   mov byte[_TIMER_C_0], 0        ; load counter 0 low byte
0268   0086 F2 E0 FF 10   mov byte[_TIMER_C_0], $10        ; load counter 0 high byte
0269   008A 4C            popa
0270   008B 06            sysret
0271   008C             
0272   008C             ; ------------------------------------------------------------------------------------------------------------------;
0273   008C             ; UART0 Interrupt
0274   008C             ; ------------------------------------------------------------------------------------------------------------------;
0275   008C             int_7:
0276   008C D7            push a
0277   008D DA            push d
0278   008E E1            pushf
0279   008F 14 35 16      mov a, [fifo_in]
0280   0092 3C            mov d, a
0281   0093 1D 80 FF      mov al, [_UART0_DATA]  ; get character
0282   0096 B9 03         cmp al, $03        ; CTRL-C
0283   0098 C6 B5 00      je CTRLC
0284   009B B9 1A         cmp al, $1A        ; CTRL-Z
0285   009D C6 BB 00      je CTRLZ
0286   00A0 3E            mov [d], al        ; add to fifo
0287   00A1 14 35 16      mov a, [fifo_in]
0288   00A4 77            inc a
0289   00A5 AF 24 21      cmp a, fifo + FIFO_SIZE         ; check if pointer reached the end of the fifo
0290   00A8 C7 AE 00      jne int_7_continue
0291   00AB 10 24 1D      mov a, fifo  
0292   00AE             int_7_continue:  
0293   00AE 42 35 16      mov [fifo_in], a      ; update fifo pointer
0294   00B1 EE            popf
0295   00B2 E7            pop d
0296   00B3 E4            pop a  
0297   00B4 06            sysret
0298   00B5             CTRLC:
0299   00B5 51 05 00      add sp, 5
0300   00B8 0A BF 0D      jmp syscall_terminate_proc
0301   00BB             CTRLZ:
0302   00BB EE            popf
0303   00BC E7            pop d
0304   00BD E4            pop a
0305   00BE 0A 02 0E      jmp syscall_pause_proc    ; pause current process and go back to the shell
0306   00C1             
0307   00C1             ; ------------------------------------------------------------------------------------------------------------------;
0308   00C1             ; System Syscalls
0309   00C1             ; ------------------------------------------------------------------------------------------------------------------;
0310   00C1             system_jmptbl:
0311   00C1 F7 00         .dw system_uname
0312   00C3 F8 00         .dw system_whoami
0313   00C5 F4 00         .dw system_setparam
0314   00C7 D1 00         .dw system_bootloader_install
0315   00C9 CF 00         .dw system_getparam
0316   00CB             syscall_system:
0317   00CB FD 0A C1 00   jmp [system_jmptbl + al]
0318   00CF             
0319   00CF             ; param register address in register d
0320   00CF             ; param value in register bl
0321   00CF             system_getparam:
0322   00CF 32            mov bl, [d]
0323   00D0 06            sysret
0324   00D1             
0325   00D1             ; kernel LBA address in 'b'
0326   00D1             system_bootloader_install:
0327   00D1 D8            push b
0328   00D2 26 00 00      mov b, 0
0329   00D5 38 00 00      mov c, 0
0330   00D8 22 01         mov ah, $01                 ; 1 sector
0331   00DA 3B 24 23      mov d, transient_area
0332   00DD 07 27 04      call ide_read_sect          ; read sector
0333   00E0 E5            pop b
0334   00E1 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0335   00E5 26 00 00      mov b, 0
0336   00E8 38 00 00      mov c, 0
0337   00EB 22 01         mov ah, $01                 ; 1 sector
0338   00ED 3B 24 23      mov d, transient_area
0339   00F0 07 4D 04      call ide_write_sect         ; write sector
0340   00F3 06            sysret
0341   00F4             
0342   00F4             ; param register address in register d
0343   00F4             ; param value in register bl
0344   00F4             system_setparam:
0345   00F4 FD 3E         mov [d], bl
0346   00F6 06            sysret
0347   00F7             
0348   00F7             system_uname:
0349   00F7 06            sysret
0350   00F8             
0351   00F8             system_whoami:
0352   00F8 06            sysret
0353   00F9             
0354   00F9             ; REBOOT SYSTEM
0355   00F9             syscall_reboot:
0356   00F9 FD D7 FF FF   push word $FFFF 
0357   00FD FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0358   0100 FD D7 C0 01   push word BIOS_RESET_VECTOR    ; and then push RESET VECTOR of the shell to the stack
0359   0104 06            sysret
0360   0105             
0361   0105             ;------------------------------------------------------------------------------------------------------;;
0362   0105             ; switch to another process
0363   0105             ; inputs:
0364   0105             ; AL = new process number
0365   0105             ;------------------------------------------------------------------------------------------------------;;
0366   0105             syscall_resume_proc:
0367   0105 FD 78         mov g, a                            ; save the process number
0368   0107 4B            pusha                               ; save all registers into kernel stack
0369   0108 22 00         mov ah, 0
0370   010A 1D 30 16      mov al, [active_proc_index]
0371   010D FD 99         shl a              ; x2
0372   010F B7 B5 0E      mov a, [proc_table_convert + a]     ; get process state start index
0373   0112 4F            mov di, a
0374   0113 48            mov a, sp
0375   0114 77            inc a
0376   0115 4D            mov si, a
0377   0116 38 14 00      mov c, 20
0378   0119 FD F5         rep movsb                           ; save process state!
0379   011B             ; restore kernel stack position to point before interrupt arrived
0380   011B 51 14 00      add sp, 20
0381   011E             ; now load the new process number!
0382   011E FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0383   0120 3D 30 16      mov [active_proc_index], al         ; set new active proc
0384   0123             ; calculate LUT entry for next process
0385   0123 22 00         mov ah, 0
0386   0125 FD 99         shl a                               ; x2
0387   0127 B7 B5 0E      mov a, [proc_table_convert + a]     ; get process state start index  
0388   012A 4D            mov si, a                           ; source is proc state block
0389   012B 48            mov a, sp
0390   012C 5F 13 00      sub a, 19
0391   012F 4F            mov di, a                           ; destination is kernel stack
0392   0130             ; restore SP
0393   0130 7D            dec a
0394   0131 47            mov sp, a
0395   0132 38 14 00      mov c, 20
0396   0135 FD F5         rep movsb
0397   0137             ; set VM process
0398   0137 1D 30 16      mov al, [active_proc_index]
0399   013A 01            setptb
0400   013B 4C            popa
0401   013C 06            sysret
0402   013D             
0403   013D             syscall_list_procs:
0404   013D 3B 55 16      mov d, s_ps_header
0405   0140 07 FF 10      call _puts
0406   0143 3B 95 18      mov d, proc_availab_table + 1
0407   0146 38 01 00      mov c, 1
0408   0149             list_procs_L0:  
0409   0149 BD 01         cmp byte[d], 1
0410   014B C7 6F 01      jne list_procs_next
0411   014E 2D            mov b, d
0412   014F 61 94 18      sub b, proc_availab_table
0413   0152 FD 9F 05      shl b, 5
0414   0155 DA            push d
0415   0156 D8            push b
0416   0157 28            mov b, c
0417   0158 07 9F 11      call print_u8x
0418   015B 22 20         mov ah, ' '
0419   015D 07 D3 0F      call _putchar
0420   0160 07 D3 0F      call _putchar
0421   0163 E5            pop b
0422   0164 74            mov d, b
0423   0165 58 A4 18      add d, proc_names
0424   0168 07 FF 10      call _puts
0425   016B 07 AC 10      call printnl
0426   016E E7            pop d
0427   016F             list_procs_next:
0428   016F 79            inc d
0429   0170 78            inc c
0430   0171 C2 09 00      cmp c, 9
0431   0174 C7 49 01      jne list_procs_L0
0432   0177             list_procs_end:
0433   0177 06            sysret
0434   0178             
0435   0178             ; ------------------------------------------------------------------------------------------------------------------;
0436   0178             ; Exceptions' Code Block
0437   0178             ; ------------------------------------------------------------------------------------------------------------------;
0438   0178             ; Privilege
0439   0178             ; ------------------------------------------------------------------------------------------------------------------;
0440   0178             trap_privilege:
0441   0178 0A F9 00      jmp syscall_reboot
0442   017B DA            push d
0443   017C 3B 97 16      mov d, s_priviledge
0444   017F 07 FF 10      call _puts
0445   0182 E7            pop d
0446   0183 06            sysret
0447   0184             
0448   0184             ; ------------------------------------------------------------------------------------------------------------------;
0449   0184             ; Breakpoint
0450   0184             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0451   0184             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0452   0184             ; ------------------------------------------------------------------------------------------------------------------;
0453   0184             syscall_break:
0454   0184 4B            pusha
0455   0185             syscall_break_prompt:
0456   0185 3B 3F 02      mov d, s_break1
0457   0188 07 FF 10      call _puts
0458   018B 07 AC 10      call printnl
0459   018E 07 01 12      call scan_u16d
0460   0191 AF 00 00      cmp a, 0
0461   0194 C6 9F 01      je syscall_break_regs
0462   0197 AF 01 00      cmp a, 1
0463   019A C6 C2 01      je syscall_break_mem
0464   019D             syscall_break_end:  
0465   019D 4C            popa
0466   019E 06            sysret
0467   019F             syscall_break_regs:
0468   019F 48            mov a, sp
0469   01A0 53 0E 00      add a, 14               ; back-track 7 registers
0470   01A3 3C            mov d, a
0471   01A4 3A 07         mov cl, 7
0472   01A6             syscall_regs_L0:
0473   01A6 2A            mov b, [d]
0474   01A7 FD AB         swp b
0475   01A9 07 5B 11      call print_u16x         ; print register value
0476   01AC 07 AC 10      call printnl
0477   01AF 63 02 00      sub d, 2
0478   01B2 71 01         sub cl, 1
0479   01B4 C3 00         cmp cl, 0
0480   01B6 C7 A6 01      jne syscall_regs_L0
0481   01B9 0A 85 01      jmp syscall_break_prompt
0482   01BC 07 AC 10      call printnl
0483   01BF 0A 85 01      jmp syscall_break_prompt
0484   01C2             syscall_break_mem:
0485   01C2 07 AC 10      call printnl
0486   01C5 07 7D 11      call scan_u16x
0487   01C8 4D            mov si, a               ; data source from user space
0488   01C9 FD 4F 24 21   mov di, scrap_sector    ; destination in kernel space
0489   01CD 38 00 02      mov c, 512
0490   01D0 04            load                    ; transfer data to kernel space!
0491   01D1 3B 24 21      mov d, scrap_sector     ; dump pointer in d
0492   01D4 38 00 00      mov c, 0
0493   01D7             dump_loop:
0494   01D7 84            mov al, cl
0495   01D8 87 0F         and al, $0F
0496   01DA C6 28 02      jz print_base
0497   01DD             back:
0498   01DD 1E            mov al, [d]             ; read byte
0499   01DE 2F            mov bl, al
0500   01DF 07 9F 11      call print_u8x
0501   01E2 10 00 20      mov a, $2000
0502   01E5 05 03         syscall sys_io          ; space
0503   01E7 84            mov al, cl
0504   01E8 87 0F         and al, $0F
0505   01EA B9 0F         cmp al, $0F
0506   01EC C6 FD 01      je print_ascii
0507   01EF             back1:
0508   01EF 79            inc d
0509   01F0 78            inc c
0510   01F1 C2 00 02      cmp c, 512
0511   01F4 C7 D7 01      jne dump_loop
0512   01F7 07 AC 10      call printnl
0513   01FA 0A 85 01      jmp syscall_break_prompt  ; go to syscall_break return point
0514   01FD             print_ascii:
0515   01FD 10 00 20      mov a, $2000
0516   0200 05 03         syscall sys_io
0517   0202 63 10 00      sub d, 16
0518   0205 26 10 00      mov b, 16
0519   0208             print_ascii_L:
0520   0208 79            inc d
0521   0209 1E            mov al, [d]               ; read byte
0522   020A B9 20         cmp al, $20
0523   020C C8 14 02      jlu dot
0524   020F B9 7E         cmp al, $7E
0525   0211 D0 1C 02      jleu ascii
0526   0214             dot:
0527   0214 10 00 2E      mov a, $2E00
0528   0217 05 03         syscall sys_io
0529   0219 0A 21 02      jmp ascii_continue
0530   021C             ascii:
0531   021C 23            mov ah, al
0532   021D 19 00         mov al, 0
0533   021F 05 03         syscall sys_io
0534   0221             ascii_continue:
0535   0221 FD A9 08 02   loopb print_ascii_L
0536   0225 0A EF 01      jmp back1
0537   0228             print_base:
0538   0228 07 AC 10      call printnl
0539   022B 2D            mov b, d
0540   022C 61 24 21      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0541   022F 07 5B 11      call print_u16x          ; display row
0542   0232 10 00 3A      mov a, $3A00
0543   0235 05 03         syscall sys_io
0544   0237 10 00 20      mov a, $2000
0545   023A 05 03         syscall sys_io
0546   023C 0A DD 01      jmp back
0547   023F             
0548   023F             s_break1:  
0549   023F 0A 44 65 62   .db "\nDebugger entry point.\n"
0549   0243 75 67 67 65 
0549   0247 72 20 65 6E 
0549   024B 74 72 79 20 
0549   024F 70 6F 69 6E 
0549   0253 74 2E 0A 
0550   0256 30 2E 20 53   .db "0. Show Registers\n"
0550   025A 68 6F 77 20 
0550   025E 52 65 67 69 
0550   0262 73 74 65 72 
0550   0266 73 0A 
0551   0268 31 2E 20 53   .db "1. Show 512B RAM block\n"
0551   026C 68 6F 77 20 
0551   0270 35 31 32 42 
0551   0274 20 52 41 4D 
0551   0278 20 62 6C 6F 
0551   027C 63 6B 0A 
0552   027F 32 2E 20 43   .db "2. Continue Execution", 0
0552   0283 6F 6E 74 69 
0552   0287 6E 75 65 20 
0552   028B 45 78 65 63 
0552   028F 75 74 69 6F 
0552   0293 6E 00 
0553   0295             
0554   0295             ; ------------------------------------------------------------------------------------------------------------------;
0555   0295             ; Divide by Zero
0556   0295             ; ------------------------------------------------------------------------------------------------------------------;
0557   0295             trap_div_zero:
0558   0295 D7            push a
0559   0296 DA            push d
0560   0297 E1            pushf
0561   0298 3B AE 16      mov d, s_divzero
0562   029B 07 FF 10      call _puts
0563   029E EE            popf
0564   029F E7            pop d
0565   02A0 E4            pop a
0566   02A1 06            sysret ; enable interrupts
0567   02A2             
0568   02A2             ; ------------------------------------------------------------------------------------------------------------------;
0569   02A2             ; Undefined Opcode
0570   02A2             ; ------------------------------------------------------------------------------------------------------------------;
0571   02A2             trap_undef_opcode:
0572   02A2 06            sysret
0573   02A3             
0574   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0575   02A3             ; RTC Services Syscall
0576   02A3             ; RTC I/O bank = FFA0 to FFAF
0577   02A3             ; FFA0 to FFA7 is scratch RAM
0578   02A3             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0579   02A3             ; al = 0..6 -> get
0580   02A3             ; al = 7..D -> set
0581   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0582   02A3             syscall_rtc:
0583   02A3 DB            push al
0584   02A4 DA            push d
0585   02A5 B9 06         cmp al, 6
0586   02A7 D1 BC 02      jgu syscall_rtc_set
0587   02AA             syscall_rtc_get:
0588   02AA 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0589   02AC 22 FF         mov ah, $FF    
0590   02AE 3C            mov d, a                ; get to FFA9 + offset
0591   02AF F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0592   02B3 1E            mov al, [d]             ; get data
0593   02B4 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0594   02B8 23            mov ah, al
0595   02B9 E7            pop d
0596   02BA E8            pop al
0597   02BB 06            sysret
0598   02BC             syscall_rtc_set:
0599   02BC DD            push bl
0600   02BD 99            mov bl, ah              ; set data asIDE
0601   02BE 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0602   02C0 22 FF         mov ah, $FF    
0603   02C2 3C            mov d, a                ; get to FFA9 + offset
0604   02C3 1B            mov al, bl              ; get data back
0605   02C4 F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0606   02C8 3E            mov [d], al             ; set data
0607   02C9 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0608   02CD EA            pop bl
0609   02CE E7            pop d
0610   02CF E8            pop al
0611   02D0 06            sysret
0612   02D1             
0613   02D1             datetime_serv_tbl:
0614   02D1 D9 02         .dw print_date
0615   02D3 4D 03         .dw set_date
0616   02D5             syscall_datetime:
0617   02D5 FD 0A D1 02   jmp [datetime_serv_tbl + al]      
0618   02D9             print_date:
0619   02D9 10 00 0D      mov a, $0D00           ; print carriage return char
0620   02DC 19 03         mov al, 3
0621   02DE 05 01         syscall sys_rtc        ; get week
0622   02E0 1A            mov al, ah
0623   02E1 22 00         mov ah, 0
0624   02E3 FD 9D 02      shl a, 2          
0625   02E6 3B 38 17      mov d, s_week
0626   02E9 59            add d, a
0627   02EA 07 FF 10      call _puts
0628   02ED 10 00 20      mov a, $2000
0629   02F0 05 03         syscall sys_io         ; display ' '
0630   02F2 19 04         mov al, 4
0631   02F4 05 01         syscall sys_rtc        ; get day
0632   02F6 99            mov bl, ah
0633   02F7 07 9F 11      call print_u8x
0634   02FA 10 00 20      mov a, $2000
0635   02FD 05 03         syscall sys_io         ; display ' '
0636   02FF             ; there is a problem with the month displaying
0637   02FF             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0638   02FF             ; even though it is to be understood as BCD.
0639   02FF             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0640   02FF 19 05         mov al, 05
0641   0301 05 01         syscall sys_rtc        ; get month
0642   0303 1A            mov al, ah
0643   0304 22 00         mov ah, 0
0644   0306 FD 9D 02      shl a, 2          
0645   0309 3B 04 17      mov d, s_months
0646   030C 59            add d, a
0647   030D 07 FF 10      call _puts
0648   0310 10 00 20      mov a, $2000
0649   0313 05 03         syscall sys_io         ; display ' '
0650   0315 2E 20         mov bl, $20
0651   0317 07 9F 11      call print_u8x         ; print 20 for year prefix
0652   031A 19 06         mov al, 06
0653   031C 05 01         syscall sys_rtc        ; get year
0654   031E 99            mov bl, ah
0655   031F 07 9F 11      call print_u8x
0656   0322 10 00 20      mov a, $2000  
0657   0325 05 03         syscall sys_io         ; display ' '
0658   0327 19 02         mov al, 2
0659   0329 05 01         syscall sys_rtc        ; get hours
0660   032B 99            mov bl, ah
0661   032C 07 9F 11      call print_u8x
0662   032F 10 00 3A      mov a, $3A00    
0663   0332 05 03         syscall sys_io         ; display ':'
0664   0334 19 01         mov al, 01
0665   0336 05 01         syscall sys_rtc        ; get minutes
0666   0338 99            mov bl, ah
0667   0339 07 9F 11      call print_u8x
0668   033C 10 00 3A      mov a, $3A00  
0669   033F 05 03         syscall sys_io         ; display ':'
0670   0341 19 00         mov al, 0
0671   0343 05 01         syscall sys_rtc        ; get seconds
0672   0345 99            mov bl, ah
0673   0346 07 9F 11      call print_u8x
0674   0349 07 AC 10      call printnl
0675   034C 06            sysret
0676   034D             set_date:
0677   034D 3B C9 16      mov d, s_set_year
0678   0350 07 FF 10      call _puts
0679   0353 07 EA 11      call scan_u8x          ; read integer into A
0680   0356 FD 9D 08      shl a, 8               ; only AL used, move to AH
0681   0359 19 0D         mov al, 0Dh            ; set RTC year
0682   035B 05 01         syscall sys_rtc        ; set RTC
0683   035D 3B D0 16      mov d, s_set_month
0684   0360 07 FF 10      call _puts
0685   0363 07 EA 11      call scan_u8x          ; read integer into A
0686   0366 FD 9D 08      shl a, 8               ; only AL used, move to AH
0687   0369 19 0C         mov al, 0Ch            ; set RTC month
0688   036B 05 01         syscall sys_rtc        ; set RTC
0689   036D 3B D8 16      mov d, s_set_day
0690   0370 07 FF 10      call _puts
0691   0373 07 EA 11      call scan_u8x          ; read integer into A
0692   0376 FD 9D 08      shl a, 8               ; only AL used, move to AH
0693   0379 19 0B         mov al, 0Bh            ; set RTC month
0694   037B 05 01         syscall sys_rtc        ; set RTC
0695   037D 3B DE 16      mov d, s_set_week
0696   0380 07 FF 10      call _puts
0697   0383 07 EA 11      call scan_u8x          ; read integer into A
0698   0386 FD 9D 08      shl a, 8               ; only AL used, move to AH
0699   0389 19 0A         mov al, 0Ah            ; set RTC month
0700   038B 05 01         syscall sys_rtc        ; set RTC
0701   038D 3B E8 16      mov d, s_set_hours
0702   0390 07 FF 10      call _puts
0703   0393 07 EA 11      call scan_u8x          ; read integer into A
0704   0396 FD 9D 08      shl a, 8               ; only AL used, move to AH
0705   0399 19 09         mov al, 09h            ; set RTC month
0706   039B 05 01         syscall sys_rtc        ; set RTC
0707   039D 3B F0 16      mov d, s_set_minutes
0708   03A0 07 FF 10      call _puts
0709   03A3 07 EA 11      call scan_u8x          ; read integer into A
0710   03A6 FD 9D 08      shl a, 8               ; only AL used, move to AH
0711   03A9 19 08         mov al, 08h            ; set RTC month
0712   03AB 05 01         syscall sys_rtc        ; set RTC
0713   03AD 3B FA 16      mov d, s_set_seconds
0714   03B0 07 FF 10      call _puts
0715   03B3 07 EA 11      call scan_u8x          ; read integer into A
0716   03B6 FD 9D 08      shl a, 8               ; only AL used, move to AH
0717   03B9 19 07         mov al, 07h            ; set RTC month
0718   03BB 05 01         syscall sys_rtc        ; set RTC
0719   03BD 06            sysret
0720   03BE             
0721   03BE             ; ------------------------------------------------------------------------------------------------------------------;
0722   03BE             ; IDE Services Syscall
0723   03BE             ; al = option
0724   03BE             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0725   03BE             ; IDE read/write sector
0726   03BE             ; 512 bytes
0727   03BE             ; User buffer pointer in D
0728   03BE             ; AH = number of sectors
0729   03BE             ; CB = LBA bytes 3..0
0730   03BE             ; ------------------------------------------------------------------------------------------------------------------;
0731   03BE 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0731   03C2 73 63 61 6C 
0731   03C6 6C 5F 69 64 
0731   03CA 65 20 63 61 
0731   03CE 6C 6C 65 64 
0731   03D2 3A 20 00 
0732   03D5             ide_serv_tbl:
0733   03D5 FC 03         .dw ide_reset
0734   03D7 10 04         .dw ide_sleep
0735   03D9 1F 04         .dw ide_read_sect_wrapper
0736   03DB 23 04         .dw ide_write_sect_wrapper
0737   03DD             syscall_ide:
0738   03DD DD            push bl
0739   03DE 31 28 16      mov bl, [sys_debug_mode]
0740   03E1               ; debug block
0741   03E1 C1 00         cmp bl, 0
0742   03E3 EA            pop bl
0743   03E4 C6 F8 03      je syscall_ide_jmp
0744   03E7 DA            push d
0745   03E8 DD            push bl
0746   03E9 3B BE 03      mov d, s_syscall_ide_dbg0
0747   03EC 07 FF 10      call _puts
0748   03EF 2F            mov bl, al
0749   03F0 07 9F 11      call print_u8x
0750   03F3 07 AC 10      call printnl
0751   03F6 EA            pop bl
0752   03F7 E7            pop d
0753   03F8             syscall_ide_jmp:
0754   03F8 FD 0A D5 03   jmp [ide_serv_tbl + al]    
0755   03FC               
0756   03FC             ide_reset:      
0757   03FC F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0758   0400 07 A9 04      call ide_wait                   ; wait for IDE ready             
0759   0403 F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0760   0407 F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0761   040B F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0762   040F 06            sysret
0763   0410             ide_sleep:
0764   0410 07 A9 04      call ide_wait                   ; wait for IDE ready             
0765   0413 F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0766   0417 F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0767   041B 07 A9 04      call ide_wait                   ; wait for IDE ready
0768   041E 06            sysret
0769   041F             ide_read_sect_wrapper:
0770   041F 07 27 04      call ide_read_sect
0771   0422 06            sysret
0772   0423             ide_write_sect_wrapper:
0773   0423 07 4D 04      call ide_write_sect
0774   0426 06            sysret
0775   0427             ide_read_sect:
0776   0427 1A            mov al, ah
0777   0428 24            mov ah, bl
0778   0429 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0779   042C 1C            mov al, bh
0780   042D 3D D4 FF      mov [_ide_R4], al
0781   0430 12            mov a, c
0782   0431 3D D5 FF      mov [_ide_R5], al
0783   0434 1A            mov al, ah
0784   0435 87 0F         and al, %00001111
0785   0437 8B E0         or al, %11100000                ; mode lba, master
0786   0439 3D D6 FF      mov [_ide_R6], al
0787   043C             ide_read_sect_wait:
0788   043C 1D D7 FF      mov al, [_ide_R7]  
0789   043F 87 80         and al, $80                     ; BUSY FLAG
0790   0441 C7 3C 04      jnz ide_read_sect_wait
0791   0444 19 20         mov al, $20
0792   0446 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0793   0449 07 73 04      call ide_read  
0794   044C 09            ret
0795   044D             ide_write_sect:
0796   044D 1A            mov al, ah
0797   044E 24            mov ah, bl
0798   044F 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0799   0452 1C            mov al, bh
0800   0453 3D D4 FF      mov [_ide_R4], al
0801   0456 12            mov a, c
0802   0457 3D D5 FF      mov [_ide_R5], al
0803   045A 1A            mov al, ah
0804   045B 87 0F         and al, %00001111
0805   045D 8B E0         or al, %11100000                ; mode lba, master
0806   045F 3D D6 FF      mov [_ide_R6], al
0807   0462             ide_write_sect_wait:
0808   0462 1D D7 FF      mov al, [_ide_R7]  
0809   0465 87 80         and al, $80                     ; BUSY FLAG
0810   0467 C7 62 04      jnz ide_write_sect_wait
0811   046A 19 30         mov al, $30
0812   046C 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0813   046F 07 8E 04      call ide_write      
0814   0472 09            ret
0815   0473             
0816   0473             ;----------------------------------------------------------------------------------------------------;
0817   0473             ; READ IDE DATA
0818   0473             ; pointer in D
0819   0473             ;----------------------------------------------------------------------------------------------------;
0820   0473             ide_read:
0821   0473 DA            push d
0822   0474             ide_read_loop:
0823   0474 1D D7 FF      mov al, [_ide_R7]  
0824   0477 87 80         and al, 80h                     ; BUSY FLAG
0825   0479 C7 74 04      jnz ide_read_loop               ; wait loop
0826   047C 1D D7 FF      mov al, [_ide_R7]
0827   047F 87 08         and al, %00001000               ; DRQ FLAG
0828   0481 C6 8C 04      jz ide_read_end
0829   0484 1D D0 FF      mov al, [_ide_R0]
0830   0487 3E            mov [d], al
0831   0488 79            inc d
0832   0489 0A 74 04      jmp ide_read_loop
0833   048C             ide_read_end:
0834   048C E7            pop d
0835   048D 09            ret
0836   048E             
0837   048E             ;----------------------------------------------------------------------------------------------------;
0838   048E             ; WRITE IDE DATA
0839   048E             ; data pointer in D
0840   048E             ;----------------------------------------------------------------------------------------------------;
0841   048E             ide_write:
0842   048E DA            push d
0843   048F             ide_write_loop:
0844   048F 1D D7 FF      mov al, [_ide_R7]  
0845   0492 87 80         and al, 80h             ; BUSY FLAG
0846   0494 C7 8F 04      jnz ide_write_loop      ; wait loop
0847   0497 1D D7 FF      mov al, [_ide_R7]
0848   049A 87 08         and al, %00001000       ; DRQ FLAG
0849   049C C6 A7 04      jz ide_write_end
0850   049F 1E            mov al, [d]
0851   04A0 3D D0 FF      mov [_ide_R0], al
0852   04A3 79            inc d 
0853   04A4 0A 8F 04      jmp ide_write_loop
0854   04A7             ide_write_end:
0855   04A7 E7            pop d
0856   04A8 09            ret
0857   04A9             
0858   04A9             ;----------------------------------------------------------------------------------------------------;
0859   04A9             ; wait for IDE to be ready
0860   04A9             ;----------------------------------------------------------------------------------------------------;
0861   04A9             ide_wait:
0862   04A9 1D D7 FF      mov al, [_ide_R7]  
0863   04AC 87 80         and al, 80h        ; BUSY FLAG
0864   04AE C7 A9 04      jnz ide_wait
0865   04B1 09            ret
0866   04B2             
0867   04B2             ;----------------------------------------------------------------------------------------------------;
0868   04B2             ; IO Syscall
0869   04B2             ;----------------------------------------------------------------------------------------------------;
0870   04B2             ; Baud  Divisor
0871   04B2             ; 50    2304
0872   04B2             ; 110   1047
0873   04B2             ; 300    384
0874   04B2             ; 600    192
0875   04B2             ; 1200    96
0876   04B2             ; 9600    12
0877   04B2             ; 19200    6
0878   04B2             ; 38400    3
0879   04B2             syscall_io_jmp:
0880   04B2 E5 04         .dw syscall_io_putchar
0881   04B4 F2 04         .dw syscall_io_getch
0882   04B6 BC 04         .dw syscall_io_uart_setup
0883   04B8             syscall_io:
0884   04B8 FD 0A B2 04   jmp [syscall_io_jmp + al]
0885   04BC             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0886   04BC             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0887   04BC             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0888   04BC             syscall_io_uart_setup:
0889   04BC 1D 2A 16      mov al, [sys_uart0_lcr]
0890   04BF 8B 80         or al, $80                ; set DLAB access bit
0891   04C1 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0892   04C4 1D 2D 16      mov al, [sys_uart0_div0]
0893   04C7 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0894   04CA 1D 2E 16      mov al, [sys_uart0_div1]
0895   04CD 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0896   04D0             
0897   04D0 1D 2A 16      mov al, [sys_uart0_lcr]
0898   04D3 87 7F         and al, $7F               ; clear DLAB access bit 
0899   04D5 3D 83 FF      mov [_UART0_LCR], al
0900   04D8 1D 2B 16      mov al, [sys_uart0_inten]
0901   04DB 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0902   04DE 1D 2C 16      mov al, [sys_uart0_fifoen]
0903   04E1 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0904   04E4 06            sysret
0905   04E5             
0906   04E5             ; char in ah
0907   04E5             syscall_io_putchar:
0908   04E5             syscall_io_putchar_L0:
0909   04E5 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0910   04E8 87 20         and al, $20
0911   04EA C6 E5 04      jz syscall_io_putchar_L0    
0912   04ED 1A            mov al, ah
0913   04EE 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0914   04F1 06            sysret
0915   04F2             
0916   04F2             ; char in ah
0917   04F2             ; al = sucess code
0918   04F2             syscall_io_getch:
0919   04F2 D8            push b
0920   04F3 DA            push d
0921   04F4 FD 0C         sti
0922   04F6             syscall_io_getch_L0:  
0923   04F6 14 37 16      mov a, [fifo_out]
0924   04F9 29 35 16      mov b, [fifo_in]
0925   04FC B0            cmp a, b
0926   04FD C6 F6 04      je syscall_io_getch_L0
0927   0500 3C            mov d, a
0928   0501 77            inc a
0929   0502 AF 24 21      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
0930   0505 C7 0B 05      jne syscall_io_getch_cont
0931   0508 10 24 1D      mov a, fifo  
0932   050B             syscall_io_getch_cont:  
0933   050B 42 37 16      mov [fifo_out], a             ; update fifo pointer
0934   050E 1E            mov al, [d]                   ; get char
0935   050F 23            mov ah, al
0936   0510 1D 29 16      mov al, [sys_echo_on]
0937   0513 B9 01         cmp al, 1
0938   0515 C7 24 05      jne syscall_io_getch_noecho 
0939   0518             ; here we just echo the char back to the console
0940   0518             syscall_io_getch_echo_L0:
0941   0518 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0942   051B 87 20         and al, $20                 ; isolate Transmitter Empty
0943   051D C6 18 05      jz syscall_io_getch_echo_L0
0944   0520 1A            mov al, ah
0945   0521 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0946   0524             syscall_io_getch_noecho:
0947   0524 19 01         mov al, 1                    ; AL = 1 means a char successfully received
0948   0526 E7            pop d
0949   0527 E5            pop b
0950   0528 06            sysret
0951   0529             
0952   0529             ;------------------------------------------------------------------------------------------------------;
0953   0529             ; FILE SYSTEM DATA
0954   0529             ;------------------------------------------------------------------------------------------------------;
0955   0529             ; infor for : IDE SERVICES INTERRUPT
0956   0529             ; IDE read/write 512-byte sector
0957   0529             ; al = option
0958   0529             ; user buffer pointer in D
0959   0529             ; AH = number of sectors
0960   0529             ; CB = LBA bytes 3..0  
0961   0529             ;------------------------------------------------------------------------------------------------------;
0962   0529             ; FILE SYSTEM DATA STRUCTURE
0963   0529             ;------------------------------------------------------------------------------------------------------;
0964   0529             ; for a directory we have the header first, followed by metadata
0965   0529             ; header 1 sector (512 bytes)
0966   0529             ; metadata 1 sector (512 bytes)
0967   0529             ; HEADER ENTRIES:
0968   0529             ; filename (64)
0969   0529             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0970   0529             ;
0971   0529             ; metadata entries:
0972   0529             ; filename (24)
0973   0529             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
0974   0529             ; LBA (2)
0975   0529             ; size (2)
0976   0529             ; day (1)
0977   0529             ; month (1)
0978   0529             ; year (1)
0979   0529             ; packet size = 32 bytes
0980   0529             ;
0981   0529             ; first directory on disk is the root directory '/'
0982   0529             file_system_jmptbl:
0983   0529 94 05         .dw fs_mkfs                   ; 0
0984   052B 00 00         .dw 0                         ; 1
0985   052D F6 05         .dw fs_mkdir                  ; 2
0986   052F 6F 09         .dw fs_cd                     ; 3
0987   0531 76 09         .dw fs_ls                     ; 4
0988   0533 00 00         .dw 0                  ; 5
0989   0535 EC 0A         .dw fs_mkbin                  ; 6
0990   0537 B3 0B         .dw fs_pwd                    ; 7
0991   0539 D0 0B         .dw fs_cat                    ; 8
0992   053B 2C 0C         .dw fs_rmdir                  ; 9
0993   053D 88 0C         .dw fs_rm                     ; 10
0994   053F 47 0A         .dw fs_starcom                ; 11
0995   0541 00 00         .dw 0                         ; 12
0996   0543 00 00         .dw 0                         ; 13
0997   0545 9C 05         .dw fs_chmod                  ; 14
0998   0547 F0 0C         .dw fs_mv                     ; 15
0999   0549 95 05         .dw fs_cd_root                ; 16
1000   054B 6B 09         .dw fs_get_curr_dirID         ; 17
1001   054D 47 07         .dw fs_dir_id_to_path         ; 18
1002   054F AD 07         .dw fs_path_to_dir_id_user    ; 19
1003   0551 C7 08         .dw fs_load_from_path_user    ; 20  
1004   0553 37 08         .dw fs_filepath_exists_user   ; 21
1005   0555             
1006   0555 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1006   0559 79 73 63 61 
1006   055D 6C 6C 5F 66 
1006   0561 69 6C 65 5F 
1006   0565 73 79 73 74 
1006   0569 65 6D 20 63 
1006   056D 61 6C 6C 65 
1006   0571 64 3A 20 00 
1007   0575             syscall_file_system:
1008   0575 DD            push bl
1009   0576 31 28 16      mov bl, [sys_debug_mode]
1010   0579               ; debug block
1011   0579 C1 00         cmp bl, 0
1012   057B EA            pop bl
1013   057C C6 90 05      je syscall_filesystem_jmp
1014   057F DA            push d
1015   0580 DD            push bl
1016   0581 3B 55 05      mov d, s_syscall_fs_dbg0
1017   0584 07 FF 10      call _puts
1018   0587 2F            mov bl, al
1019   0588 07 9F 11      call print_u8x
1020   058B 07 AC 10      call printnl
1021   058E EA            pop bl
1022   058F E7            pop d
1023   0590             syscall_filesystem_jmp:
1024   0590 FD 0A 29 05   jmp [file_system_jmptbl + al]
1025   0594             
1026   0594             fs_mkfs:  
1027   0594 06            sysret  
1028   0595               
1029   0595             fs_cd_root:
1030   0595 10 20 00      mov a, root_id
1031   0598 42 39 16      mov [current_dirID], a      ; set current directory LBA to ROOT
1032   059B 06            sysret  
1033   059C             
1034   059C             ; filename in D (userspace data)
1035   059C             ; permission in BL
1036   059C             fs_chmod:
1037   059C DD            push bl
1038   059D FD 4E         mov si, d
1039   059F FD 4F 24 1B   mov di, user_data
1040   05A3 38 80 00      mov c, 128
1041   05A6 04            load                        ; load filename from user-space
1042   05A7 14 39 16      mov a, [current_dirID]
1043   05AA 77            inc a                       ; metadata sector
1044   05AB 27            mov b, a
1045   05AC 38 00 00      mov c, 0                    ; upper LBA = 0
1046   05AF 22 01         mov ah, $01                  ; 1 sector
1047   05B1 3B 24 23      mov d, transient_area
1048   05B4 07 27 04      call ide_read_sect          ; read directory
1049   05B7 FD 10         cla
1050   05B9 42 31 16      mov [index], a              ; reset file counter
1051   05BC             fs_chmod_L1:
1052   05BC FD 4E         mov si, d
1053   05BE FD 4F 24 1B   mov di, user_data
1054   05C2 07 42 0F      call _strcmp
1055   05C5 C6 DC 05      je fs_chmod_found_entry
1056   05C8 58 20 00      add d, 32
1057   05CB 14 31 16      mov a, [index]
1058   05CE 77            inc a
1059   05CF 42 31 16      mov [index], a
1060   05D2 AF 10 00      cmp a, FST_FILES_PER_DIR
1061   05D5 C7 BC 05      jne fs_chmod_L1
1062   05D8 EA            pop bl
1063   05D9 0A F5 05      jmp fs_chmod_not_found
1064   05DC             fs_chmod_found_entry:  
1065   05DC FD 79         mov g, b                    ; save LBA
1066   05DE EA            pop bl                      ; retrieve saved permission value
1067   05DF 1F 18 00      mov al, [d + 24]            ; read file permissions
1068   05E2 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1069   05E4 8C            or al, bl                   ; set new permissions
1070   05E5 3F 18 00      mov [d + 24], al            ; write new permissions
1071   05E8 38 00 00      mov c, 0
1072   05EB 3B 24 23      mov d, transient_area
1073   05EE 22 01         mov ah, $01                 ; disk write 1 sect
1074   05F0 FD 27         mov b, g                    ; retrieve LBA
1075   05F2 07 4D 04      call ide_write_sect         ; write sector
1076   05F5             fs_chmod_not_found:
1077   05F5 06            sysret
1078   05F6             
1079   05F6             ;------------------------------------------------------------------------------------------------------;
1080   05F6             ; CREATE NEW DIRECTORY
1081   05F6             ;------------------------------------------------------------------------------------------------------;
1082   05F6             ; search list for NULL name entry. add new directory to list
1083   05F6             fs_mkdir:
1084   05F6 FD 4E         mov si, d
1085   05F8 FD 4F 24 1B   mov di, user_data
1086   05FC 38 00 02      mov c, 512
1087   05FF 04            load                        ; load data from user-space
1088   0600 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1089   0603                                           ; when checking for NULL name, since root has a NULL name)
1090   0603 38 00 00      mov c, 0                    ; upper LBA = 0
1091   0606             fs_mkdir_L1:  
1092   0606 22 01         mov ah, $01                  ; 1 sector
1093   0608 3B 24 23      mov d, transient_area
1094   060B 07 27 04      call ide_read_sect          ; read sector
1095   060E BD 00         cmp byte[d], 0              ; check for NULL
1096   0610 C6 19 06      je fs_mkdir_found_null
1097   0613 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1098   0616 0A 06 06      jmp fs_mkdir_L1
1099   0619             fs_mkdir_found_null:
1100   0619             ;create header file by grabbing dir name from parameter
1101   0619 D8            push b                      ; save new directory's LBA
1102   061A 38 40 00      mov c, 64
1103   061D FD 4D 24 1B   mov si, user_data
1104   0621 FD 4F 24 23   mov di, transient_area
1105   0625 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1106   0627 14 39 16      mov a, [current_dirID]
1107   062A 42 64 23      mov [transient_area + 64], a    ; store parent directory LBA
1108   062D 19 00         mov al, 0
1109   062F FD 4F 24 25   mov di, transient_area + 512
1110   0633 38 00 02      mov c, 512
1111   0636 FD F7         rep stosb                       ; clean buffer
1112   0638 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1113   063B             ; write directory entry sectors
1114   063B 3B 24 23      mov d, transient_area
1115   063E 22 02         mov ah, $02                     ; disk write, 2 sectors
1116   0640 07 4D 04      call ide_write_sect             ; write sector
1117   0643             ; now we need to add the new directory to the list, insIDE the current directory
1118   0643 14 39 16      mov a, [current_dirID]
1119   0646 53 01 00      add a, 1
1120   0649 27            mov b, a                        ; metadata sector
1121   064A 38 00 00      mov c, 0
1122   064D FD 79         mov g, b                        ; save LBA
1123   064F 3B 24 23      mov d, transient_area
1124   0652 22 01         mov ah, $01                  ; 1 sector
1125   0654 07 27 04      call ide_read_sect              ; read metadata sector
1126   0657             fs_mkdir_L2:
1127   0657 BD 00         cmp byte[d], 0
1128   0659 C6 62 06      je fs_mkdir_found_null2
1129   065C 58 20 00      add d, FST_ENTRY_SIZE
1130   065F 0A 57 06      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1131   0662             fs_mkdir_found_null2:
1132   0662 FD 4D 24 1B   mov si, user_data
1133   0666 FD 50         mov di, d
1134   0668 07 57 0F      call _strcpy                    ; copy directory name
1135   066B 58 18 00      add d, 24                       ; goto ATTRIBUTES
1136   066E 19 0B         mov al, %00001011               ; directory, no execute, write, read
1137   0670 3E            mov [d], al      
1138   0671 79            inc d
1139   0672 E5            pop b
1140   0673 D8            push b                          ; push LBA back
1141   0674 FD 43         mov [d], b                      ; save LBA
1142   0676             ; set file creation date  
1143   0676 58 04 00      add d, 4
1144   0679 19 04         mov al, 4
1145   067B 05 01         syscall sys_rtc
1146   067D 1A            mov al, ah
1147   067E 3E            mov [d], al                     ; set day
1148   067F 79            inc d
1149   0680 19 05         mov al, 5
1150   0682 05 01         syscall sys_rtc
1151   0684 1A            mov al, ah
1152   0685 3E            mov [d], al                     ; set month
1153   0686 79            inc d
1154   0687 19 06         mov al, 6
1155   0689 05 01         syscall sys_rtc
1156   068B 1A            mov al, ah
1157   068C 3E            mov [d], al                     ; set year
1158   068D             ; write sector into disk for new directory entry
1159   068D FD 27         mov b, g
1160   068F 38 00 00      mov c, 0
1161   0692 3B 24 23      mov d, transient_area
1162   0695 22 01         mov ah, $01                     ; disk write, 1 sector
1163   0697 07 4D 04      call ide_write_sect             ; write sector
1164   069A             
1165   069A             ; after adding the new directory's information to its parent directory's list
1166   069A             ; we need to now enter the new directory, and to it add two new directories!
1167   069A             ; which directories do we need to add ? '..' and '.' are the directories needed.
1168   069A             ; importantly, note that these two new directories are only entries in the list
1169   069A             ; and do not have actual physical entries in the disk as real directories.
1170   069A             ; i.e. they only exist as list entries in the new directory created so that
1171   069A             ; the new directory can reference its parent and itself.
1172   069A             ; We need to add both '..' and '.'
1173   069A             ; this first section is for '..' and on the section below we do the same for '.'
1174   069A E4            pop a                         ; retrieve the new directory's LBA  
1175   069B D7            push a                        ; and save again
1176   069C 53 01 00      add a, 1
1177   069F 27            mov b, a                      ; metadata sector
1178   06A0 38 00 00      mov c, 0
1179   06A3 FD 79         mov g, b                      ; save LBA
1180   06A5 3B 24 23      mov d, transient_area
1181   06A8 22 01         mov ah, $01                  ; 1 sector
1182   06AA 07 27 04      call ide_read_sect            ; read metadata sector
1183   06AD             fs_mkdir_L3:
1184   06AD BD 00         cmp byte[d], 0
1185   06AF C6 B8 06      je fs_mkdir_found_null3
1186   06B2 58 20 00      add d, FST_ENTRY_SIZE
1187   06B5 0A AD 06      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1188   06B8             fs_mkdir_found_null3:
1189   06B8 FD 4D 46 16   mov si, s_parent_dir
1190   06BC FD 50         mov di, d
1191   06BE 07 57 0F      call _strcpy                  ; copy directory name
1192   06C1 58 18 00      add d, 24                     ; goto ATTRIBUTES
1193   06C4 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1194   06C6 3E            mov [d], al      
1195   06C7 79            inc d
1196   06C8 29 39 16      mov b, [current_dirID]        ; retrieve the parent directorys LBA
1197   06CB FD 43         mov [d], b                    ; save LBA
1198   06CD             ; set file creation date  
1199   06CD 58 04 00      add d, 4
1200   06D0 19 04         mov al, 4
1201   06D2 05 01         syscall sys_rtc
1202   06D4 1A            mov al, ah
1203   06D5 3E            mov [d], al                   ; set day
1204   06D6 79            inc d
1205   06D7 19 05         mov al, 5
1206   06D9 05 01         syscall sys_rtc
1207   06DB 1A            mov al, ah
1208   06DC 3E            mov [d], al                   ; set month
1209   06DD 79            inc d
1210   06DE 19 06         mov al, 6
1211   06E0 05 01         syscall sys_rtc
1212   06E2 1A            mov al, ah
1213   06E3 3E            mov [d], al                   ; set year
1214   06E4             ; write sector into disk for new directory entry
1215   06E4 FD 27         mov b, g
1216   06E6 38 00 00      mov c, 0
1217   06E9 3B 24 23      mov d, transient_area
1218   06EC 22 01         mov ah, $01                   ; disk write, 1 sector
1219   06EE 07 4D 04      call ide_write_sect           ; write sector
1220   06F1             ;;;;;;;;;;;;;
1221   06F1             ; like we did above for '..', we need to now add the '.' directory to the list.
1222   06F1             ;------------------------------------------------------------------------------------------------------;
1223   06F1 E4            pop a                         ; retrieve the new directory's LBA  
1224   06F2 D7            push a
1225   06F3 53 01 00      add a, 1
1226   06F6 27            mov b, a                      ; metadata sector
1227   06F7 38 00 00      mov c, 0
1228   06FA FD 79         mov g, b                      ; save LBA
1229   06FC 3B 24 23      mov d, transient_area
1230   06FF 22 01         mov ah, $01                  ; 1 sector
1231   0701 07 27 04      call ide_read_sect            ; read metadata sector
1232   0704             fs_mkdir_L4:
1233   0704 BD 00         cmp byte[d], 0
1234   0706 C6 0F 07      je fs_mkdir_found_null4
1235   0709 58 20 00      add d, FST_ENTRY_SIZE
1236   070C 0A 04 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1237   070F             fs_mkdir_found_null4:
1238   070F FD 4D 49 16   mov si, s_current_dir
1239   0713 FD 50         mov di, d
1240   0715 07 57 0F      call _strcpy                  ; copy directory name
1241   0718 58 18 00      add d, 24                     ; goto ATTRIBUTES
1242   071B 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1243   071D 3E            mov [d], al      
1244   071E 79            inc d
1245   071F E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1246   0720 FD 43         mov [d], b                    ; save LBA
1247   0722             ; set file creation date  
1248   0722 58 04 00      add d, 4
1249   0725 19 04         mov al, 4
1250   0727 05 01         syscall sys_rtc
1251   0729 1A            mov al, ah
1252   072A 3E            mov [d], al                   ; set day
1253   072B 79            inc d
1254   072C 19 05         mov al, 5
1255   072E 05 01         syscall sys_rtc
1256   0730 1A            mov al, ah
1257   0731 3E            mov [d], al                   ; set month
1258   0732 79            inc d
1259   0733 19 06         mov al, 6
1260   0735 05 01         syscall sys_rtc
1261   0737 1A            mov al, ah
1262   0738 3E            mov [d], al                   ; set year
1263   0739             ; write sector into disk for new directory entry
1264   0739 FD 27         mov b, g
1265   073B 38 00 00      mov c, 0
1266   073E 3B 24 23      mov d, transient_area
1267   0741 22 01         mov ah, $01                   ; disk write, 1 sector
1268   0743 07 4D 04      call ide_write_sect           ; write sector
1269   0746             fs_mkdir_end:
1270   0746 06            sysret
1271   0747             
1272   0747             ;------------------------------------------------------------------------------------------------------;
1273   0747             ; get path from a given directory dirID
1274   0747             ; pseudo code:
1275   0747             ;  fs_dir_id_to_path(int dirID, char *D){
1276   0747             ;    if(dirID == 0){
1277   0747             ;      reverse path in D;
1278   0747             ;      return;
1279   0747             ;    }
1280   0747             ;    else{
1281   0747             ;      copy directory name to end of D;
1282   0747             ;      add '/' to end of D;
1283   0747             ;      parentID = get parent directory ID;
1284   0747             ;      fs_dir_id_to_path(parentID, D);
1285   0747             ;    }
1286   0747             ;  }
1287   0747             ; A = dirID
1288   0747             ; D = generated path string pointer
1289   0747             ;------------------------------------------------------------------------------------------------------;
1290   0747             ; sample path: /usr/bin
1291   0747             fs_dir_id_to_path:
1292   0747 3B A4 1A      mov d, filename
1293   074A 19 00         mov al, 0
1294   074C 3E            mov [d], al                     ; initialize path string 
1295   074D 14 39 16      mov a, [current_dirID]
1296   0750 07 5D 07      call fs_dir_id_to_path_E0
1297   0753 3B A4 1A      mov d, filename
1298   0756 07 EB 0E      call _strrev
1299   0759 07 FF 10      call _puts
1300   075C 06            sysret
1301   075D             fs_dir_id_to_path_E0:
1302   075D 07 7C 07      call get_dirname_from_dirID
1303   0760 FD 4D 4B 16   mov si, s_fslash
1304   0764 FD 50         mov di, d
1305   0766 07 65 0F      call _strcat                    ; add '/' to end of path
1306   0769 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1307   076C C6 7B 07      je fs_dir_id_to_path_root
1308   076F 07 99 07      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1309   0772 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1310   0775 C6 7B 07      je fs_dir_id_to_path_root
1311   0778 07 5D 07      call fs_dir_id_to_path_E0     ; recursively call itself
1312   077B             fs_dir_id_to_path_root:
1313   077B 09            ret
1314   077C             
1315   077C             ;------------------------------------------------------------------------------------------------------;
1316   077C             ; in_puts:
1317   077C             ; A = directory ID
1318   077C             ; out_puts:
1319   077C             ; D = pointer to directory name string
1320   077C             ;------------------------------------------------------------------------------------------------------;
1321   077C             get_dirname_from_dirID:
1322   077C D7            push a
1323   077D D8            push b
1324   077E DA            push d
1325   077F 27            mov b, a
1326   0780 38 00 00      mov c, 0                      ; upper LBA = 0
1327   0783 22 01         mov ah, $01                  ; 1 sector
1328   0785 3B 24 21      mov d, transient_area - 512
1329   0788 07 27 04      call ide_read_sect            ; read directory
1330   078B 07 EB 0E      call _strrev                  ; reverse dir name before copying
1331   078E FD 4E         mov si, d
1332   0790 E7            pop d                         ; destination address = D value pushed at beginning
1333   0791 FD 50         mov di, d
1334   0793 07 65 0F      call _strcat                  ; copy filename to D
1335   0796 E5            pop b
1336   0797 E4            pop a
1337   0798 09            ret
1338   0799             
1339   0799             ;------------------------------------------------------------------------------------------------------;
1340   0799             ; in_puts:
1341   0799             ; A = directory ID
1342   0799             ; out_puts:
1343   0799             ; A = parent directory ID
1344   0799             ;------------------------------------------------------------------------------------------------------;
1345   0799             get_parentID_from_dirID:
1346   0799 D8            push b
1347   079A DA            push d
1348   079B 27            mov b, a
1349   079C 38 00 00      mov c, 0                      ; upper LBA = 0
1350   079F 22 01         mov ah, $01                  ; 1 sector
1351   07A1 3B 24 21      mov d, transient_area - 512
1352   07A4 07 27 04      call ide_read_sect            ; read directory
1353   07A7 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1354   07AA E7            pop d
1355   07AB E5            pop b
1356   07AC 09            ret
1357   07AD             
1358   07AD             ;------------------------------------------------------------------------------------------------------;
1359   07AD             ; get dirID from a given path string
1360   07AD             ; in_puts:
1361   07AD             ; D = path pointer 
1362   07AD             ; out_puts:
1363   07AD             ; A = dirID
1364   07AD             ; if dir non existent, A = FFFF (fail code)
1365   07AD             ; /usr/local/bin    - absolute
1366   07AD             ; local/bin/games    - relative
1367   07AD             ;------------------------------------------------------------------------------------------------------;
1368   07AD             fs_path_to_dir_id_user:
1369   07AD FD 4E         mov si, d
1370   07AF FD 4F 24 1B   mov di, user_data
1371   07B3 38 00 02      mov c, 512
1372   07B6 04            load
1373   07B7 07 BB 07      call get_dirID_from_path
1374   07BA 06            sysret
1375   07BB             get_dirID_from_path:
1376   07BB 26 24 1B      mov b, user_data
1377   07BE FD 42 24 15   mov [prog], b                  ; token pointer set to path string
1378   07C2 07 85 13      call get_token
1379   07C5 31 27 15      mov bl, [tok]
1380   07C8 C1 01         cmp bl, TOK_FSLASH
1381   07CA C6 D6 07      je get_dirID_from_path_abs 
1382   07CD 14 39 16      mov a, [current_dirID]
1383   07D0 07 0B 15      call _putback
1384   07D3 0A D9 07      jmp get_dirID_from_path_E0
1385   07D6             get_dirID_from_path_abs:
1386   07D6 10 20 00      mov a, root_id
1387   07D9             get_dirID_from_path_E0:
1388   07D9 07 85 13      call get_token
1389   07DC 31 26 15      mov bl, [toktyp]
1390   07DF C1 00         cmp bl, TOKTYP_IDENTIFIER
1391   07E1 C7 32 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1392   07E4             
1393   07E4 FD 4D 28 15   mov si, tokstr
1394   07E8 FD 4F A4 1A   mov di, filename
1395   07EC 07 57 0F      call _strcpy        
1396   07EF 77            inc a                         ; metadata sector
1397   07F0 27            mov b, a
1398   07F1 38 00 00      mov c, 0                      ; upper LBA = 0
1399   07F4 22 01         mov ah, $01                  ; 1 sector
1400   07F6 3B 24 23      mov d, transient_area
1401   07F9 07 27 04      call ide_read_sect            ; read directory
1402   07FC FD 10         cla
1403   07FE 42 31 16      mov [index], a
1404   0801             get_dirID_from_path_L1:
1405   0801 FD 4E         mov si, d
1406   0803 FD 4F A4 1A   mov di, filename
1407   0807 07 42 0F      call _strcmp
1408   080A C6 20 08      je get_dirID_from_path_name_equal  
1409   080D 58 20 00      add d, 32
1410   0810 14 31 16      mov a, [index]
1411   0813 77            inc a
1412   0814 42 31 16      mov [index], a
1413   0817 AF 10 00      cmp a, FST_FILES_PER_DIR
1414   081A C6 33 08      je get_dirID_from_path_fail
1415   081D 0A 01 08      jmp get_dirID_from_path_L1
1416   0820             get_dirID_from_path_name_equal:
1417   0820 58 19 00      add d, 25           
1418   0823 15            mov a, [d]                    ; set result register A = dirID
1419   0824 07 85 13      call get_token
1420   0827 31 27 15      mov bl, [tok]
1421   082A C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1422   082C C6 D9 07      je get_dirID_from_path_E0
1423   082F 07 0B 15      call _putback
1424   0832             get_dirID_from_path_end:
1425   0832 09            ret
1426   0833             get_dirID_from_path_fail:
1427   0833 10 FF FF      mov A, $FFFF
1428   0836 09            ret
1429   0837             
1430   0837             
1431   0837             ;------------------------------------------------------------------------------------------------------;
1432   0837             ; check if file exists by a given path string
1433   0837             ; in_puts:
1434   0837             ; D = path pointer 
1435   0837             ; OUTPUTS:
1436   0837             ; A = success code, if file exists gives LBA, else, give 0
1437   0837             ; /usr/local/bin/ed
1438   0837             ;------------------------------------------------------------------------------------------------------;
1439   0837             fs_filepath_exists_user:
1440   0837 FD 4E         mov si, d
1441   0839 FD 4F 24 1B   mov di, user_data
1442   083D 38 00 02      mov c, 512
1443   0840 04            load
1444   0841 07 45 08      call file_exists_by_path
1445   0844 06            sysret
1446   0845             file_exists_by_path:
1447   0845 26 24 1B      mov b, user_data
1448   0848 FD 42 24 15   mov [prog], b                   ; token pointer set to path string
1449   084C 07 85 13      call get_token
1450   084F 31 27 15      mov bl, [tok]
1451   0852 C1 01         cmp bl, TOK_FSLASH
1452   0854 C6 60 08      je  file_exists_by_path_abs
1453   0857 14 39 16      mov a, [current_dirID]
1454   085A 07 0B 15      call _putback
1455   085D 0A 63 08      jmp file_exists_by_path_E0
1456   0860             file_exists_by_path_abs:
1457   0860 10 20 00      mov a, root_id
1458   0863             file_exists_by_path_E0:
1459   0863 07 85 13      call get_token
1460   0866 31 26 15      mov bl, [toktyp]
1461   0869 C1 00         cmp bl, TOKTYP_IDENTIFIER
1462   086B C7 C3 08      jne file_exists_by_path_end     ; check if there are tokens after '/'
1463   086E FD 4D 28 15   mov si, tokstr
1464   0872 FD 4F A4 1A   mov di, filename
1465   0876 07 57 0F      call _strcpy        
1466   0879 77            inc a                           ; metadata sector
1467   087A 27            mov b, a
1468   087B 38 00 00      mov c, 0                        ; upper LBA = 0
1469   087E 22 01         mov ah, $01                  ; 1 sector
1470   0880 3B 24 23      mov d, transient_area
1471   0883 07 27 04      call ide_read_sect              ; read directory
1472   0886 FD 10         cla
1473   0888 42 31 16      mov [index], a
1474   088B             file_exists_by_path_L1:
1475   088B FD 4E         mov si, d
1476   088D FD 4F A4 1A   mov di, filename
1477   0891 07 42 0F      call _strcmp
1478   0894 C6 AA 08      je   file_exists_by_path_name_equal
1479   0897 58 20 00      add d, 32
1480   089A 14 31 16      mov a, [index]
1481   089D 77            inc a
1482   089E 42 31 16      mov [index], a
1483   08A1 AF 10 00      cmp a, FST_FILES_PER_DIR
1484   08A4 C6 C3 08      je file_exists_by_path_end
1485   08A7 0A 8B 08      jmp file_exists_by_path_L1
1486   08AA             file_exists_by_path_name_equal:
1487   08AA 33 18 00      mov bl, [d + 24]
1488   08AD FD 87 38      and bl, %00111000               ; directory flag
1489   08B0 C1 08         cmp bl, %00001000               ; is dir?
1490   08B2 C6 B9 08      je file_exists_by_path_isdir;
1491   08B5             ; entry is a file
1492   08B5 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1493   08B8 09            ret
1494   08B9             file_exists_by_path_isdir:
1495   08B9 58 19 00      add d, 25           
1496   08BC 15            mov a, [d]                      ; set result register A = dirID
1497   08BD 07 85 13      call get_token
1498   08C0 0A 63 08      jmp file_exists_by_path_E0
1499   08C3             file_exists_by_path_end:
1500   08C3 10 00 00      mov a, 0                        ; return 0 because file was not found
1501   08C6 09            ret
1502   08C7             
1503   08C7             ;------------------------------------------------------------------------------------------------------;
1504   08C7             ; load file data from a given path string
1505   08C7             ; inputs:
1506   08C7             ; D = path pointer 
1507   08C7             ; DI = userspace program data destination
1508   08C7             ; /usr/local/bin/ed
1509   08C7             ; ./ed
1510   08C7             ;------------------------------------------------------------------------------------------------------;
1511   08C7             fs_load_from_path_user:
1512   08C7 E3            push di
1513   08C8 FD 4E         mov si, d
1514   08CA FD 4F 24 1B   mov di, user_data
1515   08CE 38 00 02      mov c, 512
1516   08D1 04            load
1517   08D2 07 DF 08      call loadfile_from_path
1518   08D5 F0            pop di
1519   08D6 FD 4D 24 23   mov si, transient_area
1520   08DA 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1521   08DD 03            store
1522   08DE 06            sysret
1523   08DF             loadfile_from_path:
1524   08DF 26 24 1B      mov b, user_data
1525   08E2 FD 42 24 15   mov [prog], b                 ; token pointer set to path string
1526   08E6 07 85 13      call get_token
1527   08E9 31 27 15      mov bl, [tok]
1528   08EC C1 01         cmp bl, TOK_FSLASH
1529   08EE C6 FA 08      je loadfile_from_path_abs 
1530   08F1 14 39 16      mov a, [current_dirID]
1531   08F4 07 0B 15      call _putback
1532   08F7 0A FD 08      jmp loadfile_from_path_E0
1533   08FA             loadfile_from_path_abs:
1534   08FA 10 20 00      mov a, root_id
1535   08FD             loadfile_from_path_E0:
1536   08FD 07 85 13      call get_token
1537   0900 31 26 15      mov bl, [toktyp]
1538   0903 C1 00         cmp bl, TOKTYP_IDENTIFIER
1539   0905 C7 6A 09      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1540   0908 FD 4D 28 15   mov si, tokstr
1541   090C FD 4F A4 1A   mov di, filename
1542   0910 07 57 0F      call _strcpy        
1543   0913 77            inc a                         ; metadata sector
1544   0914 27            mov b, a
1545   0915 38 00 00      mov c, 0                      ; upper LBA = 0
1546   0918 22 01         mov ah, $01                  ; 1 sector
1547   091A 3B 24 23      mov d, transient_area
1548   091D 07 27 04      call ide_read_sect            ; read directory
1549   0920 FD 10         cla
1550   0922 42 31 16      mov [index], a
1551   0925             loadfile_from_path_L1:
1552   0925 FD 4E         mov si, d
1553   0927 FD 4F A4 1A   mov di, filename
1554   092B 07 42 0F      call _strcmp
1555   092E C6 44 09      je loadfile_from_path_name_equal  
1556   0931 58 20 00      add d, 32
1557   0934 14 31 16      mov a, [index]
1558   0937 77            inc a
1559   0938 42 31 16      mov [index], a
1560   093B AF 10 00      cmp a, FST_FILES_PER_DIR
1561   093E C6 6A 09      je loadfile_from_path_end
1562   0941 0A 25 09      jmp loadfile_from_path_L1
1563   0944             loadfile_from_path_name_equal:
1564   0944 33 18 00      mov bl, [d + 24]
1565   0947 FD 87 38      and bl, %00111000             ; directory flag
1566   094A C1 08         cmp bl, %00001000             ; is dir?
1567   094C C6 60 09      je loadfile_isdirectory  
1568   094F             ; entry is a file
1569   094F 2B 19 00      mov b, [d + 25]               ; get LBA
1570   0952 FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1571   0954 3B 24 23      mov d, transient_area
1572   0957 38 00 00      mov c, 0
1573   095A 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1574   095C 07 27 04      call ide_read_sect            ; read sector
1575   095F 09            ret
1576   0960             loadfile_isdirectory:
1577   0960 58 19 00      add d, 25           
1578   0963 15            mov a, [d]                    ; set result register A = dirID
1579   0964 07 85 13      call get_token
1580   0967 0A FD 08      jmp loadfile_from_path_E0
1581   096A             loadfile_from_path_end:
1582   096A 09            ret
1583   096B             
1584   096B             ;------------------------------------------------------------------------------------------------------;
1585   096B             ; return the ID of the current directory
1586   096B             ; ID returned in B
1587   096B             ;------------------------------------------------------------------------------------------------------;
1588   096B             fs_get_curr_dirID:
1589   096B 29 39 16      mov b, [current_dirID]
1590   096E 06            sysret
1591   096F             
1592   096F             ;------------------------------------------------------------------------------------------------------;
1593   096F             ; CD
1594   096F             ;------------------------------------------------------------------------------------------------------;
1595   096F             ; new dirID in B
1596   096F             fs_cd:
1597   096F FD 42 39 16   mov [current_dirID], b
1598   0973 06            sysret  
1599   0974             
1600   0974             ;------------------------------------------------------------------------------------------------------;
1601   0974             ; LS
1602   0974             ; dirID in B
1603   0974             ;------------------------------------------------------------------------------------------------------;
1604   0974 00 00       ls_count:       .dw 0
1605   0976             fs_ls:
1606   0976 FD 77         inc b                        ; metadata sector
1607   0978 38 00 00      mov c, 0                     ; upper LBA = 0
1608   097B 22 01         mov ah, $01                  ; 1 sector
1609   097D 3B 24 23      mov d, transient_area
1610   0980 07 27 04      call ide_read_sect           ; read directory
1611   0983 FD 10         cla
1612   0985 42 31 16      mov [index], a               ; reset entry index
1613   0988 3D 74 09      mov [ls_count], al           ; reset item count
1614   098B             fs_ls_L1:
1615   098B BD 00         cmp byte [d], 0              ; check for NULL
1616   098D C6 24 0A      je fs_ls_next
1617   0990             fs_ls_non_null:
1618   0990 1D 74 09      mov al, [ls_count]
1619   0993 7A            inc al
1620   0994 3D 74 09      mov [ls_count], al           ; increment item count
1621   0997 1F 18 00      mov al, [d + 24]
1622   099A 87 38         and al, %00111000
1623   099C FD A2 03      shr al, 3
1624   099F 22 00         mov ah, 0                    ; file type
1625   09A1 B7 52 16      mov a, [a + file_type]      
1626   09A4 23            mov ah, al
1627   09A5 07 D3 0F      call _putchar
1628   09A8 1F 18 00      mov al, [d + 24]
1629   09AB 87 01         and al, %00000001
1630   09AD 22 00         mov ah, 0
1631   09AF B7 4D 16      mov a, [a + file_attrib]     ; read
1632   09B2 23            mov ah, al
1633   09B3 07 D3 0F      call _putchar
1634   09B6 1F 18 00      mov al, [d + 24]
1635   09B9 87 02         and al, %00000010
1636   09BB 22 00         mov ah, 0
1637   09BD B7 4D 16      mov a, [a + file_attrib]     ; write
1638   09C0 23            mov ah, al
1639   09C1 07 D3 0F      call _putchar
1640   09C4 1F 18 00      mov al, [d + 24]
1641   09C7 87 04         and al, %00000100
1642   09C9 22 00         mov ah, 0
1643   09CB B7 4D 16      mov a, [a + file_attrib]     ; execute
1644   09CE 23            mov ah, al
1645   09CF 07 D3 0F      call _putchar
1646   09D2 22 20         mov ah, $20
1647   09D4 07 D3 0F      call _putchar  
1648   09D7 2B 1B 00      mov b, [d + 27]
1649   09DA 07 5B 11      call print_u16x              ; filesize
1650   09DD 22 20         mov ah, $20
1651   09DF 07 D3 0F      call _putchar  
1652   09E2 2B 19 00      mov b, [d + 25]
1653   09E5 07 5B 11      call print_u16x              ; dirID / LBA
1654   09E8 22 20         mov ah, $20
1655   09EA 07 D3 0F      call _putchar
1656   09ED             ; print date
1657   09ED 33 1D 00      mov bl, [d + 29]             ; day
1658   09F0 07 9F 11      call print_u8x
1659   09F3 22 20         mov ah, $20
1660   09F5 07 D3 0F      call _putchar  
1661   09F8 1F 1E 00      mov al, [d + 30]             ; month
1662   09FB FD 9E 02      shl al, 2
1663   09FE DA            push d
1664   09FF 3B 04 17      mov d, s_months
1665   0A02 22 00         mov ah, 0
1666   0A04 59            add d, a
1667   0A05 07 FF 10      call _puts
1668   0A08 E7            pop d
1669   0A09 22 20         mov ah, $20
1670   0A0B 07 D3 0F      call _putchar
1671   0A0E 2E 20         mov bl, $20
1672   0A10 07 9F 11      call print_u8x
1673   0A13 33 1F 00      mov bl, [d + 31]             ; year
1674   0A16 07 9F 11      call print_u8x  
1675   0A19 22 20         mov ah, $20
1676   0A1B 07 D3 0F      call _putchar  
1677   0A1E 07 FF 10      call _puts                   ; print filename  
1678   0A21 07 AC 10      call printnl
1679   0A24             fs_ls_next:
1680   0A24 14 31 16      mov a, [index]
1681   0A27 77            inc a
1682   0A28 42 31 16      mov [index], a
1683   0A2B AF 10 00      cmp a, FST_FILES_PER_DIR
1684   0A2E C6 37 0A      je fs_ls_end
1685   0A31 58 20 00      add d, 32      
1686   0A34 0A 8B 09      jmp fs_ls_L1  
1687   0A37             fs_ls_end:
1688   0A37 3B 62 16      mov d, s_ls_total
1689   0A3A 07 FF 10      call _puts
1690   0A3D 1D 74 09      mov al, [ls_count]
1691   0A40 07 B1 11      call print_u8d
1692   0A43 07 AC 10      call printnl
1693   0A46 06            sysret
1694   0A47             
1695   0A47             
1696   0A47             ; file structure:
1697   0A47             ; 512 bytes header
1698   0A47             ; header used to tell whether the block is free
1699   0A47             ;------------------------------------------------------------------------------------------------------;
1700   0A47             ; CREATE NEW TEXTFILE
1701   0A47             ;------------------------------------------------------------------------------------------------------;
1702   0A47             ; d = content pointer in user space
1703   0A47             ; c = file size
1704   0A47             fs_starcom:
1705   0A47 FD 4E       	mov si, d
1706   0A49 FD 4F 24 23 	mov di, transient_area
1707   0A4D 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1708   0A50 04          	load					; load data from user-space
1709   0A51 07 D2 0A    	call fs_find_empty_block	; look for empty data blocks
1710   0A54 D8          	push b				; save empty block LBA
1711   0A55 FD 79         mov g, b
1712   0A57             ;create header file by grabbing file name from parameter	
1713   0A57 3B 24 25    	mov d, transient_area + 512			; pointer to file contents
1714   0A5A D9          	push c							; save length
1715   0A5B 19 01       	mov al, 1
1716   0A5D 3D 24 23    	mov [transient_area], al					; mark sectors as USED (not NULL)
1717   0A60 3B 24 23    	mov d, transient_area
1718   0A63 12            mov a, c
1719   0A64 26 00 02      mov b, 512
1720   0A67 AE            div a, b
1721   0A68 FD 77         inc b         ; inc b as the division will most likely have a remainder
1722   0A6A 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1723   0A6B 38 00 00    	mov c, 0      ; lba 
1724   0A6E FD 27         mov b, g      ; lba 
1725   0A70 07 4D 04    	call ide_write_sect			; write sectors
1726   0A73             ; now we add the file to the current directory!
1727   0A73             fs_starcom_add_to_dir:	
1728   0A73 14 39 16    	mov a, [current_dirID]
1729   0A76 77          	inc a
1730   0A77 27          	mov b, a					; metadata sector
1731   0A78 38 00 00    	mov c, 0
1732   0A7B FD 79       	mov g, b					; save LBA
1733   0A7D 3B 24 21    	mov d, scrap_sector
1734   0A80 22 01       	mov ah, $01			  ; 1 sector
1735   0A82 07 27 04    	call ide_read_sect		; read metadata sector
1736   0A85             fs_starcom_add_to_dir_L2:
1737   0A85 BD 00       	cmp byte[d], 0
1738   0A87 C6 90 0A    	je fs_starcom_add_to_dir_null
1739   0A8A 58 20 00    	add d, FST_ENTRY_SIZE
1740   0A8D 0A 85 0A    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1741   0A90             fs_starcom_add_to_dir_null:
1742   0A90 FD 4D 25 23 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1743   0A94 FD 50       	mov di, d
1744   0A96 07 57 0F    	call _strcpy			; copy file name
1745   0A99 58 18 00    	add d, 24			; skip name
1746   0A9C 19 07       	mov al, %00000111	; type=file, execute, write, read
1747   0A9E 3E          	mov [d], al			
1748   0A9F 58 03 00    	add d, 3
1749   0AA2 E4          	pop a
1750   0AA3 5F 00 02      sub a, 512
1751   0AA6 43          	mov [d], a ; file size
1752   0AA7 63 02 00    	sub d, 2
1753   0AAA E5          	pop b				; get file LBA
1754   0AAB FD 43       	mov [d], b			; save LBA	
1755   0AAD             ; set file creation date	
1756   0AAD 58 04 00    	add d, 4
1757   0AB0 19 04       	mov al, 4
1758   0AB2 05 01       	syscall sys_rtc
1759   0AB4 1A          	mov al, ah
1760   0AB5 3E          	mov [d], al			; set day
1761   0AB6 79          	inc d
1762   0AB7 19 05       	mov al, 5
1763   0AB9 05 01       	syscall sys_rtc
1764   0ABB 1A          	mov al, ah
1765   0ABC 3E          	mov [d], al			; set month
1766   0ABD 79          	inc d
1767   0ABE 19 06       	mov al, 6
1768   0AC0 05 01       	syscall sys_rtc
1769   0AC2 1A          	mov al, ah
1770   0AC3 3E          	mov [d], al			; set year
1771   0AC4             ; write sector into disk for new directory entry
1772   0AC4 FD 27       	mov b, g
1773   0AC6 38 00 00    	mov c, 0
1774   0AC9 3B 24 21    	mov d, scrap_sector
1775   0ACC 22 01       	mov ah, $01			; disk write, 1 sector
1776   0ACE 07 4D 04    	call ide_write_sect		; write sector
1777   0AD1 06          	sysret
1778   0AD2             
1779   0AD2             ;------------------------------------------------------------------------------------------------------;
1780   0AD2             ; finds an empty data block
1781   0AD2             ; block LBA returned in B
1782   0AD2             ;------------------------------------------------------------------------------------------------------;
1783   0AD2             fs_find_empty_block:
1784   0AD2 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1785   0AD5 38 00 00      mov c, 0                ; upper LBA = 0
1786   0AD8             fs_find_empty_block_L1:  
1787   0AD8 22 01         mov ah, $01                  ; 1 sector
1788   0ADA 3B 24 21      mov d, transient_area - 512
1789   0ADD 07 27 04      call ide_read_sect      ; read sector
1790   0AE0 BD 00         cmp byte [d], 0
1791   0AE2 C6 EB 0A      je fs_find_empty_block_found_null
1792   0AE5 55 20 00      add b, FS_SECTORS_PER_FILE
1793   0AE8 0A D8 0A      jmp fs_find_empty_block_L1
1794   0AEB             fs_find_empty_block_found_null:
1795   0AEB 09            ret
1796   0AEC             
1797   0AEC             ;------------------------------------------------------------------------------------------------------;
1798   0AEC             ; CREATE NEW BINARY FILE
1799   0AEC             ;------------------------------------------------------------------------------------------------------;
1800   0AEC             ; search for first null block
1801   0AEC             fs_mkbin:
1802   0AEC 19 00         mov al, 0
1803   0AEE 3D 29 16      mov [sys_echo_on], al ; disable echo
1804   0AF1 FD 4E         mov si, d
1805   0AF3 FD 4F 24 1B   mov di, user_data
1806   0AF7 38 00 02      mov c, 512
1807   0AFA 04            load                          ; load data from user-space
1808   0AFB 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
1809   0AFE 38 00 00      mov c, 0                      ; upper LBA = 0
1810   0B01             fs_mkbin_L1:  
1811   0B01 22 01         mov ah, $01                  ; 1 sector
1812   0B03 3B 24 23      mov d, transient_area
1813   0B06 07 27 04      call ide_read_sect            ; read sector
1814   0B09 BD 00         cmp byte[d], 0                ; check for NULL
1815   0B0B C6 14 0B      je fs_mkbin_found_null
1816   0B0E 55 20 00      add b, FS_SECTORS_PER_FILE
1817   0B11 0A 01 0B      jmp fs_mkbin_L1
1818   0B14             fs_mkbin_found_null:
1819   0B14 D8            push b                        ; save LBA
1820   0B15             ;create header file by grabbing file name from parameter
1821   0B15 FD 4F 24 25   mov di, transient_area + 512  ; pointer to file contents
1822   0B19 07 C5 0E      call _load_hex                ; load binary hex
1823   0B1C D9            push c                        ; save size (nbr of bytes)
1824   0B1D 19 01         mov al, 1
1825   0B1F 3D 24 23      mov [transient_area], al      ; mark sectors as USED (not NULL)
1826   0B22 FD 10         cla
1827   0B24 42 31 16      mov [index], a
1828   0B27 3B 24 23      mov d, transient_area
1829   0B2A 13            mov a, d
1830   0B2B 42 33 16      mov [buffer_addr], a
1831   0B2E             fs_mkbin_L2:
1832   0B2E 38 00 00      mov c, 0
1833   0B31 22 01         mov ah, $01                   ; disk write, 1 sector
1834   0B33 07 4D 04      call ide_write_sect           ; write sector
1835   0B36 14 31 16      mov a, [index]
1836   0B39 77            inc a
1837   0B3A 42 31 16      mov [index], a
1838   0B3D AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
1839   0B40 C6 52 0B      je fs_mkbin_add_to_dir
1840   0B43 FD 77         inc b
1841   0B45 14 33 16      mov a, [buffer_addr]
1842   0B48 53 00 02      add a, 512
1843   0B4B 42 33 16      mov [buffer_addr], a
1844   0B4E 3C            mov d, a
1845   0B4F 0A 2E 0B      jmp fs_mkbin_L2
1846   0B52             ; now we add the file to the current directory!
1847   0B52             fs_mkbin_add_to_dir:  
1848   0B52 14 39 16      mov a, [current_dirID]
1849   0B55 77            inc a
1850   0B56 27            mov b, a                      ; metadata sector
1851   0B57 38 00 00      mov c, 0
1852   0B5A FD 79         mov g, b                      ; save LBA
1853   0B5C 3B 24 23      mov d, transient_area
1854   0B5F 22 01         mov ah, $01                  ; 1 sector
1855   0B61 07 27 04      call ide_read_sect            ; read metadata sector
1856   0B64             fs_mkbin_add_to_dir_L2:
1857   0B64 BD 00         cmp byte[d], 0
1858   0B66 C6 6F 0B      je fs_mkbin_add_to_dir_null
1859   0B69 58 20 00      add d, FST_ENTRY_SIZE
1860   0B6C 0A 64 0B      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1861   0B6F             fs_mkbin_add_to_dir_null:
1862   0B6F FD 4D 24 1B   mov si, user_data
1863   0B73 FD 50         mov di, d
1864   0B75 07 57 0F      call _strcpy                  ; copy file name
1865   0B78 58 18 00      add d, 24                     ; skip name
1866   0B7B 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
1867   0B7D 3E            mov [d], al
1868   0B7E 58 03 00      add d, 3
1869   0B81 E4            pop a
1870   0B82 43            mov [d], a
1871   0B83 63 02 00      sub d, 2
1872   0B86 E5            pop b                         ; get file LBA
1873   0B87 FD 43         mov [d], b                    ; save LBA
1874   0B89               ; set file creation date  
1875   0B89 58 04 00      add d, 4
1876   0B8C 19 04         mov al, 4
1877   0B8E 05 01         syscall sys_rtc
1878   0B90 1A            mov al, ah
1879   0B91 3E            mov [d], al                   ; set day
1880   0B92 79            inc d
1881   0B93 19 05         mov al, 5
1882   0B95 05 01         syscall sys_rtc
1883   0B97 1A            mov al, ah
1884   0B98 3E            mov [d], al                   ; set month
1885   0B99 79            inc d
1886   0B9A 19 06         mov al, 6
1887   0B9C 05 01         syscall sys_rtc
1888   0B9E 1A            mov al, ah
1889   0B9F 3E            mov [d], al                   ; set year
1890   0BA0             ; write sector into disk for new directory entry
1891   0BA0 FD 27         mov b, g
1892   0BA2 38 00 00      mov c, 0
1893   0BA5 3B 24 23      mov d, transient_area
1894   0BA8 22 01         mov ah, $01                   ; disk write, 1 sector
1895   0BAA 07 4D 04      call ide_write_sect           ; write sector
1896   0BAD 19 01         mov al, 1
1897   0BAF 3D 29 16      mov [sys_echo_on], al ; enable echo
1898   0BB2 06            sysret
1899   0BB3             
1900   0BB3             ;------------------------------------------------------------------------------------------------------;
1901   0BB3             ; PWD - PRINT WORKING DIRECTORY
1902   0BB3             ;------------------------------------------------------------------------------------------------------;    
1903   0BB3             fs_pwd:
1904   0BB3 3B A4 1A      mov d, filename
1905   0BB6 19 00         mov al, 0
1906   0BB8 3E            mov [d], al                   ; initialize path string 
1907   0BB9 14 39 16      mov a, [current_dirID]
1908   0BBC 07 5D 07      call fs_dir_id_to_path_E0
1909   0BBF 3B A4 1A      mov d, filename
1910   0BC2 07 EB 0E      call _strrev
1911   0BC5 07 FF 10      call _puts
1912   0BC8 07 AC 10      call printnl
1913   0BCB 06            sysret
1914   0BCC             
1915   0BCC             ;------------------------------------------------------------------------------------------------------;
1916   0BCC             ; get current directory LBA
1917   0BCC             ; A: returned LBA
1918   0BCC             ;------------------------------------------------------------------------------------------------------;
1919   0BCC             cmd_get_curr_dir_LBA:
1920   0BCC 14 39 16      mov a, [current_dirID]
1921   0BCF 06            sysret
1922   0BD0             
1923   0BD0             ;------------------------------------------------------------------------------------------------------;
1924   0BD0             ; CAT
1925   0BD0             ; userspace destination data pointer in D
1926   0BD0             ; filename starts at D, but is overwritten after the read is made
1927   0BD0             ;------------------------------------------------------------------------------------------------------;:
1928   0BD0             fs_cat:
1929   0BD0 DA            push d                              ; save userspace file data destination
1930   0BD1 FD 4E         mov si, d
1931   0BD3 FD 4F 24 1B   mov di, user_data
1932   0BD7 38 00 02      mov c, 512
1933   0BDA 04            load                                ; copy filename from user-space
1934   0BDB 29 39 16      mov b, [current_dirID]
1935   0BDE FD 77         inc b                               ; metadata sector
1936   0BE0 38 00 00      mov c, 0                            ; upper LBA = 0
1937   0BE3 22 01         mov ah, $01                  ; 1 sector
1938   0BE5 3B 24 21      mov d, transient_area-512
1939   0BE8 07 27 04      call ide_read_sect                  ; read directory
1940   0BEB FD 10         cla
1941   0BED 42 31 16      mov [index], a                      ; reset file counter
1942   0BF0             fs_cat_L1:
1943   0BF0 FD 4E         mov si, d
1944   0BF2 FD 4F 24 1B   mov di, user_data
1945   0BF6 07 42 0F      call _strcmp
1946   0BF9 C6 0F 0C      je fs_cat_found_entry
1947   0BFC 58 20 00      add d, 32
1948   0BFF 14 31 16      mov a, [index]
1949   0C02 77            inc a
1950   0C03 42 31 16      mov [index], a
1951   0C06 AF 10 00      cmp a, FST_FILES_PER_DIR
1952   0C09 C6 2A 0C      je fs_cat_not_found
1953   0C0C 0A F0 0B      jmp fs_cat_L1
1954   0C0F             fs_cat_found_entry:
1955   0C0F 58 19 00      add d, 25                           ; get to dirID of file in disk
1956   0C12 2A            mov b, [d]                          ; get LBA
1957   0C13 FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
1958   0C15 3B 24 23      mov d, transient_area  
1959   0C18 38 00 00      mov c, 0
1960   0C1B 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
1961   0C1D 07 27 04      call ide_read_sect                  ; read sectors
1962   0C20 F0            pop di                              ; write userspace file data destination to DI
1963   0C21 FD 4D 24 23   mov si, transient_area              ; data origin
1964   0C25 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
1965   0C28 03            store
1966   0C29 06            sysret
1967   0C2A             fs_cat_not_found:
1968   0C2A E7            pop d
1969   0C2B 06            sysret
1970   0C2C             
1971   0C2C             ;------------------------------------------------------------------------------------------------------;
1972   0C2C             ; RMDIR - remove DIR by dirID
1973   0C2C             ;------------------------------------------------------------------------------------------------------;
1974   0C2C             ; deletes a directory entry in the given directory's file list 
1975   0C2C             ; also deletes the actual directory entry in the FST
1976   0C2C             ; synopsis: rmdir /usr/local/testdir
1977   0C2C             ; B = dirID
1978   0C2C             fs_rmdir:
1979   0C2C FD 79         mov g, b
1980   0C2E 11            mov a, b
1981   0C2F 07 99 07      call get_parentID_from_dirID  ; now get the directory's parent, in A
1982   0C32 D7            push a                        ; save dirID
1983   0C33             ; search for directory's entry in the parent's directory then and delete it
1984   0C33 77            inc a                         ; metadata sector
1985   0C34 27            mov b, a
1986   0C35 38 00 00      mov c, 0                      ; upper LBA = 0
1987   0C38 22 01         mov ah, $01          ;
1988   0C3A 3B 24 23      mov d, transient_area
1989   0C3D 07 27 04      call ide_read_sect            ; read directory
1990   0C40 FD 10         cla
1991   0C42 42 31 16      mov [index], a                ; reset file counter
1992   0C45 FD 27         mov b, g                      ; retrieve directory's dirID
1993   0C47             fs_rmdir_L1:
1994   0C47 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
1995   0C4A B0            cmp a, b                      ; compare dirID's to find the directory
1996   0C4B C6 61 0C      je fs_rmdir_found_entry
1997   0C4E 58 20 00      add d, 32
1998   0C51 14 31 16      mov a, [index]
1999   0C54 77            inc a
2000   0C55 42 31 16      mov [index], a
2001   0C58 AF 10 00      cmp a, FST_FILES_PER_DIR
2002   0C5B C6 86 0C      je fs_rmdir_not_found
2003   0C5E 0A 47 0C      jmp fs_rmdir_L1
2004   0C61             fs_rmdir_found_entry:
2005   0C61 FD 10         cla
2006   0C63 3E            mov [d], al                   ; make filename NULL
2007   0C64 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2008   0C67 E5            pop b
2009   0C68 FD 77         inc b                         ; metadata sector
2010   0C6A 38 00 00      mov c, 0                      ; upper LBA = 0
2011   0C6D 22 01         mov ah, $01          ; 
2012   0C6F 3B 24 23      mov d, transient_area
2013   0C72 07 4D 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2014   0C75             
2015   0C75 FD 27         mov b, g
2016   0C77 3B 24 23      mov d, transient_area  
2017   0C7A FD 10         cla
2018   0C7C 3E            mov [d], al                   ; make directory's name header NULL for re-use
2019   0C7D 38 00 00      mov c, 0
2020   0C80 22 01         mov ah, $01                   ; disk write 1 sect
2021   0C82 07 4D 04      call ide_write_sect           ; delete directory given by dirID in B
2022   0C85 06            sysret
2023   0C86             fs_rmdir_not_found:
2024   0C86 E5            pop b
2025   0C87 06            sysret
2026   0C88             
2027   0C88             ;------------------------------------------------------------------------------------------------------;
2028   0C88             ; RM - remove file
2029   0C88             ;------------------------------------------------------------------------------------------------------;
2030   0C88             ; frees up the data sectors for the file further down the disk
2031   0C88             ; deletes file entry in the directory's file list 
2032   0C88             fs_rm:
2033   0C88 FD 4E         mov si, d
2034   0C8A FD 4F 24 1B   mov di, user_data
2035   0C8E 38 00 02      mov c, 512
2036   0C91 04            load                          ; load data from user-space
2037   0C92 14 39 16      mov a, [current_dirID]
2038   0C95 77            inc a                         ; metadata sector
2039   0C96 27            mov b, a
2040   0C97 38 00 00      mov c, 0                      ; upper LBA = 0
2041   0C9A 22 01         mov ah, $01                  ; 1 sector
2042   0C9C 3B 24 23      mov d, transient_area
2043   0C9F 07 27 04      call ide_read_sect            ; read directory
2044   0CA2 10 00 00      mov a, 0
2045   0CA5 42 31 16      mov [index], a                ; reset file counter
2046   0CA8             fs_rm_L1:
2047   0CA8 FD 4E         mov si, d
2048   0CAA FD 4F 24 1B   mov di, user_data
2049   0CAE 07 42 0F      call _strcmp
2050   0CB1 C6 C7 0C      je fs_rm_found_entry
2051   0CB4 58 20 00      add d, 32
2052   0CB7 14 31 16      mov a, [index]
2053   0CBA 77            inc a
2054   0CBB 42 31 16      mov [index], a
2055   0CBE AF 10 00      cmp a, FST_FILES_PER_DIR
2056   0CC1 C6 EF 0C      je fs_rm_not_found
2057   0CC4 0A A8 0C      jmp fs_rm_L1
2058   0CC7             fs_rm_found_entry:
2059   0CC7 2B 19 00      mov b, [d + 25]               ; get LBA
2060   0CCA FD 79         mov g, b                      ; save LBA
2061   0CCC 19 00         mov al, 0
2062   0CCE 3E            mov [d], al                   ; make file entry NULL
2063   0CCF 14 39 16      mov a, [current_dirID]
2064   0CD2 77            inc a                         ; metadata sector
2065   0CD3 27            mov b, a
2066   0CD4 38 00 00      mov c, 0                      ; upper LBA = 0
2067   0CD7 22 01         mov ah, $01                   ; disk write
2068   0CD9 3B 24 23      mov d, transient_area
2069   0CDC 07 4D 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2070   0CDF 3B 24 23      mov d, transient_area  
2071   0CE2 19 00         mov al, 0
2072   0CE4 3E            mov [d], al                   ; make file's data header NULL for re-use
2073   0CE5 38 00 00      mov c, 0
2074   0CE8 FD 27         mov b, g                      ; get data header LBA
2075   0CEA 22 01         mov ah, $01                   ; disk write 1 sect
2076   0CEC 07 4D 04      call ide_write_sect           ; write sector
2077   0CEF             fs_rm_not_found:  
2078   0CEF 06            sysret  
2079   0CF0             
2080   0CF0             ;------------------------------------------------------------------------------------------------------;
2081   0CF0             ; mv - move / change file name
2082   0CF0             ;------------------------------------------------------------------------------------------------------;
2083   0CF0             fs_mv:
2084   0CF0 FD 4E         mov si, d
2085   0CF2 FD 4F 24 1B   mov di, user_data
2086   0CF6 38 00 02      mov c, 512
2087   0CF9 04            load                          ; load data from user-space
2088   0CFA 14 39 16      mov a, [current_dirID]
2089   0CFD 77            inc a                         ; metadata sector
2090   0CFE 27            mov b, a  
2091   0CFF 38 00 00      mov c, 0                      ; upper LBA = 0
2092   0D02 22 01         mov ah, $01                  ; 1 sector
2093   0D04 3B 24 23      mov d, transient_area
2094   0D07 07 27 04      call ide_read_sect            ; read directory
2095   0D0A FD 10         cla
2096   0D0C 42 31 16      mov [index], a                ; reset file counter
2097   0D0F             fs_mv_L1:
2098   0D0F FD 4E         mov si, d
2099   0D11 FD 4F 24 1B   mov di, user_data
2100   0D15 07 42 0F      call _strcmp
2101   0D18 C6 2E 0D      je fs_mv_found_entry
2102   0D1B 58 20 00      add d, 32
2103   0D1E 14 31 16      mov a, [index]
2104   0D21 77            inc a
2105   0D22 42 31 16      mov [index], a
2106   0D25 AF 10 00      cmp a, FST_FILES_PER_DIR
2107   0D28 C6 60 0D      je fs_mv_not_found
2108   0D2B 0A 0F 0D      jmp fs_mv_L1
2109   0D2E             fs_mv_found_entry:  
2110   0D2E DA            push d
2111   0D2F FD 4D A4 1B   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2112   0D33 FD 50         mov di, d
2113   0D35 07 57 0F      call _strcpy  
2114   0D38 38 00 00      mov c, 0
2115   0D3B 3B 24 23      mov d, transient_area
2116   0D3E 22 01         mov ah, $01                   ; disk write 1 sect
2117   0D40 07 4D 04      call ide_write_sect           ; write sector
2118   0D43 E7            pop d
2119   0D44             ;; need to check whether its a dir or a file here ;;;
2120   0D44 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2121   0D47 22 01         mov ah, $01
2122   0D49 3B 24 23      mov d, transient_area
2123   0D4C 38 00 00      mov c, 0
2124   0D4F 07 27 04      call ide_read_sect            ; read directory entry
2125   0D52 FD 4D A4 1B   mov si, user_data + 128
2126   0D56 FD 50         mov di, d
2127   0D58 07 57 0F      call _strcpy                  ; change directory's name
2128   0D5B 22 01         mov ah, $01
2129   0D5D 07 4D 04      call ide_write_sect           ; rewrite directory back to disk
2130   0D60             fs_mv_not_found:
2131   0D60 06            sysret
2132   0D61             
2133   0D61             kernel_reset_vector:  
2134   0D61 FD 49 FF F7   mov bp, STACK_BEGIN
2135   0D65 FD 47 FF F7   mov sp, STACK_BEGIN
2136   0D69               
2137   0D69 19 80         mov al, %10000000
2138   0D6B FD 0F         stomsk                        ; mask out timer interrupt for now (only allow UART to interrupt)
2139   0D6D FD 0C         sti  
2140   0D6F             
2141   0D6F 0C            lodstat
2142   0D70 87 DF         and al, %11011111             ; disable display register loading
2143   0D72 0D            stostat
2144   0D73               
2145   0D73             ; reset fifo pointers
2146   0D73 10 24 1D      mov a, fifo
2147   0D76 3B 35 16      mov d, fifo_in
2148   0D79 43            mov [d], a
2149   0D7A 3B 37 16      mov d, fifo_out
2150   0D7D 43            mov [d], a  
2151   0D7E 19 02         mov al, 2
2152   0D80 05 03         syscall sys_io                ; enable uart in interrupt mode
2153   0D82               
2154   0D82 3B 78 16      mov d, s_kernel_started
2155   0D85 07 FF 10      call _puts
2156   0D88             
2157   0D88 19 10         mov al, 16
2158   0D8A 05 04         syscall sys_filesystem        ; set root dirID
2159   0D8C             
2160   0D8C 3B 88 16      mov d, s_prompt_init
2161   0D8F 07 FF 10      call _puts
2162   0D92 3B 3B 16      mov d, s_init_path
2163   0D95 05 05         syscall sys_spawn_proc              ; launch init as a new process
2164   0D97             
2165   0D97             ;----------------------------------------------------------------------------------------------------;
2166   0D97             ; Process Index in A
2167   0D97             ;----------------------------------------------------------------------------------------------------;
2168   0D97             find_free_proc:
2169   0D97 FD 4D 95 18   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2170   0D9B             find_free_proc_L0:
2171   0D9B F6            lodsb                               ; get process state
2172   0D9C B9 00         cmp al, 0
2173   0D9E C6 A4 0D      je find_free_proc_free              ; if free, jump
2174   0DA1 0A 9B 0D      jmp find_free_proc_L0               ; else, goto next
2175   0DA4             find_free_proc_free:
2176   0DA4 4E            mov a, si
2177   0DA5 5F 95 18      sub a, 1 + proc_availab_table       ; get process index
2178   0DA8 09            ret
2179   0DA9               
2180   0DA9             
2181   0DA9             ;----------------------------------------------------------------------------------------------------;
2182   0DA9             ; Process Index in AL
2183   0DA9             ;----------------------------------------------------------------------------------------------------;
2184   0DA9             proc_memory_map:
2185   0DA9 22 00         mov ah, 0
2186   0DAB 27            mov b, a                      ; page in BL, 0 in BH
2187   0DAC FD 9D 05      shl a, 5                      ; multiply by 32
2188   0DAF 39            mov c, a                      ; save in C
2189   0DB0 57 20 00      add c, 32
2190   0DB3             proc_memory_map_L0:
2191   0DB3 02            pagemap
2192   0DB4 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2193   0DB7 53 01 00      add a, 1                      ; increase both 
2194   0DBA B1            cmp a, c                      ; check to see if we reached the end of memory
2195   0DBB C7 B3 0D      jne proc_memory_map_L0
2196   0DBE 09            ret
2197   0DBF               
2198   0DBF             
2199   0DBF             syscall_terminate_proc:
2200   0DBF 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2201   0DC2                                                    ; since they will not be used for anything here.
2202   0DC2 1D 30 16      mov al, [active_proc_index]
2203   0DC5 22 00         mov ah, 0  
2204   0DC7 FD 9D 05      shl a, 5                             ; x32
2205   0DCA 53 A4 18      add a, proc_names
2206   0DCD 3C            mov d, a
2207   0DCE 19 00         mov al, 0
2208   0DD0 3E            mov [d], al                           ; nullify process name
2209   0DD1             
2210   0DD1 1D 30 16      mov al, [active_proc_index]
2211   0DD4 22 00         mov ah, 0  
2212   0DD6 3C            mov d, a
2213   0DD7 19 00         mov al, 0
2214   0DD9 3F 94 18      mov [d + proc_availab_table], al    ; make process empty again
2215   0DDC               
2216   0DDC 1D 2F 16      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2217   0DDF 80            dec al
2218   0DE0 3D 2F 16      mov [nbr_active_procs], al
2219   0DE3             
2220   0DE3             ; now load the shell process again
2221   0DE3 19 02         mov al, 2                           ; next process = process 2 = shell
2222   0DE5 3D 30 16      mov [active_proc_index], al         ; set next active proc
2223   0DE8             
2224   0DE8             ; calculate LUT entry for next process
2225   0DE8 22 00         mov ah, 0
2226   0DEA FD 99         shl a                               ; x2
2227   0DEC B7 B5 0E      mov a, [proc_table_convert + a]     ; get process state start index  
2228   0DEF               
2229   0DEF 4D            mov si, a                           ; source is proc state block
2230   0DF0 48            mov a, sp
2231   0DF1 5F 13 00      sub a, 19
2232   0DF4 4F            mov di, a                           ; destination is kernel stack
2233   0DF5             ; restore SP
2234   0DF5 7D            dec a
2235   0DF6 47            mov sp, a
2236   0DF7 38 14 00      mov c, 20
2237   0DFA FD F5         rep movsb
2238   0DFC             ; set VM process
2239   0DFC 1D 30 16      mov al, [active_proc_index]
2240   0DFF 01            setptb
2241   0E00                 
2242   0E00 4C            popa
2243   0E01 06            sysret
2244   0E02             
2245   0E02             syscall_pause_proc:
2246   0E02             ; save all registers into kernel stack
2247   0E02 4B            pusha
2248   0E03 22 00         mov ah, 0
2249   0E05 1D 30 16      mov al, [active_proc_index]
2250   0E08 FD 99         shl a              ; x2
2251   0E0A B7 B5 0E      mov a, [proc_table_convert + a]   ; get process state start index
2252   0E0D                 
2253   0E0D 4F            mov di, a
2254   0E0E 48            mov a, sp
2255   0E0F 77            inc a
2256   0E10 4D            mov si, a
2257   0E11 38 14 00      mov c, 20
2258   0E14 FD F5         rep movsb                         ; save process state!
2259   0E16             ; restore kernel stack position to point before interrupt arrived
2260   0E16 51 14 00      add sp, 20
2261   0E19             ; now load the shell process again
2262   0E19 19 02         mov al, 2                         ; next process = process 2 = shell
2263   0E1B 3D 30 16      mov [active_proc_index], al       ; set next active proc
2264   0E1E             
2265   0E1E             ; calculate LUT entry for next process
2266   0E1E 22 00         mov ah, 0
2267   0E20 FD 99         shl a                             ; x2
2268   0E22 B7 B5 0E      mov a, [proc_table_convert + a]   ; get process state start index  
2269   0E25               
2270   0E25 4D            mov si, a                         ; source is proc state block
2271   0E26 48            mov a, sp
2272   0E27 5F 13 00      sub a, 19
2273   0E2A 4F            mov di, a                         ; destination is kernel stack
2274   0E2B             ; restore SP
2275   0E2B 7D            dec a
2276   0E2C 47            mov sp, a
2277   0E2D 38 14 00      mov c, 20
2278   0E30 FD F5         rep movsb
2279   0E32             ; set VM process
2280   0E32 1D 30 16      mov al, [active_proc_index]
2281   0E35 01            setptb
2282   0E36                 
2283   0E36 4C            popa
2284   0E37 06            sysret
2285   0E38             
2286   0E38             ;----------------------------------------------------------------------------------------------------;
2287   0E38             ; spawn a new process
2288   0E38             ; D = path of the process file to be spawned
2289   0E38             ; B = arguments ptr
2290   0E38             ;----------------------------------------------------------------------------------------------------;
2291   0E38             syscall_spawn_proc:
2292   0E38             ; we save the active process first  
2293   0E38 4B            pusha
2294   0E39 22 00         mov ah, 0
2295   0E3B 1D 30 16      mov al, [active_proc_index]
2296   0E3E FD 99         shl a              ; x2
2297   0E40 B7 B5 0E      mov a, [proc_table_convert + a]    ; get process state table's start index
2298   0E43               
2299   0E43 4F            mov di, a
2300   0E44 48            mov a, sp
2301   0E45 77            inc a
2302   0E46 4D            mov si, a
2303   0E47 38 14 00      mov c, 20
2304   0E4A FD F5         rep movsb                          ; save process state!
2305   0E4C             ; restore kernel stack position to point before interrupt arrived
2306   0E4C 51 14 00      add sp, 20
2307   0E4F               
2308   0E4F FD 4E         mov si, d                          ; copy the file path
2309   0E51 FD 4F 24 1B   mov di, user_data
2310   0E55 38 00 02      mov c, 512
2311   0E58 04            load
2312   0E59 11            mov a, b
2313   0E5A 4D            mov si, a                          ; copy the arguments
2314   0E5B FD 4F 24 21   mov di, scrap_sector
2315   0E5F 38 00 02      mov c, 512
2316   0E62 04            load
2317   0E63 07 DF 08      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2318   0E66                                                  ; the file data is loaded into transient_area
2319   0E66             ; now we allocate a new process  
2320   0E66 07 97 0D      call find_free_proc                ; index in A
2321   0E69 01            setptb 
2322   0E6A 07 A9 0D      call proc_memory_map               ; map process memory pages
2323   0E6D             ; copy arguments into process's memory
2324   0E6D FD 4D 24 21   mov si, scrap_sector
2325   0E71 FD 4F 00 00   mov di, 0
2326   0E75 38 00 02      mov c, 512
2327   0E78 03            store
2328   0E79             ; now copy process binary data into process's memory
2329   0E79 FD 4D 24 23   mov si, transient_area
2330   0E7D FD 4F 00 04   mov di, text_org              ; code origin address for all user processes
2331   0E81 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2332   0E84 03            store                              ; copy process data
2333   0E85                 
2334   0E85 07 97 0D      call find_free_proc                ; index in A
2335   0E88 3D 30 16      mov [active_proc_index], al        ; set new active process
2336   0E8B FD 9D 05      shl a, 5                           ; x32
2337   0E8E 53 A4 18      add a, proc_names
2338   0E91 4F            mov di, a
2339   0E92 FD 4D 24 1B   mov si, user_data                  ; copy and store process filename
2340   0E96 07 57 0F      call _strcpy
2341   0E99               
2342   0E99 07 97 0D      call find_free_proc                ; index in A
2343   0E9C 3C            mov d, a
2344   0E9D 19 01         mov al, 1
2345   0E9F 3F 94 18      mov [d + proc_availab_table], al   ; make process busy
2346   0EA2               
2347   0EA2 1D 2F 16      mov al, [nbr_active_procs]         ; increase nbr of active processes
2348   0EA5 7A            inc al
2349   0EA6 3D 2F 16      mov [nbr_active_procs], al
2350   0EA9             ; launch process
2351   0EA9 FD D7 FF FF   push word $FFFF 
2352   0EAD FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2353   0EB0 FD D7 00 04   push word text_org
2354   0EB4 06            sysret
2355   0EB5             
2356   0EB5             proc_table_convert:
2357   0EB5 54 17         .dw proc_state_table + 0
2358   0EB7 68 17         .dw proc_state_table + 20
2359   0EB9 7C 17         .dw proc_state_table + 40
2360   0EBB 90 17         .dw proc_state_table + 60
2361   0EBD A4 17         .dw proc_state_table + 80
2362   0EBF B8 17         .dw proc_state_table + 100
2363   0EC1 CC 17         .dw proc_state_table + 120
2364   0EC3 E0 17         .dw proc_state_table + 140
2365   0EC5               
2366   0EC5             ;----------------------------------------------------------------------------------------------;
2367   0EC5             ; GET HEX FILE
2368   0EC5             ; di = destination address
2369   0EC5             ; return length in bytes in C
2370   0EC5             ;----------------------------------------------------------------------------------------------;
2371   0EC5             _load_hex:
2372   0EC5 D7            push a
2373   0EC6 D8            push b
2374   0EC7 DA            push d
2375   0EC8 E2            push si
2376   0EC9 E3            push di
2377   0ECA 38 00 00      mov c, 0
2378   0ECD 50            mov a, di
2379   0ECE 3C            mov d, a          ; start of string data block
2380   0ECF 07 DA 0F      call _gets        ; get program string
2381   0ED2 4D            mov si, a
2382   0ED3             __load_hex_loop:
2383   0ED3 F6            lodsb             ; load from [SI] to AL
2384   0ED4 B9 00         cmp al, 0         ; check if ASCII 0
2385   0ED6 C6 E4 0E      jz __load_hex_ret
2386   0ED9 36            mov bh, al
2387   0EDA F6            lodsb
2388   0EDB 2F            mov bl, al
2389   0EDC 07 90 0F      call _atoi        ; convert ASCII byte in B to int (to AL)
2390   0EDF F7            stosb             ; store AL to [DI]
2391   0EE0 78            inc c
2392   0EE1 0A D3 0E      jmp __load_hex_loop
2393   0EE4             __load_hex_ret:
2394   0EE4 F0            pop di
2395   0EE5 EF            pop si
2396   0EE6 E7            pop d
2397   0EE7 E5            pop b
2398   0EE8 E4            pop a
2399   0EE9 09            ret
2400   0EEA             
2401   0EEA             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2402   0EEA             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2403   0EEA             ; for each entry insIDE DIRECTORY:
2404   0EEA             ;  if entry is a file:
2405   0EEA             ;    compare filename to searched filename
2406   0EEA             ;    if filenames are the same, print filename
2407   0EEA             ;  else if entry is a directory:
2408   0EEA             ;    cd to the given directory
2409   0EEA             ;    recursively call cmd_find
2410   0EEA             ;    cd outsIDE previous directory
2411   0EEA             ;  if current entry == last entry, return
2412   0EEA             ; endfor
2413   0EEA             f_find:
2414   0EEA 09            ret
2415   0EEB             
2416   0EEB             ; FILE INCLUDES
2417   0EEB             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  0EEB             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0EEB             IDE_buffer       .EQU  $8204
0003+  0EEB             boot_origin      .EQU  $8004
0004+  0EEB             bios_uart        .EQU  $0002
0005+  0EEB             bios_ide         .EQU  $0003
2418   0EEB             .include "lib/stdio.asm"
0001+  0EEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0EEB             ; stdio.s
0003+  0EEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0EEB             .include "lib/string.asm"
0001++ 0EEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0EEB             ; string.s
0003++ 0EEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0EEB             
0005++ 0EEB             
0006++ 0EEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0EEB             ; _strrev
0008++ 0EEB             ; reverse a string
0009++ 0EEB             ; D = string address
0010++ 0EEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0EEB             ; 01234
0012++ 0EEB             _strrev:
0013++ 0EEB 4B          	pusha
0014++ 0EEC 07 32 0F    	call _strlen	; length in C
0015++ 0EEF 12          	mov a, c
0016++ 0EF0 AF 01 00    	cmp a, 1
0017++ 0EF3 D0 0D 0F    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0EF6 7D          	dec a
0019++ 0EF7 FD 4E       	mov si, d	; beginning of string
0020++ 0EF9 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0EFB 59          	add d, a	; end of string
0022++ 0EFC 12          	mov a, c
0023++ 0EFD FD 9B       	shr a		; divide by 2
0024++ 0EFF 39          	mov c, a	; C now counts the steps
0025++ 0F00             _strrev_L0:
0026++ 0F00 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0F01 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0F02 3E          	mov [d], al	; store left char into right side
0029++ 0F03 1B          	mov al, bl
0030++ 0F04 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0F05 7E          	dec c
0032++ 0F06 7F          	dec d
0033++ 0F07 C2 00 00    	cmp c, 0
0034++ 0F0A C7 00 0F    	jne _strrev_L0
0035++ 0F0D             _strrev_end:
0036++ 0F0D 4C          	popa
0037++ 0F0E 09          	ret
0038++ 0F0F             	
0039++ 0F0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0F0F             ; _strchr
0041++ 0F0F             ; search string in D for char in AL
0042++ 0F0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0F0F             _strchr:
0044++ 0F0F             _strchr_L0:
0045++ 0F0F 32          	mov bl, [d]
0046++ 0F10 C1 00       	cmp bl, 0
0047++ 0F12 C6 1D 0F    	je _strchr_end
0048++ 0F15 BA          	cmp al, bl
0049++ 0F16 C6 1D 0F    	je _strchr_end
0050++ 0F19 79          	inc d
0051++ 0F1A 0A 0F 0F    	jmp _strchr_L0
0052++ 0F1D             _strchr_end:
0053++ 0F1D 1B          	mov al, bl
0054++ 0F1E 09          	ret
0055++ 0F1F             
0056++ 0F1F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0F1F             ; _strstr
0058++ 0F1F             ; find sub-string
0059++ 0F1F             ; str1 in SI
0060++ 0F1F             ; str2 in DI
0061++ 0F1F             ; SI points to end of source string
0062++ 0F1F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0F1F             _strstr:
0064++ 0F1F DB          	push al
0065++ 0F20 DA          	push d
0066++ 0F21 E3          	push di
0067++ 0F22             _strstr_loop:
0068++ 0F22 F3          	cmpsb					; compare a byte of the strings
0069++ 0F23 C7 2E 0F    	jne _strstr_ret
0070++ 0F26 FC 00 00    	lea d, [di + 0]
0071++ 0F29 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0F2B C7 22 0F    	jne _strstr_loop				; equal chars but not at end
0073++ 0F2E             _strstr_ret:
0074++ 0F2E F0          	pop di
0075++ 0F2F E7          	pop d
0076++ 0F30 E8          	pop al
0077++ 0F31 09          	ret
0078++ 0F32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0F32             ; length of null terminated string
0080++ 0F32             ; result in C
0081++ 0F32             ; pointer in D
0082++ 0F32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0F32             _strlen:
0084++ 0F32 DA          	push d
0085++ 0F33 38 00 00    	mov c, 0
0086++ 0F36             _strlen_L1:
0087++ 0F36 BD 00       	cmp byte [d], 0
0088++ 0F38 C6 40 0F    	je _strlen_ret
0089++ 0F3B 79          	inc d
0090++ 0F3C 78          	inc c
0091++ 0F3D 0A 36 0F    	jmp _strlen_L1
0092++ 0F40             _strlen_ret:
0093++ 0F40 E7          	pop d
0094++ 0F41 09          	ret
0095++ 0F42             
0096++ 0F42             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0F42             ; STRCMP
0098++ 0F42             ; compare two strings
0099++ 0F42             ; str1 in SI
0100++ 0F42             ; str2 in DI
0101++ 0F42             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0F42             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0F42             _strcmp:
0104++ 0F42 DB          	push al
0105++ 0F43 DA          	push d
0106++ 0F44 E3          	push di
0107++ 0F45 E2          	push si
0108++ 0F46             _strcmp_loop:
0109++ 0F46 F3          	cmpsb					; compare a byte of the strings
0110++ 0F47 C7 52 0F    	jne _strcmp_ret
0111++ 0F4A FB FF FF    	lea d, [si +- 1]
0112++ 0F4D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0F4F C7 46 0F    	jne _strcmp_loop				; equal chars but not at end
0114++ 0F52             _strcmp_ret:
0115++ 0F52 EF          	pop si
0116++ 0F53 F0          	pop di
0117++ 0F54 E7          	pop d
0118++ 0F55 E8          	pop al
0119++ 0F56 09          	ret
0120++ 0F57             
0121++ 0F57             
0122++ 0F57             ; STRCPY
0123++ 0F57             ; copy null terminated string from SI to DI
0124++ 0F57             ; source in SI
0125++ 0F57             ; destination in DI
0126++ 0F57             _strcpy:
0127++ 0F57 E2          	push si
0128++ 0F58 E3          	push di
0129++ 0F59 DB          	push al
0130++ 0F5A             _strcpy_L1:
0131++ 0F5A F6          	lodsb
0132++ 0F5B F7          	stosb
0133++ 0F5C B9 00       	cmp al, 0
0134++ 0F5E C7 5A 0F    	jne _strcpy_L1
0135++ 0F61             _strcpy_end:
0136++ 0F61 E8          	pop al
0137++ 0F62 F0          	pop di
0138++ 0F63 EF          	pop si
0139++ 0F64 09          	ret
0140++ 0F65             
0141++ 0F65             ; STRCAT
0142++ 0F65             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0F65             ; source in SI
0144++ 0F65             ; destination in DI
0145++ 0F65             _strcat:
0146++ 0F65 E2          	push si
0147++ 0F66 E3          	push di
0148++ 0F67 D7          	push a
0149++ 0F68 DA          	push d
0150++ 0F69 50          	mov a, di
0151++ 0F6A 3C          	mov d, a
0152++ 0F6B             _strcat_goto_end_L1:
0153++ 0F6B BD 00       	cmp byte[d], 0
0154++ 0F6D C6 74 0F    	je _strcat_start
0155++ 0F70 79          	inc d
0156++ 0F71 0A 6B 0F    	jmp _strcat_goto_end_L1
0157++ 0F74             _strcat_start:
0158++ 0F74 FD 50       	mov di, d
0159++ 0F76             _strcat_L1:
0160++ 0F76 F6          	lodsb
0161++ 0F77 F7          	stosb
0162++ 0F78 B9 00       	cmp al, 0
0163++ 0F7A C7 76 0F    	jne _strcat_L1
0164++ 0F7D             _strcat_end:
0165++ 0F7D E7          	pop d
0166++ 0F7E E4          	pop a
0167++ 0F7F F0          	pop di
0168++ 0F80 EF          	pop si
0169++ 0F81 09          	ret
0170++ 0F82             
0171++ 0F82             
0005+  0F82             
0006+  0F82             
0007+  0F82             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0F82             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0F82             ; ASCII in BL
0010+  0F82             ; result in AL
0011+  0F82             ; ascii for F = 0100 0110
0012+  0F82             ; ascii for 9 = 0011 1001
0013+  0F82             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0F82             hex_ascii_encode:
0015+  0F82 1B            mov al, bl
0016+  0F83 93 40         test al, $40        ; test if letter or number
0017+  0F85 C7 8B 0F      jnz hex_letter
0018+  0F88 87 0F         and al, $0F        ; get number
0019+  0F8A 09            ret
0020+  0F8B             hex_letter:
0021+  0F8B 87 0F         and al, $0F        ; get letter
0022+  0F8D 6A 09         add al, 9
0023+  0F8F 09            ret
0024+  0F90             
0025+  0F90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0F90             ; ATOI
0027+  0F90             ; 2 letter hex string in B
0028+  0F90             ; 8bit integer returned in AL
0029+  0F90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0F90             _atoi:
0031+  0F90 D8            push b
0032+  0F91 07 82 0F      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0F94 30            mov bl, bh
0034+  0F95 DB            push al          ; save a
0035+  0F96 07 82 0F      call hex_ascii_encode
0036+  0F99 EA            pop bl  
0037+  0F9A FD 9E 04      shl al, 4
0038+  0F9D 8C            or al, bl
0039+  0F9E E5            pop b
0040+  0F9F 09            ret  
0041+  0FA0             
0042+  0FA0             
0043+  0FA0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0FA0             ; scanf
0045+  0FA0             ; no need for explanations!
0046+  0FA0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0FA0             scanf:
0048+  0FA0 09            ret
0049+  0FA1             
0050+  0FA1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0FA1             ; ITOA
0052+  0FA1             ; 8bit value in BL
0053+  0FA1             ; 2 byte ASCII result in A
0054+  0FA1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0FA1             _itoa:
0056+  0FA1 DA            push d
0057+  0FA2 D8            push b
0058+  0FA3 A7 00         mov bh, 0
0059+  0FA5 FD A4 04      shr bl, 4  
0060+  0FA8 74            mov d, b
0061+  0FA9 1F 3B 12      mov al, [d + s_hex_digits]
0062+  0FAC 23            mov ah, al
0063+  0FAD               
0064+  0FAD E5            pop b
0065+  0FAE D8            push b
0066+  0FAF A7 00         mov bh, 0
0067+  0FB1 FD 87 0F      and bl, $0F
0068+  0FB4 74            mov d, b
0069+  0FB5 1F 3B 12      mov al, [d + s_hex_digits]
0070+  0FB8 E5            pop b
0071+  0FB9 E7            pop d
0072+  0FBA 09            ret
0073+  0FBB             
0074+  0FBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0FBB             ; HEX STRING TO BINARY
0076+  0FBB             ; di = destination address
0077+  0FBB             ; si = source
0078+  0FBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0FBB             _hex_to_int:
0080+  0FBB             _hex_to_int_L1:
0081+  0FBB F6            lodsb          ; load from [SI] to AL
0082+  0FBC B9 00         cmp al, 0        ; check if ASCII 0
0083+  0FBE C6 CB 0F      jz _hex_to_int_ret
0084+  0FC1 36            mov bh, al
0085+  0FC2 F6            lodsb
0086+  0FC3 2F            mov bl, al
0087+  0FC4 07 90 0F      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0FC7 F7            stosb          ; store AL to [DI]
0089+  0FC8 0A BB 0F      jmp _hex_to_int_L1
0090+  0FCB             _hex_to_int_ret:
0091+  0FCB 09            ret    
0092+  0FCC             
0093+  0FCC             
0094+  0FCC             
0095+  0FCC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0FCC             ; GETCHAR
0097+  0FCC             ; char in ah
0098+  0FCC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0FCC             getch:
0100+  0FCC DB            push al
0101+  0FCD             getch_retry:
0102+  0FCD 19 01         mov al, 1
0103+  0FCF 05 03         syscall sys_io      ; receive in AH
0104+  0FD1 E8            pop al
0105+  0FD2 09            ret
0106+  0FD3             
0107+  0FD3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0FD3             ; PUTCHAR
0109+  0FD3             ; char in ah
0110+  0FD3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0FD3             _putchar:
0112+  0FD3 DB            push al
0113+  0FD4 19 00         mov al, 0
0114+  0FD6 05 03         syscall sys_io      ; char in AH
0115+  0FD8 E8            pop al
0116+  0FD9 09            ret
0117+  0FDA             
0118+  0FDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0FDA             ;; INPUT A STRING
0120+  0FDA             ;; terminates with null
0121+  0FDA             ;; pointer in D
0122+  0FDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0FDA             _gets:
0124+  0FDA D7            push a
0125+  0FDB DA            push d
0126+  0FDC             _gets_loop:
0127+  0FDC 19 01         mov al, 1
0128+  0FDE 05 03         syscall sys_io      ; receive in AH
0129+  0FE0 76 1B         cmp ah, 27
0130+  0FE2 C6 03 10      je _gets_ansi_esc
0131+  0FE5 76 0A         cmp ah, $0A        ; LF
0132+  0FE7 C6 5F 10      je _gets_end
0133+  0FEA 76 0D         cmp ah, $0D        ; CR
0134+  0FEC C6 5F 10      je _gets_end
0135+  0FEF 76 5C         cmp ah, $5C        ; '\\'
0136+  0FF1 C6 25 10      je _gets_escape
0137+  0FF4 76 08         cmp ah, $08      ; check for backspace
0138+  0FF6 C6 FF 0F      je _gets_backspace
0139+  0FF9 1A            mov al, ah
0140+  0FFA 3E            mov [d], al
0141+  0FFB 79            inc d
0142+  0FFC 0A DC 0F      jmp _gets_loop
0143+  0FFF             _gets_backspace:
0144+  0FFF 7F            dec d
0145+  1000 0A DC 0F      jmp _gets_loop
0146+  1003             _gets_ansi_esc:
0147+  1003 19 01         mov al, 1
0148+  1005 05 03         syscall sys_io        ; receive in AH without echo
0149+  1007 76 5B         cmp ah, '['
0150+  1009 C7 DC 0F      jne _gets_loop
0151+  100C 19 01         mov al, 1
0152+  100E 05 03         syscall sys_io          ; receive in AH without echo
0153+  1010 76 44         cmp ah, 'D'
0154+  1012 C6 1D 10      je _gets_left_arrow
0155+  1015 76 43         cmp ah, 'C'
0156+  1017 C6 21 10      je _gets_right_arrow
0157+  101A 0A DC 0F      jmp _gets_loop
0158+  101D             _gets_left_arrow:
0159+  101D 7F            dec d
0160+  101E 0A DC 0F      jmp _gets_loop
0161+  1021             _gets_right_arrow:
0162+  1021 79            inc d
0163+  1022 0A DC 0F      jmp _gets_loop
0164+  1025             _gets_escape:
0165+  1025 19 01         mov al, 1
0166+  1027 05 03         syscall sys_io      ; receive in AH
0167+  1029 76 6E         cmp ah, 'n'
0168+  102B C6 4A 10      je _gets_LF
0169+  102E 76 72         cmp ah, 'r'
0170+  1030 C6 51 10      je _gets_CR
0171+  1033 76 30         cmp ah, '0'
0172+  1035 C6 58 10      je _gets_NULL
0173+  1038 76 5C         cmp ah, $5C  ; '\'
0174+  103A C6 43 10      je _gets_slash
0175+  103D 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  103E 3E            mov [d], al
0177+  103F 79            inc d
0178+  1040 0A DC 0F      jmp _gets_loop
0179+  1043             _gets_slash:
0180+  1043 19 5C         mov al, $5C
0181+  1045 3E            mov [d], al
0182+  1046 79            inc d
0183+  1047 0A DC 0F      jmp _gets_loop
0184+  104A             _gets_LF:
0185+  104A 19 0A         mov al, $0A
0186+  104C 3E            mov [d], al
0187+  104D 79            inc d
0188+  104E 0A DC 0F      jmp _gets_loop
0189+  1051             _gets_CR:
0190+  1051 19 0D         mov al, $0D
0191+  1053 3E            mov [d], al
0192+  1054 79            inc d
0193+  1055 0A DC 0F      jmp _gets_loop
0194+  1058             _gets_NULL:
0195+  1058 19 00         mov al, $00
0196+  105A 3E            mov [d], al
0197+  105B 79            inc d
0198+  105C 0A DC 0F      jmp _gets_loop
0199+  105F             _gets_end:
0200+  105F 19 00         mov al, 0
0201+  1061 3E            mov [d], al        ; terminate string
0202+  1062 E7            pop d
0203+  1063 E4            pop a
0204+  1064 09            ret
0205+  1065             
0206+  1065             
0207+  1065             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1065             ;; INPUT TEXT
0209+  1065             ;; terminated with CTRL+D
0210+  1065             ;; pointer in D
0211+  1065             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1065             _gettxt:
0213+  1065 D7            push a
0214+  1066 DA            push d
0215+  1067             _gettxt_loop:
0216+  1067 19 01         mov al, 1
0217+  1069 05 03         syscall sys_io      ; receive in AH
0218+  106B 76 04         cmp ah, 4      ; EOT
0219+  106D C6 A6 10      je _gettxt_end
0220+  1070 76 08         cmp ah, $08      ; check for backspace
0221+  1072 C6 A2 10      je _gettxt_backspace
0222+  1075 76 5C         cmp ah, $5C        ; '\'
0223+  1077 C6 80 10      je _gettxt_escape
0224+  107A 1A            mov al, ah
0225+  107B 3E            mov [d], al
0226+  107C 79            inc d
0227+  107D 0A 67 10      jmp _gettxt_loop
0228+  1080             _gettxt_escape:
0229+  1080 19 01         mov al, 1
0230+  1082 05 03         syscall sys_io      ; receive in AH
0231+  1084 76 6E         cmp ah, 'n'
0232+  1086 C6 94 10      je _gettxt_LF
0233+  1089 76 72         cmp ah, 'r'
0234+  108B C6 9B 10      je _gettxt_CR
0235+  108E 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  108F 3E            mov [d], al
0237+  1090 79            inc d
0238+  1091 0A 67 10      jmp _gettxt_loop
0239+  1094             _gettxt_LF:
0240+  1094 19 0A         mov al, $0A
0241+  1096 3E            mov [d], al
0242+  1097 79            inc d
0243+  1098 0A 67 10      jmp _gettxt_loop
0244+  109B             _gettxt_CR:
0245+  109B 19 0D         mov al, $0D
0246+  109D 3E            mov [d], al
0247+  109E 79            inc d
0248+  109F 0A 67 10      jmp _gettxt_loop
0249+  10A2             _gettxt_backspace:
0250+  10A2 7F            dec d
0251+  10A3 0A 67 10      jmp _gettxt_loop
0252+  10A6             _gettxt_end:
0253+  10A6 19 00         mov al, 0
0254+  10A8 3E            mov [d], al        ; terminate string
0255+  10A9 E7            pop d
0256+  10AA E4            pop a
0257+  10AB 09            ret
0258+  10AC             
0259+  10AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  10AC             ; PRINT NEW LINE
0261+  10AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  10AC             printnl:
0263+  10AC D7            push a
0264+  10AD 10 00 0A      mov a, $0A00
0265+  10B0 05 03         syscall sys_io
0266+  10B2 10 00 0D      mov a, $0D00
0267+  10B5 05 03         syscall sys_io
0268+  10B7 E4            pop a
0269+  10B8 09            ret
0270+  10B9             
0271+  10B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  10B9             ; _strtoint
0273+  10B9             ; 4 digit hex string number in d
0274+  10B9             ; integer returned in A
0275+  10B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  10B9             _strtointx:
0277+  10B9 D8            push b
0278+  10BA 32            mov bl, [d]
0279+  10BB 37            mov bh, bl
0280+  10BC 33 01 00      mov bl, [d + 1]
0281+  10BF 07 90 0F      call _atoi        ; convert to int in AL
0282+  10C2 23            mov ah, al        ; move to AH
0283+  10C3 33 02 00      mov bl, [d + 2]
0284+  10C6 37            mov bh, bl
0285+  10C7 33 03 00      mov bl, [d + 3]
0286+  10CA 07 90 0F      call _atoi        ; convert to int in AL
0287+  10CD E5            pop b
0288+  10CE 09            ret
0289+  10CF             
0290+  10CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  10CF             ; _strtoint
0292+  10CF             ; 5 digit base10 string number in d
0293+  10CF             ; integer returned in A
0294+  10CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  10CF             _strtoint:
0296+  10CF E2            push si
0297+  10D0 D8            push b
0298+  10D1 D9            push c
0299+  10D2 DA            push d
0300+  10D3 07 32 0F      call _strlen      ; get string length in C
0301+  10D6 7E            dec c
0302+  10D7 FD 4E         mov si, d
0303+  10D9 12            mov a, c
0304+  10DA FD 99         shl a
0305+  10DC 3B 53 12      mov d, table_power
0306+  10DF 59            add d, a
0307+  10E0 38 00 00      mov c, 0
0308+  10E3             _strtoint_L0:
0309+  10E3 F6            lodsb      ; load ASCII to al
0310+  10E4 B9 00         cmp al, 0
0311+  10E6 C6 F9 10      je _strtoint_end
0312+  10E9 6F 30         sub al, $30    ; make into integer
0313+  10EB 22 00         mov ah, 0
0314+  10ED 2A            mov b, [d]
0315+  10EE AC            mul a, b      ; result in B since it fits in 16bits
0316+  10EF 11            mov a, b
0317+  10F0 28            mov b, c
0318+  10F1 54            add a, b
0319+  10F2 39            mov c, a
0320+  10F3 63 02 00      sub d, 2
0321+  10F6 0A E3 10      jmp _strtoint_L0
0322+  10F9             _strtoint_end:
0323+  10F9 12            mov a, c
0324+  10FA E7            pop d
0325+  10FB E6            pop c
0326+  10FC E5            pop b
0327+  10FD EF            pop si
0328+  10FE 09            ret
0329+  10FF             
0330+  10FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  10FF             ; PRINT NULL TERMINATED STRING
0332+  10FF             ; pointer in D
0333+  10FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  10FF             _puts:
0335+  10FF D7            push a
0336+  1100 DA            push d
0337+  1101             _puts_L1:
0338+  1101 1E            mov al, [d]
0339+  1102 B9 00         cmp al, 0
0340+  1104 C6 10 11      jz _puts_END
0341+  1107 23            mov ah, al
0342+  1108 19 00         mov al, 0
0343+  110A 05 03         syscall sys_io
0344+  110C 79            inc d
0345+  110D 0A 01 11      jmp _puts_L1
0346+  1110             _puts_END:
0347+  1110 E7            pop d
0348+  1111 E4            pop a
0349+  1112 09            ret
0350+  1113             
0351+  1113             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  1113             ; PRINT N SIZE STRING
0353+  1113             ; pointer in D
0354+  1113             ; size in C
0355+  1113             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  1113             _putsn:
0357+  1113 DB            push al
0358+  1114 DA            push d
0359+  1115 D9            push c
0360+  1116             _putsn_L0:
0361+  1116 1E            mov al, [d]
0362+  1117 23            mov ah, al
0363+  1118 19 00         mov al, 0
0364+  111A 05 03         syscall sys_io
0365+  111C 79            inc d
0366+  111D 7E            dec c  
0367+  111E C2 00 00      cmp c, 0
0368+  1121 C7 16 11      jne _putsn_L0
0369+  1124             _putsn_end:
0370+  1124 E6            pop c
0371+  1125 E7            pop d
0372+  1126 E8            pop al
0373+  1127 09            ret
0374+  1128             
0375+  1128             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  1128             ; print 16bit decimal number
0377+  1128             ; input number in A
0378+  1128             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  1128             print_u16d:
0380+  1128 D7            push a
0381+  1129 D8            push b
0382+  112A FD D8         push g
0383+  112C 26 10 27      mov b, 10000
0384+  112F AE            div a, b      ; get 10000's coeff.
0385+  1130 07 54 11      call print_number
0386+  1133 11            mov a, b
0387+  1134 26 E8 03      mov b, 1000
0388+  1137 AE            div a, b      ; get 1000's coeff.
0389+  1138 07 54 11      call print_number
0390+  113B 11            mov a, b
0391+  113C 26 64 00      mov b, 100
0392+  113F AE            div a, b
0393+  1140 07 54 11      call print_number
0394+  1143 11            mov a, b
0395+  1144 26 0A 00      mov b, 10
0396+  1147 AE            div a, b
0397+  1148 07 54 11      call print_number
0398+  114B 1B            mov al, bl      ; 1's coeff in bl
0399+  114C 07 54 11      call print_number
0400+  114F FD F1         pop g
0401+  1151 E5            pop b
0402+  1152 E4            pop a
0403+  1153 09            ret
0404+  1154             
0405+  1154             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1154             ; print AL
0407+  1154             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1154             print_number:
0409+  1154 6A 30         add al, $30
0410+  1156 23            mov ah, al
0411+  1157 07 D3 0F      call _putchar
0412+  115A 09            ret
0413+  115B             
0414+  115B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  115B             ; PRINT 16BIT HEX INTEGER
0416+  115B             ; integer value in reg B
0417+  115B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  115B             print_u16x:
0419+  115B D7            push a
0420+  115C D8            push b
0421+  115D DD            push bl
0422+  115E 30            mov bl, bh
0423+  115F 07 A1 0F      call _itoa        ; convert bh to char in A
0424+  1162 2F            mov bl, al        ; save al
0425+  1163 19 00         mov al, 0
0426+  1165 05 03         syscall sys_io        ; display AH
0427+  1167 24            mov ah, bl        ; retrieve al
0428+  1168 19 00         mov al, 0
0429+  116A 05 03         syscall sys_io        ; display AL
0430+  116C             
0431+  116C EA            pop bl
0432+  116D 07 A1 0F      call _itoa        ; convert bh to char in A
0433+  1170 2F            mov bl, al        ; save al
0434+  1171 19 00         mov al, 0
0435+  1173 05 03         syscall sys_io        ; display AH
0436+  1175 24            mov ah, bl        ; retrieve al
0437+  1176 19 00         mov al, 0
0438+  1178 05 03         syscall sys_io        ; display AL
0439+  117A             
0440+  117A E5            pop b
0441+  117B E4            pop a
0442+  117C 09            ret
0443+  117D             
0444+  117D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  117D             ; INPUT 16BIT HEX INTEGER
0446+  117D             ; read 16bit integer into A
0447+  117D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  117D             scan_u16x:
0449+  117D F8 10 00      enter 16
0450+  1180 D8            push b
0451+  1181 DA            push d
0452+  1182             
0453+  1182 FA F1 FF      lea d, [bp + -15]
0454+  1185 07 DA 0F      call _gets        ; get number
0455+  1188             
0456+  1188 32            mov bl, [d]
0457+  1189 37            mov bh, bl
0458+  118A 33 01 00      mov bl, [d + 1]
0459+  118D 07 90 0F      call _atoi        ; convert to int in AL
0460+  1190 23            mov ah, al        ; move to AH
0461+  1191             
0462+  1191 33 02 00      mov bl, [d + 2]
0463+  1194 37            mov bh, bl
0464+  1195 33 03 00      mov bl, [d + 3]
0465+  1198 07 90 0F      call _atoi        ; convert to int in AL
0466+  119B             
0467+  119B E7            pop d
0468+  119C E5            pop b
0469+  119D F9            leave
0470+  119E 09            ret
0471+  119F             
0472+  119F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  119F             ; PRINT 8bit HEX INTEGER
0474+  119F             ; integer value in reg bl
0475+  119F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  119F             print_u8x:
0477+  119F D7            push a
0478+  11A0 DD            push bl
0479+  11A1             
0480+  11A1 07 A1 0F      call _itoa        ; convert bl to char in A
0481+  11A4 2F            mov bl, al        ; save al
0482+  11A5 19 00         mov al, 0
0483+  11A7 05 03         syscall sys_io        ; display AH
0484+  11A9 24            mov ah, bl        ; retrieve al
0485+  11AA 19 00         mov al, 0
0486+  11AC 05 03         syscall sys_io        ; display AL
0487+  11AE             
0488+  11AE EA            pop bl
0489+  11AF E4            pop a
0490+  11B0 09            ret
0491+  11B1             
0492+  11B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  11B1             ; print 8bit decimal unsigned number
0494+  11B1             ; input number in AL
0495+  11B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  11B1             print_u8d:
0497+  11B1 D7            push a
0498+  11B2 D8            push b
0499+  11B3 FD D8         push g
0500+  11B5 22 00         mov ah, 0
0501+  11B7 26 64 00      mov b, 100
0502+  11BA AE            div a, b
0503+  11BB D8            push b      ; save remainder
0504+  11BC B9 00         cmp al, 0
0505+  11BE C6 C8 11      je skip100
0506+  11C1 6A 30         add al, $30
0507+  11C3 23            mov ah, al
0508+  11C4 19 00         mov al, 0
0509+  11C6 05 03         syscall sys_io  ; print coeff
0510+  11C8             skip100:
0511+  11C8 E4            pop a
0512+  11C9 22 00         mov ah, 0
0513+  11CB 26 0A 00      mov b, 10
0514+  11CE AE            div a, b
0515+  11CF D8            push b      ; save remainder
0516+  11D0 B9 00         cmp al, 0
0517+  11D2 C6 DC 11      je skip10
0518+  11D5 6A 30         add al, $30
0519+  11D7 23            mov ah, al
0520+  11D8 19 00         mov al, 0
0521+  11DA 05 03         syscall sys_io  ; print coeff
0522+  11DC             skip10:
0523+  11DC E4            pop a
0524+  11DD 1B            mov al, bl
0525+  11DE 6A 30         add al, $30
0526+  11E0 23            mov ah, al
0527+  11E1 19 00         mov al, 0
0528+  11E3 05 03         syscall sys_io  ; print coeff
0529+  11E5 FD F1         pop g
0530+  11E7 E5            pop b
0531+  11E8 E4            pop a
0532+  11E9 09            ret
0533+  11EA             
0534+  11EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  11EA             ; INPUT 8BIT HEX INTEGER
0536+  11EA             ; read 8bit integer into AL
0537+  11EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  11EA             scan_u8x:
0539+  11EA F8 04 00      enter 4
0540+  11ED D8            push b
0541+  11EE DA            push d
0542+  11EF             
0543+  11EF FA FD FF      lea d, [bp + -3]
0544+  11F2 07 DA 0F      call _gets        ; get number
0545+  11F5             
0546+  11F5 32            mov bl, [d]
0547+  11F6 37            mov bh, bl
0548+  11F7 33 01 00      mov bl, [d + 1]
0549+  11FA 07 90 0F      call _atoi        ; convert to int in AL
0550+  11FD             
0551+  11FD E7            pop d
0552+  11FE E5            pop b
0553+  11FF F9            leave
0554+  1200 09            ret
0555+  1201             
0556+  1201             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1201             ; input decimal number
0558+  1201             ; result in A
0559+  1201             ; 655'\0'
0560+  1201             ; low--------high
0561+  1201             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1201             scan_u16d:
0563+  1201 F8 08 00      enter 8
0564+  1204 E2            push si
0565+  1205 D8            push b
0566+  1206 D9            push c
0567+  1207 DA            push d
0568+  1208 FA F9 FF      lea d, [bp +- 7]
0569+  120B 07 DA 0F      call _gets
0570+  120E 07 32 0F      call _strlen      ; get string length in C
0571+  1211 7E            dec c
0572+  1212 FD 4E         mov si, d
0573+  1214 12            mov a, c
0574+  1215 FD 99         shl a
0575+  1217 3B 53 12      mov d, table_power
0576+  121A 59            add d, a
0577+  121B 38 00 00      mov c, 0
0578+  121E             mul_loop:
0579+  121E F6            lodsb      ; load ASCII to al
0580+  121F B9 00         cmp al, 0
0581+  1221 C6 34 12      je mul_exit
0582+  1224 6F 30         sub al, $30    ; make into integer
0583+  1226 22 00         mov ah, 0
0584+  1228 2A            mov b, [d]
0585+  1229 AC            mul a, b      ; result in B since it fits in 16bits
0586+  122A 11            mov a, b
0587+  122B 28            mov b, c
0588+  122C 54            add a, b
0589+  122D 39            mov c, a
0590+  122E 63 02 00      sub d, 2
0591+  1231 0A 1E 12      jmp mul_loop
0592+  1234             mul_exit:
0593+  1234 12            mov a, c
0594+  1235 E7            pop d
0595+  1236 E6            pop c
0596+  1237 E5            pop b
0597+  1238 EF            pop si
0598+  1239 F9            leave
0599+  123A 09            ret
0600+  123B             
0601+  123B             
0602+  123B 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  123F 34 35 36 37 
0602+  1243 38 39 41 42 
0602+  1247 43 44 45 46 
0603+  124B 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  124F 1B 5B 48 00 
0604+  1253             
0605+  1253             table_power:
0606+  1253 01 00         .dw 1
0607+  1255 0A 00         .dw 10
0608+  1257 64 00         .dw 100
0609+  1259 E8 03         .dw 1000
0610+  125B 10 27         .dw 100002419   125D             .include "lib/ctype.asm"
0001+  125D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  125D             ; ctype.s
0003+  125D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  125D             
0005+  125D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  125D             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  125D             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  125D             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  125D             ;; characters are supported.
0010+  125D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  125D             ;; _isalnum 
0012+  125D             ;; _isalpha 
0013+  125D             ;; islower 
0014+  125D             ;; isupper 
0015+  125D             ;; _isdigit 
0016+  125D             ;; isxdigit
0017+  125D             ;; iscntrl 
0018+  125D             ;; isgraph 
0019+  125D             ;; _isspace 
0020+  125D             ;; isblank 
0021+  125D             ;; isprint 
0022+  125D             ;; ispunct 
0023+  125D             ;; tolower 
0024+  125D             ;; toupper
0025+  125D             
0026+  125D             
0027+  125D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  125D             ;; IS ALPHANUMERIC
0029+  125D             ;; sets ZF according with result
0030+  125D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  125D             _isalnum:
0032+  125D 07 7A 12    	call _isalpha
0033+  1260 C6 66 12    	je _isalnum_exit
0034+  1263 07 67 12    	call _isdigit
0035+  1266             _isalnum_exit:
0036+  1266 09          	ret	
0037+  1267             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1267             ;; IS DIGIT
0039+  1267             ;; sets ZF according with result
0040+  1267             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1267             _isdigit:
0042+  1267 DB          	push al
0043+  1268 B9 30       	cmp al, '0'
0044+  126A C8 76 12    	jlu _isdigit_false
0045+  126D B9 39       	cmp al, '9'
0046+  126F D1 76 12    	jgu _isdigit_false
0047+  1272 87 00       	and al, 0	; set ZF
0048+  1274 E8          	pop al
0049+  1275 09          	ret
0050+  1276             _isdigit_false:
0051+  1276 8B 01       	or al, 1	; clear ZF
0052+  1278 E8          	pop al
0053+  1279 09          	ret	
0054+  127A             	
0055+  127A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  127A             ;; IS ALPHA
0057+  127A             ;; sets ZF according with result
0058+  127A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  127A             _isalpha:
0060+  127A DB          	push al
0061+  127B B9 5F       	cmp al, '_'
0062+  127D C6 9D 12    	je _isalpha_true
0063+  1280 B9 2E       	cmp al, '.'
0064+  1282 C6 9D 12    	je _isalpha_true
0065+  1285 B9 41       	cmp al, 'A'
0066+  1287 C8 99 12    	jlu _isalpha_false
0067+  128A B9 7A       	cmp al, 'z'
0068+  128C D1 99 12    	jgu _isalpha_false
0069+  128F B9 5A       	cmp al, 'Z'
0070+  1291 D0 9D 12    	jleu _isalpha_true
0071+  1294 B9 61       	cmp al, 'a'
0072+  1296 C9 9D 12    	jgeu _isalpha_true
0073+  1299             _isalpha_false:
0074+  1299 8B 01       	or al, 1	; clear ZF
0075+  129B E8          	pop al
0076+  129C 09          	ret
0077+  129D             _isalpha_true:
0078+  129D 87 00       	and al, 0	; set ZF
0079+  129F E8          	pop al
0080+  12A0 09          	ret
0081+  12A1             
0082+  12A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  12A1             ;; IS PATH-ALPHA
0084+  12A1             ;; sets ZF according with result
0085+  12A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  12A1             ispath:
0087+  12A1 DB          	push al
0088+  12A2 07 67 12    	call _isdigit
0089+  12A5 C6 CF 12    	je ispath_true
0090+  12A8 B9 5F       	cmp al, '_'
0091+  12AA C6 CF 12    	je ispath_true
0092+  12AD B9 2F       	cmp al, '/'
0093+  12AF C6 CF 12    	je ispath_true
0094+  12B2 B9 2E       	cmp al, '.'
0095+  12B4 C6 CF 12    	je ispath_true
0096+  12B7 B9 41       	cmp al, 'A'
0097+  12B9 C8 CB 12    	jlu ispath_false
0098+  12BC B9 7A       	cmp al, 'z'
0099+  12BE D1 CB 12    	jgu ispath_false
0100+  12C1 B9 5A       	cmp al, 'Z'
0101+  12C3 D0 CF 12    	jleu ispath_true
0102+  12C6 B9 61       	cmp al, 'a'
0103+  12C8 C9 CF 12    	jgeu ispath_true
0104+  12CB             ispath_false:
0105+  12CB 8B 01       	or al, 1	; clear ZF
0106+  12CD E8          	pop al
0107+  12CE 09          	ret
0108+  12CF             ispath_true:
0109+  12CF 87 00       	and al, 0	; set ZF
0110+  12D1 E8          	pop al
0111+  12D2 09          	ret
0112+  12D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  12D3             ;; IS SPACE
0114+  12D3             ;; sets ZF according with result
0115+  12D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  12D3             _isspace:
0117+  12D3 B9 20       	cmp al, $20		; ' '
0118+  12D5 C6 E9 12    	je _isspace_exit
0119+  12D8 B9 09       	cmp al, $09		; '\t'
0120+  12DA C6 E9 12    	je _isspace_exit
0121+  12DD B9 0A       	cmp al, $0A		; '\n'
0122+  12DF C6 E9 12    	je _isspace_exit
0123+  12E2 B9 0D       	cmp al, $0D		; '\r'
0124+  12E4 C6 E9 12    	je _isspace_exit
0125+  12E7 B9 0B       	cmp al, $0B		; '\v'
0126+  12E9             _isspace_exit:
0127+  12E9 09          	ret	
0128+  12EA             
0129+  12EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  12EA             ; TO LOWER
0131+  12EA             ; input in AL
0132+  12EA             ; output in AL
0133+  12EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  12EA             _to_lower:
0135+  12EA B9 5A       	cmp al, 'Z'
0136+  12EC D1 F1 12    	jgu _to_lower_ret
0137+  12EF 6A 20       	add al, $20				; convert to lower case
0138+  12F1             _to_lower_ret:
0139+  12F1 09          	ret
0140+  12F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  12F2             ; TO UPPER
0142+  12F2             ; input in AL
0143+  12F2             ; output in AL
0144+  12F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  12F2             _to_upper:
0146+  12F2 B9 61       	cmp al, 'a'
0147+  12F4 C8 F9 12    	jlu _to_upper_ret
0148+  12F7 6F 20       	sub al, $20			; convert to upper case
0149+  12F9             _to_upper_ret:
0150+  12F9 09          	ret
0151+  12FA             
2420   12FA             .include "lib/token.asm"
0001+  12FA             TOKTYP_IDENTIFIER  .equ 0
0002+  12FA             TOKTYP_KEYWORD     .equ 1
0003+  12FA             TOKTYP_DELIMITER   .equ 2
0004+  12FA             TOKTYP_STRING      .equ 3
0005+  12FA             TOKTYP_CHAR        .equ 4
0006+  12FA             TOKTYP_NUMERIC     .equ 5
0007+  12FA             TOKTYP_END         .equ 6
0008+  12FA             
0009+  12FA             TOK_NULL           .equ 0
0010+  12FA             TOK_FSLASH         .equ 1
0011+  12FA             TOK_TIMES          .equ 2
0012+  12FA             TOK_PLUS           .equ 3
0013+  12FA             TOK_MINUS          .equ 4
0014+  12FA             TOK_DOT            .equ 5
0015+  12FA             TOK_SEMI           .equ 6
0016+  12FA             TOK_ANGLE          .equ 7
0017+  12FA             TOK_TILDE          .equ 8
0018+  12FA             TOK_EQUAL          .equ 9
0019+  12FA             TOK_COLON          .equ 10
0020+  12FA             TOK_COMMA          .equ 11
0021+  12FA             
0022+  12FA             TOK_END            .equ 20
0023+  12FA             
0024+  12FA             
0025+  12FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  12FA             ;; read a full command argment from shell input buffer
0027+  12FA             ;; argument is written into tokstr
0028+  12FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  12FA             get_arg:
0030+  12FA D7            push a
0031+  12FB E2            push si
0032+  12FC E3            push di
0033+  12FD 19 00         mov al, 0
0034+  12FF 3D 28 15      mov [tokstr], al      ; nullify tokstr string
0035+  1302 14 24 15      mov a, [prog]
0036+  1305 4D            mov si, a
0037+  1306 FD 4F 28 15   mov di, tokstr
0038+  130A             get_arg_skip_spaces:
0039+  130A F6            lodsb
0040+  130B 07 D3 12      call _isspace
0041+  130E C6 0A 13      je get_arg_skip_spaces
0042+  1311             get_arg_L0:
0043+  1311 B9 3B         cmp al, $3B        ; check if is ';'
0044+  1313 C6 20 13      je get_arg_end
0045+  1316 B9 00         cmp al, 0
0046+  1318 C6 20 13      je get_arg_end      ; check if end of input
0047+  131B F7            stosb
0048+  131C F6            lodsb
0049+  131D 0A 11 13      jmp get_arg_L0
0050+  1320             get_arg_end:
0051+  1320 19 00         mov al, 0
0052+  1322 F7            stosb
0053+  1323 D5 01 00      sub si, 1
0054+  1326 4E            mov a, si
0055+  1327 42 24 15      mov [prog], a    ; update pointer
0056+  132A F0            pop di
0057+  132B EF            pop si
0058+  132C E4            pop a
0059+  132D 09            ret
0060+  132E             
0061+  132E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  132E             ;; read a path formation from shell input buffer
0063+  132E             ;; path is written into tokstr
0064+  132E             ;; /usr/bin
0065+  132E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  132E             get_path:
0067+  132E D7            push a
0068+  132F E2            push si
0069+  1330 E3            push di
0070+  1331 19 00         mov al, 0
0071+  1333 3D 28 15      mov [tokstr], al      ; nullify tokstr string
0072+  1336 14 24 15      mov a, [prog]
0073+  1339 4D            mov si, a
0074+  133A FD 4F 28 15   mov di, tokstr
0075+  133E             get_path_skip_spaces:
0076+  133E F6            lodsb
0077+  133F 07 D3 12      call _isspace
0078+  1342 C6 3E 13      je get_path_skip_spaces
0079+  1345             get_path_is_pathchar:
0080+  1345 F7            stosb
0081+  1346 F6            lodsb
0082+  1347 07 5D 12      call _isalnum      ;check if is alphanumeric
0083+  134A C6 45 13      je get_path_is_pathchar
0084+  134D B9 2F         cmp al, '/'        ; check if is '/'
0085+  134F C6 45 13      je get_path_is_pathchar
0086+  1352 19 00         mov al, 0
0087+  1354 F7            stosb
0088+  1355 D5 01 00      sub si, 1
0089+  1358 4E            mov a, si
0090+  1359 42 24 15      mov [prog], a    ; update pointer
0091+  135C             get_path_end:
0092+  135C F0            pop di
0093+  135D EF            pop si
0094+  135E E4            pop a
0095+  135F 09            ret
0096+  1360             
0097+  1360             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  1360             ;; read a line
0099+  1360             ;; line is written into tokstr
0100+  1360             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  1360             get_line:
0102+  1360 D7            push a
0103+  1361 E2            push si
0104+  1362 E3            push di
0105+  1363 19 00         mov al, 0
0106+  1365 3D 28 15      mov [tokstr], al      ; nullify tokstr string
0107+  1368 14 24 15      mov a, [prog]
0108+  136B 4D            mov si, a
0109+  136C FD 4F 28 15   mov di, tokstr
0110+  1370             get_line_L0:
0111+  1370 F6            lodsb
0112+  1371 B9 0A         cmp al, $0A    ; check for new line
0113+  1373 C6 7A 13      je get_line_exit
0114+  1376 F7            stosb
0115+  1377 0A 70 13      jmp get_line_L0
0116+  137A             get_line_exit:
0117+  137A 19 00         mov al, 0
0118+  137C F7            stosb
0119+  137D 4E            mov a, si
0120+  137E 42 24 15      mov [prog], a    ; update pointer
0121+  1381 F0            pop di
0122+  1382 EF            pop si
0123+  1383 E4            pop a
0124+  1384 09            ret
0125+  1385             
0126+  1385             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1385             ;; token parser
0128+  1385             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1385             get_token:
0130+  1385 D7            push a
0131+  1386 DA            push d
0132+  1387 E2            push si
0133+  1388 E3            push di
0134+  1389 19 00         mov al, 0
0135+  138B 3D 28 15      mov [tokstr], al      ; nullify tokstr string
0136+  138E 19 00         mov al, TOK_NULL
0137+  1390 3D 27 15      mov [tok], al        ; nullify token
0138+  1393 14 24 15      mov a, [prog]
0139+  1396 4D            mov si, a
0140+  1397 FD 4F 28 15   mov di, tokstr
0141+  139B             get_tok_skip_spaces:
0142+  139B F6            lodsb
0143+  139C 07 D3 12      call _isspace
0144+  139F C6 9B 13      je get_tok_skip_spaces
0145+  13A2 B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  13A4 C6 89 14      je get_token_end
0147+  13A7 B9 23         cmp al, '#'      ; comments!
0148+  13A9 C6 B7 14      je get_tok_comment
0149+  13AC 07 5D 12      call _isalnum
0150+  13AF C6 96 14      jz is_alphanumeric
0151+  13B2             ; other token types
0152+  13B2             get_token_slash:
0153+  13B2 B9 2F         cmp al, '/'        ; check if '/'
0154+  13B4 C7 CC 13      jne get_token_minus
0155+  13B7 F7            stosb          ; store '/' into token string
0156+  13B8 19 00         mov al, 0
0157+  13BA F7            stosb          ; terminate token string
0158+  13BB 19 01         mov al, TOK_FSLASH
0159+  13BD 3D 27 15      mov [tok], al      
0160+  13C0 19 02         mov al, TOKTYP_DELIMITER
0161+  13C2 3D 26 15      mov [toktyp], al
0162+  13C5 4E            mov a, si
0163+  13C6 42 24 15      mov [prog], a    ; update pointer
0164+  13C9 0A B2 14      jmp get_token_return
0165+  13CC             get_token_minus:
0166+  13CC B9 2D         cmp al, '-'        ; check if '-'
0167+  13CE C7 E6 13      jne get_token_comma
0168+  13D1 F7            stosb          ; store '-' into token string
0169+  13D2 19 00         mov al, 0
0170+  13D4 F7            stosb          ; terminate token string
0171+  13D5 19 04         mov al, TOK_MINUS
0172+  13D7 3D 27 15      mov [tok], al      
0173+  13DA 19 02         mov al, TOKTYP_DELIMITER
0174+  13DC 3D 26 15      mov [toktyp], al
0175+  13DF 4E            mov a, si
0176+  13E0 42 24 15      mov [prog], a    ; update pointer
0177+  13E3 0A B2 14      jmp get_token_return
0178+  13E6             get_token_comma:
0179+  13E6 B9 2C         cmp al, ','        ; check if ','
0180+  13E8 C7 00 14      jne get_token_semi
0181+  13EB F7            stosb          ; store ',' into token string
0182+  13EC 19 00         mov al, 0
0183+  13EE F7            stosb          ; terminate token string
0184+  13EF 19 0B         mov al, TOK_COMMA
0185+  13F1 3D 27 15      mov [tok], al      
0186+  13F4 19 02         mov al, TOKTYP_DELIMITER
0187+  13F6 3D 26 15      mov [toktyp], al
0188+  13F9 4E            mov a, si
0189+  13FA 42 24 15      mov [prog], a    ; update pointer
0190+  13FD 0A B2 14      jmp get_token_return
0191+  1400             get_token_semi:
0192+  1400 B9 3B         cmp al, $3B        ; check if ';'
0193+  1402 C7 1A 14      jne get_token_colon
0194+  1405 F7            stosb          ; store ';' into token string
0195+  1406 19 00         mov al, 0
0196+  1408 F7            stosb          ; terminate token string
0197+  1409 19 06         mov al, TOK_SEMI
0198+  140B 3D 27 15      mov [tok], al      
0199+  140E 19 02         mov al, TOKTYP_DELIMITER
0200+  1410 3D 26 15      mov [toktyp], al
0201+  1413 4E            mov a, si
0202+  1414 42 24 15      mov [prog], a    ; update pointer
0203+  1417 0A B2 14      jmp get_token_return
0204+  141A             get_token_colon:
0205+  141A B9 3A         cmp al, $3A        ; check if ':'
0206+  141C C7 34 14      jne get_token_angle
0207+  141F F7            stosb          ; store ':' into token string
0208+  1420 19 00         mov al, 0
0209+  1422 F7            stosb          ; terminate token string
0210+  1423 19 0A         mov al, TOK_COLON
0211+  1425 3D 27 15      mov [tok], al      
0212+  1428 19 02         mov al, TOKTYP_DELIMITER
0213+  142A 3D 26 15      mov [toktyp], al
0214+  142D 4E            mov a, si
0215+  142E 42 24 15      mov [prog], a    ; update pointer
0216+  1431 0A B2 14      jmp get_token_return
0217+  1434             get_token_angle:
0218+  1434 B9 3E         cmp al, $3E        ; check if '>'
0219+  1436 C7 4E 14      jne get_token_tilde
0220+  1439 F7            stosb          ; store '>' into token string
0221+  143A 19 00         mov al, 0
0222+  143C F7            stosb          ; terminate token string
0223+  143D 19 07         mov al, TOK_ANGLE
0224+  143F 3D 27 15      mov [tok], al      
0225+  1442 19 02         mov al, TOKTYP_DELIMITER
0226+  1444 3D 26 15      mov [toktyp], al
0227+  1447 4E            mov a, si
0228+  1448 42 24 15      mov [prog], a    ; update pointer
0229+  144B 0A B2 14      jmp get_token_return
0230+  144E             get_token_tilde:
0231+  144E B9 7E         cmp al, '~'        ; check if '~'
0232+  1450 C7 68 14      jne get_token_equal
0233+  1453 F7            stosb          ; store '~' into token string
0234+  1454 19 00         mov al, 0
0235+  1456 F7            stosb          ; terminate token string
0236+  1457 19 08         mov al, TOK_TILDE
0237+  1459 3D 27 15      mov [tok], al      
0238+  145C 19 02         mov al, TOKTYP_DELIMITER
0239+  145E 3D 26 15      mov [toktyp], al
0240+  1461 4E            mov a, si
0241+  1462 42 24 15      mov [prog], a    ; update pointer
0242+  1465 0A B2 14      jmp get_token_return
0243+  1468             get_token_equal:
0244+  1468 B9 3D         cmp al, '='        ; check if '='
0245+  146A C7 82 14      jne get_token_skip
0246+  146D F7            stosb          ; store '=' into token string
0247+  146E 19 00         mov al, 0
0248+  1470 F7            stosb          ; terminate token string
0249+  1471 19 09         mov al, TOK_EQUAL
0250+  1473 3D 27 15      mov [tok], al      
0251+  1476 19 02         mov al, TOKTYP_DELIMITER
0252+  1478 3D 26 15      mov [toktyp], al
0253+  147B 4E            mov a, si
0254+  147C 42 24 15      mov [prog], a    ; update pointer
0255+  147F 0A B2 14      jmp get_token_return
0256+  1482             get_token_skip:
0257+  1482 4E            mov a, si
0258+  1483 42 24 15      mov [prog], a    ; update pointer
0259+  1486 0A B2 14      jmp get_token_return
0260+  1489             get_token_end:        ; end of file token
0261+  1489 19 14         mov al, TOK_END
0262+  148B 3D 27 15      mov [tok], al
0263+  148E 19 06         mov al, TOKTYP_END
0264+  1490 3D 26 15      mov [toktyp], al
0265+  1493 0A B2 14      jmp get_token_return
0266+  1496             is_alphanumeric:
0267+  1496 F7            stosb
0268+  1497 F6            lodsb
0269+  1498 07 5D 12      call _isalnum      ;check if is alphanumeric
0270+  149B C6 96 14      jz is_alphanumeric
0271+  149E B9 2E         cmp al, $2E        ; check if is '.'
0272+  14A0 C6 96 14      je is_alphanumeric
0273+  14A3 19 00         mov al, 0
0274+  14A5 F7            stosb
0275+  14A6 19 00         mov al, TOKTYP_IDENTIFIER
0276+  14A8 3D 26 15      mov [toktyp], al
0277+  14AB D5 01 00      sub si, 1
0278+  14AE 4E            mov a, si
0279+  14AF 42 24 15      mov [prog], a    ; update pointer
0280+  14B2             get_token_return:
0281+  14B2 F0            pop di
0282+  14B3 EF            pop si
0283+  14B4 E7            pop d
0284+  14B5 E4            pop a
0285+  14B6 09            ret
0286+  14B7             get_tok_comment:
0287+  14B7 F6            lodsb
0288+  14B8 B9 0A         cmp al, $0A      ; new line
0289+  14BA C7 B7 14      jne get_tok_comment
0290+  14BD 0A 9B 13      jmp get_tok_skip_spaces
0291+  14C0             
0292+  14C0             
0293+  14C0             get_number:
0294+  14C0 D7            push a
0295+  14C1 DA            push d
0296+  14C2 E2            push si
0297+  14C3 E3            push di
0298+  14C4 19 00         mov al, 0
0299+  14C6 3D 28 15      mov [tokstr], al      ; nullify tokstr string
0300+  14C9 19 00         mov al, TOK_NULL
0301+  14CB 3D 27 15      mov [tok], al        ; nullify token
0302+  14CE 14 24 15      mov a, [prog]
0303+  14D1 4D            mov si, a
0304+  14D2 FD 4F 28 15   mov di, tokstr
0305+  14D6             get_number_skip_spaces:
0306+  14D6 F6            lodsb
0307+  14D7 07 D3 12      call _isspace
0308+  14DA C6 D6 14      je get_number_skip_spaces
0309+  14DD B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  14DF C7 EF 14      jne get_number_L0
0311+  14E2 19 14         mov al, TOK_END
0312+  14E4 3D 27 15      mov [tok], al
0313+  14E7 19 06         mov al, TOKTYP_END
0314+  14E9 3D 26 15      mov [toktyp], al
0315+  14EC 0A 06 15      jmp get_number_return
0316+  14EF             get_number_L0:
0317+  14EF F7            stosb
0318+  14F0 F6            lodsb
0319+  14F1 07 67 12      call _isdigit      ;check if is numeric
0320+  14F4 C6 EF 14      jz get_number_L0
0321+  14F7 19 00         mov al, 0
0322+  14F9 F7            stosb
0323+  14FA 19 05         mov al, TOKTYP_NUMERIC
0324+  14FC 3D 26 15      mov [toktyp], al
0325+  14FF D5 01 00      sub si, 1
0326+  1502 4E            mov a, si
0327+  1503 42 24 15      mov [prog], a    ; update pointer
0328+  1506             get_number_return:
0329+  1506 F0            pop di
0330+  1507 EF            pop si
0331+  1508 E7            pop d
0332+  1509 E4            pop a
0333+  150A 09            ret
0334+  150B             
0335+  150B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  150B             ;; PUT BACK TOKEN
0337+  150B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  150B             _putback:
0339+  150B D7            push a
0340+  150C E2            push si
0341+  150D FD 4D 28 15   mov si, tokstr  
0342+  1511             _putback_loop:
0343+  1511 F6            lodsb
0344+  1512 B9 00         cmp al, 0
0345+  1514 C6 21 15      je _putback_end
0346+  1517 14 24 15      mov a, [prog]
0347+  151A 7D            dec a
0348+  151B 42 24 15      mov [prog], a      ; update pointer
0349+  151E 0A 11 15      jmp _putback_loop
0350+  1521             _putback_end:
0351+  1521 EF            pop si
0352+  1522 E4            pop a
0353+  1523 09            ret
0354+  1524             
0355+  1524             
0356+  1524             
0357+  1524             
0358+  1524 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1526             
0360+  1526 00          toktyp:    .db 0          ; token type symbol
0361+  1527 00          tok:       .db 0          ; current token symbol
0362+  1528 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  152C 00 00 00 00 
0362+  1530 00 00 00 00 
0362+  1534 00 00 00 00 
0362+  1538 00 00 00 00 
0362+  153C 00 00 00 00 
0362+  1540 00 00 00 00 
0362+  1544 00 00 00 00 
0362+  1548 00 00 00 00 
0362+  154C 00 00 00 00 
0362+  1550 00 00 00 00 
0362+  1554 00 00 00 00 
0362+  1558 00 00 00 00 
0362+  155C 00 00 00 00 
0362+  1560 00 00 00 00 
0362+  1564 00 00 00 00 
0362+  1568 00 00 00 00 
0362+  156C 00 00 00 00 
0362+  1570 00 00 00 00 
0362+  1574 00 00 00 00 
0362+  1578 00 00 00 00 
0362+  157C 00 00 00 00 
0362+  1580 00 00 00 00 
0362+  1584 00 00 00 00 
0362+  1588 00 00 00 00 
0362+  158C 00 00 00 00 
0362+  1590 00 00 00 00 
0362+  1594 00 00 00 00 
0362+  1598 00 00 00 00 
0362+  159C 00 00 00 00 
0362+  15A0 00 00 00 00 
0362+  15A4 00 00 00 00 
0362+  15A8 00 00 00 00 
0362+  15AC 00 00 00 00 
0362+  15B0 00 00 00 00 
0362+  15B4 00 00 00 00 
0362+  15B8 00 00 00 00 
0362+  15BC 00 00 00 00 
0362+  15C0 00 00 00 00 
0362+  15C4 00 00 00 00 
0362+  15C8 00 00 00 00 
0362+  15CC 00 00 00 00 
0362+  15D0 00 00 00 00 
0362+  15D4 00 00 00 00 
0362+  15D8 00 00 00 00 
0362+  15DC 00 00 00 00 
0362+  15E0 00 00 00 00 
0362+  15E4 00 00 00 00 
0362+  15E8 00 00 00 00 
0362+  15EC 00 00 00 00 
0362+  15F0 00 00 00 00 
0362+  15F4 00 00 00 00 
0362+  15F8 00 00 00 00 
0362+  15FC 00 00 00 00 
0362+  1600 00 00 00 00 
0362+  1604 00 00 00 00 
0362+  1608 00 00 00 00 
0362+  160C 00 00 00 00 
0362+  1610 00 00 00 00 
0362+  1614 00 00 00 00 
0362+  1618 00 00 00 00 
0362+  161C 00 00 00 00 
0362+  1620 00 00 00 00 
0362+  1624 00 00 00 00 
2421   1628             
2422   1628             ; Kernel parameters
2423   1628 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2424   1629 01          sys_echo_on:        .db 1
2425   162A 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2426   162B 01          sys_uart0_inten:    .db 1
2427   162C 00          sys_uart0_fifoen:   .db 0
2428   162D 0C          sys_uart0_div0:     .db 12  ;
2429   162E 00          sys_uart0_div1:     .db 0   ; default baud = 9600
2430   162F             
2431   162F 00          nbr_active_procs:   .db 0
2432   1630 01          active_proc_index:  .db 1
2433   1631             
2434   1631 00 00       index:              .dw 0
2435   1633 00 00       buffer_addr:        .dw 0
2436   1635             
2437   1635 24 1D       fifo_in:            .dw fifo
2438   1637 24 1D       fifo_out:           .dw fifo
2439   1639             
2440   1639             ; file system variables
2441   1639 00 00       current_dirID:      .dw 0     ; keep dirID of current directory
2442   163B 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2442   163F 6E 2F 69 6E 
2442   1643 69 74 00 
2443   1646             
2444   1646 2E 2E 00    s_parent_dir:       .db "..", 0
2445   1649 2E 00       s_current_dir:      .db ".", 0
2446   164B 2F 00       s_fslash:           .db "/", 0
2447   164D 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2447   1651 78 
2448   1652 2D 64 63    file_type:          .db "-dc"
2449   1655 50 49 44 20 s_ps_header:        .db "PID COMMAND\n", 0
2449   1659 43 4F 4D 4D 
2449   165D 41 4E 44 0A 
2449   1661 00 
2450   1662 54 6F 74 61 s_ls_total:         .db "Total: ", 0
2450   1666 6C 3A 20 00 
2451   166A             
2452   166A 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2452   166E 20 65 6E 61 
2452   1672 62 6C 65 64 
2452   1676 0A 00 
2453   1678 6B 65 72 6E s_kernel_started:   .db "kernel started\n", 0
2453   167C 65 6C 20 73 
2453   1680 74 61 72 74 
2453   1684 65 64 0A 00 
2454   1688 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2454   168C 74 69 6E 67 
2454   1690 20 69 6E 69 
2454   1694 74 0A 00 
2455   1697 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2455   169B 65 70 74 69 
2455   169F 6F 6E 3A 20 
2455   16A3 70 72 69 76 
2455   16A7 69 6C 65 67 
2455   16AB 65 0A 00 
2456   16AE 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2456   16B2 65 70 74 69 
2456   16B6 6F 6E 3A 20 
2456   16BA 7A 65 72 6F 
2456   16BE 20 64 69 76 
2456   16C2 69 73 69 6F 
2456   16C6 6E 0A 00 
2457   16C9             
2458   16C9 59 65 61 72 s_set_year:         .db "Year: ", 0
2458   16CD 3A 20 00 
2459   16D0 4D 6F 6E 74 s_set_month:        .db "Month: ", 0
2459   16D4 68 3A 20 00 
2460   16D8 44 61 79 3A s_set_day:          .db "Day: ", 0
2460   16DC 20 00 
2461   16DE 57 65 65 6B s_set_week:         .db "Weekday: ", 0
2461   16E2 64 61 79 3A 
2461   16E6 20 00 
2462   16E8 48 6F 75 72 s_set_hours:        .db "Hours: ", 0
2462   16EC 73 3A 20 00 
2463   16F0 4D 69 6E 75 s_set_minutes:      .db "Minutes: ", 0
2463   16F4 74 65 73 3A 
2463   16F8 20 00 
2464   16FA 53 65 63 6F s_set_seconds:      .db "Seconds: ", 0
2464   16FE 6E 64 73 3A 
2464   1702 20 00 
2465   1704             s_months:      
2466   1704 20 20 20 00   .db "   ", 0
2467   1708 4A 61 6E 00   .db "Jan", 0
2468   170C 46 65 62 00   .db "Feb", 0
2469   1710 4D 61 72 00   .db "Mar", 0
2470   1714 41 70 72 00   .db "Apr", 0
2471   1718 4D 61 79 00   .db "May", 0
2472   171C 4A 75 6E 00   .db "Jun", 0
2473   1720 4A 75 6C 00   .db "Jul", 0
2474   1724 41 75 67 00   .db "Aug", 0
2475   1728 53 65 70 00   .db "Sep", 0
2476   172C 4F 63 74 00   .db "Oct", 0
2477   1730 4E 6F 76 00   .db "Nov", 0
2478   1734 44 65 63 00   .db "Dec", 0
2479   1738             
2480   1738             s_week:        
2481   1738 53 75 6E 00   .db "Sun", 0 
2482   173C 4D 6F 6E 00   .db "Mon", 0 
2483   1740 54 75 65 00   .db "Tue", 0 
2484   1744 57 65 64 00   .db "Wed", 0 
2485   1748 54 68 75 00   .db "Thu", 0 
2486   174C 46 72 69 00   .db "Fri", 0 
2487   1750 53 61 74 00   .db "Sat", 0
2488   1754             
2489   1754 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2489   1758 00 00 00 00 
2489   175C 00 00 00 00 
2489   1760 00 00 00 00 
2489   1764 00 00 00 00 
2489   1768 00 00 00 00 
2489   176C 00 00 00 00 
2489   1770 00 00 00 00 
2489   1774 00 00 00 00 
2489   1778 00 00 00 00 
2489   177C 00 00 00 00 
2489   1780 00 00 00 00 
2489   1784 00 00 00 00 
2489   1788 00 00 00 00 
2489   178C 00 00 00 00 
2489   1790 00 00 00 00 
2489   1794 00 00 00 00 
2489   1798 00 00 00 00 
2489   179C 00 00 00 00 
2489   17A0 00 00 00 00 
2489   17A4 00 00 00 00 
2489   17A8 00 00 00 00 
2489   17AC 00 00 00 00 
2489   17B0 00 00 00 00 
2489   17B4 00 00 00 00 
2489   17B8 00 00 00 00 
2489   17BC 00 00 00 00 
2489   17C0 00 00 00 00 
2489   17C4 00 00 00 00 
2489   17C8 00 00 00 00 
2489   17CC 00 00 00 00 
2489   17D0 00 00 00 00 
2489   17D4 00 00 00 00 
2489   17D8 00 00 00 00 
2489   17DC 00 00 00 00 
2489   17E0 00 00 00 00 
2489   17E4 00 00 00 00 
2489   17E8 00 00 00 00 
2489   17EC 00 00 00 00 
2489   17F0 00 00 00 00 
2489   17F4 00 00 00 00 
2489   17F8 00 00 00 00 
2489   17FC 00 00 00 00 
2489   1800 00 00 00 00 
2489   1804 00 00 00 00 
2489   1808 00 00 00 00 
2489   180C 00 00 00 00 
2489   1810 00 00 00 00 
2489   1814 00 00 00 00 
2489   1818 00 00 00 00 
2489   181C 00 00 00 00 
2489   1820 00 00 00 00 
2489   1824 00 00 00 00 
2489   1828 00 00 00 00 
2489   182C 00 00 00 00 
2489   1830 00 00 00 00 
2489   1834 00 00 00 00 
2489   1838 00 00 00 00 
2489   183C 00 00 00 00 
2489   1840 00 00 00 00 
2489   1844 00 00 00 00 
2489   1848 00 00 00 00 
2489   184C 00 00 00 00 
2489   1850 00 00 00 00 
2489   1854 00 00 00 00 
2489   1858 00 00 00 00 
2489   185C 00 00 00 00 
2489   1860 00 00 00 00 
2489   1864 00 00 00 00 
2489   1868 00 00 00 00 
2489   186C 00 00 00 00 
2489   1870 00 00 00 00 
2489   1874 00 00 00 00 
2489   1878 00 00 00 00 
2489   187C 00 00 00 00 
2489   1880 00 00 00 00 
2489   1884 00 00 00 00 
2489   1888 00 00 00 00 
2489   188C 00 00 00 00 
2489   1890 00 00 00 00 
2490   1894 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2490   1898 00 00 00 00 
2490   189C 00 00 00 00 
2490   18A0 00 00 00 00 
2491   18A4 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2491   18A8 00 00 00 00 
2491   18AC 00 00 00 00 
2491   18B0 00 00 00 00 
2491   18B4 00 00 00 00 
2491   18B8 00 00 00 00 
2491   18BC 00 00 00 00 
2491   18C0 00 00 00 00 
2491   18C4 00 00 00 00 
2491   18C8 00 00 00 00 
2491   18CC 00 00 00 00 
2491   18D0 00 00 00 00 
2491   18D4 00 00 00 00 
2491   18D8 00 00 00 00 
2491   18DC 00 00 00 00 
2491   18E0 00 00 00 00 
2491   18E4 00 00 00 00 
2491   18E8 00 00 00 00 
2491   18EC 00 00 00 00 
2491   18F0 00 00 00 00 
2491   18F4 00 00 00 00 
2491   18F8 00 00 00 00 
2491   18FC 00 00 00 00 
2491   1900 00 00 00 00 
2491   1904 00 00 00 00 
2491   1908 00 00 00 00 
2491   190C 00 00 00 00 
2491   1910 00 00 00 00 
2491   1914 00 00 00 00 
2491   1918 00 00 00 00 
2491   191C 00 00 00 00 
2491   1920 00 00 00 00 
2491   1924 00 00 00 00 
2491   1928 00 00 00 00 
2491   192C 00 00 00 00 
2491   1930 00 00 00 00 
2491   1934 00 00 00 00 
2491   1938 00 00 00 00 
2491   193C 00 00 00 00 
2491   1940 00 00 00 00 
2491   1944 00 00 00 00 
2491   1948 00 00 00 00 
2491   194C 00 00 00 00 
2491   1950 00 00 00 00 
2491   1954 00 00 00 00 
2491   1958 00 00 00 00 
2491   195C 00 00 00 00 
2491   1960 00 00 00 00 
2491   1964 00 00 00 00 
2491   1968 00 00 00 00 
2491   196C 00 00 00 00 
2491   1970 00 00 00 00 
2491   1974 00 00 00 00 
2491   1978 00 00 00 00 
2491   197C 00 00 00 00 
2491   1980 00 00 00 00 
2491   1984 00 00 00 00 
2491   1988 00 00 00 00 
2491   198C 00 00 00 00 
2491   1990 00 00 00 00 
2491   1994 00 00 00 00 
2491   1998 00 00 00 00 
2491   199C 00 00 00 00 
2491   19A0 00 00 00 00 
2491   19A4 00 00 00 00 
2491   19A8 00 00 00 00 
2491   19AC 00 00 00 00 
2491   19B0 00 00 00 00 
2491   19B4 00 00 00 00 
2491   19B8 00 00 00 00 
2491   19BC 00 00 00 00 
2491   19C0 00 00 00 00 
2491   19C4 00 00 00 00 
2491   19C8 00 00 00 00 
2491   19CC 00 00 00 00 
2491   19D0 00 00 00 00 
2491   19D4 00 00 00 00 
2491   19D8 00 00 00 00 
2491   19DC 00 00 00 00 
2491   19E0 00 00 00 00 
2491   19E4 00 00 00 00 
2491   19E8 00 00 00 00 
2491   19EC 00 00 00 00 
2491   19F0 00 00 00 00 
2491   19F4 00 00 00 00 
2491   19F8 00 00 00 00 
2491   19FC 00 00 00 00 
2491   1A00 00 00 00 00 
2491   1A04 00 00 00 00 
2491   1A08 00 00 00 00 
2491   1A0C 00 00 00 00 
2491   1A10 00 00 00 00 
2491   1A14 00 00 00 00 
2491   1A18 00 00 00 00 
2491   1A1C 00 00 00 00 
2491   1A20 00 00 00 00 
2491   1A24 00 00 00 00 
2491   1A28 00 00 00 00 
2491   1A2C 00 00 00 00 
2491   1A30 00 00 00 00 
2491   1A34 00 00 00 00 
2491   1A38 00 00 00 00 
2491   1A3C 00 00 00 00 
2491   1A40 00 00 00 00 
2491   1A44 00 00 00 00 
2491   1A48 00 00 00 00 
2491   1A4C 00 00 00 00 
2491   1A50 00 00 00 00 
2491   1A54 00 00 00 00 
2491   1A58 00 00 00 00 
2491   1A5C 00 00 00 00 
2491   1A60 00 00 00 00 
2491   1A64 00 00 00 00 
2491   1A68 00 00 00 00 
2491   1A6C 00 00 00 00 
2491   1A70 00 00 00 00 
2491   1A74 00 00 00 00 
2491   1A78 00 00 00 00 
2491   1A7C 00 00 00 00 
2491   1A80 00 00 00 00 
2491   1A84 00 00 00 00 
2491   1A88 00 00 00 00 
2491   1A8C 00 00 00 00 
2491   1A90 00 00 00 00 
2491   1A94 00 00 00 00 
2491   1A98 00 00 00 00 
2491   1A9C 00 00 00 00 
2491   1AA0 00 00 00 00 
2492   1AA4 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2492   1AA8 00 00 00 00 
2492   1AAC 00 00 00 00 
2492   1AB0 00 00 00 00 
2492   1AB4 00 00 00 00 
2492   1AB8 00 00 00 00 
2492   1ABC 00 00 00 00 
2492   1AC0 00 00 00 00 
2492   1AC4 00 00 00 00 
2492   1AC8 00 00 00 00 
2492   1ACC 00 00 00 00 
2492   1AD0 00 00 00 00 
2492   1AD4 00 00 00 00 
2492   1AD8 00 00 00 00 
2492   1ADC 00 00 00 00 
2492   1AE0 00 00 00 00 
2492   1AE4 00 00 00 00 
2492   1AE8 00 00 00 00 
2492   1AEC 00 00 00 00 
2492   1AF0 00 00 00 00 
2492   1AF4 00 00 00 00 
2492   1AF8 00 00 00 00 
2492   1AFC 00 00 00 00 
2492   1B00 00 00 00 00 
2492   1B04 00 00 00 00 
2492   1B08 00 00 00 00 
2492   1B0C 00 00 00 00 
2492   1B10 00 00 00 00 
2492   1B14 00 00 00 00 
2492   1B18 00 00 00 00 
2492   1B1C 00 00 00 00 
2492   1B20 00 00 00 00 
2493   1B24 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2493   1B28 00 00 00 00 
2493   1B2C 00 00 00 00 
2493   1B30 00 00 00 00 
2493   1B34 00 00 00 00 
2493   1B38 00 00 00 00 
2493   1B3C 00 00 00 00 
2493   1B40 00 00 00 00 
2493   1B44 00 00 00 00 
2493   1B48 00 00 00 00 
2493   1B4C 00 00 00 00 
2493   1B50 00 00 00 00 
2493   1B54 00 00 00 00 
2493   1B58 00 00 00 00 
2493   1B5C 00 00 00 00 
2493   1B60 00 00 00 00 
2493   1B64 00 00 00 00 
2493   1B68 00 00 00 00 
2493   1B6C 00 00 00 00 
2493   1B70 00 00 00 00 
2493   1B74 00 00 00 00 
2493   1B78 00 00 00 00 
2493   1B7C 00 00 00 00 
2493   1B80 00 00 00 00 
2493   1B84 00 00 00 00 
2493   1B88 00 00 00 00 
2493   1B8C 00 00 00 00 
2493   1B90 00 00 00 00 
2493   1B94 00 00 00 00 
2493   1B98 00 00 00 00 
2493   1B9C 00 00 00 00 
2493   1BA0 00 00 00 00 
2493   1BA4 00 00 00 00 
2493   1BA8 00 00 00 00 
2493   1BAC 00 00 00 00 
2493   1BB0 00 00 00 00 
2493   1BB4 00 00 00 00 
2493   1BB8 00 00 00 00 
2493   1BBC 00 00 00 00 
2493   1BC0 00 00 00 00 
2493   1BC4 00 00 00 00 
2493   1BC8 00 00 00 00 
2493   1BCC 00 00 00 00 
2493   1BD0 00 00 00 00 
2493   1BD4 00 00 00 00 
2493   1BD8 00 00 00 00 
2493   1BDC 00 00 00 00 
2493   1BE0 00 00 00 00 
2493   1BE4 00 00 00 00 
2493   1BE8 00 00 00 00 
2493   1BEC 00 00 00 00 
2493   1BF0 00 00 00 00 
2493   1BF4 00 00 00 00 
2493   1BF8 00 00 00 00 
2493   1BFC 00 00 00 00 
2493   1C00 00 00 00 00 
2493   1C04 00 00 00 00 
2493   1C08 00 00 00 00 
2493   1C0C 00 00 00 00 
2493   1C10 00 00 00 00 
2493   1C14 00 00 00 00 
2493   1C18 00 00 00 00 
2493   1C1C 00 00 00 00 
2493   1C20 00 00 00 00 
2493   1C24 00 00 00 00 
2493   1C28 00 00 00 00 
2493   1C2C 00 00 00 00 
2493   1C30 00 00 00 00 
2493   1C34 00 00 00 00 
2493   1C38 00 00 00 00 
2493   1C3C 00 00 00 00 
2493   1C40 00 00 00 00 
2493   1C44 00 00 00 00 
2493   1C48 00 00 00 00 
2493   1C4C 00 00 00 00 
2493   1C50 00 00 00 00 
2493   1C54 00 00 00 00 
2493   1C58 00 00 00 00 
2493   1C5C 00 00 00 00 
2493   1C60 00 00 00 00 
2493   1C64 00 00 00 00 
2493   1C68 00 00 00 00 
2493   1C6C 00 00 00 00 
2493   1C70 00 00 00 00 
2493   1C74 00 00 00 00 
2493   1C78 00 00 00 00 
2493   1C7C 00 00 00 00 
2493   1C80 00 00 00 00 
2493   1C84 00 00 00 00 
2493   1C88 00 00 00 00 
2493   1C8C 00 00 00 00 
2493   1C90 00 00 00 00 
2493   1C94 00 00 00 00 
2493   1C98 00 00 00 00 
2493   1C9C 00 00 00 00 
2493   1CA0 00 00 00 00 
2493   1CA4 00 00 00 00 
2493   1CA8 00 00 00 00 
2493   1CAC 00 00 00 00 
2493   1CB0 00 00 00 00 
2493   1CB4 00 00 00 00 
2493   1CB8 00 00 00 00 
2493   1CBC 00 00 00 00 
2493   1CC0 00 00 00 00 
2493   1CC4 00 00 00 00 
2493   1CC8 00 00 00 00 
2493   1CCC 00 00 00 00 
2493   1CD0 00 00 00 00 
2493   1CD4 00 00 00 00 
2493   1CD8 00 00 00 00 
2493   1CDC 00 00 00 00 
2493   1CE0 00 00 00 00 
2493   1CE4 00 00 00 00 
2493   1CE8 00 00 00 00 
2493   1CEC 00 00 00 00 
2493   1CF0 00 00 00 00 
2493   1CF4 00 00 00 00 
2493   1CF8 00 00 00 00 
2493   1CFC 00 00 00 00 
2493   1D00 00 00 00 00 
2493   1D04 00 00 00 00 
2493   1D08 00 00 00 00 
2493   1D0C 00 00 00 00 
2493   1D10 00 00 00 00 
2493   1D14 00 00 00 00 
2493   1D18 00 00 00 00 
2493   1D1C 00 00 00 00 
2493   1D20 00 00 00 00 
2494   1D24 FF FF FF FF fifo:               .fill FIFO_SIZE
2494   1D28 FF FF FF FF 
2494   1D2C FF FF FF FF 
2494   1D30 FF FF FF FF 
2494   1D34 FF FF FF FF 
2494   1D38 FF FF FF FF 
2494   1D3C FF FF FF FF 
2494   1D40 FF FF FF FF 
2494   1D44 FF FF FF FF 
2494   1D48 FF FF FF FF 
2494   1D4C FF FF FF FF 
2494   1D50 FF FF FF FF 
2494   1D54 FF FF FF FF 
2494   1D58 FF FF FF FF 
2494   1D5C FF FF FF FF 
2494   1D60 FF FF FF FF 
2494   1D64 FF FF FF FF 
2494   1D68 FF FF FF FF 
2494   1D6C FF FF FF FF 
2494   1D70 FF FF FF FF 
2494   1D74 FF FF FF FF 
2494   1D78 FF FF FF FF 
2494   1D7C FF FF FF FF 
2494   1D80 FF FF FF FF 
2494   1D84 FF FF FF FF 
2494   1D88 FF FF FF FF 
2494   1D8C FF FF FF FF 
2494   1D90 FF FF FF FF 
2494   1D94 FF FF FF FF 
2494   1D98 FF FF FF FF 
2494   1D9C FF FF FF FF 
2494   1DA0 FF FF FF FF 
2494   1DA4 FF FF FF FF 
2494   1DA8 FF FF FF FF 
2494   1DAC FF FF FF FF 
2494   1DB0 FF FF FF FF 
2494   1DB4 FF FF FF FF 
2494   1DB8 FF FF FF FF 
2494   1DBC FF FF FF FF 
2494   1DC0 FF FF FF FF 
2494   1DC4 FF FF FF FF 
2494   1DC8 FF FF FF FF 
2494   1DCC FF FF FF FF 
2494   1DD0 FF FF FF FF 
2494   1DD4 FF FF FF FF 
2494   1DD8 FF FF FF FF 
2494   1DDC FF FF FF FF 
2494   1DE0 FF FF FF FF 
2494   1DE4 FF FF FF FF 
2494   1DE8 FF FF FF FF 
2494   1DEC FF FF FF FF 
2494   1DF0 FF FF FF FF 
2494   1DF4 FF FF FF FF 
2494   1DF8 FF FF FF FF 
2494   1DFC FF FF FF FF 
2494   1E00 FF FF FF FF 
2494   1E04 FF FF FF FF 
2494   1E08 FF FF FF FF 
2494   1E0C FF FF FF FF 
2494   1E10 FF FF FF FF 
2494   1E14 FF FF FF FF 
2494   1E18 FF FF FF FF 
2494   1E1C FF FF FF FF 
2494   1E20 FF FF FF FF 
2494   1E24 FF FF FF FF 
2494   1E28 FF FF FF FF 
2494   1E2C FF FF FF FF 
2494   1E30 FF FF FF FF 
2494   1E34 FF FF FF FF 
2494   1E38 FF FF FF FF 
2494   1E3C FF FF FF FF 
2494   1E40 FF FF FF FF 
2494   1E44 FF FF FF FF 
2494   1E48 FF FF FF FF 
2494   1E4C FF FF FF FF 
2494   1E50 FF FF FF FF 
2494   1E54 FF FF FF FF 
2494   1E58 FF FF FF FF 
2494   1E5C FF FF FF FF 
2494   1E60 FF FF FF FF 
2494   1E64 FF FF FF FF 
2494   1E68 FF FF FF FF 
2494   1E6C FF FF FF FF 
2494   1E70 FF FF FF FF 
2494   1E74 FF FF FF FF 
2494   1E78 FF FF FF FF 
2494   1E7C FF FF FF FF 
2494   1E80 FF FF FF FF 
2494   1E84 FF FF FF FF 
2494   1E88 FF FF FF FF 
2494   1E8C FF FF FF FF 
2494   1E90 FF FF FF FF 
2494   1E94 FF FF FF FF 
2494   1E98 FF FF FF FF 
2494   1E9C FF FF FF FF 
2494   1EA0 FF FF FF FF 
2494   1EA4 FF FF FF FF 
2494   1EA8 FF FF FF FF 
2494   1EAC FF FF FF FF 
2494   1EB0 FF FF FF FF 
2494   1EB4 FF FF FF FF 
2494   1EB8 FF FF FF FF 
2494   1EBC FF FF FF FF 
2494   1EC0 FF FF FF FF 
2494   1EC4 FF FF FF FF 
2494   1EC8 FF FF FF FF 
2494   1ECC FF FF FF FF 
2494   1ED0 FF FF FF FF 
2494   1ED4 FF FF FF FF 
2494   1ED8 FF FF FF FF 
2494   1EDC FF FF FF FF 
2494   1EE0 FF FF FF FF 
2494   1EE4 FF FF FF FF 
2494   1EE8 FF FF FF FF 
2494   1EEC FF FF FF FF 
2494   1EF0 FF FF FF FF 
2494   1EF4 FF FF FF FF 
2494   1EF8 FF FF FF FF 
2494   1EFC FF FF FF FF 
2494   1F00 FF FF FF FF 
2494   1F04 FF FF FF FF 
2494   1F08 FF FF FF FF 
2494   1F0C FF FF FF FF 
2494   1F10 FF FF FF FF 
2494   1F14 FF FF FF FF 
2494   1F18 FF FF FF FF 
2494   1F1C FF FF FF FF 
2494   1F20 FF FF FF FF 
2494   1F24 FF FF FF FF 
2494   1F28 FF FF FF FF 
2494   1F2C FF FF FF FF 
2494   1F30 FF FF FF FF 
2494   1F34 FF FF FF FF 
2494   1F38 FF FF FF FF 
2494   1F3C FF FF FF FF 
2494   1F40 FF FF FF FF 
2494   1F44 FF FF FF FF 
2494   1F48 FF FF FF FF 
2494   1F4C FF FF FF FF 
2494   1F50 FF FF FF FF 
2494   1F54 FF FF FF FF 
2494   1F58 FF FF FF FF 
2494   1F5C FF FF FF FF 
2494   1F60 FF FF FF FF 
2494   1F64 FF FF FF FF 
2494   1F68 FF FF FF FF 
2494   1F6C FF FF FF FF 
2494   1F70 FF FF FF FF 
2494   1F74 FF FF FF FF 
2494   1F78 FF FF FF FF 
2494   1F7C FF FF FF FF 
2494   1F80 FF FF FF FF 
2494   1F84 FF FF FF FF 
2494   1F88 FF FF FF FF 
2494   1F8C FF FF FF FF 
2494   1F90 FF FF FF FF 
2494   1F94 FF FF FF FF 
2494   1F98 FF FF FF FF 
2494   1F9C FF FF FF FF 
2494   1FA0 FF FF FF FF 
2494   1FA4 FF FF FF FF 
2494   1FA8 FF FF FF FF 
2494   1FAC FF FF FF FF 
2494   1FB0 FF FF FF FF 
2494   1FB4 FF FF FF FF 
2494   1FB8 FF FF FF FF 
2494   1FBC FF FF FF FF 
2494   1FC0 FF FF FF FF 
2494   1FC4 FF FF FF FF 
2494   1FC8 FF FF FF FF 
2494   1FCC FF FF FF FF 
2494   1FD0 FF FF FF FF 
2494   1FD4 FF FF FF FF 
2494   1FD8 FF FF FF FF 
2494   1FDC FF FF FF FF 
2494   1FE0 FF FF FF FF 
2494   1FE4 FF FF FF FF 
2494   1FE8 FF FF FF FF 
2494   1FEC FF FF FF FF 
2494   1FF0 FF FF FF FF 
2494   1FF4 FF FF FF FF 
2494   1FF8 FF FF FF FF 
2494   1FFC FF FF FF FF 
2494   2000 FF FF FF FF 
2494   2004 FF FF FF FF 
2494   2008 FF FF FF FF 
2494   200C FF FF FF FF 
2494   2010 FF FF FF FF 
2494   2014 FF FF FF FF 
2494   2018 FF FF FF FF 
2494   201C FF FF FF FF 
2494   2020 FF FF FF FF 
2494   2024 FF FF FF FF 
2494   2028 FF FF FF FF 
2494   202C FF FF FF FF 
2494   2030 FF FF FF FF 
2494   2034 FF FF FF FF 
2494   2038 FF FF FF FF 
2494   203C FF FF FF FF 
2494   2040 FF FF FF FF 
2494   2044 FF FF FF FF 
2494   2048 FF FF FF FF 
2494   204C FF FF FF FF 
2494   2050 FF FF FF FF 
2494   2054 FF FF FF FF 
2494   2058 FF FF FF FF 
2494   205C FF FF FF FF 
2494   2060 FF FF FF FF 
2494   2064 FF FF FF FF 
2494   2068 FF FF FF FF 
2494   206C FF FF FF FF 
2494   2070 FF FF FF FF 
2494   2074 FF FF FF FF 
2494   2078 FF FF FF FF 
2494   207C FF FF FF FF 
2494   2080 FF FF FF FF 
2494   2084 FF FF FF FF 
2494   2088 FF FF FF FF 
2494   208C FF FF FF FF 
2494   2090 FF FF FF FF 
2494   2094 FF FF FF FF 
2494   2098 FF FF FF FF 
2494   209C FF FF FF FF 
2494   20A0 FF FF FF FF 
2494   20A4 FF FF FF FF 
2494   20A8 FF FF FF FF 
2494   20AC FF FF FF FF 
2494   20B0 FF FF FF FF 
2494   20B4 FF FF FF FF 
2494   20B8 FF FF FF FF 
2494   20BC FF FF FF FF 
2494   20C0 FF FF FF FF 
2494   20C4 FF FF FF FF 
2494   20C8 FF FF FF FF 
2494   20CC FF FF FF FF 
2494   20D0 FF FF FF FF 
2494   20D4 FF FF FF FF 
2494   20D8 FF FF FF FF 
2494   20DC FF FF FF FF 
2494   20E0 FF FF FF FF 
2494   20E4 FF FF FF FF 
2494   20E8 FF FF FF FF 
2494   20EC FF FF FF FF 
2494   20F0 FF FF FF FF 
2494   20F4 FF FF FF FF 
2494   20F8 FF FF FF FF 
2494   20FC FF FF FF FF 
2494   2100 FF FF FF FF 
2494   2104 FF FF FF FF 
2494   2108 FF FF FF FF 
2494   210C FF FF FF FF 
2494   2110 FF FF FF FF 
2494   2114 FF FF FF FF 
2494   2118 FF FF FF FF 
2494   211C FF FF FF FF 
2494   2120 FF FF FF FF 
2495   2124             
2496   2124 FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2496   2128 FF FF FF FF 
2496   212C FF FF FF FF 
2496   2130 FF FF FF FF 
2496   2134 FF FF FF FF 
2496   2138 FF FF FF FF 
2496   213C FF FF FF FF 
2496   2140 FF FF FF FF 
2496   2144 FF FF FF FF 
2496   2148 FF FF FF FF 
2496   214C FF FF FF FF 
2496   2150 FF FF FF FF 
2496   2154 FF FF FF FF 
2496   2158 FF FF FF FF 
2496   215C FF FF FF FF 
2496   2160 FF FF FF FF 
2496   2164 FF FF FF FF 
2496   2168 FF FF FF FF 
2496   216C FF FF FF FF 
2496   2170 FF FF FF FF 
2496   2174 FF FF FF FF 
2496   2178 FF FF FF FF 
2496   217C FF FF FF FF 
2496   2180 FF FF FF FF 
2496   2184 FF FF FF FF 
2496   2188 FF FF FF FF 
2496   218C FF FF FF FF 
2496   2190 FF FF FF FF 
2496   2194 FF FF FF FF 
2496   2198 FF FF FF FF 
2496   219C FF FF FF FF 
2496   21A0 FF FF FF FF 
2496   21A4 FF FF FF FF 
2496   21A8 FF FF FF FF 
2496   21AC FF FF FF FF 
2496   21B0 FF FF FF FF 
2496   21B4 FF FF FF FF 
2496   21B8 FF FF FF FF 
2496   21BC FF FF FF FF 
2496   21C0 FF FF FF FF 
2496   21C4 FF FF FF FF 
2496   21C8 FF FF FF FF 
2496   21CC FF FF FF FF 
2496   21D0 FF FF FF FF 
2496   21D4 FF FF FF FF 
2496   21D8 FF FF FF FF 
2496   21DC FF FF FF FF 
2496   21E0 FF FF FF FF 
2496   21E4 FF FF FF FF 
2496   21E8 FF FF FF FF 
2496   21EC FF FF FF FF 
2496   21F0 FF FF FF FF 
2496   21F4 FF FF FF FF 
2496   21F8 FF FF FF FF 
2496   21FC FF FF FF FF 
2496   2200 FF FF FF FF 
2496   2204 FF FF FF FF 
2496   2208 FF FF FF FF 
2496   220C FF FF FF FF 
2496   2210 FF FF FF FF 
2496   2214 FF FF FF FF 
2496   2218 FF FF FF FF 
2496   221C FF FF FF FF 
2496   2220 FF FF FF FF 
2496   2224 FF FF FF FF 
2496   2228 FF FF FF FF 
2496   222C FF FF FF FF 
2496   2230 FF FF FF FF 
2496   2234 FF FF FF FF 
2496   2238 FF FF FF FF 
2496   223C FF FF FF FF 
2496   2240 FF FF FF FF 
2496   2244 FF FF FF FF 
2496   2248 FF FF FF FF 
2496   224C FF FF FF FF 
2496   2250 FF FF FF FF 
2496   2254 FF FF FF FF 
2496   2258 FF FF FF FF 
2496   225C FF FF FF FF 
2496   2260 FF FF FF FF 
2496   2264 FF FF FF FF 
2496   2268 FF FF FF FF 
2496   226C FF FF FF FF 
2496   2270 FF FF FF FF 
2496   2274 FF FF FF FF 
2496   2278 FF FF FF FF 
2496   227C FF FF FF FF 
2496   2280 FF FF FF FF 
2496   2284 FF FF FF FF 
2496   2288 FF FF FF FF 
2496   228C FF FF FF FF 
2496   2290 FF FF FF FF 
2496   2294 FF FF FF FF 
2496   2298 FF FF FF FF 
2496   229C FF FF FF FF 
2496   22A0 FF FF FF FF 
2496   22A4 FF FF FF FF 
2496   22A8 FF FF FF FF 
2496   22AC FF FF FF FF 
2496   22B0 FF FF FF FF 
2496   22B4 FF FF FF FF 
2496   22B8 FF FF FF FF 
2496   22BC FF FF FF FF 
2496   22C0 FF FF FF FF 
2496   22C4 FF FF FF FF 
2496   22C8 FF FF FF FF 
2496   22CC FF FF FF FF 
2496   22D0 FF FF FF FF 
2496   22D4 FF FF FF FF 
2496   22D8 FF FF FF FF 
2496   22DC FF FF FF FF 
2496   22E0 FF FF FF FF 
2496   22E4 FF FF FF FF 
2496   22E8 FF FF FF FF 
2496   22EC FF FF FF FF 
2496   22F0 FF FF FF FF 
2496   22F4 FF FF FF FF 
2496   22F8 FF FF FF FF 
2496   22FC FF FF FF FF 
2496   2300 FF FF FF FF 
2496   2304 FF FF FF FF 
2496   2308 FF FF FF FF 
2496   230C FF FF FF FF 
2496   2310 FF FF FF FF 
2496   2314 FF FF FF FF 
2496   2318 FF FF FF FF 
2496   231C FF FF FF FF 
2496   2320 FF FF FF FF 
2497   2324 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2498   2325             
2499   2325             
2500   2325             .end
tasm: Number of errors = 0
