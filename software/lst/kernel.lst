0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             ; Memory Map
0005   0000             ; ------------------------------------------------------------------------------------------------------------------;
0006   0000             ; 0000    ROM BEGIN
0007   0000             ; ....
0008   0000             ; 7FFF    ROM END
0009   0000             ;
0010   0000             ; 8000    RAM begin
0011   0000             ; ....
0012   0000             ; F7FF    Stack root
0013   0000             ; ------------------------------------------------------------------------------------------------------------------;
0014   0000             ; I/O MAP
0015   0000             ; ------------------------------------------------------------------------------------------------------------------;
0016   0000             ; FF80    UART 0              (16550)
0017   0000             ; FF90    UART 1              (16550)
0018   0000             ; FFA0    RTC                 (M48T02)
0019   0000             ; FFB0    PIO 0               (8255)
0020   0000             ; FFC0    5.25" Floppy Drive Block
0021   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0022   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0023   0000             ;   - FFC2      FDC         (WD1770 Floppy Drive Controller) 
0024   0000             ;      
0025   0000             ; FFD0    IDE                 (Compact Flash / PATA)
0026   0000             ; FFE0    Timer               (8253)
0027   0000             ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             XON               .equ $11
0050   0000             XOFF              .equ $13
0051   0000             
0052   0000             _ide_BASE         .equ $FFD0            ; IDE BASE
0053   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0054   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0055   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0056   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0057   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0058   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0059   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0060   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0061   0000             
0062   0000             _7SEG_DISPLAY     .equ $FFB0            ; BIOS POST CODE HEX DISPLAY (2 DIGITS) (CONNECTED TO PIO A)
0063   0000             _BIOS_POST_CTRL   .equ $FFB3            ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0064   0000             _PIO_A            .equ $FFB0    
0065   0000             _PIO_B            .equ $FFB1
0066   0000             _PIO_C            .equ $FFB2
0067   0000             _PIO_CONTROL      .equ $FFB3            ; PIO CONTROL PORT
0068   0000             
0069   0000             _TIMER_C_0        .equ $FFE0            ; TIMER COUNTER 0
0070   0000             _TIMER_C_1        .equ $FFE1            ; TIMER COUNTER 1
0071   0000             _TIMER_C_2        .equ $FFE2            ; TIMER COUNTER 2
0072   0000             _TIMER_CTRL       .equ $FFE3            ; TIMER CONTROL REGISTER
0073   0000             
0074   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0075   0000             FIFO_SIZE         .equ 1024
0076   0000             
0077   0000             text_org          .equ $400
0078   0000             ; ------------------------------------------------------------------------------------------------------------------;
0079   0000             
0080   0000             
0081   0000             ; For the next iteration:
0082   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0083   0000             ; inode-table format:
0084   0000             ;  file-type(f, d)
0085   0000             ;  permissons
0086   0000             ;  link-count
0087   0000             ;  filesize
0088   0000             ;  time-stamps
0089   0000             ;  15 data block pointers
0090   0000             ;  single-indirect pointer
0091   0000             
0092   0000             ; FILE ENTRY ATTRIBUTES
0093   0000             ; filename (24)
0094   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0095   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0096   0000             ; size (2)             : filesize
0097   0000             ; day (1)           
0098   0000             ; month (1)
0099   0000             ; year (1)
0100   0000             ; packet size = 32 bytes  : total packet size in bytes
0101   0000             
0102   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0103   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0104   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0105   0000             FST_NBR_DIRECTORIES     .equ 64
0106   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0107   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0108   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0109   0000             FST_LBA_START           .equ 32
0110   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0111   0000             
0112   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0113   0000             FS_SECTORS_PER_FILE     .equ 32         ; the first sector is always a header with a NULL parameter (first byte)
0114   0000                                                     ; so that we know which blocks are free or taken
0115   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0116   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0117   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0118   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0119   0000             
0120   0000             root_id:                .equ FST_LBA_START
0121   0000             
0122   0000             ; ------------------------------------------------------------------------------------------------------------------;
0123   0000             ; GLOBAL SYSTEM VARIABLES
0124   0000             ; ------------------------------------------------------------------------------------------------------------------;
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; IRQ Table
0128   0000             ; Highest priority at lowest address
0129   0000             ; ------------------------------------------------------------------------------------------------------------------;
0130   0000 3A 00       .dw int_0_fdc
0131   0002 41 00       .dw int_1
0132   0004 42 00       .dw int_2
0133   0006 43 00       .dw int_3
0134   0008 44 00       .dw int_4
0135   000A 45 00       .dw int_5
0136   000C 57 00       .dw int_6
0137   000E A3 00       .dw int_7_uart0
0138   0010             
0139   0010             ; ------------------------------------------------------------------------------------------------------------------;
0140   0010             ; Reset Vector
0141   0010             ; ------------------------------------------------------------------------------------------------------------------;
0142   0010 97 0F       .dw kernel_reset_vector
0143   0012             
0144   0012             ; ------------------------------------------------------------------------------------------------------------------;
0145   0012             ; Exception Vector Table
0146   0012             ; Total of 7 entries, starting at address $0012
0147   0012             ; ------------------------------------------------------------------------------------------------------------------;
0148   0012 8F 01       .dw trap_privilege
0149   0014 AC 02       .dw trap_div_zero
0150   0016 B9 02       .dw trap_undef_opcode
0151   0018 00 00       .dw 0
0152   001A 00 00       .dw 0
0153   001C 00 00       .dw 0
0154   001E 00 00       .dw 0
0155   0020             
0156   0020             ; ------------------------------------------------------------------------------------------------------------------;
0157   0020             ; System Call Vector Table
0158   0020             ; Starts at address $0020
0159   0020             ; ------------------------------------------------------------------------------------------------------------------;
0160   0020 9B 01       .dw syscall_break
0161   0022 BA 02       .dw syscall_rtc
0162   0024 F4 03       .dw syscall_ide
0163   0026 CF 04       .dw syscall_io
0164   0028 8C 05       .dw syscall_file_system
0165   002A E4 0E       .dw syscall_create_proc
0166   002C 54 01       .dw syscall_list_procs
0167   002E EC 02       .dw syscall_datetime
0168   0030 10 01       .dw syscall_reboot
0169   0032 AE 0E       .dw syscall_pause_proc
0170   0034 1C 01       .dw syscall_resume_proc
0171   0036 6B 0E       .dw syscall_terminate_proc
0172   0038 E2 00       .dw syscall_system
0173   003A             
0174   003A             ; ------------------------------------------------------------------------------------------------------------------;
0175   003A             ; System Call Aliases
0176   003A             ; ------------------------------------------------------------------------------------------------------------------;
0177   003A             sys_break            .equ 0
0178   003A             sys_rtc              .equ 1
0179   003A             sys_ide              .equ 2
0180   003A             sys_io               .equ 3
0181   003A             sys_filesystem       .equ 4
0182   003A             sys_create_proc      .equ 5
0183   003A             sys_list_proc        .equ 6
0184   003A             sys_datetime         .equ 7
0185   003A             sys_reboot           .equ 8
0186   003A             sys_pause_proc       .equ 9
0187   003A             sys_resume_proc      .equ 10
0188   003A             sys_terminate_proc   .equ 11
0189   003A             sys_system           .equ 12
0190   003A             
0191   003A             ; ------------------------------------------------------------------------------------------------------------------;
0192   003A             ; Alias Exports
0193   003A             ; ------------------------------------------------------------------------------------------------------------------;
0194   003A             .export text_org
0195   003A             .export sys_break
0196   003A             .export sys_rtc
0197   003A             .export sys_ide
0198   003A             .export sys_io
0199   003A             .export sys_filesystem
0200   003A             .export sys_create_proc
0201   003A             .export sys_list_proc
0202   003A             .export sys_datetime
0203   003A             .export sys_reboot
0204   003A             .export sys_pause_proc
0205   003A             .export sys_resume_proc
0206   003A             .export sys_terminate_proc
0207   003A             .export sys_system
0208   003A             
0209   003A             ; ------------------------------------------------------------------------------------------------------------------;
0210   003A             ; IRQs' Code Block
0211   003A             ; ------------------------------------------------------------------------------------------------------------------;
0212   003A             ; 5.25" Floppy Drive Controller IRQ
0213   003A             int_0_fdc:
0214   003A 3B 46 00      mov d, s_fdc_irq
0215   003D 07 E1 11      call _puts
0216   0040 06            sysret
0217   0041             int_1:
0218   0041 06            sysret
0219   0042             int_2:
0220   0042 06            sysret
0221   0043             int_3:
0222   0043 06            sysret
0223   0044             int_4:
0224   0044 06            sysret
0225   0045             int_5:
0226   0045 06            sysret
0227   0046             
0228   0046 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
0228   004A 30 20 45 78 
0228   004E 65 63 75 74 
0228   0052 65 64 2E 0A 
0228   0056 00 
0229   0057             
0230   0057             ; ------------------------------------------------------------------------------------------------------------------;
0231   0057             ; Process Swapping
0232   0057             ; ------------------------------------------------------------------------------------------------------------------;
0233   0057             int_6:  
0234   0057 4B            pusha ; save all registers into kernel stack
0235   0058 22 00         mov ah, 0
0236   005A 1D 12 17      mov al, [active_proc_index]
0237   005D FD 99         shl a              ; x2
0238   005F B7 61 0F      mov a, [proc_table_convert + a]  ; get process state start index
0239   0062 4F            mov di, a
0240   0063 48            mov a, sp
0241   0064 77            inc a
0242   0065 4D            mov si, a
0243   0066 38 14 00      mov c, 20
0244   0069 FD F5         rep movsb          ; save process state!
0245   006B             ; restore kernel stack position to point before interrupt arrived
0246   006B 51 14 00      add sp, 20
0247   006E             ; now load next process in queue
0248   006E 1D 12 17      mov al, [active_proc_index]
0249   0071 31 11 17      mov bl, [nbr_active_procs]
0250   0074 BA            cmp al, bl
0251   0075 C6 7C 00      je int6_cycle_back
0252   0078 7A            inc al            ; next process is next in the series
0253   0079 0A 7E 00      jmp int6_continue
0254   007C             int6_cycle_back:
0255   007C 19 01         mov al, 1        ; next process = process 1
0256   007E             int6_continue:
0257   007E 3D 12 17      mov [active_proc_index], al    ; set next active proc
0258   0081             
0259   0081             ; calculate LUT entry for next process
0260   0081 22 00         mov ah, 0
0261   0083 FD 99         shl a              ; x2
0262   0085 B7 61 0F      mov a, [proc_table_convert + a]    ; get process state start index  
0263   0088               
0264   0088 4D            mov si, a            ; source is proc state block
0265   0089 48            mov a, sp
0266   008A 5F 13 00      sub a, 19
0267   008D 4F            mov di, a            ; destination is kernel stack
0268   008E             ; restore SP
0269   008E 7D            dec a
0270   008F 47            mov sp, a
0271   0090 38 14 00      mov c, 20
0272   0093 FD F5         rep movsb
0273   0095             ; set VM process
0274   0095 1D 12 17      mov al, [active_proc_index]
0275   0098 01            setptb
0276   0099 F2 E0 FF 00   mov byte[_TIMER_C_0], 0        ; load counter 0 low byte
0277   009D F2 E0 FF 10   mov byte[_TIMER_C_0], $10        ; load counter 0 high byte
0278   00A1 4C            popa
0279   00A2 06            sysret
0280   00A3             
0281   00A3             ; ------------------------------------------------------------------------------------------------------------------;
0282   00A3             ; UART0 Interrupt
0283   00A3             ; ------------------------------------------------------------------------------------------------------------------;
0284   00A3             int_7_uart0:
0285   00A3 D7            push a
0286   00A4 DA            push d
0287   00A5 E1            pushf
0288   00A6 14 17 17      mov a, [fifo_in]
0289   00A9 3C            mov d, a
0290   00AA 1D 80 FF      mov al, [_UART0_DATA]  ; get character
0291   00AD B9 03         cmp al, $03        ; CTRL-C
0292   00AF C6 CC 00      je CTRLC
0293   00B2 B9 1A         cmp al, $1A        ; CTRL-Z
0294   00B4 C6 D2 00      je CTRLZ
0295   00B7 3E            mov [d], al        ; add to fifo
0296   00B8 14 17 17      mov a, [fifo_in]
0297   00BB 77            inc a
0298   00BC AF 16 22      cmp a, fifo + FIFO_SIZE         ; check if pointer reached the end of the fifo
0299   00BF C7 C5 00      jne int_7_continue
0300   00C2 10 16 1E      mov a, fifo  
0301   00C5             int_7_continue:  
0302   00C5 42 17 17      mov [fifo_in], a      ; update fifo pointer
0303   00C8 EE            popf
0304   00C9 E7            pop d
0305   00CA E4            pop a  
0306   00CB 06            sysret
0307   00CC             CTRLC:
0308   00CC 51 05 00      add sp, 5
0309   00CF 0A 6B 0E      jmp syscall_terminate_proc
0310   00D2             CTRLZ:
0311   00D2 EE            popf
0312   00D3 E7            pop d
0313   00D4 E4            pop a
0314   00D5 0A AE 0E      jmp syscall_pause_proc    ; pause current process and go back to the shell
0315   00D8             
0316   00D8             
0317   00D8             
0318   00D8             ; ------------------------------------------------------------------------------------------------------------------;
0319   00D8             ; System Syscalls
0320   00D8             ; ------------------------------------------------------------------------------------------------------------------;
0321   00D8             system_jmptbl:
0322   00D8 0E 01         .dw system_uname
0323   00DA 0F 01         .dw system_whoami
0324   00DC 0B 01         .dw system_setparam
0325   00DE E8 00         .dw system_bootloader_install
0326   00E0 E6 00         .dw system_getparam
0327   00E2             syscall_system:
0328   00E2 FD 0A D8 00   jmp [system_jmptbl + al]
0329   00E6             
0330   00E6             ; param register address in register d
0331   00E6             ; param value in register bl
0332   00E6             system_getparam:
0333   00E6 32            mov bl, [d]
0334   00E7 06            sysret
0335   00E8             
0336   00E8             ; kernel LBA address in 'b'
0337   00E8             system_bootloader_install:
0338   00E8 D8            push b
0339   00E9 26 00 00      mov b, 0
0340   00EC 38 00 00      mov c, 0
0341   00EF 22 01         mov ah, $01                 ; 1 sector
0342   00F1 3B 16 24      mov d, transient_area
0343   00F4 07 3E 04      call ide_read_sect          ; read sector
0344   00F7 E5            pop b
0345   00F8 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0346   00FC 26 00 00      mov b, 0
0347   00FF 38 00 00      mov c, 0
0348   0102 22 01         mov ah, $01                 ; 1 sector
0349   0104 3B 16 24      mov d, transient_area
0350   0107 07 64 04      call ide_write_sect         ; write sector
0351   010A 06            sysret
0352   010B             
0353   010B             ; param register address in register d
0354   010B             ; param value in register bl
0355   010B             system_setparam:
0356   010B FD 3E         mov [d], bl
0357   010D 06            sysret
0358   010E             
0359   010E             system_uname:
0360   010E 06            sysret
0361   010F             
0362   010F             system_whoami:
0363   010F 06            sysret
0364   0110             
0365   0110             ; REBOOT SYSTEM
0366   0110             syscall_reboot:
0367   0110 FD D7 FF FF   push word $FFFF 
0368   0114 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0369   0117 FD D7 C0 01   push word BIOS_RESET_VECTOR    ; and then push RESET VECTOR of the shell to the stack
0370   011B 06            sysret
0371   011C             
0372   011C             ;------------------------------------------------------------------------------------------------------;;
0373   011C             ; switch to another process
0374   011C             ; inputs:
0375   011C             ; AL = new process number
0376   011C             ;------------------------------------------------------------------------------------------------------;;
0377   011C             syscall_resume_proc:
0378   011C FD 78         mov g, a                            ; save the process number
0379   011E 4B            pusha                               ; save all registers into kernel stack
0380   011F 22 00         mov ah, 0
0381   0121 1D 12 17      mov al, [active_proc_index]
0382   0124 FD 99         shl a              ; x2
0383   0126 B7 61 0F      mov a, [proc_table_convert + a]     ; get process state start index
0384   0129 4F            mov di, a
0385   012A 48            mov a, sp
0386   012B 77            inc a
0387   012C 4D            mov si, a
0388   012D 38 14 00      mov c, 20
0389   0130 FD F5         rep movsb                           ; save process state!
0390   0132             ; restore kernel stack position to point before interrupt arrived
0391   0132 51 14 00      add sp, 20
0392   0135             ; now load the new process number!
0393   0135 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0394   0137 3D 12 17      mov [active_proc_index], al         ; set new active proc
0395   013A             ; calculate LUT entry for next process
0396   013A 22 00         mov ah, 0
0397   013C FD 99         shl a                               ; x2
0398   013E B7 61 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0399   0141 4D            mov si, a                           ; source is proc state block
0400   0142 48            mov a, sp
0401   0143 5F 13 00      sub a, 19
0402   0146 4F            mov di, a                           ; destination is kernel stack
0403   0147             ; restore SP
0404   0147 7D            dec a
0405   0148 47            mov sp, a
0406   0149 38 14 00      mov c, 20
0407   014C FD F5         rep movsb
0408   014E             ; set VM process
0409   014E 1D 12 17      mov al, [active_proc_index]
0410   0151 01            setptb
0411   0152 4C            popa
0412   0153 06            sysret
0413   0154             
0414   0154             syscall_list_procs:
0415   0154 3B 3A 17      mov d, s_ps_header
0416   0157 07 E1 11      call _puts
0417   015A 3B 87 19      mov d, proc_availab_table + 1
0418   015D 38 01 00      mov c, 1
0419   0160             list_procs_L0:  
0420   0160 BD 01         cmp byte[d], 1
0421   0162 C7 86 01      jne list_procs_next
0422   0165 2D            mov b, d
0423   0166 61 86 19      sub b, proc_availab_table
0424   0169 FD 9F 05      shl b, 5
0425   016C DA            push d
0426   016D D8            push b
0427   016E 28            mov b, c
0428   016F 07 81 12      call print_u8x
0429   0172 22 20         mov ah, ' '
0430   0174 07 B5 10      call _putchar
0431   0177 07 B5 10      call _putchar
0432   017A E5            pop b
0433   017B 74            mov d, b
0434   017C 58 96 19      add d, proc_names
0435   017F 07 E1 11      call _puts
0436   0182 07 8E 11      call printnl
0437   0185 E7            pop d
0438   0186             list_procs_next:
0439   0186 79            inc d
0440   0187 78            inc c
0441   0188 C2 09 00      cmp c, 9
0442   018B C7 60 01      jne list_procs_L0
0443   018E             list_procs_end:
0444   018E 06            sysret
0445   018F             
0446   018F             ; ------------------------------------------------------------------------------------------------------------------;
0447   018F             ; Exceptions' Code Block
0448   018F             ; ------------------------------------------------------------------------------------------------------------------;
0449   018F             ; Privilege
0450   018F             ; ------------------------------------------------------------------------------------------------------------------;
0451   018F             trap_privilege:
0452   018F 0A 10 01      jmp syscall_reboot
0453   0192 DA            push d
0454   0193 3B 89 17      mov d, s_priviledge
0455   0196 07 E1 11      call _puts
0456   0199 E7            pop d
0457   019A 06            sysret
0458   019B             
0459   019B             ; ------------------------------------------------------------------------------------------------------------------;
0460   019B             ; Breakpoint
0461   019B             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0462   019B             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0463   019B             ; ------------------------------------------------------------------------------------------------------------------;
0464   019B             syscall_break:
0465   019B 4B            pusha
0466   019C             syscall_break_prompt:
0467   019C 3B 56 02      mov d, s_break1
0468   019F 07 E1 11      call _puts
0469   01A2 07 8E 11      call printnl
0470   01A5 07 E3 12      call scan_u16d
0471   01A8 AF 00 00      cmp a, 0
0472   01AB C6 B6 01      je syscall_break_regs
0473   01AE AF 01 00      cmp a, 1
0474   01B1 C6 D9 01      je syscall_break_mem
0475   01B4             syscall_break_end:  
0476   01B4 4C            popa
0477   01B5 06            sysret
0478   01B6             syscall_break_regs:
0479   01B6 48            mov a, sp
0480   01B7 53 0E 00      add a, 14               ; back-track 7 registers
0481   01BA 3C            mov d, a
0482   01BB 3A 07         mov cl, 7
0483   01BD             syscall_regs_L0:
0484   01BD 2A            mov b, [d]
0485   01BE FD AB         swp b
0486   01C0 07 3D 12      call print_u16x         ; print register value
0487   01C3 07 8E 11      call printnl
0488   01C6 63 02 00      sub d, 2
0489   01C9 71 01         sub cl, 1
0490   01CB C3 00         cmp cl, 0
0491   01CD C7 BD 01      jne syscall_regs_L0
0492   01D0 0A 9C 01      jmp syscall_break_prompt
0493   01D3 07 8E 11      call printnl
0494   01D6 0A 9C 01      jmp syscall_break_prompt
0495   01D9             syscall_break_mem:
0496   01D9 07 8E 11      call printnl
0497   01DC 07 5F 12      call scan_u16x
0498   01DF 4D            mov si, a               ; data source from user space
0499   01E0 FD 4F 16 22   mov di, scrap_sector    ; destination in kernel space
0500   01E4 38 00 02      mov c, 512
0501   01E7 04            load                    ; transfer data to kernel space!
0502   01E8 3B 16 22      mov d, scrap_sector     ; dump pointer in d
0503   01EB 38 00 00      mov c, 0
0504   01EE             dump_loop:
0505   01EE 84            mov al, cl
0506   01EF 87 0F         and al, $0F
0507   01F1 C6 3F 02      jz print_base
0508   01F4             back:
0509   01F4 1E            mov al, [d]             ; read byte
0510   01F5 2F            mov bl, al
0511   01F6 07 81 12      call print_u8x
0512   01F9 10 00 20      mov a, $2000
0513   01FC 05 03         syscall sys_io          ; space
0514   01FE 84            mov al, cl
0515   01FF 87 0F         and al, $0F
0516   0201 B9 0F         cmp al, $0F
0517   0203 C6 14 02      je print_ascii
0518   0206             back1:
0519   0206 79            inc d
0520   0207 78            inc c
0521   0208 C2 00 02      cmp c, 512
0522   020B C7 EE 01      jne dump_loop
0523   020E 07 8E 11      call printnl
0524   0211 0A 9C 01      jmp syscall_break_prompt  ; go to syscall_break return point
0525   0214             print_ascii:
0526   0214 10 00 20      mov a, $2000
0527   0217 05 03         syscall sys_io
0528   0219 63 10 00      sub d, 16
0529   021C 26 10 00      mov b, 16
0530   021F             print_ascii_L:
0531   021F 79            inc d
0532   0220 1E            mov al, [d]               ; read byte
0533   0221 B9 20         cmp al, $20
0534   0223 C8 2B 02      jlu dot
0535   0226 B9 7E         cmp al, $7E
0536   0228 D0 33 02      jleu ascii
0537   022B             dot:
0538   022B 10 00 2E      mov a, $2E00
0539   022E 05 03         syscall sys_io
0540   0230 0A 38 02      jmp ascii_continue
0541   0233             ascii:
0542   0233 23            mov ah, al
0543   0234 19 00         mov al, 0
0544   0236 05 03         syscall sys_io
0545   0238             ascii_continue:
0546   0238 FD A9 1F 02   loopb print_ascii_L
0547   023C 0A 06 02      jmp back1
0548   023F             print_base:
0549   023F 07 8E 11      call printnl
0550   0242 2D            mov b, d
0551   0243 61 16 22      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0552   0246 07 3D 12      call print_u16x          ; display row
0553   0249 10 00 3A      mov a, $3A00
0554   024C 05 03         syscall sys_io
0555   024E 10 00 20      mov a, $2000
0556   0251 05 03         syscall sys_io
0557   0253 0A F4 01      jmp back
0558   0256             
0559   0256             s_break1:  
0560   0256 0A 44 65 62   .db "\nDebugger entry point.\n"
0560   025A 75 67 67 65 
0560   025E 72 20 65 6E 
0560   0262 74 72 79 20 
0560   0266 70 6F 69 6E 
0560   026A 74 2E 0A 
0561   026D 30 2E 20 53   .db "0. Show Registers\n"
0561   0271 68 6F 77 20 
0561   0275 52 65 67 69 
0561   0279 73 74 65 72 
0561   027D 73 0A 
0562   027F 31 2E 20 53   .db "1. Show 512B RAM block\n"
0562   0283 68 6F 77 20 
0562   0287 35 31 32 42 
0562   028B 20 52 41 4D 
0562   028F 20 62 6C 6F 
0562   0293 63 6B 0A 
0563   0296 32 2E 20 43   .db "2. Continue Execution", 0
0563   029A 6F 6E 74 69 
0563   029E 6E 75 65 20 
0563   02A2 45 78 65 63 
0563   02A6 75 74 69 6F 
0563   02AA 6E 00 
0564   02AC             
0565   02AC             ; ------------------------------------------------------------------------------------------------------------------;
0566   02AC             ; Divide by Zero
0567   02AC             ; ------------------------------------------------------------------------------------------------------------------;
0568   02AC             trap_div_zero:
0569   02AC D7            push a
0570   02AD DA            push d
0571   02AE E1            pushf
0572   02AF 3B A0 17      mov d, s_divzero
0573   02B2 07 E1 11      call _puts
0574   02B5 EE            popf
0575   02B6 E7            pop d
0576   02B7 E4            pop a
0577   02B8 06            sysret ; enable interrupts
0578   02B9             
0579   02B9             ; ------------------------------------------------------------------------------------------------------------------;
0580   02B9             ; Undefined Opcode
0581   02B9             ; ------------------------------------------------------------------------------------------------------------------;
0582   02B9             trap_undef_opcode:
0583   02B9 06            sysret
0584   02BA             
0585   02BA             ; ------------------------------------------------------------------------------------------------------------------;
0586   02BA             ; RTC Services Syscall
0587   02BA             ; RTC I/O bank = FFA0 to FFAF
0588   02BA             ; FFA0 to FFA7 is scratch RAM
0589   02BA             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0590   02BA             ; al = 0..6 -> get
0591   02BA             ; al = 7..D -> set
0592   02BA             ; ------------------------------------------------------------------------------------------------------------------;
0593   02BA             syscall_rtc:
0594   02BA DB            push al
0595   02BB DA            push d
0596   02BC B9 06         cmp al, 6
0597   02BE D1 D3 02      jgu syscall_rtc_set
0598   02C1             syscall_rtc_get:
0599   02C1 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0600   02C3 22 FF         mov ah, $FF    
0601   02C5 3C            mov d, a                ; get to FFA9 + offset
0602   02C6 F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0603   02CA 1E            mov al, [d]             ; get data
0604   02CB F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0605   02CF 23            mov ah, al
0606   02D0 E7            pop d
0607   02D1 E8            pop al
0608   02D2 06            sysret
0609   02D3             syscall_rtc_set:
0610   02D3 DD            push bl
0611   02D4 99            mov bl, ah              ; set data asIDE
0612   02D5 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0613   02D7 22 FF         mov ah, $FF    
0614   02D9 3C            mov d, a                ; get to FFA9 + offset
0615   02DA 1B            mov al, bl              ; get data back
0616   02DB F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0617   02DF 3E            mov [d], al             ; set data
0618   02E0 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0619   02E4 EA            pop bl
0620   02E5 E7            pop d
0621   02E6 E8            pop al
0622   02E7 06            sysret
0623   02E8             
0624   02E8             datetime_serv_tbl:
0625   02E8 F0 02         .dw print_date
0626   02EA 64 03         .dw set_date
0627   02EC             syscall_datetime:
0628   02EC FD 0A E8 02   jmp [datetime_serv_tbl + al]      
0629   02F0             print_date:
0630   02F0 10 00 0D      mov a, $0D00           ; print carriage return char
0631   02F3 19 03         mov al, 3
0632   02F5 05 01         syscall sys_rtc        ; get week
0633   02F7 1A            mov al, ah
0634   02F8 22 00         mov ah, 0
0635   02FA FD 9D 02      shl a, 2          
0636   02FD 3B 2A 18      mov d, s_week
0637   0300 59            add d, a
0638   0301 07 E1 11      call _puts
0639   0304 10 00 20      mov a, $2000
0640   0307 05 03         syscall sys_io         ; display ' '
0641   0309 19 04         mov al, 4
0642   030B 05 01         syscall sys_rtc        ; get day
0643   030D 99            mov bl, ah
0644   030E 07 81 12      call print_u8x
0645   0311 10 00 20      mov a, $2000
0646   0314 05 03         syscall sys_io         ; display ' '
0647   0316             ; there is a problem with the month displaying
0648   0316             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0649   0316             ; even though it is to be understood as BCD.
0650   0316             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0651   0316 19 05         mov al, 05
0652   0318 05 01         syscall sys_rtc        ; get month
0653   031A 1A            mov al, ah
0654   031B 22 00         mov ah, 0
0655   031D FD 9D 02      shl a, 2          
0656   0320 3B F6 17      mov d, s_months
0657   0323 59            add d, a
0658   0324 07 E1 11      call _puts
0659   0327 10 00 20      mov a, $2000
0660   032A 05 03         syscall sys_io         ; display ' '
0661   032C 2E 20         mov bl, $20
0662   032E 07 81 12      call print_u8x         ; print 20 for year prefix
0663   0331 19 06         mov al, 06
0664   0333 05 01         syscall sys_rtc        ; get year
0665   0335 99            mov bl, ah
0666   0336 07 81 12      call print_u8x
0667   0339 10 00 20      mov a, $2000  
0668   033C 05 03         syscall sys_io         ; display ' '
0669   033E 19 02         mov al, 2
0670   0340 05 01         syscall sys_rtc        ; get hours
0671   0342 99            mov bl, ah
0672   0343 07 81 12      call print_u8x
0673   0346 10 00 3A      mov a, $3A00    
0674   0349 05 03         syscall sys_io         ; display ':'
0675   034B 19 01         mov al, 01
0676   034D 05 01         syscall sys_rtc        ; get minutes
0677   034F 99            mov bl, ah
0678   0350 07 81 12      call print_u8x
0679   0353 10 00 3A      mov a, $3A00  
0680   0356 05 03         syscall sys_io         ; display ':'
0681   0358 19 00         mov al, 0
0682   035A 05 01         syscall sys_rtc        ; get seconds
0683   035C 99            mov bl, ah
0684   035D 07 81 12      call print_u8x
0685   0360 07 8E 11      call printnl
0686   0363 06            sysret
0687   0364             set_date:
0688   0364 3B BB 17      mov d, s_set_year
0689   0367 07 E1 11      call _puts
0690   036A 07 CC 12      call scan_u8x          ; read integer into A
0691   036D FD 9D 08      shl a, 8               ; only AL used, move to AH
0692   0370 19 0D         mov al, 0Dh            ; set RTC year
0693   0372 05 01         syscall sys_rtc        ; set RTC
0694   0374 3B C2 17      mov d, s_set_month
0695   0377 07 E1 11      call _puts
0696   037A 07 CC 12      call scan_u8x          ; read integer into A
0697   037D FD 9D 08      shl a, 8               ; only AL used, move to AH
0698   0380 19 0C         mov al, 0Ch            ; set RTC month
0699   0382 05 01         syscall sys_rtc        ; set RTC
0700   0384 3B CA 17      mov d, s_set_day
0701   0387 07 E1 11      call _puts
0702   038A 07 CC 12      call scan_u8x          ; read integer into A
0703   038D FD 9D 08      shl a, 8               ; only AL used, move to AH
0704   0390 19 0B         mov al, 0Bh            ; set RTC month
0705   0392 05 01         syscall sys_rtc        ; set RTC
0706   0394 3B D0 17      mov d, s_set_week
0707   0397 07 E1 11      call _puts
0708   039A 07 CC 12      call scan_u8x          ; read integer into A
0709   039D FD 9D 08      shl a, 8               ; only AL used, move to AH
0710   03A0 19 0A         mov al, 0Ah            ; set RTC month
0711   03A2 05 01         syscall sys_rtc        ; set RTC
0712   03A4 3B DA 17      mov d, s_set_hours
0713   03A7 07 E1 11      call _puts
0714   03AA 07 CC 12      call scan_u8x          ; read integer into A
0715   03AD FD 9D 08      shl a, 8               ; only AL used, move to AH
0716   03B0 19 09         mov al, 09h            ; set RTC month
0717   03B2 05 01         syscall sys_rtc        ; set RTC
0718   03B4 3B E2 17      mov d, s_set_minutes
0719   03B7 07 E1 11      call _puts
0720   03BA 07 CC 12      call scan_u8x          ; read integer into A
0721   03BD FD 9D 08      shl a, 8               ; only AL used, move to AH
0722   03C0 19 08         mov al, 08h            ; set RTC month
0723   03C2 05 01         syscall sys_rtc        ; set RTC
0724   03C4 3B EC 17      mov d, s_set_seconds
0725   03C7 07 E1 11      call _puts
0726   03CA 07 CC 12      call scan_u8x          ; read integer into A
0727   03CD FD 9D 08      shl a, 8               ; only AL used, move to AH
0728   03D0 19 07         mov al, 07h            ; set RTC month
0729   03D2 05 01         syscall sys_rtc        ; set RTC
0730   03D4 06            sysret
0731   03D5             
0732   03D5             ; ------------------------------------------------------------------------------------------------------------------;
0733   03D5             ; IDE Services Syscall
0734   03D5             ; al = option
0735   03D5             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0736   03D5             ; IDE read/write sector
0737   03D5             ; 512 bytes
0738   03D5             ; User buffer pointer in D
0739   03D5             ; AH = number of sectors
0740   03D5             ; CB = LBA bytes 3..0
0741   03D5             ; ------------------------------------------------------------------------------------------------------------------;
0742   03D5 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0742   03D9 73 63 61 6C 
0742   03DD 6C 5F 69 64 
0742   03E1 65 20 63 61 
0742   03E5 6C 6C 65 64 
0742   03E9 3A 20 00 
0743   03EC             ide_serv_tbl:
0744   03EC 13 04         .dw ide_reset
0745   03EE 27 04         .dw ide_sleep
0746   03F0 36 04         .dw ide_read_sect_wrapper
0747   03F2 3A 04         .dw ide_write_sect_wrapper
0748   03F4             syscall_ide:
0749   03F4 DD            push bl
0750   03F5 31 0A 17      mov bl, [sys_debug_mode]
0751   03F8               ; debug block
0752   03F8 C1 00         cmp bl, 0
0753   03FA EA            pop bl
0754   03FB C6 0F 04      je syscall_ide_jmp
0755   03FE DA            push d
0756   03FF DD            push bl
0757   0400 3B D5 03      mov d, s_syscall_ide_dbg0
0758   0403 07 E1 11      call _puts
0759   0406 2F            mov bl, al
0760   0407 07 81 12      call print_u8x
0761   040A 07 8E 11      call printnl
0762   040D EA            pop bl
0763   040E E7            pop d
0764   040F             syscall_ide_jmp:
0765   040F FD 0A EC 03   jmp [ide_serv_tbl + al]    
0766   0413               
0767   0413             ide_reset:      
0768   0413 F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0769   0417 07 C0 04      call ide_wait                   ; wait for IDE ready             
0770   041A F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0771   041E F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0772   0422 F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0773   0426 06            sysret
0774   0427             ide_sleep:
0775   0427 07 C0 04      call ide_wait                   ; wait for IDE ready             
0776   042A F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0777   042E F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0778   0432 07 C0 04      call ide_wait                   ; wait for IDE ready
0779   0435 06            sysret
0780   0436             ide_read_sect_wrapper:
0781   0436 07 3E 04      call ide_read_sect
0782   0439 06            sysret
0783   043A             ide_write_sect_wrapper:
0784   043A 07 64 04      call ide_write_sect
0785   043D 06            sysret
0786   043E             ide_read_sect:
0787   043E 1A            mov al, ah
0788   043F 24            mov ah, bl
0789   0440 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0790   0443 1C            mov al, bh
0791   0444 3D D4 FF      mov [_ide_R4], al
0792   0447 12            mov a, c
0793   0448 3D D5 FF      mov [_ide_R5], al
0794   044B 1A            mov al, ah
0795   044C 87 0F         and al, %00001111
0796   044E 8B E0         or al, %11100000                ; mode lba, master
0797   0450 3D D6 FF      mov [_ide_R6], al
0798   0453             ide_read_sect_wait:
0799   0453 1D D7 FF      mov al, [_ide_R7]  
0800   0456 87 80         and al, $80                     ; BUSY FLAG
0801   0458 C7 53 04      jnz ide_read_sect_wait
0802   045B 19 20         mov al, $20
0803   045D 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0804   0460 07 8A 04      call ide_read  
0805   0463 09            ret
0806   0464             ide_write_sect:
0807   0464 1A            mov al, ah
0808   0465 24            mov ah, bl
0809   0466 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0810   0469 1C            mov al, bh
0811   046A 3D D4 FF      mov [_ide_R4], al
0812   046D 12            mov a, c
0813   046E 3D D5 FF      mov [_ide_R5], al
0814   0471 1A            mov al, ah
0815   0472 87 0F         and al, %00001111
0816   0474 8B E0         or al, %11100000                ; mode lba, master
0817   0476 3D D6 FF      mov [_ide_R6], al
0818   0479             ide_write_sect_wait:
0819   0479 1D D7 FF      mov al, [_ide_R7]  
0820   047C 87 80         and al, $80                     ; BUSY FLAG
0821   047E C7 79 04      jnz ide_write_sect_wait
0822   0481 19 30         mov al, $30
0823   0483 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0824   0486 07 A5 04      call ide_write      
0825   0489 09            ret
0826   048A             
0827   048A             ;----------------------------------------------------------------------------------------------------;
0828   048A             ; READ IDE DATA
0829   048A             ; pointer in D
0830   048A             ;----------------------------------------------------------------------------------------------------;
0831   048A             ide_read:
0832   048A DA            push d
0833   048B             ide_read_loop:
0834   048B 1D D7 FF      mov al, [_ide_R7]  
0835   048E 87 80         and al, 80h                     ; BUSY FLAG
0836   0490 C7 8B 04      jnz ide_read_loop               ; wait loop
0837   0493 1D D7 FF      mov al, [_ide_R7]
0838   0496 87 08         and al, %00001000               ; DRQ FLAG
0839   0498 C6 A3 04      jz ide_read_end
0840   049B 1D D0 FF      mov al, [_ide_R0]
0841   049E 3E            mov [d], al
0842   049F 79            inc d
0843   04A0 0A 8B 04      jmp ide_read_loop
0844   04A3             ide_read_end:
0845   04A3 E7            pop d
0846   04A4 09            ret
0847   04A5             
0848   04A5             ;----------------------------------------------------------------------------------------------------;
0849   04A5             ; WRITE IDE DATA
0850   04A5             ; data pointer in D
0851   04A5             ;----------------------------------------------------------------------------------------------------;
0852   04A5             ide_write:
0853   04A5 DA            push d
0854   04A6             ide_write_loop:
0855   04A6 1D D7 FF      mov al, [_ide_R7]  
0856   04A9 87 80         and al, 80h             ; BUSY FLAG
0857   04AB C7 A6 04      jnz ide_write_loop      ; wait loop
0858   04AE 1D D7 FF      mov al, [_ide_R7]
0859   04B1 87 08         and al, %00001000       ; DRQ FLAG
0860   04B3 C6 BE 04      jz ide_write_end
0861   04B6 1E            mov al, [d]
0862   04B7 3D D0 FF      mov [_ide_R0], al
0863   04BA 79            inc d 
0864   04BB 0A A6 04      jmp ide_write_loop
0865   04BE             ide_write_end:
0866   04BE E7            pop d
0867   04BF 09            ret
0868   04C0             
0869   04C0             ;----------------------------------------------------------------------------------------------------;
0870   04C0             ; wait for IDE to be ready
0871   04C0             ;----------------------------------------------------------------------------------------------------;
0872   04C0             ide_wait:
0873   04C0 1D D7 FF      mov al, [_ide_R7]  
0874   04C3 87 80         and al, 80h        ; BUSY FLAG
0875   04C5 C7 C0 04      jnz ide_wait
0876   04C8 09            ret
0877   04C9             
0878   04C9             ;----------------------------------------------------------------------------------------------------;
0879   04C9             ; IO Syscall
0880   04C9             ;----------------------------------------------------------------------------------------------------;
0881   04C9             ; Baud  Divisor
0882   04C9             ; 50    2304
0883   04C9             ; 110   1047
0884   04C9             ; 300    384
0885   04C9             ; 600    192
0886   04C9             ; 1200    96
0887   04C9             ; 9600    12
0888   04C9             ; 19200    6
0889   04C9             ; 38400    3
0890   04C9             syscall_io_jmp:
0891   04C9 FC 04         .dw syscall_io_putchar
0892   04CB 09 05         .dw syscall_io_getch
0893   04CD D3 04         .dw syscall_io_uart_setup
0894   04CF             syscall_io:
0895   04CF FD 0A C9 04   jmp [syscall_io_jmp + al]
0896   04D3             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0897   04D3             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0898   04D3             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0899   04D3             syscall_io_uart_setup:
0900   04D3 1D 0C 17      mov al, [sys_uart0_lcr]
0901   04D6 8B 80         or al, $80                ; set DLAB access bit
0902   04D8 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0903   04DB 1D 0F 17      mov al, [sys_uart0_div0]
0904   04DE 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0905   04E1 1D 10 17      mov al, [sys_uart0_div1]
0906   04E4 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0907   04E7             
0908   04E7 1D 0C 17      mov al, [sys_uart0_lcr]
0909   04EA 87 7F         and al, $7F               ; clear DLAB access bit 
0910   04EC 3D 83 FF      mov [_UART0_LCR], al
0911   04EF 1D 0D 17      mov al, [sys_uart0_inten]
0912   04F2 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0913   04F5 1D 0E 17      mov al, [sys_uart0_fifoen]
0914   04F8 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0915   04FB 06            sysret
0916   04FC             
0917   04FC             ; char in ah
0918   04FC             syscall_io_putchar:
0919   04FC             syscall_io_putchar_L0:
0920   04FC 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0921   04FF 87 20         and al, $20
0922   0501 C6 FC 04      jz syscall_io_putchar_L0    
0923   0504 1A            mov al, ah
0924   0505 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0925   0508 06            sysret
0926   0509             
0927   0509             ; char in ah
0928   0509             ; al = sucess code
0929   0509             syscall_io_getch:
0930   0509 D8            push b
0931   050A DA            push d
0932   050B FD 0C         sti
0933   050D             syscall_io_getch_L0:  
0934   050D 14 19 17      mov a, [fifo_out]
0935   0510 29 17 17      mov b, [fifo_in]
0936   0513 B0            cmp a, b
0937   0514 C6 0D 05      je syscall_io_getch_L0
0938   0517 3C            mov d, a
0939   0518 77            inc a
0940   0519 AF 16 22      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
0941   051C C7 22 05      jne syscall_io_getch_cont
0942   051F 10 16 1E      mov a, fifo  
0943   0522             syscall_io_getch_cont:  
0944   0522 42 19 17      mov [fifo_out], a             ; update fifo pointer
0945   0525 1E            mov al, [d]                   ; get char
0946   0526 23            mov ah, al
0947   0527 1D 0B 17      mov al, [sys_echo_on]
0948   052A B9 01         cmp al, 1
0949   052C C7 3B 05      jne syscall_io_getch_noecho 
0950   052F             ; here we just echo the char back to the console
0951   052F             syscall_io_getch_echo_L0:
0952   052F 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0953   0532 87 20         and al, $20                 ; isolate Transmitter Empty
0954   0534 C6 2F 05      jz syscall_io_getch_echo_L0
0955   0537 1A            mov al, ah
0956   0538 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0957   053B             syscall_io_getch_noecho:
0958   053B 19 01         mov al, 1                    ; AL = 1 means a char successfully received
0959   053D E7            pop d
0960   053E E5            pop b
0961   053F 06            sysret
0962   0540             
0963   0540             ;------------------------------------------------------------------------------------------------------;
0964   0540             ; FILE SYSTEM DATA
0965   0540             ;------------------------------------------------------------------------------------------------------;
0966   0540             ; infor for : IDE SERVICES INTERRUPT
0967   0540             ; IDE read/write 512-byte sector
0968   0540             ; al = option
0969   0540             ; user buffer pointer in D
0970   0540             ; AH = number of sectors
0971   0540             ; CB = LBA bytes 3..0  
0972   0540             ;------------------------------------------------------------------------------------------------------;
0973   0540             ; FILE SYSTEM DATA STRUCTURE
0974   0540             ;------------------------------------------------------------------------------------------------------;
0975   0540             ; for a directory we have the header first, followed by metadata
0976   0540             ; header 1 sector (512 bytes)
0977   0540             ; metadata 1 sector (512 bytes)
0978   0540             ; HEADER ENTRIES:
0979   0540             ; filename (64)
0980   0540             ; parent dir LBA (2) -  to be used for faster backwards navigation...
0981   0540             ;
0982   0540             ; metadata entries:
0983   0540             ; filename (24)
0984   0540             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
0985   0540             ; LBA (2)
0986   0540             ; size (2)
0987   0540             ; day (1)
0988   0540             ; month (1)
0989   0540             ; year (1)
0990   0540             ; packet size = 32 bytes
0991   0540             ;
0992   0540             ; first directory on disk is the root directory '/'
0993   0540             file_system_jmptbl:
0994   0540 AB 05         .dw fs_mkfs                   ; 0
0995   0542 00 00         .dw 0                         ; 1
0996   0544 0D 06         .dw fs_mkdir                  ; 2
0997   0546 86 09         .dw fs_cd                     ; 3
0998   0548 8D 09         .dw fs_ls                     ; 4
0999   054A 03 0B         .dw fs_mktxt                  ; 5
1000   054C CE 0B         .dw fs_mkbin                  ; 6
1001   054E 95 0C         .dw fs_pwd                    ; 7
1002   0550 B2 0C         .dw fs_cat                    ; 8
1003   0552 0E 0D         .dw fs_rmdir                  ; 9
1004   0554 6A 0D         .dw fs_rm                     ; 10
1005   0556 5E 0A         .dw fs_starcom                ; 11
1006   0558 00 00         .dw 0                         ; 12
1007   055A 00 00         .dw 0                         ; 13
1008   055C B3 05         .dw fs_chmod                  ; 14
1009   055E D2 0D         .dw fs_mv                     ; 15
1010   0560 AC 05         .dw fs_cd_root                ; 16
1011   0562 82 09         .dw fs_get_curr_dirID         ; 17
1012   0564 5E 07         .dw fs_dir_id_to_path         ; 18
1013   0566 C4 07         .dw fs_path_to_dir_id_user    ; 19
1014   0568 DE 08         .dw fs_load_from_path_user    ; 20  
1015   056A 4E 08         .dw fs_filepath_exists_user   ; 21
1016   056C             
1017   056C 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1017   0570 79 73 63 61 
1017   0574 6C 6C 5F 66 
1017   0578 69 6C 65 5F 
1017   057C 73 79 73 74 
1017   0580 65 6D 20 63 
1017   0584 61 6C 6C 65 
1017   0588 64 3A 20 00 
1018   058C             syscall_file_system:
1019   058C DD            push bl
1020   058D 31 0A 17      mov bl, [sys_debug_mode]
1021   0590               ; debug block
1022   0590 C1 00         cmp bl, 0
1023   0592 EA            pop bl
1024   0593 C6 A7 05      je syscall_filesystem_jmp
1025   0596 DA            push d
1026   0597 DD            push bl
1027   0598 3B 6C 05      mov d, s_syscall_fs_dbg0
1028   059B 07 E1 11      call _puts
1029   059E 2F            mov bl, al
1030   059F 07 81 12      call print_u8x
1031   05A2 07 8E 11      call printnl
1032   05A5 EA            pop bl
1033   05A6 E7            pop d
1034   05A7             syscall_filesystem_jmp:
1035   05A7 FD 0A 40 05   jmp [file_system_jmptbl + al]
1036   05AB             
1037   05AB             fs_mkfs:  
1038   05AB 06            sysret  
1039   05AC               
1040   05AC             fs_cd_root:
1041   05AC 10 20 00      mov a, root_id
1042   05AF 42 1B 17      mov [current_dir_id], a      ; set current directory LBA to ROOT
1043   05B2 06            sysret  
1044   05B3             
1045   05B3             ; filename in D (userspace data)
1046   05B3             ; permission in BL
1047   05B3             fs_chmod:
1048   05B3 DD            push bl
1049   05B4 FD 4E         mov si, d
1050   05B6 FD 4F 16 1C   mov di, user_data
1051   05BA 38 80 00      mov c, 128
1052   05BD 04            load                        ; load filename from user-space
1053   05BE 14 1B 17      mov a, [current_dir_id]
1054   05C1 77            inc a                       ; metadata sector
1055   05C2 27            mov b, a
1056   05C3 38 00 00      mov c, 0                    ; upper LBA = 0
1057   05C6 22 01         mov ah, $01                  ; 1 sector
1058   05C8 3B 16 24      mov d, transient_area
1059   05CB 07 3E 04      call ide_read_sect          ; read directory
1060   05CE FD 10         cla
1061   05D0 42 13 17      mov [index], a              ; reset file counter
1062   05D3             fs_chmod_L1:
1063   05D3 FD 4E         mov si, d
1064   05D5 FD 4F 16 1C   mov di, user_data
1065   05D9 07 24 10      call _strcmp
1066   05DC C6 F3 05      je fs_chmod_found_entry
1067   05DF 58 20 00      add d, 32
1068   05E2 14 13 17      mov a, [index]
1069   05E5 77            inc a
1070   05E6 42 13 17      mov [index], a
1071   05E9 AF 10 00      cmp a, FST_FILES_PER_DIR
1072   05EC C7 D3 05      jne fs_chmod_L1
1073   05EF EA            pop bl
1074   05F0 0A 0C 06      jmp fs_chmod_not_found
1075   05F3             fs_chmod_found_entry:  
1076   05F3 FD 79         mov g, b                    ; save LBA
1077   05F5 EA            pop bl                      ; retrieve saved permission value
1078   05F6 1F 18 00      mov al, [d + 24]            ; read file permissions
1079   05F9 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1080   05FB 8C            or al, bl                   ; set new permissions
1081   05FC 3F 18 00      mov [d + 24], al            ; write new permissions
1082   05FF 38 00 00      mov c, 0
1083   0602 3B 16 24      mov d, transient_area
1084   0605 22 01         mov ah, $01                 ; disk write 1 sect
1085   0607 FD 27         mov b, g                    ; retrieve LBA
1086   0609 07 64 04      call ide_write_sect         ; write sector
1087   060C             fs_chmod_not_found:
1088   060C 06            sysret
1089   060D             
1090   060D             ;------------------------------------------------------------------------------------------------------;
1091   060D             ; CREATE NEW DIRECTORY
1092   060D             ;------------------------------------------------------------------------------------------------------;
1093   060D             ; search list for NULL name entry. add new directory to list
1094   060D             fs_mkdir:
1095   060D FD 4E         mov si, d
1096   060F FD 4F 16 1C   mov di, user_data
1097   0613 38 00 02      mov c, 512
1098   0616 04            load                        ; load data from user-space
1099   0617 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1100   061A                                           ; when checking for NULL name, since root has a NULL name)
1101   061A 38 00 00      mov c, 0                    ; upper LBA = 0
1102   061D             fs_mkdir_L1:  
1103   061D 22 01         mov ah, $01                  ; 1 sector
1104   061F 3B 16 24      mov d, transient_area
1105   0622 07 3E 04      call ide_read_sect          ; read sector
1106   0625 BD 00         cmp byte[d], 0              ; check for NULL
1107   0627 C6 30 06      je fs_mkdir_found_null
1108   062A 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1109   062D 0A 1D 06      jmp fs_mkdir_L1
1110   0630             fs_mkdir_found_null:
1111   0630             ;create header file by grabbing dir name from parameter
1112   0630 D8            push b                      ; save new directory's LBA
1113   0631 38 40 00      mov c, 64
1114   0634 FD 4D 16 1C   mov si, user_data
1115   0638 FD 4F 16 24   mov di, transient_area
1116   063C FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1117   063E 14 1B 17      mov a, [current_dir_id]
1118   0641 42 56 24      mov [transient_area + 64], a    ; store parent directory LBA
1119   0644 19 00         mov al, 0
1120   0646 FD 4F 16 26   mov di, transient_area + 512
1121   064A 38 00 02      mov c, 512
1122   064D FD F7         rep stosb                       ; clean buffer
1123   064F 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1124   0652             ; write directory entry sectors
1125   0652 3B 16 24      mov d, transient_area
1126   0655 22 02         mov ah, $02                     ; disk write, 2 sectors
1127   0657 07 64 04      call ide_write_sect             ; write sector
1128   065A             ; now we need to add the new directory to the list, insIDE the current directory
1129   065A 14 1B 17      mov a, [current_dir_id]
1130   065D 53 01 00      add a, 1
1131   0660 27            mov b, a                        ; metadata sector
1132   0661 38 00 00      mov c, 0
1133   0664 FD 79         mov g, b                        ; save LBA
1134   0666 3B 16 24      mov d, transient_area
1135   0669 22 01         mov ah, $01                  ; 1 sector
1136   066B 07 3E 04      call ide_read_sect              ; read metadata sector
1137   066E             fs_mkdir_L2:
1138   066E BD 00         cmp byte[d], 0
1139   0670 C6 79 06      je fs_mkdir_found_null2
1140   0673 58 20 00      add d, FST_ENTRY_SIZE
1141   0676 0A 6E 06      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1142   0679             fs_mkdir_found_null2:
1143   0679 FD 4D 16 1C   mov si, user_data
1144   067D FD 50         mov di, d
1145   067F 07 39 10      call _strcpy                    ; copy directory name
1146   0682 58 18 00      add d, 24                       ; goto ATTRIBUTES
1147   0685 19 0B         mov al, %00001011               ; directory, no execute, write, read
1148   0687 3E            mov [d], al      
1149   0688 79            inc d
1150   0689 E5            pop b
1151   068A D8            push b                          ; push LBA back
1152   068B FD 43         mov [d], b                      ; save LBA
1153   068D             ; set file creation date  
1154   068D 58 04 00      add d, 4
1155   0690 19 04         mov al, 4
1156   0692 05 01         syscall sys_rtc
1157   0694 1A            mov al, ah
1158   0695 3E            mov [d], al                     ; set day
1159   0696 79            inc d
1160   0697 19 05         mov al, 5
1161   0699 05 01         syscall sys_rtc
1162   069B 1A            mov al, ah
1163   069C 3E            mov [d], al                     ; set month
1164   069D 79            inc d
1165   069E 19 06         mov al, 6
1166   06A0 05 01         syscall sys_rtc
1167   06A2 1A            mov al, ah
1168   06A3 3E            mov [d], al                     ; set year
1169   06A4             ; write sector into disk for new directory entry
1170   06A4 FD 27         mov b, g
1171   06A6 38 00 00      mov c, 0
1172   06A9 3B 16 24      mov d, transient_area
1173   06AC 22 01         mov ah, $01                     ; disk write, 1 sector
1174   06AE 07 64 04      call ide_write_sect             ; write sector
1175   06B1             
1176   06B1             ; after adding the new directory's information to its parent directory's list
1177   06B1             ; we need to now enter the new directory, and to it add two new directories!
1178   06B1             ; which directories do we need to add ? '..' and '.' are the directories needed.
1179   06B1             ; importantly, note that these two new directories are only entries in the list
1180   06B1             ; and do not have actual physical entries in the disk as real directories.
1181   06B1             ; i.e. they only exist as list entries in the new directory created so that
1182   06B1             ; the new directory can reference its parent and itself.
1183   06B1             ; We need to add both '..' and '.'
1184   06B1             ; this first section is for '..' and on the section below we do the same for '.'
1185   06B1 E4            pop a                         ; retrieve the new directory's LBA  
1186   06B2 D7            push a                        ; and save again
1187   06B3 53 01 00      add a, 1
1188   06B6 27            mov b, a                      ; metadata sector
1189   06B7 38 00 00      mov c, 0
1190   06BA FD 79         mov g, b                      ; save LBA
1191   06BC 3B 16 24      mov d, transient_area
1192   06BF 22 01         mov ah, $01                  ; 1 sector
1193   06C1 07 3E 04      call ide_read_sect            ; read metadata sector
1194   06C4             fs_mkdir_L3:
1195   06C4 BD 00         cmp byte[d], 0
1196   06C6 C6 CF 06      je fs_mkdir_found_null3
1197   06C9 58 20 00      add d, FST_ENTRY_SIZE
1198   06CC 0A C4 06      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1199   06CF             fs_mkdir_found_null3:
1200   06CF FD 4D 2B 17   mov si, s_parent_dir
1201   06D3 FD 50         mov di, d
1202   06D5 07 39 10      call _strcpy                  ; copy directory name
1203   06D8 58 18 00      add d, 24                     ; goto ATTRIBUTES
1204   06DB 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1205   06DD 3E            mov [d], al      
1206   06DE 79            inc d
1207   06DF 29 1B 17      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1208   06E2 FD 43         mov [d], b                    ; save LBA
1209   06E4             ; set file creation date  
1210   06E4 58 04 00      add d, 4
1211   06E7 19 04         mov al, 4
1212   06E9 05 01         syscall sys_rtc
1213   06EB 1A            mov al, ah
1214   06EC 3E            mov [d], al                   ; set day
1215   06ED 79            inc d
1216   06EE 19 05         mov al, 5
1217   06F0 05 01         syscall sys_rtc
1218   06F2 1A            mov al, ah
1219   06F3 3E            mov [d], al                   ; set month
1220   06F4 79            inc d
1221   06F5 19 06         mov al, 6
1222   06F7 05 01         syscall sys_rtc
1223   06F9 1A            mov al, ah
1224   06FA 3E            mov [d], al                   ; set year
1225   06FB             ; write sector into disk for new directory entry
1226   06FB FD 27         mov b, g
1227   06FD 38 00 00      mov c, 0
1228   0700 3B 16 24      mov d, transient_area
1229   0703 22 01         mov ah, $01                   ; disk write, 1 sector
1230   0705 07 64 04      call ide_write_sect           ; write sector
1231   0708             ;;;;;;;;;;;;;
1232   0708             ; like we did above for '..', we need to now add the '.' directory to the list.
1233   0708             ;------------------------------------------------------------------------------------------------------;
1234   0708 E4            pop a                         ; retrieve the new directory's LBA  
1235   0709 D7            push a
1236   070A 53 01 00      add a, 1
1237   070D 27            mov b, a                      ; metadata sector
1238   070E 38 00 00      mov c, 0
1239   0711 FD 79         mov g, b                      ; save LBA
1240   0713 3B 16 24      mov d, transient_area
1241   0716 22 01         mov ah, $01                  ; 1 sector
1242   0718 07 3E 04      call ide_read_sect            ; read metadata sector
1243   071B             fs_mkdir_L4:
1244   071B BD 00         cmp byte[d], 0
1245   071D C6 26 07      je fs_mkdir_found_null4
1246   0720 58 20 00      add d, FST_ENTRY_SIZE
1247   0723 0A 1B 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1248   0726             fs_mkdir_found_null4:
1249   0726 FD 4D 2E 17   mov si, s_current_dir
1250   072A FD 50         mov di, d
1251   072C 07 39 10      call _strcpy                  ; copy directory name
1252   072F 58 18 00      add d, 24                     ; goto ATTRIBUTES
1253   0732 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1254   0734 3E            mov [d], al      
1255   0735 79            inc d
1256   0736 E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1257   0737 FD 43         mov [d], b                    ; save LBA
1258   0739             ; set file creation date  
1259   0739 58 04 00      add d, 4
1260   073C 19 04         mov al, 4
1261   073E 05 01         syscall sys_rtc
1262   0740 1A            mov al, ah
1263   0741 3E            mov [d], al                   ; set day
1264   0742 79            inc d
1265   0743 19 05         mov al, 5
1266   0745 05 01         syscall sys_rtc
1267   0747 1A            mov al, ah
1268   0748 3E            mov [d], al                   ; set month
1269   0749 79            inc d
1270   074A 19 06         mov al, 6
1271   074C 05 01         syscall sys_rtc
1272   074E 1A            mov al, ah
1273   074F 3E            mov [d], al                   ; set year
1274   0750             ; write sector into disk for new directory entry
1275   0750 FD 27         mov b, g
1276   0752 38 00 00      mov c, 0
1277   0755 3B 16 24      mov d, transient_area
1278   0758 22 01         mov ah, $01                   ; disk write, 1 sector
1279   075A 07 64 04      call ide_write_sect           ; write sector
1280   075D             fs_mkdir_end:
1281   075D 06            sysret
1282   075E             
1283   075E             ;------------------------------------------------------------------------------------------------------;
1284   075E             ; get path from a given directory dirID
1285   075E             ; pseudo code:
1286   075E             ;  fs_dir_id_to_path(int dirID, char *D){
1287   075E             ;    if(dirID == 0){
1288   075E             ;      reverse path in D;
1289   075E             ;      return;
1290   075E             ;    }
1291   075E             ;    else{
1292   075E             ;      copy directory name to end of D;
1293   075E             ;      add '/' to end of D;
1294   075E             ;      parentID = get parent directory ID;
1295   075E             ;      fs_dir_id_to_path(parentID, D);
1296   075E             ;    }
1297   075E             ;  }
1298   075E             ; A = dirID
1299   075E             ; D = generated path string pointer
1300   075E             ;------------------------------------------------------------------------------------------------------;
1301   075E             ; sample path: /usr/bin
1302   075E             fs_dir_id_to_path:
1303   075E 3B 96 1B      mov d, filename
1304   0761 19 00         mov al, 0
1305   0763 3E            mov [d], al                     ; initialize path string 
1306   0764 14 1B 17      mov a, [current_dir_id]
1307   0767 07 74 07      call fs_dir_id_to_path_E0
1308   076A 3B 96 1B      mov d, filename
1309   076D 07 CD 0F      call _strrev
1310   0770 07 E1 11      call _puts
1311   0773 06            sysret
1312   0774             fs_dir_id_to_path_E0:
1313   0774 07 93 07      call get_dirname_from_dirID
1314   0777 FD 4D 30 17   mov si, s_fslash
1315   077B FD 50         mov di, d
1316   077D 07 47 10      call _strcat                    ; add '/' to end of path
1317   0780 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1318   0783 C6 92 07      je fs_dir_id_to_path_root
1319   0786 07 B0 07      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1320   0789 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1321   078C C6 92 07      je fs_dir_id_to_path_root
1322   078F 07 74 07      call fs_dir_id_to_path_E0     ; recursively call itself
1323   0792             fs_dir_id_to_path_root:
1324   0792 09            ret
1325   0793             
1326   0793             ;------------------------------------------------------------------------------------------------------;
1327   0793             ; in_puts:
1328   0793             ; A = directory ID
1329   0793             ; out_puts:
1330   0793             ; D = pointer to directory name string
1331   0793             ;------------------------------------------------------------------------------------------------------;
1332   0793             get_dirname_from_dirID:
1333   0793 D7            push a
1334   0794 D8            push b
1335   0795 DA            push d
1336   0796 27            mov b, a
1337   0797 38 00 00      mov c, 0                      ; upper LBA = 0
1338   079A 22 01         mov ah, $01                  ; 1 sector
1339   079C 3B 16 22      mov d, transient_area - 512
1340   079F 07 3E 04      call ide_read_sect            ; read directory
1341   07A2 07 CD 0F      call _strrev                  ; reverse dir name before copying
1342   07A5 FD 4E         mov si, d
1343   07A7 E7            pop d                         ; destination address = D value pushed at beginning
1344   07A8 FD 50         mov di, d
1345   07AA 07 47 10      call _strcat                  ; copy filename to D
1346   07AD E5            pop b
1347   07AE E4            pop a
1348   07AF 09            ret
1349   07B0             
1350   07B0             ;------------------------------------------------------------------------------------------------------;
1351   07B0             ; in_puts:
1352   07B0             ; A = directory ID
1353   07B0             ; out_puts:
1354   07B0             ; A = parent directory ID
1355   07B0             ;------------------------------------------------------------------------------------------------------;
1356   07B0             get_parentID_from_dirID:
1357   07B0 D8            push b
1358   07B1 DA            push d
1359   07B2 27            mov b, a
1360   07B3 38 00 00      mov c, 0                      ; upper LBA = 0
1361   07B6 22 01         mov ah, $01                  ; 1 sector
1362   07B8 3B 16 22      mov d, transient_area - 512
1363   07BB 07 3E 04      call ide_read_sect            ; read directory
1364   07BE 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1365   07C1 E7            pop d
1366   07C2 E5            pop b
1367   07C3 09            ret
1368   07C4             
1369   07C4             ;------------------------------------------------------------------------------------------------------;
1370   07C4             ; get dirID from a given path string
1371   07C4             ; in_puts:
1372   07C4             ; D = path pointer 
1373   07C4             ; out_puts:
1374   07C4             ; A = dirID
1375   07C4             ; if dir non existent, A = FFFF (fail code)
1376   07C4             ; /usr/local/bin    - absolute
1377   07C4             ; local/bin/games    - relative
1378   07C4             ;------------------------------------------------------------------------------------------------------;
1379   07C4             fs_path_to_dir_id_user:
1380   07C4 FD 4E         mov si, d
1381   07C6 FD 4F 16 1C   mov di, user_data
1382   07CA 38 00 02      mov c, 512
1383   07CD 04            load
1384   07CE 07 D2 07      call get_dirID_from_path
1385   07D1 06            sysret
1386   07D2             get_dirID_from_path:
1387   07D2 26 16 1C      mov b, user_data
1388   07D5 FD 42 06 16   mov [prog], b                  ; token pointer set to path string
1389   07D9 07 67 14      call get_token
1390   07DC 31 09 16      mov bl, [tok]
1391   07DF C1 01         cmp bl, TOK_FSLASH
1392   07E1 C6 ED 07      je get_dirID_from_path_abs 
1393   07E4 14 1B 17      mov a, [current_dir_id]
1394   07E7 07 ED 15      call _putback
1395   07EA 0A F0 07      jmp get_dirID_from_path_E0
1396   07ED             get_dirID_from_path_abs:
1397   07ED 10 20 00      mov a, root_id
1398   07F0             get_dirID_from_path_E0:
1399   07F0 07 67 14      call get_token
1400   07F3 31 08 16      mov bl, [toktyp]
1401   07F6 C1 00         cmp bl, TOKTYP_IDENTIFIER
1402   07F8 C7 49 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1403   07FB             
1404   07FB FD 4D 0A 16   mov si, tokstr
1405   07FF FD 4F 96 1B   mov di, filename
1406   0803 07 39 10      call _strcpy        
1407   0806 77            inc a                         ; metadata sector
1408   0807 27            mov b, a
1409   0808 38 00 00      mov c, 0                      ; upper LBA = 0
1410   080B 22 01         mov ah, $01                  ; 1 sector
1411   080D 3B 16 24      mov d, transient_area
1412   0810 07 3E 04      call ide_read_sect            ; read directory
1413   0813 FD 10         cla
1414   0815 42 13 17      mov [index], a
1415   0818             get_dirID_from_path_L1:
1416   0818 FD 4E         mov si, d
1417   081A FD 4F 96 1B   mov di, filename
1418   081E 07 24 10      call _strcmp
1419   0821 C6 37 08      je get_dirID_from_path_name_equal  
1420   0824 58 20 00      add d, 32
1421   0827 14 13 17      mov a, [index]
1422   082A 77            inc a
1423   082B 42 13 17      mov [index], a
1424   082E AF 10 00      cmp a, FST_FILES_PER_DIR
1425   0831 C6 4A 08      je get_dirID_from_path_fail
1426   0834 0A 18 08      jmp get_dirID_from_path_L1
1427   0837             get_dirID_from_path_name_equal:
1428   0837 58 19 00      add d, 25           
1429   083A 15            mov a, [d]                    ; set result register A = dirID
1430   083B 07 67 14      call get_token
1431   083E 31 09 16      mov bl, [tok]
1432   0841 C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1433   0843 C6 F0 07      je get_dirID_from_path_E0
1434   0846 07 ED 15      call _putback
1435   0849             get_dirID_from_path_end:
1436   0849 09            ret
1437   084A             get_dirID_from_path_fail:
1438   084A 10 FF FF      mov A, $FFFF
1439   084D 09            ret
1440   084E             
1441   084E             
1442   084E             ;------------------------------------------------------------------------------------------------------;
1443   084E             ; check if file exists by a given path string
1444   084E             ; in_puts:
1445   084E             ; D = path pointer 
1446   084E             ; OUTPUTS:
1447   084E             ; A = success code, if file exists gives LBA, else, give 0
1448   084E             ; /usr/local/bin/ed
1449   084E             ;------------------------------------------------------------------------------------------------------;
1450   084E             fs_filepath_exists_user:
1451   084E FD 4E         mov si, d
1452   0850 FD 4F 16 1C   mov di, user_data
1453   0854 38 00 02      mov c, 512
1454   0857 04            load
1455   0858 07 5C 08      call file_exists_by_path
1456   085B 06            sysret
1457   085C             file_exists_by_path:
1458   085C 26 16 1C      mov b, user_data
1459   085F FD 42 06 16   mov [prog], b                   ; token pointer set to path string
1460   0863 07 67 14      call get_token
1461   0866 31 09 16      mov bl, [tok]
1462   0869 C1 01         cmp bl, TOK_FSLASH
1463   086B C6 77 08      je  file_exists_by_path_abs
1464   086E 14 1B 17      mov a, [current_dir_id]
1465   0871 07 ED 15      call _putback
1466   0874 0A 7A 08      jmp file_exists_by_path_E0
1467   0877             file_exists_by_path_abs:
1468   0877 10 20 00      mov a, root_id
1469   087A             file_exists_by_path_E0:
1470   087A 07 67 14      call get_token
1471   087D 31 08 16      mov bl, [toktyp]
1472   0880 C1 00         cmp bl, TOKTYP_IDENTIFIER
1473   0882 C7 DA 08      jne file_exists_by_path_end     ; check if there are tokens after '/'
1474   0885 FD 4D 0A 16   mov si, tokstr
1475   0889 FD 4F 96 1B   mov di, filename
1476   088D 07 39 10      call _strcpy        
1477   0890 77            inc a                           ; metadata sector
1478   0891 27            mov b, a
1479   0892 38 00 00      mov c, 0                        ; upper LBA = 0
1480   0895 22 01         mov ah, $01                  ; 1 sector
1481   0897 3B 16 24      mov d, transient_area
1482   089A 07 3E 04      call ide_read_sect              ; read directory
1483   089D FD 10         cla
1484   089F 42 13 17      mov [index], a
1485   08A2             file_exists_by_path_L1:
1486   08A2 FD 4E         mov si, d
1487   08A4 FD 4F 96 1B   mov di, filename
1488   08A8 07 24 10      call _strcmp
1489   08AB C6 C1 08      je   file_exists_by_path_name_equal
1490   08AE 58 20 00      add d, 32
1491   08B1 14 13 17      mov a, [index]
1492   08B4 77            inc a
1493   08B5 42 13 17      mov [index], a
1494   08B8 AF 10 00      cmp a, FST_FILES_PER_DIR
1495   08BB C6 DA 08      je file_exists_by_path_end
1496   08BE 0A A2 08      jmp file_exists_by_path_L1
1497   08C1             file_exists_by_path_name_equal:
1498   08C1 33 18 00      mov bl, [d + 24]
1499   08C4 FD 87 38      and bl, %00111000               ; directory flag
1500   08C7 C1 08         cmp bl, %00001000               ; is dir?
1501   08C9 C6 D0 08      je file_exists_by_path_isdir;
1502   08CC             ; entry is a file
1503   08CC 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1504   08CF 09            ret
1505   08D0             file_exists_by_path_isdir:
1506   08D0 58 19 00      add d, 25           
1507   08D3 15            mov a, [d]                      ; set result register A = dirID
1508   08D4 07 67 14      call get_token
1509   08D7 0A 7A 08      jmp file_exists_by_path_E0
1510   08DA             file_exists_by_path_end:
1511   08DA 10 00 00      mov a, 0                        ; return 0 because file was not found
1512   08DD 09            ret
1513   08DE             
1514   08DE             ;------------------------------------------------------------------------------------------------------;
1515   08DE             ; load file data from a given path string
1516   08DE             ; inputs:
1517   08DE             ; D = path pointer 
1518   08DE             ; DI = userspace program data destination
1519   08DE             ; /usr/local/bin/ed
1520   08DE             ; ./ed
1521   08DE             ;------------------------------------------------------------------------------------------------------;
1522   08DE             fs_load_from_path_user:
1523   08DE E3            push di
1524   08DF FD 4E         mov si, d
1525   08E1 FD 4F 16 1C   mov di, user_data
1526   08E5 38 00 02      mov c, 512
1527   08E8 04            load
1528   08E9 07 F6 08      call loadfile_from_path
1529   08EC F0            pop di
1530   08ED FD 4D 16 24   mov si, transient_area
1531   08F1 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1532   08F4 03            store
1533   08F5 06            sysret
1534   08F6             loadfile_from_path:
1535   08F6 26 16 1C      mov b, user_data
1536   08F9 FD 42 06 16   mov [prog], b                 ; token pointer set to path string
1537   08FD 07 67 14      call get_token
1538   0900 31 09 16      mov bl, [tok]
1539   0903 C1 01         cmp bl, TOK_FSLASH
1540   0905 C6 11 09      je loadfile_from_path_abs 
1541   0908 14 1B 17      mov a, [current_dir_id]
1542   090B 07 ED 15      call _putback
1543   090E 0A 14 09      jmp loadfile_from_path_E0
1544   0911             loadfile_from_path_abs:
1545   0911 10 20 00      mov a, root_id
1546   0914             loadfile_from_path_E0:
1547   0914 07 67 14      call get_token
1548   0917 31 08 16      mov bl, [toktyp]
1549   091A C1 00         cmp bl, TOKTYP_IDENTIFIER
1550   091C C7 81 09      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1551   091F FD 4D 0A 16   mov si, tokstr
1552   0923 FD 4F 96 1B   mov di, filename
1553   0927 07 39 10      call _strcpy        
1554   092A 77            inc a                         ; metadata sector
1555   092B 27            mov b, a
1556   092C 38 00 00      mov c, 0                      ; upper LBA = 0
1557   092F 22 01         mov ah, $01                  ; 1 sector
1558   0931 3B 16 24      mov d, transient_area
1559   0934 07 3E 04      call ide_read_sect            ; read directory
1560   0937 FD 10         cla
1561   0939 42 13 17      mov [index], a
1562   093C             loadfile_from_path_L1:
1563   093C FD 4E         mov si, d
1564   093E FD 4F 96 1B   mov di, filename
1565   0942 07 24 10      call _strcmp
1566   0945 C6 5B 09      je loadfile_from_path_name_equal  
1567   0948 58 20 00      add d, 32
1568   094B 14 13 17      mov a, [index]
1569   094E 77            inc a
1570   094F 42 13 17      mov [index], a
1571   0952 AF 10 00      cmp a, FST_FILES_PER_DIR
1572   0955 C6 81 09      je loadfile_from_path_end
1573   0958 0A 3C 09      jmp loadfile_from_path_L1
1574   095B             loadfile_from_path_name_equal:
1575   095B 33 18 00      mov bl, [d + 24]
1576   095E FD 87 38      and bl, %00111000             ; directory flag
1577   0961 C1 08         cmp bl, %00001000             ; is dir?
1578   0963 C6 77 09      je loadfile_isdirectory  
1579   0966             ; entry is a file
1580   0966 2B 19 00      mov b, [d + 25]               ; get LBA
1581   0969 FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1582   096B 3B 16 24      mov d, transient_area
1583   096E 38 00 00      mov c, 0
1584   0971 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1585   0973 07 3E 04      call ide_read_sect            ; read sector
1586   0976 09            ret
1587   0977             loadfile_isdirectory:
1588   0977 58 19 00      add d, 25           
1589   097A 15            mov a, [d]                    ; set result register A = dirID
1590   097B 07 67 14      call get_token
1591   097E 0A 14 09      jmp loadfile_from_path_E0
1592   0981             loadfile_from_path_end:
1593   0981 09            ret
1594   0982             
1595   0982             ;------------------------------------------------------------------------------------------------------;
1596   0982             ; return the ID of the current directory
1597   0982             ; ID returned in B
1598   0982             ;------------------------------------------------------------------------------------------------------;
1599   0982             fs_get_curr_dirID:
1600   0982 29 1B 17      mov b, [current_dir_id]
1601   0985 06            sysret
1602   0986             
1603   0986             ;------------------------------------------------------------------------------------------------------;
1604   0986             ; CD
1605   0986             ;------------------------------------------------------------------------------------------------------;
1606   0986             ; new dirID in B
1607   0986             fs_cd:
1608   0986 FD 42 1B 17   mov [current_dir_id], b
1609   098A 06            sysret  
1610   098B             
1611   098B             ;------------------------------------------------------------------------------------------------------;
1612   098B             ; LS
1613   098B             ; dirID in B
1614   098B             ;------------------------------------------------------------------------------------------------------;
1615   098B 00 00       ls_count:       .dw 0
1616   098D             fs_ls:
1617   098D FD 77         inc b                        ; metadata sector
1618   098F 38 00 00      mov c, 0                     ; upper LBA = 0
1619   0992 22 01         mov ah, $01                  ; 1 sector
1620   0994 3B 16 24      mov d, transient_area
1621   0997 07 3E 04      call ide_read_sect           ; read directory
1622   099A FD 10         cla
1623   099C 42 13 17      mov [index], a               ; reset entry index
1624   099F 3D 8B 09      mov [ls_count], al           ; reset item count
1625   09A2             fs_ls_L1:
1626   09A2 BD 00         cmp byte [d], 0              ; check for NULL
1627   09A4 C6 3B 0A      je fs_ls_next
1628   09A7             fs_ls_non_null:
1629   09A7 1D 8B 09      mov al, [ls_count]
1630   09AA 7A            inc al
1631   09AB 3D 8B 09      mov [ls_count], al           ; increment item count
1632   09AE 1F 18 00      mov al, [d + 24]
1633   09B1 87 38         and al, %00111000
1634   09B3 FD A2 03      shr al, 3
1635   09B6 22 00         mov ah, 0                    ; file type
1636   09B8 B7 37 17      mov a, [a + file_type]      
1637   09BB 23            mov ah, al
1638   09BC 07 B5 10      call _putchar
1639   09BF 1F 18 00      mov al, [d + 24]
1640   09C2 87 01         and al, %00000001
1641   09C4 22 00         mov ah, 0
1642   09C6 B7 32 17      mov a, [a + file_attrib]     ; read
1643   09C9 23            mov ah, al
1644   09CA 07 B5 10      call _putchar
1645   09CD 1F 18 00      mov al, [d + 24]
1646   09D0 87 02         and al, %00000010
1647   09D2 22 00         mov ah, 0
1648   09D4 B7 32 17      mov a, [a + file_attrib]     ; write
1649   09D7 23            mov ah, al
1650   09D8 07 B5 10      call _putchar
1651   09DB 1F 18 00      mov al, [d + 24]
1652   09DE 87 04         and al, %00000100
1653   09E0 22 00         mov ah, 0
1654   09E2 B7 32 17      mov a, [a + file_attrib]     ; execute
1655   09E5 23            mov ah, al
1656   09E6 07 B5 10      call _putchar
1657   09E9 22 20         mov ah, $20
1658   09EB 07 B5 10      call _putchar  
1659   09EE 2B 1B 00      mov b, [d + 27]
1660   09F1 07 3D 12      call print_u16x              ; filesize
1661   09F4 22 20         mov ah, $20
1662   09F6 07 B5 10      call _putchar  
1663   09F9 2B 19 00      mov b, [d + 25]
1664   09FC 07 3D 12      call print_u16x              ; dirID / LBA
1665   09FF 22 20         mov ah, $20
1666   0A01 07 B5 10      call _putchar
1667   0A04             ; print date
1668   0A04 33 1D 00      mov bl, [d + 29]             ; day
1669   0A07 07 81 12      call print_u8x
1670   0A0A 22 20         mov ah, $20
1671   0A0C 07 B5 10      call _putchar  
1672   0A0F 1F 1E 00      mov al, [d + 30]             ; month
1673   0A12 FD 9E 02      shl al, 2
1674   0A15 DA            push d
1675   0A16 3B F6 17      mov d, s_months
1676   0A19 22 00         mov ah, 0
1677   0A1B 59            add d, a
1678   0A1C 07 E1 11      call _puts
1679   0A1F E7            pop d
1680   0A20 22 20         mov ah, $20
1681   0A22 07 B5 10      call _putchar
1682   0A25 2E 20         mov bl, $20
1683   0A27 07 81 12      call print_u8x
1684   0A2A 33 1F 00      mov bl, [d + 31]             ; year
1685   0A2D 07 81 12      call print_u8x  
1686   0A30 22 20         mov ah, $20
1687   0A32 07 B5 10      call _putchar  
1688   0A35 07 E1 11      call _puts                   ; print filename  
1689   0A38 07 8E 11      call printnl
1690   0A3B             fs_ls_next:
1691   0A3B 14 13 17      mov a, [index]
1692   0A3E 77            inc a
1693   0A3F 42 13 17      mov [index], a
1694   0A42 AF 10 00      cmp a, FST_FILES_PER_DIR
1695   0A45 C6 4E 0A      je fs_ls_end
1696   0A48 58 20 00      add d, 32      
1697   0A4B 0A A2 09      jmp fs_ls_L1  
1698   0A4E             fs_ls_end:
1699   0A4E 3B 47 17      mov d, s_ls_total
1700   0A51 07 E1 11      call _puts
1701   0A54 1D 8B 09      mov al, [ls_count]
1702   0A57 07 93 12      call print_u8d
1703   0A5A 07 8E 11      call printnl
1704   0A5D 06            sysret
1705   0A5E             
1706   0A5E             
1707   0A5E             ; file structure:
1708   0A5E             ; 512 bytes header
1709   0A5E             ; header used to tell whether the block is free
1710   0A5E             ;------------------------------------------------------------------------------------------------------;
1711   0A5E             ; CREATE NEW TEXTFILE
1712   0A5E             ;------------------------------------------------------------------------------------------------------;
1713   0A5E             ; d = content pointer in user space
1714   0A5E             ; c = file size
1715   0A5E             fs_starcom:
1716   0A5E FD 4E       	mov si, d
1717   0A60 FD 4F 16 24 	mov di, transient_area
1718   0A64 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1719   0A67 04          	load					; load data from user-space
1720   0A68 07 E9 0A    	call fs_find_empty_block	; look for empty data blocks
1721   0A6B D8          	push b				; save empty block LBA
1722   0A6C FD 79         mov g, b
1723   0A6E             ;create header file by grabbing file name from parameter	
1724   0A6E 3B 16 26    	mov d, transient_area + 512			; pointer to file contents
1725   0A71 D9          	push c							; save length
1726   0A72 19 01       	mov al, 1
1727   0A74 3D 16 24    	mov [transient_area], al					; mark sectors as USED (not NULL)
1728   0A77 3B 16 24    	mov d, transient_area
1729   0A7A 12            mov a, c
1730   0A7B 26 00 02      mov b, 512
1731   0A7E AE            div a, b
1732   0A7F FD 77         inc b         ; inc b as the division will most likely have a remainder
1733   0A81 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1734   0A82 38 00 00    	mov c, 0      ; lba 
1735   0A85 FD 27         mov b, g      ; lba 
1736   0A87 07 64 04    	call ide_write_sect			; write sectors
1737   0A8A             ; now we add the file to the current directory!
1738   0A8A             fs_starcom_add_to_dir:	
1739   0A8A 14 1B 17    	mov a, [current_dir_id]
1740   0A8D 77          	inc a
1741   0A8E 27          	mov b, a					; metadata sector
1742   0A8F 38 00 00    	mov c, 0
1743   0A92 FD 79       	mov g, b					; save LBA
1744   0A94 3B 16 22    	mov d, scrap_sector
1745   0A97 22 01       	mov ah, $01			  ; 1 sector
1746   0A99 07 3E 04    	call ide_read_sect		; read metadata sector
1747   0A9C             fs_starcom_add_to_dir_L2:
1748   0A9C BD 00       	cmp byte[d], 0
1749   0A9E C6 A7 0A    	je fs_starcom_add_to_dir_null
1750   0AA1 58 20 00    	add d, FST_ENTRY_SIZE
1751   0AA4 0A 9C 0A    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1752   0AA7             fs_starcom_add_to_dir_null:
1753   0AA7 FD 4D 17 24 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1754   0AAB FD 50       	mov di, d
1755   0AAD 07 39 10    	call _strcpy			; copy file name
1756   0AB0 58 18 00    	add d, 24			; skip name
1757   0AB3 19 07       	mov al, %00000111	; type=file, execute, write, read
1758   0AB5 3E          	mov [d], al			
1759   0AB6 58 03 00    	add d, 3
1760   0AB9 E4          	pop a
1761   0ABA 5F 00 02      sub a, 512
1762   0ABD 43          	mov [d], a ; file size
1763   0ABE 63 02 00    	sub d, 2
1764   0AC1 E5          	pop b				; get file LBA
1765   0AC2 FD 43       	mov [d], b			; save LBA	
1766   0AC4             ; set file creation date	
1767   0AC4 58 04 00    	add d, 4
1768   0AC7 19 04       	mov al, 4
1769   0AC9 05 01       	syscall sys_rtc
1770   0ACB 1A          	mov al, ah
1771   0ACC 3E          	mov [d], al			; set day
1772   0ACD 79          	inc d
1773   0ACE 19 05       	mov al, 5
1774   0AD0 05 01       	syscall sys_rtc
1775   0AD2 1A          	mov al, ah
1776   0AD3 3E          	mov [d], al			; set month
1777   0AD4 79          	inc d
1778   0AD5 19 06       	mov al, 6
1779   0AD7 05 01       	syscall sys_rtc
1780   0AD9 1A          	mov al, ah
1781   0ADA 3E          	mov [d], al			; set year
1782   0ADB             ; write sector into disk for new directory entry
1783   0ADB FD 27       	mov b, g
1784   0ADD 38 00 00    	mov c, 0
1785   0AE0 3B 16 22    	mov d, scrap_sector
1786   0AE3 22 01       	mov ah, $01			; disk write, 1 sector
1787   0AE5 07 64 04    	call ide_write_sect		; write sector
1788   0AE8 06          	sysret
1789   0AE9             
1790   0AE9             ;------------------------------------------------------------------------------------------------------;
1791   0AE9             ; finds an empty data block
1792   0AE9             ; block LBA returned in B
1793   0AE9             ;------------------------------------------------------------------------------------------------------;
1794   0AE9             fs_find_empty_block:
1795   0AE9 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1796   0AEC 38 00 00      mov c, 0                ; upper LBA = 0
1797   0AEF             fs_find_empty_block_L1:  
1798   0AEF 22 01         mov ah, $01                  ; 1 sector
1799   0AF1 3B 16 22      mov d, transient_area - 512
1800   0AF4 07 3E 04      call ide_read_sect      ; read sector
1801   0AF7 BD 00         cmp byte [d], 0
1802   0AF9 C6 02 0B      je fs_find_empty_block_found_null
1803   0AFC 55 20 00      add b, FS_SECTORS_PER_FILE
1804   0AFF 0A EF 0A      jmp fs_find_empty_block_L1
1805   0B02             fs_find_empty_block_found_null:
1806   0B02 09            ret
1807   0B03             
1808   0B03             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1809   0B03             ;; CREATE NEW TEXTFILE
1810   0B03             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1811   0B03             ; search for first null block
1812   0B03             fs_mktxt:
1813   0B03 FD 4E       	mov si, d
1814   0B05 FD 4F 16 1C 	mov di, user_data
1815   0B09 38 00 01    	mov c, 256
1816   0B0C 04          	load					; load data from user-space
1817   0B0D             	
1818   0B0D 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1819   0B10 38 00 00    	mov c, 0						; reset LBA to 0
1820   0B13             fs_mktxt_L1:	
1821   0B13 10 02 01    	mov a, $0102			; disk read
1822   0B16 3B 16 24    	mov d, transient_area
1823   0B19 05 02       	syscall sys_ide ; read sector
1824   0B1B 1E          	mov al, [d]
1825   0B1C B9 00       	cmp al, 0			; check for NULL
1826   0B1E C6 27 0B    	je fs_mktxt_found_null
1827   0B21 55 20 00    	add b, FS_SECTORS_PER_FILE
1828   0B24 0A 13 0B    	jmp fs_mktxt_L1
1829   0B27             fs_mktxt_found_null:
1830   0B27 D8          	push b				; save LBA
1831   0B28             ;create header file by grabbing file name from parameter	
1832   0B28 3B 28 17    	mov d, s_dataentry
1833   0B2B 07 E1 11    	call _puts
1834   0B2E 3B 16 26    	mov d, transient_area + 512			; pointer to file contents
1835   0B31 07 47 11    	call _gettxt
1836   0B34 07 14 10    	call _strlen						; get length of file
1837   0B37 D9          	push c							; save length
1838   0B38 19 01       	mov al, 1
1839   0B3A 3D 16 24    	mov [transient_area], al					; mark sectors as USED (not NULL)
1840   0B3D 10 00 00    	mov a, 0
1841   0B40 42 13 17    	mov [index], a
1842   0B43 3B 16 24    	mov d, transient_area
1843   0B46 13          	mov a, d
1844   0B47 42 15 17    	mov [buffer_addr], a
1845   0B4A             fs_mktxt_L2:
1846   0B4A 38 00 00    	mov c, 0
1847   0B4D 10 03 01    	mov a, $0103			; disk write, 1 sector
1848   0B50 05 02       	syscall sys_ide		; write sector
1849   0B52 14 13 17    	mov a, [index]
1850   0B55 77          	inc a
1851   0B56 42 13 17    	mov [index], a
1852   0B59 AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1853   0B5C C6 6E 0B    	je fs_mktxt_add_to_dir
1854   0B5F FD 77       	inc b
1855   0B61 14 15 17    	mov a, [buffer_addr]
1856   0B64 53 00 02    	add a, 512
1857   0B67 42 15 17    	mov [buffer_addr], a
1858   0B6A 3C          	mov d, a
1859   0B6B 0A 4A 0B    	jmp fs_mktxt_L2
1860   0B6E             ; now we add the file to the current directory!
1861   0B6E             fs_mktxt_add_to_dir:	
1862   0B6E 14 1B 17    	mov a, [current_dir_id]
1863   0B71 77          	inc a
1864   0B72 27          	mov b, a					; metadata sector
1865   0B73 38 00 00    	mov c, 0
1866   0B76 FD 79       	mov g, b					; save LBA
1867   0B78 3B 16 24    	mov d, transient_area
1868   0B7B 10 02 01    	mov a, $0102			; disk read
1869   0B7E 05 02       	syscall sys_ide		; read metadata sector
1870   0B80             fs_mktxt_add_to_dir_L2:
1871   0B80 1E          	mov al, [d]
1872   0B81 B9 00       	cmp al, 0
1873   0B83 C6 8C 0B    	je fs_mktxt_add_to_dir_null
1874   0B86 58 20 00    	add d, FST_ENTRY_SIZE
1875   0B89 0A 80 0B    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1876   0B8C             fs_mktxt_add_to_dir_null:
1877   0B8C FD 4D 16 1C 	mov si, user_data
1878   0B90 FD 50       	mov di, d
1879   0B92 07 39 10    	call _strcpy			; copy file name
1880   0B95 58 18 00    	add d, 24			; skip name
1881   0B98 19 06       	mov al, %00000110		; no execute, write, read, not directory
1882   0B9A 3E          	mov [d], al			
1883   0B9B 58 03 00    	add d, 3
1884   0B9E E4          	pop a
1885   0B9F 43          	mov [d], a
1886   0BA0 63 02 00    	sub d, 2
1887   0BA3 E5          	pop b				; get file LBA
1888   0BA4 FD 43       	mov [d], b			; save LBA	
1889   0BA6             	
1890   0BA6             	; set file creation date	
1891   0BA6 58 04 00    	add d, 4
1892   0BA9 19 04       	mov al, 4
1893   0BAB 05 01       	syscall sys_rtc
1894   0BAD 1A          	mov al, ah
1895   0BAE 3E          	mov [d], al			; set day
1896   0BAF             	
1897   0BAF 79          	inc d
1898   0BB0 19 05       	mov al, 5
1899   0BB2 05 01       	syscall sys_rtc
1900   0BB4 1A          	mov al, ah
1901   0BB5 3E          	mov [d], al			; set month
1902   0BB6             	
1903   0BB6 79          	inc d
1904   0BB7 19 06       	mov al, 6
1905   0BB9 05 01       	syscall sys_rtc
1906   0BBB 1A          	mov al, ah
1907   0BBC 3E          	mov [d], al			; set year
1908   0BBD             	
1909   0BBD             ; write sector into disk for new directory entry
1910   0BBD FD 27       	mov b, g
1911   0BBF 38 00 00    	mov c, 0
1912   0BC2 3B 16 24    	mov d, transient_area
1913   0BC5 10 03 01    	mov a, $0103			; disk write, 1 sector
1914   0BC8 05 02       	syscall sys_ide		; write sector
1915   0BCA 07 8E 11    	call printnl
1916   0BCD 06          	sysret
1917   0BCE             
1918   0BCE             
1919   0BCE             
1920   0BCE             ;------------------------------------------------------------------------------------------------------;
1921   0BCE             ; CREATE NEW BINARY FILE
1922   0BCE             ;------------------------------------------------------------------------------------------------------;
1923   0BCE             ; search for first null block
1924   0BCE             fs_mkbin:
1925   0BCE 19 00         mov al, 0
1926   0BD0 3D 0B 17      mov [sys_echo_on], al ; disable echo
1927   0BD3 FD 4E         mov si, d
1928   0BD5 FD 4F 16 1C   mov di, user_data
1929   0BD9 38 00 02      mov c, 512
1930   0BDC 04            load                          ; load data from user-space
1931   0BDD 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
1932   0BE0 38 00 00      mov c, 0                      ; upper LBA = 0
1933   0BE3             fs_mkbin_L1:  
1934   0BE3 22 01         mov ah, $01                  ; 1 sector
1935   0BE5 3B 16 24      mov d, transient_area
1936   0BE8 07 3E 04      call ide_read_sect            ; read sector
1937   0BEB BD 00         cmp byte[d], 0                ; check for NULL
1938   0BED C6 F6 0B      je fs_mkbin_found_null
1939   0BF0 55 20 00      add b, FS_SECTORS_PER_FILE
1940   0BF3 0A E3 0B      jmp fs_mkbin_L1
1941   0BF6             fs_mkbin_found_null:
1942   0BF6 D8            push b                        ; save LBA
1943   0BF7             ;create header file by grabbing file name from parameter
1944   0BF7 FD 4F 16 26   mov di, transient_area + 512  ; pointer to file contents
1945   0BFB 07 71 0F      call _load_hex                ; load binary hex
1946   0BFE D9            push c                        ; save size (nbr of bytes)
1947   0BFF 19 01         mov al, 1
1948   0C01 3D 16 24      mov [transient_area], al      ; mark sectors as USED (not NULL)
1949   0C04 FD 10         cla
1950   0C06 42 13 17      mov [index], a
1951   0C09 3B 16 24      mov d, transient_area
1952   0C0C 13            mov a, d
1953   0C0D 42 15 17      mov [buffer_addr], a
1954   0C10             fs_mkbin_L2:
1955   0C10 38 00 00      mov c, 0
1956   0C13 22 01         mov ah, $01                   ; disk write, 1 sector
1957   0C15 07 64 04      call ide_write_sect           ; write sector
1958   0C18 14 13 17      mov a, [index]
1959   0C1B 77            inc a
1960   0C1C 42 13 17      mov [index], a
1961   0C1F AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
1962   0C22 C6 34 0C      je fs_mkbin_add_to_dir
1963   0C25 FD 77         inc b
1964   0C27 14 15 17      mov a, [buffer_addr]
1965   0C2A 53 00 02      add a, 512
1966   0C2D 42 15 17      mov [buffer_addr], a
1967   0C30 3C            mov d, a
1968   0C31 0A 10 0C      jmp fs_mkbin_L2
1969   0C34             ; now we add the file to the current directory!
1970   0C34             fs_mkbin_add_to_dir:  
1971   0C34 14 1B 17      mov a, [current_dir_id]
1972   0C37 77            inc a
1973   0C38 27            mov b, a                      ; metadata sector
1974   0C39 38 00 00      mov c, 0
1975   0C3C FD 79         mov g, b                      ; save LBA
1976   0C3E 3B 16 24      mov d, transient_area
1977   0C41 22 01         mov ah, $01                  ; 1 sector
1978   0C43 07 3E 04      call ide_read_sect            ; read metadata sector
1979   0C46             fs_mkbin_add_to_dir_L2:
1980   0C46 BD 00         cmp byte[d], 0
1981   0C48 C6 51 0C      je fs_mkbin_add_to_dir_null
1982   0C4B 58 20 00      add d, FST_ENTRY_SIZE
1983   0C4E 0A 46 0C      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1984   0C51             fs_mkbin_add_to_dir_null:
1985   0C51 FD 4D 16 1C   mov si, user_data
1986   0C55 FD 50         mov di, d
1987   0C57 07 39 10      call _strcpy                  ; copy file name
1988   0C5A 58 18 00      add d, 24                     ; skip name
1989   0C5D 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
1990   0C5F 3E            mov [d], al
1991   0C60 58 03 00      add d, 3
1992   0C63 E4            pop a
1993   0C64 43            mov [d], a
1994   0C65 63 02 00      sub d, 2
1995   0C68 E5            pop b                         ; get file LBA
1996   0C69 FD 43         mov [d], b                    ; save LBA
1997   0C6B               ; set file creation date  
1998   0C6B 58 04 00      add d, 4
1999   0C6E 19 04         mov al, 4
2000   0C70 05 01         syscall sys_rtc
2001   0C72 1A            mov al, ah
2002   0C73 3E            mov [d], al                   ; set day
2003   0C74 79            inc d
2004   0C75 19 05         mov al, 5
2005   0C77 05 01         syscall sys_rtc
2006   0C79 1A            mov al, ah
2007   0C7A 3E            mov [d], al                   ; set month
2008   0C7B 79            inc d
2009   0C7C 19 06         mov al, 6
2010   0C7E 05 01         syscall sys_rtc
2011   0C80 1A            mov al, ah
2012   0C81 3E            mov [d], al                   ; set year
2013   0C82             ; write sector into disk for new directory entry
2014   0C82 FD 27         mov b, g
2015   0C84 38 00 00      mov c, 0
2016   0C87 3B 16 24      mov d, transient_area
2017   0C8A 22 01         mov ah, $01                   ; disk write, 1 sector
2018   0C8C 07 64 04      call ide_write_sect           ; write sector
2019   0C8F 19 01         mov al, 1
2020   0C91 3D 0B 17      mov [sys_echo_on], al ; enable echo
2021   0C94 06            sysret
2022   0C95             
2023   0C95             ;------------------------------------------------------------------------------------------------------;
2024   0C95             ; PWD - PRINT WORKING DIRECTORY
2025   0C95             ;------------------------------------------------------------------------------------------------------;    
2026   0C95             fs_pwd:
2027   0C95 3B 96 1B      mov d, filename
2028   0C98 19 00         mov al, 0
2029   0C9A 3E            mov [d], al                   ; initialize path string 
2030   0C9B 14 1B 17      mov a, [current_dir_id]
2031   0C9E 07 74 07      call fs_dir_id_to_path_E0
2032   0CA1 3B 96 1B      mov d, filename
2033   0CA4 07 CD 0F      call _strrev
2034   0CA7 07 E1 11      call _puts
2035   0CAA 07 8E 11      call printnl
2036   0CAD 06            sysret
2037   0CAE             
2038   0CAE             ;------------------------------------------------------------------------------------------------------;
2039   0CAE             ; get current directory LBA
2040   0CAE             ; A: returned LBA
2041   0CAE             ;------------------------------------------------------------------------------------------------------;
2042   0CAE             cmd_get_curr_dir_LBA:
2043   0CAE 14 1B 17      mov a, [current_dir_id]
2044   0CB1 06            sysret
2045   0CB2             
2046   0CB2             ;------------------------------------------------------------------------------------------------------;
2047   0CB2             ; CAT
2048   0CB2             ; userspace destination data pointer in D
2049   0CB2             ; filename starts at D, but is overwritten after the read is made
2050   0CB2             ;------------------------------------------------------------------------------------------------------;:
2051   0CB2             fs_cat:
2052   0CB2 DA            push d                              ; save userspace file data destination
2053   0CB3 FD 4E         mov si, d
2054   0CB5 FD 4F 16 1C   mov di, user_data
2055   0CB9 38 00 02      mov c, 512
2056   0CBC 04            load                                ; copy filename from user-space
2057   0CBD 29 1B 17      mov b, [current_dir_id]
2058   0CC0 FD 77         inc b                               ; metadata sector
2059   0CC2 38 00 00      mov c, 0                            ; upper LBA = 0
2060   0CC5 22 01         mov ah, $01                  ; 1 sector
2061   0CC7 3B 16 22      mov d, transient_area-512
2062   0CCA 07 3E 04      call ide_read_sect                  ; read directory
2063   0CCD FD 10         cla
2064   0CCF 42 13 17      mov [index], a                      ; reset file counter
2065   0CD2             fs_cat_L1:
2066   0CD2 FD 4E         mov si, d
2067   0CD4 FD 4F 16 1C   mov di, user_data
2068   0CD8 07 24 10      call _strcmp
2069   0CDB C6 F1 0C      je fs_cat_found_entry
2070   0CDE 58 20 00      add d, 32
2071   0CE1 14 13 17      mov a, [index]
2072   0CE4 77            inc a
2073   0CE5 42 13 17      mov [index], a
2074   0CE8 AF 10 00      cmp a, FST_FILES_PER_DIR
2075   0CEB C6 0C 0D      je fs_cat_not_found
2076   0CEE 0A D2 0C      jmp fs_cat_L1
2077   0CF1             fs_cat_found_entry:
2078   0CF1 58 19 00      add d, 25                           ; get to dirID of file in disk
2079   0CF4 2A            mov b, [d]                          ; get LBA
2080   0CF5 FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2081   0CF7 3B 16 24      mov d, transient_area  
2082   0CFA 38 00 00      mov c, 0
2083   0CFD 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2084   0CFF 07 3E 04      call ide_read_sect                  ; read sectors
2085   0D02 F0            pop di                              ; write userspace file data destination to DI
2086   0D03 FD 4D 16 24   mov si, transient_area              ; data origin
2087   0D07 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2088   0D0A 03            store
2089   0D0B 06            sysret
2090   0D0C             fs_cat_not_found:
2091   0D0C E7            pop d
2092   0D0D 06            sysret
2093   0D0E             
2094   0D0E             ;------------------------------------------------------------------------------------------------------;
2095   0D0E             ; RMDIR - remove DIR by dirID
2096   0D0E             ;------------------------------------------------------------------------------------------------------;
2097   0D0E             ; deletes a directory entry in the given directory's file list 
2098   0D0E             ; also deletes the actual directory entry in the FST
2099   0D0E             ; synopsis: rmdir /usr/local/testdir
2100   0D0E             ; B = dirID
2101   0D0E             fs_rmdir:
2102   0D0E FD 79         mov g, b
2103   0D10 11            mov a, b
2104   0D11 07 B0 07      call get_parentID_from_dirID  ; now get the directory's parent, in A
2105   0D14 D7            push a                        ; save dirID
2106   0D15             ; search for directory's entry in the parent's directory then and delete it
2107   0D15 77            inc a                         ; metadata sector
2108   0D16 27            mov b, a
2109   0D17 38 00 00      mov c, 0                      ; upper LBA = 0
2110   0D1A 22 01         mov ah, $01          ;
2111   0D1C 3B 16 24      mov d, transient_area
2112   0D1F 07 3E 04      call ide_read_sect            ; read directory
2113   0D22 FD 10         cla
2114   0D24 42 13 17      mov [index], a                ; reset file counter
2115   0D27 FD 27         mov b, g                      ; retrieve directory's dirID
2116   0D29             fs_rmdir_L1:
2117   0D29 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2118   0D2C B0            cmp a, b                      ; compare dirID's to find the directory
2119   0D2D C6 43 0D      je fs_rmdir_found_entry
2120   0D30 58 20 00      add d, 32
2121   0D33 14 13 17      mov a, [index]
2122   0D36 77            inc a
2123   0D37 42 13 17      mov [index], a
2124   0D3A AF 10 00      cmp a, FST_FILES_PER_DIR
2125   0D3D C6 68 0D      je fs_rmdir_not_found
2126   0D40 0A 29 0D      jmp fs_rmdir_L1
2127   0D43             fs_rmdir_found_entry:
2128   0D43 FD 10         cla
2129   0D45 3E            mov [d], al                   ; make filename NULL
2130   0D46 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2131   0D49 E5            pop b
2132   0D4A FD 77         inc b                         ; metadata sector
2133   0D4C 38 00 00      mov c, 0                      ; upper LBA = 0
2134   0D4F 22 01         mov ah, $01          ; 
2135   0D51 3B 16 24      mov d, transient_area
2136   0D54 07 64 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2137   0D57             
2138   0D57 FD 27         mov b, g
2139   0D59 3B 16 24      mov d, transient_area  
2140   0D5C FD 10         cla
2141   0D5E 3E            mov [d], al                   ; make directory's name header NULL for re-use
2142   0D5F 38 00 00      mov c, 0
2143   0D62 22 01         mov ah, $01                   ; disk write 1 sect
2144   0D64 07 64 04      call ide_write_sect           ; delete directory given by dirID in B
2145   0D67 06            sysret
2146   0D68             fs_rmdir_not_found:
2147   0D68 E5            pop b
2148   0D69 06            sysret
2149   0D6A             
2150   0D6A             ;------------------------------------------------------------------------------------------------------;
2151   0D6A             ; RM - remove file
2152   0D6A             ;------------------------------------------------------------------------------------------------------;
2153   0D6A             ; frees up the data sectors for the file further down the disk
2154   0D6A             ; deletes file entry in the directory's file list 
2155   0D6A             fs_rm:
2156   0D6A FD 4E         mov si, d
2157   0D6C FD 4F 16 1C   mov di, user_data
2158   0D70 38 00 02      mov c, 512
2159   0D73 04            load                          ; load data from user-space
2160   0D74 14 1B 17      mov a, [current_dir_id]
2161   0D77 77            inc a                         ; metadata sector
2162   0D78 27            mov b, a
2163   0D79 38 00 00      mov c, 0                      ; upper LBA = 0
2164   0D7C 22 01         mov ah, $01                  ; 1 sector
2165   0D7E 3B 16 24      mov d, transient_area
2166   0D81 07 3E 04      call ide_read_sect            ; read directory
2167   0D84 10 00 00      mov a, 0
2168   0D87 42 13 17      mov [index], a                ; reset file counter
2169   0D8A             fs_rm_L1:
2170   0D8A FD 4E         mov si, d
2171   0D8C FD 4F 16 1C   mov di, user_data
2172   0D90 07 24 10      call _strcmp
2173   0D93 C6 A9 0D      je fs_rm_found_entry
2174   0D96 58 20 00      add d, 32
2175   0D99 14 13 17      mov a, [index]
2176   0D9C 77            inc a
2177   0D9D 42 13 17      mov [index], a
2178   0DA0 AF 10 00      cmp a, FST_FILES_PER_DIR
2179   0DA3 C6 D1 0D      je fs_rm_not_found
2180   0DA6 0A 8A 0D      jmp fs_rm_L1
2181   0DA9             fs_rm_found_entry:
2182   0DA9 2B 19 00      mov b, [d + 25]               ; get LBA
2183   0DAC FD 79         mov g, b                      ; save LBA
2184   0DAE 19 00         mov al, 0
2185   0DB0 3E            mov [d], al                   ; make file entry NULL
2186   0DB1 14 1B 17      mov a, [current_dir_id]
2187   0DB4 77            inc a                         ; metadata sector
2188   0DB5 27            mov b, a
2189   0DB6 38 00 00      mov c, 0                      ; upper LBA = 0
2190   0DB9 22 01         mov ah, $01                   ; disk write
2191   0DBB 3B 16 24      mov d, transient_area
2192   0DBE 07 64 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2193   0DC1 3B 16 24      mov d, transient_area  
2194   0DC4 19 00         mov al, 0
2195   0DC6 3E            mov [d], al                   ; make file's data header NULL for re-use
2196   0DC7 38 00 00      mov c, 0
2197   0DCA FD 27         mov b, g                      ; get data header LBA
2198   0DCC 22 01         mov ah, $01                   ; disk write 1 sect
2199   0DCE 07 64 04      call ide_write_sect           ; write sector
2200   0DD1             fs_rm_not_found:  
2201   0DD1 06            sysret  
2202   0DD2             
2203   0DD2             ;------------------------------------------------------------------------------------------------------;
2204   0DD2             ; mv - move / change file name
2205   0DD2             ;------------------------------------------------------------------------------------------------------;
2206   0DD2             fs_mv:
2207   0DD2 FD 4E         mov si, d
2208   0DD4 FD 4F 16 1C   mov di, user_data
2209   0DD8 38 00 02      mov c, 512
2210   0DDB 04            load                          ; load data from user-space
2211   0DDC 14 1B 17      mov a, [current_dir_id]
2212   0DDF 77            inc a                         ; metadata sector
2213   0DE0 27            mov b, a  
2214   0DE1 38 00 00      mov c, 0                      ; upper LBA = 0
2215   0DE4 22 01         mov ah, $01                  ; 1 sector
2216   0DE6 3B 16 24      mov d, transient_area
2217   0DE9 07 3E 04      call ide_read_sect            ; read directory
2218   0DEC FD 10         cla
2219   0DEE 42 13 17      mov [index], a                ; reset file counter
2220   0DF1             fs_mv_L1:
2221   0DF1 FD 4E         mov si, d
2222   0DF3 FD 4F 16 1C   mov di, user_data
2223   0DF7 07 24 10      call _strcmp
2224   0DFA C6 10 0E      je fs_mv_found_entry
2225   0DFD 58 20 00      add d, 32
2226   0E00 14 13 17      mov a, [index]
2227   0E03 77            inc a
2228   0E04 42 13 17      mov [index], a
2229   0E07 AF 10 00      cmp a, FST_FILES_PER_DIR
2230   0E0A C6 42 0E      je fs_mv_not_found
2231   0E0D 0A F1 0D      jmp fs_mv_L1
2232   0E10             fs_mv_found_entry:  
2233   0E10 DA            push d
2234   0E11 FD 4D 96 1C   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2235   0E15 FD 50         mov di, d
2236   0E17 07 39 10      call _strcpy  
2237   0E1A 38 00 00      mov c, 0
2238   0E1D 3B 16 24      mov d, transient_area
2239   0E20 22 01         mov ah, $01                   ; disk write 1 sect
2240   0E22 07 64 04      call ide_write_sect           ; write sector
2241   0E25 E7            pop d
2242   0E26             ;; need to check whether its a dir or a file here ;;;
2243   0E26 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2244   0E29 22 01         mov ah, $01
2245   0E2B 3B 16 24      mov d, transient_area
2246   0E2E 38 00 00      mov c, 0
2247   0E31 07 3E 04      call ide_read_sect            ; read directory entry
2248   0E34 FD 4D 96 1C   mov si, user_data + 128
2249   0E38 FD 50         mov di, d
2250   0E3A 07 39 10      call _strcpy                  ; change directory's name
2251   0E3D 22 01         mov ah, $01
2252   0E3F 07 64 04      call ide_write_sect           ; rewrite directory back to disk
2253   0E42             fs_mv_not_found:
2254   0E42 06            sysret
2255   0E43             
2256   0E43             
2257   0E43             ;----------------------------------------------------------------------------------------------------;
2258   0E43             ; Process Index in A
2259   0E43             ;----------------------------------------------------------------------------------------------------;
2260   0E43             find_free_proc:
2261   0E43 FD 4D 87 19   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2262   0E47             find_free_proc_L0:
2263   0E47 F6            lodsb                               ; get process state
2264   0E48 B9 00         cmp al, 0
2265   0E4A C6 50 0E      je find_free_proc_free              ; if free, jump
2266   0E4D 0A 47 0E      jmp find_free_proc_L0               ; else, goto next
2267   0E50             find_free_proc_free:
2268   0E50 4E            mov a, si
2269   0E51 5F 87 19      sub a, 1 + proc_availab_table       ; get process index
2270   0E54 09            ret
2271   0E55               
2272   0E55             
2273   0E55             ;----------------------------------------------------------------------------------------------------;
2274   0E55             ; Process Index in AL
2275   0E55             ;----------------------------------------------------------------------------------------------------;
2276   0E55             proc_memory_map:
2277   0E55 22 00         mov ah, 0
2278   0E57 27            mov b, a                      ; page in BL, 0 in BH
2279   0E58 FD 9D 05      shl a, 5                      ; multiply by 32
2280   0E5B 39            mov c, a                      ; save in C
2281   0E5C 57 20 00      add c, 32
2282   0E5F             proc_memory_map_L0:
2283   0E5F 02            pagemap
2284   0E60 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2285   0E63 53 01 00      add a, 1                      ; increase both 
2286   0E66 B1            cmp a, c                      ; check to see if we reached the end of memory
2287   0E67 C7 5F 0E      jne proc_memory_map_L0
2288   0E6A 09            ret
2289   0E6B               
2290   0E6B             
2291   0E6B             syscall_terminate_proc:
2292   0E6B 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2293   0E6E                                                    ; since they will not be used for anything here.
2294   0E6E 1D 12 17      mov al, [active_proc_index]
2295   0E71 22 00         mov ah, 0  
2296   0E73 FD 9D 05      shl a, 5                             ; x32
2297   0E76 53 96 19      add a, proc_names
2298   0E79 3C            mov d, a
2299   0E7A 19 00         mov al, 0
2300   0E7C 3E            mov [d], al                           ; nullify process name
2301   0E7D             
2302   0E7D 1D 12 17      mov al, [active_proc_index]
2303   0E80 22 00         mov ah, 0  
2304   0E82 3C            mov d, a
2305   0E83 19 00         mov al, 0
2306   0E85 3F 86 19      mov [d + proc_availab_table], al    ; make process empty again
2307   0E88               
2308   0E88 1D 11 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2309   0E8B 80            dec al
2310   0E8C 3D 11 17      mov [nbr_active_procs], al
2311   0E8F             
2312   0E8F             ; now load the shell process again
2313   0E8F 19 02         mov al, 2                           ; next process = process 2 = shell
2314   0E91 3D 12 17      mov [active_proc_index], al         ; set next active proc
2315   0E94             
2316   0E94             ; calculate LUT entry for next process
2317   0E94 22 00         mov ah, 0
2318   0E96 FD 99         shl a                               ; x2
2319   0E98 B7 61 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2320   0E9B               
2321   0E9B 4D            mov si, a                           ; source is proc state block
2322   0E9C 48            mov a, sp
2323   0E9D 5F 13 00      sub a, 19
2324   0EA0 4F            mov di, a                           ; destination is kernel stack
2325   0EA1             ; restore SP
2326   0EA1 7D            dec a
2327   0EA2 47            mov sp, a
2328   0EA3 38 14 00      mov c, 20
2329   0EA6 FD F5         rep movsb
2330   0EA8             ; set VM process
2331   0EA8 1D 12 17      mov al, [active_proc_index]
2332   0EAB 01            setptb
2333   0EAC                 
2334   0EAC 4C            popa
2335   0EAD 06            sysret
2336   0EAE             
2337   0EAE             syscall_pause_proc:
2338   0EAE             ; save all registers into kernel stack
2339   0EAE 4B            pusha
2340   0EAF 22 00         mov ah, 0
2341   0EB1 1D 12 17      mov al, [active_proc_index]
2342   0EB4 FD 99         shl a              ; x2
2343   0EB6 B7 61 0F      mov a, [proc_table_convert + a]   ; get process state start index
2344   0EB9                 
2345   0EB9 4F            mov di, a
2346   0EBA 48            mov a, sp
2347   0EBB 77            inc a
2348   0EBC 4D            mov si, a
2349   0EBD 38 14 00      mov c, 20
2350   0EC0 FD F5         rep movsb                         ; save process state!
2351   0EC2             ; restore kernel stack position to point before interrupt arrived
2352   0EC2 51 14 00      add sp, 20
2353   0EC5             ; now load the shell process again
2354   0EC5 19 02         mov al, 2                         ; next process = process 2 = shell
2355   0EC7 3D 12 17      mov [active_proc_index], al       ; set next active proc
2356   0ECA             
2357   0ECA             ; calculate LUT entry for next process
2358   0ECA 22 00         mov ah, 0
2359   0ECC FD 99         shl a                             ; x2
2360   0ECE B7 61 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2361   0ED1               
2362   0ED1 4D            mov si, a                         ; source is proc state block
2363   0ED2 48            mov a, sp
2364   0ED3 5F 13 00      sub a, 19
2365   0ED6 4F            mov di, a                         ; destination is kernel stack
2366   0ED7             ; restore SP
2367   0ED7 7D            dec a
2368   0ED8 47            mov sp, a
2369   0ED9 38 14 00      mov c, 20
2370   0EDC FD F5         rep movsb
2371   0EDE             ; set VM process
2372   0EDE 1D 12 17      mov al, [active_proc_index]
2373   0EE1 01            setptb
2374   0EE2                 
2375   0EE2 4C            popa
2376   0EE3 06            sysret
2377   0EE4             
2378   0EE4             ;----------------------------------------------------------------------------------------------------;
2379   0EE4             ; create a new process
2380   0EE4             ; D = path of the process file to be createed
2381   0EE4             ; B = arguments ptr
2382   0EE4             ;----------------------------------------------------------------------------------------------------;
2383   0EE4             syscall_create_proc:
2384   0EE4             ; we save the active process first  
2385   0EE4 4B            pusha
2386   0EE5 22 00         mov ah, 0
2387   0EE7 1D 12 17      mov al, [active_proc_index]
2388   0EEA FD 99         shl a              ; x2
2389   0EEC B7 61 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2390   0EEF               
2391   0EEF 4F            mov di, a
2392   0EF0 48            mov a, sp
2393   0EF1 77            inc a
2394   0EF2 4D            mov si, a
2395   0EF3 38 14 00      mov c, 20
2396   0EF6 FD F5         rep movsb                          ; save process state!
2397   0EF8             ; restore kernel stack position to point before interrupt arrived
2398   0EF8 51 14 00      add sp, 20
2399   0EFB               
2400   0EFB FD 4E         mov si, d                          ; copy the file path
2401   0EFD FD 4F 16 1C   mov di, user_data
2402   0F01 38 00 02      mov c, 512
2403   0F04 04            load
2404   0F05 11            mov a, b
2405   0F06 4D            mov si, a                          ; copy the arguments
2406   0F07 FD 4F 16 22   mov di, scrap_sector
2407   0F0B 38 00 02      mov c, 512
2408   0F0E 04            load
2409   0F0F 07 F6 08      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2410   0F12                                                  ; the file data is loaded into transient_area
2411   0F12             ; now we allocate a new process  
2412   0F12 07 43 0E      call find_free_proc                ; index in A
2413   0F15 01            setptb 
2414   0F16 07 55 0E      call proc_memory_map               ; map process memory pages
2415   0F19             ; copy arguments into process's memory
2416   0F19 FD 4D 16 22   mov si, scrap_sector
2417   0F1D FD 4F 00 00   mov di, 0
2418   0F21 38 00 02      mov c, 512
2419   0F24 03            store
2420   0F25             ; now copy process binary data into process's memory
2421   0F25 FD 4D 16 24   mov si, transient_area
2422   0F29 FD 4F 00 04   mov di, text_org              ; code origin address for all user processes
2423   0F2D 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2424   0F30 03            store                              ; copy process data
2425   0F31                 
2426   0F31 07 43 0E      call find_free_proc                ; index in A
2427   0F34 3D 12 17      mov [active_proc_index], al        ; set new active process
2428   0F37 FD 9D 05      shl a, 5                           ; x32
2429   0F3A 53 96 19      add a, proc_names
2430   0F3D 4F            mov di, a
2431   0F3E FD 4D 16 1C   mov si, user_data                  ; copy and store process filename
2432   0F42 07 39 10      call _strcpy
2433   0F45               
2434   0F45 07 43 0E      call find_free_proc                ; index in A
2435   0F48 3C            mov d, a
2436   0F49 19 01         mov al, 1
2437   0F4B 3F 86 19      mov [d + proc_availab_table], al   ; make process busy
2438   0F4E               
2439   0F4E 1D 11 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2440   0F51 7A            inc al
2441   0F52 3D 11 17      mov [nbr_active_procs], al
2442   0F55             ; launch process
2443   0F55 FD D7 FF FF   push word $FFFF 
2444   0F59 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2445   0F5C FD D7 00 04   push word text_org
2446   0F60 06            sysret
2447   0F61             
2448   0F61             proc_table_convert:
2449   0F61 46 18         .dw proc_state_table + 0
2450   0F63 5A 18         .dw proc_state_table + 20
2451   0F65 6E 18         .dw proc_state_table + 40
2452   0F67 82 18         .dw proc_state_table + 60
2453   0F69 96 18         .dw proc_state_table + 80
2454   0F6B AA 18         .dw proc_state_table + 100
2455   0F6D BE 18         .dw proc_state_table + 120
2456   0F6F D2 18         .dw proc_state_table + 140
2457   0F71               
2458   0F71             ;----------------------------------------------------------------------------------------------;
2459   0F71             ; GET HEX FILE
2460   0F71             ; di = destination address
2461   0F71             ; return length in bytes in C
2462   0F71             ;----------------------------------------------------------------------------------------------;
2463   0F71             _load_hex:
2464   0F71 D7            push a
2465   0F72 D8            push b
2466   0F73 DA            push d
2467   0F74 E2            push si
2468   0F75 E3            push di
2469   0F76 38 00 00      mov c, 0
2470   0F79 50            mov a, di
2471   0F7A 3C            mov d, a          ; start of string data block
2472   0F7B 07 BC 10      call _gets        ; get program string
2473   0F7E               ;call _puts        ; reprint to screen
2474   0F7E 4D            mov si, a
2475   0F7F             __load_hex_loop:
2476   0F7F F6            lodsb             ; load from [SI] to AL
2477   0F80 B9 00         cmp al, 0         ; check if ASCII 0
2478   0F82 C6 90 0F      jz __load_hex_ret
2479   0F85 36            mov bh, al
2480   0F86 F6            lodsb
2481   0F87 2F            mov bl, al
2482   0F88 07 72 10      call _atoi        ; convert ASCII byte in B to int (to AL)
2483   0F8B F7            stosb             ; store AL to [DI]
2484   0F8C 78            inc c
2485   0F8D 0A 7F 0F      jmp __load_hex_loop
2486   0F90             __load_hex_ret:
2487   0F90 F0            pop di
2488   0F91 EF            pop si
2489   0F92 E7            pop d
2490   0F93 E5            pop b
2491   0F94 E4            pop a
2492   0F95 09            ret
2493   0F96             
2494   0F96             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2495   0F96             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2496   0F96             ; for each entry insIDE DIRECTORY:
2497   0F96             ;  if entry is a file:
2498   0F96             ;    compare filename to searched filename
2499   0F96             ;    if filenames are the same, print filename
2500   0F96             ;  else if entry is a directory:
2501   0F96             ;    cd to the given directory
2502   0F96             ;    recursively call cmd_find
2503   0F96             ;    cd outsIDE previous directory
2504   0F96             ;  if current entry == last entry, return
2505   0F96             ; endfor
2506   0F96             f_find:
2507   0F96 09            ret
2508   0F97             
2509   0F97             
2510   0F97             ; ---------------------------------------------------------------------
2511   0F97             ; KERNEL RESET VECTOR
2512   0F97             ; ---------------------------------------------------------------------
2513   0F97             kernel_reset_vector:  
2514   0F97 FD 49 FF F7   mov bp, STACK_BEGIN
2515   0F9B FD 47 FF F7   mov sp, STACK_BEGIN
2516   0F9F               
2517   0F9F 19 81         mov al, %10000001
2518   0FA1 FD 0F         stomsk                        ; mask out timer interrupt for now (only allow UART to interrupt)
2519   0FA3 FD 0C         sti  
2520   0FA5             
2521   0FA5 0C            lodstat
2522   0FA6 87 DF         and al, %11011111             ; disable display register loading
2523   0FA8 0D            stostat
2524   0FA9               
2525   0FA9             ; reset fifo pointers
2526   0FA9 10 16 1E      mov a, fifo
2527   0FAC 3B 17 17      mov d, fifo_in
2528   0FAF 43            mov [d], a
2529   0FB0 3B 19 17      mov d, fifo_out
2530   0FB3 43            mov [d], a  
2531   0FB4 19 02         mov al, 2
2532   0FB6 05 03         syscall sys_io                ; enable uart in interrupt mode
2533   0FB8               
2534   0FB8 3B 5D 17      mov d, s_kernel_started
2535   0FBB 07 E1 11      call _puts
2536   0FBE             
2537   0FBE 19 10         mov al, 16
2538   0FC0 05 04         syscall sys_filesystem        ; set root dirID
2539   0FC2             
2540   0FC2 3B 7A 17      mov d, s_prompt_init
2541   0FC5 07 E1 11      call _puts
2542   0FC8 3B 1D 17      mov d, s_init_path
2543   0FCB 05 05         syscall sys_create_proc              ; launch init as a new process
2544   0FCD             
2545   0FCD             
2546   0FCD             ; FILE INCLUDES
2547   0FCD             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  0FCD             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0FCD             IDE_buffer       .EQU  $8204
0003+  0FCD             boot_origin      .EQU  $8004
0004+  0FCD             bios_uart        .EQU  $0002
0005+  0FCD             bios_ide         .EQU  $0003
2548   0FCD             .include "lib/stdio.asm"
0001+  0FCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0FCD             ; stdio.s
0003+  0FCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0FCD             .include "lib/string.asm"
0001++ 0FCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0FCD             ; string.s
0003++ 0FCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0FCD             
0005++ 0FCD             
0006++ 0FCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0FCD             ; _strrev
0008++ 0FCD             ; reverse a string
0009++ 0FCD             ; D = string address
0010++ 0FCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0FCD             ; 01234
0012++ 0FCD             _strrev:
0013++ 0FCD 4B          	pusha
0014++ 0FCE 07 14 10    	call _strlen	; length in C
0015++ 0FD1 12          	mov a, c
0016++ 0FD2 AF 01 00    	cmp a, 1
0017++ 0FD5 D0 EF 0F    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0FD8 7D          	dec a
0019++ 0FD9 FD 4E       	mov si, d	; beginning of string
0020++ 0FDB FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0FDD 59          	add d, a	; end of string
0022++ 0FDE 12          	mov a, c
0023++ 0FDF FD 9B       	shr a		; divide by 2
0024++ 0FE1 39          	mov c, a	; C now counts the steps
0025++ 0FE2             _strrev_L0:
0026++ 0FE2 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0FE3 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0FE4 3E          	mov [d], al	; store left char into right side
0029++ 0FE5 1B          	mov al, bl
0030++ 0FE6 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0FE7 7E          	dec c
0032++ 0FE8 7F          	dec d
0033++ 0FE9 C2 00 00    	cmp c, 0
0034++ 0FEC C7 E2 0F    	jne _strrev_L0
0035++ 0FEF             _strrev_end:
0036++ 0FEF 4C          	popa
0037++ 0FF0 09          	ret
0038++ 0FF1             	
0039++ 0FF1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0FF1             ; _strchr
0041++ 0FF1             ; search string in D for char in AL
0042++ 0FF1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0FF1             _strchr:
0044++ 0FF1             _strchr_L0:
0045++ 0FF1 32          	mov bl, [d]
0046++ 0FF2 C1 00       	cmp bl, 0
0047++ 0FF4 C6 FF 0F    	je _strchr_end
0048++ 0FF7 BA          	cmp al, bl
0049++ 0FF8 C6 FF 0F    	je _strchr_end
0050++ 0FFB 79          	inc d
0051++ 0FFC 0A F1 0F    	jmp _strchr_L0
0052++ 0FFF             _strchr_end:
0053++ 0FFF 1B          	mov al, bl
0054++ 1000 09          	ret
0055++ 1001             
0056++ 1001             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1001             ; _strstr
0058++ 1001             ; find sub-string
0059++ 1001             ; str1 in SI
0060++ 1001             ; str2 in DI
0061++ 1001             ; SI points to end of source string
0062++ 1001             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1001             _strstr:
0064++ 1001 DB          	push al
0065++ 1002 DA          	push d
0066++ 1003 E3          	push di
0067++ 1004             _strstr_loop:
0068++ 1004 F3          	cmpsb					; compare a byte of the strings
0069++ 1005 C7 10 10    	jne _strstr_ret
0070++ 1008 FC 00 00    	lea d, [di + 0]
0071++ 100B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 100D C7 04 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1010             _strstr_ret:
0074++ 1010 F0          	pop di
0075++ 1011 E7          	pop d
0076++ 1012 E8          	pop al
0077++ 1013 09          	ret
0078++ 1014             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1014             ; length of null terminated string
0080++ 1014             ; result in C
0081++ 1014             ; pointer in D
0082++ 1014             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1014             _strlen:
0084++ 1014 DA          	push d
0085++ 1015 38 00 00    	mov c, 0
0086++ 1018             _strlen_L1:
0087++ 1018 BD 00       	cmp byte [d], 0
0088++ 101A C6 22 10    	je _strlen_ret
0089++ 101D 79          	inc d
0090++ 101E 78          	inc c
0091++ 101F 0A 18 10    	jmp _strlen_L1
0092++ 1022             _strlen_ret:
0093++ 1022 E7          	pop d
0094++ 1023 09          	ret
0095++ 1024             
0096++ 1024             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1024             ; STRCMP
0098++ 1024             ; compare two strings
0099++ 1024             ; str1 in SI
0100++ 1024             ; str2 in DI
0101++ 1024             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1024             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1024             _strcmp:
0104++ 1024 DB          	push al
0105++ 1025 DA          	push d
0106++ 1026 E3          	push di
0107++ 1027 E2          	push si
0108++ 1028             _strcmp_loop:
0109++ 1028 F3          	cmpsb					; compare a byte of the strings
0110++ 1029 C7 34 10    	jne _strcmp_ret
0111++ 102C FB FF FF    	lea d, [si +- 1]
0112++ 102F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1031 C7 28 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1034             _strcmp_ret:
0115++ 1034 EF          	pop si
0116++ 1035 F0          	pop di
0117++ 1036 E7          	pop d
0118++ 1037 E8          	pop al
0119++ 1038 09          	ret
0120++ 1039             
0121++ 1039             
0122++ 1039             ; STRCPY
0123++ 1039             ; copy null terminated string from SI to DI
0124++ 1039             ; source in SI
0125++ 1039             ; destination in DI
0126++ 1039             _strcpy:
0127++ 1039 E2          	push si
0128++ 103A E3          	push di
0129++ 103B DB          	push al
0130++ 103C             _strcpy_L1:
0131++ 103C F6          	lodsb
0132++ 103D F7          	stosb
0133++ 103E B9 00       	cmp al, 0
0134++ 1040 C7 3C 10    	jne _strcpy_L1
0135++ 1043             _strcpy_end:
0136++ 1043 E8          	pop al
0137++ 1044 F0          	pop di
0138++ 1045 EF          	pop si
0139++ 1046 09          	ret
0140++ 1047             
0141++ 1047             ; STRCAT
0142++ 1047             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1047             ; source in SI
0144++ 1047             ; destination in DI
0145++ 1047             _strcat:
0146++ 1047 E2          	push si
0147++ 1048 E3          	push di
0148++ 1049 D7          	push a
0149++ 104A DA          	push d
0150++ 104B 50          	mov a, di
0151++ 104C 3C          	mov d, a
0152++ 104D             _strcat_goto_end_L1:
0153++ 104D BD 00       	cmp byte[d], 0
0154++ 104F C6 56 10    	je _strcat_start
0155++ 1052 79          	inc d
0156++ 1053 0A 4D 10    	jmp _strcat_goto_end_L1
0157++ 1056             _strcat_start:
0158++ 1056 FD 50       	mov di, d
0159++ 1058             _strcat_L1:
0160++ 1058 F6          	lodsb
0161++ 1059 F7          	stosb
0162++ 105A B9 00       	cmp al, 0
0163++ 105C C7 58 10    	jne _strcat_L1
0164++ 105F             _strcat_end:
0165++ 105F E7          	pop d
0166++ 1060 E4          	pop a
0167++ 1061 F0          	pop di
0168++ 1062 EF          	pop si
0169++ 1063 09          	ret
0170++ 1064             
0171++ 1064             
0005+  1064             
0006+  1064             
0007+  1064             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1064             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  1064             ; ASCII in BL
0010+  1064             ; result in AL
0011+  1064             ; ascii for F = 0100 0110
0012+  1064             ; ascii for 9 = 0011 1001
0013+  1064             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1064             hex_ascii_encode:
0015+  1064 1B            mov al, bl
0016+  1065 93 40         test al, $40        ; test if letter or number
0017+  1067 C7 6D 10      jnz hex_letter
0018+  106A 87 0F         and al, $0F        ; get number
0019+  106C 09            ret
0020+  106D             hex_letter:
0021+  106D 87 0F         and al, $0F        ; get letter
0022+  106F 6A 09         add al, 9
0023+  1071 09            ret
0024+  1072             
0025+  1072             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1072             ; ATOI
0027+  1072             ; 2 letter hex string in B
0028+  1072             ; 8bit integer returned in AL
0029+  1072             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1072             _atoi:
0031+  1072 D8            push b
0032+  1073 07 64 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  1076 30            mov bl, bh
0034+  1077 DB            push al          ; save a
0035+  1078 07 64 10      call hex_ascii_encode
0036+  107B EA            pop bl  
0037+  107C FD 9E 04      shl al, 4
0038+  107F 8C            or al, bl
0039+  1080 E5            pop b
0040+  1081 09            ret  
0041+  1082             
0042+  1082             
0043+  1082             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1082             ; scanf
0045+  1082             ; no need for explanations!
0046+  1082             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1082             scanf:
0048+  1082 09            ret
0049+  1083             
0050+  1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1083             ; ITOA
0052+  1083             ; 8bit value in BL
0053+  1083             ; 2 byte ASCII result in A
0054+  1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1083             _itoa:
0056+  1083 DA            push d
0057+  1084 D8            push b
0058+  1085 A7 00         mov bh, 0
0059+  1087 FD A4 04      shr bl, 4  
0060+  108A 74            mov d, b
0061+  108B 1F 1D 13      mov al, [d + s_hex_digits]
0062+  108E 23            mov ah, al
0063+  108F               
0064+  108F E5            pop b
0065+  1090 D8            push b
0066+  1091 A7 00         mov bh, 0
0067+  1093 FD 87 0F      and bl, $0F
0068+  1096 74            mov d, b
0069+  1097 1F 1D 13      mov al, [d + s_hex_digits]
0070+  109A E5            pop b
0071+  109B E7            pop d
0072+  109C 09            ret
0073+  109D             
0074+  109D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  109D             ; HEX STRING TO BINARY
0076+  109D             ; di = destination address
0077+  109D             ; si = source
0078+  109D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  109D             _hex_to_int:
0080+  109D             _hex_to_int_L1:
0081+  109D F6            lodsb          ; load from [SI] to AL
0082+  109E B9 00         cmp al, 0        ; check if ASCII 0
0083+  10A0 C6 AD 10      jz _hex_to_int_ret
0084+  10A3 36            mov bh, al
0085+  10A4 F6            lodsb
0086+  10A5 2F            mov bl, al
0087+  10A6 07 72 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  10A9 F7            stosb          ; store AL to [DI]
0089+  10AA 0A 9D 10      jmp _hex_to_int_L1
0090+  10AD             _hex_to_int_ret:
0091+  10AD 09            ret    
0092+  10AE             
0093+  10AE             
0094+  10AE             
0095+  10AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  10AE             ; GETCHAR
0097+  10AE             ; char in ah
0098+  10AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  10AE             getch:
0100+  10AE DB            push al
0101+  10AF             getch_retry:
0102+  10AF 19 01         mov al, 1
0103+  10B1 05 03         syscall sys_io      ; receive in AH
0104+  10B3 E8            pop al
0105+  10B4 09            ret
0106+  10B5             
0107+  10B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  10B5             ; PUTCHAR
0109+  10B5             ; char in ah
0110+  10B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  10B5             _putchar:
0112+  10B5 DB            push al
0113+  10B6 19 00         mov al, 0
0114+  10B8 05 03         syscall sys_io      ; char in AH
0115+  10BA E8            pop al
0116+  10BB 09            ret
0117+  10BC             
0118+  10BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  10BC             ;; INPUT A STRING
0120+  10BC             ;; terminates with null
0121+  10BC             ;; pointer in D
0122+  10BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  10BC             _gets:
0124+  10BC D7            push a
0125+  10BD DA            push d
0126+  10BE             _gets_loop:
0127+  10BE 19 01         mov al, 1
0128+  10C0 05 03         syscall sys_io      ; receive in AH
0129+  10C2 76 1B         cmp ah, 27
0130+  10C4 C6 E5 10      je _gets_ansi_esc
0131+  10C7 76 0A         cmp ah, $0A        ; LF
0132+  10C9 C6 41 11      je _gets_end
0133+  10CC 76 0D         cmp ah, $0D        ; CR
0134+  10CE C6 41 11      je _gets_end
0135+  10D1 76 5C         cmp ah, $5C        ; '\\'
0136+  10D3 C6 07 11      je _gets_escape
0137+  10D6 76 08         cmp ah, $08      ; check for backspace
0138+  10D8 C6 E1 10      je _gets_backspace
0139+  10DB 1A            mov al, ah
0140+  10DC 3E            mov [d], al
0141+  10DD 79            inc d
0142+  10DE 0A BE 10      jmp _gets_loop
0143+  10E1             _gets_backspace:
0144+  10E1 7F            dec d
0145+  10E2 0A BE 10      jmp _gets_loop
0146+  10E5             _gets_ansi_esc:
0147+  10E5 19 01         mov al, 1
0148+  10E7 05 03         syscall sys_io        ; receive in AH without echo
0149+  10E9 76 5B         cmp ah, '['
0150+  10EB C7 BE 10      jne _gets_loop
0151+  10EE 19 01         mov al, 1
0152+  10F0 05 03         syscall sys_io          ; receive in AH without echo
0153+  10F2 76 44         cmp ah, 'D'
0154+  10F4 C6 FF 10      je _gets_left_arrow
0155+  10F7 76 43         cmp ah, 'C'
0156+  10F9 C6 03 11      je _gets_right_arrow
0157+  10FC 0A BE 10      jmp _gets_loop
0158+  10FF             _gets_left_arrow:
0159+  10FF 7F            dec d
0160+  1100 0A BE 10      jmp _gets_loop
0161+  1103             _gets_right_arrow:
0162+  1103 79            inc d
0163+  1104 0A BE 10      jmp _gets_loop
0164+  1107             _gets_escape:
0165+  1107 19 01         mov al, 1
0166+  1109 05 03         syscall sys_io      ; receive in AH
0167+  110B 76 6E         cmp ah, 'n'
0168+  110D C6 2C 11      je _gets_LF
0169+  1110 76 72         cmp ah, 'r'
0170+  1112 C6 33 11      je _gets_CR
0171+  1115 76 30         cmp ah, '0'
0172+  1117 C6 3A 11      je _gets_NULL
0173+  111A 76 5C         cmp ah, $5C  ; '\'
0174+  111C C6 25 11      je _gets_slash
0175+  111F 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  1120 3E            mov [d], al
0177+  1121 79            inc d
0178+  1122 0A BE 10      jmp _gets_loop
0179+  1125             _gets_slash:
0180+  1125 19 5C         mov al, $5C
0181+  1127 3E            mov [d], al
0182+  1128 79            inc d
0183+  1129 0A BE 10      jmp _gets_loop
0184+  112C             _gets_LF:
0185+  112C 19 0A         mov al, $0A
0186+  112E 3E            mov [d], al
0187+  112F 79            inc d
0188+  1130 0A BE 10      jmp _gets_loop
0189+  1133             _gets_CR:
0190+  1133 19 0D         mov al, $0D
0191+  1135 3E            mov [d], al
0192+  1136 79            inc d
0193+  1137 0A BE 10      jmp _gets_loop
0194+  113A             _gets_NULL:
0195+  113A 19 00         mov al, $00
0196+  113C 3E            mov [d], al
0197+  113D 79            inc d
0198+  113E 0A BE 10      jmp _gets_loop
0199+  1141             _gets_end:
0200+  1141 19 00         mov al, 0
0201+  1143 3E            mov [d], al        ; terminate string
0202+  1144 E7            pop d
0203+  1145 E4            pop a
0204+  1146 09            ret
0205+  1147             
0206+  1147             
0207+  1147             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1147             ;; INPUT TEXT
0209+  1147             ;; terminated with CTRL+D
0210+  1147             ;; pointer in D
0211+  1147             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1147             _gettxt:
0213+  1147 D7            push a
0214+  1148 DA            push d
0215+  1149             _gettxt_loop:
0216+  1149 19 01         mov al, 1
0217+  114B 05 03         syscall sys_io      ; receive in AH
0218+  114D 76 04         cmp ah, 4      ; EOT
0219+  114F C6 88 11      je _gettxt_end
0220+  1152 76 08         cmp ah, $08      ; check for backspace
0221+  1154 C6 84 11      je _gettxt_backspace
0222+  1157 76 5C         cmp ah, $5C        ; '\'
0223+  1159 C6 62 11      je _gettxt_escape
0224+  115C 1A            mov al, ah
0225+  115D 3E            mov [d], al
0226+  115E 79            inc d
0227+  115F 0A 49 11      jmp _gettxt_loop
0228+  1162             _gettxt_escape:
0229+  1162 19 01         mov al, 1
0230+  1164 05 03         syscall sys_io      ; receive in AH
0231+  1166 76 6E         cmp ah, 'n'
0232+  1168 C6 76 11      je _gettxt_LF
0233+  116B 76 72         cmp ah, 'r'
0234+  116D C6 7D 11      je _gettxt_CR
0235+  1170 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  1171 3E            mov [d], al
0237+  1172 79            inc d
0238+  1173 0A 49 11      jmp _gettxt_loop
0239+  1176             _gettxt_LF:
0240+  1176 19 0A         mov al, $0A
0241+  1178 3E            mov [d], al
0242+  1179 79            inc d
0243+  117A 0A 49 11      jmp _gettxt_loop
0244+  117D             _gettxt_CR:
0245+  117D 19 0D         mov al, $0D
0246+  117F 3E            mov [d], al
0247+  1180 79            inc d
0248+  1181 0A 49 11      jmp _gettxt_loop
0249+  1184             _gettxt_backspace:
0250+  1184 7F            dec d
0251+  1185 0A 49 11      jmp _gettxt_loop
0252+  1188             _gettxt_end:
0253+  1188 19 00         mov al, 0
0254+  118A 3E            mov [d], al        ; terminate string
0255+  118B E7            pop d
0256+  118C E4            pop a
0257+  118D 09            ret
0258+  118E             
0259+  118E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  118E             ; PRINT NEW LINE
0261+  118E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  118E             printnl:
0263+  118E D7            push a
0264+  118F 10 00 0A      mov a, $0A00
0265+  1192 05 03         syscall sys_io
0266+  1194 10 00 0D      mov a, $0D00
0267+  1197 05 03         syscall sys_io
0268+  1199 E4            pop a
0269+  119A 09            ret
0270+  119B             
0271+  119B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  119B             ; _strtoint
0273+  119B             ; 4 digit hex string number in d
0274+  119B             ; integer returned in A
0275+  119B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  119B             _strtointx:
0277+  119B D8            push b
0278+  119C 32            mov bl, [d]
0279+  119D 37            mov bh, bl
0280+  119E 33 01 00      mov bl, [d + 1]
0281+  11A1 07 72 10      call _atoi        ; convert to int in AL
0282+  11A4 23            mov ah, al        ; move to AH
0283+  11A5 33 02 00      mov bl, [d + 2]
0284+  11A8 37            mov bh, bl
0285+  11A9 33 03 00      mov bl, [d + 3]
0286+  11AC 07 72 10      call _atoi        ; convert to int in AL
0287+  11AF E5            pop b
0288+  11B0 09            ret
0289+  11B1             
0290+  11B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  11B1             ; _strtoint
0292+  11B1             ; 5 digit base10 string number in d
0293+  11B1             ; integer returned in A
0294+  11B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  11B1             _strtoint:
0296+  11B1 E2            push si
0297+  11B2 D8            push b
0298+  11B3 D9            push c
0299+  11B4 DA            push d
0300+  11B5 07 14 10      call _strlen      ; get string length in C
0301+  11B8 7E            dec c
0302+  11B9 FD 4E         mov si, d
0303+  11BB 12            mov a, c
0304+  11BC FD 99         shl a
0305+  11BE 3B 35 13      mov d, table_power
0306+  11C1 59            add d, a
0307+  11C2 38 00 00      mov c, 0
0308+  11C5             _strtoint_L0:
0309+  11C5 F6            lodsb      ; load ASCII to al
0310+  11C6 B9 00         cmp al, 0
0311+  11C8 C6 DB 11      je _strtoint_end
0312+  11CB 6F 30         sub al, $30    ; make into integer
0313+  11CD 22 00         mov ah, 0
0314+  11CF 2A            mov b, [d]
0315+  11D0 AC            mul a, b      ; result in B since it fits in 16bits
0316+  11D1 11            mov a, b
0317+  11D2 28            mov b, c
0318+  11D3 54            add a, b
0319+  11D4 39            mov c, a
0320+  11D5 63 02 00      sub d, 2
0321+  11D8 0A C5 11      jmp _strtoint_L0
0322+  11DB             _strtoint_end:
0323+  11DB 12            mov a, c
0324+  11DC E7            pop d
0325+  11DD E6            pop c
0326+  11DE E5            pop b
0327+  11DF EF            pop si
0328+  11E0 09            ret
0329+  11E1             
0330+  11E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  11E1             ; PRINT NULL TERMINATED STRING
0332+  11E1             ; pointer in D
0333+  11E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  11E1             _puts:
0335+  11E1 D7            push a
0336+  11E2 DA            push d
0337+  11E3             _puts_L1:
0338+  11E3 1E            mov al, [d]
0339+  11E4 B9 00         cmp al, 0
0340+  11E6 C6 F2 11      jz _puts_END
0341+  11E9 23            mov ah, al
0342+  11EA 19 00         mov al, 0
0343+  11EC 05 03         syscall sys_io
0344+  11EE 79            inc d
0345+  11EF 0A E3 11      jmp _puts_L1
0346+  11F2             _puts_END:
0347+  11F2 E7            pop d
0348+  11F3 E4            pop a
0349+  11F4 09            ret
0350+  11F5             
0351+  11F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  11F5             ; PRINT N SIZE STRING
0353+  11F5             ; pointer in D
0354+  11F5             ; size in C
0355+  11F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  11F5             _putsn:
0357+  11F5 DB            push al
0358+  11F6 DA            push d
0359+  11F7 D9            push c
0360+  11F8             _putsn_L0:
0361+  11F8 1E            mov al, [d]
0362+  11F9 23            mov ah, al
0363+  11FA 19 00         mov al, 0
0364+  11FC 05 03         syscall sys_io
0365+  11FE 79            inc d
0366+  11FF 7E            dec c  
0367+  1200 C2 00 00      cmp c, 0
0368+  1203 C7 F8 11      jne _putsn_L0
0369+  1206             _putsn_end:
0370+  1206 E6            pop c
0371+  1207 E7            pop d
0372+  1208 E8            pop al
0373+  1209 09            ret
0374+  120A             
0375+  120A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  120A             ; print 16bit decimal number
0377+  120A             ; input number in A
0378+  120A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  120A             print_u16d:
0380+  120A D7            push a
0381+  120B D8            push b
0382+  120C FD D8         push g
0383+  120E 26 10 27      mov b, 10000
0384+  1211 AE            div a, b      ; get 10000's coeff.
0385+  1212 07 36 12      call print_number
0386+  1215 11            mov a, b
0387+  1216 26 E8 03      mov b, 1000
0388+  1219 AE            div a, b      ; get 1000's coeff.
0389+  121A 07 36 12      call print_number
0390+  121D 11            mov a, b
0391+  121E 26 64 00      mov b, 100
0392+  1221 AE            div a, b
0393+  1222 07 36 12      call print_number
0394+  1225 11            mov a, b
0395+  1226 26 0A 00      mov b, 10
0396+  1229 AE            div a, b
0397+  122A 07 36 12      call print_number
0398+  122D 1B            mov al, bl      ; 1's coeff in bl
0399+  122E 07 36 12      call print_number
0400+  1231 FD F1         pop g
0401+  1233 E5            pop b
0402+  1234 E4            pop a
0403+  1235 09            ret
0404+  1236             
0405+  1236             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1236             ; print AL
0407+  1236             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1236             print_number:
0409+  1236 6A 30         add al, $30
0410+  1238 23            mov ah, al
0411+  1239 07 B5 10      call _putchar
0412+  123C 09            ret
0413+  123D             
0414+  123D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  123D             ; PRINT 16BIT HEX INTEGER
0416+  123D             ; integer value in reg B
0417+  123D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  123D             print_u16x:
0419+  123D D7            push a
0420+  123E D8            push b
0421+  123F DD            push bl
0422+  1240 30            mov bl, bh
0423+  1241 07 83 10      call _itoa        ; convert bh to char in A
0424+  1244 2F            mov bl, al        ; save al
0425+  1245 19 00         mov al, 0
0426+  1247 05 03         syscall sys_io        ; display AH
0427+  1249 24            mov ah, bl        ; retrieve al
0428+  124A 19 00         mov al, 0
0429+  124C 05 03         syscall sys_io        ; display AL
0430+  124E             
0431+  124E EA            pop bl
0432+  124F 07 83 10      call _itoa        ; convert bh to char in A
0433+  1252 2F            mov bl, al        ; save al
0434+  1253 19 00         mov al, 0
0435+  1255 05 03         syscall sys_io        ; display AH
0436+  1257 24            mov ah, bl        ; retrieve al
0437+  1258 19 00         mov al, 0
0438+  125A 05 03         syscall sys_io        ; display AL
0439+  125C             
0440+  125C E5            pop b
0441+  125D E4            pop a
0442+  125E 09            ret
0443+  125F             
0444+  125F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  125F             ; INPUT 16BIT HEX INTEGER
0446+  125F             ; read 16bit integer into A
0447+  125F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  125F             scan_u16x:
0449+  125F F8 10 00      enter 16
0450+  1262 D8            push b
0451+  1263 DA            push d
0452+  1264             
0453+  1264 FA F1 FF      lea d, [bp + -15]
0454+  1267 07 BC 10      call _gets        ; get number
0455+  126A             
0456+  126A 32            mov bl, [d]
0457+  126B 37            mov bh, bl
0458+  126C 33 01 00      mov bl, [d + 1]
0459+  126F 07 72 10      call _atoi        ; convert to int in AL
0460+  1272 23            mov ah, al        ; move to AH
0461+  1273             
0462+  1273 33 02 00      mov bl, [d + 2]
0463+  1276 37            mov bh, bl
0464+  1277 33 03 00      mov bl, [d + 3]
0465+  127A 07 72 10      call _atoi        ; convert to int in AL
0466+  127D             
0467+  127D E7            pop d
0468+  127E E5            pop b
0469+  127F F9            leave
0470+  1280 09            ret
0471+  1281             
0472+  1281             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  1281             ; PRINT 8bit HEX INTEGER
0474+  1281             ; integer value in reg bl
0475+  1281             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  1281             print_u8x:
0477+  1281 D7            push a
0478+  1282 DD            push bl
0479+  1283             
0480+  1283 07 83 10      call _itoa        ; convert bl to char in A
0481+  1286 2F            mov bl, al        ; save al
0482+  1287 19 00         mov al, 0
0483+  1289 05 03         syscall sys_io        ; display AH
0484+  128B 24            mov ah, bl        ; retrieve al
0485+  128C 19 00         mov al, 0
0486+  128E 05 03         syscall sys_io        ; display AL
0487+  1290             
0488+  1290 EA            pop bl
0489+  1291 E4            pop a
0490+  1292 09            ret
0491+  1293             
0492+  1293             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  1293             ; print 8bit decimal unsigned number
0494+  1293             ; input number in AL
0495+  1293             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  1293             print_u8d:
0497+  1293 D7            push a
0498+  1294 D8            push b
0499+  1295 FD D8         push g
0500+  1297 22 00         mov ah, 0
0501+  1299 26 64 00      mov b, 100
0502+  129C AE            div a, b
0503+  129D D8            push b      ; save remainder
0504+  129E B9 00         cmp al, 0
0505+  12A0 C6 AA 12      je skip100
0506+  12A3 6A 30         add al, $30
0507+  12A5 23            mov ah, al
0508+  12A6 19 00         mov al, 0
0509+  12A8 05 03         syscall sys_io  ; print coeff
0510+  12AA             skip100:
0511+  12AA E4            pop a
0512+  12AB 22 00         mov ah, 0
0513+  12AD 26 0A 00      mov b, 10
0514+  12B0 AE            div a, b
0515+  12B1 D8            push b      ; save remainder
0516+  12B2 B9 00         cmp al, 0
0517+  12B4 C6 BE 12      je skip10
0518+  12B7 6A 30         add al, $30
0519+  12B9 23            mov ah, al
0520+  12BA 19 00         mov al, 0
0521+  12BC 05 03         syscall sys_io  ; print coeff
0522+  12BE             skip10:
0523+  12BE E4            pop a
0524+  12BF 1B            mov al, bl
0525+  12C0 6A 30         add al, $30
0526+  12C2 23            mov ah, al
0527+  12C3 19 00         mov al, 0
0528+  12C5 05 03         syscall sys_io  ; print coeff
0529+  12C7 FD F1         pop g
0530+  12C9 E5            pop b
0531+  12CA E4            pop a
0532+  12CB 09            ret
0533+  12CC             
0534+  12CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  12CC             ; INPUT 8BIT HEX INTEGER
0536+  12CC             ; read 8bit integer into AL
0537+  12CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  12CC             scan_u8x:
0539+  12CC F8 04 00      enter 4
0540+  12CF D8            push b
0541+  12D0 DA            push d
0542+  12D1             
0543+  12D1 FA FD FF      lea d, [bp + -3]
0544+  12D4 07 BC 10      call _gets        ; get number
0545+  12D7             
0546+  12D7 32            mov bl, [d]
0547+  12D8 37            mov bh, bl
0548+  12D9 33 01 00      mov bl, [d + 1]
0549+  12DC 07 72 10      call _atoi        ; convert to int in AL
0550+  12DF             
0551+  12DF E7            pop d
0552+  12E0 E5            pop b
0553+  12E1 F9            leave
0554+  12E2 09            ret
0555+  12E3             
0556+  12E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  12E3             ; input decimal number
0558+  12E3             ; result in A
0559+  12E3             ; 655'\0'
0560+  12E3             ; low--------high
0561+  12E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  12E3             scan_u16d:
0563+  12E3 F8 08 00      enter 8
0564+  12E6 E2            push si
0565+  12E7 D8            push b
0566+  12E8 D9            push c
0567+  12E9 DA            push d
0568+  12EA FA F9 FF      lea d, [bp +- 7]
0569+  12ED 07 BC 10      call _gets
0570+  12F0 07 14 10      call _strlen      ; get string length in C
0571+  12F3 7E            dec c
0572+  12F4 FD 4E         mov si, d
0573+  12F6 12            mov a, c
0574+  12F7 FD 99         shl a
0575+  12F9 3B 35 13      mov d, table_power
0576+  12FC 59            add d, a
0577+  12FD 38 00 00      mov c, 0
0578+  1300             mul_loop:
0579+  1300 F6            lodsb      ; load ASCII to al
0580+  1301 B9 00         cmp al, 0
0581+  1303 C6 16 13      je mul_exit
0582+  1306 6F 30         sub al, $30    ; make into integer
0583+  1308 22 00         mov ah, 0
0584+  130A 2A            mov b, [d]
0585+  130B AC            mul a, b      ; result in B since it fits in 16bits
0586+  130C 11            mov a, b
0587+  130D 28            mov b, c
0588+  130E 54            add a, b
0589+  130F 39            mov c, a
0590+  1310 63 02 00      sub d, 2
0591+  1313 0A 00 13      jmp mul_loop
0592+  1316             mul_exit:
0593+  1316 12            mov a, c
0594+  1317 E7            pop d
0595+  1318 E6            pop c
0596+  1319 E5            pop b
0597+  131A EF            pop si
0598+  131B F9            leave
0599+  131C 09            ret
0600+  131D             
0601+  131D             
0602+  131D 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  1321 34 35 36 37 
0602+  1325 38 39 41 42 
0602+  1329 43 44 45 46 
0603+  132D 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  1331 1B 5B 48 00 
0604+  1335             
0605+  1335             table_power:
0606+  1335 01 00         .dw 1
0607+  1337 0A 00         .dw 10
0608+  1339 64 00         .dw 100
0609+  133B E8 03         .dw 1000
0610+  133D 10 27         .dw 100002549   133F             .include "lib/ctype.asm"
0001+  133F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  133F             ; ctype.s
0003+  133F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  133F             
0005+  133F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  133F             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  133F             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  133F             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  133F             ;; characters are supported.
0010+  133F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  133F             ;; _isalnum 
0012+  133F             ;; _isalpha 
0013+  133F             ;; islower 
0014+  133F             ;; isupper 
0015+  133F             ;; _isdigit 
0016+  133F             ;; isxdigit
0017+  133F             ;; iscntrl 
0018+  133F             ;; isgraph 
0019+  133F             ;; _isspace 
0020+  133F             ;; isblank 
0021+  133F             ;; isprint 
0022+  133F             ;; ispunct 
0023+  133F             ;; tolower 
0024+  133F             ;; toupper
0025+  133F             
0026+  133F             
0027+  133F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  133F             ;; IS ALPHANUMERIC
0029+  133F             ;; sets ZF according with result
0030+  133F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  133F             _isalnum:
0032+  133F 07 5C 13    	call _isalpha
0033+  1342 C6 48 13    	je _isalnum_exit
0034+  1345 07 49 13    	call _isdigit
0035+  1348             _isalnum_exit:
0036+  1348 09          	ret	
0037+  1349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1349             ;; IS DIGIT
0039+  1349             ;; sets ZF according with result
0040+  1349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1349             _isdigit:
0042+  1349 DB          	push al
0043+  134A B9 30       	cmp al, '0'
0044+  134C C8 58 13    	jlu _isdigit_false
0045+  134F B9 39       	cmp al, '9'
0046+  1351 D1 58 13    	jgu _isdigit_false
0047+  1354 87 00       	and al, 0	; set ZF
0048+  1356 E8          	pop al
0049+  1357 09          	ret
0050+  1358             _isdigit_false:
0051+  1358 8B 01       	or al, 1	; clear ZF
0052+  135A E8          	pop al
0053+  135B 09          	ret	
0054+  135C             	
0055+  135C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  135C             ;; IS ALPHA
0057+  135C             ;; sets ZF according with result
0058+  135C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  135C             _isalpha:
0060+  135C DB          	push al
0061+  135D B9 5F       	cmp al, '_'
0062+  135F C6 7F 13    	je _isalpha_true
0063+  1362 B9 2E       	cmp al, '.'
0064+  1364 C6 7F 13    	je _isalpha_true
0065+  1367 B9 41       	cmp al, 'A'
0066+  1369 C8 7B 13    	jlu _isalpha_false
0067+  136C B9 7A       	cmp al, 'z'
0068+  136E D1 7B 13    	jgu _isalpha_false
0069+  1371 B9 5A       	cmp al, 'Z'
0070+  1373 D0 7F 13    	jleu _isalpha_true
0071+  1376 B9 61       	cmp al, 'a'
0072+  1378 C9 7F 13    	jgeu _isalpha_true
0073+  137B             _isalpha_false:
0074+  137B 8B 01       	or al, 1	; clear ZF
0075+  137D E8          	pop al
0076+  137E 09          	ret
0077+  137F             _isalpha_true:
0078+  137F 87 00       	and al, 0	; set ZF
0079+  1381 E8          	pop al
0080+  1382 09          	ret
0081+  1383             
0082+  1383             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  1383             ;; IS PATH-ALPHA
0084+  1383             ;; sets ZF according with result
0085+  1383             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  1383             ispath:
0087+  1383 DB          	push al
0088+  1384 07 49 13    	call _isdigit
0089+  1387 C6 B1 13    	je ispath_true
0090+  138A B9 5F       	cmp al, '_'
0091+  138C C6 B1 13    	je ispath_true
0092+  138F B9 2F       	cmp al, '/'
0093+  1391 C6 B1 13    	je ispath_true
0094+  1394 B9 2E       	cmp al, '.'
0095+  1396 C6 B1 13    	je ispath_true
0096+  1399 B9 41       	cmp al, 'A'
0097+  139B C8 AD 13    	jlu ispath_false
0098+  139E B9 7A       	cmp al, 'z'
0099+  13A0 D1 AD 13    	jgu ispath_false
0100+  13A3 B9 5A       	cmp al, 'Z'
0101+  13A5 D0 B1 13    	jleu ispath_true
0102+  13A8 B9 61       	cmp al, 'a'
0103+  13AA C9 B1 13    	jgeu ispath_true
0104+  13AD             ispath_false:
0105+  13AD 8B 01       	or al, 1	; clear ZF
0106+  13AF E8          	pop al
0107+  13B0 09          	ret
0108+  13B1             ispath_true:
0109+  13B1 87 00       	and al, 0	; set ZF
0110+  13B3 E8          	pop al
0111+  13B4 09          	ret
0112+  13B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  13B5             ;; IS SPACE
0114+  13B5             ;; sets ZF according with result
0115+  13B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  13B5             _isspace:
0117+  13B5 B9 20       	cmp al, $20		; ' '
0118+  13B7 C6 CB 13    	je _isspace_exit
0119+  13BA B9 09       	cmp al, $09		; '\t'
0120+  13BC C6 CB 13    	je _isspace_exit
0121+  13BF B9 0A       	cmp al, $0A		; '\n'
0122+  13C1 C6 CB 13    	je _isspace_exit
0123+  13C4 B9 0D       	cmp al, $0D		; '\r'
0124+  13C6 C6 CB 13    	je _isspace_exit
0125+  13C9 B9 0B       	cmp al, $0B		; '\v'
0126+  13CB             _isspace_exit:
0127+  13CB 09          	ret	
0128+  13CC             
0129+  13CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  13CC             ; TO LOWER
0131+  13CC             ; input in AL
0132+  13CC             ; output in AL
0133+  13CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  13CC             _to_lower:
0135+  13CC B9 5A       	cmp al, 'Z'
0136+  13CE D1 D3 13    	jgu _to_lower_ret
0137+  13D1 6A 20       	add al, $20				; convert to lower case
0138+  13D3             _to_lower_ret:
0139+  13D3 09          	ret
0140+  13D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  13D4             ; TO UPPER
0142+  13D4             ; input in AL
0143+  13D4             ; output in AL
0144+  13D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  13D4             _to_upper:
0146+  13D4 B9 61       	cmp al, 'a'
0147+  13D6 C8 DB 13    	jlu _to_upper_ret
0148+  13D9 6F 20       	sub al, $20			; convert to upper case
0149+  13DB             _to_upper_ret:
0150+  13DB 09          	ret
0151+  13DC             
2550   13DC             .include "lib/token.asm"
0001+  13DC             TOKTYP_IDENTIFIER  .equ 0
0002+  13DC             TOKTYP_KEYWORD     .equ 1
0003+  13DC             TOKTYP_DELIMITER   .equ 2
0004+  13DC             TOKTYP_STRING      .equ 3
0005+  13DC             TOKTYP_CHAR        .equ 4
0006+  13DC             TOKTYP_NUMERIC     .equ 5
0007+  13DC             TOKTYP_END         .equ 6
0008+  13DC             
0009+  13DC             TOK_NULL           .equ 0
0010+  13DC             TOK_FSLASH         .equ 1
0011+  13DC             TOK_TIMES          .equ 2
0012+  13DC             TOK_PLUS           .equ 3
0013+  13DC             TOK_MINUS          .equ 4
0014+  13DC             TOK_DOT            .equ 5
0015+  13DC             TOK_SEMI           .equ 6
0016+  13DC             TOK_ANGLE          .equ 7
0017+  13DC             TOK_TILDE          .equ 8
0018+  13DC             TOK_EQUAL          .equ 9
0019+  13DC             TOK_COLON          .equ 10
0020+  13DC             TOK_COMMA          .equ 11
0021+  13DC             
0022+  13DC             TOK_END            .equ 20
0023+  13DC             
0024+  13DC             
0025+  13DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  13DC             ;; read a full command argment from shell input buffer
0027+  13DC             ;; argument is written into tokstr
0028+  13DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  13DC             get_arg:
0030+  13DC D7            push a
0031+  13DD E2            push si
0032+  13DE E3            push di
0033+  13DF 19 00         mov al, 0
0034+  13E1 3D 0A 16      mov [tokstr], al      ; nullify tokstr string
0035+  13E4 14 06 16      mov a, [prog]
0036+  13E7 4D            mov si, a
0037+  13E8 FD 4F 0A 16   mov di, tokstr
0038+  13EC             get_arg_skip_spaces:
0039+  13EC F6            lodsb
0040+  13ED 07 B5 13      call _isspace
0041+  13F0 C6 EC 13      je get_arg_skip_spaces
0042+  13F3             get_arg_L0:
0043+  13F3 B9 3B         cmp al, $3B        ; check if is ';'
0044+  13F5 C6 02 14      je get_arg_end
0045+  13F8 B9 00         cmp al, 0
0046+  13FA C6 02 14      je get_arg_end      ; check if end of input
0047+  13FD F7            stosb
0048+  13FE F6            lodsb
0049+  13FF 0A F3 13      jmp get_arg_L0
0050+  1402             get_arg_end:
0051+  1402 19 00         mov al, 0
0052+  1404 F7            stosb
0053+  1405 D5 01 00      sub si, 1
0054+  1408 4E            mov a, si
0055+  1409 42 06 16      mov [prog], a    ; update pointer
0056+  140C F0            pop di
0057+  140D EF            pop si
0058+  140E E4            pop a
0059+  140F 09            ret
0060+  1410             
0061+  1410             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  1410             ;; read a path formation from shell input buffer
0063+  1410             ;; path is written into tokstr
0064+  1410             ;; /usr/bin
0065+  1410             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  1410             get_path:
0067+  1410 D7            push a
0068+  1411 E2            push si
0069+  1412 E3            push di
0070+  1413 19 00         mov al, 0
0071+  1415 3D 0A 16      mov [tokstr], al      ; nullify tokstr string
0072+  1418 14 06 16      mov a, [prog]
0073+  141B 4D            mov si, a
0074+  141C FD 4F 0A 16   mov di, tokstr
0075+  1420             get_path_skip_spaces:
0076+  1420 F6            lodsb
0077+  1421 07 B5 13      call _isspace
0078+  1424 C6 20 14      je get_path_skip_spaces
0079+  1427             get_path_is_pathchar:
0080+  1427 F7            stosb
0081+  1428 F6            lodsb
0082+  1429 07 3F 13      call _isalnum      ;check if is alphanumeric
0083+  142C C6 27 14      je get_path_is_pathchar
0084+  142F B9 2F         cmp al, '/'        ; check if is '/'
0085+  1431 C6 27 14      je get_path_is_pathchar
0086+  1434 19 00         mov al, 0
0087+  1436 F7            stosb
0088+  1437 D5 01 00      sub si, 1
0089+  143A 4E            mov a, si
0090+  143B 42 06 16      mov [prog], a    ; update pointer
0091+  143E             get_path_end:
0092+  143E F0            pop di
0093+  143F EF            pop si
0094+  1440 E4            pop a
0095+  1441 09            ret
0096+  1442             
0097+  1442             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  1442             ;; read a line
0099+  1442             ;; line is written into tokstr
0100+  1442             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  1442             get_line:
0102+  1442 D7            push a
0103+  1443 E2            push si
0104+  1444 E3            push di
0105+  1445 19 00         mov al, 0
0106+  1447 3D 0A 16      mov [tokstr], al      ; nullify tokstr string
0107+  144A 14 06 16      mov a, [prog]
0108+  144D 4D            mov si, a
0109+  144E FD 4F 0A 16   mov di, tokstr
0110+  1452             get_line_L0:
0111+  1452 F6            lodsb
0112+  1453 B9 0A         cmp al, $0A    ; check for new line
0113+  1455 C6 5C 14      je get_line_exit
0114+  1458 F7            stosb
0115+  1459 0A 52 14      jmp get_line_L0
0116+  145C             get_line_exit:
0117+  145C 19 00         mov al, 0
0118+  145E F7            stosb
0119+  145F 4E            mov a, si
0120+  1460 42 06 16      mov [prog], a    ; update pointer
0121+  1463 F0            pop di
0122+  1464 EF            pop si
0123+  1465 E4            pop a
0124+  1466 09            ret
0125+  1467             
0126+  1467             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1467             ;; token parser
0128+  1467             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1467             get_token:
0130+  1467 D7            push a
0131+  1468 DA            push d
0132+  1469 E2            push si
0133+  146A E3            push di
0134+  146B 19 00         mov al, 0
0135+  146D 3D 0A 16      mov [tokstr], al      ; nullify tokstr string
0136+  1470 19 00         mov al, TOK_NULL
0137+  1472 3D 09 16      mov [tok], al        ; nullify token
0138+  1475 14 06 16      mov a, [prog]
0139+  1478 4D            mov si, a
0140+  1479 FD 4F 0A 16   mov di, tokstr
0141+  147D             get_tok_skip_spaces:
0142+  147D F6            lodsb
0143+  147E 07 B5 13      call _isspace
0144+  1481 C6 7D 14      je get_tok_skip_spaces
0145+  1484 B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  1486 C6 6B 15      je get_token_end
0147+  1489 B9 23         cmp al, '#'      ; comments!
0148+  148B C6 99 15      je get_tok_comment
0149+  148E 07 3F 13      call _isalnum
0150+  1491 C6 78 15      jz is_alphanumeric
0151+  1494             ; other token types
0152+  1494             get_token_slash:
0153+  1494 B9 2F         cmp al, '/'        ; check if '/'
0154+  1496 C7 AE 14      jne get_token_minus
0155+  1499 F7            stosb          ; store '/' into token string
0156+  149A 19 00         mov al, 0
0157+  149C F7            stosb          ; terminate token string
0158+  149D 19 01         mov al, TOK_FSLASH
0159+  149F 3D 09 16      mov [tok], al      
0160+  14A2 19 02         mov al, TOKTYP_DELIMITER
0161+  14A4 3D 08 16      mov [toktyp], al
0162+  14A7 4E            mov a, si
0163+  14A8 42 06 16      mov [prog], a    ; update pointer
0164+  14AB 0A 94 15      jmp get_token_return
0165+  14AE             get_token_minus:
0166+  14AE B9 2D         cmp al, '-'        ; check if '-'
0167+  14B0 C7 C8 14      jne get_token_comma
0168+  14B3 F7            stosb          ; store '-' into token string
0169+  14B4 19 00         mov al, 0
0170+  14B6 F7            stosb          ; terminate token string
0171+  14B7 19 04         mov al, TOK_MINUS
0172+  14B9 3D 09 16      mov [tok], al      
0173+  14BC 19 02         mov al, TOKTYP_DELIMITER
0174+  14BE 3D 08 16      mov [toktyp], al
0175+  14C1 4E            mov a, si
0176+  14C2 42 06 16      mov [prog], a    ; update pointer
0177+  14C5 0A 94 15      jmp get_token_return
0178+  14C8             get_token_comma:
0179+  14C8 B9 2C         cmp al, ','        ; check if ','
0180+  14CA C7 E2 14      jne get_token_semi
0181+  14CD F7            stosb          ; store ',' into token string
0182+  14CE 19 00         mov al, 0
0183+  14D0 F7            stosb          ; terminate token string
0184+  14D1 19 0B         mov al, TOK_COMMA
0185+  14D3 3D 09 16      mov [tok], al      
0186+  14D6 19 02         mov al, TOKTYP_DELIMITER
0187+  14D8 3D 08 16      mov [toktyp], al
0188+  14DB 4E            mov a, si
0189+  14DC 42 06 16      mov [prog], a    ; update pointer
0190+  14DF 0A 94 15      jmp get_token_return
0191+  14E2             get_token_semi:
0192+  14E2 B9 3B         cmp al, $3B        ; check if ';'
0193+  14E4 C7 FC 14      jne get_token_colon
0194+  14E7 F7            stosb          ; store ';' into token string
0195+  14E8 19 00         mov al, 0
0196+  14EA F7            stosb          ; terminate token string
0197+  14EB 19 06         mov al, TOK_SEMI
0198+  14ED 3D 09 16      mov [tok], al      
0199+  14F0 19 02         mov al, TOKTYP_DELIMITER
0200+  14F2 3D 08 16      mov [toktyp], al
0201+  14F5 4E            mov a, si
0202+  14F6 42 06 16      mov [prog], a    ; update pointer
0203+  14F9 0A 94 15      jmp get_token_return
0204+  14FC             get_token_colon:
0205+  14FC B9 3A         cmp al, $3A        ; check if ':'
0206+  14FE C7 16 15      jne get_token_angle
0207+  1501 F7            stosb          ; store ':' into token string
0208+  1502 19 00         mov al, 0
0209+  1504 F7            stosb          ; terminate token string
0210+  1505 19 0A         mov al, TOK_COLON
0211+  1507 3D 09 16      mov [tok], al      
0212+  150A 19 02         mov al, TOKTYP_DELIMITER
0213+  150C 3D 08 16      mov [toktyp], al
0214+  150F 4E            mov a, si
0215+  1510 42 06 16      mov [prog], a    ; update pointer
0216+  1513 0A 94 15      jmp get_token_return
0217+  1516             get_token_angle:
0218+  1516 B9 3E         cmp al, $3E        ; check if '>'
0219+  1518 C7 30 15      jne get_token_tilde
0220+  151B F7            stosb          ; store '>' into token string
0221+  151C 19 00         mov al, 0
0222+  151E F7            stosb          ; terminate token string
0223+  151F 19 07         mov al, TOK_ANGLE
0224+  1521 3D 09 16      mov [tok], al      
0225+  1524 19 02         mov al, TOKTYP_DELIMITER
0226+  1526 3D 08 16      mov [toktyp], al
0227+  1529 4E            mov a, si
0228+  152A 42 06 16      mov [prog], a    ; update pointer
0229+  152D 0A 94 15      jmp get_token_return
0230+  1530             get_token_tilde:
0231+  1530 B9 7E         cmp al, '~'        ; check if '~'
0232+  1532 C7 4A 15      jne get_token_equal
0233+  1535 F7            stosb          ; store '~' into token string
0234+  1536 19 00         mov al, 0
0235+  1538 F7            stosb          ; terminate token string
0236+  1539 19 08         mov al, TOK_TILDE
0237+  153B 3D 09 16      mov [tok], al      
0238+  153E 19 02         mov al, TOKTYP_DELIMITER
0239+  1540 3D 08 16      mov [toktyp], al
0240+  1543 4E            mov a, si
0241+  1544 42 06 16      mov [prog], a    ; update pointer
0242+  1547 0A 94 15      jmp get_token_return
0243+  154A             get_token_equal:
0244+  154A B9 3D         cmp al, '='        ; check if '='
0245+  154C C7 64 15      jne get_token_skip
0246+  154F F7            stosb          ; store '=' into token string
0247+  1550 19 00         mov al, 0
0248+  1552 F7            stosb          ; terminate token string
0249+  1553 19 09         mov al, TOK_EQUAL
0250+  1555 3D 09 16      mov [tok], al      
0251+  1558 19 02         mov al, TOKTYP_DELIMITER
0252+  155A 3D 08 16      mov [toktyp], al
0253+  155D 4E            mov a, si
0254+  155E 42 06 16      mov [prog], a    ; update pointer
0255+  1561 0A 94 15      jmp get_token_return
0256+  1564             get_token_skip:
0257+  1564 4E            mov a, si
0258+  1565 42 06 16      mov [prog], a    ; update pointer
0259+  1568 0A 94 15      jmp get_token_return
0260+  156B             get_token_end:        ; end of file token
0261+  156B 19 14         mov al, TOK_END
0262+  156D 3D 09 16      mov [tok], al
0263+  1570 19 06         mov al, TOKTYP_END
0264+  1572 3D 08 16      mov [toktyp], al
0265+  1575 0A 94 15      jmp get_token_return
0266+  1578             is_alphanumeric:
0267+  1578 F7            stosb
0268+  1579 F6            lodsb
0269+  157A 07 3F 13      call _isalnum      ;check if is alphanumeric
0270+  157D C6 78 15      jz is_alphanumeric
0271+  1580 B9 2E         cmp al, $2E        ; check if is '.'
0272+  1582 C6 78 15      je is_alphanumeric
0273+  1585 19 00         mov al, 0
0274+  1587 F7            stosb
0275+  1588 19 00         mov al, TOKTYP_IDENTIFIER
0276+  158A 3D 08 16      mov [toktyp], al
0277+  158D D5 01 00      sub si, 1
0278+  1590 4E            mov a, si
0279+  1591 42 06 16      mov [prog], a    ; update pointer
0280+  1594             get_token_return:
0281+  1594 F0            pop di
0282+  1595 EF            pop si
0283+  1596 E7            pop d
0284+  1597 E4            pop a
0285+  1598 09            ret
0286+  1599             get_tok_comment:
0287+  1599 F6            lodsb
0288+  159A B9 0A         cmp al, $0A      ; new line
0289+  159C C7 99 15      jne get_tok_comment
0290+  159F 0A 7D 14      jmp get_tok_skip_spaces
0291+  15A2             
0292+  15A2             
0293+  15A2             get_number:
0294+  15A2 D7            push a
0295+  15A3 DA            push d
0296+  15A4 E2            push si
0297+  15A5 E3            push di
0298+  15A6 19 00         mov al, 0
0299+  15A8 3D 0A 16      mov [tokstr], al      ; nullify tokstr string
0300+  15AB 19 00         mov al, TOK_NULL
0301+  15AD 3D 09 16      mov [tok], al        ; nullify token
0302+  15B0 14 06 16      mov a, [prog]
0303+  15B3 4D            mov si, a
0304+  15B4 FD 4F 0A 16   mov di, tokstr
0305+  15B8             get_number_skip_spaces:
0306+  15B8 F6            lodsb
0307+  15B9 07 B5 13      call _isspace
0308+  15BC C6 B8 15      je get_number_skip_spaces
0309+  15BF B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  15C1 C7 D1 15      jne get_number_L0
0311+  15C4 19 14         mov al, TOK_END
0312+  15C6 3D 09 16      mov [tok], al
0313+  15C9 19 06         mov al, TOKTYP_END
0314+  15CB 3D 08 16      mov [toktyp], al
0315+  15CE 0A E8 15      jmp get_number_return
0316+  15D1             get_number_L0:
0317+  15D1 F7            stosb
0318+  15D2 F6            lodsb
0319+  15D3 07 49 13      call _isdigit      ;check if is numeric
0320+  15D6 C6 D1 15      jz get_number_L0
0321+  15D9 19 00         mov al, 0
0322+  15DB F7            stosb
0323+  15DC 19 05         mov al, TOKTYP_NUMERIC
0324+  15DE 3D 08 16      mov [toktyp], al
0325+  15E1 D5 01 00      sub si, 1
0326+  15E4 4E            mov a, si
0327+  15E5 42 06 16      mov [prog], a    ; update pointer
0328+  15E8             get_number_return:
0329+  15E8 F0            pop di
0330+  15E9 EF            pop si
0331+  15EA E7            pop d
0332+  15EB E4            pop a
0333+  15EC 09            ret
0334+  15ED             
0335+  15ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  15ED             ;; PUT BACK TOKEN
0337+  15ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  15ED             _putback:
0339+  15ED D7            push a
0340+  15EE E2            push si
0341+  15EF FD 4D 0A 16   mov si, tokstr  
0342+  15F3             _putback_loop:
0343+  15F3 F6            lodsb
0344+  15F4 B9 00         cmp al, 0
0345+  15F6 C6 03 16      je _putback_end
0346+  15F9 14 06 16      mov a, [prog]
0347+  15FC 7D            dec a
0348+  15FD 42 06 16      mov [prog], a      ; update pointer
0349+  1600 0A F3 15      jmp _putback_loop
0350+  1603             _putback_end:
0351+  1603 EF            pop si
0352+  1604 E4            pop a
0353+  1605 09            ret
0354+  1606             
0355+  1606             
0356+  1606             
0357+  1606             
0358+  1606 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1608             
0360+  1608 00          toktyp:    .db 0          ; token type symbol
0361+  1609 00          tok:       .db 0          ; current token symbol
0362+  160A 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  160E 00 00 00 00 
0362+  1612 00 00 00 00 
0362+  1616 00 00 00 00 
0362+  161A 00 00 00 00 
0362+  161E 00 00 00 00 
0362+  1622 00 00 00 00 
0362+  1626 00 00 00 00 
0362+  162A 00 00 00 00 
0362+  162E 00 00 00 00 
0362+  1632 00 00 00 00 
0362+  1636 00 00 00 00 
0362+  163A 00 00 00 00 
0362+  163E 00 00 00 00 
0362+  1642 00 00 00 00 
0362+  1646 00 00 00 00 
0362+  164A 00 00 00 00 
0362+  164E 00 00 00 00 
0362+  1652 00 00 00 00 
0362+  1656 00 00 00 00 
0362+  165A 00 00 00 00 
0362+  165E 00 00 00 00 
0362+  1662 00 00 00 00 
0362+  1666 00 00 00 00 
0362+  166A 00 00 00 00 
0362+  166E 00 00 00 00 
0362+  1672 00 00 00 00 
0362+  1676 00 00 00 00 
0362+  167A 00 00 00 00 
0362+  167E 00 00 00 00 
0362+  1682 00 00 00 00 
0362+  1686 00 00 00 00 
0362+  168A 00 00 00 00 
0362+  168E 00 00 00 00 
0362+  1692 00 00 00 00 
0362+  1696 00 00 00 00 
0362+  169A 00 00 00 00 
0362+  169E 00 00 00 00 
0362+  16A2 00 00 00 00 
0362+  16A6 00 00 00 00 
0362+  16AA 00 00 00 00 
0362+  16AE 00 00 00 00 
0362+  16B2 00 00 00 00 
0362+  16B6 00 00 00 00 
0362+  16BA 00 00 00 00 
0362+  16BE 00 00 00 00 
0362+  16C2 00 00 00 00 
0362+  16C6 00 00 00 00 
0362+  16CA 00 00 00 00 
0362+  16CE 00 00 00 00 
0362+  16D2 00 00 00 00 
0362+  16D6 00 00 00 00 
0362+  16DA 00 00 00 00 
0362+  16DE 00 00 00 00 
0362+  16E2 00 00 00 00 
0362+  16E6 00 00 00 00 
0362+  16EA 00 00 00 00 
0362+  16EE 00 00 00 00 
0362+  16F2 00 00 00 00 
0362+  16F6 00 00 00 00 
0362+  16FA 00 00 00 00 
0362+  16FE 00 00 00 00 
0362+  1702 00 00 00 00 
0362+  1706 00 00 00 00 
2551   170A             
2552   170A             ; kernel parameters
2553   170A 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2554   170B 01          sys_echo_on:        .db 1
2555   170C 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2556   170D 01          sys_uart0_inten:    .db 1
2557   170E 00          sys_uart0_fifoen:   .db 0
2558   170F 0C          sys_uart0_div0:     .db 12  ;
2559   1710 00          sys_uart0_div1:     .db 0   ; default baud = 9600
2560   1711             ; Baud  Divisor
2561   1711             ; 50    2304
2562   1711             ; 110   1047
2563   1711             ; 300    384
2564   1711             ; 600    192
2565   1711             ; 1200    96
2566   1711             ; 9600    12
2567   1711             ; 19200    6
2568   1711             ; 38400    3
2569   1711             
2570   1711 00          nbr_active_procs:   .db 0
2571   1712 01          active_proc_index:  .db 1
2572   1713             
2573   1713 00 00       index:              .dw 0
2574   1715 00 00       buffer_addr:        .dw 0
2575   1717             
2576   1717 16 1E       fifo_in:            .dw fifo
2577   1719 16 1E       fifo_out:           .dw fifo
2578   171B             
2579   171B             ; file system variables
2580   171B 00 00       current_dir_id:     .dw 0     ; keep dirID of current directory
2581   171D 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2581   1721 6E 2F 69 6E 
2581   1725 69 74 00 
2582   1728             
2583   1728 3E 20 00    s_dataentry:        .db "> ", 0
2584   172B 2E 2E 00    s_parent_dir:       .db "..", 0
2585   172E 2E 00       s_current_dir:      .db ".", 0
2586   1730 2F 00       s_fslash:           .db "/", 0
2587   1732 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2587   1736 78 
2588   1737 2D 64 63    file_type:          .db "-dc"
2589   173A 50 49 44 20 s_ps_header:        .db "PID COMMAND\n", 0
2589   173E 43 4F 4D 4D 
2589   1742 41 4E 44 0A 
2589   1746 00 
2590   1747 54 6F 74 61 s_ls_total:         .db "Total: ", 0
2590   174B 6C 3A 20 00 
2591   174F             
2592   174F 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2592   1753 20 65 6E 61 
2592   1757 62 6C 65 64 
2592   175B 0A 00 
2593   175D 6B 65 72 6E s_kernel_started:   .db "kernel started(version 1.0)\n", 0
2593   1761 65 6C 20 73 
2593   1765 74 61 72 74 
2593   1769 65 64 28 76 
2593   176D 65 72 73 69 
2593   1771 6F 6E 20 31 
2593   1775 2E 30 29 0A 
2593   1779 00 
2594   177A 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2594   177E 74 69 6E 67 
2594   1782 20 69 6E 69 
2594   1786 74 0A 00 
2595   1789 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2595   178D 65 70 74 69 
2595   1791 6F 6E 3A 20 
2595   1795 70 72 69 76 
2595   1799 69 6C 65 67 
2595   179D 65 0A 00 
2596   17A0 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2596   17A4 65 70 74 69 
2596   17A8 6F 6E 3A 20 
2596   17AC 7A 65 72 6F 
2596   17B0 20 64 69 76 
2596   17B4 69 73 69 6F 
2596   17B8 6E 0A 00 
2597   17BB             
2598   17BB 59 65 61 72 s_set_year:         .db "Year: ", 0
2598   17BF 3A 20 00 
2599   17C2 4D 6F 6E 74 s_set_month:        .db "Month: ", 0
2599   17C6 68 3A 20 00 
2600   17CA 44 61 79 3A s_set_day:          .db "Day: ", 0
2600   17CE 20 00 
2601   17D0 57 65 65 6B s_set_week:         .db "Weekday: ", 0
2601   17D4 64 61 79 3A 
2601   17D8 20 00 
2602   17DA 48 6F 75 72 s_set_hours:        .db "Hours: ", 0
2602   17DE 73 3A 20 00 
2603   17E2 4D 69 6E 75 s_set_minutes:      .db "Minutes: ", 0
2603   17E6 74 65 73 3A 
2603   17EA 20 00 
2604   17EC 53 65 63 6F s_set_seconds:      .db "Seconds: ", 0
2604   17F0 6E 64 73 3A 
2604   17F4 20 00 
2605   17F6             s_months:      
2606   17F6 20 20 20 00   .db "   ", 0
2607   17FA 4A 61 6E 00   .db "Jan", 0
2608   17FE 46 65 62 00   .db "Feb", 0
2609   1802 4D 61 72 00   .db "Mar", 0
2610   1806 41 70 72 00   .db "Apr", 0
2611   180A 4D 61 79 00   .db "May", 0
2612   180E 4A 75 6E 00   .db "Jun", 0
2613   1812 4A 75 6C 00   .db "Jul", 0
2614   1816 41 75 67 00   .db "Aug", 0
2615   181A 53 65 70 00   .db "Sep", 0
2616   181E 4F 63 74 00   .db "Oct", 0
2617   1822 4E 6F 76 00   .db "Nov", 0
2618   1826 44 65 63 00   .db "Dec", 0
2619   182A             
2620   182A             s_week:        
2621   182A 53 75 6E 00   .db "Sun", 0 
2622   182E 4D 6F 6E 00   .db "Mon", 0 
2623   1832 54 75 65 00   .db "Tue", 0 
2624   1836 57 65 64 00   .db "Wed", 0 
2625   183A 54 68 75 00   .db "Thu", 0 
2626   183E 46 72 69 00   .db "Fri", 0 
2627   1842 53 61 74 00   .db "Sat", 0
2628   1846             
2629   1846 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2629   184A 00 00 00 00 
2629   184E 00 00 00 00 
2629   1852 00 00 00 00 
2629   1856 00 00 00 00 
2629   185A 00 00 00 00 
2629   185E 00 00 00 00 
2629   1862 00 00 00 00 
2629   1866 00 00 00 00 
2629   186A 00 00 00 00 
2629   186E 00 00 00 00 
2629   1872 00 00 00 00 
2629   1876 00 00 00 00 
2629   187A 00 00 00 00 
2629   187E 00 00 00 00 
2629   1882 00 00 00 00 
2629   1886 00 00 00 00 
2629   188A 00 00 00 00 
2629   188E 00 00 00 00 
2629   1892 00 00 00 00 
2629   1896 00 00 00 00 
2629   189A 00 00 00 00 
2629   189E 00 00 00 00 
2629   18A2 00 00 00 00 
2629   18A6 00 00 00 00 
2629   18AA 00 00 00 00 
2629   18AE 00 00 00 00 
2629   18B2 00 00 00 00 
2629   18B6 00 00 00 00 
2629   18BA 00 00 00 00 
2629   18BE 00 00 00 00 
2629   18C2 00 00 00 00 
2629   18C6 00 00 00 00 
2629   18CA 00 00 00 00 
2629   18CE 00 00 00 00 
2629   18D2 00 00 00 00 
2629   18D6 00 00 00 00 
2629   18DA 00 00 00 00 
2629   18DE 00 00 00 00 
2629   18E2 00 00 00 00 
2629   18E6 00 00 00 00 
2629   18EA 00 00 00 00 
2629   18EE 00 00 00 00 
2629   18F2 00 00 00 00 
2629   18F6 00 00 00 00 
2629   18FA 00 00 00 00 
2629   18FE 00 00 00 00 
2629   1902 00 00 00 00 
2629   1906 00 00 00 00 
2629   190A 00 00 00 00 
2629   190E 00 00 00 00 
2629   1912 00 00 00 00 
2629   1916 00 00 00 00 
2629   191A 00 00 00 00 
2629   191E 00 00 00 00 
2629   1922 00 00 00 00 
2629   1926 00 00 00 00 
2629   192A 00 00 00 00 
2629   192E 00 00 00 00 
2629   1932 00 00 00 00 
2629   1936 00 00 00 00 
2629   193A 00 00 00 00 
2629   193E 00 00 00 00 
2629   1942 00 00 00 00 
2629   1946 00 00 00 00 
2629   194A 00 00 00 00 
2629   194E 00 00 00 00 
2629   1952 00 00 00 00 
2629   1956 00 00 00 00 
2629   195A 00 00 00 00 
2629   195E 00 00 00 00 
2629   1962 00 00 00 00 
2629   1966 00 00 00 00 
2629   196A 00 00 00 00 
2629   196E 00 00 00 00 
2629   1972 00 00 00 00 
2629   1976 00 00 00 00 
2629   197A 00 00 00 00 
2629   197E 00 00 00 00 
2629   1982 00 00 00 00 
2630   1986 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2630   198A 00 00 00 00 
2630   198E 00 00 00 00 
2630   1992 00 00 00 00 
2631   1996 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2631   199A 00 00 00 00 
2631   199E 00 00 00 00 
2631   19A2 00 00 00 00 
2631   19A6 00 00 00 00 
2631   19AA 00 00 00 00 
2631   19AE 00 00 00 00 
2631   19B2 00 00 00 00 
2631   19B6 00 00 00 00 
2631   19BA 00 00 00 00 
2631   19BE 00 00 00 00 
2631   19C2 00 00 00 00 
2631   19C6 00 00 00 00 
2631   19CA 00 00 00 00 
2631   19CE 00 00 00 00 
2631   19D2 00 00 00 00 
2631   19D6 00 00 00 00 
2631   19DA 00 00 00 00 
2631   19DE 00 00 00 00 
2631   19E2 00 00 00 00 
2631   19E6 00 00 00 00 
2631   19EA 00 00 00 00 
2631   19EE 00 00 00 00 
2631   19F2 00 00 00 00 
2631   19F6 00 00 00 00 
2631   19FA 00 00 00 00 
2631   19FE 00 00 00 00 
2631   1A02 00 00 00 00 
2631   1A06 00 00 00 00 
2631   1A0A 00 00 00 00 
2631   1A0E 00 00 00 00 
2631   1A12 00 00 00 00 
2631   1A16 00 00 00 00 
2631   1A1A 00 00 00 00 
2631   1A1E 00 00 00 00 
2631   1A22 00 00 00 00 
2631   1A26 00 00 00 00 
2631   1A2A 00 00 00 00 
2631   1A2E 00 00 00 00 
2631   1A32 00 00 00 00 
2631   1A36 00 00 00 00 
2631   1A3A 00 00 00 00 
2631   1A3E 00 00 00 00 
2631   1A42 00 00 00 00 
2631   1A46 00 00 00 00 
2631   1A4A 00 00 00 00 
2631   1A4E 00 00 00 00 
2631   1A52 00 00 00 00 
2631   1A56 00 00 00 00 
2631   1A5A 00 00 00 00 
2631   1A5E 00 00 00 00 
2631   1A62 00 00 00 00 
2631   1A66 00 00 00 00 
2631   1A6A 00 00 00 00 
2631   1A6E 00 00 00 00 
2631   1A72 00 00 00 00 
2631   1A76 00 00 00 00 
2631   1A7A 00 00 00 00 
2631   1A7E 00 00 00 00 
2631   1A82 00 00 00 00 
2631   1A86 00 00 00 00 
2631   1A8A 00 00 00 00 
2631   1A8E 00 00 00 00 
2631   1A92 00 00 00 00 
2631   1A96 00 00 00 00 
2631   1A9A 00 00 00 00 
2631   1A9E 00 00 00 00 
2631   1AA2 00 00 00 00 
2631   1AA6 00 00 00 00 
2631   1AAA 00 00 00 00 
2631   1AAE 00 00 00 00 
2631   1AB2 00 00 00 00 
2631   1AB6 00 00 00 00 
2631   1ABA 00 00 00 00 
2631   1ABE 00 00 00 00 
2631   1AC2 00 00 00 00 
2631   1AC6 00 00 00 00 
2631   1ACA 00 00 00 00 
2631   1ACE 00 00 00 00 
2631   1AD2 00 00 00 00 
2631   1AD6 00 00 00 00 
2631   1ADA 00 00 00 00 
2631   1ADE 00 00 00 00 
2631   1AE2 00 00 00 00 
2631   1AE6 00 00 00 00 
2631   1AEA 00 00 00 00 
2631   1AEE 00 00 00 00 
2631   1AF2 00 00 00 00 
2631   1AF6 00 00 00 00 
2631   1AFA 00 00 00 00 
2631   1AFE 00 00 00 00 
2631   1B02 00 00 00 00 
2631   1B06 00 00 00 00 
2631   1B0A 00 00 00 00 
2631   1B0E 00 00 00 00 
2631   1B12 00 00 00 00 
2631   1B16 00 00 00 00 
2631   1B1A 00 00 00 00 
2631   1B1E 00 00 00 00 
2631   1B22 00 00 00 00 
2631   1B26 00 00 00 00 
2631   1B2A 00 00 00 00 
2631   1B2E 00 00 00 00 
2631   1B32 00 00 00 00 
2631   1B36 00 00 00 00 
2631   1B3A 00 00 00 00 
2631   1B3E 00 00 00 00 
2631   1B42 00 00 00 00 
2631   1B46 00 00 00 00 
2631   1B4A 00 00 00 00 
2631   1B4E 00 00 00 00 
2631   1B52 00 00 00 00 
2631   1B56 00 00 00 00 
2631   1B5A 00 00 00 00 
2631   1B5E 00 00 00 00 
2631   1B62 00 00 00 00 
2631   1B66 00 00 00 00 
2631   1B6A 00 00 00 00 
2631   1B6E 00 00 00 00 
2631   1B72 00 00 00 00 
2631   1B76 00 00 00 00 
2631   1B7A 00 00 00 00 
2631   1B7E 00 00 00 00 
2631   1B82 00 00 00 00 
2631   1B86 00 00 00 00 
2631   1B8A 00 00 00 00 
2631   1B8E 00 00 00 00 
2631   1B92 00 00 00 00 
2632   1B96 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2632   1B9A 00 00 00 00 
2632   1B9E 00 00 00 00 
2632   1BA2 00 00 00 00 
2632   1BA6 00 00 00 00 
2632   1BAA 00 00 00 00 
2632   1BAE 00 00 00 00 
2632   1BB2 00 00 00 00 
2632   1BB6 00 00 00 00 
2632   1BBA 00 00 00 00 
2632   1BBE 00 00 00 00 
2632   1BC2 00 00 00 00 
2632   1BC6 00 00 00 00 
2632   1BCA 00 00 00 00 
2632   1BCE 00 00 00 00 
2632   1BD2 00 00 00 00 
2632   1BD6 00 00 00 00 
2632   1BDA 00 00 00 00 
2632   1BDE 00 00 00 00 
2632   1BE2 00 00 00 00 
2632   1BE6 00 00 00 00 
2632   1BEA 00 00 00 00 
2632   1BEE 00 00 00 00 
2632   1BF2 00 00 00 00 
2632   1BF6 00 00 00 00 
2632   1BFA 00 00 00 00 
2632   1BFE 00 00 00 00 
2632   1C02 00 00 00 00 
2632   1C06 00 00 00 00 
2632   1C0A 00 00 00 00 
2632   1C0E 00 00 00 00 
2632   1C12 00 00 00 00 
2633   1C16 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2633   1C1A 00 00 00 00 
2633   1C1E 00 00 00 00 
2633   1C22 00 00 00 00 
2633   1C26 00 00 00 00 
2633   1C2A 00 00 00 00 
2633   1C2E 00 00 00 00 
2633   1C32 00 00 00 00 
2633   1C36 00 00 00 00 
2633   1C3A 00 00 00 00 
2633   1C3E 00 00 00 00 
2633   1C42 00 00 00 00 
2633   1C46 00 00 00 00 
2633   1C4A 00 00 00 00 
2633   1C4E 00 00 00 00 
2633   1C52 00 00 00 00 
2633   1C56 00 00 00 00 
2633   1C5A 00 00 00 00 
2633   1C5E 00 00 00 00 
2633   1C62 00 00 00 00 
2633   1C66 00 00 00 00 
2633   1C6A 00 00 00 00 
2633   1C6E 00 00 00 00 
2633   1C72 00 00 00 00 
2633   1C76 00 00 00 00 
2633   1C7A 00 00 00 00 
2633   1C7E 00 00 00 00 
2633   1C82 00 00 00 00 
2633   1C86 00 00 00 00 
2633   1C8A 00 00 00 00 
2633   1C8E 00 00 00 00 
2633   1C92 00 00 00 00 
2633   1C96 00 00 00 00 
2633   1C9A 00 00 00 00 
2633   1C9E 00 00 00 00 
2633   1CA2 00 00 00 00 
2633   1CA6 00 00 00 00 
2633   1CAA 00 00 00 00 
2633   1CAE 00 00 00 00 
2633   1CB2 00 00 00 00 
2633   1CB6 00 00 00 00 
2633   1CBA 00 00 00 00 
2633   1CBE 00 00 00 00 
2633   1CC2 00 00 00 00 
2633   1CC6 00 00 00 00 
2633   1CCA 00 00 00 00 
2633   1CCE 00 00 00 00 
2633   1CD2 00 00 00 00 
2633   1CD6 00 00 00 00 
2633   1CDA 00 00 00 00 
2633   1CDE 00 00 00 00 
2633   1CE2 00 00 00 00 
2633   1CE6 00 00 00 00 
2633   1CEA 00 00 00 00 
2633   1CEE 00 00 00 00 
2633   1CF2 00 00 00 00 
2633   1CF6 00 00 00 00 
2633   1CFA 00 00 00 00 
2633   1CFE 00 00 00 00 
2633   1D02 00 00 00 00 
2633   1D06 00 00 00 00 
2633   1D0A 00 00 00 00 
2633   1D0E 00 00 00 00 
2633   1D12 00 00 00 00 
2633   1D16 00 00 00 00 
2633   1D1A 00 00 00 00 
2633   1D1E 00 00 00 00 
2633   1D22 00 00 00 00 
2633   1D26 00 00 00 00 
2633   1D2A 00 00 00 00 
2633   1D2E 00 00 00 00 
2633   1D32 00 00 00 00 
2633   1D36 00 00 00 00 
2633   1D3A 00 00 00 00 
2633   1D3E 00 00 00 00 
2633   1D42 00 00 00 00 
2633   1D46 00 00 00 00 
2633   1D4A 00 00 00 00 
2633   1D4E 00 00 00 00 
2633   1D52 00 00 00 00 
2633   1D56 00 00 00 00 
2633   1D5A 00 00 00 00 
2633   1D5E 00 00 00 00 
2633   1D62 00 00 00 00 
2633   1D66 00 00 00 00 
2633   1D6A 00 00 00 00 
2633   1D6E 00 00 00 00 
2633   1D72 00 00 00 00 
2633   1D76 00 00 00 00 
2633   1D7A 00 00 00 00 
2633   1D7E 00 00 00 00 
2633   1D82 00 00 00 00 
2633   1D86 00 00 00 00 
2633   1D8A 00 00 00 00 
2633   1D8E 00 00 00 00 
2633   1D92 00 00 00 00 
2633   1D96 00 00 00 00 
2633   1D9A 00 00 00 00 
2633   1D9E 00 00 00 00 
2633   1DA2 00 00 00 00 
2633   1DA6 00 00 00 00 
2633   1DAA 00 00 00 00 
2633   1DAE 00 00 00 00 
2633   1DB2 00 00 00 00 
2633   1DB6 00 00 00 00 
2633   1DBA 00 00 00 00 
2633   1DBE 00 00 00 00 
2633   1DC2 00 00 00 00 
2633   1DC6 00 00 00 00 
2633   1DCA 00 00 00 00 
2633   1DCE 00 00 00 00 
2633   1DD2 00 00 00 00 
2633   1DD6 00 00 00 00 
2633   1DDA 00 00 00 00 
2633   1DDE 00 00 00 00 
2633   1DE2 00 00 00 00 
2633   1DE6 00 00 00 00 
2633   1DEA 00 00 00 00 
2633   1DEE 00 00 00 00 
2633   1DF2 00 00 00 00 
2633   1DF6 00 00 00 00 
2633   1DFA 00 00 00 00 
2633   1DFE 00 00 00 00 
2633   1E02 00 00 00 00 
2633   1E06 00 00 00 00 
2633   1E0A 00 00 00 00 
2633   1E0E 00 00 00 00 
2633   1E12 00 00 00 00 
2634   1E16 FF FF FF FF fifo:               .fill FIFO_SIZE
2634   1E1A FF FF FF FF 
2634   1E1E FF FF FF FF 
2634   1E22 FF FF FF FF 
2634   1E26 FF FF FF FF 
2634   1E2A FF FF FF FF 
2634   1E2E FF FF FF FF 
2634   1E32 FF FF FF FF 
2634   1E36 FF FF FF FF 
2634   1E3A FF FF FF FF 
2634   1E3E FF FF FF FF 
2634   1E42 FF FF FF FF 
2634   1E46 FF FF FF FF 
2634   1E4A FF FF FF FF 
2634   1E4E FF FF FF FF 
2634   1E52 FF FF FF FF 
2634   1E56 FF FF FF FF 
2634   1E5A FF FF FF FF 
2634   1E5E FF FF FF FF 
2634   1E62 FF FF FF FF 
2634   1E66 FF FF FF FF 
2634   1E6A FF FF FF FF 
2634   1E6E FF FF FF FF 
2634   1E72 FF FF FF FF 
2634   1E76 FF FF FF FF 
2634   1E7A FF FF FF FF 
2634   1E7E FF FF FF FF 
2634   1E82 FF FF FF FF 
2634   1E86 FF FF FF FF 
2634   1E8A FF FF FF FF 
2634   1E8E FF FF FF FF 
2634   1E92 FF FF FF FF 
2634   1E96 FF FF FF FF 
2634   1E9A FF FF FF FF 
2634   1E9E FF FF FF FF 
2634   1EA2 FF FF FF FF 
2634   1EA6 FF FF FF FF 
2634   1EAA FF FF FF FF 
2634   1EAE FF FF FF FF 
2634   1EB2 FF FF FF FF 
2634   1EB6 FF FF FF FF 
2634   1EBA FF FF FF FF 
2634   1EBE FF FF FF FF 
2634   1EC2 FF FF FF FF 
2634   1EC6 FF FF FF FF 
2634   1ECA FF FF FF FF 
2634   1ECE FF FF FF FF 
2634   1ED2 FF FF FF FF 
2634   1ED6 FF FF FF FF 
2634   1EDA FF FF FF FF 
2634   1EDE FF FF FF FF 
2634   1EE2 FF FF FF FF 
2634   1EE6 FF FF FF FF 
2634   1EEA FF FF FF FF 
2634   1EEE FF FF FF FF 
2634   1EF2 FF FF FF FF 
2634   1EF6 FF FF FF FF 
2634   1EFA FF FF FF FF 
2634   1EFE FF FF FF FF 
2634   1F02 FF FF FF FF 
2634   1F06 FF FF FF FF 
2634   1F0A FF FF FF FF 
2634   1F0E FF FF FF FF 
2634   1F12 FF FF FF FF 
2634   1F16 FF FF FF FF 
2634   1F1A FF FF FF FF 
2634   1F1E FF FF FF FF 
2634   1F22 FF FF FF FF 
2634   1F26 FF FF FF FF 
2634   1F2A FF FF FF FF 
2634   1F2E FF FF FF FF 
2634   1F32 FF FF FF FF 
2634   1F36 FF FF FF FF 
2634   1F3A FF FF FF FF 
2634   1F3E FF FF FF FF 
2634   1F42 FF FF FF FF 
2634   1F46 FF FF FF FF 
2634   1F4A FF FF FF FF 
2634   1F4E FF FF FF FF 
2634   1F52 FF FF FF FF 
2634   1F56 FF FF FF FF 
2634   1F5A FF FF FF FF 
2634   1F5E FF FF FF FF 
2634   1F62 FF FF FF FF 
2634   1F66 FF FF FF FF 
2634   1F6A FF FF FF FF 
2634   1F6E FF FF FF FF 
2634   1F72 FF FF FF FF 
2634   1F76 FF FF FF FF 
2634   1F7A FF FF FF FF 
2634   1F7E FF FF FF FF 
2634   1F82 FF FF FF FF 
2634   1F86 FF FF FF FF 
2634   1F8A FF FF FF FF 
2634   1F8E FF FF FF FF 
2634   1F92 FF FF FF FF 
2634   1F96 FF FF FF FF 
2634   1F9A FF FF FF FF 
2634   1F9E FF FF FF FF 
2634   1FA2 FF FF FF FF 
2634   1FA6 FF FF FF FF 
2634   1FAA FF FF FF FF 
2634   1FAE FF FF FF FF 
2634   1FB2 FF FF FF FF 
2634   1FB6 FF FF FF FF 
2634   1FBA FF FF FF FF 
2634   1FBE FF FF FF FF 
2634   1FC2 FF FF FF FF 
2634   1FC6 FF FF FF FF 
2634   1FCA FF FF FF FF 
2634   1FCE FF FF FF FF 
2634   1FD2 FF FF FF FF 
2634   1FD6 FF FF FF FF 
2634   1FDA FF FF FF FF 
2634   1FDE FF FF FF FF 
2634   1FE2 FF FF FF FF 
2634   1FE6 FF FF FF FF 
2634   1FEA FF FF FF FF 
2634   1FEE FF FF FF FF 
2634   1FF2 FF FF FF FF 
2634   1FF6 FF FF FF FF 
2634   1FFA FF FF FF FF 
2634   1FFE FF FF FF FF 
2634   2002 FF FF FF FF 
2634   2006 FF FF FF FF 
2634   200A FF FF FF FF 
2634   200E FF FF FF FF 
2634   2012 FF FF FF FF 
2634   2016 FF FF FF FF 
2634   201A FF FF FF FF 
2634   201E FF FF FF FF 
2634   2022 FF FF FF FF 
2634   2026 FF FF FF FF 
2634   202A FF FF FF FF 
2634   202E FF FF FF FF 
2634   2032 FF FF FF FF 
2634   2036 FF FF FF FF 
2634   203A FF FF FF FF 
2634   203E FF FF FF FF 
2634   2042 FF FF FF FF 
2634   2046 FF FF FF FF 
2634   204A FF FF FF FF 
2634   204E FF FF FF FF 
2634   2052 FF FF FF FF 
2634   2056 FF FF FF FF 
2634   205A FF FF FF FF 
2634   205E FF FF FF FF 
2634   2062 FF FF FF FF 
2634   2066 FF FF FF FF 
2634   206A FF FF FF FF 
2634   206E FF FF FF FF 
2634   2072 FF FF FF FF 
2634   2076 FF FF FF FF 
2634   207A FF FF FF FF 
2634   207E FF FF FF FF 
2634   2082 FF FF FF FF 
2634   2086 FF FF FF FF 
2634   208A FF FF FF FF 
2634   208E FF FF FF FF 
2634   2092 FF FF FF FF 
2634   2096 FF FF FF FF 
2634   209A FF FF FF FF 
2634   209E FF FF FF FF 
2634   20A2 FF FF FF FF 
2634   20A6 FF FF FF FF 
2634   20AA FF FF FF FF 
2634   20AE FF FF FF FF 
2634   20B2 FF FF FF FF 
2634   20B6 FF FF FF FF 
2634   20BA FF FF FF FF 
2634   20BE FF FF FF FF 
2634   20C2 FF FF FF FF 
2634   20C6 FF FF FF FF 
2634   20CA FF FF FF FF 
2634   20CE FF FF FF FF 
2634   20D2 FF FF FF FF 
2634   20D6 FF FF FF FF 
2634   20DA FF FF FF FF 
2634   20DE FF FF FF FF 
2634   20E2 FF FF FF FF 
2634   20E6 FF FF FF FF 
2634   20EA FF FF FF FF 
2634   20EE FF FF FF FF 
2634   20F2 FF FF FF FF 
2634   20F6 FF FF FF FF 
2634   20FA FF FF FF FF 
2634   20FE FF FF FF FF 
2634   2102 FF FF FF FF 
2634   2106 FF FF FF FF 
2634   210A FF FF FF FF 
2634   210E FF FF FF FF 
2634   2112 FF FF FF FF 
2634   2116 FF FF FF FF 
2634   211A FF FF FF FF 
2634   211E FF FF FF FF 
2634   2122 FF FF FF FF 
2634   2126 FF FF FF FF 
2634   212A FF FF FF FF 
2634   212E FF FF FF FF 
2634   2132 FF FF FF FF 
2634   2136 FF FF FF FF 
2634   213A FF FF FF FF 
2634   213E FF FF FF FF 
2634   2142 FF FF FF FF 
2634   2146 FF FF FF FF 
2634   214A FF FF FF FF 
2634   214E FF FF FF FF 
2634   2152 FF FF FF FF 
2634   2156 FF FF FF FF 
2634   215A FF FF FF FF 
2634   215E FF FF FF FF 
2634   2162 FF FF FF FF 
2634   2166 FF FF FF FF 
2634   216A FF FF FF FF 
2634   216E FF FF FF FF 
2634   2172 FF FF FF FF 
2634   2176 FF FF FF FF 
2634   217A FF FF FF FF 
2634   217E FF FF FF FF 
2634   2182 FF FF FF FF 
2634   2186 FF FF FF FF 
2634   218A FF FF FF FF 
2634   218E FF FF FF FF 
2634   2192 FF FF FF FF 
2634   2196 FF FF FF FF 
2634   219A FF FF FF FF 
2634   219E FF FF FF FF 
2634   21A2 FF FF FF FF 
2634   21A6 FF FF FF FF 
2634   21AA FF FF FF FF 
2634   21AE FF FF FF FF 
2634   21B2 FF FF FF FF 
2634   21B6 FF FF FF FF 
2634   21BA FF FF FF FF 
2634   21BE FF FF FF FF 
2634   21C2 FF FF FF FF 
2634   21C6 FF FF FF FF 
2634   21CA FF FF FF FF 
2634   21CE FF FF FF FF 
2634   21D2 FF FF FF FF 
2634   21D6 FF FF FF FF 
2634   21DA FF FF FF FF 
2634   21DE FF FF FF FF 
2634   21E2 FF FF FF FF 
2634   21E6 FF FF FF FF 
2634   21EA FF FF FF FF 
2634   21EE FF FF FF FF 
2634   21F2 FF FF FF FF 
2634   21F6 FF FF FF FF 
2634   21FA FF FF FF FF 
2634   21FE FF FF FF FF 
2634   2202 FF FF FF FF 
2634   2206 FF FF FF FF 
2634   220A FF FF FF FF 
2634   220E FF FF FF FF 
2634   2212 FF FF FF FF 
2635   2216             
2636   2216 FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2636   221A FF FF FF FF 
2636   221E FF FF FF FF 
2636   2222 FF FF FF FF 
2636   2226 FF FF FF FF 
2636   222A FF FF FF FF 
2636   222E FF FF FF FF 
2636   2232 FF FF FF FF 
2636   2236 FF FF FF FF 
2636   223A FF FF FF FF 
2636   223E FF FF FF FF 
2636   2242 FF FF FF FF 
2636   2246 FF FF FF FF 
2636   224A FF FF FF FF 
2636   224E FF FF FF FF 
2636   2252 FF FF FF FF 
2636   2256 FF FF FF FF 
2636   225A FF FF FF FF 
2636   225E FF FF FF FF 
2636   2262 FF FF FF FF 
2636   2266 FF FF FF FF 
2636   226A FF FF FF FF 
2636   226E FF FF FF FF 
2636   2272 FF FF FF FF 
2636   2276 FF FF FF FF 
2636   227A FF FF FF FF 
2636   227E FF FF FF FF 
2636   2282 FF FF FF FF 
2636   2286 FF FF FF FF 
2636   228A FF FF FF FF 
2636   228E FF FF FF FF 
2636   2292 FF FF FF FF 
2636   2296 FF FF FF FF 
2636   229A FF FF FF FF 
2636   229E FF FF FF FF 
2636   22A2 FF FF FF FF 
2636   22A6 FF FF FF FF 
2636   22AA FF FF FF FF 
2636   22AE FF FF FF FF 
2636   22B2 FF FF FF FF 
2636   22B6 FF FF FF FF 
2636   22BA FF FF FF FF 
2636   22BE FF FF FF FF 
2636   22C2 FF FF FF FF 
2636   22C6 FF FF FF FF 
2636   22CA FF FF FF FF 
2636   22CE FF FF FF FF 
2636   22D2 FF FF FF FF 
2636   22D6 FF FF FF FF 
2636   22DA FF FF FF FF 
2636   22DE FF FF FF FF 
2636   22E2 FF FF FF FF 
2636   22E6 FF FF FF FF 
2636   22EA FF FF FF FF 
2636   22EE FF FF FF FF 
2636   22F2 FF FF FF FF 
2636   22F6 FF FF FF FF 
2636   22FA FF FF FF FF 
2636   22FE FF FF FF FF 
2636   2302 FF FF FF FF 
2636   2306 FF FF FF FF 
2636   230A FF FF FF FF 
2636   230E FF FF FF FF 
2636   2312 FF FF FF FF 
2636   2316 FF FF FF FF 
2636   231A FF FF FF FF 
2636   231E FF FF FF FF 
2636   2322 FF FF FF FF 
2636   2326 FF FF FF FF 
2636   232A FF FF FF FF 
2636   232E FF FF FF FF 
2636   2332 FF FF FF FF 
2636   2336 FF FF FF FF 
2636   233A FF FF FF FF 
2636   233E FF FF FF FF 
2636   2342 FF FF FF FF 
2636   2346 FF FF FF FF 
2636   234A FF FF FF FF 
2636   234E FF FF FF FF 
2636   2352 FF FF FF FF 
2636   2356 FF FF FF FF 
2636   235A FF FF FF FF 
2636   235E FF FF FF FF 
2636   2362 FF FF FF FF 
2636   2366 FF FF FF FF 
2636   236A FF FF FF FF 
2636   236E FF FF FF FF 
2636   2372 FF FF FF FF 
2636   2376 FF FF FF FF 
2636   237A FF FF FF FF 
2636   237E FF FF FF FF 
2636   2382 FF FF FF FF 
2636   2386 FF FF FF FF 
2636   238A FF FF FF FF 
2636   238E FF FF FF FF 
2636   2392 FF FF FF FF 
2636   2396 FF FF FF FF 
2636   239A FF FF FF FF 
2636   239E FF FF FF FF 
2636   23A2 FF FF FF FF 
2636   23A6 FF FF FF FF 
2636   23AA FF FF FF FF 
2636   23AE FF FF FF FF 
2636   23B2 FF FF FF FF 
2636   23B6 FF FF FF FF 
2636   23BA FF FF FF FF 
2636   23BE FF FF FF FF 
2636   23C2 FF FF FF FF 
2636   23C6 FF FF FF FF 
2636   23CA FF FF FF FF 
2636   23CE FF FF FF FF 
2636   23D2 FF FF FF FF 
2636   23D6 FF FF FF FF 
2636   23DA FF FF FF FF 
2636   23DE FF FF FF FF 
2636   23E2 FF FF FF FF 
2636   23E6 FF FF FF FF 
2636   23EA FF FF FF FF 
2636   23EE FF FF FF FF 
2636   23F2 FF FF FF FF 
2636   23F6 FF FF FF FF 
2636   23FA FF FF FF FF 
2636   23FE FF FF FF FF 
2636   2402 FF FF FF FF 
2636   2406 FF FF FF FF 
2636   240A FF FF FF FF 
2636   240E FF FF FF FF 
2636   2412 FF FF FF FF 
2637   2416 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2638   2417             
2639   2417             
2640   2417             .end
tasm: Number of errors = 0
