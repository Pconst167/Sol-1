0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             ; Memory Map
0005   0000             ; ------------------------------------------------------------------------------------------------------------------;
0006   0000             ; 0000    ROM BEGIN
0007   0000             ; ....
0008   0000             ; 7FFF    ROM END
0009   0000             ;
0010   0000             ; 8000    RAM begin
0011   0000             ; ....
0012   0000             ; F7FF    Stack root
0013   0000             ; ------------------------------------------------------------------------------------------------------------------;
0014   0000             ; I/O MAP
0015   0000             ; ------------------------------------------------------------------------------------------------------------------;
0016   0000             ; FF80    UART 0              (16550)
0017   0000             ; FF90    UART 1              (16550)
0018   0000             ; FFA0    RTC                 (M48T02)
0019   0000             ; FFB0    PIO 0               (8255)
0020   0000             ; FFC0    5.25" Floppy Drive Block
0021   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0022   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0023   0000             ;   - FFC8      WD1770 Status/Command    
0024   0000             ;   - FFC9      WD1770 Track Register
0025   0000             ;   - FFCA      WD1770 Sector Register
0026   0000             ;   - FFCB      WD1770 Data Register
0027   0000             ;      
0028   0000             ; FFD0    IDE                 (Compact Flash / PATA)
0029   0000             ; FFE0    Timer               (8253)
0030   0000             ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0031   0000             ; ------------------------------------------------------------------------------------------------------------------;
0032   0000             
0033   0000             ; ------------------------------------------------------------------------------------------------------------------;
0034   0000             ; System Constants
0035   0000             ; ------------------------------------------------------------------------------------------------------------------;
0036   0000             _UART0_DATA       .equ $FF80            ; data
0037   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0038   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0039   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0040   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0041   0000             _UART0_LCR        .equ $FF83            ; line control register
0042   0000             _UART0_LSR        .equ $FF85            ; line status register
0043   0000             
0044   0000             _UART1_DATA       .equ $FF90            ; data
0045   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0046   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0047   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0048   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0049   0000             _UART1_LCR        .equ $FF93            ; line control register
0050   0000             _UART1_LSR        .equ $FF95            ; line status register
0051   0000             
0052   0000             XON               .equ $11
0053   0000             XOFF              .equ $13
0054   0000             
0055   0000             _ide_BASE         .equ $FFD0            ; IDE BASE
0056   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0057   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0058   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0059   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0060   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0061   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0062   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0063   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0064   0000             
0065   0000             _7SEG_DISPLAY     .equ $FFB0            ; BIOS POST CODE HEX DISPLAY (2 DIGITS) (CONNECTED TO PIO A)
0066   0000             _BIOS_POST_CTRL   .equ $FFB3            ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0067   0000             _PIO_A            .equ $FFB0    
0068   0000             _PIO_B            .equ $FFB1
0069   0000             _PIO_C            .equ $FFB2
0070   0000             _PIO_CONTROL      .equ $FFB3            ; PIO CONTROL PORT
0071   0000             
0072   0000             _FDC_CONFIG       .equ $FFC0 
0073   0000             _FDC_STATUS_1     .equ $FFC1
0074   0000             _FDC_WD_STAT_CMD  .equ $FFC8
0075   0000             _FDC_WD_TRACK     .equ $FFC9
0076   0000             _FDC_WD_SECTOR    .equ $FFCA
0077   0000             _FDC_WD_DATA      .equ $FFCB
0078   0000             
0079   0000             _TIMER_C_0        .equ $FFE0            ; TIMER COUNTER 0
0080   0000             _TIMER_C_1        .equ $FFE1            ; TIMER COUNTER 1
0081   0000             _TIMER_C_2        .equ $FFE2            ; TIMER COUNTER 2
0082   0000             _TIMER_CTRL       .equ $FFE3            ; TIMER CONTROL REGISTER
0083   0000             
0084   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0085   0000             FIFO_SIZE         .equ 1024
0086   0000             
0087   0000             text_org          .equ $400
0088   0000             ; ------------------------------------------------------------------------------------------------------------------;
0089   0000             
0090   0000             
0091   0000             ; For the next iteration:
0092   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0093   0000             ; inode-table format:
0094   0000             ;  file-type(f, d)
0095   0000             ;  permissons
0096   0000             ;  link-count
0097   0000             ;  filesize
0098   0000             ;  time-stamps
0099   0000             ;  15 data block pointers
0100   0000             ;  single-indirect pointer
0101   0000             
0102   0000             ; FILE ENTRY ATTRIBUTES
0103   0000             ; filename (24)
0104   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0105   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0106   0000             ; size (2)             : filesize
0107   0000             ; day (1)           
0108   0000             ; month (1)
0109   0000             ; year (1)
0110   0000             ; packet size = 32 bytes  : total packet size in bytes
0111   0000             
0112   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0113   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0114   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0115   0000             FST_NBR_DIRECTORIES     .equ 64
0116   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0117   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0118   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0119   0000             FST_LBA_START           .equ 32
0120   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0121   0000             
0122   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0123   0000             FS_SECTORS_PER_FILE     .equ 32         ; the first sector is always a header with a NULL parameter (first byte)
0124   0000                                                     ; so that we know which blocks are free or taken
0125   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0126   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0127   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0128   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0129   0000             
0130   0000             root_id:                .equ FST_LBA_START
0131   0000             
0132   0000             ; ------------------------------------------------------------------------------------------------------------------;
0133   0000             ; GLOBAL SYSTEM VARIABLES
0134   0000             ; ------------------------------------------------------------------------------------------------------------------;
0135   0000             
0136   0000             ; ------------------------------------------------------------------------------------------------------------------;
0137   0000             ; IRQ Table
0138   0000             ; Highest priority at lowest address
0139   0000             ; ------------------------------------------------------------------------------------------------------------------;
0140   0000 3C 00       .dw int_0_fdc
0141   0002 43 00       .dw int_1
0142   0004 44 00       .dw int_2
0143   0006 45 00       .dw int_3
0144   0008 46 00       .dw int_4
0145   000A 47 00       .dw int_5
0146   000C 59 00       .dw int_6
0147   000E A5 00       .dw int_7_uart0
0148   0010             
0149   0010             ; ------------------------------------------------------------------------------------------------------------------;
0150   0010             ; Reset Vector
0151   0010             ; ------------------------------------------------------------------------------------------------------------------;
0152   0010 01 10       .dw kernel_reset_vector
0153   0012             
0154   0012             ; ------------------------------------------------------------------------------------------------------------------;
0155   0012             ; Exception Vector Table
0156   0012             ; Total of 7 entries, starting at address $0012
0157   0012             ; ------------------------------------------------------------------------------------------------------------------;
0158   0012 F9 01       .dw trap_privilege
0159   0014 16 03       .dw trap_div_zero
0160   0016 23 03       .dw trap_undef_opcode
0161   0018 00 00       .dw 0
0162   001A 00 00       .dw 0
0163   001C 00 00       .dw 0
0164   001E 00 00       .dw 0
0165   0020             
0166   0020             ; ------------------------------------------------------------------------------------------------------------------;
0167   0020             ; System Call Vector Table
0168   0020             ; Starts at address $0020
0169   0020             ; ------------------------------------------------------------------------------------------------------------------;
0170   0020 05 02       .dw syscall_break
0171   0022 24 03       .dw syscall_rtc
0172   0024 5E 04       .dw syscall_ide
0173   0026 39 05       .dw syscall_io
0174   0028 F6 05       .dw syscall_file_system
0175   002A 4E 0F       .dw syscall_create_proc
0176   002C BE 01       .dw syscall_list_procs
0177   002E 56 03       .dw syscall_datetime
0178   0030 7A 01       .dw syscall_reboot
0179   0032 18 0F       .dw syscall_pause_proc
0180   0034 86 01       .dw syscall_resume_proc
0181   0036 D5 0E       .dw syscall_terminate_proc
0182   0038 E4 00       .dw syscall_system
0183   003A 14 01       .dw syscall_fdc
0184   003C             
0185   003C             ; ------------------------------------------------------------------------------------------------------------------;
0186   003C             ; System Call Aliases
0187   003C             ; ------------------------------------------------------------------------------------------------------------------;
0188   003C             sys_break            .equ 0
0189   003C             sys_rtc              .equ 1
0190   003C             sys_ide              .equ 2
0191   003C             sys_io               .equ 3
0192   003C             sys_filesystem       .equ 4
0193   003C             sys_create_proc      .equ 5
0194   003C             sys_list_proc        .equ 6
0195   003C             sys_datetime         .equ 7
0196   003C             sys_reboot           .equ 8
0197   003C             sys_pause_proc       .equ 9
0198   003C             sys_resume_proc      .equ 10
0199   003C             sys_terminate_proc   .equ 11
0200   003C             sys_system           .equ 12
0201   003C             sys_fdc              .equ 13
0202   003C             
0203   003C             ; ------------------------------------------------------------------------------------------------------------------;
0204   003C             ; Alias Exports
0205   003C             ; ------------------------------------------------------------------------------------------------------------------;
0206   003C             .export text_org
0207   003C             .export sys_break
0208   003C             .export sys_rtc
0209   003C             .export sys_ide
0210   003C             .export sys_io
0211   003C             .export sys_filesystem
0212   003C             .export sys_create_proc
0213   003C             .export sys_list_proc
0214   003C             .export sys_datetime
0215   003C             .export sys_reboot
0216   003C             .export sys_pause_proc
0217   003C             .export sys_resume_proc
0218   003C             .export sys_terminate_proc
0219   003C             .export sys_system
0220   003C             .export sys_fdc
0221   003C             
0222   003C             ; ------------------------------------------------------------------------------------------------------------------;
0223   003C             ; IRQs' Code Block
0224   003C             ; ------------------------------------------------------------------------------------------------------------------;
0225   003C             ; 5.25" Floppy Drive Controller IRQ
0226   003C             int_0_fdc:
0227   003C 3B 48 00      mov d, s_fdc_irq
0228   003F 07 4B 12      call _puts
0229   0042 06            sysret
0230   0043             int_1:
0231   0043 06            sysret
0232   0044             int_2:
0233   0044 06            sysret
0234   0045             int_3:
0235   0045 06            sysret
0236   0046             int_4:
0237   0046 06            sysret
0238   0047             int_5:
0239   0047 06            sysret
0240   0048             
0241   0048 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
0241   004C 30 20 45 78 
0241   0050 65 63 75 74 
0241   0054 65 64 2E 0A 
0241   0058 00 
0242   0059             
0243   0059             ; ------------------------------------------------------------------------------------------------------------------;
0244   0059             ; Process Swapping
0245   0059             ; ------------------------------------------------------------------------------------------------------------------;
0246   0059             int_6:  
0247   0059 4B            pusha ; save all registers into kernel stack
0248   005A 22 00         mov ah, 0
0249   005C 1D 7C 17      mov al, [active_proc_index]
0250   005F FD 99         shl a              ; x2
0251   0061 B7 CB 0F      mov a, [proc_table_convert + a]  ; get process state start index
0252   0064 4F            mov di, a
0253   0065 48            mov a, sp
0254   0066 77            inc a
0255   0067 4D            mov si, a
0256   0068 38 14 00      mov c, 20
0257   006B FD F5         rep movsb          ; save process state!
0258   006D             ; restore kernel stack position to point before interrupt arrived
0259   006D 51 14 00      add sp, 20
0260   0070             ; now load next process in queue
0261   0070 1D 7C 17      mov al, [active_proc_index]
0262   0073 31 7B 17      mov bl, [nbr_active_procs]
0263   0076 BA            cmp al, bl
0264   0077 C6 7E 00      je int6_cycle_back
0265   007A 7A            inc al            ; next process is next in the series
0266   007B 0A 80 00      jmp int6_continue
0267   007E             int6_cycle_back:
0268   007E 19 01         mov al, 1        ; next process = process 1
0269   0080             int6_continue:
0270   0080 3D 7C 17      mov [active_proc_index], al    ; set next active proc
0271   0083             
0272   0083             ; calculate LUT entry for next process
0273   0083 22 00         mov ah, 0
0274   0085 FD 99         shl a              ; x2
0275   0087 B7 CB 0F      mov a, [proc_table_convert + a]    ; get process state start index  
0276   008A               
0277   008A 4D            mov si, a            ; source is proc state block
0278   008B 48            mov a, sp
0279   008C 5F 13 00      sub a, 19
0280   008F 4F            mov di, a            ; destination is kernel stack
0281   0090             ; restore SP
0282   0090 7D            dec a
0283   0091 47            mov sp, a
0284   0092 38 14 00      mov c, 20
0285   0095 FD F5         rep movsb
0286   0097             ; set VM process
0287   0097 1D 7C 17      mov al, [active_proc_index]
0288   009A 01            setptb
0289   009B F2 E0 FF 00   mov byte[_TIMER_C_0], 0        ; load counter 0 low byte
0290   009F F2 E0 FF 10   mov byte[_TIMER_C_0], $10        ; load counter 0 high byte
0291   00A3 4C            popa
0292   00A4 06            sysret
0293   00A5             
0294   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0295   00A5             ; UART0 Interrupt
0296   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0297   00A5             int_7_uart0:
0298   00A5 D7            push a
0299   00A6 DA            push d
0300   00A7 E1            pushf
0301   00A8 14 81 17      mov a, [fifo_in]
0302   00AB 3C            mov d, a
0303   00AC 1D 80 FF      mov al, [_UART0_DATA]  ; get character
0304   00AF B9 03         cmp al, $03        ; CTRL-C
0305   00B1 C6 CE 00      je CTRLC
0306   00B4 B9 1A         cmp al, $1A        ; CTRL-Z
0307   00B6 C6 D4 00      je CTRLZ
0308   00B9 3E            mov [d], al        ; add to fifo
0309   00BA 14 81 17      mov a, [fifo_in]
0310   00BD 77            inc a
0311   00BE AF C2 24      cmp a, fifo + FIFO_SIZE         ; check if pointer reached the end of the fifo
0312   00C1 C7 C7 00      jne int_7_continue
0313   00C4 10 C2 20      mov a, fifo  
0314   00C7             int_7_continue:  
0315   00C7 42 81 17      mov [fifo_in], a      ; update fifo pointer
0316   00CA EE            popf
0317   00CB E7            pop d
0318   00CC E4            pop a  
0319   00CD 06            sysret
0320   00CE             CTRLC:
0321   00CE 51 05 00      add sp, 5
0322   00D1 0A D5 0E      jmp syscall_terminate_proc
0323   00D4             CTRLZ:
0324   00D4 EE            popf
0325   00D5 E7            pop d
0326   00D6 E4            pop a
0327   00D7 0A 18 0F      jmp syscall_pause_proc    ; pause current process and go back to the shell
0328   00DA             
0329   00DA             
0330   00DA             
0331   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0332   00DA             ; System Syscalls
0333   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0334   00DA             system_jmptbl:
0335   00DA 10 01         .dw system_uname
0336   00DC 11 01         .dw system_whoami
0337   00DE 0D 01         .dw system_setparam
0338   00E0 EA 00         .dw system_bootloader_install
0339   00E2 E8 00         .dw system_getparam
0340   00E4             syscall_system:
0341   00E4 FD 0A DA 00   jmp [system_jmptbl + al]
0342   00E8             
0343   00E8             ; param register address in register d
0344   00E8             ; param value in register bl
0345   00E8             system_getparam:
0346   00E8 32            mov bl, [d]
0347   00E9 06            sysret
0348   00EA             
0349   00EA             ; kernel LBA address in 'b'
0350   00EA             system_bootloader_install:
0351   00EA D8            push b
0352   00EB 26 00 00      mov b, 0
0353   00EE 38 00 00      mov c, 0
0354   00F1 22 01         mov ah, $01                 ; 1 sector
0355   00F3 3B C2 26      mov d, transient_area
0356   00F6 07 A8 04      call ide_read_sect          ; read sector
0357   00F9 E5            pop b
0358   00FA FD 44 FE 01   mov [d + 510], b            ; update LBA address
0359   00FE 26 00 00      mov b, 0
0360   0101 38 00 00      mov c, 0
0361   0104 22 01         mov ah, $01                 ; 1 sector
0362   0106 3B C2 26      mov d, transient_area
0363   0109 07 CE 04      call ide_write_sect         ; write sector
0364   010C 06            sysret
0365   010D             
0366   010D             ; param register address in register d
0367   010D             ; param value in register bl
0368   010D             system_setparam:
0369   010D FD 3E         mov [d], bl
0370   010F 06            sysret
0371   0110             
0372   0110             system_uname:
0373   0110 06            sysret
0374   0111             
0375   0111             system_whoami:
0376   0111 06            sysret
0377   0112             
0378   0112             
0379   0112             ; the floppy control below is not yet tested. it needs to be tested.
0380   0112             ; fdc_40_FF:     .fill 40,  $FF  ; or 00                                                                                
0381   0112             ; fdc_6_00_0:    .fill 6,   $00  ;                                                                            <--|        
0382   0112             ; fdc_id_fe:     .fill 1,   $FE  ; ID Address Mark                                                               |        
0383   0112             ; fdc_track:     .fill 1,   $00  ; Track Number                                                                  |                    
0384   0112             ; fdc_side:      .fill 1,   $00  ; Side Number 00 or 01                                                          |                
0385   0112             ; fdc_sector:    .fill 1,   $01  ; Sector Number  1 through 10                                                   |                              
0386   0112             ; fdc_length:    .fill 1,   $00  ; Sector Length                                                                 |                        
0387   0112             ; fdc_2_crc_0:   .fill 1,   $F7  ; 2 CRC's Written                                                               | Write 16 times                 
0388   0112             ; fdc_11_ff:     .fill 11,  $FF  ; or 00                                                                         |                      
0389   0112             ; fdc_6_00_1:    .fill 6,   $00  ;                                                                               |                        
0390   0112             ; fdc_data_addr: .fill 1,   $FB  ; Data Address Mark                                                             |                                  
0391   0112             ; fdc_data:      .fill 128, $E5  ; Data (IBM uses E5)                                                            |                                      
0392   0112             ; fdc_2_crc_1:   .fill 1,   $F7  ; 2 CRC's Written                                                               |                                                        
0393   0112             ; fdc_10_ff:     .fill 10,  $FF  ; or 00                                                                      <--|                                                  
0394   0112             ; fdc_369_ff:    .fill 369, $FF  ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0395   0112             ; ***************************************************************************************************************
0396   0112             ; _FDC_CONFIG       .equ $FFC0 
0397   0112             ; _FDC_STATUS_1     .equ $FFC1
0398   0112             ; _FDC_WD_STAT_CMD  .equ $FFC8
0399   0112             ; _FDC_WD_TRACK     .equ $FFC9
0400   0112             ; _FDC_WD_SECTOR    .equ $FFCA
0401   0112             ; _FDC_WD_DATA      .equ $FFCB
0402   0112             fdc_jmptbl:
0403   0112 18 01         .dw syscall_fdc_format
0404   0114             syscall_fdc:
0405   0114 FD 0A 12 01   jmp [fdc_jmptbl + al]
0406   0118             
0407   0118             syscall_fdc_format:
0408   0118 FD 22 FF 00   mov g, $FF
0409   011C             fdc_wait_busy:
0410   011C 1D C8 FF      mov al, [_FDC_WD_STAT_CMD] ; read wd1770 status register
0411   011F 87 01         and al, $01                ; busy bit
0412   0121 C7 1C 01      jnz fdc_wait_busy
0413   0124             
0414   0124 FD 4D B0 18   mov si, fdc_40_FF
0415   0128 38 D1 00      mov c, 209
0416   012B             fdc_sector_loop:
0417   012B             fdc_drq_loop:
0418   012B 3B C1 FF      mov d, _FDC_STATUS_1
0419   012E 1E            mov al, [d]
0420   012F 87 01         and al, $01               ; check drq bit
0421   0131 C6 2B 01      jz fdc_drq_loop
0422   0134 F6            lodsb                     ; load format byte
0423   0135 3B CB FF      mov d, _FDC_WD_DATA       ; data register
0424   0138 3E            mov [d], al               ; send data byte to wd1770
0425   0139 7E            dec c
0426   013A C7 2B 01      jnz fdc_sector_loop
0427   013D 3B E1 18      mov d, fdc_sector
0428   0140 32            mov bl, [d]
0429   0141 FD 77         inc b
0430   0143 FD 3E         mov [d], bl
0431   0145 C1 0B         cmp bl, 11
0432   0147 C7 2B 01      jne fdc_sector_loop       ; continue formatting
0433   014A             
0434   014A             ; here all the sectors have been written. now fill in remaining of the track until wd1770 interrupts out
0435   014A             fdc_drq_loop_fill:
0436   014A 3B C1 FF      mov d, _FDC_STATUS_1
0437   014D 1E            mov al, [d]
0438   014E 87 01         and al, $01               ; check drq bit
0439   0150 C6 4A 01      jz fdc_drq_loop_fill
0440   0153 3B CB FF      mov d, _FDC_WD_DATA       ; data register
0441   0156 FD 1A         mov al, gl
0442   0158 3E            mov [d], al               ; send data byte to wd1770
0443   0159 0C            lodstat
0444   015A 1A            mov al, ah
0445   015B 87 01         and al, $01
0446   015D C6 4A 01      jz fdc_drq_loop_fill
0447   0160             
0448   0160 3B 67 01      mov d, s_format_done
0449   0163 07 4B 12      call _puts
0450   0166             
0451   0166 06            sysret
0452   0167             
0453   0167 0A 46 6F 72 s_format_done: .db "\nFormatting done.\n", 0
0453   016B 6D 61 74 74 
0453   016F 69 6E 67 20 
0453   0173 64 6F 6E 65 
0453   0177 2E 0A 00 
0454   017A             
0455   017A             ; REBOOT SYSTEM
0456   017A             syscall_reboot:
0457   017A FD D7 FF FF   push word $FFFF 
0458   017E FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0459   0181 FD D7 C0 01   push word BIOS_RESET_VECTOR    ; and then push RESET VECTOR of the shell to the stack
0460   0185 06            sysret
0461   0186             
0462   0186             ;------------------------------------------------------------------------------------------------------;;
0463   0186             ; switch to another process
0464   0186             ; inputs:
0465   0186             ; AL = new process number
0466   0186             ;------------------------------------------------------------------------------------------------------;;
0467   0186             syscall_resume_proc:
0468   0186 FD 78         mov g, a                            ; save the process number
0469   0188 4B            pusha                               ; save all registers into kernel stack
0470   0189 22 00         mov ah, 0
0471   018B 1D 7C 17      mov al, [active_proc_index]
0472   018E FD 99         shl a              ; x2
0473   0190 B7 CB 0F      mov a, [proc_table_convert + a]     ; get process state start index
0474   0193 4F            mov di, a
0475   0194 48            mov a, sp
0476   0195 77            inc a
0477   0196 4D            mov si, a
0478   0197 38 14 00      mov c, 20
0479   019A FD F5         rep movsb                           ; save process state!
0480   019C             ; restore kernel stack position to point before interrupt arrived
0481   019C 51 14 00      add sp, 20
0482   019F             ; now load the new process number!
0483   019F FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0484   01A1 3D 7C 17      mov [active_proc_index], al         ; set new active proc
0485   01A4             ; calculate LUT entry for next process
0486   01A4 22 00         mov ah, 0
0487   01A6 FD 99         shl a                               ; x2
0488   01A8 B7 CB 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0489   01AB 4D            mov si, a                           ; source is proc state block
0490   01AC 48            mov a, sp
0491   01AD 5F 13 00      sub a, 19
0492   01B0 4F            mov di, a                           ; destination is kernel stack
0493   01B1             ; restore SP
0494   01B1 7D            dec a
0495   01B2 47            mov sp, a
0496   01B3 38 14 00      mov c, 20
0497   01B6 FD F5         rep movsb
0498   01B8             ; set VM process
0499   01B8 1D 7C 17      mov al, [active_proc_index]
0500   01BB 01            setptb
0501   01BC 4C            popa
0502   01BD 06            sysret
0503   01BE             
0504   01BE             syscall_list_procs:
0505   01BE 3B A4 17      mov d, s_ps_header
0506   01C1 07 4B 12      call _puts
0507   01C4 3B 33 1C      mov d, proc_availab_table + 1
0508   01C7 38 01 00      mov c, 1
0509   01CA             list_procs_L0:  
0510   01CA BD 01         cmp byte[d], 1
0511   01CC C7 F0 01      jne list_procs_next
0512   01CF 2D            mov b, d
0513   01D0 61 32 1C      sub b, proc_availab_table
0514   01D3 FD 9F 05      shl b, 5
0515   01D6 DA            push d
0516   01D7 D8            push b
0517   01D8 28            mov b, c
0518   01D9 07 EB 12      call print_u8x
0519   01DC 22 20         mov ah, ' '
0520   01DE 07 1F 11      call _putchar
0521   01E1 07 1F 11      call _putchar
0522   01E4 E5            pop b
0523   01E5 74            mov d, b
0524   01E6 58 42 1C      add d, proc_names
0525   01E9 07 4B 12      call _puts
0526   01EC 07 F8 11      call printnl
0527   01EF E7            pop d
0528   01F0             list_procs_next:
0529   01F0 79            inc d
0530   01F1 78            inc c
0531   01F2 C2 09 00      cmp c, 9
0532   01F5 C7 CA 01      jne list_procs_L0
0533   01F8             list_procs_end:
0534   01F8 06            sysret
0535   01F9             
0536   01F9             ; ------------------------------------------------------------------------------------------------------------------;
0537   01F9             ; Exceptions' Code Block
0538   01F9             ; ------------------------------------------------------------------------------------------------------------------;
0539   01F9             ; Privilege
0540   01F9             ; ------------------------------------------------------------------------------------------------------------------;
0541   01F9             trap_privilege:
0542   01F9 0A 7A 01      jmp syscall_reboot
0543   01FC DA            push d
0544   01FD 3B F3 17      mov d, s_priviledge
0545   0200 07 4B 12      call _puts
0546   0203 E7            pop d
0547   0204 06            sysret
0548   0205             
0549   0205             ; ------------------------------------------------------------------------------------------------------------------;
0550   0205             ; Breakpoint
0551   0205             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0552   0205             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0553   0205             ; ------------------------------------------------------------------------------------------------------------------;
0554   0205             syscall_break:
0555   0205 4B            pusha
0556   0206             syscall_break_prompt:
0557   0206 3B C0 02      mov d, s_break1
0558   0209 07 4B 12      call _puts
0559   020C 07 F8 11      call printnl
0560   020F 07 4D 13      call scan_u16d
0561   0212 AF 00 00      cmp a, 0
0562   0215 C6 20 02      je syscall_break_regs
0563   0218 AF 01 00      cmp a, 1
0564   021B C6 43 02      je syscall_break_mem
0565   021E             syscall_break_end:  
0566   021E 4C            popa
0567   021F 06            sysret
0568   0220             syscall_break_regs:
0569   0220 48            mov a, sp
0570   0221 53 0E 00      add a, 14               ; back-track 7 registers
0571   0224 3C            mov d, a
0572   0225 3A 07         mov cl, 7
0573   0227             syscall_regs_L0:
0574   0227 2A            mov b, [d]
0575   0228 FD AB         swp b
0576   022A 07 A7 12      call print_u16x         ; print register value
0577   022D 07 F8 11      call printnl
0578   0230 63 02 00      sub d, 2
0579   0233 71 01         sub cl, 1
0580   0235 C3 00         cmp cl, 0
0581   0237 C7 27 02      jne syscall_regs_L0
0582   023A 0A 06 02      jmp syscall_break_prompt
0583   023D 07 F8 11      call printnl
0584   0240 0A 06 02      jmp syscall_break_prompt
0585   0243             syscall_break_mem:
0586   0243 07 F8 11      call printnl
0587   0246 07 C9 12      call scan_u16x
0588   0249 4D            mov si, a               ; data source from user space
0589   024A FD 4F C2 24   mov di, scrap_sector    ; destination in kernel space
0590   024E 38 00 02      mov c, 512
0591   0251 04            load                    ; transfer data to kernel space!
0592   0252 3B C2 24      mov d, scrap_sector     ; dump pointer in d
0593   0255 38 00 00      mov c, 0
0594   0258             dump_loop:
0595   0258 84            mov al, cl
0596   0259 87 0F         and al, $0F
0597   025B C6 A9 02      jz print_base
0598   025E             back:
0599   025E 1E            mov al, [d]             ; read byte
0600   025F 2F            mov bl, al
0601   0260 07 EB 12      call print_u8x
0602   0263 10 00 20      mov a, $2000
0603   0266 05 03         syscall sys_io          ; space
0604   0268 84            mov al, cl
0605   0269 87 0F         and al, $0F
0606   026B B9 0F         cmp al, $0F
0607   026D C6 7E 02      je print_ascii
0608   0270             back1:
0609   0270 79            inc d
0610   0271 78            inc c
0611   0272 C2 00 02      cmp c, 512
0612   0275 C7 58 02      jne dump_loop
0613   0278 07 F8 11      call printnl
0614   027B 0A 06 02      jmp syscall_break_prompt  ; go to syscall_break return point
0615   027E             print_ascii:
0616   027E 10 00 20      mov a, $2000
0617   0281 05 03         syscall sys_io
0618   0283 63 10 00      sub d, 16
0619   0286 26 10 00      mov b, 16
0620   0289             print_ascii_L:
0621   0289 79            inc d
0622   028A 1E            mov al, [d]               ; read byte
0623   028B B9 20         cmp al, $20
0624   028D C8 95 02      jlu dot
0625   0290 B9 7E         cmp al, $7E
0626   0292 D0 9D 02      jleu ascii
0627   0295             dot:
0628   0295 10 00 2E      mov a, $2E00
0629   0298 05 03         syscall sys_io
0630   029A 0A A2 02      jmp ascii_continue
0631   029D             ascii:
0632   029D 23            mov ah, al
0633   029E 19 00         mov al, 0
0634   02A0 05 03         syscall sys_io
0635   02A2             ascii_continue:
0636   02A2 FD A9 89 02   loopb print_ascii_L
0637   02A6 0A 70 02      jmp back1
0638   02A9             print_base:
0639   02A9 07 F8 11      call printnl
0640   02AC 2D            mov b, d
0641   02AD 61 C2 24      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0642   02B0 07 A7 12      call print_u16x          ; display row
0643   02B3 10 00 3A      mov a, $3A00
0644   02B6 05 03         syscall sys_io
0645   02B8 10 00 20      mov a, $2000
0646   02BB 05 03         syscall sys_io
0647   02BD 0A 5E 02      jmp back
0648   02C0             
0649   02C0             s_break1:  
0650   02C0 0A 44 65 62   .db "\nDebugger entry point.\n"
0650   02C4 75 67 67 65 
0650   02C8 72 20 65 6E 
0650   02CC 74 72 79 20 
0650   02D0 70 6F 69 6E 
0650   02D4 74 2E 0A 
0651   02D7 30 2E 20 53   .db "0. Show Registers\n"
0651   02DB 68 6F 77 20 
0651   02DF 52 65 67 69 
0651   02E3 73 74 65 72 
0651   02E7 73 0A 
0652   02E9 31 2E 20 53   .db "1. Show 512B RAM block\n"
0652   02ED 68 6F 77 20 
0652   02F1 35 31 32 42 
0652   02F5 20 52 41 4D 
0652   02F9 20 62 6C 6F 
0652   02FD 63 6B 0A 
0653   0300 32 2E 20 43   .db "2. Continue Execution", 0
0653   0304 6F 6E 74 69 
0653   0308 6E 75 65 20 
0653   030C 45 78 65 63 
0653   0310 75 74 69 6F 
0653   0314 6E 00 
0654   0316             
0655   0316             ; ------------------------------------------------------------------------------------------------------------------;
0656   0316             ; Divide by Zero
0657   0316             ; ------------------------------------------------------------------------------------------------------------------;
0658   0316             trap_div_zero:
0659   0316 D7            push a
0660   0317 DA            push d
0661   0318 E1            pushf
0662   0319 3B 0A 18      mov d, s_divzero
0663   031C 07 4B 12      call _puts
0664   031F EE            popf
0665   0320 E7            pop d
0666   0321 E4            pop a
0667   0322 06            sysret ; enable interrupts
0668   0323             
0669   0323             ; ------------------------------------------------------------------------------------------------------------------;
0670   0323             ; Undefined Opcode
0671   0323             ; ------------------------------------------------------------------------------------------------------------------;
0672   0323             trap_undef_opcode:
0673   0323 06            sysret
0674   0324             
0675   0324             ; ------------------------------------------------------------------------------------------------------------------;
0676   0324             ; RTC Services Syscall
0677   0324             ; RTC I/O bank = FFA0 to FFAF
0678   0324             ; FFA0 to FFA7 is scratch RAM
0679   0324             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0680   0324             ; al = 0..6 -> get
0681   0324             ; al = 7..D -> set
0682   0324             ; ------------------------------------------------------------------------------------------------------------------;
0683   0324             syscall_rtc:
0684   0324 DB            push al
0685   0325 DA            push d
0686   0326 B9 06         cmp al, 6
0687   0328 D1 3D 03      jgu syscall_rtc_set
0688   032B             syscall_rtc_get:
0689   032B 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0690   032D 22 FF         mov ah, $FF    
0691   032F 3C            mov d, a                ; get to FFA9 + offset
0692   0330 F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0693   0334 1E            mov al, [d]             ; get data
0694   0335 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0695   0339 23            mov ah, al
0696   033A E7            pop d
0697   033B E8            pop al
0698   033C 06            sysret
0699   033D             syscall_rtc_set:
0700   033D DD            push bl
0701   033E 99            mov bl, ah              ; set data asIDE
0702   033F 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0703   0341 22 FF         mov ah, $FF    
0704   0343 3C            mov d, a                ; get to FFA9 + offset
0705   0344 1B            mov al, bl              ; get data back
0706   0345 F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0707   0349 3E            mov [d], al             ; set data
0708   034A F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0709   034E EA            pop bl
0710   034F E7            pop d
0711   0350 E8            pop al
0712   0351 06            sysret
0713   0352             
0714   0352             datetime_serv_tbl:
0715   0352 5A 03         .dw print_date
0716   0354 CE 03         .dw set_date
0717   0356             syscall_datetime:
0718   0356 FD 0A 52 03   jmp [datetime_serv_tbl + al]      
0719   035A             print_date:
0720   035A 10 00 0D      mov a, $0D00           ; print carriage return char
0721   035D 19 03         mov al, 3
0722   035F 05 01         syscall sys_rtc        ; get week
0723   0361 1A            mov al, ah
0724   0362 22 00         mov ah, 0
0725   0364 FD 9D 02      shl a, 2          
0726   0367 3B 94 18      mov d, s_week
0727   036A 59            add d, a
0728   036B 07 4B 12      call _puts
0729   036E 10 00 20      mov a, $2000
0730   0371 05 03         syscall sys_io         ; display ' '
0731   0373 19 04         mov al, 4
0732   0375 05 01         syscall sys_rtc        ; get day
0733   0377 99            mov bl, ah
0734   0378 07 EB 12      call print_u8x
0735   037B 10 00 20      mov a, $2000
0736   037E 05 03         syscall sys_io         ; display ' '
0737   0380             ; there is a problem with the month displaying
0738   0380             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0739   0380             ; even though it is to be understood as BCD.
0740   0380             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0741   0380 19 05         mov al, 05
0742   0382 05 01         syscall sys_rtc        ; get month
0743   0384 1A            mov al, ah
0744   0385 22 00         mov ah, 0
0745   0387 FD 9D 02      shl a, 2          
0746   038A 3B 60 18      mov d, s_months
0747   038D 59            add d, a
0748   038E 07 4B 12      call _puts
0749   0391 10 00 20      mov a, $2000
0750   0394 05 03         syscall sys_io         ; display ' '
0751   0396 2E 20         mov bl, $20
0752   0398 07 EB 12      call print_u8x         ; print 20 for year prefix
0753   039B 19 06         mov al, 06
0754   039D 05 01         syscall sys_rtc        ; get year
0755   039F 99            mov bl, ah
0756   03A0 07 EB 12      call print_u8x
0757   03A3 10 00 20      mov a, $2000  
0758   03A6 05 03         syscall sys_io         ; display ' '
0759   03A8 19 02         mov al, 2
0760   03AA 05 01         syscall sys_rtc        ; get hours
0761   03AC 99            mov bl, ah
0762   03AD 07 EB 12      call print_u8x
0763   03B0 10 00 3A      mov a, $3A00    
0764   03B3 05 03         syscall sys_io         ; display ':'
0765   03B5 19 01         mov al, 01
0766   03B7 05 01         syscall sys_rtc        ; get minutes
0767   03B9 99            mov bl, ah
0768   03BA 07 EB 12      call print_u8x
0769   03BD 10 00 3A      mov a, $3A00  
0770   03C0 05 03         syscall sys_io         ; display ':'
0771   03C2 19 00         mov al, 0
0772   03C4 05 01         syscall sys_rtc        ; get seconds
0773   03C6 99            mov bl, ah
0774   03C7 07 EB 12      call print_u8x
0775   03CA 07 F8 11      call printnl
0776   03CD 06            sysret
0777   03CE             set_date:
0778   03CE 3B 25 18      mov d, s_set_year
0779   03D1 07 4B 12      call _puts
0780   03D4 07 36 13      call scan_u8x          ; read integer into A
0781   03D7 FD 9D 08      shl a, 8               ; only AL used, move to AH
0782   03DA 19 0D         mov al, 0Dh            ; set RTC year
0783   03DC 05 01         syscall sys_rtc        ; set RTC
0784   03DE 3B 2C 18      mov d, s_set_month
0785   03E1 07 4B 12      call _puts
0786   03E4 07 36 13      call scan_u8x          ; read integer into A
0787   03E7 FD 9D 08      shl a, 8               ; only AL used, move to AH
0788   03EA 19 0C         mov al, 0Ch            ; set RTC month
0789   03EC 05 01         syscall sys_rtc        ; set RTC
0790   03EE 3B 34 18      mov d, s_set_day
0791   03F1 07 4B 12      call _puts
0792   03F4 07 36 13      call scan_u8x          ; read integer into A
0793   03F7 FD 9D 08      shl a, 8               ; only AL used, move to AH
0794   03FA 19 0B         mov al, 0Bh            ; set RTC month
0795   03FC 05 01         syscall sys_rtc        ; set RTC
0796   03FE 3B 3A 18      mov d, s_set_week
0797   0401 07 4B 12      call _puts
0798   0404 07 36 13      call scan_u8x          ; read integer into A
0799   0407 FD 9D 08      shl a, 8               ; only AL used, move to AH
0800   040A 19 0A         mov al, 0Ah            ; set RTC month
0801   040C 05 01         syscall sys_rtc        ; set RTC
0802   040E 3B 44 18      mov d, s_set_hours
0803   0411 07 4B 12      call _puts
0804   0414 07 36 13      call scan_u8x          ; read integer into A
0805   0417 FD 9D 08      shl a, 8               ; only AL used, move to AH
0806   041A 19 09         mov al, 09h            ; set RTC month
0807   041C 05 01         syscall sys_rtc        ; set RTC
0808   041E 3B 4C 18      mov d, s_set_minutes
0809   0421 07 4B 12      call _puts
0810   0424 07 36 13      call scan_u8x          ; read integer into A
0811   0427 FD 9D 08      shl a, 8               ; only AL used, move to AH
0812   042A 19 08         mov al, 08h            ; set RTC month
0813   042C 05 01         syscall sys_rtc        ; set RTC
0814   042E 3B 56 18      mov d, s_set_seconds
0815   0431 07 4B 12      call _puts
0816   0434 07 36 13      call scan_u8x          ; read integer into A
0817   0437 FD 9D 08      shl a, 8               ; only AL used, move to AH
0818   043A 19 07         mov al, 07h            ; set RTC month
0819   043C 05 01         syscall sys_rtc        ; set RTC
0820   043E 06            sysret
0821   043F             
0822   043F             ; ------------------------------------------------------------------------------------------------------------------;
0823   043F             ; IDE Services Syscall
0824   043F             ; al = option
0825   043F             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0826   043F             ; IDE read/write sector
0827   043F             ; 512 bytes
0828   043F             ; User buffer pointer in D
0829   043F             ; AH = number of sectors
0830   043F             ; CB = LBA bytes 3..0
0831   043F             ; ------------------------------------------------------------------------------------------------------------------;
0832   043F 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0832   0443 73 63 61 6C 
0832   0447 6C 5F 69 64 
0832   044B 65 20 63 61 
0832   044F 6C 6C 65 64 
0832   0453 3A 20 00 
0833   0456             ide_serv_tbl:
0834   0456 7D 04         .dw ide_reset
0835   0458 91 04         .dw ide_sleep
0836   045A A0 04         .dw ide_read_sect_wrapper
0837   045C A4 04         .dw ide_write_sect_wrapper
0838   045E             syscall_ide:
0839   045E DD            push bl
0840   045F 31 74 17      mov bl, [sys_debug_mode]
0841   0462               ; debug block
0842   0462 C1 00         cmp bl, 0
0843   0464 EA            pop bl
0844   0465 C6 79 04      je syscall_ide_jmp
0845   0468 DA            push d
0846   0469 DD            push bl
0847   046A 3B 3F 04      mov d, s_syscall_ide_dbg0
0848   046D 07 4B 12      call _puts
0849   0470 2F            mov bl, al
0850   0471 07 EB 12      call print_u8x
0851   0474 07 F8 11      call printnl
0852   0477 EA            pop bl
0853   0478 E7            pop d
0854   0479             syscall_ide_jmp:
0855   0479 FD 0A 56 04   jmp [ide_serv_tbl + al]    
0856   047D               
0857   047D             ide_reset:      
0858   047D F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0859   0481 07 2A 05      call ide_wait                   ; wait for IDE ready             
0860   0484 F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0861   0488 F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0862   048C F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0863   0490 06            sysret
0864   0491             ide_sleep:
0865   0491 07 2A 05      call ide_wait                   ; wait for IDE ready             
0866   0494 F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0867   0498 F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0868   049C 07 2A 05      call ide_wait                   ; wait for IDE ready
0869   049F 06            sysret
0870   04A0             ide_read_sect_wrapper:
0871   04A0 07 A8 04      call ide_read_sect
0872   04A3 06            sysret
0873   04A4             ide_write_sect_wrapper:
0874   04A4 07 CE 04      call ide_write_sect
0875   04A7 06            sysret
0876   04A8             ide_read_sect:
0877   04A8 1A            mov al, ah
0878   04A9 24            mov ah, bl
0879   04AA 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0880   04AD 1C            mov al, bh
0881   04AE 3D D4 FF      mov [_ide_R4], al
0882   04B1 12            mov a, c
0883   04B2 3D D5 FF      mov [_ide_R5], al
0884   04B5 1A            mov al, ah
0885   04B6 87 0F         and al, %00001111
0886   04B8 8B E0         or al, %11100000                ; mode lba, master
0887   04BA 3D D6 FF      mov [_ide_R6], al
0888   04BD             ide_read_sect_wait:
0889   04BD 1D D7 FF      mov al, [_ide_R7]  
0890   04C0 87 80         and al, $80                     ; BUSY FLAG
0891   04C2 C7 BD 04      jnz ide_read_sect_wait
0892   04C5 19 20         mov al, $20
0893   04C7 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0894   04CA 07 F4 04      call ide_read  
0895   04CD 09            ret
0896   04CE             ide_write_sect:
0897   04CE 1A            mov al, ah
0898   04CF 24            mov ah, bl
0899   04D0 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0900   04D3 1C            mov al, bh
0901   04D4 3D D4 FF      mov [_ide_R4], al
0902   04D7 12            mov a, c
0903   04D8 3D D5 FF      mov [_ide_R5], al
0904   04DB 1A            mov al, ah
0905   04DC 87 0F         and al, %00001111
0906   04DE 8B E0         or al, %11100000                ; mode lba, master
0907   04E0 3D D6 FF      mov [_ide_R6], al
0908   04E3             ide_write_sect_wait:
0909   04E3 1D D7 FF      mov al, [_ide_R7]  
0910   04E6 87 80         and al, $80                     ; BUSY FLAG
0911   04E8 C7 E3 04      jnz ide_write_sect_wait
0912   04EB 19 30         mov al, $30
0913   04ED 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0914   04F0 07 0F 05      call ide_write      
0915   04F3 09            ret
0916   04F4             
0917   04F4             ;----------------------------------------------------------------------------------------------------;
0918   04F4             ; READ IDE DATA
0919   04F4             ; pointer in D
0920   04F4             ;----------------------------------------------------------------------------------------------------;
0921   04F4             ide_read:
0922   04F4 DA            push d
0923   04F5             ide_read_loop:
0924   04F5 1D D7 FF      mov al, [_ide_R7]  
0925   04F8 87 80         and al, 80h                     ; BUSY FLAG
0926   04FA C7 F5 04      jnz ide_read_loop               ; wait loop
0927   04FD 1D D7 FF      mov al, [_ide_R7]
0928   0500 87 08         and al, %00001000               ; DRQ FLAG
0929   0502 C6 0D 05      jz ide_read_end
0930   0505 1D D0 FF      mov al, [_ide_R0]
0931   0508 3E            mov [d], al
0932   0509 79            inc d
0933   050A 0A F5 04      jmp ide_read_loop
0934   050D             ide_read_end:
0935   050D E7            pop d
0936   050E 09            ret
0937   050F             
0938   050F             ;----------------------------------------------------------------------------------------------------;
0939   050F             ; WRITE IDE DATA
0940   050F             ; data pointer in D
0941   050F             ;----------------------------------------------------------------------------------------------------;
0942   050F             ide_write:
0943   050F DA            push d
0944   0510             ide_write_loop:
0945   0510 1D D7 FF      mov al, [_ide_R7]  
0946   0513 87 80         and al, 80h             ; BUSY FLAG
0947   0515 C7 10 05      jnz ide_write_loop      ; wait loop
0948   0518 1D D7 FF      mov al, [_ide_R7]
0949   051B 87 08         and al, %00001000       ; DRQ FLAG
0950   051D C6 28 05      jz ide_write_end
0951   0520 1E            mov al, [d]
0952   0521 3D D0 FF      mov [_ide_R0], al
0953   0524 79            inc d 
0954   0525 0A 10 05      jmp ide_write_loop
0955   0528             ide_write_end:
0956   0528 E7            pop d
0957   0529 09            ret
0958   052A             
0959   052A             ;----------------------------------------------------------------------------------------------------;
0960   052A             ; wait for IDE to be ready
0961   052A             ;----------------------------------------------------------------------------------------------------;
0962   052A             ide_wait:
0963   052A 1D D7 FF      mov al, [_ide_R7]  
0964   052D 87 80         and al, 80h        ; BUSY FLAG
0965   052F C7 2A 05      jnz ide_wait
0966   0532 09            ret
0967   0533             
0968   0533             ;----------------------------------------------------------------------------------------------------;
0969   0533             ; IO Syscall
0970   0533             ;----------------------------------------------------------------------------------------------------;
0971   0533             ; Baud  Divisor
0972   0533             ; 50    2304
0973   0533             ; 110   1047
0974   0533             ; 300    384
0975   0533             ; 600    192
0976   0533             ; 1200    96
0977   0533             ; 9600    12
0978   0533             ; 19200    6
0979   0533             ; 38400    3
0980   0533             syscall_io_jmp:
0981   0533 66 05         .dw syscall_io_putchar
0982   0535 73 05         .dw syscall_io_getch
0983   0537 3D 05         .dw syscall_io_uart_setup
0984   0539             syscall_io:
0985   0539 FD 0A 33 05   jmp [syscall_io_jmp + al]
0986   053D             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0987   053D             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0988   053D             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0989   053D             syscall_io_uart_setup:
0990   053D 1D 76 17      mov al, [sys_uart0_lcr]
0991   0540 8B 80         or al, $80                ; set DLAB access bit
0992   0542 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0993   0545 1D 79 17      mov al, [sys_uart0_div0]
0994   0548 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0995   054B 1D 7A 17      mov al, [sys_uart0_div1]
0996   054E 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0997   0551             
0998   0551 1D 76 17      mov al, [sys_uart0_lcr]
0999   0554 87 7F         and al, $7F               ; clear DLAB access bit 
1000   0556 3D 83 FF      mov [_UART0_LCR], al
1001   0559 1D 77 17      mov al, [sys_uart0_inten]
1002   055C 3D 81 FF      mov [_UART0_IER], al      ; interrupts
1003   055F 1D 78 17      mov al, [sys_uart0_fifoen]
1004   0562 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
1005   0565 06            sysret
1006   0566             
1007   0566             ; char in ah
1008   0566             syscall_io_putchar:
1009   0566             syscall_io_putchar_L0:
1010   0566 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1011   0569 87 20         and al, $20
1012   056B C6 66 05      jz syscall_io_putchar_L0    
1013   056E 1A            mov al, ah
1014   056F 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1015   0572 06            sysret
1016   0573             
1017   0573             ; char in ah
1018   0573             ; al = sucess code
1019   0573             syscall_io_getch:
1020   0573 D8            push b
1021   0574 DA            push d
1022   0575 FD 0C         sti
1023   0577             syscall_io_getch_L0:  
1024   0577 14 83 17      mov a, [fifo_out]
1025   057A 29 81 17      mov b, [fifo_in]
1026   057D B0            cmp a, b
1027   057E C6 77 05      je syscall_io_getch_L0
1028   0581 3C            mov d, a
1029   0582 77            inc a
1030   0583 AF C2 24      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
1031   0586 C7 8C 05      jne syscall_io_getch_cont
1032   0589 10 C2 20      mov a, fifo  
1033   058C             syscall_io_getch_cont:  
1034   058C 42 83 17      mov [fifo_out], a             ; update fifo pointer
1035   058F 1E            mov al, [d]                   ; get char
1036   0590 23            mov ah, al
1037   0591 1D 75 17      mov al, [sys_echo_on]
1038   0594 B9 01         cmp al, 1
1039   0596 C7 A5 05      jne syscall_io_getch_noecho 
1040   0599             ; here we just echo the char back to the console
1041   0599             syscall_io_getch_echo_L0:
1042   0599 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1043   059C 87 20         and al, $20                 ; isolate Transmitter Empty
1044   059E C6 99 05      jz syscall_io_getch_echo_L0
1045   05A1 1A            mov al, ah
1046   05A2 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1047   05A5             syscall_io_getch_noecho:
1048   05A5 19 01         mov al, 1                    ; AL = 1 means a char successfully received
1049   05A7 E7            pop d
1050   05A8 E5            pop b
1051   05A9 06            sysret
1052   05AA             
1053   05AA             ;------------------------------------------------------------------------------------------------------;
1054   05AA             ; FILE SYSTEM DATA
1055   05AA             ;------------------------------------------------------------------------------------------------------;
1056   05AA             ; infor for : IDE SERVICES INTERRUPT
1057   05AA             ; IDE read/write 512-byte sector
1058   05AA             ; al = option
1059   05AA             ; user buffer pointer in D
1060   05AA             ; AH = number of sectors
1061   05AA             ; CB = LBA bytes 3..0  
1062   05AA             ;------------------------------------------------------------------------------------------------------;
1063   05AA             ; FILE SYSTEM DATA STRUCTURE
1064   05AA             ;------------------------------------------------------------------------------------------------------;
1065   05AA             ; for a directory we have the header first, followed by metadata
1066   05AA             ; header 1 sector (512 bytes)
1067   05AA             ; metadata 1 sector (512 bytes)
1068   05AA             ; HEADER ENTRIES:
1069   05AA             ; filename (64)
1070   05AA             ; parent dir LBA (2) -  to be used for faster backwards navigation...
1071   05AA             ;
1072   05AA             ; metadata entries:
1073   05AA             ; filename (24)
1074   05AA             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1075   05AA             ; LBA (2)
1076   05AA             ; size (2)
1077   05AA             ; day (1)
1078   05AA             ; month (1)
1079   05AA             ; year (1)
1080   05AA             ; packet size = 32 bytes
1081   05AA             ;
1082   05AA             ; first directory on disk is the root directory '/'
1083   05AA             file_system_jmptbl:
1084   05AA 15 06         .dw fs_mkfs                   ; 0
1085   05AC 00 00         .dw 0                         ; 1
1086   05AE 77 06         .dw fs_mkdir                  ; 2
1087   05B0 F0 09         .dw fs_cd                     ; 3
1088   05B2 F7 09         .dw fs_ls                     ; 4
1089   05B4 6D 0B         .dw fs_mktxt                  ; 5
1090   05B6 38 0C         .dw fs_mkbin                  ; 6
1091   05B8 FF 0C         .dw fs_pwd                    ; 7
1092   05BA 1C 0D         .dw fs_cat                    ; 8
1093   05BC 78 0D         .dw fs_rmdir                  ; 9
1094   05BE D4 0D         .dw fs_rm                     ; 10
1095   05C0 C8 0A         .dw fs_starcom                ; 11
1096   05C2 00 00         .dw 0                         ; 12
1097   05C4 00 00         .dw 0                         ; 13
1098   05C6 1D 06         .dw fs_chmod                  ; 14
1099   05C8 3C 0E         .dw fs_mv                     ; 15
1100   05CA 16 06         .dw fs_cd_root                ; 16
1101   05CC EC 09         .dw fs_get_curr_dirID         ; 17
1102   05CE C8 07         .dw fs_dir_id_to_path         ; 18
1103   05D0 2E 08         .dw fs_path_to_dir_id_user    ; 19
1104   05D2 48 09         .dw fs_load_from_path_user    ; 20  
1105   05D4 B8 08         .dw fs_filepath_exists_user   ; 21
1106   05D6             
1107   05D6 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1107   05DA 79 73 63 61 
1107   05DE 6C 6C 5F 66 
1107   05E2 69 6C 65 5F 
1107   05E6 73 79 73 74 
1107   05EA 65 6D 20 63 
1107   05EE 61 6C 6C 65 
1107   05F2 64 3A 20 00 
1108   05F6             syscall_file_system:
1109   05F6 DD            push bl
1110   05F7 31 74 17      mov bl, [sys_debug_mode]
1111   05FA               ; debug block
1112   05FA C1 00         cmp bl, 0
1113   05FC EA            pop bl
1114   05FD C6 11 06      je syscall_filesystem_jmp
1115   0600 DA            push d
1116   0601 DD            push bl
1117   0602 3B D6 05      mov d, s_syscall_fs_dbg0
1118   0605 07 4B 12      call _puts
1119   0608 2F            mov bl, al
1120   0609 07 EB 12      call print_u8x
1121   060C 07 F8 11      call printnl
1122   060F EA            pop bl
1123   0610 E7            pop d
1124   0611             syscall_filesystem_jmp:
1125   0611 FD 0A AA 05   jmp [file_system_jmptbl + al]
1126   0615             
1127   0615             fs_mkfs:  
1128   0615 06            sysret  
1129   0616               
1130   0616             fs_cd_root:
1131   0616 10 20 00      mov a, root_id
1132   0619 42 85 17      mov [current_dir_id], a      ; set current directory LBA to ROOT
1133   061C 06            sysret  
1134   061D             
1135   061D             ; filename in D (userspace data)
1136   061D             ; permission in BL
1137   061D             fs_chmod:
1138   061D DD            push bl
1139   061E FD 4E         mov si, d
1140   0620 FD 4F C2 1E   mov di, user_data
1141   0624 38 80 00      mov c, 128
1142   0627 04            load                        ; load filename from user-space
1143   0628 14 85 17      mov a, [current_dir_id]
1144   062B 77            inc a                       ; metadata sector
1145   062C 27            mov b, a
1146   062D 38 00 00      mov c, 0                    ; upper LBA = 0
1147   0630 22 01         mov ah, $01                  ; 1 sector
1148   0632 3B C2 26      mov d, transient_area
1149   0635 07 A8 04      call ide_read_sect          ; read directory
1150   0638 FD 10         cla
1151   063A 42 7D 17      mov [index], a              ; reset file counter
1152   063D             fs_chmod_L1:
1153   063D FD 4E         mov si, d
1154   063F FD 4F C2 1E   mov di, user_data
1155   0643 07 8E 10      call _strcmp
1156   0646 C6 5D 06      je fs_chmod_found_entry
1157   0649 58 20 00      add d, 32
1158   064C 14 7D 17      mov a, [index]
1159   064F 77            inc a
1160   0650 42 7D 17      mov [index], a
1161   0653 AF 10 00      cmp a, FST_FILES_PER_DIR
1162   0656 C7 3D 06      jne fs_chmod_L1
1163   0659 EA            pop bl
1164   065A 0A 76 06      jmp fs_chmod_not_found
1165   065D             fs_chmod_found_entry:  
1166   065D FD 79         mov g, b                    ; save LBA
1167   065F EA            pop bl                      ; retrieve saved permission value
1168   0660 1F 18 00      mov al, [d + 24]            ; read file permissions
1169   0663 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1170   0665 8C            or al, bl                   ; set new permissions
1171   0666 3F 18 00      mov [d + 24], al            ; write new permissions
1172   0669 38 00 00      mov c, 0
1173   066C 3B C2 26      mov d, transient_area
1174   066F 22 01         mov ah, $01                 ; disk write 1 sect
1175   0671 FD 27         mov b, g                    ; retrieve LBA
1176   0673 07 CE 04      call ide_write_sect         ; write sector
1177   0676             fs_chmod_not_found:
1178   0676 06            sysret
1179   0677             
1180   0677             ;------------------------------------------------------------------------------------------------------;
1181   0677             ; CREATE NEW DIRECTORY
1182   0677             ;------------------------------------------------------------------------------------------------------;
1183   0677             ; search list for NULL name entry. add new directory to list
1184   0677             fs_mkdir:
1185   0677 FD 4E         mov si, d
1186   0679 FD 4F C2 1E   mov di, user_data
1187   067D 38 00 02      mov c, 512
1188   0680 04            load                        ; load data from user-space
1189   0681 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1190   0684                                           ; when checking for NULL name, since root has a NULL name)
1191   0684 38 00 00      mov c, 0                    ; upper LBA = 0
1192   0687             fs_mkdir_L1:  
1193   0687 22 01         mov ah, $01                  ; 1 sector
1194   0689 3B C2 26      mov d, transient_area
1195   068C 07 A8 04      call ide_read_sect          ; read sector
1196   068F BD 00         cmp byte[d], 0              ; check for NULL
1197   0691 C6 9A 06      je fs_mkdir_found_null
1198   0694 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1199   0697 0A 87 06      jmp fs_mkdir_L1
1200   069A             fs_mkdir_found_null:
1201   069A             ;create header file by grabbing dir name from parameter
1202   069A D8            push b                      ; save new directory's LBA
1203   069B 38 40 00      mov c, 64
1204   069E FD 4D C2 1E   mov si, user_data
1205   06A2 FD 4F C2 26   mov di, transient_area
1206   06A6 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1207   06A8 14 85 17      mov a, [current_dir_id]
1208   06AB 42 02 27      mov [transient_area + 64], a    ; store parent directory LBA
1209   06AE 19 00         mov al, 0
1210   06B0 FD 4F C2 28   mov di, transient_area + 512
1211   06B4 38 00 02      mov c, 512
1212   06B7 FD F7         rep stosb                       ; clean buffer
1213   06B9 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1214   06BC             ; write directory entry sectors
1215   06BC 3B C2 26      mov d, transient_area
1216   06BF 22 02         mov ah, $02                     ; disk write, 2 sectors
1217   06C1 07 CE 04      call ide_write_sect             ; write sector
1218   06C4             ; now we need to add the new directory to the list, insIDE the current directory
1219   06C4 14 85 17      mov a, [current_dir_id]
1220   06C7 53 01 00      add a, 1
1221   06CA 27            mov b, a                        ; metadata sector
1222   06CB 38 00 00      mov c, 0
1223   06CE FD 79         mov g, b                        ; save LBA
1224   06D0 3B C2 26      mov d, transient_area
1225   06D3 22 01         mov ah, $01                  ; 1 sector
1226   06D5 07 A8 04      call ide_read_sect              ; read metadata sector
1227   06D8             fs_mkdir_L2:
1228   06D8 BD 00         cmp byte[d], 0
1229   06DA C6 E3 06      je fs_mkdir_found_null2
1230   06DD 58 20 00      add d, FST_ENTRY_SIZE
1231   06E0 0A D8 06      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1232   06E3             fs_mkdir_found_null2:
1233   06E3 FD 4D C2 1E   mov si, user_data
1234   06E7 FD 50         mov di, d
1235   06E9 07 A3 10      call _strcpy                    ; copy directory name
1236   06EC 58 18 00      add d, 24                       ; goto ATTRIBUTES
1237   06EF 19 0B         mov al, %00001011               ; directory, no execute, write, read
1238   06F1 3E            mov [d], al      
1239   06F2 79            inc d
1240   06F3 E5            pop b
1241   06F4 D8            push b                          ; push LBA back
1242   06F5 FD 43         mov [d], b                      ; save LBA
1243   06F7             ; set file creation date  
1244   06F7 58 04 00      add d, 4
1245   06FA 19 04         mov al, 4
1246   06FC 05 01         syscall sys_rtc
1247   06FE 1A            mov al, ah
1248   06FF 3E            mov [d], al                     ; set day
1249   0700 79            inc d
1250   0701 19 05         mov al, 5
1251   0703 05 01         syscall sys_rtc
1252   0705 1A            mov al, ah
1253   0706 3E            mov [d], al                     ; set month
1254   0707 79            inc d
1255   0708 19 06         mov al, 6
1256   070A 05 01         syscall sys_rtc
1257   070C 1A            mov al, ah
1258   070D 3E            mov [d], al                     ; set year
1259   070E             ; write sector into disk for new directory entry
1260   070E FD 27         mov b, g
1261   0710 38 00 00      mov c, 0
1262   0713 3B C2 26      mov d, transient_area
1263   0716 22 01         mov ah, $01                     ; disk write, 1 sector
1264   0718 07 CE 04      call ide_write_sect             ; write sector
1265   071B             
1266   071B             ; after adding the new directory's information to its parent directory's list
1267   071B             ; we need to now enter the new directory, and to it add two new directories!
1268   071B             ; which directories do we need to add ? '..' and '.' are the directories needed.
1269   071B             ; importantly, note that these two new directories are only entries in the list
1270   071B             ; and do not have actual physical entries in the disk as real directories.
1271   071B             ; i.e. they only exist as list entries in the new directory created so that
1272   071B             ; the new directory can reference its parent and itself.
1273   071B             ; We need to add both '..' and '.'
1274   071B             ; this first section is for '..' and on the section below we do the same for '.'
1275   071B E4            pop a                         ; retrieve the new directory's LBA  
1276   071C D7            push a                        ; and save again
1277   071D 53 01 00      add a, 1
1278   0720 27            mov b, a                      ; metadata sector
1279   0721 38 00 00      mov c, 0
1280   0724 FD 79         mov g, b                      ; save LBA
1281   0726 3B C2 26      mov d, transient_area
1282   0729 22 01         mov ah, $01                  ; 1 sector
1283   072B 07 A8 04      call ide_read_sect            ; read metadata sector
1284   072E             fs_mkdir_L3:
1285   072E BD 00         cmp byte[d], 0
1286   0730 C6 39 07      je fs_mkdir_found_null3
1287   0733 58 20 00      add d, FST_ENTRY_SIZE
1288   0736 0A 2E 07      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1289   0739             fs_mkdir_found_null3:
1290   0739 FD 4D 95 17   mov si, s_parent_dir
1291   073D FD 50         mov di, d
1292   073F 07 A3 10      call _strcpy                  ; copy directory name
1293   0742 58 18 00      add d, 24                     ; goto ATTRIBUTES
1294   0745 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1295   0747 3E            mov [d], al      
1296   0748 79            inc d
1297   0749 29 85 17      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1298   074C FD 43         mov [d], b                    ; save LBA
1299   074E             ; set file creation date  
1300   074E 58 04 00      add d, 4
1301   0751 19 04         mov al, 4
1302   0753 05 01         syscall sys_rtc
1303   0755 1A            mov al, ah
1304   0756 3E            mov [d], al                   ; set day
1305   0757 79            inc d
1306   0758 19 05         mov al, 5
1307   075A 05 01         syscall sys_rtc
1308   075C 1A            mov al, ah
1309   075D 3E            mov [d], al                   ; set month
1310   075E 79            inc d
1311   075F 19 06         mov al, 6
1312   0761 05 01         syscall sys_rtc
1313   0763 1A            mov al, ah
1314   0764 3E            mov [d], al                   ; set year
1315   0765             ; write sector into disk for new directory entry
1316   0765 FD 27         mov b, g
1317   0767 38 00 00      mov c, 0
1318   076A 3B C2 26      mov d, transient_area
1319   076D 22 01         mov ah, $01                   ; disk write, 1 sector
1320   076F 07 CE 04      call ide_write_sect           ; write sector
1321   0772             ;;;;;;;;;;;;;
1322   0772             ; like we did above for '..', we need to now add the '.' directory to the list.
1323   0772             ;------------------------------------------------------------------------------------------------------;
1324   0772 E4            pop a                         ; retrieve the new directory's LBA  
1325   0773 D7            push a
1326   0774 53 01 00      add a, 1
1327   0777 27            mov b, a                      ; metadata sector
1328   0778 38 00 00      mov c, 0
1329   077B FD 79         mov g, b                      ; save LBA
1330   077D 3B C2 26      mov d, transient_area
1331   0780 22 01         mov ah, $01                  ; 1 sector
1332   0782 07 A8 04      call ide_read_sect            ; read metadata sector
1333   0785             fs_mkdir_L4:
1334   0785 BD 00         cmp byte[d], 0
1335   0787 C6 90 07      je fs_mkdir_found_null4
1336   078A 58 20 00      add d, FST_ENTRY_SIZE
1337   078D 0A 85 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1338   0790             fs_mkdir_found_null4:
1339   0790 FD 4D 98 17   mov si, s_current_dir
1340   0794 FD 50         mov di, d
1341   0796 07 A3 10      call _strcpy                  ; copy directory name
1342   0799 58 18 00      add d, 24                     ; goto ATTRIBUTES
1343   079C 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1344   079E 3E            mov [d], al      
1345   079F 79            inc d
1346   07A0 E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1347   07A1 FD 43         mov [d], b                    ; save LBA
1348   07A3             ; set file creation date  
1349   07A3 58 04 00      add d, 4
1350   07A6 19 04         mov al, 4
1351   07A8 05 01         syscall sys_rtc
1352   07AA 1A            mov al, ah
1353   07AB 3E            mov [d], al                   ; set day
1354   07AC 79            inc d
1355   07AD 19 05         mov al, 5
1356   07AF 05 01         syscall sys_rtc
1357   07B1 1A            mov al, ah
1358   07B2 3E            mov [d], al                   ; set month
1359   07B3 79            inc d
1360   07B4 19 06         mov al, 6
1361   07B6 05 01         syscall sys_rtc
1362   07B8 1A            mov al, ah
1363   07B9 3E            mov [d], al                   ; set year
1364   07BA             ; write sector into disk for new directory entry
1365   07BA FD 27         mov b, g
1366   07BC 38 00 00      mov c, 0
1367   07BF 3B C2 26      mov d, transient_area
1368   07C2 22 01         mov ah, $01                   ; disk write, 1 sector
1369   07C4 07 CE 04      call ide_write_sect           ; write sector
1370   07C7             fs_mkdir_end:
1371   07C7 06            sysret
1372   07C8             
1373   07C8             ;------------------------------------------------------------------------------------------------------;
1374   07C8             ; get path from a given directory dirID
1375   07C8             ; pseudo code:
1376   07C8             ;  fs_dir_id_to_path(int dirID, char *D){
1377   07C8             ;    if(dirID == 0){
1378   07C8             ;      reverse path in D;
1379   07C8             ;      return;
1380   07C8             ;    }
1381   07C8             ;    else{
1382   07C8             ;      copy directory name to end of D;
1383   07C8             ;      add '/' to end of D;
1384   07C8             ;      parentID = get parent directory ID;
1385   07C8             ;      fs_dir_id_to_path(parentID, D);
1386   07C8             ;    }
1387   07C8             ;  }
1388   07C8             ; A = dirID
1389   07C8             ; D = generated path string pointer
1390   07C8             ;------------------------------------------------------------------------------------------------------;
1391   07C8             ; sample path: /usr/bin
1392   07C8             fs_dir_id_to_path:
1393   07C8 3B 42 1E      mov d, filename
1394   07CB 19 00         mov al, 0
1395   07CD 3E            mov [d], al                     ; initialize path string 
1396   07CE 14 85 17      mov a, [current_dir_id]
1397   07D1 07 DE 07      call fs_dir_id_to_path_E0
1398   07D4 3B 42 1E      mov d, filename
1399   07D7 07 37 10      call _strrev
1400   07DA 07 4B 12      call _puts
1401   07DD 06            sysret
1402   07DE             fs_dir_id_to_path_E0:
1403   07DE 07 FD 07      call get_dirname_from_dirID
1404   07E1 FD 4D 9A 17   mov si, s_fslash
1405   07E5 FD 50         mov di, d
1406   07E7 07 B1 10      call _strcat                    ; add '/' to end of path
1407   07EA AF 20 00      cmp a, root_id               ; check if we are at the root directory
1408   07ED C6 FC 07      je fs_dir_id_to_path_root
1409   07F0 07 1A 08      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1410   07F3 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1411   07F6 C6 FC 07      je fs_dir_id_to_path_root
1412   07F9 07 DE 07      call fs_dir_id_to_path_E0     ; recursively call itself
1413   07FC             fs_dir_id_to_path_root:
1414   07FC 09            ret
1415   07FD             
1416   07FD             ;------------------------------------------------------------------------------------------------------;
1417   07FD             ; in_puts:
1418   07FD             ; A = directory ID
1419   07FD             ; out_puts:
1420   07FD             ; D = pointer to directory name string
1421   07FD             ;------------------------------------------------------------------------------------------------------;
1422   07FD             get_dirname_from_dirID:
1423   07FD D7            push a
1424   07FE D8            push b
1425   07FF DA            push d
1426   0800 27            mov b, a
1427   0801 38 00 00      mov c, 0                      ; upper LBA = 0
1428   0804 22 01         mov ah, $01                  ; 1 sector
1429   0806 3B C2 24      mov d, transient_area - 512
1430   0809 07 A8 04      call ide_read_sect            ; read directory
1431   080C 07 37 10      call _strrev                  ; reverse dir name before copying
1432   080F FD 4E         mov si, d
1433   0811 E7            pop d                         ; destination address = D value pushed at beginning
1434   0812 FD 50         mov di, d
1435   0814 07 B1 10      call _strcat                  ; copy filename to D
1436   0817 E5            pop b
1437   0818 E4            pop a
1438   0819 09            ret
1439   081A             
1440   081A             ;------------------------------------------------------------------------------------------------------;
1441   081A             ; in_puts:
1442   081A             ; A = directory ID
1443   081A             ; out_puts:
1444   081A             ; A = parent directory ID
1445   081A             ;------------------------------------------------------------------------------------------------------;
1446   081A             get_parentID_from_dirID:
1447   081A D8            push b
1448   081B DA            push d
1449   081C 27            mov b, a
1450   081D 38 00 00      mov c, 0                      ; upper LBA = 0
1451   0820 22 01         mov ah, $01                  ; 1 sector
1452   0822 3B C2 24      mov d, transient_area - 512
1453   0825 07 A8 04      call ide_read_sect            ; read directory
1454   0828 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1455   082B E7            pop d
1456   082C E5            pop b
1457   082D 09            ret
1458   082E             
1459   082E             ;------------------------------------------------------------------------------------------------------;
1460   082E             ; get dirID from a given path string
1461   082E             ; in_puts:
1462   082E             ; D = path pointer 
1463   082E             ; out_puts:
1464   082E             ; A = dirID
1465   082E             ; if dir non existent, A = FFFF (fail code)
1466   082E             ; /usr/local/bin    - absolute
1467   082E             ; local/bin/games    - relative
1468   082E             ;------------------------------------------------------------------------------------------------------;
1469   082E             fs_path_to_dir_id_user:
1470   082E FD 4E         mov si, d
1471   0830 FD 4F C2 1E   mov di, user_data
1472   0834 38 00 02      mov c, 512
1473   0837 04            load
1474   0838 07 3C 08      call get_dirID_from_path
1475   083B 06            sysret
1476   083C             get_dirID_from_path:
1477   083C 26 C2 1E      mov b, user_data
1478   083F FD 42 70 16   mov [prog], b                  ; token pointer set to path string
1479   0843 07 D1 14      call get_token
1480   0846 31 73 16      mov bl, [tok]
1481   0849 C1 01         cmp bl, TOK_FSLASH
1482   084B C6 57 08      je get_dirID_from_path_abs 
1483   084E 14 85 17      mov a, [current_dir_id]
1484   0851 07 57 16      call _putback
1485   0854 0A 5A 08      jmp get_dirID_from_path_E0
1486   0857             get_dirID_from_path_abs:
1487   0857 10 20 00      mov a, root_id
1488   085A             get_dirID_from_path_E0:
1489   085A 07 D1 14      call get_token
1490   085D 31 72 16      mov bl, [toktyp]
1491   0860 C1 00         cmp bl, TOKTYP_IDENTIFIER
1492   0862 C7 B3 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1493   0865             
1494   0865 FD 4D 74 16   mov si, tokstr
1495   0869 FD 4F 42 1E   mov di, filename
1496   086D 07 A3 10      call _strcpy        
1497   0870 77            inc a                         ; metadata sector
1498   0871 27            mov b, a
1499   0872 38 00 00      mov c, 0                      ; upper LBA = 0
1500   0875 22 01         mov ah, $01                  ; 1 sector
1501   0877 3B C2 26      mov d, transient_area
1502   087A 07 A8 04      call ide_read_sect            ; read directory
1503   087D FD 10         cla
1504   087F 42 7D 17      mov [index], a
1505   0882             get_dirID_from_path_L1:
1506   0882 FD 4E         mov si, d
1507   0884 FD 4F 42 1E   mov di, filename
1508   0888 07 8E 10      call _strcmp
1509   088B C6 A1 08      je get_dirID_from_path_name_equal  
1510   088E 58 20 00      add d, 32
1511   0891 14 7D 17      mov a, [index]
1512   0894 77            inc a
1513   0895 42 7D 17      mov [index], a
1514   0898 AF 10 00      cmp a, FST_FILES_PER_DIR
1515   089B C6 B4 08      je get_dirID_from_path_fail
1516   089E 0A 82 08      jmp get_dirID_from_path_L1
1517   08A1             get_dirID_from_path_name_equal:
1518   08A1 58 19 00      add d, 25           
1519   08A4 15            mov a, [d]                    ; set result register A = dirID
1520   08A5 07 D1 14      call get_token
1521   08A8 31 73 16      mov bl, [tok]
1522   08AB C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1523   08AD C6 5A 08      je get_dirID_from_path_E0
1524   08B0 07 57 16      call _putback
1525   08B3             get_dirID_from_path_end:
1526   08B3 09            ret
1527   08B4             get_dirID_from_path_fail:
1528   08B4 10 FF FF      mov A, $FFFF
1529   08B7 09            ret
1530   08B8             
1531   08B8             
1532   08B8             ;------------------------------------------------------------------------------------------------------;
1533   08B8             ; check if file exists by a given path string
1534   08B8             ; in_puts:
1535   08B8             ; D = path pointer 
1536   08B8             ; OUTPUTS:
1537   08B8             ; A = success code, if file exists gives LBA, else, give 0
1538   08B8             ; /usr/local/bin/ed
1539   08B8             ;------------------------------------------------------------------------------------------------------;
1540   08B8             fs_filepath_exists_user:
1541   08B8 FD 4E         mov si, d
1542   08BA FD 4F C2 1E   mov di, user_data
1543   08BE 38 00 02      mov c, 512
1544   08C1 04            load
1545   08C2 07 C6 08      call file_exists_by_path
1546   08C5 06            sysret
1547   08C6             file_exists_by_path:
1548   08C6 26 C2 1E      mov b, user_data
1549   08C9 FD 42 70 16   mov [prog], b                   ; token pointer set to path string
1550   08CD 07 D1 14      call get_token
1551   08D0 31 73 16      mov bl, [tok]
1552   08D3 C1 01         cmp bl, TOK_FSLASH
1553   08D5 C6 E1 08      je  file_exists_by_path_abs
1554   08D8 14 85 17      mov a, [current_dir_id]
1555   08DB 07 57 16      call _putback
1556   08DE 0A E4 08      jmp file_exists_by_path_E0
1557   08E1             file_exists_by_path_abs:
1558   08E1 10 20 00      mov a, root_id
1559   08E4             file_exists_by_path_E0:
1560   08E4 07 D1 14      call get_token
1561   08E7 31 72 16      mov bl, [toktyp]
1562   08EA C1 00         cmp bl, TOKTYP_IDENTIFIER
1563   08EC C7 44 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1564   08EF FD 4D 74 16   mov si, tokstr
1565   08F3 FD 4F 42 1E   mov di, filename
1566   08F7 07 A3 10      call _strcpy        
1567   08FA 77            inc a                           ; metadata sector
1568   08FB 27            mov b, a
1569   08FC 38 00 00      mov c, 0                        ; upper LBA = 0
1570   08FF 22 01         mov ah, $01                  ; 1 sector
1571   0901 3B C2 26      mov d, transient_area
1572   0904 07 A8 04      call ide_read_sect              ; read directory
1573   0907 FD 10         cla
1574   0909 42 7D 17      mov [index], a
1575   090C             file_exists_by_path_L1:
1576   090C FD 4E         mov si, d
1577   090E FD 4F 42 1E   mov di, filename
1578   0912 07 8E 10      call _strcmp
1579   0915 C6 2B 09      je   file_exists_by_path_name_equal
1580   0918 58 20 00      add d, 32
1581   091B 14 7D 17      mov a, [index]
1582   091E 77            inc a
1583   091F 42 7D 17      mov [index], a
1584   0922 AF 10 00      cmp a, FST_FILES_PER_DIR
1585   0925 C6 44 09      je file_exists_by_path_end
1586   0928 0A 0C 09      jmp file_exists_by_path_L1
1587   092B             file_exists_by_path_name_equal:
1588   092B 33 18 00      mov bl, [d + 24]
1589   092E FD 87 38      and bl, %00111000               ; directory flag
1590   0931 C1 08         cmp bl, %00001000               ; is dir?
1591   0933 C6 3A 09      je file_exists_by_path_isdir;
1592   0936             ; entry is a file
1593   0936 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1594   0939 09            ret
1595   093A             file_exists_by_path_isdir:
1596   093A 58 19 00      add d, 25           
1597   093D 15            mov a, [d]                      ; set result register A = dirID
1598   093E 07 D1 14      call get_token
1599   0941 0A E4 08      jmp file_exists_by_path_E0
1600   0944             file_exists_by_path_end:
1601   0944 10 00 00      mov a, 0                        ; return 0 because file was not found
1602   0947 09            ret
1603   0948             
1604   0948             ;------------------------------------------------------------------------------------------------------;
1605   0948             ; load file data from a given path string
1606   0948             ; inputs:
1607   0948             ; D = path pointer 
1608   0948             ; DI = userspace program data destination
1609   0948             ; /usr/local/bin/ed
1610   0948             ; ./ed
1611   0948             ;------------------------------------------------------------------------------------------------------;
1612   0948             fs_load_from_path_user:
1613   0948 E3            push di
1614   0949 FD 4E         mov si, d
1615   094B FD 4F C2 1E   mov di, user_data
1616   094F 38 00 02      mov c, 512
1617   0952 04            load
1618   0953 07 60 09      call loadfile_from_path
1619   0956 F0            pop di
1620   0957 FD 4D C2 26   mov si, transient_area
1621   095B 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1622   095E 03            store
1623   095F 06            sysret
1624   0960             loadfile_from_path:
1625   0960 26 C2 1E      mov b, user_data
1626   0963 FD 42 70 16   mov [prog], b                 ; token pointer set to path string
1627   0967 07 D1 14      call get_token
1628   096A 31 73 16      mov bl, [tok]
1629   096D C1 01         cmp bl, TOK_FSLASH
1630   096F C6 7B 09      je loadfile_from_path_abs 
1631   0972 14 85 17      mov a, [current_dir_id]
1632   0975 07 57 16      call _putback
1633   0978 0A 7E 09      jmp loadfile_from_path_E0
1634   097B             loadfile_from_path_abs:
1635   097B 10 20 00      mov a, root_id
1636   097E             loadfile_from_path_E0:
1637   097E 07 D1 14      call get_token
1638   0981 31 72 16      mov bl, [toktyp]
1639   0984 C1 00         cmp bl, TOKTYP_IDENTIFIER
1640   0986 C7 EB 09      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1641   0989 FD 4D 74 16   mov si, tokstr
1642   098D FD 4F 42 1E   mov di, filename
1643   0991 07 A3 10      call _strcpy        
1644   0994 77            inc a                         ; metadata sector
1645   0995 27            mov b, a
1646   0996 38 00 00      mov c, 0                      ; upper LBA = 0
1647   0999 22 01         mov ah, $01                  ; 1 sector
1648   099B 3B C2 26      mov d, transient_area
1649   099E 07 A8 04      call ide_read_sect            ; read directory
1650   09A1 FD 10         cla
1651   09A3 42 7D 17      mov [index], a
1652   09A6             loadfile_from_path_L1:
1653   09A6 FD 4E         mov si, d
1654   09A8 FD 4F 42 1E   mov di, filename
1655   09AC 07 8E 10      call _strcmp
1656   09AF C6 C5 09      je loadfile_from_path_name_equal  
1657   09B2 58 20 00      add d, 32
1658   09B5 14 7D 17      mov a, [index]
1659   09B8 77            inc a
1660   09B9 42 7D 17      mov [index], a
1661   09BC AF 10 00      cmp a, FST_FILES_PER_DIR
1662   09BF C6 EB 09      je loadfile_from_path_end
1663   09C2 0A A6 09      jmp loadfile_from_path_L1
1664   09C5             loadfile_from_path_name_equal:
1665   09C5 33 18 00      mov bl, [d + 24]
1666   09C8 FD 87 38      and bl, %00111000             ; directory flag
1667   09CB C1 08         cmp bl, %00001000             ; is dir?
1668   09CD C6 E1 09      je loadfile_isdirectory  
1669   09D0             ; entry is a file
1670   09D0 2B 19 00      mov b, [d + 25]               ; get LBA
1671   09D3 FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1672   09D5 3B C2 26      mov d, transient_area
1673   09D8 38 00 00      mov c, 0
1674   09DB 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1675   09DD 07 A8 04      call ide_read_sect            ; read sector
1676   09E0 09            ret
1677   09E1             loadfile_isdirectory:
1678   09E1 58 19 00      add d, 25           
1679   09E4 15            mov a, [d]                    ; set result register A = dirID
1680   09E5 07 D1 14      call get_token
1681   09E8 0A 7E 09      jmp loadfile_from_path_E0
1682   09EB             loadfile_from_path_end:
1683   09EB 09            ret
1684   09EC             
1685   09EC             ;------------------------------------------------------------------------------------------------------;
1686   09EC             ; return the ID of the current directory
1687   09EC             ; ID returned in B
1688   09EC             ;------------------------------------------------------------------------------------------------------;
1689   09EC             fs_get_curr_dirID:
1690   09EC 29 85 17      mov b, [current_dir_id]
1691   09EF 06            sysret
1692   09F0             
1693   09F0             ;------------------------------------------------------------------------------------------------------;
1694   09F0             ; CD
1695   09F0             ;------------------------------------------------------------------------------------------------------;
1696   09F0             ; new dirID in B
1697   09F0             fs_cd:
1698   09F0 FD 42 85 17   mov [current_dir_id], b
1699   09F4 06            sysret  
1700   09F5             
1701   09F5             ;------------------------------------------------------------------------------------------------------;
1702   09F5             ; LS
1703   09F5             ; dirID in B
1704   09F5             ;------------------------------------------------------------------------------------------------------;
1705   09F5 00 00       ls_count:       .dw 0
1706   09F7             fs_ls:
1707   09F7 FD 77         inc b                        ; metadata sector
1708   09F9 38 00 00      mov c, 0                     ; upper LBA = 0
1709   09FC 22 01         mov ah, $01                  ; 1 sector
1710   09FE 3B C2 26      mov d, transient_area
1711   0A01 07 A8 04      call ide_read_sect           ; read directory
1712   0A04 FD 10         cla
1713   0A06 42 7D 17      mov [index], a               ; reset entry index
1714   0A09 3D F5 09      mov [ls_count], al           ; reset item count
1715   0A0C             fs_ls_L1:
1716   0A0C BD 00         cmp byte [d], 0              ; check for NULL
1717   0A0E C6 A5 0A      je fs_ls_next
1718   0A11             fs_ls_non_null:
1719   0A11 1D F5 09      mov al, [ls_count]
1720   0A14 7A            inc al
1721   0A15 3D F5 09      mov [ls_count], al           ; increment item count
1722   0A18 1F 18 00      mov al, [d + 24]
1723   0A1B 87 38         and al, %00111000
1724   0A1D FD A2 03      shr al, 3
1725   0A20 22 00         mov ah, 0                    ; file type
1726   0A22 B7 A1 17      mov a, [a + file_type]      
1727   0A25 23            mov ah, al
1728   0A26 07 1F 11      call _putchar
1729   0A29 1F 18 00      mov al, [d + 24]
1730   0A2C 87 01         and al, %00000001
1731   0A2E 22 00         mov ah, 0
1732   0A30 B7 9C 17      mov a, [a + file_attrib]     ; read
1733   0A33 23            mov ah, al
1734   0A34 07 1F 11      call _putchar
1735   0A37 1F 18 00      mov al, [d + 24]
1736   0A3A 87 02         and al, %00000010
1737   0A3C 22 00         mov ah, 0
1738   0A3E B7 9C 17      mov a, [a + file_attrib]     ; write
1739   0A41 23            mov ah, al
1740   0A42 07 1F 11      call _putchar
1741   0A45 1F 18 00      mov al, [d + 24]
1742   0A48 87 04         and al, %00000100
1743   0A4A 22 00         mov ah, 0
1744   0A4C B7 9C 17      mov a, [a + file_attrib]     ; execute
1745   0A4F 23            mov ah, al
1746   0A50 07 1F 11      call _putchar
1747   0A53 22 20         mov ah, $20
1748   0A55 07 1F 11      call _putchar  
1749   0A58 2B 1B 00      mov b, [d + 27]
1750   0A5B 07 A7 12      call print_u16x              ; filesize
1751   0A5E 22 20         mov ah, $20
1752   0A60 07 1F 11      call _putchar  
1753   0A63 2B 19 00      mov b, [d + 25]
1754   0A66 07 A7 12      call print_u16x              ; dirID / LBA
1755   0A69 22 20         mov ah, $20
1756   0A6B 07 1F 11      call _putchar
1757   0A6E             ; print date
1758   0A6E 33 1D 00      mov bl, [d + 29]             ; day
1759   0A71 07 EB 12      call print_u8x
1760   0A74 22 20         mov ah, $20
1761   0A76 07 1F 11      call _putchar  
1762   0A79 1F 1E 00      mov al, [d + 30]             ; month
1763   0A7C FD 9E 02      shl al, 2
1764   0A7F DA            push d
1765   0A80 3B 60 18      mov d, s_months
1766   0A83 22 00         mov ah, 0
1767   0A85 59            add d, a
1768   0A86 07 4B 12      call _puts
1769   0A89 E7            pop d
1770   0A8A 22 20         mov ah, $20
1771   0A8C 07 1F 11      call _putchar
1772   0A8F 2E 20         mov bl, $20
1773   0A91 07 EB 12      call print_u8x
1774   0A94 33 1F 00      mov bl, [d + 31]             ; year
1775   0A97 07 EB 12      call print_u8x  
1776   0A9A 22 20         mov ah, $20
1777   0A9C 07 1F 11      call _putchar  
1778   0A9F 07 4B 12      call _puts                   ; print filename  
1779   0AA2 07 F8 11      call printnl
1780   0AA5             fs_ls_next:
1781   0AA5 14 7D 17      mov a, [index]
1782   0AA8 77            inc a
1783   0AA9 42 7D 17      mov [index], a
1784   0AAC AF 10 00      cmp a, FST_FILES_PER_DIR
1785   0AAF C6 B8 0A      je fs_ls_end
1786   0AB2 58 20 00      add d, 32      
1787   0AB5 0A 0C 0A      jmp fs_ls_L1  
1788   0AB8             fs_ls_end:
1789   0AB8 3B B1 17      mov d, s_ls_total
1790   0ABB 07 4B 12      call _puts
1791   0ABE 1D F5 09      mov al, [ls_count]
1792   0AC1 07 FD 12      call print_u8d
1793   0AC4 07 F8 11      call printnl
1794   0AC7 06            sysret
1795   0AC8             
1796   0AC8             
1797   0AC8             ; file structure:
1798   0AC8             ; 512 bytes header
1799   0AC8             ; header used to tell whether the block is free
1800   0AC8             ;------------------------------------------------------------------------------------------------------;
1801   0AC8             ; CREATE NEW TEXTFILE
1802   0AC8             ;------------------------------------------------------------------------------------------------------;
1803   0AC8             ; d = content pointer in user space
1804   0AC8             ; c = file size
1805   0AC8             fs_starcom:
1806   0AC8 FD 4E       	mov si, d
1807   0ACA FD 4F C2 26 	mov di, transient_area
1808   0ACE 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1809   0AD1 04          	load					; load data from user-space
1810   0AD2 07 53 0B    	call fs_find_empty_block	; look for empty data blocks
1811   0AD5 D8          	push b				; save empty block LBA
1812   0AD6 FD 79         mov g, b
1813   0AD8             ;create header file by grabbing file name from parameter	
1814   0AD8 3B C2 28    	mov d, transient_area + 512			; pointer to file contents
1815   0ADB D9          	push c							; save length
1816   0ADC 19 01       	mov al, 1
1817   0ADE 3D C2 26    	mov [transient_area], al					; mark sectors as USED (not NULL)
1818   0AE1 3B C2 26    	mov d, transient_area
1819   0AE4 12            mov a, c
1820   0AE5 26 00 02      mov b, 512
1821   0AE8 AE            div a, b
1822   0AE9 FD 77         inc b         ; inc b as the division will most likely have a remainder
1823   0AEB 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1824   0AEC 38 00 00    	mov c, 0      ; lba 
1825   0AEF FD 27         mov b, g      ; lba 
1826   0AF1 07 CE 04    	call ide_write_sect			; write sectors
1827   0AF4             ; now we add the file to the current directory!
1828   0AF4             fs_starcom_add_to_dir:	
1829   0AF4 14 85 17    	mov a, [current_dir_id]
1830   0AF7 77          	inc a
1831   0AF8 27          	mov b, a					; metadata sector
1832   0AF9 38 00 00    	mov c, 0
1833   0AFC FD 79       	mov g, b					; save LBA
1834   0AFE 3B C2 24    	mov d, scrap_sector
1835   0B01 22 01       	mov ah, $01			  ; 1 sector
1836   0B03 07 A8 04    	call ide_read_sect		; read metadata sector
1837   0B06             fs_starcom_add_to_dir_L2:
1838   0B06 BD 00       	cmp byte[d], 0
1839   0B08 C6 11 0B    	je fs_starcom_add_to_dir_null
1840   0B0B 58 20 00    	add d, FST_ENTRY_SIZE
1841   0B0E 0A 06 0B    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1842   0B11             fs_starcom_add_to_dir_null:
1843   0B11 FD 4D C3 26 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1844   0B15 FD 50       	mov di, d
1845   0B17 07 A3 10    	call _strcpy			; copy file name
1846   0B1A 58 18 00    	add d, 24			; skip name
1847   0B1D 19 07       	mov al, %00000111	; type=file, execute, write, read
1848   0B1F 3E          	mov [d], al			
1849   0B20 58 03 00    	add d, 3
1850   0B23 E4          	pop a
1851   0B24 5F 00 02      sub a, 512
1852   0B27 43          	mov [d], a ; file size
1853   0B28 63 02 00    	sub d, 2
1854   0B2B E5          	pop b				; get file LBA
1855   0B2C FD 43       	mov [d], b			; save LBA	
1856   0B2E             ; set file creation date	
1857   0B2E 58 04 00    	add d, 4
1858   0B31 19 04       	mov al, 4
1859   0B33 05 01       	syscall sys_rtc
1860   0B35 1A          	mov al, ah
1861   0B36 3E          	mov [d], al			; set day
1862   0B37 79          	inc d
1863   0B38 19 05       	mov al, 5
1864   0B3A 05 01       	syscall sys_rtc
1865   0B3C 1A          	mov al, ah
1866   0B3D 3E          	mov [d], al			; set month
1867   0B3E 79          	inc d
1868   0B3F 19 06       	mov al, 6
1869   0B41 05 01       	syscall sys_rtc
1870   0B43 1A          	mov al, ah
1871   0B44 3E          	mov [d], al			; set year
1872   0B45             ; write sector into disk for new directory entry
1873   0B45 FD 27       	mov b, g
1874   0B47 38 00 00    	mov c, 0
1875   0B4A 3B C2 24    	mov d, scrap_sector
1876   0B4D 22 01       	mov ah, $01			; disk write, 1 sector
1877   0B4F 07 CE 04    	call ide_write_sect		; write sector
1878   0B52 06          	sysret
1879   0B53             
1880   0B53             ;------------------------------------------------------------------------------------------------------;
1881   0B53             ; finds an empty data block
1882   0B53             ; block LBA returned in B
1883   0B53             ;------------------------------------------------------------------------------------------------------;
1884   0B53             fs_find_empty_block:
1885   0B53 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1886   0B56 38 00 00      mov c, 0                ; upper LBA = 0
1887   0B59             fs_find_empty_block_L1:  
1888   0B59 22 01         mov ah, $01                  ; 1 sector
1889   0B5B 3B C2 24      mov d, transient_area - 512
1890   0B5E 07 A8 04      call ide_read_sect      ; read sector
1891   0B61 BD 00         cmp byte [d], 0
1892   0B63 C6 6C 0B      je fs_find_empty_block_found_null
1893   0B66 55 20 00      add b, FS_SECTORS_PER_FILE
1894   0B69 0A 59 0B      jmp fs_find_empty_block_L1
1895   0B6C             fs_find_empty_block_found_null:
1896   0B6C 09            ret
1897   0B6D             
1898   0B6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1899   0B6D             ;; CREATE NEW TEXTFILE
1900   0B6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1901   0B6D             ; search for first null block
1902   0B6D             fs_mktxt:
1903   0B6D FD 4E       	mov si, d
1904   0B6F FD 4F C2 1E 	mov di, user_data
1905   0B73 38 00 01    	mov c, 256
1906   0B76 04          	load					; load data from user-space
1907   0B77             	
1908   0B77 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1909   0B7A 38 00 00    	mov c, 0						; reset LBA to 0
1910   0B7D             fs_mktxt_L1:	
1911   0B7D 10 02 01    	mov a, $0102			; disk read
1912   0B80 3B C2 26    	mov d, transient_area
1913   0B83 05 02       	syscall sys_ide ; read sector
1914   0B85 1E          	mov al, [d]
1915   0B86 B9 00       	cmp al, 0			; check for NULL
1916   0B88 C6 91 0B    	je fs_mktxt_found_null
1917   0B8B 55 20 00    	add b, FS_SECTORS_PER_FILE
1918   0B8E 0A 7D 0B    	jmp fs_mktxt_L1
1919   0B91             fs_mktxt_found_null:
1920   0B91 D8          	push b				; save LBA
1921   0B92             ;create header file by grabbing file name from parameter	
1922   0B92 3B 92 17    	mov d, s_dataentry
1923   0B95 07 4B 12    	call _puts
1924   0B98 3B C2 28    	mov d, transient_area + 512			; pointer to file contents
1925   0B9B 07 B1 11    	call _gettxt
1926   0B9E 07 7E 10    	call _strlen						; get length of file
1927   0BA1 D9          	push c							; save length
1928   0BA2 19 01       	mov al, 1
1929   0BA4 3D C2 26    	mov [transient_area], al					; mark sectors as USED (not NULL)
1930   0BA7 10 00 00    	mov a, 0
1931   0BAA 42 7D 17    	mov [index], a
1932   0BAD 3B C2 26    	mov d, transient_area
1933   0BB0 13          	mov a, d
1934   0BB1 42 7F 17    	mov [buffer_addr], a
1935   0BB4             fs_mktxt_L2:
1936   0BB4 38 00 00    	mov c, 0
1937   0BB7 10 03 01    	mov a, $0103			; disk write, 1 sector
1938   0BBA 05 02       	syscall sys_ide		; write sector
1939   0BBC 14 7D 17    	mov a, [index]
1940   0BBF 77          	inc a
1941   0BC0 42 7D 17    	mov [index], a
1942   0BC3 AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1943   0BC6 C6 D8 0B    	je fs_mktxt_add_to_dir
1944   0BC9 FD 77       	inc b
1945   0BCB 14 7F 17    	mov a, [buffer_addr]
1946   0BCE 53 00 02    	add a, 512
1947   0BD1 42 7F 17    	mov [buffer_addr], a
1948   0BD4 3C          	mov d, a
1949   0BD5 0A B4 0B    	jmp fs_mktxt_L2
1950   0BD8             ; now we add the file to the current directory!
1951   0BD8             fs_mktxt_add_to_dir:	
1952   0BD8 14 85 17    	mov a, [current_dir_id]
1953   0BDB 77          	inc a
1954   0BDC 27          	mov b, a					; metadata sector
1955   0BDD 38 00 00    	mov c, 0
1956   0BE0 FD 79       	mov g, b					; save LBA
1957   0BE2 3B C2 26    	mov d, transient_area
1958   0BE5 10 02 01    	mov a, $0102			; disk read
1959   0BE8 05 02       	syscall sys_ide		; read metadata sector
1960   0BEA             fs_mktxt_add_to_dir_L2:
1961   0BEA 1E          	mov al, [d]
1962   0BEB B9 00       	cmp al, 0
1963   0BED C6 F6 0B    	je fs_mktxt_add_to_dir_null
1964   0BF0 58 20 00    	add d, FST_ENTRY_SIZE
1965   0BF3 0A EA 0B    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1966   0BF6             fs_mktxt_add_to_dir_null:
1967   0BF6 FD 4D C2 1E 	mov si, user_data
1968   0BFA FD 50       	mov di, d
1969   0BFC 07 A3 10    	call _strcpy			; copy file name
1970   0BFF 58 18 00    	add d, 24			; skip name
1971   0C02 19 06       	mov al, %00000110		; no execute, write, read, not directory
1972   0C04 3E          	mov [d], al			
1973   0C05 58 03 00    	add d, 3
1974   0C08 E4          	pop a
1975   0C09 43          	mov [d], a
1976   0C0A 63 02 00    	sub d, 2
1977   0C0D E5          	pop b				; get file LBA
1978   0C0E FD 43       	mov [d], b			; save LBA	
1979   0C10             	
1980   0C10             	; set file creation date	
1981   0C10 58 04 00    	add d, 4
1982   0C13 19 04       	mov al, 4
1983   0C15 05 01       	syscall sys_rtc
1984   0C17 1A          	mov al, ah
1985   0C18 3E          	mov [d], al			; set day
1986   0C19             	
1987   0C19 79          	inc d
1988   0C1A 19 05       	mov al, 5
1989   0C1C 05 01       	syscall sys_rtc
1990   0C1E 1A          	mov al, ah
1991   0C1F 3E          	mov [d], al			; set month
1992   0C20             	
1993   0C20 79          	inc d
1994   0C21 19 06       	mov al, 6
1995   0C23 05 01       	syscall sys_rtc
1996   0C25 1A          	mov al, ah
1997   0C26 3E          	mov [d], al			; set year
1998   0C27             	
1999   0C27             ; write sector into disk for new directory entry
2000   0C27 FD 27       	mov b, g
2001   0C29 38 00 00    	mov c, 0
2002   0C2C 3B C2 26    	mov d, transient_area
2003   0C2F 10 03 01    	mov a, $0103			; disk write, 1 sector
2004   0C32 05 02       	syscall sys_ide		; write sector
2005   0C34 07 F8 11    	call printnl
2006   0C37 06          	sysret
2007   0C38             
2008   0C38             
2009   0C38             
2010   0C38             ;------------------------------------------------------------------------------------------------------;
2011   0C38             ; CREATE NEW BINARY FILE
2012   0C38             ;------------------------------------------------------------------------------------------------------;
2013   0C38             ; search for first null block
2014   0C38             fs_mkbin:
2015   0C38 19 00         mov al, 0
2016   0C3A 3D 75 17      mov [sys_echo_on], al ; disable echo
2017   0C3D FD 4E         mov si, d
2018   0C3F FD 4F C2 1E   mov di, user_data
2019   0C43 38 00 02      mov c, 512
2020   0C46 04            load                          ; load data from user-space
2021   0C47 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
2022   0C4A 38 00 00      mov c, 0                      ; upper LBA = 0
2023   0C4D             fs_mkbin_L1:  
2024   0C4D 22 01         mov ah, $01                  ; 1 sector
2025   0C4F 3B C2 26      mov d, transient_area
2026   0C52 07 A8 04      call ide_read_sect            ; read sector
2027   0C55 BD 00         cmp byte[d], 0                ; check for NULL
2028   0C57 C6 60 0C      je fs_mkbin_found_null
2029   0C5A 55 20 00      add b, FS_SECTORS_PER_FILE
2030   0C5D 0A 4D 0C      jmp fs_mkbin_L1
2031   0C60             fs_mkbin_found_null:
2032   0C60 D8            push b                        ; save LBA
2033   0C61             ;create header file by grabbing file name from parameter
2034   0C61 FD 4F C2 28   mov di, transient_area + 512  ; pointer to file contents
2035   0C65 07 DB 0F      call _load_hex                ; load binary hex
2036   0C68 D9            push c                        ; save size (nbr of bytes)
2037   0C69 19 01         mov al, 1
2038   0C6B 3D C2 26      mov [transient_area], al      ; mark sectors as USED (not NULL)
2039   0C6E FD 10         cla
2040   0C70 42 7D 17      mov [index], a
2041   0C73 3B C2 26      mov d, transient_area
2042   0C76 13            mov a, d
2043   0C77 42 7F 17      mov [buffer_addr], a
2044   0C7A             fs_mkbin_L2:
2045   0C7A 38 00 00      mov c, 0
2046   0C7D 22 01         mov ah, $01                   ; disk write, 1 sector
2047   0C7F 07 CE 04      call ide_write_sect           ; write sector
2048   0C82 14 7D 17      mov a, [index]
2049   0C85 77            inc a
2050   0C86 42 7D 17      mov [index], a
2051   0C89 AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
2052   0C8C C6 9E 0C      je fs_mkbin_add_to_dir
2053   0C8F FD 77         inc b
2054   0C91 14 7F 17      mov a, [buffer_addr]
2055   0C94 53 00 02      add a, 512
2056   0C97 42 7F 17      mov [buffer_addr], a
2057   0C9A 3C            mov d, a
2058   0C9B 0A 7A 0C      jmp fs_mkbin_L2
2059   0C9E             ; now we add the file to the current directory!
2060   0C9E             fs_mkbin_add_to_dir:  
2061   0C9E 14 85 17      mov a, [current_dir_id]
2062   0CA1 77            inc a
2063   0CA2 27            mov b, a                      ; metadata sector
2064   0CA3 38 00 00      mov c, 0
2065   0CA6 FD 79         mov g, b                      ; save LBA
2066   0CA8 3B C2 26      mov d, transient_area
2067   0CAB 22 01         mov ah, $01                  ; 1 sector
2068   0CAD 07 A8 04      call ide_read_sect            ; read metadata sector
2069   0CB0             fs_mkbin_add_to_dir_L2:
2070   0CB0 BD 00         cmp byte[d], 0
2071   0CB2 C6 BB 0C      je fs_mkbin_add_to_dir_null
2072   0CB5 58 20 00      add d, FST_ENTRY_SIZE
2073   0CB8 0A B0 0C      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
2074   0CBB             fs_mkbin_add_to_dir_null:
2075   0CBB FD 4D C2 1E   mov si, user_data
2076   0CBF FD 50         mov di, d
2077   0CC1 07 A3 10      call _strcpy                  ; copy file name
2078   0CC4 58 18 00      add d, 24                     ; skip name
2079   0CC7 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2080   0CC9 3E            mov [d], al
2081   0CCA 58 03 00      add d, 3
2082   0CCD E4            pop a
2083   0CCE 43            mov [d], a
2084   0CCF 63 02 00      sub d, 2
2085   0CD2 E5            pop b                         ; get file LBA
2086   0CD3 FD 43         mov [d], b                    ; save LBA
2087   0CD5               ; set file creation date  
2088   0CD5 58 04 00      add d, 4
2089   0CD8 19 04         mov al, 4
2090   0CDA 05 01         syscall sys_rtc
2091   0CDC 1A            mov al, ah
2092   0CDD 3E            mov [d], al                   ; set day
2093   0CDE 79            inc d
2094   0CDF 19 05         mov al, 5
2095   0CE1 05 01         syscall sys_rtc
2096   0CE3 1A            mov al, ah
2097   0CE4 3E            mov [d], al                   ; set month
2098   0CE5 79            inc d
2099   0CE6 19 06         mov al, 6
2100   0CE8 05 01         syscall sys_rtc
2101   0CEA 1A            mov al, ah
2102   0CEB 3E            mov [d], al                   ; set year
2103   0CEC             ; write sector into disk for new directory entry
2104   0CEC FD 27         mov b, g
2105   0CEE 38 00 00      mov c, 0
2106   0CF1 3B C2 26      mov d, transient_area
2107   0CF4 22 01         mov ah, $01                   ; disk write, 1 sector
2108   0CF6 07 CE 04      call ide_write_sect           ; write sector
2109   0CF9 19 01         mov al, 1
2110   0CFB 3D 75 17      mov [sys_echo_on], al ; enable echo
2111   0CFE 06            sysret
2112   0CFF             
2113   0CFF             ;------------------------------------------------------------------------------------------------------;
2114   0CFF             ; PWD - PRINT WORKING DIRECTORY
2115   0CFF             ;------------------------------------------------------------------------------------------------------;    
2116   0CFF             fs_pwd:
2117   0CFF 3B 42 1E      mov d, filename
2118   0D02 19 00         mov al, 0
2119   0D04 3E            mov [d], al                   ; initialize path string 
2120   0D05 14 85 17      mov a, [current_dir_id]
2121   0D08 07 DE 07      call fs_dir_id_to_path_E0
2122   0D0B 3B 42 1E      mov d, filename
2123   0D0E 07 37 10      call _strrev
2124   0D11 07 4B 12      call _puts
2125   0D14 07 F8 11      call printnl
2126   0D17 06            sysret
2127   0D18             
2128   0D18             ;------------------------------------------------------------------------------------------------------;
2129   0D18             ; get current directory LBA
2130   0D18             ; A: returned LBA
2131   0D18             ;------------------------------------------------------------------------------------------------------;
2132   0D18             cmd_get_curr_dir_LBA:
2133   0D18 14 85 17      mov a, [current_dir_id]
2134   0D1B 06            sysret
2135   0D1C             
2136   0D1C             ;------------------------------------------------------------------------------------------------------;
2137   0D1C             ; CAT
2138   0D1C             ; userspace destination data pointer in D
2139   0D1C             ; filename starts at D, but is overwritten after the read is made
2140   0D1C             ;------------------------------------------------------------------------------------------------------;:
2141   0D1C             fs_cat:
2142   0D1C DA            push d                              ; save userspace file data destination
2143   0D1D FD 4E         mov si, d
2144   0D1F FD 4F C2 1E   mov di, user_data
2145   0D23 38 00 02      mov c, 512
2146   0D26 04            load                                ; copy filename from user-space
2147   0D27 29 85 17      mov b, [current_dir_id]
2148   0D2A FD 77         inc b                               ; metadata sector
2149   0D2C 38 00 00      mov c, 0                            ; upper LBA = 0
2150   0D2F 22 01         mov ah, $01                  ; 1 sector
2151   0D31 3B C2 24      mov d, transient_area-512
2152   0D34 07 A8 04      call ide_read_sect                  ; read directory
2153   0D37 FD 10         cla
2154   0D39 42 7D 17      mov [index], a                      ; reset file counter
2155   0D3C             fs_cat_L1:
2156   0D3C FD 4E         mov si, d
2157   0D3E FD 4F C2 1E   mov di, user_data
2158   0D42 07 8E 10      call _strcmp
2159   0D45 C6 5B 0D      je fs_cat_found_entry
2160   0D48 58 20 00      add d, 32
2161   0D4B 14 7D 17      mov a, [index]
2162   0D4E 77            inc a
2163   0D4F 42 7D 17      mov [index], a
2164   0D52 AF 10 00      cmp a, FST_FILES_PER_DIR
2165   0D55 C6 76 0D      je fs_cat_not_found
2166   0D58 0A 3C 0D      jmp fs_cat_L1
2167   0D5B             fs_cat_found_entry:
2168   0D5B 58 19 00      add d, 25                           ; get to dirID of file in disk
2169   0D5E 2A            mov b, [d]                          ; get LBA
2170   0D5F FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2171   0D61 3B C2 26      mov d, transient_area  
2172   0D64 38 00 00      mov c, 0
2173   0D67 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2174   0D69 07 A8 04      call ide_read_sect                  ; read sectors
2175   0D6C F0            pop di                              ; write userspace file data destination to DI
2176   0D6D FD 4D C2 26   mov si, transient_area              ; data origin
2177   0D71 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2178   0D74 03            store
2179   0D75 06            sysret
2180   0D76             fs_cat_not_found:
2181   0D76 E7            pop d
2182   0D77 06            sysret
2183   0D78             
2184   0D78             ;------------------------------------------------------------------------------------------------------;
2185   0D78             ; RMDIR - remove DIR by dirID
2186   0D78             ;------------------------------------------------------------------------------------------------------;
2187   0D78             ; deletes a directory entry in the given directory's file list 
2188   0D78             ; also deletes the actual directory entry in the FST
2189   0D78             ; synopsis: rmdir /usr/local/testdir
2190   0D78             ; B = dirID
2191   0D78             fs_rmdir:
2192   0D78 FD 79         mov g, b
2193   0D7A 11            mov a, b
2194   0D7B 07 1A 08      call get_parentID_from_dirID  ; now get the directory's parent, in A
2195   0D7E D7            push a                        ; save dirID
2196   0D7F             ; search for directory's entry in the parent's directory then and delete it
2197   0D7F 77            inc a                         ; metadata sector
2198   0D80 27            mov b, a
2199   0D81 38 00 00      mov c, 0                      ; upper LBA = 0
2200   0D84 22 01         mov ah, $01          ;
2201   0D86 3B C2 26      mov d, transient_area
2202   0D89 07 A8 04      call ide_read_sect            ; read directory
2203   0D8C FD 10         cla
2204   0D8E 42 7D 17      mov [index], a                ; reset file counter
2205   0D91 FD 27         mov b, g                      ; retrieve directory's dirID
2206   0D93             fs_rmdir_L1:
2207   0D93 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2208   0D96 B0            cmp a, b                      ; compare dirID's to find the directory
2209   0D97 C6 AD 0D      je fs_rmdir_found_entry
2210   0D9A 58 20 00      add d, 32
2211   0D9D 14 7D 17      mov a, [index]
2212   0DA0 77            inc a
2213   0DA1 42 7D 17      mov [index], a
2214   0DA4 AF 10 00      cmp a, FST_FILES_PER_DIR
2215   0DA7 C6 D2 0D      je fs_rmdir_not_found
2216   0DAA 0A 93 0D      jmp fs_rmdir_L1
2217   0DAD             fs_rmdir_found_entry:
2218   0DAD FD 10         cla
2219   0DAF 3E            mov [d], al                   ; make filename NULL
2220   0DB0 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2221   0DB3 E5            pop b
2222   0DB4 FD 77         inc b                         ; metadata sector
2223   0DB6 38 00 00      mov c, 0                      ; upper LBA = 0
2224   0DB9 22 01         mov ah, $01          ; 
2225   0DBB 3B C2 26      mov d, transient_area
2226   0DBE 07 CE 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2227   0DC1             
2228   0DC1 FD 27         mov b, g
2229   0DC3 3B C2 26      mov d, transient_area  
2230   0DC6 FD 10         cla
2231   0DC8 3E            mov [d], al                   ; make directory's name header NULL for re-use
2232   0DC9 38 00 00      mov c, 0
2233   0DCC 22 01         mov ah, $01                   ; disk write 1 sect
2234   0DCE 07 CE 04      call ide_write_sect           ; delete directory given by dirID in B
2235   0DD1 06            sysret
2236   0DD2             fs_rmdir_not_found:
2237   0DD2 E5            pop b
2238   0DD3 06            sysret
2239   0DD4             
2240   0DD4             ;------------------------------------------------------------------------------------------------------;
2241   0DD4             ; RM - remove file
2242   0DD4             ;------------------------------------------------------------------------------------------------------;
2243   0DD4             ; frees up the data sectors for the file further down the disk
2244   0DD4             ; deletes file entry in the directory's file list 
2245   0DD4             fs_rm:
2246   0DD4 FD 4E         mov si, d
2247   0DD6 FD 4F C2 1E   mov di, user_data
2248   0DDA 38 00 02      mov c, 512
2249   0DDD 04            load                          ; load data from user-space
2250   0DDE 14 85 17      mov a, [current_dir_id]
2251   0DE1 77            inc a                         ; metadata sector
2252   0DE2 27            mov b, a
2253   0DE3 38 00 00      mov c, 0                      ; upper LBA = 0
2254   0DE6 22 01         mov ah, $01                  ; 1 sector
2255   0DE8 3B C2 26      mov d, transient_area
2256   0DEB 07 A8 04      call ide_read_sect            ; read directory
2257   0DEE 10 00 00      mov a, 0
2258   0DF1 42 7D 17      mov [index], a                ; reset file counter
2259   0DF4             fs_rm_L1:
2260   0DF4 FD 4E         mov si, d
2261   0DF6 FD 4F C2 1E   mov di, user_data
2262   0DFA 07 8E 10      call _strcmp
2263   0DFD C6 13 0E      je fs_rm_found_entry
2264   0E00 58 20 00      add d, 32
2265   0E03 14 7D 17      mov a, [index]
2266   0E06 77            inc a
2267   0E07 42 7D 17      mov [index], a
2268   0E0A AF 10 00      cmp a, FST_FILES_PER_DIR
2269   0E0D C6 3B 0E      je fs_rm_not_found
2270   0E10 0A F4 0D      jmp fs_rm_L1
2271   0E13             fs_rm_found_entry:
2272   0E13 2B 19 00      mov b, [d + 25]               ; get LBA
2273   0E16 FD 79         mov g, b                      ; save LBA
2274   0E18 19 00         mov al, 0
2275   0E1A 3E            mov [d], al                   ; make file entry NULL
2276   0E1B 14 85 17      mov a, [current_dir_id]
2277   0E1E 77            inc a                         ; metadata sector
2278   0E1F 27            mov b, a
2279   0E20 38 00 00      mov c, 0                      ; upper LBA = 0
2280   0E23 22 01         mov ah, $01                   ; disk write
2281   0E25 3B C2 26      mov d, transient_area
2282   0E28 07 CE 04      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2283   0E2B 3B C2 26      mov d, transient_area  
2284   0E2E 19 00         mov al, 0
2285   0E30 3E            mov [d], al                   ; make file's data header NULL for re-use
2286   0E31 38 00 00      mov c, 0
2287   0E34 FD 27         mov b, g                      ; get data header LBA
2288   0E36 22 01         mov ah, $01                   ; disk write 1 sect
2289   0E38 07 CE 04      call ide_write_sect           ; write sector
2290   0E3B             fs_rm_not_found:  
2291   0E3B 06            sysret  
2292   0E3C             
2293   0E3C             ;------------------------------------------------------------------------------------------------------;
2294   0E3C             ; mv - move / change file name
2295   0E3C             ;------------------------------------------------------------------------------------------------------;
2296   0E3C             fs_mv:
2297   0E3C FD 4E         mov si, d
2298   0E3E FD 4F C2 1E   mov di, user_data
2299   0E42 38 00 02      mov c, 512
2300   0E45 04            load                          ; load data from user-space
2301   0E46 14 85 17      mov a, [current_dir_id]
2302   0E49 77            inc a                         ; metadata sector
2303   0E4A 27            mov b, a  
2304   0E4B 38 00 00      mov c, 0                      ; upper LBA = 0
2305   0E4E 22 01         mov ah, $01                  ; 1 sector
2306   0E50 3B C2 26      mov d, transient_area
2307   0E53 07 A8 04      call ide_read_sect            ; read directory
2308   0E56 FD 10         cla
2309   0E58 42 7D 17      mov [index], a                ; reset file counter
2310   0E5B             fs_mv_L1:
2311   0E5B FD 4E         mov si, d
2312   0E5D FD 4F C2 1E   mov di, user_data
2313   0E61 07 8E 10      call _strcmp
2314   0E64 C6 7A 0E      je fs_mv_found_entry
2315   0E67 58 20 00      add d, 32
2316   0E6A 14 7D 17      mov a, [index]
2317   0E6D 77            inc a
2318   0E6E 42 7D 17      mov [index], a
2319   0E71 AF 10 00      cmp a, FST_FILES_PER_DIR
2320   0E74 C6 AC 0E      je fs_mv_not_found
2321   0E77 0A 5B 0E      jmp fs_mv_L1
2322   0E7A             fs_mv_found_entry:  
2323   0E7A DA            push d
2324   0E7B FD 4D 42 1F   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2325   0E7F FD 50         mov di, d
2326   0E81 07 A3 10      call _strcpy  
2327   0E84 38 00 00      mov c, 0
2328   0E87 3B C2 26      mov d, transient_area
2329   0E8A 22 01         mov ah, $01                   ; disk write 1 sect
2330   0E8C 07 CE 04      call ide_write_sect           ; write sector
2331   0E8F E7            pop d
2332   0E90             ;; need to check whether its a dir or a file here ;;;
2333   0E90 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2334   0E93 22 01         mov ah, $01
2335   0E95 3B C2 26      mov d, transient_area
2336   0E98 38 00 00      mov c, 0
2337   0E9B 07 A8 04      call ide_read_sect            ; read directory entry
2338   0E9E FD 4D 42 1F   mov si, user_data + 128
2339   0EA2 FD 50         mov di, d
2340   0EA4 07 A3 10      call _strcpy                  ; change directory's name
2341   0EA7 22 01         mov ah, $01
2342   0EA9 07 CE 04      call ide_write_sect           ; rewrite directory back to disk
2343   0EAC             fs_mv_not_found:
2344   0EAC 06            sysret
2345   0EAD             
2346   0EAD             
2347   0EAD             ;----------------------------------------------------------------------------------------------------;
2348   0EAD             ; Process Index in A
2349   0EAD             ;----------------------------------------------------------------------------------------------------;
2350   0EAD             find_free_proc:
2351   0EAD FD 4D 33 1C   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2352   0EB1             find_free_proc_L0:
2353   0EB1 F6            lodsb                               ; get process state
2354   0EB2 B9 00         cmp al, 0
2355   0EB4 C6 BA 0E      je find_free_proc_free              ; if free, jump
2356   0EB7 0A B1 0E      jmp find_free_proc_L0               ; else, goto next
2357   0EBA             find_free_proc_free:
2358   0EBA 4E            mov a, si
2359   0EBB 5F 33 1C      sub a, 1 + proc_availab_table       ; get process index
2360   0EBE 09            ret
2361   0EBF               
2362   0EBF             
2363   0EBF             ;----------------------------------------------------------------------------------------------------;
2364   0EBF             ; Process Index in AL
2365   0EBF             ;----------------------------------------------------------------------------------------------------;
2366   0EBF             proc_memory_map:
2367   0EBF 22 00         mov ah, 0
2368   0EC1 27            mov b, a                      ; page in BL, 0 in BH
2369   0EC2 FD 9D 05      shl a, 5                      ; multiply by 32
2370   0EC5 39            mov c, a                      ; save in C
2371   0EC6 57 20 00      add c, 32
2372   0EC9             proc_memory_map_L0:
2373   0EC9 02            pagemap
2374   0ECA 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2375   0ECD 53 01 00      add a, 1                      ; increase both 
2376   0ED0 B1            cmp a, c                      ; check to see if we reached the end of memory
2377   0ED1 C7 C9 0E      jne proc_memory_map_L0
2378   0ED4 09            ret
2379   0ED5               
2380   0ED5             
2381   0ED5             syscall_terminate_proc:
2382   0ED5 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2383   0ED8                                                    ; since they will not be used for anything here.
2384   0ED8 1D 7C 17      mov al, [active_proc_index]
2385   0EDB 22 00         mov ah, 0  
2386   0EDD FD 9D 05      shl a, 5                             ; x32
2387   0EE0 53 42 1C      add a, proc_names
2388   0EE3 3C            mov d, a
2389   0EE4 19 00         mov al, 0
2390   0EE6 3E            mov [d], al                           ; nullify process name
2391   0EE7             
2392   0EE7 1D 7C 17      mov al, [active_proc_index]
2393   0EEA 22 00         mov ah, 0  
2394   0EEC 3C            mov d, a
2395   0EED 19 00         mov al, 0
2396   0EEF 3F 32 1C      mov [d + proc_availab_table], al    ; make process empty again
2397   0EF2               
2398   0EF2 1D 7B 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2399   0EF5 80            dec al
2400   0EF6 3D 7B 17      mov [nbr_active_procs], al
2401   0EF9             
2402   0EF9             ; now load the shell process again
2403   0EF9 19 02         mov al, 2                           ; next process = process 2 = shell
2404   0EFB 3D 7C 17      mov [active_proc_index], al         ; set next active proc
2405   0EFE             
2406   0EFE             ; calculate LUT entry for next process
2407   0EFE 22 00         mov ah, 0
2408   0F00 FD 99         shl a                               ; x2
2409   0F02 B7 CB 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2410   0F05               
2411   0F05 4D            mov si, a                           ; source is proc state block
2412   0F06 48            mov a, sp
2413   0F07 5F 13 00      sub a, 19
2414   0F0A 4F            mov di, a                           ; destination is kernel stack
2415   0F0B             ; restore SP
2416   0F0B 7D            dec a
2417   0F0C 47            mov sp, a
2418   0F0D 38 14 00      mov c, 20
2419   0F10 FD F5         rep movsb
2420   0F12             ; set VM process
2421   0F12 1D 7C 17      mov al, [active_proc_index]
2422   0F15 01            setptb
2423   0F16                 
2424   0F16 4C            popa
2425   0F17 06            sysret
2426   0F18             
2427   0F18             syscall_pause_proc:
2428   0F18             ; save all registers into kernel stack
2429   0F18 4B            pusha
2430   0F19 22 00         mov ah, 0
2431   0F1B 1D 7C 17      mov al, [active_proc_index]
2432   0F1E FD 99         shl a              ; x2
2433   0F20 B7 CB 0F      mov a, [proc_table_convert + a]   ; get process state start index
2434   0F23                 
2435   0F23 4F            mov di, a
2436   0F24 48            mov a, sp
2437   0F25 77            inc a
2438   0F26 4D            mov si, a
2439   0F27 38 14 00      mov c, 20
2440   0F2A FD F5         rep movsb                         ; save process state!
2441   0F2C             ; restore kernel stack position to point before interrupt arrived
2442   0F2C 51 14 00      add sp, 20
2443   0F2F             ; now load the shell process again
2444   0F2F 19 02         mov al, 2                         ; next process = process 2 = shell
2445   0F31 3D 7C 17      mov [active_proc_index], al       ; set next active proc
2446   0F34             
2447   0F34             ; calculate LUT entry for next process
2448   0F34 22 00         mov ah, 0
2449   0F36 FD 99         shl a                             ; x2
2450   0F38 B7 CB 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2451   0F3B               
2452   0F3B 4D            mov si, a                         ; source is proc state block
2453   0F3C 48            mov a, sp
2454   0F3D 5F 13 00      sub a, 19
2455   0F40 4F            mov di, a                         ; destination is kernel stack
2456   0F41             ; restore SP
2457   0F41 7D            dec a
2458   0F42 47            mov sp, a
2459   0F43 38 14 00      mov c, 20
2460   0F46 FD F5         rep movsb
2461   0F48             ; set VM process
2462   0F48 1D 7C 17      mov al, [active_proc_index]
2463   0F4B 01            setptb
2464   0F4C                 
2465   0F4C 4C            popa
2466   0F4D 06            sysret
2467   0F4E             
2468   0F4E             ;----------------------------------------------------------------------------------------------------;
2469   0F4E             ; create a new process
2470   0F4E             ; D = path of the process file to be createed
2471   0F4E             ; B = arguments ptr
2472   0F4E             ;----------------------------------------------------------------------------------------------------;
2473   0F4E             syscall_create_proc:
2474   0F4E             ; we save the active process first  
2475   0F4E 4B            pusha
2476   0F4F 22 00         mov ah, 0
2477   0F51 1D 7C 17      mov al, [active_proc_index]
2478   0F54 FD 99         shl a              ; x2
2479   0F56 B7 CB 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2480   0F59               
2481   0F59 4F            mov di, a
2482   0F5A 48            mov a, sp
2483   0F5B 77            inc a
2484   0F5C 4D            mov si, a
2485   0F5D 38 14 00      mov c, 20
2486   0F60 FD F5         rep movsb                          ; save process state!
2487   0F62             ; restore kernel stack position to point before interrupt arrived
2488   0F62 51 14 00      add sp, 20
2489   0F65               
2490   0F65 FD 4E         mov si, d                          ; copy the file path
2491   0F67 FD 4F C2 1E   mov di, user_data
2492   0F6B 38 00 02      mov c, 512
2493   0F6E 04            load
2494   0F6F 11            mov a, b
2495   0F70 4D            mov si, a                          ; copy the arguments
2496   0F71 FD 4F C2 24   mov di, scrap_sector
2497   0F75 38 00 02      mov c, 512
2498   0F78 04            load
2499   0F79 07 60 09      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2500   0F7C                                                  ; the file data is loaded into transient_area
2501   0F7C             ; now we allocate a new process  
2502   0F7C 07 AD 0E      call find_free_proc                ; index in A
2503   0F7F 01            setptb 
2504   0F80 07 BF 0E      call proc_memory_map               ; map process memory pages
2505   0F83             ; copy arguments into process's memory
2506   0F83 FD 4D C2 24   mov si, scrap_sector
2507   0F87 FD 4F 00 00   mov di, 0
2508   0F8B 38 00 02      mov c, 512
2509   0F8E 03            store
2510   0F8F             ; now copy process binary data into process's memory
2511   0F8F FD 4D C2 26   mov si, transient_area
2512   0F93 FD 4F 00 04   mov di, text_org              ; code origin address for all user processes
2513   0F97 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2514   0F9A 03            store                              ; copy process data
2515   0F9B                 
2516   0F9B 07 AD 0E      call find_free_proc                ; index in A
2517   0F9E 3D 7C 17      mov [active_proc_index], al        ; set new active process
2518   0FA1 FD 9D 05      shl a, 5                           ; x32
2519   0FA4 53 42 1C      add a, proc_names
2520   0FA7 4F            mov di, a
2521   0FA8 FD 4D C2 1E   mov si, user_data                  ; copy and store process filename
2522   0FAC 07 A3 10      call _strcpy
2523   0FAF               
2524   0FAF 07 AD 0E      call find_free_proc                ; index in A
2525   0FB2 3C            mov d, a
2526   0FB3 19 01         mov al, 1
2527   0FB5 3F 32 1C      mov [d + proc_availab_table], al   ; make process busy
2528   0FB8               
2529   0FB8 1D 7B 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2530   0FBB 7A            inc al
2531   0FBC 3D 7B 17      mov [nbr_active_procs], al
2532   0FBF             ; launch process
2533   0FBF FD D7 FF FF   push word $FFFF 
2534   0FC3 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2535   0FC6 FD D7 00 04   push word text_org
2536   0FCA 06            sysret
2537   0FCB             
2538   0FCB             proc_table_convert:
2539   0FCB F2 1A         .dw proc_state_table + 0
2540   0FCD 06 1B         .dw proc_state_table + 20
2541   0FCF 1A 1B         .dw proc_state_table + 40
2542   0FD1 2E 1B         .dw proc_state_table + 60
2543   0FD3 42 1B         .dw proc_state_table + 80
2544   0FD5 56 1B         .dw proc_state_table + 100
2545   0FD7 6A 1B         .dw proc_state_table + 120
2546   0FD9 7E 1B         .dw proc_state_table + 140
2547   0FDB               
2548   0FDB             ;----------------------------------------------------------------------------------------------;
2549   0FDB             ; GET HEX FILE
2550   0FDB             ; di = destination address
2551   0FDB             ; return length in bytes in C
2552   0FDB             ;----------------------------------------------------------------------------------------------;
2553   0FDB             _load_hex:
2554   0FDB D7            push a
2555   0FDC D8            push b
2556   0FDD DA            push d
2557   0FDE E2            push si
2558   0FDF E3            push di
2559   0FE0 38 00 00      mov c, 0
2560   0FE3 50            mov a, di
2561   0FE4 3C            mov d, a          ; start of string data block
2562   0FE5 07 26 11      call _gets        ; get program string
2563   0FE8               ;call _puts        ; reprint to screen
2564   0FE8 4D            mov si, a
2565   0FE9             __load_hex_loop:
2566   0FE9 F6            lodsb             ; load from [SI] to AL
2567   0FEA B9 00         cmp al, 0         ; check if ASCII 0
2568   0FEC C6 FA 0F      jz __load_hex_ret
2569   0FEF 36            mov bh, al
2570   0FF0 F6            lodsb
2571   0FF1 2F            mov bl, al
2572   0FF2 07 DC 10      call _atoi        ; convert ASCII byte in B to int (to AL)
2573   0FF5 F7            stosb             ; store AL to [DI]
2574   0FF6 78            inc c
2575   0FF7 0A E9 0F      jmp __load_hex_loop
2576   0FFA             __load_hex_ret:
2577   0FFA F0            pop di
2578   0FFB EF            pop si
2579   0FFC E7            pop d
2580   0FFD E5            pop b
2581   0FFE E4            pop a
2582   0FFF 09            ret
2583   1000             
2584   1000             ; synopsis: look insIDE a certain DIRECTORY for files/directories
2585   1000             ; BEFORE CALLING THIS FUNCTION, CD INTO REQUIRED DIRECTORY
2586   1000             ; for each entry insIDE DIRECTORY:
2587   1000             ;  if entry is a file:
2588   1000             ;    compare filename to searched filename
2589   1000             ;    if filenames are the same, print filename
2590   1000             ;  else if entry is a directory:
2591   1000             ;    cd to the given directory
2592   1000             ;    recursively call cmd_find
2593   1000             ;    cd outsIDE previous directory
2594   1000             ;  if current entry == last entry, return
2595   1000             ; endfor
2596   1000             f_find:
2597   1000 09            ret
2598   1001             
2599   1001             
2600   1001             ; ---------------------------------------------------------------------
2601   1001             ; KERNEL RESET VECTOR
2602   1001             ; ---------------------------------------------------------------------
2603   1001             kernel_reset_vector:  
2604   1001 FD 49 FF F7   mov bp, STACK_BEGIN
2605   1005 FD 47 FF F7   mov sp, STACK_BEGIN
2606   1009               
2607   1009 19 81         mov al, %10000001
2608   100B FD 0F         stomsk                        ; mask out timer interrupt for now (only allow UART to interrupt)
2609   100D FD 0C         sti  
2610   100F             
2611   100F 0C            lodstat
2612   1010 87 DF         and al, %11011111             ; disable display register loading
2613   1012 0D            stostat
2614   1013               
2615   1013             ; reset fifo pointers
2616   1013 10 C2 20      mov a, fifo
2617   1016 3B 81 17      mov d, fifo_in
2618   1019 43            mov [d], a
2619   101A 3B 83 17      mov d, fifo_out
2620   101D 43            mov [d], a  
2621   101E 19 02         mov al, 2
2622   1020 05 03         syscall sys_io                ; enable uart in interrupt mode
2623   1022               
2624   1022 3B C7 17      mov d, s_kernel_started
2625   1025 07 4B 12      call _puts
2626   1028             
2627   1028 19 10         mov al, 16
2628   102A 05 04         syscall sys_filesystem        ; set root dirID
2629   102C             
2630   102C 3B E4 17      mov d, s_prompt_init
2631   102F 07 4B 12      call _puts
2632   1032 3B 87 17      mov d, s_init_path
2633   1035 05 05         syscall sys_create_proc              ; launch init as a new process
2634   1037             
2635   1037             
2636   1037             ; FILE INCLUDES
2637   1037             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  1037             BIOS_RESET_VECTOR .EQU  $01c0
0002+  1037             IDE_buffer       .EQU  $8204
0003+  1037             boot_origin      .EQU  $8004
0004+  1037             bios_uart        .EQU  $0002
0005+  1037             bios_ide         .EQU  $0003
2638   1037             .include "lib/stdio.asm"
0001+  1037             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1037             ; stdio.s
0003+  1037             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1037             .include "lib/string.asm"
0001++ 1037             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1037             ; string.s
0003++ 1037             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1037             
0005++ 1037             
0006++ 1037             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1037             ; _strrev
0008++ 1037             ; reverse a string
0009++ 1037             ; D = string address
0010++ 1037             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1037             ; 01234
0012++ 1037             _strrev:
0013++ 1037 4B          	pusha
0014++ 1038 07 7E 10    	call _strlen	; length in C
0015++ 103B 12          	mov a, c
0016++ 103C AF 01 00    	cmp a, 1
0017++ 103F D0 59 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1042 7D          	dec a
0019++ 1043 FD 4E       	mov si, d	; beginning of string
0020++ 1045 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1047 59          	add d, a	; end of string
0022++ 1048 12          	mov a, c
0023++ 1049 FD 9B       	shr a		; divide by 2
0024++ 104B 39          	mov c, a	; C now counts the steps
0025++ 104C             _strrev_L0:
0026++ 104C 32          	mov bl, [d]	; save load right-side char into BL
0027++ 104D F6          	lodsb		; load left-side char into AL; increase SI
0028++ 104E 3E          	mov [d], al	; store left char into right side
0029++ 104F 1B          	mov al, bl
0030++ 1050 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1051 7E          	dec c
0032++ 1052 7F          	dec d
0033++ 1053 C2 00 00    	cmp c, 0
0034++ 1056 C7 4C 10    	jne _strrev_L0
0035++ 1059             _strrev_end:
0036++ 1059 4C          	popa
0037++ 105A 09          	ret
0038++ 105B             	
0039++ 105B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 105B             ; _strchr
0041++ 105B             ; search string in D for char in AL
0042++ 105B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 105B             _strchr:
0044++ 105B             _strchr_L0:
0045++ 105B 32          	mov bl, [d]
0046++ 105C C1 00       	cmp bl, 0
0047++ 105E C6 69 10    	je _strchr_end
0048++ 1061 BA          	cmp al, bl
0049++ 1062 C6 69 10    	je _strchr_end
0050++ 1065 79          	inc d
0051++ 1066 0A 5B 10    	jmp _strchr_L0
0052++ 1069             _strchr_end:
0053++ 1069 1B          	mov al, bl
0054++ 106A 09          	ret
0055++ 106B             
0056++ 106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 106B             ; _strstr
0058++ 106B             ; find sub-string
0059++ 106B             ; str1 in SI
0060++ 106B             ; str2 in DI
0061++ 106B             ; SI points to end of source string
0062++ 106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 106B             _strstr:
0064++ 106B DB          	push al
0065++ 106C DA          	push d
0066++ 106D E3          	push di
0067++ 106E             _strstr_loop:
0068++ 106E F3          	cmpsb					; compare a byte of the strings
0069++ 106F C7 7A 10    	jne _strstr_ret
0070++ 1072 FC 00 00    	lea d, [di + 0]
0071++ 1075 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1077 C7 6E 10    	jne _strstr_loop				; equal chars but not at end
0073++ 107A             _strstr_ret:
0074++ 107A F0          	pop di
0075++ 107B E7          	pop d
0076++ 107C E8          	pop al
0077++ 107D 09          	ret
0078++ 107E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 107E             ; length of null terminated string
0080++ 107E             ; result in C
0081++ 107E             ; pointer in D
0082++ 107E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 107E             _strlen:
0084++ 107E DA          	push d
0085++ 107F 38 00 00    	mov c, 0
0086++ 1082             _strlen_L1:
0087++ 1082 BD 00       	cmp byte [d], 0
0088++ 1084 C6 8C 10    	je _strlen_ret
0089++ 1087 79          	inc d
0090++ 1088 78          	inc c
0091++ 1089 0A 82 10    	jmp _strlen_L1
0092++ 108C             _strlen_ret:
0093++ 108C E7          	pop d
0094++ 108D 09          	ret
0095++ 108E             
0096++ 108E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 108E             ; STRCMP
0098++ 108E             ; compare two strings
0099++ 108E             ; str1 in SI
0100++ 108E             ; str2 in DI
0101++ 108E             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 108E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 108E             _strcmp:
0104++ 108E DB          	push al
0105++ 108F DA          	push d
0106++ 1090 E3          	push di
0107++ 1091 E2          	push si
0108++ 1092             _strcmp_loop:
0109++ 1092 F3          	cmpsb					; compare a byte of the strings
0110++ 1093 C7 9E 10    	jne _strcmp_ret
0111++ 1096 FB FF FF    	lea d, [si +- 1]
0112++ 1099 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 109B C7 92 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 109E             _strcmp_ret:
0115++ 109E EF          	pop si
0116++ 109F F0          	pop di
0117++ 10A0 E7          	pop d
0118++ 10A1 E8          	pop al
0119++ 10A2 09          	ret
0120++ 10A3             
0121++ 10A3             
0122++ 10A3             ; STRCPY
0123++ 10A3             ; copy null terminated string from SI to DI
0124++ 10A3             ; source in SI
0125++ 10A3             ; destination in DI
0126++ 10A3             _strcpy:
0127++ 10A3 E2          	push si
0128++ 10A4 E3          	push di
0129++ 10A5 DB          	push al
0130++ 10A6             _strcpy_L1:
0131++ 10A6 F6          	lodsb
0132++ 10A7 F7          	stosb
0133++ 10A8 B9 00       	cmp al, 0
0134++ 10AA C7 A6 10    	jne _strcpy_L1
0135++ 10AD             _strcpy_end:
0136++ 10AD E8          	pop al
0137++ 10AE F0          	pop di
0138++ 10AF EF          	pop si
0139++ 10B0 09          	ret
0140++ 10B1             
0141++ 10B1             ; STRCAT
0142++ 10B1             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 10B1             ; source in SI
0144++ 10B1             ; destination in DI
0145++ 10B1             _strcat:
0146++ 10B1 E2          	push si
0147++ 10B2 E3          	push di
0148++ 10B3 D7          	push a
0149++ 10B4 DA          	push d
0150++ 10B5 50          	mov a, di
0151++ 10B6 3C          	mov d, a
0152++ 10B7             _strcat_goto_end_L1:
0153++ 10B7 BD 00       	cmp byte[d], 0
0154++ 10B9 C6 C0 10    	je _strcat_start
0155++ 10BC 79          	inc d
0156++ 10BD 0A B7 10    	jmp _strcat_goto_end_L1
0157++ 10C0             _strcat_start:
0158++ 10C0 FD 50       	mov di, d
0159++ 10C2             _strcat_L1:
0160++ 10C2 F6          	lodsb
0161++ 10C3 F7          	stosb
0162++ 10C4 B9 00       	cmp al, 0
0163++ 10C6 C7 C2 10    	jne _strcat_L1
0164++ 10C9             _strcat_end:
0165++ 10C9 E7          	pop d
0166++ 10CA E4          	pop a
0167++ 10CB F0          	pop di
0168++ 10CC EF          	pop si
0169++ 10CD 09          	ret
0170++ 10CE             
0171++ 10CE             
0005+  10CE             
0006+  10CE             
0007+  10CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  10CE             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  10CE             ; ASCII in BL
0010+  10CE             ; result in AL
0011+  10CE             ; ascii for F = 0100 0110
0012+  10CE             ; ascii for 9 = 0011 1001
0013+  10CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  10CE             hex_ascii_encode:
0015+  10CE 1B            mov al, bl
0016+  10CF 93 40         test al, $40        ; test if letter or number
0017+  10D1 C7 D7 10      jnz hex_letter
0018+  10D4 87 0F         and al, $0F        ; get number
0019+  10D6 09            ret
0020+  10D7             hex_letter:
0021+  10D7 87 0F         and al, $0F        ; get letter
0022+  10D9 6A 09         add al, 9
0023+  10DB 09            ret
0024+  10DC             
0025+  10DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  10DC             ; ATOI
0027+  10DC             ; 2 letter hex string in B
0028+  10DC             ; 8bit integer returned in AL
0029+  10DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  10DC             _atoi:
0031+  10DC D8            push b
0032+  10DD 07 CE 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  10E0 30            mov bl, bh
0034+  10E1 DB            push al          ; save a
0035+  10E2 07 CE 10      call hex_ascii_encode
0036+  10E5 EA            pop bl  
0037+  10E6 FD 9E 04      shl al, 4
0038+  10E9 8C            or al, bl
0039+  10EA E5            pop b
0040+  10EB 09            ret  
0041+  10EC             
0042+  10EC             
0043+  10EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  10EC             ; scanf
0045+  10EC             ; no need for explanations!
0046+  10EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  10EC             scanf:
0048+  10EC 09            ret
0049+  10ED             
0050+  10ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  10ED             ; ITOA
0052+  10ED             ; 8bit value in BL
0053+  10ED             ; 2 byte ASCII result in A
0054+  10ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  10ED             _itoa:
0056+  10ED DA            push d
0057+  10EE D8            push b
0058+  10EF A7 00         mov bh, 0
0059+  10F1 FD A4 04      shr bl, 4  
0060+  10F4 74            mov d, b
0061+  10F5 1F 87 13      mov al, [d + s_hex_digits]
0062+  10F8 23            mov ah, al
0063+  10F9               
0064+  10F9 E5            pop b
0065+  10FA D8            push b
0066+  10FB A7 00         mov bh, 0
0067+  10FD FD 87 0F      and bl, $0F
0068+  1100 74            mov d, b
0069+  1101 1F 87 13      mov al, [d + s_hex_digits]
0070+  1104 E5            pop b
0071+  1105 E7            pop d
0072+  1106 09            ret
0073+  1107             
0074+  1107             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1107             ; HEX STRING TO BINARY
0076+  1107             ; di = destination address
0077+  1107             ; si = source
0078+  1107             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1107             _hex_to_int:
0080+  1107             _hex_to_int_L1:
0081+  1107 F6            lodsb          ; load from [SI] to AL
0082+  1108 B9 00         cmp al, 0        ; check if ASCII 0
0083+  110A C6 17 11      jz _hex_to_int_ret
0084+  110D 36            mov bh, al
0085+  110E F6            lodsb
0086+  110F 2F            mov bl, al
0087+  1110 07 DC 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  1113 F7            stosb          ; store AL to [DI]
0089+  1114 0A 07 11      jmp _hex_to_int_L1
0090+  1117             _hex_to_int_ret:
0091+  1117 09            ret    
0092+  1118             
0093+  1118             
0094+  1118             
0095+  1118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1118             ; GETCHAR
0097+  1118             ; char in ah
0098+  1118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1118             getch:
0100+  1118 DB            push al
0101+  1119             getch_retry:
0102+  1119 19 01         mov al, 1
0103+  111B 05 03         syscall sys_io      ; receive in AH
0104+  111D E8            pop al
0105+  111E 09            ret
0106+  111F             
0107+  111F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  111F             ; PUTCHAR
0109+  111F             ; char in ah
0110+  111F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  111F             _putchar:
0112+  111F DB            push al
0113+  1120 19 00         mov al, 0
0114+  1122 05 03         syscall sys_io      ; char in AH
0115+  1124 E8            pop al
0116+  1125 09            ret
0117+  1126             
0118+  1126             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1126             ;; INPUT A STRING
0120+  1126             ;; terminates with null
0121+  1126             ;; pointer in D
0122+  1126             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1126             _gets:
0124+  1126 D7            push a
0125+  1127 DA            push d
0126+  1128             _gets_loop:
0127+  1128 19 01         mov al, 1
0128+  112A 05 03         syscall sys_io      ; receive in AH
0129+  112C 76 1B         cmp ah, 27
0130+  112E C6 4F 11      je _gets_ansi_esc
0131+  1131 76 0A         cmp ah, $0A        ; LF
0132+  1133 C6 AB 11      je _gets_end
0133+  1136 76 0D         cmp ah, $0D        ; CR
0134+  1138 C6 AB 11      je _gets_end
0135+  113B 76 5C         cmp ah, $5C        ; '\\'
0136+  113D C6 71 11      je _gets_escape
0137+  1140 76 08         cmp ah, $08      ; check for backspace
0138+  1142 C6 4B 11      je _gets_backspace
0139+  1145 1A            mov al, ah
0140+  1146 3E            mov [d], al
0141+  1147 79            inc d
0142+  1148 0A 28 11      jmp _gets_loop
0143+  114B             _gets_backspace:
0144+  114B 7F            dec d
0145+  114C 0A 28 11      jmp _gets_loop
0146+  114F             _gets_ansi_esc:
0147+  114F 19 01         mov al, 1
0148+  1151 05 03         syscall sys_io        ; receive in AH without echo
0149+  1153 76 5B         cmp ah, '['
0150+  1155 C7 28 11      jne _gets_loop
0151+  1158 19 01         mov al, 1
0152+  115A 05 03         syscall sys_io          ; receive in AH without echo
0153+  115C 76 44         cmp ah, 'D'
0154+  115E C6 69 11      je _gets_left_arrow
0155+  1161 76 43         cmp ah, 'C'
0156+  1163 C6 6D 11      je _gets_right_arrow
0157+  1166 0A 28 11      jmp _gets_loop
0158+  1169             _gets_left_arrow:
0159+  1169 7F            dec d
0160+  116A 0A 28 11      jmp _gets_loop
0161+  116D             _gets_right_arrow:
0162+  116D 79            inc d
0163+  116E 0A 28 11      jmp _gets_loop
0164+  1171             _gets_escape:
0165+  1171 19 01         mov al, 1
0166+  1173 05 03         syscall sys_io      ; receive in AH
0167+  1175 76 6E         cmp ah, 'n'
0168+  1177 C6 96 11      je _gets_LF
0169+  117A 76 72         cmp ah, 'r'
0170+  117C C6 9D 11      je _gets_CR
0171+  117F 76 30         cmp ah, '0'
0172+  1181 C6 A4 11      je _gets_NULL
0173+  1184 76 5C         cmp ah, $5C  ; '\'
0174+  1186 C6 8F 11      je _gets_slash
0175+  1189 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  118A 3E            mov [d], al
0177+  118B 79            inc d
0178+  118C 0A 28 11      jmp _gets_loop
0179+  118F             _gets_slash:
0180+  118F 19 5C         mov al, $5C
0181+  1191 3E            mov [d], al
0182+  1192 79            inc d
0183+  1193 0A 28 11      jmp _gets_loop
0184+  1196             _gets_LF:
0185+  1196 19 0A         mov al, $0A
0186+  1198 3E            mov [d], al
0187+  1199 79            inc d
0188+  119A 0A 28 11      jmp _gets_loop
0189+  119D             _gets_CR:
0190+  119D 19 0D         mov al, $0D
0191+  119F 3E            mov [d], al
0192+  11A0 79            inc d
0193+  11A1 0A 28 11      jmp _gets_loop
0194+  11A4             _gets_NULL:
0195+  11A4 19 00         mov al, $00
0196+  11A6 3E            mov [d], al
0197+  11A7 79            inc d
0198+  11A8 0A 28 11      jmp _gets_loop
0199+  11AB             _gets_end:
0200+  11AB 19 00         mov al, 0
0201+  11AD 3E            mov [d], al        ; terminate string
0202+  11AE E7            pop d
0203+  11AF E4            pop a
0204+  11B0 09            ret
0205+  11B1             
0206+  11B1             
0207+  11B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  11B1             ;; INPUT TEXT
0209+  11B1             ;; terminated with CTRL+D
0210+  11B1             ;; pointer in D
0211+  11B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  11B1             _gettxt:
0213+  11B1 D7            push a
0214+  11B2 DA            push d
0215+  11B3             _gettxt_loop:
0216+  11B3 19 01         mov al, 1
0217+  11B5 05 03         syscall sys_io      ; receive in AH
0218+  11B7 76 04         cmp ah, 4      ; EOT
0219+  11B9 C6 F2 11      je _gettxt_end
0220+  11BC 76 08         cmp ah, $08      ; check for backspace
0221+  11BE C6 EE 11      je _gettxt_backspace
0222+  11C1 76 5C         cmp ah, $5C        ; '\'
0223+  11C3 C6 CC 11      je _gettxt_escape
0224+  11C6 1A            mov al, ah
0225+  11C7 3E            mov [d], al
0226+  11C8 79            inc d
0227+  11C9 0A B3 11      jmp _gettxt_loop
0228+  11CC             _gettxt_escape:
0229+  11CC 19 01         mov al, 1
0230+  11CE 05 03         syscall sys_io      ; receive in AH
0231+  11D0 76 6E         cmp ah, 'n'
0232+  11D2 C6 E0 11      je _gettxt_LF
0233+  11D5 76 72         cmp ah, 'r'
0234+  11D7 C6 E7 11      je _gettxt_CR
0235+  11DA 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  11DB 3E            mov [d], al
0237+  11DC 79            inc d
0238+  11DD 0A B3 11      jmp _gettxt_loop
0239+  11E0             _gettxt_LF:
0240+  11E0 19 0A         mov al, $0A
0241+  11E2 3E            mov [d], al
0242+  11E3 79            inc d
0243+  11E4 0A B3 11      jmp _gettxt_loop
0244+  11E7             _gettxt_CR:
0245+  11E7 19 0D         mov al, $0D
0246+  11E9 3E            mov [d], al
0247+  11EA 79            inc d
0248+  11EB 0A B3 11      jmp _gettxt_loop
0249+  11EE             _gettxt_backspace:
0250+  11EE 7F            dec d
0251+  11EF 0A B3 11      jmp _gettxt_loop
0252+  11F2             _gettxt_end:
0253+  11F2 19 00         mov al, 0
0254+  11F4 3E            mov [d], al        ; terminate string
0255+  11F5 E7            pop d
0256+  11F6 E4            pop a
0257+  11F7 09            ret
0258+  11F8             
0259+  11F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  11F8             ; PRINT NEW LINE
0261+  11F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  11F8             printnl:
0263+  11F8 D7            push a
0264+  11F9 10 00 0A      mov a, $0A00
0265+  11FC 05 03         syscall sys_io
0266+  11FE 10 00 0D      mov a, $0D00
0267+  1201 05 03         syscall sys_io
0268+  1203 E4            pop a
0269+  1204 09            ret
0270+  1205             
0271+  1205             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  1205             ; _strtoint
0273+  1205             ; 4 digit hex string number in d
0274+  1205             ; integer returned in A
0275+  1205             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1205             _strtointx:
0277+  1205 D8            push b
0278+  1206 32            mov bl, [d]
0279+  1207 37            mov bh, bl
0280+  1208 33 01 00      mov bl, [d + 1]
0281+  120B 07 DC 10      call _atoi        ; convert to int in AL
0282+  120E 23            mov ah, al        ; move to AH
0283+  120F 33 02 00      mov bl, [d + 2]
0284+  1212 37            mov bh, bl
0285+  1213 33 03 00      mov bl, [d + 3]
0286+  1216 07 DC 10      call _atoi        ; convert to int in AL
0287+  1219 E5            pop b
0288+  121A 09            ret
0289+  121B             
0290+  121B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  121B             ; _strtoint
0292+  121B             ; 5 digit base10 string number in d
0293+  121B             ; integer returned in A
0294+  121B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  121B             _strtoint:
0296+  121B E2            push si
0297+  121C D8            push b
0298+  121D D9            push c
0299+  121E DA            push d
0300+  121F 07 7E 10      call _strlen      ; get string length in C
0301+  1222 7E            dec c
0302+  1223 FD 4E         mov si, d
0303+  1225 12            mov a, c
0304+  1226 FD 99         shl a
0305+  1228 3B 9F 13      mov d, table_power
0306+  122B 59            add d, a
0307+  122C 38 00 00      mov c, 0
0308+  122F             _strtoint_L0:
0309+  122F F6            lodsb      ; load ASCII to al
0310+  1230 B9 00         cmp al, 0
0311+  1232 C6 45 12      je _strtoint_end
0312+  1235 6F 30         sub al, $30    ; make into integer
0313+  1237 22 00         mov ah, 0
0314+  1239 2A            mov b, [d]
0315+  123A AC            mul a, b      ; result in B since it fits in 16bits
0316+  123B 11            mov a, b
0317+  123C 28            mov b, c
0318+  123D 54            add a, b
0319+  123E 39            mov c, a
0320+  123F 63 02 00      sub d, 2
0321+  1242 0A 2F 12      jmp _strtoint_L0
0322+  1245             _strtoint_end:
0323+  1245 12            mov a, c
0324+  1246 E7            pop d
0325+  1247 E6            pop c
0326+  1248 E5            pop b
0327+  1249 EF            pop si
0328+  124A 09            ret
0329+  124B             
0330+  124B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  124B             ; PRINT NULL TERMINATED STRING
0332+  124B             ; pointer in D
0333+  124B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  124B             _puts:
0335+  124B D7            push a
0336+  124C DA            push d
0337+  124D             _puts_L1:
0338+  124D 1E            mov al, [d]
0339+  124E B9 00         cmp al, 0
0340+  1250 C6 5C 12      jz _puts_END
0341+  1253 23            mov ah, al
0342+  1254 19 00         mov al, 0
0343+  1256 05 03         syscall sys_io
0344+  1258 79            inc d
0345+  1259 0A 4D 12      jmp _puts_L1
0346+  125C             _puts_END:
0347+  125C E7            pop d
0348+  125D E4            pop a
0349+  125E 09            ret
0350+  125F             
0351+  125F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  125F             ; PRINT N SIZE STRING
0353+  125F             ; pointer in D
0354+  125F             ; size in C
0355+  125F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  125F             _putsn:
0357+  125F DB            push al
0358+  1260 DA            push d
0359+  1261 D9            push c
0360+  1262             _putsn_L0:
0361+  1262 1E            mov al, [d]
0362+  1263 23            mov ah, al
0363+  1264 19 00         mov al, 0
0364+  1266 05 03         syscall sys_io
0365+  1268 79            inc d
0366+  1269 7E            dec c  
0367+  126A C2 00 00      cmp c, 0
0368+  126D C7 62 12      jne _putsn_L0
0369+  1270             _putsn_end:
0370+  1270 E6            pop c
0371+  1271 E7            pop d
0372+  1272 E8            pop al
0373+  1273 09            ret
0374+  1274             
0375+  1274             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  1274             ; print 16bit decimal number
0377+  1274             ; input number in A
0378+  1274             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  1274             print_u16d:
0380+  1274 D7            push a
0381+  1275 D8            push b
0382+  1276 FD D8         push g
0383+  1278 26 10 27      mov b, 10000
0384+  127B AE            div a, b      ; get 10000's coeff.
0385+  127C 07 A0 12      call print_number
0386+  127F 11            mov a, b
0387+  1280 26 E8 03      mov b, 1000
0388+  1283 AE            div a, b      ; get 1000's coeff.
0389+  1284 07 A0 12      call print_number
0390+  1287 11            mov a, b
0391+  1288 26 64 00      mov b, 100
0392+  128B AE            div a, b
0393+  128C 07 A0 12      call print_number
0394+  128F 11            mov a, b
0395+  1290 26 0A 00      mov b, 10
0396+  1293 AE            div a, b
0397+  1294 07 A0 12      call print_number
0398+  1297 1B            mov al, bl      ; 1's coeff in bl
0399+  1298 07 A0 12      call print_number
0400+  129B FD F1         pop g
0401+  129D E5            pop b
0402+  129E E4            pop a
0403+  129F 09            ret
0404+  12A0             
0405+  12A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  12A0             ; print AL
0407+  12A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  12A0             print_number:
0409+  12A0 6A 30         add al, $30
0410+  12A2 23            mov ah, al
0411+  12A3 07 1F 11      call _putchar
0412+  12A6 09            ret
0413+  12A7             
0414+  12A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  12A7             ; PRINT 16BIT HEX INTEGER
0416+  12A7             ; integer value in reg B
0417+  12A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  12A7             print_u16x:
0419+  12A7 D7            push a
0420+  12A8 D8            push b
0421+  12A9 DD            push bl
0422+  12AA 30            mov bl, bh
0423+  12AB 07 ED 10      call _itoa        ; convert bh to char in A
0424+  12AE 2F            mov bl, al        ; save al
0425+  12AF 19 00         mov al, 0
0426+  12B1 05 03         syscall sys_io        ; display AH
0427+  12B3 24            mov ah, bl        ; retrieve al
0428+  12B4 19 00         mov al, 0
0429+  12B6 05 03         syscall sys_io        ; display AL
0430+  12B8             
0431+  12B8 EA            pop bl
0432+  12B9 07 ED 10      call _itoa        ; convert bh to char in A
0433+  12BC 2F            mov bl, al        ; save al
0434+  12BD 19 00         mov al, 0
0435+  12BF 05 03         syscall sys_io        ; display AH
0436+  12C1 24            mov ah, bl        ; retrieve al
0437+  12C2 19 00         mov al, 0
0438+  12C4 05 03         syscall sys_io        ; display AL
0439+  12C6             
0440+  12C6 E5            pop b
0441+  12C7 E4            pop a
0442+  12C8 09            ret
0443+  12C9             
0444+  12C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  12C9             ; INPUT 16BIT HEX INTEGER
0446+  12C9             ; read 16bit integer into A
0447+  12C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  12C9             scan_u16x:
0449+  12C9 F8 10 00      enter 16
0450+  12CC D8            push b
0451+  12CD DA            push d
0452+  12CE             
0453+  12CE FA F1 FF      lea d, [bp + -15]
0454+  12D1 07 26 11      call _gets        ; get number
0455+  12D4             
0456+  12D4 32            mov bl, [d]
0457+  12D5 37            mov bh, bl
0458+  12D6 33 01 00      mov bl, [d + 1]
0459+  12D9 07 DC 10      call _atoi        ; convert to int in AL
0460+  12DC 23            mov ah, al        ; move to AH
0461+  12DD             
0462+  12DD 33 02 00      mov bl, [d + 2]
0463+  12E0 37            mov bh, bl
0464+  12E1 33 03 00      mov bl, [d + 3]
0465+  12E4 07 DC 10      call _atoi        ; convert to int in AL
0466+  12E7             
0467+  12E7 E7            pop d
0468+  12E8 E5            pop b
0469+  12E9 F9            leave
0470+  12EA 09            ret
0471+  12EB             
0472+  12EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  12EB             ; PRINT 8bit HEX INTEGER
0474+  12EB             ; integer value in reg bl
0475+  12EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  12EB             print_u8x:
0477+  12EB D7            push a
0478+  12EC DD            push bl
0479+  12ED             
0480+  12ED 07 ED 10      call _itoa        ; convert bl to char in A
0481+  12F0 2F            mov bl, al        ; save al
0482+  12F1 19 00         mov al, 0
0483+  12F3 05 03         syscall sys_io        ; display AH
0484+  12F5 24            mov ah, bl        ; retrieve al
0485+  12F6 19 00         mov al, 0
0486+  12F8 05 03         syscall sys_io        ; display AL
0487+  12FA             
0488+  12FA EA            pop bl
0489+  12FB E4            pop a
0490+  12FC 09            ret
0491+  12FD             
0492+  12FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  12FD             ; print 8bit decimal unsigned number
0494+  12FD             ; input number in AL
0495+  12FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  12FD             print_u8d:
0497+  12FD D7            push a
0498+  12FE D8            push b
0499+  12FF FD D8         push g
0500+  1301 22 00         mov ah, 0
0501+  1303 26 64 00      mov b, 100
0502+  1306 AE            div a, b
0503+  1307 D8            push b      ; save remainder
0504+  1308 B9 00         cmp al, 0
0505+  130A C6 14 13      je skip100
0506+  130D 6A 30         add al, $30
0507+  130F 23            mov ah, al
0508+  1310 19 00         mov al, 0
0509+  1312 05 03         syscall sys_io  ; print coeff
0510+  1314             skip100:
0511+  1314 E4            pop a
0512+  1315 22 00         mov ah, 0
0513+  1317 26 0A 00      mov b, 10
0514+  131A AE            div a, b
0515+  131B D8            push b      ; save remainder
0516+  131C B9 00         cmp al, 0
0517+  131E C6 28 13      je skip10
0518+  1321 6A 30         add al, $30
0519+  1323 23            mov ah, al
0520+  1324 19 00         mov al, 0
0521+  1326 05 03         syscall sys_io  ; print coeff
0522+  1328             skip10:
0523+  1328 E4            pop a
0524+  1329 1B            mov al, bl
0525+  132A 6A 30         add al, $30
0526+  132C 23            mov ah, al
0527+  132D 19 00         mov al, 0
0528+  132F 05 03         syscall sys_io  ; print coeff
0529+  1331 FD F1         pop g
0530+  1333 E5            pop b
0531+  1334 E4            pop a
0532+  1335 09            ret
0533+  1336             
0534+  1336             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  1336             ; INPUT 8BIT HEX INTEGER
0536+  1336             ; read 8bit integer into AL
0537+  1336             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  1336             scan_u8x:
0539+  1336 F8 04 00      enter 4
0540+  1339 D8            push b
0541+  133A DA            push d
0542+  133B             
0543+  133B FA FD FF      lea d, [bp + -3]
0544+  133E 07 26 11      call _gets        ; get number
0545+  1341             
0546+  1341 32            mov bl, [d]
0547+  1342 37            mov bh, bl
0548+  1343 33 01 00      mov bl, [d + 1]
0549+  1346 07 DC 10      call _atoi        ; convert to int in AL
0550+  1349             
0551+  1349 E7            pop d
0552+  134A E5            pop b
0553+  134B F9            leave
0554+  134C 09            ret
0555+  134D             
0556+  134D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  134D             ; input decimal number
0558+  134D             ; result in A
0559+  134D             ; 655'\0'
0560+  134D             ; low--------high
0561+  134D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  134D             scan_u16d:
0563+  134D F8 08 00      enter 8
0564+  1350 E2            push si
0565+  1351 D8            push b
0566+  1352 D9            push c
0567+  1353 DA            push d
0568+  1354 FA F9 FF      lea d, [bp +- 7]
0569+  1357 07 26 11      call _gets
0570+  135A 07 7E 10      call _strlen      ; get string length in C
0571+  135D 7E            dec c
0572+  135E FD 4E         mov si, d
0573+  1360 12            mov a, c
0574+  1361 FD 99         shl a
0575+  1363 3B 9F 13      mov d, table_power
0576+  1366 59            add d, a
0577+  1367 38 00 00      mov c, 0
0578+  136A             mul_loop:
0579+  136A F6            lodsb      ; load ASCII to al
0580+  136B B9 00         cmp al, 0
0581+  136D C6 80 13      je mul_exit
0582+  1370 6F 30         sub al, $30    ; make into integer
0583+  1372 22 00         mov ah, 0
0584+  1374 2A            mov b, [d]
0585+  1375 AC            mul a, b      ; result in B since it fits in 16bits
0586+  1376 11            mov a, b
0587+  1377 28            mov b, c
0588+  1378 54            add a, b
0589+  1379 39            mov c, a
0590+  137A 63 02 00      sub d, 2
0591+  137D 0A 6A 13      jmp mul_loop
0592+  1380             mul_exit:
0593+  1380 12            mov a, c
0594+  1381 E7            pop d
0595+  1382 E6            pop c
0596+  1383 E5            pop b
0597+  1384 EF            pop si
0598+  1385 F9            leave
0599+  1386 09            ret
0600+  1387             
0601+  1387             
0602+  1387 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  138B 34 35 36 37 
0602+  138F 38 39 41 42 
0602+  1393 43 44 45 46 
0603+  1397 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  139B 1B 5B 48 00 
0604+  139F             
0605+  139F             table_power:
0606+  139F 01 00         .dw 1
0607+  13A1 0A 00         .dw 10
0608+  13A3 64 00         .dw 100
0609+  13A5 E8 03         .dw 1000
0610+  13A7 10 27         .dw 100002639   13A9             .include "lib/ctype.asm"
0001+  13A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  13A9             ; ctype.s
0003+  13A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  13A9             
0005+  13A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  13A9             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  13A9             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  13A9             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  13A9             ;; characters are supported.
0010+  13A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  13A9             ;; _isalnum 
0012+  13A9             ;; _isalpha 
0013+  13A9             ;; islower 
0014+  13A9             ;; isupper 
0015+  13A9             ;; _isdigit 
0016+  13A9             ;; isxdigit
0017+  13A9             ;; iscntrl 
0018+  13A9             ;; isgraph 
0019+  13A9             ;; _isspace 
0020+  13A9             ;; isblank 
0021+  13A9             ;; isprint 
0022+  13A9             ;; ispunct 
0023+  13A9             ;; tolower 
0024+  13A9             ;; toupper
0025+  13A9             
0026+  13A9             
0027+  13A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  13A9             ;; IS ALPHANUMERIC
0029+  13A9             ;; sets ZF according with result
0030+  13A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  13A9             _isalnum:
0032+  13A9 07 C6 13    	call _isalpha
0033+  13AC C6 B2 13    	je _isalnum_exit
0034+  13AF 07 B3 13    	call _isdigit
0035+  13B2             _isalnum_exit:
0036+  13B2 09          	ret	
0037+  13B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  13B3             ;; IS DIGIT
0039+  13B3             ;; sets ZF according with result
0040+  13B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  13B3             _isdigit:
0042+  13B3 DB          	push al
0043+  13B4 B9 30       	cmp al, '0'
0044+  13B6 C8 C2 13    	jlu _isdigit_false
0045+  13B9 B9 39       	cmp al, '9'
0046+  13BB D1 C2 13    	jgu _isdigit_false
0047+  13BE 87 00       	and al, 0	; set ZF
0048+  13C0 E8          	pop al
0049+  13C1 09          	ret
0050+  13C2             _isdigit_false:
0051+  13C2 8B 01       	or al, 1	; clear ZF
0052+  13C4 E8          	pop al
0053+  13C5 09          	ret	
0054+  13C6             	
0055+  13C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  13C6             ;; IS ALPHA
0057+  13C6             ;; sets ZF according with result
0058+  13C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  13C6             _isalpha:
0060+  13C6 DB          	push al
0061+  13C7 B9 5F       	cmp al, '_'
0062+  13C9 C6 E9 13    	je _isalpha_true
0063+  13CC B9 2E       	cmp al, '.'
0064+  13CE C6 E9 13    	je _isalpha_true
0065+  13D1 B9 41       	cmp al, 'A'
0066+  13D3 C8 E5 13    	jlu _isalpha_false
0067+  13D6 B9 7A       	cmp al, 'z'
0068+  13D8 D1 E5 13    	jgu _isalpha_false
0069+  13DB B9 5A       	cmp al, 'Z'
0070+  13DD D0 E9 13    	jleu _isalpha_true
0071+  13E0 B9 61       	cmp al, 'a'
0072+  13E2 C9 E9 13    	jgeu _isalpha_true
0073+  13E5             _isalpha_false:
0074+  13E5 8B 01       	or al, 1	; clear ZF
0075+  13E7 E8          	pop al
0076+  13E8 09          	ret
0077+  13E9             _isalpha_true:
0078+  13E9 87 00       	and al, 0	; set ZF
0079+  13EB E8          	pop al
0080+  13EC 09          	ret
0081+  13ED             
0082+  13ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  13ED             ;; IS PATH-ALPHA
0084+  13ED             ;; sets ZF according with result
0085+  13ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  13ED             ispath:
0087+  13ED DB          	push al
0088+  13EE 07 B3 13    	call _isdigit
0089+  13F1 C6 1B 14    	je ispath_true
0090+  13F4 B9 5F       	cmp al, '_'
0091+  13F6 C6 1B 14    	je ispath_true
0092+  13F9 B9 2F       	cmp al, '/'
0093+  13FB C6 1B 14    	je ispath_true
0094+  13FE B9 2E       	cmp al, '.'
0095+  1400 C6 1B 14    	je ispath_true
0096+  1403 B9 41       	cmp al, 'A'
0097+  1405 C8 17 14    	jlu ispath_false
0098+  1408 B9 7A       	cmp al, 'z'
0099+  140A D1 17 14    	jgu ispath_false
0100+  140D B9 5A       	cmp al, 'Z'
0101+  140F D0 1B 14    	jleu ispath_true
0102+  1412 B9 61       	cmp al, 'a'
0103+  1414 C9 1B 14    	jgeu ispath_true
0104+  1417             ispath_false:
0105+  1417 8B 01       	or al, 1	; clear ZF
0106+  1419 E8          	pop al
0107+  141A 09          	ret
0108+  141B             ispath_true:
0109+  141B 87 00       	and al, 0	; set ZF
0110+  141D E8          	pop al
0111+  141E 09          	ret
0112+  141F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  141F             ;; IS SPACE
0114+  141F             ;; sets ZF according with result
0115+  141F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  141F             _isspace:
0117+  141F B9 20       	cmp al, $20		; ' '
0118+  1421 C6 35 14    	je _isspace_exit
0119+  1424 B9 09       	cmp al, $09		; '\t'
0120+  1426 C6 35 14    	je _isspace_exit
0121+  1429 B9 0A       	cmp al, $0A		; '\n'
0122+  142B C6 35 14    	je _isspace_exit
0123+  142E B9 0D       	cmp al, $0D		; '\r'
0124+  1430 C6 35 14    	je _isspace_exit
0125+  1433 B9 0B       	cmp al, $0B		; '\v'
0126+  1435             _isspace_exit:
0127+  1435 09          	ret	
0128+  1436             
0129+  1436             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1436             ; TO LOWER
0131+  1436             ; input in AL
0132+  1436             ; output in AL
0133+  1436             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  1436             _to_lower:
0135+  1436 B9 5A       	cmp al, 'Z'
0136+  1438 D1 3D 14    	jgu _to_lower_ret
0137+  143B 6A 20       	add al, $20				; convert to lower case
0138+  143D             _to_lower_ret:
0139+  143D 09          	ret
0140+  143E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  143E             ; TO UPPER
0142+  143E             ; input in AL
0143+  143E             ; output in AL
0144+  143E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  143E             _to_upper:
0146+  143E B9 61       	cmp al, 'a'
0147+  1440 C8 45 14    	jlu _to_upper_ret
0148+  1443 6F 20       	sub al, $20			; convert to upper case
0149+  1445             _to_upper_ret:
0150+  1445 09          	ret
0151+  1446             
2640   1446             .include "lib/token.asm"
0001+  1446             TOKTYP_IDENTIFIER  .equ 0
0002+  1446             TOKTYP_KEYWORD     .equ 1
0003+  1446             TOKTYP_DELIMITER   .equ 2
0004+  1446             TOKTYP_STRING      .equ 3
0005+  1446             TOKTYP_CHAR        .equ 4
0006+  1446             TOKTYP_NUMERIC     .equ 5
0007+  1446             TOKTYP_END         .equ 6
0008+  1446             
0009+  1446             TOK_NULL           .equ 0
0010+  1446             TOK_FSLASH         .equ 1
0011+  1446             TOK_TIMES          .equ 2
0012+  1446             TOK_PLUS           .equ 3
0013+  1446             TOK_MINUS          .equ 4
0014+  1446             TOK_DOT            .equ 5
0015+  1446             TOK_SEMI           .equ 6
0016+  1446             TOK_ANGLE          .equ 7
0017+  1446             TOK_TILDE          .equ 8
0018+  1446             TOK_EQUAL          .equ 9
0019+  1446             TOK_COLON          .equ 10
0020+  1446             TOK_COMMA          .equ 11
0021+  1446             
0022+  1446             TOK_END            .equ 20
0023+  1446             
0024+  1446             
0025+  1446             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1446             ;; read a full command argment from shell input buffer
0027+  1446             ;; argument is written into tokstr
0028+  1446             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1446             get_arg:
0030+  1446 D7            push a
0031+  1447 E2            push si
0032+  1448 E3            push di
0033+  1449 19 00         mov al, 0
0034+  144B 3D 74 16      mov [tokstr], al      ; nullify tokstr string
0035+  144E 14 70 16      mov a, [prog]
0036+  1451 4D            mov si, a
0037+  1452 FD 4F 74 16   mov di, tokstr
0038+  1456             get_arg_skip_spaces:
0039+  1456 F6            lodsb
0040+  1457 07 1F 14      call _isspace
0041+  145A C6 56 14      je get_arg_skip_spaces
0042+  145D             get_arg_L0:
0043+  145D B9 3B         cmp al, $3B        ; check if is ';'
0044+  145F C6 6C 14      je get_arg_end
0045+  1462 B9 00         cmp al, 0
0046+  1464 C6 6C 14      je get_arg_end      ; check if end of input
0047+  1467 F7            stosb
0048+  1468 F6            lodsb
0049+  1469 0A 5D 14      jmp get_arg_L0
0050+  146C             get_arg_end:
0051+  146C 19 00         mov al, 0
0052+  146E F7            stosb
0053+  146F D5 01 00      sub si, 1
0054+  1472 4E            mov a, si
0055+  1473 42 70 16      mov [prog], a    ; update pointer
0056+  1476 F0            pop di
0057+  1477 EF            pop si
0058+  1478 E4            pop a
0059+  1479 09            ret
0060+  147A             
0061+  147A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  147A             ;; read a path formation from shell input buffer
0063+  147A             ;; path is written into tokstr
0064+  147A             ;; /usr/bin
0065+  147A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  147A             get_path:
0067+  147A D7            push a
0068+  147B E2            push si
0069+  147C E3            push di
0070+  147D 19 00         mov al, 0
0071+  147F 3D 74 16      mov [tokstr], al      ; nullify tokstr string
0072+  1482 14 70 16      mov a, [prog]
0073+  1485 4D            mov si, a
0074+  1486 FD 4F 74 16   mov di, tokstr
0075+  148A             get_path_skip_spaces:
0076+  148A F6            lodsb
0077+  148B 07 1F 14      call _isspace
0078+  148E C6 8A 14      je get_path_skip_spaces
0079+  1491             get_path_is_pathchar:
0080+  1491 F7            stosb
0081+  1492 F6            lodsb
0082+  1493 07 A9 13      call _isalnum      ;check if is alphanumeric
0083+  1496 C6 91 14      je get_path_is_pathchar
0084+  1499 B9 2F         cmp al, '/'        ; check if is '/'
0085+  149B C6 91 14      je get_path_is_pathchar
0086+  149E 19 00         mov al, 0
0087+  14A0 F7            stosb
0088+  14A1 D5 01 00      sub si, 1
0089+  14A4 4E            mov a, si
0090+  14A5 42 70 16      mov [prog], a    ; update pointer
0091+  14A8             get_path_end:
0092+  14A8 F0            pop di
0093+  14A9 EF            pop si
0094+  14AA E4            pop a
0095+  14AB 09            ret
0096+  14AC             
0097+  14AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  14AC             ;; read a line
0099+  14AC             ;; line is written into tokstr
0100+  14AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  14AC             get_line:
0102+  14AC D7            push a
0103+  14AD E2            push si
0104+  14AE E3            push di
0105+  14AF 19 00         mov al, 0
0106+  14B1 3D 74 16      mov [tokstr], al      ; nullify tokstr string
0107+  14B4 14 70 16      mov a, [prog]
0108+  14B7 4D            mov si, a
0109+  14B8 FD 4F 74 16   mov di, tokstr
0110+  14BC             get_line_L0:
0111+  14BC F6            lodsb
0112+  14BD B9 0A         cmp al, $0A    ; check for new line
0113+  14BF C6 C6 14      je get_line_exit
0114+  14C2 F7            stosb
0115+  14C3 0A BC 14      jmp get_line_L0
0116+  14C6             get_line_exit:
0117+  14C6 19 00         mov al, 0
0118+  14C8 F7            stosb
0119+  14C9 4E            mov a, si
0120+  14CA 42 70 16      mov [prog], a    ; update pointer
0121+  14CD F0            pop di
0122+  14CE EF            pop si
0123+  14CF E4            pop a
0124+  14D0 09            ret
0125+  14D1             
0126+  14D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  14D1             ;; token parser
0128+  14D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  14D1             get_token:
0130+  14D1 D7            push a
0131+  14D2 DA            push d
0132+  14D3 E2            push si
0133+  14D4 E3            push di
0134+  14D5 19 00         mov al, 0
0135+  14D7 3D 74 16      mov [tokstr], al      ; nullify tokstr string
0136+  14DA 19 00         mov al, TOK_NULL
0137+  14DC 3D 73 16      mov [tok], al        ; nullify token
0138+  14DF 14 70 16      mov a, [prog]
0139+  14E2 4D            mov si, a
0140+  14E3 FD 4F 74 16   mov di, tokstr
0141+  14E7             get_tok_skip_spaces:
0142+  14E7 F6            lodsb
0143+  14E8 07 1F 14      call _isspace
0144+  14EB C6 E7 14      je get_tok_skip_spaces
0145+  14EE B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  14F0 C6 D5 15      je get_token_end
0147+  14F3 B9 23         cmp al, '#'      ; comments!
0148+  14F5 C6 03 16      je get_tok_comment
0149+  14F8 07 A9 13      call _isalnum
0150+  14FB C6 E2 15      jz is_alphanumeric
0151+  14FE             ; other token types
0152+  14FE             get_token_slash:
0153+  14FE B9 2F         cmp al, '/'        ; check if '/'
0154+  1500 C7 18 15      jne get_token_minus
0155+  1503 F7            stosb          ; store '/' into token string
0156+  1504 19 00         mov al, 0
0157+  1506 F7            stosb          ; terminate token string
0158+  1507 19 01         mov al, TOK_FSLASH
0159+  1509 3D 73 16      mov [tok], al      
0160+  150C 19 02         mov al, TOKTYP_DELIMITER
0161+  150E 3D 72 16      mov [toktyp], al
0162+  1511 4E            mov a, si
0163+  1512 42 70 16      mov [prog], a    ; update pointer
0164+  1515 0A FE 15      jmp get_token_return
0165+  1518             get_token_minus:
0166+  1518 B9 2D         cmp al, '-'        ; check if '-'
0167+  151A C7 32 15      jne get_token_comma
0168+  151D F7            stosb          ; store '-' into token string
0169+  151E 19 00         mov al, 0
0170+  1520 F7            stosb          ; terminate token string
0171+  1521 19 04         mov al, TOK_MINUS
0172+  1523 3D 73 16      mov [tok], al      
0173+  1526 19 02         mov al, TOKTYP_DELIMITER
0174+  1528 3D 72 16      mov [toktyp], al
0175+  152B 4E            mov a, si
0176+  152C 42 70 16      mov [prog], a    ; update pointer
0177+  152F 0A FE 15      jmp get_token_return
0178+  1532             get_token_comma:
0179+  1532 B9 2C         cmp al, ','        ; check if ','
0180+  1534 C7 4C 15      jne get_token_semi
0181+  1537 F7            stosb          ; store ',' into token string
0182+  1538 19 00         mov al, 0
0183+  153A F7            stosb          ; terminate token string
0184+  153B 19 0B         mov al, TOK_COMMA
0185+  153D 3D 73 16      mov [tok], al      
0186+  1540 19 02         mov al, TOKTYP_DELIMITER
0187+  1542 3D 72 16      mov [toktyp], al
0188+  1545 4E            mov a, si
0189+  1546 42 70 16      mov [prog], a    ; update pointer
0190+  1549 0A FE 15      jmp get_token_return
0191+  154C             get_token_semi:
0192+  154C B9 3B         cmp al, $3B        ; check if ';'
0193+  154E C7 66 15      jne get_token_colon
0194+  1551 F7            stosb          ; store ';' into token string
0195+  1552 19 00         mov al, 0
0196+  1554 F7            stosb          ; terminate token string
0197+  1555 19 06         mov al, TOK_SEMI
0198+  1557 3D 73 16      mov [tok], al      
0199+  155A 19 02         mov al, TOKTYP_DELIMITER
0200+  155C 3D 72 16      mov [toktyp], al
0201+  155F 4E            mov a, si
0202+  1560 42 70 16      mov [prog], a    ; update pointer
0203+  1563 0A FE 15      jmp get_token_return
0204+  1566             get_token_colon:
0205+  1566 B9 3A         cmp al, $3A        ; check if ':'
0206+  1568 C7 80 15      jne get_token_angle
0207+  156B F7            stosb          ; store ':' into token string
0208+  156C 19 00         mov al, 0
0209+  156E F7            stosb          ; terminate token string
0210+  156F 19 0A         mov al, TOK_COLON
0211+  1571 3D 73 16      mov [tok], al      
0212+  1574 19 02         mov al, TOKTYP_DELIMITER
0213+  1576 3D 72 16      mov [toktyp], al
0214+  1579 4E            mov a, si
0215+  157A 42 70 16      mov [prog], a    ; update pointer
0216+  157D 0A FE 15      jmp get_token_return
0217+  1580             get_token_angle:
0218+  1580 B9 3E         cmp al, $3E        ; check if '>'
0219+  1582 C7 9A 15      jne get_token_tilde
0220+  1585 F7            stosb          ; store '>' into token string
0221+  1586 19 00         mov al, 0
0222+  1588 F7            stosb          ; terminate token string
0223+  1589 19 07         mov al, TOK_ANGLE
0224+  158B 3D 73 16      mov [tok], al      
0225+  158E 19 02         mov al, TOKTYP_DELIMITER
0226+  1590 3D 72 16      mov [toktyp], al
0227+  1593 4E            mov a, si
0228+  1594 42 70 16      mov [prog], a    ; update pointer
0229+  1597 0A FE 15      jmp get_token_return
0230+  159A             get_token_tilde:
0231+  159A B9 7E         cmp al, '~'        ; check if '~'
0232+  159C C7 B4 15      jne get_token_equal
0233+  159F F7            stosb          ; store '~' into token string
0234+  15A0 19 00         mov al, 0
0235+  15A2 F7            stosb          ; terminate token string
0236+  15A3 19 08         mov al, TOK_TILDE
0237+  15A5 3D 73 16      mov [tok], al      
0238+  15A8 19 02         mov al, TOKTYP_DELIMITER
0239+  15AA 3D 72 16      mov [toktyp], al
0240+  15AD 4E            mov a, si
0241+  15AE 42 70 16      mov [prog], a    ; update pointer
0242+  15B1 0A FE 15      jmp get_token_return
0243+  15B4             get_token_equal:
0244+  15B4 B9 3D         cmp al, '='        ; check if '='
0245+  15B6 C7 CE 15      jne get_token_skip
0246+  15B9 F7            stosb          ; store '=' into token string
0247+  15BA 19 00         mov al, 0
0248+  15BC F7            stosb          ; terminate token string
0249+  15BD 19 09         mov al, TOK_EQUAL
0250+  15BF 3D 73 16      mov [tok], al      
0251+  15C2 19 02         mov al, TOKTYP_DELIMITER
0252+  15C4 3D 72 16      mov [toktyp], al
0253+  15C7 4E            mov a, si
0254+  15C8 42 70 16      mov [prog], a    ; update pointer
0255+  15CB 0A FE 15      jmp get_token_return
0256+  15CE             get_token_skip:
0257+  15CE 4E            mov a, si
0258+  15CF 42 70 16      mov [prog], a    ; update pointer
0259+  15D2 0A FE 15      jmp get_token_return
0260+  15D5             get_token_end:        ; end of file token
0261+  15D5 19 14         mov al, TOK_END
0262+  15D7 3D 73 16      mov [tok], al
0263+  15DA 19 06         mov al, TOKTYP_END
0264+  15DC 3D 72 16      mov [toktyp], al
0265+  15DF 0A FE 15      jmp get_token_return
0266+  15E2             is_alphanumeric:
0267+  15E2 F7            stosb
0268+  15E3 F6            lodsb
0269+  15E4 07 A9 13      call _isalnum      ;check if is alphanumeric
0270+  15E7 C6 E2 15      jz is_alphanumeric
0271+  15EA B9 2E         cmp al, $2E        ; check if is '.'
0272+  15EC C6 E2 15      je is_alphanumeric
0273+  15EF 19 00         mov al, 0
0274+  15F1 F7            stosb
0275+  15F2 19 00         mov al, TOKTYP_IDENTIFIER
0276+  15F4 3D 72 16      mov [toktyp], al
0277+  15F7 D5 01 00      sub si, 1
0278+  15FA 4E            mov a, si
0279+  15FB 42 70 16      mov [prog], a    ; update pointer
0280+  15FE             get_token_return:
0281+  15FE F0            pop di
0282+  15FF EF            pop si
0283+  1600 E7            pop d
0284+  1601 E4            pop a
0285+  1602 09            ret
0286+  1603             get_tok_comment:
0287+  1603 F6            lodsb
0288+  1604 B9 0A         cmp al, $0A      ; new line
0289+  1606 C7 03 16      jne get_tok_comment
0290+  1609 0A E7 14      jmp get_tok_skip_spaces
0291+  160C             
0292+  160C             
0293+  160C             get_number:
0294+  160C D7            push a
0295+  160D DA            push d
0296+  160E E2            push si
0297+  160F E3            push di
0298+  1610 19 00         mov al, 0
0299+  1612 3D 74 16      mov [tokstr], al      ; nullify tokstr string
0300+  1615 19 00         mov al, TOK_NULL
0301+  1617 3D 73 16      mov [tok], al        ; nullify token
0302+  161A 14 70 16      mov a, [prog]
0303+  161D 4D            mov si, a
0304+  161E FD 4F 74 16   mov di, tokstr
0305+  1622             get_number_skip_spaces:
0306+  1622 F6            lodsb
0307+  1623 07 1F 14      call _isspace
0308+  1626 C6 22 16      je get_number_skip_spaces
0309+  1629 B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  162B C7 3B 16      jne get_number_L0
0311+  162E 19 14         mov al, TOK_END
0312+  1630 3D 73 16      mov [tok], al
0313+  1633 19 06         mov al, TOKTYP_END
0314+  1635 3D 72 16      mov [toktyp], al
0315+  1638 0A 52 16      jmp get_number_return
0316+  163B             get_number_L0:
0317+  163B F7            stosb
0318+  163C F6            lodsb
0319+  163D 07 B3 13      call _isdigit      ;check if is numeric
0320+  1640 C6 3B 16      jz get_number_L0
0321+  1643 19 00         mov al, 0
0322+  1645 F7            stosb
0323+  1646 19 05         mov al, TOKTYP_NUMERIC
0324+  1648 3D 72 16      mov [toktyp], al
0325+  164B D5 01 00      sub si, 1
0326+  164E 4E            mov a, si
0327+  164F 42 70 16      mov [prog], a    ; update pointer
0328+  1652             get_number_return:
0329+  1652 F0            pop di
0330+  1653 EF            pop si
0331+  1654 E7            pop d
0332+  1655 E4            pop a
0333+  1656 09            ret
0334+  1657             
0335+  1657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1657             ;; PUT BACK TOKEN
0337+  1657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  1657             _putback:
0339+  1657 D7            push a
0340+  1658 E2            push si
0341+  1659 FD 4D 74 16   mov si, tokstr  
0342+  165D             _putback_loop:
0343+  165D F6            lodsb
0344+  165E B9 00         cmp al, 0
0345+  1660 C6 6D 16      je _putback_end
0346+  1663 14 70 16      mov a, [prog]
0347+  1666 7D            dec a
0348+  1667 42 70 16      mov [prog], a      ; update pointer
0349+  166A 0A 5D 16      jmp _putback_loop
0350+  166D             _putback_end:
0351+  166D EF            pop si
0352+  166E E4            pop a
0353+  166F 09            ret
0354+  1670             
0355+  1670             
0356+  1670             
0357+  1670             
0358+  1670 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1672             
0360+  1672 00          toktyp:    .db 0          ; token type symbol
0361+  1673 00          tok:       .db 0          ; current token symbol
0362+  1674 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  1678 00 00 00 00 
0362+  167C 00 00 00 00 
0362+  1680 00 00 00 00 
0362+  1684 00 00 00 00 
0362+  1688 00 00 00 00 
0362+  168C 00 00 00 00 
0362+  1690 00 00 00 00 
0362+  1694 00 00 00 00 
0362+  1698 00 00 00 00 
0362+  169C 00 00 00 00 
0362+  16A0 00 00 00 00 
0362+  16A4 00 00 00 00 
0362+  16A8 00 00 00 00 
0362+  16AC 00 00 00 00 
0362+  16B0 00 00 00 00 
0362+  16B4 00 00 00 00 
0362+  16B8 00 00 00 00 
0362+  16BC 00 00 00 00 
0362+  16C0 00 00 00 00 
0362+  16C4 00 00 00 00 
0362+  16C8 00 00 00 00 
0362+  16CC 00 00 00 00 
0362+  16D0 00 00 00 00 
0362+  16D4 00 00 00 00 
0362+  16D8 00 00 00 00 
0362+  16DC 00 00 00 00 
0362+  16E0 00 00 00 00 
0362+  16E4 00 00 00 00 
0362+  16E8 00 00 00 00 
0362+  16EC 00 00 00 00 
0362+  16F0 00 00 00 00 
0362+  16F4 00 00 00 00 
0362+  16F8 00 00 00 00 
0362+  16FC 00 00 00 00 
0362+  1700 00 00 00 00 
0362+  1704 00 00 00 00 
0362+  1708 00 00 00 00 
0362+  170C 00 00 00 00 
0362+  1710 00 00 00 00 
0362+  1714 00 00 00 00 
0362+  1718 00 00 00 00 
0362+  171C 00 00 00 00 
0362+  1720 00 00 00 00 
0362+  1724 00 00 00 00 
0362+  1728 00 00 00 00 
0362+  172C 00 00 00 00 
0362+  1730 00 00 00 00 
0362+  1734 00 00 00 00 
0362+  1738 00 00 00 00 
0362+  173C 00 00 00 00 
0362+  1740 00 00 00 00 
0362+  1744 00 00 00 00 
0362+  1748 00 00 00 00 
0362+  174C 00 00 00 00 
0362+  1750 00 00 00 00 
0362+  1754 00 00 00 00 
0362+  1758 00 00 00 00 
0362+  175C 00 00 00 00 
0362+  1760 00 00 00 00 
0362+  1764 00 00 00 00 
0362+  1768 00 00 00 00 
0362+  176C 00 00 00 00 
0362+  1770 00 00 00 00 
2641   1774             
2642   1774             ; kernel parameters
2643   1774 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2644   1775 01          sys_echo_on:        .db 1
2645   1776 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2646   1777 01          sys_uart0_inten:    .db 1
2647   1778 00          sys_uart0_fifoen:   .db 0
2648   1779 0C          sys_uart0_div0:     .db 12  ;
2649   177A 00          sys_uart0_div1:     .db 0   ; default baud = 9600
2650   177B             ; Baud  Divisor
2651   177B             ; 50    2304
2652   177B             ; 110   1047
2653   177B             ; 300    384
2654   177B             ; 600    192
2655   177B             ; 1200    96
2656   177B             ; 9600    12
2657   177B             ; 19200    6
2658   177B             ; 38400    3
2659   177B             
2660   177B 00          nbr_active_procs:   .db 0
2661   177C 01          active_proc_index:  .db 1
2662   177D             
2663   177D 00 00       index:              .dw 0
2664   177F 00 00       buffer_addr:        .dw 0
2665   1781             
2666   1781 C2 20       fifo_in:            .dw fifo
2667   1783 C2 20       fifo_out:           .dw fifo
2668   1785             
2669   1785             ; file system variables
2670   1785 00 00       current_dir_id:     .dw 0     ; keep dirID of current directory
2671   1787 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2671   178B 6E 2F 69 6E 
2671   178F 69 74 00 
2672   1792             
2673   1792 3E 20 00    s_dataentry:        .db "> ", 0
2674   1795 2E 2E 00    s_parent_dir:       .db "..", 0
2675   1798 2E 00       s_current_dir:      .db ".", 0
2676   179A 2F 00       s_fslash:           .db "/", 0
2677   179C 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2677   17A0 78 
2678   17A1 2D 64 63    file_type:          .db "-dc"
2679   17A4 50 49 44 20 s_ps_header:        .db "PID COMMAND\n", 0
2679   17A8 43 4F 4D 4D 
2679   17AC 41 4E 44 0A 
2679   17B0 00 
2680   17B1 54 6F 74 61 s_ls_total:         .db "Total: ", 0
2680   17B5 6C 3A 20 00 
2681   17B9             
2682   17B9 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2682   17BD 20 65 6E 61 
2682   17C1 62 6C 65 64 
2682   17C5 0A 00 
2683   17C7 6B 65 72 6E s_kernel_started:   .db "kernel started(version 1.0)\n", 0
2683   17CB 65 6C 20 73 
2683   17CF 74 61 72 74 
2683   17D3 65 64 28 76 
2683   17D7 65 72 73 69 
2683   17DB 6F 6E 20 31 
2683   17DF 2E 30 29 0A 
2683   17E3 00 
2684   17E4 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2684   17E8 74 69 6E 67 
2684   17EC 20 69 6E 69 
2684   17F0 74 0A 00 
2685   17F3 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2685   17F7 65 70 74 69 
2685   17FB 6F 6E 3A 20 
2685   17FF 70 72 69 76 
2685   1803 69 6C 65 67 
2685   1807 65 0A 00 
2686   180A 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2686   180E 65 70 74 69 
2686   1812 6F 6E 3A 20 
2686   1816 7A 65 72 6F 
2686   181A 20 64 69 76 
2686   181E 69 73 69 6F 
2686   1822 6E 0A 00 
2687   1825             
2688   1825 59 65 61 72 s_set_year:         .db "Year: ", 0
2688   1829 3A 20 00 
2689   182C 4D 6F 6E 74 s_set_month:        .db "Month: ", 0
2689   1830 68 3A 20 00 
2690   1834 44 61 79 3A s_set_day:          .db "Day: ", 0
2690   1838 20 00 
2691   183A 57 65 65 6B s_set_week:         .db "Weekday: ", 0
2691   183E 64 61 79 3A 
2691   1842 20 00 
2692   1844 48 6F 75 72 s_set_hours:        .db "Hours: ", 0
2692   1848 73 3A 20 00 
2693   184C 4D 69 6E 75 s_set_minutes:      .db "Minutes: ", 0
2693   1850 74 65 73 3A 
2693   1854 20 00 
2694   1856 53 65 63 6F s_set_seconds:      .db "Seconds: ", 0
2694   185A 6E 64 73 3A 
2694   185E 20 00 
2695   1860             s_months:      
2696   1860 20 20 20 00   .db "   ", 0
2697   1864 4A 61 6E 00   .db "Jan", 0
2698   1868 46 65 62 00   .db "Feb", 0
2699   186C 4D 61 72 00   .db "Mar", 0
2700   1870 41 70 72 00   .db "Apr", 0
2701   1874 4D 61 79 00   .db "May", 0
2702   1878 4A 75 6E 00   .db "Jun", 0
2703   187C 4A 75 6C 00   .db "Jul", 0
2704   1880 41 75 67 00   .db "Aug", 0
2705   1884 53 65 70 00   .db "Sep", 0
2706   1888 4F 63 74 00   .db "Oct", 0
2707   188C 4E 6F 76 00   .db "Nov", 0
2708   1890 44 65 63 00   .db "Dec", 0
2709   1894             
2710   1894             s_week:        
2711   1894 53 75 6E 00   .db "Sun", 0 
2712   1898 4D 6F 6E 00   .db "Mon", 0 
2713   189C 54 75 65 00   .db "Tue", 0 
2714   18A0 57 65 64 00   .db "Wed", 0 
2715   18A4 54 68 75 00   .db "Thu", 0 
2716   18A8 46 72 69 00   .db "Fri", 0 
2717   18AC 53 61 74 00   .db "Sat", 0
2718   18B0             
2719   18B0             ; This is the format of a sector for the 128 byte per sector format.
2720   18B0             ; Write the bracketed data 16 times per track.
2721   18B0             ; The recommended single-density format with 128
2722   18B0             ; bytes/sector is shown. In order to format a diskette,
2723   18B0             ; the user issues the Write Track Command, and loads
2724   18B0             ; the Data Register with the following values. For every
2725   18B0             ; byte to be written, there is one Data Request.
2726   18B0             fdc_128_bytes_per_sect:                                                                       
2727   18B0 FF FF FF FF fdc_40_FF:     .fill 40,  $FF  ; or 00                                                                                
2727   18B4 FF FF FF FF 
2727   18B8 FF FF FF FF 
2727   18BC FF FF FF FF 
2727   18C0 FF FF FF FF 
2727   18C4 FF FF FF FF 
2727   18C8 FF FF FF FF 
2727   18CC FF FF FF FF 
2727   18D0 FF FF FF FF 
2727   18D4 FF FF FF FF 
2728   18D8 00 00 00 00 fdc_6_00_0:    .fill 6,   $00  ;                                                                            <--|        
2728   18DC 00 00 
2729   18DE FE          fdc_id_fe:     .fill 1,   $FE  ; ID Address Mark                                                               |        
2730   18DF 00          fdc_track:     .fill 1,   $00  ; Track Number                                                                  |                    
2731   18E0 00          fdc_side:      .fill 1,   $00  ; Side Number 00 or 01                                                          |                
2732   18E1 01          fdc_sector:    .fill 1,   $01  ; Sector Number  1 through 10                                                   |                              
2733   18E2 00          fdc_length:    .fill 1,   $00  ; Sector Length                                                                 |                        
2734   18E3 F7          fdc_2_crc_0:   .fill 1,   $F7  ; 2 CRC's Written                                                               | Write 16 times                 
2735   18E4 FF FF FF FF fdc_11_ff:     .fill 11,  $FF  ; or 00                                                                         |                      
2735   18E8 FF FF FF FF 
2735   18EC FF FF FF 
2736   18EF 00 00 00 00 fdc_6_00_1:    .fill 6,   $00  ;                                                                               |                        
2736   18F3 00 00 
2737   18F5 FB          fdc_data_addr: .fill 1,   $FB  ; Data Address Mark                                                             |                                  
2738   18F6 E5 E5 E5 E5 fdc_data:      .fill 128, $E5  ; Data (IBM uses E5)                                                            |                                      
2738   18FA E5 E5 E5 E5 
2738   18FE E5 E5 E5 E5 
2738   1902 E5 E5 E5 E5 
2738   1906 E5 E5 E5 E5 
2738   190A E5 E5 E5 E5 
2738   190E E5 E5 E5 E5 
2738   1912 E5 E5 E5 E5 
2738   1916 E5 E5 E5 E5 
2738   191A E5 E5 E5 E5 
2738   191E E5 E5 E5 E5 
2738   1922 E5 E5 E5 E5 
2738   1926 E5 E5 E5 E5 
2738   192A E5 E5 E5 E5 
2738   192E E5 E5 E5 E5 
2738   1932 E5 E5 E5 E5 
2738   1936 E5 E5 E5 E5 
2738   193A E5 E5 E5 E5 
2738   193E E5 E5 E5 E5 
2738   1942 E5 E5 E5 E5 
2738   1946 E5 E5 E5 E5 
2738   194A E5 E5 E5 E5 
2738   194E E5 E5 E5 E5 
2738   1952 E5 E5 E5 E5 
2738   1956 E5 E5 E5 E5 
2738   195A E5 E5 E5 E5 
2738   195E E5 E5 E5 E5 
2738   1962 E5 E5 E5 E5 
2738   1966 E5 E5 E5 E5 
2738   196A E5 E5 E5 E5 
2738   196E E5 E5 E5 E5 
2738   1972 E5 E5 E5 E5 
2739   1976 F7          fdc_2_crc_1:   .fill 1,   $F7  ; 2 CRC's Written                                                               |                                                        
2740   1977 FF FF FF FF fdc_10_ff:     .fill 10,  $FF  ; or 00                                                                      <--|                                                  
2740   197B FF FF FF FF 
2740   197F FF FF 
2741   1981 FF FF FF FF fdc_369_ff:    .fill 369, $FF  ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
2741   1985 FF FF FF FF 
2741   1989 FF FF FF FF 
2741   198D FF FF FF FF 
2741   1991 FF FF FF FF 
2741   1995 FF FF FF FF 
2741   1999 FF FF FF FF 
2741   199D FF FF FF FF 
2741   19A1 FF FF FF FF 
2741   19A5 FF FF FF FF 
2741   19A9 FF FF FF FF 
2741   19AD FF FF FF FF 
2741   19B1 FF FF FF FF 
2741   19B5 FF FF FF FF 
2741   19B9 FF FF FF FF 
2741   19BD FF FF FF FF 
2741   19C1 FF FF FF FF 
2741   19C5 FF FF FF FF 
2741   19C9 FF FF FF FF 
2741   19CD FF FF FF FF 
2741   19D1 FF FF FF FF 
2741   19D5 FF FF FF FF 
2741   19D9 FF FF FF FF 
2741   19DD FF FF FF FF 
2741   19E1 FF FF FF FF 
2741   19E5 FF FF FF FF 
2741   19E9 FF FF FF FF 
2741   19ED FF FF FF FF 
2741   19F1 FF FF FF FF 
2741   19F5 FF FF FF FF 
2741   19F9 FF FF FF FF 
2741   19FD FF FF FF FF 
2741   1A01 FF FF FF FF 
2741   1A05 FF FF FF FF 
2741   1A09 FF FF FF FF 
2741   1A0D FF FF FF FF 
2741   1A11 FF FF FF FF 
2741   1A15 FF FF FF FF 
2741   1A19 FF FF FF FF 
2741   1A1D FF FF FF FF 
2741   1A21 FF FF FF FF 
2741   1A25 FF FF FF FF 
2741   1A29 FF FF FF FF 
2741   1A2D FF FF FF FF 
2741   1A31 FF FF FF FF 
2741   1A35 FF FF FF FF 
2741   1A39 FF FF FF FF 
2741   1A3D FF FF FF FF 
2741   1A41 FF FF FF FF 
2741   1A45 FF FF FF FF 
2741   1A49 FF FF FF FF 
2741   1A4D FF FF FF FF 
2741   1A51 FF FF FF FF 
2741   1A55 FF FF FF FF 
2741   1A59 FF FF FF FF 
2741   1A5D FF FF FF FF 
2741   1A61 FF FF FF FF 
2741   1A65 FF FF FF FF 
2741   1A69 FF FF FF FF 
2741   1A6D FF FF FF FF 
2741   1A71 FF FF FF FF 
2741   1A75 FF FF FF FF 
2741   1A79 FF FF FF FF 
2741   1A7D FF FF FF FF 
2741   1A81 FF FF FF FF 
2741   1A85 FF FF FF FF 
2741   1A89 FF FF FF FF 
2741   1A8D FF FF FF FF 
2741   1A91 FF FF FF FF 
2741   1A95 FF FF FF FF 
2741   1A99 FF FF FF FF 
2741   1A9D FF FF FF FF 
2741   1AA1 FF FF FF FF 
2741   1AA5 FF FF FF FF 
2741   1AA9 FF FF FF FF 
2741   1AAD FF FF FF FF 
2741   1AB1 FF FF FF FF 
2741   1AB5 FF FF FF FF 
2741   1AB9 FF FF FF FF 
2741   1ABD FF FF FF FF 
2741   1AC1 FF FF FF FF 
2741   1AC5 FF FF FF FF 
2741   1AC9 FF FF FF FF 
2741   1ACD FF FF FF FF 
2741   1AD1 FF FF FF FF 
2741   1AD5 FF FF FF FF 
2741   1AD9 FF FF FF FF 
2741   1ADD FF FF FF FF 
2741   1AE1 FF FF FF FF 
2741   1AE5 FF FF FF FF 
2741   1AE9 FF FF FF FF 
2741   1AED FF FF FF FF 
2741   1AF1 FF 
2742   1AF2             
2743   1AF2 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2743   1AF6 00 00 00 00 
2743   1AFA 00 00 00 00 
2743   1AFE 00 00 00 00 
2743   1B02 00 00 00 00 
2743   1B06 00 00 00 00 
2743   1B0A 00 00 00 00 
2743   1B0E 00 00 00 00 
2743   1B12 00 00 00 00 
2743   1B16 00 00 00 00 
2743   1B1A 00 00 00 00 
2743   1B1E 00 00 00 00 
2743   1B22 00 00 00 00 
2743   1B26 00 00 00 00 
2743   1B2A 00 00 00 00 
2743   1B2E 00 00 00 00 
2743   1B32 00 00 00 00 
2743   1B36 00 00 00 00 
2743   1B3A 00 00 00 00 
2743   1B3E 00 00 00 00 
2743   1B42 00 00 00 00 
2743   1B46 00 00 00 00 
2743   1B4A 00 00 00 00 
2743   1B4E 00 00 00 00 
2743   1B52 00 00 00 00 
2743   1B56 00 00 00 00 
2743   1B5A 00 00 00 00 
2743   1B5E 00 00 00 00 
2743   1B62 00 00 00 00 
2743   1B66 00 00 00 00 
2743   1B6A 00 00 00 00 
2743   1B6E 00 00 00 00 
2743   1B72 00 00 00 00 
2743   1B76 00 00 00 00 
2743   1B7A 00 00 00 00 
2743   1B7E 00 00 00 00 
2743   1B82 00 00 00 00 
2743   1B86 00 00 00 00 
2743   1B8A 00 00 00 00 
2743   1B8E 00 00 00 00 
2743   1B92 00 00 00 00 
2743   1B96 00 00 00 00 
2743   1B9A 00 00 00 00 
2743   1B9E 00 00 00 00 
2743   1BA2 00 00 00 00 
2743   1BA6 00 00 00 00 
2743   1BAA 00 00 00 00 
2743   1BAE 00 00 00 00 
2743   1BB2 00 00 00 00 
2743   1BB6 00 00 00 00 
2743   1BBA 00 00 00 00 
2743   1BBE 00 00 00 00 
2743   1BC2 00 00 00 00 
2743   1BC6 00 00 00 00 
2743   1BCA 00 00 00 00 
2743   1BCE 00 00 00 00 
2743   1BD2 00 00 00 00 
2743   1BD6 00 00 00 00 
2743   1BDA 00 00 00 00 
2743   1BDE 00 00 00 00 
2743   1BE2 00 00 00 00 
2743   1BE6 00 00 00 00 
2743   1BEA 00 00 00 00 
2743   1BEE 00 00 00 00 
2743   1BF2 00 00 00 00 
2743   1BF6 00 00 00 00 
2743   1BFA 00 00 00 00 
2743   1BFE 00 00 00 00 
2743   1C02 00 00 00 00 
2743   1C06 00 00 00 00 
2743   1C0A 00 00 00 00 
2743   1C0E 00 00 00 00 
2743   1C12 00 00 00 00 
2743   1C16 00 00 00 00 
2743   1C1A 00 00 00 00 
2743   1C1E 00 00 00 00 
2743   1C22 00 00 00 00 
2743   1C26 00 00 00 00 
2743   1C2A 00 00 00 00 
2743   1C2E 00 00 00 00 
2744   1C32 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2744   1C36 00 00 00 00 
2744   1C3A 00 00 00 00 
2744   1C3E 00 00 00 00 
2745   1C42 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2745   1C46 00 00 00 00 
2745   1C4A 00 00 00 00 
2745   1C4E 00 00 00 00 
2745   1C52 00 00 00 00 
2745   1C56 00 00 00 00 
2745   1C5A 00 00 00 00 
2745   1C5E 00 00 00 00 
2745   1C62 00 00 00 00 
2745   1C66 00 00 00 00 
2745   1C6A 00 00 00 00 
2745   1C6E 00 00 00 00 
2745   1C72 00 00 00 00 
2745   1C76 00 00 00 00 
2745   1C7A 00 00 00 00 
2745   1C7E 00 00 00 00 
2745   1C82 00 00 00 00 
2745   1C86 00 00 00 00 
2745   1C8A 00 00 00 00 
2745   1C8E 00 00 00 00 
2745   1C92 00 00 00 00 
2745   1C96 00 00 00 00 
2745   1C9A 00 00 00 00 
2745   1C9E 00 00 00 00 
2745   1CA2 00 00 00 00 
2745   1CA6 00 00 00 00 
2745   1CAA 00 00 00 00 
2745   1CAE 00 00 00 00 
2745   1CB2 00 00 00 00 
2745   1CB6 00 00 00 00 
2745   1CBA 00 00 00 00 
2745   1CBE 00 00 00 00 
2745   1CC2 00 00 00 00 
2745   1CC6 00 00 00 00 
2745   1CCA 00 00 00 00 
2745   1CCE 00 00 00 00 
2745   1CD2 00 00 00 00 
2745   1CD6 00 00 00 00 
2745   1CDA 00 00 00 00 
2745   1CDE 00 00 00 00 
2745   1CE2 00 00 00 00 
2745   1CE6 00 00 00 00 
2745   1CEA 00 00 00 00 
2745   1CEE 00 00 00 00 
2745   1CF2 00 00 00 00 
2745   1CF6 00 00 00 00 
2745   1CFA 00 00 00 00 
2745   1CFE 00 00 00 00 
2745   1D02 00 00 00 00 
2745   1D06 00 00 00 00 
2745   1D0A 00 00 00 00 
2745   1D0E 00 00 00 00 
2745   1D12 00 00 00 00 
2745   1D16 00 00 00 00 
2745   1D1A 00 00 00 00 
2745   1D1E 00 00 00 00 
2745   1D22 00 00 00 00 
2745   1D26 00 00 00 00 
2745   1D2A 00 00 00 00 
2745   1D2E 00 00 00 00 
2745   1D32 00 00 00 00 
2745   1D36 00 00 00 00 
2745   1D3A 00 00 00 00 
2745   1D3E 00 00 00 00 
2745   1D42 00 00 00 00 
2745   1D46 00 00 00 00 
2745   1D4A 00 00 00 00 
2745   1D4E 00 00 00 00 
2745   1D52 00 00 00 00 
2745   1D56 00 00 00 00 
2745   1D5A 00 00 00 00 
2745   1D5E 00 00 00 00 
2745   1D62 00 00 00 00 
2745   1D66 00 00 00 00 
2745   1D6A 00 00 00 00 
2745   1D6E 00 00 00 00 
2745   1D72 00 00 00 00 
2745   1D76 00 00 00 00 
2745   1D7A 00 00 00 00 
2745   1D7E 00 00 00 00 
2745   1D82 00 00 00 00 
2745   1D86 00 00 00 00 
2745   1D8A 00 00 00 00 
2745   1D8E 00 00 00 00 
2745   1D92 00 00 00 00 
2745   1D96 00 00 00 00 
2745   1D9A 00 00 00 00 
2745   1D9E 00 00 00 00 
2745   1DA2 00 00 00 00 
2745   1DA6 00 00 00 00 
2745   1DAA 00 00 00 00 
2745   1DAE 00 00 00 00 
2745   1DB2 00 00 00 00 
2745   1DB6 00 00 00 00 
2745   1DBA 00 00 00 00 
2745   1DBE 00 00 00 00 
2745   1DC2 00 00 00 00 
2745   1DC6 00 00 00 00 
2745   1DCA 00 00 00 00 
2745   1DCE 00 00 00 00 
2745   1DD2 00 00 00 00 
2745   1DD6 00 00 00 00 
2745   1DDA 00 00 00 00 
2745   1DDE 00 00 00 00 
2745   1DE2 00 00 00 00 
2745   1DE6 00 00 00 00 
2745   1DEA 00 00 00 00 
2745   1DEE 00 00 00 00 
2745   1DF2 00 00 00 00 
2745   1DF6 00 00 00 00 
2745   1DFA 00 00 00 00 
2745   1DFE 00 00 00 00 
2745   1E02 00 00 00 00 
2745   1E06 00 00 00 00 
2745   1E0A 00 00 00 00 
2745   1E0E 00 00 00 00 
2745   1E12 00 00 00 00 
2745   1E16 00 00 00 00 
2745   1E1A 00 00 00 00 
2745   1E1E 00 00 00 00 
2745   1E22 00 00 00 00 
2745   1E26 00 00 00 00 
2745   1E2A 00 00 00 00 
2745   1E2E 00 00 00 00 
2745   1E32 00 00 00 00 
2745   1E36 00 00 00 00 
2745   1E3A 00 00 00 00 
2745   1E3E 00 00 00 00 
2746   1E42 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2746   1E46 00 00 00 00 
2746   1E4A 00 00 00 00 
2746   1E4E 00 00 00 00 
2746   1E52 00 00 00 00 
2746   1E56 00 00 00 00 
2746   1E5A 00 00 00 00 
2746   1E5E 00 00 00 00 
2746   1E62 00 00 00 00 
2746   1E66 00 00 00 00 
2746   1E6A 00 00 00 00 
2746   1E6E 00 00 00 00 
2746   1E72 00 00 00 00 
2746   1E76 00 00 00 00 
2746   1E7A 00 00 00 00 
2746   1E7E 00 00 00 00 
2746   1E82 00 00 00 00 
2746   1E86 00 00 00 00 
2746   1E8A 00 00 00 00 
2746   1E8E 00 00 00 00 
2746   1E92 00 00 00 00 
2746   1E96 00 00 00 00 
2746   1E9A 00 00 00 00 
2746   1E9E 00 00 00 00 
2746   1EA2 00 00 00 00 
2746   1EA6 00 00 00 00 
2746   1EAA 00 00 00 00 
2746   1EAE 00 00 00 00 
2746   1EB2 00 00 00 00 
2746   1EB6 00 00 00 00 
2746   1EBA 00 00 00 00 
2746   1EBE 00 00 00 00 
2747   1EC2 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2747   1EC6 00 00 00 00 
2747   1ECA 00 00 00 00 
2747   1ECE 00 00 00 00 
2747   1ED2 00 00 00 00 
2747   1ED6 00 00 00 00 
2747   1EDA 00 00 00 00 
2747   1EDE 00 00 00 00 
2747   1EE2 00 00 00 00 
2747   1EE6 00 00 00 00 
2747   1EEA 00 00 00 00 
2747   1EEE 00 00 00 00 
2747   1EF2 00 00 00 00 
2747   1EF6 00 00 00 00 
2747   1EFA 00 00 00 00 
2747   1EFE 00 00 00 00 
2747   1F02 00 00 00 00 
2747   1F06 00 00 00 00 
2747   1F0A 00 00 00 00 
2747   1F0E 00 00 00 00 
2747   1F12 00 00 00 00 
2747   1F16 00 00 00 00 
2747   1F1A 00 00 00 00 
2747   1F1E 00 00 00 00 
2747   1F22 00 00 00 00 
2747   1F26 00 00 00 00 
2747   1F2A 00 00 00 00 
2747   1F2E 00 00 00 00 
2747   1F32 00 00 00 00 
2747   1F36 00 00 00 00 
2747   1F3A 00 00 00 00 
2747   1F3E 00 00 00 00 
2747   1F42 00 00 00 00 
2747   1F46 00 00 00 00 
2747   1F4A 00 00 00 00 
2747   1F4E 00 00 00 00 
2747   1F52 00 00 00 00 
2747   1F56 00 00 00 00 
2747   1F5A 00 00 00 00 
2747   1F5E 00 00 00 00 
2747   1F62 00 00 00 00 
2747   1F66 00 00 00 00 
2747   1F6A 00 00 00 00 
2747   1F6E 00 00 00 00 
2747   1F72 00 00 00 00 
2747   1F76 00 00 00 00 
2747   1F7A 00 00 00 00 
2747   1F7E 00 00 00 00 
2747   1F82 00 00 00 00 
2747   1F86 00 00 00 00 
2747   1F8A 00 00 00 00 
2747   1F8E 00 00 00 00 
2747   1F92 00 00 00 00 
2747   1F96 00 00 00 00 
2747   1F9A 00 00 00 00 
2747   1F9E 00 00 00 00 
2747   1FA2 00 00 00 00 
2747   1FA6 00 00 00 00 
2747   1FAA 00 00 00 00 
2747   1FAE 00 00 00 00 
2747   1FB2 00 00 00 00 
2747   1FB6 00 00 00 00 
2747   1FBA 00 00 00 00 
2747   1FBE 00 00 00 00 
2747   1FC2 00 00 00 00 
2747   1FC6 00 00 00 00 
2747   1FCA 00 00 00 00 
2747   1FCE 00 00 00 00 
2747   1FD2 00 00 00 00 
2747   1FD6 00 00 00 00 
2747   1FDA 00 00 00 00 
2747   1FDE 00 00 00 00 
2747   1FE2 00 00 00 00 
2747   1FE6 00 00 00 00 
2747   1FEA 00 00 00 00 
2747   1FEE 00 00 00 00 
2747   1FF2 00 00 00 00 
2747   1FF6 00 00 00 00 
2747   1FFA 00 00 00 00 
2747   1FFE 00 00 00 00 
2747   2002 00 00 00 00 
2747   2006 00 00 00 00 
2747   200A 00 00 00 00 
2747   200E 00 00 00 00 
2747   2012 00 00 00 00 
2747   2016 00 00 00 00 
2747   201A 00 00 00 00 
2747   201E 00 00 00 00 
2747   2022 00 00 00 00 
2747   2026 00 00 00 00 
2747   202A 00 00 00 00 
2747   202E 00 00 00 00 
2747   2032 00 00 00 00 
2747   2036 00 00 00 00 
2747   203A 00 00 00 00 
2747   203E 00 00 00 00 
2747   2042 00 00 00 00 
2747   2046 00 00 00 00 
2747   204A 00 00 00 00 
2747   204E 00 00 00 00 
2747   2052 00 00 00 00 
2747   2056 00 00 00 00 
2747   205A 00 00 00 00 
2747   205E 00 00 00 00 
2747   2062 00 00 00 00 
2747   2066 00 00 00 00 
2747   206A 00 00 00 00 
2747   206E 00 00 00 00 
2747   2072 00 00 00 00 
2747   2076 00 00 00 00 
2747   207A 00 00 00 00 
2747   207E 00 00 00 00 
2747   2082 00 00 00 00 
2747   2086 00 00 00 00 
2747   208A 00 00 00 00 
2747   208E 00 00 00 00 
2747   2092 00 00 00 00 
2747   2096 00 00 00 00 
2747   209A 00 00 00 00 
2747   209E 00 00 00 00 
2747   20A2 00 00 00 00 
2747   20A6 00 00 00 00 
2747   20AA 00 00 00 00 
2747   20AE 00 00 00 00 
2747   20B2 00 00 00 00 
2747   20B6 00 00 00 00 
2747   20BA 00 00 00 00 
2747   20BE 00 00 00 00 
2748   20C2 FF FF FF FF fifo:               .fill FIFO_SIZE
2748   20C6 FF FF FF FF 
2748   20CA FF FF FF FF 
2748   20CE FF FF FF FF 
2748   20D2 FF FF FF FF 
2748   20D6 FF FF FF FF 
2748   20DA FF FF FF FF 
2748   20DE FF FF FF FF 
2748   20E2 FF FF FF FF 
2748   20E6 FF FF FF FF 
2748   20EA FF FF FF FF 
2748   20EE FF FF FF FF 
2748   20F2 FF FF FF FF 
2748   20F6 FF FF FF FF 
2748   20FA FF FF FF FF 
2748   20FE FF FF FF FF 
2748   2102 FF FF FF FF 
2748   2106 FF FF FF FF 
2748   210A FF FF FF FF 
2748   210E FF FF FF FF 
2748   2112 FF FF FF FF 
2748   2116 FF FF FF FF 
2748   211A FF FF FF FF 
2748   211E FF FF FF FF 
2748   2122 FF FF FF FF 
2748   2126 FF FF FF FF 
2748   212A FF FF FF FF 
2748   212E FF FF FF FF 
2748   2132 FF FF FF FF 
2748   2136 FF FF FF FF 
2748   213A FF FF FF FF 
2748   213E FF FF FF FF 
2748   2142 FF FF FF FF 
2748   2146 FF FF FF FF 
2748   214A FF FF FF FF 
2748   214E FF FF FF FF 
2748   2152 FF FF FF FF 
2748   2156 FF FF FF FF 
2748   215A FF FF FF FF 
2748   215E FF FF FF FF 
2748   2162 FF FF FF FF 
2748   2166 FF FF FF FF 
2748   216A FF FF FF FF 
2748   216E FF FF FF FF 
2748   2172 FF FF FF FF 
2748   2176 FF FF FF FF 
2748   217A FF FF FF FF 
2748   217E FF FF FF FF 
2748   2182 FF FF FF FF 
2748   2186 FF FF FF FF 
2748   218A FF FF FF FF 
2748   218E FF FF FF FF 
2748   2192 FF FF FF FF 
2748   2196 FF FF FF FF 
2748   219A FF FF FF FF 
2748   219E FF FF FF FF 
2748   21A2 FF FF FF FF 
2748   21A6 FF FF FF FF 
2748   21AA FF FF FF FF 
2748   21AE FF FF FF FF 
2748   21B2 FF FF FF FF 
2748   21B6 FF FF FF FF 
2748   21BA FF FF FF FF 
2748   21BE FF FF FF FF 
2748   21C2 FF FF FF FF 
2748   21C6 FF FF FF FF 
2748   21CA FF FF FF FF 
2748   21CE FF FF FF FF 
2748   21D2 FF FF FF FF 
2748   21D6 FF FF FF FF 
2748   21DA FF FF FF FF 
2748   21DE FF FF FF FF 
2748   21E2 FF FF FF FF 
2748   21E6 FF FF FF FF 
2748   21EA FF FF FF FF 
2748   21EE FF FF FF FF 
2748   21F2 FF FF FF FF 
2748   21F6 FF FF FF FF 
2748   21FA FF FF FF FF 
2748   21FE FF FF FF FF 
2748   2202 FF FF FF FF 
2748   2206 FF FF FF FF 
2748   220A FF FF FF FF 
2748   220E FF FF FF FF 
2748   2212 FF FF FF FF 
2748   2216 FF FF FF FF 
2748   221A FF FF FF FF 
2748   221E FF FF FF FF 
2748   2222 FF FF FF FF 
2748   2226 FF FF FF FF 
2748   222A FF FF FF FF 
2748   222E FF FF FF FF 
2748   2232 FF FF FF FF 
2748   2236 FF FF FF FF 
2748   223A FF FF FF FF 
2748   223E FF FF FF FF 
2748   2242 FF FF FF FF 
2748   2246 FF FF FF FF 
2748   224A FF FF FF FF 
2748   224E FF FF FF FF 
2748   2252 FF FF FF FF 
2748   2256 FF FF FF FF 
2748   225A FF FF FF FF 
2748   225E FF FF FF FF 
2748   2262 FF FF FF FF 
2748   2266 FF FF FF FF 
2748   226A FF FF FF FF 
2748   226E FF FF FF FF 
2748   2272 FF FF FF FF 
2748   2276 FF FF FF FF 
2748   227A FF FF FF FF 
2748   227E FF FF FF FF 
2748   2282 FF FF FF FF 
2748   2286 FF FF FF FF 
2748   228A FF FF FF FF 
2748   228E FF FF FF FF 
2748   2292 FF FF FF FF 
2748   2296 FF FF FF FF 
2748   229A FF FF FF FF 
2748   229E FF FF FF FF 
2748   22A2 FF FF FF FF 
2748   22A6 FF FF FF FF 
2748   22AA FF FF FF FF 
2748   22AE FF FF FF FF 
2748   22B2 FF FF FF FF 
2748   22B6 FF FF FF FF 
2748   22BA FF FF FF FF 
2748   22BE FF FF FF FF 
2748   22C2 FF FF FF FF 
2748   22C6 FF FF FF FF 
2748   22CA FF FF FF FF 
2748   22CE FF FF FF FF 
2748   22D2 FF FF FF FF 
2748   22D6 FF FF FF FF 
2748   22DA FF FF FF FF 
2748   22DE FF FF FF FF 
2748   22E2 FF FF FF FF 
2748   22E6 FF FF FF FF 
2748   22EA FF FF FF FF 
2748   22EE FF FF FF FF 
2748   22F2 FF FF FF FF 
2748   22F6 FF FF FF FF 
2748   22FA FF FF FF FF 
2748   22FE FF FF FF FF 
2748   2302 FF FF FF FF 
2748   2306 FF FF FF FF 
2748   230A FF FF FF FF 
2748   230E FF FF FF FF 
2748   2312 FF FF FF FF 
2748   2316 FF FF FF FF 
2748   231A FF FF FF FF 
2748   231E FF FF FF FF 
2748   2322 FF FF FF FF 
2748   2326 FF FF FF FF 
2748   232A FF FF FF FF 
2748   232E FF FF FF FF 
2748   2332 FF FF FF FF 
2748   2336 FF FF FF FF 
2748   233A FF FF FF FF 
2748   233E FF FF FF FF 
2748   2342 FF FF FF FF 
2748   2346 FF FF FF FF 
2748   234A FF FF FF FF 
2748   234E FF FF FF FF 
2748   2352 FF FF FF FF 
2748   2356 FF FF FF FF 
2748   235A FF FF FF FF 
2748   235E FF FF FF FF 
2748   2362 FF FF FF FF 
2748   2366 FF FF FF FF 
2748   236A FF FF FF FF 
2748   236E FF FF FF FF 
2748   2372 FF FF FF FF 
2748   2376 FF FF FF FF 
2748   237A FF FF FF FF 
2748   237E FF FF FF FF 
2748   2382 FF FF FF FF 
2748   2386 FF FF FF FF 
2748   238A FF FF FF FF 
2748   238E FF FF FF FF 
2748   2392 FF FF FF FF 
2748   2396 FF FF FF FF 
2748   239A FF FF FF FF 
2748   239E FF FF FF FF 
2748   23A2 FF FF FF FF 
2748   23A6 FF FF FF FF 
2748   23AA FF FF FF FF 
2748   23AE FF FF FF FF 
2748   23B2 FF FF FF FF 
2748   23B6 FF FF FF FF 
2748   23BA FF FF FF FF 
2748   23BE FF FF FF FF 
2748   23C2 FF FF FF FF 
2748   23C6 FF FF FF FF 
2748   23CA FF FF FF FF 
2748   23CE FF FF FF FF 
2748   23D2 FF FF FF FF 
2748   23D6 FF FF FF FF 
2748   23DA FF FF FF FF 
2748   23DE FF FF FF FF 
2748   23E2 FF FF FF FF 
2748   23E6 FF FF FF FF 
2748   23EA FF FF FF FF 
2748   23EE FF FF FF FF 
2748   23F2 FF FF FF FF 
2748   23F6 FF FF FF FF 
2748   23FA FF FF FF FF 
2748   23FE FF FF FF FF 
2748   2402 FF FF FF FF 
2748   2406 FF FF FF FF 
2748   240A FF FF FF FF 
2748   240E FF FF FF FF 
2748   2412 FF FF FF FF 
2748   2416 FF FF FF FF 
2748   241A FF FF FF FF 
2748   241E FF FF FF FF 
2748   2422 FF FF FF FF 
2748   2426 FF FF FF FF 
2748   242A FF FF FF FF 
2748   242E FF FF FF FF 
2748   2432 FF FF FF FF 
2748   2436 FF FF FF FF 
2748   243A FF FF FF FF 
2748   243E FF FF FF FF 
2748   2442 FF FF FF FF 
2748   2446 FF FF FF FF 
2748   244A FF FF FF FF 
2748   244E FF FF FF FF 
2748   2452 FF FF FF FF 
2748   2456 FF FF FF FF 
2748   245A FF FF FF FF 
2748   245E FF FF FF FF 
2748   2462 FF FF FF FF 
2748   2466 FF FF FF FF 
2748   246A FF FF FF FF 
2748   246E FF FF FF FF 
2748   2472 FF FF FF FF 
2748   2476 FF FF FF FF 
2748   247A FF FF FF FF 
2748   247E FF FF FF FF 
2748   2482 FF FF FF FF 
2748   2486 FF FF FF FF 
2748   248A FF FF FF FF 
2748   248E FF FF FF FF 
2748   2492 FF FF FF FF 
2748   2496 FF FF FF FF 
2748   249A FF FF FF FF 
2748   249E FF FF FF FF 
2748   24A2 FF FF FF FF 
2748   24A6 FF FF FF FF 
2748   24AA FF FF FF FF 
2748   24AE FF FF FF FF 
2748   24B2 FF FF FF FF 
2748   24B6 FF FF FF FF 
2748   24BA FF FF FF FF 
2748   24BE FF FF FF FF 
2749   24C2             
2750   24C2 FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2750   24C6 FF FF FF FF 
2750   24CA FF FF FF FF 
2750   24CE FF FF FF FF 
2750   24D2 FF FF FF FF 
2750   24D6 FF FF FF FF 
2750   24DA FF FF FF FF 
2750   24DE FF FF FF FF 
2750   24E2 FF FF FF FF 
2750   24E6 FF FF FF FF 
2750   24EA FF FF FF FF 
2750   24EE FF FF FF FF 
2750   24F2 FF FF FF FF 
2750   24F6 FF FF FF FF 
2750   24FA FF FF FF FF 
2750   24FE FF FF FF FF 
2750   2502 FF FF FF FF 
2750   2506 FF FF FF FF 
2750   250A FF FF FF FF 
2750   250E FF FF FF FF 
2750   2512 FF FF FF FF 
2750   2516 FF FF FF FF 
2750   251A FF FF FF FF 
2750   251E FF FF FF FF 
2750   2522 FF FF FF FF 
2750   2526 FF FF FF FF 
2750   252A FF FF FF FF 
2750   252E FF FF FF FF 
2750   2532 FF FF FF FF 
2750   2536 FF FF FF FF 
2750   253A FF FF FF FF 
2750   253E FF FF FF FF 
2750   2542 FF FF FF FF 
2750   2546 FF FF FF FF 
2750   254A FF FF FF FF 
2750   254E FF FF FF FF 
2750   2552 FF FF FF FF 
2750   2556 FF FF FF FF 
2750   255A FF FF FF FF 
2750   255E FF FF FF FF 
2750   2562 FF FF FF FF 
2750   2566 FF FF FF FF 
2750   256A FF FF FF FF 
2750   256E FF FF FF FF 
2750   2572 FF FF FF FF 
2750   2576 FF FF FF FF 
2750   257A FF FF FF FF 
2750   257E FF FF FF FF 
2750   2582 FF FF FF FF 
2750   2586 FF FF FF FF 
2750   258A FF FF FF FF 
2750   258E FF FF FF FF 
2750   2592 FF FF FF FF 
2750   2596 FF FF FF FF 
2750   259A FF FF FF FF 
2750   259E FF FF FF FF 
2750   25A2 FF FF FF FF 
2750   25A6 FF FF FF FF 
2750   25AA FF FF FF FF 
2750   25AE FF FF FF FF 
2750   25B2 FF FF FF FF 
2750   25B6 FF FF FF FF 
2750   25BA FF FF FF FF 
2750   25BE FF FF FF FF 
2750   25C2 FF FF FF FF 
2750   25C6 FF FF FF FF 
2750   25CA FF FF FF FF 
2750   25CE FF FF FF FF 
2750   25D2 FF FF FF FF 
2750   25D6 FF FF FF FF 
2750   25DA FF FF FF FF 
2750   25DE FF FF FF FF 
2750   25E2 FF FF FF FF 
2750   25E6 FF FF FF FF 
2750   25EA FF FF FF FF 
2750   25EE FF FF FF FF 
2750   25F2 FF FF FF FF 
2750   25F6 FF FF FF FF 
2750   25FA FF FF FF FF 
2750   25FE FF FF FF FF 
2750   2602 FF FF FF FF 
2750   2606 FF FF FF FF 
2750   260A FF FF FF FF 
2750   260E FF FF FF FF 
2750   2612 FF FF FF FF 
2750   2616 FF FF FF FF 
2750   261A FF FF FF FF 
2750   261E FF FF FF FF 
2750   2622 FF FF FF FF 
2750   2626 FF FF FF FF 
2750   262A FF FF FF FF 
2750   262E FF FF FF FF 
2750   2632 FF FF FF FF 
2750   2636 FF FF FF FF 
2750   263A FF FF FF FF 
2750   263E FF FF FF FF 
2750   2642 FF FF FF FF 
2750   2646 FF FF FF FF 
2750   264A FF FF FF FF 
2750   264E FF FF FF FF 
2750   2652 FF FF FF FF 
2750   2656 FF FF FF FF 
2750   265A FF FF FF FF 
2750   265E FF FF FF FF 
2750   2662 FF FF FF FF 
2750   2666 FF FF FF FF 
2750   266A FF FF FF FF 
2750   266E FF FF FF FF 
2750   2672 FF FF FF FF 
2750   2676 FF FF FF FF 
2750   267A FF FF FF FF 
2750   267E FF FF FF FF 
2750   2682 FF FF FF FF 
2750   2686 FF FF FF FF 
2750   268A FF FF FF FF 
2750   268E FF FF FF FF 
2750   2692 FF FF FF FF 
2750   2696 FF FF FF FF 
2750   269A FF FF FF FF 
2750   269E FF FF FF FF 
2750   26A2 FF FF FF FF 
2750   26A6 FF FF FF FF 
2750   26AA FF FF FF FF 
2750   26AE FF FF FF FF 
2750   26B2 FF FF FF FF 
2750   26B6 FF FF FF FF 
2750   26BA FF FF FF FF 
2750   26BE FF FF FF FF 
2751   26C2 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2752   26C3             
2753   26C3             
2754   26C3             .end
tasm: Number of errors = 0
