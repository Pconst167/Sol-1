 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	1-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


 	 	 	 	
 	 	 	 	 	.LIST
 	 	 	 	
 	 	 	 	 	TITLE	ZIP	Z-LANGUAGE INTERPRETER
	 	 	 	 	 	IBMPC VERSION
 	 	 	 	
 	 	 	 	 	PAGE 58,132
 	 	 	 	
 	 	 	 	 	SUBTTL	STACK AND DATA SEGMENTS INITIALIZATION
 	 	 	 	 	
 	 	 	 	 	; CHANGES ON "D" VERSION
 	 	 	 	 	;
 	 	 	 	 	; 1) SPLIT AND SCREEN OPCODES WORK
 	 	 	 	 	; 2) RAGGED SCREEN FIXED
 	 	 	 	 	; 3) DELETE KEY COLOR PROBLEM FIXED
 	 	 	 	 	; 4) PRINTER PROBLEM FIXED
 	 	 	 	 	; 5) COLOR QUESTION ON RESTART FIXED
 	 	 	 	 	; 6) RANDOMNESS BUG FIXED - 06/25/84 - DAN HORN
 	 	 	 	
 	 	 	 	
 = 0044	 	 	 	ZVERSN	EQU	"D"	 	;ZIP VERSION NUMBER
 = 0003	 	 	 	ZMVERS	EQU	3	 	;Z-MACHINE VERSION NUMBER
 = 0100	 	 	 	LSTACK	EQU	256	 	;LENGTH OF USER STACK(MUST BE 1 PAGE FOR NOW)
 	 	 	 	
 0000	 	 	 	ABS_SG	SEGMENT AT 0H
 0000	 	 	 	ABS_SG	ENDS
 	 	 	 	
 0000	 	 	 	STK_SG	SEGMENT	PARA STACK
 0000  0100 [	 	 	 	DW	100H DUP(?)
                ????	 	
                      ]	 	
 	 	 	 	
 0200	 	 	 	STK_TOP	LABEL	WORD
 0200  0100 [	 	 	STKBOT	DW	LSTACK DUP(?)
                ????	 	
                      ]	 	
 	 	 	 	
 0400	 	 	 	ZSTK_TP	LABEL	WORD
 0400	 	 	 	STK_SG	ENDS
 	 	 	 	
 0000	 	 	 	DATA_SG	SEGMENT	PARA
 	 	 	 	
 	 	 	 	 	;VARIBLE DEFINITIONS:
 	 	 	 	
 	 	 	 	 	;SCREEN COLOR ATTRIBUTES
 0000  07	 	 	NRMATR	DB	07H	 	;FOR B/W, NORMAL - IN COLOR, WHITE ON BLUE
 0001  70	 	 	USLATR	DB	70H	 	;B/W AND COLOR, BLACK ON WHITE
 0002  07	 	 	TYPATR	DB	07H	 	;FOR COLOR, YELLOW ON BLUE/ FOR B&W, ?
 0003  20 20 20 44 6F 20	COLORQ	DB	"   Do you want color (Y/N)? ",80H
       79 6F 75 20 77 61	
       6E 74 20 63 6F 6C	
       6F 72 20 28 59 2F	
       4E 29 3F 20 80	 	
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	1-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STACK AND DATA SEGMENTS INITIALIZATION

 0020  00	 	 	COLFLG	DB	0	 	;NON ZERO IF THEY WANT COLOR
 0021  0000	 	 	OLDCUR	DW	0	 	; TEMP FOR OLD CURSOR POSITION
 	 	 	 	 	;SCRIPTING STUFF
 0023  00	 	 	SCRFLG	DB	0
 0024  20 2A 20 50 72 69	PRNRDY	DB	" * Printer not ready: Abort or Retry? ",80H
       6E 74 65 72 20 6E	
       6F 74 20 72 65 61	
       64 79 3A 20 41 62	
       6F 72 74 20 6F 72	
       20 52 65 74 72 79	
       3F 20 80	 	 	
 	 	 	 	
 	 	 	 	 	;USL STUFF
 004B  00	 	 	USLMOD	DB	0	 	;FOR PUTCHR
 004C  00	 	 	PMFLAG	DB	0	 	;AM/PM
 	 	 	 	
 004D  0000	 	 	SLSTR	DW	0	 	;TOP OF SCREEN STRING
 004F  0000	 	 	SLTAB	DW	0	 	;TABLE USED BY OPUSL
 	 	 	 	
 0051  0061 R	 	 	SLSTAB	DW	SLS40
 0053  008B R	 	 	 	DW	SLS40T
 0055  00E5 R	 	 	 	DW	SLS80
 0057  0137 R	 	 	 	DW	SLS80T
 0059  00A3 R	 	 	SLTTAB	DW	SLT40
 005B  00CD R	 	 	 	DW	SLT40T
 005D  014F R	 	 	 	DW	SLT80
 005F  01A1 R	 	 	 	DW	SLT80T
 	 	 	 	
 	 	 	 	;40 COLUMN, SCORE
 0061     19 [	 	 	SLS40	DB	25 DUP(32),"S:",4 DUP(32),"M:",7 DUP(32),0,80H
                20	 	
                    ]	 	
          04 [     53 3A	
                20	 	
                    ]	 	
          07 [     4D 3A	
                20	 	
                    ]	 	
                   00 80	
 008B  FFFF	 	 	SLS40T	DW	-1
 008D  0A40 R	 	 	 	DW	OPPRND
 008F  0002	 	 	 	DW	2
 0091  0018	 	 	 	DW	24
 0093  FFFF	 	 	 	DW	-1
 0095  09A4 R	 	 	 	DW	OPPRNN
 0097  001B	 	 	 	DW	27
 0099  001E	 	 	 	DW	30
 009B  FFFF	 	 	 	DW	-1
 009D  09A4 R	 	 	 	DW	OPPRNN
 009F  0021	 	 	 	DW	33
 00A1  0024	 	 	 	DW	36
 	 	 	 	
 	 	 	 	;40 COLUMN, TIME
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	1-3
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STACK AND DATA SEGMENTS INITIALIZATION

 00A3     19 [	 	 	SLT40	DB	25 DUP(32),"Time:",10 DUP(32),0,80H
                20	 	
                    ]	 	
                   54 69	
       6D 0A [A	 	 	
                20	 	
                    ]	 	
                   00 80	
 00CD  FFFF	 	 	SLT40T	DW	-1
 00CF  0A40 R	 	 	 	DW	OPPRND
 00D1  0002	 	 	 	DW	2
 00D3  0018	 	 	 	DW	24
 00D5  FFFF	 	 	 	DW	-1
 00D7  09ED R	 	 	 	DW	OPPRNH
 00D9  001F	 	 	 	DW	31
 00DB  0021	 	 	 	DW	33
 00DD  FFFF	 	 	 	DW	-1
 00DF  0A1A R	 	 	 	DW	OPPRNM
 00E1  0022	 	 	 	DW	34
 00E3  0027	 	 	 	DW	39
 	 	 	 	
 	 	 	 	;80 COLUMN, SCORE
 00E5     33 [	 	 	SLS80	DB	51 DUP(32),"Score:",8 DUP(32),"Moves:",9 DUP(32),0,80H
                20	 	
                    ]	 	
                   53 63	
       6F 08 [5 3A	 	
                20	 	
                    ]	 	
                   4D 6F	
       76 09 [3 3A	 	
                20	 	
                    ]	 	
                   00 80	
 0137  FFFF	 	 	SLS80T	DW	-1
 0139  0A40 R	 	 	 	DW	OPPRND
 013B  0002	 	 	 	DW	2
 013D  001B	 	 	 	DW	27
 013F  FFFF	 	 	 	DW	-1
 0141  09A4 R	 	 	 	DW	OPPRNN
 0143  003A	 	 	 	DW	58
 0145  003D	 	 	 	DW	61
 0147  FFFF	 	 	 	DW	-1
 0149  09A4 R	 	 	 	DW	OPPRNN
 014B  0049	 	 	 	DW	73
 014D  004E	 	 	 	DW	78
 	 	 	 	
 	 	 	 	;80 COLUMN, TIME
 014F     3C [	 	 	SLT80	DB	60 DUP(32),"Time:",15 DUP(32),0,80H
                20	 	
                    ]	 	
                   54 69	
       6D 0F [A	 	 	
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	1-4
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STACK AND DATA SEGMENTS INITIALIZATION

                20	 	
                    ]	 	
                   00 80	
 01A1  FFFF	 	 	SLT80T	DW	-1
 01A3  0A40 R	 	 	 	DW	OPPRND
 01A5  0002	 	 	 	DW	2
 01A7  001B	 	 	 	DW	27
 01A9  FFFF	 	 	 	DW	-1
 01AB  09ED R	 	 	 	DW	OPPRNH
 01AD  0045	 	 	 	DW	69
 01AF  0047	 	 	 	DW	71
 01B1  FFFF	 	 	 	DW	-1
 01B3  0A1A R	 	 	 	DW	OPPRNM
 01B5  0048	 	 	 	DW	72
 01B7  004D	 	 	 	DW	77
 	 	 	 	
 	 	 	 	 	;REBOOT AT END OF GAME
 01B9  20 20 2A 2A 20 45	REBOOT	DB	"  ** End of session **",0
       6E 64 20 6F 66 20	
       73 65 73 73 69 6F	
       6E 20 2A 2A 00	 	
 01D0  53 74 72 69 6B 65	REBOO1	DB	"Strike any key to reboot",0
       20 61 6E 79 20 6B	
       65 79 20 74 6F 20	
       72 65 62 6F 6F 74	
       00	 	 	
 	 	 	 	
 	 	 	 	 	;VERIFY/INTERPRETER VERSION
 	 	 	 	
 01E9  49 42 4D 2D 50 43	INTMSG	DB	"IBM-PC Interpreter Version "
       20 49 6E 74 65 72	
       70 72 65 74 65 72	
       20 56 65 72 73 69	
       6F 6E 20	 	 	
 0204  44 80	 	 	INTVER	DB	"D",80H
 	 	 	 	
 	 	 	 	 	;SAVE/RESTORE
 0206  02	 	 	NDISKS	DB	2
 0207  00	 	 	FUCK	DB	0
 	 	 	 	
 0208  54 79 70 65 20 62	SRTXT0	DB	"Type backspace to abort",80H
       61 63 6B 73 70 61	
       63 65 20 74 6F 20	
       61 62 6F 72 74 80	
 0220  44 69 73 6B 20 64	SRTXT1	DB	"Disk drive (A-D)  (default = "
       72 69 76 65 20 28	
       41 2D 44 29 20 20	
       28 64 65 66 61 75	
       6C 74 20 3D 20	 	
 023D  42	 	 	SRDRV	DB	"B"
 023E  29 3A 80	 	 	 	DB	"):",80H
 0241  50 6F 73 69 74 69	SRTXT2	DB	"Position   (0-9)  (default = "
       6F 6E 20 20 20 28	
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	1-5
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STACK AND DATA SEGMENTS INITIALIZATION

       30 2D 39 29 20 20	
       28 64 65 66 61 75	
       6C 74 20 3D 20	 	
 025E  30	 	 	SRPOS	DB	"0"
 025F  29 3A 80	 	 	 	DB	"):",80H
 0262  49 6E 73 65 72 74	SRTXT3	DB	"Insert SAVE disk, then hit a key:",80H
       20 53 41 56 45 20	
       64 69 73 6B 2C 20	
       74 68 65 6E 20 68	
       69 74 20 61 20 6B	
       65 79 3A 80	 	
 0284  49 6E 73 65 72 74	SRTXT4	DB	"Insert game disk, then hit a key:",80H
       20 67 61 6D 65 20	
       64 69 73 6B 2C 20	
       74 68 65 6E 20 68	
       69 74 20 61 20 6B	
       65 79 3A 80	 	
 	 	 	 	
 	 	 	 	 	;GTBLKS
 02A6  00	 	 	DSKMOD	DB	0	 	;0 FOR GAME READ, 1 FOR SAVE/RESTORE
 02A7  00	 	 	DSKDRV	DB	0	 	;CURRENT DRIVE
 02A8  00	 	 	DSKDIR	DB	0	 	;0 FOR READ, 1 FOR WRITE
 02A9  0000	 	 	GTBCNT	DW	0	 	;REMAINING BLOCKS TO BE READ
 02AB  0000	 	 	GTBSTT	DW	0	 	;STARTING BLOCK
 02AD  0000	 	 	GTBCOR	DW	0	 	;STARTING CORE ADDRESS
 	 	 	 	 	;OPRAND
 02AF  ????	 	 	RSEED1	DW	?	 	;SEED FOR RANDOM NUMBERS
 02B1  ????	 	 	RSEED2	DW	?	 	;SEED TWO
 02B3  ????	 	 	RTEMP	DW	?	 	;TEMP FOR RANDOM ROUTINES
 	 	 	 	 	;READ
 02B5     04 [	 	 	RDWSTR	DW	4 DUP(0)	;WORD STRING BUFFER FOR ZWORD
                0000	 	
                      ]	 	
 	 	 	 	
 02BD  0000	 	 	RDBOS	DW	0	 	;BEGINNING OF STRING POINTER
 02BF  0000	 	 	RDEOS	DW	0	 	;END OF STRING POINTER
 02C1  0000	 	 	RDRET	DW	0	 	;RETURN TABLE POINTER
 02C3  00	 	 	RDNWDS	DB	0	 	;NUMBER OF WORDS READ
 	 	 	 	 	;PUTSTR
 02C4  0000	 	 	WRDOFF	DW	0	 	;OFFSET INTO WORD TABLE FOR CURRENT SET
 	 	 	 	 	;PUTCHR
 02C6  0000	 	 	CHRPTR	DW	0	 	;POINTS TO NEXT CHARACTER POSITION
 02C8  0000	 	 	ENDBUF	DW	0	 	;POINTS JUST PAST END OF OUTPUT BUFFER (0)
 	 	 	 	 	;GETNUM
 02CA  0000	 	 	STATUS	DW	0	 	;STATUS-LINE-REQUESTED FLAG
 	 	 	 	 	;ZIPBGN
 02CC  20 09 0D 0C 2E 2C	IRBRKS	DB	" ",9,13,12,".,?",0  ;INITIAL SET OF READ BREAK CHARS
       3F 00	 	 	
 02D4  0000	 	 	TWIDTH	DW	0	 	;TERMINAL WIDTH	
 02D6  0000	 	 	RWIDTH	DW	0	 	;REAL TERMINAL WIDTH
 02D8  01	 	 	SCRN0	DB	1	 	;START OF SCROLLING SCREEN
 02D9  00	 	 	CURSCR	DB	0	 	;CURRENT SCREEN
 02DA  01	 	 	LFTMAR	DB	1	 	;LEFT MARGIN DEFAULT = 1 (2 FOR 80-COLUMN)
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	1-6
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STACK AND DATA SEGMENTS INITIALIZATION

 02DB  0000	 	 	MEMTOP	DW	0	 	;LAST AVAILABLE LOCATION
 02DD  0000	 	 	TIMEMD	DW	0	 	;TIME(VERSUS SCORE)-MODE-FOR-STATUS-LINE FLAG
 02DF  0000	 	 	ZORKID	DW	0	 	;UNIQUE GAME & VERSION IDENTIFIER
 02E1  0000	 	 	ENDLOD	DW	0	 	;ENDLOD BLOCK NUMBER
 02E3  0000	 	 	VOCTAB	DW	0	 	;SAVE VOCABULARY TABLE POINTER
 02E5  0000	 	 	OBJTAB	DW	0	 	;OBJECT TABLE POINTER
 02E7  0000	 	 	GLOTAB	DW	0	 	;GLOBAL TABLE POINTER
 02E9  0000	 	 	WRDTAB	DW	0	 	;WORD TABLE POINTER
 02EB  0000	 	 	PURBOT	DW	0	 	;PURE CODE POINTER
 02ED  0000	 	 	ESIBKS	DW	0	 	;END OF SELF-INSERTING BREAK CHARACTERS
 02EF  0000	 	 	VWLEN	DW	0	 	;NUMBER OF BYTES IN A VOCABULARY WORD ENTRY
 02F1  0000	 	 	VWORDS	DW	0	 	;NUMBER OF WORD ENTRIES IN VOCABULARY
 02F3  0000	 	 	VOCBEG	DW	0	 	;BEGINNING OF ACTUAL VOCABULARY
 02F5  0200 [	 	 	BKBUF	DB	512 DUP(?)	;SCRATCH BUFFER FOR BACKUP
                ??	 	
                    ]	 	
 	 	 	 	
 04F5     51 [	 	 	OUTBUF	DB	81 DUP(?)	;OUTPUT BUFFER
                ??	 	
                    ]	 	
 	 	 	 	
 0546     20 [	 	 	RBRKS	DB	32 DUP(?)	;STRING OF READ BREAK CHARACTERS
                ??	 	
                    ]	 	
 	 	 	 	
 0566     40 [	 	 	PAGTAB	DB	64 DUP(254,0,0,0)	;PAGE INFORMATION TABLE
                FE	 	
                00	 	
                00	 	
                00	 	
                    ]	 	
 	 	 	 	
 0666  FF	 	 	 	DB	255
 0667  0000	 	 	PAGES	DW	0	 	;SWAPPING AREA
 0669  0000	 	 	BUFPGS	DW	0
 066B  00	 	 	CHRFLG	DB	0
 	 	 	 	
 066C  00	 	 	INIFLG	DB	0
 = 0001	 	 	 	INIWID	EQU	1
 = 0002	 	 	 	INIMEM	EQU	2
 = 0004	 	 	 	INIRND	EQU	4
 	 	 	 	
 	 	 	 	 	;RESTRT
 066D  0000	 	 	ZLOCS	DW	0	 	;POINTER TO LOCALS
 066F  0000	 	 	ZPC1	DW	0	 	;ZPC BLOCK-POINTER
 0671  0000	 	 	ZPC2	DW	0	 	;ZPC BYTE-POINTER
 0673     04 [	 	 	ARGBLK	DW	4 DUP(?)	;ARGUMENT BLOCK FOR EXTENDED OPERATIONS
                ????	 	
                      ]	 	
 	 	 	 	
 	 	 	 	 	;NEWZPC
 067B  0000	 	 	CURPAG	DW	0	 	;CURRENT PAGE (WHERE ZPC IS) POINTER
 067D  0000	 	 	CURBLK	DW	0	 	;CURRENT BLOCK, USUALLY SAME AS ZPC1
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	1-7
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STACK AND DATA SEGMENTS INITIALIZATION

 067F  0000	 	 	CURTAB	DW	0	 	;CURRENT PAGE TABLE POINTER +1
 	 	 	 	 	;GETPAG
 0681  00	 	 	RTIME1	DB	0	 	;REFERENCE TIME, 1 1/2 WORDS USED
 0682  0000	 	 	RTIME2	DW	0
 0684  0000	 	 	LPAGE	DW	0	 	;LAST REFERENCED PAGE NUMBER
 0686  0000	 	 	LPLOC	DW	0	 	;AND ITS CORE LOCATION
 0688  0000	 	 	LPTAB	DW	0	 	;AND ITS TABLE POINTER
 	 	 	 	
 	 	 	 	
 	 	 	 	 	;BACKUP COPY STUFF
 068A  00	 	 	SECCNT	DB	0
 068B  03	 	 	TRKCNT	DB	3
 068C  00	 	 	BKDSK	DB	0	 	;DRIVE TO BACKUP ONTO
 068D  01	 	 	BKFRST	DB	1
 	 	 	 	
 068E  59 6F 75 20 6D 61	BKASK1	DB	"You may make one backup copy of your",0H
       79 20 6D 61 6B 65	
       20 6F 6E 65 20 62	
       61 63 6B 75 70 20	
       63 6F 70 79 20 6F	
       66 20 79 6F 75 72	
       00	 	 	
 06B3  67 61 6D 65 2E 20	BKASK2	DB	"game. To do so you need a formatted",0H
       54 6F 20 64 6F 20	
       73 6F 20 79 6F 75	
       20 6E 65 65 64 20	
       61 20 66 6F 72 6D	
       61 74 74 65 64 00	
 06D7  43 4F 50 59 20 64	BKASK3	DB	"COPY disk.  Also, neither MASTER",0H
       69 73 6B 2E 20 20	
       41 6C 73 6F 2C 20	
       6E 65 69 74 68 65	
       72 20 4D 41 53 54	
       45 52 00	 	 	
 06F8  6E 6F 72 20 43 4F	BKASK4	DB	"nor COPY disk may be write-protected.",0H
       50 59 20 64 69 73	
       6B 20 6D 61 79 20	
       62 65 20 77 72 69	
       74 65 2D 70 72 6F	
       74 65 63 74 65 64	
       2E 00	 	 	
 071E  4D 61 6B 65 20 43	BKASK5	DB	"Make COPY now? (Y/N) ",80H
       4F 50 59 20 6E 6F	
       77 3F 20 28 59 2F	
       4E 29 20 80	 	
 0734  5B 59 45 53 5D 80	BKYEP	DB	"[YES]",80H
 073A  5B 4E 4F 5D 80	 	BKNOPE	DB	"[NO]",80H
 073F  49 6E 73 65 72 74	BKMC1	DB	"Insert MASTER disk in drive A",0H
       20 4D 41 53 54 45	
       52 20 64 69 73 6B	
       20 69 6E 20 64 72	
       69 76 65 20 41 00	
 075D  49 6E 73 65 72 74	BKMC2	DB	"Insert COPY disk in drive B",0H
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	1-8
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STACK AND DATA SEGMENTS INITIALIZATION

       20 43 4F 50 59 20	
       64 69 73 6B 20 69	
       6E 20 64 72 69 76	
       65 20 42 00	 	
 0779  48 69 74 20 61 6E	BKMC3	DB	"Hit any key to start backup",80H
       79 20 6B 65 79 20	
       74 6F 20 73 74 61	
       72 74 20 62 61 63	
       6B 75 70 80	 	
 0795  49 6E 73 65 72 74	BKMAST	DB	"Insert MASTER disk; hit any key",80H
       20 4D 41 53 54 45	
       52 20 64 69 73 6B	
       3B 20 68 69 74 20	
       61 6E 79 20 6B 65	
       79 80	 	 	
 07B5  49 6E 73 65 72 74	BKCOPY	DB	"Insert COPY disk; hit any key",80H
       20 43 4F 50 59 20	
       64 69 73 6B 3B 20	
       68 69 74 20 61 6E	
       79 20 6B 65 79 80	
 07D3  44 69 73 6B 20 77	BKWPRT	DB	"Disk write-protected; hit any key",80H
       72 69 74 65 2D 70	
       72 6F 74 65 63 74	
       65 64 3B 20 68 69	
       74 20 61 6E 79 20	
       6B 65 79 80	 	
 07F5  44 69 73 6B 20 65	BKNRDY	DB	"Disk error; hit any key",80H
       72 72 6F 72 3B 20	
       68 69 74 20 61 6E	
       79 20 6B 65 79 80	
 080D  42 61 63 6B 75 70	BKDONE	DB	"Backup completed.",0H
       20 63 6F 6D 70 6C	
       65 74 65 64 2E 00	
 081F  44 69 73 6B 20 65	BKFAIL	DB	"Disk error; backup aborted.",0H
       72 72 6F 72 3B 20	
       62 61 63 6B 75 70	
       20 61 62 6F 72 74	
       65 64 2E 00	 	
 083B  50 6C 65 61 73 65	BKWPS1	DB	"Please write-protect the disk in",0H
       20 77 72 69 74 65	
       2D 70 72 6F 74 65	
       63 74 20 74 68 65	
       20 64 69 73 6B 20	
       69 6E 00	 	 	
 085C  64 72 69 76 65 20	BKWPS2	DB	"drive A; hit any key",80H
       41 3B 20 68 69 74	
       20 61 6E 79 20 6B	
       65 79 80	 	 	
 0871  0000	 	 	DSK_SV1	DW	0
 0873  0000	 	 	DSK_SV2	DW	0
 	 	 	 	
 0875  CF	 	 	DSK_PRM	DB	11001111B
 0876  02	 	 	 	DB	2
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	1-9
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STACK AND DATA SEGMENTS INITIALIZATION

 0877  25	 	 	 	DB	37
 0878  03	 	 	 	DB	3
 0879  04	 	 	 	DB	4
 087A  2A	 	 	 	DB	02AH
 087B  FF	 	 	 	DB	0FFH
 087C  50	 	 	 	DB	050H
 087D  F6	 	 	 	DB	0F6H
 087E  19	 	 	 	DB	25
 087F  04	 	 	 	DB	4
 	 	 	 	
 0880  01 00 01 03	 	IDTBL	DB	1,0,1,3
 0884  01 00 02 03	 	 	DB	1,0,2,3
 0888  01 00 03 03	 	 	DB	1,0,3,3
 088C  01 00 04 03	 	 	DB	1,0,4,3
 	 	 	 	
 	 	 	 	 	;OPERATION TABLES:
 	 	 	 	 	;ZERO ARGUMENT OPERATIONS
 0890  0B03 R	 	 	ZEROOP	DW	OPRTRU	 	;176
 0892  0B08 R	 	 	 	DW	OPRFAL	 	;177
 0894  0A55 R	 	 	 	DW	OPPRNI	 	;178
 0896  0A69 R	 	 	 	DW	OPPRNR	 	;179
 0898  0B25 R	 	 	 	DW	OPNOOP	 	;180
 089A  0083 R	 	 	 	DW	OPSAVE	 	;181
 089C  007B R	 	 	 	DW	OPREST	 	;182
 089E  01D5 R	 	 	 	DW	OPRSTT	 	;183
 08A0  0B18 R	 	 	 	DW	OPRSTA	 	;184
 08A2  0B1F R	 	 	 	DW	OPFSTA	 	;185
 08A4  01E9 R	 	 	 	DW	OPQUIT	 	;186
 08A6  0A72 R	 	 	 	DW	OPCRLF	 	;187
 08A8  02A4 R	 	 	 	DW	OPUSL	 	;188
 08AA  001F R	 	 	 	DW	OPVERI	 	;189
 08AC  0000	 	 	 	DW	0	 	;190
 08AE  0000	 	 	 	DW	0	 	;191
 	 	 	 	 	;ONE ARGUMENT OPERATIONS
 08B0  03B3 R	 	 	ONEOP	DW	OPQZER	 	;128
 08B2  04C4 R	 	 	 	DW	OPQNEX	 	;129
 08B4  04AC R	 	 	 	DW	OPQFIR	 	;130
 08B6  04A0 R	 	 	 	DW	OPLOC	 	;131
 08B8  062E R	 	 	 	DW	OPPTSI	 	;132
 08BA  0657 R	 	 	 	DW	OPINC	 	;133
 08BC  0664 R	 	 	 	DW	OPDEC	 	;134
 08BE  09E7 R	 	 	 	DW	OPPRNB	 	;135
 08C0  0000	 	 	 	DW	0	 	;136
 08C2  03E9 R	 	 	 	DW	OPREMO	 	;137
 08C4  0A40 R	 	 	 	DW	OPPRND	 	;138
 08C6  0ADA R	 	 	 	DW	OPRETU	 	;139
 08C8  0B0C R	 	 	 	DW	OPJUMP	 	;140
 08CA  09E1 R	 	 	 	DW	OPPRIN	 	;141
 08CC  0640 R	 	 	 	DW	OPVALU	 	;142
 08CE  0382 R	 	 	 	DW	OPBCOM	 	;143
 	 	 	 	 	;TWO ARGUMENT AND EXTENDED ARGUMENT OPERATIONS
 08D0  0000	 	 	EXTOP	DW	0	 	;0
 08D2  038C R	 	 	 	DW	OPQEQU	 	;1
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	1-10
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STACK AND DATA SEGMENTS INITIALIZATION

 08D4  0365 R	 	 	 	DW	OPQLES	 	;2
 08D6  036F R	 	 	 	DW	OPQGRT	 	;3
 08D8  0689 R	 	 	 	DW	OPQDLE	 	;4
 08DA  066C R	 	 	 	DW	OPQIGR	 	;5
 08DC  04D8 R	 	 	 	DW	OPQIN	 	;6
 08DE  0375 R	 	 	 	DW	OPBTST	 	;7
 08E0  037D R	 	 	 	DW	OPBOR	 	;8
 08E2  0387 R	 	 	 	DW	OPBAND	 	;9
 08E4  0435 R	 	 	 	DW	OPQFSE	 	;10
 08E6  045A R	 	 	 	DW	OPFSET	 	;11
 08E8  047D R	 	 	 	DW	OPFCLE	 	;12
 08EA  0646 R	 	 	 	DW	OPSET	 	;13
 08EC  03BE R	 	 	 	DW	OPMOVE	 	;14
 08EE  05CF R	 	 	 	DW	OPGET	 	;15
 08F0  05DE R	 	 	 	DW	OPGETB	 	;16
 08F2  04E4 R	 	 	 	DW	OPGETP	 	;17
 08F4  05FB R	 	 	 	DW	OPGTPT	 	;18
 08F6  0585 R	 	 	 	DW	OPNEXT	 	;19
 08F8  030A R	 	 	 	DW	OPADD	 	;20
 08FA  030F R	 	 	 	DW	OPSUB	 	;21
 08FC  0314 R	 	 	 	DW	OPMUL	 	;22
 08FE  0319 R	 	 	 	DW	OPDIV	 	;23
 0900  031F R	 	 	 	DW	OPMOD	 	;24
 0902  0000	 	 	 	DW	0	 	;25
 0904  0000	 	 	 	DW	0	 	;26
 0906  0000	 	 	 	DW	0	 	;27
 0908  0000	 	 	 	DW	0	 	;28
 090A  0000	 	 	 	DW	0	 	;29
 090C  0000	 	 	 	DW	0	 	;30
 090E  0000	 	 	 	DW	0	 	;31
 0910  0A75 R	 	 	 	DW	OPCALL	 	;224
 0912  05EB R	 	 	 	DW	OPPUT	 	;225
 0914  05F5 R	 	 	 	DW	OPPUTB	 	;226
 0916  0531 R	 	 	 	DW	OPPUTP	 	;227
 0918  081E R	 	 	 	DW	OPREAD	 	;228
 091A  09A1 R	 	 	 	DW	OPPRNC	 	;229
 091C  09A4 R	 	 	 	DW	OPPRNN	 	;230
 091E  0327 R	 	 	 	DW	OPRAND	 	;231
 0920  0649 R	 	 	 	DW	OPPUSH	 	;232
 0922  064F R	 	 	 	DW	OPPOP	 	;233
 0924  0243 R	 	 	 	DW	OPSPLT	 	;234
 0926  01EC R	 	 	 	DW	OPSCRN	 	;235
 0928  0000	 	 	 	DW	0	 	;236
 092A  0000	 	 	 	DW	0	 	;237
 092C  0000	 	 	 	DW	0	 	;238
 092E  0000	 	 	 	DW	0	 	;239
 0930  0000	 	 	 	DW	0	 	;240
 0932  0000	 	 	 	DW	0	 	;241
 0934  0000	 	 	 	DW	0	 	;242
 0936  0000	 	 	 	DW	0	 	;243
 0938  0000	 	 	 	DW	0	 	;244
 093A  0000	 	 	 	DW	0	 	;245
 093C  0000	 	 	 	DW	0	 	;246
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	1-11
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STACK AND DATA SEGMENTS INITIALIZATION

 093E  0000	 	 	 	DW	0	 	;247
 0940  0000	 	 	 	DW	0	 	;248
 0942  0000	 	 	 	DW	0	 	;249
 0944  0000	 	 	 	DW	0	 	;250
 0946  0000	 	 	 	DW	0	 	;251
 0948  0000	 	 	 	DW	0	 	;252
 094A  0000	 	 	 	DW	0	 	;253
 094C  0000	 	 	 	DW	0	 	;254
 094E  0000	 	 	 	DW	0	 	;255
 	 	 	 	 	;.CRLF
 0950  2A 2A 4D 4F 52 45	MORE	DB	"**MORE** ",80H
       2A 2A 20 80	 	
 095A  0000	 	 	MORLIN	DW	0
 095C  0017	 	 	LINMAX	DW	23
 = 0017	 	 	 	LINMXX	EQU	23
 	 	 	 	
 	 	 	 	 	;.GETTM
 095E  ????????	 	 	TIME	DD	?
 	 	 	 	
 	 	 	 	 	;STRUCTURE AND RECORD DEFINITIONS:
 	 	 	 	 	;OBJECT OPERATIONS
 	 	 	 	OBJECT	STRUC
 0000  ????	 	 	FLAGS1	DW	?
 0002  ????	 	 	FLAGS2	DW	?
 0004  ??	 	 	PARENT	DB	?
 0005  ??	 	 	SIBLING	DB	?
 0006  ??	 	 	CHILD1	DB	?
 0007  ????	 	 	PROPS	DW	?
 0009	 	 	 	OBJECT	ENDS
 	 	 	 	PROPID	RECORD	PROPSIZE:3,PROPNUM:5
 	 	 	 	
 	 	 	 	 	;STRING DEFINITIONS
 	 	 	 	
 	 	 	 	 	;READ
 0962  54 6F 6F 20 6D 61	ERR2	DB	"Too many words typed, flushing: ",80H
       6E 79 20 77 6F 72	
       64 73 20 74 79 70	
       65 64 2C 20 66 6C	
       75 73 68 69 6E 67	
       3A 20 80	 	 	
 	 	 	 	
 	 	 	 	 	;OPNEXT/OPPUTP
 0983  4E 6F 20 73 75 63	FTL2	DB	"No such property",0
       68 20 70 72 6F 70	
       65 72 74 79 00	 	
 	 	 	 	 	;ZIPBGN
 0994  57 72 6F 6E 67 20	FTL4	DB	"Wrong game or version",0
       67 61 6D 65 20 6F	
       72 20 76 65 72 73	
       69 6F 6E 00	 	
 	 	 	 	 	;NXTINS
 09AA  49 6C 6C 65 67 61	FTL5	DB	"Illegal operation",0
       6C 20 6F 70 65 72	
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	1-12
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STACK AND DATA SEGMENTS INITIALIZATION

       61 74 69 6F 6E 00	
 	 	 	 	 	;FINDPG
 09BC  4E 6F 20 66 72 65	FTL6	DB	"No free pages",0
       65 20 70 61 67 65	
       73 00	 	 	
 	 	 	 	 	;GTBLKS
 09CA  47 61 6D 65 20 66	FTL7	DB	"Game file read error",0
       69 6C 65 20 72 65	
       61 64 20 65 72 72	
       6F 72 00	 	 	
 	 	 	 	 	;Fatal error header
 09DF  46 61 74 61 6C 20	FATHDR	DB	"Fatal error: ",80H
       65 72 72 6F 72 3A	
       20 80	 	 	
 	 	 	 	 	;ZSTR CHARACTER CONVERSION VECTOR
 	 	 	 	
 09ED  61 62 63 64 65 66	ZCHRS	DB	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
       67 68 69 6A 6B 6C	
       6D 6E 6F 70 71 72	
       73 74 75 76 77 78	
       79 7A 41 42 43 44	
       45 46 47 48 49 4A	
       4B 4C 4D 4E 4F 50	
       51 52 53 54 55 56	
       57 58 59 5A	 	
 0A21  20 20 30 31 32 33	 	DB	"  0123456789.,!?_#'"
       34 35 36 37 38 39	
       2E 2C 21 3F 5F 23	
       27	 	 	
 0A34  22 2F 5C 2D 3A 28	 	DB	'"/\-:()'
       29	 	 	
 0A3B	 	 	 	DATA_SG	ENDS
 	 	 	 	
 	 	 	 	 	SUBTTL	MACROS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	2-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	MACROS

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	GTAWRD	MACRO	D,S	 	;;GET ABSOLUTE WORD
 	 	 	 	 	MOV	D&X,ES:&S
 	 	 	 	 	XCHG	D&H,D&L
 	 	 	 	 	ENDM
 	 	 	 	
 	 	 	 	PTAWRD	MACRO	D,S	 	;;PUT ABSOLUTE WORK
 	 	 	 	 	XCHG	S&H,S&L
 	 	 	 	 	MOV	ES:&D,S&X
 	 	 	 	 	ENDM
 	 	 	 	
 	 	 	 	MOVM	MACRO	D,S,R	 	;;MOVE MEMORY TO MEMORY
 	 	 	 	 	MOV	R,S
 	 	 	 	 	MOV	D,R
 	 	 	 	 	ENDM
 	 	 	 	
 	 	 	 	PUSHZ	MACRO	S	 	;;PUSH ONTO Z STACK
 	 	 	 	 	XCHG	SP,DI
 	 	 	 	 	PUSH	S
 	 	 	 	 	XCHG	SP,DI
 	 	 	 	 	ENDM
 	 	 	 	
 	 	 	 	POPZ	MACRO	D	 	;;POP FROM Z STACK
 	 	 	 	 	XCHG	SP,DI
 	 	 	 	 	POP	D
 	 	 	 	 	XCHG	SP,DI
 	 	 	 	 	ENDM
 	 	 	 	
 	 	 	 	POPZT	MACRO	D	 	;;GET TOP OF Z STACK
 	 	 	 	 	MOV	D,SS:[DI]
 	 	 	 	 	ENDM
 	 	 	 	
 	 	 	 	PUSHZT	MACRO	S	 	;;PUT TOP OF Z STACK
 	 	 	 	 	MOV	SS:[DI],S
 	 	 	 	 	ENDM
 	 	 	 	
 	 	 	 	PRINT	MACRO	STR	 	;;PRINT A STRING, POINTER IS ARGUMENT
 	 	 	 	 	PUSH	AX
 	 	 	 	 	MOV	AX,OFFSET STR
 	 	 	 	 	CALL	.PRINT
 	 	 	 	 	POP	AX
 	 	 	 	 	ENDM
 	 	 	 	
 	 	 	 	FATAL	MACRO	ERR	 	;;PRINT FATAL ERROR AND DIE
 	 	 	 	 	CALL	.CRLF
 	 	 	 	 	MOV	AX,OFFSET FATHDR
 	 	 	 	 	CALL	.PRINT
 	 	 	 	 	MOV	AX,OFFSET ERR
 	 	 	 	 	CALL	.PRINT
 	 	 	 	 	JMP	FINISH
 	 	 	 	 	ENDM
 	 	 	 	
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	2-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	MACROS

 	 	 	 	CURGET	MACRO
 	 	 	 	 	PUSH	AX
 	 	 	 	 	SUB	BH,BH
 	 	 	 	 	MOV	AH,3
 	 	 	 	 	INT	10H
 	 	 	 	 	POP	AX
 	 	 	 	 	ENDM
 	 	 	 	
 	 	 	 	CURSET	MACRO	POS
 	 	 	 	 	PUSH	AX
 	 	 	 	 	SUB	BH,BH
 	 	 	 	 	MOV	AH,2
 	 	 	 	IFNB<POS>
 	 	 	 	 	MOV	DX,POS
 	 	 	 	ENDIF
 	 	 	 	 	INT	10H
 	 	 	 	 	POP	AX
 	 	 	 	 	ENDM
 	 	 	 	
 	 	 	 	 	SUBTTL	SYSTEM INITIALIZATION
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	3-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	SYSTEM INITIALIZATION

 	 	 	 	 	PAGE	+
 	 	 	 	
 0000	 	 	 	CODE_SG	SEGMENT	PARA
 	 	 	 	ASSUME	CS:CODE_SG,DS:DATA_SG,ES:GAME_SG,SS:STK_SG
 	 	 	 	
 0000	 	 	 	START	PROC	FAR
 	 	 	 	
 	 	 	 	;NEVER, EVEN FOR AN INSTANT, CONSIDER CHANGING THESE NEXT INSTRUCTIONS
 	 	 	 	;THE GAME CREATOR MODIFIES THEM AND THEY MUST REMAIN HERE
 	 	 	 	
 	 	 	 	 	MOVM	DS,DATA_SG,AX
 0000  B8  ---- R             +	 	MOV	AX,DATA_SG
 0003  8E D8                  +	 	MOV	DS,AX
 	 	 	 	 	MOVM	ES,GAME_SG,AX
 0005  B8  ---- R             +	 	MOV	AX,GAME_SG
 0008  8E C0                  +	 	MOV	ES,AX
 	 	 	 	 	MOVM	SS,STK_SG,AX
 000A  B8  ---- R             +	 	MOV	AX,STK_SG
 000D  8E D0                  +	 	MOV	SS,AX
 	 	 	 	
 	 	 	 	;END OF MAGIC SECTION.  HACK AND SLASH TO YOUR HEART'S CONTENT
 	 	 	 	
 000F  BC 0200 R	 	 	MOV	SP,OFFSET STK_TOP
 0012  BF 0400 R	 	 	MOV	DI,OFFSET ZSTK_TP
 0015  E9 0F6A R	 	 	JMP	ZIPBGN	 	;JUMP TO BEGINNING OF ZIP CODE
 0018	 	 	 	START	ENDP
 	 	 	 	
 0018	 	 	 	FEEP	PROC
 0018  B8 0007	 	 	 	MOV	AX,7
 001B  E8 1887 R	 	 	CALL	.TTYOUT	 	;BELL
 001E  C3	 	 	 	RET
 001F	 	 	 	FEEP	ENDP
 	 	 	 	
 001F	 	 	 	OPVERI	PROC
 	 	 	 	 	PRINT	INTMSG
 001F  50                     +	 	PUSH	AX
 0020  B8 01E9 R              +	 	MOV	AX,OFFSET INTMSG
 0023  E8 196F R              +	 	CALL	.PRINT
 0026  58                     +	 	POP	AX
 0027  E8 18F0 R	 	 	CALL	.CRLF
 002A  26: A1 001A	 	 	MOV	AX,ES:[PLENTH]
 002E  86 E0	 	 	 	XCHG	AH,AL
 0030  56	 	 	 	PUSH	SI
 0031  57	 	 	 	PUSH	DI
 0032  FF 36 02E1 R	 	 	PUSH	ENDLOD
 0036  E8 0C6B R	 	 	CALL	BSPLIT
 0039  8B F0	 	 	 	MOV	SI,AX
 003B  8B FB	 	 	 	MOV	DI,BX
 003D  B8 0000	 	 	 	MOV	AX,0
 0040  BB 0040	 	 	 	MOV	BX,64
 0043  BA 0000	 	 	 	MOV	DX,0
 0046  C7 06 02E1 R 0000	 	MOV	ENDLOD,0
 004C  56	 	 	OPVR1:	PUSH	SI
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	3-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	SYSTEM INITIALIZATION

 004D  57	 	 	 	PUSH	DI
 004E  52	 	 	 	PUSH	DX
 004F  E8 0B26 R	 	 	CALL	GETBYT
 0052  5A	 	 	 	POP	DX
 0053  5F	 	 	 	POP	DI
 0054  5E	 	 	 	POP	SI
 0055  03 D1	 	 	 	ADD	DX,CX
 0057  83 FB 00	 	 	 	CMP	BX,0
 005A  75 01	 	 	 	JNZ	OPVX
 005C  90	 	 	 	NOP
 005D  3B C6	 	 	OPVX:	CMP	AX,SI
 005F  75 EB	 	 	 	JNE	OPVR1
 0061  3B DF	 	 	 	CMP	BX,DI
 0063  75 E7	 	 	 	JNE	OPVR1
 0065  26: A1 001C	 	 	MOV	AX,ES:[PCHKSM]
 0069  86 E0	 	 	 	XCHG	AH,AL
 006B  8F 06 02E1 R	 	 	POP	ENDLOD
 006F  5F	 	 	 	POP	DI
 0070  5E	 	 	 	POP	SI
 0071  3B C2	 	 	 	CMP	AX,DX
 0073  74 03	 	 	 	JE	OPVR2
 0075  E9 0C12 R	 	 	JMP	PFALSE
 0078  E9 0C17 R	 	OPVR2:	JMP	PTRUE
 007B	 	 	 	OPVERI	ENDP
 	 	 	 	
 007B	 	 	 	OPREST	PROC
 007B  C6 06 02A8 R 00	 	 	MOV	DSKDIR,0	;INDICATE RESTORE
 0080  EB 06 90	 	 	 	JMP	OSV0$
 0083	 	 	 	OPREST	ENDP
 	 	 	 	
 0083	 	 	 	OPSAVE	PROC
 0083  C6 06 02A8 R 01	 	 	MOV	DSKDIR,1	;INDICATE WRITE
 0088	 	 	 	OSV0$:	PRINT	SRTXT0	 	;WRITE "TYPE BACKSPACE..."
 0088  50                     +	 	PUSH	AX
 0089  B8 0208 R              +	 	MOV	AX,OFFSET SRTXT0
 008C  E8 196F R              +	 	CALL	.PRINT
 008F  58                     +	 	POP	AX
 0090  E8 18F0 R	 	 	CALL	.CRLF
 	 	 	 	 	PRINT	SRTXT2	 	;WRITE "POSITION (DEFAULT = X): "
 0093  50                     +	 	PUSH	AX
 0094  B8 0241 R              +	 	MOV	AX,OFFSET SRTXT2
 0097  E8 196F R              +	 	CALL	.PRINT
 009A  58                     +	 	POP	AX
 009B  E8 1864 R	 	OSV2A$:	CALL	.CHRIN
 009E  3C 0D	 	 	 	CMP	AL,13
 00A0  75 03	 	 	 	JNE	OSV3$
 00A2  A0 025E R	 	 	MOV	AL,SRPOS	;GET DEFAULT POSITION
 00A5  8A D8	 	 	OSV3$:	MOV	BL,AL
 00A7  3C 08	 	 	 	CMP	AL,8
 00A9  75 06	 	 	 	JNE	OSV3X$
 00AB  E8 18F0 R	 	 	CALL	.CRLF
 00AE  E9 0C12 R	 	 	JMP	PFALSE
 00B1  2C 30	 	 	OSV3X$:	SUB	AL,"0"	
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	3-3
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	SYSTEM INITIALIZATION

 00B3  3C 09	 	 	 	CMP	AL,9
 00B5  7F 04	 	 	 	JG	OSV3A$
 00B7  3C 00	 	 	 	CMP	AL,0
 00B9  7D 05	 	 	 	JGE	OSV3B$
 00BB  E8 0018 R	 	OSV3A$:	CALL	FEEP
 00BE  EB DB	 	 	 	JMP	OSV2A$
 00C0  88 1E 025E R	 	OSV3B$:	MOV	SRPOS,BL
 00C4  8A C3	 	 	 	MOV	AL,BL
 00C6  8A 26 0000 R	 	 	MOV	AH,NRMATR
 00CA  E8 1887 R	 	 	CALL	.TTYOUT
 00CD  E8 18F0 R	 	 	CALL	.CRLF
 	 	 	 	 	PRINT	SRTXT1	 	;WRITE "DRIVE (DEFAULT = X): "
 00D0  50                     +	 	PUSH	AX
 00D1  B8 0220 R              +	 	MOV	AX,OFFSET SRTXT1
 00D4  E8 196F R              +	 	CALL	.PRINT
 00D7  58                     +	 	POP	AX
 00D8  E8 1864 R	 	OSV0A$:	CALL	.CHRIN
 00DB  3C 0D	 	 	 	CMP	AL,13
 00DD  75 03	 	 	 	JNE	OSV1$
 00DF  A0 023D R	 	 	MOV	AL,SRDRV	;GET DEFAULT DRIVE
 00E2  3C 08	 	 	OSV1$:	CMP	AL,8
 00E4  75 06	 	 	 	JNE	OSAB1$
 00E6  E8 18F0 R	 	 	CALL	.CRLF
 00E9  E9 0C12 R	 	 	JMP	PFALSE
 00EC  3C 61	 	 	OSAB1$:	CMP	AL,"a"
 00EE  7C 02	 	 	 	JL	OSAB2$
 00F0  2C 20	 	 	 	SUB	AL,32	 	;UPPERCASE DRIVE LETTERS
 00F2  8A D8	 	 	OSAB2$:	MOV	BL,AL
 00F4  2C 41	 	 	 	SUB	AL,"A"	 	;GET DOWN TO BASICS
 00F6  3C 03	 	 	 	CMP	AL,3
 00F8  7F 04	 	 	 	JG	OSV1A$	 	;LOSING DRIVE NUMBER
 00FA  3C 00	 	 	 	CMP	AL,0
 00FC  7D 05	 	 	 	JGE	OSV1B$
 00FE  E8 0018 R	 	OSV1A$:	CALL	FEEP	 	;EXPRESS DISPLEASURE
 0101  EB D5	 	 	 	JMP	OSV0A$
 0103  88 1E 023D R	 	OSV1B$:	MOV	SRDRV,BL
 0107  8A C3	 	 	 	MOV	AL,BL
 0109  8A 26 0000 R	 	 	MOV	AH,NRMATR
 010D  E8 1887 R	 	 	CALL	.TTYOUT	 	;ECHO THE DRIVE LETTER
 0110  E8 18F0 R	 	 	CALL	.CRLF
 	 	 	 	 	PRINT	SRTXT3	 	;WRITE "Insert save disk..."
 0113  50                     +	 	PUSH	AX
 0114  B8 0262 R              +	 	MOV	AX,OFFSET SRTXT3
 0117  E8 196F R              +	 	CALL	.PRINT
 011A  58                     +	 	POP	AX
 011B  E8 1864 R	 	 	CALL	.CHRIN
 011E  3C 08	 	 	 	CMP	AL,8	 	;ABORT REQUESTED?
 0120  75 06	 	 	 	JNE	OSV3Z$
 0122  E8 18F0 R	 	 	CALL	.CRLF
 0125  E9 0C12 R	 	 	JMP	PFALSE
 0128  A0 025E R	 	OSV3Z$:	MOV	AL,SRPOS	;GET POSITION
 012B  2C 30	 	 	 	SUB	AL,"0"
 012D  2A E4	 	 	 	SUB	AH,AH
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	3-4
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	SYSTEM INITIALIZATION

 012F  8A 1E 023D R	 	 	MOV	BL,SRDRV
 0133  80 EB 41	 	 	 	SUB	BL,"A"
 0136  88 1E 02A7 R	 	 	MOV	DSKDRV,BL
 013A  87 FC	 	 	 	XCHG	DI,SP
 013C  FF 36 066F R	 	 	PUSH	ZPC1
 0140  FF 36 0671 R	 	 	PUSH	ZPC2
 0144  FF 36 066D R	 	 	PUSH	ZLOCS
 0148  FF 36 02DF R	 	 	PUSH	ZORKID	
 014C  36: 89 26 0200 R	 	 	MOV	STKBOT,SP	;SAVE THE WORLD
 0151  8B E7	 	 	 	MOV	SP,DI
 0153  B1 05	 	 	 	MOV	CL,5
 0155  D3 E0	 	 	 	SHL	AX,CL	 	;CHANGE TO BLOCK
 0157  50	 	 	 	PUSH	AX	 	;SAVE STARTING BLOCK #
 0158  06	 	 	 	PUSH	ES	 	;SAVE ES
 0159  8C D2	 	 	 	MOV	DX,SS
 015B  8E C2	 	 	 	MOV	ES,DX	 	;FAKE ES TO BE STACK SEGMENT
 015D  BB 0200 R	 	 	MOV	BX,OFFSET STKBOT
 0160  B9 0001	 	 	 	MOV	CX,1
 0163  E8 1484 R	 	 	CALL	SRBLKS	 	;READ/WRITE STACK
 0166  9C	 	 	 	PUSHF
 0167  8B FC	 	 	 	MOV	DI,SP	 	;SAVE SP
 0169  36: 8B 26 0200 R	 	 	MOV	SP,STKBOT	;RETRIEVE SAVED USER STACK POINTER
 016E  58	 	 	 	POP	AX
 016F  3B 06 02DF R	 	 	CMP	AX,ZORKID	;CHECK GAME VERSIONS
 0173  74 12	 	 	 	JE	OSVT0$
 	 	 	 	 	FATAL	FTL4
 0175  E8 18F0 R              +	 	CALL	.CRLF
 0178  B8 09DF R              +	 	MOV	AX,OFFSET FATHDR
 017B  E8 196F R              +	 	CALL	.PRINT
 017E  B8 0994 R              +	 	MOV	AX,OFFSET FTL4
 0181  E8 196F R              +	 	CALL	.PRINT
 0184  E9 1A47 R              +	 	JMP	FINISH
 0187  8F 06 066D R	 	OSVT0$:	POP	ZLOCS
 018B  8F 06 0671 R	 	 	POP	ZPC2
 018F  8F 06 066F R	 	 	POP	ZPC1
 0193  87 FC	 	 	 	XCHG	DI,SP
 0195  9D	 	 	 	POPF
 0196  07	 	 	 	POP	ES
 0197  58	 	 	 	POP	AX
 0198  72 35	 	 	 	JC	OSV4$	 	;DIE HERE IF FIRST READ/WRITE FAILED
 019A  40	 	 	 	INC	AX	 	;NEXT BLOCK STARTS
 019B  2B DB	 	 	 	SUB	BX,BX	 	;START AT ES:0
 019D  8B 0E 02EB R	 	 	MOV	CX,PURBOT	;NUMBER OF PURE BLOCKS
 01A1  E8 1484 R	 	 	CALL	SRBLKS
 01A4  9C	 	 	 	PUSHF	 	 	;SAVE FLAGS FROM CALL
 01A5  E8 18F0 R	 	 	CALL	.CRLF
 01A8  80 3E 02A7 R 00	 	 	CMP	DSKDRV,0	;CHECK FOR DRIVE 0
 01AD  75 0E	 	 	 	JNZ	OSV3C$
 	 	 	 	 	PRINT	SRTXT4	 	;WRITE "Insert game disk..."
 01AF  50                     +	 	PUSH	AX
 01B0  B8 0284 R              +	 	MOV	AX,OFFSET SRTXT4
 01B3  E8 196F R              +	 	CALL	.PRINT
 01B6  58                     +	 	POP	AX
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	3-5
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	SYSTEM INITIALIZATION

 01B7  E8 1864 R	 	 	CALL	.CHRIN	 	;WAIT UNTIL READY
 01BA  E8 18F0 R	 	 	CALL	.CRLF
 01BD  E8 1245 R	 	OSV3C$:	CALL	NEWZPC	 	;PAGE MAY HAVE CHANGED, LOSER!
 01C0  9D	 	 	 	POPF	 	 	;GET FLAGS BACK
 01C1  72 0C	 	 	 	JC	OSV4$
 01C3  A0 0023 R	 	 	MOV	AL,SCRFLG	;GET CURRENT SCRIPT STATE
 	 	 	 	 	PTAWRD	[PFLAGS],A	;AND MAKE RESTORED FLAGS REFLECT IT
 01C6  86 E0                  +	 	XCHG	AH,AL
 01C8  26: A3 0010            +	 	MOV	ES:[PFLAGS],AX
 01CC  E9 0C17 R	 	 	JMP	PTRUE
 01CF  E8 18F0 R	 	OSV4$:	CALL	.CRLF
 01D2  E9 0C12 R	 	 	JMP	PFALSE
 01D5	 	 	 	OPSAVE	ENDP
 	 	 	 	
 01D5	 	 	 	OPRSTT	PROC
 01D5  8B 2E 02C6 R	 	 	MOV	BP,CHRPTR
 01D9  3E: C6 46 00 00	 	 	MOV	BYTE PTR DS:[BP],0	;FORCE OUT THE BUFFER
 	 	 	 	 	PRINT	OUTBUF
 01DE  50                     +	 	PUSH	AX
 01DF  B8 04F5 R              +	 	MOV	AX,OFFSET OUTBUF
 01E2  E8 196F R              +	 	CALL	.PRINT
 01E5  58                     +	 	POP	AX
 01E6  E9 10C2 R	 	 	JMP	RESTRT	 	 	;JUMP TO RESTART ADDRESS
 01E9	 	 	 	OPRSTT	ENDP
 	 	 	 	
 01E9	 	 	 	OPQUIT	PROC
 01E9  E9 1A47 R	 	 	JMP	FINISH
 01EC	 	 	 	OPQUIT	ENDP
 	 	 	 	
 01EC	 	 	 	OPSCRN	PROC
 01EC  2A E4	 	 	 	SUB	AH,AH	 	; ONLY HAVE LOWER BYTE
 01EE  A2 02D9 R	 	 	MOV	CURSCR,AL	; put screen # into current screen
 01F1  3D 0000	 	 	 	CMP	AX,0	 	; was it 0
 01F4  75 1B	 	 	 	JNE	OPSCR1	 	; no then test #1
 01F6  8B 16 0021 R	 	 	MOV	DX,OLDCUR	; save old cursor position
 01FA  80 3E 0020 R 00	 	 	CMP	COLFLG,0	; TEST IF COLOR ON
 01FF  74 08	 	 	 	JZ	DIP1
 0201  C6 06 0000 R 17	 	 	MOV	NRMATR,17H	; give them color
 0206  EB 34 90	 	 	 	JMP	OPSCR2
 0209  C6 06 0000 R 07	 	DIP1:	MOV	NRMATR,07H	; GIVE THEN NOTHING
 020E  EB 2C 90	 	 	 	JMP	OPSCR2
 	 	 	 	
 0211  3D 0001	 	 	OPSCR1:	CMP	AX,1	 	; was it 1
 0214  75 2C	 	 	 	JNE	OPSCR3
 	 	 	 	 	CURGET
 0216  50                     +	 	PUSH	AX
 0217  2A FF                  +	 	SUB	BH,BH
 0219  B4 03                  +	 	MOV	AH,3
 021B  CD 10                  +	 	INT	10H
 021D  58                     +	 	POP	AX
 021E  89 16 0021 R	 	 	MOV	OLDCUR,DX	; no then ignore
 0222  80 3E 0020 R 00	 	 	CMP	COLFLG,0	; TEST IF COLOR ON
 0227  74 08	 	 	 	JZ	DIP3
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	3-6
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	SYSTEM INITIALIZATION

 0229  C6 06 0000 R 75	 	 	MOV	NRMATR,75H	; give them color
 022E  EB 06 90	 	 	 	JMP	DIP4
 	 	 	 	
 0231  C6 06 0000 R 07	 	DIP3:	MOV	NRMATR,07H	; GIVE THEM NOTHING
 0236  B6 01	 	 	DIP4:	MOV	DH,1	 	; put it at 1,1
 0238  8A 16 02DA R	 	 	MOV	DL,LFTMAR	; UPPER LEFT-HAND CORNER
 023C  B4 02	 	 	OPSCR2:	MOV	AH,2	 	; set cursor
 023E  B7 00	 	 	 	MOV	BH,0	 	; graphics page
 0240  CD 10	 	 	 	INT	10H
 0242  C3	 	 	OPSCR3:	RET	
 0243	 	 	 	OPSCRN	ENDP
 	 	 	 	
 0243	 	 	 	OPSPLT	PROC
 0243  3D 0000	 	 	 	CMP	AX,0	 	; split zero
 0246  74 4A	 	 	 	JE	OPSPLU
 	 	 	 	 	CURGET
 0248  50                     +	 	PUSH	AX
 0249  2A FF                  +	 	SUB	BH,BH
 024B  B4 03                  +	 	MOV	AH,3
 024D  CD 10                  +	 	INT	10H
 024F  58                     +	 	POP	AX
 0250  89 16 0021 R	 	 	MOV	OLDCUR,DX
 0254  29 06 095C R	 	 	SUB	LINMAX,AX	; subtract max plus one
 0258  05 0001	 	 	 	ADD	AX,1
 025B  A2 02D8 R	 	 	MOV	SCRN0,AL	; USED IN SCROLL FOR CRLF
 025E  8A 0E 02DA R	 	 	MOV	CL,LFTMAR
 0262  B5 01	 	 	 	MOV	CH,01	 	; UPPER LEFT CORNER
 0264  8B 16 02D6 R	 	 	MOV	DX,RWIDTH	; LOWER RIGHT ROW
 0268  2A 16 02DA R	 	 	SUB	DL,LFTMAR
 026C  80 EA 01	 	 	 	SUB	DL,1
 026F  8A 36 02D8 R	 	 	MOV	DH,SCRN0	; LOWER RIGHT COLUMN
 0273  B0 00	 	 	 	MOV	AL,0	 	; blank entire screen
 0275  B4 06	 	 	 	MOV	AH,6	 	; clear the screen
 0277  80 3E 0020 R 00	 	 	CMP	COLFLG,0	; IS IT COLOR?
 027C  74 05	 	 	 	JZ	DAN1	
 027E  B7 2F	 	 	 	MOV	BH,2FH	 	; WHITE ON GREEN
 0280  EB 03 90	 	 	 	JMP	DAN2
 0283  B7 07	 	 	DAN1:	MOV	BH,07H	 	; IF NO COLOR THEN BLACK ON WHITE	
 0285  CD 10	 	 	DAN2:	INT	10H	 	; CLEAR TOP WINDOW
 0287  8B 16 0021 R	 	 	MOV	DX,OLDCUR	; GET BACK CURSOR POSITION
 028B  B4 02	 	 	 	MOV	AH,2	 	; set cursor
 028D  2A FF	 	 	 	SUB	BH,BH	 	; make sure it's zero
 028F  CD 10	 	 	 	INT	10H
 0291  C3	 	 	 	RET
 	 	 	 	
 0292  C6 06 02D8 R 01	 	OPSPLU:	MOV	SCRN0,1
 0297  B8 0017	 	 	 	MOV	AX,LINMXX
 029A  A3 095C R	 	 	MOV	LINMAX,AX
 029D  C7 06 095A R 0000	 	MOV	MORLIN,0	;RESET MORE COUNT
 02A3  C3	 	 	 	RET
 02A4	 	 	 	OPSPLT	ENDP
 	 	 	 	
 02A4	 	 	 	OPUSL	PROC
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	3-7
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	SYSTEM INITIALIZATION

 02A4  57	 	 	 	PUSH	DI
 02A5  C6 06 004B R 01	 	 	MOV	USLMOD,1
 	 	 	 	 	CURGET	 	 	;GET THE CURSOR LOCATION
 02AA  50                     +	 	PUSH	AX
 02AB  2A FF                  +	 	SUB	BH,BH
 02AD  B4 03                  +	 	MOV	AH,3
 02AF  CD 10                  +	 	INT	10H
 02B1  58                     +	 	POP	AX
 02B2  52	 	 	 	PUSH	DX	 	;SAVE IT FOR A RAINY DAY
 02B3  B8 0010	 	 	 	MOV	AX,16	 	;FIRST GLOBAL (ROOM)
 02B6  8B 3E 004F R	 	 	MOV	DI,SLTAB	;USL TABLE IN FORCE
 02BA  B9 0003	 	 	 	MOV	CX,3	 	;NUMBER OF THINGS WE PRINT
 02BD  50	 	 	USLLP$:	PUSH	AX
 02BE  E8 0BA0 R	 	 	CALL	GETVAR	 	;GET THE GLOBAL
 02C1  3B 05	 	 	 	CMP	AX,[DI]	 	;HAS IT CHANGED
 02C3  74 2F	 	 	 	JE	USL1$	 	;THANK GOD, NO
 	 	 	 	 	CURSET	[DI+4]	 	;MOVE THE CURSOR TO THE RIGHT PLACE
 02C5  50                     +	 	PUSH	AX
 02C6  2A FF                  +	 	SUB	BH,BH
 02C8  B4 02                  +	 	MOV	AH,2
 02CA  8B 55 04               +	 	MOV	DX,[DI+4]
 02CD  CD 10                  +	 	INT	10H
 02CF  58                     +	 	POP	AX
 02D0  51	 	 	 	PUSH	CX
 02D1  57	 	 	 	PUSH	DI
 02D2  FF 55 02	 	 	 	CALL	WORD PTR [DI+2]	;CALL THE PROPER ROUTINE
 	 	 	 	 	CURGET	 	 	;WHERE IS THE CURSOR NOW?
 02D5  50                     +	 	PUSH	AX
 02D6  2A FF                  +	 	SUB	BH,BH
 02D8  B4 03                  +	 	MOV	AH,3
 02DA  CD 10                  +	 	INT	10H
 02DC  58                     +	 	POP	AX
 02DD  5F	 	 	 	POP	DI
 02DE  2B 55 06	 	 	 	SUB	DX,[DI+6]	;WHERE IS THE END OF THE FIELD?
 02E1  F7 DA	 	 	 	NEG	DX
 02E3  7E 0B	 	 	 	JLE	USLN$	 	;DONT PRINT ZERO OR LESS SPACES
 02E5  8A C2	 	 	 	MOV	AL,DL
 02E7  8A 26 0001 R	 	 	MOV	AH,USLATR	;THIS IS REVERSE VIDEO
 02EB  57	 	 	 	PUSH	DI
 02EC  E8 18C2 R	 	 	CALL	.SPACE	 	;PRINT THAT MANY SPACES
 02EF  5F	 	 	 	POP	DI
 02F0  83 C7 08	 	 	USLN$:	ADD	DI,8	 	;POINT TO NEXT TABLE ENTRY
 02F3  59	 	 	 	POP	CX	 	;RESTORE REGISTERS
 02F4  58	 	 	USL1$:	POP	AX
 02F5  40	 	 	 	INC	AX	 	;POINT TO NEXT GLOBAL
 02F6  E2 C5	 	 	 	LOOP	USLLP$	 	;DO ALL THREE THEN LEAVE
 02F8  5A	 	 	 	POP	DX
 	 	 	 	 	CURSET	DX	 	;IT MAY OR MAY NOT BE RAINING, BUT....
 02F9  50                     +	 	PUSH	AX
 02FA  2A FF                  +	 	SUB	BH,BH
 02FC  B4 02                  +	 	MOV	AH,2
 02FE  8B D2                  +	 	MOV	DX,DX
 0300  CD 10                  +	 	INT	10H
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	3-8
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	SYSTEM INITIALIZATION

 0302  58                     +	 	POP	AX
 0303  C6 06 004B R 00	 	 	MOV	USLMOD,0
 0308  5F	 	 	 	POP	DI
 0309  C3	 	 	 	RET
 030A	 	 	 	OPUSL	ENDP
 	 	 	 	
 	 	 	 	 	SUBTTL	ARITHMETIC OPERATIONS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	4-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	ARITHMETIC OPERATIONS

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	 	;ADD
 030A	 	 	 	OPADD	PROC
 030A  03 C3	 	 	 	ADD	AX,BX	 	;ADD OPR1 AND OPR2
 030C  E9 0C02 R	 	 	JMP	PUTVAL	 	;RETURN THE VALUE
 030F	 	 	 	OPADD	ENDP
 	 	 	 	
 	 	 	 	 	;SUB
 030F	 	 	 	OPSUB	PROC
 030F  2B C3	 	 	  	SUB	AX,BX	 	;SUBTRACT OPR2 FROM OPR1
 0311  E9 0C02 R	 	 	JMP	PUTVAL	 	;RETURN THE VALUE
 0314	 	 	 	OPSUB	ENDP
 	 	 	 	
 	 	 	 	 	;MULTIPLY AX BY BX
 0314	 	 	 	OPMUL	PROC
 0314  F7 EB	 	 	 	IMUL	BX	 	;MULTIPLY OPR1 BY OPR2,IGNORING OVERFLOW(DX)
 0316  E9 0C02 R	 	 	JMP	PUTVAL	 	;RETURN THE VALUE
 0319	 	 	 	OPMUL	ENDP
 	 	 	 	
 	 	 	 	 	;DIVIDE AX BY BX
 0319	 	 	 	OPDIV	PROC
 0319  99	 	 	 	CWD	 	 	;CLEAR HIGH WORD AND EXTEND SIGN FOR DIVIDE
 031A  F7 FB	 	 	 	IDIV	BX	 	;DIVIDE OPR1 BY OPR2
 031C  E9 0C02 R	 	 	JMP	PUTVAL	 	;RETURN THE VALUE
 031F	 	 	 	OPDIV	ENDP
 	 	 	 	
 	 	 	 	 	;MOD
 031F	 	 	 	OPMOD	PROC
 031F  99	 	 	 	CWD	 	 	;CLEAR HIGH WORD AND EXTEND SIGN FOR DIVIDE
 0320  F7 FB	 	 	 	IDIV	BX	 	;DIVIDE OPR1 BY OPR2
 0322  8B C2	 	 	 	MOV	AX,DX	 	;WE WANT REMAINDER
 0324  E9 0C02 R	 	 	JMP	PUTVAL	 	;RETURN THE VALUE
 0327	 	 	 	OPMOD	ENDP
 	 	 	 	
 	 	 	 	 	;RANDOM
 0327	 	 	 	OPRAND	PROC
 0327  2A E4	 	 	 	SUB	AH,AH
 0329  A3 02B3 R	 	 	MOV	RTEMP,AX
 032C  A1 02AF R	 	 	MOV	AX,RSEED1
 032F  8B 1E 02B1 R	 	 	MOV	BX,RSEED2
 0333  A3 02B1 R	 	 	MOV	RSEED2,AX
 0336  F8	 	 	 	CLC
 0337  D1 D8	 	 	 	RCR	AX,1
 0339  D1 DB	 	 	 	RCR	BX,1
 033B  31 1E 02AF R	 	 	XOR	RSEED1,BX
 033F  A1 02AF R	 	 	MOV	AX,RSEED1
 0342  25 EFFF	 	 	 	AND	AX,0EFFFH
 0345  2B D2	 	 	 	SUB	DX,DX
 0347  F7 36 02B3 R	 	 	DIV	RTEMP
 034B  8B C2	 	 	 	MOV	AX,DX
 034D  40	 	 	 	INC	AX	 	;MUST BE BETWEEN 1 AND N, INCLUSIVE
 034E  F6 06 066C R 04	 	 	TEST	INIFLG,INIRND
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	4-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	ARITHMETIC OPERATIONS

 0353  75 03	 	 	 	JNZ	OPRN1$
 0355  E9 0C02 R	 	 	JMP	PUTVAL	 	;SIMPLY RETURN
 0358  50	 	 	OPRN1$:	PUSH	AX
 0359  E8 09A4 R	 	 	CALL	OPPRNN	 	;PRINT NUMBER
 035C  B0 20	 	 	 	MOV	AL,32
 035E  E8 0E61 R	 	 	CALL	PUTCHR
 0361  58	 	 	 	POP	AX
 0362  E9 0C02 R	 	 	JMP	PUTVAL	 	;RETURN THE VALUE
 0365	 	 	 	OPRAND	ENDP
 	 	 	 	
 	 	 	 	 	;LESS?
 0365	 	 	 	OPQLES	PROC
 0365  3B C3	 	 	 	CMP	AX,BX	 	;IS OPR1 LESS THAN OPR2?
 0367  7C 03	 	 	 	JL 	JPT	 	;YES, PREDICATE TRUE
 0369  E9 0C12 R	 	JPF:	JMP	PFALSE	 	;NO, PREDICATE FALSE
 036C  E9 0C17 R	 	JPT:	JMP	PTRUE
 036F	 	 	 	OPQLES	ENDP
 	 	 	 	
 	 	 	 	 	;GRTR?
 036F	 	 	 	OPQGRT	PROC
 036F  3B C3	 	 	 	CMP	AX,BX	 	;IS OPR1 GREATER THAN OPR2?
 0371  7F F9	 	 	 	JG 	JPT	 	;YES, PREDICATE TRUE
 0373  EB F4	 	 	 	JMP	JPF	 	;NO, PREDICATE FALSE
 0375	 	 	 	OPQGRT	ENDP
 	 	 	 	
 	 	 	 	 	SUBTTL	LOGICAL OPERATIONS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	5-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	LOGICAL OPERATIONS

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	 	;BTST
 0375	 	 	 	OPBTST	PROC
 0375  F7 D0	 	 	 	NOT	AX	 	;TURN OFF BITS IN OPR2 THAT ARE ON IN OPR1
 0377  23 D8	 	 	 	AND	BX,AX
 0379  74 F1	 	 	 	JE	JPT	 	;SUCCESS IF OPR2 COMPLETELY CLEARED
 037B  EB EC	 	 	 	JMP	JPF
 037D	 	 	 	OPBTST	ENDP
 	 	 	 	
 	 	 	 	 	;BOR
 037D	 	 	 	OPBOR	PROC
 037D  0B C3	 	 	 	OR	AX,BX	 	;LOGICAL OR
 037F  E9 0C02 R	 	 	JMP	PUTVAL	 	;RETURN THE VALUE
 0382	 	 	 	OPBOR	ENDP
 	 	 	 	
 	 	 	 	 	;BCOM
 0382	 	 	 	OPBCOM	PROC	
 0382  F7 D0	 	 	 	NOT	AX	 	;LOGICAL COMPLEMENT
 0384  E9 0C02 R	 	 	JMP	PUTVAL	 	;RETURN THE VALUE
 0387	 	 	 	OPBCOM	ENDP
 	 	 	 	
 	 	 	 	 	;BAND
 0387	 	 	 	OPBAND	PROC
 0387  23 C3	 	 	 	AND	AX,BX	 	;LOGICAL AND
 0389  E9 0C02 R	 	 	JMP	PUTVAL	 	;RETURN THE VALUE
 038C	 	 	 	OPBAND	ENDP
 	 	 	 	
 	 	 	 	 	SUBTTL	GENERAL PREDICATES
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	6-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	GENERAL PREDICATES

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	 	;EQUAL?
 038C	 	 	 	OPQEQU	PROC
 038C  90	 	 	 	NOP	 	 	;TELL CALLER TO USE ARGUMENT BLOCK
 038D  8B 1E 0673 R	 	 	MOV	BX,ARGBLK	;GET OPR1
 0391  3B 1E 0675 R	 	 	CMP	BX,ARGBLK[2]	;IS OPR1 EQUAL TO OPR2?
 0395  74 16	 	 	 	JE	OQE1$	 	;YES
 0397  3D 0003	 	 	 	CMP	AX,3	 	;NO, IS THERE A THIRD OPERAND?
 039A  7C 14	 	 	 	JL	OQE2$	 	;NO
 039C  3B 1E 0677 R	 	 	CMP	BX,ARGBLK[4]	;YES, IS IT EQUAL TO OPR1?
 03A0  74 0B	 	 	 	JE	OQE1$	 	;YES
 03A2  3D 0004	 	 	 	CMP	AX,4	 	;NO, IS THERE A FOURTH?
 03A5  7C 09	 	 	 	JL	OQE2$	 	;NO
 03A7  3B 1E 0679 R	 	 	CMP	BX,ARGBLK[6]	;YES, IS IT EQUAL TO OPR1?
 03AB  75 03	 	 	 	JNE	OQE2$	 	;NO
 03AD  E9 0C17 R	 	OQE1$:	JMP	PTRUE	 	;PREDICATE TRUE IF EQUAL
 03B0  E9 0C12 R	 	OQE2$:	JMP	PFALSE	 	;PREDICATE FALSE IF NOT
 03B3	 	 	 	OPQEQU	ENDP
 	 	 	 	
 	 	 	 	 	;ZERO?
 03B3	 	 	 	OPQZER	PROC
 03B3  3D 0000	 	 	 	CMP	AX,0	 	;IS OPR ZERO?
 03B6  75 03	 	 	 	JNE	OQZ1$	 	;NO, PREDICATE FALSE
 03B8  E9 0C17 R	 	 	JMP	PTRUE	 	;YES, PREDICATE TRUE
 03BB  E9 0C12 R	 	OQZ1$:	JMP	PFALSE
 03BE	 	 	 	OPQZER	ENDP
 	 	 	 	
 	 	 	 	 	SUBTTL	OBJECT OPERATIONS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	7-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	OBJECT OPERATIONS

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	 	;MOVE (OBJ1 INTO OBJ2)
 03BE	 	 	 	OPMOVE	PROC
 03BE  50	 	 	 	PUSH	AX	 	;PROTECT OPRS FROM REMOVE CALL
 03BF  53	 	 	 	PUSH	BX
 03C0  E8 03E9 R	 	 	CALL	OPREMO	 	;REMOVE OBJ1 FROM WHEREVER IT IS
 03C3  5A	 	 	 	POP	DX	 	;OBJ2
 03C4  8B C2	 	 	 	MOV	AX,DX
 03C6  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND ITS LOCATION
 03C9  8B D8	 	 	 	MOV	BX,AX	 	;MOVE TO BASE
 03CB  59	 	 	 	POP	CX	 	;OBJ1
 03CC  8B C1	 	 	 	MOV	AX,CX
 03CE  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND ITS LOCATION
 03D1  8B E8	 	 	 	MOV	BP,AX	 	;MOVE TO BASE
 03D3  26: 88 56 04	 	 	MOV	ES:[BP].PARENT,DL	;PUT OBJ2 INTO OBJ1'S LOC SLOT
 03D7  26: 8A 77 06	 	 	MOV	DH,ES:[BX].CHILD1	;GET CONTENTS OF OBJ2'S FIRST SLOT
 03DB  26: 88 4F 06	 	 	MOV	ES:[BX].CHILD1,CL	;MAKE OBJ1 FIRST CONTENT OF OBJ2
 03DF  80 FE 00	 	 	 	CMP	DH,0	 	;WERE THERE ANY OTHER CONTENTS?
 03E2  74 04	 	 	 	JE	OMV1$	 	;NO
 03E4  26: 88 76 05	 	 	MOV	ES:[BP].SIBLING,DH	;YES, CHAIN ONTO OBJ1'S SIBLING SLOT
 03E8  C3	 	 	OMV1$:	RET
 03E9	 	 	 	OPMOVE	ENDP
 	 	 	 	
 	 	 	 	 	;REMOVE (OBJ FROM ITS PARENT)
 03E9	 	 	 	OPREMO	PROC
 03E9  8B C8	 	 	 	MOV	CX,AX	 	;SAVE OBJ FOR LATER
 03EB  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND ITS LOCATION
 03EE  8B D8	 	 	 	MOV	BX,AX	 	;MOVE TO BASE
 03F0  26: 8A 6F 04	 	 	MOV	CH,ES:[BX].PARENT	;GET ITS PARENT
 03F4  80 FD 00	 	 	 	CMP	CH,0	 	;DOES IT HAVE A PARENT?
 03F7  74 3B	 	 	 	JE	ORM3$	 	;IF NOT, WE'RE DONE
 03F9  8A C5	 	 	 	MOV	AL,CH	 	;PARENT
 03FB  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND PARENT'S LOCATION
 03FE  8B E8	 	 	 	MOV	BP,AX	 	;MOVE TO BASE
 0400  26: 8A 56 06	 	 	MOV	DL,ES:[BP].CHILD1	;GET PARENT'S FIRST CONTENT
 0404  3A D1	 	 	 	CMP	DL,CL	 	;IS IT OBJ?
 0406  75 0B	 	 	 	JNE	ORM1$	 	;NO
 	 	 	 	 	MOVM	ES:[BP].CHILD1,ES:[BX].SIBLING,AL	;YES, CHANGE SLOT TO
 0408  26: 8A 47 05           +	 	MOV	AL,ES:[BX].SIBLING
 040C  26: 88 46 06           +	 	MOV	ES:[BP].CHILD1,AL
 	 	 	 	 	 	 	 	 	 	 	;OBJ'S SIBLING
 0410  EB 18 90	 	 	 	JMP	ORM2$	 	;AND RETURN
 0413  8A C2	 	 	ORM1$:	MOV	AL,DL	 	;CURRENT SIBLING
 0415  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND ITS LOCATION
 0418  8B E8	 	 	 	MOV	BP,AX	 	;MOVE TO BASE
 041A  26: 8A 56 05	 	 	MOV	DL,ES:[BP].SIBLING	;GET NEXT SIBLING IN CHAIN
 041E  3A D1	 	 	 	CMP	DL,CL	 	;IS IT OBJ?
 0420  75 F1	 	 	 	JNE	ORM1$	 	;NO, CONTINUE LOOP
 	 	 	 	 	MOVM	ES:[BP].SIBLING,ES:[BX].SIBLING,AL	;YES, CHANGE IT TO
 0422  26: 8A 47 05           +	 	MOV	AL,ES:[BX].SIBLING
 0426  26: 88 46 05           +	 	MOV	ES:[BP].SIBLING,AL
 	 	 	 	 	 	 	 	 	 	 	;OBJ'S SIBLING
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	7-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	OBJECT OPERATIONS

 042A  26: C6 47 04 00	 	ORM2$:	MOV	ES:[BX].PARENT,0	;OBJ NOW HAS NO PARENT
 042F  26: C6 47 05 00	 	 	MOV	ES:[BX].SIBLING,0	;OR SIBLING
 0434  C3	 	 	ORM3$:	RET
 0435	 	 	 	OPREMO	ENDP
 	 	 	 	
 	 	 	 	 	;FSET? (IS FLAG SET IN OBJ?)
 0435	 	 	 	OPQFSE	PROC
 0435  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND OBJ'S LOCATION
 0438  83 FB 10	 	 	 	CMP	BX,16	 	;SECOND WORD FLAG?
 043B  7C 05	 	 	 	JL	OQF1$	 	;NO
 043D  83 EB 10	 	 	 	SUB	BX,16	 	;YES, SUBTRACT 16 FROM FLAG NUMBER
 0440  40	 	 	 	INC	AX	 	;AND USE SECOND FLAG WORD
 0441  40	 	 	 	INC	AX
 0442  8B CB	 	 	OQF1$:	MOV	CX,BX	 	;MOVE TO COUNT
 0444  8B D8	 	 	 	MOV	BX,AX	 	;MOVE TO BASE
 	 	 	 	 	GTAWRD	A,[BX]	 	;GET THE FLAG WORD
 0446  26: 8B 07              +	 	MOV	AX,ES:[BX]
 0449  86 E0                  +	 	XCHG	AH,AL
 044B  BA 8000	 	 	 	MOV	DX,8000H	;SHIFT A BIT TO PROPER POSITION
 044E  D3 EA	 	 	 	SHR	DX,CL
 0450  85 C2	 	 	 	TEST	AX,DX	 	;IS THIS BIT SET IN FLAG WORD?
 0452  74 03	 	 	 	JE	OQF2$	 	;NO, PREDICATE FALSE
 0454  E9 0C17 R	 	 	JMP	PTRUE	 	;YES, PREDICATE TRUE
 0457  E9 0C12 R	 	OQF2$:	JMP	PFALSE
 045A	 	 	 	OPQFSE	ENDP
 	 	 	 	
 	 	 	 	 	;FSET (SET A FLAG IN OBJ)
 045A	 	 	 	OPFSET	PROC
 045A  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND OBJ'S LOCATION
 045D  83 FB 10	 	 	 	CMP	BX,16	 	;SECOND WORD FLAG?
 0460  7C 05	 	 	 	JL	OFS1$	 	;NO
 0462  83 EB 10	 	 	 	SUB	BX,16	 	;YES, SUBTRACT 16 FROM FLAG NUMBER
 0465  40	 	 	 	INC	AX	 	;AND USE SECOND FLAG WORD
 0466  40	 	 	 	INC	AX
 0467  8B CB	 	 	OFS1$:	MOV	CX,BX	 	;MOVE TO COUNT
 0469  8B D8	 	 	 	MOV	BX,AX	 	;MOVE TO BASE
 	 	 	 	 	GTAWRD	A,[BX]	 	;GET THE FLAG WORD
 046B  26: 8B 07              +	 	MOV	AX,ES:[BX]
 046E  86 E0                  +	 	XCHG	AH,AL
 0470  BA 8000	 	 	 	MOV	DX,8000H	;SHIFT A BIT TO PROPER POSITION
 0473  D3 EA	 	 	 	SHR	DX,CL
 0475  0B C2	 	 	 	OR	AX,DX	 	;SET THIS BIT IN FLAG WORD
 	 	 	 	 	PTAWRD	[BX],A	 	;STORE THE NEW FLAG WORD
 0477  86 E0                  +	 	XCHG	AH,AL
 0479  26: 89 07              +	 	MOV	ES:[BX],AX
 047C  C3	 	 	 	RET
 047D	 	 	 	OPFSET	ENDP
 	 	 	 	
 	 	 	 	 	;FCLEAR (CLEAR A FLAG IN OBJ)
 047D	 	 	 	OPFCLE	PROC
 047D  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND OBJ'S LOCATION
 0480  83 FB 10	 	 	 	CMP	BX,16	 	;SECOND WORD FLAG?
 0483  7C 05	 	 	 	JL	OFC1$	 	;NO
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	7-3
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	OBJECT OPERATIONS

 0485  83 EB 10	 	 	 	SUB	BX,16	 	;YES, SUBTRACT 16 FROM FLAG NUMBER
 0488  40	 	 	 	INC	AX	 	;AND USE SECOND FLAG WORD
 0489  40	 	 	 	INC	AX
 048A  8B CB	 	 	OFC1$:	MOV	CX,BX	 	;MOVE TO COUNT
 048C  8B D8	 	 	 	MOV	BX,AX	 	;MOVE TO BASE
 	 	 	 	 	GTAWRD	A,[BX]	 	;GET THE FLAG WORD
 048E  26: 8B 07              +	 	MOV	AX,ES:[BX]
 0491  86 E0                  +	 	XCHG	AH,AL
 0493  BA 7FFF	 	 	 	MOV	DX,7FFFH	;SHIFT A BIT TO PROPER POSITION
 0496  D3 CA	 	 	 	ROR	DX,CL
 0498  23 C2	 	 	 	AND	AX,DX	 	;CLEAR THIS BIT IN FLAG WORD
 	 	 	 	 	PTAWRD	[BX],A	 	;STORE THE NEW FLAG WORD
 049A  86 E0                  +	 	XCHG	AH,AL
 049C  26: 89 07              +	 	MOV	ES:[BX],AX
 049F  C3	 	 	 	RET
 04A0	 	 	 	OPFCLE	ENDP
 	 	 	 	
 	 	 	 	 	;LOC (RETURN CONTAINER OF OBJ)
 04A0	 	 	 	OPLOC	PROC
 04A0  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND OBJ'S LOCATION
 04A3  8B D8	 	 	 	MOV	BX,AX	 	;MOVE TO BASE
 04A5  26: 8A 47 04	 	 	MOV	AL,ES:[BX].PARENT	;GET LOC SLOT
 04A9  E9 0BFD R	 	 	JMP	BYTVAL	 	;RETURN THE BYTE VALUE
 04AC	 	 	 	OPLOC	ENDP
 	 	 	 	
 	 	 	 	 	;FIRST? (RETURN FIRST SLOT OF OBJ, FAIL IF NONE)
 04AC	 	 	 	OPQFIR	PROC
 04AC  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND OBJ'S LOCATION
 04AF  8B D8	 	 	 	MOV	BX,AX	 	;MOVE TO BASE
 04B1  26: 8A 47 06	 	 	MOV	AL,ES:[BX].CHILD1	;GET FIRST SLOT
 04B5  50	 	 	 	PUSH	AX	 	;SAVE IT
 04B6  E8 0BFD R	 	 	CALL	BYTVAL	 	;RETURN THE BYTE VALUE
 04B9  58	 	 	 	POP	AX	 	;RESTORE IT
 04BA  3C 00	 	 	 	CMP	AL,0	 	;WAS IT ZERO?
 04BC  74 03	 	 	 	JE	JPF1	 	;YES, PREDICATE FALSE
 04BE  E9 0C17 R	 	JPT1:	JMP	PTRUE	 	;NO, PREDICATE TRUE
 04C1  E9 0C12 R	 	JPF1:	JMP	PFALSE
 04C4	 	 	 	OPQFIR	ENDP
 	 	 	 	
 	 	 	 	 	;NEXT? (RETURN THE NEXT (SIBLING) SLOT OF OBJ, FAIL IF NONE)
 04C4	 	 	 	OPQNEX	PROC
 04C4  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND OBJ'S LOCATION
 04C7  8B D8	 	 	 	MOV	BX,AX	 	;MOVE TO BASE
 04C9  26: 8A 47 05	 	 	MOV	AL,ES:[BX].SIBLING	;GET SIBLING SLOT
 04CD  50	 	 	 	PUSH	AX	 	;SAVE IT
 04CE  E8 0BFD R	 	 	CALL	BYTVAL	 	;RETURN THE BYTE VALUE
 04D1  58	 	 	 	POP	AX	 	;RESTORE IT
 04D2  3C 00	 	 	 	CMP	AL,0	 	;WAS IT ZERO?
 04D4  74 EB	 	 	 	JE	JPF1	 	;YES, PREDICATE FALSE
 04D6  EB E6	 	 	 	JMP	JPT1	 	;NO, PREDICATE TRUE
 04D8	 	 	 	OPQNEX	ENDP
 	 	 	 	
 	 	 	 	 	;IN? (IS OBJ1 CONTAINED IN OBJ2?)
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	7-4
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	OBJECT OPERATIONS

 04D8	 	 	 	OPQIN	PROC
 04D8  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND OBJ1'S LOCATION
 04DB  93	 	 	 	XCHG	AX,BX	 	;MOVE TO BASE
 04DC  26: 38 47 04	 	 	CMP	ES:[BX].PARENT,AL	;IS OBJ1'S PARENT OBJ2?
 04E0  74 DC	 	 	 	JE	JPT1	 	;YES, PREDICATE TRUE
 04E2  EB DD	 	 	 	JMP	JPF1	 	;NO, PREDICATE FALSE
 04E4	 	 	 	OPQIN	ENDP
 	 	 	 	
 	 	 	 	 	;GETP (GET SPECIFIED PROPERTY OF OBJ, DEFAULT IF NONE)
 04E4	 	 	 	OPGETP	PROC
 04E4  8B D3	 	 	 	MOV	DX,BX	 	;PROPERTY
 04E6  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND OBJ'S LOCATION
 04E9  8B E8	 	 	 	MOV	BP,AX	 	;MOVE TO BASE
 	 	 	 	 	GTAWRD	B,[BP].PROPS	;GET LOCATION OF ITS PROPERTY TABLE
 04EB  26: 8B 5E 07           +	 	MOV	BX,ES:[BP].PROPS
 04EF  86 FB                  +	 	XCHG	BH,BL
 04F1  26: 8A 07	 	 	MOV	AL,ES:[BX]	;LENGTH OF SHORT DESCRIPTION IN WORDS
 04F4  2A E4	 	 	 	SUB	AH,AH	 	;CLEAN OFF ANY HIGH-ORDER BYTE
 04F6  D1 E0	 	 	 	SHL	AX,1	 	;CONVERT TO BYTES
 04F8  03 D8	 	 	 	ADD	BX,AX	 	;ADJUST POINTER TO SKIP IT
 04FA  43	 	 	 	INC	BX	 	;ALSO SKIP LENGTH BYTE
 04FB  EB 04 90	 	 	 	JMP	OGP2$	 	;SKIP NEXT LINE FIRST TIME THROUGH LOOP
 04FE  E8 0C8C R	 	OGP1$:	CALL	NXTPRP	 	;POINT TO NEXT PROPERTY
 0501  26: 8A 07	 	OGP2$:	MOV	AL,ES:[BX]	;GET PROPERTY IDENTIFIER
 0504  24 1F	 	 	 	AND	AL,MASK	PROPNUM	;CLEAN OFF LENGTH BITS
 0506  3A C2	 	 	 	CMP	AL,DL	 	;COMPARE PROPERTY NUMBER WITH DESIRED ONE
 0508  7F F4	 	 	 	JG	OGP1$	 	;IF GREATER, LOOP (TABLE SORTED IN REVERSE)
 050A  7C 14	 	 	 	JL	OGP3$	 	;IF LESS, NO SUCH PROPERTY HERE
 050C  26: 8A 07	 	 	MOV	AL,ES:[BX]	;GOT IT, NOW FIND LENGTH OF PROPERTY
 050F  43	 	 	 	INC	BX	 	;POINT TO PROPERTY VALUE
 0510  24 E0	 	 	 	AND	AL,MASK PROPSIZE;GET LENGTH BITS
 0512  B1 05	 	 	 	MOV	CL,PROPSIZE
 0514  D2 E8	 	 	 	SHR	AL,CL
 0516  3C 00	 	 	 	CMP	AL,0	 	;BYTE VALUE?
 0518  75 0F	 	 	 	JNE	OGP5$	 	;NO
 051A  26: 8A 07	 	 	MOV	AL,ES:[BX]	;GET THE BYTE
 051D  E9 0BFD R	 	 	JMP	BYTVAL	 	;AND RETURN IT
 0520  4A	 	 	OGP3$:	DEC	DX	 	;POINT INTO DEFAULT PROPERTY TABLE
 0521  D1 E2	 	 	 	SHL	DX,1
 0523  8B DA	 	 	 	MOV	BX,DX
 0525  03 1E 02E5 R	 	OGP4$:	ADD	BX,OBJTAB	;GET THE WORD
 0529	 	 	 	OGP5$:	GTAWRD	A,[BX]	
 0529  26: 8B 07              +	 	MOV	AX,ES:[BX]
 052C  86 E0                  +	 	XCHG	AH,AL
 052E  E9 0C02 R	 	 	JMP	PUTVAL	 	;AND RETURN IT
 0531	 	 	 	OPGETP	ENDP
 	 	 	 	
 	 	 	 	 	;PUTP (CHANGE VALUE OF A PROPERTY, ERROR IF BAD NUMBER)
 0531	 	 	 	OPPUTP	PROC
 0531  51	 	 	 	PUSH	CX	 	;SAVE NEW VALUE
 0532  8B D3	 	 	 	MOV	DX,BX	 	;PROPERTY
 0534  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND OBJ'S LOCATION
 0537  8B E8	 	 	 	MOV	BP,AX	 	;MOVE TO BASE
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	7-5
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	OBJECT OPERATIONS

 	 	 	 	 	GTAWRD	B,[BP].PROPS	;GET LOCATION OF ITS PROPERTY TABLE
 0539  26: 8B 5E 07           +	 	MOV	BX,ES:[BP].PROPS
 053D  86 FB                  +	 	XCHG	BH,BL
 053F  26: 8A 07	 	 	MOV	AL,ES:[BX]	;LENGTH OF SHORT DESCRIPTION IN WORDS
 0542  2A E4	 	 	 	SUB	AH,AH	 	;CLEAN OFF ANY HIGH-ORDER BYTE
 0544  D1 E0	 	 	 	SHL	AX,1	 	;CONVERT TO BYTES
 0546  03 D8	 	 	 	ADD	BX,AX	 	;ADJUST POINTER TO SKIP IT
 0548  43	 	 	 	INC	BX	 	;ALSO SKIP LENGTH BYTE
 0549  EB 04 90	 	 	 	JMP	OPP2$	 	;SKIP NEXT LINE FIRST TIME THROUGH LOOP
 054C  E8 0C8C R	 	OPP1$:	CALL	NXTPRP	 	;POINT TO NEXT PROPERTY
 054F  26: 8A 07	 	OPP2$:	MOV	AL,ES:[BX]	;GET PROPERTY IDENTIFIER
 0552  24 1F	 	 	 	AND	AL,MASK PROPNUM	;CLEAN OFF LENGTH BITS
 0554  3A C2	 	 	 	CMP	AL,DL	 	;COMPARE PROPERTY NUMBER WITH DESIRED ONE
 0556  74 14	 	 	 	JE	OPP3$	 	;IF EQUAL, GOT IT
 0558  7F F2	 	 	 	JG	OPP1$	 	;IF GREATER, LOOP (TABLE SORTED IN REVERSE)
 	 	 	 	 	FATAL	FTL2	 	;OTHERWISE, FATAL ERROR
 055A  E8 18F0 R              +	 	CALL	.CRLF
 055D  B8 09DF R              +	 	MOV	AX,OFFSET FATHDR
 0560  E8 196F R              +	 	CALL	.PRINT
 0563  B8 0983 R              +	 	MOV	AX,OFFSET FTL2
 0566  E8 196F R              +	 	CALL	.PRINT
 0569  E9 1A47 R              +	 	JMP	FINISH
 056C  26: 8A 07	 	OPP3$:	MOV	AL,ES:[BX]	;NOW FIND LENGTH OF PROPERTY
 056F  43	 	 	 	INC	BX	 	;POINT TO PROPERTY VALUE
 0570  24 E0	 	 	 	AND	AL,MASK PROPSIZE;GET LENGTH BITS
 0572  B1 05	 	 	 	MOV	CL,PROPSIZE
 0574  D2 E8	 	 	 	SHR	AL,CL
 0576  3C 00	 	 	 	CMP	AL,0	 	;BYTE VALUE?
 0578  58	 	 	 	POP	AX	 	;RESTORE NEW VALUE
 0579  75 04	 	 	 	JNE	OPP4$	 	;ZERO MEANS BYTE VALUE
 057B  26: 88 07	 	 	MOV	ES:[BX],AL	;STORE THE NEW BYTE
 057E  C3	 	 	 	RET	 	 	;AND RETURN
 057F	 	 	 	OPP4$:	PTAWRD	[BX],A	 	;STORE THE NEW WORD VALUE
 057F  86 E0                  +	 	XCHG	AH,AL
 0581  26: 89 07              +	 	MOV	ES:[BX],AX
 0584  C3	 	 	 	RET
 0585	 	 	 	OPPUTP	ENDP
 	 	 	 	
 	 	 	 	 	;NEXTP (RETURN NUMBER OF NEXT PROP FOLLOWING GIVEN PROB IN OBJ)
 0585	 	 	 	OPNEXT	PROC
 0585  8B D3	 	 	 	MOV	DX,BX	 	;PROPERTY
 0587  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND OBJ'S LOCATION
 058A  8B E8	 	 	 	MOV	BP,AX	 	;MOVE TO BASE
 	 	 	 	 	GTAWRD	B,[BP].PROPS	;GET ITS LOCATION
 058C  26: 8B 5E 07           +	 	MOV	BX,ES:[BP].PROPS
 0590  86 FB                  +	 	XCHG	BH,BL
 0592  26: 8A 07	 	 	MOV	AL,ES:[BX]	;LENGTH OF SHORT DESCRIPTION IN WORDS
 0595  2A E4	 	 	 	SUB	AH,AH	 	;CLEAN OFF ANY HIGH-ORDER BYTE
 0597  D1 E0	 	 	 	SHL	AX,1	 	;CONVERT TO BYTES
 0599  03 D8	 	 	 	ADD	BX,AX	 	;ADJUST POINTER TO SKIP IT
 059B  43	 	 	 	INC	BX	 	;ALSO SKIP LENGTH BYTE
 059C  83 FA 00	 	 	 	CMP	DX,0	 	;WERE WE GIVEN ZERO AS PROP?
 059F  74 26	 	 	 	JE	ONX4$	 	;YES, GO RETURN FIRST PROPERTY NUMBER
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	7-6
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	OBJECT OPERATIONS

 05A1  EB 04 90	 	 	 	JMP	ONX2$	 	;NO, SKIP NEXT LINE FIRST TIME THROUGH LOOP
 05A4  E8 0C8C R	 	ONX1$:	CALL	NXTPRP	 	;POINT TO NEXT PROPERTY
 05A7  26: 8A 07	 	ONX2$:	MOV	AL,ES:[BX]	;GET PROPERTY IDENTIFIER
 05AA  24 1F	 	 	 	AND	AL,MASK PROPNUM	;CLEAN OFF LENGTH BITS
 05AC  3A C2	 	 	 	CMP	AL,DL	 	;COMPARE PROPERTY NUMBER WITH DESIRED ONE
 05AE  74 14	 	 	 	JE	ONX3$	 	;IF EQUAL, GOT IT
 05B0  7F F2	 	 	 	JG	ONX1$	 	;IF GREATER, LOOP (TABLE SORTED IN REVERSE)
 	 	 	 	 	FATAL	FTL2	 	;OTHERWISE, FATAL ERROR
 05B2  E8 18F0 R              +	 	CALL	.CRLF
 05B5  B8 09DF R              +	 	MOV	AX,OFFSET FATHDR
 05B8  E8 196F R              +	 	CALL	.PRINT
 05BB  B8 0983 R              +	 	MOV	AX,OFFSET FTL2
 05BE  E8 196F R              +	 	CALL	.PRINT
 05C1  E9 1A47 R              +	 	JMP	FINISH
 05C4  E8 0C8C R	 	ONX3$:	CALL	NXTPRP	 	;POINT TO NEXT PROPERTY
 05C7  26: 8A 07	 	ONX4$:	MOV	AL,ES:[BX]	;GET PROPERTY IDENTIFIER
 05CA  24 1F	 	 	 	AND	AL,MASK PROPNUM	;EXTRACT PROPERTY NUMBER
 05CC  E9 0C02 R	 	 	JMP	PUTVAL	 	;AND RETURN IT
 05CF	 	 	 	OPNEXT	ENDP
 	 	 	 	
 	 	 	 	 	SUBTTL	TABLE OPERATIONS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	8-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	TABLE OPERATIONS

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	 	;GET (GET THE ITEM'TH WORD FROM TABLE)
 05CF	 	 	 	OPGET	PROC
 05CF  D1 E3	 	 	 	SHL	BX,1	 	;CONVERT ITEM TO BYTE COUNT
 05D1  03 C3	 	 	 	ADD	AX,BX	 	;INDEX INTO TABLE
 05D3  E8 0C5D R	 	 	CALL	BSPLTB	 	;SPLIT THE POINTER
 05D6  E8 0B53 R	 	 	CALL	GETWRD	 	;GET THE WORD
 05D9  8B C1	 	 	 	MOV	AX,CX
 05DB  E9 0C02 R	 	 	JMP	PUTVAL	 	;AND RETURN IT
 05DE	 	 	 	OPGET	ENDP
 	 	 	 	
 	 	 	 	 	;GETB (GET THE ITEM'TH BYTE FROM TABLE)
 05DE	 	 	 	OPGETB	PROC
 05DE  03 C3	 	 	 	ADD	AX,BX	 	;INDEX INTO TABLE
 05E0  E8 0C5D R	 	 	CALL	BSPLTB	 	;SPLIT THE POINTER
 05E3  E8 0B26 R	 	 	CALL	GETBYT	 	;GET THE BYTE
 05E6  8B C1	 	 	 	MOV	AX,CX
 05E8  E9 0BFD R	 	 	JMP	BYTVAL	 	;AND RETURN IT
 05EB	 	 	 	OPGETB	ENDP
 	 	 	 	
 	 	 	 	 	;PUT (REPLACE THE ITEM'TH WORD IN TABLE)
 05EB	 	 	 	OPPUT	PROC
 05EB  D1 E3	 	 	 	SHL	BX,1	 	;CONVERT ITEM TO BYTE COUNT
 05ED  03 D8	 	 	 	ADD	BX,AX	 	;INDEX INTO TABLE
 	 	 	 	 	PTAWRD	[BX],C	 	;STORE THE WORD
 05EF  86 E9                  +	 	XCHG	CH,CL
 05F1  26: 89 0F              +	 	MOV	ES:[BX],CX
 05F4  C3	 	 	 	RET
 05F5	 	 	 	OPPUT	ENDP
 	 	 	 	
 	 	 	 	 	;PUTB (REPLACE ITEM'TH BYTE IN TABLE)
 05F5	 	 	 	OPPUTB	PROC
 05F5  03 D8	 	 	 	ADD	BX,AX	 	;INDEX INTO TABLE
 05F7  26: 88 0F	 	 	MOV	ES:[BX],CL	;STORE BYTE
 05FA  C3	 	 	 	RET
 05FB	 	 	 	OPPUTB	ENDP
 	 	 	 	
 	 	 	 	 	;GETPT (GET POINTER TO PROPERTY TABLE FOR GIVEN PROP)
 05FB	 	 	 	OPGTPT	PROC
 05FB  8B D3	 	 	 	MOV	DX,BX	 	;PROPERTY
 05FD  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND OBJ'S LOCATION
 0600  8B E8	 	 	 	MOV	BP,AX	 	;MOVE TO BASE
 	 	 	 	 	GTAWRD	B,[BP].PROPS	;GET LOCATION OF ITS PROPERTY TABLE
 0602  26: 8B 5E 07           +	 	MOV	BX,ES:[BP].PROPS
 0606  86 FB                  +	 	XCHG	BH,BL
 0608  26: 8A 07	 	 	MOV	AL,ES:[BX]	;LENGTH OF SHORT DESCRIPTION IN WORDS
 060B  2A E4	 	 	 	SUB	AH,AH	 	;CLEAN OFF ANY HIGH-ORDER BYTE
 060D  D1 E0	 	 	 	SHL	AX,1	 	;CONVERT TO BYTES
 060F  03 D8	 	 	 	ADD	BX,AX	 	;ADJUST POINTER TO SKIP IT
 0611  43	 	 	 	INC	BX	 	;ALSO SKIP LENGTH BYTE
 0612  EB 04 90	 	 	 	JMP	OGT2$	 	;SKIP NEXT LINE FIRST TIME THROUGH LOOP
 0615  E8 0C8C R	 	OGT1$:	CALL	NXTPRP	 	;POINT TO NEXT PROPERTY
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	8-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	TABLE OPERATIONS

 0618  26: 8A 07	 	OGT2$:	MOV	AL,ES:[BX]	;GET PROPERTY IDENTIFIER
 061B  24 1F	 	 	 	AND	AL,MASK PROPNUM	;CLEAN OFF LENGTH BITS
 061D  3A C2	 	 	 	CMP	AL,DL	 	;COMPARE PROPERTY NUMBER WITH DESIRED ONE
 061F  7F F4	 	 	 	JG	OGT1$	 	;IF GREATER, LOOP (TABLE SORTED IN REVERSE)
 0621  74 05	 	 	 	JE	OGT3$	 	;FOUND THE PROPERTY
 0623  2B C0	 	 	 	SUB	AX,AX	 	;RETURN ZERO FOR NO SUCH PROPERTY
 0625  EB 04 90	 	 	 	JMP	OGT4$
 0628  43	 	 	OGT3$:	INC	BX	 	;POINT TO PROPERTY VALUE
 0629  8B C3	 	 	 	MOV	AX,BX	 	;AND RETURN IT
 062B  E9 0C02 R	 	OGT4$:	JMP	PUTVAL
 062E	 	 	 	OPGTPT	ENDP
 	 	 	 	
 	 	 	 	 	;PTSIZE (RETURN SIZE OF PROPERTY TABLE)
 062E	 	 	 	OPPTSI	PROC
 062E  8B D8	 	 	 	MOV	BX,AX	 	;TABLE POINTER
 0630  26: 8A 47 FF	 	 	MOV	AL,ES:[BX-1]	;GET PROPERTY INDENTIFIER
 0634  24 E0	 	 	 	AND	AL,MASK PROPSIZE;EXTRACT LENGTH BITS
 0636  2A E4	 	 	 	SUB	AH,AH
 0638  B1 05	 	 	 	MOV	CL,PROPSIZE
 063A  D3 E8	 	 	 	SHR	AX,CL
 063C  40	 	 	 	INC	AX	 	;ADJUST TO ACTUAL LENGTH
 063D  E9 0C02 R	 	 	JMP	PUTVAL	 	;RETURN IT
 0640	 	 	 	OPPTSI	ENDP
 	 	 	 	
 	 	 	 	 	SUBTTL	VARIABLE OPERATIONS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	9-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	VARIABLE OPERATIONS

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	 	;VALUE (GET VALUE OF VAR)
 0640	 	 	 	OPVALU	PROC
 0640  E8 0BA0 R	 	 	CALL	GETVAR	 	;GET THE VALUE
 0643  E9 0C02 R	 	 	JMP	PUTVAL	 	;AND RETURN IT
 0646	 	 	 	OPVALU	ENDP
 	 	 	 	
 	 	 	 	 	;SET (VAR TO VALUE)
 0646	 	 	 	OPSET	PROC
 0646  E9 0BD0 R	 	 	JMP	PUTVAR	 	;STORE THE VALUE
 0649	 	 	 	OPSET	ENDP
 	 	 	 	
 	 	 	 	 	;PUSH (A VALUE ONTO THE STACK)
 0649	 	 	 	OPPUSH	PROC
 	 	 	 	 	PUSHZ	AX	 	;PUSH THE VALUE
 0649  87 E7                  +	 	XCHG	SP,DI
 064B  50                     +	 	PUSH	AX
 064C  87 E7                  +	 	XCHG	SP,DI
 064E  C3	 	 	 	RET
 064F	 	 	 	OPPUSH	ENDP
 	 	 	 	
 	 	 	 	 	;POP (A VALUE OFF THE STACK INTO VAR)
 064F	 	 	 	OPPOP	PROC
 	 	 	 	 	POPZ	BX	 	;POP A VALUE
 064F  87 E7                  +	 	XCHG	SP,DI
 0651  5B                     +	 	POP	BX
 0652  87 E7                  +	 	XCHG	SP,DI
 0654  E9 0BD0 R	 	 	JMP	PUTVAR	 	;AND STORE IT
 0657	 	 	 	OPPOP	ENDP
 	 	 	 	
 	 	 	 	 	;INC (INCREMENT VAR)
 0657	 	 	 	OPINC	PROC
 0657  8B C8	 	 	 	MOV	CX,AX	 	;VARIABLE
 0659  E8 0BA0 R	 	 	CALL	GETVAR	 	;GET VAR'S VALUE
 065C  40	 	 	 	INC	AX	 	;INCREMENT IT
 065D  8B D8	 	 	OPINC1:	MOV	BX,AX	 	;VALUE
 065F  8B C1	 	 	 	MOV	AX,CX	 	;VARIABLE
 0661  E9 0BD0 R	 	 	JMP	PUTVAR	 	;STORE NEW VALUE
 0664	 	 	 	OPINC	ENDP
 	 	 	 	
 	 	 	 	 	;DEC (DECREMENT VAR)
 0664	 	 	 	OPDEC	PROC
 0664  8B C8	 	 	 	MOV	CX,AX	 	;VARIABLE
 0666  E8 0BA0 R	 	 	CALL	GETVAR	 	;GET VAR'S VALUE
 0669  48	 	 	 	DEC	AX	 	;DECREMENT IT
 066A  EB F1	 	 	 	JMP	OPINC1	 	;STORE NEW VALUE
 066C	 	 	 	OPDEC	ENDP
 	 	 	 	
 	 	 	 	 	;IGRTR? (INCREMENT VAR & TEST IF GREATER THAN VAL)
 066C	 	 	 	OPQIGR	PROC
 066C  50	 	 	 	PUSH	AX	 	;SAVE VARIABLE
 066D  E8 0BA0 R	 	 	CALL	GETVAR	 	;GET VAR'S VALUE
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	9-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	VARIABLE OPERATIONS

 0670  40	 	 	 	INC	AX	 	;INCREMENT IT
 0671  2B C9	 	 	 	SUB	CX,CX	 	;SET FLAG FALSE
 0673  3B C3	 	 	 	CMP	AX,BX	 	;NEW VALUE GREATER THAN VAL?
 0675  7E 01	 	 	 	JLE	OPQIG1	 	;NO
 0677  41	 	 	OPQIG0:	INC	CX	 	;YES, CHANGE FLAG TO TRUE
 0678  8B D8	 	 	OPQIG1:	MOV	BX,AX	 	;VALUE
 067A  58	 	 	 	POP	AX	 	;RESTORE VARIABLE
 067B  E8 0BD0 R	 	 	CALL	PUTVAR	 	;STORE NEW VALUE
 067E  83 F9 00	 	 	 	CMP	CX,0	 	;TEST FLAG
 0681  74 03	 	 	 	JE	OQI1$	 	;FALSE, PREDICATE FALSE
 0683  E9 0C17 R	 	 	JMP	PTRUE	 	;ELSE, PREDICATE TRUE
 0686  E9 0C12 R	 	OQI1$:	JMP	PFALSE
 0689	 	 	 	OPQIGR	ENDP
 	 	 	 	
 	 	 	 	 	;DLESS? (DECREMENT VAR & TEST IF LESS THAN VAL)
 0689	 	 	 	OPQDLE	PROC
 0689  50	 	 	 	PUSH	AX	 	;SAVE VARIABLE
 068A  E8 0BA0 R	 	 	CALL	GETVAR	 	;GET VAR'S VALUE
 068D  48	 	 	 	DEC	AX	 	;DECREMENT IT
 068E  2B C9	 	 	 	SUB	CX,CX	 	;SET FLAG FALSE
 0690  3B C3	 	 	 	CMP	AX,BX	 	;NEW VALUE LESS THAN VAL?
 0692  7D E4	 	 	 	JGE	OPQIG1	 	;NO, PREDICATE FALSE
 0694  EB E1	 	 	 	JMP	OPQIG0	 	;YES, PREDICATE TRUE
 0696	 	 	 	OPQDLE	ENDP
 	 	 	 	
 	 	 	 	 	SUBTTL	I/O OPERATIONS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	10-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	I/O OPERATIONS

 	 	 	 	 	PAGE	+
 	 	 	 	
 = 000A	 	 	 	EOLCHR	EQU	10	 	;LINE-FEED IS END-OF-LINE CHARACTER
 	 	 	 	
 0696	 	 	 	GETLIN	PROC
 0696  53	 	 	 	PUSH	BX
 0697  A0 0023 R	 	 	MOV	AL,SCRFLG
 069A  50	 	 	 	PUSH	AX
 069B  C6 06 0023 R 00	 	 	MOV	SCRFLG,0	;DEFEAT SCRIPTING DURING INPUT
 06A0  8B D6	 	 	 	MOV	DX,SI	 	;HOLD ON TO STA
 06A2  26: 8A 0C	 	 	MOV	CL,ES:[SI]
 06A5  2A ED	 	 	 	SUB	CH,CH	 	;CX HAS MAX # CHARACTERS TO READ
 06A7  46	 	 	 	INC	SI	 	;SI HAS POINTER TO LINE BUFFER
 06A8  E8 1864 R	 	GTLL$:	CALL	.CHRIN	 	;GET A CHARACTER
 06AB  3C 0A	 	 	 	CMP	AL,EOLCHR	;IS IT END OF LINE?
 06AD  74 04	 	 	 	JE	GTLX$
 06AF  3C 0D	 	 	 	CMP	AL,13
 06B1  75 09	 	 	 	JNE	GTL0$
 06B3  E8 18F0 R	 	GTLX$:	CALL	.CRLF
 06B6  58	 	 	 	POP	AX
 06B7  A2 0023 R	 	 	MOV	SCRFLG,AL	;RESET SCRIPT FLAG
 06BA  5B	 	 	 	POP	BX
 06BB  C3	 	 	 	RET	 	 	;OUR WORK IS DONE
 06BC  3C 08	 	 	GTL0$:	CMP	AL,8	 	;WAS IT A BACKSPACE
 06BE  75 44	 	 	 	JNE	GTL1$
 06C0  8B C6	 	 	 	MOV	AX,SI
 06C2  2C 01	 	 	 	SUB	AL,1
 06C4  3B D0	 	 	 	CMP	DX,AX	 	;ARE WE AT BEGINNING OF BUFFER?
 06C6  75 0C	 	 	 	JNE	GTL2$
 06C8  B8 0007	 	 	GTLF$:	MOV	AX,7
 06CB  E8 1887 R	 	 	CALL	.TTYOUT	 	;FEEP AT HIM NOW
 06CE  EB D8	 	 	 	JMP	GTLL$
 06D0  4E	 	 	GTLL1$:	DEC	SI	 	;MOVE BUFFER AND COUNT BACK (OR FORWARD)
 06D1  41	 	 	 	INC	CX
 06D2  EB D4	 	 	 	JMP	GTLL$
 06D4  52	 	 	GTL2$:	PUSH	DX
 06D5  51	 	 	 	PUSH	CX
 	 	 	 	 	CURGET	 	 	;READ THE CURSOR (DH = ROW, DL = COLUMN)
 06D6  50                     +	 	PUSH	AX
 06D7  2A FF                  +	 	SUB	BH,BH
 06D9  B4 03                  +	 	MOV	AH,3
 06DB  CD 10                  +	 	INT	10H
 06DD  58                     +	 	POP	AX
 06DE  59	 	 	 	POP	CX
 06DF  3A 16 02DA R	 	 	CMP	DL,LFTMAR	;ARE WE AT BEGINNING OF A LINE?
 06E3  75 08	 	 	 	JNE	GTL3$
 06E5  80 EE 01	 	 	 	SUB	DH,1	 	;PREVIOUS LINE
 06E8  A1 02D4 R	 	 	MOV	AX,TWIDTH
 06EB  8A D0	 	 	 	MOV	DL,AL	 	;END OF LINE
 06ED  80 EA 01	 	 	GTL3$:	SUB	DL,1	 	;CURSET/GET ARE ZERO BASED
 	 	 	 	 	CURSET	 	 	;MOVE IT THERE
 06F0  50                     +	 	PUSH	AX
 06F1  2A FF                  +	 	SUB	BH,BH
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	10-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	I/O OPERATIONS

 06F3  B4 02                  +	 	MOV	AH,2
 06F5  CD 10                  +	 	INT	10H
 06F7  58                     +	 	POP	AX
 06F8  B0 01	 	 	 	MOV	AL,1
 06FA  8A 26 0000 R	 	 	MOV	AH,NRMATR	;NO ATTRIBUTES, ONE SPACE
 06FE  E8 18C2 R	 	 	CALL	.SPACE	 	;WRITE THE SPACE
 0701  5A	 	 	 	POP	DX
 0702  EB CC	 	 	 	JMP	GTLL1$	 	;LOOP BACK
 	 	 	 	
 0704  E3 C2	 	 	GTL1$:	JCXZ	GTLF$	 	;BUFFER FULL
 0706  8A 26 0002 R	 	 	MOV	AH,TYPATR	
 070A  E8 1887 R	 	 	CALL	.TTYOUT	 	;ECHO THE CHARACTER
 070D  50	 	 	 	PUSH	AX
 070E  52	 	 	 	PUSH	DX
 070F  51	 	 	 	PUSH	CX
 	 	 	 	 	CURGET	 	 	;FIND THE CURSOR
 0710  50                     +	 	PUSH	AX
 0711  2A FF                  +	 	SUB	BH,BH
 0713  B4 03                  +	 	MOV	AH,3
 0715  CD 10                  +	 	INT	10H
 0717  58                     +	 	POP	AX
 0718  59	 	 	 	POP	CX
 0719  A1 02D4 R	 	 	MOV	AX,TWIDTH
 071C  3A D0	 	 	 	CMP	DL,AL	 	;CHECK IF AT END OF LINE
 071E  75 03	 	 	 	JNZ	GTL5$
 0720  E8 18F0 R	 	 	CALL	.CRLF	 	;MAKE A NICE CRLF AT END OF LINE
 0723  5A	 	 	GTL5$:	POP	DX
 0724  58	 	 	 	POP	AX
 0725  3C 41	 	 	GTL4$:	CMP	AL,"A"	 	; CHECK UPPER CASE RANGE A-Z
 0727  7C 06	 	 	 	JL	GTLD$
 0729  3C 5A	 	 	 	CMP	AL,"Z"
 072B  7F 02	 	 	 	JG	GTLD$
 072D  04 20	 	 	 	ADD	AL,20H	 	;ADJUST FOR LOWER CASE
 072F  26: 88 04	 	GTLD$:	MOV	ES:[SI],AL	; *** THIS PUTS CHAR. IN BUFFER ***
 0732  46	 	 	 	INC	SI	 	;MOVE POINTER, COUNT FORWARD
 0733  FE C9	 	 	 	DEC	CL
 0735  E9 06A8 R	 	 	JMP	GTLL$
 0738	 	 	 	GETLIN	ENDP
 	 	 	 	
 0738	 	 	 	PRTLOS	PROC
 0738  A0 0023 R	 	 	MOV	AL,SCRFLG
 073B  50	 	 	 	PUSH	AX
 073C  52	 	 	 	PUSH	DX
 073D  C6 06 0023 R 00	 	 	MOV	SCRFLG,0	;TURN OFF SCRIPTING TO AVOID GETTING HUNG
 	 	 	 	 	PRINT	PRNRDY
 0742  50                     +	 	PUSH	AX
 0743  B8 0024 R              +	 	MOV	AX,OFFSET PRNRDY
 0746  E8 196F R              +	 	CALL	.PRINT
 0749  58                     +	 	POP	AX
 074A  E8 1864 R	 	PRNL$:	CALL	.CHRIN
 074D  3C 41	 	 	 	CMP	AL,"A"
 074F  74 13	 	 	 	JE	PRNA$
 0751  3C 61	 	 	 	CMP	AL,"a"
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	10-3
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	I/O OPERATIONS

 0753  74 0F	 	 	 	JE	PRNA$
 0755  3C 52	 	 	 	CMP	AL,"R"
 0757  74 17	 	 	 	JE	PRNR$
 0759  3C 72	 	 	 	CMP	AL,"r"
 075B  74 13	 	 	 	JE	PRNR$
 075D  B0 07	 	 	 	MOV	AL,7
 075F  E8 1887 R	 	 	CALL	.TTYOUT
 0762  EB E6	 	 	 	JMP	PRNL$
 0764  F8	 	 	PRNA$:	CLC
 0765  9C	 	 	PRNEX$:	PUSHF
 0766  E8 18F0 R	 	 	CALL	.CRLF
 0769  9D	 	 	 	POPF
 076A  5A	 	 	 	POP	DX
 076B  58	 	 	 	POP	AX
 076C  A2 0023 R	 	 	MOV	SCRFLG,AL	;RESTORE SCRIPT FLAG
 076F  C3	 	 	 	RET
 0770  F9	 	 	PRNR$:	STC
 0771  EB F2	 	 	 	JMP	PRNEX$
 0773	 	 	 	PRTLOS	ENDP
 	 	 	 	
 0773	 	 	 	PRTOUT	PROC
 0773  B4 00	 	 	PRTRT$:	MOV	AH,0	 	;CODE FOR OUTPUT TO PRINTER PORT
 0775  BA 0000	 	 	 	MOV	DX,0
 0778  CD 17	 	 	 	INT	17H	 	;FORCE IT OUT
 077A  F6 C4 01	 	 	 	TEST	AH,1	 	;ERROR TIME OUT CODE
 077D  74 1B	 	 	 	JZ	PRTO1$	 	;LOST ON TIME OUT
 077F  E8 0738 R	 	 	CALL	PRTLOS
 0782  72 EF	 	 	 	JC	PRTRT$	 	;RETRY IF SO ORDERED
 	 	 	 	 	GTAWRD	A,[PFLAGS]
 0784  26: A1 0010            +	 	MOV	AX,ES:[PFLAGS]
 0788  86 E0                  +	 	XCHG	AH,AL
 078A  25 FFFE	 	 	 	AND	AX,0FFFEH	;TURN OFF THE SCRIPT BIT
 	 	 	 	 	PTAWRD	[PFLAGS],A	
 078D  86 E0                  +	 	XCHG	AH,AL
 078F  26: A3 0010            +	 	MOV	ES:[PFLAGS],AX
 0793  C6 06 0023 R 00	 	 	MOV	SCRFLG,0	;AND UNSET THE FLAG
 0798  F9	 	 	 	STC	 	 	;INDICATE LOSER WANTS ABORT
 0799  C3	 	 	 	RET
 079A  F8	 	 	PRTO1$:	CLC	 	 	;INDICATE WIN
 079B  C3	 	 	 	RET
 079C	 	 	 	PRTOUT	ENDP
 	 	 	 	
 079C	 	 	 	SCRCHK	PROC
 079C  50	 	 	 	PUSH	AX
 079D  53	 	 	 	PUSH	BX
 079E  52	 	 	 	PUSH	DX
 	 	 	 	 	GTAWRD	A,[PFLAGS]
 079F  26: A1 0010            +	 	MOV	AX,ES:[PFLAGS]
 07A3  86 E0                  +	 	XCHG	AH,AL
 07A5  A8 01	 	 	 	TEST	AL,1	 	;CHECK IF SCRIPTING IS REQUESTED
 07A7  74 63	 	 	 	JZ	SCRNN$
 07A9  80 3E 0023 R 00	 	 	CMP	SCRFLG,0	;CHECK WHETHER THIS IS A NEW STATE
 07AE  75 2F	 	 	 	JNE	SCR1$
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	10-4
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	I/O OPERATIONS

 07B0  52	 	 	SCRR1$:	PUSH	DX
 07B1  BA 0000	 	 	 	MOV	DX,0	 	;FIRST PRINTER SLOT
 07B4  B4 01	 	 	 	MOV	AH,1
 07B6  CD 17	 	 	 	INT	17H	 	;INITIALIZE PORT
 07B8  F6 C4 A1	 	 	 	TEST	AH,0A1H	 	;CHECK FOR TIME OUT,BUSY, OUT OF PAPER
 07BB  75 04	 	 	 	JNZ	SCRR2$
 07BD  5A	 	 	 	POP	DX
 07BE  EB 1F 90	 	 	 	JMP	SCR1$
 07C1  5A	 	 	SCRR2$:	POP	DX
 07C2  E8 0738 R	 	 	CALL	PRTLOS	 	;ASK USER WHAT TO DO NOW?
 07C5  72 E9	 	 	 	JC	SCRR1$	 	;RETRY
 	 	 	 	 	GTAWRD	A,[PFLAGS]
 07C7  26: A1 0010            +	 	MOV	AX,ES:[PFLAGS]
 07CB  86 E0                  +	 	XCHG	AH,AL
 07CD  25 FFFE	 	 	 	AND	AX,0FFFEH	;TURN OFF THE SCRIPT BIT
 	 	 	 	 	PTAWRD	[PFLAGS],A	
 07D0  86 E0                  +	 	XCHG	AH,AL
 07D2  26: A3 0010            +	 	MOV	ES:[PFLAGS],AX
 07D6  C6 06 0023 R 00	 	 	MOV	SCRFLG,0	;AND FLAG
 07DB  5A	 	 	SCREX$:	POP	DX
 07DC  5B	 	 	 	POP	BX
 07DD  58	 	 	 	POP	AX
 07DE  C3	 	 	 	RET
 07DF  C6 06 0023 R 01	 	SCR1$:	MOV	SCRFLG,1
 07E4  2B C9	 	 	 	SUB	CX,CX	 	;COUNT OF CHARS PRINTED
 07E6  8B EA	 	 	 	MOV	BP,DX	 	;START OF INPUT LINE
 07E8  45	 	 	 	INC	BP	 	;FIRST CHAR IS LENGTH OF BUFFER
 07E9  26: 8A 46 00	 	SCR1L$:	MOV	AL,ES:[BP]
 07ED  45	 	 	 	INC	BP	 	;GET CHARACTER
 07EE  3B EE	 	 	 	CMP	BP,SI	 	;END OF INPUT?
 07F0  7E 05	 	 	 	JLE	SCR2L$
 07F2  E8 0813 R	 	 	CALL	PRTCRL
 07F5  EB E4	 	 	 	JMP	SCREX$
 07F7  E8 0773 R	 	SCR2L$:	CALL	PRTOUT	 	;OUTPUT ONE CHARACTER TO THE PRINTER
 07FA  72 DF	 	 	 	JC	SCREX$	 	;THIS MEANS SCRIPTING ABORTED
 07FC  41	 	 	 	INC	CX
 07FD  3B 0E 02D4 R	 	 	CMP	CX,TWIDTH
 0801  75 E6	 	 	 	JNE	SCR1L$
 0803  E8 0813 R	 	 	CALL	PRTCRL
 0806  72 D3	 	 	 	JC	SCREX$
 0808  2B C9	 	 	 	SUB	CX,CX	 	;RESTART COUNT
 080A  EB DD	 	 	 	JMP	SCR1L$	 	;GO FOR MORE	
 	 	 	 	
 080C  C6 06 0023 R 00	 	SCRNN$:	MOV	SCRFLG,0
 0811  EB C8	 	 	 	JMP	SCREX$
 0813	 	 	 	SCRCHK	ENDP
 	 	 	 	
 0813	 	 	 	PRTCRL	PROC
 0813  B0 0D	 	 	 	MOV	AL,13	 	;FINISH UP WITH CRLF
 0815  E8 0773 R	 	 	CALL	PRTOUT
 0818  B0 0A	 	 	 	MOV	AL,10
 081A  E8 0773 R	 	 	CALL	PRTOUT
 081D  C3	 	 	 	RET
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	10-5
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	I/O OPERATIONS

 081E	 	 	 	PRTCRL	ENDP
 	 	 	 	
 	 	 	 	 	;READ (A LINE OF INPUT & PARSE IT, LINE BUF IN ES:AX,
 	 	 	 	 	;RETURN BUF IN ES:BX)
 081E	 	 	 	OPREAD	PROC
 081E  50	 	 	 	PUSH	AX	 	;SAVE LINE BUF
 081F  50	 	 	 	PUSH	AX
 0820  53	 	 	 	PUSH	BX
 0821  E8 02A4 R	 	 	CALL	OPUSL	 	;UPDATE STATUS LINE
 0824  5B	 	 	 	POP	BX
 0825  58	 	 	 	POP	AX
 0826  8B 2E 02C6 R	 	 	MOV	BP,CHRPTR	;NEXT CHARACTER POSITION
 082A  3E: C6 46 00 80	 	 	MOV	BYTE PTR DS:[BP],80H ;DON'T END OUTPUT, IF ANY, WITH NEW LINE
 082F	 	 	 	ORD1$:	PRINT	OUTBUF	 	;FORCE OUT ANY QUEUED TEXT
 082F  50                     +	 	PUSH	AX
 0830  B8 04F5 R              +	 	MOV	AX,OFFSET OUTBUF
 0833  E8 196F R              +	 	CALL	.PRINT
 0836  58                     +	 	POP	AX
 0837  C7 06 02C6 R 04F5 R	 	MOV	CHRPTR,OFFSET OUTBUF  ;RESET CHARACTER POINTER
 083D  5E	 	 	 	POP	SI	 	;INPUT BUFFER POINTER
 083E  C7 06 095A R 0000	 	MOV	MORLIN,0	;RE-INITIALIZE MORE COUNT FROM HERE
 0844  E8 0696 R	 	 	CALL	GETLIN	 	;GET SOME CHARACTERS
 0847  E8 079C R	 	 	CALL	SCRCHK	 	;CHECK FOR SCRIPTING, SCRIPT INPUT IF ON
 084A  57	 	 	ORDNS$:	PUSH	DI
 084B  89 16 02BD R	 	 	MOV	RDBOS,DX	;INITIALIZE RDBOS
 084F  89 36 02BF R	 	 	MOV	RDEOS,SI	;AND RDEOS
 0853  89 1E 02C1 R	 	 	MOV	RDRET,BX	;STORE RET POINTER
 0857  C6 06 02C3 R 00	 	 	MOV	RDNWDS,0	;NO WORDS SO FAR
 085C  42	 	 	 	INC	DX	 	;SKIP LENGTH BYTE
 085D  8B FB	 	 	 	MOV	DI,BX	 	;THIS WILL BE WORD ENTRY POINTER
 085F  47	 	 	 	INC	DI	 	;SKIP MAX WORDS & NWORDS BYTES
 0860  47	 	 	 	INC	DI
 0861  B9 02B5 R	 	ORD8$:	MOV	CX,OFFSET RDWSTR;HERE FOR NEXT WORD, POINT TO WORD STRING
 0864  8B DA	 	 	 	MOV	BX,DX	 	;AND SAVE BEGINNING OF WORD POINTER
 0866  3B 16 02BF R	 	ORD9$:	CMP	DX,RDEOS	;END OF STRING?
 086A  75 09	 	 	 	JNE	ORD10$	 	;NO
 086C  81 F9 02B5 R	 	 	CMP	CX,OFFSET RDWSTR;YES, WAS A WORD FOUND?
 0870  75 4B	 	 	 	JNE	ORD15$	 	;YES, WE STILL HAVE TO LOOKUP WORD
 0872  E9 098F R	 	 	JMP	ORD23$	 	;NO, WE'RE DONE
 0875  8B EA	 	 	ORD10$:	MOV	BP,DX	 	;GET NEXT CHARACTER FROM BUFFER
 0877  26: 8A 46 00	 	 	MOV	AL,ES:[BP]
 087B  3C 41	 	 	 	CMP	AL,"A"
 087D  7C 06	 	 	 	JL	ORD1A$
 087F  3C 5A	 	 	 	CMP	AL,"Z"
 0881  7F 02	 	 	 	JG	ORD1A$
 0883  04 20	 	 	 	ADD	AL,32	 	;LOWERCASIFY ALPHABETICS
 0885  42	 	 	ORD1A$:	INC	DX
 0886  BE 0546 R	 	 	MOV	SI,OFFSET RBRKS	;LIST OF READ BREAK CHARACTERS
 0889  46	 	 	ORD11$:	INC	SI
 088A  3A 44 FF	 	 	 	CMP	AL,[SI-1]	;SEARCH LIST FOR THIS ONE
 088D  74 14	 	 	 	JE	ORD12$	 	;FOUND IT
 088F  80 3C 00	 	 	 	CMP	BYTE PTR [SI],0  ;END OF LIST?
 0892  75 F5	 	 	 	JNE	ORD11$	 	;NO, CONTINUE SEARCH
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	10-6
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	I/O OPERATIONS

 0894  81 F9 02BB R	 	 	CMP	CX,OFFSET RDWSTR[6]  ;YES, NOT A BREAK, WORD STRING FULL?
 0898  74 CC	 	 	 	JE	ORD9$	 	;YES, LOOP UNTIL END OF WORD
 089A  8B E9	 	 	 	MOV	BP,CX	 	;NO, TACK THIS CHARACTER ONTO STRING
 089C  3E: 88 46 00	 	 	MOV	DS:[BP],AL
 08A0  41	 	 	 	INC	CX
 08A1  EB C3	 	 	 	JMP	ORD9$	 	;AND LOOP
 08A3  81 F9 02B5 R	 	ORD12$:	CMP	CX,OFFSET RDWSTR;WORD READ BEFORE THIS BREAK?
 08A7  75 13	 	 	 	JNE	ORD14$	 	;YES
 08A9  3B 36 02ED R	 	 	CMP	SI,ESIBKS	;NO, BUT IS IT A SELF-INSERTING BREAK?
 08AD  76 03	 	 	 	JBE	ORD13$	 	;YES
 08AF  43	 	 	 	INC	BX	 	;NO, UPDATE BEGINNING OF WORD TO SKIP BREAK
 08B0  EB B4	 	 	 	JMP	ORD9$	 	;AND RETURN TO LOOP TO FIND A WORD
 08B2  8B E9	 	 	ORD13$:	MOV	BP,CX	 	;STORE THE BREAK IN WORD STRING
 08B4  3E: 88 46 00	 	 	MOV	DS:[BP],AL
 08B8  41	 	 	 	INC	CX
 08B9  EB 02 90	 	 	 	JMP	ORD15$	 	;AND GO FOR THE WORD
 08BC  4A	 	 	ORD14$:	DEC	DX	 	;UNREAD TERMINATING BREAK IN CASE IT WAS SI
 08BD  FE 06 02C3 R	 	ORD15$:	INC	RDNWDS	 	;INCREMENT FOUND WORD COUNT
 08C1  8B EB	 	 	 	MOV	BP,BX	 	;GREATER THAN MAX ALLOWED?
 08C3  8B 1E 02C1 R	 	 	MOV	BX,RDRET
 08C7  26: 8A 1F	 	 	MOV	BL,ES:[BX]
 08CA  38 1E 02C3 R	 	 	CMP	RDNWDS,BL
 08CE  8B DD	 	 	 	MOV	BX,BP
 08D0  7E 25	 	 	 	JLE	ORD16$	 	;NO
 	 	 	 	 	PRINT	ERR2	 	;YES, INFORM LOSER
 08D2  50                     +	 	PUSH	AX
 08D3  B8 0962 R              +	 	MOV	AX,OFFSET ERR2
 08D6  E8 196F R              +	 	CALL	.PRINT
 08D9  58                     +	 	POP	AX
 08DA  8B C3	 	 	 	MOV	AX,BX	 	;BEGINNING OF THIS WORD
 08DC  8B 2E 02BF R	 	 	MOV	BP,RDEOS	;SAVE BYTE AFTER EOS
 08E0  26: 8A 5E 00	 	 	MOV	BL,ES:[BP]
 08E4  26: C6 46 00 00	 	 	MOV	BYTE PTR ES:[BP],0  ;ZERO IT TO MAKE STRING ASCIZ
 08E9  E8 196F R	 	 	CALL	.PRINT	 	;PRINT IT
 08EC  26: 88 5E 00	 	 	MOV	ES:[BP],BL	;AND RESTORE OLD BYTE
 08F0  FE 0E 02C3 R	 	 	DEC	RDNWDS	 	;REMEMBER THAT WE FLUSHED THIS WORD
 08F4  E9 098F R	 	 	JMP	ORD23$	 	;AND WE'RE DONE
 08F7  8B C3	 	 	ORD16$:	MOV	AX,BX	 	;CALCULATE NUMBER OF CHARACTERS IN WORD
 08F9  F7 D8	 	 	 	NEG	AX
 08FB  03 C2	 	 	 	ADD	AX,DX
 08FD  26: 88 45 02	 	 	MOV	ES:[DI+2],AL	;SAVE THE NUMBER IN RET TABLE
 0901  2B 1E 02BD R	 	 	SUB	BX,RDBOS	;BYTE OFFSET FOR BEGINNING OF WORD
 0905  26: 88 5D 03	 	 	MOV	ES:[DI+3],BL	;STORE IT, TOO
 0909  8B E9	 	 	 	MOV	BP,CX	 	;MAKE WORD STRING ASCIZ
 090B  3E: C6 46 00 00	 	 	MOV	BYTE PTR DS:[BP],0
 0910  B8 02B5 R	 	 	MOV	AX,OFFSET RDWSTR;POINT TO IT
 0913  E8 0DDF R	 	 	CALL	ZWORD	 	;AND CONVERT TO (2-WORD) ZWORD
 0916  52	 	 	 	PUSH	DX	 	;SAVE CHAR & WORD ENTRY POINTERS
 0917  57	 	 	 	PUSH	DI
 0918  8B F8	 	 	 	MOV	DI,AX	 	;FIRST ZWORD WORD
 091A  8B 36 02F1 R	 	 	MOV	SI,VWORDS	;NUMBER OF VOCABULARY WORDS
 091E  8B C6	 	 	 	MOV	AX,SI
 0920  48	 	 	 	DEC	AX	 	;WE WANT TO POINT TO LAST WORD
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	10-7
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	I/O OPERATIONS

 0921  F7 26 02EF R	 	 	MUL	VWLEN	 	;MULTIPLY BY WORD LENGTH IN BYTES
 0925  03 06 02F3 R	 	 	ADD	AX,VOCBEG	;ADD POINTER TO BEGINNING TO FIND LAST WORD
 0929  8B C8	 	 	 	MOV	CX,AX	 	;POINTER TO LAST WORD
 092B  8B D7	 	 	 	MOV	DX,DI	 	;FIRST ZWORD WORD
 092D  8B FB	 	 	 	MOV	DI,BX	 	;SECOND ZWORD WORD
 092F  8B 1E 02EF R	 	 	MOV	BX,VWLEN	;CALCULATE INITIAL OFFSET FOR BINARY SEARCH
 0933  D1 FE	 	 	 	SAR	SI,1
 0935  D1 E3	 	 	ORD17$:	SAL	BX,1
 0937  D1 FE	 	 	 	SAR	SI,1
 0939  83 FE 00	 	 	 	CMP	SI,0
 093C  75 F7	 	 	 	JNE	ORD17$
 093E  8B 36 02F3 R	 	 	MOV	SI,VOCBEG	;BEGINNING OF WORD TABLE
 0942  03 F3	 	 	 	ADD	SI,BX	 	;ADD CURRENT OFFSET(HALF OF POWER-OF-2 TABLE)
 0944  50	 	 	 	PUSH	AX	 	;SAVE
 0945  A1 02EF R	 	 	MOV	AX,VWLEN	;AVOID FENCEPOST BUG FOR EXACT POWER-OF-2 TBL
 0948  2B F0	 	 	 	SUB	SI,AX
 094A  58	 	 	 	POP	AX	 	;RESTORE
 094B  D1 FB	 	 	ORD18$:	SAR	BX,1	 	;NEXT OFFSET WILL BE HALF OF PREVIOUS ONE
 	 	 	 	 	GTAWRD	A,[SI]	 	;GET FIRST HALF OF CURRENT ZWORD
 094D  26: 8B 04              +	 	MOV	AX,ES:[SI]
 0950  86 E0                  +	 	XCHG	AH,AL
 0952  3B D0	 	 	 	CMP	DX,AX	 	;COMPARE DESIRED ONE TO IT
 0954  77 15	 	 	 	JA	ORD19$	 	;GREATER, WE'LL HAVE TO MOVE UP
 0956  72 1E	 	 	 	JB	ORD20$	 	;LESS, WE'LL HAVE TO MOVE DOWN
 0958  8B EE	 	 	 	MOV	BP,SI	 	;SAME, GET SECOND HALF
 095A  45	 	 	 	INC	BP
 095B  45	 	 	 	INC	BP
 	 	 	 	 	GTAWRD	A,[BP]
 095C  26: 8B 46 00           +	 	MOV	AX,ES:[BP]
 0960  86 E0                  +	 	XCHG	AH,AL
 0962  3B F8	 	 	 	CMP	DI,AX	 	;COMPARE DESIRED WORD WITH IT
 0964  77 05	 	 	 	JA	ORD19$	 	;GREATER, WE'LL HAVE TO MOVE UP
 0966  72 0E	 	 	 	JB	ORD20$	 	;LESS, WE'LL HAVE TO MOVE DOWN
 0968  EB 16 90	 	 	 	JMP	ORD22$	 	;SAME, WE'VE FOUND IT, RETURN IT
 096B  03 F3	 	 	ORD19$:	ADD	SI,BX	 	;TO MOVE UP, ADD CURRENT OFFSET
 096D  3B F1	 	 	 	CMP	SI,CX	 	;HAVE WE MOVED PAST END OF TABLE?
 096F  76 07	 	 	 	JBE	ORD21$	 	;NO
 0971  8B F1	 	 	 	MOV	SI,CX	 	;YES, POINT TO END OF TABLE INSTEAD
 0973  EB 03 90	 	 	 	JMP	ORD21$
 0976  2B F3	 	 	ORD20$:	SUB	SI,BX	 	;TO MOVE DOWN, SIMPLY SUBTRACT OFFSET
 0978  3B 1E 02EF R	 	ORD21$:	CMP	BX,VWLEN	;IS OFFSET RESOLUTION BELOW ONE WORD?
 097C  7D CD	 	 	 	JGE	ORD18$	 	;NO, CONTINUE LOOP
 097E  2B F6	 	 	 	SUB	SI,SI	 	;YES, WORD NOT FOUND, RETURN ZERO
 0980  5F	 	 	ORD22$:	POP	DI	 	;RESTORE WORD ENTRY POINTER
 0981  8B D6	 	 	 	MOV	DX,SI	 	;POINTER TO WORD FOUND
 0983  86 F2	 	 	 	XCHG	DH,DL
 0985  26: 89 15	 	 	MOV	ES:[DI],DX	;STORE IT
 0988  5A	 	 	 	POP	DX	 	;RESTORE CHAR POINTER
 0989  83 C7 04	 	 	 	ADD	DI,4	 	;UPDATE POINTER FOR NEXT WORD ENTRY
 098C  E9 0861 R	 	 	JMP	ORD8$	 	;GO FOR IT
 098F  FF 06 02C1 R	 	ORD23$:	INC	RDRET	 	;DONE, STORE NUMBER OF WORDS FOUND
 0993  8B 2E 02C1 R	 	 	MOV	BP,RDRET
 	 	 	 	 	MOVM	ES:[BP],RDNWDS,DL
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	10-8
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	I/O OPERATIONS

 0997  8A 16 02C3 R           +	 	MOV	DL,RDNWDS
 099B  26: 88 56 00           +	 	MOV	ES:[BP],DL
 099F  5F	 	 	 	POP	DI	 	;RESTORE USER STACK POINTER
 09A0  C3	 	 	 	RET	 	 	;AND RETURN
 09A1	 	 	 	OPREAD	ENDP
 	 	 	 	
 	 	 	 	 	;PRINTC (PRINT CHAR WHOSE ASCII VALUE IS GIVEN)
 09A1	 	 	 	OPPRNC	PROC
 09A1  E9 0E61 R	 	 	JMP	PUTCHR	 	;QUEUE THE CHARACTER FOR PRINTING
 09A4	 	 	 	OPPRNC	ENDP
 	 	 	 	
 	 	 	 	 	;PRINTN (PRINT A NUMBER)
 09A4	 	 	 	OPPRNN	PROC
 09A4  8B D8	 	 	 	MOV	BX,AX	 	;NUMBER TO PRINT
 09A6  83 FB 00	 	 	 	CMP	BX,0
 09A9  75 06	 	 	 	JNE	OPN1$	 	;NON-ZERO
 09AB  B8 0030	 	 	 	MOV	AX,"0"	 	;SPECIAL CASE ZERO
 09AE  E9 0E61 R	 	 	JMP	PUTCHR
 09B1  7F 08	 	 	OPN1$:	JG	OPN2$	 	;POSITIVE?
 09B3  B8 002D	 	 	 	MOV	AX,"-"	 	;NO, PRINT MINUS SIGN
 09B6  E8 0E61 R	 	 	CALL	PUTCHR
 09B9  F7 DB	 	 	 	NEG	BX	 	;AND MAKE IT POSITIVE
 09BB  2B C9	 	 	OPN2$:	SUB	CX,CX	 	;COUNT OF DIGITS ON STACK
 09BD  EB 0D 90	 	 	 	JMP	OPN4$	 	;START WITH GREATER-THAN-10 TEST
 09C0  8B C3	 	 	OPN3$:	MOV	AX,BX	 	;EXTRACT A DIGIT
 09C2  BD 000A	 	 	 	MOV	BP,10
 09C5  99	 	 	 	CWD
 09C6  F7 FD	 	 	 	IDIV	BP
 09C8  52	 	 	 	PUSH	DX	 	;PUSH IT
 09C9  41	 	 	 	INC	CX	 	;BUMP COUNT
 09CA  8B D8	 	 	 	MOV	BX,AX	 	;GET QUOTIENT
 09CC  83 FB 0A	 	 	OPN4$:	CMP	BX,10	 	;MORE DIGITS TO EXTRACT?
 09CF  7D EF	 	 	 	JGE	OPN3$	 	;YES, GO LOOP
 09D1  8B C3	 	 	 	MOV	AX,BX	 	;NO, GET LAST (FIRST) DIGIT
 09D3  EB 02 90	 	 	 	JMP	OPN6$	 	;ALREADY IN PLACE
 09D6  58	 	 	OPN5$:	POP	AX	 	;POP NEXT DIGIT
 09D7  05 0030	 	 	OPN6$:	ADD	AX,"0"	 	;ASCIIZE IT
 09DA  E8 0E61 R	 	 	CALL	PUTCHR	 	;QUEUE IT
 09DD  49	 	 	 	DEC	CX	 	;REDUCE DIGIT COUNT
 09DE  7D F6	 	 	 	JGE	OPN5$	 	;LOOP IF SOME LEFT
 09E0  C3	 	 	 	RET	 	 	;ELSE, RETURN
 09E1	 	 	 	OPPRNN	ENDP
 	 	 	 	
 	 	 	 	 	;PRINT (THE STRING POINTED TO BY ES:AX)
 09E1	 	 	 	OPPRIN	PROC
 09E1  E8 0C6B R	 	 	CALL	BSPLIT	 	;SPLIT THE BLOCK & WORD NUMBERS
 09E4  E9 0CA1 R	 	 	JMP	PUTSTR	 	;PRINT THE STRING
 09E7	 	 	 	OPPRIN	ENDP
 	 	 	 	
 	 	 	 	 	;PRINTB (PRINT THE STRING POINTED TO BY THE BYTE-POINTER ES:AX)
 09E7	 	 	 	OPPRNB	PROC
 09E7  E8 0C5D R	 	 	CALL	BSPLTB	 	;SPLIT THE BLOCK & BYTE NUMBERS
 09EA  E9 0CA1 R	 	 	JMP	PUTSTR	 	;PRINT THE STRING
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	10-9
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	I/O OPERATIONS

 09ED	 	 	 	OPPRNB	ENDP
 	 	 	 	
 	 	 	 	;PSEUDO-INSTRUCTIONS FOR HOURS/MINUTES HERE FOR STATUS LINE
 09ED	 	 	 	OPPRNH	PROC
 09ED  C6 06 004C R 00	 	 	MOV	PMFLAG,0
 09F2  3C 0C	 	 	 	CMP	AL,12
 09F4  7C 05	 	 	 	JL	OPH0$
 09F6  C6 06 004C R 01	 	 	MOV	PMFLAG,1
 09FB  3C 00	 	 	OPH0$:	CMP	AL,0
 09FD  75 02	 	 	 	JNE	OPH00$
 09FF  B0 0C	 	 	 	MOV	AL,12
 0A01  3C 0C	 	 	OPH00$:	CMP	AL,12
 0A03  7E 02	 	 	 	JLE	OPH1$
 0A05  2C 0C	 	 	 	SUB	AL,12	 	;HOUR SLOT IS 24 HOUR TIME
 0A07  3C 09	 	 	OPH1$:	CMP	AL,9
 0A09  7F 07	 	 	 	JG	OPH2$
 0A0B  50	 	 	 	PUSH	AX
 0A0C  B0 20	 	 	 	MOV	AL,32
 0A0E  E8 0E61 R	 	 	CALL	PUTCHR	 	;OUTPUT SPACE FOR HOUR LESS THAN 10
 0A11  58	 	 	 	POP	AX
 0A12  E8 09A4 R	 	OPH2$:	CALL	OPPRNN
 0A15  B0 3A	 	 	 	MOV	AL,":"
 0A17  E9 0E61 R	 	 	JMP	PUTCHR	 	;AND COLON
 0A1A	 	 	 	OPPRNH	ENDP
 	 	 	 	
 0A1A	 	 	 	OPPRNM	PROC
 0A1A  3C 09	 	 	 	CMP	AL,9
 0A1C  7F 07	 	 	 	JG	OPM1$
 0A1E  50	 	 	 	PUSH	AX
 0A1F  B0 30	 	 	 	MOV	AL,"0"
 0A21  E8 0E61 R	 	 	CALL	PUTCHR
 0A24  58	 	 	 	POP	AX
 0A25  E8 09A4 R	 	OPM1$:	CALL	OPPRNN
 0A28  B0 20	 	 	 	MOV	AL,32
 0A2A  E8 0E61 R	 	 	CALL	PUTCHR
 0A2D  B0 61	 	 	 	MOV	AL,"a"
 0A2F  80 3E 004C R 00	 	 	CMP	PMFLAG,0
 0A34  74 02	 	 	 	JE	OPM2$
 0A36  B0 70	 	 	 	MOV	AL,"p"
 0A38  E8 0E61 R	 	OPM2$:	CALL	PUTCHR
 0A3B  B0 6D	 	 	 	MOV	AL,"m"
 0A3D  E9 0E61 R	 	 	JMP	PUTCHR
 0A40	 	 	 	OPPRNM	ENDP
 	 	 	 	 	
 	 	 	 	 	;PRINTD (PRINT OBJ'S SHORT DESCRIPTION)
 0A40	 	 	 	OPPRND	PROC
 0A40  E8 0C76 R	 	 	CALL	OBJLOC	 	;FIND OBJ'S LOCATION
 0A43  05 0007	 	 	 	ADD	AX,7	 	;PROPERTY TABLE POINTER
 0A46  8B E8	 	 	 	MOV	BP,AX
 	 	 	 	 	GTAWRD	A,[BP]	 	;GET IT
 0A48  26: 8B 46 00           +	 	MOV	AX,ES:[BP]
 0A4C  86 E0                  +	 	XCHG	AH,AL
 0A4E  40	 	 	 	INC	AX	 	;POINT TO STRING
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	10-10
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	I/O OPERATIONS

 0A4F  E8 0C5D R	 	 	CALL	BSPLTB	 	;SPLIT POINTER
 0A52  E9 0CA1 R	 	 	JMP	PUTSTR	 	;AND PRINT THE STRING
 0A55	 	 	 	OPPRND	ENDP
 	 	 	 	
 	 	 	 	 	;PRINTI (PRINT THE STRING FOLLOWING THIS INSTRUCTION)
 0A55	 	 	 	OPPRNI	PROC
 0A55  A1 066F R	 	 	MOV	AX,ZPC1	 	;GET POINTER TO STRING
 0A58  8B 1E 0671 R	 	 	MOV	BX,ZPC2
 0A5C  E8 0CA1 R	 	 	CALL	PUTSTR	 	;AND PRINT IT
 0A5F  A3 066F R	 	 	MOV	ZPC1,AX	 	;UPDATE ZPC
 0A62  89 1E 0671 R	 	 	MOV	ZPC2,BX
 0A66  E9 1245 R	 	 	JMP	NEWZPC
 0A69	 	 	 	OPPRNI	ENDP
 	 	 	 	
 	 	 	 	 	;PRINTR (PRINTI FOLLOWED BY RTRUE)
 0A69	 	 	 	OPPRNR	PROC
 0A69  E8 0A55 R	 	 	CALL	OPPRNI	 	;DO A PRINTI
 0A6C  E8 0A72 R	 	 	CALL	OPCRLF	 	;A CRLF
 0A6F  E9 0B03 R	 	 	JMP	OPRTRU	 	;AND AN RTRUE
 0A72	 	 	 	OPPRNR	ENDP
 	 	 	 	
 	 	 	 	 	;CRLF (DO A NEWLINE)
 0A72	 	 	 	OPCRLF	PROC
 0A72  E9 0F02 R	 	 	JMP	NEWLIN	 	;DO A NEWLINE
 0A75	 	 	 	OPCRLF	ENDP
 	 	 	 	
 	 	 	 	 	SUBTTL	CONTROL OPERATIONS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	11-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	CONTROL OPERATIONS

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	 	;CALL (A FUNCTION WITH OPTIONAL ARGUMENTS), # OF ARGS IN AX
 0A75	 	 	 	OPCALL	PROC
 0A75  90	 	 	 	NOP	 	 	;TELL CALLER TO USE ARGUMENT BLOCK
 0A76  8B D0	 	 	 	MOV	DX,AX	 	;NUMBER OF ARGUMENTS TO CALL
 0A78  A1 0673 R	 	 	MOV	AX,ARGBLK	;FUNCTION TO CALL
 0A7B  3D 0000	 	 	 	CMP	AX,0
 0A7E  75 05	 	 	 	JNE	OCL1$	 	;ZERO?
 0A80  2B C0	 	 	 	SUB	AX,AX	 	;YES, SIMPLY RETURN A ZERO
 0A82  E9 0C02 R	 	 	JMP	PUTVAL
 0A85	 	 	 	OCL1$:	PUSHZ	ZPC1	 	;OTHERWISE, SAVE OLD ZPC
 0A85  87 E7                  +	 	XCHG	SP,DI
 0A87  FF 36 066F R           +	 	PUSH	ZPC1
 0A8B  87 E7                  +	 	XCHG	SP,DI
 	 	 	 	 	PUSHZ	ZPC2
 0A8D  87 E7                  +	 	XCHG	SP,DI
 0A8F  FF 36 0671 R           +	 	PUSH	ZPC2
 0A93  87 E7                  +	 	XCHG	SP,DI
 0A95  8B 0E 066D R	 	 	MOV	CX,ZLOCS	;AND OLD LOCAL POINTER
 	 	 	 	;	SUB	CX,STKBOT	;BUT RELATIVIZE IT IN CASE OF SAVE
 	 	 	 	 	PUSHZ	CX	 	;AND SAVE IT
 0A99  87 E7                  +	 	XCHG	SP,DI
 0A9B  51                     +	 	PUSH	CX
 0A9C  87 E7                  +	 	XCHG	SP,DI
 0A9E  E8 0C6B R	 	 	CALL	BSPLIT	 	;SPLIT FUNCTION POINTER
 0AA1  A3 066F R	 	 	MOV	ZPC1,AX	 	;MAKE IT THE NEW ZPC
 0AA4  89 1E 0671 R	 	 	MOV	ZPC2,BX
 0AA8  E8 1245 R	 	 	CALL	NEWZPC	 	;UPDATE ZPC STUFF
 0AAB  89 3E 066D R	 	 	MOV	ZLOCS,DI	;LOCALS WILL START AT NEXT STACK SLOT
 0AAF  83 2E 066D R 02	 	 	SUB	ZLOCS,2
 0AB4  E8 0B60 R	 	 	CALL	NXTBYT	 	;NUMBER OF LOCALS
 0AB7  8B D8	 	 	 	MOV	BX,AX
 0AB9  BD 0675 R	 	 	MOV	BP,OFFSET ARGBLK[2]  ;POINT TO FIRST OPTIONAL ARG
 0ABC  4B	 	 	OCL2$:	DEC	BX	 	;ANY MORE LOCALS?
 0ABD  7C 1A	 	 	 	JL	OCL4$	 	;NO, WE'RE DONE
 0ABF  E8 0B80 R	 	 	CALL	NXTWRD	 	;YES, GET THE NEXT LOCAL DEFAULT VALUE
 0AC2  4A	 	 	 	DEC	DX	 	;ANY MORE OPTIONALS GIVEN?
 0AC3  7E 0D	 	 	 	JLE	OCL3$	 	;NO
 	 	 	 	 	PUSHZ	DS:[BP]	 	;YES, USE ITS VALUE
 0AC5  87 E7                  +	 	XCHG	SP,DI
 0AC7  3E: FF 76 00           +	 	PUSH	DS:[BP]
 0ACB  87 E7                  +	 	XCHG	SP,DI
 0ACD  83 C5 02	 	 	 	ADD	BP,2
 0AD0  EB EA	 	 	 	JMP	OCL2$	 	;AND CONTINUE LOOP
 0AD2	 	 	 	OCL3$:	PUSHZ	AX	 	;OTHERWISE, USE DEFAULT
 0AD2  87 E7                  +	 	XCHG	SP,DI
 0AD4  50                     +	 	PUSH	AX
 0AD5  87 E7                  +	 	XCHG	SP,DI
 0AD7  EB E3	 	 	 	JMP	OCL2$	 	;AND LOOP
 0AD9  C3	 	 	OCL4$:	RET
 0ADA	 	 	 	OPCALL	ENDP
 	 	 	 	
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	11-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	CONTROL OPERATIONS

 	 	 	 	 	;RETURN (FROM CURRENT FUNCTION CALL)
 0ADA	 	 	 	OPRETU	PROC
 0ADA  8B 3E 066D R	 	 	MOV	DI,ZLOCS	;RESTORE OLD TOP OF STACK
 	 	 	 	 	POPZ	DX	 	;DUMMY POP	 	 	[WHY?]
 0ADE  87 E7                  +	 	XCHG	SP,DI
 0AE0  5A                     +	 	POP	DX
 0AE1  87 E7                  +	 	XCHG	SP,DI
 	 	 	 	 	POPZ	ZLOCS	 	;AND OTHER VALUES
 0AE3  87 E7                  +	 	XCHG	SP,DI
 0AE5  8F 06 066D R           +	 	POP	ZLOCS
 0AE9  87 E7                  +	 	XCHG	SP,DI
 	 	 	 	
 	 	 	 	;	MOV	DX,STKBOT	;RE-ABSOLUTIZE THIS ONE
 	 	 	 	;	ADD	ZLOCS,DX	
 	 	 	 	
 	 	 	 	 	POPZ	ZPC2
 0AEB  87 E7                  +	 	XCHG	SP,DI
 0AED  8F 06 0671 R           +	 	POP	ZPC2
 0AF1  87 E7                  +	 	XCHG	SP,DI
 	 	 	 	 	POPZ	ZPC1
 0AF3  87 E7                  +	 	XCHG	SP,DI
 0AF5  8F 06 066F R           +	 	POP	ZPC1
 0AF9  87 E7                  +	 	XCHG	SP,DI
 0AFB  50	 	 	 	PUSH	AX	 	;VALUE TO RETURN
 0AFC  E8 1245 R	 	 	CALL	NEWZPC	 	;UPDATE ZPC STUFF
 0AFF  58	 	 	 	POP	AX
 0B00  E9 0C02 R	 	 	JMP	PUTVAL	 	;RETURN THE VALUE
 0B03	 	 	 	OPRETU	ENDP
 	 	 	 	
 	 	 	 	 	;RTRUE
 0B03	 	 	 	OPRTRU	PROC
 0B03  B8 0001	 	 	 	MOV	AX,1	 	;RETURN A 1
 0B06  EB D2	 	 	 	JMP	OPRETU
 0B08	 	 	 	OPRTRU	ENDP
 	 	 	 	
 	 	 	 	 	;RFALSE
 0B08	 	 	 	OPRFAL	PROC
 0B08  2B C0	 	 	 	SUB	AX,AX	 	;RETURN A 0
 0B0A  EB CE	 	 	 	JMP	OPRETU
 0B0C	 	 	 	OPRFAL	ENDP
 	 	 	 	
 	 	 	 	 	;JUMP (TO A NEW LOCATION)
 0B0C	 	 	 	OPJUMP	PROC
 0B0C  01 06 0671 R	 	 	ADD	ZPC2,AX	 	;ADD OFFSET TO CURRENT ZPC
 0B10  83 2E 0671 R 02	 	 	SUB	ZPC2,2	 	;ADJUST IT
 0B15  E9 1245 R	 	 	JMP	NEWZPC	 	;NORMALIZE IT & UPDATE ZPC STUFF
 0B18	 	 	 	OPJUMP	ENDP
 	 	 	 	
 	 	 	 	 	;RSTACK (RETURN STACK)
 0B18	 	 	 	OPRSTA	PROC
 	 	 	 	 	POPZ	AX	 	;POP A VALUE
 0B18  87 E7                  +	 	XCHG	SP,DI
 0B1A  58                     +	 	POP	AX
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	11-3
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	CONTROL OPERATIONS

 0B1B  87 E7                  +	 	XCHG	SP,DI
 0B1D  EB BB	 	 	 	JMP	OPRETU	 	;AND RETURN IT
 0B1F	 	 	 	OPRSTA	ENDP
 	 	 	 	
 	 	 	 	 	;FSTACK (FLUSH A VALUE OFF THE STACK)
 0B1F	 	 	 	OPFSTA	PROC
 	 	 	 	 	POPZ	DX	 	;FLUSH ONE
 0B1F  87 E7                  +	 	XCHG	SP,DI
 0B21  5A                     +	 	POP	DX
 0B22  87 E7                  +	 	XCHG	SP,DI
 0B24  C3	 	 	 	RET
 0B25	 	 	 	OPFSTA	ENDP
 	 	 	 	
 	 	 	 	 	;NOOP (NO OPERATION)
 0B25	 	 	 	OPNOOP	PROC
 0B25  C3	 	 	 	RET	 	 	;DO NOTHING
 0B26	 	 	 	OPNOOP	ENDP
 	 	 	 	
 	 	 	 	 	SUBTTL	LOW LEVEL FUNCTIONS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	12-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	LOW LEVEL FUNCTIONS

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	 	;GET A BYTE, BLOCK-POINTER ES:AX, BYTE-POINTER ES:BX, RESULT IN CX,
 	 	 	 	 	;UPDATE AX & BX TO REFLECT BYTE GOTTEN
 0B26	 	 	 	GETBYT	PROC
 0B26  50	 	 	 	PUSH	AX	 	;SAVE BLOCK-POINTER
 0B27  3B 06 02E1 R	 	 	CMP	AX,ENDLOD	;IS THIS A PRELOADED LOCATION?
 0B2B  7D 0D	 	 	 	JGE	GTY1$	 	;NO
 0B2D  B1 09	 	 	 	MOV	CL,9	 	;YES, RECONSTRUCT POINTER
 0B2F  D3 E0	 	 	 	SHL	AX,CL	 	;SHIFT BLOCK POINTER BY 9
 0B31  0B C3	 	 	 	OR	AX,BX	 	;ADD IN THE OFFSET
 0B33  93	 	 	 	XCHG	AX,BX
 0B34  26: 8A 0F	 	 	MOV	CL,ES:[BX]	;GET THE BYTE
 0B37  EB 0A 90	 	 	 	JMP	GTY2$	 	;CLEAR UNWANTED BYTE & RETURN IT
 0B3A  E8 12E1 R	 	GTY1$:	CALL	GETPAG	 	;FIND THE PROPER PAGE
 0B3D  03 C3	 	 	 	ADD	AX,BX	 	;POINT TO DESIRED BYTE
 0B3F  93	 	 	 	XCHG	AX,BX
 0B40  26: 8A 0F	 	 	MOV	CL,ES:[BX]	;GET IT
 0B43  2A ED	 	 	GTY2$:	SUB	CH,CH	 	;CLEAR UNWANTED BYTE & RETURN IT
 0B45  8B D8	 	 	 	MOV	BX,AX
 0B47  58	 	 	 	POP	AX	 	;RESTORE BLOCK-POINTER
 0B48  43	 	 	 	INC	BX	 	;UPDATE POINTER
 0B49  81 FB 0200	 	 	CMP	BX,200H	 	;END-OF-PAGE?
 0B4D  75 03	 	 	 	JNE	GTY3$	 	;NO
 0B4F  2B DB	 	 	 	SUB	BX,BX	 	;YES, CLEAR BYTE-POINTER
 0B51  40	 	 	 	INC	AX	 	;AND UPDATE BLOCK-POINTER
 0B52  C3	 	 	GTY3$:	RET
 0B53	 	 	 	GETBYT	ENDP
 	 	 	 	
 	 	 	 	 	;GET A WORD, BLOCK POINTER ES:AX, BYTE-POINTER ES:BX, RESULT IN CX
 0B53	 	 	 	GETWRD	PROC
 0B53  52	 	 	 	PUSH	DX	 	;SAVE
 0B54  E8 0B26 R	 	 	CALL	GETBYT	 	;GET HIGH-ORDER BYTE
 0B57  51	 	 	 	PUSH	CX	 	;SAVE IT
 0B58  E8 0B26 R	 	 	CALL	GETBYT	 	;GET LOW-ORDER BYTE
 0B5B  5A	 	 	 	POP	DX	 	;GET OTHER BYTE
 0B5C  8A EA	 	 	 	MOV	CH,DL	 	;POSITION IT
 0B5E  5A	 	 	 	POP	DX	 	;RESTORE
 0B5F  C3	 	 	 	RET
 0B60	 	 	 	GETWRD	ENDP
 	 	 	 	
 	 	 	 	 	;GET THE NEXT BYTE, RETURN IT IN AX
 0B60	 	 	 	NXTBYT	PROC
 0B60  53	 	 	 	PUSH	BX	 	;SAVE
 0B61  8B 1E 0671 R	 	 	MOV	BX,ZPC2	 	;BYTE POINTER
 0B65  03 1E 067B R	 	 	ADD	BX,CURPAG	;INDEX INTO CURRENT PAGE
 0B69  26: FF 37	 	 	PUSH	ES:[BX]	 	;SAVE BYTE
 0B6C  FF 06 0671 R	 	 	INC	ZPC2	 	;UPDATE PC
 0B70  81 3E 0671 R 0200	 	CMP	ZPC2,200H	;END-OF-PAGE?
 0B76  7C 03	 	 	 	JL	NXB1$	 	;NO
 0B78  E8 1245 R	 	 	CALL	NEWZPC	 	;YES, UPDATE PAGE
 0B7B  58	 	 	NXB1$:	POP	AX	 	;RETRIEVE BYTE
 0B7C  2A E4	 	 	 	SUB	AH,AH	 	;CLEAR UNWANTED BYTE
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	12-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	LOW LEVEL FUNCTIONS

 0B7E  5B	 	 	 	POP	BX	 	;RESTORE
 0B7F  C3	 	 	 	RET	 	 	;AND RETURN IT
 0B80	 	 	 	NXTBYT	ENDP
 	 	 	 	
 	 	 	 	 	;GET THE NEXT WORD, RETURN IT IN AX
 0B80	 	 	 	NXTWRD	PROC
 0B80  53	 	 	 	PUSH	BX	 	;SAVE
 0B81  E8 0B60 R	 	 	CALL	NXTBYT	 	;GET HIGH-ORDER BYTE
 0B84  50	 	 	 	PUSH	AX	 	;SAVE IT
 0B85  E8 0B60 R	 	 	CALL	NXTBYT	 	;GET LOW-ORDER BYTE
 0B88  5B	 	 	 	POP	BX	 	;GET HIGH-ORDER BYTE
 0B89  8A E3	 	 	 	MOV	AH,BL	 	;POSITION IT
 0B8B  5B	 	 	 	POP	BX	 	;RESTORE
 0B8C  C3	 	 	 	RET	 	 	;RETURN THE WORD
 0B8D	 	 	 	NXTWRD	ENDP
 	 	 	 	
 	 	 	 	 	;GET AN ARGUMENT GIVEN ITS TYPE IN AX
 0B8D	 	 	 	GETARG	PROC
 0B8D  48	 	 	 	DEC	AX	 	;EXAMINE ARGUMENT
 0B8E  7C F0	 	 	 	JL	NXTWRD	 	;0 MEANT LONG IMMEDIATE
 0B90  74 CE	 	 	 	JE	NXTBYT	 	;1 MEANT SHORT IMMEDIATE
 0B92  E8 0B60 R	 	 	CALL	NXTBYT	 	;2 MEANT VARIABLE, GET THE VAR
 0B95  3D 0000	 	 	 	CMP	AX,0	 	;STACK?
 0B98  75 06	 	 	 	JNE	GETVAR	 	;NO, JUST GET THE VAR'S VALUE
 	 	 	 	 	POPZ	AX	 	;YES, POP THE STACK
 0B9A  87 E7                  +	 	XCHG	SP,DI
 0B9C  58                     +	 	POP	AX
 0B9D  87 E7                  +	 	XCHG	SP,DI
 0B9F  C3	 	 	 	RET
 0BA0	 	 	 	GETARG	ENDP
 	 	 	 	
 	 	 	 	 	;GET VALUE OF A VARIABLE, VAR IN AX, VALUE RETURNED IN AX
 0BA0	 	 	 	GETVAR	PROC
 0BA0  3D 0000	 	 	 	CMP	AX,0	 	;STACK?
 0BA3  75 04	 	 	 	JNE	GTV1$	 	;NO
 	 	 	 	 	POPZT	AX	 	;YES, GET TOP-OF-STACK
 0BA5  36: 8B 05              +	 	MOV	AX,SS:[DI]
 0BA8  C3	 	 	 	RET
 0BA9  55	 	 	GTV1$:	PUSH	BP	 	;SAVE
 0BAA  3D 0010	 	 	 	CMP	AX,16	 	;LOCAL?
 0BAD  7D 0E	 	 	 	JGE	GTV3$	 	;NO
 0BAF  48	 	 	 	DEC	AX	 	;YES, POINT TO PROPER STACK ELEMENT
 0BB0  D1 E0	 	 	 	SHL	AX,1
 0BB2  8B 2E 066D R	 	 	MOV	BP,ZLOCS
 0BB6  2B E8	 	 	 	SUB	BP,AX
 0BB8  8B 46 00	 	 	 	MOV	AX,[BP]	 	;AND GET IT
 0BBB  5D	 	 	GTV2$:	POP	BP	 	;RESTORE
 0BBC  C3	 	 	 	RET
 0BBD  2D 0010	 	 	GTV3$:	SUB	AX,16	 	;GLOBAL, POINT TO PROPER GLOBAL TABLE ELEMENT
 0BC0  D1 E0	 	 	 	SHL	AX,1
 0BC2  03 06 02E7 R	 	 	ADD	AX,GLOTAB
 0BC6  8B E8	 	 	 	MOV	BP,AX	 	;AND GET IT
 	 	 	 	 	GTAWRD	A,[BP]
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	12-3
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	LOW LEVEL FUNCTIONS

 0BC8  26: 8B 46 00           +	 	MOV	AX,ES:[BP]
 0BCC  86 E0                  +	 	XCHG	AH,AL
 0BCE  EB EB	 	 	 	JMP	GTV2$
 0BD0	 	 	 	GETVAR	ENDP
 	 	 	 	
 	 	 	 	 	;UPDATE VALUE OF A VARIABLE, VAR IN AX, NEW VALUE IN BX
 0BD0	 	 	 	PUTVAR	PROC
 0BD0  3D 0000	 	 	 	CMP	AX,0	 	;STACK?
 0BD3  75 04	 	 	 	JNE	PTV1$	 	;NO
 	 	 	 	 	PUSHZT	BX	 	;YES, UPDATE TOP-OF-STACK
 0BD5  36: 89 1D              +	 	MOV	SS:[DI],BX
 0BD8  C3	 	 	 	RET
 0BD9  3D 0010	 	 	PTV1$:	CMP	AX,16	 	;LOCAL?
 0BDC  7D 0F	 	 	 	JGE	PTV2$	 	;NO
 0BDE  55	 	 	 	PUSH	BP	 	;SAVE
 0BDF  48	 	 	 	DEC	AX	 	;YES, POINT TO PROPER STACK ELEMENT
 0BE0  D1 E0	 	 	 	SHL	AX,1
 0BE2  8B 2E 066D R	 	 	MOV	BP,ZLOCS
 0BE6  2B E8	 	 	 	SUB	BP,AX
 0BE8  89 5E 00	 	 	 	MOV	[BP],BX	 	;AND UPDATE IT
 0BEB  5D	 	 	 	POP	BP	 	;RESTORE
 0BEC  C3	 	 	 	RET
 0BED  2D 0010	 	 	PTV2$:	SUB	AX,16	 	;GLOBAL, POINT TO PROPER GLOBAL TABLE ELEMENT
 0BF0  D1 E0	 	 	 	SHL	AX,1
 0BF2  03 06 02E7 R	 	 	ADD	AX,GLOTAB
 0BF6  93	 	 	 	XCHG	AX,BX	 	;AND UPDATE IT
 	 	 	 	 	PTAWRD	[BX],A
 0BF7  86 E0                  +	 	XCHG	AH,AL
 0BF9  26: 89 07              +	 	MOV	ES:[BX],AX
 0BFC  C3	 	 	 	RET
 0BFD	 	 	 	PUTVAR	ENDP
 	 	 	 	
 	 	 	 	 	;RETURN VAL IN AX TO LOCATION SPECIFIED BY NEXTBYTE
 	 	 	 	 	;DESTROYS BX, BUT IS USUALLY CALLED AT END OF TOP-LEVEL FUNCTION
 0BFD	 	 	 	BYTVAL	PROC
 0BFD  2A E4	 	 	 	SUB	AH,AH	 	;THIS ENTRY FOR BYTE VALUE TO CLEAR HIGH BYTE
 0BFF  EB 01 90	 	 	 	JMP	PUTVAL
 0C02	 	 	 	BYTVAL	ENDP
 	 	 	 	 	
 0C02	 	 	 	PUTVAL	PROC
 0C02  8B D8	 	 	 	MOV	BX,AX	 	;NORMAL ENTRY
 0C04  E8 0B60 R	 	 	CALL	NXTBYT	 	;GET VAR TO USE
 0C07  3D 0000	 	 	 	CMP	AX,0	 	;STACK?
 0C0A  75 C4	 	 	 	JNE	PUTVAR	 	;NO, GO STORE VALUE
 	 	 	 	 	PUSHZ	BX	 	;YES, PUSH ONTO STACK
 0C0C  87 E7                  +	 	XCHG	SP,DI
 0C0E  53                     +	 	PUSH	BX
 0C0F  87 E7                  +	 	XCHG	SP,DI
 0C11  C3	 	 	 	RET	 	 	;AND RETURN
 0C12	 	 	 	PUTVAL	ENDP
 	 	 	 	
 	 	 	 	 	;PREDICATE HANDLERS TRUE & FALSE
 	 	 	 	 	;DESTROYS REGISTERS, BUT ARE ONLY CALLED FROM END OF TOP-LEVEL FCNS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	12-4
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	LOW LEVEL FUNCTIONS

 0C12	 	 	 	PFALSE	PROC
 0C12  2B DB	 	 	 	SUB	BX,BX	 	;PREDICATE WAS FALSE, CLEAR FLAG
 0C14  EB 07 90	 	 	 	JMP	PPRED
 0C17	 	 	 	PFALSE	ENDP
 	 	 	 	
 0C17	 	 	 	PTRUE	PROC
 0C17  BB 0001	 	 	 	MOV	BX,1	 	;PREDICATE WAS TRUE, SET FLAG
 0C1A  EB 01 90	 	 	 	JMP	PPRED
 0C1D	 	 	 	PTRUE	ENDP
 	 	 	 	 	
 0C1D	 	 	 	PPRED	PROC
 0C1D  E8 0B60 R	 	 	CALL	NXTBYT	 	;GET FIRST (OR ONLY) PREDICATE JUMP BYTE
 0C20  A9 0080	 	 	 	TEST	AX,80H	 	;NORMAL POLARITY PREDICATE?
 0C23  74 01	 	 	 	JE	PPR1$	 	;NO, LEAVE FLAG ALONE
 0C25  43	 	 	 	INC	BX	 	;YES, INCREMENT FLAG
 0C26  A9 0040	 	 	PPR1$:	TEST	AX,40H	 	;ONE-BYTE JUMP OFFSET?
 0C29  74 06	 	 	 	JE	PPR2$	 	;NO
 0C2B  25 FF3F	 	 	 	AND	AX,0FF3FH	;YES, CLEAR SPECIAL BITS
 0C2E  EB 13 90	 	 	 	JMP	PPR3$
 0C31  25 FF3F	 	 	PPR2$:	AND	AX,0FF3FH	;CLR SPECIAL BITS FROM HIGH-ORDER OFFSET BYTE
 0C34  8B C8	 	 	 	MOV	CX,AX	 	;HIGH-ORDER BYTE
 0C36  E8 0B60 R	 	 	CALL	NXTBYT	 	;GET LOW-ORDER BYTE
 0C39  8A E1	 	 	 	MOV	AH,CL	 	;MOVE IN HIGH-ORDER BITS
 0C3B  A9 2000	 	 	 	TEST	AX,2000H	;IS NUMBER NEGATIVE (14-BIT 2'S COMP NUMBER)?
 0C3E  74 03	 	 	 	JE	PPR3$	 	;NO
 0C40  0D C000	 	 	 	OR	AX,0C000H	;YES, MAKE 16-BIT NUMBER NEGATIVE
 0C43  4B	 	 	PPR3$:	DEC	BX	 	;TEST FLAG
 0C44  74 16	 	 	 	JE	PPR6$	 	;WAS 1, THAT MEANS DO NOTHING
 0C46  3D 0000	 	 	 	CMP	AX,0	 	;ZERO JUMP?
 0C49  75 03	 	 	 	JNE	PPR4$	 	;NO
 0C4B  E9 0B08 R	 	 	JMP	OPRFAL	 	;YES, THAT MEANS DO AN RFALSE
 0C4E  48	 	 	PPR4$:	DEC	AX	 	;ONE JUMP?
 0C4F  75 03	 	 	 	JNE	PPR5$	 	;NO
 0C51  E9 0B03 R	 	 	JMP	OPRTRU	 	;YES, THAT MEANS DO AN RTRUE
 0C54  48	 	 	PPR5$:	DEC	AX	 	;ADJUST OFFSET
 0C55  01 06 0671 R	 	 	ADD	ZPC2,AX	 	;ADD TO PC
 0C59  E9 1245 R	 	 	JMP	NEWZPC	 	;AND UPDATE ZPC STUFF
 0C5C  C3	 	 	PPR6$:	RET
 0C5D	 	 	 	PPRED	ENDP
 	 	 	 	
 	 	 	 	 	;SPLIT BYTE-POINTER IN AX TO BLOCK-POINTER IN AX & BYTE OFFSET IN BX
 0C5D	 	 	 	BSPLTB	PROC
 0C5D  8B D8	 	 	 	MOV	BX,AX
 0C5F  86 C4	 	 	 	XCHG	AL,AH	 	;EXTRACT BLOCK BITS
 0C61  D1 E8	 	 	 	SHR	AX,1
 0C63  25 007F	 	 	 	AND	AX,7FH	 	;CLEAR UNWANTED BITS
 0C66  81 E3 01FF	 	 	AND	BX,1FFH	 	;CLEAR ALL BUT BYTE OFFSET BITS
 0C6A  C3	 	 	 	RET
 0C6B	 	 	 	BSPLTB	ENDP
 	 	 	 	
 	 	 	 	 	;SPLIT WORD-POINTER IN AX TO BLOCK-POINTER IN AX & BYTE-OFFSET IN BX
 0C6B	 	 	 	BSPLIT	PROC
 0C6B  8B D8	 	 	 	MOV	BX,AX
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	12-5
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	LOW LEVEL FUNCTIONS

 0C6D  8A C4	 	 	 	MOV	AL,AH	 	;EXTRACT BLOCK BITS
 0C6F  2A E4	 	 	 	SUB	AH,AH	 	;CLEAR UNWANTED BITS
 0C71  2A FF	 	 	 	SUB	BH,BH	 	;CLEAR ALL BUT WORD OFFSET BITS
 0C73  D1 E3	 	 	 	SHL	BX,1	 	;CONVERT TO BYTE OFFSET
 0C75  C3	 	 	 	RET
 0C76	 	 	 	BSPLIT	ENDP
 	 	 	 	 	
 	 	 	 	 	SUBTTL	OBJECT HACKERS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	13-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	OBJECT HACKERS

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	 	;GIVEN OBJ NUMBER IN AX, RETURN OBJ LOCATION IN AX
 0C76	 	 	 	OBJLOC	PROC
 0C76  2A E4	 	 	 	SUB	AH,AH	 	;CLEAR UNWANTED BITS
 0C78  53	 	 	 	PUSH	BX	 	;MULTIPLY BY 9 THE LAZY WAY
 0C79  8B D8	 	 	 	MOV	BX,AX
 0C7B  D1 E0	 	 	 	SHL	AX,1
 0C7D  D1 E0	 	 	 	SHL	AX,1
 0C7F  D1 E0	 	 	 	SHL	AX,1
 0C81  03 C3	 	 	 	ADD	AX,BX
 0C83  5B	 	 	 	POP	BX	 	;RESTORE
 0C84  03 06 02E5 R	 	 	ADD	AX,OBJTAB	;INDEX INTO OBJECT TABLE
 0C88  05 0035	 	 	 	ADD	AX,53	 	;SKIPPING DEFAULT PROPERTY TABLE
 0C8B  C3	 	 	 	RET
 0C8C	 	 	 	OBJLOC	ENDP
 	 	 	 	
 	 	 	 	 	;GIVEN POINTER TO A PROPERTY IN BX!, UPDATE IT TO POINT TO NEXT PROP
 0C8C	 	 	 	NXTPRP	PROC
 0C8C  50	 	 	 	PUSH	AX	 	;SAVE
 0C8D  51	 	 	 	PUSH	CX	 	;SAVE
 0C8E  26: 8A 07	 	 	MOV	AL,ES:[BX]	;GET PROPERTY IDENTIFIER
 0C91  24 E0	 	 	 	AND	AL,MASK PROPSIZE;EXTRACT PROPERTY LENGTH (MINUS 1)
 0C93  B1 05	 	 	 	MOV	CL,PROPSIZE
 0C95  D2 E8	 	 	 	SHR	AL,CL
 0C97  2A E4	 	 	 	SUB	AH,AH
 0C99  03 D8	 	 	 	ADD	BX,AX	 	;ADD IT TO OLD POINTER
 0C9B  83 C3 02	 	 	 	ADD	BX,2	 	;ADJUST FOR EXTRA LENGTH BYTE PLUS IDENTIFIER
 0C9E  59	 	 	 	POP	CX	 	;RESTORE
 0C9F  58	 	 	 	POP	AX	 	;RESTORE
 0CA0  C3	 	 	 	RET
 0CA1	 	 	 	NXTPRP	ENDP
 	 	 	 	 	
 	 	 	 	 	SUBTTL	STRING FUNCTIONS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	14-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STRING FUNCTIONS

 	 	 	 	 	PAGE	+
 	 	 	 	
 = 0005	 	 	 	PADCHR	EQU	5	 	;ZSTR PADDING CHARACTER
 	 	 	 	
 	 	 	 	 	;OUTPUT A ZSTR, BLOCK-POINTER IN AX, BYTE-POINTER IN BX
 	 	 	 	 	;RETURN UPDATED POINTER
 0CA1	 	 	 	PUTSTR	PROC
 0CA1  56	 	 	 	PUSH	SI	 	;SAVE
 0CA2  51	 	 	 	PUSH	CX	 	;SAVE
 0CA3  52	 	 	 	PUSH	DX	 	;SAVE
 0CA4  57	 	 	 	PUSH	DI	 	;SAVE
 0CA5  55	 	 	 	PUSH	BP	 	;SAVE
 0CA6  2B D2	 	 	 	SUB	DX,DX	 	;TEMP CS STARTS AT 0
 0CA8  2B FF	 	 	 	SUB	DI,DI	 	;PERM CS STARTS AT 0
 0CAA  E8 0B53 R	 	PTS1$:	CALL	GETWRD	 	;GET NEXT STRING WORD
 0CAD  8B F1	 	 	 	MOV	SI,CX
 0CAF  50	 	 	 	PUSH	AX	 	;SAVE POINTER & COPY OF STRING WORD
 0CB0  53	 	 	 	PUSH	BX
 0CB1  56	 	 	 	PUSH	SI
 0CB2  B9 0003	 	 	 	MOV	CX,3	 	;3 BYTES IN WORD
 0CB5  56	 	 	PTS2$:	PUSH	SI	 	;SAVE CURRENT BYTE (IN LOW-ORDER POSITION)
 0CB6  8B E9	 	 	 	MOV	BP,CX	 	;SHIFT TO NEXT BYTE
 0CB8  B1 05	 	 	 	MOV	CL,5
 0CBA  D3 FE	 	 	 	SAR	SI,CL
 0CBC  8B CD	 	 	 	MOV	CX,BP
 0CBE  E2 F5	 	 	 	LOOP	PTS2$	 	;LOOP UNTIL DONE
 0CC0  B9 0003	 	 	 	MOV	CX,3	 	;RETRIEVE THE 3 BYTES
 0CC3  5E	 	 	PTS3$:	POP	SI	 	;GET NEXT BYTE
 0CC4  81 E6 001F	 	 	AND	SI,1FH	 	;CLEAR UNWANTED BITS
 0CC8  83 FA 00	 	 	 	CMP	DX,0	 	;IN WORD MODE?
 0CCB  7D 18	 	 	 	JGE	PTS4$	 	;NO	 	 	{WAS BPL, CHECK}
 0CCD  D1 E6	 	 	 	SAL	SI,1	 	;YES, CALCULATE WORD OFFSET
 0CCF  03 36 02E9 R	 	 	ADD	SI,WRDTAB	;POINT INTO WORD TABLE
 0CD3  03 36 02C4 R	 	 	ADD	SI,WRDOFF	;USING PROPER 32-WORD BLOCK
 	 	 	 	 	GTAWRD	A,[SI]	 	;POINT TO WORD STRING
 0CD7  26: 8B 04              +	 	MOV	AX,ES:[SI]
 0CDA  86 E0                  +	 	XCHG	AH,AL
 0CDC  E8 0C6B R	 	 	CALL	BSPLIT	 	;SPLIT IT
 0CDF  E8 0CA1 R	 	 	CALL	PUTSTR	 	;AND PRINT IT
 0CE2  E9 0D76 R	 	 	JMP	PTS15$	 	;CONT. WHERE WE LEFT OFF WITH TEMP CS RESET
 0CE5  83 FA 03	 	 	PTS4$:	CMP	DX,3	 	;CS 3 SELECTED (ASCII MODE)?
 0CE8  7C 1C	 	 	 	JL	PTS6$	 	;NO, NORMAL CS
 0CEA  75 07	 	 	 	JNE	PTS5$	 	;NO, BUT WE ARE IN ASCII MODE
 0CEC  86 D6	 	 	 	XCHG	DL,DH	 	;SHIFT SOME BITS HIGH TO MAKE NUMBER LARGE
 0CEE  0B D6	 	 	 	OR	DX,SI	 	;SAVE HIGH-ORDER ASCII BITS HERE
 0CF0  E9 0D78 R	 	 	JMP	PTS16$	 	;GO GET NEXT BYTE
 0CF3  81 E2 0003	 	PTS5$:	AND	DX,3	 	;EXTRACT PREVIOUSLY SAVED HIGH-ORDER BITS
 0CF7  8B E9	 	 	 	MOV	BP,CX	 	;POSITION THEM
 0CF9  B1 05	 	 	 	MOV	CL,5
 0CFB  D3 E2	 	 	 	SAL	DX,CL
 0CFD  8B CD	 	 	 	MOV	CX,BP
 0CFF  0B D6	 	 	 	OR	DX,SI	 	;OR IN LOW-ORDER BITS
 0D01  8B C2	 	 	 	MOV	AX,DX
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	14-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STRING FUNCTIONS

 0D03  EB 6E 90	 	 	 	JMP	PTS14$	 	;GO PRINT THE CHARACTER
 0D06  83 FE 06	 	 	PTS6$:	CMP	SI,6	 	;SPECIAL CODE?
 0D09  7C 29	 	 	 	JL	PTS9$	 	;YES, SPACE, WORD, OR SHIFT
 0D0B  83 FA 02	 	 	 	CMP	DX,2	 	;MIGHT ALSO BE SPECIAL IF IN CS 2
 0D0E  75 11	 	 	 	JNE	PTS8$	 	;BUT WE'RE NOT
 0D10  83 FE 07	 	 	 	CMP	SI,7	 	;CRLF?
 0D13  74 06	 	 	 	JE	PTS7$	 	;YES
 0D15  7F 0A	 	 	 	JG	PTS8$	 	;NO, NOT ASCII MODE, EITHER?
 0D17  42	 	 	 	INC	DX	 	;YES IT IS, SWITCH TO ASCII MODE
 0D18  EB 5E 90	 	 	 	JMP	PTS16$	 	;AND GO GET NEXT BYTE
 0D1B  E8 0F02 R	 	PTS7$:	CALL	NEWLIN	 	;CRLF REQUESTED, DO A NEWLINE
 0D1E  EB 56 90	 	 	 	JMP	PTS15$
 0D21  8B C2	 	 	PTS8$:	MOV	AX,DX	 	;NORMAL CHARACTER, GET CS
 0D23  BD 001A	 	 	 	MOV	BP,26	 	;CALCULATE OFFSET FOR THIS CS
 0D26  F7 E5	 	 	 	MUL	BP
 0D28  03 C6	 	 	 	ADD	AX,SI	 	;ADD IN CHARACTER OFFSET (+6)
 0D2A  2D 0006	 	 	 	SUB	AX,6	 	;CHARACTER OFFSET
 0D2D  BB 09ED R	 	 	MOV	BX,OFFSET ZCHRS	;GET THE CHARACTER FROM CONVERSION VECTOR
 0D30  D7	 	 	 	XLAT	ZCHRS
 0D31  EB 40 90	 	 	 	JMP	PTS14$	 	;GO PRINT IT
 0D34  83 FE 00	 	 	PTS9$:	CMP	SI,0	 	;IS IT A SPACE?
 0D37  75 06	 	 	 	JNE	PTS10$	 	;NO
 0D39  B8 0020	 	 	 	MOV	AX," "	 	;YES, GO PRINT A SPACE
 0D3C  EB 35 90	 	 	 	JMP	PTS14$
 0D3F  83 FE 03	 	 	PTS10$:	CMP	SI,3	 	;IS IT A WORD?
 0D42  7F 14	 	 	 	JG	PTS11$	 	;NO, MUST BE A SHIFT
 0D44  81 CA 8000	 	 	OR	DX,8000H	;SWITCH TO WORD MODE FOR NEXT BYTE
 0D48  4E	 	 	 	DEC	SI	 	;CALCULATE WORD-TABLE BLOCK OFFSET
 0D49  8B E9	 	 	 	MOV	BP,CX	 	;64 BYTES IN A BLOCK
 0D4B  B1 06	 	 	 	MOV	CL,6
 0D4D  D3 E6	 	 	 	SHL	SI,CL
 0D4F  8B CD	 	 	 	MOV	CX,BP
 0D51  89 36 02C4 R	 	 	MOV	WRDOFF,SI	;SAVE IT AND LOOP
 0D55  EB 21 90	 	 	 	JMP	PTS16$
 0D58  83 EE 03	 	 	PTS11$:	SUB	SI,3	 	;CALCULATE NEW CS
 0D5B  83 FA 00	 	 	 	CMP	DX,0	 	;TEMPORARY SHIFT (FROM CS 0)?
 0D5E  75 05	 	 	 	JNE	PTS12$	 	;NO
 0D60  8B D6	 	 	 	MOV	DX,SI	 	;YES, JUST SAVE NEW TEMP CS
 0D62  EB 14 90	 	 	 	JMP	PTS16$
 0D65  3B F2	 	 	PTS12$:	CMP	SI,DX	 	;IS THIS THE CURRENT CS?
 0D67  74 02	 	 	 	JE	PTS13$	 	;YES, DO A PERM SHIFT TO IT
 0D69  2B D2	 	 	 	SUB	DX,DX	 	;OTHERWISE, PERM SHIFT TO CS 0
 0D6B  8B FA	 	 	PTS13$:	MOV	DI,DX	 	;TEMP & PERM CS'S ARE SAME NOW
 0D6D  EB 09 90	 	 	 	JMP	PTS16$
 0D70  E9 0CC3 R	 	PTS3A$:	JMP	PTS3$	 	;DUMMY FOR NON-SHORT LOOP
 0D73  E8 0E61 R	 	PTS14$:	CALL	PUTCHR	 	;PRINT THE CHARACTER
 0D76  8B D7	 	 	PTS15$:	MOV	DX,DI	 	;RESET TEMP CS TO PERM CS
 0D78  E2 F6	 	 	PTS16$:	LOOP	PTS3A$	 	;NEXT BYTE
 0D7A  5E	 	 	 	POP	SI	 	;RESTORE POINTERS & ORIGINAL STRING WORD
 0D7B  5B	 	 	 	POP	BX
 0D7C  58	 	 	 	POP	AX
 0D7D  83 FE 00	 	 	 	CMP	SI,0	 	;END-OF-STRING?
 0D80  7C 03	 	 	 	JL	PTS1A$	 	;YES, CLEAN UP & RETURN UPDATED POINTER
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	14-3
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STRING FUNCTIONS

 0D82  E9 0CAA R	 	 	JMP	PTS1$	 	;NO, GET NEXT WORD
 0D85  5D	 	 	PTS1A$:	POP	BP	 	;RESTORES
 0D86  5F	 	 	 	POP	DI
 0D87  5A	 	 	 	POP	DX
 0D88  59	 	 	 	POP	CX
 0D89  5E	 	 	 	POP	SI
 0D8A  C3	 	 	 	RET
 0D8B	 	 	 	PUTSTR	ENDP
 	 	 	 	
 	 	 	 	 	;GIVEN AN ASCII CHARACTER IN AX, RETURN THE CHARACTER SET # IN AX
 0D8B	 	 	 	CHRCS	PROC
 0D8B  3D 0000	 	 	 	CMP	AX,0	 	;IS THIS A NULL?
 0D8E  75 04	 	 	 	JNE	CCS1$	 	;NO
 0D90  B8 0003	 	 	 	MOV	AX,3	 	;YES, RETURN DUMMY CS NUMBER
 0D93  C3	 	 	 	RET
 0D94  53	 	 	CCS1$:	PUSH	BX	 	;SAVE
 0D95  BB 09ED R	 	 	MOV	BX,OFFSET ZCHRS	;POINT TO CONVERSION VECTOR
 0D98  43	 	 	CCS2$:	INC	BX	 	;FOUND THE CHARACTER?
 0D99  3A 47 FF	 	 	 	CMP	AL,[BX-1]
 0D9C  74 0B	 	 	 	JE	CCS3$	 	;YES
 0D9E  80 3F 00	 	 	 	CMP	BYTE PTR [BX],0	;NO, END OF STRING?
 0DA1  75 F5	 	 	 	JNE	CCS2$	 	;NO, CONTINUE LOOP
 0DA3  B8 0002	 	 	 	MOV	AX,2	 	;YES, CALL IT CS 2
 0DA6  EB 0F 90	 	 	 	JMP	CCS5$
 0DA9  81 EB 09ED R	 	CCS3$:	SUB	BX,OFFSET ZCHRS	;FIND CHARACTER POSITION
 0DAD  2B C0	 	 	 	SUB	AX,AX	 	;START WITH CS 0
 0DAF  83 EB 1A	 	 	CCS4$:	SUB	BX,26	 	;EVERY 26 CHARACTERS IS A NEW CS
 0DB2  7E 03	 	 	 	JLE	CCS5$	 	;DONE
 0DB4  40	 	 	 	INC	AX	 	;INCREMENT CS # & CONTINUE LOOP
 0DB5  EB F8	 	 	 	JMP	CCS4$
 0DB7  5B	 	 	CCS5$:	POP	BX
 0DB8  C3	 	 	 	RET
 0DB9	 	 	 	CHRCS	ENDP
 	 	 	 	
 	 	 	 	 	;GIVEN AN ASCII CHARACTER IN AX, RETURN ZSTR BYTE VALUE IN AX
 0DB9	 	 	 	CHRBYT	PROC
 0DB9  53	 	 	 	PUSH	BX	 	;SAVE
 0DBA  BB 09ED R	 	 	MOV	BX,OFFSET ZCHRS	;POINT TO CHARACTER CONVERSION TABLE
 0DBD  43	 	 	CHB1$:	INC	BX	;FOUND THE CHARACTER?
 0DBE  3A 47 FF	 	 	 	CMP	AL,[BX-1]
 0DC1  74 0A	 	 	 	JE	CHB2$	 	;YES
 0DC3  80 3F 00	 	 	 	CMP	BYTE PTR [BX],0	;NO, END OF STRING?
 0DC6  75 F5	 	 	 	JNE	CHB1$	 	;NO, CONTINUE LOOP
 0DC8  2B C0	 	 	 	SUB	AX,AX	 	;YES, RETURN ZERO FOR FAILURE
 0DCA  EB 11 90	 	 	 	JMP	CHB4$
 0DCD  81 EB 09E8 R	 	CHB2$:	SUB	BX,OFFSET ZCHRS-5  ;ADJUST POINTER SO FIRST CHARACTER IS 6
 0DD1  8B C3	 	 	 	MOV	AX,BX
 0DD3  3D 0020	 	 	CHB3$:	CMP	AX,32	 	;SUBTRACT MULTIPLES OF 26 UNTIL BASE CODE
 0DD6  7C 05	 	 	 	JL	CHB4$
 0DD8  2D 001A	 	 	 	SUB	AX,26
 0DDB  EB F6	 	 	 	JMP	CHB3$
 0DDD  5B	 	 	CHB4$:	POP	BX	 	;RESTORE
 0DDE  C3	 	 	 	RET
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	14-4
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STRING FUNCTIONS

 0DDF	 	 	 	CHRBYT	ENDP
 	 	 	 	
 	 	 	 	 	;CONVERT UP TO 6 ASCIZ CHARS POINTED TO BY DS:AX
 	 	 	 	 	;TO A 2-WORD ZSTR RETURNED IN AX & BX
 0DDF	 	 	 	ZWORD	PROC
 0DDF  56	 	 	 	PUSH	SI	 	;SAVES
 0DE0  51	 	 	 	PUSH	CX
 0DE1  52	 	 	 	PUSH	DX
 0DE2  57	 	 	 	PUSH	DI
 0DE3  55	 	 	 	PUSH	BP
 0DE4  8B F0	 	 	 	MOV	SI,AX	 	;CHARACTER STRING POINTER
 0DE6  2B FF	 	 	 	SUB	DI,DI	 	;CS STARTS AT 0
 0DE8  B9 0006	 	 	 	MOV	CX,6	 	;MAKE 6 ZSTR BYTES
 0DEB  46	 	 	ZWD1$:	INC	SI	 	;GET NEXT CHARACTER
 0DEC  8A 5C FF	 	 	 	MOV	BL,[SI-1]
 0DEF  80 FB 00	 	 	 	CMP	BL,0
 0DF2  75 09	 	 	 	JNE	ZWD3$	 	;NOT END-OF-STRING
 0DF4  B8 0005	 	 	 	MOV	AX,OFFSET PADCHR;AT END-OF-STRING, PAD WITH PAD CHARACTER
 0DF7  50	 	 	ZWD2$:	PUSH	AX	 	;SAVE A PAD BYTE
 0DF8  E2 FD	 	 	 	LOOP	ZWD2$	 	;LOOP UNTIL DONE
 0DFA  EB 3A 90	 	 	 	JMP	ZWD6$	 	;THEN GO FORM ZWORD
 0DFD  8B C3	 	 	ZWD3$:	MOV	AX,BX
 0DFF  E8 0D8B R	 	 	CALL	CHRCS	 	;FIND THE CS NUMBER FOR THIS CHAR
 0E02  3D 0000	 	 	 	CMP	AX,0	 	;CS 0?
 0E05  74 07	 	 	 	JE	ZWD4$	 	;YES
 0E07  05 0003	 	 	 	ADD	AX,3	 	;NO, CALCULATE TEMP SHIFT BYTE
 0E0A  50	 	 	 	PUSH	AX	 	;SAVE THE SHIFT BYTE
 0E0B  49	 	 	 	DEC	CX	 	;REDUCE BYTE COUNT
 0E0C  74 28	 	 	 	JE	ZWD6$	 	;DONE
 0E0E  8B C3	 	 	ZWD4$:	MOV	AX,BX	 	;FIND THE PROPER BYTE VALUE FOR THIS CHAR
 0E10  E8 0DB9 R	 	 	CALL	CHRBYT
 0E13  3D 0000	 	 	 	CMP	AX,0	 	;IN NORMAL CS'S?
 0E16  75 1B	 	 	 	JNE	ZWD5$	 	;YES
 0E18  B8 0006	 	 	 	MOV	AX,6	 	;NO, USE ASCII SHIFT
 0E1B  50	 	 	 	PUSH	AX
 0E1C  49	 	 	 	DEC	CX	 	;DONE YET?
 0E1D  74 17	 	 	 	JE	ZWD6$	 	;YES
 0E1F  8B C3	 	 	 	MOV	AX,BX	 	;NO, SAVE HIGH-ORDER ASCII BITS
 0E21  8B E9	 	 	 	MOV	BP,CX
 0E23  B1 05	 	 	 	MOV	CL,5
 0E25  D3 F8	 	 	 	SAR	AX,CL
 0E27  8B CD	 	 	 	MOV	CX,BP
 0E29  50	 	 	 	PUSH	AX
 0E2A  49	 	 	 	DEC	CX	 	;DONE YET?
 0E2B  74 09	 	 	 	JE	ZWD6$	 	;YES
 0E2D  81 E3 001F	 	 	AND	BX,1FH	 	;NO, SAVE LOW-ORDER ASCII BITS
 0E31  8B C3	 	 	 	MOV	AX,BX
 0E33  50	 	 	ZWD5$:	PUSH	AX	 	;SAVE THIS BYTE
 0E34  E2 B5	 	 	 	LOOP	ZWD1$	 	;LOOP UNTIL ZWORD FULL
 0E36  8B EC	 	 	ZWD6$:	MOV	BP,SP	 	;BUILD ZWORD WORDS FROM 6 SAVED BYTES
 0E38  8B 46 0A	 	 	 	MOV	AX,[BP+10]
 0E3B  B1 05	 	 	 	MOV	CL,5
 0E3D  D3 E0	 	 	 	SHL	AX,CL
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	14-5
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	STRING FUNCTIONS

 0E3F  0B 46 08	 	 	 	OR	AX,[BP+8]
 0E42  D3 E0	 	 	 	SHL	AX,CL
 0E44  0B 46 06	 	 	 	OR	AX,[BP+6]
 0E47  8B 5E 04	 	 	 	MOV	BX,[BP+4]
 0E4A  D3 E3	 	 	 	SHL	BX,CL
 0E4C  0B 5E 02	 	 	 	OR	BX,[BP+2]
 0E4F  D3 E3	 	 	 	SHL	BX,CL
 0E51  0B 5E 00	 	 	 	OR	BX,[BP]
 0E54  81 CB 8000	 	 	OR	BX,8000H	;SET END-OF-STRING BIT IN SECOND WORD
 0E58  83 C4 0C	 	 	 	ADD	SP,12	 	;FLUSH STACK
 0E5B  5D	 	 	 	POP	BP	 	;RESTORES
 0E5C  5F	 	 	 	POP	DI
 0E5D  5A	 	 	 	POP	DX
 0E5E  59	 	 	 	POP	CX
 0E5F  5E	 	 	 	POP	SI
 0E60  C3	 	 	 	RET
 0E61	 	 	 	ZWORD	ENDP
 	 	 	 	 	
 	 	 	 	 	SUBTTL	TERMINAL I/O
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	15-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	TERMINAL I/O

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	 	;QUEUE CHARACTER IN AX FOR OUTPUT
 0E61	 	 	 	PUTCHR	PROC
 0E61  55	 	 	 	PUSH	BP
 0E62  80 3E 004B R 00	 	 	CMP	USLMOD,0
 0E67  74 22	 	 	 	JE	PTC0$
 0E69  50	 	 	 	PUSH	AX	 	;SAVE EVERYTHING
 0E6A  53	 	 	 	PUSH	BX
 0E6B  51	 	 	 	PUSH	CX
 0E6C  56	 	 	 	PUSH	SI
 0E6D  57	 	 	 	PUSH	DI
 0E6E  2A FF	 	 	 	SUB	BH,BH
 0E70  B4 09	 	 	 	MOV	AH,9
 0E72  B9 0001	 	 	 	MOV	CX,1
 0E75  8A 1E 0001 R	 	 	MOV	BL,USLATR
 0E79  CD 10	 	 	 	INT	10H	 	;OUTPUT CHARACTER IN INVERSE VIDEO
 0E7B  B4 03	 	 	 	MOV	AH,3
 0E7D  CD 10	 	 	 	INT	10H	 	;READ CURSOR
 0E7F  42	 	 	 	INC	DX
 0E80  B4 02	 	 	 	MOV	AH,2
 0E82  CD 10	 	 	 	INT	10H	 	;MOVE CURSOR FORWARD
 0E84  5F	 	 	 	POP	DI
 0E85  5E	 	 	 	POP	SI
 0E86  59	 	 	 	POP	CX
 0E87  5B	 	 	 	POP	BX
 0E88  58	 	 	 	POP	AX
 0E89  5D	 	 	 	POP	BP
 0E8A  C3	 	 	 	RET
 0E8B  8B 2E 02C6 R	 	PTC0$:	MOV	BP,CHRPTR	;END OF BUFFER?
 0E8F  3B 2E 02C8 R	 	 	CMP	BP,ENDBUF
 0E93  75 5F	 	 	 	JNE	PTC7$	 	;NO
 0E95  50	 	 	 	PUSH	AX	 	;YES, ENTER OUTPUT ROUTINE; SAVES
 0E96  53	 	 	 	PUSH	BX
 0E97  56	 	 	 	PUSH	SI
 0E98  8B 1E 02C8 R	 	 	MOV	BX,ENDBUF	;END OF BUFFER
 0E9C  BE 04F5 R	 	 	MOV	SI,OFFSET OUTBUF;BEGINNING OF BUFFER
 0E9F  4B	 	 	PTC1$:	DEC	BX	 	;SEARCH FOR SPACE BACKWARDS FROM END
 0EA0  80 3F 20	 	 	 	CMP	BYTE PTR [BX]," "
 0EA3  74 20	 	 	 	JE	PTC3$
 0EA5  3B DE	 	 	 	CMP	BX,SI	 	;STOP AT BEGINNING OF BUFFER
 0EA7  75 F6	 	 	 	JNE	PTC1$
 0EA9	 	 	 	PTC2$:	PRINT	OUTBUF	 	;NO SPACES, OUTPUT WHOLE LINE
 0EA9  50                     +	 	PUSH	AX
 0EAA  B8 04F5 R              +	 	MOV	AX,OFFSET OUTBUF
 0EAD  E8 196F R              +	 	CALL	.PRINT
 0EB0  58                     +	 	POP	AX
 0EB1  89 36 02C6 R	 	 	MOV	CHRPTR,SI	;RESTORE POINTER TO BEGINNING OF BUFFER
 0EB5  8B EC	 	 	 	MOV	BP,SP
 0EB7  80 7E 04 20	 	 	CMP	BYTE PTR [BP+4]," "  ;DID A SPACE CAUSE BUFFER OVERFLOW?
 0EBB  75 2F	 	 	 	JNE	PTC6$	 	;NO
 0EBD  C7 46 04 0000	 	 	MOV	WORD PTR [BP+4],0	;YES, FLUSH IT
 0EC2  EB 28 90	 	 	 	JMP	PTC6$	 	;AND RETURN
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	15-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	TERMINAL I/O

 0EC5  3B DE	 	 	PTC3$:	CMP	BX,SI	 	;DEGENERATE CASE WITH SPACE AT OUTBUF?
 0EC7  74 E0	 	 	 	JE	PTC2$	 	;YES, OUTPUT WHOLE LINE
 0EC9  C6 07 00	 	 	 	MOV	BYTE PTR [BX],0	;NO, OUTPUT UP TO SPACE
 	 	 	 	 	PRINT	OUTBUF
 0ECC  50                     +	 	PUSH	AX
 0ECD  B8 04F5 R              +	 	MOV	AX,OFFSET OUTBUF
 0ED0  E8 196F R              +	 	CALL	.PRINT
 0ED3  58                     +	 	POP	AX
 0ED4  A1 02C8 R	 	 	MOV	AX,ENDBUF	;END OF BUFFER
 0ED7  43	 	 	 	INC	BX	 	;START GETTING CHARACTERS AFTER THE SPACE
 0ED8  3B D8	 	 	PTC4$:	CMP	BX,AX	 	;AT END YET?
 0EDA  74 0C	 	 	 	JE	PTC5$	 	;YES
 0EDC  8B E8	 	 	 	MOV	BP,AX	 	;SAVE AX
 	 	 	 	 	MOVM	[SI],[BX],AL	;NO, COPY NEXT CHAR TO BEGINNING OF BUF
 0EDE  8A 07                  +	 	MOV	AL,[BX]
 0EE0  88 04                  +	 	MOV	[SI],AL
 0EE2  8B C5	 	 	 	MOV	AX,BP	 	;RESTORE AX
 0EE4  43	 	 	 	INC	BX
 0EE5  46	 	 	 	INC	SI
 0EE6  EB F0	 	 	 	JMP	PTC4$	 	;AND CONTINUE
 0EE8  89 36 02C6 R	 	PTC5$:	MOV	CHRPTR,SI	;NEXT CHAR WILL GO AFTER COPIED STUFF
 0EEC  5E	 	 	PTC6$:	POP	SI	 	;CLEAN UP
 0EED  5B	 	 	 	POP	BX
 0EEE  58	 	 	 	POP	AX
 0EEF  3D 0000	 	 	 	CMP	AX,0	 	;AND IGNORE A NULL CHARACTER
 0EF2  74 0C	 	 	 	JE	PTC8$
 0EF4  8B 2E 02C6 R	 	PTC7$:	MOV	BP,CHRPTR	;NOW STORE THE CHARACTER IN BUFFER
 0EF8  3E: 88 46 00	 	 	MOV	DS:[BP],AL
 0EFC  FF 06 02C6 R	 	 	INC	CHRPTR	 	;UPDATE POINTER
 0F00  5D	 	 	PTC8$:	POP	BP	 	;RESTORE
 0F01  C3	 	 	 	RET	 	 	;AND RETURN
 0F02	 	 	 	PUTCHR	ENDP
 	 	 	 	
 	 	 	 	 	;GO TO NEW LINE, OUTPUTTING CURRENT BUFFER
 0F02	 	 	 	NEWLIN	PROC
 0F02  53	 	 	 	PUSH	BX	 	;SAVE
 0F03  8B 1E 02C6 R	 	 	MOV	BX,CHRPTR	;END LINE AT CURRENT POINT
 0F07  C6 07 00	 	 	 	MOV	BYTE PTR [BX],0
 0F0A  C7 06 02C6 R 04F5 R	 	MOV	CHRPTR,OFFSET OUTBUF  ;RESET CHARACTER POINTER
 0F10  5B	 	 	 	POP	BX	 	;RESTORE
 	 	 	 	 	PRINT	OUTBUF	 	;AND OUTPUT LINE
 0F11  50                     +	 	PUSH	AX
 0F12  B8 04F5 R              +	 	MOV	AX,OFFSET OUTBUF
 0F15  E8 196F R              +	 	CALL	.PRINT
 0F18  58                     +	 	POP	AX
 0F19  C3	 	 	 	RET
 0F1A	 	 	 	NEWLIN	ENDP
 	 	 	 	
 = 000F	 	 	 	EOICHR	EQU	15	 	;CARRIAGE RETURN IS NORMAL END OF INPUT
 	 	 	 	
 	 	 	 	 	SUBTTL	TOP LEVEL STUFF
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	16-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	TOP LEVEL STUFF

 	 	 	 	 	PAGE	+
 	 	 	 	
 = 0000	 	 	 	PVERS1	EQU	0	 	;POSITION OF ZVERSION VERSION BYTE
 = 0001	 	 	 	PVERS2	EQU	1	 	;ZVERSION MODE BYTE
 = 0002	 	 	 	PZRKID	EQU	2	 	;ZORKID
 = 0004	 	 	 	PENDLD	EQU	4	 	;ENDLOD
 = 0006	 	 	 	PSTART	EQU	6	 	;START
 = 0008	 	 	 	PVOCTB	EQU	10Q	 	;VOCAB
 = 000A	 	 	 	POBJTB	EQU	12Q	 	;OBJECT
 = 000C	 	 	 	PGLOTB	EQU	14Q	 	;GLOBALS
 = 000E	 	 	 	PPURBT	EQU	16Q	 	;PURBOT
 = 0010	 	 	 	PFLAGS	EQU	20Q	 	;USER FLAG WORD
 = 0012	 	 	 	PSERNM	EQU	22Q	 	;SERIAL NUMBER (6 BYTES)
 = 0018	 	 	 	PWRDTB	EQU	30Q	 	;WORDS
 = 001A	 	 	 	PLENTH	EQU	32Q	 	;GAME LENGTH
 = 001C	 	 	 	PCHKSM	EQU	34Q	 	;GAME CHECKSUM
 = 0050	 	 	 	LMOUTB	EQU	80	 	;MAX LENGTH OF OUTBUF, EXCLUDING TERMINAL 0
 = 0050	 	 	 	LDOUTB	EQU	80	 	;DEFAULT LENGTH OF OUTBUF
 = 0080	 	 	 	LPAGES	EQU	128	 	;MAX NUMBER OF PAGES EXPECTED
 = 0750	 	 	 	LXBYTS	EQU	LSTACK+LMOUTB+(4*LPAGES)+2000Q  ;LENGTH OF EXTRA BYTES NEEDED
 	 	 	 	
 	 	 	 	 	;INITIALIZATION
 0F1A	 	 	 	TSETUP	PROC
 0F1A  F6 06 066C R 01	 	 	TEST	INIFLG,INIWID	;CHECK FOR FORCED 40 COLUMN MODE
 0F1F  74 06	 	 	 	JZ	TS0$
 0F21  C7 06 02D4 R 0026	 	MOV	TWIDTH,38	;FORCE IT TO 40
 0F27  BB 04F5 R	 	TS0$:	MOV	BX,OFFSET OUTBUF	;START OF OUTPUT BUFFER
 0F2A  03 1E 02D4 R	 	 	ADD	BX,TWIDTH	;ADD LENGTH OF BUFFER
 0F2E  2A 1E 02DA R	 	 	SUB	BL,LFTMAR	; *** SUBTRACT THE LEFT MARGIN VALUE
 0F32  89 1E 02C8 R	 	 	MOV	ENDBUF,BX	;THIS IS ENDBUF POINTER
 0F36  C6 07 00	 	 	 	MOV	BYTE PTR [BX],0	;BUFFER IS FOLLOWED BY A 0 FOR CONVENIENCE
 0F39  BB 0051 R	 	 	MOV	BX,OFFSET SLSTAB ;GET STATUS LINE TABLE
 0F3C  83 3E 02DD R 00	 	 	CMP	TIMEMD,0	;CHECK FOR SCORE/TIME MODE
 0F41  74 03	 	 	 	JE	TS1$
 0F43  83 C3 08	 	 	 	ADD	BX,8	 	;THE TIME MODE TABLE IS OFFSET FOUR WORDS
 0F46  BE 0000	 	 	TS1$:	MOV	SI,0	 	;OFFSET INTO PROPER TABLE
 0F49  83 3E 02D4 R 26	 	 	CMP	TWIDTH,38	;CHECK TERMINAL WIDTH
 0F4E  74 03	 	 	 	JE	TS2$
 0F50  83 C6 04	 	 	 	ADD	SI,4	 	;OFFSET TO 80 COLUMN STUFF
 0F53  8B 00	 	 	TS2$:	MOV	AX,[BX][SI]
 0F55  A3 004D R	 	 	MOV	SLSTR,AX
 0F58  8B 48 02	 	 	 	MOV	CX,2[BX][SI]
 0F5B  89 0E 004F R	 	 	MOV	SLTAB,CX	;GET THE RIGHT POINTERS TO STRING/TABLE
 0F5F  8A 1E 0001 R	 	 	MOV	BL,USLATR	;INVERSE VIDEO, STRING ALREADY IN AX
 0F63  B9 0000	 	 	 	MOV	CX,0	 	;AT 0,LFTMAR
 0F66  E8 198B R	 	 	CALL	.PRINTA	 	;PRINT THE STATUS LINE
 0F69  C3	 	 	 	RET
 0F6A	 	 	 	TSETUP	ENDP
 	 	 	 	
 0F6A	 	 	 	ZIPBGN	PROC
 0F6A  E8 13A6 R	 	 	CALL	SYSINI	 	;DO ANY SYSTEM INITIALIZATION
 0F6D  E8 1566 R	 	 	CALL	BKCHK	 	;CHECK FOR MAKING BACKUP COPY
 0F70  E8 1A0A R	 	STR5$:	CALL	.GETMEM
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	16-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	TOP LEVEL STUFF

 0F73  8C C3	 	 	 	MOV	BX,ES
 0F75  2B C3	 	 	 	SUB	AX,BX
 0F77  A3 02DB R	 	 	MOV	MEMTOP,AX	;LAST AVAILABLE PARAGRAPH LOCATION
 0F7A  2B C0	 	 	 	SUB	AX,AX	 	;BLOCK 0
 0F7C  2B DB	 	 	 	SUB	BX,BX	 	;PUT AT BEGINNING OF GAME SEGMENT
 0F7E  E8 147B R	 	 	CALL	GETBLK	 	;GET THE BLOCK
 0F81  26: 80 3E 0000 03	 	CMP	BYTE PTR ES:[PVERS1],ZMVERS  ;PROPER Z-MACHINE VERSION?
 0F87  75 08	 	 	 	JNE	STR8$	 	;NO
 0F89  26: F6 06 0001 01	 	TEST	BYTE PTR ES:[PVERS2],1  ;YES,PROPER MODE BITS?
 0F8F  74 12	 	 	 	JE	STR9$	 	;YES
 0F91	 	 	 	STR8$:	FATAL	FTL4	 	;SOMETHING WRONG, DIE
 0F91  E8 18F0 R              +	 	CALL	.CRLF
 0F94  B8 09DF R              +	 	MOV	AX,OFFSET FATHDR
 0F97  E8 196F R              +	 	CALL	.PRINT
 0F9A  B8 0994 R              +	 	MOV	AX,OFFSET FTL4
 0F9D  E8 196F R              +	 	CALL	.PRINT
 0FA0  E9 1A47 R              +	 	JMP	FINISH
 0FA3  26: F6 06 0001 02	STR9$: 	TEST	BYTE PTR ES:[PVERS2],2  ;TIME MODE REQUESTED?
 0FA9  74 04	 	 	 	JE	STR10$	 	;NO
 0FAB  FF 06 02DD R	 	 	INC	TIMEMD	 	;YES
 0FAF	 	 	 	STR10$:	GTAWRD	A,[PZRKID]	;UNIQUE GAME & VERSION INDENTIFER
 0FAF  26: A1 0002            +	 	MOV	AX,ES:[PZRKID]
 0FB3  86 E0                  +	 	XCHG	AH,AL
 0FB5  A3 02DF R	 	 	MOV	ZORKID,AX
 0FB8  26: 80 0E 0001 20	 	OR	BYTE PTR ES:[PVERS2],0020H	 ;SET SPLIT BIT
 	 	 	 	 	GTAWRD	A,[PENDLD]	;GET ENDLOD POINTER
 0FBE  26: A1 0004            +	 	MOV	AX,ES:[PENDLD]
 0FC2  86 E0                  +	 	XCHG	AH,AL
 0FC4  A9 01FF	 	 	 	TEST	AX,1FFH	 	;ROUND UP TO NEXT BLOCK
 0FC7  74 06	 	 	 	JE	STR12$
 0FC9  25 FE00	 	 	 	AND	AX,0FE00H
 0FCC  05 0200	 	 	 	ADD	AX,200H
 0FCF  8B C8	 	 	STR12$:	MOV	CX,AX
 0FD1  8B E9	 	 	 	MOV	BP,CX	 	;EXTRACT ENDLOD BLOCK
 0FD3  B1 09	 	 	 	MOV	CL,9
 0FD5  D3 FD	 	 	 	SAR	BP,CL
 0FD7  8B CD	 	 	 	MOV	CX,BP
 0FD9  89 0E 02E1 R	 	 	MOV	ENDLOD,CX	;SAVE ENDLOD BLOCK NUMBER
 0FDD  49	 	 	 	DEC	CX	 	;NUMBER OF BLOCKS LEFT TO LOAD
 0FDE  B8 0001	 	 	 	MOV	AX,1	 	;STARTING WITH BLOCK 1
 0FE1  BB 0200	 	 	 	MOV	BX,200H	 	;LOCATION TO PUT THEM
 0FE4  E8 149E R	 	 	CALL	GTBLKS	 	;GET THE BLOCKS
 	 	 	 	 	GTAWRD	A,[PVOCTB]	;VOCAB LOCATION
 0FE7  26: A1 0008            +	 	MOV	AX,ES:[PVOCTB]
 0FEB  86 E0                  +	 	XCHG	AH,AL
 0FED  A3 02E3 R	 	 	MOV	VOCTAB,AX	;SAVE VOCABULARY TABLE POINTER
 	 	 	 	 	GTAWRD	A,[POBJTB]	;GET OBJECT TABLE POINTER
 0FF0  26: A1 000A            +	 	MOV	AX,ES:[POBJTB]
 0FF4  86 E0                  +	 	XCHG	AH,AL
 0FF6  A3 02E5 R	 	 	MOV	OBJTAB,AX
 	 	 	 	 	GTAWRD	A,[PGLOTB]	;GET GLOBAL TABLE POINTER
 0FF9  26: A1 000C            +	 	MOV	AX,ES:[PGLOTB]
 0FFD  86 E0                  +	 	XCHG	AH,AL
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	16-3
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	TOP LEVEL STUFF

 0FFF  A3 02E7 R	 	 	MOV	GLOTAB,AX
 	 	 	 	 	GTAWRD	A,[PWRDTB]	;GET WORD TABLE POINTER
 1002  26: A1 0018            +	 	MOV	AX,ES:[PWRDTB]
 1006  86 E0                  +	 	XCHG	AH,AL
 1008  A3 02E9 R	 	 	MOV	WRDTAB,AX
 	 	 	 	 	GTAWRD	A,[PPURBT]	;GET PURE CODE POINTER
 100B  26: A1 000E            +	 	MOV	AX,ES:[PPURBT]
 100F  86 E0                  +	 	XCHG	AH,AL
 1011  A9 01FF	 	 	 	TEST	AX,1FFH	 	;ROUND UP TO NEXT BLOCK
 1014  74 03	 	 	 	JE	STR13$
 1016  05 0200	 	 	 	ADD	AX,200H
 1019  B1 09	 	 	STR13$:	MOV	CL,9	 	;EXTRACT BLOCK NUMBER
 101B  D3 F8	 	 	 	SAR	AX,CL
 101D  25 007F	 	 	 	AND	AX,7FH	 	;CLEAR UNWANTED BITS
 1020  A3 02EB R	 	 	MOV	PURBOT,AX	;SAVE IT
 1023  BB 0546 R	 	 	MOV	BX,OFFSET RBRKS	;START OF READ BREAK CHARACTER TABLE
 1026  8B 36 02E3 R	 	 	MOV	SI,VOCTAB	;VOCAB TABLE POINTER
 102A  26: 8A 0C	 	 	MOV	CL,BYTE PTR ES:[SI]  ;1ST BYTE IN VOCTAB IS # OF SIBREAKS
 102D  2A ED	 	 	 	SUB	CH,CH	 	;CLEAR HIGH BYTE
 102F  46	 	 	 	INC	SI
 1030	 	 	 	STR14$:	MOVM	[BX],ES:[SI],AL ;TRANSFER THEM
 1030  26: 8A 04              +	 	MOV	AL,ES:[SI]
 1033  88 07                  +	 	MOV	[BX],AL
 1035  43	 	 	 	INC	BX
 1036  46	 	 	 	INC	SI
 1037  E2 F7	 	 	 	LOOP	STR14$
 1039  89 1E 02ED R	 	 	MOV	ESIBKS,BX	;REMEMBER END OF SI BREAKS
 103D  BD 02CC R	 	 	MOV	BP,OFFSET IRBRKS;ALWAYS END WITH INITIAL BREAK CHARACTERS
 1040	 	 	 	STR15$:	MOVM	[BX],DS:[BP],AL	;TRANSFER THEM
 1040  3E: 8A 46 00           +	 	MOV	AL,DS:[BP]
 1044  88 07                  +	 	MOV	[BX],AL
 1046  43	 	 	 	INC	BX
 1047  45	 	 	 	INC	BP
 1048  3C 00	 	 	 	CMP	AL,0
 104A  75 F4	 	 	 	JNE	STR15$
 104C  26: 8A 04	 	 	MOV	AL,ES:[SI]	;GET VOCABULARY ENTRY LENGTH
 104F  2A E4	 	 	 	SUB	AH,AH
 1051  A3 02EF R	 	 	MOV	VWLEN,AX	;AND STORE IT AWAY
 1054  46	 	 	 	INC	SI
 	 	 	 	 	GTAWRD	A,[SI]	 	;GET NEXT WORD IN TABLE
 1055  26: 8B 04              +	 	MOV	AX,ES:[SI]
 1058  86 E0                  +	 	XCHG	AH,AL
 105A  A3 02F1 R	 	 	MOV	VWORDS,AX	;NUMBER OF WORD ENTRIES IN VOCABULARY
 105D  83 C6 02	 	 	 	ADD	SI,2	 	;MOVE TO NEXT WORD
 1060  89 36 02F3 R	 	 	MOV	VOCBEG,SI	;BEGINNING OF ACTUAL VOCABULARY
 	 	 	 	
 1064  8B 36 02E1 R	 	 	MOV	SI,ENDLOD	;GET # PAGES IN ENDLOD
 1068  B1 09	 	 	 	MOV	CL,9
 106A  D3 E6	 	 	 	SHL	SI,CL	 	;THIS IS FIRST LOCATION (ES:) OF PAGING 
 106C  89 36 0667 R	 	 	MOV	PAGES,SI	;SAVE THIS TO USE AS AN OFFSET
 	 	 	 	
 1070  8B 36 02E1 R	 	 	MOV	SI,ENDLOD	;GET # PAGES IN ENDLOD
 1074  F7 DE	 	 	 	NEG	SI
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	16-4
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	TOP LEVEL STUFF

 1076  8B 3E 02DB R	 	 	MOV	DI,MEMTOP	;GET PARAGRAPHS OF MEMORY
 107A  B1 05	 	 	 	MOV	CL,5
 107C  D3 FF	 	 	 	SAR	DI,CL	 	;CHANGE TO PAGES
 107E  03 F7	 	 	 	ADD	SI,DI	 	;NUMBER OF PAGES FOR PAGING
 1080  89 36 0669 R	 	 	MOV	BUFPGS,SI	;SAVE THIS NUMBER FOR FUTURE REFERENCE
 1084  83 3E 0669 R 3F	 	 	CMP	BUFPGS,63
 1089  7E 09	 	 	 	JLE	STR16$
 108B  C7 06 0669 R 003F	 	MOV	BUFPGS,63	;OUR TABLE IS ONLY SO BIG....
 1091  BE 003F	 	 	 	MOV	SI,63
 1094  D1 E6	 	 	STR16$:	SHL	SI,1
 1096  D1 E6	 	 	 	SHL	SI,1	 	;EACH PAGE HAS 4 BYTES OF INFO
 1098  BB 0566 R	 	 	MOV	BX,OFFSET PAGTAB  ;POINT INTO PAGE INFO TABLE
 109B  03 F3	 	 	 	ADD	SI,BX
 109D  C7 04 FFFF	 	 	MOV	WORD PTR [SI],-1  ;MAKE THIS THE END OF TABLE MARK
 	 	 	 	
 10A1  E8 1A34 R	 	 	CALL	.GETTM	 	;GET THE CURRENT TIME-OF-DAY
 	 	 	 	 	MOVM	RSEED1,TIME[2],AX;USE IT TO INITIALIZE RANDOM NUMBER SEED
 10A4  A1 0960 R              +	 	MOV	AX,TIME[2]
 10A7  A3 02AF R              +	 	MOV	RSEED1,AX
 	 	 	 	 	MOVM	RSEED2,TIME,AX	;BE CONSISTENT
 10AA  A1 095E R              +	 	MOV	AX,TIME
 10AD  A3 02B1 R              +	 	MOV	RSEED2,AX
 10B0  EB 13 90	 	 	STR17$:	JMP	START1
 10B3	 	 	 	ZIPBGN	ENDP
 	 	 	 	
 10B3	 	 	 	PRSPC	PROC
 10B3  50	 	 	 	PUSH	AX
 10B4  53	 	 	 	PUSH	BX
 10B5  51	 	 	 	PUSH	CX
 10B6  E8 09A4 R	 	 	CALL	OPPRNN
 10B9  B0 20	 	 	 	MOV	AL,32
 10BB  E8 0E61 R	 	 	CALL	PUTCHR
 10BE  59	 	 	 	POP	CX
 10BF  5B	 	 	 	POP	BX
 10C0  58	 	 	 	POP	AX
 10C1  C3	 	 	 	RET
 10C2	 	 	 	PRSPC	ENDP
 	 	 	 	
 	 	 	 	 	;RESTART EXECUTION HERE
 10C2	 	 	 	RESTRT	PROC
 10C2  CD 19	 	 	 	INT	19H	 	; REBOOT THE SUCKER FOR NOW
 10C4  C3	 	 	 	RET	 	 	; I'M SENTIMENTAL
 	 	 	 	
 10C5  E8 1527 R	 	START1:	CALL	WPCHK	 	;MAKE SURE GAME DISK IS WRITE-PRO
 10C8  E8 0F1A R	 	 	CALL	TSETUP	 	;SETUP TERMINAL/STATUS LINE
 10CB  E8 1438 R	 	 	CALL	CLRSCR	 	;CLEAR THE REMAINDER OF THE SCREEN
 10CE  BC 0200 R	 	 	MOV	SP,OFFSET STK_TOP	;INIT OUR STACK POINTER
 10D1  BF 0400 R	 	 	MOV	DI,OFFSET ZSTK_TP	;INIT USER STACK POINTER
 10D4  C7 06 02C6 R 04F5 R	 	MOV	CHRPTR,OFFSET OUTBUF	;INIT OUTPUT CHAR. POINTER
 10DA  89 3E 066D R	 	 	MOV	ZLOCS,DI	 	; LOCALS WOULD START AT FIRST SLOT,
 10DE  83 2E 066D R 02	 	 	SUB	ZLOCS,2	 	 	; IF THERE WERE ANY
 	 	 	 	 	GTAWRD	A,[PSTART]
 10E3  26: A1 0006            +	 	MOV	AX,ES:[PSTART]
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	16-5
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	TOP LEVEL STUFF

 10E7  86 E0                  +	 	XCHG	AH,AL
 10E9  E8 0C5D R	 	 	CALL	BSPLTB	 	;SPLIT BLOCK & BYTE POINTERS
 10EC  A3 066F R	 	 	MOV	ZPC1,AX	 	;INIT ZPC BLOCK-POINTER
 10EF  89 1E 0671 R	 	 	MOV	ZPC2,BX	 	;INIT ZPC BYTE-POINTER
 10F3  E8 1245 R	 	 	CALL	NEWZPC	 	;GET PAGE TO EXECUTE
 10F6  80 3E 066C R 05	 	 	CMP	INIFLG,5
 10FB  75 2C	 	 	 	JNE	FUBAR$
 10FD  8C C8	 	 	 	MOV	AX,CS
 10FF  E8 10B3 R	 	 	CALL	PRSPC
 1102  8C D8	 	 	 	MOV	AX,DS
 1104  E8 10B3 R	 	 	CALL	PRSPC
 1107  8C C0	 	 	 	MOV	AX,ES
 1109  E8 10B3 R	 	 	CALL	PRSPC
 110C  8C D0	 	 	 	MOV	AX,SS
 110E  E8 10B3 R	 	 	CALL 	PRSPC
 1111  A1 02E1 R	 	 	MOV	AX,ENDLOD
 1114  E8 10B3 R	 	 	CALL	PRSPC
 1117  A1 0667 R	 	 	MOV	AX,PAGES
 111A  E8 10B3 R	 	 	CALL	PRSPC
 111D  A1 0669 R	 	 	MOV	AX,BUFPGS
 1120  E8 10B3 R	 	 	CALL	PRSPC
 1123  A1 02DB R	 	 	MOV	AX,MEMTOP
 1126  E8 10B3 R	 	 	CALL	PRSPC
 1129  C6 06 0207 R 01	 	FUBAR$:	MOV	FUCK,1
 112E  EB 01 90	 	 	 	JMP	NXTINS
 	 	 	 	
 1131	 	 	 	RESTRT	ENDP
 	 	 	 	 	
 	 	 	 	 	;MAIN INSTRUCTION INTERPRETATION LOOP
 1131	 	 	 	NXTINS	PROC
 1131  E8 0B60 R	 	 	CALL	NXTBYT	 	;GET THE OPERATION BYTE
 1134  8B D0	 	 	 	MOV	DX,AX	 	;SAVE A COPY
 1136  3D 0080	 	 	 	CMP	AX,80H	 	;IS IT A 2OP?
 1139  7C 7D	 	 	 	JL	NXI9$	 	;YES
 113B  3D 00B0	 	 	 	CMP	AX,0B0H	 	;NO, IS IT A 1OP?
 113E  7D 03	 	 	 	JGE	NXI0A$	 	;NO
 1140  E9 11FA R	 	 	JMP	NXI12$	 	;YES
 1143  3D 00C0	 	 	NXI0A$:	CMP	AX,0C0H	 	;IS IT A 0OP?
 1146  7F 03	 	 	 	JG	NXI0B$	 	;NO
 1148  E9 121D R	 	 	JMP	NXI13$	 	;YES
 114B  25 003F	 	 	NXI0B$:	AND	AX,3FH	 	;IT'S EXTENDED, GET THE OPCODE
 114E  D1 E0	 	 	 	SHL	AX,1	 	;MAKE IT A WORD OFFSET
 1150  8B E8	 	 	 	MOV	BP,AX	 	;GET THE OPERATOR POINTER
 1152  3E: 8B B6 08D0 R	 	 	MOV	SI,DS:[BP+EXTOP]
 1157  83 FE 00	 	 	 	CMP	SI,0
 115A  75 03	 	 	 	JNE	NXI0C$	 	;OPERATION EXISTS
 115C  E9 122E R	 	 	JMP	NXI14$	 	;NO SUCH OPERATION
 115F  E8 0B60 R	 	NXI0C$:	CALL	NXTBYT	 	;GET THE ARGUMENT BYTE
 1162  B9 0004	 	 	 	MOV	CX,4	 	;SPLIT IT INTO 4 2-BIT MODE BYTES
 1165  50	 	 	NXI1$:	PUSH	AX
 1166  D1 F8	 	 	 	SAR	AX,1
 1168  D1 F8	 	 	 	SAR	AX,1
 116A  E2 F9	 	 	 	LOOP	NXI1$
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	16-6
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	TOP LEVEL STUFF

 116C  B9 0004	 	 	 	MOV	CX,4	 	;RETRIEVE THE 4 BYTES IN PROPER ORDER
 116F  2B D2	 	 	 	SUB	DX,DX
 1171  BB 0673 R	 	 	MOV	BX,OFFSET ARGBLK;FIRST ARGUMENT SLOT
 1174  58	 	 	NXI2$:	POP	AX	 	;GET NEXT MODE BYTE?
 1175  25 0003	 	 	 	AND	AX,3	 	;CLEAR OFF UNWANTED BITS
 1178  3D 0003	 	 	 	CMP	AX,3	 	;NO MORE ARGUMENTS?
 117B  74 0E	 	 	 	JE	NXI4$	 	;YES, FLUSH ANY OTHER MODE BYTES
 117D  E8 0B8D R	 	 	CALL	GETARG	 	;ELSE, GET THE NEXT ARGUMENT
 1180  89 07	 	 	 	MOV	[BX],AX	 	;SAVE IT IN ARGUMENT BLOCK
 1182  83 C3 02	 	 	 	ADD	BX,2
 1185  42	 	 	 	INC	DX	 	;REMEMBER NUMBER OF ARGS GOTTEN
 1186  E2 EC	 	 	NXI3$:	LOOP	NXI2$	 	;LOOP FOR REST OF MODE BYTES
 1188  EB 06 90	 	 	 	JMP	NXI5$
 118B  49	 	 	NXI4$:	DEC	CX	 	;DETERMINE NUMBER OF REMAINING MODE BYTES
 118C  D1 E1	 	 	 	SHL	CX,1	 	;WORD COUNT
 118E  03 E1	 	 	 	ADD	SP,CX	 	;FLUSH THEM
 1190  87 CA	 	 	NXI5$:	XCHG	CX,DX
 1192  8B C1	 	 	 	MOV	AX,CX	 	;NUMBER OF ARGS GOES HERE FOR OPERATOR TO USE
 1194  2E: 80 3C 90	 	 	CMP	CS:BYTE PTR [SI],90H  ;DOES OPERATOR WANT ARGBLK POINTER?
 1198  74 1B	 	 	 	JE	NXI8A$	 	;YES, CALL OPERATOR NOW
 119A  49	 	 	 	DEC	CX	 	;NO, IT WANTS ARGS IN REGISTERS
 119B  7C 18	 	 	 	JL	NXI8A$	 	;NO ARGS, JUST CALL OPERATOR
 119D  74 13	 	 	 	JE	NXI8$	 	;1 ARG, GET IT
 119F  83 E9 02	 	 	 	SUB	CX,2
 11A2  7C 0A	 	 	 	JL	NXI7$	 	;2 ARGS
 11A4  74 04	 	 	 	JE	NXI6$	 	;3 ARGS
 11A6  8B 16 0679 R	 	 	MOV	DX,ARGBLK[6]	;ELSE, 4 ARGS, GET 4TH
 11AA  8B 0E 0677 R	 	NXI6$:	MOV	CX,ARGBLK[4]	;GET 3RD
 11AE  8B 1E 0675 R	 	NXI7$:	MOV	BX,ARGBLK[2]	;GET 2ND
 11B2  A1 0673 R	 	NXI8$:	MOV	AX,ARGBLK	;GET FIRST ARG
 11B5  E9 1240 R	 	NXI8A$:	JMP	NXI15$	 	;AND CALL OPERATOR
 11B8  25 001F	 	 	NXI9$:	AND	AX,1FH	 	;2OP, EXTRACT OPERATION BITS
 11BB  D1 E0	 	 	 	SHL	AX,1	 	;MAKE IT A WORD OFFSET
 11BD  8B E8	 	 	 	MOV	BP,AX	 	;FIND POINTER TO OPERATOR ROUTINE
 11BF  3E: 8B B6 08D0 R	 	 	MOV	SI,DS:[BP+EXTOP]
 11C4  83 FE 00	 	 	 	CMP	SI,0
 11C7  74 65	 	 	 	JE	NXI14$	 	;NO SUCH OPERATION
 11C9  B8 0001	 	 	 	MOV	AX,1	 	;ASSUME FIRST ARG IS AN IMMEDIATE
 11CC  F7 C2 0040	 	 	TEST	DX,40H	 	;IS IT INSTEAD A VARIABLE?
 11D0  74 01	 	 	 	JE	NXI10$	 	;NO
 11D2  40	 	 	 	INC	AX	 	;YES, CHANGE MODE
 11D3  E8 0B8D R	 	NXI10$:	CALL	GETARG	 	;GET THE FIRST ARG
 11D6  50	 	 	 	PUSH	AX	 	;SAVE IT
 11D7  B8 0001	 	 	 	MOV	AX,1	 	;ASSUME SECOND ARG IS AN IMMEDIATE
 11DA  F7 C2 0020	 	 	TEST	DX,20H	 	;IS IT INSTEAD A VARIABLE?
 11DE  74 01	 	 	 	JE	NXI11$	 	;NO
 11E0  40	 	 	 	INC	AX	 	;YES, CHANGE MODE
 11E1  E8 0B8D R	 	NXI11$:	CALL	GETARG	 	;GET THE SECOND ARG
 11E4  8B D8	 	 	 	MOV	BX,AX	 	;POSITION IT
 11E6  58	 	 	 	POP	AX	 	;RECOVER FIRST ARG
 11E7  2E: 80 3C 90	 	 	CMP	CS:BYTE PTR [SI],90H  ;DOES ROUTINE WANT ARGUMENT BLOCK?
 11EB  75 53	 	 	 	JNE	NXI15$	 	;NO, GO CALL IT
 11ED  A3 0673 R	 	 	MOV	ARGBLK,AX	;YES, MOVE ARGS TO ARGBLK
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	16-7
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	TOP LEVEL STUFF

 11F0  89 1E 0675 R	 	 	MOV	ARGBLK[2],BX
 11F4  B8 0002	 	 	 	MOV	AX,2	 	;ALWAYS 2 ARGS
 11F7  EB 47 90	 	 	 	JMP	NXI15$	 	;NOW CALL OPERATOR
 11FA  81 E2 000F	 	NXI12$:	AND	DX,0FH	 	;1OP, EXTRACT OPERATION BITS
 11FE  D1 E2	 	 	 	SHL	DX,1	 	;MAKE IT A WORD OFFSET
 1200  8B EA	 	 	 	MOV	BP,DX	 	;GET OPERATOR ROUTINE POINTER
 1202  3E: 8B B6 08B0 R	 	 	MOV	SI,DS:[BP+ONEOP]
 1207  83 FE 00	 	 	 	CMP	SI,0
 120A  74 22	 	 	 	JE	NXI14$	 	;ILLEGAL OPERATION
 120C  D1 F8	 	 	 	SAR	AX,1	 	;EXTRACT MODE BITS
 120E  D1 F8	 	 	 	SAR	AX,1
 1210  D1 F8	 	 	 	SAR	AX,1
 1212  D1 F8	 	 	 	SAR	AX,1
 1214  25 0003	 	 	 	AND	AX,3
 1217  E8 0B8D R	 	 	CALL	GETARG	 	;GET THE ARGUMENT
 121A  EB 24 90	 	 	 	JMP	NXI15$	 	;AND CALL OPERATOR
 121D  25 000F	 	 	NXI13$:	AND	AX,0FH	 	;0OP, EXTRACT OPERATION BITS
 1220  D1 E0	 	 	 	SHL	AX,1	 	;MAKE IT A WORD OFFSET
 1222  8B E8	 	 	 	MOV	BP,AX	 	;GET OPERATOR ROUTINE POINTER
 1224  3E: 8B B6 0890 R	 	 	MOV	SI,DS:[BP+ZEROOP]
 1229  83 FE 00	 	 	 	CMP	SI,0
 122C  75 12	 	 	 	JNE	NXI15$	 	;IT'S A LEGAL OPERATION
 122E	 	 	 	NXI14$:	FATAL	FTL5	 	;OTHERWISE, COMPLAIN
 122E  E8 18F0 R              +	 	CALL	.CRLF
 1231  B8 09DF R              +	 	MOV	AX,OFFSET FATHDR
 1234  E8 196F R              +	 	CALL	.PRINT
 1237  B8 09AA R              +	 	MOV	AX,OFFSET FTL5
 123A  E8 196F R              +	 	CALL	.PRINT
 123D  E9 1A47 R              +	 	JMP	FINISH
 1240  FF D6	 	 	NXI15$:	CALL	SI	 	;CALL THE OPERATOR ROUTINE
 1242  E9 1131 R	 	 	JMP	NXTINS	 	;AND LOOP FOR NEXT INSTRUCTION
 1245	 	 	 	NXTINS	ENDP
 	 	 	 	
 	 	 	 	 	SUBTTL	PAGING ROUTINES
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	17-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	PAGING ROUTINES

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	 	;NORMALIZE ZPC & GET PROPER PAGE
 1245	 	 	 	NEWZPC	PROC
 1245  56	 	 	 	PUSH	SI	 	;SAVES
 1246  55	 	 	 	PUSH	BP
 1247  53	 	 	 	PUSH	BX
 1248  51	 	 	 	PUSH	CX
 1249  52	 	 	 	PUSH	DX
 124A  2B C0	 	 	 	SUB	AX,AX	 	;USE DOUBLE-WORD ARITHMETIC
 124C  8B 1E 066F R	 	 	MOV	BX,ZPC1	 	;GET BLOCK-POINTER
 1250  8A FB	 	 	 	MOV	BH,BL	 	;POSITION IT
 1252  2A DB	 	 	 	SUB	BL,BL
 1254  D1 E3	 	 	 	SHL	BX,1
 1256  15 0000	 	 	 	ADC	AX,0
 1259  8B 36 0671 R	 	 	MOV	SI,ZPC2	 	;GET BYTE-OFFSET
 125D  96	 	 	 	XCHG	SI,AX	 	;DOUBLE-WORDIFY IT (MIGHT BE NEGATIVE)
 125E  99	 	 	 	CWD
 125F  96	 	 	 	XCHG	SI,AX
 1260  03 DE	 	 	 	ADD	BX,SI	 	;ADD IT TO OTHER DOUBLE WORD
 1262  13 C2	 	 	 	ADC	AX,DX
 1264  8B D3	 	 	 	MOV	DX,BX
 1266  81 E2 01FF	 	 	AND	DX,1FFH	 	;EXTRACT BYTE-OFFSET
 126A  89 16 0671 R	 	 	MOV	ZPC2,DX	 	;SAVE IT
 126E  B1 09	 	 	 	MOV	CL,9	 	;EXTRACT BLOCK-POINTER
 1270  D3 FB	 	 	 	SAR	BX,CL
 1272  81 E3 007F	 	 	AND	BX,7FH
 1276  A9 0001	 	 	 	TEST	AX,1	 	;TEST 17TH BIT
 1279  74 04	 	 	 	JE	NWZ1$	 	;WAS 0
 127B  81 CB 0080	 	 	OR	BX,80H	 	;WAS 1, SET PROPER BIT IN BLOCK-POINTER
 127F  89 1E 066F R	 	NWZ1$:	MOV	ZPC1,BX	 	;SAVE IT
 1283  3B 1E 067D R	 	 	CMP	BX,CURBLK	;HAS IT CHANGED?
 1287  74 52	 	 	 	JE	NWZ5$	 	;NO
 1289  89 1E 067D R	 	 	MOV	CURBLK,BX	;YES, REMEMBER NEW BLOCK
 128D  A1 067F R	 	 	MOV	AX,CURTAB	;IS OLD PAGE IN PAGING SPACE?
 1290  3D 0000	 	 	 	CMP	AX,0
 1293  74 13	 	 	 	JE	NWZ2$	 	;NO
 1295  8B E8	 	 	 	MOV	BP,AX	 	;YES, STORE CURRENT REF TIME FOR OLD PAGE
 	 	 	 	 	MOVM	DS:[BP],RTIME1,CL
 1297  8A 0E 0681 R           +	 	MOV	CL,RTIME1
 129B  3E: 88 4E 00           +	 	MOV	DS:[BP],CL
 	 	 	 	 	MOVM	DS:[BP+1],RTIME2,CX
 129F  8B 0E 0682 R           +	 	MOV	CX,RTIME2
 12A3  3E: 89 4E 01           +	 	MOV	DS:[BP+1],CX
 12A7  40	 	 	 	INC	AX
 12A8  3B 1E 02E1 R	 	NWZ2$:	CMP	BX,ENDLOD	;NEW PAGE ALREADY IN CORE?
 12AC  7C 1F	 	 	 	JL	NWZ3$	 	;YES
 12AE  8B C3	 	 	 	MOV	AX,BX	 	;NO, GET NEW PAGE
 12B0  E8 12E1 R	 	 	CALL	GETPAG
 12B3  8B D8	 	 	 	MOV	BX,AX
 12B5  A1 0688 R	 	 	MOV	AX,LPTAB	;GET NEW PAGE TABLE POINTER
 12B8  40	 	 	 	INC	AX	 	;POINT TO REF SLOT
 12B9  A3 067F R	 	 	MOV	CURTAB,AX	;SAVE THIS POINTER FOR LATER
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	17-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	PAGING ROUTINES

 12BC  8B E8	 	 	 	MOV	BP,AX	 	;STORE HIGHEST RTIME TO KEEP PAGE FOR US
 12BE  3E: C6 46 00 FF	 	 	MOV	BYTE PTR DS:[BP],-1
 12C3  3E: C7 46 01 FFFF	 	MOV	WORD PTR DS:[BP+1],-1
 12C9  40	 	 	 	INC	AX
 12CA  EB 0B 90	 	 	 	JMP	NWZ4$
 12CD  B1 09	 	 	NWZ3$:	MOV	CL,9	 	;CALCULATE PAGE ADDRESS
 12CF  D3 E3	 	 	 	SHL	BX,CL
 12D1  C7 06 067F R 0000	 	MOV	CURTAB,0	;CLEARING POINTER MEANS PAGE IS PRELOADED
 12D7  89 1E 067B R	 	NWZ4$:	MOV	CURPAG,BX	;UPDATE PAGE POINTER
 12DB  5A	 	 	NWZ5$:	POP	DX	 	;RESTORES
 12DC  59	 	 	 	POP	CX
 12DD  5B	 	 	 	POP	BX
 12DE  5D	 	 	 	POP	BP
 12DF  5E	 	 	 	POP	SI
 12E0  C3	 	 	 	RET	 	 	;AND RETURN
 12E1	 	 	 	NEWZPC	ENDP
 	 	 	 	
 	 	 	 	 	;GET THE PAGE WHOSE NUMBER IS IN AX, RETURN A POINTER TO IT IN AX
 12E1	 	 	 	GETPAG	PROC
 12E1  3B 06 0684 R	 	 	CMP	AX,LPAGE	;IS THIS THE SAME PAGE AS LAST REFERENCED?
 12E5  75 04	 	 	 	JNE	GTP1$	 	;NO
 12E7  A1 0686 R	 	 	MOV	AX,LPLOC	;YES, WE ALREADY HAVE LOCATION
 12EA  C3	 	 	 	RET	 	 	;RETURN IT
 12EB  A3 0684 R	 	GTP1$:	MOV	LPAGE,AX	;SAVE NEW PAGE NUMBER
 12EE  51	 	 	 	PUSH	CX	 	;SAVES
 12EF  53	 	 	 	PUSH	BX
 12F0  83 06 0682 R 01	 	 	ADD	RTIME2,1	;UPDATE REFERENCE TIME (COUNT)
 12F5  80 16 0681 R 00	 	 	ADC	RTIME1,0
 12FA  BB 0566 R	 	 	MOV	BX,OFFSET PAGTAB;PAGE INFORMATION TABLE
 12FD  43	 	 	GTP2$:	INC	BX
 12FE  3A 47 FF	 	 	 	CMP	AL,[BX-1]	;SEARCH FOR DESIRED BLOCK
 1301  75 27	 	 	 	JNE	GTP3$	 	;NOT IT
 1303  3B 06 067D R	 	 	CMP	AX,CURBLK	;IS THIS THE CURRENT CODE PAGE?
 1307  74 0D	 	 	 	JE	GTP2A$	 	;DON'T UPDATE REFERENCE TIME
 	 	 	 	 	MOVM	[BX],RTIME1,CL	;FOUND IT, UPDATE ITS REFERENCE TIME
 1309  8A 0E 0681 R           +	 	MOV	CL,RTIME1
 130D  88 0F                  +	 	MOV	[BX],CL
 	 	 	 	 	MOVM	[BX+1],RTIME2,CX
 130F  8B 0E 0682 R           +	 	MOV	CX,RTIME2
 1313  89 4F 01               +	 	MOV	[BX+1],CX
 1316  4B	 	 	GTP2A$:	DEC	BX	 	;BACKUP TO BEGINNING OF TABLE ENTRY
 1317  89 1E 0688 R	 	 	MOV	LPTAB,BX	;SAVE IT
 131B  81 EB 0566 R	 	 	SUB	BX,OFFSET PAGTAB;CALCULATE ADDRESS OF PAGE
 131F  B1 07	 	 	 	MOV	CL,7
 1321  D3 E3	 	 	 	SHL	BX,CL
 1323  03 1E 0667 R	 	 	ADD	BX,PAGES
 1327  EB 28 90	 	 	 	JMP	GTP4$	 	;AND RETURN PAGE POINTER
 132A  83 C3 03	 	 	GTP3$:	ADD	BX,3	 	;SKIP REFERENCE TIME
 132D  83 3F FF	 	 	 	CMP	WORD PTR [BX],-1;END OF TABLE?
 1330  75 CB	 	 	 	JNE	GTP2$	 	;NO, CONTINUE SEARCH
 1332  E8 1359 R	 	 	CALL	FINDPG	 	;YES, FIND A PAGE TO LOAD INTO
 1335  50	 	 	 	PUSH	AX	 	;PAGE POINTER
 1336  89 1E 0688 R	 	 	MOV	LPTAB,BX	;SAVE PAGE TABLE POINTER
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	17-3
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	PAGING ROUTINES

 133A  A1 0684 R	 	 	MOV	AX,LPAGE	;SAVE NEW BLOCK NUMBER
 133D  88 07	 	 	 	MOV	[BX],AL
 	 	 	 	 	MOVM	[BX+1],RTIME1,CL;AND CURRENT REF TIME
 133F  8A 0E 0681 R           +	 	MOV	CL,RTIME1
 1343  88 4F 01               +	 	MOV	[BX+1],CL
 	 	 	 	 	MOVM	[BX+2],RTIME2,CX
 1346  8B 0E 0682 R           +	 	MOV	CX,RTIME2
 134A  89 4F 02               +	 	MOV	[BX+2],CX
 134D  5B	 	 	 	POP	BX	 	;PAGE POINTER
 134E  E8 147B R	 	 	CALL	GETBLK	 	;GET THE BLOCK
 1351  8B C3	 	 	GTP4$:	MOV	AX,BX	 	;RETURN PAGE POINTER
 1353  A3 0686 R	 	 	MOV	LPLOC,AX	;AND SAVE IT FOR LATER
 1356  5B	 	 	 	POP	BX	 	;RESTORES
 1357  59	 	 	 	POP	CX
 1358  C3	 	 	 	RET
 1359	 	 	 	GETPAG	ENDP
 	 	 	 	
 	 	 	 	 	;FIND A GOOD PAGE, RETURN PAGE POINTER IN AX & PAGTAB POINTER IN BX
 1359	 	 	 	FINDPG	PROC
 1359  51	 	 	 	PUSH	CX
 135A  BB 0566 R	 	 	MOV	BX,OFFSET PAGTAB
 135D  B9 FFFF	 	 	 	MOV	CX,-1	 	;FAKE BEST-CASE REFERENCE COUNT
 1360  8B D1	 	 	 	MOV	DX,CX
 1362  43	 	 	 	INC	BX	 	;SKIP BLOCK NUMBER FOR NOW
 1363  43	 	 	FNP1$:	INC	BX	 	;IS THIS REF TIME WORSE THAN CURRENT WORST?
 1364  38 4F FF	 	 	 	CMP	[BX-1],CL
 1367  77 0D	 	 	 	JA	FNP3$	 	;NO
 1369  72 04	 	 	 	JB	FNP2$	 	;YES
 136B  39 17	 	 	 	CMP	[BX],DX	 	;MAYBE, COMPARE LOW-ORDER WORDS, WORSE?
 136D  73 07	 	 	 	JAE	FNP3$	 	;NO
 136F  8A 4F FF	 	 	FNP2$:	MOV	CL,[BX-1]	;YES, SAVE ITS REF COUNT
 1372  8B 17	 	 	 	MOV	DX,[BX]
 1374  8B C3	 	 	 	MOV	AX,BX	 	;AND LOCATION (+2)
 1376  83 C3 03	 	 	FNP3$:	ADD	BX,3	 	;SKIP SECOND WORD
 1379  80 7F FF FF	 	 	CMP	BYTE PTR [BX-1],-1	;LOOP UNTIL END OF TABLE
 137D  75 E4	 	 	 	JNE	FNP1$
 137F  41	 	 	 	INC	CX	 	;WAS A PAGE REALLY FOUND?
 1380  74 12	 	 	 	JE	FNP4$	 	;NO, GROSS BUG!
 1382  2D 0002	 	 	 	SUB	AX,2	 	;YES, CALCULATE CORE LOCATION OF PAGE
 1385  8B D8	 	 	 	MOV	BX,AX
 1387  2D 0566 R	 	 	SUB	AX,OFFSET PAGTAB
 138A  B1 07	 	 	 	MOV	CL,7
 138C  D3 E0	 	 	 	SHL	AX,CL
 138E  03 06 0667 R	 	 	ADD	AX,PAGES
 1392  59	 	 	 	POP	CX	 	;RESTORES
 1393  C3	 	 	 	RET
 1394	 	 	 	FNP4$:	FATAL	FTL6
 1394  E8 18F0 R              +	 	CALL	.CRLF
 1397  B8 09DF R              +	 	MOV	AX,OFFSET FATHDR
 139A  E8 196F R              +	 	CALL	.PRINT
 139D  B8 09BC R              +	 	MOV	AX,OFFSET FTL6
 13A0  E8 196F R              +	 	CALL	.PRINT
 13A3  E9 1A47 R              +	 	JMP	FINISH
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	17-4
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	PAGING ROUTINES

 13A6	 	 	 	FINDPG	ENDP
 	 	 	 	
 	 	 	 	 	SUBTTL	HIGH LEVEL IBMPC DEPENDENT STUFF
 	 	 	 	
 	 	 	 	 	;SYSTEM INITIALIZATION
 13A6	 	 	 	SYSINI	PROC
 13A6  B4 0F	 	 	 	MOV	AH,15
 13A8  CD 10	 	 	 	INT	10H	 	;CHECK VIDEO STATE
 13AA  8A DC	 	 	 	MOV	BL,AH	 	;GET SCREEN WIDTH
 13AC  2A FF	 	 	 	SUB	BH,BH	 	;AND ZERO HIGH END
 13AE  89 1E 02D4 R	 	 	MOV	TWIDTH,BX	;SAVE IT AWAY
 13B2  89 1E 02D6 R	 	 	MOV	RWIDTH,BX
 13B6  83 2E 02D4 R 02	 	 	SUB	TWIDTH,2
 13BB  FE 06 02DA R	 	 	INC	LFTMAR	 	; FIX FOR OVERSCAN
 13BF  3C 07	 	 	 	CMP	AL,7
 13C1  74 29	 	 	 	JE	SINIX$
 13C3  A8 01	 	 	 	TEST	AL,1
 13C5  74 25	 	 	 	JZ	SINIX$
 	 	 	 	 	PRINT	COLORQ	 	;ASK IF COLOR IS REALLY NEEDED
 13C7  50                     +	 	PUSH	AX
 13C8  B8 0003 R              +	 	MOV	AX,OFFSET COLORQ
 13CB  E8 196F R              +	 	CALL	.PRINT
 13CE  58                     +	 	POP	AX
 13CF  E8 1864 R	 	 	CALL	.CHRIN	 	;READ A CHARACTER
 13D2  3C 59	 	 	 	CMP	AL,"Y"
 13D4  74 04	 	 	 	JE	SINC$	 	;REALLY WANTS COLOR IF Y OR y
 13D6  3C 79	 	 	 	CMP	AL,"y"
 13D8  75 12	 	 	 	JNE	SINIX$
 13DA  A2 0020 R	 	SINC$:	MOV	COLFLG,AL	; NON-ZERO = THEY WANT COLOR
 13DD  C6 06 0001 R 74	 	 	MOV	USLATR,74H	;MAKE STATUS LINE RED ON WHITE IN COLOR MODE
 13E2  C6 06 0000 R 17	 	 	MOV	NRMATR,17H	;WHITE ON BLUE FOR THE REST
 13E7  C6 06 0002 R 1F	 	 	MOV	TYPATR,1FH	;INPUT WILL BE YELLOW ON BLUE
 	 	 	 	
 13EC  B4 01	 	 	SINIX$:	MOV	AH,1
 13EE  CD 16	 	 	 	INT	16H	 	;CHECK KEYBOARD
 13F0  74 0F	 	 	 	JZ	SINI0$	 	;NO CHARACTER AVAILABLE
 13F2  2C 30	 	 	 	SUB	AL,"0"
 13F4  7C 07	 	 	 	JL	SINIF$
 13F6  3C 09	 	 	 	CMP	AL,9
 13F8  7F 03	 	 	 	JG	SINIF$
 13FA  A2 066C R	 	 	MOV	INIFLG,AL	;SET UP INIT FLAG IF 0-9
 13FD  B4 00	 	 	SINIF$:	MOV	AH,0
 13FF  CD 16	 	 	 	INT	16H	 	;BE NICE AND READ THE CHARACTER
 	 	 	 	
 1401  CD 11	 	 	SINI0$:	INT	11H	 	;DEVICE DETERMINATION
 1403  A8 C0	 	 	 	TEST	AL,0C0H	 	;TEST BITS 7&6 FOR # DRIVES
 1405  75 0A	 	 	 	JNZ	SINI1$
 1407  C6 06 023D R 41	 	 	MOV	SRDRV,"A"	;MAKE DEFAULT DRIVE A FOR 1 DRIVE SYSTEM
 140C  C6 06 0206 R 01	 	 	MOV	NDISKS,1
 	 	 	 	
 1411  F6 06 066C R 02	 	SINI1$:	TEST	INIFLG,INIMEM
 1416  74 05	 	 	 	JZ	SIN1A$
 1418  C6 06 0206 R 01	 	 	MOV	NDISKS,1
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	17-5
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	HIGH LEVEL IBMPC DEPENDENT STUFF

 141D  F6 06 066C R 08	 	SIN1A$:	TEST	INIFLG,8	;CHECK FOR COLOR SETUP
 1422  74 13	 	 	 	JZ	SINI2$
 1424  B0 55	 	 	 	MOV	AL,"U"
 1426  E8 1455 R	 	 	CALL	GETNUM	 	;READ NUMBER FOR USL ATTRIBUTE
 1429  A2 0001 R	 	 	MOV	USLATR,AL
 142C  E8 18F0 R	 	 	CALL	.CRLF
 142F  B0 4E	 	 	 	MOV	AL,"N"
 1431  E8 1455 R	 	 	CALL	GETNUM
 1434  A2 0000 R	 	 	MOV	NRMATR,AL
 1437  C3	 	 	SINI2$:	RET
 1438	 	 	 	SYSINI	ENDP
 	 	 	 	
 1438	 	 	 	CLRSCR	PROC
 1438  B5 01	 	 	 	MOV	CH,1	;CLEAR ACTIVE SCREEN AREA
 143A  B1 00	 	 	 	MOV	CL,0
 143C  8B 16 02D4 R	 	 	MOV	DX,TWIDTH
 1440  FE C2	 	 	 	INC	DL
 1442  80 FA 28	 	 	 	CMP	DL,40
 1445  7E 02	 	 	 	JLE	CLRSC1
 1447  FE C2	 	 	 	INC	DL
 1449  B6 18	 	 	CLRSC1:	MOV	DH,18H
 144B  B8 0600	 	 	 	MOV	AX,0600H
 144E  8A 3E 0000 R	 	 	MOV	BH,NRMATR
 1452  CD 10	 	 	 	INT	10H	 	;CLEAR SCREEN, I HOPE
 1454  C3	 	 	 	RET
 1455	 	 	 	CLRSCR	ENDP
 	 	 	 	
 1455	 	 	 	GETNUM	PROC
 1455  B7 00	 	 	 	MOV	BH,0
 1457  B4 07	 	 	 	MOV	AH,7
 1459  E8 1887 R	 	 	CALL	.TTYOUT	 	;WHAT A PROMPT!
 145C  E8 1864 R	 	 	CALL	.CHRIN
 145F  B4 07	 	 	 	MOV	AH,7
 1461  E8 1887 R	 	 	CALL	.TTYOUT	 	;ECHO
 1464  2C 30	 	 	 	SUB	AL,"0"
 1466  8A D8	 	 	 	MOV	BL,AL
 1468  E8 1864 R	 	 	CALL	.CHRIN
 146B  B4 07	 	 	 	MOV	AH,7
 146D  E8 1887 R	 	 	CALL	.TTYOUT	 	;ECHO
 1470  2C 30	 	 	 	SUB	AL,"0"
 1472  B1 04	 	 	 	MOV	CL,4
 1474  D2 E3	 	 	 	SHL	BL,CL
 1476  02 D8	 	 	 	ADD	BL,AL
 1478  8B C3	 	 	 	MOV	AX,BX
 147A  C3	 	 	 	RET
 147B	 	 	 	GETNUM	ENDP
 	 	 	 	
 	 	 	 	 	;GET A GAME FILE BLOCK, BLOCK NUMBER IN AX, CORE LOCATION IN ES:BX
 147B	 	 	 	GETBLK	PROC
 147B  51	 	 	 	PUSH	CX	 	;SAVE
 147C  B9 0001	 	 	 	MOV	CX,1	 	;CALL GTBLKS FOR 1 BLOCK ONLY
 147F  E8 149E R	 	 	CALL	GTBLKS
 1482  59	 	 	 	POP	CX	 	;RESTORE
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	17-6
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	HIGH LEVEL IBMPC DEPENDENT STUFF

 1483  C3	 	 	 	RET
 1484	 	 	 	GETBLK	ENDP
 	 	 	 	
 = 0006	 	 	 	GAMETRK	EQU	6	 	;FIRST GAME TRACK (0-39)
 	 	 	 	
 1484	 	 	 	SRBLKS	PROC
 1484  C6 06 02A6 R 01	 	 	MOV	DSKMOD,1	;SAVE/RESTORE MODE
 1489  EB 22 90	 	 	 	JMP	GTBKI$
 148C	 	 	 	SRBLKS	ENDP
 	 	 	 	
 148C	 	 	 	PTBLKS	PROC
 148C  C6 06 02A8 R 01	 	 	MOV	DSKDIR,1	;SET FLAG FOR WRITE
 1491  C6 06 02A7 R 00	 	 	MOV	DSKDRV,0	;ALWAYS FROM DRIVE 0
 1496  C6 06 02A6 R 00	 	 	MOV	DSKMOD,0	;GAME MODE
 149B  EB 10 90	 	 	 	JMP	GTBKI$
 149E	 	 	 	PTBLKS	ENDP
 	 	 	 	
 	 	 	 	 	;GET A SERIES OF GAME FILE BLOCKS,
 	 	 	 	 	;FIRST BLOCK NUMBER IN AX, CORE LOCATION IN ES:BX # OF BLOCKS IN CX
 149E	 	 	 	GTBLKS	PROC
 149E  C6 06 02A8 R 00	 	 	MOV	DSKDIR,0	;READ MODE
 14A3  C6 06 02A7 R 00	 	 	MOV	DSKDRV,0	;ALWAYS FROM DRIVE 0
 14A8  C6 06 02A6 R 00	 	 	MOV	DSKMOD,0	;GAME MODE
 14AD  52	 	 	GTBKI$:	PUSH	DX	 	;SAVES
 14AE  55	 	 	 	PUSH	BP
 14AF  89 0E 02A9 R	 	GTBX0$:	MOV	GTBCNT,CX	;SAVE NUMBER OF BLOCKS TO READ
 14B3  A3 02AB R	 	 	MOV	GTBSTT,AX	;SAVE FIRST BLOCK
 14B6  89 1E 02AD R	 	 	MOV	GTBCOR,BX	;SAVE STARTING LOCATION
 14BA  BD 0008	 	 	 	MOV	BP,8	 	;8 BLOCKS PER TRACK
 14BD  2B D2	 	 	 	SUB	DX,DX	 	;CLEAR HIGH WORD FOR DIVIDE
 14BF  F7 F5	 	 	 	DIV	BP	 	;DETERMINE TRACK AND SECTOR OFFSETS
 14C1  91	 	 	 	XCHG	AX,CX	 	;SECTOR OFFSET & NUMBER OF BLOCKS
 14C2  80 3E 02A6 R 00	 	 	CMP	DSKMOD,0	;CHECK FOR GAME VS. SAVE/RESTORE
 14C7  75 03	 	 	 	JNE	GTBXN$
 14C9  83 C1 06	 	 	 	ADD	CX,GAMETRK	;ADD IN FIRST GAME TRACK
 14CC  8A E9	 	 	GTBXN$:	MOV	CH,CL	 	;POSITION TRACK NUMBER
 14CE  42	 	 	 	INC	DX	 	;CONVERT TO ONE-BASED SECTOR NUMBER
 14CF  8A CA	 	 	 	MOV	CL,DL	 	;POSITION SECTOR NUMBER
 14D1  8A 26 02A7 R	 	 	MOV	AH,DSKDRV	;ALWAYS DRIVE 0
 14D5  B2 09	 	 	 	MOV	DL,9
 14D7  2A D1	 	 	 	SUB	DL,CL	 	;DL NOW HAS MAXIMUM SECTORS LEFT THIS TRACK
 14D9  3A C2	 	 	 	CMP	AL,DL	 	;SEE IF WE WANT MORE THAN THE MAX
 14DB  7E 04	 	 	 	JLE	GTBX1$
 14DD  8A C2	 	 	 	MOV	AL,DL	 	;MAKE IT THE MAX THEN
 14DF  B6 01	 	 	 	MOV	DH,1	 	;SIGNAL ANOTHER PASS NEEDED
 14E1  E8 19B2 R	 	GTBX1$:	CALL	.RDWRT	 	;PERFORM THE DISK OPERATION
 14E4  72 25	 	 	 	JC	GTB1$	 	;READ/WRITE FAILED IF CARRY SET
 14E6  80 FE 01	 	 	 	CMP	DH,1	 	;TEST FOR ANOTHER PASS
 14E9  75 1C	 	 	 	JNZ	GTBX2$
 14EB  2A F6	 	 	 	SUB	DH,DH	 	;CLEAN UP SO THAT DL IS # SECTORS JUST HACKED
 14ED  A1 02AB R	 	 	MOV	AX,GTBSTT
 14F0  03 C2	 	 	 	ADD	AX,DX	 	;START N SECTORS HIGHER
 14F2  8B 0E 02A9 R	 	 	MOV	CX,GTBCNT
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	17-7
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	HIGH LEVEL IBMPC DEPENDENT STUFF

 14F6  2B CA	 	 	 	SUB	CX,DX	 	;AND N LESS SECTORS LEFT TO HACK
 14F8  8B 1E 02AD R	 	 	MOV	BX,GTBCOR
 14FC  51	 	 	 	PUSH	CX
 14FD  B9 0009	 	 	 	MOV	CX,9	 	;SHIFT #SECTORS BY 9 FOR NEW CORE ADDRESS
 1500  D3 E2	 	 	 	SHL	DX,CL
 1502  59	 	 	 	POP	CX
 1503  03 DA	 	 	 	ADD	BX,DX	 	;HERE'S WHERE TO READ INTO NEXT PASS
 1505  EB A8	 	 	 	JMP	GTBX0$
 1507  F8	 	 	GTBX2$:	CLC	 	 	;INDICATE DISK OPERATION WON
 1508  5D	 	 	GTBX3$:	POP	BP	 	;RESTORES
 1509  5A	 	 	 	POP	DX
 150A  C3	 	 	 	RET
 150B  80 3E 02A6 R 00	 	GTB1$:	CMP	DSKMOD,0	;CHECK WHETHER THIS IS GAME MODE
 1510  74 03	 	 	 	JZ	GTB2$	 	;YES, FATAL OUT
 1512  F9	 	 	 	STC	 	 	;SET CARRY FLAG TO INDICATE LOSSAGE
 1513  EB F3	 	 	 	JMP	GTBX3$	 	;RETURN NORMALLY
 1515	 	 	 	GTB2$:	FATAL	FTL7
 1515  E8 18F0 R              +	 	CALL	.CRLF
 1518  B8 09DF R              +	 	MOV	AX,OFFSET FATHDR
 151B  E8 196F R              +	 	CALL	.PRINT
 151E  B8 09CA R              +	 	MOV	AX,OFFSET FTL7
 1521  E8 196F R              +	 	CALL	.PRINT
 1524  E9 1A47 R              +	 	JMP	FINISH
 1527	 	 	 	GTBLKS	ENDP
 	 	 	 	
 	 	 	 	 	SUBTTL	FRIGGING BACKUP COPY ROUTINE
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	18-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	FRIGGING BACKUP COPY ROUTINE

 	 	 	 	 	PAGE	+
 	 	 	 	
 1527	 	 	 	WPCHK	PROC
 1527  C6 06 02A8 R 01	 	 	MOV	DSKDIR,1	; WRITE
 152C  C6 06 02A7 R 00	 	 	MOV	DSKDRV,0	; DRIVE 0
 1531  C6 06 02A6 R 01	 	 	MOV	DSKMOD,1	; ABSOLUTE SECTORS
 1536  B8 002F	 	 	 	MOV	AX,2FH	 	; RANDOM SPOT
 1539  BB 0000	 	 	 	MOV	BX,0
 153C  B9 0001	 	 	 	MOV	CX,1	 	; ONE BLOCK
 153F  E8 14AD R	 	 	CALL	GTBKI$
 1542  80 FC 03	 	 	 	CMP	AH,3	 	; HOPE IT FAILS WITH W/P FAILURE
 1545  74 18	 	 	 	JE	WPCHK1	 	; GOOD. WIN
 	 	 	 	 	PRINT	BKWPS1	 	; TELL USER TO W/P DISK
 1547  50                     +	 	PUSH	AX
 1548  B8 083B R              +	 	MOV	AX,OFFSET BKWPS1
 154B  E8 196F R              +	 	CALL	.PRINT
 154E  58                     +	 	POP	AX
 	 	 	 	 	PRINT	BKWPS2
 154F  50                     +	 	PUSH	AX
 1550  B8 085C R              +	 	MOV	AX,OFFSET BKWPS2
 1553  E8 196F R              +	 	CALL	.PRINT
 1556  58                     +	 	POP	AX
 1557  E8 1864 R	 	 	CALL	.CHRIN	 	; WAIT FOR CHARACTER
 155A  E8 18F0 R	 	 	CALL	.CRLF
 155D  EB C8	 	 	 	JMP	WPCHK	 	; AND TRY AGAIN
 155F  C7 06 095A R 0000	WPCHK1:	MOV	MORLIN,0
 1565  C3	 	 	 	RET
 1566	 	 	 	WPCHK	ENDP
 	 	 	 	
 	 	 	 	 	;CHECK WHETHER BACKUP IS POSSIBLE
 1566	 	 	 	BKCHK	PROC
 1566  E8 0F1A R	 	 	CALL	TSETUP
 1569  E8 1791 R	 	 	CALL	BKSTAT	 	;GET STATUS BITS INTO AL
 156C  3C 03	 	 	 	CMP	AL,3	 	;THIS IS MASTER/BACKUP ALLOWED
 156E  74 01	 	 	 	JE	BKUP	
 1570  C3	 	 	 	RET
 	 	 	 	
 1571	 	 	 	BKUP:	PRINT	BKASK1	 	;ASK WHETHER BACKUP WANTED
 1571  50                     +	 	PUSH	AX
 1572  B8 068E R              +	 	MOV	AX,OFFSET BKASK1
 1575  E8 196F R              +	 	CALL	.PRINT
 1578  58                     +	 	POP	AX
 	 	 	 	 	PRINT	BKASK2
 1579  50                     +	 	PUSH	AX
 157A  B8 06B3 R              +	 	MOV	AX,OFFSET BKASK2
 157D  E8 196F R              +	 	CALL	.PRINT
 1580  58                     +	 	POP	AX
 	 	 	 	 	PRINT	BKASK3
 1581  50                     +	 	PUSH	AX
 1582  B8 06D7 R              +	 	MOV	AX,OFFSET BKASK3
 1585  E8 196F R              +	 	CALL	.PRINT
 1588  58                     +	 	POP	AX
 	 	 	 	 	PRINT	BKASK4
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	18-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	FRIGGING BACKUP COPY ROUTINE

 1589  50                     +	 	PUSH	AX
 158A  B8 06F8 R              +	 	MOV	AX,OFFSET BKASK4
 158D  E8 196F R              +	 	CALL	.PRINT
 1590  58                     +	 	POP	AX
 	 	 	 	 	PRINT	BKASK5
 1591  50                     +	 	PUSH	AX
 1592  B8 071E R              +	 	MOV	AX,OFFSET BKASK5
 1595  E8 196F R              +	 	CALL	.PRINT
 1598  58                     +	 	POP	AX
 1599  E8 1864 R	 	 	CALL	.CHRIN	 	;GET A CHARACTER
 159C  3C 21	 	 	 	CMP	AL,"!"
 159E  74 1A	 	 	 	JE	BKUPF
 15A0  3C 59	 	 	 	CMP	AL,"Y"
 15A2  74 1B	 	 	 	JE	BKUP1
 15A4  3C 79	 	 	 	CMP	AL,"y"
 15A6  74 17	 	 	 	JE	BKUP1
 	 	 	 	 	PRINT	BKNOPE
 15A8  50                     +	 	PUSH	AX
 15A9  B8 073A R              +	 	MOV	AX,OFFSET BKNOPE
 15AC  E8 196F R              +	 	CALL	.PRINT
 15AF  58                     +	 	POP	AX
 15B0  E8 18F0 R	 	 	CALL	.CRLF
 15B3  C7 06 095A R 0000	 	MOV	MORLIN,0
 15B9  C3	 	 	 	RET	 	 	;DOESN'T WANT TO, APPARENTLY...
 	 	 	 	
 15BA  C6 06 0206 R 01	 	BKUPF:	MOV	NDISKS,1
 15BF	 	 	 	BKUP1:	PRINT	BKYEP
 15BF  50                     +	 	PUSH	AX
 15C0  B8 0734 R              +	 	MOV	AX,OFFSET BKYEP
 15C3  E8 196F R              +	 	CALL	.PRINT
 15C6  58                     +	 	POP	AX
 15C7  E8 18F0 R	 	 	CALL	.CRLF
 15CA  A0 0206 R	 	 	MOV	AL,NDISKS
 15CD  3C 01	 	 	 	CMP	AL,1
 15CF  74 05	 	 	 	JE	BKUP1Z
 15D1  C6 06 068C R 01	 	 	MOV	BKDSK,1	 	;MAKE COPY DISK DRIVE 1 FOR >1 DRIVE SYSTEMS
 15D6  80 3E 0206 R 01	 	BKUP1Z:	CMP	NDISKS,1
 15DB  74 06	 	 	 	JE	BKZZ
 15DD  E8 17F2 R	 	 	CALL	BKIFST	 	;INSERT MASTER DISK
 15E0  EB 01 90	 	 	 	JMP	BKZZ
 15E3  B8 0000	 	 	BKZZ:	MOV	AX,0	 	;SECTOR 0
 15E6  BB 0000	 	 	 	MOV	BX,0	 	;LOCATION 0
 15E9  B9 0001	 	 	 	MOV	CX,1	 	;ONE SECTOR (BOOTSTRAP)
 15EC  C6 06 02A8 R 00	 	 	MOV	DSKDIR,0	;READ
 15F1  C6 06 02A7 R 00	 	 	MOV	DSKDRV,0
 15F6  E8 14AD R	 	 	CALL	GTBKI$
 15F9  73 03	 	 	 	JNC	BKUP1A
 15FB  E9 1747 R	 	 	JMP	BKABRT
 15FE  E8 183F R	 	BKUP1A:	CALL	BKICOP	 	;INSERT COPY DISK
 1601  B8 0000	 	 	 	MOV	AX,0
 1604  BB 0000	 	 	 	MOV	BX,0
 1607  B9 0001	 	 	 	MOV	CX,1
 160A  C6 06 02A8 R 01	 	 	MOV	DSKDIR,1
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	18-3
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	FRIGGING BACKUP COPY ROUTINE

 	 	 	 	 	MOVM	DSKDRV,BKDSK,DL
 160F  8A 16 068C R           +	 	MOV	DL,BKDSK
 1613  88 16 02A7 R           +	 	MOV	DSKDRV,DL
 1617  E8 14AD R	 	 	CALL	GTBKI$	 	;WRITE BOOTSTRAP ONTO COPY
 161A  73 03	 	 	 	JNC	BKUP1B
 161C  E9 1747 R	 	 	JMP	BKABRT
 161F  E8 1817 R	 	BKUP1B:	CALL	BKIMST	 	;ASK TO INSERT MASTER
 	 	 	 	
 	 	 	 	;CODE HERE FOR FORMATTING/COPYING INTERPRETER IS TAKEN
 	 	 	 	;FROM CREATE.ASM  -- IT'S ALL MAGIC
 	 	 	 	
 1622  E8 1759 R	 	 	CALL	DSKHAK
 	 	 	 	
 1625  BA 0003	 	 	 	MOV	DX,3
 1628  2B DB	 	 	 	SUB	BX,BX
 162A  B5 01	 	 	 	MOV	CH,1
 162C  52	 	 	BKRIL:	PUSH	DX
 162D  B1 01	 	 	 	MOV	CL,1
 162F  51	 	 	 	PUSH	CX
 1630  2B D2	 	 	 	SUB	DX,DX
 1632  B8 0204	 	 	 	MOV	AX,0204H
 1635  CD 13	 	 	 	INT	13H
 1637  72 0E	 	 	 	JC	BKRIF
 1639  59	 	 	 	POP	CX
 163A  FE C5	 	 	 	INC	CH
 163C  81 C3 1000	 	 	ADD	BX,1000H
 1640  5A	 	 	 	POP	DX
 1641  4A	 	 	 	DEC	DX
 1642  75 E8	 	 	 	JNZ	BKRIL
 1644  EB 06 90	 	 	 	JMP	BKWINT
 	 	 	 	
 1647  5A	 	 	BKRIF:	POP	DX
 1648  5A	 	 	 	POP	DX
 1649  E9 1747 R	 	 	JMP	BKABRT
 	 	 	 	
 164C  E8 177A R	 	BKWINT:	CALL	DSKFIX
 	 	 	 	
 164F  E8 183F R	 	 	CALL	BKICOP	 	;LOAD COPY DISK
 	 	 	 	
 1652  E8 1759 R	 	 	CALL	DSKHAK
 	 	 	 	
 	 	 	 	; NOW WRITE IT OUT
 	 	 	 	
 1655  B9 0101	 	 	 	MOV	CX,0101H
 1658  BB 0880 R	 	FRML:	MOV	BX,OFFSET IDTBL
 165B  C6 06 068A R 04	 	 	MOV	SECCNT,4
 1660  88 2F	 	 	FRMLL:	MOV	[BX],CH
 1662  83 C3 04	 	 	 	ADD	BX,4
 1665  FE 0E 068A R	 	 	DEC	SECCNT
 1669  75 F5	 	 	 	JNZ	FRMLL
 	 	 	 	
 166B  BB 0880 R	 	 	MOV	BX,OFFSET IDTBL
 166E  B6 00	 	 	 	MOV	DH,0
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	18-4
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	FRIGGING BACKUP COPY ROUTINE

 1670  8A 16 068C R	 	 	MOV	DL,BKDSK
 1674  06	 	 	 	PUSH	ES
 1675  8C D8	 	 	 	MOV	AX,DS
 1677  8E C0	 	 	 	MOV	ES,AX
 1679  B8 0504	 	 	 	MOV	AX,0504H
 167C  CD 13	 	 	 	INT	13H	 	;ES MUST BE = TO DS FOR FORMAT
 167E  07	 	 	 	POP	ES	 	
 167F  80 C5 01	 	 	 	ADD	CH,1	 	;PUT CHECK FOR FAILURE HERE
 1682  FE 0E 068B R	 	 	DEC	TRKCNT
 1686  75 D0	 	 	 	JNZ	FRML
 	 	 	 	
 1688  C6 06 068B R 03	 	 	MOV	TRKCNT,3
 168D  BB 0000	 	 	 	MOV	BX,0
 1690  B9 0101	 	 	 	MOV	CX,0101H
 1693  B6 00	 	 	 	MOV	DH,0
 1695  8A 16 068C R	 	 	MOV	DL,BKDSK
 1699  B8 0304	 	 	WLP:	MOV	AX,0304H
 169C  CD 13	 	 	 	INT	13H
 169E  81 C3 1000	 	 	ADD	BX,1000H
 16A2  FE C5	 	 	 	INC	CH
 16A4  FE 0E 068B R	 	 	DEC	TRKCNT
 16A8  75 EF	 	 	 	JNZ	WLP
 	 	 	 	
 16AA  E8 177A R	 	 	CALL	DSKFIX
 	 	 	 	
 16AD  C6 06 068B R 04	 	 	MOV	TRKCNT,4	;READ MAX. 96 K (THIS WILL CHANGE)
 16B2  C6 06 068A R 30	 	 	MOV	SECCNT,30H	;START OF GAME
 16B7  E8 1817 R	 	BKUPGL:	CALL	BKIMST	 	;GET MASTER BACK INTO DRIVE
 16BA  C6 06 02A8 R 00	 	 	MOV	DSKDIR,0	;READ
 16BF  C6 06 02A7 R 00	 	 	MOV	DSKDRV,0
 16C4  A0 068A R	 	 	MOV	AL,SECCNT
 16C7  2A E4	 	 	 	SUB	AH,AH	 	;FIRST SECTOR HERE
 16C9  BB 0000	 	 	 	MOV	BX,0
 16CC  B9 0040	 	 	 	MOV	CX,40H	 	;GET 32K (64 SECTORS)
 16CF  E8 14AD R	 	 	CALL	GTBKI$	 	;READ SOME GAME STUFF
 16D2  73 03	 	 	 	JNC	BKUPG1
 16D4  EB 71 90	 	 	 	JMP	BKABRT
 16D7  80 3E 068B R 01	 	BKUPG1:	CMP	TRKCNT,1
 16DC  75 26	 	 	 	JNE	BKUP2	 	;CONTINUE
 16DE  C6 06 02A8 R 01	 	 	MOV	DSKDIR,1	;WRITE
 16E3  C6 06 02A7 R 00	 	 	MOV	DSKDRV,0
 16E8  BB 02F5 R	 	 	MOV	BX,OFFSET BKBUF
 16EB  B9 0001	 	 	 	MOV	CX,1
 16EE  C6 06 02F5 R 01	 	 	MOV	BKBUF,1	 	;PVERS1=0
 16F3  06	 	 	 	PUSH	ES
 16F4  8C D8	 	 	 	MOV	AX,DS
 16F6  8E C0	 	 	 	MOV	ES,AX
 16F8  B8 002E	 	 	 	MOV	AX,2EH
 16FB  E8 14AD R	 	 	CALL	GTBKI$	 	;FIX SO IT CAN'T BE COPIED
 16FE  07	 	 	 	POP	ES
 16FF  73 03	 	 	 	JNC	BKUP2
 1701  EB 44 90	 	 	 	JMP	BKABRT
 1704  E8 183F R	 	BKUP2:	CALL	BKICOP	 	;GET COPY NOW
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	18-5
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	FRIGGING BACKUP COPY ROUTINE

 1707  C6 06 02A8 R 01	 	 	MOV	DSKDIR,1	;WRITE
 	 	 	 	 	MOVM	DSKDRV,BKDSK,DL
 170C  8A 16 068C R           +	 	MOV	DL,BKDSK
 1710  88 16 02A7 R           +	 	MOV	DSKDRV,DL
 1714  A0 068A R	 	 	MOV	AL,SECCNT
 1717  2A E4	 	 	 	SUB	AH,AH
 1719  BB 0000	 	 	 	MOV	BX,0
 171C  B9 0040	 	 	 	MOV	CX,40H
 171F  E8 14AD R	 	 	CALL	GTBKI$	 	;WRITE SOME GAME STUFF
 1722  73 03	 	 	 	JNC	BKUP2A
 1724  EB 21 90	 	 	 	JMP	BKABRT
 1727  80 2E 068B R 01	 	BKUP2A:	SUB	TRKCNT,1
 172C  74 07	 	 	 	JZ	BKUP3	 	;DONE WITH BACKUP
 172E  80 06 068A R 40	 	 	ADD	SECCNT,40H
 1733  EB 82	 	 	 	JMP	BKUPGL
 	 	 	 	
 1735	 	 	 	BKUP3:	PRINT	BKDONE
 1735  50                     +	 	PUSH	AX
 1736  B8 080D R              +	 	MOV	AX,OFFSET BKDONE
 1739  E8 196F R              +	 	CALL	.PRINT
 173C  58                     +	 	POP	AX
 173D  E8 1817 R	 	 	CALL	BKIMST	 	;ENSURE MASTER IN PLACE
 1740  C7 06 095A R 0000	 	MOV	MORLIN,0
 1746  C3	 	 	 	RET
 	 	 	 	
 1747	 	 	 	BKABRT:	PRINT	BKFAIL
 1747  50                     +	 	PUSH	AX
 1748  B8 081F R              +	 	MOV	AX,OFFSET BKFAIL
 174B  E8 196F R              +	 	CALL	.PRINT
 174E  58                     +	 	POP	AX
 174F  E8 1817 R	 	 	CALL	BKIMST	 	;ENSURE MASTER IN PLACE
 1752  C7 06 095A R 0000	 	MOV	MORLIN,0
 1758  C3	 	 	 	RET
 	 	 	 	
 1759	 	 	 	BKCHK	ENDP
 	 	 	 	 	
 1759	 	 	 	DSKHAK	PROC
 1759  8C DF	 	 	 	MOV	DI,DS
 175B  BE 0875 R	 	 	MOV	SI,OFFSET DSK_PRM
 175E  1E	 	 	 	PUSH	DS
 175F  2B C0	 	 	 	SUB	AX,AX
 1761  8E D8	 	 	 	MOV	DS,AX
 	 	 	 	ASSUME	DS:ABS_SG
 1763  BB 0078	 	 	 	MOV	BX,78H
 1766  8B 0F	 	 	 	MOV	CX,[BX]
 1768  8B 57 02	 	 	 	MOV	DX,[BX+2]
 176B  89 37	 	 	 	MOV	[BX],SI
 176D  89 7F 02	 	 	 	MOV	[BX+2],DI
 1770  1F	 	 	 	POP	DS
 	 	 	 	ASSUME	DS:DATA_SG
 1771  89 0E 0871 R	 	 	MOV	DSK_SV1,CX
 1775  89 16 0873 R	 	 	MOV	DSK_SV2,DX
 1779  C3	 	 	 	RET
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	18-6
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	FRIGGING BACKUP COPY ROUTINE

 177A	 	 	 	DSKHAK	ENDP
 	 	 	 	
 177A	 	 	 	DSKFIX	PROC
 177A  1E	 	 	 	PUSH	DS
 177B  8B 0E 0871 R	 	 	MOV	CX,DSK_SV1
 177F  8B 16 0873 R	 	 	MOV	DX,DSK_SV2
 1783  2B C0	 	 	 	SUB	AX,AX
 1785  8E D8	 	 	 	MOV	DS,AX
 	 	 	 	ASSUME	DS:ABS_SG
 1787  BB 0078	 	 	 	MOV	BX,78H
 178A  89 0F	 	 	 	MOV	[BX],CX
 178C  89 57 02	 	 	 	MOV	[BX+2],DX
 178F  1F	 	 	 	POP	DS
 	 	 	 	ASSUME	DS:DATA_SG
 1790  C3	 	 	 	RET
 1791	 	 	 	DSKFIX	ENDP
 	 	 	 	
 	 	 	 	 	;READ THE STATUS BLOCK FROM DISK
 1791	 	 	 	BKSTAT	PROC
 1791  06	 	 	 	PUSH	ES
 1792  8C D8	 	 	 	MOV	AX,DS
 1794  8E C0	 	 	 	MOV	ES,AX
 1796  C6 06 02A8 R 00	 	BKSTRT:	MOV	DSKDIR,0	;READ
 179B  C6 06 02A6 R 01	 	 	MOV	DSKMOD,1	;ABSOLUTE SECTORS
 17A0  B8 002E	 	 	 	MOV	AX,2EH	 	;STATUS SECTOR
 17A3  BB 02F5 R	 	 	MOV	BX,OFFSET BKBUF	;READ AT BKBUF (IN DS)
 17A6  B9 0001	 	 	 	MOV	CX,1	 	;ONE SECTOR
 17A9  E8 14AD R	 	 	CALL	GTBKI$	 	;READ IT
 17AC  72 34	 	 	 	JC	BKST1	 	;FAILED?
 17AE  80 3E 068D R 01	 	 	CMP	BKFRST,1
 17B3  74 13	 	 	 	JE	BKSEND
 17B5  C6 06 02A8 R 01	 	 	MOV	DSKDIR,1	;WRITE
 17BA  B8 002F	 	 	 	MOV	AX,2FH	 	;RANDOM SPOT
 17BD  BB 0000	 	 	 	MOV	BX,0
 17C0  B9 0001	 	 	 	MOV	CX,1
 17C3  E8 14AD R	 	 	CALL	GTBKI$	 	;WRITE SOMETHING OR OTHER
 17C6  72 0A	 	 	 	JC	BKST0	 	;LOSER!
 17C8  C6 06 068D R 00	 	BKSEND:	MOV	BKFRST,0
 17CD  07	 	 	 	POP	ES
 17CE  A0 02F5 R	 	 	MOV	AL,BKBUF	;GET FIRST BYTE
 17D1  C3	 	 	 	RET
 17D2  80 FC 03	 	 	BKST0:	CMP	AH,3	 	;CHECK SPECIFICALLY FOR WRITE-PROTECT
 17D5  75 0B	 	 	 	JNE	BKST1
 	 	 	 	 	PRINT	BKWPRT	 	;TELL LOSER ABOUT WRITE PROTECTEDNESS
 17D7  50                     +	 	PUSH	AX
 17D8  B8 07D3 R              +	 	MOV	AX,OFFSET BKWPRT
 17DB  E8 196F R              +	 	CALL	.PRINT
 17DE  58                     +	 	POP	AX
 17DF  EB 09 90	 	 	 	JMP	BKST2
 	 	 	 	
 17E2	 	 	 	BKST1:	PRINT	BKNRDY	 	;TELL LOSER DISK ISN`T WINNING
 17E2  50                     +	 	PUSH	AX
 17E3  B8 07F5 R              +	 	MOV	AX,OFFSET BKNRDY
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	18-7
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	FRIGGING BACKUP COPY ROUTINE

 17E6  E8 196F R              +	 	CALL	.PRINT
 17E9  58                     +	 	POP	AX
 17EA  E8 1864 R	 	BKST2:	CALL	.CHRIN	 	;GET SOME RANDOM CHARACTER
 17ED  E8 18F0 R	 	 	CALL	.CRLF
 17F0  EB A4	 	 	 	JMP	BKSTRT	 	;TRY, TRY AGAIN
 	 	 	 	
 17F2	 	 	 	BKSTAT	ENDP
 	 	 	 	
 	 	 	 	 	;ASK LOSER TO INSERT MASTER DISK, CHECK FOR MASTERHOOD
 17F2	 	 	 	BKIFST	PROC
 	 	 	 	 	PRINT	BKMC1
 17F2  50                     +	 	PUSH	AX
 17F3  B8 073F R              +	 	MOV	AX,OFFSET BKMC1
 17F6  E8 196F R              +	 	CALL	.PRINT
 17F9  58                     +	 	POP	AX
 	 	 	 	 	PRINT	BKMC2
 17FA  50                     +	 	PUSH	AX
 17FB  B8 075D R              +	 	MOV	AX,OFFSET BKMC2
 17FE  E8 196F R              +	 	CALL	.PRINT
 1801  58                     +	 	POP	AX
 	 	 	 	 	PRINT	BKMC3
 1802  50                     +	 	PUSH	AX
 1803  B8 0779 R              +	 	MOV	AX,OFFSET BKMC3
 1806  E8 196F R              +	 	CALL	.PRINT
 1809  58                     +	 	POP	AX
 180A  E8 1864 R	 	 	CALL	.CHRIN
 180D  E8 18F0 R	 	 	CALL	.CRLF
 1810  E8 1817 R	 	 	CALL	BKIMST
 1813  E8 183F R	 	 	CALL	BKICOP
 1816  C3	 	 	 	RET
 1817	 	 	 	BKIFST	ENDP
 	 	 	 	
 1817	 	 	 	BKIMST	PROC
 1817  80 3E 068C R 00	 	 	CMP	BKDSK,0
 181C  75 0E	 	 	 	JNE	BKIMS1
 181E	 	 	 	BKIMSR:	PRINT	BKMAST	 	;PRINT MESSAGE
 181E  50                     +	 	PUSH	AX
 181F  B8 0795 R              +	 	MOV	AX,OFFSET BKMAST
 1822  E8 196F R              +	 	CALL	.PRINT
 1825  58                     +	 	POP	AX
 1826  E8 1864 R	 	 	CALL	.CHRIN	 	;GET SOME CHARACTER
 1829  E8 18F0 R	 	 	CALL	.CRLF
 182C  C6 06 02A7 R 00	 	BKIMS1:	MOV	DSKDRV,0
 1831  E8 1791 R	 	 	CALL	BKSTAT	 	;GET STATUS FROM DISK, ENSURE NOT W/P
 1834  3C 03	 	 	 	CMP	AL,3
 1836  74 06	 	 	 	JE	BKIMSX	 	;IT'S NOT A MASTER DISK....
 1838  3C 01	 	 	 	CMP	AL,1
 183A  74 02	 	 	 	JE	BKIMSX
 183C  EB E0	 	 	 	JMP	BKIMSR
 183E  C3	 	 	BKIMSX:	RET
 183F	 	 	 	BKIMST	ENDP
 	 	 	 	
 	 	 	 	 	;ASK LOSER TO INSERT COPY DISK, CHECK FOR COPYHOOD
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	18-8
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	FRIGGING BACKUP COPY ROUTINE

 183F	 	 	 	BKICOP	PROC
 183F  80 3E 068C R 00	 	 	CMP	BKDSK,0
 1844  75 0E	 	 	 	JNE	BKICP1
 1846	 	 	 	BKICPR:	PRINT	BKCOPY	 	;PRINT MESSAGE
 1846  50                     +	 	PUSH	AX
 1847  B8 07B5 R              +	 	MOV	AX,OFFSET BKCOPY
 184A  E8 196F R              +	 	CALL	.PRINT
 184D  58                     +	 	POP	AX
 184E  E8 1864 R	 	 	CALL	.CHRIN
 1851  E8 18F0 R	 	 	CALL	.CRLF
 1854	 	 	 	BKICP1:	MOVM	DSKDRV,BKDSK,DL
 1854  8A 16 068C R           +	 	MOV	DL,BKDSK
 1858  88 16 02A7 R           +	 	MOV	DSKDRV,DL
 185C  E8 1791 R	 	 	CALL	BKSTAT
 185F  A8 01	 	 	 	TEST	AL,1
 1861  75 E3	 	 	 	JNZ	BKICPR	 	;IT'S NOT A COPY DISK....
 1863  C3	 	 	 	RET
 1864	 	 	 	BKICOP	ENDP	
 	 	 	 	
 	 	 	 	 	SUBTTL  IBMPC SYSTEM ROUTINES
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	19-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	IBMPC SYSTEM ROUTINES

 	 	 	 	 	PAGE	+
 	 	 	 	
 	 	 	 	 	;READ A CHARACTER INTO AX, WAITING UNTIL ONE IS AVAILABLE, NO ECHO
 1864	 	 	 	.CHRIN	PROC
 1864  80 3E 066B R 00	 	 	CMP	CHRFLG,0
 1869  75 15	 	 	 	JNZ	.CHR1$
 186B  C6 06 066B R 01	 	 	MOV	CHRFLG,1
 1870  51	 	 	 	PUSH	CX
 1871  52	 	 	 	PUSH	DX
 1872  2A E4	 	 	 	SUB	AH,AH
 1874  CD 1A	 	 	 	INT	1AH	 	;READ THE SYSTEM TIME AT FIRST CHARACTER
 1876  31 0E 02AF R	 	 	XOR	RSEED1,CX	;DO SOME MORE RANDOMIZING
 187A  31 16 02B1 R	 	 	XOR	RSEED2,DX	;BE CONSISTENT
 187E  5A	 	 	 	POP	DX
 187F  59	 	 	 	POP	CX
 1880  2A E4	 	 	.CHR1$:	SUB	AH,AH	 	;SET UP FOR READ NEXT CHARACTER STRUCK
 1882  CD 16	 	 	 	INT	16H	 	;CALL BIOS KEYBOARD I/O ROUTINE
 1884  2A E4	 	 	 	SUB	AH,AH	 	;CLEAR HIGH BYTE
 1886  C3	 	 	 	RET
 1887	 	 	 	.CHRIN	ENDP
 	 	 	 	
 	 	 	 	 	;PRINT THE CHARACTER IN AL, FOREGROUND IN AH
 1887	 	 	 	.TTYOUT	PROC
 1887  50	 	 	 	PUSH	AX
 1888  53	 	 	 	PUSH	BX	 	;SAVES
 1889  52	 	 	 	PUSH	DX
 188A  55	 	 	 	PUSH	BP
 188B  50	 	 	 	PUSH	AX
 188C  8A DC	 	 	 	MOV	BL,AH	 	;FOREGROUND
 188E  B4 0E	 	 	 	MOV	AH,14	 	;SET UP FOR TELETYPE OUTPUT
 1890  2A FF	 	 	 	SUB	BH,BH	 	;PAGE 0
 1892  CD 10	 	 	 	INT	10H	 	;CALL BIOS DISPLAY I/O ROUTINE
 1894  58	 	 	 	POP	AX
 1895  80 3E 0023 R 00	 	 	CMP	SCRFLG,0
 189A  74 03	 	 	 	JZ	.TYO1$
 189C  E8 0773 R	 	 	CALL	PRTOUT
 189F  5D	 	 	.TYO1$:	POP	BP	 	;RESTORES
 18A0  5A	 	 	 	POP	DX
 18A1  5B	 	 	 	POP	BX
 18A2  58	 	 	 	POP	AX
 18A3  C3	 	 	 	RET
 18A4	 	 	 	.TTYOUT	ENDP
 	 	 	 	
 	 	 	 	 	;PRINT THE CHARACTER IN AL, ATTRIBUTES IN AH, ROW IN BH, COLUMN IN BL
 18A4	 	 	 	.CHROUT	PROC
 18A4  51	 	 	 	PUSH	CX	 	;SAVES
 18A5  52	 	 	 	PUSH	DX
 18A6  55	 	 	 	PUSH	BP
 18A7  50	 	 	 	PUSH	AX	 	;SAVE CHARACTER AND ATTRIBUTES
 18A8  B4 02	 	 	 	MOV	AH,2	 	;SET UP FOR SET CURSOR POSITION
 18AA  8B D3	 	 	 	MOV	DX,BX	 	;ROW AND COLUMN
 18AC  2A FF	 	 	 	SUB	BH,BH	 	;PAGE 0
 18AE  CD 10	 	 	 	INT	10H	 	;CALL BIOS DISPLAY I/O ROUTINE
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	19-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	IBMPC SYSTEM ROUTINES

 18B0  58	 	 	 	POP	AX	 	;RESTORE CHARACTER AND ATTRIBUTES
 18B1  B4 09	 	 	 	MOV	AH,9	 	;SET UP FOR WRITE ATTRIBUTE/CHARACTER
 18B3  2A FF	 	 	 	SUB	BH,BH	 	;PAGE 0
 18B5  8A 1E 0000 R	 	 	MOV	BL,NRMATR	;NORMAL ATTRIBUTES
 18B9  B9 0001	 	 	 	MOV	CX,1	 	;WRITE 1 CHARACTER
 18BC  CD 10	 	 	 	INT	10H	 	;CALL BIOS DISPLAY I/O ROUTINE
 18BE  5D	 	 	 	POP	BP	 	;RESTORES
 18BF  5A	 	 	 	POP	DX
 18C0  59	 	 	 	POP	CX
 18C1  C3	 	 	 	RET
 18C2	 	 	 	.CHROUT	ENDP
 	 	 	 	
 	 	 	 	 	;PRINT SPACES, WITHOUT MOVING CURSOR, NUMBER IN AL, ATTRIBUTE IN AH
 18C2	 	 	 	.SPACE	PROC
 18C2  53	 	 	 	PUSH	BX	 	;SAVES
 18C3  51	 	 	 	PUSH	CX
 18C4  55	 	 	 	PUSH	BP
 18C5  8A DC	 	 	 	MOV	BL,AH	 	;ATTRIBUTE
 18C7  2A E4	 	 	 	SUB	AH,AH	 	;CLEAR HIGH BYTE
 18C9  8B C8	 	 	 	MOV	CX,AX	 	;NUMBER OF SPACES
 18CB  B4 09	 	 	 	MOV	AH,9	 	;SET UP FOR WRITE ATTRIBUTE/CHARACTER
 18CD  B0 20	 	 	 	MOV	AL,32	 	;WRITE SPACES
 18CF  2A FF	 	 	 	SUB	BH,BH	 	;PAGE 0
 18D1  8A 1E 0000 R	 	 	MOV	BL,NRMATR	;****** THIS SHOULD HELP
 18D5  CD 10	 	 	 	INT	10H	 	;CALL BIOS DISPLAY I/O ROUTINE
 18D7  5D	 	 	 	POP	BP	 	;RESTORES
 18D8  59	 	 	 	POP	CX
 18D9  5B	 	 	 	POP	BX
 18DA  C3	 	 	 	RET
 18DB	 	 	 	.SPACE	ENDP
 	 	 	 	
 	 	 	 	 	;MOVE TO FIRST COLUMN OF SCREEN BOTTOM
 18DB	 	 	 	.CRBT	PROC
 18DB  50	 	 	 	PUSH	AX	 	;SAVES
 18DC  53	 	 	 	PUSH	BX
 18DD  52	 	 	 	PUSH	DX
 18DE  55	 	 	 	PUSH	BP
 18DF  B4 02	 	 	 	MOV	AH,2	 	;SET UP FOR SET CURSOR POSITION
 18E1  2A FF	 	 	 	SUB	BH,BH	 	;PAGE 0
 18E3  8A 16 02DA R	 	 	MOV	DL,LFTMAR	;MOVE TO FIRST COLUMN
 18E7  B6 18	 	 	 	MOV	DH,24	 	;MOVE TO BOTTOM ROW
 18E9  CD 10	 	 	 	INT	10H	 	;CALL BIOS DISPLAY I/O ROUTINE
 18EB  5D	 	 	 	POP	BP	 	;RESTORES
 18EC  5A	 	 	 	POP	DX
 18ED  5B	 	 	 	POP	BX
 18EE  58	 	 	 	POP	AX
 18EF  C3	 	 	 	RET
 18F0	 	 	 	.CRBT	ENDP
 	 	 	 	
 	 	 	 	 	;PRINT A CARRIAGE RETURN/LINE FEED, WITH MORE MODE (ASSUMING SCREEN
 	 	 	 	 	;BOTTOM)
 18F0	 	 	 	.CRLF	PROC
 18F0  50	 	 	 	PUSH	AX	 	;SAVES
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	19-3
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	IBMPC SYSTEM ROUTINES

 18F1  53	 	 	 	PUSH	BX
 18F2  51	 	 	 	PUSH	CX
 18F3  52	 	 	 	PUSH	DX
 18F4  55	 	 	 	PUSH	BP
 18F5  80 3E 02D9 R 00	 	 	CMP	CURSCR,0
 18FA  74 18	 	 	 	JE	.CRLFN
 	 	 	 	
 	 	 	 	 	CURGET	 	 	;HERE FOR SCREEN 1, PUT CURSOR ON NEXT LINE
 18FC  50                     +	 	PUSH	AX
 18FD  2A FF                  +	 	SUB	BH,BH
 18FF  B4 03                  +	 	MOV	AH,3
 1901  CD 10                  +	 	INT	10H
 1903  58                     +	 	POP	AX
 1904  80 C6 01	 	 	 	ADD	DH,1
 1907  B2 02	 	 	 	MOV	DL,2	 	; ADJUST FOR SONAR IN SEA STALKER
 	 	 	 	
 1909	 	 	 	.CRLF1:	CURSET
 1909  50                     +	 	PUSH	AX
 190A  2A FF                  +	 	SUB	BH,BH
 190C  B4 02                  +	 	MOV	AH,2
 190E  CD 10                  +	 	INT	10H
 1910  58                     +	 	POP	AX
 1911  EB 4C 90	 	 	 	JMP	.CR1$
 	 	 	 	
 1914  FF 06 095A R	 	.CRLFN:	INC	MORLIN	 	;INCREMENT NUMBER OF LINES OUTPUT
 1918  B4 06	 	 	 	MOV	AH,6	 	;SET UP FOR SCROLL PAGE UP
 191A  B0 01	 	 	 	MOV	AL,1	 	;ONE LINE UP
 191C  8A 3E 0000 R	 	 	MOV	BH,NRMATR	;NORMAL DISPLAY ATTRIBUTE
 1920  B1 00	 	 	 	MOV	CL,0
 1922  8A 2E 02D8 R	 	 	MOV	CH,SCRN0
 1926  8B 16 02D4 R	 	 	MOV	DX,TWIDTH
 192A  B6 18	 	 	 	MOV	DH,18H	 	;END AT LINE 24, COLUMN TWIDTH+1
 192C  CD 10	 	 	 	INT	10H	 	;CALL BIOS DISPLAY I/O ROUTINE
 192E  E8 18DB R	 	 	CALL	.CRBT	 	;MOVE TO BEGINNING OF NEW LINE
 1931  A1 095A R	 	 	MOV	AX,MORLIN
 1934  3B 06 095C R	 	 	CMP	AX,LINMAX	;FULL PAGE OUTPUT?
 1938  7C 25	 	 	 	JL	.CR1$	 	;NOT YET
 193A  C7 06 095A R 0000	 	MOV	MORLIN,0	;RESET COUNTER
 1940  B8 0950 R	 	 	MOV	AX,OFFSET MORE	;ADDRESS OF MORE MODE PROMPT STRING
 1943  8A 1E 0001 R	 	 	MOV	BL,USLATR	;INVERSE VIDEO
 1947  B5 18	 	 	 	MOV	CH,18H	 	;STARTING IN ROW 24, COLUMN LFTMAR
 1949  8A 0E 02DA R	 	 	MOV	CL,LFTMAR
 194D  E8 198B R	 	 	CALL	.PRINTA	 	;PRINT IT WITH ATTRIBUTES
 1950  E8 1864 R	 	 	CALL	.CHRIN	 	;READ A CHARACTER TO CONTINUE
 1953  E8 18DB R	 	 	CALL	.CRBT	 	;MOVE TO BEGINNING OF NEW LINE
 1956  B0 09	 	 	 	MOV	AL,9	 	;9 SPACES
 1958  8A 26 0000 R	 	 	MOV	AH,NRMATR	;NORMAL DISPLAY
 195C  E8 18C2 R	 	 	CALL	.SPACE	 	;PRINT THEM (CURSOR UNAFFECTED)
 195F  80 3E 0023 R 00	 	.CR1$:	CMP	SCRFLG,0
 1964  74 03	 	 	 	JE	.CR2$
 1966  E8 0813 R	 	 	CALL	PRTCRL	 	;CRLF TO PRINTER
 1969  5D	 	 	.CR2$:	POP	BP	 	;RESTORES
 196A  5A	 	 	 	POP	DX
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	19-4
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	IBMPC SYSTEM ROUTINES

 196B  59	 	 	 	POP	CX
 196C  5B	 	 	 	POP	BX
 196D  58	 	 	 	POP	AX
 196E  C3	 	 	 	RET
 196F	 	 	 	.CRLF	ENDP
 	 	 	 	
 	 	 	 	 	;PRINT A STRING, POINTER (TO DATA SEGMENT) IN AX, WHITE FOREGROUND
 196F	 	 	 	.PRINT	PROC
 196F  53	 	 	 	PUSH	BX	 	;SAVE BX
 1970  8B D8	 	 	 	MOV	BX,AX	 	;STRING POINTER
 1972  8A 07	 	 	.PR1$:	MOV	AL,[BX]	 	;GET NEXT CHARACTER
 1974  3C 00	 	 	 	CMP	AL,0	 	;END OF LINE, WITH CRLF?
 1976  74 0E	 	 	 	JE	.PR2$	 	;YES
 1978  3C 80	 	 	 	CMP	AL,80H	 	;END OF LINE, NO CRLF?
 197A  74 0D	 	 	 	JE	.PR3$	 	;YES
 197C  8A 26 0000 R	 	 	MOV	AH,NRMATR	;WHITE FOREGROUND
 1980  E8 1887 R	 	 	CALL	.TTYOUT	 	;PRINT CHARACTER
 1983  43	 	 	 	INC	BX	 	;POINT TO NEXT CHARACTER
 1984  EB EC	 	 	 	JMP	.PR1$	 	;REPEAT
 1986  E8 18F0 R	 	.PR2$:	CALL	.CRLF	 	;PRINT A CRLF
 1989  5B	 	 	.PR3$:	POP	BX	 	;RESTORE BX
 198A  C3	 	 	 	RET
 198B	 	 	 	.PRINT	ENDP
 	 	 	 	
 	 	 	 	 	;PRINT A STRING, POINTER (TO DATA SEGMENT) IN AX, ATTRIBUTES IN BX,
 	 	 	 	 	;STARTING ROW IN CH, STARTING COLUMN IN CL
 198B	 	 	 	.PRINTA	PROC
 198B  51	 	 	 	PUSH	CX	 	;SAVE CX
 198C  52	 	 	 	PUSH	DX	 	;SAVE DX
 198D  56	 	 	 	PUSH	SI	 	;SAVE SI
 198E  57	 	 	 	PUSH	DI	 	;SAVE DI
 198F  8B F0	 	 	 	MOV	SI,AX	 	;STRING POINTER
 1991  8B D3	 	 	 	MOV	DX,BX	 	;ATTRIBUTES
 1993  8B F9	 	 	 	MOV	DI,CX	 	;ROW AND COLUMN
 1995  8A 04	 	 	.PA1$:	MOV	AL,[SI]	 	;GET NEXT CHARACTER
 1997  3C 00	 	 	 	CMP	AL,0	 	;END OF LINE, WITH CRLF?
 1999  74 0F	 	 	 	JE	.PA2$	 	;YES
 199B  3C 80	 	 	 	CMP	AL,80H	 	;END OF LINE, NO CRLF?
 199D  74 0E	 	 	 	JE	.PA3$	 	;YES
 199F  8A E2	 	 	 	MOV	AH,DL	 	;ATTRIBUTES
 19A1  8B DF	 	 	 	MOV	BX,DI	 	;ROW AND COLUMN
 19A3  E8 18A4 R	 	 	CALL	.CHROUT	 	;PRINT CHARACTER
 19A6  46	 	 	 	INC	SI	 	;POINT TO NEXT CHARACTER
 19A7  47	 	 	 	INC	DI	 	;MOVE TO NEXT COLUMN
 19A8  EB EB	 	 	 	JMP	.PA1$	 	;REPEAT
 19AA  E8 18F0 R	 	.PA2$:	CALL	.CRLF	 	;PRINT A CRLF
 19AD  5F	 	 	.PA3$:	POP	DI	 	;RESTORE DI
 19AE  5E	 	 	 	POP	SI	 	;RESTORE SI
 19AF  5A	 	 	 	POP	DX	 	;RESTORE DX
 19B0  59	 	 	 	POP	CX	 	;RESTORE CX
 19B1  C3	 	 	 	RET
 19B2	 	 	 	.PRINTA	ENDP
 	 	 	 	
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	19-5
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	IBMPC SYSTEM ROUTINES

 	 	 	 	 	;READ AL SECTORS FROM DRIVE AH STARTING AT TRACK CH, SECTOR CL
 	 	 	 	 	;TO MEMORY STARTING AT ES:BX
 19B2	 	 	 	.RDWRT	PROC
 19B2  52	 	 	 	PUSH	DX	 	;SAVES
 19B3  55	 	 	 	PUSH	BP
 19B4  56	 	 	 	PUSH	SI
 19B5  80 3E 0207 R 00	 	 	CMP	FUCK,0
 19BA  74 17	 	 	 	JE	.RDX$
 19BC  80 3E 066C R 05	 	 	CMP	INIFLG,5
 19C1  75 10	 	 	 	JNE	.RDX$
 19C3  E8 10B3 R	 	 	CALL	PRSPC
 19C6  8B C3	 	 	 	MOV	AX,BX
 19C8  E8 10B3 R	 	 	CALL	PRSPC
 19CB  8B C1	 	 	 	MOV	AX,CX
 19CD  E8 10B3 R	 	 	CALL	PRSPC
 19D0  E8 18F0 R	 	 	CALL	.CRLF
 19D3  BD 0004	 	 	.RDX$:	MOV	BP,4	 	;TRY READING 4 TIMES BEFORE FAILING
 19D6  8A D4	 	 	 	MOV	DL,AH	 	;DRIVE NUMBER
 19D8  B4 02	 	 	 	MOV	AH,2	 	;SET UP FOR DISK READ
 19DA  80 3E 02A8 R 00	 	 	CMP	DSKDIR,0
 19DF  74 03	 	 	 	JE	.RD0$
 19E1  80 C4 01	 	 	 	ADD	AH,1	 	;WRITE IS CONVENIENTLY 3
 19E4  8B F0	 	 	.RD0$:	MOV	SI,AX	 	;SAVE SET UP DATA FOR RETRIES
 19E6  2A F6	 	 	 	SUB	DH,DH	 	;HEAD 0
 19E8  8B C6	 	 	.RD1$:	MOV	AX,SI	 	;RESTORE SET UP DATA
 19EA  CD 13	 	 	 	INT	13H	 	;CALL BIOS DISKETTE I/O ROUTINE
 19EC  73 18	 	 	 	JNC	.RD2$	 	;READ SUCCEEDED
 19EE  4D	 	 	 	DEC	BP	 	;DECREMENT TRY COUNTER
 19EF  75 F7	 	 	 	JNE	.RD1$	 	;RETRY IF COUNTER NON-ZERO
 19F1  80 3E 0207 R 00	 	 	CMP	FUCK,0
 19F6  74 0D	 	 	 	JE	.RDFL$
 19F8  80 3E 066C R 05	 	 	CMP	INIFLG,5
 19FD  75 06	 	 	 	JNE	.RDFL$
 19FF  E8 10B3 R	 	 	CALL	PRSPC
 1A02  E8 18F0 R	 	 	CALL	.CRLF
 1A05  F9	 	 	.RDFL$:	STC	 	 	;INDICATE READ FAILED
 1A06  5E	 	 	.RD2$:	POP	SI	 	;RESTORES
 1A07  5D	 	 	 	POP	BP
 1A08  5A	 	 	 	POP	DX
 1A09  C3	 	 	 	RET
 1A0A	 	 	 	.RDWRT	ENDP
 	 	 	 	
 	 	 	 	 	;GET MEMORY SIZE (IN PARAGRAPHS)
 1A0A	 	 	 	.GETMEM	PROC
 1A0A  F6 06 066C R 02	 	 	TEST	INIFLG,INIMEM	;CHECK FOR FORCED MEMORY
 1A0F  74 04	 	 	 	JZ	.GTM1$
 1A11  B8 0C00	 	 	 	MOV	AX,0C00H	;48K (IN PARAGRAPHS)
 1A14  C3	 	 	 	RET
 1A15  CD 12	 	 	.GTM1$:	INT	12H	 	;CALL BIOS MEMORY SIZE DETERMINATION ROUTINE
 1A17  3D 0200	 	 	 	CMP	AX,512	 	;CHECK FOR >512K
 1A1A  7C 03	 	 	 	JL	.GTMX$
 1A1C  B8 01F4	 	 	 	MOV	AX,500
 1A1F  D1 E0	 	 	.GTMX$:	SHL	AX,1	 	;CONVERT FROM K TO PARAGRAPHS
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	19-6
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION
	 	 	 	IBMPC SYSTEM ROUTINES

 1A21  D1 E0	 	 	 	SHL	AX,1
 1A23  D1 E0	 	 	 	SHL	AX,1
 1A25  D1 E0	 	 	 	SHL	AX,1
 1A27  D1 E0	 	 	 	SHL	AX,1
 1A29  D1 E0	 	 	 	SHL	AX,1
 1A2B  3D 1000	 	 	 	CMP	AX,1000H	;MAXIMUM ALLOWED IS 64K (CROCK)
 1A2E  7E 03	 	 	 	JLE	.GTM2$
 1A30  B8 1000	 	 	 	MOV	AX,1000H
 1A33  C3	 	 	.GTM2$:	RET
 1A34	 	 	 	.GETMEM	ENDP
 	 	 	 	
 	 	 	 	 	;GET TIME
 1A34	 	 	 	.GETTM	PROC
 1A34  50	 	 	 	PUSH	AX	 	;SAVES
 1A35  51	 	 	 	PUSH	CX
 1A36  52	 	 	 	PUSH	DX
 1A37  2A E4	 	 	 	SUB	AH,AH	 	;SET UP FOR READ TIME OF DAY
 1A39  CD 1A	 	 	 	INT	1AH	 	;CALL BIOS TIME OF DAY ROUTINE
 1A3B  89 0E 095E R	 	 	MOV	TIME,CX	 	;STORE IN VARIABLE
 1A3F  89 16 0960 R	 	 	MOV	TIME[2],DX
 1A43  5A	 	 	 	POP	DX	 	;RESTORES
 1A44  59	 	 	 	POP	CX
 1A45  58	 	 	 	POP	AX
 1A46  C3	 	 	 	RET
 1A47	 	 	 	.GETTM	ENDP
 	 	 	 	
 1A47	 	 	 	FINISH	PROC
 1A47  E8 18F0 R	 	 	CALL	.CRLF
 	 	 	 	 	PRINT	REBOOT
 1A4A  50                     +	 	PUSH	AX
 1A4B  B8 01B9 R              +	 	MOV	AX,OFFSET REBOOT
 1A4E  E8 196F R              +	 	CALL	.PRINT
 1A51  58                     +	 	POP	AX
 	 	 	 	 	PRINT	REBOO1
 1A52  50                     +	 	PUSH	AX
 1A53  B8 01D0 R              +	 	MOV	AX,OFFSET REBOO1
 1A56  E8 196F R              +	 	CALL	.PRINT
 1A59  58                     +	 	POP	AX
 1A5A  E8 1864 R	 	 	CALL	.CHRIN	 	;GET A CHARACTER
 1A5D  CD 19	 	 	 	INT	19H	 	;REBOOT
 1A5F	 	 	 	FINISH	ENDP
 	 	 	 	
 1A5F	 	 	 	CODE_SG	ENDS
 	 	 	 	
 0000	 	 	 	GAME_SG	SEGMENT	PAGE AT 800H
 0000	 	 	 	GAME_SG	ENDS
 	 	 	 	
 	 	 	 	 	END	START

 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-1
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


Macros:

	 	N a m e  	 	Length

CURGET . . . . . . . . . . . . .	0002	
CURSET . . . . . . . . . . . . .	0003	
FATAL. . . . . . . . . . . . . .	0003	
GTAWRD . . . . . . . . . . . . .	0001	
MOVM . . . . . . . . . . . . . .	0001	
POPZ . . . . . . . . . . . . . .	0002	
POPZT. . . . . . . . . . . . . .	0001	
PRINT. . . . . . . . . . . . . .	0002	
PTAWRD . . . . . . . . . . . . .	0001	
PUSHZ. . . . . . . . . . . . . .	0002	
PUSHZT . . . . . . . . . . . . .	0001	

Structures and records:

	 	N a m e	 	 	Width	# fields
	 	 	 	 	Shift	Width	Mask	Initial

OBJECT . . . . . . . . . . . . .	0009	0006
  FLAGS1 . . . . . . . . . . . . .	0000
  FLAGS2 . . . . . . . . . . . . .	0002
  PARENT . . . . . . . . . . . . .	0004
  SIBLING. . . . . . . . . . . . .	0005
  CHILD1 . . . . . . . . . . . . .	0006
  PROPS. . . . . . . . . . . . . .	0007
PROPID . . . . . . . . . . . . .	0008	0002
  PROPSIZE . . . . . . . . . . . .	0005	0003	00E0	0000
  PROPNUM. . . . . . . . . . . . .	0000	0005	001F	0000

Segments and groups:

	 	N a m e	 	 	Size	align	combine	class

ABS_SG . . . . . . . . . . . . .	0000	AT    	0000	
CODE_SG. . . . . . . . . . . . .	1A5F	PARA  	NONE	
DATA_SG. . . . . . . . . . . . .	0A3B	PARA  	NONE	
GAME_SG. . . . . . . . . . . . .	0000	AT    	0800	
STK_SG . . . . . . . . . . . . .	0400	PARA  	STACK 	

Symbols:            

	 	N a m e	 	 	Type	Value	Attr         

ARGBLK . . . . . . . . . . . . .	L WORD 	0673	DATA_SG	Length =0004
BKABRT . . . . . . . . . . . . .	L NEAR 	1747	CODE_SG
BKASK1 . . . . . . . . . . . . .	L BYTE 	068E	DATA_SG
BKASK2 . . . . . . . . . . . . .	L BYTE 	06B3	DATA_SG
BKASK3 . . . . . . . . . . . . .	L BYTE 	06D7	DATA_SG
BKASK4 . . . . . . . . . . . . .	L BYTE 	06F8	DATA_SG
BKASK5 . . . . . . . . . . . . .	L BYTE 	071E	DATA_SG
BKBUF. . . . . . . . . . . . . .	L BYTE 	02F5	DATA_SG	Length =0200
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-2
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


BKCHK. . . . . . . . . . . . . .	N PROC	1566	CODE_SG	Length =01F3
BKCOPY . . . . . . . . . . . . .	L BYTE 	07B5	DATA_SG
BKDONE . . . . . . . . . . . . .	L BYTE 	080D	DATA_SG
BKDSK. . . . . . . . . . . . . .	L BYTE 	068C	DATA_SG
BKFAIL . . . . . . . . . . . . .	L BYTE 	081F	DATA_SG
BKFRST . . . . . . . . . . . . .	L BYTE 	068D	DATA_SG
BKICOP . . . . . . . . . . . . .	N PROC	183F	CODE_SG	Length =0025
BKICP1 . . . . . . . . . . . . .	L NEAR 	1854	CODE_SG
BKICPR . . . . . . . . . . . . .	L NEAR 	1846	CODE_SG
BKIFST . . . . . . . . . . . . .	N PROC	17F2	CODE_SG	Length =0025
BKIMS1 . . . . . . . . . . . . .	L NEAR 	182C	CODE_SG
BKIMSR . . . . . . . . . . . . .	L NEAR 	181E	CODE_SG
BKIMST . . . . . . . . . . . . .	N PROC	1817	CODE_SG	Length =0028
BKIMSX . . . . . . . . . . . . .	L NEAR 	183E	CODE_SG
BKMAST . . . . . . . . . . . . .	L BYTE 	0795	DATA_SG
BKMC1. . . . . . . . . . . . . .	L BYTE 	073F	DATA_SG
BKMC2. . . . . . . . . . . . . .	L BYTE 	075D	DATA_SG
BKMC3. . . . . . . . . . . . . .	L BYTE 	0779	DATA_SG
BKNOPE . . . . . . . . . . . . .	L BYTE 	073A	DATA_SG
BKNRDY . . . . . . . . . . . . .	L BYTE 	07F5	DATA_SG
BKRIF. . . . . . . . . . . . . .	L NEAR 	1647	CODE_SG
BKRIL. . . . . . . . . . . . . .	L NEAR 	162C	CODE_SG
BKSEND . . . . . . . . . . . . .	L NEAR 	17C8	CODE_SG
BKST0. . . . . . . . . . . . . .	L NEAR 	17D2	CODE_SG
BKST1. . . . . . . . . . . . . .	L NEAR 	17E2	CODE_SG
BKST2. . . . . . . . . . . . . .	L NEAR 	17EA	CODE_SG
BKSTAT . . . . . . . . . . . . .	N PROC	1791	CODE_SG	Length =0061
BKSTRT . . . . . . . . . . . . .	L NEAR 	1796	CODE_SG
BKUP . . . . . . . . . . . . . .	L NEAR 	1571	CODE_SG
BKUP1. . . . . . . . . . . . . .	L NEAR 	15BF	CODE_SG
BKUP1A . . . . . . . . . . . . .	L NEAR 	15FE	CODE_SG
BKUP1B . . . . . . . . . . . . .	L NEAR 	161F	CODE_SG
BKUP1Z . . . . . . . . . . . . .	L NEAR 	15D6	CODE_SG
BKUP2. . . . . . . . . . . . . .	L NEAR 	1704	CODE_SG
BKUP2A . . . . . . . . . . . . .	L NEAR 	1727	CODE_SG
BKUP3. . . . . . . . . . . . . .	L NEAR 	1735	CODE_SG
BKUPF. . . . . . . . . . . . . .	L NEAR 	15BA	CODE_SG
BKUPG1 . . . . . . . . . . . . .	L NEAR 	16D7	CODE_SG
BKUPGL . . . . . . . . . . . . .	L NEAR 	16B7	CODE_SG
BKWINT . . . . . . . . . . . . .	L NEAR 	164C	CODE_SG
BKWPRT . . . . . . . . . . . . .	L BYTE 	07D3	DATA_SG
BKWPS1 . . . . . . . . . . . . .	L BYTE 	083B	DATA_SG
BKWPS2 . . . . . . . . . . . . .	L BYTE 	085C	DATA_SG
BKYEP. . . . . . . . . . . . . .	L BYTE 	0734	DATA_SG
BKZZ . . . . . . . . . . . . . .	L NEAR 	15E3	CODE_SG
BSPLIT . . . . . . . . . . . . .	N PROC	0C6B	CODE_SG	Length =000B
BSPLTB . . . . . . . . . . . . .	N PROC	0C5D	CODE_SG	Length =000E
BUFPGS . . . . . . . . . . . . .	L WORD 	0669	DATA_SG
BYTVAL . . . . . . . . . . . . .	N PROC	0BFD	CODE_SG	Length =0005
CCS1$. . . . . . . . . . . . . .	L NEAR 	0D94	CODE_SG
CCS2$. . . . . . . . . . . . . .	L NEAR 	0D98	CODE_SG
CCS3$. . . . . . . . . . . . . .	L NEAR 	0DA9	CODE_SG
CCS4$. . . . . . . . . . . . . .	L NEAR 	0DAF	CODE_SG
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-3
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


CCS5$. . . . . . . . . . . . . .	L NEAR 	0DB7	CODE_SG
CHB1$. . . . . . . . . . . . . .	L NEAR 	0DBD	CODE_SG
CHB2$. . . . . . . . . . . . . .	L NEAR 	0DCD	CODE_SG
CHB3$. . . . . . . . . . . . . .	L NEAR 	0DD3	CODE_SG
CHB4$. . . . . . . . . . . . . .	L NEAR 	0DDD	CODE_SG
CHRBYT . . . . . . . . . . . . .	N PROC	0DB9	CODE_SG	Length =0026
CHRCS. . . . . . . . . . . . . .	N PROC	0D8B	CODE_SG	Length =002E
CHRFLG . . . . . . . . . . . . .	L BYTE 	066B	DATA_SG
CHRPTR . . . . . . . . . . . . .	L WORD 	02C6	DATA_SG
CLRSC1 . . . . . . . . . . . . .	L NEAR 	1449	CODE_SG
CLRSCR . . . . . . . . . . . . .	N PROC	1438	CODE_SG	Length =001D
COLFLG . . . . . . . . . . . . .	L BYTE 	0020	DATA_SG
COLORQ . . . . . . . . . . . . .	L BYTE 	0003	DATA_SG
CURBLK . . . . . . . . . . . . .	L WORD 	067D	DATA_SG
CURPAG . . . . . . . . . . . . .	L WORD 	067B	DATA_SG
CURSCR . . . . . . . . . . . . .	L BYTE 	02D9	DATA_SG
CURTAB . . . . . . . . . . . . .	L WORD 	067F	DATA_SG
DAN1 . . . . . . . . . . . . . .	L NEAR 	0283	CODE_SG
DAN2 . . . . . . . . . . . . . .	L NEAR 	0285	CODE_SG
DIP1 . . . . . . . . . . . . . .	L NEAR 	0209	CODE_SG
DIP3 . . . . . . . . . . . . . .	L NEAR 	0231	CODE_SG
DIP4 . . . . . . . . . . . . . .	L NEAR 	0236	CODE_SG
DSKDIR . . . . . . . . . . . . .	L BYTE 	02A8	DATA_SG
DSKDRV . . . . . . . . . . . . .	L BYTE 	02A7	DATA_SG
DSKFIX . . . . . . . . . . . . .	N PROC	177A	CODE_SG	Length =0017
DSKHAK . . . . . . . . . . . . .	N PROC	1759	CODE_SG	Length =0021
DSKMOD . . . . . . . . . . . . .	L BYTE 	02A6	DATA_SG
DSK_PRM. . . . . . . . . . . . .	L BYTE 	0875	DATA_SG
DSK_SV1. . . . . . . . . . . . .	L WORD 	0871	DATA_SG
DSK_SV2. . . . . . . . . . . . .	L WORD 	0873	DATA_SG
ENDBUF . . . . . . . . . . . . .	L WORD 	02C8	DATA_SG
ENDLOD . . . . . . . . . . . . .	L WORD 	02E1	DATA_SG
EOICHR . . . . . . . . . . . . .	Number	000F	
EOLCHR . . . . . . . . . . . . .	Number	000A	
ERR2 . . . . . . . . . . . . . .	L BYTE 	0962	DATA_SG
ESIBKS . . . . . . . . . . . . .	L WORD 	02ED	DATA_SG
EXTOP. . . . . . . . . . . . . .	L WORD 	08D0	DATA_SG
FATHDR . . . . . . . . . . . . .	L BYTE 	09DF	DATA_SG
FEEP . . . . . . . . . . . . . .	N PROC	0018	CODE_SG	Length =0007
FINDPG . . . . . . . . . . . . .	N PROC	1359	CODE_SG	Length =004D
FINISH . . . . . . . . . . . . .	N PROC	1A47	CODE_SG	Length =0018
FNP1$. . . . . . . . . . . . . .	L NEAR 	1363	CODE_SG
FNP2$. . . . . . . . . . . . . .	L NEAR 	136F	CODE_SG
FNP3$. . . . . . . . . . . . . .	L NEAR 	1376	CODE_SG
FNP4$. . . . . . . . . . . . . .	L NEAR 	1394	CODE_SG
FRML . . . . . . . . . . . . . .	L NEAR 	1658	CODE_SG
FRMLL. . . . . . . . . . . . . .	L NEAR 	1660	CODE_SG
FTL2 . . . . . . . . . . . . . .	L BYTE 	0983	DATA_SG
FTL4 . . . . . . . . . . . . . .	L BYTE 	0994	DATA_SG
FTL5 . . . . . . . . . . . . . .	L BYTE 	09AA	DATA_SG
FTL6 . . . . . . . . . . . . . .	L BYTE 	09BC	DATA_SG
FTL7 . . . . . . . . . . . . . .	L BYTE 	09CA	DATA_SG
FUBAR$ . . . . . . . . . . . . .	L NEAR 	1129	CODE_SG
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-4
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


FUCK . . . . . . . . . . . . . .	L BYTE 	0207	DATA_SG
GAMETRK. . . . . . . . . . . . .	Number	0006	
GETARG . . . . . . . . . . . . .	N PROC	0B8D	CODE_SG	Length =0013
GETBLK . . . . . . . . . . . . .	N PROC	147B	CODE_SG	Length =0009
GETBYT . . . . . . . . . . . . .	N PROC	0B26	CODE_SG	Length =002D
GETLIN . . . . . . . . . . . . .	N PROC	0696	CODE_SG	Length =00A2
GETNUM . . . . . . . . . . . . .	N PROC	1455	CODE_SG	Length =0026
GETPAG . . . . . . . . . . . . .	N PROC	12E1	CODE_SG	Length =0078
GETVAR . . . . . . . . . . . . .	N PROC	0BA0	CODE_SG	Length =0030
GETWRD . . . . . . . . . . . . .	N PROC	0B53	CODE_SG	Length =000D
GLOTAB . . . . . . . . . . . . .	L WORD 	02E7	DATA_SG
GTB1$. . . . . . . . . . . . . .	L NEAR 	150B	CODE_SG
GTB2$. . . . . . . . . . . . . .	L NEAR 	1515	CODE_SG
GTBCNT . . . . . . . . . . . . .	L WORD 	02A9	DATA_SG
GTBCOR . . . . . . . . . . . . .	L WORD 	02AD	DATA_SG
GTBKI$ . . . . . . . . . . . . .	L NEAR 	14AD	CODE_SG
GTBLKS . . . . . . . . . . . . .	N PROC	149E	CODE_SG	Length =0089
GTBSTT . . . . . . . . . . . . .	L WORD 	02AB	DATA_SG
GTBX0$ . . . . . . . . . . . . .	L NEAR 	14AF	CODE_SG
GTBX1$ . . . . . . . . . . . . .	L NEAR 	14E1	CODE_SG
GTBX2$ . . . . . . . . . . . . .	L NEAR 	1507	CODE_SG
GTBX3$ . . . . . . . . . . . . .	L NEAR 	1508	CODE_SG
GTBXN$ . . . . . . . . . . . . .	L NEAR 	14CC	CODE_SG
GTL0$. . . . . . . . . . . . . .	L NEAR 	06BC	CODE_SG
GTL1$. . . . . . . . . . . . . .	L NEAR 	0704	CODE_SG
GTL2$. . . . . . . . . . . . . .	L NEAR 	06D4	CODE_SG
GTL3$. . . . . . . . . . . . . .	L NEAR 	06ED	CODE_SG
GTL4$. . . . . . . . . . . . . .	L NEAR 	0725	CODE_SG
GTL5$. . . . . . . . . . . . . .	L NEAR 	0723	CODE_SG
GTLD$. . . . . . . . . . . . . .	L NEAR 	072F	CODE_SG
GTLF$. . . . . . . . . . . . . .	L NEAR 	06C8	CODE_SG
GTLL$. . . . . . . . . . . . . .	L NEAR 	06A8	CODE_SG
GTLL1$ . . . . . . . . . . . . .	L NEAR 	06D0	CODE_SG
GTLX$. . . . . . . . . . . . . .	L NEAR 	06B3	CODE_SG
GTP1$. . . . . . . . . . . . . .	L NEAR 	12EB	CODE_SG
GTP2$. . . . . . . . . . . . . .	L NEAR 	12FD	CODE_SG
GTP2A$ . . . . . . . . . . . . .	L NEAR 	1316	CODE_SG
GTP3$. . . . . . . . . . . . . .	L NEAR 	132A	CODE_SG
GTP4$. . . . . . . . . . . . . .	L NEAR 	1351	CODE_SG
GTV1$. . . . . . . . . . . . . .	L NEAR 	0BA9	CODE_SG
GTV2$. . . . . . . . . . . . . .	L NEAR 	0BBB	CODE_SG
GTV3$. . . . . . . . . . . . . .	L NEAR 	0BBD	CODE_SG
GTY1$. . . . . . . . . . . . . .	L NEAR 	0B3A	CODE_SG
GTY2$. . . . . . . . . . . . . .	L NEAR 	0B43	CODE_SG
GTY3$. . . . . . . . . . . . . .	L NEAR 	0B52	CODE_SG
IDTBL. . . . . . . . . . . . . .	L BYTE 	0880	DATA_SG
INIFLG . . . . . . . . . . . . .	L BYTE 	066C	DATA_SG
INIMEM . . . . . . . . . . . . .	Number	0002	
INIRND . . . . . . . . . . . . .	Number	0004	
INIWID . . . . . . . . . . . . .	Number	0001	
INTMSG . . . . . . . . . . . . .	L BYTE 	01E9	DATA_SG
INTVER . . . . . . . . . . . . .	L BYTE 	0204	DATA_SG
IRBRKS . . . . . . . . . . . . .	L BYTE 	02CC	DATA_SG
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-5
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


JPF. . . . . . . . . . . . . . .	L NEAR 	0369	CODE_SG
JPF1 . . . . . . . . . . . . . .	L NEAR 	04C1	CODE_SG
JPT. . . . . . . . . . . . . . .	L NEAR 	036C	CODE_SG
JPT1 . . . . . . . . . . . . . .	L NEAR 	04BE	CODE_SG
LDOUTB . . . . . . . . . . . . .	Number	0050	
LFTMAR . . . . . . . . . . . . .	L BYTE 	02DA	DATA_SG
LINMAX . . . . . . . . . . . . .	L WORD 	095C	DATA_SG
LINMXX . . . . . . . . . . . . .	Number	0017	
LMOUTB . . . . . . . . . . . . .	Number	0050	
LPAGE. . . . . . . . . . . . . .	L WORD 	0684	DATA_SG
LPAGES . . . . . . . . . . . . .	Number	0080	
LPLOC. . . . . . . . . . . . . .	L WORD 	0686	DATA_SG
LPTAB. . . . . . . . . . . . . .	L WORD 	0688	DATA_SG
LSTACK . . . . . . . . . . . . .	Number	0100	
LXBYTS . . . . . . . . . . . . .	Number	0750	
MEMTOP . . . . . . . . . . . . .	L WORD 	02DB	DATA_SG
MORE . . . . . . . . . . . . . .	L BYTE 	0950	DATA_SG
MORLIN . . . . . . . . . . . . .	L WORD 	095A	DATA_SG
NDISKS . . . . . . . . . . . . .	L BYTE 	0206	DATA_SG
NEWLIN . . . . . . . . . . . . .	N PROC	0F02	CODE_SG	Length =0018
NEWZPC . . . . . . . . . . . . .	N PROC	1245	CODE_SG	Length =009C
NRMATR . . . . . . . . . . . . .	L BYTE 	0000	DATA_SG
NWZ1$. . . . . . . . . . . . . .	L NEAR 	127F	CODE_SG
NWZ2$. . . . . . . . . . . . . .	L NEAR 	12A8	CODE_SG
NWZ3$. . . . . . . . . . . . . .	L NEAR 	12CD	CODE_SG
NWZ4$. . . . . . . . . . . . . .	L NEAR 	12D7	CODE_SG
NWZ5$. . . . . . . . . . . . . .	L NEAR 	12DB	CODE_SG
NXB1$. . . . . . . . . . . . . .	L NEAR 	0B7B	CODE_SG
NXI0A$ . . . . . . . . . . . . .	L NEAR 	1143	CODE_SG
NXI0B$ . . . . . . . . . . . . .	L NEAR 	114B	CODE_SG
NXI0C$ . . . . . . . . . . . . .	L NEAR 	115F	CODE_SG
NXI1$. . . . . . . . . . . . . .	L NEAR 	1165	CODE_SG
NXI10$ . . . . . . . . . . . . .	L NEAR 	11D3	CODE_SG
NXI11$ . . . . . . . . . . . . .	L NEAR 	11E1	CODE_SG
NXI12$ . . . . . . . . . . . . .	L NEAR 	11FA	CODE_SG
NXI13$ . . . . . . . . . . . . .	L NEAR 	121D	CODE_SG
NXI14$ . . . . . . . . . . . . .	L NEAR 	122E	CODE_SG
NXI15$ . . . . . . . . . . . . .	L NEAR 	1240	CODE_SG
NXI2$. . . . . . . . . . . . . .	L NEAR 	1174	CODE_SG
NXI3$. . . . . . . . . . . . . .	L NEAR 	1186	CODE_SG
NXI4$. . . . . . . . . . . . . .	L NEAR 	118B	CODE_SG
NXI5$. . . . . . . . . . . . . .	L NEAR 	1190	CODE_SG
NXI6$. . . . . . . . . . . . . .	L NEAR 	11AA	CODE_SG
NXI7$. . . . . . . . . . . . . .	L NEAR 	11AE	CODE_SG
NXI8$. . . . . . . . . . . . . .	L NEAR 	11B2	CODE_SG
NXI8A$ . . . . . . . . . . . . .	L NEAR 	11B5	CODE_SG
NXI9$. . . . . . . . . . . . . .	L NEAR 	11B8	CODE_SG
NXTBYT . . . . . . . . . . . . .	N PROC	0B60	CODE_SG	Length =0020
NXTINS . . . . . . . . . . . . .	N PROC	1131	CODE_SG	Length =0114
NXTPRP . . . . . . . . . . . . .	N PROC	0C8C	CODE_SG	Length =0015
NXTWRD . . . . . . . . . . . . .	N PROC	0B80	CODE_SG	Length =000D
OBJLOC . . . . . . . . . . . . .	N PROC	0C76	CODE_SG	Length =0016
OBJTAB . . . . . . . . . . . . .	L WORD 	02E5	DATA_SG
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-6
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


OCL1$. . . . . . . . . . . . . .	L NEAR 	0A85	CODE_SG
OCL2$. . . . . . . . . . . . . .	L NEAR 	0ABC	CODE_SG
OCL3$. . . . . . . . . . . . . .	L NEAR 	0AD2	CODE_SG
OCL4$. . . . . . . . . . . . . .	L NEAR 	0AD9	CODE_SG
OFC1$. . . . . . . . . . . . . .	L NEAR 	048A	CODE_SG
OFS1$. . . . . . . . . . . . . .	L NEAR 	0467	CODE_SG
OGP1$. . . . . . . . . . . . . .	L NEAR 	04FE	CODE_SG
OGP2$. . . . . . . . . . . . . .	L NEAR 	0501	CODE_SG
OGP3$. . . . . . . . . . . . . .	L NEAR 	0520	CODE_SG
OGP4$. . . . . . . . . . . . . .	L NEAR 	0525	CODE_SG
OGP5$. . . . . . . . . . . . . .	L NEAR 	0529	CODE_SG
OGT1$. . . . . . . . . . . . . .	L NEAR 	0615	CODE_SG
OGT2$. . . . . . . . . . . . . .	L NEAR 	0618	CODE_SG
OGT3$. . . . . . . . . . . . . .	L NEAR 	0628	CODE_SG
OGT4$. . . . . . . . . . . . . .	L NEAR 	062B	CODE_SG
OLDCUR . . . . . . . . . . . . .	L WORD 	0021	DATA_SG
OMV1$. . . . . . . . . . . . . .	L NEAR 	03E8	CODE_SG
ONEOP. . . . . . . . . . . . . .	L WORD 	08B0	DATA_SG
ONX1$. . . . . . . . . . . . . .	L NEAR 	05A4	CODE_SG
ONX2$. . . . . . . . . . . . . .	L NEAR 	05A7	CODE_SG
ONX3$. . . . . . . . . . . . . .	L NEAR 	05C4	CODE_SG
ONX4$. . . . . . . . . . . . . .	L NEAR 	05C7	CODE_SG
OPADD. . . . . . . . . . . . . .	N PROC	030A	CODE_SG	Length =0005
OPBAND . . . . . . . . . . . . .	N PROC	0387	CODE_SG	Length =0005
OPBCOM . . . . . . . . . . . . .	N PROC	0382	CODE_SG	Length =0005
OPBOR. . . . . . . . . . . . . .	N PROC	037D	CODE_SG	Length =0005
OPBTST . . . . . . . . . . . . .	N PROC	0375	CODE_SG	Length =0008
OPCALL . . . . . . . . . . . . .	N PROC	0A75	CODE_SG	Length =0065
OPCRLF . . . . . . . . . . . . .	N PROC	0A72	CODE_SG	Length =0003
OPDEC. . . . . . . . . . . . . .	N PROC	0664	CODE_SG	Length =0008
OPDIV. . . . . . . . . . . . . .	N PROC	0319	CODE_SG	Length =0006
OPFCLE . . . . . . . . . . . . .	N PROC	047D	CODE_SG	Length =0023
OPFSET . . . . . . . . . . . . .	N PROC	045A	CODE_SG	Length =0023
OPFSTA . . . . . . . . . . . . .	N PROC	0B1F	CODE_SG	Length =0006
OPGET. . . . . . . . . . . . . .	N PROC	05CF	CODE_SG	Length =000F
OPGETB . . . . . . . . . . . . .	N PROC	05DE	CODE_SG	Length =000D
OPGETP . . . . . . . . . . . . .	N PROC	04E4	CODE_SG	Length =004D
OPGTPT . . . . . . . . . . . . .	N PROC	05FB	CODE_SG	Length =0033
OPH0$. . . . . . . . . . . . . .	L NEAR 	09FB	CODE_SG
OPH00$ . . . . . . . . . . . . .	L NEAR 	0A01	CODE_SG
OPH1$. . . . . . . . . . . . . .	L NEAR 	0A07	CODE_SG
OPH2$. . . . . . . . . . . . . .	L NEAR 	0A12	CODE_SG
OPINC. . . . . . . . . . . . . .	N PROC	0657	CODE_SG	Length =000D
OPINC1 . . . . . . . . . . . . .	L NEAR 	065D	CODE_SG
OPJUMP . . . . . . . . . . . . .	N PROC	0B0C	CODE_SG	Length =000C
OPLOC. . . . . . . . . . . . . .	N PROC	04A0	CODE_SG	Length =000C
OPM1$. . . . . . . . . . . . . .	L NEAR 	0A25	CODE_SG
OPM2$. . . . . . . . . . . . . .	L NEAR 	0A38	CODE_SG
OPMOD. . . . . . . . . . . . . .	N PROC	031F	CODE_SG	Length =0008
OPMOVE . . . . . . . . . . . . .	N PROC	03BE	CODE_SG	Length =002B
OPMUL. . . . . . . . . . . . . .	N PROC	0314	CODE_SG	Length =0005
OPN1$. . . . . . . . . . . . . .	L NEAR 	09B1	CODE_SG
OPN2$. . . . . . . . . . . . . .	L NEAR 	09BB	CODE_SG
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-7
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


OPN3$. . . . . . . . . . . . . .	L NEAR 	09C0	CODE_SG
OPN4$. . . . . . . . . . . . . .	L NEAR 	09CC	CODE_SG
OPN5$. . . . . . . . . . . . . .	L NEAR 	09D6	CODE_SG
OPN6$. . . . . . . . . . . . . .	L NEAR 	09D7	CODE_SG
OPNEXT . . . . . . . . . . . . .	N PROC	0585	CODE_SG	Length =004A
OPNOOP . . . . . . . . . . . . .	N PROC	0B25	CODE_SG	Length =0001
OPP1$. . . . . . . . . . . . . .	L NEAR 	054C	CODE_SG
OPP2$. . . . . . . . . . . . . .	L NEAR 	054F	CODE_SG
OPP3$. . . . . . . . . . . . . .	L NEAR 	056C	CODE_SG
OPP4$. . . . . . . . . . . . . .	L NEAR 	057F	CODE_SG
OPPOP. . . . . . . . . . . . . .	N PROC	064F	CODE_SG	Length =0008
OPPRIN . . . . . . . . . . . . .	N PROC	09E1	CODE_SG	Length =0006
OPPRNB . . . . . . . . . . . . .	N PROC	09E7	CODE_SG	Length =0006
OPPRNC . . . . . . . . . . . . .	N PROC	09A1	CODE_SG	Length =0003
OPPRND . . . . . . . . . . . . .	N PROC	0A40	CODE_SG	Length =0015
OPPRNH . . . . . . . . . . . . .	N PROC	09ED	CODE_SG	Length =002D
OPPRNI . . . . . . . . . . . . .	N PROC	0A55	CODE_SG	Length =0014
OPPRNM . . . . . . . . . . . . .	N PROC	0A1A	CODE_SG	Length =0026
OPPRNN . . . . . . . . . . . . .	N PROC	09A4	CODE_SG	Length =003D
OPPRNR . . . . . . . . . . . . .	N PROC	0A69	CODE_SG	Length =0009
OPPTSI . . . . . . . . . . . . .	N PROC	062E	CODE_SG	Length =0012
OPPUSH . . . . . . . . . . . . .	N PROC	0649	CODE_SG	Length =0006
OPPUT. . . . . . . . . . . . . .	N PROC	05EB	CODE_SG	Length =000A
OPPUTB . . . . . . . . . . . . .	N PROC	05F5	CODE_SG	Length =0006
OPPUTP . . . . . . . . . . . . .	N PROC	0531	CODE_SG	Length =0054
OPQDLE . . . . . . . . . . . . .	N PROC	0689	CODE_SG	Length =000D
OPQEQU . . . . . . . . . . . . .	N PROC	038C	CODE_SG	Length =0027
OPQFIR . . . . . . . . . . . . .	N PROC	04AC	CODE_SG	Length =0018
OPQFSE . . . . . . . . . . . . .	N PROC	0435	CODE_SG	Length =0025
OPQGRT . . . . . . . . . . . . .	N PROC	036F	CODE_SG	Length =0006
OPQIG0 . . . . . . . . . . . . .	L NEAR 	0677	CODE_SG
OPQIG1 . . . . . . . . . . . . .	L NEAR 	0678	CODE_SG
OPQIGR . . . . . . . . . . . . .	N PROC	066C	CODE_SG	Length =001D
OPQIN. . . . . . . . . . . . . .	N PROC	04D8	CODE_SG	Length =000C
OPQLES . . . . . . . . . . . . .	N PROC	0365	CODE_SG	Length =000A
OPQNEX . . . . . . . . . . . . .	N PROC	04C4	CODE_SG	Length =0014
OPQUIT . . . . . . . . . . . . .	N PROC	01E9	CODE_SG	Length =0003
OPQZER . . . . . . . . . . . . .	N PROC	03B3	CODE_SG	Length =000B
OPRAND . . . . . . . . . . . . .	N PROC	0327	CODE_SG	Length =003E
OPREAD . . . . . . . . . . . . .	N PROC	081E	CODE_SG	Length =0183
OPREMO . . . . . . . . . . . . .	N PROC	03E9	CODE_SG	Length =004C
OPREST . . . . . . . . . . . . .	N PROC	007B	CODE_SG	Length =0008
OPRETU . . . . . . . . . . . . .	N PROC	0ADA	CODE_SG	Length =0029
OPRFAL . . . . . . . . . . . . .	N PROC	0B08	CODE_SG	Length =0004
OPRN1$ . . . . . . . . . . . . .	L NEAR 	0358	CODE_SG
OPRSTA . . . . . . . . . . . . .	N PROC	0B18	CODE_SG	Length =0007
OPRSTT . . . . . . . . . . . . .	N PROC	01D5	CODE_SG	Length =0014
OPRTRU . . . . . . . . . . . . .	N PROC	0B03	CODE_SG	Length =0005
OPSAVE . . . . . . . . . . . . .	N PROC	0083	CODE_SG	Length =0152
OPSCR1 . . . . . . . . . . . . .	L NEAR 	0211	CODE_SG
OPSCR2 . . . . . . . . . . . . .	L NEAR 	023C	CODE_SG
OPSCR3 . . . . . . . . . . . . .	L NEAR 	0242	CODE_SG
OPSCRN . . . . . . . . . . . . .	N PROC	01EC	CODE_SG	Length =0057
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-8
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


OPSET. . . . . . . . . . . . . .	N PROC	0646	CODE_SG	Length =0003
OPSPLT . . . . . . . . . . . . .	N PROC	0243	CODE_SG	Length =0061
OPSPLU . . . . . . . . . . . . .	L NEAR 	0292	CODE_SG
OPSUB. . . . . . . . . . . . . .	N PROC	030F	CODE_SG	Length =0005
OPUSL. . . . . . . . . . . . . .	N PROC	02A4	CODE_SG	Length =0066
OPVALU . . . . . . . . . . . . .	N PROC	0640	CODE_SG	Length =0006
OPVERI . . . . . . . . . . . . .	N PROC	001F	CODE_SG	Length =005C
OPVR1. . . . . . . . . . . . . .	L NEAR 	004C	CODE_SG
OPVR2. . . . . . . . . . . . . .	L NEAR 	0078	CODE_SG
OPVX . . . . . . . . . . . . . .	L NEAR 	005D	CODE_SG
OQE1$. . . . . . . . . . . . . .	L NEAR 	03AD	CODE_SG
OQE2$. . . . . . . . . . . . . .	L NEAR 	03B0	CODE_SG
OQF1$. . . . . . . . . . . . . .	L NEAR 	0442	CODE_SG
OQF2$. . . . . . . . . . . . . .	L NEAR 	0457	CODE_SG
OQI1$. . . . . . . . . . . . . .	L NEAR 	0686	CODE_SG
OQZ1$. . . . . . . . . . . . . .	L NEAR 	03BB	CODE_SG
ORD1$. . . . . . . . . . . . . .	L NEAR 	082F	CODE_SG
ORD10$ . . . . . . . . . . . . .	L NEAR 	0875	CODE_SG
ORD11$ . . . . . . . . . . . . .	L NEAR 	0889	CODE_SG
ORD12$ . . . . . . . . . . . . .	L NEAR 	08A3	CODE_SG
ORD13$ . . . . . . . . . . . . .	L NEAR 	08B2	CODE_SG
ORD14$ . . . . . . . . . . . . .	L NEAR 	08BC	CODE_SG
ORD15$ . . . . . . . . . . . . .	L NEAR 	08BD	CODE_SG
ORD16$ . . . . . . . . . . . . .	L NEAR 	08F7	CODE_SG
ORD17$ . . . . . . . . . . . . .	L NEAR 	0935	CODE_SG
ORD18$ . . . . . . . . . . . . .	L NEAR 	094B	CODE_SG
ORD19$ . . . . . . . . . . . . .	L NEAR 	096B	CODE_SG
ORD1A$ . . . . . . . . . . . . .	L NEAR 	0885	CODE_SG
ORD20$ . . . . . . . . . . . . .	L NEAR 	0976	CODE_SG
ORD21$ . . . . . . . . . . . . .	L NEAR 	0978	CODE_SG
ORD22$ . . . . . . . . . . . . .	L NEAR 	0980	CODE_SG
ORD23$ . . . . . . . . . . . . .	L NEAR 	098F	CODE_SG
ORD8$. . . . . . . . . . . . . .	L NEAR 	0861	CODE_SG
ORD9$. . . . . . . . . . . . . .	L NEAR 	0866	CODE_SG
ORDNS$ . . . . . . . . . . . . .	L NEAR 	084A	CODE_SG
ORM1$. . . . . . . . . . . . . .	L NEAR 	0413	CODE_SG
ORM2$. . . . . . . . . . . . . .	L NEAR 	042A	CODE_SG
ORM3$. . . . . . . . . . . . . .	L NEAR 	0434	CODE_SG
OSAB1$ . . . . . . . . . . . . .	L NEAR 	00EC	CODE_SG
OSAB2$ . . . . . . . . . . . . .	L NEAR 	00F2	CODE_SG
OSV0$. . . . . . . . . . . . . .	L NEAR 	0088	CODE_SG
OSV0A$ . . . . . . . . . . . . .	L NEAR 	00D8	CODE_SG
OSV1$. . . . . . . . . . . . . .	L NEAR 	00E2	CODE_SG
OSV1A$ . . . . . . . . . . . . .	L NEAR 	00FE	CODE_SG
OSV1B$ . . . . . . . . . . . . .	L NEAR 	0103	CODE_SG
OSV2A$ . . . . . . . . . . . . .	L NEAR 	009B	CODE_SG
OSV3$. . . . . . . . . . . . . .	L NEAR 	00A5	CODE_SG
OSV3A$ . . . . . . . . . . . . .	L NEAR 	00BB	CODE_SG
OSV3B$ . . . . . . . . . . . . .	L NEAR 	00C0	CODE_SG
OSV3C$ . . . . . . . . . . . . .	L NEAR 	01BD	CODE_SG
OSV3X$ . . . . . . . . . . . . .	L NEAR 	00B1	CODE_SG
OSV3Z$ . . . . . . . . . . . . .	L NEAR 	0128	CODE_SG
OSV4$. . . . . . . . . . . . . .	L NEAR 	01CF	CODE_SG
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-9
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


OSVT0$ . . . . . . . . . . . . .	L NEAR 	0187	CODE_SG
OUTBUF . . . . . . . . . . . . .	L BYTE 	04F5	DATA_SG	Length =0051
PADCHR . . . . . . . . . . . . .	Number	0005	
PAGES. . . . . . . . . . . . . .	L WORD 	0667	DATA_SG
PAGTAB . . . . . . . . . . . . .	L BYTE 	0566	DATA_SG	Length =0040
PCHKSM . . . . . . . . . . . . .	Number	001C	
PENDLD . . . . . . . . . . . . .	Number	0004	
PFALSE . . . . . . . . . . . . .	N PROC	0C12	CODE_SG	Length =0005
PFLAGS . . . . . . . . . . . . .	Number	0010	
PGLOTB . . . . . . . . . . . . .	Number	000C	
PLENTH . . . . . . . . . . . . .	Number	001A	
PMFLAG . . . . . . . . . . . . .	L BYTE 	004C	DATA_SG
POBJTB . . . . . . . . . . . . .	Number	000A	
PPR1$. . . . . . . . . . . . . .	L NEAR 	0C26	CODE_SG
PPR2$. . . . . . . . . . . . . .	L NEAR 	0C31	CODE_SG
PPR3$. . . . . . . . . . . . . .	L NEAR 	0C43	CODE_SG
PPR4$. . . . . . . . . . . . . .	L NEAR 	0C4E	CODE_SG
PPR5$. . . . . . . . . . . . . .	L NEAR 	0C54	CODE_SG
PPR6$. . . . . . . . . . . . . .	L NEAR 	0C5C	CODE_SG
PPRED. . . . . . . . . . . . . .	N PROC	0C1D	CODE_SG	Length =0040
PPURBT . . . . . . . . . . . . .	Number	000E	
PRNA$. . . . . . . . . . . . . .	L NEAR 	0764	CODE_SG
PRNEX$ . . . . . . . . . . . . .	L NEAR 	0765	CODE_SG
PRNL$. . . . . . . . . . . . . .	L NEAR 	074A	CODE_SG
PRNR$. . . . . . . . . . . . . .	L NEAR 	0770	CODE_SG
PRNRDY . . . . . . . . . . . . .	L BYTE 	0024	DATA_SG
PRSPC. . . . . . . . . . . . . .	N PROC	10B3	CODE_SG	Length =000F
PRTCRL . . . . . . . . . . . . .	N PROC	0813	CODE_SG	Length =000B
PRTLOS . . . . . . . . . . . . .	N PROC	0738	CODE_SG	Length =003B
PRTO1$ . . . . . . . . . . . . .	L NEAR 	079A	CODE_SG
PRTOUT . . . . . . . . . . . . .	N PROC	0773	CODE_SG	Length =0029
PRTRT$ . . . . . . . . . . . . .	L NEAR 	0773	CODE_SG
PSERNM . . . . . . . . . . . . .	Number	0012	
PSTART . . . . . . . . . . . . .	Number	0006	
PTBLKS . . . . . . . . . . . . .	N PROC	148C	CODE_SG	Length =0012
PTC0$. . . . . . . . . . . . . .	L NEAR 	0E8B	CODE_SG
PTC1$. . . . . . . . . . . . . .	L NEAR 	0E9F	CODE_SG
PTC2$. . . . . . . . . . . . . .	L NEAR 	0EA9	CODE_SG
PTC3$. . . . . . . . . . . . . .	L NEAR 	0EC5	CODE_SG
PTC4$. . . . . . . . . . . . . .	L NEAR 	0ED8	CODE_SG
PTC5$. . . . . . . . . . . . . .	L NEAR 	0EE8	CODE_SG
PTC6$. . . . . . . . . . . . . .	L NEAR 	0EEC	CODE_SG
PTC7$. . . . . . . . . . . . . .	L NEAR 	0EF4	CODE_SG
PTC8$. . . . . . . . . . . . . .	L NEAR 	0F00	CODE_SG
PTRUE. . . . . . . . . . . . . .	N PROC	0C17	CODE_SG	Length =0006
PTS1$. . . . . . . . . . . . . .	L NEAR 	0CAA	CODE_SG
PTS10$ . . . . . . . . . . . . .	L NEAR 	0D3F	CODE_SG
PTS11$ . . . . . . . . . . . . .	L NEAR 	0D58	CODE_SG
PTS12$ . . . . . . . . . . . . .	L NEAR 	0D65	CODE_SG
PTS13$ . . . . . . . . . . . . .	L NEAR 	0D6B	CODE_SG
PTS14$ . . . . . . . . . . . . .	L NEAR 	0D73	CODE_SG
PTS15$ . . . . . . . . . . . . .	L NEAR 	0D76	CODE_SG
PTS16$ . . . . . . . . . . . . .	L NEAR 	0D78	CODE_SG
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-10
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


PTS1A$ . . . . . . . . . . . . .	L NEAR 	0D85	CODE_SG
PTS2$. . . . . . . . . . . . . .	L NEAR 	0CB5	CODE_SG
PTS3$. . . . . . . . . . . . . .	L NEAR 	0CC3	CODE_SG
PTS3A$ . . . . . . . . . . . . .	L NEAR 	0D70	CODE_SG
PTS4$. . . . . . . . . . . . . .	L NEAR 	0CE5	CODE_SG
PTS5$. . . . . . . . . . . . . .	L NEAR 	0CF3	CODE_SG
PTS6$. . . . . . . . . . . . . .	L NEAR 	0D06	CODE_SG
PTS7$. . . . . . . . . . . . . .	L NEAR 	0D1B	CODE_SG
PTS8$. . . . . . . . . . . . . .	L NEAR 	0D21	CODE_SG
PTS9$. . . . . . . . . . . . . .	L NEAR 	0D34	CODE_SG
PTV1$. . . . . . . . . . . . . .	L NEAR 	0BD9	CODE_SG
PTV2$. . . . . . . . . . . . . .	L NEAR 	0BED	CODE_SG
PURBOT . . . . . . . . . . . . .	L WORD 	02EB	DATA_SG
PUTCHR . . . . . . . . . . . . .	N PROC	0E61	CODE_SG	Length =00A1
PUTSTR . . . . . . . . . . . . .	N PROC	0CA1	CODE_SG	Length =00EA
PUTVAL . . . . . . . . . . . . .	N PROC	0C02	CODE_SG	Length =0010
PUTVAR . . . . . . . . . . . . .	N PROC	0BD0	CODE_SG	Length =002D
PVERS1 . . . . . . . . . . . . .	Number	0000	
PVERS2 . . . . . . . . . . . . .	Number	0001	
PVOCTB . . . . . . . . . . . . .	Number	0008	
PWRDTB . . . . . . . . . . . . .	Number	0018	
PZRKID . . . . . . . . . . . . .	Number	0002	
RBRKS. . . . . . . . . . . . . .	L BYTE 	0546	DATA_SG	Length =0020
RDBOS. . . . . . . . . . . . . .	L WORD 	02BD	DATA_SG
RDEOS. . . . . . . . . . . . . .	L WORD 	02BF	DATA_SG
RDNWDS . . . . . . . . . . . . .	L BYTE 	02C3	DATA_SG
RDRET. . . . . . . . . . . . . .	L WORD 	02C1	DATA_SG
RDWSTR . . . . . . . . . . . . .	L WORD 	02B5	DATA_SG	Length =0004
REBOO1 . . . . . . . . . . . . .	L BYTE 	01D0	DATA_SG
REBOOT . . . . . . . . . . . . .	L BYTE 	01B9	DATA_SG
RESTRT . . . . . . . . . . . . .	N PROC	10C2	CODE_SG	Length =006F
RSEED1 . . . . . . . . . . . . .	L WORD 	02AF	DATA_SG
RSEED2 . . . . . . . . . . . . .	L WORD 	02B1	DATA_SG
RTEMP. . . . . . . . . . . . . .	L WORD 	02B3	DATA_SG
RTIME1 . . . . . . . . . . . . .	L BYTE 	0681	DATA_SG
RTIME2 . . . . . . . . . . . . .	L WORD 	0682	DATA_SG
RWIDTH . . . . . . . . . . . . .	L WORD 	02D6	DATA_SG
SCR1$. . . . . . . . . . . . . .	L NEAR 	07DF	CODE_SG
SCR1L$ . . . . . . . . . . . . .	L NEAR 	07E9	CODE_SG
SCR2L$ . . . . . . . . . . . . .	L NEAR 	07F7	CODE_SG
SCRCHK . . . . . . . . . . . . .	N PROC	079C	CODE_SG	Length =0077
SCREX$ . . . . . . . . . . . . .	L NEAR 	07DB	CODE_SG
SCRFLG . . . . . . . . . . . . .	L BYTE 	0023	DATA_SG
SCRN0. . . . . . . . . . . . . .	L BYTE 	02D8	DATA_SG
SCRNN$ . . . . . . . . . . . . .	L NEAR 	080C	CODE_SG
SCRR1$ . . . . . . . . . . . . .	L NEAR 	07B0	CODE_SG
SCRR2$ . . . . . . . . . . . . .	L NEAR 	07C1	CODE_SG
SECCNT . . . . . . . . . . . . .	L BYTE 	068A	DATA_SG
SIN1A$ . . . . . . . . . . . . .	L NEAR 	141D	CODE_SG
SINC$. . . . . . . . . . . . . .	L NEAR 	13DA	CODE_SG
SINI0$ . . . . . . . . . . . . .	L NEAR 	1401	CODE_SG
SINI1$ . . . . . . . . . . . . .	L NEAR 	1411	CODE_SG
SINI2$ . . . . . . . . . . . . .	L NEAR 	1437	CODE_SG
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-11
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


SINIF$ . . . . . . . . . . . . .	L NEAR 	13FD	CODE_SG
SINIX$ . . . . . . . . . . . . .	L NEAR 	13EC	CODE_SG
SLS40. . . . . . . . . . . . . .	L BYTE 	0061	DATA_SG	Length =0019
SLS40T . . . . . . . . . . . . .	L WORD 	008B	DATA_SG
SLS80. . . . . . . . . . . . . .	L BYTE 	00E5	DATA_SG	Length =0033
SLS80T . . . . . . . . . . . . .	L WORD 	0137	DATA_SG
SLSTAB . . . . . . . . . . . . .	L WORD 	0051	DATA_SG
SLSTR. . . . . . . . . . . . . .	L WORD 	004D	DATA_SG
SLT40. . . . . . . . . . . . . .	L BYTE 	00A3	DATA_SG	Length =0019
SLT40T . . . . . . . . . . . . .	L WORD 	00CD	DATA_SG
SLT80. . . . . . . . . . . . . .	L BYTE 	014F	DATA_SG	Length =003C
SLT80T . . . . . . . . . . . . .	L WORD 	01A1	DATA_SG
SLTAB. . . . . . . . . . . . . .	L WORD 	004F	DATA_SG
SLTTAB . . . . . . . . . . . . .	L WORD 	0059	DATA_SG
SRBLKS . . . . . . . . . . . . .	N PROC	1484	CODE_SG	Length =0008
SRDRV. . . . . . . . . . . . . .	L BYTE 	023D	DATA_SG
SRPOS. . . . . . . . . . . . . .	L BYTE 	025E	DATA_SG
SRTXT0 . . . . . . . . . . . . .	L BYTE 	0208	DATA_SG
SRTXT1 . . . . . . . . . . . . .	L BYTE 	0220	DATA_SG
SRTXT2 . . . . . . . . . . . . .	L BYTE 	0241	DATA_SG
SRTXT3 . . . . . . . . . . . . .	L BYTE 	0262	DATA_SG
SRTXT4 . . . . . . . . . . . . .	L BYTE 	0284	DATA_SG
START. . . . . . . . . . . . . .	F PROC	0000	CODE_SG	Length =0018
START1 . . . . . . . . . . . . .	L NEAR 	10C5	CODE_SG
STATUS . . . . . . . . . . . . .	L WORD 	02CA	DATA_SG
STKBOT . . . . . . . . . . . . .	L WORD 	0200	STK_SG	Length =0100
STK_TOP. . . . . . . . . . . . .	L WORD 	0200	STK_SG
STR10$ . . . . . . . . . . . . .	L NEAR 	0FAF	CODE_SG
STR12$ . . . . . . . . . . . . .	L NEAR 	0FCF	CODE_SG
STR13$ . . . . . . . . . . . . .	L NEAR 	1019	CODE_SG
STR14$ . . . . . . . . . . . . .	L NEAR 	1030	CODE_SG
STR15$ . . . . . . . . . . . . .	L NEAR 	1040	CODE_SG
STR16$ . . . . . . . . . . . . .	L NEAR 	1094	CODE_SG
STR17$ . . . . . . . . . . . . .	L NEAR 	10B0	CODE_SG
STR5$. . . . . . . . . . . . . .	L NEAR 	0F70	CODE_SG
STR8$. . . . . . . . . . . . . .	L NEAR 	0F91	CODE_SG
STR9$. . . . . . . . . . . . . .	L NEAR 	0FA3	CODE_SG
SYSINI . . . . . . . . . . . . .	N PROC	13A6	CODE_SG	Length =0092
TIME . . . . . . . . . . . . . .	L DWORD	095E	DATA_SG
TIMEMD . . . . . . . . . . . . .	L WORD 	02DD	DATA_SG
TRKCNT . . . . . . . . . . . . .	L BYTE 	068B	DATA_SG
TS0$ . . . . . . . . . . . . . .	L NEAR 	0F27	CODE_SG
TS1$ . . . . . . . . . . . . . .	L NEAR 	0F46	CODE_SG
TS2$ . . . . . . . . . . . . . .	L NEAR 	0F53	CODE_SG
TSETUP . . . . . . . . . . . . .	N PROC	0F1A	CODE_SG	Length =0050
TWIDTH . . . . . . . . . . . . .	L WORD 	02D4	DATA_SG
TYPATR . . . . . . . . . . . . .	L BYTE 	0002	DATA_SG
USL1$. . . . . . . . . . . . . .	L NEAR 	02F4	CODE_SG
USLATR . . . . . . . . . . . . .	L BYTE 	0001	DATA_SG
USLLP$ . . . . . . . . . . . . .	L NEAR 	02BD	CODE_SG
USLMOD . . . . . . . . . . . . .	L BYTE 	004B	DATA_SG
USLN$. . . . . . . . . . . . . .	L NEAR 	02F0	CODE_SG
VOCBEG . . . . . . . . . . . . .	L WORD 	02F3	DATA_SG
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-12
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


VOCTAB . . . . . . . . . . . . .	L WORD 	02E3	DATA_SG
VWLEN. . . . . . . . . . . . . .	L WORD 	02EF	DATA_SG
VWORDS . . . . . . . . . . . . .	L WORD 	02F1	DATA_SG
WLP. . . . . . . . . . . . . . .	L NEAR 	1699	CODE_SG
WPCHK. . . . . . . . . . . . . .	N PROC	1527	CODE_SG	Length =003F
WPCHK1 . . . . . . . . . . . . .	L NEAR 	155F	CODE_SG
WRDOFF . . . . . . . . . . . . .	L WORD 	02C4	DATA_SG
WRDTAB . . . . . . . . . . . . .	L WORD 	02E9	DATA_SG
ZCHRS. . . . . . . . . . . . . .	L BYTE 	09ED	DATA_SG
ZEROOP . . . . . . . . . . . . .	L WORD 	0890	DATA_SG
ZIPBGN . . . . . . . . . . . . .	N PROC	0F6A	CODE_SG	Length =0149
ZLOCS. . . . . . . . . . . . . .	L WORD 	066D	DATA_SG
ZMVERS . . . . . . . . . . . . .	Number	0003	
ZORKID . . . . . . . . . . . . .	L WORD 	02DF	DATA_SG
ZPC1 . . . . . . . . . . . . . .	L WORD 	066F	DATA_SG
ZPC2 . . . . . . . . . . . . . .	L WORD 	0671	DATA_SG
ZSTK_TP. . . . . . . . . . . . .	L WORD 	0400	STK_SG
ZVERSN . . . . . . . . . . . . .	Number	0044	
ZWD1$. . . . . . . . . . . . . .	L NEAR 	0DEB	CODE_SG
ZWD2$. . . . . . . . . . . . . .	L NEAR 	0DF7	CODE_SG
ZWD3$. . . . . . . . . . . . . .	L NEAR 	0DFD	CODE_SG
ZWD4$. . . . . . . . . . . . . .	L NEAR 	0E0E	CODE_SG
ZWD5$. . . . . . . . . . . . . .	L NEAR 	0E33	CODE_SG
ZWD6$. . . . . . . . . . . . . .	L NEAR 	0E36	CODE_SG
ZWORD. . . . . . . . . . . . . .	N PROC	0DDF	CODE_SG	Length =0082
.CHR1$ . . . . . . . . . . . . .	L NEAR 	1880	CODE_SG
.CHRIN . . . . . . . . . . . . .	N PROC	1864	CODE_SG	Length =0023
.CHROUT. . . . . . . . . . . . .	N PROC	18A4	CODE_SG	Length =001E
.CR1$. . . . . . . . . . . . . .	L NEAR 	195F	CODE_SG
.CR2$. . . . . . . . . . . . . .	L NEAR 	1969	CODE_SG
.CRBT. . . . . . . . . . . . . .	N PROC	18DB	CODE_SG	Length =0015
.CRLF. . . . . . . . . . . . . .	N PROC	18F0	CODE_SG	Length =007F
.CRLF1 . . . . . . . . . . . . .	L NEAR 	1909	CODE_SG
.CRLFN . . . . . . . . . . . . .	L NEAR 	1914	CODE_SG
.GETMEM. . . . . . . . . . . . .	N PROC	1A0A	CODE_SG	Length =002A
.GETTM . . . . . . . . . . . . .	N PROC	1A34	CODE_SG	Length =0013
.GTM1$ . . . . . . . . . . . . .	L NEAR 	1A15	CODE_SG
.GTM2$ . . . . . . . . . . . . .	L NEAR 	1A33	CODE_SG
.GTMX$ . . . . . . . . . . . . .	L NEAR 	1A1F	CODE_SG
.PA1$. . . . . . . . . . . . . .	L NEAR 	1995	CODE_SG
.PA2$. . . . . . . . . . . . . .	L NEAR 	19AA	CODE_SG
.PA3$. . . . . . . . . . . . . .	L NEAR 	19AD	CODE_SG
.PR1$. . . . . . . . . . . . . .	L NEAR 	1972	CODE_SG
.PR2$. . . . . . . . . . . . . .	L NEAR 	1986	CODE_SG
.PR3$. . . . . . . . . . . . . .	L NEAR 	1989	CODE_SG
.PRINT . . . . . . . . . . . . .	N PROC	196F	CODE_SG	Length =001C
.PRINTA. . . . . . . . . . . . .	N PROC	198B	CODE_SG	Length =0027
.RD0$. . . . . . . . . . . . . .	L NEAR 	19E4	CODE_SG
.RD1$. . . . . . . . . . . . . .	L NEAR 	19E8	CODE_SG
.RD2$. . . . . . . . . . . . . .	L NEAR 	1A06	CODE_SG
.RDFL$ . . . . . . . . . . . . .	L NEAR 	1A05	CODE_SG
.RDWRT . . . . . . . . . . . . .	N PROC	19B2	CODE_SG	Length =0058
.RDX$. . . . . . . . . . . . . .	L NEAR 	19D3	CODE_SG
 The IBM Personal Computer MACRO Assembler 01-01-80    	PAGE	Symbols-13
ZIP	Z-LANGUAGE INTERPRETER	 	IBMPC VERSION


.SPACE . . . . . . . . . . . . .	N PROC	18C2	CODE_SG	Length =0019
.TTYOUT. . . . . . . . . . . . .	N PROC	1887	CODE_SG	Length =001D
.TYO1$ . . . . . . . . . . . . .	L NEAR 	189F	CODE_SG

Warning Severe
Errors	Errors 
0	0
