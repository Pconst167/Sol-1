	SUBTTL	PAGEIO
	PAGE

	;GET A GAME FILE BLOCK, BLOCK NUMBER IN AX, CORE LOCATION IN ES:BX
	PUBLIC	GETBLK
GETBLK	PROC
	PUSH	CX		;SAVE
	MOV	CX,1		;CALL GTBLKS FOR 1 BLOCK ONLY
	CALL	GTBLKS
	POP	CX		;RESTORE
	RET
GETBLK	ENDP


	;GET A SERIES OF GAME FILE BLOCKS,
	;FIRST BLOCK NUMBER IN AX, CORE LOCATION IN ES:BX # OF BLOCKS IN CX
; GTBLKS UNDERWENT A MAJOR OVERHAUL.  IT WAS CHANGED TO SUPPORT 2.0 FILE
; NAMES AND FILE HANDLES.  THE FIRST PASS OF THE OVERHAUL WAS TO SUPPORT
; FITTING THE WHOLE GAME INTO MEMORY.  THIS BASTARDIZATION OF THE ORIGINAL
; WAS FURTHER CONTORTED WHEN TRYING TO SUPPORT 128K AND LESS MEMORY CONFIG-
; URATIONS.
;
; THE ORIGINAL ARGUMENTS HAVE NOT BEEN LEFT WHOLLY IN TACT.  AX IS STILL THE
; FIRST BLOCK NUMBER AND CX CONTAINS THE NUMBER OF BYTES TO READ IF ALL OF
; THE GAME IS IN MEMORY OR BLOCKS IF THE GAME DOESN'T ALL FIT.  ES:BX NO
; LONGER HAS THE CORE LOCATION.  CALLS TO THIS PROCEDURE MAY STILL PUT THE
; CORE LOCATION IN BX BUT IT IS IGNORED.  CORE LOCATION IS CALCULATED ON THE
; FLY BASED ON THE ENTRY IN PAGTAB (WHICH IN TURN SETS THE SEGMENT IN WHICH
; THE READ IS DONE.)
;
; THE STARTING BLOCK NUMBER IS USED TO MOVE THE FILE PTR (2.0) FROM THE
; BEGINNING OF THE FILE TO THE PROPER GAME BLOCK.  
;
; IN THE CASE OF ALL OF THE GAME IN MEMORY, THE SEGMENT IS CHOSEN BASED ON
; THE PAGE'S INTENDED BUFFER INDICATED BY THE VARIABLE LPTAB.  BUFFER NUMBERS
; 128 AND ABOVE GO IN TO THE SECOND SEGMENT.  THE GAME IS READ IN IN THE 
; BEGINNING IN THREE OR FOUR READS AND THIS ROUTINE IS NOT TOUCHED AGAIN.
;
; IN THE CASE OF A SMALL MEMORY SYSTEM, THE SEGMENT TO READ INTO IS CHOSEN
; BASED ON LPTAB, CURSEG AND SEGEND (SEE GETPAG FOR EXPLANATION).
;
	PUBLIC	GTBLKS,GTBKI$,GTBLP,GETIT,GTBLKB,GTBOUT,GTB2,GTB3
GTBLKS	PROC
	MOV	DSKDIR,0	;READ MODE
	PUSH	AX
	MOV	AX,GAMHNDL	; (6) GET THIS HANDLE
	MOV	HANDLE,AX	; (6) INTO THE GENERAL HANDLE
	POP	AX		; (6) AND RESTORE THIS
GTBKI$:	PUSH	BP
	PUSH	DX
	PUSH	BX
	PUSH	SI
GTBLP:	MOV	BX,0
	MOV	DX,CX		; (6) SAVE NUMBER OF BLOCKS
	MOV	CX,9		; (6) MULTIPLY BY 512
GTBLP1:	SHL	DX,1		; (6) DO IT
	SHL	AX,1		; (6) CONVERT BLK# TO OFFSET
	PUSHF			; (A0) SAVE FACT OF CARRY OUT
	SHL	BX,1
	POPF			; (A0) ONLY ADD CARRYOUT FROM AX
	ADC	BX,0		; (6) DID WE CARRY OUT ABOVE
	LOOP	GTBLP1		; (A0) GET OFFSET INTO BX:DX
	MOV	CX,BX		; (A0) NOW CX:DX HAS OFFSET
	MOV	BX,HANDLE	; (6) GET FILE HANDLE
	MOV	SI,DX		; (6) SAVE NUMBER OF BYTES FOR READ
	TEST	SEEKF,1		; (6) SHOULD WE REALLY?
	JZ	NOSEEK
	MOV	DX,AX		; (6) GET LOW ORDER #BYTES FOR SEEK
	MOV	AH,CFSEEK
	MOV	AL,0		; (6) USE OFFSET FROM BEGINNING METHOD
	INT	21H		; (6) SEEK
NOSEEK:	MOV	DX,LPTAB	; (6) FIGURE OUT BUFFER NUMBER
	TEST	FITS,1		; (6) DO WE HAVE ALL THE GAME
	JNZ	NOFIX		; (6) IF NOT, FIX LPTAB (SCALE IT DOWN)
	CMP	DX,0		; (6) ARE WE JUST STARTING UP
	JZ	NOFIX
	SUB	DX,OFFSET PAGTAB	; (6) BASIFY THE TABLE NUMBER
	MOV	CL,TBLSHF	; (A0) DIVIDE TABLE ENTRY BY TABLE WIDTH
	SHR	DX,CL		; (6) DIVIDE TABLE ENTRY BY TABLE WIDTH(8)
	MOV	CL,9		; (6) DIVIDE BY 512
	CMP	CURSEG,0	; (A0) ARE WE IN SEG0????
	JNZ	NOFIX		; (6) SKIP PAGE ADDITION
	MOV	AX,PAGES	; (6) GET AMOUNT OF PRELOD
	SHR	AX,CL		; (6) AND SKIP THAT AMOUNT OF BUFFER SPC
	ADD	DX,AX		; (6) ADD THAT INTO BUFFER NUMBER
NOFIX:	MOV	CX,SI		; (6) RESTORE #BYTES TO READ
	MOV	AH,CRDRNDZ	; (6) READ RANDOM GAME RECORD
	CMP	DSKDIR,0	; (6) ARE WE READING?
	JZ	GTREAD
	MOV	AH,CWRRNDZ	; (6) NO, DO A WRITE INSTEAD
GTREAD:	TEST	FITS,1		; (6) IS BUFFERING CONTINUOUS
	JNZ	FDSEG0		; (A0) FIGURE BUFFER FROM DX
	CMP	CURSEG,0	; (A0) WHAT SEGMENT ARE WE IN
	JZ	GETIT		; (6) FUNCTION NORMALLY
	MOV	SI,SEGEND	; (6) GET SEGMENT ENDING POINT
	PUSH	CX		; (A0) SAVE NUMBER OF BYTES READ
	MOV	CL,TBLSHF	; (A0) GET TABLE WIDTH (SHIFTIFIED)
	SHR	SI,CL		; (6) TO USE AS AN INDEX INTO SEG1 
	POP	CX		; (A0) RESTORE #BYTES TO READ
	SUB	DX,SI		; (6) BASIFY BUFFER NUMBER FOR SEG1
FDSEG0:	MOV	SI,GAMESEG	; (A0) GET SEG0 ADDR
	TEST	FITS,1		; (A0) SEG1 IF NO FIT
	JNZ	FNDSEG		; (A0) GO DO THE MATH
	ADD	SI,1000H	; (A0) JUMP TO SEG 1
FNDSEG:	CMP	DX,128		; (A0) FIND SEG THAT IT IS IN
	JB	GTBLK2$		; (A0) READY FOR ACTION, GO...
	SUB	DX,128		; (A0) NOPE, TRY NEXT SEG
	ADD	SI,1000H	; (A0) SETUP FOR LOOP
	JMP	FNDSEG
GTBLK2$:PUSH	DS
	MOV	DS,SI			; (6) SET UP DS
	JMP	GTBLKB
GETIT:	PUSH	DS
	MOV	SI,ES
	MOV	DS,SI
GTBLKB:	PUSH	CX			; (6) SAVE NUMBER OF BLOCKS
	MOV	CL,9
	SHL	DX,CL			; (6) MAKE A NEW PAGE-PTR
	POP	CX			; (6) RESTORE COUNT OF BYTES
	INT	21H			; (6) CALL DOS
	CMP	AX,CX			; (6) SET FLAGS
	POP	DS
	MOV	SEEKF,1			; (6) RESET SEEK FLAG
GTBOUT:	POP	SI
	POP	BX
	POP	DX
	POP	BP
	RET
GTB2:	PUSH	AX			; (6) SAVE THIS
	MOV	AX,GAMHNDL		; (6) GET HANDLE
	CMP	HANDLE,AX		; (6) COMPARE THEM
	JE	GTB3
	STC
	JMP	GTBOUT

GTB3:	FATAL	FTL7
GTBLKS	ENDP
