   	PAGE
	STTL "--- HARDWARE EQUATES: CBM128 ---"


	; ---------
	; Zero page stuff
	; ---------

IOBUFF	EQU	$B00		; Disk IO buffer

SECTOR	EQU	3		; (BYTE) TARGET SECTOR
TRACK	EQU	SECTOR+1	; (BYTE) TARGET TRACK
TEMP	EQU	TRACK+1		; (BYTE) Temp variable
BLNUM	EQU	TEMP+1		; (3 BYTES) place to count blocks (in ascii)
INDEX	EQU	BLNUM+3		; index into rs-232 buffer
INCHAR	EQU	INDEX+1		; incoming character
CHECKSUM EQU	INCHAR+1	; whole word for checksum please
XSAVE	EQU	CHECKSUM+2	; where to save x,y
YSAVE	EQU	XSAVE+1		; for whatever reason
QUOT	EQU	YSAVE+1		; for divide word by 10
DIVWORD	EQU	QUOT+1		; (WORD) what we are dividing

	; -----------------
	; MONITOR VARIABLES
	; -----------------

WLEFT	EQU	$E6		; LEFT MARGIN (0)
WWIDTH	EQU	$E7		; RIGHT MARGIN (40 OR 80)
WTOP	EQU	$E5		; TOP LINE (0-23)
WBOTM	EQU	$E4		; BOTTOM LINE (1-24)
LINES	EQU	$ED		; # LINES ON SCREEN
COLMODE EQU	$D7		; WHAT COLUMN MODE ARE WE IN (40/80)
QUOTMOD	EQU	$F4		; QUOTES SENT TO SCREEN TURN ON STRANGE
				; MODE, THIS FLAG SET TO 0 SHOULD
				; TURN THAT MODE OFF

	; ---------
	; ZERO-PAGE
	; ---------

D6510	EQU	$00		; 6510 DATA DIRECTION REGISTER
R6510	EQU	$01		; 6510 I/O PORT
FAST	EQU	$02		; FAST-READ AVAILABLE FLAG
STKEY	EQU	$91		; STOP KEY FLAG
MSGFLG	EQU	$9D		; KERNAL MESSAGE CONTROL FLAG
TIME	EQU	$A2		; SYSTEM JIFFY TIMER
BLNSW	EQU	$CC		; CURSOR BLINK SWITCH
NDX	EQU	$D0		; # CHARS IN KEYBOARD BUFFER
SFDX	EQU	$D4		; CURRENT KEY PRESSED
LSTX	EQU	$D5		; LAST KEY PRESSED
TBLX	EQU	$EB		; CURRENT CURSOR ROW
PNTR	EQU	$EC		; CURSOR COLUMN IN LOGICAL LINE
RVS	EQU	$F3		; REVERSE CHARACTER FLAG
KEYTAB	EQU	$F5		; KEYBOARD DECODE TABLE VECTOR
MODE	EQU	$F7		; CHARSET MODE SWITCH

FDATA	EQU	$FB		; FAST-READ DATA BUFFER
FINDEX	EQU	$FC		; FAST-READ BUFFER INDEX
FASTEN	EQU	$FD		; FAST-READ ENABLED FLAG

	; -----------
	; PAGES 2 & 3
	; -----------

LBUFF	EQU	$0200		; 89-BYTE LINE BUFFER
KEYD	EQU	$0277		; KEYBOARD QUEUE
RPTFLG	EQU	$028A		; KEY REPEAT FLAG
SHFLAG	EQU	$028D		; SHIFT KEY FLAG
KEYLOG	EQU	$028F		; VECTOR TO KEY-TABLE SETUP ROUTINE
CINV	EQU	$0314		; SYSTEM 60HZ IRQ VECTOR
CBINV	EQU	$0316		; BRK INSTRUCTION VECTOR
NMINV	EQU	$0318		; NMI INTERRUPT VECTOR

	;--------
	; other pages
	;----------
RIDBE	EQU	$0A18		; RS-232 end of buffer
RIDBS	EQU	$0A19		; RS-232 start of buffer
RIBUFF	EQU	$0C00		; RS-232 receive buffer

	; -----
	; COLOR
	; -----

COLRAM	EQU	$D800		; COLOR RAM
EXTCOL	EQU	$D020		; BORDER COLOR
BGCOLO	EQU	$D021		; BACKGRND COLOR
FRCOLO	EQU	$F1		; FOREGRND COLOR REG

WHITE	EQU	$03
RED	EQU	$1C
LGREEN	EQU	$99
CYAN	EQU	$9F
LRED	EQU	$96
YELLOW	EQU	$9E
BLUE	EQU	$1F
DYELLOW	EQU	$95
DCYAN	EQU	$97

RVSON	EQU	$12		; reverse video on/off
RVSOFF	EQU	$92
UNDON	EQU	$03		; underline on/off
UNDOFF	EQU	$82
BLKON	EQU	$0F		; blink on/off
BLKOFF	EQU	$8F


	; --------------
	; MEMORY CONTROL
	; --------------

LCRA	EQU	$FF01
LCRB	EQU	$FF02

CR	EQU	$FF00		; MAIN CONFIGURATION REGISTER
PCRA	EQU	$D501
PCRB	EQU	$D502
MCR	EQU	$D505		; MODE CONFIG REG (6502/128)
RCR	EQU	$D506		; RAM CONFIG REG (SHARED/WHERE)
FASTER	EQU	$D030		; BIT 0 - 1 = 2 MHz speed

	; -------------------
	; KERNAL JUMP VECTORS
	; -------------------

FASTIO	EQU	$FF47		; FAST DATA I/O
CHKIN	EQU	$FFC6		; OPEN CHANNEL FOR INPUT
CHKOUT	EQU	$FFC9		; OPEN CHANNEL FOR OUTPUT
CHRIN	EQU	$FFCF		; INPUT CHARACTER FROM CHANNEL
CHROUT	EQU	$FFD2		; OUTPUT CHARACTER TO CHANNEL
CINT	EQU	$FF81		; INIT SCREEN EDITOR
CLALL	EQU	$FFE7		; CLOSE ALL CHANNELS & FILES
CLOSE	EQU	$FFC3		; CLOSE A FILE
CLRCHN	EQU	$FFCC		; CLEAR CHANNEL
GETIN	EQU	$FFE4		; GET CHAR FROM KEYBOARD QUEUE
IOINIT	EQU	$FF84		; INIT I/O
OPEN	EQU	$FFC0		; OPEN A FILE
PLOT	EQU	$FFF0		; READ/SET CURSOR POSITION
RAMTAS	EQU	$FF87		; INIT RAM
READST	EQU	$FFB7		; READ I/O STATUS
SCNKEY	EQU	$FF9F		; SCAN KEYBOARD
SETLFS	EQU	$FFBA		; SET FILE ATTRIBUTES
SETMSG	EQU	$FF90		; SET KERNAL MESSAGES
SETNAM	EQU	$FFBD		; SET FILENAME
SWAPPER	EQU	$FF5F		; SWAP TO ALTERNATE DISPLAY DEVICE
RESET	EQU	$FFFC		; do a reset

MSG	.MACRO	XMSG		; to print out a message

	LDX	#<XMSG|msg	; get LSB of message
	LDA	#>XMSG|msg	; and the MSB
	LDY	#XMSG|len	; and the length of the message
	JSR	DLINE		; now print out the whole thing
	.ENDM

	END

