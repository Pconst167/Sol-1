* ----------------------
* OPCOPYT
* ----------------------

* COPYT (COPY OR CLEAR A TABLE)

OPCOPYT	NOP			* ASK FOR ARGBLK [JUST TO FREE UP REGS]
	MOVE.L	A0,A2

	MOVE.W	ARG1(A2),D0
	CMP.W	ARG2(A2),D0
	BEQ	CPYTX8		* SAME, EXIT

	MOVE.W	ARG3(A2),D1	* CHECK LENGTH:
	BEQ	CPYTX8		*   ZERO, EXIT
	BGT.S	CPYTX1		* POSITIVE
	NEG.W	ARG3(A2)	* NEGATIVE, MAKE POSITIVE

CPYTX1	TST.W	ARG2(A2)	* DEST
	BEQ.S	CPYTX6		* IF ZERO, SPECIAL CASE
	TST.W	D1		* WAS LEN NEG?
	BLT.S	CPYTX4		* IF SO, DO /NOT/ CHECK FOR OVERLAP

***	MOVE.W	ARG1(A2),D0	* SRC
	CMP.W	ARG2(A2),D0	* ANY "FORWARD OVERLAP"?
	BHI.S	CPYTX4		* NO

	ADD.W	ARG3(A2),D0	* MAYBE, SRC END (+1)
	CMP.W	ARG2(A2),D0	* ANY "FORWARD OVERLAP"?
	BLS.S	CPYTX4		* NO

* "FORWARD OVERLAP" DOES EXIST, DO A REVERSE COPY

CPYTX2	MOVE.W	ARG2(A2),D0	* DEST
	ADD.W	ARG3(A2),D0	* END (+1)
	BSR	RELABS		* ABSOLUTIZE IT  [MUST BE PRELOAD]
	MOVE.L	A0,A1

	MOVE.W	ARG1(A2),D3	* SRC
	ADD.W	ARG3(A2),D3	* END (+1)

CPYTX3	SUBQ.W	#1,D3		* [PREDECREMENT]
	MOVE.W	D3,D0
	BSR	BSPLTB		* --> D0/D1 = BLK/OFF

	BSR	GETBYT		* --> D0/D1 = NEW BLK/OFF, D2 = DATA
	MOVE.B	D2,-(A1)	* [PREDECREMENT]
	SUBQ.W	#1,ARG3(A2)
	BNE.S	CPYTX3		* LOOP  [UNSIGNED TEST]
	RTS

* DO A NORMAL COPY

CPYTX4	MOVE.W	ARG2(A2),D0	* DEST
	BSR	RELABS		* ABSOLUTIZE IT  [MUST BE PRELOAD]
	MOVE.L	A0,A1

	MOVE.W	ARG1(A2),D0
	BSR	BSPLTB		* --> D0/D1 = BLK/OFF

CPYTX5	BSR	GETBYT		* --> D0/D1 = NEW BLK/OFF, D2 = DATA
	MOVE.B	D2,(A1)+
	SUBQ.W	#1,ARG3(A2)
	BNE.S	CPYTX5		* LOOP  [UNSIGNED TEST]
	RTS

* NO DEST, JUST CLEAR THE SOURCE TABLE

CPYTX6	MOVE.W	ARG1(A2),D0	* SRC
	BSR	RELABS		* ABSOLUTIZE IT  [MUST BE PRELOAD]
CPYTX7	CLR.B	(A0)+
	SUBQ.W	#1,ARG3(A2)
	BNE.S	CPYTX7		* LOOP  [UNSIGNED TEST]
CPYTX8	RTS

* ----------------------
* OPPRNT
* ----------------------

* PRINTT (DISPLAY A TABLE IN BLOCK FORMAT)

OPPRNT	NOP			* USE AN ARGUMENT BLOCK
	LEA	DEFBLK(A6),A1	* DEFAULT ARGBLK
	MOVE.W	#3,(A1)		* 3 ARGS MAX
	MOVE.W	#1,ARG3(A1)	* DEFAULT # LINES = 1
	BSR	SETDEF		* SET UP DEFAULT
	MOVE.L	A0,A2

	TST.W	ARG2(A2)
	BLE.S	PRNTX3		* BAD COL COUNT, EXIT
	TST.W	ARG3(A2)
	BLE.S	PRNTX3		* BAD ROW COUNT, EXIT

	BSR	PUTLIN		* MAKE SURE BUFFER IS EMPTY
	MOVE.W	_cur_column,A1	* REMEMBER INITIAL CURSOR COLUMN

* WE NOW USE VIRTUAL MEMORY CALLS TO FETCH TABLE DATA

PRNTX1	MOVE.W	ARG2(A2),D3	* COLS PER ROW
	MOVE.W	ARG1(A2),D0	* TABLE BASE / START OF CURRENT ROW
	BSR	BSPLTB		* --> D0/D1 = BLK/OFF

PRNTX2	BSR	GETBYT		* --> D0/D1 = NEW BLK/OFF, D2 = CHAR
	EXG	D0,D2
	BSR	PUTCHR		* QUEUE/SCRIPT CHAR, ETC
	EXG	D0,D2

	SUBQ.W	#1,D3		* ANY MORE COLS IN THIS ROW?
	BGT.S	PRNTX2		* YES, LOOP
	
* BEFORE, WE SAVED THE CURRENT FONT AND ENABLED FONT1, TO BE SURE THE CR 
* WAS CORRECTLY INTERPRETED.  BUT (IN OTHER CONTEXTS) IT STILL GOT 
* MISINTERPRETED.  NOWADAYS, #13 ALWAYS MEANS CR, REGARDLESS OF CONTEXT 
* (SEE CharOut).  A BETTER SOLUTION WILL REQUIRE SOME STICKY RETHINKING.

	SUBQ.W	#1,ARG3(A2)	* ANY MORE ROWS IN TABLE?
	BEQ.S	PRNTX3		* NO, DONE

	MOVE.W	_w0font,-(SP)	* YES
	MOVE.W	_w1font,-(SP)
	MOVE.W	#1,_w0font	* MAKE SURE WE ARE USING ASCII (FONT 1)!
	MOVE.W	#1,_w1font

	BSR	PUTNEW		* YES, CR, SCROLL IF NEEDED  [PUTCHR #13]
	MOVE.W	(SP)+,_w1font	* RESTORE PREVIOUS VALS
	MOVE.W	(SP)+,_w0font

	MOVE.W	A1,_cur_column	* AND RESET COLUMN TO ORIGINAL VALUE

	MOVE.W	ARG2(A2),D0
	ADD.W	D0,ARG1(A2)	* START OF NEXT LINE
	BRA.S	PRNTX1		* LOOP 
PRNTX3	RTS
