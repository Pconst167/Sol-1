  Wed Jun  7 1989 12:04                                                                                                  Page    1

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- OBJECT & PROPERTY HANDLERS ---"




               2500 A.D. 6502 Macro Assembler  -  Version 4.01a
               ------------------------------------------------

                       Input  Filename : YZIP.asm
                       Output Filename : YZIP.obj


    1                      		; --------------------------
    2                      		; YZIP
    3                      		; Z-CODE INTERPRETER PROGRAM
    4                      		; FOR APPLE ][e/][c/][gs
    5                      		; --------------------------
    6                      	
    7                      		; INFOCOM, INC.
    8                      		; 125 CAMBRIDGEPARK DRIVE
    9                      		; CAMBRIDGE, MA 02140
   10                      	
   11                      		; COMPANY PRIVATE -- NOT FOR DISTRIBUTION
   12                      	
   13                      		PL	50000		; PAGE LENGTH OF PRINTER
   14                      	
   15          0000        	DEBUG	EQU	0	; ASSEMBLY FLAG FOR DEBUGGER (1 = YES)
   16          0000        	CHECKSUM EQU 	0	; == 1 for generating save/restore checksum
   17                      	
   18                      	 	; -----------
   19                      		; ERROR CODES
   20                      		; -----------
   21                      	
   22                      		; 00 -- INSUFFICIENT RAM
   23                      		; 01 -- ILLEGAL X-OP
   24                      		; 02 -- ILLEGAL 0-OP
   25                      		; 03 -- ILLEGAL 1-OP
   26                      		; 04 -- ILLEGAL 2-OP
   27                      		; 05 -- Z-STACK UNDERFLOW
   28                      		; 06 -- Z-STACK OVERFLOW
   29                      		; 07 -- ILLEGAL PROPERTY LENGTH (GETP)
   30                      		; 08 -- DIVISION BY ZERO
   31                      		; 09 -- ILLEGAL ARGUMENT COUNT (EQUAL?)
   32                      		; 10 -- ILLEGAL PROPERTY ID (PUTP)
   33                      		; 11 -- ILLEGAL PROPERTY LENGTH (PUTP)
   34                      		; 12 -- DISK ADDRESS OUT OF RANGE
   35                      		; 13 -- IMPURE CODE TOO LARGE (BM 1/20/86)
   36                      		; 14 -- DRIVE ACCESS
   37                      		; 15 -- NOT AN EZIP GAME
   38                      		; 16 -- ILLEGAL EXTENDED RANGE X-OP
   39                      		; 17 -- BAD VIRTUAL PAGE
   40                      		; 18 -- SETPC NOT PRELOADED
   41                      		; 19 -- PREVIOUS (SPC/FPC) NOT POSSIBLE
   42                      		; 20 -- PICTURE NOT FOUND
   43                      	        ; 21 -- ZERO OBJECT TO BE REMOVED
   44                      		; 22 -- OBJECT TOO BIG (ZLOC)
   45                      		; 23 -- Bad read: Read != Asked for
   46                      		; 24 -- Bad read: Retry 1 != Retry 2
   47                      		; 25 -- Clear of zero height/width window
   48   0000               		
   49   0000               		TITLE	"APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
   50   0000               		INCLUDE 	ZIP.EQU
   51   0000               		STTL	"--- YZIP EQUATES ---"
   52                      		PAGE 
  Wed Jun  7 1989 12:04                                                                                                  Page    2

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- YZIP EQUATES ---"

   53                      	
   54          000D        	VERSID	EQU	13	; VERSION OF INTERPRETER
   55                      				; See file "versions" for complete descriptions
   56                      	
   57          00FF        	TRUE	EQU	$FF	
   58          0000        	FALSE	EQU	0	
   59                      	
   60                      	; ---------------------
   61                      	; Segment table equates
   62                      	; ---------------------
   63          0000        	SGTDISKS EQU	0		; number of disks
   64          0002        	SGTPAD	EQU	SGTDISKS+2	; just some extra room
   65          0012        	SGTCHKS1 EQU	SGTPAD+16	; Checksum for disk 1 (PRELOAD)
   66          0014        	SGTPICOF1 EQU	SGTCHKS1+2	; N/A
   67          0016        	SGTSEG1 EQU	SGTPICOF1+2	; # of segments
   68          0018        	SGTGPOF1 EQU    SGTSEG1+2       ; Global Picture Directory
   69          001A        	SGTTBLS	EQU	SGTGPOF1+2	; Start of table preload (should be 0)
   70          001C        	SGTTBLE	EQU	SGTTBLS+2	; Last page of table preload
   71          001E        	SGTTBLX	EQU	SGTTBLE+2	; N/A
   72          0020        	SGTFUNS	EQU	SGTTBLX+2	; First page of function preload
   73          0022        	SGTFUNE	EQU	SGTFUNS+2	; End page of function preload
   74          0024        	SGTFUNX	EQU	SGTFUNE+2	; N/A
   75          0026        	SGTDSK	EQU	SGTFUNX+2	; Actual start of disk segment tables
   76                      	
   77          0000        	SGTCHKS EQU	0	; check sum for file
   78          0002        	SGTPICOF EQU	2	; picture data offset
   79          0004        	SGTNSEG	EQU	4	; # of segments in this list
   80          0006        	SGTGPOF EQU     6       ; Global Directory Offset 
   81          0008        	SGTSEG	EQU	8	; start of segments
   82                      	; ---------------------
   83                      	; Z-CODE HEADER OFFSETS
   84                      	; ---------------------
   85                      	
   86          0000        	ZVERS	EQU	0	; VERSION BYTE
   87          0001        	ZMODE	EQU	1	; MODE SELECT BYTE
   88          0002        	ZID	EQU	2	; GAME ID WORD
   89          0004        	ZENDLD	EQU	4	; # OF QUADWORDS ON SIDE 1 OF DISK
   90          0006        	ZGO	EQU	6	; EXECUTION ADDRESS
   91          0008        	ZVOCAB	EQU	8	; START OF VOCABULARY TABLE
   92          000A        	ZOBJEC	EQU	10	; START OF OBJECT TABLE
   93          000C        	ZGLOBAL	EQU	12	; START OF GLOBAL VARIABLE TABLE
   94          000E        	ZPURBT	EQU	14	; START OF "PURE" Z-CODE
   95          0010        	ZFLAGS	EQU	16	; FLAG WORD
   96          0012        	ZSERIA	EQU	18	; 3-WORD SERIAL NUMBER
   97          0018        	ZFWORD	EQU	24	; START OF FWORDS TABLE
   98          001A        	ZLENTH	EQU	26	; LENGTH OF Z-PROGRAM IN WORDS
   99          001C        	ZCHKSM	EQU	28	; Z-CODE CHECKSUM WORD
  100          001E        	ZINTWD	EQU	30	; INTERPRETER ID WORD (SUPPLIED BY EZIP)
  101          0020        	ZSCRWD	EQU	32	; SCREEN PARAMETER WORD ( "     "   "  )
  102          0022        	ZHWRD	EQU	34	; DISPLAY WIDTH IN PIXELS
  103          0024        	ZVWRD	EQU	36	; DISPLAY HEIGHT IN PIXELS
  104          0026        	ZFWRD	EQU	38	; FONT HEIGHT, FONT WIDTH
  105          0028        	ZFOFF	EQU	40	; FUNCTION OFFSET
  106          002A        	ZSOFF	EQU	42	; STRING OFFSET
  107          002C        	ZCLRWD	EQU	44	; FORGROUND COLOR, BACKGROUND COLOR
  108          002E        	ZTCHAR	EQU	46	; POINTER TO TBL OF TERMINATING CHARS
  109          0030        	ZTWIDTH	EQU	48	; Running counter for table output char width
  110          0032        	ZCRFUNC	EQU	50	; FUNCTION FOR CARRIAGE RETURNS
  111          0034        	ZCHRSET	EQU	52	; POINTER TO CHAR SET TBL
  112          0036        	ZEXTAB	EQU	54	; Points to extension table, if needed
  113                      	;
  114                      	; Extension table offsets
  115                      	;
  116          0000        	ZEXTLEN	EQU	0	; Length of extension table
  117          0002        	ZMSLOCX	EQU	2	; x location of mouse
  118          0004        	ZMSLOCY	EQU	4	; y location of mouse
  119          0006        	ZMSETBL	EQU	6	; MOUSE TBL CHANGE WORD
  120          0008        	ZMSEDIR	EQU	8	; DIRECTION MENU
  121          000A        	ZMSEINV	EQU	10	; INVENTORY MENU
  122          000C        	ZMSEVRB	EQU	12	; FREQUENT VERB MENU
  123          000E        	ZMSEWRD	EQU	14	; FREQUENT WORD MENU
  124          0010        	ZBUTTN	EQU	16	; BUTTON HANDLER
  125          0012        	ZJOYST	EQU	18	; JOYSTICK HANDLER
  126          0014        	ZBSTAT	EQU	20	; BUTTON STATUS
  127          0016        	ZJSTAT	EQU	22	; JOYSTICK STATUS
  Wed Jun  7 1989 12:04                                                                                                  Page    3

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- YZIP EQUATES ---"

  128                      	;
  129                      	; ZFLAGS values
  130                      	;
  131          0001        	FSCRI	EQU	$01	; scripting?
  132          0002        	FMONO	EQU	$02	; mono spaced font?
  133          0004        	FSTAT	EQU	$04	; status line refresh?
  134          0008        	FDISP	EQU	$08	; uses DISPLAY operations?
  135          0010        	FUNDO	EQU	$10	; uses UNDO?
  136          0020        	FMOUS	EQU	$20	; uses mouse?
  137          0040        	FCOLO	EQU	$40	; uses color?
  138          0080        	FMENU	EQU	$80	; uses menus?
  139                      	;---------------
  140                      	; Picture data
  141                      	;---------------
  142                      	;=== DATA HEADER ===
  143          0000        	PHFID	EQU	0		; File ID
  144          0001        	PHFLG	EQU	PHFID+1		; Flags
  145          0002        	PHHUFF	EQU	PHFLG+1		; Pointer to Huffman data
  146          0004        	PHNLD	EQU	PHHUFF+2	; # entries in local directory
  147          0006        	PHNGD	EQU	PHNLD+2		; # entries in global directory
  148          0008        	PHDSIZE	EQU	PHNGD+2		; Local directory entry size
  149          000A        	PHCHKS	EQU	PHDSIZE+2	; File Checksum
  150          000C        	PHFVERS	EQU	PHCHKS+2	; File Version (N/A)
  151          000E        	PHEXTRA	EQU	PHFVERS+2	; Extra room for getting fatter
  152          0010        	PHSIZE	EQU	16		; 16 bytes is header size
  153                      	;=== DATA HEADER FLAGS ===
  154          0001        	PHFGD	EQU	$1		; data has global directory
  155          0002        	PHFHUFF	EQU	$2		; Huffman encoded pictures
  156          0004        	PHFHUFF1 EQU	$4		; All pictures use same Huff tree
  157          0008        	PHFPAL	EQU	$8		; No pallette information
  158                      	;=== LOCAL DIRECTORY ===
  159          0000        	PLDID	EQU	0		; Picture ID
  160          0002        	PLDWID	EQU	PLDID+2		; Picture Width
  161          0003        	PLDHGHT	EQU	PLDWID+1	; Picture Height
  162          0004        	PLDFLG	EQU	PLDHGHT+1	; Flags
  163          0005        	PLDPTR	EQU	PLDFLG+1	; Pointer to picture data
  164          0008        	PLDSIZE	EQU	PLDPTR+3	; size of local directory entry
  165                      	
  166   0000               		END
  167                      	
  168   0000               		INCLUDE		ZERO.EQU
  169   0000               		STTL	"--- ZERO PAGE VARIABLES ---"
  170                      		PAGE 
  Wed Jun  7 1989 12:04                                                                                                  Page    4

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- ZERO PAGE VARIABLES ---"

  171                      	
  172          0000        	SCRCX	EQU	0		; CURSOR HORIZONTAL
  173          0001        	SCRCY	EQU	SCRCX+1		; CURSOR VERTICAL
  174          0002        	SCRBTM	EQU	SCRCY+1		; first line outside current window
  175          0003        	MAXLINES EQU	SCRBTM+1	; maximum number of lines in window
  176          0004        	LEFTMRG	EQU	MAXLINES+1	; left edge + left margin in current window
  177          0005        	WINDOW	EQU	LEFTMRG+1	; (WORD) address of current window structure
  178          0007        	LINE_X  EQU     WINDOW+2        ; (WORD) width of line counter
  179          0009        	CC_OFF  EQU     LINE_X+2        ; save offset for char drawing
  180          000A        	CLSLEFT	EQU	CC_OFF+1	; screen limits for CLS code
  181          000B        	CLSTOP	EQU	CLSLEFT+1	; top of screen
  182          000C        	CLSWIDTH EQU	CLSTOP+1	; # of columns 
  183          000D        	CLSHEIGHT EQU	CLSWIDTH+1	; # of lines
  184                      	;
  185                      	; some variables for all the screen positioning code
  186                      	;
  187          000E        	NY_DATA	EQU	CLSHEIGHT+1	; place for GET/PUT_NYBBLE to use
  188          000F        	CH_OFFSET EQU	NY_DATA+1	; offset into char data table
  189          0010        	DATALOOP EQU	CH_OFFSET+1 	; loop counter for byte works
  190          0011        	BITOFF	EQU	DATALOOP+1	; bit offset into screen byte
  191          0012        	CH_DATA	EQU	BITOFF+1	; actual char data being worked on
  192          0013        	SCR_DATA EQU	CH_DATA+1	; screen byte being worked on
  193          0014        	SH_LOOP	EQU	SCR_DATA+1	; loop counter for bit shifting
  194          0015        	SCROLLY	EQU	SH_LOOP+1	; save spot for y pos when scrolling
  195          0016        	RETRIES EQU	SCROLLY+1	; (BYTE) Machine ID
  196          0017        	CHRMAX	EQU	RETRIES+1	; (BYTE) # CHARS CAN INPUT FROM KEYBOARD
  197          0018        	SCLLINES EQU	CHRMAX+1	; (BYTE) how many lines to scroll
  198          0019        	FMTTBL	EQU	SCLLINES+1	; (BYTE) flag to show formatted table output
  199          001A        	STMASK	EQU	FMTTBL+1	; (BYTE) Mask to use on first byte of CLS
  200          001B        	ENDMASK	EQU	STMASK+1	; (BYTE) Mask to use on last byte of CLS
  201          001C        	CHPTR	EQU	ENDMASK+1	; (WORD) pointer to char data
  202          001C        	SCOFF	EQU	CHPTR		;(BYTE) Offset used by scroll
  203          001D        	SCLDIR	EQU	CHPTR+1		;(BYTE) Direction of scroll - >0 up, <0 down
  204          001E        	DSEGS	EQU	CHPTR+2 	; (WORD) Pointer to current disk's segments
  205                      	;WIDE_FLAG EQU   SCOFF+1         ; (BYTE) <> 0 if 16 bytes in char data
  206                      	;DSEGS	EQU	WIDE_FLAG+1	; (WORD) Pointer to current disk's segments
  207          0020        	LASTWV	EQU	DSEGS+2		; last of the WINDOW variables
  208                      	
  209          0050        	ZEROPG	EQU	$50		; FIRST FREE Z-PAGE LOCATION
  210                      	;
  211                      	; these are first, cuz ZBOOT inits them so we don't want to clear them
  212                      	; at ZBEGIN warm start
  213                      	;
  214          0050        	GLOBAL	EQU	ZEROPG		; (Relative Addr.) GLOBAL VARIABLE POINTER
  215          0052        	VOCAB	EQU	GLOBAL+2	; (ADDRESS) Vocab table pointer
  216          0055        	FWORDS	EQU	VOCAB+3		; (ADDRESS) F-WORDS TABLE POINTER
  217          0058        	MOUSEF	EQU	FWORDS+3	; (BYTE) ==-1/1 if we have mouse/joystick
  218          0059        	INFODOS EQU     MOUSEF+1        ; (WORD) if <>0, then pointer to D2SEG
  219          005B        	FUNOFF	EQU	INFODOS+2	; (ADDRESS) Function Offset (ZFOFF*8)
  220          005B        	FOFFH	EQU	FUNOFF		; (BYTE) Hi part 
  221          005C        	FOFFM	EQU	FUNOFF+1	; (BYTE) Middle part
  222          005D        	FOFFL	EQU	FUNOFF+2	; (BYTE) Lo part
  223          005E        	STROFF	EQU	FUNOFF+3	; (ADDRESS) String Offset (ZSOFF*8)
  224          005E        	SOFFH	EQU	STROFF		; (BYTE) Hi part 
  225          005F        	SOFFM	EQU	STROFF+1	; (BYTE) Middle part
  226          0060        	SOFFL	EQU	STROFF+2	; (BYTE) Lo part
  227                      	;
  228                      	; Beginning of warm start zeroing
  229                      	;
  230          0061        	OPCODE	EQU	STROFF+3	; (BYTE) CURRENT OPCODE
  231          0062        	NARGS	EQU	OPCODE+1	; (BYTE) # ARGUMENTS
  232          0063        	ARG1	EQU	OPCODE+2	; (WORD) ARGUMENT #1
  233          0065        	ARG2	EQU	OPCODE+4	; (WORD) ARGUMENT #2
  234          0067        	ARG3	EQU	OPCODE+6	; (WORD) ARGUMENT #3
  235          0069        	ARG4	EQU	OPCODE+8	; (WORD) ARGUMENT #4
  236          006B        	ARG5	EQU	OPCODE+10	; (WORD)
  237          006D        	ARG6	EQU	OPCODE+12	; (WORD)
  238          006F        	ARG7	EQU	OPCODE+14	; (WORD)
  239          0071        	ARG8	EQU	OPCODE+16	; (WORD)
  240          0073        	ABYTE	EQU	OPCODE+18	; (BYTE) X-OP ARGUMENT BYTE
  241          0074        	BBYTE	EQU	OPCODE+19	; (BYTE) XCALL ARG BYTE (EZIP)
  242          0075        	ADEX	EQU	OPCODE+20	; (BYTE) X-OP ARGUMENT INDEX
  243          0076        	VALUE	EQU	OPCODE+21	; (WORD) VALUE RETURN REGISTER
  244          0078        	I	EQU	VALUE+2		; (WORD) GEN-PURPOSE REGISTER #1
  245          007A        	J	EQU	VALUE+4		; (WORD) GEN-PURPOSE REGISTER #2
  Wed Jun  7 1989 12:04                                                                                                  Page    5

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- ZERO PAGE VARIABLES ---"

  246          007C        	K	EQU	VALUE+6		; (WORD) GEN-PURPOSE REGISTER #3
  247          007E        	L	EQU	VALUE+8		; (WORD) GEN-PURPOSE REGISTER #4
  248          0080        	ZPC	EQU	VALUE+10	; (3 BYTES) ZIP PROGRAM COUNTER
  249          0080        	ZPCL	EQU	ZPC		; (BYTE) <8 BITS OF [ZPC]
  250          0081        	ZPCM	EQU	ZPC+1		; (BYTE) MIDDLE 8 BITS OF [ZPC]
  251          0082        	ZPCH	EQU	ZPC+2		; (BYTE) >BIT OF [ZPC]
  252          0083        	ZPCPNT	EQU	ZPC+3		; (3 BYTES) ABS POINTER TO CURRENT Z-PAGE
  253          0083        	ZPNTL	EQU	ZPCPNT		; FIRST 2 BYTES = SAME AS FOR ZIP (EZIP)
  254          0084        	ZPNTH	EQU	ZPCPNT+1	; (BYTE)
  255          0085        	ZPCBNK	EQU	ZPCPNT+2	; (BYTE) INDICATES AUXILIARY MEMORY
  256          0086        	MPC	EQU	ZPCPNT+3	; (3 BYTES) MEMORY PROGRAM COUNTER
  257          0086        	MPCL	EQU	MPC		; (BYTE) <8 BITS OF [MPC]
  258          0087        	MPCM	EQU	MPC+1		; (BYTE) MIDDLE 8 BITS OF [MPC]
  259          0088        	MPCH	EQU	MPC+2		; (BYTE) >BIT OF [MPC]
  260          0089        	MPCPNT	EQU	MPC+3		; (3 BYTES) ABS POINTER TO CURRENT M-PAGE
  261          0089        	MPNTL	EQU	MPCPNT		; FIRST 2 BYTES = SAME AS FOR ZIP (EZIP)
  262          008A        	MPNTH	EQU	MPCPNT+1	; (BYTE)
  263          008B        	MPCBNK	EQU	MPCPNT+2	; (BYTE) INDICATES AUXILIARY MEMORY
  264          008C        	FPC	EQU	MPCBNK+1	; (3 Bytes) Fetch pointer 
  265          008C        	FPCL	EQU	FPC		; (BYTE) Low part
  266          008D        	FPCH	EQU	FPCL+1		; (BYTE) High Part
  267          008E        	FPCBNK	EQU	FPCH+1		; (BYTE) Bank part (0-Main, 1-Aux)
  268          008F        	SPC	EQU	FPCBNK+1	; (3 Bytes) Fetch pointer 
  269          008F        	SPCL	EQU	SPC		; (BYTE) Low part
  270          0090        	SPCH	EQU	SPCL+1		; (BYTE) High Part
  271          0091        	SPCBNK	EQU	SPCH+1		; (BYTE) Bank part (0-Main, 1-Aux)
  272                      	
  273                      	; Z-STRING MANIPULATION VARIABLES
  274                      	
  275          0092        	LINLEN	EQU	SPCBNK+1	; (BYTE) LENGTH OF CURRENT LINE
  276          0093        	SOURCE	EQU	LINLEN+1	; (BYTE) counter for read
  277          0094        	WRDLEN	EQU	SOURCE+1	; (BYTE) LENGTH OF CURRENT WORD
  278          0095        	ESIZE	EQU	WRDLEN+1	; (BYTE) SIZE OF VOCAB TABLE ENTRIES
  279          0096        	PSET	EQU	ESIZE+1		; (BYTE) PERMANENT CHARSET
  280          0097        	TSET	EQU	PSET+1		; (BYTE) TEMPORARY CHARSET
  281          0098        	ZCHAR	EQU	TSET+1		; (BYTE) CURRENT Z-CHAR
  282          0099        	OFFSET	EQU	ZCHAR+1		; (BYTE) F-WORD TABLE OFFSET
  283          009A        	ZFLAG	EQU	OFFSET+1	; (BYTE) Z-WORD ACCESS FLAG
  284          009B        	ZWORD	EQU	ZFLAG+1		; (WORD) CURRENT Z-WORD
  285          009D        	CONCNT	EQU	ZWORD+2		; (BYTE) Z-STRING SOURCE COUNTER
  286          009E        	CONIN	EQU	CONCNT+1	; (BYTE) CONVERSION SOURCE INDEX
  287          009F        	CONOUT	EQU	CONIN+1		; (BYTE) CONVERSION DEST INDEX
  288          00A0        	DIRTBL	EQU	CONOUT+1	; (WORD) CONTAINS TBLE TO STORE CHARS TO
  289          00A2        	XSIZE	EQU	DIRTBL+2	; (WORD) SCREEN WIDTH FOR TESTS
  290          00A4        	RAND    EQU     XSIZE+2         ; (WORD) Random number offset
  291          00A6        	CURWIN	EQU	RAND+2		; (BYTE) WHICH WINDOW TO WRITE IN
  292          00A7        	LENGTH	EQU	CURWIN+1	; (WORD) CHAR POSITION ON THE SCREEN
  293          00A9        	CHRCNT	EQU	LENGTH+2	; (BYTE) CHAR POSITION IN [LBUFF]
  294          00AA        	SCRIPT	EQU	CHRCNT+1	; (BYTE) SCRIPT ENABLE FLAG
  295          00AB        	LINCNT	EQU	SCRIPT+1	; (BYTE) LINE COUNTER
  296          00AC        	IOCHAR	EQU	LINCNT+1	; (BYTE) CHARACTER BUFFER
  297          00AD        	COLORP	EQU	IOCHAR+1	; (WORD) Pointer to current background color
  298          00AF        	ZSP	EQU	COLORP+2	; (WORD) Z Stack
  299          00B1        	SCREENF	EQU	ZSP+2		; (BYTE) DIROUT FLAG FOR SCREEN OUTPUT
  300          00B2        	TABLEF	EQU	SCREENF+1	; (BYTE) DIROUT FLAG FOR TABLE OUTPUT
  301          00B3        	VOCEND	EQU	TABLEF+1	; (3 BYTES) HOLDS MPC IN VOCAB SEARCH
  302          00B6        	DBUFF	EQU	VOCEND+3	; (WORD) RAM PG TO ACCESS (LSB = 0)
  303          00B8        	DSKBNK	EQU	DBUFF+2		; (BYTE) MAIN/AUX bank
  304          00B9        	ALLFLG	EQU	DSKBNK+1	; (BYTE) IF =1 ALL FCN KEYS (>127) ARE TCHARS
  305          00BA        	UNDFLG	EQU	ALLFLG+1	; (BYTE) Underlining flag
  306          00BB        	INVFLG	EQU	UNDFLG+1	; (BYTE) Inverse flag
  307          00BC        	MEMPAGE	EQU	INVFLG+1	; (BYTE) Save spot for XPAGING stuff
  308          00BD        	CPY_COUNT EQU	MEMPAGE+1	; (BYTE) Number of bytes for copy line
  309          00BE        	TBLHEIGHT EQU	CPY_COUNT+1	;(BYTE) Number of lines in printing table
  310          00BF        	TBLWIDTH EQU	TBLHEIGHT+1	;(BYTE) Number of bytes per line
  311          00C0        	TBLCNT	EQU	TBLWIDTH+1	;(BYTE) Counter for table printing
  312          00C1        	FONTFLG	EQU	TBLCNT+1	;(BYTE) Which font (!=0 is width)
  313          00C2        	TBLPUR	EQU	FONTFLG+1	;(BYTE) first pure table page
  314          00C3        	FUNPRE	EQU	TBLPUR+1	;(BYTE) first preloaded function page
  315          00C4        	FUNPUR	EQU	FUNPRE+1	;(BYTE)	first pure function page
  316          00C5        	FUNPGE	EQU	FUNPUR+1	;(BYTE) -number to get function preload page
  317          00C6        	DELAY_COUNTER EQU FUNPGE+1	;(BYTE) counter for delay loop
  318                      	;
  319                      	; some char-to-screen variables
  320                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page    6

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- ZERO PAGE VARIABLES ---"

  321          00C7        	CHAR_D1	EQU	DELAY_COUNTER+1	; (BYTE) character data, part 1
  322          00C8        	CHAR_D2	EQU	CHAR_D1+1	; (BYTE) char data, part 2
  323          00C9        	CW	EQU	CHAR_D2+1	; (BYTE) width of the character
  324          00CA        	CLKCTR	EQU	CW+1		; (BYTE) counter for mouse clicking
  325          00CB        	MSX	EQU	CLKCTR+1	; (BYTE) mouse cursor X
  326          00CC        	MSY	EQU	MSX+1		; (BYTE) mouse cursor Y
  327          00CD        	CURRENT	EQU	MSY+1		; (BYTE) current paging bufer
  328                      	;CURSOR_OFF EQU  CURRENT+1       ; (BYTE) ==1 if "don't show the blinking cursor"
  329          00CE        	MSTBL	EQU	CURRENT+1	; (ADDRESS) pointer to extension table
  330          00D1        	LASTZP	EQU	MSTBL+3		; just checking
  331                      	;
  332                      	; these routines are in non-swapped memory
  333                      	;
  334          00D1        	ZERO_FB	EQU	LASTZP		; put fetch byte routine in at end of ZP
  335          00DC        	ZERO_ZF	EQU	ZERO_FB+11	; and ZPCPNT fetch after that
  336          00E5        	ZERO_MF	EQU	ZERO_ZF+9	; and MPCPNT fetch after that
  337          00EE        	SAVE_DATA EQU	ZERO_MF+9	; copy data from DBUFF to IOBUFF routine
  338                      	;
  339                      	; and just to check the end
  340                      	;
  341          00FF        	ZEE_END EQU	SAVE_DATA+17	; should be == 100
  342                      	
  343   0000               		END
  344                      	
  345   0000               		INCLUDE		PRODOS.EQU
  346   0000               		STTL	"--- ProDOS EQUATES ---"
  347                      		PAGE 
  Wed Jun  7 1989 12:04                                                                                                  Page    7

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- ProDOS EQUATES ---"

  348                      	
  349                      	;
  350                      	; some parameter structures
  351                      	;
  352          0000        	OPEN_PARM	EQU	0
  353          0000        	OP_PCOUNT	EQU	OPEN_PARM	; must be 3 for open
  354          0001        	OP_PATHNAME	EQU	OP_PCOUNT+1	; address of pathname
  355          0003        	OP_FILEBUFF	EQU	OP_PATHNAME+2	; address of file data buffer
  356          0005        	OP_REFNUM	EQU	OP_FILEBUFF+2	; file reference number
  357          0006        	OPEN_PSIZE	EQU	OP_REFNUM+1	; size of parameter buffer
  358                      	
  359          0000        	READ_PARM	EQU	0		; to read things
  360          0000        	RD_PCOUNT	EQU	READ_PARM	; param count (=4)
  361          0001        	RD_REFNUM	EQU	RD_PCOUNT+1	; ref num of file
  362          0002        	RD_BUFFER	EQU	RD_REFNUM+1	; where to
  363          0004        	RD_BUFFLEN	EQU	RD_BUFFER+2	; length of buffer
  364          0006        	RD_LENGTH	EQU	RD_BUFFLEN+2	; actual length of read
  365          0008        	READ_PSIZE	EQU	RD_LENGTH+2	; length of parm block
  366                      	
  367          0000        	CLOSE_PARM	EQU	0		; for closing file
  368          0000        	CL_PCOUNT	EQU	CLOSE_PARM	; paramter count (=1)
  369          0001        	CL_REFNUM	EQU	CL_PCOUNT+1	; refnum of file to be closed
  370          0002        	CLOSE_PSIZE	EQU	CL_REFNUM+1	; this is the size, thank you
  371                      	
  372          0000        	WRITE_PARM	EQU	0		; to write things
  373          0000        	WR_PCOUNT	EQU	WRITE_PARM	; parm count (= 4)
  374          0001        	WR_REFNUM	EQU	WR_PCOUNT+1	; file refnum
  375          0002        	WR_BUFFER	EQU	WR_REFNUM+1	; data buffer address
  376          0004        	WR_BUFFLEN	EQU	WR_BUFFER+2	; data buffer length
  377          0006        	WR_LENGTH	EQU	WR_BUFFLEN+2	; actual length written
  378          0008        	WRITE_PSIZE	EQU	WR_LENGTH+2	; length of parm block
  379                      	
  380          0000        	SETMARK_PARM	EQU	0
  381          0000        	SM_PCOUNT	EQU	SETMARK_PARM	; parm count (=2)
  382          0001        	SM_REFNUM	EQU	SM_PCOUNT+1	; file refnum
  383          0002        	SM_FPOS		EQU	SM_REFNUM+1	; 3 byte file pos 
  384          0005        	SETMARK_PSIZE	EQU	SM_FPOS+3	; length of parm block
  385                      	
  386          0000        	SETPREFIX_PARM	EQU	0	
  387          0000        	SP_PCOUNT	EQU	SETPREFIX_PARM	; parm count (=1)
  388          0001        	SP_PATHNAME	EQU	SP_PCOUNT+1	; pointer to path name
  389          0003        	SETPREFIX_PSIZE	EQU	SP_PATHNAME+2	; length of block
  390                      	
  391          0000        	SETEOF_PARM     EQU     0
  392          0000        	SE_PCOUNT       EQU     SETEOF_PARM     ; parm count (=2)
  393          0001        	SE_REFNUM       EQU     SE_PCOUNT+1     ; reference number
  394          0002        	SE_NEWEOF       EQU     SE_REFNUM+1     ; new EOF position
  395          0005        	SETEOF_PSIZE    EQU     SE_NEWEOF+3     ; length of parm block
  396                      	
  397   0000               		END
  398                      	
  399   0000               		INCLUDE 	APPLE.EQU
  400   0000               		STTL "--- APPLE ][ HARDWARE STUFF ---"
  401                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page    8

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- APPLE ][ HARDWARE STUFF ---"

  402                      	; -------------------
  403                      	; APPLE II MEMORY MAP
  404                      	; -------------------
  405          0001        	AUX	EQU	1	; offset to Auxillary mem switches
  406          0000        	MAIN	EQU	0	; for main memory switches
  407                      	
  408                      	;
  409                      	; some hardware spots
  410                      	;
  411          2000        	SCREEN	EQU	$2000		; START OF Double HiRes SCREEN RAM
  412                      	
  413          BF00        	PRGLBL	EQU	$BF00		; ProDOS Globals page in main mem
  414          BF58        	PR_BITMAP EQU	$BF58		; ProDOS system bitmap
  415          BFFF        	KVERSION EQU    $BFFF           ; ProDOS version (== $FF if InfoDOS)
  416          00FF        	INFODOS_ID EQU  $FF
  417                      	
  418          C000        	IOADDR	EQU	$C000		; start of I/O registers
  419          D000        	PROADR	EQU	$D000		; start of ProDOS
  420                      	
  421          0200        	LBUFF	EQU	$0200		; LINE INPUT BUFFER
  422          0273        	PIC1BUF EQU	$0300-141	; we can use line buffer for one picture buffer
  423          0280        	SCRBUFF	EQU	LBUFF+$80	; screen line buffer
  424          2000        	BORG	EQU	$2000		; ORIGIN OF .SYSTEM CODE 
  425                      	;
  426                      	; some page 3 storage relocated stuff
  427                      	;
  428          0300        	PAGE3STUFF EQU	$300
  429          0300        	MOUSER	EQU	PAGE3STUFF	; this is where mouse subroutine goes
  430          0312        	COLORS	EQU	MOUSER+$12
  431          0352        	XPOSTBL	EQU	COLORS+$40
  432                      	
  433          0400        	SV_PCL	EQU	$400		; for scrolling data
  434          0600        	SV_PCH	EQU	$600
  435                      	
  436          0800        	IOBUFF	EQU	$0800		; 1Kb DATA BUFFER BUFFER
  437                      	
  438          0C00        	PAGING_MEM EQU	IOBUFF+$400	; Paging table stuff
  439          0C00        	NEXTPNT	EQU	PAGING_MEM
  440          0C40        	PREVPNT	EQU	NEXTPNT+$40	
  441          0C80        	VPAGEH	EQU	PREVPNT+$40	
  442          0CC0        	VPAGEL	EQU	VPAGEH+$40	
  443          0200        	PAGELEN	EQU	$200		; length of paged read
  444                      	
  445          0D00        	ZSTKBL	EQU	PAGING_MEM+$100	; Z-STACK  BOTTOM,LO  (1K STACK FOR EZIP)
  446          0E00        	ZSTKTL	EQU	ZSTKBL+$100	; TOP, LO
  447          0F00        	ZSTKBH	EQU	ZSTKBL+$200	; BOTTOM, HI
  448          1000        	ZSTKTH	EQU	ZSTKBL+$300	; TOP, HI
  449                      	;
  450                      	; now define some file i/o buffers and such
  451                      	;
  452          1100        	GAME1FIO EQU	ZSTKBL+$400	; Game file I/O buffer
  453          1500        	GAME2FIO EQU	GAME1FIO+$400	; Second game file i/o buffer
  454          1900        	SEGTBL	EQU	GAME2FIO+$400	; segment table for multi disks
  455          1C74        	PIC2BUF	EQU	SEGTBL+($400-140) ; picture buffer is 140 bytes long
  456          1D00        	TCHARTBL EQU	SEGTBL+$400	; 208 bytes for (possible) terminating
  457          1D50        	COPY_LINE EQU   TCHARTBL+$50    ; copy line in screen memory
  458          1D7C        	CPY_MOD1_SRC equ   COPY_LINE+$2C   ; special self-modifying places
  459          1D7F        	CPY_MOD1_DST equ CPY_MOD1_SRC+3
  460          1DA0        	CPY_MOD2_SRC equ   COPY_LINE+$50
  461          1DA3        	CPY_MOD2_DST equ CPY_MOD2_SRC+3
  462                      	
  463          1DD0        	DSKSEG	EQU	TCHARTBL+$D0	; spot to stash pointers for disk segments
  464          1DD0        	D1SEG	EQU	DSKSEG		; where in SEGTBL for Disk 1
  465          1DD2        	D2SEG	EQU	D1SEG+2
  466          1DD4        	D3SEG	EQU	D2SEG+2
  467          1DD6        	D4SEG	EQU	D3SEG+2
  468          1DD8        	D5SEG	EQU	D4SEG+2
  469          1DDA        	D6SEG	EQU	D5SEG+2
  470          1DDC        	D7SEG	EQU	D6SEG+2
  471          1DDE        	D8SEG	EQU	D7SEG+2
  472          1DE0        	LOCAL_SV EQU	TCHARTBL+$E0	; to save locals before restore
  473          1E00        	LOCALS	EQU	TCHARTBL+$100	; LOCAL VARIABLE STORAGE (30 BYTES)
  474          1E20        	BUFSAV	EQU	LOCALS+$20	; TEMP SPACE FOR SAVE/RESTORE (80 BYTES)
  475          1F00        	SCR_LINE EQU	LOCALS+$100	; place to build displayed line
  476          1F8C        	CHARSET EQU     SCR_LINE+140    ; spot for charset to go
  Wed Jun  7 1989 12:04                                                                                                  Page    9

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- APPLE ][ HARDWARE STUFF ---"

  477                      	;
  478                      	; now for some interpreter data
  479                      	;
  480          4000        	INTR_BEGIN EQU	$4000		; START OF Interpreter CODE in main
  481          5600        	INTR_SIZE EQU	(43*512)	; size of interpreter
  482                      	
  483          9600        	ZBEGIN	EQU	(INTR_BEGIN+INTR_SIZE) ; start of Z code
  484          7F00        	MMSIZE	EQU	PRGLBL-INTR_BEGIN ; free memory in main bank
  485          0029        	Z1SIZE	EQU	>(PRGLBL-ZBEGIN) ; size of preload, part 1
  486                      	;
  487                      	; this is in Bank 2, Main mem
  488                      	;
  489                      	;
  490                      	; Picture directory goes in Bank 2, Aux mem
  491                      	;
  492          D000        	PIC_DIR	EQU	$D000		; picture local directory
  493          DC00        	GBL_DIR EQU     $DC00           ; global directory
  494                      	;
  495                      	; some special markers if we are using InfoDOS
  496                      	;
  497          0000        	SP_BANK EQU     MAIN
  498          D000        	SP_START EQU    $D000           ; start of special area
  499          0017        	SP_SIZE EQU     ((($FE->SP_START)*256)/512)     ; how many pages
  500                      	;SP_SIZE EQU     (((>SCREEN->SP_START)*256)/512)     ; how many pages
  501                      	
  502          0001        	PB_BANK EQU     AUX          ; paging buffers in which bank
  503          0800        	PBEGIN	EQU	$0800		; start of paging buffers
  504          0018        	NUMBUFS	EQU	>(SCREEN-PBEGIN) ; how many 256k paging buffers
  505                      	;NUMBUFS	EQU	>($100-PBEGIN) ; how many 256k paging buffers
  506                      	
  507          0029        	P2PAGE	EQU	>(PRGLBL-ZBEGIN) ; first page of zcode in aux bank
  508          4000        	Z2BEGIN	EQU	$4000		; start of part 2 in aux mem
  509                      					; just after the dhires screen
  510          0040        	Z2PAGE	EQU	>Z2BEGIN	; get me just the page address
  511          007F        	Z2SIZE	EQU	>(PRGLBL-Z2BEGIN) ; size of preload, part 2
  512          00A8        	P3PAGE	EQU	Z1SIZE+Z2SIZE	; first page in aux mem part 3
  513          D000        	Z3BEGIN	EQU	$D000		; start of 3 part in aux mem
  514          00D0        	Z3PAGE	EQU	>Z3BEGIN	; get me page number too
  515          002E        	Z3SIZE	EQU	<($FE-Z3PAGE)	; size of part 3, in pages
  516                      	
  517                      	;
  518                      	; other numba's
  519                      	;
  520          00D6        	PGBEGIN	EQU	(P3PAGE+Z3SIZE)	; first paged page
  521          00D6        	PRESIZE EQU	(Z1SIZE+Z2SIZE+Z3SIZE)	; size of preload, # pages
  522          2000        	SCRSZE	EQU	INTR_BEGIN-SCREEN ; size of Double HiRes screen (8k, each bank)
  523          EE00        	RAMDSK	EQU	(119*512)	; size of RAM disk in aux mem
  524          B500        	RAMSAVE	EQU	$B500		; save this much to cover HiRes screen in
  525                      					; aux and the rest of the preload, up to
  526                      					; PRGLBL ($bf00)
  527          3900        	FREERAM	EQU	RAMDSK-RAMSAVE	; size of Free RAM after 'saving' 
  528                      					; special AUX memory
  529          2200        	DSKSZE	EQU	(512*273)	; size of ProDOS data disk file
  530                      	
  531                      	; ---------
  532                      	; CONSTANTS
  533                      	; ---------
  534                      	
  535          0002        	IIeID	EQU	2	; Apple ][e Yzip
  536          0009        	IIcID	EQU	9	; ][c Yzip
  537          000A        	IIgsID	EQU 	10	; ][gs Yzip
  538                      	
  539          00FF        	P3BANK	EQU	$FF	; show upper aux mem
  540          0000        	LO	EQU	0	
  541          0001        	HI	EQU	1	
  542          0002        	ABANK	EQU	2	; for address variables
  543                      	
  544          0000        	OFF	EQU	0	; for toggling soft-switches
  545          0001        	ON	EQU	1
  546                      	
  547          0003        	RETRY_COUNT EQU 3       ; how many retries before message
  548                      	
  549          0009        	TAB     EQU     $09     ; Tab char
  550          000B        	EOS     EQU     $0B     ; End of Sentence
  551          000D        	EOL	EQU	$0D	; EOL CHAR
  Wed Jun  7 1989 12:04                                                                                                  Page   10

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- APPLE ][ HARDWARE STUFF ---"

  552          000A        	LF	EQU	$0A	; LINE FEED
  553          0020        	SPACE	EQU	$20	; SPACE CHAR
  554          0008        	BACKSPACE EQU	$08	; BACKSPACE CHAR
  555          001B        	ESCAPE	EQU	$1B	; ESCAPE Key
  556          003F        	VOLCHAR EQU	'?'	; Key to hit for ONLINE command
  557                      	;
  558                      	; Screen Defs
  559                      	;
  560          008C        	MAXWIDTH EQU	140	; 560 / 4 = max "pixels"
  561          0230        	REAL_MAXW EQU	MAXWIDTH*4
  562          00C0        	MAXHEIGHT EQU	192	; 192 screen lines
  563          0002        	FONT_W	EQU	2	; font width (for game, anyway)
  564          0009        	FONT_H	EQU	9	; font height
  565          0003        	MFONT_W	EQU	3	; mono spaced font width, to game
  566          000C        	MONOFONT_W EQU	MFONT_W*4	; how wide the mono font really is
  567                      	
  568          0008        	SPACE_WIDTH EQU	8	; default space width
  569          0003        	BLINK_RATE EQU	3	; tenths of seconds between blinks
  570                      	
  571          001C        	OUTER_DELAY EQU	$1C	; outside delay loop counter
  572          0003        	INNER_DELAY EQU	3	; inner delay loop
  573                      	
  574          0072        	GS_OUTER_DELAY EQU $72	; ][gs outside counter
  575          0002        	GS_INNER_DELAY EQU 2	; ][gs inside counter
  576                      	
  577                      	; ----------------------
  578                      	; BOOT ZERO PAGE EQUATES
  579                      	; ----------------------
  580                      	
  581          0026        	BADDR	EQU	$26	; (WORD) ROM BOOT ADDRESS
  582          002B        	BSLOT	EQU	$2B	; (BYTE) ROM BOOT SLOT
  583                      	
  584          0280        	START_NAME EQU     $280    ; name upon boot is stored here
  585                      	; ----------------
  586                      	; HARDWARE EQUATES
  587                      	; ----------------
  588                      	
  589          C000        	KBD	EQU	$C000	; KEY STROBE
  590          C000        	STORE80 EQU	$C000	; video aux mem switch
  591          C002        	RDBNK	EQU	$C002	; READ MAIN MEMORY (+MAIN, +AUX)
  592          C004        	WRTBNK	EQU	$C004	; WRITE MAIN 48K OF MEMORY (+MAIN, +AUX)
  593          C008        	ALTZP	EQU	$C008	; R/W MAIN (C009 = AUX) >MEM
  594          C00C        	COL80SW	EQU	$C00C	; 80 Column switch
  595          C010        	ANYKEY 	EQU	$C010	; ANY KEY DOWN FLAG
  596          C019        	VERTBLNK EQU	$C019	; Vertical Blanking Flag
  597          C029        	IIGSVID EQU     $C029   ; GS MEGA ][ video register
  598          C030        	SPKR	EQU	$C030	; SPEAKER FLAG (MAKE A NOISE)
  599          C035        	IIGSSHD EQU     $C035   ; ][GS shadowing reg
  600          C050        	TEXTSW	EQU	$C050	; Graphics Switch
  601          C052        	MIXEDSW EQU	$C052	; Mixed Text/Graphics
  602          C054        	PAGE2SW EQU	$C054	; Page select
  603          C056        	HIRESSW	EQU	$C056	; Select HiRes
  604          C05E        	DHIRESW	EQU	$C05E	; Double HiRes switch (backwards: +0 on +1 off)
  605          C07E        	IOUDIS	EQU	$C07E	; Double HiRes Switch enabler (same backass way)
  606          C083        	BNK2SET	EQU	$C083	;READ/READ      READ RAM WRITE RAM BANK 2
  607          C08B        	BNK1SET	EQU	$C08B	;READ/READ      READ RAM WRITE RAM BANK 1
  608          C082        	RDROM	EQU	$C082	; READ READ ROM NO WRITE
  609          C088        	RDBNK1	EQU	$C088	; READ ram, bank 1
  610          C080        	RDBNK2	EQU	$C080	; Read ram, bank 2
  611                      	
  612                      	; -----------------
  613                      	; MONITOR VARIABLES
  614                      	; -----------------
  615                      	
  616          0036        	CSW	EQU	$36	; CHARACTER OUTPUT VECTOR (for scripting)
  617          C061        	APKEY1	EQU	$C061	; open apple key flag
  618          C062        	APKEY2	EQU	$C062	; closed apple key flag
  619                      	
  620          0002        	CURSW	EQU	2		; width of cursor
  621          0004        	CURSH	EQU	4		; height of cursor
  622                      	; -----------
  623                      	; MOUSE STUFF
  624                      	; -----------
  625          C412        	MTABLE	EQU	$C412	; Mouse ROM table
  626          0310        	MSVECTOR EQU	MOUSER+16	; where vector is stored
  Wed Jun  7 1989 12:04                                                                                                  Page   11

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- APPLE ][ HARDWARE STUFF ---"

  627          0312        	MSMOVEF	EQU	MSVECTOR+2	; Mouse moved flag
  628          0313        	MSBTNF	EQU	MSMOVEF+1	; Mouse button flag
  629                      	;
  630                      	; MOUSE screen holes
  631                      	;
  632          0478        	CLMPMINL EQU	$478		; lo part of clamping min
  633          0578        	CLMPMINH EQU	$578		; hi part of    "      "
  634          04F8        	CLMPMAXL EQU	$4F8		; lo part of clamping max
  635          05F8        	CLMPMAXH EQU	$5F8		; hi part of    "      "
  636          0478        	MOUSEXL	EQU	$478		; lo part of mouse X
  637          0578        	MOUSEXH	EQU	$578		; hi part of mouse X
  638          04F8        	MOUSEYL	EQU	$4F8		; lo part of mouse Y
  639          05F8        	MOUSEYH	EQU	$5F8		; hi part of mouse Y
  640          0778        	MOUSEST	EQU	$778		; status byte
  641                      	;
  642                      	; some mouse constants
  643                      	;
  644          0081        	SGL_CLK	EQU	$81	; single click char
  645          0082        	DBL_CLK	EQU	$82	; double click char
  646          0006        	CLK_CNT	EQU	6	; counts between single and double click
  647                      	; Subroutine offsets
  648          0000        	SETM	EQU	0
  649          0001        	SERVEM	EQU	1
  650          0002        	READM	EQU	2
  651          0003        	CLEARM	EQU	3
  652          0004        	POSM	EQU	4
  653          0005        	CLAMPM	EQU	5
  654          0006        	HOMEM	EQU	6
  655          0007        	INITM	EQU	7
  656                      	
  657                      	; --------------
  658                      	; PRODOS GLOBALS
  659                      	; --------------
  660          BF90        	PRODATE	EQU	$BF90	; date and
  661          BF92        	PROTIME	EQU	$BF92	; time
  662          BF98        	MACHID	EQU	$BF98	; machine id
  663                      	
  664                      	; ----------------
  665                      	; MONITOR ROUTINES
  666                      	; ----------------
  667          FB1E        	MPREAD	EQU	$FB1E	; Read for joystick control
  668          FC22        	MBASCAL	EQU	$FC22	; CALC LINE BASE ADDRESS
  669          FF3A        	MBELL	EQU	$FF3A	; MAKE A NOISE
  670          FFFC        	RESET_VECTOR EQU $FFFC  ; force warm reboot
  671          FC9C        	MCLEOL	EQU	$FC9C	; CLEAR TO END OF LINE
  672          FC42        	MCLEOS	EQU	$FC42	; CLEAR TO END OF SCREEN
  673          FC58        	MHOME	EQU	$FC58	; CLEAR SCREEN/HOME CURSOR
  674          FDED        	MCOUT	EQU	$FDED	; CHAR OUTPUT
  675          FDF0        	MCOUT1	EQU	$FDF0	; CHAR OUTPUT TO SCREEN
  676          FD0C        	MRDKEY	EQU	$FD0C	; READ KEY
  677          FD6F        	MGETLN1	EQU	$FD6F	; GET LINE
  678          FCA8        	MWAIT	EQU	$FCA8	; WASTE SO MUCH TIME
  679                      	;
  680                      	; Some /RAM spots
  681                      	;
  682          BF26        	RAMVEC	EQU	$BF26	; /RAM drive vector
  683          077E        	OLDVEC	EQU	$77E	; spot to save the drive vector
  684          BF16        	UNSVEC	EQU	$BF16	; "Uninstalled Device" vector
  685          BF31        	DEVCNT	EQU	$BF31	; Device count
  686          BF32        	DEVNUM	EQU	$BF32	; Device list
  687                      	
  688                      	;
  689                      	; machine info spots
  690                      	;
  691          FBB3        	MACHID1	EQU	$FBB3	; first part
  692          FBC0        	MACHID2	EQU	$FBC0	; second part
  693          FE1F        	MACHCHK	EQU	$FE1F	; differentiate between ][e and gs
  694                      				; do sec, then jsr, and if still set, = ][e
  695   0000               		END
  696                      	
  697   0000               		INCLUDE		MACROS.ASM
  698   0000               		STTL	"--- MACROS ---"
  699                      		PAGE 
  Wed Jun  7 1989 12:04                                                                                                  Page   12

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- MACROS ---"

  700                      	
  701                      	;
  702                      	; MACROS for Apple ][ Yzip
  703                      	;
  704                      	DLINE:	.MACRO	STRING,SLEN
  705                      		ldx	#<STRING	; get part of STRING
  706                      		lda	#>STRING	; get other part of string
  707                      		IFMA	2		; check to see if length passed in
  708                      		ldy	SLEN		; then just fetch it
  709                      		ELSE
  710                      		ldy	#STRING|L	; get length of string
  711                      		ENDIF
  712                      		jsr	DLINE		; print the string
  713                      		.MACEND
  714                      	;
  715                      	; ProDOS macros
  716                      	;
  717                      	PRODOS:	.MACRO	CODE, PADDR
  718                      		jsr	$BF00	; ProDOS handler
  719                      		DB	CODE	; ProDOS function code
  720                      		DW	PADDR	; Function Parameter Block address
  721                      		.MACEND
  722                      	
  723                      	QUIT:	.MACRO	PBLOCK
  724                      		PRODOS 	$65, PBLOCK
  725                      		.MACEND
  726                      	
  727                      	READ_BLOCK: .MACRO PBLOCK
  728                      		PRODOS	$80, PBLOCK
  729                      		.MACEND
  730                      	
  731                      	WRITE_BLOCK: .MACRO PBLOCK
  732                      		PRODOS	$81, PBLOCK
  733                      		.MACEND
  734                      	
  735                      	GET_TIME: .MACRO PBLOCK
  736                      		PRODOS	$82, PBLOCK
  737                      		.MACEND
  738                      	
  739                      	CREATE:	.MACRO	PBLOCK
  740                      		PRODOS	$C0, PBLOCK
  741                      		.MACEND
  742                      	
  743                      	DESTROY: .MACRO	PBLOCK
  744                      		PRODOS	$C1, PBLOCK
  745                      		.MACEND
  746                      	
  747                      	RENAME: .MACRO PBLOCK
  748                      		PRODOS	$C2, PBLOCK
  749                      		.MACEND
  750                      	
  751                      	SET_FILE_INFO: .MACRO PBLOCK
  752                      		PRODOS	$C3, PBLOCK
  753                      		.MACEND
  754                      	
  755                      	GET_FILE_INFO: .MACRO PBLOCK
  756                      		PRODOS	$C4, PBLOCK
  757                      		.MACEND
  758                      	
  759                      	ONLINE: .MACRO PBLOCK
  760                      		PRODOS	$C5, PBLOCK
  761                      		.MACEND
  762                      	
  763                      	SET_PREFIX: .MACRO PBLOCK
  764                      		PRODOS	$C6, PBLOCK
  765                      		.MACEND
  766                      	
  767                      	GET_PREFIX: .MACRO PBLOCK
  768                      		PRODOS	$C7, PBLOCK
  769                      		.MACEND
  770                      	
  771                      	OPEN: .MACRO PBLOCK
  772                      		PRODOS	$C8, PBLOCK
  773                      		.MACEND
  774                      	
  Wed Jun  7 1989 12:04                                                                                                  Page   13

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- MACROS ---"

  775                      	NEWLINE: .MACRO PBLOCK
  776                      		PRODOS	$C9, PBLOCK
  777                      		.MACEND
  778                      	
  779                      	READ: .MACRO PBLOCK
  780                      		PRODOS	$CA, PBLOCK
  781                      		.MACEND
  782                      	
  783                      	WRITE: .MACRO PBLOCK
  784                      		PRODOS	$CB, PBLOCK
  785                      		.MACEND
  786                      	
  787                      	CLOSE: .MACRO PBLOCK
  788                      		PRODOS	$CC, PBLOCK
  789                      		.MACEND
  790                      	
  791                      	FLUSH: .MACRO PBLOCK
  792                      		PRODOS	$CD, PBLOCK
  793                      		.MACEND
  794                      	
  795                      	SET_MARK: .MACRO PBLOCK
  796                      		PRODOS	$CE, PBLOCK
  797                      		.MACEND
  798                      	
  799                      	GET_MARK: .MACRO PBLOCK
  800                      		PRODOS	$CF, PBLOCK
  801                      		.MACEND
  802                      	
  803                      	SET_EOF: .MACRO PBLOCK
  804                      		PRODOS	$D0, PBLOCK
  805                      		.MACEND
  806                      	
  807                      	SET_BUF: .MACRO PBLOCK
  808                      		PRODOS	$D1, PBLOCK
  809                      		.MACEND
  810                      	
  811                      	GET_BUF: .MACRO PBLOCK
  812                      		PRODOS	$D2, PBLOCK
  813                      		.MACEND
  814                      	
  815   0000               		END
  816                      	
  817                      	
  818   0000               		TITLE 	"APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
  819   0000               		INCLUDE		ZBEGIN.ASM
  820   0000               		STTL "--- START OF APPLE ][ INTERPRETER ---"
  821                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page   14

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- START OF APPLE ][ INTERPRETER ---"

  822                      	
  823   4000               		ORG	INTR_BEGIN
  824                      	;
  825                      	; Set up for Double HiRes full screen graphics
  826                      	;	
  827   4000   AD 54 C0    		lda	PAGE2SW+OFF	; turn off page 2
  828   4003   8D 50 C0    		sta	TEXTSW+OFF	; turn off text - turn on graphics
  829   4006   8D 57 C0    		sta	HIRESSW+ON	; turn on high resolution
  830   4009   8D 52 C0    		sta	MIXEDSW+OFF	; full screen graphics
  831   400C   8D 0D C0    		sta	COL80SW+ON	; turn on 80 column
  832   400F   8D 7E C0    		sta	IOUDIS+OFF	; turn ON (it too is backwards) Dhires switch
  833   4012   8D 5E C0    		sta	DHIRESW+OFF	; turn ON (it's backwards!) Dhires
  834                      	
  835   4015   8D 01 C0    		sta	STORE80+ON	; turn on aux page display ability
  836   4018   AD 83 C0    	        lda     BNK2SET         ; read/write RAM, bank 2
  837   401B   AD 83 C0    	        lda     BNK2SET
  838                      	;
  839                      	; copy in progame from boot code
  840                      	;
  841   401E   A2 00       		ldx	#0		; start at first letter
  842   4020               	MVPRE:
  843   4020   BD 03 20    		lda	BORG+3,X	; get letter
  844   4023   F0 0C       		beq	MVPREX		; all done
  845   4025   9D 78 46    		sta	GAME1NAME,X	; save letter
  846   4028   9D 8A 46    		sta	GAME2NAME,X	; save letter
  847   402B   9D 68 46    		sta	GAME,X		; save for asking about later
  848   402E   E8          		inx			; next letter
  849   402F   D0 EF       		bne	MVPRE		; do gen
  850   4031               	MVPREX:
  851   4031   8E 67 46    		stx	GAMEL		; save length of game name
  852   4034   A9 2E       		lda	#'.'		; get extension for names
  853   4036   9D 78 46    		sta	GAME1NAME,X	; save letter
  854   4039   9D 8A 46    		sta	GAME2NAME,X	; save letter
  855   403C   E8          		inx			; next letter
  856   403D   A9 44       		lda	#'D'		; for data segments
  857   403F   9D 78 46    		sta	GAME1NAME,X	; save letter
  858   4042   9D 8A 46    		sta	GAME2NAME,X	; save letter
  859   4045   E8          		inx			; points to number
  860   4046   E8          		inx			; inclusive count for length
  861   4047   8E 77 46    		stx	GAME1NML	; save length of name
  862   404A   8E 89 46    		stx	GAME2NML	; save length of name
  863                      	
  864   404D   A9 0D       		lda	#VERSID		; put in version number
  865   404F   8D 1F 96    		sta	ZBEGIN+ZINTWD+1	
  866                      	
  867   4052   E6 AF       		inc	ZSP+LO		; INIT Z-STACK POINTERS
  868   4054   EE 7A 6C    		inc	OLDZSP+LO	; TO "1"
  869   4057   E6 B1       		inc	SCREENF		; TURN DISPLAY ON
  870   4059   E6 AA       		inc	SCRIPT		; enable scripting
  871   405B   EE A8 6C    	        inc     CRLF_CHECK      ; do CR functino check
  872                      	
  873   405E   AD 4C 6E    		lda	WINTABLE+LO	; set WINDOW to point to window 0
  874   4061   85 05       		sta	WINDOW+LO
  875   4063   AD 4D 6E    		lda	WINTABLE+HI
  876   4066   85 06       		sta	WINDOW+HI	; okay, it does
  877                      	
  878   4068   A5 63       		lda	ARG1+LO		; using mouse?
  879   406A   F0 12       		beq	ZBEGIN1		; nope
  880   406C   09 78       		ora	#$78		; point to correct screen holes
  881   406E   8D 50 50    		sta	MSFIX0+1
  882   4071   8D 5B 50    		sta	MSFIX1+1	; and modify code to point to correct spot
  883   4074   8D 60 50    		sta	MSFIX2+1
  884   4077   A5 63       		lda	ARG1+LO
  885   4079   09 F8       		ora	#$F8		; and one more
  886   407B   8D 60 50    		sta	MSFIX2+1
  887   407E               	ZBEGIN1:
  888   407E   A9 FF       		lda	#$FF		; do a clear -1 to start off
  889   4080   85 63       		sta	ARG1+LO		; so arg 1 is this
  890   4082   20 B0 57    		jsr	ZCLR		; doing it
  891                      	
  892   4085               		GET_PREFIX GPRE_PB	; get where we are to start
  893   4085               		PRODOS	$C7, GPRE_PB
  894   4085   20 00 BF    		jsr	$BF00	; ProDOS handler
  895   4088   C7          		DB	$C7	; ProDOS function code
  896   4089   6446        		DW	GPRE_PB	; Function Parameter Block address
  Wed Jun  7 1989 12:04                                                                                                  Page   15

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- START OF APPLE ][ INTERPRETER ---"

  897   408B               		.MACEND
  898   408B               		.MACEND
  899                      	
  900   408B   AD D3 1D    		lda	D2SEG+HI	; start DSEGS at .D2
  901   408E   85 1F       		sta	DSEGS+HI
  902   4090   AD D2 1D    		lda	D2SEG+LO
  903   4093   85 1E       		sta	DSEGS+LO
  904                      	
  905   4095   A9 01       		lda	#1		; open game file .D2 please
  906   4097   20 C6 49    		jsr	FETCH_FILE	; we did that
  907   409A   A5 59       	        lda     INFODOS         ; are we on little dos?
  908   409C   F0 03       	        beq     ZBEGIN2         ; nope
  909   409E   20 F1 4B    	        jsr     GET_SPECIAL     ; do special preloading if so
  910   40A1               	ZBEGIN2:
  911   40A1   AD D5 1D    		lda	D3SEG+HI	; this is cuz we be openin' .D3
  912   40A4   85 1F       		sta	DSEGS+HI
  913   40A6   AD D4 1D    		lda	D3SEG+LO
  914   40A9   85 1E       		sta	DSEGS+LO
  915   40AB   A9 02       		lda	#2		; and just for giggles, do the
  916   40AD   20 C6 49    		jsr	FETCH_FILE	; same for game file .D3
  917                      	
  918   40B0   20 AF 90    		jsr	VLDZPC		; MAKE ZPC VALID
  919   40B3   20 24 92    		jsr	NEXTPC		; skip over # of locals
  920                      	
  921                      		; ... AND FALL INTO MAIN LOOP
  922                      	
  923   40B6               		END
  924                      	
  925   40B6               		INCLUDE 	MAIN.ASM
  926   40B6               		STTL "--- MAIN LOOP ---"
  927                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page   16

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

  928                      	
  929          9600        	MD_ADDR EQU	ZBEGIN
  930          0001        	MDEBUG 	EQU	1
  931                      	
  932   40B6               	MLOOP:
  933          [01]        		IF 	MDEBUG
  934   40B6   AD 00 96    		lda	MD_ADDR	; get interesting address
  935   40B9   D0 01       		bne	MLOOPx	; just fine, thank you
  936   40BB   00          		brk		; then die
  937   40BC               	MLOOPx:
  938          [00]        		ENDIF
  939                      	
  940   40BC   A9 00       		lda	#0	
  941   40BE   85 62       		sta	NARGS		; reset number of args
  942   40C0   AD 54 C0    		lda	PAGE2SW+OFF	; just do this for the heck of it
  943   40C3   AD 83 C0    	        lda     BNK2SET
  944   40C6   AD 83 C0    	        lda     BNK2SET
  945   40C9   8D 01 C0    		sta	STORE80+ON	; must always be on
  946                      	
  947   40CC   20 24 92    		jsr	NEXTPC	; get op code
  948   40CF   85 61       		sta	OPCODE	; SAVE IT HERE
  949                      	
  950          [01]        		IF	MDEBUG
  951                      	;
  952                      	; special debugging code
  953                      	;
  954   40D1   AC 01 41    		ldy	SPCSV
  955   40D4   A5 61       		lda	OPCODE
  956   40D6   99 10 41    		sta	SAVEOP,Y
  957   40D9   A5 82       		lda	ZPCH
  958   40DB   99 20 41    		sta	SAVEZH,Y
  959   40DE   A5 81       		lda	ZPCM
  960   40E0   99 30 41    		sta	SAVEZM,Y
  961   40E3   A5 80       		lda	ZPCL
  962   40E5   99 40 41    		sta	SAVEZL,Y
  963   40E8   A5 85       		lda	ZPCBNK
  964   40EA   99 50 41    		sta	SAVEZB,Y
  965   40ED   A5 84       		lda	ZPCPNT+HI
  966   40EF   99 60 41    		sta	SAVEZP,Y
  967   40F2   AC 01 41    		ldy	SPCSV
  968   40F5   C8          		iny
  969   40F6   98          		tya
  970   40F7   29 0F       		and	#$0F
  971   40F9   8D 01 41    		sta	SPCSV	
  972   40FC   A5 61       		lda	OPCODE
  973   40FE   4C 70 41    		jmp	MAINDB
  974   4101   00          	SPCSV:	db	0
  975   4111               		ORG	$+15
  976   0411               		ORG	$.SHR.4
  977   4110               		ORG	$.SHL.4
  978   4110               	SAVEOP: ds 16
  979   4120               	SAVEZH:	ds 16
  980   4130               	SAVEZM: ds 16
  981   4140               	SAVEZL: ds 16
  982   4150               	SAVEZB: ds 16
  983   4160               	SAVEZP: ds 16		      
  984   4170               	MAINDB:
  985          [00]        		ENDIF
  986                      	;
  987                      	; DECODE AN OPCODE
  988                      	;
  989   4170   A8          		tay		; set flags
  990   4171   30 03       		bmi	DC0	; IF POSITIVE,
  991   4173   4C CD 42    		jmp	OP2	; IT'S A 2-OP
  992   4176   C9 B0       	DC0:	cmp	#$B0	
  993   4178   B0 03       		bcs	DC1	
  994   417A   4C 90 42    		jmp	OP1	; OR MAYBE A 1-OP
  995   417D   C9 C0       	DC1:	cmp	#$C0	
  996   417F   B0 03       		bcs	OPEXT	
  997   4181   4C 6A 42    		jmp	OP0	; PERHAPS A 0-OP
  998                      	
  999                      	; --------------
 1000                      	; HANDLE AN X-OP
 1001                      	; --------------
 1002                      	
  Wed Jun  7 1989 12:04                                                                                                  Page   17

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

 1003   4184   C9 EC       	OPEXT:	CMP	#236		; XCALL?
 1004   4186   D0 03       		BNE	OPX5
 1005   4188   4C 15 42    		JMP	OPXCLL		; YES, PROCESS SEPARATELY
 1006   418B   C9 FA       	OPX5:	CMP	#250		; IXCALL
 1007   418D   D0 03       		BNE	OPX6
 1008   418F   4C 15 42    		JMP	OPXCLL
 1009   4192   20 24 92    	OPX6:	JSR	NEXTPC		; GRAB THE ARGUMENT ID BYTE
 1010   4195   85 73       		STA	ABYTE		; HOLD IT HERE
 1011   4197   A2 00       		LDX	#0
 1012   4199   86 75       		STX	ADEX		; INIT ARGUMENT INDEX
 1013   419B   F0 06       		BEQ	OPX1		; JUMP TO TOP OF LOOP
 1014   419D   A5 73       	OPX0:	LDA	ABYTE		; GET ARG BYTE
 1015   419F   0A          		ASL	A		; SHIFT NEXT 2 ARG BITS
 1016   41A0   0A          		ASL	A		; INTO BITS 7 & 6
 1017   41A1   85 73       		STA	ABYTE		; HOLD FOR LATER
 1018   41A3   29 C0       	OPX1:	AND	#%11000000	; MASK OUT GARBAGE BITS
 1019   41A5   D0 06       		BNE	OPX2
 1020   41A7   20 2B 43    		JSR	GETLNG		; 00 = LONG IMMEDIATE
 1021   41AA   4C BE 41    		JMP	OPXNXT
 1022   41AD   C9 40       	OPX2:	CMP	#%01000000	; IS IT A SHORT IMMEDIATE?
 1023   41AF   D0 06       		BNE	OPX3		; NO, KEEP GUESSING
 1024   41B1   20 27 43    		JSR	GETSHT		; 01 = SHORT IMMEDIATE
 1025   41B4   4C BE 41    		JMP	OPXNXT
 1026   41B7   C9 80       	OPX3:	CMP	#%10000000	; LAST TEST
 1027   41B9   D0 17       		BNE	OPX4		; 11 = NO MORE ARGUMENTS
 1028   41BB   20 3F 43    		JSR	GETVAR		; 10 = VARIABLE
 1029   41BE   A6 75       	OPXNXT:	LDX	ADEX		; RETRIEVE ARGUMENT INDEX
 1030   41C0   A5 76       		LDA	VALUE+LO	; GRAB LSB OF VALUE
 1031   41C2   95 63       		STA	ARG1+LO,X	; STORE IN ARGUMENT TABLE
 1032   41C4   A5 77       		LDA	VALUE+HI	; GRAB MSB OF VALUE
 1033   41C6   95 64       		STA	ARG1+HI,X	; STORE THAT, TOO
 1034   41C8   E6 62       		INC	NARGS		; UPDATE ARGUMENT COUNTER
 1035   41CA   E8          		INX
 1036   41CB   E8          		INX
 1037   41CC   86 75       		STX	ADEX		; UPDATE INDEX
 1038   41CE   E0 08       		CPX	#8		; DONE 4 ARGUMENTS YET?
 1039   41D0   90 CB       		BCC	OPX0		; NO, GET SOME MORE
 1040                      	
 1041                      		; ALL X-OP ARGUMENTS READY
 1042                      	
 1043   41D2   A5 61       	OPX4:	LDA	OPCODE		; IS THIS
 1044   41D4   C9 E0       		CMP	#$E0		; AN EXTENDED 2-OP?
 1045   41D6   B0 07       		BCS	DOXOP		; NO, IT'S A REAL X-OP
 1046   41D8   C9 C0       		CMP	#$C0		; IS IT NEW OPCODE RANGE?
 1047   41DA   90 18       		BCC	ZEXTOP		; YES
 1048   41DC   4C 00 43    		JMP	OP2EX		; ELSE TREAT IT LIKE A 2-OP
 1049                      	
 1050   41DF   29 1F       	DOXOP:	AND	#%00011111	; ISOLATE ID BITS
 1051   41E1   A8          		TAY
 1052   41E2   B9 74 45    		LDA	OPTXL,Y
 1053   41E5   8D EF 41    		STA	GOX+1+LO
 1054   41E8   B9 54 45    		LDA	OPTXH,Y
 1055   41EB   8D F0 41    		STA	GOX+1+HI
 1056   41EE   20 FF FF    	GOX:	JSR	$FFFF		;DUMMY
 1057   41F1   4C B6 40    		JMP	MLOOP
 1058                      	
 1059                      		; HANDLE EXTENDED OPCODE RANGE OPS
 1060                      	
 1061   41F4   C9 1D       	ZEXTOP:	CMP	#EXTLEN		; OUT OF RANGE?
 1062   41F6   B0 18       		BCS	BADEXT
 1063   41F8   A8          		TAY			; OFFSET ALREADY CORRECT
 1064   41F9   B9 B1 45    		LDA	EXTOPL,Y
 1065   41FC   8D 06 42    		STA	GOE+1+LO
 1066   41FF   B9 94 45    		LDA	EXTOPH,Y
 1067   4202   8D 07 42    		STA	GOE+1+HI
 1068   4205   20 FF FF    	GOE:	JSR	$FFFF		;DUMMY
 1069   4208   4C B6 40    		JMP	MLOOP
 1070                      	
 1071                      		; *** ERROR #1 -- ILLEGAL X-OP ***
 1072                      	
 1073   420B   A9 01       	BADOPX:	LDA	#1
 1074   420D   4C 0A 52    		JMP	ZERROR
 1075                      	
 1076                      		; *** ERROR #16 -- ILLEGAL EXTENDED RANGE X-OP ***
 1077                      	
  Wed Jun  7 1989 12:04                                                                                                  Page   18

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

 1078   4210   A9 10       	BADEXT:	LDA	#16
 1079   4212   4C 0A 52    		JMP	ZERROR
 1080                      	
 1081                      		; HANDLE AN XCALL OPCODE
 1082                      	
 1083   4215   20 24 92    	OPXCLL:	JSR	NEXTPC	; GET 2 MODE BYTES
 1084   4218   85 73       		STA	ABYTE	
 1085   421A   20 24 92    		JSR	NEXTPC	
 1086   421D   85 74       		STA	BBYTE	
 1087   421F   A5 73       		LDA	ABYTE	; ONE TO START WITH
 1088   4221   A2 00       		LDX	#0	
 1089   4223   86 75       		STX	ADEX	; INIT ARGUMENT INDEX
 1090   4225   F0 06       		BEQ	XCALL2	; ALWAYS JUMP TO TOP OF LOOP
 1091   4227   A5 73       	XCALL1:	LDA	ABYTE	; GET ARG BYTE
 1092   4229   0A          		ASL	A	; SHIFT NEXT 2 BITS
 1093   422A   0A          		ASL	A	; INTO BITS 7 & 6
 1094   422B   85 73       		STA	ABYTE	; HOLD FOR LATER
 1095   422D   29 C0       	XCALL2:	AND	#%11000000	; MASK OUT GARBAGE
 1096   422F   D0 06       		BNE	XCALL3	
 1097   4231   20 2B 43    		JSR	GETLNG	; 00 = LONG IMMEDIATE
 1098   4234   4C 48 42    		JMP	XCNXT	
 1099   4237   C9 40       	XCALL3:	CMP	#%01000000	; SHORT IMMED?
 1100   4239   D0 06       		BNE	XCALL4	; NO, TRY ANOTHER
 1101   423B   20 27 43    		JSR	GETSHT	; 01 = SHORT IMMED.
 1102   423E   4C 48 42    		JMP	XCNXT	
 1103   4241   C9 80       	XCALL4:	CMP	#%10000000	; LAST TEST
 1104   4243   D0 8D       		BNE	OPX4	; 11 = NO MORE ARGS
 1105   4245   20 3F 43    		JSR	GETVAR	; 10 = VARIABLE
 1106   4248   A6 75       	XCNXT:	LDX	ADEX	
 1107   424A   A5 76       		LDA	VALUE+LO	
 1108   424C   95 63       		STA	ARG1+LO,X	
 1109   424E   A5 77       		LDA	VALUE+HI	
 1110   4250   95 64       		STA	ARG1+HI,X	
 1111   4252   E6 62       		INC	NARGS	
 1112   4254   E8          		INX		
 1113   4255   E8          		INX		
 1114   4256   86 75       		STX	ADEX	
 1115   4258   E0 10       		CPX	#16	
 1116   425A   D0 03       		BNE	XCALL5
 1117   425C   4C D2 41    		JMP	OPX4		; DONE, GO DO IT
 1118   425F   E0 08       	XCALL5:	CPX	#8		; DONE 1ST MODE BYTE?
 1119   4261   D0 C4       		BNE	XCALL1		; NOT QUITE YET
 1120   4263   A5 74       		LDA	BBYTE		; SET UP FOR NEXT
 1121   4265   85 73       		STA	ABYTE		; MODE BYTE
 1122   4267   4C 2D 42    		JMP	XCALL2		; GO DO IT
 1123                      	
 1124                      	; -------------
 1125                      	; HANDLE A 0-OP
 1126                      	; -------------
 1127                      	
 1128   426A   C9 BE       	OP0:	CMP	#190		; IS IT EXTOP OP
 1129   426C   F0 1A       		BEQ	EXTOP		; YES
 1130   426E   29 0F       		AND	#%00001111	; ISOLATE 0-OP ID BITS
 1131   4270   A8          		TAY		
 1132   4271   B9 E4 44    		LDA	OPT0L,Y	
 1133   4274   8D 7E 42    		STA	GO0+1+LO	
 1134   4277   B9 D4 44    		LDA	OPT0H,Y	
 1135   427A   8D 7F 42    		STA	GO0+1+HI	
 1136   427D   20 FF FF    	GO0:	JSR	$FFFF	;DUMMY
 1137   4280   4C B6 40    		JMP	MLOOP	
 1138                      	
 1139                      		; *** ERROR #2 -- ILLEGAL 0-OP ***
 1140                      	
 1141   4283   A9 02       	BADOP0:	LDA	#2	
 1142   4285   4C 0A 52    		JMP	ZERROR	
 1143                      	
 1144                      		; THIS OPCODE TELLS THAT NEXT OP IS PART OF THE
 1145                      		; EXTENDED RANGE OF OPCODES, GET IT AND PROCESS IT
 1146                      		; (THEY ARE ALL XOPS)
 1147                      	
 1148   4288   20 24 92    	EXTOP:	JSR	NEXTPC		; GO GET EXTENDED RANGE OP
 1149   428B   85 61       		STA	OPCODE		; SAVE IT
 1150   428D   4C 84 41    		JMP	OPEXT		; AND HANDLE IT
 1151                      	
 1152                      	
  Wed Jun  7 1989 12:04                                                                                                  Page   19

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

 1153                      	; -------------
 1154                      	; HANDLE A 1-OP
 1155                      	; -------------
 1156                      	
 1157   4290               	OP1:
 1158   4290   29 30       		and	#%00110000	; ISOLATE ARGUMENT BITS
 1159   4292   D0 07       		bne	OP1A	
 1160   4294   20 24 92    		jsr	NEXTPC		; get next byte
 1161   4297   A8          		tay
 1162   4298   4C 9F 42    		jmp	OP1A1	
 1163   429B   29 20       	OP1A:	and	#%00100000	; TEST AGAIN
 1164   429D   D0 0C       		bne	OP1B	
 1165                      	;
 1166                      	; 01 = SHORT IMMEDIATE
 1167                      	;
 1168   429F   85 64       	OP1A1:	sta	ARG1+HI	
 1169   42A1   20 24 92    		jsr	NEXTPC
 1170   42A4   85 63       		sta	ARG1+LO	
 1171   42A6   E6 62       		inc	NARGS	
 1172   42A8   4C B1 42    		jmp	OP1EX1	
 1173   42AB   20 3F 43    	OP1B:	JSR	GETVAR	; 10 = VARIABLE
 1174   42AE   20 1C 43    	OP1EX:	JSR	V2A1	; MOVE [VALUE] TO [ARG1], UPDATE [NARGS]
 1175   42B1   A5 61       	OP1EX1:	LDA	OPCODE	
 1176   42B3   29 0F       		AND	#%00001111	; ISOLATE 0-OP ID BITS
 1177   42B5   A8          		TAY		
 1178   42B6   B9 04 45    		LDA	OPT1L,Y	
 1179   42B9   8D C3 42    		STA	GO1+1+LO	
 1180   42BC   B9 F4 44    		LDA	OPT1H,Y	
 1181   42BF   8D C4 42    		STA	GO1+1+HI	
 1182   42C2   20 FF FF    	GO1:	JSR	$FFFF	;DUMMY
 1183   42C5   4C B6 40    		JMP	MLOOP	
 1184                      	
 1185                      	; *** ERROR #3 -- ILLEGAL 1-OP ***
 1186                      	
 1187   42C8   A9 03       	BADOP1:	LDA	#3	
 1188   42CA   4C 0A 52    		JMP	ZERROR	
 1189                      	
 1190                      	
 1191                      	
 1192                      	; -------------
 1193                      	; HANDLE A 2-OP
 1194                      	; -------------
 1195                      	
 1196   42CD   29 40       	OP2:	AND	#%01000000	; ISOLATE 1ST ARG BIT
 1197   42CF   D0 0C       		BNE	OP2A	
 1198                      	;
 1199                      	; 0 = SHORT IMMEDIATE
 1200                      	;
 1201   42D1   85 64       		sta	ARG1+HI	
 1202   42D3   20 24 92    		jsr	NEXTPC
 1203   42D6   85 63       		sta	ARG1+LO	
 1204   42D8   E6 62       		inc	NARGS	
 1205   42DA   4C E3 42    		jmp	OP2B1	
 1206   42DD   20 3F 43    	OP2A:	jsr	GETVAR	; 1 = VARIABLE
 1207   42E0   20 1C 43    	OP2B:	jsr	V2A1	; [VALUE] TO [ARG1], UPDATE [NARGS]
 1208   42E3   A5 61       	OP2B1:	lda	OPCODE	; RESTORE OPCODE BYTE
 1209   42E5   29 20       		and	#%00100000	; ISOLATE 2ND ARG BIT
 1210   42E7   D0 0A       		bne	OP2C	
 1211   42E9   85 66       		sta	ARG2+HI	
 1212   42EB   20 24 92    		jsr	NEXTPC
 1213   42EE   85 65       		sta	ARG2+LO	
 1214   42F0   4C FE 42    		jmp	OP2D1	
 1215   42F3   20 3F 43    	OP2C:	jsr	GETVAR	; 1 = VARIABLE
 1216   42F6   A5 76       	OP2D:	lda	VALUE+LO	; MOVE 2ND [VALUE]
 1217   42F8   85 65       		sta	ARG2+LO	; INTO [ARG2]
 1218   42FA   A5 77       		lda	VALUE+HI	
 1219   42FC   85 66       		sta	ARG2+HI	
 1220   42FE   E6 62       	OP2D1:	inc	NARGS	; UPDATE ARGUMENT COUNT
 1221                      	
 1222                      		; EXECUTE A 2-OP OR EXTENDED 2-OP
 1223                      	
 1224   4300   A5 61       	OP2EX:	LDA	OPCODE	
 1225   4302   29 1F       		AND	#%00011111	; ISOLATE 0-OP ID BITS
 1226   4304   A8          		TAY		
 1227   4305   B9 34 45    		LDA	OPT2L,Y	
  Wed Jun  7 1989 12:04                                                                                                  Page   20

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

 1228   4308   8D 12 43    		STA	GO2+1+LO	
 1229   430B   B9 14 45    		LDA	OPT2H,Y	
 1230   430E   8D 13 43    		STA	GO2+1+HI	
 1231   4311   20 FF FF    	GO2:	JSR	$FFFF	;DUMMY
 1232   4314   4C B6 40    		JMP	MLOOP	
 1233                      	
 1234                      	; *** ERROR #4 -- ILLEGAL 2-OP ****
 1235                      	
 1236   4317   A9 04       	BADOP2:	LDA	#4	
 1237   4319   4C 0A 52    		JMP	ZERROR	
 1238                      	
 1239                      	
 1240                      	
 1241                      	; --------------------------------------
 1242                      	; MOVE [VALUE] TO [ARG1], UPDATE [NARGS]
 1243                      	; --------------------------------------
 1244                      	
 1245   431C   A5 76       	V2A1:	LDA	VALUE+LO
 1246   431E   85 63       		STA	ARG1+LO
 1247   4320   A5 77       		LDA	VALUE+HI
 1248   4322   85 64       		STA	ARG1+HI
 1249   4324   E6 62       		INC	NARGS
 1250   4326   60          		RTS
 1251                      	
 1252   4327               		END
 1253                      	
 1254   4327               		INCLUDE 	SUBS.ASM
 1255   4327               		STTL "--- OPCODE SUPPORT SUBROUTINES ---"
 1256                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page   21

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1257                      	
 1258                      	; -----------------------
 1259                      	; FETCH A SHORT IMMEDIATE
 1260                      	; -----------------------
 1261                      	
 1262   4327   A9 00       	GETSHT:	LDA	#0	; MSB IS ZERO
 1263   4329   F0 03       		BEQ	GETV	; FETCH LSB FROM Z-CODE
 1264                      	
 1265                      	
 1266                      	; ----------------------
 1267                      	; FETCH A LONG IMMEDIATE
 1268                      	; ----------------------
 1269                      	
 1270   432B   20 24 92    	GETLNG:	JSR	NEXTPC	; GRAB MSB
 1271   432E   85 77       	GETV:	STA	VALUE+HI	
 1272   4330   20 24 92    		JSR	NEXTPC	; GRAB LSB
 1273   4333   85 76       		STA	VALUE+LO	
 1274   4335   60          		RTS		
 1275                      	
 1276                      	
 1277                      	; ----------------
 1278                      	; FETCH A VARIABLE
 1279                      	; ----------------
 1280                      	; FROM INSIDE AN OPCODE (VARIABLE ID IN [A])
 1281                      	
 1282   4336   AA          	VARGET:	TAX		; IF NON-ZERO,
 1283   4337   D0 0B       		BNE	GETVR1	; ACCESS A VARIABLE
 1284   4339   20 66 43    		JSR	POPVAL	; ELSE PULL VAR OFF Z-STACK
 1285   433C   4C 97 43    		JMP	PSHVAL	; WITHOUT ALTERING STACK
 1286                      	
 1287                      	; FROM THE MAIN LOOP (VARIABLE ID IN Z-CODE)
 1288                      	
 1289   433F   20 24 92    	GETVAR:	JSR	NEXTPC	; GRAB VAR-TYPE BYTE
 1290   4342   F0 22       		BEQ	POPVAL	; VALUE IS ON Z-STACK
 1291                      	
 1292                      	; IS VARIABLE LOCAL OR GLOBAL?
 1293                      	
 1294   4344   C9 10       	GETVR1:	CMP	#$10	; IF LOW = 16,
 1295   4346   B0 0D       		BCS	GETVRG	; IT'S GLOBAL
 1296                      	
 1297                      	; HANDLE A LOCAL VARIABLE
 1298                      	
 1299   4348   0A          	GETVRL:	ASL	A		; WORD INDEX
 1300   4349   AA          		TAX		; INTO THE [LOCALS] TABLE
 1301   434A   BD FE 1D    		LDA	LOCALS-2+LO,X	; GRAB LSB
 1302   434D   85 76       		STA	VALUE+LO	
 1303   434F   BD FF 1D    		LDA	LOCALS-2+HI,X	; AND MSB
 1304   4352   85 77       		STA	VALUE+HI	
 1305   4354   60          		RTS		
 1306                      	;
 1307                      	; HANDLE A GLOBAL VARIABLE
 1308                      	;
 1309   4355               	GETVRG:
 1310   4355   20 14 44    		jsr	GVCALC	; GET ADDRESS OF GLOBAL INTO [FPC]
 1311   4358   20 5B 92    		jsr	FETCHB	; and get hi part
 1312   435B   85 77       		sta	VALUE+HI	
 1313   435D   20 C3 8F    		jsr	NEXTFPC	; and point to next part
 1314   4360   20 5B 92    		jsr	FETCHB	; and go get it
 1315   4363   85 76       		sta	VALUE+LO ; SAVE IT
 1316   4365   60          		rts		; AND WE'RE DONE
 1317                      	
 1318                      	; ----------------------------------
 1319                      	; POP Z-STACK INTO [VALUE] AND [X/A]
 1320                      	; ----------------------------------
 1321                      	; ZSTACK DOUBLED IN SIZE FOR EZIP
 1322                      	; SO THIS RTN ALL NEW
 1323                      	
 1324   4366   A5 AF       	POPVAL:	LDA	ZSP+LO	; IF ZSP+LO IS 0
 1325   4368   D0 02       		BNE	POP1	
 1326   436A   85 B0       		STA	ZSP+HI	; MUST DEC. HI (HI = 0 OR 1 ONLY)
 1327   436C   C6 AF       	POP1:	DEC	ZSP+LO	; THEN DEC ZSP LO
 1328   436E   D0 04       		BNE	POP2	
 1329   4370   05 B0       		ORA	ZSP+HI	; LO + HI BOTH 0?
 1330   4372   F0 1E       		BEQ	UNDER	; UNDERFLOW IF ZERO!
 1331   4374   A4 AF       	POP2:	LDY	ZSP+LO	
  Wed Jun  7 1989 12:04                                                                                                  Page   22

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1332   4376   A5 B0       		LDA	ZSP+HI	
 1333   4378   F0 0C       		BEQ	POP3	; BOTTOM HALF OF ZSTACK
 1334   437A   B9 00 0E    		LDA	ZSTKTL,Y	; GET VALUE FROM TOP HALF
 1335   437D   85 76       		STA	VALUE+LO	; OF ZSTACK INTO VALUE & A,X
 1336   437F   AA          		TAX		
 1337   4380   B9 00 10    		LDA	ZSTKTH,Y	
 1338   4383   85 77       		STA	VALUE+HI	
 1339   4385   60          		RTS		
 1340                      	
 1341   4386   B9 00 0D    	POP3:	LDA	ZSTKBL,Y	; GET VALUE FROM BOTTOM HALF
 1342   4389   85 76       		STA	VALUE+LO	; OF ZSTACK INTO VALUE & A,X
 1343   438B   AA          		TAX		
 1344   438C   B9 00 0F    		LDA	ZSTKBH,Y	
 1345   438F   85 77       		STA	VALUE+HI	
 1346   4391   60          		RTS		
 1347                      	
 1348                      	; *** ERROR #5 -- Z-STACK UNDERFLOW ***
 1349   4392   A9 05       	UNDER:	LDA	#5	
 1350   4394   4C 0A 52    		JMP	ZERROR	
 1351                      	
 1352                      	; -----------------------
 1353                      	; PUSH [VALUE] TO Z-STACK
 1354                      	; -----------------------
 1355                      	
 1356   4397   A6 76       	PSHVAL:	LDX	VALUE+LO	
 1357   4399   A5 77       		LDA	VALUE+HI	
 1358                      	
 1359                      	; ---------------------
 1360                      	; PUSH [X/A] TO Z-STACK
 1361                      	; ---------------------
 1362                      	
 1363   439B   48          	PUSHXA:	PHA		; HOLD VALUE IN [A] A SEC.
 1364   439C   A4 AF       		LDY	ZSP+LO	
 1365   439E   A5 B0       		LDA	ZSP+HI	
 1366   43A0   F0 0B       		BEQ	PSHBOT	; ON BOTTOM HALF OF STACK
 1367   43A2   8A          		TXA		
 1368   43A3   99 00 0E    		STA	ZSTKTL,Y	; PUSH VALUE ONTO TOP HALF OF STACK
 1369   43A6   68          		PLA		
 1370   43A7   99 00 10    		STA	ZSTKTH,Y	
 1371   43AA   4C B5 43    		JMP	PSHUPD	; NOW UPDATE POINTER
 1372                      	
 1373   43AD   8A          	PSHBOT:	TXA		; PLACE VALUE ON ZSTACK
 1374   43AE   99 00 0D    		STA	ZSTKBL,Y	
 1375   43B1   68          		PLA		
 1376   43B2   99 00 0F    		STA	ZSTKBH,Y	
 1377   43B5   E6 AF       	PSHUPD:	INC	ZSP+LO	; UPDATE ZSTACK POINTER
 1378   43B7   D0 08       		BNE	PSHEX	
 1379   43B9   A5 AF       		LDA	ZSP+LO	
 1380   43BB   05 B0       		ORA	ZSP+HI	
 1381   43BD   D0 03       		BNE	OVER	; OVERFLOW IF $200
 1382   43BF   E6 B0       		INC	ZSP+HI	; TO 1
 1383   43C1   60          	PSHEX:	RTS		
 1384                      	
 1385                      	; *** ERROR #6 -- Z-STACK OVERFLOW ***
 1386   43C2   A9 06       	OVER:	LDA	#6	
 1387   43C4   4C 0A 52    		JMP	ZERROR	
 1388                      	
 1389                      	
 1390                      	; --------------
 1391                      	; RETURN A VALUE
 1392                      	; --------------
 1393                      	; FROM WITHIN AN OPCODE (VARIABLE ID IN [A])
 1394                      	
 1395   43C7   AA          	VARPUT:	TAX		; IF ZERO,
 1396   43C8   D0 1C       		BNE	PUTVR1	
 1397                      	
 1398                      	; FLUSH TOP WORD OFF STACK
 1399                      	; AND REPLACE WITH [VALUE]
 1400                      	
 1401   43CA   A5 AF       		LDA	ZSP+LO	; IF ZSP+LO =0
 1402   43CC   D0 02       		BNE	VAR1	; THEN HI =1 (GUARDED ELSEWHERE)
 1403   43CE   85 B0       		STA	ZSP+HI	; DECREMENT HI (ONLY 0 OR 1)
 1404   43D0   C6 AF       	VAR1:	DEC	ZSP+LO	; NOW DEC LOW BYTE
 1405   43D2   D0 C3       		BNE	PSHVAL	
 1406   43D4   05 B0       		ORA	ZSP+HI	
  Wed Jun  7 1989 12:04                                                                                                  Page   23

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1407   43D6   F0 BA       		BEQ	UNDER	; ERROR IF [ZSP] BECAME ZERO!
 1408   43D8   D0 BD       		BNE	PSHVAL	
 1409                      	
 1410                      		; RETURN A ZERO
 1411   43DA               	RET0:
 1412   43DA   A9 00       		lda	#0	
 1413   43DC   AA          		tax			; zero's all
 1414                      	;
 1415                      	; RETURN WORD IN [A], [X] (LO,HI) (EZIP EXPANDED TO A WORD)
 1416                      	;
 1417   43DD               	PUTBYT:
 1418   43DD   85 76       		STA	VALUE+LO	
 1419   43DF   86 77       		STX	VALUE+HI	; CLEAR MSB
 1420                      	;
 1421                      	; RETURN [VALUE]
 1422                      	;
 1423   43E1   20 24 92    	PUTVAL:	JSR	NEXTPC	; GET VARIABLE ID BYTE
 1424   43E4   F0 B1       		BEQ	PSHVAL	; [VALUE] GOES TO Z-STACK
 1425                      	;
 1426                      	; LOCAL OR GLOBAL VARIABLE?
 1427                      	;
 1428   43E6   C9 10       	PUTVR1:	CMP	#$10	; IF LOW = 16,
 1429   43E8   B0 0D       		BCS	PUTVLG	; IT'S GLOBAL
 1430                      	;
 1431                      	; PUT A LOCAL VARIABLE
 1432                      	;
 1433   43EA   0A          	PUTVLL:	ASL	A		; WORD INDEX
 1434   43EB   AA          		TAX		; INTO THE [LOCALS] TABLE
 1435   43EC   A5 76       		LDA	VALUE+LO	; GRAB LSB
 1436   43EE   9D FE 1D    		STA	LOCALS-2+LO,X	; SAVE IN LOCAL TABLE
 1437   43F1   A5 77       		LDA	VALUE+HI	; DO SAME TO
 1438   43F3   9D FF 1D    		STA	LOCALS-2+HI,X	; MSB
 1439   43F6   60          		RTS		
 1440                      	;
 1441                      	; RETURN A GLOBAL VARIABLE
 1442                      	;
 1443   43F7               	PUTVLG:
 1444   43F7   20 14 44    		JSR	GVCALC		; put address in [FPC]
 1445   43FA   A5 8E       		lda	FPCBNK		; and move it to stash spot
 1446   43FC   85 91       		sta	SPCBNK
 1447   43FE   A5 8D       		lda	FPCH
 1448   4400   85 90       		sta	SPCH
 1449   4402   A5 8C       		lda	FPCL
 1450   4404   85 8F       		sta	SPCL	
 1451   4406   A5 77       		lda	VALUE+HI	; GET MSB
 1452   4408   20 3A 92    		jsr	STASHB		; and save it
 1453   440B   20 A3 8F    		jsr	NEXTSPC		; point to next byte
 1454   440E   A5 76       		lda	VALUE+LO	; NOW GET LSB
 1455   4410   20 3A 92    		jsr	STASHB		; and send it out
 1456   4413   60          		rts
 1457                      	
 1458                      	; -----------------------
 1459                      	; CALC GLOBAL WORD OFFSET
 1460                      	; -----------------------
 1461                      	; ENTRY: VAR-I BYTE (16-255) IN [A]
 1462                      	; EXIT: ABSOLUTE ADDRESS OF GLOBAL VAR IN [FPC]
 1463   4414               	GVCALC:
 1464   4414   38          		sec		; time for a subtract
 1465   4415   E9 10       		sbc	#$10	; FORM A ZERO-ALIGNED INDEX
 1466   4417   A0 00       		ldy	#0	; MAKE SURE MSB OF OFFSET AND [Y]
 1467   4419   84 79       		sty	I+HI	; ARE CLEARED
 1468   441B   0A          		asl	A	; MULTIPLY OFFSET BY 2
 1469   441C   26 79       		rol	I+HI	; TO WORD-ALIGN IT
 1470   441E   18          		clc		; ADD OFFSET TO ADDR OF GLOBAL TABLE
 1471   441F   65 50       		adc	GLOBAL+LO	; TO FORM THE ABSOLUTE
 1472   4421   85 8C       		sta	FPCL	; ADDRESS OF THE
 1473   4423   A5 79       		lda	I+HI	; DESIRED GLOBAL VARIABLE
 1474   4425   65 51       		adc	GLOBAL+HI	; STORE ADDRESS BACK IN [FPC]
 1475   4427   20 7C 8F    		jsr	SETPC	; now get memory page and bank
 1476   442A   85 8D       		sta	FPCH	; hi part
 1477   442C   84 8E       		sty	FPCBNK	; and bank
 1478   442E               	WCEX:
 1479   442E   60          		rts
 1480                      	
 1481                      	
  Wed Jun  7 1989 12:04                                                                                                  Page   24

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1482                      	; ---------------
 1483                      	; PREDICATE FAILS
 1484                      	; ---------------
 1485                      	
 1486   442F   20 24 92    	PREDF:	JSR	NEXTPC	; GET 1ST BRANCH BYTE
 1487   4432   10 0C       		BPL	PREDB	; DO BRANCH IF BIT 7 OFF
 1488                      	
 1489                      	
 1490                      	; -----------------------
 1491                      	; IGNORE PREDICATE BRANCH
 1492                      	; -----------------------
 1493                      	; ENTRY: 1ST BRANCH BYTE IN [A]
 1494                      	
 1495   4434   29 40       	PREDNB:	AND	#%01000000	; TEST BIT 6
 1496   4436   D0 F6       		BNE	WCEX	; SHORT BRANCH IF SET
 1497   4438   4C 24 92    		JMP	NEXTPC	; ELSE SKIP OVER 2ND BRANCH BYTE
 1498                      	
 1499                      	
 1500                      	; ------------------
 1501                      	; PREDICATE SUCCEEDS
 1502                      	; ------------------
 1503                      	
 1504   443B   20 24 92    	PREDS:	JSR	NEXTPC	; GET 1ST BRANCH BYTE
 1505   443E   10 F4       		BPL	PREDNB	; DON'T BRANCH IF BIT 7 CLEAR
 1506                      	
 1507                      	
 1508                      	; --------------------------
 1509                      	; PERFORM A PREDICATE BRANCH
 1510                      	; --------------------------
 1511                      	; ENTRY: 1ST PRED BYTE IN [A]
 1512                      	
 1513   4440   AA          	PREDB:	TAX		; SAVE HERE
 1514   4441   29 40       		AND	#%01000000	; LONG OR SHORT BRANCH?
 1515   4443   F0 0B       		BEQ	PREDLB	; LONG IF BIT 6 IS CLEAR
 1516                      	
 1517                      		; HANDLE A SHORT BRANCH
 1518                      	
 1519   4445   8A          		TXA		; RESTORE PRED BYTE
 1520   4446   29 3F       		AND	#%00111111	; FORM SHORT OFFSET
 1521   4448   85 76       		STA	VALUE+LO	; USE AS LSB OF BRANCH OFFSET
 1522   444A   A9 00       		LDA	#0	
 1523   444C   85 77       		STA	VALUE+HI	; MSB OF OFFSET IS ZERO
 1524   444E   F0 17       		BEQ	PREDB7	; DO THE BRANCH
 1525                      	
 1526                      		; HANDLE A LONG BRANCH
 1527                      	
 1528   4450   8A          	PREDLB:	TXA		; RESTORE 1ST PRED BYTE
 1529   4451   29 3F       		AND	#%00111111	; FORM MSB OF OFFSET
 1530   4453   AA          		TAX		; SAVE HERE FOR REFERENCE
 1531   4454   29 20       		AND	#%00100000	; CHECK SIGN OF 14-BIT VALUE
 1532   4456   F0 04       		BEQ	DOB2	; POSITIVE IF ZERO, SO USE [X]
 1533   4458   8A          		TXA		; ELSE RESTORE BYTE
 1534   4459   09 E0       		ORA	#%11100000	; EXTEND THE SIGN BIT
 1535   445B   AA          		TAX		; BACK HERE FOR STORAGE
 1536   445C   86 77       	DOB2:	STX	VALUE+HI	
 1537   445E   20 24 92    		JSR	NEXTPC	; FETCH LSB OF 14-BIT OFFSET
 1538   4461   85 76       		STA	VALUE+LO	
 1539                      	
 1540                      		; BRANCH TO Z-ADDRESS IN [VALUE]
 1541                      	
 1542   4463   A5 77       	PREDB1:	LDA	VALUE+HI	; CHECK MSB OF OFFSET
 1543   4465   D0 0E       		BNE	PREDB3	; DO BRANCH IF NZ
 1544   4467   A5 76       	PREDB7:	LDA	VALUE+LO	; IF LSB IS NON-ZERO,
 1545   4469   D0 03       		BNE	PREDB2	; MAKE SURE IT ISN'T 1
 1546   446B   4C 66 79    		JMP	ZRFALS	; ELSE DO AN "RFALSE"
 1547   446E   C9 01       	PREDB2:	CMP	#1	; IF OFFSET = 1
 1548   4470   D0 03       		BNE	PREDB3	
 1549   4472   4C 5B 79    		JMP	ZRTRUE	; DO AN "RTRUE"
 1550                      	
 1551                      	; ENTRY POINT FOR "JUMP"
 1552                      	
 1553   4475   A5 76       	PREDB3:	LDA	VALUE+LO	; SUBTRACT 2 FROM OFFSET
 1554   4477   38          		SEC			; IN [VALUE]
 1555   4478   E9 02       		SBC	#2	
 1556   447A   AA          		TAX			;SAVE	LO BYTE
  Wed Jun  7 1989 12:04                                                                                                  Page   25

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1557   447B   A5 77       		LDA	VALUE+HI	
 1558   447D   E9 00       		SBC	#0	
 1559   447F   85 78       		STA	I+LO	;MSB OF OFFSET = LSB OF [I]
 1560   4481   A0 00       		LDY	#0	; CLEAR THE MSB
 1561   4483   84 79       		STY	I+HI	; OF [I]
 1562   4485   0A          		ASL	A	;	EXTEND THE SIGN OF OFFSET
 1563   4486   26 79       		ROL	I+HI	; INTO MSB OF [I]
 1564   4488   0A          		ASL	A		
 1565   4489   26 79       		ROL	I+HI	; (EZIP)
 1566   448B   0A          	        asl     A
 1567   448C   26 79       	        rol     I+HI    ; (YZIP) ??!!
 1568   448E   8A          		TXA		; GET LSB OF OFFSET
 1569   448F   65 80       		ADC	ZPCL	; ADD LOW 8 BITS OF ZPC
 1570   4491   90 06       		BCC	PREDB5	; IF OVERFLOWED,
 1571   4493   E6 78       		INC	I+LO	; UPDATE UPPER 9 BITS
 1572   4495   D0 02       		BNE	PREDB5	
 1573   4497   E6 79       		INC	I+HI	
 1574   4499   85 80       	PREDB5:	STA	ZPCL	; UPDATE ZPC
 1575   449B   A5 78       		LDA	I+LO	; IF UPPER 9 BITS ARE ZERO,
 1576   449D   05 79       		ORA	I+HI	; NO NEED TO CHANGE PAGES
 1577   449F   F0 12       		BEQ	PREDB6	
 1578   44A1   A5 78       		LDA	I+LO	; ELSE CALC NEW UPPER BITS
 1579   44A3   18          		CLC		
 1580   44A4   65 81       		ADC	ZPCM	
 1581   44A6   85 81       		STA	ZPCM	
 1582   44A8   A5 79       		LDA	I+HI	
 1583   44AA   65 82       		ADC	ZPCH	
 1584   44AC   29 07       		AND	#%00000111
 1585   44AE   85 82       		STA	ZPCH	
 1586   44B0   4C AF 90    		JMP	VLDZPC	;MAKE VALID
 1587   44B3               	PREDB6:			
 1588                      	
 1589                      		; FALL THROUGH ...
 1590                      	
 1591                      	; ----
 1592                      	; NOOP
 1593                      	; ----
 1594                      	
 1595   44B3   60          	ZNOOP:	RTS		
 1596                      	
 1597                      	
 1598                      	; ----------------------
 1599                      	; MOVE [ARG1] TO [VALUE]
 1600                      	; ----------------------
 1601                      	
 1602   44B4   A5 63       	A12VAL:	LDA	ARG1+LO	
 1603   44B6   85 76       		STA	VALUE+LO
 1604   44B8   A5 64       		LDA	ARG1+HI	
 1605   44BA   85 77       		STA	VALUE+HI
 1606   44BC   60          		RTS
 1607                      	
 1608                      	
 1609                      	; -----------------------------------
 1610                      	; INDICATE STATUS LINE REFRESH NEEDED
 1611                      	; -----------------------------------
 1612                      	
 1613   44BD   AD 11 96    	REFRSH:	LDA	ZBEGIN+ZFLAGS+1	; PICK UP LOW BYTE OF FLAG WORD
 1614   44C0   09 04       		ORA	#%00000100	; SET BIT 2
 1615   44C2   8D 11 96    		STA	ZBEGIN+ZFLAGS+1	; AND PUT IT BACK
 1616   44C5   60          		RTS
 1617                      	
 1618                      	
 1619                      	;DECJ RETURNS C=0 WHEN  J=$FFFF
 1620                      	
 1621   44C6   A5 7A       	DECJ:	LDA	J+LO	
 1622   44C8   38          		SEC		
 1623   44C9   E9 01       		SBC	#1	
 1624   44CB   85 7A       		STA	J+LO	
 1625   44CD   A5 7B       		LDA	J+HI	
 1626   44CF   E9 00       		SBC	#0	
 1627   44D1   85 7B       		STA	J+HI	
 1628   44D3   60          		RTS		
 1629                      	
 1630   44D4               		END
 1631                      	
  Wed Jun  7 1989 12:04                                                                                                  Page   26

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1632   44D4               		INCLUDE 	DISPATCH.ASM
 1633                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page   27

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1634   44D4               		STTL "--- OPCODE DISPATCH TABLES ---"
 1635                      	
 1636                      	
 1637                      		; 0-OPS
 1638                      	
 1639   44D4   79          	OPT0H:	DB	>ZRTRUE	;B0
 1640   44D5   79          		DB	>ZRFALS	;B1
 1641   44D6   79          		DB	>ZPRI	;B2
 1642   44D7   79          		DB	>ZPRR	;B3
 1643   44D8   44          		DB	>ZNOOP	;B4
 1644   44D9   8F          		DB	>OSAVE	;B5
 1645   44DA   8F          		DB	>OREST	;B6
 1646   44DB   52          		DB	>ZSTART	;B7
 1647   44DC   79          		DB	>ZRSTAK	;B8
 1648   44DD   79          		DB	>ZCATCH	;B9
 1649   44DE   52          		DB	>ZQUIT	;BA
 1650   44DF   54          		DB	>ZZCRLF	;BB
 1651   44E0   55          		DB	>ZUSL	;BC
 1652   44E1   5B          		DB	>ZVER	;BD
 1653   44E2   41          		DB	>ZEXTOP	;BE
 1654   44E3   79          		DB	>ZORIG	;BF
 1655                      	
 1656   44E4   5B          	OPT0L:	DB	<ZRTRUE	;B0
 1657   44E5   66          		DB	<ZRFALS	;B1
 1658   44E6   6A          		DB	<ZPRI	;B2
 1659   44E7   80          		DB	<ZPRR	;B3
 1660   44E8   B3          		DB	<ZNOOP	;B4
 1661   44E9   61          		DB	<OSAVE	;B5
 1662   44EA   61          		DB	<OREST	;B6
 1663   44EB   B1          		DB	<ZSTART	;B7
 1664   44EC   89          		DB	<ZRSTAK	;B8
 1665   44ED   8F          		DB	<ZCATCH	;B9
 1666   44EE   1E          		DB	<ZQUIT	;BA
 1667   44EF   D4          		DB	<ZZCRLF	;BB
 1668   44F0   B4          		DB	<ZUSL	;BC
 1669   44F1   B6          		DB	<ZVER	;BD
 1670   44F2   F4          		DB	<ZEXTOP	;BE
 1671   44F3   98          		DB	<ZORIG	;BF
 1672                      	
 1673                      		; 1-OPS
 1674                      	
 1675   44F4   79          	OPT1H:	DB	>ZZERO	;80,90,A0
 1676   44F5   79          		DB	>ZNEXT	;81
 1677   44F6   79          		DB	>ZFIRST	;82
 1678   44F7   79          		DB	>ZLOC	;83
 1679   44F8   7A          		DB	>ZPTSIZ	;84
 1680   44F9   7A          		DB	>ZINC	;85
 1681   44FA   7A          		DB	>ZDEC	;86
 1682   44FB   7A          		DB	>ZPRB	;87
 1683   44FC   7F          		DB	>ZCALL1	;88 (EZIP)
 1684   44FD   7A          		DB	>ZREMOV	;89
 1685   44FE   7B          		DB	>ZPRD	;8A
 1686   44FF   7B          		DB	>ZRET	;8B
 1687   4500   7B          		DB	>ZJUMP	;8C
 1688   4501   7B          		DB	>ZPRINT	;8D
 1689   4502   7B          		DB	>ZVALUE	;8E
 1690   4503   7F          		DB	>ZICLL1	;8F
 1691                      	
 1692   4504   9B          	OPT1L:	DB	<ZZERO	;80
 1693   4505   A4          		DB	<ZNEXT	;81
 1694   4506   B3          		DB	<ZFIRST	;82
 1695   4507   DB          		DB	<ZLOC	;83
 1696   4508   01          		DB	<ZPTSIZ	;84
 1697   4509   2C          		DB	<ZINC	;85
 1698   450A   3A          		DB	<ZDEC	;86
 1699   450B   51          		DB	<ZPRB	;87
 1700   450C   B7          		DB	<ZCALL1	;88 (EZIP)
 1701   450D   63          		DB	<ZREMOV	;89
 1702   450E   34          		DB	<ZPRD	;8A
 1703   450F   5B          		DB	<ZRET	;8B
 1704   4510   C6          		DB	<ZJUMP	;8C
 1705   4511   CC          		DB	<ZPRINT	;8D
 1706   4512   DA          		DB	<ZVALUE	;8E
 1707   4513   B0          		DB	<ZICLL1	;8F
 1708                      	
  Wed Jun  7 1989 12:04                                                                                                  Page   28

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE DISPATCH TABLES ---"

 1709                      		; 2-OPS
 1710                      	
 1711   4514   43          	OPT2H:	DB	>BADOP2	;00 (UNDEFINED)
 1712   4515   7F          		DB	>ZEQUAL	;01
 1713   4516   7B          		DB	>ZLESS	;02
 1714   4517   7B          		DB	>ZGRTR	;03
 1715   4518   7B          		DB	>ZDLESS	;04
 1716   4519   7C          		DB	>ZIGRTR	;05
 1717   451A   7C          		DB	>ZIN	;06
 1718   451B   7C          		DB	>ZBTST	;07
 1719   451C   7C          		DB	>ZBOR	;08
 1720   451D   7C          		DB	>ZBAND	;09
 1721   451E   7C          		DB	>ZFSETP	;0A
 1722   451F   7C          		DB	>ZFSET	;0B
 1723   4520   7C          		DB	>ZFCLR	;0C
 1724   4521   7C          		DB	>ZSET	;0D
 1725   4522   7C          		DB	>ZMOVE	;0E
 1726   4523   7D          		DB	>ZGET	;0F
 1727   4524   7D          		DB	>ZGETB	;10
 1728   4525   7D          		DB	>ZGETP	;11
 1729   4526   7D          		DB	>ZGETPT	;12
 1730   4527   7E          		DB	>ZNEXTP	;13
 1731   4528   7E          		DB	>ZADD	;14
 1732   4529   7E          		DB	>ZSUB	;15
 1733   452A   7E          		DB	>ZMUL	;16
 1734   452B   7E          		DB	>ZDIV	;17
 1735   452C   7E          		DB	>ZMOD	;18
 1736   452D   7F          		DB	>ZCALL2	;19 (EZIP)
 1737   452E   7F          		DB	>ZICLL2	;1A
 1738   452F   4E          		DB	>ZCOLOR	;1B
 1739   4530   7F          		DB	>ZTHROW	;1C
 1740   4531   43          		DB	>BADOP2	;1D
 1741   4532   43          		DB	>BADOP2	;1E
 1742   4533   43          		DB	>BADOP2	;1F
 1743                      	
 1744   4534   17          	OPT2L:	DB	<BADOP2	;00 (UNDEFINED)
 1745   4535   84          		DB	<ZEQUAL	;01
 1746   4536   E2          		DB	<ZLESS	;02
 1747   4537   F6          		DB	<ZGRTR	;03
 1748   4538   E8          		DB	<ZDLESS	;04
 1749   4539   01          		DB	<ZIGRTR	;05
 1750   453A   32          		DB	<ZIN		;06
 1751   453B   52          		DB	<ZBTST	;07
 1752   453C   65          		DB	<ZBOR	;08
 1753   453D   75          		DB	<ZBAND	;09
 1754   453E   81          		DB	<ZFSETP	;0A
 1755   453F   95          		DB	<ZFSET	;0B
 1756   4540   AD          		DB	<ZFCLR	;0C
 1757   4541   C9          		DB	<ZSET	;0D
 1758   4542   D6          		DB	<ZMOVE	;0E
 1759   4543   2F          		DB	<ZGET	;0F
 1760   4544   3F          		DB	<ZGETB	;10
 1761   4545   60          		DB	<ZGETP	;11
 1762   4546   C9          		DB	<ZGETPT	;12
 1763   4547   36          		DB	<ZNEXTP	;13
 1764   4548   57          		DB	<ZADD	;14
 1765   4549   64          		DB	<ZSUB	;15
 1766   454A   71          		DB	<ZMUL	;16
 1767   454B   9B          		DB	<ZDIV	;17
 1768   454C   A7          		DB	<ZMOD	;18
 1769   454D   B7          		DB	<ZCALL2	;19 (EZIP)
 1770   454E   B0          		DB	<ZICLL2	;1A
 1771   454F   D0          		DB	<ZCOLOR	;1B
 1772   4550   63          		DB	<ZTHROW	;1C
 1773   4551   17          		DB	<BADOP2	;1D
 1774   4552   17          		DB	<BADOP2	;1E
 1775   4553   17          		DB	<BADOP2	;1F
 1776                      	
 1777                      		; X-OPS
 1778                      	
 1779   4554   7F          	OPTXH:	DB	>ZCALL	;E0
 1780   4555   80          		DB	>ZPUT	;E1
 1781   4556   80          		DB	>ZPUTB	;E2
 1782   4557   80          		DB	>ZPUTP	;E3
 1783   4558   85          		DB	>ZREAD	;E4
  Wed Jun  7 1989 12:04                                                                                                  Page   29

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE DISPATCH TABLES ---"

 1784   4559   81          		DB	>ZPRC	;E5
 1785   455A   81          		DB	>ZPRN	;E6
 1786   455B   81          		DB	>ZRAND	;E7
 1787   455C   82          		DB	>ZPUSH	;E8
 1788   455D   82          		DB	>ZPOP	;E9
 1789   455E   4D          		DB	>ZSPLIT	;EA
 1790   455F   6E          		DB	>ZSCRN	;EB
 1791                      	
 1792                      		; (EZIPS FROM HERE ON)
 1793   4560   7F          		DB	>ZXCALL	;EC
 1794   4561   57          		DB	>ZCLR	;ED
 1795   4562   57          		DB	>ZERASE	;EE
 1796   4563   56          		DB	>ZCURST	;EF
 1797   4564   57          		DB	>ZCURGT	;F0
 1798   4565   70          		DB	>ZLIGHT	;F1
 1799   4566   55          		DB	>ZBUFOUT ;F2
 1800   4567   55          		DB	>ZDIRT	;F3
 1801   4568   57          		DB	>ZDIRIN	;F4 (NOT IMPLEMENTED)
 1802   4569   4E          		DB	>ZSOUND	;F5
 1803   456A   5A          		DB	>ZINPUT	;F6
 1804   456B   82          		DB	>ZINTBL	;F7
 1805   456C   83          		DB	>ZBCOM 	;F8
 1806   456D   7F          		DB	>ZICALL	;F9
 1807   456E   7F          		DB	>ZIXCLL	;FA
 1808   456F   86          		DB	>ZLEX	;FB
 1809   4570   86          		DB	>ZWSTR	;FC
 1810   4571   83          		DB	>ZCOPYT	;FD
 1811   4572   58          		DB	>ZPRNTT	;FE
 1812   4573   84          		DB	>ZASSND	;FF
 1813                      	
 1814   4574   B7          	OPTXL:	DB	<ZCALL	;E0
 1815   4575   B9          		DB	<ZPUT	;E1
 1816   4576   CB          		DB	<ZPUTB	;E2
 1817   4577   E7          		DB	<ZPUTP	;E3
 1818   4578   0E          		DB	<ZREAD	;E4
 1819   4579   2C          		DB	<ZPRC	;E5
 1820   457A   31          		DB	<ZPRN	;E6
 1821   457B   82          		DB	<ZRAND	;E7
 1822   457C   03          		DB	<ZPUSH	;E8
 1823   457D   0A          		DB	<ZPOP	;E9
 1824   457E   DD          		DB	<ZSPLIT	;EA
 1825   457F   5C          		DB	<ZSCRN	;EB
 1826                      	
 1827                      		; (EZIPS FROM HERE ON)
 1828   4580   B7          		DB	<ZXCALL	;EC
 1829   4581   B0          		DB	<ZCLR	;ED
 1830   4582   91          		DB	<ZERASE	;EE
 1831   4583   CD          		DB	<ZCURST	;EF
 1832   4584   25          		DB	<ZCURGT	;F0
 1833   4585   0B          		DB	<ZLIGHT	;F1
 1834   4586   B5          		DB	<ZBUFOUT ;F2
 1835   4587   BF          		DB	<ZDIRT	;F3
 1836   4588   7E          		DB	<ZDIRIN	;F4 (NOT IMPLEMENTED)
 1837   4589   AD          		DB	<ZSOUND	;F5
 1838   458A   D6          		DB	<ZINPUT	;F6
 1839   458B   6A          		DB	<ZINTBL	;F7
 1840   458C   07          		DB	<ZBCOM 	;F8
 1841   458D   B0          		DB	<ZICALL	;F9
 1842   458E   B0          		DB	<ZIXCLL	;FA
 1843   458F   76          		DB	<ZLEX	;FB
 1844   4590   AE          		DB	<ZWSTR	;FC
 1845   4591   16          		DB	<ZCOPYT	;FD
 1846   4592   27          		DB	<ZPRNTT	;FE
 1847   4593   06          		DB	<ZASSND	;FF
 1848                      	
 1849                      	
 1850   4594   8C          	EXTOPH:	DB	>ZSAVE	;100
 1851   4595   8D          		DB	>ZREST	;101
 1852   4596   84          		DB	>ZSHIFT	;102
 1853   4597   84          		DB	>ZASHFT	;103
 1854   4598   58          		DB	>ZFONT	;104
 1855   4599   73          		DB	>ZDISPL	;105
 1856   459A   78          		DB	>ZPICNF	;106
 1857   459B   79          		DB	>ZDCLR	;107
 1858   459C   4E          		DB	>ZMARG	;108
  Wed Jun  7 1989 12:04                                                                                                  Page   30

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE DISPATCH TABLES ---"

 1859   459D   8F          		DB	>ZISAVE	;109
 1860   459E   8F          		DB	>ZIREST	;10A
 1861   459F   42          		DB	>BADEXT	;10B - NOT USED
 1862   45A0   42          		DB	>BADEXT	;10C - NOT USED
 1863   45A1   42          		DB	>BADEXT	;10D - NOT USED
 1864   45A2   42          		DB	>BADEXT	;10E - NOT USED
 1865   45A3   42          		DB	>BADEXT	;10F - NOT USED
 1866   45A4   6E          		DB	>ZWINPOS ;110
 1867   45A5   6F          		DB	>ZWINSIZE ;111
 1868   45A6   70          		DB	>ZWINATTR ;112
 1869   45A7   70          		DB	>ZWINGET  ;113
 1870   45A8   71          		DB	>ZSCROLL  ;114
 1871   45A9   84          		DB	>ZFSTACK  ;115
 1872   45AA   85          		DB	>ZMINFO	  ;116
 1873   45AB   85          		DB	>ZMLIMIT  ;117
 1874   45AC   84          		DB	>ZXPUSH	  ;118
 1875   45AD   71          		DB	>ZWINPUT  ;119
 1876   45AE   58          		DB	>ZPRINTF  ;11A
 1877   45AF   85          		DB	>ZMENU	  ;11B
 1878   45B0   79          		DB	>ZPICSET  ;11c
 1879                      	
 1880          001D        	EXTLEN	EQU	$-EXTOPH
 1881                      	
 1882   45B1   F4          	EXTOPL:	DB	<ZSAVE	;100
 1883   45B2   DF          		DB	<ZREST	;101
 1884   45B3   15          		DB	<ZSHIFT	;102
 1885   45B4   3B          		DB	<ZASHFT	;103
 1886   45B5   D0          		DB	<ZFONT	;104
 1887   45B6   F6          		DB	<ZDISPL	;105
 1888   45B7   98          		DB	<ZPICNF	;106
 1889   45B8   1A          		DB	<ZDCLR	;107
 1890   45B9   50          		DB	<ZMARG	;108
 1891   45BA   62          		DB	<ZISAVE	;109
 1892   45BB   62          		DB	<ZIREST	;10A
 1893   45BC   10          		DB	<BADEXT	;10B - NOT USED
 1894   45BD   10          		DB	<BADEXT	;10C - NOT USED
 1895   45BE   10          		DB	<BADEXT	;10D - NOT USED
 1896   45BF   10          		DB	<BADEXT	;10E - NOT USED
 1897   45C0   10          		DB	<BADEXT	;10F - NOT USED
 1898   45C1   F9          		DB	<ZWINPOS ;110
 1899   45C2   66          		DB	<ZWINSIZE ;111
 1900   45C3   33          		DB	<ZWINATTR ;112
 1901   45C4   9E          		DB	<ZWINGET  ;113
 1902   45C5   66          		DB	<ZSCROLL  ;114
 1903   45C6   BE          		DB	<ZFSTACK  ;115
 1904   45C7   04          		DB	<ZMINFO	  ;116
 1905   45C8   04          		DB	<ZMLIMIT  ;117
 1906   45C9   59          		DB	<ZXPUSH	  ;118
 1907   45CA   AB          		DB	<ZWINPUT  ;119
 1908   45CB   93          		DB	<ZPRINTF  ;11A
 1909   45CC   05          		DB	<ZMENU	  ;11B
 1910   45CD   1A          		DB	<ZPICSET  ;11C
 1911                      	
 1912   45CE               		END
 1913                      	
 1914                      	
 1915   45CE               		TITLE 	"APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
 1916   45CE               		INCLUDE		ZDOS.ASM
 1917   45CE               		STTL "--- ZDOS (SEEKING, READING, WRITING) ---"
 1918                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page   31

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 1919                      	;
 1920                      	; some ProDOS parameter blocks here
 1921                      	;
 1922                      	READ_PB:			; for READING files
 1923   45CE   04          		db	4		; 4 parameters
 1924   45CF   00          	GMREF:	db	0		; refnum
 1925   45D0   0008        		dw	IOBUFF		; read into io buffer
 1926   45D2   0002        		dw	PAGELEN		; 512 byte buffer
 1927   45D4   0000        		dw	0		; length actually read
 1928                      	OPEN_FILE:			; opening up the pure file
 1929   45D6   03          		db	3		; 3 parameters
 1930   45D7   7746        		dw	GAME1NM		; name of pure file
 1931   45D9   0011        		dw	GAME1FIO	; game file buffer
 1932   45DB   00          		db	0		; where refnum goes
 1933   45DC               	PSEEK:	
 1934   45DC   02          		db	2	; 2 pararmeters
 1935   45DD   00          		db	0	; refnum
 1936   45DE   00 00 00    		db 	0,0,0	; 3 byte new file pos
 1937   45E1               	SET_PB:
 1938   45E1   01          		db	1	; just one parameter
 1939   45E2   9B46        		dw	GAMEPL	; where to go to
 1940                      	;
 1941                      	; some messages
 1942                      	;
 1943   45E4   0D 54 61 6B 65 	SWAPSAVE: db    EOL, "Take out save disk and insert ", EOL
        45E9   20 6F 75 74 20 
        45EE   73 61 76 65 20 
        45F3   64 69 73 6B 20 
        45F8   61 6E 64 20 69 
        45FD   6E 73 65 72 74 
        4602   20 0D 
 1944          0020        	SWAPSAVEL EQU   $-SWAPSAVE
 1945   4604   67 61 6D 65 20 	NOSWAP: db      "game disk."
        4609   64 69 73 6B 2E 
 1946          000A        	NOSWAPL EQU     $-NOSWAP
 1947   460E   0D 49 6E 73 65 	INS_MSG: db     EOL,"Insert "
        4613   72 74 20 
 1948          0008        	INS_MSGL EQU    $-INS_MSG
 1949   4616   2C 20 53 69 64 	SIDEMSG: db	", Side "
        461B   65 20 
 1950          0007        	SIDEMSGL EQU	$-SIDEMSG
 1951   461D   2C 20 69 6E 20 	DRIVE_MSG: db ", in Disk Drive "
        4622   44 69 73 6B 20 
        4627   44 72 69 76 65 
        462C   20 
 1952          0010        	DRIVE_MSGL EQU  $-DRIVE_MSG
 1953                      	
 1954   462D   0D 48 61 76 69 	RESEAT_MSG1: db EOL, "Having problems reading side #"
        4632   6E 67 20 70 72 
        4637   6F 62 6C 65 6D 
        463C   73 20 72 65 61 
        4641   64 69 6E 67 20 
        4646   73 69 64 65 20 
        464B   23 
 1955          001F        	RESEAT_MSG1L EQU   $-RESEAT_MSG1
 1956   464C   2E 0D 50 6C 65 	RESEAT_MSG2: db ".",EOL,"Please re-insert it.",EOL,EOL
        4651   61 73 65 20 72 
        4656   65 2D 69 6E 73 
        465B   65 72 74 20 69 
        4660   74 2E 0D 0D 
 1957          0018        	RESEAT_MSG2L EQU $-RESEAT_MSG2
 1958          [01]        		IF CHECKSUM
 1959                      	RETRYING: db	"RETRYING . . ."
 1960                      	RETRYINGL EQU $-RETRYING
 1961          [00]        		ENDIF
 1962                      	;
 1963                      	; place to stash prefixes and names
 1964                      	;
 1965                      	GPRE_PB:		; game prefix spot
 1966   4664   01          		db	1		; 1 parm
 1967   4665   9B46        		dw	GAMEPL		; where to put prefix
 1968   4667   00          	GAMEL:	db	0
 1969   4668               	GAME:	ds	15	; longest name
 1970                      	
 1971   4677               	GAME1NM:
  Wed Jun  7 1989 12:04                                                                                                  Page   32

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 1972   4677               	GAME1NML:
 1973   4677   00          		db	0	; not sure how long
 1974   4678               	GAME1NAME:
 1975   4678               		BLKB	15,0	; room for name
 1976   4687   00          	GAME1REF: db	0	; save refnum here
 1977   4688   00          	GAME1NUM: db	0	; number (0-3) of side
 1978                      	
 1979   4689               	GAME2NM:
 1980   4689               	GAME2NML:
 1981   4689   00          		db	0	; not sure how long
 1982   468A               	GAME2NAME:
 1983   468A               		BLKB	15,0	; room for name
 1984   4699   00          	GAME2REF: db	0	; refnum for game file 2
 1985   469A   00          	GAME2NUM: db	0	; number (0-3) of side
 1986   469B   00          	GAMEPL: db	0		; name of prefix for game file
 1987   469C               	GAMEP:	ds	64-15		; max len
 1988                      	; --------------------
 1989                      	; READ A VIRTUAL PAGE
 1990                      	; --------------------
 1991                      	; ENTRY: V-BLOCK TO READ IN [DBLOCK]
 1992                      	; BUFFER ADDRESS IN [DBUFF]
 1993                      	; DSKBNK SAYS WHERE TO PUT PAGE (AUX OR MAIN)
 1994                      	; EXIT: DATA AT [DBUFF]
 1995                      	;	
 1996   46CD               	RFLAG: ds 1
 1997   46CE               	RCHKS: ds 1
 1998   46CF               	GETDSK:
 1999   46CF   A9 03       	        lda     #RETRY_COUNT    ; set retry
 2000   46D1   85 16       	        sta     RETRIES         ; just use this for now
 2001                      	
 2002          [01]        		IF	DEBUG
 2003                      		lda	#0
 2004                      		sta	RFLAG		; show no retries
 2005                      		sta	RCHKS		; and checksum for it
 2006          [00]        		ENDIF
 2007                      	
 2008   46D3   20 8A 48    		jsr	FINDSEG		; find the segment and point to it
 2009   46D6               	GETDSKL:
 2010   46D6               		SET_MARK PSEEK		; move to the block
 2011   46D6               		PRODOS	$CE, PSEEK
 2012   46D6   20 00 BF    		jsr	$BF00	; ProDOS handler
 2013   46D9   CE          		DB	$CE	; ProDOS function code
 2014   46DA   DC45        		DW	PSEEK	; Function Parameter Block address
 2015   46DC               		.MACEND
 2016   46DC               		.MACEND
 2017   46DC   B0 26       		bcs	GDBAD		; just die then
 2018   46DE   20 56 48    		jsr	READ_DOS	; do the read, thank you
 2019   46E1   90 08       		bcc     GDEX            ; okay, just fine
 2020   46E3   EE CD 46    		inc	RFLAG
 2021   46E6   20 07 47    	        jsr     RETRY           ; try again
 2022   46E9   90 EB       	        bcc     GETDSKL         ; try all over
 2023   46EB               	GDEX:
 2024   46EB   AD D5 45    		lda	READ_PB+RD_LENGTH+HI ; Get how much read in
 2025   46EE   CD D3 45    		cmp	READ_PB+RD_BUFFLEN+HI ; same as we wanted?
 2026   46F1   F0 05       		beq	GDEX1		; yes
 2027   46F3   A9 17       		lda	#23
 2028   46F5   4C 0A 52    		jmp	ZERROR
 2029   46F8               	GDEX1:
 2030          [01]        		IF	DEBUG
 2031                      		lda	RFLAG		; see if we retried
 2032                      		beq	GDEX3		; nope
 2033                      		lda	RCHKS		; did retry checksum?
 2034                      		bne	GDEX2
 2035                      		inc	RCHKS		; now we have
 2036                      		ldy	#0		; save block
 2037                      		sty	$B00
 2038                      		clc
 2039                      	GDEXL:
 2040                      		lda	IOBUFF,Y
 2041                      		sta	$A00,Y
 2042                      		adc	$B00
 2043                      		sta	$B00
 2044                      		iny
 2045                      		bne	GDEXL
 2046                      		beq	GETDSKL
  Wed Jun  7 1989 12:04                                                                                                  Page   33

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2047                      	GDEX2:
 2048                      		ldy	#0
 2049                      		clc
 2050                      		sty	RFLAG
 2051                      	GDEX2L:
 2052                      		lda	IOBUFF,Y
 2053                      		adc	RFLAG
 2054                      		sta	RFLAG
 2055                      		iny
 2056                      		bne	GDEX2L
 2057                      		lda	RFLAG
 2058                      		cmp	$B00
 2059                      		beq	GDEX3
 2060                      		lda	#24
 2061                      		jmp	ZERROR
 2062          [00]        		ENDIF
 2063   46F8               	GDEX3:
 2064   46F8   A9 08       		lda	#>IOBUFF	; first   256 byte page
 2065   46FA   20 5D 48    		jsr	COPY_DATA	; and copy from IOBUFF to DBUFF
 2066   46FD   E6 B7       		inc	DBUFF+HI	; point to next one
 2067   46FF   A9 09       		lda	#>IOBUFF+1	; next 256 byte page
 2068   4701   4C 5D 48    		jmp	COPY_DATA	; and copy it over
 2069   4704               	GDBAD:
 2070   4704   4C 74 47    		jmp	DISK_FATAL	; just die then
 2071   4707               	RETRY:
 2072          [01]        		IF	CHECKSUM
 2073                      		DLINE	RETRYING	; show me the way to go  home
 2074          [00]        		ENDIF
 2075                      	
 2076   4707   C6 16       	        dec     RETRIES         ; count this try
 2077   4709   30 F9       	        bmi     GDBAD           ; it's dead jim
 2078   470B   F0 2F       		beq	RETRY0		; ask for reset
 2079   470D   C9 01       		cmp	#1		; down to last time?
 2080   470F   D0 61       	        bne     RETRYX          ; just try again
 2081   4711   AD DE 45    		lda	PSEEK+SM_FPOS+0
 2082   4714   48          		pha
 2083   4715   AD DF 45    		lda	PSEEK+SM_FPOS+1
 2084   4718   48          		pha
 2085   4719   AD E0 45    		lda	PSEEK+SM_FPOS+2
 2086   471C   48          		pha
 2087   471D   A9 00       		lda	#0		; seek to zero
 2088   471F   8D DE 45    		sta	PSEEK+SM_FPOS+0 ; save here for now
 2089   4722   8D DF 45    		sta	PSEEK+SM_FPOS+1 ; save here for now
 2090   4725   8D E0 45    		sta	PSEEK+SM_FPOS+2 ; save here for now
 2091   4728               		SET_MARK PSEEK		; move to the block
 2092   4728               		PRODOS	$CE, PSEEK
 2093   4728   20 00 BF    		jsr	$BF00	; ProDOS handler
 2094   472B   CE          		DB	$CE	; ProDOS function code
 2095   472C   DC45        		DW	PSEEK	; Function Parameter Block address
 2096   472E               		.MACEND
 2097   472E               		.MACEND
 2098   472E   68          		pla
 2099   472F   8D E0 45    		sta	PSEEK+SM_FPOS+2
 2100   4732   68          		pla
 2101   4733   8D DF 45    		sta	PSEEK+SM_FPOS+1
 2102   4736   68          		pla
 2103   4737   8D DE 45    		sta	PSEEK+SM_FPOS+0
 2104   473A   90 36       		bcc	RETRYX		; all done
 2105   473C               	RETRY0:
 2106   473C   48          	        pha                     ; save disk error
 2107   473D   20 A9 4C    	        jsr     SWAP2INFOW      ; go to window zero
 2108   4740               	        DLINE   RESEAT_MSG1     ; ask to move the disk around
 2109   4740   A2 2D       		ldx	#<RESEAT_MSG1	; get part of RESEAT_MSG1
 2110   4742   A9 46       		lda	#>RESEAT_MSG1	; get other part of string
 2111          [01]        		IFMA	2		; check to see if length passed in
 2112                      		ldy			; then just fetch it
 2113          [01]        		ELSE
 2114   4744   A0 1F       		ldy	#RESEAT_MSG1L	; get length of string
 2115          [00]        		ENDIF
 2116   4746   20 6B 4C    		jsr	DLINE		; print the string
 2117   4749               		.MACEND
 2118   4749   AD CF 45    	        lda     GMREF           ; get ref num
 2119   474C   CD 99 46    	        cmp     GAME2REF        ; game2?
 2120   474F   D0 08       	        bne     RETRY1          ; nope
 2121   4751   AC 89 46    	        ldy     GAME2NML        ; get length
  Wed Jun  7 1989 12:04                                                                                                  Page   34

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2122   4754   B9 89 46    	        lda     GAME2NM,Y       ; and side #
 2123   4757   D0 06       	        bne     RETRY2          ; and continue
 2124   4759               	RETRY1:
 2125   4759   AC 77 46    	        ldy     GAME1NML        ; get length
 2126   475C   B9 77 46    	        lda     GAME1NM,Y       ; and side #
 2127   475F               	RETRY2:
 2128   475F   20 82 5D    	        jsr     CHAR            ; send char out there
 2129   4762               	        DLINE   RESEAT_MSG2     ; and finish statement
 2130   4762   A2 4C       		ldx	#<RESEAT_MSG2	; get part of RESEAT_MSG2
 2131   4764   A9 46       		lda	#>RESEAT_MSG2	; get other part of string
 2132          [01]        		IFMA	2		; check to see if length passed in
 2133                      		ldy			; then just fetch it
 2134          [01]        		ELSE
 2135   4766   A0 18       		ldy	#RESEAT_MSG2L	; get length of string
 2136          [00]        		ENDIF
 2137   4768   20 6B 4C    		jsr	DLINE		; print the string
 2138   476B               		.MACEND
 2139   476B   68          	        pla                     ; get disk error back
 2140   476C   20 8A 47    	        jsr     DISK_ERR        ; tell the error
 2141   476F   20 C9 4C    	        jsr     SWAPBACK        ; back to current window
 2142   4772               	RETRYX:
 2143   4772   18          	        clc                     ; show goodness
 2144   4773   60          	        rts                     ; and done
 2145                      	;
 2146                      	; this is the fatal error spot
 2147                      	;
 2148   4774               	DISK_FATAL:
 2149   4774   20 8A 47    		jsr	DISK_ERR	; print out problem
 2150   4777               	DRIVE_ERR:
 2151   4777   A9 0E       		lda	#14
 2152   4779   4C 0A 52    		jmp	ZERROR		; DRIVE ACCESS ERROR
 2153                      	;
 2154                      	; this routine prints out the string associated with the error and 
 2155                      	; returns with the carry set, like most routines do when there is
 2156                      	; an error.  The error should be in [A].
 2157                      	;
 2158   477C   50 72 6F 44 4F 	UNK_DISK:	db	"ProDOS error $"
        4781   53 20 65 72 72 
        4786   6F 72 20 24 
 2159          000E        	UNK_DISKL	EQU	$-UNK_DISK
 2160                      	
 2161   478A               	DISK_ERR:
 2162   478A   48          		pha			; save [A]
 2163   478B   20 A9 4C    		jsr	SWAP2INFOW	; point to information window
 2164   478E   68          		pla			; get it back
 2165                      	
 2166   478F   A2 1B       		ldx	#ELISTL		; scan the error table
 2167   4791               	DSKE:
 2168   4791   DD 6E 6D    		cmp	ELIST,X		;  is it this one
 2169   4794   F0 16       		beq	DSKE1		; ayyup
 2170   4796   CA          		dex			; now skip the address
 2171   4797   CA          		dex			; of the description
 2172   4798   CA          		dex			; point to next error number
 2173   4799   10 F6       		bpl	DSKE		; jump to start
 2174                      	;
 2175                      	; if we are here print out unknown error and it's value
 2176                      	;
 2177   479B   48          		pha			; save [A]
 2178   479C               		DLINE	UNK_DISK	; show error
 2179   479C   A2 7C       		ldx	#<UNK_DISK	; get part of UNK_DISK
 2180   479E   A9 47       		lda	#>UNK_DISK	; get other part of string
 2181          [01]        		IFMA	2		; check to see if length passed in
 2182                      		ldy			; then just fetch it
 2183          [01]        		ELSE
 2184   47A0   A0 0E       		ldy	#UNK_DISKL	; get length of string
 2185          [00]        		ENDIF
 2186   47A2   20 6B 4C    		jsr	DLINE		; print the string
 2187   47A5               		.MACEND
 2188   47A5   68          		pla			; get [A]
 2189   47A6   20 D3 47    		jsr	HEXNUM		; print [A]
 2190   47A9   4C CB 47    		jmp	DSK_EXIT	; done
 2191   47AC               	DSKE1:
 2192   47AC   E8          		inx			; point to string address
 2193   47AD   BD 6E 6D    		lda	ELIST,X		; get lo part
 2194   47B0   85 7E       		sta	L+LO		; save it
  Wed Jun  7 1989 12:04                                                                                                  Page   35

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2195   47B2   E8          		inx			; point to hi part
 2196   47B3   BD 6E 6D    		lda	ELIST,X		; get hi part
 2197   47B6   AA          		tax			; save here
 2198   47B7   85 7F       		sta	L+HI		; and here
 2199   47B9   A0 00       		ldy	#0		; for offset
 2200   47BB   B1 7E       		lda	(L),Y		; get length of string
 2201   47BD   A8          		tay			; save in y
 2202   47BE   E6 7E       		inc	L+LO		; point past length
 2203   47C0   A5 7E       		lda	L+LO		; get it
 2204   47C2   D0 01       		bne	DSKPR		; for printing
 2205   47C4   E8          		inx			; wrapped
 2206   47C5               	DSKPR:
 2207   47C5   8A          		txa			; hi part in a
 2208   47C6   A6 7E       		ldx	L+LO		; lo part in X
 2209   47C8   20 6B 4C    		jsr	DLINE		; print out message
 2210   47CB               	DSK_EXIT:	
 2211   47CB   20 E0 8C    		jsr	GETRET		; wait for RETURN
 2212   47CE   20 C9 4C    		jsr	SWAPBACK	; all done
 2213   47D1   38          		sec			; show badness again
 2214   47D2   60          		rts			; and be done with it
 2215                      	;
 2216                      	; HEXNUM - print out the HEX value of [A] at the current cursor
 2217                      	; 	location
 2218                      	;
 2219   47D3               	HEXNUM:
 2220   47D3   48          		pha
 2221   47D4   4A          		lsr	A
 2222   47D5   4A          		lsr	A
 2223   47D6   4A          		lsr	A
 2224   47D7   4A          		lsr	A
 2225   47D8   20 DC 47    		jsr	NIB1
 2226   47DB   68          		pla
 2227   47DC               	NIB1:
 2228   47DC   29 0F       		and	#%00001111
 2229   47DE   A8          		tay
 2230   47DF   B9 E6 47    		lda	HCHARS,Y
 2231   47E2   20 82 5D    		jsr	CHAR			; print it out
 2232   47E5   60          		rts
 2233   47E6   30 31 32 33 34 	HCHARS:	DB	"0123456789ABCDEF"
        47EB   35 36 37 38 39 
        47F0   41 42 43 44 45 
        47F5   46 
 2234                      	
 2235                      	; ----------------------
 2236                      	; WRITE [DBUFF] TO DISK
 2237                      	; ----------------------
 2238                      	; ENTRY: File already open and positioned, ready to be written to
 2239                      	;	 from page in (DBUFF).  Writes out 512bytes, starting @ DBUFF.
 2240                      	; EXIT: CARRY CLEAR IF OKAY, SET IF FAILED
 2241                      	
 2242   47F6               	PUTDSK:
 2243   47F6   A6 B8       		ldx	DSKBNK		; get bank
 2244   47F8   A0 00       		ldy	#0		; clear Y
 2245   47FA   A9 08       	        lda     #>IOBUFF        ; first buffer
 2246   47FC   20 EE 00    		jsr	SAVE_DATA	; and copy from DBUFF to IOBUFF
 2247                      	
 2248          [01]        		IF	CHECKSUM == 1
 2249                      		lda	#>IOBUFF
 2250                      		jsr	CKS_BLOCK
 2251          [00]        		ENDIF
 2252                      	
 2253   47FF   20 34 48    		jsr	NEXT_DBUFF	; point to next buffer
 2254   4802   A6 B8       	        ldx     DSKBNK          ; go get new DSKBNK
 2255   4804   A0 00       	        ldy     #0              ; clear Y again
 2256   4806   A9 09       	        lda     #>IOBUFF+1      ; top part
 2257   4808   20 EE 00    	        jsr     SAVE_DATA       ; copy to IOBUFF
 2258                      	
 2259          [01]        		IF	CHECKSUM == 1
 2260                      		lda	#>IOBUFF+1
 2261                      		jsr	CKS_BLOCK
 2262          [00]        		ENDIF
 2263                      	
 2264   480B   20 34 48    	        jsr     NEXT_DBUFF      ; count buffer
 2265   480E   4C 4F 48    		jmp	WRITE_DOS	; and now write it
 2266                      	; ---------------------
  Wed Jun  7 1989 12:04                                                                                                  Page   36

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2267                      	; READ DBLOCK FROM DISK
 2268                      	; ---------------------
 2269                      	; CALLED BY RESTORE
 2270                      	; ENTER: with file already set up as it DBUFF
 2271                      	;	L+LO == # of 256k blocks to read
 2272                      	;
 2273   4811               	GETRES:
 2274   4811   A5 7E       		lda	L+LO		; get # of blocks
 2275   4813   8D D3 45    		sta	READ_PB+RD_BUFFLEN+HI
 2276   4816   20 56 48    		jsr	READ_DOS	
 2277   4819   A2 02       		ldx	#>PAGELEN	; get starting number of pages
 2278   481B   8E D3 45    		stx	READ_PB+RD_BUFFLEN+HI
 2279   481E   90 01       		bcc	GTROK		; everything is fine
 2280   4820   60          		rts			; error if c == set
 2281   4821               	GTROK:
 2282   4821   A9 08       		lda	#>IOBUFF	; start at first block
 2283   4823   85 7F       		sta	L+HI		; we can use L+HI
 2284   4825               	GTRLOOP:
 2285   4825   A5 7F       		lda 	L+HI		; doing this block
 2286                      	
 2287          [01]        	        IF CHECKSUM == 1
 2288                      	        jsr     CKS_BLOCK       ; check check sum        
 2289          [00]        	        ENDIF
 2290                      	
 2291   4827   20 5D 48    		jsr	COPY_DATA	; and copy from IOBUFF to DBUFF
 2292   482A   20 34 48    		jsr	NEXT_DBUFF	; check for wrap
 2293   482D   E6 7F       		inc	L+HI		; count this block
 2294   482F   C6 7E       		dec	L+LO		; count this block
 2295   4831   D0 F2       		bne	GTRLOOP		; do next one
 2296   4833   60          		rts			; all finished
 2297                      	;
 2298                      	; NEXT_DBUFF
 2299                      	;       increment DBUFF to count the 2 pages done
 2300                      	;
 2301   4834               	NEXT_DBUFF:
 2302   4834   E6 B7       		inc	DBUFF+HI	; point to next page
 2303   4836   A5 B7       		lda	DBUFF+HI	; see where we are
 2304   4838   C9 BF       		cmp	#>PRGLBL	; wrapping?
 2305   483A   D0 10       		bne	GTREX		; okay then
 2306   483C   A5 B8       		lda	DSKBNK		; which bank we be in
 2307   483E   D0 06       		bne	GTR1		; aux, so go to page 3
 2308   4840   E6 B8       		inc	DSKBNK		; point to aux
 2309   4842   A9 40       		lda	#Z2PAGE		; start of page 2
 2310   4844   D0 06       	        bne     GTREX           ; so tell me which page
 2311   4846               	GTR1:
 2312   4846   A9 FF       		lda	#P3BANK		; show page 3 bank
 2313   4848   85 B8       		sta	DSKBNK		; okay
 2314   484A   A9 D0       		lda	#Z3PAGE		; page 3 of things
 2315   484C               	GTREX:
 2316   484C   85 B7       		sta	DBUFF+HI	; saved
 2317   484E   60          		rts			; all done		
 2318                      	;
 2319   484F               	WRITE_DOS:
 2320   484F               		WRITE	WRITE_SV	; write out save buffer
 2321   484F               		PRODOS	$CB, WRITE_SV
 2322   484F   20 00 BF    		jsr	$BF00	; ProDOS handler
 2323   4852   CB          		DB	$CB	; ProDOS function code
 2324   4853   0D8B        		DW	WRITE_SV	; Function Parameter Block address
 2325   4855               		.MACEND
 2326   4855               		.MACEND
 2327   4855   60          		rts			; done
 2328   4856               	READ_DOS:
 2329   4856               		READ	READ_PB		; read it
 2330   4856               		PRODOS	$CA, READ_PB
 2331   4856   20 00 BF    		jsr	$BF00	; ProDOS handler
 2332   4859   CA          		DB	$CA	; ProDOS function code
 2333   485A   CE45        		DW	READ_PB	; Function Parameter Block address
 2334   485C               		.MACEND
 2335   485C               		.MACEND
 2336   485C   60          		rts			; go home
 2337                      	;
 2338                      	; COPY_DATA - 
 2339                      	; now move the data from iobuff to dbuff (in some bank)
 2340                      	;	which part of IOBUFF is in [a] ($08 - $0B)
 2341                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page   37

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2342   485D               	COPY_DATA:
 2343   485D   8D 79 48    		sta	SDLP3+2		; self-modify code to get from IOBUFF
 2344   4860   8D 02 C0    		sta	RDBNK+MAIN	; read from main
 2345   4863   A6 B8       		ldx	DSKBNK		; get which bank it's going to
 2346   4865   30 05       		bmi	CPD1		; oh oh, third bank
 2347   4867   9D 04 C0    		sta	WRTBNK,X	; and select that bank for writing
 2348   486A   10 07       		bpl	CPD2		; okay, bank selected
 2349   486C               	CPD1:
 2350   486C   A5 B7       		lda	DBUFF+HI	; get from this zero page
 2351   486E   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
 2352   4871   85 B7       		sta	DBUFF+HI	; and save this in aux mem ZP
 2353   4873               	CPD2:
 2354   4873   A0 00       		ldy	#0		; start at beginning
 2355   4875   84 B6       		sty	DBUFF+LO	; just to be sure
 2356   4877               	SDLP3:
 2357   4877   B9 00 08    		lda	IOBUFF,Y	; this becomes modified!
 2358   487A   91 B6       		sta	(DBUFF),Y	; to [DBUFF]
 2359   487C   C8          		iny		
 2360   487D   D0 F8       		bne	SDLP3	
 2361   487F   8D 08 C0    		sta	ALTZP+MAIN	; talk about main page again
 2362   4882   8D 04 C0    		sta	WRTBNK+MAIN	; end up back at main
 2363   4885   60          		rts
 2364                      	;
 2365                      	; Segment table handling routines
 2366                      	;
 2367                      	
 2368                      	;
 2369                      	; FINDSEG - find the Virtual page in DBLOCK by searching through
 2370                      	;	the SEGTBL.
 2371                      	;
 2372   4886               	DISKPAGE: ds	2		; spot to put starting disk page
 2373   4888               	BIGPAGE:  ds	2		; DBLOCK/2 for 512 pages
 2374   488A               	FINDSEG:
 2375   488A   AD 5F 6C    		lda	DBLOCK+HI	; work with MSB first
 2376   488D   4A          		lsr	A		; /2
 2377   488E   8D 89 48    		sta	BIGPAGE+HI
 2378   4891   AD 5E 6C    		lda	DBLOCK+LO	; now LSB
 2379   4894   6A          		ror	A		; /2
 2380   4895   8D 88 48    		sta	BIGPAGE+LO
 2381   4898   AD 88 46    		lda	GAME1NUM	; get number for disk 1
 2382   489B   20 01 49    		jsr	SCANSEG		; scan through the current disk table
 2383   489E   AD 87 46    		lda	GAME1REF	; save refnum
 2384   48A1   90 0E       		bcc	FNDSG1		; found it, figger it out
 2385   48A3   AD 9A 46    		lda	GAME2NUM	; get number for disk 2
 2386   48A6   20 01 49    		jsr	SCANSEG		; see if it is here
 2387   48A9   AD 99 46    		lda	GAME2REF	; save refnum
 2388   48AC   90 03       		bcc	FNDSG1		; ayyup
 2389   48AE   20 79 49    		jsr	SEGQUEST	; get correct disk/file with segment
 2390   48B1               	FNDSG1:
 2391   48B1   8D DD 45    		sta	PSEEK+SM_REFNUM	; for seeking
 2392   48B4   8D CF 45    		sta	GMREF		; and for reading
 2393   48B7   B1 1E       		lda	(DSEGS),Y	; pick up MSB of disk page
 2394   48B9   8D 87 48    		sta	DISKPAGE+HI	; save it
 2395   48BC   C8          		iny			; point to LSB
 2396   48BD   B1 1E       		lda	(DSEGS),Y	; get it
 2397   48BF   8D 86 48    		sta	DISKPAGE+LO	; save it
 2398                      	; now point to Starting page again
 2399   48C2   88          		dey
 2400   48C3   88          		dey
 2401   48C4   88          		dey
 2402   48C5   88          		dey
 2403   48C6   AD 88 48    		lda	BIGPAGE+LO	; LSB of desired page
 2404   48C9   38          		sec			; doing subtract
 2405   48CA   F1 1E       		sbc	(DSEGS),Y	; get rid of LSB of starting page
 2406   48CC   8D DF 45    		sta	PSEEK+SM_FPOS+1 ; save here for now
 2407   48CF   88          		dey			; point to MSB of starting page
 2408   48D0   AD 89 48    		lda	BIGPAGE+HI	; get DBLOCK MSB
 2409   48D3   F1 1E       		sbc	(DSEGS),Y	; get offset
 2410   48D5   8D E0 45    		sta	PSEEK+SM_FPOS+2 ; save here temporarily
 2411   48D8   18          		clc			; now add offset to starting disk page
 2412   48D9   AD 86 48    		lda	DISKPAGE+LO	; get starting disk page
 2413   48DC   6D DF 45    		adc	PSEEK+SM_FPOS+1	; add inter-segment offset
 2414   48DF   8D DF 45    		sta	PSEEK+SM_FPOS+1	; save LSB
 2415   48E2   AD 87 48    		lda	DISKPAGE+HI	; get MSB of segment disk page
 2416   48E5   6D E0 45    		adc	PSEEK+SM_FPOS+2	; add inter-segment offset
  Wed Jun  7 1989 12:04                                                                                                  Page   38

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2417   48E8   8D E0 45    		sta	PSEEK+SM_FPOS+2	; save MSB of disk page
 2418   48EB   0E DF 45    		asl	PSEEK+SM_FPOS+1	; *2 for 256Kb pages
 2419   48EE   2E E0 45    		rol	PSEEK+SM_FPOS+2	; okay, we did
 2420   48F1   AD 5E 6C    		lda	DBLOCK+LO	; check to see which page in 512 we are
 2421   48F4   29 01       		and	#$01		; if odd, then add one more
 2422   48F6   F0 08       		beq	FNDEX		; all done then
 2423   48F8   EE DF 45    		inc	PSEEK+SM_FPOS+1	; one more page
 2424   48FB   D0 03       		bne	FNDEX		; all done if no wrap
 2425   48FD   EE E0 45    		inc	PSEEK+SM_FPOS+2	; nother page
 2426   4900               	FNDEX:
 2427   4900   60          		rts			; done
 2428                      	;
 2429                      	; SCANSEG - look through the current segment table for the desired
 2430                      	;	address found in BIGPAGE.  Return with Y pointing to disk page
 2431                      	;	and carry cleared if found.  Otherwise, return carry set.
 2432                      	;	[A] = which side number we are checking (0-n)
 2433                      	;
 2434   4901               	SCANSEG:
 2435   4901   48          		pha			; save which disk
 2436   4902   0A          		asl	A		; make word index
 2437   4903   AA          		tax			; make it an index
 2438   4904   BD D0 1D    		lda	DSKSEG+LO,X	; get LSB
 2439   4907   85 1E       		sta	DSEGS+LO
 2440   4909   BD D1 1D    		lda	DSKSEG+HI,X
 2441   490C   85 1F       		sta	DSEGS+HI
 2442   490E   A0 05       		ldy	#SGTNSEG+1	; point to segment count
 2443   4910   B1 1E       		lda	(DSEGS),Y	; get it
 2444   4912   AA          		tax			; use x as counter
 2445   4913   68          		pla			; get which side 
 2446   4914   A8          		tay			; is it side zero
 2447   4915   D0 04       		bne	SCANSG1		; nope
 2448   4917   A0 0E       		ldy	#SGTSEG+6	; skip first entry, cuz they're preload
 2449   4919   D0 02       		bne	SCANNING	; okay ready to go
 2450   491B               	SCANSG1:
 2451   491B   A0 08       		ldy	#SGTSEG		; begin at beginning
 2452   491D               	SCANNING:
 2453   491D   B1 1E       		lda	(DSEGS),Y	; get MSB of start
 2454   491F   CD 89 48    		cmp	BIGPAGE+HI	; check against block we want
 2455   4922   F0 06       		beq	SCAN1		; might be okay
 2456   4924   90 0F       		bcc	SCAN2		; PAGE > start seg, check end seg
 2457   4926   C8          	        iny                     ; LSB of start
 2458   4927               	SCAN0:
 2459   4927   C8          	        iny                     ; MSB of end
 2460   4928   B0 1F       	        bcs     NEXTSEG         ; not this one
 2461   492A               	SCAN1:
 2462   492A   C8          		iny			; point to LSB of start
 2463   492B   B1 1E       		lda	(DSEGS),Y	; get LSB
 2464   492D   CD 88 48    		cmp	BIGPAGE+LO	; check against desired LSB
 2465   4930   F0 20       		beq	GOTSEG		; we found it
 2466   4932   B0 F3       		bcs	SCAN0		; DBLOCK LSB < then start LSB, not found
 2467   4934   88          		dey			; point back to MSB of start
 2468   4935               	SCAN2:
 2469   4935   C8          		iny			; LSB of start
 2470   4936   C8          	 	iny			; MSB of end
 2471   4937   B1 1E       		lda	(DSEGS),Y	; get MSB of end
 2472   4939   CD 89 48    		cmp	BIGPAGE+HI	; check against DBLOCK MSB
 2473   493C   90 0B       		bcc	NEXTSEG 	; end < DBLOCK, check next segment
 2474   493E   D0 13       		bne	GOTSEG1		; end > DBLOCK, must be in this segment
 2475   4940   C8          		iny			; point to end LSB
 2476   4941   B1 1E       		lda	(DSEGS),Y	; get LSB
 2477   4943   CD 88 48    		cmp	BIGPAGE+LO	; how does it compare to desired LSB
 2478   4946   B0 0C       		bcs	GOTSEG2		; it's <= end, so it is here
 2479   4948   88          		dey			; point back to MSB
 2480   4949               	NEXTSEG:
 2481   4949   C8          		iny			; point to LSB of end
 2482   494A   C8          		iny			; MSB of disk page
 2483   494B   C8          		iny			; LSB of disk page
 2484   494C   C8          		iny			; MSB of next start page
 2485   494D   CA          		dex			; count this segment
 2486   494E   D0 CD       		bne	SCANNING	; check this segment
 2487                      	
 2488   4950   38          		sec			; show not on this disk
 2489   4951   60          		rts			; and done
 2490   4952               	GOTSEG:
 2491   4952   C8          		iny			; MSB of end page
  Wed Jun  7 1989 12:04                                                                                                  Page   39

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2492   4953               	GOTSEG1:
 2493   4953   C8          		iny			; LSB of end page
 2494   4954               	GOTSEG2:
 2495   4954   C8          		iny			; MSB of disk offset
 2496   4955   18          		clc			; show we found it
 2497   4956   60          		rts			; all done
 2498                      	;
 2499                      	; SEGQUEST - find the correct disk/file with the desired page on
 2500                      	;	it.  Returns SCANSEG's stuff.
 2501                      	;
 2502   4957               	DISKCNTR:	ds	1	; disk count down
 2503   4958               	PAGENF:
 2504   4958   50 61 67 65 20 		db	"Page not found in segment table: "
        495D   6E 6F 74 20 66 
        4962   6F 75 6E 64 20 
        4967   69 6E 20 73 65 
        496C   67 6D 65 6E 74 
        4971   20 74 61 62 6C 
        4976   65 3A 20 
 2505          0021        	PAGENFL	EQU	$-PAGENF
 2506   4979               	SEGQUEST:
 2507   4979   A9 01       		lda	#1		; start at first disk
 2508   497B   8D 57 49    		sta	DISKCNTR	; init counter
 2509   497E               	SEGQL:
 2510   497E   AD 57 49    		lda	DISKCNTR	; get disk
 2511   4981   CD 01 19    		cmp	SEGTBL+SGTDISKS+1	; looked at all the disks?
 2512   4984   D0 24       		bne	SEGQL1		; nope
 2513                      	;
 2514                      	; as a last resort, check disk 1, the boot disk
 2515                      	;
 2516   4986   A9 00       		lda	#0		; set up DISKCNTR
 2517   4988   8D 57 49    		sta	DISKCNTR	; we did
 2518   498B   20 01 49    		jsr	SCANSEG		; see if it is there
 2519   498E   90 27       		bcc	SEGQ1		; we found it
 2520                      	
 2521   4990               		DLINE	PAGENF		; page not found
 2522   4990   A2 58       		ldx	#<PAGENF	; get part of PAGENF
 2523   4992   A9 49       		lda	#>PAGENF	; get other part of string
 2524          [01]        		IFMA	2		; check to see if length passed in
 2525                      		ldy			; then just fetch it
 2526          [01]        		ELSE
 2527   4994   A0 21       		ldy	#PAGENFL	; get length of string
 2528          [00]        		ENDIF
 2529   4996   20 6B 4C    		jsr	DLINE		; print the string
 2530   4999               		.MACEND
 2531   4999   AD 89 48    		lda	BIGPAGE+HI	; show MSB
 2532   499C   20 D3 47    		jsr	HEXNUM		; printed
 2533   499F   AD 88 48    		lda	BIGPAGE+LO	; and LSB
 2534   49A2   20 D3 47    		jsr	HEXNUM		; we did
 2535                      	
 2536   49A5   A9 11       		lda	#17		; bad page 
 2537   49A7   4C 0A 52    		jmp	ZERROR		; die a horrible death
 2538   49AA               	SEGQL1:
 2539   49AA   AD 57 49    		lda	DISKCNTR	; get which disk we be working on
 2540   49AD   20 01 49    		jsr	SCANSEG		; find out if it is here
 2541   49B0   90 05       		bcc	SEGQ1		; it is, so open up file
 2542   49B2   EE 57 49    		inc	DISKCNTR	; not in this disk
 2543   49B5   D0 C7       		bne	SEGQL		; and try again
 2544                      	;
 2545                      	; we have found the disk it is in, so ask for it if necessary
 2546                      	;
 2547   49B7               	SEGQ1:
 2548   49B7   98          		tya			; save the y pointer
 2549   49B8   48          		pha			; it is saved
 2550   49B9   AD 57 49    		lda	DISKCNTR	; get which disk we found it under
 2551   49BC   20 C6 49    		jsr	FETCH_FILE	; go get the disk desired
 2552   49BF   68          		pla			; get the Y reg back
 2553   49C0   A8          		tay			; and show it
 2554   49C1   AD CF 45    		lda	GMREF		; get reference number again
 2555   49C4   60          		rts			; all done
 2556                      	;
 2557                      	; FETCH_FILE: check to see if we can open GAMEFILE# (where # is in [A])
 2558                      	; 	if not, ask for DISK#.
 2559                      	;
 2560   49C5   00          	SAVENUM: db	0	; spot to save ascii number  
  Wed Jun  7 1989 12:04                                                                                                  Page   40

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2561   49C6               	FETCH_FILE:
 2562   49C6   18          		clc			; adding to make
 2563   49C7   69 30       		adc	#$30		; it an ascii number
 2564   49C9   8D C5 49    		sta	SAVENUM		; just save a minute
 2565   49CC   EE C5 49    		inc	SAVENUM		; make name be one based
 2566   49CF   AE 77 46    		ldx	GAME1NML	; get length of name
 2567   49D2   AD C5 49    		lda	SAVENUM		; get name back
 2568   49D5   C9 33       		cmp	#'3'		; are we looking for disk 1 or 2?
 2569   49D7   B0 18       		bcs	FEFI1		; disks 3 and up handled special
 2570   49D9               	FEFI00:
 2571   49D9   DD 77 46    		cmp	GAME1NM,X	; is it the current open one?
 2572   49DC   D0 05       		bne	FEFI0		; nope, so we need to open it
 2573   49DE   AC 87 46    		ldy	GAME1REF	; get game 1 refnum
 2574   49E1   D0 35       		bne	FEFIX		; all set, so point to it
 2575   49E3               	FEFI0:
 2576   49E3   20 E1 4A    		jsr	DO_GAME1	; handle it special
 2577   49E6   AD 87 46    	        lda     GAME1REF        ; fetch refnum
 2578   49E9   20 20 76    		jsr	GET_PDATA	; now get the picture data
 2579   49EC   AC 87 46    	        ldy     GAME1REF        ; refetch refnum        
 2580   49EF   D0 27       		bne	FEFIX		; so all done
 2581   49F1               	FEFI1:
 2582   49F1   AE 89 46    	        ldx     GAME2NML        ; get length of second name        
 2583   49F4   DD 89 46    		cmp	GAME2NM,X	; how bout second open file?
 2584   49F7   D0 05       		bne	FEFI2		; nope, so we need to open it
 2585   49F9   AC 99 46    		ldy	GAME2REF	; it is second one, so show me
 2586   49FC   D0 1A       		bne	FEFIX		; it is open too
 2587   49FE               	FEFI2:
 2588   49FE   AD 99 46    		lda	GAME2REF	; get its refnum
 2589   4A01   F0 09       		beq	FEFI20		; nothing to close, thank you
 2590   4A03   8D 0C 8B    		sta	CLOSE_PB+CL_REFNUM ; show close who to close
 2591   4A06               		CLOSE	CLOSE_PB	; close it up tight
 2592   4A06               		PRODOS	$CC, CLOSE_PB
 2593   4A06   20 00 BF    		jsr	$BF00	; ProDOS handler
 2594   4A09   CC          		DB	$CC	; ProDOS function code
 2595   4A0A   0B8B        		DW	CLOSE_PB	; Function Parameter Block address
 2596   4A0C               		.MACEND
 2597   4A0C               		.MACEND
 2598   4A0C               	FEFI20:
 2599   4A0C   20 1F 4A    		jsr	OPEN_GAME2	; open up GAME2 file
 2600   4A0F   AD 99 46    	        lda     GAME2REF        ; get refnum for this file        
 2601   4A12   20 20 76    		jsr	GET_PDATA	; now get the picture data
 2602   4A15   AC 99 46    		ldy	GAME2REF	; get ref back, please
 2603   4A18               	FEFIX:
 2604   4A18   8C DD 45    		sty	PSEEK+SM_REFNUM	; for seeking
 2605   4A1B   8C CF 45    		sty	GMREF		; and for reading
 2606   4A1E   60          		rts			; did it
 2607                      	;
 2608                      	; OPEN_GAME2 - open up the file that GAME2NM is pointing to,
 2609                      	;	returning the REFNUM in [A], after storing in GAME2REF,
 2610                      	;	and the 2 picture structures
 2611                      	;
 2612   4A1F               	OPEN_GAME2:
 2613   4A1F   AE 89 46    	        ldx     GAME2NML        ; get end of name
 2614   4A22   AD C5 49    	        lda     SAVENUM         ; get new name
 2615   4A25   9D 89 46    		sta	GAME2NM,X	; using second file
 2616   4A28   A9 46       		lda	#>GAME2NM	; get lo byte
 2617   4A2A   8D D8 45    		sta	OPEN_FILE+OP_PATHNAME+HI
 2618   4A2D   A9 89       		lda	#<GAME2NM	; set address in open block
 2619   4A2F   8D D7 45    		sta	OPEN_FILE+OP_PATHNAME+LO
 2620   4A32   A9 15       		lda	#>GAME2FIO	; now set up file i/o buffer
 2621   4A34   8D DA 45    		sta	OPEN_FILE+OP_FILEBUFF+HI
 2622   4A37   A9 00       		lda	#<GAME2FIO	; now set up file i/o buffer
 2623   4A39   8D D9 45    		sta	OPEN_FILE+OP_FILEBUFF+LO
 2624   4A3C   20 22 4B    		jsr	OPEN_GAMEF	; find and open game file
 2625   4A3F   AD DB 45    		lda	OPEN_FILE+OP_REFNUM	; get refnum
 2626   4A42   8D 99 46    		sta	GAME2REF	; save refnum here
 2627   4A45   AE 89 46    		ldx	GAME2NML	; get me number of this side
 2628   4A48   BD 89 46    		lda	GAME2NM,X	; get ascii number
 2629   4A4B   49 30       		eor	#'0'		; make it binary
 2630   4A4D   8D 9A 46    		sta	GAME2NUM	; save num
 2631   4A50   CE 9A 46    		dec	GAME2NUM	; make it zero based
 2632   4A53   60          		rts			; finis
 2633                      	;
 2634                      	; SET_GAMEPRE: check if game prefix is in, and if not go ask for it
 2635                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page   41

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2636   4A54   00          	SAVEDISK: db    0               ; swap out save disk?
 2637   4A55   00          	SWAPPED:  db    0               ; <>0 if multi disk game
 2638                      	
 2639   4A56               	SET_GAMEPRE:
 2640   4A56   20 A9 4C    		jsr	SWAP2INFOW	; point to info window
 2641   4A59   AD 55 4A    	        lda     SWAPPED         ; are we swapping disks?
 2642   4A5C   F0 0B       	        beq     SETGP           ; nope, don't change game prefix
 2643   4A5E   AD C5 49    		lda	SAVENUM		; get which disk to put it
 2644   4A61   AC 9B 46    	        ldy     GAMEPL          ; get length of prefix
 2645   4A64   88          	        dey                     ; subtract 2 to point to prefix
 2646   4A65   88          	        dey                     ;   number
 2647   4A66   99 9C 46    		sta	GAMEP,Y		; set number for prefix
 2648   4A69               	SETGP:
 2649   4A69   A9 46       		lda	#>GAMEPL	; set up parm block
 2650   4A6B   8D E3 45    		sta	SET_PB+SP_PATHNAME+HI
 2651   4A6E   A9 9B       		lda	#<GAMEPL
 2652   4A70   8D E2 45    		sta	SET_PB+SP_PATHNAME+LO
 2653   4A73               	SETGP0:
 2654   4A73               		SET_PREFIX SET_PB	; set to game file prefix
 2655   4A73               		PRODOS	$C6, SET_PB
 2656   4A73   20 00 BF    		jsr	$BF00	; ProDOS handler
 2657   4A76   C6          		DB	$C6	; ProDOS function code
 2658   4A77   E145        		DW	SET_PB	; Function Parameter Block address
 2659   4A79               		.MACEND
 2660   4A79               		.MACEND
 2661   4A79   90 63       		bcc	SETGP1		; okay, it is
 2662   4A7B   AD 54 4A    		lda	SAVEDISK	; is it a save disk in there?
 2663   4A7E   F0 1A       		beq	SEGTP00		; nope
 2664                      	;
 2665                      	; special stuff for  save disk swapping
 2666                      	;
 2667   4A80               		DLINE	SWAPSAVE	; tell them to take out save disk
 2668   4A80   A2 E4       		ldx	#<SWAPSAVE	; get part of SWAPSAVE
 2669   4A82   A9 45       		lda	#>SWAPSAVE	; get other part of string
 2670          [01]        		IFMA	2		; check to see if length passed in
 2671                      		ldy			; then just fetch it
 2672          [01]        		ELSE
 2673   4A84   A0 20       		ldy	#SWAPSAVEL	; get length of string
 2674          [00]        		ENDIF
 2675   4A86   20 6B 4C    		jsr	DLINE		; print the string
 2676   4A89               		.MACEND
 2677   4A89   AD 55 4A    	        lda     SWAPPED         ; should we ask for specific disk?
 2678   4A8C   D0 15       	        bne     SEGTP01         ; yes, so ask for it
 2679   4A8E               	        DLINE   NOSWAP          ; no, so just get game disk
 2680   4A8E   A2 04       		ldx	#<NOSWAP	; get part of NOSWAP
 2681   4A90   A9 46       		lda	#>NOSWAP	; get other part of string
 2682          [01]        		IFMA	2		; check to see if length passed in
 2683                      		ldy			; then just fetch it
 2684          [01]        		ELSE
 2685   4A92   A0 0A       		ldy	#NOSWAPL	; get length of string
 2686          [00]        		ENDIF
 2687   4A94   20 6B 4C    		jsr	DLINE		; print the string
 2688   4A97               		.MACEND
 2689   4A97   4C D8 4A    	        jmp     SEGTP03         ; and continue
 2690   4A9A               	SEGTP00:
 2691   4A9A               		DLINE	INS_MSG		; ask for game disk
 2692   4A9A   A2 0E       		ldx	#<INS_MSG	; get part of INS_MSG
 2693   4A9C   A9 46       		lda	#>INS_MSG	; get other part of string
 2694          [01]        		IFMA	2		; check to see if length passed in
 2695                      		ldy			; then just fetch it
 2696          [01]        		ELSE
 2697   4A9E   A0 08       		ldy	#INS_MSGL	; get length of string
 2698          [00]        		ENDIF
 2699   4AA0   20 6B 4C    		jsr	DLINE		; print the string
 2700   4AA3               		.MACEND
 2701   4AA3               	SEGTP01:
 2702   4AA3               		DLINE	GAME, GAMEL	; this is the name of the game
 2703   4AA3   A2 68       		ldx	#<GAME	; get part of GAME
 2704   4AA5   A9 46       		lda	#>GAME	; get other part of string
 2705          [01]        		IFMA	2		; check to see if length passed in
 2706   4AA7   AC 67 46    		ldy	GAMEL		; then just fetch it
 2707          [01]        		ELSE
 2708                      		ldy	#GAMEL	; get length of string
 2709          [00]        		ENDIF
 2710   4AAA   20 6B 4C    		jsr	DLINE		; print the string
  Wed Jun  7 1989 12:04                                                                                                  Page   42

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2711   4AAD               		.MACEND
 2712   4AAD               		DLINE	SIDEMSG		; part 2 of message
 2713   4AAD   A2 16       		ldx	#<SIDEMSG	; get part of SIDEMSG
 2714   4AAF   A9 46       		lda	#>SIDEMSG	; get other part of string
 2715          [01]        		IFMA	2		; check to see if length passed in
 2716                      		ldy			; then just fetch it
 2717          [01]        		ELSE
 2718   4AB1   A0 07       		ldy	#SIDEMSGL	; get length of string
 2719          [00]        		ENDIF
 2720   4AB3   20 6B 4C    		jsr	DLINE		; print the string
 2721   4AB6               		.MACEND
 2722   4AB6   AD C5 49    		lda	SAVENUM		; get which disk to put it
 2723   4AB9   20 82 5D    		jsr	CHAR		; print it out
 2724   4ABC               	        DLINE   DRIVE_MSG       ; tell about drive
 2725   4ABC   A2 1D       		ldx	#<DRIVE_MSG	; get part of DRIVE_MSG
 2726   4ABE   A9 46       		lda	#>DRIVE_MSG	; get other part of string
 2727          [01]        		IFMA	2		; check to see if length passed in
 2728                      		ldy			; then just fetch it
 2729          [01]        		ELSE
 2730   4AC0   A0 10       		ldy	#DRIVE_MSGL	; get length of string
 2731          [00]        		ENDIF
 2732   4AC2   20 6B 4C    		jsr	DLINE		; print the string
 2733   4AC5               		.MACEND
 2734   4AC5   A9 32       	        lda     #'2'            ; assume it's drive 2
 2735   4AC7   AE C5 49    	        ldx     SAVENUM         ; get which disk we want
 2736   4ACA   E0 33       	        cpx     #'3'            ; >= side 3, must be disk drive 2
 2737   4ACC   B0 02       	        bcs     SEGTP02         ; fine, send that message out
 2738   4ACE   A9 31       	        lda     #'1'            ; ask for drive 1 then
 2739   4AD0               	SEGTP02:
 2740   4AD0   20 82 5D    	        jsr     CHAR            ; save which drive
 2741   4AD3   A9 2E       	        lda     #'.'            ; finish sentence
 2742   4AD5   20 82 5D    	        jsr     CHAR            ; okay
 2743   4AD8               	SEGTP03:
 2744   4AD8   20 E0 8C    		jsr	GETRET		; wait for <CR>
 2745   4ADB   4C 73 4A    		jmp	SETGP0		; try again
 2746   4ADE               	SETGP1:
 2747   4ADE   4C C9 4C    		jmp	SWAPBACK	; pointing to disk
 2748                      	;
 2749                      	; DO_GAME1 - open up the special game 1 file and point to it
 2750                      	;
 2751   4AE1               	DO_GAME1:
 2752   4AE1   AC 87 46    		ldy	GAME1REF	; get the current game 1 ref num
 2753   4AE4   F0 0B       		beq	DOG1		; not currently open
 2754   4AE6   48          		pha			; save Name
 2755   4AE7   8C 0C 8B    		sty	CLOSE_PB+CL_REFNUM	; show close
 2756   4AEA               		CLOSE	CLOSE_PB	; and close it
 2757   4AEA               		PRODOS	$CC, CLOSE_PB
 2758   4AEA   20 00 BF    		jsr	$BF00	; ProDOS handler
 2759   4AED   CC          		DB	$CC	; ProDOS function code
 2760   4AEE   0B8B        		DW	CLOSE_PB	; Function Parameter Block address
 2761   4AF0               		.MACEND
 2762   4AF0               		.MACEND
 2763   4AF0   68          		pla			; get name back
 2764   4AF1               	DOG1:
 2765   4AF1   AE 77 46    	        ldx     GAME1NML        ; get length of name
 2766   4AF4   AD C5 49    	        lda     SAVENUM         ; get new number        
 2767   4AF7   9D 77 46    		sta	GAME1NM,X	; save name
 2768   4AFA   48          		pha			; save it for later use
 2769   4AFB   A9 46       		lda	#>GAME1NM	; get lo byte
 2770   4AFD   8D D8 45    		sta	OPEN_FILE+OP_PATHNAME+HI
 2771   4B00   A9 77       		lda	#<GAME1NM	; set address in open block
 2772   4B02   8D D7 45    		sta	OPEN_FILE+OP_PATHNAME+LO
 2773   4B05   A9 11       		lda	#>GAME1FIO	; now set up file i/o buffer
 2774   4B07   8D DA 45    		sta	OPEN_FILE+OP_FILEBUFF+HI
 2775   4B0A   A9 00       		lda	#<GAME1FIO	; now set up file i/o buffer
 2776   4B0C   8D D9 45    		sta	OPEN_FILE+OP_FILEBUFF+LO
 2777   4B0F   20 22 4B    		jsr	OPEN_GAMEF	; so find and open game file
 2778   4B12   68          		pla			; get number back
 2779   4B13   49 30       		eor	#'0'		; make binary
 2780   4B15   8D 88 46    		sta	GAME1NUM	; save number
 2781   4B18   CE 88 46    		dec	GAME1NUM	; decrement for usage
 2782   4B1B   AC DB 45    		ldy	OPEN_FILE+OP_REFNUM	; get refnum
 2783   4B1E   8C 87 46    		sty	GAME1REF	; save refnum here
 2784   4B21   60          		rts			; did it
 2785                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page   43

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2786                      	;OPEN_GAMEF: open the currently pointed to game file, getting the
 2787                      	; disk if necessary (ascii number of disk/file found in SAVENUM)
 2788                      	;
 2789   4B22               	OPEN_GAMEF:
 2790   4B22   A9 00       		lda	#0		; reset volume flag
 2791   4B24   85 1D       		sta	CHPTR+HI	;okay, we be ready
 2792   4B26               	OPGM1:
 2793   4B26               		OPEN	OPEN_FILE	; open the file file
 2794   4B26               		PRODOS	$C8, OPEN_FILE
 2795   4B26   20 00 BF    		jsr	$BF00	; ProDOS handler
 2796   4B29   C8          		DB	$C8	; ProDOS function code
 2797   4B2A   D645        		DW	OPEN_FILE	; Function Parameter Block address
 2798   4B2C               		.MACEND
 2799   4B2C               		.MACEND
 2800   4B2C   90 1F       		bcc	OPGMX		; okay
 2801   4B2E   C9 46       		cmp	#$46		; file not found error?
 2802   4B30   F0 07       		beq	OPGMV		; get the volume
 2803   4B32   C9 45       		cmp	#$45		; volume not found error?
 2804   4B34   F0 03       		beq	OPGMV		; then ask for it
 2805   4B36   4C 8A 47    		jmp	DISK_ERR	; die with ZERROR
 2806   4B39               	OPGMV:
 2807   4B39   20 A5 4B    		jsr	CHECKVOLS	; try another volume
 2808   4B3C   90 E8       		bcc	OPGM1		; ==0 if no more volumes to try
 2809   4B3E   AD 54 4A    	        lda     SAVEDISK        ; doing save?
 2810   4B41   D0 05       	        bne     OPGMV1          ; yes, so don't set swap flag
 2811   4B43   A9 01       	        lda     #1              ; set swap flag
 2812   4B45   8D 55 4A    	        sta     SWAPPED         ; we have to swap disks
 2813   4B48               	OPGMV1:
 2814   4B48   20 56 4A    		jsr	SET_GAMEPRE	; okay, set up prefix
 2815   4B4B   90 D5       		bcc	OPEN_GAMEF	; try again
 2816   4B4D               	OPGMX:
 2817   4B4D   60          		rts
 2818                      	;
 2819                      	; LISTVOLS - list all the online volumes for saving to
 2820                      	;
 2821   4B4E               	ONLINE_PB:
 2822   4B4E   02          		db	2	; 2 parms for ONLINE call
 2823   4B4F   00          		db	0	; unit == 0 to get all current ones
 2824   4B50   0008        		dw	IOBUFF	; use IOBUFFER to store names
 2825   4B52   0D 56 6F 6C 75 	LSTVM:	db	EOL,"Volumes: ",EOL
        4B57   6D 65 73 3A 20 
        4B5C   0D 
 2826          000B        	LSTVML	EQU	$-LSTVM
 2827                      	
 2828   4B5D               	LISTVOLS:
 2829   4B5D               		DLINE	LSTVM		; print out intro message
 2830   4B5D   A2 52       		ldx	#<LSTVM	; get part of LSTVM
 2831   4B5F   A9 4B       		lda	#>LSTVM	; get other part of string
 2832          [01]        		IFMA	2		; check to see if length passed in
 2833                      		ldy			; then just fetch it
 2834          [01]        		ELSE
 2835   4B61   A0 0B       		ldy	#LSTVML	; get length of string
 2836          [00]        		ENDIF
 2837   4B63   20 6B 4C    		jsr	DLINE		; print the string
 2838   4B66               		.MACEND
 2839                      	
 2840   4B66               		ONLINE	ONLINE_PB
 2841   4B66               		PRODOS	$C5, ONLINE_PB
 2842   4B66   20 00 BF    		jsr	$BF00	; ProDOS handler
 2843   4B69   C5          		DB	$C5	; ProDOS function code
 2844   4B6A   4E4B        		DW	ONLINE_PB	; Function Parameter Block address
 2845   4B6C               		.MACEND
 2846   4B6C               		.MACEND
 2847   4B6C   90 05       		bcc	LSTV1		; worked fine
 2848   4B6E   20 8A 47    		jsr	DISK_ERR	; complain if we had an error
 2849   4B71   B0 31       		bcs	LSTVEX		; all done
 2850   4B73               	LSTV1:
 2851   4B73   A9 00       		lda	#0		; start at byte zero
 2852   4B75   48          		pha			; saved on stack
 2853   4B76               	LSTVL:
 2854   4B76   68          		pla			; get index
 2855   4B77   AA          		tax			; make it an index
 2856   4B78   BD 00 08    		lda	IOBUFF,X	; get drive/length byte
 2857   4B7B   F0 27       		beq	LSTVEX		; all done if == 0
 2858   4B7D   29 0F       		and	#$0F		; just care about length
  Wed Jun  7 1989 12:04                                                                                                  Page   44

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2859   4B7F   A8          		tay			; save in [Y] for now
 2860   4B80   8A          		txa			; into [A] for addition
 2861   4B81   18          		clc			; doing add
 2862   4B82   69 10       		adc	#16		; point to next entry
 2863   4B84   48          		pha			; save for later reference
 2864   4B85   98          		tya			; check for zero length
 2865   4B86   F0 EE       		beq	LSTVL		; nothing here but an error
 2866   4B88   A9 2F       		lda	#'/'		; start with / to be better
 2867   4B8A   20 82 5D    		jsr	CHAR		; and it is out there
 2868   4B8D               	LSTVCL:
 2869   4B8D   E8          		inx			; point to next char
 2870   4B8E   BD 00 08    		lda	IOBUFF,X	; get char
 2871   4B91   20 82 5D    		jsr	CHAR		; print it out
 2872   4B94   88          		dey			; count char
 2873   4B95   D0 F6       		bne	LSTVCL		; go get next char
 2874   4B97   A9 2F       		lda	#'/'		; end with '/' to show volume status
 2875   4B99   20 82 5D    		jsr	CHAR		; and awaaaaay we go
 2876   4B9C   A9 0D       		lda	#EOL		; do a <CR>
 2877   4B9E   20 82 5D    		jsr	CHAR		; printed
 2878   4BA1   CA          		dex			; count back one, as loop starts with inx
 2879   4BA2   D0 D2       		bne	LSTVL		; go do next one
 2880   4BA4               	LSTVEX:
 2881   4BA4   60          		rts			; toots finis
 2882                      	;
 2883                      	; CHECKVOLS - set prefix to particular volume that is currently online
 2884                      	;
 2885   4BA5               	CHECKVOLS:
 2886   4BA5   A5 1D       		lda	CHPTR+HI	; is it zero?
 2887   4BA7   D0 1C       		bne	CHV1		; if not, then get next volume
 2888   4BA9               		ONLINE	ONLINE_PB	; get online volumes
 2889   4BA9               		PRODOS	$C5, ONLINE_PB
 2890   4BA9   20 00 BF    		jsr	$BF00	; ProDOS handler
 2891   4BAC   C5          		DB	$C5	; ProDOS function code
 2892   4BAD   4E4B        		DW	ONLINE_PB	; Function Parameter Block address
 2893   4BAF               		.MACEND
 2894   4BAF               		.MACEND
 2895   4BAF   90 02       		bcc	CHV0		; okey dokey
 2896   4BB1               	CHVBX:
 2897   4BB1   38          		sec			; show badness
 2898   4BB2   60          		rts			; all done
 2899   4BB3               	CHV0:
 2900   4BB3   A9 F0       		lda	#<(IOBUFF-16)	; get LSB (-16 cuz we start with add)
 2901   4BB5   85 1C       		sta	CHPTR+LO
 2902   4BB7   A9 08       		lda	#>IOBUFF	; and mSB
 2903   4BB9   85 1D       		sta	CHPTR+HI
 2904   4BBB   A9 02       		lda	#>SCRBUFF		; this is where we will work on it
 2905   4BBD   8D E3 45    		sta	SET_PB+SP_PATHNAME+HI
 2906   4BC0   A9 80       		lda	#<SCRBUFF
 2907   4BC2   8D E2 45    		sta	SET_PB+SP_PATHNAME+LO
 2908   4BC5               	CHV1:
 2909   4BC5   A5 1C       		lda	CHPTR+LO	; point to next entry
 2910   4BC7   18          		clc			; getting ready for add
 2911   4BC8   69 10       		adc	#16		; this points to next one
 2912   4BCA   85 1C       		sta	CHPTR+LO	; can't be any wrapping
 2913   4BCC   A0 00       		ldy	#0		; to use indirect addressing
 2914   4BCE   B1 1C       		lda	(CHPTR),Y	; get length byte
 2915   4BD0   F0 DF       		beq	CHVBX		; all done if == 0
 2916   4BD2   29 0F       		and 	#$0F		; get rid of upper junk
 2917   4BD4   F0 EF       		beq	CHV1		; nothing in this one, do it again
 2918   4BD6   8D 80 02    		sta	SCRBUFF		; save length
 2919   4BD9   EE 80 02    		inc	SCRBUFF		; count the add '/'
 2920   4BDC   A8          		tay			; get for countdown
 2921   4BDD   A9 2F       		lda	#'/'		; need to start with a slash
 2922   4BDF   8D 81 02    		sta	SCRBUFF+1	; okay, we are
 2923   4BE2               	CHVL:
 2924   4BE2   B1 1C       		lda	(CHPTR),Y	; get char in path name
 2925   4BE4   99 81 02    		sta	SCRBUFF+1,Y	; save name
 2926   4BE7   88          		dey			; count char
 2927   4BE8   D0 F8       		bne	CHVL		; go get next one
 2928                      	
 2929   4BEA               		SET_PREFIX SET_PB	; so point to it
 2930   4BEA               		PRODOS	$C6, SET_PB
 2931   4BEA   20 00 BF    		jsr	$BF00	; ProDOS handler
 2932   4BED   C6          		DB	$C6	; ProDOS function code
 2933   4BEE   E145        		DW	SET_PB	; Function Parameter Block address
  Wed Jun  7 1989 12:04                                                                                                  Page   45

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2934   4BF0               		.MACEND
 2935   4BF0               		.MACEND
 2936   4BF0               	CHVX:
 2937   4BF0   60          		rts			; carry==0, we worked okay
 2938                      	;
 2939                      	; GET_SPECIAL - if we are in infodos, then we preload the first 12Kb of
 2940                      	;   stuff into the area in the main bank, pages $D0-$FF, Language Card 2.
 2941                      	;  Assume .D2 file has just been opened and go get it.
 2942   4BF1               	GET_SPECIAL:
 2943   4BF1   A9 03       	        lda     #RETRY_COUNT
 2944   4BF3   85 16       	        sta     RETRIES         ; how many retries
 2945   4BF5               	GTS_RDL:
 2946   4BF5   A9 00       	        lda     #0              ; make sure we are at the start
 2947   4BF7   8D DE 45    	        sta     PSEEK+SM_FPOS	; set pos to zero
 2948   4BFA   8D DF 45    	        sta     PSEEK+SM_FPOS+1
 2949   4BFD   8D E0 45    	        sta     PSEEK+SM_FPOS+2
 2950   4C00   85 7C       	        sta     K+LO
 2951   4C02   85 7E       	        sta     L+LO            ; make sure these are zero too
 2952   4C04               	        SET_MARK PSEEK		; go back to the beginning
 2953   4C04               		PRODOS	$CE, PSEEK
 2954   4C04   20 00 BF    		jsr	$BF00	; ProDOS handler
 2955   4C07   CE          		DB	$CE	; ProDOS function code
 2956   4C08   DC45        		DW	PSEEK	; Function Parameter Block address
 2957   4C0A               		.MACEND
 2958   4C0A               		.MACEND
 2959   4C0A               	        
 2960   4C0A   A9 02       	        lda     #2              ; one page at a time        
 2961   4C0C   8D D3 45    	        sta     READ_PB+RD_BUFFLEN+HI   ; show how much is special
 2962   4C0F   A9 17       	        lda     #SP_SIZE        ; how many pages in special part?
 2963   4C11   85 7A       	        sta     J+LO            ; use as counter
 2964   4C13   A9 D0       	        lda     #>SP_START      ; where does it go?
 2965   4C15   85 7F       	        sta     L+HI            ; L is pointer to there
 2966   4C17               	GTS_RD:
 2967   4C17   A9 00       	        lda     #MAIN           ; make sure we are in main
 2968   4C19   8D 04 C0    	        sta     WRTBNK+MAIN
 2969   4C1C               	        READ    READ_PB         ; go get 1Kb
 2970   4C1C               		PRODOS	$CA, READ_PB
 2971   4C1C   20 00 BF    		jsr	$BF00	; ProDOS handler
 2972   4C1F   CA          		DB	$CA	; ProDOS function code
 2973   4C20   CE45        		DW	READ_PB	; Function Parameter Block address
 2974   4C22               		.MACEND
 2975   4C22               		.MACEND
 2976   4C22   90 05       	        bcc     GTS_RD1         ; just fine
 2977   4C24   20 07 47    	        jsr     RETRY           ; try again
 2978   4C27   90 CC       	        bcc     GTS_RDL         ; and do it again
 2979   4C29               	GTS_RD1:
 2980   4C29   A2 00       	        ldx     #SP_BANK        ; get bank that special is in
 2981   4C2B   9D 04 C0    	        sta     WRTBNK,X
 2982   4C2E   A9 08       	        lda     #>IOBUFF        ; get MSB of start
 2983   4C30   85 7D       	        sta     K+HI            ; K is source
 2984   4C32   A2 02       	        ldx     #2              ; 2 blocks of 256 bytes each
 2985   4C34               	GTS_CPL0:
 2986   4C34   A0 00       	        ldy     #0              ; indexer
 2987   4C36               	GTS_CPL:
 2988   4C36   B1 7C       	        lda     (K),y           ; get it
 2989   4C38   91 7E       	        sta     (L),y           ; store it
 2990   4C3A   C8          	        iny                     ; next
 2991   4C3B   D0 F9       	        bne     GTS_CPL         ; gwon then
 2992   4C3D   E6 7D       	        inc     K+HI            ; point to next block
 2993   4C3F   E6 7F       	        inc     L+HI            ; for destination too
 2994   4C41   CA          	        dex                     ; count block
 2995   4C42   D0 F0       	        bne     GTS_CPL0        ; next block
 2996   4C44   C6 7A       	        dec     J+LO            ; count this 1Kb
 2997   4C46   D0 CF       	        bne     GTS_RD          ; go get next one
 2998   4C48               	        
 2999   4C48   8D 04 C0    	        sta     WRTBNK+MAIN     ; make sure we are in main
 3000                      	;
 3001                      	; now figger out last page
 3002                      	;
 3003   4C4B   A0 09       	        ldy     #SGTSEG+1       ; get start segment LSB
 3004   4C4D   B1 59       	        lda     (INFODOS),Y     ; got it
 3005   4C4F   18          	        clc                     ; doing add
 3006   4C50   69 17       	        adc     #<SP_SIZE       ; add in size LSB
 3007   4C52   8D AA 6C    	        sta     INFODOS_END+LO  ; save end
 3008   4C55   88          	        dey                     ; point to MSB
  Wed Jun  7 1989 12:04                                                                                                  Page   46

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 3009   4C56   B1 59       	        lda     (INFODOS),Y     ; got it
 3010   4C58   69 00       	        adc     #>SP_SIZE       ; add in size MSB
 3011   4C5A   8D AB 6C    	        sta     INFODOS_END+HI  ; and save it
 3012   4C5D   AD AA 6C    	        lda     INFODOS_END+LO  ; now, subtract one to make
 3013   4C60   D0 03       	        bne     GTS_END         ; it inclusive
 3014   4C62   CE AB 6C    	        dec     INFODOS_END+HI  ; wrapped, so dec MSB
 3015   4C65               	GTS_END:
 3016   4C65   CE AA 6C    	        dec     INFODOS_END+LO  ; make pointers inclusive
 3017                      	
 3018   4C68   60          	        rts                     ; done
 3019                      	
 3020          [01]        		IF	CHECKSUM == 1
 3021                      	CKS_COUNT: db 0
 3022                      	CKSB:	db	0
 3023                      	CKS_BLOCK:
 3024                      	        pha
 3025                      	        sta     CKSMOD+2
 3026                      	        ldy     #0
 3027                      		lda	CKSB
 3028                      	CKSLP:
 3029                      	        clc
 3030                      	CKSMOD: adc     IOBUFF,Y
 3031                      	        iny
 3032                      	        bne     CKSLP
 3033                      	
 3034                      		sta	CKSB
 3035                      		inc	CKS_COUNT
 3036                      		pla
 3037                      		rts
 3038                      	
 3039          [02]        		IF 	0
 3040                      	        jsr     HEXNUM
 3041                      	        lda     CKS_COUNT
 3042                      	        cmp     #$F
 3043                      	        bne     CKSCNT
 3044                      	        lda     #0
 3045                      	        sta     CKS_COUNT
 3046                      	        lda     #EOL
 3047                      	        bne     CKSSEND
 3048                      	CKSCNT:
 3049                      	        inc     CKS_COUNT
 3050                      	        lda     #SPACE
 3051                      	CKSSEND:
 3052                      	        jsr     CHAR
 3053                      	        jsr     DISP_LINE
 3054                      	        pla
 3055                      	        rts
 3056          [01]        		ENDIF
 3057                      	
 3058          [00]        	        ENDIF
 3059                      	
 3060   4C69               		END
 3061                      	
 3062   4C69               		INCLUDE		MACHINE.ASM
 3063   4C69               		STTL "--- MACHINE-DEPENDENT I/O: APPLE II ---"
 3064                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page   47

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3065                      	; -----------------------
 3066                      	; DIRECT PRINT LINE [X/A]
 3067                      	; -----------------------
 3068                      	; ENTRY: STRING ADDRESS IN [X/A] (LSB/MSB)
 3069                      	; STRING LENGTH IN [Y]
 3070   4C69   00          	DLCNT:	db 	0
 3071   4C6A   00          	DLOFF:	db	0
 3072   4C6B               	DLINE:
 3073   4C6B   8E 85 4C    		stx	STRING+LO	; DROP STRING ADDRESS
 3074   4C6E   8D 86 4C    		sta	STRING+HI	; INTO DUMMY BYTES
 3075   4C71   8C 69 4C    		sty	DLCNT		; COUNTER
 3076   4C74   20 B5 55    	        jsr     CLRBUF          ; send out what's out
 3077   4C77   A5 B1       	        lda     SCREENF         ; save output flag
 3078   4C79   48          	        pha
 3079   4C7A   A2 01       		ldx	#1		; INIT CHAR-FETCH INDEX
 3080   4C7C   86 B1       	        stx     SCREENF         ; make sure screen output is on
 3081   4C7E   CA          	        dex
 3082   4C7F   8E A8 6C    	        stx     CRLF_CHECK      ; don't let swap happen
 3083   4C82   86 AA       		stx	SCRIPT		; don't script any of my internal
 3084   4C84   BD          	DOUT:	DB	$BD		; 6502 "LDA nnnn,X" OPCODE
 3085   4C85   0000        	STRING:	DW	$0000		; DUMMY OPERAND BYTES
 3086   4C87   8E 6A 4C    		stx	DLOFF		; save X
 3087   4C8A   85 AC       	        sta     IOCHAR          ; save here for DIRECT_OUT
 3088   4C8C   20 21 53    	DOUT1:	jsr	DIRECT_OUT      ; send directly out there
 3089   4C8F   AE 6A 4C    		ldx	DLOFF		; get x back
 3090   4C92   E8          		inx
 3091   4C93   CE 69 4C    		dec	DLCNT		; LOOP TILL
 3092   4C96   D0 EC       		bne	DOUT		; OUT OF CHARS
 3093   4C98   20 B5 55    		jsr	CLRBUF		; and force the chars out
 3094   4C9B   A2 01       		ldx	#1		; allow scripting again
 3095   4C9D   86 AA       		stx	SCRIPT		; okay, we did
 3096   4C9F   8E A8 6C    	        stx     CRLF_CHECK      ; and turn on check
 3097   4CA2   68          	        pla                     ; get screen flag back
 3098   4CA3   85 B1       	        sta     SCREENF         ; bingo
 3099   4CA5   60          		rts			; done
 3100                      	
 3101                      	; SWAP2INFOW - save current state and swap to the information window,
 3102                      	;	which is currently window zero
 3103   4CA6               	SWAPA1:	ds	1		; save for current ARG1
 3104   4CA7               	SWAPCW:	ds	1		; save for current window
 3105   4CA8   00          	SWAPFLG: db	0		; flag == 1 if we have already swapped
 3106   4CA9               	SWAP2INFOW:
 3107   4CA9   AD A8 4C    		lda	SWAPFLG		; already swapped?
 3108   4CAC   D0 17       		bne	SWP2		; ayyup
 3109   4CAE   20 B5 55    		jsr	CLRBUF		; clear out the buffer
 3110   4CB1   20 9F 4D    		jsr	SAVE_CURSOR	; save current postion of cursor
 3111   4CB4   A5 63       		lda	ARG1+LO		; get current arg1
 3112   4CB6   8D A6 4C    		sta	SWAPA1		; save it
 3113   4CB9   A5 A6       		lda	CURWIN		; get current window
 3114   4CBB   8D A7 4C    		sta	SWAPCW		; save it
 3115   4CBE   A9 00       		lda	#0		; swap to window zero for messages
 3116   4CC0   85 63       		sta 	ARG1+LO		; okay
 3117   4CC2   20 5C 6E    		jsr	ZSCRN		; and swap to it
 3118   4CC5               	SWP2:
 3119   4CC5   EE A8 4C    		inc	SWAPFLG		; show we are in swap window
 3120   4CC8               	SWAPEX:
 3121   4CC8   60          		rts			; all done
 3122                      	;
 3123                      	; SWAPBACK - swap out of info window, and back to old window
 3124                      	;
 3125   4CC9               	SWAPBACK:
 3126   4CC9   CE A8 4C    		dec	SWAPFLG		; are we finally leaving for good?
 3127   4CCC   D0 FA       		bne	SWAPEX		; nope
 3128   4CCE   AD A7 4C    		lda	SWAPCW		; and now for current window
 3129   4CD1   85 63       		sta	ARG1+LO		; swap to it
 3130   4CD3   20 5C 6E    		jsr	ZSCRN		; we did
 3131   4CD6   AD A6 4C    		lda	SWAPA1		; and get arg1 back
 3132   4CD9   85 63       		sta 	ARG1+LO		; we did
 3133   4CDB   4C B1 4D    		jmp	GET_CURSOR	; and get cursor back
 3134                      	
 3135                      	; -----------------------
 3136                      	; SEND [LBUFF] TO PRINTER
 3137                      	; -----------------------
 3138                      	; ENTRY: LENTH OF LINE IN [PRLEN]
 3139                      	
  Wed Jun  7 1989 12:04                                                                                                  Page   48

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3140   4CDE   60          	PLEAV:	RTS		
 3141                      	
 3142   4CDF               	PPRINT:
 3143   4CDF   A5 AA       		lda	SCRIPT		; SCRIPTING INTERNALLY ENABLED?
 3144   4CE1   2D 78 6C    		and	SCRIPTF		; SCRIPTING ON?
 3145   4CE4   2D 79 6C    		and	SCRIPTFLG	; Window allow scripting?
 3146   4CE7   F0 F5       		beq	PLEAV		; NO, EXIT
 3147   4CE9   A5 36       		lda	CSW+LO		; SAVE NORMAL OUTPUT HOOK
 3148   4CEB   48          		pha		
 3149   4CEC   A5 37       		lda	CSW+HI	
 3150   4CEE   48          		pha		
 3151   4CEF   AD 1C 4D    		lda	ALTCSW+LO	; LOAD SCRIPTING HOOK
 3152   4CF2   85 36       		sta	CSW+LO	
 3153   4CF4   AD 1D 4D    		lda	ALTCSW+HI	
 3154   4CF7   85 37       		sta	CSW+HI	
 3155   4CF9   AD 82 C0    	        lda     RDROM           ; put system ROM in for printer out
 3156   4CFC   A0 00       		ldy	#0	
 3157   4CFE               	PP5:
 3158   4CFE   B9 00 02    		lda	LBUFF,Y		;GET A CHAR TO SEND OUT
 3159   4D01   30 05       	        bmi     PP6             ; don't do highlighting
 3160   4D03   09 80       		ora	#$80		; make it apple happy
 3161   4D05   20 ED FD    		jsr	MCOUT	
 3162   4D08               	PP6:
 3163   4D08   C8          		iny		
 3164   4D09   CE 6E 6C    		dec	PRLEN		;LINE COUNT
 3165   4D0C   D0 F0       		bne	PP5		;PRINT WHOLE LINE
 3166                      	;
 3167                      	; ALL DONE, RESET TO NORMAL AND LEAVE
 3168                      	;
 3169   4D0E   AD 83 C0    	        lda     BNK2SET         ; write RAM, bank 1
 3170   4D11   AD 83 C0    	        lda     BNK2SET
 3171   4D14   68          		pla		
 3172   4D15   85 37       		sta	CSW+HI	
 3173   4D17   68          		pla		
 3174   4D18   85 36       		sta	CSW+LO	
 3175   4D1A   60          		rts		
 3176                      	
 3177   4D1B   00          	PSTAT:	DB	0	;SET TO CLEAR WHEN BOOT,
 3178                      				;I PUT IT HERE SO RESTART WON'T ALTER
 3179   4D1C   00 00       	ALTCSW:	DB	0,0	;(WORD) PRINTER COUT
 3180                      	
 3181                      		; FIRST TIME USING PRINTER, INITIALIZE IT
 3182   4D1E   0D          	SLOTM:	DB	EOL	
 3183   4D1F   50 72 69 6E 74 		DB	"Printer Slot 1-7: "
        4D24   65 72 20 53 6C 
        4D29   6F 74 20 31 2D 
        4D2E   37 3A 20 
 3184          0013        	SLOTML	EQU	$-SLOTM
 3185                      	
 3186   4D31               	PCHK:	
 3187   4D31   20 A9 4C    		jsr	SWAP2INFOW	; point to info window
 3188   4D34               	PCHK1:
 3189   4D34               		DLINE	SLOTM
 3190   4D34   A2 1E       		ldx	#<SLOTM	; get part of SLOTM
 3191   4D36   A9 4D       		lda	#>SLOTM	; get other part of string
 3192          [01]        		IFMA	2		; check to see if length passed in
 3193                      		ldy	M		; then just fetch it
 3194          [01]        		ELSE
 3195   4D38   A0 13       		ldy	#SLOTML	; get length of string
 3196          [00]        		ENDIF
 3197   4D3A   20 6B 4C    		jsr	DLINE		; print the string
 3198   4D3D               		.MACEND
 3199   4D3D   20 31 51    		jsr	GETKEY	
 3200   4D40   C9 38       		cmp	#'8'		;1-7
 3201   4D42   B0 F0       		bcs	PCHK1		;OOPS
 3202   4D44   C9 31       		cmp	#'1'		; less than '1'?
 3203   4D46   90 EC       		bcc	PCHK1		; ayyup
 3204   4D48               	PC2:
 3205   4D48   49 F0       		eor	#$F0		; make it a slot address	
 3206   4D4A   8D 1D 4D    		sta	ALTCSW+HI	
 3207   4D4D   A9 0D       		lda	#EOL
 3208   4D4F   20 82 5D    		jsr	CHAR		;SEND >CR< TO SCREEN FOR NEATNESS
 3209   4D52   EE 1B 4D    		inc	PSTAT		;SET TO ON
 3210   4D55   A5 36       		lda	CSW+LO		;SAVE NORMAL OUTPUT HOOK
 3211   4D57   48          		pha		
  Wed Jun  7 1989 12:04                                                                                                  Page   49

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3212   4D58   A5 37       		lda	CSW+HI	
 3213   4D5A   48          		pha		
 3214   4D5B   AD 1C 4D    		lda	ALTCSW+LO	;LOAD SCRIPTING HOOK
 3215   4D5E   85 36       		sta	CSW+LO	
 3216   4D60   AD 1D 4D    		lda	ALTCSW+HI	
 3217   4D63   85 37       		sta	CSW+HI	
 3218   4D65   20 98 4D    		jsr	INITPRT		; now, init it 
 3219                      	
 3220   4D68   AD 82 C0    	        lda     RDROM           ; bring in system ROM
 3221   4D6B   A9 89       		lda	#$89		; OUTPUT PRINTER SETUP SEQUENCE
 3222   4D6D   20 ED FD    		jsr	MCOUT		; START WITH COMMAND CHAR >CTRL-I<
 3223   4D70   A9 B8       		lda	#$B8		; 8 (80 COL WIDE)
 3224   4D72   20 ED FD    		jsr	MCOUT	
 3225   4D75   A9 B0       		lda	#$B0		; 0
 3226   4D77   20 ED FD    		jsr	MCOUT	
 3227   4D7A   A9 CE       		lda	#$CE		; N (LF AFTER CR)
 3228   4D7C   20 ED FD    		jsr	MCOUT	
 3229   4D7F   A5 36       		lda	CSW+LO		; SAVE REAL PRINTER OUTPUT
 3230   4D81   8D 1C 4D    		sta	ALTCSW+LO	; LOC. FOR NEXT TIME
 3231   4D84   A5 37       		lda	CSW+HI	
 3232   4D86   8D 1D 4D    		sta	ALTCSW+HI	
 3233   4D89   68          		pla			; RESET NORMAL OUTPUT
 3234   4D8A   85 37       		sta	CSW+HI	
 3235   4D8C   68          		pla		
 3236   4D8D   85 36       		sta	CSW+LO	
 3237   4D8F   AD 83 C0    	        lda     BNK2SET         ; and bring back top RAM
 3238   4D92   AD 83 C0    	        lda     BNK2SET         ; okay
 3239   4D95   4C C9 4C    		jmp	SWAPBACK	; and back to the old window
 3240   4D98               	INITPRT:
 3241   4D98   A9 00       		lda	#0		; jump to $Cn00
 3242   4D9A   85 36       		sta	CSW+LO		; make LSB == 0
 3243   4D9C   6C 36 00    		jmp	(CSW)		; and goto it
 3244                      	
 3245                      	
 3246   4D9F               	SAVE_CURSOR:
 3247   4D9F   A5 01       		lda	SCRCY		; save the cursor pos
 3248   4DA1   A0 04       		ldy	#WINY		; get offset
 3249   4DA3   91 05       		sta	(WINDOW),Y	; first y pos
 3250   4DA5   C8          		iny			; now x pos
 3251   4DA6   A5 00       		lda	SCRCX		; got it
 3252   4DA8   91 05       		sta	(WINDOW),Y	; saved it
 3253   4DAA   A0 13       		ldy	#WINLCNT	; reset line count too
 3254   4DAC   A5 AB       		lda	LINCNT		; okay
 3255   4DAE   91 05       		sta	(WINDOW),Y	; get it
 3256   4DB0   60          		rts
 3257                      	
 3258   4DB1               	GET_CURSOR:
 3259   4DB1   A0 04       		ldy	#WINY		; get cursor pos back
 3260   4DB3   B1 05       		lda	(WINDOW),Y	; got y pos
 3261   4DB5   85 01       		sta	SCRCY		; saved
 3262   4DB7   C8          		iny			; point to x pos
 3263   4DB8   B1 05       		lda	(WINDOW),Y	; got it
 3264   4DBA   85 00       		sta	SCRCX		; make it better
 3265   4DBC   38          		sec			; subtract left margin to get how long line is
 3266   4DBD   E5 04       		sbc	LEFTMRG		; okay we did that
 3267   4DBF   B0 02       	        bcs     GETCR1          ; make sure left margin is not > cur x pos
 3268   4DC1   A9 00       	        lda     #0              ; otherwise, pretend length is zero
 3269   4DC3               	GETCR1:
 3270   4DC3   85 A7       		sta	LENGTH+LO	; this is how big line is too
 3271   4DC5   A9 00       		lda	#0		; clear MSB
 3272   4DC7   85 A8       		sta	LENGTH+HI
 3273   4DC9   06 A7       		asl	LENGTH+LO	; *2
 3274   4DCB   26 A8       		rol	LENGTH+HI
 3275   4DCD   06 A7       		asl	LENGTH+LO	; *4
 3276   4DCF   26 A8       		rol	LENGTH+HI
 3277   4DD1               		
 3278   4DD1   A0 13       		ldy	#WINLCNT	; reset line count too
 3279   4DD3   B1 05       		lda	(WINDOW),Y	; get it
 3280   4DD5   85 AB       		sta	LINCNT		; okay
 3281   4DD7   A9 01       		lda	#1		; show cursor changed (maybe)
 3282   4DD9   8D 7C 6C    		sta	CURSFLG		; okay
 3283   4DDC   60          		rts
 3284                      	
 3285                      	; ------------
 3286                      	; SPLIT SCREEN
  Wed Jun  7 1989 12:04                                                                                                  Page   50

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3287                      	; ------------
 3288                      	;
 3289                      	; SPLIT SCREEN AT LINE [ARG1] putting screen 1 at top and screen
 3290                      	; 0 at bottom.
 3291                      	; DISABLE SPLIT IF [ARG1] = 0
 3292                      	;
 3293   4DDD               	ZSPLIT:
 3294   4DDD   20 9F 4D    		jsr	SAVE_CURSOR	; save the cursor pos
 3295                      	;
 3296                      	; first muck with window 1
 3297                      	;
 3298   4DE0   A5 63       		lda	ARG1+LO		; get split arg back
 3299   4DE2   8D A6 6D    		sta	WINDOW1+WINHGHT	; this becomes the height of window 1
 3300   4DE5   A9 00       		lda	#0		; put top of 1 to top of screen
 3301   4DE7   8D A4 6D    		sta	WINDOW1+WINTOP	; okay, we did it
 3302   4DEA   A5 63       		lda	ARG1+LO		; get new height
 3303   4DEC   A2 FF       		ldx	#$FF		; this is the counter
 3304   4DEE   38          		sec			; get ready for subs
 3305   4DEF               	ZSPLIT0:
 3306   4DEF   E8          		inx			; count this line
 3307   4DF0   E9 09       		sbc	#FONT_H		; subtract off font height	
 3308   4DF2   B0 FB       		bcs	ZSPLIT0		; still some lines	
 3309   4DF4   CA          		dex			; save input line
 3310   4DF5   8E BB 6D    		stx	WINDOW1+WINLINES ; saved
 3311                      	
 3312   4DF8   AD A8 6D    		lda	WINDOW1+WINY	; check cursor pos
 3313   4DFB   C5 63       		cmp	ARG1+LO		; against height
 3314   4DFD   90 11       		bcc	ZSPL1		; inside window, so save it
 3315   4DFF               	ZSPL0:
 3316   4DFF   A9 00       		lda	#0		; reset to top left
 3317   4E01   8D A8 6D    		sta	WINDOW1+WINY	; y pos at top
 3318   4E04   8D A9 6D    		sta	WINDOW1+WINX	; x pos at left
 3319   4E07   8D B9 6D    		sta	WINDOW1+WINLLEN+LO	; line length
 3320   4E0A   8D BA 6D    		sta	WINDOW1+WINLLEN+HI	; line length
 3321   4E0D   8D B7 6D    		sta	WINDOW1+WINLCNT	; line counter
 3322                      	;
 3323                      	; now muck with window 0
 3324                      	;
 3325   4E10               	ZSPL1:
 3326   4E10   AD 8C 6D    		lda	WINDOW0+WINTOP	; top of window 0
 3327   4E13   38          		sec			; doing sub
 3328   4E14   E5 63       		sbc	ARG1+LO		; subtract out the new top
 3329   4E16   18          		clc			; adding
 3330   4E17   6D 8E 6D    		adc	WINDOW0+WINHGHT	; to get the new height
 3331                      	;	bcc	ZSPLIT1		; okay, positive height
 3332                      	;	lda	#0		; make height 0
 3333   4E1A               	ZSPLIT1:
 3334   4E1A   8D 8E 6D    		sta	WINDOW0+WINHGHT	; and save new height
 3335   4E1D               		
 3336   4E1D   A2 FF       		ldx	#$FF		; this is the counter
 3337   4E1F   38          		sec			; get ready for subs
 3338   4E20               	ZSPLIT2:
 3339   4E20   E8          		inx			; count this line
 3340   4E21   E9 09       		sbc	#FONT_H		; subtract off font height	
 3341   4E23   B0 FB       		bcs	ZSPLIT2		; still some lines	
 3342   4E25   CA          		dex			; to save input line
 3343   4E26   8E A3 6D    		stx	WINDOW0+WINLINES ; saved
 3344                      	
 3345   4E29   A5 63       		lda	ARG1+LO		; this is the new top
 3346   4E2B   8D 8C 6D    		sta	WINDOW0+WINTOP	; set in structure
 3347   4E2E   CD 90 6D    		cmp	WINDOW0+WINY	; make sure cursor is still in window
 3348   4E31   F0 13       		beq	ZSPL5		; nope, at the top
 3349   4E33   90 11       		bcc	ZSPL5		; or under it
 3350   4E35   8D 90 6D    		sta	WINDOW0+WINY	; put cursor at top
 3351   4E38   A9 00       		lda	#0		; left of new
 3352   4E3A   8D 91 6D    		sta	WINDOW0+WINX	; window 0
 3353   4E3D   8D A1 6D    		sta	WINDOW0+WINLLEN+LO	; linelength
 3354   4E40   8D A2 6D    		sta	WINDOW0+WINLLEN+HI	; linelength
 3355   4E43   8D 9F 6D    		sta	WINDOW0+WINLCNT	; line counter
 3356   4E46               	ZSPL5:
 3357   4E46   20 B1 4D    		jsr	GET_CURSOR	; get the cursor pos back
 3358                      	
 3359   4E49   A9 00       		lda	#0		; now switch to window zero
 3360   4E4B   85 63       		sta	ARG1+LO		; good bye
 3361   4E4D   4C 5C 6E    		jmp	ZSCRN		; making window 0 be current
  Wed Jun  7 1989 12:04                                                                                                  Page   51

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3362                      	
 3363                      	; ------
 3364                      	; MARGIN
 3365                      	; ------
 3366                      	;
 3367                      	; Set the margins for the window
 3368                      	;
 3369                      	;  ARG1 - left margin
 3370                      	;  ARG2 - right margin
 3371                      	;  ARG3 - window ID (optional)
 3372                      	;
 3373   4E50               	ZMARG:
 3374   4E50   20 B5 55    		jsr	CLRBUF		; CLEAR LBUFF BEFORE RESETTING LINE MARGINS
 3375   4E53   20 9F 4D    		jsr	SAVE_CURSOR	; save current cursor pos
 3376   4E56               		
 3377   4E56   A5 62       		lda	NARGS		; see if window ID was passed
 3378   4E58   C9 03       		cmp	#3		; if ==3, then it's there
 3379   4E5A   F0 04       		beq	ZMRG1		; okay, so use it
 3380   4E5C   A5 A6       		lda	CURWIN		; get the current window
 3381   4E5E   85 67       		sta	ARG3+LO		; and use as the default
 3382   4E60               	ZMRG1:
 3383   4E60   A5 67       		lda	ARG3+LO		; check what window
 3384   4E62   20 7F 57    		jsr	SETWJ		; get window offset into J
 3385   4E65   A5 63       		lda	ARG1+LO		; do left margin first
 3386   4E67   A0 06       		ldy	#WINLM		; get offset
 3387   4E69   91 7A       		sta	(J),Y		; save for window
 3388   4E6B   C8          		iny			; point to right margin
 3389   4E6C   A5 65       		lda	ARG2+LO		; get right margin
 3390   4E6E   91 7A       		sta	(J),Y		; save right margin
 3391   4E70   A0 03       		ldy	#WINWID		; get full width of window
 3392   4E72   B1 7A       		lda	(J),Y		; got it
 3393   4E74   38          		sec			; subtract off the 2 margins
 3394   4E75   A0 06       		ldy	#WINLM		; first the left margin
 3395   4E77   F1 7A       		sbc	(J),Y		; okay, gone
 3396   4E79   C8          		iny			; point to right margin
 3397   4E7A   F1 7A       		sbc	(J),Y		; and take it off	
 3398   4E7C   A0 14       		ldy	#WINXSZ		; set width of usable window
 3399   4E7E   91 7A       		sta	(J),Y		; see, here it is
 3400                      	;
 3401                      	; move cursor to left margin
 3402                      	;
 3403   4E80   A0 01       		ldy	#WINLEFT	; get left edge
 3404   4E82   B1 7A       		lda	(J),Y		; got it
 3405   4E84   A0 06       		ldy	#WINLM		; and add left margin
 3406   4E86   18          		clc			; adding
 3407   4E87   71 7A       		adc	(J),Y		; to get minimum X
 3408   4E89   A0 05       		ldy	#WINX		; check to make sure X pos is okay
 3409   4E8B   91 7A       		sta	(J),Y		; then reset it
 3410                      	;
 3411                      	; now see if we changed the current window
 3412                      	;
 3413   4E8D               	ZMRGXP:
 3414   4E8D   A6 67       		ldx	ARG3+LO		; get the window
 3415   4E8F   30 04       		bmi	ZMRG3		; -3 means current window
 3416   4E91   E4 A6       		cpx	CURWIN		; check against the current window
 3417   4E93   D0 17       		bne	ZMRGX		; nope, so we be done
 3418   4E95               	ZMRG3:
 3419   4E95   85 04       		sta	LEFTMRG		; [A] already has left margin
 3420   4E97   A0 14       		ldy	#WINXSZ		; get xsize to set
 3421   4E99   B1 05       		lda	(WINDOW),Y	; got it
 3422   4E9B   85 A2       		sta	XSIZE+LO	; this is for quicky comparing
 3423   4E9D   A9 00       		lda	#0		; clear MSB
 3424   4E9F   85 A3       		sta	XSIZE+HI
 3425   4EA1   06 A2       		asl	XSIZE+LO	; *2
 3426   4EA3   26 A3       		rol	XSIZE+HI
 3427   4EA5   06 A2       		asl	XSIZE+LO	; *4
 3428   4EA7   26 A3       		rol	XSIZE+HI
 3429   4EA9   20 B1 4D    		jsr	GET_CURSOR	; restore the cursor pos
 3430   4EAC               	ZMRGX:
 3431   4EAC   60          		rts
 3432                      	;
 3433                      	; SOUND
 3434                      	; -----
 3435                      	; ARG1 = BOOP (2) BEEP (1) ALL OTHERS INVALID
 3436                      	; (EZIP)
  Wed Jun  7 1989 12:04                                                                                                  Page   52

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3437                      	
 3438   4EAD               	ZSOUND:
 3439   4EAD   A6 63       		ldx	ARG1+LO	; GET SOUND WANTED
 3440   4EAF   CA          		dex		
 3441   4EB0   F0 11       		beq	BEEP	
 3442   4EB2   CA          		dex		
 3443   4EB3   D0 0D       		bne	ZSOEX	; INVALID
 3444   4EB5   A0 FF       		ldy	#$FF	; DURATION ($C0 = .1 SEC)
 3445   4EB7               	BOOP:
 3446   4EB7   A9 10       		lda	#$10	; TONE ($0C = 1 KHZ)
 3447   4EB9   20 27 4F    		jsr	WAIT10
 3448   4EBC   AD 30 C0    		lda	SPKR	; TOGGLE SPEAKER
 3449   4EBF   88          		dey
 3450   4EC0   D0 F5       		bne	BOOP	
 3451   4EC2               	ZSOEX:
 3452   4EC2   60          		rts		
 3453                      	
 3454   4EC3               	BEEP:
 3455   4EC3   AD 82 C0    	        lda     RDROM
 3456   4EC6   20 3A FF    		jsr	MBELL	; just use system beep
 3457   4EC9   AD 83 C0    	        lda     BNK2SET ; back to bank 2
 3458   4ECC   AD 83 C0    	        lda     BNK2SET ; back to bank 2
 3459   4ECF   60          	        rts
 3460                      	;
 3461                      	; just do the background color - foreground is always white/black
 3462                      	;
 3463                      	;
 3464                      	; ZIPCOLOR - maps ZIP colors to screen colors
 3465                      	;
 3466   4ED0               	ZCOLOR:
 3467   4ED0   20 B5 55    		jsr	CLRBUF		; print out what we have
 3468                      	
 3469   4ED3   A5 62       		lda 	NARGS		; check if window was passed
 3470   4ED5   C9 03       		cmp	#3		; was it?
 3471   4ED7   F0 04       		beq	ZCLR0		; ayyup
 3472   4ED9   A5 A6       		lda	CURWIN		; make it current window
 3473   4EDB   85 67       		sta	ARG3+LO		; it is now
 3474   4EDD               	ZCLR0:
 3475   4EDD   A5 67       		lda	ARG3+LO		; get window ID
 3476   4EDF   20 7F 57    		jsr	SETWJ		; and put pointer into J
 3477                      	
 3478   4EE2   A6 65       		ldx 	ARG2+LO		; get background color
 3479   4EE4   F0 15       		beq	ZCLR2		; check fore ground color
 3480   4EE6   10 06       		bpl	ZCLR01		; not -1
 3481   4EE8   20 10 5E    		jsr	GET_NYBBLE	; get me the color nybble here
 3482   4EEB   4C F7 4E    		jmp	ZCLR11		; and use as background color
 3483   4EEE               	ZCLR01:
 3484   4EEE   CA          		dex			; check for default
 3485   4EEF   D0 02       		bne	ZCLR1		; nope, find the color
 3486   4EF1   A2 01       		ldx	#1		; use black as default back color
 3487   4EF3               	ZCLR1:
 3488   4EF3   CA          		dex			; zero base the color
 3489   4EF4   BD 44 6C    		lda	ZIPCOLOR,X	; get my color from the zip color
 3490   4EF7               	ZCLR11:
 3491   4EF7   A0 0E       		ldy	#WINBGND	; get background offset
 3492   4EF9   91 7A       		sta	(J),Y		; saved color
 3493                      	;
 3494                      	; now do foreground color
 3495                      	;
 3496   4EFB               	ZCLR2:
 3497   4EFB   A6 63       		ldx 	ARG1+LO		; get foreground color
 3498   4EFD   F0 0E       		beq	ZCLREX		; no change
 3499   4EFF   CA          		dex			; check for default
 3500   4F00   D0 02       		bne	ZCLR3		; nope, find the color
 3501   4F02   A2 08       		ldx	#8		; use white as default fore color
 3502   4F04               	ZCLR3:
 3503   4F04   CA          		dex			; zero base the color
 3504   4F05   BD 44 6C    		lda	ZIPCOLOR,X	; get my color from the zip color
 3505   4F08   A0 0D       		ldy	#WINFORE	; foreground color offset
 3506   4F0A   8A          		txa			; get into A for fun
 3507   4F0B   91 7A       		sta	(J),Y		; save in structure
 3508   4F0D               	ZCLREX:
 3509   4F0D   60          		rts
 3510                      	
 3511                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page   53

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3512                      	; CHKTME RTN - CALLED BY INPUT & ZINPUT
 3513                      	;
 3514   4F0E               	CHKTME:	
 3515   4F0E   A5 62       		lda	NARGS		; CHECK IF TIME LIMIT
 3516   4F10   C9 02       		cmp	#2
 3517   4F12   F0 12       		beq	CHKT1		; NO
 3518   4F14   A5 67       		lda	ARG3+LO		; GET DELAY WANTED
 3519   4F16   85 79       		sta	I+HI
 3520   4F18   A5 62       		lda	NARGS		; IS THERE A FCN?
 3521   4F1A   C9 04       		cmp	#4
 3522   4F1C   D0 08       		bne	CHKT1		; NO
 3523   4F1E   A5 69       		lda	ARG4+LO		; YES, SET IT
 3524   4F20   85 7A       		sta	J+LO
 3525   4F22   A5 6A       		lda	ARG4+HI
 3526   4F24   85 7B       		sta	J+HI
 3527   4F26               	CHKT1:
 3528   4F26   60          		rts			; just set things up, please
 3529                      	
 3530   4F27               	WAIT10:
 3531   4F27   A9 02       	        lda     #2              ; do this twice (maybe)
 3532   4F29   85 C6       	        sta     DELAY_COUNTER   ; put in counter
 3533   4F2B               	WAIT0:
 3534   4F2B   AD 82 C0    	        lda     RDROM           ; get roms in
 3535   4F2E   A2 04       		ldx	#4		; .04 SEC (time to do other stuff)
 3536   4F30   A9 30       	TIME1:	lda	#$30		; .01 SEC
 3537   4F32   20 A8 FC    		jsr	MWAIT	
 3538   4F35   CA          		dex		
 3539   4F36   D0 F8       		bne	TIME1	
 3540                      	
 3541   4F38   AD 83 C0    	        lda     BNK2SET         ; get roms out
 3542   4F3B   AD 83 C0    	        lda     BNK2SET
 3543                      	
 3544   4F3E   A5 58       		lda	MOUSEF		; move mouse cursor?
 3545   4F40   F0 08       		beq	WAIT1		; nope
 3546   4F42   AD A9 6C    	        lda     PTR_COUNT       ; but do we really want to check it
 3547   4F45   D0 03       	        bne     WAIT1           ; nope
 3548   4F47   4C 2B 50    		jmp	MOVE_MC		; move cursor, if necessary
 3549   4F4A               	WAIT1:
 3550   4F4A   C6 C6       	        dec     DELAY_COUNTER   ; count loop
 3551   4F4C   D0 DD       	        bne     WAIT0           ; go do again
 3552   4F4E   60          		rts
 3553                      	;
 3554                      	; tick the ol timer
 3555                      	;
 3556   4F4F               	TIMEK:
 3557   4F4F   A9 03       		lda	#BLINK_RATE	; how often to blink
 3558   4F51   8D 92 4F    		sta	CURCOUNT	; okay!
 3559   4F54               	TIMEST:
 3560   4F54   A5 78       		lda	I+LO		; don't reset if not zero
 3561   4F56   D0 07       		bne	TIMELOOP	; so keep goin' then
 3562   4F58   A5 79       		lda	I+HI
 3563   4F5A   85 78       		sta	I+LO
 3564   4F5C   20 93 4F    		jsr	STCUR		; start the cursor
 3565   4F5F               	TIMELOOP:
 3566   4F5F   20 27 4F    		jsr	WAIT10		; wait .10 secs
 3567                      	
 3568   4F62   20 E6 4F    		jsr	FKEYX		; Check for Keystroke
 3569   4F65   30 23       		bmi	TIME2		; OK, HE'S THERE, CONTINUE
 3570                      	
 3571   4F67   CE 92 4F    		dec	CURCOUNT	; count down to toggle
 3572   4F6A   D0 08       		bne	TMCNT		; okay, no blink
 3573   4F6C   20 93 4F    		jsr	STCUR		; blink cursor
 3574   4F6F   A9 03       		lda	#BLINK_RATE	; once per second
 3575   4F71   8D 92 4F    		sta	CURCOUNT	; okay!
 3576   4F74               	TMCNT:
 3577   4F74   C6 78       		dec	I+LO		; 10TH'S OF SECONDS TO WAIT
 3578   4F76   F0 02       		beq	TIMEOUT		; SOME TIME LEFT
 3579                      	
 3580   4F78   D0 E5       		bne	TIMELOOP	; so gwon back and try again! (JMP)
 3581                      	;
 3582                      	; THERE IS A TIME OUT, CHECK FOR A FCN
 3583                      	;
 3584   4F7A               	TIMEOUT:
 3585   4F7A   20 BE 4F    		jsr	ERCUR		; after erasing cursor
 3586   4F7D   A5 7B       		lda	J+HI		; IS THERE A FCN
  Wed Jun  7 1989 12:04                                                                                                  Page   54

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3587   4F7F   F0 0E       		beq	TIMEBAD		; NO FCN, LEAVE WITH NOTHING
 3588   4F81               	TIME3:
 3589   4F81   20 18 5B    		jsr	INTCLL		; INTERNALLY CALL THE FCN
 3590   4F84   A5 76       		lda	VALUE+LO	; CHECK RESULTS
 3591   4F86   F0 CC       		beq	TIMEST		; ELSE TRY AGAIN
 3592   4F88   D0 05       		bne	TIMEBAD		; else die a horrible death!
 3593   4F8A               	TIME2:
 3594   4F8A   20 BE 4F    		jsr	ERCUR		; after erasing cursor
 3595   4F8D   18          		clc			; GOT A KEY
 3596   4F8E   60          		rts
 3597   4F8F               	TIMEBAD:
 3598   4F8F   38          		sec
 3599   4F90   60          		rts
 3600                      	;
 3601                      	; display the cursor in the current spot
 3602                      	;
 3603   4F91   80          	CURSTATE:	db	$80	; blinking cursor state
 3604   4F92   00          	CURCOUNT:	db	0	; toggle counter
 3605                      	
 3606   4F93               	STCUR:
 3607   4F93   AD A7 6C    	        lda     CURSOR_OFF      ; is the cursor off?
 3608   4F96   F0 01       	        beq     STCUR1          ; no
 3609   4F98   60          	        rts                     ; yes, so don't do nuthin'
 3610   4F99               	STCUR1:
 3611   4F99   48          		pha			; save a
 3612   4F9A   A5 BB       		lda	INVFLG		; get current INVFLG
 3613   4F9C   48          		pha			; save it
 3614   4F9D   A9 80       		lda	#$80		; make it all be ones
 3615   4F9F   85 BB       		sta	INVFLG		; and blink
 3616                      	
 3617   4FA1   A9 20       		lda	#SPACE		; space for cursor
 3618   4FA3   8D E3 71    		sta	SHOW_CURSOR	; show that we are doing cursor
 3619   4FA6   20 82 5D    		jsr	CHAR		; and print it out
 3620   4FA9   20 F1 71    		jsr	DISP_LINE	; send it out
 3621                      	
 3622   4FAC   AD 91 4F    		lda	CURSTATE	; get current state
 3623   4FAF   49 80       		eor	#$80		; toggle it
 3624   4FB1   8D 91 4F    		sta	CURSTATE	; save it
 3625   4FB4   68          		pla			; get invflg
 3626   4FB5   85 BB       		sta	INVFLG		; restored
 3627   4FB7   A9 00       		lda	#0		; clear cursor flag
 3628   4FB9   8D E3 71    		sta	SHOW_CURSOR	; okay
 3629   4FBC               		
 3630   4FBC   68          		pla
 3631   4FBD   60          		rts
 3632                      	;
 3633                      	; just erase the cusor char, but leave cursor in its old place
 3634                      	;
 3635   4FBE               	ERCUR:
 3636   4FBE   48          		pha			; save a
 3637   4FBF   AD 91 4F    		lda	CURSTATE	; get current state
 3638   4FC2   D0 03       		bne	ERCURX		; not on, leave alone
 3639   4FC4   20 93 4F    		jsr	STCUR		; 'start' it out
 3640   4FC7               	ERCURX:
 3641   4FC7   68          		pla			; retrieve [A]
 3642   4FC8   60          		rts
 3643                      	;
 3644                      	; timed key input loop
 3645                      	;
 3646                      	; carry set if timed out
 3647                      	; char in [A], if there is one!
 3648   4FC9               	TIMIN:
 3649   4FC9   A5 58       		lda	MOUSEF		; is there a mouse/joystick?
 3650   4FCB   F0 03       		beq	TIMIN1		; nope
 3651   4FCD   20 BA 62    		jsr	MSCON		; turn on mouse cursor
 3652   4FD0               	TIMIN1:
 3653   4FD0   20 4F 4F    		jsr	TIMEK		; check for keystroke
 3654   4FD3   B0 05       		bcs	TMBAD		; ELSE ABORT
 3655   4FD5               	TM1:
 3656   4FD5   20 8B 51    		jsr	PARSEKEY	; GET ASCII INTO [A] AND [IOCHAR]
 3657   4FD8   B0 F6       		bcs	TIMIN1		; c==1 means no good char
 3658   4FDA               	TMBAD:
 3659   4FDA   A6 58       		ldx	MOUSEF		; is there a mouse/joystick?
 3660   4FDC   F0 07       		beq	TIMIN2		; nope
 3661   4FDE   08          		php			; save status
  Wed Jun  7 1989 12:04                                                                                                  Page   55

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3662   4FDF   48          		pha			; save (possible) char
 3663   4FE0   20 5B 62    		jsr	MSCOFF		; turn off mouse cursor
 3664   4FE3   68          		pla			; get char back
 3665   4FE4   28          		plp			; get return status
 3666   4FE5               	TIMIN2:
 3667   4FE5   60          		rts			; and away we go
 3668                      	;
 3669                      	; FKEYX - move the mouse cursor if any, then check for keystroke
 3670                      	;
 3671   4FE6               	FKEYX:
 3672   4FE6   A5 58       		lda	MOUSEF		; is there a mouse cursor?
 3673   4FE8   F0 38       		beq	KEYX		; nope
 3674   4FEA   30 07       		bmi	KEYMOUSE	; handle mouse
 3675   4FEC   20 AD 50    		jsr	DO_STICK	; handle joystick
 3676   4FEF   10 31       		bpl	KEYX		; go look for key still
 3677   4FF1   30 05       		bmi	KEYBTN		; do button handling
 3678   4FF3               	KEYMOUSE:
 3679   4FF3   20 6E 50    		jsr	DO_MOUSE	; handle mouse stuff
 3680   4FF6   10 2A       		bpl	KEYX		; go look for key still
 3681                      	;
 3682                      	; button hit, so show pos in MSTBL
 3683                      	;
 3684   4FF8               	KEYBTN:
 3685   4FF8   48          		pha			; save status
 3686   4FF9   A5 CE       		lda	MSTBL+LO
 3687   4FFB   85 8F       		sta	SPCL
 3688   4FFD   A5 CF       		lda	MSTBL+HI
 3689   4FFF   85 90       		sta 	SPCH
 3690   5001   A5 D0       		lda	MSTBL+ABANK
 3691   5003   85 91       		sta	SPCBNK
 3692   5005   A9 03       		lda	#ZMSLOCX+1	; point to LSB of mouse x
 3693   5007   20 06 90    		jsr	ADDSPC		; add to point
 3694   500A   A5 CB       		lda	MSX		; get X
 3695   500C   18          	        clc                     ; center the hot spot
 3696   500D   69 01       	        adc     #CURSW/2        ; add 1/2 width
 3697   500F   20 3A 92    		jsr	STASHB		; and stuff it away
 3698   5012   A9 02       		lda	#2		; 2 more to get to mouse y
 3699   5014   20 06 90    		jsr	ADDSPC		; okay
 3700   5017   A5 CC       		lda	MSY		; now show the world the y pos
 3701   5019   18          	        clc                     ; and center vertically too
 3702   501A   69 02       	        adc     #CURSH/2        ; add 1/2 height
 3703   501C   20 3A 92    		jsr	STASHB		; and it is away
 3704   501F   68          		pla			; get status back
 3705   5020   A8          		tay			; and set it again
 3706   5021   60          		rts			; otherwise, done
 3707   5022               	KEYX:
 3708   5022   AD 00 C0    		lda	KBD		; check keyboard strobe
 3709   5025   10 03       		bpl	KEYXX		; nothing
 3710   5027   8D 10 C0    		sta	ANYKEY		; reset strobe
 3711   502A               	KEYXX:
 3712   502A   60          		rts
 3713                      	;
 3714                      	; MOVE_MC - move the mouse/joystick cursor, if necessary
 3715                      	;
 3716   502B               	MOVE_MC:
 3717   502B   A5 58       		lda	MOUSEF		; check which kind to move
 3718   502D   10 06       		bpl	MOVE_MC1	; move joystick cursor
 3719   502F   20 41 50    		jsr	CHK_MOUSE	; move the mouse cursor
 3720   5032   4C 38 50    		jmp 	MOVE_MC2	; and print it
 3721   5035               	MOVE_MC1:
 3722   5035   20 B3 50    		jsr	MOVE_STICK	; okay, checked it out
 3723   5038               	MOVE_MC2
 3724   5038   AD 12 03    		lda	MSMOVEF		; did it move?
 3725   503B   F0 03       		beq	MOVE_MCX	; nope
 3726   503D   4C 50 62    		jmp	MSCURS		; print it
 3727   5040               	MOVE_MCX:
 3728   5040   60          		rts			; done
 3729                      	;
 3730                      	; CHK_MOUSE - check the mouse position and button state, and flag any change
 3731                      	;
 3732   5041               	CHK_MOUSE:
 3733   5041   AD 54 C0    		lda	PAGE2SW		; make sure we are pointing to main bank
 3734                      	
 3735   5044   A2 02       		ldx	#READM		; get me current cursor pos
 3736   5046   20 00 03    		jsr	MOUSER		; turn off interrupts and set current pos
  Wed Jun  7 1989 12:04                                                                                                  Page   56

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3737                      	
 3738   5049   AD 83 C0    		lda	BNK2SET		; make sure we are pointing to second bank
 3739   504C   AD 83 C0    		lda	BNK2SET		; okay
 3740                      	
 3741   504F   AD 78 07    	MSFIX0	lda	MOUSEST		; get status byte
 3742   5052   A8          		tay			; save for a sec
 3743   5053   29 20       		and	#$20		; moved since last time?
 3744   5055   F0 0D       		beq	CHKM1		; nope
 3745   5057   8D 12 03    		sta	MSMOVEF		; show movement
 3746   505A   AD 78 04    	MSFIX1	lda	MOUSEXL		; get mouse X pos
 3747   505D   85 CB       		sta	MSX		; save new one
 3748   505F   AD F8 04    	MSFIX2	lda	MOUSEYL		; and the y pos
 3749   5062   85 CC       		sta	MSY		; save for me
 3750   5064               	CHKM1:
 3751   5064   98          		tya			; get status back
 3752   5065   29 C0       		and	#$C0            ; is button down?
 3753   5067   F0 02       		beq	CHKMX		; nope
 3754   5069   A9 80       		lda	#$80            ; show down state
 3755   506B               	CHKMX:
 3756   506B   4C 25 51    	        jmp     CHK_BTN         ; check button state
 3757                      	;
 3758                      	; there is a mouse, so check it		 
 3759                      	;
 3760   506E               	DO_MOUSE:
 3761   506E   20 41 50    		jsr	CHK_MOUSE	; check the mouse please
 3762                      	; FALL THROUGH TO BUTTON CLICKING HANDLER
 3763                      	;	jmp	DO_BUTTON	; handle button clicking
 3764                      	;
 3765                      	; DO_BUTTON - handle button clicking, working with the timer to
 3766                      	; 	check for double clicking or not
 3767                      	;
 3768   5071               	DO_BUTTON:
 3769   5071   AD 12 03    		lda	MSMOVEF		; check moved flag
 3770   5074   F0 03       		beq	DOM01		; nope
 3771   5076   20 50 62    		jsr	MSCURS		; move mouse cursor
 3772   5079               	DOM01:
 3773   5079   A9 00       		lda	#0		; show no char
 3774   507B   AC 13 03    		ldy	MSBTNF		; check button flag
 3775   507E   10 15       		bpl	DOBX		; none
 3776                      	;
 3777                      	; button strike, check for double click
 3778                      	;
 3779   5080   8C 02 51    	        sty     JB_STATE        ; show new state
 3780   5083   A4 CA       		ldy	CLKCTR		; have we started click counter?
 3781   5085   10 08       		bpl	DOB02		; nope
 3782   5087   A0 01       		ldy	#1		; this resets counter
 3783   5089   84 CA       		sty	CLKCTR		; reset it
 3784   508B   A9 82       		lda	#DBL_CLK	; show double click char
 3785   508D   D0 14       		bne	DOBEXIT		; and finis
 3786   508F               	DOB02:
 3787   508F   A0 FA       		ldy	#-CLK_CNT	; set to double click timeout
 3788   5091   84 CA       		sty	CLKCTR		; okay
 3789   5093   30 0E       		bmi	DOBEXIT		;done
 3790   5095               	DOBX:
 3791   5095   A4 CA       		ldy	CLKCTR		; click counter counting?
 3792   5097   10 0A       		bpl	DOBEXIT		; nope
 3793   5099   E6 CA       		inc	CLKCTR		; count it then
 3794   509B   D0 06       		bne	DOBEXIT		; all done
 3795   509D   A0 01       		ldy	#1		; reset counter
 3796   509F   84 CA       		sty	CLKCTR		; okay
 3797   50A1   A9 81       		lda	#SGL_CLK	; set as char
 3798   50A3               	DOBEXIT:
 3799   50A3   A0 00       		ldy	#0		; clear out flags
 3800   50A5   8C 13 03    		sty	MSBTNF		; button flag
 3801   50A8   8C 12 03    		sty	MSMOVEF		; moved flag
 3802   50AB   A8          		tay			; set flag to show any char
 3803   50AC   60          		rts			; return char	
 3804                      	;
 3805                      	; DO_STICK - handle the joystick 'interrupt'
 3806                      	;
 3807   50AD               	DO_STICK:
 3808   50AD   20 B3 50    		jsr	MOVE_STICK	; first move it
 3809   50B0   4C 71 50    		jmp	DO_BUTTON	; now handle it
 3810   50B3               	MOVE_STICK:
 3811   50B3   A9 00       		lda	#0		; get horizontal change
  Wed Jun  7 1989 12:04                                                                                                  Page   57

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3812   50B5   20 03 51    		jsr	READ_STICK	; puts value in Y
 3813   50B8   C0 50       		cpy	#80		; if < 80, then jump to the left
 3814   50BA   B0 0D       		bcs	DOST1		; it is not
 3815   50BC   A5 CB       		lda	MSX		; make sure X is > 0
 3816   50BE   F0 1A       		beq	DOST2		; it is == 0, can't get smaller
 3817   50C0   8D 12 03    		sta	MSMOVEF		; show movement
 3818   50C3   C6 CB       		dec	MSX		; move one to the left
 3819   50C5   C6 CB       		dec	MSX		; move two to the left
 3820   50C7   D0 11       		bne	DOST2		; now check vertical
 3821   50C9               	DOST1:
 3822   50C9   C0 B4       		cpy	#180		; if > 160, then move right
 3823   50CB   90 0D       		bcc	DOST2		; nope
 3824   50CD   A5 CB       		lda	MSX		; make sure X is in bounds
 3825   50CF   C9 88       		cmp	#MAXWIDTH-4	; don't go too far
 3826   50D1   B0 07       		bcs	DOST2		; already maxxed out
 3827   50D3   8C 12 03    		sty	MSMOVEF		; show movement
 3828   50D6   E6 CB       		inc	MSX		; one step to the left
 3829   50D8   E6 CB       		inc	MSX		; and another one
 3830   50DA               	DOST2:
 3831   50DA   A9 01       		lda	#1		; now check vertical
 3832   50DC   20 03 51    		jsr	READ_STICK	; ask the monitor
 3833   50DF   C0 50       		cpy	#80		; if < 80, move up
 3834   50E1   B0 0D       		bcs	DOST3		; nope
 3835   50E3   A5 CC       		lda	MSY		; don't go negative
 3836   50E5   F0 1A       		beq	DOST4		; already minned out
 3837   50E7   8D 12 03    		sta	MSMOVEF		; show movement
 3838   50EA   C6 CC       		dec	MSY		; count down
 3839   50EC   C6 CC       		dec	MSY		; twice
 3840   50EE   D0 11       		bne	DOST4		; all done
 3841   50F0               	DOST3:
 3842   50F0   C0 B4       		cpy	#180		; check for downward motion
 3843   50F2   90 0D       		bcc	DOST4		; none
 3844   50F4   A5 CC       		lda	MSY		; check for maximum
 3845   50F6   C9 BD       		cmp	#MAXHEIGHT-3	; don't go below water
 3846   50F8   B0 07       		bcs	DOST4		; gone, thanx
 3847   50FA   8C 12 03    		sty	MSMOVEF		; show movement
 3848   50FD   E6 CC       		inc	MSY		; go further down
 3849   50FF   E6 CC       		inc	MSY		; twice as far for joystick
 3850   5101               	DOST4:
 3851   5101   60          		rts			; done
 3852                      	;
 3853                      	; READ_STICK - read the x or y value of the stick in mind.
 3854                      	;       [A] == 0 or 1 - the "stick" you are interested in
 3855                      	;       Also, check the button status.
 3856                      	;
 3857   5102   00          	JB_STATE  db    0               ; last state of joystick button
 3858   5103               	READ_STICK:
 3859   5103   48          		pha			; save which stick we want
 3860   5104   A2 E0       		ldx	#$E0            ; oh, pick something random
 3861   5106               	READST2:
 3862   5106   20 1B 51    	        jsr     CHECK_JOYBTN    ; check the joystick button
 3863   5109   CA          		dex
 3864   510A   D0 FA       		bne	READST2
 3865   510C   68          		pla			; get x back
 3866   510D   AA          	        tax                     ; got it
 3867   510E   AD 82 C0    	        lda     RDROM           ; bring ROM back
 3868   5111   20 1E FB    		jsr	MPREAD		; NOW do the read
 3869   5114   AD 83 C0    	        lda     BNK2SET         ; back to RAM
 3870   5117   AD 83 C0    	        lda     BNK2SET         ; back to RAM
 3871   511A   60          	        rts
 3872   511B               	CHECK_JOYBTN:
 3873   511B   A5 58       		lda	MOUSEF		; check which kind to move
 3874   511D   10 03       		bpl	DO_JBTN         ; no joystick, check mouse
 3875   511F   4C 41 50    	        jmp     CHK_MOUSE       ; then do the mouse
 3876   5122               	DO_JBTN:
 3877   5122   AD 61 C0    	        lda     APKEY1          ; get joystick button
 3878   5125               	CHK_BTN:
 3879   5125   30 03       	        bmi     READST3         ; button down
 3880   5127   8D 02 51    	        sta     JB_STATE        ; show button went up        
 3881   512A               	READST3:
 3882   512A   4D 02 51    	        eor     JB_STATE        ; toggle previous state        
 3883   512D   8D 13 03    	        sta     MSBTNF          ; set button flag
 3884   5130   60          	        rts
 3885                      	; ----------------------------
 3886                      	; FETCH ASCII KEYCODE INTO [A]
  Wed Jun  7 1989 12:04                                                                                                  Page   58

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3887                      	; ----------------------------
 3888                      	; EXIT: ASCII IN [A] & [IOCHAR]
 3889                      	
 3890   5131               	GETKEY:
 3891   5131   A9 03       		lda	#BLINK_RATE	; flag as wait for good key
 3892   5133   8D 92 4F    		sta	CURCOUNT	; clear blinker
 3893   5136   A5 58       		lda	MOUSEF		; is there a mouse/joystick?
 3894   5138   F0 03       		beq	GTK0		; nope
 3895   513A   20 BA 62    		jsr	MSCON		; turn on mouse cursor
 3896   513D               	GTK0:
 3897   513D   A9 00       		lda	#0		; clear line counter
 3898   513F   85 AB       		sta	LINCNT		; okay, we did
 3899   5141   8A          		txa			; SAVE [X] & [Y]
 3900   5142   48          		pha		
 3901   5143   98          		tya		
 3902   5144   48          		pha		
 3903   5145               	GKEY0:
 3904   5145   E6 A5       		inc	RAND+HI		; just whack on random number
 3905   5147   C6 A4       		dec	RAND+LO		; and more
 3906   5149   20 E6 4F    		jsr	FKEYX		; is there a key?
 3907   514C   30 23       		bmi	GKEY01		; got the key
 3908                      	
 3909   514E   20 27 4F    		jsr	WAIT10		; wait .1 seconds, moving mouse cursor
 3910                      	
 3911   5151   A5 58       	        lda     MOUSEF          ; do we have a joystick/mouse?
 3912   5153   F0 0D       	        beq     GKEY02          ; nope
 3913   5155   AD A9 6C    	        lda     PTR_COUNT       ; count down counter?
 3914   5158   F0 05       	        beq     GKEY00          ; nope
 3915   515A   CE A9 6C    	        dec     PTR_COUNT       ; count one wait cycle
 3916   515D   D0 03       	        bne     GKEY02          ; don't check yet
 3917   515F               	GKEY00:
 3918   515F   20 1B 51    	        jsr     CHECK_JOYBTN    ; check the joystick button, just fur the heckuvit
 3919   5162               	GKEY02:
 3920   5162   CE 92 4F    		dec	CURCOUNT	; down one
 3921   5165   D0 DE       		bne	GKEY0		; no toggle
 3922   5167   20 93 4F    		jsr	STCUR		; okay, toggle
 3923   516A   A9 03       		lda	#BLINK_RATE	; 1 per second
 3924   516C   8D 92 4F    		sta	CURCOUNT	; okay
 3925   516F   D0 D4       		bne	GKEY0		; check for key
 3926   5171               	GKEY01:
 3927   5171   48          		pha			; save char
 3928   5172   A5 58       		lda	MOUSEF		; any mouse cursor?
 3929   5174   F0 03       		beq	GTK1		; nope
 3930   5176   20 5B 62    		jsr	MSCOFF		; turn mouse cursor off
 3931   5179               	GTK1:
 3932   5179   68          		pla			; get char back
 3933   517A   20 BE 4F    		jsr	ERCUR		; so erase cursor
 3934   517D               	CHKKEY:
 3935   517D   20 8B 51    		jsr	PARSEKEY	; how was the key?
 3936   5180   B0 C3       		bcs	GKEY0		;TRY AGAIN
 3937   5182   85 AC       		sta	IOCHAR		;HOLD ON TO IT
 3938   5184   68          		pla			; RESTORE
 3939   5185   A8          		tay			; EVERYTHING
 3940   5186   68          		pla		
 3941   5187   AA          		tax		
 3942   5188   A5 AC       		lda	IOCHAR		; GET CHAR INTO [A]
 3943   518A   60          		rts			; AND RETURN IT
 3944                      	
 3945                      	;
 3946                      	; CHECK TO MAKE SURE KEY IS VALID, ONLY ACCEPT IT IF IT IS
 3947                      	;
 3948   518B               	PARSEKEY:
 3949   518B   29 7F       		and	#$7F	;SCREEN OUT SHIFTS
 3950                      	;
 3951                      	;CHECK FOR "ARROWS" & FUNCTION KEYS (X),  CONVERT FOR USE (EZIP)
 3952                      	;ALSO : CHANGE <_>)@%^&*( TO ,-.0256789 - and 'mouse' clicks
 3953                      	; and other kinds of special chars
 3954                      	;
 3955   518D               	GK0:
 3956   518D   A2 12       		ldx	#ENDKEY ; GET LENGTH OF LIST
 3957   518F               	GK2:
 3958   518F   DD D4 51    		cmp	HAVE,X	; CHECK AGAINST LIST OF UNWANTED KEYS
 3959   5192   F0 05       		beq	GK3	; FOUND IT
 3960   5194   CA          		dex
 3961   5195   10 F8       		bpl	GK2	; CHECK THEM ALL
  Wed Jun  7 1989 12:04                                                                                                  Page   59

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3962   5197   30 05       		bmi	GK4	; NOT FOUND, CONTINUE OTHER CHECKS
 3963   5199               	GK3:
 3964   5199   BD E7 51    		lda	WANT,X	; GET KEY TO USE INSTEAD
 3965   519C   18          		clc		; show niceness
 3966   519D   60          		rts		; done
 3967   519E               	GK4:
 3968   519E   C9 20       		cmp	#SPACE	; NO CTRL CHARS ACCEPTABLE
 3969   51A0   90 14       		bcc	BADKEY	; IF < SPACE, BAD
 3970                      	
 3971   51A2   C9 3C       		cmp	#'<'	; pick up numbers and most punctuation
 3972   51A4   90 15       		bcc	OK	; we did
 3973                      	
 3974   51A6   C9 7B       		cmp	#'z'+1	;PICK OUT LETTERS NOW
 3975   51A8   B0 0C       		bcs	BADKEY	;IF > BAD
 3976   51AA   C9 61       		cmp	#'a'
 3977   51AC   B0 0D       		bcs	OK	;IF > OK
 3978   51AE   C9 41       		cmp	#'A'
 3979   51B0   90 04       		bcc	BADKEY
 3980   51B2   C9 5B       		CMP	#'Z'+1	
 3981   51B4   90 05       		BCC	OK	;IF < OK
 3982   51B6               	BADKEY:
 3983   51B6   20 C3 4E    		jsr	BEEP	;BAD KEY, GIVE WARNING NOISE, gwon back
 3984   51B9   38          		sec		; show badness
 3985   51BA   60          		rts		; and done
 3986   51BB               	OK:
 3987   51BB   C9 30       		cmp	#'0'	; check for number keys
 3988   51BD   90 13       		bcc	OKj	; nope, < 0
 3989   51BF   C9 3A       		cmp	#'9'+1	; more than a nine?
 3990   51C1   B0 0F       		bcs	OKj	; ayyup
 3991                      	;
 3992                      	; here we check for the closed apple key being down too
 3993                      	;
 3994   51C3   AE 62 C0    		ldx	APKEY2	; how about the closed apple key
 3995   51C6   10 0A       		bpl	OKj	; not pressed,	so use as number key
 3996                      	;
 3997                      	; transform number key into a function key
 3998                      	;
 3999   51C8   18          		CLC		; get ready for add
 4000   51C9   69 54       		ADC	#84	; transforms '1'-'9' to 133-141
 4001   51CB   C9 84       		CMP	#132	; but '0' wants to be a 142!
 4002   51CD   D0 03       		BNE 	OKj	; but it's not it
 4003   51CF   18          		CLC		; again, don't want carry
 4004   51D0   69 0A       		ADC	#10	; voila!
 4005   51D2               	OKj:
 4006   51D2   18          		clc		; show a wicked good character is about to arrive
 4007   51D3   60          		rts		; toots finis
 4008                      	
 4009   51D4   0B 0A 08 15 7F 	HAVE:	DB	$0B,$0A,$08,$15,$7f,ESCAPE,$3C,$7C,$3F
        51D9   1B 3C 7C 3F 
 4010   51DD   3C 5F 3E 40 25 		DB	$3C,$5F,$3E,$40,$25,$5E,$26,$01,$02, EOL
        51E2   5E 26 01 02 0D 
 4011   51E7   81 82 83 84 08 	WANT:	DB	129,130,131,132,08,ESCAPE,$3C,$7C,$3F
        51EC   1B 3C 7C 3F 
 4012   51F0   2C 2D 2E 32 35 		DB	$2C,$2D,$2E,$32,$35,$36,$37,254,253, EOL
        51F5   36 37 FE FD 0D 
 4013          0012        	ENDKEY	EQU	$-WANT-1
 4014                      	
 4015   51FA               		END
 4016                      	
 4017   51FA               		INCLUDE		IO.ASM	
 4018   51FA               		STTL "--- GAME I/O: APPLE II ---"
 4019                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page   60

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4020                      	
 4021                      		; --------------
 4022                      		; INTERNAL ERROR
 4023                      		; --------------
 4024                      		; ENTRY: ERROR CODE IN [A]
 4025                      		; EXIT: HA!
 4026                      	
 4027   51FA   0D 49 6E 74 65 	ERRM:	DB	EOL,"Internal error "
        51FF   72 6E 61 6C 20 
        5204   65 72 72 6F 72 
        5209   20 
 4028          0010        	ERRML	EQU	$-ERRM
 4029                      	
 4030   520A               	ZERROR:
 4031   520A   48          		pha			; save err number
 4032   520B   20 A9 4C    	        jsr     SWAP2INFOW      ; go to the info window (window 0)`
 4033   520E               		DLINE	ERRM		; print message
 4034   520E   A2 FA       		ldx	#<ERRM	; get part of ERRM
 4035   5210   A9 51       		lda	#>ERRM	; get other part of string
 4036          [01]        		IFMA	2		; check to see if length passed in
 4037                      		ldy			; then just fetch it
 4038          [01]        		ELSE
 4039   5212   A0 10       		ldy	#ERRML	; get length of string
 4040          [00]        		ENDIF
 4041   5214   20 6B 4C    		jsr	DLINE		; print the string
 4042   5217               		.MACEND
 4043   5217   68          		pla			; get error number
 4044   5218   20 D3 47    		jsr	HEXNUM		; print error number
 4045   521B   4C 21 52    		jmp	ZQUIT1		; and die
 4046                      	
 4047                      	
 4048                      		; ----
 4049                      		; QUIT
 4050                      		; ----
 4051                      	
 4052   521E   20 E7 54    	ZQUIT:	JSR	ZCRLF		; FLUSH BUFFER
 4053   5221               	ZQUIT1:
 4054   5221               		DLINE	ENDM		; print ending message
 4055   5221   A2 8C       		ldx	#<ENDM	; get part of ENDM
 4056   5223   A9 52       		lda	#>ENDM	; get other part of string
 4057          [01]        		IFMA	2		; check to see if length passed in
 4058                      		ldy			; then just fetch it
 4059          [01]        		ELSE
 4060   5225   A0 10       		ldy	#ENDML	; get length of string
 4061          [00]        		ENDIF
 4062   5227   20 6B 4C    		jsr	DLINE		; print the string
 4063   522A               		.MACEND
 4064   522A   20 E0 8C    		jsr	GETRET		; wait for <CR>
 4065   522D   A5 59       	        lda     INFODOS         ; in dinky-dos?
 4066   522F   F0 17       	        beq     ZQUIT2          ; nope
 4067   5231   A9 00       	        lda     #0              ; clear power up byte
 4068   5233   8D F4 03    	        sta     $3F4            ; make it do cold boot        
 4069   5236   AD FD FF    	        lda     RESET_VECTOR+HI ; now, set up where to die to
 4070   5239   8D 47 52    	        sta     ZQUITR1+2
 4071   523C   AD FC FF    	        lda     RESET_VECTOR+LO
 4072   523F   8D 46 52    	        sta     ZQUITR1+1
 4073   5242   AD 82 C0    	        lda     RDROM           ; get ROM back
 4074   5245               	ZQUITR1:
 4075   5245   4C FC FF    	        jmp     RESET_VECTOR    ; just reset things
 4076                      	;
 4077                      	; re-enable /RAM
 4078                      	;
 4079   5248               	ZQUIT2:
 4080   5248   AE 31 BF    		ldx	DEVCNT		; put device in at end
 4081   524B   E8          		inx			; point to one past end
 4082   524C   8E 31 BF    		stx	DEVCNT		; show new count
 4083   524F   A9 BF       		lda	#$BF		; /RAM ID
 4084   5251   9D 32 BF    		sta	DEVNUM,X	; save it
 4085   5254   AD 7F 07    		lda	OLDVEC+HI	; restore old vector
 4086   5257   8D 27 BF    		sta	RAMVEC+HI
 4087   525A   AD 7E 07    		lda	OLDVEC+LO
 4088   525D   8D 26 BF    		sta	RAMVEC+LO
 4089                      	;
 4090                      	; now format /RAM
 4091                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page   61

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4092   5260   A9 03       		lda	#3		; stash into FORMAT parm block
 4093   5262   85 42       		sta	$42		; it goes here, oddly enough
 4094   5264   A9 B0       		lda	#$B0		; device id for /RAM
 4095   5266   85 43       		sta	$43		; and here it goes
 4096   5268   A9 11       		lda	#>GAME1FIO	; IO buffer
 4097   526A   85 45       		sta	$45		; this is where it goes
 4098   526C   A9 00       		lda	#<GAME1FIO	; lsb
 4099   526E   85 44       		sta	$44
 4100   5270   AD 80 C0    		lda	RDBNK2		; set up card for driver
 4101   5273   20 89 52    		jsr	RAMDRV		; format /RAM
 4102   5276   AD 82 C0    		lda	RDROM		; get ROM back
 4103   5279               		
 4104   5279   8D 51 C0    		sta	TEXTSW+ON	; turn on text
 4105   527C               		QUIT	QUIT_PB		
 4106   527C               		PRODOS 	$65, QUIT_PB
 4107   527C   20 00 BF    		jsr	$BF00	; ProDOS handler
 4108   527F   65          		DB	$65	; ProDOS function code
 4109   5280   8252        		DW	QUIT_PB	; Function Parameter Block address
 4110   5282               		.MACEND
 4111   5282               		.MACEND
 4112   5282               	QUIT_PB:
 4113   5282   04          		db	4		; 4 parms
 4114   5283   00 00 00 00 00 		db	0,0,0,0,0,0	; just zeros
        5288   00 
 4115   5289               	RAMDRV:
 4116   5289   6C 26 BF    		jmp	(RAMVEC)	; goto RAM driver
 4117                      	
 4118   528C   0D 45 6E 64 20 	ENDM:	DB	EOL,"End of session."
        5291   6F 66 20 73 65 
        5296   73 73 69 6F 6E 
        529B   2E 
 4119          0010        	ENDML	EQU	$-ENDM
 4120                      	
 4121                      	; -------
 4122                      	; RESTART
 4123                      	; -------
 4124   529C               	BOOT_RD:
 4125   529C   04          		db 	4
 4126   529D   00          		db	0
 4127   529E   0020        		dw	BORG		; put into where it wants
 4128   52A0   FFFF        		dw	$FFFF		; read lots
 4129   52A2               	BOOTNAME:
 4130   52A2   0E          		db	BNAMEL		; length will go here
 4131   52A3   49 4E 46 4F 43 	        db      "INFOCOM.SYSTEM"
        52A8   4F 4D 2E 53 59 
        52AD   53 54 45 4D 
 4132          000E        	BNAMEL  EQU     $-BOOTNAME-1
 4133   52B1               	ZSTART:
 4134   52B1   20 94 8C    		jsr	CLOSE_GAME	; make sure everything is closed
 4135                      	
 4136   52B4   A9 FF       		lda	#$FF		; just do a clear -1
 4137   52B6   85 63       		sta	ARG1+LO		; done
 4138   52B8   20 B0 57    		jsr	ZCLR		; to clear screen and set up window 0
 4139   52BB   A9 A2       		lda	#<BOOTNAME	; now, set open file name
 4140   52BD   8D D7 45    		sta	OPEN_FILE+OP_PATHNAME+LO
 4141   52C0   A9 52       		lda	#>BOOTNAME
 4142   52C2   8D D8 45    		sta	OPEN_FILE+OP_PATHNAME+HI
 4143   52C5   A9 31       		lda	#'1'		; set disk name to disk #1
 4144   52C7   8D C5 49    	        sta     SAVENUM         ; show open_gamef
 4145   52CA   20 22 4B    	        jsr     OPEN_GAMEF      ; okay
 4146                      	
 4147   52CD   AD DB 45    		lda	OPEN_FILE+OP_REFNUM ; get ref num
 4148   52D0   8D 9D 52    		sta	BOOT_RD+RD_REFNUM ; save ref num
 4149   52D3   8D 0C 8B    		sta	CLOSE_PB+CL_REFNUM
 4150   52D6               		READ	BOOT_RD		; read in boot system
 4151   52D6               		PRODOS	$CA, BOOT_RD
 4152   52D6   20 00 BF    		jsr	$BF00	; ProDOS handler
 4153   52D9   CA          		DB	$CA	; ProDOS function code
 4154   52DA   9C52        		DW	BOOT_RD	; Function Parameter Block address
 4155   52DC               		.MACEND
 4156   52DC               		.MACEND
 4157   52DC   90 03       		bcc	ZSTRTX		; okay, everything is fine
 4158   52DE   4C 74 47    		jmp	DISK_FATAL	; die otherwise
 4159   52E1               	ZSTRTX:
 4160   52E1               		CLOSE	CLOSE_PB	; and close it up
  Wed Jun  7 1989 12:04                                                                                                  Page   62

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4161   52E1               		PRODOS	$CC, CLOSE_PB
 4162   52E1   20 00 BF    		jsr	$BF00	; ProDOS handler
 4163   52E4   CC          		DB	$CC	; ProDOS function code
 4164   52E5   0B8B        		DW	CLOSE_PB	; Function Parameter Block address
 4165   52E7               		.MACEND
 4166   52E7               		.MACEND
 4167   52E7   4C 00 20    		jmp	BORG		; and go to it
 4168   52EA               		
 4169                      		; --------------------------------
 4170                      		; RETURN RANDOM BYTES IN [A] & [X]
 4171                      		; --------------------------------
 4172   52EA               	RANDOM:
 4173   52EA   E6 A5       	        inc	RAND+HI	
 4174   52EC   C6 A4       		dec	RAND+LO	
 4175   52EE   A5 A4       		lda	RAND+LO         ; get LSB
 4176   52F0   65 A5       	        adc     RAND+HI         ; add MSB
 4177   52F2   29 7F       	        and     #$7F            ; don't let it go into $C0 page
 4178   52F4   85 A5       	        sta     RAND+HI         ; new MSB        
 4179   52F6   A8          	        tay                     ; get random offset
 4180   52F7   B1 A4       	        lda     (RAND),Y        ; get random number
 4181   52F9   AA          	        tax                     ; save in X
 4182   52FA   65 A4       	        adc     RAND+LO         ; and go to another spot
 4183   52FC   29 7F       	        and     #$7F            ; don't go above $80
 4184   52FE   85 A5       	        sta     RAND+HI         ; okay
 4185   5300   A8          	        tay                     ; more randomness
 4186   5301   B1 A4       	        lda     (RAND),Y        ; and get it again
 4187   5303   05 A5       	        ora     RAND+HI         ; set more bits
 4188   5305   60          		rts		
 4189                      	
 4190                      	
 4191                      		; -------------------
 4192                      		; Z-PRINT A CHARACTER
 4193                      		; -------------------
 4194                      		; ENTRY: ASCII CHAR IN [A]
 4195                      		; COMMENT: SCRIPTING IS HANDLED IN UNBUFR AND FLUSH,
 4196                      		; SO CAN OUTPUT TO PRINTER AS A LINE.  TABLE AND SCREEN
 4197                      		; OUTPUT IS SET UP HERE, HANDLED A BYTE AT A TIME
 4198                      		; (DIROUT CHANGES 6/24/85)
 4199                      	
 4200   5306               	COUT:
 4201   5306   85 AC       		sta	IOCHAR		; HOLD IT A SEC
 4202   5308   A6 B2       		ldx	TABLEF		; OUTPUT TO TABLE?
 4203   530A   F0 07       		beq	COUT1		; NO
 4204   530C   A6 19       		ldx	FMTTBL		; formatted table?
 4205   530E   D0 0D       		bne	COUT5		; yes, so just do it normal
 4206   5310   4C 86 53    		jmp	TBLOUT		; just put into table
 4207   5313               	COUT1:
 4208   5313   A6 B1       		ldx	SCREENF		; OUTPUT TO SCREEN?
 4209   5315   D0 06       		bne	COUT5		; YES
 4210   5317   AE 78 6C    		ldx	SCRIPTF		; OUTPUT TO PRINTER?
 4211   531A   D0 01       		bne	COUT5		; YES
 4212   531C   60          		rts			; NO, SO DONE
 4213   531D               	COUT5:
 4214   531D   A5 AC       		lda	IOCHAR		; RETRIEVE CHAR
 4215   531F   30 5B       		bmi	COUT2		; highlight chars have no width
 4216                      	;
 4217                      	; this is an entry point for DLINE, so it doesn't check any of the above
 4218                      	; things.  Enter with character in [A]
 4219                      	;
 4220   5321               	DIRECT_OUT: 
 4221   5321   C9 0D       		cmp	#EOL		; IF ASCII EOL, just handle it special
 4222   5323   D0 03       		bne	COUT0	
 4223                      	
 4224   5325   4C E7 54    		jmp	ZCRLF		; DO IT
 4225   5328               	COUT0:
 4226   5328   B0 20       		bcs	COUT02          ; not control character
 4227   532A   C9 0B       	        cmp     #EOS            ; control-k (end of sentence)?
 4228   532C   F0 0E       	        beq     COUT01          ; yes, so put out 2 spaces
 4229   532E   C9 09       	        cmp     #TAB            ; tab char?
 4230   5330   D0 53       	        bne     CEX             ; ignore all other control chars
 4231                      	;
 4232                      	; this means do a couple of spaces
 4233                      	;
 4234   5332   A9 20       	        lda     #SPACE          ; do 3 spaces for start of line
 4235   5334   20 06 53    	        jsr     COUT            ; a little recursion never hurt!
  Wed Jun  7 1989 12:04                                                                                                  Page   63

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4236   5337   A6 A9       	        ldx     CHRCNT          ; back to beginning of line?
 4237   5339   D0 01       	        bne     COUT01          ; nope
 4238   533B               	COUT010:
 4239   533B   60          	        rts                     ; don't do any to start line
 4240   533C               	COUT01:
 4241   533C   A9 20       	        lda     #SPACE          ; 2 more spaces
 4242   533E   20 06 53    	        jsr     COUT
 4243   5341   A6 A9       	        ldx     CHRCNT          ; back to zero?
 4244   5343   F0 F6       	        beq     COUT010         ; yes, so don't add to start of line
 4245                      	
 4246   5345   A9 20       	        lda     #SPACE          ; last one
 4247   5347   4C 06 53    	        jmp     COUT            ; finally
 4248   534A               	COUT02:
 4249   534A   AA          		tax			; use char as index
 4250   534B   A5 C1       		lda	FONTFLG		; get which font we be using
 4251   534D   F0 04       		beq	COUTF1		; must be variable width
 4252   534F   A9 0C       		lda	#MONOFONT_W	; get width then of mono font
 4253   5351   D0 03       		bne	COUTF2		; okay, now do add
 4254   5353               	COUTF1:
 4255   5353   BD 2A 64    		lda	CHWID,X		; get width of char
 4256   5356               	COUTF2:
 4257   5356   18          		clc 			; get ready for add
 4258   5357   65 A7       		adc	LENGTH+LO	; ADD LINE LENGTH COUNTER
 4259   5359   85 A7       		sta	LENGTH+LO	; update length
 4260   535B   90 02       		bcc	COUT0C		; no wrap
 4261   535D   E6 A8       		inc	LENGTH+HI	; okay, wrap then
 4262   535F               	COUT0C:
 4263   535F   A5 A8       		lda	LENGTH+HI	; get MSB
 4264   5361   C5 A3       		cmp	XSIZE+HI	; check MSB first
 4265   5363   90 17       		bcc	COUT2		; no need to check lsb
 4266   5365   D0 06       		bne	COUT00		; XSIZE < LENGTH?
 4267   5367               		
 4268   5367   A5 A7       		lda	LENGTH+LO	; check LSB
 4269   5369   C5 A2       		cmp	XSIZE+LO	; END OF SCREEN LINE?
 4270   536B   90 0F       		bcc	COUT2		; haven't reached the end if XSIZE > LENGTH
 4271   536D               	COUT00:
 4272   536D   AC DB 71    		ldy	WRPFLG		; are we wrapping
 4273   5370   F0 13       		beq	CEX		; no, so truncate
 4274   5372   A6 A9       		ldx	CHRCNT		; get character count
 4275   5374   A5 AC       		lda	IOCHAR		; get the character
 4276   5376   9D 00 02    		sta	LBUFF,X		; save current char in buffer
 4277   5379   4C 73 54    		jmp	FLUSH		; YES, FLUSH THE LINE
 4278   537C               	COUT2:
 4279   537C   A6 A9       		ldx	CHRCNT		; GET LINE POINTER
 4280   537E   A5 AC       		lda	IOCHAR		; get char back
 4281   5380   9D 00 02    		sta	LBUFF,X		; ADD CHAR TO BUFFER
 4282   5383   E6 A9       		inc	CHRCNT		; and point to next CHRCNT
 4283   5385               	CEX:
 4284   5385   60          		rts
 4285   5386               		
 4286                      		; ---------------
 4287                      		; OUTPUT TO TABLE
 4288                      		; ---------------
 4289                      	;
 4290                      	; this one just puts a char into the table
 4291                      	;
 4292   5386               	TBLOUT:
 4293   5386   AA          		tax			; HOLD CHAR A SEC.
 4294                      	;
 4295                      	; figger out length of line in there
 4296                      	;
 4297   5387   A5 C1       		lda	FONTFLG		; get which font we be using
 4298   5389   F0 04       		beq	TBLOUT1		; must be variable width
 4299   538B   A9 0C       		lda	#MONOFONT_W	; get width then of mono font
 4300   538D   D0 03       		bne	TBLOUT2		; okay, now do add
 4301   538F               	TBLOUT1:
 4302   538F   BD 2A 64    		lda	CHWID,X		; get width of char
 4303   5392               	TBLOUT2:
 4304   5392   18          		clc			; add width
 4305   5393   6D 31 96    		adc	ZBEGIN+ZTWIDTH+1	; to current line width
 4306   5396   8D 31 96    		sta	ZBEGIN+ZTWIDTH+1	; save current width
 4307   5399   90 03       		bcc	TBLOUT3		; no wrap
 4308   539B   EE 30 96    		inc	ZBEGIN+ZTWIDTH+0	; wrap, then dammit
 4309   539E               	TBLOUT3:
 4310                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page   64

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4311                      	; PUT BYTE IN TABLE AT CURRENT OFFSET
 4312                      	;
 4313   539E   AD 85 6C    		lda	DIRITM+LO	; ADD IN OFFSET
 4314   53A1   18          		clc		
 4315   53A2   65 A0       		adc	DIRTBL+LO	
 4316   53A4   85 8F       		sta	SPCL		; and make it lo part
 4317   53A6   AD 86 6C    		lda	DIRITM+HI	
 4318   53A9   65 A1       		adc	DIRTBL+HI	
 4319   53AB   20 7C 8F    		jsr	SETPC		; set the PC
 4320   53AE   85 90       		sta	SPCH		; and this is high part
 4321   53B0   84 91       		sty	SPCBNK		; and the bank
 4322   53B2   8A          		txa			; PICK UP ASCII CHAR
 4323   53B3   20 3A 92    		jsr	STASHB		; and save it
 4324                      	;
 4325                      	; SET ITM OFFSET TO NEXT POSITION, INCREMENT COUNTER
 4326                      	;
 4327   53B6   EE 85 6C    		inc	DIRITM+LO	; INC OFFSET TO NEXT BYTE
 4328   53B9   D0 03       		bne	TBLRTS	
 4329   53BB   EE 86 6C    		inc	DIRITM+HI	
 4330   53BE               	TBLRTS:
 4331   53BE   60          		rts
 4332                      	;
 4333                      	; PUT LBUFF IN TABLE AT CURRENT OFFSET
 4334                      	;
 4335   53BF               	TBLRTN:
 4336   53BF   AD 85 6C    		lda	DIRITM+LO	; get where we are
 4337   53C2   18          		clc
 4338   53C3   65 A0       		adc	DIRTBL+LO	; ADD IN OFFSET
 4339   53C5   85 8F       		sta	SPCL		; and make it lo part
 4340   53C7   85 8C       		sta	FPCL		; save for later usage
 4341   53C9   AD 86 6C    		lda	DIRITM+HI	; get hi part
 4342   53CC   65 A1       		adc	DIRTBL+HI	
 4343   53CE   20 7C 8F    		jsr	SETPC		; set the PC
 4344   53D1   85 90       		sta	SPCH		; and this is high part
 4345   53D3   85 8D       		sta	FPCH		; saving
 4346   53D5   84 91       		sty	SPCBNK		; and the bank
 4347   53D7   84 8E       		sty	FPCBNK		; and here too
 4348   53D9   A9 00       		lda	#0		; start counter off at zero
 4349   53DB   85 7A       		sta	J		; use J
 4350   53DD   85 7D       		sta	K+HI		; this will be line length
 4351   53DF   85 7C       		sta	K+LO		; both parts, please
 4352   53E1   20 A3 8F    		jsr	NEXTSPC		; point past the counter
 4353   53E4               	TBLOOP:
 4354   53E4   A4 7A       		ldy	J		; get offset
 4355   53E6   B9 00 02    		lda	LBUFF,Y		; get char
 4356   53E9   AA          		tax			; save char
 4357   53EA   30 19       		bmi	TBLP1		; don't count hi light chars
 4358   53EC   C9 20       		cmp	#SPACE		; see if less than a space
 4359   53EE   90 15       		bcc	TBLP1		; no width if <$20
 4360   53F0   AA          		tax			; use char as index
 4361                      	
 4362   53F1   A5 C1       		lda	FONTFLG		; get which font we be using
 4363   53F3   F0 04       		beq	TBLF1		; must be variable width
 4364   53F5   A9 0C       		lda	#MONOFONT_W	; get width then of mono font
 4365   53F7   D0 03       		bne	TBLF2		; okay, now do add
 4366   53F9               	TBLF1:
 4367   53F9   BD 2A 64    		lda	CHWID,X		; get width of char
 4368   53FC               	TBLF2:
 4369   53FC   18          		clc			; add width
 4370   53FD   65 7C       		adc	K+LO		; to current line width
 4371   53FF   85 7C       		sta	K+LO		; save current width
 4372   5401   90 02       		bcc	TBLP1		; no wrap
 4373   5403   E6 7D       		inc	K+HI		; wrap, then dammit
 4374   5405               	TBLP1:
 4375   5405   8A          		txa			; get char back
 4376   5406   20 3A 92    		jsr	STASHB		; and save it
 4377   5409   20 A3 8F    		jsr	NEXTSPC		; next table entry
 4378   540C   E6 7A       		inc	J		; point to next char
 4379   540E   C6 A9       		dec	CHRCNT		; decrement counter
 4380   5410   D0 D2       		bne	TBLOOP		; get next one
 4381                      	;
 4382                      	; now fill with necessary spaces
 4383                      	;
 4384   5412   A5 C1       		lda	FONTFLG		; first, set up width to be added
 4385   5414   F0 04       		beq	TBLSPF1		; must be variable width font
  Wed Jun  7 1989 12:04                                                                                                  Page   65

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4386   5416   A9 0C       		lda	#MONOFONT_W	; get mono width	
 4387   5418   D0 05       		bne	TBLSPF2		; okay
 4388   541A               	TBLSPF1:
 4389   541A   A2 20       		ldx	#SPACE		; get space index
 4390   541C   BD 2A 64    		lda	CHWID,X		; okay
 4391   541F               	TBLSPF2:
 4392   541F   85 71       		sta	ARG8		; use temporarily
 4393   5421               	TBLSP:
 4394   5421   A5 7C       		lda	K+LO		; get how big line is
 4395   5423   18          		clc			; add in space
 4396   5424   65 71       		adc	ARG8		; pick up space width
 4397   5426   85 7C       		sta	K+LO		; saved
 4398   5428   90 02       		bcc	TBLSP1		; no wrap?
 4399   542A   E6 7D       		inc	K+HI		; yes, wrapping
 4400   542C               	TBLSP1:
 4401   542C   A5 A3       		lda	XSIZE+HI	; check against end
 4402   542E   C5 7D       		cmp 	K+HI		; compare against max width
 4403   5430   90 14       		bcc	TBLSPX		; all done then
 4404   5432   D0 06       		bne	TBLSP2		; no need to check if <>
 4405   5434   A5 A2       		lda	XSIZE+LO	; check LSB
 4406   5436   C5 7C       		cmp	K+LO		; well?
 4407   5438   90 0C       		bcc	TBLSPX		; all done then
 4408   543A               	TBLSP2:
 4409   543A   A9 20       		lda	#SPACE		; get it
 4410   543C   20 3A 92    		jsr	STASHB		; save it
 4411   543F   20 A3 8F    		jsr	NEXTSPC		; point to next one
 4412   5442   E6 7A       		inc	J		; count it
 4413   5444   D0 DB       		bne	TBLSP		; and continue
 4414   5446               	TBLSPX:
 4415   5446   A9 00       		lda	#0		; show end of table
 4416   5448   85 A7       		sta	LENGTH+LO	; clear out line length too
 4417   544A   85 A8       		sta	LENGTH+HI	; and hi part too
 4418   544C   20 3A 92    		jsr	STASHB		; marked with a zero
 4419   544F   20 78 90    		jsr	FP2SP		; have SPC point to beginning
 4420   5452   A9 00       		lda	#0		; upper byte of count is zero
 4421   5454   20 3A 92    		jsr	STASHB		; show it
 4422   5457   20 A3 8F    		jsr	NEXTSPC		; point to LSB
 4423   545A   A5 7A       		lda	J		; get how many chars are there	
 4424   545C   20 3A 92    		jsr	STASHB		; save at beginning of line
 4425   545F   E6 7A       		inc	J		; count counter in offset
 4426   5461   A5 7A       		lda	J		; get J back
 4427   5463   18          		clc			; add in where we were
 4428   5464   6D 85 6C    		adc	DIRITM+LO	; okay with lo part
 4429   5467   8D 85 6C    		sta	DIRITM+LO	; save it
 4430   546A   AD 86 6C    		lda	DIRITM+HI	; and now the hi part
 4431   546D   69 00       		adc	#0		; pick up carry, maybe
 4432   546F   8D 86 6C    		sta	DIRITM+HI	; and save it
 4433   5472   60          		rts
 4434                      	
 4435                      		; -------------------
 4436                      		; FLUSH OUTPUT BUFFER
 4437                      		; -------------------
 4438                      		; ENTRY: LENGTH OF BUFFER IN [X]
 4439                      	
 4440   5473               	FLUSH:
 4441   5473   A9 20       		lda	#SPACE		; SPACE CHAR
 4442   5475   8E 68 6C    		stx	OLDEND		; SAVE CURRENT END OF LINE
 4443   5478               	FL0:
 4444   5478   DD 00 02    		cmp	LBUFF,X		; FIND LAST SPACE CHAR
 4445   547B   F0 06       		beq	FL1		; IN THE LINE
 4446   547D   CA          		dex
 4447   547E   D0 F8       		bne	FL0		; IF NONE FOUND,
 4448   5480   A6 A9       		ldx	CHRCNT		; FLUSH ENTIRE LINE
 4449   5482   CA          		dex			; minus last one
 4450   5483               	FL1:
 4451   5483   8E 67 6C    		stx	OLDLEN		; SAVE OLD LINE POS HERE
 4452   5486   86 A9       		stx	CHRCNT		; MAKE IT THE NEW LINE LENGTH
 4453   5488               		
 4454   5488   A5 B2       		lda	TABLEF		; are we doing table I/O?
 4455   548A   F0 06       		beq	FL11		; nope
 4456   548C   20 BF 53    		jsr	TBLRTN		; YES, DO IT 
 4457   548F   4C 95 54    		jmp	FL12		; so refill line
 4458   5492               	FL11:
 4459   5492   20 E7 54    		jsr	ZCRLF		; PRINT LINE UP TO LAST SPACE
 4460                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page   66

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4461                      	; START NEW LINE WITH REMAINDER OF OLD
 4462                      	;
 4463   5495               	FL12:
 4464   5495   AE 67 6C    		ldx	OLDLEN		; GET OLD LINE POS
 4465   5498   A0 00       		ldy	#0		; START NEW LINE AT BEGINNING
 4466   549A               	FL2:
 4467   549A   E8          		inx		
 4468   549B   EC 68 6C    		cpx	OLDEND		; CONTINUE IF
 4469   549E   90 05       		bcc	FL3		; INSIDE of end of line
 4470   54A0   F0 03       		beq	FL3		; or at end of line
 4471   54A2   84 A9       		sty	CHRCNT	
 4472   54A4   60          		rts		
 4473   54A5               	FL3:
 4474   54A5   BD 00 02    		lda	LBUFF,X		; GET CHAR FROM OLD LINE
 4475   54A8   C9 20       	        cmp     #SPACE          ; don't move start spaces in either
 4476   54AA   F0 25       	        beq     FL4             ; fine, I won't        
 4477   54AC   99 00 02    		sta	LBUFF,Y		; MOVE TO START OF NEW LINE
 4478   54AF   30 20       		bmi	FL4		; don't count hi light chars
 4479   54B1   C9 20       		cmp	#SPACE		; don't count control chars
 4480   54B3   90 1C       		bcc	FL4		; okay
 4481   54B5   8A          		txa			; save current x
 4482   54B6   48          		pha			; saved
 4483   54B7   A5 C1       		lda	FONTFLG		; get which font we be using
 4484   54B9   F0 04       		beq	FLSF1		; must be variable width
 4485   54BB   A9 0C       		lda	#MONOFONT_W	; get width then of mono font
 4486   54BD   D0 07       		bne	FLSF2		; okay, now do add
 4487   54BF               	FLSF1:
 4488   54BF   BD 00 02    		lda	LBUFF,X		; get char back
 4489   54C2   AA          		tax			; make index
 4490   54C3   BD 2A 64    		lda	CHWID,X		; get width of char
 4491   54C6               	FLSF2:
 4492   54C6   18          		clc			; get ready for add
 4493   54C7   65 A7       		adc	LENGTH+LO	; okay, now add char width
 4494   54C9   85 A7       		sta	LENGTH+LO	; save new length
 4495   54CB   68          		pla			; get old X back
 4496   54CC   AA          		tax			; okay
 4497   54CD   90 02       		bcc	FL4		; no wrap
 4498   54CF   E6 A8       		inc	LENGTH+HI
 4499   54D1               	FL4:
 4500   54D1   C8          		iny			; UPDATE # OF chars in NEW LINE
 4501   54D2   D0 C6       		bne	FL2		; (ALWAYS)
 4502                      	
 4503                      	
 4504                      		; ---------------
 4505                      		; CARRIAGE RETURN
 4506                      		; ---------------
 4507                      	
 4508   54D4               	ZZCRLF:
 4509   54D4   A6 B2       		ldx	TABLEF		; OUTPUT TO TABLE?
 4510   54D6   F0 0F       		beq	ZCRLF		; NO
 4511                      	;
 4512                      	; if putting a <CR> into table, just add to line buffer and flush
 4513                      	;
 4514   54D8   A9 0D       		lda	#EOL		; get carriage return char
 4515   54DA   A4 A9       		ldy	CHRCNT		; add to lbuff
 4516   54DC   99 00 02    		sta	LBUFF,Y		; got it
 4517   54DF   E6 A9       		inc	CHRCNT		; now flush it
 4518   54E1   20 BF 53    		jsr	TBLRTN		; YES, DO IT (TBL ONLY)
 4519   54E4   4C 5D 55    		jmp	ZCRLFX		; git out
 4520   54E7               	ZCRLF:
 4521   54E7   A6 A9       		ldx	CHRCNT		; how far have we gone
 4522   54E9   A9 0D       		lda	#EOL		; get carriage return char
 4523   54EB   9D 00 02    		sta	LBUFF,X		; END OF CURRENT LINE
 4524   54EE   E6 A9       		inc	CHRCNT		; UPDATE LINE LENGTH
 4525   54F0   20 66 55    		jsr	LINOUT		; DISPLAY LINE
 4526                      	
 4527                      	;
 4528                      	; now check about line count
 4529                      	;
 4530   54F3   A9 00       		lda	#0
 4531   54F5   85 A9       		sta	CHRCNT		; AND RESET LINE COUNT
 4532   54F7   85 A7       		sta	LENGTH+LO	; okay
 4533   54F9   85 A8       		sta	LENGTH+HI	; okay
 4534                      	
 4535   54FB   20 84 55    		jsr	CHKFNC		; CHECK FOR CR FUNCTION (XZIP)
  Wed Jun  7 1989 12:04                                                                                                  Page   67

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4536                      	
 4537   54FE   A5 B1       		lda	SCREENF		; CHECK IF DISPLAYING TO SCREEN
 4538   5500   F0 5B       		beq	ZCRLFX		; NO, GO HANDLE IF PRINTING
 4539   5502   AD DC 71    		lda	SCRLFLG		; is it a scrolling window?
 4540   5505   F0 56       		beq	ZCRLFX		; nope, so no more
 4541   5507   E6 AB       		inc	LINCNT		; NEW LINE GOING OUT
 4542                      	
 4543   5509   A6 AB       		ldx	LINCNT		; IS IT TIME TO
 4544   550B   E4 03       		cpx	MAXLINES	; PRINT "MORE" YET?
 4545   550D   90 4E       		bcc	ZCRLFX		; NO, CONTINUE
 4546                      	
 4547   550F   A9 01       		lda	#1		; leave one line from last screen, and input line
 4548   5511   85 AB       		sta	LINCNT		; RESET LINE COUNTER
 4549   5513   A5 04       		lda	LEFTMRG		; SET LEFT MARGIN
 4550   5515   85 00       		sta	SCRCX
 4551   5517   A9 01       		lda	#1		; show cursor changed (maybe)
 4552   5519   8D 7C 6C    		sta	CURSFLG		; okay
 4553                      	;
 4554                      	; print [MORE] out myself, to avoid re-entrancy problems
 4555                      	;
 4556   551C   AD 78 6C    	        lda     SCRIPTF         ; make sure we don't script
 4557   551F   48          	        pha
 4558   5520   A2 00       	        ldx     #0              ; start with first char
 4559   5522   8E 78 6C    	        stx     SCRIPTF         ; clear script flag
 4560   5525   86 18       	        stx     SCLLINES        ; use this as a counter
 4561   5527               	MORELOOP:
 4562   5527   BD 6B 5B    	        lda     MORE,X          ; get char
 4563   552A   85 AC       	        sta     IOCHAR          ; save it
 4564   552C   20 21 53    	        jsr     DIRECT_OUT      ; pump it out there
 4565   552F   E6 18       	        inc     SCLLINES        ; count char
 4566   5531   A6 18       	        ldx     SCLLINES        ; how many have we done        
 4567   5533   E0 06       	        cpx     #MOREL          ; done?
 4568   5535   D0 F0       	        bne     MORELOOP        ; nope
 4569                      	
 4570   5537   20 B5 55    	        jsr     CLRBUF          ; make sure it shows
 4571   553A               	WAIT:
 4572   553A   20 31 51    		jsr	GETKEY		; wait for key please
 4573   553D   A9 05       		lda	#MOREL-1	; how many backspaces
 4574   553F   85 A7       		sta	LENGTH		; just use this as counter
 4575   5541               	WM11:
 4576   5541   A6 A7       		ldx	LENGTH		; which char?
 4577   5543   BD 6B 5B    		lda	MORE,X		; get char
 4578   5546   AA          		tax			; put here for erase
 4579   5547   A9 08       		lda	#BACKSPACE	; erase char
 4580   5549   20 82 5D    		jsr	CHAR
 4581   554C   C6 A7       		dec	LENGTH		; count it
 4582   554E   10 F1       		bpl	WM11
 4583   5550   68          	        pla                     ; get script flag back
 4584   5551   8D 78 6C    	        sta     SCRIPTF         ; fine
 4585   5554   A5 04       		lda	LEFTMRG		; move back to left margin
 4586   5556   85 00       		sta	SCRCX		; okay
 4587   5558   A9 01       		lda	#1		; show cursor changed (maybe)
 4588   555A   8D 7C 6C    		sta	CURSFLG		; okay
 4589   555D               	ZCRLFX:
 4590   555D   A9 00       		lda	#0
 4591   555F   85 A9       		sta	CHRCNT		; AND RESET LINE COUNT
 4592   5561   85 A7       		sta	LENGTH+LO	; okay
 4593   5563   85 A8       		sta	LENGTH+HI
 4594   5565   60          		rts
 4595   5566               	LINOUT:
 4596   5566   A4 A9       		ldy	CHRCNT		; IF BUFFER EMPTY,
 4597   5568   F0 19       		beq	LINEX		; DON'T PRINT ANYTHING
 4598   556A   8C 6E 6C    		sty	PRLEN		; SAVE LENGTH HERE FOR "PPRINT"
 4599   556D   A5 B1       		lda	SCREENF		; DISPLAY TO SCREEN?
 4600   556F   F0 0F       		beq	LOUT1		; NO, GO CHECK IF PRINT
 4601   5571   A2 00       		ldx	#0		; SEND CONTENTS OF [LBUFF]
 4602   5573               	LOUT:
 4603   5573   BD 00 02    		lda	LBUFF,X		; TO SCREEN
 4604   5576   20 82 5D    		jsr	CHAR
 4605   5579   E8          		inx
 4606   557A   88          		dey
 4607   557B   D0 F6       		bne	LOUT
 4608   557D   20 F1 71    		jsr	DISP_LINE	; make sure line gets printed
 4609   5580   20 DF 4C    	LOUT1:	JSR	PPRINT		; PRINT [LBUFF] IF ENABLED
 4610   5583               	LINEX:
  Wed Jun  7 1989 12:04                                                                                                  Page   68

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4611   5583   60          		rts			; AND RETURN
 4612                      	;
 4613                      	; CHECK IF THERE IS A PENDING FUNCTION CALL ASSOCIATED WITH <CR>'S
 4614                      	;
 4615   5584               	CHKFNC:
 4616   5584   A0 0B       		ldy	#WINCRC+HI		; get function offset
 4617   5586   B1 05       		lda	(WINDOW),Y		; IF NULL IGNORE
 4618   5588   88          	 	dey				; point to lo part
 4619   5589   11 05       		ora	(WINDOW),Y
 4620   558B   F0 26       		beq	CHKOUT
 4621                      	
 4622   558D   AD A8 6C    	        lda     CRLF_CHECK              ; do we really want to do this?
 4623   5590   F0 21       	        beq     CHKOUT                  ; nope
 4624                      	
 4625   5592   B1 05       		lda	(WINDOW),Y		; DECR COUNTER
 4626   5594   38          		sec
 4627   5595   E9 01       		sbc	#1
 4628   5597   91 05       		sta	(WINDOW),Y
 4629   5599   C8          		iny
 4630   559A   B1 05       		lda	(WINDOW),Y		; work on hi part
 4631   559C   E9 00       		sbc	#0			; pick up carry
 4632   559E   91 05       		sta	(WINDOW),Y		; save it
 4633   55A0   88          		dey		
 4634   55A1   11 05       		ora	(WINDOW),Y		; if NULL NOW, CALL FCN
 4635   55A3   D0 0E       		bne	CHKOUT
 4636                      	
 4637   55A5   A0 08       		ldy	#WINCRF+LO		; pointing to routine
 4638   55A7   B1 05       		lda	(WINDOW),Y		; get lo part	
 4639   55A9   85 7A       		sta	J+LO			; and save in J
 4640   55AB   C8          		iny				; point to hi part
 4641   55AC   B1 05       		lda	(WINDOW),Y		; got it
 4642   55AE   85 7B       		sta	J+HI
 4643   55B0   20 18 5B    		jsr	INTCLL			; DO FUNCTION CALL
 4644   55B3               	CHKOUT:
 4645   55B3   60          		rts
 4646                      	
 4647                      	
 4648                      		; ----------------------
 4649                      		; UPDATE THE STATUS LINE
 4650                      		; ----------------------
 4651                      		; NOT APPLICABLE IN EZIP.
 4652                      	
 4653   55B4   60          	ZUSL:	RTS		
 4654                      	
 4655                      	; ------
 4656                      	; BUFOUT
 4657                      	; ------
 4658                      	; ENTER: ARG1 = BUFFERED (1) OR NONBUFFERED (0) OUTPUT CHOICE
 4659                      	; EXIT: FLAG (BUFFLG) IS SET TO TELL COUT WHICH TO DO
 4660                      	;
 4661                      	; shouldn't need this in YZIP ?!
 4662                      	;
 4663   55B5               	ZBUFOUT:
 4664                      	;
 4665                      	; CLEAR OUTPUT BUFFER BEFORE DOING ANYTHING FANCY
 4666                      	;
 4667   55B5               	CLRBUF:
 4668   55B5   20 66 55    		jsr	LINOUT		; CLEAR BUFFER (DON'T RESET LINE COUNT)
 4669   55B8   A2 00       		ldx	#0
 4670   55BA   86 A9       		stx	CHRCNT
 4671   55BC   60          		rts
 4672                      	
 4673                      		; ------
 4674                      		; DIROUT
 4675                      		; ------
 4676                      		; ARG1 CONTAINS VALUE OF WHICH DEVICE TO SELECT
 4677                      		; OR DESELECT, ARG2 = THE TABLE ADDR FOR TABLE OUTPUT
 4678                      		; MULTIPLE DEVICE USAGE IS POSSIBLE.
 4679                      	
 4680   55BD   00 00       	SAVEXSIZE: db	0,0		; for formatted table saving
 4681                      	
 4682   55BF               	ZDIRT:
 4683   55BF   20 B5 55    	        jsr     CLRBUF          ; send out anything there now!
 4684                      	
 4685   55C2   A6 63       		ldx	ARG1+LO	
  Wed Jun  7 1989 12:04                                                                                                  Page   69

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4686   55C4   30 0A       		bmi	DIRRES		; NEGATIVE VALUE, DESELECTING
 4687   55C6   CA          		dex		
 4688   55C7   F0 11       		beq	DIR1		; 1 = SET OUTPUT TO SCREEN
 4689   55C9   CA          		dex		
 4690   55CA   F0 1E       		beq	DIR2		; 2 = SCRIPTING
 4691   55CC   CA          		dex		
 4692   55CD   F0 3C       		beq	DIR3		; 3 = TABLE
 4693   55CF   60          		rts			; INVALID VALUE
 4694   55D0               	DIRRES:
 4695   55D0   E8          		inx		
 4696   55D1   F0 0F       		beq	DRES1		; -1 = RESET TO SCREEN
 4697   55D3   E8          		inx		
 4698   55D4   F0 29       		beq	DRES2	
 4699   55D6   E8          		inx		
 4700   55D7   F0 3A       		beq	DRES3	
 4701   55D9   60          		rts			; INVALID VALUE, JUST LEAVE
 4702   55DA               	DIR1:
 4703   55DA   20 B5 55    		jsr	CLRBUF
 4704   55DD   A9 01       		lda 	#1		; turn screen on
 4705   55DF   85 B1       		sta	SCREENF	
 4706   55E1   60          		rts		
 4707   55E2               	DRES1:
 4708   55E2   20 B5 55    		jsr	CLRBUF
 4709   55E5   A9 00       		lda	#0
 4710   55E7   85 B1       		sta	SCREENF		; 0, TURN SCREEN OFF
 4711   55E9   60          		rts
 4712   55EA               	DIR2:
 4713   55EA   E8          		inx		
 4714   55EB   8E 78 6C    		stx	SCRIPTF		; SET SCRIPT FLAG ON
 4715   55EE   AD 11 96    		lda	ZBEGIN+ZFLAGS+1	; SET GAME FLAG ALSO
 4716   55F1   09 01       		ora	#%00000001	
 4717   55F3   8D 11 96    		sta	ZBEGIN+ZFLAGS+1	
 4718   55F6   AD 1B 4D    		lda	PSTAT		; CHECK IF PRINTER ALREADY INIT'D
 4719   55F9   D0 03       		bne	DIR2A	
 4720   55FB   20 31 4D    		jsr	PCHK		; NO, GO DO IT
 4721   55FE               	DIR2A:
 4722   55FE   60          		rts			; YES, READY TO LEAVE
 4723   55FF               	DRES2:
 4724   55FF   8E 78 6C    		stx	SCRIPTF		; TURN PRINTER OFF
 4725   5602   AD 11 96    		lda	ZBEGIN+ZFLAGS+1	; AND TURN OFF GAME FLAG TOO
 4726   5605   29 FE       		and	#%11111110	
 4727   5607   8D 11 96    		sta	ZBEGIN+ZFLAGS+1	
 4728   560A   60          		rts		
 4729   560B               	DIR3:
 4730   560B   86 B1       	        stx     SCREENF         ; turn off screen
 4731   560D   E8          		inx		
 4732   560E   86 B2       		stx	TABLEF		; TURN TABLE OUTPUT FLAG ON
 4733   5610   4C 7B 56    		jmp	START_TABLE	; and set things up
 4734   5613               	DRES3:
 4735   5613   A5 B2       		lda	TABLEF		; IF OFF ALREADY
 4736   5615   F0 63       		beq	OUT3		; LEAVE AS IS
 4737                      	
 4738   5617   86 B2       		stx	TABLEF		; TURN TBL OUTPUT OFF
 4739   5619   E8          	        inx                     ; turn screen back on
 4740   561A   86 B1       	        stx     SCREENF         ; screen back on
 4741                      	
 4742   561C   A9 03       	        lda     #3              ; add three to make it wrap
 4743   561E   18          	        clc                     ; ready for add
 4744   561F   6D 31 96    	        adc     ZBEGIN+ZTWIDTH+1 ; do it
 4745   5622   8D 31 96    	        sta     ZBEGIN+ZTWIDTH+1
 4746   5625   90 03       	        bcc     DRESCC          ; no wrap into MSB
 4747   5627   EE 30 96    	        inc     ZBEGIN+ZTWIDTH
 4748   562A               	DRESCC:
 4749   562A   4E 30 96    		lsr	ZBEGIN+ZTWIDTH+0 ; /4 to get # of pixels
 4750   562D   6E 31 96    		ror	ZBEGIN+ZTWIDTH+1
 4751   5630   4E 30 96    		lsr	ZBEGIN+ZTWIDTH+0
 4752   5633   6E 31 96    		ror	ZBEGIN+ZTWIDTH+1
 4753                      	
 4754                      	
 4755   5636   A5 19       		lda	FMTTBL		; did we do a formatted table?
 4756   5638   D0 2B       		bne	DRESFT		; yes, so fix things
 4757                      	;
 4758                      	; now put count into table
 4759                      	;
 4760   563A   A5 A0       		lda	DIRTBL+LO	; and put count into second byte of table
  Wed Jun  7 1989 12:04                                                                                                  Page   70

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4761   563C   85 8F       		sta	SPCL		; points to low par
 4762   563E   A5 A1       		lda	DIRTBL+HI	; get page 
 4763   5640   20 7C 8F    		jsr	SETPC		; okay, page and bank
 4764   5643   85 90       		sta	SPCH
 4765   5645   84 91       		sty	SPCBNK
 4766   5647   AD 85 6C    		lda	DIRITM+LO	; (2 LESS THAN [DIRITM])
 4767   564A   38          		sec		
 4768   564B   E9 02       		sbc	#2	
 4769   564D   8D 85 6C    		sta	DIRITM+LO	; save this new count
 4770   5650   B0 03       		bcs	RESET0	
 4771   5652   CE 86 6C    		dec	DIRITM+HI	; wrapped downwards
 4772   5655               	RESET0:
 4773   5655   AD 86 6C    		lda	DIRITM+HI	; get hi part
 4774   5658   20 3A 92    		jsr	STASHB		; saved that count
 4775   565B   20 A3 8F    		jsr	NEXTSPC		; and point to lo part
 4776   565E   AD 85 6C    		lda	DIRITM+LO	; and get lo part
 4777   5661   20 3A 92    		jsr	STASHB		; and save it
 4778   5664   60          		rts			; done
 4779   5665               	DRESFT:
 4780   5665   A5 A9       		lda	CHRCNT		; anything in buffer?
 4781   5667   F0 03       		beq	DRES31		; nope
 4782   5669   20 BF 53    		jsr	TBLRTN		; then fill out last line
 4783   566C               	DRES31:
 4784   566C   AD BD 55    		lda	SAVEXSIZE+LO	; get old xsize back
 4785   566F   85 A2       		sta	XSIZE+LO	; restored
 4786   5671   AD BE 55    		lda	SAVEXSIZE+HI
 4787   5674   85 A3       		sta	XSIZE+HI
 4788   5676   A9 00       		lda	#0		; reset this flag too
 4789   5678   85 19       		sta	FMTTBL		; cleared
 4790   567A               	OUT3:
 4791   567A   60          		rts		
 4792                      	;
 4793                      	; set things up for doing table output
 4794                      	;
 4795   567B               	START_TABLE:
 4796                      	
 4797   567B   A5 66       		lda	ARG2+HI		; SET UP TBL
 4798   567D   85 A1       		sta	DIRTBL+HI	
 4799   567F   A5 65       		lda	ARG2+LO		; TO STORE CHARS IN
 4800   5681   85 A0       		sta	DIRTBL+LO	
 4801   5683   A9 02       		lda	#2
 4802   5685   8D 85 6C    		sta	DIRITM+LO	
 4803   5688   A9 00       		lda	#0	
 4804   568A   8D 86 6C    		sta	DIRITM+HI	
 4805   568D   8D 31 96    		sta	ZBEGIN+ZTWIDTH+1	; clear width count
 4806   5690   8D 30 96    		sta	ZBEGIN+ZTWIDTH+0
 4807                      	;
 4808                      	; check to see if we have formatted table
 4809                      	;
 4810   5693   A5 62       		lda	NARGS		; get # of arguments
 4811   5695   C9 03       		cmp	#3		; if == 3, then we wrap it
 4812   5697   F0 01       		beq	DIR30		; nope
 4813   5699   60          		rts			; all done other wise
 4814   569A               	DIR30:
 4815   569A   86 19       		stx	FMTTBL		; set formatted table flag
 4816   569C   A5 A2       		lda	XSIZE+LO	; save the current XSIZE
 4817   569E   8D BD 55    		sta	SAVEXSIZE+LO	; okay, did it
 4818   56A1   A5 A3       		lda	XSIZE+HI	; and MSB
 4819   56A3   8D BE 55    		sta	SAVEXSIZE+HI	; okay
 4820   56A6   A5 67       		lda	ARG3+LO		; this is the actual amount
 4821   56A8   A6 68       		ldx	ARG3+HI		; get interesting arg
 4822   56AA   30 0B       		bmi	DIRFT1		; check for negative width
 4823   56AC   20 7F 57    		jsr	SETWJ		; get the window offset
 4824   56AF   A0 14       		ldy	#WINXSZ		; get its XSIZE
 4825   56B1   B1 7A       		lda	(J),Y		; got it
 4826   56B3   85 A2       		sta	XSIZE+LO	; aren't we nice
 4827   56B5   D0 06       		bne	DIR31		; jump to end
 4828   56B7               	DIRFT1:
 4829   56B7   49 FF       		eor	#$FF		; turn to a positive number
 4830   56B9   85 A2       		sta	XSIZE+LO	; save it
 4831   56BB   E6 A2       		inc	XSIZE+LO	; to make it right
 4832   56BD               	DIR31:
 4833   56BD   A9 00       		lda	#0		; items starts at zero
 4834   56BF   8D 85 6C    		sta	DIRITM+LO	; okay
 4835   56C2   85 A3       		sta	XSIZE+HI	; clear out highness
  Wed Jun  7 1989 12:04                                                                                                  Page   71

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4836   56C4   06 A2       		asl	XSIZE+LO	; *2
 4837   56C6   26 A3       		rol	XSIZE+HI	
 4838   56C8   06 A2       		asl	XSIZE+LO	; *4
 4839   56CA   26 A3       		rol	XSIZE+HI
 4840   56CC   60          		rts		
 4841                      	
 4842                      		; ------
 4843                      		; CURSET
 4844                      		; ------
 4845                      		; SET CURSOR AT LINE (ARG1) AS OFFSET FROM TOP OF WINDOW
 4846                      		; AND AT COLUMN (ARG2) in (optional) window ARG3
 4847                      	
 4848   56CD               	ZCURST:
 4849   56CD   20 B5 55    		jsr	CLRBUF		; CLEAR OUT ANY NON DISPLAYED TEXT 1ST
 4850   56D0   A5 63       	        lda     ARG1+LO         ; see if < 0
 4851   56D2   C9 FF       	        cmp     #$FF            ; -1 == turn off cursor
 4852   56D4   D0 04       	        bne     ZCURS00         ; nope
 4853   56D6   A9 01       	        lda     #1              ; show cursor off
 4854   56D8   D0 06       	        bne     ZCURSTXX        ; go do it and return
 4855   56DA               	ZCURS00:
 4856   56DA   C9 FE       	        cmp     #$FE            ; -2 == turn cursor on
 4857   56DC   D0 06       	        bne     ZCURS0          ; nope, just deal with normally
 4858   56DE   A9 00       	        lda     #0              ; show cursor not off
 4859   56E0               	ZCURSTXX:
 4860   56E0   8D A7 6C    	        sta     CURSOR_OFF      ; show current cursor state
 4861   56E3   60          	        rts
 4862   56E4               	ZCURS0:
 4863   56E4   C6 63       		dec	ARG1+LO		; zero base both args
 4864   56E6   C6 65       		dec	ARG2+LO		; thanx
 4865   56E8               		
 4866   56E8   A5 62       		lda	NARGS		; check for id
 4867   56EA   C9 03       		cmp	#3		; if 3 args, then window ID specified
 4868   56EC   F0 04       		beq	ZCURS1		; not 3, so use current window
 4869                      	
 4870   56EE   A5 A6       		lda	CURWIN		; show current window being done
 4871   56F0   85 67       		sta	ARG3+LO		; thanx
 4872   56F2               	ZCURS1:
 4873   56F2   A5 67       		lda	ARG3+LO		; get window ID
 4874   56F4   20 7F 57    		jsr	SETWJ		; put address into J
 4875   56F7   A5 63       		lda	ARG1+LO		; GET LINE
 4876   56F9   A0 02       		ldy	#WINHGHT	; check against height
 4877   56FB   D1 7A       		cmp	(J),Y		; too far?
 4878   56FD   90 05       		bcc	ZCURS3		; no, so use it
 4879   56FF   B1 7A       		lda	(J),Y		; got max out
 4880   5701   A8          		tay			; but one too far
 4881   5702   88          		dey			; all better now
 4882   5703   98          		tya			; back to A
 4883   5704               	ZCURS3:
 4884   5704   18          		clc			; get ready for add
 4885   5705   A0 00       		ldy	#WINTOP		; do y pos first
 4886   5707   71 7A       		adc	(J),Y		; add in top to get absolute value
 4887   5709   A0 04       		ldy	#WINY		; get y pos offset
 4888   570B   91 7A       		sta	(J),Y		; save here
 4889   570D   A5 65       		lda	ARG2+LO		; GET COLUMN
 4890   570F   A0 03       		ldy	#WINWID		; check against width
 4891   5711   D1 7A       		cmp	(J),Y		; is it to for right (like Reagan?)
 4892   5713   90 05       		bcc	ZCURS4		; nope, must be dukakis
 4893   5715   B1 7A       		lda	(J),Y		; get max
 4894   5717   A8          		tay			; for going down one
 4895   5718   88          		dey			; done it
 4896   5719   98          		tya			; back to A for usefullness
 4897   571A               	ZCURS4:
 4898   571A   A0 01       		ldy	#WINLEFT	; get left edge to absolute it
 4899   571C   71 7A       		adc	(J),Y		; carry clear from above
 4900   571E   A0 05       		ldy	#WINX		; this is the x pos
 4901   5720   91 7A       		sta	(J),Y		; into the structure
 4902                      	;
 4903                      	; now check for current window again, move cursor anyway
 4904                      	;	
 4905   5722   4C B1 4D    		jmp	GET_CURSOR	; get cursor pos from WINDOW
 4906                      	
 4907                      		; ------
 4908                      		; CURGET
 4909                      		; ------
 4910                      	
  Wed Jun  7 1989 12:04                                                                                                  Page   72

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4911   5725               	ZCURGT:
 4912   5725   20 B5 55    		jsr	CLRBUF		; flush the buffer
 4913                      	
 4914   5728   20 9F 4D    		jsr	SAVE_CURSOR	; save the current position
 4915                      	
 4916   572B   C6 62       		dec	NARGS		; see how many arguments
 4917   572D   F0 04       		beq	ZCURG1		; use main window
 4918   572F   A5 65       		lda	ARG2+LO		; get window id
 4919   5731   10 02       		bpl	ZCURG2		; and figger it out
 4920   5733               	ZCURG1:
 4921   5733   A5 A6       		lda	CURWIN		; use current window
 4922   5735               	ZCURG2:
 4923   5735   20 7F 57    		jsr	SETWJ		; make J point to right place
 4924                      	
 4925   5738   A5 64       		lda	ARG1+HI		; get table address
 4926   573A   20 7C 8F    		jsr	SETPC		; get real address in memory
 4927   573D   84 91       		sty	SPCBNK		; set bank
 4928   573F   85 90       		sta	SPCH		; and page
 4929   5741   A5 63       		lda	ARG1+LO		; get table offset
 4930   5743   85 8F       		sta	SPCL		; and save it
 4931                      	
 4932   5745   A9 00       		lda	#0		; zero hi part of Y pos
 4933   5747   20 3A 92    		jsr	STASHB		; and save it
 4934   574A   20 A3 8F    		jsr	NEXTSPC		; and point to next one
 4935   574D   20 64 57    		jsr	FETCHCY		; Fetch Y pos
 4936   5750   20 3A 92    		jsr	STASHB		; and save it
 4937   5753   20 A3 8F    		jsr	NEXTSPC
 4938                      	;
 4939                      	; now for the X pos
 4940   5756   A9 00       		lda	#0		; zero top byte of x pos
 4941   5758   20 3A 92    		jsr	STASHB
 4942   575B   20 A3 8F    		jsr	NEXTSPC
 4943   575E   20 71 57    		jsr	FETCHCX		; and now the X pos, and return
 4944   5761   4C 3A 92    		jmp	STASHB		; and stash it away
 4945                      	
 4946                      	;
 4947                      	; FETCHCY - get the relativized Y pos into [A]
 4948                      	;	J points to window structure
 4949   5764               	FETCHCY:	
 4950   5764   A0 04       		ldy	#WINY		; get Y pos of window's cursor
 4951   5766   B1 7A       		lda	(J),Y		; got it
 4952   5768   A0 00       		ldy	#WINTOP		; need to de-absolute it
 4953   576A   38          		sec			; get ready for sub
 4954   576B   F1 7A       		sbc	(J),Y		; get relative pos
 4955   576D   AA          		tax			; for 1 basing it
 4956   576E   E8          		inx			; 1 align it
 4957   576F   8A          		txa			; and put for save
 4958   5770   60          		rts
 4959                      	;
 4960                      	; FETCHCX - get relativized X pos into [A]
 4961                      	;	J points to window structure
 4962   5771               	FETCHCX:
 4963   5771   A0 05       		ldy	#WINX		; get X pos of cursor
 4964   5773   B1 7A       		lda	(J),Y		; got it
 4965   5775   A0 01       		ldy	#WINLEFT	; relativize it
 4966   5777   38          		sec			; get ready for sub
 4967   5778   F1 7A       		sbc	(J),Y		; subtract left edge
 4968   577A   AA          		tax			; for incing
 4969   577B   E8          		inx			; 1 ALIGN IT
 4970   577C   8A          		txa
 4971   577D   60          		rts
 4972                      	
 4973                      		; -----
 4974                      		; DIRIN
 4975                      		; -----
 4976                      		; NOT YET IMPLEMENTED, BUT RESERVED
 4977                      	
 4978   577E   60          	ZDIRIN:	RTS		
 4979                      	
 4980                      	;
 4981                      	; SETWJ - set up J to point to window structure for window ID in [A]
 4982                      	;
 4983   577F               	SETWJ:
 4984   577F   A8          		tay			; check for -3 (current window)
 4985   5780   10 02       		bpl	SWJ1		; nope, window ID here
  Wed Jun  7 1989 12:04                                                                                                  Page   73

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4986   5782   A5 A6       		lda	CURWIN		; -3 means current window
 4987   5784               	SWJ1:
 4988   5784   0A          		asl	A		; shift to make word index
 4989   5785   A8          		tay			; and now make index
 4990   5786   B9 4C 6E    		lda	WINTABLE,Y	; get lo part of window struct address
 4991   5789   85 7A       		sta	J+LO		; and save it
 4992   578B   B9 4D 6E    		lda	WINTABLE+1,Y	; here's the hi part
 4993   578E   85 7B       		sta	J+HI		; prove it
 4994   5790   60          		rts
 4995                      	
 4996                      		; -----
 4997                      		; ERASE
 4998                      		; -----
 4999                      	
 5000   5791               	ZERASE:
 5001   5791   A5 63       		lda	ARG1+LO	
 5002   5793   C9 01       		cmp	#1	
 5003   5795   D0 06       		bne	ZEROUT		; not clreol
 5004                      	
 5005   5797   20 B5 55    		jsr	CLRBUF
 5006   579A   4C 02 61    		jmp	CLREOL		; CLEAR TO END OF LINE
 5007   579D               	ZEROUT:
 5008   579D   85 0C       	        sta     CLSWIDTH        ; this many pixels wide
 5009   579F   A9 09       	        lda     #FONT_H         ; pixels of font_height
 5010   57A1   85 0D       	        sta     CLSHEIGHT
 5011   57A3   A5 00       	        lda     SCRCX           ; start at current cursor pos
 5012   57A5   85 0A       	        sta     CLSLEFT
 5013   57A7   A5 01       	        lda     SCRCY
 5014   57A9   85 0B       	        sta     CLSTOP
 5015   57AB   4C 05 5F    	        jmp     CLS             ; and do it
 5016                      	
 5017                      	; -----
 5018                      	; CLEAR the current window
 5019                      	; -----
 5020   57AE   0000        	SAVEXY:	dw	0
 5021                      	
 5022   57B0               	ZCLR:
 5023   57B0   20 B5 55    		jsr	CLRBUF		; flush the current buffer
 5024   57B3   20 9F 4D    		jsr	SAVE_CURSOR	; save the cursor pos
 5025                      	
 5026   57B6   A5 63       		lda	ARG1+LO		; CHECK WHAT TO DO
 5027   57B8   10 26       		bpl	CLRW		; a particular window
 5028   57BA   C9 FD       	 	cmp	#$FD		; -3 means current window	
 5029   57BC   F0 22       		beq	CLRW		; so just handle it regular
 5030   57BE   C9 FE       		cmp	#$FE		; clear with nothing social
 5031   57C0   F0 07       		beq	CLRCLS		; just clear the screen
 5032                      	;
 5033                      	; UNSPLIT SCREEN & CLEAR IT
 5034                      	;
 5035   57C2   A9 00       		lda	#0		; just use SPLIT 0
 5036   57C4   85 63       		sta	ARG1+LO		; as if called normally
 5037   57C6   20 DD 4D    		jsr	ZSPLIT		; do the split
 5038                      	;
 5039                      	; just clear the entire screen
 5040                      	;
 5041   57C9               	CLRCLS:
 5042   57C9   A9 00       		lda	#0		; clear the entire screen
 5043   57CB   85 0A       		sta	CLSLEFT		; from top left
 5044   57CD   85 0B       		sta	CLSTOP
 5045   57CF   A9 8C       		lda	#MAXWIDTH	; to bottom right
 5046   57D1   85 0C       		sta	CLSWIDTH
 5047   57D3   A9 C0       		lda	#MAXHEIGHT
 5048   57D5   85 0D       		sta	CLSHEIGHT
 5049                      	
 5050   57D7   20 05 5F    		jsr	CLS		; do the clear screen (no cursor movement)
 5051   57DA   A5 63       		lda 	ARG1+LO		; check for -2
 5052   57DC   30 44       		bmi	ZCLRX 		; it is, don't move cursor
 5053   57DE   10 1B       		bpl	ZCLEARX		; move cursor
 5054   57E0               	CLRW:
 5055   57E0   20 7F 57    		jsr	SETWJ		; get me the window pointer
 5056   57E3   A0 00       		ldy	#WINTOP		; step thro to get data
 5057   57E5   B1 7A       		lda	(J),Y		; TOP
 5058   57E7   85 0B       		sta	CLSTOP		; save for clear
 5059   57E9   C8          		iny			; point to left
 5060   57EA   B1 7A       		lda	(J),Y		; get it
  Wed Jun  7 1989 12:04                                                                                                  Page   74

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5061   57EC   85 0A       		sta	CLSLEFT		; tell CLS
 5062   57EE   C8          		iny			; now at WINHGHT
 5063   57EF   B1 7A       		lda	(J),Y		; got it
 5064   57F1   85 0D       		sta	CLSHEIGHT	; save for clear
 5065   57F3   C8          		iny			; now at WINWID
 5066   57F4   B1 7A       		lda	(J),Y		; get height
 5067   57F6   85 0C       		sta	CLSWIDTH	; saved
 5068   57F8   20 05 5F    		jsr	CLS		; screen cleared
 5069                      	;
 5070                      	; now move the cursor to 1,1, if not == -2
 5071                      	;
 5072   57FB               	ZCLEARX:
 5073   57FB   A5 63       		lda	ARG1+LO		; check arg
 5074   57FD   20 7F 57    		jsr	SETWJ		; make sure J still points to window
 5075   5800   A0 00       		ldy	#WINTOP		; put at top left of window
 5076   5802   B1 7A       		lda	(J),Y		; get top
 5077   5804   A0 04       		ldy	#WINY		; and make it the y pos
 5078   5806   91 7A       		sta	(J),Y		; of the cursor
 5079   5808   A0 01       		ldy	#WINLEFT	; and the left is
 5080   580A   B1 7A       		lda 	(J),Y		; the
 5081   580C   18          		clc			; add in the left margin
 5082   580D   A0 06       		ldy	#WINLM		; here's the left margin
 5083   580F   71 7A       		adc	(J),Y		; added it
 5084   5811   A0 05       		ldy	#WINX		; x pos of the
 5085   5813   91 7A       		sta	(J),Y		; cursor
 5086   5815   A9 00       		lda	#0		; and clear out line count
 5087   5817   A0 13       		ldy	#WINLCNT	; line count
 5088   5819   91 7A       		sta	(J),Y		; okay
 5089   581B   A0 15       		ldy	#WINLLEN	; and length of current line
 5090   581D   91 7A       		sta	(J),Y		; okay
 5091   581F   C8          		iny			; do hi
 5092   5820   91 7A       		sta	(J),Y		; okay
 5093   5822               	ZCLRX:
 5094   5822   4C B1 4D    		jmp	GET_CURSOR	; restore the cursor pos for the current window
 5095                      	
 5096                      	; ------
 5097                      	; PRINTT
 5098                      	; ------
 5099                      	; PRINT A TABLE TO SCREEN, ARG1 = # OF BYTES
 5100                      	; ARG2 = WIDTH, ARG3 (DEF = 1) = HEIGHT
 5101                      	
 5102          0078        	OLDCHZ	EQU	I+LO		; EASIER TO READ
 5103          0079        	OLDEHZ	EQU	I+HI
 5104          007E        	OLDCVT	EQU	L+LO
 5105                      	
 5106   5825   0000        	TBL_LEN DW	0		; save for length
 5107                      	
 5108   5827               	ZPRNTT:
 5109   5827   A5 63       		lda	ARG1+LO		; USE GETBYT AS TBL COULD
 5110   5829   85 86       		sta	MPCL		; BE ANYWHERE
 5111   582B   A5 64       		lda	ARG1+HI
 5112   582D   85 87       		sta	MPCM
 5113   582F   A9 00       		lda	#0
 5114   5831   85 88       		sta	MPCH
 5115   5833   20 85 90    		jsr	VLDMPC
 5116                      	
 5117   5836   A5 65       		lda	ARG2+LO		; ONLY A BYTE AS MAX
 5118   5838   F0 58       		beq	PTTDUN		; QUIT NOW IF NULL
 5119                      	
 5120   583A   85 BF       		sta	TBLWIDTH	; width of the table
 5121   583C   85 C0       		sta	TBLCNT		; start counter off at width
 5122   583E   C6 62       		dec	NARGS		; count down to 1 (maybe)
 5123   5840   A5 62       		lda	NARGS
 5124   5842   C9 01       		cmp	#1
 5125   5844   F0 02       		beq	NOHIGHT		; DEFAULT HEIGHT IS 1
 5126   5846   A5 67       		lda	ARG3+LO		; get passed height
 5127   5848               	NOHIGHT:
 5128   5848   85 BE       		sta	TBLHEIGHT	; height of the table (at least 1)
 5129   584A   A5 00       		lda	SCRCX
 5130   584C   85 79       		sta	OLDEHZ
 5131   584E   38          		sec			; subtract left margin to get how long line is
 5132   584F   E5 04       		sbc	LEFTMRG		; okay we did that
 5133   5851   8D 25 58    		sta	TBL_LEN+LO	; this is how big line is too
 5134   5854   A9 00       		lda	#0		; clear MSB
 5135   5856   0E 25 58    		asl	TBL_LEN+LO	; *2
  Wed Jun  7 1989 12:04                                                                                                  Page   75

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5136   5859   2A          		rol	A
 5137   585A   0E 25 58    		asl	TBL_LEN+LO	; *4
 5138   585D   2A          		rol	A
 5139   585E   8D 26 58    		sta	TBL_LEN+HI	; save
 5140   5861               	PTTLP:
 5141   5861   20 0E 92    		jsr	GETBYT		; GET A BYTE
 5142   5864   20 06 53    		jsr	COUT		; and send it out
 5143                      	
 5144   5867   C6 C0       		dec	TBLCNT		; one more byte done
 5145   5869   D0 F6       		bne	PTTLP
 5146   586B   C6 BE       		dec	TBLHEIGHT	; IF DONE ALL LINES
 5147   586D   F0 23       		beq	PTTDUN		; LEAVE
 5148                      	
 5149   586F   20 B5 55    		jsr	CLRBUF		; so send out stuff that's there
 5150                      	
 5151   5872   A5 79       		lda	OLDEHZ		; get old x pos
 5152   5874   85 00       		sta	SCRCX		; and restore it
 5153   5876   A9 01       		lda	#1		; show cursor changed
 5154   5878   8D 7C 6C    		sta	CURSFLG		; okay
 5155   587B   A5 01       		lda	SCRCY		; point to next line
 5156   587D   18          		clc			; by adding in the font height
 5157   587E   69 09       		adc	#FONT_H		; okay, goody
 5158   5880   85 01       		sta	SCRCY		; and here we are
 5159                      	
 5160   5882   AD 26 58    		lda	TBL_LEN+HI	; reset length
 5161   5885   85 A8       		sta	LENGTH+HI	; hi part
 5162   5887   AD 25 58    		lda	TBL_LEN+LO	; lo part
 5163   588A   85 A7       		sta	LENGTH+LO	; just a lo
 5164                      	
 5165   588C   A5 BF       		lda	TBLWIDTH	; RESET COUNT
 5166   588E   85 C0       		sta	TBLCNT		; thanx
 5167   5890   D0 CF       		bne	PTTLP		; GO DO NEXT LINE
 5168   5892               	PTTDUN:
 5169   5892   60          		rts
 5170                      	;--------------
 5171                      	; ZPRINTF
 5172                      	;--------------
 5173                      	; ZPRINTF - print a formatted table
 5174                      	;
 5175   5893               	ZPRINTF:
 5176   5893   A5 63       		lda	ARG1+LO		; USE GETBYT AS TBL COULD
 5177   5895   85 86       		sta	MPCL		; BE ANYWHERE
 5178   5897   A5 64       		lda	ARG1+HI
 5179   5899   85 87       		sta	MPCM
 5180   589B   A9 00       		lda	#0
 5181   589D   85 88       		sta	MPCH
 5182   589F   20 85 90    		jsr	VLDMPC
 5183                      	
 5184   58A2   A5 00       		lda	SCRCX		; save the X pos
 5185   58A4   85 79       		sta	OLDEHZ		; saved here
 5186   58A6               	ZPFL1:
 5187   58A6   20 0E 92    		jsr	GETBYT		; get the length byte, MSB, & ignore
 5188   58A9   20 0E 92    		jsr	GETBYT		; get the length byte
 5189   58AC   F0 21       		beq	ZPFX		; no more if == 0
 5190   58AE   85 BF       		sta	TBLWIDTH	; keep track of it
 5191   58B0               	ZPFL2:
 5192   58B0   20 0E 92    		jsr	GETBYT		; now get the char byte
 5193   58B3   20 82 5D    		jsr	CHAR		; and send it yt
 5194   58B6   C6 BF       		dec	TBLWIDTH	; any more?
 5195   58B8   D0 F6       		bne	ZPFL2		; ayyup
 5196                      	
 5197   58BA   20 F1 71    	 	jsr	DISP_LINE	; make sure line goes out
 5198   58BD   A5 79       		lda	OLDEHZ		; reset a few things
 5199   58BF   85 00       		sta	SCRCX		; including x pos
 5200   58C1   A9 01       		lda	#1		; show cursor changed
 5201   58C3   8D 7C 6C    		sta	CURSFLG		; okay
 5202   58C6   A5 01       		lda	SCRCY		; point to next line
 5203   58C8   18          		clc			; by adding in the font height
 5204   58C9   69 09       		adc	#FONT_H		; okay, goody
 5205   58CB   85 01       		sta	SCRCY		; and here we are
 5206   58CD   D0 D7       		bne	ZPFL1		; and do it again
 5207   58CF               	ZPFX:
 5208   58CF   60          		rts
 5209                      	; ------------
 5210                      	; SET NEW FONT
  Wed Jun  7 1989 12:04                                                                                                  Page   76

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5211                      	; ------------
 5212                      	
 5213                      	; Font 4 is mono-spaced font.
 5214                      	
 5215   58D0               	ZFONT:
 5216   58D0   20 B5 55    	        jsr     CLRBUF          ; clear the buffer first
 5217                      	
 5218   58D3   C6 62       		dec	NARGS		; did we get passed a window id?
 5219   58D5   D0 04       		bne	ZFNTWID		; yup
 5220   58D7   A9 FD       		lda	#$FD		; -3 means current window
 5221   58D9   85 65       		sta	ARG2+LO		; make it the arg2 then
 5222   58DB               	ZFNTWID:
 5223   58DB   A5 65       		lda	ARG2+LO		; get window we are interested in
 5224   58DD   20 7F 57    		jsr	SETWJ		; make [J] point to window struct
 5225                      	
 5226   58E0   A5 63       		lda	ARG1+LO		; check for 
 5227   58E2   C9 01       		cmp	#1		; font 1
 5228   58E4   F0 0E       		beq	ZFNT1		;  or
 5229   58E6   C9 04       		cmp	#4		; font 4 (monospace)
 5230   58E8   D0 2A       		bne	ZFBAD		; nope, so die
 5231                      	;
 5232                      	; font 4 is the monospaced font
 5233                      	;
 5234   58EA   A0 10       		ldy	#WINFSIZE	; point to width
 5235   58EC   A9 03       		lda	#MFONT_W	; get game width
 5236   58EE   91 7A       		sta 	(J),Y		; store the width
 5237   58F0   A9 03       		lda	#3		; set font ID
 5238   58F2   D0 08       		bne	ZFNTEX		; all done
 5239   58F4               	ZFNT1:
 5240   58F4   A0 10       		ldy	#WINFSIZE	; point to width
 5241   58F6   A9 02       		lda	#FONT_W		; get game width
 5242   58F8   91 7A       		sta 	(J),Y		; store the width
 5243   58FA   A9 00       		lda	#0		; set font ID
 5244   58FC               	ZFNTEX:
 5245   58FC   A0 0F       		ldy	#WINFONT	; set font
 5246   58FE   48          		pha			; save font id
 5247   58FF   B1 7A       		lda	(J),Y		; get old font id
 5248   5901   AA          		tax			; save old font id
 5249   5902   68          		pla			; get new one back
 5250   5903   91 7A       		sta	(J),Y		; save in structure
 5251   5905   B1 05       		lda	(WINDOW),Y	; get current window font
 5252   5907   F0 02       		beq	ZFNT0X		; set flag with zero	
 5253   5909   A9 0C       		lda	#MONOFONT_W	; get width of mono spaced font
 5254   590B               	ZFNT0X:
 5255   590B   85 C1       		sta	FONTFLG		; and set flag too
 5256   590D   E8          		inx			; make it say correct font ID for game
 5257   590E   8A          		txa			; put in A for put val
 5258   590F   A2 00       		ldx	#0		; clear X
 5259   5911   4C E1 43    		jmp	PUTVAL		; and return it
 5260   5914               	ZFBAD:
 5261   5914   4C DA 43    		jmp	RET0		; TELL IT DOESN'T WORK
 5262                      	; ------------------------------
 5263                      	; FETCH A LINE OF INPUT FOR READ
 5264                      	; ------------------------------
 5265                      	; ENTRY: Relative READ table address in RDTBL1
 5266                      	; EXIT: # CHARS READ IN [A]
 5267   5917               	SV_SPC:	ds	3		; save SPC here for later usage
 5268                      	
 5269   591A               	INPUT:
 5270   591A   20 B5 55    		jsr	CLRBUF		; FLUSH [LBUFF]
 5271   591D   A0 00       		ldy	#0		; RESET LINE COUNT
 5272   591F   84 79       		sty	I+HI		; clear local variables
 5273   5921   84 78       		sty	I+LO	
 5274   5923   84 7B       		sty	J+HI	
 5275   5925   84 7A       		sty	J+LO	
 5276   5927   8C 69 5B    		sty	BRKCHR		; init break char
 5277   592A   84 AB       		sty	LINCNT		; RESET LINE COUNT
 5278   592C   8C A9 6C    	        sty     PTR_COUNT       ; we start by looking at pointer        
 5279   592F   8C 7C 6C    	        sty     CURSFLG         ; make sure we don't change cursor
 5280                      	;
 5281                      	; check for new TCHARS table
 5282                      	;
 5283   5932   AD 2F 96    		lda	ZBEGIN+ZTCHAR+1	; so check lower byte for different tchars
 5284   5935   CD 89 6C    		cmp	SVTCHAR+LO	; is it different?
 5285   5938   D0 08       		bne	IO_DOT		; ayyup, get new one
  Wed Jun  7 1989 12:04                                                                                                  Page   77

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5286   593A   AD 2E 96    		lda	ZBEGIN+ZTCHAR	; get current TCHARS hi part
 5287   593D   CD 8A 6C    		cmp	SVTCHAR+HI	; is it the same as saved one?
 5288                      	
 5289   5940   F0 03       		beq	IOj		; yes, so don't muck with it
 5290   5942               	IO_DOT:
 5291   5942   20 7E 5A    		jsr	DO_TCHARS	; new table, so copy it over
 5292                      	;
 5293                      	; now set up FPC
 5294                      	;
 5295   5945               	IOj:
 5296   5945   AD 80 6C    		lda	RDTBL1+HI	; get page of table
 5297   5948   20 7C 8F    		jsr	SETPC		; and get me the memory page and bank
 5298   594B   85 8D       		sta	FPCH		; save page
 5299   594D   84 8E       		sty	FPCBNK		; and bank
 5300   594F   AD 7F 6C    		lda	RDTBL1+LO	; and get offset
 5301   5952   85 8C       		sta	FPCL		; set up FPC/SPC
 5302   5954   20 5B 92    		jsr	FETCHB		; get length of line
 5303   5957   A8          		tay			; for dec'ing
 5304   5958   88          		dey			; don't count the offset byte
 5305   5959   88          		dey			; and leave room for terminator
 5306   595A   84 17       		sty	CHRMAX		; and save it
 5307   595C   20 C3 8F    		jsr	NEXTFPC		; point to next byte
 5308   595F   20 5B 92    		jsr	FETCHB		; get current offset into buffer
 5309   5962   8D 62 5B    		sta	CHARCNT		; save how many chars out there
 5310   5965   20 C3 8F    		jsr	NEXTFPC 	; point to beginning of data buffer
 5311                      	;
 5312                      	; now finish setting up saved SPC
 5313                      	;
 5314   5968   A2 02       		ldx	#2
 5315   596A               	INSVCL:
 5316   596A   B5 8C       		lda	FPC,X		; get byte to saved for use later on
 5317   596C   9D 17 59    		sta	SV_SPC,X	; it is saved here
 5318   596F   CA          		dex
 5319   5970   10 F8       		bpl	INSVCL		; next!
 5320                      	;
 5321                      	; now copy current buffer into local buffer
 5322                      	;
 5323   5972   AD 62 5B    		lda	CHARCNT		; make sure we have some
 5324   5975   F0 11       		beq	CPIOLX		; nope, none in there now
 5325   5977   A2 00       		ldx	#0		; start at first char
 5326   5979               	CPIOL:
 5327   5979   20 5B 92    		jsr	FETCHB		; get a char
 5328   597C   9D 00 02    		sta	LBUFF,X		; save char
 5329   597F   20 C3 8F    		jsr	NEXTFPC		; point to next one
 5330   5982   E8          		inx			; next char
 5331   5983   EC 62 5B    		cpx	CHARCNT		; got them all yet?
 5332   5986   D0 F1       		bne	CPIOL		; nope
 5333   5988               	CPIOLX:
 5334   5988   20 0E 4F    		jsr	CHKTME		; START  TIME LIMIT
 5335                      	;
 5336                      	; this is the get-a-key-and-whack-on-it loop
 5337                      	;
 5338   598B               	INLOOP:
 5339   598B   A5 79       		lda	I+HI		; is there a time?
 5340   598D   F0 08       		beq	INPL1		; nope
 5341   598F   20 C9 4F    		jsr	TIMIN		; do timed input
 5342   5992   90 06       		bcc	INPL2		; got a char, process it
 5343   5994   4C 78 5A    		jmp	LEXBAD		; timed out with nothing there!
 5344   5997               	INPL1:
 5345   5997   20 31 51    		jsr	GETKEY		; let apple do the walking
 5346   599A               	INPL2:
 5347   599A   20 B5 5A    		jsr	ISTCHR		; CHECK IF IT'S AN ACCEPTABLE TERMINATOR KEY
 5348   599D   B0 0D       		bcs	NOTYET
 5349                      	
 5350   599F   8D 69 5B    		sta	BRKCHR
 5351   59A2   C9 0D       		cmp	#EOL		; IF EOL PUT TO SCREEN
 5352   59A4   F0 03       		beq	ENDLINx
 5353   59A6   4C 2F 5A    		jmp	ENDIN		; ELSE JUST END
 5354   59A9               	ENDLINx:
 5355   59A9   4C 1F 5A    	        jmp     ENDLIN          ; can't reach with a branch
 5356   59AC               	NOTYET:
 5357   59AC   A0 FF       	        ldy     #$FF            ; restart pointer device counter
 5358   59AE   8C A9 6C    	        sty     PTR_COUNT       ; and start again
 5359   59B1   A8          		tay			; check for functions keys that aren't
 5360   59B2   30 65       		bmi	CBAD		; terminators and feep if it is
  Wed Jun  7 1989 12:04                                                                                                  Page   78

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5361   59B4   C9 0D       		cmp	#EOL		; EOL?
 5362   59B6   F0 67       		beq	ENDLIN		; LINE DONE IF SO
 5363   59B8   C5 1B       		cmp	ESCAPE		; don't allow escape char's thru
 5364   59BA   F0 5D       		beq	CBAD		; okay, I won't
 5365                      	
 5366   59BC   C9 08       		cmp	#BACKSPACE	; BACKSPACE?
 5367   59BE   F0 38       		beq	BACKUP		; SPECIAL HANDLING
 5368   59C0   C9 1B       	        cmp     #ESCAPE         ; ESCAPE char?
 5369   59C2   F0 55       	        beq     CBAD            ; don't like it
 5370                      	
 5371   59C4   AC 62 5B    		ldy	CHARCNT		; where do we put char?
 5372   59C7   C4 17       		cpy	CHRMAX		; are we filled up?
 5373   59C9   B0 4E       		bcs	CBAD		; boy, am i full
 5374                      	
 5375   59CB   48          		pha			; save it
 5376   59CC   AA          		tax			; use as index
 5377   59CD   A5 A7       		lda	LENGTH+LO	; GET LINE LENGTH COUNTER
 5378   59CF   18          		clc 			; get ready for add
 5379   59D0   7D 2A 64    		adc	CHWID,X		; add width
 5380   59D3   A8          	        tay                     ; save LSB in Y
 5381   59D4   A6 A8       	        ldx     LENGTH+HI       ; get high byte        
 5382   59D6   90 01       		bcc	INP0C		; no wrap
 5383   59D8   E8          		inx             	; okay, wrap then
 5384   59D9               	INP0C:
 5385   59D9   68          		pla			; get char back
 5386   59DA   E4 A3       		cpx	XSIZE+HI	; check MSB first
 5387   59DC   90 04       		bcc	NOIOWRAP	; no need to check lsb
 5388   59DE   C4 A2       		cpy	XSIZE+LO	; end of screen line?
 5389   59E0   B0 37       		bcs     CBAD            ; reached end, so just beep
 5390   59E2               	NOIOWRAP:
 5391   59E2   86 A8       	        stx     LENGTH+HI       ; save MSB
 5392   59E4   84 A7       	        sty     LENGTH+LO       ; and LSB
 5393   59E6   AE 62 5B    		ldx	CHARCNT		; for putting in line buffer
 5394   59E9   9D 00 02    		sta	LBUFF,X		; and save it in case we goto printer
 5395   59EC   20 82 5D    		jsr	CHAR		; SEND TO SCREEN
 5396   59EF   20 F1 71    		jsr	DISP_LINE	; show char
 5397   59F2   EE 62 5B    		inc	CHARCNT		; NEXT POSITION IN LINE
 5398   59F5   4C 8B 59    		jmp	INLOOP		; NO, GET ANOTHER CHAR
 5399                      	;
 5400                      	; HANDLE BACKSPACE
 5401                      	;
 5402   59F8               	BACKUP:
 5403   59F8   AE 62 5B    		ldx	CHARCNT		; if == 2 then empty
 5404   59FB   F0 1C       		beq	CBAD		; JMP to beeping
 5405   59FD   CA          		dex			; get rid of char
 5406   59FE   8E 62 5B    		stx	CHARCNT		; saved
 5407   5A01   BD 00 02    		lda	LBUFF,X		; get char we are interested in
 5408   5A04   AA          		tax			; put in x
 5409                      	
 5410   5A05   A5 A7       		lda	LENGTH+LO	; GET LINE LENGTH COUNTER
 5411   5A07   38          		sec 			; get ready for sub
 5412   5A08   FD 2A 64    		sbc	CHWID,X		; sub width
 5413   5A0B   85 A7       		sta	LENGTH+LO	; update length
 5414   5A0D   B0 02       		bcs	BCKP1		; no wrap
 5415   5A0F   C6 A8       		dec	LENGTH+HI	; okay, wrap then
 5416   5A11               	BCKP1:
 5417   5A11   A9 08       		lda	#BACKSPACE	; so do erasing backspace
 5418   5A13   20 82 5D    		jsr	CHAR
 5419   5A16   4C 8B 59    		jmp	INLOOP
 5420   5A19               	CBAD:
 5421   5A19   20 C3 4E    		jsr	BEEP		; ELSE SCREAM WITH PAIN
 5422   5A1C   4C 8B 59    		jmp	INLOOP		; AND WAIT FOR SOMETHING BETTER
 5423                      	;
 5424                      	; HANDLE END OF LINE KEY
 5425                      	;
 5426   5A1F               	ENDLIN:
 5427   5A1F   8D 69 5B    		sta	BRKCHR
 5428   5A22   A9 0D       		lda	#EOL		; get EOL char
 5429   5A24   20 82 5D    		jsr	CHAR		; SEND EOL TO SCREEN
 5430   5A27   A9 00       		lda	#0		; and show 0 length of line out there
 5431   5A29   85 A7       		sta	LENGTH+LO	; thanx
 5432   5A2B   85 A8       		sta	LENGTH+HI	; and msb
 5433   5A2D   E6 AB       		inc	LINCNT		; take into account the <CR> at EOL
 5434   5A2F               	ENDIN:
 5435                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page   79

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5436                      	; now save lbuff in table for posterity
 5437                      	;
 5438   5A2F   AD 19 59    		lda	SV_SPC+ABANK	; get bank first
 5439   5A32   85 91       		sta	SPCBNK		; saved
 5440   5A34   AD 18 59    		lda	SV_SPC+HI
 5441   5A37   85 90       		sta	SPCH
 5442   5A39   AD 17 59    		lda	SV_SPC+LO
 5443   5A3C   85 8F       		sta	SPCL
 5444   5A3E   A2 00       		ldx	#0		; start with first char in buffer
 5445   5A40               	ENDLOOP:
 5446   5A40   EC 62 5B    		cpx	CHARCNT		; done yet?
 5447   5A43   F0 16       		beq	INP111
 5448   5A45   BD 00 02    		lda	LBUFF,X		; get char
 5449   5A48   C9 41       		cmp	#'A'		; IF CHAR IS UPPERCASE ALPHA,
 5450   5A4A   90 06       		bcc	LEX		; CONVERT TO LOWER CASE
 5451   5A4C   C9 5B       		cmp	#'Z'+1	
 5452   5A4E   B0 02       		bcs	LEX
 5453   5A50   69 20       		adc	#$20		; converting away
 5454   5A52               	LEX:
 5455   5A52   20 3A 92    		jsr	STASHB		; okay, stashing away
 5456   5A55   20 A3 8F    		jsr	NEXTSPC		; and point to next char in table
 5457   5A58   E8          		inx			; point to next char
 5458   5A59   D0 E5       		bne	ENDLOOP		; so get next one
 5459   5A5B               	INP111:
 5460   5A5B   A9 00       		lda	#00		; to show end of line
 5461   5A5D   20 3A 92    		jsr	STASHB		; so put it in buffer
 5462                      	;
 5463                      	; now put in new line length
 5464                      	;
 5465   5A60   AD 80 6C    		lda	RDTBL1+HI	; get page of table
 5466   5A63   20 7C 8F    		jsr	SETPC		; and get me the memory page and bank
 5467   5A66   85 90       		sta	SPCH		; save page
 5468   5A68   84 91       		sty	SPCBNK		; and bank
 5469   5A6A   AD 7F 6C    		lda	RDTBL1+LO	; and get offset
 5470   5A6D   85 8F       		sta	SPCL
 5471   5A6F   20 A3 8F    		jsr	NEXTSPC		; and point to char count
 5472   5A72   AD 62 5B    		lda	CHARCNT		; get character count
 5473   5A75   20 3A 92    		jsr	STASHB		; and shove it away  
 5474   5A78               	LEXBAD:
 5475   5A78   A0 00       	        ldy     #0              ; clear out
 5476   5A7A   8C A9 6C    	        sty     PTR_COUNT       ; pointer flag
 5477   5A7D   60          		rts			; Length is in [A]
 5478                      	;
 5479                      	; Copy over a new TCHARS table
 5480                      	;
 5481   5A7E               	DO_TCHARS:
 5482                      	;
 5483                      	; now do somethin' with the TCHAR table (maybe, if <> 0)
 5484                      	;
 5485   5A7E   AD 2E 96    		lda	ZBEGIN+ZTCHAR	; DO SAME FOR TCHARS TABLE
 5486   5A81   8D 8A 6C    		sta	SVTCHAR+HI	; save it for checking
 5487   5A84   20 7C 8F    		jsr	SETPC		; and now make absolute
 5488   5A87   85 8D       		sta	FPCH		; Save in FPC
 5489   5A89   84 8E       		sty	FPCBNK
 5490   5A8B   AD 2F 96    		lda	ZBEGIN+ZTCHAR+1	; NO CHANGE FOR LSB
 5491   5A8E   8D 89 6C    		sta	SVTCHAR+LO	; and save for later check
 5492   5A91   85 8C       		sta	FPCL		; now move pointer to fetch spot
 5493                      	
 5494   5A93   A9 00       		lda	#0		; and set index
 5495   5A95   85 78       		sta	I		; thank you
 5496   5A97   85 B9       		sta	ALLFLG		; turn it off
 5497   5A99               	TCHLP:
 5498   5A99   20 5B 92    		jsr	FETCHB		; get the byte in [a]
 5499   5A9C   20 C3 8F    		jsr	NEXTFPC		; point to next one
 5500   5A9F   A6 78       		ldx	I		; get offset
 5501   5AA1   E6 78       		inc	I		; and point to next one
 5502   5AA3   9D 00 1D    		sta	TCHARTBL,X	; save in lower memory, thank you
 5503   5AA6   C9 00       		cmp	#0		; are we done yet?
 5504   5AA8   F0 0A       		beq	TCHj		; NULL TERMINATED STRING
 5505   5AAA   C9 FF       		cmp	#$FF		; $ff means all >128 chars are terminators
 5506   5AAC   D0 04       		bne	TCHLNEXT	; nope
 5507   5AAE   A9 01       		lda	#1		; yes,
 5508   5AB0   85 B9       		sta	ALLFLG		; so set flag to say so
 5509   5AB2               	TCHLNEXT:
 5510   5AB2   D0 E5       		bne	TCHLP		; and go get it
  Wed Jun  7 1989 12:04                                                                                                  Page   80

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5511   5AB4               	TCHj:
 5512   5AB4   60          		rts
 5513                      	
 5514                      		; ------------------------
 5515                      		; IS IT A TERMINATOR CHAR?
 5516                      		; ------------------------
 5517                      	
 5518   5AB5               	ISTCHR:
 5519   5AB5   AE 00 1D    		ldx	TCHARTBL	; check for chars in TCHAR table
 5520   5AB8   F0 18       		beq	ISNOT		; nope
 5521                      	
 5522   5ABA   A6 B9       		ldx	ALLFLG		; ARE ALL FCN KEYS (<127) TERMINATORS
 5523   5ABC   F0 05       		beq	ISCHK		; 0 = NO, GO CHECK LIST
 5524   5ABE   AA          	        tax                     ; check for minus
 5525   5ABF   30 13       		bmi	ISFND		; YUP
 5526   5AC1   10 0F       		bpl	ISNOT
 5527   5AC3               	ISCHK:
 5528   5AC3   A0 00       		ldy	#0
 5529   5AC5               	ISLP:
 5530   5AC5   D9 00 1D    	        cmp	TCHARTBL,Y	; IS CHAR WE HAVE A TCHAR?
 5531   5AC8   F0 0A       		beq	ISFND		; YES
 5532   5ACA   BE 00 1D    		ldx	TCHARTBL,Y	; NULL = END OF STRING
 5533   5ACD   F0 03       		beq	ISNOT
 5534   5ACF   C8          		iny
 5535   5AD0   D0 F3       		bne	ISLP		; SHOULD ALWAYS LOOP
 5536   5AD2               	ISNOT:
 5537   5AD2   38          		sec
 5538   5AD3   60          		rts			; NOT FOUND
 5539   5AD4               	ISFND:	
 5540   5AD4   18          		clc
 5541   5AD5   60          		rts
 5542                      	
 5543                      		; -----
 5544                      		; INPUT 1 char, no printing
 5545                      		; -----
 5546                      	
 5547   5AD6               	ZINPUT:
 5548   5AD6   20 B5 55    		JSR	CLRBUF
 5549                      	
 5550   5AD9   A0 00       		ldy	#0	
 5551   5ADB   84 AB       		sty	LINCNT	
 5552   5ADD   84 A9       		sty	CHRCNT	
 5553   5ADF   84 79       		sty	I+HI		; init locals too
 5554   5AE1   84 78       		sty	I+LO
 5555   5AE3   84 7B       		sty	J+HI
 5556   5AE5   84 7A       		sty	J+LO
 5557   5AE7   8C A9 6C    	        sty     PTR_COUNT       ; always check the pointer
 5558   5AEA               	 
 5559   5AEA   C6 62       		DEC	NARGS	
 5560   5AEC   F0 18       		BEQ	ZINP3		; NO TIME LIMIT
 5561   5AEE   A5 65       		LDA	ARG2+LO		; GET DELAY WANTED
 5562   5AF0   85 79       		STA	I+HI	
 5563   5AF2   C6 62       		DEC	NARGS	
 5564   5AF4   F0 08       		BEQ	ZINP4		; NO FCN
 5565   5AF6   A5 67       		LDA	ARG3+LO	
 5566   5AF8   85 7A       		STA	J+LO	
 5567   5AFA   A5 68       		LDA	ARG3+HI	
 5568   5AFC   85 7B       		STA	J+HI	
 5569   5AFE               	ZINP4:
 5570   5AFE   20 C9 4F    		JSR	TIMIN		; CALL timed input rotine
 5571   5B01   90 10       		BCC	ZINPRK		; send char on home
 5572   5B03   4C DA 43    		JMP	RET0		; time out without character
 5573   5B06               	ZINP3:
 5574   5B06   20 31 51    		jsr	GETKEY		; ok, find which char was pressed
 5575   5B09   C9 1B       	        cmp     #ESCAPE         ; don't use escape char
 5576   5B0B   D0 06       	        bne     ZINPRK          ; fine
 5577   5B0D   20 C3 4E    	        jsr     BEEP            ; complain
 5578   5B10   4C 06 5B    	        jmp     ZINP3           ; do again
 5579   5B13               	ZINPRK:
 5580   5B13   A2 00       		LDX	#0
 5581   5B15   4C DD 43    		JMP	PUTBYT		; RETURN CHAR
 5582                      	
 5583                      	
 5584   5B18               	INTCLL:
 5585   5B18   A5 79       		LDA	I+HI		; SAVE VALUES FOR CALLING RTN
  Wed Jun  7 1989 12:04                                                                                                  Page   81

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5586   5B1A   48          		PHA		
 5587   5B1B   A5 78       		LDA	I+LO
 5588   5B1D   48          		PHA
 5589   5B1E   A5 7B       		LDA	J+HI	
 5590   5B20   85 64       		STA	ARG1+HI		; pretend it's arg1
 5591   5B22   48          		PHA		
 5592   5B23   A5 7A       		LDA	J+LO	
 5593   5B25   85 63       		STA	ARG1+LO		; and this is the other half
 5594   5B27   48          		PHA		
 5595                      	
 5596   5B28   A2 01       		LDX	#1
 5597   5B2A   86 62       		STX	NARGS		; 0 args for internal call
 5598   5B2C   CA          		DEX
 5599   5B2D   8E 64 5B    		STX	IRET		; make sure it returns here!
 5600   5B30               		
 5601   5B30   A5 80       		LDA	ZPCL		; a fake one to say we
 5602   5B32   48          		PHA			; are an internal call
 5603   5B33   A5 81       		LDA	ZPCM		; so save real one
 5604   5B35   48          		PHA
 5605   5B36   A5 82       		LDA	ZPCH	
 5606   5B38   48          		PHA
 5607                      	
 5608   5B39   A9 00       		LDA	#0		; return addr of zero is 
 5609   5B3B   85 82       		STA	ZPCH		; internal call!
 5610   5B3D   85 81       		STA	ZPCM
 5611   5B3F   85 80       		STA	ZPCL
 5612                      	
 5613   5B41   20 CD 7F    		JSR	DOCALL
 5614                      	
 5615   5B44   4C B6 40    		JMP	MLOOP		; GO DO FCN
 5616                      	;
 5617                      	; RETURN FROM FCN WILL COME HERE
 5618                      	;
 5619   5B47               	ZIRET:
 5620   5B47   68          	 	PLA			; GET RID OF RTS FROM ZRET
 5621   5B48   68          		PLA		
 5622                      	
 5623   5B49   68          		PLA			; get old zpc back
 5624   5B4A   85 82       		STA	ZPCH
 5625   5B4C   68          		PLA
 5626   5B4D   85 81       		STA	ZPCM
 5627   5B4F   68          		PLA
 5628   5B50   85 80       		STA	ZPCL
 5629   5B52   20 AF 90    		JSR	VLDZPC		; and validate it
 5630                      	
 5631   5B55   68          		PLA			; RESTORE FOR CALLING RTN
 5632   5B56   85 7A       		STA	J+LO	
 5633   5B58   68          		PLA		
 5634   5B59   85 7B       		STA	J+HI	
 5635   5B5B   68          		PLA
 5636   5B5C   85 78       		STA	I+LO
 5637   5B5E   68          		PLA		
 5638   5B5F   85 79       		STA	I+HI	
 5639   5B61   60          		RTS			; GO BACK TO CALLER
 5640                      	
 5641                      	; INPUT: routine locals!
 5642   5B62   00          	CHARCNT:	DB	0	; where into buffer goes char
 5643   5B63   00          	SVCHAR:		DB	0	; where to save the char before printing
 5644                      	
 5645   5B64   00          	IRET:	DB	0		; FLAG TELLS IF RETURNLESS CALL
 5646                      	
 5647   5B65   00 00       	MTEMP:	DB	00,00		; temp spot for math routines
 5648   5B67   00          	TYPE:	DB	0		; PARTIAL OR NORMAL (WHOLE) SAVE/RESTORE
 5649   5B68   00          	ASSVLU:	DB	0		; how many args to this subroutine
 5650   5B69   00          	BRKCHR:	DB	0		; READ BREAK CHAR
 5651   5B6A   00          	RDFLAG:	DB	0		; 0 - only read 1 - do lex on it
 5652   5B6B   5B 4D 4F 52 45 	MORE:	DB	"[MORE]"	
        5B70   5D 
 5653          0006        	MOREL	EQU	$-MORE
 5654   5B71               		END
 5655                      	
 5656   5B71               		INCLUDE		VERIFY.ASM
 5657   5B71               		STTL "--- VERIFY CODE ---"
 5658                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page   82

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5659                      	
 5660                      		; ------
 5661                      		; VERIFY
 5662                      		; ------
 5663                      		; VERIFY GAME CODE ON DISK
 5664   5B71   0D 54 68 65 20 	VERBAD:	DB	EOL,"The data segment of file is BAD!",EOL
        5B76   64 61 74 61 20 
        5B7B   73 65 67 6D 65 
        5B80   6E 74 20 6F 66 
        5B85   20 66 69 6C 65 
        5B8A   20 69 73 20 42 
        5B8F   41 44 21 0D 
 5665          0022        	VERBADL	EQU	$-VERBAD
 5666   5B93   0D 54 68 65 20 	VERPBAD: DB	EOL,"The picture data of file is BAD!",EOL
        5B98   70 69 63 74 75 
        5B9D   72 65 20 64 61 
        5BA2   74 61 20 6F 66 
        5BA7   20 66 69 6C 65 
        5BAC   20 69 73 20 42 
        5BB1   41 44 21 0D 
 5667          0022        	VERPBADL EQU	$-VERPBAD
 5668   5BB5   00          	ZVFLAG:	db	0		; set to indicate ugliness
 5669          0078        	STARTPOS EQU	I+LO		; this is where to start block
 5670   5BB6               	ZVER:
 5671   5BB6   20 94 8C    		jsr	CLOSE_GAME	; make sure the game files are closed
 5672   5BB9   AC 89 46    		ldy	GAME2NML	; get length of name
 5673   5BBC   B9 89 46    		lda	GAME2NM,Y	; get last char
 5674   5BBF   49 30       		eor	#$30		; make normal number
 5675   5BC1   A8          		tay			; -1 to make ready for FETCH_FILE
 5676   5BC2   88          		dey			; F_F incs first
 5677   5BC3   98          		tya			; to push onto stack
 5678   5BC4   48          		pha			; and save for restoring later
 5679   5BC5   A9 00       		lda	#0		; clear a few counters
 5680   5BC7   8D B5 5B    		sta 	ZVFLAG		; ==0 - verify worked; !=0 - verify broke
 5681   5BCA   AD 01 19    		lda	SEGTBL+SGTDISKS+1	; get how many disks are here
 5682   5BCD   8D 57 49    		sta 	DISKCNTR	; this shows which disk we are working on
 5683   5BD0   CE 57 49    		dec	DISKCNTR	; start down by one
 5684   5BD3               	VERIFY_LOOP:
 5685   5BD3   20 0B 5C    		jsr	VERIFY_DATA	; check data in this file
 5686   5BD6   20 96 5C    		jsr	VERIFY_PICD	; check (possible) picture data in this file
 5687   5BD9   AD CF 45    		lda	GMREF		; get reference number
 5688   5BDC   8D 0C 8B    		sta	CLOSE_PB+CL_REFNUM ; and show CLOSE
 5689   5BDF               		CLOSE	CLOSE_PB	; and shut it up
 5690   5BDF               		PRODOS	$CC, CLOSE_PB
 5691   5BDF   20 00 BF    		jsr	$BF00	; ProDOS handler
 5692   5BE2   CC          		DB	$CC	; ProDOS function code
 5693   5BE3   0B8B        		DW	CLOSE_PB	; Function Parameter Block address
 5694   5BE5               		.MACEND
 5695   5BE5               		.MACEND
 5696   5BE5   CE 57 49    		dec	DISKCNTR	; next please
 5697   5BE8   10 E9       		bpl	VERIFY_LOOP	; and check the next file
 5698   5BEA               	ZVERX:
 5699   5BEA   A9 02       		lda	#>PAGELEN	; reset read buffer length
 5700   5BEC   8D D3 45    		sta	READ_PB+RD_BUFFLEN+HI	; to be $100
 5701   5BEF   A9 00       		lda	#<PAGELEN	; this is for LSB
 5702   5BF1   8D D2 45    		sta	READ_PB+RD_BUFFLEN+LO	; to be $100
 5703   5BF4   20 94 8C    		jsr	CLOSE_GAME	; close up the 2 files, thank you
 5704   5BF7   A9 01       		lda	#1		; open game file #1 (*.D2)
 5705   5BF9   20 C6 49    		jsr	FETCH_FILE	; this opens it up
 5706   5BFC   68          		pla			; get file number back (*.D3/4/5)
 5707   5BFD   20 C6 49    		jsr	FETCH_FILE	; and open it back up
 5708   5C00   AD B5 5B    		lda	ZVFLAG		; see if we were successful
 5709   5C03   F0 03       		beq	ZVERGOOD	; it worked fine
 5710   5C05   4C 2F 44    		jmp	PREDF		; no it didn't
 5711   5C08               	ZVERGOOD:
 5712   5C08   4C 3B 44    		jmp	PREDS		; all done
 5713                      	;
 5714                      	; VERIFY_DATA - check the data part of the picture.  This routine sets
 5715                      	; up DSEGS and open the file.  It will move to the data section if this
 5716                      	; is the preload file, set up J to be the number of 256 byte blocks, and
 5717                      	; print out the verdict.  The disk we are working on (0-3) is in DISKCNTR.
 5718                      	;
 5719   5C0B               	VERIFY_DATA:
 5720   5C0B   AD 57 49    		lda	DISKCNTR	; get disk we are interested in
 5721   5C0E   0A          		asl	A		; make word pointer
  Wed Jun  7 1989 12:04                                                                                                  Page   83

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5722   5C0F   AA          		tax			; create index
 5723   5C10   BD D1 1D    		lda	DSKSEG+HI,X	; get MSB of seg table address
 5724   5C13   85 1F       		sta	DSEGS+HI	; save in pointer
 5725   5C15   BD D0 1D    		lda	DSKSEG+LO,X	; get LSB of seg table address
 5726   5C18   85 1E       		sta	DSEGS+LO	; now pointer is all set
 5727   5C1A   AD 57 49    		lda	DISKCNTR	; get disk again
 5728   5C1D   20 C6 49    		jsr	FETCH_FILE	; so we can open up correct file
 5729   5C20   A9 00       		lda	#0		; make sure we start at beginning
 5730   5C22   8D DE 45    		sta	PSEEK+SM_FPOS
 5731   5C25   8D DF 45    		sta	PSEEK+SM_FPOS+1
 5732   5C28   8D E0 45    		sta	PSEEK+SM_FPOS+2
 5733   5C2B   85 78       		sta	STARTPOS	; start at first byte, prob'ly
 5734   5C2D               		SET_MARK PSEEK		; and move to beginning of file
 5735   5C2D               		PRODOS	$CE, PSEEK
 5736   5C2D   20 00 BF    		jsr	$BF00	; ProDOS handler
 5737   5C30   CE          		DB	$CE	; ProDOS function code
 5738   5C31   DC45        		DW	PSEEK	; Function Parameter Block address
 5739   5C33               		.MACEND
 5740   5C33               		.MACEND
 5741   5C33   AD 57 49    		lda	DISKCNTR	; now check if this is preload
 5742   5C36   D0 03       		bne	VERD1		; if <> 0, then it isn't
 5743   5C38   20 51 5D    		jsr	SETUP_DISK0	; move around to point to start of data
 5744   5C3B               	VERD1:
 5745   5C3B   A0 02       		ldy	#SGTPICOF	; find where picture data starts
 5746   5C3D   B1 1E       		lda	(DSEGS),Y	; MSB
 5747   5C3F   85 7B       		sta	J+HI		; J is the page counter
 5748   5C41   C8          		iny			; point to LSB
 5749   5C42   11 1E       		ora	(DSEGS),Y	; any picture file?
 5750   5C44   D0 08       		bne	VERD01		; yes, so mark end of data
 5751   5C46   A9 FF       		lda	#$FF		; set J to be a real big number
 5752   5C48   85 7A       		sta	J+LO		; okay
 5753   5C4A   85 7B       		sta	J+HI		; and this one
 5754   5C4C   D0 15       		bne	VERD11		; all done
 5755   5C4E               	VERD01:
 5756   5C4E   B1 1E       		lda	(DSEGS),Y	; and here it is
 5757   5C50   0A          		asl	A		; *2 to make 512 pages be 256 pages
 5758   5C51   85 7A       		sta	J+LO		; this is where it ends up
 5759   5C53   26 7B       		rol	J+HI		; move in carry to MSB
 5760   5C55   A5 7A       		lda	J+LO		; now, subtract any skipping
 5761   5C57   38          		sec			; doing sub
 5762   5C58   ED DF 45    		sbc	PSEEK+SM_FPOS+1	; take away any skipped amount
 5763   5C5B   85 7A       		sta	J+LO		; and save it
 5764   5C5D   A5 7B       		lda	J+HI		; pick up carry
 5765   5C5F   E9 00       		sbc	#0		; we will
 5766   5C61   85 7B       		sta	J+HI		; we did
 5767   5C63               	VERD11:
 5768   5C63   20 E6 5C    		jsr	VERIFY_FILE	; now, actually do the work
 5769   5C66   90 2D       		bcc	VERDX		; worked just fine
 5770   5C68               		DLINE	VERBAD		; puke, gag, argh
 5771   5C68   A2 71       		ldx	#<VERBAD	; get part of VERBAD
 5772   5C6A   A9 5B       		lda	#>VERBAD	; get other part of string
 5773          [01]        		IFMA	2		; check to see if length passed in
 5774                      		ldy			; then just fetch it
 5775          [01]        		ELSE
 5776   5C6C   A0 22       		ldy	#VERBADL	; get length of string
 5777          [00]        		ENDIF
 5778   5C6E   20 6B 4C    		jsr	DLINE		; print the string
 5779   5C71               		.MACEND
 5780                      	;
 5781                      	; This prints out which file is garfed
 5782                      	;
 5783   5C71               	VER_FMSG:
 5784   5C71   AD 57 49    		lda	DISKCNTR	; which file did we do?
 5785   5C74   C9 02       		cmp	#2		; 0,1 are in one place
 5786   5C76   B0 0D       		bcs	VERDB1		; nope it isn't it
 5787   5C78               		DLINE	GAME1NAME,GAME1NML
 5788   5C78   A2 78       		ldx	#<GAME1NAME	; get part of GAME1NAME
 5789   5C7A   A9 46       		lda	#>GAME1NAME	; get other part of string
 5790          [01]        		IFMA	2		; check to see if length passed in
 5791   5C7C   AC 77 46    		ldy	GAME1NML		; then just fetch it
 5792          [01]        		ELSE
 5793                      		ldy	#GAME1NAMEL	; get length of string
 5794          [00]        		ENDIF
 5795   5C7F   20 6B 4C    		jsr	DLINE		; print the string
 5796   5C82               		.MACEND
  Wed Jun  7 1989 12:04                                                                                                  Page   84

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5797   5C82   4C 8F 5C    		jmp 	VERDB2		
 5798   5C85               	VERDB1:
 5799   5C85               		DLINE	GAME2NAME,GAME2NML ; 2,3 are in another
 5800   5C85   A2 8A       		ldx	#<GAME2NAME	; get part of GAME2NAME
 5801   5C87   A9 46       		lda	#>GAME2NAME	; get other part of string
 5802          [01]        		IFMA	2		; check to see if length passed in
 5803   5C89   AC 89 46    		ldy	GAME2NML		; then just fetch it
 5804          [01]        		ELSE
 5805                      		ldy	#GAME2NAMEL	; get length of string
 5806          [00]        		ENDIF
 5807   5C8C   20 6B 4C    		jsr	DLINE		; print the string
 5808   5C8F               		.MACEND
 5809   5C8F               	VERDB2:
 5810   5C8F   EE B5 5B    		inc	ZVFLAG		; show bad file
 5811   5C92   20 E0 8C    		jsr	GETRET		; just wait for <CR>
 5812   5C95               	VERDX:
 5813   5C95   60          		rts			; all done
 5814                      	;
 5815                      	; VERIFY_PICD - verify the picture data in a file.  First check to see if
 5816                      	; there is any.  If so, seek to it, set J==0 to show VERIFY_FILE to read
 5817                      	; til EOF, and print out bad picture data message if necessary.
 5818                      	;
 5819   5C96               	VERIFY_PICD:
 5820   5C96   A9 FF       		lda	#$FF		; gonna zero bunch of stuff
 5821   5C98   85 7B       		sta	J+HI		; and the counter
 5822   5C9A   85 7A       		sta	J+LO		; which means now goto EOF
 5823   5C9C   A0 02       		ldy	#SGTPICOF	; fetch the picture data offset
 5824   5C9E   B1 1E       		lda	(DSEGS),Y	; get MSB
 5825   5CA0   8D E0 45    		sta	PSEEK+SM_FPOS+2	; we are doing pages
 5826   5CA3   C8          		iny			; pointing to LSB
 5827   5CA4   11 1E       		ora	(DSEGS),Y	; first, check for all zeros
 5828   5CA6   D0 01       		bne	VERP1		; nope, some picture data is there
 5829   5CA8   60          		rts			; just gwon back if nothing here
 5830   5CA9               	VERP1:
 5831   5CA9   B1 1E       		lda	(DSEGS),Y	; go get LSB
 5832   5CAB   0A          		asl	A		; *2 to get 256 byte pages
 5833   5CAC   8D DF 45    		sta	PSEEK+SM_FPOS+1	; put away here
 5834   5CAF   2E E0 45    		rol	PSEEK+SM_FPOS+2	; pick up carry
 5835   5CB2   A9 10       		lda	#PHSIZE		; skip over header of file
 5836   5CB4   85 78       		sta	STARTPOS	; show offset in first block
 5837   5CB6               	VERP11:
 5838   5CB6               		SET_MARK PSEEK		; and move to picture data spot
 5839   5CB6               		PRODOS	$CE, PSEEK
 5840   5CB6   20 00 BF    		jsr	$BF00	; ProDOS handler
 5841   5CB9   CE          		DB	$CE	; ProDOS function code
 5842   5CBA   DC45        		DW	PSEEK	; Function Parameter Block address
 5843   5CBC               		.MACEND
 5844   5CBC               		.MACEND
 5845   5CBC   20 E6 5C    		jsr	VERIFY_FILE	; read in the data
 5846   5CBF               		SET_MARK PSEEK		; get back to beginning of pic data
 5847   5CBF               		PRODOS	$CE, PSEEK
 5848   5CBF   20 00 BF    		jsr	$BF00	; ProDOS handler
 5849   5CC2   CE          		DB	$CE	; ProDOS function code
 5850   5CC3   DC45        		DW	PSEEK	; Function Parameter Block address
 5851   5CC5               		.MACEND
 5852   5CC5               		.MACEND
 5853   5CC5               		READ	READ_PB		; read in a block worth
 5854   5CC5               		PRODOS	$CA, READ_PB
 5855   5CC5   20 00 BF    		jsr	$BF00	; ProDOS handler
 5856   5CC8   CA          		DB	$CA	; ProDOS function code
 5857   5CC9   CE45        		DW	READ_PB	; Function Parameter Block address
 5858   5CCB               		.MACEND
 5859   5CCB               		.MACEND
 5860   5CCB   AD 0A 08    		lda	IOBUFF+PHCHKS	; get MSB of picture checksum
 5861   5CCE   C5 7F       		cmp	L+HI		; same as what we got?
 5862   5CD0   D0 07       		bne 	VERPB		; nope
 5863   5CD2   AD 0B 08    		lda 	IOBUFF+PHCHKS+1	; get LSB of picture checksum
 5864   5CD5   C5 7E       		cmp	L+LO		; same as mine?
 5865   5CD7   F0 0C       		beq	VERPX		; yup, checked out fine
 5866   5CD9               	VERPB:
 5867   5CD9               		DLINE	VERPBAD		; picture data bad
 5868   5CD9   A2 93       		ldx	#<VERPBAD	; get part of VERPBAD
 5869   5CDB   A9 5B       		lda	#>VERPBAD	; get other part of string
 5870          [01]        		IFMA	2		; check to see if length passed in
 5871                      		ldy			; then just fetch it
  Wed Jun  7 1989 12:04                                                                                                  Page   85

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5872          [01]        		ELSE
 5873   5CDD   A0 22       		ldy	#VERPBADL	; get length of string
 5874          [00]        		ENDIF
 5875   5CDF   20 6B 4C    		jsr	DLINE		; print the string
 5876   5CE2               		.MACEND
 5877   5CE2   4C 71 5C    		jmp	VER_FMSG	; print out file name
 5878   5CE5               	VERPX:
 5879   5CE5   60          		rts			; tootis finis
 5880                      	;
 5881                      	; VERIFY_FILE - Files is already open and pointing to start of checksummed
 5882                      	; data.  Works along til J == 0 or EOF, which ever comes first.  Starts by
 5883                      	; dec'ing J, so if J starts as 0, effectively means goto EOF.
 5884                      	;
 5885   5CE6               	VERIFY_FILE:
 5886   5CE6   A9 00       		lda	#0		; clear out checksum counter
 5887   5CE8   85 7F       		sta	L+HI		; MSB
 5888   5CEA   85 7E       		sta	L+LO		; LSB
 5889   5CEC   8D D2 45    		sta	READ_PB+RD_BUFFLEN+LO
 5890   5CEF   A9 04       		lda	#4		; make read read $400 (1Kb)
 5891   5CF1   8D D3 45    		sta	READ_PB+RD_BUFFLEN+HI
 5892   5CF4               	VFLOOP:	
 5893   5CF4   A9 03       	        lda     #RETRY_COUNT    ; and set up retry count
 5894   5CF6   85 16       	        sta     RETRIES
 5895   5CF8   A9 00       		lda	#<IOBUFF	; reset K to point to beginning of
 5896   5CFA   85 7C       		sta	K+LO		; IOBUFF we are
 5897   5CFC   A9 08       		lda	#>IOBUFF	; reading all the data
 5898   5CFE   85 7D       		sta	K+HI		; into, using as pointer
 5899   5D00               	VFLRD:
 5900   5D00               		READ	READ_PB		; read in 1Kb of data
 5901   5D00               		PRODOS	$CA, READ_PB
 5902   5D00   20 00 BF    		jsr	$BF00	; ProDOS handler
 5903   5D03   CA          		DB	$CA	; ProDOS function code
 5904   5D04   CE45        		DW	READ_PB	; Function Parameter Block address
 5905   5D06               		.MACEND
 5906   5D06               		.MACEND
 5907   5D06   90 0D       		bcc	VERF0		; just fine read
 5908   5D08   C9 4C       		cmp	#$4C		; EOF error?
 5909   5D0A   F0 32       		beq	VFCHECK		; yes, so wee bee done
 5910   5D0C   C9 4D       	        cmp     #$4D            ; InfoDOS EOF error?
 5911   5D0E   F0 2E       	        beq     VFCHECK         ; ayyup
 5912   5D10   20 07 47    	        jsr     RETRY           ; check about retrying
 5913   5D13   90 EB       	        bcc     VFLRD           ; and do again
 5914   5D15               	VERF0:
 5915   5D15   A5 7A       	        lda     J+LO            ; count the block to be read
 5916   5D17   D0 06       	        bne     VERF1           ; no wrapping
 5917   5D19   A5 7B       	        lda     J+HI            ; anything left?
 5918   5D1B   F0 21       	        beq     VFCHECK         ; nope, all done then
 5919   5D1D   C6 7B       	        dec     J+HI            ; count one block
 5920   5D1F               	VERF1:
 5921   5D1F   C6 7A       		dec	J+LO		; count block
 5922   5D21   A4 78       		ldy	STARTPOS	; and begin
 5923   5D23               	VERF2:
 5924   5D23   B1 7C       		lda	(K),Y		; get byte
 5925   5D25   18          		clc			; doing add
 5926   5D26   65 7E       		adc	L+LO		; add it in
 5927   5D28   85 7E       		sta	L+LO		; save it
 5928   5D2A   90 02       		bcc	VERF3		; no wrap
 5929   5D2C   E6 7F       		inc	L+HI		; yes ther is
 5930   5D2E               	VERF3:
 5931   5D2E   C8          		iny			; next byte
 5932   5D2F   D0 F2       		bne	VERF2		; back to start of inner tloop
 5933                      	
 5934   5D31   A9 00       		lda	#0		; start at first byte
 5935   5D33   85 78       		sta	STARTPOS	; okay
 5936   5D35   E6 7D       		inc	K+HI		; point to next block
 5937   5D37   CE D5 45    		dec	READ_PB+RD_LENGTH+HI	; count this one
 5938   5D3A   F0 B8       		beq	VFLOOP		; go read some more
 5939   5D3C   D0 D7       		bne	VERF0		; go do next 256 byte block
 5940   5D3E               	VFCHECK:
 5941   5D3E   A0 00       		ldy	#SGTCHKS	; get check sum
 5942   5D40   A5 7F       		lda	L+HI		; start with MSB
 5943   5D42   D1 1E       		cmp	(DSEGS),Y	; well . . . ?
 5944   5D44   D0 09       		bne	VFBAD		; nope, it is wrong
 5945   5D46   C8          		iny			; first byte is okay
 5946   5D47   A5 7E       		lda	L+LO		; so check LSB
  Wed Jun  7 1989 12:04                                                                                                  Page   86

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5947   5D49   D1 1E       		cmp	(DSEGS),Y	; well . . . ?
 5948   5D4B   D0 02       		bne	VFBAD		; die a slow ugly death
 5949   5D4D   18          		clc			; clear carry to show niceness
 5950   5D4E   60          		rts
 5951   5D4F               	VFBAD:
 5952   5D4F   38          		sec			; carry is set if bad
 5953   5D50   60          		rts			; and return to your fate
 5954                      	;
 5955                      	; SETUP_DISK0 - this routine does some special processing to get the file
 5956                      	; pointer to the beginning of data for the preload file.  It skips over
 5957                      	; segment table.
 5958   5D51               	SETUP_DISK0:
 5959   5D51               		READ	READ_PB		; read in first block
 5960   5D51               		PRODOS	$CA, READ_PB
 5961   5D51   20 00 BF    		jsr	$BF00	; ProDOS handler
 5962   5D54   CA          		DB	$CA	; ProDOS function code
 5963   5D55   CE45        		DW	READ_PB	; Function Parameter Block address
 5964   5D57               		.MACEND
 5965   5D57               		.MACEND
 5966   5D57   AD 00 08    		lda	IOBUFF		; MSB of segment table size (in words)
 5967   5D5A   8D DF 45    		sta	PSEEK+SM_FPOS+1	; middle part of offset
 5968   5D5D   AD 01 08    		lda	IOBUFF+1	; LSB of size
 5969   5D60   0A          		asl	A		; *2 to pick up carry
 5970   5D61   2E DF 45    		rol	PSEEK+SM_FPOS+1	; rotate in carry
 5971   5D64   2E E0 45    		rol	PSEEK+SM_FPOS+2	; and once more
 5972   5D67   A8          	        tay                     ; check for wrapping upwards 
 5973   5D68   F0 08       	        beq     STD01           ; no wrap up then
 5974   5D6A               	STD00:
 5975   5D6A   EE DF 45    	        inc     PSEEK+SM_FPOS+1 ; wee did
 5976   5D6D   D0 03       	        bne     STD01           ; no more wrapping
 5977   5D6F   EE E0 45    	        inc     PSEEK+SM_FPOS+2 ; yes there is
 5978   5D72               	STD01:        
 5979   5D72   AD DF 45    	        lda     PSEEK+SM_FPOS+1 ; make sure it is a 512 byte page
 5980   5D75   29 01       	        and     #$1             ; even page?
 5981   5D77   D0 F1       	        bne     STD00           ; inc again, please
 5982   5D79               	STD0X:
 5983   5D79               		SET_MARK PSEEK		; skip the segment table stuff
 5984   5D79               		PRODOS	$CE, PSEEK
 5985   5D79   20 00 BF    		jsr	$BF00	; ProDOS handler
 5986   5D7C   CE          		DB	$CE	; ProDOS function code
 5987   5D7D   DC45        		DW	PSEEK	; Function Parameter Block address
 5988   5D7F               		.MACEND
 5989   5D7F               		.MACEND
 5990   5D7F   60          		rts			; all done
 5991                      	
 5992   5D80               		END
 5993                      	
 5994   5D80               		INCLUDE		SCREEN.ASM
 5995   5D80               		STTL	"--- APPLE ][ SCREEN STUFF ---"
 5996                      		PAGE
  Wed Jun  7 1989 12:04                                                                                                  Page   87

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 5997                      	
 5998                      	; -----------------
 5999                      	; PRINT CHAR IN [A] AT CV,CH
 6000                      	; -----------------
 6001                      	;
 6002                      	; uses memory register [L]
 6003                      	;
 6004   5D80   00          	SAVECY	DB	0	; spot to save current screen y pos
 6005   5D81   00          	SAVECX	DB	0	; spot for x pos
 6006                      	
 6007   5D82               	CHAR:
 6008   5D82   85 AC       		sta	IOCHAR	; SAVE HERE
 6009   5D84   8A          		txa		; SAVE [X] AND [Y]
 6010   5D85   48          		pha		
 6011   5D86   98          		tya		
 6012   5D87   48          		pha
 6013   5D88               		
 6014   5D88   A5 AC       		lda	IOCHAR		; get it back
 6015   5D8A   C9 08       		cmp	#BACKSPACE	; is it backspace with erase?
 6016   5D8C   D0 03       		bne	CHCX		; nope
 6017                      	
 6018   5D8E   4C B0 5E    		jmp	DO_BSPC		; so handle backspace
 6019   5D91               	CHCX:
 6020   5D91   C9 0D       		cmp	#EOL		; is it <CR>?
 6021   5D93   D0 03       		bne	CHCONT		; just let dline handle it
 6022   5D95               		
 6023   5D95   4C 7D 5E    		jmp	DO_EOL		; handle <CR>
 6024                      	;
 6025                      	; so save some stuff and do all the necessary figgering
 6026                      	;
 6027   5D98               	CHCONT:
 6028   5D98   AE E4 71    		ldx	SCRCNT		; just stash character
 6029   5D9B   9D 80 02    		sta	SCRBUFF,X	; save it
 6030   5D9E   EE E4 71    		inc	SCRCNT		; and count it
 6031   5DA1               	CH_EXIT:
 6032   5DA1   68          		pla			; RESTORE [X] AND [Y]
 6033   5DA2   A8          		tay		
 6034   5DA3   68          		pla		
 6035   5DA4   AA          		tax		
 6036   5DA5   60          		rts
 6037                      	;
 6038                      	; PUT_NYBBLE - put 4 bits to the screen at SCRCX, SCRCY (the lower 4 bits
 6039                      	;	in [A]).
 6040                      	;
 6041   5DA6               	PUT_NYBBLE:
 6042   5DA6   85 0E       		sta	NY_DATA		; save [A] for mucking with
 6043   5DA8   20 51 5E    		jsr	SETPOS		; set up offsets using SCRCX
 6044                      	
 6045   5DAB   A9 08       		lda	#$8		; start at first bit, left to right
 6046   5DAD   85 10       		sta	DATALOOP	; and init the counter with it
 6047   5DAF               	PNY0:
 6048   5DAF   A6 8E       		ldx	FPCBNK		; which bank
 6049   5DB1   BD 54 C0    		lda	PAGE2SW,X	; select it
 6050   5DB4   A0 00       		ldy	#0		; start with zero
 6051   5DB6   B1 8C       		lda	(FPC),Y		; get it
 6052   5DB8   85 13       		sta	SCR_DATA	; and save it
 6053   5DBA               	PNY1:	
 6054   5DBA   A6 11       		ldx	BITOFF		; get which interesting bit we want
 6055   5DBC   BD 09 5E    		lda	GT_BITS,X	; get bit 
 6056   5DBF   48          		pha			; save bit pictures
 6057   5DC0   A5 10       		lda	DATALOOP 	; see if we have done all 4 bits in this 'pixel'
 6058   5DC2   F0 29       		beq	PNY_EXIT 	; toots finis
 6059   5DC4   46 10       		lsr	DATALOOP 	; point to next bit
 6060   5DC6   24 0E       		bit	NY_DATA		; is this bit set?
 6061   5DC8   D0 08       		bne	PNY_SET		; yes it is, so we will handle different
 6062                      	;
 6063                      	; Bit is clear, so clear appropriate one in the SCR_DATA byte
 6064                      	;
 6065   5DCA   68          		pla			; get bit picture back
 6066   5DCB   49 FF       		eor	#$FF		; turn bits all around
 6067   5DCD   25 13       		and 	SCR_DATA	; turn off bit in screen data
 6068   5DCF   4C D5 5D    		jmp	PNY_NEXT	; and continue
 6069   5DD2               	PNY_SET:
 6070   5DD2   68          		pla			; get bit mask back
 6071   5DD3   05 13       		ora	SCR_DATA	; turn on bit
  Wed Jun  7 1989 12:04                                                                                                  Page   88

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6072   5DD5               	PNY_NEXT:
 6073   5DD5   85 13       		sta	SCR_DATA	; save result
 6074   5DD7   E6 11       		inc	BITOFF		; we're looking at next bit
 6075   5DD9   A5 11       		lda	BITOFF		; now check how we're doing
 6076   5DDB   C9 07       		cmp	#7		; only doing bits 0-6
 6077   5DDD   D0 DB       		bne	PNY1		; check next bit
 6078                      	;
 6079                      	; we've finished this byte in screen memory, point to next one
 6080                      	;
 6081   5DDF   A9 00       		lda	#0		; start at zero'th bit
 6082   5DE1   85 11       		sta	BITOFF		; thank you
 6083   5DE3   A5 13       		lda	SCR_DATA	; now stash this one in the screen
 6084   5DE5   91 8C       		sta	(FPC),Y		; y is still zero; still pointing to bank
 6085   5DE7   20 F6 5D    		jsr	NEXT_SCR	; make SPC/FPC point to next spot
 6086   5DEA   4C AF 5D    		jmp	PNY0	; and continue on please
 6087                      	;
 6088                      	; all done, so make sure we stash anything out there
 6089                      	;
 6090   5DED               	PNY_EXIT:
 6091   5DED   68          		pla			; get bit mask back to fix stack
 6092   5DEE   A5 13       		lda	SCR_DATA	; put away the current data byte
 6093   5DF0   91 8C       		sta	(FPC),Y		; y is still zero; still pointing to bank
 6094   5DF2   AD 54 C0    		lda	PAGE2SW+MAIN	; back to MAIN page 2
 6095   5DF5   60          		rts
 6096                      	;
 6097                      	; NEXT_SCR - make FPC/SPC point to next screen byte
 6098                      	;
 6099   5DF6               	NEXT_SCR:
 6100                      	;
 6101                      	; if in main bank, when we go to aux bank, we need to look at the next
 6102                      	; 	byte in memory
 6103                      	;
 6104   5DF6   A5 8E       		lda	FPCBNK		; get what bank we're talking to currently
 6105   5DF8   D0 08       		bne	NXS0		; 0 = main bank, 1 = aux bank
 6106   5DFA   E6 8F       		inc	SPCL	; point to next byte
 6107   5DFC   E6 8C       		inc	FPCL	; and for fetching
 6108   5DFE   A9 01       		lda	#AUX	; and point to aux bank
 6109   5E00   D0 02       		bne	NXS1	; (BRANCH) and continue on
 6110                      	;
 6111                      	; if in aux bank, all we need to do is switch banks
 6112                      	;
 6113   5E02               	NXS0:
 6114   5E02   A9 00       		lda	#MAIN	; just make it main bank
 6115   5E04               	NXS1:
 6116   5E04   85 91       		sta	SPCBNK	; for stashing and
 6117   5E06   85 8E       		sta	FPCBNK	; fetching
 6118   5E08   60          		rts
 6119                      	;
 6120                      	; GET_NYBBLE - get the 4 bits which represent the screen at position
 6121                      	;	SCRCX, SCRCY; return nybble in low 4 bits of [A]
 6122                      	;
 6123   5E09   01 02 04 08 10 	GT_BITS: db 1,2,4,8,$10,$20,$40
        5E0E   20 40 
 6124   5E10               	GET_NYBBLE:
 6125   5E10   20 51 5E    		jsr	SETPOS	; set up offsets using SCRCX
 6126                      	
 6127   5E13   A9 00       		lda	#0	; clear out my data spot
 6128   5E15   85 0E       		sta	NY_DATA	; for mucking with
 6129                      	
 6130   5E17   A9 10       		lda	#$10	; setting bits 0-3, starting with shift
 6131   5E19   85 10       		sta	DATALOOP ; so init the setter
 6132   5E1B               	GNY0:
 6133   5E1B   A6 8E       		ldx	FPCBNK		; which bank
 6134   5E1D   BD 54 C0    		lda	PAGE2SW,X	; save which bank
 6135   5E20   A0 00       		ldy	#0		; zero y
 6136   5E22   B1 8C       		lda	(FPC),Y		; get byte
 6137   5E24   85 13       		sta	SCR_DATA	; and save it
 6138   5E26               	GNY1:	
 6139   5E26   46 10       		lsr	DATALOOP ; see if we have done all 4 bits in this 'pixel'
 6140   5E28   F0 21       		beq	GNY_EXIT ; all done!
 6141                      	
 6142   5E2A   A6 11       		ldx	BITOFF	; get bit offset
 6143   5E2C   BD 09 5E    		lda	GT_BITS,X	; get bit pattern
 6144                      	;
 6145                      	; now check appropriate bit in Screen Data
  Wed Jun  7 1989 12:04                                                                                                  Page   89

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6146                      	;
 6147   5E2F   25 13       		and	SCR_DATA ; see if it is set
 6148   5E31   F0 06       		beq	GNY3	; no bit set here
 6149                      	;
 6150                      	; bit is set, so set it in my data nybble
 6151                      	;
 6152   5E33   A5 10       		lda	DATALOOP ; get bit setter
 6153   5E35   05 0E       		ora	NY_DATA	; and put it into my data byte
 6154   5E37   85 0E       		sta	NY_DATA	; and save it
 6155   5E39               	GNY3:
 6156   5E39   E6 11       		inc	BITOFF	; we're looking at next bit
 6157   5E3B   A5 11       		lda	BITOFF	; now check how we're doing
 6158   5E3D   C9 07       		cmp	#7	; only doing bits 0-6
 6159   5E3F   D0 E5       		bne	GNY1	; check next bit
 6160                      	;
 6161                      	; we've finished this byte in screen memory, point to next one
 6162                      	;
 6163   5E41   A9 00       		lda	#0	; start at zero'th bit
 6164   5E43   85 11       		sta	BITOFF	; thank you
 6165   5E45   20 F6 5D    		jsr	NEXT_SCR	; point to next byte
 6166   5E48   4C 1B 5E    		jmp	GNY0	; and continue on please
 6167   5E4B               	GNY_EXIT:
 6168   5E4B   AD 54 C0    		lda	PAGE2SW+MAIN	; back to main page 2
 6169   5E4E   A5 0E       		lda	NY_DATA	; get the nybble desired
 6170   5E50   60          		rts
 6171                      	;
 6172                      	; SETPOS - get the byte offset and the bit offset from the table using
 6173                      	;		SCRCX
 6174                      	;
 6175                      	;	USES: SCRCX, SCRCY
 6176                      	;	SETS: FPC - pointer to correct screen memory location
 6177                      	;	      BITOFF - bit offset to get to start of byte (N.B. this is left to
 6178                      	;			right count, while in memory it is right to left!)
 6179   5E51               	SETPOS:
 6180   5E51   A5 00       		lda	SCRCX		; get the x pos
 6181   5E53   AA          		tax			; put where we can use it
 6182   5E54   BD 52 03    		lda	XPOSTBL,X	; get byte #
 6183   5E57   85 8C       		sta	FPCL		; okay, saved
 6184   5E59   BD B7 6B    		lda	XBITTBL,X	; get bitoffset
 6185   5E5C   85 11       		sta	BITOFF		; where it wants it
 6186                      	
 6187   5E5E   A5 8C       		lda	FPCL		; check for correct bank
 6188   5E60   29 01       		and	#$01		; if odd, then must be main bank
 6189   5E62   D0 04       		bne	STP11		; okay, it be odd
 6190   5E64   A9 01       		lda	#AUX		; aux bank
 6191   5E66   D0 02       		bne	STP22		; jump
 6192   5E68               	STP11:
 6193   5E68   A9 00       		lda	#MAIN		; main bank
 6194   5E6A               	STP22:
 6195   5E6A   85 8E       		sta	FPCBNK		; save it
 6196   5E6C   A5 8C       		lda	FPCL		; get for fetch
 6197   5E6E   4A          		lsr	A		; /2 to get correct byte offset
 6198   5E6F   A6 01       		ldx	SCRCY		; get vertical pos
 6199   5E71   18          		clc			; get ready for adding
 6200   5E72   7D 37 6A    		adc	BASEL,X	 	; add low part
 6201   5E75   85 8C       		sta	FPCL		; save low part
 6202   5E77   BD F7 6A    		lda	BASEH,X		; get high part
 6203   5E7A   85 8D       		sta	FPCH		; save high part
 6204   5E7C   60          		rts			; done !?
 6205                      	;
 6206                      	; DO_EOL - if this is end of line, check if we are at end of window
 6207                      	; 	and if we are, and it is a scrollable window, scroll.  Then move
 6208                      	;	the cursor to the left margin of said window
 6209                      	;
 6210   5E7D               	DO_EOL:
 6211   5E7D   20 F1 71    		jsr	DISP_LINE	; make sure line gets out there
 6212   5E80   A5 01       		lda	SCRCY		; get current vertical pos
 6213   5E82   18          		clc			; add font height
 6214   5E83   69 09       		adc	#FONT_H		; thank you
 6215   5E85   48          		pha			; save this position
 6216   5E86   69 09       		adc	#FONT_H		; make sure we have room for characters here
 6217   5E88   C5 02       		cmp	SCRBTM		; so check against the bottom
 6218   5E8A   F0 02       		beq	SAVECV		; no scroll yet
 6219   5E8C   B0 05       		bcs	SCROLLCITY	; nope, can't use it
 6220   5E8E               	SAVECV:
  Wed Jun  7 1989 12:04                                                                                                  Page   90

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6221   5E8E   68          		pla			; get new CV
 6222   5E8F   85 01       		sta	SCRCY		; and save it
 6223   5E91   D0 09       		bne	DEL1		; JUMP
 6224   5E93               	SCROLLCITY:
 6225   5E93   68          		pla			; get bad y pos
 6226   5E94   AD DC 71    		lda	SCRLFLG		; is this a scrolling window?
 6227   5E97   F0 03       		beq	DEL1		; nope, just move to left edge
 6228   5E99   20 ED 5F    		jsr	SCROLL_UP	; and scroll window
 6229   5E9C               	DEL1:
 6230                      	;
 6231                      	; move cursor back to left margin
 6232                      	;
 6233   5E9C   A5 04       		lda	LEFTMRG		; get left margin
 6234   5E9E   85 00       		sta	SCRCX		; and set itpositions
 6235   5EA0   A9 01       		lda	#1		; show cursor changed (maybe)
 6236   5EA2   8D 7C 6C    		sta	CURSFLG		; okay
 6237   5EA5   A9 00       		lda	#0		; clear length too
 6238   5EA7   85 A7       		sta	LENGTH+LO	; no more on line
 6239   5EA9   85 A8       		sta	LENGTH+HI	; no more on line
 6240   5EAB   4C A1 5D    		jmp	CH_EXIT		; now finish it up
 6241                      	;
 6242                      	; DO_BSPC - do a backspace, by erasing char just before cursor to
 6243                      	;	background color, and moving cursor back one space
 6244                      	; 	[X] == character to delete
 6245                      	;
 6246   5EAE   0000        	SAVECHX: DW 	0
 6247                      	
 6248   5EB0               	DO_BSPC:
 6249   5EB0   AD D8 71    		lda	CHR_X+LO	; figger new CHR_X
 6250   5EB3   38          		sec			; subtract width
 6251   5EB4   A4 C1       		ldy	FONTFLG		; get which font we be using
 6252   5EB6   F0 05       		beq	DOBSP0		; must be variable width
 6253   5EB8   E9 0C       		sbc	#MONOFONT_W	; get width then of mono font
 6254   5EBA   4C C0 5E    		jmp	DOBSP1		; okay, now do add
 6255   5EBD               	DOBSP0:
 6256   5EBD   FD 2A 64    		sbc	CHWID,X		; get width of char to be erased
 6257   5EC0               	DOBSP1:
 6258   5EC0   8D D8 71    		sta	CHR_X+LO	; show new one
 6259   5EC3   8D AE 5E    		sta	SAVECHX+LO	; save to restore later
 6260   5EC6   AD D9 71    		lda	CHR_X+HI	; and pick up carry
 6261   5EC9   E9 00       		sbc	#0		; okay, did it
 6262   5ECB   8D D9 71    		sta	CHR_X+HI	; save it
 6263   5ECE   8D AF 5E    		sta	SAVECHX+HI	; okay
 6264   5ED1   A0 20       		ldy	#SPACE		; get SPACE offset
 6265   5ED3   A5 C1       	        lda     FONTFLG         ; monospaced font?
 6266   5ED5   F0 04       	        beq     DOBSP2          ; nope
 6267   5ED7   A9 0C       	        lda     #MONOFONT_W     ; make monospaced wide
 6268   5ED9   D0 03       	        bne     DOBSP3          ; fine
 6269   5EDB               	DOBSP2:
 6270   5EDB   BD 2A 64    		lda	CHWID,X		; get width of char
 6271   5EDE               	DOBSP3:
 6272   5EDE   99 2A 64    		sta	CHWID,Y		; set space to be this wide	
 6273   5EE1   8C 80 02    		sty	SCRBUFF		; make space for erasing
 6274   5EE4   A9 01       		lda	#1		; show one char
 6275   5EE6   8D E4 71    		sta	SCRCNT		; assume it used to be zero
 6276   5EE9   20 F1 71    		jsr	DISP_LINE	; put that space out
 6277   5EEC   AD AE 5E    		lda	SAVECHX+LO	; restore old/new x pos
 6278   5EEF   8D D8 71    		sta	CHR_X+LO
 6279   5EF2   AD AF 5E    		lda	SAVECHX+HI
 6280   5EF5   8D D9 71    		sta	CHR_X+HI
 6281   5EF8   20 8A 73    		jsr	GET_SCRCX	; update SCRCX please
 6282                      	
 6283   5EFB   A9 08       		lda	#SPACE_WIDTH	; restore width of space char
 6284   5EFD   A0 20       		ldy	#SPACE		; get offset
 6285   5EFF   99 2A 64    		sta	CHWID,Y		; okay
 6286                      	
 6287   5F02   4C A1 5D    		jmp	CH_EXIT		; done
 6288                      	;
 6289                      	; CLS - clear the window, using CLS parameters
 6290                      	;
 6291   5F05               	CLS:
 6292   5F05   A5 00       		lda	SCRCX		; save the current X,Y
 6293   5F07   8D 81 5D    		sta	SAVECX		; x
 6294   5F0A   A5 01       		lda	SCRCY
 6295   5F0C   8D 80 5D    		sta	SAVECY		; saved
  Wed Jun  7 1989 12:04                                                                                                  Page   91

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6296   5F0F   A5 0B       		lda	CLSTOP		; get top line
 6297   5F11   85 01       		sta	SCRCY		; and set up a y pos
 6298                      	
 6299   5F13   20 C1 5F    		jsr	SETMASK		; set up masks and ending point
 6300                      	
 6301   5F16   A5 BD       		lda	CPY_COUNT	; get count
 6302   5F18   85 14       		sta	SH_LOOP		; save count
 6303   5F1A   A5 0A       		lda	CLSLEFT		; get left edge
 6304   5F1C   85 00       		sta	SCRCX		; set up as X pos
 6305   5F1E   A0 0E       		ldy	#WINBGND	; get background offset
 6306   5F20   B1 05       		lda	(WINDOW),Y	; get background color
 6307   5F22   85 71       		sta	ARG8		; save it here
 6308   5F24   A5 0C       		lda	CLSWIDTH	; how wide we be?
 6309   5F26   D0 05       		bne	CLSOKAY		; not a zero width
 6310   5F28   A9 19       		lda	#25		; zero can't do zero width
 6311   5F2A   4C 0A 52    		jmp	ZERROR		; so die
 6312   5F2D               	CLSOKAY:
 6313   5F2D   C9 03       		cmp	#3		; if skinny, handle special
 6314   5F2F   B0 28       		bcs	L1L0		; nope
 6315   5F31   85 6F       		sta	ARG7		; make this be the counter
 6316   5F33   A5 0D       		lda	CLSHEIGHT	; just use PUT/GET NYBBLE if only one wide
 6317   5F35   D0 05       		bne	CLSOKAY1	; not a zero height either
 6318   5F37   A9 19       		lda	#25		; bad error
 6319   5F39   4C 0A 52    		jmp	ZERROR
 6320   5F3C               	CLSOKAY1:	
 6321   5F3C   85 7A       		sta	J		; save here
 6322   5F3E               	CLS1W:
 6323   5F3E   A5 71       		lda	ARG8		; get color
 6324   5F40   20 A6 5D    		jsr	PUT_NYBBLE	; put it
 6325   5F43   E6 00       		inc	SCRCX		; next x
 6326   5F45   C6 6F       		dec	ARG7		; counter
 6327   5F47   D0 F5       		bne	CLS1W		; do next X
 6328   5F49   A5 0A       		lda	CLSLEFT		; get left edge again
 6329   5F4B   85 00       		sta	SCRCX		; point to it
 6330   5F4D   E6 01       		inc	SCRCY		; next line
 6331   5F4F   A5 0C       		lda	CLSWIDTH	; restore width count
 6332   5F51   85 6F       		sta	ARG7		; thanks
 6333   5F53   C6 7A       		dec	J		; count
 6334   5F55   D0 E7       		bne	CLS1W		; do it
 6335   5F57   F0 56       		beq	CLSEXIT		; all done then
 6336   5F59               	L1L0:
 6337   5F59   85 7A       		sta	J		; use j as counter
 6338   5F5B               	L1L:
 6339   5F5B   A5 71       		lda	ARG8		; a color please
 6340   5F5D   20 A6 5D    		jsr	PUT_NYBBLE	; do first line easy
 6341   5F60   E6 00       		inc	SCRCX		; next nybble
 6342   5F62   C6 7A       		dec	J		; done yet?
 6343   5F64   D0 F5       		bne	L1L		; nope
 6344                      	
 6345   5F66   A5 0A       		lda	CLSLEFT		; where is left column
 6346   5F68   85 00       		sta	SCRCX		; here!
 6347   5F6A   20 51 5E    		jsr	SETPOS		; get the address
 6348   5F6D   20 78 90    		jsr	FP2SP		; SPC is source PC, now!
 6349   5F70   A5 0D       		lda	CLSHEIGHT	; how many lines are we clearing
 6350   5F72   D0 05       		bne	CLSOKAY2	; not a zero height either
 6351   5F74   A9 19       		lda	#25		; bad error
 6352   5F76   4C 0A 52    		jmp	ZERROR
 6353   5F79               	CLSOKAY2:	
 6354   5F79   85 7A       		sta	J		; j is counter again
 6355   5F7B   C6 7A       	 	dec	J		; already cleared one line
 6356   5F7D   F0 30       		beq	CLSEXIT		; only one line to do!
 6357   5F7F               	CLSLOOP:
 6358   5F7F   A5 90       	        lda     SPCH            ; now, modify COPY_LINE
 6359   5F81   8D 7D 1D    	        sta     CPY_MOD1_SRC+HI
 6360   5F84   8D A1 1D    	        sta     CPY_MOD2_SRC+HI
 6361   5F87   A5 8F       	        lda     SPCL
 6362   5F89   8D 7C 1D    	        sta     CPY_MOD1_SRC+LO
 6363   5F8C   8D A0 1D    	        sta     CPY_MOD2_SRC+LO     
 6364   5F8F   E6 01       		inc	SCRCY		; clear this line
 6365   5F91   20 51 5E    		jsr	SETPOS		; where am i?
 6366   5F94   A5 8D       	        lda     FPCH            ; now, modify COPY_LINE
 6367   5F96   8D 80 1D    	        sta     CPY_MOD1_DST+HI
 6368   5F99   8D A4 1D    	        sta     CPY_MOD2_DST+HI
 6369   5F9C   A5 8C       	        lda     FPCL
 6370   5F9E   8D 7F 1D    	        sta     CPY_MOD1_DST+LO
  Wed Jun  7 1989 12:04                                                                                                  Page   92

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6371   5FA1   8D A3 1D    	        sta     CPY_MOD2_DST+LO     
 6372   5FA4   A5 14       		lda	SH_LOOP		; get count
 6373   5FA6   85 BD       		sta	CPY_COUNT	; and save it
 6374   5FA8   20 50 1D    		jsr	COPY_LINE	; did the copy (i hope)
 6375   5FAB   C6 7A       		dec	J		; count it
 6376   5FAD   D0 D0       		bne	CLSLOOP		; next one please
 6377   5FAF               	CLSEXIT:
 6378   5FAF   AD 81 5D    	 	lda	SAVECX		; get X,Y back
 6379   5FB2   85 00       		sta	SCRCX		; got it
 6380   5FB4   AD 80 5D    		lda	SAVECY		; now for y
 6381   5FB7   85 01       		sta	SCRCY		; restored!
 6382                      	
 6383   5FB9   60          		rts
 6384                      	;
 6385                      	; SETMASK - figger out the start and end masks, as well as setting
 6386                      	;	stuff to point to stopping address.  Use CLSLEFT and CLSWIDTH
 6387                      	;
 6388   5FBA   00 01 03 07 0F 	ST_BITS: db 0,1,3,7,$f,$1f,$3f
        5FBF   1F 3F 
 6389   5FC1               	SETMASK:
 6390   5FC1   A5 0A       		lda	CLSLEFT		; munge with SCRX
 6391   5FC3   85 00       		sta	SCRCX		; okay
 6392   5FC5   20 51 5E    		jsr	SETPOS		; get me the bit offset of start
 6393                      	
 6394   5FC8   A6 11       		ldx	BITOFF		; now set up mask
 6395   5FCA   BD BA 5F    		lda	ST_BITS,X	; get the bit pattern
 6396   5FCD   85 1A       		sta	STMASK		; save it
 6397                      	
 6398   5FCF   A5 0A       		lda	CLSLEFT		; get left edge again
 6399   5FD1   18          		clc			; add width
 6400   5FD2   65 0C       		adc	CLSWIDTH	; to get where to stop
 6401   5FD4   AA          		tax			; make index
 6402   5FD5   86 00       		stx	SCRCX		; set cur pos
 6403   5FD7   BD 52 03    		lda	XPOSTBL,X	; get how many bytes
 6404   5FDA   A6 0A       		ldx	CLSLEFT		; subtract from byte offset of start
 6405   5FDC   38          		sec			; subbing
 6406   5FDD   FD 52 03    		sbc	XPOSTBL,X
 6407   5FE0   85 BD       		sta	CPY_COUNT	; and save it
 6408                      	
 6409   5FE2   20 51 5E    		jsr	SETPOS		; so get its address
 6410                      	
 6411   5FE5   A6 11       		ldx	BITOFF		; get bit offset
 6412   5FE7   BD BA 5F    		lda	ST_BITS,X	; get pattern
 6413   5FEA   85 1B       		sta	ENDMASK		; okay!
 6414   5FEC   60          		rts
 6415                      	;
 6416                      	; SCROLL_UP - roll the current window by FONT_H lines
 6417                      	;
 6418   5FED               	SCROLL_UP:
 6419   5FED   A9 09       		lda 	#FONT_H		; show one line
 6420   5FEF   85 18       		sta	SCLLINES	; done
 6421   5FF1   85 1D       		sta	SCLDIR		; show scroll up with positive number
 6422   5FF3   A0 00       		ldy	#WINTOP		; get top of screen
 6423   5FF5   B1 05       		lda	(WINDOW),Y	; got it
 6424   5FF7   85 0B       		sta	CLSTOP		; saved it
 6425   5FF9   C8          		iny			; point to left edge
 6426   5FFA   B1 05       		lda	(WINDOW),Y	; get left edge
 6427   5FFC   85 0A       		sta	CLSLEFT		; save
 6428   5FFE   C8          		iny			; this is now the height
 6429   5FFF   B1 05       		lda	(WINDOW),Y	; get window height
 6430   6001   85 0D       		sta	CLSHEIGHT	; show me
 6431   6003   C8          		iny			; and now for the width
 6432   6004   B1 05       		lda	(WINDOW),Y	; get width
 6433   6006   85 0C       	  	sta	CLSWIDTH	; saved it
 6434                      					; so fall thru
 6435                      					; and do the scrolling
 6436                      	;	FALLING THRU
 6437                      	;	   |
 6438                      	;	  \ /
 6439                      	;
 6440                      	;
 6441                      	; DO_SCROLL - scroll SCLLINES withing the window as defined by
 6442                      	;	CLSLEFT,TOP,WIDTH, and HEIGHT
 6443                      	;
 6444   6008               	DO_SCROLL:
  Wed Jun  7 1989 12:04                                                                                                  Page   93

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6445   6008   A5 00       		lda	SCRCX		; save the current X,Y
 6446   600A   8D 81 5D    		sta	SAVECX		; x
 6447   600D   A5 01       		lda	SCRCY
 6448   600F   8D 80 5D    		sta	SAVECY		; saved
 6449   6012   A5 18       		lda	SCLLINES	; how many lines?
 6450                      	
 6451   6014   A6 1D       		ldx	SCLDIR		; which direction?
 6452   6016   10 04       		bpl	SC1		; >0 means scroll up
 6453                      	;
 6454                      	; scroll down, so we are going to start at the bottom and copy downwards
 6455                      	; until we reach the top
 6456                      	;
 6457                      	; now modify code so we do adds to get destination line and subtracts
 6458                      	; to get new src line
 6459                      	;
 6460   6018   A0 C6       		ldy	#$C6		; 'dec' opcode
 6461   601A   D0 04       		bne	SC2		; jump to modify
 6462   601C               	SC1:
 6463                      	;
 6464                      	; scroll up - start at top and copy upwards until we reach the bottom
 6465                      	;
 6466   601C   A0 E6       		ldy	#$E6		; 'inc' opcode
 6467   601E   A6 18       		ldx	SCLLINES	; get # of scrolling lines
 6468   6020               	SC2:
 6469   6020   8C D7 60    		sty	SCMOD1		; make inc/dec
 6470   6023   8C D9 60    		sty	SCMOD2		; either inc or dec
 6471   6026   86 1C       		stx	SCOFF		; save the offset between SRC and DST
 6472                      	
 6473   6028   A5 1D       		lda	SCLDIR		; which direction?
 6474   602A   10 13       		bpl	SC3		; must be normal scroll
 6475                      	;
 6476                      	; if scrolling downwards, we need to start source at bottom-offset and
 6477                      	; end when the destination is at top+offset
 6478                      	;
 6479   602C   A5 0D       		lda	CLSHEIGHT	; get # of lines in window
 6480   602E   38          		sec			; subbing
 6481   602F   E5 1C       		sbc	SCOFF		; subtract offset to get source
 6482   6031   18          		clc			; adding
 6483   6032   65 0B       		adc	CLSTOP		; and get absolute position
 6484   6034   AA          		tax			; put in X
 6485   6035   CA          		dex			; for 0 offset it
 6486   6036   A5 0B       		lda	CLSTOP		; now figger last line to copy
 6487   6038   18          		clc			; adding
 6488   6039   65 0D       		adc	CLSHEIGHT	; get me last line
 6489   603B   A8          		tay			; for later storage
 6490   603C   88          		dey			; make 0 based
 6491   603D   D0 08       		bne	SC4		; always jumps
 6492   603F               	SC3:
 6493                      	;
 6494                      	; if scrolling upwards, start src at top+offset and end when destination
 6495                      	; is at bottom-offset
 6496                      	;
 6497   603F   A5 0B       		lda	CLSTOP		; get top
 6498   6041   18          		clc			; adding
 6499   6042   65 1C       		adc	SCOFF		; add in offset
 6500   6044   AA          		tax			; for later on
 6501   6045   A4 0B       		ldy	CLSTOP		; first destination is top of window
 6502   6047               	SC4:
 6503   6047   86 01       		stx	SCRCY		; Starting Source
 6504   6049   84 15       		sty	SCROLLY		; Starting Destination
 6505                      	
 6506   604B   20 C1 5F    		jsr	SETMASK		; set the masks and horizontal endpoint
 6507   604E   A5 BD       		lda	CPY_COUNT	; save for future generations
 6508   6050   85 14       		sta	SH_LOOP		; save it
 6509   6052   A5 0D       		lda	CLSHEIGHT	; how high
 6510   6054   85 10       		sta	DATALOOP	; save as counter
 6511   6056   38          		sec			; for subbing
 6512   6057   E5 1C       		sbc	SCOFF		; subtract scrolling amount
 6513   6059   85 0D       		sta	CLSHEIGHT	; this is how many lines to copy
 6514   605B   A5 01       		lda	SCRCY		; save Start Source
 6515   605D   48          		pha
 6516   605E   A5 0B       		lda	CLSTOP		; start at Y pos
 6517   6060   85 01       		sta	SCRCY
 6518   6062   A5 0A       		lda	CLSLEFT		; and x pos
 6519   6064   85 00       		sta	SCRCX		; thank you
  Wed Jun  7 1989 12:04                                                                                                  Page   94

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6520   6066   AD 54 C0    		lda	PAGE2SW+MAIN	; make sure main memory page is in there
 6521   6069               	SCRL1:
 6522   6069   20 51 5E    		jsr	SETPOS		; set up line pointer
 6523   606C   A4 01       		ldy	SCRCY		; get top
 6524   606E   C0 78       		cpy	#120		; 120 bytes per list
 6525   6070   90 05       		bcc	SCRLY		; all set
 6526   6072   98          		tya			; for adding
 6527   6073   18          		clc
 6528   6074   69 08       		adc	#8
 6529   6076   A8          		tay
 6530   6077               	SCRLY:
 6531   6077   A5 8D       		lda	FPCH
 6532   6079   99 00 06    		sta	SV_PCH,Y
 6533   607C   A5 8C       		lda	FPCL
 6534   607E   99 00 04    		sta	SV_PCL,Y
 6535   6081   E6 01       		inc	SCRCY		; next line please
 6536   6083   C6 10       		dec	DATALOOP
 6537   6085   D0 E2       		bne	SCRL1
 6538                      	
 6539   6087   68          		pla			; get StartSource back
 6540   6088   85 01       		sta	SCRCY
 6541   608A   A5 8E       		lda	FPCBNK		; init SPC bank too
 6542   608C   85 91       		sta	SPCBNK		; fine, we did
 6543   608E               	SCROLLING:
 6544   608E   A4 01       		ldy	SCRCY		; get source Y for index
 6545   6090   C0 78       		cpy	#120		; jump over junk
 6546   6092   90 05       		bcc	SCLYY
 6547   6094   98          		tya
 6548   6095   18          		clc
 6549   6096   69 08       		adc	#8
 6550   6098   A8          		tay
 6551   6099               	SCLYY:
 6552   6099   B9 00 06    		lda	SV_PCH,Y
 6553   609C   85 90       		sta	SPCH
 6554   609E   8D 7D 1D    	        sta     CPY_MOD1_SRC+HI
 6555   60A1   8D A1 1D    	        sta     CPY_MOD2_SRC+HI
 6556   60A4   B9 00 04    		lda	SV_PCL,Y
 6557   60A7   8D 7C 1D    	        sta     CPY_MOD1_SRC+LO
 6558   60AA   8D A0 1D    	        sta     CPY_MOD2_SRC+LO     
 6559   60AD   85 8F       		sta	SPCL
 6560                      	
 6561   60AF   A4 15       		ldy	SCROLLY		; get destination Y pos
 6562   60B1   C0 78       		cpy	#120		; jump over junk
 6563   60B3   90 05       		bcc	SCLYY1
 6564   60B5   98          		tya
 6565   60B6   18          		clc
 6566   60B7   69 08       		adc	#8
 6567   60B9   A8          		tay
 6568   60BA               	SCLYY1:
 6569   60BA   B9 00 06    		lda	SV_PCH,Y
 6570   60BD   85 8D       		sta	FPCH
 6571   60BF   8D 80 1D    	        sta     CPY_MOD1_DST+HI
 6572   60C2   8D A4 1D    	        sta     CPY_MOD2_DST+HI
 6573   60C5   B9 00 04    		lda	SV_PCL,Y
 6574   60C8   8D 7F 1D    	        sta     CPY_MOD1_DST+LO
 6575   60CB   8D A3 1D    	        sta     CPY_MOD2_DST+LO     
 6576   60CE   85 8C       		sta	FPCL
 6577                      	
 6578   60D0   A5 14       		lda	SH_LOOP		; get byte counter
 6579   60D2   85 BD       		sta	CPY_COUNT	; show copy line
 6580   60D4   20 50 1D    		jsr	COPY_LINE	; and do the copy
 6581   60D7   E6 01       	SCMOD1:	inc	SCRCY		; inc or dec to get next one
 6582   60D9   E6 15       	SCMOD2:	inc	SCROLLY		; inc/dec for next destination Y
 6583   60DB   C6 0D       		dec	CLSHEIGHT	; count down
 6584   60DD   D0 AF       		bne	SCROLLING	; nope
 6585                      	
 6586   60DF   A6 1D       		ldx	SCLDIR		; scroll up or down?
 6587   60E1   10 09       		bpl	SCLCLR1		; clear a little different
 6588                      	;
 6589                      	; if scrolling down, clear from current Y+1
 6590                      	;	
 6591   60E3   A5 01       		lda	SCRCY		; get current source
 6592   60E5   85 0B       		sta	CLSTOP		; save in top spot
 6593   60E7   E6 0B       		inc	CLSTOP		; get inside window
 6594   60E9   4C F0 60    		jmp	SCLCLR2
  Wed Jun  7 1989 12:04                                                                                                  Page   95

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6595   60EC               	SCLCLR1:
 6596   60EC   A5 15       		lda	SCROLLY		; get last destination
 6597   60EE   85 0B       		sta	CLSTOP		; and save it
 6598   60F0               	SCLCLR2:
 6599   60F0   A5 1C       		lda	SCOFF		; and both clear this many lines
 6600   60F2   85 0D       		sta	CLSHEIGHT	; okay?
 6601                      	
 6602   60F4   AD 81 5D    		lda	SAVECX		; now restore X and Y
 6603   60F7   85 00       		sta	SCRCX		; x
 6604   60F9   AD 80 5D    		lda	SAVECY		; and
 6605   60FC   85 01       		sta	SCRCY		; y
 6606                      	
 6607   60FE   20 05 5F    		jsr	CLS		; WIDTH and LEFT should be okay still
 6608                      	
 6609   6101   60          		rts
 6610                      	;
 6611                      	; CLREOL - clear from current cursor position to end of line by
 6612                      	;	using CLS after changing the window size
 6613                      	;	
 6614   6102               	CLREOL:
 6615   6102   A5 00       		lda	SCRCX		; and make left be where cursor is
 6616   6104   85 0A       		sta	CLSLEFT
 6617   6106   A5 01       		lda	SCRCY		; and top be where Y is
 6618   6108   85 0B       		sta	CLSTOP
 6619   610A   A9 09       		lda	#FONT_H		; and bottom be bottom of char
 6620   610C   85 0D       		sta	CLSHEIGHT
 6621   610E   A0 03       		ldy	#WINWID		; get width
 6622   6110   B1 05       		lda	(WINDOW),Y	; got it
 6623   6112   18          		clc			; now adding 
 6624   6113   A0 01       		ldy	#WINLEFT	; the left edge
 6625   6115   71 05       		adc	(WINDOW),Y	; to get the right edge
 6626   6117   38          		sec			; subbing
 6627   6118   E5 0A       		sbc	CLSLEFT		; and subtract left to get width
 6628   611A   A0 07       	        ldy     #WINRM          ; remove the size of the right margin
 6629   611C   F1 05       	        sbc     (WINDOW),Y      ; that too
 6630   611E   85 0C       		sta	CLSWIDTH 	; okay?
 6631   6120   4C 05 5F    		jmp	CLS		; now clear the screen
 6632                      	;
 6633                      	; COPY_SCRL - copy from SCR_LINE onto the screen.  CH_OFFSET says how
 6634                      	;	many bytes in SCR_LINE to copy.  FPC is assumed to be pointing
 6635                      	;	to start of screen bytes.  BITTER has the original BITOFF from
 6636                      	;	SETPOS.  ENDBIT shows how many significant bits in last byte.
 6637                      	;
 6638   6123               	COPY_SCRL:
 6639   6123   AE E3 71    		ldx	SHOW_CURSOR	; are we showing the cursor (ugh)
 6640   6126   F0 03       		beq	COPYL2		; nope
 6641   6128   4C A2 73    		jmp	DO_CURSOR	; then XOR cursor in
 6642   612B               	COPYL2:
 6643   612B   A0 0E       		ldy	#WINBGND	; get background offset
 6644   612D   B1 05       		lda	(WINDOW),Y	; get current background color
 6645   612F   F0 03       		beq	COPY_SCRL1	; if black, ignore this
 6646   6131   20 F2 61    		jsr	FIX_COLOR	; or in the color, please
 6647                      	;
 6648                      	; Alternate entry point for COPY_SCRL, used by picture drawing routine
 6649                      	; to avoid using background color and checking for cursor
 6650                      	;
 6651   6134               	COPY_SCRL1:
 6652   6134   A6 8E       		ldx	FPCBNK		; set up bank
 6653   6136   BD 54 C0    		lda	PAGE2SW,X	; set first bank 
 6654   6139   AD DA 71    		lda	ENDBIT		; did we end evenly?
 6655   613C   D0 02       		bne	COPYL22		; nope
 6656   613E   E6 0F       		inc	CH_OFFSET		; make CH_OFFSET be a counter
 6657   6140               	COPYL22:
 6658   6140   A0 00       		ldy	#0		; zero y
 6659                      	
 6660   6142   A5 0F       		lda	CH_OFFSET		; if only one, then handle real special
 6661   6144   D0 24       		bne	COPYL21		; nope
 6662                      	
 6663   6146   AE E1 71    		ldx	BITTER		; get starting bit offset
 6664   6149   BD BA 5F    		lda	ST_BITS,X	; get starting bit mask
 6665   614C   85 AC       		sta	IOCHAR		; save it
 6666   614E   AE DA 71    		ldx	ENDBIT		; get ending bit offset
 6667   6151   BD BA 5F    		lda	ST_BITS,X	; combine with ending mask bits
 6668   6154   49 FF       		eor	#$FF		; set for good ones
 6669   6156   05 AC       		ora	IOCHAR		; set up mask for bits
  Wed Jun  7 1989 12:04                                                                                                  Page   96

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6670   6158   31 8C       		and	(FPC),Y		; get me interesting bits
 6671   615A   91 8C       		sta	(FPC),Y		; save
 6672   615C   A5 AC       		lda	IOCHAR		; get flag for data
 6673   615E   49 FF       		eor	#$FF		; flip to get good data
 6674   6160   2D 00 1F    	CPYSM1:	and	SCR_LINE	; pick up my bits
 6675   6163   11 8C       		ora	(FPC),Y		; and or in screen data
 6676   6165   91 8C       		sta	(FPC),Y		; and save it 
 6677   6167   4C EE 61    		jmp	COPYLEX		; go away now
 6678   616A               	COPYL21:
 6679   616A   A5 0F       		lda	CH_OFFSET		; get # of chars
 6680   616C   4A          		lsr	A		; /2 get number in this bank
 6681   616D   69 00       		adc	#0		; pick up carry for first one
 6682   616F   85 10       		sta	DATALOOP	; and save it to work on
 6683                      	
 6684   6171   AE E1 71    		ldx	BITTER		; do we have a weird start?
 6685   6174   F0 1A       		beq	DLL2		; nope
 6686                      	;
 6687                      	; need to do the first one special
 6688                      	;
 6689   6176   B1 8C       		lda	(FPC),Y		; get byte
 6690   6178   3D BA 5F    		and	ST_BITS,X	; get masking bits
 6691   617B   85 AC       		sta	IOCHAR		; save for later
 6692   617D   BD BA 5F    		lda	ST_BITS,X	; get masking bits again
 6693   6180   49 FF       		eor	#$FF		; get good bits
 6694   6182   2D 00 1F    	CPYSM2:	and	SCR_LINE	; get first data byte
 6695   6185   05 AC       		ora	IOCHAR		; pick up screen bits
 6696   6187   91 8C       		sta	(FPC),Y		; pointing
 6697   6189   C8          		iny			; next byte
 6698   618A   A2 02       		ldx	#2		; start at next one for this bank
 6699   618C   C6 10       		dec 	DATALOOP	; kount as done
 6700   618E               	COPYLOOP:
 6701   618E   F0 0C       		beq	CPYLP2		; all done with this part of line
 6702   6190               	DLL2:
 6703   6190   BD 00 1F    	CPYSM3:	lda	SCR_LINE,X	; get data
 6704   6193   91 8C       		sta	(FPC),Y		; pointing
 6705   6195   C8          		iny			; next byte
 6706   6196   E8          		inx			; next one
 6707   6197   E8          		inx			; next one
 6708   6198   C6 10       		dec	DATALOOP	; count as used
 6709   619A   10 F2       		bpl	COPYLOOP	; start loop again
 6710   619C               	CPYLP2:
 6711   619C   A0 00       		ldy	#0		; reset Y
 6712   619E   A5 8E       		lda	FPCBNK		; which bank were we at
 6713   61A0   49 01       		eor	#1		; swap to other one
 6714   61A2   AA          		tax			; make it in x
 6715   61A3   BD 54 C0    		lda	PAGE2SW,X	; swap to write bank
 6716   61A6   8A          		txa			; check which one
 6717   61A7   F0 01       		beq	CPYLP23		; correct offset
 6718   61A9   C8          		iny			; fix offset if going from main to aux
 6719   61AA               	CPYLP23:
 6720   61AA   A2 01       		ldx	#1		; start at second byte in screen line
 6721   61AC   A5 0F       		lda	CH_OFFSET		; get starting number
 6722   61AE   4A          		lsr	A		; /2 to get how many for this bank
 6723   61AF   85 10       		sta	DATALOOP	; and show it
 6724   61B1               	COPYLOOP2:
 6725   61B1   F0 0C       		beq	LINE_DONE	; all done with this part of line
 6726                      	
 6727   61B3   BD 00 1F    	CPYSM4:	lda	SCR_LINE,X	; get data
 6728   61B6   91 8C       		sta	(FPC),Y		; pointing
 6729   61B8   C8          		iny			; next byte
 6730   61B9   E8          		inx			; next one
 6731   61BA   E8          		inx			; next one
 6732   61BB   C6 10       		dec	DATALOOP	; count as used
 6733   61BD   10 F2       		bpl	COPYLOOP2	; start loop again
 6734   61BF               	LINE_DONE:
 6735                      	;
 6736                      	; do the last byte special
 6737                      	;
 6738   61BF   86 10       		stx	DATALOOP	; save pointer
 6739   61C1   AD DA 71    		lda	ENDBIT		; get ending bit offset
 6740   61C4   F0 28       		beq	COPYLEX		; all done if nothing funky
 6741   61C6   46 0F       		lsr	CH_OFFSET	; get line offset
 6742   61C8   48          		pha			; save [A]
 6743   61C9   B0 0B       		bcs	LINED1		; if odd, point at right things
 6744   61CB   C6 10       		dec	DATALOOP	;  one less then
  Wed Jun  7 1989 12:04                                                                                                  Page   97

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6745   61CD   A6 8E       		ldx	FPCBNK		; get original bank
 6746   61CF   BD 54 C0    		lda	PAGE2SW,X	; switch to it
 6747   61D2   8A          		txa			; which bank did we do?
 6748   61D3   D0 01       		bne	LINED1		; no need to step back one
 6749   61D5   88          		dey			; point one less here too
 6750   61D6               	LINED1:
 6751   61D6   68          		pla			; get ENDBIT back
 6752   61D7   AA          		tax			; make end bits be index
 6753   61D8   BD BA 5F    		lda	ST_BITS,X	; get end mask
 6754   61DB   85 AC       		sta	IOCHAR		; save mask bits
 6755   61DD   49 FF       		eor	#$FF		; toggle every bit
 6756   61DF   31 8C       		and	(FPC),Y		; get the interesting bits in byte
 6757   61E1   91 8C       		sta	(FPC),Y		; save it
 6758   61E3   A6 10       		ldx	DATALOOP	; get data pointer
 6759   61E5   BD 00 1F    	CPYSM5:	lda	SCR_LINE,X	; turn on my bits
 6760   61E8   25 AC       		and	IOCHAR		; pick up my good bits
 6761   61EA   11 8C       		ora	(FPC),Y		; bring everything together
 6762   61EC   91 8C       		sta	(FPC),Y		; save the byte
 6763   61EE               	COPYLEX:
 6764   61EE   AD 54 C0    		lda	PAGE2SW+MAIN	; back to main, thanks
 6765   61F1   60          		rts
 6766                      	
 6767   61F2               	FIX_COLOR:
 6768   61F2   E6 0F       	        inc     CH_OFFSET       ; just to make checking easier for now
 6769                      	
 6770   61F4   0A          		asl	A		; *2
 6771   61F5   0A          		asl	A		; *4 to get correct offset
 6772   61F6   69 12       		adc	#<COLORS	; add start of table
 6773   61F8   85 AD       		sta	COLORP+LO	; save for pointer
 6774   61FA   A9 03       		lda	#>COLORS	; get hi part
 6775   61FC   69 00       		adc	#0		; pick up maybe carry
 6776   61FE   85 AE       		sta	COLORP+HI	; save pointer
 6777   6200   A2 11       	        ldx     #$11            ; ORA (),Y opcode
 6778   6202   A0 0D       	        ldy     #WINFORE        ; check foreground color
 6779   6204   B1 05       	        lda     (WINDOW),Y      ; check what color
 6780   6206   D0 11       	        bne     FIXC1           ; just leave white if not black
 6781   6208   A2 00       	        ldx     #0              ; start at beginning
 6782   620A               	FIXMUNGEL:
 6783   620A   BD 00 1F    	        lda     SCR_LINE,X      ; get byte
 6784   620D   49 FF       	        eor     #$FF            ; swap all the bits
 6785   620F   9D 00 1F    	        sta     SCR_LINE,X      ; store back
 6786   6212   E8          	        inx                     ; count it
 6787   6213   E4 0F       	        cpx     CH_OFFSET       ; done?
 6788   6215   90 F3       	        bcc     FIXMUNGEL       ; nope
 6789   6217   A2 31       	        ldx     #$31            ; AND (),Y opcode
 6790   6219               	FIXC1:
 6791   6219   8E 27 62    	        stx     FCLM            ; self mod my code (again . . . sigh)
 6792   621C   AD E1 71    		lda	BITTER		; get starting offset
 6793   621F   29 03       		and	#3		; pick up wrap
 6794   6221   A8          		tay			; make index
 6795   6222   A2 00       		ldx	#0		; start at zero line
 6796   6224               	FIXLOOP:
 6797   6224   BD 00 1F    	FCM1:	lda	SCR_LINE,X	; get screen byte
 6798   6227   11 AD       	FCLM:	ora	(COLORP),Y	; or with color byte
 6799   6229   9D 00 1F    	FCM2:	sta	SCR_LINE,X	; save it
 6800   622C   C8          		iny			; next color byte
 6801   622D   C0 04       		cpy	#4		; wrapped?
 6802   622F   D0 02       		bne	FIXLP1		; nope
 6803   6231   A0 00       		ldy	#0		; restart
 6804   6233               	FIXLP1:
 6805   6233   E8          		inx			; next screen byte
 6806   6234   E4 0F       		cpx	CH_OFFSET	; done yet?
 6807   6236   90 EC       	        bcc     FIXLOOP         ; nope
 6808   6238               	        
 6809   6238   C6 0F       	        dec     CH_OFFSET       ; fix counter
 6810   623A   60          		rts			; now we are done
 6811                      	;
 6812                      	; MSCURS - Erase the cursor from the old spot and write it in the
 6813                      	;  new spot
 6814                      	;
 6815   623B   8C          	MOLDX:	db	MAXWIDTH	; spot to save x,y of mouse
 6816   623C   C0          	MOLDY:	db	MAXHEIGHT
 6817   623D               	MSCCNT:	ds	1
 6818   623E               	SVCURS:	ds	CURSW*CURSH	; save room
 6819   6246   01          	MSWCNT:	db	1
  Wed Jun  7 1989 12:04                                                                                                  Page   98

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6820   6247   00          	MSSTATE: db	0		; 0 == off, 1 == on
 6821   6248   0F 07 07 07 07 	MSCOLOR: db	$f,7,7,7,7,7,7,7
        624D   07 07 07 
 6822                      	;
 6823   6250               	MSCURS:
 6824   6250   A9 00       		lda	#0		; clear moved flag
 6825   6252   8D 12 03    		sta	MSMOVEF		; we did
 6826   6255   20 5B 62    		jsr	MSCOFF		; turn cursor off at current pos
 6827   6258   4C BA 62    		jmp	MSCON		; and turn it on in new spot
 6828                      	
 6829                      	;
 6830                      	; MSCOFF - mouse cursor off
 6831                      	;	Copy info from saved spot back onto screen @ MOLDX, MOLDY
 6832   625B               	MSCOFF:
 6833   625B   AD 47 62    	        lda     MSSTATE         ; already off?
 6834   625E   D0 01       	        bne     MSCOFF1         ; no
 6835   6260   60          	        rts                     ; done then
 6836   6261               	MSCOFF1:
 6837   6261   A5 01       		lda	SCRCY		; save X,Y
 6838   6263   8D 80 5D    		sta	SAVECY
 6839   6266   A5 00       		lda	SCRCX
 6840   6268   8D 81 5D    		sta	SAVECX
 6841   626B   AD 3B 62    		lda	MOLDX		; point to old X,Y
 6842   626E   85 00       		sta	SCRCX
 6843   6270   AD 3C 62    		lda	MOLDY
 6844   6273   85 01       		sta	SCRCY
 6845   6275   A9 00       		lda	#0		; start at beginning of saved area
 6846   6277   8D 3D 62    		sta	MSCCNT		; save counter
 6847   627A   A9 02       		lda	#CURSW		; restore width
 6848   627C   8D 46 62    		sta	MSWCNT		; and counter
 6849   627F               	RENEWL:
 6850   627F   A5 01       		lda	SCRCY		; check bounds
 6851   6281   C9 C0       		cmp	#MAXHEIGHT
 6852   6283   B0 32       		bcs	MSC1		; all done
 6853   6285               	RENEWL0:
 6854   6285   A5 00       		lda	SCRCX
 6855   6287   C9 8C       		cmp	#MAXWIDTH
 6856   6289   B0 1E       		bcs	RENEWL1		; might not be done
 6857   628B   20 10 5E    	        jsr     GET_NYBBLE      ; get screen nybble
 6858   628E   AE 3D 62    		ldx	MSCCNT		; get counter
 6859                      	;        eor     MSCOLOR,X       ; xor to turn off
 6860   6291   49 0F       	        eor     #$0F            ; turn white/black
 6861   6293   20 A6 5D    		jsr	PUT_NYBBLE	; save nybble
 6862   6296   EE 3D 62    		inc	MSCCNT		; point to next one
 6863   6299   AD 3D 62    		lda	MSCCNT		; get counter
 6864   629C   C9 08       		cmp	#(CURSW*CURSH)	; done yet?
 6865   629E   F0 17       		beq	MSC1		; yup
 6866   62A0   CE 46 62    		dec	MSWCNT		; count down one width
 6867   62A3   F0 04       		beq	RENEWL1		; it is
 6868   62A5   E6 00       		inc	SCRCX		; next x
 6869   62A7   D0 DC       		bne	RENEWL0		; try again
 6870   62A9               	RENEWL1:
 6871   62A9   AD 3B 62    		lda	MOLDX		; reset X
 6872   62AC   85 00       		sta	SCRCX
 6873   62AE   A9 02       		lda	#CURSW		; restore width
 6874   62B0   8D 46 62    		sta	MSWCNT		; and counter
 6875   62B3   E6 01       		inc	SCRCY		; next y
 6876   62B5   D0 C8       		bne	RENEWL		; okay try some more
 6877   62B7               	MSC1:
 6878   62B7   4C 19 63    		jmp 	MSCON4		; done turning it off
 6879                      	;
 6880                      	; MSCON - turn mouse cursor on
 6881                      	;	Copy white pixels into area specified by MSX, MSY
 6882                      	;
 6883   62BA               	MSCON:
 6884   62BA   AD 47 62    	        lda     MSSTATE         ; already on?
 6885   62BD   F0 01       	        beq     MSCON0          ; no
 6886   62BF   60          	        rts                     ; don't bother
 6887   62C0               	MSCON0:
 6888   62C0   A5 01       		lda	SCRCY		; save X,Y
 6889   62C2   8D 80 5D    		sta	SAVECY
 6890   62C5   A5 00       		lda	SCRCX
 6891   62C7   8D 81 5D    		sta	SAVECX
 6892                      	
 6893   62CA   A5 CB       		lda	MSX		; get mouse x
  Wed Jun  7 1989 12:04                                                                                                  Page   99

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6894   62CC   85 00       		sta	SCRCX		; set mouse X
 6895   62CE   8D 3B 62    		sta	MOLDX		; save mouse x
 6896   62D1   A5 CC       		lda	MSY		; get mouse y
 6897   62D3   85 01       		sta	SCRCY		; set mouse Y
 6898   62D5   8D 3C 62    		sta	MOLDY		; and mouse Y
 6899   62D8   A9 00       		lda	#0		; start at beginning of saved area
 6900   62DA   8D 3D 62    		sta	MSCCNT		; save counter
 6901   62DD   A9 02       		lda	#CURSW		; restore width
 6902   62DF   8D 46 62    		sta	MSWCNT		; and counter
 6903   62E2               	MSCON1:
 6904   62E2   A5 01       		lda	SCRCY		; check bounds
 6905   62E4   C9 C0       		cmp	#MAXHEIGHT
 6906   62E6   B0 31       		bcs	MSCON4		; all done
 6907   62E8               	MSCON2:
 6908   62E8   A5 00       		lda	SCRCX
 6909   62EA   C9 8C       		cmp	#MAXWIDTH
 6910   62EC   B0 1E       		bcs	MSCON3		; might not be done
 6911   62EE   20 10 5E    		jsr	GET_NYBBLE	; save nybble
 6912   62F1   AE 3D 62    	 	ldx	MSCCNT		; get counter
 6913                      	;	eor	MSCOLOR,X	; get cursor color
 6914   62F4   49 0F       	        eor     #$0F            ; turn white/black
 6915   62F6   20 A6 5D    		jsr	PUT_NYBBLE	; put nybble
 6916   62F9   EE 3D 62    		inc	MSCCNT		; point to next one
 6917   62FC   AD 3D 62    		lda	MSCCNT		; check ending
 6918   62FF   C9 08       		cmp	#(CURSW*CURSH)	; done yet?
 6919   6301   F0 16       		beq	MSCON4		; yup
 6920   6303   CE 46 62    		dec	MSWCNT		; count down one width
 6921   6306   F0 04       		beq	MSCON3		; finished for line
 6922   6308   E6 00       		inc	SCRCX		; next x
 6923   630A   D0 DC       		bne	MSCON2		; try again
 6924   630C               	MSCON3:
 6925   630C   A5 CB       		lda	MSX		; reset X
 6926   630E   85 00       		sta	SCRCX
 6927   6310   A9 02       		lda	#CURSW		; restore width
 6928   6312   8D 46 62    		sta	MSWCNT		; and counter
 6929   6315   E6 01       		inc	SCRCY		; next y
 6930   6317   D0 C9       		bne	MSCON1		; okay try some more
 6931   6319               	MSCON4:
 6932   6319   AD 47 62    	        lda     MSSTATE         ; get current state
 6933   631C   49 01       	        eor     #$01            ; toggle it
 6934   631E   8D 47 62    	        sta     MSSTATE         ; bang
 6935   6321   AD 81 5D    		lda	SAVECX		; restore X,Y
 6936   6324   85 00       		sta	SCRCX
 6937   6326   AD 80 5D    		lda	SAVECY
 6938   6329   85 01       		sta	SCRCY
 6939   632B   60          		rts	
 6940   632C               		
 6941                      	
 6942   632C               		END
 6943                      	
 6944   632C               		INCLUDE		TABLES.ASM
 6945   632C               		STTL	"--- ZIP DATA TABLES ---"
 6946                      		PAGE
  Wed Jun  7 1989 12:04                                                                                                  Page  100

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

 6947   632C               	CHADR_H:
 6948   632C   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        6331   00 00 00 00 00 
        6336   00 00 00 00 00 
        633B   00 
 6949   633C   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        6341   00 00 00 00 00 
        6346   00 00 00 00 00 
        634B   00 
 6950   634C   64 64 64 64 64 		db	>C20,>C21,>C22,>C23,>C24,>C25,>C26,>C27
        6351   64 65 65 
 6951   6354   65 65 65 65 65 		DB	>C28,>C29,>C2A,>C2B,>C2C,>C2D,>C2E,>C2F
        6359   65 65 65 
 6952   635C   65 65 65 65 65 		db	>C30,>C31,>C32,>C33,>C34,>C35,>C36,>C37
        6361   65 65 65 
 6953   6364   65 66 66 66 66 		DB	>C38,>C39,>C3A,>C3B,>C3C,>C3D,>C3E,>C3F
        6369   66 66 66 
 6954   636C   66 66 66 66 66 		db	>C40,>C41,>C42,>C43,>C44,>C45,>C46,>C47
        6371   66 66 66 
 6955   6374   66 66 66 67 67 		DB	>C48,>C49,>C4A,>C4B,>C4C,>C4D,>C4E,>C4F
        6379   67 67 67 
 6956   637C   67 67 67 67 67 		db	>C50,>C51,>C52,>C53,>C54,>C55,>C56,>C57
        6381   67 67 67 
 6957   6384   67 68 68 68 68 		DB	>C58,>C59,>C5A,>C5B,>C5C,>C5D,>C5E,>C5F
        6389   68 68 68 
 6958   638C   68 68 68 68 68 		db	>C60,>C61,>C62,>C63,>C64,>C65,>C66,>C67
        6391   68 68 68 
 6959   6394   68 68 68 69 69 		DB	>C68,>C69,>C6A,>C6B,>C6C,>C6D,>C6E,>C6F
        6399   69 69 69 
 6960   639C   69 69 69 69 69 		db	>C70,>C71,>C72,>C73,>C74,>C75,>C76,>C77
        63A1   69 69 69 
 6961   63A4   69 69 69 6A 6A 		DB	>C78,>C79,>C7A,>C7B,>C7C,>C7D,>C7E
        63A9   6A 6A 
 6962   63AB               	CHADR_L:
 6963   63AB   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        63B0   00 00 00 00 00 
        63B5   00 00 00 00 00 
        63BA   00 
 6964   63BB   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        63C0   00 00 00 00 00 
        63C5   00 00 00 00 00 
        63CA   00 
 6965   63CB   A9 BB C4 D6 E8 		db	<C20,<C21,<C22,<C23,<C24,<C25,<C26,<C27
        63D0   FA 0C 1E 
 6966   63D3   27 30 39 42 54 		DB	<C28,<C29,<C2A,<C2B,<C2C,<C2D,<C2E,<C2F
        63D8   5D 66 6F 
 6967   63DB   81 93 9C AE C0 		db	<C30,<C31,<C32,<C33,<C34,<C35,<C36,<C37
        63E0   D2 E4 F6 
 6968   63E3   FF 11 23 2C 35 		DB	<C38,<C39,<C3A,<C3B,<C3C,<C3D,<C3E,<C3F
        63E8   3E 47 50 
 6969   63EB   62 74 86 98 AA 		db	<C40,<C41,<C42,<C43,<C44,<C45,<C46,<C47
        63F0   BC C5 CE 
 6970   63F3   E0 F2 FB 0D 1F 		DB	<C48,<C49,<C4A,<C4B,<C4C,<C4D,<C4E,<C4F
        63F8   28 3A 4C 
 6971   63FB   5E 70 82 94 A6 		db	<C50,<C51,<C52,<C53,<C54,<C55,<C56,<C57
        6400   B8 CA DC 
 6972   6403   EE 00 12 24 2D 		DB	<C58,<C59,<C5A,<C5B,<C5C,<C5D,<C5E,<C5F
        6408   3F 48 5A 
 6973   640B   63 6C 7E 90 A2 		db	<C60,<C61,<C62,<C63,<C64,<C65,<C66,<C67
        6410   B4 C6 CF 
 6974   6413   E1 F3 FC 05 17 		DB	<C68,<C69,<C6A,<C6B,<C6C,<C6D,<C6E,<C6F
        6418   20 32 44 
 6975   641B   56 68 7A 83 95 		db	<C70,<C71,<C72,<C73,<C74,<C75,<C76,<C77
        6420   9E B0 C2 
 6976   6423   D4 E6 F8 0A 13 		DB	<C78,<C79,<C7A,<C7B,<C7C,<C7D,<C7E
        6428   1C 25 
 6977                      	
 6978   642A               	CHWID:
 6979   642A   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        642F   00 00 00 00 00 
        6434   00 00 00 00 00 
        6439   00 
 6980   643A   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        643F   00 00 00 00 00 
        6444   00 00 00 00 00 
  Wed Jun  7 1989 12:04                                                                                                  Page  101

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6449   00 
 6981   644A   08 06 0A 0D 0D 		db	8,6,10,13,13,14,12,5,7,7,9,10,6,9,5,10
        644F   0E 0C 05 07 07 
        6454   09 0A 06 09 05 
        6459   0A 
 6982   645A   0B 07 0A 0A 0D 		db	11,7,10,10,13,10,11,9,11,11,5,6,9,9,9,11,16,11,11,11,11
        645F   0A 0B 09 0B 0B 
        6464   05 06 09 09 09 
        6469   0B 10 0B 0B 0B 
        646E   0B 
 6983   646F   09 09 0B 0B 05 		db	9,9,11,11,5,11,12,9,15,13,11,11,11,11,11,11,11,11
        6474   0B 0C 09 0F 0D 
        6479   0B 0B 0B 0B 0B 
        647E   0B 0B 0B 
 6984   6481   10 0B 0B 0B 09 		db	16,11,11,11,9,11,9,11,9,7,11,11,11,11,11,9,11,11,6,9,11,6
        6486   0B 09 0B 09 07 
        648B   0B 0B 0B 0B 0B 
        6490   09 0B 0B 06 09 
        6495   0B 06 
 6985   6497   0F 0B 0B 0B 0B 		db	15,11,11,11,11,9,10,9,11,11,15,11,11,11,9,6,9,12
        649C   09 0A 09 0B 0B 
        64A1   0F 0B 0B 0B 09 
        64A6   06 09 0C 
 6986                      	
 6987                      		RADIX	H				; make everything be hex
 6988          64A9        	CHAR_TABLE	EQU	*
 6989   64A9   00 00 00 00 00 	C20	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 ;(SPACE)
        64AE   00 00 00 00 00 
        64B3   00 00 00 00 00 
        64B8   00 00 00 
 6990   64BB   78 78 78 78 78 	C21	DB	78,78,78,78,78,00,78,00,00 ;! 5
        64C0   00 78 00 00 
 6991   64C4   73 80 73 80 73 	C22	DB	73,80,73,80,73,80,00,00,00,00,00,00,00,00,00,00,00,00 ;" 9
        64C9   80 00 00 00 00 
        64CE   00 00 00 00 00 
        64D3   00 00 00 
 6992   64D6   39 C0 FF F0 39 	C23	DB	39,c0,ff,f0,39,c0,39,c0,ff,f0,39,c0,00,00,00,00,00,00 ;# 12
        64DB   C0 39 C0 FF F0 
        64E0   39 C0 00 00 00 
        64E5   00 00 00 
 6993   64E8   06 00 7F E0 E6 	C24	DB	06,00,7f,e0,e6,00,7f,e0,06,70,7f,e0,06,00,00,00,00,00 ;$ 12
        64ED   00 7F E0 06 70 
        64F2   7F E0 06 00 00 
        64F7   00 00 00 
 6994   64FA   78 E0 CD C0 7B 	C25	DB	78,e0,cd,c0,7b,80,07,00,0e,f0,1d,98,38,f0,00,00,00,00 ;% 13
        64FF   80 07 00 0E F0 
        6504   1D 98 38 F0 00 
        6509   00 00 00 
 6995   650C   7F 00 E3 80 E0 	C26	DB	7f,00,e3,80,e0,00,78,00,e0,e0,e1,c0,7f,80,00,00,00,00 ;& 11
        6511   00 78 00 E0 E0 
        6516   E1 C0 7F 80 00 
        651B   00 00 00 
 6996   651E   70 70 70 00 00 	C27	DB	70,70,70,00,00,00,00,00,00 ;' 4
        6523   00 00 00 00 
 6997   6527   1C 38 70 70 70 	C28	DB	1c,38,70,70,70,38,1c,00,00 ;( 6
        652C   38 1C 00 00 
 6998   6530   70 38 1C 1C 1C 	C29	DB	70,38,1c,1c,1c,38,70,00,00 ;) 6
        6535   38 70 00 00 
 6999   6539   DB 3C FF 3C DB 	C2A	DB	db,3c,ff,3c,db,00,00,00,00 ;* 8
        653E   00 00 00 00 
 7000   6542   1C 00 1C 00 FF 	C2B	DB	1c,00,1c,00,ff,80,1c,00,1c,00,00,00,00,00,00,00,00,00 ;+ 9
        6547   80 1C 00 1C 00 
        654C   00 00 00 00 00 
        6551   00 00 00 
 7001   6554   00 00 00 00 00 	C2C	DB	00,00,00,00,00,38,38,18,70 ;, 5
        6559   38 38 18 70 
 7002   655D   00 00 00 FF 00 	C2D	DB	00,00,00,ff,00,00,00,00,00 ;- 8
        6562   00 00 00 00 
 7003   6566   00 00 00 00 00 	C2E	DB	00,00,00,00,00,70,70,00,00 ;. 4
        656B   70 70 00 00 
 7004   656F   03 80 07 00 0E 	C2F	DB	03,80,07,00,0e,00,1c,00,38,00,70,00,e0,00,00,00,00,00 ;/ 9
        6574   00 1C 00 38 00 
        6579   70 00 E0 00 00 
        657E   00 00 00 
 7005   6581   1F 00 3B 80 71 	C30	DB	1f,00,3b,80,71,c0,71,c0,71,c0,3b,80,1f,00,00,00,00,00 ;0 10
  Wed Jun  7 1989 12:04                                                                                                  Page  102

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6586   C0 71 C0 71 C0 
        658B   3B 80 1F 00 00 
        6590   00 00 00 
 7006   6593   1C 7C 1C 1C 1C 	C31	DB	1c,7c,1c,1c,1c,1c,1c,00,00 ;1 6
        6598   1C 1C 00 00 
 7007   659C   3F 00 63 80 06 	C32	DB	3f,00,63,80,06,80,0e,00,1c,00,70,00,7f,80,00,00,00,00 ;2 9
        65A1   80 0E 00 1C 00 
        65A6   70 00 7F 80 00 
        65AB   00 00 00 
 7008   65AE   7F 80 03 00 06 	C33	DB	7f,80,03,00,06,00,1f,00,03,80,63,80,3f,00,00,00,00,00 ;3 9
        65B3   00 1F 00 03 80 
        65B8   63 80 3F 00 00 
        65BD   00 00 00 
 7009   65C0   07 C0 0F C0 1D 	C34	DB	07,c0,0f,c0,1d,c0,39,c0,71,c0,7f,f0,01,c0,00,00,00,00 ;4 12
        65C5   C0 39 C0 71 C0 
        65CA   7F F0 01 C0 00 
        65CF   00 00 00 
 7010   65D2   7F 80 78 00 78 	C35	DB	7f,80,78,00,78,00,7f,00,03,80,63,80,3f,00,00,00,00,00 ;5 9
        65D7   00 7F 00 03 80 
        65DC   63 80 3F 00 00 
        65E1   00 00 00 
 7011   65E4   1F 80 38 00 70 	C36	DB	1f,80,38,00,70,00,7f,80,71,c0,71,c0,3f,80,00,00,00,00 ;6 10
        65E9   00 7F 80 71 C0 
        65EE   71 C0 3F 80 00 
        65F3   00 00 00 
 7012   65F6   7F 07 07 0E 1C 	C37	DB	7f,07,07,0e,1c,1c,1c,00,00 ;7 8
        65FB   1C 1C 00 00 
 7013   65FF   3F 80 71 C0 71 	C38	DB	3f,80,71,c0,71,c0,3f,80,71,c0,71,c0,3f,80,00,00,00,00 ;8 10
        6604   C0 3F 80 71 C0 
        6609   71 C0 3F 80 00 
        660E   00 00 00 
 7014   6611   3F 80 71 C0 71 	C39	DB	3f,80,71,c0,71,c0,3f,c0,01,c0,03,80,3f,00,00,00,00,00 ;9 10
        6616   C0 3F C0 01 C0 
        661B   03 80 3F 00 00 
        6620   00 00 00 
 7015   6623   00 00 70 70 00 	C3A	DB	00,00,70,70,00,70,70,00,00 ;: 4
        6628   70 70 00 00 
 7016   662C   00 00 38 38 00 	C3B	DB	00,00,38,38,00,38,38,18,70 ;; 5
        6631   38 38 18 70 
 7017   6635   00 0E 38 E0 38 	C3C	DB	00,0e,38,e0,38,0e,00,00,00 ;< 8
        663A   0E 00 00 00 
 7018   663E   00 00 7F 00 7F 	C3D	DB	00,00,7f,00,7f,00,00,00,00 ;= 8
        6643   00 00 00 00 
 7019   6647   00 70 1C 07 1C 	C3E	DB	00,70,1c,07,1c,70,00,00,00 ;> 8
        664C   70 00 00 00 
 7020   6650   3F 80 71 C0 03 	C3F	DB	3f,80,71,c0,03,80,0e,00,0e,00,00,00,0e,00,00,00,00,00 ;? 10
        6655   80 0E 00 0E 00 
        665A   00 00 0E 00 00 
        665F   00 00 00 
 7021   6662   1F F8 E0 0E E3 	C40	DB	1f,f8,e0,0e,e3,e7,e6,77,e6,77,e3,bc,e0,00,1f,f8,00,00 ;@ 16
        6667   E7 E6 77 E6 77 
        666C   E3 BC E0 00 1F 
        6671   F8 00 00 
 7022   6674   3F 80 71 C0 71 	C41	DB	3f,80,71,c0,71,c0,7f,c0,71,c0,71,c0,71,c0,00,00,00,00 ;A 10
        6679   C0 7F C0 71 C0 
        667E   71 C0 71 C0 00 
        6683   00 00 00 
 7023   6686   7F 80 71 C0 71 	C42	DB	7f,80,71,c0,71,c0,7f,00,71,c0,71,c0,7f,80,00,00,00,00 ;B 10
        668B   C0 7F 00 71 C0 
        6690   71 C0 7F 80 00 
        6695   00 00 00 
 7024   6698   3F 80 71 C0 70 	C43	DB	3f,80,71,c0,70,00,70,00,70,00,71,c0,3f,80,00,00,00,00 ;C 10
        669D   00 70 00 70 00 
        66A2   71 C0 3F 80 00 
        66A7   00 00 00 
 7025   66AA   7F 80 71 C0 71 	C44	DB	7f,80,71,c0,71,c0,71,c0,71,c0,71,c0,7f,80,00,00,00,00 ;D 10
        66AF   C0 71 C0 71 C0 
        66B4   71 C0 7F 80 00 
        66B9   00 00 00 
 7026   66BC   7F 70 70 7F 70 	C45	DB	7f,70,70,7f,70,70,7f,00,00 ;E 8
        66C1   70 7F 00 00 
 7027   66C5   7F 70 70 7E 70 	C46	DB	7f,70,70,7e,70,70,70,00,00 ;F 8
        66CA   70 70 00 00 
 7028   66CE   3F 80 71 C0 70 	C47	DB	3f,80,71,c0,70,00,73,c0,71,c0,71,c0,3f,80,00,00,00,00 ;G 10
        66D3   00 73 C0 71 C0 
  Wed Jun  7 1989 12:04                                                                                                  Page  103

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        66D8   71 C0 3F 80 00 
        66DD   00 00 00 
 7029   66E0   71 C0 71 C0 71 	C48	DB	71,c0,71,c0,71,c0,7f,c0,71,c0,71,c0,71,c0,00,00,00,00 ;H 10
        66E5   C0 7F C0 71 C0 
        66EA   71 C0 71 C0 00 
        66EF   00 00 00 
 7030   66F2   70 70 70 70 70 	C49	DB	70,70,70,70,70,70,70,00,00 ;I 4
        66F7   70 70 00 00 
 7031   66FB   01 C0 01 C0 01 	C4A	DB	01,c0,01,c0,01,c0,01,c0,71,c0,71,c0,3f,80,00,00,00,00 ;J 10
        6700   C0 01 C0 71 C0 
        6705   71 C0 3F 80 00 
        670A   00 00 00 
 7032   670D   70 E0 71 C0 73 	C4B	DB	70,e0,71,c0,73,80,7f,00,73,80,71,c0,70,e0,00,00,00,00 ;K 11
        6712   80 7F 00 73 80 
        6717   71 C0 70 E0 00 
        671C   00 00 00 
 7033   671F   70 70 70 70 70 	C4C	DB	70,70,70,70,70,70,7f,00,00 ;L 8
        6724   70 7F 00 00 
 7034   6728   78 3C 7C 7C 7E 	C4D	DB	78,3c,7c,7c,7e,fc,77,dc,73,9c,70,1c,70,1c,00,00,00,00 ;M 14
        672D   FC 77 DC 73 9C 
        6732   70 1C 70 1C 00 
        6737   00 00 00 
 7035   673A   78 70 7C 70 7E 	C4E	DB	78,70,7c,70,7e,70,77,70,73,f0,71,f0,70,f0,00,00,00,00 ;N 12
        673F   70 77 70 73 F0 
        6744   71 F0 70 F0 00 
        6749   00 00 00 
 7036   674C   3F 80 71 C0 71 	C4F	DB	3f,80,71,c0,71,c0,71,c0,71,c0,71,c0,3f,80,00,00,00,00 ;O 10
        6751   C0 71 C0 71 C0 
        6756   71 C0 3F 80 00 
        675B   00 00 00 
 7037   675E   7F 80 71 C0 71 	C50	DB	7f,80,71,c0,71,c0,7f,80,70,00,70,00,70,00,00,00,00,00 ;P 10
        6763   C0 7F 80 70 00 
        6768   70 00 70 00 00 
        676D   00 00 00 
 7038   6770   3F 80 71 C0 71 	C51	DB	3f,80,71,c0,71,c0,71,c0,71,c0,71,c0,3f,00,03,c0,00,00 ;Q 10
        6775   C0 71 C0 71 C0 
        677A   71 C0 3F 00 03 
        677F   C0 00 00 
 7039   6782   7F 80 71 C0 71 	C52	DB	7f,80,71,c0,71,c0,7f,00,71,c0,71,c0,71,c0,00,00,00,00 ;R 10
        6787   C0 7F 00 71 C0 
        678C   71 C0 71 C0 00 
        6791   00 00 00 
 7040   6794   3F 80 71 C0 78 	C53	DB	3f,80,71,c0,78,00,1f,00,03,c0,71,c0,3f,80,00,00,00,00 ;S 10
        6799   00 1F 00 03 C0 
        679E   71 C0 3F 80 00 
        67A3   00 00 00 
 7041   67A6   7F C0 0E 00 0E 	C54	DB	7f,c0,0e,00,0e,00,0e,00,0e,00,0e,00,0e,00,00,00,00,00 ;T 10
        67AB   00 0E 00 0E 00 
        67B0   0E 00 0E 00 00 
        67B5   00 00 00 
 7042   67B8   71 C0 71 C0 71 	C55	DB	71,c0,71,c0,71,c0,71,c0,71,c0,71,c0,1f,00,00,00,00,00 ;U 10
        67BD   C0 71 C0 71 C0 
        67C2   71 C0 1F 00 00 
        67C7   00 00 00 
 7043   67CA   71 C0 71 C0 71 	C56	DB	71,c0,71,c0,71,c0,71,c0,73,80,77,00,7e,00,00,00,00,00 ;V 10
        67CF   C0 71 C0 73 80 
        67D4   77 00 7E 00 00 
        67D9   00 00 00 
 7044   67DC   71 C7 71 C7 71 	C57	DB	71,c7,71,c7,71,c7,71,c7,71,c7,71,dc,7f,f8,00,00,00,00 ;W 16
        67E1   C7 71 C7 71 C7 
        67E6   71 DC 7F F8 00 
        67EB   00 00 00 
 7045   67EE   71 C0 71 C0 71 	C58	DB	71,c0,71,c0,71,c0,1f,00,71,c0,71,c0,71,c0,00,00,00,00 ;X 10
        67F3   C0 1F 00 71 C0 
        67F8   71 C0 71 C0 00 
        67FD   00 00 00 
 7046   6800   71 C0 71 C0 71 	C59	DB	71,c0,71,c0,71,c0,3f,80,0e,00,0e,00,0e,00,00,00,00,00 ;Y 10
        6805   C0 3F 80 0E 00 
        680A   0E 00 0E 00 00 
        680F   00 00 00 
 7047   6812   7F C0 01 C0 03 	C5A	DB	7f,c0,01,c0,03,80,0e,00,38,00,70,00,7f,c0,00,00,00,00 ;Z 10
        6817   80 0E 00 38 00 
        681C   70 00 7F C0 00 
        6821   00 00 00 
 7048   6824   7F 70 70 70 70 	C5B	DB	7f,70,70,70,70,70,7f,00,00 ;[ 8
  Wed Jun  7 1989 12:04                                                                                                  Page  104

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6829   70 7F 00 00 
 7049   682D   70 00 38 00 1C 	C5C	DB	70,00,38,00,1c,00,0e,00,07,00,03,80,01,c0,00,00,00,00 ;\ 10
        6832   00 0E 00 07 00 
        6837   03 80 01 C0 00 
        683C   00 00 00 
 7050   683F   7F 07 07 07 07 	C5D	DB	7f,07,07,07,07,07,7f,00,00 ;] 8
        6844   07 7F 00 00 
 7051   6848   00 00 0C 00 3F 	C5E	DB	00,00,0c,00,3f,00,e1,c0,00,00,00,00,00,00,00,00,00,00 ;^ 10
        684D   00 E1 C0 00 00 
        6852   00 00 00 00 00 
        6857   00 00 00 
 7052   685A   00 00 00 00 00 	C5F	DB	00,00,00,00,00,00,00,ff,00 ;_ 8
        685F   00 00 FF 00 
 7053   6863   70 38 1C 00 00 	C60	DB	70,38,1c,00,00,00,00,00,00 ;` 6
        6868   00 00 00 00 
 7054   686C   00 00 00 00 3F 	C61	DB	00,00,00,00,3f,80,01,c0,3f,c0,71,c0,3f,c0,00,00,00,00 ;a 10
        6871   80 01 C0 3F C0 
        6876   71 C0 3F C0 00 
        687B   00 00 00 
 7055   687E   70 00 70 00 7F 	C62	DB	70,00,70,00,7f,80,71,c0,71,c0,71,c0,7f,80,00,00,00,00 ;b 10
        6883   80 71 C0 71 C0 
        6888   71 C0 7F 80 00 
        688D   00 00 00 
 7056   6890   00 00 00 00 3F 	C63	DB	00,00,00,00,3f,80,71,c0,70,00,71,c0,3f,80,00,00,00,00 ;c 10
        6895   80 71 C0 70 00 
        689A   71 C0 3F 80 00 
        689F   00 00 00 
 7057   68A2   01 C0 01 C0 3F 	C64	DB	01,c0,01,c0,3f,c0,71,c0,71,c0,71,c0,3f,c0,00,00,00,00 ;d 10
        68A7   C0 71 C0 71 C0 
        68AC   71 C0 3F C0 00 
        68B1   00 00 00 
 7058   68B4   00 00 00 00 3F 	C65	DB	00,00,00,00,3f,80,79,c0,7f,c0,70,00,3f,80,00,00,00,00 ;e 10
        68B9   80 79 C0 7F C0 
        68BE   70 00 3F 80 00 
        68C3   00 00 00 
 7059   68C6   0F 1C 7F 1C 1C 	C66	DB	0f,1c,7f,1c,1c,1c,1c,00,00 ;f 8
        68CB   1C 1C 00 00 
 7060   68CF   00 00 00 00 3F 	C67	DB	00,00,00,00,3f,c0,71,c0,71,c0,71,c0,3f,c0,01,c0,3f,80 ;g 10
        68D4   C0 71 C0 71 C0 
        68D9   71 C0 3F C0 01 
        68DE   C0 3F 80 
 7061   68E1   70 00 70 00 7F 	C68	DB	70,00,70,00,7f,80,71,c0,71,c0,71,c0,71,c0,00,00,00,00 ;h 10
        68E6   80 71 C0 71 C0 
        68EB   71 C0 71 C0 00 
        68F0   00 00 00 
 7062   68F3   70 00 70 70 70 	C69	DB	70,00,70,70,70,70,70,00,00 ;i 5
        68F8   70 70 00 00 
 7063   68FC   0E 00 0E 0E 0E 	C6A	DB	0e,00,0e,0e,0e,0e,0e,0e,7c ;j 8
        6901   0E 0E 0E 7C 
 7064   6905   70 00 70 00 71 	C6B	DB	70,00,70,00,71,c0,73,80,7f,00,73,80,71,c0,00,00,00,00 ;k 10
        690A   C0 73 80 7F 00 
        690F   73 80 71 C0 00 
        6914   00 00 00 
 7065   6917   70 70 70 70 70 	C6C	DB	70,70,70,70,70,70,70,00,00 ;l 5
        691C   70 70 00 00 
 7066   6920   00 00 00 00 7F 	C6D	DB	00,00,00,00,7f,fc,73,9c,73,9c,73,9c,73,9c,00,00,00,00 ;m 14
        6925   FC 73 9C 73 9C 
        692A   73 9C 73 9C 00 
        692F   00 00 00 
 7067   6932   00 00 00 00 7F 	C6E	DB	00,00,00,00,7f,80,71,c0,71,c0,71,c0,71,c0,00,00,00,00 ;n 10
        6937   80 71 C0 71 C0 
        693C   71 C0 71 C0 00 
        6941   00 00 00 
 7068   6944   00 00 00 00 3F 	C6F	DB	00,00,00,00,3f,80,71,c0,71,c0,71,c0,3f,80,00,00,00,00 ;o 10
        6949   80 71 C0 71 C0 
        694E   71 C0 3F 80 00 
        6953   00 00 00 
 7069   6956   00 00 00 00 7F 	C70	DB	00,00,00,00,7f,80,71,c0,71,c0,71,c0,7f,80,70,00,70,00 ;p 10
        695B   80 71 C0 71 C0 
        6960   71 C0 7F 80 70 
        6965   00 70 00 
 7070   6968   00 00 00 00 3F 	C71	DB	00,00,00,00,3f,80,71,c0,71,c0,71,c0,3f,c0,01,c0,01,c0 ;q 10
        696D   80 71 C0 71 C0 
        6972   71 C0 3F C0 01 
        6977   C0 01 C0 
  Wed Jun  7 1989 12:04                                                                                                  Page  105

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

 7071   697A   00 00 77 7C 70 	C72	DB	00,00,77,7c,70,70,70,00,00 ;r 8
        697F   70 70 00 00 
 7072   6983   00 00 00 00 3F 	C73	DB	00,00,00,00,3f,00,70,00,1e,00,03,80,3f,00,00,00,00,00 ;s 9
        6988   00 70 00 1E 00 
        698D   03 80 3F 00 00 
        6992   00 00 00 
 7073   6995   1C 1C 7F 1C 1C 	C74	DB	1c,1c,7f,1c,1c,1c,0f,00,00 ;t 8
        699A   1C 0F 00 00 
 7074   699E   00 00 00 00 71 	C75	DB	00,00,00,00,71,c0,71,c0,71,c0,71,c0,3f,c0,00,00,00,00 ;u 10
        69A3   C0 71 C0 71 C0 
        69A8   71 C0 3F C0 00 
        69AD   00 00 00 
 7075   69B0   00 00 00 00 71 	C76	DB	00,00,00,00,71,c0,71,c0,73,80,77,00,7e,00,00,00,00,00 ;v 10
        69B5   C0 71 C0 73 80 
        69BA   77 00 7E 00 00 
        69BF   00 00 00 
 7076   69C2   00 00 00 00 73 	C77	DB 	00,00,00,00,73,9c,73,9c,73,9c,73,9c,7f,f8,00,00,00,00 ;w 14
        69C7   9C 73 9C 73 9C 
        69CC   73 9C 7F F8 00 
        69D1   00 00 00 
 7077   69D4   00 00 00 00 71 	C78	DB	00,00,00,00,71,c0,71,c0,1f,00,71,c0,71,c0,00,00,00,00 ;x 10
        69D9   C0 71 C0 1F 00 
        69DE   71 C0 71 C0 00 
        69E3   00 00 00 
 7078   69E6   00 00 00 00 71 	C79	DB	00,00,00,00,71,c0,71,c0,71,c0,71,c0,3f,c0,01,c0,3f,80 ;y 10
        69EB   C0 71 C0 71 C0 
        69F0   71 C0 3F C0 01 
        69F5   C0 3F 80 
 7079   69F8   00 00 00 00 7F 	C7A	DB	00,00,00,00,7f,c0,03,80,0e,00,38,00,7f,c0,00,00,00,00 ;z 10
        69FD   C0 03 80 0E 00 
        6A02   38 00 7F C0 00 
        6A07   00 00 00 
 7080   6A0A   1F 38 38 F0 38 	C7B	DB	1f,38,38,f0,38,38,1f,00,00 ;} 8
        6A0F   38 1F 00 00 
 7081   6A13   70 70 70 70 70 	C7C	DB	70,70,70,70,70,70,70,70,70 ;| 5
        6A18   70 70 70 70 
 7082   6A1C   F8 1C 1C 0F 1C 	C7D	DB	f8,1c,1c,0f,1c,1c,f8,00,00 ;} 8
        6A21   1C F8 00 00 
 7083   6A25   00 00 00 00 3C 	C7E	DB	00,00,00,00,3c,e0,e7,80,00,00,00,00,00,00,00,00,00,00 ;~ 11
        6A2A   E0 E7 80 00 00 
        6A2F   00 00 00 00 00 
        6A34   00 00 00 
 7084                      	;
 7085                      	; base addresses for the screen lines
 7086                      	;	
 7087   6A37               	BASEL:
 7088   6A37   00 00 00 00 00 		DB	00,00,00,00,00,00,00,00
        6A3C   00 00 00 
 7089   6A3F   80 80 80 80 80 		DB	80,80,80,80,80,80,80,80
        6A44   80 80 80 
 7090   6A47   00 00 00 00 00 		DB	00,00,00,00,00,00,00,00
        6A4C   00 00 00 
 7091   6A4F   80 80 80 80 80 		DB	80,80,80,80,80,80,80,80
        6A54   80 80 80 
 7092   6A57   00 00 00 00 00 		DB	00,00,00,00,00,00,00,00
        6A5C   00 00 00 
 7093   6A5F   80 80 80 80 80 		DB	80,80,80,80,80,80,80,80
        6A64   80 80 80 
 7094   6A67   00 00 00 00 00 		DB	00,00,00,00,00,00,00,00
        6A6C   00 00 00 
 7095   6A6F   80 80 80 80 80 		DB	80,80,80,80,80,80,80,80
        6A74   80 80 80 
 7096   6A77   28 28 28 28 28 		DB	28,28,28,28,28,28,28,28
        6A7C   28 28 28 
 7097   6A7F   A8 A8 A8 A8 A8 		DB	A8,A8,A8,A8,A8,A8,A8,A8
        6A84   A8 A8 A8 
 7098   6A87   28 28 28 28 28 		DB	28,28,28,28,28,28,28,28
        6A8C   28 28 28 
 7099   6A8F   A8 A8 A8 A8 A8 		DB	A8,A8,A8,A8,A8,A8,A8,A8
        6A94   A8 A8 A8 
 7100   6A97   28 28 28 28 28 		DB	28,28,28,28,28,28,28,28
        6A9C   28 28 28 
 7101   6A9F   A8 A8 A8 A8 A8 		DB	A8,A8,A8,A8,A8,A8,A8,A8
        6AA4   A8 A8 A8 
 7102   6AA7   28 28 28 28 28 		DB	28,28,28,28,28,28,28,28
  Wed Jun  7 1989 12:04                                                                                                  Page  106

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6AAC   28 28 28 
 7103   6AAF   A8 A8 A8 A8 A8 		DB	A8,A8,A8,A8,A8,A8,A8,A8
        6AB4   A8 A8 A8 
 7104   6AB7   50 50 50 50 50 		DB	50,50,50,50,50,50,50,50
        6ABC   50 50 50 
 7105   6ABF   D0 D0 D0 D0 D0 		DB	D0,D0,D0,D0,D0,D0,D0,D0
        6AC4   D0 D0 D0 
 7106   6AC7   50 50 50 50 50 		DB	50,50,50,50,50,50,50,50
        6ACC   50 50 50 
 7107   6ACF   D0 D0 D0 D0 D0 		DB	D0,D0,D0,D0,D0,D0,D0,D0
        6AD4   D0 D0 D0 
 7108   6AD7   50 50 50 50 50 		DB	50,50,50,50,50,50,50,50
        6ADC   50 50 50 
 7109   6ADF   D0 D0 D0 D0 D0 		DB	D0,D0,D0,D0,D0,D0,D0,D0
        6AE4   D0 D0 D0 
 7110   6AE7   50 50 50 50 50 		DB	50,50,50,50,50,50,50,50
        6AEC   50 50 50 
 7111   6AEF   D0 D0 D0 D0 D0 		DB	D0,D0,D0,D0,D0,D0,D0,D0
        6AF4   D0 D0 D0 
 7112   6AF7               	BASEH:
 7113   6AF7   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6AFC   34 38 3C 
 7114   6AFF   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B04   34 38 3C 
 7115   6B07   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B0C   35 39 3D 
 7116   6B0F   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B14   35 39 3D 
 7117   6B17   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B1C   36 3A 3E 
 7118   6B1F   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B24   36 3A 3E 
 7119   6B27   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6B2C   37 3B 3F 
 7120   6B2F   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6B34   37 3B 3F 
 7121   6B37   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B3C   34 38 3C 
 7122   6B3F   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B44   34 38 3C 
 7123   6B47   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B4C   35 39 3D 
 7124   6B4F   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B54   35 39 3D 
 7125   6B57   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B5C   36 3A 3E 
 7126   6B5F   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B64   36 3A 3E 
 7127   6B67   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6B6C   37 3B 3F 
 7128   6B6F   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6B74   37 3B 3F 
 7129   6B77   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B7C   34 38 3C 
 7130   6B7F   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B84   34 38 3C 
 7131   6B87   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B8C   35 39 3D 
 7132   6B8F   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B94   35 39 3D 
 7133   6B97   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B9C   36 3A 3E 
 7134   6B9F   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6BA4   36 3A 3E 
 7135   6BA7   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6BAC   37 3B 3F 
 7136   6BAF   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6BB4   37 3B 3F 
 7137                      	;
 7138                      	; this gives the bit offset for each one
 7139                      	;
 7140   6BB7               	XBITTBL:
 7141   6BB7   00          		DB	0
 7142   6BB8   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BBD   03 00 
  Wed Jun  7 1989 12:04                                                                                                  Page  107

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

 7143   6BBF   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BC4   03 00 
 7144   6BC6   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BCB   03 00 
 7145   6BCD   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BD2   03 00 
 7146   6BD4   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BD9   03 00 
 7147   6BDB   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BE0   03 00 
 7148   6BE2   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BE7   03 00 
 7149   6BE9   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BEE   03 00 
 7150   6BF0   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BF5   03 00 
 7151   6BF7   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BFC   03 00 
 7152   6BFE   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C03   03 00 
 7153   6C05   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C0A   03 00 
 7154   6C0C   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C11   03 00 
 7155   6C13   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C18   03 00 
 7156   6C1A   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C1F   03 00 
 7157   6C21   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C26   03 00 
 7158   6C28   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C2D   03 00 
 7159   6C2F   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C34   03 00 
 7160   6C36   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C3B   03 00 
 7161   6C3D   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C42   03 00 
 7162                      		RADIX	D
 7163   6C44   00 01 06 07 0C 	ZIPCOLOR: db	0,1,6,7,$C,$B,$E,$F
        6C49   0B 0E 0F 
 7164   6C4C   02 03 FF FF FF 	APLCOLOR: db    2,3,$FF,$FF,$FF,$FF,4,5,$FF,$FF,$FF,7,$FF,$FF,8,9
        6C51   FF 04 05 FF FF 
        6C56   FF 07 FF FF 08 
        6C5B   09 
 7165   6C5C               	OLDZV:
 7166                      	;
 7167                      	; Variables that used to be in the zero page but got moved out
 7168                      	;
 7169          6C5C        	PSVFLG	EQU	OLDZV		; (BYTE) PRESERVE FLAG FOR LEX 0=DON'T 1=DO
 7170          6C5D        	VOCFLG	EQU	PSVFLG+1	; (BYTE) WHICH VOC TBL, 0=NORMAL 1= ARG3
 7171          6C5E        	DBLOCK	EQU	VOCFLG+1	; (WORD) Z-BLOCK TO READ
 7172          6C60        	QUOT	EQU	DBLOCK+2	; (WORD) QUOTIENT FOR DIVISION
 7173          6C62        	REMAIN	EQU	QUOT+2		; (WORD) REMAINDER FOR DIVISION
 7174          6C64        	QSIGN	EQU	REMAIN+2	; (BYTE) SIGN OF QUOTIENT
 7175          6C65        	RSIGN	EQU	QSIGN+1		; (BYTE) SIGN OF REMAINDER
 7176          6C66        	DIGITS	EQU	RSIGN+1		; (BYTE) DIGIT COUNT FOR "PRINTN"
 7177          6C67        	OLDLEN	EQU	DIGITS+1	; (BYTE) OLD LINE LENGTH
 7178          6C68        	OLDEND	EQU	OLDLEN+1	; (BYTE) OLD LAST CHAR IN [LBUFF]
 7179          6C69        	SPSTAT	EQU	OLDEND+1	; (BYTE) SPLIT SCREEN STATUS FLAG
 7180          6C6A        	LFROM	EQU	SPSTAT+1	; (WORD) "FROM" LINE ADDRESS
 7181          6C6C        	LTO	EQU	LFROM+2		; (WORD) "TO" LINE ADDRESS
 7182          6C6E        	PRLEN	EQU	LTO+2		; (BYTE) SCRIPT LINE LENGTH
 7183          6C6F        	GPOSIT	EQU	PRLEN+1		; (BYTE) DEFAULT SAVE POSITION
 7184          6C70        	GDRIVE	EQU	GPOSIT+1	; (BYTE) DEFAULT SAVE DRIVE
 7185          6C71        	TPOSIT	EQU	GDRIVE+1	; (BYTE) TEMP SAVE POSITION
 7186          6C72        	TDRIVE	EQU	TPOSIT+1	; (BYTE) TEMP SAVE DRIVE
 7187          6C73        	TSLOT	EQU	TDRIVE+1	; (BYTE) TEMP SAVE SLOT
 7188          6C74        	DRIVE	EQU	TSLOT+1		; (BYTE) CURRENT DRIVE
 7189          6C75        	SIDEFLG	EQU	DRIVE+1		; (BYTE) which disk side are we on
 7190          6C76        	SRHOLD	EQU	SIDEFLG+1	; (WORD) <>0 if doing sequential random
 7191          6C78        	SCRIPTF	EQU	SRHOLD+2	; (BYTE) DIROUT FLAG FOR PRINTER OUTPUT
 7192          6C79        	SCRIPTFLG EQU	SCRIPTF+1	; (BYTE) Does window allow scripting?
 7193          6C7A        	OLDZSP	EQU	SCRIPTFLG+1	; (WORD)
 7194          6C7C        	CURSFLG	EQU	OLDZSP+2	; (BYTE) 1==New cursor X for DLINE
  Wed Jun  7 1989 12:04                                                                                                  Page  108

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

 7195          6C7D        	DBLK	EQU	CURSFLG+1	; (WORD)
 7196          6C7F        	RDTBL1	EQU	DBLK+2		; (WORD) READ TABLE 1 (Game Relative)
 7197          6C81        	RDTBL2	EQU	RDTBL1+2	; (WORD) READ TABLE 2
 7198          6C83        	NENTS	EQU	RDTBL2+2	; (WORD) # ENTRIES IN VOCAB TABLE
 7199          6C85        	DIRITM	EQU	NENTS+2		; (WORD) OFFSET IN OUTPUT TBL (DIRTBL)
 7200          6C87        	DIRCNT	EQU	DIRITM+2	; (WORD) COUNT OF CHARS IN TBL (DIRTBL)
 7201          6C89        	SVTCHAR EQU	DIRCNT+2	; (WORD) Old TCHARS table address
 7202          6C8B        	VOCMPC	EQU	SVTCHAR+2	; (3 BYTES) Save for vocabulary MPC
 7203          6C8E        	VCESVE	EQU	VOCMPC+3	; (3 BYTES) Save for VOCEND
 7204          6C91        	VWLSVE	EQU	VCESVE+3	; (3 BYTES) Save for VOCLEN
 7205          6C94        	DIDVTBL	EQU	VWLSVE+3	; (BYTE) <>0 if we have done default table
 7206          6C95        	IN	EQU	DIDVTBL+1	; (9 BYTES) INPUT BUFFER
 7207          6C9E        	OUT	EQU	IN+9		; (9 BYTES) OUTPUT BUFFER
 7208          6CA7        	CURSOR_OFF EQU  OUT+9           ; (BYTE) ==1 if char cursor not to be on
 7209          6CA8        	CRLF_CHECK EQU    CURSOR_OFF+1    ; (BYTE) ==1 to do CRLF function check
 7210          6CA9        	PTR_COUNT EQU   CRLF_CHECK+1      ; (BYTE) ==0 if checking pointer movement
 7211          6CAA        	INFODOS_END EQU PTR_COUNT+1     ; (WORD) last segment of infodos special
 7212          0050        	OLDZVLEN EQU 	INFODOS_END-PSVFLG+2	; this is how much to reserve
 7213                      	
 7214   6C5C               		BLKB	OLDZVLEN,0	; and zero it out
 7215                      	
 7216                      	; ------------------
 7217                      	; ERROR MESSAGE STRINGS
 7218                      	; ------------------
 7219   6CAC   0E          	E27:	db	E27L
 7220   6CAD   44 69 73 6B 20 		db	"Disk I/O Error"
        6CB2   49 2F 4F 20 45 
        6CB7   72 72 6F 72 
 7221          000E        	E27L	EQU	$-E27-1
 7222   6CBB   14          	E2B:	db	E2BL
 7223   6CBC   44 69 73 6B 20 		db	"Disk write protected"
        6CC1   77 72 69 74 65 
        6CC6   20 70 72 6F 74 
        6CCB   65 63 74 65 64 
 7224          0014        	E2BL	EQU	$-E2B-1
 7225   6CD0   0C          	E40:	db	E40L
 7226   6CD1   42 61 64 20 46 		db	"Bad Filename"
        6CD6   69 6C 65 6E 61 
        6CDB   6D 65 
 7227          000C        	E40L	EQU	$-E40-1
 7228   6CDD   0E          	E44:	db	E44L
 7229   6CDE   50 61 74 68 20 		db	"Path not found"
        6CE3   6E 6F 74 20 66 
        6CE8   6F 75 6E 64 
 7230          000E        	E44L:	EQU	$-E44-1
 7231   6CEC   10          	E45:	db	E45L
 7232   6CED   56 6F 6C 75 6D 		db	"Volume not found"
        6CF2   65 20 6E 6F 74 
        6CF7   20 66 6F 75 6E 
        6CFC   64 
 7233          0010        	E45L	EQU	$-E45-1
 7234   6CFD   0E          	E46:	db	E46L
 7235   6CFE   46 69 6C 65 20 		db	"File Not Found"
        6D03   4E 6F 74 20 46 
        6D08   6F 75 6E 64 
 7236          000E        	E46L	EQU	$-E46-1
 7237   6D0C   09          	E48:	db	E48L
 7238   6D0D   44 69 73 6B 20 		db	"Disk Full"
        6D12   46 75 6C 6C 
 7239          0009        	E48L	EQU	$-E48-1
 7240   6D16   21          	E49:    db      E49L
 7241   6D17   4C 61 6E 65 44 	        db      "LaneDOS limit: 12 files/directory"
        6D1C   4F 53 20 6C 69 
        6D21   6D 69 74 3A 20 
        6D26   31 32 20 66 69 
        6D2B   6C 65 73 2F 64 
        6D30   69 72 65 63 74 
        6D35   6F 72 79 
 7242          0021        	E49L    EQU     $-E49-1
 7243   6D38   26          	E4E:    db      E4EL
 7244   6D39   4C 61 6E 65 44 	        db      "LaneDOS limit: No writes to TREE files"
        6D3E   4F 53 20 6C 69 
        6D43   6D 69 74 3A 20 
        6D48   4E 6F 20 77 72 
        6D4D   69 74 65 73 20 
  Wed Jun  7 1989 12:04                                                                                                  Page  109

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6D52   74 6F 20 54 52 
        6D57   45 45 20 66 69 
        6D5C   6C 65 73 
 7245          0026        	E4EL    EQU     $-E4E-1
 7246   6D5F   0E          	E4C:	db	E4CL
 7247   6D60   55 6E 65 78 70 		db	"Unexpected EOF"
        6D65   65 63 74 65 64 
        6D6A   20 45 4F 46 
 7248          000E        	E4CL	EQU	$-E4C-1
 7249                      	
 7250   6D6E   27          	ELIST:	db	$27
 7251   6D6F   AC6C        		dw	E27
 7252   6D71   2B          		db	$2B
 7253   6D72   BB6C        		dw	E2B
 7254   6D74   40          		db	$40
 7255   6D75   D06C        		dw	E40
 7256   6D77   44          		db	$44
 7257   6D78   DD6C        		dw	E44
 7258   6D7A   45          		db	$45
 7259   6D7B   EC6C        		dw	E45
 7260   6D7D   46          		db	$46
 7261   6D7E   FD6C        		dw	E46
 7262   6D80   48          		db	$48
 7263   6D81   0C6D        		dw	E48
 7264   6D83   49          	        db      $49
 7265   6D84   166D        	        dw      E49
 7266   6D86   4C          		db	$4C
 7267   6D87   5F6D        		dw	E4C
 7268   6D89   4E          	        db      $4E
 7269   6D8A   386D        	        dw      E4E
 7270          001B        	ELISTL	EQU	$-ELIST-3	; mark last error code
 7271                      	
 7272   6D8C               		END
 7273                      	
 7274   6D8C               		INCLUDE		WINDOWS.ASM
 7275                      	
 7276   6D8C               		STTL	"--- WINDOW OPERATIONS ---"
 7277                      		PAGE
  Wed Jun  7 1989 12:04                                                                                                  Page  110

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7278                      	;
 7279                      	; these are the data structures for all 8 WINDOW.  They are identical and
 7280                      	; are just seperated cuz I use the addresses in the table that follows.
 7281                      	;	All numbers are inclusive, absolute, and zero-based.
 7282                      	;
 7283          0000        	WINDSTRUCT	EQU	0
 7284          0000        	WINTOP 		EQU	WINDSTRUCT	; first line of the window
 7285          0001        	WINLEFT 	EQU	WINTOP+1	; left edge of the window
 7286          0002        	WINHGHT		EQU	WINLEFT+1	; height of the window
 7287          0003        	WINWID		EQU	WINHGHT+1	; width of the window, in pixels
 7288          0004        	WINY		EQU	WINWID+1	; y pos of cursor (pos, not relative)
 7289          0005        	WINX		EQU	WINY+1		; x pos of cursor (remember, ABSOLUTE)
 7290          0006        	WINLM		EQU	WINX+1		; left margin
 7291          0007        	WINRM		EQU	WINLM+1		; right margin
 7292          0008        	WINCRF		EQU	WINRM+1		; (WORD) <CR> function
 7293          000A        	WINCRC		EQU	WINCRF+2	; (WORD) <CR> counter
 7294          000C        	WINHIGHL	EQU	WINCRC+2	; highlight mode
 7295          000D        	WINFORE		EQU	WINHIGHL+1	; foreground color (0=black-7=white)
 7296          000E        	WINBGND		EQU	WINFORE+1	; background color (0=black-7=white)
 7297          000F        	WINFONT		EQU	WINBGND+1	; window font (0=normal/4=monospaced)
 7298          0010        	WINFSIZE	EQU	WINFONT+1	; (WORD) font Height/Width
 7299          0012        	WINATR		EQU	WINFSIZE+2	; Window Attributes
 7300          0013        	WINLCNT		EQU	WINATR+1	; current number of lines
 7301                      	;
 7302                      	; these are my interesting things
 7303                      	;
 7304          0014        	WINXSZ		EQU	WINLCNT+1	; width of window, in pixels, using margin
 7305          0015        	WINLLEN		EQU	WINXSZ+1	; length of current line
 7306          0017        	WINLINES	EQU	WINLLEN+2	; max # of lines for window
 7307                      	
 7308   6D8C               	WINDOW0:
 7309   6D8C   00          		DB	0		; WINTOP - first line of the window
 7310   6D8D   00          		DB	0		; WINLEFT - left edge of the window
 7311   6D8E   C0          		DB	MAXHEIGHT	; WINHGHT - height of window
 7312   6D8F   8C          		DB	MAXWIDTH	; WINWID - width of window
 7313   6D90   00          		DB	0		; WINY - y pos of cursor (pos, not relative)
 7314   6D91   00          		DB	0		; WINX - x pos of cursor (remember, ABSOLUTE)
 7315   6D92   00          		DB	0		; WINLM - left margin
 7316   6D93   00          		DB	0		; WINRM - right margin
 7317   6D94   0000        		DW	0		; WINCRF - <CR> function
 7318   6D96   0000        		DW	0		; WINCRC - <CR> counter
 7319   6D98   00          		DB	0		; WINHIGHL - Highlights
 7320   6D99   0F          		DB	$f		; WINFORE - foreground color default of white
 7321   6D9A   00          		DB	0		; WINBGND - background color
 7322   6D9B   00          		DB	0		; WINFONT - window font (0=normal/1=alternate)
 7323   6D9C   02 09       		DB	2,FONT_H	; WINFSIZE - Width/Height
 7324   6D9E   0F          		DB	$0f		; WINATR - all attributes on for window 0
 7325   6D9F   00          		DB	0		; WINLCNT - current number of lines
 7326   6DA0   8C          		DB	MAXWIDTH	; WINXSZ - width of window, in pixels, using margin
 7327   6DA1   00 00       		DB	0,0		; WINLLEN - length of current line
 7328   6DA3   14          		DB	(MAXHEIGHT/FONT_H)-1 ; WINLINES - max # of lines for window
 7329                      	;
 7330                      	; same start as window 0, but with 0 length
 7331                      	;
 7332   6DA4               	WINDOW1:
 7333   6DA4   00 00 00 8C 00 		DB	0,0,0,MAXWIDTH,0,0,0,0,0,0,0,0,0
        6DA9   00 00 00 00 00 
        6DAE   00 00 00 
 7334   6DB1   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,MAXWIDTH,0,0,0
        6DB6   08 00 8C 00 00 
        6DBB   00 
 7335                      	;
 7336                      	; the rest have no width/height/attributes (except buffering)
 7337                      	;
 7338   6DBC               	WINDOW2:
 7339   6DBC   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6DC1   00 00 00 00 00 
        6DC6   00 00 00 
 7340   6DC9   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6DCE   08 00 00 00 00 
        6DD3   00 
 7341   6DD4               	WINDOW3:
 7342   6DD4   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6DD9   00 00 00 00 00 
        6DDE   00 00 00 
  Wed Jun  7 1989 12:04                                                                                                  Page  111

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7343   6DE1   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6DE6   08 00 00 00 00 
        6DEB   00 
 7344   6DEC               	WINDOW4:
 7345   6DEC   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6DF1   00 00 00 00 00 
        6DF6   00 00 00 
 7346   6DF9   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6DFE   08 00 00 00 00 
        6E03   00 
 7347   6E04               	WINDOW5:
 7348   6E04   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6E09   00 00 00 00 00 
        6E0E   00 00 00 
 7349   6E11   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6E16   08 00 00 00 00 
        6E1B   00 
 7350   6E1C               	WINDOW6:
 7351   6E1C   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6E21   00 00 00 00 00 
        6E26   00 00 00 
 7352   6E29   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6E2E   08 00 00 00 00 
        6E33   00 
 7353   6E34               	WINDOW7:
 7354   6E34   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6E39   00 00 00 00 00 
        6E3E   00 00 00 
 7355   6E41   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6E46   08 00 00 00 00 
        6E4B   00 
 7356                      	
 7357   6E4C               	WINTABLE:
 7358   6E4C   8C6D A46D BC6D 		DW	WINDOW0,WINDOW1,WINDOW2,WINDOW3
        6E52   D46D 
 7359   6E54   EC6D 046E 1C6E 		DW	WINDOW4,WINDOW5,WINDOW6,WINDOW7
        6E5A   346E 
 7360                      		PAGE
  Wed Jun  7 1989 12:04                                                                                                  Page  112

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7361                      	
 7362                      	; ------
 7363                      	; SCREEN
 7364                      	; ------
 7365                      	; Move to the screen specified, by updating CURWIN and the cursor
 7366                      	; X,Y pos (SCRX,SCRY).  Also put address of that window's structure
 7367                      	; in WINDOW. Save a bunch of the old stuff in old window's structure then
 7368                      	; update the same bunch with the new window's stuff.
 7369                      	;
 7370                      	;	ARG1 - new screen id: 0-7
 7371                      	;
 7372   6E5C               	ZSCRN:
 7373   6E5C   20 B5 55    		jsr	CLRBUF		; EMPTY OUTPUT BUFFER BEFORE MOVING
 7374                      	;
 7375                      	; now, save a few things from the common variables
 7376                      	;
 7377   6E5F   A0 15       		ldy	#WINLLEN	; current line length
 7378   6E61   A5 A7       		lda	LENGTH+LO	; get current line length
 7379   6E63   91 05       		sta	(WINDOW),Y	; save for later referencing
 7380   6E65   C8          		iny			; point to msb
 7381   6E66   A5 A8       		lda	LENGTH+HI	; get MSB
 7382   6E68   91 05       		sta	(WINDOW),Y	; saved
 7383   6E6A   20 9F 4D    		jsr	SAVE_CURSOR	; save the x,y pos of cursor
 7384   6E6D   A5 BB       		lda	INVFLG		; get inverse flag
 7385   6E6F   F0 04       		beq	ZSCA1		; not set
 7386   6E71   A9 01       		lda	#1		; set 1 bit
 7387   6E73   D0 06       		bne	ZSCA2		; set in window
 7388   6E75               	ZSCA1:
 7389   6E75   A5 BA       		lda	UNDFLG		; how about underlining
 7390   6E77   F0 02       		beq	ZSCA2		; nope
 7391   6E79   A9 04       		lda	#4		; 4 == underlining
 7392   6E7B               	ZSCA2:
 7393   6E7B   A0 0C       		ldy	#WINHIGHL	; set new highlight
 7394   6E7D   91 05       		sta	(WINDOW),Y	; save current attributes
 7395                      	;
 7396                      	; now it is time to update for new screen
 7397                      	;
 7398   6E7F   A5 63       		lda	ARG1+LO		; get which window
 7399   6E81   85 A6       		sta	CURWIN		; save window number
 7400   6E83   0A          		asl	A		; shift to make word indes
 7401   6E84   AA          		tax			; swap to indexing reg
 7402   6E85   BD 4C 6E    		lda	WINTABLE,X	; get the address of the new WINDOW
 7403   6E88   85 05       		sta	WINDOW+LO	; lo part comes first
 7404   6E8A   BD 4D 6E    		lda	WINTABLE+1,X	; so go get hi part
 7405   6E8D   85 06       		sta	WINDOW+HI	; save the hi part of the address
 7406                      	
 7407   6E8F   20 B1 4D    		jsr	GET_CURSOR	; restore the cursor pos
 7408                      	
 7409   6E92   A0 14       		ldy	#WINXSZ		; get line length
 7410   6E94   B1 05       		lda	(WINDOW),Y	; update zero page variable
 7411   6E96   85 A2       		sta	XSIZE+LO	; this is for quicky comparing
 7412   6E98   A9 00       		lda	#0		; clear MSB
 7413   6E9A   85 A3       		sta	XSIZE+HI
 7414   6E9C   06 A2       		asl	XSIZE+LO	; *2
 7415   6E9E   26 A3       		rol	XSIZE+HI
 7416   6EA0   06 A2       		asl	XSIZE+LO	; *4
 7417   6EA2   26 A3       		rol	XSIZE+HI
 7418   6EA4   A0 15       		ldy	#WINLLEN	; get current line length
 7419   6EA6   B1 05       		lda	(WINDOW),Y	; from before
 7420   6EA8   85 A7       		sta	LENGTH+LO	; save for later checking
 7421   6EAA   C8          		iny
 7422   6EAB   B1 05       		lda	(WINDOW),Y
 7423   6EAD   85 A8       		sta	LENGTH+HI
 7424   6EAF   A0 13       		ldy	#WINLCNT	; how many lines already out there
 7425   6EB1   B1 05       		lda	(WINDOW),Y	; has been already saved
 7426   6EB3   85 AB       		sta	LINCNT		; and save 'ere too
 7427   6EB5   A0 17       		ldy	#WINLINES	; how many lines in this
 7428   6EB7   B1 05       		lda	(WINDOW),Y	; window, anyway?
 7429   6EB9   85 03       		sta	MAXLINES	; show for everyone to see
 7430   6EBB   A0 01       		ldy	#WINLEFT	; show left margin
 7431   6EBD   B1 05       		lda	(WINDOW),Y	; get left edge
 7432   6EBF   A0 06       		ldy	#WINLM		; left margin
 7433   6EC1   18          		clc			; adding
 7434   6EC2   71 05       		adc	(WINDOW),Y	; to find new left margin
 7435   6EC4   85 04       		sta	LEFTMRG		; set up left margin for ease of use
  Wed Jun  7 1989 12:04                                                                                                  Page  113

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7436   6EC6   A0 00       		ldy	#WINTOP		; get top of window
 7437   6EC8   B1 05       		lda	(WINDOW),Y	; got it
 7438   6ECA   18          		clc			; adding
 7439   6ECB   A0 02       		ldy	#WINHGHT	; add height
 7440   6ECD   71 05       		adc	(WINDOW),Y	; did it
 7441   6ECF   85 02       		sta	SCRBTM		; this is first line outside window
 7442   6ED1   A0 0C       		ldy	#WINHIGHL	; get highlighting modes
 7443   6ED3   B1 05       		lda	(WINDOW),Y	; first for inverse video
 7444   6ED5   29 01       		and	#1		; check for inverse video
 7445   6ED7   F0 02       		beq	SCRINV		; nope
 7446   6ED9   A9 80       		lda	#$80		; means inverse video
 7447   6EDB               	SCRINV:
 7448   6EDB   85 BB       		sta	INVFLG		; there it be
 7449   6EDD   B1 05       		lda	(WINDOW),Y	; point to underline flag
 7450   6EDF   29 04       		and	#4		; check for underlining
 7451   6EE1   F0 02       		beq	SCRUND		; nope
 7452   6EE3   A9 80       		lda	#$80		; means underlining
 7453   6EE5               	SCRUND:
 7454   6EE5   85 BA       		sta	UNDFLG		; save for everyone
 7455                      	
 7456   6EE7   A0 12       		ldy	#WINATR		; get the current attributes
 7457   6EE9   B1 05       		lda	(WINDOW),Y	; gottem
 7458   6EEB   20 6D 70    		jsr	SET_ATTRIBUTES	; set the flags, thank you
 7459   6EEE   A0 0F       		ldy	#WINFONT	; get the font
 7460   6EF0   B1 05       		lda	(WINDOW),Y	; thank you
 7461   6EF2   F0 02       		beq	SCRFNT0		; is it font zero?
 7462   6EF4   A9 0C       		lda	#MONOFONT_W	; must be mono font, set width
 7463   6EF6               	SCRFNT0:
 7464   6EF6   85 C1       		sta	FONTFLG		; mark normal font
 7465   6EF8               	ZSCREX:
 7466   6EF8   60          		rts
 7467                      	;--------------
 7468                      	; ZWINPOS
 7469                      	;--------------
 7470                      	;
 7471                      	; change the window ARG1's top left corner to the new position
 7472                      	;
 7473                      	; ARG1 - window id from 0-7
 7474                      	; ARG2 - new top y pos
 7475                      	; ARG3 - new top x pos
 7476                      	;
 7477   6EF9               	ZWINPOS:
 7478   6EF9   C6 65       		dec	ARG2+LO		; make pos be zero based
 7479   6EFB   C6 67       		dec	ARG3+LO		; now they are!
 7480                      	; 
 7481                      	; if moving current window, save current cursor pos
 7482                      	;
 7483   6EFD               	ZWPOS0:
 7484   6EFD   20 9F 4D    		jsr	SAVE_CURSOR	; saving
 7485                      	;
 7486                      	; let's set up [J] to point to window we are talking about
 7487                      	;
 7488   6F00               	ZWPOS1:
 7489   6F00   A5 63       		lda	ARG1+LO		; get window ID 
 7490   6F02   20 7F 57    		jsr	SETWJ		; get J to point to it
 7491                      	
 7492   6F05   A5 65       	        lda     ARG2+LO         ; first, check the top
 7493   6F07   C9 C0       	        cmp     #MAXHEIGHT      ; < max height?
 7494   6F09   90 04       	        bcc     CKWA1           ; fine
 7495   6F0B   A9 00       	        lda     #0              ; make it zero then        
 7496   6F0D   85 65       	        sta     ARG2+LO         ; it is now
 7497   6F0F               	CKWA1:
 7498   6F0F   A5 67       	        lda     ARG3+LO         ; now check left edge
 7499   6F11   C9 8C       	        cmp     #MAXWIDTH       ; howzit compare
 7500   6F13   90 04       	        bcc     CKWA2           ; just fine
 7501   6F15   A9 00       	        lda     #0              ; this too
 7502   6F17   85 67       	        sta     ARG3+LO         ; it is now
 7503   6F19               	CKWA2:
 7504                      	;
 7505                      	; make the cursor pos be relative, so we can change back to
 7506                      	; absolute using new window pos
 7507                      	;
 7508   6F19   A0 04       		ldy	#WINY		; let's do y pos first
 7509   6F1B   B1 7A       		lda	(J),Y		; get the old y pos
 7510   6F1D   A0 00       		ldy	#WINTOP		; and subtract the top to make
  Wed Jun  7 1989 12:04                                                                                                  Page  114

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7511   6F1F   38          		sec			; (getting ready)
 7512   6F20   F1 7A       		sbc	(J),Y		; the pos relative
 7513   6F22   18          		clc			; now add in new top
 7514   6F23   65 65       		adc	ARG2+LO		; this will be new top
 7515   6F25   A0 04       		ldy	#WINY		; get y offset again
 7516   6F27   91 7A       		sta	(J),Y		; and save new absolute y pos
 7517   6F29   A0 05       	  	ldy	#WINX		; now we be talking about x pos
 7518   6F2B   B1 7A       		lda	(J),Y		; get old x pos
 7519   6F2D   38          		sec			; getting ready for sub
 7520   6F2E   A0 01       		ldy	#WINLEFT	; get rid of left ness
 7521   6F30   F1 7A       		sbc	(J),Y		; now it's relative
 7522   6F32   18          		clc			; get ready to add in new left ness
 7523   6F33   65 67       		adc	ARG3+LO		; done
 7524   6F35   A0 05       		ldy	#WINX		; get x offset again
 7525   6F37   91 7A       		sta	(J),Y		; save in structure
 7526                      	;
 7527                      	; now we can change the top and left of the window
 7528                      	;
 7529   6F39   A5 65       		lda	ARG2+LO		; this is top of window
 7530   6F3B   A0 00       		ldy	#WINTOP		; TOP offset
 7531   6F3D   91 7A       		sta	(J),Y		; save the new top
 7532   6F3F   A5 67       		lda	ARG3+LO		; here is the left edge
 7533   6F41   A0 01       		ldy	#WINLEFT	; offset into struct
 7534   6F43   91 7A       		sta	(J),Y		; saved !
 7535                      	;
 7536                      	; we might have moved current window so update screen cursor and left margin
 7537                      	;
 7538   6F45   20 B1 4D    		jsr	GET_CURSOR	; restore cursor
 7539   6F48   A0 01       		ldy	#WINLEFT	; get left edge
 7540   6F4A   B1 05       		lda	(WINDOW),Y	; okay
 7541   6F4C   A0 06       		ldy	#WINLM		; add in left margin
 7542   6F4E   18          		clc			; adding
 7543   6F4F   71 05       		adc	(WINDOW),Y	; to find new left edge
 7544   6F51   85 04       		sta	LEFTMRG		; store for ease of use
 7545   6F53   A0 14       		ldy	#WINXSZ		; get xsize
 7546   6F55   B1 7A       		lda	(J),Y		; okay
 7547   6F57   85 A2       		sta	XSIZE+LO	; this is for quicky comparing
 7548   6F59   A9 00       		lda	#0		; clear MSB
 7549   6F5B   85 A3       		sta	XSIZE+HI
 7550   6F5D   06 A2       		asl	XSIZE+LO	; *2
 7551   6F5F   26 A3       		rol	XSIZE+HI
 7552   6F61   06 A2       		asl	XSIZE+LO	; *4
 7553   6F63   26 A3       		rol	XSIZE+HI
 7554   6F65               	ZWPOSX:
 7555   6F65   60          		rts
 7556                      	;------------
 7557                      	; ZWINSIZE
 7558                      	;------------
 7559                      	;
 7560                      	; Change the size of window ARG1.  If cursor is outside of window,
 7561                      	; move to it.
 7562                      	;
 7563                      	;	ARG1 - window ID
 7564                      	; 	ARG2 - height
 7565                      	;	ARG3 - width
 7566                      	;
 7567                      	; Uses [J].
 7568                      	;
 7569   6F66               	ZWINSIZE:
 7570                      	;
 7571                      	; first put SCRCX,CY into window structure, just in case
 7572                      	;
 7573   6F66   20 9F 4D    		jsr	SAVE_CURSOR	; saved
 7574                      	;
 7575                      	; now do everything
 7576                      	;
 7577   6F69   A5 63       		lda	ARG1+LO		; get the window ID
 7578   6F6B   20 7F 57    		jsr	SETWJ		; and get window pointer
 7579                      	
 7580   6F6E   A5 65       	        lda     ARG2+LO         ; first, check the top
 7581   6F70   C9 C0       	        cmp     #MAXHEIGHT      ; < max height?
 7582   6F72   90 04       	        bcc     CKWA11          ; fine
 7583   6F74   A9 C0       	        lda     #MAXHEIGHT      ; make better
 7584   6F76   85 65       	        sta     ARG2+LO         ; it is now
 7585   6F78               	CKWA11:
  Wed Jun  7 1989 12:04                                                                                                  Page  115

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7586   6F78   A5 67       	        lda     ARG3+LO         ; now check left edge
 7587   6F7A   C9 8C       	        cmp     #MAXWIDTH       ; howzit compare
 7588   6F7C   90 04       	        bcc     CKWA21          ; just fine
 7589   6F7E   A9 8C       	        lda     #MAXWIDTH       ; make it the max
 7590   6F80   85 67       	        sta     ARG3+LO         ; it is now
 7591   6F82               	CKWA21:
 7592   6F82   A5 65       		lda	ARG2+LO		; get new height
 7593   6F84   A0 02       		ldy	#WINHGHT	; offset
 7594   6F86   91 7A       		sta	(J),Y		; save new height
 7595   6F88   A5 67       		lda	ARG3+LO		; get width
 7596   6F8A   A0 03       		ldy	#WINWID		; store width
 7597   6F8C   91 7A       		sta	(J),Y		; okay
 7598                      	;
 7599                      	; now we need to figger out new XSIZE, MAXLINES
 7600                      	;
 7601   6F8E   A0 03       		ldy	#WINWID		; store width
 7602   6F90   B1 7A       		lda	(J),Y		; get width
 7603   6F92   38          		sec			; have width, subtract margins
 7604   6F93   A0 07       		ldy	#WINRM		; first right margin
 7605   6F95   F1 7A       		sbc	(J),Y		; subtracted right margin
 7606   6F97   A0 06       		ldy	#WINLM		; and now for the left margin
 7607   6F99   F1 7A       		sbc	(J),Y		; now we have new XSIZE
 7608   6F9B   A0 14       		ldy	#WINXSZ		; get offset
 7609   6F9D   91 7A       		sta	(J),Y		; save for later ref
 7610   6F9F   A5 65       		lda	ARG2+LO		; get new height
 7611   6FA1   A2 FF       		ldx	#$FF		; this is the counter
 7612   6FA3   38          		sec			; get ready for subs
 7613   6FA4               	ZWSZ1:
 7614   6FA4   E8          		inx			; count this line
 7615   6FA5   E9 09       		sbc	#FONT_H		; subtract off font height	
 7616   6FA7   B0 FB       		bcs	ZWSZ1		; still some lines	
 7617   6FA9   CA          		dex			; to keep the input line on screen
 7618   6FAA   8A          		txa			; get line count for storage
 7619   6FAB   A0 17       		ldy	#WINLINES	; this is how many lines are allowed
 7620   6FAD   91 7A       		sta	(J),Y		; saved
 7621                      	;
 7622                      	; check to make sure the cursor is still in the window
 7623                      	;
 7624   6FAF   A0 06       		ldy	#WINLM		; get left margin
 7625   6FB1   18          		clc			; for adding
 7626   6FB2   71 7A       		adc	(J),Y		; for figgering out right edge
 7627   6FB4   A0 01       		ldy	#WINLEFT	; add in left edge
 7628   6FB6   71 7A       		adc	(J),Y		; get right column by adding in left one
 7629   6FB8   A0 05       		ldy	#WINX		; check X pos
 7630   6FBA   D1 7A       		cmp	(J),Y		; see if X is still inside?
 7631   6FBC   F0 13       		beq	ZWSZ2		; must move to top left
 7632   6FBE   90 11       		bcc	ZWSZ2		; ditto if X >= margin
 7633   6FC0   A0 00       		ldy	#WINTOP		; get top to figger last line
 7634   6FC2   B1 7A       		lda	(J),Y		; from the structure
 7635   6FC4   A0 02       		ldy	#WINHGHT	; and add in the height
 7636   6FC6   18          		clc			; getting ready for add
 7637   6FC7   71 7A       		adc	(J),Y		; to find first line outside of range
 7638   6FC9   A0 04       		ldy	#WINY		; now check y
 7639   6FCB   D1 7A       		cmp	(J),Y		; now check y then
 7640   6FCD   F0 02       		beq	ZWSZ2		; outside, move to top left
 7641   6FCF   B0 15       		bcs	ZWSZ3		; inside so quit
 7642                      	;
 7643                      	; move the cursor to top left if outside of resized window
 7644                      	;
 7645   6FD1               	ZWSZ2:
 7646   6FD1   A0 00       		ldy	#WINTOP		; top line is here
 7647   6FD3   B1 7A       		lda	(J),Y		; so get me it
 7648   6FD5   A0 04       		ldy	#WINY		; now we be doing y
 7649   6FD7   91 7A       		sta	(J),Y		; change Y
 7650   6FD9   A0 01       		ldy	#WINLEFT	; move X to left margin
 7651   6FDB   B1 7A       		lda	(J),Y		; first get left edge
 7652   6FDD   A0 06       		ldy	#WINLM		; and add in left margin
 7653   6FDF   18          		clc			; (adding)
 7654   6FE0   71 7A       		adc	(J),Y		; to get left spot of cursor
 7655   6FE2   A0 05       		ldy	#WINX		; this is x offset
 7656   6FE4   91 7A       		sta	(J),Y		; so move X there
 7657                      	;
 7658                      	; now check to see if we mucked with current window
 7659                      	;
 7660   6FE6               	ZWSZ3:
  Wed Jun  7 1989 12:04                                                                                                  Page  116

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7661   6FE6   A5 64       		lda	ARG1+HI		; this is the id
 7662   6FE8   30 04       		bmi	ZWSZ4		; must be current window
 7663   6FEA   C5 A6       		cmp	CURWIN		; is it current window?
 7664   6FEC   D0 1B       		bne	ZWSZX		; nope, so done
 7665   6FEE               	ZWSZ4:
 7666   6FEE   A0 17       		ldy	#WINLINES	; get how many lines
 7667   6FF0   B1 7A       		lda	(J),Y		; get number of lines
 7668   6FF2   85 03       		sta	MAXLINES	; set global
 7669   6FF4   A0 14       		ldy	#WINXSZ		; get new XSIZE too
 7670   6FF6   B1 7A       		lda	(J),Y		; get it
 7671   6FF8   85 A2       		sta	XSIZE+LO	; this is for quicky comparing
 7672   6FFA   A9 00       		lda	#0		; clear MSB
 7673   6FFC   85 A3       		sta	XSIZE+HI
 7674   6FFE   06 A2       		asl	XSIZE+LO	; *2
 7675   7000   26 A3       		rol	XSIZE+HI
 7676   7002   06 A2       		asl	XSIZE+LO	; *4
 7677   7004   26 A3       		rol	XSIZE+HI
 7678   7006   20 B1 4D    		jsr	GET_CURSOR	; fix the cursor pos
 7679   7009               	ZWSZX:
 7680   7009   60          		rts
 7681                      	;
 7682                      	;CHECK_WIN_ARGS
 7683                      	; check args to make sure they be okay
 7684                      	;
 7685                      	;  ARG2 = top/height
 7686                      	;  ARG3 = right/width
 7687                      	;
 7688   700A               	CHECK_WIN_ARGS:
 7689   700A   60          	        rts
 7690                      	
 7691                      		; ------
 7692                      		; HLIGHT
 7693                      		; ------
 7694                      	
 7695   700B               	ZLIGHT:
 7696   700B   A5 63       		lda	ARG1+LO		; get argument
 7697   700D   C9 10       		cmp	#$10		; must be <= 8
 7698   700F   B0 05       		bcs	ZLIEX		; nope it aint
 7699   7011   09 80       	 	ora	#$80		; turn on hi bit
 7700   7013   20 06 53    		jsr	COUT		; send it out then
 7701   7016               	ZLIEX:
 7702   7016   60          		rts			; done
 7703                      	;
 7704                      	; actually set the highlight flags according to [A]
 7705                      	;	
 7706   7017               	HLIGHT:
 7707                      	;
 7708                      	; TURN OFF ALL HIGHLIGHTS
 7709                      	;	
 7710   7017   29 7F       		and	#$7F		; turn off high bit
 7711   7019   D0 05       		bne	ZL1		; nope, must be something
 7712   701B   85 BA       		sta	UNDFLG		; and turn of underlining flag
 7713   701D   85 BB       		sta	INVFLG		; and inverse
 7714   701F   60          		rts			; all done
 7715   7020               	ZL1:
 7716   7020   C9 04       		cmp	#4		; underlining
 7717   7022   D0 05       		bne	ZL_REV		; maybe its INVERSE?
 7718                      	
 7719   7024   A9 80       		lda	#$80		; turn on UNDFLG
 7720   7026   85 BA       		sta	UNDFLG		; with an FF
 7721   7028   60          		rts			; done
 7722   7029               	ZL_REV:	
 7723   7029   C9 01       		cmp	#1		; INVERSE?
 7724   702B   D0 05       		bne	ZL_MONO		; maybe monospaced then
 7725   702D   A9 80       		lda	#$80		; must be inverse video
 7726   702F   85 BB       		sta	INVFLG		; and put it in invflg
 7727   7031   60          		rts
 7728   7032               	ZL_MONO:
 7729   7032   60          		rts			; fuck it for now!	
 7730                      	;
 7731                      	; ZWINATTER - change the scrolling/buffering/scripting/wrapping attributes
 7732                      	; of the window.
 7733                      	;
 7734                      	; ARG1 - window id
 7735                      	; ARG2 - interesting bits
  Wed Jun  7 1989 12:04                                                                                                  Page  117

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7736                      	;	| buffering | scripting | scrolling | wrapping |
 7737                      	; ARG3 - operation - 	0 MOVE
 7738                      	;		  	1 SET
 7739                      	;			2 CLEAR
 7740                      	;			3 COMPLEMENT
 7741                      	;
 7742   7033               	ZWINATTR:
 7743   7033   A5 62       		lda	NARGS		; see how many args
 7744   7035   C9 03       		cmp	#3		; check for operation args
 7745   7037   F0 04       		beq	ZWAT1		; yes, already there
 7746   7039   A9 00       		lda	#0		; zero means MOVE
 7747   703B   85 67       		sta	ARG3+LO		; so show it as default
 7748   703D               	ZWAT1:
 7749   703D   A5 63       		lda	ARG1+LO		; get window ID
 7750   703F   20 7F 57    		jsr	SETWJ		; put window address into [J]
 7751                      	
 7752   7042   A0 12       		ldy	#WINATR		; get attribute offset
 7753   7044   B1 7A       		lda	(J),Y		; get current attribute
 7754   7046   18          		clc			; so we can just branch
 7755                      	
 7756   7047   C6 67       		dec	ARG3+LO		; decrement to find out what to do
 7757   7049   30 0A       		bmi	ZWMOVE		; do a move
 7758   704B   F0 0C       		beq	ZWSET		; do a set
 7759   704D   C6 67       		dec	ARG3+LO		; check once more
 7760   704F   F0 0C       		beq	ZWCLEAR		; clear set ones
 7761                      	;
 7762                      	; this is for the COMPLEMENT operations
 7763                      	;
 7764   7051   45 65       		eor	ARG2+LO		; complement bits
 7765   7053   90 0E       		bcc	ZWAT2		; done
 7766   7055               	ZWMOVE:
 7767                      	;
 7768                      	; move into the flag word
 7769                      	;
 7770   7055   A5 65       		lda	ARG2+LO		; get new flags
 7771   7057   90 0A       		bcc	ZWAT2		; done
 7772   7059               	ZWSET:
 7773                      	;
 7774                      	; set turned on ones
 7775                      	;
 7776   7059   05 65       		ora	ARG2+LO		; set'em up
 7777   705B   90 06       		bcc	ZWAT2		; done
 7778   705D               	ZWCLEAR:
 7779                      	;
 7780                      	; clear just the ones that are on
 7781                      	;
 7782   705D   A5 65       	        lda     ARG2+LO         ; get argument
 7783   705F   49 FF       	        eor     #$FF            ; turn on all the off ones
 7784   7061   31 7A       		and	(J),Y		; keep all the other ones
 7785   7063               	ZWAT2:
 7786   7063   91 7A       		sta	(J),Y		; and save it back
 7787                      	;
 7788                      	; now, if current window, set necessary flags
 7789                      	;
 7790   7065   A6 63       		ldx 	ARG1+LO		; get window ID
 7791   7067   30 04       	        bmi     SET_ATTRIBUTES  ; assume negative is current window
 7792   7069   E4 A6       		cpx	CURWIN		; is this the current one?
 7793   706B   D0 30       		bne	ZWATX		; nope, so leave
 7794   706D               	SET_ATTRIBUTES:
 7795                      	;
 7796                      	; current window, so set flags accordingly
 7797                      	;
 7798   706D   A2 00       		ldx	#0		; to turn off flag
 7799   706F   A0 01       		ldy	#1		; to turn on flag
 7800   7071   6A          		ror	A		; get wrapping flag into carry
 7801   7072   90 05       		bcc	ZWAT3		; clear it
 7802   7074   8C DB 71    		sty	WRPFLG		; set wrapping on
 7803   7077   B0 03       		bcs	ZWAT33		; okay
 7804   7079               	ZWAT3:
 7805   7079   8E DB 71    		stx	WRPFLG		; clear wrapping flag
 7806   707C               	ZWAT33:
 7807   707C   6A          		ror	A		; now check thes crolling flag
 7808   707D   90 05       		bcc	ZWAT4		; not set
 7809   707F   8C DC 71    		sty	SCRLFLG		; turn on scrolling flag
 7810   7082   B0 03       		bcs	ZWAT44		; okay, next please
  Wed Jun  7 1989 12:04                                                                                                  Page  118

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7811   7084               	ZWAT4:
 7812   7084   8E DC 71    		stx	SCRLFLG		; turn off scrolling
 7813   7087               	ZWAT44:
 7814   7087   6A          		ror	A		; checking the scripting flag
 7815   7088   90 05       		bcc	ZWAT5		; not set
 7816   708A   8C 79 6C    		sty	SCRIPTFLG	; allow scripting? yes
 7817   708D   B0 03       		bcs	ZWAT55		; next flag
 7818   708F               	ZWAT5:	
 7819   708F   8E 79 6C    		stx	SCRIPTFLG	; allow scripting? no
 7820   7092               	ZWAT55:
 7821   7092   6A          		ror	A		; this checks the buffering flag
 7822   7093   90 05       		bcc	ZWAT6		; not set
 7823   7095   8C DD 71    		sty	BUFFLG		; turn on buffering
 7824   7098   B0 03       		bcs	ZWATX		; scram
 7825   709A               	ZWAT6:
 7826   709A   8E DD 71    		stx	BUFFLG		; turn off buffering
 7827   709D               	ZWATX:
 7828   709D   60          		rts
 7829                      	;
 7830                      	; ZWINGET - put the window stuff into a table
 7831                      	;
 7832                      	;  ARG1 - Window id
 7833                      	;  ARG2 - offset
 7834                      	;
 7835   709E               	ZWINGET:
 7836   709E   20 9F 4D    		jsr	SAVE_CURSOR	; save x,y into structure
 7837                      	
 7838   70A1   A5 63       		lda	ARG1+LO		; get window ID
 7839   70A3   20 7F 57    		jsr	SETWJ		; set up window address
 7840                      	
 7841   70A6   A5 65       		lda	ARG2+LO		; get where to start getting
 7842   70A8   0A          		asl	A		; make word index
 7843   70A9   AA          		tax			; make index
 7844   70AA   BD 46 71    		lda	ZWGTBL+LO,X	; get lo part of address
 7845   70AD   85 7C       		sta	K+LO		; save for jumping
 7846   70AF   BD 47 71    		lda	ZWGTBL+HI,X	; get hi part
 7847   70B2   85 7D       		sta	K+HI		; saved
 7848   70B4   20 BE 70    		jsr	ZWGVEC		; do the vectoring
 7849   70B7   86 77       		stx	VALUE+HI	; save hi part
 7850   70B9   85 76       		sta	VALUE+LO	; and the lo part
 7851   70BB   4C E1 43    		jmp	PUTVAL		; and return it
 7852   70BE               	ZWGVEC:
 7853   70BE   6C 7C 00    		jmp	(K)		; and goto it boys
 7854   70C1               	ZWG0:
 7855   70C1   A2 00       		ldx	#0		; zero out high part
 7856   70C3   A0 00       		ldy	#WINTOP		; get window y pos
 7857   70C5   B1 7A       		lda	(J),Y		; got it
 7858   70C7   A8          		tay			; need to inc it
 7859   70C8   C8          		iny			; to make it a one-based number
 7860   70C9   98          		tya			; back to a
 7861   70CA   60          		rts
 7862   70CB               	ZWG1:
 7863   70CB   A2 00       		ldx	#0		; zero out high part
 7864   70CD   A0 01       		ldy	#WINLEFT	; get window x pos
 7865   70CF   B1 7A       		lda	(J),Y		; got it
 7866   70D1   A8          		tay			; need to inc it
 7867   70D2   C8          		iny			; to make it a one-based number
 7868   70D3   98          		tya			; back to a
 7869   70D4   60          		rts
 7870   70D5               	ZWG2:
 7871   70D5   A2 00       		ldx	#0		; zero out high part
 7872   70D7   A0 02       		ldy	#WINHGHT	; get window height
 7873   70D9   B1 7A       		lda	(J),Y		; got it
 7874   70DB   60          		rts
 7875   70DC               	ZWG3:
 7876   70DC   A2 00       		ldx	#0		; zero out high part
 7877   70DE   A0 03       		ldy	#WINWID		; window width
 7878   70E0   B1 7A       		lda	(J),Y		; got it
 7879   70E2   60          		rts
 7880   70E3               	ZWG4:
 7881   70E3   20 64 57    		jsr	FETCHCY		; get the current Y pos
 7882   70E6   A2 00       		ldx	#0		; zero out high part
 7883   70E8   60          		rts
 7884   70E9               	ZWG5:
 7885   70E9   20 71 57    		jsr	FETCHCX		; fetch the current X pos
  Wed Jun  7 1989 12:04                                                                                                  Page  119

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7886   70EC   A2 00       		ldx	#0		; zero out high part
 7887   70EE   60          		rts
 7888   70EF               	ZWG6:
 7889   70EF   A2 00       		ldx	#0		; zero out high part
 7890   70F1   A0 06       		ldy	#WINLM		; left margin
 7891   70F3   B1 7A       		lda	(J),Y		; got it
 7892   70F5   60          		rts
 7893   70F6               	ZWG7:
 7894   70F6   A2 00       		ldx	#0		; zero out high part
 7895   70F8   A0 07       		ldy	#WINRM		; right margin
 7896   70FA   B1 7A       		lda	(J),Y		; got it
 7897   70FC   60          		rts
 7898   70FD               	ZWG8:
 7899   70FD   A0 09       		ldy	#WINCRF+HI	; <CR> function
 7900   70FF   B1 7A       		lda	(J),Y		; got it, lo part
 7901   7101   AA          		tax			; save hi part
 7902   7102   88          		dey			; point to lo part
 7903   7103   B1 7A       		lda	(J),Y		; got lo part
 7904   7105   60          		rts
 7905   7106               	ZWG9:
 7906   7106   A0 0B       		ldy	#WINCRC+HI	; <CR> count
 7907   7108   B1 7A       		lda	(J),Y		; got it, hi part
 7908   710A   AA          		tax			; save it
 7909   710B   88          		dey			; now to lo part
 7910   710C   B1 7A       		lda 	(J),Y		; got it
 7911   710E   60          		rts
 7912   710F               	ZWG10:
 7913   710F   A0 0C       		ldy	#WINHIGHL	; get high light mode
 7914   7111   B1 7A       		lda	(J),Y		; got it
 7915   7113   A2 00       		ldx	#0		; zero out high part
 7916   7115   60          		rts
 7917   7116               	ZWG11:
 7918   7116   A0 0E       		ldy	#WINBGND	; and background
 7919   7118   B1 7A       		lda	(J),Y		; got it
 7920   711A   A8          	        tay                     ; make index
 7921   711B   B9 4C 6C    	        lda     APLCOLOR,Y      ; get apl->zip color
 7922   711E   AA          	        tax                     ; save for return
 7923   711F   A0 0D       		ldy	#WINFORE	; get foreground
 7924   7121   B1 7A       		lda	(J),Y		; got it
 7925   7123   A8          		tay			; save it
 7926   7124   B9 4C 6C    	        lda     APLCOLOR,Y      ; get apl->zip color
 7927   7127   60          		rts
 7928   7128               	ZWG12:
 7929   7128   A0 0F       		ldy	#WINFONT	; now for font id
 7930   712A   B1 7A       		lda	(J),Y		; got it
 7931   712C   A2 00       		ldx	#0		; zero out high part
 7932   712E   60          		rts
 7933   712F               	ZWG13:
 7934   712F   A0 11       		ldy	#WINFSIZE+1	; font size (width)
 7935   7131   B1 7A       		lda	(J),Y		; got it
 7936   7133   AA          		tax			; save it
 7937   7134   88          		dey			; font size (height)
 7938   7135   B1 7A       		lda	(J),Y		; got it
 7939   7137   60          		rts
 7940   7138               	ZWG14:
 7941   7138   A2 00       		ldx	#0		; zero out high part
 7942   713A   A0 12       		ldy	#WINATR		; attributes
 7943   713C   B1 7A       		lda	(J),Y		; got it
 7944   713E   60          		rts			; got them!
 7945   713F               	ZWG15:
 7946   713F   A2 00       		ldx	#0		; only 1 byte worth
 7947   7141   A0 13       		ldy	#WINLCNT	; offset
 7948   7143   B1 7A       		lda	(J),Y		; get more counter
 7949   7145   60          		rts
 7950                      	;
 7951                      	; jump table for figgering out where to start filling
 7952                      	;
 7953   7146               	ZWGTBL:
 7954   7146   C170 CB70 D570 		DW	ZWG0,ZWG1,ZWG2,ZWG3,ZWG4,ZWG5,ZWG6,ZWG7
        714C   DC70 E370 E970 
        7152   EF70 F670 
 7955   7156   FD70 0671 0F71 		DW	ZWG8,ZWG9,ZWG10,ZWG11,ZWG12,ZWG13,ZWG14,ZWG15
        715C   1671 2871 2F71 
        7162   3871 3F71 
 7956                      	;	
  Wed Jun  7 1989 12:04                                                                                                  Page  120

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7957                      	; ZSCROLL - scroll the specified window up or down
 7958                      	;
 7959                      	;  ARG1 - window ID
 7960                      	;  ARG2 - lines to scroll; <0 scrolls down
 7961                      	;
 7962   7166               	ZSCROLL:
 7963   7166   20 9F 4D    		jsr	SAVE_CURSOR	; save where cursor is
 7964                      	
 7965   7169   A9 00       	        lda     #0              ; don't script scroll
 7966   716B   85 AA       	        sta     SCRIPT          ; fine, we won't now
 7967                      	
 7968   716D   A5 63       		lda	ARG1+LO		; get which window
 7969   716F   20 7F 57    		jsr	SETWJ		; set up pointer
 7970   7172   C6 62       		dec	NARGS		; see what we have for lines
 7971   7174   D0 04       		bne	ZSCR1		; a passed arg
 7972   7176   A9 01       		lda	#1		; 1 line is default
 7973   7178   85 65       		sta	ARG2+LO		; so say so
 7974   717A               	ZSCR1:
 7975   717A   A0 00       		ldy	#WINTOP		; get me window limits
 7976   717C   B1 7A       		lda	(J),Y		; first top
 7977   717E   85 0B       		sta	CLSTOP		; save for usage
 7978   7180   C8          		iny			; now left
 7979   7181   B1 7A       		lda	(J),Y		; okay, get for this window
 7980   7183   85 0A       		sta	CLSLEFT		; save left
 7981   7185   C8          		iny			; now it's width
 7982   7186   B1 7A       		lda	(J),Y		; got the window height
 7983   7188   85 0D       		sta	CLSHEIGHT	; this is it
 7984   718A   C8          		iny			; this is height
 7985   718B   B1 7A       		lda	(J),Y		; get window's height
 7986   718D   85 0C       		sta	CLSWIDTH	; save
 7987   718F   A5 66       		lda	ARG2+HI		; is it negative?
 7988   7191   85 1D       		sta	SCLDIR		; show direction of scroll
 7989   7193   10 08       		bpl	ZSCRL1		; nope
 7990   7195   A6 65       		ldx	ARG2+LO		; get how many lines
 7991   7197   49 FF       		eor	#$FF		; make pos
 7992   7199   AA          		tax			; put in X for inc
 7993   719A   E8          		inx			; and make right
 7994   719B   D0 02       		bne	ZSCRLEX		; done
 7995   719D               	ZSCRL1:
 7996   719D   A6 65       		ldx	ARG2+LO		; get how many lines
 7997   719F               	ZSCRLEX:
 7998   719F   86 18       		stx	SCLLINES	; save for routine
 7999   71A1   20 08 60    		jsr	DO_SCROLL	; and do the scroll
 8000   71A4               	ZSCRLEX1:
 8001   71A4   A9 01       	        lda     #1              ; allow scripting
 8002   71A6   85 AA       	        sta     SCRIPT          ; we do
 8003   71A8   4C B1 4D    		jmp	GET_CURSOR	; restore the cursor, thank you
 8004                      	;
 8005                      	; ZWINPUT - put some information into window structure.  Just CRF/CRC
 8006                      	;	is legit now.
 8007                      	;
 8008                      	;  ARG1 - window ID
 8009                      	;  ARG2 - Word to be saved
 8010                      	;  ARG3 - offset of value
 8011                      	;
 8012   71AB               	ZWINPUT:
 8013   71AB   20 9F 4D    	        jsr     SAVE_CURSOR     ; save the cursor pos
 8014   71AE   A5 63       		lda	ARG1+LO		; get window ID
 8015   71B0   20 7F 57    		jsr	SETWJ		; have J point to structure
 8016                      	
 8017   71B3   A5 65       		lda	ARG2+LO		; get first value in table
 8018   71B5   C9 08       		cmp	#8		; 8 = <CR> function
 8019   71B7   F0 0D       		beq	ZWIPCRF		; so save that
 8020   71B9   C9 09       		cmp	#9		; this is counter
 8021   71BB   F0 0D       		beq	ZWIPCRC		; so set counter
 8022   71BD   C9 0F       	        cmp     #15             ; LINCNT?
 8023   71BF   F0 01       	        beq     ZIPLCT          ; then set it too
 8024   71C1   60          		rts			; just die then
 8025   71C2               	ZIPLCT:
 8026   71C2   A0 13       	        ldy     #WINLCNT        ; point to line count
 8027   71C4   D0 0B       	        bne     ZWINPUT2        ; and stash it away
 8028   71C6               	ZWIPCRF:
 8029   71C6   A0 09       	        ldy     #WINCRF+1       ; point to window's CR function
 8030   71C8   D0 02       	        bne     ZWINPUT1        ; and put it        
 8031   71CA               	ZWIPCRC:
  Wed Jun  7 1989 12:04                                                                                                  Page  121

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 8032   71CA   A0 0B       		ldy	#WINCRC+1	; point to window's CR counter
 8033   71CC               	ZWINPUT1:
 8034   71CC   A5 68       		lda	ARG3+HI		; now get hi part
 8035   71CE   91 7A       		sta	(J),Y		; saved!
 8036   71D0   88          	        dey                     ; point to lo part
 8037   71D1               	ZWINPUT2:
 8038   71D1   A5 67       		lda	ARG3+LO		; start with lo part
 8039   71D3   91 7A       		sta	(J),Y		; save lo part
 8040   71D5               	ZWIPLCT:
 8041   71D5   4C B1 4D    	        jmp     GET_CURSOR      ; restore cursor/lincnt        
 8042   71D8               		
 8043   71D8               		END
 8044                      	
 8045   71D8               		INCLUDE		DLINE.ASM
 8046   71D8               		STTL	"--- Display line Routine ---"
 8047                      		PAGE
  Wed Jun  7 1989 12:04                                                                                                  Page  122

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8048                      	;
 8049                      	; some aux mem zero page stuff
 8050                      	;
 8051   71D8               	DLVARS:
 8052          71D8        	CHR_X	EQU	DLVARS		; (WORD) X pos for char (0-559)
 8053          71DA        	ENDBIT	EQU	CHR_X+2 	; (BYTE) ending bit offset
 8054          71DB        	WRPFLG	EQU	ENDBIT+1	; wrapping flag
 8055          71DC        	SCRLFLG	EQU	WRPFLG+1	; scrolling flag
 8056          71DD        	BUFFLG	EQU	SCRLFLG+1	; buffering flag
 8057          71DE        	SAVEX	EQU	BUFFLG+1	; (BYTE) save original X
 8058          71DF        	CHR_Y	EQU	SAVEX+1		; (BYTE) Working cursor Y pos
 8059          71E0        	LINECHAR EQU	CHR_Y+1		; (BYTE) working char counter
 8060          71E1        	BITTER	EQU	LINECHAR+1	; (BYTE) bit twiddler counter
 8061          71E2        	INCFLG	EQU	BITTER+1	; (BYTE) ==1 if NEXT_SCR needed after setpos
 8062          71E3        	SHOW_CURSOR EQU	INCFLG+1	; (BYTE) flag as to whether we are doing cursor
 8063          71E4        	SCRCNT	EQU	SHOW_CURSOR+1	; (BYTE) screen buffer offset
 8064          71E5        	SV_UND	EQU	SCRCNT+1	; (BYTE) spot to save underline flag
 8065          71E6        	SV_INV	EQU	SV_UND+1	; (BYTE) save starting INVFLG
 8066          71E7        	UNDERF  EQU     SV_INV+1        ; (BYTE) underline flag used internally
 8067          71E8        	LINE_HEIGHT EQU	UNDERF+1	; (BYTE) counter for height
 8068          0011        	DLVARSL	EQU	LINE_HEIGHT-CHR_X+1
 8069                      	
 8070   71D8               		BLKB	DLVARSL,0
 8071                      	
 8072   71E9   07 06 05 04 03 	BIT_BITS: DB	7,6,5,4,3,2,1,0	; number significant bits in last byte
        71EE   02 01 00 
 8073                      	
 8074   71F1               	DISP_LINE:
 8075   71F1   AD E4 71    		lda	SCRCNT		; make sure there are characters
 8076   71F4   D0 01       		bne	DPL1		; ayyup
 8077   71F6   60          		rts			; no chars, don't do anything
 8078   71F7               	DPL1:
 8079   71F7   A9 00       		lda	#0		; start at zero
 8080   71F9   85 09       		sta	CC_OFF		; which byte to use
 8081   71FB   8D E2 71    		sta	INCFLG		; and clear out inc'er flag
 8082   71FE               		
 8083   71FE   A9 08       		lda	#FONT_H-1	; do for height of char
 8084   7200   8D E8 71    		sta	LINE_HEIGHT	; height counter
 8085                      	
 8086   7203   A4 01       		ldy	SCRCY		; and starting y
 8087   7205   8C DF 71    		sty	CHR_Y		; saved
 8088   7208   A4 00       		ldy	SCRCX		; save x to
 8089   720A   8C DE 71    		sty	SAVEX		; save it
 8090   720D   A5 BB       		lda	INVFLG		; get current state
 8091   720F   8D E6 71    		sta	SV_INV		; and save it
 8092   7212   A5 BA       	        lda     UNDFLG          ; get current underline state
 8093   7214   8D E5 71    	        sta     SV_UND          ; and save it too
 8094                      	
 8095   7217   AD 7C 6C    		lda	CURSFLG		; changed x pos?
 8096   721A   F0 12       	 	beq	DPL2		; no new figgering
 8097   721C   A2 00       		ldx	#0		
 8098   721E   8E D9 71    		stx	CHR_X+HI	; clear out msb
 8099                      	
 8100   7221   A5 00       		lda	SCRCX		; get new cursor x pos
 8101   7223   0A          		asl	A		; *2
 8102   7224   2E D9 71    		rol	CHR_X+HI
 8103   7227   0A          		asl	A		; *4
 8104   7228   8D D8 71    		sta	CHR_X+LO
 8105   722B   2E D9 71    		rol	CHR_X+HI
 8106   722E               	DPL2:
 8107   722E   AD D8 71    		lda	CHR_X+LO
 8108   7231   85 00       		sta	SCRCX
 8109   7233   29 03       		and	#3		; pick up 2 bits rolling out
 8110   7235   8D E1 71    		sta	BITTER		; what to add
 8111   7238   AD D9 71    		lda	CHR_X+HI
 8112   723B   4A          		lsr	A		; /2
 8113   723C   66 00       		ror	SCRCX
 8114   723E   4A          		lsr	A		; /4
 8115   723F   66 00       		ror	SCRCX
 8116   7241   20 51 5E    		jsr	SETPOS		; set up pointers
 8117                      	
 8118   7244   AD E1 71    		lda	BITTER		; get extra
 8119   7247   18          		clc			; add in
 8120   7248   65 11       		adc	BITOFF		; normal bit offset
 8121   724A   8D E1 71    		sta	BITTER		; and make it new one
  Wed Jun  7 1989 12:04                                                                                                  Page  123

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8122   724D   C9 07       		cmp	#7		; but can't be greater than 6
 8123   724F   90 08       		bcc	DO_LINE		; okay, it's not
 8124   7251   8D E2 71    		sta	INCFLG		; show needing NEXT_SCR call
 8125   7254   E9 07       		sbc	#7		; so shrink it
 8126   7256   8D E1 71    		sta	BITTER		; save it
 8127   7259               	DO_LINE:
 8128   7259   20 51 5E    		jsr	SETPOS		; set up pointers
 8129   725C   AD E2 71    		lda	INCFLG		; do we need to go one more?
 8130   725F   F0 03       		beq	DOL1		; nope
 8131   7261   20 F6 5D    		jsr	NEXT_SCR	; and point to next screen byte
 8132   7264               	DOL1:
 8133   7264   AE E1 71    	 	ldx	BITTER		; get bit off set
 8134   7267   86 11       		stx	BITOFF		; and save here
 8135   7269   A9 00       		lda	#0		; init a few things
 8136   726B   85 13       		sta	SCR_DATA	; init screen data byte
 8137   726D   8D E0 71    		sta	LINECHAR	; which character on the line 
 8138   7270   85 0F       		sta	CH_OFFSET		; which byte in line on screen
 8139   7272   85 07       		sta	LINE_X+LO	; X pos of line
 8140   7274   85 08       		sta	LINE_X+HI	; part 2
 8141   7276   8D E7 71    	        sta     UNDERF          ; make sure this be zero
 8142                      	
 8143   7279   AD E6 71    		lda	SV_INV		; get starting INV state
 8144   727C   85 BB       		sta	INVFLG		; okay!
 8145   727E   AD E5 71    	        lda     SV_UND          ; get starting UNDERLINE state
 8146   7281   85 BA       	        sta     UNDFLG          ; and restart it
 8147                      	
 8148   7283   C6 0F       		dec	CH_OFFSET		; inclusive count
 8149   7285   A6 11       		ldx	BITOFF		; make bitoff be a count
 8150   7287   BD E9 71    		lda	BIT_BITS,X	; get count
 8151   728A   AA          		tax			; x is bit counter
 8152   728B               	CHARL:
 8153   728B   AC E0 71    		ldy	LINECHAR	; get the char
 8154   728E   CC E4 71    		cpy	SCRCNT		; done with line?
 8155   7291   D0 03       		bne	CHARL1		; nope
 8156   7293   4C 37 73    		jmp	COPYL		; okay, move onto screen
 8157   7296               	CHARL1:
 8158   7296   EE E0 71    		inc	LINECHAR	; point to next one
 8159   7299   B9 80 02    		lda	SCRBUFF,Y	; got it
 8160   729C   10 06       		bpl	CHARL3		; not a highlight char
 8161                      	
 8162   729E   20 17 70    		jsr	HLIGHT		; so check it out
 8163   72A1   4C 8B 72    		jmp	CHARL		; done
 8164   72A4               	CHARL3:
 8165   72A4   C9 20       		cmp	#SPACE		; is it a highlight char?
 8166   72A6   90 E3       		bcc	CHARL		; ignore this one then
 8167   72A8               	CHARL2:
 8168   72A8   A8          		tay			; use as index
 8169   72A9   B9 2C 63    		lda	CHADR_H,Y	; get high part of address
 8170   72AC   85 1D       		sta	CHPTR+HI	; point to it
 8171   72AE   B9 AB 63    		lda	CHADR_L,Y	; get lo part
 8172   72B1   85 1C       		sta	CHPTR+LO	; save it
 8173   72B3   B9 2A 64    		lda	CHWID,Y		; get how wide the char is
 8174   72B6   85 C9       		sta	CW		; save it
 8175   72B8   A5 09       		lda	CC_OFF		; to get data
 8176   72BA   A4 C9       		ldy	CW		; see how wide the char is
 8177   72BC   C0 0A       		cpy	#10		; if <= 8, only one byte of info
 8178   72BE   90 01       		bcc	CHRLCW		; it is, so skip shift
 8179   72C0   0A          	 	asl	A		; *2 for bigger chars
 8180   72C1               	CHRLCW:
 8181   72C1   A8          		tay			; get the index
 8182   72C2   B1 1C       		lda	(CHPTR),Y	; get first byte
 8183   72C4   85 C7       		sta	CHAR_D1		; part one
 8184   72C6   C8          		iny			; point to next part
 8185   72C7   B1 1C       		lda	(CHPTR),Y	; get second byte
 8186   72C9   85 C8       		sta	CHAR_D2		; and save it
 8187   72CB   A5 C9       		lda	CW		; get width back
 8188   72CD   C9 0A       		cmp	#10		; if <= 8 zero byte 2 of char data
 8189   72CF   B0 04       		bcs	CHRLCW1		; nope
 8190   72D1   A9 00       		lda	#0		; clear out byte 2
 8191   72D3   85 C8       		sta	CHAR_D2		; okay
 8192   72D5               	CHRLCW1:
 8193   72D5   A5 C1       		lda	FONTFLG		; is this monospacing?
 8194   72D7   F0 28       		beq	CHRLFX		; nope
 8195                      	;
 8196                      	; if monospacing, see if it char is < mono width, and try to split
  Wed Jun  7 1989 12:04                                                                                                  Page  124

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8197                      	; the difference if so
 8198                      	;
 8199   72D9   C5 C9       		cmp	CW		; check against current width
 8200   72DB   B0 12       		bcs	CHRLF0		; CW < monowidth, so center
 8201                      	;
 8202                      	; too big, so take a little off front end too
 8203                      	;
 8204   72DD   A5 C9       		lda	CW		; get current width
 8205   72DF   38          		sec			; get ready for subbing
 8206   72E0   E9 0C       		sbc	#MONOFONT_W	; take away mono width
 8207   72E2   4A          		lsr	A		; /2 to get front half
 8208   72E3   A8          		tay			; use as counter
 8209   72E4   F0 17       		beq	CHRLF1		; nothing to do
 8210   72E6               	CHRLFX1:
 8211   72E6   06 C8       		asl	CHAR_D2		; step to the left
 8212   72E8   26 C7       		rol	CHAR_D1		; pick up char
 8213   72EA   88          		dey			; count one
 8214   72EB   D0 F9       		bne	CHRLFX1		; do next one
 8215   72ED   F0 0E       		beq	CHRLF1		; all done
 8216   72EF               	CHRLF0:
 8217   72EF   38          		sec			; do sub
 8218   72F0   E5 C9       		sbc	CW		; subtract CW
 8219   72F2   4A          		lsr	A		; /2 to get front part
 8220   72F3   A8          		tay			; put in counter
 8221   72F4   F0 07       		beq	CHRLF1		; no need to do anything
 8222   72F6               	CHRLFL:
 8223   72F6   46 C7       		lsr	CHAR_D1		; shift to right
 8224   72F8   66 C8       		ror	CHAR_D2		; this part too
 8225   72FA   88          		dey			; count shift
 8226   72FB   D0 F9       		bne	CHRLFL		; not done shifting yet
 8227   72FD               	CHRLF1:
 8228   72FD   A9 0C       		lda	#MONOFONT_W	; get mono font width
 8229   72FF   85 C9       		sta	CW		; chop at mono width
 8230   7301               	CHRLFX:
 8231   7301   AD E8 71    		lda	LINE_HEIGHT	; if == 0, then pick up underlining
 8232   7304   D0 05       		bne	CHRL3		; nope
 8233                      	
 8234   7306   A5 BA       		lda	UNDFLG		; get underlining flag
 8235   7308   8D E7 71    		sta	UNDERF		; and mark for later
 8236   730B               	CHRL3:
 8237   730B   A5 13       		lda	SCR_DATA	; get starting data
 8238   730D               	DATAL:
 8239   730D   26 C8       		rol	CHAR_D2		; it's a step to the left
 8240   730F   26 C7       		rol	CHAR_D1		; nother one
 8241   7311   6A          		ror	A		; and put into screen byte
 8242   7312   45 BB       		eor	INVFLG		; pick up inversing
 8243   7314   0D E7 71    		ora	UNDERF		; pick up underline flag
 8244   7317   E6 07       		inc	LINE_X+LO	; next X pos too
 8245   7319   D0 02       		bne	DATAL0		; no wrap
 8246   731B   E6 08       		inc	LINE_X+HI	; wrapped
 8247   731D               	DATAL0:
 8248   731D   CA          		dex			; next bit pos
 8249   731E   D0 0C       		bne	DATAL1		; nope
 8250                      	;
 8251                      	; save the byte and point to next byte
 8252                      	;
 8253   7320               	STCH:
 8254   7320   4A          		lsr	A		; put in lower 7 bits
 8255   7321   E6 0F       		inc	CH_OFFSET		; point to next one
 8256   7323   A4 0F       		ldy	CH_OFFSET		; get current offset
 8257   7325   99 00 1F    		sta	SCR_LINE,Y	; save in line
 8258   7328   A2 07       		ldx	#7		; and start bitoff at 7
 8259   732A   A9 00       		lda	#0		; clear a few locals
 8260   732C               	DATAL1:
 8261   732C   C6 C9       		dec	CW		; well?
 8262   732E   30 1F       		bmi	COPYL1		; all done, start copying
 8263   7330   D0 DB       		bne	DATAL		; nope
 8264   7332   85 13       		sta	SCR_DATA	; save current screen byte stuff here
 8265   7334   4C 8B 72    		jmp	CHARL		; do next char
 8266   7337               	COPYL:
 8267   7337   A5 07       		lda	LINE_X+LO	; see if we have any at all
 8268   7339   05 08       		ora	LINE_X+HI	; well, did we go anywhere?
 8269   733B   F0 21       		beq	LINE_EXIT	; then quit
 8270   733D   BD E9 71    		lda	BIT_BITS,X	; get number of significant bits
 8271   7340   8D DA 71    		sta	ENDBIT		; save this one
  Wed Jun  7 1989 12:04                                                                                                  Page  125

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8272   7343   E0 07       		cpx	#7		; has it been renewed?
 8273   7345   F0 08       		beq	COPYL1		; no last byte
 8274   7347   A5 13       		lda	SCR_DATA	; get screen data
 8275   7349               	COPYSH:
 8276   7349   4A          		lsr	A		; put down low, please
 8277   734A   CA          		dex			; one more
 8278   734B   D0 FC       		bne	COPYSH		; and do it again
 8279   734D   F0 D1       		beq	STCH		; now save this char
 8280   734F               	COPYL1:
 8281   734F   20 23 61    		jsr	COPY_SCRL	; copy SCR_LINE to screen
 8282   7352               	LED2:
 8283   7352   E6 01       		inc	SCRCY		; point to next line	
 8284   7354   CE E8 71    		dec	LINE_HEIGHT	; count this line
 8285   7357   30 05       		bmi	LINE_EXIT	; all done!
 8286                      	
 8287   7359   E6 09       		inc	CC_OFF		; point to next byte
 8288   735B   4C 59 72    		jmp	DO_LINE		; and do next line
 8289   735E               	LINE_EXIT:
 8290   735E   AE DE 71    		ldx	SAVEX		; get x back
 8291   7361   86 00       		stx	SCRCX		; restore it
 8292                      	
 8293   7363   AD E3 71    		lda	SHOW_CURSOR	; are we just doing cursor?
 8294   7366   D0 14       		bne	DLXX		; yes, don't change char pos
 8295                      	
 8296   7368   18          		clc			; add in length of this line
 8297   7369   A5 07       		lda	LINE_X+LO	; get length of line
 8298   736B   6D D8 71    		adc	CHR_X+LO	; add to start pos
 8299   736E   8D D8 71    		sta	CHR_X+LO	; save it
 8300   7371   A5 08       		lda	LINE_X+HI	; and the MSB
 8301   7373   6D D9 71    		adc	CHR_X+HI	; okay
 8302   7376   8D D9 71    		sta	CHR_X+HI	; save for a rainy day
 8303   7379   20 8A 73    		jsr	GET_SCRCX	; set SCRCX back up
 8304   737C               	DLXX:
 8305   737C   AD DF 71    		lda	CHR_Y		; restore the 
 8306   737F   85 01       		sta	SCRCY		; y pos
 8307   7381   A9 00       		lda	#0		; clear out counter
 8308   7383   8D E4 71    		sta	SCRCNT		; okay
 8309   7386   8D 7C 6C    		sta	CURSFLG		; reset this flag too
 8310   7389   60          		rts
 8311                      	
 8312   738A               	GET_SCRCX:
 8313   738A   AD D8 71    		lda	CHR_X+LO	; pick this back up
 8314   738D   85 00       	        sta     SCRCX
 8315   738F   AD D9 71    		lda	CHR_X+HI	; /2
 8316   7392   4A          		lsr	A       	; pick up remainder
 8317   7393   66 00       		ror	SCRCX   	; /4
 8318   7395   4A          		lsr	A		; pick up remainder
 8319   7396   66 00       		ror	SCRCX		; got it
 8320   7398   AD D8 71    		lda	CHR_X+LO	; any remainder?
 8321   739B   29 03       		and	#3		; well?
 8322   739D   F0 DD       		beq	DLXX		; nope
 8323   739F   E6 00       		inc	SCRCX		; point to next pos
 8324   73A1   60          		rts
 8325                      	
 8326                      	;
 8327                      	; DO_CURSOR - read in the screen byte, XOR cursor data, store it
 8328                      	;
 8329   73A2               	DO_CURSOR:
 8330   73A2   A0 00       		ldy	#0		; and zero y
 8331   73A4   84 10       		sty	DATALOOP	; init this counter
 8332   73A6               	DOCLOOP:
 8333                      	
 8334   73A6   A0 00       		ldy	#0		; must use Y
 8335   73A8   A6 8E       		ldx	FPCBNK		; what bank
 8336   73AA   BD 54 C0    		lda	PAGE2SW,X	; select it
 8337   73AD   B1 8C       		lda	(FPC),Y		; okay, get byte
 8338   73AF   A6 10       		ldx	DATALOOP	; get offset
 8339   73B1   5D 00 1F    		eor	SCR_LINE,X	; get data
 8340   73B4   91 8C       		sta	(FPC),Y		; save data
 8341   73B6   20 F6 5D    		jsr	NEXT_SCR	; point to next screen byte
 8342   73B9   E6 10       		inc	DATALOOP	; point to next char
 8343   73BB   C6 0F       		dec	CH_OFFSET	; count one char
 8344   73BD   10 E7       		bpl	DOCLOOP		; all done with this line?
 8345   73BF   AD 54 C0    		lda	PAGE2SW+MAIN	; make sure we are point to MAIN
 8346   73C2   60          		rts
  Wed Jun  7 1989 12:04                                                                                                  Page  126

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8347                      	
 8348   73C3               		END
 8349                      	
 8350   73C3               		INCLUDE		PIC.ASM
 8351   73C3               		STTL "--- Picture Op Codes ---"
 8352                      		PAGE
  Wed Jun  7 1989 12:04                                                                                                  Page  127

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8353                      	PFILE_RD:			; for READING files
 8354   73C3   04          		db	4		; 4 parameters
 8355   73C4   00          		db	0		; refnum
 8356   73C5   0008        		dw	IOBUFF		; read into io buffer
 8357   73C7   0004        		dw	$400		; 1Kb buffer
 8358   73C9   0000        		dw	0		; length actually read
 8359   73CB               	PFSEEK:
 8360   73CB   02          		db	2	        ; 2 pararmeters
 8361   73CC   00          		db	0	        ; refnum
 8362   73CD   00 00 00    		db 	0,0,0	        ; 3 byte new file pos
 8363   73D0   0000        	PICCNT: dw	0	        ; counter of the entries
 8364   73D2   00          	PF_REFNUM: db     0             ; place to store refnum
 8365   73D3   FF          	PF_FID: db      $FF             ; File ID of local directory data
 8366   73D4   00          	P_IDX:	db 	0	
 8367   73D5   00          	P_BCNT:	db	0
 8368   73D6   00          	P_LOFF:	db	0
 8369   73D7   00          	GBL_FLAG: db    0               ; found global directory?
 8370   73D8   00          	PIC_FLAG: db    0               ; found pictures?
 8371   73D9   00          	PF_NAME: db     0                       ; name we are looking at
 8372   73DA   00          	        db      0                       ; name we found
 8373                      	
 8374   73DB               	PICINFO:
 8375   73DB               		ds	PLDSIZE ; get room for picture data
 8376                      	
 8377   73E3   00          	TRANSCLR: DB	0	; transparent color
 8378   73E4               	UNKPIC:
 8379                      	
 8380   73E4   0D 55 6E 6B 6E 		db	EOL,"Unknown Picture #"
        73E9   6F 77 6E 20 50 
        73EE   69 63 74 75 72 
        73F3   65 20 23 
 8381          0012        	UNKPICL	EQU	$-UNKPIC
 8382   73F6               	ZDISPL:
 8383   73F6   20 B5 55    		jsr	CLRBUF			; put out any and all text
 8384                      	
 8385   73F9   20 4D 77    		jsr	GET_PICINF		; get the necessary data
 8386   73FC   90 18       		bcc	ZDSP1			; everything just fine
 8387                      	
 8388   73FE               		DLINE	UNKPIC			; unknown picture number error
 8389   73FE   A2 E4       		ldx	#<UNKPIC	; get part of UNKPIC
 8390   7400   A9 73       		lda	#>UNKPIC	; get other part of string
 8391          [01]        		IFMA	2		; check to see if length passed in
 8392                      		ldy			; then just fetch it
 8393          [01]        		ELSE
 8394   7402   A0 12       		ldy	#UNKPICL	; get length of string
 8395          [00]        		ENDIF
 8396   7404   20 6B 4C    		jsr	DLINE		; print the string
 8397   7407               		.MACEND
 8398   7407   A5 64       		lda	ARG1+HI			; get MSB
 8399   7409   20 D3 47    		jsr	HEXNUM			; print it
 8400   740C   A5 63       		lda	ARG1+LO			; and LSB
 8401   740E   20 D3 47    		jsr 	HEXNUM
 8402   7411   A9 14       		lda	#$14			; bad picture number error
 8403   7413   4C 0A 52    		jmp	ZERROR			; and croak
 8404   7416               	ZDSP1:
 8405   7416   20 9F 4D    		jsr	SAVE_CURSOR		; save the cursor
 8406                      	
 8407   7419   A9 00       		lda	#0			; show no cursor change
 8408   741B   8D 7C 6C    		sta	CURSFLG			; start with none, anyway
 8409                      	
 8410   741E   C6 62       		dec	NARGS			; x,y pos passed?
 8411   7420   F0 30       		beq	ZDSP10			; nope, just use as is
 8412                      	
 8413   7422   A5 65       		lda	ARG2+LO			; get passed y pos
 8414   7424   F0 12       		beq	ZDSP01			; don't change
 8415   7426   85 01       		sta	SCRCY			; change, then
 8416   7428   C6 01       		dec	SCRCY			; zero base it
 8417   742A   A0 00       		ldy	#WINTOP			; get top edge of window
 8418   742C   B1 05       		lda	(WINDOW),Y		; got it
 8419   742E   18          		clc				; get ready for add
 8420   742F   65 01       		adc	SCRCY			; add the offset
 8421   7431   85 01       		sta	SCRCY			; and make it Y pos
 8422   7433   A9 01       		lda	#1			; show cursor change anyway
 8423   7435   8D 7C 6C    		sta	CURSFLG			; okay, we did
 8424   7438               	ZDSP01:
  Wed Jun  7 1989 12:04                                                                                                  Page  128

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8425   7438   C6 62       		dec	NARGS			; x pos passed?
 8426   743A   F0 16       		beq	ZDSP10			; nope
 8427                      	
 8428   743C   A5 67       		lda	ARG3+LO			; get x pos
 8429   743E   F0 12       		beq	ZDSP10			; if == 0, don't change
 8430   7440   85 00       		sta	SCRCX			; set as passed
 8431   7442   C6 00       		dec	SCRCX			; zero base it
 8432   7444   A0 01       		ldy	#WINLEFT		; get left hand edge of window
 8433   7446   B1 05       		lda	(WINDOW),Y		; got it
 8434   7448   18          		clc				; get ready for add
 8435   7449   65 00       		adc	SCRCX			; add the offset
 8436   744B   85 00       		sta	SCRCX			; and make it X pos
 8437   744D   A9 01       		lda	#1			; show cursor change anyway
 8438   744F   8D 7C 6C    		sta	CURSFLG			; okay, we did
 8439   7452               	ZDSP10:
 8440   7452   A5 00       		lda	SCRCX			; get current X
 8441   7454   48          		pha				; save it
 8442   7455   18          		clc				; adding
 8443   7456   6D DD 73    		adc	PICINFO+PLDWID		; add in pic width
 8444   7459   85 00       		sta	SCRCX			; save here
 8445   745B   68          		pla				; get start X pos back
 8446   745C   85 00       		sta	SCRCX			; restored
 8447   745E               	ZDSP101:
 8448   745E   AD DF 73    		lda 	PICINFO+PLDFLG		; get flag byte
 8449   7461   29 01       		and	#1			; is there a transparent color?
 8450   7463   D0 04       		bne	ZDSP11			; ayyup
 8451   7465   A9 FF       		lda	#$FF			; make TRANSCLR be $FF
 8452   7467   D0 07       		bne	ZDSP12			; okay
 8453   7469               	ZDSP11:
 8454   7469   AD DF 73    		lda	PICINFO+PLDFLG		; get hi byte of flag word
 8455   746C   4A          		lsr	A			; put in lower byte
 8456   746D   4A          		lsr	A			; put in lower byte
 8457   746E   4A          		lsr	A			; put in lower byte
 8458   746F   4A          		lsr	A			; put in lower byte
 8459   7470               	ZDSP12:
 8460   7470   8D E3 73    		sta	TRANSCLR		; save transparent color
 8461                      	
 8462   7473   AD E0 73    		lda	PICINFO+PLDPTR		; MSB of offset
 8463   7476   8D CF 73    		sta	PFSEEK+SM_FPOS+2	; MSB of seek
 8464   7479   AD E1 73    		lda	PICINFO+PLDPTR+1	; Middle
 8465   747C   29 FE       	        and     #$FE                    ; seek only to 512byte boundary
 8466   747E   8D CE 73    		sta	PFSEEK+SM_FPOS+1
 8467                      	
 8468   7481               		SET_MARK PFSEEK			; go to pic data
 8469   7481               		PRODOS	$CE, PFSEEK
 8470   7481   20 00 BF    		jsr	$BF00	; ProDOS handler
 8471   7484   CE          		DB	$CE	; ProDOS function code
 8472   7485   CB73        		DW	PFSEEK	; Function Parameter Block address
 8473   7487               		.MACEND
 8474   7487               		.MACEND
 8475   7487   A9 02       		lda	#>PIC1BUF		; set up pointers to decode buffers
 8476   7489   85 7B       		sta	J+HI
 8477   748B   A9 73       		lda	#<PIC1BUF
 8478   748D   85 7A       		sta	J+LO
 8479   748F   A9 1C       		lda	#>PIC2BUF
 8480   7491   85 7D       		sta	K+HI
 8481   7493   A9 74       		lda	#<PIC2BUF
 8482   7495   85 7C       		sta	K+LO
 8483   7497   A9 00       		lda	#0			; start line at zero
 8484   7499   8D D6 73    		sta	P_LOFF			; done
 8485   749C   A0 8B       		ldy	#MAXWIDTH-1		; clear out width buffer
 8486   749E               	ZDLI:
 8487   749E   91 7A       		sta	(J),Y			; init 'previous line' buffer to zero
 8488   74A0   88          		dey				; down one
 8489   74A1   D0 FB       		bne	ZDLI
 8490   74A3   91 7A       		sta	(J),Y			; get last one
 8491                      	
 8492   74A5   A9 08       		lda	#>IOBUFF		; now get data buffer address
 8493   74A7   85 7F       		sta	L+HI
 8494   74A9   A9 04       		lda	#4			; 4 pages read in at once
 8495   74AB   8D D5 73    		sta	P_BCNT			; okay
 8496   74AE   A9 03       		lda	#3			; 3 bytes of width data start it
 8497   74B0   18          	        clc                             ; doing add
 8498   74B1   6D E2 73    		adc	PICINFO+PLDPTR+2	; pick up LSB pointer
 8499   74B4   8D D4 73    		sta	P_IDX			; start index
  Wed Jun  7 1989 12:04                                                                                                  Page  129

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8500   74B7   90 05       	        bcc     ZDLPCC                  ; no wrap
 8501   74B9   E6 7F       	        inc     L+HI                    ; start at second one
 8502   74BB   CE D5 73    	        dec     P_BCNT                  ; one less block
 8503   74BE               	ZDLPCC:
 8504   74BE   AD E1 73    		lda	PICINFO+PLDPTR+1        ; tells which block it is in               
 8505   74C1   29 01       	        and     #$01                    ; pick up which 256 block
 8506   74C3   F0 05       	        beq     ZDLP0                   ; start at first one
 8507   74C5   E6 7F       	        inc     L+HI                    ; start at next one
 8508   74C7   CE D5 73    	        dec     P_BCNT                  ; one less block
 8509   74CA               	ZDLP0:
 8510   74CA   A9 00       		lda	#<IOBUFF
 8511   74CC   85 7E       		sta	L+LO
 8512   74CE   A9 03       	        lda     #RETRY_COUNT    ; set retry
 8513   74D0   85 0E       	        sta     NY_DATA         ; just use this for now
 8514   74D2               	ZDLPRD:
 8515   74D2               		READ	PFILE_RD		; read in 1kb worth of data
 8516   74D2               		PRODOS	$CA, PFILE_RD
 8517   74D2   20 00 BF    		jsr	$BF00	; ProDOS handler
 8518   74D5   CA          		DB	$CA	; ProDOS function code
 8519   74D6   C373        		DW	PFILE_RD	; Function Parameter Block address
 8520   74D8               		.MACEND
 8521   74D8               		.MACEND
 8522   74D8   90 05       		bcc	ZDECLP			; everything went just fine
 8523   74DA   20 07 47    	        jsr     RETRY                   ; must we?
 8524   74DD   90 F3       	        bcc     ZDLPRD                  ; yes
 8525   74DF               	ZDECLP:
 8526   74DF   AC D4 73    		ldy	P_IDX			; get data index
 8527   74E2   B1 7E       		lda	(L),Y			; get data byte
 8528   74E4   85 71       		sta	ARG8			; save here
 8529   74E6   C8          		iny				; point to next one
 8530   74E7   D0 06       		bne	ZDCLP0			; okay, use offset
 8531   74E9   20 F5 75    		jsr	NEXT_PICB		; read in next block
 8532   74EC   90 01       		bcc	ZDCLP0			; everything went fine
 8533   74EE   60          		rts				; return if not
 8534   74EF               	ZDCLP0:
 8535   74EF   B1 7E       		lda	(L),Y			; is this count or data?
 8536   74F1   C9 10       		cmp	#16			; if <= 15, previous one was data 
 8537   74F3   B0 04       		bcs	ZDCL2			; nope, must be compressed
 8538   74F5   A9 0F       		lda	#15			; show 1 bytes
 8539   74F7   D0 0B       		bne	ZDCL3			; and count this one
 8540   74F9               	ZDCL2:
 8541   74F9   C8          		iny				; point to next byte
 8542   74FA   D0 08       		bne	ZDCL3			; okay, no wrap
 8543   74FC   48          		pha				; save A
 8544   74FD   20 F5 75    		jsr	NEXT_PICB		; check about nother block
 8545   7500   68          		pla				; get A back
 8546   7501   90 01       		bcc	ZDCL3			; everything came out okay
 8547   7503   60          		rts				; problems, return
 8548   7504               	ZDCL3:
 8549   7504   8C D4 73    		sty	P_IDX			; save index
 8550   7507   38          		sec				; get ready for sub
 8551   7508   E9 0E       		sbc	#14			; make good counter
 8552   750A   AA          		tax				; put count into x
 8553   750B               	ZDCLPC:
 8554   750B   AC D6 73    		ldy	P_LOFF			; get line offset
 8555   750E   A5 71       		lda	ARG8			; get data byte
 8556   7510   51 7A       		eor	(J),Y			; XOR with previous line
 8557   7512   91 7C       		sta	(K),Y			; and save away
 8558   7514   C8          		iny				; next offset
 8559   7515   8C D6 73    		sty	P_LOFF			; save Y
 8560   7518   CC DD 73    		cpy	PICINFO+PLDWID		; end of line?
 8561   751B   D0 10       		bne	ZDCLPC1			; nope
 8562   751D   20 35 75    		jsr	COPY_PIC		; copy line into screen
 8563   7520   A5 01       		lda	SCRCY			; past bottom?
 8564   7522   C9 BF       		cmp	#MAXHEIGHT-1		; well?
 8565   7524   F0 0C       		beq	ZDCLPX			; truncate at bottom then
 8566   7526   E6 01       		inc	SCRCY			; down one line
 8567   7528   CE DE 73    		dec	PICINFO+PLDHGHT		; count line
 8568   752B   F0 05       		beq	ZDCLPX			; all done then
 8569   752D               	ZDCLPC1:
 8570   752D   CA          		dex				; count down counter
 8571   752E   D0 DB       		bne	ZDCLPC			; do this byte again
 8572   7530   F0 AD       		beq	ZDECLP			; check next byte
 8573   7532               	ZDCLPX:
 8574   7532   4C B1 4D    		jmp	GET_CURSOR		; restore the cursor
  Wed Jun  7 1989 12:04                                                                                                  Page  130

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8575                      	
 8576   7535               	COPY_PIC:
 8577   7535   8A          		txa				; save x
 8578   7536   48          		pha 
 8579   7537   A5 00       		lda	SCRCX			; get start X pos
 8580   7539   48          		pha				; okay, saved
 8581   753A   A9 00       		lda	#0			; start offset at zero
 8582   753C   85 0E       		sta	NY_DATA 		; and into data buffer
 8583   753E               	CPICLOOP:
 8584   753E   20 51 5E    		jsr	SETPOS			; point to correct line
 8585   7541   A6 11       		ldx	BITOFF			; get starting offset
 8586   7543   8E E1 71    		stx	BITTER			; bit offset for COPY_SCRL to use
 8587   7546   BD E9 71    		lda	BIT_BITS,X		; get starting bit counter
 8588   7549   AA          		tax				; okay, we did
 8589   754A   A9 8C       		lda	#MAXWIDTH		; don't let screen wrap
 8590   754C   38          		sec				; doing sub
 8591   754D   E5 00       		sbc	SCRCX			; get current X pos
 8592   754F   85 10       		sta	DATALOOP		; only use this many pixels
 8593   7551   A0 00       		ldy	#0			; start with first byte
 8594   7553   84 13       		sty	SCR_DATA		; data starts with zero
 8595   7555   88          		dey				; inclusive count
 8596   7556   84 0F       		sty	CH_OFFSET		; reset line offset
 8597   7558   A4 0E       		ldy	NY_DATA 		; start Y out
 8598   755A   20 85 75    		jsr	PIC2SCR			; move line to screen
 8599                      	
 8600   755D   A4 0E       		ldy	NY_DATA 		; current offset
 8601   755F   CC DD 73    		cpy	PICINFO+PLDWID		; did we finish whole line?
 8602   7562   B0 02       		bcs	COPYPIC1		; yup, so wrap things up
 8603   7564   90 D8       		bcc	CPICLOOP		; and continue with line
 8604   7566               	COPYPIC1:
 8605   7566   A5 7B       		lda	J+HI			; get previous line
 8606   7568   48          	 	pha				; save addr
 8607   7569   A5 7D       		lda	K+HI			; make current line be previous
 8608   756B   85 7B       		sta	J+HI
 8609   756D   68          		pla				; get old previous line back
 8610   756E   85 7D       		sta	K+HI			; make it be new current line
 8611   7570   A5 7A       		lda	J+LO			; get previous line
 8612   7572   48          		pha				; and save it
 8613   7573   A5 7C       		lda	K+LO
 8614   7575   85 7A       		sta	J+LO			; okay, it is
 8615   7577   68          		pla	
 8616   7578   85 7C       		sta	K+LO			; and save new one
 8617   757A   A9 00       		lda	#0			; pic offset is zero
 8618   757C   8D D6 73    		sta	P_LOFF			; done
 8619   757F   68          		pla				; get start X back
 8620   7580   85 00       		sta	SCRCX			; restored
 8621   7582   68          		pla				; get X reg back
 8622   7583   AA          		tax
 8623   7584   60          		rts	
 8624                      	
 8625   7585               	PIC2SCR:
 8626   7585   A9 04       		lda	#4			; 4 bits per pixel
 8627   7587   85 6F       		sta	ARG7			; use zero page
 8628   7589   B1 7C       		lda	(K),Y			; get data byte
 8629   758B   CD E3 73    		cmp	TRANSCLR		; is it transparent?
 8630   758E   D0 1D       		bne	CPYPL1			; nope
 8631   7590               	P2LOOP:
 8632   7590   E6 00       	        inc     SCRCX                   ; point to next pixel
 8633   7592   C8          		iny				; next pixel
 8634   7593   CC DD 73    		cpy	PICINFO+PLDWID		; done with line?
 8635   7596   B0 07       		bcs	P2LP1			; yup
 8636   7598   B1 7C       		lda	(K),Y			; get it
 8637   759A   CD E3 73    		cmp	TRANSCLR		; still transparent?
 8638   759D   F0 F1       		beq	P2LOOP			; ayyup
 8639   759F               	P2LP1:
 8640   759F   84 0E       		sty	NY_DATA 		; show where we ended up
 8641   75A1   60          	      	rts
 8642   75A2               	P2SLOOP:
 8643   75A2   B1 7C       		lda	(K),Y			; get data byte
 8644   75A4   CD E3 73    		cmp	TRANSCLR		; is it transparent?
 8645   75A7   F0 35       		beq	CPYSL1X			; yes, so done with this
 8646   75A9   A0 04       		ldy	#4			; 4 bits per pixel
 8647   75AB   84 6F       		sty	ARG7			; use zero page
 8648   75AD               	CPYPL1:
 8649   75AD   0A          		asl	A			; shift to upper nybble
  Wed Jun  7 1989 12:04                                                                                                  Page  131

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8650   75AE   0A          		asl	A			; shift to upper nybble
 8651   75AF   0A          		asl	A			; shift to upper nybble
 8652   75B0   0A          		asl	A			; shift to upper nybble
 8653   75B1               	CPYSL:
 8654   75B1   0A          		asl	A			; shift into carry
 8655   75B2   66 13       		ror	SCR_DATA		; pick up carry
 8656   75B4   CA          		dex				; count it
 8657   75B5   D0 12       		bne	CPYSL1			; shift again, please
 8658   75B7               	CPYSLST:
 8659   75B7   48          		pha				; save byte
 8660   75B8   A5 13       		lda	SCR_DATA		; get screen  byte
 8661   75BA   4A          		lsr	A			; move down to last 7 bits
 8662   75BB   E6 0F       		inc	CH_OFFSET			; point to interesting byte
 8663   75BD   A4 0F       		ldy	CH_OFFSET			; get offset
 8664   75BF   99 00 1F    		sta	SCR_LINE,Y		; save into mem
 8665   75C2   A2 07       		ldx	#7			; and start bitoff at 7
 8666   75C4   A9 00       		lda	#0			; clear a few locals
 8667   75C6   85 13       		sta	SCR_DATA		; screen data
 8668   75C8   68          		pla				; get byte back
 8669   75C9               	CPYSL1:
 8670   75C9   C6 6F       		dec	ARG7			; count this bit
 8671   75CB   30 25       		bmi	CPYSLX			; all done
 8672   75CD   D0 E2       		bne	CPYSL			; not done with 'pixel' yet
 8673   75CF   E6 0E       		inc	NY_DATA 		; point to next one
 8674   75D1   E6 00       	        inc     SCRCX                   ; point to next pixel
 8675   75D3   A4 0E       		ldy	NY_DATA 		; next pixel
 8676   75D5   CC DD 73    		cpy	PICINFO+PLDWID		; finished with line yet?
 8677   75D8   F0 04       		beq 	CPYSL1X			; yes, so move to screen
 8678   75DA   C6 10       		dec	DATALOOP		; reached right edge of screen?
 8679   75DC   D0 C4       		bne	P2SLOOP			; do next pixel
 8680   75DE               	CPYSL1X:
 8681   75DE   BD E9 71    		lda	BIT_BITS,X		; get me number of significant bits in this byte
 8682   75E1   8D DA 71    		sta	ENDBIT			; show end bit
 8683   75E4   E0 07       		cpx	#7			; is there a last byte to use?
 8684   75E6   F0 0A       		beq	CPYSLX			; no last byte
 8685   75E8   A5 13       		lda	SCR_DATA		; get screen data
 8686   75EA               	CPYLSH:
 8687   75EA   4A          		lsr	A			; put down low, please
 8688   75EB   CA          		dex				; one more
 8689   75EC   D0 FC       		bne	CPYLSH			; and do it again
 8690   75EE   85 13       		sta	SCR_DATA		; save for later use
 8691   75F0   F0 C5       		beq	CPYSLST			; now save this char
 8692   75F2               	CPYSLX:
 8693   75F2   4C 34 61    		jmp	COPY_SCRL1		; copy to screen
 8694                      	
 8695   75F5               	NEXT_PICB:
 8696   75F5   48          		pha				; save a please
 8697                      	
 8698   75F6   CE D5 73    		dec	P_BCNT			; done all four pages?
 8699   75F9   D0 1E       		bne	NXTPX1			; nope
 8700                      	
 8701   75FB   A9 03       	        lda     #RETRY_COUNT            ; set retry
 8702   75FD   85 16       	        sta     RETRIES                 ; just use this for now
 8703                      	
 8704   75FF   A9 08       		lda	#>IOBUFF		; reset data buffer address
 8705   7601   85 7F       		sta	L+HI
 8706   7603   A9 00       		lda	#<IOBUFF
 8707   7605   85 7E       		sta	L+LO
 8708   7607   A9 04       		lda	#4			; 4 pages read in at once
 8709   7609   8D D5 73    		sta	P_BCNT			; okay
 8710   760C               	NXTPRD:
 8711   760C               		READ	PFILE_RD		; read in 1kb worth of data
 8712   760C               		PRODOS	$CA, PFILE_RD
 8713   760C   20 00 BF    		jsr	$BF00	; ProDOS handler
 8714   760F   CA          		DB	$CA	; ProDOS function code
 8715   7610   C373        		DW	PFILE_RD	; Function Parameter Block address
 8716   7612               		.MACEND
 8717   7612               		.MACEND
 8718   7612   90 07       		bcc	NXTPX			; everything went just fine
 8719   7614   20 07 47    	        jsr     RETRY                   ; try again?
 8720   7617   90 F3       		bcc     NXTPRD                  ; okay, do it again
 8721   7619               	NXTPX1:
 8722   7619   E6 7F       		inc	L+HI			; point to next page
 8723   761B               	NXTPX:
 8724   761B   18          		clc				; make sure carry is clear
  Wed Jun  7 1989 12:04                                                                                                  Page  132

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8725   761C               	NXTPXR:
 8726   761C   A0 00       		ldy	#0			; start reading at beginnig of block
 8727   761E   68          		pla				; get [A] back
 8728   761F   60          		rts				; done
 8729                      	;
 8730                      	; GET_PDATA - go out and check the just opened file to see what kind,
 8731                      	;       if any, of picture data it has.  
 8732                      	;  [A] = REFNUM of the freshly opened file
 8733                      	;
 8734                      	
 8735   7620               	GET_PDATA:
 8736   7620   8D D2 73    	        sta     PF_REFNUM               ; save refnum for later usage
 8737   7623   A5 1F       	        lda     DSEGS+HI                ; save old one
 8738   7625   48          	        pha
 8739   7626   A5 1E       	        lda     DSEGS+LO
 8740   7628   48          	        pha
 8741   7629   AC C5 49    	        ldy     SAVENUM                 ; which file are we talking about
 8742   762C   88          	        dey                             ; zero base it
 8743   762D   98          	        tya
 8744   762E   29 0F       	        and     #$0F                    ; make sure DSEG is set
 8745   7630   0A          	        asl     A                       ; *2 for words
 8746   7631   A8          	        tay                             ; make it  index again
 8747   7632   B9 D1 1D    	        lda     DSKSEG+HI,Y             ; get MSB
 8748   7635   85 1F       	        sta     DSEGS+HI
 8749   7637   B9 D0 1D    	        lda     DSKSEG+LO,Y             ; and LSB
 8750   763A   85 1E       	        sta     DSEGS+LO
 8751   763C   20 46 76    	        jsr     GO_GET_PDATA            ; actually do the work
 8752   763F   68          	        pla                             ; get old DSEG back
 8753   7640   85 1E       	        sta     DSEGS+LO     
 8754   7642   68          	        pla
 8755   7643   85 1F       	        sta     DSEGS+HI
 8756   7645               	GETPX:
 8757   7645   60          	        rts                             ; bye
 8758   7646               	GO_GET_PDATA:
 8759   7646   AD D7 73    	        lda     GBL_FLAG                ; is there already a global dir?
 8760   7649   D0 0A       	        bne     GTPG1                   ; yes, so don't check again
 8761   764B   A0 06       	        ldy     #SGTGPOF                ; first, check for global directory
 8762   764D   A9 DC       		lda	#>GBL_DIR		; start destination off here
 8763   764F   20 6A 76    	        jsr     READ_IN_PDATA           ; go get global directory, if any
 8764   7652   8D D7 73    	        sta     GBL_FLAG                ; indicate whether there is a global
 8765   7655               	GTPG1:
 8766   7655   AD C5 49    	        lda     SAVENUM                 ; get which file is being opened
 8767   7658   29 0F       	        and     #$0F                    ; just make it binary
 8768   765A   CD D3 73    	        cmp     PF_FID                  ; same as the file we already have?
 8769   765D   F0 0A       	        beq     GETPGX                  ; yes, so don't bother
 8770   765F   A0 02       		ldy	#SGTPICOF		; point to picture offset
 8771   7661   A9 D0       		lda	#>PIC_DIR		; start destination off here
 8772   7663   20 6A 76    	        jsr     READ_IN_PDATA           ; go get the data for local pictures
 8773   7666   8D D8 73    	        sta     PIC_FLAG                ; any picture data
 8774   7669               	GETPGX:
 8775   7669   60          	        rts
 8776                      	;
 8777                      	; READ_IN_PDATA - check for desired data being in file, and skip to it if
 8778                      	;       it is.  Then, read it in in 1Kb chunks, stashing it away into the
 8779                      	;       upper bank of the aux mem language card.
 8780                      	; Enter with:
 8781                      	;   [A] = Destination page
 8782                      	;   [Y] = Offset into Segment table 
 8783                      	;
 8784   766A               	READ_IN_PDATA:
 8785   766A   48          	        pha                             ; save destination page
 8786   766B   B1 1E       		lda	(DSEGS),Y		; get MSB
 8787   766D   8D CF 73    		sta	PFSEEK+SM_FPOS+2	; Byte 2
 8788   7670   C8          		iny				; point to LSB
 8789   7671   11 1E       		ora	(DSEGS),Y		; is there any pic data?
 8790   7673   D0 04       		bne	GTPD00			; yes
 8791   7675   68          	        pla                             ; get page back
 8792   7676   A9 00       	        lda     #0                      ; show not here
 8793   7678   60          	        rts                             ; nope
 8794   7679               	GTPD00:
 8795   7679   B1 1E       		lda	(DSEGS),Y		; get it for shifting
 8796   767B   0A          		asl	A			; *2
 8797   767C   8D CE 73    		sta	PFSEEK+SM_FPOS+1	; stash away
 8798   767F   2E CF 73    		rol	PFSEEK+SM_FPOS+2	; pick up carry
 8799   7682   A9 00       		lda	#0			; clear out MSB
  Wed Jun  7 1989 12:04                                                                                                  Page  133

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8800   7684   8D C8 73    		sta	PFILE_RD+RD_BUFFLEN+HI
 8801   7687   8D CD 73    		sta	PFSEEK+SM_FPOS		; and LSB of seeking
 8802                      	
 8803   768A   AD D2 73    	        lda     PF_REFNUM               ; get file ref number
 8804   768D   8D C4 73    		sta	PFILE_RD+RD_REFNUM      ; and save it for reading and
 8805   7690   8D CC 73    		sta	PFSEEK+SM_REFNUM	; for seeking
 8806                      	
 8807   7693   A9 03       	        lda     #RETRY_COUNT    ; set retry
 8808   7695   85 0E       	        sta     NY_DATA         ; just use this for now
 8809   7697               	GTPDRD0:
 8810   7697               		SET_MARK PFSEEK			; and go to beginning
 8811   7697               		PRODOS	$CE, PFSEEK
 8812   7697   20 00 BF    		jsr	$BF00	; ProDOS handler
 8813   769A   CE          		DB	$CE	; ProDOS function code
 8814   769B   CB73        		DW	PFSEEK	; Function Parameter Block address
 8815   769D               		.MACEND
 8816   769D               		.MACEND
 8817                      	
 8818   769D   A9 04       		lda	#4			; read in 4 256 blocks
 8819   769F   8D C8 73    		sta	PFILE_RD+RD_BUFFLEN+HI	
 8820   76A2               		READ	PFILE_RD		; go get the next 4Kb worth
 8821   76A2               		PRODOS	$CA, PFILE_RD
 8822   76A2   20 00 BF    		jsr	$BF00	; ProDOS handler
 8823   76A5   CA          		DB	$CA	; ProDOS function code
 8824   76A6   C373        		DW	PFILE_RD	; Function Parameter Block address
 8825   76A8               		.MACEND
 8826   76A8               		.MACEND
 8827   76A8   90 05       	        bcc     GTPD1                   ; fine
 8828   76AA   20 07 47    	        jsr     RETRY                   ; well, do it again?
 8829   76AD   90 E8       	        bcc     GTPDRD0                 ; yes
 8830   76AF               	GTPD1:
 8831   76AF   68          	        pla                             ; get destination page back
 8832   76B0   C9 D0       	        cmp     #>PIC_DIR               ; if doing local directory, set up
 8833   76B2   D0 16       	        bne     GTPD2                   ;  picture count
 8834   76B4   AE 04 08    		ldx	IOBUFF+PHNLD		; get number of pictures
 8835   76B7   8E D1 73    		stx	PICCNT+HI		; save for count down too
 8836   76BA   AE 05 08    		ldx	IOBUFF+PHNLD+1		; and here is LSB
 8837   76BD   8E D0 73    		stx	PICCNT+LO		; saving for counting
 8838   76C0   AE 00 08    	        ldx     IOBUFF+PHFID            ; get file ID
 8839   76C3   8E D3 73    	        stx     PF_FID                  ; and save for later
 8840   76C6   A2 20       	        ldx     #(256/PLDSIZE)          ; how many entries in 256 bytes
 8841   76C8   D0 0E       	        bne     GTPD3                   ; done
 8842   76CA               	GTPD2:
 8843   76CA   AE 00 08    	        ldx     IOBUFF                  ; get MSB of how many
 8844   76CD   8E D1 73    	        stx     PICCNT+HI               ; show me
 8845   76D0   AE 01 08    	        ldx     IOBUFF+1                ; get LSB of count
 8846   76D3   8E D0 73    	        stx     PICCNT+LO
 8847   76D6   A2 80       	        ldx     #(256/2)                ; how many entries / 256 bytes
 8848   76D8               	GTPD3:
 8849   76D8   8E 0F 77    	        stx     GTPMOD+1                ; set up how big entry is
 8850   76DB   8D 09 C0    		sta	ALTZP+AUX		; use aux mem for most of this
 8851   76DE   85 7D       		sta	K+HI			; MSB of destination
 8852   76E0   A9 00       	        lda     #0                      ; clear a few things
 8853   76E2   85 7A       		sta	J+LO			; J = source
 8854   76E4   85 7C       		sta	K+LO			; K = destination
 8855   76E6   A9 04       		lda	#4			; 4 * (4*256) bytes max
 8856   76E8   8D C8 73    		sta	PFILE_RD+RD_BUFFLEN+HI	; show the read too
 8857   76EB   8D D4 73    		sta	P_IDX			; save here for counting
 8858   76EE               	GTPDL:
 8859   76EE   A0 00       	        ldy     #0                      ; start y
 8860   76F0   A9 08       		lda	#>IOBUFF		; get where source is
 8861   76F2   85 7B       		sta	J+HI			; MSB of source
 8862   76F4   A9 04       		lda	#4			; 4 blocks worth of 256
 8863   76F6   8D D5 73    		sta	P_BCNT			; used as counter
 8864   76F9   AD 8B C0    		lda	BNK1SET			; we be using bank 1 @$D000
 8865   76FC   AD 8B C0    		lda	BNK1SET			; we be using bank 1 @$D000
 8866   76FF               	GTPDL1:
 8867   76FF   B1 7A       		lda	(J),Y			; get the data byte
 8868   7701   91 7C       		sta	(K),Y			; store in upper aux
 8869   7703   C8          		iny				; point to the next one
 8870   7704   D0 F9       		bne	GTPDL1			; and go get it
 8871   7706               		
 8872   7706   E6 7B       		inc	J+HI			; next block please
 8873   7708   E6 7D       		inc	K+HI			; for destination too
 8874   770A   AD D0 73    		lda	PICCNT+LO		; how many entries?
  Wed Jun  7 1989 12:04                                                                                                  Page  134

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8875   770D   38          		sec				; doing sbc
 8876   770E   E9 20       	GTPMOD:	sbc	#(256/PLDSIZE)		; how many entries in 256 bytes?
 8877   7710   8D D0 73    		sta	PICCNT+LO		; save result
 8878   7713   B0 05       		bcs	GTPDL2			; no wrapping
 8879   7715   CE D1 73    		dec	PICCNT+HI		; wrap
 8880   7718   30 26       		bmi	GTPDLX			; all done if we go negative
 8881   771A               	GTPDL2:
 8882   771A   0D D1 73    		ora	PICCNT+HI		; make sure both are not zero
 8883   771D   F0 21       		beq	GTPDLX			; if they are, then we are done
 8884   771F   CE D5 73    		dec	P_BCNT			; count this block
 8885   7722   D0 DB       		bne	GTPDL1			; go fetch next 256 bytes
 8886   7724   8D 08 C0    		sta	ALTZP+MAIN		; swap back to main for read
 8887                      	
 8888   7727   A9 03       	        lda     #RETRY_COUNT    ; set retry
 8889   7729   85 0E       	        sta     NY_DATA         ; just use this for now
 8890   772B               	GTPDRD:
 8891   772B               		READ	PFILE_RD		; go get the next 4Kb worth
 8892   772B               		PRODOS	$CA, PFILE_RD
 8893   772B   20 00 BF    		jsr	$BF00	; ProDOS handler
 8894   772E   CA          		DB	$CA	; ProDOS function code
 8895   772F   C373        		DW	PFILE_RD	; Function Parameter Block address
 8896   7731               		.MACEND
 8897   7731               		.MACEND
 8898   7731   90 05       	        bcc     GTPDRDG                 ; fine
 8899   7733   20 07 47    	        jsr     RETRY                   ; well, do it again?
 8900   7736   90 F3       	        bcc     GTPDRD                  ; yes
 8901   7738               	GTPDRDG:
 8902   7738   8D 09 C0    		sta	ALTZP+AUX		; and back to aux for working
 8903   773B   CE D4 73    		dec	P_IDX			; max 4Kb worth of reading
 8904   773E   D0 AE       		bne	GTPDL			; and read in more
 8905   7740               	GTPDLX:
 8906   7740   8D 08 C0    		sta	ALTZP+MAIN		; back to main bank of mem
 8907   7743   AD 83 C0    		lda	BNK2SET			; back to bank 2
 8908   7746   AD 83 C0    		lda	BNK2SET			; yes please
 8909   7749   A9 01       	        lda     #1                      ; show we found it
 8910   774B   60          		rts				; all done
 8911                      	
 8912   774C   00          	GTPFLAG: db 0				; if 1 when opening next file, then
 8913                      						; this is the next file, so unable to
 8914                      						; find picture number
 8915   774D               	GET_PICINF:
 8916   774D   A9 00       		lda	#0			; set flag for double check
 8917   774F   8D 4C 77    		sta	GTPFLAG			; start at zero
 8918   7752               	GTPLOOP:
 8919   7752   A5 63       		lda	ARG1+LO			; check argument for zero
 8920   7754   05 64       		ora	ARG1+HI			; is it zero?
 8921   7756   D0 02       		bne	GTPINDX			; jump to look at first block
 8922   7758   18          		clc				; found some pictures
 8923   7759   60          		rts				; if zero, just give count
 8924   775A               	GTPINDX:
 8925   775A   A4 63       		ldy	ARG1+LO 		; get arg, as we are swapping
 8926   775C   A6 64       		ldx	ARG1+HI 		; to aux mem
 8927   775E   8D 09 C0    		sta	ALTZP+AUX		; look at AUX mem
 8928   7761   AD 8B C0    		lda	BNK1SET 		; bank 1
 8929   7764   AD 8B C0    		lda	BNK1SET 		; bank 1
 8930   7767   AD 04 D0    	        lda     PIC_DIR+PHNLD           ; get # of entries
 8931   776A   8D D1 73    	        sta     PICCNT+HI
 8932   776D   AD 05 D0    	        lda     PIC_DIR+PHNLD+1         ; it's in reverse order
 8933   7770   8D D0 73    	        sta     PICCNT+LO
 8934   7773   84 63       		sty	ARG1+LO 		; use aux mem zero page
 8935   7775   86 64       		stx	ARG1+HI 		; for new arg1
 8936   7777   A9 D0       		lda	#>PIC_DIR		; start at beginning of block
 8937   7779   85 8A       		sta	MPNTH			; hi part
 8938   777B   A9 00       		lda	#<PIC_DIR		; don't forget to start at beginning
 8939   777D   85 89       		sta	MPNTL			; we are
 8940   777F   A9 10       		lda	#PHSIZE                 ; skip over header
 8941   7781   8D D4 73    		sta	P_IDX			; this is the counter
 8942   7784               	GTP3:
 8943   7784   AC D4 73    		ldy	P_IDX			; get offset
 8944   7787   A5 64       		lda	ARG1+HI			; check against desired one
 8945   7789   D1 89       		cmp	(MPCPNT),Y		; get ID hi byte
 8946   778B   90 15       		bcc	GTPNOT			; arg1 < than entry, can't be here
 8947   778D   D0 09       		bne	GTP4			; not it, so check next one
 8948   778F   C8          		iny				; now to LSB
 8949   7790   B1 89       		lda	(MPCPNT),Y		; get it
  Wed Jun  7 1989 12:04                                                                                                  Page  135

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8950   7792   C5 63       		cmp	ARG1+LO			; is it what we want?
 8951   7794   F0 2D       		beq	GTPFOUND		; found the picture
 8952   7796   B0 0A       		bcs	GTPNOT			; arg1 < entry, cannot be here
 8953   7798               	GTP4:
 8954   7798   AD D0 73    		lda	PICCNT+LO		; get LSB
 8955   779B   D0 14       		bne	GTP4D			; no wrap down
 8956   779D   CE D1 73    		dec	PICCNT+HI		; count down MSB
 8957   77A0   10 0F       		bpl	GTP4D			; everything still okay
 8958   77A2               	GTPNOT:
 8959   77A2   8D 08 C0    		sta	ALTZP+MAIN		; back to main mem
 8960   77A5   AD 83 C0    		lda	BNK2SET			; back to bank 1
 8961   77A8   AD 83 C0    		lda	BNK2SET			; yes please
 8962   77AB   20 DC 77    	        jsr     FIND_GBL                ; find picture in global dir
 8963   77AE   90 A2       	        bcc     GTPLOOP                 ; go try again
 8964   77B0   60          	        rts                             ; just show no goodness
 8965   77B1               	GTP4D:	
 8966   77B1   CE D0 73    		dec	PICCNT+LO		; count this entry
 8967   77B4   AD D4 73    		lda	P_IDX			; get index
 8968   77B7   18          		clc				; ready to add
 8969   77B8   69 08       		adc	#PLDSIZE		; point to next entry
 8970   77BA   8D D4 73    		sta	P_IDX			; save lo part
 8971   77BD   90 C5       		bcc	GTP3			; no wrap
 8972   77BF   E6 8A       		inc	MPNTH			; next block
 8973   77C1   D0 C1       		bne	GTP3			; do next block
 8974   77C3               	GTPFOUND:
 8975   77C3   A2 00       		ldx	#0			; for copying data
 8976   77C5   88          		dey				; point to beginning of data
 8977   77C6               	GTPFL:
 8978   77C6   B1 89       		lda	(MPCPNT),Y		; get data
 8979   77C8   9D DB 73    		sta	PICINFO,X		; save data
 8980   77CB   C8          		iny				; point to new entry stuff
 8981   77CC   E8          		inx				; next x
 8982   77CD   E0 08       		cpx	#PLDSIZE		; got it all yet (not ID, tho)?
 8983   77CF   D0 F5       		bne	GTPFL			; get data
 8984   77D1   8D 08 C0    		sta	ALTZP+MAIN		; back to main mem
 8985   77D4   AD 83 C0    		lda	BNK2SET			; back to bank 2
 8986   77D7   AD 83 C0    		lda	BNK2SET			; yes please
 8987   77DA   18          		clc				; show got data
 8988   77DB   60          		rts
 8989                      	;
 8990                      	; FIND_GBL - check the global directory for the picture in question.  If there
 8991                      	;       isn't a global directory, just open the other file.  Return with carry 
 8992                      	;       set if either not in global directory, or the other file has already
 8993                      	;       been opened.
 8994                      	;
 8995   77DC               	FIND_GBL:
 8996   77DC   AD 4C 77    		lda	GTPFLAG			; have we already tried to open another file?
 8997   77DF   EE 4C 77    		inc	GTPFLAG			; show trying next file
 8998   77E2   A8          	        tay                             ; check flag
 8999   77E3   D0 0A       		bne     GTPNOT1                 ; we already should have found it
 9000   77E5   AD D7 73    	        lda     GBL_FLAG                ; do we have global dir?
 9001   77E8   D0 07       	        bne     FG1                     ; yes, so look for picture there
 9002                      	;
 9003                      	; otherwise, just check the other file
 9004                      	;
 9005   77EA   20 1B 79    		jsr	NEXTPICF		; open other picture file
 9006   77ED   18          	        clc
 9007   77EE   60          	        rts
 9008   77EF               	GTPNOT1:
 9009   77EF   38          	        sec                             ; show badness
 9010   77F0   60          	        rts
 9011                      	;
 9012                      	; go find the picture in the global directory file
 9013                      	;
 9014   77F1               	FG1:
 9015   77F1   A4 63       		ldy	ARG1+LO 		; get arg, as we are swapping
 9016   77F3   A6 64       		ldx	ARG1+HI 		; to aux mem
 9017   77F5   8D 09 C0    		sta	ALTZP+AUX		; look at AUX mem
 9018   77F8   AD 8B C0    		lda	BNK1SET 		; bank 1
 9019   77FB   AD 8B C0    		lda	BNK1SET 		; bank 1 is where the directory is
 9020   77FE   AD 00 DC    	        lda     GBL_DIR                 ; MSB of count
 9021   7801   8D D1 73    	        sta     PICCNT+HI
 9022   7804   AD 01 DC    	        lda     GBL_DIR+1               ; LSB of count
 9023   7807   8D D0 73    	        sta     PICCNT+LO               
 9024   780A   84 63       	        sty     ARG1+LO                 ; restore args
  Wed Jun  7 1989 12:04                                                                                                  Page  136

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 9025   780C   86 64       	        stx     ARG1+HI         
 9026   780E   A9 DC       		lda	#>GBL_DIR		; start at beginning of block
 9027   7810   85 8A       		sta	MPNTH			; hi part
 9028   7812   A9 00       		lda	#<GBL_DIR		; don't forget to start at beginning
 9029   7814   85 89       		sta	MPNTL			; we are
 9030   7816   A9 02       	        lda     #2                      ; start at 2nd word, skipping
 9031   7818   8D D4 73    	        sta     P_IDX                   ; the count byte
 9032   781B               	FGLOOP:
 9033   781B   EE D4 73    	        inc     P_IDX                   ; point to LSB
 9034   781E   AC D4 73    		ldy	P_IDX			; get offset
 9035   7821   B1 89       	        lda     (MPCPNT),Y              ; get global lo byte
 9036   7823   C5 63       	        cmp     ARG1+LO                 ; same as desired one?
 9037   7825   D0 0F       	        bne     FGNOT                   ; nope
 9038   7827   88          	        dey                             ; point to ID MSB
 9039   7828   B1 89       	        lda     (MPCPNT),Y              ; get global MSB
 9040   782A   29 03       	        and     #$03                    ; lower two bits are upper ID part
 9041   782C   C5 64       	        cmp     ARG1+HI                 ; same as desired one?
 9042   782E   D0 06       	        bne     FGNOT                   ; nope
 9043   7830   B1 89       	        lda     (MPCPNT),Y              ; get disk map
 9044   7832   A8          	        tay                             ; save in Y
 9045   7833   18          	        clc                             ; ready for return
 9046   7834   90 1A       	        bcc     FTNX                    ; and done
 9047   7836               	FGNOT:
 9048   7836   AD D0 73    	        lda     PICCNT+LO               ; wrap?
 9049   7839   D0 08       	        bne     FTN1                    ; nope
 9050   783B   AD D1 73    	        lda     PICCNT+HI               ; already zero?
 9051   783E   F0 0F       	        beq     FTNOTFOUND              ; sorry, it ain't anywhere
 9052   7840   CE D1 73    	        dec     PICCNT+HI               ; count down the wrap
 9053   7843               	FTN1:
 9054   7843   CE D0 73    	        dec     PICCNT+LO               ; count down towards the end
 9055   7846   EE D4 73    	        inc     P_IDX                   ; point to next entry
 9056   7849   D0 D0       	        bne     FGLOOP                  ; no wrap to next page
 9057   784B   E6 8A       	        inc     MPNTH                   ; point to next page
 9058   784D   D0 CC       	        bne     FGLOOP                  ; and continue
 9059   784F               	FTNOTFOUND:
 9060   784F   38          	        sec                             ; show not found
 9061   7850               	FTNX:
 9062   7850   8D 08 C0    		sta	ALTZP+MAIN		; back to main mem
 9063   7853   AD 83 C0    		lda	BNK2SET			; back to bank 2
 9064   7856   AD 83 C0    		lda	BNK2SET			; yes please
 9065   7859   90 01       	        bcc     FTNXX                   ; go find it then
 9066   785B   60          	        rts                             ; done
 9067   785C               	FTNXX:
 9068                      	;
 9069                      	; FIND_PICDISK - we have figgered out that the pictures exists somewhere,
 9070                      	;       so parse the passed disk number and go get that disk.
 9071                      	;       First, check to make sure the disk isn't just the other one that
 9072                      	;       is in there.  If it isn't, just use the last one that it is on.
 9073                      	;
 9074                      	;  [Y] = bit 7-2 is the 6 bit disk map
 9075                      	;
 9076   785C               	FIND_PICDISK:
 9077   785C   98          	        tya                             ; get into more useful register        
 9078   785D   4A          	        lsr     A                       ; bring down to lower part
 9079   785E   4A          	        lsr     A                       ; all set up
 9080   785F   8D D4 73    	        sta     P_IDX                   ; save for later looking
 9081   7862   A2 31       	        ldx     #'1'                    ; begin at file 1
 9082   7864   8E DA 73    		stx	PF_NAME+1		; both places
 9083   7867   E8          		inx				; start counter off at 2
 9084   7868   8E D9 73    	        stx     PF_NAME                 ; and save it
 9085   786B   A2 06       	        ldx     #6                      ; 6 possible disks
 9086   786D               	FNDPL:
 9087   786D   6E D4 73    	        ror     P_IDX                   ; put bit into carry
 9088   7870   90 16       	        bcc     FNDPL1                  ; not here
 9089   7872   AD D9 73    	        lda     PF_NAME                 ; get name we are looking at
 9090   7875   8D DA 73    	        sta     PF_NAME+1               ; save found name
 9091   7878   AC 77 46    	        ldy     GAME1NML                ; get name length
 9092   787B   D9 77 46    	        cmp     GAME1NM,Y               ; compare to last char
 9093   787E   F0 0E       	        beq     FNDP1                   ; found it
 9094   7880   AC 89 46    	        ldy     GAME2NML                ; how 'bout in disk 2?
 9095   7883   D9 89 46    	        cmp     GAME2NM,Y               ; well?
 9096   7886   F0 06       	        beq     FNDP1                   ; yes, it's already in there
 9097   7888               	FNDPL1:
 9098   7888   EE D9 73    	        inc     PF_NAME                 ; next name
 9099   788B   CA          	        dex                             ; count down
  Wed Jun  7 1989 12:04                                                                                                  Page  137

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 9100   788C   D0 DF       	        bne     FNDPL                   ; still more to look at
 9101   788E               	FNDP1:
 9102   788E   AD DA 73    	        lda     PF_NAME+1               ; get file name
 9103   7891   29 07       	        and     #$07                    ; make it non-ascii
 9104   7893   A8          	        tay                             ; put in Y for routine
 9105   7894   88          	        dey                             ; and make it zero relative
 9106   7895   4C 2B 79    	        jmp     OPEN_NEW_PF             ; go get it
 9107                      	;
 9108                      	; ZPICNF - YZIP call to get just the picture info
 9109                      	;
 9110   7898               	ZPICNF:
 9111   7898   20 4D 77    		jsr	GET_PICINF		; find the info
 9112   789B   B0 7A       		bcs	ZPICNFX			; not found
 9113                      	;
 9114                      	; being here means we found the picture
 9115                      	;
 9116   789D   A5 65       		lda	ARG2+LO			; lsb is okay
 9117   789F   85 8F       		sta	SPCL			; right
 9118   78A1   A5 66       		lda	ARG2+HI			; get page
 9119   78A3   20 7C 8F    		jsr	SETPC			; get where it is
 9120   78A6   85 90       		sta	SPCH			; hi
 9121   78A8   84 91       		sty	SPCBNK			; bnak
 9122   78AA   A5 64       		lda	ARG1+HI			; get argumnet
 9123   78AC   05 63       		ora	ARG1+LO			; check for zero arg
 9124   78AE   D0 45       		bne	ZPIC1			; okay, get picture data
 9125                      	;
 9126                      	; arg1 == 0, just return number of entries
 9127                      	;
 9128   78B0   8D 09 C0    		sta	ALTZP+AUX		; look at AUX mem
 9129   78B3   AD 8B C0    		lda	BNK1SET 		; bank 1
 9130   78B6   AD 8B C0    		lda	BNK1SET 		; bank 1
 9131   78B9   AD 0C D0    	        lda     PIC_DIR+PHFVERS		; get version number
 9132   78BC   8D D4 73    		sta	P_IDX			; just save here
 9133   78BF   AD 0D D0    	        lda     PIC_DIR+PHFVERS+1	; now for the LSB
 9134   78C2   8D D5 73    		sta	P_BCNT			; and here
 9135   78C5   AC 0A D0    		ldy	PIC_DIR+PHCHKS		; MSB of checksum
 9136   78C8   AD 0B D0    		lda	PIC_DIR+PHCHKS+1	; and LSB
 9137   78CB   8D 08 C0    		sta	ALTZP+MAIN		; back to main mem
 9138   78CE   AE 83 C0    		ldx	BNK2SET			; back to bank 2
 9139   78D1   AE 83 C0    		ldx	BNK2SET			; yes please
 9140   78D4   48          	        pha                             ; save LSB
 9141   78D5   98          	        tya                             ; put MSB into [A]        
 9142   78D6   20 3A 92    		jsr	STASHB			; and save it
 9143   78D9   20 A3 8F    		jsr	NEXTSPC			; point to LSB in table
 9144   78DC   68          	        pla                             ; get LSB back
 9145   78DD   20 3A 92    		jsr	STASHB			; and save it
 9146   78E0   20 A3 8F    		jsr	NEXTSPC			; point to Version number
 9147   78E3   AD D5 73    		lda	P_BCNT			; now for version
 9148   78E6   20 3A 92    		jsr	STASHB			; give it to game
 9149   78E9   20 A3 8F    		jsr	NEXTSPC			; now for LSB
 9150   78EC   AD D4 73    		lda	P_IDX			; this is where it is
 9151   78EF   20 3A 92    		jsr	STASHB			; and away it goes
 9152   78F2   4C 3B 44    		jmp	PREDS			; and show success		
 9153   78F5               	ZPIC1:
 9154   78F5   A9 00       		lda	#0			; height MSB
 9155   78F7   20 3A 92    		jsr	STASHB			; save it too
 9156   78FA   20 A3 8F    		jsr	NEXTSPC			; next byte
 9157   78FD   AD DE 73    		lda	PICINFO+PLDHGHT		; height LSB
 9158   7900   20 3A 92    		jsr	STASHB			; save it too
 9159   7903   20 A3 8F    		jsr	NEXTSPC			; next byte
 9160   7906   A9 00       		lda	#0			; width first
 9161   7908   20 3A 92    		jsr	STASHB			; put it there
 9162   790B   20 A3 8F    		jsr	NEXTSPC			; continue
 9163   790E   AD DD 73    		lda	PICINFO+PLDWID		; LSB of width
 9164   7911   20 3A 92    		jsr	STASHB			; save it too
 9165   7914   4C 3B 44    		jmp	PREDS
 9166   7917               	ZPICNFX:
 9167   7917   4C 2F 44    		JMP	PREDF	; SET AS BAD
 9168   791A               	ZDCLR:
 9169   791A               	ZPICSET:
 9170   791A   60          		rts				; NOT IMPLEMENTED YET
 9171                      	;
 9172                      	; NEXTPICF - Just toggle between files 3/4 for those slim and trim games
 9173                      	;       that have pictures only on those 2 disks.
 9174                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page  138

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 9175   791B               	NEXTPICF:
 9176   791B   A0 03       	        ldy     #3                      ; pretend we want file #4
 9177   791D   AE 89 46    		ldx	GAME2NML		; get length of name
 9178   7920   BD 89 46    		lda	GAME2NM,X		; get last number
 9179   7923   C9 33       		cmp	#'3'			; if 3, then open #4
 9180   7925   F0 01       		beq	NXTPF1			; yes
 9181   7927   88          	        dey                             ; no, so point to 3 then
 9182   7928               	NXTPF1:
 9183   7928   4C 2B 79    	        jmp     OPEN_NEW_PF             ; and open the new pic file
 9184                      	;
 9185                      	; OPEN_NEW_PF - open the file so we can pick up new picture data
 9186                      	;
 9187                      	;   [Y] - # of file to be pointed to (0-n)
 9188                      	;
 9189   792B               	OPEN_NEW_PF:
 9190   792B   A5 1F       		lda	DSEGS+HI		; save current DSEG
 9191   792D   48          		pha
 9192   792E   A5 1E       		lda	DSEGS+LO
 9193   7930   48          		pha
 9194   7931   AD CF 45    		lda	GMREF			; to go back to this one
 9195   7934   48          		pha
 9196                      	;
 9197                      	; now, set up DSEGS to point to correct segment table
 9198                      	;
 9199   7935   98          	        tya                             ; get to muck
 9200   7936   0A          		asl	A		        ; make word index
 9201   7937   AA          		tax			        ; make it an index
 9202   7938   BD D0 1D    		lda	DSKSEG+LO,X	        ; get LSB
 9203   793B   85 1E       		sta	DSEGS+LO
 9204   793D   BD D1 1D    		lda	DSKSEG+HI,X             ; and MSB
 9205   7940   85 1F       		sta	DSEGS+HI
 9206   7942   98          	        tya                             ; point to the new file
 9207   7943   20 C6 49    		jsr	FETCH_FILE		; and do it
 9208   7946   8C D2 73    	        sty     PF_REFNUM               ; save refnum, please
 9209   7949   20 46 76    	        jsr     GO_GET_PDATA            ; just make sure pic data is gotten    
 9210   794C               	OPENPF1:
 9211   794C   68          		pla				; get old ref num back
 9212   794D   8D CF 45    		sta	GMREF			; and for reading
 9213   7950   8D DD 45    		sta	PSEEK+SM_REFNUM 	; this sets it up for set marking
 9214   7953   68          		pla				; get old DSEG back
 9215   7954   85 1E       		sta	DSEGS+LO
 9216   7956   68          		pla
 9217   7957   85 1F       		sta	DSEGS+HI
 9218   7959   18          	        clc                             ; show it worked
 9219   795A   60          		rts
 9220                      	
 9221   795B               		END
 9222                      	
 9223                      	
 9224   795B               		TITLE 	"APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
 9225   795B               		INCLUDE 	OPS012.ASM
 9226   795B               		STTL "--- 0-OPS ---"
 9227                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page  139

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 0-OPS ---"

 9228                      	
 9229                      	
 9230                      	; -----
 9231                      	; RTRUE
 9232                      	; -----
 9233                      	; SIMULATE A "RETURN 1"
 9234                      	
 9235   795B   A2 01       	ZRTRUE:	LDX	#1	
 9236   795D   A9 00       	ZRT0:	LDA	#0	
 9237   795F   86 63       	ZRT1:	STX	ARG1+LO	; GIVE TO
 9238   7961   85 64       		STA	ARG1+HI	; [ARG1]
 9239   7963   4C 5B 7B    		JMP	ZRET	; AND DO THE RETURN
 9240                      	
 9241                      	
 9242                      	; ------
 9243                      	; RFALSE
 9244                      	; ------
 9245                      	; SIMULATE A "RETURN 0"
 9246                      	
 9247   7966   A2 00       	ZRFALS:	LDX	#0	
 9248   7968   F0 F3       		BEQ	ZRT0	
 9249                      	
 9250                      	
 9251                      	; ------
 9252                      	; PRINTI
 9253                      	; ------
 9254                      	; PRINT Z-STRING FOLLOWING THE OPCODE
 9255                      	
 9256   796A   A2 05       	ZPRI:	LDX	#5	;MOVE ZPC INTO MPC
 9257   796C               	ZPRI1:			
 9258   796C   B5 80       		LDA	ZPC,X	
 9259   796E   95 86       		STA	MPC,X	
 9260   7970   CA          		DEX		
 9261   7971   10 F9       		BPL	ZPRI1	;NO NEED TO VALIDATE AS ZPC WAS VALID ANYWAY
 9262   7973   20 D3 92    		JSR	PZSTR	; PRINT THE Z-STRING AT [MPC]
 9263   7976   A2 05       		LDX	#5	; COPY STATE OF [MPC]
 9264   7978   B5 86       	ZPRI2:	LDA	MPC,X	; INTO [ZPC]
 9265   797A   95 80       		STA	ZPC,X	
 9266   797C   CA          		DEX		
 9267   797D   10 F9       		BPL	ZPRI2	
 9268   797F   60          		RTS		
 9269                      	
 9270                      	
 9271                      	; ------
 9272                      	; PRINTR
 9273                      	; ------
 9274                      	; DO A "PRINTI," FOLLOWED BY "CRLF" AND "RTRUE"
 9275                      	
 9276   7980   20 6A 79    	ZPRR:	JSR	ZPRI	
 9277   7983   20 D4 54    		JSR	ZZCRLF	
 9278   7986   4C 5B 79    		JMP	ZRTRUE	
 9279                      	
 9280                      	
 9281                      	; ------
 9282                      	; RSTACK
 9283                      	; ------
 9284                      	; "RETURN" WITH VALUE ON STACK
 9285                      	
 9286   7989   20 66 43    	ZRSTAK:	JSR	POPVAL	; GET VALUE INTO [X/A]
 9287   798C   4C 5F 79    		JMP	ZRT1	; AND GIVE IT TO "RETURN"
 9288                      	
 9289                      	
 9290                      	; -----
 9291                      	; CATCH
 9292                      	; -----
 9293                      	
 9294   798F   AE 7B 6C    	ZCATCH:	LDX	OLDZSP+HI	; RETURN ZSTACK POINTER AS
 9295   7992   AD 7A 6C    		LDA	OLDZSP+LO	; ZRET WILL NEED IT
 9296   7995   4C DD 43    		JMP	PUTBYT
 9297                      	
 9298                      	
 9299                      	; ---------
 9300                      	; ORIGINAL?
 9301                      	; ---------
 9302                      	
  Wed Jun  7 1989 12:04                                                                                                  Page  140

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 0-OPS ---"

 9303                      	; COPY PROTECTION DEVICE, RETURNS TRUE FOR NOW
 9304                      	
 9305   7998   4C 3B 44    	ZORIG:	JMP	PREDS
 9306                      	
 9307                      	
 9308   799B               		STTL "--- 1-OPS ---"
 9309                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page  141

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9310                      	
 9311                      	
 9312                      	; -----
 9313                      	; ZERO?
 9314                      	; -----
 9315                      	; [ARG1] = 0?
 9316                      	
 9317   799B   A5 63       	ZZERO:	LDA	ARG1+LO	
 9318   799D   05 64       		ORA	ARG1+HI	
 9319   799F   F0 37       		BEQ	PFINE	
 9320   79A1   4C 2F 44    	PYUCK:	JMP	PREDF	
 9321                      	
 9322                      	
 9323                      	; -----
 9324                      	; NEXT?
 9325                      	; -----
 9326                      	; RETURN "NEXT" POINTER IN OBJECT [ARG1] ;
 9327                      	; FAIL IF LAST AND RETURN ZERO
 9328                      	
 9329   79A4               	ZNEXT:
 9330   79A4   A5 63       		LDA	ARG1+LO	
 9331   79A6   A6 64       		LDX	ARG1+HI	; (EZIP)
 9332   79A8   20 F1 94    		JSR	OBJLOC	; GET OBJECT ADDR INTO [FPC]
 9333   79AB   A9 08       		lda	#8	; POINT TO "NEXT" SLOT (EZIP)
 9334   79AD   20 E3 8F    		jsr	ADDFPC	; and point to it
 9335   79B0   4C BF 79    		jmp	FIRST1	; JMP to get it
 9336                      	
 9337                      	; ------
 9338                      	; FIRST?
 9339                      	; ------
 9340                      	; RETURN "FIRST" POINTER IN OBJECT [ARG1] ;
 9341                      	; FAIL IF LAST AND RETURN ZERO
 9342                      	; (EZIP ALTERATIONS)
 9343                      	
 9344   79B3               	ZFIRST:
 9345   79B3   A5 63       		lda	ARG1+LO	
 9346   79B5   A6 64       		ldx	ARG1+HI	
 9347   79B7   20 F1 94    		jsr	OBJLOC	; GET OBJECT ADDR INTO [FPC]
 9348   79BA   A9 0A       		lda	#10	; point to "First" slot
 9349   79BC   20 E3 8F    		jsr	ADDFPC	; and add it
 9350   79BF               	FIRST1:
 9351   79BF   20 5B 92    		jsr	FETCHB	; and get it
 9352   79C2   48          		pha		; save it
 9353   79C3   20 C3 8F    		jsr	NEXTFPC
 9354   79C6   20 5B 92    		jsr	FETCHB	; and next one
 9355   79C9   A8          		tay		; now dance around a little; save LSB
 9356   79CA   68          		pla		; get MSB back
 9357   79CB   AA          		tax		; and put to x
 9358   79CC   98          		tya		; and put LSB back into [A]
 9359   79CD   20 DD 43    		jsr	PUTBYT	; PASS IT TO VARIABLE
 9360   79D0   A5 76       		lda	VALUE+LO	; EXAMINE THE VALUE JUST "PUT"
 9361   79D2   D0 04       		bne	PFINE	
 9362   79D4   A5 77       		lda	VALUE+HI	
 9363   79D6   F0 C9       		beq	PYUCK	; FAIL IF IT WAS ZERO
 9364   79D8               	PFINE:
 9365   79D8   4C 3B 44    		jmp	PREDS	; ELSE REJOICE
 9366                      	
 9367                      	; ---
 9368                      	; LOC
 9369                      	; ---
 9370                      	; RETURN THE OBJECT CONTAINING OBJECT [ARG1] ;
 9371                      	; RETURN ZERO IF NONE
 9372                      	; (EZIP ALTERED)
 9373                      	
 9374   79DB               	ZLOC:
 9375   79DB   A5 63       		lda	ARG1+LO	
 9376   79DD   A6 64       		ldx	ARG1+HI	
 9377   79DF   E0 20       		cpx	#$20	; don't let it get too high
 9378   79E1   90 05       		bcc	ZLOC1	; fine
 9379   79E3   A9 16       		lda	#22	; too big object
 9380   79E5   4C 0A 52    		jmp	ZERROR	; and die
 9381   79E8               	ZLOC1:
 9382   79E8   20 F1 94    		jsr	OBJLOC	; GET ADDR OF OBJECT INTO [FPC]
 9383   79EB   A9 06       		lda	#6	; POINT TO "LOC" SLOT
 9384   79ED   20 E3 8F    		jsr	ADDFPC	; and make FPC point there
  Wed Jun  7 1989 12:04                                                                                                  Page  142

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9385   79F0   20 5B 92    		jsr	FETCHB	; go get byte
 9386   79F3   48          		pha		; save this please
 9387   79F4   20 C3 8F    		jsr	NEXTFPC	; and point to next one
 9388   79F7   20 5B 92    		jsr	FETCHB	; and get it in [A]
 9389   79FA   A8          		tay		; save LSB
 9390   79FB   68          		pla		; get MSB back
 9391   79FC   AA          		tax		; and put to [X]
 9392   79FD   98          		tya		; and put LSB into a
 9393   79FE   4C DD 43    		jmp	PUTBYT	; AND SHIP IT OUT
 9394                      	
 9395                      	; ------
 9396                      	; PTSIZE
 9397                      	; ------
 9398                      	; RETURN LENGTH OF PROP TABLE [ARG1] IN BYTES
 9399                      	
 9400   7A01               	ZPTSIZ:
 9401   7A01   A5 64       		lda	ARG1+HI		; MOVE ABS ADDR OF
 9402   7A03   20 7C 8F    		jsr	SETPC		; get bank/page
 9403   7A06   85 8D       		sta	FPCH		; save page
 9404   7A08   84 8E       		sty	FPCBNK		; and bank
 9405   7A0A   A5 63       		lda	ARG1+LO
 9406   7A0C   85 8C       		sta	FPCL		; and save lo part
 9407   7A0E   20 29 90    		jsr	PREVFPC		; Decrement address while moving LSB
 9408   7A11               	PTZ0:
 9409   7A11   20 5B 92    		jsr	FETCHB		; get length of property
 9410   7A14   30 0C       		bmi	PTZ2		; BIT 7 = 1, LENGTH > 2 BYTES
 9411   7A16   29 40       		and	#%01000000
 9412   7A18   F0 04       		beq	PTZ1		; BIT 6 = 0, LENGTH = 1
 9413   7A1A   A9 02       		lda	#2		; BIT 6 = 1, LENGTH = 2
 9414   7A1C   D0 09       		bne	PTZ3		; JMP
 9415   7A1E               	PTZ1:
 9416   7A1E   A9 01       		lda	#1
 9417   7A20   D0 05       		bne	PTZ3		; JMP
 9418   7A22               	PTZ2:
 9419   7A22   20 5B 92    		jsr	FETCHB		; and get it
 9420   7A25   29 3F       		and	#%00111111	; ELSE PICK UP SIZE > 2
 9421   7A27               	PTZ3:
 9422   7A27   A2 00       		ldx	#0		; CLEAR FOR PUTBYT
 9423   7A29   4C DD 43    		jmp	PUTBYT
 9424                      	; ---
 9425                      	; INC
 9426                      	; ---
 9427                      	; INCREMENT VARIABLE [ARG1]
 9428                      	
 9429   7A2C   A5 63       	ZINC:	LDA	ARG1+LO	
 9430   7A2E   20 36 43    		JSR	VARGET	; FETCH VARIABLE INTO [VALUE]
 9431   7A31   E6 76       		INC	VALUE+LO
 9432   7A33   D0 02       		BNE	ZINC1
 9433   7A35   E6 77       		INC	VALUE+HI
 9434   7A37   4C 4C 7A    	ZINC1:	JMP	ZD0
 9435                      	
 9436                      	
 9437                      	; ---
 9438                      	; DEC
 9439                      	; ---
 9440                      	; DECREMENT VARIABLE [ARG1]
 9441                      	
 9442   7A3A   A5 63       	ZDEC:	LDA	ARG1+LO	
 9443   7A3C   20 36 43    		JSR	VARGET	; FETCH VAR INTO [VALUE]
 9444   7A3F   A5 76       		LDA	VALUE+LO	
 9445   7A41   38          		SEC		
 9446   7A42   E9 01       		SBC	#1	
 9447   7A44   85 76       		STA	VALUE+LO	
 9448   7A46   A5 77       		LDA	VALUE+HI	
 9449   7A48   E9 00       		SBC	#0	
 9450   7A4A   85 77       		STA	VALUE+HI	
 9451   7A4C   A5 63       	ZD0:	LDA	ARG1+LO	; PUT RESULT BACK
 9452   7A4E   4C C7 43    		JMP	VARPUT	; INTO THE SAME VARIABLE
 9453                      	
 9454                      	
 9455                      	; ------
 9456                      	; PRINTB
 9457                      	; ------
 9458                      	; PRINT Z-STRING AT [ARG1]
 9459                      	
  Wed Jun  7 1989 12:04                                                                                                  Page  143

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9460   7A51               	ZPRB:
 9461   7A51   A5 63       		lda	ARG1+LO		; move arg1 to I
 9462   7A53   85 78       		sta	I+LO		; lo part
 9463   7A55   A5 64       		lda	ARG1+HI		; and now for arg1 hi
 9464   7A57   85 79       		sta	I+HI		; okay
 9465   7A59   20 65 8F    		jsr	SETWRD		; make [MPC] point to it
 9466   7A5C   4C D3 92    		jmp	PZSTR		; and print it
 9467                      	
 9468                      	; ------
 9469                      	; REMOVE
 9470                      	; ------
 9471                      	; MOVE OBJECT [ARG1] INTO PSEUDO-OBJECT #0
 9472                      	; (EZIP CHANGES - 1) OBJLOC NEEDS HI & LO
 9473                      	; 2) MOVES AND COMPARES 2 BYTES)
 9474                      	
 9475   7A5F               	SAVEFPC: ds	3	; spot to save the FPC
 9476   7A62               	SAVEOBJ: ds     1       ; check for zero object
 9477                      	
 9478   7A63               	ZREMOV:
 9479   7A63   A5 63       		lda	ARG1+LO	; GET SOURCE OBJECT ADDR
 9480   7A65   A6 64       		ldx	ARG1+HI	
 9481   7A67   20 F1 94    		jsr	OBJLOC	; INTO [FPC]
 9482                      	;
 9483                      	; now save this objects address in I,J
 9484                      	;
 9485   7A6A   A9 06       		lda	#6	; point to the LOC slot
 9486   7A6C   20 E3 8F    		jsr	ADDFPC	; thank you
 9487   7A6F   A5 8C       		lda	FPCL	; COPY THE SOURCE ADDR
 9488   7A71   8D 5F 7A    		sta	SAVEFPC+LO	; INTO [J]
 9489   7A74   A5 8D       		lda	FPCH	; FOR LATER REFERENCE
 9490   7A76   8D 60 7A    		sta	SAVEFPC+HI
 9491   7A79   A5 8E       		lda	FPCBNK
 9492   7A7B   8D 61 7A    		sta	SAVEFPC+ABANK
 9493                      	;
 9494                      	; now go get object this one is in
 9495                      	;		
 9496   7A7E   20 5B 92    		jsr	FETCHB	; get the data
 9497   7A81   85 7C       		sta	K	; HOLD IT
 9498   7A83   20 C3 8F    		jsr	NEXTFPC	; get lo part
 9499   7A86   20 5B 92    		jsr	FETCHB	; now get part
 9500   7A89   A8          		tay		; save it
 9501   7A8A   05 7C       		ora	K	; COMPARE BYTES
 9502   7A8C   D0 03       		bne	REMVj	; check for object
 9503   7A8E   4C 33 7B    		jmp	REMVEX	; SCRAM IF NO OBJECT
 9504   7A91               	REMVj:
 9505   7A91   98          		tya		; get lo part
 9506   7A92   A6 7C       		ldx	K	; and hi part
 9507   7A94   20 F1 94    		jsr	OBJLOC	; ELSE GET ADDR OF OBJECT [A] INTO [FPC]
 9508   7A97   A9 0B       		lda	#11	; POINT TO "FIRST" SLOT, LSB
 9509   7A99   20 E3 8F    		jsr	ADDFPC	; and point to it
 9510   7A9C   20 5B 92    		jsr	FETCHB	; and get it
 9511   7A9F   48          		pha		; save LSB
 9512   7AA0   20 29 90    		jsr	PREVFPC	; point to MSB
 9513   7AA3   20 5B 92    		jsr	FETCHB	; A=LO, X=HI
 9514   7AA6   AA          		tax		; put into x
 9515   7AA7   68          		pla		; get LSB back
 9516   7AA8   C5 63       		cmp	ARG1+LO	; IS THIS THE FIRST?
 9517   7AAA   D0 04       		bne	REMVC1	; NO, KEEP SEARCHING
 9518   7AAC   E4 64       		cpx	ARG1+HI	; HM?
 9519   7AAE   F0 2B       		beq	DO_REMOVE ; yes, so use it
 9520   7AB0               	REMVC1:
 9521   7AB0   20 F1 94    		jsr	OBJLOC	; get object
 9522   7AB3   A9 09       		lda	#9	; GET "NEXT" slot address
 9523   7AB5   20 E3 8F    		jsr	ADDFPC	; into FPC
 9524   7AB8   20 5B 92    		jsr	FETCHB	; get the byte
 9525   7ABB   48          		pha		; save LSB for later
 9526   7ABC   20 29 90    		jsr	PREVFPC	; and this is the hi part
 9527   7ABF   20 5B 92    		jsr	FETCHB
 9528   7AC2   8D 62 7A    	        sta     SAVEOBJ ; save for later check
 9529   7AC5   AA          		tax		; and put into x for (possible) check
 9530   7AC6   68          		pla		; get lo part back
 9531   7AC7   A8          	        tay             ; save a minute
 9532   7AC8   0D 62 7A    	        ora     SAVEOBJ ; well, is it zero?
 9533   7ACB   D0 05       	        bne     REMVC2  ; no, so check it
 9534   7ACD   A9 15       	        lda     #21     ; so die
  Wed Jun  7 1989 12:04                                                                                                  Page  144

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9535   7ACF   4C 0A 52    	        jmp     ZERROR  ; and croak
 9536   7AD2               	REMVC2:
 9537   7AD2   98          	        tya             ; put back into [A]
 9538   7AD3   C5 63       		cmp	ARG1+LO	; FOUND IT?
 9539   7AD5   D0 D9       		bne	REMVC1	; NO, KEEP TRYING
 9540   7AD7   E4 64       		cpx	ARG1+HI	
 9541   7AD9   D0 D5       		bne	REMVC1	
 9542   7ADB               	DO_REMOVE:
 9543                      	;
 9544                      	; now, copy from FPC to SPC for stashing away
 9545                      	;
 9546   7ADB   20 78 90    		jsr	FP2SP	; copied
 9547                      	;
 9548                      	; now get removed one's address for fetching
 9549                      	;
 9550   7ADE   AD 61 7A    		lda	SAVEFPC+ABANK	; this is where bank is
 9551   7AE1   85 8E       		sta	FPCBNK	; so show it
 9552   7AE3   AD 60 7A    		lda	SAVEFPC+HI	; and here's the hi/lo part
 9553   7AE6   85 8D       		sta	FPCH
 9554   7AE8   AD 5F 7A    		lda	SAVEFPC+LO
 9555   7AEB   85 8C       		sta	FPCL
 9556   7AED   A9 02       		lda	#2	; so get to source's "NEXT" slot
 9557   7AEF   20 E3 8F    		jsr	ADDFPC	; point to next slot
 9558   7AF2   20 5B 92    		jsr	FETCHB	; get the hi byte
 9559   7AF5   20 3A 92    		jsr	STASHB	; and save it
 9560   7AF8   20 A3 8F    		jsr	NEXTSPC	; point to next one
 9561   7AFB   20 C3 8F    		jsr	NEXTFPC	; and from the source too
 9562   7AFE   20 5B 92    		jsr	FETCHB	; get lo byte
 9563   7B01   20 3A 92    		jsr	STASHB	; and save it away
 9564                      	;
 9565                      	; now zero out SOURCE's loc and next spots
 9566                      	;
 9567   7B04   AD 61 7A    		lda	SAVEFPC+ABANK	; bank of source
 9568   7B07   85 91       		sta	SPCBNK
 9569   7B09   AD 60 7A    		lda	SAVEFPC+HI	; and addr of source LOC slot
 9570   7B0C   85 90       		sta	SPCH
 9571   7B0E   AD 5F 7A    		lda	SAVEFPC+LO
 9572   7B11   85 8F       		sta	SPCL	
 9573                      	;
 9574                      	; zero out NEXT and LOC of source
 9575                      	;
 9576   7B13   A9 00       		lda	#0	; zero out 4 locations (LOC MSB)
 9577   7B15   20 3A 92    		jsr	STASHB
 9578   7B18   20 A3 8F    		jsr	NEXTSPC
 9579   7B1B               		
 9580   7B1B   A9 00       		lda	#0	; zero out 4 locations (LOC LSB)
 9581   7B1D   20 3A 92    		jsr	STASHB
 9582   7B20   20 A3 8F    		jsr	NEXTSPC
 9583   7B23               		
 9584   7B23   A9 00       		lda	#0	; zero out 4 locations (NEXT MSB)
 9585   7B25   20 3A 92    		jsr	STASHB
 9586   7B28   20 A3 8F    		jsr	NEXTSPC
 9587   7B2B               		
 9588   7B2B   A9 00       		lda	#0	; zero out 4 locations (NEXT LSB)
 9589   7B2D   20 3A 92    		jsr	STASHB
 9590   7B30   20 A3 8F    		jsr	NEXTSPC
 9591   7B33               	REMVEX:
 9592   7B33   60          		RTS		
 9593                      	
 9594                      	
 9595                      	; ------
 9596                      	; PRINTD
 9597                      	; ------
 9598                      	; PRINT SHORT DESCRIPTION OF OBJECT [ARG1]
 9599                      	
 9600   7B34               	ZPRD:
 9601   7B34   A5 63       		lda	ARG1+LO	
 9602   7B36   A6 64       		ldx	ARG1+HI	; (EZIP)
 9603   7B38   20 F1 94    		jsr	OBJLOC	; GET ADDR OF OBJECT INTO [FPC]
 9604   7B3B   A9 0D       		lda	#13	; GET PROP TABLE POINTER (EZIP)
 9605   7B3D   20 E3 8F    		jsr	ADDFPC	; and point to LSB
 9606   7B40   20 5B 92    		jsr	FETCHB	; fetch LSB
 9607   7B43   48          		pha		; SAVE IT HERE
 9608   7B44   20 29 90    		jsr	PREVFPC	; and now fetch MSB
 9609   7B47   20 5B 92    		jsr	FETCHB	; thank you
  Wed Jun  7 1989 12:04                                                                                                  Page  145

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9610   7B4A   85 79       		sta	I+HI	; AND MSB
 9611   7B4C   68          		pla		; get LSB back
 9612   7B4D   85 78       		sta	I+LO	; STORE LSB
 9613   7B4F   E6 78       		inc	I+LO	; POINT PAST THE
 9614   7B51   D0 02       		bne	PDC0	; LENGTH BYTE
 9615   7B53   E6 79       		inc	I+HI	
 9616   7B55   20 65 8F    	PDC0:	jsr	SETWRD	; CALC Z-STRING ADDR
 9617   7B58   4C D3 92    		jmp	PZSTR	; AND PRINT IT
 9618                      	
 9619                      	
 9620                      	; ------
 9621                      	; RETURN
 9622                      	; ------
 9623                      	; RETURN FROM "CALL" WITH VALUE [ARG1]
 9624                      	
 9625   7B5B               	ZRET:
 9626   7B5B   AD 7A 6C    		LDA	OLDZSP+LO	; RE-SYNC THE
 9627   7B5E   85 AF       		STA	ZSP+LO		; Z-STACK POINTER
 9628   7B60   AD 7B 6C    		LDA	OLDZSP+HI
 9629   7B63   85 B0       		STA	ZSP+HI
 9630   7B65   20 66 43    		JSR	POPVAL		; POP # LOCALS INTO [X/A]
 9631   7B68   86 79       		STX	I+HI		; SAVE HERE
 9632   7B6A   20 66 43    		JSR	POPVAL		; now we need number of args
 9633   7B6D   8D 68 5B    		STA	ASSVLU		; for ASSIGNED?
 9634                      	
 9635   7B70   A6 79       		LDX	I+HI		; see how many locals
 9636   7B72   F0 19       		BEQ	RET2		; SKIP IF NOT
 9637                      	
 9638                      		; RESTORE PUSHED LOCALS
 9639                      	
 9640   7B74   CA          		DEX			; ZERO-ALIGN
 9641   7B75   8A          		TXA			; AND
 9642   7B76   0A          		ASL	A		; WORD-ALIGN # LOCALS
 9643   7B77   85 78       		STA	I+LO		; FOR USE AS A STORAGE INDEX
 9644   7B79   20 66 43    	RET1:	JSR	POPVAL		; POP A LOCAL INTO [X/A]
 9645   7B7C   A4 78       		LDY	I+LO		; RETRIEVE STORAGE INDEX
 9646   7B7E   99 01 1E    		STA	LOCALS+HI,Y	; STORE MSB OF LOCAL
 9647   7B81   8A          		TXA			; MOVE LSB
 9648   7B82   99 00 1E    		STA	LOCALS+LO,Y	; AND STORE THAT TOO
 9649   7B85   C6 78       		DEC	I+LO
 9650   7B87   C6 78       		DEC	I+LO		; UPDATE STORAGE INDEX
 9651   7B89   C6 79       		DEC	I+HI		; AND LOCALS COUNT
 9652   7B8B   D0 EC       		BNE	RET1		; POP TILL NO MORE LOCALS
 9653                      	
 9654                      		; RESTORE OTHER VARIABLES
 9655                      	
 9656   7B8D               	RET2:
 9657   7B8D   20 66 43    		JSR	POPVAL		; POP [ZPCH] AND [ZPCM]
 9658   7B90   86 81       		STX	ZPCM
 9659   7B92   85 82       		STA	ZPCH
 9660   7B94   20 66 43    		JSR	POPVAL		; POP AND RESTORE
 9661   7B97   8E 64 5B    		STX	IRET
 9662   7B9A   85 80       		STA	ZPCL
 9663   7B9C   20 66 43    		JSR	POPVAL
 9664   7B9F   8E 7A 6C    		STX	OLDZSP+LO
 9665   7BA2   8D 7B 6C    		STA	OLDZSP+HI
 9666                      	
 9667   7BA5   A5 80       		LDA	ZPCL		; check for zero zpc
 9668   7BA7   D0 0E       		BNE	RETj		; which means we are returning to
 9669   7BA9   A5 81       		LDA	ZPCM		; an internal call
 9670   7BAB   D0 0A       		BNE	RETj		; rather than just a normal
 9671   7BAD   A5 82       		LDA	ZPCH		; return
 9672   7BAF   D0 06       		BNE	RETj		; but so far it isn't
 9673                      	
 9674   7BB1   20 B4 44    		JSR	A12VAL		; MOVE [ARG1] TO [VALUE]
 9675   7BB4   4C 47 5B    		JMP	ZIRET		; so then do internal return
 9676   7BB7               	RETj:
 9677   7BB7   20 AF 90    		JSR	VLDZPC		; MAKE VALID
 9678   7BBA   AD 64 5B    		LDA	IRET		; CHECK IF SHOULD RETURN A VALUE
 9679   7BBD   F0 01       		BEQ	RETYES		; (0 = RET, 1  = NO RETURN)
 9680   7BBF   60          		RTS			; NO, SO JUST GET OUT OF HERE
 9681   7BC0               	RETYES:
 9682   7BC0   20 B4 44    		JSR	A12VAL		; MOVE [ARG1] TO [VALUE]
 9683   7BC3   4C E1 43    		JMP	PUTVAL		; AND RETURN IT
 9684                      	
  Wed Jun  7 1989 12:04                                                                                                  Page  146

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9685                      	
 9686                      	; ----
 9687                      	; JUMP
 9688                      	; ----
 9689                      	; JUMP  TO Z-LOCATION IN [ARG1]
 9690                      	
 9691   7BC6   20 B4 44    	ZJUMP:	JSR	A12VAL	; MOVE [ARG1] TO [VALUE]
 9692   7BC9   4C 75 44    		JMP	PREDB3	; A BRANCH THAT ALWAYS SUCCEEDS
 9693                      	
 9694                      	
 9695                      	; -----
 9696                      	; PRINT
 9697                      	; -----
 9698                      	; PRINT Z-STRING AT WORD (QUAD) POINTER [ARG1]
 9699                      	
 9700   7BCC               	ZPRINT:
 9701   7BCC   A5 63       		LDA	ARG1+LO	
 9702   7BCE   85 78       		STA	I+LO	
 9703   7BD0   A5 64       		LDA	ARG1+HI	
 9704   7BD2   85 79       		STA	I+HI	
 9705   7BD4   20 A5 92    		JSR	SETSTR	; CALC STRING ADDRESS
 9706   7BD7   4C D3 92    		JMP	PZSTR	; AND PRINT IT
 9707                      	
 9708                      	
 9709                      	; -----
 9710                      	; VALUE
 9711                      	; -----
 9712                      	; RETURN VALUE OF VARIABLE [ARG1]
 9713                      	
 9714   7BDA               	ZVALUE:
 9715   7BDA   A5 63       		LDA	ARG1+LO	
 9716   7BDC   20 36 43    		JSR	VARGET	; GET THE VALUE
 9717   7BDF   4C E1 43    		JMP	PUTVAL	; EASY ENOUGH
 9718                      	
 9719                      	
 9720                      	
 9721   7BE2               		STTL "--- 2-OPS ---"
 9722                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page  147

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

 9723                      	
 9724                      	
 9725                      	; -----
 9726                      	; LESS?
 9727                      	; -----
 9728                      	; [ARG1] < [ARG2]?
 9729                      	
 9730   7BE2               	ZLESS:
 9731   7BE2   20 B4 44    		JSR	A12VAL	; MOVE [ARG1] TO [VALUE]
 9732   7BE5   4C EB 7B    		JMP	DLS0	; MOVE [ARG2] TO [I] & COMPARE
 9733                      	
 9734                      	
 9735                      	; ------
 9736                      	; DLESS?
 9737                      	; ------
 9738                      	; DECREMENT [ARG1] ; SUCCEED IF < [ARG2]
 9739                      	
 9740   7BE8               	ZDLESS:
 9741   7BE8   20 3A 7A    		JSR	ZDEC	; MOVES ([ARG1]-1) TO [VALUE]
 9742   7BEB   A5 65       	DLS0:	LDA	ARG2+LO	; MOVE [ARG2] TO [I]
 9743   7BED   85 78       		STA	I+LO	
 9744   7BEF   A5 66       		LDA	ARG2+HI	
 9745   7BF1   85 79       		STA	I+HI	
 9746   7BF3   4C 14 7C    		JMP	COMPAR	; COMPARE & RETURN
 9747                      	
 9748                      	
 9749                      	; -----
 9750                      	; GRTR?
 9751                      	; -----
 9752                      	; [ARG1] < [ARG2]?
 9753                      	
 9754   7BF6   A5 63       	ZGRTR:	LDA	ARG1+LO	; MOVE [ARG1] TO [I]
 9755   7BF8   85 78       		STA	I+LO	
 9756   7BFA   A5 64       		LDA	ARG1+HI	
 9757   7BFC   85 79       		STA	I+HI	
 9758   7BFE   4C 0C 7C    		JMP	A2VAL	; MOVE [ARG2] TO [VALUE] & COMPARE
 9759                      	
 9760                      	
 9761                      	; ------
 9762                      	; IGRTR?
 9763                      	; ------
 9764                      	; INCREMENT [ARG1] ; SUCCEED IF GREATER THAN [ARG2]
 9765                      	
 9766   7C01   20 2C 7A    	ZIGRTR:	JSR	ZINC	; GET ([ARG1]+1) INTO [VALUE]
 9767   7C04   A5 76       		LDA	VALUE+LO	; MOVE [VALUE] TO [I]
 9768   7C06   85 78       		STA	I+LO	
 9769   7C08   A5 77       		LDA	VALUE+HI	
 9770   7C0A   85 79       		STA	I+HI	
 9771   7C0C   A5 65       	A2VAL:	LDA	ARG2+LO	; MOVE [ARG2] TO [VALUE]
 9772   7C0E   85 76       		STA	VALUE+LO	
 9773   7C10   A5 66       		LDA	ARG2+HI	
 9774   7C12   85 77       		STA	VALUE+HI	
 9775                      	
 9776                      	
 9777                      	; -----------------
 9778                      	; SIGNED COMPARISON
 9779                      	; -----------------
 9780                      	; ENTRY: VALUES IN [VALUE] AND [I]
 9781                      	;
 9782                      	;  IS [VALUE] > [I]
 9783                      	;
 9784   7C14               	COMPAR:
 9785   7C14   A5 79       		LDA	I+HI
 9786   7C16   45 77       		EOR	VALUE+HI
 9787   7C18   10 09       		BPL	SCMP
 9788   7C1A   A5 79       		LDA	I+HI
 9789   7C1C   C5 77       		CMP	VALUE+HI
 9790   7C1E   90 42       		BCC	PGOOD
 9791   7C20   4C 2F 44    		JMP	PREDF
 9792                      	
 9793   7C23   A5 77       	SCMP:	LDA	VALUE+HI
 9794   7C25   C5 79       		CMP	I+HI
 9795   7C27   D0 04       		BNE	SCEX
 9796   7C29   A5 76       		LDA	VALUE+LO
 9797   7C2B   C5 78       		CMP	I+LO
  Wed Jun  7 1989 12:04                                                                                                  Page  148

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

 9798   7C2D   90 33       	SCEX:	BCC	PGOOD
 9799   7C2F   4C 2F 44    		JMP	PREDF
 9800                      	
 9801                      	
 9802                      	; ---
 9803                      	; IN?
 9804                      	; ---
 9805                      	; IS OBJECT [ARG1] CONTAINED IN OBJECT [ARG2]?
 9806   7C32               	ZIN:
 9807   7C32   A5 63       		LDA	ARG1+LO	
 9808   7C34   A6 64       		LDX	ARG1+HI	
 9809   7C36   20 F1 94    		JSR	OBJLOC	; GET ADDR OF TARGET OBJECT INTO [FPC]
 9810   7C39   A9 06       		LDA	#6	; POINT TO "LOC" SLOT
 9811   7C3B   20 E3 8F    		jsr	ADDFPC	; and point to it
 9812   7C3E   20 5B 92    		jsr	FETCHB	; well?
 9813   7C41   C5 66       		CMP	ARG2+HI	; IS IT THERE?
 9814   7C43   D0 0A       		BNE	PBAD	; NO
 9815   7C45   20 C3 8F    		jsr	NEXTFPC	; point to lo part
 9816   7C48   20 5B 92    		jsr	FETCHB	; and get it
 9817   7C4B   C5 65       		CMP	ARG2+LO	
 9818   7C4D   F0 13       		BEQ	PGOOD	; YES, SUCCEED
 9819   7C4F   4C 2F 44    	PBAD:	JMP	PREDF	; TOO BAD, CHUM ...
 9820                      	
 9821                      	
 9822                      	; ----
 9823                      	; BTST
 9824                      	; ----
 9825                      	; IS EVERY "ON" BIT IN [ARG1]
 9826                      	; ALSO "ON" IN [ARG2]?
 9827                      	
 9828   7C52   A5 65       	ZBTST:	LDA	ARG2+LO	; FIRST CHECK LSBS
 9829   7C54   25 63       		AND	ARG1+LO	
 9830   7C56   C5 65       		CMP	ARG2+LO	; LSBS MATCH?
 9831   7C58   D0 F5       		BNE	PBAD	; NO, EXIT NOW
 9832   7C5A   A5 66       		LDA	ARG2+HI	; ELSE CHECK MSBS
 9833   7C5C   25 64       		AND	ARG1+HI	
 9834   7C5E   C5 66       		CMP	ARG2+HI	; MATCHED?
 9835   7C60   D0 ED       		BNE	PBAD	; SORRY ...
 9836   7C62               	PGOOD:
 9837   7C62   4C 3B 44    		JMP	PREDS	
 9838                      	
 9839                      	
 9840                      	; ---
 9841                      	; BOR
 9842                      	; ---
 9843                      	; RETURN [ARG1] "OR" [ARG2]
 9844                      	
 9845   7C65   A5 63       	ZBOR:	LDA	ARG1+LO	
 9846   7C67   05 65       		ORA	ARG2+LO	
 9847   7C69   AA          		TAX		
 9848   7C6A   A5 64       		LDA	ARG1+HI	
 9849   7C6C   05 66       		ORA	ARG2+HI	
 9850                      	
 9851                      		; FALL THROUGH ...
 9852                      	
 9853                      	
 9854                      	; ---------------------
 9855                      	; RETURN VALUE IN [X/A]
 9856                      	; ---------------------
 9857                      	
 9858   7C6E   86 76       	VEXIT:	STX	VALUE+LO
 9859   7C70   85 77       		STA	VALUE+HI
 9860   7C72   4C E1 43    		JMP	PUTVAL
 9861                      	
 9862                      	
 9863                      	; ----
 9864                      	; BAND
 9865                      	; ----
 9866                      	; RETURN [ARG1] "AND" [ARG2]
 9867                      	
 9868   7C75   A5 63       	ZBAND:	LDA	ARG1+LO	
 9869   7C77   25 65       		AND	ARG2+LO	
 9870   7C79   AA          		TAX		
 9871   7C7A   A5 64       		LDA	ARG1+HI	
 9872   7C7C   25 66       		AND	ARG2+HI	
  Wed Jun  7 1989 12:04                                                                                                  Page  149

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

 9873   7C7E   4C 6E 7C    		JMP	VEXIT	
 9874                      	
 9875                      	
 9876                      	; -----
 9877                      	; FSET?
 9878                      	; -----
 9879                      	; IS FLAG [ARG2] SET IN OBJECT [ARG1]?
 9880                      	
 9881   7C81   20 80 95    	ZFSETP:	JSR	FLAGSU	; GET BITS INTO [K] AND [J]
 9882   7C84   A5 7D       		LDA	K+HI	; DO MSBS
 9883   7C86   25 7B       		AND	J+HI	
 9884   7C88   85 7D       		STA	K+HI	
 9885   7C8A   A5 7C       		LDA	K+LO	; DO LSBS
 9886   7C8C   25 7A       		AND	J+LO	
 9887   7C8E   05 7D       		ORA	K+HI	; ANY BITS ON?
 9888   7C90   D0 D0       		BNE	PGOOD	; TARGET BIT MUST BE ON
 9889   7C92   4C 2F 44    		JMP	PREDF	
 9890                      	
 9891                      	
 9892                      	; ----
 9893                      	; FSET
 9894                      	; ----
 9895                      	; SET FLAG [ARG2] IN OBJECT [ARG1]
 9896                      	
 9897   7C95               	ZFSET:
 9898   7C95   20 80 95    		JSR	FLAGSU	; GET BITS INTO [K] & [J], ADDR IN [FPC]
 9899                      	;
 9900                      	; now, copy from FPC to SPC for stashing away
 9901                      	;
 9902   7C98   20 78 90    		jsr	FP2SP	; okay, done it
 9903   7C9B   A5 7D       		lda	K+HI	; FIRST DO MSBS
 9904   7C9D   05 7B       		ora	J+HI	
 9905   7C9F   20 3A 92    		jsr	STASHB
 9906   7CA2   20 A3 8F    		jsr	NEXTSPC
 9907   7CA5   A5 7C       		lda	K+LO	; THEN LSBS
 9908   7CA7   05 7A       		ora	J+LO	
 9909   7CA9   20 3A 92    		jsr	STASHB
 9910   7CAC   60          		rts
 9911                      	
 9912                      	
 9913                      	; ------
 9914                      	; FCLEAR
 9915                      	; ------
 9916                      	; CLEAR FLAG [ARG2] IN OBJECT [ARG1]
 9917                      	
 9918   7CAD               	ZFCLR:
 9919   7CAD   20 80 95    		jsr	FLAGSU	; GETS BITS INTO [J] & [K], ADDR IN [FPC]
 9920                      	;
 9921                      	; now, copy from FPC to SPC for stashing away
 9922                      	;
 9923   7CB0   20 78 90    		jsr	FP2SP	; okey dokey
 9924                      	
 9925   7CB3   A5 7B       		lda	J+HI	; FETCH MSB
 9926   7CB5   49 FF       		eor	#$FF	; COMPLEMENT IT
 9927   7CB7   25 7D       		and	K+HI	; RUB OUT FLAG
 9928   7CB9   20 3A 92    		jsr	STASHB	; and save it
 9929   7CBC   20 A3 8F    		jsr	NEXTSPC	; point to lo part
 9930   7CBF   A5 7A       		lda	J+LO	; SAME FOR LSB
 9931   7CC1   49 FF       		eor	#$FF	
 9932   7CC3   25 7C       		and	K+LO	
 9933   7CC5   20 3A 92    		jsr	STASHB	; and show it to the world
 9934   7CC8   60          		rts
 9935                      	
 9936                      	
 9937                      	; ---
 9938                      	; SET
 9939                      	; ---
 9940                      	; SET VARIABLE [ARG1] EQUAL TO [ARG2]
 9941                      	
 9942   7CC9   A5 65       	ZSET:	LDA	ARG2+LO	; MOVE THE VALUE
 9943   7CCB   85 76       		STA	VALUE+LO	; INTO [VALUE]
 9944   7CCD   A5 66       		LDA	ARG2+HI	
 9945   7CCF   85 77       		STA	VALUE+HI	
 9946   7CD1   A5 63       		LDA	ARG1+LO	; GET VARIABLE ID
 9947   7CD3   4C C7 43    		JMP	VARPUT	; AND CHANGE THE VARIABLE
  Wed Jun  7 1989 12:04                                                                                                  Page  150

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

 9948                      	
 9949                      	
 9950                      	; ----
 9951                      	; MOVE
 9952                      	; ----
 9953                      	; MOVE OBJECT [ARG1] INTO OBJECT [ARG2]
 9954                      	; (EZIP - EXPANDED FROM BYTE OBJECTS TO WORD OBJECTS)
 9955                      	
 9956   7CD6               	ZMOVE:
 9957   7CD6   20 63 7A    		jsr	ZREMOV		; REMOVE FIRST - CUT ARG1 OUT OF WHERE IT IS
 9958                      	;
 9959                      	; Make [ARG1] be first in [ARG2]'s chain.
 9960                      	;
 9961   7CD9   A5 65       		lda	ARG2+LO	
 9962   7CDB   A6 66       		ldx	ARG2+HI		; Get parent's address
 9963   7CDD   20 F1 94    		jsr	OBJLOC		; into [FPC]
 9964   7CE0   A9 0A       		lda	#10		; point to FIRST slot
 9965   7CE2   20 E3 8F    		jsr	ADDFPC		; okay
 9966   7CE5   20 5B 92    		jsr	FETCHB		; get old first one (MSB)
 9967   7CE8   85 7D       		sta	K+HI		; save it
 9968   7CEA   20 C3 8F    		jsr	NEXTFPC		; point to next part
 9969   7CED   20 5B 92    		jsr	FETCHB		; and get it
 9970   7CF0   85 7C       		sta	K+LO		; okay, saved
 9971   7CF2   20 78 90    		jsr	FP2SP		; make FPC == SPC
 9972                      	;
 9973                      	; now make object [ARG1] be first in object [ARG2]
 9974                      	; SPC is currently pointing to LSB of [ARG2]'s FIRST slot
 9975                      	;
 9976   7CF5   A5 63       		lda	ARG1+LO		; stash away low part first
 9977   7CF7   20 3A 92    		jsr	STASHB		; stashed
 9978   7CFA   20 53 90    		jsr	PREVSPC		; point to high part
 9979   7CFD   A5 64       		lda	ARG1+HI		; get hi part of source
 9980   7CFF   20 3A 92    		jsr	STASHB		; save it
 9981                      	;
 9982                      	; now point to object [ARG1] to update its slots
 9983                      	;
 9984   7D02   A6 64       		ldx	ARG1+HI		; put hi part here
 9985   7D04   A5 63       		lda	ARG1+LO		; and lo part here for OBJLOC
 9986   7D06   20 F1 94    		jsr	OBJLOC		; get me the SOURCE of all confusion
 9987   7D09   A9 06       		lda	#6		; point to LOC slot
 9988   7D0B   20 E3 8F    		jsr	ADDFPC		; and now FPC points there
 9989   7D0E   20 78 90    		jsr	FP2SP		; now make it the STASH pointer
 9990                      	;
 9991                      	; update [ARG1]s LOC pointer to be [ARG2]
 9992                      	; SPC points to LOC slot
 9993                      	;
 9994   7D11   A5 66       		lda	ARG2+HI		; get PARENT number
 9995   7D13   20 3A 92    		jsr	STASHB		; and save it in LOC
 9996   7D16   20 A3 8F    		jsr	NEXTSPC		; and point to LSB of LOC
 9997   7D19   A5 65       		lda	ARG2+LO		; got parent's lowness
 9998   7D1B   20 3A 92    		jsr	STASHB		; and saved it in ARG1
 9999                      	;
10000                      	; Move old FIRST object and make it [ARG1]s NEXT
10001                      	; now SPC points to [ARG1]s NEXT slot
10002                      	;
10003   7D1E   20 A3 8F    		jsr	NEXTSPC		; point to MSB of NEXT
10004   7D21   A5 7D       		lda	K+HI		; get old FIRST one
10005   7D23   20 3A 92    		jsr	STASHB	; and save it
10006   7D26   20 A3 8F    		jsr	NEXTSPC	; and point to LSB now
10007   7D29   A5 7C       		lda	K+LO	; get LSB of this
10008   7D2B   20 3A 92    		jsr	STASHB	; saved
10009   7D2E   60          		rts
10010                      	
10011                      	; ---
10012                      	; GET
10013                      	; ---
10014                      	; RETURN ITEM [ARG2] IN WORD-TABLE [ARG1]
10015                      	
10016   7D2F               	ZGET:
10017   7D2F   20 46 7D    		JSR	WCALC		; CALC ADDRESS
10018   7D32   20 0E 92    		JSR	GETBYT		; GET 1ST BYTE (MSB)
10019   7D35   85 77       	DOGET:	STA	VALUE+HI	; SAVE MSB
10020   7D37   20 0E 92    		JSR	GETBYT		; GET LSB
10021   7D3A   85 76       		STA	VALUE+LO	; SAVE AND
10022   7D3C   4C E1 43    		jmp	PUTVAL		; HAND IT OVER
  Wed Jun  7 1989 12:04                                                                                                  Page  151

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10023                      	
10024                      	
10025                      	; ----
10026                      	; GETB
10027                      	; ----
10028                      	; RETURN ITEM [ARG2] IN BYTE-TABLE AT [ARG1]
10029                      	
10030   7D3F               	ZGETB:
10031   7D3F   20 4A 7D    		JSR	BCALC	
10032   7D42   A9 00       		LDA	#0	
10033   7D44   F0 EF       		BEQ	DOGET		; [A] = 0, SO CLEAR MSB OF [VALUE]
10034                      	
10035                      	
10036                      	; --------------------
10037                      	; CALC TABLE ADDRESSES
10038                      	; --------------------
10039                      	; WORD-ALIGNED ENTRY
10040                      	
10041   7D46               	WCALC:
10042   7D46   06 65       		ASL	ARG2+LO	; WORD-ALIGN FOR
10043   7D48   26 66       		ROL	ARG2+HI	; WORD ACCESS
10044                      	;
10045                      	; BYTE-ALIGNED ENTRY
10046                      	;
10047   7D4A               	BCALC:
10048   7D4A   A5 65       		LDA	ARG2+LO	; ADD BASE ADDR OF TABLE
10049   7D4C   18          		CLC		; TO ITEM
10050   7D4D   65 63       		ADC	ARG1+LO	; INDEX
10051   7D4F   85 86       		STA	MPCL	
10052   7D51   A5 66       		LDA	ARG2+HI	; SAME FOR MSBS
10053   7D53   65 64       		ADC	ARG1+HI	
10054   7D55   85 87       		STA	MPCM	
10055   7D57   A9 00       		LDA	#0	
10056   7D59   69 00       		ADC	#0	; PICK UP CARRY FROM MPCM
10057   7D5B   85 88       		STA	MPCH	; TO GET TOP BIT
10058   7D5D   4C 85 90    		JMP	VLDMPC	
10059                      	
10060                      	
10061                      	; ----
10062                      	; GETP
10063                      	; ----
10064                      	; RETURN PROPERTY [ARG2] OF OBJECT [ARG1] ;
10065                      	; IF NO PROP [ARG2], RETURN [ARG2]'TH ELEMENT OF OBJECT #0
10066                      	
10067   7D60               	ZGETP:
10068   7D60   20 2C 95    		jsr	PROPB		; set up FPC
10069   7D63               	GETP1:
10070   7D63   20 57 95    		jsr	PROPN		; GET ID OF PROP TBL
10071   7D66   C5 65       		cmp	ARG2+LO		; Compare PROP ID
10072   7D68   F0 30       		beq	GETP3		; FOUND IT
10073   7D6A   90 06       		bcc	GETP2		; NOT THERE
10074   7D6C   20 76 95    		jsr	PROPNX		; GET NEXT PROP, ALIGN [FPC] TO IT
10075   7D6F   4C 63 7D    		jmp	GETP1		; TRY AGAIN WITH NEXT PROP
10076                      	;
10077                      	; PROPERTY NOT THERE, GET DEFAULT
10078                      	;
10079   7D72               	GETP2:
10080   7D72   A5 65       		lda	ARG2+LO		; GET PROPERTY #
10081   7D74   38          		sec			; ZERO-ALIGN IT
10082   7D75   E9 01       		sbc	#1	
10083   7D77   0A          		asl	A		; WORD-ALIGN IT
10084   7D78   18          		clc			; add in table start
10085   7D79   6D 0B 96    		adc	ZBEGIN+ZOBJEC+1	; add lo part
10086   7D7C   85 8C       		sta	FPCL		; save for fetch
10087   7D7E   AD 0A 96    		lda	ZBEGIN+ZOBJEC	; now get hi part
10088   7D81   69 00       		adc	#0		; pick up carry, if any
10089   7D83   20 7C 8F    		jsr	SETPC		; get memory spot for this page
10090   7D86   85 8D       		sta	FPCH		; page and
10091   7D88   84 8E       		sty	FPCBNK		; bank
10092   7D8A   20 5B 92    		jsr	FETCHB		; GET MSB OF PROPERTY
10093   7D8D   85 77       		sta	VALUE+HI	
10094   7D8F   20 C3 8F    		jsr	NEXTFPC
10095   7D92   20 5B 92    		jsr	FETCHB		; DO SAME WITH LSB
10096   7D95   85 76       		sta	VALUE+LO	
10097   7D97   4C E1 43    		jmp	PUTVAL		; RETURN DEFAULT IN [VALUE]
  Wed Jun  7 1989 12:04                                                                                                  Page  152

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10098   7D9A               	GETP3:
10099   7D9A   20 5D 95    		jsr	PROPL		; GET LENGTH OF PROP INTO [A]
10100   7D9D   AA          		tax			; save [A]
10101   7D9E   20 C3 8F    		jsr	NEXTFPC		; MAKE [FPC] POINT TO 1ST BYTE OF PROP
10102   7DA1   E0 01       		cpx	#1		; IF LENGTH =1
10103   7DA3   F0 09       		beq	GETPB		; GET A BYTE PROPERTY
10104   7DA5   E0 02       		cpx	#2		; IF LENGTH = 2
10105   7DA7   F0 10       		beq	GETPW		; GET A WORD PROPERTY
10106                      	
10107                      		; *** ERROR #7: PROPERTY LENGTH ***
10108                      	
10109   7DA9   A9 07       		LDA	#7	
10110   7DAB   4C 0A 52    		JMP	ZERROR	
10111                      	;
10112                      	; GET A 1-BYTE PROPERTY
10113                      	;
10114   7DAE               	GETPB:
10115   7DAE   20 5B 92    		jsr	FETCHB		; GET LSB INTO [A]
10116   7DB1   85 76       		sta	VALUE+LO	; STORE LSB
10117   7DB3   A9 00       		lda	#0		; CLEAR MSB
10118   7DB5   85 77       		sta	VALUE+HI	; and zero it
10119   7DB7   F0 0D       		beq	ETPEX	
10120                      	;
10121                      	; GET A 2-BYTE PROPERTY
10122                      	;
10123   7DB9               	GETPW:
10124   7DB9   20 5B 92    		jsr	FETCHB		; GET MSB
10125   7DBC   85 77       		sta	VALUE+HI	; store MSB
10126   7DBE   20 C3 8F    		jsr	NEXTFPC		; POINT TO LSB
10127   7DC1   20 5B 92    		jsr	FETCHB		; GET IT INTO [A]
10128   7DC4   85 76       		sta	VALUE+LO	; AND MSB
10129   7DC6               	ETPEX:
10130   7DC6   4C E1 43    		jmp	PUTVAL	
10131                      	
10132                      	; -----
10133                      	; GETPT
10134                      	; -----
10135                      	; RETURN POINTER TO PROP TABLE [ARG2]
10136                      	; IN OBJECT [ARG1]
10137                      	
10138   7DC9               	ZGETPT:
10139   7DC9   A5 63       		lda	ARG1+LO
10140   7DCB   A6 64       		ldx	ARG1+HI		; (EZIP)
10141   7DCD   20 F1 94    		jsr	OBJLOC		; put location into [FPC]
10142   7DD0   A9 0C       		lda	#12		; get offset table pointer
10143   7DD2   20 E3 8F    		jsr	ADDFPC		; and point to it
10144   7DD5   20 5B 92    		jsr	FETCHB		; get MSB of table pointer
10145   7DD8   48          		pha			; save page
10146   7DD9   20 C3 8F    		jsr	NEXTFPC		; point to LSB
10147   7DDC   20 5B 92    		jsr	FETCHB		; and get it
10148   7DDF   85 8C       		sta	FPCL		; and save it
10149   7DE1   68          		pla			; get page address back
10150   7DE2   20 7C 8F    		jsr	SETPC		; and absolutize it
10151   7DE5   85 8D       		sta	FPCH		; and save page
10152   7DE7   84 8E       		sty	FPCBNK		; and bank
10153   7DE9   20 5B 92    		jsr	FETCHB		; GET LENGTH OF SHORT DESC
10154   7DEC   0A          		asl	A		; WORD-ALIGN IT
10155   7DED   A8          		tay			; now point to just past it
10156   7DEE   C8          		iny			; thank you
10157   7DEF   98          		tya			; for adding
10158   7DF0   20 E3 8F    		jsr	ADDFPC		; and POINT JUST PAST THE DESCRIPTION
10159   7DF3               	GETPT1:
10160   7DF3   20 57 95    		jsr	PROPN		; get prop ID
10161   7DF6   C5 65       		cmp	ARG2+LO		; CHECK ID
10162   7DF8   F0 0B       		beq	GETPT2
10163   7DFA   B0 03       		bcs	DDD		; .GE. so check some more
10164   7DFC   4C 33 7E    		jmp	DORET		; BEYOND IT, SO NOT THERE
10165   7DFF               	DDD:
10166   7DFF   20 76 95    		jsr	PROPNX		; point to next one
10167   7E02   4C F3 7D    		jmp	GETPT1		; next please
10168   7E05               	GETPT2:
10169   7E05   20 5D 95    		jsr	PROPL		; get the length of this property
10170   7E08   20 C3 8F    		jsr	NEXTFPC		; INC TO POINT AT PROPERTY VALUE (EZIP)
10171                      	;
10172                      	; now subtract absolute address to get relative address for returning
  Wed Jun  7 1989 12:04                                                                                                  Page  153

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10173                      	; what a pain in the neck
10174                      	;
10175   7E0B   A5 8E       		lda	FPCBNK		; check which bank we are in
10176   7E0D   F0 16       		beq	GETPB0		; in main bank, it's easier
10177                      	;
10178                      	; if in AUX bank, then we must subtract beginning of AUX mem, then
10179                      	; add in size of MAIN bank
10180                      	;
10181   7E0F   A5 8D       		lda	FPCH		; get page
10182   7E11   C9 D0       		cmp	#>Z3BEGIN	; in part 2 of aux?
10183   7E13   B0 08       		bcs	GETPB3		; ayyup
10184   7E15   38          		sec			; and subtract
10185   7E16   E9 40       		sbc	#>Z2BEGIN	; first page in aux
10186   7E18   18          		clc			; now add in how many pages in main
10187   7E19   69 29       		adc	#P2PAGE		; now we have relative start
10188   7E1B   D0 0D       		bne	GETP15		; JUMP to putval
10189   7E1D               	GETPB3:
10190   7E1D   38          		sec			; and subtract
10191   7E1E   E9 D0       		sbc	#>Z3BEGIN	; first page in aux, part 2
10192   7E20   18          		clc			; now add in how many pages in main
10193   7E21   69 A8       		adc	#P3PAGE		; now we have relative start
10194   7E23   D0 05       		bne	GETP15		; jump to putval	
10195   7E25               	GETPB0:
10196   7E25   A5 8D       		lda	FPCH		; get page in main mem
10197   7E27   38          		sec			; and then subtract
10198   7E28   E9 96       		sbc	#>ZBEGIN	; start of main mem
10199   7E2A               	GETP15:
10200   7E2A   85 77       		sta	VALUE+HI	; save hi part for returning
10201   7E2C   A5 8C       		lda	FPCL		; and just save lo part
10202   7E2E   85 76       		sta	VALUE+LO	; okay?
10203   7E30   4C E1 43    		jmp	PUTVAL		; AND RETURN
10204   7E33               	DORET:	
10205   7E33   4C DA 43    		jmp	RET0		; ELSE RETURN A ZERO
10206                      	
10207                      	
10208                      	; -----
10209                      	; NEXTP
10210                      	; -----
10211                      	; RETURN INDEX # OF PROP FOLLOWING PROP [ARG2] IN OBJECT [AR
10212                      	; RETURN ZERO IF LAST ; RETURN FIRST IF [ARG2]=0; ERROR IF NO
10213                      	
10214   7E36               	ZNEXTP:
10215   7E36   20 2C 95    		JSR	PROPB	; ALIGN [FPC] AT PROPERTY TBL'S 1ST ENTRY
10216   7E39   A5 65       		LDA	ARG2+LO	; IF [ARG2]=0
10217   7E3B   F0 12       		BEQ	NXTP3	; RETURN "FIRST" SLOT
10218   7E3D               	NXTP1:
10219   7E3D   20 57 95    		JSR	PROPN	; FETCH PROPERTY #
10220   7E40   C5 65       		CMP	ARG2+LO	; COMPARE TO TARGET #
10221   7E42   F0 08       		BEQ	NXTP2	; FOUND IT!
10222   7E44   90 ED       		BCC	DORET	; LAST PROP, SO RETURN ZERO
10223   7E46   20 76 95    		JSR	PROPNX	; ELSE TRY NEXT PROPERTY (EZIP)
10224   7E49   4C 3D 7E    		JMP	NXTP1	
10225   7E4C   20 76 95    	NXTP2:	JSR	PROPNX	; POINT TO FOLLOWING PROPERTY
10226   7E4F   20 57 95    	NXTP3:	JSR	PROPN	; GET THE PROPERTY #
10227   7E52   A2 00       		LDX	#0	; FOR PUTBYT (EZIP)
10228   7E54   4C DD 43    		JMP	PUTBYT	; AND RETURN IT
10229                      	
10230                      	
10231                      	; ---
10232                      	; ADD
10233                      	; ---
10234                      	; RETURN [ARG1] + [ARG2]
10235                      	
10236   7E57   A5 63       	ZADD:	LDA	ARG1+LO	; ADD LSBS
10237   7E59   18          		CLC		
10238   7E5A   65 65       		ADC	ARG2+LO	
10239   7E5C   AA          		TAX		; SAVE LSB HERE
10240   7E5D   A5 64       		LDA	ARG1+HI	; ADD MSBS
10241   7E5F   65 66       		ADC	ARG2+HI	
10242   7E61   4C 6E 7C    		JMP	VEXIT	
10243                      	
10244                      	
10245                      	; ---
10246                      	; SUB
10247                      	; ---
  Wed Jun  7 1989 12:04                                                                                                  Page  154

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10248                      	; RETURN [ARG1] - [ARG2]
10249                      	
10250   7E64   A5 63       	ZSUB:	LDA	ARG1+LO	; SUBTRACT LSBS
10251   7E66   38          		SEC		
10252   7E67   E5 65       		SBC	ARG2+LO	
10253   7E69   AA          		TAX		; SAVE LSB HERE
10254   7E6A   A5 64       		LDA	ARG1+HI	; SUBTRACT MSBS
10255   7E6C   E5 66       		SBC	ARG2+HI	
10256   7E6E   4C 6E 7C    		JMP	VEXIT	; EXIT WITH [X]=LSB, [A]=MSB
10257                      	
10258                      	
10259                      	; ---
10260                      	; MUL
10261                      	; ---
10262                      	; RETURN [ARG1] * [ARG2]
10263                      	
10264   7E71   20 57 7F    	ZMUL:	JSR	MINIT	; INIT THINGS
10265   7E74   6E 66 5B    	ZMLOOP:	ROR	MTEMP+HI	
10266   7E77   6E 65 5B    		ROR	MTEMP+LO	
10267   7E7A   66 66       		ROR	ARG2+HI	
10268   7E7C   66 65       		ROR	ARG2+LO	
10269   7E7E   90 11       		BCC	ZMNEXT	
10270   7E80   A5 63       		LDA	ARG1+LO	
10271   7E82   18          		CLC		
10272   7E83   6D 65 5B    		ADC	MTEMP+LO	
10273   7E86   8D 65 5B    		STA	MTEMP+LO	
10274   7E89   A5 64       		LDA	ARG1+HI	
10275   7E8B   6D 66 5B    		ADC	MTEMP+HI	
10276   7E8E   8D 66 5B    		STA	MTEMP+HI	
10277   7E91   CA          	ZMNEXT:	DEX		
10278   7E92   10 E0       		BPL	ZMLOOP	
10279   7E94   A6 65       		LDX	ARG2+LO	; PUT LSB OF PRODUCT
10280   7E96   A5 66       		LDA	ARG2+HI	; AND MSB
10281   7E98   4C 6E 7C    		JMP	VEXIT	; WHERE "VEXIT" EXPECTS THEM
10282                      	
10283                      	
10284                      	; ---
10285                      	; DIV
10286                      	; ---
10287                      	; RETURN QUOTIENT OF [ARG1] / [ARG2]
10288                      	
10289   7E9B   20 B3 7E    	ZDIV:	JSR	DIVIDE	
10290   7E9E   AE 60 6C    		LDX	QUOT+LO	
10291   7EA1   AD 61 6C    		LDA	QUOT+HI	
10292   7EA4   4C 6E 7C    		JMP	VEXIT	
10293                      	
10294                      	
10295                      	; ---
10296                      	; MOD
10297                      	; ---
10298                      	; RETURN REMAINDER OF [ARG1] / [ARG2]
10299                      	
10300   7EA7   20 B3 7E    	ZMOD:	JSR	DIVIDE	
10301   7EAA   AE 62 6C    		LDX	REMAIN+LO	; FETCH THE REMAINDER
10302   7EAD   AD 63 6C    		LDA	REMAIN+HI	; IN [REMAIN]
10303   7EB0   4C 6E 7C    		JMP	VEXIT	; AND RETURN IT
10304                      	
10305                      	
10306                      	; ---------------
10307                      	; SIGNED DIVISION
10308                      	; ---------------
10309                      	; ENTRY: DIVIDEND IN [ARG1], DIVISOR IN [ARG2]
10310                      	; EXIT: QUOTIENT IN [QUOT], REMAINDER IN [REMAIN]
10311                      	
10312   7EB3               	DIVIDE:
10313   7EB3   A5 64       		LDA	ARG1+HI	; SIGN OF REMAINDER
10314   7EB5   8D 65 6C    		STA	RSIGN	; IS THE SIGN OF THE DIVIDEND
10315   7EB8   45 66       		EOR	ARG2+HI	; SIGN OF QUOTIENT IS POSITIVE
10316   7EBA   8D 64 6C    		STA	QSIGN	; IF SIGNS OF TERMS ARE THE SAME
10317   7EBD   A5 63       		LDA	ARG1+LO	; MOVE [ARG1] TO [QUOT]
10318   7EBF   8D 60 6C    		STA	QUOT+LO	
10319   7EC2   A5 64       		LDA	ARG1+HI	
10320   7EC4   8D 61 6C    		STA	QUOT+HI	; IF DIVIDEND IS POSITIVE
10321   7EC7   10 03       		BPL	ABSDIV	; MOVE DIVISOR
10322   7EC9   20 FD 7E    		JSR	ABQUOT	; ELSE CALC ABS(DIVIDEND) FIRST
  Wed Jun  7 1989 12:04                                                                                                  Page  155

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10323   7ECC   A5 65       	ABSDIV:	LDA	ARG2+LO	
10324   7ECE   8D 62 6C    		STA	REMAIN+LO	
10325   7ED1   A5 66       		LDA	ARG2+HI	
10326   7ED3   8D 63 6C    		STA	REMAIN+HI	; IF REMAINDER IS POSITIVE
10327   7ED6   10 03       		BPL	GODIV	; WE'RE READY TO DIVIDE
10328   7ED8   20 EB 7E    		JSR	ABREM	; ELSE CALC ABS(DIVISOR)
10329   7EDB   20 0F 7F    	GODIV:	JSR	UDIV	; DO UNSIGNED DIVIDE
10330   7EDE   AD 64 6C    		LDA	QSIGN	; SHOULD QUOTIENT BE FLIPPED?
10331   7EE1   10 03       		BPL	RFLIP	; NO, TEST REMAINDER
10332   7EE3   20 FD 7E    		JSR	ABQUOT	; ELSE GET ABSOLUTE VALUE
10333   7EE6   AD 65 6C    	RFLIP:	LDA	RSIGN	; SHOULD EMAINDER BE FLIPPED?
10334   7EE9   10 11       		BPL	DIVEX	; NO, WE'RE DONE
10335                      	
10336                      		; ELSE FALL THROUGH ...
10337                      	
10338                      	
10339                      	; ----------------
10340                      	; CALC ABS(REMAIN)
10341                      	; ----------------
10342                      	
10343   7EEB   A9 00       	ABREM:	LDA	#0	
10344   7EED   38          		SEC		
10345   7EEE   ED 62 6C    		SBC	REMAIN+LO	
10346   7EF1   8D 62 6C    		STA	REMAIN+LO	
10347   7EF4   A9 00       		LDA	#0	
10348   7EF6   ED 63 6C    		SBC	REMAIN+HI	
10349   7EF9   8D 63 6C    		STA	REMAIN+HI	
10350   7EFC   60          	DIVEX:	RTS		
10351                      	
10352                      	
10353                      	; --------------
10354                      	; CALC ABS(QUOT)
10355                      	; --------------
10356                      	
10357   7EFD   A9 00       	ABQUOT:	LDA	#0	
10358   7EFF   38          		SEC		
10359   7F00   ED 60 6C    		SBC	QUOT+LO	
10360   7F03   8D 60 6C    		STA	QUOT+LO	
10361   7F06   A9 00       		LDA	#0	
10362   7F08   ED 61 6C    		SBC	QUOT+HI	
10363   7F0B   8D 61 6C    		STA	QUOT+HI	
10364   7F0E   60          		RTS		
10365                      	
10366                      	
10367                      	; -----------------
10368                      	; UNSIGNED DIVISION
10369                      	; -----------------
10370                      	; ENTRY: DIVIDEND IN [QUOT], DIVISOR IN [REMAIN]
10371                      	; EXIT: QUOTIENT IN [QUOT], REMAINDER IN [REMAIN]
10372                      	
10373   7F0F               	UDIV:
10374   7F0F   AD 62 6C    		LDA	REMAIN+LO	; CHECK [REMAIN]
10375   7F12   0D 63 6C    		ORA	REMAIN+HI	; BEFORE PROCEEDING
10376   7F15   F0 3B       		BEQ	DIVERR	; CAN'T DIVIDE BY ZERO!
10377   7F17   20 57 7F    		JSR	MINIT	; SET IT ALL UP
10378   7F1A   2E 60 6C    	UDLOOP:	ROL	QUOT+LO	
10379   7F1D   2E 61 6C    		ROL	QUOT+HI	
10380   7F20   2E 65 5B    		ROL	MTEMP+LO	
10381   7F23   2E 66 5B    		ROL	MTEMP+HI	
10382   7F26   AD 65 5B    		LDA	MTEMP+LO	
10383   7F29   38          		SEC		
10384   7F2A   ED 62 6C    		SBC	REMAIN+LO	
10385   7F2D   A8          		TAY		; SAVE HERE
10386   7F2E   AD 66 5B    		LDA	MTEMP+HI	
10387   7F31   ED 63 6C    		SBC	REMAIN+HI	
10388   7F34   90 06       		BCC	UDNEXT	
10389   7F36   8C 65 5B    		STY	MTEMP+LO	
10390   7F39   8D 66 5B    		STA	MTEMP+HI	
10391   7F3C   CA          	UDNEXT:	DEX		
10392   7F3D   D0 DB       		BNE	UDLOOP	
10393   7F3F   2E 60 6C    		ROL	QUOT+LO	; SHIFT LAST CARRY FOR QUOTIENT
10394   7F42   2E 61 6C    		ROL	QUOT+HI	
10395   7F45   AD 65 5B    		LDA	MTEMP+LO	; MOVE REMAINDER
10396   7F48   8D 62 6C    		STA	REMAIN+LO	; INTO [REMAIN]
10397   7F4B   AD 66 5B    		LDA	MTEMP+HI	
  Wed Jun  7 1989 12:04                                                                                                  Page  156

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10398   7F4E   8D 63 6C    		STA	REMAIN+HI	
10399   7F51   60          		RTS		
10400                      	
10401                      		; *** ERROR #8: DIVISION BY ZERO ***
10402                      	
10403   7F52   A9 08       	DIVERR:	LDA	#8	
10404   7F54   4C 0A 52    		JMP	ZERROR	
10405                      	
10406                      	
10407                      	; ---------
10408                      	; MATH INIT
10409                      	; ---------
10410                      	
10411   7F57   A2 10       	MINIT:	LDX	#16		; INIT LOOPING INDEX
10412   7F59   A9 00       		LDA	#0
10413   7F5B   8D 65 5B    		STA	MTEMP+LO	; CLEAR TEMP
10414   7F5E   8D 66 5B    		STA	MTEMP+HI	; REGISTER
10415   7F61   18          		CLC			; AND CARRY
10416   7F62   60          		RTS
10417                      	
10418                      	
10419                      	; -----
10420                      	; THROW
10421                      	; -----
10422                      	
10423   7F63               	ZTHROW:
10424   7F63   A5 65       		lda	ARG2+LO		; check to see if we are ready to do return
10425   7F65   CD 7A 6C    		cmp	OLDZSP+LO
10426   7F68   D0 07       		bne	ZTHLOOP		; nope, keep unwinding the stack
10427   7F6A   A5 66       		lda	ARG2+HI
10428   7F6C   CD 7B 6C    		cmp	OLDZSP+HI	; have we found the right frame yet?
10429   7F6F   F0 06       		beq	ZTHDO		; yes
10430   7F71               	ZTHLOOP:
10431   7F71   20 5B 7B    		jsr	ZRET		; do another return
10432   7F74   4C 63 7F    		jmp	ZTHROW		; and try again
10433   7F77               	ZTHDO:	
10434   7F77   A5 65       		lda	ARG2+LO		; SET ZSTACK POINTER
10435   7F79   8D 7A 6C    		sta	OLDZSP+LO	; UP FOR ZRET
10436   7F7C   A5 66       		lda	ARG2+HI
10437   7F7E   8D 7B 6C    		sta	OLDZSP+HI
10438   7F81   4C 5B 7B    		jmp	ZRET
10439                      	
10440   7F84               		END
10441                      	
10442   7F84               		INCLUDE 	OPSX.ASM
10443                      		PAGE			
  Wed Jun  7 1989 12:04                                                                                                  Page  157

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10444   7F84               		STTL "--- X-OPS ---"
10445                      	
10446                      	
10447                      		; ------
10448                      		; EQUAL?
10449                      		; ------
10450                      		; IS [ARG1] = [ARG2] (OR [ARG3] OR [ARG4])?
10451                      	
10452   7F84               	ZEQUAL:
10453   7F84   C6 62       		DEC	NARGS	; DOUBLE-CHECK # ARGS
10454   7F86   A5 63       		LDA	ARG1+LO	; FETCH LSB
10455   7F88   A6 64       		LDX	ARG1+HI	; AND MSB OF [ARG1]
10456   7F8A   C5 65       		CMP	ARG2+LO	; TEST LSB OF [ARG2]
10457   7F8C   D0 04       		BNE	TRY2	; NO GOOD, LOOK FOR ANOTHER ARG
10458   7F8E   E4 66       		CPX	ARG2+HI	; ELSE TRY MSB OF [ARG2]
10459   7F90   F0 18       		BEQ	EQOK	; MATCHED!
10460   7F92   C6 62       	TRY2:	DEC	NARGS	; OUT OF ARGS YET?
10461   7F94   F0 17       		BEQ	EQBAD	; YES, WE FAILED
10462   7F96   C5 67       		CMP	ARG3+LO	; TRY LSB OF [ARG3]
10463   7F98   D0 04       		BNE	TRY3	; NO GOOD, LOOK FOR ANOTHER ARG
10464   7F9A   E4 68       		CPX	ARG3+HI	; HOW ABOUT MSB OF [ARG3]?
10465   7F9C   F0 0C       		BEQ	EQOK	; YAY!
10466   7F9E   C6 62       	TRY3:	DEC	NARGS	; OUT OF ARGS YET?
10467   7FA0   F0 0B       		BEQ	EQBAD	; IF NOT ...
10468   7FA2   C5 69       		CMP	ARG4+LO	; TRY [ARG4]
10469   7FA4   D0 07       		BNE	EQBAD	; SORRY, CHUM
10470   7FA6   E4 6A       		CPX	ARG4+HI	; MSB MATCHED?
10471   7FA8   D0 03       		BNE	EQBAD	; TOO BAD
10472                      	
10473   7FAA   4C 3B 44    	EQOK:	JMP	PREDS	; FINALLY MATCHED!
10474                      	
10475   7FAD   4C 2F 44    	EQBAD:	JMP	PREDF	; FAILURE (SNIFF!)
10476                      	
10477                      	
10478                      	; ----------------------------
10479                      	; ICALL,ICALL1, ICALL2, IXCALL
10480                      	; ----------------------------
10481                      	
10482   7FB0               	ZICALL:
10483   7FB0               	ZICLL1:
10484   7FB0               	ZICLL2:
10485   7FB0   A9 01       	ZIXCLL:	LDA	#1	; SET FLAG FOR RETURNLESS CALL
10486   7FB2   8D 64 5B    		STA	IRET
10487   7FB5   D0 05       		BNE	IENTR	; JMP OVER NORMAL SETTING
10488                      	
10489                      	
10490                      	; -------------------
10491                      	; XCALL, CALL1, CALL2
10492                      	; -------------------
10493                      	
10494                      	ZXCALL:			; DROP	THROUGH
10495                      	ZCALL1:			; CALL	RTN HANDLES ALL 4 KINDS
10496   7FB7               	ZCALL2:
10497                      	
10498                      	; ----
10499                      	; CALL
10500                      	; ----
10501                      	; BRANCH TO FUNCTION AT ([ARG1]*4), PASSING
10502                      	; OPTIONAL PARAMETERS IN [ARG2]-[ARG4]
10503                      	; ([ARG5]-[ARG8] FOR XCALL (EZIP))
10504                      	
10505   7FB7   A9 00       	ZCALL:	LDA	#0
10506   7FB9   8D 64 5B    		STA	IRET		; SET FLAG TO RETURN SOMETHING
10507   7FBC   A5 63       	IENTR:	LDA	ARG1+LO
10508   7FBE   05 64       		ORA	ARG1+HI		; IS CALL ADDRESS ZERO?
10509   7FC0   D0 0B       		BNE	DOCALL		; NO, CONTINUE
10510   7FC2   AD 64 5B    		LDA	IRET		; any ret value?
10511   7FC5   F0 01       		BEQ	Ij		; yes, so return a zero
10512                      	
10513   7FC7   60          		RTS			; otherwise, just end
10514   7FC8               	Ij:
10515   7FC8   A2 00       		LDX	#0
10516   7FCA   4C DD 43    		JMP	PUTBYT		; ELSE RETURN THE ZERO IN [A]
10517   7FCD   AE 7A 6C    	DOCALL:	LDX	OLDZSP+LO	; SAVE OLD STACK POINTER
10518   7FD0   AD 7B 6C    		LDA	OLDZSP+HI
  Wed Jun  7 1989 12:04                                                                                                  Page  158

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10519   7FD3   20 9B 43    		JSR	PUSHXA
10520   7FD6   A5 80       		LDA	ZPCL		; AND LSB OF [ZPC]
10521   7FD8   AE 64 5B    		LDX	IRET		; AND RETURN FLAG
10522   7FDB   20 9B 43    		JSR	PUSHXA		; ON THE Z-STACK
10523   7FDE   A6 81       		LDX	ZPCM		; SAVE MIDDLE 8 BITS
10524   7FE0   A5 82       		LDA	ZPCH		; AND TOP BIT OF [ZPC]
10525   7FE2   20 9B 43    		JSR	PUSHXA		; AS WELL
10526                      	
10527                      		; FORM 16-BIT ADDRESS FROM [ARG1]
10528                      	
10529   7FE5   A9 00       		LDA	#0	
10530   7FE7   06 63       		ASL	ARG1+LO		; MULTIPLY [ARG1]
10531   7FE9   26 64       		ROL	ARG1+HI		; (BY 2)
10532   7FEB   2A          		ROL	A		; >BIT INTO [A]
10533   7FEC   06 63       		ASL	ARG1+LO		; BY 4 (EZIP)
10534   7FEE   26 64       		ROL	ARG1+HI	
10535   7FF0   2A          		ROL	A
10536   7FF1   85 82       		STA	ZPCH		; NEW >BIT OF [ZPC]
10537   7FF3   A5 64       		LDA	ARG1+HI		; GET NEW <BYTES
10538   7FF5   85 81       		STA	ZPCM	
10539   7FF7   A5 63       		LDA	ARG1+LO	
10540   7FF9   85 80       		STA	ZPCL	
10541                      	;
10542                      	; now add offset
10543                      	;
10544   7FFB   18          		clc			; doing adding
10545   7FFC   A5 80       		lda	ZPCL		; start at lo part
10546   7FFE   65 5D       		adc	FOFFL		; add in lo part
10547   8000   85 80       		sta	ZPCL
10548   8002   A5 81       		lda	ZPCM
10549   8004   65 5C       		adc	FOFFM
10550   8006   85 81       		sta	ZPCM
10551   8008   A5 82       		lda	ZPCH
10552   800A   65 5B       		adc	FOFFH
10553   800C   85 82       		sta	ZPCH
10554   800E   20 AF 90    		jsr	VLDZPC	
10555   8011   20 24 92    		jsr	NEXTPC		; FETCH # LOCALS TO PASS
10556   8014   85 7A       		sta	J+LO		; SAVE HERE FOR COUNTING
10557   8016   85 7B       		sta	J+HI		; AND HERE FOR LATER REFERENCE
10558   8018   F0 21       		beq	ZCLL2		; SKIP IF NO LOCALS
10559   801A   A9 00       		lda	#0	
10560   801C   85 78       		sta	I+LO		; ELSE INIT STORAGE INDEX
10561   801E               	ZCLL1:
10562   801E   A4 78       		LDY	I+LO	
10563   8020   BE 00 1E    		LDX	LOCALS+LO,Y	; GET LSB OF LOCAL INTO [X]
10564   8023   B9 01 1E    		LDA	LOCALS+HI,Y	; AND MSB INTO [A]
10565   8026   20 9B 43    		JSR	PUSHXA		; PUSH LOCAL IN [X/A] ONTO Z-STACK
10566   8029   A4 78       		LDY	I+LO		; RESTORE INDEX
10567   802B   A9 00       		LDA	#0		; ZERO ALL LOCALS (X)
10568   802D   99 00 1E    		STA	LOCALS+LO,Y
10569   8030   99 01 1E    		STA	LOCALS+HI,Y
10570   8033   C8          		INY		
10571   8034   C8          		INY			; UPDATE
10572   8035   84 78       		STY	I+LO		; THE STORAGE INDEX
10573   8037   C6 7A       		DEC	J+LO		; ANY MORE LOCALS?
10574   8039   D0 E3       		BNE	ZCLL1		; YES, KEEP LOOPING
10575                      	;
10576                      	; MOVE UP TO 7 ARGUMENTS TO [LOCALS]
10577                      	;
10578   803B               	ZCLL2:
10579   803B   AD 68 5B    		LDA	ASSVLU		; get how many here
10580   803E   20 9B 43    		JSR	PUSHXA		; save how many args for ASSIGNED?
10581   8041   C6 62       		DEC	NARGS		; EXTRA ARGS IN THIS CALL?
10582   8043   A5 62       		LDA	NARGS		; SAVE FOR ASSIGNED? OP
10583   8045   8D 68 5B    		STA	ASSVLU		; and save away
10584   8048   F0 5E       		BEQ	ZCALL3		; NO, CONTINUE
10585   804A   A5 65       		LDA	ARG2+LO		; MOVE [ARG2] TO LOCAL #1
10586   804C   8D 00 1E    		STA	LOCALS+LO	
10587   804F   A5 66       		LDA	ARG2+HI	
10588   8051   8D 01 1E    		STA	LOCALS+HI	
10589   8054   C6 62       		DEC	NARGS		; ANY LEFT?
10590   8056   F0 50       		BEQ	ZCALL3		; NO, SCRAM
10591   8058   A5 67       		LDA	ARG3+LO		; MOVE [ARG3] TO LOCAL #2
10592   805A   8D 02 1E    		STA	LOCALS+LO+2	
10593   805D   A5 68       		LDA	ARG3+HI	
  Wed Jun  7 1989 12:04                                                                                                  Page  159

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10594   805F   8D 03 1E    		STA	LOCALS+HI+2	
10595   8062   C6 62       		DEC	NARGS		; ANY LEFT?
10596   8064   F0 42       		BEQ	ZCALL3		; NO, EXUENT
10597   8066   A5 69       		LDA	ARG4+LO		; MOVE [ARG4] TO LOCAL #3
10598   8068   8D 04 1E    		STA	LOCALS+LO+4	
10599   806B   A5 6A       		LDA	ARG4+HI	
10600   806D   8D 05 1E    		STA	LOCALS+HI+4	
10601   8070   C6 62       		DEC	NARGS		; MORE (THAT MEANS IT'S AN XCALL)
10602   8072   F0 34       		BEQ	ZCALL3		; NO, JUST A CALL
10603   8074   A5 6B       		LDA	ARG5+LO		; MOVE [ARG5] TO LOCAL #4
10604   8076   8D 06 1E    		STA	LOCALS+LO+6	
10605   8079   A5 6C       		LDA	ARG5+HI	
10606   807B   8D 07 1E    		STA	LOCALS+HI+6	
10607   807E   C6 62       		DEC	NARGS		; MORE?
10608   8080   F0 26       		BEQ	ZCALL3		; NO
10609   8082   A5 6D       		LDA	ARG6+LO		; MOVE [ARG6] TO LOCAL #5
10610   8084   8D 08 1E    		STA	LOCALS+LO+8	
10611   8087   A5 6E       		LDA	ARG6+HI	
10612   8089   8D 09 1E    		STA	LOCALS+HI+8	
10613   808C   C6 62       		DEC	NARGS		; MORE?
10614   808E   F0 18       		BEQ	ZCALL3		; NO
10615   8090   A5 6F       		LDA	ARG7+LO		; MOVE [ARG7] TO LOCAL #6
10616   8092   8D 0A 1E    		STA	LOCALS+LO+10	
10617   8095   A5 70       		LDA	ARG7+HI	
10618   8097   8D 0B 1E    		STA	LOCALS+HI+10	
10619   809A   C6 62       		DEC	NARGS		; MORE?
10620   809C   F0 0A       		BEQ	ZCALL3		; NO
10621   809E   A5 71       		LDA	ARG8+LO		; MOVE [ARG8] TO LOCAL #7
10622   80A0   8D 0C 1E    		STA	LOCALS+LO+12	
10623   80A3   A5 72       		LDA	ARG8+HI	
10624   80A5   8D 0D 1E    		STA	LOCALS+HI+12	
10625   80A8   A6 7B       	ZCALL3:	LDX	J+HI		; RETRIEVE # LOCALS
10626   80AA   8A          		TXA			; DUPE FOR NO GOOD REASON
10627   80AB   20 9B 43    		JSR	PUSHXA		; PUSH # LOCALS ONTO Z-STACK
10628   80AE   A5 B0       		LDA	ZSP+HI		; REMEMBER WHERE
10629   80B0   8D 7B 6C    		STA	OLDZSP+HI	; WE CAME FROM
10630   80B3   A5 AF       		LDA	ZSP+LO	
10631   80B5   8D 7A 6C    		STA	OLDZSP+LO	
10632   80B8   60          		RTS			; WHEW!
10633                      	
10634                      	
10635                      	; ---
10636                      	; PUT
10637                      	; ---
10638                      	; SET ITEM [ARG2] IN WORD-TABLE [ARG1] EQUAL TO [ARG3]
10639   80B9               	ZPUT:
10640   80B9   06 65       		asl	ARG2+LO	; WORD-ALIGN [ARG2]
10641   80BB   26 66       		rol	ARG2+HI	
10642   80BD   20 D4 80    		jsr	PCALC	; GET ITEM ADDR INTO [SPC]
10643   80C0   A5 68       		lda	ARG3+HI	; STORE MSB OF [ARG3]
10644   80C2   20 3A 92    		jsr	STASHB	; and store it away
10645   80C5   20 A3 8F    		jsr	NEXTSPC	; POINT TO LSB
10646   80C8   4C CE 80    		jmp	PUTLSB	; and put in lsb
10647                      	
10648                      	
10649                      	; ----
10650                      	; PUTB
10651                      	; ----
10652                      	; SET ITEM [ARG2] IN BYTE-TABLE [ARG1] EQUAL TO [ARG3]
10653                      	
10654   80CB   20 D4 80    	ZPUTB:	JSR	PCALC	
10655                      	;
10656                      	; ENTRY FOR "PUT"
10657                      	;
10658   80CE               	PUTLSB:
10659   80CE   A5 67       		LDA	ARG3+LO	; GET LSB OF [ARG3]
10660   80D0   20 3A 92    		jsr	STASHB	; and save it away
10661   80D3   60          		RTS		
10662                      	
10663                      	
10664                      	; ---------------------------
10665                      	; CALC ITEM ADDRESS FOR "PUT"
10666                      	; ---------------------------
10667                      	; put the 3 byte address into SPC
10668                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page  160

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10669   80D4   A5 65       	PCALC:	LDA	ARG2+LO	; ADD ITEM OFFSET IN [ARG2]
10670   80D6   18          		CLC		; TO TABLE ADDR IN [ARG1]
10671   80D7   65 63       		ADC	ARG1+LO	; TO FORM A POINTER
10672   80D9   85 8F       		STA	SPCL	; in [SPC]
10673   80DB   A5 66       		LDA	ARG2+HI	; SAME FOR MSB
10674   80DD   65 64       		ADC	ARG1+HI	
10675   80DF   20 7C 8F    		jsr	SETPC	; and figger out where it is
10676   80E2   85 90       		sta	SPCH	; set page
10677   80E4   84 91       		sty	SPCBNK	; and bank
10678   80E6   60          		rts
10679                      	
10680                      	; ----
10681                      	; PUTP
10682                      	; ----
10683                      	; SET PROPERTY [ARG2] IN OBJECT [ARG1] EQUAL TO [ARG3]
10684                      	
10685   80E7               	ZPUTP:
10686   80E7   20 2C 95    		jsr	PROPB		; GET PROP TBL ADDR
10687   80EA               	PUTP1:
10688   80EA   20 57 95    		jsr	PROPN		; GET ID
10689   80ED   C5 65       		cmp	ARG2+LO		; is it the wanted one?
10690   80EF   F0 08       		beq	PUTP2		; ayyup
10691   80F1   90 2F       		bcc	PNERR		; ERROR IF LOWER
10692   80F3   20 76 95    		jsr	PROPNX		; TRY NEXT PROPERTY, ALIGN [I] AT IT (EZIP)
10693   80F6   4C EA 80    		jmp	PUTP1		; and check again
10694   80F9               	PUTP2:
10695   80F9   20 5D 95    		jsr	PROPL		; GET PROPERTY LENGTH INTO [A]
10696   80FC   AA          		tax			; save length
10697   80FD   20 C3 8F    		jsr	NEXTFPC		; and point to first prop. byte
10698   8100   A5 8E       		lda	FPCBNK		; and copy FPC to SPC for storage
10699   8102   85 91       		sta	SPCBNK
10700   8104   A5 8D       		lda	FPCH
10701   8106   85 90       		sta	SPCH
10702   8108   A5 8C       		lda	FPCL
10703   810A   85 8F       		sta	SPCL		; saved it
10704   810C   E0 01       		cpx	#1		; IF LENGTH = 1
10705   810E   F0 0C       		beq	PUTP3		; PUT A BYTE
10706   8110   E0 02       		cpx	#2		; PUT A WORD IF [A] = 2
10707   8112   D0 13       		bne	PLERR		; ELSE LENGTH IS BAD
10708   8114   A5 68       		lda	ARG3+HI		; GET MSB OF PROPERTY
10709   8116   20 3A 92    		jsr	STASHB		; and store in object
10710   8119   20 A3 8F    		jsr	NEXTSPC		; POINT TO LSB SLOT
10711   811C               	PUTP3:
10712   811C   A5 67       		lda	ARG3+LO		; FETCH LSB of property
10713   811E   20 3A 92    		jsr	STASHB		; AND STORE IN OBJECT
10714   8121   60          		rts
10715                      	
10716                      		; *** ERROR #10: BAD PROPERTY NUMBER ***
10717                      	
10718   8122   A9 0A       	PNERR:	LDA	#10	
10719   8124   4C 0A 52    		JMP	ZERROR	
10720                      	
10721                      		; *** ERROR #11: PUTP PROPERTY LENGTH ***
10722                      	
10723   8127   A9 0B       	PLERR:	LDA	#11	
10724   8129   4C 0A 52    		JMP	ZERROR	
10725                      	
10726                      	
10727                      	; ------
10728                      	; PRINTC
10729                      	; ------
10730                      	; PRINT CHAR WITH ASCII VALUE IN [ARG1]
10731                      	
10732   812C   A5 63       	ZPRC:	LDA	ARG1+LO	; GRAB THE CHAR
10733   812E   4C 06 53    		JMP	COUT	; AND SHIP IT OUT
10734                      	
10735                      	
10736                      	; ------
10737                      	; PRINTN
10738                      	; ------
10739                      	; PRINT VALUE OF [ARG1] AS A SIGNED INTEGER
10740                      	
10741   8131   A5 63       	ZPRN:	LDA	ARG1+LO	; MOVE [ARG1] TO [QUOT]
10742   8133   8D 60 6C    		STA	QUOT+LO	
10743   8136   A5 64       		LDA	ARG1+HI	
  Wed Jun  7 1989 12:04                                                                                                  Page  161

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10744   8138   8D 61 6C    		STA	QUOT+HI	
10745                      	
10746                      		; PRINT [QUOT]
10747                      	
10748   813B   AD 61 6C    	NUMBER:	LDA	QUOT+HI	; IF VALUE IS POSITIVE
10749   813E   10 08       		BPL	DIGCNT	; CONTINUE
10750   8140   A9 2D       		LDA	#'-'	; ELSE START WITH A MINUS SIGN
10751   8142   20 06 53    		JSR	COUT	
10752   8145   20 FD 7E    		JSR	ABQUOT	; AND CALC ABS([QUOT])
10753                      	
10754                      		; COUNT # OF DECIMAL DIGITS
10755                      	
10756   8148   A9 00       	DIGCNT:	LDA	#0	; RESET
10757   814A   8D 66 6C    		STA	DIGITS	; DIGIT INDEX
10758   814D   AD 60 6C    	DGC:	LDA	QUOT+LO	; IS QUOTIENT
10759   8150   0D 61 6C    		ORA	QUOT+HI	; ZERO YET?
10760   8153   F0 16       		BEQ	PRNTN3	; YES, READY TO PRINT
10761   8155   A9 0A       		LDA	#10	; ELSE DIVIDE [QUOT]
10762   8157   8D 62 6C    		STA	REMAIN+LO	; BY 10 (LSB)
10763   815A   A9 00       		LDA	#0	
10764   815C   8D 63 6C    		STA	REMAIN+HI	; 10 (MSB)
10765   815F   20 0F 7F    		JSR	UDIV	; UNSIGNED DIVIDE
10766   8162   AD 62 6C    		LDA	REMAIN+LO	; FETCH LSB OF REMAINDER (THE DIGIT)
10767   8165   48          		PHA		; SAVE IT ON STACK
10768   8166   EE 66 6C    		INC	DIGITS	; UPDATE DIGIT COUNT
10769   8169   D0 E2       		BNE	DGC	; LOOP TILL QUOTIENT=0
10770   816B   AD 66 6C    	PRNTN3:	LDA	DIGITS	; IF DIGIT COUNT IS NZ
10771   816E   D0 05       		BNE	PRNTN4	; CONTINUE
10772   8170   A9 30       		LDA	#'0'	; ELSE PRINT "0"
10773   8172   4C 06 53    		JMP	COUT	; AND RETURN
10774   8175   68          	PRNTN4:	PLA		; PULL A DIGIT OFF THE STACK
10775   8176   18          		CLC		
10776   8177   69 30       		ADC	#'0'	; CONVERT TO DB	II
10777   8179   20 06 53    		JSR	COUT	; AND PRINT IT
10778   817C   CE 66 6C    		DEC	DIGITS	; OUT OF DIGITS YET?
10779   817F   D0 F4       		BNE	PRNTN4	; NO, KEEP LOOPING
10780   8181   60          		RTS		
10781                      	
10782                      	
10783                      	; ------
10784                      	; RANDOM
10785                      	; ------
10786                      	; RETURN A RANDOM VALUE BETWEEN 0 AND [ARG1]
10787                      	
10788   8182   A5 63       	ZRAND:	LDA	ARG1+LO		; IF VALUE IS ZERO
10789   8184   05 64       	 	ORA	ARG1+HI
10790   8186   D0 09       		BNE	ZRAND1
10791   8188   8D 76 6C    		STA	SRHOLD+LO	; RETURN TO RANDOM RANDOM
10792   818B   8D 77 6C    		STA	SRHOLD+HI	; CLEAR INDICATOR
10793   818E   4C DA 43    		JMP	RET0		; AND RETURN THRU HERE SO ALIGNED
10794   8191   AD 76 6C    	ZRAND1:	LDA	SRHOLD+LO	; ARE WE NONRAMDOM INCREMENTING? (EZIP)
10795   8194   0D 77 6C    		ORA	SRHOLD+HI
10796   8197   D0 41       		BNE	ZRAND3		; YUP
10797   8199   A5 64       		LDA	ARG1+HI
10798   819B   10 17       		BPL	ZRAND2		; GENERATE A RANDOM #
10799   819D   49 FF       		EOR	#$FF		; SET UP TO INCREMENT FROM 1 THRU INT
10800   819F   8D 77 6C    		STA	SRHOLD+HI	; GET ABSOLUTE
10801   81A2   A5 63       		LDA	ARG1+LO
10802   81A4   49 FF       		EOR	#$FF
10803   81A6   8D 76 6C    		STA	SRHOLD+LO
10804   81A9   EE 76 6C    		INC	SRHOLD+LO
10805   81AC   A9 00       		LDA	#0		; W/ NO RAMDOMNESS
10806   81AE   85 A5       		STA	RAND+HI
10807   81B0   85 A4       		STA	RAND+LO
10808   81B2   F0 26       		BEQ	ZRAND3		; JMP  (END EZIP)
10809   81B4   A5 63       	ZRAND2:	LDA	ARG1+LO		; MAKE [ARG1] THE DIVISOR
10810   81B6   85 65       		STA	ARG2+LO
10811   81B8   A5 64       		LDA	ARG1+HI
10812   81BA   85 66       		STA	ARG2+HI
10813   81BC   20 EA 52    		JSR	RANDOM		; GET RANDOM BYTES INTO [A] AND [X]
10814   81BF   86 63       		STX	ARG1+LO		; MAKE THEM THE DIVIDEND
10815   81C1   29 7F       		AND	#$7F		; MAKE SURE MSB IS POSITIVE
10816   81C3   85 64       		STA	ARG1+HI
10817   81C5   20 B3 7E    		JSR	DIVIDE		; SIGNED DIVIDE, [ARG1] / [ARG2]
10818   81C8   AD 62 6C    		LDA	REMAIN+LO	; MOVE REMAINDER
  Wed Jun  7 1989 12:04                                                                                                  Page  162

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10819   81CB   18          		CLC
10820   81CC   69 01       		ADC	#1		; ADD 1
10821   81CE   85 76       		STA	VALUE+LO	; INTO [VALUE]
10822   81D0   AD 63 6C    		LDA	REMAIN+HI
10823   81D3   69 00       		ADC	#0
10824   81D5   85 77       		STA	VALUE+HI
10825   81D7   4C E1 43    		JMP	PUTVAL		; AND RETURN RESULT
10826                      	
10827                      		; NON RANDOM INCREMENTING
10828                      	
10829   81DA               	ZRAND3:
10830   81DA   A5 A5       		LDA	RAND+HI	; (EZIP)
10831   81DC   CD 77 6C    		CMP	SRHOLD+HI
10832   81DF   90 11       		BCC	ZRAND4
10833   81E1   A5 A4       		LDA	RAND+LO
10834   81E3   CD 76 6C    		CMP	SRHOLD+LO
10835   81E6   90 0A       		BCC	ZRAND4
10836   81E8   F0 08       		BEQ	ZRAND4
10837   81EA   A9 01       		LDA	#1		; WENT THRU ALL
10838   81EC   85 A4       		STA	RAND+LO	; START AGAIN
10839   81EE   A9 00       		LDA	#0
10840   81F0   85 A5       		STA	RAND+HI
10841   81F2   A5 A4       	ZRAND4:	LDA	RAND+LO
10842   81F4   85 76       		STA	VALUE+LO
10843   81F6   A5 A5       		LDA	RAND+HI
10844   81F8   85 77       		STA	VALUE+HI
10845   81FA   E6 A4       		INC	RAND+LO	; FOR NEXT TIME
10846   81FC   D0 02       		BNE	ZRAND5
10847   81FE   E6 A5       		INC	RAND+HI
10848   8200   4C E1 43    	ZRAND5:	JMP	PUTVAL		; (END EZIP)
10849                      	
10850                      	
10851                      	; ----
10852                      	; PUSH
10853                      	; ----
10854                      	; PUSH [ARG1] ONTO THE Z-STACK
10855                      	
10856   8203   A6 63       	ZPUSH:	LDX	ARG1+LO	
10857   8205   A5 64       		LDA	ARG1+HI	
10858   8207   4C 9B 43    		JMP	PUSHXA	
10859                      	
10860                      	
10861                      	; ---
10862                      	; POP
10863                      	; ---
10864                      	; POP WORD OFF Z-STACK, STORE IN VARIABLE [ARG1]
10865                      	
10866   820A               	ZPOP:
10867   820A   A5 62       		lda	NARGS		; check whether it wants game or passed stack
10868   820C   F0 56       		beq	ZPOP1		; must want from game stack
10869                      	
10870   820E   A5 63       		lda	ARG1+LO		; get me the address of the LTABLE
10871   8210   85 8C       		sta	FPCL		; for munging with
10872   8212   A5 64       		lda	ARG1+HI		; this is page
10873   8214   20 7C 8F    		jsr	SETPC		; get me actual page/bank
10874   8217   85 8D       		sta	FPCH		; set page
10875   8219   84 8E       		sty	FPCBNK		; and bank
10876                      	
10877   821B   20 5B 92    		jsr	FETCHB		; this is hi part of counter
10878   821E   85 7B       		sta	J+HI		; save it
10879   8220   20 C3 8F    		jsr	NEXTFPC		; point to lo part
10880   8223   20 5B 92    		jsr	FETCHB		; get it
10881   8226   85 7A       		sta	J+LO		; save it
10882                      	;
10883                      	; now count popping this one and stash it into the table
10884                      	;
10885   8228   E6 7A       		inc	J+LO		; count it
10886   822A   D0 02       		bne	ZPOP2		; wrapped?
10887   822C   E6 7B       		inc	J+HI		; increment MSB
10888   822E               	ZPOP2:
10889   822E   20 78 90    		jsr	FP2SP		; set up to stash back in beginning of LTABLE
10890   8231   A5 7A       		lda	J+LO		; LSB first
10891   8233   20 3A 92    		jsr	STASHB		; saved it
10892   8236   20 53 90    		jsr	PREVSPC		; point to MSB
10893   8239   A5 7B       		lda	J+HI		; get it
  Wed Jun  7 1989 12:04                                                                                                  Page  163

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10894   823B   20 3A 92    		jsr	STASHB		; saved it
10895                      	;
10896                      	; finally, we can save the arg into the stack
10897                      	;
10898   823E   06 7A       		asl	J+LO		; make a word offset (*2)
10899   8240   26 7B       		rol	J+HI		; pick up carry maybe
10900   8242   A5 7A       		lda	J+LO		; add in arg offset
10901   8244   18          		clc			; adding
10902   8245   65 63       		adc	ARG1+LO		; figger offset
10903   8247   85 8C       		sta	FPCL		; this goes here for fetching
10904   8249   A5 7B       		lda	J+HI		; now page
10905   824B   65 64       		adc	ARG1+HI		; add in start of table
10906   824D   20 7C 8F    		jsr	SETPC		; get me memory page
10907   8250   85 8D       		sta	FPCH		; page
10908   8252   84 8E       		sty	FPCBNK		; and bank
10909   8254   20 5B 92    		jsr	FETCHB		; get MSB
10910   8257   85 77       		sta	VALUE+HI	; save value
10911   8259   20 C3 8F    		jsr	NEXTFPC		; and point to LSB
10912   825C   20 5B 92    		jsr	FETCHB		; get LSB
10913   825F   85 76       		sta	VALUE+LO	; and save
10914   8261   4C 67 82    		jmp	ZPOP3		; and return it
10915   8264               	ZPOP1:
10916   8264   20 66 43    		jsr	POPVAL		; VALUE INTO [VALUE]
10917   8267               	ZPOP3:
10918   8267   4C E1 43    		jmp	PUTVAL		; AND put the data away
10919                      	
10920                      	
10921                      	; ------
10922                      	; INTBL?
10923                      	; ------
10924                      	
10925   826A               	ZINTBL:
10926   826A   A5 68       		LDA	ARG3+HI		; JIC COUNT IS 0,
10927   826C   30 7D       		BMI	INTNF		; >0, just ignore!
10928   826E   05 67       		ORA	ARG3+LO
10929   8270   F0 79       		BEQ	INTNF		; SAY NOT FOUND
10930                      	
10931   8272   A5 62       		LDA	NARGS		; IS THERE A RECORD SPEC?
10932   8274   C9 04       		CMP	#4
10933   8276   F0 04       		BEQ	SET4
10934   8278   A9 82       	SETDEF:	LDA	#130		; NO, SET DEFAULT
10935   827A   85 69       		STA	ARG4+LO
10936                      	
10937   827C   A5 69       	SET4:	LDA	ARG4+LO
10938   827E   F0 F8       		BEQ	SETDEF		; GO BACK AND GET VALUE
10939   8280   A9 00       		LDA	#0		; COMPARE BYTE OR WORD?
10940   8282   06 69       		ASL	ARG4+LO
10941   8284   2A          		ROL	A		; PICK UP INDICATOR
10942   8285   46 69       		LSR	ARG4+LO		; CLEAR FROM RECORD LENGTH
10943   8287   8D 67 5B    		STA	TYPE 		; BYTE (0) OR WORD (1)
10944   828A   AD 67 5B    		LDA	TYPE		; SET FLAG
10945   828D   D0 04       		BNE	SETTBL
10946   828F   A5 63       		LDA	ARG1+LO		; IF ONLY BYTE, MOVE IT
10947   8291   85 64       		STA	ARG1+HI		; TO FIRST BYTE CHECKED
10948   8293               	SETTBL:
10949   8293   A5 65       		LDA	ARG2+LO		; PICK UP TBL ADDR
10950   8295   85 86       		STA	MPCL
10951   8297   A5 66       		LDA	ARG2+HI
10952   8299   85 87       		STA	MPCM
10953   829B   A9 00       		LDA	#0
10954   829D   85 88       		STA	MPCH		; ONLY A WORD ADDR, SO IN 1ST 64K
10955   829F   20 85 90    		JSR	VLDMPC
10956                      	
10957   82A2   A5 86       	INTLP:	LDA	MPCL		; HOLD START ADDR, MPC WILL BE A MESS
10958   82A4   8D 7B 00    		STA	VWCUR+0
10959   82A7   A5 87       		LDA	MPCM
10960   82A9   8D 7C 00    		STA	VWCUR+1
10961   82AC   A5 88       		LDA	MPCH
10962   82AE   8D 7D 00    		STA	VWCUR+2
10963   82B1   20 0E 92    		JSR	GETBYT		; GET 1ST BYTE
10964   82B4   C5 64       		CMP	ARG1+HI		; DOES IT = THE VALUE LOOKING FOR?
10965   82B6   D0 0C       		BNE	INTNXT		; NO
10966   82B8   AD 67 5B    		LDA	TYPE
10967   82BB   F0 3A       		BEQ	INTFND		; ONLY COMPARING A BYTE SO FOUND!
10968   82BD   20 0E 92    		JSR	GETBYT
  Wed Jun  7 1989 12:04                                                                                                  Page  164

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10969   82C0   C5 63       		CMP	ARG1+LO
10970   82C2   F0 33       		BEQ	INTFND		; YES, FOUND IT
10971   82C4               	INTNXT:
10972   82C4   AD 7B 00    		LDA	VWCUR+0		; TO MOVE UP, JUST ADD
10973   82C7   18          		CLC			; OFFSET FROM START OF THIS
10974   82C8   65 69       		ADC	ARG4+LO		; ENTRY
10975   82CA   85 86       		STA	MPCL
10976   82CC   90 11       		BCC	INEXT0
10977                      	
10978   82CE   AD 7C 00    		LDA	VWCUR+1		; PICK UP CARRY
10979   82D1   69 00       		ADC	#0
10980   82D3   85 87       		STA	MPCM
10981   82D5   AD 7D 00    		LDA	VWCUR+2
10982   82D8   69 00       		ADC	#0
10983   82DA   85 88       		STA	MPCH
10984   82DC   20 85 90    		JSR	VLDMPC		; CROSSED PAGE SO RE-VALIDATE
10985                      	
10986   82DF   C6 67       	INEXT0:	DEC	ARG3+LO		; CHECKED ALL ENTRIES?
10987   82E1   D0 BF       		BNE	INTLP
10988   82E3   A5 68       		LDA	ARG3+HI
10989   82E5   F0 04       		BEQ	INTNF
10990   82E7   C6 68       		DEC	ARG3+HI
10991   82E9   D0 B7       		BNE	INTLP
10992                      	
10993   82EB               	INTNF:
10994   82EB   A9 00       		LDA	#0		; 0 = NOT FOUND
10995   82ED   85 76       		STA	VALUE+LO
10996   82EF   85 77       		STA	VALUE+HI
10997   82F1   20 E1 43    		JSR	PUTVAL
10998   82F4   4C 2F 44    		JMP	PREDF		; FAILED!
10999                      	
11000   82F7               	INTFND:
11001   82F7   AD 7B 00    		LDA	VWCUR+LO
11002   82FA   85 76       		STA	VALUE+LO	; AND SET TO RETURN THE VALUE
11003   82FC   AD 7C 00    		LDA	VWCUR+HI
11004   82FF   85 77       		STA	VALUE+HI
11005   8301   20 E1 43    		JSR	PUTVAL		; SEND IT BACK
11006   8304   4C 3B 44    		JMP	PREDS		; AND SCREEM SUCCESS
11007                      	
11008                      	; ----
11009                      	; BCOM
11010                      	; ----
11011                      	; COMPLEMENT [ARG1]
11012                      	
11013   8307   A5 63       	ZBCOM:	LDA	ARG1+LO
11014   8309   49 FF       		EOR	#$FF
11015   830B   85 76       		STA	VALUE+LO
11016   830D   A5 64       		LDA	ARG1+HI
11017   830F   49 FF       		EOR	#$FF
11018   8311   85 77       		STA	VALUE+HI
11019   8313   4C E1 43    		JMP	PUTVAL
11020                      	
11021                      	
11022                      	; -----
11023                      	; COPYT
11024                      	; -----
11025                      	
11026   8316               	ZCOPYT:
11027   8316   A5 65       		LDA	ARG2+LO		; CHECK OUT WHAT'S TO BE DONE
11028   8318   05 66       		ORA	ARG2+HI
11029   831A   D0 03       		BNE	ZC0
11030   831C   4C CB 83    		JMP	CASE1		; ZERO LENGTH BYTES OF SOURCE
11031   831F               	ZC0:
11032   831F   A5 68       		LDA	ARG3+HI
11033   8321   C9 7F       		CMP	#$7F
11034   8323   90 03       		BCC	CASE2
11035   8325   4C F1 83    		JMP	CASE3		; FORWARD COPY
11036                      	
11037                      		; CASE2 - CHECK IF FORWARD OR BACKWARD COPY
11038                      	
11039   8328   A5 64       	CASE2:	LDA	ARG1+HI		; IF SRC < DEST
11040   832A   C5 66       		CMP	ARG2+HI
11041   832C   90 0D       		BCC	CHK2
11042   832E   F0 03       		BEQ	ZC1
11043   8330   4C 54 83    		JMP	FRWRD		; NO
  Wed Jun  7 1989 12:04                                                                                                  Page  165

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11044   8333   A5 63       	ZC1:	LDA	ARG1+LO
11045   8335   C5 65       		CMP	ARG2+LO
11046   8337   F0 02       		BEQ	CHK2
11047   8339   B0 19       		BCS	FRWRD		; NO
11048   833B   A5 63       	CHK2:	LDA	ARG1+LO		; AND SRC + LENGTH > DEST
11049   833D   18          		CLC
11050   833E   65 67       		ADC	ARG3+LO
11051   8340   85 78       		STA	I+LO
11052   8342   A5 64       		LDA	ARG1+HI
11053   8344   65 68       		ADC	ARG3+HI
11054   8346   C5 66       		CMP	ARG2+HI
11055   8348   90 0A       		BCC	FRWRD		; NO
11056   834A   D0 3E       		BNE	BKWRD		; YES
11057   834C   A5 78       		LDA	I+LO
11058   834E   C5 65       		CMP	ARG2+LO
11059   8350   F0 02       		BEQ	FRWRD		; DEBUG, IF EQUAL REALLY LESS
11060   8352   B0 36       		BCS	BKWRD		; OVERLAPS SO DO BACKWARD COPY
11061                      	
11062                      		; ELSE FALL THROUGH TO FORWARD COPY
11063                      	
11064   8354   A9 00       	FRWRD:	LDA	#0		; USE GETBYT CAUSE MAY  BE
11065   8356   85 88       		STA	MPCH		; BEYOND MAIN MEMORY
11066   8358   A5 64       		LDA	ARG1+HI
11067   835A   85 87       		STA	MPCM
11068   835C   A5 63       		LDA	ARG1+LO
11069   835E   85 86       		STA	MPCL
11070   8360   20 85 90    		JSR	VLDMPC		; AND ALIGN TO CORRECT PAGE
11071   8363   A5 65       		LDA	ARG2+LO
11072   8365   85 8F       		STA	SPCL
11073   8367   A5 66       		LDA	ARG2+HI
11074   8369   20 7C 8F    		jsr	SETPC		; get memory spot
11075   836C   85 90       		sta	SPCH		; high part
11076   836E   84 91       		sty	SPCBNK		; and the bank part
11077   8370   A5 67       		LDA	ARG3+LO
11078   8372   85 7A       		STA	J+LO
11079   8374   A5 68       		LDA	ARG3+HI
11080   8376   85 7B       		STA	J+HI
11081   8378               	FRLP:
11082   8378   20 C6 44    		jsr	DECJ
11083   837B   90 0C       		bcc	FRDUN		; CARRY CLEAR ON $FFFF
11084   837D   20 0E 92    		jsr	GETBYT
11085   8380   20 3A 92    		jsr	STASHB		; and save it
11086   8383   20 A3 8F    		jsr	NEXTSPC		; and point to next one
11087   8386   4C 78 83    		jmp	FRLP
11088   8389               	FRDUN:
11089   8389   60          		rts
11090                      	
11091                      	
11092   838A               	BKWRD:	
11093   838A   A5 67       		LDA	ARG3+LO		; DECR 1ST TO GET CORRECT OFFSET
11094   838C   85 7A       		STA	J+LO
11095   838E   A5 68       		LDA	ARG3+HI
11096   8390   85 7B       		STA	J+HI
11097   8392   20 C6 44    		JSR	DECJ
11098   8395   A5 63       		LDA	ARG1+LO		; SET TO END OF SOURCE & DEST.
11099   8397   18          		CLC
11100   8398   65 7A       		ADC	J+LO
11101   839A   85 8C       		sta	FPCL		; set up fetch pointer
11102   839C   A5 64       		LDA	ARG1+HI
11103   839E   65 7B       		ADC	J+HI
11104   83A0   20 7C 8F    		jsr	SETPC		; and get mem locations
11105   83A3   85 8D       		sta	FPCH
11106   83A5   84 8E       		sty	FPCBNK
11107   83A7   A5 65       		LDA	ARG2+LO
11108   83A9   18          		CLC
11109   83AA   65 7A       		ADC	J+LO
11110   83AC   85 8F       		sta	SPCL		; and now set up stash pointer
11111   83AE   A5 66       		LDA	ARG2+HI
11112   83B0   65 7B       		ADC	J+HI
11113   83B2   20 7C 8F    		jsr	SETPC		; and get me page/bank
11114   83B5   85 90       		sta	SPCH
11115   83B7   84 91       		sty	SPCBNK
11116   83B9               	BKLP:
11117   83B9   20 5B 92    		jsr	FETCHB		; get byte
11118   83BC   20 3A 92    		jsr	STASHB		; and save it
  Wed Jun  7 1989 12:04                                                                                                  Page  166

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11119   83BF   20 29 90    		jsr	PREVFPC		; going backwards
11120   83C2   20 53 90    		jsr	PREVSPC		; and here too
11121   83C5   20 C6 44    		jsr	DECJ		; RETURNS CARRY CLEAR ON $FFFF
11122   83C8   B0 EF       		bcs	BKLP
11123   83CA               	BKDUN:
11124   83CA   60          		RTS
11125                      	
11126                      		; ZERO LENGTH # OF BYTES OF SOURCE
11127                      	
11128   83CB   A5 63       	CASE1:	LDA	ARG1+LO
11129   83CD   85 8F       		STA	SPCL		; set stash pointer
11130   83CF   A5 64       		LDA	ARG1+HI
11131   83D1   20 7C 8F    		jsr	SETPC		; get page/bank
11132   83D4   85 90       		sta	SPCH
11133   83D6   84 91       		sty	SPCBNK
11134   83D8   A5 67       		LDA	ARG3+LO		; SET UP COUNTER
11135   83DA   85 7A       		STA	J+LO
11136   83DC   A5 68       		LDA	ARG3+HI
11137   83DE   85 7B       		STA	J+HI
11138   83E0               	C1LP:
11139   83E0   20 C6 44    		jsr	DECJ		; CARRY CLEAR WHEN J = $FFFF
11140   83E3   90 0B       		bcc	C1DUN
11141   83E5   A9 00       		lda	#0
11142   83E7   20 3A 92    		jsr	STASHB		; and zero it
11143   83EA   20 A3 8F    		jsr	NEXTSPC		; and point to next one
11144   83ED   4C E0 83    		jmp	C1LP
11145   83F0               	C1DUN:
11146   83F0   60          		rts
11147                      	
11148                      		; 2'S COMPLEMENT LENGTH (XOR + 1) THEN DO FORWARD COPY
11149                      	
11150   83F1               	CASE3:
11151   83F1   A5 67       		LDA	ARG3+LO
11152   83F3   49 FF       		EOR	#$FF
11153   83F5   85 67       		STA	ARG3+LO
11154   83F7   A5 68       		LDA	ARG3+HI
11155   83F9   49 FF       		EOR	#$FF
11156   83FB   85 68       		STA	ARG3+HI
11157   83FD   E6 67       		INC	ARG3+LO
11158   83FF   D0 02       		BNE	GOFRWD
11159   8401   E6 68       		INC	ARG3+HI
11160   8403   4C 54 83    	GOFRWD:	JMP	FRWRD
11161                      	
11162                      	
11163                      	; ---------
11164                      	; ASSIGNED?
11165                      	; ---------
11166                      	
11167                      	
11168   8406               	ZASSND:
11169   8406   A5 63       		LDA	ARG1+LO		; COMPARE TO # OF OPTIONALS FROM LAST CALL
11170   8408   CD 68 5B    		CMP	ASSVLU
11171   840B   90 05       		BCC	DOYES		; IF LESS OR EQUAL, WAS ASSIGNED
11172   840D   F0 03       		BEQ	DOYES
11173   840F   4C 2F 44    		JMP	PREDF
11174   8412               	DOYES:
11175   8412   4C 3B 44    		JMP	PREDS
11176                      	
11177                      	
11178                      	; -------------
11179                      	; LOGICAL SHIFT
11180                      	; -------------
11181                      	; SHIFT ARG1, ARG2 BITS (LEFT IF ARG2 IS POS. RIGHT IF NEG.)
11182                      	
11183   8415   A5 63       	ZSHIFT:	LDA	ARG1+LO		; SET UP FOR SHIFT
11184   8417   85 76       		STA	VALUE+LO
11185   8419   A5 64       		LDA	ARG1+HI
11186   841B   85 77       		STA	VALUE+HI
11187   841D   A5 65       		LDA	ARG2+LO		; IF NEGATIVE, SHIFT RIGHT
11188   841F   C9 80       		CMP	#$80
11189   8421   B0 0B       		BCS	SRIGHT
11190                      	
11191                      		; SHIFT LEFT
11192                      	
11193   8423   A8          		TAY			; COUNT
  Wed Jun  7 1989 12:04                                                                                                  Page  167

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11194   8424   06 76       	SLP1:	ASL	VALUE+LO
11195   8426   26 77       		ROL	VALUE+HI
11196   8428   88          		DEY
11197   8429   D0 F9       		BNE	SLP1
11198   842B   4C E1 43    		JMP	PUTVAL		; AND RETURN THE VALUE
11199                      	
11200   842E   49 FF       	SRIGHT:	EOR	#$FF		; COMPLEMENT
11201   8430   A8          		TAY
11202   8431   46 77       	SLP2:	LSR	VALUE+HI	; SHIFT
11203   8433   66 76       		ROR	VALUE+LO
11204   8435   88          		DEY
11205   8436   10 F9       		BPL	SLP2
11206   8438   4C E1 43    		JMP	PUTVAL
11207                      	
11208                      	
11209                      	; ----------------
11210                      	; ARITHMETIC SHIFT
11211                      	; ----------------
11212                      	; PROPAGATING SIGN BIT ON RIGHT SHIFT
11213                      	
11214   843B   A5 65       	ZASHFT:	LDA	ARG2+LO		; IF NEGATIVE, SHIFT RIGHT
11215   843D   C9 80       		CMP	#$80
11216   843F   90 D4       		BCC	ZSHIFT		; SAME AS LOGICAL SHIFT
11217   8441   A6 63       		LDX	ARG1+LO		; SET UP FOR SHIFT
11218   8443   86 76       		STX	VALUE+LO
11219   8445   A6 64       		LDX	ARG1+HI
11220   8447   86 77       		STX	VALUE+HI
11221                      	
11222   8449   49 FF       		EOR	#$FF		; COMPLEMENT COUNT
11223   844B   A8          		TAY
11224   844C   A5 64       	ASLP2:	LDA	ARG1+HI
11225   844E   0A          		ASL	A		; GET SIGN BIT
11226   844F   66 77       		ROR	VALUE+HI	; SHIFT
11227   8451   66 76       		ROR	VALUE+LO
11228   8453   88          		DEY
11229   8454   10 F6       		BPL	ASLP2
11230   8456   4C E1 43    		JMP	PUTVAL
11231   8459               		
11232                      	; --------
11233                      	; XPUSH
11234                      	; --------
11235   8459               	ZXPUSH:
11236   8459   A5 65       		lda	ARG2+LO		; get me the address of the LTABLE
11237   845B   85 8C       		sta	FPCL		; for munging with
11238   845D   A5 66       		lda	ARG2+HI		; this is page
11239   845F   20 7C 8F    		jsr	SETPC		; get me actual page/bank
11240   8462   85 8D       		sta	FPCH		; set page
11241   8464   84 8E       		sty	FPCBNK		; and bank
11242                      	
11243   8466   20 5B 92    		jsr	FETCHB		; this is hi part of counter
11244   8469   85 7B       		sta	J+HI		; save it
11245   846B   20 C3 8F    		jsr	NEXTFPC		; point to lo part
11246   846E   20 5B 92    		jsr	FETCHB		; get it
11247   8471   85 7A       		sta	J+LO		; thanx
11248   8473   05 7B       		ora	J+HI		; check for zero elements left
11249   8475   D0 03       		bne	ZXP0		; yes, there is room at the inn
11250                      	
11251   8477   4C 2F 44    		jmp	PREDF		; no room here!
11252   847A               	ZXP0:
11253   847A   20 78 90    		jsr	FP2SP		; set up to stash back in beginning of LTABLE
11254   847D   A5 7B       		lda	J+HI		; now the MSB
11255   847F   85 7D       		sta	K+HI		; and saved it
11256   8481   A5 7A       		lda	J+LO		; save this
11257   8483   85 7C       		sta	K+LO		; save it
11258                      	;
11259                      	; now count this one and stash it into the table
11260                      	;
11261   8485   D0 02       		bne	ZXP1		; nope, dec okay
11262   8487   C6 7B       		dec	J+HI		; decrement MSB
11263   8489               	ZXP1:
11264   8489   C6 7A       		dec	J+LO		; and the LSB
11265   848B   A5 7A       		lda	J+LO		; LSB first
11266   848D   20 3A 92    		jsr	STASHB		; saved it
11267   8490   20 53 90    		jsr	PREVSPC		; point to MSB
11268   8493   A5 7B       		lda	J+HI		; get it
  Wed Jun  7 1989 12:04                                                                                                  Page  168

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11269   8495   20 3A 92    		jsr	STASHB		; saved it
11270                      	;
11271                      	; finally, we can save the arg into the stack
11272                      	;
11273   8498   06 7C       		asl	K+LO		; make a word offset (*2)
11274   849A   26 7D       		rol	K+HI		; pick up carry maybe
11275   849C   A5 7C       		lda	K+LO		; add in arg offset
11276   849E   18          		clc			; adding
11277   849F   65 65       		adc	ARG2+LO		; figger offset
11278   84A1   85 8F       		sta	SPCL		; this goes here for stashing
11279   84A3   A5 7D       		lda	K+HI		; now page
11280   84A5   65 66       		adc	ARG2+HI		; add in start of table
11281   84A7   20 7C 8F    		jsr	SETPC		; get me memory page
11282   84AA   85 90       		sta	SPCH		; page
11283   84AC   84 91       		sty	SPCBNK		; and bank
11284                      	
11285   84AE   A5 64       		lda	ARG1+HI		; push MSB
11286   84B0   20 3A 92    		jsr	STASHB		; saved
11287   84B3   20 A3 8F    		jsr	NEXTSPC		; point to next one
11288   84B6   A5 63       		lda	ARG1+LO		; and now LSB 
11289   84B8   20 3A 92    		jsr	STASHB		; into the stack
11290   84BB   4C 3B 44    		jmp	PREDS		; show we worked good
11291                      	;---------
11292                      	; ZFSTACK
11293                      	;---------
11294   84BE               	ZFSTACK:
11295   84BE   C6 62       		dec	NARGS		; how many args there?
11296   84C0   D0 0E       		bne	ZFS1		; flush ARG2 stack
11297                      	;
11298                      	; pop from system stack
11299                      	;
11300   84C2   A5 63       		lda	ARG1+LO		; just add number to system counter
11301   84C4   18          		clc			; adding
11302   84C5   65 AF       		adc	ZSP+LO		; added
11303   84C7   85 AF       		sta	ZSP+LO		; and saved
11304   84C9   A5 64       		lda	ARG1+HI		; get hi part
11305   84CB   65 B0       		adc	ZSP+HI		; add in hi part
11306   84CD   85 B0       		sta	ZSP+HI		; save hi part
11307   84CF   60          		rts
11308   84D0               	ZFS1:
11309   84D0   A5 65       		lda	ARG2+LO		; get LTABLE we are interested in
11310   84D2   85 8C       		sta	FPCL		; set up FPC first
11311   84D4   A5 66       		lda	ARG2+HI		; and page
11312   84D6   20 7C 8F    		jsr	SETPC		; tell me where
11313   84D9   85 8D       		sta	FPCH		; save me where
11314   84DB   84 8E       		sty	FPCBNK		; FPC all set
11315   84DD   20 78 90    		jsr	FP2SP		; have SPC point to stack too
11316                      	
11317   84E0   20 5B 92    		jsr	FETCHB		; get MSB of counter
11318   84E3   85 7B       		sta	J+HI		; save MSB
11319   84E5   20 C3 8F    		jsr	NEXTFPC		; point to LSB
11320   84E8   20 5B 92    		jsr	FETCHB		; get LSB
11321   84EB   85 7A       		sta	J+LO		; save LSB
11322   84ED               		
11323   84ED   A5 7A       		lda	J+LO		; get LSB back
11324   84EF   18          		clc			; get ready for add
11325   84F0   65 63       		adc	ARG1+LO		; add how many to get rid off
11326   84F2   85 7A       		sta	J+LO		; save new counter
11327   84F4   A5 7B       		lda	J+HI		; get MSB
11328   84F6   65 64       		adc	ARG1+HI		; add MSB
11329                      	
11330   84F8   20 3A 92    		jsr	STASHB		; save Msb of new counter
11331   84FB   20 A3 8F    		jsr	NEXTSPC		; point to LSB
11332   84FE   A5 7A       		lda	J+LO		; get lsb
11333   8500   20 3A 92    		jsr	STASHB		; okay, reset the counter
11334   8503   60          		rts
11335                      	
11336                      	;
11337                      	; no mouse stuff yet
11338                      	;
11339   8504               	ZMINFO:
11340   8504               	ZMLIMIT:
11341   8504   60          		rts
11342   8505               	ZMENU:
11343   8505   4C 2F 44    		jmp	PREDF		; no menu stuff either
  Wed Jun  7 1989 12:04                                                                                                  Page  169

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11344                      	
11345   8508               		END
11346                      	
11347   8508               		INCLUDE 	READ.ASM
11348   8508               		STTL "--- READ HANDLER ---"
11349                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page  170

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11350                      	; ----
11351                      	; READ
11352                      	; ----
11353                      	; READ LINE INTO TABLE [ARG1] ; PARSE INTO TABLE [ARG2] (IF ARG2 IS THERE)
11354                      	
11355   8508   00          	MAXWORDS DB	0		; maximum number of words in table
11356   8509   00          	WORDCNT	DB	0		; how many words read so far
11357   850A   00          	WORDSTART DB	0		; table offset of word
11358   850B               	SAVESPC	DS	3		; SPC that points to Word Count
11359                      	
11360   850E               	ZREAD:
11361   850E   A5 64       		lda	ARG1+HI		; MAKE THE TABLE ADDRESSES
11362   8510   8D 80 6C    		sta	RDTBL1+HI	; AND PLACE IT HERE TO USE
11363   8513   A5 63       		lda	ARG1+LO
11364   8515   8D 7F 6C    		sta	RDTBL1+LO	; LSBS NEED NOT CHANGE
11365                      	
11366   8518   A9 00       		lda	#0		; TURN OFF FLAGS
11367   851A   8D 5C 6C    		sta	PSVFLG		; FOR ZLEX
11368   851D   8D 5D 6C    		sta	VOCFLG
11369                      	
11370   8520   A6 62       		ldx	NARGS
11371   8522   CA          		dex			; IF 2ND TBL ADDR 0 OR NOT THERE
11372   8523   F0 14       		beq	ONLYRD		; JUST READ IN DON'T DO CONVERSION (X)
11373   8525   A2 00       		ldx	#0		; JIC
11374   8527   A5 66       		lda	ARG2+HI
11375   8529   05 65       		ora	ARG2+LO
11376   852B   F0 0C       		beq	ONLYRD
11377                      	
11378   852D   A5 66       		lda	ARG2+HI
11379   852F   8D 82 6C    		sta	RDTBL2+HI
11380   8532   A5 65       		lda	ARG2+LO
11381   8534   8D 81 6C    		sta	RDTBL2+LO
11382                      	
11383   8537   A2 01       		ldx	#1		;  1 = DO IT ALL (X)
11384   8539               	ONLYRD:
11385   8539   8E 6A 5B    		stx	RDFLAG		; CHECK AGAIN AFTER READ IN WHAT TO DO
11386   853C   20 1A 59    		jsr	INPUT		; READ LINE; RETURN LENGTH IN [RDTBL1],1
11387                      	
11388   853F   AD 6A 5B    		lda	RDFLAG		; FLAG (X)
11389   8542   F0 03       		beq	RDEX		; IF INPUT ONLY, LEAVE NOW
11390   8544   20 54 85    		jsr	DOREST
11391   8547               	RDEX:
11392   8547   A9 F0       		lda	#$F0		; RETURN NOW ONLY WANTED READ PART
11393   8549   8D 6A 5B    		sta	RDFLAG
11394   854C   AD 69 5B    		lda	BRKCHR		; GET BREAK CHAR
11395   854F   A2 00       		ldx	#0
11396   8551   4C DD 43    		jmp	PUTBYT		; RETURN IT 
11397                      	;
11398                      	; IF TIMEOUT, [A]=0 SO WILL QUIT W/NO RESULTS
11399                      	;
11400   8554               	DOREST:
11401   8554   AD 82 6C    		lda	RDTBL2+HI	; get max number of words
11402   8557   20 7C 8F    		jsr	SETPC		; tell me memory and bank
11403   855A   85 8D       		sta	FPCH		; save page
11404   855C   84 8E       		sty	FPCBNK		; and bank
11405   855E   AD 81 6C    		lda	RDTBL2+LO	; and for LSB
11406   8561   85 8C       		sta	FPCL		; it is same
11407   8563   20 5B 92    		jsr	FETCHB		; get max # of words in table
11408   8566   F0 04       		beq	RDERR		; (5/14/85 - FORCE # WORDS TO
11409   8568   C9 3B       		cmp	#59		; BE BETWEEN 1 AND 59)
11410   856A   90 02       		bcc	RD0
11411   856C               	RDERR:
11412   856C   A9 3A       		lda	#58		; (5/16/86 - MAKE IT 58, 59 LOST)
11413   856E               	RD0:
11414   856E   8D 08 85    		sta	MAXWORDS	; save max words
11415   8571   A9 00       		lda	#0		; start at 0 words
11416   8573   8D 09 85    		sta	WORDCNT		; save it
11417   8576   85 94       		sta	WRDLEN		; INIT # CHARS IN WORD COUNTER
11418   8578   A9 02       		lda	#2		
11419   857A   85 93       		sta	SOURCE		; INIT SOURCE TABLE PNTR
11420                      	;
11421                      	; now futz with destination table a little
11422                      	;
11423   857C   20 C3 8F    		jsr	NEXTFPC		; now we point to # words read
11424   857F   A5 8E       		lda	FPCBNK		; and save this pointer
  Wed Jun  7 1989 12:04                                                                                                  Page  171

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11425   8581   8D 0B 85    		sta	SAVESPC		; for stashing at the end
11426   8584   A5 8D       		lda	FPCH
11427   8586   8D 0C 85    		sta	SAVESPC+1
11428   8589   A5 8C       		lda	FPCL
11429   858B   8D 0D 85    		sta	SAVESPC+2
11430                      	
11431   858E   A9 04       		lda	#4		; offset to end of first entry
11432   8590   20 E3 8F    		jsr	ADDFPC		; and point to end of first entry
11433   8593   20 78 90    		jsr	FP2SP		; now put RDTBL2 into stash pointer
11434                      	;
11435                      	; now get source table
11436                      	;	
11437   8596   AD 80 6C    		lda	RDTBL1+HI	; get page
11438   8599   20 7C 8F    		jsr	SETPC		; and tell me what mem page and bank
11439   859C   85 8D       		sta	FPCH		; set up fetch counter
11440   859E   84 8E       		sty	FPCBNK		; and bank
11441   85A0   AD 7F 6C    		lda	RDTBL1+LO	; and lo stays the same
11442   85A3   85 8C       		sta	FPCL		; and save it
11443   85A5   20 C3 8F    		jsr	NEXTFPC		; get # of chars in buffer
11444   85A8   20 5B 92    		jsr	FETCHB		; and tell me about it
11445   85AB   85 92       		sta	LINLEN		; SAVE # CHARS IN LINE
11446   85AD   20 C3 8F    		jsr	NEXTFPC		; now point to first char in line
11447                      	;
11448                      	; MAIN LOOP STARTS HERE
11449                      	;
11450   85B0               	READL:
11451   85B0   AD 08 85    		lda	MAXWORDS	; how we doin'?
11452   85B3   CD 09 85    		cmp	WORDCNT		; see if we have maxxed out
11453   85B6   90 06       		bcc	RLEX		; all done, thank you
11454                      	
11455   85B8   A5 92       		lda	LINLEN
11456   85BA   05 94       		ora	WRDLEN		; OUT OF CHARS AND WORDS?
11457   85BC   D0 16       		bne	RL2		; NOT YET
11458   85BE               	RLEX:
11459   85BE   AD 0B 85    		lda	SAVESPC		; now set SPC to point to # words
11460   85C1   85 91       		sta	SPCBNK		; read byte, as saved at the beginning
11461   85C3   AD 0C 85    		lda	SAVESPC+1
11462   85C6   85 90       		sta	SPCH
11463   85C8   AD 0D 85    		lda	SAVESPC+2
11464   85CB   85 8F       		sta	SPCL
11465   85CD   AD 09 85    		lda	WORDCNT		; get word count
11466   85D0   20 3A 92    		jsr	STASHB		; and save it
11467   85D3   60          		rts
11468   85D4               	RL2:
11469   85D4   A5 94       		lda	WRDLEN		; GET WORD LENGTH
11470   85D6   C9 09       		cmp	#9		; 9 CHARS DONE? (EZIP)
11471   85D8   90 03       		bcc	RL3		; NO, KEEP GOING
11472   85DA   20 0B 87    		jsr	FLUSHW		; ELSE FLUSH REMAINDER OF WORD
11473   85DD               	RL3:
11474   85DD   A5 94       		lda	WRDLEN		; GET WORD LENGTH AGAIN
11475   85DF   D0 24       		bne	READL2		; CONTINUE IF NOT FIRST CHAR
11476                      	;
11477                      	; START A NEW WORD
11478                      	;
11479   85E1   A2 08       		ldx	#8		; CLEAR Z-WORD INPUT BUFFER
11480   85E3   9D 95 6C    	RLL:	sta	IN,X		; [A] = 0
11481   85E6   CA          		dex
11482   85E7   10 FA       		bpl	RLL
11483                      	
11484   85E9   A5 93       		lda	SOURCE		; STORE THE START POS OF THE WORD
11485   85EB   8D 0A 85    		sta	WORDSTART	; and save it for later
11486   85EE   20 5B 92    		jsr	FETCHB		; GET A CHAR FROM SOURCE BUFFER
11487   85F1   20 3C 87    		jsr	SIB		; IS IT A SELF-INSERTING BREAK?
11488   85F4   B0 2C       		bcs	DOSIB		; YES IF CARRY WAS SET
11489   85F6   20 30 87    		jsr	NORM		; IS IT A "NORMAL" BREAK?
11490   85F9   90 0A       		bcc	READL2		; NO, CONTINUE
11491   85FB   E6 93       		inc	SOURCE		; ELSE FLUSH THE STRANDED BREAK
11492   85FD   20 C3 8F    		jsr	NEXTFPC		; and point to next char
11493   8600   C6 92       		dec	LINLEN		; UPDATE # CHARS LEFT IN LINE
11494   8602   4C B0 85    		jmp	READL		; AND LOOP
11495   8605               	READL2:
11496   8605   A5 92       		lda	LINLEN		; OUT OF CHARS YET?
11497   8607   F0 25       		beq	READL3		; LOOKS THAT WAY
11498   8609   20 5B 92    		jsr	FETCHB		; Grab the char
11499   860C   20 2B 87    		jsr	BREAK		; IS IT A BREAK?
  Wed Jun  7 1989 12:04                                                                                                  Page  172

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11500   860F   B0 1D       		bcs	READL3		; YES IF CARRY WAS SET
11501   8611   A6 94       		ldx	WRDLEN		; ELSE STORE THE CHAR
11502   8613   9D 95 6C    		sta	IN,X		; INTO THE INPUT BUFFER
11503   8616   C6 92       		dec	LINLEN		; ONE LESS CHAR IN LINE
11504   8618   E6 94       		inc	WRDLEN		; ONE MORE IN WORD
11505   861A   E6 93       		inc	SOURCE		; and update next source
11506   861C   20 C3 8F    		jsr	NEXTFPC		; POINT TO NEXT CHAR IN SOURCE
11507   861F   4C B0 85    		jmp	READL		; AND LOOP BACK
11508                      	;
11509                      	; handle self-inserting breaks
11510   8622               	DOSIB:
11511   8622   8D 95 6C    		sta	IN		; put the break into 1st word slot
11512   8625   C6 92       		dec	LINLEN		; one less char in line
11513   8627   E6 94       		inc	WRDLEN		; one more in word buffer
11514   8629   E6 93       		inc	SOURCE		; and update next source
11515   862B   20 C3 8F    		jsr	NEXTFPC		; point to next source char
11516   862E               	READL3:
11517   862E   A5 94       		lda	WRDLEN		; ANY CHARS IN WORD YET?
11518   8630   D0 03       		bne	READL31		; yup, so deal with word
11519   8632   4C B0 85    		jmp	READL		; then go get next word
11520   8635               	READL31:
11521   8635   20 17 94    		jsr	CONZST		; CONVERT ASCII IN [IN] TO Z-STRING
11522   8638   20 6C 87    		jsr	FINDW		; AND LOOK IT UP IN VOCABULARY
11523                      	
11524   863B   AD 0A 85    		lda	WORDSTART	; get where it starts
11525   863E   20 3A 92    		jsr	STASHB		; and save it
11526   8641   20 53 90    		jsr	PREVSPC		; step backwards to point to length
11527   8644   A5 94       		lda	WRDLEN		; and get length
11528   8646   20 3A 92    		jsr	STASHB		; and save it away
11529   8649   20 53 90    		jsr	PREVSPC		; and backwards to LSB of offset
11530   864C   A2 06       		ldx	#6		; offset to point to end of next entry
11531                      	
11532   864E   EE 09 85    		inc	WORDCNT		; increment # words read
11533                      	
11534   8651   AD 5C 6C    		lda	PSVFLG		; IF SHOULD PRESERVE WHAT'S IN
11535   8654   F0 06       		beq	READL4
11536   8656   A5 77       		lda	VALUE+HI	; RDTBL2 AND NOT FOUND (VALUE = 0)
11537   8658   05 76       		ora	VALUE+LO
11538   865A   F0 0F       		beq	READL5		; JUST SKIP OVER
11539   865C               	READL4:
11540   865C   A5 76       		lda	VALUE+LO	; GET LSB OF VOCAB ENTRY ADDRESS
11541   865E   20 3A 92    		jsr	STASHB		; and stash it away
11542   8661   20 53 90    		jsr	PREVSPC		; point to MSB part
11543   8664   A5 77       		lda	VALUE+HI	; ALSO STORE MSB IN 2ND SLOT
11544   8666   20 3A 92    		jsr	STASHB		; and send it out
11545   8669   A2 07       		ldx	#7		; offset to point to end of next entry
11546   866B               	READL5:
11547   866B   A9 00       		lda	#0
11548   866D   85 94       		sta	WRDLEN		; CLEAR # CHARS IN WORD
11549   866F   8A          		txa			; get offset
11550   8670   20 06 90    		jsr	ADDSPC		; and point to end of next entry
11551   8673   4C B0 85    		jmp	READL		; AND LOOP BACK
11552                      	
11553                      	; ---
11554                      	; LEX
11555                      	; ---
11556                      	; DO PARSE OF TBL1 INTO TBL2 (2ND HALF OF READ)
11557                      	
11558   8676               	ZLEX:
11559   8676   A5 64       		LDA	ARG1+HI		; MAKE THE TABLE ADDRESSES
11560   8678   8D 80 6C    		STA	RDTBL1+HI	; AND PLACE IT HERE TO USE
11561   867B   A5 63       		LDA	ARG1+LO
11562   867D   8D 7F 6C    		STA	RDTBL1+LO	; LSBS NEED NOT CHANGE
11563                      	
11564   8680   A5 66       		LDA	ARG2+HI
11565   8682   8D 82 6C    		STA	RDTBL2+HI
11566   8685   A5 65       		LDA	ARG2+LO
11567   8687   8D 81 6C    		STA	RDTBL2+LO
11568                      	
11569   868A   C6 62       		DEC	NARGS
11570   868C   C6 62       		DEC	NARGS
11571   868E   F0 13       		BEQ	NORMLEX		; USE NORMAL VOCAB TBL
11572                      	
11573   8690   A9 01       		LDA	#1		; USE ARG3 VOCAB TBL
11574   8692   8D 5D 6C    		STA	VOCFLG
  Wed Jun  7 1989 12:04                                                                                                  Page  173

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11575   8695   A9 00       		LDA	#0
11576   8697   C6 62       		DEC	NARGS
11577   8699   F0 02       		BEQ	NOSAVE		; ZERO UNFOUND WORDS
11578   869B   A9 01       		LDA	#1		; PRESERVE UNFOUND WORD SLOT FLAG
11579   869D   8D 5C 6C    	NOSAVE:	STA	PSVFLG
11580   86A0   4C AB 86    		JMP	DOLEX
11581                      	
11582   86A3   A9 00       	NORMLEX: LDA	#0
11583   86A5   8D 5D 6C    		STA	VOCFLG		; USE NORMAL VOCAB TBL
11584   86A8   8D 5C 6C    		STA	PSVFLG		; AND WILL BE NO PRESERVING
11585                      	
11586   86AB   4C 54 85    	DOLEX:	JMP	DOREST		; GO DO LEXICAL CONVERSION AND JUST RETURN
11587                      	
11588                      	
11589                      	; -----
11590                      	; ZWSTR
11591                      	; -----
11592                      	; CONVERT A WORD TO A ZWORD, PLACE IN ARG4 TBL
11593   86AE               	ZWSTR:
11594   86AE   A5 64       		lda	ARG1+HI		; Make ARG1 be the FPC
11595   86B0   20 7C 8F    		jsr	SETPC		; so get absolute mem bank/page
11596   86B3   84 8E       		sty	FPCBNK		; save bank and
11597   86B5   85 8D       		sta	FPCH		; page
11598   86B7   A5 63       		lda	ARG1+LO
11599   86B9   85 8C       		sta	FPCL		; LSBS NEED NOT CHANGE
11600                      	;
11601                      	; (IGNORE WORD LENGTH CAUSE CHECK FOR BREAK CHAR (9 CHAR MAX))
11602                      	;
11603   86BB   A5 67       		lda	ARG3+LO		; ADD OFFSET INTO INBUF
11604   86BD   20 E3 8F    		jsr	ADDFPC		; add it to the FPC
11605                      	
11606   86C0   A5 6A       		lda	ARG4+HI		; now fix the SPC too
11607   86C2   20 7C 8F    		jsr	SETPC		; get me bank and page
11608   86C5   84 91       		sty	SPCBNK		; save bank
11609   86C7   85 90       		sta	SPCH		; save page
11610   86C9   A5 69       		lda	ARG4+LO
11611   86CB   85 8F       		sta	SPCL		; LSB doesn't change
11612                      	;
11613                      	; START A NEW WORD
11614                      	;
11615   86CD   A9 09       		lda	#9
11616   86CF   85 92       		sta	LINLEN		; 1 WORD'S WORTH
11617   86D1   A9 00       		lda	#0
11618   86D3   85 94       		sta	WRDLEN
11619                      	
11620   86D5   A2 08       		ldx	#8		; CLEAR Z-WORD INPUT BUFFER
11621   86D7   9D 95 6C    	WSTR1:	sta	IN,X		; [A] = 0
11622   86DA   CA          		dex
11623   86DB   10 FA       		bpl	WSTR1
11624                      	;
11625                      	; THIS LOOP READS FROM INBUF TIL BREAK OR 9 CHARS READ
11626                      	;
11627   86DD               	WSTR2:
11628   86DD   20 5B 92    		jsr	FETCHB		; grab the next char
11629   86E0   20 2B 87    		jsr	BREAK		; IS IT A BREAK?
11630   86E3   B0 0E       		bcs	WSTR3		; YES IF CARRY WAS SET
11631   86E5   A6 94       		ldx	WRDLEN		; ELSE STORE THE CHAR
11632   86E7   9D 95 6C    		sta	IN,X		; INTO THE INPUT BUFFER
11633   86EA   E6 94       		inc	WRDLEN		; ONE MORE CHAR IN WORD
11634   86EC   C6 92       		dec	LINLEN		; ONE LESS IN LINE
11635   86EE   20 C3 8F    		jsr	NEXTFPC		; point to next char
11636   86F1   D0 EA       		bne	WSTR2		; AND LOOP BACK TIL DONE
11637   86F3               	WSTR3:
11638   86F3   A5 94       		lda	WRDLEN		; ANY CHARS IN WORD YET?
11639   86F5   F0 13       		beq	WOOPS		; APPARENTLY NOT, OOPS
11640   86F7   20 17 94    		jsr	CONZST		; CONVERT ASCII IN [IN] TO Z-STRING
11641                      	
11642   86FA   A2 00       		ldx	#0		; MOVE FROM [OUT] TO RDTBL2
11643   86FC   BD 9E 6C    	WSTR4:	lda	OUT,X
11644   86FF   20 3A 92    		jsr	STASHB		; and stash it into ZWORD table
11645   8702   20 A3 8F    		jsr	NEXTSPC		; and point to next byte
11646   8705   E8          		inx
11647   8706   E0 06       		cpx	#6		; max 6 word table
11648   8708   D0 F2       		bne	WSTR4		; not done yet
11649   870A               	WOOPS:
  Wed Jun  7 1989 12:04                                                                                                  Page  174

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11650   870A   60          		rts
11651                      	
11652                      	; ----------
11653                      	; FLUSH WORD
11654                      	; ----------
11655                      	
11656   870B               	FLUSHW:
11657   870B   A5 92       		lda	LINLEN		; ANY CHARS LEFT IN LINE?
11658   870D   F0 14       		beq	FLEX		; NO, SCRAM
11659   870F   20 5B 92    		jsr	FETCHB		; GRAB A CHAR
11660   8712   20 2B 87    		jsr	BREAK		; IS IT A BREAK?
11661   8715   B0 0C       		bcs	FLEX		; EXIT IF SO
11662   8717   C6 92       		dec	LINLEN		; ELSE UPDATE CHAR COUNT
11663   8719   E6 94       		inc	WRDLEN		; AND WORD-CHAR COUNT
11664   871B   E6 93       		inc	SOURCE		; AND CHAR POINTER
11665   871D   20 C3 8F    		jsr	NEXTFPC		; and FPC pointer too
11666   8720   4C 0B 87    		jmp	FLUSHW		; AND LOOP BACK (ALWAYS)
11667   8723               	FLEX:
11668   8723   60          		rts
11669                      	
11670                      	
11671                      	; ---------------------------------
11672                      	; IS CHAR IN [A] ANY TYPE OF BREAK?
11673                      	; ---------------------------------
11674                      	; ------------------
11675                      	; NORMAL BREAK CHARS
11676                      	; ------------------
11677                      	
11678   8724   21 3F 2C 2E 	BRKTBL:	DB	'!?,.'		; IN ORDER OF
11679   8728   0D          		DB	$0D		; ASCII	ENDING FREQUENCY
11680   8729   20          		DB	SPACE		; SPACE CHAR IS TESTED FIRST FOR SPEED
11681   872A   00          		DB	0		; ZERO ADDED FOR ZWSTR (X)
11682          0007        	NBRKS	EQU	$-BRKTBL	; # NORMAL BREAKS
11683                      	
11684   872B   20 3C 87    	BREAK:	JSR	SIB		; CHECK FOR A SIB FIRST
11685   872E   B0 3A       		BCS	FBRK		; EXIT NOW IF MATCHED
11686                      	
11687                      		; ELSE FALL THROUGH ...
11688                      	
11689                      	
11690                      	; --------------------------------
11691                      	; IS CHAR IN [A] A "NORMAL" BREAK?
11692                      	; --------------------------------
11693                      	
11694   8730   A2 06       	NORM:	LDX	#NBRKS-1	; NUMBER OF "NORMAL" BREAKS
11695   8732   DD 24 87    	NBL:	CMP	BRKTBL,X	; MATCHED?
11696   8735   F0 33       		BEQ	FBRK		; YES, EXIT
11697   8737   CA          		DEX
11698   8738   10 F8       		BPL	NBL		; NO, KEEP LOOKING
11699   873A   18          		CLC			; NO MATCH, CLEAR CARRY
11700   873B   60          		RTS			; AND RETURN
11701                      	
11702                      	
11703                      	; ---------------------
11704                      	; IS CHAR IN [A] A SIB?
11705                      	; ---------------------
11706                      	
11707   873C   85 AC       	SIB:	STA	IOCHAR		; SAVE TEST CHAR
11708   873E   A5 54       		lda	VOCAB+ABANK	; get bank
11709   8740   85 8B       		sta	MPCBNK		; and save it
11710   8742   A5 53       		lda	VOCAB+HI	; and hi part
11711   8744   85 8A       		sta	MPCPNT+HI	; and save it
11712   8746   AD 08 96    		lda	ZBEGIN+ZVOCAB+0 ; GET 1ST BYTE IN VOCAB TABLE
11713   8749   AC 09 96    		LDY	ZBEGIN+ZVOCAB+1
11714   874C   85 87       		STA	MPCM
11715   874E   84 86       		STY	MPCL
11716   8750   A9 00       		LDA	#0
11717   8752   85 88       		STA	MPCH		; now everything is set up
11718   8754   20 0E 92    		JSR	GETBYT		; HAS # SIBS
11719   8757   85 7A       		STA	J		; USE AS AN INDEX
11720   8759   20 0E 92    	SBL:	JSR	GETBYT		; GET NEXT SIB
11721   875C   C5 AC       		CMP	IOCHAR		; MATCHED?
11722   875E   F0 08       		BEQ	FBRK0		; YES, REPORT IT
11723   8760   C6 7A       		DEC	J
11724   8762   D0 F5       		BNE	SBL		; ELSE KEEP LOOPING
  Wed Jun  7 1989 12:04                                                                                                  Page  175

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11725   8764   A5 AC       		LDA	IOCHAR
11726   8766   18          		CLC			; NO MATCH, SO
11727   8767   60          		RTS			; EXIT WITH CARRY CLEAR
11728   8768   A5 AC       	FBRK0:	LDA	IOCHAR
11729   876A   38          	FBRK:	SEC			; EXIT WITH CARRY SET
11730   876B   60          		RTS			; IF MATCHED WITH A BREAK CHAR
11731                      	
11732                      	
11733                      	; -----------------
11734                      	; VOCABULARY SEARCH
11735                      	; -----------------
11736                      	; ENTRY: 6-BYTE TARGET Z-WORD IN [OUT]
11737                      	; EXIT: VIRTUAL ENTRY ADDRESS IN [VALUE] IF FOUND ;
11738                      	; OTHERWISE [VALUE] = 0
11739                      	
11740          0078        	VWLEN	EQU	I		; **********
11741          007B        	VWCUR	EQU	J+HI
11742                      	
11743   876C               	FINDW:
11744   876C   AD 5D 6C    		lda	VOCFLG		; USE WHAT VOCAB TBL?
11745   876F   F0 07       		beq	FWL2		; NORMAL
11746   8771   A5 68       		lda	ARG3+HI		; IF ALTERNATE VOCTBL
11747   8773   A4 67       		ldy	ARG3+LO		; IT'S ADDR IS IN ARG3
11748   8775   4C 9F 87    		jmp	FWL3
11749   8778               	FWL2:
11750   8778   AD 94 6C    		lda	DIDVTBL		; have we done default vocab table?
11751   877B   F0 17       		beq	FWLNEW		; nope, so do it the first time
11752   877D   A2 02       		ldx	#2		; restore pointers
11753   877F               	FWRSTL:
11754   877F   BD 8B 6C    		lda	VOCMPC,X	; get it
11755   8782   95 86       		sta	MPC,X		; save it
11756   8784   BD 8E 6C    		lda	VCESVE,X	; save VOCEND too
11757   8787   95 B3       		sta	VOCEND,X	; okay, we have
11758   8789   BD 91 6C    		lda	VWLSVE,X	; and starting length
11759   878C   95 78       		sta	VWLEN,X		; we have
11760   878E   CA          		dex			; count
11761   878F   10 EE       		bpl	FWRSTL		; okay, next one
11762   8791   4C 75 88    		jmp	FWLOOP		; and go do it
11763   8794               	FWLNEW:
11764   8794   A9 FF       		lda	#$FF		; show we are doing default table
11765   8796   8D 94 6C    		sta	DIDVTBL		; we shall
11766                      	
11767   8799   AD 08 96    		lda	ZBEGIN+ZVOCAB	; GET VIRTUAL ADDR OF VOCAB TBL
11768   879C   AC 09 96    		ldy	ZBEGIN+ZVOCAB+1
11769   879F               	FWL3:
11770   879F   85 87       		STA	MPCM
11771   87A1   84 86       		STY	MPCL
11772   87A3   A9 00       		LDA	#0
11773   87A5   85 88       		STA	MPCH
11774   87A7   20 85 90    		JSR	VLDMPC		; SET TO NEW PAGE
11775   87AA   20 0E 92    		JSR	GETBYT		; GET # SIBS
11776   87AD   18          		CLC
11777   87AE   65 86       		ADC	MPCL		; GET ACTUAL BASE ADDR OF VOCAB ENTRIES
11778   87B0   85 86       		STA	MPCL
11779   87B2   90 02       		BCC	FWL0
11780   87B4   E6 87       		INC	MPCM
11781   87B6   20 85 90    	FWL0:	JSR	VLDMPC		; SET TO NEW PAGE
11782   87B9   20 0E 92    		JSR	GETBYT		; GET # BYTES PER ENTRY (AND MOVE TO NEXT BYTE)
11783   87BC   85 95       		STA	ESIZE		; SAVE IT HERE
11784   87BE   85 78       		STA	VWLEN+0		; AND HERE
11785   87C0   A9 00       		LDA	#0		; CLEAR REST OF COUNTER
11786   87C2   85 79       		STA	VWLEN+1
11787   87C4   85 7A       		STA	VWLEN+2
11788                      	
11789   87C6   20 0E 92    		JSR	GETBYT		; GET # OF ENTRIES IN TBL (MSB)
11790   87C9   8D 84 6C    		STA	NENTS+HI	; AND STUFF IT IN [NENTS]
11791   87CC   20 0E 92    		JSR	GETBYT		; DON'T FORGET THE LSB!
11792   87CF   8D 83 6C    		STA	NENTS+LO
11793   87D2   AD 84 6C    		LDA	NENTS+HI
11794   87D5   10 03       		BPL	SORTED
11795   87D7   4C 2E 89    		JMP	UNSORTED	; VOCAB LIST IS UNSORTED, HANDLE DIFFERENTLY
11796   87DA               	SORTED:
11797   87DA   A9 00       		LDA	#0		; FIND SIZE OF VAOCAB TBL
11798   87DC   85 B3       		STA	VOCEND		; TO LOCATE THE END OF IT
11799   87DE   85 B4       		STA	VOCEND+1
  Wed Jun  7 1989 12:04                                                                                                  Page  176

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11800   87E0   85 B5       		STA	VOCEND+2
11801   87E2   A6 95       		LDX	ESIZE
11802   87E4               	FWL1:
11803   87E4   18          		CLC
11804   87E5   A5 B3       		LDA	VOCEND		; (# OF ENTRIES) * (ENTRY SIZE)
11805   87E7   6D 83 6C    		ADC	NENTS+LO
11806   87EA   85 B3       		STA	VOCEND
11807   87EC   A5 B4       		LDA	VOCEND+1
11808   87EE   6D 84 6C    		ADC	NENTS+HI
11809   87F1   85 B4       		STA	VOCEND+1
11810   87F3   90 02       		bcc	FWL11
11811   87F5   E6 B5       		inc	VOCEND+2
11812   87F7               	FWL11:
11813   87F7   CA          		DEX
11814   87F8   D0 EA       		BNE	FWL1
11815                      	
11816   87FA   18          		CLC
11817   87FB   A5 B3       		LDA	VOCEND		; AND ADD LENGTH TO START OF TBL
11818   87FD   65 86       		ADC	MPCL		; TO GET END OF TBL
11819   87FF   85 B3       		STA	VOCEND
11820   8801   A5 B4       		LDA	VOCEND+1
11821   8803   65 87       		ADC	MPCM
11822   8805   85 B4       		STA	VOCEND+1
11823   8807   A5 B5       		LDA	VOCEND+2
11824   8809   65 88       		ADC	MPCH
11825   880B   85 B5       		STA	VOCEND+2	; TO SAVE FOR TESTING IF PAST END
11826                      	
11827   880D   A5 B3       		LDA	VOCEND		; SUBTRACT [ESIZE] SO THAT
11828   880F   38          		SEC			; [VOCEND] POINTS TO REAL LAST ENTRY
11829   8810   E5 95       		SBC	ESIZE
11830   8812   85 B3       		STA	VOCEND
11831   8814   A5 B4       		LDA	VOCEND+1
11832   8816   E9 00       		SBC	#0
11833   8818   85 B4       		STA	VOCEND+1
11834                      	;
11835                      	; BEGIN THE SEARCH! [MPC] NOW POINTS TO 1ST ENTRY
11836                      	;
11837   881A   4E 84 6C    		LSR	NENTS+HI	; 2 ALIGN # OF ENTRIES
11838   881D   6E 83 6C    		ROR	NENTS+LO	; 2 point to middle of table
11839   8820   06 78       	FWCALC:	ASL	VWLEN+0		; CALCULATE INITIAL OFFSET FOR SEARCH
11840   8822   26 79       		ROL	VWLEN+1
11841   8824   26 7A       		ROL	VWLEN+2
11842   8826   4E 84 6C    		LSR	NENTS+HI
11843   8829   6E 83 6C    		ROR	NENTS+LO
11844   882C   D0 F2       		BNE	FWCALC
11845                      	
11846   882E   18          		CLC			; ADD 1ST OFFSET INTO START OF VOCABULARL
11847   882F   A5 86       		LDA	MPCL		; WHICH IS CURRENTLY IN MPC
11848   8831   65 78       		ADC	VWLEN+0
11849   8833   85 86       		STA	MPCL
11850   8835   A5 87       		LDA	MPCM
11851   8837   65 79       		ADC	VWLEN+1
11852   8839   85 87       		STA	MPCM
11853   883B   A5 88       		LDA	MPCH
11854   883D   65 7A       		ADC	VWLEN+2
11855   883F   85 88       		STA	MPCH
11856                      	
11857   8841   38          		SEC			; AVOID FENCE-POST BUG FOR
11858   8842   A5 86       		LDA	MPCL		; EXACT-POWER-OF-2 TBL (DUNCAN)
11859   8844   E5 95       		SBC	ESIZE
11860   8846   85 86       		STA	MPCL
11861   8848   B0 0F       		BCS	FWSAVE
11862   884A   A5 87       		LDA	MPCM
11863   884C   38          		SEC
11864   884D   E9 01       		SBC	#1
11865   884F   85 87       		STA	MPCM
11866   8851   B0 06       		BCS	FWSAVE
11867   8853   A5 88       		LDA	MPCH
11868   8855   E9 00       		SBC	#0
11869   8857   85 88       		STA	MPCH
11870   8859               	FWSAVE:
11871   8859   AD 94 6C    		lda	DIDVTBL		; are we installing default table?
11872   885C   10 17       		bpl	FWLOOP		; already have?	
11873   885E   A2 02       		ldx	#2		; save MPC
11874   8860   8E 94 6C    		stx	DIDVTBL		; show we have saved it
  Wed Jun  7 1989 12:04                                                                                                  Page  177

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11875   8863               	FWSVL:
11876   8863   B5 86       		lda	MPC,X		; get it
11877   8865   9D 8B 6C    		sta	VOCMPC,X	; save it
11878   8868   B5 B3       		lda	VOCEND,X	; save VOCEND too
11879   886A   9D 8E 6C    		sta	VCESVE,X	; okay, we have
11880   886D   B5 78       		lda	VWLEN,X		; and starting length
11881   886F   9D 91 6C    		sta	VWLSVE,X	; we have
11882   8872   CA          		dex			; count
11883   8873   10 EE       		bpl	FWSVL		; okay, next one
11884   8875               	FWLOOP:
11885   8875   46 7A       		lsr	VWLEN+2		; SET FOR NEXT OFFSET,
11886   8877   66 79       		ror	VWLEN+1		; WHICH IS HALF THIS ONE
11887   8879   66 78       		ror	VWLEN+0
11888                      	
11889   887B   A5 86       		lda	MPCL		; HOLD START ADDR, MPC WILL BE A MESS
11890   887D   85 7B       		sta	VWCUR+0
11891   887F   A5 87       		lda	MPCM
11892   8881   85 7C       		sta	VWCUR+1
11893   8883   A5 88       		lda	MPCH
11894   8885   85 7D       		sta	VWCUR+2
11895                      	
11896   8887   20 85 90    		jsr	VLDMPC		; SET TO NEW PAGE
11897   888A   20 0E 92    		jsr	GETBYT		; GET 1ST BYTE OF ENTRY
11898   888D   CD 9E 6C    		cmp	OUT		; MATCH 1ST BYTE OF TARGET?
11899   8890   90 34       		bcc	WNEXT		; LESS
11900   8892   D0 66       		bne	FWPREV		; GREATER
11901   8894   20 0E 92    		jsr	GETBYT	
11902   8897   CD 9F 6C    		cmp	OUT+1		; 2ND BYTE MATCHED?
11903   889A   90 2A       		bcc	WNEXT
11904   889C   D0 5C       		bne	FWPREV		; NOPE
11905   889E   20 0E 92    		jsr	GETBYT
11906   88A1   CD A0 6C    		cmp	OUT+2		; 3RD BYTE?
11907   88A4   90 20       		bcc	WNEXT
11908   88A6   D0 52       		bne	FWPREV		; SORRY ...
11909   88A8   20 0E 92    		jsr	GETBYT
11910   88AB   CD A1 6C    		cmp	OUT+3		; 4TH BYTE
11911   88AE   90 16       		bcc	WNEXT
11912   88B0   D0 48       		BNE	FWPREV
11913   88B2   20 0E 92    		JSR	GETBYT
11914   88B5   CD A2 6C    		CMP	OUT+4		; 5TH BYTE?
11915   88B8   90 0C       		BCC	WNEXT
11916   88BA   D0 3E       		BNE	FWPREV		; SORRY ...
11917   88BC   20 0E 92    		JSR	GETBYT
11918   88BF   CD A3 6C    		CMP	OUT+5		; LAST BYTE?
11919   88C2   F0 5A       		BEQ	FWSUCC		; FOUND IT!
11920   88C4   B0 34       		BCS	FWPREV		; ELSE BACK UP ...
11921   88C6               	WNEXT:
11922   88C6   A5 7B       		LDA	VWCUR+0		; TO MOVE UP, JUST ADD
11923   88C8   18          		CLC			; OFFSET FROM START OF THIS
11924   88C9   65 78       		ADC	VWLEN+0		; ENTRY
11925   88CB   85 86       		STA	MPCL
11926   88CD   A5 7C       		LDA	VWCUR+1
11927   88CF   65 79       		ADC	VWLEN+1
11928   88D1   B0 18       		BCS	WNXT2		; SAVES CODE (?)
11929                      	
11930   88D3   85 87       		STA	MPCM
11931   88D5   A9 00       		LDA	#0
11932   88D7   85 88       		STA	MPCH
11933   88D9               	WNXT0:
11934   88D9   A5 87       		LDA	MPCM		; GONE PAST END?
11935   88DB   C5 B4       		CMP	VOCEND+1	
11936   88DD   F0 04       		BEQ	WNXT1		; MAYBE
11937   88DF   B0 0A       		BCS	WNXT2		; YES
11938   88E1   90 2A       		BCC	FWMORE		; NO
11939   88E3               	WNXT1:
11940   88E3   A5 86       		LDA	MPCL
11941   88E5   C5 B3       		CMP	VOCEND
11942   88E7   90 24       		BCC	FWMORE		; NO
11943   88E9   F0 22       		BEQ	FWMORE		; NO, EQUAL
11944   88EB               	WNXT2:
11945   88EB   A5 B3       		LDA	VOCEND		; YES, SO POINT TO END OF TBL
11946   88ED   85 86       		STA	MPCL
11947   88EF   A5 B4       		LDA	VOCEND+1
11948   88F1   85 87       		STA	MPCM
11949   88F3   A5 B5       		LDA	VOCEND+2
  Wed Jun  7 1989 12:04                                                                                                  Page  178

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11950   88F5   85 88       		STA	MPCH
11951   88F7   4C 0D 89    		JMP	FWMORE
11952   88FA               	FWPREV:
11953   88FA   A5 7B       		LDA	VWCUR+0		; TO MOVE DOWN, JUST SUBTRACT
11954   88FC   38          		SEC			; OFFSET FROM START OF THIS
11955   88FD   E5 78       		SBC	VWLEN+0		; ENTRY
11956   88FF   85 86       		STA	MPCL
11957   8901   A5 7C       		LDA	VWCUR+1
11958   8903   E5 79       		SBC	VWLEN+1
11959   8905   85 87       		STA	MPCM
11960   8907   A5 7D       		LDA	VWCUR+2
11961   8909   E5 7A       		SBC	VWLEN+2
11962   890B   85 88       		STA	MPCH
11963   890D               	FWMORE:
11964   890D   A5 7A       		LDA	VWLEN+2		; IF OFFSET >GE< 1 WORD, CONTINUE
11965   890F   D0 0A       		BNE	FWM1
11966   8911   A5 79       		LDA	VWLEN+1
11967   8913   D0 06       		BNE	FWM1
11968   8915   A5 78       		LDA	VWLEN+0
11969   8917   C5 95       		CMP	ESIZE
11970   8919   90 0C       		BCC	FWFAIL
11971   891B               	FWM1:
11972   891B   4C 75 88    		JMP	FWLOOP		; AND TRY AGAIN
11973                      	
11974   891E   A5 7B       	FWSUCC:	LDA	VWCUR+0		; ENTRY MATCHED!  RETRIEVE START OF WORD
11975   8920   85 76       		STA	VALUE+LO
11976   8922   A5 7C       		LDA	VWCUR+1
11977   8924   85 77       		STA	VALUE+HI	; MUST BE 64K LIMIT AS ONLY
11978   8926   60          		RTS			; WORD VALUE RETURNABLE
11979   8927               	FWFAIL:
11980   8927   A9 00       		LDA	#0		; NOT FOUND
11981   8929   85 76       		STA	VALUE+LO
11982   892B   85 77       		STA	VALUE+HI
11983   892D   60          		RTS			; THEN RETURN WITH [VALUE] = 0
11984                      	;
11985                      	; DO UNSORTED SEARCH ON VOCAB TBL IN MPC
11986                      	;
11987   892E               	UNSORTED:
11988   892E   A9 FF       		LDA	#$FF		; 2'S COMPLEMENT LENGTH
11989   8930   4D 84 6C    		EOR	NENTS+HI	; TO GET REAL LENGTH
11990   8933   8D 84 6C    		STA	NENTS+HI	; WAS NEGATIVE TO SIGNIFY
11991   8936   A9 FF       		LDA	#$FF		; UNSORTED VOCAB TBL
11992   8938   4D 83 6C    		EOR	NENTS+LO
11993   893B   8D 83 6C    		STA	NENTS+LO
11994   893E   EE 83 6C    		INC	NENTS+LO	; 2'S CMPL
11995   8941   D0 03       		BNE	UNSRT0
11996   8943   EE 84 6C    		INC	NENTS+HI
11997   8946               	UNSRT0:
11998   8946   A5 86       		LDA	MPCL		; HOLD START ADDR, MPC WILL BE A MESS
11999   8948   85 7B       		STA	VWCUR+0
12000   894A   A5 87       		LDA	MPCM
12001   894C   85 7C       		STA	VWCUR+1
12002   894E   A5 88       		LDA	MPCH
12003   8950   85 7D       		STA	VWCUR+2
12004                      	
12005   8952   20 0E 92    		JSR	GETBYT		; GET 1ST BYTE OF ENTRY
12006   8955   CD 9E 6C    		CMP	OUT		; MATCH 1ST BYTE OF TARGET?
12007   8958   D0 28       		BNE	FNEXT		; LESS
12008   895A   20 0E 92    		JSR	GETBYT
12009   895D   CD 9F 6C    		CMP	OUT+1		; 2ND BYTE MATCHED?
12010   8960   D0 20       		BNE	FNEXT
12011   8962   20 0E 92    		JSR	GETBYT
12012   8965   CD A0 6C    		CMP	OUT+2		; 3RD BYTE?
12013   8968   D0 18       		BNE	FNEXT
12014   896A   20 0E 92    		JSR	GETBYT
12015   896D   CD A1 6C    		CMP	OUT+3		; 4TH BYTE
12016   8970   D0 10       		BNE	FNEXT
12017   8972   20 0E 92    		JSR	GETBYT
12018   8975   CD A2 6C    		CMP	OUT+4		; 5TH BYTE?
12019   8978   D0 08       		BNE	FNEXT
12020   897A   20 0E 92    		JSR	GETBYT
12021   897D   CD A3 6C    		CMP	OUT+5		; LAST BYTE?
12022   8980   F0 9C       		BEQ	FWSUCC		; FOUND IT!
12023                      	
12024   8982   A5 7B       	FNEXT:	LDA	VWCUR+LO	; TO MOVE UP, JUST ADD
  Wed Jun  7 1989 12:04                                                                                                  Page  179

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

12025   8984   18          		CLC			; OFFSET FROM START OF THIS
12026   8985   65 95       		ADC	ESIZE		; ENTRY
12027   8987   85 86       		STA	MPCL
12028   8989   90 0D       		BCC	FNEXT0
12029                      	
12030   898B   A5 7C       		LDA	VWCUR+HI	; PICK UP CARRY
12031   898D   69 00       		ADC	#0
12032   898F   85 87       		STA	MPCM
12033   8991   A9 00       		LDA	#0
12034   8993   85 88       		STA	MPCH
12035   8995   20 85 90    		JSR	VLDMPC		; CROSSED PAGE SO RE-VALIDATE
12036                      	
12037   8998   CE 83 6C    	FNEXT0:	DEC	NENTS+LO	; CHECKED ALL ENTRIES?
12038   899B   D0 A9       		BNE	UNSRT0
12039   899D   AD 84 6C    		LDA	NENTS+HI
12040   89A0   F0 85       		BEQ	FWFAIL		; GO INDICATE NO FIND
12041   89A2   CE 84 6C    		DEC	NENTS+HI	; OR DO NEXT 256 ENTRIES
12042   89A5   4C 46 89    		JMP	UNSRT0
12043                      	
12044   89A8               		END
12045                      	
12046   89A8               		INCLUDE		ZSAVRES.ASM
12047                      	
12048   89A8               		STTL	"--- ZIP SAVE AND RESTORE ROUTINES ---"
12049                      		PAGE
  Wed Jun  7 1989 12:04                                                                                                  Page  180

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12050                      	; -----------------------------
12051                      	; SET UP SAVE & RESTORE SCREENS
12052                      	; -----------------------------
12053   89A8               	SAVRES:
12054   89A8   20 E7 54    		jsr	ZCRLF	; CLEAR THE LINE BUFFER
12055   89AB   A9 00       		lda	#0	
12056   89AD   85 AA       		sta	SCRIPT	; DISABLE SCRIPTING
12057   89AF   AD 54 C0    		lda	PAGE2SW+MAIN	; just do this for the heck of it
12058   89B2   AD 83 C0    	        lda     BNK2SET		; this stuff too
12059   89B5   AD 83 C0    	        lda     BNK2SET
12060                      	
12061   89B8   60          		rts
12062                      	
12063                      	; -----------------------------
12064                      	; SAVE & RESTORE STRINGS
12065                      	; -----------------------------
12066   89B9   59 45 53    	YES:	DB	"YES"
12067   89BC   0D          		DB	EOL	
12068          0004        	YESL	EQU	$-YES	
12069   89BD   4E 4F       	NO:	DB	"NO"	
12070   89BF   0D          		DB	EOL	
12071          0003        	NOL	EQU	$-NO	
12072                      	
12073   89C0   0D          	NAMEQ:	db	EOL
12074   89C1   49 6E 73 65 72 		db	"Insert save disk and enter "
        89C6   74 20 73 61 76 
        89CB   65 20 64 69 73 
        89D0   6B 20 61 6E 64 
        89D5   20 65 6E 74 65 
        89DA   72 20 
12075   89DC   66 75 6C 6C 20 		db	"full pathname of save file: "
        89E1   70 61 74 68 6E 
        89E6   61 6D 65 20 6F 
        89EB   66 20 73 61 76 
        89F0   65 20 66 69 6C 
        89F5   65 3A 20 
12076   89F8   0D          		db	EOL
12077   89F9   48 69 74 20 27 		db	"Hit '?' key to get a list of online volumes."
        89FE   3F 27 20 6B 65 
        8A03   79 20 74 6F 20 
        8A08   67 65 74 20 61 
        8A0D   20 6C 69 73 74 
        8A12   20 6F 66 20 6F 
        8A17   6E 6C 69 6E 65 
        8A1C   20 76 6F 6C 75 
        8A21   6D 65 73 2E 
12078   8A25   0D          		db	EOL
12079   8A26   43 75 72 72 65 		db	"Current pathname is:",
        8A2B   6E 74 20 70 61 
        8A30   74 68 6E 61 6D 
        8A35   65 20 69 73 3A 
        8A3A   00 
12080   8A3B   0D          		db	EOL
12081          007C        	NAMEQL	EQU	$-NAMEQ
12082                      	SNDATA:		 	; show start of name and length
12083   8A3C   00          	SNAMEL:	db	0	; place to save length of name
12084   8A3D               	SAVENAME: ds	64+15	; save plenty of room for max name
12085                      	
12086   8A8C   0D 46 69 6C 65 	DELQ:	db	EOL,"File exists, delete it (Yes/No)? "
        8A91   20 65 78 69 73 
        8A96   74 73 2C 20 64 
        8A9B   65 6C 65 74 65 
        8AA0   20 69 74 20 28 
        8AA5   59 65 73 2F 4E 
        8AAA   6F 29 3F 20 
12087          0023        	DELQL	EQU	$-DELQ+1	; include this following EOL
12088   8AAE   0D 50 6C 65 61 	RETQ:	db	EOL,"Please hit [RETURN]",EOL
        8AB3   73 65 20 68 69 
        8AB8   74 20 5B 52 45 
        8ABD   54 55 52 4E 5D 
        8AC2   0D 
12089          0015        	RETQL	EQU	$-RETQ
12090   8AC3   0D 4E 61 6D 65 	PREFIX_ERR: db  EOL,"Name must have prefix, "
        8AC8   20 6D 75 73 74 
        8ACD   20 68 61 76 65 
  Wed Jun  7 1989 12:04                                                                                                  Page  181

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

        8AD2   20 70 72 65 66 
        8AD7   69 78 2C 20 
12091   8ADB   69 2E 65 2E 3A 	        db      "i.e.: /DISKNAME/FILENAME",EOL
        8AE0   20 2F 44 49 53 
        8AE5   4B 4E 41 4D 45 
        8AEA   2F 46 49 4C 45 
        8AEF   4E 41 4D 45 0D 
12092          0031        	PREFIX_ERRL EQU  $-PREFIX_ERR
12093                      	; -----------------------------
12094                      	; SAVE/RESTORE Parameter Blocks
12095                      	; -----------------------------
12096   8AF4               	CREATE_PB:
12097   8AF4   07          		db	7		; 7 parameters
12098   8AF5   3C8A        		dw	SNDATA		; pointer to name
12099   8AF7   C3          		db	$C3		; full access to file
12100   8AF8   06          		db	$06		; BIN file type
12101   8AF9   0000        		dw	0		; no aux data
12102   8AFB   01          		db	$01		; standard file
12103   8AFC   0000        		dw	0		; create date
12104   8AFE   0000        		dw	0
12105                      		     ; creation time
12106   8B00               	SETEOF_PB:
12107   8B00   02          		db 	2		; 1 parameter
12108   8B01   00          	        db      0               ; refnum
12109   8B02   00 00 00    	        db      0,0,0           ; set to zero spot to clear it out
12110   8B05               	OPEN_SV:
12111   8B05   03          		db	3		; 3 parameters
12112   8B06   3C8A        		dw	SNDATA		; name
12113   8B08   0011        		dw	GAME1FIO	; file buffer
12114   8B0A   00          		db	0		; ref num
12115   8B0B               	CLOSE_PB:
12116   8B0B   01          		db	1		; only one parm
12117   8B0C   00          		db	0		; the refnum
12118   8B0D               	WRITE_SV:
12119   8B0D   04          		db	4		; parm count
12120   8B0E   00          		db	0		; refnum
12121   8B0F   0008        		dw	IOBUFF		; data is always here
12122   8B11   0002        		dw	512             ; 1 page worth
12123   8B13   0000        		dw	0		; how many actually went
12124                      	
12125                      	; get the save file name.  If user hits the ESC key, then abort the
12126                      	; save by return with the carry set.
12127                      	;
12128   8B15               	GET_SNAME:
12129   8B15   20 94 8C    		jsr	CLOSE_GAME	; close the game files
12130   8B18   20 A9 4C    		jsr	SWAP2INFOW	; goto information window
12131   8B1B               	GTSN0:
12132   8B1B               		DLINE	NAMEQ		; ask about name
12133   8B1B   A2 C0       		ldx	#<NAMEQ	; get part of NAMEQ
12134   8B1D   A9 89       		lda	#>NAMEQ	; get other part of string
12135          [01]        		IFMA	2		; check to see if length passed in
12136                      		ldy			; then just fetch it
12137          [01]        		ELSE
12138   8B1F   A0 7C       		ldy	#NAMEQL	; get length of string
12139          [00]        		ENDIF
12140   8B21   20 6B 4C    		jsr	DLINE		; print the string
12141   8B24               		.MACEND
12142   8B24   AD 3C 8A    		lda	SNAMEL		; is there a name yet?
12143   8B27   F0 0A       		beq	GTSN00		; nope
12144   8B29               		DLINE	SAVENAME,SNAMEL	; show current name of file
12145   8B29   A2 3D       		ldx	#<SAVENAME	; get part of SAVENAME
12146   8B2B   A9 8A       		lda	#>SAVENAME	; get other part of string
12147          [01]        		IFMA	2		; check to see if length passed in
12148   8B2D   AC 3C 8A    		ldy	SNAMEL		; then just fetch it
12149          [01]        		ELSE
12150                      		ldy	#SAVENAMEL	; get length of string
12151          [00]        		ENDIF
12152   8B30   20 6B 4C    		jsr	DLINE		; print the string
12153   8B33               		.MACEND
12154   8B33               	GTSN00:
12155   8B33   A9 00       		lda	#0		; clear line count	
12156   8B35   8D 0C 8B    		sta	CLOSE_PB+CL_REFNUM ; clear this too
12157   8B38   AE 3C 8A    		ldx	SNAMEL		; get length
12158   8B3B   86 A9       		stx	CHRCNT		; okay
12159   8B3D   AC 3C 8A    		ldy	SNAMEL		; point to copy
  Wed Jun  7 1989 12:04                                                                                                  Page  182

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12160   8B40   88          		dey			; one less
12161   8B41               	GCOPY:
12162   8B41   BD 3C 8A    		lda	SNAMEL,X	; get char
12163   8B44   99 00 02    		sta	LBUFF,Y		; save it
12164   8B47   CA          		dex			; point to previous one
12165   8B48   88          		dey			; previous pointer
12166   8B49   10 F6       		bpl	GCOPY		; copy until length byte
12167   8B4B               	GNAME:
12168   8B4B   20 31 51    		jsr	GETKEY		; WAIT FOR A KEY
12169   8B4E   C9 0D       		cmp	#EOL		; IF [RETURN],
12170   8B50   F0 5F       		beq	GOTNAME		; got the name
12171   8B52   C9 1B       		cmp	#ESCAPE		; hit escape key?
12172   8B54   38          		sec			; just in case it does exit
12173   8B55   D0 03       		bne     GNM2
12174   8B57   4C F5 8B    	        jmp     GNX             ; all done then
12175   8B5A               	GNM2:
12176   8B5A   C9 08       		cmp	#BACKSPACE	; erasing things?
12177   8B5C   D0 15       		bne	GNM1		; nope
12178                      	
12179   8B5E   A6 A9       		ldx	CHRCNT		; make sure there are chars there
12180   8B60   D0 06       		bne	GNMBP		; ayyup, do delete
12181   8B62               	GNMBAD:
12182   8B62   20 C3 4E    		jsr	BEEP		; no room for delete
12183   8B65   4C 4B 8B    		jmp	GNAME		; okay
12184   8B68               	GNMBP:
12185   8B68   CA          		dex			; point down one
12186   8B69   86 A9       		stx	CHRCNT		; count one down
12187   8B6B   BD 00 02    		lda	LBUFF,X		; get char to delete
12188   8B6E   AA          		tax			; show in [X]
12189   8B6F   A9 08       		lda	#BACKSPACE	; and doing a backspace 
12190   8B71   D0 35       		bne	GNMSHOW		; okay, delete char on screen
12191   8B73               	GNM1:
12192   8B73   C9 2F       		cmp	#'/'		; slash is the only good non-numeric char
12193   8B75   F0 2A       		beq	GNMGOOD		; fine, use it
12194   8B77   C9 2E       		cmp	#'.'		; well, maybe a . too
12195   8B79   F0 26       		beq	GNMGOOD 	; fine, here it is
12196   8B7B   C9 3F       		cmp	#VOLCHAR	; does user want list of volumes?
12197   8B7D   D0 0A       		bne	GNM1x		; nope
12198                      	
12199   8B7F   A9 00       		lda	#0		; clear out current name
12200   8B81   85 A9       		sta	CHRCNT		; okay, we did
12201   8B83   20 5D 4B    		jsr	LISTVOLS	; show them
12202   8B86   4C 1B 8B    		jmp	GTSN0		; start over, kind of
12203   8B89               	GNM1x:
12204   8B89   C9 30       		cmp	#'0'		; is it a number
12205   8B8B   90 D5       		bcc	GNMBAD		; nope
12206   8B8D   C9 3A       		cmp	#'9'+1		; well?
12207   8B8F   90 10       		bcc	GNMGOOD		; yup
12208   8B91   C9 7B       		cmp	#'z'+1		; make sure it is alpha numeric
12209   8B93   B0 CD       		bcs	GNMBAD		; nope
12210   8B95   C9 41       		cmp	#'A'		; well?
12211   8B97   90 C9       		bcc	GNMBAD		; nope
12212   8B99   C9 61       		cmp	#'a'		; little char?
12213   8B9B   B0 04       		bcs	GNMGOOD		; yup
12214   8B9D   C9 5B       		cmp	#'Z'+1		; big char
12215   8B9F   B0 C1       		bcs	GNMBAD		; nope
12216   8BA1               	GNMGOOD:
12217   8BA1   A6 A9       		ldx	CHRCNT		; get name index
12218   8BA3   E6 A9       		inc	CHRCNT		; point to next char
12219   8BA5   9D 00 02    		sta	LBUFF,X		; save name char
12220   8BA8               	GNMSHOW:
12221   8BA8   20 82 5D    		jsr	CHAR		; show character
12222   8BAB   20 F1 71    		jsr	DISP_LINE	; make sure it is there
12223   8BAE   4C 4B 8B    		jmp	GNAME		; go get next char
12224                      	;
12225                      	; got the name, so copy it to the SAVENAME buffer
12226                      	;
12227   8BB1               	GOTNAME:
12228   8BB1   A5 A9       	        lda     CHRCNT          ; did we get any?
12229   8BB3   F0 07       	        beq     GTNMERR         ; nope
12230   8BB5   AD 00 02    	        lda     LBUFF           ; make sure first name is a directory
12231   8BB8   C9 2F       	        cmp     #'/'            ; is it?
12232   8BBA   F0 10       	        beq     GTNM1           ; yup, probly okay then
12233   8BBC               	GTNMERR:
12234   8BBC   A9 00       		lda	#0		; clear CHRCNT so name doesn't get
  Wed Jun  7 1989 12:04                                                                                                  Page  183

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12235   8BBE   85 A9       		sta	CHRCNT		; output again
12236   8BC0               	        DLINE   PREFIX_ERR      ; complain and die
12237   8BC0   A2 C3       		ldx	#<PREFIX_ERR	; get part of PREFIX_ERR
12238   8BC2   A9 8A       		lda	#>PREFIX_ERR	; get other part of string
12239          [01]        		IFMA	2		; check to see if length passed in
12240                      		ldy			; then just fetch it
12241          [01]        		ELSE
12242   8BC4   A0 31       		ldy	#PREFIX_ERRL	; get length of string
12243          [00]        		ENDIF
12244   8BC6   20 6B 4C    		jsr	DLINE		; print the string
12245   8BC9               		.MACEND
12246   8BC9   38          	        sec                     ; show bad name
12247   8BCA   B0 29       	        bcs     GNX             ; all done
12248   8BCC               	GTNM1:
12249   8BCC   A2 00       	        ldx     #0              ; now check to make sure there are 2
12250   8BCE   A0 FE       	        ldy     #$FE            ; use this as counter
12251   8BD0               	GTNMCHK:
12252   8BD0   BD 00 02    	        lda     LBUFF,X         ; get char
12253   8BD3   E8          	        inx                     ; next char
12254   8BD4   C9 2F       	        cmp     #'/'            ; prefix deliminator?
12255   8BD6   D0 03       	        bne     GTNMCHK1        ; nope
12256   8BD8   C8          	        iny                     ; count this one
12257   8BD9   F0 06       	        beq     GTNM2           ; we have 2 of them
12258   8BDB               	GTNMCHK1:
12259   8BDB   E4 A9       	        cpx     CHRCNT          ; at end?
12260   8BDD   F0 DD       	        beq     GTNMERR         ; yes, and no 2 '/'s
12261   8BDF   D0 EF       	        bne     GTNMCHK         ; go check next char
12262   8BE1               	GTNM2:
12263   8BE1   E4 A9       	        cpx     CHRCNT          ; make sure there are chars after prefix
12264   8BE3   F0 D7       	        beq     GTNMERR         ; nope, still an error
12265   8BE5   A6 A9       	        ldx	CHRCNT		; get how many characters
12266   8BE7   8E 3C 8A    		stx	SNAMEL		; save in length byte
12267   8BEA   CA          		dex			; points one too far
12268   8BEB               	GNL:
12269   8BEB   BD 00 02    		lda	LBUFF,X		; get the char
12270   8BEE   9D 3D 8A    		sta	SAVENAME,X	; save the char
12271   8BF1   CA          		dex			; point to previous one
12272   8BF2   10 F7       		bpl	GNL		; and go get it
12273   8BF4   18          		clc			; show did just fine
12274   8BF5               	GNX:
12275   8BF5   08          		php			; save status
12276   8BF6   A9 00       		lda	#0		; and clear CHRCNT
12277   8BF8   85 A9       		sta	CHRCNT		; okay
12278   8BFA   A9 0D       		lda	#EOL		; print EOL
12279   8BFC   20 82 5D    		jsr	CHAR		; okay
12280   8BFF   20 C9 4C    		jsr	SWAPBACK	; change back to old window
12281   8C02   28          		plp			; get status back
12282   8C03   60          		rts			; all done
12283                      	;
12284                      	; open up a save file, by first trying to create it.  If it already exists
12285                      	; then make sure the player wants to delete the file, then get rid of it.
12286                      	; Finally open the file.  Return with carry set if user aborts the save.
12287                      	; Store the ref number into the write parm block.
12288                      	;
12289   8C04               	OPEN_SAVE:
12290   8C04               		CREATE	CREATE_PB	; first try to create the file
12291   8C04               		PRODOS	$C0, CREATE_PB
12292   8C04   20 00 BF    		jsr	$BF00	; ProDOS handler
12293   8C07   C0          		DB	$C0	; ProDOS function code
12294   8C08   F48A        		DW	CREATE_PB	; Function Parameter Block address
12295   8C0A               		.MACEND
12296   8C0A               		.MACEND
12297   8C0A   90 16       		bcc	OPSV_OPEN	; created just fine, so open it
12298                      	;
12299                      	; can't create the file, check out why
12300                      	;
12301   8C0C   C9 47       		cmp	#$47		; this means file already there	
12302   8C0E   F0 03       		beq	OPSV1		; nope, not that
12303   8C10   4C 8A 47    		jmp	DISK_ERR	; show badness
12304   8C13               	OPSV1:
12305   8C13               		DLINE	DELQ		; ask about deleting this file
12306   8C13   A2 8C       		ldx	#<DELQ	; get part of DELQ
12307   8C15   A9 8A       		lda	#>DELQ	; get other part of string
12308          [01]        		IFMA	2		; check to see if length passed in
12309                      		ldy			; then just fetch it
  Wed Jun  7 1989 12:04                                                                                                  Page  184

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12310          [01]        		ELSE
12311   8C17   A0 23       		ldy	#DELQL	; get length of string
12312          [00]        		ENDIF
12313   8C19   20 6B 4C    		jsr	DLINE		; print the string
12314   8C1C               		.MACEND
12315   8C1C   20 A9 8C    		jsr	GETYN		; get me the yes or no
12316   8C1F   90 01       		bcc	OPSV_OPEN	; so then delete it if yes
12317   8C21   60          		rts			; nope, so just quit
12318   8C22               	OPSV_OPEN:
12319   8C22               		OPEN	OPEN_SV		; open the save file
12320   8C22               		PRODOS	$C8, OPEN_SV
12321   8C22   20 00 BF    		jsr	$BF00	; ProDOS handler
12322   8C25   C8          		DB	$C8	; ProDOS function code
12323   8C26   058B        		DW	OPEN_SV	; Function Parameter Block address
12324   8C28               		.MACEND
12325   8C28               		.MACEND
12326   8C28   90 03       		bcc	OPSV_OP1	; okey, things worked just fine
12327   8C2A   4C 8A 47    		jmp	DISK_ERR		; complain about error
12328   8C2D               	OPSV_OP1:
12329   8C2D   AD 0A 8B    		lda	OPEN_SV+OP_REFNUM	; get the ref number
12330   8C30   8D 0E 8B    		sta	WRITE_SV+WR_REFNUM	; save the ref number
12331   8C33   8D 0C 8B    		sta	CLOSE_PB+CL_REFNUM	; to close parm too
12332   8C36   8D 01 8B    	        sta     SETEOF_PB+SE_REFNUM     ; for cleansing file
12333   8C39               	        SET_EOF SETEOF_PB       ; clear out file
12334   8C39               		PRODOS	$D0, SETEOF_PB
12335   8C39   20 00 BF    		jsr	$BF00	; ProDOS handler
12336   8C3C   D0          		DB	$D0	; ProDOS function code
12337   8C3D   008B        		DW	SETEOF_PB	; Function Parameter Block address
12338   8C3F               		.MACEND
12339   8C3F               		.MACEND
12340   8C3F   90 03       	        bcc     OPSVEX          ; no problems
12341   8C41   20 8A 47    	        jsr     DISK_ERR        ; complain
12342   8C44               	OPSVEX:
12343   8C44   60          		rts			; file has been opened, return
12344                      	;
12345                      	; OPEN_RES - open the save file
12346                      	;
12347   8C45               	OPEN_RES:
12348   8C45               		OPEN	OPEN_SV		; open it up
12349   8C45               		PRODOS	$C8, OPEN_SV
12350   8C45   20 00 BF    		jsr	$BF00	; ProDOS handler
12351   8C48   C8          		DB	$C8	; ProDOS function code
12352   8C49   058B        		DW	OPEN_SV	; Function Parameter Block address
12353   8C4B               		.MACEND
12354   8C4B               		.MACEND
12355   8C4B   90 01       		bcc	OPR1		; okay, it worked
12356   8C4D   60          		rts			; okay, it didn't
12357   8C4E               	OPR1:
12358   8C4E   AD 0A 8B    		lda	OPEN_SV+OP_REFNUM ; get reference number
12359   8C51   8D CF 45    		sta	READ_PB+RD_REFNUM ; save for read
12360   8C54   8D 0C 8B    		sta	CLOSE_PB+CL_REFNUM ; and for close
12361   8C57   60          		rts
12362                      	;
12363                      	; CLOSE_SAVE - close up the save file if it is open, and
12364                      	;       restore open game files
12365                      	;
12366   8C58               	CLOSE_SAVE:
12367   8C58   AD 0C 8B    		lda	CLOSE_PB+CL_REFNUM ; check if it opened
12368   8C5B   F0 06       		beq	CLSVX		; okay, nothing
12369   8C5D               		CLOSE	CLOSE_PB	; close the save file
12370   8C5D               		PRODOS	$CC, CLOSE_PB
12371   8C5D   20 00 BF    		jsr	$BF00	; ProDOS handler
12372   8C60   CC          		DB	$CC	; ProDOS function code
12373   8C61   0B8B        		DW	CLOSE_PB	; Function Parameter Block address
12374   8C63               		.MACEND
12375   8C63               		.MACEND
12376   8C63               	CLSVX:
12377                      	;	lda	#1              ; flag is true
12378                      	;	sta	SAVEDISK	; show we have a save disk in there
12379                      	;        jsr     SET_GAMEPRE     ; go get the last one used
12380                      	;	jsr	FETCH_FILE	; this does it
12381   8C63   AE 77 46    		ldx	GAME1NML	; get length of current name
12382   8C66   BD 77 46    		lda	GAME1NM,X	; get the number of the file
12383   8C69   8D C5 49    		sta	SAVENUM 	; we need this to look for prefix
12384   8C6C   8D 54 4A    	        sta     SAVEDISK        ; show taking out save disk, not game disk        
  Wed Jun  7 1989 12:04                                                                                                  Page  185

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12385   8C6F   20 E1 4A    		jsr	DO_GAME1        ; open up GAME1 file
12386   8C72   AD D3 1D    		lda	D2SEG+HI	; set DSEGS to point to #2
12387   8C75   85 1F       		sta	DSEGS+HI
12388   8C77   AD D2 1D    		lda	D2SEG+LO
12389   8C7A   85 1E       		sta	DSEGS+LO
12390   8C7C   AE 89 46    		ldx	GAME2NML	; get length of current name
12391   8C7F   BD 89 46    		lda	GAME2NM,X	; get the number of the file
12392   8C82   8D C5 49    		sta	SAVENUM 	; we need this to look for prefix
12393   8C85   20 1F 4A    		jsr	OPEN_GAME2	; open up GAME2 file
12394   8C88   A0 00       		ldy	#0		; open up GAME2 file, just for kicks
12395   8C8A   8C 54 4A    		sty	SAVEDISK	; show we have a save disk in there
12396   8C8D   8C 0C 8B    		sty	CLOSE_PB+CL_REFNUM	; clear close
12397   8C90   C8          	        iny                     ; set for true        
12398   8C91   84 AA       		sty	SCRIPT		; allow scripting again
12399   8C93   60          		rts			; DONE
12400                      	;
12401                      	; CLOSE_GAME - close the current game file(s)
12402                      	;	and set DSEGS to point to preload so it will reopen them
12403                      	;
12404   8C94               	CLOSE_GAME:
12405   8C94   A9 00       		lda	#0			; show no files are open
12406   8C96   8D 0C 8B    		sta	CLOSE_PB+CL_REFNUM	; 0 closes all files
12407   8C99   8D 87 46    		sta	GAME1REF		; zero out two game files too
12408   8C9C   8D 99 46    		sta	GAME2REF		; and here is number 2
12409   8C9F   8D D3 73    	        sta     PF_FID                  ; clear this too
12410   8CA2               		CLOSE	CLOSE_PB		; now all are closed
12411   8CA2               		PRODOS	$CC, CLOSE_PB
12412   8CA2   20 00 BF    		jsr	$BF00	; ProDOS handler
12413   8CA5   CC          		DB	$CC	; ProDOS function code
12414   8CA6   0B8B        		DW	CLOSE_PB	; Function Parameter Block address
12415   8CA8               		.MACEND
12416   8CA8               		.MACEND
12417   8CA8   60          		rts
12418                      	;
12419                      	; Get answer to Yes/No question.  Return with C==0 for yes, and C==1
12420                      	; for a no.  RETURN == Yes, ESCAPE == NO
12421                      	;
12422   8CA9               	GETYN:
12423   8CA9   20 31 51    		jsr	GETKEY		; get the key strok
12424   8CAC   C9 79       		cmp	#'y'		; IF REPLY IS "Y"
12425   8CAE   F0 25       		beq	ALLSET		; ACCEPT RESPONSES
12426   8CB0   C9 59       		cmp	#'Y'		; get both y's
12427   8CB2   F0 21       		beq	ALLSET	
12428   8CB4   C9 0D       		cmp	#EOL		; EOL IS ALSO ACCEPTABLE
12429   8CB6   F0 1D       		beq	ALLSET	
12430   8CB8   C9 6E       		cmp	#'n'		; IF REPLY IS "N"
12431   8CBA   F0 0E       		beq	NOTSAT		; return with carry set
12432   8CBC   C9 4E       		cmp	#'N'		; check both n's
12433   8CBE   F0 0A       		beq	NOTSAT	
12434   8CC0   C9 1B       		cmp	#ESCAPE		; check for ESC key too
12435   8CC2   F0 06       		beq	NOTSAT		; which means no
12436   8CC4   20 C3 4E    		jsr	BEEP		; ELSE BEEP
12437   8CC7   4C A9 8C    		jmp	GETYN		; INSIST ON Y OR N
12438   8CCA               	NOTSAT:
12439   8CCA               		DLINE	NO		; PRINT "NO"/EOL
12440   8CCA   A2 BD       		ldx	#<NO	; get part of NO
12441   8CCC   A9 89       		lda	#>NO	; get other part of string
12442          [01]        		IFMA	2		; check to see if length passed in
12443                      		ldy			; then just fetch it
12444          [01]        		ELSE
12445   8CCE   A0 03       		ldy	#NOL	; get length of string
12446          [00]        		ENDIF
12447   8CD0   20 6B 4C    		jsr	DLINE		; print the string
12448   8CD3               		.MACEND
12449   8CD3   38          		sec			; set the carry
12450   8CD4   60          		rts			; and show it
12451   8CD5               	ALLSET:
12452   8CD5               		DLINE	YES  		; Print "YES"/EOL
12453   8CD5   A2 B9       		ldx	#<YES	; get part of YES
12454   8CD7   A9 89       		lda	#>YES	; get other part of string
12455          [01]        		IFMA	2		; check to see if length passed in
12456                      		ldy			; then just fetch it
12457          [01]        		ELSE
12458   8CD9   A0 04       		ldy	#YESL	; get length of string
12459          [00]        		ENDIF
  Wed Jun  7 1989 12:04                                                                                                  Page  186

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12460   8CDB   20 6B 4C    		jsr	DLINE		; print the string
12461   8CDE               		.MACEND
12462   8CDE   18          		clc			; clear the carry
12463   8CDF   60          		rts
12464   8CE0               	GETRET:
12465   8CE0               		DLINE	RETQ		; ask for return
12466   8CE0   A2 AE       		ldx	#<RETQ	; get part of RETQ
12467   8CE2   A9 8A       		lda	#>RETQ	; get other part of string
12468          [01]        		IFMA	2		; check to see if length passed in
12469                      		ldy			; then just fetch it
12470          [01]        		ELSE
12471   8CE4   A0 15       		ldy	#RETQL	; get length of string
12472          [00]        		ENDIF
12473   8CE6   20 6B 4C    		jsr	DLINE		; print the string
12474   8CE9               		.MACEND
12475   8CE9               	GETRETL:
12476   8CE9   20 31 51    		jsr	GETKEY		; get a key
12477   8CEC   C9 0D       		cmp	#EOL		; return key?
12478   8CEE   D0 F9       		bne	GETRETL		; nope
12479   8CF0   20 82 5D    		jsr	CHAR		; show the <CR>
12480   8CF3   60          		rts
12481   8CF4               			
12482                      	; ---------
12483                      	; SAVE GAME
12484                      	; ---------
12485   8CF4               	ZSAVE:
12486   8CF4   A9 4E       		lda	#'N'
12487   8CF6   A6 62       		ldx	NARGS
12488   8CF8   F0 02       		beq	OLDSAV		; NORMAL, COMPLETE SAVE
12489   8CFA   A9 50       		lda	#'P'
12490   8CFC               	OLDSAV:
12491   8CFC   8D 67 5B    		sta	TYPE
12492   8CFF   20 A8 89    		jsr	SAVRES		; set up screen
12493   8D02   20 15 8B    		jsr	GET_SNAME	; get the name of the save file
12494   8D05   B0 7B       		bcs	ZSEXIT		; don't wanna after all
12495   8D07   20 04 8C    		jsr	OPEN_SAVE	; open the file
12496   8D0A   B0 76       		bcs	ZSEXIT		; don't really care to
12497                      	;
12498                      	; SAVE GAME PARAMETERS IN [BUFSAV]
12499                      	;		
12500   8D0C   AD 02 96    		lda	ZBEGIN+ZID	; MOVE GAME ID
12501   8D0F   8D 20 1E    		sta	BUFSAV+0	; INTO 1ST 2 BYTES
12502   8D12   AD 03 96    		lda	ZBEGIN+ZID+1	; OF THE A
12503   8D15   8D 21 1E    		sta	BUFSAV+1	
12504   8D18   A5 AF       		lda	ZSP+LO		; MOVE [ZSP]
12505   8D1A   8D 22 1E    		sta	BUFSAV+2	
12506   8D1D   A5 B0       		lda	ZSP+HI	
12507   8D1F   8D 23 1E    		sta	BUFSAV+3	
12508   8D22   AD 7A 6C    		lda	OLDZSP+LO	
12509   8D25   8D 24 1E    		sta	BUFSAV+4	
12510   8D28   AD 7B 6C    		lda	OLDZSP+HI	; MOVE [OLDZSP]
12511   8D2B   8D 25 1E    		sta	BUFSAV+5	
12512   8D2E   A2 02       		ldx	#2		; MOVE CONTENTS OF [ZPC]
12513   8D30   B5 80       	ZSL1:	lda	ZPC,X		; TO BYTES 7-9
12514   8D32   9D 26 1E    		sta	BUFSAV+6,X	; OF [BUFSAV]
12515   8D35   CA          		dex		
12516   8D36   10 F8       		bpl	ZSL1	
12517   8D38   AD 67 5B    		lda	TYPE
12518   8D3B   8D 29 1E    		sta	BUFSAV+9	; NORMAL OR PARTIAL
12519   8D3E   C9 50       		cmp	#'P'
12520   8D40   D0 2A       		bne	ZSNONM		; NORMAL SAVE SO NO name TO SAVE
12521                      	
12522   8D42   A5 67       		lda	ARG3+LO		; set up FPC to get save name
12523   8D44   85 8C       		sta	FPCL		; lo part is okay
12524   8D46   A5 68       		lda	ARG3+HI		; get page
12525   8D48   20 7C 8F    		jsr	SETPC		; get memory addr
12526   8D4B   85 8D       		sta	FPCH		; page number
12527   8D4D   84 8E       		sty	FPCBNK		; and bank
12528   8D4F   20 5B 92    		jsr	FETCHB		; get count
12529   8D52   85 78       		sta	I		; and save it
12530   8D54   20 C3 8F    		jsr	NEXTFPC		; point to next byte
12531   8D57   A9 00       		lda	#0		; set up data offset
12532   8D59   85 7A       		sta	J		; did it
12533   8D5B               	ZSL3:
12534   8D5B   20 5B 92    		jsr	FETCHB		; get data byte
  Wed Jun  7 1989 12:04                                                                                                  Page  187

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12535   8D5E   A4 7A       		ldy	J		; get offset
12536   8D60   99 2A 1E    		sta	BUFSAV+10,Y	; save into buffer
12537   8D63   20 C3 8F    		jsr	NEXTFPC		; point to next byte
12538   8D66   E6 7A       		inc	J		; next byte
12539   8D68   C6 78       		dec	I		; count it
12540   8D6A   D0 EF       		bne	ZSL3		; loop again
12541   8D6C               	ZSNONM:
12542                      	;
12543                      	; WRITE [LOCALS]/[BUFSAV] PAGE TO DISK
12544                      	;
12545   8D6C   A9 00       		lda	#MAIN		; in the main bank
12546   8D6E   85 B8       		sta	DSKBNK		; thank you
12547   8D70   A9 1E       		lda	#>LOCALS	; start at locals
12548   8D72   85 B7       		sta	DBUFF+HI	; POINT TO THE PAGE
12549   8D74   20 F6 47    		jsr	PUTDSK		; AND WRITE IT OUT
12550   8D77   90 0F       		bcc	ZSOK		; IF SUCCEEDED, WRITE STACK
12551   8D79               	ZSBAD:
12552   8D79   20 8A 47    		jsr	DISK_ERR	; print error message
12553   8D7C               	        SET_EOF SETEOF_PB       ; clear out file, maybe
12554   8D7C               		PRODOS	$D0, SETEOF_PB
12555   8D7C   20 00 BF    		jsr	$BF00	; ProDOS handler
12556   8D7F   D0          		DB	$D0	; ProDOS function code
12557   8D80   008B        		DW	SETEOF_PB	; Function Parameter Block address
12558   8D82               		.MACEND
12559   8D82               		.MACEND
12560   8D82               	ZSEXIT:
12561   8D82   20 58 8C    		jsr	CLOSE_SAVE	  ; else get game file back
12562   8D85   4C DA 43    		jmp	RET0		; AND FAIL
12563                      	;
12564                      	; IF A PARTIAL SAVE WRITE FROM ARG1 FOR ARG2 BYTES TO DISK
12565                      	; (ROUNDED TO PGS) SKIPPING ZSTACK WRITE
12566                      	;
12567   8D88               	ZSOK:
12568   8D88   AD 67 5B    		lda	TYPE
12569   8D8B   C9 50       		cmp	#'P'
12570   8D8D   D0 1F       		bne	ZSALL
12571   8D8F   A5 64       		lda	ARG1+HI		; find where to start & how far to go
12572   8D91   20 7C 8F    		jsr	SETPC		; get page in memory
12573   8D94   48          	        pha                     ; save for minute
12574   8D95   29 01       	        and     #$01            ; check for odd page
12575   8D97   F0 02       	        beq     ZSP1            ; nope, don't make one more page
12576   8D99   E6 66       	        inc     ARG2+HI         ; go get one more page
12577   8D9B               	ZSP1:
12578   8D9B   68          	        pla                     ; get it back
12579   8D9C   29 FE       	        and     #$FE            ; must be on block boundary
12580   8D9E   85 B7       		sta	DBUFF+HI	; this is page
12581   8DA0   84 B8       		sty	DSKBNK		; which bank
12582   8DA2   A6 66       		ldx	ARG2+HI		; get MSB of count
12583   8DA4   A5 63       		lda	ARG1+LO		; get lo offset
12584   8DA6   18          		clc			; add
12585   8DA7   65 65       		adc	ARG2+LO		; lo count
12586   8DA9   90 01       		bcc	ZSPINC		; no extra page
12587   8DAB   E8          		inx			; wrapped extra page
12588   8DAC               	ZSPINC:
12589   8DAC   D0 15       	        bne     SAVE2DISK       ; go copy it now
12590                      	;
12591                      	; WRITE CONTENTS OF Z-STACK TO DISK
12592                      	;
12593   8DAE               	ZSALL:
12594   8DAE   A9 0D       		lda	#>ZSTKBL	; point to 1st page
12595   8DB0   85 B7       		sta	DBUFF+HI        
12596   8DB2   20 F6 47    		jsr	PUTDSK		; write them, first one
12597   8DB5   B0 C2       		bcs	ZSBAD
12598   8DB7   20 F6 47    		jsr	PUTDSK		; write them, second one
12599   8DBA   B0 BD       		bcs	ZSBAD
12600                      	;
12601                      	; WRITE ENTIRE GAME PRELOAD TO DISK
12602                      	;
12603   8DBC   A9 96       		lda	#>ZBEGIN	; POINT TO 1ST PAGE
12604   8DBE   85 B7       		sta	DBUFF+HI	; OF PRELOAD
12605   8DC0   AE 0E 96    		ldx	ZBEGIN+ZPURBT	; GET # IMPURE PAGES
12606   8DC3               	SAVE2DISK:
12607   8DC3   E8          		inx			; use for counting
12608   8DC4   86 78       		stx	I+LO
12609   8DC6   46 78       	        lsr     I+LO            ; /2 for 512byte pages
  Wed Jun  7 1989 12:04                                                                                                  Page  188

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12610   8DC8   90 02       	        bcc     ZSL2            ; no wrapping
12611   8DCA   E6 78       	        inc     I+LO            ; wrapped once
12612   8DCC               	ZSL2:
12613   8DCC   20 F6 47    		jsr	PUTDSK          ; this does the write
12614   8DCF   B0 A8       		bcs	ZSBAD
12615   8DD1   C6 78       		dec	I+LO            ; count one page
12616   8DD3   D0 F7       		bne	ZSL2            ; not done yet
12617                      	
12618   8DD5   20 58 8C    		jsr	CLOSE_SAVE	; prompt for game file
12619                      	
12620          [01]        		IF	CHECKSUM == 1
12621                      		lda	CKS_COUNT
12622                      		jsr	HEXNUM
12623                      		lda	CKSB
12624                      		jsr	HEXNUM
12625                      		lda	#EOL
12626                      		jsr	CHAR
12627          [00]        		ENDIF
12628                      	
12629   8DD8   A9 01       		lda	#1		; set to mark
12630   8DDA   A2 00       		ldx	#0
12631   8DDC   4C DD 43    		jmp	PUTBYT		; SUCCESS
12632                      	
12633                      	; ------------
12634                      	; RESTORE GAME
12635                      	; ------------
12636                      	
12637   8DDF               	ZREST:
12638   8DDF   A9 4E       		lda	#'N'
12639   8DE1   A6 62       		ldx	NARGS
12640   8DE3   F0 02       		beq	OLDRES		; NORMAL, COMPLETE RESTORE
12641   8DE5   A9 50       		lda	#'P'		; partial restore
12642   8DE7               	OLDRES:
12643   8DE7   8D 67 5B    		sta	TYPE		; save which kind of restore
12644                      	;	
12645                      	; SAVE LOCALS IN CASE OF ERROR
12646                      	;
12647   8DEA   A2 1F       		ldx	#31
12648   8DEC   BD 00 1E    	LOCSAV:	lda	LOCALS,X	; COPY ALL LOCALS
12649   8DEF   9D E0 1D    		sta	LOCAL_SV,X	; to a save spot
12650   8DF2   CA          		dex
12651   8DF3   10 F7       		bpl	LOCSAV
12652                      	
12653   8DF5   20 15 8B    		jsr	GET_SNAME	; get the name of the file
12654   8DF8   B0 3C       		bcs	ZRQUIT		; okay, don't do it
12655   8DFA   20 45 8C    		jsr	OPEN_RES	; open the restore file
12656   8DFD   B0 34       		bcs	ZRBAD		; can't do it
12657                      	
12658   8DFF   AD 67 5B    		lda	TYPE		; PARTIAL SAVE DIFFERS STARTING HERE
12659   8E02   C9 50       		cmp	#'P'
12660   8E04   D0 03       		bne	ZRNRML
12661   8E06   4C C7 8E    		jmp	ZPARTR		; just a partial restore
12662   8E09               	ZRNRML:
12663   8E09   A9 00       		lda	#MAIN
12664   8E0B   85 B8       		sta	DSKBNK		; SET TO WRITE TO MAIN BANK
12665   8E0D   A9 1E       		lda	#>LOCALS
12666   8E0F   85 B7       		sta	DBUFF+HI
12667   8E11   A9 02       		lda	#2              ; must read in two pages
12668   8E13   85 7E       		sta	L+LO
12669   8E15   20 11 48    		jsr	GETRES		; RETRIEVE 1ST BLOCK OF PRELOAD
12670   8E18   B0 19       		bcs	ZRBAD           ; didn't work!
12671   8E1A   AD D5 45    	        lda     READ_PB+RD_LENGTH+HI ; see how much was read in
12672   8E1D   C9 02       	        cmp     #2              ; were 2 blocks read in?
12673   8E1F   D0 15       	        bne     ZRQUIT          ; wrong kind of file for complete save
12674                      	
12675   8E21   AD 20 1E    		lda	BUFSAV+0	; DOES 1ST BYTE OF SAVED GAME ID
12676   8E24   CD 02 96    		cmp	ZBEGIN+ZID	; MATCH THE CURRENT ID?
12677   8E27   D0 0D       		bne	ZRQUIT		; WRONG DISK IF NOT
12678                      	
12679   8E29   AD 21 1E    		lda	BUFSAV+1	; WHAT ABOUT THE 2ND BYTE?
12680   8E2C   CD 03 96    		cmp	ZBEGIN+ZID+1
12681   8E2F   F0 16       		beq	ZROK		; CONTINUE IF BOTH BYTES MATCH
12682   8E31   D0 03       	 	bne	ZRQUIT		; skip disk error message
12683                      	;
12684                      	; HANDLE RESTORE ERROR
  Wed Jun  7 1989 12:04                                                                                                  Page  189

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12685                      	;
12686   8E33               	ZRBAD:
12687   8E33   20 8A 47    		jsr	DISK_ERR	; print error message
12688   8E36               	ZRQUIT:
12689   8E36   A2 1F       		ldx	#31		; RESTORE ALL SAVED LOCALS
12690   8E38   BD E0 1D    	ZRL2:	lda	LOCAL_SV,X
12691   8E3B   9D 00 1E    		sta	LOCALS,X
12692   8E3E   CA          		dex
12693   8E3F   10 F7       		bpl	ZRL2
12694   8E41               	BADRES:
12695   8E41   20 58 8C    		jsr	CLOSE_SAVE	  ; PROMPT FOR GAME DISK
12696   8E44   4C DA 43    		jmp	RET0		; PREDICATE FAILS
12697                      	;
12698                      	; CONTINUE RESTORE
12699                      	;
12700   8E47               	ZROK:
12701   8E47   AD 10 96    		lda	ZBEGIN+ZFLAGS	; save both flag bytes
12702   8E4A   85 7A       		sta	J+LO
12703   8E4C   AD 11 96    		lda	ZBEGIN+ZFLAGS+1
12704   8E4F   85 7B       		sta	J+HI
12705                      	
12706   8E51   A9 0D       		lda	#>ZSTKBL	; retrieve old contents of
12707   8E53   85 B7       		sta	DBUFF+HI	; z-stack
12708   8E55   A9 04       		lda	#4		; do 4 pages
12709   8E57   85 7E       		sta	L+LO		; tell GETRES how many pages
12710   8E59   20 11 48    		jsr	GETRES		; get 4 pages of z-stack
12711   8E5C   90 03       		bcc	ZROKL1
12712   8E5E   4C 74 47    		jmp	DISK_FATAL	; if here, mix of good & bad so die
12713   8E61               	ZROKL1:
12714   8E61   A9 96       		lda	#>ZBEGIN	; get where we are
12715   8E63   85 B7       		sta	DBUFF+HI
12716   8E65   AD 0E 96    		lda	ZBEGIN+ZPURBT	; get # pages to load
12717   8E68   85 78       		sta	I+LO
12718   8E6A   E6 78       	        inc     I+LO            ; go get last page if possible
12719   8E6C               	LREST0:
12720   8E6C   A5 78       		lda	I+LO		; how many pages left
12721   8E6E   F0 20       	        beq     LRESTj          ; finis
12722   8E70   38          		sec			; doing subtract
12723   8E71   E9 04       		sbc	#4		; doing it 4 blocks at a time
12724   8E73   90 0E       		bcc	LREST1		; <4 blocks left so deal with it special
12725   8E75   85 78       		sta	I+LO		; save remenants
12726   8E77               	LREST:
12727   8E77   A9 04       		lda	#4		; assume at least 4 pages
12728   8E79   85 7E       		sta	L+LO		; this tells GETRES how many to read in
12729   8E7B   20 11 48    		jsr	GETRES		; fetch the remainder
12730   8E7E   90 EC       		bcc	LREST0
12731   8E80   4C 74 47    		jmp	DISK_FATAL
12732   8E83               	LREST1:
12733   8E83   A5 78       		lda	I+LO		; get how many left
12734   8E85   85 7E       		sta	L+LO		; and show it to GETRES
12735   8E87   29 01       	        and     #$1             ; is it odd?
12736   8E89   F0 02       	        beq     LREST2          ; nope
12737   8E8B   E6 7E       	        inc     L+LO            ; read one more
12738   8E8D               	LREST2:
12739   8E8D   20 11 48    		jsr	GETRES		; and finish it up
12740                      	;
12741                      	; RESTORE THE STATE OF THE SAVED GAME
12742                      	;
12743   8E90               	LRESTj:
12744   8E90   A5 7A       		lda	J+LO		; RESTORE THE STATE
12745   8E92   8D 10 96    		sta	ZBEGIN+ZFLAGS	; OF THE FLAG WORD
12746   8E95   A5 7B       		lda	J+HI
12747   8E97   8D 11 96    		sta	ZBEGIN+ZFLAGS+1
12748                      	
12749   8E9A   AD 22 1E    		lda	BUFSAV+2	; RESTORE THE [ZSP]
12750   8E9D   85 AF       		sta	ZSP+LO
12751   8E9F   AD 23 1E    		lda	BUFSAV+3
12752   8EA2   85 B0       		sta	ZSP+HI
12753   8EA4   AD 24 1E    		lda	BUFSAV+4
12754   8EA7   8D 7A 6C    		sta	OLDZSP+LO
12755   8EAA   AD 25 1E    		lda	BUFSAV+5	; AND THE [OLDZSP]
12756   8EAD   8D 7B 6C    		sta	OLDZSP+HI
12757                      	
12758   8EB0   A2 02       		ldx	#2		; RESTORE THE [ZPC]
12759   8EB2   BD 26 1E    	ZRL4:	lda	BUFSAV+6,X
  Wed Jun  7 1989 12:04                                                                                                  Page  190

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12760   8EB5   95 80       		sta	ZPC,X
12761   8EB7   CA          		dex
12762   8EB8   10 F8       		bpl	ZRL4
12763                      	
12764   8EBA   20 58 8C    	ZROUT:	jsr	CLOSE_SAVE	  ; PROMPT FOR GAME DISK
12765   8EBD   20 AF 90    		jsr	VLDZPC		; MAKE VALID (MUST DO AFTER GET DISK)
12766                      	
12767          [01]        		IF	CHECKSUM == 1
12768                      		lda	CKS_COUNT
12769                      		jsr	HEXNUM
12770                      		lda	CKSB
12771                      		jsr	HEXNUM
12772                      		lda	#EOL
12773                      		jsr	CHAR
12774          [00]        		ENDIF
12775                      	
12776   8EC0   A9 02       		lda	#2		; SET TO
12777   8EC2   A2 00       		ldx	#0
12778   8EC4   4C DD 43    		jmp	PUTBYT		; SUCCESS
12779                      	
12780                      	
12781                      		; DO PARTIAL RESTORE GETTING 1ST PAGE 
12782                      		; AND LAST PAGE BYTE ALIGNMENT CORRECT
12783                      	        ; WRITE LOCALS TO IOBUFF JUST TO LOOK AT NAME
12784   8EC7               	ZPARTR:	
12785   8EC7   A9 00       		lda	#MAIN
12786   8EC9   85 B8       		sta	DSKBNK
12787   8ECB   A9 08       		lda	#>IOBUFF	; DON'T READ TO LOCALS YET (X)
12788   8ECD   85 B7       		sta	DBUFF+HI
12789   8ECF   A9 02       		lda	#2		; just one block please
12790   8ED1   85 7E       		sta	L+LO
12791   8ED3   20 11 48    		jsr	GETRES		; RETRIEVE 1ST BLOCK OF PRELOAD
12792   8ED6   90 03       		bcc     ZRN2            ; worked just fine
12793   8ED8               	ZPBAD:
12794   8ED8   4C 41 8E    	        jmp	BADRES		; names don't match, die
12795   8EDB               	ZRN2:
12796   8EDB   A5 67       		lda	ARG3+LO		; set up FPC to get save name
12797   8EDD   85 8C       		sta	FPCL		; lo part is okay
12798   8EDF   A5 68       		lda	ARG3+HI		; get page
12799   8EE1   20 7C 8F    		jsr	SETPC		; get memory addr
12800   8EE4   85 8D       		sta	FPCH		; page number
12801   8EE6   84 8E       		sty	FPCBNK		; and bank
12802   8EE8   20 5B 92    		jsr	FETCHB		; get count
12803   8EEB   85 78       		sta	I		; and save it
12804   8EED   20 C3 8F    		jsr	NEXTFPC		; point to next byte
12805   8EF0   A9 20       		lda	#<BUFSAV	; get bufsav offset
12806   8EF2   18          		clc			; and add
12807   8EF3   69 0A       		adc	#10		; name offset
12808   8EF5   85 7A       		sta	J		; did it
12809   8EF7               	ZRN3:
12810   8EF7   20 5B 92    		jsr	FETCHB		; get data byte
12811   8EFA   A4 7A       		ldy	J		; get offset
12812   8EFC   D9 00 08    		cmp	IOBUFF,Y	; save into buffer
12813   8EFF   D0 D7       		bne	ZPBAD		; okay, then it's not it
12814   8F01   20 C3 8F    		jsr	NEXTFPC		; point to next byte
12815   8F04   E6 7A       		inc	J		; next byte
12816   8F06   C6 78       		dec	I		; count it
12817   8F08   D0 ED       		bne	ZRN3		; loop again
12818                      	
12819   8F0A   A5 64       		lda	ARG1+HI		; FIND WHERE TO START & HOW FAR TO GO
12820   8F0C   20 7C 8F    		jsr	SETPC		; get page in memory
12821   8F0F   85 90       		sta	SPCH		; this is page
12822   8F11   84 91       		sty	SPCBNK		; which bank
12823   8F13   A5 63       		lda	ARG1+LO		; START BYTE FIRST PAGE
12824   8F15   85 8F       		sta	SPCL
12825                      	
12826   8F17   A6 66       		ldx	ARG2+HI
12827   8F19   86 7B       		stx	J+HI
12828   8F1B   A6 65       		ldx	ARG2+LO
12829   8F1D   86 7A       		stx	J+LO            ; how many to get
12830                      	
12831   8F1F   20 C6 44    		jsr	DECJ		; correct alignment for this usage
12832   8F22               	POK:
12833   8F22   A9 08       		lda	#>IOBUFF	; get 1st page
12834   8F24   85 B7       		sta	DBUFF+HI	; getres should keep in iobuff
  Wed Jun  7 1989 12:04                                                                                                  Page  191

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12835   8F26   8D 42 8F    	        sta     ZPARTMOD+2      ; and show where to get it from
12836   8F29   A9 01       	        lda     #$01            ; is it odd
12837   8F2B   24 90       	        bit     SPCH            ; get page destination
12838   8F2D   F0 03       	        beq     ZPARTx          ; nope
12839   8F2F   EE 42 8F    	        inc     ZPARTMOD+2      ; then get second page worth
12840   8F32               	ZPARTx:
12841   8F32   A9 02       		lda	#2		; just do one block
12842   8F34   85 7E       		sta	L+LO
12843   8F36   20 11 48    		jsr	GETRES
12844   8F39   90 03       		bcc	ZPART0
12845   8F3B   4C 74 47    		jmp	DISK_FATAL	; ALL MESSED UP, JUST QUIT
12846   8F3E               	ZPART0:
12847   8F3E   A4 63       		ldy	ARG1+LO		; START BYTE FIRST PAGE
12848   8F40               	ZPARTMOD:
12849   8F40   B9 00 08    		lda	IOBUFF,Y        ; this gets modified with good page #
12850   8F43   20 3A 92    		jsr	STASHB
12851   8F46   20 A3 8F    		jsr	NEXTSPC
12852   8F49   20 C6 44    		jsr	DECJ
12853   8F4C   B0 03       		bcs	ZPART1		; CARRY CLEAR IF $FFFF RESULT
12854   8F4E   4C BA 8E    		jmp	ZROUT
12855   8F51               	ZPART1:
12856   8F51   E6 63       		inc	ARG1+LO
12857   8F53   D0 E9       		bne	ZPART0
12858   8F55   A9 09       	        lda     #>IOBUFF+1      ; this is second page address
12859   8F57   CD 42 8F    	        cmp     ZPARTMOD+2      ; is it second one already?
12860   8F5A   F0 C6       		beq	POK		; yes, so read in a new block
12861   8F5C   8D 42 8F    	        sta     ZPARTMOD+2      ; then update it 
12862   8F5F   D0 DD       	        bne     ZPART0          ; and do it again
12863                      	;
12864                      	; THE OLD SAVE & RESTORE STILL HAVE OPCODES
12865                      	; SO JUST PUT IN A PLACE FOR THEM HERE FOR NOW
12866                      	;
12867   8F61               	OSAVE:
12868   8F61   60          	OREST:	RTS
12869                      	
12870   8F62               	ZISAVE:
12871   8F62   4C DA 43    	ZIREST:	JMP	RET0	; NOT IMPLEMENTED ON APPLE
12872   8F65               		END
12873                      	
12874                      	
12875   8F65               		TITLE 	"APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
12876   8F65               		INCLUDE 	XPAGING.ASM
12877   8F65               		STTL "--- MEMORY PAGING ROUTINES ---"
12878                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page  192

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

12879                      	
12880                      	; -------------------------
12881                      	; POINT [MPC] TO V-ADDR [I]
12882                      	; -------------------------
12883                      	
12884   8F65   A5 78       	SETWRD:	LDA	I+LO	
12885   8F67   85 86       		STA	MPCL	
12886   8F69   A5 79       		LDA	I+HI	
12887   8F6B   85 87       		STA	MPCM	
12888   8F6D   A9 00       		LDA	#0	
12889   8F6F   85 88       		STA	MPCH	; ZERO TOP BIT
12890   8F71   4C 85 90    		JMP	VLDMPC	
12891                      	
12892                      	;
12893   8F74   00 00       	WANTED:	DB	00,00	
12894                      	;
12895   8F76   00          	NEXT:	DB	00	
12896   8F77   00          	NSUBA:	DB	00	
12897   8F78   00          	PSUBA:	DB	00	
12898                      	;
12899   8F79   00          	YTEMP:	DB	00	
12900   8F7A   00          	ATEMP:	DB	00	
12901   8F7B   00          	NSUBY:	DB	00	
12902                      	;
12903                      	; set [A](page), [Y](bank) to point to memory page where page in [A] is
12904                      	;
12905   8F7C               	SETPC:			
12906   8F7C   85 BC       		sta	MEMPAGE		; save it for later addition
12907   8F7E   C9 29       		cmp	#P2PAGE 	; IS IT A PAGE IN MAIN
12908   8F80   B0 06       		bcs	VF2		; No, it might be in aux mem
12909                      	
12910   8F82   A9 96       		lda	#>ZBEGIN 	; ADD OFFSET TO GET RAM PAGE
12911   8F84   A0 00       		ldy	#MAIN		; in the main bank
12912   8F86   F0 12       		beq	VFEXI		; BRA to fetch
12913   8F88               	VF2:
12914   8F88   C9 D6       		cmp	#PGBEGIN	; is it paged?
12915   8F8A   B0 12       		bcs	VFERR		; yes it be paged, so can't deal with it
12916   8F8C   C9 A8       		cmp	#P3PAGE		; is it in Aux Mem, Part 2?
12917   8F8E   B0 06       		bcs	VF3		; yes, so subtract different amount
12918                      	;
12919                      	; this is in lower aux 
12920                      	;				
12921   8F90   A9 17       		lda	#(Z2PAGE-Z1SIZE) ; subtract size from offset
12922   8F92   A0 01       		ldy	#AUX		; show aux mem
12923   8F94   D0 04       		bne	VFEXI		; jump to end
12924   8F96               	VF3:
12925   8F96   A9 28       		lda	#(Z3PAGE-(Z1SIZE+Z2SIZE)) ; subtract out first 2 sides
12926   8F98   A0 FF       		ldy	#P3BANK		; show page 3 bank
12927   8F9A               	VFEXI:
12928   8F9A   18          		clc			; get ready for addition
12929   8F9B   65 BC       		adc	MEMPAGE		; now get actual offset
12930   8F9D   60          		rts	
12931   8F9E               	VFERR:
12932                      	;
12933                      	; out of range
12934                      	;
12935   8F9E   A9 12       		lda	#18
12936   8FA0   4C 0A 52    		jmp	ZERROR
12937                      	;
12938                      	; NEXTSPC - inc SPCL and check for wrapping round to next bank
12939                      	;
12940   8FA3               	NEXTSPC:
12941   8FA3   E6 8F       		inc	SPCL		; next lo byte
12942   8FA5   D0 1B       		bne	NXSP_EXIT	; no change then
12943   8FA7   E6 90       		inc	SPCH		; next page
12944   8FA9   A5 90       		lda	SPCH		; so get page
12945   8FAB   C9 BF       		cmp	#>PRGLBL	; have we reached end of line?
12946   8FAD   D0 13       		bne	NXSP_EXIT	; we be okay
12947   8FAF   A5 91       		lda	SPCBNK		; get bank
12948   8FB1   D0 07       		bne	NXSP1		; must go to Part 3
12949   8FB3   E6 91       		inc	SPCBNK		; so point to aux bank
12950   8FB5   A9 40       		lda	#Z2PAGE		; first page in aux
12951   8FB7   85 90       		sta	SPCH		; and point to it
12952   8FB9   60          		rts			; and all done
12953   8FBA               	NXSP1:
  Wed Jun  7 1989 12:04                                                                                                  Page  193

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

12954   8FBA   A9 D0       		lda	#Z3PAGE		; get start of page 3
12955   8FBC   85 90       		sta	SPCH		; and point there
12956   8FBE   A9 FF       		lda	#P3BANK		; and point to this bank
12957   8FC0   85 91       		sta	SPCBNK		; okey
12958   8FC2               	NXSP_EXIT:
12959   8FC2   60          		rts
12960                      	;
12961                      	; NEXTFPC - inc DPCL and check for wrapping round to next bank
12962                      	;
12963   8FC3               	NEXTFPC:
12964   8FC3   E6 8C       		inc	FPCL		; next lo byte
12965   8FC5   D0 1B       		bne	NXFP_EXIT	; no change then
12966   8FC7   E6 8D       		inc	FPCH		; next page
12967   8FC9   A5 8D       		lda	FPCH		; and get it for checking
12968   8FCB   C9 BF       		cmp	#>PRGLBL	; have we reached end of line?
12969   8FCD   D0 13       		bne	NXFP_EXIT	; we be okay
12970   8FCF   A5 8E       		lda	FPCBNK		; get bank
12971   8FD1   D0 07       		bne	NXFP1		; must skip over stuff in middle
12972   8FD3   E6 8E       		inc	FPCBNK		; so point to aux bank
12973   8FD5   A9 40       		lda	#Z2PAGE		; first page in aux
12974   8FD7   85 8D       		sta	FPCH		; and point to it
12975   8FD9   60          		rts			; toots finis
12976   8FDA               	NXFP1:
12977   8FDA   A9 D0       		lda	#Z3PAGE		; start of part 3
12978   8FDC   85 8D       		sta	FPCH		; so show me
12979   8FDE   A9 FF       		lda	#P3BANK		; and point to this bank
12980   8FE0   85 8E       		sta	FPCBNK		; okey
12981   8FE2               	NXFP_EXIT:
12982   8FE2   60          		rts
12983                      	;
12984                      	; ADDFPC - add amount in [A] to current FPC and check for bank wrap
12985                      	;
12986   8FE3               	ADDFPC:
12987   8FE3   18          		clc			; get ready for add
12988   8FE4   65 8C       		adc	FPCL		; add lo part
12989   8FE6   85 8C       		sta	FPCL		; and save it
12990   8FE8   90 1B       		bcc	AFPX		; all done if no page wrap
12991   8FEA   E6 8D       		inc	FPCH		; point to next page
12992   8FEC   A5 8D       		lda	FPCH		; get it for compare
12993   8FEE   C9 BF       		cmp	#>PRGLBL	; at end of line in main bank?
12994   8FF0   D0 13       		bne	AFPX		; nope, all done then
12995   8FF2   A5 8E       		lda	FPCBNK		; get bank
12996   8FF4   F0 09       		beq	AFP1		; it is main, so we be ok
12997   8FF6   A9 D0       		lda	#Z3PAGE		; must go to part 3 if in aux mem
12998   8FF8   85 8D       		sta	FPCH		; thanx
12999   8FFA   A9 FF       		lda	#P3BANK		; and point to this bank
13000   8FFC   85 8E       		sta	FPCBNK		; okey
13001   8FFE   60          		rts			; done
13002   8FFF               	AFP1:
13003   8FFF   E6 8E       		inc	FPCBNK		; point to aux
13004   9001   A9 40       		lda	#Z2PAGE		; get start in aux
13005   9003   85 8D       		sta	FPCH		; and save it
13006   9005               	AFPX:
13007   9005   60          		rts
13008                      	;
13009                      	; ADDSPC - add amount in [A] to current SPC and check for bank wrap
13010                      	;
13011   9006               	ADDSPC:
13012   9006   18          		clc			; get ready for add
13013   9007   65 8F       		adc	SPCL		; add lo part
13014   9009   85 8F       		sta	SPCL		; and save it
13015   900B   90 1B       		bcc	ASPX		; all done if no page wrap
13016   900D   E6 90       		inc	SPCH		; point to next page
13017   900F   A5 90       		lda	SPCH		; get it for compare
13018   9011   C9 BF       		cmp	#>PRGLBL	; at end of line in main bank?
13019   9013   D0 13       		bne	ASPX		; nope, all done then
13020   9015   A5 91       		lda	SPCBNK		; get bank
13021   9017   F0 09       		beq	ASP1		; it is main, so we be ok
13022   9019   A9 D0       		lda	#Z3PAGE		; must go to part 3 if in aux mem
13023   901B   85 90       		sta	SPCH		; thanx
13024   901D   A9 FF       		lda	#P3BANK		; and point to this bank
13025   901F   85 91       		sta	SPCBNK		; okey
13026   9021   60          		rts			; done
13027   9022               	ASP1:
13028   9022   E6 91       		inc	SPCBNK		; point to aux
  Wed Jun  7 1989 12:04                                                                                                  Page  194

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13029   9024   A9 40       		lda	#Z2PAGE		; get start in aux
13030   9026   85 90       		sta	SPCH		; and save it
13031   9028               	ASPX:
13032   9028   60          		rts
13033                      	;
13034                      	; PREVFPC - DEC FPCL and check for wrapping round to next bank
13035                      	;
13036   9029               	PREVFPC:
13037   9029   A5 8C       		lda	FPCL		; get lo part
13038   902B   D0 1E       		bne	PFPC2		; it's not zero, so no wrapping
13039   902D   A5 8D       		lda	FPCH		; get current page
13040   902F   C9 40       		cmp	#Z2PAGE		; have we reached beginning of page 2?
13041   9031   F0 08       		beq	PFPC1		; wrap to first bank
13042   9033   C9 D0       		cmp	#Z3PAGE		; beginning of part 3?
13043   9035   F0 0C       		beq	PFPC3		; ayyup
13044   9037   C6 8D       		dec	FPCH		; point to previous page
13045   9039   D0 10       		bne	PFPC2		; okay
13046   903B               	PFPC1:
13047   903B   A5 8E       		lda	FPCBNK		; get bank
13048   903D   F0 0F       		beq	VF1ERR		; oops, can't go backwards from main bank
13049   903F   A9 00       		lda	#MAIN		; so point to main bank
13050   9041   F0 02       		beq	PFPC4		; and store it away
13051   9043               	PFPC3:
13052   9043   A9 01       		lda	#AUX		; and point to this bank
13053   9045               	PFPC4:
13054   9045   85 8E       		sta	FPCBNK		; okey
13055   9047   A9 BE       		lda	#(>PRGLBL)-1	; get me last page in part 2
13056   9049   85 8D       		sta	FPCH		; and show me
13057   904B               	PFPC2:
13058   904B   C6 8C       		dec	FPCL		; and point to previous byte
13059   904D   60          		rts
13060   904E               	VF1ERR:
13061                      	;
13062                      	; out of range
13063                      	;
13064   904E   A9 13       		lda	#19
13065   9050   4C 0A 52    		jmp	ZERROR
13066                      	;
13067                      	; PREVSPC - DEC SPCL and check for wrapping round to main bank
13068                      	;
13069   9053               	PREVSPC:
13070   9053   A5 8F       		lda	SPCL		; get lo part
13071   9055   D0 1E       		bne	PSPC2		; it's not zero, so no wrapping
13072   9057   A5 90       		lda	SPCH		; get current page
13073   9059   C9 40       		cmp	#Z2PAGE		; have we reached beginning of page 2?
13074   905B   F0 08       		beq	PSPC1		; wrap to first bank
13075   905D   C9 D0       		cmp	#Z3PAGE		; down past page 3?
13076   905F   F0 0C       		beq	PSPC3		; sure is
13077   9061   C6 90       		dec	SPCH		; point to previous page
13078   9063   D0 10       		bne	PSPC2		; okay
13079   9065               	PSPC1:
13080   9065   A5 91       		lda	SPCBNK		; get bank
13081   9067   F0 E5       		beq	VF1ERR		; oops, can't go backwards from main bank
13082   9069   A9 00       		lda	#MAIN		; so point to main bank
13083   906B   F0 02       		beq	PSPC4		; so save it
13084   906D               	PSPC3:
13085   906D   A9 01       		lda	#AUX		; and point to this bank
13086   906F               	PSPC4:
13087   906F   85 8E       		sta	FPCBNK		; okey
13088   9071   A9 BE       		lda	#>PRGLBL-1	; get me last page in low part
13089   9073   85 90       		sta	SPCH		; and show me
13090   9075               	PSPC2:
13091   9075   C6 8F       		dec	SPCL		; and point to previous byte
13092   9077   60          		rts
13093                      	;
13094                      	; FP2SP - copy the 3 parts of FPC to SPC
13095                      	;
13096   9078               	FP2SP:
13097   9078   A5 8E       		lda	FPCBNK
13098   907A   85 91       		sta	SPCBNK
13099   907C   A5 8D       		lda	FPCH
13100   907E   85 90       		sta	SPCH
13101   9080   A5 8C       		lda	FPCL
13102   9082   85 8F       		sta	SPCL
13103   9084   60          		rts
  Wed Jun  7 1989 12:04                                                                                                  Page  195

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13104   9085               		
13105                      	; MAKE [MPCPNT],[MPCBNK] POINT TO
13106                      	; THE RAM PAGE AND BANK THAT HOLDS
13107                      	; THE V-PAGE MPCH,M
13108                      	;
13109   9085               	VLDMPC:			
13110   9085   A5 88       		lda	MPCH		; check hi part
13111   9087   D0 0F       		bne	VLD3		; NOT IN FIRST V-64K, so must be paged
13112   9089   A5 87       		lda	MPCM		; check to see if it is paged
13113   908B   20 A7 91    		jsr	CHECKPRE	; is it preloaded?
13114   908E   B0 08       		bcs	VLD3		; no, so it be paged
13115   9090   20 7C 8F    		jsr	SETPC		; so put page/bank into A/Y
13116   9093   84 8B       		sty	MPCBNK	
13117   9095   85 8A       		sta	MPCPNT+HI	
13118   9097               	NOMUCK:
13119   9097   60          		rts	
13120                      	;
13121                      	; must be paged, so check for it or read it in
13122                      	;
13123   9098               	VLD3:	
13124   9098   A5 88       		lda	MPCH	
13125   909A   A4 87       		ldy	MPCM	
13126   909C   20 E5 90    		jsr	PAGE	;RETURN BUFFER IN A THAT HAS VPAGE A,Y
13127   909F   18          		clc		
13128   90A0   69 08       		adc	#>PBEGIN	
13129   90A2   85 8A       		sta	MPCPNT+HI	
13130   90A4   A0 01       		ldy	#PB_BANK	; paging buffers are in aux mem
13131   90A6   84 8B       		sty	MPCBNK	
13132                      	;
13133                      	; TEST FOR MUCK
13134                      	;
13135   90A8   AD E4 90    		lda	MUCKFLG	
13136   90AB   F0 EA       		beq	NOMUCK	
13137   90AD   D0 00       		bne	VLDZPC	;MAY HAVE MUCKED ZPC SO GO FIX
13138                      	;
13139                      	; SAME IDEA AS VLDMPC
13140                      	;
13141   90AF               	VLDZPC:
13142   90AF   A5 59       	        lda     INFODOS         ; check first for InfoDOS page
13143   90B1   F0 06       	        beq     VLDZ1           ; none
13144   90B3   20 BC 91    	        jsr     INFO_PAGE       ; well, is it?
13145   90B6   90 01       	        bcc     VLDZ1           ; nope
13146   90B8   60          	        rts                     ; all set otherwise
13147   90B9               	VLDZ1:
13148   90B9   A5 82       		lda	ZPCH	
13149   90BB   D0 0F       		bne	VLDZ3		;NOT IN FIRST V-64K, so must be paged
13150   90BD   A5 81       		lda	ZPCM		; check to see if it is paged
13151   90BF   20 A7 91    		jsr	CHECKPRE	; is it preloaded?
13152   90C2   B0 08       		bcs	VLDZ3		; no, so it must be paged
13153   90C4   20 7C 8F    		jsr	SETPC		; point to correct bank and page
13154   90C7   84 85       		sty	ZPCBNK		; set bank
13155   90C9   85 84       		sta	ZPCPNT+HI	; and MSB of pointer
13156   90CB               	NOZMUCK:
13157   90CB   60          		rts		
13158                      	VLDZ3:				;MUST BE PAGED
13159   90CC   A5 82       		lda	ZPCH	
13160   90CE   A4 81       		ldy	ZPCM	
13161   90D0   20 E5 90    		jsr	PAGE		;RETURN BUFFER IN A THAT HAS VPAGE A,Y
13162   90D3   18          		clc		
13163   90D4   69 08       		adc	#>PBEGIN	
13164   90D6   85 84       		sta	ZPCPNT+HI	
13165   90D8   A0 01       		ldy	#PB_BANK
13166   90DA   84 85       		sty	ZPCBNK	
13167                      	;
13168                      	; TEST MUCKING
13169                      	;
13170   90DC   AD E4 90    		lda	MUCKFLG	
13171   90DF   F0 EA       		beq	NOZMUCK	
13172   90E1   4C 85 90    		jmp	VLDMPC	;MAY HAVE MUCKED MPC SO GO FIX
13173                      	
13174                      	
13175                      	; FIND V-PAGE A,Y IF IT IS IN MEM
13176                      	; AND RETURN WITH LINKED LIST
13177                      	; PROPERLY MAINTAINED
13178                      	; IF V-PAGE A,Y NOT IN MEM
  Wed Jun  7 1989 12:04                                                                                                  Page  196

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13179                      	; GET FROM DISK AND PUT IN RIGHT
13180                      	; PLACE
13181                      	
13182   90E4   00          	MUCKFLG:	DB	00	;00 IF PAGING BUFFERS NOT MUCKED
13183                      	
13184   90E5               	PAGE:
13185   90E5   8D 75 8F    		sta	WANTED+HI	
13186   90E8   8C 74 8F    		sty	WANTED+LO	
13187   90EB   A2 00       		ldx	#0	
13188   90ED   8E E4 90    		stx	MUCKFLG		; CLEAR MUCK FLAG
13189   90F0   20 8F 91    		jsr	WHERE	
13190   90F3   90 39       		bcc	TOUGH		; PAGE IS RESIDENT IN PAGING SPACE
13191                      	;
13192                      	; PAGE MUST BE BROUGHT IN FROM DISK
13193                      	;
13194   90F5   A6 CD       		ldx	CURRENT		;GET BUFFER TO PUT PAGE INTO
13195   90F7   BD 00 0C    		lda	NEXTPNT,X	;BY LOOKING AT NEXT POINTER
13196   90FA   85 CD       		sta	CURRENT		;MAKE IT THE CURRENT BUFFER
13197   90FC   AA          		tax		
13198   90FD   AD 75 8F    		lda	WANTED+HI	;LET BUFFER MAP KNOW
13199   9100   9D 80 0C    		sta	VPAGEH,X	;WHICH PAGE
13200   9103   AD 74 8F    		lda	WANTED+LO	;IS GOING TO
13201   9106   29 FE       		and	#$FE		; make address be even
13202   9108   9D C0 0C    		sta	VPAGEL,X	;BE THERE
13203                      	;***
13204                      	; point to the next page too
13205                      	;
13206   910B   09 01       		ora	#1		; add one to point to next 256 byte page
13207   910D   48          		pha			; save it
13208   910E   8A          		txa			; get pointer
13209   910F   A8          		tay			; into y
13210   9110   C8          		iny			; point to next buffer
13211   9111   68          		pla			; get second buffer back
13212   9112   99 C0 0C    		sta	VPAGEL,Y	; so point to it
13213   9115   BD 80 0C    		lda	VPAGEH,X	; get MSB
13214   9118   99 80 0C    		sta	VPAGEH,Y	; and save it
13215                      	;
13216                      	; A = WANTED+HI
13217                      	; Y = WANTED+LO
13218                      	; X = BUFFER
13219                      	;
13220   911B   AD 74 8F    		lda	WANTED+LO	
13221   911E   29 FE       		and	#$FE		; clear low bit to make it even
13222   9120   A8          		tay			; want it in y
13223                      	;*** 
13224   9121   AD 75 8F    		lda	WANTED+HI	
13225   9124   A6 CD       		ldx	CURRENT
13226   9126   20 53 91    		jsr	GETVPAGE	; PUT V-PAGE A,Y INTO PAGING BUFFER X
13227                      	;***
13228   9129   CE E4 90    		dec	MUCKFLG		; INDICATE A MUCKING
13229   912C   D0 1C       		bne	PAGEXIT		; and return current buffer
13230   912E               	TOUGH:
13231   912E   29 FE       		and	#$FE		; make even page, please
13232   9130   8D 76 8F    		sta	NEXT	
13233   9133   C5 CD       		cmp	CURRENT		; GETS REALY SCREWED IF CURRENT==NEXT
13234   9135   F0 13       		beq	PAGEXIT		; DO NOT CHANGE POINTERS IF IT DOES
13235                      	;
13236                      	; Y=NEXT(CURRENT)
13237                      	; DO THE RIGHT THING TO THE POINTERS
13238                      	;
13239                      	;	ldy	CURRENT	
13240                      	;	lda	NEXTPNT,Y	
13241                      	;	sta	NSUBCUR	
13242   9137   AD 76 8F    		lda	NEXT	
13243   913A   20 7D 91    		jsr	DETATCH	
13244   913D   A4 CD       		ldy	CURRENT	
13245   913F   AD 76 8F    		lda	NEXT	
13246   9142   20 66 91    		jsr	INSERT	
13247   9145   AD 76 8F    		lda	NEXT	
13248   9148   85 CD       		sta	CURRENT	
13249   914A               	PAGEXIT:
13250                      	;*** perhaps add one to point to correct buffer
13251   914A   AD 74 8F    		lda	WANTED+LO	; get LSB
13252   914D   29 01       		and	#$01		; pick up even/odd bit
13253   914F   18          		clc			; doing add
  Wed Jun  7 1989 12:04                                                                                                  Page  197

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13254   9150   65 CD       		adc	CURRENT		; point to correct buffer
13255   9152   60          		rts
13256                      	
13257   9153               	GETVPAGE:			
13258   9153   8D 5F 6C    		sta	DBLOCK+HI	
13259   9156   8C 5E 6C    		sty	DBLOCK+LO	
13260   9159   8A          		txa			; get which paging buffer
13261   915A   18          		clc		
13262   915B   69 08       		adc	#>PBEGIN	; and set up abs addr
13263   915D   85 B7       		sta	DBUFF+HI	; thank you, that's much better
13264   915F   A2 01       		ldx	#PB_BANK
13265   9161   86 B8       		stx	DSKBNK	
13266   9163   4C CF 46    		jmp	GETDSK	
13267                      	
13268                      	; INSERT A AFTER Y
13269                      	; A.next = Y.next
13270                      	; Y.next = A
13271                      	; A.previous = Y
13272                      	; [Y.next].previous = A
13273   9166               	INSERT:
13274   9166   AA          		tax
13275   9167   B9 00 0C    		lda	NEXTPNT,Y	; Y.next
13276   916A   9D 00 0C    		sta	NEXTPNT,X	; A.next = Y.next
13277   916D   48          		pha			; save Y.next for later
13278   916E   8A          		txa
13279   916F   99 00 0C    		sta	NEXTPNT,Y	; Y.next = A
13280   9172   98          		tya
13281   9173   9D 40 0C    		sta	PREVPNT,X	; A.prev = Y
13282   9176   68          		pla			; get Y.next back
13283   9177   A8          		tay			; [Y.next].previous
13284   9178   8A          		txa
13285   9179   99 40 0C    		sta	PREVPNT,Y	; [Y.next].previous = A
13286   917C   60          		rts
13287                      	
13288          [01]        		IF	0	
13289                      	;
13290                      	; old one, which puts A AFTER! Y
13291                      	;
13292                      	; PREV(A)=Y
13293                      	; PREV(NEXT(Y))=A
13294                      	; NEXT(A)=NEXT(Y)
13295                      	; NEXT(Y)=A
13296                      	
13297                      		sta	ATEMP	
13298                      		sty	YTEMP	
13299                      		tax		
13300                      		tya		
13301                      		sta	PREVPNT,X	
13302                      	
13303                      		lda	NEXTPNT,Y	
13304                      		sta	NSUBY	
13305                      		txa		
13306                      		ldx	NSUBY	
13307                      		sta	PREVPNT,X	
13308                      	
13309                      		txa		
13310                      		ldx	ATEMP	
13311                      		sta	NEXTPNT,X	
13312                      	
13313                      		lda	ATEMP	
13314                      		sta	NEXTPNT,Y	
13315                      		rts		
13316          [00]        		ENDIF
13317                      	
13318                      	; DETATCH BUFFER >A<
13319                      	; NEXT(PREV(A))=NEXT(A)
13320                      	; PREV(NEXT(A))=PREV(A)
13321                      	
13322   917D               	DETATCH:
13323   917D   AA          		tax
13324   917E   BD 00 0C    		lda	NEXTPNT,X
13325   9181   A8          		tay			; Y == A.next
13326   9182   BD 40 0C    		lda	PREVPNT,X	; get A.previous
13327   9185   AA          		tax			; X == A.previous
13328   9186   98          		tya			; get A.next
  Wed Jun  7 1989 12:04                                                                                                  Page  198

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13329   9187   9D 00 0C    		sta	NEXTPNT,X	; [A.previous].next = A.next
13330   918A   8A          		txa			; get A.previous
13331   918B   99 40 0C    		sta	PREVPNT,Y	; [A.next].previous = A.previous
13332   918E   60          		rts		
13333                      	
13334                      	
13335                      	; RETURN BUFFER OF PAGE [WANTED]
13336                      	; IN >A< ELSE SEC  (Y=WANTED+LO)
13337                      	
13338   918F   A2 17       	WHERE:	LDX	#NUMBUFS-1	
13339   9191               	WHLOOP:			
13340   9191   AD 75 8F    		LDA	WANTED+HI	
13341   9194   DD 80 0C    		CMP	VPAGEH,X	;>SAME
13342   9197   F0 05       		BEQ	WHGOT	
13343   9199               	WHNOGOT:			
13344   9199   CA          		DEX		
13345   919A   10 F5       		BPL	WHLOOP	
13346   919C   38          		SEC		
13347   919D   60          		RTS		
13348   919E               	WHGOT:			
13349   919E   98          		TYA		
13350   919F   DD C0 0C    		CMP	VPAGEL,X	
13351   91A2   D0 F5       		BNE	WHNOGOT	
13352   91A4   8A          		TXA		
13353   91A5   18          		CLC		
13354   91A6   60          		RTS		
13355                      	;
13356                      	; CHECKPRE - check to see if page in [A] is in preloaded
13357                      	;
13358   91A7               	CHECKPRE:
13359   91A7   C5 C2       		cmp	TBLPUR		; check against PURE tables
13360   91A9   90 0B       		bcc	CHKPEXY		; must be preloaded then
13361   91AB               	CHKP1:
13362   91AB   C5 C3       		cmp	FUNPRE		; is it in function preload?
13363   91AD   90 09       		bcc	CHKPEXN		; preloaded function > desired, not preloaded
13364   91AF   C5 C4       		cmp	FUNPUR		; how bout at end?
13365   91B1   B0 05       		bcs	CHKPEXN		; it is not preloaded
13366   91B3               	CHKP3:
13367   91B3   18          		clc			; doing add
13368   91B4   65 C5       		adc	FUNPGE		; get me memory page for function
13369   91B6               	CHKPEXY:
13370   91B6   18          		clc			; show it is preloaded
13371   91B7   60          		rts			; then we got it
13372   91B8               	CHKPEXN:
13373   91B8   38          		sec			; show it ain't here
13374   91B9   60          		rts
13375                      	;
13376                      	; INFO_PAGE - is it one of the special preloaded pages for infoDOS?  If it
13377                      	;       is, then set up ZPCPNTR to point to it, and set carry.  Otherwise,
13378                      	;       clear carry to show it ain't.
13379   91BA               	IPAGE:	ds	2
13380   91BC               	INFO_PAGE:
13381   91BC   A5 82       	        lda     ZPCH            ; get 2 parts
13382   91BE   8D BB 91    	        sta     IPAGE+HI
13383   91C1   A5 81       	        lda     ZPCM
13384   91C3   8D BA 91    	        sta     IPAGE+LO
13385   91C6   4E BB 91    	        lsr     IPAGE+HI      ; /2 to get 512 block        
13386   91C9   6E BA 91    	        ror     IPAGE+LO
13387   91CC   A0 08       	        ldy     #SGTSEG         ; point to first segment, MSB
13388   91CE   B1 59       	        lda     (INFODOS),Y     ; howzit look?
13389   91D0   C8          	        iny                     ; point to LSB
13390   91D1   CD BB 91    	        cmp     IPAGE+HI
13391   91D4   90 0B       	        bcc     INFP1           ; might be interesting
13392   91D6   D0 34       	        bne     INFPNX          ; not here, < than minimum
13393   91D8   B1 59       	        lda     (INFODOS),Y     ; how bout LSB
13394   91DA   CD BA 91    	        cmp     IPAGE+LO
13395   91DD   F0 14       	        beq     INFPYX          ; found it
13396   91DF   B0 2B       	        bcs     INFPNX          ; nope, < than minimum again
13397                      	;
13398                      	; here, it's at least > than minimum
13399                      	;
13400   91E1               	INFP1:
13401                      	;        iny                     ; point at end block, MSB
13402   91E1   AD AB 6C    	        lda     INFODOS_END+HI  ; howz end segment look
13403   91E4   CD BB 91    	        cmp     IPAGE+HI
  Wed Jun  7 1989 12:04                                                                                                  Page  199

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13404   91E7   90 23       	        bcc     INFPNX          ; nope, > than maximum of special
13405   91E9   D0 08       	        bne     INFPYX          ; yup, < than maximum of special
13406                      	;        iny                     ; LSB of last one
13407   91EB   AD AA 6C    	        lda     INFODOS_END+LO     ; is LSB < special?
13408   91EE   CD BA 91    	        cmp     IPAGE+LO      ; MSB of current one == MSB of special        
13409   91F1   90 19       	        bcc     INFPNX          ; nope, not here
13410   91F3               	INFPYX:
13411   91F3   A0 09       	        ldy     #SGTSEG+1       ; point back to start block, LSB
13412   91F5   B1 59       	        lda     (INFODOS),Y     ; get start block
13413   91F7   0A          	        asl     A               ; *2 to get start page
13414   91F8   8D BA 91    	        sta     IPAGE+LO      ; save it
13415   91FB   A5 81       	        lda     ZPCM
13416   91FD   38          	        sec                     ; doing sub
13417   91FE   ED BA 91    	        sbc     IPAGE+LO      ; get offset into special block
13418   9201   18          	        clc                     ; now add in offset
13419   9202   69 D0       	        adc     #>SP_START      ; get the start of special area
13420   9204   85 84       	        sta     ZPCPNT+HI       ; show ZPCPNTR
13421   9206   A9 00       	        lda     #SP_BANK        ; which bank
13422   9208   85 85       	        sta     ZPCBNK          ; okey
13423   920A   38          	        sec                     ; show it was here
13424   920B   60          	        rts
13425   920C               	INFPNX:
13426   920C   18          	        clc                     ; show not here
13427   920D   60          	        rts                     ; g'day
13428   920E               	        
13429   920E               	        
13430   920E               	        
13431   920E               	CHKPEXN0:
13432                      	
13433   920E               	GETBYT:			
13434   920E   A4 86       		ldy	MPCL	
13435   9210   20 8D 92    		jsr	MFETCH		; go and get it
13436   9213   E6 86       		inc	MPCL		;POINT TO NEXT BYTE
13437   9215   D0 0B       		bne	GETGOT		;IF NO CROSS WE ARE STILL VALID
13438   9217   E6 87       		inc	MPCM	
13439   9219   D0 02       		bne	GET1
13440   921B   E6 88       		inc	MPCH
13441   921D               	GET1:
13442   921D   48          		pha			; save byte	
13443   921E   20 85 90    		jsr	VLDMPC	
13444   9221   68          		pla			; and get it back
13445   9222               	GETGOT:
13446   9222   A8          		tay		;SET FLAGS
13447   9223   60          		rts		;RED SLIPPER TIME
13448                      	;
13449                      	; NEXTPC - Fetch the byte at the current ZPC, point to next byte and
13450                      	; 		validate pointer
13451                      	;
13452   9224               	NEXTPC:
13453   9224   A4 80       		ldy	ZPCL		; get low pointer
13454   9226   20 75 92    		jsr	ZFETCH		; fetch @ZPCPNT
13455   9229   E6 80       		inc	ZPCL	
13456   922B   D0 0B       		bne	NXTGOT	
13457   922D   E6 81       		inc	ZPCM	
13458   922F   D0 02       		bne	CRSZ1	
13459   9231   E6 82       		inc	ZPCH	
13460   9233               	CRSZ1:
13461   9233   48          		pha			; save opcode
13462   9234   20 AF 90    		jsr	VLDZPC	
13463   9237   68          		pla			; and get it back
13464   9238               	NXTGOT:
13465   9238   A8          		tay		
13466   9239   60          		rts		
13467                      	
13468                      	;
13469                      	; STASHB - use SPC to save a byte in either aux or main mem
13470                      	;
13471   923A               	STASHB:	
13472   923A   A4 91       		ldy	SPCBNK		; get the bank
13473   923C   30 09       		bmi	SB1		; must be in upper RAM
13474   923E   99 04 C0    		sta	WRTBNK,Y	; set bank
13475   9241   A0 00       		ldy	#0		; can only do this with Y
13476   9243   91 8F       		sta	(SPC),Y		; get the sucker
13477   9245   F0 10       		beq	SBEXI		; jump to end it
13478                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page  200

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13479                      	; this is in aux mem, >$E000
13480                      	;
13481   9247               	SB1:
13482   9247   A4 90       		ldy	SPCH		; get high part
13483   9249   8C 53 92    		sty	SBMOD+2		; and self mod my code
13484   924C   A4 8F       		ldy	SPCL		; and get the low part
13485   924E   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
13486   9251               	SBMOD:
13487   9251   99 00 D0    		sta	Z3BEGIN,Y	; store the little byte
13488   9254   8D 08 C0    		sta	ALTZP+MAIN	; go back to main mem
13489   9257               	SBEXI:
13490   9257   8D 04 C0    		sta	WRTBNK+MAIN	; and write to main
13491   925A   60          		rts
13492                      	;
13493                      	; FETCHB - fetch a byte from either main memory, aux memory, or upper
13494                      	;	Aux memory
13495                      	;
13496   925B               	FETCHB:
13497   925B   A4 8E       		ldy	FPCBNK		; get the bank
13498   925D   30 04       		bmi	FB1		; must be in upper RAM
13499   925F   20 D1 00    		jsr	ZERO_FB		; go to low end fetch
13500   9262   60          		rts
13501                      	;
13502                      	; this is in aux mem, >$E000
13503                      	;
13504   9263               	FB1:
13505   9263   A5 8D       		lda	FPCH		; get which page
13506   9265   8D 6F 92    		sta	FBMOD+2		; and show in operand
13507   9268   A4 8C       		ldy	FPCL		; get which byte
13508   926A   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
13509   926D   B9 00 D0    	FBMOD:	lda	Z3BEGIN,Y	; get the sucker
13510   9270   8D 08 C0    		sta	ALTZP+MAIN	; go back to main mem
13511   9273   A8          		tay			; set condition code
13512   9274   60          		rts
13513                      	;
13514                      	; ZFETCH - after checking for which bank (main, aux 1 or aux 2), go get
13515                      	;  the byte @ ZPCPNT, with the offset being in [Y]
13516                      	;
13517   9275               	ZFETCH:
13518   9275   A6 85       		ldx	ZPCBNK		; get the bank
13519   9277   30 04       		bmi	ZFB1		; must be in upper RAM
13520   9279   20 DC 00    		jsr	ZERO_ZF		; go to low end fetch
13521   927C   60          		rts
13522                      	;
13523                      	; this is in aux mem, >$D000
13524                      	;
13525   927D               	ZFB1:
13526   927D   A5 84       		lda	ZPNTH		; which page are we talking about
13527   927F   8D 87 92    		sta	ZBMOD+2		; show in the operand
13528   9282   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
13529   9285   B9 00 D0    	ZBMOD:	lda	Z3BEGIN,Y	; get the sucker
13530   9288   8D 08 C0    		sta	ALTZP+MAIN	; go back to main mem
13531   928B   AA          		tax			; set condition code
13532   928C   60          		rts
13533                      	;
13534                      	; MFETCH - after checking for which bank (main, aux 1 or aux 2), go get
13535                      	;  the byte @MPCPNT, with the offset being in [Y]
13536                      	;
13537   928D               	MFETCH:
13538   928D   A6 8B       		ldx	MPCBNK		; get the bank
13539   928F   30 04       		bmi	MB1		; must be in upper RAM
13540   9291   20 E5 00    		jsr	ZERO_MF		; go to low end fetch
13541   9294   60          		rts
13542                      	;
13543                      	; this is in aux mem, >$D000
13544                      	;
13545   9295               	MB1:
13546   9295   A5 8A       		lda	MPNTH		; which page are we talking about
13547   9297   8D 9F 92    		sta	MBMOD+2		; show in the operand
13548   929A   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
13549                      	
13550   929D   B9 00 D0    	MBMOD:	lda	Z3BEGIN,Y	; get the sucker
13551                      	
13552   92A0   8D 08 C0    		sta	ALTZP+MAIN	; go back to main mem
13553   92A3   AA          		tax			; set condition code
  Wed Jun  7 1989 12:04                                                                                                  Page  201

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13554   92A4   60          		rts
13555                      	
13556                      	
13557   92A5               		END
13558                      	
13559   92A5               		INCLUDE 	ZSTRING.ASM
13560                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page  202

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13561   92A5               		STTL "--- Z-STRING HANDLERS ---"
13562                      	
13563                      	; -----------------------
13564                      	; POINT MPC TO ZSTRING IN [I], using SOFF
13565                      	; -----------------------
13566                      	
13567   92A5               	SETSTR:
13568   92A5   A5 78       		lda	I+LO
13569   92A7   85 86       		sta	MPCL		; save in lo part	
13570   92A9   A5 79       		lda	I+HI
13571   92AB   85 87       		sta	MPCM		; middle part
13572   92AD   A9 00       		lda	#0		; clear hi part
13573   92AF   85 88       		sta	MPCH		; okay, we did
13574   92B1   06 86       		asl	MPCL		; *2
13575   92B3   26 87       		rol	MPCM
13576   92B5   26 88       		rol	MPCH
13577   92B7   06 86       		asl	MPCL		; *4
13578   92B9   26 87       		rol	MPCM
13579   92BB   26 88       		rol	MPCH
13580                      	;
13581                      	; now add the offset
13582                      	;
13583   92BD   A5 86       		lda	MPCL		; carry clear from above
13584   92BF   65 60       		adc	SOFFL		; add lo part of offset
13585   92C1   85 86       		sta	MPCL		; save
13586   92C3   A5 87       		lda	MPCM
13587   92C5   65 5F       		adc	SOFFM
13588   92C7   85 87       		sta	MPCM
13589   92C9   A5 88       		lda	MPCH
13590   92CB   65 5E       		adc	SOFFH
13591   92CD   85 88       		sta	MPCH
13592   92CF   4C 85 90    		jmp	VLDMPC		; make MPCPNT to it
13593                      	
13594                      	
13595   92D2   60          	ZSTEX:	RTS		
13596                      	
13597                      	; -----------------------
13598                      	; PRINT Z-STRING AT [MPC]
13599                      	; -----------------------
13600   92D3               	PZSTR:
13601   92D3   A2 00       	        ldx	#0	
13602   92D5   86 96       		stx	PSET	        ; ASSUME PERMANENT CHARSET
13603   92D7   86 9A       		stx	ZFLAG	        ; CLEAR BYTE FLAG
13604   92D9   CA          		dex		        ; = $FF
13605   92DA   86 97       		stx	TSET	        ; NO TEMPSET ACTIVE
13606   92DC               	PZTOP:
13607   92DC   20 CF 93    	        jsr	GETZCH	        ; GET A Z-CHAR
13608   92DF   B0 F1       		bcs	ZSTEX	        ; END OF STRING IF CARRY IS SET
13609   92E1   85 98       		sta	ZCHAR	        ; ELSE SAVE CHAR HERE
13610   92E3   AA          		tax		        ; SET FLAGS
13611   92E4   F0 45       		beq	BLANK	        ; PRINT SPACE IF CHAR = 0
13612   92E6   C9 04       		cmp	#4	        ; IS THIS AN F-WORD?
13613   92E8   90 5F       		bcc	DOFREQ	        ; APPARENTLY SO
13614   92EA   C9 06       		cmp	#6	        ; PERHAPS A SHIFT CODE?
13615   92EC   90 41       		bcc	NEWSET	        ; YES, CHANGE CHARSETS
13616   92EE   20 B1 93    		jsr	GETSET	        ; ELSE GET CHARSET
13617   92F1   AA          		tax		        ; SET FLAGS
13618   92F2   D0 14       		bne	SET1	        ; SKIP IF NOT CHARSET #0
13619                      	;
13620                      	; PRINT A LOWER-CASE CHAR (CHARSET #0)
13621                      	;
13622   92F4   A9 FA       	        lda     #$FA            ; what to add to get offset into char table
13623   92F6               	TOASC:
13624   92F6   8D FD 92    	        sta     TOASCM+1        ; modify code
13625   92F9   A5 98       	        lda     ZCHAR           ; use char as offset
13626   92FB   18          	        clc                     ; make char be an index
13627   92FC   69 06       	TOASCM: adc     #6              ; we just did
13628   92FE   AA          	        tax                     ; now use as index
13629   92FF   BD 8C 1F    	        lda     CHARSET,X       ; go get that char in charset zero
13630   9302               	SHOVE:
13631   9302   20 06 53    	        jsr	COUT	        ; SHOW THE CHAR
13632   9305   4C DC 92    		jmp	PZTOP	        ; AND GRAB NEXT CHAR
13633                      	;
13634                      	; PRINT AN UPPER-CASE CHAR (CHARSET #1)
13635                      	;
  Wed Jun  7 1989 12:04                                                                                                  Page  203

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13636   9308               	SET1:
13637   9308   C9 01       	        cmp	#1	        ; make sure it's set #1
13638   930A   D0 04       		bne	SET2	        ; else must be set #2
13639   930C   A9 14       		lda	#20             ; skip into Charset 1 part of table
13640   930E   D0 E6       		bne	TOASC	        ; fix just like the others
13641                      	;
13642                      	; PRINT FROM CHARSET #2
13643                      	;
13644   9310               	SET2:
13645   9310   A5 98       	        lda	ZCHAR	        ; retrieve the z-char
13646   9312   C9 06       	        cmp     #6              ; is it a special ascii char?
13647   9314   F0 04       	        beq     DIRECT          ; yes, so do it special
13648   9316   A9 2E       	        lda     #46             ; nothing special, just get offset
13649   9318   D0 DC       	        bne     TOASC           ; and jump
13650                      	;
13651                      	; DECODE A "DIRECT" ASCII CHAR
13652                      	;
13653   931A               	DIRECT:
13654   931A   20 CF 93    	        jsr	GETZCH	        ; FETCH NEXT Z-CHAR
13655   931D   0A          		asl	A		
13656   931E   0A          		asl	A		
13657   931F   0A          		asl	A		
13658   9320   0A          		asl	A		
13659   9321   0A          		asl	A	        ; SHIFT INTO POSITION
13660   9322   85 98       		sta	ZCHAR	        ; AND SAVE HERE
13661   9324   20 CF 93    		jsr	GETZCH	        ; GRAB YET ANOTHER Z-CHAR
13662   9327   05 98       		ora	ZCHAR	        ; SUPERIMPOSE THE 2ND BYTE
13663   9329   D0 D7       		bne	SHOVE	        ; AND PRINT THE RESULT
13664                      	;
13665                      	; PRINT A SPACE
13666                      	;
13667   932B               	BLANK:
13668   932B   A9 20       	        lda	#SPACE	        ; ASCII SPACE CHAR
13669   932D   D0 D3       		bne	SHOVE	
13670                      	
13671                      		; CHANGE CHARSET
13672                      	
13673   932F   38          	NEWSET:	SEC		; CONVERT THE SHIFT CODE
13674   9330   E9 03       		SBC	#3	; TO 1 OR 2
13675   9332   A8          		TAY		
13676   9333   20 B1 93    		JSR	GETSET	; IS MODE TEMPORARY?
13677   9336   D0 05       		BNE	TOPERM	; YES, DO A PERMSHIFT
13678   9338   84 97       		STY	TSET	; ELSE JUST A TEMPSHIFT
13679   933A   4C DC 92    		JMP	PZTOP	; AND CONTINUE
13680   933D   84 96       	TOPERM:	STY	PSET	; SET PERM CHARSET
13681   933F   C5 96       		CMP	PSET	; SAME AS BEFORE?
13682   9341   F0 99       		BEQ	PZTOP	; YES, CONTINUE
13683   9343   A9 00       		LDA	#0	
13684   9345   85 96       		STA	PSET	; ELSE RESET CHARSET
13685   9347   F0 93       		BEQ	PZTOP	; BEFORE LOOPING BACK
13686                      	
13687                      		; PRINT AN F-WORD
13688                      	
13689   9349   38          	DOFREQ:	SEC		
13690   934A   E9 01       		SBC	#1	; ZERO-ALIGN THE CODE
13691   934C   0A          		ASL	A	; AND MULTIPLY TIMES 64
13692   934D   0A          		ASL	A	; TO OBTAIN THE SEGMENT OFFSET
13693   934E   0A          		ASL	A	; INTO THE F-WORDS TABLE
13694   934F   0A          		ASL	A		
13695   9350   0A          		ASL	A		
13696   9351   0A          		ASL	A		
13697   9352   85 99       		STA	OFFSET	; SAVE OFFSET FOR LATER
13698   9354   20 CF 93    		JSR	GETZCH	; NOW GET THE F-WORD POINTER
13699   9357   0A          		ASL	A	; WORD-ALIGN IT
13700   9358   18          		CLC		; AND
13701   9359   65 99       		ADC	OFFSET	; ADD THE SEGMENT OFFSET
13702                      	;
13703                      	; set up FPC to point to FWORDS table
13704                      	;
13705   935B   A6 57       		ldx	FWORDS+ABANK
13706   935D   86 8E       		stx	FPCBNK
13707   935F   A6 56       		ldx	FWORDS+HI
13708   9361   86 8D       		stx	FPCH
13709   9363   A6 55       		ldx	FWORDS+LO
13710   9365   86 8C       		stx	FPCL
  Wed Jun  7 1989 12:04                                                                                                  Page  204

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13711   9367   20 E3 8F    		jsr	ADDFPC		; add offset of the F-word
13712   936A   20 5B 92    		jsr	FETCHB		; and get MSB of F-word
13713   936D   85 79       		sta	I+HI		; and save it
13714   936F   20 C3 8F    		jsr	NEXTFPC		; and point to LSB
13715   9372   20 5B 92    		jsr	FETCHB		; and get it
13716   9375   85 78       		sta	I+LO		; and save it
13717                      	;
13718                      	; SAVE THE STATE OF CURRENT Z-STRING
13719                      	;
13720   9377   A5 88       		LDA	MPCH	
13721   9379   48          		PHA		
13722   937A   A5 87       		LDA	MPCM	
13723   937C   48          		PHA		
13724   937D   A5 86       		LDA	MPCL	
13725   937F   48          		PHA		
13726   9380   A5 96       		LDA	PSET	
13727   9382   48          		PHA		
13728   9383   A5 9A       		LDA	ZFLAG	
13729   9385   48          		PHA		
13730   9386   A5 9C       		LDA	ZWORD+HI	
13731   9388   48          		PHA		
13732   9389   A5 9B       		LDA	ZWORD+LO	
13733   938B   48          		PHA		
13734   938C   20 BD 93    		JSR	SETFWD	; PRINT THE Z-STRING
13735   938F   20 D3 92    		JSR	PZSTR	; IN [I]
13736                      	;
13737                      	; RESTORE OLD Z-STRING
13738                      	;
13739   9392   68          		PLA		
13740   9393   85 9B       		STA	ZWORD+LO	
13741   9395   68          		PLA		
13742   9396   85 9C       		STA	ZWORD+HI	
13743   9398   68          		PLA		
13744   9399   85 9A       		STA	ZFLAG	
13745   939B   68          		PLA		
13746   939C   85 96       		STA	PSET	
13747   939E   68          		PLA		
13748   939F   85 86       		STA	MPCL	
13749   93A1   68          		PLA		
13750   93A2   85 87       		STA	MPCM	
13751   93A4   68          		PLA		
13752   93A5   85 88       		STA	MPCH	
13753   93A7   A2 FF       		LDX	#$FF	
13754   93A9   86 97       		STX	TSET	; DISABLE TEMP CHARSET
13755   93AB   20 85 90    		JSR	VLDMPC	
13756   93AE   4C DC 92    		JMP	PZTOP	; CONTINUE INNOCENTLY
13757                      	
13758                      	
13759                      	; ----------------------
13760                      	; RETURN CURRENT CHARSET
13761                      	; ----------------------
13762                      	
13763   93B1   A5 97       	GETSET:	LDA	TSET	
13764   93B3   10 03       		BPL	GS	
13765   93B5   A5 96       		LDA	PSET	
13766   93B7   60          		RTS		
13767   93B8   A0 FF       	GS:	LDY	#$FF	
13768   93BA   84 97       		STY	TSET	
13769   93BC   60          		RTS		
13770                      	
13771                      	
13772                      	; -------------------------
13773                      	; POINT [I] AT FWORD STRING
13774                      	; -------------------------
13775                      	
13776   93BD   A5 78       	SETFWD:	LDA	I+LO	; WORD-ALIGN THE ADDRESS
13777   93BF   0A          		ASL	A		
13778   93C0   85 86       		STA	MPCL	
13779   93C2   A5 79       		LDA	I+HI	
13780   93C4   2A          		ROL	A		
13781   93C5   85 87       		STA	MPCM	
13782   93C7   A9 00       		LDA	#0	
13783   93C9   2A          		ROL	A		
13784   93CA   85 88       		STA	MPCH	
13785   93CC   4C 85 90    		JMP	VLDMPC	
  Wed Jun  7 1989 12:04                                                                                                  Page  205

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13786                      	
13787                      	
13788                      	; -----------------
13789                      	; FETCH NEXT Z-CHAR
13790                      	; -----------------
13791                      	
13792   93CF   A5 9A       	GETZCH:	LDA	ZFLAG	; WHICH BYTE IS THIS?
13793   93D1   10 02       		BPL	GTZ0	; $FF = LAST
13794   93D3   38          		SEC		; SET CARRY TO INDICATE
13795   93D4   60          		RTS		; NO MORE CHARS
13796   93D5   D0 13       	GTZ0:	BNE	GETZ1	; NOT FIRST CHAR, EITHER
13797                      	
13798                      		; GET A Z-WORD INTO [ZWORD], RETURN 1ST CHAR IN TRIPLET
13799                      	
13800   93D7   E6 9A       		INC	ZFLAG	; UPDATE CHAR COUNT
13801   93D9   20 0E 92    		JSR	GETBYT	; GET TRIPLET AT [MPC]
13802   93DC   85 9C       		STA	ZWORD+HI	; INTO [ZWORD]
13803   93DE   20 0E 92    		JSR	GETBYT	
13804   93E1   85 9B       		STA	ZWORD+LO	
13805   93E3   A5 9C       		LDA	ZWORD+HI	
13806   93E5   4A          		LSR	A		
13807   93E6   4A          		LSR	A	; SHIFT 1ST CHAR INTO PLACE
13808   93E7   4C 13 94    		JMP	GTEXIT	; AND RETURN IT
13809   93EA   38          	GETZ1:	SEC		
13810   93EB   E9 01       		SBC	#1	
13811   93ED   D0 16       		BNE	GETZ2	; LAST CHAR IN TRIPLET IF ZERO
13812   93EF   A9 02       		LDA	#2	; ELSE
13813   93F1   85 9A       		STA	ZFLAG	; RESET CHAR INDEX
13814   93F3   A5 9B       		LDA	ZWORD+LO	; GET BOTTOM HALF OF TRIPLET
13815   93F5   85 78       		STA	I+LO	; MOVE HERE FOR SHIFTING
13816   93F7   A5 9C       		LDA	ZWORD+HI	; GET TOP HALF
13817   93F9   06 78       		ASL	I+LO	; SHIFT THE TOP 3 BITS OF LOWER HALF
13818   93FB   2A          		ROL	A	; INTO THE BOTTOM OF THE TOP HALF
13819   93FC   06 78       		ASL	I+LO	
13820   93FE   2A          		ROL	A		
13821   93FF   06 78       		ASL	I+LO	
13822   9401   2A          		ROL	A		
13823   9402   4C 13 94    		JMP	GTEXIT	
13824   9405   A9 00       	GETZ2:	LDA	#0	; SET FLAG TO INDICATE
13825   9407   85 9A       		STA	ZFLAG	; END OF TRIPLET
13826   9409   A5 9C       		LDA	ZWORD+HI	; TEST TOP HALF OF TRIPLET
13827   940B   10 04       		BPL	GETZ3	; CONTINUE IF NOT END OF STRING
13828   940D   A9 FF       		LDA	#$FF	; ELSE
13829   940F   85 9A       		STA	ZFLAG	; INDICATE LAST TRIPLET IN STRING
13830   9411   A5 9B       	GETZ3:	LDA	ZWORD+LO	; GET BOTTOM HALF OF TRIPLET
13831   9413   29 1F       	GTEXIT:	AND	#%00011111	; MASK OUT GARBAGE BITS
13832   9415   18          		CLC		
13833   9416   60          		RTS		
13834                      	
13835                      	
13836                      	; ---------------------------------
13837                      	; CONVERT [IN] TO Z-STRING IN [OUT]
13838                      	; ---------------------------------
13839   9417               	CONZST:
13840   9417   A9 05       	        lda	#5	        ; FILL OUTPUT BUFFER
13841   9419   A2 08       		ldx	#8	        ; WITH PAD CHARS ($05)
13842   941B               	CZSL:
13843   941B   9D 9E 6C    	        sta	OUT,X	
13844   941E   CA          		dex		
13845   941F   10 FA       		bpl	CZSL	
13846                      	
13847   9421   A9 09       		lda	#9	        ; INIT
13848   9423   85 9D       		sta	CONCNT	        ; CHAR COUNT
13849   9425   A9 00       		lda	#0	        ; CLEAR
13850   9427   85 9E       		sta	CONIN	        ; SOURCE AND
13851   9429   85 9F       		sta	CONOUT	        ; OUTPUT INDEXES
13852   942B               	CONTOP:
13853   942B   A6 9E       	        ldx	CONIN	        ; fetch source index
13854   942D   E6 9E       		inc	CONIN	        ; and update
13855   942F   BD 95 6C    		lda	IN,X	        ; grab an ascii char
13856   9432   85 98       		sta	ZCHAR	        ; save it here
13857   9434   D0 04       		bne	NEXTZ	        ; continue if char was nz
13858   9436   A9 05       		lda	#5	        ; else ship out
13859   9438   D0 27       		bne	CSHIP1	        ; a pad char
13860   943A               	NEXTZ:
  Wed Jun  7 1989 12:04                                                                                                  Page  206

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13861   943A   20 66 94    	        jsr     FINDCHAR        ; find out where it tis
13862   943D   F0 21       	        beq     CSHIP           ; no shift for charset zero
13863   943F   18          		clc		        ; else do a temp-shift
13864   9440   69 03       		adc	#3	        ; 4 = charset 1, 5 = charset 2
13865   9442   20 94 94    	        jsr     CSTASH          ; save the char in outbuf
13866   9445   C9 05       	        cmp     #5              ; charset 2?
13867   9447   D0 17       	        bne     CSHIP           ; nope
13868   9449   E0 06       	        cpx     #6              ; ascii escape?
13869   944B   D0 13       	        bne     CSHIP           ; nope
13870                      	;
13871                      	; Handle special Ascii escape sequence
13872                      	;
13873   944D   8A          	        txa                     ; get ASCII alert char (#6)        
13874   944E   20 94 94    	        jsr     CSTASH          ; shove it away
13875                      	;
13876                      	; do 1st half of "direct"
13877                      	;
13878   9451   A5 98       		lda	ZCHAR           ; re-fetch char        
13879   9453   4A          		lsr	A               ; get upper 2 bits in lower 2 bits
13880   9454   4A          		lsr	A
13881   9455   4A          		lsr	A
13882   9456   4A          		lsr	A
13883   9457   4A          		lsr	A
13884   9458   20 94 94    	        jsr     CSTASH
13885                      	;
13886                      	; SEND 2ND HALF OF "DIRECT"
13887                      	;
13888   945B   A5 98       		lda	ZCHAR	        ; get char yet again
13889   945D   29 1F       		and	#%00011111	; and get lower 5 bits
13890   945F   AA          	        tax                     ; this is where it is expected
13891                      	;
13892                      	; SHIP Z-CHAR TO OUTPUT BUFFER
13893                      	;
13894   9460               	CSHIP:
13895   9460   8A          	        txa                     ; get char
13896   9461               	CSHIP1:
13897   9461   20 94 94    	        jsr     CSTASH          ; put char away
13898   9464   D0 C5       	        bne     CONTOP          ; do again
13899                      	;
13900                      	; FINDCHAR - look through the charset table for the character.  If found,
13901                      	;       figger out which shift it is.  If not found, return charset 2, 
13902                      	;       character #6.
13903                      	;  Enter:
13904                      	;       [A] = Char we are looking for
13905                      	;  Returns:
13906                      	;       [A] = Charset (0-2)
13907                      	;       [X] = Character # (6-31)
13908                      	;
13909   9466               	FINDCHAR:
13910   9466   A2 00       	        ldx     #0              ; start at first char, first set
13911   9468   A0 4E       	        ldy     #78             ; there are 78 characters
13912   946A               	FNDCL:
13913   946A   DD 8C 1F    	        cmp     CHARSET,X       ; found it?
13914   946D   F0 09       	        beq     FNDCLX          ; yes
13915   946F   E8          	        inx                     ; next char
13916   9470   88          	        dey                     ; count char
13917   9471   D0 F7       	        bne     FNDCL           ; go check next char
13918                      	;
13919                      	; not found in table, use ASCII escape sequence
13920                      	;
13921   9473   A9 02       	        lda     #2              ; escape sequence is char set 2
13922   9475   A2 06       	        ldx     #6              ; character 6
13923   9477   60          	        rts                     ; and done
13924   9478               	FNDCLX:
13925   9478   8A          	        txa                     ; put here for compares/action
13926   9479   A0 00       	        ldy     #0              ; this is char set 0
13927   947B   A2 FA       	        ldx     #$FA            ; what to "subtract" to get +6
13928   947D   C9 1A       	        cmp     #26             ; how we doin'?
13929   947F   90 0A       	        bcc     FNDCHX          ; all done
13930   9481   C8          	        iny                     ; char set 1
13931   9482   A2 14       	        ldx     #20             ; char set 1 offset
13932   9484   C9 34       	        cmp     #52             ; well?
13933   9486   90 03       	        bcc    FNDCHX           ; must be char set 1
13934   9488   A2 2E       	        ldx     #46             ; for char set 2 setting up
13935   948A   C8          	        iny                     ; must be char set 2 then
  Wed Jun  7 1989 12:04                                                                                                  Page  207

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13936   948B               	FNDCHX:
13937   948B   8E 90 94    	        stx     FNDCHM+1        ; what to subtract to get offset
13938   948E   38          	        sec                     ; doing subtract
13939   948F   E9 06       	FNDCHM: sbc     #6              ; make good offset
13940   9491   AA          	        tax                     ; put here for return
13941   9492   98          	        tya                     ; and here to set flag
13942   9493   60          	        rts
13943                      	;
13944                      	; CSTASH - put the char in OUT.  If we run out of room don't return, just
13945                      	;       jump to ZCRUSH as final destination
13946                      	;   [A] - char to be put away
13947                      	;
13948   9494               	CSTASH:
13949   9494   A4 9F       		ldy	CONOUT	        ; fetch output index
13950   9496   99 9E 6C    		sta	OUT,Y	        ; send the shift char
13951   9499   E6 9F       		inc	CONOUT	        ; update index
13952   949B   C6 9D       		dec	CONCNT	        ; and char count
13953   949D   D0 05       		bne	CSTX            ; plenty more room
13954   949F   68          	        pla                     ; get rid of return spot
13955   94A0   68          	        pla                     ; fine
13956   94A1   4C A5 94    		jmp	ZCRUSH	        ; if out of room, crush 'em!
13957   94A4               	CSTX:
13958   94A4   60          	        rts
13959                      	; ----------------------
13960                      	; CRUSH Z-CHARS IN [OUT], mushing them into small 5 bit pieces
13961                      	; ----------------------
13962   94A5               	ZCRUSH:
13963   94A5   AD 9F 6C    	        LDA	OUT+1	        ; GET 2ND Z-CHAR
13964   94A8   0A          		ASL	A	        ; SHIFT BITS INTO POSITION
13965   94A9   0A          		ASL	A		
13966   94AA   0A          		ASL	A		
13967   94AB   0A          		ASL	A		
13968   94AC   2E 9E 6C    		ROL	OUT	        ; ALONG WITH 1ST Z-CHAR
13969   94AF   0A          		ASL	A		
13970   94B0   2E 9E 6C    		ROL	OUT	
13971   94B3   0D A0 6C    		ORA	OUT+2	        ; SUPERIMPOSE 3RD Z-CHAR
13972   94B6   8D 9F 6C    		STA	OUT+1	
13973   94B9   AD A2 6C    		LDA	OUT+4	        ; GET 5TH Z-CHAR
13974   94BC   0A          		ASL	A	        ; SHIFT BITS
13975   94BD   0A          		ASL	A		
13976   94BE   0A          		ASL	A		
13977   94BF   0A          		ASL	A		
13978   94C0   2E A1 6C    		ROL	OUT+3	        ; ALONG WITH 4TH Z-CHAR
13979   94C3   0A          		ASL	A		
13980   94C4   2E A1 6C    		ROL	OUT+3	
13981   94C7   0D A3 6C    		ORA	OUT+5	        ; SUPERIMPOSE 6TH Z-CHAR
13982   94CA   AA          		TAX		        ; SAVE HERE
13983   94CB   AD A1 6C    		LDA	OUT+3	        ; GRAB 4TH Z-CHAR
13984   94CE   8D A0 6C    		STA	OUT+2	        ; MOVE CRUSHED Z-WORD
13985   94D1   8E A1 6C    		STX	OUT+3	        ; INTO PLACE
13986   94D4   AD A5 6C    		LDA	OUT+7	        ; GET 8TH Z-CHAR (EZIP)
13987   94D7   0A          		ASL	A	        ; SHIFT BITS
13988   94D8   0A          		ASL	A		
13989   94D9   0A          		ASL	A		
13990   94DA   0A          		ASL	A		
13991   94DB   2E A4 6C    		ROL	OUT+6	        ; ALONG WITH 7TH Z-CHAR
13992   94DE   0A          		ASL	A		
13993   94DF   2E A4 6C    		ROL	OUT+6	
13994   94E2   0D A6 6C    		ORA	OUT+8	        ; SUPERIMPOSE 9TH Z-CHAR
13995   94E5   8D A3 6C    		STA	OUT+5	        ; SAVE HERE
13996   94E8   AD A4 6C    		LDA	OUT+6	        ; GRAB 7TH Z-CHAR
13997   94EB   09 80       		ORA	#%10000000	; SET HIGH BIT
13998   94ED   8D A2 6C    		STA	OUT+4	        ; MOVE CRUSHED Z-WORD INTO PLACE
13999   94F0   60          		RTS		
14000                      	
14001   94F1               		END
14002                      	
14003   94F1               		INCLUDE 	OBJECTS.ASM
14004   94F1               		STTL "--- OBJECT & PROPERTY HANDLERS ---"
14005                      		PAGE	
  Wed Jun  7 1989 12:04                                                                                                  Page  208

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- OBJECT & PROPERTY HANDLERS ---"

14006                      	
14007                      	; ----------------------------------
14008                      	; GET ABSOLUTE ADDRESS OF OBJECT [A]
14009                      	; ----------------------------------
14010                      	; ENTER: OBJECT IN A/X (LO/HI)
14011                      	; EXIT: ADDRESS IN [FPC]
14012   94F1               	OBJLOC:
14013   94F1   86 79       		STX	I+HI		; SAVE MSB FOR SHIFTING
14014   94F3   0A          		ASL	A		; MULTIPLY BY LENGTH OF AN ENTRY (14)
14015   94F4   85 78       		STA	I+LO	
14016   94F6   26 79       		ROL	I+HI	
14017   94F8   A6 79       		LDX	I+HI	
14018   94FA   0A          		ASL	A		
14019   94FB   26 79       		ROL	I+HI	; *4
14020   94FD   0A          		ASL	A		
14021   94FE   26 79       		ROL	I+HI	; *8
14022   9500   0A          		ASL	A		
14023   9501   26 79       		ROL	I+HI	; *16
14024   9503   38          		SEC		
14025   9504   E5 78       		SBC	I+LO	; -(*2)
14026   9506   85 78       		STA	I+LO	; SO IS *14 TOTAL
14027   9508   A5 79       		LDA	I+HI	
14028   950A   86 79       		STX	I+HI	
14029   950C   E5 79       		SBC	I+HI	
14030   950E   85 79       		STA	I+HI	
14031   9510   A5 78       		LDA	I+LO	
14032   9512   18          		CLC		
14033   9513   69 70       		ADC	#112		; ADD OBJECT TABLE OFFSET
14034   9515   90 02       		BCC	OBJ3	
14035   9517   E6 79       		INC	I+HI	
14036   9519               	OBJ3:
14037   9519   18          		clc			; NEXT ADD THE relative ADDR
14038   951A   6D 0B 96    		adc	ZBEGIN+ZOBJEC+1	; OF THE OBJECT TABLE
14039   951D   85 8C       		sta	FPCL		; save lo byte
14040   951F   A5 79       		lda	I+HI	
14041   9521   6D 0A 96    		adc	ZBEGIN+ZOBJEC	; now work on page
14042   9524   20 7C 8F    		jsr	SETPC		; now get page/bank
14043   9527   85 8D       		sta	FPCH		; this is hi part
14044   9529   84 8E       		sty	FPCBNK		; and this is the bank
14045   952B   60          		rts
14046                      	; -----------------------------
14047                      	; GET ADDRESS OF PROPERTY TABLE
14048                      	; -----------------------------
14049                      	; EXIT: [FPC] HAS ABSOLUTE ADDR OF PROPERTY TABLE
14050                      	;		including OFFSET TO START OF PROP IDS
14051   952C               	PROPB:
14052   952C   A5 63       		lda	ARG1+LO	
14053   952E   A6 64       		ldx	ARG1+HI	; get address
14054   9530   20 F1 94    		jsr	OBJLOC	; put table location into FPC
14055   9533   A9 0C       		lda	#12	; add 12 to get to beginning
14056   9535   20 E3 8F    		jsr	ADDFPC	; and add it to FPC
14057   9538   20 5B 92    		jsr	FETCHB	; get MSB of P-TABLE Address
14058   953B   48          		pha		; and save it for a moment
14059   953C   20 C3 8F    		jsr	NEXTFPC	; to get LSB
14060   953F   20 5B 92    		jsr	FETCHB	; get LSB of P-TABLE Address
14061   9542   85 8C       		sta	FPCL	; and save lo part
14062   9544   68          		pla		; get page back
14063   9545   20 7C 8F    		jsr	SETPC	; and set up memory bank/page
14064   9548   85 8D       		sta	FPCH	; save page
14065   954A   84 8E       		sty	FPCBNK	; and bank
14066   954C   20 5B 92    		jsr	FETCHB	; get length of short description
14067   954F   0A          		asl	A	; WORD-ALIGN IT
14068   9550   20 E3 8F    		jsr	ADDFPC	; and add it to FPC
14069   9553   20 C3 8F    		jsr	NEXTFPC	; POINT JUST PAST THE DESCRIPTION
14070   9556   60          		rts
14071                      	
14072                      	
14073                      	; -------------------
14074                      	; FETCH A PROPERTY ID
14075                      	; -------------------
14076                      	; ENTRY: LIKE "PROPB" EXIT (i.e. - address in FPC)
14077                      	;
14078   9557               	PROPN:
14079   9557   20 5B 92    		jsr	FETCHB		; get the byte
14080   955A   29 3F       		and	#%00111111	; MASK OUT LENGTH BITS (EZIP)
  Wed Jun  7 1989 12:04                                                                                                  Page  209

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- OBJECT & PROPERTY HANDLERS ---"

14081   955C   60          		rts		
14082                      	
14083                      	; -------------------------------
14084                      	; FETCH # BYTES IN PROPERTY VALUE
14085                      	; -------------------------------
14086                      	; ENTRY: LIKE "PROPB" EXIT (i.e. - address in FPC)
14087                      	;
14088   955D               	PROPL:
14089   955D   20 5B 92    		jsr	FETCHB		; CHECK LENGTH FLAGS
14090   9560   AA          		tax			; save it
14091   9561   10 09       		bpl	SHORT		; OFF, SO 1 OR 2 BYTES
14092   9563   20 C3 8F    		jsr	NEXTFPC
14093   9566   20 5B 92    		jsr	FETCHB		; NEXT BYTE HAS LENGTH
14094   9569   29 3F       		and	#%00111111	; MASK OFF EXTRA BITS
14095   956B   60          		rts		
14096   956C               	SHORT:
14097   956C   29 40       		and	#%01000000	; BIT 6
14098   956E   F0 03       		beq	ONE	
14099   9570   A9 02       		lda	#2		; BIT 6 = 1, LENGTH =2
14100   9572   60          		rts		
14101   9573               	ONE:
14102   9573   A9 01       		lda	#1		; BIT 6 = 0, LENGTH =1
14103   9575   60          		rts		
14104                      	
14105                      	; ----------------------
14106                      	; POINT TO NEXT PROPERTY
14107                      	; ----------------------
14108                      	; ENTRY: LIKE "PROPB" EXIT (i.e. - in [FPC])
14109                      	;
14110   9576               	PROPNX:
14111   9576   20 5D 95    		jsr	PROPL	; GET LENGTH OF CURRENT PROP
14112   9579   A8          		tay		; move one more for correct alignment
14113   957A   C8          		iny		; okay, done it
14114   957B   98          		tya		; thanks
14115   957C   20 E3 8F    		jsr	ADDFPC	; add to [FPC]
14116   957F   60          		rts
14117                      	;
14118                      	; ----------------
14119                      	; GET OBJECT FLAGS
14120                      	; ----------------
14121                      	; ENTRY: OBJECT # IN [ARG1], FLAG # IN [ARG2]
14122                      	; EXIT: FLAG WORD IN [K], BIT ID IN [J],
14123                      	; FLAG WORD ADDRESS IN [FPC]
14124                      	;
14125   9580               	FLAGSU:
14126   9580   A5 63       		LDA	ARG1+LO	; get table offset
14127   9582   A6 64       		LDX	ARG1+HI	
14128   9584   20 F1 94    		JSR	OBJLOC	; GET OBJECT ADDR IN [FPC]
14129   9587   A5 65       		LDA	ARG2+LO	; LOOK AT FLAG ID
14130   9589   C9 10       		CMP	#$10	; FIRST SET OF FLAGS?
14131   958B   90 14       		BCC	FLS1	; YES, ADDR IN [FPC] IS CORRECT
14132   958D   E9 10       		SBC	#16	; ELSE ZERO-ALIGN FLAG INDEX
14133   958F   AA          		TAX		; SAVE IT HERE
14134   9590   C9 10       		CMP	#$10	; CHECK IF IN 2ND WORD
14135   9592   90 07       		BCC	FLS	; YES, GO ALIGN FOR THAT
14136   9594   E9 10       		SBC	#16	; ELSE ALIGN TO 3RD WORD
14137   9596   AA          		TAX		
14138   9597   A9 04       		lda	#4	; 3rd Flag word
14139   9599   D0 02       		bne	FLSx	; and add it in
14140   959B               	FLS:
14141   959B   A9 02       		lda	#2	; 2nd Flag word
14142   959D               	FLSx:
14143   959D   20 E3 8F    		jsr	ADDFPC
14144   95A0               	FLS0:
14145   95A0   8A          		TXA		; RESTORE INDEX
14146   95A1               	FLS1:
14147   95A1   85 7C       		STA	K+LO	; SAVE FLAG ID HERE
14148   95A3   A2 01       		LDX	#1	; INIT THE
14149   95A5   86 7A       		STX	J+LO	; FLAG WORD TO
14150   95A7   CA          		DEX		; $0001
14151   95A8   86 7B       		STX	J+HI	
14152   95AA   A9 0F       		LDA	#15	; SUBTRACT THE BIT POSITION
14153   95AC   38          		SEC		; FROM 15
14154   95AD   E5 7C       		SBC	K+LO	; TO GET THE SHIFT LOOP
14155   95AF   AA          		TAX		; INDEX
  Wed Jun  7 1989 12:04                                                                                                  Page  210

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- OBJECT & PROPERTY HANDLERS ---"

14156   95B0   F0 07       		BEQ	FLS2	; EXIT NOW IF NO SHIFT NEEDED
14157   95B2   06 7A       	FLSL:	ASL	J+LO	; SHIFT THE BIT
14158   95B4   26 7B       		ROL	J+HI	; INTO POSITION
14159   95B6   CA          		DEX		
14160   95B7   D0 F9       		BNE	FLSL	
14161   95B9               	FLS2:
14162   95B9   20 5B 92    		jsr	FETCHB	; MOVE THE FLAG WORD
14163   95BC   85 7D       		sta	K+HI	; INTO [K] - FIRST THE MSB
14164   95BE   20 C3 8F    		jsr	NEXTFPC	; and then get get LSB
14165   95C1   20 5B 92    		jsr	FETCHB
14166   95C4   85 7C       		sta	K+LO	; THEN THE LSB
14167   95C6   4C 29 90    		jmp	PREVFPC	; point back to flag word
14168                      	
14169   95C9               		END
14170                      	
14171                      	
14172   95C9               		BLKB	ZBEGIN-$,0
14173   9600               		END



           Lines Assembled :  14173             Assembly Errors :  0


