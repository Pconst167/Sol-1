  Wed May 24 1989 15:00                                                                                                  Page    1

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- OBJECT & PROPERTY HANDLERS ---"




               2500 A.D. 6502 Macro Assembler  -  Version 4.01a
               ------------------------------------------------

                       Input  Filename : YZIP.asm
                       Output Filename : YZIP.obj


    1                      		; --------------------------
    2                      		; YZIP
    3                      		; Z-CODE INTERPRETER PROGRAM
    4                      		; FOR APPLE ][e/][c/][gs
    5                      		; --------------------------
    6                      	
    7                      		; INFOCOM, INC.
    8                      		; 125 CAMBRIDGEPARK DRIVE
    9                      		; CAMBRIDGE, MA 02140
   10                      	
   11                      		; COMPANY PRIVATE -- NOT FOR DISTRIBUTION
   12                      	
   13                      		PL	50000		; PAGE LENGTH OF PRINTER
   14                      	
   15          0000        	DEBUG	EQU	0	; ASSEMBLY FLAG FOR DEBUGGER (1 = YES)
   16          0000        	CHECKSUM EQU 	0	; == 1 for generating save/restore checksum
   17                      	
   18                      	 	; -----------
   19                      		; ERROR CODES
   20                      		; -----------
   21                      	
   22                      		; 00 -- INSUFFICIENT RAM
   23                      		; 01 -- ILLEGAL X-OP
   24                      		; 02 -- ILLEGAL 0-OP
   25                      		; 03 -- ILLEGAL 1-OP
   26                      		; 04 -- ILLEGAL 2-OP
   27                      		; 05 -- Z-STACK UNDERFLOW
   28                      		; 06 -- Z-STACK OVERFLOW
   29                      		; 07 -- ILLEGAL PROPERTY LENGTH (GETP)
   30                      		; 08 -- DIVISION BY ZERO
   31                      		; 09 -- ILLEGAL ARGUMENT COUNT (EQUAL?)
   32                      		; 10 -- ILLEGAL PROPERTY ID (PUTP)
   33                      		; 11 -- ILLEGAL PROPERTY LENGTH (PUTP)
   34                      		; 12 -- DISK ADDRESS OUT OF RANGE
   35                      		; 13 -- IMPURE CODE TOO LARGE (BM 1/20/86)
   36                      		; 14 -- DRIVE ACCESS
   37                      		; 15 -- NOT AN EZIP GAME
   38                      		; 16 -- ILLEGAL EXTENDED RANGE X-OP
   39                      		; 17 -- BAD VIRTUAL PAGE
   40                      		; 18 -- SETPC NOT PRELOADED
   41                      		; 19 -- PREVIOUS (SPC/FPC) NOT POSSIBLE
   42                      		; 20 -- PICTURE NOT FOUND
   43                      	        ; 21 -- ZERO OBJECT TO BE REMOVED
   44                      		; 22 -- OBJECT TOO BIG (ZLOC)
   45                      		; 23 -- Bad read: Read != Asked for
   46                      		; 24 -- Bad read: Retry 1 != Retry 2
   47                      		; 25 -- Clear of zero height/width window
   48   0000               		
   49   0000               		TITLE	"APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
   50   0000               		INCLUDE 	ZIP.EQU
   51   0000               		STTL	"--- YZIP EQUATES ---"
   52                      		PAGE 
  Wed May 24 1989 15:00                                                                                                  Page    2

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- YZIP EQUATES ---"

   53                      	
   54          0009        	VERSID	EQU	9	; VERSION OF INTERPRETER
   55                      				; See file "versions" for complete descriptions
   56                      	
   57          00FF        	TRUE	EQU	$FF	
   58          0000        	FALSE	EQU	0	
   59                      	
   60                      	; ---------------------
   61                      	; Segment table equates
   62                      	; ---------------------
   63          0000        	SGTDISKS EQU	0		; number of disks
   64          0002        	SGTPAD	EQU	SGTDISKS+2	; just some extra room
   65          0012        	SGTCHKS1 EQU	SGTPAD+16	; Checksum for disk 1 (PRELOAD)
   66          0014        	SGTPICOF1 EQU	SGTCHKS1+2	; N/A
   67          0016        	SGTSEG1 EQU	SGTPICOF1+2	; # of segments
   68          0018        	SGTGPOF1 EQU    SGTSEG1+2       ; Global Picture Directory
   69          001A        	SGTTBLS	EQU	SGTGPOF1+2	; Start of table preload (should be 0)
   70          001C        	SGTTBLE	EQU	SGTTBLS+2	; Last page of table preload
   71          001E        	SGTTBLX	EQU	SGTTBLE+2	; N/A
   72          0020        	SGTFUNS	EQU	SGTTBLX+2	; First page of function preload
   73          0022        	SGTFUNE	EQU	SGTFUNS+2	; End page of function preload
   74          0024        	SGTFUNX	EQU	SGTFUNE+2	; N/A
   75          0026        	SGTDSK	EQU	SGTFUNX+2	; Actual start of disk segment tables
   76                      	
   77          0000        	SGTCHKS EQU	0	; check sum for file
   78          0002        	SGTPICOF EQU	2	; picture data offset
   79          0004        	SGTNSEG	EQU	4	; # of segments in this list
   80          0006        	SGTGPOF EQU     6       ; Global Directory Offset 
   81          0008        	SGTSEG	EQU	8	; start of segments
   82                      	; ---------------------
   83                      	; Z-CODE HEADER OFFSETS
   84                      	; ---------------------
   85                      	
   86          0000        	ZVERS	EQU	0	; VERSION BYTE
   87          0001        	ZMODE	EQU	1	; MODE SELECT BYTE
   88          0002        	ZID	EQU	2	; GAME ID WORD
   89          0004        	ZENDLD	EQU	4	; # OF QUADWORDS ON SIDE 1 OF DISK
   90          0006        	ZGO	EQU	6	; EXECUTION ADDRESS
   91          0008        	ZVOCAB	EQU	8	; START OF VOCABULARY TABLE
   92          000A        	ZOBJEC	EQU	10	; START OF OBJECT TABLE
   93          000C        	ZGLOBAL	EQU	12	; START OF GLOBAL VARIABLE TABLE
   94          000E        	ZPURBT	EQU	14	; START OF "PURE" Z-CODE
   95          0010        	ZFLAGS	EQU	16	; FLAG WORD
   96          0012        	ZSERIA	EQU	18	; 3-WORD SERIAL NUMBER
   97          0018        	ZFWORD	EQU	24	; START OF FWORDS TABLE
   98          001A        	ZLENTH	EQU	26	; LENGTH OF Z-PROGRAM IN WORDS
   99          001C        	ZCHKSM	EQU	28	; Z-CODE CHECKSUM WORD
  100          001E        	ZINTWD	EQU	30	; INTERPRETER ID WORD (SUPPLIED BY EZIP)
  101          0020        	ZSCRWD	EQU	32	; SCREEN PARAMETER WORD ( "     "   "  )
  102          0022        	ZHWRD	EQU	34	; DISPLAY WIDTH IN PIXELS
  103          0024        	ZVWRD	EQU	36	; DISPLAY HEIGHT IN PIXELS
  104          0026        	ZFWRD	EQU	38	; FONT HEIGHT, FONT WIDTH
  105          0028        	ZFOFF	EQU	40	; FUNCTION OFFSET
  106          002A        	ZSOFF	EQU	42	; STRING OFFSET
  107          002C        	ZCLRWD	EQU	44	; FORGROUND COLOR, BACKGROUND COLOR
  108          002E        	ZTCHAR	EQU	46	; POINTER TO TBL OF TERMINATING CHARS
  109          0030        	ZTWIDTH	EQU	48	; Running counter for table output char width
  110          0032        	ZCRFUNC	EQU	50	; FUNCTION FOR CARRIAGE RETURNS
  111          0034        	ZCHRSET	EQU	52	; POINTER TO CHAR SET TBL
  112          0036        	ZEXTAB	EQU	54	; Points to extension table, if needed
  113                      	;
  114                      	; Extension table offsets
  115                      	;
  116          0000        	ZEXTLEN	EQU	0	; Length of extension table
  117          0002        	ZMSLOCX	EQU	2	; x location of mouse
  118          0004        	ZMSLOCY	EQU	4	; y location of mouse
  119          0006        	ZMSETBL	EQU	6	; MOUSE TBL CHANGE WORD
  120          0008        	ZMSEDIR	EQU	8	; DIRECTION MENU
  121          000A        	ZMSEINV	EQU	10	; INVENTORY MENU
  122          000C        	ZMSEVRB	EQU	12	; FREQUENT VERB MENU
  123          000E        	ZMSEWRD	EQU	14	; FREQUENT WORD MENU
  124          0010        	ZBUTTN	EQU	16	; BUTTON HANDLER
  125          0012        	ZJOYST	EQU	18	; JOYSTICK HANDLER
  126          0014        	ZBSTAT	EQU	20	; BUTTON STATUS
  127          0016        	ZJSTAT	EQU	22	; JOYSTICK STATUS
  Wed May 24 1989 15:00                                                                                                  Page    3

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- YZIP EQUATES ---"

  128                      	;
  129                      	; ZFLAGS values
  130                      	;
  131          0001        	FSCRI	EQU	$01	; scripting?
  132          0002        	FMONO	EQU	$02	; mono spaced font?
  133          0004        	FSTAT	EQU	$04	; status line refresh?
  134          0008        	FDISP	EQU	$08	; uses DISPLAY operations?
  135          0010        	FUNDO	EQU	$10	; uses UNDO?
  136          0020        	FMOUS	EQU	$20	; uses mouse?
  137          0040        	FCOLO	EQU	$40	; uses color?
  138          0080        	FMENU	EQU	$80	; uses menus?
  139                      	;---------------
  140                      	; Picture data
  141                      	;---------------
  142                      	;=== DATA HEADER ===
  143          0000        	PHFID	EQU	0		; File ID
  144          0001        	PHFLG	EQU	PHFID+1		; Flags
  145          0002        	PHHUFF	EQU	PHFLG+1		; Pointer to Huffman data
  146          0004        	PHNLD	EQU	PHHUFF+2	; # entries in local directory
  147          0006        	PHNGD	EQU	PHNLD+2		; # entries in global directory
  148          0008        	PHDSIZE	EQU	PHNGD+2		; Local directory entry size
  149          000A        	PHCHKS	EQU	PHDSIZE+2	; File Checksum
  150          000C        	PHFVERS	EQU	PHCHKS+2	; File Version (N/A)
  151          000E        	PHEXTRA	EQU	PHFVERS+2	; Extra room for getting fatter
  152          0010        	PHSIZE	EQU	16		; 16 bytes is header size
  153                      	;=== DATA HEADER FLAGS ===
  154          0001        	PHFGD	EQU	$1		; data has global directory
  155          0002        	PHFHUFF	EQU	$2		; Huffman encoded pictures
  156          0004        	PHFHUFF1 EQU	$4		; All pictures use same Huff tree
  157          0008        	PHFPAL	EQU	$8		; No pallette information
  158                      	;=== LOCAL DIRECTORY ===
  159          0000        	PLDID	EQU	0		; Picture ID
  160          0002        	PLDWID	EQU	PLDID+2		; Picture Width
  161          0003        	PLDHGHT	EQU	PLDWID+1	; Picture Height
  162          0004        	PLDFLG	EQU	PLDHGHT+1	; Flags
  163          0005        	PLDPTR	EQU	PLDFLG+1	; Pointer to picture data
  164          0008        	PLDSIZE	EQU	PLDPTR+3	; size of local directory entry
  165                      	
  166   0000               		END
  167                      	
  168   0000               		INCLUDE		ZERO.EQU
  169   0000               		STTL	"--- ZERO PAGE VARIABLES ---"
  170                      		PAGE 
  Wed May 24 1989 15:00                                                                                                  Page    4

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- ZERO PAGE VARIABLES ---"

  171                      	
  172          0000        	SCRCX	EQU	0		; CURSOR HORIZONTAL
  173          0001        	SCRCY	EQU	SCRCX+1		; CURSOR VERTICAL
  174          0002        	SCRBTM	EQU	SCRCY+1		; first line outside current window
  175          0003        	MAXLINES EQU	SCRBTM+1	; maximum number of lines in window
  176          0004        	LEFTMRG	EQU	MAXLINES+1	; left edge + left margin in current window
  177          0005        	WINDOW	EQU	LEFTMRG+1	; (WORD) address of current window structure
  178          0007        	LINE_X  EQU     WINDOW+2        ; (WORD) width of line counter
  179          0009        	CC_OFF  EQU     LINE_X+2        ; save offset for char drawing
  180          000A        	CLSLEFT	EQU	CC_OFF+1	; screen limits for CLS code
  181          000B        	CLSTOP	EQU	CLSLEFT+1	; top of screen
  182          000C        	CLSWIDTH EQU	CLSTOP+1	; # of columns 
  183          000D        	CLSHEIGHT EQU	CLSWIDTH+1	; # of lines
  184                      	;
  185                      	; some variables for all the screen positioning code
  186                      	;
  187          000E        	NY_DATA	EQU	CLSHEIGHT+1	; place for GET/PUT_NYBBLE to use
  188          000F        	CH_OFFSET EQU	NY_DATA+1	; offset into char data table
  189          0010        	DATALOOP EQU	CH_OFFSET+1 	; loop counter for byte works
  190          0011        	BITOFF	EQU	DATALOOP+1	; bit offset into screen byte
  191          0012        	CH_DATA	EQU	BITOFF+1	; actual char data being worked on
  192          0013        	SCR_DATA EQU	CH_DATA+1	; screen byte being worked on
  193          0014        	SH_LOOP	EQU	SCR_DATA+1	; loop counter for bit shifting
  194          0015        	SCROLLY	EQU	SH_LOOP+1	; save spot for y pos when scrolling
  195          0016        	RETRIES EQU	SCROLLY+1	; (BYTE) Machine ID
  196          0017        	CHRMAX	EQU	RETRIES+1	; (BYTE) # CHARS CAN INPUT FROM KEYBOARD
  197          0018        	SCLLINES EQU	CHRMAX+1	; (BYTE) how many lines to scroll
  198          0019        	FMTTBL	EQU	SCLLINES+1	; (BYTE) flag to show formatted table output
  199          001A        	STMASK	EQU	FMTTBL+1	; (BYTE) Mask to use on first byte of CLS
  200          001B        	ENDMASK	EQU	STMASK+1	; (BYTE) Mask to use on last byte of CLS
  201          001C        	CHPTR	EQU	ENDMASK+1	; (WORD) pointer to char data
  202          001C        	SCOFF	EQU	CHPTR		;(BYTE) Offset used by scroll
  203          001D        	SCLDIR	EQU	CHPTR+1		;(BYTE) Direction of scroll - >0 up, <0 down
  204          001E        	DSEGS	EQU	CHPTR+2 	; (WORD) Pointer to current disk's segments
  205                      	;WIDE_FLAG EQU   SCOFF+1         ; (BYTE) <> 0 if 16 bytes in char data
  206                      	;DSEGS	EQU	WIDE_FLAG+1	; (WORD) Pointer to current disk's segments
  207          0020        	LASTWV	EQU	DSEGS+2		; last of the WINDOW variables
  208                      	
  209          0050        	ZEROPG	EQU	$50		; FIRST FREE Z-PAGE LOCATION
  210                      	;
  211                      	; these are first, cuz ZBOOT inits them so we don't want to clear them
  212                      	; at ZBEGIN warm start
  213                      	;
  214          0050        	GLOBAL	EQU	ZEROPG		; (Relative Addr.) GLOBAL VARIABLE POINTER
  215          0052        	VOCAB	EQU	GLOBAL+2	; (ADDRESS) Vocab table pointer
  216          0055        	FWORDS	EQU	VOCAB+3		; (ADDRESS) F-WORDS TABLE POINTER
  217          0058        	MOUSEF	EQU	FWORDS+3	; (BYTE) ==-1/1 if we have mouse/joystick
  218          0059        	INFODOS EQU     MOUSEF+1        ; (WORD) if <>0, then pointer to D2SEG
  219          005B        	FUNOFF	EQU	INFODOS+2	; (ADDRESS) Function Offset (ZFOFF*8)
  220          005B        	FOFFH	EQU	FUNOFF		; (BYTE) Hi part 
  221          005C        	FOFFM	EQU	FUNOFF+1	; (BYTE) Middle part
  222          005D        	FOFFL	EQU	FUNOFF+2	; (BYTE) Lo part
  223          005E        	STROFF	EQU	FUNOFF+3	; (ADDRESS) String Offset (ZSOFF*8)
  224          005E        	SOFFH	EQU	STROFF		; (BYTE) Hi part 
  225          005F        	SOFFM	EQU	STROFF+1	; (BYTE) Middle part
  226          0060        	SOFFL	EQU	STROFF+2	; (BYTE) Lo part
  227                      	;
  228                      	; Beginning of warm start zeroing
  229                      	;
  230          0061        	OPCODE	EQU	STROFF+3	; (BYTE) CURRENT OPCODE
  231          0062        	NARGS	EQU	OPCODE+1	; (BYTE) # ARGUMENTS
  232          0063        	ARG1	EQU	OPCODE+2	; (WORD) ARGUMENT #1
  233          0065        	ARG2	EQU	OPCODE+4	; (WORD) ARGUMENT #2
  234          0067        	ARG3	EQU	OPCODE+6	; (WORD) ARGUMENT #3
  235          0069        	ARG4	EQU	OPCODE+8	; (WORD) ARGUMENT #4
  236          006B        	ARG5	EQU	OPCODE+10	; (WORD)
  237          006D        	ARG6	EQU	OPCODE+12	; (WORD)
  238          006F        	ARG7	EQU	OPCODE+14	; (WORD)
  239          0071        	ARG8	EQU	OPCODE+16	; (WORD)
  240          0073        	ABYTE	EQU	OPCODE+18	; (BYTE) X-OP ARGUMENT BYTE
  241          0074        	BBYTE	EQU	OPCODE+19	; (BYTE) XCALL ARG BYTE (EZIP)
  242          0075        	ADEX	EQU	OPCODE+20	; (BYTE) X-OP ARGUMENT INDEX
  243          0076        	VALUE	EQU	OPCODE+21	; (WORD) VALUE RETURN REGISTER
  244          0078        	I	EQU	VALUE+2		; (WORD) GEN-PURPOSE REGISTER #1
  245          007A        	J	EQU	VALUE+4		; (WORD) GEN-PURPOSE REGISTER #2
  Wed May 24 1989 15:00                                                                                                  Page    5

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- ZERO PAGE VARIABLES ---"

  246          007C        	K	EQU	VALUE+6		; (WORD) GEN-PURPOSE REGISTER #3
  247          007E        	L	EQU	VALUE+8		; (WORD) GEN-PURPOSE REGISTER #4
  248          0080        	ZPC	EQU	VALUE+10	; (3 BYTES) ZIP PROGRAM COUNTER
  249          0080        	ZPCL	EQU	ZPC		; (BYTE) <8 BITS OF [ZPC]
  250          0081        	ZPCM	EQU	ZPC+1		; (BYTE) MIDDLE 8 BITS OF [ZPC]
  251          0082        	ZPCH	EQU	ZPC+2		; (BYTE) >BIT OF [ZPC]
  252          0083        	ZPCPNT	EQU	ZPC+3		; (3 BYTES) ABS POINTER TO CURRENT Z-PAGE
  253          0083        	ZPNTL	EQU	ZPCPNT		; FIRST 2 BYTES = SAME AS FOR ZIP (EZIP)
  254          0084        	ZPNTH	EQU	ZPCPNT+1	; (BYTE)
  255          0085        	ZPCBNK	EQU	ZPCPNT+2	; (BYTE) INDICATES AUXILIARY MEMORY
  256          0086        	MPC	EQU	ZPCPNT+3	; (3 BYTES) MEMORY PROGRAM COUNTER
  257          0086        	MPCL	EQU	MPC		; (BYTE) <8 BITS OF [MPC]
  258          0087        	MPCM	EQU	MPC+1		; (BYTE) MIDDLE 8 BITS OF [MPC]
  259          0088        	MPCH	EQU	MPC+2		; (BYTE) >BIT OF [MPC]
  260          0089        	MPCPNT	EQU	MPC+3		; (3 BYTES) ABS POINTER TO CURRENT M-PAGE
  261          0089        	MPNTL	EQU	MPCPNT		; FIRST 2 BYTES = SAME AS FOR ZIP (EZIP)
  262          008A        	MPNTH	EQU	MPCPNT+1	; (BYTE)
  263          008B        	MPCBNK	EQU	MPCPNT+2	; (BYTE) INDICATES AUXILIARY MEMORY
  264          008C        	FPC	EQU	MPCBNK+1	; (3 Bytes) Fetch pointer 
  265          008C        	FPCL	EQU	FPC		; (BYTE) Low part
  266          008D        	FPCH	EQU	FPCL+1		; (BYTE) High Part
  267          008E        	FPCBNK	EQU	FPCH+1		; (BYTE) Bank part (0-Main, 1-Aux)
  268          008F        	SPC	EQU	FPCBNK+1	; (3 Bytes) Fetch pointer 
  269          008F        	SPCL	EQU	SPC		; (BYTE) Low part
  270          0090        	SPCH	EQU	SPCL+1		; (BYTE) High Part
  271          0091        	SPCBNK	EQU	SPCH+1		; (BYTE) Bank part (0-Main, 1-Aux)
  272                      	
  273                      	; Z-STRING MANIPULATION VARIABLES
  274                      	
  275          0092        	LINLEN	EQU	SPCBNK+1	; (BYTE) LENGTH OF CURRENT LINE
  276          0093        	SOURCE	EQU	LINLEN+1	; (BYTE) counter for read
  277          0094        	WRDLEN	EQU	SOURCE+1	; (BYTE) LENGTH OF CURRENT WORD
  278          0095        	ESIZE	EQU	WRDLEN+1	; (BYTE) SIZE OF VOCAB TABLE ENTRIES
  279          0096        	PSET	EQU	ESIZE+1		; (BYTE) PERMANENT CHARSET
  280          0097        	TSET	EQU	PSET+1		; (BYTE) TEMPORARY CHARSET
  281          0098        	ZCHAR	EQU	TSET+1		; (BYTE) CURRENT Z-CHAR
  282          0099        	OFFSET	EQU	ZCHAR+1		; (BYTE) F-WORD TABLE OFFSET
  283          009A        	ZFLAG	EQU	OFFSET+1	; (BYTE) Z-WORD ACCESS FLAG
  284          009B        	ZWORD	EQU	ZFLAG+1		; (WORD) CURRENT Z-WORD
  285          009D        	CONCNT	EQU	ZWORD+2		; (BYTE) Z-STRING SOURCE COUNTER
  286          009E        	CONIN	EQU	CONCNT+1	; (BYTE) CONVERSION SOURCE INDEX
  287          009F        	CONOUT	EQU	CONIN+1		; (BYTE) CONVERSION DEST INDEX
  288          00A0        	DIRTBL	EQU	CONOUT+1	; (WORD) CONTAINS TBLE TO STORE CHARS TO
  289          00A2        	XSIZE	EQU	DIRTBL+2	; (WORD) SCREEN WIDTH FOR TESTS
  290          00A4        	RAND    EQU     XSIZE+2         ; (WORD) Random number offset
  291          00A6        	CURWIN	EQU	RAND+2		; (BYTE) WHICH WINDOW TO WRITE IN
  292          00A7        	LENGTH	EQU	CURWIN+1	; (WORD) CHAR POSITION ON THE SCREEN
  293          00A9        	CHRCNT	EQU	LENGTH+2	; (BYTE) CHAR POSITION IN [LBUFF]
  294          00AA        	SCRIPT	EQU	CHRCNT+1	; (BYTE) SCRIPT ENABLE FLAG
  295          00AB        	LINCNT	EQU	SCRIPT+1	; (BYTE) LINE COUNTER
  296          00AC        	IOCHAR	EQU	LINCNT+1	; (BYTE) CHARACTER BUFFER
  297          00AD        	COLORP	EQU	IOCHAR+1	; (WORD) Pointer to current background color
  298          00AF        	ZSP	EQU	COLORP+2	; (WORD) Z Stack
  299          00B1        	SCREENF	EQU	ZSP+2		; (BYTE) DIROUT FLAG FOR SCREEN OUTPUT
  300          00B2        	TABLEF	EQU	SCREENF+1	; (BYTE) DIROUT FLAG FOR TABLE OUTPUT
  301          00B3        	VOCEND	EQU	TABLEF+1	; (3 BYTES) HOLDS MPC IN VOCAB SEARCH
  302          00B6        	DBUFF	EQU	VOCEND+3	; (WORD) RAM PG TO ACCESS (LSB = 0)
  303          00B8        	DSKBNK	EQU	DBUFF+2		; (BYTE) MAIN/AUX bank
  304          00B9        	ALLFLG	EQU	DSKBNK+1	; (BYTE) IF =1 ALL FCN KEYS (>127) ARE TCHARS
  305          00BA        	UNDFLG	EQU	ALLFLG+1	; (BYTE) Underlining flag
  306          00BB        	INVFLG	EQU	UNDFLG+1	; (BYTE) Inverse flag
  307          00BC        	MEMPAGE	EQU	INVFLG+1	; (BYTE) Save spot for XPAGING stuff
  308          00BD        	CPY_COUNT EQU	MEMPAGE+1	; (BYTE) Number of bytes for copy line
  309          00BE        	TBLHEIGHT EQU	CPY_COUNT+1	;(BYTE) Number of lines in printing table
  310          00BF        	TBLWIDTH EQU	TBLHEIGHT+1	;(BYTE) Number of bytes per line
  311          00C0        	TBLCNT	EQU	TBLWIDTH+1	;(BYTE) Counter for table printing
  312          00C1        	FONTFLG	EQU	TBLCNT+1	;(BYTE) Which font (!=0 is width)
  313          00C2        	TBLPUR	EQU	FONTFLG+1	;(BYTE) first pure table page
  314          00C3        	FUNPRE	EQU	TBLPUR+1	;(BYTE) first preloaded function page
  315          00C4        	FUNPUR	EQU	FUNPRE+1	;(BYTE)	first pure function page
  316          00C5        	FUNPGE	EQU	FUNPUR+1	;(BYTE) -number to get function preload page
  317          00C6        	DELAY_COUNTER EQU FUNPGE+1	;(BYTE) counter for delay loop
  318                      	;
  319                      	; some char-to-screen variables
  320                      	;
  Wed May 24 1989 15:00                                                                                                  Page    6

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- ZERO PAGE VARIABLES ---"

  321          00C7        	CHAR_D1	EQU	DELAY_COUNTER+1	; (BYTE) character data, part 1
  322          00C8        	CHAR_D2	EQU	CHAR_D1+1	; (BYTE) char data, part 2
  323          00C9        	CW	EQU	CHAR_D2+1	; (BYTE) width of the character
  324          00CA        	CLKCTR	EQU	CW+1		; (BYTE) counter for mouse clicking
  325          00CB        	MSX	EQU	CLKCTR+1	; (BYTE) mouse cursor X
  326          00CC        	MSY	EQU	MSX+1		; (BYTE) mouse cursor Y
  327          00CD        	CURRENT	EQU	MSY+1		; (BYTE) current paging bufer
  328                      	;CURSOR_OFF EQU  CURRENT+1       ; (BYTE) ==1 if "don't show the blinking cursor"
  329          00CE        	MSTBL	EQU	CURRENT+1	; (ADDRESS) pointer to extension table
  330          00D1        	LASTZP	EQU	MSTBL+3		; just checking
  331                      	;
  332                      	; these routines are in non-swapped memory
  333                      	;
  334          00D1        	ZERO_FB	EQU	LASTZP		; put fetch byte routine in at end of ZP
  335          00DC        	ZERO_ZF	EQU	ZERO_FB+11	; and ZPCPNT fetch after that
  336          00E5        	ZERO_MF	EQU	ZERO_ZF+9	; and MPCPNT fetch after that
  337          00EE        	SAVE_DATA EQU	ZERO_MF+9	; copy data from DBUFF to IOBUFF routine
  338                      	;
  339                      	; and just to check the end
  340                      	;
  341          00FF        	ZEE_END EQU	SAVE_DATA+17	; should be == 100
  342                      	
  343   0000               		END
  344                      	
  345   0000               		INCLUDE		PRODOS.EQU
  346   0000               		STTL	"--- ProDOS EQUATES ---"
  347                      		PAGE 
  Wed May 24 1989 15:00                                                                                                  Page    7

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- ProDOS EQUATES ---"

  348                      	
  349                      	;
  350                      	; some parameter structures
  351                      	;
  352          0000        	OPEN_PARM	EQU	0
  353          0000        	OP_PCOUNT	EQU	OPEN_PARM	; must be 3 for open
  354          0001        	OP_PATHNAME	EQU	OP_PCOUNT+1	; address of pathname
  355          0003        	OP_FILEBUFF	EQU	OP_PATHNAME+2	; address of file data buffer
  356          0005        	OP_REFNUM	EQU	OP_FILEBUFF+2	; file reference number
  357          0006        	OPEN_PSIZE	EQU	OP_REFNUM+1	; size of parameter buffer
  358                      	
  359          0000        	READ_PARM	EQU	0		; to read things
  360          0000        	RD_PCOUNT	EQU	READ_PARM	; param count (=4)
  361          0001        	RD_REFNUM	EQU	RD_PCOUNT+1	; ref num of file
  362          0002        	RD_BUFFER	EQU	RD_REFNUM+1	; where to
  363          0004        	RD_BUFFLEN	EQU	RD_BUFFER+2	; length of buffer
  364          0006        	RD_LENGTH	EQU	RD_BUFFLEN+2	; actual length of read
  365          0008        	READ_PSIZE	EQU	RD_LENGTH+2	; length of parm block
  366                      	
  367          0000        	CLOSE_PARM	EQU	0		; for closing file
  368          0000        	CL_PCOUNT	EQU	CLOSE_PARM	; paramter count (=1)
  369          0001        	CL_REFNUM	EQU	CL_PCOUNT+1	; refnum of file to be closed
  370          0002        	CLOSE_PSIZE	EQU	CL_REFNUM+1	; this is the size, thank you
  371                      	
  372          0000        	WRITE_PARM	EQU	0		; to write things
  373          0000        	WR_PCOUNT	EQU	WRITE_PARM	; parm count (= 4)
  374          0001        	WR_REFNUM	EQU	WR_PCOUNT+1	; file refnum
  375          0002        	WR_BUFFER	EQU	WR_REFNUM+1	; data buffer address
  376          0004        	WR_BUFFLEN	EQU	WR_BUFFER+2	; data buffer length
  377          0006        	WR_LENGTH	EQU	WR_BUFFLEN+2	; actual length written
  378          0008        	WRITE_PSIZE	EQU	WR_LENGTH+2	; length of parm block
  379                      	
  380          0000        	SETMARK_PARM	EQU	0
  381          0000        	SM_PCOUNT	EQU	SETMARK_PARM	; parm count (=2)
  382          0001        	SM_REFNUM	EQU	SM_PCOUNT+1	; file refnum
  383          0002        	SM_FPOS		EQU	SM_REFNUM+1	; 3 byte file pos 
  384          0005        	SETMARK_PSIZE	EQU	SM_FPOS+3	; length of parm block
  385                      	
  386          0000        	SETPREFIX_PARM	EQU	0	
  387          0000        	SP_PCOUNT	EQU	SETPREFIX_PARM	; parm count (=1)
  388          0001        	SP_PATHNAME	EQU	SP_PCOUNT+1	; pointer to path name
  389          0003        	SETPREFIX_PSIZE	EQU	SP_PATHNAME+2	; length of block
  390                      	
  391          0000        	SETEOF_PARM     EQU     0
  392          0000        	SE_PCOUNT       EQU     SETEOF_PARM     ; parm count (=2)
  393          0001        	SE_REFNUM       EQU     SE_PCOUNT+1     ; reference number
  394          0002        	SE_NEWEOF       EQU     SE_REFNUM+1     ; new EOF position
  395          0005        	SETEOF_PSIZE    EQU     SE_NEWEOF+3     ; length of parm block
  396                      	
  397   0000               		END
  398                      	
  399   0000               		INCLUDE 	APPLE.EQU
  400   0000               		STTL "--- APPLE ][ HARDWARE STUFF ---"
  401                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page    8

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- APPLE ][ HARDWARE STUFF ---"

  402                      	; -------------------
  403                      	; APPLE II MEMORY MAP
  404                      	; -------------------
  405          0001        	AUX	EQU	1	; offset to Auxillary mem switches
  406          0000        	MAIN	EQU	0	; for main memory switches
  407                      	
  408                      	;
  409                      	; some hardware spots
  410                      	;
  411          2000        	SCREEN	EQU	$2000		; START OF Double HiRes SCREEN RAM
  412                      	
  413          BF00        	PRGLBL	EQU	$BF00		; ProDOS Globals page in main mem
  414          BF58        	PR_BITMAP EQU	$BF58		; ProDOS system bitmap
  415          BFFF        	KVERSION EQU    $BFFF           ; ProDOS version (== $FF if InfoDOS)
  416          00FF        	INFODOS_ID EQU  $FF
  417                      	
  418          C000        	IOADDR	EQU	$C000		; start of I/O registers
  419          D000        	PROADR	EQU	$D000		; start of ProDOS
  420                      	
  421          0200        	LBUFF	EQU	$0200		; LINE INPUT BUFFER
  422          0273        	PIC1BUF EQU	$0300-141	; we can use line buffer for one picture buffer
  423          0280        	SCRBUFF	EQU	LBUFF+$80	; screen line buffer
  424          2000        	BORG	EQU	$2000		; ORIGIN OF .SYSTEM CODE 
  425                      	;
  426                      	; some page 3 storage relocated stuff
  427                      	;
  428          0300        	PAGE3STUFF EQU	$300
  429          0300        	MOUSER	EQU	PAGE3STUFF	; this is where mouse subroutine goes
  430          0312        	COLORS	EQU	MOUSER+$12
  431          0352        	XPOSTBL	EQU	COLORS+$40
  432                      	
  433          0400        	SV_PCL	EQU	$400		; for scrolling data
  434          0600        	SV_PCH	EQU	$600
  435                      	
  436          0800        	IOBUFF	EQU	$0800		; 1Kb DATA BUFFER BUFFER
  437                      	
  438          0C00        	PAGING_MEM EQU	IOBUFF+$400	; Paging table stuff
  439          0C00        	NEXTPNT	EQU	PAGING_MEM
  440          0C40        	PREVPNT	EQU	NEXTPNT+$40	
  441          0C80        	VPAGEH	EQU	PREVPNT+$40	
  442          0CC0        	VPAGEL	EQU	VPAGEH+$40	
  443          0200        	PAGELEN	EQU	$200		; length of paged read
  444                      	
  445          0D00        	ZSTKBL	EQU	PAGING_MEM+$100	; Z-STACK  BOTTOM,LO  (1K STACK FOR EZIP)
  446          0E00        	ZSTKTL	EQU	ZSTKBL+$100	; TOP, LO
  447          0F00        	ZSTKBH	EQU	ZSTKBL+$200	; BOTTOM, HI
  448          1000        	ZSTKTH	EQU	ZSTKBL+$300	; TOP, HI
  449                      	;
  450                      	; now define some file i/o buffers and such
  451                      	;
  452          1100        	GAME1FIO EQU	ZSTKBL+$400	; Game file I/O buffer
  453          1500        	GAME2FIO EQU	GAME1FIO+$400	; Second game file i/o buffer
  454          1900        	SEGTBL	EQU	GAME2FIO+$400	; segment table for multi disks
  455          1C74        	PIC2BUF	EQU	SEGTBL+($400-140) ; picture buffer is 140 bytes long
  456          1D00        	TCHARTBL EQU	SEGTBL+$400	; 208 bytes for (possible) terminating
  457          1D50        	COPY_LINE EQU   TCHARTBL+$50    ; copy line in screen memory
  458          1D7C        	CPY_MOD1_SRC equ   COPY_LINE+$2C   ; special self-modifying places
  459          1D7F        	CPY_MOD1_DST equ CPY_MOD1_SRC+3
  460          1DA0        	CPY_MOD2_SRC equ   COPY_LINE+$50
  461          1DA3        	CPY_MOD2_DST equ CPY_MOD2_SRC+3
  462                      	
  463          1DD0        	DSKSEG	EQU	TCHARTBL+$D0	; spot to stash pointers for disk segments
  464          1DD0        	D1SEG	EQU	DSKSEG		; where in SEGTBL for Disk 1
  465          1DD2        	D2SEG	EQU	D1SEG+2
  466          1DD4        	D3SEG	EQU	D2SEG+2
  467          1DD6        	D4SEG	EQU	D3SEG+2
  468          1DD8        	D5SEG	EQU	D4SEG+2
  469          1DDA        	D6SEG	EQU	D5SEG+2
  470          1DDC        	D7SEG	EQU	D6SEG+2
  471          1DDE        	D8SEG	EQU	D7SEG+2
  472          1DE0        	LOCAL_SV EQU	TCHARTBL+$E0	; to save locals before restore
  473          1E00        	LOCALS	EQU	TCHARTBL+$100	; LOCAL VARIABLE STORAGE (30 BYTES)
  474          1E20        	BUFSAV	EQU	LOCALS+$20	; TEMP SPACE FOR SAVE/RESTORE (80 BYTES)
  475          1F00        	SCR_LINE EQU	LOCALS+$100	; place to build displayed line
  476          1F8C        	CHARSET EQU     SCR_LINE+140    ; spot for charset to go
  Wed May 24 1989 15:00                                                                                                  Page    9

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- APPLE ][ HARDWARE STUFF ---"

  477                      	;
  478                      	; now for some interpreter data
  479                      	;
  480          4000        	INTR_BEGIN EQU	$4000		; START OF Interpreter CODE in main
  481          5600        	INTR_SIZE EQU	(43*512)	; size of interpreter
  482                      	
  483          9600        	ZBEGIN	EQU	(INTR_BEGIN+INTR_SIZE) ; start of Z code
  484          7F00        	MMSIZE	EQU	PRGLBL-INTR_BEGIN ; free memory in main bank
  485          0029        	Z1SIZE	EQU	>(PRGLBL-ZBEGIN) ; size of preload, part 1
  486                      	;
  487                      	; this is in Bank 2, Main mem
  488                      	;
  489                      	;
  490                      	; Picture directory goes in Bank 2, Aux mem
  491                      	;
  492          D000        	PIC_DIR	EQU	$D000		; picture local directory
  493          DC00        	GBL_DIR EQU     $DC00           ; global directory
  494                      	;
  495                      	; some special markers if we are using InfoDOS
  496                      	;
  497          0000        	SP_BANK EQU     MAIN
  498          D000        	SP_START EQU    $D000           ; start of special area
  499          0017        	SP_SIZE EQU     ((($FE->SP_START)*256)/512)     ; how many pages
  500                      	;SP_SIZE EQU     (((>SCREEN->SP_START)*256)/512)     ; how many pages
  501                      	
  502          0001        	PB_BANK EQU     AUX          ; paging buffers in which bank
  503          0800        	PBEGIN	EQU	$0800		; start of paging buffers
  504          0018        	NUMBUFS	EQU	>(SCREEN-PBEGIN) ; how many 256k paging buffers
  505                      	;NUMBUFS	EQU	>($100-PBEGIN) ; how many 256k paging buffers
  506                      	
  507          0029        	P2PAGE	EQU	>(PRGLBL-ZBEGIN) ; first page of zcode in aux bank
  508          4000        	Z2BEGIN	EQU	$4000		; start of part 2 in aux mem
  509                      					; just after the dhires screen
  510          0040        	Z2PAGE	EQU	>Z2BEGIN	; get me just the page address
  511          007F        	Z2SIZE	EQU	>(PRGLBL-Z2BEGIN) ; size of preload, part 2
  512          00A8        	P3PAGE	EQU	Z1SIZE+Z2SIZE	; first page in aux mem part 3
  513          D000        	Z3BEGIN	EQU	$D000		; start of 3 part in aux mem
  514          00D0        	Z3PAGE	EQU	>Z3BEGIN	; get me page number too
  515          002E        	Z3SIZE	EQU	<($FE-Z3PAGE)	; size of part 3, in pages
  516                      	
  517                      	;
  518                      	; other numba's
  519                      	;
  520          00D6        	PGBEGIN	EQU	(P3PAGE+Z3SIZE)	; first paged page
  521          00D6        	PRESIZE EQU	(Z1SIZE+Z2SIZE+Z3SIZE)	; size of preload, # pages
  522          2000        	SCRSZE	EQU	INTR_BEGIN-SCREEN ; size of Double HiRes screen (8k, each bank)
  523          EE00        	RAMDSK	EQU	(119*512)	; size of RAM disk in aux mem
  524          B500        	RAMSAVE	EQU	$B500		; save this much to cover HiRes screen in
  525                      					; aux and the rest of the preload, up to
  526                      					; PRGLBL ($bf00)
  527          3900        	FREERAM	EQU	RAMDSK-RAMSAVE	; size of Free RAM after 'saving' 
  528                      					; special AUX memory
  529          2200        	DSKSZE	EQU	(512*273)	; size of ProDOS data disk file
  530                      	
  531                      	; ---------
  532                      	; CONSTANTS
  533                      	; ---------
  534                      	
  535          0002        	IIeID	EQU	2	; Apple ][e Yzip
  536          0009        	IIcID	EQU	9	; ][c Yzip
  537          000A        	IIgsID	EQU 	10	; ][gs Yzip
  538                      	
  539          00FF        	P3BANK	EQU	$FF	; show upper aux mem
  540          0000        	LO	EQU	0	
  541          0001        	HI	EQU	1	
  542          0002        	ABANK	EQU	2	; for address variables
  543                      	
  544          0000        	OFF	EQU	0	; for toggling soft-switches
  545          0001        	ON	EQU	1
  546                      	
  547          0003        	RETRY_COUNT EQU 3       ; how many retries before message
  548                      	
  549          0009        	TAB     EQU     $09     ; Tab char
  550          000B        	EOS     EQU     $0B     ; End of Sentence
  551          000D        	EOL	EQU	$0D	; EOL CHAR
  Wed May 24 1989 15:00                                                                                                  Page   10

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- APPLE ][ HARDWARE STUFF ---"

  552          000A        	LF	EQU	$0A	; LINE FEED
  553          0020        	SPACE	EQU	$20	; SPACE CHAR
  554          0008        	BACKSPACE EQU	$08	; BACKSPACE CHAR
  555          001B        	ESCAPE	EQU	$1B	; ESCAPE Key
  556          003F        	VOLCHAR EQU	'?'	; Key to hit for ONLINE command
  557                      	;
  558                      	; Screen Defs
  559                      	;
  560          008C        	MAXWIDTH EQU	140	; 560 / 4 = max "pixels"
  561          0230        	REAL_MAXW EQU	MAXWIDTH*4
  562          00C0        	MAXHEIGHT EQU	192	; 192 screen lines
  563          0002        	FONT_W	EQU	2	; font width (for game, anyway)
  564          0009        	FONT_H	EQU	9	; font height
  565          0003        	MFONT_W	EQU	3	; mono spaced font width, to game
  566          000C        	MONOFONT_W EQU	MFONT_W*4	; how wide the mono font really is
  567                      	
  568          0008        	SPACE_WIDTH EQU	8	; default space width
  569          0003        	BLINK_RATE EQU	3	; tenths of seconds between blinks
  570                      	
  571          001C        	OUTER_DELAY EQU	$1C	; outside delay loop counter
  572          0003        	INNER_DELAY EQU	3	; inner delay loop
  573                      	
  574          0072        	GS_OUTER_DELAY EQU $72	; ][gs outside counter
  575          0002        	GS_INNER_DELAY EQU 2	; ][gs inside counter
  576                      	
  577                      	; ----------------------
  578                      	; BOOT ZERO PAGE EQUATES
  579                      	; ----------------------
  580                      	
  581          0026        	BADDR	EQU	$26	; (WORD) ROM BOOT ADDRESS
  582          002B        	BSLOT	EQU	$2B	; (BYTE) ROM BOOT SLOT
  583                      	
  584          0280        	START_NAME EQU     $280    ; name upon boot is stored here
  585                      	; ----------------
  586                      	; HARDWARE EQUATES
  587                      	; ----------------
  588                      	
  589          C000        	KBD	EQU	$C000	; KEY STROBE
  590          C000        	STORE80 EQU	$C000	; video aux mem switch
  591          C002        	RDBNK	EQU	$C002	; READ MAIN MEMORY (+MAIN, +AUX)
  592          C004        	WRTBNK	EQU	$C004	; WRITE MAIN 48K OF MEMORY (+MAIN, +AUX)
  593          C008        	ALTZP	EQU	$C008	; R/W MAIN (C009 = AUX) >MEM
  594          C00C        	COL80SW	EQU	$C00C	; 80 Column switch
  595          C010        	ANYKEY 	EQU	$C010	; ANY KEY DOWN FLAG
  596          C019        	VERTBLNK EQU	$C019	; Vertical Blanking Flag
  597          C029        	IIGSVID EQU     $C029   ; GS MEGA ][ video register
  598          C030        	SPKR	EQU	$C030	; SPEAKER FLAG (MAKE A NOISE)
  599          C035        	IIGSSHD EQU     $C035   ; ][GS shadowing reg
  600          C050        	TEXTSW	EQU	$C050	; Graphics Switch
  601          C052        	MIXEDSW EQU	$C052	; Mixed Text/Graphics
  602          C054        	PAGE2SW EQU	$C054	; Page select
  603          C056        	HIRESSW	EQU	$C056	; Select HiRes
  604          C05E        	DHIRESW	EQU	$C05E	; Double HiRes switch (backwards: +0 on +1 off)
  605          C07E        	IOUDIS	EQU	$C07E	; Double HiRes Switch enabler (same backass way)
  606          C083        	BNK2SET	EQU	$C083	;READ/READ      READ RAM WRITE RAM BANK 2
  607          C08B        	BNK1SET	EQU	$C08B	;READ/READ      READ RAM WRITE RAM BANK 1
  608          C082        	RDROM	EQU	$C082	; READ READ ROM NO WRITE
  609          C088        	RDBNK1	EQU	$C088	; READ ram, bank 1
  610          C080        	RDBNK2	EQU	$C080	; Read ram, bank 2
  611                      	
  612                      	; -----------------
  613                      	; MONITOR VARIABLES
  614                      	; -----------------
  615                      	
  616          0036        	CSW	EQU	$36	; CHARACTER OUTPUT VECTOR (for scripting)
  617          C061        	APKEY1	EQU	$C061	; open apple key flag
  618          C062        	APKEY2	EQU	$C062	; closed apple key flag
  619                      	
  620          0002        	CURSW	EQU	2		; width of cursor
  621          0004        	CURSH	EQU	4		; height of cursor
  622                      	; -----------
  623                      	; MOUSE STUFF
  624                      	; -----------
  625          C412        	MTABLE	EQU	$C412	; Mouse ROM table
  626          0310        	MSVECTOR EQU	MOUSER+16	; where vector is stored
  Wed May 24 1989 15:00                                                                                                  Page   11

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- APPLE ][ HARDWARE STUFF ---"

  627          0312        	MSMOVEF	EQU	MSVECTOR+2	; Mouse moved flag
  628          0313        	MSBTNF	EQU	MSMOVEF+1	; Mouse button flag
  629                      	;
  630                      	; MOUSE screen holes
  631                      	;
  632          0478        	CLMPMINL EQU	$478		; lo part of clamping min
  633          0578        	CLMPMINH EQU	$578		; hi part of    "      "
  634          04F8        	CLMPMAXL EQU	$4F8		; lo part of clamping max
  635          05F8        	CLMPMAXH EQU	$5F8		; hi part of    "      "
  636          0478        	MOUSEXL	EQU	$478		; lo part of mouse X
  637          0578        	MOUSEXH	EQU	$578		; hi part of mouse X
  638          04F8        	MOUSEYL	EQU	$4F8		; lo part of mouse Y
  639          05F8        	MOUSEYH	EQU	$5F8		; hi part of mouse Y
  640          0778        	MOUSEST	EQU	$778		; status byte
  641                      	;
  642                      	; some mouse constants
  643                      	;
  644          0081        	SGL_CLK	EQU	$81	; single click char
  645          0082        	DBL_CLK	EQU	$82	; double click char
  646          0006        	CLK_CNT	EQU	6	; counts between single and double click
  647                      	; Subroutine offsets
  648          0000        	SETM	EQU	0
  649          0001        	SERVEM	EQU	1
  650          0002        	READM	EQU	2
  651          0003        	CLEARM	EQU	3
  652          0004        	POSM	EQU	4
  653          0005        	CLAMPM	EQU	5
  654          0006        	HOMEM	EQU	6
  655          0007        	INITM	EQU	7
  656                      	
  657                      	; --------------
  658                      	; PRODOS GLOBALS
  659                      	; --------------
  660          BF90        	PRODATE	EQU	$BF90	; date and
  661          BF92        	PROTIME	EQU	$BF92	; time
  662          BF98        	MACHID	EQU	$BF98	; machine id
  663                      	
  664                      	; ----------------
  665                      	; MONITOR ROUTINES
  666                      	; ----------------
  667          FB1E        	MPREAD	EQU	$FB1E	; Read for joystick control
  668          FC22        	MBASCAL	EQU	$FC22	; CALC LINE BASE ADDRESS
  669          FF3A        	MBELL	EQU	$FF3A	; MAKE A NOISE
  670          FFFC        	RESET_VECTOR EQU $FFFC  ; force warm reboot
  671          FC9C        	MCLEOL	EQU	$FC9C	; CLEAR TO END OF LINE
  672          FC42        	MCLEOS	EQU	$FC42	; CLEAR TO END OF SCREEN
  673          FC58        	MHOME	EQU	$FC58	; CLEAR SCREEN/HOME CURSOR
  674          FDED        	MCOUT	EQU	$FDED	; CHAR OUTPUT
  675          FDF0        	MCOUT1	EQU	$FDF0	; CHAR OUTPUT TO SCREEN
  676          FD0C        	MRDKEY	EQU	$FD0C	; READ KEY
  677          FD6F        	MGETLN1	EQU	$FD6F	; GET LINE
  678          FCA8        	MWAIT	EQU	$FCA8	; WASTE SO MUCH TIME
  679                      	;
  680                      	; Some /RAM spots
  681                      	;
  682          BF26        	RAMVEC	EQU	$BF26	; /RAM drive vector
  683          077E        	OLDVEC	EQU	$77E	; spot to save the drive vector
  684          BF16        	UNSVEC	EQU	$BF16	; "Uninstalled Device" vector
  685          BF31        	DEVCNT	EQU	$BF31	; Device count
  686          BF32        	DEVNUM	EQU	$BF32	; Device list
  687                      	
  688                      	;
  689                      	; machine info spots
  690                      	;
  691          FBB3        	MACHID1	EQU	$FBB3	; first part
  692          FBC0        	MACHID2	EQU	$FBC0	; second part
  693          FE1F        	MACHCHK	EQU	$FE1F	; differentiate between ][e and gs
  694                      				; do sec, then jsr, and if still set, = ][e
  695   0000               		END
  696                      	
  697   0000               		INCLUDE		MACROS.ASM
  698   0000               		STTL	"--- MACROS ---"
  699                      		PAGE 
  Wed May 24 1989 15:00                                                                                                  Page   12

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- MACROS ---"

  700                      	
  701                      	;
  702                      	; MACROS for Apple ][ Yzip
  703                      	;
  704                      	DLINE:	.MACRO	STRING,SLEN
  705                      		ldx	#<STRING	; get part of STRING
  706                      		lda	#>STRING	; get other part of string
  707                      		IFMA	2		; check to see if length passed in
  708                      		ldy	SLEN		; then just fetch it
  709                      		ELSE
  710                      		ldy	#STRING|L	; get length of string
  711                      		ENDIF
  712                      		jsr	DLINE		; print the string
  713                      		.MACEND
  714                      	;
  715                      	; ProDOS macros
  716                      	;
  717                      	PRODOS:	.MACRO	CODE, PADDR
  718                      		jsr	$BF00	; ProDOS handler
  719                      		DB	CODE	; ProDOS function code
  720                      		DW	PADDR	; Function Parameter Block address
  721                      		.MACEND
  722                      	
  723                      	QUIT:	.MACRO	PBLOCK
  724                      		PRODOS 	$65, PBLOCK
  725                      		.MACEND
  726                      	
  727                      	READ_BLOCK: .MACRO PBLOCK
  728                      		PRODOS	$80, PBLOCK
  729                      		.MACEND
  730                      	
  731                      	WRITE_BLOCK: .MACRO PBLOCK
  732                      		PRODOS	$81, PBLOCK
  733                      		.MACEND
  734                      	
  735                      	GET_TIME: .MACRO PBLOCK
  736                      		PRODOS	$82, PBLOCK
  737                      		.MACEND
  738                      	
  739                      	CREATE:	.MACRO	PBLOCK
  740                      		PRODOS	$C0, PBLOCK
  741                      		.MACEND
  742                      	
  743                      	DESTROY: .MACRO	PBLOCK
  744                      		PRODOS	$C1, PBLOCK
  745                      		.MACEND
  746                      	
  747                      	RENAME: .MACRO PBLOCK
  748                      		PRODOS	$C2, PBLOCK
  749                      		.MACEND
  750                      	
  751                      	SET_FILE_INFO: .MACRO PBLOCK
  752                      		PRODOS	$C3, PBLOCK
  753                      		.MACEND
  754                      	
  755                      	GET_FILE_INFO: .MACRO PBLOCK
  756                      		PRODOS	$C4, PBLOCK
  757                      		.MACEND
  758                      	
  759                      	ONLINE: .MACRO PBLOCK
  760                      		PRODOS	$C5, PBLOCK
  761                      		.MACEND
  762                      	
  763                      	SET_PREFIX: .MACRO PBLOCK
  764                      		PRODOS	$C6, PBLOCK
  765                      		.MACEND
  766                      	
  767                      	GET_PREFIX: .MACRO PBLOCK
  768                      		PRODOS	$C7, PBLOCK
  769                      		.MACEND
  770                      	
  771                      	OPEN: .MACRO PBLOCK
  772                      		PRODOS	$C8, PBLOCK
  773                      		.MACEND
  774                      	
  Wed May 24 1989 15:00                                                                                                  Page   13

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- MACROS ---"

  775                      	NEWLINE: .MACRO PBLOCK
  776                      		PRODOS	$C9, PBLOCK
  777                      		.MACEND
  778                      	
  779                      	READ: .MACRO PBLOCK
  780                      		PRODOS	$CA, PBLOCK
  781                      		.MACEND
  782                      	
  783                      	WRITE: .MACRO PBLOCK
  784                      		PRODOS	$CB, PBLOCK
  785                      		.MACEND
  786                      	
  787                      	CLOSE: .MACRO PBLOCK
  788                      		PRODOS	$CC, PBLOCK
  789                      		.MACEND
  790                      	
  791                      	FLUSH: .MACRO PBLOCK
  792                      		PRODOS	$CD, PBLOCK
  793                      		.MACEND
  794                      	
  795                      	SET_MARK: .MACRO PBLOCK
  796                      		PRODOS	$CE, PBLOCK
  797                      		.MACEND
  798                      	
  799                      	GET_MARK: .MACRO PBLOCK
  800                      		PRODOS	$CF, PBLOCK
  801                      		.MACEND
  802                      	
  803                      	SET_EOF: .MACRO PBLOCK
  804                      		PRODOS	$D0, PBLOCK
  805                      		.MACEND
  806                      	
  807                      	SET_BUF: .MACRO PBLOCK
  808                      		PRODOS	$D1, PBLOCK
  809                      		.MACEND
  810                      	
  811                      	GET_BUF: .MACRO PBLOCK
  812                      		PRODOS	$D2, PBLOCK
  813                      		.MACEND
  814                      	
  815   0000               		END
  816                      	
  817                      	
  818   0000               		TITLE 	"APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
  819   0000               		INCLUDE		ZBEGIN.ASM
  820   0000               		STTL "--- START OF APPLE ][ INTERPRETER ---"
  821                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page   14

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- START OF APPLE ][ INTERPRETER ---"

  822                      	
  823   4000               		ORG	INTR_BEGIN
  824                      	;
  825                      	; Set up for Double HiRes full screen graphics
  826                      	;	
  827   4000   AD 54 C0    		lda	PAGE2SW+OFF	; turn off page 2
  828   4003   8D 50 C0    		sta	TEXTSW+OFF	; turn off text - turn on graphics
  829   4006   8D 57 C0    		sta	HIRESSW+ON	; turn on high resolution
  830   4009   8D 52 C0    		sta	MIXEDSW+OFF	; full screen graphics
  831   400C   8D 0D C0    		sta	COL80SW+ON	; turn on 80 column
  832   400F   8D 7E C0    		sta	IOUDIS+OFF	; turn ON (it too is backwards) Dhires switch
  833   4012   8D 5E C0    		sta	DHIRESW+OFF	; turn ON (it's backwards!) Dhires
  834                      	
  835   4015   8D 01 C0    		sta	STORE80+ON	; turn on aux page display ability
  836   4018   AD 83 C0    	        lda     BNK2SET         ; read/write RAM, bank 2
  837   401B   AD 83 C0    	        lda     BNK2SET
  838                      	;
  839                      	; copy in progame from boot code
  840                      	;
  841   401E   A2 00       		ldx	#0		; start at first letter
  842   4020               	MVPRE:
  843   4020   BD 03 20    		lda	BORG+3,X	; get letter
  844   4023   F0 0C       		beq	MVPREX		; all done
  845   4025   9D 78 46    		sta	GAME1NAME,X	; save letter
  846   4028   9D 8A 46    		sta	GAME2NAME,X	; save letter
  847   402B   9D 68 46    		sta	GAME,X		; save for asking about later
  848   402E   E8          		inx			; next letter
  849   402F   D0 EF       		bne	MVPRE		; do gen
  850   4031               	MVPREX:
  851   4031   8E 67 46    		stx	GAMEL		; save length of game name
  852   4034   A9 2E       		lda	#'.'		; get extension for names
  853   4036   9D 78 46    		sta	GAME1NAME,X	; save letter
  854   4039   9D 8A 46    		sta	GAME2NAME,X	; save letter
  855   403C   E8          		inx			; next letter
  856   403D   A9 44       		lda	#'D'		; for data segments
  857   403F   9D 78 46    		sta	GAME1NAME,X	; save letter
  858   4042   9D 8A 46    		sta	GAME2NAME,X	; save letter
  859   4045   E8          		inx			; points to number
  860   4046   E8          		inx			; inclusive count for length
  861   4047   8E 77 46    		stx	GAME1NML	; save length of name
  862   404A   8E 89 46    		stx	GAME2NML	; save length of name
  863                      	
  864   404D   A9 09       		lda	#VERSID		; put in version number
  865   404F   8D 1F 96    		sta	ZBEGIN+ZINTWD+1	
  866                      	
  867   4052   E6 AF       		inc	ZSP+LO		; INIT Z-STACK POINTERS
  868   4054   EE 75 6C    		inc	OLDZSP+LO	; TO "1"
  869   4057   E6 B1       		inc	SCREENF		; TURN DISPLAY ON
  870   4059   E6 AA       		inc	SCRIPT		; enable scripting
  871   405B   EE A3 6C    	        inc     CRLF_CHECK      ; do CR functino check
  872                      	
  873   405E   AD 47 6E    		lda	WINTABLE+LO	; set WINDOW to point to window 0
  874   4061   85 05       		sta	WINDOW+LO
  875   4063   AD 48 6E    		lda	WINTABLE+HI
  876   4066   85 06       		sta	WINDOW+HI	; okay, it does
  877                      	
  878   4068   A5 63       		lda	ARG1+LO		; using mouse?
  879   406A   F0 12       		beq	ZBEGIN1		; nope
  880   406C   09 78       		ora	#$78		; point to correct screen holes
  881   406E   8D 50 50    		sta	MSFIX0+1
  882   4071   8D 5B 50    		sta	MSFIX1+1	; and modify code to point to correct spot
  883   4074   8D 60 50    		sta	MSFIX2+1
  884   4077   A5 63       		lda	ARG1+LO
  885   4079   09 F8       		ora	#$F8		; and one more
  886   407B   8D 60 50    		sta	MSFIX2+1
  887   407E               	ZBEGIN1:
  888   407E   A9 FF       		lda	#$FF		; do a clear -1 to start off
  889   4080   85 63       		sta	ARG1+LO		; so arg 1 is this
  890   4082   20 A8 57    		jsr	ZCLR		; doing it
  891                      	
  892   4085               		GET_PREFIX GPRE_PB	; get where we are to start
  893   4085               		PRODOS	$C7, GPRE_PB
  894   4085   20 00 BF    		jsr	$BF00	; ProDOS handler
  895   4088   C7          		DB	$C7	; ProDOS function code
  896   4089   6446        		DW	GPRE_PB	; Function Parameter Block address
  Wed May 24 1989 15:00                                                                                                  Page   15

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- START OF APPLE ][ INTERPRETER ---"

  897   408B               		.MACEND
  898   408B               		.MACEND
  899                      	
  900   408B   AD D3 1D    		lda	D2SEG+HI	; start DSEGS at .D2
  901   408E   85 1F       		sta	DSEGS+HI
  902   4090   AD D2 1D    		lda	D2SEG+LO
  903   4093   85 1E       		sta	DSEGS+LO
  904                      	
  905   4095   A9 01       		lda	#1		; open game file .D2 please
  906   4097   20 C6 49    		jsr	FETCH_FILE	; we did that
  907   409A   A5 59       	        lda     INFODOS         ; are we on little dos?
  908   409C   F0 03       	        beq     ZBEGIN2         ; nope
  909   409E   20 F1 4B    	        jsr     GET_SPECIAL     ; do special preloading if so
  910   40A1               	ZBEGIN2:
  911   40A1   AD D5 1D    		lda	D3SEG+HI	; this is cuz we be openin' .D3
  912   40A4   85 1F       		sta	DSEGS+HI
  913   40A6   AD D4 1D    		lda	D3SEG+LO
  914   40A9   85 1E       		sta	DSEGS+LO
  915   40AB   A9 02       		lda	#2		; and just for giggles, do the
  916   40AD   20 C6 49    		jsr	FETCH_FILE	; same for game file .D3
  917                      	
  918   40B0   20 AA 90    		jsr	VLDZPC		; MAKE ZPC VALID
  919   40B3   20 1F 92    		jsr	NEXTPC		; skip over # of locals
  920                      	
  921                      		; ... AND FALL INTO MAIN LOOP
  922                      	
  923   40B6               		END
  924                      	
  925   40B6               		INCLUDE 	MAIN.ASM
  926   40B6               		STTL "--- MAIN LOOP ---"
  927                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page   16

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

  928                      	
  929          9600        	MD_ADDR EQU	ZBEGIN
  930          0001        	MDEBUG 	EQU	1
  931                      	
  932   40B6               	MLOOP:
  933          [01]        		IF 	MDEBUG
  934   40B6   AD 00 96    		lda	MD_ADDR	; get interesting address
  935   40B9   D0 01       		bne	MLOOPx	; just fine, thank you
  936   40BB   00          		brk		; then die
  937   40BC               	MLOOPx:
  938          [00]        		ENDIF
  939                      	
  940   40BC   A9 00       		lda	#0	
  941   40BE   85 62       		sta	NARGS		; reset number of args
  942   40C0   AD 54 C0    		lda	PAGE2SW+OFF	; just do this for the heck of it
  943   40C3   AD 83 C0    	        lda     BNK2SET
  944   40C6   AD 83 C0    	        lda     BNK2SET
  945   40C9   8D 01 C0    		sta	STORE80+ON	; must always be on
  946                      	
  947   40CC   20 1F 92    		jsr	NEXTPC	; get op code
  948   40CF   85 61       		sta	OPCODE	; SAVE IT HERE
  949                      	
  950          [01]        		IF	MDEBUG
  951                      	;
  952                      	; special debugging code
  953                      	;
  954   40D1   AC 01 41    		ldy	SPCSV
  955   40D4   A5 61       		lda	OPCODE
  956   40D6   99 10 41    		sta	SAVEOP,Y
  957   40D9   A5 82       		lda	ZPCH
  958   40DB   99 20 41    		sta	SAVEZH,Y
  959   40DE   A5 81       		lda	ZPCM
  960   40E0   99 30 41    		sta	SAVEZM,Y
  961   40E3   A5 80       		lda	ZPCL
  962   40E5   99 40 41    		sta	SAVEZL,Y
  963   40E8   A5 85       		lda	ZPCBNK
  964   40EA   99 50 41    		sta	SAVEZB,Y
  965   40ED   A5 84       		lda	ZPCPNT+HI
  966   40EF   99 60 41    		sta	SAVEZP,Y
  967   40F2   AC 01 41    		ldy	SPCSV
  968   40F5   C8          		iny
  969   40F6   98          		tya
  970   40F7   29 0F       		and	#$0F
  971   40F9   8D 01 41    		sta	SPCSV	
  972   40FC   A5 61       		lda	OPCODE
  973   40FE   4C 70 41    		jmp	MAINDB
  974   4101   00          	SPCSV:	db	0
  975   4111               		ORG	$+15
  976   0411               		ORG	$.SHR.4
  977   4110               		ORG	$.SHL.4
  978   4110               	SAVEOP: ds 16
  979   4120               	SAVEZH:	ds 16
  980   4130               	SAVEZM: ds 16
  981   4140               	SAVEZL: ds 16
  982   4150               	SAVEZB: ds 16
  983   4160               	SAVEZP: ds 16		      
  984   4170               	MAINDB:
  985          [00]        		ENDIF
  986                      	;
  987                      	; DECODE AN OPCODE
  988                      	;
  989   4170   A8          		tay		; set flags
  990   4171   30 03       		bmi	DC0	; IF POSITIVE,
  991   4173   4C CD 42    		jmp	OP2	; IT'S A 2-OP
  992   4176   C9 B0       	DC0:	cmp	#$B0	
  993   4178   B0 03       		bcs	DC1	
  994   417A   4C 90 42    		jmp	OP1	; OR MAYBE A 1-OP
  995   417D   C9 C0       	DC1:	cmp	#$C0	
  996   417F   B0 03       		bcs	OPEXT	
  997   4181   4C 6A 42    		jmp	OP0	; PERHAPS A 0-OP
  998                      	
  999                      	; --------------
 1000                      	; HANDLE AN X-OP
 1001                      	; --------------
 1002                      	
  Wed May 24 1989 15:00                                                                                                  Page   17

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

 1003   4184   C9 EC       	OPEXT:	CMP	#236		; XCALL?
 1004   4186   D0 03       		BNE	OPX5
 1005   4188   4C 15 42    		JMP	OPXCLL		; YES, PROCESS SEPARATELY
 1006   418B   C9 FA       	OPX5:	CMP	#250		; IXCALL
 1007   418D   D0 03       		BNE	OPX6
 1008   418F   4C 15 42    		JMP	OPXCLL
 1009   4192   20 1F 92    	OPX6:	JSR	NEXTPC		; GRAB THE ARGUMENT ID BYTE
 1010   4195   85 73       		STA	ABYTE		; HOLD IT HERE
 1011   4197   A2 00       		LDX	#0
 1012   4199   86 75       		STX	ADEX		; INIT ARGUMENT INDEX
 1013   419B   F0 06       		BEQ	OPX1		; JUMP TO TOP OF LOOP
 1014   419D   A5 73       	OPX0:	LDA	ABYTE		; GET ARG BYTE
 1015   419F   0A          		ASL	A		; SHIFT NEXT 2 ARG BITS
 1016   41A0   0A          		ASL	A		; INTO BITS 7 & 6
 1017   41A1   85 73       		STA	ABYTE		; HOLD FOR LATER
 1018   41A3   29 C0       	OPX1:	AND	#%11000000	; MASK OUT GARBAGE BITS
 1019   41A5   D0 06       		BNE	OPX2
 1020   41A7   20 2B 43    		JSR	GETLNG		; 00 = LONG IMMEDIATE
 1021   41AA   4C BE 41    		JMP	OPXNXT
 1022   41AD   C9 40       	OPX2:	CMP	#%01000000	; IS IT A SHORT IMMEDIATE?
 1023   41AF   D0 06       		BNE	OPX3		; NO, KEEP GUESSING
 1024   41B1   20 27 43    		JSR	GETSHT		; 01 = SHORT IMMEDIATE
 1025   41B4   4C BE 41    		JMP	OPXNXT
 1026   41B7   C9 80       	OPX3:	CMP	#%10000000	; LAST TEST
 1027   41B9   D0 17       		BNE	OPX4		; 11 = NO MORE ARGUMENTS
 1028   41BB   20 3F 43    		JSR	GETVAR		; 10 = VARIABLE
 1029   41BE   A6 75       	OPXNXT:	LDX	ADEX		; RETRIEVE ARGUMENT INDEX
 1030   41C0   A5 76       		LDA	VALUE+LO	; GRAB LSB OF VALUE
 1031   41C2   95 63       		STA	ARG1+LO,X	; STORE IN ARGUMENT TABLE
 1032   41C4   A5 77       		LDA	VALUE+HI	; GRAB MSB OF VALUE
 1033   41C6   95 64       		STA	ARG1+HI,X	; STORE THAT, TOO
 1034   41C8   E6 62       		INC	NARGS		; UPDATE ARGUMENT COUNTER
 1035   41CA   E8          		INX
 1036   41CB   E8          		INX
 1037   41CC   86 75       		STX	ADEX		; UPDATE INDEX
 1038   41CE   E0 08       		CPX	#8		; DONE 4 ARGUMENTS YET?
 1039   41D0   90 CB       		BCC	OPX0		; NO, GET SOME MORE
 1040                      	
 1041                      		; ALL X-OP ARGUMENTS READY
 1042                      	
 1043   41D2   A5 61       	OPX4:	LDA	OPCODE		; IS THIS
 1044   41D4   C9 E0       		CMP	#$E0		; AN EXTENDED 2-OP?
 1045   41D6   B0 07       		BCS	DOXOP		; NO, IT'S A REAL X-OP
 1046   41D8   C9 C0       		CMP	#$C0		; IS IT NEW OPCODE RANGE?
 1047   41DA   90 18       		BCC	ZEXTOP		; YES
 1048   41DC   4C 00 43    		JMP	OP2EX		; ELSE TREAT IT LIKE A 2-OP
 1049                      	
 1050   41DF   29 1F       	DOXOP:	AND	#%00011111	; ISOLATE ID BITS
 1051   41E1   A8          		TAY
 1052   41E2   B9 74 45    		LDA	OPTXL,Y
 1053   41E5   8D EF 41    		STA	GOX+1+LO
 1054   41E8   B9 54 45    		LDA	OPTXH,Y
 1055   41EB   8D F0 41    		STA	GOX+1+HI
 1056   41EE   20 FF FF    	GOX:	JSR	$FFFF		;DUMMY
 1057   41F1   4C B6 40    		JMP	MLOOP
 1058                      	
 1059                      		; HANDLE EXTENDED OPCODE RANGE OPS
 1060                      	
 1061   41F4   C9 1D       	ZEXTOP:	CMP	#EXTLEN		; OUT OF RANGE?
 1062   41F6   B0 18       		BCS	BADEXT
 1063   41F8   A8          		TAY			; OFFSET ALREADY CORRECT
 1064   41F9   B9 B1 45    		LDA	EXTOPL,Y
 1065   41FC   8D 06 42    		STA	GOE+1+LO
 1066   41FF   B9 94 45    		LDA	EXTOPH,Y
 1067   4202   8D 07 42    		STA	GOE+1+HI
 1068   4205   20 FF FF    	GOE:	JSR	$FFFF		;DUMMY
 1069   4208   4C B6 40    		JMP	MLOOP
 1070                      	
 1071                      		; *** ERROR #1 -- ILLEGAL X-OP ***
 1072                      	
 1073   420B   A9 01       	BADOPX:	LDA	#1
 1074   420D   4C 0A 52    		JMP	ZERROR
 1075                      	
 1076                      		; *** ERROR #16 -- ILLEGAL EXTENDED RANGE X-OP ***
 1077                      	
  Wed May 24 1989 15:00                                                                                                  Page   18

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

 1078   4210   A9 10       	BADEXT:	LDA	#16
 1079   4212   4C 0A 52    		JMP	ZERROR
 1080                      	
 1081                      		; HANDLE AN XCALL OPCODE
 1082                      	
 1083   4215   20 1F 92    	OPXCLL:	JSR	NEXTPC	; GET 2 MODE BYTES
 1084   4218   85 73       		STA	ABYTE	
 1085   421A   20 1F 92    		JSR	NEXTPC	
 1086   421D   85 74       		STA	BBYTE	
 1087   421F   A5 73       		LDA	ABYTE	; ONE TO START WITH
 1088   4221   A2 00       		LDX	#0	
 1089   4223   86 75       		STX	ADEX	; INIT ARGUMENT INDEX
 1090   4225   F0 06       		BEQ	XCALL2	; ALWAYS JUMP TO TOP OF LOOP
 1091   4227   A5 73       	XCALL1:	LDA	ABYTE	; GET ARG BYTE
 1092   4229   0A          		ASL	A	; SHIFT NEXT 2 BITS
 1093   422A   0A          		ASL	A	; INTO BITS 7 & 6
 1094   422B   85 73       		STA	ABYTE	; HOLD FOR LATER
 1095   422D   29 C0       	XCALL2:	AND	#%11000000	; MASK OUT GARBAGE
 1096   422F   D0 06       		BNE	XCALL3	
 1097   4231   20 2B 43    		JSR	GETLNG	; 00 = LONG IMMEDIATE
 1098   4234   4C 48 42    		JMP	XCNXT	
 1099   4237   C9 40       	XCALL3:	CMP	#%01000000	; SHORT IMMED?
 1100   4239   D0 06       		BNE	XCALL4	; NO, TRY ANOTHER
 1101   423B   20 27 43    		JSR	GETSHT	; 01 = SHORT IMMED.
 1102   423E   4C 48 42    		JMP	XCNXT	
 1103   4241   C9 80       	XCALL4:	CMP	#%10000000	; LAST TEST
 1104   4243   D0 8D       		BNE	OPX4	; 11 = NO MORE ARGS
 1105   4245   20 3F 43    		JSR	GETVAR	; 10 = VARIABLE
 1106   4248   A6 75       	XCNXT:	LDX	ADEX	
 1107   424A   A5 76       		LDA	VALUE+LO	
 1108   424C   95 63       		STA	ARG1+LO,X	
 1109   424E   A5 77       		LDA	VALUE+HI	
 1110   4250   95 64       		STA	ARG1+HI,X	
 1111   4252   E6 62       		INC	NARGS	
 1112   4254   E8          		INX		
 1113   4255   E8          		INX		
 1114   4256   86 75       		STX	ADEX	
 1115   4258   E0 10       		CPX	#16	
 1116   425A   D0 03       		BNE	XCALL5
 1117   425C   4C D2 41    		JMP	OPX4		; DONE, GO DO IT
 1118   425F   E0 08       	XCALL5:	CPX	#8		; DONE 1ST MODE BYTE?
 1119   4261   D0 C4       		BNE	XCALL1		; NOT QUITE YET
 1120   4263   A5 74       		LDA	BBYTE		; SET UP FOR NEXT
 1121   4265   85 73       		STA	ABYTE		; MODE BYTE
 1122   4267   4C 2D 42    		JMP	XCALL2		; GO DO IT
 1123                      	
 1124                      	; -------------
 1125                      	; HANDLE A 0-OP
 1126                      	; -------------
 1127                      	
 1128   426A   C9 BE       	OP0:	CMP	#190		; IS IT EXTOP OP
 1129   426C   F0 1A       		BEQ	EXTOP		; YES
 1130   426E   29 0F       		AND	#%00001111	; ISOLATE 0-OP ID BITS
 1131   4270   A8          		TAY		
 1132   4271   B9 E4 44    		LDA	OPT0L,Y	
 1133   4274   8D 7E 42    		STA	GO0+1+LO	
 1134   4277   B9 D4 44    		LDA	OPT0H,Y	
 1135   427A   8D 7F 42    		STA	GO0+1+HI	
 1136   427D   20 FF FF    	GO0:	JSR	$FFFF	;DUMMY
 1137   4280   4C B6 40    		JMP	MLOOP	
 1138                      	
 1139                      		; *** ERROR #2 -- ILLEGAL 0-OP ***
 1140                      	
 1141   4283   A9 02       	BADOP0:	LDA	#2	
 1142   4285   4C 0A 52    		JMP	ZERROR	
 1143                      	
 1144                      		; THIS OPCODE TELLS THAT NEXT OP IS PART OF THE
 1145                      		; EXTENDED RANGE OF OPCODES, GET IT AND PROCESS IT
 1146                      		; (THEY ARE ALL XOPS)
 1147                      	
 1148   4288   20 1F 92    	EXTOP:	JSR	NEXTPC		; GO GET EXTENDED RANGE OP
 1149   428B   85 61       		STA	OPCODE		; SAVE IT
 1150   428D   4C 84 41    		JMP	OPEXT		; AND HANDLE IT
 1151                      	
 1152                      	
  Wed May 24 1989 15:00                                                                                                  Page   19

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

 1153                      	; -------------
 1154                      	; HANDLE A 1-OP
 1155                      	; -------------
 1156                      	
 1157   4290               	OP1:
 1158   4290   29 30       		and	#%00110000	; ISOLATE ARGUMENT BITS
 1159   4292   D0 07       		bne	OP1A	
 1160   4294   20 1F 92    		jsr	NEXTPC		; get next byte
 1161   4297   A8          		tay
 1162   4298   4C 9F 42    		jmp	OP1A1	
 1163   429B   29 20       	OP1A:	and	#%00100000	; TEST AGAIN
 1164   429D   D0 0C       		bne	OP1B	
 1165                      	;
 1166                      	; 01 = SHORT IMMEDIATE
 1167                      	;
 1168   429F   85 64       	OP1A1:	sta	ARG1+HI	
 1169   42A1   20 1F 92    		jsr	NEXTPC
 1170   42A4   85 63       		sta	ARG1+LO	
 1171   42A6   E6 62       		inc	NARGS	
 1172   42A8   4C B1 42    		jmp	OP1EX1	
 1173   42AB   20 3F 43    	OP1B:	JSR	GETVAR	; 10 = VARIABLE
 1174   42AE   20 1C 43    	OP1EX:	JSR	V2A1	; MOVE [VALUE] TO [ARG1], UPDATE [NARGS]
 1175   42B1   A5 61       	OP1EX1:	LDA	OPCODE	
 1176   42B3   29 0F       		AND	#%00001111	; ISOLATE 0-OP ID BITS
 1177   42B5   A8          		TAY		
 1178   42B6   B9 04 45    		LDA	OPT1L,Y	
 1179   42B9   8D C3 42    		STA	GO1+1+LO	
 1180   42BC   B9 F4 44    		LDA	OPT1H,Y	
 1181   42BF   8D C4 42    		STA	GO1+1+HI	
 1182   42C2   20 FF FF    	GO1:	JSR	$FFFF	;DUMMY
 1183   42C5   4C B6 40    		JMP	MLOOP	
 1184                      	
 1185                      	; *** ERROR #3 -- ILLEGAL 1-OP ***
 1186                      	
 1187   42C8   A9 03       	BADOP1:	LDA	#3	
 1188   42CA   4C 0A 52    		JMP	ZERROR	
 1189                      	
 1190                      	
 1191                      	
 1192                      	; -------------
 1193                      	; HANDLE A 2-OP
 1194                      	; -------------
 1195                      	
 1196   42CD   29 40       	OP2:	AND	#%01000000	; ISOLATE 1ST ARG BIT
 1197   42CF   D0 0C       		BNE	OP2A	
 1198                      	;
 1199                      	; 0 = SHORT IMMEDIATE
 1200                      	;
 1201   42D1   85 64       		sta	ARG1+HI	
 1202   42D3   20 1F 92    		jsr	NEXTPC
 1203   42D6   85 63       		sta	ARG1+LO	
 1204   42D8   E6 62       		inc	NARGS	
 1205   42DA   4C E3 42    		jmp	OP2B1	
 1206   42DD   20 3F 43    	OP2A:	jsr	GETVAR	; 1 = VARIABLE
 1207   42E0   20 1C 43    	OP2B:	jsr	V2A1	; [VALUE] TO [ARG1], UPDATE [NARGS]
 1208   42E3   A5 61       	OP2B1:	lda	OPCODE	; RESTORE OPCODE BYTE
 1209   42E5   29 20       		and	#%00100000	; ISOLATE 2ND ARG BIT
 1210   42E7   D0 0A       		bne	OP2C	
 1211   42E9   85 66       		sta	ARG2+HI	
 1212   42EB   20 1F 92    		jsr	NEXTPC
 1213   42EE   85 65       		sta	ARG2+LO	
 1214   42F0   4C FE 42    		jmp	OP2D1	
 1215   42F3   20 3F 43    	OP2C:	jsr	GETVAR	; 1 = VARIABLE
 1216   42F6   A5 76       	OP2D:	lda	VALUE+LO	; MOVE 2ND [VALUE]
 1217   42F8   85 65       		sta	ARG2+LO	; INTO [ARG2]
 1218   42FA   A5 77       		lda	VALUE+HI	
 1219   42FC   85 66       		sta	ARG2+HI	
 1220   42FE   E6 62       	OP2D1:	inc	NARGS	; UPDATE ARGUMENT COUNT
 1221                      	
 1222                      		; EXECUTE A 2-OP OR EXTENDED 2-OP
 1223                      	
 1224   4300   A5 61       	OP2EX:	LDA	OPCODE	
 1225   4302   29 1F       		AND	#%00011111	; ISOLATE 0-OP ID BITS
 1226   4304   A8          		TAY		
 1227   4305   B9 34 45    		LDA	OPT2L,Y	
  Wed May 24 1989 15:00                                                                                                  Page   20

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

 1228   4308   8D 12 43    		STA	GO2+1+LO	
 1229   430B   B9 14 45    		LDA	OPT2H,Y	
 1230   430E   8D 13 43    		STA	GO2+1+HI	
 1231   4311   20 FF FF    	GO2:	JSR	$FFFF	;DUMMY
 1232   4314   4C B6 40    		JMP	MLOOP	
 1233                      	
 1234                      	; *** ERROR #4 -- ILLEGAL 2-OP ****
 1235                      	
 1236   4317   A9 04       	BADOP2:	LDA	#4	
 1237   4319   4C 0A 52    		JMP	ZERROR	
 1238                      	
 1239                      	
 1240                      	
 1241                      	; --------------------------------------
 1242                      	; MOVE [VALUE] TO [ARG1], UPDATE [NARGS]
 1243                      	; --------------------------------------
 1244                      	
 1245   431C   A5 76       	V2A1:	LDA	VALUE+LO
 1246   431E   85 63       		STA	ARG1+LO
 1247   4320   A5 77       		LDA	VALUE+HI
 1248   4322   85 64       		STA	ARG1+HI
 1249   4324   E6 62       		INC	NARGS
 1250   4326   60          		RTS
 1251                      	
 1252   4327               		END
 1253                      	
 1254   4327               		INCLUDE 	SUBS.ASM
 1255   4327               		STTL "--- OPCODE SUPPORT SUBROUTINES ---"
 1256                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page   21

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1257                      	
 1258                      	; -----------------------
 1259                      	; FETCH A SHORT IMMEDIATE
 1260                      	; -----------------------
 1261                      	
 1262   4327   A9 00       	GETSHT:	LDA	#0	; MSB IS ZERO
 1263   4329   F0 03       		BEQ	GETV	; FETCH LSB FROM Z-CODE
 1264                      	
 1265                      	
 1266                      	; ----------------------
 1267                      	; FETCH A LONG IMMEDIATE
 1268                      	; ----------------------
 1269                      	
 1270   432B   20 1F 92    	GETLNG:	JSR	NEXTPC	; GRAB MSB
 1271   432E   85 77       	GETV:	STA	VALUE+HI	
 1272   4330   20 1F 92    		JSR	NEXTPC	; GRAB LSB
 1273   4333   85 76       		STA	VALUE+LO	
 1274   4335   60          		RTS		
 1275                      	
 1276                      	
 1277                      	; ----------------
 1278                      	; FETCH A VARIABLE
 1279                      	; ----------------
 1280                      	; FROM INSIDE AN OPCODE (VARIABLE ID IN [A])
 1281                      	
 1282   4336   AA          	VARGET:	TAX		; IF NON-ZERO,
 1283   4337   D0 0B       		BNE	GETVR1	; ACCESS A VARIABLE
 1284   4339   20 66 43    		JSR	POPVAL	; ELSE PULL VAR OFF Z-STACK
 1285   433C   4C 97 43    		JMP	PSHVAL	; WITHOUT ALTERING STACK
 1286                      	
 1287                      	; FROM THE MAIN LOOP (VARIABLE ID IN Z-CODE)
 1288                      	
 1289   433F   20 1F 92    	GETVAR:	JSR	NEXTPC	; GRAB VAR-TYPE BYTE
 1290   4342   F0 22       		BEQ	POPVAL	; VALUE IS ON Z-STACK
 1291                      	
 1292                      	; IS VARIABLE LOCAL OR GLOBAL?
 1293                      	
 1294   4344   C9 10       	GETVR1:	CMP	#$10	; IF LOW = 16,
 1295   4346   B0 0D       		BCS	GETVRG	; IT'S GLOBAL
 1296                      	
 1297                      	; HANDLE A LOCAL VARIABLE
 1298                      	
 1299   4348   0A          	GETVRL:	ASL	A		; WORD INDEX
 1300   4349   AA          		TAX		; INTO THE [LOCALS] TABLE
 1301   434A   BD FE 1D    		LDA	LOCALS-2+LO,X	; GRAB LSB
 1302   434D   85 76       		STA	VALUE+LO	
 1303   434F   BD FF 1D    		LDA	LOCALS-2+HI,X	; AND MSB
 1304   4352   85 77       		STA	VALUE+HI	
 1305   4354   60          		RTS		
 1306                      	;
 1307                      	; HANDLE A GLOBAL VARIABLE
 1308                      	;
 1309   4355               	GETVRG:
 1310   4355   20 14 44    		jsr	GVCALC	; GET ADDRESS OF GLOBAL INTO [FPC]
 1311   4358   20 56 92    		jsr	FETCHB	; and get hi part
 1312   435B   85 77       		sta	VALUE+HI	
 1313   435D   20 BE 8F    		jsr	NEXTFPC	; and point to next part
 1314   4360   20 56 92    		jsr	FETCHB	; and go get it
 1315   4363   85 76       		sta	VALUE+LO ; SAVE IT
 1316   4365   60          		rts		; AND WE'RE DONE
 1317                      	
 1318                      	; ----------------------------------
 1319                      	; POP Z-STACK INTO [VALUE] AND [X/A]
 1320                      	; ----------------------------------
 1321                      	; ZSTACK DOUBLED IN SIZE FOR EZIP
 1322                      	; SO THIS RTN ALL NEW
 1323                      	
 1324   4366   A5 AF       	POPVAL:	LDA	ZSP+LO	; IF ZSP+LO IS 0
 1325   4368   D0 02       		BNE	POP1	
 1326   436A   85 B0       		STA	ZSP+HI	; MUST DEC. HI (HI = 0 OR 1 ONLY)
 1327   436C   C6 AF       	POP1:	DEC	ZSP+LO	; THEN DEC ZSP LO
 1328   436E   D0 04       		BNE	POP2	
 1329   4370   05 B0       		ORA	ZSP+HI	; LO + HI BOTH 0?
 1330   4372   F0 1E       		BEQ	UNDER	; UNDERFLOW IF ZERO!
 1331   4374   A4 AF       	POP2:	LDY	ZSP+LO	
  Wed May 24 1989 15:00                                                                                                  Page   22

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1332   4376   A5 B0       		LDA	ZSP+HI	
 1333   4378   F0 0C       		BEQ	POP3	; BOTTOM HALF OF ZSTACK
 1334   437A   B9 00 0E    		LDA	ZSTKTL,Y	; GET VALUE FROM TOP HALF
 1335   437D   85 76       		STA	VALUE+LO	; OF ZSTACK INTO VALUE & A,X
 1336   437F   AA          		TAX		
 1337   4380   B9 00 10    		LDA	ZSTKTH,Y	
 1338   4383   85 77       		STA	VALUE+HI	
 1339   4385   60          		RTS		
 1340                      	
 1341   4386   B9 00 0D    	POP3:	LDA	ZSTKBL,Y	; GET VALUE FROM BOTTOM HALF
 1342   4389   85 76       		STA	VALUE+LO	; OF ZSTACK INTO VALUE & A,X
 1343   438B   AA          		TAX		
 1344   438C   B9 00 0F    		LDA	ZSTKBH,Y	
 1345   438F   85 77       		STA	VALUE+HI	
 1346   4391   60          		RTS		
 1347                      	
 1348                      	; *** ERROR #5 -- Z-STACK UNDERFLOW ***
 1349   4392   A9 05       	UNDER:	LDA	#5	
 1350   4394   4C 0A 52    		JMP	ZERROR	
 1351                      	
 1352                      	; -----------------------
 1353                      	; PUSH [VALUE] TO Z-STACK
 1354                      	; -----------------------
 1355                      	
 1356   4397   A6 76       	PSHVAL:	LDX	VALUE+LO	
 1357   4399   A5 77       		LDA	VALUE+HI	
 1358                      	
 1359                      	; ---------------------
 1360                      	; PUSH [X/A] TO Z-STACK
 1361                      	; ---------------------
 1362                      	
 1363   439B   48          	PUSHXA:	PHA		; HOLD VALUE IN [A] A SEC.
 1364   439C   A4 AF       		LDY	ZSP+LO	
 1365   439E   A5 B0       		LDA	ZSP+HI	
 1366   43A0   F0 0B       		BEQ	PSHBOT	; ON BOTTOM HALF OF STACK
 1367   43A2   8A          		TXA		
 1368   43A3   99 00 0E    		STA	ZSTKTL,Y	; PUSH VALUE ONTO TOP HALF OF STACK
 1369   43A6   68          		PLA		
 1370   43A7   99 00 10    		STA	ZSTKTH,Y	
 1371   43AA   4C B5 43    		JMP	PSHUPD	; NOW UPDATE POINTER
 1372                      	
 1373   43AD   8A          	PSHBOT:	TXA		; PLACE VALUE ON ZSTACK
 1374   43AE   99 00 0D    		STA	ZSTKBL,Y	
 1375   43B1   68          		PLA		
 1376   43B2   99 00 0F    		STA	ZSTKBH,Y	
 1377   43B5   E6 AF       	PSHUPD:	INC	ZSP+LO	; UPDATE ZSTACK POINTER
 1378   43B7   D0 08       		BNE	PSHEX	
 1379   43B9   A5 AF       		LDA	ZSP+LO	
 1380   43BB   05 B0       		ORA	ZSP+HI	
 1381   43BD   D0 03       		BNE	OVER	; OVERFLOW IF $200
 1382   43BF   E6 B0       		INC	ZSP+HI	; TO 1
 1383   43C1   60          	PSHEX:	RTS		
 1384                      	
 1385                      	; *** ERROR #6 -- Z-STACK OVERFLOW ***
 1386   43C2   A9 06       	OVER:	LDA	#6	
 1387   43C4   4C 0A 52    		JMP	ZERROR	
 1388                      	
 1389                      	
 1390                      	; --------------
 1391                      	; RETURN A VALUE
 1392                      	; --------------
 1393                      	; FROM WITHIN AN OPCODE (VARIABLE ID IN [A])
 1394                      	
 1395   43C7   AA          	VARPUT:	TAX		; IF ZERO,
 1396   43C8   D0 1C       		BNE	PUTVR1	
 1397                      	
 1398                      	; FLUSH TOP WORD OFF STACK
 1399                      	; AND REPLACE WITH [VALUE]
 1400                      	
 1401   43CA   A5 AF       		LDA	ZSP+LO	; IF ZSP+LO =0
 1402   43CC   D0 02       		BNE	VAR1	; THEN HI =1 (GUARDED ELSEWHERE)
 1403   43CE   85 B0       		STA	ZSP+HI	; DECREMENT HI (ONLY 0 OR 1)
 1404   43D0   C6 AF       	VAR1:	DEC	ZSP+LO	; NOW DEC LOW BYTE
 1405   43D2   D0 C3       		BNE	PSHVAL	
 1406   43D4   05 B0       		ORA	ZSP+HI	
  Wed May 24 1989 15:00                                                                                                  Page   23

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1407   43D6   F0 BA       		BEQ	UNDER	; ERROR IF [ZSP] BECAME ZERO!
 1408   43D8   D0 BD       		BNE	PSHVAL	
 1409                      	
 1410                      		; RETURN A ZERO
 1411   43DA               	RET0:
 1412   43DA   A9 00       		lda	#0	
 1413   43DC   AA          		tax			; zero's all
 1414                      	;
 1415                      	; RETURN WORD IN [A], [X] (LO,HI) (EZIP EXPANDED TO A WORD)
 1416                      	;
 1417   43DD               	PUTBYT:
 1418   43DD   85 76       		STA	VALUE+LO	
 1419   43DF   86 77       		STX	VALUE+HI	; CLEAR MSB
 1420                      	;
 1421                      	; RETURN [VALUE]
 1422                      	;
 1423   43E1   20 1F 92    	PUTVAL:	JSR	NEXTPC	; GET VARIABLE ID BYTE
 1424   43E4   F0 B1       		BEQ	PSHVAL	; [VALUE] GOES TO Z-STACK
 1425                      	;
 1426                      	; LOCAL OR GLOBAL VARIABLE?
 1427                      	;
 1428   43E6   C9 10       	PUTVR1:	CMP	#$10	; IF LOW = 16,
 1429   43E8   B0 0D       		BCS	PUTVLG	; IT'S GLOBAL
 1430                      	;
 1431                      	; PUT A LOCAL VARIABLE
 1432                      	;
 1433   43EA   0A          	PUTVLL:	ASL	A		; WORD INDEX
 1434   43EB   AA          		TAX		; INTO THE [LOCALS] TABLE
 1435   43EC   A5 76       		LDA	VALUE+LO	; GRAB LSB
 1436   43EE   9D FE 1D    		STA	LOCALS-2+LO,X	; SAVE IN LOCAL TABLE
 1437   43F1   A5 77       		LDA	VALUE+HI	; DO SAME TO
 1438   43F3   9D FF 1D    		STA	LOCALS-2+HI,X	; MSB
 1439   43F6   60          		RTS		
 1440                      	;
 1441                      	; RETURN A GLOBAL VARIABLE
 1442                      	;
 1443   43F7               	PUTVLG:
 1444   43F7   20 14 44    		JSR	GVCALC		; put address in [FPC]
 1445   43FA   A5 8E       		lda	FPCBNK		; and move it to stash spot
 1446   43FC   85 91       		sta	SPCBNK
 1447   43FE   A5 8D       		lda	FPCH
 1448   4400   85 90       		sta	SPCH
 1449   4402   A5 8C       		lda	FPCL
 1450   4404   85 8F       		sta	SPCL	
 1451   4406   A5 77       		lda	VALUE+HI	; GET MSB
 1452   4408   20 35 92    		jsr	STASHB		; and save it
 1453   440B   20 9E 8F    		jsr	NEXTSPC		; point to next byte
 1454   440E   A5 76       		lda	VALUE+LO	; NOW GET LSB
 1455   4410   20 35 92    		jsr	STASHB		; and send it out
 1456   4413   60          		rts
 1457                      	
 1458                      	; -----------------------
 1459                      	; CALC GLOBAL WORD OFFSET
 1460                      	; -----------------------
 1461                      	; ENTRY: VAR-I BYTE (16-255) IN [A]
 1462                      	; EXIT: ABSOLUTE ADDRESS OF GLOBAL VAR IN [FPC]
 1463   4414               	GVCALC:
 1464   4414   38          		sec		; time for a subtract
 1465   4415   E9 10       		sbc	#$10	; FORM A ZERO-ALIGNED INDEX
 1466   4417   A0 00       		ldy	#0	; MAKE SURE MSB OF OFFSET AND [Y]
 1467   4419   84 79       		sty	I+HI	; ARE CLEARED
 1468   441B   0A          		asl	A	; MULTIPLY OFFSET BY 2
 1469   441C   26 79       		rol	I+HI	; TO WORD-ALIGN IT
 1470   441E   18          		clc		; ADD OFFSET TO ADDR OF GLOBAL TABLE
 1471   441F   65 50       		adc	GLOBAL+LO	; TO FORM THE ABSOLUTE
 1472   4421   85 8C       		sta	FPCL	; ADDRESS OF THE
 1473   4423   A5 79       		lda	I+HI	; DESIRED GLOBAL VARIABLE
 1474   4425   65 51       		adc	GLOBAL+HI	; STORE ADDRESS BACK IN [FPC]
 1475   4427   20 77 8F    		jsr	SETPC	; now get memory page and bank
 1476   442A   85 8D       		sta	FPCH	; hi part
 1477   442C   84 8E       		sty	FPCBNK	; and bank
 1478   442E               	WCEX:
 1479   442E   60          		rts
 1480                      	
 1481                      	
  Wed May 24 1989 15:00                                                                                                  Page   24

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1482                      	; ---------------
 1483                      	; PREDICATE FAILS
 1484                      	; ---------------
 1485                      	
 1486   442F   20 1F 92    	PREDF:	JSR	NEXTPC	; GET 1ST BRANCH BYTE
 1487   4432   10 0C       		BPL	PREDB	; DO BRANCH IF BIT 7 OFF
 1488                      	
 1489                      	
 1490                      	; -----------------------
 1491                      	; IGNORE PREDICATE BRANCH
 1492                      	; -----------------------
 1493                      	; ENTRY: 1ST BRANCH BYTE IN [A]
 1494                      	
 1495   4434   29 40       	PREDNB:	AND	#%01000000	; TEST BIT 6
 1496   4436   D0 F6       		BNE	WCEX	; SHORT BRANCH IF SET
 1497   4438   4C 1F 92    		JMP	NEXTPC	; ELSE SKIP OVER 2ND BRANCH BYTE
 1498                      	
 1499                      	
 1500                      	; ------------------
 1501                      	; PREDICATE SUCCEEDS
 1502                      	; ------------------
 1503                      	
 1504   443B   20 1F 92    	PREDS:	JSR	NEXTPC	; GET 1ST BRANCH BYTE
 1505   443E   10 F4       		BPL	PREDNB	; DON'T BRANCH IF BIT 7 CLEAR
 1506                      	
 1507                      	
 1508                      	; --------------------------
 1509                      	; PERFORM A PREDICATE BRANCH
 1510                      	; --------------------------
 1511                      	; ENTRY: 1ST PRED BYTE IN [A]
 1512                      	
 1513   4440   AA          	PREDB:	TAX		; SAVE HERE
 1514   4441   29 40       		AND	#%01000000	; LONG OR SHORT BRANCH?
 1515   4443   F0 0B       		BEQ	PREDLB	; LONG IF BIT 6 IS CLEAR
 1516                      	
 1517                      		; HANDLE A SHORT BRANCH
 1518                      	
 1519   4445   8A          		TXA		; RESTORE PRED BYTE
 1520   4446   29 3F       		AND	#%00111111	; FORM SHORT OFFSET
 1521   4448   85 76       		STA	VALUE+LO	; USE AS LSB OF BRANCH OFFSET
 1522   444A   A9 00       		LDA	#0	
 1523   444C   85 77       		STA	VALUE+HI	; MSB OF OFFSET IS ZERO
 1524   444E   F0 17       		BEQ	PREDB7	; DO THE BRANCH
 1525                      	
 1526                      		; HANDLE A LONG BRANCH
 1527                      	
 1528   4450   8A          	PREDLB:	TXA		; RESTORE 1ST PRED BYTE
 1529   4451   29 3F       		AND	#%00111111	; FORM MSB OF OFFSET
 1530   4453   AA          		TAX		; SAVE HERE FOR REFERENCE
 1531   4454   29 20       		AND	#%00100000	; CHECK SIGN OF 14-BIT VALUE
 1532   4456   F0 04       		BEQ	DOB2	; POSITIVE IF ZERO, SO USE [X]
 1533   4458   8A          		TXA		; ELSE RESTORE BYTE
 1534   4459   09 E0       		ORA	#%11100000	; EXTEND THE SIGN BIT
 1535   445B   AA          		TAX		; BACK HERE FOR STORAGE
 1536   445C   86 77       	DOB2:	STX	VALUE+HI	
 1537   445E   20 1F 92    		JSR	NEXTPC	; FETCH LSB OF 14-BIT OFFSET
 1538   4461   85 76       		STA	VALUE+LO	
 1539                      	
 1540                      		; BRANCH TO Z-ADDRESS IN [VALUE]
 1541                      	
 1542   4463   A5 77       	PREDB1:	LDA	VALUE+HI	; CHECK MSB OF OFFSET
 1543   4465   D0 0E       		BNE	PREDB3	; DO BRANCH IF NZ
 1544   4467   A5 76       	PREDB7:	LDA	VALUE+LO	; IF LSB IS NON-ZERO,
 1545   4469   D0 03       		BNE	PREDB2	; MAKE SURE IT ISN'T 1
 1546   446B   4C 61 79    		JMP	ZRFALS	; ELSE DO AN "RFALSE"
 1547   446E   C9 01       	PREDB2:	CMP	#1	; IF OFFSET = 1
 1548   4470   D0 03       		BNE	PREDB3	
 1549   4472   4C 56 79    		JMP	ZRTRUE	; DO AN "RTRUE"
 1550                      	
 1551                      	; ENTRY POINT FOR "JUMP"
 1552                      	
 1553   4475   A5 76       	PREDB3:	LDA	VALUE+LO	; SUBTRACT 2 FROM OFFSET
 1554   4477   38          		SEC			; IN [VALUE]
 1555   4478   E9 02       		SBC	#2	
 1556   447A   AA          		TAX			;SAVE	LO BYTE
  Wed May 24 1989 15:00                                                                                                  Page   25

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1557   447B   A5 77       		LDA	VALUE+HI	
 1558   447D   E9 00       		SBC	#0	
 1559   447F   85 78       		STA	I+LO	;MSB OF OFFSET = LSB OF [I]
 1560   4481   A0 00       		LDY	#0	; CLEAR THE MSB
 1561   4483   84 79       		STY	I+HI	; OF [I]
 1562   4485   0A          		ASL	A	;	EXTEND THE SIGN OF OFFSET
 1563   4486   26 79       		ROL	I+HI	; INTO MSB OF [I]
 1564   4488   0A          		ASL	A		
 1565   4489   26 79       		ROL	I+HI	; (EZIP)
 1566   448B   0A          	        asl     A
 1567   448C   26 79       	        rol     I+HI    ; (YZIP) ??!!
 1568   448E   8A          		TXA		; GET LSB OF OFFSET
 1569   448F   65 80       		ADC	ZPCL	; ADD LOW 8 BITS OF ZPC
 1570   4491   90 06       		BCC	PREDB5	; IF OVERFLOWED,
 1571   4493   E6 78       		INC	I+LO	; UPDATE UPPER 9 BITS
 1572   4495   D0 02       		BNE	PREDB5	
 1573   4497   E6 79       		INC	I+HI	
 1574   4499   85 80       	PREDB5:	STA	ZPCL	; UPDATE ZPC
 1575   449B   A5 78       		LDA	I+LO	; IF UPPER 9 BITS ARE ZERO,
 1576   449D   05 79       		ORA	I+HI	; NO NEED TO CHANGE PAGES
 1577   449F   F0 12       		BEQ	PREDB6	
 1578   44A1   A5 78       		LDA	I+LO	; ELSE CALC NEW UPPER BITS
 1579   44A3   18          		CLC		
 1580   44A4   65 81       		ADC	ZPCM	
 1581   44A6   85 81       		STA	ZPCM	
 1582   44A8   A5 79       		LDA	I+HI	
 1583   44AA   65 82       		ADC	ZPCH	
 1584   44AC   29 07       		AND	#%00000111
 1585   44AE   85 82       		STA	ZPCH	
 1586   44B0   4C AA 90    		JMP	VLDZPC	;MAKE VALID
 1587   44B3               	PREDB6:			
 1588                      	
 1589                      		; FALL THROUGH ...
 1590                      	
 1591                      	; ----
 1592                      	; NOOP
 1593                      	; ----
 1594                      	
 1595   44B3   60          	ZNOOP:	RTS		
 1596                      	
 1597                      	
 1598                      	; ----------------------
 1599                      	; MOVE [ARG1] TO [VALUE]
 1600                      	; ----------------------
 1601                      	
 1602   44B4   A5 63       	A12VAL:	LDA	ARG1+LO	
 1603   44B6   85 76       		STA	VALUE+LO
 1604   44B8   A5 64       		LDA	ARG1+HI	
 1605   44BA   85 77       		STA	VALUE+HI
 1606   44BC   60          		RTS
 1607                      	
 1608                      	
 1609                      	; -----------------------------------
 1610                      	; INDICATE STATUS LINE REFRESH NEEDED
 1611                      	; -----------------------------------
 1612                      	
 1613   44BD   AD 11 96    	REFRSH:	LDA	ZBEGIN+ZFLAGS+1	; PICK UP LOW BYTE OF FLAG WORD
 1614   44C0   09 04       		ORA	#%00000100	; SET BIT 2
 1615   44C2   8D 11 96    		STA	ZBEGIN+ZFLAGS+1	; AND PUT IT BACK
 1616   44C5   60          		RTS
 1617                      	
 1618                      	
 1619                      	;DECJ RETURNS C=0 WHEN  J=$FFFF
 1620                      	
 1621   44C6   A5 7A       	DECJ:	LDA	J+LO	
 1622   44C8   38          		SEC		
 1623   44C9   E9 01       		SBC	#1	
 1624   44CB   85 7A       		STA	J+LO	
 1625   44CD   A5 7B       		LDA	J+HI	
 1626   44CF   E9 00       		SBC	#0	
 1627   44D1   85 7B       		STA	J+HI	
 1628   44D3   60          		RTS		
 1629                      	
 1630   44D4               		END
 1631                      	
  Wed May 24 1989 15:00                                                                                                  Page   26

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1632   44D4               		INCLUDE 	DISPATCH.ASM
 1633                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page   27

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1634   44D4               		STTL "--- OPCODE DISPATCH TABLES ---"
 1635                      	
 1636                      	
 1637                      		; 0-OPS
 1638                      	
 1639   44D4   79          	OPT0H:	DB	>ZRTRUE	;B0
 1640   44D5   79          		DB	>ZRFALS	;B1
 1641   44D6   79          		DB	>ZPRI	;B2
 1642   44D7   79          		DB	>ZPRR	;B3
 1643   44D8   44          		DB	>ZNOOP	;B4
 1644   44D9   8F          		DB	>OSAVE	;B5
 1645   44DA   8F          		DB	>OREST	;B6
 1646   44DB   52          		DB	>ZSTART	;B7
 1647   44DC   79          		DB	>ZRSTAK	;B8
 1648   44DD   79          		DB	>ZCATCH	;B9
 1649   44DE   52          		DB	>ZQUIT	;BA
 1650   44DF   54          		DB	>ZZCRLF	;BB
 1651   44E0   55          		DB	>ZUSL	;BC
 1652   44E1   5B          		DB	>ZVER	;BD
 1653   44E2   41          		DB	>ZEXTOP	;BE
 1654   44E3   79          		DB	>ZORIG	;BF
 1655                      	
 1656   44E4   56          	OPT0L:	DB	<ZRTRUE	;B0
 1657   44E5   61          		DB	<ZRFALS	;B1
 1658   44E6   65          		DB	<ZPRI	;B2
 1659   44E7   7B          		DB	<ZPRR	;B3
 1660   44E8   B3          		DB	<ZNOOP	;B4
 1661   44E9   5C          		DB	<OSAVE	;B5
 1662   44EA   5C          		DB	<OREST	;B6
 1663   44EB   B1          		DB	<ZSTART	;B7
 1664   44EC   84          		DB	<ZRSTAK	;B8
 1665   44ED   8A          		DB	<ZCATCH	;B9
 1666   44EE   1E          		DB	<ZQUIT	;BA
 1667   44EF   CC          		DB	<ZZCRLF	;BB
 1668   44F0   AC          		DB	<ZUSL	;BC
 1669   44F1   B1          		DB	<ZVER	;BD
 1670   44F2   F4          		DB	<ZEXTOP	;BE
 1671   44F3   93          		DB	<ZORIG	;BF
 1672                      	
 1673                      		; 1-OPS
 1674                      	
 1675   44F4   79          	OPT1H:	DB	>ZZERO	;80,90,A0
 1676   44F5   79          		DB	>ZNEXT	;81
 1677   44F6   79          		DB	>ZFIRST	;82
 1678   44F7   79          		DB	>ZLOC	;83
 1679   44F8   79          		DB	>ZPTSIZ	;84
 1680   44F9   7A          		DB	>ZINC	;85
 1681   44FA   7A          		DB	>ZDEC	;86
 1682   44FB   7A          		DB	>ZPRB	;87
 1683   44FC   7F          		DB	>ZCALL1	;88 (EZIP)
 1684   44FD   7A          		DB	>ZREMOV	;89
 1685   44FE   7B          		DB	>ZPRD	;8A
 1686   44FF   7B          		DB	>ZRET	;8B
 1687   4500   7B          		DB	>ZJUMP	;8C
 1688   4501   7B          		DB	>ZPRINT	;8D
 1689   4502   7B          		DB	>ZVALUE	;8E
 1690   4503   7F          		DB	>ZICLL1	;8F
 1691                      	
 1692   4504   96          	OPT1L:	DB	<ZZERO	;80
 1693   4505   9F          		DB	<ZNEXT	;81
 1694   4506   AE          		DB	<ZFIRST	;82
 1695   4507   D6          		DB	<ZLOC	;83
 1696   4508   FC          		DB	<ZPTSIZ	;84
 1697   4509   27          		DB	<ZINC	;85
 1698   450A   35          		DB	<ZDEC	;86
 1699   450B   4C          		DB	<ZPRB	;87
 1700   450C   B2          		DB	<ZCALL1	;88 (EZIP)
 1701   450D   5E          		DB	<ZREMOV	;89
 1702   450E   2F          		DB	<ZPRD	;8A
 1703   450F   56          		DB	<ZRET	;8B
 1704   4510   C1          		DB	<ZJUMP	;8C
 1705   4511   C7          		DB	<ZPRINT	;8D
 1706   4512   D5          		DB	<ZVALUE	;8E
 1707   4513   AB          		DB	<ZICLL1	;8F
 1708                      	
  Wed May 24 1989 15:00                                                                                                  Page   28

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE DISPATCH TABLES ---"

 1709                      		; 2-OPS
 1710                      	
 1711   4514   43          	OPT2H:	DB	>BADOP2	;00 (UNDEFINED)
 1712   4515   7F          		DB	>ZEQUAL	;01
 1713   4516   7B          		DB	>ZLESS	;02
 1714   4517   7B          		DB	>ZGRTR	;03
 1715   4518   7B          		DB	>ZDLESS	;04
 1716   4519   7B          		DB	>ZIGRTR	;05
 1717   451A   7C          		DB	>ZIN	;06
 1718   451B   7C          		DB	>ZBTST	;07
 1719   451C   7C          		DB	>ZBOR	;08
 1720   451D   7C          		DB	>ZBAND	;09
 1721   451E   7C          		DB	>ZFSETP	;0A
 1722   451F   7C          		DB	>ZFSET	;0B
 1723   4520   7C          		DB	>ZFCLR	;0C
 1724   4521   7C          		DB	>ZSET	;0D
 1725   4522   7C          		DB	>ZMOVE	;0E
 1726   4523   7D          		DB	>ZGET	;0F
 1727   4524   7D          		DB	>ZGETB	;10
 1728   4525   7D          		DB	>ZGETP	;11
 1729   4526   7D          		DB	>ZGETPT	;12
 1730   4527   7E          		DB	>ZNEXTP	;13
 1731   4528   7E          		DB	>ZADD	;14
 1732   4529   7E          		DB	>ZSUB	;15
 1733   452A   7E          		DB	>ZMUL	;16
 1734   452B   7E          		DB	>ZDIV	;17
 1735   452C   7E          		DB	>ZMOD	;18
 1736   452D   7F          		DB	>ZCALL2	;19 (EZIP)
 1737   452E   7F          		DB	>ZICLL2	;1A
 1738   452F   4E          		DB	>ZCOLOR	;1B
 1739   4530   7F          		DB	>ZTHROW	;1C
 1740   4531   43          		DB	>BADOP2	;1D
 1741   4532   43          		DB	>BADOP2	;1E
 1742   4533   43          		DB	>BADOP2	;1F
 1743                      	
 1744   4534   17          	OPT2L:	DB	<BADOP2	;00 (UNDEFINED)
 1745   4535   7F          		DB	<ZEQUAL	;01
 1746   4536   DD          		DB	<ZLESS	;02
 1747   4537   F1          		DB	<ZGRTR	;03
 1748   4538   E3          		DB	<ZDLESS	;04
 1749   4539   FC          		DB	<ZIGRTR	;05
 1750   453A   2D          		DB	<ZIN		;06
 1751   453B   4D          		DB	<ZBTST	;07
 1752   453C   60          		DB	<ZBOR	;08
 1753   453D   70          		DB	<ZBAND	;09
 1754   453E   7C          		DB	<ZFSETP	;0A
 1755   453F   90          		DB	<ZFSET	;0B
 1756   4540   A8          		DB	<ZFCLR	;0C
 1757   4541   C4          		DB	<ZSET	;0D
 1758   4542   D1          		DB	<ZMOVE	;0E
 1759   4543   2A          		DB	<ZGET	;0F
 1760   4544   3A          		DB	<ZGETB	;10
 1761   4545   5B          		DB	<ZGETP	;11
 1762   4546   C4          		DB	<ZGETPT	;12
 1763   4547   31          		DB	<ZNEXTP	;13
 1764   4548   52          		DB	<ZADD	;14
 1765   4549   5F          		DB	<ZSUB	;15
 1766   454A   6C          		DB	<ZMUL	;16
 1767   454B   96          		DB	<ZDIV	;17
 1768   454C   A2          		DB	<ZMOD	;18
 1769   454D   B2          		DB	<ZCALL2	;19 (EZIP)
 1770   454E   AB          		DB	<ZICLL2	;1A
 1771   454F   D0          		DB	<ZCOLOR	;1B
 1772   4550   5E          		DB	<ZTHROW	;1C
 1773   4551   17          		DB	<BADOP2	;1D
 1774   4552   17          		DB	<BADOP2	;1E
 1775   4553   17          		DB	<BADOP2	;1F
 1776                      	
 1777                      		; X-OPS
 1778                      	
 1779   4554   7F          	OPTXH:	DB	>ZCALL	;E0
 1780   4555   80          		DB	>ZPUT	;E1
 1781   4556   80          		DB	>ZPUTB	;E2
 1782   4557   80          		DB	>ZPUTP	;E3
 1783   4558   85          		DB	>ZREAD	;E4
  Wed May 24 1989 15:00                                                                                                  Page   29

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE DISPATCH TABLES ---"

 1784   4559   81          		DB	>ZPRC	;E5
 1785   455A   81          		DB	>ZPRN	;E6
 1786   455B   81          		DB	>ZRAND	;E7
 1787   455C   81          		DB	>ZPUSH	;E8
 1788   455D   82          		DB	>ZPOP	;E9
 1789   455E   4D          		DB	>ZSPLIT	;EA
 1790   455F   6E          		DB	>ZSCRN	;EB
 1791                      	
 1792                      		; (EZIPS FROM HERE ON)
 1793   4560   7F          		DB	>ZXCALL	;EC
 1794   4561   57          		DB	>ZCLR	;ED
 1795   4562   57          		DB	>ZERASE	;EE
 1796   4563   56          		DB	>ZCURST	;EF
 1797   4564   57          		DB	>ZCURGT	;F0
 1798   4565   70          		DB	>ZLIGHT	;F1
 1799   4566   55          		DB	>ZBUFOUT ;F2
 1800   4567   55          		DB	>ZDIRT	;F3
 1801   4568   57          		DB	>ZDIRIN	;F4 (NOT IMPLEMENTED)
 1802   4569   4E          		DB	>ZSOUND	;F5
 1803   456A   5A          		DB	>ZINPUT	;F6
 1804   456B   82          		DB	>ZINTBL	;F7
 1805   456C   83          		DB	>ZBCOM 	;F8
 1806   456D   7F          		DB	>ZICALL	;F9
 1807   456E   7F          		DB	>ZIXCLL	;FA
 1808   456F   86          		DB	>ZLEX	;FB
 1809   4570   86          		DB	>ZWSTR	;FC
 1810   4571   83          		DB	>ZCOPYT	;FD
 1811   4572   58          		DB	>ZPRNTT	;FE
 1812   4573   84          		DB	>ZASSND	;FF
 1813                      	
 1814   4574   B2          	OPTXL:	DB	<ZCALL	;E0
 1815   4575   B4          		DB	<ZPUT	;E1
 1816   4576   C6          		DB	<ZPUTB	;E2
 1817   4577   E2          		DB	<ZPUTP	;E3
 1818   4578   09          		DB	<ZREAD	;E4
 1819   4579   27          		DB	<ZPRC	;E5
 1820   457A   2C          		DB	<ZPRN	;E6
 1821   457B   7D          		DB	<ZRAND	;E7
 1822   457C   FE          		DB	<ZPUSH	;E8
 1823   457D   05          		DB	<ZPOP	;E9
 1824   457E   DD          		DB	<ZSPLIT	;EA
 1825   457F   57          		DB	<ZSCRN	;EB
 1826                      	
 1827                      		; (EZIPS FROM HERE ON)
 1828   4580   B2          		DB	<ZXCALL	;EC
 1829   4581   A8          		DB	<ZCLR	;ED
 1830   4582   89          		DB	<ZERASE	;EE
 1831   4583   C5          		DB	<ZCURST	;EF
 1832   4584   1D          		DB	<ZCURGT	;F0
 1833   4585   06          		DB	<ZLIGHT	;F1
 1834   4586   AD          		DB	<ZBUFOUT ;F2
 1835   4587   B7          		DB	<ZDIRT	;F3
 1836   4588   76          		DB	<ZDIRIN	;F4 (NOT IMPLEMENTED)
 1837   4589   AD          		DB	<ZSOUND	;F5
 1838   458A   D1          		DB	<ZINPUT	;F6
 1839   458B   65          		DB	<ZINTBL	;F7
 1840   458C   02          		DB	<ZBCOM 	;F8
 1841   458D   AB          		DB	<ZICALL	;F9
 1842   458E   AB          		DB	<ZIXCLL	;FA
 1843   458F   71          		DB	<ZLEX	;FB
 1844   4590   A9          		DB	<ZWSTR	;FC
 1845   4591   11          		DB	<ZCOPYT	;FD
 1846   4592   1F          		DB	<ZPRNTT	;FE
 1847   4593   01          		DB	<ZASSND	;FF
 1848                      	
 1849                      	
 1850   4594   8C          	EXTOPH:	DB	>ZSAVE	;100
 1851   4595   8D          		DB	>ZREST	;101
 1852   4596   84          		DB	>ZSHIFT	;102
 1853   4597   84          		DB	>ZASHFT	;103
 1854   4598   58          		DB	>ZFONT	;104
 1855   4599   73          		DB	>ZDISPL	;105
 1856   459A   78          		DB	>ZPICNF	;106
 1857   459B   79          		DB	>ZDCLR	;107
 1858   459C   4E          		DB	>ZMARG	;108
  Wed May 24 1989 15:00                                                                                                  Page   30

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE DISPATCH TABLES ---"

 1859   459D   8F          		DB	>ZISAVE	;109
 1860   459E   8F          		DB	>ZIREST	;10A
 1861   459F   42          		DB	>BADEXT	;10B - NOT USED
 1862   45A0   42          		DB	>BADEXT	;10C - NOT USED
 1863   45A1   42          		DB	>BADEXT	;10D - NOT USED
 1864   45A2   42          		DB	>BADEXT	;10E - NOT USED
 1865   45A3   42          		DB	>BADEXT	;10F - NOT USED
 1866   45A4   6E          		DB	>ZWINPOS ;110
 1867   45A5   6F          		DB	>ZWINSIZE ;111
 1868   45A6   70          		DB	>ZWINATTR ;112
 1869   45A7   70          		DB	>ZWINGET  ;113
 1870   45A8   71          		DB	>ZSCROLL  ;114
 1871   45A9   84          		DB	>ZFSTACK  ;115
 1872   45AA   84          		DB	>ZMINFO	  ;116
 1873   45AB   84          		DB	>ZMLIMIT  ;117
 1874   45AC   84          		DB	>ZXPUSH	  ;118
 1875   45AD   71          		DB	>ZWINPUT  ;119
 1876   45AE   58          		DB	>ZPRINTF  ;11A
 1877   45AF   85          		DB	>ZMENU	  ;11B
 1878   45B0   79          		DB	>ZPICSET  ;11c
 1879                      	
 1880          001D        	EXTLEN	EQU	$-EXTOPH
 1881                      	
 1882   45B1   EF          	EXTOPL:	DB	<ZSAVE	;100
 1883   45B2   DA          		DB	<ZREST	;101
 1884   45B3   10          		DB	<ZSHIFT	;102
 1885   45B4   36          		DB	<ZASHFT	;103
 1886   45B5   CB          		DB	<ZFONT	;104
 1887   45B6   F1          		DB	<ZDISPL	;105
 1888   45B7   93          		DB	<ZPICNF	;106
 1889   45B8   15          		DB	<ZDCLR	;107
 1890   45B9   50          		DB	<ZMARG	;108
 1891   45BA   5D          		DB	<ZISAVE	;109
 1892   45BB   5D          		DB	<ZIREST	;10A
 1893   45BC   10          		DB	<BADEXT	;10B - NOT USED
 1894   45BD   10          		DB	<BADEXT	;10C - NOT USED
 1895   45BE   10          		DB	<BADEXT	;10D - NOT USED
 1896   45BF   10          		DB	<BADEXT	;10E - NOT USED
 1897   45C0   10          		DB	<BADEXT	;10F - NOT USED
 1898   45C1   F4          		DB	<ZWINPOS ;110
 1899   45C2   61          		DB	<ZWINSIZE ;111
 1900   45C3   2E          		DB	<ZWINATTR ;112
 1901   45C4   99          		DB	<ZWINGET  ;113
 1902   45C5   61          		DB	<ZSCROLL  ;114
 1903   45C6   B9          		DB	<ZFSTACK  ;115
 1904   45C7   FF          		DB	<ZMINFO	  ;116
 1905   45C8   FF          		DB	<ZMLIMIT  ;117
 1906   45C9   54          		DB	<ZXPUSH	  ;118
 1907   45CA   A6          		DB	<ZWINPUT  ;119
 1908   45CB   91          		DB	<ZPRINTF  ;11A
 1909   45CC   00          		DB	<ZMENU	  ;11B
 1910   45CD   15          		DB	<ZPICSET  ;11C
 1911                      	
 1912   45CE               		END
 1913                      	
 1914                      	
 1915   45CE               		TITLE 	"APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
 1916   45CE               		INCLUDE		ZDOS.ASM
 1917   45CE               		STTL "--- ZDOS (SEEKING, READING, WRITING) ---"
 1918                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page   31

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 1919                      	;
 1920                      	; some ProDOS parameter blocks here
 1921                      	;
 1922                      	READ_PB:			; for READING files
 1923   45CE   04          		db	4		; 4 parameters
 1924   45CF   00          	GMREF:	db	0		; refnum
 1925   45D0   0008        		dw	IOBUFF		; read into io buffer
 1926   45D2   0002        		dw	PAGELEN		; 512 byte buffer
 1927   45D4   0000        		dw	0		; length actually read
 1928                      	OPEN_FILE:			; opening up the pure file
 1929   45D6   03          		db	3		; 3 parameters
 1930   45D7   7746        		dw	GAME1NM		; name of pure file
 1931   45D9   0011        		dw	GAME1FIO	; game file buffer
 1932   45DB   00          		db	0		; where refnum goes
 1933   45DC               	PSEEK:	
 1934   45DC   02          		db	2	; 2 pararmeters
 1935   45DD   00          		db	0	; refnum
 1936   45DE   00 00 00    		db 	0,0,0	; 3 byte new file pos
 1937   45E1               	SET_PB:
 1938   45E1   01          		db	1	; just one parameter
 1939   45E2   9B46        		dw	GAMEPL	; where to go to
 1940                      	;
 1941                      	; some messages
 1942                      	;
 1943   45E4   0D 54 61 6B 65 	SWAPSAVE: db    EOL, "Take out save disk and insert ", EOL
        45E9   20 6F 75 74 20 
        45EE   73 61 76 65 20 
        45F3   64 69 73 6B 20 
        45F8   61 6E 64 20 69 
        45FD   6E 73 65 72 74 
        4602   20 0D 
 1944          0020        	SWAPSAVEL EQU   $-SWAPSAVE
 1945   4604   67 61 6D 65 20 	NOSWAP: db      "game disk."
        4609   64 69 73 6B 2E 
 1946          000A        	NOSWAPL EQU     $-NOSWAP
 1947   460E   0D 49 6E 73 65 	INS_MSG: db     EOL,"Insert "
        4613   72 74 20 
 1948          0008        	INS_MSGL EQU    $-INS_MSG
 1949   4616   2C 20 53 69 64 	SIDEMSG: db	", Side "
        461B   65 20 
 1950          0007        	SIDEMSGL EQU	$-SIDEMSG
 1951   461D   2C 20 69 6E 20 	DRIVE_MSG: db ", in Disk Drive "
        4622   44 69 73 6B 20 
        4627   44 72 69 76 65 
        462C   20 
 1952          0010        	DRIVE_MSGL EQU  $-DRIVE_MSG
 1953                      	
 1954   462D   0D 48 61 76 69 	RESEAT_MSG1: db EOL, "Having problems reading side #"
        4632   6E 67 20 70 72 
        4637   6F 62 6C 65 6D 
        463C   73 20 72 65 61 
        4641   64 69 6E 67 20 
        4646   73 69 64 65 20 
        464B   23 
 1955          001F        	RESEAT_MSG1L EQU   $-RESEAT_MSG1
 1956   464C   2E 0D 50 6C 65 	RESEAT_MSG2: db ".",EOL,"Please re-insert it.",EOL,EOL
        4651   61 73 65 20 72 
        4656   65 2D 69 6E 73 
        465B   65 72 74 20 69 
        4660   74 2E 0D 0D 
 1957          0018        	RESEAT_MSG2L EQU $-RESEAT_MSG2
 1958          [01]        		IF CHECKSUM
 1959                      	RETRYING: db	"RETRYING . . ."
 1960                      	RETRYINGL EQU $-RETRYING
 1961          [00]        		ENDIF
 1962                      	;
 1963                      	; place to stash prefixes and names
 1964                      	;
 1965                      	GPRE_PB:		; game prefix spot
 1966   4664   01          		db	1		; 1 parm
 1967   4665   9B46        		dw	GAMEPL		; where to put prefix
 1968   4667   00          	GAMEL:	db	0
 1969   4668               	GAME:	ds	15	; longest name
 1970                      	
 1971   4677               	GAME1NM:
  Wed May 24 1989 15:00                                                                                                  Page   32

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 1972   4677               	GAME1NML:
 1973   4677   00          		db	0	; not sure how long
 1974   4678               	GAME1NAME:
 1975   4678               		BLKB	15,0	; room for name
 1976   4687   00          	GAME1REF: db	0	; save refnum here
 1977   4688   00          	GAME1NUM: db	0	; number (0-3) of side
 1978                      	
 1979   4689               	GAME2NM:
 1980   4689               	GAME2NML:
 1981   4689   00          		db	0	; not sure how long
 1982   468A               	GAME2NAME:
 1983   468A               		BLKB	15,0	; room for name
 1984   4699   00          	GAME2REF: db	0	; refnum for game file 2
 1985   469A   00          	GAME2NUM: db	0	; number (0-3) of side
 1986   469B   00          	GAMEPL: db	0		; name of prefix for game file
 1987   469C               	GAMEP:	ds	64-15		; max len
 1988                      	; --------------------
 1989                      	; READ A VIRTUAL PAGE
 1990                      	; --------------------
 1991                      	; ENTRY: V-BLOCK TO READ IN [DBLOCK]
 1992                      	; BUFFER ADDRESS IN [DBUFF]
 1993                      	; DSKBNK SAYS WHERE TO PUT PAGE (AUX OR MAIN)
 1994                      	; EXIT: DATA AT [DBUFF]
 1995                      	;	
 1996   46CD               	RFLAG: ds 1
 1997   46CE               	RCHKS: ds 1
 1998   46CF               	GETDSK:
 1999   46CF   A9 03       	        lda     #RETRY_COUNT    ; set retry
 2000   46D1   85 16       	        sta     RETRIES         ; just use this for now
 2001                      	
 2002          [01]        		IF	DEBUG
 2003                      		lda	#0
 2004                      		sta	RFLAG		; show no retries
 2005                      		sta	RCHKS		; and checksum for it
 2006          [00]        		ENDIF
 2007                      	
 2008   46D3   20 8A 48    		jsr	FINDSEG		; find the segment and point to it
 2009   46D6               	GETDSKL:
 2010   46D6               		SET_MARK PSEEK		; move to the block
 2011   46D6               		PRODOS	$CE, PSEEK
 2012   46D6   20 00 BF    		jsr	$BF00	; ProDOS handler
 2013   46D9   CE          		DB	$CE	; ProDOS function code
 2014   46DA   DC45        		DW	PSEEK	; Function Parameter Block address
 2015   46DC               		.MACEND
 2016   46DC               		.MACEND
 2017   46DC   B0 26       		bcs	GDBAD		; just die then
 2018   46DE   20 56 48    		jsr	READ_DOS	; do the read, thank you
 2019   46E1   90 08       		bcc     GDEX            ; okay, just fine
 2020   46E3   EE CD 46    		inc	RFLAG
 2021   46E6   20 07 47    	        jsr     RETRY           ; try again
 2022   46E9   90 EB       	        bcc     GETDSKL         ; try all over
 2023   46EB               	GDEX:
 2024   46EB   AD D5 45    		lda	READ_PB+RD_LENGTH+HI ; Get how much read in
 2025   46EE   CD D3 45    		cmp	READ_PB+RD_BUFFLEN+HI ; same as we wanted?
 2026   46F1   F0 05       		beq	GDEX1		; yes
 2027   46F3   A9 17       		lda	#23
 2028   46F5   4C 0A 52    		jmp	ZERROR
 2029   46F8               	GDEX1:
 2030          [01]        		IF	DEBUG
 2031                      		lda	RFLAG		; see if we retried
 2032                      		beq	GDEX3		; nope
 2033                      		lda	RCHKS		; did retry checksum?
 2034                      		bne	GDEX2
 2035                      		inc	RCHKS		; now we have
 2036                      		ldy	#0		; save block
 2037                      		sty	$B00
 2038                      		clc
 2039                      	GDEXL:
 2040                      		lda	IOBUFF,Y
 2041                      		sta	$A00,Y
 2042                      		adc	$B00
 2043                      		sta	$B00
 2044                      		iny
 2045                      		bne	GDEXL
 2046                      		beq	GETDSKL
  Wed May 24 1989 15:00                                                                                                  Page   33

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2047                      	GDEX2:
 2048                      		ldy	#0
 2049                      		clc
 2050                      		sty	RFLAG
 2051                      	GDEX2L:
 2052                      		lda	IOBUFF,Y
 2053                      		adc	RFLAG
 2054                      		sta	RFLAG
 2055                      		iny
 2056                      		bne	GDEX2L
 2057                      		lda	RFLAG
 2058                      		cmp	$B00
 2059                      		beq	GDEX3
 2060                      		lda	#24
 2061                      		jmp	ZERROR
 2062          [00]        		ENDIF
 2063   46F8               	GDEX3:
 2064   46F8   A9 08       		lda	#>IOBUFF	; first   256 byte page
 2065   46FA   20 5D 48    		jsr	COPY_DATA	; and copy from IOBUFF to DBUFF
 2066   46FD   E6 B7       		inc	DBUFF+HI	; point to next one
 2067   46FF   A9 09       		lda	#>IOBUFF+1	; next 256 byte page
 2068   4701   4C 5D 48    		jmp	COPY_DATA	; and copy it over
 2069   4704               	GDBAD:
 2070   4704   4C 74 47    		jmp	DISK_FATAL	; just die then
 2071   4707               	RETRY:
 2072          [01]        		IF	CHECKSUM
 2073                      		DLINE	RETRYING	; show me the way to go  home
 2074          [00]        		ENDIF
 2075                      	
 2076   4707   C6 16       	        dec     RETRIES         ; count this try
 2077   4709   30 F9       	        bmi     GDBAD           ; it's dead jim
 2078   470B   F0 2F       		beq	RETRY0		; ask for reset
 2079   470D   C9 01       		cmp	#1		; down to last time?
 2080   470F   D0 61       	        bne     RETRYX          ; just try again
 2081   4711   AD DE 45    		lda	PSEEK+SM_FPOS+0
 2082   4714   48          		pha
 2083   4715   AD DF 45    		lda	PSEEK+SM_FPOS+1
 2084   4718   48          		pha
 2085   4719   AD E0 45    		lda	PSEEK+SM_FPOS+2
 2086   471C   48          		pha
 2087   471D   A9 00       		lda	#0		; seek to zero
 2088   471F   8D DE 45    		sta	PSEEK+SM_FPOS+0 ; save here for now
 2089   4722   8D DF 45    		sta	PSEEK+SM_FPOS+1 ; save here for now
 2090   4725   8D E0 45    		sta	PSEEK+SM_FPOS+2 ; save here for now
 2091   4728               		SET_MARK PSEEK		; move to the block
 2092   4728               		PRODOS	$CE, PSEEK
 2093   4728   20 00 BF    		jsr	$BF00	; ProDOS handler
 2094   472B   CE          		DB	$CE	; ProDOS function code
 2095   472C   DC45        		DW	PSEEK	; Function Parameter Block address
 2096   472E               		.MACEND
 2097   472E               		.MACEND
 2098   472E   68          		pla
 2099   472F   8D E0 45    		sta	PSEEK+SM_FPOS+2
 2100   4732   68          		pla
 2101   4733   8D DF 45    		sta	PSEEK+SM_FPOS+1
 2102   4736   68          		pla
 2103   4737   8D DE 45    		sta	PSEEK+SM_FPOS+0
 2104   473A   90 36       		bcc	RETRYX		; all done
 2105   473C               	RETRY0:
 2106   473C   48          	        pha                     ; save disk error
 2107   473D   20 A9 4C    	        jsr     SWAP2INFOW      ; go to window zero
 2108   4740               	        DLINE   RESEAT_MSG1     ; ask to move the disk around
 2109   4740   A2 2D       		ldx	#<RESEAT_MSG1	; get part of RESEAT_MSG1
 2110   4742   A9 46       		lda	#>RESEAT_MSG1	; get other part of string
 2111          [01]        		IFMA	2		; check to see if length passed in
 2112                      		ldy			; then just fetch it
 2113          [01]        		ELSE
 2114   4744   A0 1F       		ldy	#RESEAT_MSG1L	; get length of string
 2115          [00]        		ENDIF
 2116   4746   20 6B 4C    		jsr	DLINE		; print the string
 2117   4749               		.MACEND
 2118   4749   AD CF 45    	        lda     GMREF           ; get ref num
 2119   474C   CD 99 46    	        cmp     GAME2REF        ; game2?
 2120   474F   D0 08       	        bne     RETRY1          ; nope
 2121   4751   AC 89 46    	        ldy     GAME2NML        ; get length
  Wed May 24 1989 15:00                                                                                                  Page   34

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2122   4754   B9 89 46    	        lda     GAME2NM,Y       ; and side #
 2123   4757   D0 06       	        bne     RETRY2          ; and continue
 2124   4759               	RETRY1:
 2125   4759   AC 77 46    	        ldy     GAME1NML        ; get length
 2126   475C   B9 77 46    	        lda     GAME1NM,Y       ; and side #
 2127   475F               	RETRY2:
 2128   475F   20 7D 5D    	        jsr     CHAR            ; send char out there
 2129   4762               	        DLINE   RESEAT_MSG2     ; and finish statement
 2130   4762   A2 4C       		ldx	#<RESEAT_MSG2	; get part of RESEAT_MSG2
 2131   4764   A9 46       		lda	#>RESEAT_MSG2	; get other part of string
 2132          [01]        		IFMA	2		; check to see if length passed in
 2133                      		ldy			; then just fetch it
 2134          [01]        		ELSE
 2135   4766   A0 18       		ldy	#RESEAT_MSG2L	; get length of string
 2136          [00]        		ENDIF
 2137   4768   20 6B 4C    		jsr	DLINE		; print the string
 2138   476B               		.MACEND
 2139   476B   68          	        pla                     ; get disk error back
 2140   476C   20 8A 47    	        jsr     DISK_ERR        ; tell the error
 2141   476F   20 C9 4C    	        jsr     SWAPBACK        ; back to current window
 2142   4772               	RETRYX:
 2143   4772   18          	        clc                     ; show goodness
 2144   4773   60          	        rts                     ; and done
 2145                      	;
 2146                      	; this is the fatal error spot
 2147                      	;
 2148   4774               	DISK_FATAL:
 2149   4774   20 8A 47    		jsr	DISK_ERR	; print out problem
 2150   4777               	DRIVE_ERR:
 2151   4777   A9 0E       		lda	#14
 2152   4779   4C 0A 52    		jmp	ZERROR		; DRIVE ACCESS ERROR
 2153                      	;
 2154                      	; this routine prints out the string associated with the error and 
 2155                      	; returns with the carry set, like most routines do when there is
 2156                      	; an error.  The error should be in [A].
 2157                      	;
 2158   477C   50 72 6F 44 4F 	UNK_DISK:	db	"ProDOS error $"
        4781   53 20 65 72 72 
        4786   6F 72 20 24 
 2159          000E        	UNK_DISKL	EQU	$-UNK_DISK
 2160                      	
 2161   478A               	DISK_ERR:
 2162   478A   48          		pha			; save [A]
 2163   478B   20 A9 4C    		jsr	SWAP2INFOW	; point to information window
 2164   478E   68          		pla			; get it back
 2165                      	
 2166   478F   A2 1B       		ldx	#ELISTL		; scan the error table
 2167   4791               	DSKE:
 2168   4791   DD 69 6D    		cmp	ELIST,X		;  is it this one
 2169   4794   F0 16       		beq	DSKE1		; ayyup
 2170   4796   CA          		dex			; now skip the address
 2171   4797   CA          		dex			; of the description
 2172   4798   CA          		dex			; point to next error number
 2173   4799   10 F6       		bpl	DSKE		; jump to start
 2174                      	;
 2175                      	; if we are here print out unknown error and it's value
 2176                      	;
 2177   479B   48          		pha			; save [A]
 2178   479C               		DLINE	UNK_DISK	; show error
 2179   479C   A2 7C       		ldx	#<UNK_DISK	; get part of UNK_DISK
 2180   479E   A9 47       		lda	#>UNK_DISK	; get other part of string
 2181          [01]        		IFMA	2		; check to see if length passed in
 2182                      		ldy			; then just fetch it
 2183          [01]        		ELSE
 2184   47A0   A0 0E       		ldy	#UNK_DISKL	; get length of string
 2185          [00]        		ENDIF
 2186   47A2   20 6B 4C    		jsr	DLINE		; print the string
 2187   47A5               		.MACEND
 2188   47A5   68          		pla			; get [A]
 2189   47A6   20 D3 47    		jsr	HEXNUM		; print [A]
 2190   47A9   4C CB 47    		jmp	DSK_EXIT	; done
 2191   47AC               	DSKE1:
 2192   47AC   E8          		inx			; point to string address
 2193   47AD   BD 69 6D    		lda	ELIST,X		; get lo part
 2194   47B0   85 7E       		sta	L+LO		; save it
  Wed May 24 1989 15:00                                                                                                  Page   35

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2195   47B2   E8          		inx			; point to hi part
 2196   47B3   BD 69 6D    		lda	ELIST,X		; get hi part
 2197   47B6   AA          		tax			; save here
 2198   47B7   85 7F       		sta	L+HI		; and here
 2199   47B9   A0 00       		ldy	#0		; for offset
 2200   47BB   B1 7E       		lda	(L),Y		; get length of string
 2201   47BD   A8          		tay			; save in y
 2202   47BE   E6 7E       		inc	L+LO		; point past length
 2203   47C0   A5 7E       		lda	L+LO		; get it
 2204   47C2   D0 01       		bne	DSKPR		; for printing
 2205   47C4   E8          		inx			; wrapped
 2206   47C5               	DSKPR:
 2207   47C5   8A          		txa			; hi part in a
 2208   47C6   A6 7E       		ldx	L+LO		; lo part in X
 2209   47C8   20 6B 4C    		jsr	DLINE		; print out message
 2210   47CB               	DSK_EXIT:	
 2211   47CB   20 DB 8C    		jsr	GETRET		; wait for RETURN
 2212   47CE   20 C9 4C    		jsr	SWAPBACK	; all done
 2213   47D1   38          		sec			; show badness again
 2214   47D2   60          		rts			; and be done with it
 2215                      	;
 2216                      	; HEXNUM - print out the HEX value of [A] at the current cursor
 2217                      	; 	location
 2218                      	;
 2219   47D3               	HEXNUM:
 2220   47D3   48          		pha
 2221   47D4   4A          		lsr	A
 2222   47D5   4A          		lsr	A
 2223   47D6   4A          		lsr	A
 2224   47D7   4A          		lsr	A
 2225   47D8   20 DC 47    		jsr	NIB1
 2226   47DB   68          		pla
 2227   47DC               	NIB1:
 2228   47DC   29 0F       		and	#%00001111
 2229   47DE   A8          		tay
 2230   47DF   B9 E6 47    		lda	HCHARS,Y
 2231   47E2   20 7D 5D    		jsr	CHAR			; print it out
 2232   47E5   60          		rts
 2233   47E6   30 31 32 33 34 	HCHARS:	DB	"0123456789ABCDEF"
        47EB   35 36 37 38 39 
        47F0   41 42 43 44 45 
        47F5   46 
 2234                      	
 2235                      	; ----------------------
 2236                      	; WRITE [DBUFF] TO DISK
 2237                      	; ----------------------
 2238                      	; ENTRY: File already open and positioned, ready to be written to
 2239                      	;	 from page in (DBUFF).  Writes out 512bytes, starting @ DBUFF.
 2240                      	; EXIT: CARRY CLEAR IF OKAY, SET IF FAILED
 2241                      	
 2242   47F6               	PUTDSK:
 2243   47F6   A6 B8       		ldx	DSKBNK		; get bank
 2244   47F8   A0 00       		ldy	#0		; clear Y
 2245   47FA   A9 08       	        lda     #>IOBUFF        ; first buffer
 2246   47FC   20 EE 00    		jsr	SAVE_DATA	; and copy from DBUFF to IOBUFF
 2247                      	
 2248          [01]        		IF	CHECKSUM == 1
 2249                      		lda	#>IOBUFF
 2250                      		jsr	CKS_BLOCK
 2251          [00]        		ENDIF
 2252                      	
 2253   47FF   20 34 48    		jsr	NEXT_DBUFF	; point to next buffer
 2254   4802   A6 B8       	        ldx     DSKBNK          ; go get new DSKBNK
 2255   4804   A0 00       	        ldy     #0              ; clear Y again
 2256   4806   A9 09       	        lda     #>IOBUFF+1      ; top part
 2257   4808   20 EE 00    	        jsr     SAVE_DATA       ; copy to IOBUFF
 2258                      	
 2259          [01]        		IF	CHECKSUM == 1
 2260                      		lda	#>IOBUFF+1
 2261                      		jsr	CKS_BLOCK
 2262          [00]        		ENDIF
 2263                      	
 2264   480B   20 34 48    	        jsr     NEXT_DBUFF      ; count buffer
 2265   480E   4C 4F 48    		jmp	WRITE_DOS	; and now write it
 2266                      	; ---------------------
  Wed May 24 1989 15:00                                                                                                  Page   36

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2267                      	; READ DBLOCK FROM DISK
 2268                      	; ---------------------
 2269                      	; CALLED BY RESTORE
 2270                      	; ENTER: with file already set up as it DBUFF
 2271                      	;	L+LO == # of 256k blocks to read
 2272                      	;
 2273   4811               	GETRES:
 2274   4811   A5 7E       		lda	L+LO		; get # of blocks
 2275   4813   8D D3 45    		sta	READ_PB+RD_BUFFLEN+HI
 2276   4816   20 56 48    		jsr	READ_DOS	
 2277   4819   A2 02       		ldx	#>PAGELEN	; get starting number of pages
 2278   481B   8E D3 45    		stx	READ_PB+RD_BUFFLEN+HI
 2279   481E   90 01       		bcc	GTROK		; everything is fine
 2280   4820   60          		rts			; error if c == set
 2281   4821               	GTROK:
 2282   4821   A9 08       		lda	#>IOBUFF	; start at first block
 2283   4823   85 7F       		sta	L+HI		; we can use L+HI
 2284   4825               	GTRLOOP:
 2285   4825   A5 7F       		lda 	L+HI		; doing this block
 2286                      	
 2287          [01]        	        IF CHECKSUM == 1
 2288                      	        jsr     CKS_BLOCK       ; check check sum        
 2289          [00]        	        ENDIF
 2290                      	
 2291   4827   20 5D 48    		jsr	COPY_DATA	; and copy from IOBUFF to DBUFF
 2292   482A   20 34 48    		jsr	NEXT_DBUFF	; check for wrap
 2293   482D   E6 7F       		inc	L+HI		; count this block
 2294   482F   C6 7E       		dec	L+LO		; count this block
 2295   4831   D0 F2       		bne	GTRLOOP		; do next one
 2296   4833   60          		rts			; all finished
 2297                      	;
 2298                      	; NEXT_DBUFF
 2299                      	;       increment DBUFF to count the 2 pages done
 2300                      	;
 2301   4834               	NEXT_DBUFF:
 2302   4834   E6 B7       		inc	DBUFF+HI	; point to next page
 2303   4836   A5 B7       		lda	DBUFF+HI	; see where we are
 2304   4838   C9 BF       		cmp	#>PRGLBL	; wrapping?
 2305   483A   D0 10       		bne	GTREX		; okay then
 2306   483C   A5 B8       		lda	DSKBNK		; which bank we be in
 2307   483E   D0 06       		bne	GTR1		; aux, so go to page 3
 2308   4840   E6 B8       		inc	DSKBNK		; point to aux
 2309   4842   A9 40       		lda	#Z2PAGE		; start of page 2
 2310   4844   D0 06       	        bne     GTREX           ; so tell me which page
 2311   4846               	GTR1:
 2312   4846   A9 FF       		lda	#P3BANK		; show page 3 bank
 2313   4848   85 B8       		sta	DSKBNK		; okay
 2314   484A   A9 D0       		lda	#Z3PAGE		; page 3 of things
 2315   484C               	GTREX:
 2316   484C   85 B7       		sta	DBUFF+HI	; saved
 2317   484E   60          		rts			; all done		
 2318                      	;
 2319   484F               	WRITE_DOS:
 2320   484F               		WRITE	WRITE_SV	; write out save buffer
 2321   484F               		PRODOS	$CB, WRITE_SV
 2322   484F   20 00 BF    		jsr	$BF00	; ProDOS handler
 2323   4852   CB          		DB	$CB	; ProDOS function code
 2324   4853   088B        		DW	WRITE_SV	; Function Parameter Block address
 2325   4855               		.MACEND
 2326   4855               		.MACEND
 2327   4855   60          		rts			; done
 2328   4856               	READ_DOS:
 2329   4856               		READ	READ_PB		; read it
 2330   4856               		PRODOS	$CA, READ_PB
 2331   4856   20 00 BF    		jsr	$BF00	; ProDOS handler
 2332   4859   CA          		DB	$CA	; ProDOS function code
 2333   485A   CE45        		DW	READ_PB	; Function Parameter Block address
 2334   485C               		.MACEND
 2335   485C               		.MACEND
 2336   485C   60          		rts			; go home
 2337                      	;
 2338                      	; COPY_DATA - 
 2339                      	; now move the data from iobuff to dbuff (in some bank)
 2340                      	;	which part of IOBUFF is in [a] ($08 - $0B)
 2341                      	;
  Wed May 24 1989 15:00                                                                                                  Page   37

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2342   485D               	COPY_DATA:
 2343   485D   8D 79 48    		sta	SDLP3+2		; self-modify code to get from IOBUFF
 2344   4860   8D 02 C0    		sta	RDBNK+MAIN	; read from main
 2345   4863   A6 B8       		ldx	DSKBNK		; get which bank it's going to
 2346   4865   30 05       		bmi	CPD1		; oh oh, third bank
 2347   4867   9D 04 C0    		sta	WRTBNK,X	; and select that bank for writing
 2348   486A   10 07       		bpl	CPD2		; okay, bank selected
 2349   486C               	CPD1:
 2350   486C   A5 B7       		lda	DBUFF+HI	; get from this zero page
 2351   486E   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
 2352   4871   85 B7       		sta	DBUFF+HI	; and save this in aux mem ZP
 2353   4873               	CPD2:
 2354   4873   A0 00       		ldy	#0		; start at beginning
 2355   4875   84 B6       		sty	DBUFF+LO	; just to be sure
 2356   4877               	SDLP3:
 2357   4877   B9 00 08    		lda	IOBUFF,Y	; this becomes modified!
 2358   487A   91 B6       		sta	(DBUFF),Y	; to [DBUFF]
 2359   487C   C8          		iny		
 2360   487D   D0 F8       		bne	SDLP3	
 2361   487F   8D 08 C0    		sta	ALTZP+MAIN	; talk about main page again
 2362   4882   8D 04 C0    		sta	WRTBNK+MAIN	; end up back at main
 2363   4885   60          		rts
 2364                      	;
 2365                      	; Segment table handling routines
 2366                      	;
 2367                      	
 2368                      	;
 2369                      	; FINDSEG - find the Virtual page in DBLOCK by searching through
 2370                      	;	the SEGTBL.
 2371                      	;
 2372   4886               	DISKPAGE: ds	2		; spot to put starting disk page
 2373   4888               	BIGPAGE:  ds	2		; DBLOCK/2 for 512 pages
 2374   488A               	FINDSEG:
 2375   488A   AD 5A 6C    		lda	DBLOCK+HI	; work with MSB first
 2376   488D   4A          		lsr	A		; /2
 2377   488E   8D 89 48    		sta	BIGPAGE+HI
 2378   4891   AD 59 6C    		lda	DBLOCK+LO	; now LSB
 2379   4894   6A          		ror	A		; /2
 2380   4895   8D 88 48    		sta	BIGPAGE+LO
 2381   4898   AD 88 46    		lda	GAME1NUM	; get number for disk 1
 2382   489B   20 01 49    		jsr	SCANSEG		; scan through the current disk table
 2383   489E   AD 87 46    		lda	GAME1REF	; save refnum
 2384   48A1   90 0E       		bcc	FNDSG1		; found it, figger it out
 2385   48A3   AD 9A 46    		lda	GAME2NUM	; get number for disk 2
 2386   48A6   20 01 49    		jsr	SCANSEG		; see if it is here
 2387   48A9   AD 99 46    		lda	GAME2REF	; save refnum
 2388   48AC   90 03       		bcc	FNDSG1		; ayyup
 2389   48AE   20 79 49    		jsr	SEGQUEST	; get correct disk/file with segment
 2390   48B1               	FNDSG1:
 2391   48B1   8D DD 45    		sta	PSEEK+SM_REFNUM	; for seeking
 2392   48B4   8D CF 45    		sta	GMREF		; and for reading
 2393   48B7   B1 1E       		lda	(DSEGS),Y	; pick up MSB of disk page
 2394   48B9   8D 87 48    		sta	DISKPAGE+HI	; save it
 2395   48BC   C8          		iny			; point to LSB
 2396   48BD   B1 1E       		lda	(DSEGS),Y	; get it
 2397   48BF   8D 86 48    		sta	DISKPAGE+LO	; save it
 2398                      	; now point to Starting page again
 2399   48C2   88          		dey
 2400   48C3   88          		dey
 2401   48C4   88          		dey
 2402   48C5   88          		dey
 2403   48C6   AD 88 48    		lda	BIGPAGE+LO	; LSB of desired page
 2404   48C9   38          		sec			; doing subtract
 2405   48CA   F1 1E       		sbc	(DSEGS),Y	; get rid of LSB of starting page
 2406   48CC   8D DF 45    		sta	PSEEK+SM_FPOS+1 ; save here for now
 2407   48CF   88          		dey			; point to MSB of starting page
 2408   48D0   AD 89 48    		lda	BIGPAGE+HI	; get DBLOCK MSB
 2409   48D3   F1 1E       		sbc	(DSEGS),Y	; get offset
 2410   48D5   8D E0 45    		sta	PSEEK+SM_FPOS+2 ; save here temporarily
 2411   48D8   18          		clc			; now add offset to starting disk page
 2412   48D9   AD 86 48    		lda	DISKPAGE+LO	; get starting disk page
 2413   48DC   6D DF 45    		adc	PSEEK+SM_FPOS+1	; add inter-segment offset
 2414   48DF   8D DF 45    		sta	PSEEK+SM_FPOS+1	; save LSB
 2415   48E2   AD 87 48    		lda	DISKPAGE+HI	; get MSB of segment disk page
 2416   48E5   6D E0 45    		adc	PSEEK+SM_FPOS+2	; add inter-segment offset
  Wed May 24 1989 15:00                                                                                                  Page   38

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2417   48E8   8D E0 45    		sta	PSEEK+SM_FPOS+2	; save MSB of disk page
 2418   48EB   0E DF 45    		asl	PSEEK+SM_FPOS+1	; *2 for 256Kb pages
 2419   48EE   2E E0 45    		rol	PSEEK+SM_FPOS+2	; okay, we did
 2420   48F1   AD 59 6C    		lda	DBLOCK+LO	; check to see which page in 512 we are
 2421   48F4   29 01       		and	#$01		; if odd, then add one more
 2422   48F6   F0 08       		beq	FNDEX		; all done then
 2423   48F8   EE DF 45    		inc	PSEEK+SM_FPOS+1	; one more page
 2424   48FB   D0 03       		bne	FNDEX		; all done if no wrap
 2425   48FD   EE E0 45    		inc	PSEEK+SM_FPOS+2	; nother page
 2426   4900               	FNDEX:
 2427   4900   60          		rts			; done
 2428                      	;
 2429                      	; SCANSEG - look through the current segment table for the desired
 2430                      	;	address found in BIGPAGE.  Return with Y pointing to disk page
 2431                      	;	and carry cleared if found.  Otherwise, return carry set.
 2432                      	;	[A] = which side number we are checking (0-n)
 2433                      	;
 2434   4901               	SCANSEG:
 2435   4901   48          		pha			; save which disk
 2436   4902   0A          		asl	A		; make word index
 2437   4903   AA          		tax			; make it an index
 2438   4904   BD D0 1D    		lda	DSKSEG+LO,X	; get LSB
 2439   4907   85 1E       		sta	DSEGS+LO
 2440   4909   BD D1 1D    		lda	DSKSEG+HI,X
 2441   490C   85 1F       		sta	DSEGS+HI
 2442   490E   A0 05       		ldy	#SGTNSEG+1	; point to segment count
 2443   4910   B1 1E       		lda	(DSEGS),Y	; get it
 2444   4912   AA          		tax			; use x as counter
 2445   4913   68          		pla			; get which side 
 2446   4914   A8          		tay			; is it side zero
 2447   4915   D0 04       		bne	SCANSG1		; nope
 2448   4917   A0 0E       		ldy	#SGTSEG+6	; skip first entry, cuz they're preload
 2449   4919   D0 02       		bne	SCANNING	; okay ready to go
 2450   491B               	SCANSG1:
 2451   491B   A0 08       		ldy	#SGTSEG		; begin at beginning
 2452   491D               	SCANNING:
 2453   491D   B1 1E       		lda	(DSEGS),Y	; get MSB of start
 2454   491F   CD 89 48    		cmp	BIGPAGE+HI	; check against block we want
 2455   4922   F0 06       		beq	SCAN1		; might be okay
 2456   4924   90 0F       		bcc	SCAN2		; PAGE > start seg, check end seg
 2457   4926   C8          	        iny                     ; LSB of start
 2458   4927               	SCAN0:
 2459   4927   C8          	        iny                     ; MSB of end
 2460   4928   B0 1F       	        bcs     NEXTSEG         ; not this one
 2461   492A               	SCAN1:
 2462   492A   C8          		iny			; point to LSB of start
 2463   492B   B1 1E       		lda	(DSEGS),Y	; get LSB
 2464   492D   CD 88 48    		cmp	BIGPAGE+LO	; check against desired LSB
 2465   4930   F0 20       		beq	GOTSEG		; we found it
 2466   4932   B0 F3       		bcs	SCAN0		; DBLOCK LSB < then start LSB, not found
 2467   4934   88          		dey			; point back to MSB of start
 2468   4935               	SCAN2:
 2469   4935   C8          		iny			; LSB of start
 2470   4936   C8          	 	iny			; MSB of end
 2471   4937   B1 1E       		lda	(DSEGS),Y	; get MSB of end
 2472   4939   CD 89 48    		cmp	BIGPAGE+HI	; check against DBLOCK MSB
 2473   493C   90 0B       		bcc	NEXTSEG 	; end < DBLOCK, check next segment
 2474   493E   D0 13       		bne	GOTSEG1		; end > DBLOCK, must be in this segment
 2475   4940   C8          		iny			; point to end LSB
 2476   4941   B1 1E       		lda	(DSEGS),Y	; get LSB
 2477   4943   CD 88 48    		cmp	BIGPAGE+LO	; how does it compare to desired LSB
 2478   4946   B0 0C       		bcs	GOTSEG2		; it's <= end, so it is here
 2479   4948   88          		dey			; point back to MSB
 2480   4949               	NEXTSEG:
 2481   4949   C8          		iny			; point to LSB of end
 2482   494A   C8          		iny			; MSB of disk page
 2483   494B   C8          		iny			; LSB of disk page
 2484   494C   C8          		iny			; MSB of next start page
 2485   494D   CA          		dex			; count this segment
 2486   494E   D0 CD       		bne	SCANNING	; check this segment
 2487                      	
 2488   4950   38          		sec			; show not on this disk
 2489   4951   60          		rts			; and done
 2490   4952               	GOTSEG:
 2491   4952   C8          		iny			; MSB of end page
  Wed May 24 1989 15:00                                                                                                  Page   39

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2492   4953               	GOTSEG1:
 2493   4953   C8          		iny			; LSB of end page
 2494   4954               	GOTSEG2:
 2495   4954   C8          		iny			; MSB of disk offset
 2496   4955   18          		clc			; show we found it
 2497   4956   60          		rts			; all done
 2498                      	;
 2499                      	; SEGQUEST - find the correct disk/file with the desired page on
 2500                      	;	it.  Returns SCANSEG's stuff.
 2501                      	;
 2502   4957               	DISKCNTR:	ds	1	; disk count down
 2503   4958               	PAGENF:
 2504   4958   50 61 67 65 20 		db	"Page not found in segment table: "
        495D   6E 6F 74 20 66 
        4962   6F 75 6E 64 20 
        4967   69 6E 20 73 65 
        496C   67 6D 65 6E 74 
        4971   20 74 61 62 6C 
        4976   65 3A 20 
 2505          0021        	PAGENFL	EQU	$-PAGENF
 2506   4979               	SEGQUEST:
 2507   4979   A9 01       		lda	#1		; start at first disk
 2508   497B   8D 57 49    		sta	DISKCNTR	; init counter
 2509   497E               	SEGQL:
 2510   497E   AD 57 49    		lda	DISKCNTR	; get disk
 2511   4981   CD 01 19    		cmp	SEGTBL+SGTDISKS+1	; looked at all the disks?
 2512   4984   D0 24       		bne	SEGQL1		; nope
 2513                      	;
 2514                      	; as a last resort, check disk 1, the boot disk
 2515                      	;
 2516   4986   A9 00       		lda	#0		; set up DISKCNTR
 2517   4988   8D 57 49    		sta	DISKCNTR	; we did
 2518   498B   20 01 49    		jsr	SCANSEG		; see if it is there
 2519   498E   90 27       		bcc	SEGQ1		; we found it
 2520                      	
 2521   4990               		DLINE	PAGENF		; page not found
 2522   4990   A2 58       		ldx	#<PAGENF	; get part of PAGENF
 2523   4992   A9 49       		lda	#>PAGENF	; get other part of string
 2524          [01]        		IFMA	2		; check to see if length passed in
 2525                      		ldy			; then just fetch it
 2526          [01]        		ELSE
 2527   4994   A0 21       		ldy	#PAGENFL	; get length of string
 2528          [00]        		ENDIF
 2529   4996   20 6B 4C    		jsr	DLINE		; print the string
 2530   4999               		.MACEND
 2531   4999   AD 89 48    		lda	BIGPAGE+HI	; show MSB
 2532   499C   20 D3 47    		jsr	HEXNUM		; printed
 2533   499F   AD 88 48    		lda	BIGPAGE+LO	; and LSB
 2534   49A2   20 D3 47    		jsr	HEXNUM		; we did
 2535                      	
 2536   49A5   A9 11       		lda	#17		; bad page 
 2537   49A7   4C 0A 52    		jmp	ZERROR		; die a horrible death
 2538   49AA               	SEGQL1:
 2539   49AA   AD 57 49    		lda	DISKCNTR	; get which disk we be working on
 2540   49AD   20 01 49    		jsr	SCANSEG		; find out if it is here
 2541   49B0   90 05       		bcc	SEGQ1		; it is, so open up file
 2542   49B2   EE 57 49    		inc	DISKCNTR	; not in this disk
 2543   49B5   D0 C7       		bne	SEGQL		; and try again
 2544                      	;
 2545                      	; we have found the disk it is in, so ask for it if necessary
 2546                      	;
 2547   49B7               	SEGQ1:
 2548   49B7   98          		tya			; save the y pointer
 2549   49B8   48          		pha			; it is saved
 2550   49B9   AD 57 49    		lda	DISKCNTR	; get which disk we found it under
 2551   49BC   20 C6 49    		jsr	FETCH_FILE	; go get the disk desired
 2552   49BF   68          		pla			; get the Y reg back
 2553   49C0   A8          		tay			; and show it
 2554   49C1   AD CF 45    		lda	GMREF		; get reference number again
 2555   49C4   60          		rts			; all done
 2556                      	;
 2557                      	; FETCH_FILE: check to see if we can open GAMEFILE# (where # is in [A])
 2558                      	; 	if not, ask for DISK#.
 2559                      	;
 2560   49C5   00          	SAVENUM: db	0	; spot to save ascii number  
  Wed May 24 1989 15:00                                                                                                  Page   40

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2561   49C6               	FETCH_FILE:
 2562   49C6   18          		clc			; adding to make
 2563   49C7   69 30       		adc	#$30		; it an ascii number
 2564   49C9   8D C5 49    		sta	SAVENUM		; just save a minute
 2565   49CC   EE C5 49    		inc	SAVENUM		; make name be one based
 2566   49CF   AE 77 46    		ldx	GAME1NML	; get length of name
 2567   49D2   AD C5 49    		lda	SAVENUM		; get name back
 2568   49D5   C9 33       		cmp	#'3'		; are we looking for disk 1 or 2?
 2569   49D7   B0 18       		bcs	FEFI1		; disks 3 and up handled special
 2570   49D9               	FEFI00:
 2571   49D9   DD 77 46    		cmp	GAME1NM,X	; is it the current open one?
 2572   49DC   D0 05       		bne	FEFI0		; nope, so we need to open it
 2573   49DE   AC 87 46    		ldy	GAME1REF	; get game 1 refnum
 2574   49E1   D0 35       		bne	FEFIX		; all set, so point to it
 2575   49E3               	FEFI0:
 2576   49E3   20 E1 4A    		jsr	DO_GAME1	; handle it special
 2577   49E6   AD 87 46    	        lda     GAME1REF        ; fetch refnum
 2578   49E9   20 1B 76    		jsr	GET_PDATA	; now get the picture data
 2579   49EC   AC 87 46    	        ldy     GAME1REF        ; refetch refnum        
 2580   49EF   D0 27       		bne	FEFIX		; so all done
 2581   49F1               	FEFI1:
 2582   49F1   AE 89 46    	        ldx     GAME2NML        ; get length of second name        
 2583   49F4   DD 89 46    		cmp	GAME2NM,X	; how bout second open file?
 2584   49F7   D0 05       		bne	FEFI2		; nope, so we need to open it
 2585   49F9   AC 99 46    		ldy	GAME2REF	; it is second one, so show me
 2586   49FC   D0 1A       		bne	FEFIX		; it is open too
 2587   49FE               	FEFI2:
 2588   49FE   AD 99 46    		lda	GAME2REF	; get its refnum
 2589   4A01   F0 09       		beq	FEFI20		; nothing to close, thank you
 2590   4A03   8D 07 8B    		sta	CLOSE_PB+CL_REFNUM ; show close who to close
 2591   4A06               		CLOSE	CLOSE_PB	; close it up tight
 2592   4A06               		PRODOS	$CC, CLOSE_PB
 2593   4A06   20 00 BF    		jsr	$BF00	; ProDOS handler
 2594   4A09   CC          		DB	$CC	; ProDOS function code
 2595   4A0A   068B        		DW	CLOSE_PB	; Function Parameter Block address
 2596   4A0C               		.MACEND
 2597   4A0C               		.MACEND
 2598   4A0C               	FEFI20:
 2599   4A0C   20 1F 4A    		jsr	OPEN_GAME2	; open up GAME2 file
 2600   4A0F   AD 99 46    	        lda     GAME2REF        ; get refnum for this file        
 2601   4A12   20 1B 76    		jsr	GET_PDATA	; now get the picture data
 2602   4A15   AC 99 46    		ldy	GAME2REF	; get ref back, please
 2603   4A18               	FEFIX:
 2604   4A18   8C DD 45    		sty	PSEEK+SM_REFNUM	; for seeking
 2605   4A1B   8C CF 45    		sty	GMREF		; and for reading
 2606   4A1E   60          		rts			; did it
 2607                      	;
 2608                      	; OPEN_GAME2 - open up the file that GAME2NM is pointing to,
 2609                      	;	returning the REFNUM in [A], after storing in GAME2REF,
 2610                      	;	and the 2 picture structures
 2611                      	;
 2612   4A1F               	OPEN_GAME2:
 2613   4A1F   AE 89 46    	        ldx     GAME2NML        ; get end of name
 2614   4A22   AD C5 49    	        lda     SAVENUM         ; get new name
 2615   4A25   9D 89 46    		sta	GAME2NM,X	; using second file
 2616   4A28   A9 46       		lda	#>GAME2NM	; get lo byte
 2617   4A2A   8D D8 45    		sta	OPEN_FILE+OP_PATHNAME+HI
 2618   4A2D   A9 89       		lda	#<GAME2NM	; set address in open block
 2619   4A2F   8D D7 45    		sta	OPEN_FILE+OP_PATHNAME+LO
 2620   4A32   A9 15       		lda	#>GAME2FIO	; now set up file i/o buffer
 2621   4A34   8D DA 45    		sta	OPEN_FILE+OP_FILEBUFF+HI
 2622   4A37   A9 00       		lda	#<GAME2FIO	; now set up file i/o buffer
 2623   4A39   8D D9 45    		sta	OPEN_FILE+OP_FILEBUFF+LO
 2624   4A3C   20 22 4B    		jsr	OPEN_GAMEF	; find and open game file
 2625   4A3F   AD DB 45    		lda	OPEN_FILE+OP_REFNUM	; get refnum
 2626   4A42   8D 99 46    		sta	GAME2REF	; save refnum here
 2627   4A45   AE 89 46    		ldx	GAME2NML	; get me number of this side
 2628   4A48   BD 89 46    		lda	GAME2NM,X	; get ascii number
 2629   4A4B   49 30       		eor	#'0'		; make it binary
 2630   4A4D   8D 9A 46    		sta	GAME2NUM	; save num
 2631   4A50   CE 9A 46    		dec	GAME2NUM	; make it zero based
 2632   4A53   60          		rts			; finis
 2633                      	;
 2634                      	; SET_GAMEPRE: check if game prefix is in, and if not go ask for it
 2635                      	;
  Wed May 24 1989 15:00                                                                                                  Page   41

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2636   4A54   00          	SAVEDISK: db    0               ; swap out save disk?
 2637   4A55   00          	SWAPPED:  db    0               ; <>0 if multi disk game
 2638                      	
 2639   4A56               	SET_GAMEPRE:
 2640   4A56   20 A9 4C    		jsr	SWAP2INFOW	; point to info window
 2641   4A59   AD 55 4A    	        lda     SWAPPED         ; are we swapping disks?
 2642   4A5C   F0 0B       	        beq     SETGP           ; nope, don't change game prefix
 2643   4A5E   AD C5 49    		lda	SAVENUM		; get which disk to put it
 2644   4A61   AC 9B 46    	        ldy     GAMEPL          ; get length of prefix
 2645   4A64   88          	        dey                     ; subtract 2 to point to prefix
 2646   4A65   88          	        dey                     ;   number
 2647   4A66   99 9C 46    		sta	GAMEP,Y		; set number for prefix
 2648   4A69               	SETGP:
 2649   4A69   A9 46       		lda	#>GAMEPL	; set up parm block
 2650   4A6B   8D E3 45    		sta	SET_PB+SP_PATHNAME+HI
 2651   4A6E   A9 9B       		lda	#<GAMEPL
 2652   4A70   8D E2 45    		sta	SET_PB+SP_PATHNAME+LO
 2653   4A73               	SETGP0:
 2654   4A73               		SET_PREFIX SET_PB	; set to game file prefix
 2655   4A73               		PRODOS	$C6, SET_PB
 2656   4A73   20 00 BF    		jsr	$BF00	; ProDOS handler
 2657   4A76   C6          		DB	$C6	; ProDOS function code
 2658   4A77   E145        		DW	SET_PB	; Function Parameter Block address
 2659   4A79               		.MACEND
 2660   4A79               		.MACEND
 2661   4A79   90 63       		bcc	SETGP1		; okay, it is
 2662   4A7B   AD 54 4A    		lda	SAVEDISK	; is it a save disk in there?
 2663   4A7E   F0 1A       		beq	SEGTP00		; nope
 2664                      	;
 2665                      	; special stuff for  save disk swapping
 2666                      	;
 2667   4A80               		DLINE	SWAPSAVE	; tell them to take out save disk
 2668   4A80   A2 E4       		ldx	#<SWAPSAVE	; get part of SWAPSAVE
 2669   4A82   A9 45       		lda	#>SWAPSAVE	; get other part of string
 2670          [01]        		IFMA	2		; check to see if length passed in
 2671                      		ldy			; then just fetch it
 2672          [01]        		ELSE
 2673   4A84   A0 20       		ldy	#SWAPSAVEL	; get length of string
 2674          [00]        		ENDIF
 2675   4A86   20 6B 4C    		jsr	DLINE		; print the string
 2676   4A89               		.MACEND
 2677   4A89   AD 55 4A    	        lda     SWAPPED         ; should we ask for specific disk?
 2678   4A8C   D0 15       	        bne     SEGTP01         ; yes, so ask for it
 2679   4A8E               	        DLINE   NOSWAP          ; no, so just get game disk
 2680   4A8E   A2 04       		ldx	#<NOSWAP	; get part of NOSWAP
 2681   4A90   A9 46       		lda	#>NOSWAP	; get other part of string
 2682          [01]        		IFMA	2		; check to see if length passed in
 2683                      		ldy			; then just fetch it
 2684          [01]        		ELSE
 2685   4A92   A0 0A       		ldy	#NOSWAPL	; get length of string
 2686          [00]        		ENDIF
 2687   4A94   20 6B 4C    		jsr	DLINE		; print the string
 2688   4A97               		.MACEND
 2689   4A97   4C D8 4A    	        jmp     SEGTP03         ; and continue
 2690   4A9A               	SEGTP00:
 2691   4A9A               		DLINE	INS_MSG		; ask for game disk
 2692   4A9A   A2 0E       		ldx	#<INS_MSG	; get part of INS_MSG
 2693   4A9C   A9 46       		lda	#>INS_MSG	; get other part of string
 2694          [01]        		IFMA	2		; check to see if length passed in
 2695                      		ldy			; then just fetch it
 2696          [01]        		ELSE
 2697   4A9E   A0 08       		ldy	#INS_MSGL	; get length of string
 2698          [00]        		ENDIF
 2699   4AA0   20 6B 4C    		jsr	DLINE		; print the string
 2700   4AA3               		.MACEND
 2701   4AA3               	SEGTP01:
 2702   4AA3               		DLINE	GAME, GAMEL	; this is the name of the game
 2703   4AA3   A2 68       		ldx	#<GAME	; get part of GAME
 2704   4AA5   A9 46       		lda	#>GAME	; get other part of string
 2705          [01]        		IFMA	2		; check to see if length passed in
 2706   4AA7   AC 67 46    		ldy	GAMEL		; then just fetch it
 2707          [01]        		ELSE
 2708                      		ldy	#GAMEL	; get length of string
 2709          [00]        		ENDIF
 2710   4AAA   20 6B 4C    		jsr	DLINE		; print the string
  Wed May 24 1989 15:00                                                                                                  Page   42

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2711   4AAD               		.MACEND
 2712   4AAD               		DLINE	SIDEMSG		; part 2 of message
 2713   4AAD   A2 16       		ldx	#<SIDEMSG	; get part of SIDEMSG
 2714   4AAF   A9 46       		lda	#>SIDEMSG	; get other part of string
 2715          [01]        		IFMA	2		; check to see if length passed in
 2716                      		ldy			; then just fetch it
 2717          [01]        		ELSE
 2718   4AB1   A0 07       		ldy	#SIDEMSGL	; get length of string
 2719          [00]        		ENDIF
 2720   4AB3   20 6B 4C    		jsr	DLINE		; print the string
 2721   4AB6               		.MACEND
 2722   4AB6   AD C5 49    		lda	SAVENUM		; get which disk to put it
 2723   4AB9   20 7D 5D    		jsr	CHAR		; print it out
 2724   4ABC               	        DLINE   DRIVE_MSG       ; tell about drive
 2725   4ABC   A2 1D       		ldx	#<DRIVE_MSG	; get part of DRIVE_MSG
 2726   4ABE   A9 46       		lda	#>DRIVE_MSG	; get other part of string
 2727          [01]        		IFMA	2		; check to see if length passed in
 2728                      		ldy			; then just fetch it
 2729          [01]        		ELSE
 2730   4AC0   A0 10       		ldy	#DRIVE_MSGL	; get length of string
 2731          [00]        		ENDIF
 2732   4AC2   20 6B 4C    		jsr	DLINE		; print the string
 2733   4AC5               		.MACEND
 2734   4AC5   A9 32       	        lda     #'2'            ; assume it's drive 2
 2735   4AC7   AE C5 49    	        ldx     SAVENUM         ; get which disk we want
 2736   4ACA   E0 33       	        cpx     #'3'            ; >= side 3, must be disk drive 2
 2737   4ACC   B0 02       	        bcs     SEGTP02         ; fine, send that message out
 2738   4ACE   A9 31       	        lda     #'1'            ; ask for drive 1 then
 2739   4AD0               	SEGTP02:
 2740   4AD0   20 7D 5D    	        jsr     CHAR            ; save which drive
 2741   4AD3   A9 2E       	        lda     #'.'            ; finish sentence
 2742   4AD5   20 7D 5D    	        jsr     CHAR            ; okay
 2743   4AD8               	SEGTP03:
 2744   4AD8   20 DB 8C    		jsr	GETRET		; wait for <CR>
 2745   4ADB   4C 73 4A    		jmp	SETGP0		; try again
 2746   4ADE               	SETGP1:
 2747   4ADE   4C C9 4C    		jmp	SWAPBACK	; pointing to disk
 2748                      	;
 2749                      	; DO_GAME1 - open up the special game 1 file and point to it
 2750                      	;
 2751   4AE1               	DO_GAME1:
 2752   4AE1   AC 87 46    		ldy	GAME1REF	; get the current game 1 ref num
 2753   4AE4   F0 0B       		beq	DOG1		; not currently open
 2754   4AE6   48          		pha			; save Name
 2755   4AE7   8C 07 8B    		sty	CLOSE_PB+CL_REFNUM	; show close
 2756   4AEA               		CLOSE	CLOSE_PB	; and close it
 2757   4AEA               		PRODOS	$CC, CLOSE_PB
 2758   4AEA   20 00 BF    		jsr	$BF00	; ProDOS handler
 2759   4AED   CC          		DB	$CC	; ProDOS function code
 2760   4AEE   068B        		DW	CLOSE_PB	; Function Parameter Block address
 2761   4AF0               		.MACEND
 2762   4AF0               		.MACEND
 2763   4AF0   68          		pla			; get name back
 2764   4AF1               	DOG1:
 2765   4AF1   AE 77 46    	        ldx     GAME1NML        ; get length of name
 2766   4AF4   AD C5 49    	        lda     SAVENUM         ; get new number        
 2767   4AF7   9D 77 46    		sta	GAME1NM,X	; save name
 2768   4AFA   48          		pha			; save it for later use
 2769   4AFB   A9 46       		lda	#>GAME1NM	; get lo byte
 2770   4AFD   8D D8 45    		sta	OPEN_FILE+OP_PATHNAME+HI
 2771   4B00   A9 77       		lda	#<GAME1NM	; set address in open block
 2772   4B02   8D D7 45    		sta	OPEN_FILE+OP_PATHNAME+LO
 2773   4B05   A9 11       		lda	#>GAME1FIO	; now set up file i/o buffer
 2774   4B07   8D DA 45    		sta	OPEN_FILE+OP_FILEBUFF+HI
 2775   4B0A   A9 00       		lda	#<GAME1FIO	; now set up file i/o buffer
 2776   4B0C   8D D9 45    		sta	OPEN_FILE+OP_FILEBUFF+LO
 2777   4B0F   20 22 4B    		jsr	OPEN_GAMEF	; so find and open game file
 2778   4B12   68          		pla			; get number back
 2779   4B13   49 30       		eor	#'0'		; make binary
 2780   4B15   8D 88 46    		sta	GAME1NUM	; save number
 2781   4B18   CE 88 46    		dec	GAME1NUM	; decrement for usage
 2782   4B1B   AC DB 45    		ldy	OPEN_FILE+OP_REFNUM	; get refnum
 2783   4B1E   8C 87 46    		sty	GAME1REF	; save refnum here
 2784   4B21   60          		rts			; did it
 2785                      	;
  Wed May 24 1989 15:00                                                                                                  Page   43

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2786                      	;OPEN_GAMEF: open the currently pointed to game file, getting the
 2787                      	; disk if necessary (ascii number of disk/file found in SAVENUM)
 2788                      	;
 2789   4B22               	OPEN_GAMEF:
 2790   4B22   A9 00       		lda	#0		; reset volume flag
 2791   4B24   85 1D       		sta	CHPTR+HI	;okay, we be ready
 2792   4B26               	OPGM1:
 2793   4B26               		OPEN	OPEN_FILE	; open the file file
 2794   4B26               		PRODOS	$C8, OPEN_FILE
 2795   4B26   20 00 BF    		jsr	$BF00	; ProDOS handler
 2796   4B29   C8          		DB	$C8	; ProDOS function code
 2797   4B2A   D645        		DW	OPEN_FILE	; Function Parameter Block address
 2798   4B2C               		.MACEND
 2799   4B2C               		.MACEND
 2800   4B2C   90 1F       		bcc	OPGMX		; okay
 2801   4B2E   C9 46       		cmp	#$46		; file not found error?
 2802   4B30   F0 07       		beq	OPGMV		; get the volume
 2803   4B32   C9 45       		cmp	#$45		; volume not found error?
 2804   4B34   F0 03       		beq	OPGMV		; then ask for it
 2805   4B36   4C 8A 47    		jmp	DISK_ERR	; die with ZERROR
 2806   4B39               	OPGMV:
 2807   4B39   20 A5 4B    		jsr	CHECKVOLS	; try another volume
 2808   4B3C   90 E8       		bcc	OPGM1		; ==0 if no more volumes to try
 2809   4B3E   AD 54 4A    	        lda     SAVEDISK        ; doing save?
 2810   4B41   D0 05       	        bne     OPGMV1          ; yes, so don't set swap flag
 2811   4B43   A9 01       	        lda     #1              ; set swap flag
 2812   4B45   8D 55 4A    	        sta     SWAPPED         ; we have to swap disks
 2813   4B48               	OPGMV1:
 2814   4B48   20 56 4A    		jsr	SET_GAMEPRE	; okay, set up prefix
 2815   4B4B   90 D5       		bcc	OPEN_GAMEF	; try again
 2816   4B4D               	OPGMX:
 2817   4B4D   60          		rts
 2818                      	;
 2819                      	; LISTVOLS - list all the online volumes for saving to
 2820                      	;
 2821   4B4E               	ONLINE_PB:
 2822   4B4E   02          		db	2	; 2 parms for ONLINE call
 2823   4B4F   00          		db	0	; unit == 0 to get all current ones
 2824   4B50   0008        		dw	IOBUFF	; use IOBUFFER to store names
 2825   4B52   0D 56 6F 6C 75 	LSTVM:	db	EOL,"Volumes: ",EOL
        4B57   6D 65 73 3A 20 
        4B5C   0D 
 2826          000B        	LSTVML	EQU	$-LSTVM
 2827                      	
 2828   4B5D               	LISTVOLS:
 2829   4B5D               		DLINE	LSTVM		; print out intro message
 2830   4B5D   A2 52       		ldx	#<LSTVM	; get part of LSTVM
 2831   4B5F   A9 4B       		lda	#>LSTVM	; get other part of string
 2832          [01]        		IFMA	2		; check to see if length passed in
 2833                      		ldy			; then just fetch it
 2834          [01]        		ELSE
 2835   4B61   A0 0B       		ldy	#LSTVML	; get length of string
 2836          [00]        		ENDIF
 2837   4B63   20 6B 4C    		jsr	DLINE		; print the string
 2838   4B66               		.MACEND
 2839                      	
 2840   4B66               		ONLINE	ONLINE_PB
 2841   4B66               		PRODOS	$C5, ONLINE_PB
 2842   4B66   20 00 BF    		jsr	$BF00	; ProDOS handler
 2843   4B69   C5          		DB	$C5	; ProDOS function code
 2844   4B6A   4E4B        		DW	ONLINE_PB	; Function Parameter Block address
 2845   4B6C               		.MACEND
 2846   4B6C               		.MACEND
 2847   4B6C   90 05       		bcc	LSTV1		; worked fine
 2848   4B6E   20 8A 47    		jsr	DISK_ERR	; complain if we had an error
 2849   4B71   B0 31       		bcs	LSTVEX		; all done
 2850   4B73               	LSTV1:
 2851   4B73   A9 00       		lda	#0		; start at byte zero
 2852   4B75   48          		pha			; saved on stack
 2853   4B76               	LSTVL:
 2854   4B76   68          		pla			; get index
 2855   4B77   AA          		tax			; make it an index
 2856   4B78   BD 00 08    		lda	IOBUFF,X	; get drive/length byte
 2857   4B7B   F0 27       		beq	LSTVEX		; all done if == 0
 2858   4B7D   29 0F       		and	#$0F		; just care about length
  Wed May 24 1989 15:00                                                                                                  Page   44

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2859   4B7F   A8          		tay			; save in [Y] for now
 2860   4B80   8A          		txa			; into [A] for addition
 2861   4B81   18          		clc			; doing add
 2862   4B82   69 10       		adc	#16		; point to next entry
 2863   4B84   48          		pha			; save for later reference
 2864   4B85   98          		tya			; check for zero length
 2865   4B86   F0 EE       		beq	LSTVL		; nothing here but an error
 2866   4B88   A9 2F       		lda	#'/'		; start with / to be better
 2867   4B8A   20 7D 5D    		jsr	CHAR		; and it is out there
 2868   4B8D               	LSTVCL:
 2869   4B8D   E8          		inx			; point to next char
 2870   4B8E   BD 00 08    		lda	IOBUFF,X	; get char
 2871   4B91   20 7D 5D    		jsr	CHAR		; print it out
 2872   4B94   88          		dey			; count char
 2873   4B95   D0 F6       		bne	LSTVCL		; go get next char
 2874   4B97   A9 2F       		lda	#'/'		; end with '/' to show volume status
 2875   4B99   20 7D 5D    		jsr	CHAR		; and awaaaaay we go
 2876   4B9C   A9 0D       		lda	#EOL		; do a <CR>
 2877   4B9E   20 7D 5D    		jsr	CHAR		; printed
 2878   4BA1   CA          		dex			; count back one, as loop starts with inx
 2879   4BA2   D0 D2       		bne	LSTVL		; go do next one
 2880   4BA4               	LSTVEX:
 2881   4BA4   60          		rts			; toots finis
 2882                      	;
 2883                      	; CHECKVOLS - set prefix to particular volume that is currently online
 2884                      	;
 2885   4BA5               	CHECKVOLS:
 2886   4BA5   A5 1D       		lda	CHPTR+HI	; is it zero?
 2887   4BA7   D0 1C       		bne	CHV1		; if not, then get next volume
 2888   4BA9               		ONLINE	ONLINE_PB	; get online volumes
 2889   4BA9               		PRODOS	$C5, ONLINE_PB
 2890   4BA9   20 00 BF    		jsr	$BF00	; ProDOS handler
 2891   4BAC   C5          		DB	$C5	; ProDOS function code
 2892   4BAD   4E4B        		DW	ONLINE_PB	; Function Parameter Block address
 2893   4BAF               		.MACEND
 2894   4BAF               		.MACEND
 2895   4BAF   90 02       		bcc	CHV0		; okey dokey
 2896   4BB1               	CHVBX:
 2897   4BB1   38          		sec			; show badness
 2898   4BB2   60          		rts			; all done
 2899   4BB3               	CHV0:
 2900   4BB3   A9 F0       		lda	#<(IOBUFF-16)	; get LSB (-16 cuz we start with add)
 2901   4BB5   85 1C       		sta	CHPTR+LO
 2902   4BB7   A9 08       		lda	#>IOBUFF	; and mSB
 2903   4BB9   85 1D       		sta	CHPTR+HI
 2904   4BBB   A9 02       		lda	#>SCRBUFF		; this is where we will work on it
 2905   4BBD   8D E3 45    		sta	SET_PB+SP_PATHNAME+HI
 2906   4BC0   A9 80       		lda	#<SCRBUFF
 2907   4BC2   8D E2 45    		sta	SET_PB+SP_PATHNAME+LO
 2908   4BC5               	CHV1:
 2909   4BC5   A5 1C       		lda	CHPTR+LO	; point to next entry
 2910   4BC7   18          		clc			; getting ready for add
 2911   4BC8   69 10       		adc	#16		; this points to next one
 2912   4BCA   85 1C       		sta	CHPTR+LO	; can't be any wrapping
 2913   4BCC   A0 00       		ldy	#0		; to use indirect addressing
 2914   4BCE   B1 1C       		lda	(CHPTR),Y	; get length byte
 2915   4BD0   F0 DF       		beq	CHVBX		; all done if == 0
 2916   4BD2   29 0F       		and 	#$0F		; get rid of upper junk
 2917   4BD4   F0 EF       		beq	CHV1		; nothing in this one, do it again
 2918   4BD6   8D 80 02    		sta	SCRBUFF		; save length
 2919   4BD9   EE 80 02    		inc	SCRBUFF		; count the add '/'
 2920   4BDC   A8          		tay			; get for countdown
 2921   4BDD   A9 2F       		lda	#'/'		; need to start with a slash
 2922   4BDF   8D 81 02    		sta	SCRBUFF+1	; okay, we are
 2923   4BE2               	CHVL:
 2924   4BE2   B1 1C       		lda	(CHPTR),Y	; get char in path name
 2925   4BE4   99 81 02    		sta	SCRBUFF+1,Y	; save name
 2926   4BE7   88          		dey			; count char
 2927   4BE8   D0 F8       		bne	CHVL		; go get next one
 2928                      	
 2929   4BEA               		SET_PREFIX SET_PB	; so point to it
 2930   4BEA               		PRODOS	$C6, SET_PB
 2931   4BEA   20 00 BF    		jsr	$BF00	; ProDOS handler
 2932   4BED   C6          		DB	$C6	; ProDOS function code
 2933   4BEE   E145        		DW	SET_PB	; Function Parameter Block address
  Wed May 24 1989 15:00                                                                                                  Page   45

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2934   4BF0               		.MACEND
 2935   4BF0               		.MACEND
 2936   4BF0               	CHVX:
 2937   4BF0   60          		rts			; carry==0, we worked okay
 2938                      	;
 2939                      	; GET_SPECIAL - if we are in infodos, then we preload the first 12Kb of
 2940                      	;   stuff into the area in the main bank, pages $D0-$FF, Language Card 2.
 2941                      	;  Assume .D2 file has just been opened and go get it.
 2942   4BF1               	GET_SPECIAL:
 2943   4BF1   A9 03       	        lda     #RETRY_COUNT
 2944   4BF3   85 16       	        sta     RETRIES         ; how many retries
 2945   4BF5               	GTS_RDL:
 2946   4BF5   A9 00       	        lda     #0              ; make sure we are at the start
 2947   4BF7   8D DE 45    	        sta     PSEEK+SM_FPOS	; set pos to zero
 2948   4BFA   8D DF 45    	        sta     PSEEK+SM_FPOS+1
 2949   4BFD   8D E0 45    	        sta     PSEEK+SM_FPOS+2
 2950   4C00   85 7C       	        sta     K+LO
 2951   4C02   85 7E       	        sta     L+LO            ; make sure these are zero too
 2952   4C04               	        SET_MARK PSEEK		; go back to the beginning
 2953   4C04               		PRODOS	$CE, PSEEK
 2954   4C04   20 00 BF    		jsr	$BF00	; ProDOS handler
 2955   4C07   CE          		DB	$CE	; ProDOS function code
 2956   4C08   DC45        		DW	PSEEK	; Function Parameter Block address
 2957   4C0A               		.MACEND
 2958   4C0A               		.MACEND
 2959   4C0A               	        
 2960   4C0A   A9 02       	        lda     #2              ; one page at a time        
 2961   4C0C   8D D3 45    	        sta     READ_PB+RD_BUFFLEN+HI   ; show how much is special
 2962   4C0F   A9 17       	        lda     #SP_SIZE        ; how many pages in special part?
 2963   4C11   85 7A       	        sta     J+LO            ; use as counter
 2964   4C13   A9 D0       	        lda     #>SP_START      ; where does it go?
 2965   4C15   85 7F       	        sta     L+HI            ; L is pointer to there
 2966   4C17               	GTS_RD:
 2967   4C17   A9 00       	        lda     #MAIN           ; make sure we are in main
 2968   4C19   8D 04 C0    	        sta     WRTBNK+MAIN
 2969   4C1C               	        READ    READ_PB         ; go get 1Kb
 2970   4C1C               		PRODOS	$CA, READ_PB
 2971   4C1C   20 00 BF    		jsr	$BF00	; ProDOS handler
 2972   4C1F   CA          		DB	$CA	; ProDOS function code
 2973   4C20   CE45        		DW	READ_PB	; Function Parameter Block address
 2974   4C22               		.MACEND
 2975   4C22               		.MACEND
 2976   4C22   90 05       	        bcc     GTS_RD1         ; just fine
 2977   4C24   20 07 47    	        jsr     RETRY           ; try again
 2978   4C27   90 CC       	        bcc     GTS_RDL         ; and do it again
 2979   4C29               	GTS_RD1:
 2980   4C29   A2 00       	        ldx     #SP_BANK        ; get bank that special is in
 2981   4C2B   9D 04 C0    	        sta     WRTBNK,X
 2982   4C2E   A9 08       	        lda     #>IOBUFF        ; get MSB of start
 2983   4C30   85 7D       	        sta     K+HI            ; K is source
 2984   4C32   A2 02       	        ldx     #2              ; 2 blocks of 256 bytes each
 2985   4C34               	GTS_CPL0:
 2986   4C34   A0 00       	        ldy     #0              ; indexer
 2987   4C36               	GTS_CPL:
 2988   4C36   B1 7C       	        lda     (K),y           ; get it
 2989   4C38   91 7E       	        sta     (L),y           ; store it
 2990   4C3A   C8          	        iny                     ; next
 2991   4C3B   D0 F9       	        bne     GTS_CPL         ; gwon then
 2992   4C3D   E6 7D       	        inc     K+HI            ; point to next block
 2993   4C3F   E6 7F       	        inc     L+HI            ; for destination too
 2994   4C41   CA          	        dex                     ; count block
 2995   4C42   D0 F0       	        bne     GTS_CPL0        ; next block
 2996   4C44   C6 7A       	        dec     J+LO            ; count this 1Kb
 2997   4C46   D0 CF       	        bne     GTS_RD          ; go get next one
 2998   4C48               	        
 2999   4C48   8D 04 C0    	        sta     WRTBNK+MAIN     ; make sure we are in main
 3000                      	;
 3001                      	; now figger out last page
 3002                      	;
 3003   4C4B   A0 09       	        ldy     #SGTSEG+1       ; get start segment LSB
 3004   4C4D   B1 59       	        lda     (INFODOS),Y     ; got it
 3005   4C4F   18          	        clc                     ; doing add
 3006   4C50   69 17       	        adc     #<SP_SIZE       ; add in size LSB
 3007   4C52   8D A5 6C    	        sta     INFODOS_END+LO  ; save end
 3008   4C55   88          	        dey                     ; point to MSB
  Wed May 24 1989 15:00                                                                                                  Page   46

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 3009   4C56   B1 59       	        lda     (INFODOS),Y     ; got it
 3010   4C58   69 00       	        adc     #>SP_SIZE       ; add in size MSB
 3011   4C5A   8D A6 6C    	        sta     INFODOS_END+HI  ; and save it
 3012   4C5D   AD A5 6C    	        lda     INFODOS_END+LO  ; now, subtract one to make
 3013   4C60   D0 03       	        bne     GTS_END         ; it inclusive
 3014   4C62   CE A6 6C    	        dec     INFODOS_END+HI  ; wrapped, so dec MSB
 3015   4C65               	GTS_END:
 3016   4C65   CE A5 6C    	        dec     INFODOS_END+LO  ; make pointers inclusive
 3017                      	
 3018   4C68   60          	        rts                     ; done
 3019                      	
 3020          [01]        		IF	CHECKSUM == 1
 3021                      	CKS_COUNT: db 0
 3022                      	CKSB:	db	0
 3023                      	CKS_BLOCK:
 3024                      	        pha
 3025                      	        sta     CKSMOD+2
 3026                      	        ldy     #0
 3027                      		lda	CKSB
 3028                      	CKSLP:
 3029                      	        clc
 3030                      	CKSMOD: adc     IOBUFF,Y
 3031                      	        iny
 3032                      	        bne     CKSLP
 3033                      	
 3034                      		sta	CKSB
 3035                      		inc	CKS_COUNT
 3036                      		pla
 3037                      		rts
 3038                      	
 3039          [02]        		IF 	0
 3040                      	        jsr     HEXNUM
 3041                      	        lda     CKS_COUNT
 3042                      	        cmp     #$F
 3043                      	        bne     CKSCNT
 3044                      	        lda     #0
 3045                      	        sta     CKS_COUNT
 3046                      	        lda     #EOL
 3047                      	        bne     CKSSEND
 3048                      	CKSCNT:
 3049                      	        inc     CKS_COUNT
 3050                      	        lda     #SPACE
 3051                      	CKSSEND:
 3052                      	        jsr     CHAR
 3053                      	        jsr     DISP_LINE
 3054                      	        pla
 3055                      	        rts
 3056          [01]        		ENDIF
 3057                      	
 3058          [00]        	        ENDIF
 3059                      	
 3060   4C69               		END
 3061                      	
 3062   4C69               		INCLUDE		MACHINE.ASM
 3063   4C69               		STTL "--- MACHINE-DEPENDENT I/O: APPLE II ---"
 3064                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page   47

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3065                      	; -----------------------
 3066                      	; DIRECT PRINT LINE [X/A]
 3067                      	; -----------------------
 3068                      	; ENTRY: STRING ADDRESS IN [X/A] (LSB/MSB)
 3069                      	; STRING LENGTH IN [Y]
 3070   4C69   00          	DLCNT:	db 	0
 3071   4C6A   00          	DLOFF:	db	0
 3072   4C6B               	DLINE:
 3073   4C6B   8E 85 4C    		stx	STRING+LO	; DROP STRING ADDRESS
 3074   4C6E   8D 86 4C    		sta	STRING+HI	; INTO DUMMY BYTES
 3075   4C71   8C 69 4C    		sty	DLCNT		; COUNTER
 3076   4C74   20 AD 55    	        jsr     CLRBUF          ; send out what's out
 3077   4C77   A5 B1       	        lda     SCREENF         ; save output flag
 3078   4C79   48          	        pha
 3079   4C7A   A2 01       		ldx	#1		; INIT CHAR-FETCH INDEX
 3080   4C7C   86 B1       	        stx     SCREENF         ; make sure screen output is on
 3081   4C7E   CA          	        dex
 3082   4C7F   8E A3 6C    	        stx     CRLF_CHECK      ; don't let swap happen
 3083   4C82   86 AA       		stx	SCRIPT		; don't script any of my internal
 3084   4C84   BD          	DOUT:	DB	$BD		; 6502 "LDA nnnn,X" OPCODE
 3085   4C85   0000        	STRING:	DW	$0000		; DUMMY OPERAND BYTES
 3086   4C87   8E 6A 4C    		stx	DLOFF		; save X
 3087   4C8A   85 AC       	        sta     IOCHAR          ; save here for DIRECT_OUT
 3088   4C8C   20 21 53    	DOUT1:	jsr	DIRECT_OUT      ; send directly out there
 3089   4C8F   AE 6A 4C    		ldx	DLOFF		; get x back
 3090   4C92   E8          		inx
 3091   4C93   CE 69 4C    		dec	DLCNT		; LOOP TILL
 3092   4C96   D0 EC       		bne	DOUT		; OUT OF CHARS
 3093   4C98   20 AD 55    		jsr	CLRBUF		; and force the chars out
 3094   4C9B   A2 01       		ldx	#1		; allow scripting again
 3095   4C9D   86 AA       		stx	SCRIPT		; okay, we did
 3096   4C9F   8E A3 6C    	        stx     CRLF_CHECK      ; and turn on check
 3097   4CA2   68          	        pla                     ; get screen flag back
 3098   4CA3   85 B1       	        sta     SCREENF         ; bingo
 3099   4CA5   60          		rts			; done
 3100                      	
 3101                      	; SWAP2INFOW - save current state and swap to the information window,
 3102                      	;	which is currently window zero
 3103   4CA6               	SWAPA1:	ds	1		; save for current ARG1
 3104   4CA7               	SWAPCW:	ds	1		; save for current window
 3105   4CA8   00          	SWAPFLG: db	0		; flag == 1 if we have already swapped
 3106   4CA9               	SWAP2INFOW:
 3107   4CA9   AD A8 4C    		lda	SWAPFLG		; already swapped?
 3108   4CAC   D0 17       		bne	SWP2		; ayyup
 3109   4CAE   20 AD 55    		jsr	CLRBUF		; clear out the buffer
 3110   4CB1   20 9F 4D    		jsr	SAVE_CURSOR	; save current postion of cursor
 3111   4CB4   A5 63       		lda	ARG1+LO		; get current arg1
 3112   4CB6   8D A6 4C    		sta	SWAPA1		; save it
 3113   4CB9   A5 A6       		lda	CURWIN		; get current window
 3114   4CBB   8D A7 4C    		sta	SWAPCW		; save it
 3115   4CBE   A9 00       		lda	#0		; swap to window zero for messages
 3116   4CC0   85 63       		sta 	ARG1+LO		; okay
 3117   4CC2   20 57 6E    		jsr	ZSCRN		; and swap to it
 3118   4CC5               	SWP2:
 3119   4CC5   EE A8 4C    		inc	SWAPFLG		; show we are in swap window
 3120   4CC8               	SWAPEX:
 3121   4CC8   60          		rts			; all done
 3122                      	;
 3123                      	; SWAPBACK - swap out of info window, and back to old window
 3124                      	;
 3125   4CC9               	SWAPBACK:
 3126   4CC9   CE A8 4C    		dec	SWAPFLG		; are we finally leaving for good?
 3127   4CCC   D0 FA       		bne	SWAPEX		; nope
 3128   4CCE   AD A7 4C    		lda	SWAPCW		; and now for current window
 3129   4CD1   85 63       		sta	ARG1+LO		; swap to it
 3130   4CD3   20 57 6E    		jsr	ZSCRN		; we did
 3131   4CD6   AD A6 4C    		lda	SWAPA1		; and get arg1 back
 3132   4CD9   85 63       		sta 	ARG1+LO		; we did
 3133   4CDB   4C B1 4D    		jmp	GET_CURSOR	; and get cursor back
 3134                      	
 3135                      	; -----------------------
 3136                      	; SEND [LBUFF] TO PRINTER
 3137                      	; -----------------------
 3138                      	; ENTRY: LENTH OF LINE IN [PRLEN]
 3139                      	
  Wed May 24 1989 15:00                                                                                                  Page   48

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3140   4CDE   60          	PLEAV:	RTS		
 3141                      	
 3142   4CDF               	PPRINT:
 3143   4CDF   A5 AA       		lda	SCRIPT		; SCRIPTING INTERNALLY ENABLED?
 3144   4CE1   2D 73 6C    		and	SCRIPTF		; SCRIPTING ON?
 3145   4CE4   2D 74 6C    		and	SCRIPTFLG	; Window allow scripting?
 3146   4CE7   F0 F5       		beq	PLEAV		; NO, EXIT
 3147   4CE9   A5 36       		lda	CSW+LO		; SAVE NORMAL OUTPUT HOOK
 3148   4CEB   48          		pha		
 3149   4CEC   A5 37       		lda	CSW+HI	
 3150   4CEE   48          		pha		
 3151   4CEF   AD 1C 4D    		lda	ALTCSW+LO	; LOAD SCRIPTING HOOK
 3152   4CF2   85 36       		sta	CSW+LO	
 3153   4CF4   AD 1D 4D    		lda	ALTCSW+HI	
 3154   4CF7   85 37       		sta	CSW+HI	
 3155   4CF9   AD 82 C0    	        lda     RDROM           ; put system ROM in for printer out
 3156   4CFC   A0 00       		ldy	#0	
 3157   4CFE               	PP5:
 3158   4CFE   B9 00 02    		lda	LBUFF,Y		;GET A CHAR TO SEND OUT
 3159   4D01   30 05       	        bmi     PP6             ; don't do highlighting
 3160   4D03   09 80       		ora	#$80		; make it apple happy
 3161   4D05   20 ED FD    		jsr	MCOUT	
 3162   4D08               	PP6:
 3163   4D08   C8          		iny		
 3164   4D09   CE 69 6C    		dec	PRLEN		;LINE COUNT
 3165   4D0C   D0 F0       		bne	PP5		;PRINT WHOLE LINE
 3166                      	;
 3167                      	; ALL DONE, RESET TO NORMAL AND LEAVE
 3168                      	;
 3169   4D0E   AD 83 C0    	        lda     BNK2SET         ; write RAM, bank 1
 3170   4D11   AD 83 C0    	        lda     BNK2SET
 3171   4D14   68          		pla		
 3172   4D15   85 37       		sta	CSW+HI	
 3173   4D17   68          		pla		
 3174   4D18   85 36       		sta	CSW+LO	
 3175   4D1A   60          		rts		
 3176                      	
 3177   4D1B   00          	PSTAT:	DB	0	;SET TO CLEAR WHEN BOOT,
 3178                      				;I PUT IT HERE SO RESTART WON'T ALTER
 3179   4D1C   00 00       	ALTCSW:	DB	0,0	;(WORD) PRINTER COUT
 3180                      	
 3181                      		; FIRST TIME USING PRINTER, INITIALIZE IT
 3182   4D1E   0D          	SLOTM:	DB	EOL	
 3183   4D1F   50 72 69 6E 74 		DB	"Printer Slot 1-7: "
        4D24   65 72 20 53 6C 
        4D29   6F 74 20 31 2D 
        4D2E   37 3A 20 
 3184          0013        	SLOTML	EQU	$-SLOTM
 3185                      	
 3186   4D31               	PCHK:	
 3187   4D31   20 A9 4C    		jsr	SWAP2INFOW	; point to info window
 3188   4D34               	PCHK1:
 3189   4D34               		DLINE	SLOTM
 3190   4D34   A2 1E       		ldx	#<SLOTM	; get part of SLOTM
 3191   4D36   A9 4D       		lda	#>SLOTM	; get other part of string
 3192          [01]        		IFMA	2		; check to see if length passed in
 3193                      		ldy	M		; then just fetch it
 3194          [01]        		ELSE
 3195   4D38   A0 13       		ldy	#SLOTML	; get length of string
 3196          [00]        		ENDIF
 3197   4D3A   20 6B 4C    		jsr	DLINE		; print the string
 3198   4D3D               		.MACEND
 3199   4D3D   20 31 51    		jsr	GETKEY	
 3200   4D40   C9 38       		cmp	#'8'		;1-7
 3201   4D42   B0 F0       		bcs	PCHK1		;OOPS
 3202   4D44   C9 31       		cmp	#'1'		; less than '1'?
 3203   4D46   90 EC       		bcc	PCHK1		; ayyup
 3204   4D48               	PC2:
 3205   4D48   49 F0       		eor	#$F0		; make it a slot address	
 3206   4D4A   8D 1D 4D    		sta	ALTCSW+HI	
 3207   4D4D   A9 0D       		lda	#EOL
 3208   4D4F   20 7D 5D    		jsr	CHAR		;SEND >CR< TO SCREEN FOR NEATNESS
 3209   4D52   EE 1B 4D    		inc	PSTAT		;SET TO ON
 3210   4D55   A5 36       		lda	CSW+LO		;SAVE NORMAL OUTPUT HOOK
 3211   4D57   48          		pha		
  Wed May 24 1989 15:00                                                                                                  Page   49

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3212   4D58   A5 37       		lda	CSW+HI	
 3213   4D5A   48          		pha		
 3214   4D5B   AD 1C 4D    		lda	ALTCSW+LO	;LOAD SCRIPTING HOOK
 3215   4D5E   85 36       		sta	CSW+LO	
 3216   4D60   AD 1D 4D    		lda	ALTCSW+HI	
 3217   4D63   85 37       		sta	CSW+HI	
 3218   4D65   20 98 4D    		jsr	INITPRT		; now, init it 
 3219                      	
 3220   4D68   AD 82 C0    	        lda     RDROM           ; bring in system ROM
 3221   4D6B   A9 89       		lda	#$89		; OUTPUT PRINTER SETUP SEQUENCE
 3222   4D6D   20 ED FD    		jsr	MCOUT		; START WITH COMMAND CHAR >CTRL-I<
 3223   4D70   A9 B8       		lda	#$B8		; 8 (80 COL WIDE)
 3224   4D72   20 ED FD    		jsr	MCOUT	
 3225   4D75   A9 B0       		lda	#$B0		; 0
 3226   4D77   20 ED FD    		jsr	MCOUT	
 3227   4D7A   A9 CE       		lda	#$CE		; N (LF AFTER CR)
 3228   4D7C   20 ED FD    		jsr	MCOUT	
 3229   4D7F   A5 36       		lda	CSW+LO		; SAVE REAL PRINTER OUTPUT
 3230   4D81   8D 1C 4D    		sta	ALTCSW+LO	; LOC. FOR NEXT TIME
 3231   4D84   A5 37       		lda	CSW+HI	
 3232   4D86   8D 1D 4D    		sta	ALTCSW+HI	
 3233   4D89   68          		pla			; RESET NORMAL OUTPUT
 3234   4D8A   85 37       		sta	CSW+HI	
 3235   4D8C   68          		pla		
 3236   4D8D   85 36       		sta	CSW+LO	
 3237   4D8F   AD 83 C0    	        lda     BNK2SET         ; and bring back top RAM
 3238   4D92   AD 83 C0    	        lda     BNK2SET         ; okay
 3239   4D95   4C C9 4C    		jmp	SWAPBACK	; and back to the old window
 3240   4D98               	INITPRT:
 3241   4D98   A9 00       		lda	#0		; jump to $Cn00
 3242   4D9A   85 36       		sta	CSW+LO		; make LSB == 0
 3243   4D9C   6C 36 00    		jmp	(CSW)		; and goto it
 3244                      	
 3245                      	
 3246   4D9F               	SAVE_CURSOR:
 3247   4D9F   A5 01       		lda	SCRCY		; save the cursor pos
 3248   4DA1   A0 04       		ldy	#WINY		; get offset
 3249   4DA3   91 05       		sta	(WINDOW),Y	; first y pos
 3250   4DA5   C8          		iny			; now x pos
 3251   4DA6   A5 00       		lda	SCRCX		; got it
 3252   4DA8   91 05       		sta	(WINDOW),Y	; saved it
 3253   4DAA   A0 13       		ldy	#WINLCNT	; reset line count too
 3254   4DAC   A5 AB       		lda	LINCNT		; okay
 3255   4DAE   91 05       		sta	(WINDOW),Y	; get it
 3256   4DB0   60          		rts
 3257                      	
 3258   4DB1               	GET_CURSOR:
 3259   4DB1   A0 04       		ldy	#WINY		; get cursor pos back
 3260   4DB3   B1 05       		lda	(WINDOW),Y	; got y pos
 3261   4DB5   85 01       		sta	SCRCY		; saved
 3262   4DB7   C8          		iny			; point to x pos
 3263   4DB8   B1 05       		lda	(WINDOW),Y	; got it
 3264   4DBA   85 00       		sta	SCRCX		; make it better
 3265   4DBC   38          		sec			; subtract left margin to get how long line is
 3266   4DBD   E5 04       		sbc	LEFTMRG		; okay we did that
 3267   4DBF   B0 02       	        bcs     GETCR1          ; make sure left margin is not > cur x pos
 3268   4DC1   A9 00       	        lda     #0              ; otherwise, pretend length is zero
 3269   4DC3               	GETCR1:
 3270   4DC3   85 A7       		sta	LENGTH+LO	; this is how big line is too
 3271   4DC5   A9 00       		lda	#0		; clear MSB
 3272   4DC7   85 A8       		sta	LENGTH+HI
 3273   4DC9   06 A7       		asl	LENGTH+LO	; *2
 3274   4DCB   26 A8       		rol	LENGTH+HI
 3275   4DCD   06 A7       		asl	LENGTH+LO	; *4
 3276   4DCF   26 A8       		rol	LENGTH+HI
 3277   4DD1               		
 3278   4DD1   A0 13       		ldy	#WINLCNT	; reset line count too
 3279   4DD3   B1 05       		lda	(WINDOW),Y	; get it
 3280   4DD5   85 AB       		sta	LINCNT		; okay
 3281   4DD7   A9 01       		lda	#1		; show cursor changed (maybe)
 3282   4DD9   8D 77 6C    		sta	CURSFLG		; okay
 3283   4DDC   60          		rts
 3284                      	
 3285                      	; ------------
 3286                      	; SPLIT SCREEN
  Wed May 24 1989 15:00                                                                                                  Page   50

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3287                      	; ------------
 3288                      	;
 3289                      	; SPLIT SCREEN AT LINE [ARG1] putting screen 1 at top and screen
 3290                      	; 0 at bottom.
 3291                      	; DISABLE SPLIT IF [ARG1] = 0
 3292                      	;
 3293   4DDD               	ZSPLIT:
 3294   4DDD   20 9F 4D    		jsr	SAVE_CURSOR	; save the cursor pos
 3295                      	;
 3296                      	; first muck with window 1
 3297                      	;
 3298   4DE0   A5 63       		lda	ARG1+LO		; get split arg back
 3299   4DE2   8D A1 6D    		sta	WINDOW1+WINHGHT	; this becomes the height of window 1
 3300   4DE5   A9 00       		lda	#0		; put top of 1 to top of screen
 3301   4DE7   8D 9F 6D    		sta	WINDOW1+WINTOP	; okay, we did it
 3302   4DEA   A5 63       		lda	ARG1+LO		; get new height
 3303   4DEC   A2 FF       		ldx	#$FF		; this is the counter
 3304   4DEE   38          		sec			; get ready for subs
 3305   4DEF               	ZSPLIT0:
 3306   4DEF   E8          		inx			; count this line
 3307   4DF0   E9 09       		sbc	#FONT_H		; subtract off font height	
 3308   4DF2   B0 FB       		bcs	ZSPLIT0		; still some lines	
 3309   4DF4   CA          		dex			; save input line
 3310   4DF5   8E B6 6D    		stx	WINDOW1+WINLINES ; saved
 3311                      	
 3312   4DF8   AD A3 6D    		lda	WINDOW1+WINY	; check cursor pos
 3313   4DFB   C5 63       		cmp	ARG1+LO		; against height
 3314   4DFD   90 11       		bcc	ZSPL1		; inside window, so save it
 3315   4DFF               	ZSPL0:
 3316   4DFF   A9 00       		lda	#0		; reset to top left
 3317   4E01   8D A3 6D    		sta	WINDOW1+WINY	; y pos at top
 3318   4E04   8D A4 6D    		sta	WINDOW1+WINX	; x pos at left
 3319   4E07   8D B4 6D    		sta	WINDOW1+WINLLEN+LO	; line length
 3320   4E0A   8D B5 6D    		sta	WINDOW1+WINLLEN+HI	; line length
 3321   4E0D   8D B2 6D    		sta	WINDOW1+WINLCNT	; line counter
 3322                      	;
 3323                      	; now muck with window 0
 3324                      	;
 3325   4E10               	ZSPL1:
 3326   4E10   AD 87 6D    		lda	WINDOW0+WINTOP	; top of window 0
 3327   4E13   38          		sec			; doing sub
 3328   4E14   E5 63       		sbc	ARG1+LO		; subtract out the new top
 3329   4E16   18          		clc			; adding
 3330   4E17   6D 89 6D    		adc	WINDOW0+WINHGHT	; to get the new height
 3331                      	;	bcc	ZSPLIT1		; okay, positive height
 3332                      	;	lda	#0		; make height 0
 3333   4E1A               	ZSPLIT1:
 3334   4E1A   8D 89 6D    		sta	WINDOW0+WINHGHT	; and save new height
 3335   4E1D               		
 3336   4E1D   A2 FF       		ldx	#$FF		; this is the counter
 3337   4E1F   38          		sec			; get ready for subs
 3338   4E20               	ZSPLIT2:
 3339   4E20   E8          		inx			; count this line
 3340   4E21   E9 09       		sbc	#FONT_H		; subtract off font height	
 3341   4E23   B0 FB       		bcs	ZSPLIT2		; still some lines	
 3342   4E25   CA          		dex			; to save input line
 3343   4E26   8E 9E 6D    		stx	WINDOW0+WINLINES ; saved
 3344                      	
 3345   4E29   A5 63       		lda	ARG1+LO		; this is the new top
 3346   4E2B   8D 87 6D    		sta	WINDOW0+WINTOP	; set in structure
 3347   4E2E   CD 8B 6D    		cmp	WINDOW0+WINY	; make sure cursor is still in window
 3348   4E31   F0 13       		beq	ZSPL5		; nope, at the top
 3349   4E33   90 11       		bcc	ZSPL5		; or under it
 3350   4E35   8D 8B 6D    		sta	WINDOW0+WINY	; put cursor at top
 3351   4E38   A9 00       		lda	#0		; left of new
 3352   4E3A   8D 8C 6D    		sta	WINDOW0+WINX	; window 0
 3353   4E3D   8D 9C 6D    		sta	WINDOW0+WINLLEN+LO	; linelength
 3354   4E40   8D 9D 6D    		sta	WINDOW0+WINLLEN+HI	; linelength
 3355   4E43   8D 9A 6D    		sta	WINDOW0+WINLCNT	; line counter
 3356   4E46               	ZSPL5:
 3357   4E46   20 B1 4D    		jsr	GET_CURSOR	; get the cursor pos back
 3358                      	
 3359   4E49   A9 00       		lda	#0		; now switch to window zero
 3360   4E4B   85 63       		sta	ARG1+LO		; good bye
 3361   4E4D   4C 57 6E    		jmp	ZSCRN		; making window 0 be current
  Wed May 24 1989 15:00                                                                                                  Page   51

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3362                      	
 3363                      	; ------
 3364                      	; MARGIN
 3365                      	; ------
 3366                      	;
 3367                      	; Set the margins for the window
 3368                      	;
 3369                      	;  ARG1 - left margin
 3370                      	;  ARG2 - right margin
 3371                      	;  ARG3 - window ID (optional)
 3372                      	;
 3373   4E50               	ZMARG:
 3374   4E50   20 AD 55    		jsr	CLRBUF		; CLEAR LBUFF BEFORE RESETTING LINE MARGINS
 3375   4E53   20 9F 4D    		jsr	SAVE_CURSOR	; save current cursor pos
 3376   4E56               		
 3377   4E56   A5 62       		lda	NARGS		; see if window ID was passed
 3378   4E58   C9 03       		cmp	#3		; if ==3, then it's there
 3379   4E5A   F0 04       		beq	ZMRG1		; okay, so use it
 3380   4E5C   A5 A6       		lda	CURWIN		; get the current window
 3381   4E5E   85 67       		sta	ARG3+LO		; and use as the default
 3382   4E60               	ZMRG1:
 3383   4E60   A5 67       		lda	ARG3+LO		; check what window
 3384   4E62   20 77 57    		jsr	SETWJ		; get window offset into J
 3385   4E65   A5 63       		lda	ARG1+LO		; do left margin first
 3386   4E67   A0 06       		ldy	#WINLM		; get offset
 3387   4E69   91 7A       		sta	(J),Y		; save for window
 3388   4E6B   C8          		iny			; point to right margin
 3389   4E6C   A5 65       		lda	ARG2+LO		; get right margin
 3390   4E6E   91 7A       		sta	(J),Y		; save right margin
 3391   4E70   A0 03       		ldy	#WINWID		; get full width of window
 3392   4E72   B1 7A       		lda	(J),Y		; got it
 3393   4E74   38          		sec			; subtract off the 2 margins
 3394   4E75   A0 06       		ldy	#WINLM		; first the left margin
 3395   4E77   F1 7A       		sbc	(J),Y		; okay, gone
 3396   4E79   C8          		iny			; point to right margin
 3397   4E7A   F1 7A       		sbc	(J),Y		; and take it off	
 3398   4E7C   A0 14       		ldy	#WINXSZ		; set width of usable window
 3399   4E7E   91 7A       		sta	(J),Y		; see, here it is
 3400                      	;
 3401                      	; move cursor to left margin
 3402                      	;
 3403   4E80   A0 01       		ldy	#WINLEFT	; get left edge
 3404   4E82   B1 7A       		lda	(J),Y		; got it
 3405   4E84   A0 06       		ldy	#WINLM		; and add left margin
 3406   4E86   18          		clc			; adding
 3407   4E87   71 7A       		adc	(J),Y		; to get minimum X
 3408   4E89   A0 05       		ldy	#WINX		; check to make sure X pos is okay
 3409   4E8B   91 7A       		sta	(J),Y		; then reset it
 3410                      	;
 3411                      	; now see if we changed the current window
 3412                      	;
 3413   4E8D               	ZMRGXP:
 3414   4E8D   A6 67       		ldx	ARG3+LO		; get the window
 3415   4E8F   30 04       		bmi	ZMRG3		; -3 means current window
 3416   4E91   E4 A6       		cpx	CURWIN		; check against the current window
 3417   4E93   D0 17       		bne	ZMRGX		; nope, so we be done
 3418   4E95               	ZMRG3:
 3419   4E95   85 04       		sta	LEFTMRG		; [A] already has left margin
 3420   4E97   A0 14       		ldy	#WINXSZ		; get xsize to set
 3421   4E99   B1 05       		lda	(WINDOW),Y	; got it
 3422   4E9B   85 A2       		sta	XSIZE+LO	; this is for quicky comparing
 3423   4E9D   A9 00       		lda	#0		; clear MSB
 3424   4E9F   85 A3       		sta	XSIZE+HI
 3425   4EA1   06 A2       		asl	XSIZE+LO	; *2
 3426   4EA3   26 A3       		rol	XSIZE+HI
 3427   4EA5   06 A2       		asl	XSIZE+LO	; *4
 3428   4EA7   26 A3       		rol	XSIZE+HI
 3429   4EA9   20 B1 4D    		jsr	GET_CURSOR	; restore the cursor pos
 3430   4EAC               	ZMRGX:
 3431   4EAC   60          		rts
 3432                      	;
 3433                      	; SOUND
 3434                      	; -----
 3435                      	; ARG1 = BOOP (2) BEEP (1) ALL OTHERS INVALID
 3436                      	; (EZIP)
  Wed May 24 1989 15:00                                                                                                  Page   52

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3437                      	
 3438   4EAD               	ZSOUND:
 3439   4EAD   A6 63       		ldx	ARG1+LO	; GET SOUND WANTED
 3440   4EAF   CA          		dex		
 3441   4EB0   F0 11       		beq	BEEP	
 3442   4EB2   CA          		dex		
 3443   4EB3   D0 0D       		bne	ZSOEX	; INVALID
 3444   4EB5   A0 FF       		ldy	#$FF	; DURATION ($C0 = .1 SEC)
 3445   4EB7               	BOOP:
 3446   4EB7   A9 10       		lda	#$10	; TONE ($0C = 1 KHZ)
 3447   4EB9   20 27 4F    		jsr	WAIT10
 3448   4EBC   AD 30 C0    		lda	SPKR	; TOGGLE SPEAKER
 3449   4EBF   88          		dey
 3450   4EC0   D0 F5       		bne	BOOP	
 3451   4EC2               	ZSOEX:
 3452   4EC2   60          		rts		
 3453                      	
 3454   4EC3               	BEEP:
 3455   4EC3   AD 82 C0    	        lda     RDROM
 3456   4EC6   20 3A FF    		jsr	MBELL	; just use system beep
 3457   4EC9   AD 83 C0    	        lda     BNK2SET ; back to bank 2
 3458   4ECC   AD 83 C0    	        lda     BNK2SET ; back to bank 2
 3459   4ECF   60          	        rts
 3460                      	;
 3461                      	; just do the background color - foreground is always white/black
 3462                      	;
 3463                      	;
 3464                      	; ZIPCOLOR - maps ZIP colors to screen colors
 3465                      	;
 3466   4ED0               	ZCOLOR:
 3467   4ED0   20 AD 55    		jsr	CLRBUF		; print out what we have
 3468                      	
 3469   4ED3   A5 62       		lda 	NARGS		; check if window was passed
 3470   4ED5   C9 03       		cmp	#3		; was it?
 3471   4ED7   F0 04       		beq	ZCLR0		; ayyup
 3472   4ED9   A5 A6       		lda	CURWIN		; make it current window
 3473   4EDB   85 67       		sta	ARG3+LO		; it is now
 3474   4EDD               	ZCLR0:
 3475   4EDD   A5 67       		lda	ARG3+LO		; get window ID
 3476   4EDF   20 77 57    		jsr	SETWJ		; and put pointer into J
 3477                      	
 3478   4EE2   A6 65       		ldx 	ARG2+LO		; get background color
 3479   4EE4   F0 15       		beq	ZCLR2		; check fore ground color
 3480   4EE6   10 06       		bpl	ZCLR01		; not -1
 3481   4EE8   20 0B 5E    		jsr	GET_NYBBLE	; get me the color nybble here
 3482   4EEB   4C F7 4E    		jmp	ZCLR11		; and use as background color
 3483   4EEE               	ZCLR01:
 3484   4EEE   CA          		dex			; check for default
 3485   4EEF   D0 02       		bne	ZCLR1		; nope, find the color
 3486   4EF1   A2 01       		ldx	#1		; use black as default back color
 3487   4EF3               	ZCLR1:
 3488   4EF3   CA          		dex			; zero base the color
 3489   4EF4   BD 3F 6C    		lda	ZIPCOLOR,X	; get my color from the zip color
 3490   4EF7               	ZCLR11:
 3491   4EF7   A0 0E       		ldy	#WINBGND	; get background offset
 3492   4EF9   91 7A       		sta	(J),Y		; saved color
 3493                      	;
 3494                      	; now do foreground color
 3495                      	;
 3496   4EFB               	ZCLR2:
 3497   4EFB   A6 63       		ldx 	ARG1+LO		; get foreground color
 3498   4EFD   F0 0E       		beq	ZCLREX		; no change
 3499   4EFF   CA          		dex			; check for default
 3500   4F00   D0 02       		bne	ZCLR3		; nope, find the color
 3501   4F02   A2 08       		ldx	#8		; use white as default fore color
 3502   4F04               	ZCLR3:
 3503   4F04   CA          		dex			; zero base the color
 3504   4F05   BD 3F 6C    		lda	ZIPCOLOR,X	; get my color from the zip color
 3505   4F08   A0 0D       		ldy	#WINFORE	; foreground color offset
 3506   4F0A   8A          		txa			; get into A for fun
 3507   4F0B   91 7A       		sta	(J),Y		; save in structure
 3508   4F0D               	ZCLREX:
 3509   4F0D   60          		rts
 3510                      	
 3511                      	;
  Wed May 24 1989 15:00                                                                                                  Page   53

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3512                      	; CHKTME RTN - CALLED BY INPUT & ZINPUT
 3513                      	;
 3514   4F0E               	CHKTME:	
 3515   4F0E   A5 62       		lda	NARGS		; CHECK IF TIME LIMIT
 3516   4F10   C9 02       		cmp	#2
 3517   4F12   F0 12       		beq	CHKT1		; NO
 3518   4F14   A5 67       		lda	ARG3+LO		; GET DELAY WANTED
 3519   4F16   85 79       		sta	I+HI
 3520   4F18   A5 62       		lda	NARGS		; IS THERE A FCN?
 3521   4F1A   C9 04       		cmp	#4
 3522   4F1C   D0 08       		bne	CHKT1		; NO
 3523   4F1E   A5 69       		lda	ARG4+LO		; YES, SET IT
 3524   4F20   85 7A       		sta	J+LO
 3525   4F22   A5 6A       		lda	ARG4+HI
 3526   4F24   85 7B       		sta	J+HI
 3527   4F26               	CHKT1:
 3528   4F26   60          		rts			; just set things up, please
 3529                      	
 3530   4F27               	WAIT10:
 3531   4F27   A9 02       	        lda     #2              ; do this twice (maybe)
 3532   4F29   85 C6       	        sta     DELAY_COUNTER   ; put in counter
 3533   4F2B               	WAIT0:
 3534   4F2B   AD 82 C0    	        lda     RDROM           ; get roms in
 3535   4F2E   A2 04       		ldx	#4		; .04 SEC (time to do other stuff)
 3536   4F30   A9 30       	TIME1:	lda	#$30		; .01 SEC
 3537   4F32   20 A8 FC    		jsr	MWAIT	
 3538   4F35   CA          		dex		
 3539   4F36   D0 F8       		bne	TIME1	
 3540                      	
 3541   4F38   AD 83 C0    	        lda     BNK2SET         ; get roms out
 3542   4F3B   AD 83 C0    	        lda     BNK2SET
 3543                      	
 3544   4F3E   A5 58       		lda	MOUSEF		; move mouse cursor?
 3545   4F40   F0 08       		beq	WAIT1		; nope
 3546   4F42   AD A4 6C    	        lda     PTR_COUNT       ; but do we really want to check it
 3547   4F45   D0 03       	        bne     WAIT1           ; nope
 3548   4F47   4C 2B 50    		jmp	MOVE_MC		; move cursor, if necessary
 3549   4F4A               	WAIT1:
 3550   4F4A   C6 C6       	        dec     DELAY_COUNTER   ; count loop
 3551   4F4C   D0 DD       	        bne     WAIT0           ; go do again
 3552   4F4E   60          		rts
 3553                      	;
 3554                      	; tick the ol timer
 3555                      	;
 3556   4F4F               	TIMEK:
 3557   4F4F   A9 03       		lda	#BLINK_RATE	; how often to blink
 3558   4F51   8D 92 4F    		sta	CURCOUNT	; okay!
 3559   4F54               	TIMEST:
 3560   4F54   A5 78       		lda	I+LO		; don't reset if not zero
 3561   4F56   D0 07       		bne	TIMELOOP	; so keep goin' then
 3562   4F58   A5 79       		lda	I+HI
 3563   4F5A   85 78       		sta	I+LO
 3564   4F5C   20 93 4F    		jsr	STCUR		; start the cursor
 3565   4F5F               	TIMELOOP:
 3566   4F5F   20 27 4F    		jsr	WAIT10		; wait .10 secs
 3567                      	
 3568   4F62   20 E6 4F    		jsr	FKEYX		; Check for Keystroke
 3569   4F65   30 23       		bmi	TIME2		; OK, HE'S THERE, CONTINUE
 3570                      	
 3571   4F67   CE 92 4F    		dec	CURCOUNT	; count down to toggle
 3572   4F6A   D0 08       		bne	TMCNT		; okay, no blink
 3573   4F6C   20 93 4F    		jsr	STCUR		; blink cursor
 3574   4F6F   A9 03       		lda	#BLINK_RATE	; once per second
 3575   4F71   8D 92 4F    		sta	CURCOUNT	; okay!
 3576   4F74               	TMCNT:
 3577   4F74   C6 78       		dec	I+LO		; 10TH'S OF SECONDS TO WAIT
 3578   4F76   F0 02       		beq	TIMEOUT		; SOME TIME LEFT
 3579                      	
 3580   4F78   D0 E5       		bne	TIMELOOP	; so gwon back and try again! (JMP)
 3581                      	;
 3582                      	; THERE IS A TIME OUT, CHECK FOR A FCN
 3583                      	;
 3584   4F7A               	TIMEOUT:
 3585   4F7A   20 BE 4F    		jsr	ERCUR		; after erasing cursor
 3586   4F7D   A5 7B       		lda	J+HI		; IS THERE A FCN
  Wed May 24 1989 15:00                                                                                                  Page   54

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3587   4F7F   F0 0E       		beq	TIMEBAD		; NO FCN, LEAVE WITH NOTHING
 3588   4F81               	TIME3:
 3589   4F81   20 13 5B    		jsr	INTCLL		; INTERNALLY CALL THE FCN
 3590   4F84   A5 76       		lda	VALUE+LO	; CHECK RESULTS
 3591   4F86   F0 CC       		beq	TIMEST		; ELSE TRY AGAIN
 3592   4F88   D0 05       		bne	TIMEBAD		; else die a horrible death!
 3593   4F8A               	TIME2:
 3594   4F8A   20 BE 4F    		jsr	ERCUR		; after erasing cursor
 3595   4F8D   18          		clc			; GOT A KEY
 3596   4F8E   60          		rts
 3597   4F8F               	TIMEBAD:
 3598   4F8F   38          		sec
 3599   4F90   60          		rts
 3600                      	;
 3601                      	; display the cursor in the current spot
 3602                      	;
 3603   4F91   80          	CURSTATE:	db	$80	; blinking cursor state
 3604   4F92   00          	CURCOUNT:	db	0	; toggle counter
 3605                      	
 3606   4F93               	STCUR:
 3607   4F93   AD A2 6C    	        lda     CURSOR_OFF      ; is the cursor off?
 3608   4F96   F0 01       	        beq     STCUR1          ; no
 3609   4F98   60          	        rts                     ; yes, so don't do nuthin'
 3610   4F99               	STCUR1:
 3611   4F99   48          		pha			; save a
 3612   4F9A   A5 BB       		lda	INVFLG		; get current INVFLG
 3613   4F9C   48          		pha			; save it
 3614   4F9D   A9 80       		lda	#$80		; make it all be ones
 3615   4F9F   85 BB       		sta	INVFLG		; and blink
 3616                      	
 3617   4FA1   A9 20       		lda	#SPACE		; space for cursor
 3618   4FA3   8D DE 71    		sta	SHOW_CURSOR	; show that we are doing cursor
 3619   4FA6   20 7D 5D    		jsr	CHAR		; and print it out
 3620   4FA9   20 EC 71    		jsr	DISP_LINE	; send it out
 3621                      	
 3622   4FAC   AD 91 4F    		lda	CURSTATE	; get current state
 3623   4FAF   49 80       		eor	#$80		; toggle it
 3624   4FB1   8D 91 4F    		sta	CURSTATE	; save it
 3625   4FB4   68          		pla			; get invflg
 3626   4FB5   85 BB       		sta	INVFLG		; restored
 3627   4FB7   A9 00       		lda	#0		; clear cursor flag
 3628   4FB9   8D DE 71    		sta	SHOW_CURSOR	; okay
 3629   4FBC               		
 3630   4FBC   68          		pla
 3631   4FBD   60          		rts
 3632                      	;
 3633                      	; just erase the cusor char, but leave cursor in its old place
 3634                      	;
 3635   4FBE               	ERCUR:
 3636   4FBE   48          		pha			; save a
 3637   4FBF   AD 91 4F    		lda	CURSTATE	; get current state
 3638   4FC2   D0 03       		bne	ERCURX		; not on, leave alone
 3639   4FC4   20 93 4F    		jsr	STCUR		; 'start' it out
 3640   4FC7               	ERCURX:
 3641   4FC7   68          		pla			; retrieve [A]
 3642   4FC8   60          		rts
 3643                      	;
 3644                      	; timed key input loop
 3645                      	;
 3646                      	; carry set if timed out
 3647                      	; char in [A], if there is one!
 3648   4FC9               	TIMIN:
 3649   4FC9   A5 58       		lda	MOUSEF		; is there a mouse/joystick?
 3650   4FCB   F0 03       		beq	TIMIN1		; nope
 3651   4FCD   20 B5 62    		jsr	MSCON		; turn on mouse cursor
 3652   4FD0               	TIMIN1:
 3653   4FD0   20 4F 4F    		jsr	TIMEK		; check for keystroke
 3654   4FD3   B0 05       		bcs	TMBAD		; ELSE ABORT
 3655   4FD5               	TM1:
 3656   4FD5   20 8B 51    		jsr	PARSEKEY	; GET ASCII INTO [A] AND [IOCHAR]
 3657   4FD8   B0 F6       		bcs	TIMIN1		; c==1 means no good char
 3658   4FDA               	TMBAD:
 3659   4FDA   A6 58       		ldx	MOUSEF		; is there a mouse/joystick?
 3660   4FDC   F0 07       		beq	TIMIN2		; nope
 3661   4FDE   08          		php			; save status
  Wed May 24 1989 15:00                                                                                                  Page   55

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3662   4FDF   48          		pha			; save (possible) char
 3663   4FE0   20 56 62    		jsr	MSCOFF		; turn off mouse cursor
 3664   4FE3   68          		pla			; get char back
 3665   4FE4   28          		plp			; get return status
 3666   4FE5               	TIMIN2:
 3667   4FE5   60          		rts			; and away we go
 3668                      	;
 3669                      	; FKEYX - move the mouse cursor if any, then check for keystroke
 3670                      	;
 3671   4FE6               	FKEYX:
 3672   4FE6   A5 58       		lda	MOUSEF		; is there a mouse cursor?
 3673   4FE8   F0 38       		beq	KEYX		; nope
 3674   4FEA   30 07       		bmi	KEYMOUSE	; handle mouse
 3675   4FEC   20 AD 50    		jsr	DO_STICK	; handle joystick
 3676   4FEF   10 31       		bpl	KEYX		; go look for key still
 3677   4FF1   30 05       		bmi	KEYBTN		; do button handling
 3678   4FF3               	KEYMOUSE:
 3679   4FF3   20 6E 50    		jsr	DO_MOUSE	; handle mouse stuff
 3680   4FF6   10 2A       		bpl	KEYX		; go look for key still
 3681                      	;
 3682                      	; button hit, so show pos in MSTBL
 3683                      	;
 3684   4FF8               	KEYBTN:
 3685   4FF8   48          		pha			; save status
 3686   4FF9   A5 CE       		lda	MSTBL+LO
 3687   4FFB   85 8F       		sta	SPCL
 3688   4FFD   A5 CF       		lda	MSTBL+HI
 3689   4FFF   85 90       		sta 	SPCH
 3690   5001   A5 D0       		lda	MSTBL+ABANK
 3691   5003   85 91       		sta	SPCBNK
 3692   5005   A9 03       		lda	#ZMSLOCX+1	; point to LSB of mouse x
 3693   5007   20 01 90    		jsr	ADDSPC		; add to point
 3694   500A   A5 CB       		lda	MSX		; get X
 3695   500C   18          	        clc                     ; center the hot spot
 3696   500D   69 01       	        adc     #CURSW/2        ; add 1/2 width
 3697   500F   20 35 92    		jsr	STASHB		; and stuff it away
 3698   5012   A9 02       		lda	#2		; 2 more to get to mouse y
 3699   5014   20 01 90    		jsr	ADDSPC		; okay
 3700   5017   A5 CC       		lda	MSY		; now show the world the y pos
 3701   5019   18          	        clc                     ; and center vertically too
 3702   501A   69 02       	        adc     #CURSH/2        ; add 1/2 height
 3703   501C   20 35 92    		jsr	STASHB		; and it is away
 3704   501F   68          		pla			; get status back
 3705   5020   A8          		tay			; and set it again
 3706   5021   60          		rts			; otherwise, done
 3707   5022               	KEYX:
 3708   5022   AD 00 C0    		lda	KBD		; check keyboard strobe
 3709   5025   10 03       		bpl	KEYXX		; nothing
 3710   5027   8D 10 C0    		sta	ANYKEY		; reset strobe
 3711   502A               	KEYXX:
 3712   502A   60          		rts
 3713                      	;
 3714                      	; MOVE_MC - move the mouse/joystick cursor, if necessary
 3715                      	;
 3716   502B               	MOVE_MC:
 3717   502B   A5 58       		lda	MOUSEF		; check which kind to move
 3718   502D   10 06       		bpl	MOVE_MC1	; move joystick cursor
 3719   502F   20 41 50    		jsr	CHK_MOUSE	; move the mouse cursor
 3720   5032   4C 38 50    		jmp 	MOVE_MC2	; and print it
 3721   5035               	MOVE_MC1:
 3722   5035   20 B3 50    		jsr	MOVE_STICK	; okay, checked it out
 3723   5038               	MOVE_MC2
 3724   5038   AD 12 03    		lda	MSMOVEF		; did it move?
 3725   503B   F0 03       		beq	MOVE_MCX	; nope
 3726   503D   4C 4B 62    		jmp	MSCURS		; print it
 3727   5040               	MOVE_MCX:
 3728   5040   60          		rts			; done
 3729                      	;
 3730                      	; CHK_MOUSE - check the mouse position and button state, and flag any change
 3731                      	;
 3732   5041               	CHK_MOUSE:
 3733   5041   AD 54 C0    		lda	PAGE2SW		; make sure we are pointing to main bank
 3734                      	
 3735   5044   A2 02       		ldx	#READM		; get me current cursor pos
 3736   5046   20 00 03    		jsr	MOUSER		; turn off interrupts and set current pos
  Wed May 24 1989 15:00                                                                                                  Page   56

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3737                      	
 3738   5049   AD 83 C0    		lda	BNK2SET		; make sure we are pointing to second bank
 3739   504C   AD 83 C0    		lda	BNK2SET		; okay
 3740                      	
 3741   504F   AD 78 07    	MSFIX0	lda	MOUSEST		; get status byte
 3742   5052   A8          		tay			; save for a sec
 3743   5053   29 20       		and	#$20		; moved since last time?
 3744   5055   F0 0D       		beq	CHKM1		; nope
 3745   5057   8D 12 03    		sta	MSMOVEF		; show movement
 3746   505A   AD 78 04    	MSFIX1	lda	MOUSEXL		; get mouse X pos
 3747   505D   85 CB       		sta	MSX		; save new one
 3748   505F   AD F8 04    	MSFIX2	lda	MOUSEYL		; and the y pos
 3749   5062   85 CC       		sta	MSY		; save for me
 3750   5064               	CHKM1:
 3751   5064   98          		tya			; get status back
 3752   5065   29 C0       		and	#$C0            ; is button down?
 3753   5067   F0 02       		beq	CHKMX		; nope
 3754   5069   A9 80       		lda	#$80            ; show down state
 3755   506B               	CHKMX:
 3756   506B   4C 25 51    	        jmp     CHK_BTN         ; check button state
 3757                      	;
 3758                      	; there is a mouse, so check it		 
 3759                      	;
 3760   506E               	DO_MOUSE:
 3761   506E   20 41 50    		jsr	CHK_MOUSE	; check the mouse please
 3762                      	; FALL THROUGH TO BUTTON CLICKING HANDLER
 3763                      	;	jmp	DO_BUTTON	; handle button clicking
 3764                      	;
 3765                      	; DO_BUTTON - handle button clicking, working with the timer to
 3766                      	; 	check for double clicking or not
 3767                      	;
 3768   5071               	DO_BUTTON:
 3769   5071   AD 12 03    		lda	MSMOVEF		; check moved flag
 3770   5074   F0 03       		beq	DOM01		; nope
 3771   5076   20 4B 62    		jsr	MSCURS		; move mouse cursor
 3772   5079               	DOM01:
 3773   5079   A9 00       		lda	#0		; show no char
 3774   507B   AC 13 03    		ldy	MSBTNF		; check button flag
 3775   507E   10 15       		bpl	DOBX		; none
 3776                      	;
 3777                      	; button strike, check for double click
 3778                      	;
 3779   5080   8C 02 51    	        sty     JB_STATE        ; show new state
 3780   5083   A4 CA       		ldy	CLKCTR		; have we started click counter?
 3781   5085   10 08       		bpl	DOB02		; nope
 3782   5087   A0 01       		ldy	#1		; this resets counter
 3783   5089   84 CA       		sty	CLKCTR		; reset it
 3784   508B   A9 82       		lda	#DBL_CLK	; show double click char
 3785   508D   D0 14       		bne	DOBEXIT		; and finis
 3786   508F               	DOB02:
 3787   508F   A0 FA       		ldy	#-CLK_CNT	; set to double click timeout
 3788   5091   84 CA       		sty	CLKCTR		; okay
 3789   5093   30 0E       		bmi	DOBEXIT		;done
 3790   5095               	DOBX:
 3791   5095   A4 CA       		ldy	CLKCTR		; click counter counting?
 3792   5097   10 0A       		bpl	DOBEXIT		; nope
 3793   5099   E6 CA       		inc	CLKCTR		; count it then
 3794   509B   D0 06       		bne	DOBEXIT		; all done
 3795   509D   A0 01       		ldy	#1		; reset counter
 3796   509F   84 CA       		sty	CLKCTR		; okay
 3797   50A1   A9 81       		lda	#SGL_CLK	; set as char
 3798   50A3               	DOBEXIT:
 3799   50A3   A0 00       		ldy	#0		; clear out flags
 3800   50A5   8C 13 03    		sty	MSBTNF		; button flag
 3801   50A8   8C 12 03    		sty	MSMOVEF		; moved flag
 3802   50AB   A8          		tay			; set flag to show any char
 3803   50AC   60          		rts			; return char	
 3804                      	;
 3805                      	; DO_STICK - handle the joystick 'interrupt'
 3806                      	;
 3807   50AD               	DO_STICK:
 3808   50AD   20 B3 50    		jsr	MOVE_STICK	; first move it
 3809   50B0   4C 71 50    		jmp	DO_BUTTON	; now handle it
 3810   50B3               	MOVE_STICK:
 3811   50B3   A9 00       		lda	#0		; get horizontal change
  Wed May 24 1989 15:00                                                                                                  Page   57

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3812   50B5   20 03 51    		jsr	READ_STICK	; puts value in Y
 3813   50B8   C0 50       		cpy	#80		; if < 80, then jump to the left
 3814   50BA   B0 0D       		bcs	DOST1		; it is not
 3815   50BC   A5 CB       		lda	MSX		; make sure X is > 0
 3816   50BE   F0 1A       		beq	DOST2		; it is == 0, can't get smaller
 3817   50C0   8D 12 03    		sta	MSMOVEF		; show movement
 3818   50C3   C6 CB       		dec	MSX		; move one to the left
 3819   50C5   C6 CB       		dec	MSX		; move two to the left
 3820   50C7   D0 11       		bne	DOST2		; now check vertical
 3821   50C9               	DOST1:
 3822   50C9   C0 B4       		cpy	#180		; if > 160, then move right
 3823   50CB   90 0D       		bcc	DOST2		; nope
 3824   50CD   A5 CB       		lda	MSX		; make sure X is in bounds
 3825   50CF   C9 88       		cmp	#MAXWIDTH-4	; don't go too far
 3826   50D1   B0 07       		bcs	DOST2		; already maxxed out
 3827   50D3   8C 12 03    		sty	MSMOVEF		; show movement
 3828   50D6   E6 CB       		inc	MSX		; one step to the left
 3829   50D8   E6 CB       		inc	MSX		; and another one
 3830   50DA               	DOST2:
 3831   50DA   A9 01       		lda	#1		; now check vertical
 3832   50DC   20 03 51    		jsr	READ_STICK	; ask the monitor
 3833   50DF   C0 50       		cpy	#80		; if < 80, move up
 3834   50E1   B0 0D       		bcs	DOST3		; nope
 3835   50E3   A5 CC       		lda	MSY		; don't go negative
 3836   50E5   F0 1A       		beq	DOST4		; already minned out
 3837   50E7   8D 12 03    		sta	MSMOVEF		; show movement
 3838   50EA   C6 CC       		dec	MSY		; count down
 3839   50EC   C6 CC       		dec	MSY		; twice
 3840   50EE   D0 11       		bne	DOST4		; all done
 3841   50F0               	DOST3:
 3842   50F0   C0 B4       		cpy	#180		; check for downward motion
 3843   50F2   90 0D       		bcc	DOST4		; none
 3844   50F4   A5 CC       		lda	MSY		; check for maximum
 3845   50F6   C9 BD       		cmp	#MAXHEIGHT-3	; don't go below water
 3846   50F8   B0 07       		bcs	DOST4		; gone, thanx
 3847   50FA   8C 12 03    		sty	MSMOVEF		; show movement
 3848   50FD   E6 CC       		inc	MSY		; go further down
 3849   50FF   E6 CC       		inc	MSY		; twice as far for joystick
 3850   5101               	DOST4:
 3851   5101   60          		rts			; done
 3852                      	;
 3853                      	; READ_STICK - read the x or y value of the stick in mind.
 3854                      	;       [A] == 0 or 1 - the "stick" you are interested in
 3855                      	;       Also, check the button status.
 3856                      	;
 3857   5102   00          	JB_STATE  db    0               ; last state of joystick button
 3858   5103               	READ_STICK:
 3859   5103   48          		pha			; save which stick we want
 3860   5104   A2 E0       		ldx	#$E0            ; oh, pick something random
 3861   5106               	READST2:
 3862   5106   20 1B 51    	        jsr     CHECK_JOYBTN    ; check the joystick button
 3863   5109   CA          		dex
 3864   510A   D0 FA       		bne	READST2
 3865   510C   68          		pla			; get x back
 3866   510D   AA          	        tax                     ; got it
 3867   510E   AD 82 C0    	        lda     RDROM           ; bring ROM back
 3868   5111   20 1E FB    		jsr	MPREAD		; NOW do the read
 3869   5114   AD 83 C0    	        lda     BNK2SET         ; back to RAM
 3870   5117   AD 83 C0    	        lda     BNK2SET         ; back to RAM
 3871   511A   60          	        rts
 3872   511B               	CHECK_JOYBTN:
 3873   511B   A5 58       		lda	MOUSEF		; check which kind to move
 3874   511D   10 03       		bpl	DO_JBTN         ; no joystick, check mouse
 3875   511F   4C 41 50    	        jmp     CHK_MOUSE       ; then do the mouse
 3876   5122               	DO_JBTN:
 3877   5122   AD 61 C0    	        lda     APKEY1          ; get joystick button
 3878   5125               	CHK_BTN:
 3879   5125   30 03       	        bmi     READST3         ; button down
 3880   5127   8D 02 51    	        sta     JB_STATE        ; show button went up        
 3881   512A               	READST3:
 3882   512A   4D 02 51    	        eor     JB_STATE        ; toggle previous state        
 3883   512D   8D 13 03    	        sta     MSBTNF          ; set button flag
 3884   5130   60          	        rts
 3885                      	; ----------------------------
 3886                      	; FETCH ASCII KEYCODE INTO [A]
  Wed May 24 1989 15:00                                                                                                  Page   58

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3887                      	; ----------------------------
 3888                      	; EXIT: ASCII IN [A] & [IOCHAR]
 3889                      	
 3890   5131               	GETKEY:
 3891   5131   A9 03       		lda	#BLINK_RATE	; flag as wait for good key
 3892   5133   8D 92 4F    		sta	CURCOUNT	; clear blinker
 3893   5136   A5 58       		lda	MOUSEF		; is there a mouse/joystick?
 3894   5138   F0 03       		beq	GTK0		; nope
 3895   513A   20 B5 62    		jsr	MSCON		; turn on mouse cursor
 3896   513D               	GTK0:
 3897   513D   A9 00       		lda	#0		; clear line counter
 3898   513F   85 AB       		sta	LINCNT		; okay, we did
 3899   5141   8A          		txa			; SAVE [X] & [Y]
 3900   5142   48          		pha		
 3901   5143   98          		tya		
 3902   5144   48          		pha		
 3903   5145               	GKEY0:
 3904   5145   E6 A5       		inc	RAND+HI		; just whack on random number
 3905   5147   C6 A4       		dec	RAND+LO		; and more
 3906   5149   20 E6 4F    		jsr	FKEYX		; is there a key?
 3907   514C   30 23       		bmi	GKEY01		; got the key
 3908                      	
 3909   514E   20 27 4F    		jsr	WAIT10		; wait .1 seconds, moving mouse cursor
 3910                      	
 3911   5151   A5 58       	        lda     MOUSEF          ; do we have a joystick/mouse?
 3912   5153   F0 0D       	        beq     GKEY02          ; nope
 3913   5155   AD A4 6C    	        lda     PTR_COUNT       ; count down counter?
 3914   5158   F0 05       	        beq     GKEY00          ; nope
 3915   515A   CE A4 6C    	        dec     PTR_COUNT       ; count one wait cycle
 3916   515D   D0 03       	        bne     GKEY02          ; don't check yet
 3917   515F               	GKEY00:
 3918   515F   20 1B 51    	        jsr     CHECK_JOYBTN    ; check the joystick button, just fur the heckuvit
 3919   5162               	GKEY02:
 3920   5162   CE 92 4F    		dec	CURCOUNT	; down one
 3921   5165   D0 DE       		bne	GKEY0		; no toggle
 3922   5167   20 93 4F    		jsr	STCUR		; okay, toggle
 3923   516A   A9 03       		lda	#BLINK_RATE	; 1 per second
 3924   516C   8D 92 4F    		sta	CURCOUNT	; okay
 3925   516F   D0 D4       		bne	GKEY0		; check for key
 3926   5171               	GKEY01:
 3927   5171   48          		pha			; save char
 3928   5172   A5 58       		lda	MOUSEF		; any mouse cursor?
 3929   5174   F0 03       		beq	GTK1		; nope
 3930   5176   20 56 62    		jsr	MSCOFF		; turn mouse cursor off
 3931   5179               	GTK1:
 3932   5179   68          		pla			; get char back
 3933   517A   20 BE 4F    		jsr	ERCUR		; so erase cursor
 3934   517D               	CHKKEY:
 3935   517D   20 8B 51    		jsr	PARSEKEY	; how was the key?
 3936   5180   B0 C3       		bcs	GKEY0		;TRY AGAIN
 3937   5182   85 AC       		sta	IOCHAR		;HOLD ON TO IT
 3938   5184   68          		pla			; RESTORE
 3939   5185   A8          		tay			; EVERYTHING
 3940   5186   68          		pla		
 3941   5187   AA          		tax		
 3942   5188   A5 AC       		lda	IOCHAR		; GET CHAR INTO [A]
 3943   518A   60          		rts			; AND RETURN IT
 3944                      	
 3945                      	;
 3946                      	; CHECK TO MAKE SURE KEY IS VALID, ONLY ACCEPT IT IF IT IS
 3947                      	;
 3948   518B               	PARSEKEY:
 3949   518B   29 7F       		and	#$7F	;SCREEN OUT SHIFTS
 3950                      	;
 3951                      	;CHECK FOR "ARROWS" & FUNCTION KEYS (X),  CONVERT FOR USE (EZIP)
 3952                      	;ALSO : CHANGE <_>)@%^&*( TO ,-.0256789 - and 'mouse' clicks
 3953                      	; and other kinds of special chars
 3954                      	;
 3955   518D               	GK0:
 3956   518D   A2 12       		ldx	#ENDKEY ; GET LENGTH OF LIST
 3957   518F               	GK2:
 3958   518F   DD D4 51    		cmp	HAVE,X	; CHECK AGAINST LIST OF UNWANTED KEYS
 3959   5192   F0 05       		beq	GK3	; FOUND IT
 3960   5194   CA          		dex
 3961   5195   10 F8       		bpl	GK2	; CHECK THEM ALL
  Wed May 24 1989 15:00                                                                                                  Page   59

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3962   5197   30 05       		bmi	GK4	; NOT FOUND, CONTINUE OTHER CHECKS
 3963   5199               	GK3:
 3964   5199   BD E7 51    		lda	WANT,X	; GET KEY TO USE INSTEAD
 3965   519C   18          		clc		; show niceness
 3966   519D   60          		rts		; done
 3967   519E               	GK4:
 3968   519E   C9 20       		cmp	#SPACE	; NO CTRL CHARS ACCEPTABLE
 3969   51A0   90 14       		bcc	BADKEY	; IF < SPACE, BAD
 3970                      	
 3971   51A2   C9 3C       		cmp	#'<'	; pick up numbers and most punctuation
 3972   51A4   90 15       		bcc	OK	; we did
 3973                      	
 3974   51A6   C9 7B       		cmp	#'z'+1	;PICK OUT LETTERS NOW
 3975   51A8   B0 0C       		bcs	BADKEY	;IF > BAD
 3976   51AA   C9 61       		cmp	#'a'
 3977   51AC   B0 0D       		bcs	OK	;IF > OK
 3978   51AE   C9 41       		cmp	#'A'
 3979   51B0   90 04       		bcc	BADKEY
 3980   51B2   C9 5B       		CMP	#'Z'+1	
 3981   51B4   90 05       		BCC	OK	;IF < OK
 3982   51B6               	BADKEY:
 3983   51B6   20 C3 4E    		jsr	BEEP	;BAD KEY, GIVE WARNING NOISE, gwon back
 3984   51B9   38          		sec		; show badness
 3985   51BA   60          		rts		; and done
 3986   51BB               	OK:
 3987   51BB   C9 30       		cmp	#'0'	; check for number keys
 3988   51BD   90 13       		bcc	OKj	; nope, < 0
 3989   51BF   C9 3A       		cmp	#'9'+1	; more than a nine?
 3990   51C1   B0 0F       		bcs	OKj	; ayyup
 3991                      	;
 3992                      	; here we check for the closed apple key being down too
 3993                      	;
 3994   51C3   AE 62 C0    		ldx	APKEY2	; how about the closed apple key
 3995   51C6   10 0A       		bpl	OKj	; not pressed,	so use as number key
 3996                      	;
 3997                      	; transform number key into a function key
 3998                      	;
 3999   51C8   18          		CLC		; get ready for add
 4000   51C9   69 54       		ADC	#84	; transforms '1'-'9' to 133-141
 4001   51CB   C9 84       		CMP	#132	; but '0' wants to be a 142!
 4002   51CD   D0 03       		BNE 	OKj	; but it's not it
 4003   51CF   18          		CLC		; again, don't want carry
 4004   51D0   69 0A       		ADC	#10	; voila!
 4005   51D2               	OKj:
 4006   51D2   18          		clc		; show a wicked good character is about to arrive
 4007   51D3   60          		rts		; toots finis
 4008                      	
 4009   51D4   0B 0A 08 15 7F 	HAVE:	DB	$0B,$0A,$08,$15,$7f,ESCAPE,$3C,$7C,$3F
        51D9   1B 3C 7C 3F 
 4010   51DD   3C 5F 3E 40 25 		DB	$3C,$5F,$3E,$40,$25,$5E,$26,$01,$02, EOL
        51E2   5E 26 01 02 0D 
 4011   51E7   81 82 83 84 08 	WANT:	DB	129,130,131,132,08,ESCAPE,$3C,$7C,$3F
        51EC   1B 3C 7C 3F 
 4012   51F0   2C 2D 2E 32 35 		DB	$2C,$2D,$2E,$32,$35,$36,$37,254,253, EOL
        51F5   36 37 FE FD 0D 
 4013          0012        	ENDKEY	EQU	$-WANT-1
 4014                      	
 4015   51FA               		END
 4016                      	
 4017   51FA               		INCLUDE		IO.ASM	
 4018   51FA               		STTL "--- GAME I/O: APPLE II ---"
 4019                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page   60

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4020                      	
 4021                      		; --------------
 4022                      		; INTERNAL ERROR
 4023                      		; --------------
 4024                      		; ENTRY: ERROR CODE IN [A]
 4025                      		; EXIT: HA!
 4026                      	
 4027   51FA   0D 49 6E 74 65 	ERRM:	DB	EOL,"Internal error "
        51FF   72 6E 61 6C 20 
        5204   65 72 72 6F 72 
        5209   20 
 4028          0010        	ERRML	EQU	$-ERRM
 4029                      	
 4030   520A               	ZERROR:
 4031   520A   48          		pha			; save err number
 4032   520B   20 A9 4C    	        jsr     SWAP2INFOW      ; go to the info window (window 0)`
 4033   520E               		DLINE	ERRM		; print message
 4034   520E   A2 FA       		ldx	#<ERRM	; get part of ERRM
 4035   5210   A9 51       		lda	#>ERRM	; get other part of string
 4036          [01]        		IFMA	2		; check to see if length passed in
 4037                      		ldy			; then just fetch it
 4038          [01]        		ELSE
 4039   5212   A0 10       		ldy	#ERRML	; get length of string
 4040          [00]        		ENDIF
 4041   5214   20 6B 4C    		jsr	DLINE		; print the string
 4042   5217               		.MACEND
 4043   5217   68          		pla			; get error number
 4044   5218   20 D3 47    		jsr	HEXNUM		; print error number
 4045   521B   4C 21 52    		jmp	ZQUIT1		; and die
 4046                      	
 4047                      	
 4048                      		; ----
 4049                      		; QUIT
 4050                      		; ----
 4051                      	
 4052   521E   20 DF 54    	ZQUIT:	JSR	ZCRLF		; FLUSH BUFFER
 4053   5221               	ZQUIT1:
 4054   5221               		DLINE	ENDM		; print ending message
 4055   5221   A2 8C       		ldx	#<ENDM	; get part of ENDM
 4056   5223   A9 52       		lda	#>ENDM	; get other part of string
 4057          [01]        		IFMA	2		; check to see if length passed in
 4058                      		ldy			; then just fetch it
 4059          [01]        		ELSE
 4060   5225   A0 10       		ldy	#ENDML	; get length of string
 4061          [00]        		ENDIF
 4062   5227   20 6B 4C    		jsr	DLINE		; print the string
 4063   522A               		.MACEND
 4064   522A   20 DB 8C    		jsr	GETRET		; wait for <CR>
 4065   522D   A5 59       	        lda     INFODOS         ; in dinky-dos?
 4066   522F   F0 17       	        beq     ZQUIT2          ; nope
 4067   5231   A9 00       	        lda     #0              ; clear power up byte
 4068   5233   8D F4 03    	        sta     $3F4            ; make it do cold boot        
 4069   5236   AD FD FF    	        lda     RESET_VECTOR+HI ; now, set up where to die to
 4070   5239   8D 47 52    	        sta     ZQUITR1+2
 4071   523C   AD FC FF    	        lda     RESET_VECTOR+LO
 4072   523F   8D 46 52    	        sta     ZQUITR1+1
 4073   5242   AD 82 C0    	        lda     RDROM           ; get ROM back
 4074   5245               	ZQUITR1:
 4075   5245   4C FC FF    	        jmp     RESET_VECTOR    ; just reset things
 4076                      	;
 4077                      	; re-enable /RAM
 4078                      	;
 4079   5248               	ZQUIT2:
 4080   5248   AE 31 BF    		ldx	DEVCNT		; put device in at end
 4081   524B   E8          		inx			; point to one past end
 4082   524C   8E 31 BF    		stx	DEVCNT		; show new count
 4083   524F   A9 BF       		lda	#$BF		; /RAM ID
 4084   5251   9D 32 BF    		sta	DEVNUM,X	; save it
 4085   5254   AD 7F 07    		lda	OLDVEC+HI	; restore old vector
 4086   5257   8D 27 BF    		sta	RAMVEC+HI
 4087   525A   AD 7E 07    		lda	OLDVEC+LO
 4088   525D   8D 26 BF    		sta	RAMVEC+LO
 4089                      	;
 4090                      	; now format /RAM
 4091                      	;
  Wed May 24 1989 15:00                                                                                                  Page   61

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4092   5260   A9 03       		lda	#3		; stash into FORMAT parm block
 4093   5262   85 42       		sta	$42		; it goes here, oddly enough
 4094   5264   A9 B0       		lda	#$B0		; device id for /RAM
 4095   5266   85 43       		sta	$43		; and here it goes
 4096   5268   A9 11       		lda	#>GAME1FIO	; IO buffer
 4097   526A   85 45       		sta	$45		; this is where it goes
 4098   526C   A9 00       		lda	#<GAME1FIO	; lsb
 4099   526E   85 44       		sta	$44
 4100   5270   AD 80 C0    		lda	RDBNK2		; set up card for driver
 4101   5273   20 89 52    		jsr	RAMDRV		; format /RAM
 4102   5276   AD 82 C0    		lda	RDROM		; get ROM back
 4103   5279               		
 4104   5279   8D 51 C0    		sta	TEXTSW+ON	; turn on text
 4105   527C               		QUIT	QUIT_PB		
 4106   527C               		PRODOS 	$65, QUIT_PB
 4107   527C   20 00 BF    		jsr	$BF00	; ProDOS handler
 4108   527F   65          		DB	$65	; ProDOS function code
 4109   5280   8252        		DW	QUIT_PB	; Function Parameter Block address
 4110   5282               		.MACEND
 4111   5282               		.MACEND
 4112   5282               	QUIT_PB:
 4113   5282   04          		db	4		; 4 parms
 4114   5283   00 00 00 00 00 		db	0,0,0,0,0,0	; just zeros
        5288   00 
 4115   5289               	RAMDRV:
 4116   5289   6C 26 BF    		jmp	(RAMVEC)	; goto RAM driver
 4117                      	
 4118   528C   0D 45 6E 64 20 	ENDM:	DB	EOL,"End of session."
        5291   6F 66 20 73 65 
        5296   73 73 69 6F 6E 
        529B   2E 
 4119          0010        	ENDML	EQU	$-ENDM
 4120                      	
 4121                      	; -------
 4122                      	; RESTART
 4123                      	; -------
 4124   529C               	BOOT_RD:
 4125   529C   04          		db 	4
 4126   529D   00          		db	0
 4127   529E   0020        		dw	BORG		; put into where it wants
 4128   52A0   FFFF        		dw	$FFFF		; read lots
 4129   52A2               	BOOTNAME:
 4130   52A2   0E          		db	BNAMEL		; length will go here
 4131   52A3   49 4E 46 4F 43 	        db      "INFOCOM.SYSTEM"
        52A8   4F 4D 2E 53 59 
        52AD   53 54 45 4D 
 4132          000E        	BNAMEL  EQU     $-BOOTNAME-1
 4133   52B1               	ZSTART:
 4134   52B1   20 8F 8C    		jsr	CLOSE_GAME	; make sure everything is closed
 4135                      	
 4136   52B4   A9 FF       		lda	#$FF		; just do a clear -1
 4137   52B6   85 63       		sta	ARG1+LO		; done
 4138   52B8   20 A8 57    		jsr	ZCLR		; to clear screen and set up window 0
 4139   52BB   A9 A2       		lda	#<BOOTNAME	; now, set open file name
 4140   52BD   8D D7 45    		sta	OPEN_FILE+OP_PATHNAME+LO
 4141   52C0   A9 52       		lda	#>BOOTNAME
 4142   52C2   8D D8 45    		sta	OPEN_FILE+OP_PATHNAME+HI
 4143   52C5   A9 31       		lda	#'1'		; set disk name to disk #1
 4144   52C7   8D C5 49    	        sta     SAVENUM         ; show open_gamef
 4145   52CA   20 22 4B    	        jsr     OPEN_GAMEF      ; okay
 4146                      	
 4147   52CD   AD DB 45    		lda	OPEN_FILE+OP_REFNUM ; get ref num
 4148   52D0   8D 9D 52    		sta	BOOT_RD+RD_REFNUM ; save ref num
 4149   52D3   8D 07 8B    		sta	CLOSE_PB+CL_REFNUM
 4150   52D6               		READ	BOOT_RD		; read in boot system
 4151   52D6               		PRODOS	$CA, BOOT_RD
 4152   52D6   20 00 BF    		jsr	$BF00	; ProDOS handler
 4153   52D9   CA          		DB	$CA	; ProDOS function code
 4154   52DA   9C52        		DW	BOOT_RD	; Function Parameter Block address
 4155   52DC               		.MACEND
 4156   52DC               		.MACEND
 4157   52DC   90 03       		bcc	ZSTRTX		; okay, everything is fine
 4158   52DE   4C 74 47    		jmp	DISK_FATAL	; die otherwise
 4159   52E1               	ZSTRTX:
 4160   52E1               		CLOSE	CLOSE_PB	; and close it up
  Wed May 24 1989 15:00                                                                                                  Page   62

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4161   52E1               		PRODOS	$CC, CLOSE_PB
 4162   52E1   20 00 BF    		jsr	$BF00	; ProDOS handler
 4163   52E4   CC          		DB	$CC	; ProDOS function code
 4164   52E5   068B        		DW	CLOSE_PB	; Function Parameter Block address
 4165   52E7               		.MACEND
 4166   52E7               		.MACEND
 4167   52E7   4C 00 20    		jmp	BORG		; and go to it
 4168   52EA               		
 4169                      		; --------------------------------
 4170                      		; RETURN RANDOM BYTES IN [A] & [X]
 4171                      		; --------------------------------
 4172   52EA               	RANDOM:
 4173   52EA   E6 A5       	        inc	RAND+HI	
 4174   52EC   C6 A4       		dec	RAND+LO	
 4175   52EE   A5 A4       		lda	RAND+LO         ; get LSB
 4176   52F0   65 A5       	        adc     RAND+HI         ; add MSB
 4177   52F2   29 7F       	        and     #$7F            ; don't let it go into $C0 page
 4178   52F4   85 A5       	        sta     RAND+HI         ; new MSB        
 4179   52F6   A8          	        tay                     ; get random offset
 4180   52F7   B1 A4       	        lda     (RAND),Y        ; get random number
 4181   52F9   AA          	        tax                     ; save in X
 4182   52FA   65 A4       	        adc     RAND+LO         ; and go to another spot
 4183   52FC   29 7F       	        and     #$7F            ; don't go above $80
 4184   52FE   85 A5       	        sta     RAND+HI         ; okay
 4185   5300   A8          	        tay                     ; more randomness
 4186   5301   B1 A4       	        lda     (RAND),Y        ; and get it again
 4187   5303   05 A5       	        ora     RAND+HI         ; set more bits
 4188   5305   60          		rts		
 4189                      	
 4190                      	
 4191                      		; -------------------
 4192                      		; Z-PRINT A CHARACTER
 4193                      		; -------------------
 4194                      		; ENTRY: ASCII CHAR IN [A]
 4195                      		; COMMENT: SCRIPTING IS HANDLED IN UNBUFR AND FLUSH,
 4196                      		; SO CAN OUTPUT TO PRINTER AS A LINE.  TABLE AND SCREEN
 4197                      		; OUTPUT IS SET UP HERE, HANDLED A BYTE AT A TIME
 4198                      		; (DIROUT CHANGES 6/24/85)
 4199                      	
 4200   5306               	COUT:
 4201   5306   85 AC       		sta	IOCHAR		; HOLD IT A SEC
 4202   5308   A6 B2       		ldx	TABLEF		; OUTPUT TO TABLE?
 4203   530A   F0 07       		beq	COUT1		; NO
 4204   530C   A6 19       		ldx	FMTTBL		; formatted table?
 4205   530E   D0 0D       		bne	COUT5		; yes, so just do it normal
 4206   5310   4C 86 53    		jmp	TBLOUT		; just put into table
 4207   5313               	COUT1:
 4208   5313   A6 B1       		ldx	SCREENF		; OUTPUT TO SCREEN?
 4209   5315   D0 06       		bne	COUT5		; YES
 4210   5317   AE 73 6C    		ldx	SCRIPTF		; OUTPUT TO PRINTER?
 4211   531A   D0 01       		bne	COUT5		; YES
 4212   531C   60          		rts			; NO, SO DONE
 4213   531D               	COUT5:
 4214   531D   A5 AC       		lda	IOCHAR		; RETRIEVE CHAR
 4215   531F   30 5B       		bmi	COUT2		; highlight chars have no width
 4216                      	;
 4217                      	; this is an entry point for DLINE, so it doesn't check any of the above
 4218                      	; things.  Enter with character in [A]
 4219                      	;
 4220   5321               	DIRECT_OUT: 
 4221   5321   C9 0D       		cmp	#EOL		; IF ASCII EOL, just handle it special
 4222   5323   D0 03       		bne	COUT0	
 4223                      	
 4224   5325   4C DF 54    		jmp	ZCRLF		; DO IT
 4225   5328               	COUT0:
 4226   5328   B0 20       		bcs	COUT02          ; not control character
 4227   532A   C9 0B       	        cmp     #EOS            ; control-k (end of sentence)?
 4228   532C   F0 0E       	        beq     COUT01          ; yes, so put out 2 spaces
 4229   532E   C9 09       	        cmp     #TAB            ; tab char?
 4230   5330   D0 53       	        bne     CEX             ; ignore all other control chars
 4231                      	;
 4232                      	; this means do a couple of spaces
 4233                      	;
 4234   5332   A9 20       	        lda     #SPACE          ; do 3 spaces for start of line
 4235   5334   20 06 53    	        jsr     COUT            ; a little recursion never hurt!
  Wed May 24 1989 15:00                                                                                                  Page   63

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4236   5337   A6 A9       	        ldx     CHRCNT          ; back to beginning of line?
 4237   5339   D0 01       	        bne     COUT01          ; nope
 4238   533B               	COUT010:
 4239   533B   60          	        rts                     ; don't do any to start line
 4240   533C               	COUT01:
 4241   533C   A9 20       	        lda     #SPACE          ; 2 more spaces
 4242   533E   20 06 53    	        jsr     COUT
 4243   5341   A6 A9       	        ldx     CHRCNT          ; back to zero?
 4244   5343   F0 F6       	        beq     COUT010         ; yes, so don't add to start of line
 4245                      	
 4246   5345   A9 20       	        lda     #SPACE          ; last one
 4247   5347   4C 06 53    	        jmp     COUT            ; finally
 4248   534A               	COUT02:
 4249   534A   AA          		tax			; use char as index
 4250   534B   A5 C1       		lda	FONTFLG		; get which font we be using
 4251   534D   F0 04       		beq	COUTF1		; must be variable width
 4252   534F   A9 0C       		lda	#MONOFONT_W	; get width then of mono font
 4253   5351   D0 03       		bne	COUTF2		; okay, now do add
 4254   5353               	COUTF1:
 4255   5353   BD 25 64    		lda	CHWID,X		; get width of char
 4256   5356               	COUTF2:
 4257   5356   18          		clc 			; get ready for add
 4258   5357   65 A7       		adc	LENGTH+LO	; ADD LINE LENGTH COUNTER
 4259   5359   85 A7       		sta	LENGTH+LO	; update length
 4260   535B   90 02       		bcc	COUT0C		; no wrap
 4261   535D   E6 A8       		inc	LENGTH+HI	; okay, wrap then
 4262   535F               	COUT0C:
 4263   535F   A5 A8       		lda	LENGTH+HI	; get MSB
 4264   5361   C5 A3       		cmp	XSIZE+HI	; check MSB first
 4265   5363   90 17       		bcc	COUT2		; no need to check lsb
 4266   5365   D0 06       		bne	COUT00		; XSIZE < LENGTH?
 4267   5367               		
 4268   5367   A5 A7       		lda	LENGTH+LO	; check LSB
 4269   5369   C5 A2       		cmp	XSIZE+LO	; END OF SCREEN LINE?
 4270   536B   90 0F       		bcc	COUT2		; haven't reached the end if XSIZE > LENGTH
 4271   536D               	COUT00:
 4272   536D   AC D6 71    		ldy	WRPFLG		; are we wrapping
 4273   5370   F0 13       		beq	CEX		; no, so truncate
 4274   5372   A6 A9       		ldx	CHRCNT		; get character count
 4275   5374   A5 AC       		lda	IOCHAR		; get the character
 4276   5376   9D 00 02    		sta	LBUFF,X		; save current char in buffer
 4277   5379   4C 6B 54    		jmp	FLUSH		; YES, FLUSH THE LINE
 4278   537C               	COUT2:
 4279   537C   A6 A9       		ldx	CHRCNT		; GET LINE POINTER
 4280   537E   A5 AC       		lda	IOCHAR		; get char back
 4281   5380   9D 00 02    		sta	LBUFF,X		; ADD CHAR TO BUFFER
 4282   5383   E6 A9       		inc	CHRCNT		; and point to next CHRCNT
 4283   5385               	CEX:
 4284   5385   60          		rts
 4285   5386               		
 4286                      		; ---------------
 4287                      		; OUTPUT TO TABLE
 4288                      		; ---------------
 4289                      	;
 4290                      	; this one just puts a char into the table
 4291                      	;
 4292   5386               	TBLOUT:
 4293   5386   AA          		tax			; HOLD CHAR A SEC.
 4294                      	;
 4295                      	; figger out length of line in there
 4296                      	;
 4297   5387   A5 C1       		lda	FONTFLG		; get which font we be using
 4298   5389   F0 04       		beq	TBLOUT1		; must be variable width
 4299   538B   A9 0C       		lda	#MONOFONT_W	; get width then of mono font
 4300   538D   D0 03       		bne	TBLOUT2		; okay, now do add
 4301   538F               	TBLOUT1:
 4302   538F   BD 25 64    		lda	CHWID,X		; get width of char
 4303   5392               	TBLOUT2:
 4304   5392   18          		clc			; add width
 4305   5393   6D 31 96    		adc	ZBEGIN+ZTWIDTH+1	; to current line width
 4306   5396   8D 31 96    		sta	ZBEGIN+ZTWIDTH+1	; save current width
 4307   5399   90 03       		bcc	TBLOUT3		; no wrap
 4308   539B   EE 30 96    		inc	ZBEGIN+ZTWIDTH+0	; wrap, then dammit
 4309   539E               	TBLOUT3:
 4310                      	;
  Wed May 24 1989 15:00                                                                                                  Page   64

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4311                      	; PUT BYTE IN TABLE AT CURRENT OFFSET
 4312                      	;
 4313   539E   AD 80 6C    		lda	DIRITM+LO	; ADD IN OFFSET
 4314   53A1   18          		clc		
 4315   53A2   65 A0       		adc	DIRTBL+LO	
 4316   53A4   85 8F       		sta	SPCL		; and make it lo part
 4317   53A6   AD 81 6C    		lda	DIRITM+HI	
 4318   53A9   65 A1       		adc	DIRTBL+HI	
 4319   53AB   20 77 8F    		jsr	SETPC		; set the PC
 4320   53AE   85 90       		sta	SPCH		; and this is high part
 4321   53B0   84 91       		sty	SPCBNK		; and the bank
 4322   53B2   8A          		txa			; PICK UP ASCII CHAR
 4323   53B3   20 35 92    		jsr	STASHB		; and save it
 4324                      	;
 4325                      	; SET ITM OFFSET TO NEXT POSITION, INCREMENT COUNTER
 4326                      	;
 4327   53B6   EE 80 6C    		inc	DIRITM+LO	; INC OFFSET TO NEXT BYTE
 4328   53B9   D0 03       		bne	TBLRTS	
 4329   53BB   EE 81 6C    		inc	DIRITM+HI	
 4330   53BE               	TBLRTS:
 4331   53BE   60          		rts
 4332                      	;
 4333                      	; PUT LBUFF IN TABLE AT CURRENT OFFSET
 4334                      	;
 4335   53BF               	TBLRTN:
 4336   53BF   AD 80 6C    		lda	DIRITM+LO	; get where we are
 4337   53C2   18          		clc
 4338   53C3   65 A0       		adc	DIRTBL+LO	; ADD IN OFFSET
 4339   53C5   85 8F       		sta	SPCL		; and make it lo part
 4340   53C7   85 8C       		sta	FPCL		; save for later usage
 4341   53C9   AD 81 6C    		lda	DIRITM+HI	; get hi part
 4342   53CC   65 A1       		adc	DIRTBL+HI	
 4343   53CE   20 77 8F    		jsr	SETPC		; set the PC
 4344   53D1   85 90       		sta	SPCH		; and this is high part
 4345   53D3   85 8D       		sta	FPCH		; saving
 4346   53D5   84 91       		sty	SPCBNK		; and the bank
 4347   53D7   84 8E       		sty	FPCBNK		; and here too
 4348   53D9   A9 00       		lda	#0		; start counter off at zero
 4349   53DB   85 7A       		sta	J		; use J
 4350   53DD   85 7D       		sta	K+HI		; this will be line length
 4351   53DF   85 7C       		sta	K+LO		; both parts, please
 4352   53E1   20 9E 8F    		jsr	NEXTSPC		; point past the counter
 4353   53E4               	TBLOOP:
 4354   53E4   A4 7A       		ldy	J		; get offset
 4355   53E6   B9 00 02    		lda	LBUFF,Y		; get char
 4356   53E9   AA          		tax			; save char
 4357   53EA   30 19       		bmi	TBLP1		; don't count hi light chars
 4358   53EC   C9 20       		cmp	#SPACE		; see if less than a space
 4359   53EE   90 15       		bcc	TBLP1		; no width if <$20
 4360   53F0   AA          		tax			; use char as index
 4361                      	
 4362   53F1   A5 C1       		lda	FONTFLG		; get which font we be using
 4363   53F3   F0 04       		beq	TBLF1		; must be variable width
 4364   53F5   A9 0C       		lda	#MONOFONT_W	; get width then of mono font
 4365   53F7   D0 03       		bne	TBLF2		; okay, now do add
 4366   53F9               	TBLF1:
 4367   53F9   BD 25 64    		lda	CHWID,X		; get width of char
 4368   53FC               	TBLF2:
 4369   53FC   18          		clc			; add width
 4370   53FD   65 7C       		adc	K+LO		; to current line width
 4371   53FF   85 7C       		sta	K+LO		; save current width
 4372   5401   90 02       		bcc	TBLP1		; no wrap
 4373   5403   E6 7D       		inc	K+HI		; wrap, then dammit
 4374   5405               	TBLP1:
 4375   5405   8A          		txa			; get char back
 4376   5406   20 35 92    		jsr	STASHB		; and save it
 4377   5409   20 9E 8F    		jsr	NEXTSPC		; next table entry
 4378   540C   E6 7A       		inc	J		; point to next char
 4379   540E   C6 A9       		dec	CHRCNT		; decrement counter
 4380   5410   D0 D2       		bne	TBLOOP		; get next one
 4381                      	;
 4382                      	; now fill with necessary spaces
 4383                      	;
 4384   5412   A5 C1       		lda	FONTFLG		; first, set up width to be added
 4385   5414   F0 04       		beq	TBLSPF1		; must be variable width font
  Wed May 24 1989 15:00                                                                                                  Page   65

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4386   5416   A9 0C       		lda	#MONOFONT_W	; get mono width	
 4387   5418   D0 05       		bne	TBLSPF2		; okay
 4388   541A               	TBLSPF1:
 4389   541A   A2 20       		ldx	#SPACE		; get space index
 4390   541C   BD 25 64    		lda	CHWID,X		; okay
 4391   541F               	TBLSPF2:
 4392   541F   85 71       		sta	ARG8		; use temporarily
 4393   5421               	TBLSP:
 4394   5421   A5 7C       		lda	K+LO		; get how big line is
 4395   5423   18          		clc			; add in space
 4396   5424   65 71       		adc	ARG8		; pick up space width
 4397   5426   85 7C       		sta	K+LO		; saved
 4398   5428   90 02       		bcc	TBLSP1		; no wrap?
 4399   542A   E6 7D       		inc	K+HI		; yes, wrapping
 4400   542C               	TBLSP1:
 4401   542C   A5 A3       		lda	XSIZE+HI	; check against end
 4402   542E   C5 7D       		cmp 	K+HI		; compare against max width
 4403   5430   90 14       		bcc	TBLSPX		; all done then
 4404   5432   D0 06       		bne	TBLSP2		; no need to check if <>
 4405   5434   A5 A2       		lda	XSIZE+LO	; check LSB
 4406   5436   C5 7C       		cmp	K+LO		; well?
 4407   5438   90 0C       		bcc	TBLSPX		; all done then
 4408   543A               	TBLSP2:
 4409   543A   A9 20       		lda	#SPACE		; get it
 4410   543C   20 35 92    		jsr	STASHB		; save it
 4411   543F   20 9E 8F    		jsr	NEXTSPC		; point to next one
 4412   5442   E6 7A       		inc	J		; count it
 4413   5444   D0 DB       		bne	TBLSP		; and continue
 4414   5446               	TBLSPX:
 4415   5446   A9 00       		lda	#0		; show end of table
 4416   5448   85 A7       		sta	LENGTH+LO	; clear out line length too
 4417   544A   85 A8       		sta	LENGTH+HI	; and hi part too
 4418   544C   20 35 92    		jsr	STASHB		; marked with a zero
 4419   544F   20 73 90    		jsr	FP2SP		; have SPC point to beginning
 4420   5452   A5 7A       		lda	J		; get how many chars are there	
 4421   5454   20 35 92    		jsr	STASHB		; save at beginning of line
 4422   5457   E6 7A       		inc	J		; count counter in offset
 4423   5459   A5 7A       		lda	J		; get J back
 4424   545B   18          		clc			; add in where we were
 4425   545C   6D 80 6C    		adc	DIRITM+LO	; okay with lo part
 4426   545F   8D 80 6C    		sta	DIRITM+LO	; save it
 4427   5462   AD 81 6C    		lda	DIRITM+HI	; and now the hi part
 4428   5465   69 00       		adc	#0		; pick up carry, maybe
 4429   5467   8D 81 6C    		sta	DIRITM+HI	; and save it
 4430   546A   60          		rts
 4431                      	
 4432                      		; -------------------
 4433                      		; FLUSH OUTPUT BUFFER
 4434                      		; -------------------
 4435                      		; ENTRY: LENGTH OF BUFFER IN [X]
 4436                      	
 4437   546B               	FLUSH:
 4438   546B   A9 20       		lda	#SPACE		; SPACE CHAR
 4439   546D   8E 63 6C    		stx	OLDEND		; SAVE CURRENT END OF LINE
 4440   5470               	FL0:
 4441   5470   DD 00 02    		cmp	LBUFF,X		; FIND LAST SPACE CHAR
 4442   5473   F0 06       		beq	FL1		; IN THE LINE
 4443   5475   CA          		dex
 4444   5476   D0 F8       		bne	FL0		; IF NONE FOUND,
 4445   5478   A6 A9       		ldx	CHRCNT		; FLUSH ENTIRE LINE
 4446   547A   CA          		dex			; minus last one
 4447   547B               	FL1:
 4448   547B   8E 62 6C    		stx	OLDLEN		; SAVE OLD LINE POS HERE
 4449   547E   86 A9       		stx	CHRCNT		; MAKE IT THE NEW LINE LENGTH
 4450   5480               		
 4451   5480   A5 B2       		lda	TABLEF		; are we doing table I/O?
 4452   5482   F0 06       		beq	FL11		; nope
 4453   5484   20 BF 53    		jsr	TBLRTN		; YES, DO IT 
 4454   5487   4C 8D 54    		jmp	FL12		; so refill line
 4455   548A               	FL11:
 4456   548A   20 DF 54    		jsr	ZCRLF		; PRINT LINE UP TO LAST SPACE
 4457                      	;
 4458                      	; START NEW LINE WITH REMAINDER OF OLD
 4459                      	;
 4460   548D               	FL12:
  Wed May 24 1989 15:00                                                                                                  Page   66

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4461   548D   AE 62 6C    		ldx	OLDLEN		; GET OLD LINE POS
 4462   5490   A0 00       		ldy	#0		; START NEW LINE AT BEGINNING
 4463   5492               	FL2:
 4464   5492   E8          		inx		
 4465   5493   EC 63 6C    		cpx	OLDEND		; CONTINUE IF
 4466   5496   90 05       		bcc	FL3		; INSIDE of end of line
 4467   5498   F0 03       		beq	FL3		; or at end of line
 4468   549A   84 A9       		sty	CHRCNT	
 4469   549C   60          		rts		
 4470   549D               	FL3:
 4471   549D   BD 00 02    		lda	LBUFF,X		; GET CHAR FROM OLD LINE
 4472   54A0   C9 20       	        cmp     #SPACE          ; don't move start spaces in either
 4473   54A2   F0 25       	        beq     FL4             ; fine, I won't        
 4474   54A4   99 00 02    		sta	LBUFF,Y		; MOVE TO START OF NEW LINE
 4475   54A7   30 20       		bmi	FL4		; don't count hi light chars
 4476   54A9   C9 20       		cmp	#SPACE		; don't count control chars
 4477   54AB   90 1C       		bcc	FL4		; okay
 4478   54AD   8A          		txa			; save current x
 4479   54AE   48          		pha			; saved
 4480   54AF   A5 C1       		lda	FONTFLG		; get which font we be using
 4481   54B1   F0 04       		beq	FLSF1		; must be variable width
 4482   54B3   A9 0C       		lda	#MONOFONT_W	; get width then of mono font
 4483   54B5   D0 07       		bne	FLSF2		; okay, now do add
 4484   54B7               	FLSF1:
 4485   54B7   BD 00 02    		lda	LBUFF,X		; get char back
 4486   54BA   AA          		tax			; make index
 4487   54BB   BD 25 64    		lda	CHWID,X		; get width of char
 4488   54BE               	FLSF2:
 4489   54BE   18          		clc			; get ready for add
 4490   54BF   65 A7       		adc	LENGTH+LO	; okay, now add char width
 4491   54C1   85 A7       		sta	LENGTH+LO	; save new length
 4492   54C3   68          		pla			; get old X back
 4493   54C4   AA          		tax			; okay
 4494   54C5   90 02       		bcc	FL4		; no wrap
 4495   54C7   E6 A8       		inc	LENGTH+HI
 4496   54C9               	FL4:
 4497   54C9   C8          		iny			; UPDATE # OF chars in NEW LINE
 4498   54CA   D0 C6       		bne	FL2		; (ALWAYS)
 4499                      	
 4500                      	
 4501                      		; ---------------
 4502                      		; CARRIAGE RETURN
 4503                      		; ---------------
 4504                      	
 4505   54CC               	ZZCRLF:
 4506   54CC   A6 B2       		ldx	TABLEF		; OUTPUT TO TABLE?
 4507   54CE   F0 0F       		beq	ZCRLF		; NO
 4508                      	;
 4509                      	; if putting a <CR> into table, just add to line buffer and flush
 4510                      	;
 4511   54D0   A9 0D       		lda	#EOL		; get carriage return char
 4512   54D2   A4 A9       		ldy	CHRCNT		; add to lbuff
 4513   54D4   99 00 02    		sta	LBUFF,Y		; got it
 4514   54D7   E6 A9       		inc	CHRCNT		; now flush it
 4515   54D9   20 BF 53    		jsr	TBLRTN		; YES, DO IT (TBL ONLY)
 4516   54DC   4C 55 55    		jmp	ZCRLFX		; git out
 4517   54DF               	ZCRLF:
 4518   54DF   A6 A9       		ldx	CHRCNT		; how far have we gone
 4519   54E1   A9 0D       		lda	#EOL		; get carriage return char
 4520   54E3   9D 00 02    		sta	LBUFF,X		; END OF CURRENT LINE
 4521   54E6   E6 A9       		inc	CHRCNT		; UPDATE LINE LENGTH
 4522   54E8   20 5E 55    		jsr	LINOUT		; DISPLAY LINE
 4523                      	
 4524                      	;
 4525                      	; now check about line count
 4526                      	;
 4527   54EB   A9 00       		lda	#0
 4528   54ED   85 A9       		sta	CHRCNT		; AND RESET LINE COUNT
 4529   54EF   85 A7       		sta	LENGTH+LO	; okay
 4530   54F1   85 A8       		sta	LENGTH+HI	; okay
 4531                      	
 4532   54F3   20 7C 55    		jsr	CHKFNC		; CHECK FOR CR FUNCTION (XZIP)
 4533                      	
 4534   54F6   A5 B1       		lda	SCREENF		; CHECK IF DISPLAYING TO SCREEN
 4535   54F8   F0 5B       		beq	ZCRLFX		; NO, GO HANDLE IF PRINTING
  Wed May 24 1989 15:00                                                                                                  Page   67

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4536   54FA   AD D7 71    		lda	SCRLFLG		; is it a scrolling window?
 4537   54FD   F0 56       		beq	ZCRLFX		; nope, so no more
 4538   54FF   E6 AB       		inc	LINCNT		; NEW LINE GOING OUT
 4539                      	
 4540   5501   A6 AB       		ldx	LINCNT		; IS IT TIME TO
 4541   5503   E4 03       		cpx	MAXLINES	; PRINT "MORE" YET?
 4542   5505   90 4E       		bcc	ZCRLFX		; NO, CONTINUE
 4543                      	
 4544   5507   A9 01       		lda	#1		; leave one line from last screen, and input line
 4545   5509   85 AB       		sta	LINCNT		; RESET LINE COUNTER
 4546   550B   A5 04       		lda	LEFTMRG		; SET LEFT MARGIN
 4547   550D   85 00       		sta	SCRCX
 4548   550F   A9 01       		lda	#1		; show cursor changed (maybe)
 4549   5511   8D 77 6C    		sta	CURSFLG		; okay
 4550                      	;
 4551                      	; print [MORE] out myself, to avoid re-entrancy problems
 4552                      	;
 4553   5514   AD 73 6C    	        lda     SCRIPTF         ; make sure we don't script
 4554   5517   48          	        pha
 4555   5518   A2 00       	        ldx     #0              ; start with first char
 4556   551A   8E 73 6C    	        stx     SCRIPTF         ; clear script flag
 4557   551D   86 18       	        stx     SCLLINES        ; use this as a counter
 4558   551F               	MORELOOP:
 4559   551F   BD 66 5B    	        lda     MORE,X          ; get char
 4560   5522   85 AC       	        sta     IOCHAR          ; save it
 4561   5524   20 21 53    	        jsr     DIRECT_OUT      ; pump it out there
 4562   5527   E6 18       	        inc     SCLLINES        ; count char
 4563   5529   A6 18       	        ldx     SCLLINES        ; how many have we done        
 4564   552B   E0 06       	        cpx     #MOREL          ; done?
 4565   552D   D0 F0       	        bne     MORELOOP        ; nope
 4566                      	
 4567   552F   20 AD 55    	        jsr     CLRBUF          ; make sure it shows
 4568   5532               	WAIT:
 4569   5532   20 31 51    		jsr	GETKEY		; wait for key please
 4570   5535   A9 05       		lda	#MOREL-1	; how many backspaces
 4571   5537   85 A7       		sta	LENGTH		; just use this as counter
 4572   5539               	WM11:
 4573   5539   A6 A7       		ldx	LENGTH		; which char?
 4574   553B   BD 66 5B    		lda	MORE,X		; get char
 4575   553E   AA          		tax			; put here for erase
 4576   553F   A9 08       		lda	#BACKSPACE	; erase char
 4577   5541   20 7D 5D    		jsr	CHAR
 4578   5544   C6 A7       		dec	LENGTH		; count it
 4579   5546   10 F1       		bpl	WM11
 4580   5548   68          	        pla                     ; get script flag back
 4581   5549   8D 73 6C    	        sta     SCRIPTF         ; fine
 4582   554C   A5 04       		lda	LEFTMRG		; move back to left margin
 4583   554E   85 00       		sta	SCRCX		; okay
 4584   5550   A9 01       		lda	#1		; show cursor changed (maybe)
 4585   5552   8D 77 6C    		sta	CURSFLG		; okay
 4586   5555               	ZCRLFX:
 4587   5555   A9 00       		lda	#0
 4588   5557   85 A9       		sta	CHRCNT		; AND RESET LINE COUNT
 4589   5559   85 A7       		sta	LENGTH+LO	; okay
 4590   555B   85 A8       		sta	LENGTH+HI
 4591   555D   60          		rts
 4592   555E               	LINOUT:
 4593   555E   A4 A9       		ldy	CHRCNT		; IF BUFFER EMPTY,
 4594   5560   F0 19       		beq	LINEX		; DON'T PRINT ANYTHING
 4595   5562   8C 69 6C    		sty	PRLEN		; SAVE LENGTH HERE FOR "PPRINT"
 4596   5565   A5 B1       		lda	SCREENF		; DISPLAY TO SCREEN?
 4597   5567   F0 0F       		beq	LOUT1		; NO, GO CHECK IF PRINT
 4598   5569   A2 00       		ldx	#0		; SEND CONTENTS OF [LBUFF]
 4599   556B               	LOUT:
 4600   556B   BD 00 02    		lda	LBUFF,X		; TO SCREEN
 4601   556E   20 7D 5D    		jsr	CHAR
 4602   5571   E8          		inx
 4603   5572   88          		dey
 4604   5573   D0 F6       		bne	LOUT
 4605   5575   20 EC 71    		jsr	DISP_LINE	; make sure line gets printed
 4606   5578   20 DF 4C    	LOUT1:	JSR	PPRINT		; PRINT [LBUFF] IF ENABLED
 4607   557B               	LINEX:
 4608   557B   60          		rts			; AND RETURN
 4609                      	;
 4610                      	; CHECK IF THERE IS A PENDING FUNCTION CALL ASSOCIATED WITH <CR>'S
  Wed May 24 1989 15:00                                                                                                  Page   68

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4611                      	;
 4612   557C               	CHKFNC:
 4613   557C   A0 0B       		ldy	#WINCRC+HI		; get function offset
 4614   557E   B1 05       		lda	(WINDOW),Y		; IF NULL IGNORE
 4615   5580   88          	 	dey				; point to lo part
 4616   5581   11 05       		ora	(WINDOW),Y
 4617   5583   F0 26       		beq	CHKOUT
 4618                      	
 4619   5585   AD A3 6C    	        lda     CRLF_CHECK              ; do we really want to do this?
 4620   5588   F0 21       	        beq     CHKOUT                  ; nope
 4621                      	
 4622   558A   B1 05       		lda	(WINDOW),Y		; DECR COUNTER
 4623   558C   38          		sec
 4624   558D   E9 01       		sbc	#1
 4625   558F   91 05       		sta	(WINDOW),Y
 4626   5591   C8          		iny
 4627   5592   B1 05       		lda	(WINDOW),Y		; work on hi part
 4628   5594   E9 00       		sbc	#0			; pick up carry
 4629   5596   91 05       		sta	(WINDOW),Y		; save it
 4630   5598   88          		dey		
 4631   5599   11 05       		ora	(WINDOW),Y		; if NULL NOW, CALL FCN
 4632   559B   D0 0E       		bne	CHKOUT
 4633                      	
 4634   559D   A0 08       		ldy	#WINCRF+LO		; pointing to routine
 4635   559F   B1 05       		lda	(WINDOW),Y		; get lo part	
 4636   55A1   85 7A       		sta	J+LO			; and save in J
 4637   55A3   C8          		iny				; point to hi part
 4638   55A4   B1 05       		lda	(WINDOW),Y		; got it
 4639   55A6   85 7B       		sta	J+HI
 4640   55A8   20 13 5B    		jsr	INTCLL			; DO FUNCTION CALL
 4641   55AB               	CHKOUT:
 4642   55AB   60          		rts
 4643                      	
 4644                      	
 4645                      		; ----------------------
 4646                      		; UPDATE THE STATUS LINE
 4647                      		; ----------------------
 4648                      		; NOT APPLICABLE IN EZIP.
 4649                      	
 4650   55AC   60          	ZUSL:	RTS		
 4651                      	
 4652                      	; ------
 4653                      	; BUFOUT
 4654                      	; ------
 4655                      	; ENTER: ARG1 = BUFFERED (1) OR NONBUFFERED (0) OUTPUT CHOICE
 4656                      	; EXIT: FLAG (BUFFLG) IS SET TO TELL COUT WHICH TO DO
 4657                      	;
 4658                      	; shouldn't need this in YZIP ?!
 4659                      	;
 4660   55AD               	ZBUFOUT:
 4661                      	;
 4662                      	; CLEAR OUTPUT BUFFER BEFORE DOING ANYTHING FANCY
 4663                      	;
 4664   55AD               	CLRBUF:
 4665   55AD   20 5E 55    		jsr	LINOUT		; CLEAR BUFFER (DON'T RESET LINE COUNT)
 4666   55B0   A2 00       		ldx	#0
 4667   55B2   86 A9       		stx	CHRCNT
 4668   55B4   60          		rts
 4669                      	
 4670                      		; ------
 4671                      		; DIROUT
 4672                      		; ------
 4673                      		; ARG1 CONTAINS VALUE OF WHICH DEVICE TO SELECT
 4674                      		; OR DESELECT, ARG2 = THE TABLE ADDR FOR TABLE OUTPUT
 4675                      		; MULTIPLE DEVICE USAGE IS POSSIBLE.
 4676                      	
 4677   55B5   00 00       	SAVEXSIZE: db	0,0		; for formatted table saving
 4678                      	
 4679   55B7               	ZDIRT:
 4680   55B7   20 AD 55    	        jsr     CLRBUF          ; send out anything there now!
 4681                      	
 4682   55BA   A6 63       		ldx	ARG1+LO	
 4683   55BC   30 0A       		bmi	DIRRES		; NEGATIVE VALUE, DESELECTING
 4684   55BE   CA          		dex		
 4685   55BF   F0 11       		beq	DIR1		; 1 = SET OUTPUT TO SCREEN
  Wed May 24 1989 15:00                                                                                                  Page   69

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4686   55C1   CA          		dex		
 4687   55C2   F0 1E       		beq	DIR2		; 2 = SCRIPTING
 4688   55C4   CA          		dex		
 4689   55C5   F0 3C       		beq	DIR3		; 3 = TABLE
 4690   55C7   60          		rts			; INVALID VALUE
 4691   55C8               	DIRRES:
 4692   55C8   E8          		inx		
 4693   55C9   F0 0F       		beq	DRES1		; -1 = RESET TO SCREEN
 4694   55CB   E8          		inx		
 4695   55CC   F0 29       		beq	DRES2	
 4696   55CE   E8          		inx		
 4697   55CF   F0 3A       		beq	DRES3	
 4698   55D1   60          		rts			; INVALID VALUE, JUST LEAVE
 4699   55D2               	DIR1:
 4700   55D2   20 AD 55    		jsr	CLRBUF
 4701   55D5   A9 01       		lda 	#1		; turn screen on
 4702   55D7   85 B1       		sta	SCREENF	
 4703   55D9   60          		rts		
 4704   55DA               	DRES1:
 4705   55DA   20 AD 55    		jsr	CLRBUF
 4706   55DD   A9 00       		lda	#0
 4707   55DF   85 B1       		sta	SCREENF		; 0, TURN SCREEN OFF
 4708   55E1   60          		rts
 4709   55E2               	DIR2:
 4710   55E2   E8          		inx		
 4711   55E3   8E 73 6C    		stx	SCRIPTF		; SET SCRIPT FLAG ON
 4712   55E6   AD 11 96    		lda	ZBEGIN+ZFLAGS+1	; SET GAME FLAG ALSO
 4713   55E9   09 01       		ora	#%00000001	
 4714   55EB   8D 11 96    		sta	ZBEGIN+ZFLAGS+1	
 4715   55EE   AD 1B 4D    		lda	PSTAT		; CHECK IF PRINTER ALREADY INIT'D
 4716   55F1   D0 03       		bne	DIR2A	
 4717   55F3   20 31 4D    		jsr	PCHK		; NO, GO DO IT
 4718   55F6               	DIR2A:
 4719   55F6   60          		rts			; YES, READY TO LEAVE
 4720   55F7               	DRES2:
 4721   55F7   8E 73 6C    		stx	SCRIPTF		; TURN PRINTER OFF
 4722   55FA   AD 11 96    		lda	ZBEGIN+ZFLAGS+1	; AND TURN OFF GAME FLAG TOO
 4723   55FD   29 FE       		and	#%11111110	
 4724   55FF   8D 11 96    		sta	ZBEGIN+ZFLAGS+1	
 4725   5602   60          		rts		
 4726   5603               	DIR3:
 4727   5603   86 B1       	        stx     SCREENF         ; turn off screen
 4728   5605   E8          		inx		
 4729   5606   86 B2       		stx	TABLEF		; TURN TABLE OUTPUT FLAG ON
 4730   5608   4C 73 56    		jmp	START_TABLE	; and set things up
 4731   560B               	DRES3:
 4732   560B   A5 B2       		lda	TABLEF		; IF OFF ALREADY
 4733   560D   F0 63       		beq	OUT3		; LEAVE AS IS
 4734                      	
 4735   560F   86 B2       		stx	TABLEF		; TURN TBL OUTPUT OFF
 4736   5611   E8          	        inx                     ; turn screen back on
 4737   5612   86 B1       	        stx     SCREENF         ; screen back on
 4738                      	
 4739   5614   A9 03       	        lda     #3              ; add three to make it wrap
 4740   5616   18          	        clc                     ; ready for add
 4741   5617   6D 31 96    	        adc     ZBEGIN+ZTWIDTH+1 ; do it
 4742   561A   8D 31 96    	        sta     ZBEGIN+ZTWIDTH+1
 4743   561D   90 03       	        bcc     DRESCC          ; no wrap into MSB
 4744   561F   EE 30 96    	        inc     ZBEGIN+ZTWIDTH
 4745   5622               	DRESCC:
 4746   5622   4E 30 96    		lsr	ZBEGIN+ZTWIDTH+0 ; /4 to get # of pixels
 4747   5625   6E 31 96    		ror	ZBEGIN+ZTWIDTH+1
 4748   5628   4E 30 96    		lsr	ZBEGIN+ZTWIDTH+0
 4749   562B   6E 31 96    		ror	ZBEGIN+ZTWIDTH+1
 4750                      	
 4751                      	
 4752   562E   A5 19       		lda	FMTTBL		; did we do a formatted table?
 4753   5630   D0 2B       		bne	DRESFT		; yes, so fix things
 4754                      	;
 4755                      	; now put count into table
 4756                      	;
 4757   5632   A5 A0       		lda	DIRTBL+LO	; and put count into second byte of table
 4758   5634   85 8F       		sta	SPCL		; points to low par
 4759   5636   A5 A1       		lda	DIRTBL+HI	; get page 
 4760   5638   20 77 8F    		jsr	SETPC		; okay, page and bank
  Wed May 24 1989 15:00                                                                                                  Page   70

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4761   563B   85 90       		sta	SPCH
 4762   563D   84 91       		sty	SPCBNK
 4763   563F   AD 80 6C    		lda	DIRITM+LO	; (2 LESS THAN [DIRITM])
 4764   5642   38          		sec		
 4765   5643   E9 02       		sbc	#2	
 4766   5645   8D 80 6C    		sta	DIRITM+LO	; save this new count
 4767   5648   B0 03       		bcs	RESET0	
 4768   564A   CE 81 6C    		dec	DIRITM+HI	; wrapped downwards
 4769   564D               	RESET0:
 4770   564D   AD 81 6C    		lda	DIRITM+HI	; get hi part
 4771   5650   20 35 92    		jsr	STASHB		; saved that count
 4772   5653   20 9E 8F    		jsr	NEXTSPC		; and point to lo part
 4773   5656   AD 80 6C    		lda	DIRITM+LO	; and get lo part
 4774   5659   20 35 92    		jsr	STASHB		; and save it
 4775   565C   60          		rts			; done
 4776   565D               	DRESFT:
 4777   565D   A5 A9       		lda	CHRCNT		; anything in buffer?
 4778   565F   F0 03       		beq	DRES31		; nope
 4779   5661   20 BF 53    		jsr	TBLRTN		; then fill out last line
 4780   5664               	DRES31:
 4781   5664   AD B5 55    		lda	SAVEXSIZE+LO	; get old xsize back
 4782   5667   85 A2       		sta	XSIZE+LO	; restored
 4783   5669   AD B6 55    		lda	SAVEXSIZE+HI
 4784   566C   85 A3       		sta	XSIZE+HI
 4785   566E   A9 00       		lda	#0		; reset this flag too
 4786   5670   85 19       		sta	FMTTBL		; cleared
 4787   5672               	OUT3:
 4788   5672   60          		rts		
 4789                      	;
 4790                      	; set things up for doing table output
 4791                      	;
 4792   5673               	START_TABLE:
 4793                      	
 4794   5673   A5 66       		lda	ARG2+HI		; SET UP TBL
 4795   5675   85 A1       		sta	DIRTBL+HI	
 4796   5677   A5 65       		lda	ARG2+LO		; TO STORE CHARS IN
 4797   5679   85 A0       		sta	DIRTBL+LO	
 4798   567B   A9 02       		lda	#2
 4799   567D   8D 80 6C    		sta	DIRITM+LO	
 4800   5680   A9 00       		lda	#0	
 4801   5682   8D 81 6C    		sta	DIRITM+HI	
 4802   5685   8D 31 96    		sta	ZBEGIN+ZTWIDTH+1	; clear width count
 4803   5688   8D 30 96    		sta	ZBEGIN+ZTWIDTH+0
 4804                      	;
 4805                      	; check to see if we have formatted table
 4806                      	;
 4807   568B   A5 62       		lda	NARGS		; get # of arguments
 4808   568D   C9 03       		cmp	#3		; if == 3, then we wrap it
 4809   568F   F0 01       		beq	DIR30		; nope
 4810   5691   60          		rts			; all done other wise
 4811   5692               	DIR30:
 4812   5692   86 19       		stx	FMTTBL		; set formatted table flag
 4813   5694   A5 A2       		lda	XSIZE+LO	; save the current XSIZE
 4814   5696   8D B5 55    		sta	SAVEXSIZE+LO	; okay, did it
 4815   5699   A5 A3       		lda	XSIZE+HI	; and MSB
 4816   569B   8D B6 55    		sta	SAVEXSIZE+HI	; okay
 4817   569E   A5 67       		lda	ARG3+LO		; this is the actual amount
 4818   56A0   A6 68       		ldx	ARG3+HI		; get interesting arg
 4819   56A2   30 0B       		bmi	DIRFT1		; check for negative width
 4820   56A4   20 77 57    		jsr	SETWJ		; get the window offset
 4821   56A7   A0 14       		ldy	#WINXSZ		; get its XSIZE
 4822   56A9   B1 7A       		lda	(J),Y		; got it
 4823   56AB   85 A2       		sta	XSIZE+LO	; aren't we nice
 4824   56AD   D0 06       		bne	DIR31		; jump to end
 4825   56AF               	DIRFT1:
 4826   56AF   49 FF       		eor	#$FF		; turn to a positive number
 4827   56B1   85 A2       		sta	XSIZE+LO	; save it
 4828   56B3   E6 A2       		inc	XSIZE+LO	; to make it right
 4829   56B5               	DIR31:
 4830   56B5   A9 00       		lda	#0		; items starts at zero
 4831   56B7   8D 80 6C    		sta	DIRITM+LO	; okay
 4832   56BA   85 A3       		sta	XSIZE+HI	; clear out highness
 4833   56BC   06 A2       		asl	XSIZE+LO	; *2
 4834   56BE   26 A3       		rol	XSIZE+HI	
 4835   56C0   06 A2       		asl	XSIZE+LO	; *4
  Wed May 24 1989 15:00                                                                                                  Page   71

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4836   56C2   26 A3       		rol	XSIZE+HI
 4837   56C4   60          		rts		
 4838                      	
 4839                      		; ------
 4840                      		; CURSET
 4841                      		; ------
 4842                      		; SET CURSOR AT LINE (ARG1) AS OFFSET FROM TOP OF WINDOW
 4843                      		; AND AT COLUMN (ARG2) in (optional) window ARG3
 4844                      	
 4845   56C5               	ZCURST:
 4846   56C5   20 AD 55    		jsr	CLRBUF		; CLEAR OUT ANY NON DISPLAYED TEXT 1ST
 4847   56C8   A5 63       	        lda     ARG1+LO         ; see if < 0
 4848   56CA   C9 FF       	        cmp     #$FF            ; -1 == turn off cursor
 4849   56CC   D0 04       	        bne     ZCURS00         ; nope
 4850   56CE   A9 01       	        lda     #1              ; show cursor off
 4851   56D0   D0 06       	        bne     ZCURSTXX        ; go do it and return
 4852   56D2               	ZCURS00:
 4853   56D2   C9 FE       	        cmp     #$FE            ; -2 == turn cursor on
 4854   56D4   D0 06       	        bne     ZCURS0          ; nope, just deal with normally
 4855   56D6   A9 00       	        lda     #0              ; show cursor not off
 4856   56D8               	ZCURSTXX:
 4857   56D8   8D A2 6C    	        sta     CURSOR_OFF      ; show current cursor state
 4858   56DB   60          	        rts
 4859   56DC               	ZCURS0:
 4860   56DC   C6 63       		dec	ARG1+LO		; zero base both args
 4861   56DE   C6 65       		dec	ARG2+LO		; thanx
 4862   56E0               		
 4863   56E0   A5 62       		lda	NARGS		; check for id
 4864   56E2   C9 03       		cmp	#3		; if 3 args, then window ID specified
 4865   56E4   F0 04       		beq	ZCURS1		; not 3, so use current window
 4866                      	
 4867   56E6   A5 A6       		lda	CURWIN		; show current window being done
 4868   56E8   85 67       		sta	ARG3+LO		; thanx
 4869   56EA               	ZCURS1:
 4870   56EA   A5 67       		lda	ARG3+LO		; get window ID
 4871   56EC   20 77 57    		jsr	SETWJ		; put address into J
 4872   56EF   A5 63       		lda	ARG1+LO		; GET LINE
 4873   56F1   A0 02       		ldy	#WINHGHT	; check against height
 4874   56F3   D1 7A       		cmp	(J),Y		; too far?
 4875   56F5   90 05       		bcc	ZCURS3		; no, so use it
 4876   56F7   B1 7A       		lda	(J),Y		; got max out
 4877   56F9   A8          		tay			; but one too far
 4878   56FA   88          		dey			; all better now
 4879   56FB   98          		tya			; back to A
 4880   56FC               	ZCURS3:
 4881   56FC   18          		clc			; get ready for add
 4882   56FD   A0 00       		ldy	#WINTOP		; do y pos first
 4883   56FF   71 7A       		adc	(J),Y		; add in top to get absolute value
 4884   5701   A0 04       		ldy	#WINY		; get y pos offset
 4885   5703   91 7A       		sta	(J),Y		; save here
 4886   5705   A5 65       		lda	ARG2+LO		; GET COLUMN
 4887   5707   A0 03       		ldy	#WINWID		; check against width
 4888   5709   D1 7A       		cmp	(J),Y		; is it to for right (like Reagan?)
 4889   570B   90 05       		bcc	ZCURS4		; nope, must be dukakis
 4890   570D   B1 7A       		lda	(J),Y		; get max
 4891   570F   A8          		tay			; for going down one
 4892   5710   88          		dey			; done it
 4893   5711   98          		tya			; back to A for usefullness
 4894   5712               	ZCURS4:
 4895   5712   A0 01       		ldy	#WINLEFT	; get left edge to absolute it
 4896   5714   71 7A       		adc	(J),Y		; carry clear from above
 4897   5716   A0 05       		ldy	#WINX		; this is the x pos
 4898   5718   91 7A       		sta	(J),Y		; into the structure
 4899                      	;
 4900                      	; now check for current window again, move cursor anyway
 4901                      	;	
 4902   571A   4C B1 4D    		jmp	GET_CURSOR	; get cursor pos from WINDOW
 4903                      	
 4904                      		; ------
 4905                      		; CURGET
 4906                      		; ------
 4907                      	
 4908   571D               	ZCURGT:
 4909   571D   20 AD 55    		jsr	CLRBUF		; flush the buffer
 4910                      	
  Wed May 24 1989 15:00                                                                                                  Page   72

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4911   5720   20 9F 4D    		jsr	SAVE_CURSOR	; save the current position
 4912                      	
 4913   5723   C6 62       		dec	NARGS		; see how many arguments
 4914   5725   F0 04       		beq	ZCURG1		; use main window
 4915   5727   A5 65       		lda	ARG2+LO		; get window id
 4916   5729   10 02       		bpl	ZCURG2		; and figger it out
 4917   572B               	ZCURG1:
 4918   572B   A5 A6       		lda	CURWIN		; use current window
 4919   572D               	ZCURG2:
 4920   572D   20 77 57    		jsr	SETWJ		; make J point to right place
 4921                      	
 4922   5730   A5 64       		lda	ARG1+HI		; get table address
 4923   5732   20 77 8F    		jsr	SETPC		; get real address in memory
 4924   5735   84 91       		sty	SPCBNK		; set bank
 4925   5737   85 90       		sta	SPCH		; and page
 4926   5739   A5 63       		lda	ARG1+LO		; get table offset
 4927   573B   85 8F       		sta	SPCL		; and save it
 4928                      	
 4929   573D   A9 00       		lda	#0		; zero hi part of Y pos
 4930   573F   20 35 92    		jsr	STASHB		; and save it
 4931   5742   20 9E 8F    		jsr	NEXTSPC		; and point to next one
 4932   5745   20 5C 57    		jsr	FETCHCY		; Fetch Y pos
 4933   5748   20 35 92    		jsr	STASHB		; and save it
 4934   574B   20 9E 8F    		jsr	NEXTSPC
 4935                      	;
 4936                      	; now for the X pos
 4937   574E   A9 00       		lda	#0		; zero top byte of x pos
 4938   5750   20 35 92    		jsr	STASHB
 4939   5753   20 9E 8F    		jsr	NEXTSPC
 4940   5756   20 69 57    		jsr	FETCHCX		; and now the X pos, and return
 4941   5759   4C 35 92    		jmp	STASHB		; and stash it away
 4942                      	
 4943                      	;
 4944                      	; FETCHCY - get the relativized Y pos into [A]
 4945                      	;	J points to window structure
 4946   575C               	FETCHCY:	
 4947   575C   A0 04       		ldy	#WINY		; get Y pos of window's cursor
 4948   575E   B1 7A       		lda	(J),Y		; got it
 4949   5760   A0 00       		ldy	#WINTOP		; need to de-absolute it
 4950   5762   38          		sec			; get ready for sub
 4951   5763   F1 7A       		sbc	(J),Y		; get relative pos
 4952   5765   AA          		tax			; for 1 basing it
 4953   5766   E8          		inx			; 1 align it
 4954   5767   8A          		txa			; and put for save
 4955   5768   60          		rts
 4956                      	;
 4957                      	; FETCHCX - get relativized X pos into [A]
 4958                      	;	J points to window structure
 4959   5769               	FETCHCX:
 4960   5769   A0 05       		ldy	#WINX		; get X pos of cursor
 4961   576B   B1 7A       		lda	(J),Y		; got it
 4962   576D   A0 01       		ldy	#WINLEFT	; relativize it
 4963   576F   38          		sec			; get ready for sub
 4964   5770   F1 7A       		sbc	(J),Y		; subtract left edge
 4965   5772   AA          		tax			; for incing
 4966   5773   E8          		inx			; 1 ALIGN IT
 4967   5774   8A          		txa
 4968   5775   60          		rts
 4969                      	
 4970                      		; -----
 4971                      		; DIRIN
 4972                      		; -----
 4973                      		; NOT YET IMPLEMENTED, BUT RESERVED
 4974                      	
 4975   5776   60          	ZDIRIN:	RTS		
 4976                      	
 4977                      	;
 4978                      	; SETWJ - set up J to point to window structure for window ID in [A]
 4979                      	;
 4980   5777               	SETWJ:
 4981   5777   A8          		tay			; check for -3 (current window)
 4982   5778   10 02       		bpl	SWJ1		; nope, window ID here
 4983   577A   A5 A6       		lda	CURWIN		; -3 means current window
 4984   577C               	SWJ1:
 4985   577C   0A          		asl	A		; shift to make word index
  Wed May 24 1989 15:00                                                                                                  Page   73

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4986   577D   A8          		tay			; and now make index
 4987   577E   B9 47 6E    		lda	WINTABLE,Y	; get lo part of window struct address
 4988   5781   85 7A       		sta	J+LO		; and save it
 4989   5783   B9 48 6E    		lda	WINTABLE+1,Y	; here's the hi part
 4990   5786   85 7B       		sta	J+HI		; prove it
 4991   5788   60          		rts
 4992                      	
 4993                      		; -----
 4994                      		; ERASE
 4995                      		; -----
 4996                      	
 4997   5789               	ZERASE:
 4998   5789   A5 63       		lda	ARG1+LO	
 4999   578B   C9 01       		cmp	#1	
 5000   578D   D0 06       		bne	ZEROUT		; not clreol
 5001                      	
 5002   578F   20 AD 55    		jsr	CLRBUF
 5003   5792   4C FD 60    		jmp	CLREOL		; CLEAR TO END OF LINE
 5004   5795               	ZEROUT:
 5005   5795   85 0C       	        sta     CLSWIDTH        ; this many pixels wide
 5006   5797   A9 09       	        lda     #FONT_H         ; pixels of font_height
 5007   5799   85 0D       	        sta     CLSHEIGHT
 5008   579B   A5 00       	        lda     SCRCX           ; start at current cursor pos
 5009   579D   85 0A       	        sta     CLSLEFT
 5010   579F   A5 01       	        lda     SCRCY
 5011   57A1   85 0B       	        sta     CLSTOP
 5012   57A3   4C 00 5F    	        jmp     CLS             ; and do it
 5013                      	
 5014                      	; -----
 5015                      	; CLEAR the current window
 5016                      	; -----
 5017   57A6   0000        	SAVEXY:	dw	0
 5018                      	
 5019   57A8               	ZCLR:
 5020   57A8   20 AD 55    		jsr	CLRBUF		; flush the current buffer
 5021   57AB   20 9F 4D    		jsr	SAVE_CURSOR	; save the cursor pos
 5022                      	
 5023   57AE   A5 63       		lda	ARG1+LO		; CHECK WHAT TO DO
 5024   57B0   10 26       		bpl	CLRW		; a particular window
 5025   57B2   C9 FD       	 	cmp	#$FD		; -3 means current window	
 5026   57B4   F0 22       		beq	CLRW		; so just handle it regular
 5027   57B6   C9 FE       		cmp	#$FE		; clear with nothing social
 5028   57B8   F0 07       		beq	CLRCLS		; just clear the screen
 5029                      	;
 5030                      	; UNSPLIT SCREEN & CLEAR IT
 5031                      	;
 5032   57BA   A9 00       		lda	#0		; just use SPLIT 0
 5033   57BC   85 63       		sta	ARG1+LO		; as if called normally
 5034   57BE   20 DD 4D    		jsr	ZSPLIT		; do the split
 5035                      	;
 5036                      	; just clear the entire screen
 5037                      	;
 5038   57C1               	CLRCLS:
 5039   57C1   A9 00       		lda	#0		; clear the entire screen
 5040   57C3   85 0A       		sta	CLSLEFT		; from top left
 5041   57C5   85 0B       		sta	CLSTOP
 5042   57C7   A9 8C       		lda	#MAXWIDTH	; to bottom right
 5043   57C9   85 0C       		sta	CLSWIDTH
 5044   57CB   A9 C0       		lda	#MAXHEIGHT
 5045   57CD   85 0D       		sta	CLSHEIGHT
 5046                      	
 5047   57CF   20 00 5F    		jsr	CLS		; do the clear screen (no cursor movement)
 5048   57D2   A5 63       		lda 	ARG1+LO		; check for -2
 5049   57D4   30 44       		bmi	ZCLRX 		; it is, don't move cursor
 5050   57D6   10 1B       		bpl	ZCLEARX		; move cursor
 5051   57D8               	CLRW:
 5052   57D8   20 77 57    		jsr	SETWJ		; get me the window pointer
 5053   57DB   A0 00       		ldy	#WINTOP		; step thro to get data
 5054   57DD   B1 7A       		lda	(J),Y		; TOP
 5055   57DF   85 0B       		sta	CLSTOP		; save for clear
 5056   57E1   C8          		iny			; point to left
 5057   57E2   B1 7A       		lda	(J),Y		; get it
 5058   57E4   85 0A       		sta	CLSLEFT		; tell CLS
 5059   57E6   C8          		iny			; now at WINHGHT
 5060   57E7   B1 7A       		lda	(J),Y		; got it
  Wed May 24 1989 15:00                                                                                                  Page   74

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5061   57E9   85 0D       		sta	CLSHEIGHT	; save for clear
 5062   57EB   C8          		iny			; now at WINWID
 5063   57EC   B1 7A       		lda	(J),Y		; get height
 5064   57EE   85 0C       		sta	CLSWIDTH	; saved
 5065   57F0   20 00 5F    		jsr	CLS		; screen cleared
 5066                      	;
 5067                      	; now move the cursor to 1,1, if not == -2
 5068                      	;
 5069   57F3               	ZCLEARX:
 5070   57F3   A5 63       		lda	ARG1+LO		; check arg
 5071   57F5   20 77 57    		jsr	SETWJ		; make sure J still points to window
 5072   57F8   A0 00       		ldy	#WINTOP		; put at top left of window
 5073   57FA   B1 7A       		lda	(J),Y		; get top
 5074   57FC   A0 04       		ldy	#WINY		; and make it the y pos
 5075   57FE   91 7A       		sta	(J),Y		; of the cursor
 5076   5800   A0 01       		ldy	#WINLEFT	; and the left is
 5077   5802   B1 7A       		lda 	(J),Y		; the
 5078   5804   18          		clc			; add in the left margin
 5079   5805   A0 06       		ldy	#WINLM		; here's the left margin
 5080   5807   71 7A       		adc	(J),Y		; added it
 5081   5809   A0 05       		ldy	#WINX		; x pos of the
 5082   580B   91 7A       		sta	(J),Y		; cursor
 5083   580D   A9 00       		lda	#0		; and clear out line count
 5084   580F   A0 13       		ldy	#WINLCNT	; line count
 5085   5811   91 7A       		sta	(J),Y		; okay
 5086   5813   A0 15       		ldy	#WINLLEN	; and length of current line
 5087   5815   91 7A       		sta	(J),Y		; okay
 5088   5817   C8          		iny			; do hi
 5089   5818   91 7A       		sta	(J),Y		; okay
 5090   581A               	ZCLRX:
 5091   581A   4C B1 4D    		jmp	GET_CURSOR	; restore the cursor pos for the current window
 5092                      	
 5093                      	; ------
 5094                      	; PRINTT
 5095                      	; ------
 5096                      	; PRINT A TABLE TO SCREEN, ARG1 = # OF BYTES
 5097                      	; ARG2 = WIDTH, ARG3 (DEF = 1) = HEIGHT
 5098                      	
 5099          0078        	OLDCHZ	EQU	I+LO		; EASIER TO READ
 5100          0079        	OLDEHZ	EQU	I+HI
 5101          007E        	OLDCVT	EQU	L+LO
 5102                      	
 5103   581D   0000        	TBL_LEN DW	0		; save for length
 5104                      	
 5105   581F               	ZPRNTT:
 5106                      	;
 5107                      	; make sure the buffer is empty, thanks
 5108                      	;
 5109   581F   20 AD 55    		jsr	CLRBUF
 5110                      	
 5111   5822   A5 63       		lda	ARG1+LO		; USE GETBYT AS TBL COULD
 5112   5824   85 86       		sta	MPCL		; BE ANYWHERE
 5113   5826   A5 64       		lda	ARG1+HI
 5114   5828   85 87       		sta	MPCM
 5115   582A   A9 00       		lda	#0
 5116   582C   85 88       		sta	MPCH
 5117   582E   20 80 90    		jsr	VLDMPC
 5118                      	
 5119   5831   A5 65       		lda	ARG2+LO		; ONLY A BYTE AS MAX
 5120   5833   F0 58       		beq	PTTDUN		; QUIT NOW IF NULL
 5121                      	
 5122   5835   85 BF       		sta	TBLWIDTH	; width of the table
 5123   5837   85 C0       		sta	TBLCNT		; start counter off at width
 5124   5839   C6 62       		dec	NARGS		; count down to 1 (maybe)
 5125   583B   A5 62       		lda	NARGS
 5126   583D   C9 01       		cmp	#1
 5127   583F   F0 02       		beq	NOHIGHT		; DEFAULT HEIGHT IS 1
 5128   5841   A5 67       		lda	ARG3+LO		; get passed height
 5129   5843               	NOHIGHT:
 5130   5843   85 BE       		sta	TBLHEIGHT	; height of the table (at least 1)
 5131   5845   A5 00       		lda	SCRCX
 5132   5847   85 79       		sta	OLDEHZ
 5133   5849   38          		sec			; subtract left margin to get how long line is
 5134   584A   E5 04       		sbc	LEFTMRG		; okay we did that
 5135   584C   8D 1D 58    		sta	TBL_LEN+LO	; this is how big line is too
  Wed May 24 1989 15:00                                                                                                  Page   75

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5136   584F   A9 00       		lda	#0		; clear MSB
 5137   5851   0E 1D 58    		asl	TBL_LEN+LO	; *2
 5138   5854   2A          		rol	A
 5139   5855   0E 1D 58    		asl	TBL_LEN+LO	; *4
 5140   5858   2A          		rol	A
 5141   5859   8D 1E 58    		sta	TBL_LEN+HI	; save
 5142   585C               	PTTLP:
 5143   585C   20 09 92    		jsr	GETBYT		; GET A BYTE
 5144   585F   20 06 53    		jsr	COUT		; and send it out
 5145                      	
 5146   5862   C6 C0       		dec	TBLCNT		; one more byte done
 5147   5864   D0 F6       		bne	PTTLP
 5148   5866   C6 BE       		dec	TBLHEIGHT	; IF DONE ALL LINES
 5149   5868   F0 23       		beq	PTTDUN		; LEAVE
 5150                      	
 5151   586A   20 AD 55    		jsr	CLRBUF		; so send out stuff that's there
 5152                      	
 5153   586D   A5 79       		lda	OLDEHZ		; get old x pos
 5154   586F   85 00       		sta	SCRCX		; and restore it
 5155   5871   A9 01       		lda	#1		; show cursor changed
 5156   5873   8D 77 6C    		sta	CURSFLG		; okay
 5157   5876   A5 01       		lda	SCRCY		; point to next line
 5158   5878   18          		clc			; by adding in the font height
 5159   5879   69 09       		adc	#FONT_H		; okay, goody
 5160   587B   85 01       		sta	SCRCY		; and here we are
 5161                      	
 5162   587D   AD 1E 58    		lda	TBL_LEN+HI	; reset length
 5163   5880   85 A8       		sta	LENGTH+HI	; hi part
 5164   5882   AD 1D 58    		lda	TBL_LEN+LO	; lo part
 5165   5885   85 A7       		sta	LENGTH+LO	; just a lo
 5166                      	
 5167   5887   A5 BF       		lda	TBLWIDTH	; RESET COUNT
 5168   5889   85 C0       		sta	TBLCNT		; thanx
 5169   588B   D0 CF       		bne	PTTLP		; GO DO NEXT LINE
 5170   588D               	PTTDUN:
 5171   588D   20 AD 55    		jsr	CLRBUF		; send out last bit
 5172   5890   60          		rts
 5173                      	;--------------
 5174                      	; ZPRINTF
 5175                      	;--------------
 5176                      	; ZPRINTF - print a formatted table
 5177                      	;
 5178   5891               	ZPRINTF:
 5179   5891   A5 63       		lda	ARG1+LO		; USE GETBYT AS TBL COULD
 5180   5893   85 86       		sta	MPCL		; BE ANYWHERE
 5181   5895   A5 64       		lda	ARG1+HI
 5182   5897   85 87       		sta	MPCM
 5183   5899   A9 00       		lda	#0
 5184   589B   85 88       		sta	MPCH
 5185   589D   20 80 90    		jsr	VLDMPC
 5186                      	
 5187   58A0   A5 00       		lda	SCRCX		; save the X pos
 5188   58A2   85 79       		sta	OLDEHZ		; saved here
 5189   58A4               	ZPFL1:
 5190   58A4   20 09 92    		jsr	GETBYT		; get the length byte
 5191   58A7   F0 21       		beq	ZPFX		; no more if == 0
 5192   58A9   85 BF       		sta	TBLWIDTH	; keep track of it
 5193   58AB               	ZPFL2:
 5194   58AB   20 09 92    		jsr	GETBYT		; now get the char byte
 5195   58AE   20 7D 5D    		jsr	CHAR		; and send it yt
 5196   58B1   C6 BF       		dec	TBLWIDTH	; any more?
 5197   58B3   D0 F6       		bne	ZPFL2		; ayyup
 5198                      	
 5199   58B5   20 EC 71    	 	jsr	DISP_LINE	; make sure line goes out
 5200   58B8   A5 79       		lda	OLDEHZ		; reset a few things
 5201   58BA   85 00       		sta	SCRCX		; including x pos
 5202   58BC   A9 01       		lda	#1		; show cursor changed
 5203   58BE   8D 77 6C    		sta	CURSFLG		; okay
 5204   58C1   A5 01       		lda	SCRCY		; point to next line
 5205   58C3   18          		clc			; by adding in the font height
 5206   58C4   69 09       		adc	#FONT_H		; okay, goody
 5207   58C6   85 01       		sta	SCRCY		; and here we are
 5208   58C8   D0 DA       		bne	ZPFL1		; and do it again
 5209   58CA               	ZPFX:
 5210   58CA   60          		rts
  Wed May 24 1989 15:00                                                                                                  Page   76

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5211                      	; ------------
 5212                      	; SET NEW FONT
 5213                      	; ------------
 5214                      	
 5215                      	; Font 4 is mono-spaced font.
 5216                      	
 5217   58CB               	ZFONT:
 5218   58CB   20 AD 55    	        jsr     CLRBUF          ; clear the buffer first
 5219                      	
 5220   58CE   C6 62       		dec	NARGS		; did we get passed a window id?
 5221   58D0   D0 04       		bne	ZFNTWID		; yup
 5222   58D2   A9 FD       		lda	#$FD		; -3 means current window
 5223   58D4   85 65       		sta	ARG2+LO		; make it the arg2 then
 5224   58D6               	ZFNTWID:
 5225   58D6   A5 65       		lda	ARG2+LO		; get window we are interested in
 5226   58D8   20 77 57    		jsr	SETWJ		; make [J] point to window struct
 5227                      	
 5228   58DB   A5 63       		lda	ARG1+LO		; check for 
 5229   58DD   C9 01       		cmp	#1		; font 1
 5230   58DF   F0 0E       		beq	ZFNT1		;  or
 5231   58E1   C9 04       		cmp	#4		; font 4 (monospace)
 5232   58E3   D0 2A       		bne	ZFBAD		; nope, so die
 5233                      	;
 5234                      	; font 4 is the monospaced font
 5235                      	;
 5236   58E5   A0 10       		ldy	#WINFSIZE	; point to width
 5237   58E7   A9 03       		lda	#MFONT_W	; get game width
 5238   58E9   91 7A       		sta 	(J),Y		; store the width
 5239   58EB   A9 03       		lda	#3		; set font ID
 5240   58ED   D0 08       		bne	ZFNTEX		; all done
 5241   58EF               	ZFNT1:
 5242   58EF   A0 10       		ldy	#WINFSIZE	; point to width
 5243   58F1   A9 02       		lda	#FONT_W		; get game width
 5244   58F3   91 7A       		sta 	(J),Y		; store the width
 5245   58F5   A9 00       		lda	#0		; set font ID
 5246   58F7               	ZFNTEX:
 5247   58F7   A0 0F       		ldy	#WINFONT	; set font
 5248   58F9   48          		pha			; save font id
 5249   58FA   B1 7A       		lda	(J),Y		; get old font id
 5250   58FC   AA          		tax			; save old font id
 5251   58FD   68          		pla			; get new one back
 5252   58FE   91 7A       		sta	(J),Y		; save in structure
 5253   5900   B1 05       		lda	(WINDOW),Y	; get current window font
 5254   5902   F0 02       		beq	ZFNT0X		; set flag with zero	
 5255   5904   A9 0C       		lda	#MONOFONT_W	; get width of mono spaced font
 5256   5906               	ZFNT0X:
 5257   5906   85 C1       		sta	FONTFLG		; and set flag too
 5258   5908   E8          		inx			; make it say correct font ID for game
 5259   5909   8A          		txa			; put in A for put val
 5260   590A   A2 00       		ldx	#0		; clear X
 5261   590C   4C E1 43    		jmp	PUTVAL		; and return it
 5262   590F               	ZFBAD:
 5263   590F   4C DA 43    		jmp	RET0		; TELL IT DOESN'T WORK
 5264                      	; ------------------------------
 5265                      	; FETCH A LINE OF INPUT FOR READ
 5266                      	; ------------------------------
 5267                      	; ENTRY: Relative READ table address in RDTBL1
 5268                      	; EXIT: # CHARS READ IN [A]
 5269   5912               	SV_SPC:	ds	3		; save SPC here for later usage
 5270                      	
 5271   5915               	INPUT:
 5272   5915   20 AD 55    		jsr	CLRBUF		; FLUSH [LBUFF]
 5273   5918   A0 00       		ldy	#0		; RESET LINE COUNT
 5274   591A   84 79       		sty	I+HI		; clear local variables
 5275   591C   84 78       		sty	I+LO	
 5276   591E   84 7B       		sty	J+HI	
 5277   5920   84 7A       		sty	J+LO	
 5278   5922   8C 64 5B    		sty	BRKCHR		; init break char
 5279   5925   84 AB       		sty	LINCNT		; RESET LINE COUNT
 5280   5927   8C A4 6C    	        sty     PTR_COUNT       ; we start by looking at pointer        
 5281   592A   8C 77 6C    	        sty     CURSFLG         ; make sure we don't change cursor
 5282                      	;
 5283                      	; check for new TCHARS table
 5284                      	;
 5285   592D   AD 2F 96    		lda	ZBEGIN+ZTCHAR+1	; so check lower byte for different tchars
  Wed May 24 1989 15:00                                                                                                  Page   77

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5286   5930   CD 84 6C    		cmp	SVTCHAR+LO	; is it different?
 5287   5933   D0 08       		bne	IO_DOT		; ayyup, get new one
 5288   5935   AD 2E 96    		lda	ZBEGIN+ZTCHAR	; get current TCHARS hi part
 5289   5938   CD 85 6C    		cmp	SVTCHAR+HI	; is it the same as saved one?
 5290                      	
 5291   593B   F0 03       		beq	IOj		; yes, so don't muck with it
 5292   593D               	IO_DOT:
 5293   593D   20 79 5A    		jsr	DO_TCHARS	; new table, so copy it over
 5294                      	;
 5295                      	; now set up FPC
 5296                      	;
 5297   5940               	IOj:
 5298   5940   AD 7B 6C    		lda	RDTBL1+HI	; get page of table
 5299   5943   20 77 8F    		jsr	SETPC		; and get me the memory page and bank
 5300   5946   85 8D       		sta	FPCH		; save page
 5301   5948   84 8E       		sty	FPCBNK		; and bank
 5302   594A   AD 7A 6C    		lda	RDTBL1+LO	; and get offset
 5303   594D   85 8C       		sta	FPCL		; set up FPC/SPC
 5304   594F   20 56 92    		jsr	FETCHB		; get length of line
 5305   5952   A8          		tay			; for dec'ing
 5306   5953   88          		dey			; don't count the offset byte
 5307   5954   88          		dey			; and leave room for terminator
 5308   5955   84 17       		sty	CHRMAX		; and save it
 5309   5957   20 BE 8F    		jsr	NEXTFPC		; point to next byte
 5310   595A   20 56 92    		jsr	FETCHB		; get current offset into buffer
 5311   595D   8D 5D 5B    		sta	CHARCNT		; save how many chars out there
 5312   5960   20 BE 8F    		jsr	NEXTFPC 	; point to beginning of data buffer
 5313                      	;
 5314                      	; now finish setting up saved SPC
 5315                      	;
 5316   5963   A2 02       		ldx	#2
 5317   5965               	INSVCL:
 5318   5965   B5 8C       		lda	FPC,X		; get byte to saved for use later on
 5319   5967   9D 12 59    		sta	SV_SPC,X	; it is saved here
 5320   596A   CA          		dex
 5321   596B   10 F8       		bpl	INSVCL		; next!
 5322                      	;
 5323                      	; now copy current buffer into local buffer
 5324                      	;
 5325   596D   AD 5D 5B    		lda	CHARCNT		; make sure we have some
 5326   5970   F0 11       		beq	CPIOLX		; nope, none in there now
 5327   5972   A2 00       		ldx	#0		; start at first char
 5328   5974               	CPIOL:
 5329   5974   20 56 92    		jsr	FETCHB		; get a char
 5330   5977   9D 00 02    		sta	LBUFF,X		; save char
 5331   597A   20 BE 8F    		jsr	NEXTFPC		; point to next one
 5332   597D   E8          		inx			; next char
 5333   597E   EC 5D 5B    		cpx	CHARCNT		; got them all yet?
 5334   5981   D0 F1       		bne	CPIOL		; nope
 5335   5983               	CPIOLX:
 5336   5983   20 0E 4F    		jsr	CHKTME		; START  TIME LIMIT
 5337                      	;
 5338                      	; this is the get-a-key-and-whack-on-it loop
 5339                      	;
 5340   5986               	INLOOP:
 5341   5986   A5 79       		lda	I+HI		; is there a time?
 5342   5988   F0 08       		beq	INPL1		; nope
 5343   598A   20 C9 4F    		jsr	TIMIN		; do timed input
 5344   598D   90 06       		bcc	INPL2		; got a char, process it
 5345   598F   4C 73 5A    		jmp	LEXBAD		; timed out with nothing there!
 5346   5992               	INPL1:
 5347   5992   20 31 51    		jsr	GETKEY		; let apple do the walking
 5348   5995               	INPL2:
 5349   5995   20 B0 5A    		jsr	ISTCHR		; CHECK IF IT'S AN ACCEPTABLE TERMINATOR KEY
 5350   5998   B0 0D       		bcs	NOTYET
 5351                      	
 5352   599A   8D 64 5B    		sta	BRKCHR
 5353   599D   C9 0D       		cmp	#EOL		; IF EOL PUT TO SCREEN
 5354   599F   F0 03       		beq	ENDLINx
 5355   59A1   4C 2A 5A    		jmp	ENDIN		; ELSE JUST END
 5356   59A4               	ENDLINx:
 5357   59A4   4C 1A 5A    	        jmp     ENDLIN          ; can't reach with a branch
 5358   59A7               	NOTYET:
 5359   59A7   A0 FF       	        ldy     #$FF            ; restart pointer device counter
 5360   59A9   8C A4 6C    	        sty     PTR_COUNT       ; and start again
  Wed May 24 1989 15:00                                                                                                  Page   78

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5361   59AC   A8          		tay			; check for functions keys that aren't
 5362   59AD   30 65       		bmi	CBAD		; terminators and feep if it is
 5363   59AF   C9 0D       		cmp	#EOL		; EOL?
 5364   59B1   F0 67       		beq	ENDLIN		; LINE DONE IF SO
 5365   59B3   C5 1B       		cmp	ESCAPE		; don't allow escape char's thru
 5366   59B5   F0 5D       		beq	CBAD		; okay, I won't
 5367                      	
 5368   59B7   C9 08       		cmp	#BACKSPACE	; BACKSPACE?
 5369   59B9   F0 38       		beq	BACKUP		; SPECIAL HANDLING
 5370   59BB   C9 1B       	        cmp     #ESCAPE         ; ESCAPE char?
 5371   59BD   F0 55       	        beq     CBAD            ; don't like it
 5372                      	
 5373   59BF   AC 5D 5B    		ldy	CHARCNT		; where do we put char?
 5374   59C2   C4 17       		cpy	CHRMAX		; are we filled up?
 5375   59C4   B0 4E       		bcs	CBAD		; boy, am i full
 5376                      	
 5377   59C6   48          		pha			; save it
 5378   59C7   AA          		tax			; use as index
 5379   59C8   A5 A7       		lda	LENGTH+LO	; GET LINE LENGTH COUNTER
 5380   59CA   18          		clc 			; get ready for add
 5381   59CB   7D 25 64    		adc	CHWID,X		; add width
 5382   59CE   A8          	        tay                     ; save LSB in Y
 5383   59CF   A6 A8       	        ldx     LENGTH+HI       ; get high byte        
 5384   59D1   90 01       		bcc	INP0C		; no wrap
 5385   59D3   E8          		inx             	; okay, wrap then
 5386   59D4               	INP0C:
 5387   59D4   68          		pla			; get char back
 5388   59D5   E4 A3       		cpx	XSIZE+HI	; check MSB first
 5389   59D7   90 04       		bcc	NOIOWRAP	; no need to check lsb
 5390   59D9   C4 A2       		cpy	XSIZE+LO	; end of screen line?
 5391   59DB   B0 37       		bcs     CBAD            ; reached end, so just beep
 5392   59DD               	NOIOWRAP:
 5393   59DD   86 A8       	        stx     LENGTH+HI       ; save MSB
 5394   59DF   84 A7       	        sty     LENGTH+LO       ; and LSB
 5395   59E1   AE 5D 5B    		ldx	CHARCNT		; for putting in line buffer
 5396   59E4   9D 00 02    		sta	LBUFF,X		; and save it in case we goto printer
 5397   59E7   20 7D 5D    		jsr	CHAR		; SEND TO SCREEN
 5398   59EA   20 EC 71    		jsr	DISP_LINE	; show char
 5399   59ED   EE 5D 5B    		inc	CHARCNT		; NEXT POSITION IN LINE
 5400   59F0   4C 86 59    		jmp	INLOOP		; NO, GET ANOTHER CHAR
 5401                      	;
 5402                      	; HANDLE BACKSPACE
 5403                      	;
 5404   59F3               	BACKUP:
 5405   59F3   AE 5D 5B    		ldx	CHARCNT		; if == 2 then empty
 5406   59F6   F0 1C       		beq	CBAD		; JMP to beeping
 5407   59F8   CA          		dex			; get rid of char
 5408   59F9   8E 5D 5B    		stx	CHARCNT		; saved
 5409   59FC   BD 00 02    		lda	LBUFF,X		; get char we are interested in
 5410   59FF   AA          		tax			; put in x
 5411                      	
 5412   5A00   A5 A7       		lda	LENGTH+LO	; GET LINE LENGTH COUNTER
 5413   5A02   38          		sec 			; get ready for sub
 5414   5A03   FD 25 64    		sbc	CHWID,X		; sub width
 5415   5A06   85 A7       		sta	LENGTH+LO	; update length
 5416   5A08   B0 02       		bcs	BCKP1		; no wrap
 5417   5A0A   C6 A8       		dec	LENGTH+HI	; okay, wrap then
 5418   5A0C               	BCKP1:
 5419   5A0C   A9 08       		lda	#BACKSPACE	; so do erasing backspace
 5420   5A0E   20 7D 5D    		jsr	CHAR
 5421   5A11   4C 86 59    		jmp	INLOOP
 5422   5A14               	CBAD:
 5423   5A14   20 C3 4E    		jsr	BEEP		; ELSE SCREAM WITH PAIN
 5424   5A17   4C 86 59    		jmp	INLOOP		; AND WAIT FOR SOMETHING BETTER
 5425                      	;
 5426                      	; HANDLE END OF LINE KEY
 5427                      	;
 5428   5A1A               	ENDLIN:
 5429   5A1A   8D 64 5B    		sta	BRKCHR
 5430   5A1D   A9 0D       		lda	#EOL		; get EOL char
 5431   5A1F   20 7D 5D    		jsr	CHAR		; SEND EOL TO SCREEN
 5432   5A22   A9 00       		lda	#0		; and show 0 length of line out there
 5433   5A24   85 A7       		sta	LENGTH+LO	; thanx
 5434   5A26   85 A8       		sta	LENGTH+HI	; and msb
 5435   5A28   E6 AB       		inc	LINCNT		; take into account the <CR> at EOL
  Wed May 24 1989 15:00                                                                                                  Page   79

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5436   5A2A               	ENDIN:
 5437                      	;
 5438                      	; now save lbuff in table for posterity
 5439                      	;
 5440   5A2A   AD 14 59    		lda	SV_SPC+ABANK	; get bank first
 5441   5A2D   85 91       		sta	SPCBNK		; saved
 5442   5A2F   AD 13 59    		lda	SV_SPC+HI
 5443   5A32   85 90       		sta	SPCH
 5444   5A34   AD 12 59    		lda	SV_SPC+LO
 5445   5A37   85 8F       		sta	SPCL
 5446   5A39   A2 00       		ldx	#0		; start with first char in buffer
 5447   5A3B               	ENDLOOP:
 5448   5A3B   EC 5D 5B    		cpx	CHARCNT		; done yet?
 5449   5A3E   F0 16       		beq	INP111
 5450   5A40   BD 00 02    		lda	LBUFF,X		; get char
 5451   5A43   C9 41       		cmp	#'A'		; IF CHAR IS UPPERCASE ALPHA,
 5452   5A45   90 06       		bcc	LEX		; CONVERT TO LOWER CASE
 5453   5A47   C9 5B       		cmp	#'Z'+1	
 5454   5A49   B0 02       		bcs	LEX
 5455   5A4B   69 20       		adc	#$20		; converting away
 5456   5A4D               	LEX:
 5457   5A4D   20 35 92    		jsr	STASHB		; okay, stashing away
 5458   5A50   20 9E 8F    		jsr	NEXTSPC		; and point to next char in table
 5459   5A53   E8          		inx			; point to next char
 5460   5A54   D0 E5       		bne	ENDLOOP		; so get next one
 5461   5A56               	INP111:
 5462   5A56   A9 00       		lda	#00		; to show end of line
 5463   5A58   20 35 92    		jsr	STASHB		; so put it in buffer
 5464                      	;
 5465                      	; now put in new line length
 5466                      	;
 5467   5A5B   AD 7B 6C    		lda	RDTBL1+HI	; get page of table
 5468   5A5E   20 77 8F    		jsr	SETPC		; and get me the memory page and bank
 5469   5A61   85 90       		sta	SPCH		; save page
 5470   5A63   84 91       		sty	SPCBNK		; and bank
 5471   5A65   AD 7A 6C    		lda	RDTBL1+LO	; and get offset
 5472   5A68   85 8F       		sta	SPCL
 5473   5A6A   20 9E 8F    		jsr	NEXTSPC		; and point to char count
 5474   5A6D   AD 5D 5B    		lda	CHARCNT		; get character count
 5475   5A70   20 35 92    		jsr	STASHB		; and shove it away  
 5476   5A73               	LEXBAD:
 5477   5A73   A0 00       	        ldy     #0              ; clear out
 5478   5A75   8C A4 6C    	        sty     PTR_COUNT       ; pointer flag
 5479   5A78   60          		rts			; Length is in [A]
 5480                      	;
 5481                      	; Copy over a new TCHARS table
 5482                      	;
 5483   5A79               	DO_TCHARS:
 5484                      	;
 5485                      	; now do somethin' with the TCHAR table (maybe, if <> 0)
 5486                      	;
 5487   5A79   AD 2E 96    		lda	ZBEGIN+ZTCHAR	; DO SAME FOR TCHARS TABLE
 5488   5A7C   8D 85 6C    		sta	SVTCHAR+HI	; save it for checking
 5489   5A7F   20 77 8F    		jsr	SETPC		; and now make absolute
 5490   5A82   85 8D       		sta	FPCH		; Save in FPC
 5491   5A84   84 8E       		sty	FPCBNK
 5492   5A86   AD 2F 96    		lda	ZBEGIN+ZTCHAR+1	; NO CHANGE FOR LSB
 5493   5A89   8D 84 6C    		sta	SVTCHAR+LO	; and save for later check
 5494   5A8C   85 8C       		sta	FPCL		; now move pointer to fetch spot
 5495                      	
 5496   5A8E   A9 00       		lda	#0		; and set index
 5497   5A90   85 78       		sta	I		; thank you
 5498   5A92   85 B9       		sta	ALLFLG		; turn it off
 5499   5A94               	TCHLP:
 5500   5A94   20 56 92    		jsr	FETCHB		; get the byte in [a]
 5501   5A97   20 BE 8F    		jsr	NEXTFPC		; point to next one
 5502   5A9A   A6 78       		ldx	I		; get offset
 5503   5A9C   E6 78       		inc	I		; and point to next one
 5504   5A9E   9D 00 1D    		sta	TCHARTBL,X	; save in lower memory, thank you
 5505   5AA1   C9 00       		cmp	#0		; are we done yet?
 5506   5AA3   F0 0A       		beq	TCHj		; NULL TERMINATED STRING
 5507   5AA5   C9 FF       		cmp	#$FF		; $ff means all >128 chars are terminators
 5508   5AA7   D0 04       		bne	TCHLNEXT	; nope
 5509   5AA9   A9 01       		lda	#1		; yes,
 5510   5AAB   85 B9       		sta	ALLFLG		; so set flag to say so
  Wed May 24 1989 15:00                                                                                                  Page   80

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5511   5AAD               	TCHLNEXT:
 5512   5AAD   D0 E5       		bne	TCHLP		; and go get it
 5513   5AAF               	TCHj:
 5514   5AAF   60          		rts
 5515                      	
 5516                      		; ------------------------
 5517                      		; IS IT A TERMINATOR CHAR?
 5518                      		; ------------------------
 5519                      	
 5520   5AB0               	ISTCHR:
 5521   5AB0   AE 00 1D    		ldx	TCHARTBL	; check for chars in TCHAR table
 5522   5AB3   F0 18       		beq	ISNOT		; nope
 5523                      	
 5524   5AB5   A6 B9       		ldx	ALLFLG		; ARE ALL FCN KEYS (<127) TERMINATORS
 5525   5AB7   F0 05       		beq	ISCHK		; 0 = NO, GO CHECK LIST
 5526   5AB9   AA          	        tax                     ; check for minus
 5527   5ABA   30 13       		bmi	ISFND		; YUP
 5528   5ABC   10 0F       		bpl	ISNOT
 5529   5ABE               	ISCHK:
 5530   5ABE   A0 00       		ldy	#0
 5531   5AC0               	ISLP:
 5532   5AC0   D9 00 1D    	        cmp	TCHARTBL,Y	; IS CHAR WE HAVE A TCHAR?
 5533   5AC3   F0 0A       		beq	ISFND		; YES
 5534   5AC5   BE 00 1D    		ldx	TCHARTBL,Y	; NULL = END OF STRING
 5535   5AC8   F0 03       		beq	ISNOT
 5536   5ACA   C8          		iny
 5537   5ACB   D0 F3       		bne	ISLP		; SHOULD ALWAYS LOOP
 5538   5ACD               	ISNOT:
 5539   5ACD   38          		sec
 5540   5ACE   60          		rts			; NOT FOUND
 5541   5ACF               	ISFND:	
 5542   5ACF   18          		clc
 5543   5AD0   60          		rts
 5544                      	
 5545                      		; -----
 5546                      		; INPUT 1 char, no printing
 5547                      		; -----
 5548                      	
 5549   5AD1               	ZINPUT:
 5550   5AD1   20 AD 55    		JSR	CLRBUF
 5551                      	
 5552   5AD4   A0 00       		ldy	#0	
 5553   5AD6   84 AB       		sty	LINCNT	
 5554   5AD8   84 A9       		sty	CHRCNT	
 5555   5ADA   84 79       		sty	I+HI		; init locals too
 5556   5ADC   84 78       		sty	I+LO
 5557   5ADE   84 7B       		sty	J+HI
 5558   5AE0   84 7A       		sty	J+LO
 5559   5AE2   8C A4 6C    	        sty     PTR_COUNT       ; always check the pointer
 5560   5AE5               	 
 5561   5AE5   C6 62       		DEC	NARGS	
 5562   5AE7   F0 18       		BEQ	ZINP3		; NO TIME LIMIT
 5563   5AE9   A5 65       		LDA	ARG2+LO		; GET DELAY WANTED
 5564   5AEB   85 79       		STA	I+HI	
 5565   5AED   C6 62       		DEC	NARGS	
 5566   5AEF   F0 08       		BEQ	ZINP4		; NO FCN
 5567   5AF1   A5 67       		LDA	ARG3+LO	
 5568   5AF3   85 7A       		STA	J+LO	
 5569   5AF5   A5 68       		LDA	ARG3+HI	
 5570   5AF7   85 7B       		STA	J+HI	
 5571   5AF9               	ZINP4:
 5572   5AF9   20 C9 4F    		JSR	TIMIN		; CALL timed input rotine
 5573   5AFC   90 10       		BCC	ZINPRK		; send char on home
 5574   5AFE   4C DA 43    		JMP	RET0		; time out without character
 5575   5B01               	ZINP3:
 5576   5B01   20 31 51    		jsr	GETKEY		; ok, find which char was pressed
 5577   5B04   C9 1B       	        cmp     #ESCAPE         ; don't use escape char
 5578   5B06   D0 06       	        bne     ZINPRK          ; fine
 5579   5B08   20 C3 4E    	        jsr     BEEP            ; complain
 5580   5B0B   4C 01 5B    	        jmp     ZINP3           ; do again
 5581   5B0E               	ZINPRK:
 5582   5B0E   A2 00       		LDX	#0
 5583   5B10   4C DD 43    		JMP	PUTBYT		; RETURN CHAR
 5584                      	
 5585                      	
  Wed May 24 1989 15:00                                                                                                  Page   81

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5586   5B13               	INTCLL:
 5587   5B13   A5 79       		LDA	I+HI		; SAVE VALUES FOR CALLING RTN
 5588   5B15   48          		PHA		
 5589   5B16   A5 78       		LDA	I+LO
 5590   5B18   48          		PHA
 5591   5B19   A5 7B       		LDA	J+HI	
 5592   5B1B   85 64       		STA	ARG1+HI		; pretend it's arg1
 5593   5B1D   48          		PHA		
 5594   5B1E   A5 7A       		LDA	J+LO	
 5595   5B20   85 63       		STA	ARG1+LO		; and this is the other half
 5596   5B22   48          		PHA		
 5597                      	
 5598   5B23   A2 01       		LDX	#1
 5599   5B25   86 62       		STX	NARGS		; 0 args for internal call
 5600   5B27   CA          		DEX
 5601   5B28   8E 5F 5B    		STX	IRET		; make sure it returns here!
 5602   5B2B               		
 5603   5B2B   A5 80       		LDA	ZPCL		; a fake one to say we
 5604   5B2D   48          		PHA			; are an internal call
 5605   5B2E   A5 81       		LDA	ZPCM		; so save real one
 5606   5B30   48          		PHA
 5607   5B31   A5 82       		LDA	ZPCH	
 5608   5B33   48          		PHA
 5609                      	
 5610   5B34   A9 00       		LDA	#0		; return addr of zero is 
 5611   5B36   85 82       		STA	ZPCH		; internal call!
 5612   5B38   85 81       		STA	ZPCM
 5613   5B3A   85 80       		STA	ZPCL
 5614                      	
 5615   5B3C   20 C8 7F    		JSR	DOCALL
 5616                      	
 5617   5B3F   4C B6 40    		JMP	MLOOP		; GO DO FCN
 5618                      	;
 5619                      	; RETURN FROM FCN WILL COME HERE
 5620                      	;
 5621   5B42               	ZIRET:
 5622   5B42   68          	 	PLA			; GET RID OF RTS FROM ZRET
 5623   5B43   68          		PLA		
 5624                      	
 5625   5B44   68          		PLA			; get old zpc back
 5626   5B45   85 82       		STA	ZPCH
 5627   5B47   68          		PLA
 5628   5B48   85 81       		STA	ZPCM
 5629   5B4A   68          		PLA
 5630   5B4B   85 80       		STA	ZPCL
 5631   5B4D   20 AA 90    		JSR	VLDZPC		; and validate it
 5632                      	
 5633   5B50   68          		PLA			; RESTORE FOR CALLING RTN
 5634   5B51   85 7A       		STA	J+LO	
 5635   5B53   68          		PLA		
 5636   5B54   85 7B       		STA	J+HI	
 5637   5B56   68          		PLA
 5638   5B57   85 78       		STA	I+LO
 5639   5B59   68          		PLA		
 5640   5B5A   85 79       		STA	I+HI	
 5641   5B5C   60          		RTS			; GO BACK TO CALLER
 5642                      	
 5643                      	; INPUT: routine locals!
 5644   5B5D   00          	CHARCNT:	DB	0	; where into buffer goes char
 5645   5B5E   00          	SVCHAR:		DB	0	; where to save the char before printing
 5646                      	
 5647   5B5F   00          	IRET:	DB	0		; FLAG TELLS IF RETURNLESS CALL
 5648                      	
 5649   5B60   00 00       	MTEMP:	DB	00,00		; temp spot for math routines
 5650   5B62   00          	TYPE:	DB	0		; PARTIAL OR NORMAL (WHOLE) SAVE/RESTORE
 5651   5B63   00          	ASSVLU:	DB	0		; how many args to this subroutine
 5652   5B64   00          	BRKCHR:	DB	0		; READ BREAK CHAR
 5653   5B65   00          	RDFLAG:	DB	0		; 0 - only read 1 - do lex on it
 5654   5B66   5B 4D 4F 52 45 	MORE:	DB	"[MORE]"	
        5B6B   5D 
 5655          0006        	MOREL	EQU	$-MORE
 5656   5B6C               		END
 5657                      	
 5658   5B6C               		INCLUDE		VERIFY.ASM
 5659   5B6C               		STTL "--- VERIFY CODE ---"
  Wed May 24 1989 15:00                                                                                                  Page   82

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5660                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page   83

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5661                      	
 5662                      		; ------
 5663                      		; VERIFY
 5664                      		; ------
 5665                      		; VERIFY GAME CODE ON DISK
 5666   5B6C   0D 54 68 65 20 	VERBAD:	DB	EOL,"The data segment of file is BAD!",EOL
        5B71   64 61 74 61 20 
        5B76   73 65 67 6D 65 
        5B7B   6E 74 20 6F 66 
        5B80   20 66 69 6C 65 
        5B85   20 69 73 20 42 
        5B8A   41 44 21 0D 
 5667          0022        	VERBADL	EQU	$-VERBAD
 5668   5B8E   0D 54 68 65 20 	VERPBAD: DB	EOL,"The picture data of file is BAD!",EOL
        5B93   70 69 63 74 75 
        5B98   72 65 20 64 61 
        5B9D   74 61 20 6F 66 
        5BA2   20 66 69 6C 65 
        5BA7   20 69 73 20 42 
        5BAC   41 44 21 0D 
 5669          0022        	VERPBADL EQU	$-VERPBAD
 5670   5BB0   00          	ZVFLAG:	db	0		; set to indicate ugliness
 5671          0078        	STARTPOS EQU	I+LO		; this is where to start block
 5672   5BB1               	ZVER:
 5673   5BB1   20 8F 8C    		jsr	CLOSE_GAME	; make sure the game files are closed
 5674   5BB4   AC 89 46    		ldy	GAME2NML	; get length of name
 5675   5BB7   B9 89 46    		lda	GAME2NM,Y	; get last char
 5676   5BBA   49 30       		eor	#$30		; make normal number
 5677   5BBC   A8          		tay			; -1 to make ready for FETCH_FILE
 5678   5BBD   88          		dey			; F_F incs first
 5679   5BBE   98          		tya			; to push onto stack
 5680   5BBF   48          		pha			; and save for restoring later
 5681   5BC0   A9 00       		lda	#0		; clear a few counters
 5682   5BC2   8D B0 5B    		sta 	ZVFLAG		; ==0 - verify worked; !=0 - verify broke
 5683   5BC5   AD 01 19    		lda	SEGTBL+SGTDISKS+1	; get how many disks are here
 5684   5BC8   8D 57 49    		sta 	DISKCNTR	; this shows which disk we are working on
 5685   5BCB   CE 57 49    		dec	DISKCNTR	; start down by one
 5686   5BCE               	VERIFY_LOOP:
 5687   5BCE   20 06 5C    		jsr	VERIFY_DATA	; check data in this file
 5688   5BD1   20 91 5C    		jsr	VERIFY_PICD	; check (possible) picture data in this file
 5689   5BD4   AD CF 45    		lda	GMREF		; get reference number
 5690   5BD7   8D 07 8B    		sta	CLOSE_PB+CL_REFNUM ; and show CLOSE
 5691   5BDA               		CLOSE	CLOSE_PB	; and shut it up
 5692   5BDA               		PRODOS	$CC, CLOSE_PB
 5693   5BDA   20 00 BF    		jsr	$BF00	; ProDOS handler
 5694   5BDD   CC          		DB	$CC	; ProDOS function code
 5695   5BDE   068B        		DW	CLOSE_PB	; Function Parameter Block address
 5696   5BE0               		.MACEND
 5697   5BE0               		.MACEND
 5698   5BE0   CE 57 49    		dec	DISKCNTR	; next please
 5699   5BE3   10 E9       		bpl	VERIFY_LOOP	; and check the next file
 5700   5BE5               	ZVERX:
 5701   5BE5   A9 02       		lda	#>PAGELEN	; reset read buffer length
 5702   5BE7   8D D3 45    		sta	READ_PB+RD_BUFFLEN+HI	; to be $100
 5703   5BEA   A9 00       		lda	#<PAGELEN	; this is for LSB
 5704   5BEC   8D D2 45    		sta	READ_PB+RD_BUFFLEN+LO	; to be $100
 5705   5BEF   20 8F 8C    		jsr	CLOSE_GAME	; close up the 2 files, thank you
 5706   5BF2   A9 01       		lda	#1		; open game file #1 (*.D2)
 5707   5BF4   20 C6 49    		jsr	FETCH_FILE	; this opens it up
 5708   5BF7   68          		pla			; get file number back (*.D3/4/5)
 5709   5BF8   20 C6 49    		jsr	FETCH_FILE	; and open it back up
 5710   5BFB   AD B0 5B    		lda	ZVFLAG		; see if we were successful
 5711   5BFE   F0 03       		beq	ZVERGOOD	; it worked fine
 5712   5C00   4C 2F 44    		jmp	PREDF		; no it didn't
 5713   5C03               	ZVERGOOD:
 5714   5C03   4C 3B 44    		jmp	PREDS		; all done
 5715                      	;
 5716                      	; VERIFY_DATA - check the data part of the picture.  This routine sets
 5717                      	; up DSEGS and open the file.  It will move to the data section if this
 5718                      	; is the preload file, set up J to be the number of 256 byte blocks, and
 5719                      	; print out the verdict.  The disk we are working on (0-3) is in DISKCNTR.
 5720                      	;
 5721   5C06               	VERIFY_DATA:
 5722   5C06   AD 57 49    		lda	DISKCNTR	; get disk we are interested in
 5723   5C09   0A          		asl	A		; make word pointer
  Wed May 24 1989 15:00                                                                                                  Page   84

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5724   5C0A   AA          		tax			; create index
 5725   5C0B   BD D1 1D    		lda	DSKSEG+HI,X	; get MSB of seg table address
 5726   5C0E   85 1F       		sta	DSEGS+HI	; save in pointer
 5727   5C10   BD D0 1D    		lda	DSKSEG+LO,X	; get LSB of seg table address
 5728   5C13   85 1E       		sta	DSEGS+LO	; now pointer is all set
 5729   5C15   AD 57 49    		lda	DISKCNTR	; get disk again
 5730   5C18   20 C6 49    		jsr	FETCH_FILE	; so we can open up correct file
 5731   5C1B   A9 00       		lda	#0		; make sure we start at beginning
 5732   5C1D   8D DE 45    		sta	PSEEK+SM_FPOS
 5733   5C20   8D DF 45    		sta	PSEEK+SM_FPOS+1
 5734   5C23   8D E0 45    		sta	PSEEK+SM_FPOS+2
 5735   5C26   85 78       		sta	STARTPOS	; start at first byte, prob'ly
 5736   5C28               		SET_MARK PSEEK		; and move to beginning of file
 5737   5C28               		PRODOS	$CE, PSEEK
 5738   5C28   20 00 BF    		jsr	$BF00	; ProDOS handler
 5739   5C2B   CE          		DB	$CE	; ProDOS function code
 5740   5C2C   DC45        		DW	PSEEK	; Function Parameter Block address
 5741   5C2E               		.MACEND
 5742   5C2E               		.MACEND
 5743   5C2E   AD 57 49    		lda	DISKCNTR	; now check if this is preload
 5744   5C31   D0 03       		bne	VERD1		; if <> 0, then it isn't
 5745   5C33   20 4C 5D    		jsr	SETUP_DISK0	; move around to point to start of data
 5746   5C36               	VERD1:
 5747   5C36   A0 02       		ldy	#SGTPICOF	; find where picture data starts
 5748   5C38   B1 1E       		lda	(DSEGS),Y	; MSB
 5749   5C3A   85 7B       		sta	J+HI		; J is the page counter
 5750   5C3C   C8          		iny			; point to LSB
 5751   5C3D   11 1E       		ora	(DSEGS),Y	; any picture file?
 5752   5C3F   D0 08       		bne	VERD01		; yes, so mark end of data
 5753   5C41   A9 FF       		lda	#$FF		; set J to be a real big number
 5754   5C43   85 7A       		sta	J+LO		; okay
 5755   5C45   85 7B       		sta	J+HI		; and this one
 5756   5C47   D0 15       		bne	VERD11		; all done
 5757   5C49               	VERD01:
 5758   5C49   B1 1E       		lda	(DSEGS),Y	; and here it is
 5759   5C4B   0A          		asl	A		; *2 to make 512 pages be 256 pages
 5760   5C4C   85 7A       		sta	J+LO		; this is where it ends up
 5761   5C4E   26 7B       		rol	J+HI		; move in carry to MSB
 5762   5C50   A5 7A       		lda	J+LO		; now, subtract any skipping
 5763   5C52   38          		sec			; doing sub
 5764   5C53   ED DF 45    		sbc	PSEEK+SM_FPOS+1	; take away any skipped amount
 5765   5C56   85 7A       		sta	J+LO		; and save it
 5766   5C58   A5 7B       		lda	J+HI		; pick up carry
 5767   5C5A   E9 00       		sbc	#0		; we will
 5768   5C5C   85 7B       		sta	J+HI		; we did
 5769   5C5E               	VERD11:
 5770   5C5E   20 E1 5C    		jsr	VERIFY_FILE	; now, actually do the work
 5771   5C61   90 2D       		bcc	VERDX		; worked just fine
 5772   5C63               		DLINE	VERBAD		; puke, gag, argh
 5773   5C63   A2 6C       		ldx	#<VERBAD	; get part of VERBAD
 5774   5C65   A9 5B       		lda	#>VERBAD	; get other part of string
 5775          [01]        		IFMA	2		; check to see if length passed in
 5776                      		ldy			; then just fetch it
 5777          [01]        		ELSE
 5778   5C67   A0 22       		ldy	#VERBADL	; get length of string
 5779          [00]        		ENDIF
 5780   5C69   20 6B 4C    		jsr	DLINE		; print the string
 5781   5C6C               		.MACEND
 5782                      	;
 5783                      	; This prints out which file is garfed
 5784                      	;
 5785   5C6C               	VER_FMSG:
 5786   5C6C   AD 57 49    		lda	DISKCNTR	; which file did we do?
 5787   5C6F   C9 02       		cmp	#2		; 0,1 are in one place
 5788   5C71   B0 0D       		bcs	VERDB1		; nope it isn't it
 5789   5C73               		DLINE	GAME1NAME,GAME1NML
 5790   5C73   A2 78       		ldx	#<GAME1NAME	; get part of GAME1NAME
 5791   5C75   A9 46       		lda	#>GAME1NAME	; get other part of string
 5792          [01]        		IFMA	2		; check to see if length passed in
 5793   5C77   AC 77 46    		ldy	GAME1NML		; then just fetch it
 5794          [01]        		ELSE
 5795                      		ldy	#GAME1NAMEL	; get length of string
 5796          [00]        		ENDIF
 5797   5C7A   20 6B 4C    		jsr	DLINE		; print the string
 5798   5C7D               		.MACEND
  Wed May 24 1989 15:00                                                                                                  Page   85

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5799   5C7D   4C 8A 5C    		jmp 	VERDB2		
 5800   5C80               	VERDB1:
 5801   5C80               		DLINE	GAME2NAME,GAME2NML ; 2,3 are in another
 5802   5C80   A2 8A       		ldx	#<GAME2NAME	; get part of GAME2NAME
 5803   5C82   A9 46       		lda	#>GAME2NAME	; get other part of string
 5804          [01]        		IFMA	2		; check to see if length passed in
 5805   5C84   AC 89 46    		ldy	GAME2NML		; then just fetch it
 5806          [01]        		ELSE
 5807                      		ldy	#GAME2NAMEL	; get length of string
 5808          [00]        		ENDIF
 5809   5C87   20 6B 4C    		jsr	DLINE		; print the string
 5810   5C8A               		.MACEND
 5811   5C8A               	VERDB2:
 5812   5C8A   EE B0 5B    		inc	ZVFLAG		; show bad file
 5813   5C8D   20 DB 8C    		jsr	GETRET		; just wait for <CR>
 5814   5C90               	VERDX:
 5815   5C90   60          		rts			; all done
 5816                      	;
 5817                      	; VERIFY_PICD - verify the picture data in a file.  First check to see if
 5818                      	; there is any.  If so, seek to it, set J==0 to show VERIFY_FILE to read
 5819                      	; til EOF, and print out bad picture data message if necessary.
 5820                      	;
 5821   5C91               	VERIFY_PICD:
 5822   5C91   A9 FF       		lda	#$FF		; gonna zero bunch of stuff
 5823   5C93   85 7B       		sta	J+HI		; and the counter
 5824   5C95   85 7A       		sta	J+LO		; which means now goto EOF
 5825   5C97   A0 02       		ldy	#SGTPICOF	; fetch the picture data offset
 5826   5C99   B1 1E       		lda	(DSEGS),Y	; get MSB
 5827   5C9B   8D E0 45    		sta	PSEEK+SM_FPOS+2	; we are doing pages
 5828   5C9E   C8          		iny			; pointing to LSB
 5829   5C9F   11 1E       		ora	(DSEGS),Y	; first, check for all zeros
 5830   5CA1   D0 01       		bne	VERP1		; nope, some picture data is there
 5831   5CA3   60          		rts			; just gwon back if nothing here
 5832   5CA4               	VERP1:
 5833   5CA4   B1 1E       		lda	(DSEGS),Y	; go get LSB
 5834   5CA6   0A          		asl	A		; *2 to get 256 byte pages
 5835   5CA7   8D DF 45    		sta	PSEEK+SM_FPOS+1	; put away here
 5836   5CAA   2E E0 45    		rol	PSEEK+SM_FPOS+2	; pick up carry
 5837   5CAD   A9 10       		lda	#PHSIZE		; skip over header of file
 5838   5CAF   85 78       		sta	STARTPOS	; show offset in first block
 5839   5CB1               	VERP11:
 5840   5CB1               		SET_MARK PSEEK		; and move to picture data spot
 5841   5CB1               		PRODOS	$CE, PSEEK
 5842   5CB1   20 00 BF    		jsr	$BF00	; ProDOS handler
 5843   5CB4   CE          		DB	$CE	; ProDOS function code
 5844   5CB5   DC45        		DW	PSEEK	; Function Parameter Block address
 5845   5CB7               		.MACEND
 5846   5CB7               		.MACEND
 5847   5CB7   20 E1 5C    		jsr	VERIFY_FILE	; read in the data
 5848   5CBA               		SET_MARK PSEEK		; get back to beginning of pic data
 5849   5CBA               		PRODOS	$CE, PSEEK
 5850   5CBA   20 00 BF    		jsr	$BF00	; ProDOS handler
 5851   5CBD   CE          		DB	$CE	; ProDOS function code
 5852   5CBE   DC45        		DW	PSEEK	; Function Parameter Block address
 5853   5CC0               		.MACEND
 5854   5CC0               		.MACEND
 5855   5CC0               		READ	READ_PB		; read in a block worth
 5856   5CC0               		PRODOS	$CA, READ_PB
 5857   5CC0   20 00 BF    		jsr	$BF00	; ProDOS handler
 5858   5CC3   CA          		DB	$CA	; ProDOS function code
 5859   5CC4   CE45        		DW	READ_PB	; Function Parameter Block address
 5860   5CC6               		.MACEND
 5861   5CC6               		.MACEND
 5862   5CC6   AD 0A 08    		lda	IOBUFF+PHCHKS	; get MSB of picture checksum
 5863   5CC9   C5 7F       		cmp	L+HI		; same as what we got?
 5864   5CCB   D0 07       		bne 	VERPB		; nope
 5865   5CCD   AD 0B 08    		lda 	IOBUFF+PHCHKS+1	; get LSB of picture checksum
 5866   5CD0   C5 7E       		cmp	L+LO		; same as mine?
 5867   5CD2   F0 0C       		beq	VERPX		; yup, checked out fine
 5868   5CD4               	VERPB:
 5869   5CD4               		DLINE	VERPBAD		; picture data bad
 5870   5CD4   A2 8E       		ldx	#<VERPBAD	; get part of VERPBAD
 5871   5CD6   A9 5B       		lda	#>VERPBAD	; get other part of string
 5872          [01]        		IFMA	2		; check to see if length passed in
 5873                      		ldy			; then just fetch it
  Wed May 24 1989 15:00                                                                                                  Page   86

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5874          [01]        		ELSE
 5875   5CD8   A0 22       		ldy	#VERPBADL	; get length of string
 5876          [00]        		ENDIF
 5877   5CDA   20 6B 4C    		jsr	DLINE		; print the string
 5878   5CDD               		.MACEND
 5879   5CDD   4C 6C 5C    		jmp	VER_FMSG	; print out file name
 5880   5CE0               	VERPX:
 5881   5CE0   60          		rts			; tootis finis
 5882                      	;
 5883                      	; VERIFY_FILE - Files is already open and pointing to start of checksummed
 5884                      	; data.  Works along til J == 0 or EOF, which ever comes first.  Starts by
 5885                      	; dec'ing J, so if J starts as 0, effectively means goto EOF.
 5886                      	;
 5887   5CE1               	VERIFY_FILE:
 5888   5CE1   A9 00       		lda	#0		; clear out checksum counter
 5889   5CE3   85 7F       		sta	L+HI		; MSB
 5890   5CE5   85 7E       		sta	L+LO		; LSB
 5891   5CE7   8D D2 45    		sta	READ_PB+RD_BUFFLEN+LO
 5892   5CEA   A9 04       		lda	#4		; make read read $400 (1Kb)
 5893   5CEC   8D D3 45    		sta	READ_PB+RD_BUFFLEN+HI
 5894   5CEF               	VFLOOP:	
 5895   5CEF   A9 03       	        lda     #RETRY_COUNT    ; and set up retry count
 5896   5CF1   85 16       	        sta     RETRIES
 5897   5CF3   A9 00       		lda	#<IOBUFF	; reset K to point to beginning of
 5898   5CF5   85 7C       		sta	K+LO		; IOBUFF we are
 5899   5CF7   A9 08       		lda	#>IOBUFF	; reading all the data
 5900   5CF9   85 7D       		sta	K+HI		; into, using as pointer
 5901   5CFB               	VFLRD:
 5902   5CFB               		READ	READ_PB		; read in 1Kb of data
 5903   5CFB               		PRODOS	$CA, READ_PB
 5904   5CFB   20 00 BF    		jsr	$BF00	; ProDOS handler
 5905   5CFE   CA          		DB	$CA	; ProDOS function code
 5906   5CFF   CE45        		DW	READ_PB	; Function Parameter Block address
 5907   5D01               		.MACEND
 5908   5D01               		.MACEND
 5909   5D01   90 0D       		bcc	VERF0		; just fine read
 5910   5D03   C9 4C       		cmp	#$4C		; EOF error?
 5911   5D05   F0 32       		beq	VFCHECK		; yes, so wee bee done
 5912   5D07   C9 4D       	        cmp     #$4D            ; InfoDOS EOF error?
 5913   5D09   F0 2E       	        beq     VFCHECK         ; ayyup
 5914   5D0B   20 07 47    	        jsr     RETRY           ; check about retrying
 5915   5D0E   90 EB       	        bcc     VFLRD           ; and do again
 5916   5D10               	VERF0:
 5917   5D10   A5 7A       	        lda     J+LO            ; count the block to be read
 5918   5D12   D0 06       	        bne     VERF1           ; no wrapping
 5919   5D14   A5 7B       	        lda     J+HI            ; anything left?
 5920   5D16   F0 21       	        beq     VFCHECK         ; nope, all done then
 5921   5D18   C6 7B       	        dec     J+HI            ; count one block
 5922   5D1A               	VERF1:
 5923   5D1A   C6 7A       		dec	J+LO		; count block
 5924   5D1C   A4 78       		ldy	STARTPOS	; and begin
 5925   5D1E               	VERF2:
 5926   5D1E   B1 7C       		lda	(K),Y		; get byte
 5927   5D20   18          		clc			; doing add
 5928   5D21   65 7E       		adc	L+LO		; add it in
 5929   5D23   85 7E       		sta	L+LO		; save it
 5930   5D25   90 02       		bcc	VERF3		; no wrap
 5931   5D27   E6 7F       		inc	L+HI		; yes ther is
 5932   5D29               	VERF3:
 5933   5D29   C8          		iny			; next byte
 5934   5D2A   D0 F2       		bne	VERF2		; back to start of inner tloop
 5935                      	
 5936   5D2C   A9 00       		lda	#0		; start at first byte
 5937   5D2E   85 78       		sta	STARTPOS	; okay
 5938   5D30   E6 7D       		inc	K+HI		; point to next block
 5939   5D32   CE D5 45    		dec	READ_PB+RD_LENGTH+HI	; count this one
 5940   5D35   F0 B8       		beq	VFLOOP		; go read some more
 5941   5D37   D0 D7       		bne	VERF0		; go do next 256 byte block
 5942   5D39               	VFCHECK:
 5943   5D39   A0 00       		ldy	#SGTCHKS	; get check sum
 5944   5D3B   A5 7F       		lda	L+HI		; start with MSB
 5945   5D3D   D1 1E       		cmp	(DSEGS),Y	; well . . . ?
 5946   5D3F   D0 09       		bne	VFBAD		; nope, it is wrong
 5947   5D41   C8          		iny			; first byte is okay
 5948   5D42   A5 7E       		lda	L+LO		; so check LSB
  Wed May 24 1989 15:00                                                                                                  Page   87

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5949   5D44   D1 1E       		cmp	(DSEGS),Y	; well . . . ?
 5950   5D46   D0 02       		bne	VFBAD		; die a slow ugly death
 5951   5D48   18          		clc			; clear carry to show niceness
 5952   5D49   60          		rts
 5953   5D4A               	VFBAD:
 5954   5D4A   38          		sec			; carry is set if bad
 5955   5D4B   60          		rts			; and return to your fate
 5956                      	;
 5957                      	; SETUP_DISK0 - this routine does some special processing to get the file
 5958                      	; pointer to the beginning of data for the preload file.  It skips over
 5959                      	; segment table.
 5960   5D4C               	SETUP_DISK0:
 5961   5D4C               		READ	READ_PB		; read in first block
 5962   5D4C               		PRODOS	$CA, READ_PB
 5963   5D4C   20 00 BF    		jsr	$BF00	; ProDOS handler
 5964   5D4F   CA          		DB	$CA	; ProDOS function code
 5965   5D50   CE45        		DW	READ_PB	; Function Parameter Block address
 5966   5D52               		.MACEND
 5967   5D52               		.MACEND
 5968   5D52   AD 00 08    		lda	IOBUFF		; MSB of segment table size (in words)
 5969   5D55   8D DF 45    		sta	PSEEK+SM_FPOS+1	; middle part of offset
 5970   5D58   AD 01 08    		lda	IOBUFF+1	; LSB of size
 5971   5D5B   0A          		asl	A		; *2 to pick up carry
 5972   5D5C   2E DF 45    		rol	PSEEK+SM_FPOS+1	; rotate in carry
 5973   5D5F   2E E0 45    		rol	PSEEK+SM_FPOS+2	; and once more
 5974   5D62   A8          	        tay                     ; check for wrapping upwards 
 5975   5D63   F0 08       	        beq     STD01           ; no wrap up then
 5976   5D65               	STD00:
 5977   5D65   EE DF 45    	        inc     PSEEK+SM_FPOS+1 ; wee did
 5978   5D68   D0 03       	        bne     STD01           ; no more wrapping
 5979   5D6A   EE E0 45    	        inc     PSEEK+SM_FPOS+2 ; yes there is
 5980   5D6D               	STD01:        
 5981   5D6D   AD DF 45    	        lda     PSEEK+SM_FPOS+1 ; make sure it is a 512 byte page
 5982   5D70   29 01       	        and     #$1             ; even page?
 5983   5D72   D0 F1       	        bne     STD00           ; inc again, please
 5984   5D74               	STD0X:
 5985   5D74               		SET_MARK PSEEK		; skip the segment table stuff
 5986   5D74               		PRODOS	$CE, PSEEK
 5987   5D74   20 00 BF    		jsr	$BF00	; ProDOS handler
 5988   5D77   CE          		DB	$CE	; ProDOS function code
 5989   5D78   DC45        		DW	PSEEK	; Function Parameter Block address
 5990   5D7A               		.MACEND
 5991   5D7A               		.MACEND
 5992   5D7A   60          		rts			; all done
 5993                      	
 5994   5D7B               		END
 5995                      	
 5996   5D7B               		INCLUDE		SCREEN.ASM
 5997   5D7B               		STTL	"--- APPLE ][ SCREEN STUFF ---"
 5998                      		PAGE
  Wed May 24 1989 15:00                                                                                                  Page   88

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 5999                      	
 6000                      	; -----------------
 6001                      	; PRINT CHAR IN [A] AT CV,CH
 6002                      	; -----------------
 6003                      	;
 6004                      	; uses memory register [L]
 6005                      	;
 6006   5D7B   00          	SAVECY	DB	0	; spot to save current screen y pos
 6007   5D7C   00          	SAVECX	DB	0	; spot for x pos
 6008                      	
 6009   5D7D               	CHAR:
 6010   5D7D   85 AC       		sta	IOCHAR	; SAVE HERE
 6011   5D7F   8A          		txa		; SAVE [X] AND [Y]
 6012   5D80   48          		pha		
 6013   5D81   98          		tya		
 6014   5D82   48          		pha
 6015   5D83               		
 6016   5D83   A5 AC       		lda	IOCHAR		; get it back
 6017   5D85   C9 08       		cmp	#BACKSPACE	; is it backspace with erase?
 6018   5D87   D0 03       		bne	CHCX		; nope
 6019                      	
 6020   5D89   4C AB 5E    		jmp	DO_BSPC		; so handle backspace
 6021   5D8C               	CHCX:
 6022   5D8C   C9 0D       		cmp	#EOL		; is it <CR>?
 6023   5D8E   D0 03       		bne	CHCONT		; just let dline handle it
 6024   5D90               		
 6025   5D90   4C 78 5E    		jmp	DO_EOL		; handle <CR>
 6026                      	;
 6027                      	; so save some stuff and do all the necessary figgering
 6028                      	;
 6029   5D93               	CHCONT:
 6030   5D93   AE DF 71    		ldx	SCRCNT		; just stash character
 6031   5D96   9D 80 02    		sta	SCRBUFF,X	; save it
 6032   5D99   EE DF 71    		inc	SCRCNT		; and count it
 6033   5D9C               	CH_EXIT:
 6034   5D9C   68          		pla			; RESTORE [X] AND [Y]
 6035   5D9D   A8          		tay		
 6036   5D9E   68          		pla		
 6037   5D9F   AA          		tax		
 6038   5DA0   60          		rts
 6039                      	;
 6040                      	; PUT_NYBBLE - put 4 bits to the screen at SCRCX, SCRCY (the lower 4 bits
 6041                      	;	in [A]).
 6042                      	;
 6043   5DA1               	PUT_NYBBLE:
 6044   5DA1   85 0E       		sta	NY_DATA		; save [A] for mucking with
 6045   5DA3   20 4C 5E    		jsr	SETPOS		; set up offsets using SCRCX
 6046                      	
 6047   5DA6   A9 08       		lda	#$8		; start at first bit, left to right
 6048   5DA8   85 10       		sta	DATALOOP	; and init the counter with it
 6049   5DAA               	PNY0:
 6050   5DAA   A6 8E       		ldx	FPCBNK		; which bank
 6051   5DAC   BD 54 C0    		lda	PAGE2SW,X	; select it
 6052   5DAF   A0 00       		ldy	#0		; start with zero
 6053   5DB1   B1 8C       		lda	(FPC),Y		; get it
 6054   5DB3   85 13       		sta	SCR_DATA	; and save it
 6055   5DB5               	PNY1:	
 6056   5DB5   A6 11       		ldx	BITOFF		; get which interesting bit we want
 6057   5DB7   BD 04 5E    		lda	GT_BITS,X	; get bit 
 6058   5DBA   48          		pha			; save bit pictures
 6059   5DBB   A5 10       		lda	DATALOOP 	; see if we have done all 4 bits in this 'pixel'
 6060   5DBD   F0 29       		beq	PNY_EXIT 	; toots finis
 6061   5DBF   46 10       		lsr	DATALOOP 	; point to next bit
 6062   5DC1   24 0E       		bit	NY_DATA		; is this bit set?
 6063   5DC3   D0 08       		bne	PNY_SET		; yes it is, so we will handle different
 6064                      	;
 6065                      	; Bit is clear, so clear appropriate one in the SCR_DATA byte
 6066                      	;
 6067   5DC5   68          		pla			; get bit picture back
 6068   5DC6   49 FF       		eor	#$FF		; turn bits all around
 6069   5DC8   25 13       		and 	SCR_DATA	; turn off bit in screen data
 6070   5DCA   4C D0 5D    		jmp	PNY_NEXT	; and continue
 6071   5DCD               	PNY_SET:
 6072   5DCD   68          		pla			; get bit mask back
 6073   5DCE   05 13       		ora	SCR_DATA	; turn on bit
  Wed May 24 1989 15:00                                                                                                  Page   89

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6074   5DD0               	PNY_NEXT:
 6075   5DD0   85 13       		sta	SCR_DATA	; save result
 6076   5DD2   E6 11       		inc	BITOFF		; we're looking at next bit
 6077   5DD4   A5 11       		lda	BITOFF		; now check how we're doing
 6078   5DD6   C9 07       		cmp	#7		; only doing bits 0-6
 6079   5DD8   D0 DB       		bne	PNY1		; check next bit
 6080                      	;
 6081                      	; we've finished this byte in screen memory, point to next one
 6082                      	;
 6083   5DDA   A9 00       		lda	#0		; start at zero'th bit
 6084   5DDC   85 11       		sta	BITOFF		; thank you
 6085   5DDE   A5 13       		lda	SCR_DATA	; now stash this one in the screen
 6086   5DE0   91 8C       		sta	(FPC),Y		; y is still zero; still pointing to bank
 6087   5DE2   20 F1 5D    		jsr	NEXT_SCR	; make SPC/FPC point to next spot
 6088   5DE5   4C AA 5D    		jmp	PNY0	; and continue on please
 6089                      	;
 6090                      	; all done, so make sure we stash anything out there
 6091                      	;
 6092   5DE8               	PNY_EXIT:
 6093   5DE8   68          		pla			; get bit mask back to fix stack
 6094   5DE9   A5 13       		lda	SCR_DATA	; put away the current data byte
 6095   5DEB   91 8C       		sta	(FPC),Y		; y is still zero; still pointing to bank
 6096   5DED   AD 54 C0    		lda	PAGE2SW+MAIN	; back to MAIN page 2
 6097   5DF0   60          		rts
 6098                      	;
 6099                      	; NEXT_SCR - make FPC/SPC point to next screen byte
 6100                      	;
 6101   5DF1               	NEXT_SCR:
 6102                      	;
 6103                      	; if in main bank, when we go to aux bank, we need to look at the next
 6104                      	; 	byte in memory
 6105                      	;
 6106   5DF1   A5 8E       		lda	FPCBNK		; get what bank we're talking to currently
 6107   5DF3   D0 08       		bne	NXS0		; 0 = main bank, 1 = aux bank
 6108   5DF5   E6 8F       		inc	SPCL	; point to next byte
 6109   5DF7   E6 8C       		inc	FPCL	; and for fetching
 6110   5DF9   A9 01       		lda	#AUX	; and point to aux bank
 6111   5DFB   D0 02       		bne	NXS1	; (BRANCH) and continue on
 6112                      	;
 6113                      	; if in aux bank, all we need to do is switch banks
 6114                      	;
 6115   5DFD               	NXS0:
 6116   5DFD   A9 00       		lda	#MAIN	; just make it main bank
 6117   5DFF               	NXS1:
 6118   5DFF   85 91       		sta	SPCBNK	; for stashing and
 6119   5E01   85 8E       		sta	FPCBNK	; fetching
 6120   5E03   60          		rts
 6121                      	;
 6122                      	; GET_NYBBLE - get the 4 bits which represent the screen at position
 6123                      	;	SCRCX, SCRCY; return nybble in low 4 bits of [A]
 6124                      	;
 6125   5E04   01 02 04 08 10 	GT_BITS: db 1,2,4,8,$10,$20,$40
        5E09   20 40 
 6126   5E0B               	GET_NYBBLE:
 6127   5E0B   20 4C 5E    		jsr	SETPOS	; set up offsets using SCRCX
 6128                      	
 6129   5E0E   A9 00       		lda	#0	; clear out my data spot
 6130   5E10   85 0E       		sta	NY_DATA	; for mucking with
 6131                      	
 6132   5E12   A9 10       		lda	#$10	; setting bits 0-3, starting with shift
 6133   5E14   85 10       		sta	DATALOOP ; so init the setter
 6134   5E16               	GNY0:
 6135   5E16   A6 8E       		ldx	FPCBNK		; which bank
 6136   5E18   BD 54 C0    		lda	PAGE2SW,X	; save which bank
 6137   5E1B   A0 00       		ldy	#0		; zero y
 6138   5E1D   B1 8C       		lda	(FPC),Y		; get byte
 6139   5E1F   85 13       		sta	SCR_DATA	; and save it
 6140   5E21               	GNY1:	
 6141   5E21   46 10       		lsr	DATALOOP ; see if we have done all 4 bits in this 'pixel'
 6142   5E23   F0 21       		beq	GNY_EXIT ; all done!
 6143                      	
 6144   5E25   A6 11       		ldx	BITOFF	; get bit offset
 6145   5E27   BD 04 5E    		lda	GT_BITS,X	; get bit pattern
 6146                      	;
 6147                      	; now check appropriate bit in Screen Data
  Wed May 24 1989 15:00                                                                                                  Page   90

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6148                      	;
 6149   5E2A   25 13       		and	SCR_DATA ; see if it is set
 6150   5E2C   F0 06       		beq	GNY3	; no bit set here
 6151                      	;
 6152                      	; bit is set, so set it in my data nybble
 6153                      	;
 6154   5E2E   A5 10       		lda	DATALOOP ; get bit setter
 6155   5E30   05 0E       		ora	NY_DATA	; and put it into my data byte
 6156   5E32   85 0E       		sta	NY_DATA	; and save it
 6157   5E34               	GNY3:
 6158   5E34   E6 11       		inc	BITOFF	; we're looking at next bit
 6159   5E36   A5 11       		lda	BITOFF	; now check how we're doing
 6160   5E38   C9 07       		cmp	#7	; only doing bits 0-6
 6161   5E3A   D0 E5       		bne	GNY1	; check next bit
 6162                      	;
 6163                      	; we've finished this byte in screen memory, point to next one
 6164                      	;
 6165   5E3C   A9 00       		lda	#0	; start at zero'th bit
 6166   5E3E   85 11       		sta	BITOFF	; thank you
 6167   5E40   20 F1 5D    		jsr	NEXT_SCR	; point to next byte
 6168   5E43   4C 16 5E    		jmp	GNY0	; and continue on please
 6169   5E46               	GNY_EXIT:
 6170   5E46   AD 54 C0    		lda	PAGE2SW+MAIN	; back to main page 2
 6171   5E49   A5 0E       		lda	NY_DATA	; get the nybble desired
 6172   5E4B   60          		rts
 6173                      	;
 6174                      	; SETPOS - get the byte offset and the bit offset from the table using
 6175                      	;		SCRCX
 6176                      	;
 6177                      	;	USES: SCRCX, SCRCY
 6178                      	;	SETS: FPC - pointer to correct screen memory location
 6179                      	;	      BITOFF - bit offset to get to start of byte (N.B. this is left to
 6180                      	;			right count, while in memory it is right to left!)
 6181   5E4C               	SETPOS:
 6182   5E4C   A5 00       		lda	SCRCX		; get the x pos
 6183   5E4E   AA          		tax			; put where we can use it
 6184   5E4F   BD 52 03    		lda	XPOSTBL,X	; get byte #
 6185   5E52   85 8C       		sta	FPCL		; okay, saved
 6186   5E54   BD B2 6B    		lda	XBITTBL,X	; get bitoffset
 6187   5E57   85 11       		sta	BITOFF		; where it wants it
 6188                      	
 6189   5E59   A5 8C       		lda	FPCL		; check for correct bank
 6190   5E5B   29 01       		and	#$01		; if odd, then must be main bank
 6191   5E5D   D0 04       		bne	STP11		; okay, it be odd
 6192   5E5F   A9 01       		lda	#AUX		; aux bank
 6193   5E61   D0 02       		bne	STP22		; jump
 6194   5E63               	STP11:
 6195   5E63   A9 00       		lda	#MAIN		; main bank
 6196   5E65               	STP22:
 6197   5E65   85 8E       		sta	FPCBNK		; save it
 6198   5E67   A5 8C       		lda	FPCL		; get for fetch
 6199   5E69   4A          		lsr	A		; /2 to get correct byte offset
 6200   5E6A   A6 01       		ldx	SCRCY		; get vertical pos
 6201   5E6C   18          		clc			; get ready for adding
 6202   5E6D   7D 32 6A    		adc	BASEL,X	 	; add low part
 6203   5E70   85 8C       		sta	FPCL		; save low part
 6204   5E72   BD F2 6A    		lda	BASEH,X		; get high part
 6205   5E75   85 8D       		sta	FPCH		; save high part
 6206   5E77   60          		rts			; done !?
 6207                      	;
 6208                      	; DO_EOL - if this is end of line, check if we are at end of window
 6209                      	; 	and if we are, and it is a scrollable window, scroll.  Then move
 6210                      	;	the cursor to the left margin of said window
 6211                      	;
 6212   5E78               	DO_EOL:
 6213   5E78   20 EC 71    		jsr	DISP_LINE	; make sure line gets out there
 6214   5E7B   A5 01       		lda	SCRCY		; get current vertical pos
 6215   5E7D   18          		clc			; add font height
 6216   5E7E   69 09       		adc	#FONT_H		; thank you
 6217   5E80   48          		pha			; save this position
 6218   5E81   69 09       		adc	#FONT_H		; make sure we have room for characters here
 6219   5E83   C5 02       		cmp	SCRBTM		; so check against the bottom
 6220   5E85   F0 02       		beq	SAVECV		; no scroll yet
 6221   5E87   B0 05       		bcs	SCROLLCITY	; nope, can't use it
 6222   5E89               	SAVECV:
  Wed May 24 1989 15:00                                                                                                  Page   91

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6223   5E89   68          		pla			; get new CV
 6224   5E8A   85 01       		sta	SCRCY		; and save it
 6225   5E8C   D0 09       		bne	DEL1		; JUMP
 6226   5E8E               	SCROLLCITY:
 6227   5E8E   68          		pla			; get bad y pos
 6228   5E8F   AD D7 71    		lda	SCRLFLG		; is this a scrolling window?
 6229   5E92   F0 03       		beq	DEL1		; nope, just move to left edge
 6230   5E94   20 E8 5F    		jsr	SCROLL_UP	; and scroll window
 6231   5E97               	DEL1:
 6232                      	;
 6233                      	; move cursor back to left margin
 6234                      	;
 6235   5E97   A5 04       		lda	LEFTMRG		; get left margin
 6236   5E99   85 00       		sta	SCRCX		; and set itpositions
 6237   5E9B   A9 01       		lda	#1		; show cursor changed (maybe)
 6238   5E9D   8D 77 6C    		sta	CURSFLG		; okay
 6239   5EA0   A9 00       		lda	#0		; clear length too
 6240   5EA2   85 A7       		sta	LENGTH+LO	; no more on line
 6241   5EA4   85 A8       		sta	LENGTH+HI	; no more on line
 6242   5EA6   4C 9C 5D    		jmp	CH_EXIT		; now finish it up
 6243                      	;
 6244                      	; DO_BSPC - do a backspace, by erasing char just before cursor to
 6245                      	;	background color, and moving cursor back one space
 6246                      	; 	[X] == character to delete
 6247                      	;
 6248   5EA9   0000        	SAVECHX: DW 	0
 6249                      	
 6250   5EAB               	DO_BSPC:
 6251   5EAB   AD D3 71    		lda	CHR_X+LO	; figger new CHR_X
 6252   5EAE   38          		sec			; subtract width
 6253   5EAF   A4 C1       		ldy	FONTFLG		; get which font we be using
 6254   5EB1   F0 05       		beq	DOBSP0		; must be variable width
 6255   5EB3   E9 0C       		sbc	#MONOFONT_W	; get width then of mono font
 6256   5EB5   4C BB 5E    		jmp	DOBSP1		; okay, now do add
 6257   5EB8               	DOBSP0:
 6258   5EB8   FD 25 64    		sbc	CHWID,X		; get width of char to be erased
 6259   5EBB               	DOBSP1:
 6260   5EBB   8D D3 71    		sta	CHR_X+LO	; show new one
 6261   5EBE   8D A9 5E    		sta	SAVECHX+LO	; save to restore later
 6262   5EC1   AD D4 71    		lda	CHR_X+HI	; and pick up carry
 6263   5EC4   E9 00       		sbc	#0		; okay, did it
 6264   5EC6   8D D4 71    		sta	CHR_X+HI	; save it
 6265   5EC9   8D AA 5E    		sta	SAVECHX+HI	; okay
 6266   5ECC   A0 20       		ldy	#SPACE		; get SPACE offset
 6267   5ECE   A5 C1       	        lda     FONTFLG         ; monospaced font?
 6268   5ED0   F0 04       	        beq     DOBSP2          ; nope
 6269   5ED2   A9 0C       	        lda     #MONOFONT_W     ; make monospaced wide
 6270   5ED4   D0 03       	        bne     DOBSP3          ; fine
 6271   5ED6               	DOBSP2:
 6272   5ED6   BD 25 64    		lda	CHWID,X		; get width of char
 6273   5ED9               	DOBSP3:
 6274   5ED9   99 25 64    		sta	CHWID,Y		; set space to be this wide	
 6275   5EDC   8C 80 02    		sty	SCRBUFF		; make space for erasing
 6276   5EDF   A9 01       		lda	#1		; show one char
 6277   5EE1   8D DF 71    		sta	SCRCNT		; assume it used to be zero
 6278   5EE4   20 EC 71    		jsr	DISP_LINE	; put that space out
 6279   5EE7   AD A9 5E    		lda	SAVECHX+LO	; restore old/new x pos
 6280   5EEA   8D D3 71    		sta	CHR_X+LO
 6281   5EED   AD AA 5E    		lda	SAVECHX+HI
 6282   5EF0   8D D4 71    		sta	CHR_X+HI
 6283   5EF3   20 85 73    		jsr	GET_SCRCX	; update SCRCX please
 6284                      	
 6285   5EF6   A9 08       		lda	#SPACE_WIDTH	; restore width of space char
 6286   5EF8   A0 20       		ldy	#SPACE		; get offset
 6287   5EFA   99 25 64    		sta	CHWID,Y		; okay
 6288                      	
 6289   5EFD   4C 9C 5D    		jmp	CH_EXIT		; done
 6290                      	;
 6291                      	; CLS - clear the window, using CLS parameters
 6292                      	;
 6293   5F00               	CLS:
 6294   5F00   A5 00       		lda	SCRCX		; save the current X,Y
 6295   5F02   8D 7C 5D    		sta	SAVECX		; x
 6296   5F05   A5 01       		lda	SCRCY
 6297   5F07   8D 7B 5D    		sta	SAVECY		; saved
  Wed May 24 1989 15:00                                                                                                  Page   92

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6298   5F0A   A5 0B       		lda	CLSTOP		; get top line
 6299   5F0C   85 01       		sta	SCRCY		; and set up a y pos
 6300                      	
 6301   5F0E   20 BC 5F    		jsr	SETMASK		; set up masks and ending point
 6302                      	
 6303   5F11   A5 BD       		lda	CPY_COUNT	; get count
 6304   5F13   85 14       		sta	SH_LOOP		; save count
 6305   5F15   A5 0A       		lda	CLSLEFT		; get left edge
 6306   5F17   85 00       		sta	SCRCX		; set up as X pos
 6307   5F19   A0 0E       		ldy	#WINBGND	; get background offset
 6308   5F1B   B1 05       		lda	(WINDOW),Y	; get background color
 6309   5F1D   85 71       		sta	ARG8		; save it here
 6310   5F1F   A5 0C       		lda	CLSWIDTH	; how wide we be?
 6311   5F21   D0 05       		bne	CLSOKAY		; not a zero width
 6312   5F23   A9 19       		lda	#25		; zero can't do zero width
 6313   5F25   4C 0A 52    		jmp	ZERROR		; so die
 6314   5F28               	CLSOKAY:
 6315   5F28   C9 03       		cmp	#3		; if skinny, handle special
 6316   5F2A   B0 28       		bcs	L1L0		; nope
 6317   5F2C   85 6F       		sta	ARG7		; make this be the counter
 6318   5F2E   A5 0D       		lda	CLSHEIGHT	; just use PUT/GET NYBBLE if only one wide
 6319   5F30   D0 05       		bne	CLSOKAY1	; not a zero height either
 6320   5F32   A9 19       		lda	#25		; bad error
 6321   5F34   4C 0A 52    		jmp	ZERROR
 6322   5F37               	CLSOKAY1:	
 6323   5F37   85 7A       		sta	J		; save here
 6324   5F39               	CLS1W:
 6325   5F39   A5 71       		lda	ARG8		; get color
 6326   5F3B   20 A1 5D    		jsr	PUT_NYBBLE	; put it
 6327   5F3E   E6 00       		inc	SCRCX		; next x
 6328   5F40   C6 6F       		dec	ARG7		; counter
 6329   5F42   D0 F5       		bne	CLS1W		; do next X
 6330   5F44   A5 0A       		lda	CLSLEFT		; get left edge again
 6331   5F46   85 00       		sta	SCRCX		; point to it
 6332   5F48   E6 01       		inc	SCRCY		; next line
 6333   5F4A   A5 0C       		lda	CLSWIDTH	; restore width count
 6334   5F4C   85 6F       		sta	ARG7		; thanks
 6335   5F4E   C6 7A       		dec	J		; count
 6336   5F50   D0 E7       		bne	CLS1W		; do it
 6337   5F52   F0 56       		beq	CLSEXIT		; all done then
 6338   5F54               	L1L0:
 6339   5F54   85 7A       		sta	J		; use j as counter
 6340   5F56               	L1L:
 6341   5F56   A5 71       		lda	ARG8		; a color please
 6342   5F58   20 A1 5D    		jsr	PUT_NYBBLE	; do first line easy
 6343   5F5B   E6 00       		inc	SCRCX		; next nybble
 6344   5F5D   C6 7A       		dec	J		; done yet?
 6345   5F5F   D0 F5       		bne	L1L		; nope
 6346                      	
 6347   5F61   A5 0A       		lda	CLSLEFT		; where is left column
 6348   5F63   85 00       		sta	SCRCX		; here!
 6349   5F65   20 4C 5E    		jsr	SETPOS		; get the address
 6350   5F68   20 73 90    		jsr	FP2SP		; SPC is source PC, now!
 6351   5F6B   A5 0D       		lda	CLSHEIGHT	; how many lines are we clearing
 6352   5F6D   D0 05       		bne	CLSOKAY2	; not a zero height either
 6353   5F6F   A9 19       		lda	#25		; bad error
 6354   5F71   4C 0A 52    		jmp	ZERROR
 6355   5F74               	CLSOKAY2:	
 6356   5F74   85 7A       		sta	J		; j is counter again
 6357   5F76   C6 7A       	 	dec	J		; already cleared one line
 6358   5F78   F0 30       		beq	CLSEXIT		; only one line to do!
 6359   5F7A               	CLSLOOP:
 6360   5F7A   A5 90       	        lda     SPCH            ; now, modify COPY_LINE
 6361   5F7C   8D 7D 1D    	        sta     CPY_MOD1_SRC+HI
 6362   5F7F   8D A1 1D    	        sta     CPY_MOD2_SRC+HI
 6363   5F82   A5 8F       	        lda     SPCL
 6364   5F84   8D 7C 1D    	        sta     CPY_MOD1_SRC+LO
 6365   5F87   8D A0 1D    	        sta     CPY_MOD2_SRC+LO     
 6366   5F8A   E6 01       		inc	SCRCY		; clear this line
 6367   5F8C   20 4C 5E    		jsr	SETPOS		; where am i?
 6368   5F8F   A5 8D       	        lda     FPCH            ; now, modify COPY_LINE
 6369   5F91   8D 80 1D    	        sta     CPY_MOD1_DST+HI
 6370   5F94   8D A4 1D    	        sta     CPY_MOD2_DST+HI
 6371   5F97   A5 8C       	        lda     FPCL
 6372   5F99   8D 7F 1D    	        sta     CPY_MOD1_DST+LO
  Wed May 24 1989 15:00                                                                                                  Page   93

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6373   5F9C   8D A3 1D    	        sta     CPY_MOD2_DST+LO     
 6374   5F9F   A5 14       		lda	SH_LOOP		; get count
 6375   5FA1   85 BD       		sta	CPY_COUNT	; and save it
 6376   5FA3   20 50 1D    		jsr	COPY_LINE	; did the copy (i hope)
 6377   5FA6   C6 7A       		dec	J		; count it
 6378   5FA8   D0 D0       		bne	CLSLOOP		; next one please
 6379   5FAA               	CLSEXIT:
 6380   5FAA   AD 7C 5D    	 	lda	SAVECX		; get X,Y back
 6381   5FAD   85 00       		sta	SCRCX		; got it
 6382   5FAF   AD 7B 5D    		lda	SAVECY		; now for y
 6383   5FB2   85 01       		sta	SCRCY		; restored!
 6384                      	
 6385   5FB4   60          		rts
 6386                      	;
 6387                      	; SETMASK - figger out the start and end masks, as well as setting
 6388                      	;	stuff to point to stopping address.  Use CLSLEFT and CLSWIDTH
 6389                      	;
 6390   5FB5   00 01 03 07 0F 	ST_BITS: db 0,1,3,7,$f,$1f,$3f
        5FBA   1F 3F 
 6391   5FBC               	SETMASK:
 6392   5FBC   A5 0A       		lda	CLSLEFT		; munge with SCRX
 6393   5FBE   85 00       		sta	SCRCX		; okay
 6394   5FC0   20 4C 5E    		jsr	SETPOS		; get me the bit offset of start
 6395                      	
 6396   5FC3   A6 11       		ldx	BITOFF		; now set up mask
 6397   5FC5   BD B5 5F    		lda	ST_BITS,X	; get the bit pattern
 6398   5FC8   85 1A       		sta	STMASK		; save it
 6399                      	
 6400   5FCA   A5 0A       		lda	CLSLEFT		; get left edge again
 6401   5FCC   18          		clc			; add width
 6402   5FCD   65 0C       		adc	CLSWIDTH	; to get where to stop
 6403   5FCF   AA          		tax			; make index
 6404   5FD0   86 00       		stx	SCRCX		; set cur pos
 6405   5FD2   BD 52 03    		lda	XPOSTBL,X	; get how many bytes
 6406   5FD5   A6 0A       		ldx	CLSLEFT		; subtract from byte offset of start
 6407   5FD7   38          		sec			; subbing
 6408   5FD8   FD 52 03    		sbc	XPOSTBL,X
 6409   5FDB   85 BD       		sta	CPY_COUNT	; and save it
 6410                      	
 6411   5FDD   20 4C 5E    		jsr	SETPOS		; so get its address
 6412                      	
 6413   5FE0   A6 11       		ldx	BITOFF		; get bit offset
 6414   5FE2   BD B5 5F    		lda	ST_BITS,X	; get pattern
 6415   5FE5   85 1B       		sta	ENDMASK		; okay!
 6416   5FE7   60          		rts
 6417                      	;
 6418                      	; SCROLL_UP - roll the current window by FONT_H lines
 6419                      	;
 6420   5FE8               	SCROLL_UP:
 6421   5FE8   A9 09       		lda 	#FONT_H		; show one line
 6422   5FEA   85 18       		sta	SCLLINES	; done
 6423   5FEC   85 1D       		sta	SCLDIR		; show scroll up with positive number
 6424   5FEE   A0 00       		ldy	#WINTOP		; get top of screen
 6425   5FF0   B1 05       		lda	(WINDOW),Y	; got it
 6426   5FF2   85 0B       		sta	CLSTOP		; saved it
 6427   5FF4   C8          		iny			; point to left edge
 6428   5FF5   B1 05       		lda	(WINDOW),Y	; get left edge
 6429   5FF7   85 0A       		sta	CLSLEFT		; save
 6430   5FF9   C8          		iny			; this is now the height
 6431   5FFA   B1 05       		lda	(WINDOW),Y	; get window height
 6432   5FFC   85 0D       		sta	CLSHEIGHT	; show me
 6433   5FFE   C8          		iny			; and now for the width
 6434   5FFF   B1 05       		lda	(WINDOW),Y	; get width
 6435   6001   85 0C       	  	sta	CLSWIDTH	; saved it
 6436                      					; so fall thru
 6437                      					; and do the scrolling
 6438                      	;	FALLING THRU
 6439                      	;	   |
 6440                      	;	  \ /
 6441                      	;
 6442                      	;
 6443                      	; DO_SCROLL - scroll SCLLINES withing the window as defined by
 6444                      	;	CLSLEFT,TOP,WIDTH, and HEIGHT
 6445                      	;
 6446   6003               	DO_SCROLL:
  Wed May 24 1989 15:00                                                                                                  Page   94

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6447   6003   A5 00       		lda	SCRCX		; save the current X,Y
 6448   6005   8D 7C 5D    		sta	SAVECX		; x
 6449   6008   A5 01       		lda	SCRCY
 6450   600A   8D 7B 5D    		sta	SAVECY		; saved
 6451   600D   A5 18       		lda	SCLLINES	; how many lines?
 6452                      	
 6453   600F   A6 1D       		ldx	SCLDIR		; which direction?
 6454   6011   10 04       		bpl	SC1		; >0 means scroll up
 6455                      	;
 6456                      	; scroll down, so we are going to start at the bottom and copy downwards
 6457                      	; until we reach the top
 6458                      	;
 6459                      	; now modify code so we do adds to get destination line and subtracts
 6460                      	; to get new src line
 6461                      	;
 6462   6013   A0 C6       		ldy	#$C6		; 'dec' opcode
 6463   6015   D0 04       		bne	SC2		; jump to modify
 6464   6017               	SC1:
 6465                      	;
 6466                      	; scroll up - start at top and copy upwards until we reach the bottom
 6467                      	;
 6468   6017   A0 E6       		ldy	#$E6		; 'inc' opcode
 6469   6019   A6 18       		ldx	SCLLINES	; get # of scrolling lines
 6470   601B               	SC2:
 6471   601B   8C D2 60    		sty	SCMOD1		; make inc/dec
 6472   601E   8C D4 60    		sty	SCMOD2		; either inc or dec
 6473   6021   86 1C       		stx	SCOFF		; save the offset between SRC and DST
 6474                      	
 6475   6023   A5 1D       		lda	SCLDIR		; which direction?
 6476   6025   10 13       		bpl	SC3		; must be normal scroll
 6477                      	;
 6478                      	; if scrolling downwards, we need to start source at bottom-offset and
 6479                      	; end when the destination is at top+offset
 6480                      	;
 6481   6027   A5 0D       		lda	CLSHEIGHT	; get # of lines in window
 6482   6029   38          		sec			; subbing
 6483   602A   E5 1C       		sbc	SCOFF		; subtract offset to get source
 6484   602C   18          		clc			; adding
 6485   602D   65 0B       		adc	CLSTOP		; and get absolute position
 6486   602F   AA          		tax			; put in X
 6487   6030   CA          		dex			; for 0 offset it
 6488   6031   A5 0B       		lda	CLSTOP		; now figger last line to copy
 6489   6033   18          		clc			; adding
 6490   6034   65 0D       		adc	CLSHEIGHT	; get me last line
 6491   6036   A8          		tay			; for later storage
 6492   6037   88          		dey			; make 0 based
 6493   6038   D0 08       		bne	SC4		; always jumps
 6494   603A               	SC3:
 6495                      	;
 6496                      	; if scrolling upwards, start src at top+offset and end when destination
 6497                      	; is at bottom-offset
 6498                      	;
 6499   603A   A5 0B       		lda	CLSTOP		; get top
 6500   603C   18          		clc			; adding
 6501   603D   65 1C       		adc	SCOFF		; add in offset
 6502   603F   AA          		tax			; for later on
 6503   6040   A4 0B       		ldy	CLSTOP		; first destination is top of window
 6504   6042               	SC4:
 6505   6042   86 01       		stx	SCRCY		; Starting Source
 6506   6044   84 15       		sty	SCROLLY		; Starting Destination
 6507                      	
 6508   6046   20 BC 5F    		jsr	SETMASK		; set the masks and horizontal endpoint
 6509   6049   A5 BD       		lda	CPY_COUNT	; save for future generations
 6510   604B   85 14       		sta	SH_LOOP		; save it
 6511   604D   A5 0D       		lda	CLSHEIGHT	; how high
 6512   604F   85 10       		sta	DATALOOP	; save as counter
 6513   6051   38          		sec			; for subbing
 6514   6052   E5 1C       		sbc	SCOFF		; subtract scrolling amount
 6515   6054   85 0D       		sta	CLSHEIGHT	; this is how many lines to copy
 6516   6056   A5 01       		lda	SCRCY		; save Start Source
 6517   6058   48          		pha
 6518   6059   A5 0B       		lda	CLSTOP		; start at Y pos
 6519   605B   85 01       		sta	SCRCY
 6520   605D   A5 0A       		lda	CLSLEFT		; and x pos
 6521   605F   85 00       		sta	SCRCX		; thank you
  Wed May 24 1989 15:00                                                                                                  Page   95

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6522   6061   AD 54 C0    		lda	PAGE2SW+MAIN	; make sure main memory page is in there
 6523   6064               	SCRL1:
 6524   6064   20 4C 5E    		jsr	SETPOS		; set up line pointer
 6525   6067   A4 01       		ldy	SCRCY		; get top
 6526   6069   C0 78       		cpy	#120		; 120 bytes per list
 6527   606B   90 05       		bcc	SCRLY		; all set
 6528   606D   98          		tya			; for adding
 6529   606E   18          		clc
 6530   606F   69 08       		adc	#8
 6531   6071   A8          		tay
 6532   6072               	SCRLY:
 6533   6072   A5 8D       		lda	FPCH
 6534   6074   99 00 06    		sta	SV_PCH,Y
 6535   6077   A5 8C       		lda	FPCL
 6536   6079   99 00 04    		sta	SV_PCL,Y
 6537   607C   E6 01       		inc	SCRCY		; next line please
 6538   607E   C6 10       		dec	DATALOOP
 6539   6080   D0 E2       		bne	SCRL1
 6540                      	
 6541   6082   68          		pla			; get StartSource back
 6542   6083   85 01       		sta	SCRCY
 6543   6085   A5 8E       		lda	FPCBNK		; init SPC bank too
 6544   6087   85 91       		sta	SPCBNK		; fine, we did
 6545   6089               	SCROLLING:
 6546   6089   A4 01       		ldy	SCRCY		; get source Y for index
 6547   608B   C0 78       		cpy	#120		; jump over junk
 6548   608D   90 05       		bcc	SCLYY
 6549   608F   98          		tya
 6550   6090   18          		clc
 6551   6091   69 08       		adc	#8
 6552   6093   A8          		tay
 6553   6094               	SCLYY:
 6554   6094   B9 00 06    		lda	SV_PCH,Y
 6555   6097   85 90       		sta	SPCH
 6556   6099   8D 7D 1D    	        sta     CPY_MOD1_SRC+HI
 6557   609C   8D A1 1D    	        sta     CPY_MOD2_SRC+HI
 6558   609F   B9 00 04    		lda	SV_PCL,Y
 6559   60A2   8D 7C 1D    	        sta     CPY_MOD1_SRC+LO
 6560   60A5   8D A0 1D    	        sta     CPY_MOD2_SRC+LO     
 6561   60A8   85 8F       		sta	SPCL
 6562                      	
 6563   60AA   A4 15       		ldy	SCROLLY		; get destination Y pos
 6564   60AC   C0 78       		cpy	#120		; jump over junk
 6565   60AE   90 05       		bcc	SCLYY1
 6566   60B0   98          		tya
 6567   60B1   18          		clc
 6568   60B2   69 08       		adc	#8
 6569   60B4   A8          		tay
 6570   60B5               	SCLYY1:
 6571   60B5   B9 00 06    		lda	SV_PCH,Y
 6572   60B8   85 8D       		sta	FPCH
 6573   60BA   8D 80 1D    	        sta     CPY_MOD1_DST+HI
 6574   60BD   8D A4 1D    	        sta     CPY_MOD2_DST+HI
 6575   60C0   B9 00 04    		lda	SV_PCL,Y
 6576   60C3   8D 7F 1D    	        sta     CPY_MOD1_DST+LO
 6577   60C6   8D A3 1D    	        sta     CPY_MOD2_DST+LO     
 6578   60C9   85 8C       		sta	FPCL
 6579                      	
 6580   60CB   A5 14       		lda	SH_LOOP		; get byte counter
 6581   60CD   85 BD       		sta	CPY_COUNT	; show copy line
 6582   60CF   20 50 1D    		jsr	COPY_LINE	; and do the copy
 6583   60D2   E6 01       	SCMOD1:	inc	SCRCY		; inc or dec to get next one
 6584   60D4   E6 15       	SCMOD2:	inc	SCROLLY		; inc/dec for next destination Y
 6585   60D6   C6 0D       		dec	CLSHEIGHT	; count down
 6586   60D8   D0 AF       		bne	SCROLLING	; nope
 6587                      	
 6588   60DA   A6 1D       		ldx	SCLDIR		; scroll up or down?
 6589   60DC   10 09       		bpl	SCLCLR1		; clear a little different
 6590                      	;
 6591                      	; if scrolling down, clear from current Y+1
 6592                      	;	
 6593   60DE   A5 01       		lda	SCRCY		; get current source
 6594   60E0   85 0B       		sta	CLSTOP		; save in top spot
 6595   60E2   E6 0B       		inc	CLSTOP		; get inside window
 6596   60E4   4C EB 60    		jmp	SCLCLR2
  Wed May 24 1989 15:00                                                                                                  Page   96

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6597   60E7               	SCLCLR1:
 6598   60E7   A5 15       		lda	SCROLLY		; get last destination
 6599   60E9   85 0B       		sta	CLSTOP		; and save it
 6600   60EB               	SCLCLR2:
 6601   60EB   A5 1C       		lda	SCOFF		; and both clear this many lines
 6602   60ED   85 0D       		sta	CLSHEIGHT	; okay?
 6603                      	
 6604   60EF   AD 7C 5D    		lda	SAVECX		; now restore X and Y
 6605   60F2   85 00       		sta	SCRCX		; x
 6606   60F4   AD 7B 5D    		lda	SAVECY		; and
 6607   60F7   85 01       		sta	SCRCY		; y
 6608                      	
 6609   60F9   20 00 5F    		jsr	CLS		; WIDTH and LEFT should be okay still
 6610                      	
 6611   60FC   60          		rts
 6612                      	;
 6613                      	; CLREOL - clear from current cursor position to end of line by
 6614                      	;	using CLS after changing the window size
 6615                      	;	
 6616   60FD               	CLREOL:
 6617   60FD   A5 00       		lda	SCRCX		; and make left be where cursor is
 6618   60FF   85 0A       		sta	CLSLEFT
 6619   6101   A5 01       		lda	SCRCY		; and top be where Y is
 6620   6103   85 0B       		sta	CLSTOP
 6621   6105   A9 09       		lda	#FONT_H		; and bottom be bottom of char
 6622   6107   85 0D       		sta	CLSHEIGHT
 6623   6109   A0 03       		ldy	#WINWID		; get width
 6624   610B   B1 05       		lda	(WINDOW),Y	; got it
 6625   610D   18          		clc			; now adding 
 6626   610E   A0 01       		ldy	#WINLEFT	; the left edge
 6627   6110   71 05       		adc	(WINDOW),Y	; to get the right edge
 6628   6112   38          		sec			; subbing
 6629   6113   E5 0A       		sbc	CLSLEFT		; and subtract left to get width
 6630   6115   A0 07       	        ldy     #WINRM          ; remove the size of the right margin
 6631   6117   F1 05       	        sbc     (WINDOW),Y      ; that too
 6632   6119   85 0C       		sta	CLSWIDTH 	; okay?
 6633   611B   4C 00 5F    		jmp	CLS		; now clear the screen
 6634                      	;
 6635                      	; COPY_SCRL - copy from SCR_LINE onto the screen.  CH_OFFSET says how
 6636                      	;	many bytes in SCR_LINE to copy.  FPC is assumed to be pointing
 6637                      	;	to start of screen bytes.  BITTER has the original BITOFF from
 6638                      	;	SETPOS.  ENDBIT shows how many significant bits in last byte.
 6639                      	;
 6640   611E               	COPY_SCRL:
 6641   611E   AE DE 71    		ldx	SHOW_CURSOR	; are we showing the cursor (ugh)
 6642   6121   F0 03       		beq	COPYL2		; nope
 6643   6123   4C 9D 73    		jmp	DO_CURSOR	; then XOR cursor in
 6644   6126               	COPYL2:
 6645   6126   A0 0E       		ldy	#WINBGND	; get background offset
 6646   6128   B1 05       		lda	(WINDOW),Y	; get current background color
 6647   612A   F0 03       		beq	COPY_SCRL1	; if black, ignore this
 6648   612C   20 ED 61    		jsr	FIX_COLOR	; or in the color, please
 6649                      	;
 6650                      	; Alternate entry point for COPY_SCRL, used by picture drawing routine
 6651                      	; to avoid using background color and checking for cursor
 6652                      	;
 6653   612F               	COPY_SCRL1:
 6654   612F   A6 8E       		ldx	FPCBNK		; set up bank
 6655   6131   BD 54 C0    		lda	PAGE2SW,X	; set first bank 
 6656   6134   AD D5 71    		lda	ENDBIT		; did we end evenly?
 6657   6137   D0 02       		bne	COPYL22		; nope
 6658   6139   E6 0F       		inc	CH_OFFSET		; make CH_OFFSET be a counter
 6659   613B               	COPYL22:
 6660   613B   A0 00       		ldy	#0		; zero y
 6661                      	
 6662   613D   A5 0F       		lda	CH_OFFSET		; if only one, then handle real special
 6663   613F   D0 24       		bne	COPYL21		; nope
 6664                      	
 6665   6141   AE DC 71    		ldx	BITTER		; get starting bit offset
 6666   6144   BD B5 5F    		lda	ST_BITS,X	; get starting bit mask
 6667   6147   85 AC       		sta	IOCHAR		; save it
 6668   6149   AE D5 71    		ldx	ENDBIT		; get ending bit offset
 6669   614C   BD B5 5F    		lda	ST_BITS,X	; combine with ending mask bits
 6670   614F   49 FF       		eor	#$FF		; set for good ones
 6671   6151   05 AC       		ora	IOCHAR		; set up mask for bits
  Wed May 24 1989 15:00                                                                                                  Page   97

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6672   6153   31 8C       		and	(FPC),Y		; get me interesting bits
 6673   6155   91 8C       		sta	(FPC),Y		; save
 6674   6157   A5 AC       		lda	IOCHAR		; get flag for data
 6675   6159   49 FF       		eor	#$FF		; flip to get good data
 6676   615B   2D 00 1F    	CPYSM1:	and	SCR_LINE	; pick up my bits
 6677   615E   11 8C       		ora	(FPC),Y		; and or in screen data
 6678   6160   91 8C       		sta	(FPC),Y		; and save it 
 6679   6162   4C E9 61    		jmp	COPYLEX		; go away now
 6680   6165               	COPYL21:
 6681   6165   A5 0F       		lda	CH_OFFSET		; get # of chars
 6682   6167   4A          		lsr	A		; /2 get number in this bank
 6683   6168   69 00       		adc	#0		; pick up carry for first one
 6684   616A   85 10       		sta	DATALOOP	; and save it to work on
 6685                      	
 6686   616C   AE DC 71    		ldx	BITTER		; do we have a weird start?
 6687   616F   F0 1A       		beq	DLL2		; nope
 6688                      	;
 6689                      	; need to do the first one special
 6690                      	;
 6691   6171   B1 8C       		lda	(FPC),Y		; get byte
 6692   6173   3D B5 5F    		and	ST_BITS,X	; get masking bits
 6693   6176   85 AC       		sta	IOCHAR		; save for later
 6694   6178   BD B5 5F    		lda	ST_BITS,X	; get masking bits again
 6695   617B   49 FF       		eor	#$FF		; get good bits
 6696   617D   2D 00 1F    	CPYSM2:	and	SCR_LINE	; get first data byte
 6697   6180   05 AC       		ora	IOCHAR		; pick up screen bits
 6698   6182   91 8C       		sta	(FPC),Y		; pointing
 6699   6184   C8          		iny			; next byte
 6700   6185   A2 02       		ldx	#2		; start at next one for this bank
 6701   6187   C6 10       		dec 	DATALOOP	; kount as done
 6702   6189               	COPYLOOP:
 6703   6189   F0 0C       		beq	CPYLP2		; all done with this part of line
 6704   618B               	DLL2:
 6705   618B   BD 00 1F    	CPYSM3:	lda	SCR_LINE,X	; get data
 6706   618E   91 8C       		sta	(FPC),Y		; pointing
 6707   6190   C8          		iny			; next byte
 6708   6191   E8          		inx			; next one
 6709   6192   E8          		inx			; next one
 6710   6193   C6 10       		dec	DATALOOP	; count as used
 6711   6195   10 F2       		bpl	COPYLOOP	; start loop again
 6712   6197               	CPYLP2:
 6713   6197   A0 00       		ldy	#0		; reset Y
 6714   6199   A5 8E       		lda	FPCBNK		; which bank were we at
 6715   619B   49 01       		eor	#1		; swap to other one
 6716   619D   AA          		tax			; make it in x
 6717   619E   BD 54 C0    		lda	PAGE2SW,X	; swap to write bank
 6718   61A1   8A          		txa			; check which one
 6719   61A2   F0 01       		beq	CPYLP23		; correct offset
 6720   61A4   C8          		iny			; fix offset if going from main to aux
 6721   61A5               	CPYLP23:
 6722   61A5   A2 01       		ldx	#1		; start at second byte in screen line
 6723   61A7   A5 0F       		lda	CH_OFFSET		; get starting number
 6724   61A9   4A          		lsr	A		; /2 to get how many for this bank
 6725   61AA   85 10       		sta	DATALOOP	; and show it
 6726   61AC               	COPYLOOP2:
 6727   61AC   F0 0C       		beq	LINE_DONE	; all done with this part of line
 6728                      	
 6729   61AE   BD 00 1F    	CPYSM4:	lda	SCR_LINE,X	; get data
 6730   61B1   91 8C       		sta	(FPC),Y		; pointing
 6731   61B3   C8          		iny			; next byte
 6732   61B4   E8          		inx			; next one
 6733   61B5   E8          		inx			; next one
 6734   61B6   C6 10       		dec	DATALOOP	; count as used
 6735   61B8   10 F2       		bpl	COPYLOOP2	; start loop again
 6736   61BA               	LINE_DONE:
 6737                      	;
 6738                      	; do the last byte special
 6739                      	;
 6740   61BA   86 10       		stx	DATALOOP	; save pointer
 6741   61BC   AD D5 71    		lda	ENDBIT		; get ending bit offset
 6742   61BF   F0 28       		beq	COPYLEX		; all done if nothing funky
 6743   61C1   46 0F       		lsr	CH_OFFSET	; get line offset
 6744   61C3   48          		pha			; save [A]
 6745   61C4   B0 0B       		bcs	LINED1		; if odd, point at right things
 6746   61C6   C6 10       		dec	DATALOOP	;  one less then
  Wed May 24 1989 15:00                                                                                                  Page   98

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6747   61C8   A6 8E       		ldx	FPCBNK		; get original bank
 6748   61CA   BD 54 C0    		lda	PAGE2SW,X	; switch to it
 6749   61CD   8A          		txa			; which bank did we do?
 6750   61CE   D0 01       		bne	LINED1		; no need to step back one
 6751   61D0   88          		dey			; point one less here too
 6752   61D1               	LINED1:
 6753   61D1   68          		pla			; get ENDBIT back
 6754   61D2   AA          		tax			; make end bits be index
 6755   61D3   BD B5 5F    		lda	ST_BITS,X	; get end mask
 6756   61D6   85 AC       		sta	IOCHAR		; save mask bits
 6757   61D8   49 FF       		eor	#$FF		; toggle every bit
 6758   61DA   31 8C       		and	(FPC),Y		; get the interesting bits in byte
 6759   61DC   91 8C       		sta	(FPC),Y		; save it
 6760   61DE   A6 10       		ldx	DATALOOP	; get data pointer
 6761   61E0   BD 00 1F    	CPYSM5:	lda	SCR_LINE,X	; turn on my bits
 6762   61E3   25 AC       		and	IOCHAR		; pick up my good bits
 6763   61E5   11 8C       		ora	(FPC),Y		; bring everything together
 6764   61E7   91 8C       		sta	(FPC),Y		; save the byte
 6765   61E9               	COPYLEX:
 6766   61E9   AD 54 C0    		lda	PAGE2SW+MAIN	; back to main, thanks
 6767   61EC   60          		rts
 6768                      	
 6769   61ED               	FIX_COLOR:
 6770   61ED   E6 0F       	        inc     CH_OFFSET       ; just to make checking easier for now
 6771                      	
 6772   61EF   0A          		asl	A		; *2
 6773   61F0   0A          		asl	A		; *4 to get correct offset
 6774   61F1   69 12       		adc	#<COLORS	; add start of table
 6775   61F3   85 AD       		sta	COLORP+LO	; save for pointer
 6776   61F5   A9 03       		lda	#>COLORS	; get hi part
 6777   61F7   69 00       		adc	#0		; pick up maybe carry
 6778   61F9   85 AE       		sta	COLORP+HI	; save pointer
 6779   61FB   A2 11       	        ldx     #$11            ; ORA (),Y opcode
 6780   61FD   A0 0D       	        ldy     #WINFORE        ; check foreground color
 6781   61FF   B1 05       	        lda     (WINDOW),Y      ; check what color
 6782   6201   D0 11       	        bne     FIXC1           ; just leave white if not black
 6783   6203   A2 00       	        ldx     #0              ; start at beginning
 6784   6205               	FIXMUNGEL:
 6785   6205   BD 00 1F    	        lda     SCR_LINE,X      ; get byte
 6786   6208   49 FF       	        eor     #$FF            ; swap all the bits
 6787   620A   9D 00 1F    	        sta     SCR_LINE,X      ; store back
 6788   620D   E8          	        inx                     ; count it
 6789   620E   E4 0F       	        cpx     CH_OFFSET       ; done?
 6790   6210   90 F3       	        bcc     FIXMUNGEL       ; nope
 6791   6212   A2 31       	        ldx     #$31            ; AND (),Y opcode
 6792   6214               	FIXC1:
 6793   6214   8E 22 62    	        stx     FCLM            ; self mod my code (again . . . sigh)
 6794   6217   AD DC 71    		lda	BITTER		; get starting offset
 6795   621A   29 03       		and	#3		; pick up wrap
 6796   621C   A8          		tay			; make index
 6797   621D   A2 00       		ldx	#0		; start at zero line
 6798   621F               	FIXLOOP:
 6799   621F   BD 00 1F    	FCM1:	lda	SCR_LINE,X	; get screen byte
 6800   6222   11 AD       	FCLM:	ora	(COLORP),Y	; or with color byte
 6801   6224   9D 00 1F    	FCM2:	sta	SCR_LINE,X	; save it
 6802   6227   C8          		iny			; next color byte
 6803   6228   C0 04       		cpy	#4		; wrapped?
 6804   622A   D0 02       		bne	FIXLP1		; nope
 6805   622C   A0 00       		ldy	#0		; restart
 6806   622E               	FIXLP1:
 6807   622E   E8          		inx			; next screen byte
 6808   622F   E4 0F       		cpx	CH_OFFSET	; done yet?
 6809   6231   90 EC       	        bcc     FIXLOOP         ; nope
 6810   6233               	        
 6811   6233   C6 0F       	        dec     CH_OFFSET       ; fix counter
 6812   6235   60          		rts			; now we are done
 6813                      	;
 6814                      	; MSCURS - Erase the cursor from the old spot and write it in the
 6815                      	;  new spot
 6816                      	;
 6817   6236   8C          	MOLDX:	db	MAXWIDTH	; spot to save x,y of mouse
 6818   6237   C0          	MOLDY:	db	MAXHEIGHT
 6819   6238               	MSCCNT:	ds	1
 6820   6239               	SVCURS:	ds	CURSW*CURSH	; save room
 6821   6241   01          	MSWCNT:	db	1
  Wed May 24 1989 15:00                                                                                                  Page   99

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6822   6242   00          	MSSTATE: db	0		; 0 == off, 1 == on
 6823   6243   0F 07 07 07 07 	MSCOLOR: db	$f,7,7,7,7,7,7,7
        6248   07 07 07 
 6824                      	;
 6825   624B               	MSCURS:
 6826   624B   A9 00       		lda	#0		; clear moved flag
 6827   624D   8D 12 03    		sta	MSMOVEF		; we did
 6828   6250   20 56 62    		jsr	MSCOFF		; turn cursor off at current pos
 6829   6253   4C B5 62    		jmp	MSCON		; and turn it on in new spot
 6830                      	
 6831                      	;
 6832                      	; MSCOFF - mouse cursor off
 6833                      	;	Copy info from saved spot back onto screen @ MOLDX, MOLDY
 6834   6256               	MSCOFF:
 6835   6256   AD 42 62    	        lda     MSSTATE         ; already off?
 6836   6259   D0 01       	        bne     MSCOFF1         ; no
 6837   625B   60          	        rts                     ; done then
 6838   625C               	MSCOFF1:
 6839   625C   A5 01       		lda	SCRCY		; save X,Y
 6840   625E   8D 7B 5D    		sta	SAVECY
 6841   6261   A5 00       		lda	SCRCX
 6842   6263   8D 7C 5D    		sta	SAVECX
 6843   6266   AD 36 62    		lda	MOLDX		; point to old X,Y
 6844   6269   85 00       		sta	SCRCX
 6845   626B   AD 37 62    		lda	MOLDY
 6846   626E   85 01       		sta	SCRCY
 6847   6270   A9 00       		lda	#0		; start at beginning of saved area
 6848   6272   8D 38 62    		sta	MSCCNT		; save counter
 6849   6275   A9 02       		lda	#CURSW		; restore width
 6850   6277   8D 41 62    		sta	MSWCNT		; and counter
 6851   627A               	RENEWL:
 6852   627A   A5 01       		lda	SCRCY		; check bounds
 6853   627C   C9 C0       		cmp	#MAXHEIGHT
 6854   627E   B0 32       		bcs	MSC1		; all done
 6855   6280               	RENEWL0:
 6856   6280   A5 00       		lda	SCRCX
 6857   6282   C9 8C       		cmp	#MAXWIDTH
 6858   6284   B0 1E       		bcs	RENEWL1		; might not be done
 6859   6286   20 0B 5E    	        jsr     GET_NYBBLE      ; get screen nybble
 6860   6289   AE 38 62    		ldx	MSCCNT		; get counter
 6861                      	;        eor     MSCOLOR,X       ; xor to turn off
 6862   628C   49 0F       	        eor     #$0F            ; turn white/black
 6863   628E   20 A1 5D    		jsr	PUT_NYBBLE	; save nybble
 6864   6291   EE 38 62    		inc	MSCCNT		; point to next one
 6865   6294   AD 38 62    		lda	MSCCNT		; get counter
 6866   6297   C9 08       		cmp	#(CURSW*CURSH)	; done yet?
 6867   6299   F0 17       		beq	MSC1		; yup
 6868   629B   CE 41 62    		dec	MSWCNT		; count down one width
 6869   629E   F0 04       		beq	RENEWL1		; it is
 6870   62A0   E6 00       		inc	SCRCX		; next x
 6871   62A2   D0 DC       		bne	RENEWL0		; try again
 6872   62A4               	RENEWL1:
 6873   62A4   AD 36 62    		lda	MOLDX		; reset X
 6874   62A7   85 00       		sta	SCRCX
 6875   62A9   A9 02       		lda	#CURSW		; restore width
 6876   62AB   8D 41 62    		sta	MSWCNT		; and counter
 6877   62AE   E6 01       		inc	SCRCY		; next y
 6878   62B0   D0 C8       		bne	RENEWL		; okay try some more
 6879   62B2               	MSC1:
 6880   62B2   4C 14 63    		jmp 	MSCON4		; done turning it off
 6881                      	;
 6882                      	; MSCON - turn mouse cursor on
 6883                      	;	Copy white pixels into area specified by MSX, MSY
 6884                      	;
 6885   62B5               	MSCON:
 6886   62B5   AD 42 62    	        lda     MSSTATE         ; already on?
 6887   62B8   F0 01       	        beq     MSCON0          ; no
 6888   62BA   60          	        rts                     ; don't bother
 6889   62BB               	MSCON0:
 6890   62BB   A5 01       		lda	SCRCY		; save X,Y
 6891   62BD   8D 7B 5D    		sta	SAVECY
 6892   62C0   A5 00       		lda	SCRCX
 6893   62C2   8D 7C 5D    		sta	SAVECX
 6894                      	
 6895   62C5   A5 CB       		lda	MSX		; get mouse x
  Wed May 24 1989 15:00                                                                                                  Page  100

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6896   62C7   85 00       		sta	SCRCX		; set mouse X
 6897   62C9   8D 36 62    		sta	MOLDX		; save mouse x
 6898   62CC   A5 CC       		lda	MSY		; get mouse y
 6899   62CE   85 01       		sta	SCRCY		; set mouse Y
 6900   62D0   8D 37 62    		sta	MOLDY		; and mouse Y
 6901   62D3   A9 00       		lda	#0		; start at beginning of saved area
 6902   62D5   8D 38 62    		sta	MSCCNT		; save counter
 6903   62D8   A9 02       		lda	#CURSW		; restore width
 6904   62DA   8D 41 62    		sta	MSWCNT		; and counter
 6905   62DD               	MSCON1:
 6906   62DD   A5 01       		lda	SCRCY		; check bounds
 6907   62DF   C9 C0       		cmp	#MAXHEIGHT
 6908   62E1   B0 31       		bcs	MSCON4		; all done
 6909   62E3               	MSCON2:
 6910   62E3   A5 00       		lda	SCRCX
 6911   62E5   C9 8C       		cmp	#MAXWIDTH
 6912   62E7   B0 1E       		bcs	MSCON3		; might not be done
 6913   62E9   20 0B 5E    		jsr	GET_NYBBLE	; save nybble
 6914   62EC   AE 38 62    	 	ldx	MSCCNT		; get counter
 6915                      	;	eor	MSCOLOR,X	; get cursor color
 6916   62EF   49 0F       	        eor     #$0F            ; turn white/black
 6917   62F1   20 A1 5D    		jsr	PUT_NYBBLE	; put nybble
 6918   62F4   EE 38 62    		inc	MSCCNT		; point to next one
 6919   62F7   AD 38 62    		lda	MSCCNT		; check ending
 6920   62FA   C9 08       		cmp	#(CURSW*CURSH)	; done yet?
 6921   62FC   F0 16       		beq	MSCON4		; yup
 6922   62FE   CE 41 62    		dec	MSWCNT		; count down one width
 6923   6301   F0 04       		beq	MSCON3		; finished for line
 6924   6303   E6 00       		inc	SCRCX		; next x
 6925   6305   D0 DC       		bne	MSCON2		; try again
 6926   6307               	MSCON3:
 6927   6307   A5 CB       		lda	MSX		; reset X
 6928   6309   85 00       		sta	SCRCX
 6929   630B   A9 02       		lda	#CURSW		; restore width
 6930   630D   8D 41 62    		sta	MSWCNT		; and counter
 6931   6310   E6 01       		inc	SCRCY		; next y
 6932   6312   D0 C9       		bne	MSCON1		; okay try some more
 6933   6314               	MSCON4:
 6934   6314   AD 42 62    	        lda     MSSTATE         ; get current state
 6935   6317   49 01       	        eor     #$01            ; toggle it
 6936   6319   8D 42 62    	        sta     MSSTATE         ; bang
 6937   631C   AD 7C 5D    		lda	SAVECX		; restore X,Y
 6938   631F   85 00       		sta	SCRCX
 6939   6321   AD 7B 5D    		lda	SAVECY
 6940   6324   85 01       		sta	SCRCY
 6941   6326   60          		rts	
 6942   6327               		
 6943                      	
 6944   6327               		END
 6945                      	
 6946   6327               		INCLUDE		TABLES.ASM
 6947   6327               		STTL	"--- ZIP DATA TABLES ---"
 6948                      		PAGE
  Wed May 24 1989 15:00                                                                                                  Page  101

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

 6949   6327               	CHADR_H:
 6950   6327   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        632C   00 00 00 00 00 
        6331   00 00 00 00 00 
        6336   00 
 6951   6337   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        633C   00 00 00 00 00 
        6341   00 00 00 00 00 
        6346   00 
 6952   6347   64 64 64 64 64 		db	>C20,>C21,>C22,>C23,>C24,>C25,>C26,>C27
        634C   64 65 65 
 6953   634F   65 65 65 65 65 		DB	>C28,>C29,>C2A,>C2B,>C2C,>C2D,>C2E,>C2F
        6354   65 65 65 
 6954   6357   65 65 65 65 65 		db	>C30,>C31,>C32,>C33,>C34,>C35,>C36,>C37
        635C   65 65 65 
 6955   635F   65 66 66 66 66 		DB	>C38,>C39,>C3A,>C3B,>C3C,>C3D,>C3E,>C3F
        6364   66 66 66 
 6956   6367   66 66 66 66 66 		db	>C40,>C41,>C42,>C43,>C44,>C45,>C46,>C47
        636C   66 66 66 
 6957   636F   66 66 66 67 67 		DB	>C48,>C49,>C4A,>C4B,>C4C,>C4D,>C4E,>C4F
        6374   67 67 67 
 6958   6377   67 67 67 67 67 		db	>C50,>C51,>C52,>C53,>C54,>C55,>C56,>C57
        637C   67 67 67 
 6959   637F   67 67 68 68 68 		DB	>C58,>C59,>C5A,>C5B,>C5C,>C5D,>C5E,>C5F
        6384   68 68 68 
 6960   6387   68 68 68 68 68 		db	>C60,>C61,>C62,>C63,>C64,>C65,>C66,>C67
        638C   68 68 68 
 6961   638F   68 68 68 69 69 		DB	>C68,>C69,>C6A,>C6B,>C6C,>C6D,>C6E,>C6F
        6394   69 69 69 
 6962   6397   69 69 69 69 69 		db	>C70,>C71,>C72,>C73,>C74,>C75,>C76,>C77
        639C   69 69 69 
 6963   639F   69 69 69 6A 6A 		DB	>C78,>C79,>C7A,>C7B,>C7C,>C7D,>C7E
        63A4   6A 6A 
 6964   63A6               	CHADR_L:
 6965   63A6   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        63AB   00 00 00 00 00 
        63B0   00 00 00 00 00 
        63B5   00 
 6966   63B6   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        63BB   00 00 00 00 00 
        63C0   00 00 00 00 00 
        63C5   00 
 6967   63C6   A4 B6 BF D1 E3 		db	<C20,<C21,<C22,<C23,<C24,<C25,<C26,<C27
        63CB   F5 07 19 
 6968   63CE   22 2B 34 3D 4F 		DB	<C28,<C29,<C2A,<C2B,<C2C,<C2D,<C2E,<C2F
        63D3   58 61 6A 
 6969   63D6   7C 8E 97 A9 BB 		db	<C30,<C31,<C32,<C33,<C34,<C35,<C36,<C37
        63DB   CD DF F1 
 6970   63DE   FA 0C 1E 27 30 		DB	<C38,<C39,<C3A,<C3B,<C3C,<C3D,<C3E,<C3F
        63E3   39 42 4B 
 6971   63E6   5D 6F 81 93 A5 		db	<C40,<C41,<C42,<C43,<C44,<C45,<C46,<C47
        63EB   B7 C0 C9 
 6972   63EE   DB ED F6 08 1A 		DB	<C48,<C49,<C4A,<C4B,<C4C,<C4D,<C4E,<C4F
        63F3   23 35 47 
 6973   63F6   59 6B 7D 8F A1 		db	<C50,<C51,<C52,<C53,<C54,<C55,<C56,<C57
        63FB   B3 C5 D7 
 6974   63FE   E9 FB 0D 1F 28 		DB	<C58,<C59,<C5A,<C5B,<C5C,<C5D,<C5E,<C5F
        6403   3A 43 55 
 6975   6406   5E 67 79 8B 9D 		db	<C60,<C61,<C62,<C63,<C64,<C65,<C66,<C67
        640B   AF C1 CA 
 6976   640E   DC EE F7 00 12 		DB	<C68,<C69,<C6A,<C6B,<C6C,<C6D,<C6E,<C6F
        6413   1B 2D 3F 
 6977   6416   51 63 75 7E 90 		db	<C70,<C71,<C72,<C73,<C74,<C75,<C76,<C77
        641B   99 AB BD 
 6978   641E   CF E1 F3 05 0E 		DB	<C78,<C79,<C7A,<C7B,<C7C,<C7D,<C7E
        6423   17 20 
 6979                      	
 6980   6425               	CHWID:
 6981   6425   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        642A   00 00 00 00 00 
        642F   00 00 00 00 00 
        6434   00 
 6982   6435   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        643A   00 00 00 00 00 
        643F   00 00 00 00 00 
  Wed May 24 1989 15:00                                                                                                  Page  102

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6444   00 
 6983   6445   08 06 0A 0D 0D 		db	8,6,10,13,13,14,12,5,7,7,9,10,6,9,5,10
        644A   0E 0C 05 07 07 
        644F   09 0A 06 09 05 
        6454   0A 
 6984   6455   0B 07 0A 0A 0D 		db	11,7,10,10,13,10,11,9,11,11,5,6,9,9,9,11,16,11,11,11,11
        645A   0A 0B 09 0B 0B 
        645F   05 06 09 09 09 
        6464   0B 10 0B 0B 0B 
        6469   0B 
 6985   646A   09 09 0B 0B 05 		db	9,9,11,11,5,11,12,9,15,13,11,11,11,11,11,11,11,11
        646F   0B 0C 09 0F 0D 
        6474   0B 0B 0B 0B 0B 
        6479   0B 0B 0B 
 6986   647C   10 0B 0B 0B 09 		db	16,11,11,11,9,11,9,11,9,7,11,11,11,11,11,9,11,11,6,9,11,6
        6481   0B 09 0B 09 07 
        6486   0B 0B 0B 0B 0B 
        648B   09 0B 0B 06 09 
        6490   0B 06 
 6987   6492   0F 0B 0B 0B 0B 		db	15,11,11,11,11,9,10,9,11,11,15,11,11,11,9,6,9,12
        6497   09 0A 09 0B 0B 
        649C   0F 0B 0B 0B 09 
        64A1   06 09 0C 
 6988                      	
 6989                      		RADIX	H				; make everything be hex
 6990          64A4        	CHAR_TABLE	EQU	*
 6991   64A4   00 00 00 00 00 	C20	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 ;(SPACE)
        64A9   00 00 00 00 00 
        64AE   00 00 00 00 00 
        64B3   00 00 00 
 6992   64B6   78 78 78 78 78 	C21	DB	78,78,78,78,78,00,78,00,00 ;! 5
        64BB   00 78 00 00 
 6993   64BF   73 80 73 80 73 	C22	DB	73,80,73,80,73,80,00,00,00,00,00,00,00,00,00,00,00,00 ;" 9
        64C4   80 00 00 00 00 
        64C9   00 00 00 00 00 
        64CE   00 00 00 
 6994   64D1   39 C0 FF F0 39 	C23	DB	39,c0,ff,f0,39,c0,39,c0,ff,f0,39,c0,00,00,00,00,00,00 ;# 12
        64D6   C0 39 C0 FF F0 
        64DB   39 C0 00 00 00 
        64E0   00 00 00 
 6995   64E3   06 00 7F E0 E6 	C24	DB	06,00,7f,e0,e6,00,7f,e0,06,70,7f,e0,06,00,00,00,00,00 ;$ 12
        64E8   00 7F E0 06 70 
        64ED   7F E0 06 00 00 
        64F2   00 00 00 
 6996   64F5   78 E0 CD C0 7B 	C25	DB	78,e0,cd,c0,7b,80,07,00,0e,f0,1d,98,38,f0,00,00,00,00 ;% 13
        64FA   80 07 00 0E F0 
        64FF   1D 98 38 F0 00 
        6504   00 00 00 
 6997   6507   7F 00 E3 80 E0 	C26	DB	7f,00,e3,80,e0,00,78,00,e0,e0,e1,c0,7f,80,00,00,00,00 ;& 11
        650C   00 78 00 E0 E0 
        6511   E1 C0 7F 80 00 
        6516   00 00 00 
 6998   6519   70 70 70 00 00 	C27	DB	70,70,70,00,00,00,00,00,00 ;' 4
        651E   00 00 00 00 
 6999   6522   1C 38 70 70 70 	C28	DB	1c,38,70,70,70,38,1c,00,00 ;( 6
        6527   38 1C 00 00 
 7000   652B   70 38 1C 1C 1C 	C29	DB	70,38,1c,1c,1c,38,70,00,00 ;) 6
        6530   38 70 00 00 
 7001   6534   DB 3C FF 3C DB 	C2A	DB	db,3c,ff,3c,db,00,00,00,00 ;* 8
        6539   00 00 00 00 
 7002   653D   1C 00 1C 00 FF 	C2B	DB	1c,00,1c,00,ff,80,1c,00,1c,00,00,00,00,00,00,00,00,00 ;+ 9
        6542   80 1C 00 1C 00 
        6547   00 00 00 00 00 
        654C   00 00 00 
 7003   654F   00 00 00 00 00 	C2C	DB	00,00,00,00,00,38,38,18,70 ;, 5
        6554   38 38 18 70 
 7004   6558   00 00 00 FF 00 	C2D	DB	00,00,00,ff,00,00,00,00,00 ;- 8
        655D   00 00 00 00 
 7005   6561   00 00 00 00 00 	C2E	DB	00,00,00,00,00,70,70,00,00 ;. 4
        6566   70 70 00 00 
 7006   656A   03 80 07 00 0E 	C2F	DB	03,80,07,00,0e,00,1c,00,38,00,70,00,e0,00,00,00,00,00 ;/ 9
        656F   00 1C 00 38 00 
        6574   70 00 E0 00 00 
        6579   00 00 00 
 7007   657C   1F 00 3B 80 71 	C30	DB	1f,00,3b,80,71,c0,71,c0,71,c0,3b,80,1f,00,00,00,00,00 ;0 10
  Wed May 24 1989 15:00                                                                                                  Page  103

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6581   C0 71 C0 71 C0 
        6586   3B 80 1F 00 00 
        658B   00 00 00 
 7008   658E   1C 7C 1C 1C 1C 	C31	DB	1c,7c,1c,1c,1c,1c,1c,00,00 ;1 6
        6593   1C 1C 00 00 
 7009   6597   3F 00 63 80 06 	C32	DB	3f,00,63,80,06,80,0e,00,1c,00,70,00,7f,80,00,00,00,00 ;2 9
        659C   80 0E 00 1C 00 
        65A1   70 00 7F 80 00 
        65A6   00 00 00 
 7010   65A9   7F 80 03 00 06 	C33	DB	7f,80,03,00,06,00,1f,00,03,80,63,80,3f,00,00,00,00,00 ;3 9
        65AE   00 1F 00 03 80 
        65B3   63 80 3F 00 00 
        65B8   00 00 00 
 7011   65BB   07 C0 0F C0 1D 	C34	DB	07,c0,0f,c0,1d,c0,39,c0,71,c0,7f,f0,01,c0,00,00,00,00 ;4 12
        65C0   C0 39 C0 71 C0 
        65C5   7F F0 01 C0 00 
        65CA   00 00 00 
 7012   65CD   7F 80 78 00 78 	C35	DB	7f,80,78,00,78,00,7f,00,03,80,63,80,3f,00,00,00,00,00 ;5 9
        65D2   00 7F 00 03 80 
        65D7   63 80 3F 00 00 
        65DC   00 00 00 
 7013   65DF   1F 80 38 00 70 	C36	DB	1f,80,38,00,70,00,7f,80,71,c0,71,c0,3f,80,00,00,00,00 ;6 10
        65E4   00 7F 80 71 C0 
        65E9   71 C0 3F 80 00 
        65EE   00 00 00 
 7014   65F1   7F 07 07 0E 1C 	C37	DB	7f,07,07,0e,1c,1c,1c,00,00 ;7 8
        65F6   1C 1C 00 00 
 7015   65FA   3F 80 71 C0 71 	C38	DB	3f,80,71,c0,71,c0,3f,80,71,c0,71,c0,3f,80,00,00,00,00 ;8 10
        65FF   C0 3F 80 71 C0 
        6604   71 C0 3F 80 00 
        6609   00 00 00 
 7016   660C   3F 80 71 C0 71 	C39	DB	3f,80,71,c0,71,c0,3f,c0,01,c0,03,80,3f,00,00,00,00,00 ;9 10
        6611   C0 3F C0 01 C0 
        6616   03 80 3F 00 00 
        661B   00 00 00 
 7017   661E   00 00 70 70 00 	C3A	DB	00,00,70,70,00,70,70,00,00 ;: 4
        6623   70 70 00 00 
 7018   6627   00 00 38 38 00 	C3B	DB	00,00,38,38,00,38,38,18,70 ;; 5
        662C   38 38 18 70 
 7019   6630   00 0E 38 E0 38 	C3C	DB	00,0e,38,e0,38,0e,00,00,00 ;< 8
        6635   0E 00 00 00 
 7020   6639   00 00 7F 00 7F 	C3D	DB	00,00,7f,00,7f,00,00,00,00 ;= 8
        663E   00 00 00 00 
 7021   6642   00 70 1C 07 1C 	C3E	DB	00,70,1c,07,1c,70,00,00,00 ;> 8
        6647   70 00 00 00 
 7022   664B   3F 80 71 C0 03 	C3F	DB	3f,80,71,c0,03,80,0e,00,0e,00,00,00,0e,00,00,00,00,00 ;? 10
        6650   80 0E 00 0E 00 
        6655   00 00 0E 00 00 
        665A   00 00 00 
 7023   665D   1F F8 E0 0E E3 	C40	DB	1f,f8,e0,0e,e3,e7,e6,77,e6,77,e3,bc,e0,00,1f,f8,00,00 ;@ 16
        6662   E7 E6 77 E6 77 
        6667   E3 BC E0 00 1F 
        666C   F8 00 00 
 7024   666F   3F 80 71 C0 71 	C41	DB	3f,80,71,c0,71,c0,7f,c0,71,c0,71,c0,71,c0,00,00,00,00 ;A 10
        6674   C0 7F C0 71 C0 
        6679   71 C0 71 C0 00 
        667E   00 00 00 
 7025   6681   7F 80 71 C0 71 	C42	DB	7f,80,71,c0,71,c0,7f,00,71,c0,71,c0,7f,80,00,00,00,00 ;B 10
        6686   C0 7F 00 71 C0 
        668B   71 C0 7F 80 00 
        6690   00 00 00 
 7026   6693   3F 80 71 C0 70 	C43	DB	3f,80,71,c0,70,00,70,00,70,00,71,c0,3f,80,00,00,00,00 ;C 10
        6698   00 70 00 70 00 
        669D   71 C0 3F 80 00 
        66A2   00 00 00 
 7027   66A5   7F 80 71 C0 71 	C44	DB	7f,80,71,c0,71,c0,71,c0,71,c0,71,c0,7f,80,00,00,00,00 ;D 10
        66AA   C0 71 C0 71 C0 
        66AF   71 C0 7F 80 00 
        66B4   00 00 00 
 7028   66B7   7F 70 70 7F 70 	C45	DB	7f,70,70,7f,70,70,7f,00,00 ;E 8
        66BC   70 7F 00 00 
 7029   66C0   7F 70 70 7E 70 	C46	DB	7f,70,70,7e,70,70,70,00,00 ;F 8
        66C5   70 70 00 00 
 7030   66C9   3F 80 71 C0 70 	C47	DB	3f,80,71,c0,70,00,73,c0,71,c0,71,c0,3f,80,00,00,00,00 ;G 10
        66CE   00 73 C0 71 C0 
  Wed May 24 1989 15:00                                                                                                  Page  104

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        66D3   71 C0 3F 80 00 
        66D8   00 00 00 
 7031   66DB   71 C0 71 C0 71 	C48	DB	71,c0,71,c0,71,c0,7f,c0,71,c0,71,c0,71,c0,00,00,00,00 ;H 10
        66E0   C0 7F C0 71 C0 
        66E5   71 C0 71 C0 00 
        66EA   00 00 00 
 7032   66ED   70 70 70 70 70 	C49	DB	70,70,70,70,70,70,70,00,00 ;I 4
        66F2   70 70 00 00 
 7033   66F6   01 C0 01 C0 01 	C4A	DB	01,c0,01,c0,01,c0,01,c0,71,c0,71,c0,3f,80,00,00,00,00 ;J 10
        66FB   C0 01 C0 71 C0 
        6700   71 C0 3F 80 00 
        6705   00 00 00 
 7034   6708   70 E0 71 C0 73 	C4B	DB	70,e0,71,c0,73,80,7f,00,73,80,71,c0,70,e0,00,00,00,00 ;K 11
        670D   80 7F 00 73 80 
        6712   71 C0 70 E0 00 
        6717   00 00 00 
 7035   671A   70 70 70 70 70 	C4C	DB	70,70,70,70,70,70,7f,00,00 ;L 8
        671F   70 7F 00 00 
 7036   6723   78 3C 7C 7C 7E 	C4D	DB	78,3c,7c,7c,7e,fc,77,dc,73,9c,70,1c,70,1c,00,00,00,00 ;M 14
        6728   FC 77 DC 73 9C 
        672D   70 1C 70 1C 00 
        6732   00 00 00 
 7037   6735   78 70 7C 70 7E 	C4E	DB	78,70,7c,70,7e,70,77,70,73,f0,71,f0,70,f0,00,00,00,00 ;N 12
        673A   70 77 70 73 F0 
        673F   71 F0 70 F0 00 
        6744   00 00 00 
 7038   6747   3F 80 71 C0 71 	C4F	DB	3f,80,71,c0,71,c0,71,c0,71,c0,71,c0,3f,80,00,00,00,00 ;O 10
        674C   C0 71 C0 71 C0 
        6751   71 C0 3F 80 00 
        6756   00 00 00 
 7039   6759   7F 80 71 C0 71 	C50	DB	7f,80,71,c0,71,c0,7f,80,70,00,70,00,70,00,00,00,00,00 ;P 10
        675E   C0 7F 80 70 00 
        6763   70 00 70 00 00 
        6768   00 00 00 
 7040   676B   3F 80 71 C0 71 	C51	DB	3f,80,71,c0,71,c0,71,c0,71,c0,71,c0,3f,00,03,c0,00,00 ;Q 10
        6770   C0 71 C0 71 C0 
        6775   71 C0 3F 00 03 
        677A   C0 00 00 
 7041   677D   7F 80 71 C0 71 	C52	DB	7f,80,71,c0,71,c0,7f,00,71,c0,71,c0,71,c0,00,00,00,00 ;R 10
        6782   C0 7F 00 71 C0 
        6787   71 C0 71 C0 00 
        678C   00 00 00 
 7042   678F   3F 80 71 C0 78 	C53	DB	3f,80,71,c0,78,00,1f,00,03,c0,71,c0,3f,80,00,00,00,00 ;S 10
        6794   00 1F 00 03 C0 
        6799   71 C0 3F 80 00 
        679E   00 00 00 
 7043   67A1   7F C0 0E 00 0E 	C54	DB	7f,c0,0e,00,0e,00,0e,00,0e,00,0e,00,0e,00,00,00,00,00 ;T 10
        67A6   00 0E 00 0E 00 
        67AB   0E 00 0E 00 00 
        67B0   00 00 00 
 7044   67B3   71 C0 71 C0 71 	C55	DB	71,c0,71,c0,71,c0,71,c0,71,c0,71,c0,1f,00,00,00,00,00 ;U 10
        67B8   C0 71 C0 71 C0 
        67BD   71 C0 1F 00 00 
        67C2   00 00 00 
 7045   67C5   71 C0 71 C0 71 	C56	DB	71,c0,71,c0,71,c0,71,c0,73,80,77,00,7e,00,00,00,00,00 ;V 10
        67CA   C0 71 C0 73 80 
        67CF   77 00 7E 00 00 
        67D4   00 00 00 
 7046   67D7   71 C7 71 C7 71 	C57	DB	71,c7,71,c7,71,c7,71,c7,71,c7,71,dc,7f,f8,00,00,00,00 ;W 16
        67DC   C7 71 C7 71 C7 
        67E1   71 DC 7F F8 00 
        67E6   00 00 00 
 7047   67E9   71 C0 71 C0 71 	C58	DB	71,c0,71,c0,71,c0,1f,00,71,c0,71,c0,71,c0,00,00,00,00 ;X 10
        67EE   C0 1F 00 71 C0 
        67F3   71 C0 71 C0 00 
        67F8   00 00 00 
 7048   67FB   71 C0 71 C0 71 	C59	DB	71,c0,71,c0,71,c0,3f,80,0e,00,0e,00,0e,00,00,00,00,00 ;Y 10
        6800   C0 3F 80 0E 00 
        6805   0E 00 0E 00 00 
        680A   00 00 00 
 7049   680D   7F C0 01 C0 03 	C5A	DB	7f,c0,01,c0,03,80,0e,00,38,00,70,00,7f,c0,00,00,00,00 ;Z 10
        6812   80 0E 00 38 00 
        6817   70 00 7F C0 00 
        681C   00 00 00 
 7050   681F   7F 70 70 70 70 	C5B	DB	7f,70,70,70,70,70,7f,00,00 ;[ 8
  Wed May 24 1989 15:00                                                                                                  Page  105

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6824   70 7F 00 00 
 7051   6828   70 00 38 00 1C 	C5C	DB	70,00,38,00,1c,00,0e,00,07,00,03,80,01,c0,00,00,00,00 ;\ 10
        682D   00 0E 00 07 00 
        6832   03 80 01 C0 00 
        6837   00 00 00 
 7052   683A   7F 07 07 07 07 	C5D	DB	7f,07,07,07,07,07,7f,00,00 ;] 8
        683F   07 7F 00 00 
 7053   6843   00 00 0C 00 3F 	C5E	DB	00,00,0c,00,3f,00,e1,c0,00,00,00,00,00,00,00,00,00,00 ;^ 10
        6848   00 E1 C0 00 00 
        684D   00 00 00 00 00 
        6852   00 00 00 
 7054   6855   00 00 00 00 00 	C5F	DB	00,00,00,00,00,00,00,ff,00 ;_ 8
        685A   00 00 FF 00 
 7055   685E   70 38 1C 00 00 	C60	DB	70,38,1c,00,00,00,00,00,00 ;` 6
        6863   00 00 00 00 
 7056   6867   00 00 00 00 3F 	C61	DB	00,00,00,00,3f,80,01,c0,3f,c0,71,c0,3f,c0,00,00,00,00 ;a 10
        686C   80 01 C0 3F C0 
        6871   71 C0 3F C0 00 
        6876   00 00 00 
 7057   6879   70 00 70 00 7F 	C62	DB	70,00,70,00,7f,80,71,c0,71,c0,71,c0,7f,80,00,00,00,00 ;b 10
        687E   80 71 C0 71 C0 
        6883   71 C0 7F 80 00 
        6888   00 00 00 
 7058   688B   00 00 00 00 3F 	C63	DB	00,00,00,00,3f,80,71,c0,70,00,71,c0,3f,80,00,00,00,00 ;c 10
        6890   80 71 C0 70 00 
        6895   71 C0 3F 80 00 
        689A   00 00 00 
 7059   689D   01 C0 01 C0 3F 	C64	DB	01,c0,01,c0,3f,c0,71,c0,71,c0,71,c0,3f,c0,00,00,00,00 ;d 10
        68A2   C0 71 C0 71 C0 
        68A7   71 C0 3F C0 00 
        68AC   00 00 00 
 7060   68AF   00 00 00 00 3F 	C65	DB	00,00,00,00,3f,80,79,c0,7f,c0,70,00,3f,80,00,00,00,00 ;e 10
        68B4   80 79 C0 7F C0 
        68B9   70 00 3F 80 00 
        68BE   00 00 00 
 7061   68C1   0F 1C 7F 1C 1C 	C66	DB	0f,1c,7f,1c,1c,1c,1c,00,00 ;f 8
        68C6   1C 1C 00 00 
 7062   68CA   00 00 00 00 3F 	C67	DB	00,00,00,00,3f,c0,71,c0,71,c0,71,c0,3f,c0,01,c0,3f,80 ;g 10
        68CF   C0 71 C0 71 C0 
        68D4   71 C0 3F C0 01 
        68D9   C0 3F 80 
 7063   68DC   70 00 70 00 7F 	C68	DB	70,00,70,00,7f,80,71,c0,71,c0,71,c0,71,c0,00,00,00,00 ;h 10
        68E1   80 71 C0 71 C0 
        68E6   71 C0 71 C0 00 
        68EB   00 00 00 
 7064   68EE   70 00 70 70 70 	C69	DB	70,00,70,70,70,70,70,00,00 ;i 5
        68F3   70 70 00 00 
 7065   68F7   0E 00 0E 0E 0E 	C6A	DB	0e,00,0e,0e,0e,0e,0e,0e,7c ;j 8
        68FC   0E 0E 0E 7C 
 7066   6900   70 00 70 00 71 	C6B	DB	70,00,70,00,71,c0,73,80,7f,00,73,80,71,c0,00,00,00,00 ;k 10
        6905   C0 73 80 7F 00 
        690A   73 80 71 C0 00 
        690F   00 00 00 
 7067   6912   70 70 70 70 70 	C6C	DB	70,70,70,70,70,70,70,00,00 ;l 5
        6917   70 70 00 00 
 7068   691B   00 00 00 00 7F 	C6D	DB	00,00,00,00,7f,fc,73,9c,73,9c,73,9c,73,9c,00,00,00,00 ;m 14
        6920   FC 73 9C 73 9C 
        6925   73 9C 73 9C 00 
        692A   00 00 00 
 7069   692D   00 00 00 00 7F 	C6E	DB	00,00,00,00,7f,80,71,c0,71,c0,71,c0,71,c0,00,00,00,00 ;n 10
        6932   80 71 C0 71 C0 
        6937   71 C0 71 C0 00 
        693C   00 00 00 
 7070   693F   00 00 00 00 3F 	C6F	DB	00,00,00,00,3f,80,71,c0,71,c0,71,c0,3f,80,00,00,00,00 ;o 10
        6944   80 71 C0 71 C0 
        6949   71 C0 3F 80 00 
        694E   00 00 00 
 7071   6951   00 00 00 00 7F 	C70	DB	00,00,00,00,7f,80,71,c0,71,c0,71,c0,7f,80,70,00,70,00 ;p 10
        6956   80 71 C0 71 C0 
        695B   71 C0 7F 80 70 
        6960   00 70 00 
 7072   6963   00 00 00 00 3F 	C71	DB	00,00,00,00,3f,80,71,c0,71,c0,71,c0,3f,c0,01,c0,01,c0 ;q 10
        6968   80 71 C0 71 C0 
        696D   71 C0 3F C0 01 
        6972   C0 01 C0 
  Wed May 24 1989 15:00                                                                                                  Page  106

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

 7073   6975   00 00 77 7C 70 	C72	DB	00,00,77,7c,70,70,70,00,00 ;r 8
        697A   70 70 00 00 
 7074   697E   00 00 00 00 3F 	C73	DB	00,00,00,00,3f,00,70,00,1e,00,03,80,3f,00,00,00,00,00 ;s 9
        6983   00 70 00 1E 00 
        6988   03 80 3F 00 00 
        698D   00 00 00 
 7075   6990   1C 1C 7F 1C 1C 	C74	DB	1c,1c,7f,1c,1c,1c,0f,00,00 ;t 8
        6995   1C 0F 00 00 
 7076   6999   00 00 00 00 71 	C75	DB	00,00,00,00,71,c0,71,c0,71,c0,71,c0,3f,c0,00,00,00,00 ;u 10
        699E   C0 71 C0 71 C0 
        69A3   71 C0 3F C0 00 
        69A8   00 00 00 
 7077   69AB   00 00 00 00 71 	C76	DB	00,00,00,00,71,c0,71,c0,73,80,77,00,7e,00,00,00,00,00 ;v 10
        69B0   C0 71 C0 73 80 
        69B5   77 00 7E 00 00 
        69BA   00 00 00 
 7078   69BD   00 00 00 00 73 	C77	DB 	00,00,00,00,73,9c,73,9c,73,9c,73,9c,7f,f8,00,00,00,00 ;w 14
        69C2   9C 73 9C 73 9C 
        69C7   73 9C 7F F8 00 
        69CC   00 00 00 
 7079   69CF   00 00 00 00 71 	C78	DB	00,00,00,00,71,c0,71,c0,1f,00,71,c0,71,c0,00,00,00,00 ;x 10
        69D4   C0 71 C0 1F 00 
        69D9   71 C0 71 C0 00 
        69DE   00 00 00 
 7080   69E1   00 00 00 00 71 	C79	DB	00,00,00,00,71,c0,71,c0,71,c0,71,c0,3f,c0,01,c0,3f,80 ;y 10
        69E6   C0 71 C0 71 C0 
        69EB   71 C0 3F C0 01 
        69F0   C0 3F 80 
 7081   69F3   00 00 00 00 7F 	C7A	DB	00,00,00,00,7f,c0,03,80,0e,00,38,00,7f,c0,00,00,00,00 ;z 10
        69F8   C0 03 80 0E 00 
        69FD   38 00 7F C0 00 
        6A02   00 00 00 
 7082   6A05   1F 38 38 F0 38 	C7B	DB	1f,38,38,f0,38,38,1f,00,00 ;} 8
        6A0A   38 1F 00 00 
 7083   6A0E   70 70 70 70 70 	C7C	DB	70,70,70,70,70,70,70,70,70 ;| 5
        6A13   70 70 70 70 
 7084   6A17   F8 1C 1C 0F 1C 	C7D	DB	f8,1c,1c,0f,1c,1c,f8,00,00 ;} 8
        6A1C   1C F8 00 00 
 7085   6A20   00 00 00 00 3C 	C7E	DB	00,00,00,00,3c,e0,e7,80,00,00,00,00,00,00,00,00,00,00 ;~ 11
        6A25   E0 E7 80 00 00 
        6A2A   00 00 00 00 00 
        6A2F   00 00 00 
 7086                      	;
 7087                      	; base addresses for the screen lines
 7088                      	;	
 7089   6A32               	BASEL:
 7090   6A32   00 00 00 00 00 		DB	00,00,00,00,00,00,00,00
        6A37   00 00 00 
 7091   6A3A   80 80 80 80 80 		DB	80,80,80,80,80,80,80,80
        6A3F   80 80 80 
 7092   6A42   00 00 00 00 00 		DB	00,00,00,00,00,00,00,00
        6A47   00 00 00 
 7093   6A4A   80 80 80 80 80 		DB	80,80,80,80,80,80,80,80
        6A4F   80 80 80 
 7094   6A52   00 00 00 00 00 		DB	00,00,00,00,00,00,00,00
        6A57   00 00 00 
 7095   6A5A   80 80 80 80 80 		DB	80,80,80,80,80,80,80,80
        6A5F   80 80 80 
 7096   6A62   00 00 00 00 00 		DB	00,00,00,00,00,00,00,00
        6A67   00 00 00 
 7097   6A6A   80 80 80 80 80 		DB	80,80,80,80,80,80,80,80
        6A6F   80 80 80 
 7098   6A72   28 28 28 28 28 		DB	28,28,28,28,28,28,28,28
        6A77   28 28 28 
 7099   6A7A   A8 A8 A8 A8 A8 		DB	A8,A8,A8,A8,A8,A8,A8,A8
        6A7F   A8 A8 A8 
 7100   6A82   28 28 28 28 28 		DB	28,28,28,28,28,28,28,28
        6A87   28 28 28 
 7101   6A8A   A8 A8 A8 A8 A8 		DB	A8,A8,A8,A8,A8,A8,A8,A8
        6A8F   A8 A8 A8 
 7102   6A92   28 28 28 28 28 		DB	28,28,28,28,28,28,28,28
        6A97   28 28 28 
 7103   6A9A   A8 A8 A8 A8 A8 		DB	A8,A8,A8,A8,A8,A8,A8,A8
        6A9F   A8 A8 A8 
 7104   6AA2   28 28 28 28 28 		DB	28,28,28,28,28,28,28,28
  Wed May 24 1989 15:00                                                                                                  Page  107

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6AA7   28 28 28 
 7105   6AAA   A8 A8 A8 A8 A8 		DB	A8,A8,A8,A8,A8,A8,A8,A8
        6AAF   A8 A8 A8 
 7106   6AB2   50 50 50 50 50 		DB	50,50,50,50,50,50,50,50
        6AB7   50 50 50 
 7107   6ABA   D0 D0 D0 D0 D0 		DB	D0,D0,D0,D0,D0,D0,D0,D0
        6ABF   D0 D0 D0 
 7108   6AC2   50 50 50 50 50 		DB	50,50,50,50,50,50,50,50
        6AC7   50 50 50 
 7109   6ACA   D0 D0 D0 D0 D0 		DB	D0,D0,D0,D0,D0,D0,D0,D0
        6ACF   D0 D0 D0 
 7110   6AD2   50 50 50 50 50 		DB	50,50,50,50,50,50,50,50
        6AD7   50 50 50 
 7111   6ADA   D0 D0 D0 D0 D0 		DB	D0,D0,D0,D0,D0,D0,D0,D0
        6ADF   D0 D0 D0 
 7112   6AE2   50 50 50 50 50 		DB	50,50,50,50,50,50,50,50
        6AE7   50 50 50 
 7113   6AEA   D0 D0 D0 D0 D0 		DB	D0,D0,D0,D0,D0,D0,D0,D0
        6AEF   D0 D0 D0 
 7114   6AF2               	BASEH:
 7115   6AF2   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6AF7   34 38 3C 
 7116   6AFA   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6AFF   34 38 3C 
 7117   6B02   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B07   35 39 3D 
 7118   6B0A   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B0F   35 39 3D 
 7119   6B12   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B17   36 3A 3E 
 7120   6B1A   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B1F   36 3A 3E 
 7121   6B22   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6B27   37 3B 3F 
 7122   6B2A   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6B2F   37 3B 3F 
 7123   6B32   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B37   34 38 3C 
 7124   6B3A   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B3F   34 38 3C 
 7125   6B42   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B47   35 39 3D 
 7126   6B4A   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B4F   35 39 3D 
 7127   6B52   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B57   36 3A 3E 
 7128   6B5A   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B5F   36 3A 3E 
 7129   6B62   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6B67   37 3B 3F 
 7130   6B6A   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6B6F   37 3B 3F 
 7131   6B72   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B77   34 38 3C 
 7132   6B7A   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B7F   34 38 3C 
 7133   6B82   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B87   35 39 3D 
 7134   6B8A   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B8F   35 39 3D 
 7135   6B92   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B97   36 3A 3E 
 7136   6B9A   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B9F   36 3A 3E 
 7137   6BA2   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6BA7   37 3B 3F 
 7138   6BAA   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6BAF   37 3B 3F 
 7139                      	;
 7140                      	; this gives the bit offset for each one
 7141                      	;
 7142   6BB2               	XBITTBL:
 7143   6BB2   00          		DB	0
 7144   6BB3   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BB8   03 00 
  Wed May 24 1989 15:00                                                                                                  Page  108

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

 7145   6BBA   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BBF   03 00 
 7146   6BC1   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BC6   03 00 
 7147   6BC8   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BCD   03 00 
 7148   6BCF   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BD4   03 00 
 7149   6BD6   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BDB   03 00 
 7150   6BDD   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BE2   03 00 
 7151   6BE4   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BE9   03 00 
 7152   6BEB   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BF0   03 00 
 7153   6BF2   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BF7   03 00 
 7154   6BF9   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BFE   03 00 
 7155   6C00   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C05   03 00 
 7156   6C07   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C0C   03 00 
 7157   6C0E   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C13   03 00 
 7158   6C15   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C1A   03 00 
 7159   6C1C   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C21   03 00 
 7160   6C23   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C28   03 00 
 7161   6C2A   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C2F   03 00 
 7162   6C31   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C36   03 00 
 7163   6C38   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C3D   03 00 
 7164                      		RADIX	D
 7165   6C3F   00 01 06 07 0C 	ZIPCOLOR: db	0,1,6,7,$C,$B,$E,$F
        6C44   0B 0E 0F 
 7166   6C47   02 03 FF FF FF 	APLCOLOR: db    2,3,$FF,$FF,$FF,$FF,4,5,$FF,$FF,$FF,7,$FF,$FF,8,9
        6C4C   FF 04 05 FF FF 
        6C51   FF 07 FF FF 08 
        6C56   09 
 7167   6C57               	OLDZV:
 7168                      	;
 7169                      	; Variables that used to be in the zero page but got moved out
 7170                      	;
 7171          6C57        	PSVFLG	EQU	OLDZV		; (BYTE) PRESERVE FLAG FOR LEX 0=DON'T 1=DO
 7172          6C58        	VOCFLG	EQU	PSVFLG+1	; (BYTE) WHICH VOC TBL, 0=NORMAL 1= ARG3
 7173          6C59        	DBLOCK	EQU	VOCFLG+1	; (WORD) Z-BLOCK TO READ
 7174          6C5B        	QUOT	EQU	DBLOCK+2	; (WORD) QUOTIENT FOR DIVISION
 7175          6C5D        	REMAIN	EQU	QUOT+2		; (WORD) REMAINDER FOR DIVISION
 7176          6C5F        	QSIGN	EQU	REMAIN+2	; (BYTE) SIGN OF QUOTIENT
 7177          6C60        	RSIGN	EQU	QSIGN+1		; (BYTE) SIGN OF REMAINDER
 7178          6C61        	DIGITS	EQU	RSIGN+1		; (BYTE) DIGIT COUNT FOR "PRINTN"
 7179          6C62        	OLDLEN	EQU	DIGITS+1	; (BYTE) OLD LINE LENGTH
 7180          6C63        	OLDEND	EQU	OLDLEN+1	; (BYTE) OLD LAST CHAR IN [LBUFF]
 7181          6C64        	SPSTAT	EQU	OLDEND+1	; (BYTE) SPLIT SCREEN STATUS FLAG
 7182          6C65        	LFROM	EQU	SPSTAT+1	; (WORD) "FROM" LINE ADDRESS
 7183          6C67        	LTO	EQU	LFROM+2		; (WORD) "TO" LINE ADDRESS
 7184          6C69        	PRLEN	EQU	LTO+2		; (BYTE) SCRIPT LINE LENGTH
 7185          6C6A        	GPOSIT	EQU	PRLEN+1		; (BYTE) DEFAULT SAVE POSITION
 7186          6C6B        	GDRIVE	EQU	GPOSIT+1	; (BYTE) DEFAULT SAVE DRIVE
 7187          6C6C        	TPOSIT	EQU	GDRIVE+1	; (BYTE) TEMP SAVE POSITION
 7188          6C6D        	TDRIVE	EQU	TPOSIT+1	; (BYTE) TEMP SAVE DRIVE
 7189          6C6E        	TSLOT	EQU	TDRIVE+1	; (BYTE) TEMP SAVE SLOT
 7190          6C6F        	DRIVE	EQU	TSLOT+1		; (BYTE) CURRENT DRIVE
 7191          6C70        	SIDEFLG	EQU	DRIVE+1		; (BYTE) which disk side are we on
 7192          6C71        	SRHOLD	EQU	SIDEFLG+1	; (WORD) <>0 if doing sequential random
 7193          6C73        	SCRIPTF	EQU	SRHOLD+2	; (BYTE) DIROUT FLAG FOR PRINTER OUTPUT
 7194          6C74        	SCRIPTFLG EQU	SCRIPTF+1	; (BYTE) Does window allow scripting?
 7195          6C75        	OLDZSP	EQU	SCRIPTFLG+1	; (WORD)
 7196          6C77        	CURSFLG	EQU	OLDZSP+2	; (BYTE) 1==New cursor X for DLINE
  Wed May 24 1989 15:00                                                                                                  Page  109

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

 7197          6C78        	DBLK	EQU	CURSFLG+1	; (WORD)
 7198          6C7A        	RDTBL1	EQU	DBLK+2		; (WORD) READ TABLE 1 (Game Relative)
 7199          6C7C        	RDTBL2	EQU	RDTBL1+2	; (WORD) READ TABLE 2
 7200          6C7E        	NENTS	EQU	RDTBL2+2	; (WORD) # ENTRIES IN VOCAB TABLE
 7201          6C80        	DIRITM	EQU	NENTS+2		; (WORD) OFFSET IN OUTPUT TBL (DIRTBL)
 7202          6C82        	DIRCNT	EQU	DIRITM+2	; (WORD) COUNT OF CHARS IN TBL (DIRTBL)
 7203          6C84        	SVTCHAR EQU	DIRCNT+2	; (WORD) Old TCHARS table address
 7204          6C86        	VOCMPC	EQU	SVTCHAR+2	; (3 BYTES) Save for vocabulary MPC
 7205          6C89        	VCESVE	EQU	VOCMPC+3	; (3 BYTES) Save for VOCEND
 7206          6C8C        	VWLSVE	EQU	VCESVE+3	; (3 BYTES) Save for VOCLEN
 7207          6C8F        	DIDVTBL	EQU	VWLSVE+3	; (BYTE) <>0 if we have done default table
 7208          6C90        	IN	EQU	DIDVTBL+1	; (9 BYTES) INPUT BUFFER
 7209          6C99        	OUT	EQU	IN+9		; (9 BYTES) OUTPUT BUFFER
 7210          6CA2        	CURSOR_OFF EQU  OUT+9           ; (BYTE) ==1 if char cursor not to be on
 7211          6CA3        	CRLF_CHECK EQU    CURSOR_OFF+1    ; (BYTE) ==1 to do CRLF function check
 7212          6CA4        	PTR_COUNT EQU   CRLF_CHECK+1      ; (BYTE) ==0 if checking pointer movement
 7213          6CA5        	INFODOS_END EQU PTR_COUNT+1     ; (WORD) last segment of infodos special
 7214          0050        	OLDZVLEN EQU 	INFODOS_END-PSVFLG+2	; this is how much to reserve
 7215                      	
 7216   6C57               		BLKB	OLDZVLEN,0	; and zero it out
 7217                      	
 7218                      	; ------------------
 7219                      	; ERROR MESSAGE STRINGS
 7220                      	; ------------------
 7221   6CA7   0E          	E27:	db	E27L
 7222   6CA8   44 69 73 6B 20 		db	"Disk I/O Error"
        6CAD   49 2F 4F 20 45 
        6CB2   72 72 6F 72 
 7223          000E        	E27L	EQU	$-E27-1
 7224   6CB6   14          	E2B:	db	E2BL
 7225   6CB7   44 69 73 6B 20 		db	"Disk write protected"
        6CBC   77 72 69 74 65 
        6CC1   20 70 72 6F 74 
        6CC6   65 63 74 65 64 
 7226          0014        	E2BL	EQU	$-E2B-1
 7227   6CCB   0C          	E40:	db	E40L
 7228   6CCC   42 61 64 20 46 		db	"Bad Filename"
        6CD1   69 6C 65 6E 61 
        6CD6   6D 65 
 7229          000C        	E40L	EQU	$-E40-1
 7230   6CD8   0E          	E44:	db	E44L
 7231   6CD9   50 61 74 68 20 		db	"Path not found"
        6CDE   6E 6F 74 20 66 
        6CE3   6F 75 6E 64 
 7232          000E        	E44L:	EQU	$-E44-1
 7233   6CE7   10          	E45:	db	E45L
 7234   6CE8   56 6F 6C 75 6D 		db	"Volume not found"
        6CED   65 20 6E 6F 74 
        6CF2   20 66 6F 75 6E 
        6CF7   64 
 7235          0010        	E45L	EQU	$-E45-1
 7236   6CF8   0E          	E46:	db	E46L
 7237   6CF9   46 69 6C 65 20 		db	"File Not Found"
        6CFE   4E 6F 74 20 46 
        6D03   6F 75 6E 64 
 7238          000E        	E46L	EQU	$-E46-1
 7239   6D07   09          	E48:	db	E48L
 7240   6D08   44 69 73 6B 20 		db	"Disk Full"
        6D0D   46 75 6C 6C 
 7241          0009        	E48L	EQU	$-E48-1
 7242   6D11   21          	E49:    db      E49L
 7243   6D12   4C 61 6E 65 44 	        db      "LaneDOS limit: 12 files/directory"
        6D17   4F 53 20 6C 69 
        6D1C   6D 69 74 3A 20 
        6D21   31 32 20 66 69 
        6D26   6C 65 73 2F 64 
        6D2B   69 72 65 63 74 
        6D30   6F 72 79 
 7244          0021        	E49L    EQU     $-E49-1
 7245   6D33   26          	E4E:    db      E4EL
 7246   6D34   4C 61 6E 65 44 	        db      "LaneDOS limit: No writes to TREE files"
        6D39   4F 53 20 6C 69 
        6D3E   6D 69 74 3A 20 
        6D43   4E 6F 20 77 72 
        6D48   69 74 65 73 20 
  Wed May 24 1989 15:00                                                                                                  Page  110

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6D4D   74 6F 20 54 52 
        6D52   45 45 20 66 69 
        6D57   6C 65 73 
 7247          0026        	E4EL    EQU     $-E4E-1
 7248   6D5A   0E          	E4C:	db	E4CL
 7249   6D5B   55 6E 65 78 70 		db	"Unexpected EOF"
        6D60   65 63 74 65 64 
        6D65   20 45 4F 46 
 7250          000E        	E4CL	EQU	$-E4C-1
 7251                      	
 7252   6D69   27          	ELIST:	db	$27
 7253   6D6A   A76C        		dw	E27
 7254   6D6C   2B          		db	$2B
 7255   6D6D   B66C        		dw	E2B
 7256   6D6F   40          		db	$40
 7257   6D70   CB6C        		dw	E40
 7258   6D72   44          		db	$44
 7259   6D73   D86C        		dw	E44
 7260   6D75   45          		db	$45
 7261   6D76   E76C        		dw	E45
 7262   6D78   46          		db	$46
 7263   6D79   F86C        		dw	E46
 7264   6D7B   48          		db	$48
 7265   6D7C   076D        		dw	E48
 7266   6D7E   49          	        db      $49
 7267   6D7F   116D        	        dw      E49
 7268   6D81   4C          		db	$4C
 7269   6D82   5A6D        		dw	E4C
 7270   6D84   4E          	        db      $4E
 7271   6D85   336D        	        dw      E4E
 7272          001B        	ELISTL	EQU	$-ELIST-3	; mark last error code
 7273                      	
 7274   6D87               		END
 7275                      	
 7276   6D87               		INCLUDE		WINDOWS.ASM
 7277                      	
 7278   6D87               		STTL	"--- WINDOW OPERATIONS ---"
 7279                      		PAGE
  Wed May 24 1989 15:00                                                                                                  Page  111

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7280                      	;
 7281                      	; these are the data structures for all 8 WINDOW.  They are identical and
 7282                      	; are just seperated cuz I use the addresses in the table that follows.
 7283                      	;	All numbers are inclusive, absolute, and zero-based.
 7284                      	;
 7285          0000        	WINDSTRUCT	EQU	0
 7286          0000        	WINTOP 		EQU	WINDSTRUCT	; first line of the window
 7287          0001        	WINLEFT 	EQU	WINTOP+1	; left edge of the window
 7288          0002        	WINHGHT		EQU	WINLEFT+1	; height of the window
 7289          0003        	WINWID		EQU	WINHGHT+1	; width of the window, in pixels
 7290          0004        	WINY		EQU	WINWID+1	; y pos of cursor (pos, not relative)
 7291          0005        	WINX		EQU	WINY+1		; x pos of cursor (remember, ABSOLUTE)
 7292          0006        	WINLM		EQU	WINX+1		; left margin
 7293          0007        	WINRM		EQU	WINLM+1		; right margin
 7294          0008        	WINCRF		EQU	WINRM+1		; (WORD) <CR> function
 7295          000A        	WINCRC		EQU	WINCRF+2	; (WORD) <CR> counter
 7296          000C        	WINHIGHL	EQU	WINCRC+2	; highlight mode
 7297          000D        	WINFORE		EQU	WINHIGHL+1	; foreground color (0=black-7=white)
 7298          000E        	WINBGND		EQU	WINFORE+1	; background color (0=black-7=white)
 7299          000F        	WINFONT		EQU	WINBGND+1	; window font (0=normal/4=monospaced)
 7300          0010        	WINFSIZE	EQU	WINFONT+1	; (WORD) font Height/Width
 7301          0012        	WINATR		EQU	WINFSIZE+2	; Window Attributes
 7302          0013        	WINLCNT		EQU	WINATR+1	; current number of lines
 7303                      	;
 7304                      	; these are my interesting things
 7305                      	;
 7306          0014        	WINXSZ		EQU	WINLCNT+1	; width of window, in pixels, using margin
 7307          0015        	WINLLEN		EQU	WINXSZ+1	; length of current line
 7308          0017        	WINLINES	EQU	WINLLEN+2	; max # of lines for window
 7309                      	
 7310   6D87               	WINDOW0:
 7311   6D87   00          		DB	0		; WINTOP - first line of the window
 7312   6D88   00          		DB	0		; WINLEFT - left edge of the window
 7313   6D89   C0          		DB	MAXHEIGHT	; WINHGHT - height of window
 7314   6D8A   8C          		DB	MAXWIDTH	; WINWID - width of window
 7315   6D8B   00          		DB	0		; WINY - y pos of cursor (pos, not relative)
 7316   6D8C   00          		DB	0		; WINX - x pos of cursor (remember, ABSOLUTE)
 7317   6D8D   00          		DB	0		; WINLM - left margin
 7318   6D8E   00          		DB	0		; WINRM - right margin
 7319   6D8F   0000        		DW	0		; WINCRF - <CR> function
 7320   6D91   0000        		DW	0		; WINCRC - <CR> counter
 7321   6D93   00          		DB	0		; WINHIGHL - Highlights
 7322   6D94   0F          		DB	$f		; WINFORE - foreground color default of white
 7323   6D95   00          		DB	0		; WINBGND - background color
 7324   6D96   00          		DB	0		; WINFONT - window font (0=normal/1=alternate)
 7325   6D97   02 09       		DB	2,FONT_H	; WINFSIZE - Width/Height
 7326   6D99   0F          		DB	$0f		; WINATR - all attributes on for window 0
 7327   6D9A   00          		DB	0		; WINLCNT - current number of lines
 7328   6D9B   8C          		DB	MAXWIDTH	; WINXSZ - width of window, in pixels, using margin
 7329   6D9C   00 00       		DB	0,0		; WINLLEN - length of current line
 7330   6D9E   14          		DB	(MAXHEIGHT/FONT_H)-1 ; WINLINES - max # of lines for window
 7331                      	;
 7332                      	; same start as window 0, but with 0 length
 7333                      	;
 7334   6D9F               	WINDOW1:
 7335   6D9F   00 00 00 8C 00 		DB	0,0,0,MAXWIDTH,0,0,0,0,0,0,0,0,0
        6DA4   00 00 00 00 00 
        6DA9   00 00 00 
 7336   6DAC   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,MAXWIDTH,0,0,0
        6DB1   08 00 8C 00 00 
        6DB6   00 
 7337                      	;
 7338                      	; the rest have no width/height/attributes (except buffering)
 7339                      	;
 7340   6DB7               	WINDOW2:
 7341   6DB7   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6DBC   00 00 00 00 00 
        6DC1   00 00 00 
 7342   6DC4   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6DC9   08 00 00 00 00 
        6DCE   00 
 7343   6DCF               	WINDOW3:
 7344   6DCF   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6DD4   00 00 00 00 00 
        6DD9   00 00 00 
  Wed May 24 1989 15:00                                                                                                  Page  112

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7345   6DDC   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6DE1   08 00 00 00 00 
        6DE6   00 
 7346   6DE7               	WINDOW4:
 7347   6DE7   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6DEC   00 00 00 00 00 
        6DF1   00 00 00 
 7348   6DF4   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6DF9   08 00 00 00 00 
        6DFE   00 
 7349   6DFF               	WINDOW5:
 7350   6DFF   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6E04   00 00 00 00 00 
        6E09   00 00 00 
 7351   6E0C   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6E11   08 00 00 00 00 
        6E16   00 
 7352   6E17               	WINDOW6:
 7353   6E17   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6E1C   00 00 00 00 00 
        6E21   00 00 00 
 7354   6E24   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6E29   08 00 00 00 00 
        6E2E   00 
 7355   6E2F               	WINDOW7:
 7356   6E2F   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6E34   00 00 00 00 00 
        6E39   00 00 00 
 7357   6E3C   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6E41   08 00 00 00 00 
        6E46   00 
 7358                      	
 7359   6E47               	WINTABLE:
 7360   6E47   876D 9F6D B76D 		DW	WINDOW0,WINDOW1,WINDOW2,WINDOW3
        6E4D   CF6D 
 7361   6E4F   E76D FF6D 176E 		DW	WINDOW4,WINDOW5,WINDOW6,WINDOW7
        6E55   2F6E 
 7362                      		PAGE
  Wed May 24 1989 15:00                                                                                                  Page  113

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7363                      	
 7364                      	; ------
 7365                      	; SCREEN
 7366                      	; ------
 7367                      	; Move to the screen specified, by updating CURWIN and the cursor
 7368                      	; X,Y pos (SCRX,SCRY).  Also put address of that window's structure
 7369                      	; in WINDOW. Save a bunch of the old stuff in old window's structure then
 7370                      	; update the same bunch with the new window's stuff.
 7371                      	;
 7372                      	;	ARG1 - new screen id: 0-7
 7373                      	;
 7374   6E57               	ZSCRN:
 7375   6E57   20 AD 55    		jsr	CLRBUF		; EMPTY OUTPUT BUFFER BEFORE MOVING
 7376                      	;
 7377                      	; now, save a few things from the common variables
 7378                      	;
 7379   6E5A   A0 15       		ldy	#WINLLEN	; current line length
 7380   6E5C   A5 A7       		lda	LENGTH+LO	; get current line length
 7381   6E5E   91 05       		sta	(WINDOW),Y	; save for later referencing
 7382   6E60   C8          		iny			; point to msb
 7383   6E61   A5 A8       		lda	LENGTH+HI	; get MSB
 7384   6E63   91 05       		sta	(WINDOW),Y	; saved
 7385   6E65   20 9F 4D    		jsr	SAVE_CURSOR	; save the x,y pos of cursor
 7386   6E68   A5 BB       		lda	INVFLG		; get inverse flag
 7387   6E6A   F0 04       		beq	ZSCA1		; not set
 7388   6E6C   A9 01       		lda	#1		; set 1 bit
 7389   6E6E   D0 06       		bne	ZSCA2		; set in window
 7390   6E70               	ZSCA1:
 7391   6E70   A5 BA       		lda	UNDFLG		; how about underlining
 7392   6E72   F0 02       		beq	ZSCA2		; nope
 7393   6E74   A9 04       		lda	#4		; 4 == underlining
 7394   6E76               	ZSCA2:
 7395   6E76   A0 0C       		ldy	#WINHIGHL	; set new highlight
 7396   6E78   91 05       		sta	(WINDOW),Y	; save current attributes
 7397                      	;
 7398                      	; now it is time to update for new screen
 7399                      	;
 7400   6E7A   A5 63       		lda	ARG1+LO		; get which window
 7401   6E7C   85 A6       		sta	CURWIN		; save window number
 7402   6E7E   0A          		asl	A		; shift to make word indes
 7403   6E7F   AA          		tax			; swap to indexing reg
 7404   6E80   BD 47 6E    		lda	WINTABLE,X	; get the address of the new WINDOW
 7405   6E83   85 05       		sta	WINDOW+LO	; lo part comes first
 7406   6E85   BD 48 6E    		lda	WINTABLE+1,X	; so go get hi part
 7407   6E88   85 06       		sta	WINDOW+HI	; save the hi part of the address
 7408                      	
 7409   6E8A   20 B1 4D    		jsr	GET_CURSOR	; restore the cursor pos
 7410                      	
 7411   6E8D   A0 14       		ldy	#WINXSZ		; get line length
 7412   6E8F   B1 05       		lda	(WINDOW),Y	; update zero page variable
 7413   6E91   85 A2       		sta	XSIZE+LO	; this is for quicky comparing
 7414   6E93   A9 00       		lda	#0		; clear MSB
 7415   6E95   85 A3       		sta	XSIZE+HI
 7416   6E97   06 A2       		asl	XSIZE+LO	; *2
 7417   6E99   26 A3       		rol	XSIZE+HI
 7418   6E9B   06 A2       		asl	XSIZE+LO	; *4
 7419   6E9D   26 A3       		rol	XSIZE+HI
 7420   6E9F   A0 15       		ldy	#WINLLEN	; get current line length
 7421   6EA1   B1 05       		lda	(WINDOW),Y	; from before
 7422   6EA3   85 A7       		sta	LENGTH+LO	; save for later checking
 7423   6EA5   C8          		iny
 7424   6EA6   B1 05       		lda	(WINDOW),Y
 7425   6EA8   85 A8       		sta	LENGTH+HI
 7426   6EAA   A0 13       		ldy	#WINLCNT	; how many lines already out there
 7427   6EAC   B1 05       		lda	(WINDOW),Y	; has been already saved
 7428   6EAE   85 AB       		sta	LINCNT		; and save 'ere too
 7429   6EB0   A0 17       		ldy	#WINLINES	; how many lines in this
 7430   6EB2   B1 05       		lda	(WINDOW),Y	; window, anyway?
 7431   6EB4   85 03       		sta	MAXLINES	; show for everyone to see
 7432   6EB6   A0 01       		ldy	#WINLEFT	; show left margin
 7433   6EB8   B1 05       		lda	(WINDOW),Y	; get left edge
 7434   6EBA   A0 06       		ldy	#WINLM		; left margin
 7435   6EBC   18          		clc			; adding
 7436   6EBD   71 05       		adc	(WINDOW),Y	; to find new left margin
 7437   6EBF   85 04       		sta	LEFTMRG		; set up left margin for ease of use
  Wed May 24 1989 15:00                                                                                                  Page  114

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7438   6EC1   A0 00       		ldy	#WINTOP		; get top of window
 7439   6EC3   B1 05       		lda	(WINDOW),Y	; got it
 7440   6EC5   18          		clc			; adding
 7441   6EC6   A0 02       		ldy	#WINHGHT	; add height
 7442   6EC8   71 05       		adc	(WINDOW),Y	; did it
 7443   6ECA   85 02       		sta	SCRBTM		; this is first line outside window
 7444   6ECC   A0 0C       		ldy	#WINHIGHL	; get highlighting modes
 7445   6ECE   B1 05       		lda	(WINDOW),Y	; first for inverse video
 7446   6ED0   29 01       		and	#1		; check for inverse video
 7447   6ED2   F0 02       		beq	SCRINV		; nope
 7448   6ED4   A9 80       		lda	#$80		; means inverse video
 7449   6ED6               	SCRINV:
 7450   6ED6   85 BB       		sta	INVFLG		; there it be
 7451   6ED8   B1 05       		lda	(WINDOW),Y	; point to underline flag
 7452   6EDA   29 04       		and	#4		; check for underlining
 7453   6EDC   F0 02       		beq	SCRUND		; nope
 7454   6EDE   A9 80       		lda	#$80		; means underlining
 7455   6EE0               	SCRUND:
 7456   6EE0   85 BA       		sta	UNDFLG		; save for everyone
 7457                      	
 7458   6EE2   A0 12       		ldy	#WINATR		; get the current attributes
 7459   6EE4   B1 05       		lda	(WINDOW),Y	; gottem
 7460   6EE6   20 68 70    		jsr	SET_ATTRIBUTES	; set the flags, thank you
 7461   6EE9   A0 0F       		ldy	#WINFONT	; get the font
 7462   6EEB   B1 05       		lda	(WINDOW),Y	; thank you
 7463   6EED   F0 02       		beq	SCRFNT0		; is it font zero?
 7464   6EEF   A9 0C       		lda	#MONOFONT_W	; must be mono font, set width
 7465   6EF1               	SCRFNT0:
 7466   6EF1   85 C1       		sta	FONTFLG		; mark normal font
 7467   6EF3               	ZSCREX:
 7468   6EF3   60          		rts
 7469                      	;--------------
 7470                      	; ZWINPOS
 7471                      	;--------------
 7472                      	;
 7473                      	; change the window ARG1's top left corner to the new position
 7474                      	;
 7475                      	; ARG1 - window id from 0-7
 7476                      	; ARG2 - new top y pos
 7477                      	; ARG3 - new top x pos
 7478                      	;
 7479   6EF4               	ZWINPOS:
 7480   6EF4   C6 65       		dec	ARG2+LO		; make pos be zero based
 7481   6EF6   C6 67       		dec	ARG3+LO		; now they are!
 7482                      	; 
 7483                      	; if moving current window, save current cursor pos
 7484                      	;
 7485   6EF8               	ZWPOS0:
 7486   6EF8   20 9F 4D    		jsr	SAVE_CURSOR	; saving
 7487                      	;
 7488                      	; let's set up [J] to point to window we are talking about
 7489                      	;
 7490   6EFB               	ZWPOS1:
 7491   6EFB   A5 63       		lda	ARG1+LO		; get window ID 
 7492   6EFD   20 77 57    		jsr	SETWJ		; get J to point to it
 7493                      	
 7494   6F00   A5 65       	        lda     ARG2+LO         ; first, check the top
 7495   6F02   C9 C0       	        cmp     #MAXHEIGHT      ; < max height?
 7496   6F04   90 04       	        bcc     CKWA1           ; fine
 7497   6F06   A9 00       	        lda     #0              ; make it zero then        
 7498   6F08   85 65       	        sta     ARG2+LO         ; it is now
 7499   6F0A               	CKWA1:
 7500   6F0A   A5 67       	        lda     ARG3+LO         ; now check left edge
 7501   6F0C   C9 8C       	        cmp     #MAXWIDTH       ; howzit compare
 7502   6F0E   90 04       	        bcc     CKWA2           ; just fine
 7503   6F10   A9 00       	        lda     #0              ; this too
 7504   6F12   85 67       	        sta     ARG3+LO         ; it is now
 7505   6F14               	CKWA2:
 7506                      	;
 7507                      	; make the cursor pos be relative, so we can change back to
 7508                      	; absolute using new window pos
 7509                      	;
 7510   6F14   A0 04       		ldy	#WINY		; let's do y pos first
 7511   6F16   B1 7A       		lda	(J),Y		; get the old y pos
 7512   6F18   A0 00       		ldy	#WINTOP		; and subtract the top to make
  Wed May 24 1989 15:00                                                                                                  Page  115

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7513   6F1A   38          		sec			; (getting ready)
 7514   6F1B   F1 7A       		sbc	(J),Y		; the pos relative
 7515   6F1D   18          		clc			; now add in new top
 7516   6F1E   65 65       		adc	ARG2+LO		; this will be new top
 7517   6F20   A0 04       		ldy	#WINY		; get y offset again
 7518   6F22   91 7A       		sta	(J),Y		; and save new absolute y pos
 7519   6F24   A0 05       	  	ldy	#WINX		; now we be talking about x pos
 7520   6F26   B1 7A       		lda	(J),Y		; get old x pos
 7521   6F28   38          		sec			; getting ready for sub
 7522   6F29   A0 01       		ldy	#WINLEFT	; get rid of left ness
 7523   6F2B   F1 7A       		sbc	(J),Y		; now it's relative
 7524   6F2D   18          		clc			; get ready to add in new left ness
 7525   6F2E   65 67       		adc	ARG3+LO		; done
 7526   6F30   A0 05       		ldy	#WINX		; get x offset again
 7527   6F32   91 7A       		sta	(J),Y		; save in structure
 7528                      	;
 7529                      	; now we can change the top and left of the window
 7530                      	;
 7531   6F34   A5 65       		lda	ARG2+LO		; this is top of window
 7532   6F36   A0 00       		ldy	#WINTOP		; TOP offset
 7533   6F38   91 7A       		sta	(J),Y		; save the new top
 7534   6F3A   A5 67       		lda	ARG3+LO		; here is the left edge
 7535   6F3C   A0 01       		ldy	#WINLEFT	; offset into struct
 7536   6F3E   91 7A       		sta	(J),Y		; saved !
 7537                      	;
 7538                      	; we might have moved current window so update screen cursor and left margin
 7539                      	;
 7540   6F40   20 B1 4D    		jsr	GET_CURSOR	; restore cursor
 7541   6F43   A0 01       		ldy	#WINLEFT	; get left edge
 7542   6F45   B1 05       		lda	(WINDOW),Y	; okay
 7543   6F47   A0 06       		ldy	#WINLM		; add in left margin
 7544   6F49   18          		clc			; adding
 7545   6F4A   71 05       		adc	(WINDOW),Y	; to find new left edge
 7546   6F4C   85 04       		sta	LEFTMRG		; store for ease of use
 7547   6F4E   A0 14       		ldy	#WINXSZ		; get xsize
 7548   6F50   B1 7A       		lda	(J),Y		; okay
 7549   6F52   85 A2       		sta	XSIZE+LO	; this is for quicky comparing
 7550   6F54   A9 00       		lda	#0		; clear MSB
 7551   6F56   85 A3       		sta	XSIZE+HI
 7552   6F58   06 A2       		asl	XSIZE+LO	; *2
 7553   6F5A   26 A3       		rol	XSIZE+HI
 7554   6F5C   06 A2       		asl	XSIZE+LO	; *4
 7555   6F5E   26 A3       		rol	XSIZE+HI
 7556   6F60               	ZWPOSX:
 7557   6F60   60          		rts
 7558                      	;------------
 7559                      	; ZWINSIZE
 7560                      	;------------
 7561                      	;
 7562                      	; Change the size of window ARG1.  If cursor is outside of window,
 7563                      	; move to it.
 7564                      	;
 7565                      	;	ARG1 - window ID
 7566                      	; 	ARG2 - height
 7567                      	;	ARG3 - width
 7568                      	;
 7569                      	; Uses [J].
 7570                      	;
 7571   6F61               	ZWINSIZE:
 7572                      	;
 7573                      	; first put SCRCX,CY into window structure, just in case
 7574                      	;
 7575   6F61   20 9F 4D    		jsr	SAVE_CURSOR	; saved
 7576                      	;
 7577                      	; now do everything
 7578                      	;
 7579   6F64   A5 63       		lda	ARG1+LO		; get the window ID
 7580   6F66   20 77 57    		jsr	SETWJ		; and get window pointer
 7581                      	
 7582   6F69   A5 65       	        lda     ARG2+LO         ; first, check the top
 7583   6F6B   C9 C0       	        cmp     #MAXHEIGHT      ; < max height?
 7584   6F6D   90 04       	        bcc     CKWA11          ; fine
 7585   6F6F   A9 C0       	        lda     #MAXHEIGHT      ; make better
 7586   6F71   85 65       	        sta     ARG2+LO         ; it is now
 7587   6F73               	CKWA11:
  Wed May 24 1989 15:00                                                                                                  Page  116

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7588   6F73   A5 67       	        lda     ARG3+LO         ; now check left edge
 7589   6F75   C9 8C       	        cmp     #MAXWIDTH       ; howzit compare
 7590   6F77   90 04       	        bcc     CKWA21          ; just fine
 7591   6F79   A9 8C       	        lda     #MAXWIDTH       ; make it the max
 7592   6F7B   85 67       	        sta     ARG3+LO         ; it is now
 7593   6F7D               	CKWA21:
 7594   6F7D   A5 65       		lda	ARG2+LO		; get new height
 7595   6F7F   A0 02       		ldy	#WINHGHT	; offset
 7596   6F81   91 7A       		sta	(J),Y		; save new height
 7597   6F83   A5 67       		lda	ARG3+LO		; get width
 7598   6F85   A0 03       		ldy	#WINWID		; store width
 7599   6F87   91 7A       		sta	(J),Y		; okay
 7600                      	;
 7601                      	; now we need to figger out new XSIZE, MAXLINES
 7602                      	;
 7603   6F89   A0 03       		ldy	#WINWID		; store width
 7604   6F8B   B1 7A       		lda	(J),Y		; get width
 7605   6F8D   38          		sec			; have width, subtract margins
 7606   6F8E   A0 07       		ldy	#WINRM		; first right margin
 7607   6F90   F1 7A       		sbc	(J),Y		; subtracted right margin
 7608   6F92   A0 06       		ldy	#WINLM		; and now for the left margin
 7609   6F94   F1 7A       		sbc	(J),Y		; now we have new XSIZE
 7610   6F96   A0 14       		ldy	#WINXSZ		; get offset
 7611   6F98   91 7A       		sta	(J),Y		; save for later ref
 7612   6F9A   A5 65       		lda	ARG2+LO		; get new height
 7613   6F9C   A2 FF       		ldx	#$FF		; this is the counter
 7614   6F9E   38          		sec			; get ready for subs
 7615   6F9F               	ZWSZ1:
 7616   6F9F   E8          		inx			; count this line
 7617   6FA0   E9 09       		sbc	#FONT_H		; subtract off font height	
 7618   6FA2   B0 FB       		bcs	ZWSZ1		; still some lines	
 7619   6FA4   CA          		dex			; to keep the input line on screen
 7620   6FA5   8A          		txa			; get line count for storage
 7621   6FA6   A0 17       		ldy	#WINLINES	; this is how many lines are allowed
 7622   6FA8   91 7A       		sta	(J),Y		; saved
 7623                      	;
 7624                      	; check to make sure the cursor is still in the window
 7625                      	;
 7626   6FAA   A0 06       		ldy	#WINLM		; get left margin
 7627   6FAC   18          		clc			; for adding
 7628   6FAD   71 7A       		adc	(J),Y		; for figgering out right edge
 7629   6FAF   A0 01       		ldy	#WINLEFT	; add in left edge
 7630   6FB1   71 7A       		adc	(J),Y		; get right column by adding in left one
 7631   6FB3   A0 05       		ldy	#WINX		; check X pos
 7632   6FB5   D1 7A       		cmp	(J),Y		; see if X is still inside?
 7633   6FB7   F0 13       		beq	ZWSZ2		; must move to top left
 7634   6FB9   90 11       		bcc	ZWSZ2		; ditto if X >= margin
 7635   6FBB   A0 00       		ldy	#WINTOP		; get top to figger last line
 7636   6FBD   B1 7A       		lda	(J),Y		; from the structure
 7637   6FBF   A0 02       		ldy	#WINHGHT	; and add in the height
 7638   6FC1   18          		clc			; getting ready for add
 7639   6FC2   71 7A       		adc	(J),Y		; to find first line outside of range
 7640   6FC4   A0 04       		ldy	#WINY		; now check y
 7641   6FC6   D1 7A       		cmp	(J),Y		; now check y then
 7642   6FC8   F0 02       		beq	ZWSZ2		; outside, move to top left
 7643   6FCA   B0 15       		bcs	ZWSZ3		; inside so quit
 7644                      	;
 7645                      	; move the cursor to top left if outside of resized window
 7646                      	;
 7647   6FCC               	ZWSZ2:
 7648   6FCC   A0 00       		ldy	#WINTOP		; top line is here
 7649   6FCE   B1 7A       		lda	(J),Y		; so get me it
 7650   6FD0   A0 04       		ldy	#WINY		; now we be doing y
 7651   6FD2   91 7A       		sta	(J),Y		; change Y
 7652   6FD4   A0 01       		ldy	#WINLEFT	; move X to left margin
 7653   6FD6   B1 7A       		lda	(J),Y		; first get left edge
 7654   6FD8   A0 06       		ldy	#WINLM		; and add in left margin
 7655   6FDA   18          		clc			; (adding)
 7656   6FDB   71 7A       		adc	(J),Y		; to get left spot of cursor
 7657   6FDD   A0 05       		ldy	#WINX		; this is x offset
 7658   6FDF   91 7A       		sta	(J),Y		; so move X there
 7659                      	;
 7660                      	; now check to see if we mucked with current window
 7661                      	;
 7662   6FE1               	ZWSZ3:
  Wed May 24 1989 15:00                                                                                                  Page  117

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7663   6FE1   A5 64       		lda	ARG1+HI		; this is the id
 7664   6FE3   30 04       		bmi	ZWSZ4		; must be current window
 7665   6FE5   C5 A6       		cmp	CURWIN		; is it current window?
 7666   6FE7   D0 1B       		bne	ZWSZX		; nope, so done
 7667   6FE9               	ZWSZ4:
 7668   6FE9   A0 17       		ldy	#WINLINES	; get how many lines
 7669   6FEB   B1 7A       		lda	(J),Y		; get number of lines
 7670   6FED   85 03       		sta	MAXLINES	; set global
 7671   6FEF   A0 14       		ldy	#WINXSZ		; get new XSIZE too
 7672   6FF1   B1 7A       		lda	(J),Y		; get it
 7673   6FF3   85 A2       		sta	XSIZE+LO	; this is for quicky comparing
 7674   6FF5   A9 00       		lda	#0		; clear MSB
 7675   6FF7   85 A3       		sta	XSIZE+HI
 7676   6FF9   06 A2       		asl	XSIZE+LO	; *2
 7677   6FFB   26 A3       		rol	XSIZE+HI
 7678   6FFD   06 A2       		asl	XSIZE+LO	; *4
 7679   6FFF   26 A3       		rol	XSIZE+HI
 7680   7001   20 B1 4D    		jsr	GET_CURSOR	; fix the cursor pos
 7681   7004               	ZWSZX:
 7682   7004   60          		rts
 7683                      	;
 7684                      	;CHECK_WIN_ARGS
 7685                      	; check args to make sure they be okay
 7686                      	;
 7687                      	;  ARG2 = top/height
 7688                      	;  ARG3 = right/width
 7689                      	;
 7690   7005               	CHECK_WIN_ARGS:
 7691   7005   60          	        rts
 7692                      	
 7693                      		; ------
 7694                      		; HLIGHT
 7695                      		; ------
 7696                      	
 7697   7006               	ZLIGHT:
 7698   7006   A5 63       		lda	ARG1+LO		; get argument
 7699   7008   C9 10       		cmp	#$10		; must be <= 8
 7700   700A   B0 05       		bcs	ZLIEX		; nope it aint
 7701   700C   09 80       	 	ora	#$80		; turn on hi bit
 7702   700E   20 06 53    		jsr	COUT		; send it out then
 7703   7011               	ZLIEX:
 7704   7011   60          		rts			; done
 7705                      	;
 7706                      	; actually set the highlight flags according to [A]
 7707                      	;	
 7708   7012               	HLIGHT:
 7709                      	;
 7710                      	; TURN OFF ALL HIGHLIGHTS
 7711                      	;	
 7712   7012   29 7F       		and	#$7F		; turn off high bit
 7713   7014   D0 05       		bne	ZL1		; nope, must be something
 7714   7016   85 BA       		sta	UNDFLG		; and turn of underlining flag
 7715   7018   85 BB       		sta	INVFLG		; and inverse
 7716   701A   60          		rts			; all done
 7717   701B               	ZL1:
 7718   701B   C9 04       		cmp	#4		; underlining
 7719   701D   D0 05       		bne	ZL_REV		; maybe its INVERSE?
 7720                      	
 7721   701F   A9 80       		lda	#$80		; turn on UNDFLG
 7722   7021   85 BA       		sta	UNDFLG		; with an FF
 7723   7023   60          		rts			; done
 7724   7024               	ZL_REV:	
 7725   7024   C9 01       		cmp	#1		; INVERSE?
 7726   7026   D0 05       		bne	ZL_MONO		; maybe monospaced then
 7727   7028   A9 80       		lda	#$80		; must be inverse video
 7728   702A   85 BB       		sta	INVFLG		; and put it in invflg
 7729   702C   60          		rts
 7730   702D               	ZL_MONO:
 7731   702D   60          		rts			; fuck it for now!	
 7732                      	;
 7733                      	; ZWINATTER - change the scrolling/buffering/scripting/wrapping attributes
 7734                      	; of the window.
 7735                      	;
 7736                      	; ARG1 - window id
 7737                      	; ARG2 - interesting bits
  Wed May 24 1989 15:00                                                                                                  Page  118

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7738                      	;	| buffering | scripting | scrolling | wrapping |
 7739                      	; ARG3 - operation - 	0 MOVE
 7740                      	;		  	1 SET
 7741                      	;			2 CLEAR
 7742                      	;			3 COMPLEMENT
 7743                      	;
 7744   702E               	ZWINATTR:
 7745   702E   A5 62       		lda	NARGS		; see how many args
 7746   7030   C9 03       		cmp	#3		; check for operation args
 7747   7032   F0 04       		beq	ZWAT1		; yes, already there
 7748   7034   A9 00       		lda	#0		; zero means MOVE
 7749   7036   85 67       		sta	ARG3+LO		; so show it as default
 7750   7038               	ZWAT1:
 7751   7038   A5 63       		lda	ARG1+LO		; get window ID
 7752   703A   20 77 57    		jsr	SETWJ		; put window address into [J]
 7753                      	
 7754   703D   A0 12       		ldy	#WINATR		; get attribute offset
 7755   703F   B1 7A       		lda	(J),Y		; get current attribute
 7756   7041   18          		clc			; so we can just branch
 7757                      	
 7758   7042   C6 67       		dec	ARG3+LO		; decrement to find out what to do
 7759   7044   30 0A       		bmi	ZWMOVE		; do a move
 7760   7046   F0 0C       		beq	ZWSET		; do a set
 7761   7048   C6 67       		dec	ARG3+LO		; check once more
 7762   704A   F0 0C       		beq	ZWCLEAR		; clear set ones
 7763                      	;
 7764                      	; this is for the COMPLEMENT operations
 7765                      	;
 7766   704C   45 65       		eor	ARG2+LO		; complement bits
 7767   704E   90 0E       		bcc	ZWAT2		; done
 7768   7050               	ZWMOVE:
 7769                      	;
 7770                      	; move into the flag word
 7771                      	;
 7772   7050   A5 65       		lda	ARG2+LO		; get new flags
 7773   7052   90 0A       		bcc	ZWAT2		; done
 7774   7054               	ZWSET:
 7775                      	;
 7776                      	; set turned on ones
 7777                      	;
 7778   7054   05 65       		ora	ARG2+LO		; set'em up
 7779   7056   90 06       		bcc	ZWAT2		; done
 7780   7058               	ZWCLEAR:
 7781                      	;
 7782                      	; clear just the ones that are on
 7783                      	;
 7784   7058   A5 65       	        lda     ARG2+LO         ; get argument
 7785   705A   49 FF       	        eor     #$FF            ; turn on all the off ones
 7786   705C   31 7A       		and	(J),Y		; keep all the other ones
 7787   705E               	ZWAT2:
 7788   705E   91 7A       		sta	(J),Y		; and save it back
 7789                      	;
 7790                      	; now, if current window, set necessary flags
 7791                      	;
 7792   7060   A6 63       		ldx 	ARG1+LO		; get window ID
 7793   7062   30 04       	        bmi     SET_ATTRIBUTES  ; assume negative is current window
 7794   7064   E4 A6       		cpx	CURWIN		; is this the current one?
 7795   7066   D0 30       		bne	ZWATX		; nope, so leave
 7796   7068               	SET_ATTRIBUTES:
 7797                      	;
 7798                      	; current window, so set flags accordingly
 7799                      	;
 7800   7068   A2 00       		ldx	#0		; to turn off flag
 7801   706A   A0 01       		ldy	#1		; to turn on flag
 7802   706C   6A          		ror	A		; get wrapping flag into carry
 7803   706D   90 05       		bcc	ZWAT3		; clear it
 7804   706F   8C D6 71    		sty	WRPFLG		; set wrapping on
 7805   7072   B0 03       		bcs	ZWAT33		; okay
 7806   7074               	ZWAT3:
 7807   7074   8E D6 71    		stx	WRPFLG		; clear wrapping flag
 7808   7077               	ZWAT33:
 7809   7077   6A          		ror	A		; now check thes crolling flag
 7810   7078   90 05       		bcc	ZWAT4		; not set
 7811   707A   8C D7 71    		sty	SCRLFLG		; turn on scrolling flag
 7812   707D   B0 03       		bcs	ZWAT44		; okay, next please
  Wed May 24 1989 15:00                                                                                                  Page  119

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7813   707F               	ZWAT4:
 7814   707F   8E D7 71    		stx	SCRLFLG		; turn off scrolling
 7815   7082               	ZWAT44:
 7816   7082   6A          		ror	A		; checking the scripting flag
 7817   7083   90 05       		bcc	ZWAT5		; not set
 7818   7085   8C 74 6C    		sty	SCRIPTFLG	; allow scripting? yes
 7819   7088   B0 03       		bcs	ZWAT55		; next flag
 7820   708A               	ZWAT5:	
 7821   708A   8E 74 6C    		stx	SCRIPTFLG	; allow scripting? no
 7822   708D               	ZWAT55:
 7823   708D   6A          		ror	A		; this checks the buffering flag
 7824   708E   90 05       		bcc	ZWAT6		; not set
 7825   7090   8C D8 71    		sty	BUFFLG		; turn on buffering
 7826   7093   B0 03       		bcs	ZWATX		; scram
 7827   7095               	ZWAT6:
 7828   7095   8E D8 71    		stx	BUFFLG		; turn off buffering
 7829   7098               	ZWATX:
 7830   7098   60          		rts
 7831                      	;
 7832                      	; ZWINGET - put the window stuff into a table
 7833                      	;
 7834                      	;  ARG1 - Window id
 7835                      	;  ARG2 - offset
 7836                      	;
 7837   7099               	ZWINGET:
 7838   7099   20 9F 4D    		jsr	SAVE_CURSOR	; save x,y into structure
 7839                      	
 7840   709C   A5 63       		lda	ARG1+LO		; get window ID
 7841   709E   20 77 57    		jsr	SETWJ		; set up window address
 7842                      	
 7843   70A1   A5 65       		lda	ARG2+LO		; get where to start getting
 7844   70A3   0A          		asl	A		; make word index
 7845   70A4   AA          		tax			; make index
 7846   70A5   BD 41 71    		lda	ZWGTBL+LO,X	; get lo part of address
 7847   70A8   85 7C       		sta	K+LO		; save for jumping
 7848   70AA   BD 42 71    		lda	ZWGTBL+HI,X	; get hi part
 7849   70AD   85 7D       		sta	K+HI		; saved
 7850   70AF   20 B9 70    		jsr	ZWGVEC		; do the vectoring
 7851   70B2   86 77       		stx	VALUE+HI	; save hi part
 7852   70B4   85 76       		sta	VALUE+LO	; and the lo part
 7853   70B6   4C E1 43    		jmp	PUTVAL		; and return it
 7854   70B9               	ZWGVEC:
 7855   70B9   6C 7C 00    		jmp	(K)		; and goto it boys
 7856   70BC               	ZWG0:
 7857   70BC   A2 00       		ldx	#0		; zero out high part
 7858   70BE   A0 00       		ldy	#WINTOP		; get window y pos
 7859   70C0   B1 7A       		lda	(J),Y		; got it
 7860   70C2   A8          		tay			; need to inc it
 7861   70C3   C8          		iny			; to make it a one-based number
 7862   70C4   98          		tya			; back to a
 7863   70C5   60          		rts
 7864   70C6               	ZWG1:
 7865   70C6   A2 00       		ldx	#0		; zero out high part
 7866   70C8   A0 01       		ldy	#WINLEFT	; get window x pos
 7867   70CA   B1 7A       		lda	(J),Y		; got it
 7868   70CC   A8          		tay			; need to inc it
 7869   70CD   C8          		iny			; to make it a one-based number
 7870   70CE   98          		tya			; back to a
 7871   70CF   60          		rts
 7872   70D0               	ZWG2:
 7873   70D0   A2 00       		ldx	#0		; zero out high part
 7874   70D2   A0 02       		ldy	#WINHGHT	; get window height
 7875   70D4   B1 7A       		lda	(J),Y		; got it
 7876   70D6   60          		rts
 7877   70D7               	ZWG3:
 7878   70D7   A2 00       		ldx	#0		; zero out high part
 7879   70D9   A0 03       		ldy	#WINWID		; window width
 7880   70DB   B1 7A       		lda	(J),Y		; got it
 7881   70DD   60          		rts
 7882   70DE               	ZWG4:
 7883   70DE   20 5C 57    		jsr	FETCHCY		; get the current Y pos
 7884   70E1   A2 00       		ldx	#0		; zero out high part
 7885   70E3   60          		rts
 7886   70E4               	ZWG5:
 7887   70E4   20 69 57    		jsr	FETCHCX		; fetch the current X pos
  Wed May 24 1989 15:00                                                                                                  Page  120

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7888   70E7   A2 00       		ldx	#0		; zero out high part
 7889   70E9   60          		rts
 7890   70EA               	ZWG6:
 7891   70EA   A2 00       		ldx	#0		; zero out high part
 7892   70EC   A0 06       		ldy	#WINLM		; left margin
 7893   70EE   B1 7A       		lda	(J),Y		; got it
 7894   70F0   60          		rts
 7895   70F1               	ZWG7:
 7896   70F1   A2 00       		ldx	#0		; zero out high part
 7897   70F3   A0 07       		ldy	#WINRM		; right margin
 7898   70F5   B1 7A       		lda	(J),Y		; got it
 7899   70F7   60          		rts
 7900   70F8               	ZWG8:
 7901   70F8   A0 09       		ldy	#WINCRF+HI	; <CR> function
 7902   70FA   B1 7A       		lda	(J),Y		; got it, lo part
 7903   70FC   AA          		tax			; save hi part
 7904   70FD   88          		dey			; point to lo part
 7905   70FE   B1 7A       		lda	(J),Y		; got lo part
 7906   7100   60          		rts
 7907   7101               	ZWG9:
 7908   7101   A0 0B       		ldy	#WINCRC+HI	; <CR> count
 7909   7103   B1 7A       		lda	(J),Y		; got it, hi part
 7910   7105   AA          		tax			; save it
 7911   7106   88          		dey			; now to lo part
 7912   7107   B1 7A       		lda 	(J),Y		; got it
 7913   7109   60          		rts
 7914   710A               	ZWG10:
 7915   710A   A0 0C       		ldy	#WINHIGHL	; get high light mode
 7916   710C   B1 7A       		lda	(J),Y		; got it
 7917   710E   A2 00       		ldx	#0		; zero out high part
 7918   7110   60          		rts
 7919   7111               	ZWG11:
 7920   7111   A0 0E       		ldy	#WINBGND	; and background
 7921   7113   B1 7A       		lda	(J),Y		; got it
 7922   7115   A8          	        tay                     ; make index
 7923   7116   B9 47 6C    	        lda     APLCOLOR,Y      ; get apl->zip color
 7924   7119   AA          	        tax                     ; save for return
 7925   711A   A0 0D       		ldy	#WINFORE	; get foreground
 7926   711C   B1 7A       		lda	(J),Y		; got it
 7927   711E   A8          		tay			; save it
 7928   711F   B9 47 6C    	        lda     APLCOLOR,Y      ; get apl->zip color
 7929   7122   60          		rts
 7930   7123               	ZWG12:
 7931   7123   A0 0F       		ldy	#WINFONT	; now for font id
 7932   7125   B1 7A       		lda	(J),Y		; got it
 7933   7127   A2 00       		ldx	#0		; zero out high part
 7934   7129   60          		rts
 7935   712A               	ZWG13:
 7936   712A   A0 11       		ldy	#WINFSIZE+1	; font size (width)
 7937   712C   B1 7A       		lda	(J),Y		; got it
 7938   712E   AA          		tax			; save it
 7939   712F   88          		dey			; font size (height)
 7940   7130   B1 7A       		lda	(J),Y		; got it
 7941   7132   60          		rts
 7942   7133               	ZWG14:
 7943   7133   A2 00       		ldx	#0		; zero out high part
 7944   7135   A0 12       		ldy	#WINATR		; attributes
 7945   7137   B1 7A       		lda	(J),Y		; got it
 7946   7139   60          		rts			; got them!
 7947   713A               	ZWG15:
 7948   713A   A2 00       		ldx	#0		; only 1 byte worth
 7949   713C   A0 13       		ldy	#WINLCNT	; offset
 7950   713E   B1 7A       		lda	(J),Y		; get more counter
 7951   7140   60          		rts
 7952                      	;
 7953                      	; jump table for figgering out where to start filling
 7954                      	;
 7955   7141               	ZWGTBL:
 7956   7141   BC70 C670 D070 		DW	ZWG0,ZWG1,ZWG2,ZWG3,ZWG4,ZWG5,ZWG6,ZWG7
        7147   D770 DE70 E470 
        714D   EA70 F170 
 7957   7151   F870 0171 0A71 		DW	ZWG8,ZWG9,ZWG10,ZWG11,ZWG12,ZWG13,ZWG14,ZWG15
        7157   1171 2371 2A71 
        715D   3371 3A71 
 7958                      	;	
  Wed May 24 1989 15:00                                                                                                  Page  121

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7959                      	; ZSCROLL - scroll the specified window up or down
 7960                      	;
 7961                      	;  ARG1 - window ID
 7962                      	;  ARG2 - lines to scroll; <0 scrolls down
 7963                      	;
 7964   7161               	ZSCROLL:
 7965   7161   20 9F 4D    		jsr	SAVE_CURSOR	; save where cursor is
 7966                      	
 7967   7164   A9 00       	        lda     #0              ; don't script scroll
 7968   7166   85 AA       	        sta     SCRIPT          ; fine, we won't now
 7969                      	
 7970   7168   A5 63       		lda	ARG1+LO		; get which window
 7971   716A   20 77 57    		jsr	SETWJ		; set up pointer
 7972   716D   C6 62       		dec	NARGS		; see what we have for lines
 7973   716F   D0 04       		bne	ZSCR1		; a passed arg
 7974   7171   A9 01       		lda	#1		; 1 line is default
 7975   7173   85 65       		sta	ARG2+LO		; so say so
 7976   7175               	ZSCR1:
 7977   7175   A0 00       		ldy	#WINTOP		; get me window limits
 7978   7177   B1 7A       		lda	(J),Y		; first top
 7979   7179   85 0B       		sta	CLSTOP		; save for usage
 7980   717B   C8          		iny			; now left
 7981   717C   B1 7A       		lda	(J),Y		; okay, get for this window
 7982   717E   85 0A       		sta	CLSLEFT		; save left
 7983   7180   C8          		iny			; now it's width
 7984   7181   B1 7A       		lda	(J),Y		; got the window height
 7985   7183   85 0D       		sta	CLSHEIGHT	; this is it
 7986   7185   C8          		iny			; this is height
 7987   7186   B1 7A       		lda	(J),Y		; get window's height
 7988   7188   85 0C       		sta	CLSWIDTH	; save
 7989   718A   A5 66       		lda	ARG2+HI		; is it negative?
 7990   718C   85 1D       		sta	SCLDIR		; show direction of scroll
 7991   718E   10 08       		bpl	ZSCRL1		; nope
 7992   7190   A6 65       		ldx	ARG2+LO		; get how many lines
 7993   7192   49 FF       		eor	#$FF		; make pos
 7994   7194   AA          		tax			; put in X for inc
 7995   7195   E8          		inx			; and make right
 7996   7196   D0 02       		bne	ZSCRLEX		; done
 7997   7198               	ZSCRL1:
 7998   7198   A6 65       		ldx	ARG2+LO		; get how many lines
 7999   719A               	ZSCRLEX:
 8000   719A   86 18       		stx	SCLLINES	; save for routine
 8001   719C   20 03 60    		jsr	DO_SCROLL	; and do the scroll
 8002   719F               	ZSCRLEX1:
 8003   719F   A9 01       	        lda     #1              ; allow scripting
 8004   71A1   85 AA       	        sta     SCRIPT          ; we do
 8005   71A3   4C B1 4D    		jmp	GET_CURSOR	; restore the cursor, thank you
 8006                      	;
 8007                      	; ZWINPUT - put some information into window structure.  Just CRF/CRC
 8008                      	;	is legit now.
 8009                      	;
 8010                      	;  ARG1 - window ID
 8011                      	;  ARG2 - Word to be saved
 8012                      	;  ARG3 - offset of value
 8013                      	;
 8014   71A6               	ZWINPUT:
 8015   71A6   20 9F 4D    	        jsr     SAVE_CURSOR     ; save the cursor pos
 8016   71A9   A5 63       		lda	ARG1+LO		; get window ID
 8017   71AB   20 77 57    		jsr	SETWJ		; have J point to structure
 8018                      	
 8019   71AE   A5 65       		lda	ARG2+LO		; get first value in table
 8020   71B0   C9 08       		cmp	#8		; 8 = <CR> function
 8021   71B2   F0 0D       		beq	ZWIPCRF		; so save that
 8022   71B4   C9 09       		cmp	#9		; this is counter
 8023   71B6   F0 0D       		beq	ZWIPCRC		; so set counter
 8024   71B8   C9 0F       	        cmp     #15             ; LINCNT?
 8025   71BA   F0 01       	        beq     ZIPLCT          ; then set it too
 8026   71BC   60          		rts			; just die then
 8027   71BD               	ZIPLCT:
 8028   71BD   A0 13       	        ldy     #WINLCNT        ; point to line count
 8029   71BF   D0 0B       	        bne     ZWINPUT2        ; and stash it away
 8030   71C1               	ZWIPCRF:
 8031   71C1   A0 09       	        ldy     #WINCRF+1       ; point to window's CR function
 8032   71C3   D0 02       	        bne     ZWINPUT1        ; and put it        
 8033   71C5               	ZWIPCRC:
  Wed May 24 1989 15:00                                                                                                  Page  122

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 8034   71C5   A0 0B       		ldy	#WINCRC+1	; point to window's CR counter
 8035   71C7               	ZWINPUT1:
 8036   71C7   A5 68       		lda	ARG3+HI		; now get hi part
 8037   71C9   91 7A       		sta	(J),Y		; saved!
 8038   71CB   88          	        dey                     ; point to lo part
 8039   71CC               	ZWINPUT2:
 8040   71CC   A5 67       		lda	ARG3+LO		; start with lo part
 8041   71CE   91 7A       		sta	(J),Y		; save lo part
 8042   71D0               	ZWIPLCT:
 8043   71D0   4C B1 4D    	        jmp     GET_CURSOR      ; restore cursor/lincnt        
 8044   71D3               		
 8045   71D3               		END
 8046                      	
 8047   71D3               		INCLUDE		DLINE.ASM
 8048   71D3               		STTL	"--- Display line Routine ---"
 8049                      		PAGE
  Wed May 24 1989 15:00                                                                                                  Page  123

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8050                      	;
 8051                      	; some aux mem zero page stuff
 8052                      	;
 8053   71D3               	DLVARS:
 8054          71D3        	CHR_X	EQU	DLVARS		; (WORD) X pos for char (0-559)
 8055          71D5        	ENDBIT	EQU	CHR_X+2 	; (BYTE) ending bit offset
 8056          71D6        	WRPFLG	EQU	ENDBIT+1	; wrapping flag
 8057          71D7        	SCRLFLG	EQU	WRPFLG+1	; scrolling flag
 8058          71D8        	BUFFLG	EQU	SCRLFLG+1	; buffering flag
 8059          71D9        	SAVEX	EQU	BUFFLG+1	; (BYTE) save original X
 8060          71DA        	CHR_Y	EQU	SAVEX+1		; (BYTE) Working cursor Y pos
 8061          71DB        	LINECHAR EQU	CHR_Y+1		; (BYTE) working char counter
 8062          71DC        	BITTER	EQU	LINECHAR+1	; (BYTE) bit twiddler counter
 8063          71DD        	INCFLG	EQU	BITTER+1	; (BYTE) ==1 if NEXT_SCR needed after setpos
 8064          71DE        	SHOW_CURSOR EQU	INCFLG+1	; (BYTE) flag as to whether we are doing cursor
 8065          71DF        	SCRCNT	EQU	SHOW_CURSOR+1	; (BYTE) screen buffer offset
 8066          71E0        	SV_UND	EQU	SCRCNT+1	; (BYTE) spot to save underline flag
 8067          71E1        	SV_INV	EQU	SV_UND+1	; (BYTE) save starting INVFLG
 8068          71E2        	UNDERF  EQU     SV_INV+1        ; (BYTE) underline flag used internally
 8069          71E3        	LINE_HEIGHT EQU	UNDERF+1	; (BYTE) counter for height
 8070          0011        	DLVARSL	EQU	LINE_HEIGHT-CHR_X+1
 8071                      	
 8072   71D3               		BLKB	DLVARSL,0
 8073                      	
 8074   71E4   07 06 05 04 03 	BIT_BITS: DB	7,6,5,4,3,2,1,0	; number significant bits in last byte
        71E9   02 01 00 
 8075                      	
 8076   71EC               	DISP_LINE:
 8077   71EC   AD DF 71    		lda	SCRCNT		; make sure there are characters
 8078   71EF   D0 01       		bne	DPL1		; ayyup
 8079   71F1   60          		rts			; no chars, don't do anything
 8080   71F2               	DPL1:
 8081   71F2   A9 00       		lda	#0		; start at zero
 8082   71F4   85 09       		sta	CC_OFF		; which byte to use
 8083   71F6   8D DD 71    		sta	INCFLG		; and clear out inc'er flag
 8084   71F9               		
 8085   71F9   A9 08       		lda	#FONT_H-1	; do for height of char
 8086   71FB   8D E3 71    		sta	LINE_HEIGHT	; height counter
 8087                      	
 8088   71FE   A4 01       		ldy	SCRCY		; and starting y
 8089   7200   8C DA 71    		sty	CHR_Y		; saved
 8090   7203   A4 00       		ldy	SCRCX		; save x to
 8091   7205   8C D9 71    		sty	SAVEX		; save it
 8092   7208   A5 BB       		lda	INVFLG		; get current state
 8093   720A   8D E1 71    		sta	SV_INV		; and save it
 8094   720D   A5 BA       	        lda     UNDFLG          ; get current underline state
 8095   720F   8D E0 71    	        sta     SV_UND          ; and save it too
 8096                      	
 8097   7212   AD 77 6C    		lda	CURSFLG		; changed x pos?
 8098   7215   F0 12       	 	beq	DPL2		; no new figgering
 8099   7217   A2 00       		ldx	#0		
 8100   7219   8E D4 71    		stx	CHR_X+HI	; clear out msb
 8101                      	
 8102   721C   A5 00       		lda	SCRCX		; get new cursor x pos
 8103   721E   0A          		asl	A		; *2
 8104   721F   2E D4 71    		rol	CHR_X+HI
 8105   7222   0A          		asl	A		; *4
 8106   7223   8D D3 71    		sta	CHR_X+LO
 8107   7226   2E D4 71    		rol	CHR_X+HI
 8108   7229               	DPL2:
 8109   7229   AD D3 71    		lda	CHR_X+LO
 8110   722C   85 00       		sta	SCRCX
 8111   722E   29 03       		and	#3		; pick up 2 bits rolling out
 8112   7230   8D DC 71    		sta	BITTER		; what to add
 8113   7233   AD D4 71    		lda	CHR_X+HI
 8114   7236   4A          		lsr	A		; /2
 8115   7237   66 00       		ror	SCRCX
 8116   7239   4A          		lsr	A		; /4
 8117   723A   66 00       		ror	SCRCX
 8118   723C   20 4C 5E    		jsr	SETPOS		; set up pointers
 8119                      	
 8120   723F   AD DC 71    		lda	BITTER		; get extra
 8121   7242   18          		clc			; add in
 8122   7243   65 11       		adc	BITOFF		; normal bit offset
 8123   7245   8D DC 71    		sta	BITTER		; and make it new one
  Wed May 24 1989 15:00                                                                                                  Page  124

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8124   7248   C9 07       		cmp	#7		; but can't be greater than 6
 8125   724A   90 08       		bcc	DO_LINE		; okay, it's not
 8126   724C   8D DD 71    		sta	INCFLG		; show needing NEXT_SCR call
 8127   724F   E9 07       		sbc	#7		; so shrink it
 8128   7251   8D DC 71    		sta	BITTER		; save it
 8129   7254               	DO_LINE:
 8130   7254   20 4C 5E    		jsr	SETPOS		; set up pointers
 8131   7257   AD DD 71    		lda	INCFLG		; do we need to go one more?
 8132   725A   F0 03       		beq	DOL1		; nope
 8133   725C   20 F1 5D    		jsr	NEXT_SCR	; and point to next screen byte
 8134   725F               	DOL1:
 8135   725F   AE DC 71    	 	ldx	BITTER		; get bit off set
 8136   7262   86 11       		stx	BITOFF		; and save here
 8137   7264   A9 00       		lda	#0		; init a few things
 8138   7266   85 13       		sta	SCR_DATA	; init screen data byte
 8139   7268   8D DB 71    		sta	LINECHAR	; which character on the line 
 8140   726B   85 0F       		sta	CH_OFFSET		; which byte in line on screen
 8141   726D   85 07       		sta	LINE_X+LO	; X pos of line
 8142   726F   85 08       		sta	LINE_X+HI	; part 2
 8143   7271   8D E2 71    	        sta     UNDERF          ; make sure this be zero
 8144                      	
 8145   7274   AD E1 71    		lda	SV_INV		; get starting INV state
 8146   7277   85 BB       		sta	INVFLG		; okay!
 8147   7279   AD E0 71    	        lda     SV_UND          ; get starting UNDERLINE state
 8148   727C   85 BA       	        sta     UNDFLG          ; and restart it
 8149                      	
 8150   727E   C6 0F       		dec	CH_OFFSET		; inclusive count
 8151   7280   A6 11       		ldx	BITOFF		; make bitoff be a count
 8152   7282   BD E4 71    		lda	BIT_BITS,X	; get count
 8153   7285   AA          		tax			; x is bit counter
 8154   7286               	CHARL:
 8155   7286   AC DB 71    		ldy	LINECHAR	; get the char
 8156   7289   CC DF 71    		cpy	SCRCNT		; done with line?
 8157   728C   D0 03       		bne	CHARL1		; nope
 8158   728E   4C 32 73    		jmp	COPYL		; okay, move onto screen
 8159   7291               	CHARL1:
 8160   7291   EE DB 71    		inc	LINECHAR	; point to next one
 8161   7294   B9 80 02    		lda	SCRBUFF,Y	; got it
 8162   7297   10 06       		bpl	CHARL3		; not a highlight char
 8163                      	
 8164   7299   20 12 70    		jsr	HLIGHT		; so check it out
 8165   729C   4C 86 72    		jmp	CHARL		; done
 8166   729F               	CHARL3:
 8167   729F   C9 20       		cmp	#SPACE		; is it a highlight char?
 8168   72A1   90 E3       		bcc	CHARL		; ignore this one then
 8169   72A3               	CHARL2:
 8170   72A3   A8          		tay			; use as index
 8171   72A4   B9 27 63    		lda	CHADR_H,Y	; get high part of address
 8172   72A7   85 1D       		sta	CHPTR+HI	; point to it
 8173   72A9   B9 A6 63    		lda	CHADR_L,Y	; get lo part
 8174   72AC   85 1C       		sta	CHPTR+LO	; save it
 8175   72AE   B9 25 64    		lda	CHWID,Y		; get how wide the char is
 8176   72B1   85 C9       		sta	CW		; save it
 8177   72B3   A5 09       		lda	CC_OFF		; to get data
 8178   72B5   A4 C9       		ldy	CW		; see how wide the char is
 8179   72B7   C0 0A       		cpy	#10		; if <= 8, only one byte of info
 8180   72B9   90 01       		bcc	CHRLCW		; it is, so skip shift
 8181   72BB   0A          	 	asl	A		; *2 for bigger chars
 8182   72BC               	CHRLCW:
 8183   72BC   A8          		tay			; get the index
 8184   72BD   B1 1C       		lda	(CHPTR),Y	; get first byte
 8185   72BF   85 C7       		sta	CHAR_D1		; part one
 8186   72C1   C8          		iny			; point to next part
 8187   72C2   B1 1C       		lda	(CHPTR),Y	; get second byte
 8188   72C4   85 C8       		sta	CHAR_D2		; and save it
 8189   72C6   A5 C9       		lda	CW		; get width back
 8190   72C8   C9 0A       		cmp	#10		; if <= 8 zero byte 2 of char data
 8191   72CA   B0 04       		bcs	CHRLCW1		; nope
 8192   72CC   A9 00       		lda	#0		; clear out byte 2
 8193   72CE   85 C8       		sta	CHAR_D2		; okay
 8194   72D0               	CHRLCW1:
 8195   72D0   A5 C1       		lda	FONTFLG		; is this monospacing?
 8196   72D2   F0 28       		beq	CHRLFX		; nope
 8197                      	;
 8198                      	; if monospacing, see if it char is < mono width, and try to split
  Wed May 24 1989 15:00                                                                                                  Page  125

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8199                      	; the difference if so
 8200                      	;
 8201   72D4   C5 C9       		cmp	CW		; check against current width
 8202   72D6   B0 12       		bcs	CHRLF0		; CW < monowidth, so center
 8203                      	;
 8204                      	; too big, so take a little off front end too
 8205                      	;
 8206   72D8   A5 C9       		lda	CW		; get current width
 8207   72DA   38          		sec			; get ready for subbing
 8208   72DB   E9 0C       		sbc	#MONOFONT_W	; take away mono width
 8209   72DD   4A          		lsr	A		; /2 to get front half
 8210   72DE   A8          		tay			; use as counter
 8211   72DF   F0 17       		beq	CHRLF1		; nothing to do
 8212   72E1               	CHRLFX1:
 8213   72E1   06 C8       		asl	CHAR_D2		; step to the left
 8214   72E3   26 C7       		rol	CHAR_D1		; pick up char
 8215   72E5   88          		dey			; count one
 8216   72E6   D0 F9       		bne	CHRLFX1		; do next one
 8217   72E8   F0 0E       		beq	CHRLF1		; all done
 8218   72EA               	CHRLF0:
 8219   72EA   38          		sec			; do sub
 8220   72EB   E5 C9       		sbc	CW		; subtract CW
 8221   72ED   4A          		lsr	A		; /2 to get front part
 8222   72EE   A8          		tay			; put in counter
 8223   72EF   F0 07       		beq	CHRLF1		; no need to do anything
 8224   72F1               	CHRLFL:
 8225   72F1   46 C7       		lsr	CHAR_D1		; shift to right
 8226   72F3   66 C8       		ror	CHAR_D2		; this part too
 8227   72F5   88          		dey			; count shift
 8228   72F6   D0 F9       		bne	CHRLFL		; not done shifting yet
 8229   72F8               	CHRLF1:
 8230   72F8   A9 0C       		lda	#MONOFONT_W	; get mono font width
 8231   72FA   85 C9       		sta	CW		; chop at mono width
 8232   72FC               	CHRLFX:
 8233   72FC   AD E3 71    		lda	LINE_HEIGHT	; if == 0, then pick up underlining
 8234   72FF   D0 05       		bne	CHRL3		; nope
 8235                      	
 8236   7301   A5 BA       		lda	UNDFLG		; get underlining flag
 8237   7303   8D E2 71    		sta	UNDERF		; and mark for later
 8238   7306               	CHRL3:
 8239   7306   A5 13       		lda	SCR_DATA	; get starting data
 8240   7308               	DATAL:
 8241   7308   26 C8       		rol	CHAR_D2		; it's a step to the left
 8242   730A   26 C7       		rol	CHAR_D1		; nother one
 8243   730C   6A          		ror	A		; and put into screen byte
 8244   730D   45 BB       		eor	INVFLG		; pick up inversing
 8245   730F   0D E2 71    		ora	UNDERF		; pick up underline flag
 8246   7312   E6 07       		inc	LINE_X+LO	; next X pos too
 8247   7314   D0 02       		bne	DATAL0		; no wrap
 8248   7316   E6 08       		inc	LINE_X+HI	; wrapped
 8249   7318               	DATAL0:
 8250   7318   CA          		dex			; next bit pos
 8251   7319   D0 0C       		bne	DATAL1		; nope
 8252                      	;
 8253                      	; save the byte and point to next byte
 8254                      	;
 8255   731B               	STCH:
 8256   731B   4A          		lsr	A		; put in lower 7 bits
 8257   731C   E6 0F       		inc	CH_OFFSET		; point to next one
 8258   731E   A4 0F       		ldy	CH_OFFSET		; get current offset
 8259   7320   99 00 1F    		sta	SCR_LINE,Y	; save in line
 8260   7323   A2 07       		ldx	#7		; and start bitoff at 7
 8261   7325   A9 00       		lda	#0		; clear a few locals
 8262   7327               	DATAL1:
 8263   7327   C6 C9       		dec	CW		; well?
 8264   7329   30 1F       		bmi	COPYL1		; all done, start copying
 8265   732B   D0 DB       		bne	DATAL		; nope
 8266   732D   85 13       		sta	SCR_DATA	; save current screen byte stuff here
 8267   732F   4C 86 72    		jmp	CHARL		; do next char
 8268   7332               	COPYL:
 8269   7332   A5 07       		lda	LINE_X+LO	; see if we have any at all
 8270   7334   05 08       		ora	LINE_X+HI	; well, did we go anywhere?
 8271   7336   F0 21       		beq	LINE_EXIT	; then quit
 8272   7338   BD E4 71    		lda	BIT_BITS,X	; get number of significant bits
 8273   733B   8D D5 71    		sta	ENDBIT		; save this one
  Wed May 24 1989 15:00                                                                                                  Page  126

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8274   733E   E0 07       		cpx	#7		; has it been renewed?
 8275   7340   F0 08       		beq	COPYL1		; no last byte
 8276   7342   A5 13       		lda	SCR_DATA	; get screen data
 8277   7344               	COPYSH:
 8278   7344   4A          		lsr	A		; put down low, please
 8279   7345   CA          		dex			; one more
 8280   7346   D0 FC       		bne	COPYSH		; and do it again
 8281   7348   F0 D1       		beq	STCH		; now save this char
 8282   734A               	COPYL1:
 8283   734A   20 1E 61    		jsr	COPY_SCRL	; copy SCR_LINE to screen
 8284   734D               	LED2:
 8285   734D   E6 01       		inc	SCRCY		; point to next line	
 8286   734F   CE E3 71    		dec	LINE_HEIGHT	; count this line
 8287   7352   30 05       		bmi	LINE_EXIT	; all done!
 8288                      	
 8289   7354   E6 09       		inc	CC_OFF		; point to next byte
 8290   7356   4C 54 72    		jmp	DO_LINE		; and do next line
 8291   7359               	LINE_EXIT:
 8292   7359   AE D9 71    		ldx	SAVEX		; get x back
 8293   735C   86 00       		stx	SCRCX		; restore it
 8294                      	
 8295   735E   AD DE 71    		lda	SHOW_CURSOR	; are we just doing cursor?
 8296   7361   D0 14       		bne	DLXX		; yes, don't change char pos
 8297                      	
 8298   7363   18          		clc			; add in length of this line
 8299   7364   A5 07       		lda	LINE_X+LO	; get length of line
 8300   7366   6D D3 71    		adc	CHR_X+LO	; add to start pos
 8301   7369   8D D3 71    		sta	CHR_X+LO	; save it
 8302   736C   A5 08       		lda	LINE_X+HI	; and the MSB
 8303   736E   6D D4 71    		adc	CHR_X+HI	; okay
 8304   7371   8D D4 71    		sta	CHR_X+HI	; save for a rainy day
 8305   7374   20 85 73    		jsr	GET_SCRCX	; set SCRCX back up
 8306   7377               	DLXX:
 8307   7377   AD DA 71    		lda	CHR_Y		; restore the 
 8308   737A   85 01       		sta	SCRCY		; y pos
 8309   737C   A9 00       		lda	#0		; clear out counter
 8310   737E   8D DF 71    		sta	SCRCNT		; okay
 8311   7381   8D 77 6C    		sta	CURSFLG		; reset this flag too
 8312   7384   60          		rts
 8313                      	
 8314   7385               	GET_SCRCX:
 8315   7385   AD D3 71    		lda	CHR_X+LO	; pick this back up
 8316   7388   85 00       	        sta     SCRCX
 8317   738A   AD D4 71    		lda	CHR_X+HI	; /2
 8318   738D   4A          		lsr	A       	; pick up remainder
 8319   738E   66 00       		ror	SCRCX   	; /4
 8320   7390   4A          		lsr	A		; pick up remainder
 8321   7391   66 00       		ror	SCRCX		; got it
 8322   7393   AD D3 71    		lda	CHR_X+LO	; any remainder?
 8323   7396   29 03       		and	#3		; well?
 8324   7398   F0 DD       		beq	DLXX		; nope
 8325   739A   E6 00       		inc	SCRCX		; point to next pos
 8326   739C   60          		rts
 8327                      	
 8328                      	;
 8329                      	; DO_CURSOR - read in the screen byte, XOR cursor data, store it
 8330                      	;
 8331   739D               	DO_CURSOR:
 8332   739D   A0 00       		ldy	#0		; and zero y
 8333   739F   84 10       		sty	DATALOOP	; init this counter
 8334   73A1               	DOCLOOP:
 8335                      	
 8336   73A1   A0 00       		ldy	#0		; must use Y
 8337   73A3   A6 8E       		ldx	FPCBNK		; what bank
 8338   73A5   BD 54 C0    		lda	PAGE2SW,X	; select it
 8339   73A8   B1 8C       		lda	(FPC),Y		; okay, get byte
 8340   73AA   A6 10       		ldx	DATALOOP	; get offset
 8341   73AC   5D 00 1F    		eor	SCR_LINE,X	; get data
 8342   73AF   91 8C       		sta	(FPC),Y		; save data
 8343   73B1   20 F1 5D    		jsr	NEXT_SCR	; point to next screen byte
 8344   73B4   E6 10       		inc	DATALOOP	; point to next char
 8345   73B6   C6 0F       		dec	CH_OFFSET	; count one char
 8346   73B8   10 E7       		bpl	DOCLOOP		; all done with this line?
 8347   73BA   AD 54 C0    		lda	PAGE2SW+MAIN	; make sure we are point to MAIN
 8348   73BD   60          		rts
  Wed May 24 1989 15:00                                                                                                  Page  127

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8349                      	
 8350   73BE               		END
 8351                      	
 8352   73BE               		INCLUDE		PIC.ASM
 8353   73BE               		STTL "--- Picture Op Codes ---"
 8354                      		PAGE
  Wed May 24 1989 15:00                                                                                                  Page  128

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8355                      	PFILE_RD:			; for READING files
 8356   73BE   04          		db	4		; 4 parameters
 8357   73BF   00          		db	0		; refnum
 8358   73C0   0008        		dw	IOBUFF		; read into io buffer
 8359   73C2   0004        		dw	$400		; 1Kb buffer
 8360   73C4   0000        		dw	0		; length actually read
 8361   73C6               	PFSEEK:
 8362   73C6   02          		db	2	        ; 2 pararmeters
 8363   73C7   00          		db	0	        ; refnum
 8364   73C8   00 00 00    		db 	0,0,0	        ; 3 byte new file pos
 8365   73CB   0000        	PICCNT: dw	0	        ; counter of the entries
 8366   73CD   00          	PF_REFNUM: db     0             ; place to store refnum
 8367   73CE   FF          	PF_FID: db      $FF             ; File ID of local directory data
 8368   73CF   00          	P_IDX:	db 	0	
 8369   73D0   00          	P_BCNT:	db	0
 8370   73D1   00          	P_LOFF:	db	0
 8371   73D2   00          	GBL_FLAG: db    0               ; found global directory?
 8372   73D3   00          	PIC_FLAG: db    0               ; found pictures?
 8373   73D4   00          	PF_NAME: db     0                       ; name we are looking at
 8374   73D5   00          	        db      0                       ; name we found
 8375                      	
 8376   73D6               	PICINFO:
 8377   73D6               		ds	PLDSIZE ; get room for picture data
 8378                      	
 8379   73DE   00          	TRANSCLR: DB	0	; transparent color
 8380   73DF               	UNKPIC:
 8381                      	
 8382   73DF   0D 55 6E 6B 6E 		db	EOL,"Unknown Picture #"
        73E4   6F 77 6E 20 50 
        73E9   69 63 74 75 72 
        73EE   65 20 23 
 8383          0012        	UNKPICL	EQU	$-UNKPIC
 8384   73F1               	ZDISPL:
 8385   73F1   20 AD 55    		jsr	CLRBUF			; put out any and all text
 8386                      	
 8387   73F4   20 48 77    		jsr	GET_PICINF		; get the necessary data
 8388   73F7   90 18       		bcc	ZDSP1			; everything just fine
 8389                      	
 8390   73F9               		DLINE	UNKPIC			; unknown picture number error
 8391   73F9   A2 DF       		ldx	#<UNKPIC	; get part of UNKPIC
 8392   73FB   A9 73       		lda	#>UNKPIC	; get other part of string
 8393          [01]        		IFMA	2		; check to see if length passed in
 8394                      		ldy			; then just fetch it
 8395          [01]        		ELSE
 8396   73FD   A0 12       		ldy	#UNKPICL	; get length of string
 8397          [00]        		ENDIF
 8398   73FF   20 6B 4C    		jsr	DLINE		; print the string
 8399   7402               		.MACEND
 8400   7402   A5 64       		lda	ARG1+HI			; get MSB
 8401   7404   20 D3 47    		jsr	HEXNUM			; print it
 8402   7407   A5 63       		lda	ARG1+LO			; and LSB
 8403   7409   20 D3 47    		jsr 	HEXNUM
 8404   740C   A9 14       		lda	#$14			; bad picture number error
 8405   740E   4C 0A 52    		jmp	ZERROR			; and croak
 8406   7411               	ZDSP1:
 8407   7411   20 9F 4D    		jsr	SAVE_CURSOR		; save the cursor
 8408                      	
 8409   7414   A9 00       		lda	#0			; show no cursor change
 8410   7416   8D 77 6C    		sta	CURSFLG			; start with none, anyway
 8411                      	
 8412   7419   C6 62       		dec	NARGS			; x,y pos passed?
 8413   741B   F0 30       		beq	ZDSP10			; nope, just use as is
 8414                      	
 8415   741D   A5 65       		lda	ARG2+LO			; get passed y pos
 8416   741F   F0 12       		beq	ZDSP01			; don't change
 8417   7421   85 01       		sta	SCRCY			; change, then
 8418   7423   C6 01       		dec	SCRCY			; zero base it
 8419   7425   A0 00       		ldy	#WINTOP			; get top edge of window
 8420   7427   B1 05       		lda	(WINDOW),Y		; got it
 8421   7429   18          		clc				; get ready for add
 8422   742A   65 01       		adc	SCRCY			; add the offset
 8423   742C   85 01       		sta	SCRCY			; and make it Y pos
 8424   742E   A9 01       		lda	#1			; show cursor change anyway
 8425   7430   8D 77 6C    		sta	CURSFLG			; okay, we did
 8426   7433               	ZDSP01:
  Wed May 24 1989 15:00                                                                                                  Page  129

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8427   7433   C6 62       		dec	NARGS			; x pos passed?
 8428   7435   F0 16       		beq	ZDSP10			; nope
 8429                      	
 8430   7437   A5 67       		lda	ARG3+LO			; get x pos
 8431   7439   F0 12       		beq	ZDSP10			; if == 0, don't change
 8432   743B   85 00       		sta	SCRCX			; set as passed
 8433   743D   C6 00       		dec	SCRCX			; zero base it
 8434   743F   A0 01       		ldy	#WINLEFT		; get left hand edge of window
 8435   7441   B1 05       		lda	(WINDOW),Y		; got it
 8436   7443   18          		clc				; get ready for add
 8437   7444   65 00       		adc	SCRCX			; add the offset
 8438   7446   85 00       		sta	SCRCX			; and make it X pos
 8439   7448   A9 01       		lda	#1			; show cursor change anyway
 8440   744A   8D 77 6C    		sta	CURSFLG			; okay, we did
 8441   744D               	ZDSP10:
 8442   744D   A5 00       		lda	SCRCX			; get current X
 8443   744F   48          		pha				; save it
 8444   7450   18          		clc				; adding
 8445   7451   6D D8 73    		adc	PICINFO+PLDWID		; add in pic width
 8446   7454   85 00       		sta	SCRCX			; save here
 8447   7456   68          		pla				; get start X pos back
 8448   7457   85 00       		sta	SCRCX			; restored
 8449   7459               	ZDSP101:
 8450   7459   AD DA 73    		lda 	PICINFO+PLDFLG		; get flag byte
 8451   745C   29 01       		and	#1			; is there a transparent color?
 8452   745E   D0 04       		bne	ZDSP11			; ayyup
 8453   7460   A9 FF       		lda	#$FF			; make TRANSCLR be $FF
 8454   7462   D0 07       		bne	ZDSP12			; okay
 8455   7464               	ZDSP11:
 8456   7464   AD DA 73    		lda	PICINFO+PLDFLG		; get hi byte of flag word
 8457   7467   4A          		lsr	A			; put in lower byte
 8458   7468   4A          		lsr	A			; put in lower byte
 8459   7469   4A          		lsr	A			; put in lower byte
 8460   746A   4A          		lsr	A			; put in lower byte
 8461   746B               	ZDSP12:
 8462   746B   8D DE 73    		sta	TRANSCLR		; save transparent color
 8463                      	
 8464   746E   AD DB 73    		lda	PICINFO+PLDPTR		; MSB of offset
 8465   7471   8D CA 73    		sta	PFSEEK+SM_FPOS+2	; MSB of seek
 8466   7474   AD DC 73    		lda	PICINFO+PLDPTR+1	; Middle
 8467   7477   29 FE       	        and     #$FE                    ; seek only to 512byte boundary
 8468   7479   8D C9 73    		sta	PFSEEK+SM_FPOS+1
 8469                      	
 8470   747C               		SET_MARK PFSEEK			; go to pic data
 8471   747C               		PRODOS	$CE, PFSEEK
 8472   747C   20 00 BF    		jsr	$BF00	; ProDOS handler
 8473   747F   CE          		DB	$CE	; ProDOS function code
 8474   7480   C673        		DW	PFSEEK	; Function Parameter Block address
 8475   7482               		.MACEND
 8476   7482               		.MACEND
 8477   7482   A9 02       		lda	#>PIC1BUF		; set up pointers to decode buffers
 8478   7484   85 7B       		sta	J+HI
 8479   7486   A9 73       		lda	#<PIC1BUF
 8480   7488   85 7A       		sta	J+LO
 8481   748A   A9 1C       		lda	#>PIC2BUF
 8482   748C   85 7D       		sta	K+HI
 8483   748E   A9 74       		lda	#<PIC2BUF
 8484   7490   85 7C       		sta	K+LO
 8485   7492   A9 00       		lda	#0			; start line at zero
 8486   7494   8D D1 73    		sta	P_LOFF			; done
 8487   7497   A0 8B       		ldy	#MAXWIDTH-1		; clear out width buffer
 8488   7499               	ZDLI:
 8489   7499   91 7A       		sta	(J),Y			; init 'previous line' buffer to zero
 8490   749B   88          		dey				; down one
 8491   749C   D0 FB       		bne	ZDLI
 8492   749E   91 7A       		sta	(J),Y			; get last one
 8493                      	
 8494   74A0   A9 08       		lda	#>IOBUFF		; now get data buffer address
 8495   74A2   85 7F       		sta	L+HI
 8496   74A4   A9 04       		lda	#4			; 4 pages read in at once
 8497   74A6   8D D0 73    		sta	P_BCNT			; okay
 8498   74A9   A9 03       		lda	#3			; 3 bytes of width data start it
 8499   74AB   18          	        clc                             ; doing add
 8500   74AC   6D DD 73    		adc	PICINFO+PLDPTR+2	; pick up LSB pointer
 8501   74AF   8D CF 73    		sta	P_IDX			; start index
  Wed May 24 1989 15:00                                                                                                  Page  130

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8502   74B2   90 05       	        bcc     ZDLPCC                  ; no wrap
 8503   74B4   E6 7F       	        inc     L+HI                    ; start at second one
 8504   74B6   CE D0 73    	        dec     P_BCNT                  ; one less block
 8505   74B9               	ZDLPCC:
 8506   74B9   AD DC 73    		lda	PICINFO+PLDPTR+1        ; tells which block it is in               
 8507   74BC   29 01       	        and     #$01                    ; pick up which 256 block
 8508   74BE   F0 05       	        beq     ZDLP0                   ; start at first one
 8509   74C0   E6 7F       	        inc     L+HI                    ; start at next one
 8510   74C2   CE D0 73    	        dec     P_BCNT                  ; one less block
 8511   74C5               	ZDLP0:
 8512   74C5   A9 00       		lda	#<IOBUFF
 8513   74C7   85 7E       		sta	L+LO
 8514   74C9   A9 03       	        lda     #RETRY_COUNT    ; set retry
 8515   74CB   85 0E       	        sta     NY_DATA         ; just use this for now
 8516   74CD               	ZDLPRD:
 8517   74CD               		READ	PFILE_RD		; read in 1kb worth of data
 8518   74CD               		PRODOS	$CA, PFILE_RD
 8519   74CD   20 00 BF    		jsr	$BF00	; ProDOS handler
 8520   74D0   CA          		DB	$CA	; ProDOS function code
 8521   74D1   BE73        		DW	PFILE_RD	; Function Parameter Block address
 8522   74D3               		.MACEND
 8523   74D3               		.MACEND
 8524   74D3   90 05       		bcc	ZDECLP			; everything went just fine
 8525   74D5   20 07 47    	        jsr     RETRY                   ; must we?
 8526   74D8   90 F3       	        bcc     ZDLPRD                  ; yes
 8527   74DA               	ZDECLP:
 8528   74DA   AC CF 73    		ldy	P_IDX			; get data index
 8529   74DD   B1 7E       		lda	(L),Y			; get data byte
 8530   74DF   85 71       		sta	ARG8			; save here
 8531   74E1   C8          		iny				; point to next one
 8532   74E2   D0 06       		bne	ZDCLP0			; okay, use offset
 8533   74E4   20 F0 75    		jsr	NEXT_PICB		; read in next block
 8534   74E7   90 01       		bcc	ZDCLP0			; everything went fine
 8535   74E9   60          		rts				; return if not
 8536   74EA               	ZDCLP0:
 8537   74EA   B1 7E       		lda	(L),Y			; is this count or data?
 8538   74EC   C9 10       		cmp	#16			; if <= 15, previous one was data 
 8539   74EE   B0 04       		bcs	ZDCL2			; nope, must be compressed
 8540   74F0   A9 0F       		lda	#15			; show 1 bytes
 8541   74F2   D0 0B       		bne	ZDCL3			; and count this one
 8542   74F4               	ZDCL2:
 8543   74F4   C8          		iny				; point to next byte
 8544   74F5   D0 08       		bne	ZDCL3			; okay, no wrap
 8545   74F7   48          		pha				; save A
 8546   74F8   20 F0 75    		jsr	NEXT_PICB		; check about nother block
 8547   74FB   68          		pla				; get A back
 8548   74FC   90 01       		bcc	ZDCL3			; everything came out okay
 8549   74FE   60          		rts				; problems, return
 8550   74FF               	ZDCL3:
 8551   74FF   8C CF 73    		sty	P_IDX			; save index
 8552   7502   38          		sec				; get ready for sub
 8553   7503   E9 0E       		sbc	#14			; make good counter
 8554   7505   AA          		tax				; put count into x
 8555   7506               	ZDCLPC:
 8556   7506   AC D1 73    		ldy	P_LOFF			; get line offset
 8557   7509   A5 71       		lda	ARG8			; get data byte
 8558   750B   51 7A       		eor	(J),Y			; XOR with previous line
 8559   750D   91 7C       		sta	(K),Y			; and save away
 8560   750F   C8          		iny				; next offset
 8561   7510   8C D1 73    		sty	P_LOFF			; save Y
 8562   7513   CC D8 73    		cpy	PICINFO+PLDWID		; end of line?
 8563   7516   D0 10       		bne	ZDCLPC1			; nope
 8564   7518   20 30 75    		jsr	COPY_PIC		; copy line into screen
 8565   751B   A5 01       		lda	SCRCY			; past bottom?
 8566   751D   C9 BF       		cmp	#MAXHEIGHT-1		; well?
 8567   751F   F0 0C       		beq	ZDCLPX			; truncate at bottom then
 8568   7521   E6 01       		inc	SCRCY			; down one line
 8569   7523   CE D9 73    		dec	PICINFO+PLDHGHT		; count line
 8570   7526   F0 05       		beq	ZDCLPX			; all done then
 8571   7528               	ZDCLPC1:
 8572   7528   CA          		dex				; count down counter
 8573   7529   D0 DB       		bne	ZDCLPC			; do this byte again
 8574   752B   F0 AD       		beq	ZDECLP			; check next byte
 8575   752D               	ZDCLPX:
 8576   752D   4C B1 4D    		jmp	GET_CURSOR		; restore the cursor
  Wed May 24 1989 15:00                                                                                                  Page  131

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8577                      	
 8578   7530               	COPY_PIC:
 8579   7530   8A          		txa				; save x
 8580   7531   48          		pha 
 8581   7532   A5 00       		lda	SCRCX			; get start X pos
 8582   7534   48          		pha				; okay, saved
 8583   7535   A9 00       		lda	#0			; start offset at zero
 8584   7537   85 0E       		sta	NY_DATA 		; and into data buffer
 8585   7539               	CPICLOOP:
 8586   7539   20 4C 5E    		jsr	SETPOS			; point to correct line
 8587   753C   A6 11       		ldx	BITOFF			; get starting offset
 8588   753E   8E DC 71    		stx	BITTER			; bit offset for COPY_SCRL to use
 8589   7541   BD E4 71    		lda	BIT_BITS,X		; get starting bit counter
 8590   7544   AA          		tax				; okay, we did
 8591   7545   A9 8C       		lda	#MAXWIDTH		; don't let screen wrap
 8592   7547   38          		sec				; doing sub
 8593   7548   E5 00       		sbc	SCRCX			; get current X pos
 8594   754A   85 10       		sta	DATALOOP		; only use this many pixels
 8595   754C   A0 00       		ldy	#0			; start with first byte
 8596   754E   84 13       		sty	SCR_DATA		; data starts with zero
 8597   7550   88          		dey				; inclusive count
 8598   7551   84 0F       		sty	CH_OFFSET		; reset line offset
 8599   7553   A4 0E       		ldy	NY_DATA 		; start Y out
 8600   7555   20 80 75    		jsr	PIC2SCR			; move line to screen
 8601                      	
 8602   7558   A4 0E       		ldy	NY_DATA 		; current offset
 8603   755A   CC D8 73    		cpy	PICINFO+PLDWID		; did we finish whole line?
 8604   755D   B0 02       		bcs	COPYPIC1		; yup, so wrap things up
 8605   755F   90 D8       		bcc	CPICLOOP		; and continue with line
 8606   7561               	COPYPIC1:
 8607   7561   A5 7B       		lda	J+HI			; get previous line
 8608   7563   48          	 	pha				; save addr
 8609   7564   A5 7D       		lda	K+HI			; make current line be previous
 8610   7566   85 7B       		sta	J+HI
 8611   7568   68          		pla				; get old previous line back
 8612   7569   85 7D       		sta	K+HI			; make it be new current line
 8613   756B   A5 7A       		lda	J+LO			; get previous line
 8614   756D   48          		pha				; and save it
 8615   756E   A5 7C       		lda	K+LO
 8616   7570   85 7A       		sta	J+LO			; okay, it is
 8617   7572   68          		pla	
 8618   7573   85 7C       		sta	K+LO			; and save new one
 8619   7575   A9 00       		lda	#0			; pic offset is zero
 8620   7577   8D D1 73    		sta	P_LOFF			; done
 8621   757A   68          		pla				; get start X back
 8622   757B   85 00       		sta	SCRCX			; restored
 8623   757D   68          		pla				; get X reg back
 8624   757E   AA          		tax
 8625   757F   60          		rts	
 8626                      	
 8627   7580               	PIC2SCR:
 8628   7580   A9 04       		lda	#4			; 4 bits per pixel
 8629   7582   85 6F       		sta	ARG7			; use zero page
 8630   7584   B1 7C       		lda	(K),Y			; get data byte
 8631   7586   CD DE 73    		cmp	TRANSCLR		; is it transparent?
 8632   7589   D0 1D       		bne	CPYPL1			; nope
 8633   758B               	P2LOOP:
 8634   758B   E6 00       	        inc     SCRCX                   ; point to next pixel
 8635   758D   C8          		iny				; next pixel
 8636   758E   CC D8 73    		cpy	PICINFO+PLDWID		; done with line?
 8637   7591   B0 07       		bcs	P2LP1			; yup
 8638   7593   B1 7C       		lda	(K),Y			; get it
 8639   7595   CD DE 73    		cmp	TRANSCLR		; still transparent?
 8640   7598   F0 F1       		beq	P2LOOP			; ayyup
 8641   759A               	P2LP1:
 8642   759A   84 0E       		sty	NY_DATA 		; show where we ended up
 8643   759C   60          	      	rts
 8644   759D               	P2SLOOP:
 8645   759D   B1 7C       		lda	(K),Y			; get data byte
 8646   759F   CD DE 73    		cmp	TRANSCLR		; is it transparent?
 8647   75A2   F0 35       		beq	CPYSL1X			; yes, so done with this
 8648   75A4   A0 04       		ldy	#4			; 4 bits per pixel
 8649   75A6   84 6F       		sty	ARG7			; use zero page
 8650   75A8               	CPYPL1:
 8651   75A8   0A          		asl	A			; shift to upper nybble
  Wed May 24 1989 15:00                                                                                                  Page  132

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8652   75A9   0A          		asl	A			; shift to upper nybble
 8653   75AA   0A          		asl	A			; shift to upper nybble
 8654   75AB   0A          		asl	A			; shift to upper nybble
 8655   75AC               	CPYSL:
 8656   75AC   0A          		asl	A			; shift into carry
 8657   75AD   66 13       		ror	SCR_DATA		; pick up carry
 8658   75AF   CA          		dex				; count it
 8659   75B0   D0 12       		bne	CPYSL1			; shift again, please
 8660   75B2               	CPYSLST:
 8661   75B2   48          		pha				; save byte
 8662   75B3   A5 13       		lda	SCR_DATA		; get screen  byte
 8663   75B5   4A          		lsr	A			; move down to last 7 bits
 8664   75B6   E6 0F       		inc	CH_OFFSET			; point to interesting byte
 8665   75B8   A4 0F       		ldy	CH_OFFSET			; get offset
 8666   75BA   99 00 1F    		sta	SCR_LINE,Y		; save into mem
 8667   75BD   A2 07       		ldx	#7			; and start bitoff at 7
 8668   75BF   A9 00       		lda	#0			; clear a few locals
 8669   75C1   85 13       		sta	SCR_DATA		; screen data
 8670   75C3   68          		pla				; get byte back
 8671   75C4               	CPYSL1:
 8672   75C4   C6 6F       		dec	ARG7			; count this bit
 8673   75C6   30 25       		bmi	CPYSLX			; all done
 8674   75C8   D0 E2       		bne	CPYSL			; not done with 'pixel' yet
 8675   75CA   E6 0E       		inc	NY_DATA 		; point to next one
 8676   75CC   E6 00       	        inc     SCRCX                   ; point to next pixel
 8677   75CE   A4 0E       		ldy	NY_DATA 		; next pixel
 8678   75D0   CC D8 73    		cpy	PICINFO+PLDWID		; finished with line yet?
 8679   75D3   F0 04       		beq 	CPYSL1X			; yes, so move to screen
 8680   75D5   C6 10       		dec	DATALOOP		; reached right edge of screen?
 8681   75D7   D0 C4       		bne	P2SLOOP			; do next pixel
 8682   75D9               	CPYSL1X:
 8683   75D9   BD E4 71    		lda	BIT_BITS,X		; get me number of significant bits in this byte
 8684   75DC   8D D5 71    		sta	ENDBIT			; show end bit
 8685   75DF   E0 07       		cpx	#7			; is there a last byte to use?
 8686   75E1   F0 0A       		beq	CPYSLX			; no last byte
 8687   75E3   A5 13       		lda	SCR_DATA		; get screen data
 8688   75E5               	CPYLSH:
 8689   75E5   4A          		lsr	A			; put down low, please
 8690   75E6   CA          		dex				; one more
 8691   75E7   D0 FC       		bne	CPYLSH			; and do it again
 8692   75E9   85 13       		sta	SCR_DATA		; save for later use
 8693   75EB   F0 C5       		beq	CPYSLST			; now save this char
 8694   75ED               	CPYSLX:
 8695   75ED   4C 2F 61    		jmp	COPY_SCRL1		; copy to screen
 8696                      	
 8697   75F0               	NEXT_PICB:
 8698   75F0   48          		pha				; save a please
 8699                      	
 8700   75F1   CE D0 73    		dec	P_BCNT			; done all four pages?
 8701   75F4   D0 1E       		bne	NXTPX1			; nope
 8702                      	
 8703   75F6   A9 03       	        lda     #RETRY_COUNT            ; set retry
 8704   75F8   85 16       	        sta     RETRIES                 ; just use this for now
 8705                      	
 8706   75FA   A9 08       		lda	#>IOBUFF		; reset data buffer address
 8707   75FC   85 7F       		sta	L+HI
 8708   75FE   A9 00       		lda	#<IOBUFF
 8709   7600   85 7E       		sta	L+LO
 8710   7602   A9 04       		lda	#4			; 4 pages read in at once
 8711   7604   8D D0 73    		sta	P_BCNT			; okay
 8712   7607               	NXTPRD:
 8713   7607               		READ	PFILE_RD		; read in 1kb worth of data
 8714   7607               		PRODOS	$CA, PFILE_RD
 8715   7607   20 00 BF    		jsr	$BF00	; ProDOS handler
 8716   760A   CA          		DB	$CA	; ProDOS function code
 8717   760B   BE73        		DW	PFILE_RD	; Function Parameter Block address
 8718   760D               		.MACEND
 8719   760D               		.MACEND
 8720   760D   90 07       		bcc	NXTPX			; everything went just fine
 8721   760F   20 07 47    	        jsr     RETRY                   ; try again?
 8722   7612   90 F3       		bcc     NXTPRD                  ; okay, do it again
 8723   7614               	NXTPX1:
 8724   7614   E6 7F       		inc	L+HI			; point to next page
 8725   7616               	NXTPX:
 8726   7616   18          		clc				; make sure carry is clear
  Wed May 24 1989 15:00                                                                                                  Page  133

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8727   7617               	NXTPXR:
 8728   7617   A0 00       		ldy	#0			; start reading at beginnig of block
 8729   7619   68          		pla				; get [A] back
 8730   761A   60          		rts				; done
 8731                      	;
 8732                      	; GET_PDATA - go out and check the just opened file to see what kind,
 8733                      	;       if any, of picture data it has.  
 8734                      	;  [A] = REFNUM of the freshly opened file
 8735                      	;
 8736                      	
 8737   761B               	GET_PDATA:
 8738   761B   8D CD 73    	        sta     PF_REFNUM               ; save refnum for later usage
 8739   761E   A5 1F       	        lda     DSEGS+HI                ; save old one
 8740   7620   48          	        pha
 8741   7621   A5 1E       	        lda     DSEGS+LO
 8742   7623   48          	        pha
 8743   7624   AC C5 49    	        ldy     SAVENUM                 ; which file are we talking about
 8744   7627   88          	        dey                             ; zero base it
 8745   7628   98          	        tya
 8746   7629   29 0F       	        and     #$0F                    ; make sure DSEG is set
 8747   762B   0A          	        asl     A                       ; *2 for words
 8748   762C   A8          	        tay                             ; make it  index again
 8749   762D   B9 D1 1D    	        lda     DSKSEG+HI,Y             ; get MSB
 8750   7630   85 1F       	        sta     DSEGS+HI
 8751   7632   B9 D0 1D    	        lda     DSKSEG+LO,Y             ; and LSB
 8752   7635   85 1E       	        sta     DSEGS+LO
 8753   7637   20 41 76    	        jsr     GO_GET_PDATA            ; actually do the work
 8754   763A   68          	        pla                             ; get old DSEG back
 8755   763B   85 1E       	        sta     DSEGS+LO     
 8756   763D   68          	        pla
 8757   763E   85 1F       	        sta     DSEGS+HI
 8758   7640               	GETPX:
 8759   7640   60          	        rts                             ; bye
 8760   7641               	GO_GET_PDATA:
 8761   7641   AD D2 73    	        lda     GBL_FLAG                ; is there already a global dir?
 8762   7644   D0 0A       	        bne     GTPG1                   ; yes, so don't check again
 8763   7646   A0 06       	        ldy     #SGTGPOF                ; first, check for global directory
 8764   7648   A9 DC       		lda	#>GBL_DIR		; start destination off here
 8765   764A   20 65 76    	        jsr     READ_IN_PDATA           ; go get global directory, if any
 8766   764D   8D D2 73    	        sta     GBL_FLAG                ; indicate whether there is a global
 8767   7650               	GTPG1:
 8768   7650   AD C5 49    	        lda     SAVENUM                 ; get which file is being opened
 8769   7653   29 0F       	        and     #$0F                    ; just make it binary
 8770   7655   CD CE 73    	        cmp     PF_FID                  ; same as the file we already have?
 8771   7658   F0 0A       	        beq     GETPGX                  ; yes, so don't bother
 8772   765A   A0 02       		ldy	#SGTPICOF		; point to picture offset
 8773   765C   A9 D0       		lda	#>PIC_DIR		; start destination off here
 8774   765E   20 65 76    	        jsr     READ_IN_PDATA           ; go get the data for local pictures
 8775   7661   8D D3 73    	        sta     PIC_FLAG                ; any picture data
 8776   7664               	GETPGX:
 8777   7664   60          	        rts
 8778                      	;
 8779                      	; READ_IN_PDATA - check for desired data being in file, and skip to it if
 8780                      	;       it is.  Then, read it in in 1Kb chunks, stashing it away into the
 8781                      	;       upper bank of the aux mem language card.
 8782                      	; Enter with:
 8783                      	;   [A] = Destination page
 8784                      	;   [Y] = Offset into Segment table 
 8785                      	;
 8786   7665               	READ_IN_PDATA:
 8787   7665   48          	        pha                             ; save destination page
 8788   7666   B1 1E       		lda	(DSEGS),Y		; get MSB
 8789   7668   8D CA 73    		sta	PFSEEK+SM_FPOS+2	; Byte 2
 8790   766B   C8          		iny				; point to LSB
 8791   766C   11 1E       		ora	(DSEGS),Y		; is there any pic data?
 8792   766E   D0 04       		bne	GTPD00			; yes
 8793   7670   68          	        pla                             ; get page back
 8794   7671   A9 00       	        lda     #0                      ; show not here
 8795   7673   60          	        rts                             ; nope
 8796   7674               	GTPD00:
 8797   7674   B1 1E       		lda	(DSEGS),Y		; get it for shifting
 8798   7676   0A          		asl	A			; *2
 8799   7677   8D C9 73    		sta	PFSEEK+SM_FPOS+1	; stash away
 8800   767A   2E CA 73    		rol	PFSEEK+SM_FPOS+2	; pick up carry
 8801   767D   A9 00       		lda	#0			; clear out MSB
  Wed May 24 1989 15:00                                                                                                  Page  134

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8802   767F   8D C3 73    		sta	PFILE_RD+RD_BUFFLEN+HI
 8803   7682   8D C8 73    		sta	PFSEEK+SM_FPOS		; and LSB of seeking
 8804                      	
 8805   7685   AD CD 73    	        lda     PF_REFNUM               ; get file ref number
 8806   7688   8D BF 73    		sta	PFILE_RD+RD_REFNUM      ; and save it for reading and
 8807   768B   8D C7 73    		sta	PFSEEK+SM_REFNUM	; for seeking
 8808                      	
 8809   768E   A9 03       	        lda     #RETRY_COUNT    ; set retry
 8810   7690   85 0E       	        sta     NY_DATA         ; just use this for now
 8811   7692               	GTPDRD0:
 8812   7692               		SET_MARK PFSEEK			; and go to beginning
 8813   7692               		PRODOS	$CE, PFSEEK
 8814   7692   20 00 BF    		jsr	$BF00	; ProDOS handler
 8815   7695   CE          		DB	$CE	; ProDOS function code
 8816   7696   C673        		DW	PFSEEK	; Function Parameter Block address
 8817   7698               		.MACEND
 8818   7698               		.MACEND
 8819                      	
 8820   7698   A9 04       		lda	#4			; read in 4 256 blocks
 8821   769A   8D C3 73    		sta	PFILE_RD+RD_BUFFLEN+HI	
 8822   769D               		READ	PFILE_RD		; go get the next 4Kb worth
 8823   769D               		PRODOS	$CA, PFILE_RD
 8824   769D   20 00 BF    		jsr	$BF00	; ProDOS handler
 8825   76A0   CA          		DB	$CA	; ProDOS function code
 8826   76A1   BE73        		DW	PFILE_RD	; Function Parameter Block address
 8827   76A3               		.MACEND
 8828   76A3               		.MACEND
 8829   76A3   90 05       	        bcc     GTPD1                   ; fine
 8830   76A5   20 07 47    	        jsr     RETRY                   ; well, do it again?
 8831   76A8   90 E8       	        bcc     GTPDRD0                 ; yes
 8832   76AA               	GTPD1:
 8833   76AA   68          	        pla                             ; get destination page back
 8834   76AB   C9 D0       	        cmp     #>PIC_DIR               ; if doing local directory, set up
 8835   76AD   D0 16       	        bne     GTPD2                   ;  picture count
 8836   76AF   AE 04 08    		ldx	IOBUFF+PHNLD		; get number of pictures
 8837   76B2   8E CC 73    		stx	PICCNT+HI		; save for count down too
 8838   76B5   AE 05 08    		ldx	IOBUFF+PHNLD+1		; and here is LSB
 8839   76B8   8E CB 73    		stx	PICCNT+LO		; saving for counting
 8840   76BB   AE 00 08    	        ldx     IOBUFF+PHFID            ; get file ID
 8841   76BE   8E CE 73    	        stx     PF_FID                  ; and save for later
 8842   76C1   A2 20       	        ldx     #(256/PLDSIZE)          ; how many entries in 256 bytes
 8843   76C3   D0 0E       	        bne     GTPD3                   ; done
 8844   76C5               	GTPD2:
 8845   76C5   AE 00 08    	        ldx     IOBUFF                  ; get MSB of how many
 8846   76C8   8E CC 73    	        stx     PICCNT+HI               ; show me
 8847   76CB   AE 01 08    	        ldx     IOBUFF+1                ; get LSB of count
 8848   76CE   8E CB 73    	        stx     PICCNT+LO
 8849   76D1   A2 80       	        ldx     #(256/2)                ; how many entries / 256 bytes
 8850   76D3               	GTPD3:
 8851   76D3   8E 0A 77    	        stx     GTPMOD+1                ; set up how big entry is
 8852   76D6   8D 09 C0    		sta	ALTZP+AUX		; use aux mem for most of this
 8853   76D9   85 7D       		sta	K+HI			; MSB of destination
 8854   76DB   A9 00       	        lda     #0                      ; clear a few things
 8855   76DD   85 7A       		sta	J+LO			; J = source
 8856   76DF   85 7C       		sta	K+LO			; K = destination
 8857   76E1   A9 04       		lda	#4			; 4 * (4*256) bytes max
 8858   76E3   8D C3 73    		sta	PFILE_RD+RD_BUFFLEN+HI	; show the read too
 8859   76E6   8D CF 73    		sta	P_IDX			; save here for counting
 8860   76E9               	GTPDL:
 8861   76E9   A0 00       	        ldy     #0                      ; start y
 8862   76EB   A9 08       		lda	#>IOBUFF		; get where source is
 8863   76ED   85 7B       		sta	J+HI			; MSB of source
 8864   76EF   A9 04       		lda	#4			; 4 blocks worth of 256
 8865   76F1   8D D0 73    		sta	P_BCNT			; used as counter
 8866   76F4   AD 8B C0    		lda	BNK1SET			; we be using bank 1 @$D000
 8867   76F7   AD 8B C0    		lda	BNK1SET			; we be using bank 1 @$D000
 8868   76FA               	GTPDL1:
 8869   76FA   B1 7A       		lda	(J),Y			; get the data byte
 8870   76FC   91 7C       		sta	(K),Y			; store in upper aux
 8871   76FE   C8          		iny				; point to the next one
 8872   76FF   D0 F9       		bne	GTPDL1			; and go get it
 8873   7701               		
 8874   7701   E6 7B       		inc	J+HI			; next block please
 8875   7703   E6 7D       		inc	K+HI			; for destination too
 8876   7705   AD CB 73    		lda	PICCNT+LO		; how many entries?
  Wed May 24 1989 15:00                                                                                                  Page  135

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8877   7708   38          		sec				; doing sbc
 8878   7709   E9 20       	GTPMOD:	sbc	#(256/PLDSIZE)		; how many entries in 256 bytes?
 8879   770B   8D CB 73    		sta	PICCNT+LO		; save result
 8880   770E   B0 05       		bcs	GTPDL2			; no wrapping
 8881   7710   CE CC 73    		dec	PICCNT+HI		; wrap
 8882   7713   30 26       		bmi	GTPDLX			; all done if we go negative
 8883   7715               	GTPDL2:
 8884   7715   0D CC 73    		ora	PICCNT+HI		; make sure both are not zero
 8885   7718   F0 21       		beq	GTPDLX			; if they are, then we are done
 8886   771A   CE D0 73    		dec	P_BCNT			; count this block
 8887   771D   D0 DB       		bne	GTPDL1			; go fetch next 256 bytes
 8888   771F   8D 08 C0    		sta	ALTZP+MAIN		; swap back to main for read
 8889                      	
 8890   7722   A9 03       	        lda     #RETRY_COUNT    ; set retry
 8891   7724   85 0E       	        sta     NY_DATA         ; just use this for now
 8892   7726               	GTPDRD:
 8893   7726               		READ	PFILE_RD		; go get the next 4Kb worth
 8894   7726               		PRODOS	$CA, PFILE_RD
 8895   7726   20 00 BF    		jsr	$BF00	; ProDOS handler
 8896   7729   CA          		DB	$CA	; ProDOS function code
 8897   772A   BE73        		DW	PFILE_RD	; Function Parameter Block address
 8898   772C               		.MACEND
 8899   772C               		.MACEND
 8900   772C   90 05       	        bcc     GTPDRDG                 ; fine
 8901   772E   20 07 47    	        jsr     RETRY                   ; well, do it again?
 8902   7731   90 F3       	        bcc     GTPDRD                  ; yes
 8903   7733               	GTPDRDG:
 8904   7733   8D 09 C0    		sta	ALTZP+AUX		; and back to aux for working
 8905   7736   CE CF 73    		dec	P_IDX			; max 4Kb worth of reading
 8906   7739   D0 AE       		bne	GTPDL			; and read in more
 8907   773B               	GTPDLX:
 8908   773B   8D 08 C0    		sta	ALTZP+MAIN		; back to main bank of mem
 8909   773E   AD 83 C0    		lda	BNK2SET			; back to bank 2
 8910   7741   AD 83 C0    		lda	BNK2SET			; yes please
 8911   7744   A9 01       	        lda     #1                      ; show we found it
 8912   7746   60          		rts				; all done
 8913                      	
 8914   7747   00          	GTPFLAG: db 0				; if 1 when opening next file, then
 8915                      						; this is the next file, so unable to
 8916                      						; find picture number
 8917   7748               	GET_PICINF:
 8918   7748   A9 00       		lda	#0			; set flag for double check
 8919   774A   8D 47 77    		sta	GTPFLAG			; start at zero
 8920   774D               	GTPLOOP:
 8921   774D   A5 63       		lda	ARG1+LO			; check argument for zero
 8922   774F   05 64       		ora	ARG1+HI			; is it zero?
 8923   7751   D0 02       		bne	GTPINDX			; jump to look at first block
 8924   7753   18          		clc				; found some pictures
 8925   7754   60          		rts				; if zero, just give count
 8926   7755               	GTPINDX:
 8927   7755   A4 63       		ldy	ARG1+LO 		; get arg, as we are swapping
 8928   7757   A6 64       		ldx	ARG1+HI 		; to aux mem
 8929   7759   8D 09 C0    		sta	ALTZP+AUX		; look at AUX mem
 8930   775C   AD 8B C0    		lda	BNK1SET 		; bank 1
 8931   775F   AD 8B C0    		lda	BNK1SET 		; bank 1
 8932   7762   AD 04 D0    	        lda     PIC_DIR+PHNLD           ; get # of entries
 8933   7765   8D CC 73    	        sta     PICCNT+HI
 8934   7768   AD 05 D0    	        lda     PIC_DIR+PHNLD+1         ; it's in reverse order
 8935   776B   8D CB 73    	        sta     PICCNT+LO
 8936   776E   84 63       		sty	ARG1+LO 		; use aux mem zero page
 8937   7770   86 64       		stx	ARG1+HI 		; for new arg1
 8938   7772   A9 D0       		lda	#>PIC_DIR		; start at beginning of block
 8939   7774   85 8A       		sta	MPNTH			; hi part
 8940   7776   A9 00       		lda	#<PIC_DIR		; don't forget to start at beginning
 8941   7778   85 89       		sta	MPNTL			; we are
 8942   777A   A9 10       		lda	#PHSIZE                 ; skip over header
 8943   777C   8D CF 73    		sta	P_IDX			; this is the counter
 8944   777F               	GTP3:
 8945   777F   AC CF 73    		ldy	P_IDX			; get offset
 8946   7782   A5 64       		lda	ARG1+HI			; check against desired one
 8947   7784   D1 89       		cmp	(MPCPNT),Y		; get ID hi byte
 8948   7786   90 15       		bcc	GTPNOT			; arg1 < than entry, can't be here
 8949   7788   D0 09       		bne	GTP4			; not it, so check next one
 8950   778A   C8          		iny				; now to LSB
 8951   778B   B1 89       		lda	(MPCPNT),Y		; get it
  Wed May 24 1989 15:00                                                                                                  Page  136

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8952   778D   C5 63       		cmp	ARG1+LO			; is it what we want?
 8953   778F   F0 2D       		beq	GTPFOUND		; found the picture
 8954   7791   B0 0A       		bcs	GTPNOT			; arg1 < entry, cannot be here
 8955   7793               	GTP4:
 8956   7793   AD CB 73    		lda	PICCNT+LO		; get LSB
 8957   7796   D0 14       		bne	GTP4D			; no wrap down
 8958   7798   CE CC 73    		dec	PICCNT+HI		; count down MSB
 8959   779B   10 0F       		bpl	GTP4D			; everything still okay
 8960   779D               	GTPNOT:
 8961   779D   8D 08 C0    		sta	ALTZP+MAIN		; back to main mem
 8962   77A0   AD 83 C0    		lda	BNK2SET			; back to bank 1
 8963   77A3   AD 83 C0    		lda	BNK2SET			; yes please
 8964   77A6   20 D7 77    	        jsr     FIND_GBL                ; find picture in global dir
 8965   77A9   90 A2       	        bcc     GTPLOOP                 ; go try again
 8966   77AB   60          	        rts                             ; just show no goodness
 8967   77AC               	GTP4D:	
 8968   77AC   CE CB 73    		dec	PICCNT+LO		; count this entry
 8969   77AF   AD CF 73    		lda	P_IDX			; get index
 8970   77B2   18          		clc				; ready to add
 8971   77B3   69 08       		adc	#PLDSIZE		; point to next entry
 8972   77B5   8D CF 73    		sta	P_IDX			; save lo part
 8973   77B8   90 C5       		bcc	GTP3			; no wrap
 8974   77BA   E6 8A       		inc	MPNTH			; next block
 8975   77BC   D0 C1       		bne	GTP3			; do next block
 8976   77BE               	GTPFOUND:
 8977   77BE   A2 00       		ldx	#0			; for copying data
 8978   77C0   88          		dey				; point to beginning of data
 8979   77C1               	GTPFL:
 8980   77C1   B1 89       		lda	(MPCPNT),Y		; get data
 8981   77C3   9D D6 73    		sta	PICINFO,X		; save data
 8982   77C6   C8          		iny				; point to new entry stuff
 8983   77C7   E8          		inx				; next x
 8984   77C8   E0 08       		cpx	#PLDSIZE		; got it all yet (not ID, tho)?
 8985   77CA   D0 F5       		bne	GTPFL			; get data
 8986   77CC   8D 08 C0    		sta	ALTZP+MAIN		; back to main mem
 8987   77CF   AD 83 C0    		lda	BNK2SET			; back to bank 2
 8988   77D2   AD 83 C0    		lda	BNK2SET			; yes please
 8989   77D5   18          		clc				; show got data
 8990   77D6   60          		rts
 8991                      	;
 8992                      	; FIND_GBL - check the global directory for the picture in question.  If there
 8993                      	;       isn't a global directory, just open the other file.  Return with carry 
 8994                      	;       set if either not in global directory, or the other file has already
 8995                      	;       been opened.
 8996                      	;
 8997   77D7               	FIND_GBL:
 8998   77D7   AD 47 77    		lda	GTPFLAG			; have we already tried to open another file?
 8999   77DA   EE 47 77    		inc	GTPFLAG			; show trying next file
 9000   77DD   A8          	        tay                             ; check flag
 9001   77DE   D0 0A       		bne     GTPNOT1                 ; we already should have found it
 9002   77E0   AD D2 73    	        lda     GBL_FLAG                ; do we have global dir?
 9003   77E3   D0 07       	        bne     FG1                     ; yes, so look for picture there
 9004                      	;
 9005                      	; otherwise, just check the other file
 9006                      	;
 9007   77E5   20 16 79    		jsr	NEXTPICF		; open other picture file
 9008   77E8   18          	        clc
 9009   77E9   60          	        rts
 9010   77EA               	GTPNOT1:
 9011   77EA   38          	        sec                             ; show badness
 9012   77EB   60          	        rts
 9013                      	;
 9014                      	; go find the picture in the global directory file
 9015                      	;
 9016   77EC               	FG1:
 9017   77EC   A4 63       		ldy	ARG1+LO 		; get arg, as we are swapping
 9018   77EE   A6 64       		ldx	ARG1+HI 		; to aux mem
 9019   77F0   8D 09 C0    		sta	ALTZP+AUX		; look at AUX mem
 9020   77F3   AD 8B C0    		lda	BNK1SET 		; bank 1
 9021   77F6   AD 8B C0    		lda	BNK1SET 		; bank 1 is where the directory is
 9022   77F9   AD 00 DC    	        lda     GBL_DIR                 ; MSB of count
 9023   77FC   8D CC 73    	        sta     PICCNT+HI
 9024   77FF   AD 01 DC    	        lda     GBL_DIR+1               ; LSB of count
 9025   7802   8D CB 73    	        sta     PICCNT+LO               
 9026   7805   84 63       	        sty     ARG1+LO                 ; restore args
  Wed May 24 1989 15:00                                                                                                  Page  137

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 9027   7807   86 64       	        stx     ARG1+HI         
 9028   7809   A9 DC       		lda	#>GBL_DIR		; start at beginning of block
 9029   780B   85 8A       		sta	MPNTH			; hi part
 9030   780D   A9 00       		lda	#<GBL_DIR		; don't forget to start at beginning
 9031   780F   85 89       		sta	MPNTL			; we are
 9032   7811   A9 02       	        lda     #2                      ; start at 2nd word, skipping
 9033   7813   8D CF 73    	        sta     P_IDX                   ; the count byte
 9034   7816               	FGLOOP:
 9035   7816   EE CF 73    	        inc     P_IDX                   ; point to LSB
 9036   7819   AC CF 73    		ldy	P_IDX			; get offset
 9037   781C   B1 89       	        lda     (MPCPNT),Y              ; get global lo byte
 9038   781E   C5 63       	        cmp     ARG1+LO                 ; same as desired one?
 9039   7820   D0 0F       	        bne     FGNOT                   ; nope
 9040   7822   88          	        dey                             ; point to ID MSB
 9041   7823   B1 89       	        lda     (MPCPNT),Y              ; get global MSB
 9042   7825   29 03       	        and     #$03                    ; lower two bits are upper ID part
 9043   7827   C5 64       	        cmp     ARG1+HI                 ; same as desired one?
 9044   7829   D0 06       	        bne     FGNOT                   ; nope
 9045   782B   B1 89       	        lda     (MPCPNT),Y              ; get disk map
 9046   782D   A8          	        tay                             ; save in Y
 9047   782E   18          	        clc                             ; ready for return
 9048   782F   90 1A       	        bcc     FTNX                    ; and done
 9049   7831               	FGNOT:
 9050   7831   AD CB 73    	        lda     PICCNT+LO               ; wrap?
 9051   7834   D0 08       	        bne     FTN1                    ; nope
 9052   7836   AD CC 73    	        lda     PICCNT+HI               ; already zero?
 9053   7839   F0 0F       	        beq     FTNOTFOUND              ; sorry, it ain't anywhere
 9054   783B   CE CC 73    	        dec     PICCNT+HI               ; count down the wrap
 9055   783E               	FTN1:
 9056   783E   CE CB 73    	        dec     PICCNT+LO               ; count down towards the end
 9057   7841   EE CF 73    	        inc     P_IDX                   ; point to next entry
 9058   7844   D0 D0       	        bne     FGLOOP                  ; no wrap to next page
 9059   7846   E6 8A       	        inc     MPNTH                   ; point to next page
 9060   7848   D0 CC       	        bne     FGLOOP                  ; and continue
 9061   784A               	FTNOTFOUND:
 9062   784A   38          	        sec                             ; show not found
 9063   784B               	FTNX:
 9064   784B   8D 08 C0    		sta	ALTZP+MAIN		; back to main mem
 9065   784E   AD 83 C0    		lda	BNK2SET			; back to bank 2
 9066   7851   AD 83 C0    		lda	BNK2SET			; yes please
 9067   7854   90 01       	        bcc     FTNXX                   ; go find it then
 9068   7856   60          	        rts                             ; done
 9069   7857               	FTNXX:
 9070                      	;
 9071                      	; FIND_PICDISK - we have figgered out that the pictures exists somewhere,
 9072                      	;       so parse the passed disk number and go get that disk.
 9073                      	;       First, check to make sure the disk isn't just the other one that
 9074                      	;       is in there.  If it isn't, just use the last one that it is on.
 9075                      	;
 9076                      	;  [Y] = bit 7-2 is the 6 bit disk map
 9077                      	;
 9078   7857               	FIND_PICDISK:
 9079   7857   98          	        tya                             ; get into more useful register        
 9080   7858   4A          	        lsr     A                       ; bring down to lower part
 9081   7859   4A          	        lsr     A                       ; all set up
 9082   785A   8D CF 73    	        sta     P_IDX                   ; save for later looking
 9083   785D   A2 31       	        ldx     #'1'                    ; begin at file 1
 9084   785F   8E D5 73    		stx	PF_NAME+1		; both places
 9085   7862   E8          		inx				; start counter off at 2
 9086   7863   8E D4 73    	        stx     PF_NAME                 ; and save it
 9087   7866   A2 06       	        ldx     #6                      ; 6 possible disks
 9088   7868               	FNDPL:
 9089   7868   6E CF 73    	        ror     P_IDX                   ; put bit into carry
 9090   786B   90 16       	        bcc     FNDPL1                  ; not here
 9091   786D   AD D4 73    	        lda     PF_NAME                 ; get name we are looking at
 9092   7870   8D D5 73    	        sta     PF_NAME+1               ; save found name
 9093   7873   AC 77 46    	        ldy     GAME1NML                ; get name length
 9094   7876   D9 77 46    	        cmp     GAME1NM,Y               ; compare to last char
 9095   7879   F0 0E       	        beq     FNDP1                   ; found it
 9096   787B   AC 89 46    	        ldy     GAME2NML                ; how 'bout in disk 2?
 9097   787E   D9 89 46    	        cmp     GAME2NM,Y               ; well?
 9098   7881   F0 06       	        beq     FNDP1                   ; yes, it's already in there
 9099   7883               	FNDPL1:
 9100   7883   EE D4 73    	        inc     PF_NAME                 ; next name
 9101   7886   CA          	        dex                             ; count down
  Wed May 24 1989 15:00                                                                                                  Page  138

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 9102   7887   D0 DF       	        bne     FNDPL                   ; still more to look at
 9103   7889               	FNDP1:
 9104   7889   AD D5 73    	        lda     PF_NAME+1               ; get file name
 9105   788C   29 07       	        and     #$07                    ; make it non-ascii
 9106   788E   A8          	        tay                             ; put in Y for routine
 9107   788F   88          	        dey                             ; and make it zero relative
 9108   7890   4C 26 79    	        jmp     OPEN_NEW_PF             ; go get it
 9109                      	;
 9110                      	; ZPICNF - YZIP call to get just the picture info
 9111                      	;
 9112   7893               	ZPICNF:
 9113   7893   20 48 77    		jsr	GET_PICINF		; find the info
 9114   7896   B0 7A       		bcs	ZPICNFX			; not found
 9115                      	;
 9116                      	; being here means we found the picture
 9117                      	;
 9118   7898   A5 65       		lda	ARG2+LO			; lsb is okay
 9119   789A   85 8F       		sta	SPCL			; right
 9120   789C   A5 66       		lda	ARG2+HI			; get page
 9121   789E   20 77 8F    		jsr	SETPC			; get where it is
 9122   78A1   85 90       		sta	SPCH			; hi
 9123   78A3   84 91       		sty	SPCBNK			; bnak
 9124   78A5   A5 64       		lda	ARG1+HI			; get argumnet
 9125   78A7   05 63       		ora	ARG1+LO			; check for zero arg
 9126   78A9   D0 45       		bne	ZPIC1			; okay, get picture data
 9127                      	;
 9128                      	; arg1 == 0, just return number of entries
 9129                      	;
 9130   78AB   8D 09 C0    		sta	ALTZP+AUX		; look at AUX mem
 9131   78AE   AD 8B C0    		lda	BNK1SET 		; bank 1
 9132   78B1   AD 8B C0    		lda	BNK1SET 		; bank 1
 9133   78B4   AD 0C D0    	        lda     PIC_DIR+PHFVERS		; get version number
 9134   78B7   8D CF 73    		sta	P_IDX			; just save here
 9135   78BA   AD 0D D0    	        lda     PIC_DIR+PHFVERS+1	; now for the LSB
 9136   78BD   8D D0 73    		sta	P_BCNT			; and here
 9137   78C0   AC 0A D0    		ldy	PIC_DIR+PHCHKS		; MSB of checksum
 9138   78C3   AD 0B D0    		lda	PIC_DIR+PHCHKS+1	; and LSB
 9139   78C6   8D 08 C0    		sta	ALTZP+MAIN		; back to main mem
 9140   78C9   AE 83 C0    		ldx	BNK2SET			; back to bank 2
 9141   78CC   AE 83 C0    		ldx	BNK2SET			; yes please
 9142   78CF   48          	        pha                             ; save LSB
 9143   78D0   98          	        tya                             ; put MSB into [A]        
 9144   78D1   20 35 92    		jsr	STASHB			; and save it
 9145   78D4   20 9E 8F    		jsr	NEXTSPC			; point to LSB in table
 9146   78D7   68          	        pla                             ; get LSB back
 9147   78D8   20 35 92    		jsr	STASHB			; and save it
 9148   78DB   20 9E 8F    		jsr	NEXTSPC			; point to Version number
 9149   78DE   AD D0 73    		lda	P_BCNT			; now for version
 9150   78E1   20 35 92    		jsr	STASHB			; give it to game
 9151   78E4   20 9E 8F    		jsr	NEXTSPC			; now for LSB
 9152   78E7   AD CF 73    		lda	P_IDX			; this is where it is
 9153   78EA   20 35 92    		jsr	STASHB			; and away it goes
 9154   78ED   4C 3B 44    		jmp	PREDS			; and show success		
 9155   78F0               	ZPIC1:
 9156   78F0   A9 00       		lda	#0			; height MSB
 9157   78F2   20 35 92    		jsr	STASHB			; save it too
 9158   78F5   20 9E 8F    		jsr	NEXTSPC			; next byte
 9159   78F8   AD D9 73    		lda	PICINFO+PLDHGHT		; height LSB
 9160   78FB   20 35 92    		jsr	STASHB			; save it too
 9161   78FE   20 9E 8F    		jsr	NEXTSPC			; next byte
 9162   7901   A9 00       		lda	#0			; width first
 9163   7903   20 35 92    		jsr	STASHB			; put it there
 9164   7906   20 9E 8F    		jsr	NEXTSPC			; continue
 9165   7909   AD D8 73    		lda	PICINFO+PLDWID		; LSB of width
 9166   790C   20 35 92    		jsr	STASHB			; save it too
 9167   790F   4C 3B 44    		jmp	PREDS
 9168   7912               	ZPICNFX:
 9169   7912   4C 2F 44    		JMP	PREDF	; SET AS BAD
 9170   7915               	ZDCLR:
 9171   7915               	ZPICSET:
 9172   7915   60          		rts				; NOT IMPLEMENTED YET
 9173                      	;
 9174                      	; NEXTPICF - Just toggle between files 3/4 for those slim and trim games
 9175                      	;       that have pictures only on those 2 disks.
 9176                      	;
  Wed May 24 1989 15:00                                                                                                  Page  139

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 9177   7916               	NEXTPICF:
 9178   7916   A0 03       	        ldy     #3                      ; pretend we want file #4
 9179   7918   AE 89 46    		ldx	GAME2NML		; get length of name
 9180   791B   BD 89 46    		lda	GAME2NM,X		; get last number
 9181   791E   C9 33       		cmp	#'3'			; if 3, then open #4
 9182   7920   F0 01       		beq	NXTPF1			; yes
 9183   7922   88          	        dey                             ; no, so point to 3 then
 9184   7923               	NXTPF1:
 9185   7923   4C 26 79    	        jmp     OPEN_NEW_PF             ; and open the new pic file
 9186                      	;
 9187                      	; OPEN_NEW_PF - open the file so we can pick up new picture data
 9188                      	;
 9189                      	;   [Y] - # of file to be pointed to (0-n)
 9190                      	;
 9191   7926               	OPEN_NEW_PF:
 9192   7926   A5 1F       		lda	DSEGS+HI		; save current DSEG
 9193   7928   48          		pha
 9194   7929   A5 1E       		lda	DSEGS+LO
 9195   792B   48          		pha
 9196   792C   AD CF 45    		lda	GMREF			; to go back to this one
 9197   792F   48          		pha
 9198                      	;
 9199                      	; now, set up DSEGS to point to correct segment table
 9200                      	;
 9201   7930   98          	        tya                             ; get to muck
 9202   7931   0A          		asl	A		        ; make word index
 9203   7932   AA          		tax			        ; make it an index
 9204   7933   BD D0 1D    		lda	DSKSEG+LO,X	        ; get LSB
 9205   7936   85 1E       		sta	DSEGS+LO
 9206   7938   BD D1 1D    		lda	DSKSEG+HI,X             ; and MSB
 9207   793B   85 1F       		sta	DSEGS+HI
 9208   793D   98          	        tya                             ; point to the new file
 9209   793E   20 C6 49    		jsr	FETCH_FILE		; and do it
 9210   7941   8C CD 73    	        sty     PF_REFNUM               ; save refnum, please
 9211   7944   20 41 76    	        jsr     GO_GET_PDATA            ; just make sure pic data is gotten    
 9212   7947               	OPENPF1:
 9213   7947   68          		pla				; get old ref num back
 9214   7948   8D CF 45    		sta	GMREF			; and for reading
 9215   794B   8D DD 45    		sta	PSEEK+SM_REFNUM 	; this sets it up for set marking
 9216   794E   68          		pla				; get old DSEG back
 9217   794F   85 1E       		sta	DSEGS+LO
 9218   7951   68          		pla
 9219   7952   85 1F       		sta	DSEGS+HI
 9220   7954   18          	        clc                             ; show it worked
 9221   7955   60          		rts
 9222                      	
 9223   7956               		END
 9224                      	
 9225                      	
 9226   7956               		TITLE 	"APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
 9227   7956               		INCLUDE 	OPS012.ASM
 9228   7956               		STTL "--- 0-OPS ---"
 9229                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page  140

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 0-OPS ---"

 9230                      	
 9231                      	
 9232                      	; -----
 9233                      	; RTRUE
 9234                      	; -----
 9235                      	; SIMULATE A "RETURN 1"
 9236                      	
 9237   7956   A2 01       	ZRTRUE:	LDX	#1	
 9238   7958   A9 00       	ZRT0:	LDA	#0	
 9239   795A   86 63       	ZRT1:	STX	ARG1+LO	; GIVE TO
 9240   795C   85 64       		STA	ARG1+HI	; [ARG1]
 9241   795E   4C 56 7B    		JMP	ZRET	; AND DO THE RETURN
 9242                      	
 9243                      	
 9244                      	; ------
 9245                      	; RFALSE
 9246                      	; ------
 9247                      	; SIMULATE A "RETURN 0"
 9248                      	
 9249   7961   A2 00       	ZRFALS:	LDX	#0	
 9250   7963   F0 F3       		BEQ	ZRT0	
 9251                      	
 9252                      	
 9253                      	; ------
 9254                      	; PRINTI
 9255                      	; ------
 9256                      	; PRINT Z-STRING FOLLOWING THE OPCODE
 9257                      	
 9258   7965   A2 05       	ZPRI:	LDX	#5	;MOVE ZPC INTO MPC
 9259   7967               	ZPRI1:			
 9260   7967   B5 80       		LDA	ZPC,X	
 9261   7969   95 86       		STA	MPC,X	
 9262   796B   CA          		DEX		
 9263   796C   10 F9       		BPL	ZPRI1	;NO NEED TO VALIDATE AS ZPC WAS VALID ANYWAY
 9264   796E   20 CE 92    		JSR	PZSTR	; PRINT THE Z-STRING AT [MPC]
 9265   7971   A2 05       		LDX	#5	; COPY STATE OF [MPC]
 9266   7973   B5 86       	ZPRI2:	LDA	MPC,X	; INTO [ZPC]
 9267   7975   95 80       		STA	ZPC,X	
 9268   7977   CA          		DEX		
 9269   7978   10 F9       		BPL	ZPRI2	
 9270   797A   60          		RTS		
 9271                      	
 9272                      	
 9273                      	; ------
 9274                      	; PRINTR
 9275                      	; ------
 9276                      	; DO A "PRINTI," FOLLOWED BY "CRLF" AND "RTRUE"
 9277                      	
 9278   797B   20 65 79    	ZPRR:	JSR	ZPRI	
 9279   797E   20 CC 54    		JSR	ZZCRLF	
 9280   7981   4C 56 79    		JMP	ZRTRUE	
 9281                      	
 9282                      	
 9283                      	; ------
 9284                      	; RSTACK
 9285                      	; ------
 9286                      	; "RETURN" WITH VALUE ON STACK
 9287                      	
 9288   7984   20 66 43    	ZRSTAK:	JSR	POPVAL	; GET VALUE INTO [X/A]
 9289   7987   4C 5A 79    		JMP	ZRT1	; AND GIVE IT TO "RETURN"
 9290                      	
 9291                      	
 9292                      	; -----
 9293                      	; CATCH
 9294                      	; -----
 9295                      	
 9296   798A   AE 76 6C    	ZCATCH:	LDX	OLDZSP+HI	; RETURN ZSTACK POINTER AS
 9297   798D   AD 75 6C    		LDA	OLDZSP+LO	; ZRET WILL NEED IT
 9298   7990   4C DD 43    		JMP	PUTBYT
 9299                      	
 9300                      	
 9301                      	; ---------
 9302                      	; ORIGINAL?
 9303                      	; ---------
 9304                      	
  Wed May 24 1989 15:00                                                                                                  Page  141

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 0-OPS ---"

 9305                      	; COPY PROTECTION DEVICE, RETURNS TRUE FOR NOW
 9306                      	
 9307   7993   4C 3B 44    	ZORIG:	JMP	PREDS
 9308                      	
 9309                      	
 9310   7996               		STTL "--- 1-OPS ---"
 9311                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page  142

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9312                      	
 9313                      	
 9314                      	; -----
 9315                      	; ZERO?
 9316                      	; -----
 9317                      	; [ARG1] = 0?
 9318                      	
 9319   7996   A5 63       	ZZERO:	LDA	ARG1+LO	
 9320   7998   05 64       		ORA	ARG1+HI	
 9321   799A   F0 37       		BEQ	PFINE	
 9322   799C   4C 2F 44    	PYUCK:	JMP	PREDF	
 9323                      	
 9324                      	
 9325                      	; -----
 9326                      	; NEXT?
 9327                      	; -----
 9328                      	; RETURN "NEXT" POINTER IN OBJECT [ARG1] ;
 9329                      	; FAIL IF LAST AND RETURN ZERO
 9330                      	
 9331   799F               	ZNEXT:
 9332   799F   A5 63       		LDA	ARG1+LO	
 9333   79A1   A6 64       		LDX	ARG1+HI	; (EZIP)
 9334   79A3   20 EC 94    		JSR	OBJLOC	; GET OBJECT ADDR INTO [FPC]
 9335   79A6   A9 08       		lda	#8	; POINT TO "NEXT" SLOT (EZIP)
 9336   79A8   20 DE 8F    		jsr	ADDFPC	; and point to it
 9337   79AB   4C BA 79    		jmp	FIRST1	; JMP to get it
 9338                      	
 9339                      	; ------
 9340                      	; FIRST?
 9341                      	; ------
 9342                      	; RETURN "FIRST" POINTER IN OBJECT [ARG1] ;
 9343                      	; FAIL IF LAST AND RETURN ZERO
 9344                      	; (EZIP ALTERATIONS)
 9345                      	
 9346   79AE               	ZFIRST:
 9347   79AE   A5 63       		lda	ARG1+LO	
 9348   79B0   A6 64       		ldx	ARG1+HI	
 9349   79B2   20 EC 94    		jsr	OBJLOC	; GET OBJECT ADDR INTO [FPC]
 9350   79B5   A9 0A       		lda	#10	; point to "First" slot
 9351   79B7   20 DE 8F    		jsr	ADDFPC	; and add it
 9352   79BA               	FIRST1:
 9353   79BA   20 56 92    		jsr	FETCHB	; and get it
 9354   79BD   48          		pha		; save it
 9355   79BE   20 BE 8F    		jsr	NEXTFPC
 9356   79C1   20 56 92    		jsr	FETCHB	; and next one
 9357   79C4   A8          		tay		; now dance around a little; save LSB
 9358   79C5   68          		pla		; get MSB back
 9359   79C6   AA          		tax		; and put to x
 9360   79C7   98          		tya		; and put LSB back into [A]
 9361   79C8   20 DD 43    		jsr	PUTBYT	; PASS IT TO VARIABLE
 9362   79CB   A5 76       		lda	VALUE+LO	; EXAMINE THE VALUE JUST "PUT"
 9363   79CD   D0 04       		bne	PFINE	
 9364   79CF   A5 77       		lda	VALUE+HI	
 9365   79D1   F0 C9       		beq	PYUCK	; FAIL IF IT WAS ZERO
 9366   79D3               	PFINE:
 9367   79D3   4C 3B 44    		jmp	PREDS	; ELSE REJOICE
 9368                      	
 9369                      	; ---
 9370                      	; LOC
 9371                      	; ---
 9372                      	; RETURN THE OBJECT CONTAINING OBJECT [ARG1] ;
 9373                      	; RETURN ZERO IF NONE
 9374                      	; (EZIP ALTERED)
 9375                      	
 9376   79D6               	ZLOC:
 9377   79D6   A5 63       		lda	ARG1+LO	
 9378   79D8   A6 64       		ldx	ARG1+HI	
 9379   79DA   E0 20       		cpx	#$20	; don't let it get too high
 9380   79DC   90 05       		bcc	ZLOC1	; fine
 9381   79DE   A9 16       		lda	#22	; too big object
 9382   79E0   4C 0A 52    		jmp	ZERROR	; and die
 9383   79E3               	ZLOC1:
 9384   79E3   20 EC 94    		jsr	OBJLOC	; GET ADDR OF OBJECT INTO [FPC]
 9385   79E6   A9 06       		lda	#6	; POINT TO "LOC" SLOT
 9386   79E8   20 DE 8F    		jsr	ADDFPC	; and make FPC point there
  Wed May 24 1989 15:00                                                                                                  Page  143

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9387   79EB   20 56 92    		jsr	FETCHB	; go get byte
 9388   79EE   48          		pha		; save this please
 9389   79EF   20 BE 8F    		jsr	NEXTFPC	; and point to next one
 9390   79F2   20 56 92    		jsr	FETCHB	; and get it in [A]
 9391   79F5   A8          		tay		; save LSB
 9392   79F6   68          		pla		; get MSB back
 9393   79F7   AA          		tax		; and put to [X]
 9394   79F8   98          		tya		; and put LSB into a
 9395   79F9   4C DD 43    		jmp	PUTBYT	; AND SHIP IT OUT
 9396                      	
 9397                      	; ------
 9398                      	; PTSIZE
 9399                      	; ------
 9400                      	; RETURN LENGTH OF PROP TABLE [ARG1] IN BYTES
 9401                      	
 9402   79FC               	ZPTSIZ:
 9403   79FC   A5 64       		lda	ARG1+HI		; MOVE ABS ADDR OF
 9404   79FE   20 77 8F    		jsr	SETPC		; get bank/page
 9405   7A01   85 8D       		sta	FPCH		; save page
 9406   7A03   84 8E       		sty	FPCBNK		; and bank
 9407   7A05   A5 63       		lda	ARG1+LO
 9408   7A07   85 8C       		sta	FPCL		; and save lo part
 9409   7A09   20 24 90    		jsr	PREVFPC		; Decrement address while moving LSB
 9410   7A0C               	PTZ0:
 9411   7A0C   20 56 92    		jsr	FETCHB		; get length of property
 9412   7A0F   30 0C       		bmi	PTZ2		; BIT 7 = 1, LENGTH > 2 BYTES
 9413   7A11   29 40       		and	#%01000000
 9414   7A13   F0 04       		beq	PTZ1		; BIT 6 = 0, LENGTH = 1
 9415   7A15   A9 02       		lda	#2		; BIT 6 = 1, LENGTH = 2
 9416   7A17   D0 09       		bne	PTZ3		; JMP
 9417   7A19               	PTZ1:
 9418   7A19   A9 01       		lda	#1
 9419   7A1B   D0 05       		bne	PTZ3		; JMP
 9420   7A1D               	PTZ2:
 9421   7A1D   20 56 92    		jsr	FETCHB		; and get it
 9422   7A20   29 3F       		and	#%00111111	; ELSE PICK UP SIZE > 2
 9423   7A22               	PTZ3:
 9424   7A22   A2 00       		ldx	#0		; CLEAR FOR PUTBYT
 9425   7A24   4C DD 43    		jmp	PUTBYT
 9426                      	; ---
 9427                      	; INC
 9428                      	; ---
 9429                      	; INCREMENT VARIABLE [ARG1]
 9430                      	
 9431   7A27   A5 63       	ZINC:	LDA	ARG1+LO	
 9432   7A29   20 36 43    		JSR	VARGET	; FETCH VARIABLE INTO [VALUE]
 9433   7A2C   E6 76       		INC	VALUE+LO
 9434   7A2E   D0 02       		BNE	ZINC1
 9435   7A30   E6 77       		INC	VALUE+HI
 9436   7A32   4C 47 7A    	ZINC1:	JMP	ZD0
 9437                      	
 9438                      	
 9439                      	; ---
 9440                      	; DEC
 9441                      	; ---
 9442                      	; DECREMENT VARIABLE [ARG1]
 9443                      	
 9444   7A35   A5 63       	ZDEC:	LDA	ARG1+LO	
 9445   7A37   20 36 43    		JSR	VARGET	; FETCH VAR INTO [VALUE]
 9446   7A3A   A5 76       		LDA	VALUE+LO	
 9447   7A3C   38          		SEC		
 9448   7A3D   E9 01       		SBC	#1	
 9449   7A3F   85 76       		STA	VALUE+LO	
 9450   7A41   A5 77       		LDA	VALUE+HI	
 9451   7A43   E9 00       		SBC	#0	
 9452   7A45   85 77       		STA	VALUE+HI	
 9453   7A47   A5 63       	ZD0:	LDA	ARG1+LO	; PUT RESULT BACK
 9454   7A49   4C C7 43    		JMP	VARPUT	; INTO THE SAME VARIABLE
 9455                      	
 9456                      	
 9457                      	; ------
 9458                      	; PRINTB
 9459                      	; ------
 9460                      	; PRINT Z-STRING AT [ARG1]
 9461                      	
  Wed May 24 1989 15:00                                                                                                  Page  144

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9462   7A4C               	ZPRB:
 9463   7A4C   A5 63       		lda	ARG1+LO		; move arg1 to I
 9464   7A4E   85 78       		sta	I+LO		; lo part
 9465   7A50   A5 64       		lda	ARG1+HI		; and now for arg1 hi
 9466   7A52   85 79       		sta	I+HI		; okay
 9467   7A54   20 60 8F    		jsr	SETWRD		; make [MPC] point to it
 9468   7A57   4C CE 92    		jmp	PZSTR		; and print it
 9469                      	
 9470                      	; ------
 9471                      	; REMOVE
 9472                      	; ------
 9473                      	; MOVE OBJECT [ARG1] INTO PSEUDO-OBJECT #0
 9474                      	; (EZIP CHANGES - 1) OBJLOC NEEDS HI & LO
 9475                      	; 2) MOVES AND COMPARES 2 BYTES)
 9476                      	
 9477   7A5A               	SAVEFPC: ds	3	; spot to save the FPC
 9478   7A5D               	SAVEOBJ: ds     1       ; check for zero object
 9479                      	
 9480   7A5E               	ZREMOV:
 9481   7A5E   A5 63       		lda	ARG1+LO	; GET SOURCE OBJECT ADDR
 9482   7A60   A6 64       		ldx	ARG1+HI	
 9483   7A62   20 EC 94    		jsr	OBJLOC	; INTO [FPC]
 9484                      	;
 9485                      	; now save this objects address in I,J
 9486                      	;
 9487   7A65   A9 06       		lda	#6	; point to the LOC slot
 9488   7A67   20 DE 8F    		jsr	ADDFPC	; thank you
 9489   7A6A   A5 8C       		lda	FPCL	; COPY THE SOURCE ADDR
 9490   7A6C   8D 5A 7A    		sta	SAVEFPC+LO	; INTO [J]
 9491   7A6F   A5 8D       		lda	FPCH	; FOR LATER REFERENCE
 9492   7A71   8D 5B 7A    		sta	SAVEFPC+HI
 9493   7A74   A5 8E       		lda	FPCBNK
 9494   7A76   8D 5C 7A    		sta	SAVEFPC+ABANK
 9495                      	;
 9496                      	; now go get object this one is in
 9497                      	;		
 9498   7A79   20 56 92    		jsr	FETCHB	; get the data
 9499   7A7C   85 7C       		sta	K	; HOLD IT
 9500   7A7E   20 BE 8F    		jsr	NEXTFPC	; get lo part
 9501   7A81   20 56 92    		jsr	FETCHB	; now get part
 9502   7A84   A8          		tay		; save it
 9503   7A85   05 7C       		ora	K	; COMPARE BYTES
 9504   7A87   D0 03       		bne	REMVj	; check for object
 9505   7A89   4C 2E 7B    		jmp	REMVEX	; SCRAM IF NO OBJECT
 9506   7A8C               	REMVj:
 9507   7A8C   98          		tya		; get lo part
 9508   7A8D   A6 7C       		ldx	K	; and hi part
 9509   7A8F   20 EC 94    		jsr	OBJLOC	; ELSE GET ADDR OF OBJECT [A] INTO [FPC]
 9510   7A92   A9 0B       		lda	#11	; POINT TO "FIRST" SLOT, LSB
 9511   7A94   20 DE 8F    		jsr	ADDFPC	; and point to it
 9512   7A97   20 56 92    		jsr	FETCHB	; and get it
 9513   7A9A   48          		pha		; save LSB
 9514   7A9B   20 24 90    		jsr	PREVFPC	; point to MSB
 9515   7A9E   20 56 92    		jsr	FETCHB	; A=LO, X=HI
 9516   7AA1   AA          		tax		; put into x
 9517   7AA2   68          		pla		; get LSB back
 9518   7AA3   C5 63       		cmp	ARG1+LO	; IS THIS THE FIRST?
 9519   7AA5   D0 04       		bne	REMVC1	; NO, KEEP SEARCHING
 9520   7AA7   E4 64       		cpx	ARG1+HI	; HM?
 9521   7AA9   F0 2B       		beq	DO_REMOVE ; yes, so use it
 9522   7AAB               	REMVC1:
 9523   7AAB   20 EC 94    		jsr	OBJLOC	; get object
 9524   7AAE   A9 09       		lda	#9	; GET "NEXT" slot address
 9525   7AB0   20 DE 8F    		jsr	ADDFPC	; into FPC
 9526   7AB3   20 56 92    		jsr	FETCHB	; get the byte
 9527   7AB6   48          		pha		; save LSB for later
 9528   7AB7   20 24 90    		jsr	PREVFPC	; and this is the hi part
 9529   7ABA   20 56 92    		jsr	FETCHB
 9530   7ABD   8D 5D 7A    	        sta     SAVEOBJ ; save for later check
 9531   7AC0   AA          		tax		; and put into x for (possible) check
 9532   7AC1   68          		pla		; get lo part back
 9533   7AC2   A8          	        tay             ; save a minute
 9534   7AC3   0D 5D 7A    	        ora     SAVEOBJ ; well, is it zero?
 9535   7AC6   D0 05       	        bne     REMVC2  ; no, so check it
 9536   7AC8   A9 15       	        lda     #21     ; so die
  Wed May 24 1989 15:00                                                                                                  Page  145

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9537   7ACA   4C 0A 52    	        jmp     ZERROR  ; and croak
 9538   7ACD               	REMVC2:
 9539   7ACD   98          	        tya             ; put back into [A]
 9540   7ACE   C5 63       		cmp	ARG1+LO	; FOUND IT?
 9541   7AD0   D0 D9       		bne	REMVC1	; NO, KEEP TRYING
 9542   7AD2   E4 64       		cpx	ARG1+HI	
 9543   7AD4   D0 D5       		bne	REMVC1	
 9544   7AD6               	DO_REMOVE:
 9545                      	;
 9546                      	; now, copy from FPC to SPC for stashing away
 9547                      	;
 9548   7AD6   20 73 90    		jsr	FP2SP	; copied
 9549                      	;
 9550                      	; now get removed one's address for fetching
 9551                      	;
 9552   7AD9   AD 5C 7A    		lda	SAVEFPC+ABANK	; this is where bank is
 9553   7ADC   85 8E       		sta	FPCBNK	; so show it
 9554   7ADE   AD 5B 7A    		lda	SAVEFPC+HI	; and here's the hi/lo part
 9555   7AE1   85 8D       		sta	FPCH
 9556   7AE3   AD 5A 7A    		lda	SAVEFPC+LO
 9557   7AE6   85 8C       		sta	FPCL
 9558   7AE8   A9 02       		lda	#2	; so get to source's "NEXT" slot
 9559   7AEA   20 DE 8F    		jsr	ADDFPC	; point to next slot
 9560   7AED   20 56 92    		jsr	FETCHB	; get the hi byte
 9561   7AF0   20 35 92    		jsr	STASHB	; and save it
 9562   7AF3   20 9E 8F    		jsr	NEXTSPC	; point to next one
 9563   7AF6   20 BE 8F    		jsr	NEXTFPC	; and from the source too
 9564   7AF9   20 56 92    		jsr	FETCHB	; get lo byte
 9565   7AFC   20 35 92    		jsr	STASHB	; and save it away
 9566                      	;
 9567                      	; now zero out SOURCE's loc and next spots
 9568                      	;
 9569   7AFF   AD 5C 7A    		lda	SAVEFPC+ABANK	; bank of source
 9570   7B02   85 91       		sta	SPCBNK
 9571   7B04   AD 5B 7A    		lda	SAVEFPC+HI	; and addr of source LOC slot
 9572   7B07   85 90       		sta	SPCH
 9573   7B09   AD 5A 7A    		lda	SAVEFPC+LO
 9574   7B0C   85 8F       		sta	SPCL	
 9575                      	;
 9576                      	; zero out NEXT and LOC of source
 9577                      	;
 9578   7B0E   A9 00       		lda	#0	; zero out 4 locations (LOC MSB)
 9579   7B10   20 35 92    		jsr	STASHB
 9580   7B13   20 9E 8F    		jsr	NEXTSPC
 9581   7B16               		
 9582   7B16   A9 00       		lda	#0	; zero out 4 locations (LOC LSB)
 9583   7B18   20 35 92    		jsr	STASHB
 9584   7B1B   20 9E 8F    		jsr	NEXTSPC
 9585   7B1E               		
 9586   7B1E   A9 00       		lda	#0	; zero out 4 locations (NEXT MSB)
 9587   7B20   20 35 92    		jsr	STASHB
 9588   7B23   20 9E 8F    		jsr	NEXTSPC
 9589   7B26               		
 9590   7B26   A9 00       		lda	#0	; zero out 4 locations (NEXT LSB)
 9591   7B28   20 35 92    		jsr	STASHB
 9592   7B2B   20 9E 8F    		jsr	NEXTSPC
 9593   7B2E               	REMVEX:
 9594   7B2E   60          		RTS		
 9595                      	
 9596                      	
 9597                      	; ------
 9598                      	; PRINTD
 9599                      	; ------
 9600                      	; PRINT SHORT DESCRIPTION OF OBJECT [ARG1]
 9601                      	
 9602   7B2F               	ZPRD:
 9603   7B2F   A5 63       		lda	ARG1+LO	
 9604   7B31   A6 64       		ldx	ARG1+HI	; (EZIP)
 9605   7B33   20 EC 94    		jsr	OBJLOC	; GET ADDR OF OBJECT INTO [FPC]
 9606   7B36   A9 0D       		lda	#13	; GET PROP TABLE POINTER (EZIP)
 9607   7B38   20 DE 8F    		jsr	ADDFPC	; and point to LSB
 9608   7B3B   20 56 92    		jsr	FETCHB	; fetch LSB
 9609   7B3E   48          		pha		; SAVE IT HERE
 9610   7B3F   20 24 90    		jsr	PREVFPC	; and now fetch MSB
 9611   7B42   20 56 92    		jsr	FETCHB	; thank you
  Wed May 24 1989 15:00                                                                                                  Page  146

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9612   7B45   85 79       		sta	I+HI	; AND MSB
 9613   7B47   68          		pla		; get LSB back
 9614   7B48   85 78       		sta	I+LO	; STORE LSB
 9615   7B4A   E6 78       		inc	I+LO	; POINT PAST THE
 9616   7B4C   D0 02       		bne	PDC0	; LENGTH BYTE
 9617   7B4E   E6 79       		inc	I+HI	
 9618   7B50   20 60 8F    	PDC0:	jsr	SETWRD	; CALC Z-STRING ADDR
 9619   7B53   4C CE 92    		jmp	PZSTR	; AND PRINT IT
 9620                      	
 9621                      	
 9622                      	; ------
 9623                      	; RETURN
 9624                      	; ------
 9625                      	; RETURN FROM "CALL" WITH VALUE [ARG1]
 9626                      	
 9627   7B56               	ZRET:
 9628   7B56   AD 75 6C    		LDA	OLDZSP+LO	; RE-SYNC THE
 9629   7B59   85 AF       		STA	ZSP+LO		; Z-STACK POINTER
 9630   7B5B   AD 76 6C    		LDA	OLDZSP+HI
 9631   7B5E   85 B0       		STA	ZSP+HI
 9632   7B60   20 66 43    		JSR	POPVAL		; POP # LOCALS INTO [X/A]
 9633   7B63   86 79       		STX	I+HI		; SAVE HERE
 9634   7B65   20 66 43    		JSR	POPVAL		; now we need number of args
 9635   7B68   8D 63 5B    		STA	ASSVLU		; for ASSIGNED?
 9636                      	
 9637   7B6B   A6 79       		LDX	I+HI		; see how many locals
 9638   7B6D   F0 19       		BEQ	RET2		; SKIP IF NOT
 9639                      	
 9640                      		; RESTORE PUSHED LOCALS
 9641                      	
 9642   7B6F   CA          		DEX			; ZERO-ALIGN
 9643   7B70   8A          		TXA			; AND
 9644   7B71   0A          		ASL	A		; WORD-ALIGN # LOCALS
 9645   7B72   85 78       		STA	I+LO		; FOR USE AS A STORAGE INDEX
 9646   7B74   20 66 43    	RET1:	JSR	POPVAL		; POP A LOCAL INTO [X/A]
 9647   7B77   A4 78       		LDY	I+LO		; RETRIEVE STORAGE INDEX
 9648   7B79   99 01 1E    		STA	LOCALS+HI,Y	; STORE MSB OF LOCAL
 9649   7B7C   8A          		TXA			; MOVE LSB
 9650   7B7D   99 00 1E    		STA	LOCALS+LO,Y	; AND STORE THAT TOO
 9651   7B80   C6 78       		DEC	I+LO
 9652   7B82   C6 78       		DEC	I+LO		; UPDATE STORAGE INDEX
 9653   7B84   C6 79       		DEC	I+HI		; AND LOCALS COUNT
 9654   7B86   D0 EC       		BNE	RET1		; POP TILL NO MORE LOCALS
 9655                      	
 9656                      		; RESTORE OTHER VARIABLES
 9657                      	
 9658   7B88               	RET2:
 9659   7B88   20 66 43    		JSR	POPVAL		; POP [ZPCH] AND [ZPCM]
 9660   7B8B   86 81       		STX	ZPCM
 9661   7B8D   85 82       		STA	ZPCH
 9662   7B8F   20 66 43    		JSR	POPVAL		; POP AND RESTORE
 9663   7B92   8E 5F 5B    		STX	IRET
 9664   7B95   85 80       		STA	ZPCL
 9665   7B97   20 66 43    		JSR	POPVAL
 9666   7B9A   8E 75 6C    		STX	OLDZSP+LO
 9667   7B9D   8D 76 6C    		STA	OLDZSP+HI
 9668                      	
 9669   7BA0   A5 80       		LDA	ZPCL		; check for zero zpc
 9670   7BA2   D0 0E       		BNE	RETj		; which means we are returning to
 9671   7BA4   A5 81       		LDA	ZPCM		; an internal call
 9672   7BA6   D0 0A       		BNE	RETj		; rather than just a normal
 9673   7BA8   A5 82       		LDA	ZPCH		; return
 9674   7BAA   D0 06       		BNE	RETj		; but so far it isn't
 9675                      	
 9676   7BAC   20 B4 44    		JSR	A12VAL		; MOVE [ARG1] TO [VALUE]
 9677   7BAF   4C 42 5B    		JMP	ZIRET		; so then do internal return
 9678   7BB2               	RETj:
 9679   7BB2   20 AA 90    		JSR	VLDZPC		; MAKE VALID
 9680   7BB5   AD 5F 5B    		LDA	IRET		; CHECK IF SHOULD RETURN A VALUE
 9681   7BB8   F0 01       		BEQ	RETYES		; (0 = RET, 1  = NO RETURN)
 9682   7BBA   60          		RTS			; NO, SO JUST GET OUT OF HERE
 9683   7BBB               	RETYES:
 9684   7BBB   20 B4 44    		JSR	A12VAL		; MOVE [ARG1] TO [VALUE]
 9685   7BBE   4C E1 43    		JMP	PUTVAL		; AND RETURN IT
 9686                      	
  Wed May 24 1989 15:00                                                                                                  Page  147

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9687                      	
 9688                      	; ----
 9689                      	; JUMP
 9690                      	; ----
 9691                      	; JUMP  TO Z-LOCATION IN [ARG1]
 9692                      	
 9693   7BC1   20 B4 44    	ZJUMP:	JSR	A12VAL	; MOVE [ARG1] TO [VALUE]
 9694   7BC4   4C 75 44    		JMP	PREDB3	; A BRANCH THAT ALWAYS SUCCEEDS
 9695                      	
 9696                      	
 9697                      	; -----
 9698                      	; PRINT
 9699                      	; -----
 9700                      	; PRINT Z-STRING AT WORD (QUAD) POINTER [ARG1]
 9701                      	
 9702   7BC7               	ZPRINT:
 9703   7BC7   A5 63       		LDA	ARG1+LO	
 9704   7BC9   85 78       		STA	I+LO	
 9705   7BCB   A5 64       		LDA	ARG1+HI	
 9706   7BCD   85 79       		STA	I+HI	
 9707   7BCF   20 A0 92    		JSR	SETSTR	; CALC STRING ADDRESS
 9708   7BD2   4C CE 92    		JMP	PZSTR	; AND PRINT IT
 9709                      	
 9710                      	
 9711                      	; -----
 9712                      	; VALUE
 9713                      	; -----
 9714                      	; RETURN VALUE OF VARIABLE [ARG1]
 9715                      	
 9716   7BD5               	ZVALUE:
 9717   7BD5   A5 63       		LDA	ARG1+LO	
 9718   7BD7   20 36 43    		JSR	VARGET	; GET THE VALUE
 9719   7BDA   4C E1 43    		JMP	PUTVAL	; EASY ENOUGH
 9720                      	
 9721                      	
 9722                      	
 9723   7BDD               		STTL "--- 2-OPS ---"
 9724                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page  148

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

 9725                      	
 9726                      	
 9727                      	; -----
 9728                      	; LESS?
 9729                      	; -----
 9730                      	; [ARG1] < [ARG2]?
 9731                      	
 9732   7BDD               	ZLESS:
 9733   7BDD   20 B4 44    		JSR	A12VAL	; MOVE [ARG1] TO [VALUE]
 9734   7BE0   4C E6 7B    		JMP	DLS0	; MOVE [ARG2] TO [I] & COMPARE
 9735                      	
 9736                      	
 9737                      	; ------
 9738                      	; DLESS?
 9739                      	; ------
 9740                      	; DECREMENT [ARG1] ; SUCCEED IF < [ARG2]
 9741                      	
 9742   7BE3               	ZDLESS:
 9743   7BE3   20 35 7A    		JSR	ZDEC	; MOVES ([ARG1]-1) TO [VALUE]
 9744   7BE6   A5 65       	DLS0:	LDA	ARG2+LO	; MOVE [ARG2] TO [I]
 9745   7BE8   85 78       		STA	I+LO	
 9746   7BEA   A5 66       		LDA	ARG2+HI	
 9747   7BEC   85 79       		STA	I+HI	
 9748   7BEE   4C 0F 7C    		JMP	COMPAR	; COMPARE & RETURN
 9749                      	
 9750                      	
 9751                      	; -----
 9752                      	; GRTR?
 9753                      	; -----
 9754                      	; [ARG1] < [ARG2]?
 9755                      	
 9756   7BF1   A5 63       	ZGRTR:	LDA	ARG1+LO	; MOVE [ARG1] TO [I]
 9757   7BF3   85 78       		STA	I+LO	
 9758   7BF5   A5 64       		LDA	ARG1+HI	
 9759   7BF7   85 79       		STA	I+HI	
 9760   7BF9   4C 07 7C    		JMP	A2VAL	; MOVE [ARG2] TO [VALUE] & COMPARE
 9761                      	
 9762                      	
 9763                      	; ------
 9764                      	; IGRTR?
 9765                      	; ------
 9766                      	; INCREMENT [ARG1] ; SUCCEED IF GREATER THAN [ARG2]
 9767                      	
 9768   7BFC   20 27 7A    	ZIGRTR:	JSR	ZINC	; GET ([ARG1]+1) INTO [VALUE]
 9769   7BFF   A5 76       		LDA	VALUE+LO	; MOVE [VALUE] TO [I]
 9770   7C01   85 78       		STA	I+LO	
 9771   7C03   A5 77       		LDA	VALUE+HI	
 9772   7C05   85 79       		STA	I+HI	
 9773   7C07   A5 65       	A2VAL:	LDA	ARG2+LO	; MOVE [ARG2] TO [VALUE]
 9774   7C09   85 76       		STA	VALUE+LO	
 9775   7C0B   A5 66       		LDA	ARG2+HI	
 9776   7C0D   85 77       		STA	VALUE+HI	
 9777                      	
 9778                      	
 9779                      	; -----------------
 9780                      	; SIGNED COMPARISON
 9781                      	; -----------------
 9782                      	; ENTRY: VALUES IN [VALUE] AND [I]
 9783                      	;
 9784                      	;  IS [VALUE] > [I]
 9785                      	;
 9786   7C0F               	COMPAR:
 9787   7C0F   A5 79       		LDA	I+HI
 9788   7C11   45 77       		EOR	VALUE+HI
 9789   7C13   10 09       		BPL	SCMP
 9790   7C15   A5 79       		LDA	I+HI
 9791   7C17   C5 77       		CMP	VALUE+HI
 9792   7C19   90 42       		BCC	PGOOD
 9793   7C1B   4C 2F 44    		JMP	PREDF
 9794                      	
 9795   7C1E   A5 77       	SCMP:	LDA	VALUE+HI
 9796   7C20   C5 79       		CMP	I+HI
 9797   7C22   D0 04       		BNE	SCEX
 9798   7C24   A5 76       		LDA	VALUE+LO
 9799   7C26   C5 78       		CMP	I+LO
  Wed May 24 1989 15:00                                                                                                  Page  149

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

 9800   7C28   90 33       	SCEX:	BCC	PGOOD
 9801   7C2A   4C 2F 44    		JMP	PREDF
 9802                      	
 9803                      	
 9804                      	; ---
 9805                      	; IN?
 9806                      	; ---
 9807                      	; IS OBJECT [ARG1] CONTAINED IN OBJECT [ARG2]?
 9808   7C2D               	ZIN:
 9809   7C2D   A5 63       		LDA	ARG1+LO	
 9810   7C2F   A6 64       		LDX	ARG1+HI	
 9811   7C31   20 EC 94    		JSR	OBJLOC	; GET ADDR OF TARGET OBJECT INTO [FPC]
 9812   7C34   A9 06       		LDA	#6	; POINT TO "LOC" SLOT
 9813   7C36   20 DE 8F    		jsr	ADDFPC	; and point to it
 9814   7C39   20 56 92    		jsr	FETCHB	; well?
 9815   7C3C   C5 66       		CMP	ARG2+HI	; IS IT THERE?
 9816   7C3E   D0 0A       		BNE	PBAD	; NO
 9817   7C40   20 BE 8F    		jsr	NEXTFPC	; point to lo part
 9818   7C43   20 56 92    		jsr	FETCHB	; and get it
 9819   7C46   C5 65       		CMP	ARG2+LO	
 9820   7C48   F0 13       		BEQ	PGOOD	; YES, SUCCEED
 9821   7C4A   4C 2F 44    	PBAD:	JMP	PREDF	; TOO BAD, CHUM ...
 9822                      	
 9823                      	
 9824                      	; ----
 9825                      	; BTST
 9826                      	; ----
 9827                      	; IS EVERY "ON" BIT IN [ARG1]
 9828                      	; ALSO "ON" IN [ARG2]?
 9829                      	
 9830   7C4D   A5 65       	ZBTST:	LDA	ARG2+LO	; FIRST CHECK LSBS
 9831   7C4F   25 63       		AND	ARG1+LO	
 9832   7C51   C5 65       		CMP	ARG2+LO	; LSBS MATCH?
 9833   7C53   D0 F5       		BNE	PBAD	; NO, EXIT NOW
 9834   7C55   A5 66       		LDA	ARG2+HI	; ELSE CHECK MSBS
 9835   7C57   25 64       		AND	ARG1+HI	
 9836   7C59   C5 66       		CMP	ARG2+HI	; MATCHED?
 9837   7C5B   D0 ED       		BNE	PBAD	; SORRY ...
 9838   7C5D               	PGOOD:
 9839   7C5D   4C 3B 44    		JMP	PREDS	
 9840                      	
 9841                      	
 9842                      	; ---
 9843                      	; BOR
 9844                      	; ---
 9845                      	; RETURN [ARG1] "OR" [ARG2]
 9846                      	
 9847   7C60   A5 63       	ZBOR:	LDA	ARG1+LO	
 9848   7C62   05 65       		ORA	ARG2+LO	
 9849   7C64   AA          		TAX		
 9850   7C65   A5 64       		LDA	ARG1+HI	
 9851   7C67   05 66       		ORA	ARG2+HI	
 9852                      	
 9853                      		; FALL THROUGH ...
 9854                      	
 9855                      	
 9856                      	; ---------------------
 9857                      	; RETURN VALUE IN [X/A]
 9858                      	; ---------------------
 9859                      	
 9860   7C69   86 76       	VEXIT:	STX	VALUE+LO
 9861   7C6B   85 77       		STA	VALUE+HI
 9862   7C6D   4C E1 43    		JMP	PUTVAL
 9863                      	
 9864                      	
 9865                      	; ----
 9866                      	; BAND
 9867                      	; ----
 9868                      	; RETURN [ARG1] "AND" [ARG2]
 9869                      	
 9870   7C70   A5 63       	ZBAND:	LDA	ARG1+LO	
 9871   7C72   25 65       		AND	ARG2+LO	
 9872   7C74   AA          		TAX		
 9873   7C75   A5 64       		LDA	ARG1+HI	
 9874   7C77   25 66       		AND	ARG2+HI	
  Wed May 24 1989 15:00                                                                                                  Page  150

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

 9875   7C79   4C 69 7C    		JMP	VEXIT	
 9876                      	
 9877                      	
 9878                      	; -----
 9879                      	; FSET?
 9880                      	; -----
 9881                      	; IS FLAG [ARG2] SET IN OBJECT [ARG1]?
 9882                      	
 9883   7C7C   20 7B 95    	ZFSETP:	JSR	FLAGSU	; GET BITS INTO [K] AND [J]
 9884   7C7F   A5 7D       		LDA	K+HI	; DO MSBS
 9885   7C81   25 7B       		AND	J+HI	
 9886   7C83   85 7D       		STA	K+HI	
 9887   7C85   A5 7C       		LDA	K+LO	; DO LSBS
 9888   7C87   25 7A       		AND	J+LO	
 9889   7C89   05 7D       		ORA	K+HI	; ANY BITS ON?
 9890   7C8B   D0 D0       		BNE	PGOOD	; TARGET BIT MUST BE ON
 9891   7C8D   4C 2F 44    		JMP	PREDF	
 9892                      	
 9893                      	
 9894                      	; ----
 9895                      	; FSET
 9896                      	; ----
 9897                      	; SET FLAG [ARG2] IN OBJECT [ARG1]
 9898                      	
 9899   7C90               	ZFSET:
 9900   7C90   20 7B 95    		JSR	FLAGSU	; GET BITS INTO [K] & [J], ADDR IN [FPC]
 9901                      	;
 9902                      	; now, copy from FPC to SPC for stashing away
 9903                      	;
 9904   7C93   20 73 90    		jsr	FP2SP	; okay, done it
 9905   7C96   A5 7D       		lda	K+HI	; FIRST DO MSBS
 9906   7C98   05 7B       		ora	J+HI	
 9907   7C9A   20 35 92    		jsr	STASHB
 9908   7C9D   20 9E 8F    		jsr	NEXTSPC
 9909   7CA0   A5 7C       		lda	K+LO	; THEN LSBS
 9910   7CA2   05 7A       		ora	J+LO	
 9911   7CA4   20 35 92    		jsr	STASHB
 9912   7CA7   60          		rts
 9913                      	
 9914                      	
 9915                      	; ------
 9916                      	; FCLEAR
 9917                      	; ------
 9918                      	; CLEAR FLAG [ARG2] IN OBJECT [ARG1]
 9919                      	
 9920   7CA8               	ZFCLR:
 9921   7CA8   20 7B 95    		jsr	FLAGSU	; GETS BITS INTO [J] & [K], ADDR IN [FPC]
 9922                      	;
 9923                      	; now, copy from FPC to SPC for stashing away
 9924                      	;
 9925   7CAB   20 73 90    		jsr	FP2SP	; okey dokey
 9926                      	
 9927   7CAE   A5 7B       		lda	J+HI	; FETCH MSB
 9928   7CB0   49 FF       		eor	#$FF	; COMPLEMENT IT
 9929   7CB2   25 7D       		and	K+HI	; RUB OUT FLAG
 9930   7CB4   20 35 92    		jsr	STASHB	; and save it
 9931   7CB7   20 9E 8F    		jsr	NEXTSPC	; point to lo part
 9932   7CBA   A5 7A       		lda	J+LO	; SAME FOR LSB
 9933   7CBC   49 FF       		eor	#$FF	
 9934   7CBE   25 7C       		and	K+LO	
 9935   7CC0   20 35 92    		jsr	STASHB	; and show it to the world
 9936   7CC3   60          		rts
 9937                      	
 9938                      	
 9939                      	; ---
 9940                      	; SET
 9941                      	; ---
 9942                      	; SET VARIABLE [ARG1] EQUAL TO [ARG2]
 9943                      	
 9944   7CC4   A5 65       	ZSET:	LDA	ARG2+LO	; MOVE THE VALUE
 9945   7CC6   85 76       		STA	VALUE+LO	; INTO [VALUE]
 9946   7CC8   A5 66       		LDA	ARG2+HI	
 9947   7CCA   85 77       		STA	VALUE+HI	
 9948   7CCC   A5 63       		LDA	ARG1+LO	; GET VARIABLE ID
 9949   7CCE   4C C7 43    		JMP	VARPUT	; AND CHANGE THE VARIABLE
  Wed May 24 1989 15:00                                                                                                  Page  151

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

 9950                      	
 9951                      	
 9952                      	; ----
 9953                      	; MOVE
 9954                      	; ----
 9955                      	; MOVE OBJECT [ARG1] INTO OBJECT [ARG2]
 9956                      	; (EZIP - EXPANDED FROM BYTE OBJECTS TO WORD OBJECTS)
 9957                      	
 9958   7CD1               	ZMOVE:
 9959   7CD1   20 5E 7A    		jsr	ZREMOV		; REMOVE FIRST - CUT ARG1 OUT OF WHERE IT IS
 9960                      	;
 9961                      	; Make [ARG1] be first in [ARG2]'s chain.
 9962                      	;
 9963   7CD4   A5 65       		lda	ARG2+LO	
 9964   7CD6   A6 66       		ldx	ARG2+HI		; Get parent's address
 9965   7CD8   20 EC 94    		jsr	OBJLOC		; into [FPC]
 9966   7CDB   A9 0A       		lda	#10		; point to FIRST slot
 9967   7CDD   20 DE 8F    		jsr	ADDFPC		; okay
 9968   7CE0   20 56 92    		jsr	FETCHB		; get old first one (MSB)
 9969   7CE3   85 7D       		sta	K+HI		; save it
 9970   7CE5   20 BE 8F    		jsr	NEXTFPC		; point to next part
 9971   7CE8   20 56 92    		jsr	FETCHB		; and get it
 9972   7CEB   85 7C       		sta	K+LO		; okay, saved
 9973   7CED   20 73 90    		jsr	FP2SP		; make FPC == SPC
 9974                      	;
 9975                      	; now make object [ARG1] be first in object [ARG2]
 9976                      	; SPC is currently pointing to LSB of [ARG2]'s FIRST slot
 9977                      	;
 9978   7CF0   A5 63       		lda	ARG1+LO		; stash away low part first
 9979   7CF2   20 35 92    		jsr	STASHB		; stashed
 9980   7CF5   20 4E 90    		jsr	PREVSPC		; point to high part
 9981   7CF8   A5 64       		lda	ARG1+HI		; get hi part of source
 9982   7CFA   20 35 92    		jsr	STASHB		; save it
 9983                      	;
 9984                      	; now point to object [ARG1] to update its slots
 9985                      	;
 9986   7CFD   A6 64       		ldx	ARG1+HI		; put hi part here
 9987   7CFF   A5 63       		lda	ARG1+LO		; and lo part here for OBJLOC
 9988   7D01   20 EC 94    		jsr	OBJLOC		; get me the SOURCE of all confusion
 9989   7D04   A9 06       		lda	#6		; point to LOC slot
 9990   7D06   20 DE 8F    		jsr	ADDFPC		; and now FPC points there
 9991   7D09   20 73 90    		jsr	FP2SP		; now make it the STASH pointer
 9992                      	;
 9993                      	; update [ARG1]s LOC pointer to be [ARG2]
 9994                      	; SPC points to LOC slot
 9995                      	;
 9996   7D0C   A5 66       		lda	ARG2+HI		; get PARENT number
 9997   7D0E   20 35 92    		jsr	STASHB		; and save it in LOC
 9998   7D11   20 9E 8F    		jsr	NEXTSPC		; and point to LSB of LOC
 9999   7D14   A5 65       		lda	ARG2+LO		; got parent's lowness
10000   7D16   20 35 92    		jsr	STASHB		; and saved it in ARG1
10001                      	;
10002                      	; Move old FIRST object and make it [ARG1]s NEXT
10003                      	; now SPC points to [ARG1]s NEXT slot
10004                      	;
10005   7D19   20 9E 8F    		jsr	NEXTSPC		; point to MSB of NEXT
10006   7D1C   A5 7D       		lda	K+HI		; get old FIRST one
10007   7D1E   20 35 92    		jsr	STASHB	; and save it
10008   7D21   20 9E 8F    		jsr	NEXTSPC	; and point to LSB now
10009   7D24   A5 7C       		lda	K+LO	; get LSB of this
10010   7D26   20 35 92    		jsr	STASHB	; saved
10011   7D29   60          		rts
10012                      	
10013                      	; ---
10014                      	; GET
10015                      	; ---
10016                      	; RETURN ITEM [ARG2] IN WORD-TABLE [ARG1]
10017                      	
10018   7D2A               	ZGET:
10019   7D2A   20 41 7D    		JSR	WCALC		; CALC ADDRESS
10020   7D2D   20 09 92    		JSR	GETBYT		; GET 1ST BYTE (MSB)
10021   7D30   85 77       	DOGET:	STA	VALUE+HI	; SAVE MSB
10022   7D32   20 09 92    		JSR	GETBYT		; GET LSB
10023   7D35   85 76       		STA	VALUE+LO	; SAVE AND
10024   7D37   4C E1 43    		jmp	PUTVAL		; HAND IT OVER
  Wed May 24 1989 15:00                                                                                                  Page  152

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10025                      	
10026                      	
10027                      	; ----
10028                      	; GETB
10029                      	; ----
10030                      	; RETURN ITEM [ARG2] IN BYTE-TABLE AT [ARG1]
10031                      	
10032   7D3A               	ZGETB:
10033   7D3A   20 45 7D    		JSR	BCALC	
10034   7D3D   A9 00       		LDA	#0	
10035   7D3F   F0 EF       		BEQ	DOGET		; [A] = 0, SO CLEAR MSB OF [VALUE]
10036                      	
10037                      	
10038                      	; --------------------
10039                      	; CALC TABLE ADDRESSES
10040                      	; --------------------
10041                      	; WORD-ALIGNED ENTRY
10042                      	
10043   7D41               	WCALC:
10044   7D41   06 65       		ASL	ARG2+LO	; WORD-ALIGN FOR
10045   7D43   26 66       		ROL	ARG2+HI	; WORD ACCESS
10046                      	;
10047                      	; BYTE-ALIGNED ENTRY
10048                      	;
10049   7D45               	BCALC:
10050   7D45   A5 65       		LDA	ARG2+LO	; ADD BASE ADDR OF TABLE
10051   7D47   18          		CLC		; TO ITEM
10052   7D48   65 63       		ADC	ARG1+LO	; INDEX
10053   7D4A   85 86       		STA	MPCL	
10054   7D4C   A5 66       		LDA	ARG2+HI	; SAME FOR MSBS
10055   7D4E   65 64       		ADC	ARG1+HI	
10056   7D50   85 87       		STA	MPCM	
10057   7D52   A9 00       		LDA	#0	
10058   7D54   69 00       		ADC	#0	; PICK UP CARRY FROM MPCM
10059   7D56   85 88       		STA	MPCH	; TO GET TOP BIT
10060   7D58   4C 80 90    		JMP	VLDMPC	
10061                      	
10062                      	
10063                      	; ----
10064                      	; GETP
10065                      	; ----
10066                      	; RETURN PROPERTY [ARG2] OF OBJECT [ARG1] ;
10067                      	; IF NO PROP [ARG2], RETURN [ARG2]'TH ELEMENT OF OBJECT #0
10068                      	
10069   7D5B               	ZGETP:
10070   7D5B   20 27 95    		jsr	PROPB		; set up FPC
10071   7D5E               	GETP1:
10072   7D5E   20 52 95    		jsr	PROPN		; GET ID OF PROP TBL
10073   7D61   C5 65       		cmp	ARG2+LO		; Compare PROP ID
10074   7D63   F0 30       		beq	GETP3		; FOUND IT
10075   7D65   90 06       		bcc	GETP2		; NOT THERE
10076   7D67   20 71 95    		jsr	PROPNX		; GET NEXT PROP, ALIGN [FPC] TO IT
10077   7D6A   4C 5E 7D    		jmp	GETP1		; TRY AGAIN WITH NEXT PROP
10078                      	;
10079                      	; PROPERTY NOT THERE, GET DEFAULT
10080                      	;
10081   7D6D               	GETP2:
10082   7D6D   A5 65       		lda	ARG2+LO		; GET PROPERTY #
10083   7D6F   38          		sec			; ZERO-ALIGN IT
10084   7D70   E9 01       		sbc	#1	
10085   7D72   0A          		asl	A		; WORD-ALIGN IT
10086   7D73   18          		clc			; add in table start
10087   7D74   6D 0B 96    		adc	ZBEGIN+ZOBJEC+1	; add lo part
10088   7D77   85 8C       		sta	FPCL		; save for fetch
10089   7D79   AD 0A 96    		lda	ZBEGIN+ZOBJEC	; now get hi part
10090   7D7C   69 00       		adc	#0		; pick up carry, if any
10091   7D7E   20 77 8F    		jsr	SETPC		; get memory spot for this page
10092   7D81   85 8D       		sta	FPCH		; page and
10093   7D83   84 8E       		sty	FPCBNK		; bank
10094   7D85   20 56 92    		jsr	FETCHB		; GET MSB OF PROPERTY
10095   7D88   85 77       		sta	VALUE+HI	
10096   7D8A   20 BE 8F    		jsr	NEXTFPC
10097   7D8D   20 56 92    		jsr	FETCHB		; DO SAME WITH LSB
10098   7D90   85 76       		sta	VALUE+LO	
10099   7D92   4C E1 43    		jmp	PUTVAL		; RETURN DEFAULT IN [VALUE]
  Wed May 24 1989 15:00                                                                                                  Page  153

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10100   7D95               	GETP3:
10101   7D95   20 58 95    		jsr	PROPL		; GET LENGTH OF PROP INTO [A]
10102   7D98   AA          		tax			; save [A]
10103   7D99   20 BE 8F    		jsr	NEXTFPC		; MAKE [FPC] POINT TO 1ST BYTE OF PROP
10104   7D9C   E0 01       		cpx	#1		; IF LENGTH =1
10105   7D9E   F0 09       		beq	GETPB		; GET A BYTE PROPERTY
10106   7DA0   E0 02       		cpx	#2		; IF LENGTH = 2
10107   7DA2   F0 10       		beq	GETPW		; GET A WORD PROPERTY
10108                      	
10109                      		; *** ERROR #7: PROPERTY LENGTH ***
10110                      	
10111   7DA4   A9 07       		LDA	#7	
10112   7DA6   4C 0A 52    		JMP	ZERROR	
10113                      	;
10114                      	; GET A 1-BYTE PROPERTY
10115                      	;
10116   7DA9               	GETPB:
10117   7DA9   20 56 92    		jsr	FETCHB		; GET LSB INTO [A]
10118   7DAC   85 76       		sta	VALUE+LO	; STORE LSB
10119   7DAE   A9 00       		lda	#0		; CLEAR MSB
10120   7DB0   85 77       		sta	VALUE+HI	; and zero it
10121   7DB2   F0 0D       		beq	ETPEX	
10122                      	;
10123                      	; GET A 2-BYTE PROPERTY
10124                      	;
10125   7DB4               	GETPW:
10126   7DB4   20 56 92    		jsr	FETCHB		; GET MSB
10127   7DB7   85 77       		sta	VALUE+HI	; store MSB
10128   7DB9   20 BE 8F    		jsr	NEXTFPC		; POINT TO LSB
10129   7DBC   20 56 92    		jsr	FETCHB		; GET IT INTO [A]
10130   7DBF   85 76       		sta	VALUE+LO	; AND MSB
10131   7DC1               	ETPEX:
10132   7DC1   4C E1 43    		jmp	PUTVAL	
10133                      	
10134                      	; -----
10135                      	; GETPT
10136                      	; -----
10137                      	; RETURN POINTER TO PROP TABLE [ARG2]
10138                      	; IN OBJECT [ARG1]
10139                      	
10140   7DC4               	ZGETPT:
10141   7DC4   A5 63       		lda	ARG1+LO
10142   7DC6   A6 64       		ldx	ARG1+HI		; (EZIP)
10143   7DC8   20 EC 94    		jsr	OBJLOC		; put location into [FPC]
10144   7DCB   A9 0C       		lda	#12		; get offset table pointer
10145   7DCD   20 DE 8F    		jsr	ADDFPC		; and point to it
10146   7DD0   20 56 92    		jsr	FETCHB		; get MSB of table pointer
10147   7DD3   48          		pha			; save page
10148   7DD4   20 BE 8F    		jsr	NEXTFPC		; point to LSB
10149   7DD7   20 56 92    		jsr	FETCHB		; and get it
10150   7DDA   85 8C       		sta	FPCL		; and save it
10151   7DDC   68          		pla			; get page address back
10152   7DDD   20 77 8F    		jsr	SETPC		; and absolutize it
10153   7DE0   85 8D       		sta	FPCH		; and save page
10154   7DE2   84 8E       		sty	FPCBNK		; and bank
10155   7DE4   20 56 92    		jsr	FETCHB		; GET LENGTH OF SHORT DESC
10156   7DE7   0A          		asl	A		; WORD-ALIGN IT
10157   7DE8   A8          		tay			; now point to just past it
10158   7DE9   C8          		iny			; thank you
10159   7DEA   98          		tya			; for adding
10160   7DEB   20 DE 8F    		jsr	ADDFPC		; and POINT JUST PAST THE DESCRIPTION
10161   7DEE               	GETPT1:
10162   7DEE   20 52 95    		jsr	PROPN		; get prop ID
10163   7DF1   C5 65       		cmp	ARG2+LO		; CHECK ID
10164   7DF3   F0 0B       		beq	GETPT2
10165   7DF5   B0 03       		bcs	DDD		; .GE. so check some more
10166   7DF7   4C 2E 7E    		jmp	DORET		; BEYOND IT, SO NOT THERE
10167   7DFA               	DDD:
10168   7DFA   20 71 95    		jsr	PROPNX		; point to next one
10169   7DFD   4C EE 7D    		jmp	GETPT1		; next please
10170   7E00               	GETPT2:
10171   7E00   20 58 95    		jsr	PROPL		; get the length of this property
10172   7E03   20 BE 8F    		jsr	NEXTFPC		; INC TO POINT AT PROPERTY VALUE (EZIP)
10173                      	;
10174                      	; now subtract absolute address to get relative address for returning
  Wed May 24 1989 15:00                                                                                                  Page  154

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10175                      	; what a pain in the neck
10176                      	;
10177   7E06   A5 8E       		lda	FPCBNK		; check which bank we are in
10178   7E08   F0 16       		beq	GETPB0		; in main bank, it's easier
10179                      	;
10180                      	; if in AUX bank, then we must subtract beginning of AUX mem, then
10181                      	; add in size of MAIN bank
10182                      	;
10183   7E0A   A5 8D       		lda	FPCH		; get page
10184   7E0C   C9 D0       		cmp	#>Z3BEGIN	; in part 2 of aux?
10185   7E0E   B0 08       		bcs	GETPB3		; ayyup
10186   7E10   38          		sec			; and subtract
10187   7E11   E9 40       		sbc	#>Z2BEGIN	; first page in aux
10188   7E13   18          		clc			; now add in how many pages in main
10189   7E14   69 29       		adc	#P2PAGE		; now we have relative start
10190   7E16   D0 0D       		bne	GETP15		; JUMP to putval
10191   7E18               	GETPB3:
10192   7E18   38          		sec			; and subtract
10193   7E19   E9 D0       		sbc	#>Z3BEGIN	; first page in aux, part 2
10194   7E1B   18          		clc			; now add in how many pages in main
10195   7E1C   69 A8       		adc	#P3PAGE		; now we have relative start
10196   7E1E   D0 05       		bne	GETP15		; jump to putval	
10197   7E20               	GETPB0:
10198   7E20   A5 8D       		lda	FPCH		; get page in main mem
10199   7E22   38          		sec			; and then subtract
10200   7E23   E9 96       		sbc	#>ZBEGIN	; start of main mem
10201   7E25               	GETP15:
10202   7E25   85 77       		sta	VALUE+HI	; save hi part for returning
10203   7E27   A5 8C       		lda	FPCL		; and just save lo part
10204   7E29   85 76       		sta	VALUE+LO	; okay?
10205   7E2B   4C E1 43    		jmp	PUTVAL		; AND RETURN
10206   7E2E               	DORET:	
10207   7E2E   4C DA 43    		jmp	RET0		; ELSE RETURN A ZERO
10208                      	
10209                      	
10210                      	; -----
10211                      	; NEXTP
10212                      	; -----
10213                      	; RETURN INDEX # OF PROP FOLLOWING PROP [ARG2] IN OBJECT [AR
10214                      	; RETURN ZERO IF LAST ; RETURN FIRST IF [ARG2]=0; ERROR IF NO
10215                      	
10216   7E31               	ZNEXTP:
10217   7E31   20 27 95    		JSR	PROPB	; ALIGN [FPC] AT PROPERTY TBL'S 1ST ENTRY
10218   7E34   A5 65       		LDA	ARG2+LO	; IF [ARG2]=0
10219   7E36   F0 12       		BEQ	NXTP3	; RETURN "FIRST" SLOT
10220   7E38               	NXTP1:
10221   7E38   20 52 95    		JSR	PROPN	; FETCH PROPERTY #
10222   7E3B   C5 65       		CMP	ARG2+LO	; COMPARE TO TARGET #
10223   7E3D   F0 08       		BEQ	NXTP2	; FOUND IT!
10224   7E3F   90 ED       		BCC	DORET	; LAST PROP, SO RETURN ZERO
10225   7E41   20 71 95    		JSR	PROPNX	; ELSE TRY NEXT PROPERTY (EZIP)
10226   7E44   4C 38 7E    		JMP	NXTP1	
10227   7E47   20 71 95    	NXTP2:	JSR	PROPNX	; POINT TO FOLLOWING PROPERTY
10228   7E4A   20 52 95    	NXTP3:	JSR	PROPN	; GET THE PROPERTY #
10229   7E4D   A2 00       		LDX	#0	; FOR PUTBYT (EZIP)
10230   7E4F   4C DD 43    		JMP	PUTBYT	; AND RETURN IT
10231                      	
10232                      	
10233                      	; ---
10234                      	; ADD
10235                      	; ---
10236                      	; RETURN [ARG1] + [ARG2]
10237                      	
10238   7E52   A5 63       	ZADD:	LDA	ARG1+LO	; ADD LSBS
10239   7E54   18          		CLC		
10240   7E55   65 65       		ADC	ARG2+LO	
10241   7E57   AA          		TAX		; SAVE LSB HERE
10242   7E58   A5 64       		LDA	ARG1+HI	; ADD MSBS
10243   7E5A   65 66       		ADC	ARG2+HI	
10244   7E5C   4C 69 7C    		JMP	VEXIT	
10245                      	
10246                      	
10247                      	; ---
10248                      	; SUB
10249                      	; ---
  Wed May 24 1989 15:00                                                                                                  Page  155

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10250                      	; RETURN [ARG1] - [ARG2]
10251                      	
10252   7E5F   A5 63       	ZSUB:	LDA	ARG1+LO	; SUBTRACT LSBS
10253   7E61   38          		SEC		
10254   7E62   E5 65       		SBC	ARG2+LO	
10255   7E64   AA          		TAX		; SAVE LSB HERE
10256   7E65   A5 64       		LDA	ARG1+HI	; SUBTRACT MSBS
10257   7E67   E5 66       		SBC	ARG2+HI	
10258   7E69   4C 69 7C    		JMP	VEXIT	; EXIT WITH [X]=LSB, [A]=MSB
10259                      	
10260                      	
10261                      	; ---
10262                      	; MUL
10263                      	; ---
10264                      	; RETURN [ARG1] * [ARG2]
10265                      	
10266   7E6C   20 52 7F    	ZMUL:	JSR	MINIT	; INIT THINGS
10267   7E6F   6E 61 5B    	ZMLOOP:	ROR	MTEMP+HI	
10268   7E72   6E 60 5B    		ROR	MTEMP+LO	
10269   7E75   66 66       		ROR	ARG2+HI	
10270   7E77   66 65       		ROR	ARG2+LO	
10271   7E79   90 11       		BCC	ZMNEXT	
10272   7E7B   A5 63       		LDA	ARG1+LO	
10273   7E7D   18          		CLC		
10274   7E7E   6D 60 5B    		ADC	MTEMP+LO	
10275   7E81   8D 60 5B    		STA	MTEMP+LO	
10276   7E84   A5 64       		LDA	ARG1+HI	
10277   7E86   6D 61 5B    		ADC	MTEMP+HI	
10278   7E89   8D 61 5B    		STA	MTEMP+HI	
10279   7E8C   CA          	ZMNEXT:	DEX		
10280   7E8D   10 E0       		BPL	ZMLOOP	
10281   7E8F   A6 65       		LDX	ARG2+LO	; PUT LSB OF PRODUCT
10282   7E91   A5 66       		LDA	ARG2+HI	; AND MSB
10283   7E93   4C 69 7C    		JMP	VEXIT	; WHERE "VEXIT" EXPECTS THEM
10284                      	
10285                      	
10286                      	; ---
10287                      	; DIV
10288                      	; ---
10289                      	; RETURN QUOTIENT OF [ARG1] / [ARG2]
10290                      	
10291   7E96   20 AE 7E    	ZDIV:	JSR	DIVIDE	
10292   7E99   AE 5B 6C    		LDX	QUOT+LO	
10293   7E9C   AD 5C 6C    		LDA	QUOT+HI	
10294   7E9F   4C 69 7C    		JMP	VEXIT	
10295                      	
10296                      	
10297                      	; ---
10298                      	; MOD
10299                      	; ---
10300                      	; RETURN REMAINDER OF [ARG1] / [ARG2]
10301                      	
10302   7EA2   20 AE 7E    	ZMOD:	JSR	DIVIDE	
10303   7EA5   AE 5D 6C    		LDX	REMAIN+LO	; FETCH THE REMAINDER
10304   7EA8   AD 5E 6C    		LDA	REMAIN+HI	; IN [REMAIN]
10305   7EAB   4C 69 7C    		JMP	VEXIT	; AND RETURN IT
10306                      	
10307                      	
10308                      	; ---------------
10309                      	; SIGNED DIVISION
10310                      	; ---------------
10311                      	; ENTRY: DIVIDEND IN [ARG1], DIVISOR IN [ARG2]
10312                      	; EXIT: QUOTIENT IN [QUOT], REMAINDER IN [REMAIN]
10313                      	
10314   7EAE               	DIVIDE:
10315   7EAE   A5 64       		LDA	ARG1+HI	; SIGN OF REMAINDER
10316   7EB0   8D 60 6C    		STA	RSIGN	; IS THE SIGN OF THE DIVIDEND
10317   7EB3   45 66       		EOR	ARG2+HI	; SIGN OF QUOTIENT IS POSITIVE
10318   7EB5   8D 5F 6C    		STA	QSIGN	; IF SIGNS OF TERMS ARE THE SAME
10319   7EB8   A5 63       		LDA	ARG1+LO	; MOVE [ARG1] TO [QUOT]
10320   7EBA   8D 5B 6C    		STA	QUOT+LO	
10321   7EBD   A5 64       		LDA	ARG1+HI	
10322   7EBF   8D 5C 6C    		STA	QUOT+HI	; IF DIVIDEND IS POSITIVE
10323   7EC2   10 03       		BPL	ABSDIV	; MOVE DIVISOR
10324   7EC4   20 F8 7E    		JSR	ABQUOT	; ELSE CALC ABS(DIVIDEND) FIRST
  Wed May 24 1989 15:00                                                                                                  Page  156

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10325   7EC7   A5 65       	ABSDIV:	LDA	ARG2+LO	
10326   7EC9   8D 5D 6C    		STA	REMAIN+LO	
10327   7ECC   A5 66       		LDA	ARG2+HI	
10328   7ECE   8D 5E 6C    		STA	REMAIN+HI	; IF REMAINDER IS POSITIVE
10329   7ED1   10 03       		BPL	GODIV	; WE'RE READY TO DIVIDE
10330   7ED3   20 E6 7E    		JSR	ABREM	; ELSE CALC ABS(DIVISOR)
10331   7ED6   20 0A 7F    	GODIV:	JSR	UDIV	; DO UNSIGNED DIVIDE
10332   7ED9   AD 5F 6C    		LDA	QSIGN	; SHOULD QUOTIENT BE FLIPPED?
10333   7EDC   10 03       		BPL	RFLIP	; NO, TEST REMAINDER
10334   7EDE   20 F8 7E    		JSR	ABQUOT	; ELSE GET ABSOLUTE VALUE
10335   7EE1   AD 60 6C    	RFLIP:	LDA	RSIGN	; SHOULD EMAINDER BE FLIPPED?
10336   7EE4   10 11       		BPL	DIVEX	; NO, WE'RE DONE
10337                      	
10338                      		; ELSE FALL THROUGH ...
10339                      	
10340                      	
10341                      	; ----------------
10342                      	; CALC ABS(REMAIN)
10343                      	; ----------------
10344                      	
10345   7EE6   A9 00       	ABREM:	LDA	#0	
10346   7EE8   38          		SEC		
10347   7EE9   ED 5D 6C    		SBC	REMAIN+LO	
10348   7EEC   8D 5D 6C    		STA	REMAIN+LO	
10349   7EEF   A9 00       		LDA	#0	
10350   7EF1   ED 5E 6C    		SBC	REMAIN+HI	
10351   7EF4   8D 5E 6C    		STA	REMAIN+HI	
10352   7EF7   60          	DIVEX:	RTS		
10353                      	
10354                      	
10355                      	; --------------
10356                      	; CALC ABS(QUOT)
10357                      	; --------------
10358                      	
10359   7EF8   A9 00       	ABQUOT:	LDA	#0	
10360   7EFA   38          		SEC		
10361   7EFB   ED 5B 6C    		SBC	QUOT+LO	
10362   7EFE   8D 5B 6C    		STA	QUOT+LO	
10363   7F01   A9 00       		LDA	#0	
10364   7F03   ED 5C 6C    		SBC	QUOT+HI	
10365   7F06   8D 5C 6C    		STA	QUOT+HI	
10366   7F09   60          		RTS		
10367                      	
10368                      	
10369                      	; -----------------
10370                      	; UNSIGNED DIVISION
10371                      	; -----------------
10372                      	; ENTRY: DIVIDEND IN [QUOT], DIVISOR IN [REMAIN]
10373                      	; EXIT: QUOTIENT IN [QUOT], REMAINDER IN [REMAIN]
10374                      	
10375   7F0A               	UDIV:
10376   7F0A   AD 5D 6C    		LDA	REMAIN+LO	; CHECK [REMAIN]
10377   7F0D   0D 5E 6C    		ORA	REMAIN+HI	; BEFORE PROCEEDING
10378   7F10   F0 3B       		BEQ	DIVERR	; CAN'T DIVIDE BY ZERO!
10379   7F12   20 52 7F    		JSR	MINIT	; SET IT ALL UP
10380   7F15   2E 5B 6C    	UDLOOP:	ROL	QUOT+LO	
10381   7F18   2E 5C 6C    		ROL	QUOT+HI	
10382   7F1B   2E 60 5B    		ROL	MTEMP+LO	
10383   7F1E   2E 61 5B    		ROL	MTEMP+HI	
10384   7F21   AD 60 5B    		LDA	MTEMP+LO	
10385   7F24   38          		SEC		
10386   7F25   ED 5D 6C    		SBC	REMAIN+LO	
10387   7F28   A8          		TAY		; SAVE HERE
10388   7F29   AD 61 5B    		LDA	MTEMP+HI	
10389   7F2C   ED 5E 6C    		SBC	REMAIN+HI	
10390   7F2F   90 06       		BCC	UDNEXT	
10391   7F31   8C 60 5B    		STY	MTEMP+LO	
10392   7F34   8D 61 5B    		STA	MTEMP+HI	
10393   7F37   CA          	UDNEXT:	DEX		
10394   7F38   D0 DB       		BNE	UDLOOP	
10395   7F3A   2E 5B 6C    		ROL	QUOT+LO	; SHIFT LAST CARRY FOR QUOTIENT
10396   7F3D   2E 5C 6C    		ROL	QUOT+HI	
10397   7F40   AD 60 5B    		LDA	MTEMP+LO	; MOVE REMAINDER
10398   7F43   8D 5D 6C    		STA	REMAIN+LO	; INTO [REMAIN]
10399   7F46   AD 61 5B    		LDA	MTEMP+HI	
  Wed May 24 1989 15:00                                                                                                  Page  157

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10400   7F49   8D 5E 6C    		STA	REMAIN+HI	
10401   7F4C   60          		RTS		
10402                      	
10403                      		; *** ERROR #8: DIVISION BY ZERO ***
10404                      	
10405   7F4D   A9 08       	DIVERR:	LDA	#8	
10406   7F4F   4C 0A 52    		JMP	ZERROR	
10407                      	
10408                      	
10409                      	; ---------
10410                      	; MATH INIT
10411                      	; ---------
10412                      	
10413   7F52   A2 10       	MINIT:	LDX	#16		; INIT LOOPING INDEX
10414   7F54   A9 00       		LDA	#0
10415   7F56   8D 60 5B    		STA	MTEMP+LO	; CLEAR TEMP
10416   7F59   8D 61 5B    		STA	MTEMP+HI	; REGISTER
10417   7F5C   18          		CLC			; AND CARRY
10418   7F5D   60          		RTS
10419                      	
10420                      	
10421                      	; -----
10422                      	; THROW
10423                      	; -----
10424                      	
10425   7F5E               	ZTHROW:
10426   7F5E   A5 65       		lda	ARG2+LO		; check to see if we are ready to do return
10427   7F60   CD 75 6C    		cmp	OLDZSP+LO
10428   7F63   D0 07       		bne	ZTHLOOP		; nope, keep unwinding the stack
10429   7F65   A5 66       		lda	ARG2+HI
10430   7F67   CD 76 6C    		cmp	OLDZSP+HI	; have we found the right frame yet?
10431   7F6A   F0 06       		beq	ZTHDO		; yes
10432   7F6C               	ZTHLOOP:
10433   7F6C   20 56 7B    		jsr	ZRET		; do another return
10434   7F6F   4C 5E 7F    		jmp	ZTHROW		; and try again
10435   7F72               	ZTHDO:	
10436   7F72   A5 65       		lda	ARG2+LO		; SET ZSTACK POINTER
10437   7F74   8D 75 6C    		sta	OLDZSP+LO	; UP FOR ZRET
10438   7F77   A5 66       		lda	ARG2+HI
10439   7F79   8D 76 6C    		sta	OLDZSP+HI
10440   7F7C   4C 56 7B    		jmp	ZRET
10441                      	
10442   7F7F               		END
10443                      	
10444   7F7F               		INCLUDE 	OPSX.ASM
10445                      		PAGE			
  Wed May 24 1989 15:00                                                                                                  Page  158

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10446   7F7F               		STTL "--- X-OPS ---"
10447                      	
10448                      	
10449                      		; ------
10450                      		; EQUAL?
10451                      		; ------
10452                      		; IS [ARG1] = [ARG2] (OR [ARG3] OR [ARG4])?
10453                      	
10454   7F7F               	ZEQUAL:
10455   7F7F   C6 62       		DEC	NARGS	; DOUBLE-CHECK # ARGS
10456   7F81   A5 63       		LDA	ARG1+LO	; FETCH LSB
10457   7F83   A6 64       		LDX	ARG1+HI	; AND MSB OF [ARG1]
10458   7F85   C5 65       		CMP	ARG2+LO	; TEST LSB OF [ARG2]
10459   7F87   D0 04       		BNE	TRY2	; NO GOOD, LOOK FOR ANOTHER ARG
10460   7F89   E4 66       		CPX	ARG2+HI	; ELSE TRY MSB OF [ARG2]
10461   7F8B   F0 18       		BEQ	EQOK	; MATCHED!
10462   7F8D   C6 62       	TRY2:	DEC	NARGS	; OUT OF ARGS YET?
10463   7F8F   F0 17       		BEQ	EQBAD	; YES, WE FAILED
10464   7F91   C5 67       		CMP	ARG3+LO	; TRY LSB OF [ARG3]
10465   7F93   D0 04       		BNE	TRY3	; NO GOOD, LOOK FOR ANOTHER ARG
10466   7F95   E4 68       		CPX	ARG3+HI	; HOW ABOUT MSB OF [ARG3]?
10467   7F97   F0 0C       		BEQ	EQOK	; YAY!
10468   7F99   C6 62       	TRY3:	DEC	NARGS	; OUT OF ARGS YET?
10469   7F9B   F0 0B       		BEQ	EQBAD	; IF NOT ...
10470   7F9D   C5 69       		CMP	ARG4+LO	; TRY [ARG4]
10471   7F9F   D0 07       		BNE	EQBAD	; SORRY, CHUM
10472   7FA1   E4 6A       		CPX	ARG4+HI	; MSB MATCHED?
10473   7FA3   D0 03       		BNE	EQBAD	; TOO BAD
10474                      	
10475   7FA5   4C 3B 44    	EQOK:	JMP	PREDS	; FINALLY MATCHED!
10476                      	
10477   7FA8   4C 2F 44    	EQBAD:	JMP	PREDF	; FAILURE (SNIFF!)
10478                      	
10479                      	
10480                      	; ----------------------------
10481                      	; ICALL,ICALL1, ICALL2, IXCALL
10482                      	; ----------------------------
10483                      	
10484   7FAB               	ZICALL:
10485   7FAB               	ZICLL1:
10486   7FAB               	ZICLL2:
10487   7FAB   A9 01       	ZIXCLL:	LDA	#1	; SET FLAG FOR RETURNLESS CALL
10488   7FAD   8D 5F 5B    		STA	IRET
10489   7FB0   D0 05       		BNE	IENTR	; JMP OVER NORMAL SETTING
10490                      	
10491                      	
10492                      	; -------------------
10493                      	; XCALL, CALL1, CALL2
10494                      	; -------------------
10495                      	
10496                      	ZXCALL:			; DROP	THROUGH
10497                      	ZCALL1:			; CALL	RTN HANDLES ALL 4 KINDS
10498   7FB2               	ZCALL2:
10499                      	
10500                      	; ----
10501                      	; CALL
10502                      	; ----
10503                      	; BRANCH TO FUNCTION AT ([ARG1]*4), PASSING
10504                      	; OPTIONAL PARAMETERS IN [ARG2]-[ARG4]
10505                      	; ([ARG5]-[ARG8] FOR XCALL (EZIP))
10506                      	
10507   7FB2   A9 00       	ZCALL:	LDA	#0
10508   7FB4   8D 5F 5B    		STA	IRET		; SET FLAG TO RETURN SOMETHING
10509   7FB7   A5 63       	IENTR:	LDA	ARG1+LO
10510   7FB9   05 64       		ORA	ARG1+HI		; IS CALL ADDRESS ZERO?
10511   7FBB   D0 0B       		BNE	DOCALL		; NO, CONTINUE
10512   7FBD   AD 5F 5B    		LDA	IRET		; any ret value?
10513   7FC0   F0 01       		BEQ	Ij		; yes, so return a zero
10514                      	
10515   7FC2   60          		RTS			; otherwise, just end
10516   7FC3               	Ij:
10517   7FC3   A2 00       		LDX	#0
10518   7FC5   4C DD 43    		JMP	PUTBYT		; ELSE RETURN THE ZERO IN [A]
10519   7FC8   AE 75 6C    	DOCALL:	LDX	OLDZSP+LO	; SAVE OLD STACK POINTER
10520   7FCB   AD 76 6C    		LDA	OLDZSP+HI
  Wed May 24 1989 15:00                                                                                                  Page  159

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10521   7FCE   20 9B 43    		JSR	PUSHXA
10522   7FD1   A5 80       		LDA	ZPCL		; AND LSB OF [ZPC]
10523   7FD3   AE 5F 5B    		LDX	IRET		; AND RETURN FLAG
10524   7FD6   20 9B 43    		JSR	PUSHXA		; ON THE Z-STACK
10525   7FD9   A6 81       		LDX	ZPCM		; SAVE MIDDLE 8 BITS
10526   7FDB   A5 82       		LDA	ZPCH		; AND TOP BIT OF [ZPC]
10527   7FDD   20 9B 43    		JSR	PUSHXA		; AS WELL
10528                      	
10529                      		; FORM 16-BIT ADDRESS FROM [ARG1]
10530                      	
10531   7FE0   A9 00       		LDA	#0	
10532   7FE2   06 63       		ASL	ARG1+LO		; MULTIPLY [ARG1]
10533   7FE4   26 64       		ROL	ARG1+HI		; (BY 2)
10534   7FE6   2A          		ROL	A		; >BIT INTO [A]
10535   7FE7   06 63       		ASL	ARG1+LO		; BY 4 (EZIP)
10536   7FE9   26 64       		ROL	ARG1+HI	
10537   7FEB   2A          		ROL	A
10538   7FEC   85 82       		STA	ZPCH		; NEW >BIT OF [ZPC]
10539   7FEE   A5 64       		LDA	ARG1+HI		; GET NEW <BYTES
10540   7FF0   85 81       		STA	ZPCM	
10541   7FF2   A5 63       		LDA	ARG1+LO	
10542   7FF4   85 80       		STA	ZPCL	
10543                      	;
10544                      	; now add offset
10545                      	;
10546   7FF6   18          		clc			; doing adding
10547   7FF7   A5 80       		lda	ZPCL		; start at lo part
10548   7FF9   65 5D       		adc	FOFFL		; add in lo part
10549   7FFB   85 80       		sta	ZPCL
10550   7FFD   A5 81       		lda	ZPCM
10551   7FFF   65 5C       		adc	FOFFM
10552   8001   85 81       		sta	ZPCM
10553   8003   A5 82       		lda	ZPCH
10554   8005   65 5B       		adc	FOFFH
10555   8007   85 82       		sta	ZPCH
10556   8009   20 AA 90    		jsr	VLDZPC	
10557   800C   20 1F 92    		jsr	NEXTPC		; FETCH # LOCALS TO PASS
10558   800F   85 7A       		sta	J+LO		; SAVE HERE FOR COUNTING
10559   8011   85 7B       		sta	J+HI		; AND HERE FOR LATER REFERENCE
10560   8013   F0 21       		beq	ZCLL2		; SKIP IF NO LOCALS
10561   8015   A9 00       		lda	#0	
10562   8017   85 78       		sta	I+LO		; ELSE INIT STORAGE INDEX
10563   8019               	ZCLL1:
10564   8019   A4 78       		LDY	I+LO	
10565   801B   BE 00 1E    		LDX	LOCALS+LO,Y	; GET LSB OF LOCAL INTO [X]
10566   801E   B9 01 1E    		LDA	LOCALS+HI,Y	; AND MSB INTO [A]
10567   8021   20 9B 43    		JSR	PUSHXA		; PUSH LOCAL IN [X/A] ONTO Z-STACK
10568   8024   A4 78       		LDY	I+LO		; RESTORE INDEX
10569   8026   A9 00       		LDA	#0		; ZERO ALL LOCALS (X)
10570   8028   99 00 1E    		STA	LOCALS+LO,Y
10571   802B   99 01 1E    		STA	LOCALS+HI,Y
10572   802E   C8          		INY		
10573   802F   C8          		INY			; UPDATE
10574   8030   84 78       		STY	I+LO		; THE STORAGE INDEX
10575   8032   C6 7A       		DEC	J+LO		; ANY MORE LOCALS?
10576   8034   D0 E3       		BNE	ZCLL1		; YES, KEEP LOOPING
10577                      	;
10578                      	; MOVE UP TO 7 ARGUMENTS TO [LOCALS]
10579                      	;
10580   8036               	ZCLL2:
10581   8036   AD 63 5B    		LDA	ASSVLU		; get how many here
10582   8039   20 9B 43    		JSR	PUSHXA		; save how many args for ASSIGNED?
10583   803C   C6 62       		DEC	NARGS		; EXTRA ARGS IN THIS CALL?
10584   803E   A5 62       		LDA	NARGS		; SAVE FOR ASSIGNED? OP
10585   8040   8D 63 5B    		STA	ASSVLU		; and save away
10586   8043   F0 5E       		BEQ	ZCALL3		; NO, CONTINUE
10587   8045   A5 65       		LDA	ARG2+LO		; MOVE [ARG2] TO LOCAL #1
10588   8047   8D 00 1E    		STA	LOCALS+LO	
10589   804A   A5 66       		LDA	ARG2+HI	
10590   804C   8D 01 1E    		STA	LOCALS+HI	
10591   804F   C6 62       		DEC	NARGS		; ANY LEFT?
10592   8051   F0 50       		BEQ	ZCALL3		; NO, SCRAM
10593   8053   A5 67       		LDA	ARG3+LO		; MOVE [ARG3] TO LOCAL #2
10594   8055   8D 02 1E    		STA	LOCALS+LO+2	
10595   8058   A5 68       		LDA	ARG3+HI	
  Wed May 24 1989 15:00                                                                                                  Page  160

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10596   805A   8D 03 1E    		STA	LOCALS+HI+2	
10597   805D   C6 62       		DEC	NARGS		; ANY LEFT?
10598   805F   F0 42       		BEQ	ZCALL3		; NO, EXUENT
10599   8061   A5 69       		LDA	ARG4+LO		; MOVE [ARG4] TO LOCAL #3
10600   8063   8D 04 1E    		STA	LOCALS+LO+4	
10601   8066   A5 6A       		LDA	ARG4+HI	
10602   8068   8D 05 1E    		STA	LOCALS+HI+4	
10603   806B   C6 62       		DEC	NARGS		; MORE (THAT MEANS IT'S AN XCALL)
10604   806D   F0 34       		BEQ	ZCALL3		; NO, JUST A CALL
10605   806F   A5 6B       		LDA	ARG5+LO		; MOVE [ARG5] TO LOCAL #4
10606   8071   8D 06 1E    		STA	LOCALS+LO+6	
10607   8074   A5 6C       		LDA	ARG5+HI	
10608   8076   8D 07 1E    		STA	LOCALS+HI+6	
10609   8079   C6 62       		DEC	NARGS		; MORE?
10610   807B   F0 26       		BEQ	ZCALL3		; NO
10611   807D   A5 6D       		LDA	ARG6+LO		; MOVE [ARG6] TO LOCAL #5
10612   807F   8D 08 1E    		STA	LOCALS+LO+8	
10613   8082   A5 6E       		LDA	ARG6+HI	
10614   8084   8D 09 1E    		STA	LOCALS+HI+8	
10615   8087   C6 62       		DEC	NARGS		; MORE?
10616   8089   F0 18       		BEQ	ZCALL3		; NO
10617   808B   A5 6F       		LDA	ARG7+LO		; MOVE [ARG7] TO LOCAL #6
10618   808D   8D 0A 1E    		STA	LOCALS+LO+10	
10619   8090   A5 70       		LDA	ARG7+HI	
10620   8092   8D 0B 1E    		STA	LOCALS+HI+10	
10621   8095   C6 62       		DEC	NARGS		; MORE?
10622   8097   F0 0A       		BEQ	ZCALL3		; NO
10623   8099   A5 71       		LDA	ARG8+LO		; MOVE [ARG8] TO LOCAL #7
10624   809B   8D 0C 1E    		STA	LOCALS+LO+12	
10625   809E   A5 72       		LDA	ARG8+HI	
10626   80A0   8D 0D 1E    		STA	LOCALS+HI+12	
10627   80A3   A6 7B       	ZCALL3:	LDX	J+HI		; RETRIEVE # LOCALS
10628   80A5   8A          		TXA			; DUPE FOR NO GOOD REASON
10629   80A6   20 9B 43    		JSR	PUSHXA		; PUSH # LOCALS ONTO Z-STACK
10630   80A9   A5 B0       		LDA	ZSP+HI		; REMEMBER WHERE
10631   80AB   8D 76 6C    		STA	OLDZSP+HI	; WE CAME FROM
10632   80AE   A5 AF       		LDA	ZSP+LO	
10633   80B0   8D 75 6C    		STA	OLDZSP+LO	
10634   80B3   60          		RTS			; WHEW!
10635                      	
10636                      	
10637                      	; ---
10638                      	; PUT
10639                      	; ---
10640                      	; SET ITEM [ARG2] IN WORD-TABLE [ARG1] EQUAL TO [ARG3]
10641   80B4               	ZPUT:
10642   80B4   06 65       		asl	ARG2+LO	; WORD-ALIGN [ARG2]
10643   80B6   26 66       		rol	ARG2+HI	
10644   80B8   20 CF 80    		jsr	PCALC	; GET ITEM ADDR INTO [SPC]
10645   80BB   A5 68       		lda	ARG3+HI	; STORE MSB OF [ARG3]
10646   80BD   20 35 92    		jsr	STASHB	; and store it away
10647   80C0   20 9E 8F    		jsr	NEXTSPC	; POINT TO LSB
10648   80C3   4C C9 80    		jmp	PUTLSB	; and put in lsb
10649                      	
10650                      	
10651                      	; ----
10652                      	; PUTB
10653                      	; ----
10654                      	; SET ITEM [ARG2] IN BYTE-TABLE [ARG1] EQUAL TO [ARG3]
10655                      	
10656   80C6   20 CF 80    	ZPUTB:	JSR	PCALC	
10657                      	;
10658                      	; ENTRY FOR "PUT"
10659                      	;
10660   80C9               	PUTLSB:
10661   80C9   A5 67       		LDA	ARG3+LO	; GET LSB OF [ARG3]
10662   80CB   20 35 92    		jsr	STASHB	; and save it away
10663   80CE   60          		RTS		
10664                      	
10665                      	
10666                      	; ---------------------------
10667                      	; CALC ITEM ADDRESS FOR "PUT"
10668                      	; ---------------------------
10669                      	; put the 3 byte address into SPC
10670                      	;
  Wed May 24 1989 15:00                                                                                                  Page  161

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10671   80CF   A5 65       	PCALC:	LDA	ARG2+LO	; ADD ITEM OFFSET IN [ARG2]
10672   80D1   18          		CLC		; TO TABLE ADDR IN [ARG1]
10673   80D2   65 63       		ADC	ARG1+LO	; TO FORM A POINTER
10674   80D4   85 8F       		STA	SPCL	; in [SPC]
10675   80D6   A5 66       		LDA	ARG2+HI	; SAME FOR MSB
10676   80D8   65 64       		ADC	ARG1+HI	
10677   80DA   20 77 8F    		jsr	SETPC	; and figger out where it is
10678   80DD   85 90       		sta	SPCH	; set page
10679   80DF   84 91       		sty	SPCBNK	; and bank
10680   80E1   60          		rts
10681                      	
10682                      	; ----
10683                      	; PUTP
10684                      	; ----
10685                      	; SET PROPERTY [ARG2] IN OBJECT [ARG1] EQUAL TO [ARG3]
10686                      	
10687   80E2               	ZPUTP:
10688   80E2   20 27 95    		jsr	PROPB		; GET PROP TBL ADDR
10689   80E5               	PUTP1:
10690   80E5   20 52 95    		jsr	PROPN		; GET ID
10691   80E8   C5 65       		cmp	ARG2+LO		; is it the wanted one?
10692   80EA   F0 08       		beq	PUTP2		; ayyup
10693   80EC   90 2F       		bcc	PNERR		; ERROR IF LOWER
10694   80EE   20 71 95    		jsr	PROPNX		; TRY NEXT PROPERTY, ALIGN [I] AT IT (EZIP)
10695   80F1   4C E5 80    		jmp	PUTP1		; and check again
10696   80F4               	PUTP2:
10697   80F4   20 58 95    		jsr	PROPL		; GET PROPERTY LENGTH INTO [A]
10698   80F7   AA          		tax			; save length
10699   80F8   20 BE 8F    		jsr	NEXTFPC		; and point to first prop. byte
10700   80FB   A5 8E       		lda	FPCBNK		; and copy FPC to SPC for storage
10701   80FD   85 91       		sta	SPCBNK
10702   80FF   A5 8D       		lda	FPCH
10703   8101   85 90       		sta	SPCH
10704   8103   A5 8C       		lda	FPCL
10705   8105   85 8F       		sta	SPCL		; saved it
10706   8107   E0 01       		cpx	#1		; IF LENGTH = 1
10707   8109   F0 0C       		beq	PUTP3		; PUT A BYTE
10708   810B   E0 02       		cpx	#2		; PUT A WORD IF [A] = 2
10709   810D   D0 13       		bne	PLERR		; ELSE LENGTH IS BAD
10710   810F   A5 68       		lda	ARG3+HI		; GET MSB OF PROPERTY
10711   8111   20 35 92    		jsr	STASHB		; and store in object
10712   8114   20 9E 8F    		jsr	NEXTSPC		; POINT TO LSB SLOT
10713   8117               	PUTP3:
10714   8117   A5 67       		lda	ARG3+LO		; FETCH LSB of property
10715   8119   20 35 92    		jsr	STASHB		; AND STORE IN OBJECT
10716   811C   60          		rts
10717                      	
10718                      		; *** ERROR #10: BAD PROPERTY NUMBER ***
10719                      	
10720   811D   A9 0A       	PNERR:	LDA	#10	
10721   811F   4C 0A 52    		JMP	ZERROR	
10722                      	
10723                      		; *** ERROR #11: PUTP PROPERTY LENGTH ***
10724                      	
10725   8122   A9 0B       	PLERR:	LDA	#11	
10726   8124   4C 0A 52    		JMP	ZERROR	
10727                      	
10728                      	
10729                      	; ------
10730                      	; PRINTC
10731                      	; ------
10732                      	; PRINT CHAR WITH ASCII VALUE IN [ARG1]
10733                      	
10734   8127   A5 63       	ZPRC:	LDA	ARG1+LO	; GRAB THE CHAR
10735   8129   4C 06 53    		JMP	COUT	; AND SHIP IT OUT
10736                      	
10737                      	
10738                      	; ------
10739                      	; PRINTN
10740                      	; ------
10741                      	; PRINT VALUE OF [ARG1] AS A SIGNED INTEGER
10742                      	
10743   812C   A5 63       	ZPRN:	LDA	ARG1+LO	; MOVE [ARG1] TO [QUOT]
10744   812E   8D 5B 6C    		STA	QUOT+LO	
10745   8131   A5 64       		LDA	ARG1+HI	
  Wed May 24 1989 15:00                                                                                                  Page  162

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10746   8133   8D 5C 6C    		STA	QUOT+HI	
10747                      	
10748                      		; PRINT [QUOT]
10749                      	
10750   8136   AD 5C 6C    	NUMBER:	LDA	QUOT+HI	; IF VALUE IS POSITIVE
10751   8139   10 08       		BPL	DIGCNT	; CONTINUE
10752   813B   A9 2D       		LDA	#'-'	; ELSE START WITH A MINUS SIGN
10753   813D   20 06 53    		JSR	COUT	
10754   8140   20 F8 7E    		JSR	ABQUOT	; AND CALC ABS([QUOT])
10755                      	
10756                      		; COUNT # OF DECIMAL DIGITS
10757                      	
10758   8143   A9 00       	DIGCNT:	LDA	#0	; RESET
10759   8145   8D 61 6C    		STA	DIGITS	; DIGIT INDEX
10760   8148   AD 5B 6C    	DGC:	LDA	QUOT+LO	; IS QUOTIENT
10761   814B   0D 5C 6C    		ORA	QUOT+HI	; ZERO YET?
10762   814E   F0 16       		BEQ	PRNTN3	; YES, READY TO PRINT
10763   8150   A9 0A       		LDA	#10	; ELSE DIVIDE [QUOT]
10764   8152   8D 5D 6C    		STA	REMAIN+LO	; BY 10 (LSB)
10765   8155   A9 00       		LDA	#0	
10766   8157   8D 5E 6C    		STA	REMAIN+HI	; 10 (MSB)
10767   815A   20 0A 7F    		JSR	UDIV	; UNSIGNED DIVIDE
10768   815D   AD 5D 6C    		LDA	REMAIN+LO	; FETCH LSB OF REMAINDER (THE DIGIT)
10769   8160   48          		PHA		; SAVE IT ON STACK
10770   8161   EE 61 6C    		INC	DIGITS	; UPDATE DIGIT COUNT
10771   8164   D0 E2       		BNE	DGC	; LOOP TILL QUOTIENT=0
10772   8166   AD 61 6C    	PRNTN3:	LDA	DIGITS	; IF DIGIT COUNT IS NZ
10773   8169   D0 05       		BNE	PRNTN4	; CONTINUE
10774   816B   A9 30       		LDA	#'0'	; ELSE PRINT "0"
10775   816D   4C 06 53    		JMP	COUT	; AND RETURN
10776   8170   68          	PRNTN4:	PLA		; PULL A DIGIT OFF THE STACK
10777   8171   18          		CLC		
10778   8172   69 30       		ADC	#'0'	; CONVERT TO DB	II
10779   8174   20 06 53    		JSR	COUT	; AND PRINT IT
10780   8177   CE 61 6C    		DEC	DIGITS	; OUT OF DIGITS YET?
10781   817A   D0 F4       		BNE	PRNTN4	; NO, KEEP LOOPING
10782   817C   60          		RTS		
10783                      	
10784                      	
10785                      	; ------
10786                      	; RANDOM
10787                      	; ------
10788                      	; RETURN A RANDOM VALUE BETWEEN 0 AND [ARG1]
10789                      	
10790   817D   A5 63       	ZRAND:	LDA	ARG1+LO		; IF VALUE IS ZERO
10791   817F   05 64       	 	ORA	ARG1+HI
10792   8181   D0 09       		BNE	ZRAND1
10793   8183   8D 71 6C    		STA	SRHOLD+LO	; RETURN TO RANDOM RANDOM
10794   8186   8D 72 6C    		STA	SRHOLD+HI	; CLEAR INDICATOR
10795   8189   4C DA 43    		JMP	RET0		; AND RETURN THRU HERE SO ALIGNED
10796   818C   AD 71 6C    	ZRAND1:	LDA	SRHOLD+LO	; ARE WE NONRAMDOM INCREMENTING? (EZIP)
10797   818F   0D 72 6C    		ORA	SRHOLD+HI
10798   8192   D0 41       		BNE	ZRAND3		; YUP
10799   8194   A5 64       		LDA	ARG1+HI
10800   8196   10 17       		BPL	ZRAND2		; GENERATE A RANDOM #
10801   8198   49 FF       		EOR	#$FF		; SET UP TO INCREMENT FROM 1 THRU INT
10802   819A   8D 72 6C    		STA	SRHOLD+HI	; GET ABSOLUTE
10803   819D   A5 63       		LDA	ARG1+LO
10804   819F   49 FF       		EOR	#$FF
10805   81A1   8D 71 6C    		STA	SRHOLD+LO
10806   81A4   EE 71 6C    		INC	SRHOLD+LO
10807   81A7   A9 00       		LDA	#0		; W/ NO RAMDOMNESS
10808   81A9   85 A5       		STA	RAND+HI
10809   81AB   85 A4       		STA	RAND+LO
10810   81AD   F0 26       		BEQ	ZRAND3		; JMP  (END EZIP)
10811   81AF   A5 63       	ZRAND2:	LDA	ARG1+LO		; MAKE [ARG1] THE DIVISOR
10812   81B1   85 65       		STA	ARG2+LO
10813   81B3   A5 64       		LDA	ARG1+HI
10814   81B5   85 66       		STA	ARG2+HI
10815   81B7   20 EA 52    		JSR	RANDOM		; GET RANDOM BYTES INTO [A] AND [X]
10816   81BA   86 63       		STX	ARG1+LO		; MAKE THEM THE DIVIDEND
10817   81BC   29 7F       		AND	#$7F		; MAKE SURE MSB IS POSITIVE
10818   81BE   85 64       		STA	ARG1+HI
10819   81C0   20 AE 7E    		JSR	DIVIDE		; SIGNED DIVIDE, [ARG1] / [ARG2]
10820   81C3   AD 5D 6C    		LDA	REMAIN+LO	; MOVE REMAINDER
  Wed May 24 1989 15:00                                                                                                  Page  163

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10821   81C6   18          		CLC
10822   81C7   69 01       		ADC	#1		; ADD 1
10823   81C9   85 76       		STA	VALUE+LO	; INTO [VALUE]
10824   81CB   AD 5E 6C    		LDA	REMAIN+HI
10825   81CE   69 00       		ADC	#0
10826   81D0   85 77       		STA	VALUE+HI
10827   81D2   4C E1 43    		JMP	PUTVAL		; AND RETURN RESULT
10828                      	
10829                      		; NON RANDOM INCREMENTING
10830                      	
10831   81D5               	ZRAND3:
10832   81D5   A5 A5       		LDA	RAND+HI	; (EZIP)
10833   81D7   CD 72 6C    		CMP	SRHOLD+HI
10834   81DA   90 11       		BCC	ZRAND4
10835   81DC   A5 A4       		LDA	RAND+LO
10836   81DE   CD 71 6C    		CMP	SRHOLD+LO
10837   81E1   90 0A       		BCC	ZRAND4
10838   81E3   F0 08       		BEQ	ZRAND4
10839   81E5   A9 01       		LDA	#1		; WENT THRU ALL
10840   81E7   85 A4       		STA	RAND+LO	; START AGAIN
10841   81E9   A9 00       		LDA	#0
10842   81EB   85 A5       		STA	RAND+HI
10843   81ED   A5 A4       	ZRAND4:	LDA	RAND+LO
10844   81EF   85 76       		STA	VALUE+LO
10845   81F1   A5 A5       		LDA	RAND+HI
10846   81F3   85 77       		STA	VALUE+HI
10847   81F5   E6 A4       		INC	RAND+LO	; FOR NEXT TIME
10848   81F7   D0 02       		BNE	ZRAND5
10849   81F9   E6 A5       		INC	RAND+HI
10850   81FB   4C E1 43    	ZRAND5:	JMP	PUTVAL		; (END EZIP)
10851                      	
10852                      	
10853                      	; ----
10854                      	; PUSH
10855                      	; ----
10856                      	; PUSH [ARG1] ONTO THE Z-STACK
10857                      	
10858   81FE   A6 63       	ZPUSH:	LDX	ARG1+LO	
10859   8200   A5 64       		LDA	ARG1+HI	
10860   8202   4C 9B 43    		JMP	PUSHXA	
10861                      	
10862                      	
10863                      	; ---
10864                      	; POP
10865                      	; ---
10866                      	; POP WORD OFF Z-STACK, STORE IN VARIABLE [ARG1]
10867                      	
10868   8205               	ZPOP:
10869   8205   A5 62       		lda	NARGS		; check whether it wants game or passed stack
10870   8207   F0 56       		beq	ZPOP1		; must want from game stack
10871                      	
10872   8209   A5 63       		lda	ARG1+LO		; get me the address of the LTABLE
10873   820B   85 8C       		sta	FPCL		; for munging with
10874   820D   A5 64       		lda	ARG1+HI		; this is page
10875   820F   20 77 8F    		jsr	SETPC		; get me actual page/bank
10876   8212   85 8D       		sta	FPCH		; set page
10877   8214   84 8E       		sty	FPCBNK		; and bank
10878                      	
10879   8216   20 56 92    		jsr	FETCHB		; this is hi part of counter
10880   8219   85 7B       		sta	J+HI		; save it
10881   821B   20 BE 8F    		jsr	NEXTFPC		; point to lo part
10882   821E   20 56 92    		jsr	FETCHB		; get it
10883   8221   85 7A       		sta	J+LO		; save it
10884                      	;
10885                      	; now count popping this one and stash it into the table
10886                      	;
10887   8223   E6 7A       		inc	J+LO		; count it
10888   8225   D0 02       		bne	ZPOP2		; wrapped?
10889   8227   E6 7B       		inc	J+HI		; increment MSB
10890   8229               	ZPOP2:
10891   8229   20 73 90    		jsr	FP2SP		; set up to stash back in beginning of LTABLE
10892   822C   A5 7A       		lda	J+LO		; LSB first
10893   822E   20 35 92    		jsr	STASHB		; saved it
10894   8231   20 4E 90    		jsr	PREVSPC		; point to MSB
10895   8234   A5 7B       		lda	J+HI		; get it
  Wed May 24 1989 15:00                                                                                                  Page  164

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10896   8236   20 35 92    		jsr	STASHB		; saved it
10897                      	;
10898                      	; finally, we can save the arg into the stack
10899                      	;
10900   8239   06 7A       		asl	J+LO		; make a word offset (*2)
10901   823B   26 7B       		rol	J+HI		; pick up carry maybe
10902   823D   A5 7A       		lda	J+LO		; add in arg offset
10903   823F   18          		clc			; adding
10904   8240   65 63       		adc	ARG1+LO		; figger offset
10905   8242   85 8C       		sta	FPCL		; this goes here for fetching
10906   8244   A5 7B       		lda	J+HI		; now page
10907   8246   65 64       		adc	ARG1+HI		; add in start of table
10908   8248   20 77 8F    		jsr	SETPC		; get me memory page
10909   824B   85 8D       		sta	FPCH		; page
10910   824D   84 8E       		sty	FPCBNK		; and bank
10911   824F   20 56 92    		jsr	FETCHB		; get MSB
10912   8252   85 77       		sta	VALUE+HI	; save value
10913   8254   20 BE 8F    		jsr	NEXTFPC		; and point to LSB
10914   8257   20 56 92    		jsr	FETCHB		; get LSB
10915   825A   85 76       		sta	VALUE+LO	; and save
10916   825C   4C 62 82    		jmp	ZPOP3		; and return it
10917   825F               	ZPOP1:
10918   825F   20 66 43    		jsr	POPVAL		; VALUE INTO [VALUE]
10919   8262               	ZPOP3:
10920   8262   4C E1 43    		jmp	PUTVAL		; AND put the data away
10921                      	
10922                      	
10923                      	; ------
10924                      	; INTBL?
10925                      	; ------
10926                      	
10927   8265               	ZINTBL:
10928   8265   A5 68       		LDA	ARG3+HI		; JIC COUNT IS 0,
10929   8267   30 7D       		BMI	INTNF		; >0, just ignore!
10930   8269   05 67       		ORA	ARG3+LO
10931   826B   F0 79       		BEQ	INTNF		; SAY NOT FOUND
10932                      	
10933   826D   A5 62       		LDA	NARGS		; IS THERE A RECORD SPEC?
10934   826F   C9 04       		CMP	#4
10935   8271   F0 04       		BEQ	SET4
10936   8273   A9 82       	SETDEF:	LDA	#130		; NO, SET DEFAULT
10937   8275   85 69       		STA	ARG4+LO
10938                      	
10939   8277   A5 69       	SET4:	LDA	ARG4+LO
10940   8279   F0 F8       		BEQ	SETDEF		; GO BACK AND GET VALUE
10941   827B   A9 00       		LDA	#0		; COMPARE BYTE OR WORD?
10942   827D   06 69       		ASL	ARG4+LO
10943   827F   2A          		ROL	A		; PICK UP INDICATOR
10944   8280   46 69       		LSR	ARG4+LO		; CLEAR FROM RECORD LENGTH
10945   8282   8D 62 5B    		STA	TYPE 		; BYTE (0) OR WORD (1)
10946   8285   AD 62 5B    		LDA	TYPE		; SET FLAG
10947   8288   D0 04       		BNE	SETTBL
10948   828A   A5 63       		LDA	ARG1+LO		; IF ONLY BYTE, MOVE IT
10949   828C   85 64       		STA	ARG1+HI		; TO FIRST BYTE CHECKED
10950   828E               	SETTBL:
10951   828E   A5 65       		LDA	ARG2+LO		; PICK UP TBL ADDR
10952   8290   85 86       		STA	MPCL
10953   8292   A5 66       		LDA	ARG2+HI
10954   8294   85 87       		STA	MPCM
10955   8296   A9 00       		LDA	#0
10956   8298   85 88       		STA	MPCH		; ONLY A WORD ADDR, SO IN 1ST 64K
10957   829A   20 80 90    		JSR	VLDMPC
10958                      	
10959   829D   A5 86       	INTLP:	LDA	MPCL		; HOLD START ADDR, MPC WILL BE A MESS
10960   829F   8D 7B 00    		STA	VWCUR+0
10961   82A2   A5 87       		LDA	MPCM
10962   82A4   8D 7C 00    		STA	VWCUR+1
10963   82A7   A5 88       		LDA	MPCH
10964   82A9   8D 7D 00    		STA	VWCUR+2
10965   82AC   20 09 92    		JSR	GETBYT		; GET 1ST BYTE
10966   82AF   C5 64       		CMP	ARG1+HI		; DOES IT = THE VALUE LOOKING FOR?
10967   82B1   D0 0C       		BNE	INTNXT		; NO
10968   82B3   AD 62 5B    		LDA	TYPE
10969   82B6   F0 3A       		BEQ	INTFND		; ONLY COMPARING A BYTE SO FOUND!
10970   82B8   20 09 92    		JSR	GETBYT
  Wed May 24 1989 15:00                                                                                                  Page  165

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10971   82BB   C5 63       		CMP	ARG1+LO
10972   82BD   F0 33       		BEQ	INTFND		; YES, FOUND IT
10973   82BF               	INTNXT:
10974   82BF   AD 7B 00    		LDA	VWCUR+0		; TO MOVE UP, JUST ADD
10975   82C2   18          		CLC			; OFFSET FROM START OF THIS
10976   82C3   65 69       		ADC	ARG4+LO		; ENTRY
10977   82C5   85 86       		STA	MPCL
10978   82C7   90 11       		BCC	INEXT0
10979                      	
10980   82C9   AD 7C 00    		LDA	VWCUR+1		; PICK UP CARRY
10981   82CC   69 00       		ADC	#0
10982   82CE   85 87       		STA	MPCM
10983   82D0   AD 7D 00    		LDA	VWCUR+2
10984   82D3   69 00       		ADC	#0
10985   82D5   85 88       		STA	MPCH
10986   82D7   20 80 90    		JSR	VLDMPC		; CROSSED PAGE SO RE-VALIDATE
10987                      	
10988   82DA   C6 67       	INEXT0:	DEC	ARG3+LO		; CHECKED ALL ENTRIES?
10989   82DC   D0 BF       		BNE	INTLP
10990   82DE   A5 68       		LDA	ARG3+HI
10991   82E0   F0 04       		BEQ	INTNF
10992   82E2   C6 68       		DEC	ARG3+HI
10993   82E4   D0 B7       		BNE	INTLP
10994                      	
10995   82E6               	INTNF:
10996   82E6   A9 00       		LDA	#0		; 0 = NOT FOUND
10997   82E8   85 76       		STA	VALUE+LO
10998   82EA   85 77       		STA	VALUE+HI
10999   82EC   20 E1 43    		JSR	PUTVAL
11000   82EF   4C 2F 44    		JMP	PREDF		; FAILED!
11001                      	
11002   82F2               	INTFND:
11003   82F2   AD 7B 00    		LDA	VWCUR+LO
11004   82F5   85 76       		STA	VALUE+LO	; AND SET TO RETURN THE VALUE
11005   82F7   AD 7C 00    		LDA	VWCUR+HI
11006   82FA   85 77       		STA	VALUE+HI
11007   82FC   20 E1 43    		JSR	PUTVAL		; SEND IT BACK
11008   82FF   4C 3B 44    		JMP	PREDS		; AND SCREEM SUCCESS
11009                      	
11010                      	; ----
11011                      	; BCOM
11012                      	; ----
11013                      	; COMPLEMENT [ARG1]
11014                      	
11015   8302   A5 63       	ZBCOM:	LDA	ARG1+LO
11016   8304   49 FF       		EOR	#$FF
11017   8306   85 76       		STA	VALUE+LO
11018   8308   A5 64       		LDA	ARG1+HI
11019   830A   49 FF       		EOR	#$FF
11020   830C   85 77       		STA	VALUE+HI
11021   830E   4C E1 43    		JMP	PUTVAL
11022                      	
11023                      	
11024                      	; -----
11025                      	; COPYT
11026                      	; -----
11027                      	
11028   8311               	ZCOPYT:
11029   8311   A5 65       		LDA	ARG2+LO		; CHECK OUT WHAT'S TO BE DONE
11030   8313   05 66       		ORA	ARG2+HI
11031   8315   D0 03       		BNE	ZC0
11032   8317   4C C6 83    		JMP	CASE1		; ZERO LENGTH BYTES OF SOURCE
11033   831A               	ZC0:
11034   831A   A5 68       		LDA	ARG3+HI
11035   831C   C9 7F       		CMP	#$7F
11036   831E   90 03       		BCC	CASE2
11037   8320   4C EC 83    		JMP	CASE3		; FORWARD COPY
11038                      	
11039                      		; CASE2 - CHECK IF FORWARD OR BACKWARD COPY
11040                      	
11041   8323   A5 64       	CASE2:	LDA	ARG1+HI		; IF SRC < DEST
11042   8325   C5 66       		CMP	ARG2+HI
11043   8327   90 0D       		BCC	CHK2
11044   8329   F0 03       		BEQ	ZC1
11045   832B   4C 4F 83    		JMP	FRWRD		; NO
  Wed May 24 1989 15:00                                                                                                  Page  166

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11046   832E   A5 63       	ZC1:	LDA	ARG1+LO
11047   8330   C5 65       		CMP	ARG2+LO
11048   8332   F0 02       		BEQ	CHK2
11049   8334   B0 19       		BCS	FRWRD		; NO
11050   8336   A5 63       	CHK2:	LDA	ARG1+LO		; AND SRC + LENGTH > DEST
11051   8338   18          		CLC
11052   8339   65 67       		ADC	ARG3+LO
11053   833B   85 78       		STA	I+LO
11054   833D   A5 64       		LDA	ARG1+HI
11055   833F   65 68       		ADC	ARG3+HI
11056   8341   C5 66       		CMP	ARG2+HI
11057   8343   90 0A       		BCC	FRWRD		; NO
11058   8345   D0 3E       		BNE	BKWRD		; YES
11059   8347   A5 78       		LDA	I+LO
11060   8349   C5 65       		CMP	ARG2+LO
11061   834B   F0 02       		BEQ	FRWRD		; DEBUG, IF EQUAL REALLY LESS
11062   834D   B0 36       		BCS	BKWRD		; OVERLAPS SO DO BACKWARD COPY
11063                      	
11064                      		; ELSE FALL THROUGH TO FORWARD COPY
11065                      	
11066   834F   A9 00       	FRWRD:	LDA	#0		; USE GETBYT CAUSE MAY  BE
11067   8351   85 88       		STA	MPCH		; BEYOND MAIN MEMORY
11068   8353   A5 64       		LDA	ARG1+HI
11069   8355   85 87       		STA	MPCM
11070   8357   A5 63       		LDA	ARG1+LO
11071   8359   85 86       		STA	MPCL
11072   835B   20 80 90    		JSR	VLDMPC		; AND ALIGN TO CORRECT PAGE
11073   835E   A5 65       		LDA	ARG2+LO
11074   8360   85 8F       		STA	SPCL
11075   8362   A5 66       		LDA	ARG2+HI
11076   8364   20 77 8F    		jsr	SETPC		; get memory spot
11077   8367   85 90       		sta	SPCH		; high part
11078   8369   84 91       		sty	SPCBNK		; and the bank part
11079   836B   A5 67       		LDA	ARG3+LO
11080   836D   85 7A       		STA	J+LO
11081   836F   A5 68       		LDA	ARG3+HI
11082   8371   85 7B       		STA	J+HI
11083   8373               	FRLP:
11084   8373   20 C6 44    		jsr	DECJ
11085   8376   90 0C       		bcc	FRDUN		; CARRY CLEAR ON $FFFF
11086   8378   20 09 92    		jsr	GETBYT
11087   837B   20 35 92    		jsr	STASHB		; and save it
11088   837E   20 9E 8F    		jsr	NEXTSPC		; and point to next one
11089   8381   4C 73 83    		jmp	FRLP
11090   8384               	FRDUN:
11091   8384   60          		rts
11092                      	
11093                      	
11094   8385               	BKWRD:	
11095   8385   A5 67       		LDA	ARG3+LO		; DECR 1ST TO GET CORRECT OFFSET
11096   8387   85 7A       		STA	J+LO
11097   8389   A5 68       		LDA	ARG3+HI
11098   838B   85 7B       		STA	J+HI
11099   838D   20 C6 44    		JSR	DECJ
11100   8390   A5 63       		LDA	ARG1+LO		; SET TO END OF SOURCE & DEST.
11101   8392   18          		CLC
11102   8393   65 7A       		ADC	J+LO
11103   8395   85 8C       		sta	FPCL		; set up fetch pointer
11104   8397   A5 64       		LDA	ARG1+HI
11105   8399   65 7B       		ADC	J+HI
11106   839B   20 77 8F    		jsr	SETPC		; and get mem locations
11107   839E   85 8D       		sta	FPCH
11108   83A0   84 8E       		sty	FPCBNK
11109   83A2   A5 65       		LDA	ARG2+LO
11110   83A4   18          		CLC
11111   83A5   65 7A       		ADC	J+LO
11112   83A7   85 8F       		sta	SPCL		; and now set up stash pointer
11113   83A9   A5 66       		LDA	ARG2+HI
11114   83AB   65 7B       		ADC	J+HI
11115   83AD   20 77 8F    		jsr	SETPC		; and get me page/bank
11116   83B0   85 90       		sta	SPCH
11117   83B2   84 91       		sty	SPCBNK
11118   83B4               	BKLP:
11119   83B4   20 56 92    		jsr	FETCHB		; get byte
11120   83B7   20 35 92    		jsr	STASHB		; and save it
  Wed May 24 1989 15:00                                                                                                  Page  167

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11121   83BA   20 24 90    		jsr	PREVFPC		; going backwards
11122   83BD   20 4E 90    		jsr	PREVSPC		; and here too
11123   83C0   20 C6 44    		jsr	DECJ		; RETURNS CARRY CLEAR ON $FFFF
11124   83C3   B0 EF       		bcs	BKLP
11125   83C5               	BKDUN:
11126   83C5   60          		RTS
11127                      	
11128                      		; ZERO LENGTH # OF BYTES OF SOURCE
11129                      	
11130   83C6   A5 63       	CASE1:	LDA	ARG1+LO
11131   83C8   85 8F       		STA	SPCL		; set stash pointer
11132   83CA   A5 64       		LDA	ARG1+HI
11133   83CC   20 77 8F    		jsr	SETPC		; get page/bank
11134   83CF   85 90       		sta	SPCH
11135   83D1   84 91       		sty	SPCBNK
11136   83D3   A5 67       		LDA	ARG3+LO		; SET UP COUNTER
11137   83D5   85 7A       		STA	J+LO
11138   83D7   A5 68       		LDA	ARG3+HI
11139   83D9   85 7B       		STA	J+HI
11140   83DB               	C1LP:
11141   83DB   20 C6 44    		jsr	DECJ		; CARRY CLEAR WHEN J = $FFFF
11142   83DE   90 0B       		bcc	C1DUN
11143   83E0   A9 00       		lda	#0
11144   83E2   20 35 92    		jsr	STASHB		; and zero it
11145   83E5   20 9E 8F    		jsr	NEXTSPC		; and point to next one
11146   83E8   4C DB 83    		jmp	C1LP
11147   83EB               	C1DUN:
11148   83EB   60          		rts
11149                      	
11150                      		; 2'S COMPLEMENT LENGTH (XOR + 1) THEN DO FORWARD COPY
11151                      	
11152   83EC               	CASE3:
11153   83EC   A5 67       		LDA	ARG3+LO
11154   83EE   49 FF       		EOR	#$FF
11155   83F0   85 67       		STA	ARG3+LO
11156   83F2   A5 68       		LDA	ARG3+HI
11157   83F4   49 FF       		EOR	#$FF
11158   83F6   85 68       		STA	ARG3+HI
11159   83F8   E6 67       		INC	ARG3+LO
11160   83FA   D0 02       		BNE	GOFRWD
11161   83FC   E6 68       		INC	ARG3+HI
11162   83FE   4C 4F 83    	GOFRWD:	JMP	FRWRD
11163                      	
11164                      	
11165                      	; ---------
11166                      	; ASSIGNED?
11167                      	; ---------
11168                      	
11169                      	
11170   8401               	ZASSND:
11171   8401   A5 63       		LDA	ARG1+LO		; COMPARE TO # OF OPTIONALS FROM LAST CALL
11172   8403   CD 63 5B    		CMP	ASSVLU
11173   8406   90 05       		BCC	DOYES		; IF LESS OR EQUAL, WAS ASSIGNED
11174   8408   F0 03       		BEQ	DOYES
11175   840A   4C 2F 44    		JMP	PREDF
11176   840D               	DOYES:
11177   840D   4C 3B 44    		JMP	PREDS
11178                      	
11179                      	
11180                      	; -------------
11181                      	; LOGICAL SHIFT
11182                      	; -------------
11183                      	; SHIFT ARG1, ARG2 BITS (LEFT IF ARG2 IS POS. RIGHT IF NEG.)
11184                      	
11185   8410   A5 63       	ZSHIFT:	LDA	ARG1+LO		; SET UP FOR SHIFT
11186   8412   85 76       		STA	VALUE+LO
11187   8414   A5 64       		LDA	ARG1+HI
11188   8416   85 77       		STA	VALUE+HI
11189   8418   A5 65       		LDA	ARG2+LO		; IF NEGATIVE, SHIFT RIGHT
11190   841A   C9 80       		CMP	#$80
11191   841C   B0 0B       		BCS	SRIGHT
11192                      	
11193                      		; SHIFT LEFT
11194                      	
11195   841E   A8          		TAY			; COUNT
  Wed May 24 1989 15:00                                                                                                  Page  168

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11196   841F   06 76       	SLP1:	ASL	VALUE+LO
11197   8421   26 77       		ROL	VALUE+HI
11198   8423   88          		DEY
11199   8424   D0 F9       		BNE	SLP1
11200   8426   4C E1 43    		JMP	PUTVAL		; AND RETURN THE VALUE
11201                      	
11202   8429   49 FF       	SRIGHT:	EOR	#$FF		; COMPLEMENT
11203   842B   A8          		TAY
11204   842C   46 77       	SLP2:	LSR	VALUE+HI	; SHIFT
11205   842E   66 76       		ROR	VALUE+LO
11206   8430   88          		DEY
11207   8431   10 F9       		BPL	SLP2
11208   8433   4C E1 43    		JMP	PUTVAL
11209                      	
11210                      	
11211                      	; ----------------
11212                      	; ARITHMETIC SHIFT
11213                      	; ----------------
11214                      	; PROPAGATING SIGN BIT ON RIGHT SHIFT
11215                      	
11216   8436   A5 65       	ZASHFT:	LDA	ARG2+LO		; IF NEGATIVE, SHIFT RIGHT
11217   8438   C9 80       		CMP	#$80
11218   843A   90 D4       		BCC	ZSHIFT		; SAME AS LOGICAL SHIFT
11219   843C   A6 63       		LDX	ARG1+LO		; SET UP FOR SHIFT
11220   843E   86 76       		STX	VALUE+LO
11221   8440   A6 64       		LDX	ARG1+HI
11222   8442   86 77       		STX	VALUE+HI
11223                      	
11224   8444   49 FF       		EOR	#$FF		; COMPLEMENT COUNT
11225   8446   A8          		TAY
11226   8447   A5 64       	ASLP2:	LDA	ARG1+HI
11227   8449   0A          		ASL	A		; GET SIGN BIT
11228   844A   66 77       		ROR	VALUE+HI	; SHIFT
11229   844C   66 76       		ROR	VALUE+LO
11230   844E   88          		DEY
11231   844F   10 F6       		BPL	ASLP2
11232   8451   4C E1 43    		JMP	PUTVAL
11233   8454               		
11234                      	; --------
11235                      	; XPUSH
11236                      	; --------
11237   8454               	ZXPUSH:
11238   8454   A5 65       		lda	ARG2+LO		; get me the address of the LTABLE
11239   8456   85 8C       		sta	FPCL		; for munging with
11240   8458   A5 66       		lda	ARG2+HI		; this is page
11241   845A   20 77 8F    		jsr	SETPC		; get me actual page/bank
11242   845D   85 8D       		sta	FPCH		; set page
11243   845F   84 8E       		sty	FPCBNK		; and bank
11244                      	
11245   8461   20 56 92    		jsr	FETCHB		; this is hi part of counter
11246   8464   85 7B       		sta	J+HI		; save it
11247   8466   20 BE 8F    		jsr	NEXTFPC		; point to lo part
11248   8469   20 56 92    		jsr	FETCHB		; get it
11249   846C   85 7A       		sta	J+LO		; thanx
11250   846E   05 7B       		ora	J+HI		; check for zero elements left
11251   8470   D0 03       		bne	ZXP0		; yes, there is room at the inn
11252                      	
11253   8472   4C 2F 44    		jmp	PREDF		; no room here!
11254   8475               	ZXP0:
11255   8475   20 73 90    		jsr	FP2SP		; set up to stash back in beginning of LTABLE
11256   8478   A5 7B       		lda	J+HI		; now the MSB
11257   847A   85 7D       		sta	K+HI		; and saved it
11258   847C   A5 7A       		lda	J+LO		; save this
11259   847E   85 7C       		sta	K+LO		; save it
11260                      	;
11261                      	; now count this one and stash it into the table
11262                      	;
11263   8480   D0 02       		bne	ZXP1		; nope, dec okay
11264   8482   C6 7B       		dec	J+HI		; decrement MSB
11265   8484               	ZXP1:
11266   8484   C6 7A       		dec	J+LO		; and the LSB
11267   8486   A5 7A       		lda	J+LO		; LSB first
11268   8488   20 35 92    		jsr	STASHB		; saved it
11269   848B   20 4E 90    		jsr	PREVSPC		; point to MSB
11270   848E   A5 7B       		lda	J+HI		; get it
  Wed May 24 1989 15:00                                                                                                  Page  169

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11271   8490   20 35 92    		jsr	STASHB		; saved it
11272                      	;
11273                      	; finally, we can save the arg into the stack
11274                      	;
11275   8493   06 7C       		asl	K+LO		; make a word offset (*2)
11276   8495   26 7D       		rol	K+HI		; pick up carry maybe
11277   8497   A5 7C       		lda	K+LO		; add in arg offset
11278   8499   18          		clc			; adding
11279   849A   65 65       		adc	ARG2+LO		; figger offset
11280   849C   85 8F       		sta	SPCL		; this goes here for stashing
11281   849E   A5 7D       		lda	K+HI		; now page
11282   84A0   65 66       		adc	ARG2+HI		; add in start of table
11283   84A2   20 77 8F    		jsr	SETPC		; get me memory page
11284   84A5   85 90       		sta	SPCH		; page
11285   84A7   84 91       		sty	SPCBNK		; and bank
11286                      	
11287   84A9   A5 64       		lda	ARG1+HI		; push MSB
11288   84AB   20 35 92    		jsr	STASHB		; saved
11289   84AE   20 9E 8F    		jsr	NEXTSPC		; point to next one
11290   84B1   A5 63       		lda	ARG1+LO		; and now LSB 
11291   84B3   20 35 92    		jsr	STASHB		; into the stack
11292   84B6   4C 3B 44    		jmp	PREDS		; show we worked good
11293                      	;---------
11294                      	; ZFSTACK
11295                      	;---------
11296   84B9               	ZFSTACK:
11297   84B9   C6 62       		dec	NARGS		; how many args there?
11298   84BB   D0 0E       		bne	ZFS1		; flush ARG2 stack
11299                      	;
11300                      	; pop from system stack
11301                      	;
11302   84BD   A5 63       		lda	ARG1+LO		; just add number to system counter
11303   84BF   18          		clc			; adding
11304   84C0   65 AF       		adc	ZSP+LO		; added
11305   84C2   85 AF       		sta	ZSP+LO		; and saved
11306   84C4   A5 64       		lda	ARG1+HI		; get hi part
11307   84C6   65 B0       		adc	ZSP+HI		; add in hi part
11308   84C8   85 B0       		sta	ZSP+HI		; save hi part
11309   84CA   60          		rts
11310   84CB               	ZFS1:
11311   84CB   A5 65       		lda	ARG2+LO		; get LTABLE we are interested in
11312   84CD   85 8C       		sta	FPCL		; set up FPC first
11313   84CF   A5 66       		lda	ARG2+HI		; and page
11314   84D1   20 77 8F    		jsr	SETPC		; tell me where
11315   84D4   85 8D       		sta	FPCH		; save me where
11316   84D6   84 8E       		sty	FPCBNK		; FPC all set
11317   84D8   20 73 90    		jsr	FP2SP		; have SPC point to stack too
11318                      	
11319   84DB   20 56 92    		jsr	FETCHB		; get MSB of counter
11320   84DE   85 7B       		sta	J+HI		; save MSB
11321   84E0   20 BE 8F    		jsr	NEXTFPC		; point to LSB
11322   84E3   20 56 92    		jsr	FETCHB		; get LSB
11323   84E6   85 7A       		sta	J+LO		; save LSB
11324   84E8               		
11325   84E8   A5 7A       		lda	J+LO		; get LSB back
11326   84EA   18          		clc			; get ready for add
11327   84EB   65 63       		adc	ARG1+LO		; add how many to get rid off
11328   84ED   85 7A       		sta	J+LO		; save new counter
11329   84EF   A5 7B       		lda	J+HI		; get MSB
11330   84F1   65 64       		adc	ARG1+HI		; add MSB
11331                      	
11332   84F3   20 35 92    		jsr	STASHB		; save Msb of new counter
11333   84F6   20 9E 8F    		jsr	NEXTSPC		; point to LSB
11334   84F9   A5 7A       		lda	J+LO		; get lsb
11335   84FB   20 35 92    		jsr	STASHB		; okay, reset the counter
11336   84FE   60          		rts
11337                      	
11338                      	;
11339                      	; no mouse stuff yet
11340                      	;
11341   84FF               	ZMINFO:
11342   84FF               	ZMLIMIT:
11343   84FF   60          		rts
11344   8500               	ZMENU:
11345   8500   4C 2F 44    		jmp	PREDF		; no menu stuff either
  Wed May 24 1989 15:00                                                                                                  Page  170

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11346                      	
11347   8503               		END
11348                      	
11349   8503               		INCLUDE 	READ.ASM
11350   8503               		STTL "--- READ HANDLER ---"
11351                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page  171

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11352                      	; ----
11353                      	; READ
11354                      	; ----
11355                      	; READ LINE INTO TABLE [ARG1] ; PARSE INTO TABLE [ARG2] (IF ARG2 IS THERE)
11356                      	
11357   8503   00          	MAXWORDS DB	0		; maximum number of words in table
11358   8504   00          	WORDCNT	DB	0		; how many words read so far
11359   8505   00          	WORDSTART DB	0		; table offset of word
11360   8506               	SAVESPC	DS	3		; SPC that points to Word Count
11361                      	
11362   8509               	ZREAD:
11363   8509   A5 64       		lda	ARG1+HI		; MAKE THE TABLE ADDRESSES
11364   850B   8D 7B 6C    		sta	RDTBL1+HI	; AND PLACE IT HERE TO USE
11365   850E   A5 63       		lda	ARG1+LO
11366   8510   8D 7A 6C    		sta	RDTBL1+LO	; LSBS NEED NOT CHANGE
11367                      	
11368   8513   A9 00       		lda	#0		; TURN OFF FLAGS
11369   8515   8D 57 6C    		sta	PSVFLG		; FOR ZLEX
11370   8518   8D 58 6C    		sta	VOCFLG
11371                      	
11372   851B   A6 62       		ldx	NARGS
11373   851D   CA          		dex			; IF 2ND TBL ADDR 0 OR NOT THERE
11374   851E   F0 14       		beq	ONLYRD		; JUST READ IN DON'T DO CONVERSION (X)
11375   8520   A2 00       		ldx	#0		; JIC
11376   8522   A5 66       		lda	ARG2+HI
11377   8524   05 65       		ora	ARG2+LO
11378   8526   F0 0C       		beq	ONLYRD
11379                      	
11380   8528   A5 66       		lda	ARG2+HI
11381   852A   8D 7D 6C    		sta	RDTBL2+HI
11382   852D   A5 65       		lda	ARG2+LO
11383   852F   8D 7C 6C    		sta	RDTBL2+LO
11384                      	
11385   8532   A2 01       		ldx	#1		;  1 = DO IT ALL (X)
11386   8534               	ONLYRD:
11387   8534   8E 65 5B    		stx	RDFLAG		; CHECK AGAIN AFTER READ IN WHAT TO DO
11388   8537   20 15 59    		jsr	INPUT		; READ LINE; RETURN LENGTH IN [RDTBL1],1
11389                      	
11390   853A   AD 65 5B    		lda	RDFLAG		; FLAG (X)
11391   853D   F0 03       		beq	RDEX		; IF INPUT ONLY, LEAVE NOW
11392   853F   20 4F 85    		jsr	DOREST
11393   8542               	RDEX:
11394   8542   A9 F0       		lda	#$F0		; RETURN NOW ONLY WANTED READ PART
11395   8544   8D 65 5B    		sta	RDFLAG
11396   8547   AD 64 5B    		lda	BRKCHR		; GET BREAK CHAR
11397   854A   A2 00       		ldx	#0
11398   854C   4C DD 43    		jmp	PUTBYT		; RETURN IT 
11399                      	;
11400                      	; IF TIMEOUT, [A]=0 SO WILL QUIT W/NO RESULTS
11401                      	;
11402   854F               	DOREST:
11403   854F   AD 7D 6C    		lda	RDTBL2+HI	; get max number of words
11404   8552   20 77 8F    		jsr	SETPC		; tell me memory and bank
11405   8555   85 8D       		sta	FPCH		; save page
11406   8557   84 8E       		sty	FPCBNK		; and bank
11407   8559   AD 7C 6C    		lda	RDTBL2+LO	; and for LSB
11408   855C   85 8C       		sta	FPCL		; it is same
11409   855E   20 56 92    		jsr	FETCHB		; get max # of words in table
11410   8561   F0 04       		beq	RDERR		; (5/14/85 - FORCE # WORDS TO
11411   8563   C9 3B       		cmp	#59		; BE BETWEEN 1 AND 59)
11412   8565   90 02       		bcc	RD0
11413   8567               	RDERR:
11414   8567   A9 3A       		lda	#58		; (5/16/86 - MAKE IT 58, 59 LOST)
11415   8569               	RD0:
11416   8569   8D 03 85    		sta	MAXWORDS	; save max words
11417   856C   A9 00       		lda	#0		; start at 0 words
11418   856E   8D 04 85    		sta	WORDCNT		; save it
11419   8571   85 94       		sta	WRDLEN		; INIT # CHARS IN WORD COUNTER
11420   8573   A9 02       		lda	#2		
11421   8575   85 93       		sta	SOURCE		; INIT SOURCE TABLE PNTR
11422                      	;
11423                      	; now futz with destination table a little
11424                      	;
11425   8577   20 BE 8F    		jsr	NEXTFPC		; now we point to # words read
11426   857A   A5 8E       		lda	FPCBNK		; and save this pointer
  Wed May 24 1989 15:00                                                                                                  Page  172

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11427   857C   8D 06 85    		sta	SAVESPC		; for stashing at the end
11428   857F   A5 8D       		lda	FPCH
11429   8581   8D 07 85    		sta	SAVESPC+1
11430   8584   A5 8C       		lda	FPCL
11431   8586   8D 08 85    		sta	SAVESPC+2
11432                      	
11433   8589   A9 04       		lda	#4		; offset to end of first entry
11434   858B   20 DE 8F    		jsr	ADDFPC		; and point to end of first entry
11435   858E   20 73 90    		jsr	FP2SP		; now put RDTBL2 into stash pointer
11436                      	;
11437                      	; now get source table
11438                      	;	
11439   8591   AD 7B 6C    		lda	RDTBL1+HI	; get page
11440   8594   20 77 8F    		jsr	SETPC		; and tell me what mem page and bank
11441   8597   85 8D       		sta	FPCH		; set up fetch counter
11442   8599   84 8E       		sty	FPCBNK		; and bank
11443   859B   AD 7A 6C    		lda	RDTBL1+LO	; and lo stays the same
11444   859E   85 8C       		sta	FPCL		; and save it
11445   85A0   20 BE 8F    		jsr	NEXTFPC		; get # of chars in buffer
11446   85A3   20 56 92    		jsr	FETCHB		; and tell me about it
11447   85A6   85 92       		sta	LINLEN		; SAVE # CHARS IN LINE
11448   85A8   20 BE 8F    		jsr	NEXTFPC		; now point to first char in line
11449                      	;
11450                      	; MAIN LOOP STARTS HERE
11451                      	;
11452   85AB               	READL:
11453   85AB   AD 03 85    		lda	MAXWORDS	; how we doin'?
11454   85AE   CD 04 85    		cmp	WORDCNT		; see if we have maxxed out
11455   85B1   90 06       		bcc	RLEX		; all done, thank you
11456                      	
11457   85B3   A5 92       		lda	LINLEN
11458   85B5   05 94       		ora	WRDLEN		; OUT OF CHARS AND WORDS?
11459   85B7   D0 16       		bne	RL2		; NOT YET
11460   85B9               	RLEX:
11461   85B9   AD 06 85    		lda	SAVESPC		; now set SPC to point to # words
11462   85BC   85 91       		sta	SPCBNK		; read byte, as saved at the beginning
11463   85BE   AD 07 85    		lda	SAVESPC+1
11464   85C1   85 90       		sta	SPCH
11465   85C3   AD 08 85    		lda	SAVESPC+2
11466   85C6   85 8F       		sta	SPCL
11467   85C8   AD 04 85    		lda	WORDCNT		; get word count
11468   85CB   20 35 92    		jsr	STASHB		; and save it
11469   85CE   60          		rts
11470   85CF               	RL2:
11471   85CF   A5 94       		lda	WRDLEN		; GET WORD LENGTH
11472   85D1   C9 09       		cmp	#9		; 9 CHARS DONE? (EZIP)
11473   85D3   90 03       		bcc	RL3		; NO, KEEP GOING
11474   85D5   20 06 87    		jsr	FLUSHW		; ELSE FLUSH REMAINDER OF WORD
11475   85D8               	RL3:
11476   85D8   A5 94       		lda	WRDLEN		; GET WORD LENGTH AGAIN
11477   85DA   D0 24       		bne	READL2		; CONTINUE IF NOT FIRST CHAR
11478                      	;
11479                      	; START A NEW WORD
11480                      	;
11481   85DC   A2 08       		ldx	#8		; CLEAR Z-WORD INPUT BUFFER
11482   85DE   9D 90 6C    	RLL:	sta	IN,X		; [A] = 0
11483   85E1   CA          		dex
11484   85E2   10 FA       		bpl	RLL
11485                      	
11486   85E4   A5 93       		lda	SOURCE		; STORE THE START POS OF THE WORD
11487   85E6   8D 05 85    		sta	WORDSTART	; and save it for later
11488   85E9   20 56 92    		jsr	FETCHB		; GET A CHAR FROM SOURCE BUFFER
11489   85EC   20 37 87    		jsr	SIB		; IS IT A SELF-INSERTING BREAK?
11490   85EF   B0 2C       		bcs	DOSIB		; YES IF CARRY WAS SET
11491   85F1   20 2B 87    		jsr	NORM		; IS IT A "NORMAL" BREAK?
11492   85F4   90 0A       		bcc	READL2		; NO, CONTINUE
11493   85F6   E6 93       		inc	SOURCE		; ELSE FLUSH THE STRANDED BREAK
11494   85F8   20 BE 8F    		jsr	NEXTFPC		; and point to next char
11495   85FB   C6 92       		dec	LINLEN		; UPDATE # CHARS LEFT IN LINE
11496   85FD   4C AB 85    		jmp	READL		; AND LOOP
11497   8600               	READL2:
11498   8600   A5 92       		lda	LINLEN		; OUT OF CHARS YET?
11499   8602   F0 25       		beq	READL3		; LOOKS THAT WAY
11500   8604   20 56 92    		jsr	FETCHB		; Grab the char
11501   8607   20 26 87    		jsr	BREAK		; IS IT A BREAK?
  Wed May 24 1989 15:00                                                                                                  Page  173

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11502   860A   B0 1D       		bcs	READL3		; YES IF CARRY WAS SET
11503   860C   A6 94       		ldx	WRDLEN		; ELSE STORE THE CHAR
11504   860E   9D 90 6C    		sta	IN,X		; INTO THE INPUT BUFFER
11505   8611   C6 92       		dec	LINLEN		; ONE LESS CHAR IN LINE
11506   8613   E6 94       		inc	WRDLEN		; ONE MORE IN WORD
11507   8615   E6 93       		inc	SOURCE		; and update next source
11508   8617   20 BE 8F    		jsr	NEXTFPC		; POINT TO NEXT CHAR IN SOURCE
11509   861A   4C AB 85    		jmp	READL		; AND LOOP BACK
11510                      	;
11511                      	; handle self-inserting breaks
11512   861D               	DOSIB:
11513   861D   8D 90 6C    		sta	IN		; put the break into 1st word slot
11514   8620   C6 92       		dec	LINLEN		; one less char in line
11515   8622   E6 94       		inc	WRDLEN		; one more in word buffer
11516   8624   E6 93       		inc	SOURCE		; and update next source
11517   8626   20 BE 8F    		jsr	NEXTFPC		; point to next source char
11518   8629               	READL3:
11519   8629   A5 94       		lda	WRDLEN		; ANY CHARS IN WORD YET?
11520   862B   D0 03       		bne	READL31		; yup, so deal with word
11521   862D   4C AB 85    		jmp	READL		; then go get next word
11522   8630               	READL31:
11523   8630   20 12 94    		jsr	CONZST		; CONVERT ASCII IN [IN] TO Z-STRING
11524   8633   20 67 87    		jsr	FINDW		; AND LOOK IT UP IN VOCABULARY
11525                      	
11526   8636   AD 05 85    		lda	WORDSTART	; get where it starts
11527   8639   20 35 92    		jsr	STASHB		; and save it
11528   863C   20 4E 90    		jsr	PREVSPC		; step backwards to point to length
11529   863F   A5 94       		lda	WRDLEN		; and get length
11530   8641   20 35 92    		jsr	STASHB		; and save it away
11531   8644   20 4E 90    		jsr	PREVSPC		; and backwards to LSB of offset
11532   8647   A2 06       		ldx	#6		; offset to point to end of next entry
11533                      	
11534   8649   EE 04 85    		inc	WORDCNT		; increment # words read
11535                      	
11536   864C   AD 57 6C    		lda	PSVFLG		; IF SHOULD PRESERVE WHAT'S IN
11537   864F   F0 06       		beq	READL4
11538   8651   A5 77       		lda	VALUE+HI	; RDTBL2 AND NOT FOUND (VALUE = 0)
11539   8653   05 76       		ora	VALUE+LO
11540   8655   F0 0F       		beq	READL5		; JUST SKIP OVER
11541   8657               	READL4:
11542   8657   A5 76       		lda	VALUE+LO	; GET LSB OF VOCAB ENTRY ADDRESS
11543   8659   20 35 92    		jsr	STASHB		; and stash it away
11544   865C   20 4E 90    		jsr	PREVSPC		; point to MSB part
11545   865F   A5 77       		lda	VALUE+HI	; ALSO STORE MSB IN 2ND SLOT
11546   8661   20 35 92    		jsr	STASHB		; and send it out
11547   8664   A2 07       		ldx	#7		; offset to point to end of next entry
11548   8666               	READL5:
11549   8666   A9 00       		lda	#0
11550   8668   85 94       		sta	WRDLEN		; CLEAR # CHARS IN WORD
11551   866A   8A          		txa			; get offset
11552   866B   20 01 90    		jsr	ADDSPC		; and point to end of next entry
11553   866E   4C AB 85    		jmp	READL		; AND LOOP BACK
11554                      	
11555                      	; ---
11556                      	; LEX
11557                      	; ---
11558                      	; DO PARSE OF TBL1 INTO TBL2 (2ND HALF OF READ)
11559                      	
11560   8671               	ZLEX:
11561   8671   A5 64       		LDA	ARG1+HI		; MAKE THE TABLE ADDRESSES
11562   8673   8D 7B 6C    		STA	RDTBL1+HI	; AND PLACE IT HERE TO USE
11563   8676   A5 63       		LDA	ARG1+LO
11564   8678   8D 7A 6C    		STA	RDTBL1+LO	; LSBS NEED NOT CHANGE
11565                      	
11566   867B   A5 66       		LDA	ARG2+HI
11567   867D   8D 7D 6C    		STA	RDTBL2+HI
11568   8680   A5 65       		LDA	ARG2+LO
11569   8682   8D 7C 6C    		STA	RDTBL2+LO
11570                      	
11571   8685   C6 62       		DEC	NARGS
11572   8687   C6 62       		DEC	NARGS
11573   8689   F0 13       		BEQ	NORMLEX		; USE NORMAL VOCAB TBL
11574                      	
11575   868B   A9 01       		LDA	#1		; USE ARG3 VOCAB TBL
11576   868D   8D 58 6C    		STA	VOCFLG
  Wed May 24 1989 15:00                                                                                                  Page  174

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11577   8690   A9 00       		LDA	#0
11578   8692   C6 62       		DEC	NARGS
11579   8694   F0 02       		BEQ	NOSAVE		; ZERO UNFOUND WORDS
11580   8696   A9 01       		LDA	#1		; PRESERVE UNFOUND WORD SLOT FLAG
11581   8698   8D 57 6C    	NOSAVE:	STA	PSVFLG
11582   869B   4C A6 86    		JMP	DOLEX
11583                      	
11584   869E   A9 00       	NORMLEX: LDA	#0
11585   86A0   8D 58 6C    		STA	VOCFLG		; USE NORMAL VOCAB TBL
11586   86A3   8D 57 6C    		STA	PSVFLG		; AND WILL BE NO PRESERVING
11587                      	
11588   86A6   4C 4F 85    	DOLEX:	JMP	DOREST		; GO DO LEXICAL CONVERSION AND JUST RETURN
11589                      	
11590                      	
11591                      	; -----
11592                      	; ZWSTR
11593                      	; -----
11594                      	; CONVERT A WORD TO A ZWORD, PLACE IN ARG4 TBL
11595   86A9               	ZWSTR:
11596   86A9   A5 64       		lda	ARG1+HI		; Make ARG1 be the FPC
11597   86AB   20 77 8F    		jsr	SETPC		; so get absolute mem bank/page
11598   86AE   84 8E       		sty	FPCBNK		; save bank and
11599   86B0   85 8D       		sta	FPCH		; page
11600   86B2   A5 63       		lda	ARG1+LO
11601   86B4   85 8C       		sta	FPCL		; LSBS NEED NOT CHANGE
11602                      	;
11603                      	; (IGNORE WORD LENGTH CAUSE CHECK FOR BREAK CHAR (9 CHAR MAX))
11604                      	;
11605   86B6   A5 67       		lda	ARG3+LO		; ADD OFFSET INTO INBUF
11606   86B8   20 DE 8F    		jsr	ADDFPC		; add it to the FPC
11607                      	
11608   86BB   A5 6A       		lda	ARG4+HI		; now fix the SPC too
11609   86BD   20 77 8F    		jsr	SETPC		; get me bank and page
11610   86C0   84 91       		sty	SPCBNK		; save bank
11611   86C2   85 90       		sta	SPCH		; save page
11612   86C4   A5 69       		lda	ARG4+LO
11613   86C6   85 8F       		sta	SPCL		; LSB doesn't change
11614                      	;
11615                      	; START A NEW WORD
11616                      	;
11617   86C8   A9 09       		lda	#9
11618   86CA   85 92       		sta	LINLEN		; 1 WORD'S WORTH
11619   86CC   A9 00       		lda	#0
11620   86CE   85 94       		sta	WRDLEN
11621                      	
11622   86D0   A2 08       		ldx	#8		; CLEAR Z-WORD INPUT BUFFER
11623   86D2   9D 90 6C    	WSTR1:	sta	IN,X		; [A] = 0
11624   86D5   CA          		dex
11625   86D6   10 FA       		bpl	WSTR1
11626                      	;
11627                      	; THIS LOOP READS FROM INBUF TIL BREAK OR 9 CHARS READ
11628                      	;
11629   86D8               	WSTR2:
11630   86D8   20 56 92    		jsr	FETCHB		; grab the next char
11631   86DB   20 26 87    		jsr	BREAK		; IS IT A BREAK?
11632   86DE   B0 0E       		bcs	WSTR3		; YES IF CARRY WAS SET
11633   86E0   A6 94       		ldx	WRDLEN		; ELSE STORE THE CHAR
11634   86E2   9D 90 6C    		sta	IN,X		; INTO THE INPUT BUFFER
11635   86E5   E6 94       		inc	WRDLEN		; ONE MORE CHAR IN WORD
11636   86E7   C6 92       		dec	LINLEN		; ONE LESS IN LINE
11637   86E9   20 BE 8F    		jsr	NEXTFPC		; point to next char
11638   86EC   D0 EA       		bne	WSTR2		; AND LOOP BACK TIL DONE
11639   86EE               	WSTR3:
11640   86EE   A5 94       		lda	WRDLEN		; ANY CHARS IN WORD YET?
11641   86F0   F0 13       		beq	WOOPS		; APPARENTLY NOT, OOPS
11642   86F2   20 12 94    		jsr	CONZST		; CONVERT ASCII IN [IN] TO Z-STRING
11643                      	
11644   86F5   A2 00       		ldx	#0		; MOVE FROM [OUT] TO RDTBL2
11645   86F7   BD 99 6C    	WSTR4:	lda	OUT,X
11646   86FA   20 35 92    		jsr	STASHB		; and stash it into ZWORD table
11647   86FD   20 9E 8F    		jsr	NEXTSPC		; and point to next byte
11648   8700   E8          		inx
11649   8701   E0 06       		cpx	#6		; max 6 word table
11650   8703   D0 F2       		bne	WSTR4		; not done yet
11651   8705               	WOOPS:
  Wed May 24 1989 15:00                                                                                                  Page  175

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11652   8705   60          		rts
11653                      	
11654                      	; ----------
11655                      	; FLUSH WORD
11656                      	; ----------
11657                      	
11658   8706               	FLUSHW:
11659   8706   A5 92       		lda	LINLEN		; ANY CHARS LEFT IN LINE?
11660   8708   F0 14       		beq	FLEX		; NO, SCRAM
11661   870A   20 56 92    		jsr	FETCHB		; GRAB A CHAR
11662   870D   20 26 87    		jsr	BREAK		; IS IT A BREAK?
11663   8710   B0 0C       		bcs	FLEX		; EXIT IF SO
11664   8712   C6 92       		dec	LINLEN		; ELSE UPDATE CHAR COUNT
11665   8714   E6 94       		inc	WRDLEN		; AND WORD-CHAR COUNT
11666   8716   E6 93       		inc	SOURCE		; AND CHAR POINTER
11667   8718   20 BE 8F    		jsr	NEXTFPC		; and FPC pointer too
11668   871B   4C 06 87    		jmp	FLUSHW		; AND LOOP BACK (ALWAYS)
11669   871E               	FLEX:
11670   871E   60          		rts
11671                      	
11672                      	
11673                      	; ---------------------------------
11674                      	; IS CHAR IN [A] ANY TYPE OF BREAK?
11675                      	; ---------------------------------
11676                      	; ------------------
11677                      	; NORMAL BREAK CHARS
11678                      	; ------------------
11679                      	
11680   871F   21 3F 2C 2E 	BRKTBL:	DB	'!?,.'		; IN ORDER OF
11681   8723   0D          		DB	$0D		; ASCII	ENDING FREQUENCY
11682   8724   20          		DB	SPACE		; SPACE CHAR IS TESTED FIRST FOR SPEED
11683   8725   00          		DB	0		; ZERO ADDED FOR ZWSTR (X)
11684          0007        	NBRKS	EQU	$-BRKTBL	; # NORMAL BREAKS
11685                      	
11686   8726   20 37 87    	BREAK:	JSR	SIB		; CHECK FOR A SIB FIRST
11687   8729   B0 3A       		BCS	FBRK		; EXIT NOW IF MATCHED
11688                      	
11689                      		; ELSE FALL THROUGH ...
11690                      	
11691                      	
11692                      	; --------------------------------
11693                      	; IS CHAR IN [A] A "NORMAL" BREAK?
11694                      	; --------------------------------
11695                      	
11696   872B   A2 06       	NORM:	LDX	#NBRKS-1	; NUMBER OF "NORMAL" BREAKS
11697   872D   DD 1F 87    	NBL:	CMP	BRKTBL,X	; MATCHED?
11698   8730   F0 33       		BEQ	FBRK		; YES, EXIT
11699   8732   CA          		DEX
11700   8733   10 F8       		BPL	NBL		; NO, KEEP LOOKING
11701   8735   18          		CLC			; NO MATCH, CLEAR CARRY
11702   8736   60          		RTS			; AND RETURN
11703                      	
11704                      	
11705                      	; ---------------------
11706                      	; IS CHAR IN [A] A SIB?
11707                      	; ---------------------
11708                      	
11709   8737   85 AC       	SIB:	STA	IOCHAR		; SAVE TEST CHAR
11710   8739   A5 54       		lda	VOCAB+ABANK	; get bank
11711   873B   85 8B       		sta	MPCBNK		; and save it
11712   873D   A5 53       		lda	VOCAB+HI	; and hi part
11713   873F   85 8A       		sta	MPCPNT+HI	; and save it
11714   8741   AD 08 96    		lda	ZBEGIN+ZVOCAB+0 ; GET 1ST BYTE IN VOCAB TABLE
11715   8744   AC 09 96    		LDY	ZBEGIN+ZVOCAB+1
11716   8747   85 87       		STA	MPCM
11717   8749   84 86       		STY	MPCL
11718   874B   A9 00       		LDA	#0
11719   874D   85 88       		STA	MPCH		; now everything is set up
11720   874F   20 09 92    		JSR	GETBYT		; HAS # SIBS
11721   8752   85 7A       		STA	J		; USE AS AN INDEX
11722   8754   20 09 92    	SBL:	JSR	GETBYT		; GET NEXT SIB
11723   8757   C5 AC       		CMP	IOCHAR		; MATCHED?
11724   8759   F0 08       		BEQ	FBRK0		; YES, REPORT IT
11725   875B   C6 7A       		DEC	J
11726   875D   D0 F5       		BNE	SBL		; ELSE KEEP LOOPING
  Wed May 24 1989 15:00                                                                                                  Page  176

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11727   875F   A5 AC       		LDA	IOCHAR
11728   8761   18          		CLC			; NO MATCH, SO
11729   8762   60          		RTS			; EXIT WITH CARRY CLEAR
11730   8763   A5 AC       	FBRK0:	LDA	IOCHAR
11731   8765   38          	FBRK:	SEC			; EXIT WITH CARRY SET
11732   8766   60          		RTS			; IF MATCHED WITH A BREAK CHAR
11733                      	
11734                      	
11735                      	; -----------------
11736                      	; VOCABULARY SEARCH
11737                      	; -----------------
11738                      	; ENTRY: 6-BYTE TARGET Z-WORD IN [OUT]
11739                      	; EXIT: VIRTUAL ENTRY ADDRESS IN [VALUE] IF FOUND ;
11740                      	; OTHERWISE [VALUE] = 0
11741                      	
11742          0078        	VWLEN	EQU	I		; **********
11743          007B        	VWCUR	EQU	J+HI
11744                      	
11745   8767               	FINDW:
11746   8767   AD 58 6C    		lda	VOCFLG		; USE WHAT VOCAB TBL?
11747   876A   F0 07       		beq	FWL2		; NORMAL
11748   876C   A5 68       		lda	ARG3+HI		; IF ALTERNATE VOCTBL
11749   876E   A4 67       		ldy	ARG3+LO		; IT'S ADDR IS IN ARG3
11750   8770   4C 9A 87    		jmp	FWL3
11751   8773               	FWL2:
11752   8773   AD 8F 6C    		lda	DIDVTBL		; have we done default vocab table?
11753   8776   F0 17       		beq	FWLNEW		; nope, so do it the first time
11754   8778   A2 02       		ldx	#2		; restore pointers
11755   877A               	FWRSTL:
11756   877A   BD 86 6C    		lda	VOCMPC,X	; get it
11757   877D   95 86       		sta	MPC,X		; save it
11758   877F   BD 89 6C    		lda	VCESVE,X	; save VOCEND too
11759   8782   95 B3       		sta	VOCEND,X	; okay, we have
11760   8784   BD 8C 6C    		lda	VWLSVE,X	; and starting length
11761   8787   95 78       		sta	VWLEN,X		; we have
11762   8789   CA          		dex			; count
11763   878A   10 EE       		bpl	FWRSTL		; okay, next one
11764   878C   4C 70 88    		jmp	FWLOOP		; and go do it
11765   878F               	FWLNEW:
11766   878F   A9 FF       		lda	#$FF		; show we are doing default table
11767   8791   8D 8F 6C    		sta	DIDVTBL		; we shall
11768                      	
11769   8794   AD 08 96    		lda	ZBEGIN+ZVOCAB	; GET VIRTUAL ADDR OF VOCAB TBL
11770   8797   AC 09 96    		ldy	ZBEGIN+ZVOCAB+1
11771   879A               	FWL3:
11772   879A   85 87       		STA	MPCM
11773   879C   84 86       		STY	MPCL
11774   879E   A9 00       		LDA	#0
11775   87A0   85 88       		STA	MPCH
11776   87A2   20 80 90    		JSR	VLDMPC		; SET TO NEW PAGE
11777   87A5   20 09 92    		JSR	GETBYT		; GET # SIBS
11778   87A8   18          		CLC
11779   87A9   65 86       		ADC	MPCL		; GET ACTUAL BASE ADDR OF VOCAB ENTRIES
11780   87AB   85 86       		STA	MPCL
11781   87AD   90 02       		BCC	FWL0
11782   87AF   E6 87       		INC	MPCM
11783   87B1   20 80 90    	FWL0:	JSR	VLDMPC		; SET TO NEW PAGE
11784   87B4   20 09 92    		JSR	GETBYT		; GET # BYTES PER ENTRY (AND MOVE TO NEXT BYTE)
11785   87B7   85 95       		STA	ESIZE		; SAVE IT HERE
11786   87B9   85 78       		STA	VWLEN+0		; AND HERE
11787   87BB   A9 00       		LDA	#0		; CLEAR REST OF COUNTER
11788   87BD   85 79       		STA	VWLEN+1
11789   87BF   85 7A       		STA	VWLEN+2
11790                      	
11791   87C1   20 09 92    		JSR	GETBYT		; GET # OF ENTRIES IN TBL (MSB)
11792   87C4   8D 7F 6C    		STA	NENTS+HI	; AND STUFF IT IN [NENTS]
11793   87C7   20 09 92    		JSR	GETBYT		; DON'T FORGET THE LSB!
11794   87CA   8D 7E 6C    		STA	NENTS+LO
11795   87CD   AD 7F 6C    		LDA	NENTS+HI
11796   87D0   10 03       		BPL	SORTED
11797   87D2   4C 29 89    		JMP	UNSORTED	; VOCAB LIST IS UNSORTED, HANDLE DIFFERENTLY
11798   87D5               	SORTED:
11799   87D5   A9 00       		LDA	#0		; FIND SIZE OF VAOCAB TBL
11800   87D7   85 B3       		STA	VOCEND		; TO LOCATE THE END OF IT
11801   87D9   85 B4       		STA	VOCEND+1
  Wed May 24 1989 15:00                                                                                                  Page  177

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11802   87DB   85 B5       		STA	VOCEND+2
11803   87DD   A6 95       		LDX	ESIZE
11804   87DF               	FWL1:
11805   87DF   18          		CLC
11806   87E0   A5 B3       		LDA	VOCEND		; (# OF ENTRIES) * (ENTRY SIZE)
11807   87E2   6D 7E 6C    		ADC	NENTS+LO
11808   87E5   85 B3       		STA	VOCEND
11809   87E7   A5 B4       		LDA	VOCEND+1
11810   87E9   6D 7F 6C    		ADC	NENTS+HI
11811   87EC   85 B4       		STA	VOCEND+1
11812   87EE   90 02       		bcc	FWL11
11813   87F0   E6 B5       		inc	VOCEND+2
11814   87F2               	FWL11:
11815   87F2   CA          		DEX
11816   87F3   D0 EA       		BNE	FWL1
11817                      	
11818   87F5   18          		CLC
11819   87F6   A5 B3       		LDA	VOCEND		; AND ADD LENGTH TO START OF TBL
11820   87F8   65 86       		ADC	MPCL		; TO GET END OF TBL
11821   87FA   85 B3       		STA	VOCEND
11822   87FC   A5 B4       		LDA	VOCEND+1
11823   87FE   65 87       		ADC	MPCM
11824   8800   85 B4       		STA	VOCEND+1
11825   8802   A5 B5       		LDA	VOCEND+2
11826   8804   65 88       		ADC	MPCH
11827   8806   85 B5       		STA	VOCEND+2	; TO SAVE FOR TESTING IF PAST END
11828                      	
11829   8808   A5 B3       		LDA	VOCEND		; SUBTRACT [ESIZE] SO THAT
11830   880A   38          		SEC			; [VOCEND] POINTS TO REAL LAST ENTRY
11831   880B   E5 95       		SBC	ESIZE
11832   880D   85 B3       		STA	VOCEND
11833   880F   A5 B4       		LDA	VOCEND+1
11834   8811   E9 00       		SBC	#0
11835   8813   85 B4       		STA	VOCEND+1
11836                      	;
11837                      	; BEGIN THE SEARCH! [MPC] NOW POINTS TO 1ST ENTRY
11838                      	;
11839   8815   4E 7F 6C    		LSR	NENTS+HI	; 2 ALIGN # OF ENTRIES
11840   8818   6E 7E 6C    		ROR	NENTS+LO	; 2 point to middle of table
11841   881B   06 78       	FWCALC:	ASL	VWLEN+0		; CALCULATE INITIAL OFFSET FOR SEARCH
11842   881D   26 79       		ROL	VWLEN+1
11843   881F   26 7A       		ROL	VWLEN+2
11844   8821   4E 7F 6C    		LSR	NENTS+HI
11845   8824   6E 7E 6C    		ROR	NENTS+LO
11846   8827   D0 F2       		BNE	FWCALC
11847                      	
11848   8829   18          		CLC			; ADD 1ST OFFSET INTO START OF VOCABULARL
11849   882A   A5 86       		LDA	MPCL		; WHICH IS CURRENTLY IN MPC
11850   882C   65 78       		ADC	VWLEN+0
11851   882E   85 86       		STA	MPCL
11852   8830   A5 87       		LDA	MPCM
11853   8832   65 79       		ADC	VWLEN+1
11854   8834   85 87       		STA	MPCM
11855   8836   A5 88       		LDA	MPCH
11856   8838   65 7A       		ADC	VWLEN+2
11857   883A   85 88       		STA	MPCH
11858                      	
11859   883C   38          		SEC			; AVOID FENCE-POST BUG FOR
11860   883D   A5 86       		LDA	MPCL		; EXACT-POWER-OF-2 TBL (DUNCAN)
11861   883F   E5 95       		SBC	ESIZE
11862   8841   85 86       		STA	MPCL
11863   8843   B0 0F       		BCS	FWSAVE
11864   8845   A5 87       		LDA	MPCM
11865   8847   38          		SEC
11866   8848   E9 01       		SBC	#1
11867   884A   85 87       		STA	MPCM
11868   884C   B0 06       		BCS	FWSAVE
11869   884E   A5 88       		LDA	MPCH
11870   8850   E9 00       		SBC	#0
11871   8852   85 88       		STA	MPCH
11872   8854               	FWSAVE:
11873   8854   AD 8F 6C    		lda	DIDVTBL		; are we installing default table?
11874   8857   10 17       		bpl	FWLOOP		; already have?	
11875   8859   A2 02       		ldx	#2		; save MPC
11876   885B   8E 8F 6C    		stx	DIDVTBL		; show we have saved it
  Wed May 24 1989 15:00                                                                                                  Page  178

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11877   885E               	FWSVL:
11878   885E   B5 86       		lda	MPC,X		; get it
11879   8860   9D 86 6C    		sta	VOCMPC,X	; save it
11880   8863   B5 B3       		lda	VOCEND,X	; save VOCEND too
11881   8865   9D 89 6C    		sta	VCESVE,X	; okay, we have
11882   8868   B5 78       		lda	VWLEN,X		; and starting length
11883   886A   9D 8C 6C    		sta	VWLSVE,X	; we have
11884   886D   CA          		dex			; count
11885   886E   10 EE       		bpl	FWSVL		; okay, next one
11886   8870               	FWLOOP:
11887   8870   46 7A       		lsr	VWLEN+2		; SET FOR NEXT OFFSET,
11888   8872   66 79       		ror	VWLEN+1		; WHICH IS HALF THIS ONE
11889   8874   66 78       		ror	VWLEN+0
11890                      	
11891   8876   A5 86       		lda	MPCL		; HOLD START ADDR, MPC WILL BE A MESS
11892   8878   85 7B       		sta	VWCUR+0
11893   887A   A5 87       		lda	MPCM
11894   887C   85 7C       		sta	VWCUR+1
11895   887E   A5 88       		lda	MPCH
11896   8880   85 7D       		sta	VWCUR+2
11897                      	
11898   8882   20 80 90    		jsr	VLDMPC		; SET TO NEW PAGE
11899   8885   20 09 92    		jsr	GETBYT		; GET 1ST BYTE OF ENTRY
11900   8888   CD 99 6C    		cmp	OUT		; MATCH 1ST BYTE OF TARGET?
11901   888B   90 34       		bcc	WNEXT		; LESS
11902   888D   D0 66       		bne	FWPREV		; GREATER
11903   888F   20 09 92    		jsr	GETBYT	
11904   8892   CD 9A 6C    		cmp	OUT+1		; 2ND BYTE MATCHED?
11905   8895   90 2A       		bcc	WNEXT
11906   8897   D0 5C       		bne	FWPREV		; NOPE
11907   8899   20 09 92    		jsr	GETBYT
11908   889C   CD 9B 6C    		cmp	OUT+2		; 3RD BYTE?
11909   889F   90 20       		bcc	WNEXT
11910   88A1   D0 52       		bne	FWPREV		; SORRY ...
11911   88A3   20 09 92    		jsr	GETBYT
11912   88A6   CD 9C 6C    		cmp	OUT+3		; 4TH BYTE
11913   88A9   90 16       		bcc	WNEXT
11914   88AB   D0 48       		BNE	FWPREV
11915   88AD   20 09 92    		JSR	GETBYT
11916   88B0   CD 9D 6C    		CMP	OUT+4		; 5TH BYTE?
11917   88B3   90 0C       		BCC	WNEXT
11918   88B5   D0 3E       		BNE	FWPREV		; SORRY ...
11919   88B7   20 09 92    		JSR	GETBYT
11920   88BA   CD 9E 6C    		CMP	OUT+5		; LAST BYTE?
11921   88BD   F0 5A       		BEQ	FWSUCC		; FOUND IT!
11922   88BF   B0 34       		BCS	FWPREV		; ELSE BACK UP ...
11923   88C1               	WNEXT:
11924   88C1   A5 7B       		LDA	VWCUR+0		; TO MOVE UP, JUST ADD
11925   88C3   18          		CLC			; OFFSET FROM START OF THIS
11926   88C4   65 78       		ADC	VWLEN+0		; ENTRY
11927   88C6   85 86       		STA	MPCL
11928   88C8   A5 7C       		LDA	VWCUR+1
11929   88CA   65 79       		ADC	VWLEN+1
11930   88CC   B0 18       		BCS	WNXT2		; SAVES CODE (?)
11931                      	
11932   88CE   85 87       		STA	MPCM
11933   88D0   A9 00       		LDA	#0
11934   88D2   85 88       		STA	MPCH
11935   88D4               	WNXT0:
11936   88D4   A5 87       		LDA	MPCM		; GONE PAST END?
11937   88D6   C5 B4       		CMP	VOCEND+1	
11938   88D8   F0 04       		BEQ	WNXT1		; MAYBE
11939   88DA   B0 0A       		BCS	WNXT2		; YES
11940   88DC   90 2A       		BCC	FWMORE		; NO
11941   88DE               	WNXT1:
11942   88DE   A5 86       		LDA	MPCL
11943   88E0   C5 B3       		CMP	VOCEND
11944   88E2   90 24       		BCC	FWMORE		; NO
11945   88E4   F0 22       		BEQ	FWMORE		; NO, EQUAL
11946   88E6               	WNXT2:
11947   88E6   A5 B3       		LDA	VOCEND		; YES, SO POINT TO END OF TBL
11948   88E8   85 86       		STA	MPCL
11949   88EA   A5 B4       		LDA	VOCEND+1
11950   88EC   85 87       		STA	MPCM
11951   88EE   A5 B5       		LDA	VOCEND+2
  Wed May 24 1989 15:00                                                                                                  Page  179

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11952   88F0   85 88       		STA	MPCH
11953   88F2   4C 08 89    		JMP	FWMORE
11954   88F5               	FWPREV:
11955   88F5   A5 7B       		LDA	VWCUR+0		; TO MOVE DOWN, JUST SUBTRACT
11956   88F7   38          		SEC			; OFFSET FROM START OF THIS
11957   88F8   E5 78       		SBC	VWLEN+0		; ENTRY
11958   88FA   85 86       		STA	MPCL
11959   88FC   A5 7C       		LDA	VWCUR+1
11960   88FE   E5 79       		SBC	VWLEN+1
11961   8900   85 87       		STA	MPCM
11962   8902   A5 7D       		LDA	VWCUR+2
11963   8904   E5 7A       		SBC	VWLEN+2
11964   8906   85 88       		STA	MPCH
11965   8908               	FWMORE:
11966   8908   A5 7A       		LDA	VWLEN+2		; IF OFFSET >GE< 1 WORD, CONTINUE
11967   890A   D0 0A       		BNE	FWM1
11968   890C   A5 79       		LDA	VWLEN+1
11969   890E   D0 06       		BNE	FWM1
11970   8910   A5 78       		LDA	VWLEN+0
11971   8912   C5 95       		CMP	ESIZE
11972   8914   90 0C       		BCC	FWFAIL
11973   8916               	FWM1:
11974   8916   4C 70 88    		JMP	FWLOOP		; AND TRY AGAIN
11975                      	
11976   8919   A5 7B       	FWSUCC:	LDA	VWCUR+0		; ENTRY MATCHED!  RETRIEVE START OF WORD
11977   891B   85 76       		STA	VALUE+LO
11978   891D   A5 7C       		LDA	VWCUR+1
11979   891F   85 77       		STA	VALUE+HI	; MUST BE 64K LIMIT AS ONLY
11980   8921   60          		RTS			; WORD VALUE RETURNABLE
11981   8922               	FWFAIL:
11982   8922   A9 00       		LDA	#0		; NOT FOUND
11983   8924   85 76       		STA	VALUE+LO
11984   8926   85 77       		STA	VALUE+HI
11985   8928   60          		RTS			; THEN RETURN WITH [VALUE] = 0
11986                      	;
11987                      	; DO UNSORTED SEARCH ON VOCAB TBL IN MPC
11988                      	;
11989   8929               	UNSORTED:
11990   8929   A9 FF       		LDA	#$FF		; 2'S COMPLEMENT LENGTH
11991   892B   4D 7F 6C    		EOR	NENTS+HI	; TO GET REAL LENGTH
11992   892E   8D 7F 6C    		STA	NENTS+HI	; WAS NEGATIVE TO SIGNIFY
11993   8931   A9 FF       		LDA	#$FF		; UNSORTED VOCAB TBL
11994   8933   4D 7E 6C    		EOR	NENTS+LO
11995   8936   8D 7E 6C    		STA	NENTS+LO
11996   8939   EE 7E 6C    		INC	NENTS+LO	; 2'S CMPL
11997   893C   D0 03       		BNE	UNSRT0
11998   893E   EE 7F 6C    		INC	NENTS+HI
11999   8941               	UNSRT0:
12000   8941   A5 86       		LDA	MPCL		; HOLD START ADDR, MPC WILL BE A MESS
12001   8943   85 7B       		STA	VWCUR+0
12002   8945   A5 87       		LDA	MPCM
12003   8947   85 7C       		STA	VWCUR+1
12004   8949   A5 88       		LDA	MPCH
12005   894B   85 7D       		STA	VWCUR+2
12006                      	
12007   894D   20 09 92    		JSR	GETBYT		; GET 1ST BYTE OF ENTRY
12008   8950   CD 99 6C    		CMP	OUT		; MATCH 1ST BYTE OF TARGET?
12009   8953   D0 28       		BNE	FNEXT		; LESS
12010   8955   20 09 92    		JSR	GETBYT
12011   8958   CD 9A 6C    		CMP	OUT+1		; 2ND BYTE MATCHED?
12012   895B   D0 20       		BNE	FNEXT
12013   895D   20 09 92    		JSR	GETBYT
12014   8960   CD 9B 6C    		CMP	OUT+2		; 3RD BYTE?
12015   8963   D0 18       		BNE	FNEXT
12016   8965   20 09 92    		JSR	GETBYT
12017   8968   CD 9C 6C    		CMP	OUT+3		; 4TH BYTE
12018   896B   D0 10       		BNE	FNEXT
12019   896D   20 09 92    		JSR	GETBYT
12020   8970   CD 9D 6C    		CMP	OUT+4		; 5TH BYTE?
12021   8973   D0 08       		BNE	FNEXT
12022   8975   20 09 92    		JSR	GETBYT
12023   8978   CD 9E 6C    		CMP	OUT+5		; LAST BYTE?
12024   897B   F0 9C       		BEQ	FWSUCC		; FOUND IT!
12025                      	
12026   897D   A5 7B       	FNEXT:	LDA	VWCUR+LO	; TO MOVE UP, JUST ADD
  Wed May 24 1989 15:00                                                                                                  Page  180

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

12027   897F   18          		CLC			; OFFSET FROM START OF THIS
12028   8980   65 95       		ADC	ESIZE		; ENTRY
12029   8982   85 86       		STA	MPCL
12030   8984   90 0D       		BCC	FNEXT0
12031                      	
12032   8986   A5 7C       		LDA	VWCUR+HI	; PICK UP CARRY
12033   8988   69 00       		ADC	#0
12034   898A   85 87       		STA	MPCM
12035   898C   A9 00       		LDA	#0
12036   898E   85 88       		STA	MPCH
12037   8990   20 80 90    		JSR	VLDMPC		; CROSSED PAGE SO RE-VALIDATE
12038                      	
12039   8993   CE 7E 6C    	FNEXT0:	DEC	NENTS+LO	; CHECKED ALL ENTRIES?
12040   8996   D0 A9       		BNE	UNSRT0
12041   8998   AD 7F 6C    		LDA	NENTS+HI
12042   899B   F0 85       		BEQ	FWFAIL		; GO INDICATE NO FIND
12043   899D   CE 7F 6C    		DEC	NENTS+HI	; OR DO NEXT 256 ENTRIES
12044   89A0   4C 41 89    		JMP	UNSRT0
12045                      	
12046   89A3               		END
12047                      	
12048   89A3               		INCLUDE		ZSAVRES.ASM
12049                      	
12050   89A3               		STTL	"--- ZIP SAVE AND RESTORE ROUTINES ---"
12051                      		PAGE
  Wed May 24 1989 15:00                                                                                                  Page  181

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12052                      	; -----------------------------
12053                      	; SET UP SAVE & RESTORE SCREENS
12054                      	; -----------------------------
12055   89A3               	SAVRES:
12056   89A3   20 DF 54    		jsr	ZCRLF	; CLEAR THE LINE BUFFER
12057   89A6   A9 00       		lda	#0	
12058   89A8   85 AA       		sta	SCRIPT	; DISABLE SCRIPTING
12059   89AA   AD 54 C0    		lda	PAGE2SW+MAIN	; just do this for the heck of it
12060   89AD   AD 83 C0    	        lda     BNK2SET		; this stuff too
12061   89B0   AD 83 C0    	        lda     BNK2SET
12062                      	
12063   89B3   60          		rts
12064                      	
12065                      	; -----------------------------
12066                      	; SAVE & RESTORE STRINGS
12067                      	; -----------------------------
12068   89B4   59 45 53    	YES:	DB	"YES"
12069   89B7   0D          		DB	EOL	
12070          0004        	YESL	EQU	$-YES	
12071   89B8   4E 4F       	NO:	DB	"NO"	
12072   89BA   0D          		DB	EOL	
12073          0003        	NOL	EQU	$-NO	
12074                      	
12075   89BB   0D          	NAMEQ:	db	EOL
12076   89BC   49 6E 73 65 72 		db	"Insert save disk and enter "
        89C1   74 20 73 61 76 
        89C6   65 20 64 69 73 
        89CB   6B 20 61 6E 64 
        89D0   20 65 6E 74 65 
        89D5   72 20 
12077   89D7   66 75 6C 6C 20 		db	"full pathname of save file: "
        89DC   70 61 74 68 6E 
        89E1   61 6D 65 20 6F 
        89E6   66 20 73 61 76 
        89EB   65 20 66 69 6C 
        89F0   65 3A 20 
12078   89F3   0D          		db	EOL
12079   89F4   48 69 74 20 27 		db	"Hit '?' key to get a list of online volumes."
        89F9   3F 27 20 6B 65 
        89FE   79 20 74 6F 20 
        8A03   67 65 74 20 61 
        8A08   20 6C 69 73 74 
        8A0D   20 6F 66 20 6F 
        8A12   6E 6C 69 6E 65 
        8A17   20 76 6F 6C 75 
        8A1C   6D 65 73 2E 
12080   8A20   0D          		db	EOL
12081   8A21   43 75 72 72 65 		db	"Current pathname is:",
        8A26   6E 74 20 70 61 
        8A2B   74 68 6E 61 6D 
        8A30   65 20 69 73 3A 
        8A35   00 
12082   8A36   0D          		db	EOL
12083          007C        	NAMEQL	EQU	$-NAMEQ
12084                      	SNDATA:		 	; show start of name and length
12085   8A37   00          	SNAMEL:	db	0	; place to save length of name
12086   8A38               	SAVENAME: ds	64+15	; save plenty of room for max name
12087                      	
12088   8A87   0D 46 69 6C 65 	DELQ:	db	EOL,"File exists, delete it (Yes/No)? "
        8A8C   20 65 78 69 73 
        8A91   74 73 2C 20 64 
        8A96   65 6C 65 74 65 
        8A9B   20 69 74 20 28 
        8AA0   59 65 73 2F 4E 
        8AA5   6F 29 3F 20 
12089          0023        	DELQL	EQU	$-DELQ+1	; include this following EOL
12090   8AA9   0D 50 6C 65 61 	RETQ:	db	EOL,"Please hit [RETURN]",EOL
        8AAE   73 65 20 68 69 
        8AB3   74 20 5B 52 45 
        8AB8   54 55 52 4E 5D 
        8ABD   0D 
12091          0015        	RETQL	EQU	$-RETQ
12092   8ABE   0D 4E 61 6D 65 	PREFIX_ERR: db  EOL,"Name must have prefix, "
        8AC3   20 6D 75 73 74 
        8AC8   20 68 61 76 65 
  Wed May 24 1989 15:00                                                                                                  Page  182

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

        8ACD   20 70 72 65 66 
        8AD2   69 78 2C 20 
12093   8AD6   69 2E 65 2E 3A 	        db      "i.e.: /DISKNAME/FILENAME",EOL
        8ADB   20 2F 44 49 53 
        8AE0   4B 4E 41 4D 45 
        8AE5   2F 46 49 4C 45 
        8AEA   4E 41 4D 45 0D 
12094          0031        	PREFIX_ERRL EQU  $-PREFIX_ERR
12095                      	; -----------------------------
12096                      	; SAVE/RESTORE Parameter Blocks
12097                      	; -----------------------------
12098   8AEF               	CREATE_PB:
12099   8AEF   07          		db	7		; 7 parameters
12100   8AF0   378A        		dw	SNDATA		; pointer to name
12101   8AF2   C3          		db	$C3		; full access to file
12102   8AF3   06          		db	$06		; BIN file type
12103   8AF4   0000        		dw	0		; no aux data
12104   8AF6   01          		db	$01		; standard file
12105   8AF7   0000        		dw	0		; create date
12106   8AF9   0000        		dw	0
12107                      		     ; creation time
12108   8AFB               	SETEOF_PB:
12109   8AFB   02          		db 	2		; 1 parameter
12110   8AFC   00          	        db      0               ; refnum
12111   8AFD   00 00 00    	        db      0,0,0           ; set to zero spot to clear it out
12112   8B00               	OPEN_SV:
12113   8B00   03          		db	3		; 3 parameters
12114   8B01   378A        		dw	SNDATA		; name
12115   8B03   0011        		dw	GAME1FIO	; file buffer
12116   8B05   00          		db	0		; ref num
12117   8B06               	CLOSE_PB:
12118   8B06   01          		db	1		; only one parm
12119   8B07   00          		db	0		; the refnum
12120   8B08               	WRITE_SV:
12121   8B08   04          		db	4		; parm count
12122   8B09   00          		db	0		; refnum
12123   8B0A   0008        		dw	IOBUFF		; data is always here
12124   8B0C   0002        		dw	512             ; 1 page worth
12125   8B0E   0000        		dw	0		; how many actually went
12126                      	
12127                      	; get the save file name.  If user hits the ESC key, then abort the
12128                      	; save by return with the carry set.
12129                      	;
12130   8B10               	GET_SNAME:
12131   8B10   20 8F 8C    		jsr	CLOSE_GAME	; close the game files
12132   8B13   20 A9 4C    		jsr	SWAP2INFOW	; goto information window
12133   8B16               	GTSN0:
12134   8B16               		DLINE	NAMEQ		; ask about name
12135   8B16   A2 BB       		ldx	#<NAMEQ	; get part of NAMEQ
12136   8B18   A9 89       		lda	#>NAMEQ	; get other part of string
12137          [01]        		IFMA	2		; check to see if length passed in
12138                      		ldy			; then just fetch it
12139          [01]        		ELSE
12140   8B1A   A0 7C       		ldy	#NAMEQL	; get length of string
12141          [00]        		ENDIF
12142   8B1C   20 6B 4C    		jsr	DLINE		; print the string
12143   8B1F               		.MACEND
12144   8B1F   AD 37 8A    		lda	SNAMEL		; is there a name yet?
12145   8B22   F0 0A       		beq	GTSN00		; nope
12146   8B24               		DLINE	SAVENAME,SNAMEL	; show current name of file
12147   8B24   A2 38       		ldx	#<SAVENAME	; get part of SAVENAME
12148   8B26   A9 8A       		lda	#>SAVENAME	; get other part of string
12149          [01]        		IFMA	2		; check to see if length passed in
12150   8B28   AC 37 8A    		ldy	SNAMEL		; then just fetch it
12151          [01]        		ELSE
12152                      		ldy	#SAVENAMEL	; get length of string
12153          [00]        		ENDIF
12154   8B2B   20 6B 4C    		jsr	DLINE		; print the string
12155   8B2E               		.MACEND
12156   8B2E               	GTSN00:
12157   8B2E   A9 00       		lda	#0		; clear line count	
12158   8B30   8D 07 8B    		sta	CLOSE_PB+CL_REFNUM ; clear this too
12159   8B33   AE 37 8A    		ldx	SNAMEL		; get length
12160   8B36   86 A9       		stx	CHRCNT		; okay
12161   8B38   AC 37 8A    		ldy	SNAMEL		; point to copy
  Wed May 24 1989 15:00                                                                                                  Page  183

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12162   8B3B   88          		dey			; one less
12163   8B3C               	GCOPY:
12164   8B3C   BD 37 8A    		lda	SNAMEL,X	; get char
12165   8B3F   99 00 02    		sta	LBUFF,Y		; save it
12166   8B42   CA          		dex			; point to previous one
12167   8B43   88          		dey			; previous pointer
12168   8B44   10 F6       		bpl	GCOPY		; copy until length byte
12169   8B46               	GNAME:
12170   8B46   20 31 51    		jsr	GETKEY		; WAIT FOR A KEY
12171   8B49   C9 0D       		cmp	#EOL		; IF [RETURN],
12172   8B4B   F0 5F       		beq	GOTNAME		; got the name
12173   8B4D   C9 1B       		cmp	#ESCAPE		; hit escape key?
12174   8B4F   38          		sec			; just in case it does exit
12175   8B50   D0 03       		bne     GNM2
12176   8B52   4C F0 8B    	        jmp     GNX             ; all done then
12177   8B55               	GNM2:
12178   8B55   C9 08       		cmp	#BACKSPACE	; erasing things?
12179   8B57   D0 15       		bne	GNM1		; nope
12180                      	
12181   8B59   A6 A9       		ldx	CHRCNT		; make sure there are chars there
12182   8B5B   D0 06       		bne	GNMBP		; ayyup, do delete
12183   8B5D               	GNMBAD:
12184   8B5D   20 C3 4E    		jsr	BEEP		; no room for delete
12185   8B60   4C 46 8B    		jmp	GNAME		; okay
12186   8B63               	GNMBP:
12187   8B63   CA          		dex			; point down one
12188   8B64   86 A9       		stx	CHRCNT		; count one down
12189   8B66   BD 00 02    		lda	LBUFF,X		; get char to delete
12190   8B69   AA          		tax			; show in [X]
12191   8B6A   A9 08       		lda	#BACKSPACE	; and doing a backspace 
12192   8B6C   D0 35       		bne	GNMSHOW		; okay, delete char on screen
12193   8B6E               	GNM1:
12194   8B6E   C9 2F       		cmp	#'/'		; slash is the only good non-numeric char
12195   8B70   F0 2A       		beq	GNMGOOD		; fine, use it
12196   8B72   C9 2E       		cmp	#'.'		; well, maybe a . too
12197   8B74   F0 26       		beq	GNMGOOD 	; fine, here it is
12198   8B76   C9 3F       		cmp	#VOLCHAR	; does user want list of volumes?
12199   8B78   D0 0A       		bne	GNM1x		; nope
12200                      	
12201   8B7A   A9 00       		lda	#0		; clear out current name
12202   8B7C   85 A9       		sta	CHRCNT		; okay, we did
12203   8B7E   20 5D 4B    		jsr	LISTVOLS	; show them
12204   8B81   4C 16 8B    		jmp	GTSN0		; start over, kind of
12205   8B84               	GNM1x:
12206   8B84   C9 30       		cmp	#'0'		; is it a number
12207   8B86   90 D5       		bcc	GNMBAD		; nope
12208   8B88   C9 3A       		cmp	#'9'+1		; well?
12209   8B8A   90 10       		bcc	GNMGOOD		; yup
12210   8B8C   C9 7B       		cmp	#'z'+1		; make sure it is alpha numeric
12211   8B8E   B0 CD       		bcs	GNMBAD		; nope
12212   8B90   C9 41       		cmp	#'A'		; well?
12213   8B92   90 C9       		bcc	GNMBAD		; nope
12214   8B94   C9 61       		cmp	#'a'		; little char?
12215   8B96   B0 04       		bcs	GNMGOOD		; yup
12216   8B98   C9 5B       		cmp	#'Z'+1		; big char
12217   8B9A   B0 C1       		bcs	GNMBAD		; nope
12218   8B9C               	GNMGOOD:
12219   8B9C   A6 A9       		ldx	CHRCNT		; get name index
12220   8B9E   E6 A9       		inc	CHRCNT		; point to next char
12221   8BA0   9D 00 02    		sta	LBUFF,X		; save name char
12222   8BA3               	GNMSHOW:
12223   8BA3   20 7D 5D    		jsr	CHAR		; show character
12224   8BA6   20 EC 71    		jsr	DISP_LINE	; make sure it is there
12225   8BA9   4C 46 8B    		jmp	GNAME		; go get next char
12226                      	;
12227                      	; got the name, so copy it to the SAVENAME buffer
12228                      	;
12229   8BAC               	GOTNAME:
12230   8BAC   A5 A9       	        lda     CHRCNT          ; did we get any?
12231   8BAE   F0 07       	        beq     GTNMERR         ; nope
12232   8BB0   AD 00 02    	        lda     LBUFF           ; make sure first name is a directory
12233   8BB3   C9 2F       	        cmp     #'/'            ; is it?
12234   8BB5   F0 10       	        beq     GTNM1           ; yup, probly okay then
12235   8BB7               	GTNMERR:
12236   8BB7   A9 00       		lda	#0		; clear CHRCNT so name doesn't get
  Wed May 24 1989 15:00                                                                                                  Page  184

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12237   8BB9   85 A9       		sta	CHRCNT		; output again
12238   8BBB               	        DLINE   PREFIX_ERR      ; complain and die
12239   8BBB   A2 BE       		ldx	#<PREFIX_ERR	; get part of PREFIX_ERR
12240   8BBD   A9 8A       		lda	#>PREFIX_ERR	; get other part of string
12241          [01]        		IFMA	2		; check to see if length passed in
12242                      		ldy			; then just fetch it
12243          [01]        		ELSE
12244   8BBF   A0 31       		ldy	#PREFIX_ERRL	; get length of string
12245          [00]        		ENDIF
12246   8BC1   20 6B 4C    		jsr	DLINE		; print the string
12247   8BC4               		.MACEND
12248   8BC4   38          	        sec                     ; show bad name
12249   8BC5   B0 29       	        bcs     GNX             ; all done
12250   8BC7               	GTNM1:
12251   8BC7   A2 00       	        ldx     #0              ; now check to make sure there are 2
12252   8BC9   A0 FE       	        ldy     #$FE            ; use this as counter
12253   8BCB               	GTNMCHK:
12254   8BCB   BD 00 02    	        lda     LBUFF,X         ; get char
12255   8BCE   E8          	        inx                     ; next char
12256   8BCF   C9 2F       	        cmp     #'/'            ; prefix deliminator?
12257   8BD1   D0 03       	        bne     GTNMCHK1        ; nope
12258   8BD3   C8          	        iny                     ; count this one
12259   8BD4   F0 06       	        beq     GTNM2           ; we have 2 of them
12260   8BD6               	GTNMCHK1:
12261   8BD6   E4 A9       	        cpx     CHRCNT          ; at end?
12262   8BD8   F0 DD       	        beq     GTNMERR         ; yes, and no 2 '/'s
12263   8BDA   D0 EF       	        bne     GTNMCHK         ; go check next char
12264   8BDC               	GTNM2:
12265   8BDC   E4 A9       	        cpx     CHRCNT          ; make sure there are chars after prefix
12266   8BDE   F0 D7       	        beq     GTNMERR         ; nope, still an error
12267   8BE0   A6 A9       	        ldx	CHRCNT		; get how many characters
12268   8BE2   8E 37 8A    		stx	SNAMEL		; save in length byte
12269   8BE5   CA          		dex			; points one too far
12270   8BE6               	GNL:
12271   8BE6   BD 00 02    		lda	LBUFF,X		; get the char
12272   8BE9   9D 38 8A    		sta	SAVENAME,X	; save the char
12273   8BEC   CA          		dex			; point to previous one
12274   8BED   10 F7       		bpl	GNL		; and go get it
12275   8BEF   18          		clc			; show did just fine
12276   8BF0               	GNX:
12277   8BF0   08          		php			; save status
12278   8BF1   A9 00       		lda	#0		; and clear CHRCNT
12279   8BF3   85 A9       		sta	CHRCNT		; okay
12280   8BF5   A9 0D       		lda	#EOL		; print EOL
12281   8BF7   20 7D 5D    		jsr	CHAR		; okay
12282   8BFA   20 C9 4C    		jsr	SWAPBACK	; change back to old window
12283   8BFD   28          		plp			; get status back
12284   8BFE   60          		rts			; all done
12285                      	;
12286                      	; open up a save file, by first trying to create it.  If it already exists
12287                      	; then make sure the player wants to delete the file, then get rid of it.
12288                      	; Finally open the file.  Return with carry set if user aborts the save.
12289                      	; Store the ref number into the write parm block.
12290                      	;
12291   8BFF               	OPEN_SAVE:
12292   8BFF               		CREATE	CREATE_PB	; first try to create the file
12293   8BFF               		PRODOS	$C0, CREATE_PB
12294   8BFF   20 00 BF    		jsr	$BF00	; ProDOS handler
12295   8C02   C0          		DB	$C0	; ProDOS function code
12296   8C03   EF8A        		DW	CREATE_PB	; Function Parameter Block address
12297   8C05               		.MACEND
12298   8C05               		.MACEND
12299   8C05   90 16       		bcc	OPSV_OPEN	; created just fine, so open it
12300                      	;
12301                      	; can't create the file, check out why
12302                      	;
12303   8C07   C9 47       		cmp	#$47		; this means file already there	
12304   8C09   F0 03       		beq	OPSV1		; nope, not that
12305   8C0B   4C 8A 47    		jmp	DISK_ERR	; show badness
12306   8C0E               	OPSV1:
12307   8C0E               		DLINE	DELQ		; ask about deleting this file
12308   8C0E   A2 87       		ldx	#<DELQ	; get part of DELQ
12309   8C10   A9 8A       		lda	#>DELQ	; get other part of string
12310          [01]        		IFMA	2		; check to see if length passed in
12311                      		ldy			; then just fetch it
  Wed May 24 1989 15:00                                                                                                  Page  185

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12312          [01]        		ELSE
12313   8C12   A0 23       		ldy	#DELQL	; get length of string
12314          [00]        		ENDIF
12315   8C14   20 6B 4C    		jsr	DLINE		; print the string
12316   8C17               		.MACEND
12317   8C17   20 A4 8C    		jsr	GETYN		; get me the yes or no
12318   8C1A   90 01       		bcc	OPSV_OPEN	; so then delete it if yes
12319   8C1C   60          		rts			; nope, so just quit
12320   8C1D               	OPSV_OPEN:
12321   8C1D               		OPEN	OPEN_SV		; open the save file
12322   8C1D               		PRODOS	$C8, OPEN_SV
12323   8C1D   20 00 BF    		jsr	$BF00	; ProDOS handler
12324   8C20   C8          		DB	$C8	; ProDOS function code
12325   8C21   008B        		DW	OPEN_SV	; Function Parameter Block address
12326   8C23               		.MACEND
12327   8C23               		.MACEND
12328   8C23   90 03       		bcc	OPSV_OP1	; okey, things worked just fine
12329   8C25   4C 8A 47    		jmp	DISK_ERR		; complain about error
12330   8C28               	OPSV_OP1:
12331   8C28   AD 05 8B    		lda	OPEN_SV+OP_REFNUM	; get the ref number
12332   8C2B   8D 09 8B    		sta	WRITE_SV+WR_REFNUM	; save the ref number
12333   8C2E   8D 07 8B    		sta	CLOSE_PB+CL_REFNUM	; to close parm too
12334   8C31   8D FC 8A    	        sta     SETEOF_PB+SE_REFNUM     ; for cleansing file
12335   8C34               	        SET_EOF SETEOF_PB       ; clear out file
12336   8C34               		PRODOS	$D0, SETEOF_PB
12337   8C34   20 00 BF    		jsr	$BF00	; ProDOS handler
12338   8C37   D0          		DB	$D0	; ProDOS function code
12339   8C38   FB8A        		DW	SETEOF_PB	; Function Parameter Block address
12340   8C3A               		.MACEND
12341   8C3A               		.MACEND
12342   8C3A   90 03       	        bcc     OPSVEX          ; no problems
12343   8C3C   20 8A 47    	        jsr     DISK_ERR        ; complain
12344   8C3F               	OPSVEX:
12345   8C3F   60          		rts			; file has been opened, return
12346                      	;
12347                      	; OPEN_RES - open the save file
12348                      	;
12349   8C40               	OPEN_RES:
12350   8C40               		OPEN	OPEN_SV		; open it up
12351   8C40               		PRODOS	$C8, OPEN_SV
12352   8C40   20 00 BF    		jsr	$BF00	; ProDOS handler
12353   8C43   C8          		DB	$C8	; ProDOS function code
12354   8C44   008B        		DW	OPEN_SV	; Function Parameter Block address
12355   8C46               		.MACEND
12356   8C46               		.MACEND
12357   8C46   90 01       		bcc	OPR1		; okay, it worked
12358   8C48   60          		rts			; okay, it didn't
12359   8C49               	OPR1:
12360   8C49   AD 05 8B    		lda	OPEN_SV+OP_REFNUM ; get reference number
12361   8C4C   8D CF 45    		sta	READ_PB+RD_REFNUM ; save for read
12362   8C4F   8D 07 8B    		sta	CLOSE_PB+CL_REFNUM ; and for close
12363   8C52   60          		rts
12364                      	;
12365                      	; CLOSE_SAVE - close up the save file if it is open, and
12366                      	;       restore open game files
12367                      	;
12368   8C53               	CLOSE_SAVE:
12369   8C53   AD 07 8B    		lda	CLOSE_PB+CL_REFNUM ; check if it opened
12370   8C56   F0 06       		beq	CLSVX		; okay, nothing
12371   8C58               		CLOSE	CLOSE_PB	; close the save file
12372   8C58               		PRODOS	$CC, CLOSE_PB
12373   8C58   20 00 BF    		jsr	$BF00	; ProDOS handler
12374   8C5B   CC          		DB	$CC	; ProDOS function code
12375   8C5C   068B        		DW	CLOSE_PB	; Function Parameter Block address
12376   8C5E               		.MACEND
12377   8C5E               		.MACEND
12378   8C5E               	CLSVX:
12379                      	;	lda	#1              ; flag is true
12380                      	;	sta	SAVEDISK	; show we have a save disk in there
12381                      	;        jsr     SET_GAMEPRE     ; go get the last one used
12382                      	;	jsr	FETCH_FILE	; this does it
12383   8C5E   AE 77 46    		ldx	GAME1NML	; get length of current name
12384   8C61   BD 77 46    		lda	GAME1NM,X	; get the number of the file
12385   8C64   8D C5 49    		sta	SAVENUM 	; we need this to look for prefix
12386   8C67   8D 54 4A    	        sta     SAVEDISK        ; show taking out save disk, not game disk        
  Wed May 24 1989 15:00                                                                                                  Page  186

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12387   8C6A   20 E1 4A    		jsr	DO_GAME1        ; open up GAME1 file
12388   8C6D   AD D3 1D    		lda	D2SEG+HI	; set DSEGS to point to #2
12389   8C70   85 1F       		sta	DSEGS+HI
12390   8C72   AD D2 1D    		lda	D2SEG+LO
12391   8C75   85 1E       		sta	DSEGS+LO
12392   8C77   AE 89 46    		ldx	GAME2NML	; get length of current name
12393   8C7A   BD 89 46    		lda	GAME2NM,X	; get the number of the file
12394   8C7D   8D C5 49    		sta	SAVENUM 	; we need this to look for prefix
12395   8C80   20 1F 4A    		jsr	OPEN_GAME2	; open up GAME2 file
12396   8C83   A0 00       		ldy	#0		; open up GAME2 file, just for kicks
12397   8C85   8C 54 4A    		sty	SAVEDISK	; show we have a save disk in there
12398   8C88   8C 07 8B    		sty	CLOSE_PB+CL_REFNUM	; clear close
12399   8C8B   C8          	        iny                     ; set for true        
12400   8C8C   84 AA       		sty	SCRIPT		; allow scripting again
12401   8C8E   60          		rts			; DONE
12402                      	;
12403                      	; CLOSE_GAME - close the current game file(s)
12404                      	;	and set DSEGS to point to preload so it will reopen them
12405                      	;
12406   8C8F               	CLOSE_GAME:
12407   8C8F   A9 00       		lda	#0			; show no files are open
12408   8C91   8D 07 8B    		sta	CLOSE_PB+CL_REFNUM	; 0 closes all files
12409   8C94   8D 87 46    		sta	GAME1REF		; zero out two game files too
12410   8C97   8D 99 46    		sta	GAME2REF		; and here is number 2
12411   8C9A   8D CE 73    	        sta     PF_FID                  ; clear this too
12412   8C9D               		CLOSE	CLOSE_PB		; now all are closed
12413   8C9D               		PRODOS	$CC, CLOSE_PB
12414   8C9D   20 00 BF    		jsr	$BF00	; ProDOS handler
12415   8CA0   CC          		DB	$CC	; ProDOS function code
12416   8CA1   068B        		DW	CLOSE_PB	; Function Parameter Block address
12417   8CA3               		.MACEND
12418   8CA3               		.MACEND
12419   8CA3   60          		rts
12420                      	;
12421                      	; Get answer to Yes/No question.  Return with C==0 for yes, and C==1
12422                      	; for a no.  RETURN == Yes, ESCAPE == NO
12423                      	;
12424   8CA4               	GETYN:
12425   8CA4   20 31 51    		jsr	GETKEY		; get the key strok
12426   8CA7   C9 79       		cmp	#'y'		; IF REPLY IS "Y"
12427   8CA9   F0 25       		beq	ALLSET		; ACCEPT RESPONSES
12428   8CAB   C9 59       		cmp	#'Y'		; get both y's
12429   8CAD   F0 21       		beq	ALLSET	
12430   8CAF   C9 0D       		cmp	#EOL		; EOL IS ALSO ACCEPTABLE
12431   8CB1   F0 1D       		beq	ALLSET	
12432   8CB3   C9 6E       		cmp	#'n'		; IF REPLY IS "N"
12433   8CB5   F0 0E       		beq	NOTSAT		; return with carry set
12434   8CB7   C9 4E       		cmp	#'N'		; check both n's
12435   8CB9   F0 0A       		beq	NOTSAT	
12436   8CBB   C9 1B       		cmp	#ESCAPE		; check for ESC key too
12437   8CBD   F0 06       		beq	NOTSAT		; which means no
12438   8CBF   20 C3 4E    		jsr	BEEP		; ELSE BEEP
12439   8CC2   4C A4 8C    		jmp	GETYN		; INSIST ON Y OR N
12440   8CC5               	NOTSAT:
12441   8CC5               		DLINE	NO		; PRINT "NO"/EOL
12442   8CC5   A2 B8       		ldx	#<NO	; get part of NO
12443   8CC7   A9 89       		lda	#>NO	; get other part of string
12444          [01]        		IFMA	2		; check to see if length passed in
12445                      		ldy			; then just fetch it
12446          [01]        		ELSE
12447   8CC9   A0 03       		ldy	#NOL	; get length of string
12448          [00]        		ENDIF
12449   8CCB   20 6B 4C    		jsr	DLINE		; print the string
12450   8CCE               		.MACEND
12451   8CCE   38          		sec			; set the carry
12452   8CCF   60          		rts			; and show it
12453   8CD0               	ALLSET:
12454   8CD0               		DLINE	YES  		; Print "YES"/EOL
12455   8CD0   A2 B4       		ldx	#<YES	; get part of YES
12456   8CD2   A9 89       		lda	#>YES	; get other part of string
12457          [01]        		IFMA	2		; check to see if length passed in
12458                      		ldy			; then just fetch it
12459          [01]        		ELSE
12460   8CD4   A0 04       		ldy	#YESL	; get length of string
12461          [00]        		ENDIF
  Wed May 24 1989 15:00                                                                                                  Page  187

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12462   8CD6   20 6B 4C    		jsr	DLINE		; print the string
12463   8CD9               		.MACEND
12464   8CD9   18          		clc			; clear the carry
12465   8CDA   60          		rts
12466   8CDB               	GETRET:
12467   8CDB               		DLINE	RETQ		; ask for return
12468   8CDB   A2 A9       		ldx	#<RETQ	; get part of RETQ
12469   8CDD   A9 8A       		lda	#>RETQ	; get other part of string
12470          [01]        		IFMA	2		; check to see if length passed in
12471                      		ldy			; then just fetch it
12472          [01]        		ELSE
12473   8CDF   A0 15       		ldy	#RETQL	; get length of string
12474          [00]        		ENDIF
12475   8CE1   20 6B 4C    		jsr	DLINE		; print the string
12476   8CE4               		.MACEND
12477   8CE4               	GETRETL:
12478   8CE4   20 31 51    		jsr	GETKEY		; get a key
12479   8CE7   C9 0D       		cmp	#EOL		; return key?
12480   8CE9   D0 F9       		bne	GETRETL		; nope
12481   8CEB   20 7D 5D    		jsr	CHAR		; show the <CR>
12482   8CEE   60          		rts
12483   8CEF               			
12484                      	; ---------
12485                      	; SAVE GAME
12486                      	; ---------
12487   8CEF               	ZSAVE:
12488   8CEF   A9 4E       		lda	#'N'
12489   8CF1   A6 62       		ldx	NARGS
12490   8CF3   F0 02       		beq	OLDSAV		; NORMAL, COMPLETE SAVE
12491   8CF5   A9 50       		lda	#'P'
12492   8CF7               	OLDSAV:
12493   8CF7   8D 62 5B    		sta	TYPE
12494   8CFA   20 A3 89    		jsr	SAVRES		; set up screen
12495   8CFD   20 10 8B    		jsr	GET_SNAME	; get the name of the save file
12496   8D00   B0 7B       		bcs	ZSEXIT		; don't wanna after all
12497   8D02   20 FF 8B    		jsr	OPEN_SAVE	; open the file
12498   8D05   B0 76       		bcs	ZSEXIT		; don't really care to
12499                      	;
12500                      	; SAVE GAME PARAMETERS IN [BUFSAV]
12501                      	;		
12502   8D07   AD 02 96    		lda	ZBEGIN+ZID	; MOVE GAME ID
12503   8D0A   8D 20 1E    		sta	BUFSAV+0	; INTO 1ST 2 BYTES
12504   8D0D   AD 03 96    		lda	ZBEGIN+ZID+1	; OF THE A
12505   8D10   8D 21 1E    		sta	BUFSAV+1	
12506   8D13   A5 AF       		lda	ZSP+LO		; MOVE [ZSP]
12507   8D15   8D 22 1E    		sta	BUFSAV+2	
12508   8D18   A5 B0       		lda	ZSP+HI	
12509   8D1A   8D 23 1E    		sta	BUFSAV+3	
12510   8D1D   AD 75 6C    		lda	OLDZSP+LO	
12511   8D20   8D 24 1E    		sta	BUFSAV+4	
12512   8D23   AD 76 6C    		lda	OLDZSP+HI	; MOVE [OLDZSP]
12513   8D26   8D 25 1E    		sta	BUFSAV+5	
12514   8D29   A2 02       		ldx	#2		; MOVE CONTENTS OF [ZPC]
12515   8D2B   B5 80       	ZSL1:	lda	ZPC,X		; TO BYTES 7-9
12516   8D2D   9D 26 1E    		sta	BUFSAV+6,X	; OF [BUFSAV]
12517   8D30   CA          		dex		
12518   8D31   10 F8       		bpl	ZSL1	
12519   8D33   AD 62 5B    		lda	TYPE
12520   8D36   8D 29 1E    		sta	BUFSAV+9	; NORMAL OR PARTIAL
12521   8D39   C9 50       		cmp	#'P'
12522   8D3B   D0 2A       		bne	ZSNONM		; NORMAL SAVE SO NO name TO SAVE
12523                      	
12524   8D3D   A5 67       		lda	ARG3+LO		; set up FPC to get save name
12525   8D3F   85 8C       		sta	FPCL		; lo part is okay
12526   8D41   A5 68       		lda	ARG3+HI		; get page
12527   8D43   20 77 8F    		jsr	SETPC		; get memory addr
12528   8D46   85 8D       		sta	FPCH		; page number
12529   8D48   84 8E       		sty	FPCBNK		; and bank
12530   8D4A   20 56 92    		jsr	FETCHB		; get count
12531   8D4D   85 78       		sta	I		; and save it
12532   8D4F   20 BE 8F    		jsr	NEXTFPC		; point to next byte
12533   8D52   A9 00       		lda	#0		; set up data offset
12534   8D54   85 7A       		sta	J		; did it
12535   8D56               	ZSL3:
12536   8D56   20 56 92    		jsr	FETCHB		; get data byte
  Wed May 24 1989 15:00                                                                                                  Page  188

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12537   8D59   A4 7A       		ldy	J		; get offset
12538   8D5B   99 2A 1E    		sta	BUFSAV+10,Y	; save into buffer
12539   8D5E   20 BE 8F    		jsr	NEXTFPC		; point to next byte
12540   8D61   E6 7A       		inc	J		; next byte
12541   8D63   C6 78       		dec	I		; count it
12542   8D65   D0 EF       		bne	ZSL3		; loop again
12543   8D67               	ZSNONM:
12544                      	;
12545                      	; WRITE [LOCALS]/[BUFSAV] PAGE TO DISK
12546                      	;
12547   8D67   A9 00       		lda	#MAIN		; in the main bank
12548   8D69   85 B8       		sta	DSKBNK		; thank you
12549   8D6B   A9 1E       		lda	#>LOCALS	; start at locals
12550   8D6D   85 B7       		sta	DBUFF+HI	; POINT TO THE PAGE
12551   8D6F   20 F6 47    		jsr	PUTDSK		; AND WRITE IT OUT
12552   8D72   90 0F       		bcc	ZSOK		; IF SUCCEEDED, WRITE STACK
12553   8D74               	ZSBAD:
12554   8D74   20 8A 47    		jsr	DISK_ERR	; print error message
12555   8D77               	        SET_EOF SETEOF_PB       ; clear out file, maybe
12556   8D77               		PRODOS	$D0, SETEOF_PB
12557   8D77   20 00 BF    		jsr	$BF00	; ProDOS handler
12558   8D7A   D0          		DB	$D0	; ProDOS function code
12559   8D7B   FB8A        		DW	SETEOF_PB	; Function Parameter Block address
12560   8D7D               		.MACEND
12561   8D7D               		.MACEND
12562   8D7D               	ZSEXIT:
12563   8D7D   20 53 8C    		jsr	CLOSE_SAVE	  ; else get game file back
12564   8D80   4C DA 43    		jmp	RET0		; AND FAIL
12565                      	;
12566                      	; IF A PARTIAL SAVE WRITE FROM ARG1 FOR ARG2 BYTES TO DISK
12567                      	; (ROUNDED TO PGS) SKIPPING ZSTACK WRITE
12568                      	;
12569   8D83               	ZSOK:
12570   8D83   AD 62 5B    		lda	TYPE
12571   8D86   C9 50       		cmp	#'P'
12572   8D88   D0 1F       		bne	ZSALL
12573   8D8A   A5 64       		lda	ARG1+HI		; find where to start & how far to go
12574   8D8C   20 77 8F    		jsr	SETPC		; get page in memory
12575   8D8F   48          	        pha                     ; save for minute
12576   8D90   29 01       	        and     #$01            ; check for odd page
12577   8D92   F0 02       	        beq     ZSP1            ; nope, don't make one more page
12578   8D94   E6 66       	        inc     ARG2+HI         ; go get one more page
12579   8D96               	ZSP1:
12580   8D96   68          	        pla                     ; get it back
12581   8D97   29 FE       	        and     #$FE            ; must be on block boundary
12582   8D99   85 B7       		sta	DBUFF+HI	; this is page
12583   8D9B   84 B8       		sty	DSKBNK		; which bank
12584   8D9D   A6 66       		ldx	ARG2+HI		; get MSB of count
12585   8D9F   A5 63       		lda	ARG1+LO		; get lo offset
12586   8DA1   18          		clc			; add
12587   8DA2   65 65       		adc	ARG2+LO		; lo count
12588   8DA4   90 01       		bcc	ZSPINC		; no extra page
12589   8DA6   E8          		inx			; wrapped extra page
12590   8DA7               	ZSPINC:
12591   8DA7   D0 15       	        bne     SAVE2DISK       ; go copy it now
12592                      	;
12593                      	; WRITE CONTENTS OF Z-STACK TO DISK
12594                      	;
12595   8DA9               	ZSALL:
12596   8DA9   A9 0D       		lda	#>ZSTKBL	; point to 1st page
12597   8DAB   85 B7       		sta	DBUFF+HI        
12598   8DAD   20 F6 47    		jsr	PUTDSK		; write them, first one
12599   8DB0   B0 C2       		bcs	ZSBAD
12600   8DB2   20 F6 47    		jsr	PUTDSK		; write them, second one
12601   8DB5   B0 BD       		bcs	ZSBAD
12602                      	;
12603                      	; WRITE ENTIRE GAME PRELOAD TO DISK
12604                      	;
12605   8DB7   A9 96       		lda	#>ZBEGIN	; POINT TO 1ST PAGE
12606   8DB9   85 B7       		sta	DBUFF+HI	; OF PRELOAD
12607   8DBB   AE 0E 96    		ldx	ZBEGIN+ZPURBT	; GET # IMPURE PAGES
12608   8DBE               	SAVE2DISK:
12609   8DBE   E8          		inx			; use for counting
12610   8DBF   86 78       		stx	I+LO
12611   8DC1   46 78       	        lsr     I+LO            ; /2 for 512byte pages
  Wed May 24 1989 15:00                                                                                                  Page  189

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12612   8DC3   90 02       	        bcc     ZSL2            ; no wrapping
12613   8DC5   E6 78       	        inc     I+LO            ; wrapped once
12614   8DC7               	ZSL2:
12615   8DC7   20 F6 47    		jsr	PUTDSK          ; this does the write
12616   8DCA   B0 A8       		bcs	ZSBAD
12617   8DCC   C6 78       		dec	I+LO            ; count one page
12618   8DCE   D0 F7       		bne	ZSL2            ; not done yet
12619                      	
12620   8DD0   20 53 8C    		jsr	CLOSE_SAVE	; prompt for game file
12621                      	
12622          [01]        		IF	CHECKSUM == 1
12623                      		lda	CKS_COUNT
12624                      		jsr	HEXNUM
12625                      		lda	CKSB
12626                      		jsr	HEXNUM
12627                      		lda	#EOL
12628                      		jsr	CHAR
12629          [00]        		ENDIF
12630                      	
12631   8DD3   A9 01       		lda	#1		; set to mark
12632   8DD5   A2 00       		ldx	#0
12633   8DD7   4C DD 43    		jmp	PUTBYT		; SUCCESS
12634                      	
12635                      	; ------------
12636                      	; RESTORE GAME
12637                      	; ------------
12638                      	
12639   8DDA               	ZREST:
12640   8DDA   A9 4E       		lda	#'N'
12641   8DDC   A6 62       		ldx	NARGS
12642   8DDE   F0 02       		beq	OLDRES		; NORMAL, COMPLETE RESTORE
12643   8DE0   A9 50       		lda	#'P'		; partial restore
12644   8DE2               	OLDRES:
12645   8DE2   8D 62 5B    		sta	TYPE		; save which kind of restore
12646                      	;	
12647                      	; SAVE LOCALS IN CASE OF ERROR
12648                      	;
12649   8DE5   A2 1F       		ldx	#31
12650   8DE7   BD 00 1E    	LOCSAV:	lda	LOCALS,X	; COPY ALL LOCALS
12651   8DEA   9D E0 1D    		sta	LOCAL_SV,X	; to a save spot
12652   8DED   CA          		dex
12653   8DEE   10 F7       		bpl	LOCSAV
12654                      	
12655   8DF0   20 10 8B    		jsr	GET_SNAME	; get the name of the file
12656   8DF3   B0 3C       		bcs	ZRQUIT		; okay, don't do it
12657   8DF5   20 40 8C    		jsr	OPEN_RES	; open the restore file
12658   8DF8   B0 34       		bcs	ZRBAD		; can't do it
12659                      	
12660   8DFA   AD 62 5B    		lda	TYPE		; PARTIAL SAVE DIFFERS STARTING HERE
12661   8DFD   C9 50       		cmp	#'P'
12662   8DFF   D0 03       		bne	ZRNRML
12663   8E01   4C C2 8E    		jmp	ZPARTR		; just a partial restore
12664   8E04               	ZRNRML:
12665   8E04   A9 00       		lda	#MAIN
12666   8E06   85 B8       		sta	DSKBNK		; SET TO WRITE TO MAIN BANK
12667   8E08   A9 1E       		lda	#>LOCALS
12668   8E0A   85 B7       		sta	DBUFF+HI
12669   8E0C   A9 02       		lda	#2              ; must read in two pages
12670   8E0E   85 7E       		sta	L+LO
12671   8E10   20 11 48    		jsr	GETRES		; RETRIEVE 1ST BLOCK OF PRELOAD
12672   8E13   B0 19       		bcs	ZRBAD           ; didn't work!
12673   8E15   AD D5 45    	        lda     READ_PB+RD_LENGTH+HI ; see how much was read in
12674   8E18   C9 02       	        cmp     #2              ; were 2 blocks read in?
12675   8E1A   D0 15       	        bne     ZRQUIT          ; wrong kind of file for complete save
12676                      	
12677   8E1C   AD 20 1E    		lda	BUFSAV+0	; DOES 1ST BYTE OF SAVED GAME ID
12678   8E1F   CD 02 96    		cmp	ZBEGIN+ZID	; MATCH THE CURRENT ID?
12679   8E22   D0 0D       		bne	ZRQUIT		; WRONG DISK IF NOT
12680                      	
12681   8E24   AD 21 1E    		lda	BUFSAV+1	; WHAT ABOUT THE 2ND BYTE?
12682   8E27   CD 03 96    		cmp	ZBEGIN+ZID+1
12683   8E2A   F0 16       		beq	ZROK		; CONTINUE IF BOTH BYTES MATCH
12684   8E2C   D0 03       	 	bne	ZRQUIT		; skip disk error message
12685                      	;
12686                      	; HANDLE RESTORE ERROR
  Wed May 24 1989 15:00                                                                                                  Page  190

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12687                      	;
12688   8E2E               	ZRBAD:
12689   8E2E   20 8A 47    		jsr	DISK_ERR	; print error message
12690   8E31               	ZRQUIT:
12691   8E31   A2 1F       		ldx	#31		; RESTORE ALL SAVED LOCALS
12692   8E33   BD E0 1D    	ZRL2:	lda	LOCAL_SV,X
12693   8E36   9D 00 1E    		sta	LOCALS,X
12694   8E39   CA          		dex
12695   8E3A   10 F7       		bpl	ZRL2
12696   8E3C               	BADRES:
12697   8E3C   20 53 8C    		jsr	CLOSE_SAVE	  ; PROMPT FOR GAME DISK
12698   8E3F   4C DA 43    		jmp	RET0		; PREDICATE FAILS
12699                      	;
12700                      	; CONTINUE RESTORE
12701                      	;
12702   8E42               	ZROK:
12703   8E42   AD 10 96    		lda	ZBEGIN+ZFLAGS	; save both flag bytes
12704   8E45   85 7A       		sta	J+LO
12705   8E47   AD 11 96    		lda	ZBEGIN+ZFLAGS+1
12706   8E4A   85 7B       		sta	J+HI
12707                      	
12708   8E4C   A9 0D       		lda	#>ZSTKBL	; retrieve old contents of
12709   8E4E   85 B7       		sta	DBUFF+HI	; z-stack
12710   8E50   A9 04       		lda	#4		; do 4 pages
12711   8E52   85 7E       		sta	L+LO		; tell GETRES how many pages
12712   8E54   20 11 48    		jsr	GETRES		; get 4 pages of z-stack
12713   8E57   90 03       		bcc	ZROKL1
12714   8E59   4C 74 47    		jmp	DISK_FATAL	; if here, mix of good & bad so die
12715   8E5C               	ZROKL1:
12716   8E5C   A9 96       		lda	#>ZBEGIN	; get where we are
12717   8E5E   85 B7       		sta	DBUFF+HI
12718   8E60   AD 0E 96    		lda	ZBEGIN+ZPURBT	; get # pages to load
12719   8E63   85 78       		sta	I+LO
12720   8E65   E6 78       	        inc     I+LO            ; go get last page if possible
12721   8E67               	LREST0:
12722   8E67   A5 78       		lda	I+LO		; how many pages left
12723   8E69   F0 20       	        beq     LRESTj          ; finis
12724   8E6B   38          		sec			; doing subtract
12725   8E6C   E9 04       		sbc	#4		; doing it 4 blocks at a time
12726   8E6E   90 0E       		bcc	LREST1		; <4 blocks left so deal with it special
12727   8E70   85 78       		sta	I+LO		; save remenants
12728   8E72               	LREST:
12729   8E72   A9 04       		lda	#4		; assume at least 4 pages
12730   8E74   85 7E       		sta	L+LO		; this tells GETRES how many to read in
12731   8E76   20 11 48    		jsr	GETRES		; fetch the remainder
12732   8E79   90 EC       		bcc	LREST0
12733   8E7B   4C 74 47    		jmp	DISK_FATAL
12734   8E7E               	LREST1:
12735   8E7E   A5 78       		lda	I+LO		; get how many left
12736   8E80   85 7E       		sta	L+LO		; and show it to GETRES
12737   8E82   29 01       	        and     #$1             ; is it odd?
12738   8E84   F0 02       	        beq     LREST2          ; nope
12739   8E86   E6 7E       	        inc     L+LO            ; read one more
12740   8E88               	LREST2:
12741   8E88   20 11 48    		jsr	GETRES		; and finish it up
12742                      	;
12743                      	; RESTORE THE STATE OF THE SAVED GAME
12744                      	;
12745   8E8B               	LRESTj:
12746   8E8B   A5 7A       		lda	J+LO		; RESTORE THE STATE
12747   8E8D   8D 10 96    		sta	ZBEGIN+ZFLAGS	; OF THE FLAG WORD
12748   8E90   A5 7B       		lda	J+HI
12749   8E92   8D 11 96    		sta	ZBEGIN+ZFLAGS+1
12750                      	
12751   8E95   AD 22 1E    		lda	BUFSAV+2	; RESTORE THE [ZSP]
12752   8E98   85 AF       		sta	ZSP+LO
12753   8E9A   AD 23 1E    		lda	BUFSAV+3
12754   8E9D   85 B0       		sta	ZSP+HI
12755   8E9F   AD 24 1E    		lda	BUFSAV+4
12756   8EA2   8D 75 6C    		sta	OLDZSP+LO
12757   8EA5   AD 25 1E    		lda	BUFSAV+5	; AND THE [OLDZSP]
12758   8EA8   8D 76 6C    		sta	OLDZSP+HI
12759                      	
12760   8EAB   A2 02       		ldx	#2		; RESTORE THE [ZPC]
12761   8EAD   BD 26 1E    	ZRL4:	lda	BUFSAV+6,X
  Wed May 24 1989 15:00                                                                                                  Page  191

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12762   8EB0   95 80       		sta	ZPC,X
12763   8EB2   CA          		dex
12764   8EB3   10 F8       		bpl	ZRL4
12765                      	
12766   8EB5   20 53 8C    	ZROUT:	jsr	CLOSE_SAVE	  ; PROMPT FOR GAME DISK
12767   8EB8   20 AA 90    		jsr	VLDZPC		; MAKE VALID (MUST DO AFTER GET DISK)
12768                      	
12769          [01]        		IF	CHECKSUM == 1
12770                      		lda	CKS_COUNT
12771                      		jsr	HEXNUM
12772                      		lda	CKSB
12773                      		jsr	HEXNUM
12774                      		lda	#EOL
12775                      		jsr	CHAR
12776          [00]        		ENDIF
12777                      	
12778   8EBB   A9 02       		lda	#2		; SET TO
12779   8EBD   A2 00       		ldx	#0
12780   8EBF   4C DD 43    		jmp	PUTBYT		; SUCCESS
12781                      	
12782                      	
12783                      		; DO PARTIAL RESTORE GETTING 1ST PAGE 
12784                      		; AND LAST PAGE BYTE ALIGNMENT CORRECT
12785                      	        ; WRITE LOCALS TO IOBUFF JUST TO LOOK AT NAME
12786   8EC2               	ZPARTR:	
12787   8EC2   A9 00       		lda	#MAIN
12788   8EC4   85 B8       		sta	DSKBNK
12789   8EC6   A9 08       		lda	#>IOBUFF	; DON'T READ TO LOCALS YET (X)
12790   8EC8   85 B7       		sta	DBUFF+HI
12791   8ECA   A9 02       		lda	#2		; just one block please
12792   8ECC   85 7E       		sta	L+LO
12793   8ECE   20 11 48    		jsr	GETRES		; RETRIEVE 1ST BLOCK OF PRELOAD
12794   8ED1   90 03       		bcc     ZRN2            ; worked just fine
12795   8ED3               	ZPBAD:
12796   8ED3   4C 3C 8E    	        jmp	BADRES		; names don't match, die
12797   8ED6               	ZRN2:
12798   8ED6   A5 67       		lda	ARG3+LO		; set up FPC to get save name
12799   8ED8   85 8C       		sta	FPCL		; lo part is okay
12800   8EDA   A5 68       		lda	ARG3+HI		; get page
12801   8EDC   20 77 8F    		jsr	SETPC		; get memory addr
12802   8EDF   85 8D       		sta	FPCH		; page number
12803   8EE1   84 8E       		sty	FPCBNK		; and bank
12804   8EE3   20 56 92    		jsr	FETCHB		; get count
12805   8EE6   85 78       		sta	I		; and save it
12806   8EE8   20 BE 8F    		jsr	NEXTFPC		; point to next byte
12807   8EEB   A9 20       		lda	#<BUFSAV	; get bufsav offset
12808   8EED   18          		clc			; and add
12809   8EEE   69 0A       		adc	#10		; name offset
12810   8EF0   85 7A       		sta	J		; did it
12811   8EF2               	ZRN3:
12812   8EF2   20 56 92    		jsr	FETCHB		; get data byte
12813   8EF5   A4 7A       		ldy	J		; get offset
12814   8EF7   D9 00 08    		cmp	IOBUFF,Y	; save into buffer
12815   8EFA   D0 D7       		bne	ZPBAD		; okay, then it's not it
12816   8EFC   20 BE 8F    		jsr	NEXTFPC		; point to next byte
12817   8EFF   E6 7A       		inc	J		; next byte
12818   8F01   C6 78       		dec	I		; count it
12819   8F03   D0 ED       		bne	ZRN3		; loop again
12820                      	
12821   8F05   A5 64       		lda	ARG1+HI		; FIND WHERE TO START & HOW FAR TO GO
12822   8F07   20 77 8F    		jsr	SETPC		; get page in memory
12823   8F0A   85 90       		sta	SPCH		; this is page
12824   8F0C   84 91       		sty	SPCBNK		; which bank
12825   8F0E   A5 63       		lda	ARG1+LO		; START BYTE FIRST PAGE
12826   8F10   85 8F       		sta	SPCL
12827                      	
12828   8F12   A6 66       		ldx	ARG2+HI
12829   8F14   86 7B       		stx	J+HI
12830   8F16   A6 65       		ldx	ARG2+LO
12831   8F18   86 7A       		stx	J+LO            ; how many to get
12832                      	
12833   8F1A   20 C6 44    		jsr	DECJ		; correct alignment for this usage
12834   8F1D               	POK:
12835   8F1D   A9 08       		lda	#>IOBUFF	; get 1st page
12836   8F1F   85 B7       		sta	DBUFF+HI	; getres should keep in iobuff
  Wed May 24 1989 15:00                                                                                                  Page  192

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12837   8F21   8D 3D 8F    	        sta     ZPARTMOD+2      ; and show where to get it from
12838   8F24   A9 01       	        lda     #$01            ; is it odd
12839   8F26   24 90       	        bit     SPCH            ; get page destination
12840   8F28   F0 03       	        beq     ZPARTx          ; nope
12841   8F2A   EE 3D 8F    	        inc     ZPARTMOD+2      ; then get second page worth
12842   8F2D               	ZPARTx:
12843   8F2D   A9 02       		lda	#2		; just do one block
12844   8F2F   85 7E       		sta	L+LO
12845   8F31   20 11 48    		jsr	GETRES
12846   8F34   90 03       		bcc	ZPART0
12847   8F36   4C 74 47    		jmp	DISK_FATAL	; ALL MESSED UP, JUST QUIT
12848   8F39               	ZPART0:
12849   8F39   A4 63       		ldy	ARG1+LO		; START BYTE FIRST PAGE
12850   8F3B               	ZPARTMOD:
12851   8F3B   B9 00 08    		lda	IOBUFF,Y        ; this gets modified with good page #
12852   8F3E   20 35 92    		jsr	STASHB
12853   8F41   20 9E 8F    		jsr	NEXTSPC
12854   8F44   20 C6 44    		jsr	DECJ
12855   8F47   B0 03       		bcs	ZPART1		; CARRY CLEAR IF $FFFF RESULT
12856   8F49   4C B5 8E    		jmp	ZROUT
12857   8F4C               	ZPART1:
12858   8F4C   E6 63       		inc	ARG1+LO
12859   8F4E   D0 E9       		bne	ZPART0
12860   8F50   A9 09       	        lda     #>IOBUFF+1      ; this is second page address
12861   8F52   CD 3D 8F    	        cmp     ZPARTMOD+2      ; is it second one already?
12862   8F55   F0 C6       		beq	POK		; yes, so read in a new block
12863   8F57   8D 3D 8F    	        sta     ZPARTMOD+2      ; then update it 
12864   8F5A   D0 DD       	        bne     ZPART0          ; and do it again
12865                      	;
12866                      	; THE OLD SAVE & RESTORE STILL HAVE OPCODES
12867                      	; SO JUST PUT IN A PLACE FOR THEM HERE FOR NOW
12868                      	;
12869   8F5C               	OSAVE:
12870   8F5C   60          	OREST:	RTS
12871                      	
12872   8F5D               	ZISAVE:
12873   8F5D   4C DA 43    	ZIREST:	JMP	RET0	; NOT IMPLEMENTED ON APPLE
12874   8F60               		END
12875                      	
12876                      	
12877   8F60               		TITLE 	"APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
12878   8F60               		INCLUDE 	XPAGING.ASM
12879   8F60               		STTL "--- MEMORY PAGING ROUTINES ---"
12880                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page  193

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

12881                      	
12882                      	; -------------------------
12883                      	; POINT [MPC] TO V-ADDR [I]
12884                      	; -------------------------
12885                      	
12886   8F60   A5 78       	SETWRD:	LDA	I+LO	
12887   8F62   85 86       		STA	MPCL	
12888   8F64   A5 79       		LDA	I+HI	
12889   8F66   85 87       		STA	MPCM	
12890   8F68   A9 00       		LDA	#0	
12891   8F6A   85 88       		STA	MPCH	; ZERO TOP BIT
12892   8F6C   4C 80 90    		JMP	VLDMPC	
12893                      	
12894                      	;
12895   8F6F   00 00       	WANTED:	DB	00,00	
12896                      	;
12897   8F71   00          	NEXT:	DB	00	
12898   8F72   00          	NSUBA:	DB	00	
12899   8F73   00          	PSUBA:	DB	00	
12900                      	;
12901   8F74   00          	YTEMP:	DB	00	
12902   8F75   00          	ATEMP:	DB	00	
12903   8F76   00          	NSUBY:	DB	00	
12904                      	;
12905                      	; set [A](page), [Y](bank) to point to memory page where page in [A] is
12906                      	;
12907   8F77               	SETPC:			
12908   8F77   85 BC       		sta	MEMPAGE		; save it for later addition
12909   8F79   C9 29       		cmp	#P2PAGE 	; IS IT A PAGE IN MAIN
12910   8F7B   B0 06       		bcs	VF2		; No, it might be in aux mem
12911                      	
12912   8F7D   A9 96       		lda	#>ZBEGIN 	; ADD OFFSET TO GET RAM PAGE
12913   8F7F   A0 00       		ldy	#MAIN		; in the main bank
12914   8F81   F0 12       		beq	VFEXI		; BRA to fetch
12915   8F83               	VF2:
12916   8F83   C9 D6       		cmp	#PGBEGIN	; is it paged?
12917   8F85   B0 12       		bcs	VFERR		; yes it be paged, so can't deal with it
12918   8F87   C9 A8       		cmp	#P3PAGE		; is it in Aux Mem, Part 2?
12919   8F89   B0 06       		bcs	VF3		; yes, so subtract different amount
12920                      	;
12921                      	; this is in lower aux 
12922                      	;				
12923   8F8B   A9 17       		lda	#(Z2PAGE-Z1SIZE) ; subtract size from offset
12924   8F8D   A0 01       		ldy	#AUX		; show aux mem
12925   8F8F   D0 04       		bne	VFEXI		; jump to end
12926   8F91               	VF3:
12927   8F91   A9 28       		lda	#(Z3PAGE-(Z1SIZE+Z2SIZE)) ; subtract out first 2 sides
12928   8F93   A0 FF       		ldy	#P3BANK		; show page 3 bank
12929   8F95               	VFEXI:
12930   8F95   18          		clc			; get ready for addition
12931   8F96   65 BC       		adc	MEMPAGE		; now get actual offset
12932   8F98   60          		rts	
12933   8F99               	VFERR:
12934                      	;
12935                      	; out of range
12936                      	;
12937   8F99   A9 12       		lda	#18
12938   8F9B   4C 0A 52    		jmp	ZERROR
12939                      	;
12940                      	; NEXTSPC - inc SPCL and check for wrapping round to next bank
12941                      	;
12942   8F9E               	NEXTSPC:
12943   8F9E   E6 8F       		inc	SPCL		; next lo byte
12944   8FA0   D0 1B       		bne	NXSP_EXIT	; no change then
12945   8FA2   E6 90       		inc	SPCH		; next page
12946   8FA4   A5 90       		lda	SPCH		; so get page
12947   8FA6   C9 BF       		cmp	#>PRGLBL	; have we reached end of line?
12948   8FA8   D0 13       		bne	NXSP_EXIT	; we be okay
12949   8FAA   A5 91       		lda	SPCBNK		; get bank
12950   8FAC   D0 07       		bne	NXSP1		; must go to Part 3
12951   8FAE   E6 91       		inc	SPCBNK		; so point to aux bank
12952   8FB0   A9 40       		lda	#Z2PAGE		; first page in aux
12953   8FB2   85 90       		sta	SPCH		; and point to it
12954   8FB4   60          		rts			; and all done
12955   8FB5               	NXSP1:
  Wed May 24 1989 15:00                                                                                                  Page  194

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

12956   8FB5   A9 D0       		lda	#Z3PAGE		; get start of page 3
12957   8FB7   85 90       		sta	SPCH		; and point there
12958   8FB9   A9 FF       		lda	#P3BANK		; and point to this bank
12959   8FBB   85 91       		sta	SPCBNK		; okey
12960   8FBD               	NXSP_EXIT:
12961   8FBD   60          		rts
12962                      	;
12963                      	; NEXTFPC - inc DPCL and check for wrapping round to next bank
12964                      	;
12965   8FBE               	NEXTFPC:
12966   8FBE   E6 8C       		inc	FPCL		; next lo byte
12967   8FC0   D0 1B       		bne	NXFP_EXIT	; no change then
12968   8FC2   E6 8D       		inc	FPCH		; next page
12969   8FC4   A5 8D       		lda	FPCH		; and get it for checking
12970   8FC6   C9 BF       		cmp	#>PRGLBL	; have we reached end of line?
12971   8FC8   D0 13       		bne	NXFP_EXIT	; we be okay
12972   8FCA   A5 8E       		lda	FPCBNK		; get bank
12973   8FCC   D0 07       		bne	NXFP1		; must skip over stuff in middle
12974   8FCE   E6 8E       		inc	FPCBNK		; so point to aux bank
12975   8FD0   A9 40       		lda	#Z2PAGE		; first page in aux
12976   8FD2   85 8D       		sta	FPCH		; and point to it
12977   8FD4   60          		rts			; toots finis
12978   8FD5               	NXFP1:
12979   8FD5   A9 D0       		lda	#Z3PAGE		; start of part 3
12980   8FD7   85 8D       		sta	FPCH		; so show me
12981   8FD9   A9 FF       		lda	#P3BANK		; and point to this bank
12982   8FDB   85 8E       		sta	FPCBNK		; okey
12983   8FDD               	NXFP_EXIT:
12984   8FDD   60          		rts
12985                      	;
12986                      	; ADDFPC - add amount in [A] to current FPC and check for bank wrap
12987                      	;
12988   8FDE               	ADDFPC:
12989   8FDE   18          		clc			; get ready for add
12990   8FDF   65 8C       		adc	FPCL		; add lo part
12991   8FE1   85 8C       		sta	FPCL		; and save it
12992   8FE3   90 1B       		bcc	AFPX		; all done if no page wrap
12993   8FE5   E6 8D       		inc	FPCH		; point to next page
12994   8FE7   A5 8D       		lda	FPCH		; get it for compare
12995   8FE9   C9 BF       		cmp	#>PRGLBL	; at end of line in main bank?
12996   8FEB   D0 13       		bne	AFPX		; nope, all done then
12997   8FED   A5 8E       		lda	FPCBNK		; get bank
12998   8FEF   F0 09       		beq	AFP1		; it is main, so we be ok
12999   8FF1   A9 D0       		lda	#Z3PAGE		; must go to part 3 if in aux mem
13000   8FF3   85 8D       		sta	FPCH		; thanx
13001   8FF5   A9 FF       		lda	#P3BANK		; and point to this bank
13002   8FF7   85 8E       		sta	FPCBNK		; okey
13003   8FF9   60          		rts			; done
13004   8FFA               	AFP1:
13005   8FFA   E6 8E       		inc	FPCBNK		; point to aux
13006   8FFC   A9 40       		lda	#Z2PAGE		; get start in aux
13007   8FFE   85 8D       		sta	FPCH		; and save it
13008   9000               	AFPX:
13009   9000   60          		rts
13010                      	;
13011                      	; ADDSPC - add amount in [A] to current SPC and check for bank wrap
13012                      	;
13013   9001               	ADDSPC:
13014   9001   18          		clc			; get ready for add
13015   9002   65 8F       		adc	SPCL		; add lo part
13016   9004   85 8F       		sta	SPCL		; and save it
13017   9006   90 1B       		bcc	ASPX		; all done if no page wrap
13018   9008   E6 90       		inc	SPCH		; point to next page
13019   900A   A5 90       		lda	SPCH		; get it for compare
13020   900C   C9 BF       		cmp	#>PRGLBL	; at end of line in main bank?
13021   900E   D0 13       		bne	ASPX		; nope, all done then
13022   9010   A5 91       		lda	SPCBNK		; get bank
13023   9012   F0 09       		beq	ASP1		; it is main, so we be ok
13024   9014   A9 D0       		lda	#Z3PAGE		; must go to part 3 if in aux mem
13025   9016   85 90       		sta	SPCH		; thanx
13026   9018   A9 FF       		lda	#P3BANK		; and point to this bank
13027   901A   85 91       		sta	SPCBNK		; okey
13028   901C   60          		rts			; done
13029   901D               	ASP1:
13030   901D   E6 91       		inc	SPCBNK		; point to aux
  Wed May 24 1989 15:00                                                                                                  Page  195

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13031   901F   A9 40       		lda	#Z2PAGE		; get start in aux
13032   9021   85 90       		sta	SPCH		; and save it
13033   9023               	ASPX:
13034   9023   60          		rts
13035                      	;
13036                      	; PREVFPC - DEC FPCL and check for wrapping round to next bank
13037                      	;
13038   9024               	PREVFPC:
13039   9024   A5 8C       		lda	FPCL		; get lo part
13040   9026   D0 1E       		bne	PFPC2		; it's not zero, so no wrapping
13041   9028   A5 8D       		lda	FPCH		; get current page
13042   902A   C9 40       		cmp	#Z2PAGE		; have we reached beginning of page 2?
13043   902C   F0 08       		beq	PFPC1		; wrap to first bank
13044   902E   C9 D0       		cmp	#Z3PAGE		; beginning of part 3?
13045   9030   F0 0C       		beq	PFPC3		; ayyup
13046   9032   C6 8D       		dec	FPCH		; point to previous page
13047   9034   D0 10       		bne	PFPC2		; okay
13048   9036               	PFPC1:
13049   9036   A5 8E       		lda	FPCBNK		; get bank
13050   9038   F0 0F       		beq	VF1ERR		; oops, can't go backwards from main bank
13051   903A   A9 00       		lda	#MAIN		; so point to main bank
13052   903C   F0 02       		beq	PFPC4		; and store it away
13053   903E               	PFPC3:
13054   903E   A9 01       		lda	#AUX		; and point to this bank
13055   9040               	PFPC4:
13056   9040   85 8E       		sta	FPCBNK		; okey
13057   9042   A9 BE       		lda	#(>PRGLBL)-1	; get me last page in part 2
13058   9044   85 8D       		sta	FPCH		; and show me
13059   9046               	PFPC2:
13060   9046   C6 8C       		dec	FPCL		; and point to previous byte
13061   9048   60          		rts
13062   9049               	VF1ERR:
13063                      	;
13064                      	; out of range
13065                      	;
13066   9049   A9 13       		lda	#19
13067   904B   4C 0A 52    		jmp	ZERROR
13068                      	;
13069                      	; PREVSPC - DEC SPCL and check for wrapping round to main bank
13070                      	;
13071   904E               	PREVSPC:
13072   904E   A5 8F       		lda	SPCL		; get lo part
13073   9050   D0 1E       		bne	PSPC2		; it's not zero, so no wrapping
13074   9052   A5 90       		lda	SPCH		; get current page
13075   9054   C9 40       		cmp	#Z2PAGE		; have we reached beginning of page 2?
13076   9056   F0 08       		beq	PSPC1		; wrap to first bank
13077   9058   C9 D0       		cmp	#Z3PAGE		; down past page 3?
13078   905A   F0 0C       		beq	PSPC3		; sure is
13079   905C   C6 90       		dec	SPCH		; point to previous page
13080   905E   D0 10       		bne	PSPC2		; okay
13081   9060               	PSPC1:
13082   9060   A5 91       		lda	SPCBNK		; get bank
13083   9062   F0 E5       		beq	VF1ERR		; oops, can't go backwards from main bank
13084   9064   A9 00       		lda	#MAIN		; so point to main bank
13085   9066   F0 02       		beq	PSPC4		; so save it
13086   9068               	PSPC3:
13087   9068   A9 01       		lda	#AUX		; and point to this bank
13088   906A               	PSPC4:
13089   906A   85 8E       		sta	FPCBNK		; okey
13090   906C   A9 BE       		lda	#>PRGLBL-1	; get me last page in low part
13091   906E   85 90       		sta	SPCH		; and show me
13092   9070               	PSPC2:
13093   9070   C6 8F       		dec	SPCL		; and point to previous byte
13094   9072   60          		rts
13095                      	;
13096                      	; FP2SP - copy the 3 parts of FPC to SPC
13097                      	;
13098   9073               	FP2SP:
13099   9073   A5 8E       		lda	FPCBNK
13100   9075   85 91       		sta	SPCBNK
13101   9077   A5 8D       		lda	FPCH
13102   9079   85 90       		sta	SPCH
13103   907B   A5 8C       		lda	FPCL
13104   907D   85 8F       		sta	SPCL
13105   907F   60          		rts
  Wed May 24 1989 15:00                                                                                                  Page  196

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13106   9080               		
13107                      	; MAKE [MPCPNT],[MPCBNK] POINT TO
13108                      	; THE RAM PAGE AND BANK THAT HOLDS
13109                      	; THE V-PAGE MPCH,M
13110                      	;
13111   9080               	VLDMPC:			
13112   9080   A5 88       		lda	MPCH		; check hi part
13113   9082   D0 0F       		bne	VLD3		; NOT IN FIRST V-64K, so must be paged
13114   9084   A5 87       		lda	MPCM		; check to see if it is paged
13115   9086   20 A2 91    		jsr	CHECKPRE	; is it preloaded?
13116   9089   B0 08       		bcs	VLD3		; no, so it be paged
13117   908B   20 77 8F    		jsr	SETPC		; so put page/bank into A/Y
13118   908E   84 8B       		sty	MPCBNK	
13119   9090   85 8A       		sta	MPCPNT+HI	
13120   9092               	NOMUCK:
13121   9092   60          		rts	
13122                      	;
13123                      	; must be paged, so check for it or read it in
13124                      	;
13125   9093               	VLD3:	
13126   9093   A5 88       		lda	MPCH	
13127   9095   A4 87       		ldy	MPCM	
13128   9097   20 E0 90    		jsr	PAGE	;RETURN BUFFER IN A THAT HAS VPAGE A,Y
13129   909A   18          		clc		
13130   909B   69 08       		adc	#>PBEGIN	
13131   909D   85 8A       		sta	MPCPNT+HI	
13132   909F   A0 01       		ldy	#PB_BANK	; paging buffers are in aux mem
13133   90A1   84 8B       		sty	MPCBNK	
13134                      	;
13135                      	; TEST FOR MUCK
13136                      	;
13137   90A3   AD DF 90    		lda	MUCKFLG	
13138   90A6   F0 EA       		beq	NOMUCK	
13139   90A8   D0 00       		bne	VLDZPC	;MAY HAVE MUCKED ZPC SO GO FIX
13140                      	;
13141                      	; SAME IDEA AS VLDMPC
13142                      	;
13143   90AA               	VLDZPC:
13144   90AA   A5 59       	        lda     INFODOS         ; check first for InfoDOS page
13145   90AC   F0 06       	        beq     VLDZ1           ; none
13146   90AE   20 B7 91    	        jsr     INFO_PAGE       ; well, is it?
13147   90B1   90 01       	        bcc     VLDZ1           ; nope
13148   90B3   60          	        rts                     ; all set otherwise
13149   90B4               	VLDZ1:
13150   90B4   A5 82       		lda	ZPCH	
13151   90B6   D0 0F       		bne	VLDZ3		;NOT IN FIRST V-64K, so must be paged
13152   90B8   A5 81       		lda	ZPCM		; check to see if it is paged
13153   90BA   20 A2 91    		jsr	CHECKPRE	; is it preloaded?
13154   90BD   B0 08       		bcs	VLDZ3		; no, so it must be paged
13155   90BF   20 77 8F    		jsr	SETPC		; point to correct bank and page
13156   90C2   84 85       		sty	ZPCBNK		; set bank
13157   90C4   85 84       		sta	ZPCPNT+HI	; and MSB of pointer
13158   90C6               	NOZMUCK:
13159   90C6   60          		rts		
13160                      	VLDZ3:				;MUST BE PAGED
13161   90C7   A5 82       		lda	ZPCH	
13162   90C9   A4 81       		ldy	ZPCM	
13163   90CB   20 E0 90    		jsr	PAGE		;RETURN BUFFER IN A THAT HAS VPAGE A,Y
13164   90CE   18          		clc		
13165   90CF   69 08       		adc	#>PBEGIN	
13166   90D1   85 84       		sta	ZPCPNT+HI	
13167   90D3   A0 01       		ldy	#PB_BANK
13168   90D5   84 85       		sty	ZPCBNK	
13169                      	;
13170                      	; TEST MUCKING
13171                      	;
13172   90D7   AD DF 90    		lda	MUCKFLG	
13173   90DA   F0 EA       		beq	NOZMUCK	
13174   90DC   4C 80 90    		jmp	VLDMPC	;MAY HAVE MUCKED MPC SO GO FIX
13175                      	
13176                      	
13177                      	; FIND V-PAGE A,Y IF IT IS IN MEM
13178                      	; AND RETURN WITH LINKED LIST
13179                      	; PROPERLY MAINTAINED
13180                      	; IF V-PAGE A,Y NOT IN MEM
  Wed May 24 1989 15:00                                                                                                  Page  197

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13181                      	; GET FROM DISK AND PUT IN RIGHT
13182                      	; PLACE
13183                      	
13184   90DF   00          	MUCKFLG:	DB	00	;00 IF PAGING BUFFERS NOT MUCKED
13185                      	
13186   90E0               	PAGE:
13187   90E0   8D 70 8F    		sta	WANTED+HI	
13188   90E3   8C 6F 8F    		sty	WANTED+LO	
13189   90E6   A2 00       		ldx	#0	
13190   90E8   8E DF 90    		stx	MUCKFLG		; CLEAR MUCK FLAG
13191   90EB   20 8A 91    		jsr	WHERE	
13192   90EE   90 39       		bcc	TOUGH		; PAGE IS RESIDENT IN PAGING SPACE
13193                      	;
13194                      	; PAGE MUST BE BROUGHT IN FROM DISK
13195                      	;
13196   90F0   A6 CD       		ldx	CURRENT		;GET BUFFER TO PUT PAGE INTO
13197   90F2   BD 00 0C    		lda	NEXTPNT,X	;BY LOOKING AT NEXT POINTER
13198   90F5   85 CD       		sta	CURRENT		;MAKE IT THE CURRENT BUFFER
13199   90F7   AA          		tax		
13200   90F8   AD 70 8F    		lda	WANTED+HI	;LET BUFFER MAP KNOW
13201   90FB   9D 80 0C    		sta	VPAGEH,X	;WHICH PAGE
13202   90FE   AD 6F 8F    		lda	WANTED+LO	;IS GOING TO
13203   9101   29 FE       		and	#$FE		; make address be even
13204   9103   9D C0 0C    		sta	VPAGEL,X	;BE THERE
13205                      	;***
13206                      	; point to the next page too
13207                      	;
13208   9106   09 01       		ora	#1		; add one to point to next 256 byte page
13209   9108   48          		pha			; save it
13210   9109   8A          		txa			; get pointer
13211   910A   A8          		tay			; into y
13212   910B   C8          		iny			; point to next buffer
13213   910C   68          		pla			; get second buffer back
13214   910D   99 C0 0C    		sta	VPAGEL,Y	; so point to it
13215   9110   BD 80 0C    		lda	VPAGEH,X	; get MSB
13216   9113   99 80 0C    		sta	VPAGEH,Y	; and save it
13217                      	;
13218                      	; A = WANTED+HI
13219                      	; Y = WANTED+LO
13220                      	; X = BUFFER
13221                      	;
13222   9116   AD 6F 8F    		lda	WANTED+LO	
13223   9119   29 FE       		and	#$FE		; clear low bit to make it even
13224   911B   A8          		tay			; want it in y
13225                      	;*** 
13226   911C   AD 70 8F    		lda	WANTED+HI	
13227   911F   A6 CD       		ldx	CURRENT
13228   9121   20 4E 91    		jsr	GETVPAGE	; PUT V-PAGE A,Y INTO PAGING BUFFER X
13229                      	;***
13230   9124   CE DF 90    		dec	MUCKFLG		; INDICATE A MUCKING
13231   9127   D0 1C       		bne	PAGEXIT		; and return current buffer
13232   9129               	TOUGH:
13233   9129   29 FE       		and	#$FE		; make even page, please
13234   912B   8D 71 8F    		sta	NEXT	
13235   912E   C5 CD       		cmp	CURRENT		; GETS REALY SCREWED IF CURRENT==NEXT
13236   9130   F0 13       		beq	PAGEXIT		; DO NOT CHANGE POINTERS IF IT DOES
13237                      	;
13238                      	; Y=NEXT(CURRENT)
13239                      	; DO THE RIGHT THING TO THE POINTERS
13240                      	;
13241                      	;	ldy	CURRENT	
13242                      	;	lda	NEXTPNT,Y	
13243                      	;	sta	NSUBCUR	
13244   9132   AD 71 8F    		lda	NEXT	
13245   9135   20 78 91    		jsr	DETATCH	
13246   9138   A4 CD       		ldy	CURRENT	
13247   913A   AD 71 8F    		lda	NEXT	
13248   913D   20 61 91    		jsr	INSERT	
13249   9140   AD 71 8F    		lda	NEXT	
13250   9143   85 CD       		sta	CURRENT	
13251   9145               	PAGEXIT:
13252                      	;*** perhaps add one to point to correct buffer
13253   9145   AD 6F 8F    		lda	WANTED+LO	; get LSB
13254   9148   29 01       		and	#$01		; pick up even/odd bit
13255   914A   18          		clc			; doing add
  Wed May 24 1989 15:00                                                                                                  Page  198

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13256   914B   65 CD       		adc	CURRENT		; point to correct buffer
13257   914D   60          		rts
13258                      	
13259   914E               	GETVPAGE:			
13260   914E   8D 5A 6C    		sta	DBLOCK+HI	
13261   9151   8C 59 6C    		sty	DBLOCK+LO	
13262   9154   8A          		txa			; get which paging buffer
13263   9155   18          		clc		
13264   9156   69 08       		adc	#>PBEGIN	; and set up abs addr
13265   9158   85 B7       		sta	DBUFF+HI	; thank you, that's much better
13266   915A   A2 01       		ldx	#PB_BANK
13267   915C   86 B8       		stx	DSKBNK	
13268   915E   4C CF 46    		jmp	GETDSK	
13269                      	
13270                      	; INSERT A AFTER Y
13271                      	; A.next = Y.next
13272                      	; Y.next = A
13273                      	; A.previous = Y
13274                      	; [Y.next].previous = A
13275   9161               	INSERT:
13276   9161   AA          		tax
13277   9162   B9 00 0C    		lda	NEXTPNT,Y	; Y.next
13278   9165   9D 00 0C    		sta	NEXTPNT,X	; A.next = Y.next
13279   9168   48          		pha			; save Y.next for later
13280   9169   8A          		txa
13281   916A   99 00 0C    		sta	NEXTPNT,Y	; Y.next = A
13282   916D   98          		tya
13283   916E   9D 40 0C    		sta	PREVPNT,X	; A.prev = Y
13284   9171   68          		pla			; get Y.next back
13285   9172   A8          		tay			; [Y.next].previous
13286   9173   8A          		txa
13287   9174   99 40 0C    		sta	PREVPNT,Y	; [Y.next].previous = A
13288   9177   60          		rts
13289                      	
13290          [01]        		IF	0	
13291                      	;
13292                      	; old one, which puts A AFTER! Y
13293                      	;
13294                      	; PREV(A)=Y
13295                      	; PREV(NEXT(Y))=A
13296                      	; NEXT(A)=NEXT(Y)
13297                      	; NEXT(Y)=A
13298                      	
13299                      		sta	ATEMP	
13300                      		sty	YTEMP	
13301                      		tax		
13302                      		tya		
13303                      		sta	PREVPNT,X	
13304                      	
13305                      		lda	NEXTPNT,Y	
13306                      		sta	NSUBY	
13307                      		txa		
13308                      		ldx	NSUBY	
13309                      		sta	PREVPNT,X	
13310                      	
13311                      		txa		
13312                      		ldx	ATEMP	
13313                      		sta	NEXTPNT,X	
13314                      	
13315                      		lda	ATEMP	
13316                      		sta	NEXTPNT,Y	
13317                      		rts		
13318          [00]        		ENDIF
13319                      	
13320                      	; DETATCH BUFFER >A<
13321                      	; NEXT(PREV(A))=NEXT(A)
13322                      	; PREV(NEXT(A))=PREV(A)
13323                      	
13324   9178               	DETATCH:
13325   9178   AA          		tax
13326   9179   BD 00 0C    		lda	NEXTPNT,X
13327   917C   A8          		tay			; Y == A.next
13328   917D   BD 40 0C    		lda	PREVPNT,X	; get A.previous
13329   9180   AA          		tax			; X == A.previous
13330   9181   98          		tya			; get A.next
  Wed May 24 1989 15:00                                                                                                  Page  199

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13331   9182   9D 00 0C    		sta	NEXTPNT,X	; [A.previous].next = A.next
13332   9185   8A          		txa			; get A.previous
13333   9186   99 40 0C    		sta	PREVPNT,Y	; [A.next].previous = A.previous
13334   9189   60          		rts		
13335                      	
13336                      	
13337                      	; RETURN BUFFER OF PAGE [WANTED]
13338                      	; IN >A< ELSE SEC  (Y=WANTED+LO)
13339                      	
13340   918A   A2 17       	WHERE:	LDX	#NUMBUFS-1	
13341   918C               	WHLOOP:			
13342   918C   AD 70 8F    		LDA	WANTED+HI	
13343   918F   DD 80 0C    		CMP	VPAGEH,X	;>SAME
13344   9192   F0 05       		BEQ	WHGOT	
13345   9194               	WHNOGOT:			
13346   9194   CA          		DEX		
13347   9195   10 F5       		BPL	WHLOOP	
13348   9197   38          		SEC		
13349   9198   60          		RTS		
13350   9199               	WHGOT:			
13351   9199   98          		TYA		
13352   919A   DD C0 0C    		CMP	VPAGEL,X	
13353   919D   D0 F5       		BNE	WHNOGOT	
13354   919F   8A          		TXA		
13355   91A0   18          		CLC		
13356   91A1   60          		RTS		
13357                      	;
13358                      	; CHECKPRE - check to see if page in [A] is in preloaded
13359                      	;
13360   91A2               	CHECKPRE:
13361   91A2   C5 C2       		cmp	TBLPUR		; check against PURE tables
13362   91A4   90 0B       		bcc	CHKPEXY		; must be preloaded then
13363   91A6               	CHKP1:
13364   91A6   C5 C3       		cmp	FUNPRE		; is it in function preload?
13365   91A8   90 09       		bcc	CHKPEXN		; preloaded function > desired, not preloaded
13366   91AA   C5 C4       		cmp	FUNPUR		; how bout at end?
13367   91AC   B0 05       		bcs	CHKPEXN		; it is not preloaded
13368   91AE               	CHKP3:
13369   91AE   18          		clc			; doing add
13370   91AF   65 C5       		adc	FUNPGE		; get me memory page for function
13371   91B1               	CHKPEXY:
13372   91B1   18          		clc			; show it is preloaded
13373   91B2   60          		rts			; then we got it
13374   91B3               	CHKPEXN:
13375   91B3   38          		sec			; show it ain't here
13376   91B4   60          		rts
13377                      	;
13378                      	; INFO_PAGE - is it one of the special preloaded pages for infoDOS?  If it
13379                      	;       is, then set up ZPCPNTR to point to it, and set carry.  Otherwise,
13380                      	;       clear carry to show it ain't.
13381   91B5               	IPAGE:	ds	2
13382   91B7               	INFO_PAGE:
13383   91B7   A5 82       	        lda     ZPCH            ; get 2 parts
13384   91B9   8D B6 91    	        sta     IPAGE+HI
13385   91BC   A5 81       	        lda     ZPCM
13386   91BE   8D B5 91    	        sta     IPAGE+LO
13387   91C1   4E B6 91    	        lsr     IPAGE+HI      ; /2 to get 512 block        
13388   91C4   6E B5 91    	        ror     IPAGE+LO
13389   91C7   A0 08       	        ldy     #SGTSEG         ; point to first segment, MSB
13390   91C9   B1 59       	        lda     (INFODOS),Y     ; howzit look?
13391   91CB   C8          	        iny                     ; point to LSB
13392   91CC   CD B6 91    	        cmp     IPAGE+HI
13393   91CF   90 0B       	        bcc     INFP1           ; might be interesting
13394   91D1   D0 34       	        bne     INFPNX          ; not here, < than minimum
13395   91D3   B1 59       	        lda     (INFODOS),Y     ; how bout LSB
13396   91D5   CD B5 91    	        cmp     IPAGE+LO
13397   91D8   F0 14       	        beq     INFPYX          ; found it
13398   91DA   B0 2B       	        bcs     INFPNX          ; nope, < than minimum again
13399                      	;
13400                      	; here, it's at least > than minimum
13401                      	;
13402   91DC               	INFP1:
13403                      	;        iny                     ; point at end block, MSB
13404   91DC   AD A6 6C    	        lda     INFODOS_END+HI  ; howz end segment look
13405   91DF   CD B6 91    	        cmp     IPAGE+HI
  Wed May 24 1989 15:00                                                                                                  Page  200

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13406   91E2   90 23       	        bcc     INFPNX          ; nope, > than maximum of special
13407   91E4   D0 08       	        bne     INFPYX          ; yup, < than maximum of special
13408                      	;        iny                     ; LSB of last one
13409   91E6   AD A5 6C    	        lda     INFODOS_END+LO     ; is LSB < special?
13410   91E9   CD B5 91    	        cmp     IPAGE+LO      ; MSB of current one == MSB of special        
13411   91EC   90 19       	        bcc     INFPNX          ; nope, not here
13412   91EE               	INFPYX:
13413   91EE   A0 09       	        ldy     #SGTSEG+1       ; point back to start block, LSB
13414   91F0   B1 59       	        lda     (INFODOS),Y     ; get start block
13415   91F2   0A          	        asl     A               ; *2 to get start page
13416   91F3   8D B5 91    	        sta     IPAGE+LO      ; save it
13417   91F6   A5 81       	        lda     ZPCM
13418   91F8   38          	        sec                     ; doing sub
13419   91F9   ED B5 91    	        sbc     IPAGE+LO      ; get offset into special block
13420   91FC   18          	        clc                     ; now add in offset
13421   91FD   69 D0       	        adc     #>SP_START      ; get the start of special area
13422   91FF   85 84       	        sta     ZPCPNT+HI       ; show ZPCPNTR
13423   9201   A9 00       	        lda     #SP_BANK        ; which bank
13424   9203   85 85       	        sta     ZPCBNK          ; okey
13425   9205   38          	        sec                     ; show it was here
13426   9206   60          	        rts
13427   9207               	INFPNX:
13428   9207   18          	        clc                     ; show not here
13429   9208   60          	        rts                     ; g'day
13430   9209               	        
13431   9209               	        
13432   9209               	        
13433   9209               	CHKPEXN0:
13434                      	
13435   9209               	GETBYT:			
13436   9209   A4 86       		ldy	MPCL	
13437   920B   20 88 92    		jsr	MFETCH		; go and get it
13438   920E   E6 86       		inc	MPCL		;POINT TO NEXT BYTE
13439   9210   D0 0B       		bne	GETGOT		;IF NO CROSS WE ARE STILL VALID
13440   9212   E6 87       		inc	MPCM	
13441   9214   D0 02       		bne	GET1
13442   9216   E6 88       		inc	MPCH
13443   9218               	GET1:
13444   9218   48          		pha			; save byte	
13445   9219   20 80 90    		jsr	VLDMPC	
13446   921C   68          		pla			; and get it back
13447   921D               	GETGOT:
13448   921D   A8          		tay		;SET FLAGS
13449   921E   60          		rts		;RED SLIPPER TIME
13450                      	;
13451                      	; NEXTPC - Fetch the byte at the current ZPC, point to next byte and
13452                      	; 		validate pointer
13453                      	;
13454   921F               	NEXTPC:
13455   921F   A4 80       		ldy	ZPCL		; get low pointer
13456   9221   20 70 92    		jsr	ZFETCH		; fetch @ZPCPNT
13457   9224   E6 80       		inc	ZPCL	
13458   9226   D0 0B       		bne	NXTGOT	
13459   9228   E6 81       		inc	ZPCM	
13460   922A   D0 02       		bne	CRSZ1	
13461   922C   E6 82       		inc	ZPCH	
13462   922E               	CRSZ1:
13463   922E   48          		pha			; save opcode
13464   922F   20 AA 90    		jsr	VLDZPC	
13465   9232   68          		pla			; and get it back
13466   9233               	NXTGOT:
13467   9233   A8          		tay		
13468   9234   60          		rts		
13469                      	
13470                      	;
13471                      	; STASHB - use SPC to save a byte in either aux or main mem
13472                      	;
13473   9235               	STASHB:	
13474   9235   A4 91       		ldy	SPCBNK		; get the bank
13475   9237   30 09       		bmi	SB1		; must be in upper RAM
13476   9239   99 04 C0    		sta	WRTBNK,Y	; set bank
13477   923C   A0 00       		ldy	#0		; can only do this with Y
13478   923E   91 8F       		sta	(SPC),Y		; get the sucker
13479   9240   F0 10       		beq	SBEXI		; jump to end it
13480                      	;
  Wed May 24 1989 15:00                                                                                                  Page  201

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13481                      	; this is in aux mem, >$E000
13482                      	;
13483   9242               	SB1:
13484   9242   A4 90       		ldy	SPCH		; get high part
13485   9244   8C 4E 92    		sty	SBMOD+2		; and self mod my code
13486   9247   A4 8F       		ldy	SPCL		; and get the low part
13487   9249   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
13488   924C               	SBMOD:
13489   924C   99 00 D0    		sta	Z3BEGIN,Y	; store the little byte
13490   924F   8D 08 C0    		sta	ALTZP+MAIN	; go back to main mem
13491   9252               	SBEXI:
13492   9252   8D 04 C0    		sta	WRTBNK+MAIN	; and write to main
13493   9255   60          		rts
13494                      	;
13495                      	; FETCHB - fetch a byte from either main memory, aux memory, or upper
13496                      	;	Aux memory
13497                      	;
13498   9256               	FETCHB:
13499   9256   A4 8E       		ldy	FPCBNK		; get the bank
13500   9258   30 04       		bmi	FB1		; must be in upper RAM
13501   925A   20 D1 00    		jsr	ZERO_FB		; go to low end fetch
13502   925D   60          		rts
13503                      	;
13504                      	; this is in aux mem, >$E000
13505                      	;
13506   925E               	FB1:
13507   925E   A5 8D       		lda	FPCH		; get which page
13508   9260   8D 6A 92    		sta	FBMOD+2		; and show in operand
13509   9263   A4 8C       		ldy	FPCL		; get which byte
13510   9265   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
13511   9268   B9 00 D0    	FBMOD:	lda	Z3BEGIN,Y	; get the sucker
13512   926B   8D 08 C0    		sta	ALTZP+MAIN	; go back to main mem
13513   926E   A8          		tay			; set condition code
13514   926F   60          		rts
13515                      	;
13516                      	; ZFETCH - after checking for which bank (main, aux 1 or aux 2), go get
13517                      	;  the byte @ ZPCPNT, with the offset being in [Y]
13518                      	;
13519   9270               	ZFETCH:
13520   9270   A6 85       		ldx	ZPCBNK		; get the bank
13521   9272   30 04       		bmi	ZFB1		; must be in upper RAM
13522   9274   20 DC 00    		jsr	ZERO_ZF		; go to low end fetch
13523   9277   60          		rts
13524                      	;
13525                      	; this is in aux mem, >$D000
13526                      	;
13527   9278               	ZFB1:
13528   9278   A5 84       		lda	ZPNTH		; which page are we talking about
13529   927A   8D 82 92    		sta	ZBMOD+2		; show in the operand
13530   927D   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
13531   9280   B9 00 D0    	ZBMOD:	lda	Z3BEGIN,Y	; get the sucker
13532   9283   8D 08 C0    		sta	ALTZP+MAIN	; go back to main mem
13533   9286   AA          		tax			; set condition code
13534   9287   60          		rts
13535                      	;
13536                      	; MFETCH - after checking for which bank (main, aux 1 or aux 2), go get
13537                      	;  the byte @MPCPNT, with the offset being in [Y]
13538                      	;
13539   9288               	MFETCH:
13540   9288   A6 8B       		ldx	MPCBNK		; get the bank
13541   928A   30 04       		bmi	MB1		; must be in upper RAM
13542   928C   20 E5 00    		jsr	ZERO_MF		; go to low end fetch
13543   928F   60          		rts
13544                      	;
13545                      	; this is in aux mem, >$D000
13546                      	;
13547   9290               	MB1:
13548   9290   A5 8A       		lda	MPNTH		; which page are we talking about
13549   9292   8D 9A 92    		sta	MBMOD+2		; show in the operand
13550   9295   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
13551                      	
13552   9298   B9 00 D0    	MBMOD:	lda	Z3BEGIN,Y	; get the sucker
13553                      	
13554   929B   8D 08 C0    		sta	ALTZP+MAIN	; go back to main mem
13555   929E   AA          		tax			; set condition code
  Wed May 24 1989 15:00                                                                                                  Page  202

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13556   929F   60          		rts
13557                      	
13558                      	
13559   92A0               		END
13560                      	
13561   92A0               		INCLUDE 	ZSTRING.ASM
13562                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page  203

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13563   92A0               		STTL "--- Z-STRING HANDLERS ---"
13564                      	
13565                      	; -----------------------
13566                      	; POINT MPC TO ZSTRING IN [I], using SOFF
13567                      	; -----------------------
13568                      	
13569   92A0               	SETSTR:
13570   92A0   A5 78       		lda	I+LO
13571   92A2   85 86       		sta	MPCL		; save in lo part	
13572   92A4   A5 79       		lda	I+HI
13573   92A6   85 87       		sta	MPCM		; middle part
13574   92A8   A9 00       		lda	#0		; clear hi part
13575   92AA   85 88       		sta	MPCH		; okay, we did
13576   92AC   06 86       		asl	MPCL		; *2
13577   92AE   26 87       		rol	MPCM
13578   92B0   26 88       		rol	MPCH
13579   92B2   06 86       		asl	MPCL		; *4
13580   92B4   26 87       		rol	MPCM
13581   92B6   26 88       		rol	MPCH
13582                      	;
13583                      	; now add the offset
13584                      	;
13585   92B8   A5 86       		lda	MPCL		; carry clear from above
13586   92BA   65 60       		adc	SOFFL		; add lo part of offset
13587   92BC   85 86       		sta	MPCL		; save
13588   92BE   A5 87       		lda	MPCM
13589   92C0   65 5F       		adc	SOFFM
13590   92C2   85 87       		sta	MPCM
13591   92C4   A5 88       		lda	MPCH
13592   92C6   65 5E       		adc	SOFFH
13593   92C8   85 88       		sta	MPCH
13594   92CA   4C 80 90    		jmp	VLDMPC		; make MPCPNT to it
13595                      	
13596                      	
13597   92CD   60          	ZSTEX:	RTS		
13598                      	
13599                      	; -----------------------
13600                      	; PRINT Z-STRING AT [MPC]
13601                      	; -----------------------
13602   92CE               	PZSTR:
13603   92CE   A2 00       	        ldx	#0	
13604   92D0   86 96       		stx	PSET	        ; ASSUME PERMANENT CHARSET
13605   92D2   86 9A       		stx	ZFLAG	        ; CLEAR BYTE FLAG
13606   92D4   CA          		dex		        ; = $FF
13607   92D5   86 97       		stx	TSET	        ; NO TEMPSET ACTIVE
13608   92D7               	PZTOP:
13609   92D7   20 CA 93    	        jsr	GETZCH	        ; GET A Z-CHAR
13610   92DA   B0 F1       		bcs	ZSTEX	        ; END OF STRING IF CARRY IS SET
13611   92DC   85 98       		sta	ZCHAR	        ; ELSE SAVE CHAR HERE
13612   92DE   AA          		tax		        ; SET FLAGS
13613   92DF   F0 45       		beq	BLANK	        ; PRINT SPACE IF CHAR = 0
13614   92E1   C9 04       		cmp	#4	        ; IS THIS AN F-WORD?
13615   92E3   90 5F       		bcc	DOFREQ	        ; APPARENTLY SO
13616   92E5   C9 06       		cmp	#6	        ; PERHAPS A SHIFT CODE?
13617   92E7   90 41       		bcc	NEWSET	        ; YES, CHANGE CHARSETS
13618   92E9   20 AC 93    		jsr	GETSET	        ; ELSE GET CHARSET
13619   92EC   AA          		tax		        ; SET FLAGS
13620   92ED   D0 14       		bne	SET1	        ; SKIP IF NOT CHARSET #0
13621                      	;
13622                      	; PRINT A LOWER-CASE CHAR (CHARSET #0)
13623                      	;
13624   92EF   A9 FA       	        lda     #$FA            ; what to add to get offset into char table
13625   92F1               	TOASC:
13626   92F1   8D F8 92    	        sta     TOASCM+1        ; modify code
13627   92F4   A5 98       	        lda     ZCHAR           ; use char as offset
13628   92F6   18          	        clc                     ; make char be an index
13629   92F7   69 06       	TOASCM: adc     #6              ; we just did
13630   92F9   AA          	        tax                     ; now use as index
13631   92FA   BD 8C 1F    	        lda     CHARSET,X       ; go get that char in charset zero
13632   92FD               	SHOVE:
13633   92FD   20 06 53    	        jsr	COUT	        ; SHOW THE CHAR
13634   9300   4C D7 92    		jmp	PZTOP	        ; AND GRAB NEXT CHAR
13635                      	;
13636                      	; PRINT AN UPPER-CASE CHAR (CHARSET #1)
13637                      	;
  Wed May 24 1989 15:00                                                                                                  Page  204

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13638   9303               	SET1:
13639   9303   C9 01       	        cmp	#1	        ; make sure it's set #1
13640   9305   D0 04       		bne	SET2	        ; else must be set #2
13641   9307   A9 14       		lda	#20             ; skip into Charset 1 part of table
13642   9309   D0 E6       		bne	TOASC	        ; fix just like the others
13643                      	;
13644                      	; PRINT FROM CHARSET #2
13645                      	;
13646   930B               	SET2:
13647   930B   A5 98       	        lda	ZCHAR	        ; retrieve the z-char
13648   930D   C9 06       	        cmp     #6              ; is it a special ascii char?
13649   930F   F0 04       	        beq     DIRECT          ; yes, so do it special
13650   9311   A9 2E       	        lda     #46             ; nothing special, just get offset
13651   9313   D0 DC       	        bne     TOASC           ; and jump
13652                      	;
13653                      	; DECODE A "DIRECT" ASCII CHAR
13654                      	;
13655   9315               	DIRECT:
13656   9315   20 CA 93    	        jsr	GETZCH	        ; FETCH NEXT Z-CHAR
13657   9318   0A          		asl	A		
13658   9319   0A          		asl	A		
13659   931A   0A          		asl	A		
13660   931B   0A          		asl	A		
13661   931C   0A          		asl	A	        ; SHIFT INTO POSITION
13662   931D   85 98       		sta	ZCHAR	        ; AND SAVE HERE
13663   931F   20 CA 93    		jsr	GETZCH	        ; GRAB YET ANOTHER Z-CHAR
13664   9322   05 98       		ora	ZCHAR	        ; SUPERIMPOSE THE 2ND BYTE
13665   9324   D0 D7       		bne	SHOVE	        ; AND PRINT THE RESULT
13666                      	;
13667                      	; PRINT A SPACE
13668                      	;
13669   9326               	BLANK:
13670   9326   A9 20       	        lda	#SPACE	        ; ASCII SPACE CHAR
13671   9328   D0 D3       		bne	SHOVE	
13672                      	
13673                      		; CHANGE CHARSET
13674                      	
13675   932A   38          	NEWSET:	SEC		; CONVERT THE SHIFT CODE
13676   932B   E9 03       		SBC	#3	; TO 1 OR 2
13677   932D   A8          		TAY		
13678   932E   20 AC 93    		JSR	GETSET	; IS MODE TEMPORARY?
13679   9331   D0 05       		BNE	TOPERM	; YES, DO A PERMSHIFT
13680   9333   84 97       		STY	TSET	; ELSE JUST A TEMPSHIFT
13681   9335   4C D7 92    		JMP	PZTOP	; AND CONTINUE
13682   9338   84 96       	TOPERM:	STY	PSET	; SET PERM CHARSET
13683   933A   C5 96       		CMP	PSET	; SAME AS BEFORE?
13684   933C   F0 99       		BEQ	PZTOP	; YES, CONTINUE
13685   933E   A9 00       		LDA	#0	
13686   9340   85 96       		STA	PSET	; ELSE RESET CHARSET
13687   9342   F0 93       		BEQ	PZTOP	; BEFORE LOOPING BACK
13688                      	
13689                      		; PRINT AN F-WORD
13690                      	
13691   9344   38          	DOFREQ:	SEC		
13692   9345   E9 01       		SBC	#1	; ZERO-ALIGN THE CODE
13693   9347   0A          		ASL	A	; AND MULTIPLY TIMES 64
13694   9348   0A          		ASL	A	; TO OBTAIN THE SEGMENT OFFSET
13695   9349   0A          		ASL	A	; INTO THE F-WORDS TABLE
13696   934A   0A          		ASL	A		
13697   934B   0A          		ASL	A		
13698   934C   0A          		ASL	A		
13699   934D   85 99       		STA	OFFSET	; SAVE OFFSET FOR LATER
13700   934F   20 CA 93    		JSR	GETZCH	; NOW GET THE F-WORD POINTER
13701   9352   0A          		ASL	A	; WORD-ALIGN IT
13702   9353   18          		CLC		; AND
13703   9354   65 99       		ADC	OFFSET	; ADD THE SEGMENT OFFSET
13704                      	;
13705                      	; set up FPC to point to FWORDS table
13706                      	;
13707   9356   A6 57       		ldx	FWORDS+ABANK
13708   9358   86 8E       		stx	FPCBNK
13709   935A   A6 56       		ldx	FWORDS+HI
13710   935C   86 8D       		stx	FPCH
13711   935E   A6 55       		ldx	FWORDS+LO
13712   9360   86 8C       		stx	FPCL
  Wed May 24 1989 15:00                                                                                                  Page  205

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13713   9362   20 DE 8F    		jsr	ADDFPC		; add offset of the F-word
13714   9365   20 56 92    		jsr	FETCHB		; and get MSB of F-word
13715   9368   85 79       		sta	I+HI		; and save it
13716   936A   20 BE 8F    		jsr	NEXTFPC		; and point to LSB
13717   936D   20 56 92    		jsr	FETCHB		; and get it
13718   9370   85 78       		sta	I+LO		; and save it
13719                      	;
13720                      	; SAVE THE STATE OF CURRENT Z-STRING
13721                      	;
13722   9372   A5 88       		LDA	MPCH	
13723   9374   48          		PHA		
13724   9375   A5 87       		LDA	MPCM	
13725   9377   48          		PHA		
13726   9378   A5 86       		LDA	MPCL	
13727   937A   48          		PHA		
13728   937B   A5 96       		LDA	PSET	
13729   937D   48          		PHA		
13730   937E   A5 9A       		LDA	ZFLAG	
13731   9380   48          		PHA		
13732   9381   A5 9C       		LDA	ZWORD+HI	
13733   9383   48          		PHA		
13734   9384   A5 9B       		LDA	ZWORD+LO	
13735   9386   48          		PHA		
13736   9387   20 B8 93    		JSR	SETFWD	; PRINT THE Z-STRING
13737   938A   20 CE 92    		JSR	PZSTR	; IN [I]
13738                      	;
13739                      	; RESTORE OLD Z-STRING
13740                      	;
13741   938D   68          		PLA		
13742   938E   85 9B       		STA	ZWORD+LO	
13743   9390   68          		PLA		
13744   9391   85 9C       		STA	ZWORD+HI	
13745   9393   68          		PLA		
13746   9394   85 9A       		STA	ZFLAG	
13747   9396   68          		PLA		
13748   9397   85 96       		STA	PSET	
13749   9399   68          		PLA		
13750   939A   85 86       		STA	MPCL	
13751   939C   68          		PLA		
13752   939D   85 87       		STA	MPCM	
13753   939F   68          		PLA		
13754   93A0   85 88       		STA	MPCH	
13755   93A2   A2 FF       		LDX	#$FF	
13756   93A4   86 97       		STX	TSET	; DISABLE TEMP CHARSET
13757   93A6   20 80 90    		JSR	VLDMPC	
13758   93A9   4C D7 92    		JMP	PZTOP	; CONTINUE INNOCENTLY
13759                      	
13760                      	
13761                      	; ----------------------
13762                      	; RETURN CURRENT CHARSET
13763                      	; ----------------------
13764                      	
13765   93AC   A5 97       	GETSET:	LDA	TSET	
13766   93AE   10 03       		BPL	GS	
13767   93B0   A5 96       		LDA	PSET	
13768   93B2   60          		RTS		
13769   93B3   A0 FF       	GS:	LDY	#$FF	
13770   93B5   84 97       		STY	TSET	
13771   93B7   60          		RTS		
13772                      	
13773                      	
13774                      	; -------------------------
13775                      	; POINT [I] AT FWORD STRING
13776                      	; -------------------------
13777                      	
13778   93B8   A5 78       	SETFWD:	LDA	I+LO	; WORD-ALIGN THE ADDRESS
13779   93BA   0A          		ASL	A		
13780   93BB   85 86       		STA	MPCL	
13781   93BD   A5 79       		LDA	I+HI	
13782   93BF   2A          		ROL	A		
13783   93C0   85 87       		STA	MPCM	
13784   93C2   A9 00       		LDA	#0	
13785   93C4   2A          		ROL	A		
13786   93C5   85 88       		STA	MPCH	
13787   93C7   4C 80 90    		JMP	VLDMPC	
  Wed May 24 1989 15:00                                                                                                  Page  206

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13788                      	
13789                      	
13790                      	; -----------------
13791                      	; FETCH NEXT Z-CHAR
13792                      	; -----------------
13793                      	
13794   93CA   A5 9A       	GETZCH:	LDA	ZFLAG	; WHICH BYTE IS THIS?
13795   93CC   10 02       		BPL	GTZ0	; $FF = LAST
13796   93CE   38          		SEC		; SET CARRY TO INDICATE
13797   93CF   60          		RTS		; NO MORE CHARS
13798   93D0   D0 13       	GTZ0:	BNE	GETZ1	; NOT FIRST CHAR, EITHER
13799                      	
13800                      		; GET A Z-WORD INTO [ZWORD], RETURN 1ST CHAR IN TRIPLET
13801                      	
13802   93D2   E6 9A       		INC	ZFLAG	; UPDATE CHAR COUNT
13803   93D4   20 09 92    		JSR	GETBYT	; GET TRIPLET AT [MPC]
13804   93D7   85 9C       		STA	ZWORD+HI	; INTO [ZWORD]
13805   93D9   20 09 92    		JSR	GETBYT	
13806   93DC   85 9B       		STA	ZWORD+LO	
13807   93DE   A5 9C       		LDA	ZWORD+HI	
13808   93E0   4A          		LSR	A		
13809   93E1   4A          		LSR	A	; SHIFT 1ST CHAR INTO PLACE
13810   93E2   4C 0E 94    		JMP	GTEXIT	; AND RETURN IT
13811   93E5   38          	GETZ1:	SEC		
13812   93E6   E9 01       		SBC	#1	
13813   93E8   D0 16       		BNE	GETZ2	; LAST CHAR IN TRIPLET IF ZERO
13814   93EA   A9 02       		LDA	#2	; ELSE
13815   93EC   85 9A       		STA	ZFLAG	; RESET CHAR INDEX
13816   93EE   A5 9B       		LDA	ZWORD+LO	; GET BOTTOM HALF OF TRIPLET
13817   93F0   85 78       		STA	I+LO	; MOVE HERE FOR SHIFTING
13818   93F2   A5 9C       		LDA	ZWORD+HI	; GET TOP HALF
13819   93F4   06 78       		ASL	I+LO	; SHIFT THE TOP 3 BITS OF LOWER HALF
13820   93F6   2A          		ROL	A	; INTO THE BOTTOM OF THE TOP HALF
13821   93F7   06 78       		ASL	I+LO	
13822   93F9   2A          		ROL	A		
13823   93FA   06 78       		ASL	I+LO	
13824   93FC   2A          		ROL	A		
13825   93FD   4C 0E 94    		JMP	GTEXIT	
13826   9400   A9 00       	GETZ2:	LDA	#0	; SET FLAG TO INDICATE
13827   9402   85 9A       		STA	ZFLAG	; END OF TRIPLET
13828   9404   A5 9C       		LDA	ZWORD+HI	; TEST TOP HALF OF TRIPLET
13829   9406   10 04       		BPL	GETZ3	; CONTINUE IF NOT END OF STRING
13830   9408   A9 FF       		LDA	#$FF	; ELSE
13831   940A   85 9A       		STA	ZFLAG	; INDICATE LAST TRIPLET IN STRING
13832   940C   A5 9B       	GETZ3:	LDA	ZWORD+LO	; GET BOTTOM HALF OF TRIPLET
13833   940E   29 1F       	GTEXIT:	AND	#%00011111	; MASK OUT GARBAGE BITS
13834   9410   18          		CLC		
13835   9411   60          		RTS		
13836                      	
13837                      	
13838                      	; ---------------------------------
13839                      	; CONVERT [IN] TO Z-STRING IN [OUT]
13840                      	; ---------------------------------
13841   9412               	CONZST:
13842   9412   A9 05       	        lda	#5	        ; FILL OUTPUT BUFFER
13843   9414   A2 08       		ldx	#8	        ; WITH PAD CHARS ($05)
13844   9416               	CZSL:
13845   9416   9D 99 6C    	        sta	OUT,X	
13846   9419   CA          		dex		
13847   941A   10 FA       		bpl	CZSL	
13848                      	
13849   941C   A9 09       		lda	#9	        ; INIT
13850   941E   85 9D       		sta	CONCNT	        ; CHAR COUNT
13851   9420   A9 00       		lda	#0	        ; CLEAR
13852   9422   85 9E       		sta	CONIN	        ; SOURCE AND
13853   9424   85 9F       		sta	CONOUT	        ; OUTPUT INDEXES
13854   9426               	CONTOP:
13855   9426   A6 9E       	        ldx	CONIN	        ; fetch source index
13856   9428   E6 9E       		inc	CONIN	        ; and update
13857   942A   BD 90 6C    		lda	IN,X	        ; grab an ascii char
13858   942D   85 98       		sta	ZCHAR	        ; save it here
13859   942F   D0 04       		bne	NEXTZ	        ; continue if char was nz
13860   9431   A9 05       		lda	#5	        ; else ship out
13861   9433   D0 27       		bne	CSHIP1	        ; a pad char
13862   9435               	NEXTZ:
  Wed May 24 1989 15:00                                                                                                  Page  207

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13863   9435   20 61 94    	        jsr     FINDCHAR        ; find out where it tis
13864   9438   F0 21       	        beq     CSHIP           ; no shift for charset zero
13865   943A   18          		clc		        ; else do a temp-shift
13866   943B   69 03       		adc	#3	        ; 4 = charset 1, 5 = charset 2
13867   943D   20 8F 94    	        jsr     CSTASH          ; save the char in outbuf
13868   9440   C9 05       	        cmp     #5              ; charset 2?
13869   9442   D0 17       	        bne     CSHIP           ; nope
13870   9444   E0 06       	        cpx     #6              ; ascii escape?
13871   9446   D0 13       	        bne     CSHIP           ; nope
13872                      	;
13873                      	; Handle special Ascii escape sequence
13874                      	;
13875   9448   8A          	        txa                     ; get ASCII alert char (#6)        
13876   9449   20 8F 94    	        jsr     CSTASH          ; shove it away
13877                      	;
13878                      	; do 1st half of "direct"
13879                      	;
13880   944C   A5 98       		lda	ZCHAR           ; re-fetch char        
13881   944E   4A          		lsr	A               ; get upper 2 bits in lower 2 bits
13882   944F   4A          		lsr	A
13883   9450   4A          		lsr	A
13884   9451   4A          		lsr	A
13885   9452   4A          		lsr	A
13886   9453   20 8F 94    	        jsr     CSTASH
13887                      	;
13888                      	; SEND 2ND HALF OF "DIRECT"
13889                      	;
13890   9456   A5 98       		lda	ZCHAR	        ; get char yet again
13891   9458   29 1F       		and	#%00011111	; and get lower 5 bits
13892   945A   AA          	        tax                     ; this is where it is expected
13893                      	;
13894                      	; SHIP Z-CHAR TO OUTPUT BUFFER
13895                      	;
13896   945B               	CSHIP:
13897   945B   8A          	        txa                     ; get char
13898   945C               	CSHIP1:
13899   945C   20 8F 94    	        jsr     CSTASH          ; put char away
13900   945F   D0 C5       	        bne     CONTOP          ; do again
13901                      	;
13902                      	; FINDCHAR - look through the charset table for the character.  If found,
13903                      	;       figger out which shift it is.  If not found, return charset 2, 
13904                      	;       character #6.
13905                      	;  Enter:
13906                      	;       [A] = Char we are looking for
13907                      	;  Returns:
13908                      	;       [A] = Charset (0-2)
13909                      	;       [X] = Character # (6-31)
13910                      	;
13911   9461               	FINDCHAR:
13912   9461   A2 00       	        ldx     #0              ; start at first char, first set
13913   9463   A0 4E       	        ldy     #78             ; there are 78 characters
13914   9465               	FNDCL:
13915   9465   DD 8C 1F    	        cmp     CHARSET,X       ; found it?
13916   9468   F0 09       	        beq     FNDCLX          ; yes
13917   946A   E8          	        inx                     ; next char
13918   946B   88          	        dey                     ; count char
13919   946C   D0 F7       	        bne     FNDCL           ; go check next char
13920                      	;
13921                      	; not found in table, use ASCII escape sequence
13922                      	;
13923   946E   A9 02       	        lda     #2              ; escape sequence is char set 2
13924   9470   A2 06       	        ldx     #6              ; character 6
13925   9472   60          	        rts                     ; and done
13926   9473               	FNDCLX:
13927   9473   8A          	        txa                     ; put here for compares/action
13928   9474   A0 00       	        ldy     #0              ; this is char set 0
13929   9476   A2 FA       	        ldx     #$FA            ; what to "subtract" to get +6
13930   9478   C9 1A       	        cmp     #26             ; how we doin'?
13931   947A   90 0A       	        bcc     FNDCHX          ; all done
13932   947C   C8          	        iny                     ; char set 1
13933   947D   A2 14       	        ldx     #20             ; char set 1 offset
13934   947F   C9 34       	        cmp     #52             ; well?
13935   9481   90 03       	        bcc    FNDCHX           ; must be char set 1
13936   9483   A2 2E       	        ldx     #46             ; for char set 2 setting up
13937   9485   C8          	        iny                     ; must be char set 2 then
  Wed May 24 1989 15:00                                                                                                  Page  208

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13938   9486               	FNDCHX:
13939   9486   8E 8B 94    	        stx     FNDCHM+1        ; what to subtract to get offset
13940   9489   38          	        sec                     ; doing subtract
13941   948A   E9 06       	FNDCHM: sbc     #6              ; make good offset
13942   948C   AA          	        tax                     ; put here for return
13943   948D   98          	        tya                     ; and here to set flag
13944   948E   60          	        rts
13945                      	;
13946                      	; CSTASH - put the char in OUT.  If we run out of room don't return, just
13947                      	;       jump to ZCRUSH as final destination
13948                      	;   [A] - char to be put away
13949                      	;
13950   948F               	CSTASH:
13951   948F   A4 9F       		ldy	CONOUT	        ; fetch output index
13952   9491   99 99 6C    		sta	OUT,Y	        ; send the shift char
13953   9494   E6 9F       		inc	CONOUT	        ; update index
13954   9496   C6 9D       		dec	CONCNT	        ; and char count
13955   9498   D0 05       		bne	CSTX            ; plenty more room
13956   949A   68          	        pla                     ; get rid of return spot
13957   949B   68          	        pla                     ; fine
13958   949C   4C A0 94    		jmp	ZCRUSH	        ; if out of room, crush 'em!
13959   949F               	CSTX:
13960   949F   60          	        rts
13961                      	; ----------------------
13962                      	; CRUSH Z-CHARS IN [OUT], mushing them into small 5 bit pieces
13963                      	; ----------------------
13964   94A0               	ZCRUSH:
13965   94A0   AD 9A 6C    	        LDA	OUT+1	        ; GET 2ND Z-CHAR
13966   94A3   0A          		ASL	A	        ; SHIFT BITS INTO POSITION
13967   94A4   0A          		ASL	A		
13968   94A5   0A          		ASL	A		
13969   94A6   0A          		ASL	A		
13970   94A7   2E 99 6C    		ROL	OUT	        ; ALONG WITH 1ST Z-CHAR
13971   94AA   0A          		ASL	A		
13972   94AB   2E 99 6C    		ROL	OUT	
13973   94AE   0D 9B 6C    		ORA	OUT+2	        ; SUPERIMPOSE 3RD Z-CHAR
13974   94B1   8D 9A 6C    		STA	OUT+1	
13975   94B4   AD 9D 6C    		LDA	OUT+4	        ; GET 5TH Z-CHAR
13976   94B7   0A          		ASL	A	        ; SHIFT BITS
13977   94B8   0A          		ASL	A		
13978   94B9   0A          		ASL	A		
13979   94BA   0A          		ASL	A		
13980   94BB   2E 9C 6C    		ROL	OUT+3	        ; ALONG WITH 4TH Z-CHAR
13981   94BE   0A          		ASL	A		
13982   94BF   2E 9C 6C    		ROL	OUT+3	
13983   94C2   0D 9E 6C    		ORA	OUT+5	        ; SUPERIMPOSE 6TH Z-CHAR
13984   94C5   AA          		TAX		        ; SAVE HERE
13985   94C6   AD 9C 6C    		LDA	OUT+3	        ; GRAB 4TH Z-CHAR
13986   94C9   8D 9B 6C    		STA	OUT+2	        ; MOVE CRUSHED Z-WORD
13987   94CC   8E 9C 6C    		STX	OUT+3	        ; INTO PLACE
13988   94CF   AD A0 6C    		LDA	OUT+7	        ; GET 8TH Z-CHAR (EZIP)
13989   94D2   0A          		ASL	A	        ; SHIFT BITS
13990   94D3   0A          		ASL	A		
13991   94D4   0A          		ASL	A		
13992   94D5   0A          		ASL	A		
13993   94D6   2E 9F 6C    		ROL	OUT+6	        ; ALONG WITH 7TH Z-CHAR
13994   94D9   0A          		ASL	A		
13995   94DA   2E 9F 6C    		ROL	OUT+6	
13996   94DD   0D A1 6C    		ORA	OUT+8	        ; SUPERIMPOSE 9TH Z-CHAR
13997   94E0   8D 9E 6C    		STA	OUT+5	        ; SAVE HERE
13998   94E3   AD 9F 6C    		LDA	OUT+6	        ; GRAB 7TH Z-CHAR
13999   94E6   09 80       		ORA	#%10000000	; SET HIGH BIT
14000   94E8   8D 9D 6C    		STA	OUT+4	        ; MOVE CRUSHED Z-WORD INTO PLACE
14001   94EB   60          		RTS		
14002                      	
14003   94EC               		END
14004                      	
14005   94EC               		INCLUDE 	OBJECTS.ASM
14006   94EC               		STTL "--- OBJECT & PROPERTY HANDLERS ---"
14007                      		PAGE	
  Wed May 24 1989 15:00                                                                                                  Page  209

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- OBJECT & PROPERTY HANDLERS ---"

14008                      	
14009                      	; ----------------------------------
14010                      	; GET ABSOLUTE ADDRESS OF OBJECT [A]
14011                      	; ----------------------------------
14012                      	; ENTER: OBJECT IN A/X (LO/HI)
14013                      	; EXIT: ADDRESS IN [FPC]
14014   94EC               	OBJLOC:
14015   94EC   86 79       		STX	I+HI		; SAVE MSB FOR SHIFTING
14016   94EE   0A          		ASL	A		; MULTIPLY BY LENGTH OF AN ENTRY (14)
14017   94EF   85 78       		STA	I+LO	
14018   94F1   26 79       		ROL	I+HI	
14019   94F3   A6 79       		LDX	I+HI	
14020   94F5   0A          		ASL	A		
14021   94F6   26 79       		ROL	I+HI	; *4
14022   94F8   0A          		ASL	A		
14023   94F9   26 79       		ROL	I+HI	; *8
14024   94FB   0A          		ASL	A		
14025   94FC   26 79       		ROL	I+HI	; *16
14026   94FE   38          		SEC		
14027   94FF   E5 78       		SBC	I+LO	; -(*2)
14028   9501   85 78       		STA	I+LO	; SO IS *14 TOTAL
14029   9503   A5 79       		LDA	I+HI	
14030   9505   86 79       		STX	I+HI	
14031   9507   E5 79       		SBC	I+HI	
14032   9509   85 79       		STA	I+HI	
14033   950B   A5 78       		LDA	I+LO	
14034   950D   18          		CLC		
14035   950E   69 70       		ADC	#112		; ADD OBJECT TABLE OFFSET
14036   9510   90 02       		BCC	OBJ3	
14037   9512   E6 79       		INC	I+HI	
14038   9514               	OBJ3:
14039   9514   18          		clc			; NEXT ADD THE relative ADDR
14040   9515   6D 0B 96    		adc	ZBEGIN+ZOBJEC+1	; OF THE OBJECT TABLE
14041   9518   85 8C       		sta	FPCL		; save lo byte
14042   951A   A5 79       		lda	I+HI	
14043   951C   6D 0A 96    		adc	ZBEGIN+ZOBJEC	; now work on page
14044   951F   20 77 8F    		jsr	SETPC		; now get page/bank
14045   9522   85 8D       		sta	FPCH		; this is hi part
14046   9524   84 8E       		sty	FPCBNK		; and this is the bank
14047   9526   60          		rts
14048                      	; -----------------------------
14049                      	; GET ADDRESS OF PROPERTY TABLE
14050                      	; -----------------------------
14051                      	; EXIT: [FPC] HAS ABSOLUTE ADDR OF PROPERTY TABLE
14052                      	;		including OFFSET TO START OF PROP IDS
14053   9527               	PROPB:
14054   9527   A5 63       		lda	ARG1+LO	
14055   9529   A6 64       		ldx	ARG1+HI	; get address
14056   952B   20 EC 94    		jsr	OBJLOC	; put table location into FPC
14057   952E   A9 0C       		lda	#12	; add 12 to get to beginning
14058   9530   20 DE 8F    		jsr	ADDFPC	; and add it to FPC
14059   9533   20 56 92    		jsr	FETCHB	; get MSB of P-TABLE Address
14060   9536   48          		pha		; and save it for a moment
14061   9537   20 BE 8F    		jsr	NEXTFPC	; to get LSB
14062   953A   20 56 92    		jsr	FETCHB	; get LSB of P-TABLE Address
14063   953D   85 8C       		sta	FPCL	; and save lo part
14064   953F   68          		pla		; get page back
14065   9540   20 77 8F    		jsr	SETPC	; and set up memory bank/page
14066   9543   85 8D       		sta	FPCH	; save page
14067   9545   84 8E       		sty	FPCBNK	; and bank
14068   9547   20 56 92    		jsr	FETCHB	; get length of short description
14069   954A   0A          		asl	A	; WORD-ALIGN IT
14070   954B   20 DE 8F    		jsr	ADDFPC	; and add it to FPC
14071   954E   20 BE 8F    		jsr	NEXTFPC	; POINT JUST PAST THE DESCRIPTION
14072   9551   60          		rts
14073                      	
14074                      	
14075                      	; -------------------
14076                      	; FETCH A PROPERTY ID
14077                      	; -------------------
14078                      	; ENTRY: LIKE "PROPB" EXIT (i.e. - address in FPC)
14079                      	;
14080   9552               	PROPN:
14081   9552   20 56 92    		jsr	FETCHB		; get the byte
14082   9555   29 3F       		and	#%00111111	; MASK OUT LENGTH BITS (EZIP)
  Wed May 24 1989 15:00                                                                                                  Page  210

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- OBJECT & PROPERTY HANDLERS ---"

14083   9557   60          		rts		
14084                      	
14085                      	; -------------------------------
14086                      	; FETCH # BYTES IN PROPERTY VALUE
14087                      	; -------------------------------
14088                      	; ENTRY: LIKE "PROPB" EXIT (i.e. - address in FPC)
14089                      	;
14090   9558               	PROPL:
14091   9558   20 56 92    		jsr	FETCHB		; CHECK LENGTH FLAGS
14092   955B   AA          		tax			; save it
14093   955C   10 09       		bpl	SHORT		; OFF, SO 1 OR 2 BYTES
14094   955E   20 BE 8F    		jsr	NEXTFPC
14095   9561   20 56 92    		jsr	FETCHB		; NEXT BYTE HAS LENGTH
14096   9564   29 3F       		and	#%00111111	; MASK OFF EXTRA BITS
14097   9566   60          		rts		
14098   9567               	SHORT:
14099   9567   29 40       		and	#%01000000	; BIT 6
14100   9569   F0 03       		beq	ONE	
14101   956B   A9 02       		lda	#2		; BIT 6 = 1, LENGTH =2
14102   956D   60          		rts		
14103   956E               	ONE:
14104   956E   A9 01       		lda	#1		; BIT 6 = 0, LENGTH =1
14105   9570   60          		rts		
14106                      	
14107                      	; ----------------------
14108                      	; POINT TO NEXT PROPERTY
14109                      	; ----------------------
14110                      	; ENTRY: LIKE "PROPB" EXIT (i.e. - in [FPC])
14111                      	;
14112   9571               	PROPNX:
14113   9571   20 58 95    		jsr	PROPL	; GET LENGTH OF CURRENT PROP
14114   9574   A8          		tay		; move one more for correct alignment
14115   9575   C8          		iny		; okay, done it
14116   9576   98          		tya		; thanks
14117   9577   20 DE 8F    		jsr	ADDFPC	; add to [FPC]
14118   957A   60          		rts
14119                      	;
14120                      	; ----------------
14121                      	; GET OBJECT FLAGS
14122                      	; ----------------
14123                      	; ENTRY: OBJECT # IN [ARG1], FLAG # IN [ARG2]
14124                      	; EXIT: FLAG WORD IN [K], BIT ID IN [J],
14125                      	; FLAG WORD ADDRESS IN [FPC]
14126                      	;
14127   957B               	FLAGSU:
14128   957B   A5 63       		LDA	ARG1+LO	; get table offset
14129   957D   A6 64       		LDX	ARG1+HI	
14130   957F   20 EC 94    		JSR	OBJLOC	; GET OBJECT ADDR IN [FPC]
14131   9582   A5 65       		LDA	ARG2+LO	; LOOK AT FLAG ID
14132   9584   C9 10       		CMP	#$10	; FIRST SET OF FLAGS?
14133   9586   90 14       		BCC	FLS1	; YES, ADDR IN [FPC] IS CORRECT
14134   9588   E9 10       		SBC	#16	; ELSE ZERO-ALIGN FLAG INDEX
14135   958A   AA          		TAX		; SAVE IT HERE
14136   958B   C9 10       		CMP	#$10	; CHECK IF IN 2ND WORD
14137   958D   90 07       		BCC	FLS	; YES, GO ALIGN FOR THAT
14138   958F   E9 10       		SBC	#16	; ELSE ALIGN TO 3RD WORD
14139   9591   AA          		TAX		
14140   9592   A9 04       		lda	#4	; 3rd Flag word
14141   9594   D0 02       		bne	FLSx	; and add it in
14142   9596               	FLS:
14143   9596   A9 02       		lda	#2	; 2nd Flag word
14144   9598               	FLSx:
14145   9598   20 DE 8F    		jsr	ADDFPC
14146   959B               	FLS0:
14147   959B   8A          		TXA		; RESTORE INDEX
14148   959C               	FLS1:
14149   959C   85 7C       		STA	K+LO	; SAVE FLAG ID HERE
14150   959E   A2 01       		LDX	#1	; INIT THE
14151   95A0   86 7A       		STX	J+LO	; FLAG WORD TO
14152   95A2   CA          		DEX		; $0001
14153   95A3   86 7B       		STX	J+HI	
14154   95A5   A9 0F       		LDA	#15	; SUBTRACT THE BIT POSITION
14155   95A7   38          		SEC		; FROM 15
14156   95A8   E5 7C       		SBC	K+LO	; TO GET THE SHIFT LOOP
14157   95AA   AA          		TAX		; INDEX
  Wed May 24 1989 15:00                                                                                                  Page  211

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- OBJECT & PROPERTY HANDLERS ---"

14158   95AB   F0 07       		BEQ	FLS2	; EXIT NOW IF NO SHIFT NEEDED
14159   95AD   06 7A       	FLSL:	ASL	J+LO	; SHIFT THE BIT
14160   95AF   26 7B       		ROL	J+HI	; INTO POSITION
14161   95B1   CA          		DEX		
14162   95B2   D0 F9       		BNE	FLSL	
14163   95B4               	FLS2:
14164   95B4   20 56 92    		jsr	FETCHB	; MOVE THE FLAG WORD
14165   95B7   85 7D       		sta	K+HI	; INTO [K] - FIRST THE MSB
14166   95B9   20 BE 8F    		jsr	NEXTFPC	; and then get get LSB
14167   95BC   20 56 92    		jsr	FETCHB
14168   95BF   85 7C       		sta	K+LO	; THEN THE LSB
14169   95C1   4C 24 90    		jmp	PREVFPC	; point back to flag word
14170                      	
14171   95C4               		END
14172                      	
14173                      	
14174   95C4               		BLKB	ZBEGIN-$,0
14175   9600               		END



           Lines Assembled :  14175             Assembly Errors :  0


