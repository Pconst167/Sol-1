  Tue Jun 13 1989 11:42                                                                                                  Page    1

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- OBJECT & PROPERTY HANDLERS ---"




               2500 A.D. 6502 Macro Assembler  -  Version 4.01a
               ------------------------------------------------

                       Input  Filename : YZIP.asm
                       Output Filename : YZIP.obj


    1                      		; --------------------------
    2                      		; YZIP
    3                      		; Z-CODE INTERPRETER PROGRAM
    4                      		; FOR APPLE ][e/][c/][gs
    5                      		; --------------------------
    6                      	
    7                      		; INFOCOM, INC.
    8                      		; 125 CAMBRIDGEPARK DRIVE
    9                      		; CAMBRIDGE, MA 02140
   10                      	
   11                      		; COMPANY PRIVATE -- NOT FOR DISTRIBUTION
   12                      	
   13                      		PL	50000		; PAGE LENGTH OF PRINTER
   14                      	
   15          0000        	DEBUG	EQU	0	; ASSEMBLY FLAG FOR DEBUGGER (1 = YES)
   16          0000        	CHECKSUM EQU 	0	; == 1 for generating save/restore checksum
   17                      	
   18                      	 	; -----------
   19                      		; ERROR CODES
   20                      		; -----------
   21                      	
   22                      		; 00 -- INSUFFICIENT RAM
   23                      		; 01 -- ILLEGAL X-OP
   24                      		; 02 -- ILLEGAL 0-OP
   25                      		; 03 -- ILLEGAL 1-OP
   26                      		; 04 -- ILLEGAL 2-OP
   27                      		; 05 -- Z-STACK UNDERFLOW
   28                      		; 06 -- Z-STACK OVERFLOW
   29                      		; 07 -- ILLEGAL PROPERTY LENGTH (GETP)
   30                      		; 08 -- DIVISION BY ZERO
   31                      		; 09 -- ILLEGAL ARGUMENT COUNT (EQUAL?)
   32                      		; 10 -- ILLEGAL PROPERTY ID (PUTP)
   33                      		; 11 -- ILLEGAL PROPERTY LENGTH (PUTP)
   34                      		; 12 -- DISK ADDRESS OUT OF RANGE
   35                      		; 13 -- IMPURE CODE TOO LARGE (BM 1/20/86)
   36                      		; 14 -- DRIVE ACCESS
   37                      		; 15 -- NOT AN EZIP GAME
   38                      		; 16 -- ILLEGAL EXTENDED RANGE X-OP
   39                      		; 17 -- BAD VIRTUAL PAGE
   40                      		; 18 -- SETPC NOT PRELOADED
   41                      		; 19 -- PREVIOUS (SPC/FPC) NOT POSSIBLE
   42                      		; 20 -- PICTURE NOT FOUND
   43                      	        ; 21 -- ZERO OBJECT TO BE REMOVED
   44                      		; 22 -- OBJECT TOO BIG (ZLOC)
   45                      		; 23 -- Bad read: Read != Asked for
   46                      		; 24 -- Bad read: Retry 1 != Retry 2
   47                      		; 25 -- Clear of zero height/width window
   48   0000               		
   49   0000               		TITLE	"APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
   50   0000               		INCLUDE 	ZIP.EQU
   51   0000               		STTL	"--- YZIP EQUATES ---"
   52                      		PAGE 
  Tue Jun 13 1989 11:42                                                                                                  Page    2

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- YZIP EQUATES ---"

   53                      	
   54          000F        	VERSID	EQU	15	; VERSION OF INTERPRETER
   55                      				; See file "versions" for complete descriptions
   56                      	
   57          00FF        	TRUE	EQU	$FF	
   58          0000        	FALSE	EQU	0	
   59                      	
   60                      	; ---------------------
   61                      	; Segment table equates
   62                      	; ---------------------
   63          0000        	SGTDISKS EQU	0		; number of disks
   64          0002        	SGTPAD	EQU	SGTDISKS+2	; just some extra room
   65          0012        	SGTCHKS1 EQU	SGTPAD+16	; Checksum for disk 1 (PRELOAD)
   66          0014        	SGTPICOF1 EQU	SGTCHKS1+2	; N/A
   67          0016        	SGTSEG1 EQU	SGTPICOF1+2	; # of segments
   68          0018        	SGTGPOF1 EQU    SGTSEG1+2       ; Global Picture Directory
   69          001A        	SGTTBLS	EQU	SGTGPOF1+2	; Start of table preload (should be 0)
   70          001C        	SGTTBLE	EQU	SGTTBLS+2	; Last page of table preload
   71          001E        	SGTTBLX	EQU	SGTTBLE+2	; N/A
   72          0020        	SGTFUNS	EQU	SGTTBLX+2	; First page of function preload
   73          0022        	SGTFUNE	EQU	SGTFUNS+2	; End page of function preload
   74          0024        	SGTFUNX	EQU	SGTFUNE+2	; N/A
   75          0026        	SGTDSK	EQU	SGTFUNX+2	; Actual start of disk segment tables
   76                      	
   77          0000        	SGTCHKS EQU	0	; check sum for file
   78          0002        	SGTPICOF EQU	2	; picture data offset
   79          0004        	SGTNSEG	EQU	4	; # of segments in this list
   80          0006        	SGTGPOF EQU     6       ; Global Directory Offset 
   81          0008        	SGTSEG	EQU	8	; start of segments
   82                      	; ---------------------
   83                      	; Z-CODE HEADER OFFSETS
   84                      	; ---------------------
   85                      	
   86          0000        	ZVERS	EQU	0	; VERSION BYTE
   87          0001        	ZMODE	EQU	1	; MODE SELECT BYTE
   88          0002        	ZID	EQU	2	; GAME ID WORD
   89          0004        	ZENDLD	EQU	4	; # OF QUADWORDS ON SIDE 1 OF DISK
   90          0006        	ZGO	EQU	6	; EXECUTION ADDRESS
   91          0008        	ZVOCAB	EQU	8	; START OF VOCABULARY TABLE
   92          000A        	ZOBJEC	EQU	10	; START OF OBJECT TABLE
   93          000C        	ZGLOBAL	EQU	12	; START OF GLOBAL VARIABLE TABLE
   94          000E        	ZPURBT	EQU	14	; START OF "PURE" Z-CODE
   95          0010        	ZFLAGS	EQU	16	; FLAG WORD
   96          0012        	ZSERIA	EQU	18	; 3-WORD SERIAL NUMBER
   97          0018        	ZFWORD	EQU	24	; START OF FWORDS TABLE
   98          001A        	ZLENTH	EQU	26	; LENGTH OF Z-PROGRAM IN WORDS
   99          001C        	ZCHKSM	EQU	28	; Z-CODE CHECKSUM WORD
  100          001E        	ZINTWD	EQU	30	; INTERPRETER ID WORD (SUPPLIED BY EZIP)
  101          0020        	ZSCRWD	EQU	32	; SCREEN PARAMETER WORD ( "     "   "  )
  102          0022        	ZHWRD	EQU	34	; DISPLAY WIDTH IN PIXELS
  103          0024        	ZVWRD	EQU	36	; DISPLAY HEIGHT IN PIXELS
  104          0026        	ZFWRD	EQU	38	; FONT HEIGHT, FONT WIDTH
  105          0028        	ZFOFF	EQU	40	; FUNCTION OFFSET
  106          002A        	ZSOFF	EQU	42	; STRING OFFSET
  107          002C        	ZCLRWD	EQU	44	; FORGROUND COLOR, BACKGROUND COLOR
  108          002E        	ZTCHAR	EQU	46	; POINTER TO TBL OF TERMINATING CHARS
  109          0030        	ZTWIDTH	EQU	48	; Running counter for table output char width
  110          0032        	ZCRFUNC	EQU	50	; FUNCTION FOR CARRIAGE RETURNS
  111          0034        	ZCHRSET	EQU	52	; POINTER TO CHAR SET TBL
  112          0036        	ZEXTAB	EQU	54	; Points to extension table, if needed
  113                      	;
  114                      	; Extension table offsets
  115                      	;
  116          0000        	ZEXTLEN	EQU	0	; Length of extension table
  117          0002        	ZMSLOCX	EQU	2	; x location of mouse
  118          0004        	ZMSLOCY	EQU	4	; y location of mouse
  119          0006        	ZMSETBL	EQU	6	; MOUSE TBL CHANGE WORD
  120          0008        	ZMSEDIR	EQU	8	; DIRECTION MENU
  121          000A        	ZMSEINV	EQU	10	; INVENTORY MENU
  122          000C        	ZMSEVRB	EQU	12	; FREQUENT VERB MENU
  123          000E        	ZMSEWRD	EQU	14	; FREQUENT WORD MENU
  124          0010        	ZBUTTN	EQU	16	; BUTTON HANDLER
  125          0012        	ZJOYST	EQU	18	; JOYSTICK HANDLER
  126          0014        	ZBSTAT	EQU	20	; BUTTON STATUS
  127          0016        	ZJSTAT	EQU	22	; JOYSTICK STATUS
  Tue Jun 13 1989 11:42                                                                                                  Page    3

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- YZIP EQUATES ---"

  128                      	;
  129                      	; ZFLAGS values
  130                      	;
  131          0001        	FSCRI	EQU	$01	; scripting?
  132          0002        	FMONO	EQU	$02	; mono spaced font?
  133          0004        	FSTAT	EQU	$04	; status line refresh?
  134          0008        	FDISP	EQU	$08	; uses DISPLAY operations?
  135          0010        	FUNDO	EQU	$10	; uses UNDO?
  136          0020        	FMOUS	EQU	$20	; uses mouse?
  137          0040        	FCOLO	EQU	$40	; uses color?
  138          0080        	FMENU	EQU	$80	; uses menus?
  139                      	;---------------
  140                      	; Picture data
  141                      	;---------------
  142                      	;=== DATA HEADER ===
  143          0000        	PHFID	EQU	0		; File ID
  144          0001        	PHFLG	EQU	PHFID+1		; Flags
  145          0002        	PHHUFF	EQU	PHFLG+1		; Pointer to Huffman data
  146          0004        	PHNLD	EQU	PHHUFF+2	; # entries in local directory
  147          0006        	PHNGD	EQU	PHNLD+2		; # entries in global directory
  148          0008        	PHDSIZE	EQU	PHNGD+2		; Local directory entry size
  149          000A        	PHCHKS	EQU	PHDSIZE+2	; File Checksum
  150          000C        	PHFVERS	EQU	PHCHKS+2	; File Version (N/A)
  151          000E        	PHEXTRA	EQU	PHFVERS+2	; Extra room for getting fatter
  152          0010        	PHSIZE	EQU	16		; 16 bytes is header size
  153                      	;=== DATA HEADER FLAGS ===
  154          0001        	PHFGD	EQU	$1		; data has global directory
  155          0002        	PHFHUFF	EQU	$2		; Huffman encoded pictures
  156          0004        	PHFHUFF1 EQU	$4		; All pictures use same Huff tree
  157          0008        	PHFPAL	EQU	$8		; No pallette information
  158                      	;=== LOCAL DIRECTORY ===
  159          0000        	PLDID	EQU	0		; Picture ID
  160          0002        	PLDWID	EQU	PLDID+2		; Picture Width
  161          0003        	PLDHGHT	EQU	PLDWID+1	; Picture Height
  162          0004        	PLDFLG	EQU	PLDHGHT+1	; Flags
  163          0005        	PLDPTR	EQU	PLDFLG+1	; Pointer to picture data
  164          0008        	PLDSIZE	EQU	PLDPTR+3	; size of local directory entry
  165                      	
  166   0000               		END
  167                      	
  168   0000               		INCLUDE		ZERO.EQU
  169   0000               		STTL	"--- ZERO PAGE VARIABLES ---"
  170                      		PAGE 
  Tue Jun 13 1989 11:42                                                                                                  Page    4

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- ZERO PAGE VARIABLES ---"

  171                      	
  172          0000        	SCRCX	EQU	0		; CURSOR HORIZONTAL
  173          0001        	SCRCY	EQU	SCRCX+1		; CURSOR VERTICAL
  174          0002        	SCRBTM	EQU	SCRCY+1		; first line outside current window
  175          0003        	MAXLINES EQU	SCRBTM+1	; maximum number of lines in window
  176          0004        	LEFTMRG	EQU	MAXLINES+1	; left edge + left margin in current window
  177          0005        	WINDOW	EQU	LEFTMRG+1	; (WORD) address of current window structure
  178          0007        	LINE_X  EQU     WINDOW+2        ; (WORD) width of line counter
  179          0009        	CC_OFF  EQU     LINE_X+2        ; save offset for char drawing
  180          000A        	CLSLEFT	EQU	CC_OFF+1	; screen limits for CLS code
  181          000B        	CLSTOP	EQU	CLSLEFT+1	; top of screen
  182          000C        	CLSWIDTH EQU	CLSTOP+1	; # of columns 
  183          000D        	CLSHEIGHT EQU	CLSWIDTH+1	; # of lines
  184                      	;
  185                      	; some variables for all the screen positioning code
  186                      	;
  187          000E        	NY_DATA	EQU	CLSHEIGHT+1	; place for GET/PUT_NYBBLE to use
  188          000F        	CH_OFFSET EQU	NY_DATA+1	; offset into char data table
  189          0010        	DATALOOP EQU	CH_OFFSET+1 	; loop counter for byte works
  190          0011        	BITOFF	EQU	DATALOOP+1	; bit offset into screen byte
  191          0012        	CH_DATA	EQU	BITOFF+1	; actual char data being worked on
  192          0013        	SCR_DATA EQU	CH_DATA+1	; screen byte being worked on
  193          0014        	SH_LOOP	EQU	SCR_DATA+1	; loop counter for bit shifting
  194          0015        	SCROLLY	EQU	SH_LOOP+1	; save spot for y pos when scrolling
  195          0016        	RETRIES EQU	SCROLLY+1	; (BYTE) Machine ID
  196          0017        	CHRMAX	EQU	RETRIES+1	; (BYTE) # CHARS CAN INPUT FROM KEYBOARD
  197          0018        	SCLLINES EQU	CHRMAX+1	; (BYTE) how many lines to scroll
  198          0019        	FMTTBL	EQU	SCLLINES+1	; (BYTE) flag to show formatted table output
  199          001A        	STMASK	EQU	FMTTBL+1	; (BYTE) Mask to use on first byte of CLS
  200          001B        	ENDMASK	EQU	STMASK+1	; (BYTE) Mask to use on last byte of CLS
  201          001C        	CHPTR	EQU	ENDMASK+1	; (WORD) pointer to char data
  202          001C        	SCOFF	EQU	CHPTR		;(BYTE) Offset used by scroll
  203          001D        	SCLDIR	EQU	CHPTR+1		;(BYTE) Direction of scroll - >0 up, <0 down
  204          001E        	DSEGS	EQU	CHPTR+2 	; (WORD) Pointer to current disk's segments
  205                      	;WIDE_FLAG EQU   SCOFF+1         ; (BYTE) <> 0 if 16 bytes in char data
  206                      	;DSEGS	EQU	WIDE_FLAG+1	; (WORD) Pointer to current disk's segments
  207          0020        	LASTWV	EQU	DSEGS+2		; last of the WINDOW variables
  208                      	
  209          0050        	ZEROPG	EQU	$50		; FIRST FREE Z-PAGE LOCATION
  210                      	;
  211                      	; these are first, cuz ZBOOT inits them so we don't want to clear them
  212                      	; at ZBEGIN warm start
  213                      	;
  214          0050        	GLOBAL	EQU	ZEROPG		; (Relative Addr.) GLOBAL VARIABLE POINTER
  215          0052        	VOCAB	EQU	GLOBAL+2	; (ADDRESS) Vocab table pointer
  216          0055        	FWORDS	EQU	VOCAB+3		; (ADDRESS) F-WORDS TABLE POINTER
  217          0058        	MOUSEF	EQU	FWORDS+3	; (BYTE) ==-1/1 if we have mouse/joystick
  218          0059        	INFODOS EQU     MOUSEF+1        ; (WORD) if <>0, then pointer to D2SEG
  219          005B        	FUNOFF	EQU	INFODOS+2	; (ADDRESS) Function Offset (ZFOFF*8)
  220          005B        	FOFFH	EQU	FUNOFF		; (BYTE) Hi part 
  221          005C        	FOFFM	EQU	FUNOFF+1	; (BYTE) Middle part
  222          005D        	FOFFL	EQU	FUNOFF+2	; (BYTE) Lo part
  223          005E        	STROFF	EQU	FUNOFF+3	; (ADDRESS) String Offset (ZSOFF*8)
  224          005E        	SOFFH	EQU	STROFF		; (BYTE) Hi part 
  225          005F        	SOFFM	EQU	STROFF+1	; (BYTE) Middle part
  226          0060        	SOFFL	EQU	STROFF+2	; (BYTE) Lo part
  227                      	;
  228                      	; Beginning of warm start zeroing
  229                      	;
  230          0061        	OPCODE	EQU	STROFF+3	; (BYTE) CURRENT OPCODE
  231          0062        	NARGS	EQU	OPCODE+1	; (BYTE) # ARGUMENTS
  232          0063        	ARG1	EQU	OPCODE+2	; (WORD) ARGUMENT #1
  233          0065        	ARG2	EQU	OPCODE+4	; (WORD) ARGUMENT #2
  234          0067        	ARG3	EQU	OPCODE+6	; (WORD) ARGUMENT #3
  235          0069        	ARG4	EQU	OPCODE+8	; (WORD) ARGUMENT #4
  236          006B        	ARG5	EQU	OPCODE+10	; (WORD)
  237          006D        	ARG6	EQU	OPCODE+12	; (WORD)
  238          006F        	ARG7	EQU	OPCODE+14	; (WORD)
  239          0071        	ARG8	EQU	OPCODE+16	; (WORD)
  240          0073        	ABYTE	EQU	OPCODE+18	; (BYTE) X-OP ARGUMENT BYTE
  241          0074        	BBYTE	EQU	OPCODE+19	; (BYTE) XCALL ARG BYTE (EZIP)
  242          0075        	ADEX	EQU	OPCODE+20	; (BYTE) X-OP ARGUMENT INDEX
  243          0076        	VALUE	EQU	OPCODE+21	; (WORD) VALUE RETURN REGISTER
  244          0078        	I	EQU	VALUE+2		; (WORD) GEN-PURPOSE REGISTER #1
  245          007A        	J	EQU	VALUE+4		; (WORD) GEN-PURPOSE REGISTER #2
  Tue Jun 13 1989 11:42                                                                                                  Page    5

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- ZERO PAGE VARIABLES ---"

  246          007C        	K	EQU	VALUE+6		; (WORD) GEN-PURPOSE REGISTER #3
  247          007E        	L	EQU	VALUE+8		; (WORD) GEN-PURPOSE REGISTER #4
  248          0080        	ZPC	EQU	VALUE+10	; (3 BYTES) ZIP PROGRAM COUNTER
  249          0080        	ZPCL	EQU	ZPC		; (BYTE) <8 BITS OF [ZPC]
  250          0081        	ZPCM	EQU	ZPC+1		; (BYTE) MIDDLE 8 BITS OF [ZPC]
  251          0082        	ZPCH	EQU	ZPC+2		; (BYTE) >BIT OF [ZPC]
  252          0083        	ZPCPNT	EQU	ZPC+3		; (3 BYTES) ABS POINTER TO CURRENT Z-PAGE
  253          0083        	ZPNTL	EQU	ZPCPNT		; FIRST 2 BYTES = SAME AS FOR ZIP (EZIP)
  254          0084        	ZPNTH	EQU	ZPCPNT+1	; (BYTE)
  255          0085        	ZPCBNK	EQU	ZPCPNT+2	; (BYTE) INDICATES AUXILIARY MEMORY
  256          0086        	MPC	EQU	ZPCPNT+3	; (3 BYTES) MEMORY PROGRAM COUNTER
  257          0086        	MPCL	EQU	MPC		; (BYTE) <8 BITS OF [MPC]
  258          0087        	MPCM	EQU	MPC+1		; (BYTE) MIDDLE 8 BITS OF [MPC]
  259          0088        	MPCH	EQU	MPC+2		; (BYTE) >BIT OF [MPC]
  260          0089        	MPCPNT	EQU	MPC+3		; (3 BYTES) ABS POINTER TO CURRENT M-PAGE
  261          0089        	MPNTL	EQU	MPCPNT		; FIRST 2 BYTES = SAME AS FOR ZIP (EZIP)
  262          008A        	MPNTH	EQU	MPCPNT+1	; (BYTE)
  263          008B        	MPCBNK	EQU	MPCPNT+2	; (BYTE) INDICATES AUXILIARY MEMORY
  264          008C        	FPC	EQU	MPCBNK+1	; (3 Bytes) Fetch pointer 
  265          008C        	FPCL	EQU	FPC		; (BYTE) Low part
  266          008D        	FPCH	EQU	FPCL+1		; (BYTE) High Part
  267          008E        	FPCBNK	EQU	FPCH+1		; (BYTE) Bank part (0-Main, 1-Aux)
  268          008F        	SPC	EQU	FPCBNK+1	; (3 Bytes) Fetch pointer 
  269          008F        	SPCL	EQU	SPC		; (BYTE) Low part
  270          0090        	SPCH	EQU	SPCL+1		; (BYTE) High Part
  271          0091        	SPCBNK	EQU	SPCH+1		; (BYTE) Bank part (0-Main, 1-Aux)
  272                      	
  273                      	; Z-STRING MANIPULATION VARIABLES
  274                      	
  275          0092        	LINLEN	EQU	SPCBNK+1	; (BYTE) LENGTH OF CURRENT LINE
  276          0093        	SOURCE	EQU	LINLEN+1	; (BYTE) counter for read
  277          0094        	WRDLEN	EQU	SOURCE+1	; (BYTE) LENGTH OF CURRENT WORD
  278          0095        	ESIZE	EQU	WRDLEN+1	; (BYTE) SIZE OF VOCAB TABLE ENTRIES
  279          0096        	PSET	EQU	ESIZE+1		; (BYTE) PERMANENT CHARSET
  280          0097        	TSET	EQU	PSET+1		; (BYTE) TEMPORARY CHARSET
  281          0098        	ZCHAR	EQU	TSET+1		; (BYTE) CURRENT Z-CHAR
  282          0099        	OFFSET	EQU	ZCHAR+1		; (BYTE) F-WORD TABLE OFFSET
  283          009A        	ZFLAG	EQU	OFFSET+1	; (BYTE) Z-WORD ACCESS FLAG
  284          009B        	ZWORD	EQU	ZFLAG+1		; (WORD) CURRENT Z-WORD
  285          009D        	CONCNT	EQU	ZWORD+2		; (BYTE) Z-STRING SOURCE COUNTER
  286          009E        	CONIN	EQU	CONCNT+1	; (BYTE) CONVERSION SOURCE INDEX
  287          009F        	CONOUT	EQU	CONIN+1		; (BYTE) CONVERSION DEST INDEX
  288          00A0        	DIRTBL	EQU	CONOUT+1	; (WORD) CONTAINS TBLE TO STORE CHARS TO
  289          00A2        	XSIZE	EQU	DIRTBL+2	; (WORD) SCREEN WIDTH FOR TESTS
  290          00A4        	RAND    EQU     XSIZE+2         ; (WORD) Random number offset
  291          00A6        	CURWIN	EQU	RAND+2		; (BYTE) WHICH WINDOW TO WRITE IN
  292          00A7        	LENGTH	EQU	CURWIN+1	; (WORD) CHAR POSITION ON THE SCREEN
  293          00A9        	CHRCNT	EQU	LENGTH+2	; (BYTE) CHAR POSITION IN [LBUFF]
  294          00AA        	SCRIPT	EQU	CHRCNT+1	; (BYTE) SCRIPT ENABLE FLAG
  295          00AB        	LINCNT	EQU	SCRIPT+1	; (BYTE) LINE COUNTER
  296          00AC        	IOCHAR	EQU	LINCNT+1	; (BYTE) CHARACTER BUFFER
  297          00AD        	COLORP	EQU	IOCHAR+1	; (WORD) Pointer to current background color
  298          00AF        	ZSP	EQU	COLORP+2	; (WORD) Z Stack
  299          00B1        	SCREENF	EQU	ZSP+2		; (BYTE) DIROUT FLAG FOR SCREEN OUTPUT
  300          00B2        	TABLEF	EQU	SCREENF+1	; (BYTE) DIROUT FLAG FOR TABLE OUTPUT
  301          00B3        	VOCEND	EQU	TABLEF+1	; (3 BYTES) HOLDS MPC IN VOCAB SEARCH
  302          00B6        	DBUFF	EQU	VOCEND+3	; (WORD) RAM PG TO ACCESS (LSB = 0)
  303          00B8        	DSKBNK	EQU	DBUFF+2		; (BYTE) MAIN/AUX bank
  304          00B9        	ALLFLG	EQU	DSKBNK+1	; (BYTE) IF =1 ALL FCN KEYS (>127) ARE TCHARS
  305          00BA        	UNDFLG	EQU	ALLFLG+1	; (BYTE) Underlining flag
  306          00BB        	INVFLG	EQU	UNDFLG+1	; (BYTE) Inverse flag
  307          00BC        	MEMPAGE	EQU	INVFLG+1	; (BYTE) Save spot for XPAGING stuff
  308          00BD        	CPY_COUNT EQU	MEMPAGE+1	; (BYTE) Number of bytes for copy line
  309          00BE        	TBLHEIGHT EQU	CPY_COUNT+1	;(BYTE) Number of lines in printing table
  310          00BF        	TBLWIDTH EQU	TBLHEIGHT+1	;(BYTE) Number of bytes per line
  311          00C0        	TBLCNT	EQU	TBLWIDTH+1	;(BYTE) Counter for table printing
  312          00C1        	FONTFLG	EQU	TBLCNT+1	;(BYTE) Which font (!=0 is width)
  313          00C2        	TBLPUR	EQU	FONTFLG+1	;(BYTE) first pure table page
  314          00C3        	FUNPRE	EQU	TBLPUR+1	;(BYTE) first preloaded function page
  315          00C4        	FUNPUR	EQU	FUNPRE+1	;(BYTE)	first pure function page
  316          00C5        	FUNPGE	EQU	FUNPUR+1	;(BYTE) -number to get function preload page
  317          00C6        	DELAY_COUNTER EQU FUNPGE+1	;(BYTE) counter for delay loop
  318                      	;
  319                      	; some char-to-screen variables
  320                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page    6

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- ZERO PAGE VARIABLES ---"

  321          00C7        	CHAR_D1	EQU	DELAY_COUNTER+1	; (BYTE) character data, part 1
  322          00C8        	CHAR_D2	EQU	CHAR_D1+1	; (BYTE) char data, part 2
  323          00C9        	CW	EQU	CHAR_D2+1	; (BYTE) width of the character
  324          00CA        	CLKCTR	EQU	CW+1		; (BYTE) counter for mouse clicking
  325          00CB        	MSX	EQU	CLKCTR+1	; (BYTE) mouse cursor X
  326          00CC        	MSY	EQU	MSX+1		; (BYTE) mouse cursor Y
  327          00CD        	CURRENT	EQU	MSY+1		; (BYTE) current paging bufer
  328                      	;CURSOR_OFF EQU  CURRENT+1       ; (BYTE) ==1 if "don't show the blinking cursor"
  329          00CE        	MSTBL	EQU	CURRENT+1	; (ADDRESS) pointer to extension table
  330          00D1        	LASTZP	EQU	MSTBL+3		; just checking
  331                      	;
  332                      	; these routines are in non-swapped memory
  333                      	;
  334          00D1        	ZERO_FB	EQU	LASTZP		; put fetch byte routine in at end of ZP
  335          00DC        	ZERO_ZF	EQU	ZERO_FB+11	; and ZPCPNT fetch after that
  336          00E5        	ZERO_MF	EQU	ZERO_ZF+9	; and MPCPNT fetch after that
  337          00EE        	SAVE_DATA EQU	ZERO_MF+9	; copy data from DBUFF to IOBUFF routine
  338                      	;
  339                      	; and just to check the end
  340                      	;
  341          00FF        	ZEE_END EQU	SAVE_DATA+17	; should be == 100
  342                      	
  343   0000               		END
  344                      	
  345   0000               		INCLUDE		PRODOS.EQU
  346   0000               		STTL	"--- ProDOS EQUATES ---"
  347                      		PAGE 
  Tue Jun 13 1989 11:42                                                                                                  Page    7

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- ProDOS EQUATES ---"

  348                      	
  349                      	;
  350                      	; some parameter structures
  351                      	;
  352          0000        	OPEN_PARM	EQU	0
  353          0000        	OP_PCOUNT	EQU	OPEN_PARM	; must be 3 for open
  354          0001        	OP_PATHNAME	EQU	OP_PCOUNT+1	; address of pathname
  355          0003        	OP_FILEBUFF	EQU	OP_PATHNAME+2	; address of file data buffer
  356          0005        	OP_REFNUM	EQU	OP_FILEBUFF+2	; file reference number
  357          0006        	OPEN_PSIZE	EQU	OP_REFNUM+1	; size of parameter buffer
  358                      	
  359          0000        	READ_PARM	EQU	0		; to read things
  360          0000        	RD_PCOUNT	EQU	READ_PARM	; param count (=4)
  361          0001        	RD_REFNUM	EQU	RD_PCOUNT+1	; ref num of file
  362          0002        	RD_BUFFER	EQU	RD_REFNUM+1	; where to
  363          0004        	RD_BUFFLEN	EQU	RD_BUFFER+2	; length of buffer
  364          0006        	RD_LENGTH	EQU	RD_BUFFLEN+2	; actual length of read
  365          0008        	READ_PSIZE	EQU	RD_LENGTH+2	; length of parm block
  366                      	
  367          0000        	CLOSE_PARM	EQU	0		; for closing file
  368          0000        	CL_PCOUNT	EQU	CLOSE_PARM	; paramter count (=1)
  369          0001        	CL_REFNUM	EQU	CL_PCOUNT+1	; refnum of file to be closed
  370          0002        	CLOSE_PSIZE	EQU	CL_REFNUM+1	; this is the size, thank you
  371                      	
  372          0000        	WRITE_PARM	EQU	0		; to write things
  373          0000        	WR_PCOUNT	EQU	WRITE_PARM	; parm count (= 4)
  374          0001        	WR_REFNUM	EQU	WR_PCOUNT+1	; file refnum
  375          0002        	WR_BUFFER	EQU	WR_REFNUM+1	; data buffer address
  376          0004        	WR_BUFFLEN	EQU	WR_BUFFER+2	; data buffer length
  377          0006        	WR_LENGTH	EQU	WR_BUFFLEN+2	; actual length written
  378          0008        	WRITE_PSIZE	EQU	WR_LENGTH+2	; length of parm block
  379                      	
  380          0000        	SETMARK_PARM	EQU	0
  381          0000        	SM_PCOUNT	EQU	SETMARK_PARM	; parm count (=2)
  382          0001        	SM_REFNUM	EQU	SM_PCOUNT+1	; file refnum
  383          0002        	SM_FPOS		EQU	SM_REFNUM+1	; 3 byte file pos 
  384          0005        	SETMARK_PSIZE	EQU	SM_FPOS+3	; length of parm block
  385                      	
  386          0000        	SETPREFIX_PARM	EQU	0	
  387          0000        	SP_PCOUNT	EQU	SETPREFIX_PARM	; parm count (=1)
  388          0001        	SP_PATHNAME	EQU	SP_PCOUNT+1	; pointer to path name
  389          0003        	SETPREFIX_PSIZE	EQU	SP_PATHNAME+2	; length of block
  390                      	
  391          0000        	SETEOF_PARM     EQU     0
  392          0000        	SE_PCOUNT       EQU     SETEOF_PARM     ; parm count (=2)
  393          0001        	SE_REFNUM       EQU     SE_PCOUNT+1     ; reference number
  394          0002        	SE_NEWEOF       EQU     SE_REFNUM+1     ; new EOF position
  395          0005        	SETEOF_PSIZE    EQU     SE_NEWEOF+3     ; length of parm block
  396                      	
  397   0000               		END
  398                      	
  399   0000               		INCLUDE 	APPLE.EQU
  400   0000               		STTL "--- APPLE ][ HARDWARE STUFF ---"
  401                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page    8

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- APPLE ][ HARDWARE STUFF ---"

  402                      	; -------------------
  403                      	; APPLE II MEMORY MAP
  404                      	; -------------------
  405          0001        	AUX	EQU	1	; offset to Auxillary mem switches
  406          0000        	MAIN	EQU	0	; for main memory switches
  407                      	
  408                      	;
  409                      	; some hardware spots
  410                      	;
  411          2000        	SCREEN	EQU	$2000		; START OF Double HiRes SCREEN RAM
  412                      	
  413          BF00        	PRGLBL	EQU	$BF00		; ProDOS Globals page in main mem
  414          BF58        	PR_BITMAP EQU	$BF58		; ProDOS system bitmap
  415          BFFF        	KVERSION EQU    $BFFF           ; ProDOS version (== $FF if InfoDOS)
  416          00FF        	INFODOS_ID EQU  $FF
  417                      	
  418          C000        	IOADDR	EQU	$C000		; start of I/O registers
  419          D000        	PROADR	EQU	$D000		; start of ProDOS
  420                      	
  421          0200        	LBUFF	EQU	$0200		; LINE INPUT BUFFER
  422          0273        	PIC1BUF EQU	$0300-141	; we can use line buffer for one picture buffer
  423          0280        	SCRBUFF	EQU	LBUFF+$80	; screen line buffer
  424          2000        	BORG	EQU	$2000		; ORIGIN OF .SYSTEM CODE 
  425                      	;
  426                      	; some page 3 storage relocated stuff
  427                      	;
  428          0300        	PAGE3STUFF EQU	$300
  429          0300        	MOUSER	EQU	PAGE3STUFF	; this is where mouse subroutine goes
  430          0312        	COLORS	EQU	MOUSER+$12
  431          0352        	XPOSTBL	EQU	COLORS+$40
  432                      	
  433          0400        	SV_PCL	EQU	$400		; for scrolling data
  434          0600        	SV_PCH	EQU	$600
  435                      	
  436          0800        	IOBUFF	EQU	$0800		; 1Kb DATA BUFFER BUFFER
  437                      	
  438          0C00        	PAGING_MEM EQU	IOBUFF+$400	; Paging table stuff
  439          0C00        	NEXTPNT	EQU	PAGING_MEM
  440          0C40        	PREVPNT	EQU	NEXTPNT+$40	
  441          0C80        	VPAGEH	EQU	PREVPNT+$40	
  442          0CC0        	VPAGEL	EQU	VPAGEH+$40	
  443          0200        	PAGELEN	EQU	$200		; length of paged read
  444                      	
  445          0D00        	ZSTKBL	EQU	PAGING_MEM+$100	; Z-STACK  BOTTOM,LO  (1K STACK FOR EZIP)
  446          0E00        	ZSTKTL	EQU	ZSTKBL+$100	; TOP, LO
  447          0F00        	ZSTKBH	EQU	ZSTKBL+$200	; BOTTOM, HI
  448          1000        	ZSTKTH	EQU	ZSTKBL+$300	; TOP, HI
  449                      	;
  450                      	; now define some file i/o buffers and such
  451                      	;
  452          1100        	GAME1FIO EQU	ZSTKBL+$400	; Game file I/O buffer
  453          1500        	GAME2FIO EQU	GAME1FIO+$400	; Second game file i/o buffer
  454          1900        	SEGTBL	EQU	GAME2FIO+$400	; segment table for multi disks
  455          1C74        	PIC2BUF	EQU	SEGTBL+($400-140) ; picture buffer is 140 bytes long
  456          1D00        	TCHARTBL EQU	SEGTBL+$400	; 208 bytes for (possible) terminating
  457          1D50        	COPY_LINE EQU   TCHARTBL+$50    ; copy line in screen memory
  458          1D7C        	CPY_MOD1_SRC equ   COPY_LINE+$2C   ; special self-modifying places
  459          1D7F        	CPY_MOD1_DST equ CPY_MOD1_SRC+3
  460          1DA0        	CPY_MOD2_SRC equ   COPY_LINE+$50
  461          1DA3        	CPY_MOD2_DST equ CPY_MOD2_SRC+3
  462                      	
  463          1DD0        	DSKSEG	EQU	TCHARTBL+$D0	; spot to stash pointers for disk segments
  464          1DD0        	D1SEG	EQU	DSKSEG		; where in SEGTBL for Disk 1
  465          1DD2        	D2SEG	EQU	D1SEG+2
  466          1DD4        	D3SEG	EQU	D2SEG+2
  467          1DD6        	D4SEG	EQU	D3SEG+2
  468          1DD8        	D5SEG	EQU	D4SEG+2
  469          1DDA        	D6SEG	EQU	D5SEG+2
  470          1DDC        	D7SEG	EQU	D6SEG+2
  471          1DDE        	D8SEG	EQU	D7SEG+2
  472          1DE0        	LOCAL_SV EQU	TCHARTBL+$E0	; to save locals before restore
  473          1E00        	LOCALS	EQU	TCHARTBL+$100	; LOCAL VARIABLE STORAGE (30 BYTES)
  474          1E20        	BUFSAV	EQU	LOCALS+$20	; TEMP SPACE FOR SAVE/RESTORE (80 BYTES)
  475          1F00        	SCR_LINE EQU	LOCALS+$100	; place to build displayed line
  476          1F8C        	CHARSET EQU     SCR_LINE+140    ; spot for charset to go
  Tue Jun 13 1989 11:42                                                                                                  Page    9

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- APPLE ][ HARDWARE STUFF ---"

  477                      	;
  478                      	; now for some interpreter data
  479                      	;
  480          4000        	INTR_BEGIN EQU	$4000		; START OF Interpreter CODE in main
  481          5600        	INTR_SIZE EQU	(43*512)	; size of interpreter
  482                      	
  483          9600        	ZBEGIN	EQU	(INTR_BEGIN+INTR_SIZE) ; start of Z code
  484          7F00        	MMSIZE	EQU	PRGLBL-INTR_BEGIN ; free memory in main bank
  485          0029        	Z1SIZE	EQU	>(PRGLBL-ZBEGIN) ; size of preload, part 1
  486                      	;
  487                      	; this is in Bank 2, Main mem
  488                      	;
  489                      	;
  490                      	; Picture directory goes in Bank 2, Aux mem
  491                      	;
  492          D000        	PIC_DIR	EQU	$D000		; picture local directory
  493          DC00        	GBL_DIR EQU     $DC00           ; global directory
  494                      	;
  495                      	; some special markers if we are using InfoDOS
  496                      	;
  497          0000        	SP_BANK EQU     MAIN
  498          D000        	SP_START EQU    $D000           ; start of special area
  499          0017        	SP_SIZE EQU     ((($FE->SP_START)*256)/512)     ; how many pages
  500                      	;SP_SIZE EQU     (((>SCREEN->SP_START)*256)/512)     ; how many pages
  501                      	
  502          0001        	PB_BANK EQU     AUX          ; paging buffers in which bank
  503          0800        	PBEGIN	EQU	$0800		; start of paging buffers
  504          0018        	NUMBUFS	EQU	>(SCREEN-PBEGIN) ; how many 256k paging buffers
  505                      	;NUMBUFS	EQU	>($100-PBEGIN) ; how many 256k paging buffers
  506                      	
  507          0029        	P2PAGE	EQU	>(PRGLBL-ZBEGIN) ; first page of zcode in aux bank
  508          4000        	Z2BEGIN	EQU	$4000		; start of part 2 in aux mem
  509                      					; just after the dhires screen
  510          0040        	Z2PAGE	EQU	>Z2BEGIN	; get me just the page address
  511          007F        	Z2SIZE	EQU	>(PRGLBL-Z2BEGIN) ; size of preload, part 2
  512          00A8        	P3PAGE	EQU	Z1SIZE+Z2SIZE	; first page in aux mem part 3
  513          D000        	Z3BEGIN	EQU	$D000		; start of 3 part in aux mem
  514          00D0        	Z3PAGE	EQU	>Z3BEGIN	; get me page number too
  515          002E        	Z3SIZE	EQU	<($FE-Z3PAGE)	; size of part 3, in pages
  516                      	
  517                      	;
  518                      	; other numba's
  519                      	;
  520          00D6        	PGBEGIN	EQU	(P3PAGE+Z3SIZE)	; first paged page
  521          00D6        	PRESIZE EQU	(Z1SIZE+Z2SIZE+Z3SIZE)	; size of preload, # pages
  522          2000        	SCRSZE	EQU	INTR_BEGIN-SCREEN ; size of Double HiRes screen (8k, each bank)
  523          EE00        	RAMDSK	EQU	(119*512)	; size of RAM disk in aux mem
  524          B500        	RAMSAVE	EQU	$B500		; save this much to cover HiRes screen in
  525                      					; aux and the rest of the preload, up to
  526                      					; PRGLBL ($bf00)
  527          3900        	FREERAM	EQU	RAMDSK-RAMSAVE	; size of Free RAM after 'saving' 
  528                      					; special AUX memory
  529          2200        	DSKSZE	EQU	(512*273)	; size of ProDOS data disk file
  530                      	
  531                      	; ---------
  532                      	; CONSTANTS
  533                      	; ---------
  534                      	
  535          0002        	IIeID	EQU	2	; Apple ][e Yzip
  536          0009        	IIcID	EQU	9	; ][c Yzip
  537          000A        	IIgsID	EQU 	10	; ][gs Yzip
  538                      	
  539          00FF        	P3BANK	EQU	$FF	; show upper aux mem
  540          0000        	LO	EQU	0	
  541          0001        	HI	EQU	1	
  542          0002        	ABANK	EQU	2	; for address variables
  543                      	
  544          0000        	OFF	EQU	0	; for toggling soft-switches
  545          0001        	ON	EQU	1
  546                      	
  547          0003        	RETRY_COUNT EQU 3       ; how many retries before message
  548                      	
  549          0009        	TAB     EQU     $09     ; Tab char
  550          000B        	EOS     EQU     $0B     ; End of Sentence
  551          000D        	EOL	EQU	$0D	; EOL CHAR
  Tue Jun 13 1989 11:42                                                                                                  Page   10

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- APPLE ][ HARDWARE STUFF ---"

  552          000A        	LF	EQU	$0A	; LINE FEED
  553          0020        	SPACE	EQU	$20	; SPACE CHAR
  554          0008        	BACKSPACE EQU	$08	; BACKSPACE CHAR
  555          001B        	ESCAPE	EQU	$1B	; ESCAPE Key
  556          003F        	VOLCHAR EQU	'?'	; Key to hit for ONLINE command
  557                      	;
  558                      	; Screen Defs
  559                      	;
  560          008C        	MAXWIDTH EQU	140	; 560 / 4 = max "pixels"
  561          0230        	REAL_MAXW EQU	MAXWIDTH*4
  562          00C0        	MAXHEIGHT EQU	192	; 192 screen lines
  563          0002        	FONT_W	EQU	2	; font width (for game, anyway)
  564          0009        	FONT_H	EQU	9	; font height
  565          0003        	MFONT_W	EQU	3	; mono spaced font width, to game
  566          000C        	MONOFONT_W EQU	MFONT_W*4	; how wide the mono font really is
  567                      	
  568          0008        	SPACE_WIDTH EQU	8	; default space width
  569          0003        	BLINK_RATE EQU	3	; tenths of seconds between blinks
  570                      	
  571          001C        	OUTER_DELAY EQU	$1C	; outside delay loop counter
  572          0003        	INNER_DELAY EQU	3	; inner delay loop
  573                      	
  574          0072        	GS_OUTER_DELAY EQU $72	; ][gs outside counter
  575          0002        	GS_INNER_DELAY EQU 2	; ][gs inside counter
  576                      	
  577                      	; ----------------------
  578                      	; BOOT ZERO PAGE EQUATES
  579                      	; ----------------------
  580                      	
  581          0026        	BADDR	EQU	$26	; (WORD) ROM BOOT ADDRESS
  582          002B        	BSLOT	EQU	$2B	; (BYTE) ROM BOOT SLOT
  583                      	
  584          0280        	START_NAME EQU     $280    ; name upon boot is stored here
  585                      	; ----------------
  586                      	; HARDWARE EQUATES
  587                      	; ----------------
  588                      	
  589          C000        	KBD	EQU	$C000	; KEY STROBE
  590          C000        	STORE80 EQU	$C000	; video aux mem switch
  591          C002        	RDBNK	EQU	$C002	; READ MAIN MEMORY (+MAIN, +AUX)
  592          C004        	WRTBNK	EQU	$C004	; WRITE MAIN 48K OF MEMORY (+MAIN, +AUX)
  593          C008        	ALTZP	EQU	$C008	; R/W MAIN (C009 = AUX) >MEM
  594          C00C        	COL80SW	EQU	$C00C	; 80 Column switch
  595          C010        	ANYKEY 	EQU	$C010	; ANY KEY DOWN FLAG
  596          C019        	VERTBLNK EQU	$C019	; Vertical Blanking Flag
  597          C029        	IIGSVID EQU     $C029   ; GS MEGA ][ video register
  598          C030        	SPKR	EQU	$C030	; SPEAKER FLAG (MAKE A NOISE)
  599          C035        	IIGSSHD EQU     $C035   ; ][GS shadowing reg
  600          C050        	TEXTSW	EQU	$C050	; Graphics Switch
  601          C052        	MIXEDSW EQU	$C052	; Mixed Text/Graphics
  602          C054        	PAGE2SW EQU	$C054	; Page select
  603          C056        	HIRESSW	EQU	$C056	; Select HiRes
  604          C05E        	DHIRESW	EQU	$C05E	; Double HiRes switch (backwards: +0 on +1 off)
  605          C07E        	IOUDIS	EQU	$C07E	; Double HiRes Switch enabler (same backass way)
  606          C083        	BNK2SET	EQU	$C083	;READ/READ      READ RAM WRITE RAM BANK 2
  607          C08B        	BNK1SET	EQU	$C08B	;READ/READ      READ RAM WRITE RAM BANK 1
  608          C082        	RDROM	EQU	$C082	; READ READ ROM NO WRITE
  609          C088        	RDBNK1	EQU	$C088	; READ ram, bank 1
  610          C080        	RDBNK2	EQU	$C080	; Read ram, bank 2
  611                      	
  612                      	; -----------------
  613                      	; MONITOR VARIABLES
  614                      	; -----------------
  615                      	
  616          0036        	CSW	EQU	$36	; CHARACTER OUTPUT VECTOR (for scripting)
  617          C061        	APKEY1	EQU	$C061	; open apple key flag
  618          C062        	APKEY2	EQU	$C062	; closed apple key flag
  619                      	
  620          0002        	CURSW	EQU	2		; width of cursor
  621          0004        	CURSH	EQU	4		; height of cursor
  622                      	; -----------
  623                      	; MOUSE STUFF
  624                      	; -----------
  625          C412        	MTABLE	EQU	$C412	; Mouse ROM table
  626          0310        	MSVECTOR EQU	MOUSER+16	; where vector is stored
  Tue Jun 13 1989 11:42                                                                                                  Page   11

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- APPLE ][ HARDWARE STUFF ---"

  627          0312        	MSMOVEF	EQU	MSVECTOR+2	; Mouse moved flag
  628          0313        	MSBTNF	EQU	MSMOVEF+1	; Mouse button flag
  629                      	;
  630                      	; MOUSE screen holes
  631                      	;
  632          0478        	CLMPMINL EQU	$478		; lo part of clamping min
  633          0578        	CLMPMINH EQU	$578		; hi part of    "      "
  634          04F8        	CLMPMAXL EQU	$4F8		; lo part of clamping max
  635          05F8        	CLMPMAXH EQU	$5F8		; hi part of    "      "
  636          0478        	MOUSEXL	EQU	$478		; lo part of mouse X
  637          0578        	MOUSEXH	EQU	$578		; hi part of mouse X
  638          04F8        	MOUSEYL	EQU	$4F8		; lo part of mouse Y
  639          05F8        	MOUSEYH	EQU	$5F8		; hi part of mouse Y
  640          0778        	MOUSEST	EQU	$778		; status byte
  641                      	;
  642                      	; some mouse constants
  643                      	;
  644          0081        	SGL_CLK	EQU	$81	; single click char
  645          0082        	DBL_CLK	EQU	$82	; double click char
  646          0006        	CLK_CNT	EQU	6	; counts between single and double click
  647                      	; Subroutine offsets
  648          0000        	SETM	EQU	0
  649          0001        	SERVEM	EQU	1
  650          0002        	READM	EQU	2
  651          0003        	CLEARM	EQU	3
  652          0004        	POSM	EQU	4
  653          0005        	CLAMPM	EQU	5
  654          0006        	HOMEM	EQU	6
  655          0007        	INITM	EQU	7
  656                      	
  657                      	; --------------
  658                      	; PRODOS GLOBALS
  659                      	; --------------
  660          BF90        	PRODATE	EQU	$BF90	; date and
  661          BF92        	PROTIME	EQU	$BF92	; time
  662          BF98        	MACHID	EQU	$BF98	; machine id
  663                      	
  664                      	; ----------------
  665                      	; MONITOR ROUTINES
  666                      	; ----------------
  667          FB1E        	MPREAD	EQU	$FB1E	; Read for joystick control
  668          FC22        	MBASCAL	EQU	$FC22	; CALC LINE BASE ADDRESS
  669          FF3A        	MBELL	EQU	$FF3A	; MAKE A NOISE
  670          FFFC        	RESET_VECTOR EQU $FFFC  ; force warm reboot
  671          FC9C        	MCLEOL	EQU	$FC9C	; CLEAR TO END OF LINE
  672          FC42        	MCLEOS	EQU	$FC42	; CLEAR TO END OF SCREEN
  673          FC58        	MHOME	EQU	$FC58	; CLEAR SCREEN/HOME CURSOR
  674          FDED        	MCOUT	EQU	$FDED	; CHAR OUTPUT
  675          FDF0        	MCOUT1	EQU	$FDF0	; CHAR OUTPUT TO SCREEN
  676          FD0C        	MRDKEY	EQU	$FD0C	; READ KEY
  677          FD6F        	MGETLN1	EQU	$FD6F	; GET LINE
  678          FCA8        	MWAIT	EQU	$FCA8	; WASTE SO MUCH TIME
  679                      	;
  680                      	; Some /RAM spots
  681                      	;
  682          BF26        	RAMVEC	EQU	$BF26	; /RAM drive vector
  683          077E        	OLDVEC	EQU	$77E	; spot to save the drive vector
  684          BF16        	UNSVEC	EQU	$BF16	; "Uninstalled Device" vector
  685          BF31        	DEVCNT	EQU	$BF31	; Device count
  686          BF32        	DEVNUM	EQU	$BF32	; Device list
  687                      	
  688                      	;
  689                      	; machine info spots
  690                      	;
  691          FBB3        	MACHID1	EQU	$FBB3	; first part
  692          FBC0        	MACHID2	EQU	$FBC0	; second part
  693          FE1F        	MACHCHK	EQU	$FE1F	; differentiate between ][e and gs
  694                      				; do sec, then jsr, and if still set, = ][e
  695   0000               		END
  696                      	
  697   0000               		INCLUDE		MACROS.ASM
  698   0000               		STTL	"--- MACROS ---"
  699                      		PAGE 
  Tue Jun 13 1989 11:42                                                                                                  Page   12

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- MACROS ---"

  700                      	
  701                      	;
  702                      	; MACROS for Apple ][ Yzip
  703                      	;
  704                      	DLINE:	.MACRO	STRING,SLEN
  705                      		ldx	#<STRING	; get part of STRING
  706                      		lda	#>STRING	; get other part of string
  707                      		IFMA	2		; check to see if length passed in
  708                      		ldy	SLEN		; then just fetch it
  709                      		ELSE
  710                      		ldy	#STRING|L	; get length of string
  711                      		ENDIF
  712                      		jsr	DLINE		; print the string
  713                      		.MACEND
  714                      	;
  715                      	; ProDOS macros
  716                      	;
  717                      	PRODOS:	.MACRO	CODE, PADDR
  718                      		jsr	$BF00	; ProDOS handler
  719                      		DB	CODE	; ProDOS function code
  720                      		DW	PADDR	; Function Parameter Block address
  721                      		.MACEND
  722                      	
  723                      	QUIT:	.MACRO	PBLOCK
  724                      		PRODOS 	$65, PBLOCK
  725                      		.MACEND
  726                      	
  727                      	READ_BLOCK: .MACRO PBLOCK
  728                      		PRODOS	$80, PBLOCK
  729                      		.MACEND
  730                      	
  731                      	WRITE_BLOCK: .MACRO PBLOCK
  732                      		PRODOS	$81, PBLOCK
  733                      		.MACEND
  734                      	
  735                      	GET_TIME: .MACRO PBLOCK
  736                      		PRODOS	$82, PBLOCK
  737                      		.MACEND
  738                      	
  739                      	CREATE:	.MACRO	PBLOCK
  740                      		PRODOS	$C0, PBLOCK
  741                      		.MACEND
  742                      	
  743                      	DESTROY: .MACRO	PBLOCK
  744                      		PRODOS	$C1, PBLOCK
  745                      		.MACEND
  746                      	
  747                      	RENAME: .MACRO PBLOCK
  748                      		PRODOS	$C2, PBLOCK
  749                      		.MACEND
  750                      	
  751                      	SET_FILE_INFO: .MACRO PBLOCK
  752                      		PRODOS	$C3, PBLOCK
  753                      		.MACEND
  754                      	
  755                      	GET_FILE_INFO: .MACRO PBLOCK
  756                      		PRODOS	$C4, PBLOCK
  757                      		.MACEND
  758                      	
  759                      	ONLINE: .MACRO PBLOCK
  760                      		PRODOS	$C5, PBLOCK
  761                      		.MACEND
  762                      	
  763                      	SET_PREFIX: .MACRO PBLOCK
  764                      		PRODOS	$C6, PBLOCK
  765                      		.MACEND
  766                      	
  767                      	GET_PREFIX: .MACRO PBLOCK
  768                      		PRODOS	$C7, PBLOCK
  769                      		.MACEND
  770                      	
  771                      	OPEN: .MACRO PBLOCK
  772                      		PRODOS	$C8, PBLOCK
  773                      		.MACEND
  774                      	
  Tue Jun 13 1989 11:42                                                                                                  Page   13

        "APPLE YZIP (c)Infocom, Inc. --- EQUATES AND SUCH"
        "--- MACROS ---"

  775                      	NEWLINE: .MACRO PBLOCK
  776                      		PRODOS	$C9, PBLOCK
  777                      		.MACEND
  778                      	
  779                      	READ: .MACRO PBLOCK
  780                      		PRODOS	$CA, PBLOCK
  781                      		.MACEND
  782                      	
  783                      	WRITE: .MACRO PBLOCK
  784                      		PRODOS	$CB, PBLOCK
  785                      		.MACEND
  786                      	
  787                      	CLOSE: .MACRO PBLOCK
  788                      		PRODOS	$CC, PBLOCK
  789                      		.MACEND
  790                      	
  791                      	FLUSH: .MACRO PBLOCK
  792                      		PRODOS	$CD, PBLOCK
  793                      		.MACEND
  794                      	
  795                      	SET_MARK: .MACRO PBLOCK
  796                      		PRODOS	$CE, PBLOCK
  797                      		.MACEND
  798                      	
  799                      	GET_MARK: .MACRO PBLOCK
  800                      		PRODOS	$CF, PBLOCK
  801                      		.MACEND
  802                      	
  803                      	SET_EOF: .MACRO PBLOCK
  804                      		PRODOS	$D0, PBLOCK
  805                      		.MACEND
  806                      	
  807                      	SET_BUF: .MACRO PBLOCK
  808                      		PRODOS	$D1, PBLOCK
  809                      		.MACEND
  810                      	
  811                      	GET_BUF: .MACRO PBLOCK
  812                      		PRODOS	$D2, PBLOCK
  813                      		.MACEND
  814                      	
  815   0000               		END
  816                      	
  817                      	
  818   0000               		TITLE 	"APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
  819   0000               		INCLUDE		ZBEGIN.ASM
  820   0000               		STTL "--- START OF APPLE ][ INTERPRETER ---"
  821                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page   14

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- START OF APPLE ][ INTERPRETER ---"

  822                      	
  823   4000               		ORG	INTR_BEGIN
  824                      	;
  825                      	; Set up for Double HiRes full screen graphics
  826                      	;	
  827   4000   AD 54 C0    		lda	PAGE2SW+OFF	; turn off page 2
  828   4003   8D 50 C0    		sta	TEXTSW+OFF	; turn off text - turn on graphics
  829   4006   8D 57 C0    		sta	HIRESSW+ON	; turn on high resolution
  830   4009   8D 52 C0    		sta	MIXEDSW+OFF	; full screen graphics
  831   400C   8D 0D C0    		sta	COL80SW+ON	; turn on 80 column
  832   400F   8D 7E C0    		sta	IOUDIS+OFF	; turn ON (it too is backwards) Dhires switch
  833   4012   8D 5E C0    		sta	DHIRESW+OFF	; turn ON (it's backwards!) Dhires
  834                      	
  835   4015   8D 01 C0    		sta	STORE80+ON	; turn on aux page display ability
  836   4018   AD 83 C0    	        lda     BNK2SET         ; read/write RAM, bank 2
  837   401B   AD 83 C0    	        lda     BNK2SET
  838                      	;
  839                      	; copy in progame from boot code
  840                      	;
  841   401E   A2 00       		ldx	#0		; start at first letter
  842   4020               	MVPRE:
  843   4020   BD 03 20    		lda	BORG+3,X	; get letter
  844   4023   F0 0C       		beq	MVPREX		; all done
  845   4025   9D 68 46    		sta	GAME1NAME,X	; save letter
  846   4028   9D 7A 46    		sta	GAME2NAME,X	; save letter
  847   402B   9D 58 46    		sta	GAME,X		; save for asking about later
  848   402E   E8          		inx			; next letter
  849   402F   D0 EF       		bne	MVPRE		; do gen
  850   4031               	MVPREX:
  851   4031   8E 57 46    		stx	GAMEL		; save length of game name
  852   4034   A9 2E       		lda	#'.'		; get extension for names
  853   4036   9D 68 46    		sta	GAME1NAME,X	; save letter
  854   4039   9D 7A 46    		sta	GAME2NAME,X	; save letter
  855   403C   E8          		inx			; next letter
  856   403D   A9 44       		lda	#'D'		; for data segments
  857   403F   9D 68 46    		sta	GAME1NAME,X	; save letter
  858   4042   9D 7A 46    		sta	GAME2NAME,X	; save letter
  859   4045   E8          		inx			; points to number
  860   4046   E8          		inx			; inclusive count for length
  861   4047   8E 67 46    		stx	GAME1NML	; save length of name
  862   404A   8E 79 46    		stx	GAME2NML	; save length of name
  863                      	
  864   404D   A9 0F       		lda	#VERSID		; put in version number
  865   404F   8D 1F 96    		sta	ZBEGIN+ZINTWD+1	
  866                      	
  867   4052   E6 AF       		inc	ZSP+LO		; INIT Z-STACK POINTERS
  868   4054   EE A3 6C    		inc	OLDZSP+LO	; TO "1"
  869   4057   E6 B1       		inc	SCREENF		; TURN DISPLAY ON
  870   4059   E6 AA       		inc	SCRIPT		; enable scripting
  871   405B   EE D1 6C    	        inc     CRLF_CHECK      ; do CR functino check
  872                      	
  873   405E   AD 75 6E    		lda	WINTABLE+LO	; set WINDOW to point to window 0
  874   4061   85 05       		sta	WINDOW+LO
  875   4063   AD 76 6E    		lda	WINTABLE+HI
  876   4066   85 06       		sta	WINDOW+HI	; okay, it does
  877                      	
  878   4068   A5 63       		lda	ARG1+LO		; using mouse?
  879   406A   F0 12       		beq	ZBEGIN1		; nope
  880   406C   09 78       		ora	#$78		; point to correct screen holes
  881   406E   8D 3F 50    		sta	MSFIX0+1
  882   4071   8D 4A 50    		sta	MSFIX1+1	; and modify code to point to correct spot
  883   4074   8D 4F 50    		sta	MSFIX2+1
  884   4077   A5 63       		lda	ARG1+LO
  885   4079   09 F8       		ora	#$F8		; and one more
  886   407B   8D 4F 50    		sta	MSFIX2+1
  887   407E               	ZBEGIN1:
  888   407E   A9 FF       		lda	#$FF		; do a clear -1 to start off
  889   4080   85 63       		sta	ARG1+LO		; so arg 1 is this
  890   4082   20 B8 57    		jsr	ZCLR		; doing it
  891                      	
  892   4085               		GET_PREFIX GPRE_PB	; get where we are to start
  893   4085               		PRODOS	$C7, GPRE_PB
  894   4085   20 00 BF    		jsr	$BF00	; ProDOS handler
  895   4088   C7          		DB	$C7	; ProDOS function code
  896   4089   5446        		DW	GPRE_PB	; Function Parameter Block address
  Tue Jun 13 1989 11:42                                                                                                  Page   15

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- START OF APPLE ][ INTERPRETER ---"

  897   408B               		.MACEND
  898   408B               		.MACEND
  899                      	
  900   408B   AD D3 1D    		lda	D2SEG+HI	; start DSEGS at .D2
  901   408E   85 1F       		sta	DSEGS+HI
  902   4090   AD D2 1D    		lda	D2SEG+LO
  903   4093   85 1E       		sta	DSEGS+LO
  904                      	
  905   4095   A9 01       		lda	#1		; open game file .D2 please
  906   4097   20 B6 49    		jsr	FETCH_FILE	; we did that
  907   409A   A5 59       	        lda     INFODOS         ; are we on little dos?
  908   409C   F0 03       	        beq     ZBEGIN2         ; nope
  909   409E   20 E1 4B    	        jsr     GET_SPECIAL     ; do special preloading if so
  910   40A1               	ZBEGIN2:
  911   40A1   AD D5 1D    		lda	D3SEG+HI	; this is cuz we be openin' .D3
  912   40A4   85 1F       		sta	DSEGS+HI
  913   40A6   AD D4 1D    		lda	D3SEG+LO
  914   40A9   85 1E       		sta	DSEGS+LO
  915   40AB   A9 02       		lda	#2		; and just for giggles, do the
  916   40AD   20 B6 49    		jsr	FETCH_FILE	; same for game file .D3
  917                      	
  918   40B0   20 DC 90    		jsr	VLDZPC		; MAKE ZPC VALID
  919   40B3   20 51 92    		jsr	NEXTPC		; skip over # of locals
  920                      	
  921                      		; ... AND FALL INTO MAIN LOOP
  922                      	
  923   40B6               		END
  924                      	
  925   40B6               		INCLUDE 	MAIN.ASM
  926   40B6               		STTL "--- MAIN LOOP ---"
  927                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page   16

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

  928                      	
  929          9600        	MD_ADDR EQU	ZBEGIN
  930          0001        	MDEBUG 	EQU	1
  931                      	
  932   40B6               	MLOOP:
  933          [01]        		IF 	0
  934                      		lda	MD_ADDR	; get interesting address
  935                      		bne	MLOOPx	; just fine, thank you
  936                      		brk		; then die
  937                      	MLOOPx:
  938          [00]        		ENDIF
  939                      	
  940   40B6   A9 00       		lda	#0	
  941   40B8   85 62       		sta	NARGS		; reset number of args
  942   40BA   AD 54 C0    		lda	PAGE2SW+OFF	; just do this for the heck of it
  943   40BD   AD 83 C0    	        lda     BNK2SET
  944   40C0   AD 83 C0    	        lda     BNK2SET
  945   40C3   8D 01 C0    		sta	STORE80+ON	; must always be on
  946                      	
  947   40C6   20 51 92    		jsr	NEXTPC	; get op code
  948   40C9   85 61       		sta	OPCODE	; SAVE IT HERE
  949                      	
  950          [01]        		IF	MDEBUG
  951                      	;
  952                      	; special debugging code
  953                      	;
  954   40CB   AC FA 40    		ldy	SPCSV
  955   40CE   A5 61       		lda	OPCODE
  956   40D0   99 00 41    		sta	SAVEOP,Y
  957   40D3   A5 82       		lda	ZPCH
  958   40D5   99 10 41    		sta	SAVEZH,Y
  959   40D8   A5 81       		lda	ZPCM
  960   40DA   99 20 41    		sta	SAVEZM,Y
  961   40DD   A5 80       		lda	ZPCL
  962   40DF   99 30 41    		sta	SAVEZL,Y
  963   40E2   A5 85       		lda	ZPCBNK
  964   40E4   99 40 41    		sta	SAVEZB,Y
  965   40E7   A5 84       		lda	ZPCPNT+HI
  966   40E9   99 50 41    		sta	SAVEZP,Y
  967   40EC   AC FA 40    		ldy	SPCSV
  968   40EF   C8          		iny
  969   40F0   98          		tya
  970   40F1   29 0F       		and	#$0F
  971   40F3   8D FA 40    		sta	SPCSV	
  972   40F6   A5 61       		lda	OPCODE
  973   40F8   D0 66       		bne	MAINDB
  974   40FA   00          	SPCSV:	db	0
  975   410A               		ORG	$+15
  976   0410               		ORG	$.SHR.4
  977   4100               		ORG	$.SHL.4
  978   4100               	SAVEOP: ds 16
  979   4110               	SAVEZH:	ds 16
  980   4120               	SAVEZM: ds 16
  981   4130               	SAVEZL: ds 16
  982   4140               	SAVEZB: ds 16
  983   4150               	SAVEZP: ds 16		      
  984   4160               	MAINDB:
  985          [00]        		ENDIF
  986                      	;
  987                      	; DECODE AN OPCODE
  988                      	;
  989   4160   A8          		tay		; set flags
  990   4161   30 03       		bmi	DC0	; IF POSITIVE,
  991   4163   4C BD 42    		jmp	OP2	; IT'S A 2-OP
  992   4166   C9 B0       	DC0:	cmp	#$B0	
  993   4168   B0 03       		bcs	DC1	
  994   416A   4C 80 42    		jmp	OP1	; OR MAYBE A 1-OP
  995   416D   C9 C0       	DC1:	cmp	#$C0	
  996   416F   B0 03       		bcs	OPEXT	
  997   4171   4C 5A 42    		jmp	OP0	; PERHAPS A 0-OP
  998                      	
  999                      	; --------------
 1000                      	; HANDLE AN X-OP
 1001                      	; --------------
 1002                      	
  Tue Jun 13 1989 11:42                                                                                                  Page   17

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

 1003   4174   C9 EC       	OPEXT:	CMP	#236		; XCALL?
 1004   4176   D0 03       		BNE	OPX5
 1005   4178   4C 05 42    		JMP	OPXCLL		; YES, PROCESS SEPARATELY
 1006   417B   C9 FA       	OPX5:	CMP	#250		; IXCALL
 1007   417D   D0 03       		BNE	OPX6
 1008   417F   4C 05 42    		JMP	OPXCLL
 1009   4182   20 51 92    	OPX6:	JSR	NEXTPC		; GRAB THE ARGUMENT ID BYTE
 1010   4185   85 73       		STA	ABYTE		; HOLD IT HERE
 1011   4187   A2 00       		LDX	#0
 1012   4189   86 75       		STX	ADEX		; INIT ARGUMENT INDEX
 1013   418B   F0 06       		BEQ	OPX1		; JUMP TO TOP OF LOOP
 1014   418D   A5 73       	OPX0:	LDA	ABYTE		; GET ARG BYTE
 1015   418F   0A          		ASL	A		; SHIFT NEXT 2 ARG BITS
 1016   4190   0A          		ASL	A		; INTO BITS 7 & 6
 1017   4191   85 73       		STA	ABYTE		; HOLD FOR LATER
 1018   4193   29 C0       	OPX1:	AND	#%11000000	; MASK OUT GARBAGE BITS
 1019   4195   D0 06       		BNE	OPX2
 1020   4197   20 1B 43    		JSR	GETLNG		; 00 = LONG IMMEDIATE
 1021   419A   4C AE 41    		JMP	OPXNXT
 1022   419D   C9 40       	OPX2:	CMP	#%01000000	; IS IT A SHORT IMMEDIATE?
 1023   419F   D0 06       		BNE	OPX3		; NO, KEEP GUESSING
 1024   41A1   20 17 43    		JSR	GETSHT		; 01 = SHORT IMMEDIATE
 1025   41A4   4C AE 41    		JMP	OPXNXT
 1026   41A7   C9 80       	OPX3:	CMP	#%10000000	; LAST TEST
 1027   41A9   D0 17       		BNE	OPX4		; 11 = NO MORE ARGUMENTS
 1028   41AB   20 2F 43    		JSR	GETVAR		; 10 = VARIABLE
 1029   41AE   A6 75       	OPXNXT:	LDX	ADEX		; RETRIEVE ARGUMENT INDEX
 1030   41B0   A5 76       		LDA	VALUE+LO	; GRAB LSB OF VALUE
 1031   41B2   95 63       		STA	ARG1+LO,X	; STORE IN ARGUMENT TABLE
 1032   41B4   A5 77       		LDA	VALUE+HI	; GRAB MSB OF VALUE
 1033   41B6   95 64       		STA	ARG1+HI,X	; STORE THAT, TOO
 1034   41B8   E6 62       		INC	NARGS		; UPDATE ARGUMENT COUNTER
 1035   41BA   E8          		INX
 1036   41BB   E8          		INX
 1037   41BC   86 75       		STX	ADEX		; UPDATE INDEX
 1038   41BE   E0 08       		CPX	#8		; DONE 4 ARGUMENTS YET?
 1039   41C0   90 CB       		BCC	OPX0		; NO, GET SOME MORE
 1040                      	
 1041                      		; ALL X-OP ARGUMENTS READY
 1042                      	
 1043   41C2   A5 61       	OPX4:	LDA	OPCODE		; IS THIS
 1044   41C4   C9 E0       		CMP	#$E0		; AN EXTENDED 2-OP?
 1045   41C6   B0 07       		BCS	DOXOP		; NO, IT'S A REAL X-OP
 1046   41C8   C9 C0       		CMP	#$C0		; IS IT NEW OPCODE RANGE?
 1047   41CA   90 18       		BCC	ZEXTOP		; YES
 1048   41CC   4C F0 42    		JMP	OP2EX		; ELSE TREAT IT LIKE A 2-OP
 1049                      	
 1050   41CF   29 1F       	DOXOP:	AND	#%00011111	; ISOLATE ID BITS
 1051   41D1   A8          		TAY
 1052   41D2   B9 64 45    		LDA	OPTXL,Y
 1053   41D5   8D DF 41    		STA	GOX+1+LO
 1054   41D8   B9 44 45    		LDA	OPTXH,Y
 1055   41DB   8D E0 41    		STA	GOX+1+HI
 1056   41DE   20 FF FF    	GOX:	JSR	$FFFF		;DUMMY
 1057   41E1   4C B6 40    		JMP	MLOOP
 1058                      	
 1059                      		; HANDLE EXTENDED OPCODE RANGE OPS
 1060                      	
 1061   41E4   C9 1D       	ZEXTOP:	CMP	#EXTLEN		; OUT OF RANGE?
 1062   41E6   B0 18       		BCS	BADEXT
 1063   41E8   A8          		TAY			; OFFSET ALREADY CORRECT
 1064   41E9   B9 A1 45    		LDA	EXTOPL,Y
 1065   41EC   8D F6 41    		STA	GOE+1+LO
 1066   41EF   B9 84 45    		LDA	EXTOPH,Y
 1067   41F2   8D F7 41    		STA	GOE+1+HI
 1068   41F5   20 FF FF    	GOE:	JSR	$FFFF		;DUMMY
 1069   41F8   4C B6 40    		JMP	MLOOP
 1070                      	
 1071                      		; *** ERROR #1 -- ILLEGAL X-OP ***
 1072                      	
 1073   41FB   A9 01       	BADOPX:	LDA	#1
 1074   41FD   4C F9 51    		JMP	ZERROR
 1075                      	
 1076                      		; *** ERROR #16 -- ILLEGAL EXTENDED RANGE X-OP ***
 1077                      	
  Tue Jun 13 1989 11:42                                                                                                  Page   18

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

 1078   4200   A9 10       	BADEXT:	LDA	#16
 1079   4202   4C F9 51    		JMP	ZERROR
 1080                      	
 1081                      		; HANDLE AN XCALL OPCODE
 1082                      	
 1083   4205   20 51 92    	OPXCLL:	JSR	NEXTPC	; GET 2 MODE BYTES
 1084   4208   85 73       		STA	ABYTE	
 1085   420A   20 51 92    		JSR	NEXTPC	
 1086   420D   85 74       		STA	BBYTE	
 1087   420F   A5 73       		LDA	ABYTE	; ONE TO START WITH
 1088   4211   A2 00       		LDX	#0	
 1089   4213   86 75       		STX	ADEX	; INIT ARGUMENT INDEX
 1090   4215   F0 06       		BEQ	XCALL2	; ALWAYS JUMP TO TOP OF LOOP
 1091   4217   A5 73       	XCALL1:	LDA	ABYTE	; GET ARG BYTE
 1092   4219   0A          		ASL	A	; SHIFT NEXT 2 BITS
 1093   421A   0A          		ASL	A	; INTO BITS 7 & 6
 1094   421B   85 73       		STA	ABYTE	; HOLD FOR LATER
 1095   421D   29 C0       	XCALL2:	AND	#%11000000	; MASK OUT GARBAGE
 1096   421F   D0 06       		BNE	XCALL3	
 1097   4221   20 1B 43    		JSR	GETLNG	; 00 = LONG IMMEDIATE
 1098   4224   4C 38 42    		JMP	XCNXT	
 1099   4227   C9 40       	XCALL3:	CMP	#%01000000	; SHORT IMMED?
 1100   4229   D0 06       		BNE	XCALL4	; NO, TRY ANOTHER
 1101   422B   20 17 43    		JSR	GETSHT	; 01 = SHORT IMMED.
 1102   422E   4C 38 42    		JMP	XCNXT	
 1103   4231   C9 80       	XCALL4:	CMP	#%10000000	; LAST TEST
 1104   4233   D0 8D       		BNE	OPX4	; 11 = NO MORE ARGS
 1105   4235   20 2F 43    		JSR	GETVAR	; 10 = VARIABLE
 1106   4238   A6 75       	XCNXT:	LDX	ADEX	
 1107   423A   A5 76       		LDA	VALUE+LO	
 1108   423C   95 63       		STA	ARG1+LO,X	
 1109   423E   A5 77       		LDA	VALUE+HI	
 1110   4240   95 64       		STA	ARG1+HI,X	
 1111   4242   E6 62       		INC	NARGS	
 1112   4244   E8          		INX		
 1113   4245   E8          		INX		
 1114   4246   86 75       		STX	ADEX	
 1115   4248   E0 10       		CPX	#16	
 1116   424A   D0 03       		BNE	XCALL5
 1117   424C   4C C2 41    		JMP	OPX4		; DONE, GO DO IT
 1118   424F   E0 08       	XCALL5:	CPX	#8		; DONE 1ST MODE BYTE?
 1119   4251   D0 C4       		BNE	XCALL1		; NOT QUITE YET
 1120   4253   A5 74       		LDA	BBYTE		; SET UP FOR NEXT
 1121   4255   85 73       		STA	ABYTE		; MODE BYTE
 1122   4257   4C 1D 42    		JMP	XCALL2		; GO DO IT
 1123                      	
 1124                      	; -------------
 1125                      	; HANDLE A 0-OP
 1126                      	; -------------
 1127                      	
 1128   425A   C9 BE       	OP0:	CMP	#190		; IS IT EXTOP OP
 1129   425C   F0 1A       		BEQ	EXTOP		; YES
 1130   425E   29 0F       		AND	#%00001111	; ISOLATE 0-OP ID BITS
 1131   4260   A8          		TAY		
 1132   4261   B9 D4 44    		LDA	OPT0L,Y	
 1133   4264   8D 6E 42    		STA	GO0+1+LO	
 1134   4267   B9 C4 44    		LDA	OPT0H,Y	
 1135   426A   8D 6F 42    		STA	GO0+1+HI	
 1136   426D   20 FF FF    	GO0:	JSR	$FFFF	;DUMMY
 1137   4270   4C B6 40    		JMP	MLOOP	
 1138                      	
 1139                      		; *** ERROR #2 -- ILLEGAL 0-OP ***
 1140                      	
 1141   4273   A9 02       	BADOP0:	LDA	#2	
 1142   4275   4C F9 51    		JMP	ZERROR	
 1143                      	
 1144                      		; THIS OPCODE TELLS THAT NEXT OP IS PART OF THE
 1145                      		; EXTENDED RANGE OF OPCODES, GET IT AND PROCESS IT
 1146                      		; (THEY ARE ALL XOPS)
 1147                      	
 1148   4278   20 51 92    	EXTOP:	JSR	NEXTPC		; GO GET EXTENDED RANGE OP
 1149   427B   85 61       		STA	OPCODE		; SAVE IT
 1150   427D   4C 74 41    		JMP	OPEXT		; AND HANDLE IT
 1151                      	
 1152                      	
  Tue Jun 13 1989 11:42                                                                                                  Page   19

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

 1153                      	; -------------
 1154                      	; HANDLE A 1-OP
 1155                      	; -------------
 1156                      	
 1157   4280               	OP1:
 1158   4280   29 30       		and	#%00110000	; ISOLATE ARGUMENT BITS
 1159   4282   D0 07       		bne	OP1A	
 1160   4284   20 51 92    		jsr	NEXTPC		; get next byte
 1161   4287   A8          		tay
 1162   4288   4C 8F 42    		jmp	OP1A1	
 1163   428B   29 20       	OP1A:	and	#%00100000	; TEST AGAIN
 1164   428D   D0 0C       		bne	OP1B	
 1165                      	;
 1166                      	; 01 = SHORT IMMEDIATE
 1167                      	;
 1168   428F   85 64       	OP1A1:	sta	ARG1+HI	
 1169   4291   20 51 92    		jsr	NEXTPC
 1170   4294   85 63       		sta	ARG1+LO	
 1171   4296   E6 62       		inc	NARGS	
 1172   4298   4C A1 42    		jmp	OP1EX1	
 1173   429B   20 2F 43    	OP1B:	JSR	GETVAR	; 10 = VARIABLE
 1174   429E   20 0C 43    	OP1EX:	JSR	V2A1	; MOVE [VALUE] TO [ARG1], UPDATE [NARGS]
 1175   42A1   A5 61       	OP1EX1:	LDA	OPCODE	
 1176   42A3   29 0F       		AND	#%00001111	; ISOLATE 0-OP ID BITS
 1177   42A5   A8          		TAY		
 1178   42A6   B9 F4 44    		LDA	OPT1L,Y	
 1179   42A9   8D B3 42    		STA	GO1+1+LO	
 1180   42AC   B9 E4 44    		LDA	OPT1H,Y	
 1181   42AF   8D B4 42    		STA	GO1+1+HI	
 1182   42B2   20 FF FF    	GO1:	JSR	$FFFF	;DUMMY
 1183   42B5   4C B6 40    		JMP	MLOOP	
 1184                      	
 1185                      	; *** ERROR #3 -- ILLEGAL 1-OP ***
 1186                      	
 1187   42B8   A9 03       	BADOP1:	LDA	#3	
 1188   42BA   4C F9 51    		JMP	ZERROR	
 1189                      	
 1190                      	
 1191                      	
 1192                      	; -------------
 1193                      	; HANDLE A 2-OP
 1194                      	; -------------
 1195                      	
 1196   42BD   29 40       	OP2:	AND	#%01000000	; ISOLATE 1ST ARG BIT
 1197   42BF   D0 0C       		BNE	OP2A	
 1198                      	;
 1199                      	; 0 = SHORT IMMEDIATE
 1200                      	;
 1201   42C1   85 64       		sta	ARG1+HI	
 1202   42C3   20 51 92    		jsr	NEXTPC
 1203   42C6   85 63       		sta	ARG1+LO	
 1204   42C8   E6 62       		inc	NARGS	
 1205   42CA   4C D3 42    		jmp	OP2B1	
 1206   42CD   20 2F 43    	OP2A:	jsr	GETVAR	; 1 = VARIABLE
 1207   42D0   20 0C 43    	OP2B:	jsr	V2A1	; [VALUE] TO [ARG1], UPDATE [NARGS]
 1208   42D3   A5 61       	OP2B1:	lda	OPCODE	; RESTORE OPCODE BYTE
 1209   42D5   29 20       		and	#%00100000	; ISOLATE 2ND ARG BIT
 1210   42D7   D0 0A       		bne	OP2C	
 1211   42D9   85 66       		sta	ARG2+HI	
 1212   42DB   20 51 92    		jsr	NEXTPC
 1213   42DE   85 65       		sta	ARG2+LO	
 1214   42E0   4C EE 42    		jmp	OP2D1	
 1215   42E3   20 2F 43    	OP2C:	jsr	GETVAR	; 1 = VARIABLE
 1216   42E6   A5 76       	OP2D:	lda	VALUE+LO	; MOVE 2ND [VALUE]
 1217   42E8   85 65       		sta	ARG2+LO	; INTO [ARG2]
 1218   42EA   A5 77       		lda	VALUE+HI	
 1219   42EC   85 66       		sta	ARG2+HI	
 1220   42EE   E6 62       	OP2D1:	inc	NARGS	; UPDATE ARGUMENT COUNT
 1221                      	
 1222                      		; EXECUTE A 2-OP OR EXTENDED 2-OP
 1223                      	
 1224   42F0   A5 61       	OP2EX:	LDA	OPCODE	
 1225   42F2   29 1F       		AND	#%00011111	; ISOLATE 0-OP ID BITS
 1226   42F4   A8          		TAY		
 1227   42F5   B9 24 45    		LDA	OPT2L,Y	
  Tue Jun 13 1989 11:42                                                                                                  Page   20

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- MAIN LOOP ---"

 1228   42F8   8D 02 43    		STA	GO2+1+LO	
 1229   42FB   B9 04 45    		LDA	OPT2H,Y	
 1230   42FE   8D 03 43    		STA	GO2+1+HI	
 1231   4301   20 FF FF    	GO2:	JSR	$FFFF	;DUMMY
 1232   4304   4C B6 40    		JMP	MLOOP	
 1233                      	
 1234                      	; *** ERROR #4 -- ILLEGAL 2-OP ****
 1235                      	
 1236   4307   A9 04       	BADOP2:	LDA	#4	
 1237   4309   4C F9 51    		JMP	ZERROR	
 1238                      	
 1239                      	
 1240                      	
 1241                      	; --------------------------------------
 1242                      	; MOVE [VALUE] TO [ARG1], UPDATE [NARGS]
 1243                      	; --------------------------------------
 1244                      	
 1245   430C   A5 76       	V2A1:	LDA	VALUE+LO
 1246   430E   85 63       		STA	ARG1+LO
 1247   4310   A5 77       		LDA	VALUE+HI
 1248   4312   85 64       		STA	ARG1+HI
 1249   4314   E6 62       		INC	NARGS
 1250   4316   60          		RTS
 1251                      	
 1252   4317               		END
 1253                      	
 1254   4317               		INCLUDE 	SUBS.ASM
 1255   4317               		STTL "--- OPCODE SUPPORT SUBROUTINES ---"
 1256                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page   21

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1257                      	
 1258                      	; -----------------------
 1259                      	; FETCH A SHORT IMMEDIATE
 1260                      	; -----------------------
 1261                      	
 1262   4317   A9 00       	GETSHT:	LDA	#0	; MSB IS ZERO
 1263   4319   F0 03       		BEQ	GETV	; FETCH LSB FROM Z-CODE
 1264                      	
 1265                      	
 1266                      	; ----------------------
 1267                      	; FETCH A LONG IMMEDIATE
 1268                      	; ----------------------
 1269                      	
 1270   431B   20 51 92    	GETLNG:	JSR	NEXTPC	; GRAB MSB
 1271   431E   85 77       	GETV:	STA	VALUE+HI	
 1272   4320   20 51 92    		JSR	NEXTPC	; GRAB LSB
 1273   4323   85 76       		STA	VALUE+LO	
 1274   4325   60          		RTS		
 1275                      	
 1276                      	
 1277                      	; ----------------
 1278                      	; FETCH A VARIABLE
 1279                      	; ----------------
 1280                      	; FROM INSIDE AN OPCODE (VARIABLE ID IN [A])
 1281                      	
 1282   4326   AA          	VARGET:	TAX		; IF NON-ZERO,
 1283   4327   D0 0B       		BNE	GETVR1	; ACCESS A VARIABLE
 1284   4329   20 56 43    		JSR	POPVAL	; ELSE PULL VAR OFF Z-STACK
 1285   432C   4C 87 43    		JMP	PSHVAL	; WITHOUT ALTERING STACK
 1286                      	
 1287                      	; FROM THE MAIN LOOP (VARIABLE ID IN Z-CODE)
 1288                      	
 1289   432F   20 51 92    	GETVAR:	JSR	NEXTPC	; GRAB VAR-TYPE BYTE
 1290   4332   F0 22       		BEQ	POPVAL	; VALUE IS ON Z-STACK
 1291                      	
 1292                      	; IS VARIABLE LOCAL OR GLOBAL?
 1293                      	
 1294   4334   C9 10       	GETVR1:	CMP	#$10	; IF LOW = 16,
 1295   4336   B0 0D       		BCS	GETVRG	; IT'S GLOBAL
 1296                      	
 1297                      	; HANDLE A LOCAL VARIABLE
 1298                      	
 1299   4338   0A          	GETVRL:	ASL	A		; WORD INDEX
 1300   4339   AA          		TAX		; INTO THE [LOCALS] TABLE
 1301   433A   BD FE 1D    		LDA	LOCALS-2+LO,X	; GRAB LSB
 1302   433D   85 76       		STA	VALUE+LO	
 1303   433F   BD FF 1D    		LDA	LOCALS-2+HI,X	; AND MSB
 1304   4342   85 77       		STA	VALUE+HI	
 1305   4344   60          		RTS		
 1306                      	;
 1307                      	; HANDLE A GLOBAL VARIABLE
 1308                      	;
 1309   4345               	GETVRG:
 1310   4345   20 04 44    		jsr	GVCALC	; GET ADDRESS OF GLOBAL INTO [FPC]
 1311   4348   20 88 92    		jsr	FETCHB	; and get hi part
 1312   434B   85 77       		sta	VALUE+HI	
 1313   434D   20 F0 8F    		jsr	NEXTFPC	; and point to next part
 1314   4350   20 88 92    		jsr	FETCHB	; and go get it
 1315   4353   85 76       		sta	VALUE+LO ; SAVE IT
 1316   4355   60          		rts		; AND WE'RE DONE
 1317                      	
 1318                      	; ----------------------------------
 1319                      	; POP Z-STACK INTO [VALUE] AND [X/A]
 1320                      	; ----------------------------------
 1321                      	; ZSTACK DOUBLED IN SIZE FOR EZIP
 1322                      	; SO THIS RTN ALL NEW
 1323                      	
 1324   4356   A5 AF       	POPVAL:	LDA	ZSP+LO	; IF ZSP+LO IS 0
 1325   4358   D0 02       		BNE	POP1	
 1326   435A   85 B0       		STA	ZSP+HI	; MUST DEC. HI (HI = 0 OR 1 ONLY)
 1327   435C   C6 AF       	POP1:	DEC	ZSP+LO	; THEN DEC ZSP LO
 1328   435E   D0 04       		BNE	POP2	
 1329   4360   05 B0       		ORA	ZSP+HI	; LO + HI BOTH 0?
 1330   4362   F0 1E       		BEQ	UNDER	; UNDERFLOW IF ZERO!
 1331   4364   A4 AF       	POP2:	LDY	ZSP+LO	
  Tue Jun 13 1989 11:42                                                                                                  Page   22

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1332   4366   A5 B0       		LDA	ZSP+HI	
 1333   4368   F0 0C       		BEQ	POP3	; BOTTOM HALF OF ZSTACK
 1334   436A   B9 00 0E    		LDA	ZSTKTL,Y	; GET VALUE FROM TOP HALF
 1335   436D   85 76       		STA	VALUE+LO	; OF ZSTACK INTO VALUE & A,X
 1336   436F   AA          		TAX		
 1337   4370   B9 00 10    		LDA	ZSTKTH,Y	
 1338   4373   85 77       		STA	VALUE+HI	
 1339   4375   60          		RTS		
 1340                      	
 1341   4376   B9 00 0D    	POP3:	LDA	ZSTKBL,Y	; GET VALUE FROM BOTTOM HALF
 1342   4379   85 76       		STA	VALUE+LO	; OF ZSTACK INTO VALUE & A,X
 1343   437B   AA          		TAX		
 1344   437C   B9 00 0F    		LDA	ZSTKBH,Y	
 1345   437F   85 77       		STA	VALUE+HI	
 1346   4381   60          		RTS		
 1347                      	
 1348                      	; *** ERROR #5 -- Z-STACK UNDERFLOW ***
 1349   4382   A9 05       	UNDER:	LDA	#5	
 1350   4384   4C F9 51    		JMP	ZERROR	
 1351                      	
 1352                      	; -----------------------
 1353                      	; PUSH [VALUE] TO Z-STACK
 1354                      	; -----------------------
 1355                      	
 1356   4387   A6 76       	PSHVAL:	LDX	VALUE+LO	
 1357   4389   A5 77       		LDA	VALUE+HI	
 1358                      	
 1359                      	; ---------------------
 1360                      	; PUSH [X/A] TO Z-STACK
 1361                      	; ---------------------
 1362                      	
 1363   438B   48          	PUSHXA:	PHA		; HOLD VALUE IN [A] A SEC.
 1364   438C   A4 AF       		LDY	ZSP+LO	
 1365   438E   A5 B0       		LDA	ZSP+HI	
 1366   4390   F0 0B       		BEQ	PSHBOT	; ON BOTTOM HALF OF STACK
 1367   4392   8A          		TXA		
 1368   4393   99 00 0E    		STA	ZSTKTL,Y	; PUSH VALUE ONTO TOP HALF OF STACK
 1369   4396   68          		PLA		
 1370   4397   99 00 10    		STA	ZSTKTH,Y	
 1371   439A   4C A5 43    		JMP	PSHUPD	; NOW UPDATE POINTER
 1372                      	
 1373   439D   8A          	PSHBOT:	TXA		; PLACE VALUE ON ZSTACK
 1374   439E   99 00 0D    		STA	ZSTKBL,Y	
 1375   43A1   68          		PLA		
 1376   43A2   99 00 0F    		STA	ZSTKBH,Y	
 1377   43A5   E6 AF       	PSHUPD:	INC	ZSP+LO	; UPDATE ZSTACK POINTER
 1378   43A7   D0 08       		BNE	PSHEX	
 1379   43A9   A5 AF       		LDA	ZSP+LO	
 1380   43AB   05 B0       		ORA	ZSP+HI	
 1381   43AD   D0 03       		BNE	OVER	; OVERFLOW IF $200
 1382   43AF   E6 B0       		INC	ZSP+HI	; TO 1
 1383   43B1   60          	PSHEX:	RTS		
 1384                      	
 1385                      	; *** ERROR #6 -- Z-STACK OVERFLOW ***
 1386   43B2   A9 06       	OVER:	LDA	#6	
 1387   43B4   4C F9 51    		JMP	ZERROR	
 1388                      	
 1389                      	
 1390                      	; --------------
 1391                      	; RETURN A VALUE
 1392                      	; --------------
 1393                      	; FROM WITHIN AN OPCODE (VARIABLE ID IN [A])
 1394                      	
 1395   43B7   AA          	VARPUT:	TAX		; IF ZERO,
 1396   43B8   D0 1C       		BNE	PUTVR1	
 1397                      	
 1398                      	; FLUSH TOP WORD OFF STACK
 1399                      	; AND REPLACE WITH [VALUE]
 1400                      	
 1401   43BA   A5 AF       		LDA	ZSP+LO	; IF ZSP+LO =0
 1402   43BC   D0 02       		BNE	VAR1	; THEN HI =1 (GUARDED ELSEWHERE)
 1403   43BE   85 B0       		STA	ZSP+HI	; DECREMENT HI (ONLY 0 OR 1)
 1404   43C0   C6 AF       	VAR1:	DEC	ZSP+LO	; NOW DEC LOW BYTE
 1405   43C2   D0 C3       		BNE	PSHVAL	
 1406   43C4   05 B0       		ORA	ZSP+HI	
  Tue Jun 13 1989 11:42                                                                                                  Page   23

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1407   43C6   F0 BA       		BEQ	UNDER	; ERROR IF [ZSP] BECAME ZERO!
 1408   43C8   D0 BD       		BNE	PSHVAL	
 1409                      	
 1410                      		; RETURN A ZERO
 1411   43CA               	RET0:
 1412   43CA   A9 00       		lda	#0	
 1413   43CC   AA          		tax			; zero's all
 1414                      	;
 1415                      	; RETURN WORD IN [A], [X] (LO,HI) (EZIP EXPANDED TO A WORD)
 1416                      	;
 1417   43CD               	PUTBYT:
 1418   43CD   85 76       		STA	VALUE+LO	
 1419   43CF   86 77       		STX	VALUE+HI	; CLEAR MSB
 1420                      	;
 1421                      	; RETURN [VALUE]
 1422                      	;
 1423   43D1   20 51 92    	PUTVAL:	JSR	NEXTPC	; GET VARIABLE ID BYTE
 1424   43D4   F0 B1       		BEQ	PSHVAL	; [VALUE] GOES TO Z-STACK
 1425                      	;
 1426                      	; LOCAL OR GLOBAL VARIABLE?
 1427                      	;
 1428   43D6   C9 10       	PUTVR1:	CMP	#$10	; IF LOW = 16,
 1429   43D8   B0 0D       		BCS	PUTVLG	; IT'S GLOBAL
 1430                      	;
 1431                      	; PUT A LOCAL VARIABLE
 1432                      	;
 1433   43DA   0A          	PUTVLL:	ASL	A		; WORD INDEX
 1434   43DB   AA          		TAX		; INTO THE [LOCALS] TABLE
 1435   43DC   A5 76       		LDA	VALUE+LO	; GRAB LSB
 1436   43DE   9D FE 1D    		STA	LOCALS-2+LO,X	; SAVE IN LOCAL TABLE
 1437   43E1   A5 77       		LDA	VALUE+HI	; DO SAME TO
 1438   43E3   9D FF 1D    		STA	LOCALS-2+HI,X	; MSB
 1439   43E6   60          		RTS		
 1440                      	;
 1441                      	; RETURN A GLOBAL VARIABLE
 1442                      	;
 1443   43E7               	PUTVLG:
 1444   43E7   20 04 44    		JSR	GVCALC		; put address in [FPC]
 1445   43EA   A5 8E       		lda	FPCBNK		; and move it to stash spot
 1446   43EC   85 91       		sta	SPCBNK
 1447   43EE   A5 8D       		lda	FPCH
 1448   43F0   85 90       		sta	SPCH
 1449   43F2   A5 8C       		lda	FPCL
 1450   43F4   85 8F       		sta	SPCL	
 1451   43F6   A5 77       		lda	VALUE+HI	; GET MSB
 1452   43F8   20 67 92    		jsr	STASHB		; and save it
 1453   43FB   20 D0 8F    		jsr	NEXTSPC		; point to next byte
 1454   43FE   A5 76       		lda	VALUE+LO	; NOW GET LSB
 1455   4400   20 67 92    		jsr	STASHB		; and send it out
 1456   4403   60          		rts
 1457                      	
 1458                      	; -----------------------
 1459                      	; CALC GLOBAL WORD OFFSET
 1460                      	; -----------------------
 1461                      	; ENTRY: VAR-I BYTE (16-255) IN [A]
 1462                      	; EXIT: ABSOLUTE ADDRESS OF GLOBAL VAR IN [FPC]
 1463   4404               	GVCALC:
 1464   4404   38          		sec		; time for a subtract
 1465   4405   E9 10       		sbc	#$10	; FORM A ZERO-ALIGNED INDEX
 1466   4407   A0 00       		ldy	#0	; MAKE SURE MSB OF OFFSET AND [Y]
 1467   4409   84 79       		sty	I+HI	; ARE CLEARED
 1468   440B   0A          		asl	A	; MULTIPLY OFFSET BY 2
 1469   440C   26 79       		rol	I+HI	; TO WORD-ALIGN IT
 1470   440E   18          		clc		; ADD OFFSET TO ADDR OF GLOBAL TABLE
 1471   440F   65 50       		adc	GLOBAL+LO	; TO FORM THE ABSOLUTE
 1472   4411   85 8C       		sta	FPCL	; ADDRESS OF THE
 1473   4413   A5 79       		lda	I+HI	; DESIRED GLOBAL VARIABLE
 1474   4415   65 51       		adc	GLOBAL+HI	; STORE ADDRESS BACK IN [FPC]
 1475   4417   20 A9 8F    		jsr	SETPC	; now get memory page and bank
 1476   441A   85 8D       		sta	FPCH	; hi part
 1477   441C   84 8E       		sty	FPCBNK	; and bank
 1478   441E               	WCEX:
 1479   441E   60          		rts
 1480                      	
 1481                      	
  Tue Jun 13 1989 11:42                                                                                                  Page   24

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1482                      	; ---------------
 1483                      	; PREDICATE FAILS
 1484                      	; ---------------
 1485                      	
 1486   441F   20 51 92    	PREDF:	JSR	NEXTPC	; GET 1ST BRANCH BYTE
 1487   4422   10 0C       		BPL	PREDB	; DO BRANCH IF BIT 7 OFF
 1488                      	
 1489                      	
 1490                      	; -----------------------
 1491                      	; IGNORE PREDICATE BRANCH
 1492                      	; -----------------------
 1493                      	; ENTRY: 1ST BRANCH BYTE IN [A]
 1494                      	
 1495   4424   29 40       	PREDNB:	AND	#%01000000	; TEST BIT 6
 1496   4426   D0 F6       		BNE	WCEX	; SHORT BRANCH IF SET
 1497   4428   4C 51 92    		JMP	NEXTPC	; ELSE SKIP OVER 2ND BRANCH BYTE
 1498                      	
 1499                      	
 1500                      	; ------------------
 1501                      	; PREDICATE SUCCEEDS
 1502                      	; ------------------
 1503                      	
 1504   442B   20 51 92    	PREDS:	JSR	NEXTPC	; GET 1ST BRANCH BYTE
 1505   442E   10 F4       		BPL	PREDNB	; DON'T BRANCH IF BIT 7 CLEAR
 1506                      	
 1507                      	
 1508                      	; --------------------------
 1509                      	; PERFORM A PREDICATE BRANCH
 1510                      	; --------------------------
 1511                      	; ENTRY: 1ST PRED BYTE IN [A]
 1512                      	
 1513   4430   AA          	PREDB:	TAX		; SAVE HERE
 1514   4431   29 40       		AND	#%01000000	; LONG OR SHORT BRANCH?
 1515   4433   F0 0B       		BEQ	PREDLB	; LONG IF BIT 6 IS CLEAR
 1516                      	
 1517                      		; HANDLE A SHORT BRANCH
 1518                      	
 1519   4435   8A          		TXA		; RESTORE PRED BYTE
 1520   4436   29 3F       		AND	#%00111111	; FORM SHORT OFFSET
 1521   4438   85 76       		STA	VALUE+LO	; USE AS LSB OF BRANCH OFFSET
 1522   443A   A9 00       		LDA	#0	
 1523   443C   85 77       		STA	VALUE+HI	; MSB OF OFFSET IS ZERO
 1524   443E   F0 17       		BEQ	PREDB7	; DO THE BRANCH
 1525                      	
 1526                      		; HANDLE A LONG BRANCH
 1527                      	
 1528   4440   8A          	PREDLB:	TXA		; RESTORE 1ST PRED BYTE
 1529   4441   29 3F       		AND	#%00111111	; FORM MSB OF OFFSET
 1530   4443   AA          		TAX		; SAVE HERE FOR REFERENCE
 1531   4444   29 20       		AND	#%00100000	; CHECK SIGN OF 14-BIT VALUE
 1532   4446   F0 04       		BEQ	DOB2	; POSITIVE IF ZERO, SO USE [X]
 1533   4448   8A          		TXA		; ELSE RESTORE BYTE
 1534   4449   09 E0       		ORA	#%11100000	; EXTEND THE SIGN BIT
 1535   444B   AA          		TAX		; BACK HERE FOR STORAGE
 1536   444C   86 77       	DOB2:	STX	VALUE+HI	
 1537   444E   20 51 92    		JSR	NEXTPC	; FETCH LSB OF 14-BIT OFFSET
 1538   4451   85 76       		STA	VALUE+LO	
 1539                      	
 1540                      		; BRANCH TO Z-ADDRESS IN [VALUE]
 1541                      	
 1542   4453   A5 77       	PREDB1:	LDA	VALUE+HI	; CHECK MSB OF OFFSET
 1543   4455   D0 0E       		BNE	PREDB3	; DO BRANCH IF NZ
 1544   4457   A5 76       	PREDB7:	LDA	VALUE+LO	; IF LSB IS NON-ZERO,
 1545   4459   D0 03       		BNE	PREDB2	; MAKE SURE IT ISN'T 1
 1546   445B   4C 8F 79    		JMP	ZRFALS	; ELSE DO AN "RFALSE"
 1547   445E   C9 01       	PREDB2:	CMP	#1	; IF OFFSET = 1
 1548   4460   D0 03       		BNE	PREDB3	
 1549   4462   4C 84 79    		JMP	ZRTRUE	; DO AN "RTRUE"
 1550                      	
 1551                      	; ENTRY POINT FOR "JUMP"
 1552                      	
 1553   4465   A5 76       	PREDB3:	LDA	VALUE+LO	; SUBTRACT 2 FROM OFFSET
 1554   4467   38          		SEC			; IN [VALUE]
 1555   4468   E9 02       		SBC	#2	
 1556   446A   AA          		TAX			;SAVE	LO BYTE
  Tue Jun 13 1989 11:42                                                                                                  Page   25

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1557   446B   A5 77       		LDA	VALUE+HI	
 1558   446D   E9 00       		SBC	#0	
 1559   446F   85 78       		STA	I+LO	;MSB OF OFFSET = LSB OF [I]
 1560   4471   A0 00       		LDY	#0	; CLEAR THE MSB
 1561   4473   84 79       		STY	I+HI	; OF [I]
 1562   4475   0A          		ASL	A	;	EXTEND THE SIGN OF OFFSET
 1563   4476   26 79       		ROL	I+HI	; INTO MSB OF [I]
 1564   4478   0A          		ASL	A		
 1565   4479   26 79       		ROL	I+HI	; (EZIP)
 1566   447B   0A          	        asl     A
 1567   447C   26 79       	        rol     I+HI    ; (YZIP) ??!!
 1568   447E   8A          		TXA		; GET LSB OF OFFSET
 1569   447F   65 80       		ADC	ZPCL	; ADD LOW 8 BITS OF ZPC
 1570   4481   90 06       		BCC	PREDB5	; IF OVERFLOWED,
 1571   4483   E6 78       		INC	I+LO	; UPDATE UPPER 9 BITS
 1572   4485   D0 02       		BNE	PREDB5	
 1573   4487   E6 79       		INC	I+HI	
 1574   4489   85 80       	PREDB5:	STA	ZPCL	; UPDATE ZPC
 1575   448B   A5 78       		LDA	I+LO	; IF UPPER 9 BITS ARE ZERO,
 1576   448D   05 79       		ORA	I+HI	; NO NEED TO CHANGE PAGES
 1577   448F   F0 12       		BEQ	PREDB6	
 1578   4491   A5 78       		LDA	I+LO	; ELSE CALC NEW UPPER BITS
 1579   4493   18          		CLC		
 1580   4494   65 81       		ADC	ZPCM	
 1581   4496   85 81       		STA	ZPCM	
 1582   4498   A5 79       		LDA	I+HI	
 1583   449A   65 82       		ADC	ZPCH	
 1584   449C   29 07       		AND	#%00000111
 1585   449E   85 82       		STA	ZPCH	
 1586   44A0   4C DC 90    		JMP	VLDZPC	;MAKE VALID
 1587   44A3               	PREDB6:			
 1588                      	
 1589                      		; FALL THROUGH ...
 1590                      	
 1591                      	; ----
 1592                      	; NOOP
 1593                      	; ----
 1594                      	
 1595   44A3   60          	ZNOOP:	RTS		
 1596                      	
 1597                      	
 1598                      	; ----------------------
 1599                      	; MOVE [ARG1] TO [VALUE]
 1600                      	; ----------------------
 1601                      	
 1602   44A4   A5 63       	A12VAL:	LDA	ARG1+LO	
 1603   44A6   85 76       		STA	VALUE+LO
 1604   44A8   A5 64       		LDA	ARG1+HI	
 1605   44AA   85 77       		STA	VALUE+HI
 1606   44AC   60          		RTS
 1607                      	
 1608                      	
 1609                      	; -----------------------------------
 1610                      	; INDICATE STATUS LINE REFRESH NEEDED
 1611                      	; -----------------------------------
 1612                      	
 1613   44AD   AD 11 96    	REFRSH:	LDA	ZBEGIN+ZFLAGS+1	; PICK UP LOW BYTE OF FLAG WORD
 1614   44B0   09 04       		ORA	#%00000100	; SET BIT 2
 1615   44B2   8D 11 96    		STA	ZBEGIN+ZFLAGS+1	; AND PUT IT BACK
 1616   44B5   60          		RTS
 1617                      	
 1618                      	
 1619                      	;DECJ RETURNS C=0 WHEN  J=$FFFF
 1620                      	
 1621   44B6   A5 7A       	DECJ:	LDA	J+LO	
 1622   44B8   38          		SEC		
 1623   44B9   E9 01       		SBC	#1	
 1624   44BB   85 7A       		STA	J+LO	
 1625   44BD   A5 7B       		LDA	J+HI	
 1626   44BF   E9 00       		SBC	#0	
 1627   44C1   85 7B       		STA	J+HI	
 1628   44C3   60          		RTS		
 1629                      	
 1630   44C4               		END
 1631                      	
  Tue Jun 13 1989 11:42                                                                                                  Page   26

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1632   44C4               		INCLUDE 	DISPATCH.ASM
 1633                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page   27

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE SUPPORT SUBROUTINES ---"

 1634   44C4               		STTL "--- OPCODE DISPATCH TABLES ---"
 1635                      	
 1636                      	
 1637                      		; 0-OPS
 1638                      	
 1639   44C4   79          	OPT0H:	DB	>ZRTRUE	;B0
 1640   44C5   79          		DB	>ZRFALS	;B1
 1641   44C6   79          		DB	>ZPRI	;B2
 1642   44C7   79          		DB	>ZPRR	;B3
 1643   44C8   44          		DB	>ZNOOP	;B4
 1644   44C9   8F          		DB	>OSAVE	;B5
 1645   44CA   8F          		DB	>OREST	;B6
 1646   44CB   52          		DB	>ZSTART	;B7
 1647   44CC   79          		DB	>ZRSTAK	;B8
 1648   44CD   79          		DB	>ZCATCH	;B9
 1649   44CE   52          		DB	>ZQUIT	;BA
 1650   44CF   54          		DB	>ZZCRLF	;BB
 1651   44D0   55          		DB	>ZUSL	;BC
 1652   44D1   5B          		DB	>ZVER	;BD
 1653   44D2   41          		DB	>ZEXTOP	;BE
 1654   44D3   79          		DB	>ZORIG	;BF
 1655                      	
 1656   44D4   84          	OPT0L:	DB	<ZRTRUE	;B0
 1657   44D5   8F          		DB	<ZRFALS	;B1
 1658   44D6   93          		DB	<ZPRI	;B2
 1659   44D7   A9          		DB	<ZPRR	;B3
 1660   44D8   A3          		DB	<ZNOOP	;B4
 1661   44D9   8E          		DB	<OSAVE	;B5
 1662   44DA   8E          		DB	<OREST	;B6
 1663   44DB   A0          		DB	<ZSTART	;B7
 1664   44DC   B2          		DB	<ZRSTAK	;B8
 1665   44DD   B8          		DB	<ZCATCH	;B9
 1666   44DE   0D          		DB	<ZQUIT	;BA
 1667   44DF   D6          		DB	<ZZCRLF	;BB
 1668   44E0   BD          		DB	<ZUSL	;BC
 1669   44E1   DD          		DB	<ZVER	;BD
 1670   44E2   E4          		DB	<ZEXTOP	;BE
 1671   44E3   C1          		DB	<ZORIG	;BF
 1672                      	
 1673                      		; 1-OPS
 1674                      	
 1675   44E4   79          	OPT1H:	DB	>ZZERO	;80,90,A0
 1676   44E5   79          		DB	>ZNEXT	;81
 1677   44E6   79          		DB	>ZFIRST	;82
 1678   44E7   7A          		DB	>ZLOC	;83
 1679   44E8   7A          		DB	>ZPTSIZ	;84
 1680   44E9   7A          		DB	>ZINC	;85
 1681   44EA   7A          		DB	>ZDEC	;86
 1682   44EB   7A          		DB	>ZPRB	;87
 1683   44EC   7F          		DB	>ZCALL1	;88 (EZIP)
 1684   44ED   7A          		DB	>ZREMOV	;89
 1685   44EE   7B          		DB	>ZPRD	;8A
 1686   44EF   7B          		DB	>ZRET	;8B
 1687   44F0   7B          		DB	>ZJUMP	;8C
 1688   44F1   7B          		DB	>ZPRINT	;8D
 1689   44F2   7C          		DB	>ZVALUE	;8E
 1690   44F3   7F          		DB	>ZICLL1	;8F
 1691                      	
 1692   44F4   C4          	OPT1L:	DB	<ZZERO	;80
 1693   44F5   CD          		DB	<ZNEXT	;81
 1694   44F6   DC          		DB	<ZFIRST	;82
 1695   44F7   04          		DB	<ZLOC	;83
 1696   44F8   2A          		DB	<ZPTSIZ	;84
 1697   44F9   55          		DB	<ZINC	;85
 1698   44FA   63          		DB	<ZDEC	;86
 1699   44FB   7A          		DB	<ZPRB	;87
 1700   44FC   E0          		DB	<ZCALL1	;88 (EZIP)
 1701   44FD   8C          		DB	<ZREMOV	;89
 1702   44FE   5D          		DB	<ZPRD	;8A
 1703   44FF   84          		DB	<ZRET	;8B
 1704   4500   EF          		DB	<ZJUMP	;8C
 1705   4501   F5          		DB	<ZPRINT	;8D
 1706   4502   03          		DB	<ZVALUE	;8E
 1707   4503   D9          		DB	<ZICLL1	;8F
 1708                      	
  Tue Jun 13 1989 11:42                                                                                                  Page   28

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE DISPATCH TABLES ---"

 1709                      		; 2-OPS
 1710                      	
 1711   4504   43          	OPT2H:	DB	>BADOP2	;00 (UNDEFINED)
 1712   4505   7F          		DB	>ZEQUAL	;01
 1713   4506   7C          		DB	>ZLESS	;02
 1714   4507   7C          		DB	>ZGRTR	;03
 1715   4508   7C          		DB	>ZDLESS	;04
 1716   4509   7C          		DB	>ZIGRTR	;05
 1717   450A   7C          		DB	>ZIN	;06
 1718   450B   7C          		DB	>ZBTST	;07
 1719   450C   7C          		DB	>ZBOR	;08
 1720   450D   7C          		DB	>ZBAND	;09
 1721   450E   7C          		DB	>ZFSETP	;0A
 1722   450F   7C          		DB	>ZFSET	;0B
 1723   4510   7C          		DB	>ZFCLR	;0C
 1724   4511   7C          		DB	>ZSET	;0D
 1725   4512   7C          		DB	>ZMOVE	;0E
 1726   4513   7D          		DB	>ZGET	;0F
 1727   4514   7D          		DB	>ZGETB	;10
 1728   4515   7D          		DB	>ZGETP	;11
 1729   4516   7D          		DB	>ZGETPT	;12
 1730   4517   7E          		DB	>ZNEXTP	;13
 1731   4518   7E          		DB	>ZADD	;14
 1732   4519   7E          		DB	>ZSUB	;15
 1733   451A   7E          		DB	>ZMUL	;16
 1734   451B   7E          		DB	>ZDIV	;17
 1735   451C   7E          		DB	>ZMOD	;18
 1736   451D   7F          		DB	>ZCALL2	;19 (EZIP)
 1737   451E   7F          		DB	>ZICLL2	;1A
 1738   451F   4E          		DB	>ZCOLOR	;1B
 1739   4520   7F          		DB	>ZTHROW	;1C
 1740   4521   43          		DB	>BADOP2	;1D
 1741   4522   43          		DB	>BADOP2	;1E
 1742   4523   43          		DB	>BADOP2	;1F
 1743                      	
 1744   4524   07          	OPT2L:	DB	<BADOP2	;00 (UNDEFINED)
 1745   4525   AD          		DB	<ZEQUAL	;01
 1746   4526   0B          		DB	<ZLESS	;02
 1747   4527   1F          		DB	<ZGRTR	;03
 1748   4528   11          		DB	<ZDLESS	;04
 1749   4529   2A          		DB	<ZIGRTR	;05
 1750   452A   5B          		DB	<ZIN		;06
 1751   452B   7B          		DB	<ZBTST	;07
 1752   452C   8E          		DB	<ZBOR	;08
 1753   452D   9E          		DB	<ZBAND	;09
 1754   452E   AA          		DB	<ZFSETP	;0A
 1755   452F   BE          		DB	<ZFSET	;0B
 1756   4530   D6          		DB	<ZFCLR	;0C
 1757   4531   F2          		DB	<ZSET	;0D
 1758   4532   FF          		DB	<ZMOVE	;0E
 1759   4533   58          		DB	<ZGET	;0F
 1760   4534   68          		DB	<ZGETB	;10
 1761   4535   89          		DB	<ZGETP	;11
 1762   4536   F2          		DB	<ZGETPT	;12
 1763   4537   5F          		DB	<ZNEXTP	;13
 1764   4538   80          		DB	<ZADD	;14
 1765   4539   8D          		DB	<ZSUB	;15
 1766   453A   9A          		DB	<ZMUL	;16
 1767   453B   C4          		DB	<ZDIV	;17
 1768   453C   D0          		DB	<ZMOD	;18
 1769   453D   E0          		DB	<ZCALL2	;19 (EZIP)
 1770   453E   D9          		DB	<ZICLL2	;1A
 1771   453F   C0          		DB	<ZCOLOR	;1B
 1772   4540   8C          		DB	<ZTHROW	;1C
 1773   4541   07          		DB	<BADOP2	;1D
 1774   4542   07          		DB	<BADOP2	;1E
 1775   4543   07          		DB	<BADOP2	;1F
 1776                      	
 1777                      		; X-OPS
 1778                      	
 1779   4544   7F          	OPTXH:	DB	>ZCALL	;E0
 1780   4545   80          		DB	>ZPUT	;E1
 1781   4546   80          		DB	>ZPUTB	;E2
 1782   4547   81          		DB	>ZPUTP	;E3
 1783   4548   85          		DB	>ZREAD	;E4
  Tue Jun 13 1989 11:42                                                                                                  Page   29

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE DISPATCH TABLES ---"

 1784   4549   81          		DB	>ZPRC	;E5
 1785   454A   81          		DB	>ZPRN	;E6
 1786   454B   81          		DB	>ZRAND	;E7
 1787   454C   82          		DB	>ZPUSH	;E8
 1788   454D   82          		DB	>ZPOP	;E9
 1789   454E   4D          		DB	>ZSPLIT	;EA
 1790   454F   6E          		DB	>ZSCRN	;EB
 1791                      	
 1792                      		; (EZIPS FROM HERE ON)
 1793   4550   7F          		DB	>ZXCALL	;EC
 1794   4551   57          		DB	>ZCLR	;ED
 1795   4552   57          		DB	>ZERASE	;EE
 1796   4553   56          		DB	>ZCURST	;EF
 1797   4554   57          		DB	>ZCURGT	;F0
 1798   4555   70          		DB	>ZLIGHT	;F1
 1799   4556   55          		DB	>ZBUFOUT ;F2
 1800   4557   55          		DB	>ZDIRT	;F3
 1801   4558   57          		DB	>ZDIRIN	;F4 (NOT IMPLEMENTED)
 1802   4559   4E          		DB	>ZSOUND	;F5
 1803   455A   5A          		DB	>ZINPUT	;F6
 1804   455B   82          		DB	>ZINTBL	;F7
 1805   455C   83          		DB	>ZBCOM 	;F8
 1806   455D   7F          		DB	>ZICALL	;F9
 1807   455E   7F          		DB	>ZIXCLL	;FA
 1808   455F   86          		DB	>ZLEX	;FB
 1809   4560   86          		DB	>ZWSTR	;FC
 1810   4561   83          		DB	>ZCOPYT	;FD
 1811   4562   58          		DB	>ZPRNTT	;FE
 1812   4563   84          		DB	>ZASSND	;FF
 1813                      	
 1814   4564   E0          	OPTXL:	DB	<ZCALL	;E0
 1815   4565   E2          		DB	<ZPUT	;E1
 1816   4566   F4          		DB	<ZPUTB	;E2
 1817   4567   10          		DB	<ZPUTP	;E3
 1818   4568   37          		DB	<ZREAD	;E4
 1819   4569   55          		DB	<ZPRC	;E5
 1820   456A   5A          		DB	<ZPRN	;E6
 1821   456B   AB          		DB	<ZRAND	;E7
 1822   456C   2C          		DB	<ZPUSH	;E8
 1823   456D   33          		DB	<ZPOP	;E9
 1824   456E   CD          		DB	<ZSPLIT	;EA
 1825   456F   85          		DB	<ZSCRN	;EB
 1826                      	
 1827                      		; (EZIPS FROM HERE ON)
 1828   4570   E0          		DB	<ZXCALL	;EC
 1829   4571   B8          		DB	<ZCLR	;ED
 1830   4572   99          		DB	<ZERASE	;EE
 1831   4573   D5          		DB	<ZCURST	;EF
 1832   4574   2D          		DB	<ZCURGT	;F0
 1833   4575   34          		DB	<ZLIGHT	;F1
 1834   4576   BE          		DB	<ZBUFOUT ;F2
 1835   4577   C8          		DB	<ZDIRT	;F3
 1836   4578   86          		DB	<ZDIRIN	;F4 (NOT IMPLEMENTED)
 1837   4579   9D          		DB	<ZSOUND	;F5
 1838   457A   FD          		DB	<ZINPUT	;F6
 1839   457B   93          		DB	<ZINTBL	;F7
 1840   457C   30          		DB	<ZBCOM 	;F8
 1841   457D   D9          		DB	<ZICALL	;F9
 1842   457E   D9          		DB	<ZIXCLL	;FA
 1843   457F   9F          		DB	<ZLEX	;FB
 1844   4580   D7          		DB	<ZWSTR	;FC
 1845   4581   3F          		DB	<ZCOPYT	;FD
 1846   4582   2F          		DB	<ZPRNTT	;FE
 1847   4583   2F          		DB	<ZASSND	;FF
 1848                      	
 1849                      	
 1850   4584   8D          	EXTOPH:	DB	>ZSAVE	;100
 1851   4585   8E          		DB	>ZREST	;101
 1852   4586   84          		DB	>ZSHIFT	;102
 1853   4587   84          		DB	>ZASHFT	;103
 1854   4588   58          		DB	>ZFONT	;104
 1855   4589   74          		DB	>ZDISPL	;105
 1856   458A   78          		DB	>ZPICNF	;106
 1857   458B   79          		DB	>ZDCLR	;107
 1858   458C   4E          		DB	>ZMARG	;108
  Tue Jun 13 1989 11:42                                                                                                  Page   30

        "APPLE YZIP (c)Infocom, Inc.. --- INIT & MAINLINE"
        "--- OPCODE DISPATCH TABLES ---"

 1859   458D   8F          		DB	>ZISAVE	;109
 1860   458E   8F          		DB	>ZIREST	;10A
 1861   458F   42          		DB	>BADEXT	;10B - NOT USED
 1862   4590   42          		DB	>BADEXT	;10C - NOT USED
 1863   4591   42          		DB	>BADEXT	;10D - NOT USED
 1864   4592   42          		DB	>BADEXT	;10E - NOT USED
 1865   4593   42          		DB	>BADEXT	;10F - NOT USED
 1866   4594   6F          		DB	>ZWINPOS ;110
 1867   4595   6F          		DB	>ZWINSIZE ;111
 1868   4596   70          		DB	>ZWINATTR ;112
 1869   4597   70          		DB	>ZWINGET  ;113
 1870   4598   71          		DB	>ZSCROLL  ;114
 1871   4599   84          		DB	>ZFSTACK  ;115
 1872   459A   85          		DB	>ZMINFO	  ;116
 1873   459B   85          		DB	>ZMLIMIT  ;117
 1874   459C   84          		DB	>ZXPUSH	  ;118
 1875   459D   71          		DB	>ZWINPUT  ;119
 1876   459E   58          		DB	>ZPRINTF  ;11A
 1877   459F   85          		DB	>ZMENU	  ;11B
 1878   45A0   79          		DB	>ZPICSET  ;11c
 1879                      	
 1880          001D        	EXTLEN	EQU	$-EXTOPH
 1881                      	
 1882   45A1   21          	EXTOPL:	DB	<ZSAVE	;100
 1883   45A2   0C          		DB	<ZREST	;101
 1884   45A3   3E          		DB	<ZSHIFT	;102
 1885   45A4   64          		DB	<ZASHFT	;103
 1886   45A5   D8          		DB	<ZFONT	;104
 1887   45A6   1F          		DB	<ZDISPL	;105
 1888   45A7   C1          		DB	<ZPICNF	;106
 1889   45A8   43          		DB	<ZDCLR	;107
 1890   45A9   40          		DB	<ZMARG	;108
 1891   45AA   8F          		DB	<ZISAVE	;109
 1892   45AB   8F          		DB	<ZIREST	;10A
 1893   45AC   00          		DB	<BADEXT	;10B - NOT USED
 1894   45AD   00          		DB	<BADEXT	;10C - NOT USED
 1895   45AE   00          		DB	<BADEXT	;10D - NOT USED
 1896   45AF   00          		DB	<BADEXT	;10E - NOT USED
 1897   45B0   00          		DB	<BADEXT	;10F - NOT USED
 1898   45B1   22          		DB	<ZWINPOS ;110
 1899   45B2   8F          		DB	<ZWINSIZE ;111
 1900   45B3   5C          		DB	<ZWINATTR ;112
 1901   45B4   C7          		DB	<ZWINGET  ;113
 1902   45B5   8F          		DB	<ZSCROLL  ;114
 1903   45B6   E7          		DB	<ZFSTACK  ;115
 1904   45B7   2D          		DB	<ZMINFO	  ;116
 1905   45B8   2D          		DB	<ZMLIMIT  ;117
 1906   45B9   82          		DB	<ZXPUSH	  ;118
 1907   45BA   D4          		DB	<ZWINPUT  ;119
 1908   45BB   9B          		DB	<ZPRINTF  ;11A
 1909   45BC   2E          		DB	<ZMENU	  ;11B
 1910   45BD   43          		DB	<ZPICSET  ;11C
 1911                      	
 1912   45BE               		END
 1913                      	
 1914                      	
 1915   45BE               		TITLE 	"APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
 1916   45BE               		INCLUDE		ZDOS.ASM
 1917   45BE               		STTL "--- ZDOS (SEEKING, READING, WRITING) ---"
 1918                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page   31

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 1919                      	;
 1920                      	; some ProDOS parameter blocks here
 1921                      	;
 1922                      	READ_PB:			; for READING files
 1923   45BE   04          		db	4		; 4 parameters
 1924   45BF   00          	GMREF:	db	0		; refnum
 1925   45C0   0008        		dw	IOBUFF		; read into io buffer
 1926   45C2   0002        		dw	PAGELEN		; 512 byte buffer
 1927   45C4   0000        		dw	0		; length actually read
 1928                      	OPEN_FILE:			; opening up the pure file
 1929   45C6   03          		db	3		; 3 parameters
 1930   45C7   6746        		dw	GAME1NM		; name of pure file
 1931   45C9   0011        		dw	GAME1FIO	; game file buffer
 1932   45CB   00          		db	0		; where refnum goes
 1933   45CC               	PSEEK:	
 1934   45CC   02          		db	2	; 2 pararmeters
 1935   45CD   00          		db	0	; refnum
 1936   45CE   00 00 00    		db 	0,0,0	; 3 byte new file pos
 1937   45D1               	SET_PB:
 1938   45D1   01          		db	1	; just one parameter
 1939   45D2   8B46        		dw	GAMEPL	; where to go to
 1940                      	;
 1941                      	; some messages
 1942                      	;
 1943   45D4   0D 54 61 6B 65 	SWAPSAVE: db    EOL, "Take out save disk and insert ", EOL
        45D9   20 6F 75 74 20 
        45DE   73 61 76 65 20 
        45E3   64 69 73 6B 20 
        45E8   61 6E 64 20 69 
        45ED   6E 73 65 72 74 
        45F2   20 0D 
 1944          0020        	SWAPSAVEL EQU   $-SWAPSAVE
 1945   45F4   67 61 6D 65 20 	NOSWAP: db      "game disk."
        45F9   64 69 73 6B 2E 
 1946          000A        	NOSWAPL EQU     $-NOSWAP
 1947   45FE   0D 49 6E 73 65 	INS_MSG: db     EOL,"Insert "
        4603   72 74 20 
 1948          0008        	INS_MSGL EQU    $-INS_MSG
 1949   4606   2C 20 53 69 64 	SIDEMSG: db	", Side "
        460B   65 20 
 1950          0007        	SIDEMSGL EQU	$-SIDEMSG
 1951   460D   2C 20 69 6E 20 	DRIVE_MSG: db ", in Disk Drive "
        4612   44 69 73 6B 20 
        4617   44 72 69 76 65 
        461C   20 
 1952          0010        	DRIVE_MSGL EQU  $-DRIVE_MSG
 1953                      	
 1954   461D   0D 48 61 76 69 	RESEAT_MSG1: db EOL, "Having problems reading side #"
        4622   6E 67 20 70 72 
        4627   6F 62 6C 65 6D 
        462C   73 20 72 65 61 
        4631   64 69 6E 67 20 
        4636   73 69 64 65 20 
        463B   23 
 1955          001F        	RESEAT_MSG1L EQU   $-RESEAT_MSG1
 1956   463C   2E 0D 50 6C 65 	RESEAT_MSG2: db ".",EOL,"Please re-insert it.",EOL,EOL
        4641   61 73 65 20 72 
        4646   65 2D 69 6E 73 
        464B   65 72 74 20 69 
        4650   74 2E 0D 0D 
 1957          0018        	RESEAT_MSG2L EQU $-RESEAT_MSG2
 1958          [01]        		IF CHECKSUM
 1959                      	RETRYING: db	"RETRYING . . ."
 1960                      	RETRYINGL EQU $-RETRYING
 1961          [00]        		ENDIF
 1962                      	;
 1963                      	; place to stash prefixes and names
 1964                      	;
 1965                      	GPRE_PB:		; game prefix spot
 1966   4654   01          		db	1		; 1 parm
 1967   4655   8B46        		dw	GAMEPL		; where to put prefix
 1968   4657   00          	GAMEL:	db	0
 1969   4658               	GAME:	ds	15	; longest name
 1970                      	
 1971   4667               	GAME1NM:
  Tue Jun 13 1989 11:42                                                                                                  Page   32

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 1972   4667               	GAME1NML:
 1973   4667   00          		db	0	; not sure how long
 1974   4668               	GAME1NAME:
 1975   4668               		BLKB	15,0	; room for name
 1976   4677   00          	GAME1REF: db	0	; save refnum here
 1977   4678   00          	GAME1NUM: db	0	; number (0-3) of side
 1978                      	
 1979   4679               	GAME2NM:
 1980   4679               	GAME2NML:
 1981   4679   00          		db	0	; not sure how long
 1982   467A               	GAME2NAME:
 1983   467A               		BLKB	15,0	; room for name
 1984   4689   00          	GAME2REF: db	0	; refnum for game file 2
 1985   468A   00          	GAME2NUM: db	0	; number (0-3) of side
 1986   468B   00          	GAMEPL: db	0		; name of prefix for game file
 1987   468C               	GAMEP:	ds	64-15		; max len
 1988                      	; --------------------
 1989                      	; READ A VIRTUAL PAGE
 1990                      	; --------------------
 1991                      	; ENTRY: V-BLOCK TO READ IN [DBLOCK]
 1992                      	; BUFFER ADDRESS IN [DBUFF]
 1993                      	; DSKBNK SAYS WHERE TO PUT PAGE (AUX OR MAIN)
 1994                      	; EXIT: DATA AT [DBUFF]
 1995                      	;	
 1996   46BD               	RFLAG: ds 1
 1997   46BE               	RCHKS: ds 1
 1998   46BF               	GETDSK:
 1999   46BF   A9 03       	        lda     #RETRY_COUNT    ; set retry
 2000   46C1   85 16       	        sta     RETRIES         ; just use this for now
 2001                      	
 2002          [01]        		IF	DEBUG
 2003                      		lda	#0
 2004                      		sta	RFLAG		; show no retries
 2005                      		sta	RCHKS		; and checksum for it
 2006          [00]        		ENDIF
 2007                      	
 2008   46C3   20 7A 48    		jsr	FINDSEG		; find the segment and point to it
 2009   46C6               	GETDSKL:
 2010   46C6               		SET_MARK PSEEK		; move to the block
 2011   46C6               		PRODOS	$CE, PSEEK
 2012   46C6   20 00 BF    		jsr	$BF00	; ProDOS handler
 2013   46C9   CE          		DB	$CE	; ProDOS function code
 2014   46CA   CC45        		DW	PSEEK	; Function Parameter Block address
 2015   46CC               		.MACEND
 2016   46CC               		.MACEND
 2017   46CC   B0 26       		bcs	GDBAD		; just die then
 2018   46CE   20 46 48    		jsr	READ_DOS	; do the read, thank you
 2019   46D1   90 08       		bcc     GDEX            ; okay, just fine
 2020   46D3   EE BD 46    		inc	RFLAG
 2021   46D6   20 F7 46    	        jsr     RETRY           ; try again
 2022   46D9   90 EB       	        bcc     GETDSKL         ; try all over
 2023   46DB               	GDEX:
 2024   46DB   AD C5 45    		lda	READ_PB+RD_LENGTH+HI ; Get how much read in
 2025   46DE   CD C3 45    		cmp	READ_PB+RD_BUFFLEN+HI ; same as we wanted?
 2026   46E1   F0 05       		beq	GDEX1		; yes
 2027   46E3   A9 17       		lda	#23
 2028   46E5   4C F9 51    		jmp	ZERROR
 2029   46E8               	GDEX1:
 2030          [01]        		IF	DEBUG
 2031                      		lda	RFLAG		; see if we retried
 2032                      		beq	GDEX3		; nope
 2033                      		lda	RCHKS		; did retry checksum?
 2034                      		bne	GDEX2
 2035                      		inc	RCHKS		; now we have
 2036                      		ldy	#0		; save block
 2037                      		sty	$B00
 2038                      		clc
 2039                      	GDEXL:
 2040                      		lda	IOBUFF,Y
 2041                      		sta	$A00,Y
 2042                      		adc	$B00
 2043                      		sta	$B00
 2044                      		iny
 2045                      		bne	GDEXL
 2046                      		beq	GETDSKL
  Tue Jun 13 1989 11:42                                                                                                  Page   33

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2047                      	GDEX2:
 2048                      		ldy	#0
 2049                      		clc
 2050                      		sty	RFLAG
 2051                      	GDEX2L:
 2052                      		lda	IOBUFF,Y
 2053                      		adc	RFLAG
 2054                      		sta	RFLAG
 2055                      		iny
 2056                      		bne	GDEX2L
 2057                      		lda	RFLAG
 2058                      		cmp	$B00
 2059                      		beq	GDEX3
 2060                      		lda	#24
 2061                      		jmp	ZERROR
 2062          [00]        		ENDIF
 2063   46E8               	GDEX3:
 2064   46E8   A9 08       		lda	#>IOBUFF	; first   256 byte page
 2065   46EA   20 4D 48    		jsr	COPY_DATA	; and copy from IOBUFF to DBUFF
 2066   46ED   E6 B7       		inc	DBUFF+HI	; point to next one
 2067   46EF   A9 09       		lda	#>IOBUFF+1	; next 256 byte page
 2068   46F1   4C 4D 48    		jmp	COPY_DATA	; and copy it over
 2069   46F4               	GDBAD:
 2070   46F4   4C 64 47    		jmp	DISK_FATAL	; just die then
 2071   46F7               	RETRY:
 2072          [01]        		IF	CHECKSUM
 2073                      		DLINE	RETRYING	; show me the way to go  home
 2074          [00]        		ENDIF
 2075                      	
 2076   46F7   C6 16       	        dec     RETRIES         ; count this try
 2077   46F9   30 F9       	        bmi     GDBAD           ; it's dead jim
 2078   46FB   F0 2F       		beq	RETRY0		; ask for reset
 2079   46FD   C9 01       		cmp	#1		; down to last time?
 2080   46FF   D0 61       	        bne     RETRYX          ; just try again
 2081   4701   AD CE 45    		lda	PSEEK+SM_FPOS+0
 2082   4704   48          		pha
 2083   4705   AD CF 45    		lda	PSEEK+SM_FPOS+1
 2084   4708   48          		pha
 2085   4709   AD D0 45    		lda	PSEEK+SM_FPOS+2
 2086   470C   48          		pha
 2087   470D   A9 00       		lda	#0		; seek to zero
 2088   470F   8D CE 45    		sta	PSEEK+SM_FPOS+0 ; save here for now
 2089   4712   8D CF 45    		sta	PSEEK+SM_FPOS+1 ; save here for now
 2090   4715   8D D0 45    		sta	PSEEK+SM_FPOS+2 ; save here for now
 2091   4718               		SET_MARK PSEEK		; move to the block
 2092   4718               		PRODOS	$CE, PSEEK
 2093   4718   20 00 BF    		jsr	$BF00	; ProDOS handler
 2094   471B   CE          		DB	$CE	; ProDOS function code
 2095   471C   CC45        		DW	PSEEK	; Function Parameter Block address
 2096   471E               		.MACEND
 2097   471E               		.MACEND
 2098   471E   68          		pla
 2099   471F   8D D0 45    		sta	PSEEK+SM_FPOS+2
 2100   4722   68          		pla
 2101   4723   8D CF 45    		sta	PSEEK+SM_FPOS+1
 2102   4726   68          		pla
 2103   4727   8D CE 45    		sta	PSEEK+SM_FPOS+0
 2104   472A   90 36       		bcc	RETRYX		; all done
 2105   472C               	RETRY0:
 2106   472C   48          	        pha                     ; save disk error
 2107   472D   20 99 4C    	        jsr     SWAP2INFOW      ; go to window zero
 2108   4730               	        DLINE   RESEAT_MSG1     ; ask to move the disk around
 2109   4730   A2 1D       		ldx	#<RESEAT_MSG1	; get part of RESEAT_MSG1
 2110   4732   A9 46       		lda	#>RESEAT_MSG1	; get other part of string
 2111          [01]        		IFMA	2		; check to see if length passed in
 2112                      		ldy			; then just fetch it
 2113          [01]        		ELSE
 2114   4734   A0 1F       		ldy	#RESEAT_MSG1L	; get length of string
 2115          [00]        		ENDIF
 2116   4736   20 5B 4C    		jsr	DLINE		; print the string
 2117   4739               		.MACEND
 2118   4739   AD BF 45    	        lda     GMREF           ; get ref num
 2119   473C   CD 89 46    	        cmp     GAME2REF        ; game2?
 2120   473F   D0 08       	        bne     RETRY1          ; nope
 2121   4741   AC 79 46    	        ldy     GAME2NML        ; get length
  Tue Jun 13 1989 11:42                                                                                                  Page   34

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2122   4744   B9 79 46    	        lda     GAME2NM,Y       ; and side #
 2123   4747   D0 06       	        bne     RETRY2          ; and continue
 2124   4749               	RETRY1:
 2125   4749   AC 67 46    	        ldy     GAME1NML        ; get length
 2126   474C   B9 67 46    	        lda     GAME1NM,Y       ; and side #
 2127   474F               	RETRY2:
 2128   474F   20 A9 5D    	        jsr     CHAR            ; send char out there
 2129   4752               	        DLINE   RESEAT_MSG2     ; and finish statement
 2130   4752   A2 3C       		ldx	#<RESEAT_MSG2	; get part of RESEAT_MSG2
 2131   4754   A9 46       		lda	#>RESEAT_MSG2	; get other part of string
 2132          [01]        		IFMA	2		; check to see if length passed in
 2133                      		ldy			; then just fetch it
 2134          [01]        		ELSE
 2135   4756   A0 18       		ldy	#RESEAT_MSG2L	; get length of string
 2136          [00]        		ENDIF
 2137   4758   20 5B 4C    		jsr	DLINE		; print the string
 2138   475B               		.MACEND
 2139   475B   68          	        pla                     ; get disk error back
 2140   475C   20 7A 47    	        jsr     DISK_ERR        ; tell the error
 2141   475F   20 B9 4C    	        jsr     SWAPBACK        ; back to current window
 2142   4762               	RETRYX:
 2143   4762   18          	        clc                     ; show goodness
 2144   4763   60          	        rts                     ; and done
 2145                      	;
 2146                      	; this is the fatal error spot
 2147                      	;
 2148   4764               	DISK_FATAL:
 2149   4764   20 7A 47    		jsr	DISK_ERR	; print out problem
 2150   4767               	DRIVE_ERR:
 2151   4767   A9 0E       		lda	#14
 2152   4769   4C F9 51    		jmp	ZERROR		; DRIVE ACCESS ERROR
 2153                      	;
 2154                      	; this routine prints out the string associated with the error and 
 2155                      	; returns with the carry set, like most routines do when there is
 2156                      	; an error.  The error should be in [A].
 2157                      	;
 2158   476C   50 72 6F 44 4F 	UNK_DISK:	db	"ProDOS error $"
        4771   53 20 65 72 72 
        4776   6F 72 20 24 
 2159          000E        	UNK_DISKL	EQU	$-UNK_DISK
 2160                      	
 2161   477A               	DISK_ERR:
 2162   477A   48          		pha			; save [A]
 2163   477B   20 99 4C    		jsr	SWAP2INFOW	; point to information window
 2164   477E   68          		pla			; get it back
 2165                      	
 2166   477F   A2 1B       		ldx	#ELISTL		; scan the error table
 2167   4781               	DSKE:
 2168   4781   DD 97 6D    		cmp	ELIST,X		;  is it this one
 2169   4784   F0 16       		beq	DSKE1		; ayyup
 2170   4786   CA          		dex			; now skip the address
 2171   4787   CA          		dex			; of the description
 2172   4788   CA          		dex			; point to next error number
 2173   4789   10 F6       		bpl	DSKE		; jump to start
 2174                      	;
 2175                      	; if we are here print out unknown error and it's value
 2176                      	;
 2177   478B   48          		pha			; save [A]
 2178   478C               		DLINE	UNK_DISK	; show error
 2179   478C   A2 6C       		ldx	#<UNK_DISK	; get part of UNK_DISK
 2180   478E   A9 47       		lda	#>UNK_DISK	; get other part of string
 2181          [01]        		IFMA	2		; check to see if length passed in
 2182                      		ldy			; then just fetch it
 2183          [01]        		ELSE
 2184   4790   A0 0E       		ldy	#UNK_DISKL	; get length of string
 2185          [00]        		ENDIF
 2186   4792   20 5B 4C    		jsr	DLINE		; print the string
 2187   4795               		.MACEND
 2188   4795   68          		pla			; get [A]
 2189   4796   20 C3 47    		jsr	HEXNUM		; print [A]
 2190   4799   4C BB 47    		jmp	DSK_EXIT	; done
 2191   479C               	DSKE1:
 2192   479C   E8          		inx			; point to string address
 2193   479D   BD 97 6D    		lda	ELIST,X		; get lo part
 2194   47A0   85 7E       		sta	L+LO		; save it
  Tue Jun 13 1989 11:42                                                                                                  Page   35

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2195   47A2   E8          		inx			; point to hi part
 2196   47A3   BD 97 6D    		lda	ELIST,X		; get hi part
 2197   47A6   AA          		tax			; save here
 2198   47A7   85 7F       		sta	L+HI		; and here
 2199   47A9   A0 00       		ldy	#0		; for offset
 2200   47AB   B1 7E       		lda	(L),Y		; get length of string
 2201   47AD   A8          		tay			; save in y
 2202   47AE   E6 7E       		inc	L+LO		; point past length
 2203   47B0   A5 7E       		lda	L+LO		; get it
 2204   47B2   D0 01       		bne	DSKPR		; for printing
 2205   47B4   E8          		inx			; wrapped
 2206   47B5               	DSKPR:
 2207   47B5   8A          		txa			; hi part in a
 2208   47B6   A6 7E       		ldx	L+LO		; lo part in X
 2209   47B8   20 5B 4C    		jsr	DLINE		; print out message
 2210   47BB               	DSK_EXIT:	
 2211   47BB   20 0D 8D    		jsr	GETRET		; wait for RETURN
 2212   47BE   20 B9 4C    		jsr	SWAPBACK	; all done
 2213   47C1   38          		sec			; show badness again
 2214   47C2   60          		rts			; and be done with it
 2215                      	;
 2216                      	; HEXNUM - print out the HEX value of [A] at the current cursor
 2217                      	; 	location
 2218                      	;
 2219   47C3               	HEXNUM:
 2220   47C3   48          		pha
 2221   47C4   4A          		lsr	A
 2222   47C5   4A          		lsr	A
 2223   47C6   4A          		lsr	A
 2224   47C7   4A          		lsr	A
 2225   47C8   20 CC 47    		jsr	NIB1
 2226   47CB   68          		pla
 2227   47CC               	NIB1:
 2228   47CC   29 0F       		and	#%00001111
 2229   47CE   A8          		tay
 2230   47CF   B9 D6 47    		lda	HCHARS,Y
 2231   47D2   20 A9 5D    		jsr	CHAR			; print it out
 2232   47D5   60          		rts
 2233   47D6   30 31 32 33 34 	HCHARS:	DB	"0123456789ABCDEF"
        47DB   35 36 37 38 39 
        47E0   41 42 43 44 45 
        47E5   46 
 2234                      	
 2235                      	; ----------------------
 2236                      	; WRITE [DBUFF] TO DISK
 2237                      	; ----------------------
 2238                      	; ENTRY: File already open and positioned, ready to be written to
 2239                      	;	 from page in (DBUFF).  Writes out 512bytes, starting @ DBUFF.
 2240                      	; EXIT: CARRY CLEAR IF OKAY, SET IF FAILED
 2241                      	
 2242   47E6               	PUTDSK:
 2243   47E6   A6 B8       		ldx	DSKBNK		; get bank
 2244   47E8   A0 00       		ldy	#0		; clear Y
 2245   47EA   A9 08       	        lda     #>IOBUFF        ; first buffer
 2246   47EC   20 EE 00    		jsr	SAVE_DATA	; and copy from DBUFF to IOBUFF
 2247                      	
 2248          [01]        		IF	CHECKSUM == 1
 2249                      		lda	#>IOBUFF
 2250                      		jsr	CKS_BLOCK
 2251          [00]        		ENDIF
 2252                      	
 2253   47EF   20 24 48    		jsr	NEXT_DBUFF	; point to next buffer
 2254   47F2   A6 B8       	        ldx     DSKBNK          ; go get new DSKBNK
 2255   47F4   A0 00       	        ldy     #0              ; clear Y again
 2256   47F6   A9 09       	        lda     #>IOBUFF+1      ; top part
 2257   47F8   20 EE 00    	        jsr     SAVE_DATA       ; copy to IOBUFF
 2258                      	
 2259          [01]        		IF	CHECKSUM == 1
 2260                      		lda	#>IOBUFF+1
 2261                      		jsr	CKS_BLOCK
 2262          [00]        		ENDIF
 2263                      	
 2264   47FB   20 24 48    	        jsr     NEXT_DBUFF      ; count buffer
 2265   47FE   4C 3F 48    		jmp	WRITE_DOS	; and now write it
 2266                      	; ---------------------
  Tue Jun 13 1989 11:42                                                                                                  Page   36

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2267                      	; READ DBLOCK FROM DISK
 2268                      	; ---------------------
 2269                      	; CALLED BY RESTORE
 2270                      	; ENTER: with file already set up as it DBUFF
 2271                      	;	L+LO == # of 256k blocks to read
 2272                      	;
 2273   4801               	GETRES:
 2274   4801   A5 7E       		lda	L+LO		; get # of blocks
 2275   4803   8D C3 45    		sta	READ_PB+RD_BUFFLEN+HI
 2276   4806   20 46 48    		jsr	READ_DOS	
 2277   4809   A2 02       		ldx	#>PAGELEN	; get starting number of pages
 2278   480B   8E C3 45    		stx	READ_PB+RD_BUFFLEN+HI
 2279   480E   90 01       		bcc	GTROK		; everything is fine
 2280   4810   60          		rts			; error if c == set
 2281   4811               	GTROK:
 2282   4811   A9 08       		lda	#>IOBUFF	; start at first block
 2283   4813   85 7F       		sta	L+HI		; we can use L+HI
 2284   4815               	GTRLOOP:
 2285   4815   A5 7F       		lda 	L+HI		; doing this block
 2286                      	
 2287          [01]        	        IF CHECKSUM == 1
 2288                      	        jsr     CKS_BLOCK       ; check check sum        
 2289          [00]        	        ENDIF
 2290                      	
 2291   4817   20 4D 48    		jsr	COPY_DATA	; and copy from IOBUFF to DBUFF
 2292   481A   20 24 48    		jsr	NEXT_DBUFF	; check for wrap
 2293   481D   E6 7F       		inc	L+HI		; count this block
 2294   481F   C6 7E       		dec	L+LO		; count this block
 2295   4821   D0 F2       		bne	GTRLOOP		; do next one
 2296   4823   60          		rts			; all finished
 2297                      	;
 2298                      	; NEXT_DBUFF
 2299                      	;       increment DBUFF to count the 2 pages done
 2300                      	;
 2301   4824               	NEXT_DBUFF:
 2302   4824   E6 B7       		inc	DBUFF+HI	; point to next page
 2303   4826   A5 B7       		lda	DBUFF+HI	; see where we are
 2304   4828   C9 BF       		cmp	#>PRGLBL	; wrapping?
 2305   482A   D0 10       		bne	GTREX		; okay then
 2306   482C   A5 B8       		lda	DSKBNK		; which bank we be in
 2307   482E   D0 06       		bne	GTR1		; aux, so go to page 3
 2308   4830   E6 B8       		inc	DSKBNK		; point to aux
 2309   4832   A9 40       		lda	#Z2PAGE		; start of page 2
 2310   4834   D0 06       	        bne     GTREX           ; so tell me which page
 2311   4836               	GTR1:
 2312   4836   A9 FF       		lda	#P3BANK		; show page 3 bank
 2313   4838   85 B8       		sta	DSKBNK		; okay
 2314   483A   A9 D0       		lda	#Z3PAGE		; page 3 of things
 2315   483C               	GTREX:
 2316   483C   85 B7       		sta	DBUFF+HI	; saved
 2317   483E   60          		rts			; all done		
 2318                      	;
 2319   483F               	WRITE_DOS:
 2320   483F               		WRITE	WRITE_SV	; write out save buffer
 2321   483F               		PRODOS	$CB, WRITE_SV
 2322   483F   20 00 BF    		jsr	$BF00	; ProDOS handler
 2323   4842   CB          		DB	$CB	; ProDOS function code
 2324   4843   368B        		DW	WRITE_SV	; Function Parameter Block address
 2325   4845               		.MACEND
 2326   4845               		.MACEND
 2327   4845   60          		rts			; done
 2328   4846               	READ_DOS:
 2329   4846               		READ	READ_PB		; read it
 2330   4846               		PRODOS	$CA, READ_PB
 2331   4846   20 00 BF    		jsr	$BF00	; ProDOS handler
 2332   4849   CA          		DB	$CA	; ProDOS function code
 2333   484A   BE45        		DW	READ_PB	; Function Parameter Block address
 2334   484C               		.MACEND
 2335   484C               		.MACEND
 2336   484C   60          		rts			; go home
 2337                      	;
 2338                      	; COPY_DATA - 
 2339                      	; now move the data from iobuff to dbuff (in some bank)
 2340                      	;	which part of IOBUFF is in [a] ($08 - $0B)
 2341                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page   37

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2342   484D               	COPY_DATA:
 2343   484D   8D 69 48    		sta	SDLP3+2		; self-modify code to get from IOBUFF
 2344   4850   8D 02 C0    		sta	RDBNK+MAIN	; read from main
 2345   4853   A6 B8       		ldx	DSKBNK		; get which bank it's going to
 2346   4855   30 05       		bmi	CPD1		; oh oh, third bank
 2347   4857   9D 04 C0    		sta	WRTBNK,X	; and select that bank for writing
 2348   485A   10 07       		bpl	CPD2		; okay, bank selected
 2349   485C               	CPD1:
 2350   485C   A5 B7       		lda	DBUFF+HI	; get from this zero page
 2351   485E   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
 2352   4861   85 B7       		sta	DBUFF+HI	; and save this in aux mem ZP
 2353   4863               	CPD2:
 2354   4863   A0 00       		ldy	#0		; start at beginning
 2355   4865   84 B6       		sty	DBUFF+LO	; just to be sure
 2356   4867               	SDLP3:
 2357   4867   B9 00 08    		lda	IOBUFF,Y	; this becomes modified!
 2358   486A   91 B6       		sta	(DBUFF),Y	; to [DBUFF]
 2359   486C   C8          		iny		
 2360   486D   D0 F8       		bne	SDLP3	
 2361   486F   8D 08 C0    		sta	ALTZP+MAIN	; talk about main page again
 2362   4872   8D 04 C0    		sta	WRTBNK+MAIN	; end up back at main
 2363   4875   60          		rts
 2364                      	;
 2365                      	; Segment table handling routines
 2366                      	;
 2367                      	
 2368                      	;
 2369                      	; FINDSEG - find the Virtual page in DBLOCK by searching through
 2370                      	;	the SEGTBL.
 2371                      	;
 2372   4876               	DISKPAGE: ds	2		; spot to put starting disk page
 2373   4878               	BIGPAGE:  ds	2		; DBLOCK/2 for 512 pages
 2374   487A               	FINDSEG:
 2375   487A   AD 88 6C    		lda	DBLOCK+HI	; work with MSB first
 2376   487D   4A          		lsr	A		; /2
 2377   487E   8D 79 48    		sta	BIGPAGE+HI
 2378   4881   AD 87 6C    		lda	DBLOCK+LO	; now LSB
 2379   4884   6A          		ror	A		; /2
 2380   4885   8D 78 48    		sta	BIGPAGE+LO
 2381   4888   AD 78 46    		lda	GAME1NUM	; get number for disk 1
 2382   488B   20 F1 48    		jsr	SCANSEG		; scan through the current disk table
 2383   488E   AD 77 46    		lda	GAME1REF	; save refnum
 2384   4891   90 0E       		bcc	FNDSG1		; found it, figger it out
 2385   4893   AD 8A 46    		lda	GAME2NUM	; get number for disk 2
 2386   4896   20 F1 48    		jsr	SCANSEG		; see if it is here
 2387   4899   AD 89 46    		lda	GAME2REF	; save refnum
 2388   489C   90 03       		bcc	FNDSG1		; ayyup
 2389   489E   20 69 49    		jsr	SEGQUEST	; get correct disk/file with segment
 2390   48A1               	FNDSG1:
 2391   48A1   8D CD 45    		sta	PSEEK+SM_REFNUM	; for seeking
 2392   48A4   8D BF 45    		sta	GMREF		; and for reading
 2393   48A7   B1 1E       		lda	(DSEGS),Y	; pick up MSB of disk page
 2394   48A9   8D 77 48    		sta	DISKPAGE+HI	; save it
 2395   48AC   C8          		iny			; point to LSB
 2396   48AD   B1 1E       		lda	(DSEGS),Y	; get it
 2397   48AF   8D 76 48    		sta	DISKPAGE+LO	; save it
 2398                      	; now point to Starting page again
 2399   48B2   88          		dey
 2400   48B3   88          		dey
 2401   48B4   88          		dey
 2402   48B5   88          		dey
 2403   48B6   AD 78 48    		lda	BIGPAGE+LO	; LSB of desired page
 2404   48B9   38          		sec			; doing subtract
 2405   48BA   F1 1E       		sbc	(DSEGS),Y	; get rid of LSB of starting page
 2406   48BC   8D CF 45    		sta	PSEEK+SM_FPOS+1 ; save here for now
 2407   48BF   88          		dey			; point to MSB of starting page
 2408   48C0   AD 79 48    		lda	BIGPAGE+HI	; get DBLOCK MSB
 2409   48C3   F1 1E       		sbc	(DSEGS),Y	; get offset
 2410   48C5   8D D0 45    		sta	PSEEK+SM_FPOS+2 ; save here temporarily
 2411   48C8   18          		clc			; now add offset to starting disk page
 2412   48C9   AD 76 48    		lda	DISKPAGE+LO	; get starting disk page
 2413   48CC   6D CF 45    		adc	PSEEK+SM_FPOS+1	; add inter-segment offset
 2414   48CF   8D CF 45    		sta	PSEEK+SM_FPOS+1	; save LSB
 2415   48D2   AD 77 48    		lda	DISKPAGE+HI	; get MSB of segment disk page
 2416   48D5   6D D0 45    		adc	PSEEK+SM_FPOS+2	; add inter-segment offset
  Tue Jun 13 1989 11:42                                                                                                  Page   38

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2417   48D8   8D D0 45    		sta	PSEEK+SM_FPOS+2	; save MSB of disk page
 2418   48DB   0E CF 45    		asl	PSEEK+SM_FPOS+1	; *2 for 256Kb pages
 2419   48DE   2E D0 45    		rol	PSEEK+SM_FPOS+2	; okay, we did
 2420   48E1   AD 87 6C    		lda	DBLOCK+LO	; check to see which page in 512 we are
 2421   48E4   29 01       		and	#$01		; if odd, then add one more
 2422   48E6   F0 08       		beq	FNDEX		; all done then
 2423   48E8   EE CF 45    		inc	PSEEK+SM_FPOS+1	; one more page
 2424   48EB   D0 03       		bne	FNDEX		; all done if no wrap
 2425   48ED   EE D0 45    		inc	PSEEK+SM_FPOS+2	; nother page
 2426   48F0               	FNDEX:
 2427   48F0   60          		rts			; done
 2428                      	;
 2429                      	; SCANSEG - look through the current segment table for the desired
 2430                      	;	address found in BIGPAGE.  Return with Y pointing to disk page
 2431                      	;	and carry cleared if found.  Otherwise, return carry set.
 2432                      	;	[A] = which side number we are checking (0-n)
 2433                      	;
 2434   48F1               	SCANSEG:
 2435   48F1   48          		pha			; save which disk
 2436   48F2   0A          		asl	A		; make word index
 2437   48F3   AA          		tax			; make it an index
 2438   48F4   BD D0 1D    		lda	DSKSEG+LO,X	; get LSB
 2439   48F7   85 1E       		sta	DSEGS+LO
 2440   48F9   BD D1 1D    		lda	DSKSEG+HI,X
 2441   48FC   85 1F       		sta	DSEGS+HI
 2442   48FE   A0 05       		ldy	#SGTNSEG+1	; point to segment count
 2443   4900   B1 1E       		lda	(DSEGS),Y	; get it
 2444   4902   AA          		tax			; use x as counter
 2445   4903   68          		pla			; get which side 
 2446   4904   A8          		tay			; is it side zero
 2447   4905   D0 04       		bne	SCANSG1		; nope
 2448   4907   A0 0E       		ldy	#SGTSEG+6	; skip first entry, cuz they're preload
 2449   4909   D0 02       		bne	SCANNING	; okay ready to go
 2450   490B               	SCANSG1:
 2451   490B   A0 08       		ldy	#SGTSEG		; begin at beginning
 2452   490D               	SCANNING:
 2453   490D   B1 1E       		lda	(DSEGS),Y	; get MSB of start
 2454   490F   CD 79 48    		cmp	BIGPAGE+HI	; check against block we want
 2455   4912   F0 06       		beq	SCAN1		; might be okay
 2456   4914   90 0F       		bcc	SCAN2		; PAGE > start seg, check end seg
 2457   4916   C8          	        iny                     ; LSB of start
 2458   4917               	SCAN0:
 2459   4917   C8          	        iny                     ; MSB of end
 2460   4918   B0 1F       	        bcs     NEXTSEG         ; not this one
 2461   491A               	SCAN1:
 2462   491A   C8          		iny			; point to LSB of start
 2463   491B   B1 1E       		lda	(DSEGS),Y	; get LSB
 2464   491D   CD 78 48    		cmp	BIGPAGE+LO	; check against desired LSB
 2465   4920   F0 20       		beq	GOTSEG		; we found it
 2466   4922   B0 F3       		bcs	SCAN0		; DBLOCK LSB < then start LSB, not found
 2467   4924   88          		dey			; point back to MSB of start
 2468   4925               	SCAN2:
 2469   4925   C8          		iny			; LSB of start
 2470   4926   C8          	 	iny			; MSB of end
 2471   4927   B1 1E       		lda	(DSEGS),Y	; get MSB of end
 2472   4929   CD 79 48    		cmp	BIGPAGE+HI	; check against DBLOCK MSB
 2473   492C   90 0B       		bcc	NEXTSEG 	; end < DBLOCK, check next segment
 2474   492E   D0 13       		bne	GOTSEG1		; end > DBLOCK, must be in this segment
 2475   4930   C8          		iny			; point to end LSB
 2476   4931   B1 1E       		lda	(DSEGS),Y	; get LSB
 2477   4933   CD 78 48    		cmp	BIGPAGE+LO	; how does it compare to desired LSB
 2478   4936   B0 0C       		bcs	GOTSEG2		; it's <= end, so it is here
 2479   4938   88          		dey			; point back to MSB
 2480   4939               	NEXTSEG:
 2481   4939   C8          		iny			; point to LSB of end
 2482   493A   C8          		iny			; MSB of disk page
 2483   493B   C8          		iny			; LSB of disk page
 2484   493C   C8          		iny			; MSB of next start page
 2485   493D   CA          		dex			; count this segment
 2486   493E   D0 CD       		bne	SCANNING	; check this segment
 2487                      	
 2488   4940   38          		sec			; show not on this disk
 2489   4941   60          		rts			; and done
 2490   4942               	GOTSEG:
 2491   4942   C8          		iny			; MSB of end page
  Tue Jun 13 1989 11:42                                                                                                  Page   39

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2492   4943               	GOTSEG1:
 2493   4943   C8          		iny			; LSB of end page
 2494   4944               	GOTSEG2:
 2495   4944   C8          		iny			; MSB of disk offset
 2496   4945   18          		clc			; show we found it
 2497   4946   60          		rts			; all done
 2498                      	;
 2499                      	; SEGQUEST - find the correct disk/file with the desired page on
 2500                      	;	it.  Returns SCANSEG's stuff.
 2501                      	;
 2502   4947               	DISKCNTR:	ds	1	; disk count down
 2503   4948               	PAGENF:
 2504   4948   50 61 67 65 20 		db	"Page not found in segment table: "
        494D   6E 6F 74 20 66 
        4952   6F 75 6E 64 20 
        4957   69 6E 20 73 65 
        495C   67 6D 65 6E 74 
        4961   20 74 61 62 6C 
        4966   65 3A 20 
 2505          0021        	PAGENFL	EQU	$-PAGENF
 2506   4969               	SEGQUEST:
 2507   4969   A9 01       		lda	#1		; start at first disk
 2508   496B   8D 47 49    		sta	DISKCNTR	; init counter
 2509   496E               	SEGQL:
 2510   496E   AD 47 49    		lda	DISKCNTR	; get disk
 2511   4971   CD 01 19    		cmp	SEGTBL+SGTDISKS+1	; looked at all the disks?
 2512   4974   D0 24       		bne	SEGQL1		; nope
 2513                      	;
 2514                      	; as a last resort, check disk 1, the boot disk
 2515                      	;
 2516   4976   A9 00       		lda	#0		; set up DISKCNTR
 2517   4978   8D 47 49    		sta	DISKCNTR	; we did
 2518   497B   20 F1 48    		jsr	SCANSEG		; see if it is there
 2519   497E   90 27       		bcc	SEGQ1		; we found it
 2520                      	
 2521   4980               		DLINE	PAGENF		; page not found
 2522   4980   A2 48       		ldx	#<PAGENF	; get part of PAGENF
 2523   4982   A9 49       		lda	#>PAGENF	; get other part of string
 2524          [01]        		IFMA	2		; check to see if length passed in
 2525                      		ldy			; then just fetch it
 2526          [01]        		ELSE
 2527   4984   A0 21       		ldy	#PAGENFL	; get length of string
 2528          [00]        		ENDIF
 2529   4986   20 5B 4C    		jsr	DLINE		; print the string
 2530   4989               		.MACEND
 2531   4989   AD 79 48    		lda	BIGPAGE+HI	; show MSB
 2532   498C   20 C3 47    		jsr	HEXNUM		; printed
 2533   498F   AD 78 48    		lda	BIGPAGE+LO	; and LSB
 2534   4992   20 C3 47    		jsr	HEXNUM		; we did
 2535                      	
 2536   4995   A9 11       		lda	#17		; bad page 
 2537   4997   4C F9 51    		jmp	ZERROR		; die a horrible death
 2538   499A               	SEGQL1:
 2539   499A   AD 47 49    		lda	DISKCNTR	; get which disk we be working on
 2540   499D   20 F1 48    		jsr	SCANSEG		; find out if it is here
 2541   49A0   90 05       		bcc	SEGQ1		; it is, so open up file
 2542   49A2   EE 47 49    		inc	DISKCNTR	; not in this disk
 2543   49A5   D0 C7       		bne	SEGQL		; and try again
 2544                      	;
 2545                      	; we have found the disk it is in, so ask for it if necessary
 2546                      	;
 2547   49A7               	SEGQ1:
 2548   49A7   98          		tya			; save the y pointer
 2549   49A8   48          		pha			; it is saved
 2550   49A9   AD 47 49    		lda	DISKCNTR	; get which disk we found it under
 2551   49AC   20 B6 49    		jsr	FETCH_FILE	; go get the disk desired
 2552   49AF   68          		pla			; get the Y reg back
 2553   49B0   A8          		tay			; and show it
 2554   49B1   AD BF 45    		lda	GMREF		; get reference number again
 2555   49B4   60          		rts			; all done
 2556                      	;
 2557                      	; FETCH_FILE: check to see if we can open GAMEFILE# (where # is in [A])
 2558                      	; 	if not, ask for DISK#.
 2559                      	;
 2560   49B5   00          	SAVENUM: db	0	; spot to save ascii number  
  Tue Jun 13 1989 11:42                                                                                                  Page   40

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2561   49B6               	FETCH_FILE:
 2562   49B6   18          		clc			; adding to make
 2563   49B7   69 30       		adc	#$30		; it an ascii number
 2564   49B9   8D B5 49    		sta	SAVENUM		; just save a minute
 2565   49BC   EE B5 49    		inc	SAVENUM		; make name be one based
 2566   49BF   AE 67 46    		ldx	GAME1NML	; get length of name
 2567   49C2   AD B5 49    		lda	SAVENUM		; get name back
 2568   49C5   C9 33       		cmp	#'3'		; are we looking for disk 1 or 2?
 2569   49C7   B0 18       		bcs	FEFI1		; disks 3 and up handled special
 2570   49C9               	FEFI00:
 2571   49C9   DD 67 46    		cmp	GAME1NM,X	; is it the current open one?
 2572   49CC   D0 05       		bne	FEFI0		; nope, so we need to open it
 2573   49CE   AC 77 46    		ldy	GAME1REF	; get game 1 refnum
 2574   49D1   D0 35       		bne	FEFIX		; all set, so point to it
 2575   49D3               	FEFI0:
 2576   49D3   20 D1 4A    		jsr	DO_GAME1	; handle it special
 2577   49D6   AD 77 46    	        lda     GAME1REF        ; fetch refnum
 2578   49D9   20 49 76    		jsr	GET_PDATA	; now get the picture data
 2579   49DC   AC 77 46    	        ldy     GAME1REF        ; refetch refnum        
 2580   49DF   D0 27       		bne	FEFIX		; so all done
 2581   49E1               	FEFI1:
 2582   49E1   AE 79 46    	        ldx     GAME2NML        ; get length of second name        
 2583   49E4   DD 79 46    		cmp	GAME2NM,X	; how bout second open file?
 2584   49E7   D0 05       		bne	FEFI2		; nope, so we need to open it
 2585   49E9   AC 89 46    		ldy	GAME2REF	; it is second one, so show me
 2586   49EC   D0 1A       		bne	FEFIX		; it is open too
 2587   49EE               	FEFI2:
 2588   49EE   AD 89 46    		lda	GAME2REF	; get its refnum
 2589   49F1   F0 09       		beq	FEFI20		; nothing to close, thank you
 2590   49F3   8D 35 8B    		sta	CLOSE_PB+CL_REFNUM ; show close who to close
 2591   49F6               		CLOSE	CLOSE_PB	; close it up tight
 2592   49F6               		PRODOS	$CC, CLOSE_PB
 2593   49F6   20 00 BF    		jsr	$BF00	; ProDOS handler
 2594   49F9   CC          		DB	$CC	; ProDOS function code
 2595   49FA   348B        		DW	CLOSE_PB	; Function Parameter Block address
 2596   49FC               		.MACEND
 2597   49FC               		.MACEND
 2598   49FC               	FEFI20:
 2599   49FC   20 0F 4A    		jsr	OPEN_GAME2	; open up GAME2 file
 2600   49FF   AD 89 46    	        lda     GAME2REF        ; get refnum for this file        
 2601   4A02   20 49 76    		jsr	GET_PDATA	; now get the picture data
 2602   4A05   AC 89 46    		ldy	GAME2REF	; get ref back, please
 2603   4A08               	FEFIX:
 2604   4A08   8C CD 45    		sty	PSEEK+SM_REFNUM	; for seeking
 2605   4A0B   8C BF 45    		sty	GMREF		; and for reading
 2606   4A0E   60          		rts			; did it
 2607                      	;
 2608                      	; OPEN_GAME2 - open up the file that GAME2NM is pointing to,
 2609                      	;	returning the REFNUM in [A], after storing in GAME2REF,
 2610                      	;	and the 2 picture structures
 2611                      	;
 2612   4A0F               	OPEN_GAME2:
 2613   4A0F   AE 79 46    	        ldx     GAME2NML        ; get end of name
 2614   4A12   AD B5 49    	        lda     SAVENUM         ; get new name
 2615   4A15   9D 79 46    		sta	GAME2NM,X	; using second file
 2616   4A18   A9 46       		lda	#>GAME2NM	; get lo byte
 2617   4A1A   8D C8 45    		sta	OPEN_FILE+OP_PATHNAME+HI
 2618   4A1D   A9 79       		lda	#<GAME2NM	; set address in open block
 2619   4A1F   8D C7 45    		sta	OPEN_FILE+OP_PATHNAME+LO
 2620   4A22   A9 15       		lda	#>GAME2FIO	; now set up file i/o buffer
 2621   4A24   8D CA 45    		sta	OPEN_FILE+OP_FILEBUFF+HI
 2622   4A27   A9 00       		lda	#<GAME2FIO	; now set up file i/o buffer
 2623   4A29   8D C9 45    		sta	OPEN_FILE+OP_FILEBUFF+LO
 2624   4A2C   20 12 4B    		jsr	OPEN_GAMEF	; find and open game file
 2625   4A2F   AD CB 45    		lda	OPEN_FILE+OP_REFNUM	; get refnum
 2626   4A32   8D 89 46    		sta	GAME2REF	; save refnum here
 2627   4A35   AE 79 46    		ldx	GAME2NML	; get me number of this side
 2628   4A38   BD 79 46    		lda	GAME2NM,X	; get ascii number
 2629   4A3B   49 30       		eor	#'0'		; make it binary
 2630   4A3D   8D 8A 46    		sta	GAME2NUM	; save num
 2631   4A40   CE 8A 46    		dec	GAME2NUM	; make it zero based
 2632   4A43   60          		rts			; finis
 2633                      	;
 2634                      	; SET_GAMEPRE: check if game prefix is in, and if not go ask for it
 2635                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page   41

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2636   4A44   00          	SAVEDISK: db    0               ; swap out save disk?
 2637   4A45   00          	SWAPPED:  db    0               ; <>0 if multi disk game
 2638                      	
 2639   4A46               	SET_GAMEPRE:
 2640   4A46   20 99 4C    		jsr	SWAP2INFOW	; point to info window
 2641   4A49   AD 45 4A    	        lda     SWAPPED         ; are we swapping disks?
 2642   4A4C   F0 0B       	        beq     SETGP           ; nope, don't change game prefix
 2643   4A4E   AD B5 49    		lda	SAVENUM		; get which disk to put it
 2644   4A51   AC 8B 46    	        ldy     GAMEPL          ; get length of prefix
 2645   4A54   88          	        dey                     ; subtract 2 to point to prefix
 2646   4A55   88          	        dey                     ;   number
 2647   4A56   99 8C 46    		sta	GAMEP,Y		; set number for prefix
 2648   4A59               	SETGP:
 2649   4A59   A9 46       		lda	#>GAMEPL	; set up parm block
 2650   4A5B   8D D3 45    		sta	SET_PB+SP_PATHNAME+HI
 2651   4A5E   A9 8B       		lda	#<GAMEPL
 2652   4A60   8D D2 45    		sta	SET_PB+SP_PATHNAME+LO
 2653   4A63               	SETGP0:
 2654   4A63               		SET_PREFIX SET_PB	; set to game file prefix
 2655   4A63               		PRODOS	$C6, SET_PB
 2656   4A63   20 00 BF    		jsr	$BF00	; ProDOS handler
 2657   4A66   C6          		DB	$C6	; ProDOS function code
 2658   4A67   D145        		DW	SET_PB	; Function Parameter Block address
 2659   4A69               		.MACEND
 2660   4A69               		.MACEND
 2661   4A69   90 63       		bcc	SETGP1		; okay, it is
 2662   4A6B   AD 44 4A    		lda	SAVEDISK	; is it a save disk in there?
 2663   4A6E   F0 1A       		beq	SEGTP00		; nope
 2664                      	;
 2665                      	; special stuff for  save disk swapping
 2666                      	;
 2667   4A70               		DLINE	SWAPSAVE	; tell them to take out save disk
 2668   4A70   A2 D4       		ldx	#<SWAPSAVE	; get part of SWAPSAVE
 2669   4A72   A9 45       		lda	#>SWAPSAVE	; get other part of string
 2670          [01]        		IFMA	2		; check to see if length passed in
 2671                      		ldy			; then just fetch it
 2672          [01]        		ELSE
 2673   4A74   A0 20       		ldy	#SWAPSAVEL	; get length of string
 2674          [00]        		ENDIF
 2675   4A76   20 5B 4C    		jsr	DLINE		; print the string
 2676   4A79               		.MACEND
 2677   4A79   AD 45 4A    	        lda     SWAPPED         ; should we ask for specific disk?
 2678   4A7C   D0 15       	        bne     SEGTP01         ; yes, so ask for it
 2679   4A7E               	        DLINE   NOSWAP          ; no, so just get game disk
 2680   4A7E   A2 F4       		ldx	#<NOSWAP	; get part of NOSWAP
 2681   4A80   A9 45       		lda	#>NOSWAP	; get other part of string
 2682          [01]        		IFMA	2		; check to see if length passed in
 2683                      		ldy			; then just fetch it
 2684          [01]        		ELSE
 2685   4A82   A0 0A       		ldy	#NOSWAPL	; get length of string
 2686          [00]        		ENDIF
 2687   4A84   20 5B 4C    		jsr	DLINE		; print the string
 2688   4A87               		.MACEND
 2689   4A87   4C C8 4A    	        jmp     SEGTP03         ; and continue
 2690   4A8A               	SEGTP00:
 2691   4A8A               		DLINE	INS_MSG		; ask for game disk
 2692   4A8A   A2 FE       		ldx	#<INS_MSG	; get part of INS_MSG
 2693   4A8C   A9 45       		lda	#>INS_MSG	; get other part of string
 2694          [01]        		IFMA	2		; check to see if length passed in
 2695                      		ldy			; then just fetch it
 2696          [01]        		ELSE
 2697   4A8E   A0 08       		ldy	#INS_MSGL	; get length of string
 2698          [00]        		ENDIF
 2699   4A90   20 5B 4C    		jsr	DLINE		; print the string
 2700   4A93               		.MACEND
 2701   4A93               	SEGTP01:
 2702   4A93               		DLINE	GAME, GAMEL	; this is the name of the game
 2703   4A93   A2 58       		ldx	#<GAME	; get part of GAME
 2704   4A95   A9 46       		lda	#>GAME	; get other part of string
 2705          [01]        		IFMA	2		; check to see if length passed in
 2706   4A97   AC 57 46    		ldy	GAMEL		; then just fetch it
 2707          [01]        		ELSE
 2708                      		ldy	#GAMEL	; get length of string
 2709          [00]        		ENDIF
 2710   4A9A   20 5B 4C    		jsr	DLINE		; print the string
  Tue Jun 13 1989 11:42                                                                                                  Page   42

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2711   4A9D               		.MACEND
 2712   4A9D               		DLINE	SIDEMSG		; part 2 of message
 2713   4A9D   A2 06       		ldx	#<SIDEMSG	; get part of SIDEMSG
 2714   4A9F   A9 46       		lda	#>SIDEMSG	; get other part of string
 2715          [01]        		IFMA	2		; check to see if length passed in
 2716                      		ldy			; then just fetch it
 2717          [01]        		ELSE
 2718   4AA1   A0 07       		ldy	#SIDEMSGL	; get length of string
 2719          [00]        		ENDIF
 2720   4AA3   20 5B 4C    		jsr	DLINE		; print the string
 2721   4AA6               		.MACEND
 2722   4AA6   AD B5 49    		lda	SAVENUM		; get which disk to put it
 2723   4AA9   20 A9 5D    		jsr	CHAR		; print it out
 2724   4AAC               	        DLINE   DRIVE_MSG       ; tell about drive
 2725   4AAC   A2 0D       		ldx	#<DRIVE_MSG	; get part of DRIVE_MSG
 2726   4AAE   A9 46       		lda	#>DRIVE_MSG	; get other part of string
 2727          [01]        		IFMA	2		; check to see if length passed in
 2728                      		ldy			; then just fetch it
 2729          [01]        		ELSE
 2730   4AB0   A0 10       		ldy	#DRIVE_MSGL	; get length of string
 2731          [00]        		ENDIF
 2732   4AB2   20 5B 4C    		jsr	DLINE		; print the string
 2733   4AB5               		.MACEND
 2734   4AB5   A9 32       	        lda     #'2'            ; assume it's drive 2
 2735   4AB7   AE B5 49    	        ldx     SAVENUM         ; get which disk we want
 2736   4ABA   E0 33       	        cpx     #'3'            ; >= side 3, must be disk drive 2
 2737   4ABC   B0 02       	        bcs     SEGTP02         ; fine, send that message out
 2738   4ABE   A9 31       	        lda     #'1'            ; ask for drive 1 then
 2739   4AC0               	SEGTP02:
 2740   4AC0   20 A9 5D    	        jsr     CHAR            ; save which drive
 2741   4AC3   A9 2E       	        lda     #'.'            ; finish sentence
 2742   4AC5   20 A9 5D    	        jsr     CHAR            ; okay
 2743   4AC8               	SEGTP03:
 2744   4AC8   20 0D 8D    		jsr	GETRET		; wait for <CR>
 2745   4ACB   4C 63 4A    		jmp	SETGP0		; try again
 2746   4ACE               	SETGP1:
 2747   4ACE   4C B9 4C    		jmp	SWAPBACK	; pointing to disk
 2748                      	;
 2749                      	; DO_GAME1 - open up the special game 1 file and point to it
 2750                      	;
 2751   4AD1               	DO_GAME1:
 2752   4AD1   AC 77 46    		ldy	GAME1REF	; get the current game 1 ref num
 2753   4AD4   F0 0B       		beq	DOG1		; not currently open
 2754   4AD6   48          		pha			; save Name
 2755   4AD7   8C 35 8B    		sty	CLOSE_PB+CL_REFNUM	; show close
 2756   4ADA               		CLOSE	CLOSE_PB	; and close it
 2757   4ADA               		PRODOS	$CC, CLOSE_PB
 2758   4ADA   20 00 BF    		jsr	$BF00	; ProDOS handler
 2759   4ADD   CC          		DB	$CC	; ProDOS function code
 2760   4ADE   348B        		DW	CLOSE_PB	; Function Parameter Block address
 2761   4AE0               		.MACEND
 2762   4AE0               		.MACEND
 2763   4AE0   68          		pla			; get name back
 2764   4AE1               	DOG1:
 2765   4AE1   AE 67 46    	        ldx     GAME1NML        ; get length of name
 2766   4AE4   AD B5 49    	        lda     SAVENUM         ; get new number        
 2767   4AE7   9D 67 46    		sta	GAME1NM,X	; save name
 2768   4AEA   48          		pha			; save it for later use
 2769   4AEB   A9 46       		lda	#>GAME1NM	; get lo byte
 2770   4AED   8D C8 45    		sta	OPEN_FILE+OP_PATHNAME+HI
 2771   4AF0   A9 67       		lda	#<GAME1NM	; set address in open block
 2772   4AF2   8D C7 45    		sta	OPEN_FILE+OP_PATHNAME+LO
 2773   4AF5   A9 11       		lda	#>GAME1FIO	; now set up file i/o buffer
 2774   4AF7   8D CA 45    		sta	OPEN_FILE+OP_FILEBUFF+HI
 2775   4AFA   A9 00       		lda	#<GAME1FIO	; now set up file i/o buffer
 2776   4AFC   8D C9 45    		sta	OPEN_FILE+OP_FILEBUFF+LO
 2777   4AFF   20 12 4B    		jsr	OPEN_GAMEF	; so find and open game file
 2778   4B02   68          		pla			; get number back
 2779   4B03   49 30       		eor	#'0'		; make binary
 2780   4B05   8D 78 46    		sta	GAME1NUM	; save number
 2781   4B08   CE 78 46    		dec	GAME1NUM	; decrement for usage
 2782   4B0B   AC CB 45    		ldy	OPEN_FILE+OP_REFNUM	; get refnum
 2783   4B0E   8C 77 46    		sty	GAME1REF	; save refnum here
 2784   4B11   60          		rts			; did it
 2785                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page   43

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2786                      	;OPEN_GAMEF: open the currently pointed to game file, getting the
 2787                      	; disk if necessary (ascii number of disk/file found in SAVENUM)
 2788                      	;
 2789   4B12               	OPEN_GAMEF:
 2790   4B12   A9 00       		lda	#0		; reset volume flag
 2791   4B14   85 1D       		sta	CHPTR+HI	;okay, we be ready
 2792   4B16               	OPGM1:
 2793   4B16               		OPEN	OPEN_FILE	; open the file file
 2794   4B16               		PRODOS	$C8, OPEN_FILE
 2795   4B16   20 00 BF    		jsr	$BF00	; ProDOS handler
 2796   4B19   C8          		DB	$C8	; ProDOS function code
 2797   4B1A   C645        		DW	OPEN_FILE	; Function Parameter Block address
 2798   4B1C               		.MACEND
 2799   4B1C               		.MACEND
 2800   4B1C   90 1F       		bcc	OPGMX		; okay
 2801   4B1E   C9 46       		cmp	#$46		; file not found error?
 2802   4B20   F0 07       		beq	OPGMV		; get the volume
 2803   4B22   C9 45       		cmp	#$45		; volume not found error?
 2804   4B24   F0 03       		beq	OPGMV		; then ask for it
 2805   4B26   4C 7A 47    		jmp	DISK_ERR	; die with ZERROR
 2806   4B29               	OPGMV:
 2807   4B29   20 95 4B    		jsr	CHECKVOLS	; try another volume
 2808   4B2C   90 E8       		bcc	OPGM1		; ==0 if no more volumes to try
 2809   4B2E   AD 44 4A    	        lda     SAVEDISK        ; doing save?
 2810   4B31   D0 05       	        bne     OPGMV1          ; yes, so don't set swap flag
 2811   4B33   A9 01       	        lda     #1              ; set swap flag
 2812   4B35   8D 45 4A    	        sta     SWAPPED         ; we have to swap disks
 2813   4B38               	OPGMV1:
 2814   4B38   20 46 4A    		jsr	SET_GAMEPRE	; okay, set up prefix
 2815   4B3B   90 D5       		bcc	OPEN_GAMEF	; try again
 2816   4B3D               	OPGMX:
 2817   4B3D   60          		rts
 2818                      	;
 2819                      	; LISTVOLS - list all the online volumes for saving to
 2820                      	;
 2821   4B3E               	ONLINE_PB:
 2822   4B3E   02          		db	2	; 2 parms for ONLINE call
 2823   4B3F   00          		db	0	; unit == 0 to get all current ones
 2824   4B40   0008        		dw	IOBUFF	; use IOBUFFER to store names
 2825   4B42   0D 56 6F 6C 75 	LSTVM:	db	EOL,"Volumes: ",EOL
        4B47   6D 65 73 3A 20 
        4B4C   0D 
 2826          000B        	LSTVML	EQU	$-LSTVM
 2827                      	
 2828   4B4D               	LISTVOLS:
 2829   4B4D               		DLINE	LSTVM		; print out intro message
 2830   4B4D   A2 42       		ldx	#<LSTVM	; get part of LSTVM
 2831   4B4F   A9 4B       		lda	#>LSTVM	; get other part of string
 2832          [01]        		IFMA	2		; check to see if length passed in
 2833                      		ldy			; then just fetch it
 2834          [01]        		ELSE
 2835   4B51   A0 0B       		ldy	#LSTVML	; get length of string
 2836          [00]        		ENDIF
 2837   4B53   20 5B 4C    		jsr	DLINE		; print the string
 2838   4B56               		.MACEND
 2839                      	
 2840   4B56               		ONLINE	ONLINE_PB
 2841   4B56               		PRODOS	$C5, ONLINE_PB
 2842   4B56   20 00 BF    		jsr	$BF00	; ProDOS handler
 2843   4B59   C5          		DB	$C5	; ProDOS function code
 2844   4B5A   3E4B        		DW	ONLINE_PB	; Function Parameter Block address
 2845   4B5C               		.MACEND
 2846   4B5C               		.MACEND
 2847   4B5C   90 05       		bcc	LSTV1		; worked fine
 2848   4B5E   20 7A 47    		jsr	DISK_ERR	; complain if we had an error
 2849   4B61   B0 31       		bcs	LSTVEX		; all done
 2850   4B63               	LSTV1:
 2851   4B63   A9 00       		lda	#0		; start at byte zero
 2852   4B65   48          		pha			; saved on stack
 2853   4B66               	LSTVL:
 2854   4B66   68          		pla			; get index
 2855   4B67   AA          		tax			; make it an index
 2856   4B68   BD 00 08    		lda	IOBUFF,X	; get drive/length byte
 2857   4B6B   F0 27       		beq	LSTVEX		; all done if == 0
 2858   4B6D   29 0F       		and	#$0F		; just care about length
  Tue Jun 13 1989 11:42                                                                                                  Page   44

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2859   4B6F   A8          		tay			; save in [Y] for now
 2860   4B70   8A          		txa			; into [A] for addition
 2861   4B71   18          		clc			; doing add
 2862   4B72   69 10       		adc	#16		; point to next entry
 2863   4B74   48          		pha			; save for later reference
 2864   4B75   98          		tya			; check for zero length
 2865   4B76   F0 EE       		beq	LSTVL		; nothing here but an error
 2866   4B78   A9 2F       		lda	#'/'		; start with / to be better
 2867   4B7A   20 A9 5D    		jsr	CHAR		; and it is out there
 2868   4B7D               	LSTVCL:
 2869   4B7D   E8          		inx			; point to next char
 2870   4B7E   BD 00 08    		lda	IOBUFF,X	; get char
 2871   4B81   20 A9 5D    		jsr	CHAR		; print it out
 2872   4B84   88          		dey			; count char
 2873   4B85   D0 F6       		bne	LSTVCL		; go get next char
 2874   4B87   A9 2F       		lda	#'/'		; end with '/' to show volume status
 2875   4B89   20 A9 5D    		jsr	CHAR		; and awaaaaay we go
 2876   4B8C   A9 0D       		lda	#EOL		; do a <CR>
 2877   4B8E   20 A9 5D    		jsr	CHAR		; printed
 2878   4B91   CA          		dex			; count back one, as loop starts with inx
 2879   4B92   D0 D2       		bne	LSTVL		; go do next one
 2880   4B94               	LSTVEX:
 2881   4B94   60          		rts			; toots finis
 2882                      	;
 2883                      	; CHECKVOLS - set prefix to particular volume that is currently online
 2884                      	;
 2885   4B95               	CHECKVOLS:
 2886   4B95   A5 1D       		lda	CHPTR+HI	; is it zero?
 2887   4B97   D0 1C       		bne	CHV1		; if not, then get next volume
 2888   4B99               		ONLINE	ONLINE_PB	; get online volumes
 2889   4B99               		PRODOS	$C5, ONLINE_PB
 2890   4B99   20 00 BF    		jsr	$BF00	; ProDOS handler
 2891   4B9C   C5          		DB	$C5	; ProDOS function code
 2892   4B9D   3E4B        		DW	ONLINE_PB	; Function Parameter Block address
 2893   4B9F               		.MACEND
 2894   4B9F               		.MACEND
 2895   4B9F   90 02       		bcc	CHV0		; okey dokey
 2896   4BA1               	CHVBX:
 2897   4BA1   38          		sec			; show badness
 2898   4BA2   60          		rts			; all done
 2899   4BA3               	CHV0:
 2900   4BA3   A9 F0       		lda	#<(IOBUFF-16)	; get LSB (-16 cuz we start with add)
 2901   4BA5   85 1C       		sta	CHPTR+LO
 2902   4BA7   A9 08       		lda	#>IOBUFF	; and mSB
 2903   4BA9   85 1D       		sta	CHPTR+HI
 2904   4BAB   A9 02       		lda	#>SCRBUFF		; this is where we will work on it
 2905   4BAD   8D D3 45    		sta	SET_PB+SP_PATHNAME+HI
 2906   4BB0   A9 80       		lda	#<SCRBUFF
 2907   4BB2   8D D2 45    		sta	SET_PB+SP_PATHNAME+LO
 2908   4BB5               	CHV1:
 2909   4BB5   A5 1C       		lda	CHPTR+LO	; point to next entry
 2910   4BB7   18          		clc			; getting ready for add
 2911   4BB8   69 10       		adc	#16		; this points to next one
 2912   4BBA   85 1C       		sta	CHPTR+LO	; can't be any wrapping
 2913   4BBC   A0 00       		ldy	#0		; to use indirect addressing
 2914   4BBE   B1 1C       		lda	(CHPTR),Y	; get length byte
 2915   4BC0   F0 DF       		beq	CHVBX		; all done if == 0
 2916   4BC2   29 0F       		and 	#$0F		; get rid of upper junk
 2917   4BC4   F0 EF       		beq	CHV1		; nothing in this one, do it again
 2918   4BC6   8D 80 02    		sta	SCRBUFF		; save length
 2919   4BC9   EE 80 02    		inc	SCRBUFF		; count the add '/'
 2920   4BCC   A8          		tay			; get for countdown
 2921   4BCD   A9 2F       		lda	#'/'		; need to start with a slash
 2922   4BCF   8D 81 02    		sta	SCRBUFF+1	; okay, we are
 2923   4BD2               	CHVL:
 2924   4BD2   B1 1C       		lda	(CHPTR),Y	; get char in path name
 2925   4BD4   99 81 02    		sta	SCRBUFF+1,Y	; save name
 2926   4BD7   88          		dey			; count char
 2927   4BD8   D0 F8       		bne	CHVL		; go get next one
 2928                      	
 2929   4BDA               		SET_PREFIX SET_PB	; so point to it
 2930   4BDA               		PRODOS	$C6, SET_PB
 2931   4BDA   20 00 BF    		jsr	$BF00	; ProDOS handler
 2932   4BDD   C6          		DB	$C6	; ProDOS function code
 2933   4BDE   D145        		DW	SET_PB	; Function Parameter Block address
  Tue Jun 13 1989 11:42                                                                                                  Page   45

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 2934   4BE0               		.MACEND
 2935   4BE0               		.MACEND
 2936   4BE0               	CHVX:
 2937   4BE0   60          		rts			; carry==0, we worked okay
 2938                      	;
 2939                      	; GET_SPECIAL - if we are in infodos, then we preload the first 12Kb of
 2940                      	;   stuff into the area in the main bank, pages $D0-$FF, Language Card 2.
 2941                      	;  Assume .D2 file has just been opened and go get it.
 2942   4BE1               	GET_SPECIAL:
 2943   4BE1   A9 03       	        lda     #RETRY_COUNT
 2944   4BE3   85 16       	        sta     RETRIES         ; how many retries
 2945   4BE5               	GTS_RDL:
 2946   4BE5   A9 00       	        lda     #0              ; make sure we are at the start
 2947   4BE7   8D CE 45    	        sta     PSEEK+SM_FPOS	; set pos to zero
 2948   4BEA   8D CF 45    	        sta     PSEEK+SM_FPOS+1
 2949   4BED   8D D0 45    	        sta     PSEEK+SM_FPOS+2
 2950   4BF0   85 7C       	        sta     K+LO
 2951   4BF2   85 7E       	        sta     L+LO            ; make sure these are zero too
 2952   4BF4               	        SET_MARK PSEEK		; go back to the beginning
 2953   4BF4               		PRODOS	$CE, PSEEK
 2954   4BF4   20 00 BF    		jsr	$BF00	; ProDOS handler
 2955   4BF7   CE          		DB	$CE	; ProDOS function code
 2956   4BF8   CC45        		DW	PSEEK	; Function Parameter Block address
 2957   4BFA               		.MACEND
 2958   4BFA               		.MACEND
 2959   4BFA               	        
 2960   4BFA   A9 02       	        lda     #2              ; one page at a time        
 2961   4BFC   8D C3 45    	        sta     READ_PB+RD_BUFFLEN+HI   ; show how much is special
 2962   4BFF   A9 17       	        lda     #SP_SIZE        ; how many pages in special part?
 2963   4C01   85 7A       	        sta     J+LO            ; use as counter
 2964   4C03   A9 D0       	        lda     #>SP_START      ; where does it go?
 2965   4C05   85 7F       	        sta     L+HI            ; L is pointer to there
 2966   4C07               	GTS_RD:
 2967   4C07   A9 00       	        lda     #MAIN           ; make sure we are in main
 2968   4C09   8D 04 C0    	        sta     WRTBNK+MAIN
 2969   4C0C               	        READ    READ_PB         ; go get 1Kb
 2970   4C0C               		PRODOS	$CA, READ_PB
 2971   4C0C   20 00 BF    		jsr	$BF00	; ProDOS handler
 2972   4C0F   CA          		DB	$CA	; ProDOS function code
 2973   4C10   BE45        		DW	READ_PB	; Function Parameter Block address
 2974   4C12               		.MACEND
 2975   4C12               		.MACEND
 2976   4C12   90 05       	        bcc     GTS_RD1         ; just fine
 2977   4C14   20 F7 46    	        jsr     RETRY           ; try again
 2978   4C17   90 CC       	        bcc     GTS_RDL         ; and do it again
 2979   4C19               	GTS_RD1:
 2980   4C19   A2 00       	        ldx     #SP_BANK        ; get bank that special is in
 2981   4C1B   9D 04 C0    	        sta     WRTBNK,X
 2982   4C1E   A9 08       	        lda     #>IOBUFF        ; get MSB of start
 2983   4C20   85 7D       	        sta     K+HI            ; K is source
 2984   4C22   A2 02       	        ldx     #2              ; 2 blocks of 256 bytes each
 2985   4C24               	GTS_CPL0:
 2986   4C24   A0 00       	        ldy     #0              ; indexer
 2987   4C26               	GTS_CPL:
 2988   4C26   B1 7C       	        lda     (K),y           ; get it
 2989   4C28   91 7E       	        sta     (L),y           ; store it
 2990   4C2A   C8          	        iny                     ; next
 2991   4C2B   D0 F9       	        bne     GTS_CPL         ; gwon then
 2992   4C2D   E6 7D       	        inc     K+HI            ; point to next block
 2993   4C2F   E6 7F       	        inc     L+HI            ; for destination too
 2994   4C31   CA          	        dex                     ; count block
 2995   4C32   D0 F0       	        bne     GTS_CPL0        ; next block
 2996   4C34   C6 7A       	        dec     J+LO            ; count this 1Kb
 2997   4C36   D0 CF       	        bne     GTS_RD          ; go get next one
 2998   4C38               	        
 2999   4C38   8D 04 C0    	        sta     WRTBNK+MAIN     ; make sure we are in main
 3000                      	;
 3001                      	; now figger out last page
 3002                      	;
 3003   4C3B   A0 09       	        ldy     #SGTSEG+1       ; get start segment LSB
 3004   4C3D   B1 59       	        lda     (INFODOS),Y     ; got it
 3005   4C3F   18          	        clc                     ; doing add
 3006   4C40   69 17       	        adc     #<SP_SIZE       ; add in size LSB
 3007   4C42   8D D3 6C    	        sta     INFODOS_END+LO  ; save end
 3008   4C45   88          	        dey                     ; point to MSB
  Tue Jun 13 1989 11:42                                                                                                  Page   46

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZDOS (SEEKING, READING, WRITING) ---"

 3009   4C46   B1 59       	        lda     (INFODOS),Y     ; got it
 3010   4C48   69 00       	        adc     #>SP_SIZE       ; add in size MSB
 3011   4C4A   8D D4 6C    	        sta     INFODOS_END+HI  ; and save it
 3012   4C4D   AD D3 6C    	        lda     INFODOS_END+LO  ; now, subtract one to make
 3013   4C50   D0 03       	        bne     GTS_END         ; it inclusive
 3014   4C52   CE D4 6C    	        dec     INFODOS_END+HI  ; wrapped, so dec MSB
 3015   4C55               	GTS_END:
 3016   4C55   CE D3 6C    	        dec     INFODOS_END+LO  ; make pointers inclusive
 3017                      	
 3018   4C58   60          	        rts                     ; done
 3019                      	
 3020          [01]        		IF	CHECKSUM == 1
 3021                      	CKS_COUNT: db 0
 3022                      	CKSB:	db	0
 3023                      	CKS_BLOCK:
 3024                      	        pha
 3025                      	        sta     CKSMOD+2
 3026                      	        ldy     #0
 3027                      		lda	CKSB
 3028                      	CKSLP:
 3029                      	        clc
 3030                      	CKSMOD: adc     IOBUFF,Y
 3031                      	        iny
 3032                      	        bne     CKSLP
 3033                      	
 3034                      		sta	CKSB
 3035                      		inc	CKS_COUNT
 3036                      		pla
 3037                      		rts
 3038                      	
 3039          [02]        		IF 	0
 3040                      	        jsr     HEXNUM
 3041                      	        lda     CKS_COUNT
 3042                      	        cmp     #$F
 3043                      	        bne     CKSCNT
 3044                      	        lda     #0
 3045                      	        sta     CKS_COUNT
 3046                      	        lda     #EOL
 3047                      	        bne     CKSSEND
 3048                      	CKSCNT:
 3049                      	        inc     CKS_COUNT
 3050                      	        lda     #SPACE
 3051                      	CKSSEND:
 3052                      	        jsr     CHAR
 3053                      	        jsr     DISP_LINE
 3054                      	        pla
 3055                      	        rts
 3056          [01]        		ENDIF
 3057                      	
 3058          [00]        	        ENDIF
 3059                      	
 3060   4C59               		END
 3061                      	
 3062   4C59               		INCLUDE		MACHINE.ASM
 3063   4C59               		STTL "--- MACHINE-DEPENDENT I/O: APPLE II ---"
 3064                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page   47

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3065                      	; -----------------------
 3066                      	; DIRECT PRINT LINE [X/A]
 3067                      	; -----------------------
 3068                      	; ENTRY: STRING ADDRESS IN [X/A] (LSB/MSB)
 3069                      	; STRING LENGTH IN [Y]
 3070   4C59   00          	DLCNT:	db 	0
 3071   4C5A   00          	DLOFF:	db	0
 3072   4C5B               	DLINE:
 3073   4C5B   8E 75 4C    		stx	STRING+LO	; DROP STRING ADDRESS
 3074   4C5E   8D 76 4C    		sta	STRING+HI	; INTO DUMMY BYTES
 3075   4C61   8C 59 4C    		sty	DLCNT		; COUNTER
 3076   4C64   20 BE 55    	        jsr     CLRBUF          ; send out what's out
 3077   4C67   A5 B1       	        lda     SCREENF         ; save output flag
 3078   4C69   48          	        pha
 3079   4C6A   A2 01       		ldx	#1		; INIT CHAR-FETCH INDEX
 3080   4C6C   86 B1       	        stx     SCREENF         ; make sure screen output is on
 3081   4C6E   CA          	        dex
 3082   4C6F   8E D1 6C    	        stx     CRLF_CHECK      ; don't let swap happen
 3083   4C72   86 AA       		stx	SCRIPT		; don't script any of my internal
 3084   4C74   BD          	DOUT:	DB	$BD		; 6502 "LDA nnnn,X" OPCODE
 3085   4C75   0000        	STRING:	DW	$0000		; DUMMY OPERAND BYTES
 3086   4C77   8E 5A 4C    		stx	DLOFF		; save X
 3087   4C7A   85 AC       	        sta     IOCHAR          ; save here for DIRECT_OUT
 3088   4C7C   20 10 53    	DOUT1:	jsr	DIRECT_OUT      ; send directly out there
 3089   4C7F   AE 5A 4C    		ldx	DLOFF		; get x back
 3090   4C82   E8          		inx
 3091   4C83   CE 59 4C    		dec	DLCNT		; LOOP TILL
 3092   4C86   D0 EC       		bne	DOUT		; OUT OF CHARS
 3093   4C88   20 BE 55    		jsr	CLRBUF		; and force the chars out
 3094   4C8B   A2 01       		ldx	#1		; allow scripting again
 3095   4C8D   86 AA       		stx	SCRIPT		; okay, we did
 3096   4C8F   8E D1 6C    	        stx     CRLF_CHECK      ; and turn on check
 3097   4C92   68          	        pla                     ; get screen flag back
 3098   4C93   85 B1       	        sta     SCREENF         ; bingo
 3099   4C95   60          		rts			; done
 3100                      	
 3101                      	; SWAP2INFOW - save current state and swap to the information window,
 3102                      	;	which is currently window zero
 3103   4C96               	SWAPA1:	ds	1		; save for current ARG1
 3104   4C97               	SWAPCW:	ds	1		; save for current window
 3105   4C98   00          	SWAPFLG: db	0		; flag == 1 if we have already swapped
 3106   4C99               	SWAP2INFOW:
 3107   4C99   AD 98 4C    		lda	SWAPFLG		; already swapped?
 3108   4C9C   D0 17       		bne	SWP2		; ayyup
 3109   4C9E   20 BE 55    		jsr	CLRBUF		; clear out the buffer
 3110   4CA1   20 8F 4D    		jsr	SAVE_CURSOR	; save current postion of cursor
 3111   4CA4   A5 63       		lda	ARG1+LO		; get current arg1
 3112   4CA6   8D 96 4C    		sta	SWAPA1		; save it
 3113   4CA9   A5 A6       		lda	CURWIN		; get current window
 3114   4CAB   8D 97 4C    		sta	SWAPCW		; save it
 3115   4CAE   A9 00       		lda	#0		; swap to window zero for messages
 3116   4CB0   85 63       		sta 	ARG1+LO		; okay
 3117   4CB2   20 85 6E    		jsr	ZSCRN		; and swap to it
 3118   4CB5               	SWP2:
 3119   4CB5   EE 98 4C    		inc	SWAPFLG		; show we are in swap window
 3120   4CB8               	SWAPEX:
 3121   4CB8   60          		rts			; all done
 3122                      	;
 3123                      	; SWAPBACK - swap out of info window, and back to old window
 3124                      	;
 3125   4CB9               	SWAPBACK:
 3126   4CB9   CE 98 4C    		dec	SWAPFLG		; are we finally leaving for good?
 3127   4CBC   D0 FA       		bne	SWAPEX		; nope
 3128   4CBE   AD 97 4C    		lda	SWAPCW		; and now for current window
 3129   4CC1   85 63       		sta	ARG1+LO		; swap to it
 3130   4CC3   20 85 6E    		jsr	ZSCRN		; we did
 3131   4CC6   AD 96 4C    		lda	SWAPA1		; and get arg1 back
 3132   4CC9   85 63       		sta 	ARG1+LO		; we did
 3133   4CCB   4C A1 4D    		jmp	GET_CURSOR	; and get cursor back
 3134                      	
 3135                      	; -----------------------
 3136                      	; SEND [LBUFF] TO PRINTER
 3137                      	; -----------------------
 3138                      	; ENTRY: LENTH OF LINE IN [PRLEN]
 3139                      	
  Tue Jun 13 1989 11:42                                                                                                  Page   48

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3140   4CCE   60          	PLEAV:	RTS		
 3141                      	
 3142   4CCF               	PPRINT:
 3143   4CCF   A5 AA       		lda	SCRIPT		; SCRIPTING INTERNALLY ENABLED?
 3144   4CD1   2D A1 6C    		and	SCRIPTF		; SCRIPTING ON?
 3145   4CD4   2D A2 6C    		and	SCRIPTFLG	; Window allow scripting?
 3146   4CD7   F0 F5       		beq	PLEAV		; NO, EXIT
 3147   4CD9   A5 36       		lda	CSW+LO		; SAVE NORMAL OUTPUT HOOK
 3148   4CDB   48          		pha		
 3149   4CDC   A5 37       		lda	CSW+HI	
 3150   4CDE   48          		pha		
 3151   4CDF   AD 0C 4D    		lda	ALTCSW+LO	; LOAD SCRIPTING HOOK
 3152   4CE2   85 36       		sta	CSW+LO	
 3153   4CE4   AD 0D 4D    		lda	ALTCSW+HI	
 3154   4CE7   85 37       		sta	CSW+HI	
 3155   4CE9   AD 82 C0    	        lda     RDROM           ; put system ROM in for printer out
 3156   4CEC   A0 00       		ldy	#0	
 3157   4CEE               	PP5:
 3158   4CEE   B9 00 02    		lda	LBUFF,Y		;GET A CHAR TO SEND OUT
 3159   4CF1   30 05       	        bmi     PP6             ; don't do highlighting
 3160   4CF3   09 80       		ora	#$80		; make it apple happy
 3161   4CF5   20 ED FD    		jsr	MCOUT	
 3162   4CF8               	PP6:
 3163   4CF8   C8          		iny		
 3164   4CF9   CE 97 6C    		dec	PRLEN		;LINE COUNT
 3165   4CFC   D0 F0       		bne	PP5		;PRINT WHOLE LINE
 3166                      	;
 3167                      	; ALL DONE, RESET TO NORMAL AND LEAVE
 3168                      	;
 3169   4CFE   AD 83 C0    	        lda     BNK2SET         ; write RAM, bank 1
 3170   4D01   AD 83 C0    	        lda     BNK2SET
 3171   4D04   68          		pla		
 3172   4D05   85 37       		sta	CSW+HI	
 3173   4D07   68          		pla		
 3174   4D08   85 36       		sta	CSW+LO	
 3175   4D0A   60          		rts		
 3176                      	
 3177   4D0B   00          	PSTAT:	DB	0	;SET TO CLEAR WHEN BOOT,
 3178                      				;I PUT IT HERE SO RESTART WON'T ALTER
 3179   4D0C   00 00       	ALTCSW:	DB	0,0	;(WORD) PRINTER COUT
 3180                      	
 3181                      		; FIRST TIME USING PRINTER, INITIALIZE IT
 3182   4D0E   0D          	SLOTM:	DB	EOL	
 3183   4D0F   50 72 69 6E 74 		DB	"Printer Slot 1-7: "
        4D14   65 72 20 53 6C 
        4D19   6F 74 20 31 2D 
        4D1E   37 3A 20 
 3184          0013        	SLOTML	EQU	$-SLOTM
 3185                      	
 3186   4D21               	PCHK:	
 3187   4D21   20 99 4C    		jsr	SWAP2INFOW	; point to info window
 3188   4D24               	PCHK1:
 3189   4D24               		DLINE	SLOTM
 3190   4D24   A2 0E       		ldx	#<SLOTM	; get part of SLOTM
 3191   4D26   A9 4D       		lda	#>SLOTM	; get other part of string
 3192          [01]        		IFMA	2		; check to see if length passed in
 3193                      		ldy	M		; then just fetch it
 3194          [01]        		ELSE
 3195   4D28   A0 13       		ldy	#SLOTML	; get length of string
 3196          [00]        		ENDIF
 3197   4D2A   20 5B 4C    		jsr	DLINE		; print the string
 3198   4D2D               		.MACEND
 3199   4D2D   20 20 51    		jsr	GETKEY	
 3200   4D30   C9 38       		cmp	#'8'		;1-7
 3201   4D32   B0 F0       		bcs	PCHK1		;OOPS
 3202   4D34   C9 31       		cmp	#'1'		; less than '1'?
 3203   4D36   90 EC       		bcc	PCHK1		; ayyup
 3204   4D38               	PC2:
 3205   4D38   49 F0       		eor	#$F0		; make it a slot address	
 3206   4D3A   8D 0D 4D    		sta	ALTCSW+HI	
 3207   4D3D   A9 0D       		lda	#EOL
 3208   4D3F   20 A9 5D    		jsr	CHAR		;SEND >CR< TO SCREEN FOR NEATNESS
 3209   4D42   EE 0B 4D    		inc	PSTAT		;SET TO ON
 3210   4D45   A5 36       		lda	CSW+LO		;SAVE NORMAL OUTPUT HOOK
 3211   4D47   48          		pha		
  Tue Jun 13 1989 11:42                                                                                                  Page   49

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3212   4D48   A5 37       		lda	CSW+HI	
 3213   4D4A   48          		pha		
 3214   4D4B   AD 0C 4D    		lda	ALTCSW+LO	;LOAD SCRIPTING HOOK
 3215   4D4E   85 36       		sta	CSW+LO	
 3216   4D50   AD 0D 4D    		lda	ALTCSW+HI	
 3217   4D53   85 37       		sta	CSW+HI	
 3218   4D55   20 88 4D    		jsr	INITPRT		; now, init it 
 3219                      	
 3220   4D58   AD 82 C0    	        lda     RDROM           ; bring in system ROM
 3221   4D5B   A9 89       		lda	#$89		; OUTPUT PRINTER SETUP SEQUENCE
 3222   4D5D   20 ED FD    		jsr	MCOUT		; START WITH COMMAND CHAR >CTRL-I<
 3223   4D60   A9 B8       		lda	#$B8		; 8 (80 COL WIDE)
 3224   4D62   20 ED FD    		jsr	MCOUT	
 3225   4D65   A9 B0       		lda	#$B0		; 0
 3226   4D67   20 ED FD    		jsr	MCOUT	
 3227   4D6A   A9 CE       		lda	#$CE		; N (LF AFTER CR)
 3228   4D6C   20 ED FD    		jsr	MCOUT	
 3229   4D6F   A5 36       		lda	CSW+LO		; SAVE REAL PRINTER OUTPUT
 3230   4D71   8D 0C 4D    		sta	ALTCSW+LO	; LOC. FOR NEXT TIME
 3231   4D74   A5 37       		lda	CSW+HI	
 3232   4D76   8D 0D 4D    		sta	ALTCSW+HI	
 3233   4D79   68          		pla			; RESET NORMAL OUTPUT
 3234   4D7A   85 37       		sta	CSW+HI	
 3235   4D7C   68          		pla		
 3236   4D7D   85 36       		sta	CSW+LO	
 3237   4D7F   AD 83 C0    	        lda     BNK2SET         ; and bring back top RAM
 3238   4D82   AD 83 C0    	        lda     BNK2SET         ; okay
 3239   4D85   4C B9 4C    		jmp	SWAPBACK	; and back to the old window
 3240   4D88               	INITPRT:
 3241   4D88   A9 00       		lda	#0		; jump to $Cn00
 3242   4D8A   85 36       		sta	CSW+LO		; make LSB == 0
 3243   4D8C   6C 36 00    		jmp	(CSW)		; and goto it
 3244                      	
 3245                      	
 3246   4D8F               	SAVE_CURSOR:
 3247   4D8F   A5 01       		lda	SCRCY		; save the cursor pos
 3248   4D91   A0 04       		ldy	#WINY		; get offset
 3249   4D93   91 05       		sta	(WINDOW),Y	; first y pos
 3250   4D95   C8          		iny			; now x pos
 3251   4D96   A5 00       		lda	SCRCX		; got it
 3252   4D98   91 05       		sta	(WINDOW),Y	; saved it
 3253   4D9A   A0 13       		ldy	#WINLCNT	; reset line count too
 3254   4D9C   A5 AB       		lda	LINCNT		; okay
 3255   4D9E   91 05       		sta	(WINDOW),Y	; get it
 3256   4DA0   60          		rts
 3257                      	
 3258   4DA1               	GET_CURSOR:
 3259   4DA1   A0 04       		ldy	#WINY		; get cursor pos back
 3260   4DA3   B1 05       		lda	(WINDOW),Y	; got y pos
 3261   4DA5   85 01       		sta	SCRCY		; saved
 3262   4DA7   C8          		iny			; point to x pos
 3263   4DA8   B1 05       		lda	(WINDOW),Y	; got it
 3264   4DAA   85 00       		sta	SCRCX		; make it better
 3265   4DAC   38          		sec			; subtract left margin to get how long line is
 3266   4DAD   E5 04       		sbc	LEFTMRG		; okay we did that
 3267   4DAF   B0 02       	        bcs     GETCR1          ; make sure left margin is not > cur x pos
 3268   4DB1   A9 00       	        lda     #0              ; otherwise, pretend length is zero
 3269   4DB3               	GETCR1:
 3270   4DB3   85 A7       		sta	LENGTH+LO	; this is how big line is too
 3271   4DB5   A9 00       		lda	#0		; clear MSB
 3272   4DB7   85 A8       		sta	LENGTH+HI
 3273   4DB9   06 A7       		asl	LENGTH+LO	; *2
 3274   4DBB   26 A8       		rol	LENGTH+HI
 3275   4DBD   06 A7       		asl	LENGTH+LO	; *4
 3276   4DBF   26 A8       		rol	LENGTH+HI
 3277   4DC1               		
 3278   4DC1   A0 13       		ldy	#WINLCNT	; reset line count too
 3279   4DC3   B1 05       		lda	(WINDOW),Y	; get it
 3280   4DC5   85 AB       		sta	LINCNT		; okay
 3281   4DC7   A9 01       		lda	#1		; show cursor changed (maybe)
 3282   4DC9   8D A5 6C    		sta	CURSFLG		; okay
 3283   4DCC   60          		rts
 3284                      	
 3285                      	; ------------
 3286                      	; SPLIT SCREEN
  Tue Jun 13 1989 11:42                                                                                                  Page   50

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3287                      	; ------------
 3288                      	;
 3289                      	; SPLIT SCREEN AT LINE [ARG1] putting screen 1 at top and screen
 3290                      	; 0 at bottom.
 3291                      	; DISABLE SPLIT IF [ARG1] = 0
 3292                      	;
 3293   4DCD               	ZSPLIT:
 3294   4DCD   20 8F 4D    		jsr	SAVE_CURSOR	; save the cursor pos
 3295                      	;
 3296                      	; first muck with window 1
 3297                      	;
 3298   4DD0   A5 63       		lda	ARG1+LO		; get split arg back
 3299   4DD2   8D CF 6D    		sta	WINDOW1+WINHGHT	; this becomes the height of window 1
 3300   4DD5   A9 00       		lda	#0		; put top of 1 to top of screen
 3301   4DD7   8D CD 6D    		sta	WINDOW1+WINTOP	; okay, we did it
 3302   4DDA   A5 63       		lda	ARG1+LO		; get new height
 3303   4DDC   A2 FF       		ldx	#$FF		; this is the counter
 3304   4DDE   38          		sec			; get ready for subs
 3305   4DDF               	ZSPLIT0:
 3306   4DDF   E8          		inx			; count this line
 3307   4DE0   E9 09       		sbc	#FONT_H		; subtract off font height	
 3308   4DE2   B0 FB       		bcs	ZSPLIT0		; still some lines	
 3309   4DE4   CA          		dex			; save input line
 3310   4DE5   8E E4 6D    		stx	WINDOW1+WINLINES ; saved
 3311                      	
 3312   4DE8   AD D1 6D    		lda	WINDOW1+WINY	; check cursor pos
 3313   4DEB   C5 63       		cmp	ARG1+LO		; against height
 3314   4DED   90 11       		bcc	ZSPL1		; inside window, so save it
 3315   4DEF               	ZSPL0:
 3316   4DEF   A9 00       		lda	#0		; reset to top left
 3317   4DF1   8D D1 6D    		sta	WINDOW1+WINY	; y pos at top
 3318   4DF4   8D D2 6D    		sta	WINDOW1+WINX	; x pos at left
 3319   4DF7   8D E2 6D    		sta	WINDOW1+WINLLEN+LO	; line length
 3320   4DFA   8D E3 6D    		sta	WINDOW1+WINLLEN+HI	; line length
 3321   4DFD   8D E0 6D    		sta	WINDOW1+WINLCNT	; line counter
 3322                      	;
 3323                      	; now muck with window 0
 3324                      	;
 3325   4E00               	ZSPL1:
 3326   4E00   AD B5 6D    		lda	WINDOW0+WINTOP	; top of window 0
 3327   4E03   38          		sec			; doing sub
 3328   4E04   E5 63       		sbc	ARG1+LO		; subtract out the new top
 3329   4E06   18          		clc			; adding
 3330   4E07   6D B7 6D    		adc	WINDOW0+WINHGHT	; to get the new height
 3331                      	;	bcc	ZSPLIT1		; okay, positive height
 3332                      	;	lda	#0		; make height 0
 3333   4E0A               	ZSPLIT1:
 3334   4E0A   8D B7 6D    		sta	WINDOW0+WINHGHT	; and save new height
 3335   4E0D               		
 3336   4E0D   A2 FF       		ldx	#$FF		; this is the counter
 3337   4E0F   38          		sec			; get ready for subs
 3338   4E10               	ZSPLIT2:
 3339   4E10   E8          		inx			; count this line
 3340   4E11   E9 09       		sbc	#FONT_H		; subtract off font height	
 3341   4E13   B0 FB       		bcs	ZSPLIT2		; still some lines	
 3342   4E15   CA          		dex			; to save input line
 3343   4E16   8E CC 6D    		stx	WINDOW0+WINLINES ; saved
 3344                      	
 3345   4E19   A5 63       		lda	ARG1+LO		; this is the new top
 3346   4E1B   8D B5 6D    		sta	WINDOW0+WINTOP	; set in structure
 3347   4E1E   CD B9 6D    		cmp	WINDOW0+WINY	; make sure cursor is still in window
 3348   4E21   F0 13       		beq	ZSPL5		; nope, at the top
 3349   4E23   90 11       		bcc	ZSPL5		; or under it
 3350   4E25   8D B9 6D    		sta	WINDOW0+WINY	; put cursor at top
 3351   4E28   A9 00       		lda	#0		; left of new
 3352   4E2A   8D BA 6D    		sta	WINDOW0+WINX	; window 0
 3353   4E2D   8D CA 6D    		sta	WINDOW0+WINLLEN+LO	; linelength
 3354   4E30   8D CB 6D    		sta	WINDOW0+WINLLEN+HI	; linelength
 3355   4E33   8D C8 6D    		sta	WINDOW0+WINLCNT	; line counter
 3356   4E36               	ZSPL5:
 3357   4E36   20 A1 4D    		jsr	GET_CURSOR	; get the cursor pos back
 3358                      	
 3359   4E39   A9 00       		lda	#0		; now switch to window zero
 3360   4E3B   85 63       		sta	ARG1+LO		; good bye
 3361   4E3D   4C 85 6E    		jmp	ZSCRN		; making window 0 be current
  Tue Jun 13 1989 11:42                                                                                                  Page   51

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3362                      	
 3363                      	; ------
 3364                      	; MARGIN
 3365                      	; ------
 3366                      	;
 3367                      	; Set the margins for the window
 3368                      	;
 3369                      	;  ARG1 - left margin
 3370                      	;  ARG2 - right margin
 3371                      	;  ARG3 - window ID (optional)
 3372                      	;
 3373   4E40               	ZMARG:
 3374   4E40   20 BE 55    		jsr	CLRBUF		; CLEAR LBUFF BEFORE RESETTING LINE MARGINS
 3375   4E43   20 8F 4D    		jsr	SAVE_CURSOR	; save current cursor pos
 3376   4E46               		
 3377   4E46   A5 62       		lda	NARGS		; see if window ID was passed
 3378   4E48   C9 03       		cmp	#3		; if ==3, then it's there
 3379   4E4A   F0 04       		beq	ZMRG1		; okay, so use it
 3380   4E4C   A5 A6       		lda	CURWIN		; get the current window
 3381   4E4E   85 67       		sta	ARG3+LO		; and use as the default
 3382   4E50               	ZMRG1:
 3383   4E50   A5 67       		lda	ARG3+LO		; check what window
 3384   4E52   20 87 57    		jsr	SETWJ		; get window offset into J
 3385   4E55   A5 63       		lda	ARG1+LO		; do left margin first
 3386   4E57   A0 06       		ldy	#WINLM		; get offset
 3387   4E59   91 7A       		sta	(J),Y		; save for window
 3388   4E5B   C8          		iny			; point to right margin
 3389   4E5C   A5 65       		lda	ARG2+LO		; get right margin
 3390   4E5E   91 7A       		sta	(J),Y		; save right margin
 3391   4E60   A0 03       		ldy	#WINWID		; get full width of window
 3392   4E62   B1 7A       		lda	(J),Y		; got it
 3393   4E64   38          		sec			; subtract off the 2 margins
 3394   4E65   A0 06       		ldy	#WINLM		; first the left margin
 3395   4E67   F1 7A       		sbc	(J),Y		; okay, gone
 3396   4E69   C8          		iny			; point to right margin
 3397   4E6A   F1 7A       		sbc	(J),Y		; and take it off	
 3398   4E6C   A0 14       		ldy	#WINXSZ		; set width of usable window
 3399   4E6E   91 7A       		sta	(J),Y		; see, here it is
 3400                      	;
 3401                      	; move cursor to left margin
 3402                      	;
 3403   4E70   A0 01       		ldy	#WINLEFT	; get left edge
 3404   4E72   B1 7A       		lda	(J),Y		; got it
 3405   4E74   A0 06       		ldy	#WINLM		; and add left margin
 3406   4E76   18          		clc			; adding
 3407   4E77   71 7A       		adc	(J),Y		; to get minimum X
 3408   4E79   A0 05       		ldy	#WINX		; check to make sure X pos is okay
 3409   4E7B   91 7A       		sta	(J),Y		; then reset it
 3410                      	;
 3411                      	; now see if we changed the current window
 3412                      	;
 3413   4E7D               	ZMRGXP:
 3414   4E7D   A6 67       		ldx	ARG3+LO		; get the window
 3415   4E7F   30 04       		bmi	ZMRG3		; -3 means current window
 3416   4E81   E4 A6       		cpx	CURWIN		; check against the current window
 3417   4E83   D0 17       		bne	ZMRGX		; nope, so we be done
 3418   4E85               	ZMRG3:
 3419   4E85   85 04       		sta	LEFTMRG		; [A] already has left margin
 3420   4E87   A0 14       		ldy	#WINXSZ		; get xsize to set
 3421   4E89   B1 05       		lda	(WINDOW),Y	; got it
 3422   4E8B   85 A2       		sta	XSIZE+LO	; this is for quicky comparing
 3423   4E8D   A9 00       		lda	#0		; clear MSB
 3424   4E8F   85 A3       		sta	XSIZE+HI
 3425   4E91   06 A2       		asl	XSIZE+LO	; *2
 3426   4E93   26 A3       		rol	XSIZE+HI
 3427   4E95   06 A2       		asl	XSIZE+LO	; *4
 3428   4E97   26 A3       		rol	XSIZE+HI
 3429   4E99   20 A1 4D    		jsr	GET_CURSOR	; restore the cursor pos
 3430   4E9C               	ZMRGX:
 3431   4E9C   60          		rts
 3432                      	;
 3433                      	; SOUND
 3434                      	; -----
 3435                      	; ARG1 = BOOP (2) BEEP (1) ALL OTHERS INVALID
 3436                      	; (EZIP)
  Tue Jun 13 1989 11:42                                                                                                  Page   52

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3437                      	
 3438   4E9D               	ZSOUND:
 3439   4E9D   A6 63       		ldx	ARG1+LO	; GET SOUND WANTED
 3440   4E9F   CA          		dex		
 3441   4EA0   F0 11       		beq	BEEP	
 3442   4EA2   CA          		dex		
 3443   4EA3   D0 0D       		bne	ZSOEX	; INVALID
 3444   4EA5   A0 FF       		ldy	#$FF	; DURATION ($C0 = .1 SEC)
 3445   4EA7               	BOOP:
 3446   4EA7   A9 10       		lda	#$10	; TONE ($0C = 1 KHZ)
 3447   4EA9   20 16 4F    		jsr	WAIT10
 3448   4EAC   AD 30 C0    		lda	SPKR	; TOGGLE SPEAKER
 3449   4EAF   88          		dey
 3450   4EB0   D0 F5       		bne	BOOP	
 3451   4EB2               	ZSOEX:
 3452   4EB2   60          		rts		
 3453                      	
 3454   4EB3               	BEEP:
 3455   4EB3   AD 82 C0    	        lda     RDROM
 3456   4EB6   20 3A FF    		jsr	MBELL	; just use system beep
 3457   4EB9   AD 83 C0    	        lda     BNK2SET ; back to bank 2
 3458   4EBC   AD 83 C0    	        lda     BNK2SET ; back to bank 2
 3459   4EBF   60          	        rts
 3460                      	;
 3461                      	; just do the background color - foreground is always white/black
 3462                      	;
 3463                      	;
 3464                      	; ZIPCOLOR - maps ZIP colors to screen colors
 3465                      	;
 3466   4EC0               	ZCOLOR:
 3467   4EC0   20 BE 55    		jsr	CLRBUF		; print out what we have
 3468                      	
 3469   4EC3   A5 62       		lda 	NARGS		; check if window was passed
 3470   4EC5   C9 03       		cmp	#3		; was it?
 3471   4EC7   F0 04       		beq	ZCLR0		; ayyup
 3472   4EC9   A5 A6       		lda	CURWIN		; make it current window
 3473   4ECB   85 67       		sta	ARG3+LO		; it is now
 3474   4ECD               	ZCLR0:
 3475   4ECD   A5 67       		lda	ARG3+LO		; get window ID
 3476   4ECF   20 87 57    		jsr	SETWJ		; and put pointer into J
 3477                      	
 3478   4ED2   A6 65       		ldx 	ARG2+LO		; get background color
 3479   4ED4   F0 15       		beq	ZCLR2		; check fore ground color
 3480   4ED6   10 06       		bpl	ZCLR01		; not -1
 3481   4ED8   20 37 5E    		jsr	GET_NYBBLE	; get me the color nybble here
 3482   4EDB   4C E7 4E    		jmp	ZCLR11		; and use as background color
 3483   4EDE               	ZCLR01:
 3484   4EDE   CA          		dex			; check for default
 3485   4EDF   D0 02       		bne	ZCLR1		; nope, find the color
 3486   4EE1   A2 01       		ldx	#1		; use black as default back color
 3487   4EE3               	ZCLR1:
 3488   4EE3   CA          		dex			; zero base the color
 3489   4EE4   BD 6D 6C    		lda	ZIPCOLOR,X	; get my color from the zip color
 3490   4EE7               	ZCLR11:
 3491   4EE7   A0 0E       		ldy	#WINBGND	; get background offset
 3492   4EE9   91 7A       		sta	(J),Y		; saved color
 3493                      	;
 3494                      	; now do foreground color
 3495                      	;
 3496   4EEB               	ZCLR2:
 3497   4EEB   A6 63       		ldx 	ARG1+LO		; get foreground color
 3498   4EED   F0 0D       		beq	ZCLREX		; no change
 3499   4EEF   CA          		dex			; check for default
 3500   4EF0   D0 02       		bne	ZCLR3		; nope, find the color
 3501   4EF2   A2 08       		ldx	#8		; use white as default fore color
 3502   4EF4               	ZCLR3:
 3503   4EF4   CA          		dex			; zero base the color
 3504   4EF5   BD 6D 6C    		lda	ZIPCOLOR,X	; get my color from the zip color
 3505   4EF8   A0 0D       		ldy	#WINFORE	; foreground color offset
 3506   4EFA   91 7A       		sta	(J),Y		; save in structure
 3507   4EFC               	ZCLREX:
 3508   4EFC   60          		rts
 3509                      	
 3510                      	;
 3511                      	; CHKTME RTN - CALLED BY INPUT & ZINPUT
  Tue Jun 13 1989 11:42                                                                                                  Page   53

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3512                      	;
 3513   4EFD               	CHKTME:	
 3514   4EFD   A5 62       		lda	NARGS		; CHECK IF TIME LIMIT
 3515   4EFF   C9 02       		cmp	#2
 3516   4F01   F0 12       		beq	CHKT1		; NO
 3517   4F03   A5 67       		lda	ARG3+LO		; GET DELAY WANTED
 3518   4F05   85 79       		sta	I+HI
 3519   4F07   A5 62       		lda	NARGS		; IS THERE A FCN?
 3520   4F09   C9 04       		cmp	#4
 3521   4F0B   D0 08       		bne	CHKT1		; NO
 3522   4F0D   A5 69       		lda	ARG4+LO		; YES, SET IT
 3523   4F0F   85 7A       		sta	J+LO
 3524   4F11   A5 6A       		lda	ARG4+HI
 3525   4F13   85 7B       		sta	J+HI
 3526   4F15               	CHKT1:
 3527   4F15   60          		rts			; just set things up, please
 3528                      	
 3529   4F16               	WAIT10:
 3530   4F16   A9 02       	        lda     #2              ; do this twice (maybe)
 3531   4F18   85 C6       	        sta     DELAY_COUNTER   ; put in counter
 3532   4F1A               	WAIT0:
 3533   4F1A   AD 82 C0    	        lda     RDROM           ; get roms in
 3534   4F1D   A2 04       		ldx	#4		; .04 SEC (time to do other stuff)
 3535   4F1F   A9 30       	TIME1:	lda	#$30		; .01 SEC
 3536   4F21   20 A8 FC    		jsr	MWAIT	
 3537   4F24   CA          		dex		
 3538   4F25   D0 F8       		bne	TIME1	
 3539                      	
 3540   4F27   AD 83 C0    	        lda     BNK2SET         ; get roms out
 3541   4F2A   AD 83 C0    	        lda     BNK2SET
 3542                      	
 3543   4F2D   A5 58       		lda	MOUSEF		; move mouse cursor?
 3544   4F2F   F0 08       		beq	WAIT1		; nope
 3545   4F31   AD D2 6C    	        lda     PTR_COUNT       ; but do we really want to check it
 3546   4F34   D0 03       	        bne     WAIT1           ; nope
 3547   4F36   4C 1A 50    		jmp	MOVE_MC		; move cursor, if necessary
 3548   4F39               	WAIT1:
 3549   4F39   C6 C6       	        dec     DELAY_COUNTER   ; count loop
 3550   4F3B   D0 DD       	        bne     WAIT0           ; go do again
 3551   4F3D   60          		rts
 3552                      	;
 3553                      	; tick the ol timer
 3554                      	;
 3555   4F3E               	TIMEK:
 3556   4F3E   A9 03       		lda	#BLINK_RATE	; how often to blink
 3557   4F40   8D 81 4F    		sta	CURCOUNT	; okay!
 3558   4F43               	TIMEST:
 3559   4F43   A5 78       		lda	I+LO		; don't reset if not zero
 3560   4F45   D0 07       		bne	TIMELOOP	; so keep goin' then
 3561   4F47   A5 79       		lda	I+HI
 3562   4F49   85 78       		sta	I+LO
 3563   4F4B   20 82 4F    		jsr	STCUR		; start the cursor
 3564   4F4E               	TIMELOOP:
 3565   4F4E   20 16 4F    		jsr	WAIT10		; wait .10 secs
 3566                      	
 3567   4F51   20 D5 4F    		jsr	FKEYX		; Check for Keystroke
 3568   4F54   30 23       		bmi	TIME2		; OK, HE'S THERE, CONTINUE
 3569                      	
 3570   4F56   CE 81 4F    		dec	CURCOUNT	; count down to toggle
 3571   4F59   D0 08       		bne	TMCNT		; okay, no blink
 3572   4F5B   20 82 4F    		jsr	STCUR		; blink cursor
 3573   4F5E   A9 03       		lda	#BLINK_RATE	; once per second
 3574   4F60   8D 81 4F    		sta	CURCOUNT	; okay!
 3575   4F63               	TMCNT:
 3576   4F63   C6 78       		dec	I+LO		; 10TH'S OF SECONDS TO WAIT
 3577   4F65   F0 02       		beq	TIMEOUT		; SOME TIME LEFT
 3578                      	
 3579   4F67   D0 E5       		bne	TIMELOOP	; so gwon back and try again! (JMP)
 3580                      	;
 3581                      	; THERE IS A TIME OUT, CHECK FOR A FCN
 3582                      	;
 3583   4F69               	TIMEOUT:
 3584   4F69   20 AD 4F    		jsr	ERCUR		; after erasing cursor
 3585   4F6C   A5 7B       		lda	J+HI		; IS THERE A FCN
 3586   4F6E   F0 0E       		beq	TIMEBAD		; NO FCN, LEAVE WITH NOTHING
  Tue Jun 13 1989 11:42                                                                                                  Page   54

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3587   4F70               	TIME3:
 3588   4F70   20 3F 5B    		jsr	INTCLL		; INTERNALLY CALL THE FCN
 3589   4F73   A5 76       		lda	VALUE+LO	; CHECK RESULTS
 3590   4F75   F0 CC       		beq	TIMEST		; ELSE TRY AGAIN
 3591   4F77   D0 05       		bne	TIMEBAD		; else die a horrible death!
 3592   4F79               	TIME2:
 3593   4F79   20 AD 4F    		jsr	ERCUR		; after erasing cursor
 3594   4F7C   18          		clc			; GOT A KEY
 3595   4F7D   60          		rts
 3596   4F7E               	TIMEBAD:
 3597   4F7E   38          		sec
 3598   4F7F   60          		rts
 3599                      	;
 3600                      	; display the cursor in the current spot
 3601                      	;
 3602   4F80   80          	CURSTATE:	db	$80	; blinking cursor state
 3603   4F81   00          	CURCOUNT:	db	0	; toggle counter
 3604                      	
 3605   4F82               	STCUR:
 3606   4F82   AE D0 6C    	        ldx     CURSOR_OFF      ; is the cursor off?
 3607   4F85   F0 01       	        beq     STCUR1          ; no
 3608   4F87   60          	        rts                     ; yes, so don't do nuthin'
 3609   4F88               	STCUR1:
 3610   4F88   48          		pha			; save a
 3611   4F89   A5 BB       		lda	INVFLG		; get current INVFLG
 3612   4F8B   48          		pha			; save it
 3613   4F8C   A9 80       		lda	#$80		; make it all be ones
 3614   4F8E   85 BB       		sta	INVFLG		; and blink
 3615                      	
 3616   4F90   A9 20       		lda	#SPACE		; space for cursor
 3617   4F92   8D 0C 72    		sta	SHOW_CURSOR	; show that we are doing cursor
 3618   4F95   20 A9 5D    		jsr	CHAR		; and print it out
 3619   4F98   20 1A 72    		jsr	DISP_LINE	; send it out
 3620                      	
 3621   4F9B   AD 80 4F    		lda	CURSTATE	; get current state
 3622   4F9E   49 80       		eor	#$80		; toggle it
 3623   4FA0   8D 80 4F    		sta	CURSTATE	; save it
 3624   4FA3   68          		pla			; get invflg
 3625   4FA4   85 BB       		sta	INVFLG		; restored
 3626   4FA6   A9 00       		lda	#0		; clear cursor flag
 3627   4FA8   8D 0C 72    		sta	SHOW_CURSOR	; okay
 3628   4FAB               		
 3629   4FAB   68          		pla			; get [A] back
 3630   4FAC   60          		rts
 3631                      	;
 3632                      	; just erase the cusor char, but leave cursor in its old place
 3633                      	;
 3634   4FAD               	ERCUR:
 3635   4FAD   48          		pha			; save a
 3636   4FAE   AD 80 4F    		lda	CURSTATE	; get current state
 3637   4FB1   D0 03       		bne	ERCURX		; not on, leave alone
 3638   4FB3   20 82 4F    		jsr	STCUR		; 'start' it out
 3639   4FB6               	ERCURX:
 3640   4FB6   68          		pla			; retrieve [A]
 3641   4FB7   60          		rts
 3642                      	;
 3643                      	; timed key input loop
 3644                      	;
 3645                      	; carry set if timed out
 3646                      	; char in [A], if there is one!
 3647   4FB8               	TIMIN:
 3648   4FB8   A5 58       		lda	MOUSEF		; is there a mouse/joystick?
 3649   4FBA   F0 03       		beq	TIMIN1		; nope
 3650   4FBC   20 E3 62    		jsr	MSCON		; turn on mouse cursor
 3651   4FBF               	TIMIN1:
 3652   4FBF   20 3E 4F    		jsr	TIMEK		; check for keystroke
 3653   4FC2   B0 05       		bcs	TMBAD		; ELSE ABORT
 3654   4FC4               	TM1:
 3655   4FC4   20 7A 51    		jsr	PARSEKEY	; GET ASCII INTO [A] AND [IOCHAR]
 3656   4FC7   B0 F6       		bcs	TIMIN1		; c==1 means no good char
 3657   4FC9               	TMBAD:
 3658   4FC9   A6 58       		ldx	MOUSEF		; is there a mouse/joystick?
 3659   4FCB   F0 07       		beq	TIMIN2		; nope
 3660   4FCD   08          		php			; save status
 3661   4FCE   48          		pha			; save (possible) char
  Tue Jun 13 1989 11:42                                                                                                  Page   55

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3662   4FCF   20 84 62    		jsr	MSCOFF		; turn off mouse cursor
 3663   4FD2   68          		pla			; get char back
 3664   4FD3   28          		plp			; get return status
 3665   4FD4               	TIMIN2:
 3666   4FD4   60          		rts			; and away we go
 3667                      	;
 3668                      	; FKEYX - move the mouse cursor if any, then check for keystroke
 3669                      	;
 3670   4FD5               	FKEYX:
 3671   4FD5   A5 58       		lda	MOUSEF		; is there a mouse cursor?
 3672   4FD7   F0 38       		beq	KEYX		; nope
 3673   4FD9   30 07       		bmi	KEYMOUSE	; handle mouse
 3674   4FDB   20 9C 50    		jsr	DO_STICK	; handle joystick
 3675   4FDE   10 31       		bpl	KEYX		; go look for key still
 3676   4FE0   30 05       		bmi	KEYBTN		; do button handling
 3677   4FE2               	KEYMOUSE:
 3678   4FE2   20 5D 50    		jsr	DO_MOUSE	; handle mouse stuff
 3679   4FE5   10 2A       		bpl	KEYX		; go look for key still
 3680                      	;
 3681                      	; button hit, so show pos in MSTBL
 3682                      	;
 3683   4FE7               	KEYBTN:
 3684   4FE7   48          		pha			; save status
 3685   4FE8   A5 CE       		lda	MSTBL+LO
 3686   4FEA   85 8F       		sta	SPCL
 3687   4FEC   A5 CF       		lda	MSTBL+HI
 3688   4FEE   85 90       		sta 	SPCH
 3689   4FF0   A5 D0       		lda	MSTBL+ABANK
 3690   4FF2   85 91       		sta	SPCBNK
 3691   4FF4   A9 03       		lda	#ZMSLOCX+1	; point to LSB of mouse x
 3692   4FF6   20 33 90    		jsr	ADDSPC		; add to point
 3693   4FF9   A5 CB       		lda	MSX		; get X
 3694   4FFB   18          	        clc                     ; center the hot spot
 3695   4FFC   69 01       	        adc     #CURSW/2        ; add 1/2 width
 3696   4FFE   20 67 92    		jsr	STASHB		; and stuff it away
 3697   5001   A9 02       		lda	#2		; 2 more to get to mouse y
 3698   5003   20 33 90    		jsr	ADDSPC		; okay
 3699   5006   A5 CC       		lda	MSY		; now show the world the y pos
 3700   5008   18          	        clc                     ; and center vertically too
 3701   5009   69 02       	        adc     #CURSH/2        ; add 1/2 height
 3702   500B   20 67 92    		jsr	STASHB		; and it is away
 3703   500E   68          		pla			; get status back
 3704   500F   A8          		tay			; and set it again
 3705   5010   60          		rts			; otherwise, done
 3706   5011               	KEYX:
 3707   5011   AD 00 C0    		lda	KBD		; check keyboard strobe
 3708   5014   10 03       		bpl	KEYXX		; nothing
 3709   5016   8D 10 C0    		sta	ANYKEY		; reset strobe
 3710   5019               	KEYXX:
 3711   5019   60          		rts
 3712                      	;
 3713                      	; MOVE_MC - move the mouse/joystick cursor, if necessary
 3714                      	;
 3715   501A               	MOVE_MC:
 3716   501A   A5 58       		lda	MOUSEF		; check which kind to move
 3717   501C   10 06       		bpl	MOVE_MC1	; move joystick cursor
 3718   501E   20 30 50    		jsr	CHK_MOUSE	; move the mouse cursor
 3719   5021   4C 27 50    		jmp 	MOVE_MC2	; and print it
 3720   5024               	MOVE_MC1:
 3721   5024   20 A2 50    		jsr	MOVE_STICK	; okay, checked it out
 3722   5027               	MOVE_MC2
 3723   5027   AD 12 03    		lda	MSMOVEF		; did it move?
 3724   502A   F0 03       		beq	MOVE_MCX	; nope
 3725   502C   4C 79 62    		jmp	MSCURS		; print it
 3726   502F               	MOVE_MCX:
 3727   502F   60          		rts			; done
 3728                      	;
 3729                      	; CHK_MOUSE - check the mouse position and button state, and flag any change
 3730                      	;
 3731   5030               	CHK_MOUSE:
 3732   5030   AD 54 C0    		lda	PAGE2SW		; make sure we are pointing to main bank
 3733                      	
 3734   5033   A2 02       		ldx	#READM		; get me current cursor pos
 3735   5035   20 00 03    		jsr	MOUSER		; turn off interrupts and set current pos
 3736                      	
  Tue Jun 13 1989 11:42                                                                                                  Page   56

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3737   5038   AD 83 C0    		lda	BNK2SET		; make sure we are pointing to second bank
 3738   503B   AD 83 C0    		lda	BNK2SET		; okay
 3739                      	
 3740   503E   AD 78 07    	MSFIX0	lda	MOUSEST		; get status byte
 3741   5041   A8          		tay			; save for a sec
 3742   5042   29 20       		and	#$20		; moved since last time?
 3743   5044   F0 0D       		beq	CHKM1		; nope
 3744   5046   8D 12 03    		sta	MSMOVEF		; show movement
 3745   5049   AD 78 04    	MSFIX1	lda	MOUSEXL		; get mouse X pos
 3746   504C   85 CB       		sta	MSX		; save new one
 3747   504E   AD F8 04    	MSFIX2	lda	MOUSEYL		; and the y pos
 3748   5051   85 CC       		sta	MSY		; save for me
 3749   5053               	CHKM1:
 3750   5053   98          		tya			; get status back
 3751   5054   29 C0       		and	#$C0            ; is button down?
 3752   5056   F0 02       		beq	CHKMX		; nope
 3753   5058   A9 80       		lda	#$80            ; show down state
 3754   505A               	CHKMX:
 3755   505A   4C 14 51    	        jmp     CHK_BTN         ; check button state
 3756                      	;
 3757                      	; there is a mouse, so check it		 
 3758                      	;
 3759   505D               	DO_MOUSE:
 3760   505D   20 30 50    		jsr	CHK_MOUSE	; check the mouse please
 3761                      	; FALL THROUGH TO BUTTON CLICKING HANDLER
 3762                      	;	jmp	DO_BUTTON	; handle button clicking
 3763                      	;
 3764                      	; DO_BUTTON - handle button clicking, working with the timer to
 3765                      	; 	check for double clicking or not
 3766                      	;
 3767   5060               	DO_BUTTON:
 3768   5060   AD 12 03    		lda	MSMOVEF		; check moved flag
 3769   5063   F0 03       		beq	DOM01		; nope
 3770   5065   20 79 62    		jsr	MSCURS		; move mouse cursor
 3771   5068               	DOM01:
 3772   5068   A9 00       		lda	#0		; show no char
 3773   506A   AC 13 03    		ldy	MSBTNF		; check button flag
 3774   506D   10 15       		bpl	DOBX		; none
 3775                      	;
 3776                      	; button strike, check for double click
 3777                      	;
 3778   506F   8C F1 50    	        sty     JB_STATE        ; show new state
 3779   5072   A4 CA       		ldy	CLKCTR		; have we started click counter?
 3780   5074   10 08       		bpl	DOB02		; nope
 3781   5076   A0 01       		ldy	#1		; this resets counter
 3782   5078   84 CA       		sty	CLKCTR		; reset it
 3783   507A   A9 82       		lda	#DBL_CLK	; show double click char
 3784   507C   D0 14       		bne	DOBEXIT		; and finis
 3785   507E               	DOB02:
 3786   507E   A0 FA       		ldy	#-CLK_CNT	; set to double click timeout
 3787   5080   84 CA       		sty	CLKCTR		; okay
 3788   5082   30 0E       		bmi	DOBEXIT		;done
 3789   5084               	DOBX:
 3790   5084   A4 CA       		ldy	CLKCTR		; click counter counting?
 3791   5086   10 0A       		bpl	DOBEXIT		; nope
 3792   5088   E6 CA       		inc	CLKCTR		; count it then
 3793   508A   D0 06       		bne	DOBEXIT		; all done
 3794   508C   A0 01       		ldy	#1		; reset counter
 3795   508E   84 CA       		sty	CLKCTR		; okay
 3796   5090   A9 81       		lda	#SGL_CLK	; set as char
 3797   5092               	DOBEXIT:
 3798   5092   A0 00       		ldy	#0		; clear out flags
 3799   5094   8C 13 03    		sty	MSBTNF		; button flag
 3800   5097   8C 12 03    		sty	MSMOVEF		; moved flag
 3801   509A   A8          		tay			; set flag to show any char
 3802   509B   60          		rts			; return char	
 3803                      	;
 3804                      	; DO_STICK - handle the joystick 'interrupt'
 3805                      	;
 3806   509C               	DO_STICK:
 3807   509C   20 A2 50    		jsr	MOVE_STICK	; first move it
 3808   509F   4C 60 50    		jmp	DO_BUTTON	; now handle it
 3809   50A2               	MOVE_STICK:
 3810   50A2   A9 00       		lda	#0		; get horizontal change
 3811   50A4   20 F2 50    		jsr	READ_STICK	; puts value in Y
  Tue Jun 13 1989 11:42                                                                                                  Page   57

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3812   50A7   C0 50       		cpy	#80		; if < 80, then jump to the left
 3813   50A9   B0 0D       		bcs	DOST1		; it is not
 3814   50AB   A5 CB       		lda	MSX		; make sure X is > 0
 3815   50AD   F0 1A       		beq	DOST2		; it is == 0, can't get smaller
 3816   50AF   8D 12 03    		sta	MSMOVEF		; show movement
 3817   50B2   C6 CB       		dec	MSX		; move one to the left
 3818   50B4   C6 CB       		dec	MSX		; move two to the left
 3819   50B6   D0 11       		bne	DOST2		; now check vertical
 3820   50B8               	DOST1:
 3821   50B8   C0 B4       		cpy	#180		; if > 160, then move right
 3822   50BA   90 0D       		bcc	DOST2		; nope
 3823   50BC   A5 CB       		lda	MSX		; make sure X is in bounds
 3824   50BE   C9 88       		cmp	#MAXWIDTH-4	; don't go too far
 3825   50C0   B0 07       		bcs	DOST2		; already maxxed out
 3826   50C2   8C 12 03    		sty	MSMOVEF		; show movement
 3827   50C5   E6 CB       		inc	MSX		; one step to the left
 3828   50C7   E6 CB       		inc	MSX		; and another one
 3829   50C9               	DOST2:
 3830   50C9   A9 01       		lda	#1		; now check vertical
 3831   50CB   20 F2 50    		jsr	READ_STICK	; ask the monitor
 3832   50CE   C0 50       		cpy	#80		; if < 80, move up
 3833   50D0   B0 0D       		bcs	DOST3		; nope
 3834   50D2   A5 CC       		lda	MSY		; don't go negative
 3835   50D4   F0 1A       		beq	DOST4		; already minned out
 3836   50D6   8D 12 03    		sta	MSMOVEF		; show movement
 3837   50D9   C6 CC       		dec	MSY		; count down
 3838   50DB   C6 CC       		dec	MSY		; twice
 3839   50DD   D0 11       		bne	DOST4		; all done
 3840   50DF               	DOST3:
 3841   50DF   C0 B4       		cpy	#180		; check for downward motion
 3842   50E1   90 0D       		bcc	DOST4		; none
 3843   50E3   A5 CC       		lda	MSY		; check for maximum
 3844   50E5   C9 BD       		cmp	#MAXHEIGHT-3	; don't go below water
 3845   50E7   B0 07       		bcs	DOST4		; gone, thanx
 3846   50E9   8C 12 03    		sty	MSMOVEF		; show movement
 3847   50EC   E6 CC       		inc	MSY		; go further down
 3848   50EE   E6 CC       		inc	MSY		; twice as far for joystick
 3849   50F0               	DOST4:
 3850   50F0   60          		rts			; done
 3851                      	;
 3852                      	; READ_STICK - read the x or y value of the stick in mind.
 3853                      	;       [A] == 0 or 1 - the "stick" you are interested in
 3854                      	;       Also, check the button status.
 3855                      	;
 3856   50F1   00          	JB_STATE  db    0               ; last state of joystick button
 3857   50F2               	READ_STICK:
 3858   50F2   48          		pha			; save which stick we want
 3859   50F3   A2 E0       		ldx	#$E0            ; oh, pick something random
 3860   50F5               	READST2:
 3861   50F5   20 0A 51    	        jsr     CHECK_JOYBTN    ; check the joystick button
 3862   50F8   CA          		dex
 3863   50F9   D0 FA       		bne	READST2
 3864   50FB   68          		pla			; get x back
 3865   50FC   AA          	        tax                     ; got it
 3866   50FD   AD 82 C0    	        lda     RDROM           ; bring ROM back
 3867   5100   20 1E FB    		jsr	MPREAD		; NOW do the read
 3868   5103   AD 83 C0    	        lda     BNK2SET         ; back to RAM
 3869   5106   AD 83 C0    	        lda     BNK2SET         ; back to RAM
 3870   5109   60          	        rts
 3871   510A               	CHECK_JOYBTN:
 3872   510A   A5 58       		lda	MOUSEF		; check which kind to move
 3873   510C   10 03       		bpl	DO_JBTN         ; no joystick, check mouse
 3874   510E   4C 30 50    	        jmp     CHK_MOUSE       ; then do the mouse
 3875   5111               	DO_JBTN:
 3876   5111   AD 61 C0    	        lda     APKEY1          ; get joystick button
 3877   5114               	CHK_BTN:
 3878   5114   30 03       	        bmi     READST3         ; button down
 3879   5116   8D F1 50    	        sta     JB_STATE        ; show button went up        
 3880   5119               	READST3:
 3881   5119   4D F1 50    	        eor     JB_STATE        ; toggle previous state        
 3882   511C   8D 13 03    	        sta     MSBTNF          ; set button flag
 3883   511F   60          	        rts
 3884                      	; ----------------------------
 3885                      	; FETCH ASCII KEYCODE INTO [A]
 3886                      	; ----------------------------
  Tue Jun 13 1989 11:42                                                                                                  Page   58

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3887                      	; EXIT: ASCII IN [A] & [IOCHAR]
 3888                      	
 3889   5120               	GETKEY:
 3890   5120   A9 03       		lda	#BLINK_RATE	; flag as wait for good key
 3891   5122   8D 81 4F    		sta	CURCOUNT	; clear blinker
 3892   5125   A5 58       		lda	MOUSEF		; is there a mouse/joystick?
 3893   5127   F0 03       		beq	GTK0		; nope
 3894   5129   20 E3 62    		jsr	MSCON		; turn on mouse cursor
 3895   512C               	GTK0:
 3896   512C   A9 00       		lda	#0		; clear line counter
 3897   512E   85 AB       		sta	LINCNT		; okay, we did
 3898   5130   8A          		txa			; SAVE [X] & [Y]
 3899   5131   48          		pha		
 3900   5132   98          		tya		
 3901   5133   48          		pha		
 3902   5134               	GKEY0:
 3903   5134   E6 A5       		inc	RAND+HI		; just whack on random number
 3904   5136   C6 A4       		dec	RAND+LO		; and more
 3905   5138   20 D5 4F    		jsr	FKEYX		; is there a key?
 3906   513B   30 23       		bmi	GKEY01		; got the key
 3907                      	
 3908   513D   20 16 4F    		jsr	WAIT10		; wait .1 seconds, moving mouse cursor
 3909                      	
 3910   5140   A5 58       	        lda     MOUSEF          ; do we have a joystick/mouse?
 3911   5142   F0 0D       	        beq     GKEY02          ; nope
 3912   5144   AD D2 6C    	        lda     PTR_COUNT       ; count down counter?
 3913   5147   F0 05       	        beq     GKEY00          ; nope
 3914   5149   CE D2 6C    	        dec     PTR_COUNT       ; count one wait cycle
 3915   514C   D0 03       	        bne     GKEY02          ; don't check yet
 3916   514E               	GKEY00:
 3917   514E   20 0A 51    	        jsr     CHECK_JOYBTN    ; check the joystick button, just fur the heckuvit
 3918   5151               	GKEY02:
 3919   5151   CE 81 4F    		dec	CURCOUNT	; down one
 3920   5154   D0 DE       		bne	GKEY0		; no toggle
 3921   5156   20 82 4F    		jsr	STCUR		; okay, toggle
 3922   5159   A9 03       		lda	#BLINK_RATE	; 1 per second
 3923   515B   8D 81 4F    		sta	CURCOUNT	; okay
 3924   515E   D0 D4       		bne	GKEY0		; check for key
 3925   5160               	GKEY01:
 3926   5160   48          		pha			; save char
 3927   5161   A5 58       		lda	MOUSEF		; any mouse cursor?
 3928   5163   F0 03       		beq	GTK1		; nope
 3929   5165   20 84 62    		jsr	MSCOFF		; turn mouse cursor off
 3930   5168               	GTK1:
 3931   5168   68          		pla			; get char back
 3932   5169   20 AD 4F    		jsr	ERCUR		; so erase cursor
 3933   516C               	CHKKEY:
 3934   516C   20 7A 51    		jsr	PARSEKEY	; how was the key?
 3935   516F   B0 C3       		bcs	GKEY0		;TRY AGAIN
 3936   5171   85 AC       		sta	IOCHAR		;HOLD ON TO IT
 3937   5173   68          		pla			; RESTORE
 3938   5174   A8          		tay			; EVERYTHING
 3939   5175   68          		pla		
 3940   5176   AA          		tax		
 3941   5177   A5 AC       		lda	IOCHAR		; GET CHAR INTO [A]
 3942   5179   60          		rts			; AND RETURN IT
 3943                      	
 3944                      	;
 3945                      	; CHECK TO MAKE SURE KEY IS VALID, ONLY ACCEPT IT IF IT IS
 3946                      	;
 3947   517A               	PARSEKEY:
 3948   517A   29 7F       		and	#$7F	;SCREEN OUT SHIFTS
 3949                      	;
 3950                      	;CHECK FOR "ARROWS" & FUNCTION KEYS (X),  CONVERT FOR USE (EZIP)
 3951                      	;ALSO : CHANGE <_>)@%^&*( TO ,-.0256789 - and 'mouse' clicks
 3952                      	; and other kinds of special chars
 3953                      	;
 3954   517C               	GK0:
 3955   517C   A2 12       		ldx	#ENDKEY ; GET LENGTH OF LIST
 3956   517E               	GK2:
 3957   517E   DD C3 51    		cmp	HAVE,X	; CHECK AGAINST LIST OF UNWANTED KEYS
 3958   5181   F0 05       		beq	GK3	; FOUND IT
 3959   5183   CA          		dex
 3960   5184   10 F8       		bpl	GK2	; CHECK THEM ALL
 3961   5186   30 05       		bmi	GK4	; NOT FOUND, CONTINUE OTHER CHECKS
  Tue Jun 13 1989 11:42                                                                                                  Page   59

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- MACHINE-DEPENDENT I/O: APPLE II ---"

 3962   5188               	GK3:
 3963   5188   BD D6 51    		lda	WANT,X	; GET KEY TO USE INSTEAD
 3964   518B   18          		clc		; show niceness
 3965   518C   60          		rts		; done
 3966   518D               	GK4:
 3967   518D   C9 20       		cmp	#SPACE	; NO CTRL CHARS ACCEPTABLE
 3968   518F   90 14       		bcc	BADKEY	; IF < SPACE, BAD
 3969                      	
 3970   5191   C9 3C       		cmp	#'<'	; pick up numbers and most punctuation
 3971   5193   90 15       		bcc	OK	; we did
 3972                      	
 3973   5195   C9 7B       		cmp	#'z'+1	;PICK OUT LETTERS NOW
 3974   5197   B0 0C       		bcs	BADKEY	;IF > BAD
 3975   5199   C9 61       		cmp	#'a'
 3976   519B   B0 0D       		bcs	OK	;IF > OK
 3977   519D   C9 41       		cmp	#'A'
 3978   519F   90 04       		bcc	BADKEY
 3979   51A1   C9 5B       		CMP	#'Z'+1	
 3980   51A3   90 05       		BCC	OK	;IF < OK
 3981   51A5               	BADKEY:
 3982   51A5   20 B3 4E    		jsr	BEEP	;BAD KEY, GIVE WARNING NOISE, gwon back
 3983   51A8   38          		sec		; show badness
 3984   51A9   60          		rts		; and done
 3985   51AA               	OK:
 3986   51AA   C9 30       		cmp	#'0'	; check for number keys
 3987   51AC   90 13       		bcc	OKj	; nope, < 0
 3988   51AE   C9 3A       		cmp	#'9'+1	; more than a nine?
 3989   51B0   B0 0F       		bcs	OKj	; ayyup
 3990                      	;
 3991                      	; here we check for the closed apple key being down too
 3992                      	;
 3993   51B2   AE 62 C0    		ldx	APKEY2	; how about the closed apple key
 3994   51B5   10 0A       		bpl	OKj	; not pressed,	so use as number key
 3995                      	;
 3996                      	; transform number key into a function key
 3997                      	;
 3998   51B7   18          		CLC		; get ready for add
 3999   51B8   69 54       		ADC	#84	; transforms '1'-'9' to 133-141
 4000   51BA   C9 84       		CMP	#132	; but '0' wants to be a 142!
 4001   51BC   D0 03       		BNE 	OKj	; but it's not it
 4002   51BE   18          		CLC		; again, don't want carry
 4003   51BF   69 0A       		ADC	#10	; voila!
 4004   51C1               	OKj:
 4005   51C1   18          		clc		; show a wicked good character is about to arrive
 4006   51C2   60          		rts		; toots finis
 4007                      	
 4008   51C3   0B 0A 08 15 7F 	HAVE:	DB	$0B,$0A,$08,$15,$7f,ESCAPE,$3C,$7C,$3F
        51C8   1B 3C 7C 3F 
 4009   51CC   3C 5F 3E 40 25 		DB	$3C,$5F,$3E,$40,$25,$5E,$26,$01,$02, EOL
        51D1   5E 26 01 02 0D 
 4010   51D6   81 82 83 84 08 	WANT:	DB	129,130,131,132,08,ESCAPE,$3C,$7C,$3F
        51DB   1B 3C 7C 3F 
 4011   51DF   2C 2D 2E 32 35 		DB	$2C,$2D,$2E,$32,$35,$36,$37,254,253, EOL
        51E4   36 37 FE FD 0D 
 4012          0012        	ENDKEY	EQU	$-WANT-1
 4013                      	
 4014   51E9               		END
 4015                      	
 4016   51E9               		INCLUDE		IO.ASM	
 4017   51E9               		STTL "--- GAME I/O: APPLE II ---"
 4018                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page   60

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4019                      	
 4020                      		; --------------
 4021                      		; INTERNAL ERROR
 4022                      		; --------------
 4023                      		; ENTRY: ERROR CODE IN [A]
 4024                      		; EXIT: HA!
 4025                      	
 4026   51E9   0D 49 6E 74 65 	ERRM:	DB	EOL,"Internal error "
        51EE   72 6E 61 6C 20 
        51F3   65 72 72 6F 72 
        51F8   20 
 4027          0010        	ERRML	EQU	$-ERRM
 4028                      	
 4029   51F9               	ZERROR:
 4030   51F9   48          		pha			; save err number
 4031   51FA   20 99 4C    	        jsr     SWAP2INFOW      ; go to the info window (window 0)`
 4032   51FD               		DLINE	ERRM		; print message
 4033   51FD   A2 E9       		ldx	#<ERRM	; get part of ERRM
 4034   51FF   A9 51       		lda	#>ERRM	; get other part of string
 4035          [01]        		IFMA	2		; check to see if length passed in
 4036                      		ldy			; then just fetch it
 4037          [01]        		ELSE
 4038   5201   A0 10       		ldy	#ERRML	; get length of string
 4039          [00]        		ENDIF
 4040   5203   20 5B 4C    		jsr	DLINE		; print the string
 4041   5206               		.MACEND
 4042   5206   68          		pla			; get error number
 4043   5207   20 C3 47    		jsr	HEXNUM		; print error number
 4044   520A   4C 10 52    		jmp	ZQUIT1		; and die
 4045                      	
 4046                      	
 4047                      		; ----
 4048                      		; QUIT
 4049                      		; ----
 4050                      	
 4051   520D   20 E9 54    	ZQUIT:	JSR	ZCRLF		; FLUSH BUFFER
 4052   5210               	ZQUIT1:
 4053   5210               		DLINE	ENDM		; print ending message
 4054   5210   A2 7B       		ldx	#<ENDM	; get part of ENDM
 4055   5212   A9 52       		lda	#>ENDM	; get other part of string
 4056          [01]        		IFMA	2		; check to see if length passed in
 4057                      		ldy			; then just fetch it
 4058          [01]        		ELSE
 4059   5214   A0 10       		ldy	#ENDML	; get length of string
 4060          [00]        		ENDIF
 4061   5216   20 5B 4C    		jsr	DLINE		; print the string
 4062   5219               		.MACEND
 4063   5219   20 0D 8D    		jsr	GETRET		; wait for <CR>
 4064   521C   A5 59       	        lda     INFODOS         ; in dinky-dos?
 4065   521E   F0 17       	        beq     ZQUIT2          ; nope
 4066   5220   A9 00       	        lda     #0              ; clear power up byte
 4067   5222   8D F4 03    	        sta     $3F4            ; make it do cold boot        
 4068   5225   AD FD FF    	        lda     RESET_VECTOR+HI ; now, set up where to die to
 4069   5228   8D 36 52    	        sta     ZQUITR1+2
 4070   522B   AD FC FF    	        lda     RESET_VECTOR+LO
 4071   522E   8D 35 52    	        sta     ZQUITR1+1
 4072   5231   AD 82 C0    	        lda     RDROM           ; get ROM back
 4073   5234               	ZQUITR1:
 4074   5234   4C FC FF    	        jmp     RESET_VECTOR    ; just reset things
 4075                      	;
 4076                      	; re-enable /RAM
 4077                      	;
 4078   5237               	ZQUIT2:
 4079   5237   AE 31 BF    		ldx	DEVCNT		; put device in at end
 4080   523A   E8          		inx			; point to one past end
 4081   523B   8E 31 BF    		stx	DEVCNT		; show new count
 4082   523E   A9 BF       		lda	#$BF		; /RAM ID
 4083   5240   9D 32 BF    		sta	DEVNUM,X	; save it
 4084   5243   AD 7F 07    		lda	OLDVEC+HI	; restore old vector
 4085   5246   8D 27 BF    		sta	RAMVEC+HI
 4086   5249   AD 7E 07    		lda	OLDVEC+LO
 4087   524C   8D 26 BF    		sta	RAMVEC+LO
 4088                      	;
 4089                      	; now format /RAM
 4090                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page   61

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4091   524F   A9 03       		lda	#3		; stash into FORMAT parm block
 4092   5251   85 42       		sta	$42		; it goes here, oddly enough
 4093   5253   A9 B0       		lda	#$B0		; device id for /RAM
 4094   5255   85 43       		sta	$43		; and here it goes
 4095   5257   A9 11       		lda	#>GAME1FIO	; IO buffer
 4096   5259   85 45       		sta	$45		; this is where it goes
 4097   525B   A9 00       		lda	#<GAME1FIO	; lsb
 4098   525D   85 44       		sta	$44
 4099   525F   AD 80 C0    		lda	RDBNK2		; set up card for driver
 4100   5262   20 78 52    		jsr	RAMDRV		; format /RAM
 4101   5265   AD 82 C0    		lda	RDROM		; get ROM back
 4102   5268               		
 4103   5268   8D 51 C0    		sta	TEXTSW+ON	; turn on text
 4104   526B               		QUIT	QUIT_PB		
 4105   526B               		PRODOS 	$65, QUIT_PB
 4106   526B   20 00 BF    		jsr	$BF00	; ProDOS handler
 4107   526E   65          		DB	$65	; ProDOS function code
 4108   526F   7152        		DW	QUIT_PB	; Function Parameter Block address
 4109   5271               		.MACEND
 4110   5271               		.MACEND
 4111   5271               	QUIT_PB:
 4112   5271   04          		db	4		; 4 parms
 4113   5272   00 00 00 00 00 		db	0,0,0,0,0,0	; just zeros
        5277   00 
 4114   5278               	RAMDRV:
 4115   5278   6C 26 BF    		jmp	(RAMVEC)	; goto RAM driver
 4116                      	
 4117   527B   0D 45 6E 64 20 	ENDM:	DB	EOL,"End of session."
        5280   6F 66 20 73 65 
        5285   73 73 69 6F 6E 
        528A   2E 
 4118          0010        	ENDML	EQU	$-ENDM
 4119                      	
 4120                      	; -------
 4121                      	; RESTART
 4122                      	; -------
 4123   528B               	BOOT_RD:
 4124   528B   04          		db 	4
 4125   528C   00          		db	0
 4126   528D   0020        		dw	BORG		; put into where it wants
 4127   528F   FFFF        		dw	$FFFF		; read lots
 4128   5291               	BOOTNAME:
 4129   5291   0E          		db	BNAMEL		; length will go here
 4130   5292   49 4E 46 4F 43 	        db      "INFOCOM.SYSTEM"
        5297   4F 4D 2E 53 59 
        529C   53 54 45 4D 
 4131          000E        	BNAMEL  EQU     $-BOOTNAME-1
 4132   52A0               	ZSTART:
 4133   52A0   20 C1 8C    		jsr	CLOSE_GAME	; make sure everything is closed
 4134                      	
 4135   52A3   A9 FF       		lda	#$FF		; just do a clear -1
 4136   52A5   85 63       		sta	ARG1+LO		; done
 4137   52A7   20 B8 57    		jsr	ZCLR		; to clear screen and set up window 0
 4138   52AA   A9 91       		lda	#<BOOTNAME	; now, set open file name
 4139   52AC   8D C7 45    		sta	OPEN_FILE+OP_PATHNAME+LO
 4140   52AF   A9 52       		lda	#>BOOTNAME
 4141   52B1   8D C8 45    		sta	OPEN_FILE+OP_PATHNAME+HI
 4142   52B4   A9 31       		lda	#'1'		; set disk name to disk #1
 4143   52B6   8D B5 49    	        sta     SAVENUM         ; show open_gamef
 4144   52B9   20 12 4B    	        jsr     OPEN_GAMEF      ; okay
 4145                      	
 4146   52BC   AD CB 45    		lda	OPEN_FILE+OP_REFNUM ; get ref num
 4147   52BF   8D 8C 52    		sta	BOOT_RD+RD_REFNUM ; save ref num
 4148   52C2   8D 35 8B    		sta	CLOSE_PB+CL_REFNUM
 4149   52C5               		READ	BOOT_RD		; read in boot system
 4150   52C5               		PRODOS	$CA, BOOT_RD
 4151   52C5   20 00 BF    		jsr	$BF00	; ProDOS handler
 4152   52C8   CA          		DB	$CA	; ProDOS function code
 4153   52C9   8B52        		DW	BOOT_RD	; Function Parameter Block address
 4154   52CB               		.MACEND
 4155   52CB               		.MACEND
 4156   52CB   90 03       		bcc	ZSTRTX		; okay, everything is fine
 4157   52CD   4C 64 47    		jmp	DISK_FATAL	; die otherwise
 4158   52D0               	ZSTRTX:
 4159   52D0               		CLOSE	CLOSE_PB	; and close it up
  Tue Jun 13 1989 11:42                                                                                                  Page   62

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4160   52D0               		PRODOS	$CC, CLOSE_PB
 4161   52D0   20 00 BF    		jsr	$BF00	; ProDOS handler
 4162   52D3   CC          		DB	$CC	; ProDOS function code
 4163   52D4   348B        		DW	CLOSE_PB	; Function Parameter Block address
 4164   52D6               		.MACEND
 4165   52D6               		.MACEND
 4166   52D6   4C 00 20    		jmp	BORG		; and go to it
 4167   52D9               		
 4168                      		; --------------------------------
 4169                      		; RETURN RANDOM BYTES IN [A] & [X]
 4170                      		; --------------------------------
 4171   52D9               	RANDOM:
 4172   52D9   E6 A5       	        inc	RAND+HI	
 4173   52DB   C6 A4       		dec	RAND+LO	
 4174   52DD   A5 A4       		lda	RAND+LO         ; get LSB
 4175   52DF   65 A5       	        adc     RAND+HI         ; add MSB
 4176   52E1   29 7F       	        and     #$7F            ; don't let it go into $C0 page
 4177   52E3   85 A5       	        sta     RAND+HI         ; new MSB        
 4178   52E5   A8          	        tay                     ; get random offset
 4179   52E6   B1 A4       	        lda     (RAND),Y        ; get random number
 4180   52E8   AA          	        tax                     ; save in X
 4181   52E9   65 A4       	        adc     RAND+LO         ; and go to another spot
 4182   52EB   29 7F       	        and     #$7F            ; don't go above $80
 4183   52ED   85 A5       	        sta     RAND+HI         ; okay
 4184   52EF   A8          	        tay                     ; more randomness
 4185   52F0   B1 A4       	        lda     (RAND),Y        ; and get it again
 4186   52F2   05 A5       	        ora     RAND+HI         ; set more bits
 4187   52F4   60          		rts		
 4188                      	
 4189                      	
 4190                      		; -------------------
 4191                      		; Z-PRINT A CHARACTER
 4192                      		; -------------------
 4193                      		; ENTRY: ASCII CHAR IN [A]
 4194                      		; COMMENT: SCRIPTING IS HANDLED IN UNBUFR AND FLUSH,
 4195                      		; SO CAN OUTPUT TO PRINTER AS A LINE.  TABLE AND SCREEN
 4196                      		; OUTPUT IS SET UP HERE, HANDLED A BYTE AT A TIME
 4197                      		; (DIROUT CHANGES 6/24/85)
 4198                      	
 4199   52F5               	COUT:
 4200   52F5   85 AC       		sta	IOCHAR		; HOLD IT A SEC
 4201   52F7   A6 B2       		ldx	TABLEF		; OUTPUT TO TABLE?
 4202   52F9   F0 07       		beq	COUT1		; NO
 4203   52FB   A6 19       		ldx	FMTTBL		; formatted table?
 4204   52FD   D0 0D       		bne	COUT5		; yes, so just do it normal
 4205   52FF   4C 77 53    		jmp	TBLOUT		; just put into table
 4206   5302               	COUT1:
 4207   5302   A6 B1       		ldx	SCREENF		; OUTPUT TO SCREEN?
 4208   5304   D0 06       		bne	COUT5		; YES
 4209   5306   AE A1 6C    		ldx	SCRIPTF		; OUTPUT TO PRINTER?
 4210   5309   D0 01       		bne	COUT5		; YES
 4211   530B   60          		rts			; NO, SO DONE
 4212   530C               	COUT5:
 4213   530C   A5 AC       		lda	IOCHAR		; RETRIEVE CHAR
 4214   530E   30 5D       		bmi	COUT2		; highlight chars have no width
 4215                      	;
 4216                      	; this is an entry point for DLINE, so it doesn't check any of the above
 4217                      	; things.  Enter with character in [A]
 4218                      	;
 4219   5310               	DIRECT_OUT: 
 4220   5310   C9 0D       		cmp	#EOL		; IF ASCII EOL, just handle it special
 4221   5312   D0 03       		bne	COUT0	
 4222                      	
 4223   5314   4C E9 54    		jmp	ZCRLF		; DO IT
 4224   5317               	COUT0:
 4225   5317   B0 20       		bcs	COUT02          ; not control character
 4226   5319   C9 0B       	        cmp     #EOS            ; control-k (end of sentence)?
 4227   531B   F0 0E       	        beq     COUT01          ; yes, so put out 2 spaces
 4228   531D   C9 09       	        cmp     #TAB            ; tab char?
 4229   531F   D0 55       	        bne     CEX             ; ignore all other control chars
 4230                      	;
 4231                      	; this means do a couple of spaces
 4232                      	;
 4233   5321   A9 20       	        lda     #SPACE          ; do 3 spaces for start of line
 4234   5323   20 F5 52    	        jsr     COUT            ; a little recursion never hurt!
  Tue Jun 13 1989 11:42                                                                                                  Page   63

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4235   5326   A6 A9       	        ldx     CHRCNT          ; back to beginning of line?
 4236   5328   D0 01       	        bne     COUT01          ; nope
 4237   532A               	COUT010:
 4238   532A   60          	        rts                     ; don't do any to start line
 4239   532B               	COUT01:
 4240   532B   A9 20       	        lda     #SPACE          ; 2 more spaces
 4241   532D   20 F5 52    	        jsr     COUT
 4242   5330   A6 A9       	        ldx     CHRCNT          ; back to zero?
 4243   5332   F0 F6       	        beq     COUT010         ; yes, so don't add to start of line
 4244                      	
 4245   5334   A9 20       	        lda     #SPACE          ; last one
 4246   5336   4C F5 52    	        jmp     COUT            ; finally
 4247   5339               	COUT02:
 4248   5339   AA          		tax			; use char as index
 4249   533A   A5 C1       		lda	FONTFLG		; get which font we be using
 4250   533C   F0 04       		beq	COUTF1		; must be variable width
 4251   533E   A9 0C       		lda	#MONOFONT_W	; get width then of mono font
 4252   5340   D0 03       		bne	COUTF2		; okay, now do add
 4253   5342               	COUTF1:
 4254   5342   BD 53 64    		lda	CHWID,X		; get width of char
 4255   5345               	COUTF2:
 4256   5345   18          		clc 			; get ready for add
 4257   5346   65 A7       		adc	LENGTH+LO	; ADD LINE LENGTH COUNTER
 4258   5348   85 A7       		sta	LENGTH+LO	; update length
 4259   534A   90 02       		bcc	COUT0C		; no wrap
 4260   534C   E6 A8       		inc	LENGTH+HI	; okay, wrap then
 4261   534E               	COUT0C:
 4262   534E   A5 A8       		lda	LENGTH+HI	; get MSB
 4263   5350   C5 A3       		cmp	XSIZE+HI	; check MSB first
 4264   5352   90 19       		bcc	COUT2		; no need to check lsb
 4265   5354   D0 08       		bne	COUT00		; XSIZE < LENGTH?
 4266   5356               		
 4267   5356   A5 A7       		lda	LENGTH+LO	; check LSB
 4268   5358   C5 A2       		cmp	XSIZE+LO	; END OF SCREEN LINE?
 4269   535A   90 11       		bcc	COUT2		; haven't reached the end if XSIZE >= LENGTH
 4270   535C   F0 0F       		beq	COUT2		; okay
 4271   535E               	COUT00:
 4272   535E   AC 04 72    		ldy	WRPFLG		; are we wrapping
 4273   5361   F0 13       		beq	CEX		; no, so truncate
 4274   5363   A6 A9       		ldx	CHRCNT		; get character count
 4275   5365   A5 AC       		lda	IOCHAR		; get the character
 4276   5367   9D 00 02    		sta	LBUFF,X		; save current char in buffer
 4277   536A   4C 71 54    		jmp	FLUSH		; YES, FLUSH THE LINE
 4278   536D               	COUT2:
 4279   536D   A6 A9       		ldx	CHRCNT		; GET LINE POINTER
 4280   536F   A5 AC       		lda	IOCHAR		; get char back
 4281   5371   9D 00 02    		sta	LBUFF,X		; ADD CHAR TO BUFFER
 4282   5374   E6 A9       		inc	CHRCNT		; and point to next CHRCNT
 4283   5376               	CEX:
 4284   5376   60          		rts
 4285   5377               		
 4286                      		; ---------------
 4287                      		; OUTPUT TO TABLE
 4288                      		; ---------------
 4289                      	;
 4290                      	; this one just puts a char into the table
 4291                      	;
 4292   5377               	TBLOUT:
 4293   5377   AA          		tax			; HOLD CHAR A SEC.
 4294                      	;
 4295                      	; figger out length of line in there
 4296                      	;
 4297   5378   A5 C1       		lda	FONTFLG		; get which font we be using
 4298   537A   F0 04       		beq	TBLOUT1		; must be variable width
 4299   537C   A9 0C       		lda	#MONOFONT_W	; get width then of mono font
 4300   537E   D0 03       		bne	TBLOUT2		; okay, now do add
 4301   5380               	TBLOUT1:
 4302   5380   BD 53 64    		lda	CHWID,X		; get width of char
 4303   5383               	TBLOUT2:
 4304   5383   18          		clc			; add width
 4305   5384   6D 31 96    		adc	ZBEGIN+ZTWIDTH+1	; to current line width
 4306   5387   8D 31 96    		sta	ZBEGIN+ZTWIDTH+1	; save current width
 4307   538A   90 03       		bcc	TBLOUT3		; no wrap
 4308   538C   EE 30 96    		inc	ZBEGIN+ZTWIDTH+0	; wrap, then dammit
 4309   538F               	TBLOUT3:
  Tue Jun 13 1989 11:42                                                                                                  Page   64

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4310                      	;
 4311                      	; PUT BYTE IN TABLE AT CURRENT OFFSET
 4312                      	;
 4313   538F   AD AE 6C    		lda	DIRITM+LO	; ADD IN OFFSET
 4314   5392   18          		clc		
 4315   5393   65 A0       		adc	DIRTBL+LO	
 4316   5395   85 8F       		sta	SPCL		; and make it lo part
 4317   5397   AD AF 6C    		lda	DIRITM+HI	
 4318   539A   65 A1       		adc	DIRTBL+HI	
 4319   539C   20 A9 8F    		jsr	SETPC		; set the PC
 4320   539F   85 90       		sta	SPCH		; and this is high part
 4321   53A1   84 91       		sty	SPCBNK		; and the bank
 4322   53A3   8A          		txa			; PICK UP ASCII CHAR
 4323   53A4   20 67 92    		jsr	STASHB		; and save it
 4324                      	;
 4325                      	; SET ITM OFFSET TO NEXT POSITION, INCREMENT COUNTER
 4326                      	;
 4327   53A7   EE AE 6C    		inc	DIRITM+LO	; INC OFFSET TO NEXT BYTE
 4328   53AA   D0 03       		bne	TBLRTS	
 4329   53AC   EE AF 6C    		inc	DIRITM+HI	
 4330   53AF               	TBLRTS:
 4331   53AF   60          		rts
 4332                      	;
 4333                      	; PUT LBUFF IN TABLE AT CURRENT OFFSET
 4334                      	;
 4335   53B0               	TBLRTN:
 4336   53B0   AD AE 6C    		lda	DIRITM+LO	; get where we are
 4337   53B3   18          		clc
 4338   53B4   65 A0       		adc	DIRTBL+LO	; add in offset
 4339   53B6   85 8F       		sta	SPCL		; and make it lo part
 4340   53B8   85 8C       		sta	FPCL		; save for later usage
 4341   53BA   AD AF 6C    		lda	DIRITM+HI	; get hi part
 4342   53BD   65 A1       		adc	DIRTBL+HI	
 4343   53BF   20 A9 8F    		jsr	SETPC		; set the PC
 4344   53C2   85 90       		sta	SPCH		; and this is high part
 4345   53C4   85 8D       		sta	FPCH		; saving
 4346   53C6   84 91       		sty	SPCBNK		; and the bank
 4347   53C8   84 8E       		sty	FPCBNK		; and here too
 4348   53CA   A9 00       		lda	#0		; start counter off at zero
 4349   53CC   85 7A       		sta	J		; use J
 4350   53CE   85 7D       		sta	K+HI		; this will be line length
 4351   53D0   85 7C       		sta	K+LO		; both parts, please
 4352   53D2   20 D0 8F    		jsr	NEXTSPC		; point past the (word) counter
 4353   53D5   20 D0 8F    		jsr	NEXTSPC		; point past the counter
 4354   53D8               	TBLOOP:
 4355   53D8   A4 7A       		ldy	J		; get offset
 4356   53DA   B9 00 02    		lda	LBUFF,Y		; get char
 4357   53DD   AA          		tax			; save char
 4358   53DE   30 19       		bmi	TBLP1		; don't count hi light chars
 4359   53E0   C9 20       		cmp	#SPACE		; see if less than a space
 4360   53E2   90 15       		bcc	TBLP1		; no width if <$20
 4361   53E4   AA          		tax			; use char as index
 4362                      	
 4363   53E5   A5 C1       		lda	FONTFLG		; get which font we be using
 4364   53E7   F0 04       		beq	TBLF1		; must be variable width
 4365   53E9   A9 0C       		lda	#MONOFONT_W	; get width then of mono font
 4366   53EB   D0 03       		bne	TBLF2		; okay, now do add
 4367   53ED               	TBLF1:
 4368   53ED   BD 53 64    		lda	CHWID,X		; get width of char
 4369   53F0               	TBLF2:
 4370   53F0   18          		clc			; add width
 4371   53F1   65 7C       		adc	K+LO		; to current line width
 4372   53F3   85 7C       		sta	K+LO		; save current width
 4373   53F5   90 02       		bcc	TBLP1		; no wrap
 4374   53F7   E6 7D       		inc	K+HI		; wrap, then dammit
 4375   53F9               	TBLP1:
 4376   53F9   8A          		txa			; get char back
 4377   53FA   20 67 92    		jsr	STASHB		; and save it
 4378   53FD   20 D0 8F    		jsr	NEXTSPC		; next table entry
 4379   5400   E6 7A       		inc	J		; point to next char
 4380   5402   C6 A9       		dec	CHRCNT		; decrement counter
 4381   5404   D0 D2       		bne	TBLOOP		; get next one
 4382                      	;
 4383                      	; now fill with necessary spaces
 4384                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page   65

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4385   5406   A5 C1       		lda	FONTFLG		; first, set up width to be added
 4386   5408   F0 04       		beq	TBLSPF1		; must be variable width font
 4387   540A   A9 0C       		lda	#MONOFONT_W	; get mono width	
 4388   540C   D0 05       		bne	TBLSPF2		; okay
 4389   540E               	TBLSPF1:
 4390   540E   A2 20       		ldx	#SPACE		; get space index
 4391   5410   BD 53 64    		lda	CHWID,X		; okay
 4392   5413               	TBLSPF2:
 4393   5413   85 71       		sta	ARG8		; use temporarily
 4394   5415               	TBLSP:
 4395   5415   A5 7C       		lda	K+LO		; get how big line is
 4396   5417   18          		clc			; add in space
 4397   5418   65 71       		adc	ARG8		; pick up space width
 4398   541A   85 7C       		sta	K+LO		; saved
 4399   541C   90 02       		bcc	TBLSP1		; no wrap?
 4400   541E   E6 7D       		inc	K+HI		; yes, wrapping
 4401   5420               	TBLSP1:
 4402   5420   A5 A3       		lda	XSIZE+HI	; check against end
 4403   5422   C5 7D       		cmp 	K+HI		; compare against max width
 4404   5424   90 14       		bcc	TBLSPX		; all done then
 4405   5426   D0 06       		bne	TBLSP2		; no need to check if <>
 4406   5428   A5 A2       		lda	XSIZE+LO	; check LSB
 4407   542A   C5 7C       		cmp	K+LO		; well?
 4408   542C   90 0C       		bcc	TBLSPX		; all done then
 4409   542E               	TBLSP2:
 4410   542E   A9 20       		lda	#SPACE		; get it
 4411   5430   20 67 92    		jsr	STASHB		; save it
 4412   5433   20 D0 8F    		jsr	NEXTSPC		; point to next one
 4413   5436   E6 7A       		inc	J		; count it
 4414   5438   D0 DB       		bne	TBLSP		; and continue
 4415   543A               	TBLSPX:
 4416   543A   A9 00       		lda	#0		; show end of table
 4417   543C   85 A7       		sta	LENGTH+LO	; clear out line length too
 4418   543E   85 A8       		sta	LENGTH+HI	; and hi part too
 4419   5440   20 67 92    		jsr	STASHB		; marked with a zero
 4420   5443   20 D0 8F    		jsr	NEXTSPC		; point to LSB of next count
 4421   5446   A9 00       		lda	#0		; and stash another zero there
 4422   5448   20 67 92    		jsr	STASHB		; away it goes
 4423   544B   20 A5 90    		jsr	FP2SP		; have SPC point to beginning
 4424   544E   A9 00       		lda	#0		; upper byte of count is zero
 4425   5450   20 67 92    		jsr	STASHB		; show it
 4426   5453   20 D0 8F    		jsr	NEXTSPC		; point to LSB
 4427   5456   A5 7A       		lda	J		; get how many chars are there	
 4428   5458   20 67 92    		jsr	STASHB		; save at beginning of line
 4429   545B   E6 7A       		inc	J		; count (word) counter in offset
 4430   545D   E6 7A       		inc	J		; count counter in offset
 4431   545F   A5 7A       		lda	J		; get J back
 4432   5461   18          		clc			; add in where we were
 4433   5462   6D AE 6C    		adc	DIRITM+LO	; okay with lo part
 4434   5465   8D AE 6C    		sta	DIRITM+LO	; save it
 4435   5468   AD AF 6C    		lda	DIRITM+HI	; and now the hi part
 4436   546B   69 00       		adc	#0		; pick up carry, maybe
 4437   546D   8D AF 6C    		sta	DIRITM+HI	; and save it
 4438   5470   60          		rts
 4439                      	
 4440                      		; -------------------
 4441                      		; FLUSH OUTPUT BUFFER
 4442                      		; -------------------
 4443                      		; ENTRY: LENGTH OF BUFFER IN [X]
 4444                      	
 4445   5471               	FLUSH:
 4446   5471   8A          		txa			; is it zero?
 4447   5472   D0 01       		bne	FL00		; nope
 4448   5474   60          		rts			; just ignore if only one character
 4449   5475               	FL00:
 4450   5475   A9 20       		lda	#SPACE		; SPACE CHAR
 4451   5477   8E 91 6C    		stx	OLDEND		; SAVE CURRENT END OF LINE
 4452   547A               	FL0:
 4453   547A   DD 00 02    		cmp	LBUFF,X		; FIND LAST SPACE CHAR
 4454   547D   F0 06       		beq	FL1		; IN THE LINE
 4455   547F   CA          		dex
 4456   5480   D0 F8       		bne	FL0		; IF NONE FOUND,
 4457   5482   A6 A9       		ldx	CHRCNT		; FLUSH ENTIRE LINE
 4458   5484   CA          		dex			; minus last one
 4459   5485               	FL1:
  Tue Jun 13 1989 11:42                                                                                                  Page   66

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4460   5485   8E 90 6C    		stx	OLDLEN		; SAVE OLD LINE POS HERE
 4461   5488   86 A9       		stx	CHRCNT		; MAKE IT THE NEW LINE LENGTH
 4462   548A               		
 4463   548A   A5 B2       		lda	TABLEF		; are we doing table I/O?
 4464   548C   F0 06       		beq	FL11		; nope
 4465   548E   20 B0 53    		jsr	TBLRTN		; YES, DO IT 
 4466   5491   4C 97 54    		jmp	FL12		; so refill line
 4467   5494               	FL11:
 4468   5494   20 E9 54    		jsr	ZCRLF		; PRINT LINE UP TO LAST SPACE
 4469                      	;
 4470                      	; START NEW LINE WITH REMAINDER OF OLD
 4471                      	;
 4472   5497               	FL12:
 4473   5497   AE 90 6C    		ldx	OLDLEN		; GET OLD LINE POS
 4474   549A   A0 00       		ldy	#0		; START NEW LINE AT BEGINNING
 4475   549C               	FL2:
 4476   549C   E8          		inx		
 4477   549D   EC 91 6C    		cpx	OLDEND		; CONTINUE IF
 4478   54A0   90 05       		bcc	FL3		; INSIDE of end of line
 4479   54A2   F0 03       		beq	FL3		; or at end of line
 4480   54A4   84 A9       		sty	CHRCNT	
 4481   54A6   60          		rts		
 4482   54A7               	FL3:
 4483   54A7   BD 00 02    		lda	LBUFF,X		; GET CHAR FROM OLD LINE
 4484   54AA   C9 20       	        cmp     #SPACE          ; don't move start spaces in either
 4485   54AC   F0 25       	        beq     FL4             ; fine, I won't        
 4486   54AE   99 00 02    		sta	LBUFF,Y		; MOVE TO START OF NEW LINE
 4487   54B1   30 20       		bmi	FL4		; don't count hi light chars
 4488   54B3   C9 20       		cmp	#SPACE		; don't count control chars
 4489   54B5   90 1C       		bcc	FL4		; okay
 4490   54B7   8A          		txa			; save current x
 4491   54B8   48          		pha			; saved
 4492   54B9   A5 C1       		lda	FONTFLG		; get which font we be using
 4493   54BB   F0 04       		beq	FLSF1		; must be variable width
 4494   54BD   A9 0C       		lda	#MONOFONT_W	; get width then of mono font
 4495   54BF   D0 07       		bne	FLSF2		; okay, now do add
 4496   54C1               	FLSF1:
 4497   54C1   BD 00 02    		lda	LBUFF,X		; get char back
 4498   54C4   AA          		tax			; make index
 4499   54C5   BD 53 64    		lda	CHWID,X		; get width of char
 4500   54C8               	FLSF2:
 4501   54C8   18          		clc			; get ready for add
 4502   54C9   65 A7       		adc	LENGTH+LO	; okay, now add char width
 4503   54CB   85 A7       		sta	LENGTH+LO	; save new length
 4504   54CD   68          		pla			; get old X back
 4505   54CE   AA          		tax			; okay
 4506   54CF   90 02       		bcc	FL4		; no wrap
 4507   54D1   E6 A8       		inc	LENGTH+HI
 4508   54D3               	FL4:
 4509   54D3   C8          		iny			; UPDATE # OF chars in NEW LINE
 4510   54D4   D0 C6       		bne	FL2		; (ALWAYS)
 4511                      	
 4512                      	
 4513                      		; ---------------
 4514                      		; CARRIAGE RETURN
 4515                      		; ---------------
 4516                      	
 4517   54D6               	ZZCRLF:
 4518   54D6   A6 B2       		ldx	TABLEF		; OUTPUT TO TABLE?
 4519   54D8   F0 0F       		beq	ZCRLF		; NO
 4520                      	;
 4521                      	; if putting a <CR> into table, just add to line buffer and flush
 4522                      	;
 4523   54DA   A9 0D       		lda	#EOL		; get carriage return char
 4524   54DC   A4 A9       		ldy	CHRCNT		; add to lbuff
 4525   54DE   99 00 02    		sta	LBUFF,Y		; got it
 4526   54E1   E6 A9       		inc	CHRCNT		; now flush it
 4527   54E3   20 B0 53    		jsr	TBLRTN		; YES, DO IT (TBL ONLY)
 4528   54E6   4C 5F 55    		jmp	ZCRLFX		; git out
 4529   54E9               	ZCRLF:
 4530   54E9   A6 A9       		ldx	CHRCNT		; how far have we gone
 4531   54EB   A9 0D       		lda	#EOL		; get carriage return char
 4532   54ED   9D 00 02    		sta	LBUFF,X		; END OF CURRENT LINE
 4533   54F0   E6 A9       		inc	CHRCNT		; UPDATE LINE LENGTH
 4534   54F2   20 68 55    		jsr	LINOUT		; DISPLAY LINE
  Tue Jun 13 1989 11:42                                                                                                  Page   67

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4535                      	
 4536                      	;
 4537                      	; now check about line count
 4538                      	;
 4539   54F5   A9 00       		lda	#0
 4540   54F7   85 A9       		sta	CHRCNT		; AND RESET LINE COUNT
 4541   54F9   85 A7       		sta	LENGTH+LO	; okay
 4542   54FB   85 A8       		sta	LENGTH+HI	; okay
 4543                      	
 4544   54FD   20 8D 55    		jsr	CHKFNC		; CHECK FOR CR FUNCTION (XZIP)
 4545                      	
 4546   5500   A5 B1       		lda	SCREENF		; CHECK IF DISPLAYING TO SCREEN
 4547   5502   F0 5B       		beq	ZCRLFX		; NO, GO HANDLE IF PRINTING
 4548   5504   AD 05 72    		lda	SCRLFLG		; is it a scrolling window?
 4549   5507   F0 56       		beq	ZCRLFX		; nope, so no more
 4550   5509   E6 AB       		inc	LINCNT		; NEW LINE GOING OUT
 4551                      	
 4552   550B   A6 AB       		ldx	LINCNT		; IS IT TIME TO
 4553   550D   E4 03       		cpx	MAXLINES	; PRINT "MORE" YET?
 4554   550F   90 4E       		bcc	ZCRLFX		; NO, CONTINUE
 4555                      	
 4556   5511   A9 01       		lda	#1		; leave one line from last screen, and input line
 4557   5513   85 AB       		sta	LINCNT		; RESET LINE COUNTER
 4558   5515   A5 04       		lda	LEFTMRG		; SET LEFT MARGIN
 4559   5517   85 00       		sta	SCRCX
 4560   5519   A9 01       		lda	#1		; show cursor changed (maybe)
 4561   551B   8D A5 6C    		sta	CURSFLG		; okay
 4562                      	;
 4563                      	; print [MORE] out myself, to avoid re-entrancy problems
 4564                      	;
 4565   551E   AD A1 6C    	        lda     SCRIPTF         ; make sure we don't script
 4566   5521   48          	        pha
 4567   5522   A2 00       	        ldx     #0              ; start with first char
 4568   5524   8E A1 6C    	        stx     SCRIPTF         ; clear script flag
 4569   5527   86 18       	        stx     SCLLINES        ; use this as a counter
 4570   5529               	MORELOOP:
 4571   5529   BD 92 5B    	        lda     MORE,X          ; get char
 4572   552C   85 AC       	        sta     IOCHAR          ; save it
 4573   552E   20 10 53    	        jsr     DIRECT_OUT      ; pump it out there
 4574   5531   E6 18       	        inc     SCLLINES        ; count char
 4575   5533   A6 18       	        ldx     SCLLINES        ; how many have we done        
 4576   5535   E0 06       	        cpx     #MOREL          ; done?
 4577   5537   D0 F0       	        bne     MORELOOP        ; nope
 4578                      	
 4579   5539   20 BE 55    	        jsr     CLRBUF          ; make sure it shows
 4580   553C               	WAIT:
 4581   553C   20 20 51    		jsr	GETKEY		; wait for key please
 4582   553F   A9 05       		lda	#MOREL-1	; how many backspaces
 4583   5541   85 A7       		sta	LENGTH		; just use this as counter
 4584   5543               	WM11:
 4585   5543   A6 A7       		ldx	LENGTH		; which char?
 4586   5545   BD 92 5B    		lda	MORE,X		; get char
 4587   5548   AA          		tax			; put here for erase
 4588   5549   A9 08       		lda	#BACKSPACE	; erase char
 4589   554B   20 A9 5D    		jsr	CHAR
 4590   554E   C6 A7       		dec	LENGTH		; count it
 4591   5550   10 F1       		bpl	WM11
 4592   5552   68          	        pla                     ; get script flag back
 4593   5553   8D A1 6C    	        sta     SCRIPTF         ; fine
 4594   5556   A5 04       		lda	LEFTMRG		; move back to left margin
 4595   5558   85 00       		sta	SCRCX		; okay
 4596   555A   A9 01       		lda	#1		; show cursor changed (maybe)
 4597   555C   8D A5 6C    		sta	CURSFLG		; okay
 4598   555F               	ZCRLFX:
 4599   555F   A9 00       		lda	#0
 4600   5561   85 A9       		sta	CHRCNT		; AND RESET LINE COUNT
 4601   5563   85 A7       		sta	LENGTH+LO	; okay
 4602   5565   85 A8       		sta	LENGTH+HI
 4603   5567   60          		rts
 4604   5568               	LINOUT:
 4605   5568   A4 A9       		ldy	CHRCNT		; IF BUFFER EMPTY,
 4606   556A   F0 20       		beq	LINEX		; DON'T PRINT ANYTHING
 4607   556C   8C 97 6C    		sty	PRLEN		; SAVE LENGTH HERE FOR "PPRINT"
 4608   556F   A5 B1       		lda	SCREENF		; DISPLAY TO SCREEN?
 4609   5571   D0 07       		bne	LOUT0		; yes, so do it
  Tue Jun 13 1989 11:42                                                                                                  Page   68

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4610   5573   A5 19       		lda	FMTTBL		; formatted table?
 4611   5575   F0 12       		beq	LOUT1		; check scripting
 4612   5577   4C B0 53    		jmp	TBLRTN		; flush to table
 4613   557A               	LOUT0:
 4614   557A   A2 00       		ldx	#0		; SEND CONTENTS OF [LBUFF]
 4615   557C               	LOUT:
 4616   557C   BD 00 02    		lda	LBUFF,X		; TO SCREEN
 4617   557F   20 A9 5D    		jsr	CHAR
 4618   5582   E8          		inx
 4619   5583   88          		dey
 4620   5584   D0 F6       		bne	LOUT
 4621   5586   20 1A 72    		jsr	DISP_LINE	; make sure line gets printed
 4622   5589   20 CF 4C    	LOUT1:	JSR	PPRINT		; PRINT [LBUFF] IF ENABLED
 4623   558C               	LINEX:
 4624   558C   60          		rts			; AND RETURN
 4625                      	;
 4626                      	; CHECK IF THERE IS A PENDING FUNCTION CALL ASSOCIATED WITH <CR>'S
 4627                      	;
 4628   558D               	CHKFNC:
 4629   558D   A0 0B       		ldy	#WINCRC+HI		; get function offset
 4630   558F   B1 05       		lda	(WINDOW),Y		; IF NULL IGNORE
 4631   5591   88          	 	dey				; point to lo part
 4632   5592   11 05       		ora	(WINDOW),Y
 4633   5594   F0 26       		beq	CHKOUT
 4634                      	
 4635   5596   AD D1 6C    	        lda     CRLF_CHECK              ; do we really want to do this?
 4636   5599   F0 21       	        beq     CHKOUT                  ; nope
 4637                      	
 4638   559B   B1 05       		lda	(WINDOW),Y		; DECR COUNTER
 4639   559D   38          		sec
 4640   559E   E9 01       		sbc	#1
 4641   55A0   91 05       		sta	(WINDOW),Y
 4642   55A2   C8          		iny
 4643   55A3   B1 05       		lda	(WINDOW),Y		; work on hi part
 4644   55A5   E9 00       		sbc	#0			; pick up carry
 4645   55A7   91 05       		sta	(WINDOW),Y		; save it
 4646   55A9   88          		dey		
 4647   55AA   11 05       		ora	(WINDOW),Y		; if NULL NOW, CALL FCN
 4648   55AC   D0 0E       		bne	CHKOUT
 4649                      	
 4650   55AE   A0 08       		ldy	#WINCRF+LO		; pointing to routine
 4651   55B0   B1 05       		lda	(WINDOW),Y		; get lo part	
 4652   55B2   85 7A       		sta	J+LO			; and save in J
 4653   55B4   C8          		iny				; point to hi part
 4654   55B5   B1 05       		lda	(WINDOW),Y		; got it
 4655   55B7   85 7B       		sta	J+HI
 4656   55B9   20 3F 5B    		jsr	INTCLL			; DO FUNCTION CALL
 4657   55BC               	CHKOUT:
 4658   55BC   60          		rts
 4659                      	
 4660                      	
 4661                      		; ----------------------
 4662                      		; UPDATE THE STATUS LINE
 4663                      		; ----------------------
 4664                      		; NOT APPLICABLE IN EZIP.
 4665                      	
 4666   55BD   60          	ZUSL:	RTS		
 4667                      	
 4668                      	; ------
 4669                      	; BUFOUT
 4670                      	; ------
 4671                      	; ENTER: ARG1 = BUFFERED (1) OR NONBUFFERED (0) OUTPUT CHOICE
 4672                      	; EXIT: FLAG (BUFFLG) IS SET TO TELL COUT WHICH TO DO
 4673                      	;
 4674                      	; shouldn't need this in YZIP ?!
 4675                      	;
 4676   55BE               	ZBUFOUT:
 4677                      	;
 4678                      	; CLEAR OUTPUT BUFFER BEFORE DOING ANYTHING FANCY
 4679                      	;
 4680   55BE               	CLRBUF:
 4681   55BE   20 68 55    		jsr	LINOUT		; CLEAR BUFFER (DON'T RESET LINE COUNT)
 4682   55C1   A2 00       		ldx	#0
 4683   55C3   86 A9       		stx	CHRCNT
 4684   55C5   60          		rts
  Tue Jun 13 1989 11:42                                                                                                  Page   69

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4685                      	
 4686                      		; ------
 4687                      		; DIROUT
 4688                      		; ------
 4689                      		; ARG1 CONTAINS VALUE OF WHICH DEVICE TO SELECT
 4690                      		; OR DESELECT, ARG2 = THE TABLE ADDR FOR TABLE OUTPUT
 4691                      		; MULTIPLE DEVICE USAGE IS POSSIBLE.
 4692                      	
 4693   55C6   00 00       	SAVEXSIZE: db	0,0		; for formatted table saving
 4694                      	
 4695   55C8               	ZDIRT:
 4696   55C8   20 BE 55    	        jsr     CLRBUF          ; send out anything there now!
 4697                      	
 4698   55CB   A6 63       		ldx	ARG1+LO	
 4699   55CD   30 0A       		bmi	DIRRES		; NEGATIVE VALUE, DESELECTING
 4700   55CF   CA          		dex		
 4701   55D0   F0 11       		beq	DIR1		; 1 = SET OUTPUT TO SCREEN
 4702   55D2   CA          		dex		
 4703   55D3   F0 1E       		beq	DIR2		; 2 = SCRIPTING
 4704   55D5   CA          		dex		
 4705   55D6   F0 3C       		beq	DIR3		; 3 = TABLE
 4706   55D8   60          		rts			; INVALID VALUE
 4707   55D9               	DIRRES:
 4708   55D9   E8          		inx		
 4709   55DA   F0 0F       		beq	DRES1		; -1 = RESET TO SCREEN
 4710   55DC   E8          		inx		
 4711   55DD   F0 29       		beq	DRES2	
 4712   55DF   E8          		inx		
 4713   55E0   F0 3A       		beq	DRES3	
 4714   55E2   60          		rts			; INVALID VALUE, JUST LEAVE
 4715   55E3               	DIR1:
 4716   55E3   20 BE 55    		jsr	CLRBUF
 4717   55E6   A9 01       		lda 	#1		; turn screen on
 4718   55E8   85 B1       		sta	SCREENF	
 4719   55EA   60          		rts		
 4720   55EB               	DRES1:
 4721   55EB   20 BE 55    		jsr	CLRBUF
 4722   55EE   A9 00       		lda	#0
 4723   55F0   85 B1       		sta	SCREENF		; 0, TURN SCREEN OFF
 4724   55F2   60          		rts
 4725   55F3               	DIR2:
 4726   55F3   E8          		inx		
 4727   55F4   8E A1 6C    		stx	SCRIPTF		; SET SCRIPT FLAG ON
 4728   55F7   AD 11 96    		lda	ZBEGIN+ZFLAGS+1	; SET GAME FLAG ALSO
 4729   55FA   09 01       		ora	#%00000001	
 4730   55FC   8D 11 96    		sta	ZBEGIN+ZFLAGS+1	
 4731   55FF   AD 0B 4D    		lda	PSTAT		; CHECK IF PRINTER ALREADY INIT'D
 4732   5602   D0 03       		bne	DIR2A	
 4733   5604   20 21 4D    		jsr	PCHK		; NO, GO DO IT
 4734   5607               	DIR2A:
 4735   5607   60          		rts			; YES, READY TO LEAVE
 4736   5608               	DRES2:
 4737   5608   8E A1 6C    		stx	SCRIPTF		; TURN PRINTER OFF
 4738   560B   AD 11 96    		lda	ZBEGIN+ZFLAGS+1	; AND TURN OFF GAME FLAG TOO
 4739   560E   29 FE       		and	#%11111110	
 4740   5610   8D 11 96    		sta	ZBEGIN+ZFLAGS+1	
 4741   5613   60          		rts		
 4742   5614               	DIR3:
 4743   5614   86 B1       	        stx     SCREENF         ; turn off screen
 4744   5616   E8          		inx		
 4745   5617   86 B2       		stx	TABLEF		; TURN TABLE OUTPUT FLAG ON
 4746   5619   4C 83 56    		jmp	START_TABLE	; and set things up
 4747   561C               	DRES3:
 4748   561C   A5 B2       		lda	TABLEF		; IF OFF ALREADY
 4749   561E   F0 62       		beq	OUT3		; LEAVE AS IS
 4750                      	
 4751   5620   86 B2       		stx	TABLEF		; TURN TBL OUTPUT OFF
 4752   5622   E8          	        inx                     ; turn screen back on
 4753   5623   86 B1       	        stx     SCREENF         ; screen back on
 4754                      	
 4755   5625   A9 03       	        lda     #3              ; add three to make it wrap
 4756   5627   18          	        clc                     ; ready for add
 4757   5628   6D 31 96    	        adc     ZBEGIN+ZTWIDTH+1 ; do it
 4758   562B   8D 31 96    	        sta     ZBEGIN+ZTWIDTH+1
 4759   562E   90 03       	        bcc     DRESCC          ; no wrap into MSB
  Tue Jun 13 1989 11:42                                                                                                  Page   70

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4760   5630   EE 30 96    	        inc     ZBEGIN+ZTWIDTH
 4761   5633               	DRESCC:
 4762   5633   4E 30 96    		lsr	ZBEGIN+ZTWIDTH+0 ; /4 to get # of pixels
 4763   5636   6E 31 96    		ror	ZBEGIN+ZTWIDTH+1
 4764   5639   4E 30 96    		lsr	ZBEGIN+ZTWIDTH+0
 4765   563C   6E 31 96    		ror	ZBEGIN+ZTWIDTH+1
 4766                      	
 4767                      	
 4768   563F   A5 19       		lda	FMTTBL		; did we do a formatted table?
 4769   5641   D0 2A       		bne	DRESFT		; yes, so fix things
 4770                      	;
 4771                      	; not formatted table, so put count into table
 4772                      	;
 4773   5643   A5 A0       		lda	DIRTBL+LO	; and put count into second byte of table
 4774   5645   85 8F       		sta	SPCL		; points to low par
 4775   5647   A5 A1       		lda	DIRTBL+HI	; get page 
 4776   5649   20 A9 8F    		jsr	SETPC		; okay, page and bank
 4777   564C   85 90       		sta	SPCH
 4778   564E   84 91       		sty	SPCBNK
 4779   5650   AD AE 6C    		lda	DIRITM+LO	; (2 LESS THAN [DIRITM])
 4780   5653   38          		sec		
 4781   5654   E9 02       		sbc	#2	
 4782   5656   8D AE 6C    		sta	DIRITM+LO	; save this new count
 4783   5659   B0 03       		bcs	RESET0	
 4784   565B   CE AF 6C    		dec	DIRITM+HI	; wrapped downwards
 4785   565E               	RESET0:
 4786   565E   AD AF 6C    		lda	DIRITM+HI	; get hi part
 4787   5661   20 67 92    		jsr	STASHB		; saved that count
 4788   5664   20 D0 8F    		jsr	NEXTSPC		; and point to lo part
 4789   5667   AD AE 6C    		lda	DIRITM+LO	; and get lo part
 4790   566A   4C 67 92    		jmp	STASHB		; and save it, and done
 4791   566D               	DRESFT:
 4792   566D   A5 A9       		lda	CHRCNT		; anything in buffer?
 4793   566F   F0 03       		beq	DRES31		; nope
 4794   5671   20 B0 53    		jsr	TBLRTN		; then fill out last line
 4795   5674               	DRES31:
 4796   5674   AD C6 55    		lda	SAVEXSIZE+LO	; get old xsize back
 4797   5677   85 A2       		sta	XSIZE+LO	; restored
 4798   5679   AD C7 55    		lda	SAVEXSIZE+HI
 4799   567C   85 A3       		sta	XSIZE+HI
 4800   567E   A9 00       		lda	#0		; reset this flag too
 4801   5680   85 19       		sta	FMTTBL		; cleared
 4802   5682               	OUT3:
 4803   5682   60          		rts		
 4804                      	;
 4805                      	; set things up for doing table output
 4806                      	;
 4807   5683               	START_TABLE:
 4808                      	
 4809   5683   A5 66       		lda	ARG2+HI		; SET UP TBL
 4810   5685   85 A1       		sta	DIRTBL+HI	
 4811   5687   A5 65       		lda	ARG2+LO		; TO STORE CHARS IN
 4812   5689   85 A0       		sta	DIRTBL+LO	
 4813   568B   A9 02       		lda	#2
 4814   568D   8D AE 6C    		sta	DIRITM+LO	; start at second char
 4815   5690   A9 00       		lda	#0		; zero item counter
 4816   5692   8D AF 6C    		sta	DIRITM+HI	
 4817   5695   8D 31 96    		sta	ZBEGIN+ZTWIDTH+1	; clear width count
 4818   5698   8D 30 96    		sta	ZBEGIN+ZTWIDTH+0
 4819                      	;
 4820                      	; check to see if we have formatted table
 4821                      	;
 4822   569B   A5 62       		lda	NARGS		; get # of arguments
 4823   569D   C9 03       		cmp	#3		; if == 3, then we wrap it
 4824   569F   F0 01       		beq	DIR30		; nope
 4825   56A1   60          		rts			; all done other wise
 4826   56A2               	DIR30:
 4827   56A2   86 19       		stx	FMTTBL		; set formatted table flag
 4828   56A4   A5 A2       		lda	XSIZE+LO	; save the current XSIZE
 4829   56A6   8D C6 55    		sta	SAVEXSIZE+LO	; okay, did it
 4830   56A9   A5 A3       		lda	XSIZE+HI	; and MSB
 4831   56AB   8D C7 55    		sta	SAVEXSIZE+HI	; okay
 4832   56AE   A5 67       		lda	ARG3+LO		; this is the actual amount
 4833   56B0   A6 68       		ldx	ARG3+HI		; get interesting arg
 4834   56B2   30 0B       		bmi	DIRFT1		; check for negative width
  Tue Jun 13 1989 11:42                                                                                                  Page   71

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4835   56B4   20 87 57    		jsr	SETWJ		; get the window offset
 4836   56B7   A0 14       		ldy	#WINXSZ		; get its XSIZE
 4837   56B9   B1 7A       		lda	(J),Y		; got it
 4838   56BB   85 A2       		sta	XSIZE+LO	; aren't we nice
 4839   56BD   D0 06       		bne	DIR31		; jump to end
 4840   56BF               	DIRFT1:
 4841   56BF   49 FF       		eor	#$FF		; turn to a positive number
 4842   56C1   85 A2       		sta	XSIZE+LO	; save it
 4843   56C3   E6 A2       		inc	XSIZE+LO	; to make it right
 4844   56C5               	DIR31:
 4845   56C5   A9 00       		lda	#0		; items starts at zero
 4846   56C7   8D AE 6C    		sta	DIRITM+LO	; okay
 4847   56CA   85 A3       		sta	XSIZE+HI	; clear out highness
 4848   56CC   06 A2       		asl	XSIZE+LO	; *2
 4849   56CE   26 A3       		rol	XSIZE+HI	
 4850   56D0   06 A2       		asl	XSIZE+LO	; *4
 4851   56D2   26 A3       		rol	XSIZE+HI
 4852   56D4   60          		rts		
 4853                      	
 4854                      		; ------
 4855                      		; CURSET
 4856                      		; ------
 4857                      		; SET CURSOR AT LINE (ARG1) AS OFFSET FROM TOP OF WINDOW
 4858                      		; AND AT COLUMN (ARG2) in (optional) window ARG3
 4859                      	
 4860   56D5               	ZCURST:
 4861   56D5   20 BE 55    		jsr	CLRBUF		; CLEAR OUT ANY NON DISPLAYED TEXT 1ST
 4862   56D8   A5 63       	        lda     ARG1+LO         ; see if < 0
 4863   56DA   C9 FF       	        cmp     #$FF            ; -1 == turn off cursor
 4864   56DC   D0 04       	        bne     ZCURS00         ; nope
 4865   56DE   A9 01       	        lda     #1              ; show cursor off
 4866   56E0   D0 06       	        bne     ZCURSTXX        ; go do it and return
 4867   56E2               	ZCURS00:
 4868   56E2   C9 FE       	        cmp     #$FE            ; -2 == turn cursor on
 4869   56E4   D0 06       	        bne     ZCURS0          ; nope, just deal with normally
 4870   56E6   A9 00       	        lda     #0              ; show cursor not off
 4871   56E8               	ZCURSTXX:
 4872   56E8   8D D0 6C    	        sta     CURSOR_OFF      ; show current cursor state
 4873   56EB   60          	        rts
 4874   56EC               	ZCURS0:
 4875   56EC   C6 63       		dec	ARG1+LO		; zero base both args
 4876   56EE   C6 65       		dec	ARG2+LO		; thanx
 4877   56F0               		
 4878   56F0   A5 62       		lda	NARGS		; check for id
 4879   56F2   C9 03       		cmp	#3		; if 3 args, then window ID specified
 4880   56F4   F0 04       		beq	ZCURS1		; not 3, so use current window
 4881                      	
 4882   56F6   A5 A6       		lda	CURWIN		; show current window being done
 4883   56F8   85 67       		sta	ARG3+LO		; thanx
 4884   56FA               	ZCURS1:
 4885   56FA   A5 67       		lda	ARG3+LO		; get window ID
 4886   56FC   20 87 57    		jsr	SETWJ		; put address into J
 4887   56FF   A5 63       		lda	ARG1+LO		; GET LINE
 4888   5701   A0 02       		ldy	#WINHGHT	; check against height
 4889   5703   D1 7A       		cmp	(J),Y		; too far?
 4890   5705   90 05       		bcc	ZCURS3		; no, so use it
 4891   5707   B1 7A       		lda	(J),Y		; got max out
 4892   5709   A8          		tay			; but one too far
 4893   570A   88          		dey			; all better now
 4894   570B   98          		tya			; back to A
 4895   570C               	ZCURS3:
 4896   570C   18          		clc			; get ready for add
 4897   570D   A0 00       		ldy	#WINTOP		; do y pos first
 4898   570F   71 7A       		adc	(J),Y		; add in top to get absolute value
 4899   5711   A0 04       		ldy	#WINY		; get y pos offset
 4900   5713   91 7A       		sta	(J),Y		; save here
 4901   5715   A5 65       		lda	ARG2+LO		; GET COLUMN
 4902   5717   A0 03       		ldy	#WINWID		; check against width
 4903   5719   D1 7A       		cmp	(J),Y		; is it to for right (like Reagan?)
 4904   571B   90 05       		bcc	ZCURS4		; nope, must be dukakis
 4905   571D   B1 7A       		lda	(J),Y		; get max
 4906   571F   A8          		tay			; for going down one
 4907   5720   88          		dey			; done it
 4908   5721   98          		tya			; back to A for usefullness
 4909   5722               	ZCURS4:
  Tue Jun 13 1989 11:42                                                                                                  Page   72

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4910   5722   A0 01       		ldy	#WINLEFT	; get left edge to absolute it
 4911   5724   71 7A       		adc	(J),Y		; carry clear from above
 4912   5726   A0 05       		ldy	#WINX		; this is the x pos
 4913   5728   91 7A       		sta	(J),Y		; into the structure
 4914                      	;
 4915                      	; now check for current window again, move cursor anyway
 4916                      	;	
 4917   572A   4C A1 4D    		jmp	GET_CURSOR	; get cursor pos from WINDOW
 4918                      	
 4919                      		; ------
 4920                      		; CURGET
 4921                      		; ------
 4922                      	
 4923   572D               	ZCURGT:
 4924   572D   20 BE 55    		jsr	CLRBUF		; flush the buffer
 4925                      	
 4926   5730   20 8F 4D    		jsr	SAVE_CURSOR	; save the current position
 4927                      	
 4928   5733   C6 62       		dec	NARGS		; see how many arguments
 4929   5735   F0 04       		beq	ZCURG1		; use main window
 4930   5737   A5 65       		lda	ARG2+LO		; get window id
 4931   5739   10 02       		bpl	ZCURG2		; and figger it out
 4932   573B               	ZCURG1:
 4933   573B   A5 A6       		lda	CURWIN		; use current window
 4934   573D               	ZCURG2:
 4935   573D   20 87 57    		jsr	SETWJ		; make J point to right place
 4936                      	
 4937   5740   A5 64       		lda	ARG1+HI		; get table address
 4938   5742   20 A9 8F    		jsr	SETPC		; get real address in memory
 4939   5745   84 91       		sty	SPCBNK		; set bank
 4940   5747   85 90       		sta	SPCH		; and page
 4941   5749   A5 63       		lda	ARG1+LO		; get table offset
 4942   574B   85 8F       		sta	SPCL		; and save it
 4943                      	
 4944   574D   A9 00       		lda	#0		; zero hi part of Y pos
 4945   574F   20 67 92    		jsr	STASHB		; and save it
 4946   5752   20 D0 8F    		jsr	NEXTSPC		; and point to next one
 4947   5755   20 6C 57    		jsr	FETCHCY		; Fetch Y pos
 4948   5758   20 67 92    		jsr	STASHB		; and save it
 4949   575B   20 D0 8F    		jsr	NEXTSPC
 4950                      	;
 4951                      	; now for the X pos
 4952   575E   A9 00       		lda	#0		; zero top byte of x pos
 4953   5760   20 67 92    		jsr	STASHB
 4954   5763   20 D0 8F    		jsr	NEXTSPC
 4955   5766   20 79 57    		jsr	FETCHCX		; and now the X pos, and return
 4956   5769   4C 67 92    		jmp	STASHB		; and stash it away
 4957                      	
 4958                      	;
 4959                      	; FETCHCY - get the relativized Y pos into [A]
 4960                      	;	J points to window structure
 4961   576C               	FETCHCY:	
 4962   576C   A0 04       		ldy	#WINY		; get Y pos of window's cursor
 4963   576E   B1 7A       		lda	(J),Y		; got it
 4964   5770   A0 00       		ldy	#WINTOP		; need to de-absolute it
 4965   5772   38          		sec			; get ready for sub
 4966   5773   F1 7A       		sbc	(J),Y		; get relative pos
 4967   5775   AA          		tax			; for 1 basing it
 4968   5776   E8          		inx			; 1 align it
 4969   5777   8A          		txa			; and put for save
 4970   5778   60          		rts
 4971                      	;
 4972                      	; FETCHCX - get relativized X pos into [A]
 4973                      	;	J points to window structure
 4974   5779               	FETCHCX:
 4975   5779   A0 05       		ldy	#WINX		; get X pos of cursor
 4976   577B   B1 7A       		lda	(J),Y		; got it
 4977   577D   A0 01       		ldy	#WINLEFT	; relativize it
 4978   577F   38          		sec			; get ready for sub
 4979   5780   F1 7A       		sbc	(J),Y		; subtract left edge
 4980   5782   AA          		tax			; for incing
 4981   5783   E8          		inx			; 1 ALIGN IT
 4982   5784   8A          		txa
 4983   5785   60          		rts
 4984                      	
  Tue Jun 13 1989 11:42                                                                                                  Page   73

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 4985                      		; -----
 4986                      		; DIRIN
 4987                      		; -----
 4988                      		; NOT YET IMPLEMENTED, BUT RESERVED
 4989                      	
 4990   5786   60          	ZDIRIN:	RTS		
 4991                      	
 4992                      	;
 4993                      	; SETWJ - set up J to point to window structure for window ID in [A]
 4994                      	;
 4995   5787               	SETWJ:
 4996   5787   A8          		tay			; check for -3 (current window)
 4997   5788   10 02       		bpl	SWJ1		; nope, window ID here
 4998   578A   A5 A6       		lda	CURWIN		; -3 means current window
 4999   578C               	SWJ1:
 5000   578C   0A          		asl	A		; shift to make word index
 5001   578D   A8          		tay			; and now make index
 5002   578E   B9 75 6E    		lda	WINTABLE,Y	; get lo part of window struct address
 5003   5791   85 7A       		sta	J+LO		; and save it
 5004   5793   B9 76 6E    		lda	WINTABLE+1,Y	; here's the hi part
 5005   5796   85 7B       		sta	J+HI		; prove it
 5006   5798   60          		rts
 5007                      	
 5008                      		; -----
 5009                      		; ERASE
 5010                      		; -----
 5011                      	
 5012   5799               	ZERASE:
 5013   5799   A5 63       		lda	ARG1+LO	
 5014   579B   C9 01       		cmp	#1	
 5015   579D   D0 06       		bne	ZEROUT		; not clreol
 5016                      	
 5017   579F   20 BE 55    		jsr	CLRBUF
 5018   57A2   4C 2B 61    		jmp	CLREOL		; CLEAR TO END OF LINE
 5019   57A5               	ZEROUT:
 5020   57A5   85 0C       	        sta     CLSWIDTH        ; this many pixels wide
 5021   57A7   A9 09       	        lda     #FONT_H         ; pixels of font_height
 5022   57A9   85 0D       	        sta     CLSHEIGHT
 5023   57AB   A5 00       	        lda     SCRCX           ; start at current cursor pos
 5024   57AD   85 0A       	        sta     CLSLEFT
 5025   57AF   A5 01       	        lda     SCRCY
 5026   57B1   85 0B       	        sta     CLSTOP
 5027   57B3   4C 2C 5F    	        jmp     CLS             ; and do it
 5028                      	
 5029                      	; -----
 5030                      	; CLEAR the current window
 5031                      	; -----
 5032   57B6   0000        	SAVEXY:	dw	0
 5033                      	
 5034   57B8               	ZCLR:
 5035   57B8   20 BE 55    		jsr	CLRBUF		; flush the current buffer
 5036   57BB   20 8F 4D    		jsr	SAVE_CURSOR	; save the cursor pos
 5037                      	
 5038   57BE   A5 63       		lda	ARG1+LO		; CHECK WHAT TO DO
 5039   57C0   10 26       		bpl	CLRW		; a particular window
 5040   57C2   C9 FD       	 	cmp	#$FD		; -3 means current window	
 5041   57C4   F0 22       		beq	CLRW		; so just handle it regular
 5042   57C6   C9 FE       		cmp	#$FE		; clear with nothing social
 5043   57C8   F0 07       		beq	CLRCLS		; just clear the screen
 5044                      	;
 5045                      	; UNSPLIT SCREEN & CLEAR IT
 5046                      	;
 5047   57CA   A9 00       		lda	#0		; just use SPLIT 0
 5048   57CC   85 63       		sta	ARG1+LO		; as if called normally
 5049   57CE   20 CD 4D    		jsr	ZSPLIT		; do the split
 5050                      	;
 5051                      	; just clear the entire screen
 5052                      	;
 5053   57D1               	CLRCLS:
 5054   57D1   A9 00       		lda	#0		; clear the entire screen
 5055   57D3   85 0A       		sta	CLSLEFT		; from top left
 5056   57D5   85 0B       		sta	CLSTOP
 5057   57D7   A9 8C       		lda	#MAXWIDTH	; to bottom right
 5058   57D9   85 0C       		sta	CLSWIDTH
 5059   57DB   A9 C0       		lda	#MAXHEIGHT
  Tue Jun 13 1989 11:42                                                                                                  Page   74

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5060   57DD   85 0D       		sta	CLSHEIGHT
 5061                      	
 5062   57DF   20 2C 5F    		jsr	CLS		; do the clear screen (no cursor movement)
 5063   57E2   A5 63       		lda 	ARG1+LO		; check for -2
 5064   57E4   30 44       		bmi	ZCLRX 		; it is, don't move cursor
 5065   57E6   10 1B       		bpl	ZCLEARX		; move cursor
 5066   57E8               	CLRW:
 5067   57E8   20 87 57    		jsr	SETWJ		; get me the window pointer
 5068   57EB   A0 00       		ldy	#WINTOP		; step thro to get data
 5069   57ED   B1 7A       		lda	(J),Y		; TOP
 5070   57EF   85 0B       		sta	CLSTOP		; save for clear
 5071   57F1   C8          		iny			; point to left
 5072   57F2   B1 7A       		lda	(J),Y		; get it
 5073   57F4   85 0A       		sta	CLSLEFT		; tell CLS
 5074   57F6   C8          		iny			; now at WINHGHT
 5075   57F7   B1 7A       		lda	(J),Y		; got it
 5076   57F9   85 0D       		sta	CLSHEIGHT	; save for clear
 5077   57FB   C8          		iny			; now at WINWID
 5078   57FC   B1 7A       		lda	(J),Y		; get height
 5079   57FE   85 0C       		sta	CLSWIDTH	; saved
 5080   5800   20 2C 5F    		jsr	CLS		; screen cleared
 5081                      	;
 5082                      	; now move the cursor to 1,1, if not == -2
 5083                      	;
 5084   5803               	ZCLEARX:
 5085   5803   A5 63       		lda	ARG1+LO		; check arg
 5086   5805   20 87 57    		jsr	SETWJ		; make sure J still points to window
 5087   5808   A0 00       		ldy	#WINTOP		; put at top left of window
 5088   580A   B1 7A       		lda	(J),Y		; get top
 5089   580C   A0 04       		ldy	#WINY		; and make it the y pos
 5090   580E   91 7A       		sta	(J),Y		; of the cursor
 5091   5810   A0 01       		ldy	#WINLEFT	; and the left is
 5092   5812   B1 7A       		lda 	(J),Y		; the
 5093   5814   18          		clc			; add in the left margin
 5094   5815   A0 06       		ldy	#WINLM		; here's the left margin
 5095   5817   71 7A       		adc	(J),Y		; added it
 5096   5819   A0 05       		ldy	#WINX		; x pos of the
 5097   581B   91 7A       		sta	(J),Y		; cursor
 5098   581D   A9 00       		lda	#0		; and clear out line count
 5099   581F   A0 13       		ldy	#WINLCNT	; line count
 5100   5821   91 7A       		sta	(J),Y		; okay
 5101   5823   A0 15       		ldy	#WINLLEN	; and length of current line
 5102   5825   91 7A       		sta	(J),Y		; okay
 5103   5827   C8          		iny			; do hi
 5104   5828   91 7A       		sta	(J),Y		; okay
 5105   582A               	ZCLRX:
 5106   582A   4C A1 4D    		jmp	GET_CURSOR	; restore the cursor pos for the current window
 5107                      	
 5108                      	; ------
 5109                      	; PRINTT
 5110                      	; ------
 5111                      	; PRINT A TABLE TO SCREEN, ARG1 = # OF BYTES
 5112                      	; ARG2 = WIDTH, ARG3 (DEF = 1) = HEIGHT
 5113                      	
 5114          0078        	OLDCHZ	EQU	I+LO		; EASIER TO READ
 5115          0079        	OLDEHZ	EQU	I+HI
 5116          007E        	OLDCVT	EQU	L+LO
 5117                      	
 5118   582D   0000        	TBL_LEN DW	0		; save for length
 5119                      	
 5120   582F               	ZPRNTT:
 5121   582F   A5 63       		lda	ARG1+LO		; USE GETBYT AS TBL COULD
 5122   5831   85 86       		sta	MPCL		; BE ANYWHERE
 5123   5833   A5 64       		lda	ARG1+HI
 5124   5835   85 87       		sta	MPCM
 5125   5837   A9 00       		lda	#0
 5126   5839   85 88       		sta	MPCH
 5127   583B   20 B2 90    		jsr	VLDMPC
 5128                      	
 5129   583E   A5 65       		lda	ARG2+LO		; ONLY A BYTE AS MAX
 5130   5840   F0 58       		beq	PTTDUN		; QUIT NOW IF NULL
 5131                      	
 5132   5842   85 BF       		sta	TBLWIDTH	; width of the table
 5133   5844   85 C0       		sta	TBLCNT		; start counter off at width
 5134   5846   C6 62       		dec	NARGS		; count down to 1 (maybe)
  Tue Jun 13 1989 11:42                                                                                                  Page   75

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5135   5848   A5 62       		lda	NARGS
 5136   584A   C9 01       		cmp	#1
 5137   584C   F0 02       		beq	NOHIGHT		; DEFAULT HEIGHT IS 1
 5138   584E   A5 67       		lda	ARG3+LO		; get passed height
 5139   5850               	NOHIGHT:
 5140   5850   85 BE       		sta	TBLHEIGHT	; height of the table (at least 1)
 5141   5852   A5 00       		lda	SCRCX
 5142   5854   85 79       		sta	OLDEHZ
 5143   5856   38          		sec			; subtract left margin to get how long line is
 5144   5857   E5 04       		sbc	LEFTMRG		; okay we did that
 5145   5859   8D 2D 58    		sta	TBL_LEN+LO	; this is how big line is too
 5146   585C   A9 00       		lda	#0		; clear MSB
 5147   585E   0E 2D 58    		asl	TBL_LEN+LO	; *2
 5148   5861   2A          		rol	A
 5149   5862   0E 2D 58    		asl	TBL_LEN+LO	; *4
 5150   5865   2A          		rol	A
 5151   5866   8D 2E 58    		sta	TBL_LEN+HI	; save
 5152   5869               	PTTLP:
 5153   5869   20 3B 92    		jsr	GETBYT		; GET A BYTE
 5154   586C   20 F5 52    		jsr	COUT		; and send it out
 5155                      	
 5156   586F   C6 C0       		dec	TBLCNT		; one more byte done
 5157   5871   D0 F6       		bne	PTTLP
 5158   5873   C6 BE       		dec	TBLHEIGHT	; IF DONE ALL LINES
 5159   5875   F0 23       		beq	PTTDUN		; LEAVE
 5160                      	
 5161   5877   20 BE 55    		jsr	CLRBUF		; so send out stuff that's there
 5162                      	
 5163   587A   A5 79       		lda	OLDEHZ		; get old x pos
 5164   587C   85 00       		sta	SCRCX		; and restore it
 5165   587E   A9 01       		lda	#1		; show cursor changed
 5166   5880   8D A5 6C    		sta	CURSFLG		; okay
 5167   5883   A5 01       		lda	SCRCY		; point to next line
 5168   5885   18          		clc			; by adding in the font height
 5169   5886   69 09       		adc	#FONT_H		; okay, goody
 5170   5888   85 01       		sta	SCRCY		; and here we are
 5171                      	
 5172   588A   AD 2E 58    		lda	TBL_LEN+HI	; reset length
 5173   588D   85 A8       		sta	LENGTH+HI	; hi part
 5174   588F   AD 2D 58    		lda	TBL_LEN+LO	; lo part
 5175   5892   85 A7       		sta	LENGTH+LO	; just a lo
 5176                      	
 5177   5894   A5 BF       		lda	TBLWIDTH	; RESET COUNT
 5178   5896   85 C0       		sta	TBLCNT		; thanx
 5179   5898   D0 CF       		bne	PTTLP		; GO DO NEXT LINE
 5180   589A               	PTTDUN:
 5181   589A   60          		rts
 5182                      	;--------------
 5183                      	; ZPRINTF
 5184                      	;--------------
 5185                      	; ZPRINTF - print a formatted table
 5186                      	;
 5187   589B               	ZPRINTF:
 5188   589B   A5 63       		lda	ARG1+LO		; USE GETBYT AS TBL COULD
 5189   589D   85 86       		sta	MPCL		; BE ANYWHERE
 5190   589F   A5 64       		lda	ARG1+HI
 5191   58A1   85 87       		sta	MPCM
 5192   58A3   A9 00       		lda	#0
 5193   58A5   85 88       		sta	MPCH
 5194   58A7   20 B2 90    		jsr	VLDMPC
 5195                      	
 5196   58AA   A5 00       		lda	SCRCX		; save the X pos
 5197   58AC   85 79       		sta	OLDEHZ		; saved here
 5198   58AE               	ZPFL1:
 5199   58AE   20 3B 92    		jsr	GETBYT		; get the length byte, MSB, & ignore
 5200   58B1   20 3B 92    		jsr	GETBYT		; get the length byte
 5201   58B4   F0 21       		beq	ZPFX		; no more if == 0
 5202   58B6   85 BF       		sta	TBLWIDTH	; keep track of it
 5203   58B8               	ZPFL2:
 5204   58B8   20 3B 92    		jsr	GETBYT		; now get the char byte
 5205   58BB   20 A9 5D    		jsr	CHAR		; and send it yt
 5206   58BE   C6 BF       		dec	TBLWIDTH	; any more?
 5207   58C0   D0 F6       		bne	ZPFL2		; ayyup
 5208                      	
 5209   58C2   20 1A 72    	 	jsr	DISP_LINE	; make sure line goes out
  Tue Jun 13 1989 11:42                                                                                                  Page   76

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5210   58C5   A5 79       		lda	OLDEHZ		; reset a few things
 5211   58C7   85 00       		sta	SCRCX		; including x pos
 5212   58C9   A9 01       		lda	#1		; show cursor changed
 5213   58CB   8D A5 6C    		sta	CURSFLG		; okay
 5214   58CE   A5 01       		lda	SCRCY		; point to next line
 5215   58D0   18          		clc			; by adding in the font height
 5216   58D1   69 09       		adc	#FONT_H		; okay, goody
 5217   58D3   85 01       		sta	SCRCY		; and here we are
 5218   58D5   D0 D7       		bne	ZPFL1		; and do it again
 5219   58D7               	ZPFX:
 5220   58D7   60          		rts
 5221                      	; ------------
 5222                      	; SET NEW FONT
 5223                      	; ------------
 5224                      	
 5225                      	; Font 4 is mono-spaced font.
 5226                      	
 5227   58D8               	ZFONT:
 5228   58D8   20 BE 55    	        jsr     CLRBUF          ; clear the buffer first
 5229                      	
 5230   58DB   C6 62       		dec	NARGS		; did we get passed a window id?
 5231   58DD   D0 04       		bne	ZFNTWID		; yup
 5232   58DF   A9 FD       		lda	#$FD		; -3 means current window
 5233   58E1   85 65       		sta	ARG2+LO		; make it the arg2 then
 5234   58E3               	ZFNTWID:
 5235   58E3   A5 65       		lda	ARG2+LO		; get window we are interested in
 5236   58E5   20 87 57    		jsr	SETWJ		; make [J] point to window struct
 5237                      	
 5238   58E8   A5 63       		lda	ARG1+LO		; check for 
 5239   58EA   C9 01       		cmp	#1		; font 1
 5240   58EC   F0 0E       		beq	ZFNT1		;  or
 5241   58EE   C9 04       		cmp	#4		; font 4 (monospace)
 5242   58F0   D0 2A       		bne	ZFBAD		; nope, so die
 5243                      	;
 5244                      	; font 4 is the monospaced font
 5245                      	;
 5246   58F2   A0 10       		ldy	#WINFSIZE	; point to width
 5247   58F4   A9 03       		lda	#MFONT_W	; get game width
 5248   58F6   91 7A       		sta 	(J),Y		; store the width
 5249   58F8   A9 03       		lda	#3		; set font ID
 5250   58FA   D0 08       		bne	ZFNTEX		; all done
 5251   58FC               	ZFNT1:
 5252   58FC   A0 10       		ldy	#WINFSIZE	; point to width
 5253   58FE   A9 02       		lda	#FONT_W		; get game width
 5254   5900   91 7A       		sta 	(J),Y		; store the width
 5255   5902   A9 00       		lda	#0		; set font ID
 5256   5904               	ZFNTEX:
 5257   5904   A0 0F       		ldy	#WINFONT	; set font
 5258   5906   48          		pha			; save font id
 5259   5907   B1 7A       		lda	(J),Y		; get old font id
 5260   5909   AA          		tax			; save old font id
 5261   590A   68          		pla			; get new one back
 5262   590B   91 7A       		sta	(J),Y		; save in structure
 5263   590D   B1 05       		lda	(WINDOW),Y	; get current window font
 5264   590F   F0 02       		beq	ZFNT0X		; set flag with zero	
 5265   5911   A9 0C       		lda	#MONOFONT_W	; get width of mono spaced font
 5266   5913               	ZFNT0X:
 5267   5913   85 C1       		sta	FONTFLG		; and set flag too
 5268   5915   E8          		inx			; make it say correct font ID for game
 5269   5916   8A          		txa			; put in A for put val
 5270   5917   A2 00       		ldx	#0		; clear X
 5271   5919   4C D1 43    		jmp	PUTVAL		; and return it
 5272   591C               	ZFBAD:
 5273   591C   4C CA 43    		jmp	RET0		; TELL IT DOESN'T WORK
 5274                      	; ------------------------------
 5275                      	; FETCH A LINE OF INPUT FOR READ
 5276                      	; ------------------------------
 5277                      	; ENTRY: Relative READ table address in RDTBL1
 5278                      	; EXIT: # CHARS READ IN [A]
 5279   591F               	SV_SPC:	ds	3		; save SPC here for later usage
 5280   5922   0000        	INP_X:	dw	0		; saved cursor position
 5281                      	
 5282   5924               	INPUT:
 5283   5924   20 BE 55    		jsr	CLRBUF		; FLUSH [LBUFF]
 5284   5927   A0 00       		ldy	#0		; RESET LINE COUNT
  Tue Jun 13 1989 11:42                                                                                                  Page   77

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5285   5929   84 79       		sty	I+HI		; clear local variables
 5286   592B   84 78       		sty	I+LO	
 5287   592D   84 7B       		sty	J+HI	
 5288   592F   84 7A       		sty	J+LO	
 5289   5931   8C 90 5B    		sty	BRKCHR		; init break char
 5290   5934   84 AB       		sty	LINCNT		; RESET LINE COUNT
 5291   5936   8C D2 6C    	        sty     PTR_COUNT       ; we start by looking at pointer        
 5292   5939   AD A5 6C    		lda	CURSFLG		; really move the cursor?
 5293   593C   F0 0F       		beq	IO_CURS		; nope
 5294                      	;
 5295                      	; re-doing the (hopefully) saved read, so put cursor back
 5296                      	;
 5297   593E   AD 23 59    		lda	INP_X+HI	; first, the MSB
 5298   5941   8D 02 72    		sta	CHR_X+HI
 5299   5944   AD 22 59    		lda	INP_X+LO	; now the LSB
 5300   5947   8D 01 72    		sta	CHR_X+LO
 5301   594A   8C A5 6C    	        sty     CURSFLG         ; make sure we don't change cursor
 5302   594D               	IO_CURS:
 5303                      	;
 5304                      	; check for new TCHARS table
 5305                      	;
 5306   594D   AD 2F 96    		lda	ZBEGIN+ZTCHAR+1	; so check lower byte for different tchars
 5307   5950   CD B2 6C    		cmp	SVTCHAR+LO	; is it different?
 5308   5953   D0 08       		bne	IO_DOT		; ayyup, get new one
 5309   5955   AD 2E 96    		lda	ZBEGIN+ZTCHAR	; get current TCHARS hi part
 5310   5958   CD B3 6C    		cmp	SVTCHAR+HI	; is it the same as saved one?
 5311   595B   F0 03       		beq	IOj		; yes, so don't muck with it
 5312   595D               	IO_DOT:
 5313   595D   20 A5 5A    		jsr	DO_TCHARS	; new table, so copy it over
 5314                      	;
 5315                      	; now set up FPC
 5316                      	;
 5317   5960               	IOj:
 5318   5960   AD A9 6C    		lda	RDTBL1+HI	; get page of table
 5319   5963   20 A9 8F    		jsr	SETPC		; and get me the memory page and bank
 5320   5966   85 8D       		sta	FPCH		; save page
 5321   5968   84 8E       		sty	FPCBNK		; and bank
 5322   596A   AD A8 6C    		lda	RDTBL1+LO	; and get offset
 5323   596D   85 8C       		sta	FPCL		; set up FPC/SPC
 5324   596F   20 88 92    		jsr	FETCHB		; get length of line
 5325   5972   A8          		tay			; for dec'ing
 5326   5973   88          		dey			; don't count the offset byte
 5327   5974   88          		dey			; and leave room for terminator
 5328   5975   84 17       		sty	CHRMAX		; and save it
 5329   5977   20 F0 8F    		jsr	NEXTFPC		; point to next byte
 5330   597A   20 88 92    		jsr	FETCHB		; get current offset into buffer
 5331   597D   8D 89 5B    		sta	CHARCNT		; save how many chars out there
 5332   5980   20 F0 8F    		jsr	NEXTFPC 	; point to beginning of data buffer
 5333                      	;
 5334                      	; now finish setting up saved SPC
 5335                      	;
 5336   5983   A2 02       		ldx	#2
 5337   5985               	INSVCL:
 5338   5985   B5 8C       		lda	FPC,X		; get byte to saved for use later on
 5339   5987   9D 1F 59    		sta	SV_SPC,X	; it is saved here
 5340   598A   CA          		dex
 5341   598B   10 F8       		bpl	INSVCL		; next!
 5342                      	;
 5343                      	; now copy current buffer into local buffer
 5344                      	;
 5345   598D   AD 89 5B    		lda	CHARCNT		; make sure we have some
 5346   5990   F0 11       		beq	CPIOLX		; nope, none in there now
 5347   5992   A2 00       		ldx	#0		; start at first char
 5348   5994               	CPIOL:
 5349   5994   20 88 92    		jsr	FETCHB		; get a char
 5350   5997   9D 00 02    		sta	LBUFF,X		; save char
 5351   599A   20 F0 8F    		jsr	NEXTFPC		; point to next one
 5352   599D   E8          		inx			; next char
 5353   599E   EC 89 5B    		cpx	CHARCNT		; got them all yet?
 5354   59A1   D0 F1       		bne	CPIOL		; nope
 5355   59A3               	CPIOLX:
 5356   59A3   20 FD 4E    		jsr	CHKTME		; START  TIME LIMIT
 5357                      	;
 5358                      	; this is the get-a-key-and-whack-on-it loop
 5359                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page   78

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5360   59A6               	INLOOP:
 5361   59A6   A5 79       		lda	I+HI		; is there a time?
 5362   59A8   F0 08       		beq	INPL1		; nope
 5363   59AA   20 B8 4F    		jsr	TIMIN		; do timed input
 5364   59AD   90 06       		bcc	INPL2		; got a char, process it
 5365   59AF   4C 93 5A    		jmp	LEXBAD		; timed out with nothing there!
 5366   59B2               	INPL1:
 5367   59B2   20 20 51    		jsr	GETKEY		; let apple do the walking
 5368   59B5               	INPL2:
 5369   59B5   20 DC 5A    		jsr	ISTCHR		; CHECK IF IT'S AN ACCEPTABLE TERMINATOR KEY
 5370   59B8   B0 0D       		bcs	NOTYET
 5371                      	
 5372   59BA   8D 90 5B    		sta	BRKCHR
 5373   59BD   C9 0D       		cmp	#EOL		; IF EOL PUT TO SCREEN
 5374   59BF   F0 03       		beq	ENDLINx
 5375   59C1   4C 4A 5A    		jmp	ENDIN		; ELSE JUST END
 5376   59C4               	ENDLINx:
 5377   59C4   4C 3A 5A    	        jmp     ENDLIN          ; can't reach with a branch
 5378   59C7               	NOTYET:
 5379   59C7   A0 FF       	        ldy     #$FF            ; restart pointer device counter
 5380   59C9   8C D2 6C    	        sty     PTR_COUNT       ; and start again
 5381   59CC   A8          		tay			; check for functions keys that aren't
 5382   59CD   30 65       		bmi	CBAD		; terminators and feep if it is
 5383   59CF   C9 0D       		cmp	#EOL		; EOL?
 5384   59D1   F0 67       		beq	ENDLIN		; LINE DONE IF SO
 5385   59D3   C5 1B       		cmp	ESCAPE		; don't allow escape char's thru
 5386   59D5   F0 5D       		beq	CBAD		; okay, I won't
 5387                      	
 5388   59D7   C9 08       		cmp	#BACKSPACE	; BACKSPACE?
 5389   59D9   F0 38       		beq	BACKUP		; SPECIAL HANDLING
 5390   59DB   C9 1B       	        cmp     #ESCAPE         ; ESCAPE char?
 5391   59DD   F0 55       	        beq     CBAD            ; don't like it
 5392                      	
 5393   59DF   AC 89 5B    		ldy	CHARCNT		; where do we put char?
 5394   59E2   C4 17       		cpy	CHRMAX		; are we filled up?
 5395   59E4   B0 4E       		bcs	CBAD		; boy, am i full
 5396                      	
 5397   59E6   48          		pha			; save it
 5398   59E7   AA          		tax			; use as index
 5399   59E8   A5 A7       		lda	LENGTH+LO	; GET LINE LENGTH COUNTER
 5400   59EA   18          		clc 			; get ready for add
 5401   59EB   7D 53 64    		adc	CHWID,X		; add width
 5402   59EE   A8          	        tay                     ; save LSB in Y
 5403   59EF   A6 A8       	        ldx     LENGTH+HI       ; get high byte        
 5404   59F1   90 01       		bcc	INP0C		; no wrap
 5405   59F3   E8          		inx             	; okay, wrap then
 5406   59F4               	INP0C:
 5407   59F4   68          		pla			; get char back
 5408   59F5   E4 A3       		cpx	XSIZE+HI	; check MSB first
 5409   59F7   90 04       		bcc	NOIOWRAP	; no need to check lsb
 5410   59F9   C4 A2       		cpy	XSIZE+LO	; end of screen line?
 5411   59FB   B0 37       		bcs     CBAD            ; reached end, so just beep
 5412   59FD               	NOIOWRAP:
 5413   59FD   86 A8       	        stx     LENGTH+HI       ; save MSB
 5414   59FF   84 A7       	        sty     LENGTH+LO       ; and LSB
 5415   5A01   AE 89 5B    		ldx	CHARCNT		; for putting in line buffer
 5416   5A04   9D 00 02    		sta	LBUFF,X		; and save it in case we goto printer
 5417   5A07   20 A9 5D    		jsr	CHAR		; SEND TO SCREEN
 5418   5A0A   20 1A 72    		jsr	DISP_LINE	; show char
 5419   5A0D   EE 89 5B    		inc	CHARCNT		; NEXT POSITION IN LINE
 5420   5A10   4C A6 59    		jmp	INLOOP		; NO, GET ANOTHER CHAR
 5421                      	;
 5422                      	; HANDLE BACKSPACE
 5423                      	;
 5424   5A13               	BACKUP:
 5425   5A13   AE 89 5B    		ldx	CHARCNT		; if == 2 then empty
 5426   5A16   F0 1C       		beq	CBAD		; JMP to beeping
 5427   5A18   CA          		dex			; get rid of char
 5428   5A19   8E 89 5B    		stx	CHARCNT		; saved
 5429   5A1C   BD 00 02    		lda	LBUFF,X		; get char we are interested in
 5430   5A1F   AA          		tax			; put in x
 5431                      	
 5432   5A20   A5 A7       		lda	LENGTH+LO	; GET LINE LENGTH COUNTER
 5433   5A22   38          		sec 			; get ready for sub
 5434   5A23   FD 53 64    		sbc	CHWID,X		; sub width
  Tue Jun 13 1989 11:42                                                                                                  Page   79

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5435   5A26   85 A7       		sta	LENGTH+LO	; update length
 5436   5A28   B0 02       		bcs	BCKP1		; no wrap
 5437   5A2A   C6 A8       		dec	LENGTH+HI	; okay, wrap then
 5438   5A2C               	BCKP1:
 5439   5A2C   A9 08       		lda	#BACKSPACE	; so do erasing backspace
 5440   5A2E   20 A9 5D    		jsr	CHAR
 5441   5A31   4C A6 59    		jmp	INLOOP
 5442   5A34               	CBAD:
 5443   5A34   20 B3 4E    		jsr	BEEP		; ELSE SCREAM WITH PAIN
 5444   5A37   4C A6 59    		jmp	INLOOP		; AND WAIT FOR SOMETHING BETTER
 5445                      	;
 5446                      	; HANDLE END OF LINE KEY
 5447                      	;
 5448   5A3A               	ENDLIN:
 5449   5A3A   8D 90 5B    		sta	BRKCHR
 5450   5A3D   A9 0D       		lda	#EOL		; get EOL char
 5451   5A3F   20 A9 5D    		jsr	CHAR		; SEND EOL TO SCREEN
 5452   5A42   A9 00       		lda	#0		; and show 0 length of line out there
 5453   5A44   85 A7       		sta	LENGTH+LO	; thanx
 5454   5A46   85 A8       		sta	LENGTH+HI	; and msb
 5455   5A48   E6 AB       		inc	LINCNT		; take into account the <CR> at EOL
 5456   5A4A               	ENDIN:
 5457                      	;
 5458                      	; now save lbuff in table for posterity
 5459                      	;
 5460   5A4A   AD 21 59    		lda	SV_SPC+ABANK	; get bank first
 5461   5A4D   85 91       		sta	SPCBNK		; saved
 5462   5A4F   AD 20 59    		lda	SV_SPC+HI
 5463   5A52   85 90       		sta	SPCH
 5464   5A54   AD 1F 59    		lda	SV_SPC+LO
 5465   5A57   85 8F       		sta	SPCL
 5466   5A59   A2 00       		ldx	#0		; start with first char in buffer
 5467   5A5B               	ENDLOOP:
 5468   5A5B   EC 89 5B    		cpx	CHARCNT		; done yet?
 5469   5A5E   F0 16       		beq	INP111
 5470   5A60   BD 00 02    		lda	LBUFF,X		; get char
 5471   5A63   C9 41       		cmp	#'A'		; IF CHAR IS UPPERCASE ALPHA,
 5472   5A65   90 06       		bcc	LEX		; CONVERT TO LOWER CASE
 5473   5A67   C9 5B       		cmp	#'Z'+1	
 5474   5A69   B0 02       		bcs	LEX
 5475   5A6B   69 20       		adc	#$20		; converting away
 5476   5A6D               	LEX:
 5477   5A6D   20 67 92    		jsr	STASHB		; okay, stashing away
 5478   5A70   20 D0 8F    		jsr	NEXTSPC		; and point to next char in table
 5479   5A73   E8          		inx			; point to next char
 5480   5A74   D0 E5       		bne	ENDLOOP		; so get next one
 5481   5A76               	INP111:
 5482   5A76   A9 00       		lda	#00		; to show end of line
 5483   5A78   20 67 92    		jsr	STASHB		; so put it in buffer
 5484                      	;
 5485                      	; now put in new line length
 5486                      	;
 5487   5A7B   AD A9 6C    		lda	RDTBL1+HI	; get page of table
 5488   5A7E   20 A9 8F    		jsr	SETPC		; and get me the memory page and bank
 5489   5A81   85 90       		sta	SPCH		; save page
 5490   5A83   84 91       		sty	SPCBNK		; and bank
 5491   5A85   AD A8 6C    		lda	RDTBL1+LO	; and get offset
 5492   5A88   85 8F       		sta	SPCL
 5493   5A8A   20 D0 8F    		jsr	NEXTSPC		; and point to char count
 5494   5A8D   AD 89 5B    		lda	CHARCNT		; get character count
 5495   5A90   20 67 92    		jsr	STASHB		; and shove it away  
 5496   5A93               	LEXBAD:
 5497   5A93   A0 00       	        ldy     #0              ; clear out
 5498   5A95   8C D2 6C    	        sty     PTR_COUNT       ; pointer flag
 5499                      	;
 5500                      	; now, save CHR_X, in case we redo this read
 5501                      	;
 5502   5A98   AD 02 72    		lda	CHR_X+HI	; first, the MSB
 5503   5A9B   8D 23 59    		sta	INP_X+HI
 5504   5A9E   AD 01 72    		lda	CHR_X+LO	; now the LSB
 5505   5AA1   8D 22 59    		sta	INP_X+LO
 5506   5AA4   60          		rts			; Length is in [A]
 5507                      	;
 5508                      	; Copy over a new TCHARS table
 5509                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page   80

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5510   5AA5               	DO_TCHARS:
 5511                      	;
 5512                      	; now do somethin' with the TCHAR table (maybe, if <> 0)
 5513                      	;
 5514   5AA5   AD 2E 96    		lda	ZBEGIN+ZTCHAR	; DO SAME FOR TCHARS TABLE
 5515   5AA8   8D B3 6C    		sta	SVTCHAR+HI	; save it for checking
 5516   5AAB   20 A9 8F    		jsr	SETPC		; and now make absolute
 5517   5AAE   85 8D       		sta	FPCH		; Save in FPC
 5518   5AB0   84 8E       		sty	FPCBNK
 5519   5AB2   AD 2F 96    		lda	ZBEGIN+ZTCHAR+1	; NO CHANGE FOR LSB
 5520   5AB5   8D B2 6C    		sta	SVTCHAR+LO	; and save for later check
 5521   5AB8   85 8C       		sta	FPCL		; now move pointer to fetch spot
 5522                      	
 5523   5ABA   A9 00       		lda	#0		; and set index
 5524   5ABC   85 78       		sta	I		; thank you
 5525   5ABE   85 B9       		sta	ALLFLG		; turn it off
 5526   5AC0               	TCHLP:
 5527   5AC0   20 88 92    		jsr	FETCHB		; get the byte in [a]
 5528   5AC3   20 F0 8F    		jsr	NEXTFPC		; point to next one
 5529   5AC6   A6 78       		ldx	I		; get offset
 5530   5AC8   E6 78       		inc	I		; and point to next one
 5531   5ACA   9D 00 1D    		sta	TCHARTBL,X	; save in lower memory, thank you
 5532   5ACD   C9 00       		cmp	#0		; are we done yet?
 5533   5ACF   F0 0A       		beq	TCHj		; NULL TERMINATED STRING
 5534   5AD1   C9 FF       		cmp	#$FF		; $ff means all >128 chars are terminators
 5535   5AD3   D0 04       		bne	TCHLNEXT	; nope
 5536   5AD5   A9 01       		lda	#1		; yes,
 5537   5AD7   85 B9       		sta	ALLFLG		; so set flag to say so
 5538   5AD9               	TCHLNEXT:
 5539   5AD9   D0 E5       		bne	TCHLP		; and go get it
 5540   5ADB               	TCHj:
 5541   5ADB   60          		rts
 5542                      	
 5543                      		; ------------------------
 5544                      		; IS IT A TERMINATOR CHAR?
 5545                      		; ------------------------
 5546                      	
 5547   5ADC               	ISTCHR:
 5548   5ADC   AE 00 1D    		ldx	TCHARTBL	; check for chars in TCHAR table
 5549   5ADF   F0 18       		beq	ISNOT		; nope
 5550                      	
 5551   5AE1   A6 B9       		ldx	ALLFLG		; ARE ALL FCN KEYS (<127) TERMINATORS
 5552   5AE3   F0 05       		beq	ISCHK		; 0 = NO, GO CHECK LIST
 5553   5AE5   AA          	        tax                     ; check for minus
 5554   5AE6   30 13       		bmi	ISFND		; YUP
 5555   5AE8   10 0F       		bpl	ISNOT
 5556   5AEA               	ISCHK:
 5557   5AEA   A0 00       		ldy	#0
 5558   5AEC               	ISLP:
 5559   5AEC   D9 00 1D    	        cmp	TCHARTBL,Y	; IS CHAR WE HAVE A TCHAR?
 5560   5AEF   F0 0A       		beq	ISFND		; YES
 5561   5AF1   BE 00 1D    		ldx	TCHARTBL,Y	; NULL = END OF STRING
 5562   5AF4   F0 03       		beq	ISNOT
 5563   5AF6   C8          		iny
 5564   5AF7   D0 F3       		bne	ISLP		; SHOULD ALWAYS LOOP
 5565   5AF9               	ISNOT:
 5566   5AF9   38          		sec
 5567   5AFA   60          		rts			; NOT FOUND
 5568   5AFB               	ISFND:	
 5569   5AFB   18          		clc
 5570   5AFC   60          		rts
 5571                      	
 5572                      		; -----
 5573                      		; INPUT 1 char, no printing
 5574                      		; -----
 5575                      	
 5576   5AFD               	ZINPUT:
 5577   5AFD   20 BE 55    		JSR	CLRBUF
 5578                      	
 5579   5B00   A0 00       		ldy	#0	
 5580   5B02   84 AB       		sty	LINCNT	
 5581   5B04   84 A9       		sty	CHRCNT	
 5582   5B06   84 79       		sty	I+HI		; init locals too
 5583   5B08   84 78       		sty	I+LO
 5584   5B0A   84 7B       		sty	J+HI
  Tue Jun 13 1989 11:42                                                                                                  Page   81

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5585   5B0C   84 7A       		sty	J+LO
 5586   5B0E   8C D2 6C    	        sty     PTR_COUNT       ; always check the pointer
 5587   5B11               	 
 5588   5B11   C6 62       		DEC	NARGS	
 5589   5B13   F0 18       		BEQ	ZINP3		; NO TIME LIMIT
 5590   5B15   A5 65       		LDA	ARG2+LO		; GET DELAY WANTED
 5591   5B17   85 79       		STA	I+HI	
 5592   5B19   C6 62       		DEC	NARGS	
 5593   5B1B   F0 08       		BEQ	ZINP4		; NO FCN
 5594   5B1D   A5 67       		LDA	ARG3+LO	
 5595   5B1F   85 7A       		STA	J+LO	
 5596   5B21   A5 68       		LDA	ARG3+HI	
 5597   5B23   85 7B       		STA	J+HI	
 5598   5B25               	ZINP4:
 5599   5B25   20 B8 4F    		JSR	TIMIN		; CALL timed input rotine
 5600   5B28   90 10       		BCC	ZINPRK		; send char on home
 5601   5B2A   4C CA 43    		JMP	RET0		; time out without character
 5602   5B2D               	ZINP3:
 5603   5B2D   20 20 51    		jsr	GETKEY		; ok, find which char was pressed
 5604   5B30   C9 1B       	        cmp     #ESCAPE         ; don't use escape char
 5605   5B32   D0 06       	        bne     ZINPRK          ; fine
 5606   5B34   20 B3 4E    	        jsr     BEEP            ; complain
 5607   5B37   4C 2D 5B    	        jmp     ZINP3           ; do again
 5608   5B3A               	ZINPRK:
 5609   5B3A   A2 00       		LDX	#0
 5610   5B3C   4C CD 43    		JMP	PUTBYT		; RETURN CHAR
 5611                      	
 5612                      	
 5613   5B3F               	INTCLL:
 5614   5B3F   A5 79       		LDA	I+HI		; SAVE VALUES FOR CALLING RTN
 5615   5B41   48          		PHA		
 5616   5B42   A5 78       		LDA	I+LO
 5617   5B44   48          		PHA
 5618   5B45   A5 7B       		LDA	J+HI	
 5619   5B47   85 64       		STA	ARG1+HI		; pretend it's arg1
 5620   5B49   48          		PHA		
 5621   5B4A   A5 7A       		LDA	J+LO	
 5622   5B4C   85 63       		STA	ARG1+LO		; and this is the other half
 5623   5B4E   48          		PHA		
 5624                      	
 5625   5B4F   A2 01       		LDX	#1
 5626   5B51   86 62       		STX	NARGS		; 0 args for internal call
 5627   5B53   CA          		DEX
 5628   5B54   8E 8B 5B    		STX	IRET		; make sure it returns here!
 5629   5B57               		
 5630   5B57   A5 80       		LDA	ZPCL		; a fake one to say we
 5631   5B59   48          		PHA			; are an internal call
 5632   5B5A   A5 81       		LDA	ZPCM		; so save real one
 5633   5B5C   48          		PHA
 5634   5B5D   A5 82       		LDA	ZPCH	
 5635   5B5F   48          		PHA
 5636                      	
 5637   5B60   A9 00       		LDA	#0		; return addr of zero is 
 5638   5B62   85 82       		STA	ZPCH		; internal call!
 5639   5B64   85 81       		STA	ZPCM
 5640   5B66   85 80       		STA	ZPCL
 5641                      	
 5642   5B68   20 F6 7F    		JSR	DOCALL
 5643                      	
 5644   5B6B   4C B6 40    		JMP	MLOOP		; GO DO FCN
 5645                      	;
 5646                      	; RETURN FROM FCN WILL COME HERE
 5647                      	;
 5648   5B6E               	ZIRET:
 5649   5B6E   68          	 	PLA			; GET RID OF RTS FROM ZRET
 5650   5B6F   68          		PLA		
 5651                      	
 5652   5B70   68          		PLA			; get old zpc back
 5653   5B71   85 82       		STA	ZPCH
 5654   5B73   68          		PLA
 5655   5B74   85 81       		STA	ZPCM
 5656   5B76   68          		PLA
 5657   5B77   85 80       		STA	ZPCL
 5658   5B79   20 DC 90    		JSR	VLDZPC		; and validate it
 5659                      	
  Tue Jun 13 1989 11:42                                                                                                  Page   82

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- GAME I/O: APPLE II ---"

 5660   5B7C   68          		PLA			; RESTORE FOR CALLING RTN
 5661   5B7D   85 7A       		STA	J+LO	
 5662   5B7F   68          		PLA		
 5663   5B80   85 7B       		STA	J+HI	
 5664   5B82   68          		PLA
 5665   5B83   85 78       		STA	I+LO
 5666   5B85   68          		PLA		
 5667   5B86   85 79       		STA	I+HI	
 5668   5B88   60          		RTS			; GO BACK TO CALLER
 5669                      	
 5670                      	; INPUT: routine locals!
 5671   5B89   00          	CHARCNT:	DB	0	; where into buffer goes char
 5672   5B8A   00          	SVCHAR:		DB	0	; where to save the char before printing
 5673                      	
 5674   5B8B   00          	IRET:	DB	0		; FLAG TELLS IF RETURNLESS CALL
 5675                      	
 5676   5B8C   00 00       	MTEMP:	DB	00,00		; temp spot for math routines
 5677   5B8E   00          	TYPE:	DB	0		; PARTIAL OR NORMAL (WHOLE) SAVE/RESTORE
 5678   5B8F   00          	ASSVLU:	DB	0		; how many args to this subroutine
 5679   5B90   00          	BRKCHR:	DB	0		; READ BREAK CHAR
 5680   5B91   00          	RDFLAG:	DB	0		; 0 - only read 1 - do lex on it
 5681   5B92   5B 4D 4F 52 45 	MORE:	DB	"[MORE]"	
        5B97   5D 
 5682          0006        	MOREL	EQU	$-MORE
 5683   5B98               		END
 5684                      	
 5685   5B98               		INCLUDE		VERIFY.ASM
 5686   5B98               		STTL "--- VERIFY CODE ---"
 5687                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page   83

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5688                      	
 5689                      		; ------
 5690                      		; VERIFY
 5691                      		; ------
 5692                      		; VERIFY GAME CODE ON DISK
 5693   5B98   0D 54 68 65 20 	VERBAD:	DB	EOL,"The data segment of file is BAD!",EOL
        5B9D   64 61 74 61 20 
        5BA2   73 65 67 6D 65 
        5BA7   6E 74 20 6F 66 
        5BAC   20 66 69 6C 65 
        5BB1   20 69 73 20 42 
        5BB6   41 44 21 0D 
 5694          0022        	VERBADL	EQU	$-VERBAD
 5695   5BBA   0D 54 68 65 20 	VERPBAD: DB	EOL,"The picture data of file is BAD!",EOL
        5BBF   70 69 63 74 75 
        5BC4   72 65 20 64 61 
        5BC9   74 61 20 6F 66 
        5BCE   20 66 69 6C 65 
        5BD3   20 69 73 20 42 
        5BD8   41 44 21 0D 
 5696          0022        	VERPBADL EQU	$-VERPBAD
 5697   5BDC   00          	ZVFLAG:	db	0		; set to indicate ugliness
 5698          0078        	STARTPOS EQU	I+LO		; this is where to start block
 5699   5BDD               	ZVER:
 5700   5BDD   20 C1 8C    		jsr	CLOSE_GAME	; make sure the game files are closed
 5701   5BE0   AC 79 46    		ldy	GAME2NML	; get length of name
 5702   5BE3   B9 79 46    		lda	GAME2NM,Y	; get last char
 5703   5BE6   49 30       		eor	#$30		; make normal number
 5704   5BE8   A8          		tay			; -1 to make ready for FETCH_FILE
 5705   5BE9   88          		dey			; F_F incs first
 5706   5BEA   98          		tya			; to push onto stack
 5707   5BEB   48          		pha			; and save for restoring later
 5708   5BEC   A9 00       		lda	#0		; clear a few counters
 5709   5BEE   8D DC 5B    		sta 	ZVFLAG		; ==0 - verify worked; !=0 - verify broke
 5710   5BF1   AD 01 19    		lda	SEGTBL+SGTDISKS+1	; get how many disks are here
 5711   5BF4   8D 47 49    		sta 	DISKCNTR	; this shows which disk we are working on
 5712   5BF7   CE 47 49    		dec	DISKCNTR	; start down by one
 5713   5BFA               	VERIFY_LOOP:
 5714   5BFA   20 32 5C    		jsr	VERIFY_DATA	; check data in this file
 5715   5BFD   20 BD 5C    		jsr	VERIFY_PICD	; check (possible) picture data in this file
 5716   5C00   AD BF 45    		lda	GMREF		; get reference number
 5717   5C03   8D 35 8B    		sta	CLOSE_PB+CL_REFNUM ; and show CLOSE
 5718   5C06               		CLOSE	CLOSE_PB	; and shut it up
 5719   5C06               		PRODOS	$CC, CLOSE_PB
 5720   5C06   20 00 BF    		jsr	$BF00	; ProDOS handler
 5721   5C09   CC          		DB	$CC	; ProDOS function code
 5722   5C0A   348B        		DW	CLOSE_PB	; Function Parameter Block address
 5723   5C0C               		.MACEND
 5724   5C0C               		.MACEND
 5725   5C0C   CE 47 49    		dec	DISKCNTR	; next please
 5726   5C0F   10 E9       		bpl	VERIFY_LOOP	; and check the next file
 5727   5C11               	ZVERX:
 5728   5C11   A9 02       		lda	#>PAGELEN	; reset read buffer length
 5729   5C13   8D C3 45    		sta	READ_PB+RD_BUFFLEN+HI	; to be $100
 5730   5C16   A9 00       		lda	#<PAGELEN	; this is for LSB
 5731   5C18   8D C2 45    		sta	READ_PB+RD_BUFFLEN+LO	; to be $100
 5732   5C1B   20 C1 8C    		jsr	CLOSE_GAME	; close up the 2 files, thank you
 5733   5C1E   A9 01       		lda	#1		; open game file #1 (*.D2)
 5734   5C20   20 B6 49    		jsr	FETCH_FILE	; this opens it up
 5735   5C23   68          		pla			; get file number back (*.D3/4/5)
 5736   5C24   20 B6 49    		jsr	FETCH_FILE	; and open it back up
 5737   5C27   AD DC 5B    		lda	ZVFLAG		; see if we were successful
 5738   5C2A   F0 03       		beq	ZVERGOOD	; it worked fine
 5739   5C2C   4C 1F 44    		jmp	PREDF		; no it didn't
 5740   5C2F               	ZVERGOOD:
 5741   5C2F   4C 2B 44    		jmp	PREDS		; all done
 5742                      	;
 5743                      	; VERIFY_DATA - check the data part of the picture.  This routine sets
 5744                      	; up DSEGS and open the file.  It will move to the data section if this
 5745                      	; is the preload file, set up J to be the number of 256 byte blocks, and
 5746                      	; print out the verdict.  The disk we are working on (0-3) is in DISKCNTR.
 5747                      	;
 5748   5C32               	VERIFY_DATA:
 5749   5C32   AD 47 49    		lda	DISKCNTR	; get disk we are interested in
 5750   5C35   0A          		asl	A		; make word pointer
  Tue Jun 13 1989 11:42                                                                                                  Page   84

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5751   5C36   AA          		tax			; create index
 5752   5C37   BD D1 1D    		lda	DSKSEG+HI,X	; get MSB of seg table address
 5753   5C3A   85 1F       		sta	DSEGS+HI	; save in pointer
 5754   5C3C   BD D0 1D    		lda	DSKSEG+LO,X	; get LSB of seg table address
 5755   5C3F   85 1E       		sta	DSEGS+LO	; now pointer is all set
 5756   5C41   AD 47 49    		lda	DISKCNTR	; get disk again
 5757   5C44   20 B6 49    		jsr	FETCH_FILE	; so we can open up correct file
 5758   5C47   A9 00       		lda	#0		; make sure we start at beginning
 5759   5C49   8D CE 45    		sta	PSEEK+SM_FPOS
 5760   5C4C   8D CF 45    		sta	PSEEK+SM_FPOS+1
 5761   5C4F   8D D0 45    		sta	PSEEK+SM_FPOS+2
 5762   5C52   85 78       		sta	STARTPOS	; start at first byte, prob'ly
 5763   5C54               		SET_MARK PSEEK		; and move to beginning of file
 5764   5C54               		PRODOS	$CE, PSEEK
 5765   5C54   20 00 BF    		jsr	$BF00	; ProDOS handler
 5766   5C57   CE          		DB	$CE	; ProDOS function code
 5767   5C58   CC45        		DW	PSEEK	; Function Parameter Block address
 5768   5C5A               		.MACEND
 5769   5C5A               		.MACEND
 5770   5C5A   AD 47 49    		lda	DISKCNTR	; now check if this is preload
 5771   5C5D   D0 03       		bne	VERD1		; if <> 0, then it isn't
 5772   5C5F   20 78 5D    		jsr	SETUP_DISK0	; move around to point to start of data
 5773   5C62               	VERD1:
 5774   5C62   A0 02       		ldy	#SGTPICOF	; find where picture data starts
 5775   5C64   B1 1E       		lda	(DSEGS),Y	; MSB
 5776   5C66   85 7B       		sta	J+HI		; J is the page counter
 5777   5C68   C8          		iny			; point to LSB
 5778   5C69   11 1E       		ora	(DSEGS),Y	; any picture file?
 5779   5C6B   D0 08       		bne	VERD01		; yes, so mark end of data
 5780   5C6D   A9 FF       		lda	#$FF		; set J to be a real big number
 5781   5C6F   85 7A       		sta	J+LO		; okay
 5782   5C71   85 7B       		sta	J+HI		; and this one
 5783   5C73   D0 15       		bne	VERD11		; all done
 5784   5C75               	VERD01:
 5785   5C75   B1 1E       		lda	(DSEGS),Y	; and here it is
 5786   5C77   0A          		asl	A		; *2 to make 512 pages be 256 pages
 5787   5C78   85 7A       		sta	J+LO		; this is where it ends up
 5788   5C7A   26 7B       		rol	J+HI		; move in carry to MSB
 5789   5C7C   A5 7A       		lda	J+LO		; now, subtract any skipping
 5790   5C7E   38          		sec			; doing sub
 5791   5C7F   ED CF 45    		sbc	PSEEK+SM_FPOS+1	; take away any skipped amount
 5792   5C82   85 7A       		sta	J+LO		; and save it
 5793   5C84   A5 7B       		lda	J+HI		; pick up carry
 5794   5C86   E9 00       		sbc	#0		; we will
 5795   5C88   85 7B       		sta	J+HI		; we did
 5796   5C8A               	VERD11:
 5797   5C8A   20 0D 5D    		jsr	VERIFY_FILE	; now, actually do the work
 5798   5C8D   90 2D       		bcc	VERDX		; worked just fine
 5799   5C8F               		DLINE	VERBAD		; puke, gag, argh
 5800   5C8F   A2 98       		ldx	#<VERBAD	; get part of VERBAD
 5801   5C91   A9 5B       		lda	#>VERBAD	; get other part of string
 5802          [01]        		IFMA	2		; check to see if length passed in
 5803                      		ldy			; then just fetch it
 5804          [01]        		ELSE
 5805   5C93   A0 22       		ldy	#VERBADL	; get length of string
 5806          [00]        		ENDIF
 5807   5C95   20 5B 4C    		jsr	DLINE		; print the string
 5808   5C98               		.MACEND
 5809                      	;
 5810                      	; This prints out which file is garfed
 5811                      	;
 5812   5C98               	VER_FMSG:
 5813   5C98   AD 47 49    		lda	DISKCNTR	; which file did we do?
 5814   5C9B   C9 02       		cmp	#2		; 0,1 are in one place
 5815   5C9D   B0 0D       		bcs	VERDB1		; nope it isn't it
 5816   5C9F               		DLINE	GAME1NAME,GAME1NML
 5817   5C9F   A2 68       		ldx	#<GAME1NAME	; get part of GAME1NAME
 5818   5CA1   A9 46       		lda	#>GAME1NAME	; get other part of string
 5819          [01]        		IFMA	2		; check to see if length passed in
 5820   5CA3   AC 67 46    		ldy	GAME1NML		; then just fetch it
 5821          [01]        		ELSE
 5822                      		ldy	#GAME1NAMEL	; get length of string
 5823          [00]        		ENDIF
 5824   5CA6   20 5B 4C    		jsr	DLINE		; print the string
 5825   5CA9               		.MACEND
  Tue Jun 13 1989 11:42                                                                                                  Page   85

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5826   5CA9   4C B6 5C    		jmp 	VERDB2		
 5827   5CAC               	VERDB1:
 5828   5CAC               		DLINE	GAME2NAME,GAME2NML ; 2,3 are in another
 5829   5CAC   A2 7A       		ldx	#<GAME2NAME	; get part of GAME2NAME
 5830   5CAE   A9 46       		lda	#>GAME2NAME	; get other part of string
 5831          [01]        		IFMA	2		; check to see if length passed in
 5832   5CB0   AC 79 46    		ldy	GAME2NML		; then just fetch it
 5833          [01]        		ELSE
 5834                      		ldy	#GAME2NAMEL	; get length of string
 5835          [00]        		ENDIF
 5836   5CB3   20 5B 4C    		jsr	DLINE		; print the string
 5837   5CB6               		.MACEND
 5838   5CB6               	VERDB2:
 5839   5CB6   EE DC 5B    		inc	ZVFLAG		; show bad file
 5840   5CB9   20 0D 8D    		jsr	GETRET		; just wait for <CR>
 5841   5CBC               	VERDX:
 5842   5CBC   60          		rts			; all done
 5843                      	;
 5844                      	; VERIFY_PICD - verify the picture data in a file.  First check to see if
 5845                      	; there is any.  If so, seek to it, set J==0 to show VERIFY_FILE to read
 5846                      	; til EOF, and print out bad picture data message if necessary.
 5847                      	;
 5848   5CBD               	VERIFY_PICD:
 5849   5CBD   A9 FF       		lda	#$FF		; gonna zero bunch of stuff
 5850   5CBF   85 7B       		sta	J+HI		; and the counter
 5851   5CC1   85 7A       		sta	J+LO		; which means now goto EOF
 5852   5CC3   A0 02       		ldy	#SGTPICOF	; fetch the picture data offset
 5853   5CC5   B1 1E       		lda	(DSEGS),Y	; get MSB
 5854   5CC7   8D D0 45    		sta	PSEEK+SM_FPOS+2	; we are doing pages
 5855   5CCA   C8          		iny			; pointing to LSB
 5856   5CCB   11 1E       		ora	(DSEGS),Y	; first, check for all zeros
 5857   5CCD   D0 01       		bne	VERP1		; nope, some picture data is there
 5858   5CCF   60          		rts			; just gwon back if nothing here
 5859   5CD0               	VERP1:
 5860   5CD0   B1 1E       		lda	(DSEGS),Y	; go get LSB
 5861   5CD2   0A          		asl	A		; *2 to get 256 byte pages
 5862   5CD3   8D CF 45    		sta	PSEEK+SM_FPOS+1	; put away here
 5863   5CD6   2E D0 45    		rol	PSEEK+SM_FPOS+2	; pick up carry
 5864   5CD9   A9 10       		lda	#PHSIZE		; skip over header of file
 5865   5CDB   85 78       		sta	STARTPOS	; show offset in first block
 5866   5CDD               	VERP11:
 5867   5CDD               		SET_MARK PSEEK		; and move to picture data spot
 5868   5CDD               		PRODOS	$CE, PSEEK
 5869   5CDD   20 00 BF    		jsr	$BF00	; ProDOS handler
 5870   5CE0   CE          		DB	$CE	; ProDOS function code
 5871   5CE1   CC45        		DW	PSEEK	; Function Parameter Block address
 5872   5CE3               		.MACEND
 5873   5CE3               		.MACEND
 5874   5CE3   20 0D 5D    		jsr	VERIFY_FILE	; read in the data
 5875   5CE6               		SET_MARK PSEEK		; get back to beginning of pic data
 5876   5CE6               		PRODOS	$CE, PSEEK
 5877   5CE6   20 00 BF    		jsr	$BF00	; ProDOS handler
 5878   5CE9   CE          		DB	$CE	; ProDOS function code
 5879   5CEA   CC45        		DW	PSEEK	; Function Parameter Block address
 5880   5CEC               		.MACEND
 5881   5CEC               		.MACEND
 5882   5CEC               		READ	READ_PB		; read in a block worth
 5883   5CEC               		PRODOS	$CA, READ_PB
 5884   5CEC   20 00 BF    		jsr	$BF00	; ProDOS handler
 5885   5CEF   CA          		DB	$CA	; ProDOS function code
 5886   5CF0   BE45        		DW	READ_PB	; Function Parameter Block address
 5887   5CF2               		.MACEND
 5888   5CF2               		.MACEND
 5889   5CF2   AD 0A 08    		lda	IOBUFF+PHCHKS	; get MSB of picture checksum
 5890   5CF5   C5 7F       		cmp	L+HI		; same as what we got?
 5891   5CF7   D0 07       		bne 	VERPB		; nope
 5892   5CF9   AD 0B 08    		lda 	IOBUFF+PHCHKS+1	; get LSB of picture checksum
 5893   5CFC   C5 7E       		cmp	L+LO		; same as mine?
 5894   5CFE   F0 0C       		beq	VERPX		; yup, checked out fine
 5895   5D00               	VERPB:
 5896   5D00               		DLINE	VERPBAD		; picture data bad
 5897   5D00   A2 BA       		ldx	#<VERPBAD	; get part of VERPBAD
 5898   5D02   A9 5B       		lda	#>VERPBAD	; get other part of string
 5899          [01]        		IFMA	2		; check to see if length passed in
 5900                      		ldy			; then just fetch it
  Tue Jun 13 1989 11:42                                                                                                  Page   86

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5901          [01]        		ELSE
 5902   5D04   A0 22       		ldy	#VERPBADL	; get length of string
 5903          [00]        		ENDIF
 5904   5D06   20 5B 4C    		jsr	DLINE		; print the string
 5905   5D09               		.MACEND
 5906   5D09   4C 98 5C    		jmp	VER_FMSG	; print out file name
 5907   5D0C               	VERPX:
 5908   5D0C   60          		rts			; tootis finis
 5909                      	;
 5910                      	; VERIFY_FILE - Files is already open and pointing to start of checksummed
 5911                      	; data.  Works along til J == 0 or EOF, which ever comes first.  Starts by
 5912                      	; dec'ing J, so if J starts as 0, effectively means goto EOF.
 5913                      	;
 5914   5D0D               	VERIFY_FILE:
 5915   5D0D   A9 00       		lda	#0		; clear out checksum counter
 5916   5D0F   85 7F       		sta	L+HI		; MSB
 5917   5D11   85 7E       		sta	L+LO		; LSB
 5918   5D13   8D C2 45    		sta	READ_PB+RD_BUFFLEN+LO
 5919   5D16   A9 04       		lda	#4		; make read read $400 (1Kb)
 5920   5D18   8D C3 45    		sta	READ_PB+RD_BUFFLEN+HI
 5921   5D1B               	VFLOOP:	
 5922   5D1B   A9 03       	        lda     #RETRY_COUNT    ; and set up retry count
 5923   5D1D   85 16       	        sta     RETRIES
 5924   5D1F   A9 00       		lda	#<IOBUFF	; reset K to point to beginning of
 5925   5D21   85 7C       		sta	K+LO		; IOBUFF we are
 5926   5D23   A9 08       		lda	#>IOBUFF	; reading all the data
 5927   5D25   85 7D       		sta	K+HI		; into, using as pointer
 5928   5D27               	VFLRD:
 5929   5D27               		READ	READ_PB		; read in 1Kb of data
 5930   5D27               		PRODOS	$CA, READ_PB
 5931   5D27   20 00 BF    		jsr	$BF00	; ProDOS handler
 5932   5D2A   CA          		DB	$CA	; ProDOS function code
 5933   5D2B   BE45        		DW	READ_PB	; Function Parameter Block address
 5934   5D2D               		.MACEND
 5935   5D2D               		.MACEND
 5936   5D2D   90 0D       		bcc	VERF0		; just fine read
 5937   5D2F   C9 4C       		cmp	#$4C		; EOF error?
 5938   5D31   F0 32       		beq	VFCHECK		; yes, so wee bee done
 5939   5D33   C9 4D       	        cmp     #$4D            ; InfoDOS EOF error?
 5940   5D35   F0 2E       	        beq     VFCHECK         ; ayyup
 5941   5D37   20 F7 46    	        jsr     RETRY           ; check about retrying
 5942   5D3A   90 EB       	        bcc     VFLRD           ; and do again
 5943   5D3C               	VERF0:
 5944   5D3C   A5 7A       	        lda     J+LO            ; count the block to be read
 5945   5D3E   D0 06       	        bne     VERF1           ; no wrapping
 5946   5D40   A5 7B       	        lda     J+HI            ; anything left?
 5947   5D42   F0 21       	        beq     VFCHECK         ; nope, all done then
 5948   5D44   C6 7B       	        dec     J+HI            ; count one block
 5949   5D46               	VERF1:
 5950   5D46   C6 7A       		dec	J+LO		; count block
 5951   5D48   A4 78       		ldy	STARTPOS	; and begin
 5952   5D4A               	VERF2:
 5953   5D4A   B1 7C       		lda	(K),Y		; get byte
 5954   5D4C   18          		clc			; doing add
 5955   5D4D   65 7E       		adc	L+LO		; add it in
 5956   5D4F   85 7E       		sta	L+LO		; save it
 5957   5D51   90 02       		bcc	VERF3		; no wrap
 5958   5D53   E6 7F       		inc	L+HI		; yes ther is
 5959   5D55               	VERF3:
 5960   5D55   C8          		iny			; next byte
 5961   5D56   D0 F2       		bne	VERF2		; back to start of inner tloop
 5962                      	
 5963   5D58   A9 00       		lda	#0		; start at first byte
 5964   5D5A   85 78       		sta	STARTPOS	; okay
 5965   5D5C   E6 7D       		inc	K+HI		; point to next block
 5966   5D5E   CE C5 45    		dec	READ_PB+RD_LENGTH+HI	; count this one
 5967   5D61   F0 B8       		beq	VFLOOP		; go read some more
 5968   5D63   D0 D7       		bne	VERF0		; go do next 256 byte block
 5969   5D65               	VFCHECK:
 5970   5D65   A0 00       		ldy	#SGTCHKS	; get check sum
 5971   5D67   A5 7F       		lda	L+HI		; start with MSB
 5972   5D69   D1 1E       		cmp	(DSEGS),Y	; well . . . ?
 5973   5D6B   D0 09       		bne	VFBAD		; nope, it is wrong
 5974   5D6D   C8          		iny			; first byte is okay
 5975   5D6E   A5 7E       		lda	L+LO		; so check LSB
  Tue Jun 13 1989 11:42                                                                                                  Page   87

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- VERIFY CODE ---"

 5976   5D70   D1 1E       		cmp	(DSEGS),Y	; well . . . ?
 5977   5D72   D0 02       		bne	VFBAD		; die a slow ugly death
 5978   5D74   18          		clc			; clear carry to show niceness
 5979   5D75   60          		rts
 5980   5D76               	VFBAD:
 5981   5D76   38          		sec			; carry is set if bad
 5982   5D77   60          		rts			; and return to your fate
 5983                      	;
 5984                      	; SETUP_DISK0 - this routine does some special processing to get the file
 5985                      	; pointer to the beginning of data for the preload file.  It skips over
 5986                      	; segment table.
 5987   5D78               	SETUP_DISK0:
 5988   5D78               		READ	READ_PB		; read in first block
 5989   5D78               		PRODOS	$CA, READ_PB
 5990   5D78   20 00 BF    		jsr	$BF00	; ProDOS handler
 5991   5D7B   CA          		DB	$CA	; ProDOS function code
 5992   5D7C   BE45        		DW	READ_PB	; Function Parameter Block address
 5993   5D7E               		.MACEND
 5994   5D7E               		.MACEND
 5995   5D7E   AD 00 08    		lda	IOBUFF		; MSB of segment table size (in words)
 5996   5D81   8D CF 45    		sta	PSEEK+SM_FPOS+1	; middle part of offset
 5997   5D84   AD 01 08    		lda	IOBUFF+1	; LSB of size
 5998   5D87   0A          		asl	A		; *2 to pick up carry
 5999   5D88   2E CF 45    		rol	PSEEK+SM_FPOS+1	; rotate in carry
 6000   5D8B   2E D0 45    		rol	PSEEK+SM_FPOS+2	; and once more
 6001   5D8E   A8          	        tay                     ; check for wrapping upwards 
 6002   5D8F   F0 08       	        beq     STD01           ; no wrap up then
 6003   5D91               	STD00:
 6004   5D91   EE CF 45    	        inc     PSEEK+SM_FPOS+1 ; wee did
 6005   5D94   D0 03       	        bne     STD01           ; no more wrapping
 6006   5D96   EE D0 45    	        inc     PSEEK+SM_FPOS+2 ; yes there is
 6007   5D99               	STD01:        
 6008   5D99   AD CF 45    	        lda     PSEEK+SM_FPOS+1 ; make sure it is a 512 byte page
 6009   5D9C   29 01       	        and     #$1             ; even page?
 6010   5D9E   D0 F1       	        bne     STD00           ; inc again, please
 6011   5DA0               	STD0X:
 6012   5DA0               		SET_MARK PSEEK		; skip the segment table stuff
 6013   5DA0               		PRODOS	$CE, PSEEK
 6014   5DA0   20 00 BF    		jsr	$BF00	; ProDOS handler
 6015   5DA3   CE          		DB	$CE	; ProDOS function code
 6016   5DA4   CC45        		DW	PSEEK	; Function Parameter Block address
 6017   5DA6               		.MACEND
 6018   5DA6               		.MACEND
 6019   5DA6   60          		rts			; all done
 6020                      	
 6021   5DA7               		END
 6022                      	
 6023   5DA7               		INCLUDE		SCREEN.ASM
 6024   5DA7               		STTL	"--- APPLE ][ SCREEN STUFF ---"
 6025                      		PAGE
  Tue Jun 13 1989 11:42                                                                                                  Page   88

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6026                      	
 6027                      	; -----------------
 6028                      	; PRINT CHAR IN [A] AT CV,CH
 6029                      	; -----------------
 6030                      	;
 6031                      	; uses memory register [L]
 6032                      	;
 6033   5DA7   00          	SAVECY	DB	0	; spot to save current screen y pos
 6034   5DA8   00          	SAVECX	DB	0	; spot for x pos
 6035                      	
 6036   5DA9               	CHAR:
 6037   5DA9   85 AC       		sta	IOCHAR	; SAVE HERE
 6038   5DAB   8A          		txa		; SAVE [X] AND [Y]
 6039   5DAC   48          		pha		
 6040   5DAD   98          		tya		
 6041   5DAE   48          		pha
 6042   5DAF               		
 6043   5DAF   A5 AC       		lda	IOCHAR		; get it back
 6044   5DB1   C9 08       		cmp	#BACKSPACE	; is it backspace with erase?
 6045   5DB3   D0 03       		bne	CHCX		; nope
 6046                      	
 6047   5DB5   4C D7 5E    		jmp	DO_BSPC		; so handle backspace
 6048   5DB8               	CHCX:
 6049   5DB8   C9 0D       		cmp	#EOL		; is it <CR>?
 6050   5DBA   D0 03       		bne	CHCONT		; just let dline handle it
 6051   5DBC               		
 6052   5DBC   4C A4 5E    		jmp	DO_EOL		; handle <CR>
 6053                      	;
 6054                      	; so save some stuff and do all the necessary figgering
 6055                      	;
 6056   5DBF               	CHCONT:
 6057   5DBF   AE 0D 72    		ldx	SCRCNT		; just stash character
 6058   5DC2   9D 80 02    		sta	SCRBUFF,X	; save it
 6059   5DC5   EE 0D 72    		inc	SCRCNT		; and count it
 6060   5DC8               	CH_EXIT:
 6061   5DC8   68          		pla			; RESTORE [X] AND [Y]
 6062   5DC9   A8          		tay		
 6063   5DCA   68          		pla		
 6064   5DCB   AA          		tax		
 6065   5DCC   60          		rts
 6066                      	;
 6067                      	; PUT_NYBBLE - put 4 bits to the screen at SCRCX, SCRCY (the lower 4 bits
 6068                      	;	in [A]).
 6069                      	;
 6070   5DCD               	PUT_NYBBLE:
 6071   5DCD   85 0E       		sta	NY_DATA		; save [A] for mucking with
 6072   5DCF   20 78 5E    		jsr	SETPOS		; set up offsets using SCRCX
 6073                      	
 6074   5DD2   A9 08       		lda	#$8		; start at first bit, left to right
 6075   5DD4   85 10       		sta	DATALOOP	; and init the counter with it
 6076   5DD6               	PNY0:
 6077   5DD6   A6 8E       		ldx	FPCBNK		; which bank
 6078   5DD8   BD 54 C0    		lda	PAGE2SW,X	; select it
 6079   5DDB   A0 00       		ldy	#0		; start with zero
 6080   5DDD   B1 8C       		lda	(FPC),Y		; get it
 6081   5DDF   85 13       		sta	SCR_DATA	; and save it
 6082   5DE1               	PNY1:	
 6083   5DE1   A6 11       		ldx	BITOFF		; get which interesting bit we want
 6084   5DE3   BD 30 5E    		lda	GT_BITS,X	; get bit 
 6085   5DE6   48          		pha			; save bit pictures
 6086   5DE7   A5 10       		lda	DATALOOP 	; see if we have done all 4 bits in this 'pixel'
 6087   5DE9   F0 29       		beq	PNY_EXIT 	; toots finis
 6088   5DEB   46 10       		lsr	DATALOOP 	; point to next bit
 6089   5DED   24 0E       		bit	NY_DATA		; is this bit set?
 6090   5DEF   D0 08       		bne	PNY_SET		; yes it is, so we will handle different
 6091                      	;
 6092                      	; Bit is clear, so clear appropriate one in the SCR_DATA byte
 6093                      	;
 6094   5DF1   68          		pla			; get bit picture back
 6095   5DF2   49 FF       		eor	#$FF		; turn bits all around
 6096   5DF4   25 13       		and 	SCR_DATA	; turn off bit in screen data
 6097   5DF6   4C FC 5D    		jmp	PNY_NEXT	; and continue
 6098   5DF9               	PNY_SET:
 6099   5DF9   68          		pla			; get bit mask back
 6100   5DFA   05 13       		ora	SCR_DATA	; turn on bit
  Tue Jun 13 1989 11:42                                                                                                  Page   89

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6101   5DFC               	PNY_NEXT:
 6102   5DFC   85 13       		sta	SCR_DATA	; save result
 6103   5DFE   E6 11       		inc	BITOFF		; we're looking at next bit
 6104   5E00   A5 11       		lda	BITOFF		; now check how we're doing
 6105   5E02   C9 07       		cmp	#7		; only doing bits 0-6
 6106   5E04   D0 DB       		bne	PNY1		; check next bit
 6107                      	;
 6108                      	; we've finished this byte in screen memory, point to next one
 6109                      	;
 6110   5E06   A9 00       		lda	#0		; start at zero'th bit
 6111   5E08   85 11       		sta	BITOFF		; thank you
 6112   5E0A   A5 13       		lda	SCR_DATA	; now stash this one in the screen
 6113   5E0C   91 8C       		sta	(FPC),Y		; y is still zero; still pointing to bank
 6114   5E0E   20 1D 5E    		jsr	NEXT_SCR	; make SPC/FPC point to next spot
 6115   5E11   4C D6 5D    		jmp	PNY0	; and continue on please
 6116                      	;
 6117                      	; all done, so make sure we stash anything out there
 6118                      	;
 6119   5E14               	PNY_EXIT:
 6120   5E14   68          		pla			; get bit mask back to fix stack
 6121   5E15   A5 13       		lda	SCR_DATA	; put away the current data byte
 6122   5E17   91 8C       		sta	(FPC),Y		; y is still zero; still pointing to bank
 6123   5E19   AD 54 C0    		lda	PAGE2SW+MAIN	; back to MAIN page 2
 6124   5E1C   60          		rts
 6125                      	;
 6126                      	; NEXT_SCR - make FPC/SPC point to next screen byte
 6127                      	;
 6128   5E1D               	NEXT_SCR:
 6129                      	;
 6130                      	; if in main bank, when we go to aux bank, we need to look at the next
 6131                      	; 	byte in memory
 6132                      	;
 6133   5E1D   A5 8E       		lda	FPCBNK		; get what bank we're talking to currently
 6134   5E1F   D0 08       		bne	NXS0		; 0 = main bank, 1 = aux bank
 6135   5E21   E6 8F       		inc	SPCL	; point to next byte
 6136   5E23   E6 8C       		inc	FPCL	; and for fetching
 6137   5E25   A9 01       		lda	#AUX	; and point to aux bank
 6138   5E27   D0 02       		bne	NXS1	; (BRANCH) and continue on
 6139                      	;
 6140                      	; if in aux bank, all we need to do is switch banks
 6141                      	;
 6142   5E29               	NXS0:
 6143   5E29   A9 00       		lda	#MAIN	; just make it main bank
 6144   5E2B               	NXS1:
 6145   5E2B   85 91       		sta	SPCBNK	; for stashing and
 6146   5E2D   85 8E       		sta	FPCBNK	; fetching
 6147   5E2F   60          		rts
 6148                      	;
 6149                      	; GET_NYBBLE - get the 4 bits which represent the screen at position
 6150                      	;	SCRCX, SCRCY; return nybble in low 4 bits of [A]
 6151                      	;
 6152   5E30   01 02 04 08 10 	GT_BITS: db 1,2,4,8,$10,$20,$40
        5E35   20 40 
 6153   5E37               	GET_NYBBLE:
 6154   5E37   20 78 5E    		jsr	SETPOS	; set up offsets using SCRCX
 6155                      	
 6156   5E3A   A9 00       		lda	#0	; clear out my data spot
 6157   5E3C   85 0E       		sta	NY_DATA	; for mucking with
 6158                      	
 6159   5E3E   A9 10       		lda	#$10	; setting bits 0-3, starting with shift
 6160   5E40   85 10       		sta	DATALOOP ; so init the setter
 6161   5E42               	GNY0:
 6162   5E42   A6 8E       		ldx	FPCBNK		; which bank
 6163   5E44   BD 54 C0    		lda	PAGE2SW,X	; save which bank
 6164   5E47   A0 00       		ldy	#0		; zero y
 6165   5E49   B1 8C       		lda	(FPC),Y		; get byte
 6166   5E4B   85 13       		sta	SCR_DATA	; and save it
 6167   5E4D               	GNY1:	
 6168   5E4D   46 10       		lsr	DATALOOP ; see if we have done all 4 bits in this 'pixel'
 6169   5E4F   F0 21       		beq	GNY_EXIT ; all done!
 6170                      	
 6171   5E51   A6 11       		ldx	BITOFF	; get bit offset
 6172   5E53   BD 30 5E    		lda	GT_BITS,X	; get bit pattern
 6173                      	;
 6174                      	; now check appropriate bit in Screen Data
  Tue Jun 13 1989 11:42                                                                                                  Page   90

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6175                      	;
 6176   5E56   25 13       		and	SCR_DATA ; see if it is set
 6177   5E58   F0 06       		beq	GNY3	; no bit set here
 6178                      	;
 6179                      	; bit is set, so set it in my data nybble
 6180                      	;
 6181   5E5A   A5 10       		lda	DATALOOP ; get bit setter
 6182   5E5C   05 0E       		ora	NY_DATA	; and put it into my data byte
 6183   5E5E   85 0E       		sta	NY_DATA	; and save it
 6184   5E60               	GNY3:
 6185   5E60   E6 11       		inc	BITOFF	; we're looking at next bit
 6186   5E62   A5 11       		lda	BITOFF	; now check how we're doing
 6187   5E64   C9 07       		cmp	#7	; only doing bits 0-6
 6188   5E66   D0 E5       		bne	GNY1	; check next bit
 6189                      	;
 6190                      	; we've finished this byte in screen memory, point to next one
 6191                      	;
 6192   5E68   A9 00       		lda	#0	; start at zero'th bit
 6193   5E6A   85 11       		sta	BITOFF	; thank you
 6194   5E6C   20 1D 5E    		jsr	NEXT_SCR	; point to next byte
 6195   5E6F   4C 42 5E    		jmp	GNY0	; and continue on please
 6196   5E72               	GNY_EXIT:
 6197   5E72   AD 54 C0    		lda	PAGE2SW+MAIN	; back to main page 2
 6198   5E75   A5 0E       		lda	NY_DATA	; get the nybble desired
 6199   5E77   60          		rts
 6200                      	;
 6201                      	; SETPOS - get the byte offset and the bit offset from the table using
 6202                      	;		SCRCX
 6203                      	;
 6204                      	;	USES: SCRCX, SCRCY
 6205                      	;	SETS: FPC - pointer to correct screen memory location
 6206                      	;	      BITOFF - bit offset to get to start of byte (N.B. this is left to
 6207                      	;			right count, while in memory it is right to left!)
 6208   5E78               	SETPOS:
 6209   5E78   A5 00       		lda	SCRCX		; get the x pos
 6210   5E7A   AA          		tax			; put where we can use it
 6211   5E7B   BD 52 03    		lda	XPOSTBL,X	; get byte #
 6212   5E7E   85 8C       		sta	FPCL		; okay, saved
 6213   5E80   BD E0 6B    		lda	XBITTBL,X	; get bitoffset
 6214   5E83   85 11       		sta	BITOFF		; where it wants it
 6215                      	
 6216   5E85   A5 8C       		lda	FPCL		; check for correct bank
 6217   5E87   29 01       		and	#$01		; if odd, then must be main bank
 6218   5E89   D0 04       		bne	STP11		; okay, it be odd
 6219   5E8B   A9 01       		lda	#AUX		; aux bank
 6220   5E8D   D0 02       		bne	STP22		; jump
 6221   5E8F               	STP11:
 6222   5E8F   A9 00       		lda	#MAIN		; main bank
 6223   5E91               	STP22:
 6224   5E91   85 8E       		sta	FPCBNK		; save it
 6225   5E93   A5 8C       		lda	FPCL		; get for fetch
 6226   5E95   4A          		lsr	A		; /2 to get correct byte offset
 6227   5E96   A6 01       		ldx	SCRCY		; get vertical pos
 6228   5E98   18          		clc			; get ready for adding
 6229   5E99   7D 60 6A    		adc	BASEL,X	 	; add low part
 6230   5E9C   85 8C       		sta	FPCL		; save low part
 6231   5E9E   BD 20 6B    		lda	BASEH,X		; get high part
 6232   5EA1   85 8D       		sta	FPCH		; save high part
 6233   5EA3   60          		rts			; done !?
 6234                      	;
 6235                      	; DO_EOL - if this is end of line, check if we are at end of window
 6236                      	; 	and if we are, and it is a scrollable window, scroll.  Then move
 6237                      	;	the cursor to the left margin of said window
 6238                      	;
 6239   5EA4               	DO_EOL:
 6240   5EA4   20 1A 72    		jsr	DISP_LINE	; make sure line gets out there
 6241   5EA7   A5 01       		lda	SCRCY		; get current vertical pos
 6242   5EA9   18          		clc			; add font height
 6243   5EAA   69 09       		adc	#FONT_H		; thank you
 6244   5EAC   48          		pha			; save this position
 6245   5EAD   69 09       		adc	#FONT_H		; make sure we have room for characters here
 6246   5EAF   C5 02       		cmp	SCRBTM		; so check against the bottom
 6247   5EB1   F0 02       		beq	SAVECV		; no scroll yet
 6248   5EB3   B0 05       		bcs	SCROLLCITY	; nope, can't use it
 6249   5EB5               	SAVECV:
  Tue Jun 13 1989 11:42                                                                                                  Page   91

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6250   5EB5   68          		pla			; get new CV
 6251   5EB6   85 01       		sta	SCRCY		; and save it
 6252   5EB8   D0 09       		bne	DEL1		; JUMP
 6253   5EBA               	SCROLLCITY:
 6254   5EBA   68          		pla			; get bad y pos
 6255   5EBB   AD 05 72    		lda	SCRLFLG		; is this a scrolling window?
 6256   5EBE   F0 03       		beq	DEL1		; nope, just move to left edge
 6257   5EC0   20 16 60    		jsr	SCROLL_UP	; and scroll window
 6258   5EC3               	DEL1:
 6259                      	;
 6260                      	; move cursor back to left margin
 6261                      	;
 6262   5EC3   A5 04       		lda	LEFTMRG		; get left margin
 6263   5EC5   85 00       		sta	SCRCX		; and set itpositions
 6264   5EC7   A9 01       		lda	#1		; show cursor changed (maybe)
 6265   5EC9   8D A5 6C    		sta	CURSFLG		; okay
 6266   5ECC   A9 00       		lda	#0		; clear length too
 6267   5ECE   85 A7       		sta	LENGTH+LO	; no more on line
 6268   5ED0   85 A8       		sta	LENGTH+HI	; no more on line
 6269   5ED2   4C C8 5D    		jmp	CH_EXIT		; now finish it up
 6270                      	;
 6271                      	; DO_BSPC - do a backspace, by erasing char just before cursor to
 6272                      	;	background color, and moving cursor back one space
 6273                      	; 	[X] == character to delete
 6274                      	;
 6275   5ED5   0000        	SAVECHX: DW 	0
 6276                      	
 6277   5ED7               	DO_BSPC:
 6278   5ED7   AD 01 72    		lda	CHR_X+LO	; figger new CHR_X
 6279   5EDA   38          		sec			; subtract width
 6280   5EDB   A4 C1       		ldy	FONTFLG		; get which font we be using
 6281   5EDD   F0 05       		beq	DOBSP0		; must be variable width
 6282   5EDF   E9 0C       		sbc	#MONOFONT_W	; get width then of mono font
 6283   5EE1   4C E7 5E    		jmp	DOBSP1		; okay, now do add
 6284   5EE4               	DOBSP0:
 6285   5EE4   FD 53 64    		sbc	CHWID,X		; get width of char to be erased
 6286   5EE7               	DOBSP1:
 6287   5EE7   8D 01 72    		sta	CHR_X+LO	; show new one
 6288   5EEA   8D D5 5E    		sta	SAVECHX+LO	; save to restore later
 6289   5EED   AD 02 72    		lda	CHR_X+HI	; and pick up carry
 6290   5EF0   E9 00       		sbc	#0		; okay, did it
 6291   5EF2   8D 02 72    		sta	CHR_X+HI	; save it
 6292   5EF5   8D D6 5E    		sta	SAVECHX+HI	; okay
 6293   5EF8   A0 20       		ldy	#SPACE		; get SPACE offset
 6294   5EFA   A5 C1       	        lda     FONTFLG         ; monospaced font?
 6295   5EFC   F0 04       	        beq     DOBSP2          ; nope
 6296   5EFE   A9 0C       	        lda     #MONOFONT_W     ; make monospaced wide
 6297   5F00   D0 03       	        bne     DOBSP3          ; fine
 6298   5F02               	DOBSP2:
 6299   5F02   BD 53 64    		lda	CHWID,X		; get width of char
 6300   5F05               	DOBSP3:
 6301   5F05   99 53 64    		sta	CHWID,Y		; set space to be this wide	
 6302   5F08   8C 80 02    		sty	SCRBUFF		; make space for erasing
 6303   5F0B   A9 01       		lda	#1		; show one char
 6304   5F0D   8D 0D 72    		sta	SCRCNT		; assume it used to be zero
 6305   5F10   20 1A 72    		jsr	DISP_LINE	; put that space out
 6306   5F13   AD D5 5E    		lda	SAVECHX+LO	; restore old/new x pos
 6307   5F16   8D 01 72    		sta	CHR_X+LO
 6308   5F19   AD D6 5E    		lda	SAVECHX+HI
 6309   5F1C   8D 02 72    		sta	CHR_X+HI
 6310   5F1F   20 B3 73    		jsr	GET_SCRCX	; update SCRCX please
 6311                      	
 6312   5F22   A9 08       		lda	#SPACE_WIDTH	; restore width of space char
 6313   5F24   A0 20       		ldy	#SPACE		; get offset
 6314   5F26   99 53 64    		sta	CHWID,Y		; okay
 6315                      	
 6316   5F29   4C C8 5D    		jmp	CH_EXIT		; done
 6317                      	;
 6318                      	; CLS - clear the window, using CLS parameters
 6319                      	;
 6320   5F2C               	CLS:
 6321   5F2C   A5 00       		lda	SCRCX		; save the current X,Y
 6322   5F2E   8D A8 5D    		sta	SAVECX		; x
 6323   5F31   A5 01       		lda	SCRCY
 6324   5F33   8D A7 5D    		sta	SAVECY		; saved
  Tue Jun 13 1989 11:42                                                                                                  Page   92

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6325   5F36   A5 0B       		lda	CLSTOP		; get top line
 6326   5F38   85 01       		sta	SCRCY		; and set up a y pos
 6327                      	
 6328   5F3A   20 E8 5F    		jsr	SETMASK		; set up masks and ending point
 6329                      	
 6330   5F3D   A5 BD       		lda	CPY_COUNT	; get count
 6331   5F3F   85 14       		sta	SH_LOOP		; save count
 6332   5F41   A5 0A       		lda	CLSLEFT		; get left edge
 6333   5F43   85 00       		sta	SCRCX		; set up as X pos
 6334   5F45   A0 0E       		ldy	#WINBGND	; get background offset
 6335   5F47   B1 05       		lda	(WINDOW),Y	; get background color
 6336   5F49   85 71       		sta	ARG8		; save it here
 6337   5F4B   A5 0C       		lda	CLSWIDTH	; how wide we be?
 6338   5F4D   D0 05       		bne	CLSOKAY		; not a zero width
 6339   5F4F   A9 19       		lda	#25		; zero can't do zero width
 6340   5F51   4C F9 51    		jmp	ZERROR		; so die
 6341   5F54               	CLSOKAY:
 6342   5F54   C9 03       		cmp	#3		; if skinny, handle special
 6343   5F56   B0 28       		bcs	L1L0		; nope
 6344   5F58   85 6F       		sta	ARG7		; make this be the counter
 6345   5F5A   A5 0D       		lda	CLSHEIGHT	; just use PUT/GET NYBBLE if only one wide
 6346   5F5C   D0 05       		bne	CLSOKAY1	; not a zero height either
 6347   5F5E   A9 19       		lda	#25		; bad error
 6348   5F60   4C F9 51    		jmp	ZERROR
 6349   5F63               	CLSOKAY1:	
 6350   5F63   85 7A       		sta	J		; save here
 6351   5F65               	CLS1W:
 6352   5F65   A5 71       		lda	ARG8		; get color
 6353   5F67   20 CD 5D    		jsr	PUT_NYBBLE	; put it
 6354   5F6A   E6 00       		inc	SCRCX		; next x
 6355   5F6C   C6 6F       		dec	ARG7		; counter
 6356   5F6E   D0 F5       		bne	CLS1W		; do next X
 6357   5F70   A5 0A       		lda	CLSLEFT		; get left edge again
 6358   5F72   85 00       		sta	SCRCX		; point to it
 6359   5F74   E6 01       		inc	SCRCY		; next line
 6360   5F76   A5 0C       		lda	CLSWIDTH	; restore width count
 6361   5F78   85 6F       		sta	ARG7		; thanks
 6362   5F7A   C6 7A       		dec	J		; count
 6363   5F7C   D0 E7       		bne	CLS1W		; do it
 6364   5F7E   F0 56       		beq	CLSEXIT		; all done then
 6365   5F80               	L1L0:
 6366   5F80   85 7A       		sta	J		; use j as counter
 6367   5F82               	L1L:
 6368   5F82   A5 71       		lda	ARG8		; a color please
 6369   5F84   20 CD 5D    		jsr	PUT_NYBBLE	; do first line easy
 6370   5F87   E6 00       		inc	SCRCX		; next nybble
 6371   5F89   C6 7A       		dec	J		; done yet?
 6372   5F8B   D0 F5       		bne	L1L		; nope
 6373                      	
 6374   5F8D   A5 0A       		lda	CLSLEFT		; where is left column
 6375   5F8F   85 00       		sta	SCRCX		; here!
 6376   5F91   20 78 5E    		jsr	SETPOS		; get the address
 6377   5F94   20 A5 90    		jsr	FP2SP		; SPC is source PC, now!
 6378   5F97   A5 0D       		lda	CLSHEIGHT	; how many lines are we clearing
 6379   5F99   D0 05       		bne	CLSOKAY2	; not a zero height either
 6380   5F9B   A9 19       		lda	#25		; bad error
 6381   5F9D   4C F9 51    		jmp	ZERROR
 6382   5FA0               	CLSOKAY2:	
 6383   5FA0   85 7A       		sta	J		; j is counter again
 6384   5FA2   C6 7A       	 	dec	J		; already cleared one line
 6385   5FA4   F0 30       		beq	CLSEXIT		; only one line to do!
 6386   5FA6               	CLSLOOP:
 6387   5FA6   A5 90       	        lda     SPCH            ; now, modify COPY_LINE
 6388   5FA8   8D 7D 1D    	        sta     CPY_MOD1_SRC+HI
 6389   5FAB   8D A1 1D    	        sta     CPY_MOD2_SRC+HI
 6390   5FAE   A5 8F       	        lda     SPCL
 6391   5FB0   8D 7C 1D    	        sta     CPY_MOD1_SRC+LO
 6392   5FB3   8D A0 1D    	        sta     CPY_MOD2_SRC+LO     
 6393   5FB6   E6 01       		inc	SCRCY		; clear this line
 6394   5FB8   20 78 5E    		jsr	SETPOS		; where am i?
 6395   5FBB   A5 8D       	        lda     FPCH            ; now, modify COPY_LINE
 6396   5FBD   8D 80 1D    	        sta     CPY_MOD1_DST+HI
 6397   5FC0   8D A4 1D    	        sta     CPY_MOD2_DST+HI
 6398   5FC3   A5 8C       	        lda     FPCL
 6399   5FC5   8D 7F 1D    	        sta     CPY_MOD1_DST+LO
  Tue Jun 13 1989 11:42                                                                                                  Page   93

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6400   5FC8   8D A3 1D    	        sta     CPY_MOD2_DST+LO     
 6401   5FCB   A5 14       		lda	SH_LOOP		; get count
 6402   5FCD   85 BD       		sta	CPY_COUNT	; and save it
 6403   5FCF   20 50 1D    		jsr	COPY_LINE	; did the copy (i hope)
 6404   5FD2   C6 7A       		dec	J		; count it
 6405   5FD4   D0 D0       		bne	CLSLOOP		; next one please
 6406   5FD6               	CLSEXIT:
 6407   5FD6   AD A8 5D    	 	lda	SAVECX		; get X,Y back
 6408   5FD9   85 00       		sta	SCRCX		; got it
 6409   5FDB   AD A7 5D    		lda	SAVECY		; now for y
 6410   5FDE   85 01       		sta	SCRCY		; restored!
 6411                      	
 6412   5FE0   60          		rts
 6413                      	;
 6414                      	; SETMASK - figger out the start and end masks, as well as setting
 6415                      	;	stuff to point to stopping address.  Use CLSLEFT and CLSWIDTH
 6416                      	;
 6417   5FE1   00 01 03 07 0F 	ST_BITS: db 0,1,3,7,$f,$1f,$3f
        5FE6   1F 3F 
 6418   5FE8               	SETMASK:
 6419   5FE8   A5 0A       		lda	CLSLEFT		; munge with SCRX
 6420   5FEA   85 00       		sta	SCRCX		; okay
 6421   5FEC   20 78 5E    		jsr	SETPOS		; get me the bit offset of start
 6422                      	
 6423   5FEF   A6 11       		ldx	BITOFF		; now set up mask
 6424   5FF1   BD E1 5F    		lda	ST_BITS,X	; get the bit pattern
 6425   5FF4   85 1A       		sta	STMASK		; save it
 6426                      	
 6427   5FF6   A5 0A       		lda	CLSLEFT		; get left edge again
 6428   5FF8   18          		clc			; add width
 6429   5FF9   65 0C       		adc	CLSWIDTH	; to get where to stop
 6430   5FFB   AA          		tax			; make index
 6431   5FFC   86 00       		stx	SCRCX		; set cur pos
 6432   5FFE   BD 52 03    		lda	XPOSTBL,X	; get how many bytes
 6433   6001   A6 0A       		ldx	CLSLEFT		; subtract from byte offset of start
 6434   6003   38          		sec			; subbing
 6435   6004   FD 52 03    		sbc	XPOSTBL,X
 6436   6007   85 BD       		sta	CPY_COUNT	; and save it
 6437   6009   E6 BD       		inc	CPY_COUNT	; and make it inclusive count
 6438                      	
 6439   600B   20 78 5E    		jsr	SETPOS		; so get its address
 6440                      	
 6441   600E   A6 11       		ldx	BITOFF		; get bit offset
 6442   6010   BD E1 5F    		lda	ST_BITS,X	; get pattern
 6443   6013   85 1B       		sta	ENDMASK		; okay!
 6444   6015   60          		rts
 6445                      	;
 6446                      	; SCROLL_UP - roll the current window by FONT_H lines
 6447                      	;
 6448   6016               	SCROLL_UP:
 6449   6016   A9 09       		lda 	#FONT_H		; show one line
 6450   6018   85 18       		sta	SCLLINES	; done
 6451   601A   85 1D       		sta	SCLDIR		; show scroll up with positive number
 6452   601C   A0 00       		ldy	#WINTOP		; get top of screen
 6453   601E   B1 05       		lda	(WINDOW),Y	; got it
 6454   6020   85 0B       		sta	CLSTOP		; saved it
 6455   6022   C8          		iny			; point to left edge
 6456   6023   B1 05       		lda	(WINDOW),Y	; get left edge
 6457   6025   85 0A       		sta	CLSLEFT		; save
 6458   6027   C8          		iny			; this is now the height
 6459   6028   B1 05       		lda	(WINDOW),Y	; get window height
 6460   602A   85 0D       		sta	CLSHEIGHT	; show me
 6461   602C   C8          		iny			; and now for the width
 6462   602D   B1 05       		lda	(WINDOW),Y	; get width
 6463   602F   85 0C       	  	sta	CLSWIDTH	; saved it
 6464                      					; so fall thru
 6465                      					; and do the scrolling
 6466                      	;	FALLING THRU
 6467                      	;	   |
 6468                      	;	  \ /
 6469                      	;
 6470                      	;
 6471                      	; DO_SCROLL - scroll SCLLINES withing the window as defined by
 6472                      	;	CLSLEFT,TOP,WIDTH, and HEIGHT
 6473                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page   94

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6474   6031               	DO_SCROLL:
 6475   6031   A5 00       		lda	SCRCX		; save the current X,Y
 6476   6033   8D A8 5D    		sta	SAVECX		; x
 6477   6036   A5 01       		lda	SCRCY
 6478   6038   8D A7 5D    		sta	SAVECY		; saved
 6479   603B   A5 18       		lda	SCLLINES	; how many lines?
 6480                      	
 6481   603D   A6 1D       		ldx	SCLDIR		; which direction?
 6482   603F   10 04       		bpl	SC1		; >0 means scroll up
 6483                      	;
 6484                      	; scroll down, so we are going to start at the bottom and copy downwards
 6485                      	; until we reach the top
 6486                      	;
 6487                      	; now modify code so we do adds to get destination line and subtracts
 6488                      	; to get new src line
 6489                      	;
 6490   6041   A0 C6       		ldy	#$C6		; 'dec' opcode
 6491   6043   D0 04       		bne	SC2		; jump to modify
 6492   6045               	SC1:
 6493                      	;
 6494                      	; scroll up - start at top and copy upwards until we reach the bottom
 6495                      	;
 6496   6045   A0 E6       		ldy	#$E6		; 'inc' opcode
 6497   6047   A6 18       		ldx	SCLLINES	; get # of scrolling lines
 6498   6049               	SC2:
 6499   6049   8C 00 61    		sty	SCMOD1		; make inc/dec
 6500   604C   8C 02 61    		sty	SCMOD2		; either inc or dec
 6501   604F   86 1C       		stx	SCOFF		; save the offset between SRC and DST
 6502                      	
 6503   6051   A5 1D       		lda	SCLDIR		; which direction?
 6504   6053   10 13       		bpl	SC3		; must be normal scroll
 6505                      	;
 6506                      	; if scrolling downwards, we need to start source at bottom-offset and
 6507                      	; end when the destination is at top+offset
 6508                      	;
 6509   6055   A5 0D       		lda	CLSHEIGHT	; get # of lines in window
 6510   6057   38          		sec			; subbing
 6511   6058   E5 1C       		sbc	SCOFF		; subtract offset to get source
 6512   605A   18          		clc			; adding
 6513   605B   65 0B       		adc	CLSTOP		; and get absolute position
 6514   605D   AA          		tax			; put in X
 6515   605E   CA          		dex			; for 0 offset it
 6516   605F   A5 0B       		lda	CLSTOP		; now figger last line to copy
 6517   6061   18          		clc			; adding
 6518   6062   65 0D       		adc	CLSHEIGHT	; get me last line
 6519   6064   A8          		tay			; for later storage
 6520   6065   88          		dey			; make 0 based
 6521   6066   D0 08       		bne	SC4		; always jumps
 6522   6068               	SC3:
 6523                      	;
 6524                      	; if scrolling upwards, start src at top+offset and end when destination
 6525                      	; is at bottom-offset
 6526                      	;
 6527   6068   A5 0B       		lda	CLSTOP		; get top
 6528   606A   18          		clc			; adding
 6529   606B   65 1C       		adc	SCOFF		; add in offset
 6530   606D   AA          		tax			; for later on
 6531   606E   A4 0B       		ldy	CLSTOP		; first destination is top of window
 6532   6070               	SC4:
 6533   6070   86 01       		stx	SCRCY		; Starting Source
 6534   6072   84 15       		sty	SCROLLY		; Starting Destination
 6535                      	
 6536   6074   20 E8 5F    		jsr	SETMASK		; set the masks and horizontal endpoint
 6537   6077   A5 BD       		lda	CPY_COUNT	; save for future generations
 6538   6079   85 14       		sta	SH_LOOP		; save it
 6539   607B   A5 0D       		lda	CLSHEIGHT	; how high
 6540   607D   85 10       		sta	DATALOOP	; save as counter
 6541   607F   38          		sec			; for subbing
 6542   6080   E5 1C       		sbc	SCOFF		; subtract scrolling amount
 6543   6082   85 0D       		sta	CLSHEIGHT	; this is how many lines to copy
 6544   6084   A5 01       		lda	SCRCY		; save Start Source
 6545   6086   48          		pha
 6546   6087   A5 0B       		lda	CLSTOP		; start at Y pos
 6547   6089   85 01       		sta	SCRCY
 6548   608B   A5 0A       		lda	CLSLEFT		; and x pos
  Tue Jun 13 1989 11:42                                                                                                  Page   95

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6549   608D   85 00       		sta	SCRCX		; thank you
 6550   608F   AD 54 C0    		lda	PAGE2SW+MAIN	; make sure main memory page is in there
 6551   6092               	SCRL1:
 6552   6092   20 78 5E    		jsr	SETPOS		; set up line pointer
 6553   6095   A4 01       		ldy	SCRCY		; get top
 6554   6097   C0 78       		cpy	#120		; 120 bytes per list
 6555   6099   90 05       		bcc	SCRLY		; all set
 6556   609B   98          		tya			; for adding
 6557   609C   18          		clc
 6558   609D   69 08       		adc	#8
 6559   609F   A8          		tay
 6560   60A0               	SCRLY:
 6561   60A0   A5 8D       		lda	FPCH
 6562   60A2   99 00 06    		sta	SV_PCH,Y
 6563   60A5   A5 8C       		lda	FPCL
 6564   60A7   99 00 04    		sta	SV_PCL,Y
 6565   60AA   E6 01       		inc	SCRCY		; next line please
 6566   60AC   C6 10       		dec	DATALOOP
 6567   60AE   D0 E2       		bne	SCRL1
 6568                      	
 6569   60B0   68          		pla			; get StartSource back
 6570   60B1   85 01       		sta	SCRCY
 6571   60B3   A5 8E       		lda	FPCBNK		; init SPC bank too
 6572   60B5   85 91       		sta	SPCBNK		; fine, we did
 6573   60B7               	SCROLLING:
 6574   60B7   A4 01       		ldy	SCRCY		; get source Y for index
 6575   60B9   C0 78       		cpy	#120		; jump over junk
 6576   60BB   90 05       		bcc	SCLYY
 6577   60BD   98          		tya
 6578   60BE   18          		clc
 6579   60BF   69 08       		adc	#8
 6580   60C1   A8          		tay
 6581   60C2               	SCLYY:
 6582   60C2   B9 00 06    		lda	SV_PCH,Y
 6583   60C5   85 90       		sta	SPCH
 6584   60C7   8D 7D 1D    	        sta     CPY_MOD1_SRC+HI
 6585   60CA   8D A1 1D    	        sta     CPY_MOD2_SRC+HI
 6586   60CD   B9 00 04    		lda	SV_PCL,Y
 6587   60D0   8D 7C 1D    	        sta     CPY_MOD1_SRC+LO
 6588   60D3   8D A0 1D    	        sta     CPY_MOD2_SRC+LO     
 6589   60D6   85 8F       		sta	SPCL
 6590                      	
 6591   60D8   A4 15       		ldy	SCROLLY		; get destination Y pos
 6592   60DA   C0 78       		cpy	#120		; jump over junk
 6593   60DC   90 05       		bcc	SCLYY1
 6594   60DE   98          		tya
 6595   60DF   18          		clc
 6596   60E0   69 08       		adc	#8
 6597   60E2   A8          		tay
 6598   60E3               	SCLYY1:
 6599   60E3   B9 00 06    		lda	SV_PCH,Y
 6600   60E6   85 8D       		sta	FPCH
 6601   60E8   8D 80 1D    	        sta     CPY_MOD1_DST+HI
 6602   60EB   8D A4 1D    	        sta     CPY_MOD2_DST+HI
 6603   60EE   B9 00 04    		lda	SV_PCL,Y
 6604   60F1   8D 7F 1D    	        sta     CPY_MOD1_DST+LO
 6605   60F4   8D A3 1D    	        sta     CPY_MOD2_DST+LO     
 6606   60F7   85 8C       		sta	FPCL
 6607                      	
 6608   60F9   A5 14       		lda	SH_LOOP		; get byte counter
 6609   60FB   85 BD       		sta	CPY_COUNT	; show copy line
 6610   60FD   20 50 1D    		jsr	COPY_LINE	; and do the copy
 6611   6100   E6 01       	SCMOD1:	inc	SCRCY		; inc or dec to get next one
 6612   6102   E6 15       	SCMOD2:	inc	SCROLLY		; inc/dec for next destination Y
 6613   6104   C6 0D       		dec	CLSHEIGHT	; count down
 6614   6106   D0 AF       		bne	SCROLLING	; nope
 6615                      	
 6616   6108   A6 1D       		ldx	SCLDIR		; scroll up or down?
 6617   610A   10 09       		bpl	SCLCLR1		; clear a little different
 6618                      	;
 6619                      	; if scrolling down, clear from current Y+1
 6620                      	;	
 6621   610C   A5 01       		lda	SCRCY		; get current source
 6622   610E   85 0B       		sta	CLSTOP		; save in top spot
 6623   6110   E6 0B       		inc	CLSTOP		; get inside window
  Tue Jun 13 1989 11:42                                                                                                  Page   96

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6624   6112   4C 19 61    		jmp	SCLCLR2
 6625   6115               	SCLCLR1:
 6626   6115   A5 15       		lda	SCROLLY		; get last destination
 6627   6117   85 0B       		sta	CLSTOP		; and save it
 6628   6119               	SCLCLR2:
 6629   6119   A5 1C       		lda	SCOFF		; and both clear this many lines
 6630   611B   85 0D       		sta	CLSHEIGHT	; okay?
 6631                      	
 6632   611D   AD A8 5D    		lda	SAVECX		; now restore X and Y
 6633   6120   85 00       		sta	SCRCX		; x
 6634   6122   AD A7 5D    		lda	SAVECY		; and
 6635   6125   85 01       		sta	SCRCY		; y
 6636                      	
 6637   6127   20 2C 5F    		jsr	CLS		; WIDTH and LEFT should be okay still
 6638                      	
 6639   612A   60          		rts
 6640                      	;
 6641                      	; CLREOL - clear from current cursor position to end of line by
 6642                      	;	using CLS after changing the window size
 6643                      	;	
 6644   612B               	CLREOL:
 6645   612B   A5 00       		lda	SCRCX		; and make left be where cursor is
 6646   612D   85 0A       		sta	CLSLEFT
 6647   612F   A5 01       		lda	SCRCY		; and top be where Y is
 6648   6131   85 0B       		sta	CLSTOP
 6649   6133   A9 09       		lda	#FONT_H		; and bottom be bottom of char
 6650   6135   85 0D       		sta	CLSHEIGHT
 6651   6137   A0 03       		ldy	#WINWID		; get width
 6652   6139   B1 05       		lda	(WINDOW),Y	; got it
 6653   613B   18          		clc			; now adding 
 6654   613C   A0 01       		ldy	#WINLEFT	; the left edge
 6655   613E   71 05       		adc	(WINDOW),Y	; to get the right edge
 6656   6140   38          		sec			; subbing
 6657   6141   E5 0A       		sbc	CLSLEFT		; and subtract left to get width
 6658   6143   A0 07       	        ldy     #WINRM          ; remove the size of the right margin
 6659   6145   F1 05       	        sbc     (WINDOW),Y      ; that too
 6660   6147   85 0C       		sta	CLSWIDTH 	; okay?
 6661   6149   4C 2C 5F    		jmp	CLS		; now clear the screen
 6662                      	;
 6663                      	; COPY_SCRL - copy from SCR_LINE onto the screen.  CH_OFFSET says how
 6664                      	;	many bytes in SCR_LINE to copy.  FPC is assumed to be pointing
 6665                      	;	to start of screen bytes.  BITTER has the original BITOFF from
 6666                      	;	SETPOS.  ENDBIT shows how many significant bits in last byte.
 6667                      	;
 6668   614C               	COPY_SCRL:
 6669   614C   AE 0C 72    		ldx	SHOW_CURSOR	; are we showing the cursor (ugh)
 6670   614F   F0 03       		beq	COPYL2		; nope
 6671   6151   4C CB 73    		jmp	DO_CURSOR	; then XOR cursor in
 6672   6154               	COPYL2:
 6673   6154   A0 0E       		ldy	#WINBGND	; get background offset
 6674   6156   B1 05       		lda	(WINDOW),Y	; get current background color
 6675   6158   F0 03       		beq	COPY_SCRL1	; if black, ignore this
 6676   615A   20 1B 62    		jsr	FIX_COLOR	; or in the color, please
 6677                      	;
 6678                      	; Alternate entry point for COPY_SCRL, used by picture drawing routine
 6679                      	; to avoid using background color and checking for cursor
 6680                      	;
 6681   615D               	COPY_SCRL1:
 6682   615D   A6 8E       		ldx	FPCBNK		; set up bank
 6683   615F   BD 54 C0    		lda	PAGE2SW,X	; set first bank 
 6684   6162   AD 03 72    		lda	ENDBIT		; did we end evenly?
 6685   6165   D0 02       		bne	COPYL22		; nope
 6686   6167   E6 0F       		inc	CH_OFFSET		; make CH_OFFSET be a counter
 6687   6169               	COPYL22:
 6688   6169   A0 00       		ldy	#0		; zero y
 6689                      	
 6690   616B   A5 0F       		lda	CH_OFFSET		; if only one, then handle real special
 6691   616D   D0 24       		bne	COPYL21		; nope
 6692                      	
 6693   616F   AE 0A 72    		ldx	BITTER		; get starting bit offset
 6694   6172   BD E1 5F    		lda	ST_BITS,X	; get starting bit mask
 6695   6175   85 AC       		sta	IOCHAR		; save it
 6696   6177   AE 03 72    		ldx	ENDBIT		; get ending bit offset
 6697   617A   BD E1 5F    		lda	ST_BITS,X	; combine with ending mask bits
 6698   617D   49 FF       		eor	#$FF		; set for good ones
  Tue Jun 13 1989 11:42                                                                                                  Page   97

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6699   617F   05 AC       		ora	IOCHAR		; set up mask for bits
 6700   6181   31 8C       		and	(FPC),Y		; get me interesting bits
 6701   6183   91 8C       		sta	(FPC),Y		; save
 6702   6185   A5 AC       		lda	IOCHAR		; get flag for data
 6703   6187   49 FF       		eor	#$FF		; flip to get good data
 6704   6189   2D 00 1F    	CPYSM1:	and	SCR_LINE	; pick up my bits
 6705   618C   11 8C       		ora	(FPC),Y		; and or in screen data
 6706   618E   91 8C       		sta	(FPC),Y		; and save it 
 6707   6190   4C 17 62    		jmp	COPYLEX		; go away now
 6708   6193               	COPYL21:
 6709   6193   A5 0F       		lda	CH_OFFSET		; get # of chars
 6710   6195   4A          		lsr	A		; /2 get number in this bank
 6711   6196   69 00       		adc	#0		; pick up carry for first one
 6712   6198   85 10       		sta	DATALOOP	; and save it to work on
 6713                      	
 6714   619A   AE 0A 72    		ldx	BITTER		; do we have a weird start?
 6715   619D   F0 1A       		beq	DLL2		; nope
 6716                      	;
 6717                      	; need to do the first one special
 6718                      	;
 6719   619F   B1 8C       		lda	(FPC),Y		; get byte
 6720   61A1   3D E1 5F    		and	ST_BITS,X	; get masking bits
 6721   61A4   85 AC       		sta	IOCHAR		; save for later
 6722   61A6   BD E1 5F    		lda	ST_BITS,X	; get masking bits again
 6723   61A9   49 FF       		eor	#$FF		; get good bits
 6724   61AB   2D 00 1F    	CPYSM2:	and	SCR_LINE	; get first data byte
 6725   61AE   05 AC       		ora	IOCHAR		; pick up screen bits
 6726   61B0   91 8C       		sta	(FPC),Y		; pointing
 6727   61B2   C8          		iny			; next byte
 6728   61B3   A2 02       		ldx	#2		; start at next one for this bank
 6729   61B5   C6 10       		dec 	DATALOOP	; kount as done
 6730   61B7               	COPYLOOP:
 6731   61B7   F0 0C       		beq	CPYLP2		; all done with this part of line
 6732   61B9               	DLL2:
 6733   61B9   BD 00 1F    	CPYSM3:	lda	SCR_LINE,X	; get data
 6734   61BC   91 8C       		sta	(FPC),Y		; pointing
 6735   61BE   C8          		iny			; next byte
 6736   61BF   E8          		inx			; next one
 6737   61C0   E8          		inx			; next one
 6738   61C1   C6 10       		dec	DATALOOP	; count as used
 6739   61C3   10 F2       		bpl	COPYLOOP	; start loop again
 6740   61C5               	CPYLP2:
 6741   61C5   A0 00       		ldy	#0		; reset Y
 6742   61C7   A5 8E       		lda	FPCBNK		; which bank were we at
 6743   61C9   49 01       		eor	#1		; swap to other one
 6744   61CB   AA          		tax			; make it in x
 6745   61CC   BD 54 C0    		lda	PAGE2SW,X	; swap to write bank
 6746   61CF   8A          		txa			; check which one
 6747   61D0   F0 01       		beq	CPYLP23		; correct offset
 6748   61D2   C8          		iny			; fix offset if going from main to aux
 6749   61D3               	CPYLP23:
 6750   61D3   A2 01       		ldx	#1		; start at second byte in screen line
 6751   61D5   A5 0F       		lda	CH_OFFSET		; get starting number
 6752   61D7   4A          		lsr	A		; /2 to get how many for this bank
 6753   61D8   85 10       		sta	DATALOOP	; and show it
 6754   61DA               	COPYLOOP2:
 6755   61DA   F0 0C       		beq	LINE_DONE	; all done with this part of line
 6756                      	
 6757   61DC   BD 00 1F    	CPYSM4:	lda	SCR_LINE,X	; get data
 6758   61DF   91 8C       		sta	(FPC),Y		; pointing
 6759   61E1   C8          		iny			; next byte
 6760   61E2   E8          		inx			; next one
 6761   61E3   E8          		inx			; next one
 6762   61E4   C6 10       		dec	DATALOOP	; count as used
 6763   61E6   10 F2       		bpl	COPYLOOP2	; start loop again
 6764   61E8               	LINE_DONE:
 6765                      	;
 6766                      	; do the last byte special
 6767                      	;
 6768   61E8   86 10       		stx	DATALOOP	; save pointer
 6769   61EA   AD 03 72    		lda	ENDBIT		; get ending bit offset
 6770   61ED   F0 28       		beq	COPYLEX		; all done if nothing funky
 6771   61EF   46 0F       		lsr	CH_OFFSET	; get line offset
 6772   61F1   48          		pha			; save [A]
 6773   61F2   B0 0B       		bcs	LINED1		; if odd, point at right things
  Tue Jun 13 1989 11:42                                                                                                  Page   98

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6774   61F4   C6 10       		dec	DATALOOP	;  one less then
 6775   61F6   A6 8E       		ldx	FPCBNK		; get original bank
 6776   61F8   BD 54 C0    		lda	PAGE2SW,X	; switch to it
 6777   61FB   8A          		txa			; which bank did we do?
 6778   61FC   D0 01       		bne	LINED1		; no need to step back one
 6779   61FE   88          		dey			; point one less here too
 6780   61FF               	LINED1:
 6781   61FF   68          		pla			; get ENDBIT back
 6782   6200   AA          		tax			; make end bits be index
 6783   6201   BD E1 5F    		lda	ST_BITS,X	; get end mask
 6784   6204   85 AC       		sta	IOCHAR		; save mask bits
 6785   6206   49 FF       		eor	#$FF		; toggle every bit
 6786   6208   31 8C       		and	(FPC),Y		; get the interesting bits in byte
 6787   620A   91 8C       		sta	(FPC),Y		; save it
 6788   620C   A6 10       		ldx	DATALOOP	; get data pointer
 6789   620E   BD 00 1F    	CPYSM5:	lda	SCR_LINE,X	; turn on my bits
 6790   6211   25 AC       		and	IOCHAR		; pick up my good bits
 6791   6213   11 8C       		ora	(FPC),Y		; bring everything together
 6792   6215   91 8C       		sta	(FPC),Y		; save the byte
 6793   6217               	COPYLEX:
 6794   6217   AD 54 C0    		lda	PAGE2SW+MAIN	; back to main, thanks
 6795   621A   60          		rts
 6796                      	
 6797   621B               	FIX_COLOR:
 6798   621B   E6 0F       	        inc     CH_OFFSET       ; just to make checking easier for now
 6799                      	
 6800   621D   0A          		asl	A		; *2
 6801   621E   0A          		asl	A		; *4 to get correct offset
 6802   621F   69 12       		adc	#<COLORS	; add start of table
 6803   6221   85 AD       		sta	COLORP+LO	; save for pointer
 6804   6223   A9 03       		lda	#>COLORS	; get hi part
 6805   6225   69 00       		adc	#0		; pick up maybe carry
 6806   6227   85 AE       		sta	COLORP+HI	; save pointer
 6807   6229   A2 11       	        ldx     #$11            ; ORA (),Y opcode
 6808   622B   A0 0D       	        ldy     #WINFORE        ; check foreground color
 6809   622D   B1 05       	        lda     (WINDOW),Y      ; check what color
 6810   622F   D0 11       	        bne     FIXC1           ; just leave white if not black
 6811   6231   A2 00       	        ldx     #0              ; start at beginning
 6812   6233               	FIXMUNGEL:
 6813   6233   BD 00 1F    	        lda     SCR_LINE,X      ; get byte
 6814   6236   49 FF       	        eor     #$FF            ; swap all the bits
 6815   6238   9D 00 1F    	        sta     SCR_LINE,X      ; store back
 6816   623B   E8          	        inx                     ; count it
 6817   623C   E4 0F       	        cpx     CH_OFFSET       ; done?
 6818   623E   90 F3       	        bcc     FIXMUNGEL       ; nope
 6819   6240   A2 31       	        ldx     #$31            ; AND (),Y opcode
 6820   6242               	FIXC1:
 6821   6242   8E 50 62    	        stx     FCLM            ; self mod my code (again . . . sigh)
 6822   6245   AD 0A 72    		lda	BITTER		; get starting offset
 6823   6248   29 03       		and	#3		; pick up wrap
 6824   624A   A8          		tay			; make index
 6825   624B   A2 00       		ldx	#0		; start at zero line
 6826   624D               	FIXLOOP:
 6827   624D   BD 00 1F    	FCM1:	lda	SCR_LINE,X	; get screen byte
 6828   6250   11 AD       	FCLM:	ora	(COLORP),Y	; or with color byte
 6829   6252   9D 00 1F    	FCM2:	sta	SCR_LINE,X	; save it
 6830   6255   C8          		iny			; next color byte
 6831   6256   C0 04       		cpy	#4		; wrapped?
 6832   6258   D0 02       		bne	FIXLP1		; nope
 6833   625A   A0 00       		ldy	#0		; restart
 6834   625C               	FIXLP1:
 6835   625C   E8          		inx			; next screen byte
 6836   625D   E4 0F       		cpx	CH_OFFSET	; done yet?
 6837   625F   90 EC       	        bcc     FIXLOOP         ; nope
 6838   6261               	        
 6839   6261   C6 0F       	        dec     CH_OFFSET       ; fix counter
 6840   6263   60          		rts			; now we are done
 6841                      	;
 6842                      	; MSCURS - Erase the cursor from the old spot and write it in the
 6843                      	;  new spot
 6844                      	;
 6845   6264   8C          	MOLDX:	db	MAXWIDTH	; spot to save x,y of mouse
 6846   6265   C0          	MOLDY:	db	MAXHEIGHT
 6847   6266               	MSCCNT:	ds	1
 6848   6267               	SVCURS:	ds	CURSW*CURSH	; save room
  Tue Jun 13 1989 11:42                                                                                                  Page   99

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6849   626F   01          	MSWCNT:	db	1
 6850   6270   00          	MSSTATE: db	0		; 0 == off, 1 == on
 6851   6271   0F 07 07 07 07 	MSCOLOR: db	$f,7,7,7,7,7,7,7
        6276   07 07 07 
 6852                      	;
 6853   6279               	MSCURS:
 6854   6279   A9 00       		lda	#0		; clear moved flag
 6855   627B   8D 12 03    		sta	MSMOVEF		; we did
 6856   627E   20 84 62    		jsr	MSCOFF		; turn cursor off at current pos
 6857   6281   4C E3 62    		jmp	MSCON		; and turn it on in new spot
 6858                      	
 6859                      	;
 6860                      	; MSCOFF - mouse cursor off
 6861                      	;	Copy info from saved spot back onto screen @ MOLDX, MOLDY
 6862   6284               	MSCOFF:
 6863   6284   AD 70 62    	        lda     MSSTATE         ; already off?
 6864   6287   D0 01       	        bne     MSCOFF1         ; no
 6865   6289   60          	        rts                     ; done then
 6866   628A               	MSCOFF1:
 6867   628A   A5 01       		lda	SCRCY		; save X,Y
 6868   628C   8D A7 5D    		sta	SAVECY
 6869   628F   A5 00       		lda	SCRCX
 6870   6291   8D A8 5D    		sta	SAVECX
 6871   6294   AD 64 62    		lda	MOLDX		; point to old X,Y
 6872   6297   85 00       		sta	SCRCX
 6873   6299   AD 65 62    		lda	MOLDY
 6874   629C   85 01       		sta	SCRCY
 6875   629E   A9 00       		lda	#0		; start at beginning of saved area
 6876   62A0   8D 66 62    		sta	MSCCNT		; save counter
 6877   62A3   A9 02       		lda	#CURSW		; restore width
 6878   62A5   8D 6F 62    		sta	MSWCNT		; and counter
 6879   62A8               	RENEWL:
 6880   62A8   A5 01       		lda	SCRCY		; check bounds
 6881   62AA   C9 C0       		cmp	#MAXHEIGHT
 6882   62AC   B0 32       		bcs	MSC1		; all done
 6883   62AE               	RENEWL0:
 6884   62AE   A5 00       		lda	SCRCX
 6885   62B0   C9 8C       		cmp	#MAXWIDTH
 6886   62B2   B0 1E       		bcs	RENEWL1		; might not be done
 6887   62B4   20 37 5E    	        jsr     GET_NYBBLE      ; get screen nybble
 6888   62B7   AE 66 62    		ldx	MSCCNT		; get counter
 6889                      	;        eor     MSCOLOR,X       ; xor to turn off
 6890   62BA   49 0F       	        eor     #$0F            ; turn white/black
 6891   62BC   20 CD 5D    		jsr	PUT_NYBBLE	; save nybble
 6892   62BF   EE 66 62    		inc	MSCCNT		; point to next one
 6893   62C2   AD 66 62    		lda	MSCCNT		; get counter
 6894   62C5   C9 08       		cmp	#(CURSW*CURSH)	; done yet?
 6895   62C7   F0 17       		beq	MSC1		; yup
 6896   62C9   CE 6F 62    		dec	MSWCNT		; count down one width
 6897   62CC   F0 04       		beq	RENEWL1		; it is
 6898   62CE   E6 00       		inc	SCRCX		; next x
 6899   62D0   D0 DC       		bne	RENEWL0		; try again
 6900   62D2               	RENEWL1:
 6901   62D2   AD 64 62    		lda	MOLDX		; reset X
 6902   62D5   85 00       		sta	SCRCX
 6903   62D7   A9 02       		lda	#CURSW		; restore width
 6904   62D9   8D 6F 62    		sta	MSWCNT		; and counter
 6905   62DC   E6 01       		inc	SCRCY		; next y
 6906   62DE   D0 C8       		bne	RENEWL		; okay try some more
 6907   62E0               	MSC1:
 6908   62E0   4C 42 63    		jmp 	MSCON4		; done turning it off
 6909                      	;
 6910                      	; MSCON - turn mouse cursor on
 6911                      	;	Copy white pixels into area specified by MSX, MSY
 6912                      	;
 6913   62E3               	MSCON:
 6914   62E3   AD 70 62    	        lda     MSSTATE         ; already on?
 6915   62E6   F0 01       	        beq     MSCON0          ; no
 6916   62E8   60          	        rts                     ; don't bother
 6917   62E9               	MSCON0:
 6918   62E9   A5 01       		lda	SCRCY		; save X,Y
 6919   62EB   8D A7 5D    		sta	SAVECY
 6920   62EE   A5 00       		lda	SCRCX
 6921   62F0   8D A8 5D    		sta	SAVECX
 6922                      	
  Tue Jun 13 1989 11:42                                                                                                  Page  100

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- APPLE ][ SCREEN STUFF ---"

 6923   62F3   A5 CB       		lda	MSX		; get mouse x
 6924   62F5   85 00       		sta	SCRCX		; set mouse X
 6925   62F7   8D 64 62    		sta	MOLDX		; save mouse x
 6926   62FA   A5 CC       		lda	MSY		; get mouse y
 6927   62FC   85 01       		sta	SCRCY		; set mouse Y
 6928   62FE   8D 65 62    		sta	MOLDY		; and mouse Y
 6929   6301   A9 00       		lda	#0		; start at beginning of saved area
 6930   6303   8D 66 62    		sta	MSCCNT		; save counter
 6931   6306   A9 02       		lda	#CURSW		; restore width
 6932   6308   8D 6F 62    		sta	MSWCNT		; and counter
 6933   630B               	MSCON1:
 6934   630B   A5 01       		lda	SCRCY		; check bounds
 6935   630D   C9 C0       		cmp	#MAXHEIGHT
 6936   630F   B0 31       		bcs	MSCON4		; all done
 6937   6311               	MSCON2:
 6938   6311   A5 00       		lda	SCRCX
 6939   6313   C9 8C       		cmp	#MAXWIDTH
 6940   6315   B0 1E       		bcs	MSCON3		; might not be done
 6941   6317   20 37 5E    		jsr	GET_NYBBLE	; save nybble
 6942   631A   AE 66 62    	 	ldx	MSCCNT		; get counter
 6943                      	;	eor	MSCOLOR,X	; get cursor color
 6944   631D   49 0F       	        eor     #$0F            ; turn white/black
 6945   631F   20 CD 5D    		jsr	PUT_NYBBLE	; put nybble
 6946   6322   EE 66 62    		inc	MSCCNT		; point to next one
 6947   6325   AD 66 62    		lda	MSCCNT		; check ending
 6948   6328   C9 08       		cmp	#(CURSW*CURSH)	; done yet?
 6949   632A   F0 16       		beq	MSCON4		; yup
 6950   632C   CE 6F 62    		dec	MSWCNT		; count down one width
 6951   632F   F0 04       		beq	MSCON3		; finished for line
 6952   6331   E6 00       		inc	SCRCX		; next x
 6953   6333   D0 DC       		bne	MSCON2		; try again
 6954   6335               	MSCON3:
 6955   6335   A5 CB       		lda	MSX		; reset X
 6956   6337   85 00       		sta	SCRCX
 6957   6339   A9 02       		lda	#CURSW		; restore width
 6958   633B   8D 6F 62    		sta	MSWCNT		; and counter
 6959   633E   E6 01       		inc	SCRCY		; next y
 6960   6340   D0 C9       		bne	MSCON1		; okay try some more
 6961   6342               	MSCON4:
 6962   6342   AD 70 62    	        lda     MSSTATE         ; get current state
 6963   6345   49 01       	        eor     #$01            ; toggle it
 6964   6347   8D 70 62    	        sta     MSSTATE         ; bang
 6965   634A   AD A8 5D    		lda	SAVECX		; restore X,Y
 6966   634D   85 00       		sta	SCRCX
 6967   634F   AD A7 5D    		lda	SAVECY
 6968   6352   85 01       		sta	SCRCY
 6969   6354   60          		rts	
 6970   6355               		
 6971                      	
 6972   6355               		END
 6973                      	
 6974   6355               		INCLUDE		TABLES.ASM
 6975   6355               		STTL	"--- ZIP DATA TABLES ---"
 6976                      		PAGE
  Tue Jun 13 1989 11:42                                                                                                  Page  101

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

 6977   6355               	CHADR_H:
 6978   6355   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        635A   00 00 00 00 00 
        635F   00 00 00 00 00 
        6364   00 
 6979   6365   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        636A   00 00 00 00 00 
        636F   00 00 00 00 00 
        6374   00 
 6980   6375   64 64 64 64 65 		db	>C20,>C21,>C22,>C23,>C24,>C25,>C26,>C27
        637A   65 65 65 
 6981   637D   65 65 65 65 65 		DB	>C28,>C29,>C2A,>C2B,>C2C,>C2D,>C2E,>C2F
        6382   65 65 65 
 6982   6385   65 65 65 65 65 		db	>C30,>C31,>C32,>C33,>C34,>C35,>C36,>C37
        638A   65 66 66 
 6983   638D   66 66 66 66 66 		DB	>C38,>C39,>C3A,>C3B,>C3C,>C3D,>C3E,>C3F
        6392   66 66 66 
 6984   6395   66 66 66 66 66 		db	>C40,>C41,>C42,>C43,>C44,>C45,>C46,>C47
        639A   66 66 66 
 6985   639D   67 67 67 67 67 		DB	>C48,>C49,>C4A,>C4B,>C4C,>C4D,>C4E,>C4F
        63A2   67 67 67 
 6986   63A5   67 67 67 67 67 		db	>C50,>C51,>C52,>C53,>C54,>C55,>C56,>C57
        63AA   67 67 68 
 6987   63AD   68 68 68 68 68 		DB	>C58,>C59,>C5A,>C5B,>C5C,>C5D,>C5E,>C5F
        63B2   68 68 68 
 6988   63B5   68 68 68 68 68 		db	>C60,>C61,>C62,>C63,>C64,>C65,>C66,>C67
        63BA   68 68 68 
 6989   63BD   69 69 69 69 69 		DB	>C68,>C69,>C6A,>C6B,>C6C,>C6D,>C6E,>C6F
        63C2   69 69 69 
 6990   63C5   69 69 69 69 69 		db	>C70,>C71,>C72,>C73,>C74,>C75,>C76,>C77
        63CA   69 69 69 
 6991   63CD   69 6A 6A 6A 6A 		DB	>C78,>C79,>C7A,>C7B,>C7C,>C7D,>C7E
        63D2   6A 6A 
 6992   63D4               	CHADR_L:
 6993   63D4   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        63D9   00 00 00 00 00 
        63DE   00 00 00 00 00 
        63E3   00 
 6994   63E4   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        63E9   00 00 00 00 00 
        63EE   00 00 00 00 00 
        63F3   00 
 6995   63F4   D2 E4 ED FF 11 		db	<C20,<C21,<C22,<C23,<C24,<C25,<C26,<C27
        63F9   23 35 47 
 6996   63FC   50 59 62 6B 7D 		DB	<C28,<C29,<C2A,<C2B,<C2C,<C2D,<C2E,<C2F
        6401   86 8F 98 
 6997   6404   AA BC C5 D7 E9 		db	<C30,<C31,<C32,<C33,<C34,<C35,<C36,<C37
        6409   FB 0D 1F 
 6998   640C   28 3A 4C 55 5E 		DB	<C38,<C39,<C3A,<C3B,<C3C,<C3D,<C3E,<C3F
        6411   67 70 79 
 6999   6414   8B 9D AF C1 D3 		db	<C40,<C41,<C42,<C43,<C44,<C45,<C46,<C47
        6419   E5 EE F7 
 7000   641C   09 1B 24 36 48 		DB	<C48,<C49,<C4A,<C4B,<C4C,<C4D,<C4E,<C4F
        6421   51 63 75 
 7001   6424   87 99 AB BD CF 		db	<C50,<C51,<C52,<C53,<C54,<C55,<C56,<C57
        6429   E1 F3 05 
 7002   642C   17 29 3B 4D 56 		DB	<C58,<C59,<C5A,<C5B,<C5C,<C5D,<C5E,<C5F
        6431   68 71 83 
 7003   6434   8C 95 A7 B9 CB 		db	<C60,<C61,<C62,<C63,<C64,<C65,<C66,<C67
        6439   DD EF F8 
 7004   643C   0A 1C 25 2E 40 		DB	<C68,<C69,<C6A,<C6B,<C6C,<C6D,<C6E,<C6F
        6441   49 5B 6D 
 7005   6444   7F 91 A3 AC BE 		db	<C70,<C71,<C72,<C73,<C74,<C75,<C76,<C77
        6449   C7 D9 EB 
 7006   644C   FD 0F 21 33 3C 		DB	<C78,<C79,<C7A,<C7B,<C7C,<C7D,<C7E
        6451   45 4E 
 7007                      	
 7008   6453               	CHWID:
 7009   6453   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        6458   00 00 00 00 00 
        645D   00 00 00 00 00 
        6462   00 
 7010   6463   00 00 00 00 00 		db	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        6468   00 00 00 00 00 
        646D   00 00 00 00 00 
  Tue Jun 13 1989 11:42                                                                                                  Page  102

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6472   00 
 7011   6473   08 06 0A 0D 0D 		db	8,6,10,13,13,14,12,5,7,7,9,10,6,9,5,10
        6478   0E 0C 05 07 07 
        647D   09 0A 06 09 05 
        6482   0A 
 7012   6483   0B 07 0A 0A 0D 		db	11,7,10,10,13,10,11,9,11,11,5,6,9,9,9,11,16,11,11,11,11
        6488   0A 0B 09 0B 0B 
        648D   05 06 09 09 09 
        6492   0B 10 0B 0B 0B 
        6497   0B 
 7013   6498   09 09 0B 0B 05 		db	9,9,11,11,5,11,12,9,15,13,11,11,11,11,11,11,11,11
        649D   0B 0C 09 0F 0D 
        64A2   0B 0B 0B 0B 0B 
        64A7   0B 0B 0B 
 7014   64AA   10 0B 0B 0B 09 		db	16,11,11,11,9,11,9,11,9,7,11,11,11,11,11,9,11,11,6,9,11,6
        64AF   0B 09 0B 09 07 
        64B4   0B 0B 0B 0B 0B 
        64B9   09 0B 0B 06 09 
        64BE   0B 06 
 7015   64C0   0F 0B 0B 0B 0B 		db	15,11,11,11,11,9,10,9,11,11,15,11,11,11,9,6,9,12
        64C5   09 0A 09 0B 0B 
        64CA   0F 0B 0B 0B 09 
        64CF   06 09 0C 
 7016                      	
 7017                      		RADIX	H				; make everything be hex
 7018          64D2        	CHAR_TABLE	EQU	*
 7019   64D2   00 00 00 00 00 	C20	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 ;(SPACE)
        64D7   00 00 00 00 00 
        64DC   00 00 00 00 00 
        64E1   00 00 00 
 7020   64E4   78 78 78 78 78 	C21	DB	78,78,78,78,78,00,78,00,00 ;! 5
        64E9   00 78 00 00 
 7021   64ED   73 80 73 80 73 	C22	DB	73,80,73,80,73,80,00,00,00,00,00,00,00,00,00,00,00,00 ;" 9
        64F2   80 00 00 00 00 
        64F7   00 00 00 00 00 
        64FC   00 00 00 
 7022   64FF   39 C0 FF F0 39 	C23	DB	39,c0,ff,f0,39,c0,39,c0,ff,f0,39,c0,00,00,00,00,00,00 ;# 12
        6504   C0 39 C0 FF F0 
        6509   39 C0 00 00 00 
        650E   00 00 00 
 7023   6511   06 00 7F E0 E6 	C24	DB	06,00,7f,e0,e6,00,7f,e0,06,70,7f,e0,06,00,00,00,00,00 ;$ 12
        6516   00 7F E0 06 70 
        651B   7F E0 06 00 00 
        6520   00 00 00 
 7024   6523   78 E0 CD C0 7B 	C25	DB	78,e0,cd,c0,7b,80,07,00,0e,f0,1d,98,38,f0,00,00,00,00 ;% 13
        6528   80 07 00 0E F0 
        652D   1D 98 38 F0 00 
        6532   00 00 00 
 7025   6535   7F 00 E3 80 E0 	C26	DB	7f,00,e3,80,e0,00,78,00,e0,e0,e1,c0,7f,80,00,00,00,00 ;& 11
        653A   00 78 00 E0 E0 
        653F   E1 C0 7F 80 00 
        6544   00 00 00 
 7026   6547   70 70 70 00 00 	C27	DB	70,70,70,00,00,00,00,00,00 ;' 4
        654C   00 00 00 00 
 7027   6550   1C 38 70 70 70 	C28	DB	1c,38,70,70,70,38,1c,00,00 ;( 6
        6555   38 1C 00 00 
 7028   6559   70 38 1C 1C 1C 	C29	DB	70,38,1c,1c,1c,38,70,00,00 ;) 6
        655E   38 70 00 00 
 7029   6562   DB 3C FF 3C DB 	C2A	DB	db,3c,ff,3c,db,00,00,00,00 ;* 8
        6567   00 00 00 00 
 7030   656B   1C 00 1C 00 FF 	C2B	DB	1c,00,1c,00,ff,80,1c,00,1c,00,00,00,00,00,00,00,00,00 ;+ 9
        6570   80 1C 00 1C 00 
        6575   00 00 00 00 00 
        657A   00 00 00 
 7031   657D   00 00 00 00 00 	C2C	DB	00,00,00,00,00,38,38,18,70 ;, 5
        6582   38 38 18 70 
 7032   6586   00 00 00 FF 00 	C2D	DB	00,00,00,ff,00,00,00,00,00 ;- 8
        658B   00 00 00 00 
 7033   658F   00 00 00 00 00 	C2E	DB	00,00,00,00,00,70,70,00,00 ;. 4
        6594   70 70 00 00 
 7034   6598   03 80 07 00 0E 	C2F	DB	03,80,07,00,0e,00,1c,00,38,00,70,00,e0,00,00,00,00,00 ;/ 9
        659D   00 1C 00 38 00 
        65A2   70 00 E0 00 00 
        65A7   00 00 00 
 7035   65AA   1F 00 3B 80 71 	C30	DB	1f,00,3b,80,71,c0,71,c0,71,c0,3b,80,1f,00,00,00,00,00 ;0 10
  Tue Jun 13 1989 11:42                                                                                                  Page  103

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        65AF   C0 71 C0 71 C0 
        65B4   3B 80 1F 00 00 
        65B9   00 00 00 
 7036   65BC   1C 7C 1C 1C 1C 	C31	DB	1c,7c,1c,1c,1c,1c,1c,00,00 ;1 6
        65C1   1C 1C 00 00 
 7037   65C5   3F 00 63 80 06 	C32	DB	3f,00,63,80,06,80,0e,00,1c,00,70,00,7f,80,00,00,00,00 ;2 9
        65CA   80 0E 00 1C 00 
        65CF   70 00 7F 80 00 
        65D4   00 00 00 
 7038   65D7   7F 80 03 00 06 	C33	DB	7f,80,03,00,06,00,1f,00,03,80,63,80,3f,00,00,00,00,00 ;3 9
        65DC   00 1F 00 03 80 
        65E1   63 80 3F 00 00 
        65E6   00 00 00 
 7039   65E9   07 C0 0F C0 1D 	C34	DB	07,c0,0f,c0,1d,c0,39,c0,71,c0,7f,f0,01,c0,00,00,00,00 ;4 12
        65EE   C0 39 C0 71 C0 
        65F3   7F F0 01 C0 00 
        65F8   00 00 00 
 7040   65FB   7F 80 78 00 78 	C35	DB	7f,80,78,00,78,00,7f,00,03,80,63,80,3f,00,00,00,00,00 ;5 9
        6600   00 7F 00 03 80 
        6605   63 80 3F 00 00 
        660A   00 00 00 
 7041   660D   1F 80 38 00 70 	C36	DB	1f,80,38,00,70,00,7f,80,71,c0,71,c0,3f,80,00,00,00,00 ;6 10
        6612   00 7F 80 71 C0 
        6617   71 C0 3F 80 00 
        661C   00 00 00 
 7042   661F   7F 07 07 0E 1C 	C37	DB	7f,07,07,0e,1c,1c,1c,00,00 ;7 8
        6624   1C 1C 00 00 
 7043   6628   3F 80 71 C0 71 	C38	DB	3f,80,71,c0,71,c0,3f,80,71,c0,71,c0,3f,80,00,00,00,00 ;8 10
        662D   C0 3F 80 71 C0 
        6632   71 C0 3F 80 00 
        6637   00 00 00 
 7044   663A   3F 80 71 C0 71 	C39	DB	3f,80,71,c0,71,c0,3f,c0,01,c0,03,80,3f,00,00,00,00,00 ;9 10
        663F   C0 3F C0 01 C0 
        6644   03 80 3F 00 00 
        6649   00 00 00 
 7045   664C   00 00 70 70 00 	C3A	DB	00,00,70,70,00,70,70,00,00 ;: 4
        6651   70 70 00 00 
 7046   6655   00 00 38 38 00 	C3B	DB	00,00,38,38,00,38,38,18,70 ;; 5
        665A   38 38 18 70 
 7047   665E   00 0E 38 E0 38 	C3C	DB	00,0e,38,e0,38,0e,00,00,00 ;< 8
        6663   0E 00 00 00 
 7048   6667   00 00 7F 00 7F 	C3D	DB	00,00,7f,00,7f,00,00,00,00 ;= 8
        666C   00 00 00 00 
 7049   6670   00 70 1C 07 1C 	C3E	DB	00,70,1c,07,1c,70,00,00,00 ;> 8
        6675   70 00 00 00 
 7050   6679   3F 80 71 C0 03 	C3F	DB	3f,80,71,c0,03,80,0e,00,0e,00,00,00,0e,00,00,00,00,00 ;? 10
        667E   80 0E 00 0E 00 
        6683   00 00 0E 00 00 
        6688   00 00 00 
 7051   668B   1F F8 E0 0E E3 	C40	DB	1f,f8,e0,0e,e3,e7,e6,77,e6,77,e3,bc,e0,00,1f,f8,00,00 ;@ 16
        6690   E7 E6 77 E6 77 
        6695   E3 BC E0 00 1F 
        669A   F8 00 00 
 7052   669D   3F 80 71 C0 71 	C41	DB	3f,80,71,c0,71,c0,7f,c0,71,c0,71,c0,71,c0,00,00,00,00 ;A 10
        66A2   C0 7F C0 71 C0 
        66A7   71 C0 71 C0 00 
        66AC   00 00 00 
 7053   66AF   7F 80 71 C0 71 	C42	DB	7f,80,71,c0,71,c0,7f,00,71,c0,71,c0,7f,80,00,00,00,00 ;B 10
        66B4   C0 7F 00 71 C0 
        66B9   71 C0 7F 80 00 
        66BE   00 00 00 
 7054   66C1   3F 80 71 C0 70 	C43	DB	3f,80,71,c0,70,00,70,00,70,00,71,c0,3f,80,00,00,00,00 ;C 10
        66C6   00 70 00 70 00 
        66CB   71 C0 3F 80 00 
        66D0   00 00 00 
 7055   66D3   7F 80 71 C0 71 	C44	DB	7f,80,71,c0,71,c0,71,c0,71,c0,71,c0,7f,80,00,00,00,00 ;D 10
        66D8   C0 71 C0 71 C0 
        66DD   71 C0 7F 80 00 
        66E2   00 00 00 
 7056   66E5   7F 70 70 7F 70 	C45	DB	7f,70,70,7f,70,70,7f,00,00 ;E 8
        66EA   70 7F 00 00 
 7057   66EE   7F 70 70 7E 70 	C46	DB	7f,70,70,7e,70,70,70,00,00 ;F 8
        66F3   70 70 00 00 
 7058   66F7   3F 80 71 C0 70 	C47	DB	3f,80,71,c0,70,00,73,c0,71,c0,71,c0,3f,80,00,00,00,00 ;G 10
        66FC   00 73 C0 71 C0 
  Tue Jun 13 1989 11:42                                                                                                  Page  104

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6701   71 C0 3F 80 00 
        6706   00 00 00 
 7059   6709   71 C0 71 C0 71 	C48	DB	71,c0,71,c0,71,c0,7f,c0,71,c0,71,c0,71,c0,00,00,00,00 ;H 10
        670E   C0 7F C0 71 C0 
        6713   71 C0 71 C0 00 
        6718   00 00 00 
 7060   671B   70 70 70 70 70 	C49	DB	70,70,70,70,70,70,70,00,00 ;I 4
        6720   70 70 00 00 
 7061   6724   01 C0 01 C0 01 	C4A	DB	01,c0,01,c0,01,c0,01,c0,71,c0,71,c0,3f,80,00,00,00,00 ;J 10
        6729   C0 01 C0 71 C0 
        672E   71 C0 3F 80 00 
        6733   00 00 00 
 7062   6736   70 E0 71 C0 73 	C4B	DB	70,e0,71,c0,73,80,7f,00,73,80,71,c0,70,e0,00,00,00,00 ;K 11
        673B   80 7F 00 73 80 
        6740   71 C0 70 E0 00 
        6745   00 00 00 
 7063   6748   70 70 70 70 70 	C4C	DB	70,70,70,70,70,70,7f,00,00 ;L 8
        674D   70 7F 00 00 
 7064   6751   78 3C 7C 7C 7E 	C4D	DB	78,3c,7c,7c,7e,fc,77,dc,73,9c,70,1c,70,1c,00,00,00,00 ;M 14
        6756   FC 77 DC 73 9C 
        675B   70 1C 70 1C 00 
        6760   00 00 00 
 7065   6763   78 70 7C 70 7E 	C4E	DB	78,70,7c,70,7e,70,77,70,73,f0,71,f0,70,f0,00,00,00,00 ;N 12
        6768   70 77 70 73 F0 
        676D   71 F0 70 F0 00 
        6772   00 00 00 
 7066   6775   3F 80 71 C0 71 	C4F	DB	3f,80,71,c0,71,c0,71,c0,71,c0,71,c0,3f,80,00,00,00,00 ;O 10
        677A   C0 71 C0 71 C0 
        677F   71 C0 3F 80 00 
        6784   00 00 00 
 7067   6787   7F 80 71 C0 71 	C50	DB	7f,80,71,c0,71,c0,7f,80,70,00,70,00,70,00,00,00,00,00 ;P 10
        678C   C0 7F 80 70 00 
        6791   70 00 70 00 00 
        6796   00 00 00 
 7068   6799   3F 80 71 C0 71 	C51	DB	3f,80,71,c0,71,c0,71,c0,71,c0,71,c0,3f,00,03,c0,00,00 ;Q 10
        679E   C0 71 C0 71 C0 
        67A3   71 C0 3F 00 03 
        67A8   C0 00 00 
 7069   67AB   7F 80 71 C0 71 	C52	DB	7f,80,71,c0,71,c0,7f,00,71,c0,71,c0,71,c0,00,00,00,00 ;R 10
        67B0   C0 7F 00 71 C0 
        67B5   71 C0 71 C0 00 
        67BA   00 00 00 
 7070   67BD   3F 80 71 C0 78 	C53	DB	3f,80,71,c0,78,00,1f,00,03,c0,71,c0,3f,80,00,00,00,00 ;S 10
        67C2   00 1F 00 03 C0 
        67C7   71 C0 3F 80 00 
        67CC   00 00 00 
 7071   67CF   7F C0 0E 00 0E 	C54	DB	7f,c0,0e,00,0e,00,0e,00,0e,00,0e,00,0e,00,00,00,00,00 ;T 10
        67D4   00 0E 00 0E 00 
        67D9   0E 00 0E 00 00 
        67DE   00 00 00 
 7072   67E1   71 C0 71 C0 71 	C55	DB	71,c0,71,c0,71,c0,71,c0,71,c0,71,c0,1f,00,00,00,00,00 ;U 10
        67E6   C0 71 C0 71 C0 
        67EB   71 C0 1F 00 00 
        67F0   00 00 00 
 7073   67F3   71 C0 71 C0 71 	C56	DB	71,c0,71,c0,71,c0,71,c0,73,80,77,00,7e,00,00,00,00,00 ;V 10
        67F8   C0 71 C0 73 80 
        67FD   77 00 7E 00 00 
        6802   00 00 00 
 7074   6805   71 C7 71 C7 71 	C57	DB	71,c7,71,c7,71,c7,71,c7,71,c7,71,dc,7f,f8,00,00,00,00 ;W 16
        680A   C7 71 C7 71 C7 
        680F   71 DC 7F F8 00 
        6814   00 00 00 
 7075   6817   71 C0 71 C0 71 	C58	DB	71,c0,71,c0,71,c0,1f,00,71,c0,71,c0,71,c0,00,00,00,00 ;X 10
        681C   C0 1F 00 71 C0 
        6821   71 C0 71 C0 00 
        6826   00 00 00 
 7076   6829   71 C0 71 C0 71 	C59	DB	71,c0,71,c0,71,c0,3f,80,0e,00,0e,00,0e,00,00,00,00,00 ;Y 10
        682E   C0 3F 80 0E 00 
        6833   0E 00 0E 00 00 
        6838   00 00 00 
 7077   683B   7F C0 01 C0 03 	C5A	DB	7f,c0,01,c0,03,80,0e,00,38,00,70,00,7f,c0,00,00,00,00 ;Z 10
        6840   80 0E 00 38 00 
        6845   70 00 7F C0 00 
        684A   00 00 00 
 7078   684D   7F 70 70 70 70 	C5B	DB	7f,70,70,70,70,70,7f,00,00 ;[ 8
  Tue Jun 13 1989 11:42                                                                                                  Page  105

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6852   70 7F 00 00 
 7079   6856   70 00 38 00 1C 	C5C	DB	70,00,38,00,1c,00,0e,00,07,00,03,80,01,c0,00,00,00,00 ;\ 10
        685B   00 0E 00 07 00 
        6860   03 80 01 C0 00 
        6865   00 00 00 
 7080   6868   7F 07 07 07 07 	C5D	DB	7f,07,07,07,07,07,7f,00,00 ;] 8
        686D   07 7F 00 00 
 7081   6871   00 00 0C 00 3F 	C5E	DB	00,00,0c,00,3f,00,e1,c0,00,00,00,00,00,00,00,00,00,00 ;^ 10
        6876   00 E1 C0 00 00 
        687B   00 00 00 00 00 
        6880   00 00 00 
 7082   6883   00 00 00 00 00 	C5F	DB	00,00,00,00,00,00,00,ff,00 ;_ 8
        6888   00 00 FF 00 
 7083   688C   70 38 1C 00 00 	C60	DB	70,38,1c,00,00,00,00,00,00 ;` 6
        6891   00 00 00 00 
 7084   6895   00 00 00 00 3F 	C61	DB	00,00,00,00,3f,80,01,c0,3f,c0,71,c0,3f,c0,00,00,00,00 ;a 10
        689A   80 01 C0 3F C0 
        689F   71 C0 3F C0 00 
        68A4   00 00 00 
 7085   68A7   70 00 70 00 7F 	C62	DB	70,00,70,00,7f,80,71,c0,71,c0,71,c0,7f,80,00,00,00,00 ;b 10
        68AC   80 71 C0 71 C0 
        68B1   71 C0 7F 80 00 
        68B6   00 00 00 
 7086   68B9   00 00 00 00 3F 	C63	DB	00,00,00,00,3f,80,71,c0,70,00,71,c0,3f,80,00,00,00,00 ;c 10
        68BE   80 71 C0 70 00 
        68C3   71 C0 3F 80 00 
        68C8   00 00 00 
 7087   68CB   01 C0 01 C0 3F 	C64	DB	01,c0,01,c0,3f,c0,71,c0,71,c0,71,c0,3f,c0,00,00,00,00 ;d 10
        68D0   C0 71 C0 71 C0 
        68D5   71 C0 3F C0 00 
        68DA   00 00 00 
 7088   68DD   00 00 00 00 3F 	C65	DB	00,00,00,00,3f,80,79,c0,7f,c0,70,00,3f,80,00,00,00,00 ;e 10
        68E2   80 79 C0 7F C0 
        68E7   70 00 3F 80 00 
        68EC   00 00 00 
 7089   68EF   0F 1C 7F 1C 1C 	C66	DB	0f,1c,7f,1c,1c,1c,1c,00,00 ;f 8
        68F4   1C 1C 00 00 
 7090   68F8   00 00 00 00 3F 	C67	DB	00,00,00,00,3f,c0,71,c0,71,c0,71,c0,3f,c0,01,c0,3f,80 ;g 10
        68FD   C0 71 C0 71 C0 
        6902   71 C0 3F C0 01 
        6907   C0 3F 80 
 7091   690A   70 00 70 00 7F 	C68	DB	70,00,70,00,7f,80,71,c0,71,c0,71,c0,71,c0,00,00,00,00 ;h 10
        690F   80 71 C0 71 C0 
        6914   71 C0 71 C0 00 
        6919   00 00 00 
 7092   691C   70 00 70 70 70 	C69	DB	70,00,70,70,70,70,70,00,00 ;i 5
        6921   70 70 00 00 
 7093   6925   0E 00 0E 0E 0E 	C6A	DB	0e,00,0e,0e,0e,0e,0e,0e,7c ;j 8
        692A   0E 0E 0E 7C 
 7094   692E   70 00 70 00 71 	C6B	DB	70,00,70,00,71,c0,73,80,7f,00,73,80,71,c0,00,00,00,00 ;k 10
        6933   C0 73 80 7F 00 
        6938   73 80 71 C0 00 
        693D   00 00 00 
 7095   6940   70 70 70 70 70 	C6C	DB	70,70,70,70,70,70,70,00,00 ;l 5
        6945   70 70 00 00 
 7096   6949   00 00 00 00 7F 	C6D	DB	00,00,00,00,7f,fc,73,9c,73,9c,73,9c,73,9c,00,00,00,00 ;m 14
        694E   FC 73 9C 73 9C 
        6953   73 9C 73 9C 00 
        6958   00 00 00 
 7097   695B   00 00 00 00 7F 	C6E	DB	00,00,00,00,7f,80,71,c0,71,c0,71,c0,71,c0,00,00,00,00 ;n 10
        6960   80 71 C0 71 C0 
        6965   71 C0 71 C0 00 
        696A   00 00 00 
 7098   696D   00 00 00 00 3F 	C6F	DB	00,00,00,00,3f,80,71,c0,71,c0,71,c0,3f,80,00,00,00,00 ;o 10
        6972   80 71 C0 71 C0 
        6977   71 C0 3F 80 00 
        697C   00 00 00 
 7099   697F   00 00 00 00 7F 	C70	DB	00,00,00,00,7f,80,71,c0,71,c0,71,c0,7f,80,70,00,70,00 ;p 10
        6984   80 71 C0 71 C0 
        6989   71 C0 7F 80 70 
        698E   00 70 00 
 7100   6991   00 00 00 00 3F 	C71	DB	00,00,00,00,3f,80,71,c0,71,c0,71,c0,3f,c0,01,c0,01,c0 ;q 10
        6996   80 71 C0 71 C0 
        699B   71 C0 3F C0 01 
        69A0   C0 01 C0 
  Tue Jun 13 1989 11:42                                                                                                  Page  106

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

 7101   69A3   00 00 77 7C 70 	C72	DB	00,00,77,7c,70,70,70,00,00 ;r 8
        69A8   70 70 00 00 
 7102   69AC   00 00 00 00 3F 	C73	DB	00,00,00,00,3f,00,70,00,1e,00,03,80,3f,00,00,00,00,00 ;s 9
        69B1   00 70 00 1E 00 
        69B6   03 80 3F 00 00 
        69BB   00 00 00 
 7103   69BE   1C 1C 7F 1C 1C 	C74	DB	1c,1c,7f,1c,1c,1c,0f,00,00 ;t 8
        69C3   1C 0F 00 00 
 7104   69C7   00 00 00 00 71 	C75	DB	00,00,00,00,71,c0,71,c0,71,c0,71,c0,3f,c0,00,00,00,00 ;u 10
        69CC   C0 71 C0 71 C0 
        69D1   71 C0 3F C0 00 
        69D6   00 00 00 
 7105   69D9   00 00 00 00 71 	C76	DB	00,00,00,00,71,c0,71,c0,73,80,77,00,7e,00,00,00,00,00 ;v 10
        69DE   C0 71 C0 73 80 
        69E3   77 00 7E 00 00 
        69E8   00 00 00 
 7106   69EB   00 00 00 00 73 	C77	DB 	00,00,00,00,73,9c,73,9c,73,9c,73,9c,7f,f8,00,00,00,00 ;w 14
        69F0   9C 73 9C 73 9C 
        69F5   73 9C 7F F8 00 
        69FA   00 00 00 
 7107   69FD   00 00 00 00 71 	C78	DB	00,00,00,00,71,c0,71,c0,1f,00,71,c0,71,c0,00,00,00,00 ;x 10
        6A02   C0 71 C0 1F 00 
        6A07   71 C0 71 C0 00 
        6A0C   00 00 00 
 7108   6A0F   00 00 00 00 71 	C79	DB	00,00,00,00,71,c0,71,c0,71,c0,71,c0,3f,c0,01,c0,3f,80 ;y 10
        6A14   C0 71 C0 71 C0 
        6A19   71 C0 3F C0 01 
        6A1E   C0 3F 80 
 7109   6A21   00 00 00 00 7F 	C7A	DB	00,00,00,00,7f,c0,03,80,0e,00,38,00,7f,c0,00,00,00,00 ;z 10
        6A26   C0 03 80 0E 00 
        6A2B   38 00 7F C0 00 
        6A30   00 00 00 
 7110   6A33   1F 38 38 F0 38 	C7B	DB	1f,38,38,f0,38,38,1f,00,00 ;} 8
        6A38   38 1F 00 00 
 7111   6A3C   70 70 70 70 70 	C7C	DB	70,70,70,70,70,70,70,70,70 ;| 5
        6A41   70 70 70 70 
 7112   6A45   F8 1C 1C 0F 1C 	C7D	DB	f8,1c,1c,0f,1c,1c,f8,00,00 ;} 8
        6A4A   1C F8 00 00 
 7113   6A4E   00 00 00 00 3C 	C7E	DB	00,00,00,00,3c,e0,e7,80,00,00,00,00,00,00,00,00,00,00 ;~ 11
        6A53   E0 E7 80 00 00 
        6A58   00 00 00 00 00 
        6A5D   00 00 00 
 7114                      	;
 7115                      	; base addresses for the screen lines
 7116                      	;	
 7117   6A60               	BASEL:
 7118   6A60   00 00 00 00 00 		DB	00,00,00,00,00,00,00,00
        6A65   00 00 00 
 7119   6A68   80 80 80 80 80 		DB	80,80,80,80,80,80,80,80
        6A6D   80 80 80 
 7120   6A70   00 00 00 00 00 		DB	00,00,00,00,00,00,00,00
        6A75   00 00 00 
 7121   6A78   80 80 80 80 80 		DB	80,80,80,80,80,80,80,80
        6A7D   80 80 80 
 7122   6A80   00 00 00 00 00 		DB	00,00,00,00,00,00,00,00
        6A85   00 00 00 
 7123   6A88   80 80 80 80 80 		DB	80,80,80,80,80,80,80,80
        6A8D   80 80 80 
 7124   6A90   00 00 00 00 00 		DB	00,00,00,00,00,00,00,00
        6A95   00 00 00 
 7125   6A98   80 80 80 80 80 		DB	80,80,80,80,80,80,80,80
        6A9D   80 80 80 
 7126   6AA0   28 28 28 28 28 		DB	28,28,28,28,28,28,28,28
        6AA5   28 28 28 
 7127   6AA8   A8 A8 A8 A8 A8 		DB	A8,A8,A8,A8,A8,A8,A8,A8
        6AAD   A8 A8 A8 
 7128   6AB0   28 28 28 28 28 		DB	28,28,28,28,28,28,28,28
        6AB5   28 28 28 
 7129   6AB8   A8 A8 A8 A8 A8 		DB	A8,A8,A8,A8,A8,A8,A8,A8
        6ABD   A8 A8 A8 
 7130   6AC0   28 28 28 28 28 		DB	28,28,28,28,28,28,28,28
        6AC5   28 28 28 
 7131   6AC8   A8 A8 A8 A8 A8 		DB	A8,A8,A8,A8,A8,A8,A8,A8
        6ACD   A8 A8 A8 
 7132   6AD0   28 28 28 28 28 		DB	28,28,28,28,28,28,28,28
  Tue Jun 13 1989 11:42                                                                                                  Page  107

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6AD5   28 28 28 
 7133   6AD8   A8 A8 A8 A8 A8 		DB	A8,A8,A8,A8,A8,A8,A8,A8
        6ADD   A8 A8 A8 
 7134   6AE0   50 50 50 50 50 		DB	50,50,50,50,50,50,50,50
        6AE5   50 50 50 
 7135   6AE8   D0 D0 D0 D0 D0 		DB	D0,D0,D0,D0,D0,D0,D0,D0
        6AED   D0 D0 D0 
 7136   6AF0   50 50 50 50 50 		DB	50,50,50,50,50,50,50,50
        6AF5   50 50 50 
 7137   6AF8   D0 D0 D0 D0 D0 		DB	D0,D0,D0,D0,D0,D0,D0,D0
        6AFD   D0 D0 D0 
 7138   6B00   50 50 50 50 50 		DB	50,50,50,50,50,50,50,50
        6B05   50 50 50 
 7139   6B08   D0 D0 D0 D0 D0 		DB	D0,D0,D0,D0,D0,D0,D0,D0
        6B0D   D0 D0 D0 
 7140   6B10   50 50 50 50 50 		DB	50,50,50,50,50,50,50,50
        6B15   50 50 50 
 7141   6B18   D0 D0 D0 D0 D0 		DB	D0,D0,D0,D0,D0,D0,D0,D0
        6B1D   D0 D0 D0 
 7142   6B20               	BASEH:
 7143   6B20   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B25   34 38 3C 
 7144   6B28   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B2D   34 38 3C 
 7145   6B30   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B35   35 39 3D 
 7146   6B38   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B3D   35 39 3D 
 7147   6B40   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B45   36 3A 3E 
 7148   6B48   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B4D   36 3A 3E 
 7149   6B50   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6B55   37 3B 3F 
 7150   6B58   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6B5D   37 3B 3F 
 7151   6B60   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B65   34 38 3C 
 7152   6B68   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6B6D   34 38 3C 
 7153   6B70   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B75   35 39 3D 
 7154   6B78   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6B7D   35 39 3D 
 7155   6B80   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B85   36 3A 3E 
 7156   6B88   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6B8D   36 3A 3E 
 7157   6B90   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6B95   37 3B 3F 
 7158   6B98   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6B9D   37 3B 3F 
 7159   6BA0   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6BA5   34 38 3C 
 7160   6BA8   20 24 28 2C 30 		DB	20,24,28,2C,30,34,38,3C
        6BAD   34 38 3C 
 7161   6BB0   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6BB5   35 39 3D 
 7162   6BB8   21 25 29 2D 31 		DB	21,25,29,2D,31,35,39,3D
        6BBD   35 39 3D 
 7163   6BC0   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6BC5   36 3A 3E 
 7164   6BC8   22 26 2A 2E 32 		DB	22,26,2A,2E,32,36,3A,3E	
        6BCD   36 3A 3E 
 7165   6BD0   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6BD5   37 3B 3F 
 7166   6BD8   23 27 2B 2F 33 		DB	23,27,2B,2F,33,37,3B,3F
        6BDD   37 3B 3F 
 7167                      	;
 7168                      	; this gives the bit offset for each one
 7169                      	;
 7170   6BE0               	XBITTBL:
 7171   6BE0   00          		DB	0
 7172   6BE1   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BE6   03 00 
  Tue Jun 13 1989 11:42                                                                                                  Page  108

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

 7173   6BE8   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BED   03 00 
 7174   6BEF   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BF4   03 00 
 7175   6BF6   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6BFB   03 00 
 7176   6BFD   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C02   03 00 
 7177   6C04   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C09   03 00 
 7178   6C0B   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C10   03 00 
 7179   6C12   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C17   03 00 
 7180   6C19   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C1E   03 00 
 7181   6C20   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C25   03 00 
 7182   6C27   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C2C   03 00 
 7183   6C2E   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C33   03 00 
 7184   6C35   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C3A   03 00 
 7185   6C3C   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C41   03 00 
 7186   6C43   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C48   03 00 
 7187   6C4A   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C4F   03 00 
 7188   6C51   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C56   03 00 
 7189   6C58   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C5D   03 00 
 7190   6C5F   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C64   03 00 
 7191   6C66   04 01 05 02 06 		DB	4,1,5,2,6,3,0
        6C6B   03 00 
 7192                      		RADIX	D
 7193   6C6D   00 01 06 07 0C 	ZIPCOLOR: db	0,1,6,7,$C,$B,$E,$F
        6C72   0B 0E 0F 
 7194   6C75   02 03 FF FF FF 	APLCOLOR: db    2,3,$FF,$FF,$FF,$FF,4,5,$FF,$FF,$FF,7,$FF,$FF,8,9
        6C7A   FF 04 05 FF FF 
        6C7F   FF 07 FF FF 08 
        6C84   09 
 7195   6C85               	OLDZV:
 7196                      	;
 7197                      	; Variables that used to be in the zero page but got moved out
 7198                      	;
 7199          6C85        	PSVFLG	EQU	OLDZV		; (BYTE) PRESERVE FLAG FOR LEX 0=DON'T 1=DO
 7200          6C86        	VOCFLG	EQU	PSVFLG+1	; (BYTE) WHICH VOC TBL, 0=NORMAL 1= ARG3
 7201          6C87        	DBLOCK	EQU	VOCFLG+1	; (WORD) Z-BLOCK TO READ
 7202          6C89        	QUOT	EQU	DBLOCK+2	; (WORD) QUOTIENT FOR DIVISION
 7203          6C8B        	REMAIN	EQU	QUOT+2		; (WORD) REMAINDER FOR DIVISION
 7204          6C8D        	QSIGN	EQU	REMAIN+2	; (BYTE) SIGN OF QUOTIENT
 7205          6C8E        	RSIGN	EQU	QSIGN+1		; (BYTE) SIGN OF REMAINDER
 7206          6C8F        	DIGITS	EQU	RSIGN+1		; (BYTE) DIGIT COUNT FOR "PRINTN"
 7207          6C90        	OLDLEN	EQU	DIGITS+1	; (BYTE) OLD LINE LENGTH
 7208          6C91        	OLDEND	EQU	OLDLEN+1	; (BYTE) OLD LAST CHAR IN [LBUFF]
 7209          6C92        	SPSTAT	EQU	OLDEND+1	; (BYTE) SPLIT SCREEN STATUS FLAG
 7210          6C93        	LFROM	EQU	SPSTAT+1	; (WORD) "FROM" LINE ADDRESS
 7211          6C95        	LTO	EQU	LFROM+2		; (WORD) "TO" LINE ADDRESS
 7212          6C97        	PRLEN	EQU	LTO+2		; (BYTE) SCRIPT LINE LENGTH
 7213          6C98        	GPOSIT	EQU	PRLEN+1		; (BYTE) DEFAULT SAVE POSITION
 7214          6C99        	GDRIVE	EQU	GPOSIT+1	; (BYTE) DEFAULT SAVE DRIVE
 7215          6C9A        	TPOSIT	EQU	GDRIVE+1	; (BYTE) TEMP SAVE POSITION
 7216          6C9B        	TDRIVE	EQU	TPOSIT+1	; (BYTE) TEMP SAVE DRIVE
 7217          6C9C        	TSLOT	EQU	TDRIVE+1	; (BYTE) TEMP SAVE SLOT
 7218          6C9D        	DRIVE	EQU	TSLOT+1		; (BYTE) CURRENT DRIVE
 7219          6C9E        	SIDEFLG	EQU	DRIVE+1		; (BYTE) which disk side are we on
 7220          6C9F        	SRHOLD	EQU	SIDEFLG+1	; (WORD) <>0 if doing sequential random
 7221          6CA1        	SCRIPTF	EQU	SRHOLD+2	; (BYTE) DIROUT FLAG FOR PRINTER OUTPUT
 7222          6CA2        	SCRIPTFLG EQU	SCRIPTF+1	; (BYTE) Does window allow scripting?
 7223          6CA3        	OLDZSP	EQU	SCRIPTFLG+1	; (WORD)
 7224          6CA5        	CURSFLG	EQU	OLDZSP+2	; (BYTE) 1==New cursor X for DLINE
  Tue Jun 13 1989 11:42                                                                                                  Page  109

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

 7225          6CA6        	DBLK	EQU	CURSFLG+1	; (WORD)
 7226          6CA8        	RDTBL1	EQU	DBLK+2		; (WORD) READ TABLE 1 (Game Relative)
 7227          6CAA        	RDTBL2	EQU	RDTBL1+2	; (WORD) READ TABLE 2
 7228          6CAC        	NENTS	EQU	RDTBL2+2	; (WORD) # ENTRIES IN VOCAB TABLE
 7229          6CAE        	DIRITM	EQU	NENTS+2		; (WORD) OFFSET IN OUTPUT TBL (DIRTBL)
 7230          6CB0        	DIRCNT	EQU	DIRITM+2	; (WORD) COUNT OF CHARS IN TBL (DIRTBL)
 7231          6CB2        	SVTCHAR EQU	DIRCNT+2	; (WORD) Old TCHARS table address
 7232          6CB4        	VOCMPC	EQU	SVTCHAR+2	; (3 BYTES) Save for vocabulary MPC
 7233          6CB7        	VCESVE	EQU	VOCMPC+3	; (3 BYTES) Save for VOCEND
 7234          6CBA        	VWLSVE	EQU	VCESVE+3	; (3 BYTES) Save for VOCLEN
 7235          6CBD        	DIDVTBL	EQU	VWLSVE+3	; (BYTE) <>0 if we have done default table
 7236          6CBE        	IN	EQU	DIDVTBL+1	; (9 BYTES) INPUT BUFFER
 7237          6CC7        	OUT	EQU	IN+9		; (9 BYTES) OUTPUT BUFFER
 7238          6CD0        	CURSOR_OFF EQU  OUT+9           ; (BYTE) ==1 if char cursor not to be on
 7239          6CD1        	CRLF_CHECK EQU    CURSOR_OFF+1    ; (BYTE) ==1 to do CRLF function check
 7240          6CD2        	PTR_COUNT EQU   CRLF_CHECK+1      ; (BYTE) ==0 if checking pointer movement
 7241          6CD3        	INFODOS_END EQU PTR_COUNT+1     ; (WORD) last segment of infodos special
 7242          0050        	OLDZVLEN EQU 	INFODOS_END-PSVFLG+2	; this is how much to reserve
 7243                      	
 7244   6C85               		BLKB	OLDZVLEN,0	; and zero it out
 7245                      	
 7246                      	; ------------------
 7247                      	; ERROR MESSAGE STRINGS
 7248                      	; ------------------
 7249   6CD5   0E          	E27:	db	E27L
 7250   6CD6   44 69 73 6B 20 		db	"Disk I/O Error"
        6CDB   49 2F 4F 20 45 
        6CE0   72 72 6F 72 
 7251          000E        	E27L	EQU	$-E27-1
 7252   6CE4   14          	E2B:	db	E2BL
 7253   6CE5   44 69 73 6B 20 		db	"Disk write protected"
        6CEA   77 72 69 74 65 
        6CEF   20 70 72 6F 74 
        6CF4   65 63 74 65 64 
 7254          0014        	E2BL	EQU	$-E2B-1
 7255   6CF9   0C          	E40:	db	E40L
 7256   6CFA   42 61 64 20 46 		db	"Bad Filename"
        6CFF   69 6C 65 6E 61 
        6D04   6D 65 
 7257          000C        	E40L	EQU	$-E40-1
 7258   6D06   0E          	E44:	db	E44L
 7259   6D07   50 61 74 68 20 		db	"Path not found"
        6D0C   6E 6F 74 20 66 
        6D11   6F 75 6E 64 
 7260          000E        	E44L:	EQU	$-E44-1
 7261   6D15   10          	E45:	db	E45L
 7262   6D16   56 6F 6C 75 6D 		db	"Volume not found"
        6D1B   65 20 6E 6F 74 
        6D20   20 66 6F 75 6E 
        6D25   64 
 7263          0010        	E45L	EQU	$-E45-1
 7264   6D26   0E          	E46:	db	E46L
 7265   6D27   46 69 6C 65 20 		db	"File Not Found"
        6D2C   4E 6F 74 20 46 
        6D31   6F 75 6E 64 
 7266          000E        	E46L	EQU	$-E46-1
 7267   6D35   09          	E48:	db	E48L
 7268   6D36   44 69 73 6B 20 		db	"Disk Full"
        6D3B   46 75 6C 6C 
 7269          0009        	E48L	EQU	$-E48-1
 7270   6D3F   21          	E49:    db      E49L
 7271   6D40   4C 61 6E 65 44 	        db      "LaneDOS limit: 12 files/directory"
        6D45   4F 53 20 6C 69 
        6D4A   6D 69 74 3A 20 
        6D4F   31 32 20 66 69 
        6D54   6C 65 73 2F 64 
        6D59   69 72 65 63 74 
        6D5E   6F 72 79 
 7272          0021        	E49L    EQU     $-E49-1
 7273   6D61   26          	E4E:    db      E4EL
 7274   6D62   4C 61 6E 65 44 	        db      "LaneDOS limit: No writes to TREE files"
        6D67   4F 53 20 6C 69 
        6D6C   6D 69 74 3A 20 
        6D71   4E 6F 20 77 72 
        6D76   69 74 65 73 20 
  Tue Jun 13 1989 11:42                                                                                                  Page  110

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- ZIP DATA TABLES ---"

        6D7B   74 6F 20 54 52 
        6D80   45 45 20 66 69 
        6D85   6C 65 73 
 7275          0026        	E4EL    EQU     $-E4E-1
 7276   6D88   0E          	E4C:	db	E4CL
 7277   6D89   55 6E 65 78 70 		db	"Unexpected EOF"
        6D8E   65 63 74 65 64 
        6D93   20 45 4F 46 
 7278          000E        	E4CL	EQU	$-E4C-1
 7279                      	
 7280   6D97   27          	ELIST:	db	$27
 7281   6D98   D56C        		dw	E27
 7282   6D9A   2B          		db	$2B
 7283   6D9B   E46C        		dw	E2B
 7284   6D9D   40          		db	$40
 7285   6D9E   F96C        		dw	E40
 7286   6DA0   44          		db	$44
 7287   6DA1   066D        		dw	E44
 7288   6DA3   45          		db	$45
 7289   6DA4   156D        		dw	E45
 7290   6DA6   46          		db	$46
 7291   6DA7   266D        		dw	E46
 7292   6DA9   48          		db	$48
 7293   6DAA   356D        		dw	E48
 7294   6DAC   49          	        db      $49
 7295   6DAD   3F6D        	        dw      E49
 7296   6DAF   4C          		db	$4C
 7297   6DB0   886D        		dw	E4C
 7298   6DB2   4E          	        db      $4E
 7299   6DB3   616D        	        dw      E4E
 7300          001B        	ELISTL	EQU	$-ELIST-3	; mark last error code
 7301                      	
 7302   6DB5               		END
 7303                      	
 7304   6DB5               		INCLUDE		WINDOWS.ASM
 7305                      	
 7306   6DB5               		STTL	"--- WINDOW OPERATIONS ---"
 7307                      		PAGE
  Tue Jun 13 1989 11:42                                                                                                  Page  111

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7308                      	;
 7309                      	; these are the data structures for all 8 WINDOW.  They are identical and
 7310                      	; are just seperated cuz I use the addresses in the table that follows.
 7311                      	;	All numbers are inclusive, absolute, and zero-based.
 7312                      	;
 7313          0000        	WINDSTRUCT	EQU	0
 7314          0000        	WINTOP 		EQU	WINDSTRUCT	; first line of the window
 7315          0001        	WINLEFT 	EQU	WINTOP+1	; left edge of the window
 7316          0002        	WINHGHT		EQU	WINLEFT+1	; height of the window
 7317          0003        	WINWID		EQU	WINHGHT+1	; width of the window, in pixels
 7318          0004        	WINY		EQU	WINWID+1	; y pos of cursor (pos, not relative)
 7319          0005        	WINX		EQU	WINY+1		; x pos of cursor (remember, ABSOLUTE)
 7320          0006        	WINLM		EQU	WINX+1		; left margin
 7321          0007        	WINRM		EQU	WINLM+1		; right margin
 7322          0008        	WINCRF		EQU	WINRM+1		; (WORD) <CR> function
 7323          000A        	WINCRC		EQU	WINCRF+2	; (WORD) <CR> counter
 7324          000C        	WINHIGHL	EQU	WINCRC+2	; highlight mode
 7325          000D        	WINFORE		EQU	WINHIGHL+1	; foreground color (0=black-7=white)
 7326          000E        	WINBGND		EQU	WINFORE+1	; background color (0=black-7=white)
 7327          000F        	WINFONT		EQU	WINBGND+1	; window font (0=normal/4=monospaced)
 7328          0010        	WINFSIZE	EQU	WINFONT+1	; (WORD) font Height/Width
 7329          0012        	WINATR		EQU	WINFSIZE+2	; Window Attributes
 7330          0013        	WINLCNT		EQU	WINATR+1	; current number of lines
 7331                      	;
 7332                      	; these are my interesting things
 7333                      	;
 7334          0014        	WINXSZ		EQU	WINLCNT+1	; width of window, in pixels, using margin
 7335          0015        	WINLLEN		EQU	WINXSZ+1	; length of current line
 7336          0017        	WINLINES	EQU	WINLLEN+2	; max # of lines for window
 7337                      	
 7338   6DB5               	WINDOW0:
 7339   6DB5   00          		DB	0		; WINTOP - first line of the window
 7340   6DB6   00          		DB	0		; WINLEFT - left edge of the window
 7341   6DB7   C0          		DB	MAXHEIGHT	; WINHGHT - height of window
 7342   6DB8   8C          		DB	MAXWIDTH	; WINWID - width of window
 7343   6DB9   00          		DB	0		; WINY - y pos of cursor (pos, not relative)
 7344   6DBA   00          		DB	0		; WINX - x pos of cursor (remember, ABSOLUTE)
 7345   6DBB   00          		DB	0		; WINLM - left margin
 7346   6DBC   00          		DB	0		; WINRM - right margin
 7347   6DBD   0000        		DW	0		; WINCRF - <CR> function
 7348   6DBF   0000        		DW	0		; WINCRC - <CR> counter
 7349   6DC1   00          		DB	0		; WINHIGHL - Highlights
 7350   6DC2   0F          		DB	$f		; WINFORE - foreground color default of white
 7351   6DC3   00          		DB	0		; WINBGND - background color
 7352   6DC4   00          		DB	0		; WINFONT - window font (0=normal/1=alternate)
 7353   6DC5   02 09       		DB	2,FONT_H	; WINFSIZE - Width/Height
 7354   6DC7   0F          		DB	$0f		; WINATR - all attributes on for window 0
 7355   6DC8   00          		DB	0		; WINLCNT - current number of lines
 7356   6DC9   8C          		DB	MAXWIDTH	; WINXSZ - width of window, in pixels, using margin
 7357   6DCA   00 00       		DB	0,0		; WINLLEN - length of current line
 7358   6DCC   14          		DB	(MAXHEIGHT/FONT_H)-1 ; WINLINES - max # of lines for window
 7359                      	;
 7360                      	; same start as window 0, but with 0 length
 7361                      	;
 7362   6DCD               	WINDOW1:
 7363   6DCD   00 00 00 8C 00 		DB	0,0,0,MAXWIDTH,0,0,0,0,0,0,0,0,0
        6DD2   00 00 00 00 00 
        6DD7   00 00 00 
 7364   6DDA   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,MAXWIDTH,0,0,0
        6DDF   08 00 8C 00 00 
        6DE4   00 
 7365                      	;
 7366                      	; the rest have no width/height/attributes (except buffering)
 7367                      	;
 7368   6DE5               	WINDOW2:
 7369   6DE5   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6DEA   00 00 00 00 00 
        6DEF   00 00 00 
 7370   6DF2   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6DF7   08 00 00 00 00 
        6DFC   00 
 7371   6DFD               	WINDOW3:
 7372   6DFD   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6E02   00 00 00 00 00 
        6E07   00 00 00 
  Tue Jun 13 1989 11:42                                                                                                  Page  112

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7373   6E0A   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6E0F   08 00 00 00 00 
        6E14   00 
 7374   6E15               	WINDOW4:
 7375   6E15   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6E1A   00 00 00 00 00 
        6E1F   00 00 00 
 7376   6E22   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6E27   08 00 00 00 00 
        6E2C   00 
 7377   6E2D               	WINDOW5:
 7378   6E2D   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6E32   00 00 00 00 00 
        6E37   00 00 00 
 7379   6E3A   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6E3F   08 00 00 00 00 
        6E44   00 
 7380   6E45               	WINDOW6:
 7381   6E45   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6E4A   00 00 00 00 00 
        6E4F   00 00 00 
 7382   6E52   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6E57   08 00 00 00 00 
        6E5C   00 
 7383   6E5D               	WINDOW7:
 7384   6E5D   00 00 00 00 00 		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
        6E62   00 00 00 00 00 
        6E67   00 00 00 
 7385   6E6A   0F 00 00 02 09 		DB	$F,0,0,2,FONT_H,$08,0,0,0,0,0
        6E6F   08 00 00 00 00 
        6E74   00 
 7386                      	
 7387   6E75               	WINTABLE:
 7388   6E75   B56D CD6D E56D 		DW	WINDOW0,WINDOW1,WINDOW2,WINDOW3
        6E7B   FD6D 
 7389   6E7D   156E 2D6E 456E 		DW	WINDOW4,WINDOW5,WINDOW6,WINDOW7
        6E83   5D6E 
 7390                      		PAGE
  Tue Jun 13 1989 11:42                                                                                                  Page  113

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7391                      	
 7392                      	; ------
 7393                      	; SCREEN
 7394                      	; ------
 7395                      	; Move to the screen specified, by updating CURWIN and the cursor
 7396                      	; X,Y pos (SCRX,SCRY).  Also put address of that window's structure
 7397                      	; in WINDOW. Save a bunch of the old stuff in old window's structure then
 7398                      	; update the same bunch with the new window's stuff.
 7399                      	;
 7400                      	;	ARG1 - new screen id: 0-7
 7401                      	;
 7402   6E85               	ZSCRN:
 7403   6E85   20 BE 55    		jsr	CLRBUF		; EMPTY OUTPUT BUFFER BEFORE MOVING
 7404                      	;
 7405                      	; now, save a few things from the common variables
 7406                      	;
 7407   6E88   A0 15       		ldy	#WINLLEN	; current line length
 7408   6E8A   A5 A7       		lda	LENGTH+LO	; get current line length
 7409   6E8C   91 05       		sta	(WINDOW),Y	; save for later referencing
 7410   6E8E   C8          		iny			; point to msb
 7411   6E8F   A5 A8       		lda	LENGTH+HI	; get MSB
 7412   6E91   91 05       		sta	(WINDOW),Y	; saved
 7413   6E93   20 8F 4D    		jsr	SAVE_CURSOR	; save the x,y pos of cursor
 7414   6E96   A5 BB       		lda	INVFLG		; get inverse flag
 7415   6E98   F0 04       		beq	ZSCA1		; not set
 7416   6E9A   A9 01       		lda	#1		; set 1 bit
 7417   6E9C   D0 06       		bne	ZSCA2		; set in window
 7418   6E9E               	ZSCA1:
 7419   6E9E   A5 BA       		lda	UNDFLG		; how about underlining
 7420   6EA0   F0 02       		beq	ZSCA2		; nope
 7421   6EA2   A9 04       		lda	#4		; 4 == underlining
 7422   6EA4               	ZSCA2:
 7423   6EA4   A0 0C       		ldy	#WINHIGHL	; set new highlight
 7424   6EA6   91 05       		sta	(WINDOW),Y	; save current attributes
 7425                      	;
 7426                      	; now it is time to update for new screen
 7427                      	;
 7428   6EA8   A5 63       		lda	ARG1+LO		; get which window
 7429   6EAA   85 A6       		sta	CURWIN		; save window number
 7430   6EAC   0A          		asl	A		; shift to make word indes
 7431   6EAD   AA          		tax			; swap to indexing reg
 7432   6EAE   BD 75 6E    		lda	WINTABLE,X	; get the address of the new WINDOW
 7433   6EB1   85 05       		sta	WINDOW+LO	; lo part comes first
 7434   6EB3   BD 76 6E    		lda	WINTABLE+1,X	; so go get hi part
 7435   6EB6   85 06       		sta	WINDOW+HI	; save the hi part of the address
 7436                      	
 7437   6EB8   20 A1 4D    		jsr	GET_CURSOR	; restore the cursor pos
 7438                      	
 7439   6EBB   A0 14       		ldy	#WINXSZ		; get line length
 7440   6EBD   B1 05       		lda	(WINDOW),Y	; update zero page variable
 7441   6EBF   85 A2       		sta	XSIZE+LO	; this is for quicky comparing
 7442   6EC1   A9 00       		lda	#0		; clear MSB
 7443   6EC3   85 A3       		sta	XSIZE+HI
 7444   6EC5   06 A2       		asl	XSIZE+LO	; *2
 7445   6EC7   26 A3       		rol	XSIZE+HI
 7446   6EC9   06 A2       		asl	XSIZE+LO	; *4
 7447   6ECB   26 A3       		rol	XSIZE+HI
 7448   6ECD   A0 15       		ldy	#WINLLEN	; get current line length
 7449   6ECF   B1 05       		lda	(WINDOW),Y	; from before
 7450   6ED1   85 A7       		sta	LENGTH+LO	; save for later checking
 7451   6ED3   C8          		iny
 7452   6ED4   B1 05       		lda	(WINDOW),Y
 7453   6ED6   85 A8       		sta	LENGTH+HI
 7454   6ED8   A0 13       		ldy	#WINLCNT	; how many lines already out there
 7455   6EDA   B1 05       		lda	(WINDOW),Y	; has been already saved
 7456   6EDC   85 AB       		sta	LINCNT		; and save 'ere too
 7457   6EDE   A0 17       		ldy	#WINLINES	; how many lines in this
 7458   6EE0   B1 05       		lda	(WINDOW),Y	; window, anyway?
 7459   6EE2   85 03       		sta	MAXLINES	; show for everyone to see
 7460   6EE4   A0 01       		ldy	#WINLEFT	; show left margin
 7461   6EE6   B1 05       		lda	(WINDOW),Y	; get left edge
 7462   6EE8   A0 06       		ldy	#WINLM		; left margin
 7463   6EEA   18          		clc			; adding
 7464   6EEB   71 05       		adc	(WINDOW),Y	; to find new left margin
 7465   6EED   85 04       		sta	LEFTMRG		; set up left margin for ease of use
  Tue Jun 13 1989 11:42                                                                                                  Page  114

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7466   6EEF   A0 00       		ldy	#WINTOP		; get top of window
 7467   6EF1   B1 05       		lda	(WINDOW),Y	; got it
 7468   6EF3   18          		clc			; adding
 7469   6EF4   A0 02       		ldy	#WINHGHT	; add height
 7470   6EF6   71 05       		adc	(WINDOW),Y	; did it
 7471   6EF8   85 02       		sta	SCRBTM		; this is first line outside window
 7472   6EFA   A0 0C       		ldy	#WINHIGHL	; get highlighting modes
 7473   6EFC   B1 05       		lda	(WINDOW),Y	; first for inverse video
 7474   6EFE   29 01       		and	#1		; check for inverse video
 7475   6F00   F0 02       		beq	SCRINV		; nope
 7476   6F02   A9 80       		lda	#$80		; means inverse video
 7477   6F04               	SCRINV:
 7478   6F04   85 BB       		sta	INVFLG		; there it be
 7479   6F06   B1 05       		lda	(WINDOW),Y	; point to underline flag
 7480   6F08   29 04       		and	#4		; check for underlining
 7481   6F0A   F0 02       		beq	SCRUND		; nope
 7482   6F0C   A9 80       		lda	#$80		; means underlining
 7483   6F0E               	SCRUND:
 7484   6F0E   85 BA       		sta	UNDFLG		; save for everyone
 7485                      	
 7486   6F10   A0 12       		ldy	#WINATR		; get the current attributes
 7487   6F12   B1 05       		lda	(WINDOW),Y	; gottem
 7488   6F14   20 96 70    		jsr	SET_ATTRIBUTES	; set the flags, thank you
 7489   6F17   A0 0F       		ldy	#WINFONT	; get the font
 7490   6F19   B1 05       		lda	(WINDOW),Y	; thank you
 7491   6F1B   F0 02       		beq	SCRFNT0		; is it font zero?
 7492   6F1D   A9 0C       		lda	#MONOFONT_W	; must be mono font, set width
 7493   6F1F               	SCRFNT0:
 7494   6F1F   85 C1       		sta	FONTFLG		; mark normal font
 7495   6F21               	ZSCREX:
 7496   6F21   60          		rts
 7497                      	;--------------
 7498                      	; ZWINPOS
 7499                      	;--------------
 7500                      	;
 7501                      	; change the window ARG1's top left corner to the new position
 7502                      	;
 7503                      	; ARG1 - window id from 0-7
 7504                      	; ARG2 - new top y pos
 7505                      	; ARG3 - new top x pos
 7506                      	;
 7507   6F22               	ZWINPOS:
 7508   6F22   C6 65       		dec	ARG2+LO		; make pos be zero based
 7509   6F24   C6 67       		dec	ARG3+LO		; now they are!
 7510                      	; 
 7511                      	; if moving current window, save current cursor pos
 7512                      	;
 7513   6F26               	ZWPOS0:
 7514   6F26   20 8F 4D    		jsr	SAVE_CURSOR	; saving
 7515                      	;
 7516                      	; let's set up [J] to point to window we are talking about
 7517                      	;
 7518   6F29               	ZWPOS1:
 7519   6F29   A5 63       		lda	ARG1+LO		; get window ID 
 7520   6F2B   20 87 57    		jsr	SETWJ		; get J to point to it
 7521                      	
 7522   6F2E   A5 65       	        lda     ARG2+LO         ; first, check the top
 7523   6F30   C9 C0       	        cmp     #MAXHEIGHT      ; < max height?
 7524   6F32   90 04       	        bcc     CKWA1           ; fine
 7525   6F34   A9 00       	        lda     #0              ; make it zero then        
 7526   6F36   85 65       	        sta     ARG2+LO         ; it is now
 7527   6F38               	CKWA1:
 7528   6F38   A5 67       	        lda     ARG3+LO         ; now check left edge
 7529   6F3A   C9 8C       	        cmp     #MAXWIDTH       ; howzit compare
 7530   6F3C   90 04       	        bcc     CKWA2           ; just fine
 7531   6F3E   A9 00       	        lda     #0              ; this too
 7532   6F40   85 67       	        sta     ARG3+LO         ; it is now
 7533   6F42               	CKWA2:
 7534                      	;
 7535                      	; make the cursor pos be relative, so we can change back to
 7536                      	; absolute using new window pos
 7537                      	;
 7538   6F42   A0 04       		ldy	#WINY		; let's do y pos first
 7539   6F44   B1 7A       		lda	(J),Y		; get the old y pos
 7540   6F46   A0 00       		ldy	#WINTOP		; and subtract the top to make
  Tue Jun 13 1989 11:42                                                                                                  Page  115

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7541   6F48   38          		sec			; (getting ready)
 7542   6F49   F1 7A       		sbc	(J),Y		; the pos relative
 7543   6F4B   18          		clc			; now add in new top
 7544   6F4C   65 65       		adc	ARG2+LO		; this will be new top
 7545   6F4E   A0 04       		ldy	#WINY		; get y offset again
 7546   6F50   91 7A       		sta	(J),Y		; and save new absolute y pos
 7547   6F52   A0 05       	  	ldy	#WINX		; now we be talking about x pos
 7548   6F54   B1 7A       		lda	(J),Y		; get old x pos
 7549   6F56   38          		sec			; getting ready for sub
 7550   6F57   A0 01       		ldy	#WINLEFT	; get rid of left ness
 7551   6F59   F1 7A       		sbc	(J),Y		; now it's relative
 7552   6F5B   18          		clc			; get ready to add in new left ness
 7553   6F5C   65 67       		adc	ARG3+LO		; done
 7554   6F5E   A0 05       		ldy	#WINX		; get x offset again
 7555   6F60   91 7A       		sta	(J),Y		; save in structure
 7556                      	;
 7557                      	; now we can change the top and left of the window
 7558                      	;
 7559   6F62   A5 65       		lda	ARG2+LO		; this is top of window
 7560   6F64   A0 00       		ldy	#WINTOP		; TOP offset
 7561   6F66   91 7A       		sta	(J),Y		; save the new top
 7562   6F68   A5 67       		lda	ARG3+LO		; here is the left edge
 7563   6F6A   A0 01       		ldy	#WINLEFT	; offset into struct
 7564   6F6C   91 7A       		sta	(J),Y		; saved !
 7565                      	;
 7566                      	; we might have moved current window so update screen cursor and left margin
 7567                      	;
 7568   6F6E   20 A1 4D    		jsr	GET_CURSOR	; restore cursor
 7569   6F71   A0 01       		ldy	#WINLEFT	; get left edge
 7570   6F73   B1 05       		lda	(WINDOW),Y	; okay
 7571   6F75   A0 06       		ldy	#WINLM		; add in left margin
 7572   6F77   18          		clc			; adding
 7573   6F78   71 05       		adc	(WINDOW),Y	; to find new left edge
 7574   6F7A   85 04       		sta	LEFTMRG		; store for ease of use
 7575   6F7C   A0 14       		ldy	#WINXSZ		; get xsize
 7576   6F7E   B1 7A       		lda	(J),Y		; okay
 7577   6F80   85 A2       		sta	XSIZE+LO	; this is for quicky comparing
 7578   6F82   A9 00       		lda	#0		; clear MSB
 7579   6F84   85 A3       		sta	XSIZE+HI
 7580   6F86   06 A2       		asl	XSIZE+LO	; *2
 7581   6F88   26 A3       		rol	XSIZE+HI
 7582   6F8A   06 A2       		asl	XSIZE+LO	; *4
 7583   6F8C   26 A3       		rol	XSIZE+HI
 7584   6F8E               	ZWPOSX:
 7585   6F8E   60          		rts
 7586                      	;------------
 7587                      	; ZWINSIZE
 7588                      	;------------
 7589                      	;
 7590                      	; Change the size of window ARG1.  If cursor is outside of window,
 7591                      	; move to it.
 7592                      	;
 7593                      	;	ARG1 - window ID
 7594                      	; 	ARG2 - height
 7595                      	;	ARG3 - width
 7596                      	;
 7597                      	; Uses [J].
 7598                      	;
 7599   6F8F               	ZWINSIZE:
 7600                      	;
 7601                      	; first put SCRCX,CY into window structure, just in case
 7602                      	;
 7603   6F8F   20 8F 4D    		jsr	SAVE_CURSOR	; saved
 7604                      	;
 7605                      	; now do everything
 7606                      	;
 7607   6F92   A5 63       		lda	ARG1+LO		; get the window ID
 7608   6F94   20 87 57    		jsr	SETWJ		; and get window pointer
 7609                      	
 7610   6F97   A5 65       	        lda     ARG2+LO         ; first, check the top
 7611   6F99   C9 C0       	        cmp     #MAXHEIGHT      ; < max height?
 7612   6F9B   90 04       	        bcc     CKWA11          ; fine
 7613   6F9D   A9 C0       	        lda     #MAXHEIGHT      ; make better
 7614   6F9F   85 65       	        sta     ARG2+LO         ; it is now
 7615   6FA1               	CKWA11:
  Tue Jun 13 1989 11:42                                                                                                  Page  116

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7616   6FA1   A5 67       	        lda     ARG3+LO         ; now check left edge
 7617   6FA3   C9 8C       	        cmp     #MAXWIDTH       ; howzit compare
 7618   6FA5   90 04       	        bcc     CKWA21          ; just fine
 7619   6FA7   A9 8C       	        lda     #MAXWIDTH       ; make it the max
 7620   6FA9   85 67       	        sta     ARG3+LO         ; it is now
 7621   6FAB               	CKWA21:
 7622   6FAB   A5 65       		lda	ARG2+LO		; get new height
 7623   6FAD   A0 02       		ldy	#WINHGHT	; offset
 7624   6FAF   91 7A       		sta	(J),Y		; save new height
 7625   6FB1   A5 67       		lda	ARG3+LO		; get width
 7626   6FB3   A0 03       		ldy	#WINWID		; store width
 7627   6FB5   91 7A       		sta	(J),Y		; okay
 7628                      	;
 7629                      	; now we need to figger out new XSIZE, MAXLINES
 7630                      	;
 7631   6FB7   A0 03       		ldy	#WINWID		; store width
 7632   6FB9   B1 7A       		lda	(J),Y		; get width
 7633   6FBB   38          		sec			; have width, subtract margins
 7634   6FBC   A0 07       		ldy	#WINRM		; first right margin
 7635   6FBE   F1 7A       		sbc	(J),Y		; subtracted right margin
 7636   6FC0   A0 06       		ldy	#WINLM		; and now for the left margin
 7637   6FC2   F1 7A       		sbc	(J),Y		; now we have new XSIZE
 7638   6FC4   A0 14       		ldy	#WINXSZ		; get offset
 7639   6FC6   91 7A       		sta	(J),Y		; save for later ref
 7640   6FC8   A5 65       		lda	ARG2+LO		; get new height
 7641   6FCA   A2 FF       		ldx	#$FF		; this is the counter
 7642   6FCC   38          		sec			; get ready for subs
 7643   6FCD               	ZWSZ1:
 7644   6FCD   E8          		inx			; count this line
 7645   6FCE   E9 09       		sbc	#FONT_H		; subtract off font height	
 7646   6FD0   B0 FB       		bcs	ZWSZ1		; still some lines	
 7647   6FD2   CA          		dex			; to keep the input line on screen
 7648   6FD3   8A          		txa			; get line count for storage
 7649   6FD4   A0 17       		ldy	#WINLINES	; this is how many lines are allowed
 7650   6FD6   91 7A       		sta	(J),Y		; saved
 7651                      	;
 7652                      	; check to make sure the cursor is still in the window
 7653                      	;
 7654   6FD8   A0 06       		ldy	#WINLM		; get left margin
 7655   6FDA   18          		clc			; for adding
 7656   6FDB   71 7A       		adc	(J),Y		; for figgering out right edge
 7657   6FDD   A0 01       		ldy	#WINLEFT	; add in left edge
 7658   6FDF   71 7A       		adc	(J),Y		; get right column by adding in left one
 7659   6FE1   A0 05       		ldy	#WINX		; check X pos
 7660   6FE3   D1 7A       		cmp	(J),Y		; see if X is still inside?
 7661   6FE5   F0 13       		beq	ZWSZ2		; must move to top left
 7662   6FE7   90 11       		bcc	ZWSZ2		; ditto if X >= margin
 7663   6FE9   A0 00       		ldy	#WINTOP		; get top to figger last line
 7664   6FEB   B1 7A       		lda	(J),Y		; from the structure
 7665   6FED   A0 02       		ldy	#WINHGHT	; and add in the height
 7666   6FEF   18          		clc			; getting ready for add
 7667   6FF0   71 7A       		adc	(J),Y		; to find first line outside of range
 7668   6FF2   A0 04       		ldy	#WINY		; now check y
 7669   6FF4   D1 7A       		cmp	(J),Y		; now check y then
 7670   6FF6   F0 02       		beq	ZWSZ2		; outside, move to top left
 7671   6FF8   B0 15       		bcs	ZWSZ3		; inside so quit
 7672                      	;
 7673                      	; move the cursor to top left if outside of resized window
 7674                      	;
 7675   6FFA               	ZWSZ2:
 7676   6FFA   A0 00       		ldy	#WINTOP		; top line is here
 7677   6FFC   B1 7A       		lda	(J),Y		; so get me it
 7678   6FFE   A0 04       		ldy	#WINY		; now we be doing y
 7679   7000   91 7A       		sta	(J),Y		; change Y
 7680   7002   A0 01       		ldy	#WINLEFT	; move X to left margin
 7681   7004   B1 7A       		lda	(J),Y		; first get left edge
 7682   7006   A0 06       		ldy	#WINLM		; and add in left margin
 7683   7008   18          		clc			; (adding)
 7684   7009   71 7A       		adc	(J),Y		; to get left spot of cursor
 7685   700B   A0 05       		ldy	#WINX		; this is x offset
 7686   700D   91 7A       		sta	(J),Y		; so move X there
 7687                      	;
 7688                      	; now check to see if we mucked with current window
 7689                      	;
 7690   700F               	ZWSZ3:
  Tue Jun 13 1989 11:42                                                                                                  Page  117

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7691   700F   A5 64       		lda	ARG1+HI		; this is the id
 7692   7011   30 04       		bmi	ZWSZ4		; must be current window
 7693   7013   C5 A6       		cmp	CURWIN		; is it current window?
 7694   7015   D0 1B       		bne	ZWSZX		; nope, so done
 7695   7017               	ZWSZ4:
 7696   7017   A0 17       		ldy	#WINLINES	; get how many lines
 7697   7019   B1 7A       		lda	(J),Y		; get number of lines
 7698   701B   85 03       		sta	MAXLINES	; set global
 7699   701D   A0 14       		ldy	#WINXSZ		; get new XSIZE too
 7700   701F   B1 7A       		lda	(J),Y		; get it
 7701   7021   85 A2       		sta	XSIZE+LO	; this is for quicky comparing
 7702   7023   A9 00       		lda	#0		; clear MSB
 7703   7025   85 A3       		sta	XSIZE+HI
 7704   7027   06 A2       		asl	XSIZE+LO	; *2
 7705   7029   26 A3       		rol	XSIZE+HI
 7706   702B   06 A2       		asl	XSIZE+LO	; *4
 7707   702D   26 A3       		rol	XSIZE+HI
 7708   702F   20 A1 4D    		jsr	GET_CURSOR	; fix the cursor pos
 7709   7032               	ZWSZX:
 7710   7032   60          		rts
 7711                      	;
 7712                      	;CHECK_WIN_ARGS
 7713                      	; check args to make sure they be okay
 7714                      	;
 7715                      	;  ARG2 = top/height
 7716                      	;  ARG3 = right/width
 7717                      	;
 7718   7033               	CHECK_WIN_ARGS:
 7719   7033   60          	        rts
 7720                      	
 7721                      		; ------
 7722                      		; HLIGHT
 7723                      		; ------
 7724                      	
 7725   7034               	ZLIGHT:
 7726   7034   A5 63       		lda	ARG1+LO		; get argument
 7727   7036   C9 10       		cmp	#$10		; must be <= 8
 7728   7038   B0 05       		bcs	ZLIEX		; nope it aint
 7729   703A   09 80       	 	ora	#$80		; turn on hi bit
 7730   703C   20 F5 52    		jsr	COUT		; send it out then
 7731   703F               	ZLIEX:
 7732   703F   60          		rts			; done
 7733                      	;
 7734                      	; actually set the highlight flags according to [A]
 7735                      	;	
 7736   7040               	HLIGHT:
 7737                      	;
 7738                      	; TURN OFF ALL HIGHLIGHTS
 7739                      	;	
 7740   7040   29 7F       		and	#$7F		; turn off high bit
 7741   7042   D0 05       		bne	ZL1		; nope, must be something
 7742   7044   85 BA       		sta	UNDFLG		; and turn of underlining flag
 7743   7046   85 BB       		sta	INVFLG		; and inverse
 7744   7048   60          		rts			; all done
 7745   7049               	ZL1:
 7746   7049   C9 04       		cmp	#4		; underlining
 7747   704B   D0 05       		bne	ZL_REV		; maybe its INVERSE?
 7748                      	
 7749   704D   A9 80       		lda	#$80		; turn on UNDFLG
 7750   704F   85 BA       		sta	UNDFLG		; with an FF
 7751   7051   60          		rts			; done
 7752   7052               	ZL_REV:	
 7753   7052   C9 01       		cmp	#1		; INVERSE?
 7754   7054   D0 05       		bne	ZL_MONO		; maybe monospaced then
 7755   7056   A9 80       		lda	#$80		; must be inverse video
 7756   7058   85 BB       		sta	INVFLG		; and put it in invflg
 7757   705A   60          		rts
 7758   705B               	ZL_MONO:
 7759   705B   60          		rts			; fuck it for now!	
 7760                      	;
 7761                      	; ZWINATTER - change the scrolling/buffering/scripting/wrapping attributes
 7762                      	; of the window.
 7763                      	;
 7764                      	; ARG1 - window id
 7765                      	; ARG2 - interesting bits
  Tue Jun 13 1989 11:42                                                                                                  Page  118

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7766                      	;	| buffering | scripting | scrolling | wrapping |
 7767                      	; ARG3 - operation - 	0 MOVE
 7768                      	;		  	1 SET
 7769                      	;			2 CLEAR
 7770                      	;			3 COMPLEMENT
 7771                      	;
 7772   705C               	ZWINATTR:
 7773   705C   A5 62       		lda	NARGS		; see how many args
 7774   705E   C9 03       		cmp	#3		; check for operation args
 7775   7060   F0 04       		beq	ZWAT1		; yes, already there
 7776   7062   A9 00       		lda	#0		; zero means MOVE
 7777   7064   85 67       		sta	ARG3+LO		; so show it as default
 7778   7066               	ZWAT1:
 7779   7066   A5 63       		lda	ARG1+LO		; get window ID
 7780   7068   20 87 57    		jsr	SETWJ		; put window address into [J]
 7781                      	
 7782   706B   A0 12       		ldy	#WINATR		; get attribute offset
 7783   706D   B1 7A       		lda	(J),Y		; get current attribute
 7784   706F   18          		clc			; so we can just branch
 7785                      	
 7786   7070   C6 67       		dec	ARG3+LO		; decrement to find out what to do
 7787   7072   30 0A       		bmi	ZWMOVE		; do a move
 7788   7074   F0 0C       		beq	ZWSET		; do a set
 7789   7076   C6 67       		dec	ARG3+LO		; check once more
 7790   7078   F0 0C       		beq	ZWCLEAR		; clear set ones
 7791                      	;
 7792                      	; this is for the COMPLEMENT operations
 7793                      	;
 7794   707A   45 65       		eor	ARG2+LO		; complement bits
 7795   707C   90 0E       		bcc	ZWAT2		; done
 7796   707E               	ZWMOVE:
 7797                      	;
 7798                      	; move into the flag word
 7799                      	;
 7800   707E   A5 65       		lda	ARG2+LO		; get new flags
 7801   7080   90 0A       		bcc	ZWAT2		; done
 7802   7082               	ZWSET:
 7803                      	;
 7804                      	; set turned on ones
 7805                      	;
 7806   7082   05 65       		ora	ARG2+LO		; set'em up
 7807   7084   90 06       		bcc	ZWAT2		; done
 7808   7086               	ZWCLEAR:
 7809                      	;
 7810                      	; clear just the ones that are on
 7811                      	;
 7812   7086   A5 65       	        lda     ARG2+LO         ; get argument
 7813   7088   49 FF       	        eor     #$FF            ; turn on all the off ones
 7814   708A   31 7A       		and	(J),Y		; keep all the other ones
 7815   708C               	ZWAT2:
 7816   708C   91 7A       		sta	(J),Y		; and save it back
 7817                      	;
 7818                      	; now, if current window, set necessary flags
 7819                      	;
 7820   708E   A6 63       		ldx 	ARG1+LO		; get window ID
 7821   7090   30 04       	        bmi     SET_ATTRIBUTES  ; assume negative is current window
 7822   7092   E4 A6       		cpx	CURWIN		; is this the current one?
 7823   7094   D0 30       		bne	ZWATX		; nope, so leave
 7824   7096               	SET_ATTRIBUTES:
 7825                      	;
 7826                      	; current window, so set flags accordingly
 7827                      	;
 7828   7096   A2 00       		ldx	#0		; to turn off flag
 7829   7098   A0 01       		ldy	#1		; to turn on flag
 7830   709A   6A          		ror	A		; get wrapping flag into carry
 7831   709B   90 05       		bcc	ZWAT3		; clear it
 7832   709D   8C 04 72    		sty	WRPFLG		; set wrapping on
 7833   70A0   B0 03       		bcs	ZWAT33		; okay
 7834   70A2               	ZWAT3:
 7835   70A2   8E 04 72    		stx	WRPFLG		; clear wrapping flag
 7836   70A5               	ZWAT33:
 7837   70A5   6A          		ror	A		; now check thes crolling flag
 7838   70A6   90 05       		bcc	ZWAT4		; not set
 7839   70A8   8C 05 72    		sty	SCRLFLG		; turn on scrolling flag
 7840   70AB   B0 03       		bcs	ZWAT44		; okay, next please
  Tue Jun 13 1989 11:42                                                                                                  Page  119

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7841   70AD               	ZWAT4:
 7842   70AD   8E 05 72    		stx	SCRLFLG		; turn off scrolling
 7843   70B0               	ZWAT44:
 7844   70B0   6A          		ror	A		; checking the scripting flag
 7845   70B1   90 05       		bcc	ZWAT5		; not set
 7846   70B3   8C A2 6C    		sty	SCRIPTFLG	; allow scripting? yes
 7847   70B6   B0 03       		bcs	ZWAT55		; next flag
 7848   70B8               	ZWAT5:	
 7849   70B8   8E A2 6C    		stx	SCRIPTFLG	; allow scripting? no
 7850   70BB               	ZWAT55:
 7851   70BB   6A          		ror	A		; this checks the buffering flag
 7852   70BC   90 05       		bcc	ZWAT6		; not set
 7853   70BE   8C 06 72    		sty	BUFFLG		; turn on buffering
 7854   70C1   B0 03       		bcs	ZWATX		; scram
 7855   70C3               	ZWAT6:
 7856   70C3   8E 06 72    		stx	BUFFLG		; turn off buffering
 7857   70C6               	ZWATX:
 7858   70C6   60          		rts
 7859                      	;
 7860                      	; ZWINGET - put the window stuff into a table
 7861                      	;
 7862                      	;  ARG1 - Window id
 7863                      	;  ARG2 - offset
 7864                      	;
 7865   70C7               	ZWINGET:
 7866   70C7   20 8F 4D    		jsr	SAVE_CURSOR	; save x,y into structure
 7867                      	
 7868   70CA   A5 63       		lda	ARG1+LO		; get window ID
 7869   70CC   20 87 57    		jsr	SETWJ		; set up window address
 7870                      	
 7871   70CF   A5 65       		lda	ARG2+LO		; get where to start getting
 7872   70D1   0A          		asl	A		; make word index
 7873   70D2   AA          		tax			; make index
 7874   70D3   BD 6F 71    		lda	ZWGTBL+LO,X	; get lo part of address
 7875   70D6   85 7C       		sta	K+LO		; save for jumping
 7876   70D8   BD 70 71    		lda	ZWGTBL+HI,X	; get hi part
 7877   70DB   85 7D       		sta	K+HI		; saved
 7878   70DD   20 E7 70    		jsr	ZWGVEC		; do the vectoring
 7879   70E0   86 77       		stx	VALUE+HI	; save hi part
 7880   70E2   85 76       		sta	VALUE+LO	; and the lo part
 7881   70E4   4C D1 43    		jmp	PUTVAL		; and return it
 7882   70E7               	ZWGVEC:
 7883   70E7   6C 7C 00    		jmp	(K)		; and goto it boys
 7884   70EA               	ZWG0:
 7885   70EA   A2 00       		ldx	#0		; zero out high part
 7886   70EC   A0 00       		ldy	#WINTOP		; get window y pos
 7887   70EE   B1 7A       		lda	(J),Y		; got it
 7888   70F0   A8          		tay			; need to inc it
 7889   70F1   C8          		iny			; to make it a one-based number
 7890   70F2   98          		tya			; back to a
 7891   70F3   60          		rts
 7892   70F4               	ZWG1:
 7893   70F4   A2 00       		ldx	#0		; zero out high part
 7894   70F6   A0 01       		ldy	#WINLEFT	; get window x pos
 7895   70F8   B1 7A       		lda	(J),Y		; got it
 7896   70FA   A8          		tay			; need to inc it
 7897   70FB   C8          		iny			; to make it a one-based number
 7898   70FC   98          		tya			; back to a
 7899   70FD   60          		rts
 7900   70FE               	ZWG2:
 7901   70FE   A2 00       		ldx	#0		; zero out high part
 7902   7100   A0 02       		ldy	#WINHGHT	; get window height
 7903   7102   B1 7A       		lda	(J),Y		; got it
 7904   7104   60          		rts
 7905   7105               	ZWG3:
 7906   7105   A2 00       		ldx	#0		; zero out high part
 7907   7107   A0 03       		ldy	#WINWID		; window width
 7908   7109   B1 7A       		lda	(J),Y		; got it
 7909   710B   60          		rts
 7910   710C               	ZWG4:
 7911   710C   20 6C 57    		jsr	FETCHCY		; get the current Y pos
 7912   710F   A2 00       		ldx	#0		; zero out high part
 7913   7111   60          		rts
 7914   7112               	ZWG5:
 7915   7112   20 79 57    		jsr	FETCHCX		; fetch the current X pos
  Tue Jun 13 1989 11:42                                                                                                  Page  120

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7916   7115   A2 00       		ldx	#0		; zero out high part
 7917   7117   60          		rts
 7918   7118               	ZWG6:
 7919   7118   A2 00       		ldx	#0		; zero out high part
 7920   711A   A0 06       		ldy	#WINLM		; left margin
 7921   711C   B1 7A       		lda	(J),Y		; got it
 7922   711E   60          		rts
 7923   711F               	ZWG7:
 7924   711F   A2 00       		ldx	#0		; zero out high part
 7925   7121   A0 07       		ldy	#WINRM		; right margin
 7926   7123   B1 7A       		lda	(J),Y		; got it
 7927   7125   60          		rts
 7928   7126               	ZWG8:
 7929   7126   A0 09       		ldy	#WINCRF+HI	; <CR> function
 7930   7128   B1 7A       		lda	(J),Y		; got it, lo part
 7931   712A   AA          		tax			; save hi part
 7932   712B   88          		dey			; point to lo part
 7933   712C   B1 7A       		lda	(J),Y		; got lo part
 7934   712E   60          		rts
 7935   712F               	ZWG9:
 7936   712F   A0 0B       		ldy	#WINCRC+HI	; <CR> count
 7937   7131   B1 7A       		lda	(J),Y		; got it, hi part
 7938   7133   AA          		tax			; save it
 7939   7134   88          		dey			; now to lo part
 7940   7135   B1 7A       		lda 	(J),Y		; got it
 7941   7137   60          		rts
 7942   7138               	ZWG10:
 7943   7138   A0 0C       		ldy	#WINHIGHL	; get high light mode
 7944   713A   B1 7A       		lda	(J),Y		; got it
 7945   713C   A2 00       		ldx	#0		; zero out high part
 7946   713E   60          		rts
 7947   713F               	ZWG11:
 7948   713F   A0 0E       		ldy	#WINBGND	; and background
 7949   7141   B1 7A       		lda	(J),Y		; got it
 7950   7143   A8          	        tay                     ; make index
 7951   7144   B9 75 6C    	        lda     APLCOLOR,Y      ; get apl->zip color
 7952   7147   AA          	        tax                     ; save for return
 7953   7148   A0 0D       		ldy	#WINFORE	; get foreground
 7954   714A   B1 7A       		lda	(J),Y		; got it
 7955   714C   A8          		tay			; save it
 7956   714D   B9 75 6C    	        lda     APLCOLOR,Y      ; get apl->zip color
 7957   7150   60          		rts
 7958   7151               	ZWG12:
 7959   7151   A0 0F       		ldy	#WINFONT	; now for font id
 7960   7153   B1 7A       		lda	(J),Y		; got it
 7961   7155   A2 00       		ldx	#0		; zero out high part
 7962   7157   60          		rts
 7963   7158               	ZWG13:
 7964   7158   A0 11       		ldy	#WINFSIZE+1	; font size (width)
 7965   715A   B1 7A       		lda	(J),Y		; got it
 7966   715C   AA          		tax			; save it
 7967   715D   88          		dey			; font size (height)
 7968   715E   B1 7A       		lda	(J),Y		; got it
 7969   7160   60          		rts
 7970   7161               	ZWG14:
 7971   7161   A2 00       		ldx	#0		; zero out high part
 7972   7163   A0 12       		ldy	#WINATR		; attributes
 7973   7165   B1 7A       		lda	(J),Y		; got it
 7974   7167   60          		rts			; got them!
 7975   7168               	ZWG15:
 7976   7168   A2 00       		ldx	#0		; only 1 byte worth
 7977   716A   A0 13       		ldy	#WINLCNT	; offset
 7978   716C   B1 7A       		lda	(J),Y		; get more counter
 7979   716E   60          		rts
 7980                      	;
 7981                      	; jump table for figgering out where to start filling
 7982                      	;
 7983   716F               	ZWGTBL:
 7984   716F   EA70 F470 FE70 		DW	ZWG0,ZWG1,ZWG2,ZWG3,ZWG4,ZWG5,ZWG6,ZWG7
        7175   0571 0C71 1271 
        717B   1871 1F71 
 7985   717F   2671 2F71 3871 		DW	ZWG8,ZWG9,ZWG10,ZWG11,ZWG12,ZWG13,ZWG14,ZWG15
        7185   3F71 5171 5871 
        718B   6171 6871 
 7986                      	;	
  Tue Jun 13 1989 11:42                                                                                                  Page  121

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 7987                      	; ZSCROLL - scroll the specified window up or down
 7988                      	;
 7989                      	;  ARG1 - window ID
 7990                      	;  ARG2 - lines to scroll; <0 scrolls down
 7991                      	;
 7992   718F               	ZSCROLL:
 7993   718F   20 8F 4D    		jsr	SAVE_CURSOR	; save where cursor is
 7994                      	
 7995   7192   A9 00       	        lda     #0              ; don't script scroll
 7996   7194   85 AA       	        sta     SCRIPT          ; fine, we won't now
 7997                      	
 7998   7196   A5 63       		lda	ARG1+LO		; get which window
 7999   7198   20 87 57    		jsr	SETWJ		; set up pointer
 8000   719B   C6 62       		dec	NARGS		; see what we have for lines
 8001   719D   D0 04       		bne	ZSCR1		; a passed arg
 8002   719F   A9 01       		lda	#1		; 1 line is default
 8003   71A1   85 65       		sta	ARG2+LO		; so say so
 8004   71A3               	ZSCR1:
 8005   71A3   A0 00       		ldy	#WINTOP		; get me window limits
 8006   71A5   B1 7A       		lda	(J),Y		; first top
 8007   71A7   85 0B       		sta	CLSTOP		; save for usage
 8008   71A9   C8          		iny			; now left
 8009   71AA   B1 7A       		lda	(J),Y		; okay, get for this window
 8010   71AC   85 0A       		sta	CLSLEFT		; save left
 8011   71AE   C8          		iny			; now it's width
 8012   71AF   B1 7A       		lda	(J),Y		; got the window height
 8013   71B1   85 0D       		sta	CLSHEIGHT	; this is it
 8014   71B3   C8          		iny			; this is height
 8015   71B4   B1 7A       		lda	(J),Y		; get window's height
 8016   71B6   85 0C       		sta	CLSWIDTH	; save
 8017   71B8   A5 66       		lda	ARG2+HI		; is it negative?
 8018   71BA   85 1D       		sta	SCLDIR		; show direction of scroll
 8019   71BC   10 08       		bpl	ZSCRL1		; nope
 8020   71BE   A6 65       		ldx	ARG2+LO		; get how many lines
 8021   71C0   49 FF       		eor	#$FF		; make pos
 8022   71C2   AA          		tax			; put in X for inc
 8023   71C3   E8          		inx			; and make right
 8024   71C4   D0 02       		bne	ZSCRLEX		; done
 8025   71C6               	ZSCRL1:
 8026   71C6   A6 65       		ldx	ARG2+LO		; get how many lines
 8027   71C8               	ZSCRLEX:
 8028   71C8   86 18       		stx	SCLLINES	; save for routine
 8029   71CA   20 31 60    		jsr	DO_SCROLL	; and do the scroll
 8030   71CD               	ZSCRLEX1:
 8031   71CD   A9 01       	        lda     #1              ; allow scripting
 8032   71CF   85 AA       	        sta     SCRIPT          ; we do
 8033   71D1   4C A1 4D    		jmp	GET_CURSOR	; restore the cursor, thank you
 8034                      	;
 8035                      	; ZWINPUT - put some information into window structure.  Just CRF/CRC
 8036                      	;	is legit now.
 8037                      	;
 8038                      	;  ARG1 - window ID
 8039                      	;  ARG2 - Word to be saved
 8040                      	;  ARG3 - offset of value
 8041                      	;
 8042   71D4               	ZWINPUT:
 8043   71D4   20 8F 4D    	        jsr     SAVE_CURSOR     ; save the cursor pos
 8044   71D7   A5 63       		lda	ARG1+LO		; get window ID
 8045   71D9   20 87 57    		jsr	SETWJ		; have J point to structure
 8046                      	
 8047   71DC   A5 65       		lda	ARG2+LO		; get first value in table
 8048   71DE   C9 08       		cmp	#8		; 8 = <CR> function
 8049   71E0   F0 0D       		beq	ZWIPCRF		; so save that
 8050   71E2   C9 09       		cmp	#9		; this is counter
 8051   71E4   F0 0D       		beq	ZWIPCRC		; so set counter
 8052   71E6   C9 0F       	        cmp     #15             ; LINCNT?
 8053   71E8   F0 01       	        beq     ZIPLCT          ; then set it too
 8054   71EA   60          		rts			; just die then
 8055   71EB               	ZIPLCT:
 8056   71EB   A0 13       	        ldy     #WINLCNT        ; point to line count
 8057   71ED   D0 0B       	        bne     ZWINPUT2        ; and stash it away
 8058   71EF               	ZWIPCRF:
 8059   71EF   A0 09       	        ldy     #WINCRF+1       ; point to window's CR function
 8060   71F1   D0 02       	        bne     ZWINPUT1        ; and put it        
 8061   71F3               	ZWIPCRC:
  Tue Jun 13 1989 11:42                                                                                                  Page  122

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- WINDOW OPERATIONS ---"

 8062   71F3   A0 0B       		ldy	#WINCRC+1	; point to window's CR counter
 8063   71F5               	ZWINPUT1:
 8064   71F5   A5 68       		lda	ARG3+HI		; now get hi part
 8065   71F7   91 7A       		sta	(J),Y		; saved!
 8066   71F9   88          	        dey                     ; point to lo part
 8067   71FA               	ZWINPUT2:
 8068   71FA   A5 67       		lda	ARG3+LO		; start with lo part
 8069   71FC   91 7A       		sta	(J),Y		; save lo part
 8070   71FE               	ZWIPLCT:
 8071   71FE   4C A1 4D    	        jmp     GET_CURSOR      ; restore cursor/lincnt        
 8072   7201               		
 8073   7201               		END
 8074                      	
 8075   7201               		INCLUDE		DLINE.ASM
 8076   7201               		STTL	"--- Display line Routine ---"
 8077                      		PAGE
  Tue Jun 13 1989 11:42                                                                                                  Page  123

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8078                      	;
 8079                      	; some aux mem zero page stuff
 8080                      	;
 8081   7201               	DLVARS:
 8082          7201        	CHR_X	EQU	DLVARS		; (WORD) X pos for char (0-559)
 8083          7203        	ENDBIT	EQU	CHR_X+2 	; (BYTE) ending bit offset
 8084          7204        	WRPFLG	EQU	ENDBIT+1	; wrapping flag
 8085          7205        	SCRLFLG	EQU	WRPFLG+1	; scrolling flag
 8086          7206        	BUFFLG	EQU	SCRLFLG+1	; buffering flag
 8087          7207        	SAVEX	EQU	BUFFLG+1	; (BYTE) save original X
 8088          7208        	CHR_Y	EQU	SAVEX+1		; (BYTE) Working cursor Y pos
 8089          7209        	LINECHAR EQU	CHR_Y+1		; (BYTE) working char counter
 8090          720A        	BITTER	EQU	LINECHAR+1	; (BYTE) bit twiddler counter
 8091          720B        	INCFLG	EQU	BITTER+1	; (BYTE) ==1 if NEXT_SCR needed after setpos
 8092          720C        	SHOW_CURSOR EQU	INCFLG+1	; (BYTE) flag as to whether we are doing cursor
 8093          720D        	SCRCNT	EQU	SHOW_CURSOR+1	; (BYTE) screen buffer offset
 8094          720E        	SV_UND	EQU	SCRCNT+1	; (BYTE) spot to save underline flag
 8095          720F        	SV_INV	EQU	SV_UND+1	; (BYTE) save starting INVFLG
 8096          7210        	UNDERF  EQU     SV_INV+1        ; (BYTE) underline flag used internally
 8097          7211        	LINE_HEIGHT EQU	UNDERF+1	; (BYTE) counter for height
 8098          0011        	DLVARSL	EQU	LINE_HEIGHT-CHR_X+1
 8099                      	
 8100   7201               		BLKB	DLVARSL,0
 8101                      	
 8102   7212   07 06 05 04 03 	BIT_BITS: DB	7,6,5,4,3,2,1,0	; number significant bits in last byte
        7217   02 01 00 
 8103                      	
 8104   721A               	DISP_LINE:
 8105   721A   AD 0D 72    		lda	SCRCNT		; make sure there are characters
 8106   721D   D0 01       		bne	DPL1		; ayyup
 8107   721F   60          		rts			; no chars, don't do anything
 8108   7220               	DPL1:
 8109   7220   A9 00       		lda	#0		; start at zero
 8110   7222   85 09       		sta	CC_OFF		; which byte to use
 8111   7224   8D 0B 72    		sta	INCFLG		; and clear out inc'er flag
 8112   7227               		
 8113   7227   A9 08       		lda	#FONT_H-1	; do for height of char
 8114   7229   8D 11 72    		sta	LINE_HEIGHT	; height counter
 8115                      	
 8116   722C   A4 01       		ldy	SCRCY		; and starting y
 8117   722E   8C 08 72    		sty	CHR_Y		; saved
 8118   7231   A4 00       		ldy	SCRCX		; save x to
 8119   7233   8C 07 72    		sty	SAVEX		; save it
 8120   7236   A5 BB       		lda	INVFLG		; get current state
 8121   7238   8D 0F 72    		sta	SV_INV		; and save it
 8122   723B   A5 BA       	        lda     UNDFLG          ; get current underline state
 8123   723D   8D 0E 72    	        sta     SV_UND          ; and save it too
 8124                      	
 8125   7240   AD A5 6C    		lda	CURSFLG		; changed x pos?
 8126   7243   F0 12       	 	beq	DPL2		; no new figgering
 8127   7245   A2 00       		ldx	#0		
 8128   7247   8E 02 72    		stx	CHR_X+HI	; clear out msb
 8129                      	
 8130   724A   A5 00       		lda	SCRCX		; get new cursor x pos
 8131   724C   0A          		asl	A		; *2
 8132   724D   2E 02 72    		rol	CHR_X+HI
 8133   7250   0A          		asl	A		; *4
 8134   7251   8D 01 72    		sta	CHR_X+LO
 8135   7254   2E 02 72    		rol	CHR_X+HI
 8136   7257               	DPL2:
 8137   7257   AD 01 72    		lda	CHR_X+LO
 8138   725A   85 00       		sta	SCRCX
 8139   725C   29 03       		and	#3		; pick up 2 bits rolling out
 8140   725E   8D 0A 72    		sta	BITTER		; what to add
 8141   7261   AD 02 72    		lda	CHR_X+HI
 8142   7264   4A          		lsr	A		; /2
 8143   7265   66 00       		ror	SCRCX
 8144   7267   4A          		lsr	A		; /4
 8145   7268   66 00       		ror	SCRCX
 8146   726A   20 78 5E    		jsr	SETPOS		; set up pointers
 8147                      	
 8148   726D   AD 0A 72    		lda	BITTER		; get extra
 8149   7270   18          		clc			; add in
 8150   7271   65 11       		adc	BITOFF		; normal bit offset
 8151   7273   8D 0A 72    		sta	BITTER		; and make it new one
  Tue Jun 13 1989 11:42                                                                                                  Page  124

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8152   7276   C9 07       		cmp	#7		; but can't be greater than 6
 8153   7278   90 08       		bcc	DO_LINE		; okay, it's not
 8154   727A   8D 0B 72    		sta	INCFLG		; show needing NEXT_SCR call
 8155   727D   E9 07       		sbc	#7		; so shrink it
 8156   727F   8D 0A 72    		sta	BITTER		; save it
 8157   7282               	DO_LINE:
 8158   7282   20 78 5E    		jsr	SETPOS		; set up pointers
 8159   7285   AD 0B 72    		lda	INCFLG		; do we need to go one more?
 8160   7288   F0 03       		beq	DOL1		; nope
 8161   728A   20 1D 5E    		jsr	NEXT_SCR	; and point to next screen byte
 8162   728D               	DOL1:
 8163   728D   AE 0A 72    	 	ldx	BITTER		; get bit off set
 8164   7290   86 11       		stx	BITOFF		; and save here
 8165   7292   A9 00       		lda	#0		; init a few things
 8166   7294   85 13       		sta	SCR_DATA	; init screen data byte
 8167   7296   8D 09 72    		sta	LINECHAR	; which character on the line 
 8168   7299   85 0F       		sta	CH_OFFSET		; which byte in line on screen
 8169   729B   85 07       		sta	LINE_X+LO	; X pos of line
 8170   729D   85 08       		sta	LINE_X+HI	; part 2
 8171   729F   8D 10 72    	        sta     UNDERF          ; make sure this be zero
 8172                      	
 8173   72A2   AD 0F 72    		lda	SV_INV		; get starting INV state
 8174   72A5   85 BB       		sta	INVFLG		; okay!
 8175   72A7   AD 0E 72    	        lda     SV_UND          ; get starting UNDERLINE state
 8176   72AA   85 BA       	        sta     UNDFLG          ; and restart it
 8177                      	
 8178   72AC   C6 0F       		dec	CH_OFFSET		; inclusive count
 8179   72AE   A6 11       		ldx	BITOFF		; make bitoff be a count
 8180   72B0   BD 12 72    		lda	BIT_BITS,X	; get count
 8181   72B3   AA          		tax			; x is bit counter
 8182   72B4               	CHARL:
 8183   72B4   AC 09 72    		ldy	LINECHAR	; get the char
 8184   72B7   CC 0D 72    		cpy	SCRCNT		; done with line?
 8185   72BA   D0 03       		bne	CHARL1		; nope
 8186   72BC   4C 60 73    		jmp	COPYL		; okay, move onto screen
 8187   72BF               	CHARL1:
 8188   72BF   EE 09 72    		inc	LINECHAR	; point to next one
 8189   72C2   B9 80 02    		lda	SCRBUFF,Y	; got it
 8190   72C5   10 06       		bpl	CHARL3		; not a highlight char
 8191                      	
 8192   72C7   20 40 70    		jsr	HLIGHT		; so check it out
 8193   72CA   4C B4 72    		jmp	CHARL		; done
 8194   72CD               	CHARL3:
 8195   72CD   C9 20       		cmp	#SPACE		; is it a highlight char?
 8196   72CF   90 E3       		bcc	CHARL		; ignore this one then
 8197   72D1               	CHARL2:
 8198   72D1   A8          		tay			; use as index
 8199   72D2   B9 55 63    		lda	CHADR_H,Y	; get high part of address
 8200   72D5   85 1D       		sta	CHPTR+HI	; point to it
 8201   72D7   B9 D4 63    		lda	CHADR_L,Y	; get lo part
 8202   72DA   85 1C       		sta	CHPTR+LO	; save it
 8203   72DC   B9 53 64    		lda	CHWID,Y		; get how wide the char is
 8204   72DF   85 C9       		sta	CW		; save it
 8205   72E1   A5 09       		lda	CC_OFF		; to get data
 8206   72E3   A4 C9       		ldy	CW		; see how wide the char is
 8207   72E5   C0 0A       		cpy	#10		; if <= 8, only one byte of info
 8208   72E7   90 01       		bcc	CHRLCW		; it is, so skip shift
 8209   72E9   0A          	 	asl	A		; *2 for bigger chars
 8210   72EA               	CHRLCW:
 8211   72EA   A8          		tay			; get the index
 8212   72EB   B1 1C       		lda	(CHPTR),Y	; get first byte
 8213   72ED   85 C7       		sta	CHAR_D1		; part one
 8214   72EF   C8          		iny			; point to next part
 8215   72F0   B1 1C       		lda	(CHPTR),Y	; get second byte
 8216   72F2   85 C8       		sta	CHAR_D2		; and save it
 8217   72F4   A5 C9       		lda	CW		; get width back
 8218   72F6   C9 0A       		cmp	#10		; if <= 8 zero byte 2 of char data
 8219   72F8   B0 04       		bcs	CHRLCW1		; nope
 8220   72FA   A9 00       		lda	#0		; clear out byte 2
 8221   72FC   85 C8       		sta	CHAR_D2		; okay
 8222   72FE               	CHRLCW1:
 8223   72FE   A5 C1       		lda	FONTFLG		; is this monospacing?
 8224   7300   F0 28       		beq	CHRLFX		; nope
 8225                      	;
 8226                      	; if monospacing, see if it char is < mono width, and try to split
  Tue Jun 13 1989 11:42                                                                                                  Page  125

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8227                      	; the difference if so
 8228                      	;
 8229   7302   C5 C9       		cmp	CW		; check against current width
 8230   7304   B0 12       		bcs	CHRLF0		; CW < monowidth, so center
 8231                      	;
 8232                      	; too big, so take a little off front end too
 8233                      	;
 8234   7306   A5 C9       		lda	CW		; get current width
 8235   7308   38          		sec			; get ready for subbing
 8236   7309   E9 0C       		sbc	#MONOFONT_W	; take away mono width
 8237   730B   4A          		lsr	A		; /2 to get front half
 8238   730C   A8          		tay			; use as counter
 8239   730D   F0 17       		beq	CHRLF1		; nothing to do
 8240   730F               	CHRLFX1:
 8241   730F   06 C8       		asl	CHAR_D2		; step to the left
 8242   7311   26 C7       		rol	CHAR_D1		; pick up char
 8243   7313   88          		dey			; count one
 8244   7314   D0 F9       		bne	CHRLFX1		; do next one
 8245   7316   F0 0E       		beq	CHRLF1		; all done
 8246   7318               	CHRLF0:
 8247   7318   38          		sec			; do sub
 8248   7319   E5 C9       		sbc	CW		; subtract CW
 8249   731B   4A          		lsr	A		; /2 to get front part
 8250   731C   A8          		tay			; put in counter
 8251   731D   F0 07       		beq	CHRLF1		; no need to do anything
 8252   731F               	CHRLFL:
 8253   731F   46 C7       		lsr	CHAR_D1		; shift to right
 8254   7321   66 C8       		ror	CHAR_D2		; this part too
 8255   7323   88          		dey			; count shift
 8256   7324   D0 F9       		bne	CHRLFL		; not done shifting yet
 8257   7326               	CHRLF1:
 8258   7326   A9 0C       		lda	#MONOFONT_W	; get mono font width
 8259   7328   85 C9       		sta	CW		; chop at mono width
 8260   732A               	CHRLFX:
 8261   732A   AD 11 72    		lda	LINE_HEIGHT	; if == 0, then pick up underlining
 8262   732D   D0 05       		bne	CHRL3		; nope
 8263                      	
 8264   732F   A5 BA       		lda	UNDFLG		; get underlining flag
 8265   7331   8D 10 72    		sta	UNDERF		; and mark for later
 8266   7334               	CHRL3:
 8267   7334   A5 13       		lda	SCR_DATA	; get starting data
 8268   7336               	DATAL:
 8269   7336   26 C8       		rol	CHAR_D2		; it's a step to the left
 8270   7338   26 C7       		rol	CHAR_D1		; nother one
 8271   733A   6A          		ror	A		; and put into screen byte
 8272   733B   45 BB       		eor	INVFLG		; pick up inversing
 8273   733D   0D 10 72    		ora	UNDERF		; pick up underline flag
 8274   7340   E6 07       		inc	LINE_X+LO	; next X pos too
 8275   7342   D0 02       		bne	DATAL0		; no wrap
 8276   7344   E6 08       		inc	LINE_X+HI	; wrapped
 8277   7346               	DATAL0:
 8278   7346   CA          		dex			; next bit pos
 8279   7347   D0 0C       		bne	DATAL1		; nope
 8280                      	;
 8281                      	; save the byte and point to next byte
 8282                      	;
 8283   7349               	STCH:
 8284   7349   4A          		lsr	A		; put in lower 7 bits
 8285   734A   E6 0F       		inc	CH_OFFSET		; point to next one
 8286   734C   A4 0F       		ldy	CH_OFFSET		; get current offset
 8287   734E   99 00 1F    		sta	SCR_LINE,Y	; save in line
 8288   7351   A2 07       		ldx	#7		; and start bitoff at 7
 8289   7353   A9 00       		lda	#0		; clear a few locals
 8290   7355               	DATAL1:
 8291   7355   C6 C9       		dec	CW		; well?
 8292   7357   30 1F       		bmi	COPYL1		; all done, start copying
 8293   7359   D0 DB       		bne	DATAL		; nope
 8294   735B   85 13       		sta	SCR_DATA	; save current screen byte stuff here
 8295   735D   4C B4 72    		jmp	CHARL		; do next char
 8296   7360               	COPYL:
 8297   7360   A5 07       		lda	LINE_X+LO	; see if we have any at all
 8298   7362   05 08       		ora	LINE_X+HI	; well, did we go anywhere?
 8299   7364   F0 21       		beq	LINE_EXIT	; then quit
 8300   7366   BD 12 72    		lda	BIT_BITS,X	; get number of significant bits
 8301   7369   8D 03 72    		sta	ENDBIT		; save this one
  Tue Jun 13 1989 11:42                                                                                                  Page  126

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8302   736C   E0 07       		cpx	#7		; has it been renewed?
 8303   736E   F0 08       		beq	COPYL1		; no last byte
 8304   7370   A5 13       		lda	SCR_DATA	; get screen data
 8305   7372               	COPYSH:
 8306   7372   4A          		lsr	A		; put down low, please
 8307   7373   CA          		dex			; one more
 8308   7374   D0 FC       		bne	COPYSH		; and do it again
 8309   7376   F0 D1       		beq	STCH		; now save this char
 8310   7378               	COPYL1:
 8311   7378   20 4C 61    		jsr	COPY_SCRL	; copy SCR_LINE to screen
 8312   737B               	LED2:
 8313   737B   E6 01       		inc	SCRCY		; point to next line	
 8314   737D   CE 11 72    		dec	LINE_HEIGHT	; count this line
 8315   7380   30 05       		bmi	LINE_EXIT	; all done!
 8316                      	
 8317   7382   E6 09       		inc	CC_OFF		; point to next byte
 8318   7384   4C 82 72    		jmp	DO_LINE		; and do next line
 8319   7387               	LINE_EXIT:
 8320   7387   AE 07 72    		ldx	SAVEX		; get x back
 8321   738A   86 00       		stx	SCRCX		; restore it
 8322                      	
 8323   738C   AD 0C 72    		lda	SHOW_CURSOR	; are we just doing cursor?
 8324   738F   D0 14       		bne	DLXX		; yes, don't change char pos
 8325                      	
 8326   7391   18          		clc			; add in length of this line
 8327   7392   A5 07       		lda	LINE_X+LO	; get length of line
 8328   7394   6D 01 72    		adc	CHR_X+LO	; add to start pos
 8329   7397   8D 01 72    		sta	CHR_X+LO	; save it
 8330   739A   A5 08       		lda	LINE_X+HI	; and the MSB
 8331   739C   6D 02 72    		adc	CHR_X+HI	; okay
 8332   739F   8D 02 72    		sta	CHR_X+HI	; save for a rainy day
 8333   73A2   20 B3 73    		jsr	GET_SCRCX	; set SCRCX back up
 8334   73A5               	DLXX:
 8335   73A5   AD 08 72    		lda	CHR_Y		; restore the 
 8336   73A8   85 01       		sta	SCRCY		; y pos
 8337   73AA   A9 00       		lda	#0		; clear out counter
 8338   73AC   8D 0D 72    		sta	SCRCNT		; okay
 8339   73AF   8D A5 6C    		sta	CURSFLG		; reset this flag too
 8340   73B2   60          		rts
 8341                      	
 8342   73B3               	GET_SCRCX:
 8343   73B3   AD 01 72    		lda	CHR_X+LO	; pick this back up
 8344   73B6   85 00       	        sta     SCRCX
 8345   73B8   AD 02 72    		lda	CHR_X+HI	; /2
 8346   73BB   4A          		lsr	A       	; pick up remainder
 8347   73BC   66 00       		ror	SCRCX   	; /4
 8348   73BE   4A          		lsr	A		; pick up remainder
 8349   73BF   66 00       		ror	SCRCX		; got it
 8350   73C1   AD 01 72    		lda	CHR_X+LO	; any remainder?
 8351   73C4   29 03       		and	#3		; well?
 8352   73C6   F0 DD       		beq	DLXX		; nope
 8353   73C8   E6 00       		inc	SCRCX		; point to next pos
 8354   73CA   60          		rts
 8355                      	
 8356                      	;
 8357                      	; DO_CURSOR - read in the screen byte, XOR cursor data, store it
 8358                      	;
 8359   73CB               	DO_CURSOR:
 8360   73CB   A0 00       		ldy	#0		; and zero y
 8361   73CD   84 10       		sty	DATALOOP	; init this counter
 8362   73CF               	DOCLOOP:
 8363                      	
 8364   73CF   A0 00       		ldy	#0		; must use Y
 8365   73D1   A6 8E       		ldx	FPCBNK		; what bank
 8366   73D3   BD 54 C0    		lda	PAGE2SW,X	; select it
 8367   73D6   B1 8C       		lda	(FPC),Y		; okay, get byte
 8368   73D8   A6 10       		ldx	DATALOOP	; get offset
 8369   73DA   5D 00 1F    		eor	SCR_LINE,X	; get data
 8370   73DD   91 8C       		sta	(FPC),Y		; save data
 8371   73DF   20 1D 5E    		jsr	NEXT_SCR	; point to next screen byte
 8372   73E2   E6 10       		inc	DATALOOP	; point to next char
 8373   73E4   C6 0F       		dec	CH_OFFSET	; count one char
 8374   73E6   10 E7       		bpl	DOCLOOP		; all done with this line?
 8375   73E8   AD 54 C0    		lda	PAGE2SW+MAIN	; make sure we are point to MAIN
 8376   73EB   60          		rts
  Tue Jun 13 1989 11:42                                                                                                  Page  127

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Display line Routine ---"

 8377                      	
 8378   73EC               		END
 8379                      	
 8380   73EC               		INCLUDE		PIC.ASM
 8381   73EC               		STTL "--- Picture Op Codes ---"
 8382                      		PAGE
  Tue Jun 13 1989 11:42                                                                                                  Page  128

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8383                      	PFILE_RD:			; for READING files
 8384   73EC   04          		db	4		; 4 parameters
 8385   73ED   00          		db	0		; refnum
 8386   73EE   0008        		dw	IOBUFF		; read into io buffer
 8387   73F0   0004        		dw	$400		; 1Kb buffer
 8388   73F2   0000        		dw	0		; length actually read
 8389   73F4               	PFSEEK:
 8390   73F4   02          		db	2	        ; 2 pararmeters
 8391   73F5   00          		db	0	        ; refnum
 8392   73F6   00 00 00    		db 	0,0,0	        ; 3 byte new file pos
 8393   73F9   0000        	PICCNT: dw	0	        ; counter of the entries
 8394   73FB   00          	PF_REFNUM: db     0             ; place to store refnum
 8395   73FC   FF          	PF_FID: db      $FF             ; File ID of local directory data
 8396   73FD   00          	P_IDX:	db 	0	
 8397   73FE   00          	P_BCNT:	db	0
 8398   73FF   00          	P_LOFF:	db	0
 8399   7400   00          	GBL_FLAG: db    0               ; found global directory?
 8400   7401   00          	PIC_FLAG: db    0               ; found pictures?
 8401   7402   00          	PF_NAME: db     0                       ; name we are looking at
 8402   7403   00          	        db      0                       ; name we found
 8403                      	
 8404   7404               	PICINFO:
 8405   7404               		ds	PLDSIZE ; get room for picture data
 8406                      	
 8407   740C   00          	TRANSCLR: DB	0	; transparent color
 8408   740D               	UNKPIC:
 8409                      	
 8410   740D   0D 55 6E 6B 6E 		db	EOL,"Unknown Picture #"
        7412   6F 77 6E 20 50 
        7417   69 63 74 75 72 
        741C   65 20 23 
 8411          0012        	UNKPICL	EQU	$-UNKPIC
 8412   741F               	ZDISPL:
 8413   741F   20 BE 55    		jsr	CLRBUF			; put out any and all text
 8414                      	
 8415   7422   20 76 77    		jsr	GET_PICINF		; get the necessary data
 8416   7425   90 18       		bcc	ZDSP1			; everything just fine
 8417                      	
 8418   7427               		DLINE	UNKPIC			; unknown picture number error
 8419   7427   A2 0D       		ldx	#<UNKPIC	; get part of UNKPIC
 8420   7429   A9 74       		lda	#>UNKPIC	; get other part of string
 8421          [01]        		IFMA	2		; check to see if length passed in
 8422                      		ldy			; then just fetch it
 8423          [01]        		ELSE
 8424   742B   A0 12       		ldy	#UNKPICL	; get length of string
 8425          [00]        		ENDIF
 8426   742D   20 5B 4C    		jsr	DLINE		; print the string
 8427   7430               		.MACEND
 8428   7430   A5 64       		lda	ARG1+HI			; get MSB
 8429   7432   20 C3 47    		jsr	HEXNUM			; print it
 8430   7435   A5 63       		lda	ARG1+LO			; and LSB
 8431   7437   20 C3 47    		jsr 	HEXNUM
 8432   743A   A9 14       		lda	#$14			; bad picture number error
 8433   743C   4C F9 51    		jmp	ZERROR			; and croak
 8434   743F               	ZDSP1:
 8435   743F   20 8F 4D    		jsr	SAVE_CURSOR		; save the cursor
 8436                      	
 8437   7442   A9 00       		lda	#0			; show no cursor change
 8438   7444   8D A5 6C    		sta	CURSFLG			; start with none, anyway
 8439                      	
 8440   7447   C6 62       		dec	NARGS			; x,y pos passed?
 8441   7449   F0 30       		beq	ZDSP10			; nope, just use as is
 8442                      	
 8443   744B   A5 65       		lda	ARG2+LO			; get passed y pos
 8444   744D   F0 12       		beq	ZDSP01			; don't change
 8445   744F   85 01       		sta	SCRCY			; change, then
 8446   7451   C6 01       		dec	SCRCY			; zero base it
 8447   7453   A0 00       		ldy	#WINTOP			; get top edge of window
 8448   7455   B1 05       		lda	(WINDOW),Y		; got it
 8449   7457   18          		clc				; get ready for add
 8450   7458   65 01       		adc	SCRCY			; add the offset
 8451   745A   85 01       		sta	SCRCY			; and make it Y pos
 8452   745C   A9 01       		lda	#1			; show cursor change anyway
 8453   745E   8D A5 6C    		sta	CURSFLG			; okay, we did
 8454   7461               	ZDSP01:
  Tue Jun 13 1989 11:42                                                                                                  Page  129

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8455   7461   C6 62       		dec	NARGS			; x pos passed?
 8456   7463   F0 16       		beq	ZDSP10			; nope
 8457                      	
 8458   7465   A5 67       		lda	ARG3+LO			; get x pos
 8459   7467   F0 12       		beq	ZDSP10			; if == 0, don't change
 8460   7469   85 00       		sta	SCRCX			; set as passed
 8461   746B   C6 00       		dec	SCRCX			; zero base it
 8462   746D   A0 01       		ldy	#WINLEFT		; get left hand edge of window
 8463   746F   B1 05       		lda	(WINDOW),Y		; got it
 8464   7471   18          		clc				; get ready for add
 8465   7472   65 00       		adc	SCRCX			; add the offset
 8466   7474   85 00       		sta	SCRCX			; and make it X pos
 8467   7476   A9 01       		lda	#1			; show cursor change anyway
 8468   7478   8D A5 6C    		sta	CURSFLG			; okay, we did
 8469   747B               	ZDSP10:
 8470   747B   A5 00       		lda	SCRCX			; get current X
 8471   747D   48          		pha				; save it
 8472   747E   18          		clc				; adding
 8473   747F   6D 06 74    		adc	PICINFO+PLDWID		; add in pic width
 8474   7482   85 00       		sta	SCRCX			; save here
 8475   7484   68          		pla				; get start X pos back
 8476   7485   85 00       		sta	SCRCX			; restored
 8477   7487               	ZDSP101:
 8478   7487   AD 08 74    		lda 	PICINFO+PLDFLG		; get flag byte
 8479   748A   29 01       		and	#1			; is there a transparent color?
 8480   748C   D0 04       		bne	ZDSP11			; ayyup
 8481   748E   A9 FF       		lda	#$FF			; make TRANSCLR be $FF
 8482   7490   D0 07       		bne	ZDSP12			; okay
 8483   7492               	ZDSP11:
 8484   7492   AD 08 74    		lda	PICINFO+PLDFLG		; get hi byte of flag word
 8485   7495   4A          		lsr	A			; put in lower byte
 8486   7496   4A          		lsr	A			; put in lower byte
 8487   7497   4A          		lsr	A			; put in lower byte
 8488   7498   4A          		lsr	A			; put in lower byte
 8489   7499               	ZDSP12:
 8490   7499   8D 0C 74    		sta	TRANSCLR		; save transparent color
 8491                      	
 8492   749C   AD 09 74    		lda	PICINFO+PLDPTR		; MSB of offset
 8493   749F   8D F8 73    		sta	PFSEEK+SM_FPOS+2	; MSB of seek
 8494   74A2   AD 0A 74    		lda	PICINFO+PLDPTR+1	; Middle
 8495   74A5   29 FE       	        and     #$FE                    ; seek only to 512byte boundary
 8496   74A7   8D F7 73    		sta	PFSEEK+SM_FPOS+1
 8497                      	
 8498   74AA               		SET_MARK PFSEEK			; go to pic data
 8499   74AA               		PRODOS	$CE, PFSEEK
 8500   74AA   20 00 BF    		jsr	$BF00	; ProDOS handler
 8501   74AD   CE          		DB	$CE	; ProDOS function code
 8502   74AE   F473        		DW	PFSEEK	; Function Parameter Block address
 8503   74B0               		.MACEND
 8504   74B0               		.MACEND
 8505   74B0   A9 02       		lda	#>PIC1BUF		; set up pointers to decode buffers
 8506   74B2   85 7B       		sta	J+HI
 8507   74B4   A9 73       		lda	#<PIC1BUF
 8508   74B6   85 7A       		sta	J+LO
 8509   74B8   A9 1C       		lda	#>PIC2BUF
 8510   74BA   85 7D       		sta	K+HI
 8511   74BC   A9 74       		lda	#<PIC2BUF
 8512   74BE   85 7C       		sta	K+LO
 8513   74C0   A9 00       		lda	#0			; start line at zero
 8514   74C2   8D FF 73    		sta	P_LOFF			; done
 8515   74C5   A0 8B       		ldy	#MAXWIDTH-1		; clear out width buffer
 8516   74C7               	ZDLI:
 8517   74C7   91 7A       		sta	(J),Y			; init 'previous line' buffer to zero
 8518   74C9   88          		dey				; down one
 8519   74CA   D0 FB       		bne	ZDLI
 8520   74CC   91 7A       		sta	(J),Y			; get last one
 8521                      	
 8522   74CE   A9 08       		lda	#>IOBUFF		; now get data buffer address
 8523   74D0   85 7F       		sta	L+HI
 8524   74D2   A9 04       		lda	#4			; 4 pages read in at once
 8525   74D4   8D FE 73    		sta	P_BCNT			; okay
 8526   74D7   A9 03       		lda	#3			; 3 bytes of width data start it
 8527   74D9   18          	        clc                             ; doing add
 8528   74DA   6D 0B 74    		adc	PICINFO+PLDPTR+2	; pick up LSB pointer
 8529   74DD   8D FD 73    		sta	P_IDX			; start index
  Tue Jun 13 1989 11:42                                                                                                  Page  130

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8530   74E0   90 05       	        bcc     ZDLPCC                  ; no wrap
 8531   74E2   E6 7F       	        inc     L+HI                    ; start at second one
 8532   74E4   CE FE 73    	        dec     P_BCNT                  ; one less block
 8533   74E7               	ZDLPCC:
 8534   74E7   AD 0A 74    		lda	PICINFO+PLDPTR+1        ; tells which block it is in               
 8535   74EA   29 01       	        and     #$01                    ; pick up which 256 block
 8536   74EC   F0 05       	        beq     ZDLP0                   ; start at first one
 8537   74EE   E6 7F       	        inc     L+HI                    ; start at next one
 8538   74F0   CE FE 73    	        dec     P_BCNT                  ; one less block
 8539   74F3               	ZDLP0:
 8540   74F3   A9 00       		lda	#<IOBUFF
 8541   74F5   85 7E       		sta	L+LO
 8542   74F7   A9 03       	        lda     #RETRY_COUNT    ; set retry
 8543   74F9   85 0E       	        sta     NY_DATA         ; just use this for now
 8544   74FB               	ZDLPRD:
 8545   74FB               		READ	PFILE_RD		; read in 1kb worth of data
 8546   74FB               		PRODOS	$CA, PFILE_RD
 8547   74FB   20 00 BF    		jsr	$BF00	; ProDOS handler
 8548   74FE   CA          		DB	$CA	; ProDOS function code
 8549   74FF   EC73        		DW	PFILE_RD	; Function Parameter Block address
 8550   7501               		.MACEND
 8551   7501               		.MACEND
 8552   7501   90 05       		bcc	ZDECLP			; everything went just fine
 8553   7503   20 F7 46    	        jsr     RETRY                   ; must we?
 8554   7506   90 F3       	        bcc     ZDLPRD                  ; yes
 8555   7508               	ZDECLP:
 8556   7508   AC FD 73    		ldy	P_IDX			; get data index
 8557   750B   B1 7E       		lda	(L),Y			; get data byte
 8558   750D   85 71       		sta	ARG8			; save here
 8559   750F   C8          		iny				; point to next one
 8560   7510   D0 06       		bne	ZDCLP0			; okay, use offset
 8561   7512   20 1E 76    		jsr	NEXT_PICB		; read in next block
 8562   7515   90 01       		bcc	ZDCLP0			; everything went fine
 8563   7517   60          		rts				; return if not
 8564   7518               	ZDCLP0:
 8565   7518   B1 7E       		lda	(L),Y			; is this count or data?
 8566   751A   C9 10       		cmp	#16			; if <= 15, previous one was data 
 8567   751C   B0 04       		bcs	ZDCL2			; nope, must be compressed
 8568   751E   A9 0F       		lda	#15			; show 1 bytes
 8569   7520   D0 0B       		bne	ZDCL3			; and count this one
 8570   7522               	ZDCL2:
 8571   7522   C8          		iny				; point to next byte
 8572   7523   D0 08       		bne	ZDCL3			; okay, no wrap
 8573   7525   48          		pha				; save A
 8574   7526   20 1E 76    		jsr	NEXT_PICB		; check about nother block
 8575   7529   68          		pla				; get A back
 8576   752A   90 01       		bcc	ZDCL3			; everything came out okay
 8577   752C   60          		rts				; problems, return
 8578   752D               	ZDCL3:
 8579   752D   8C FD 73    		sty	P_IDX			; save index
 8580   7530   38          		sec				; get ready for sub
 8581   7531   E9 0E       		sbc	#14			; make good counter
 8582   7533   AA          		tax				; put count into x
 8583   7534               	ZDCLPC:
 8584   7534   AC FF 73    		ldy	P_LOFF			; get line offset
 8585   7537   A5 71       		lda	ARG8			; get data byte
 8586   7539   51 7A       		eor	(J),Y			; XOR with previous line
 8587   753B   91 7C       		sta	(K),Y			; and save away
 8588   753D   C8          		iny				; next offset
 8589   753E   8C FF 73    		sty	P_LOFF			; save Y
 8590   7541   CC 06 74    		cpy	PICINFO+PLDWID		; end of line?
 8591   7544   D0 10       		bne	ZDCLPC1			; nope
 8592   7546   20 5E 75    		jsr	COPY_PIC		; copy line into screen
 8593   7549   A5 01       		lda	SCRCY			; past bottom?
 8594   754B   C9 BF       		cmp	#MAXHEIGHT-1		; well?
 8595   754D   F0 0C       		beq	ZDCLPX			; truncate at bottom then
 8596   754F   E6 01       		inc	SCRCY			; down one line
 8597   7551   CE 07 74    		dec	PICINFO+PLDHGHT		; count line
 8598   7554   F0 05       		beq	ZDCLPX			; all done then
 8599   7556               	ZDCLPC1:
 8600   7556   CA          		dex				; count down counter
 8601   7557   D0 DB       		bne	ZDCLPC			; do this byte again
 8602   7559   F0 AD       		beq	ZDECLP			; check next byte
 8603   755B               	ZDCLPX:
 8604   755B   4C A1 4D    		jmp	GET_CURSOR		; restore the cursor
  Tue Jun 13 1989 11:42                                                                                                  Page  131

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8605                      	
 8606   755E               	COPY_PIC:
 8607   755E   8A          		txa				; save x
 8608   755F   48          		pha 
 8609   7560   A5 00       		lda	SCRCX			; get start X pos
 8610   7562   48          		pha				; okay, saved
 8611   7563   A9 00       		lda	#0			; start offset at zero
 8612   7565   85 0E       		sta	NY_DATA 		; and into data buffer
 8613   7567               	CPICLOOP:
 8614   7567   20 78 5E    		jsr	SETPOS			; point to correct line
 8615   756A   A6 11       		ldx	BITOFF			; get starting offset
 8616   756C   8E 0A 72    		stx	BITTER			; bit offset for COPY_SCRL to use
 8617   756F   BD 12 72    		lda	BIT_BITS,X		; get starting bit counter
 8618   7572   AA          		tax				; okay, we did
 8619   7573   A9 8C       		lda	#MAXWIDTH		; don't let screen wrap
 8620   7575   38          		sec				; doing sub
 8621   7576   E5 00       		sbc	SCRCX			; get current X pos
 8622   7578   85 10       		sta	DATALOOP		; only use this many pixels
 8623   757A   A0 00       		ldy	#0			; start with first byte
 8624   757C   84 13       		sty	SCR_DATA		; data starts with zero
 8625   757E   88          		dey				; inclusive count
 8626   757F   84 0F       		sty	CH_OFFSET		; reset line offset
 8627   7581   A4 0E       		ldy	NY_DATA 		; start Y out
 8628   7583   20 AE 75    		jsr	PIC2SCR			; move line to screen
 8629                      	
 8630   7586   A4 0E       		ldy	NY_DATA 		; current offset
 8631   7588   CC 06 74    		cpy	PICINFO+PLDWID		; did we finish whole line?
 8632   758B   B0 02       		bcs	COPYPIC1		; yup, so wrap things up
 8633   758D   90 D8       		bcc	CPICLOOP		; and continue with line
 8634   758F               	COPYPIC1:
 8635   758F   A5 7B       		lda	J+HI			; get previous line
 8636   7591   48          	 	pha				; save addr
 8637   7592   A5 7D       		lda	K+HI			; make current line be previous
 8638   7594   85 7B       		sta	J+HI
 8639   7596   68          		pla				; get old previous line back
 8640   7597   85 7D       		sta	K+HI			; make it be new current line
 8641   7599   A5 7A       		lda	J+LO			; get previous line
 8642   759B   48          		pha				; and save it
 8643   759C   A5 7C       		lda	K+LO
 8644   759E   85 7A       		sta	J+LO			; okay, it is
 8645   75A0   68          		pla	
 8646   75A1   85 7C       		sta	K+LO			; and save new one
 8647   75A3   A9 00       		lda	#0			; pic offset is zero
 8648   75A5   8D FF 73    		sta	P_LOFF			; done
 8649   75A8   68          		pla				; get start X back
 8650   75A9   85 00       		sta	SCRCX			; restored
 8651   75AB   68          		pla				; get X reg back
 8652   75AC   AA          		tax
 8653   75AD   60          		rts	
 8654                      	
 8655   75AE               	PIC2SCR:
 8656   75AE   A9 04       		lda	#4			; 4 bits per pixel
 8657   75B0   85 6F       		sta	ARG7			; use zero page
 8658   75B2   B1 7C       		lda	(K),Y			; get data byte
 8659   75B4   CD 0C 74    		cmp	TRANSCLR		; is it transparent?
 8660   75B7   D0 1D       		bne	CPYPL1			; nope
 8661   75B9               	P2LOOP:
 8662   75B9   E6 00       	        inc     SCRCX                   ; point to next pixel
 8663   75BB   C8          		iny				; next pixel
 8664   75BC   CC 06 74    		cpy	PICINFO+PLDWID		; done with line?
 8665   75BF   B0 07       		bcs	P2LP1			; yup
 8666   75C1   B1 7C       		lda	(K),Y			; get it
 8667   75C3   CD 0C 74    		cmp	TRANSCLR		; still transparent?
 8668   75C6   F0 F1       		beq	P2LOOP			; ayyup
 8669   75C8               	P2LP1:
 8670   75C8   84 0E       		sty	NY_DATA 		; show where we ended up
 8671   75CA   60          	      	rts
 8672   75CB               	P2SLOOP:
 8673   75CB   B1 7C       		lda	(K),Y			; get data byte
 8674   75CD   CD 0C 74    		cmp	TRANSCLR		; is it transparent?
 8675   75D0   F0 35       		beq	CPYSL1X			; yes, so done with this
 8676   75D2   A0 04       		ldy	#4			; 4 bits per pixel
 8677   75D4   84 6F       		sty	ARG7			; use zero page
 8678   75D6               	CPYPL1:
 8679   75D6   0A          		asl	A			; shift to upper nybble
  Tue Jun 13 1989 11:42                                                                                                  Page  132

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8680   75D7   0A          		asl	A			; shift to upper nybble
 8681   75D8   0A          		asl	A			; shift to upper nybble
 8682   75D9   0A          		asl	A			; shift to upper nybble
 8683   75DA               	CPYSL:
 8684   75DA   0A          		asl	A			; shift into carry
 8685   75DB   66 13       		ror	SCR_DATA		; pick up carry
 8686   75DD   CA          		dex				; count it
 8687   75DE   D0 12       		bne	CPYSL1			; shift again, please
 8688   75E0               	CPYSLST:
 8689   75E0   48          		pha				; save byte
 8690   75E1   A5 13       		lda	SCR_DATA		; get screen  byte
 8691   75E3   4A          		lsr	A			; move down to last 7 bits
 8692   75E4   E6 0F       		inc	CH_OFFSET			; point to interesting byte
 8693   75E6   A4 0F       		ldy	CH_OFFSET			; get offset
 8694   75E8   99 00 1F    		sta	SCR_LINE,Y		; save into mem
 8695   75EB   A2 07       		ldx	#7			; and start bitoff at 7
 8696   75ED   A9 00       		lda	#0			; clear a few locals
 8697   75EF   85 13       		sta	SCR_DATA		; screen data
 8698   75F1   68          		pla				; get byte back
 8699   75F2               	CPYSL1:
 8700   75F2   C6 6F       		dec	ARG7			; count this bit
 8701   75F4   30 25       		bmi	CPYSLX			; all done
 8702   75F6   D0 E2       		bne	CPYSL			; not done with 'pixel' yet
 8703   75F8   E6 0E       		inc	NY_DATA 		; point to next one
 8704   75FA   E6 00       	        inc     SCRCX                   ; point to next pixel
 8705   75FC   A4 0E       		ldy	NY_DATA 		; next pixel
 8706   75FE   CC 06 74    		cpy	PICINFO+PLDWID		; finished with line yet?
 8707   7601   F0 04       		beq 	CPYSL1X			; yes, so move to screen
 8708   7603   C6 10       		dec	DATALOOP		; reached right edge of screen?
 8709   7605   D0 C4       		bne	P2SLOOP			; do next pixel
 8710   7607               	CPYSL1X:
 8711   7607   BD 12 72    		lda	BIT_BITS,X		; get me number of significant bits in this byte
 8712   760A   8D 03 72    		sta	ENDBIT			; show end bit
 8713   760D   E0 07       		cpx	#7			; is there a last byte to use?
 8714   760F   F0 0A       		beq	CPYSLX			; no last byte
 8715   7611   A5 13       		lda	SCR_DATA		; get screen data
 8716   7613               	CPYLSH:
 8717   7613   4A          		lsr	A			; put down low, please
 8718   7614   CA          		dex				; one more
 8719   7615   D0 FC       		bne	CPYLSH			; and do it again
 8720   7617   85 13       		sta	SCR_DATA		; save for later use
 8721   7619   F0 C5       		beq	CPYSLST			; now save this char
 8722   761B               	CPYSLX:
 8723   761B   4C 5D 61    		jmp	COPY_SCRL1		; copy to screen
 8724                      	
 8725   761E               	NEXT_PICB:
 8726   761E   48          		pha				; save a please
 8727                      	
 8728   761F   CE FE 73    		dec	P_BCNT			; done all four pages?
 8729   7622   D0 1E       		bne	NXTPX1			; nope
 8730                      	
 8731   7624   A9 03       	        lda     #RETRY_COUNT            ; set retry
 8732   7626   85 16       	        sta     RETRIES                 ; just use this for now
 8733                      	
 8734   7628   A9 08       		lda	#>IOBUFF		; reset data buffer address
 8735   762A   85 7F       		sta	L+HI
 8736   762C   A9 00       		lda	#<IOBUFF
 8737   762E   85 7E       		sta	L+LO
 8738   7630   A9 04       		lda	#4			; 4 pages read in at once
 8739   7632   8D FE 73    		sta	P_BCNT			; okay
 8740   7635               	NXTPRD:
 8741   7635               		READ	PFILE_RD		; read in 1kb worth of data
 8742   7635               		PRODOS	$CA, PFILE_RD
 8743   7635   20 00 BF    		jsr	$BF00	; ProDOS handler
 8744   7638   CA          		DB	$CA	; ProDOS function code
 8745   7639   EC73        		DW	PFILE_RD	; Function Parameter Block address
 8746   763B               		.MACEND
 8747   763B               		.MACEND
 8748   763B   90 07       		bcc	NXTPX			; everything went just fine
 8749   763D   20 F7 46    	        jsr     RETRY                   ; try again?
 8750   7640   90 F3       		bcc     NXTPRD                  ; okay, do it again
 8751   7642               	NXTPX1:
 8752   7642   E6 7F       		inc	L+HI			; point to next page
 8753   7644               	NXTPX:
 8754   7644   18          		clc				; make sure carry is clear
  Tue Jun 13 1989 11:42                                                                                                  Page  133

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8755   7645               	NXTPXR:
 8756   7645   A0 00       		ldy	#0			; start reading at beginnig of block
 8757   7647   68          		pla				; get [A] back
 8758   7648   60          		rts				; done
 8759                      	;
 8760                      	; GET_PDATA - go out and check the just opened file to see what kind,
 8761                      	;       if any, of picture data it has.  
 8762                      	;  [A] = REFNUM of the freshly opened file
 8763                      	;
 8764                      	
 8765   7649               	GET_PDATA:
 8766   7649   8D FB 73    	        sta     PF_REFNUM               ; save refnum for later usage
 8767   764C   A5 1F       	        lda     DSEGS+HI                ; save old one
 8768   764E   48          	        pha
 8769   764F   A5 1E       	        lda     DSEGS+LO
 8770   7651   48          	        pha
 8771   7652   AC B5 49    	        ldy     SAVENUM                 ; which file are we talking about
 8772   7655   88          	        dey                             ; zero base it
 8773   7656   98          	        tya
 8774   7657   29 0F       	        and     #$0F                    ; make sure DSEG is set
 8775   7659   0A          	        asl     A                       ; *2 for words
 8776   765A   A8          	        tay                             ; make it  index again
 8777   765B   B9 D1 1D    	        lda     DSKSEG+HI,Y             ; get MSB
 8778   765E   85 1F       	        sta     DSEGS+HI
 8779   7660   B9 D0 1D    	        lda     DSKSEG+LO,Y             ; and LSB
 8780   7663   85 1E       	        sta     DSEGS+LO
 8781   7665   20 6F 76    	        jsr     GO_GET_PDATA            ; actually do the work
 8782   7668   68          	        pla                             ; get old DSEG back
 8783   7669   85 1E       	        sta     DSEGS+LO     
 8784   766B   68          	        pla
 8785   766C   85 1F       	        sta     DSEGS+HI
 8786   766E               	GETPX:
 8787   766E   60          	        rts                             ; bye
 8788   766F               	GO_GET_PDATA:
 8789   766F   AD 00 74    	        lda     GBL_FLAG                ; is there already a global dir?
 8790   7672   D0 0A       	        bne     GTPG1                   ; yes, so don't check again
 8791   7674   A0 06       	        ldy     #SGTGPOF                ; first, check for global directory
 8792   7676   A9 DC       		lda	#>GBL_DIR		; start destination off here
 8793   7678   20 93 76    	        jsr     READ_IN_PDATA           ; go get global directory, if any
 8794   767B   8D 00 74    	        sta     GBL_FLAG                ; indicate whether there is a global
 8795   767E               	GTPG1:
 8796   767E   AD B5 49    	        lda     SAVENUM                 ; get which file is being opened
 8797   7681   29 0F       	        and     #$0F                    ; just make it binary
 8798   7683   CD FC 73    	        cmp     PF_FID                  ; same as the file we already have?
 8799   7686   F0 0A       	        beq     GETPGX                  ; yes, so don't bother
 8800   7688   A0 02       		ldy	#SGTPICOF		; point to picture offset
 8801   768A   A9 D0       		lda	#>PIC_DIR		; start destination off here
 8802   768C   20 93 76    	        jsr     READ_IN_PDATA           ; go get the data for local pictures
 8803   768F   8D 01 74    	        sta     PIC_FLAG                ; any picture data
 8804   7692               	GETPGX:
 8805   7692   60          	        rts
 8806                      	;
 8807                      	; READ_IN_PDATA - check for desired data being in file, and skip to it if
 8808                      	;       it is.  Then, read it in in 1Kb chunks, stashing it away into the
 8809                      	;       upper bank of the aux mem language card.
 8810                      	; Enter with:
 8811                      	;   [A] = Destination page
 8812                      	;   [Y] = Offset into Segment table 
 8813                      	;
 8814   7693               	READ_IN_PDATA:
 8815   7693   48          	        pha                             ; save destination page
 8816   7694   B1 1E       		lda	(DSEGS),Y		; get MSB
 8817   7696   8D F8 73    		sta	PFSEEK+SM_FPOS+2	; Byte 2
 8818   7699   C8          		iny				; point to LSB
 8819   769A   11 1E       		ora	(DSEGS),Y		; is there any pic data?
 8820   769C   D0 04       		bne	GTPD00			; yes
 8821   769E   68          	        pla                             ; get page back
 8822   769F   A9 00       	        lda     #0                      ; show not here
 8823   76A1   60          	        rts                             ; nope
 8824   76A2               	GTPD00:
 8825   76A2   B1 1E       		lda	(DSEGS),Y		; get it for shifting
 8826   76A4   0A          		asl	A			; *2
 8827   76A5   8D F7 73    		sta	PFSEEK+SM_FPOS+1	; stash away
 8828   76A8   2E F8 73    		rol	PFSEEK+SM_FPOS+2	; pick up carry
 8829   76AB   A9 00       		lda	#0			; clear out MSB
  Tue Jun 13 1989 11:42                                                                                                  Page  134

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8830   76AD   8D F1 73    		sta	PFILE_RD+RD_BUFFLEN+HI
 8831   76B0   8D F6 73    		sta	PFSEEK+SM_FPOS		; and LSB of seeking
 8832                      	
 8833   76B3   AD FB 73    	        lda     PF_REFNUM               ; get file ref number
 8834   76B6   8D ED 73    		sta	PFILE_RD+RD_REFNUM      ; and save it for reading and
 8835   76B9   8D F5 73    		sta	PFSEEK+SM_REFNUM	; for seeking
 8836                      	
 8837   76BC   A9 03       	        lda     #RETRY_COUNT    ; set retry
 8838   76BE   85 0E       	        sta     NY_DATA         ; just use this for now
 8839   76C0               	GTPDRD0:
 8840   76C0               		SET_MARK PFSEEK			; and go to beginning
 8841   76C0               		PRODOS	$CE, PFSEEK
 8842   76C0   20 00 BF    		jsr	$BF00	; ProDOS handler
 8843   76C3   CE          		DB	$CE	; ProDOS function code
 8844   76C4   F473        		DW	PFSEEK	; Function Parameter Block address
 8845   76C6               		.MACEND
 8846   76C6               		.MACEND
 8847                      	
 8848   76C6   A9 04       		lda	#4			; read in 4 256 blocks
 8849   76C8   8D F1 73    		sta	PFILE_RD+RD_BUFFLEN+HI	
 8850   76CB               		READ	PFILE_RD		; go get the next 4Kb worth
 8851   76CB               		PRODOS	$CA, PFILE_RD
 8852   76CB   20 00 BF    		jsr	$BF00	; ProDOS handler
 8853   76CE   CA          		DB	$CA	; ProDOS function code
 8854   76CF   EC73        		DW	PFILE_RD	; Function Parameter Block address
 8855   76D1               		.MACEND
 8856   76D1               		.MACEND
 8857   76D1   90 05       	        bcc     GTPD1                   ; fine
 8858   76D3   20 F7 46    	        jsr     RETRY                   ; well, do it again?
 8859   76D6   90 E8       	        bcc     GTPDRD0                 ; yes
 8860   76D8               	GTPD1:
 8861   76D8   68          	        pla                             ; get destination page back
 8862   76D9   C9 D0       	        cmp     #>PIC_DIR               ; if doing local directory, set up
 8863   76DB   D0 16       	        bne     GTPD2                   ;  picture count
 8864   76DD   AE 04 08    		ldx	IOBUFF+PHNLD		; get number of pictures
 8865   76E0   8E FA 73    		stx	PICCNT+HI		; save for count down too
 8866   76E3   AE 05 08    		ldx	IOBUFF+PHNLD+1		; and here is LSB
 8867   76E6   8E F9 73    		stx	PICCNT+LO		; saving for counting
 8868   76E9   AE 00 08    	        ldx     IOBUFF+PHFID            ; get file ID
 8869   76EC   8E FC 73    	        stx     PF_FID                  ; and save for later
 8870   76EF   A2 20       	        ldx     #(256/PLDSIZE)          ; how many entries in 256 bytes
 8871   76F1   D0 0E       	        bne     GTPD3                   ; done
 8872   76F3               	GTPD2:
 8873   76F3   AE 00 08    	        ldx     IOBUFF                  ; get MSB of how many
 8874   76F6   8E FA 73    	        stx     PICCNT+HI               ; show me
 8875   76F9   AE 01 08    	        ldx     IOBUFF+1                ; get LSB of count
 8876   76FC   8E F9 73    	        stx     PICCNT+LO
 8877   76FF   A2 80       	        ldx     #(256/2)                ; how many entries / 256 bytes
 8878   7701               	GTPD3:
 8879   7701   8E 38 77    	        stx     GTPMOD+1                ; set up how big entry is
 8880   7704   8D 09 C0    		sta	ALTZP+AUX		; use aux mem for most of this
 8881   7707   85 7D       		sta	K+HI			; MSB of destination
 8882   7709   A9 00       	        lda     #0                      ; clear a few things
 8883   770B   85 7A       		sta	J+LO			; J = source
 8884   770D   85 7C       		sta	K+LO			; K = destination
 8885   770F   A9 04       		lda	#4			; 4 * (4*256) bytes max
 8886   7711   8D F1 73    		sta	PFILE_RD+RD_BUFFLEN+HI	; show the read too
 8887   7714   8D FD 73    		sta	P_IDX			; save here for counting
 8888   7717               	GTPDL:
 8889   7717   A0 00       	        ldy     #0                      ; start y
 8890   7719   A9 08       		lda	#>IOBUFF		; get where source is
 8891   771B   85 7B       		sta	J+HI			; MSB of source
 8892   771D   A9 04       		lda	#4			; 4 blocks worth of 256
 8893   771F   8D FE 73    		sta	P_BCNT			; used as counter
 8894   7722   AD 8B C0    		lda	BNK1SET			; we be using bank 1 @$D000
 8895   7725   AD 8B C0    		lda	BNK1SET			; we be using bank 1 @$D000
 8896   7728               	GTPDL1:
 8897   7728   B1 7A       		lda	(J),Y			; get the data byte
 8898   772A   91 7C       		sta	(K),Y			; store in upper aux
 8899   772C   C8          		iny				; point to the next one
 8900   772D   D0 F9       		bne	GTPDL1			; and go get it
 8901   772F               		
 8902   772F   E6 7B       		inc	J+HI			; next block please
 8903   7731   E6 7D       		inc	K+HI			; for destination too
 8904   7733   AD F9 73    		lda	PICCNT+LO		; how many entries?
  Tue Jun 13 1989 11:42                                                                                                  Page  135

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8905   7736   38          		sec				; doing sbc
 8906   7737   E9 20       	GTPMOD:	sbc	#(256/PLDSIZE)		; how many entries in 256 bytes?
 8907   7739   8D F9 73    		sta	PICCNT+LO		; save result
 8908   773C   B0 05       		bcs	GTPDL2			; no wrapping
 8909   773E   CE FA 73    		dec	PICCNT+HI		; wrap
 8910   7741   30 26       		bmi	GTPDLX			; all done if we go negative
 8911   7743               	GTPDL2:
 8912   7743   0D FA 73    		ora	PICCNT+HI		; make sure both are not zero
 8913   7746   F0 21       		beq	GTPDLX			; if they are, then we are done
 8914   7748   CE FE 73    		dec	P_BCNT			; count this block
 8915   774B   D0 DB       		bne	GTPDL1			; go fetch next 256 bytes
 8916   774D   8D 08 C0    		sta	ALTZP+MAIN		; swap back to main for read
 8917                      	
 8918   7750   A9 03       	        lda     #RETRY_COUNT    ; set retry
 8919   7752   85 0E       	        sta     NY_DATA         ; just use this for now
 8920   7754               	GTPDRD:
 8921   7754               		READ	PFILE_RD		; go get the next 4Kb worth
 8922   7754               		PRODOS	$CA, PFILE_RD
 8923   7754   20 00 BF    		jsr	$BF00	; ProDOS handler
 8924   7757   CA          		DB	$CA	; ProDOS function code
 8925   7758   EC73        		DW	PFILE_RD	; Function Parameter Block address
 8926   775A               		.MACEND
 8927   775A               		.MACEND
 8928   775A   90 05       	        bcc     GTPDRDG                 ; fine
 8929   775C   20 F7 46    	        jsr     RETRY                   ; well, do it again?
 8930   775F   90 F3       	        bcc     GTPDRD                  ; yes
 8931   7761               	GTPDRDG:
 8932   7761   8D 09 C0    		sta	ALTZP+AUX		; and back to aux for working
 8933   7764   CE FD 73    		dec	P_IDX			; max 4Kb worth of reading
 8934   7767   D0 AE       		bne	GTPDL			; and read in more
 8935   7769               	GTPDLX:
 8936   7769   8D 08 C0    		sta	ALTZP+MAIN		; back to main bank of mem
 8937   776C   AD 83 C0    		lda	BNK2SET			; back to bank 2
 8938   776F   AD 83 C0    		lda	BNK2SET			; yes please
 8939   7772   A9 01       	        lda     #1                      ; show we found it
 8940   7774   60          		rts				; all done
 8941                      	
 8942   7775   00          	GTPFLAG: db 0				; if 1 when opening next file, then
 8943                      						; this is the next file, so unable to
 8944                      						; find picture number
 8945   7776               	GET_PICINF:
 8946   7776   A9 00       		lda	#0			; set flag for double check
 8947   7778   8D 75 77    		sta	GTPFLAG			; start at zero
 8948   777B               	GTPLOOP:
 8949   777B   A5 63       		lda	ARG1+LO			; check argument for zero
 8950   777D   05 64       		ora	ARG1+HI			; is it zero?
 8951   777F   D0 02       		bne	GTPINDX			; jump to look at first block
 8952   7781   18          		clc				; found some pictures
 8953   7782   60          		rts				; if zero, just give count
 8954   7783               	GTPINDX:
 8955   7783   A4 63       		ldy	ARG1+LO 		; get arg, as we are swapping
 8956   7785   A6 64       		ldx	ARG1+HI 		; to aux mem
 8957   7787   8D 09 C0    		sta	ALTZP+AUX		; look at AUX mem
 8958   778A   AD 8B C0    		lda	BNK1SET 		; bank 1
 8959   778D   AD 8B C0    		lda	BNK1SET 		; bank 1
 8960   7790   AD 04 D0    	        lda     PIC_DIR+PHNLD           ; get # of entries
 8961   7793   8D FA 73    	        sta     PICCNT+HI
 8962   7796   AD 05 D0    	        lda     PIC_DIR+PHNLD+1         ; it's in reverse order
 8963   7799   8D F9 73    	        sta     PICCNT+LO
 8964   779C   84 63       		sty	ARG1+LO 		; use aux mem zero page
 8965   779E   86 64       		stx	ARG1+HI 		; for new arg1
 8966   77A0   A9 D0       		lda	#>PIC_DIR		; start at beginning of block
 8967   77A2   85 8A       		sta	MPNTH			; hi part
 8968   77A4   A9 00       		lda	#<PIC_DIR		; don't forget to start at beginning
 8969   77A6   85 89       		sta	MPNTL			; we are
 8970   77A8   A9 10       		lda	#PHSIZE                 ; skip over header
 8971   77AA   8D FD 73    		sta	P_IDX			; this is the counter
 8972   77AD               	GTP3:
 8973   77AD   AC FD 73    		ldy	P_IDX			; get offset
 8974   77B0   A5 64       		lda	ARG1+HI			; check against desired one
 8975   77B2   D1 89       		cmp	(MPCPNT),Y		; get ID hi byte
 8976   77B4   90 15       		bcc	GTPNOT			; arg1 < than entry, can't be here
 8977   77B6   D0 09       		bne	GTP4			; not it, so check next one
 8978   77B8   C8          		iny				; now to LSB
 8979   77B9   B1 89       		lda	(MPCPNT),Y		; get it
  Tue Jun 13 1989 11:42                                                                                                  Page  136

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 8980   77BB   C5 63       		cmp	ARG1+LO			; is it what we want?
 8981   77BD   F0 2D       		beq	GTPFOUND		; found the picture
 8982   77BF   B0 0A       		bcs	GTPNOT			; arg1 < entry, cannot be here
 8983   77C1               	GTP4:
 8984   77C1   AD F9 73    		lda	PICCNT+LO		; get LSB
 8985   77C4   D0 14       		bne	GTP4D			; no wrap down
 8986   77C6   CE FA 73    		dec	PICCNT+HI		; count down MSB
 8987   77C9   10 0F       		bpl	GTP4D			; everything still okay
 8988   77CB               	GTPNOT:
 8989   77CB   8D 08 C0    		sta	ALTZP+MAIN		; back to main mem
 8990   77CE   AD 83 C0    		lda	BNK2SET			; back to bank 1
 8991   77D1   AD 83 C0    		lda	BNK2SET			; yes please
 8992   77D4   20 05 78    	        jsr     FIND_GBL                ; find picture in global dir
 8993   77D7   90 A2       	        bcc     GTPLOOP                 ; go try again
 8994   77D9   60          	        rts                             ; just show no goodness
 8995   77DA               	GTP4D:	
 8996   77DA   CE F9 73    		dec	PICCNT+LO		; count this entry
 8997   77DD   AD FD 73    		lda	P_IDX			; get index
 8998   77E0   18          		clc				; ready to add
 8999   77E1   69 08       		adc	#PLDSIZE		; point to next entry
 9000   77E3   8D FD 73    		sta	P_IDX			; save lo part
 9001   77E6   90 C5       		bcc	GTP3			; no wrap
 9002   77E8   E6 8A       		inc	MPNTH			; next block
 9003   77EA   D0 C1       		bne	GTP3			; do next block
 9004   77EC               	GTPFOUND:
 9005   77EC   A2 00       		ldx	#0			; for copying data
 9006   77EE   88          		dey				; point to beginning of data
 9007   77EF               	GTPFL:
 9008   77EF   B1 89       		lda	(MPCPNT),Y		; get data
 9009   77F1   9D 04 74    		sta	PICINFO,X		; save data
 9010   77F4   C8          		iny				; point to new entry stuff
 9011   77F5   E8          		inx				; next x
 9012   77F6   E0 08       		cpx	#PLDSIZE		; got it all yet (not ID, tho)?
 9013   77F8   D0 F5       		bne	GTPFL			; get data
 9014   77FA   8D 08 C0    		sta	ALTZP+MAIN		; back to main mem
 9015   77FD   AD 83 C0    		lda	BNK2SET			; back to bank 2
 9016   7800   AD 83 C0    		lda	BNK2SET			; yes please
 9017   7803   18          		clc				; show got data
 9018   7804   60          		rts
 9019                      	;
 9020                      	; FIND_GBL - check the global directory for the picture in question.  If there
 9021                      	;       isn't a global directory, just open the other file.  Return with carry 
 9022                      	;       set if either not in global directory, or the other file has already
 9023                      	;       been opened.
 9024                      	;
 9025   7805               	FIND_GBL:
 9026   7805   AD 75 77    		lda	GTPFLAG			; have we already tried to open another file?
 9027   7808   EE 75 77    		inc	GTPFLAG			; show trying next file
 9028   780B   A8          	        tay                             ; check flag
 9029   780C   D0 0A       		bne     GTPNOT1                 ; we already should have found it
 9030   780E   AD 00 74    	        lda     GBL_FLAG                ; do we have global dir?
 9031   7811   D0 07       	        bne     FG1                     ; yes, so look for picture there
 9032                      	;
 9033                      	; otherwise, just check the other file
 9034                      	;
 9035   7813   20 44 79    		jsr	NEXTPICF		; open other picture file
 9036   7816   18          	        clc
 9037   7817   60          	        rts
 9038   7818               	GTPNOT1:
 9039   7818   38          	        sec                             ; show badness
 9040   7819   60          	        rts
 9041                      	;
 9042                      	; go find the picture in the global directory file
 9043                      	;
 9044   781A               	FG1:
 9045   781A   A4 63       		ldy	ARG1+LO 		; get arg, as we are swapping
 9046   781C   A6 64       		ldx	ARG1+HI 		; to aux mem
 9047   781E   8D 09 C0    		sta	ALTZP+AUX		; look at AUX mem
 9048   7821   AD 8B C0    		lda	BNK1SET 		; bank 1
 9049   7824   AD 8B C0    		lda	BNK1SET 		; bank 1 is where the directory is
 9050   7827   AD 00 DC    	        lda     GBL_DIR                 ; MSB of count
 9051   782A   8D FA 73    	        sta     PICCNT+HI
 9052   782D   AD 01 DC    	        lda     GBL_DIR+1               ; LSB of count
 9053   7830   8D F9 73    	        sta     PICCNT+LO               
 9054   7833   84 63       	        sty     ARG1+LO                 ; restore args
  Tue Jun 13 1989 11:42                                                                                                  Page  137

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 9055   7835   86 64       	        stx     ARG1+HI         
 9056   7837   A9 DC       		lda	#>GBL_DIR		; start at beginning of block
 9057   7839   85 8A       		sta	MPNTH			; hi part
 9058   783B   A9 00       		lda	#<GBL_DIR		; don't forget to start at beginning
 9059   783D   85 89       		sta	MPNTL			; we are
 9060   783F   A9 02       	        lda     #2                      ; start at 2nd word, skipping
 9061   7841   8D FD 73    	        sta     P_IDX                   ; the count byte
 9062   7844               	FGLOOP:
 9063   7844   EE FD 73    	        inc     P_IDX                   ; point to LSB
 9064   7847   AC FD 73    		ldy	P_IDX			; get offset
 9065   784A   B1 89       	        lda     (MPCPNT),Y              ; get global lo byte
 9066   784C   C5 63       	        cmp     ARG1+LO                 ; same as desired one?
 9067   784E   D0 0F       	        bne     FGNOT                   ; nope
 9068   7850   88          	        dey                             ; point to ID MSB
 9069   7851   B1 89       	        lda     (MPCPNT),Y              ; get global MSB
 9070   7853   29 03       	        and     #$03                    ; lower two bits are upper ID part
 9071   7855   C5 64       	        cmp     ARG1+HI                 ; same as desired one?
 9072   7857   D0 06       	        bne     FGNOT                   ; nope
 9073   7859   B1 89       	        lda     (MPCPNT),Y              ; get disk map
 9074   785B   A8          	        tay                             ; save in Y
 9075   785C   18          	        clc                             ; ready for return
 9076   785D   90 1A       	        bcc     FTNX                    ; and done
 9077   785F               	FGNOT:
 9078   785F   AD F9 73    	        lda     PICCNT+LO               ; wrap?
 9079   7862   D0 08       	        bne     FTN1                    ; nope
 9080   7864   AD FA 73    	        lda     PICCNT+HI               ; already zero?
 9081   7867   F0 0F       	        beq     FTNOTFOUND              ; sorry, it ain't anywhere
 9082   7869   CE FA 73    	        dec     PICCNT+HI               ; count down the wrap
 9083   786C               	FTN1:
 9084   786C   CE F9 73    	        dec     PICCNT+LO               ; count down towards the end
 9085   786F   EE FD 73    	        inc     P_IDX                   ; point to next entry
 9086   7872   D0 D0       	        bne     FGLOOP                  ; no wrap to next page
 9087   7874   E6 8A       	        inc     MPNTH                   ; point to next page
 9088   7876   D0 CC       	        bne     FGLOOP                  ; and continue
 9089   7878               	FTNOTFOUND:
 9090   7878   38          	        sec                             ; show not found
 9091   7879               	FTNX:
 9092   7879   8D 08 C0    		sta	ALTZP+MAIN		; back to main mem
 9093   787C   AD 83 C0    		lda	BNK2SET			; back to bank 2
 9094   787F   AD 83 C0    		lda	BNK2SET			; yes please
 9095   7882   90 01       	        bcc     FTNXX                   ; go find it then
 9096   7884   60          	        rts                             ; done
 9097   7885               	FTNXX:
 9098                      	;
 9099                      	; FIND_PICDISK - we have figgered out that the pictures exists somewhere,
 9100                      	;       so parse the passed disk number and go get that disk.
 9101                      	;       First, check to make sure the disk isn't just the other one that
 9102                      	;       is in there.  If it isn't, just use the last one that it is on.
 9103                      	;
 9104                      	;  [Y] = bit 7-2 is the 6 bit disk map
 9105                      	;
 9106   7885               	FIND_PICDISK:
 9107   7885   98          	        tya                             ; get into more useful register        
 9108   7886   4A          	        lsr     A                       ; bring down to lower part
 9109   7887   4A          	        lsr     A                       ; all set up
 9110   7888   8D FD 73    	        sta     P_IDX                   ; save for later looking
 9111   788B   A2 31       	        ldx     #'1'                    ; begin at file 1
 9112   788D   8E 03 74    		stx	PF_NAME+1		; both places
 9113   7890   E8          		inx				; start counter off at 2
 9114   7891   8E 02 74    	        stx     PF_NAME                 ; and save it
 9115   7894   A2 06       	        ldx     #6                      ; 6 possible disks
 9116   7896               	FNDPL:
 9117   7896   6E FD 73    	        ror     P_IDX                   ; put bit into carry
 9118   7899   90 16       	        bcc     FNDPL1                  ; not here
 9119   789B   AD 02 74    	        lda     PF_NAME                 ; get name we are looking at
 9120   789E   8D 03 74    	        sta     PF_NAME+1               ; save found name
 9121   78A1   AC 67 46    	        ldy     GAME1NML                ; get name length
 9122   78A4   D9 67 46    	        cmp     GAME1NM,Y               ; compare to last char
 9123   78A7   F0 0E       	        beq     FNDP1                   ; found it
 9124   78A9   AC 79 46    	        ldy     GAME2NML                ; how 'bout in disk 2?
 9125   78AC   D9 79 46    	        cmp     GAME2NM,Y               ; well?
 9126   78AF   F0 06       	        beq     FNDP1                   ; yes, it's already in there
 9127   78B1               	FNDPL1:
 9128   78B1   EE 02 74    	        inc     PF_NAME                 ; next name
 9129   78B4   CA          	        dex                             ; count down
  Tue Jun 13 1989 11:42                                                                                                  Page  138

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 9130   78B5   D0 DF       	        bne     FNDPL                   ; still more to look at
 9131   78B7               	FNDP1:
 9132   78B7   AD 03 74    	        lda     PF_NAME+1               ; get file name
 9133   78BA   29 07       	        and     #$07                    ; make it non-ascii
 9134   78BC   A8          	        tay                             ; put in Y for routine
 9135   78BD   88          	        dey                             ; and make it zero relative
 9136   78BE   4C 54 79    	        jmp     OPEN_NEW_PF             ; go get it
 9137                      	;
 9138                      	; ZPICNF - YZIP call to get just the picture info
 9139                      	;
 9140   78C1               	ZPICNF:
 9141   78C1   20 76 77    		jsr	GET_PICINF		; find the info
 9142   78C4   B0 7A       		bcs	ZPICNFX			; not found
 9143                      	;
 9144                      	; being here means we found the picture
 9145                      	;
 9146   78C6   A5 65       		lda	ARG2+LO			; lsb is okay
 9147   78C8   85 8F       		sta	SPCL			; right
 9148   78CA   A5 66       		lda	ARG2+HI			; get page
 9149   78CC   20 A9 8F    		jsr	SETPC			; get where it is
 9150   78CF   85 90       		sta	SPCH			; hi
 9151   78D1   84 91       		sty	SPCBNK			; bnak
 9152   78D3   A5 64       		lda	ARG1+HI			; get argumnet
 9153   78D5   05 63       		ora	ARG1+LO			; check for zero arg
 9154   78D7   D0 45       		bne	ZPIC1			; okay, get picture data
 9155                      	;
 9156                      	; arg1 == 0, just return number of entries
 9157                      	;
 9158   78D9   8D 09 C0    		sta	ALTZP+AUX		; look at AUX mem
 9159   78DC   AD 8B C0    		lda	BNK1SET 		; bank 1
 9160   78DF   AD 8B C0    		lda	BNK1SET 		; bank 1
 9161   78E2   AD 0C D0    	        lda     PIC_DIR+PHFVERS		; get version number
 9162   78E5   8D FD 73    		sta	P_IDX			; just save here
 9163   78E8   AD 0D D0    	        lda     PIC_DIR+PHFVERS+1	; now for the LSB
 9164   78EB   8D FE 73    		sta	P_BCNT			; and here
 9165   78EE   AC 0A D0    		ldy	PIC_DIR+PHCHKS		; MSB of checksum
 9166   78F1   AD 0B D0    		lda	PIC_DIR+PHCHKS+1	; and LSB
 9167   78F4   8D 08 C0    		sta	ALTZP+MAIN		; back to main mem
 9168   78F7   AE 83 C0    		ldx	BNK2SET			; back to bank 2
 9169   78FA   AE 83 C0    		ldx	BNK2SET			; yes please
 9170   78FD   48          	        pha                             ; save LSB
 9171   78FE   98          	        tya                             ; put MSB into [A]        
 9172   78FF   20 67 92    		jsr	STASHB			; and save it
 9173   7902   20 D0 8F    		jsr	NEXTSPC			; point to LSB in table
 9174   7905   68          	        pla                             ; get LSB back
 9175   7906   20 67 92    		jsr	STASHB			; and save it
 9176   7909   20 D0 8F    		jsr	NEXTSPC			; point to Version number
 9177   790C   AD FE 73    		lda	P_BCNT			; now for version
 9178   790F   20 67 92    		jsr	STASHB			; give it to game
 9179   7912   20 D0 8F    		jsr	NEXTSPC			; now for LSB
 9180   7915   AD FD 73    		lda	P_IDX			; this is where it is
 9181   7918   20 67 92    		jsr	STASHB			; and away it goes
 9182   791B   4C 2B 44    		jmp	PREDS			; and show success		
 9183   791E               	ZPIC1:
 9184   791E   A9 00       		lda	#0			; height MSB
 9185   7920   20 67 92    		jsr	STASHB			; save it too
 9186   7923   20 D0 8F    		jsr	NEXTSPC			; next byte
 9187   7926   AD 07 74    		lda	PICINFO+PLDHGHT		; height LSB
 9188   7929   20 67 92    		jsr	STASHB			; save it too
 9189   792C   20 D0 8F    		jsr	NEXTSPC			; next byte
 9190   792F   A9 00       		lda	#0			; width first
 9191   7931   20 67 92    		jsr	STASHB			; put it there
 9192   7934   20 D0 8F    		jsr	NEXTSPC			; continue
 9193   7937   AD 06 74    		lda	PICINFO+PLDWID		; LSB of width
 9194   793A   20 67 92    		jsr	STASHB			; save it too
 9195   793D   4C 2B 44    		jmp	PREDS
 9196   7940               	ZPICNFX:
 9197   7940   4C 1F 44    		JMP	PREDF	; SET AS BAD
 9198   7943               	ZDCLR:
 9199   7943               	ZPICSET:
 9200   7943   60          		rts				; NOT IMPLEMENTED YET
 9201                      	;
 9202                      	; NEXTPICF - Just toggle between files 3/4 for those slim and trim games
 9203                      	;       that have pictures only on those 2 disks.
 9204                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page  139

        "APPLE YZIP (c)Infocom, Inc.. --- MACHINE DEPENDENT SHELL"
        "--- Picture Op Codes ---"

 9205   7944               	NEXTPICF:
 9206   7944   A0 03       	        ldy     #3                      ; pretend we want file #4
 9207   7946   AE 79 46    		ldx	GAME2NML		; get length of name
 9208   7949   BD 79 46    		lda	GAME2NM,X		; get last number
 9209   794C   C9 33       		cmp	#'3'			; if 3, then open #4
 9210   794E   F0 01       		beq	NXTPF1			; yes
 9211   7950   88          	        dey                             ; no, so point to 3 then
 9212   7951               	NXTPF1:
 9213   7951   4C 54 79    	        jmp     OPEN_NEW_PF             ; and open the new pic file
 9214                      	;
 9215                      	; OPEN_NEW_PF - open the file so we can pick up new picture data
 9216                      	;
 9217                      	;   [Y] - # of file to be pointed to (0-n)
 9218                      	;
 9219   7954               	OPEN_NEW_PF:
 9220   7954   A5 1F       		lda	DSEGS+HI		; save current DSEG
 9221   7956   48          		pha
 9222   7957   A5 1E       		lda	DSEGS+LO
 9223   7959   48          		pha
 9224   795A   AD BF 45    		lda	GMREF			; to go back to this one
 9225   795D   48          		pha
 9226                      	;
 9227                      	; now, set up DSEGS to point to correct segment table
 9228                      	;
 9229   795E   98          	        tya                             ; get to muck
 9230   795F   0A          		asl	A		        ; make word index
 9231   7960   AA          		tax			        ; make it an index
 9232   7961   BD D0 1D    		lda	DSKSEG+LO,X	        ; get LSB
 9233   7964   85 1E       		sta	DSEGS+LO
 9234   7966   BD D1 1D    		lda	DSKSEG+HI,X             ; and MSB
 9235   7969   85 1F       		sta	DSEGS+HI
 9236   796B   98          	        tya                             ; point to the new file
 9237   796C   20 B6 49    		jsr	FETCH_FILE		; and do it
 9238   796F   8C FB 73    	        sty     PF_REFNUM               ; save refnum, please
 9239   7972   20 6F 76    	        jsr     GO_GET_PDATA            ; just make sure pic data is gotten    
 9240   7975               	OPENPF1:
 9241   7975   68          		pla				; get old ref num back
 9242   7976   8D BF 45    		sta	GMREF			; and for reading
 9243   7979   8D CD 45    		sta	PSEEK+SM_REFNUM 	; this sets it up for set marking
 9244   797C   68          		pla				; get old DSEG back
 9245   797D   85 1E       		sta	DSEGS+LO
 9246   797F   68          		pla
 9247   7980   85 1F       		sta	DSEGS+HI
 9248   7982   18          	        clc                             ; show it worked
 9249   7983   60          		rts
 9250                      	
 9251   7984               		END
 9252                      	
 9253                      	
 9254   7984               		TITLE 	"APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
 9255   7984               		INCLUDE 	OPS012.ASM
 9256   7984               		STTL "--- 0-OPS ---"
 9257                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page  140

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 0-OPS ---"

 9258                      	
 9259                      	
 9260                      	; -----
 9261                      	; RTRUE
 9262                      	; -----
 9263                      	; SIMULATE A "RETURN 1"
 9264                      	
 9265   7984   A2 01       	ZRTRUE:	LDX	#1	
 9266   7986   A9 00       	ZRT0:	LDA	#0	
 9267   7988   86 63       	ZRT1:	STX	ARG1+LO	; GIVE TO
 9268   798A   85 64       		STA	ARG1+HI	; [ARG1]
 9269   798C   4C 84 7B    		JMP	ZRET	; AND DO THE RETURN
 9270                      	
 9271                      	
 9272                      	; ------
 9273                      	; RFALSE
 9274                      	; ------
 9275                      	; SIMULATE A "RETURN 0"
 9276                      	
 9277   798F   A2 00       	ZRFALS:	LDX	#0	
 9278   7991   F0 F3       		BEQ	ZRT0	
 9279                      	
 9280                      	
 9281                      	; ------
 9282                      	; PRINTI
 9283                      	; ------
 9284                      	; PRINT Z-STRING FOLLOWING THE OPCODE
 9285                      	
 9286   7993   A2 05       	ZPRI:	LDX	#5	;MOVE ZPC INTO MPC
 9287   7995               	ZPRI1:			
 9288   7995   B5 80       		LDA	ZPC,X	
 9289   7997   95 86       		STA	MPC,X	
 9290   7999   CA          		DEX		
 9291   799A   10 F9       		BPL	ZPRI1	;NO NEED TO VALIDATE AS ZPC WAS VALID ANYWAY
 9292   799C   20 00 93    		JSR	PZSTR	; PRINT THE Z-STRING AT [MPC]
 9293   799F   A2 05       		LDX	#5	; COPY STATE OF [MPC]
 9294   79A1   B5 86       	ZPRI2:	LDA	MPC,X	; INTO [ZPC]
 9295   79A3   95 80       		STA	ZPC,X	
 9296   79A5   CA          		DEX		
 9297   79A6   10 F9       		BPL	ZPRI2	
 9298   79A8   60          		RTS		
 9299                      	
 9300                      	
 9301                      	; ------
 9302                      	; PRINTR
 9303                      	; ------
 9304                      	; DO A "PRINTI," FOLLOWED BY "CRLF" AND "RTRUE"
 9305                      	
 9306   79A9   20 93 79    	ZPRR:	JSR	ZPRI	
 9307   79AC   20 D6 54    		JSR	ZZCRLF	
 9308   79AF   4C 84 79    		JMP	ZRTRUE	
 9309                      	
 9310                      	
 9311                      	; ------
 9312                      	; RSTACK
 9313                      	; ------
 9314                      	; "RETURN" WITH VALUE ON STACK
 9315                      	
 9316   79B2   20 56 43    	ZRSTAK:	JSR	POPVAL	; GET VALUE INTO [X/A]
 9317   79B5   4C 88 79    		JMP	ZRT1	; AND GIVE IT TO "RETURN"
 9318                      	
 9319                      	
 9320                      	; -----
 9321                      	; CATCH
 9322                      	; -----
 9323                      	
 9324   79B8   AE A4 6C    	ZCATCH:	LDX	OLDZSP+HI	; RETURN ZSTACK POINTER AS
 9325   79BB   AD A3 6C    		LDA	OLDZSP+LO	; ZRET WILL NEED IT
 9326   79BE   4C CD 43    		JMP	PUTBYT
 9327                      	
 9328                      	
 9329                      	; ---------
 9330                      	; ORIGINAL?
 9331                      	; ---------
 9332                      	
  Tue Jun 13 1989 11:42                                                                                                  Page  141

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 0-OPS ---"

 9333                      	; COPY PROTECTION DEVICE, RETURNS TRUE FOR NOW
 9334                      	
 9335   79C1   4C 2B 44    	ZORIG:	JMP	PREDS
 9336                      	
 9337                      	
 9338   79C4               		STTL "--- 1-OPS ---"
 9339                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page  142

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9340                      	
 9341                      	
 9342                      	; -----
 9343                      	; ZERO?
 9344                      	; -----
 9345                      	; [ARG1] = 0?
 9346                      	
 9347   79C4   A5 63       	ZZERO:	LDA	ARG1+LO	
 9348   79C6   05 64       		ORA	ARG1+HI	
 9349   79C8   F0 37       		BEQ	PFINE	
 9350   79CA   4C 1F 44    	PYUCK:	JMP	PREDF	
 9351                      	
 9352                      	
 9353                      	; -----
 9354                      	; NEXT?
 9355                      	; -----
 9356                      	; RETURN "NEXT" POINTER IN OBJECT [ARG1] ;
 9357                      	; FAIL IF LAST AND RETURN ZERO
 9358                      	
 9359   79CD               	ZNEXT:
 9360   79CD   A5 63       		LDA	ARG1+LO	
 9361   79CF   A6 64       		LDX	ARG1+HI	; (EZIP)
 9362   79D1   20 1E 95    		JSR	OBJLOC	; GET OBJECT ADDR INTO [FPC]
 9363   79D4   A9 08       		lda	#8	; POINT TO "NEXT" SLOT (EZIP)
 9364   79D6   20 10 90    		jsr	ADDFPC	; and point to it
 9365   79D9   4C E8 79    		jmp	FIRST1	; JMP to get it
 9366                      	
 9367                      	; ------
 9368                      	; FIRST?
 9369                      	; ------
 9370                      	; RETURN "FIRST" POINTER IN OBJECT [ARG1] ;
 9371                      	; FAIL IF LAST AND RETURN ZERO
 9372                      	; (EZIP ALTERATIONS)
 9373                      	
 9374   79DC               	ZFIRST:
 9375   79DC   A5 63       		lda	ARG1+LO	
 9376   79DE   A6 64       		ldx	ARG1+HI	
 9377   79E0   20 1E 95    		jsr	OBJLOC	; GET OBJECT ADDR INTO [FPC]
 9378   79E3   A9 0A       		lda	#10	; point to "First" slot
 9379   79E5   20 10 90    		jsr	ADDFPC	; and add it
 9380   79E8               	FIRST1:
 9381   79E8   20 88 92    		jsr	FETCHB	; and get it
 9382   79EB   48          		pha		; save it
 9383   79EC   20 F0 8F    		jsr	NEXTFPC
 9384   79EF   20 88 92    		jsr	FETCHB	; and next one
 9385   79F2   A8          		tay		; now dance around a little; save LSB
 9386   79F3   68          		pla		; get MSB back
 9387   79F4   AA          		tax		; and put to x
 9388   79F5   98          		tya		; and put LSB back into [A]
 9389   79F6   20 CD 43    		jsr	PUTBYT	; PASS IT TO VARIABLE
 9390   79F9   A5 76       		lda	VALUE+LO	; EXAMINE THE VALUE JUST "PUT"
 9391   79FB   D0 04       		bne	PFINE	
 9392   79FD   A5 77       		lda	VALUE+HI	
 9393   79FF   F0 C9       		beq	PYUCK	; FAIL IF IT WAS ZERO
 9394   7A01               	PFINE:
 9395   7A01   4C 2B 44    		jmp	PREDS	; ELSE REJOICE
 9396                      	
 9397                      	; ---
 9398                      	; LOC
 9399                      	; ---
 9400                      	; RETURN THE OBJECT CONTAINING OBJECT [ARG1] ;
 9401                      	; RETURN ZERO IF NONE
 9402                      	; (EZIP ALTERED)
 9403                      	
 9404   7A04               	ZLOC:
 9405   7A04   A5 63       		lda	ARG1+LO	
 9406   7A06   A6 64       		ldx	ARG1+HI	
 9407   7A08   E0 20       		cpx	#$20	; don't let it get too high
 9408   7A0A   90 05       		bcc	ZLOC1	; fine
 9409   7A0C   A9 16       		lda	#22	; too big object
 9410   7A0E   4C F9 51    		jmp	ZERROR	; and die
 9411   7A11               	ZLOC1:
 9412   7A11   20 1E 95    		jsr	OBJLOC	; GET ADDR OF OBJECT INTO [FPC]
 9413   7A14   A9 06       		lda	#6	; POINT TO "LOC" SLOT
 9414   7A16   20 10 90    		jsr	ADDFPC	; and make FPC point there
  Tue Jun 13 1989 11:42                                                                                                  Page  143

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9415   7A19   20 88 92    		jsr	FETCHB	; go get byte
 9416   7A1C   48          		pha		; save this please
 9417   7A1D   20 F0 8F    		jsr	NEXTFPC	; and point to next one
 9418   7A20   20 88 92    		jsr	FETCHB	; and get it in [A]
 9419   7A23   A8          		tay		; save LSB
 9420   7A24   68          		pla		; get MSB back
 9421   7A25   AA          		tax		; and put to [X]
 9422   7A26   98          		tya		; and put LSB into a
 9423   7A27   4C CD 43    		jmp	PUTBYT	; AND SHIP IT OUT
 9424                      	
 9425                      	; ------
 9426                      	; PTSIZE
 9427                      	; ------
 9428                      	; RETURN LENGTH OF PROP TABLE [ARG1] IN BYTES
 9429                      	
 9430   7A2A               	ZPTSIZ:
 9431   7A2A   A5 64       		lda	ARG1+HI		; MOVE ABS ADDR OF
 9432   7A2C   20 A9 8F    		jsr	SETPC		; get bank/page
 9433   7A2F   85 8D       		sta	FPCH		; save page
 9434   7A31   84 8E       		sty	FPCBNK		; and bank
 9435   7A33   A5 63       		lda	ARG1+LO
 9436   7A35   85 8C       		sta	FPCL		; and save lo part
 9437   7A37   20 56 90    		jsr	PREVFPC		; Decrement address while moving LSB
 9438   7A3A               	PTZ0:
 9439   7A3A   20 88 92    		jsr	FETCHB		; get length of property
 9440   7A3D   30 0C       		bmi	PTZ2		; BIT 7 = 1, LENGTH > 2 BYTES
 9441   7A3F   29 40       		and	#%01000000
 9442   7A41   F0 04       		beq	PTZ1		; BIT 6 = 0, LENGTH = 1
 9443   7A43   A9 02       		lda	#2		; BIT 6 = 1, LENGTH = 2
 9444   7A45   D0 09       		bne	PTZ3		; JMP
 9445   7A47               	PTZ1:
 9446   7A47   A9 01       		lda	#1
 9447   7A49   D0 05       		bne	PTZ3		; JMP
 9448   7A4B               	PTZ2:
 9449   7A4B   20 88 92    		jsr	FETCHB		; and get it
 9450   7A4E   29 3F       		and	#%00111111	; ELSE PICK UP SIZE > 2
 9451   7A50               	PTZ3:
 9452   7A50   A2 00       		ldx	#0		; CLEAR FOR PUTBYT
 9453   7A52   4C CD 43    		jmp	PUTBYT
 9454                      	; ---
 9455                      	; INC
 9456                      	; ---
 9457                      	; INCREMENT VARIABLE [ARG1]
 9458                      	
 9459   7A55   A5 63       	ZINC:	LDA	ARG1+LO	
 9460   7A57   20 26 43    		JSR	VARGET	; FETCH VARIABLE INTO [VALUE]
 9461   7A5A   E6 76       		INC	VALUE+LO
 9462   7A5C   D0 02       		BNE	ZINC1
 9463   7A5E   E6 77       		INC	VALUE+HI
 9464   7A60   4C 75 7A    	ZINC1:	JMP	ZD0
 9465                      	
 9466                      	
 9467                      	; ---
 9468                      	; DEC
 9469                      	; ---
 9470                      	; DECREMENT VARIABLE [ARG1]
 9471                      	
 9472   7A63   A5 63       	ZDEC:	LDA	ARG1+LO	
 9473   7A65   20 26 43    		JSR	VARGET	; FETCH VAR INTO [VALUE]
 9474   7A68   A5 76       		LDA	VALUE+LO	
 9475   7A6A   38          		SEC		
 9476   7A6B   E9 01       		SBC	#1	
 9477   7A6D   85 76       		STA	VALUE+LO	
 9478   7A6F   A5 77       		LDA	VALUE+HI	
 9479   7A71   E9 00       		SBC	#0	
 9480   7A73   85 77       		STA	VALUE+HI	
 9481   7A75   A5 63       	ZD0:	LDA	ARG1+LO	; PUT RESULT BACK
 9482   7A77   4C B7 43    		JMP	VARPUT	; INTO THE SAME VARIABLE
 9483                      	
 9484                      	
 9485                      	; ------
 9486                      	; PRINTB
 9487                      	; ------
 9488                      	; PRINT Z-STRING AT [ARG1]
 9489                      	
  Tue Jun 13 1989 11:42                                                                                                  Page  144

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9490   7A7A               	ZPRB:
 9491   7A7A   A5 63       		lda	ARG1+LO		; move arg1 to I
 9492   7A7C   85 78       		sta	I+LO		; lo part
 9493   7A7E   A5 64       		lda	ARG1+HI		; and now for arg1 hi
 9494   7A80   85 79       		sta	I+HI		; okay
 9495   7A82   20 92 8F    		jsr	SETWRD		; make [MPC] point to it
 9496   7A85   4C 00 93    		jmp	PZSTR		; and print it
 9497                      	
 9498                      	; ------
 9499                      	; REMOVE
 9500                      	; ------
 9501                      	; MOVE OBJECT [ARG1] INTO PSEUDO-OBJECT #0
 9502                      	; (EZIP CHANGES - 1) OBJLOC NEEDS HI & LO
 9503                      	; 2) MOVES AND COMPARES 2 BYTES)
 9504                      	
 9505   7A88               	SAVEFPC: ds	3	; spot to save the FPC
 9506   7A8B               	SAVEOBJ: ds     1       ; check for zero object
 9507                      	
 9508   7A8C               	ZREMOV:
 9509   7A8C   A5 63       		lda	ARG1+LO	; GET SOURCE OBJECT ADDR
 9510   7A8E   A6 64       		ldx	ARG1+HI	
 9511   7A90   20 1E 95    		jsr	OBJLOC	; INTO [FPC]
 9512                      	;
 9513                      	; now save this objects address in I,J
 9514                      	;
 9515   7A93   A9 06       		lda	#6	; point to the LOC slot
 9516   7A95   20 10 90    		jsr	ADDFPC	; thank you
 9517   7A98   A5 8C       		lda	FPCL	; COPY THE SOURCE ADDR
 9518   7A9A   8D 88 7A    		sta	SAVEFPC+LO	; INTO [J]
 9519   7A9D   A5 8D       		lda	FPCH	; FOR LATER REFERENCE
 9520   7A9F   8D 89 7A    		sta	SAVEFPC+HI
 9521   7AA2   A5 8E       		lda	FPCBNK
 9522   7AA4   8D 8A 7A    		sta	SAVEFPC+ABANK
 9523                      	;
 9524                      	; now go get object this one is in
 9525                      	;		
 9526   7AA7   20 88 92    		jsr	FETCHB	; get the data
 9527   7AAA   85 7C       		sta	K	; HOLD IT
 9528   7AAC   20 F0 8F    		jsr	NEXTFPC	; get lo part
 9529   7AAF   20 88 92    		jsr	FETCHB	; now get part
 9530   7AB2   A8          		tay		; save it
 9531   7AB3   05 7C       		ora	K	; COMPARE BYTES
 9532   7AB5   D0 03       		bne	REMVj	; check for object
 9533   7AB7   4C 5C 7B    		jmp	REMVEX	; SCRAM IF NO OBJECT
 9534   7ABA               	REMVj:
 9535   7ABA   98          		tya		; get lo part
 9536   7ABB   A6 7C       		ldx	K	; and hi part
 9537   7ABD   20 1E 95    		jsr	OBJLOC	; ELSE GET ADDR OF OBJECT [A] INTO [FPC]
 9538   7AC0   A9 0B       		lda	#11	; POINT TO "FIRST" SLOT, LSB
 9539   7AC2   20 10 90    		jsr	ADDFPC	; and point to it
 9540   7AC5   20 88 92    		jsr	FETCHB	; and get it
 9541   7AC8   48          		pha		; save LSB
 9542   7AC9   20 56 90    		jsr	PREVFPC	; point to MSB
 9543   7ACC   20 88 92    		jsr	FETCHB	; A=LO, X=HI
 9544   7ACF   AA          		tax		; put into x
 9545   7AD0   68          		pla		; get LSB back
 9546   7AD1   C5 63       		cmp	ARG1+LO	; IS THIS THE FIRST?
 9547   7AD3   D0 04       		bne	REMVC1	; NO, KEEP SEARCHING
 9548   7AD5   E4 64       		cpx	ARG1+HI	; HM?
 9549   7AD7   F0 2B       		beq	DO_REMOVE ; yes, so use it
 9550   7AD9               	REMVC1:
 9551   7AD9   20 1E 95    		jsr	OBJLOC	; get object
 9552   7ADC   A9 09       		lda	#9	; GET "NEXT" slot address
 9553   7ADE   20 10 90    		jsr	ADDFPC	; into FPC
 9554   7AE1   20 88 92    		jsr	FETCHB	; get the byte
 9555   7AE4   48          		pha		; save LSB for later
 9556   7AE5   20 56 90    		jsr	PREVFPC	; and this is the hi part
 9557   7AE8   20 88 92    		jsr	FETCHB
 9558   7AEB   8D 8B 7A    	        sta     SAVEOBJ ; save for later check
 9559   7AEE   AA          		tax		; and put into x for (possible) check
 9560   7AEF   68          		pla		; get lo part back
 9561   7AF0   A8          	        tay             ; save a minute
 9562   7AF1   0D 8B 7A    	        ora     SAVEOBJ ; well, is it zero?
 9563   7AF4   D0 05       	        bne     REMVC2  ; no, so check it
 9564   7AF6   A9 15       	        lda     #21     ; so die
  Tue Jun 13 1989 11:42                                                                                                  Page  145

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9565   7AF8   4C F9 51    	        jmp     ZERROR  ; and croak
 9566   7AFB               	REMVC2:
 9567   7AFB   98          	        tya             ; put back into [A]
 9568   7AFC   C5 63       		cmp	ARG1+LO	; FOUND IT?
 9569   7AFE   D0 D9       		bne	REMVC1	; NO, KEEP TRYING
 9570   7B00   E4 64       		cpx	ARG1+HI	
 9571   7B02   D0 D5       		bne	REMVC1	
 9572   7B04               	DO_REMOVE:
 9573                      	;
 9574                      	; now, copy from FPC to SPC for stashing away
 9575                      	;
 9576   7B04   20 A5 90    		jsr	FP2SP	; copied
 9577                      	;
 9578                      	; now get removed one's address for fetching
 9579                      	;
 9580   7B07   AD 8A 7A    		lda	SAVEFPC+ABANK	; this is where bank is
 9581   7B0A   85 8E       		sta	FPCBNK	; so show it
 9582   7B0C   AD 89 7A    		lda	SAVEFPC+HI	; and here's the hi/lo part
 9583   7B0F   85 8D       		sta	FPCH
 9584   7B11   AD 88 7A    		lda	SAVEFPC+LO
 9585   7B14   85 8C       		sta	FPCL
 9586   7B16   A9 02       		lda	#2	; so get to source's "NEXT" slot
 9587   7B18   20 10 90    		jsr	ADDFPC	; point to next slot
 9588   7B1B   20 88 92    		jsr	FETCHB	; get the hi byte
 9589   7B1E   20 67 92    		jsr	STASHB	; and save it
 9590   7B21   20 D0 8F    		jsr	NEXTSPC	; point to next one
 9591   7B24   20 F0 8F    		jsr	NEXTFPC	; and from the source too
 9592   7B27   20 88 92    		jsr	FETCHB	; get lo byte
 9593   7B2A   20 67 92    		jsr	STASHB	; and save it away
 9594                      	;
 9595                      	; now zero out SOURCE's loc and next spots
 9596                      	;
 9597   7B2D   AD 8A 7A    		lda	SAVEFPC+ABANK	; bank of source
 9598   7B30   85 91       		sta	SPCBNK
 9599   7B32   AD 89 7A    		lda	SAVEFPC+HI	; and addr of source LOC slot
 9600   7B35   85 90       		sta	SPCH
 9601   7B37   AD 88 7A    		lda	SAVEFPC+LO
 9602   7B3A   85 8F       		sta	SPCL	
 9603                      	;
 9604                      	; zero out NEXT and LOC of source
 9605                      	;
 9606   7B3C   A9 00       		lda	#0	; zero out 4 locations (LOC MSB)
 9607   7B3E   20 67 92    		jsr	STASHB
 9608   7B41   20 D0 8F    		jsr	NEXTSPC
 9609   7B44               		
 9610   7B44   A9 00       		lda	#0	; zero out 4 locations (LOC LSB)
 9611   7B46   20 67 92    		jsr	STASHB
 9612   7B49   20 D0 8F    		jsr	NEXTSPC
 9613   7B4C               		
 9614   7B4C   A9 00       		lda	#0	; zero out 4 locations (NEXT MSB)
 9615   7B4E   20 67 92    		jsr	STASHB
 9616   7B51   20 D0 8F    		jsr	NEXTSPC
 9617   7B54               		
 9618   7B54   A9 00       		lda	#0	; zero out 4 locations (NEXT LSB)
 9619   7B56   20 67 92    		jsr	STASHB
 9620   7B59   20 D0 8F    		jsr	NEXTSPC
 9621   7B5C               	REMVEX:
 9622   7B5C   60          		RTS		
 9623                      	
 9624                      	
 9625                      	; ------
 9626                      	; PRINTD
 9627                      	; ------
 9628                      	; PRINT SHORT DESCRIPTION OF OBJECT [ARG1]
 9629                      	
 9630   7B5D               	ZPRD:
 9631   7B5D   A5 63       		lda	ARG1+LO	
 9632   7B5F   A6 64       		ldx	ARG1+HI	; (EZIP)
 9633   7B61   20 1E 95    		jsr	OBJLOC	; GET ADDR OF OBJECT INTO [FPC]
 9634   7B64   A9 0D       		lda	#13	; GET PROP TABLE POINTER (EZIP)
 9635   7B66   20 10 90    		jsr	ADDFPC	; and point to LSB
 9636   7B69   20 88 92    		jsr	FETCHB	; fetch LSB
 9637   7B6C   48          		pha		; SAVE IT HERE
 9638   7B6D   20 56 90    		jsr	PREVFPC	; and now fetch MSB
 9639   7B70   20 88 92    		jsr	FETCHB	; thank you
  Tue Jun 13 1989 11:42                                                                                                  Page  146

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9640   7B73   85 79       		sta	I+HI	; AND MSB
 9641   7B75   68          		pla		; get LSB back
 9642   7B76   85 78       		sta	I+LO	; STORE LSB
 9643   7B78   E6 78       		inc	I+LO	; POINT PAST THE
 9644   7B7A   D0 02       		bne	PDC0	; LENGTH BYTE
 9645   7B7C   E6 79       		inc	I+HI	
 9646   7B7E   20 92 8F    	PDC0:	jsr	SETWRD	; CALC Z-STRING ADDR
 9647   7B81   4C 00 93    		jmp	PZSTR	; AND PRINT IT
 9648                      	
 9649                      	
 9650                      	; ------
 9651                      	; RETURN
 9652                      	; ------
 9653                      	; RETURN FROM "CALL" WITH VALUE [ARG1]
 9654                      	
 9655   7B84               	ZRET:
 9656   7B84   AD A3 6C    		LDA	OLDZSP+LO	; RE-SYNC THE
 9657   7B87   85 AF       		STA	ZSP+LO		; Z-STACK POINTER
 9658   7B89   AD A4 6C    		LDA	OLDZSP+HI
 9659   7B8C   85 B0       		STA	ZSP+HI
 9660   7B8E   20 56 43    		JSR	POPVAL		; POP # LOCALS INTO [X/A]
 9661   7B91   86 79       		STX	I+HI		; SAVE HERE
 9662   7B93   20 56 43    		JSR	POPVAL		; now we need number of args
 9663   7B96   8D 8F 5B    		STA	ASSVLU		; for ASSIGNED?
 9664                      	
 9665   7B99   A6 79       		LDX	I+HI		; see how many locals
 9666   7B9B   F0 19       		BEQ	RET2		; SKIP IF NOT
 9667                      	
 9668                      		; RESTORE PUSHED LOCALS
 9669                      	
 9670   7B9D   CA          		DEX			; ZERO-ALIGN
 9671   7B9E   8A          		TXA			; AND
 9672   7B9F   0A          		ASL	A		; WORD-ALIGN # LOCALS
 9673   7BA0   85 78       		STA	I+LO		; FOR USE AS A STORAGE INDEX
 9674   7BA2   20 56 43    	RET1:	JSR	POPVAL		; POP A LOCAL INTO [X/A]
 9675   7BA5   A4 78       		LDY	I+LO		; RETRIEVE STORAGE INDEX
 9676   7BA7   99 01 1E    		STA	LOCALS+HI,Y	; STORE MSB OF LOCAL
 9677   7BAA   8A          		TXA			; MOVE LSB
 9678   7BAB   99 00 1E    		STA	LOCALS+LO,Y	; AND STORE THAT TOO
 9679   7BAE   C6 78       		DEC	I+LO
 9680   7BB0   C6 78       		DEC	I+LO		; UPDATE STORAGE INDEX
 9681   7BB2   C6 79       		DEC	I+HI		; AND LOCALS COUNT
 9682   7BB4   D0 EC       		BNE	RET1		; POP TILL NO MORE LOCALS
 9683                      	
 9684                      		; RESTORE OTHER VARIABLES
 9685                      	
 9686   7BB6               	RET2:
 9687   7BB6   20 56 43    		JSR	POPVAL		; POP [ZPCH] AND [ZPCM]
 9688   7BB9   86 81       		STX	ZPCM
 9689   7BBB   85 82       		STA	ZPCH
 9690   7BBD   20 56 43    		JSR	POPVAL		; POP AND RESTORE
 9691   7BC0   8E 8B 5B    		STX	IRET
 9692   7BC3   85 80       		STA	ZPCL
 9693   7BC5   20 56 43    		JSR	POPVAL
 9694   7BC8   8E A3 6C    		STX	OLDZSP+LO
 9695   7BCB   8D A4 6C    		STA	OLDZSP+HI
 9696                      	
 9697   7BCE   A5 80       		LDA	ZPCL		; check for zero zpc
 9698   7BD0   D0 0E       		BNE	RETj		; which means we are returning to
 9699   7BD2   A5 81       		LDA	ZPCM		; an internal call
 9700   7BD4   D0 0A       		BNE	RETj		; rather than just a normal
 9701   7BD6   A5 82       		LDA	ZPCH		; return
 9702   7BD8   D0 06       		BNE	RETj		; but so far it isn't
 9703                      	
 9704   7BDA   20 A4 44    		JSR	A12VAL		; MOVE [ARG1] TO [VALUE]
 9705   7BDD   4C 6E 5B    		JMP	ZIRET		; so then do internal return
 9706   7BE0               	RETj:
 9707   7BE0   20 DC 90    		JSR	VLDZPC		; MAKE VALID
 9708   7BE3   AD 8B 5B    		LDA	IRET		; CHECK IF SHOULD RETURN A VALUE
 9709   7BE6   F0 01       		BEQ	RETYES		; (0 = RET, 1  = NO RETURN)
 9710   7BE8   60          		RTS			; NO, SO JUST GET OUT OF HERE
 9711   7BE9               	RETYES:
 9712   7BE9   20 A4 44    		JSR	A12VAL		; MOVE [ARG1] TO [VALUE]
 9713   7BEC   4C D1 43    		JMP	PUTVAL		; AND RETURN IT
 9714                      	
  Tue Jun 13 1989 11:42                                                                                                  Page  147

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 1-OPS ---"

 9715                      	
 9716                      	; ----
 9717                      	; JUMP
 9718                      	; ----
 9719                      	; JUMP  TO Z-LOCATION IN [ARG1]
 9720                      	
 9721   7BEF   20 A4 44    	ZJUMP:	JSR	A12VAL	; MOVE [ARG1] TO [VALUE]
 9722   7BF2   4C 65 44    		JMP	PREDB3	; A BRANCH THAT ALWAYS SUCCEEDS
 9723                      	
 9724                      	
 9725                      	; -----
 9726                      	; PRINT
 9727                      	; -----
 9728                      	; PRINT Z-STRING AT WORD (QUAD) POINTER [ARG1]
 9729                      	
 9730   7BF5               	ZPRINT:
 9731   7BF5   A5 63       		LDA	ARG1+LO	
 9732   7BF7   85 78       		STA	I+LO	
 9733   7BF9   A5 64       		LDA	ARG1+HI	
 9734   7BFB   85 79       		STA	I+HI	
 9735   7BFD   20 D2 92    		JSR	SETSTR	; CALC STRING ADDRESS
 9736   7C00   4C 00 93    		JMP	PZSTR	; AND PRINT IT
 9737                      	
 9738                      	
 9739                      	; -----
 9740                      	; VALUE
 9741                      	; -----
 9742                      	; RETURN VALUE OF VARIABLE [ARG1]
 9743                      	
 9744   7C03               	ZVALUE:
 9745   7C03   A5 63       		LDA	ARG1+LO	
 9746   7C05   20 26 43    		JSR	VARGET	; GET THE VALUE
 9747   7C08   4C D1 43    		JMP	PUTVAL	; EASY ENOUGH
 9748                      	
 9749                      	
 9750                      	
 9751   7C0B               		STTL "--- 2-OPS ---"
 9752                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page  148

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

 9753                      	
 9754                      	
 9755                      	; -----
 9756                      	; LESS?
 9757                      	; -----
 9758                      	; [ARG1] < [ARG2]?
 9759                      	
 9760   7C0B               	ZLESS:
 9761   7C0B   20 A4 44    		JSR	A12VAL	; MOVE [ARG1] TO [VALUE]
 9762   7C0E   4C 14 7C    		JMP	DLS0	; MOVE [ARG2] TO [I] & COMPARE
 9763                      	
 9764                      	
 9765                      	; ------
 9766                      	; DLESS?
 9767                      	; ------
 9768                      	; DECREMENT [ARG1] ; SUCCEED IF < [ARG2]
 9769                      	
 9770   7C11               	ZDLESS:
 9771   7C11   20 63 7A    		JSR	ZDEC	; MOVES ([ARG1]-1) TO [VALUE]
 9772   7C14   A5 65       	DLS0:	LDA	ARG2+LO	; MOVE [ARG2] TO [I]
 9773   7C16   85 78       		STA	I+LO	
 9774   7C18   A5 66       		LDA	ARG2+HI	
 9775   7C1A   85 79       		STA	I+HI	
 9776   7C1C   4C 3D 7C    		JMP	COMPAR	; COMPARE & RETURN
 9777                      	
 9778                      	
 9779                      	; -----
 9780                      	; GRTR?
 9781                      	; -----
 9782                      	; [ARG1] < [ARG2]?
 9783                      	
 9784   7C1F   A5 63       	ZGRTR:	LDA	ARG1+LO	; MOVE [ARG1] TO [I]
 9785   7C21   85 78       		STA	I+LO	
 9786   7C23   A5 64       		LDA	ARG1+HI	
 9787   7C25   85 79       		STA	I+HI	
 9788   7C27   4C 35 7C    		JMP	A2VAL	; MOVE [ARG2] TO [VALUE] & COMPARE
 9789                      	
 9790                      	
 9791                      	; ------
 9792                      	; IGRTR?
 9793                      	; ------
 9794                      	; INCREMENT [ARG1] ; SUCCEED IF GREATER THAN [ARG2]
 9795                      	
 9796   7C2A   20 55 7A    	ZIGRTR:	JSR	ZINC	; GET ([ARG1]+1) INTO [VALUE]
 9797   7C2D   A5 76       		LDA	VALUE+LO	; MOVE [VALUE] TO [I]
 9798   7C2F   85 78       		STA	I+LO	
 9799   7C31   A5 77       		LDA	VALUE+HI	
 9800   7C33   85 79       		STA	I+HI	
 9801   7C35   A5 65       	A2VAL:	LDA	ARG2+LO	; MOVE [ARG2] TO [VALUE]
 9802   7C37   85 76       		STA	VALUE+LO	
 9803   7C39   A5 66       		LDA	ARG2+HI	
 9804   7C3B   85 77       		STA	VALUE+HI	
 9805                      	
 9806                      	
 9807                      	; -----------------
 9808                      	; SIGNED COMPARISON
 9809                      	; -----------------
 9810                      	; ENTRY: VALUES IN [VALUE] AND [I]
 9811                      	;
 9812                      	;  IS [VALUE] > [I]
 9813                      	;
 9814   7C3D               	COMPAR:
 9815   7C3D   A5 79       		LDA	I+HI
 9816   7C3F   45 77       		EOR	VALUE+HI
 9817   7C41   10 09       		BPL	SCMP
 9818   7C43   A5 79       		LDA	I+HI
 9819   7C45   C5 77       		CMP	VALUE+HI
 9820   7C47   90 42       		BCC	PGOOD
 9821   7C49   4C 1F 44    		JMP	PREDF
 9822                      	
 9823   7C4C   A5 77       	SCMP:	LDA	VALUE+HI
 9824   7C4E   C5 79       		CMP	I+HI
 9825   7C50   D0 04       		BNE	SCEX
 9826   7C52   A5 76       		LDA	VALUE+LO
 9827   7C54   C5 78       		CMP	I+LO
  Tue Jun 13 1989 11:42                                                                                                  Page  149

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

 9828   7C56   90 33       	SCEX:	BCC	PGOOD
 9829   7C58   4C 1F 44    		JMP	PREDF
 9830                      	
 9831                      	
 9832                      	; ---
 9833                      	; IN?
 9834                      	; ---
 9835                      	; IS OBJECT [ARG1] CONTAINED IN OBJECT [ARG2]?
 9836   7C5B               	ZIN:
 9837   7C5B   A5 63       		LDA	ARG1+LO	
 9838   7C5D   A6 64       		LDX	ARG1+HI	
 9839   7C5F   20 1E 95    		JSR	OBJLOC	; GET ADDR OF TARGET OBJECT INTO [FPC]
 9840   7C62   A9 06       		LDA	#6	; POINT TO "LOC" SLOT
 9841   7C64   20 10 90    		jsr	ADDFPC	; and point to it
 9842   7C67   20 88 92    		jsr	FETCHB	; well?
 9843   7C6A   C5 66       		CMP	ARG2+HI	; IS IT THERE?
 9844   7C6C   D0 0A       		BNE	PBAD	; NO
 9845   7C6E   20 F0 8F    		jsr	NEXTFPC	; point to lo part
 9846   7C71   20 88 92    		jsr	FETCHB	; and get it
 9847   7C74   C5 65       		CMP	ARG2+LO	
 9848   7C76   F0 13       		BEQ	PGOOD	; YES, SUCCEED
 9849   7C78   4C 1F 44    	PBAD:	JMP	PREDF	; TOO BAD, CHUM ...
 9850                      	
 9851                      	
 9852                      	; ----
 9853                      	; BTST
 9854                      	; ----
 9855                      	; IS EVERY "ON" BIT IN [ARG1]
 9856                      	; ALSO "ON" IN [ARG2]?
 9857                      	
 9858   7C7B   A5 65       	ZBTST:	LDA	ARG2+LO	; FIRST CHECK LSBS
 9859   7C7D   25 63       		AND	ARG1+LO	
 9860   7C7F   C5 65       		CMP	ARG2+LO	; LSBS MATCH?
 9861   7C81   D0 F5       		BNE	PBAD	; NO, EXIT NOW
 9862   7C83   A5 66       		LDA	ARG2+HI	; ELSE CHECK MSBS
 9863   7C85   25 64       		AND	ARG1+HI	
 9864   7C87   C5 66       		CMP	ARG2+HI	; MATCHED?
 9865   7C89   D0 ED       		BNE	PBAD	; SORRY ...
 9866   7C8B               	PGOOD:
 9867   7C8B   4C 2B 44    		JMP	PREDS	
 9868                      	
 9869                      	
 9870                      	; ---
 9871                      	; BOR
 9872                      	; ---
 9873                      	; RETURN [ARG1] "OR" [ARG2]
 9874                      	
 9875   7C8E   A5 63       	ZBOR:	LDA	ARG1+LO	
 9876   7C90   05 65       		ORA	ARG2+LO	
 9877   7C92   AA          		TAX		
 9878   7C93   A5 64       		LDA	ARG1+HI	
 9879   7C95   05 66       		ORA	ARG2+HI	
 9880                      	
 9881                      		; FALL THROUGH ...
 9882                      	
 9883                      	
 9884                      	; ---------------------
 9885                      	; RETURN VALUE IN [X/A]
 9886                      	; ---------------------
 9887                      	
 9888   7C97   86 76       	VEXIT:	STX	VALUE+LO
 9889   7C99   85 77       		STA	VALUE+HI
 9890   7C9B   4C D1 43    		JMP	PUTVAL
 9891                      	
 9892                      	
 9893                      	; ----
 9894                      	; BAND
 9895                      	; ----
 9896                      	; RETURN [ARG1] "AND" [ARG2]
 9897                      	
 9898   7C9E   A5 63       	ZBAND:	LDA	ARG1+LO	
 9899   7CA0   25 65       		AND	ARG2+LO	
 9900   7CA2   AA          		TAX		
 9901   7CA3   A5 64       		LDA	ARG1+HI	
 9902   7CA5   25 66       		AND	ARG2+HI	
  Tue Jun 13 1989 11:42                                                                                                  Page  150

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

 9903   7CA7   4C 97 7C    		JMP	VEXIT	
 9904                      	
 9905                      	
 9906                      	; -----
 9907                      	; FSET?
 9908                      	; -----
 9909                      	; IS FLAG [ARG2] SET IN OBJECT [ARG1]?
 9910                      	
 9911   7CAA   20 AD 95    	ZFSETP:	JSR	FLAGSU	; GET BITS INTO [K] AND [J]
 9912   7CAD   A5 7D       		LDA	K+HI	; DO MSBS
 9913   7CAF   25 7B       		AND	J+HI	
 9914   7CB1   85 7D       		STA	K+HI	
 9915   7CB3   A5 7C       		LDA	K+LO	; DO LSBS
 9916   7CB5   25 7A       		AND	J+LO	
 9917   7CB7   05 7D       		ORA	K+HI	; ANY BITS ON?
 9918   7CB9   D0 D0       		BNE	PGOOD	; TARGET BIT MUST BE ON
 9919   7CBB   4C 1F 44    		JMP	PREDF	
 9920                      	
 9921                      	
 9922                      	; ----
 9923                      	; FSET
 9924                      	; ----
 9925                      	; SET FLAG [ARG2] IN OBJECT [ARG1]
 9926                      	
 9927   7CBE               	ZFSET:
 9928   7CBE   20 AD 95    		JSR	FLAGSU	; GET BITS INTO [K] & [J], ADDR IN [FPC]
 9929                      	;
 9930                      	; now, copy from FPC to SPC for stashing away
 9931                      	;
 9932   7CC1   20 A5 90    		jsr	FP2SP	; okay, done it
 9933   7CC4   A5 7D       		lda	K+HI	; FIRST DO MSBS
 9934   7CC6   05 7B       		ora	J+HI	
 9935   7CC8   20 67 92    		jsr	STASHB
 9936   7CCB   20 D0 8F    		jsr	NEXTSPC
 9937   7CCE   A5 7C       		lda	K+LO	; THEN LSBS
 9938   7CD0   05 7A       		ora	J+LO	
 9939   7CD2   20 67 92    		jsr	STASHB
 9940   7CD5   60          		rts
 9941                      	
 9942                      	
 9943                      	; ------
 9944                      	; FCLEAR
 9945                      	; ------
 9946                      	; CLEAR FLAG [ARG2] IN OBJECT [ARG1]
 9947                      	
 9948   7CD6               	ZFCLR:
 9949   7CD6   20 AD 95    		jsr	FLAGSU	; GETS BITS INTO [J] & [K], ADDR IN [FPC]
 9950                      	;
 9951                      	; now, copy from FPC to SPC for stashing away
 9952                      	;
 9953   7CD9   20 A5 90    		jsr	FP2SP	; okey dokey
 9954                      	
 9955   7CDC   A5 7B       		lda	J+HI	; FETCH MSB
 9956   7CDE   49 FF       		eor	#$FF	; COMPLEMENT IT
 9957   7CE0   25 7D       		and	K+HI	; RUB OUT FLAG
 9958   7CE2   20 67 92    		jsr	STASHB	; and save it
 9959   7CE5   20 D0 8F    		jsr	NEXTSPC	; point to lo part
 9960   7CE8   A5 7A       		lda	J+LO	; SAME FOR LSB
 9961   7CEA   49 FF       		eor	#$FF	
 9962   7CEC   25 7C       		and	K+LO	
 9963   7CEE   20 67 92    		jsr	STASHB	; and show it to the world
 9964   7CF1   60          		rts
 9965                      	
 9966                      	
 9967                      	; ---
 9968                      	; SET
 9969                      	; ---
 9970                      	; SET VARIABLE [ARG1] EQUAL TO [ARG2]
 9971                      	
 9972   7CF2   A5 65       	ZSET:	LDA	ARG2+LO	; MOVE THE VALUE
 9973   7CF4   85 76       		STA	VALUE+LO	; INTO [VALUE]
 9974   7CF6   A5 66       		LDA	ARG2+HI	
 9975   7CF8   85 77       		STA	VALUE+HI	
 9976   7CFA   A5 63       		LDA	ARG1+LO	; GET VARIABLE ID
 9977   7CFC   4C B7 43    		JMP	VARPUT	; AND CHANGE THE VARIABLE
  Tue Jun 13 1989 11:42                                                                                                  Page  151

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

 9978                      	
 9979                      	
 9980                      	; ----
 9981                      	; MOVE
 9982                      	; ----
 9983                      	; MOVE OBJECT [ARG1] INTO OBJECT [ARG2]
 9984                      	; (EZIP - EXPANDED FROM BYTE OBJECTS TO WORD OBJECTS)
 9985                      	
 9986   7CFF               	ZMOVE:
 9987   7CFF   20 8C 7A    		jsr	ZREMOV		; REMOVE FIRST - CUT ARG1 OUT OF WHERE IT IS
 9988                      	;
 9989                      	; Make [ARG1] be first in [ARG2]'s chain.
 9990                      	;
 9991   7D02   A5 65       		lda	ARG2+LO	
 9992   7D04   A6 66       		ldx	ARG2+HI		; Get parent's address
 9993   7D06   20 1E 95    		jsr	OBJLOC		; into [FPC]
 9994   7D09   A9 0A       		lda	#10		; point to FIRST slot
 9995   7D0B   20 10 90    		jsr	ADDFPC		; okay
 9996   7D0E   20 88 92    		jsr	FETCHB		; get old first one (MSB)
 9997   7D11   85 7D       		sta	K+HI		; save it
 9998   7D13   20 F0 8F    		jsr	NEXTFPC		; point to next part
 9999   7D16   20 88 92    		jsr	FETCHB		; and get it
10000   7D19   85 7C       		sta	K+LO		; okay, saved
10001   7D1B   20 A5 90    		jsr	FP2SP		; make FPC == SPC
10002                      	;
10003                      	; now make object [ARG1] be first in object [ARG2]
10004                      	; SPC is currently pointing to LSB of [ARG2]'s FIRST slot
10005                      	;
10006   7D1E   A5 63       		lda	ARG1+LO		; stash away low part first
10007   7D20   20 67 92    		jsr	STASHB		; stashed
10008   7D23   20 80 90    		jsr	PREVSPC		; point to high part
10009   7D26   A5 64       		lda	ARG1+HI		; get hi part of source
10010   7D28   20 67 92    		jsr	STASHB		; save it
10011                      	;
10012                      	; now point to object [ARG1] to update its slots
10013                      	;
10014   7D2B   A6 64       		ldx	ARG1+HI		; put hi part here
10015   7D2D   A5 63       		lda	ARG1+LO		; and lo part here for OBJLOC
10016   7D2F   20 1E 95    		jsr	OBJLOC		; get me the SOURCE of all confusion
10017   7D32   A9 06       		lda	#6		; point to LOC slot
10018   7D34   20 10 90    		jsr	ADDFPC		; and now FPC points there
10019   7D37   20 A5 90    		jsr	FP2SP		; now make it the STASH pointer
10020                      	;
10021                      	; update [ARG1]s LOC pointer to be [ARG2]
10022                      	; SPC points to LOC slot
10023                      	;
10024   7D3A   A5 66       		lda	ARG2+HI		; get PARENT number
10025   7D3C   20 67 92    		jsr	STASHB		; and save it in LOC
10026   7D3F   20 D0 8F    		jsr	NEXTSPC		; and point to LSB of LOC
10027   7D42   A5 65       		lda	ARG2+LO		; got parent's lowness
10028   7D44   20 67 92    		jsr	STASHB		; and saved it in ARG1
10029                      	;
10030                      	; Move old FIRST object and make it [ARG1]s NEXT
10031                      	; now SPC points to [ARG1]s NEXT slot
10032                      	;
10033   7D47   20 D0 8F    		jsr	NEXTSPC		; point to MSB of NEXT
10034   7D4A   A5 7D       		lda	K+HI		; get old FIRST one
10035   7D4C   20 67 92    		jsr	STASHB	; and save it
10036   7D4F   20 D0 8F    		jsr	NEXTSPC	; and point to LSB now
10037   7D52   A5 7C       		lda	K+LO	; get LSB of this
10038   7D54   20 67 92    		jsr	STASHB	; saved
10039   7D57   60          		rts
10040                      	
10041                      	; ---
10042                      	; GET
10043                      	; ---
10044                      	; RETURN ITEM [ARG2] IN WORD-TABLE [ARG1]
10045                      	
10046   7D58               	ZGET:
10047   7D58   20 6F 7D    		JSR	WCALC		; CALC ADDRESS
10048   7D5B   20 3B 92    		JSR	GETBYT		; GET 1ST BYTE (MSB)
10049   7D5E   85 77       	DOGET:	STA	VALUE+HI	; SAVE MSB
10050   7D60   20 3B 92    		JSR	GETBYT		; GET LSB
10051   7D63   85 76       		STA	VALUE+LO	; SAVE AND
10052   7D65   4C D1 43    		jmp	PUTVAL		; HAND IT OVER
  Tue Jun 13 1989 11:42                                                                                                  Page  152

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10053                      	
10054                      	
10055                      	; ----
10056                      	; GETB
10057                      	; ----
10058                      	; RETURN ITEM [ARG2] IN BYTE-TABLE AT [ARG1]
10059                      	
10060   7D68               	ZGETB:
10061   7D68   20 73 7D    		JSR	BCALC	
10062   7D6B   A9 00       		LDA	#0	
10063   7D6D   F0 EF       		BEQ	DOGET		; [A] = 0, SO CLEAR MSB OF [VALUE]
10064                      	
10065                      	
10066                      	; --------------------
10067                      	; CALC TABLE ADDRESSES
10068                      	; --------------------
10069                      	; WORD-ALIGNED ENTRY
10070                      	
10071   7D6F               	WCALC:
10072   7D6F   06 65       		ASL	ARG2+LO	; WORD-ALIGN FOR
10073   7D71   26 66       		ROL	ARG2+HI	; WORD ACCESS
10074                      	;
10075                      	; BYTE-ALIGNED ENTRY
10076                      	;
10077   7D73               	BCALC:
10078   7D73   A5 65       		LDA	ARG2+LO	; ADD BASE ADDR OF TABLE
10079   7D75   18          		CLC		; TO ITEM
10080   7D76   65 63       		ADC	ARG1+LO	; INDEX
10081   7D78   85 86       		STA	MPCL	
10082   7D7A   A5 66       		LDA	ARG2+HI	; SAME FOR MSBS
10083   7D7C   65 64       		ADC	ARG1+HI	
10084   7D7E   85 87       		STA	MPCM	
10085   7D80   A9 00       		LDA	#0	
10086   7D82   69 00       		ADC	#0	; PICK UP CARRY FROM MPCM
10087   7D84   85 88       		STA	MPCH	; TO GET TOP BIT
10088   7D86   4C B2 90    		JMP	VLDMPC	
10089                      	
10090                      	
10091                      	; ----
10092                      	; GETP
10093                      	; ----
10094                      	; RETURN PROPERTY [ARG2] OF OBJECT [ARG1] ;
10095                      	; IF NO PROP [ARG2], RETURN [ARG2]'TH ELEMENT OF OBJECT #0
10096                      	
10097   7D89               	ZGETP:
10098   7D89   20 59 95    		jsr	PROPB		; set up FPC
10099   7D8C               	GETP1:
10100   7D8C   20 84 95    		jsr	PROPN		; GET ID OF PROP TBL
10101   7D8F   C5 65       		cmp	ARG2+LO		; Compare PROP ID
10102   7D91   F0 30       		beq	GETP3		; FOUND IT
10103   7D93   90 06       		bcc	GETP2		; NOT THERE
10104   7D95   20 A3 95    		jsr	PROPNX		; GET NEXT PROP, ALIGN [FPC] TO IT
10105   7D98   4C 8C 7D    		jmp	GETP1		; TRY AGAIN WITH NEXT PROP
10106                      	;
10107                      	; PROPERTY NOT THERE, GET DEFAULT
10108                      	;
10109   7D9B               	GETP2:
10110   7D9B   A5 65       		lda	ARG2+LO		; GET PROPERTY #
10111   7D9D   38          		sec			; ZERO-ALIGN IT
10112   7D9E   E9 01       		sbc	#1	
10113   7DA0   0A          		asl	A		; WORD-ALIGN IT
10114   7DA1   18          		clc			; add in table start
10115   7DA2   6D 0B 96    		adc	ZBEGIN+ZOBJEC+1	; add lo part
10116   7DA5   85 8C       		sta	FPCL		; save for fetch
10117   7DA7   AD 0A 96    		lda	ZBEGIN+ZOBJEC	; now get hi part
10118   7DAA   69 00       		adc	#0		; pick up carry, if any
10119   7DAC   20 A9 8F    		jsr	SETPC		; get memory spot for this page
10120   7DAF   85 8D       		sta	FPCH		; page and
10121   7DB1   84 8E       		sty	FPCBNK		; bank
10122   7DB3   20 88 92    		jsr	FETCHB		; GET MSB OF PROPERTY
10123   7DB6   85 77       		sta	VALUE+HI	
10124   7DB8   20 F0 8F    		jsr	NEXTFPC
10125   7DBB   20 88 92    		jsr	FETCHB		; DO SAME WITH LSB
10126   7DBE   85 76       		sta	VALUE+LO	
10127   7DC0   4C D1 43    		jmp	PUTVAL		; RETURN DEFAULT IN [VALUE]
  Tue Jun 13 1989 11:42                                                                                                  Page  153

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10128   7DC3               	GETP3:
10129   7DC3   20 8A 95    		jsr	PROPL		; GET LENGTH OF PROP INTO [A]
10130   7DC6   AA          		tax			; save [A]
10131   7DC7   20 F0 8F    		jsr	NEXTFPC		; MAKE [FPC] POINT TO 1ST BYTE OF PROP
10132   7DCA   E0 01       		cpx	#1		; IF LENGTH =1
10133   7DCC   F0 09       		beq	GETPB		; GET A BYTE PROPERTY
10134   7DCE   E0 02       		cpx	#2		; IF LENGTH = 2
10135   7DD0   F0 10       		beq	GETPW		; GET A WORD PROPERTY
10136                      	
10137                      		; *** ERROR #7: PROPERTY LENGTH ***
10138                      	
10139   7DD2   A9 07       		LDA	#7	
10140   7DD4   4C F9 51    		JMP	ZERROR	
10141                      	;
10142                      	; GET A 1-BYTE PROPERTY
10143                      	;
10144   7DD7               	GETPB:
10145   7DD7   20 88 92    		jsr	FETCHB		; GET LSB INTO [A]
10146   7DDA   85 76       		sta	VALUE+LO	; STORE LSB
10147   7DDC   A9 00       		lda	#0		; CLEAR MSB
10148   7DDE   85 77       		sta	VALUE+HI	; and zero it
10149   7DE0   F0 0D       		beq	ETPEX	
10150                      	;
10151                      	; GET A 2-BYTE PROPERTY
10152                      	;
10153   7DE2               	GETPW:
10154   7DE2   20 88 92    		jsr	FETCHB		; GET MSB
10155   7DE5   85 77       		sta	VALUE+HI	; store MSB
10156   7DE7   20 F0 8F    		jsr	NEXTFPC		; POINT TO LSB
10157   7DEA   20 88 92    		jsr	FETCHB		; GET IT INTO [A]
10158   7DED   85 76       		sta	VALUE+LO	; AND MSB
10159   7DEF               	ETPEX:
10160   7DEF   4C D1 43    		jmp	PUTVAL	
10161                      	
10162                      	; -----
10163                      	; GETPT
10164                      	; -----
10165                      	; RETURN POINTER TO PROP TABLE [ARG2]
10166                      	; IN OBJECT [ARG1]
10167                      	
10168   7DF2               	ZGETPT:
10169   7DF2   A5 63       		lda	ARG1+LO
10170   7DF4   A6 64       		ldx	ARG1+HI		; (EZIP)
10171   7DF6   20 1E 95    		jsr	OBJLOC		; put location into [FPC]
10172   7DF9   A9 0C       		lda	#12		; get offset table pointer
10173   7DFB   20 10 90    		jsr	ADDFPC		; and point to it
10174   7DFE   20 88 92    		jsr	FETCHB		; get MSB of table pointer
10175   7E01   48          		pha			; save page
10176   7E02   20 F0 8F    		jsr	NEXTFPC		; point to LSB
10177   7E05   20 88 92    		jsr	FETCHB		; and get it
10178   7E08   85 8C       		sta	FPCL		; and save it
10179   7E0A   68          		pla			; get page address back
10180   7E0B   20 A9 8F    		jsr	SETPC		; and absolutize it
10181   7E0E   85 8D       		sta	FPCH		; and save page
10182   7E10   84 8E       		sty	FPCBNK		; and bank
10183   7E12   20 88 92    		jsr	FETCHB		; GET LENGTH OF SHORT DESC
10184   7E15   0A          		asl	A		; WORD-ALIGN IT
10185   7E16   A8          		tay			; now point to just past it
10186   7E17   C8          		iny			; thank you
10187   7E18   98          		tya			; for adding
10188   7E19   20 10 90    		jsr	ADDFPC		; and POINT JUST PAST THE DESCRIPTION
10189   7E1C               	GETPT1:
10190   7E1C   20 84 95    		jsr	PROPN		; get prop ID
10191   7E1F   C5 65       		cmp	ARG2+LO		; CHECK ID
10192   7E21   F0 0B       		beq	GETPT2
10193   7E23   B0 03       		bcs	DDD		; .GE. so check some more
10194   7E25   4C 5C 7E    		jmp	DORET		; BEYOND IT, SO NOT THERE
10195   7E28               	DDD:
10196   7E28   20 A3 95    		jsr	PROPNX		; point to next one
10197   7E2B   4C 1C 7E    		jmp	GETPT1		; next please
10198   7E2E               	GETPT2:
10199   7E2E   20 8A 95    		jsr	PROPL		; get the length of this property
10200   7E31   20 F0 8F    		jsr	NEXTFPC		; INC TO POINT AT PROPERTY VALUE (EZIP)
10201                      	;
10202                      	; now subtract absolute address to get relative address for returning
  Tue Jun 13 1989 11:42                                                                                                  Page  154

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10203                      	; what a pain in the neck
10204                      	;
10205   7E34   A5 8E       		lda	FPCBNK		; check which bank we are in
10206   7E36   F0 16       		beq	GETPB0		; in main bank, it's easier
10207                      	;
10208                      	; if in AUX bank, then we must subtract beginning of AUX mem, then
10209                      	; add in size of MAIN bank
10210                      	;
10211   7E38   A5 8D       		lda	FPCH		; get page
10212   7E3A   C9 D0       		cmp	#>Z3BEGIN	; in part 2 of aux?
10213   7E3C   B0 08       		bcs	GETPB3		; ayyup
10214   7E3E   38          		sec			; and subtract
10215   7E3F   E9 40       		sbc	#>Z2BEGIN	; first page in aux
10216   7E41   18          		clc			; now add in how many pages in main
10217   7E42   69 29       		adc	#P2PAGE		; now we have relative start
10218   7E44   D0 0D       		bne	GETP15		; JUMP to putval
10219   7E46               	GETPB3:
10220   7E46   38          		sec			; and subtract
10221   7E47   E9 D0       		sbc	#>Z3BEGIN	; first page in aux, part 2
10222   7E49   18          		clc			; now add in how many pages in main
10223   7E4A   69 A8       		adc	#P3PAGE		; now we have relative start
10224   7E4C   D0 05       		bne	GETP15		; jump to putval	
10225   7E4E               	GETPB0:
10226   7E4E   A5 8D       		lda	FPCH		; get page in main mem
10227   7E50   38          		sec			; and then subtract
10228   7E51   E9 96       		sbc	#>ZBEGIN	; start of main mem
10229   7E53               	GETP15:
10230   7E53   85 77       		sta	VALUE+HI	; save hi part for returning
10231   7E55   A5 8C       		lda	FPCL		; and just save lo part
10232   7E57   85 76       		sta	VALUE+LO	; okay?
10233   7E59   4C D1 43    		jmp	PUTVAL		; AND RETURN
10234   7E5C               	DORET:	
10235   7E5C   4C CA 43    		jmp	RET0		; ELSE RETURN A ZERO
10236                      	
10237                      	
10238                      	; -----
10239                      	; NEXTP
10240                      	; -----
10241                      	; RETURN INDEX # OF PROP FOLLOWING PROP [ARG2] IN OBJECT [AR
10242                      	; RETURN ZERO IF LAST ; RETURN FIRST IF [ARG2]=0; ERROR IF NO
10243                      	
10244   7E5F               	ZNEXTP:
10245   7E5F   20 59 95    		JSR	PROPB	; ALIGN [FPC] AT PROPERTY TBL'S 1ST ENTRY
10246   7E62   A5 65       		LDA	ARG2+LO	; IF [ARG2]=0
10247   7E64   F0 12       		BEQ	NXTP3	; RETURN "FIRST" SLOT
10248   7E66               	NXTP1:
10249   7E66   20 84 95    		JSR	PROPN	; FETCH PROPERTY #
10250   7E69   C5 65       		CMP	ARG2+LO	; COMPARE TO TARGET #
10251   7E6B   F0 08       		BEQ	NXTP2	; FOUND IT!
10252   7E6D   90 ED       		BCC	DORET	; LAST PROP, SO RETURN ZERO
10253   7E6F   20 A3 95    		JSR	PROPNX	; ELSE TRY NEXT PROPERTY (EZIP)
10254   7E72   4C 66 7E    		JMP	NXTP1	
10255   7E75   20 A3 95    	NXTP2:	JSR	PROPNX	; POINT TO FOLLOWING PROPERTY
10256   7E78   20 84 95    	NXTP3:	JSR	PROPN	; GET THE PROPERTY #
10257   7E7B   A2 00       		LDX	#0	; FOR PUTBYT (EZIP)
10258   7E7D   4C CD 43    		JMP	PUTBYT	; AND RETURN IT
10259                      	
10260                      	
10261                      	; ---
10262                      	; ADD
10263                      	; ---
10264                      	; RETURN [ARG1] + [ARG2]
10265                      	
10266   7E80   A5 63       	ZADD:	LDA	ARG1+LO	; ADD LSBS
10267   7E82   18          		CLC		
10268   7E83   65 65       		ADC	ARG2+LO	
10269   7E85   AA          		TAX		; SAVE LSB HERE
10270   7E86   A5 64       		LDA	ARG1+HI	; ADD MSBS
10271   7E88   65 66       		ADC	ARG2+HI	
10272   7E8A   4C 97 7C    		JMP	VEXIT	
10273                      	
10274                      	
10275                      	; ---
10276                      	; SUB
10277                      	; ---
  Tue Jun 13 1989 11:42                                                                                                  Page  155

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10278                      	; RETURN [ARG1] - [ARG2]
10279                      	
10280   7E8D   A5 63       	ZSUB:	LDA	ARG1+LO	; SUBTRACT LSBS
10281   7E8F   38          		SEC		
10282   7E90   E5 65       		SBC	ARG2+LO	
10283   7E92   AA          		TAX		; SAVE LSB HERE
10284   7E93   A5 64       		LDA	ARG1+HI	; SUBTRACT MSBS
10285   7E95   E5 66       		SBC	ARG2+HI	
10286   7E97   4C 97 7C    		JMP	VEXIT	; EXIT WITH [X]=LSB, [A]=MSB
10287                      	
10288                      	
10289                      	; ---
10290                      	; MUL
10291                      	; ---
10292                      	; RETURN [ARG1] * [ARG2]
10293                      	
10294   7E9A   20 80 7F    	ZMUL:	JSR	MINIT	; INIT THINGS
10295   7E9D   6E 8D 5B    	ZMLOOP:	ROR	MTEMP+HI	
10296   7EA0   6E 8C 5B    		ROR	MTEMP+LO	
10297   7EA3   66 66       		ROR	ARG2+HI	
10298   7EA5   66 65       		ROR	ARG2+LO	
10299   7EA7   90 11       		BCC	ZMNEXT	
10300   7EA9   A5 63       		LDA	ARG1+LO	
10301   7EAB   18          		CLC		
10302   7EAC   6D 8C 5B    		ADC	MTEMP+LO	
10303   7EAF   8D 8C 5B    		STA	MTEMP+LO	
10304   7EB2   A5 64       		LDA	ARG1+HI	
10305   7EB4   6D 8D 5B    		ADC	MTEMP+HI	
10306   7EB7   8D 8D 5B    		STA	MTEMP+HI	
10307   7EBA   CA          	ZMNEXT:	DEX		
10308   7EBB   10 E0       		BPL	ZMLOOP	
10309   7EBD   A6 65       		LDX	ARG2+LO	; PUT LSB OF PRODUCT
10310   7EBF   A5 66       		LDA	ARG2+HI	; AND MSB
10311   7EC1   4C 97 7C    		JMP	VEXIT	; WHERE "VEXIT" EXPECTS THEM
10312                      	
10313                      	
10314                      	; ---
10315                      	; DIV
10316                      	; ---
10317                      	; RETURN QUOTIENT OF [ARG1] / [ARG2]
10318                      	
10319   7EC4   20 DC 7E    	ZDIV:	JSR	DIVIDE	
10320   7EC7   AE 89 6C    		LDX	QUOT+LO	
10321   7ECA   AD 8A 6C    		LDA	QUOT+HI	
10322   7ECD   4C 97 7C    		JMP	VEXIT	
10323                      	
10324                      	
10325                      	; ---
10326                      	; MOD
10327                      	; ---
10328                      	; RETURN REMAINDER OF [ARG1] / [ARG2]
10329                      	
10330   7ED0   20 DC 7E    	ZMOD:	JSR	DIVIDE	
10331   7ED3   AE 8B 6C    		LDX	REMAIN+LO	; FETCH THE REMAINDER
10332   7ED6   AD 8C 6C    		LDA	REMAIN+HI	; IN [REMAIN]
10333   7ED9   4C 97 7C    		JMP	VEXIT	; AND RETURN IT
10334                      	
10335                      	
10336                      	; ---------------
10337                      	; SIGNED DIVISION
10338                      	; ---------------
10339                      	; ENTRY: DIVIDEND IN [ARG1], DIVISOR IN [ARG2]
10340                      	; EXIT: QUOTIENT IN [QUOT], REMAINDER IN [REMAIN]
10341                      	
10342   7EDC               	DIVIDE:
10343   7EDC   A5 64       		LDA	ARG1+HI	; SIGN OF REMAINDER
10344   7EDE   8D 8E 6C    		STA	RSIGN	; IS THE SIGN OF THE DIVIDEND
10345   7EE1   45 66       		EOR	ARG2+HI	; SIGN OF QUOTIENT IS POSITIVE
10346   7EE3   8D 8D 6C    		STA	QSIGN	; IF SIGNS OF TERMS ARE THE SAME
10347   7EE6   A5 63       		LDA	ARG1+LO	; MOVE [ARG1] TO [QUOT]
10348   7EE8   8D 89 6C    		STA	QUOT+LO	
10349   7EEB   A5 64       		LDA	ARG1+HI	
10350   7EED   8D 8A 6C    		STA	QUOT+HI	; IF DIVIDEND IS POSITIVE
10351   7EF0   10 03       		BPL	ABSDIV	; MOVE DIVISOR
10352   7EF2   20 26 7F    		JSR	ABQUOT	; ELSE CALC ABS(DIVIDEND) FIRST
  Tue Jun 13 1989 11:42                                                                                                  Page  156

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10353   7EF5   A5 65       	ABSDIV:	LDA	ARG2+LO	
10354   7EF7   8D 8B 6C    		STA	REMAIN+LO	
10355   7EFA   A5 66       		LDA	ARG2+HI	
10356   7EFC   8D 8C 6C    		STA	REMAIN+HI	; IF REMAINDER IS POSITIVE
10357   7EFF   10 03       		BPL	GODIV	; WE'RE READY TO DIVIDE
10358   7F01   20 14 7F    		JSR	ABREM	; ELSE CALC ABS(DIVISOR)
10359   7F04   20 38 7F    	GODIV:	JSR	UDIV	; DO UNSIGNED DIVIDE
10360   7F07   AD 8D 6C    		LDA	QSIGN	; SHOULD QUOTIENT BE FLIPPED?
10361   7F0A   10 03       		BPL	RFLIP	; NO, TEST REMAINDER
10362   7F0C   20 26 7F    		JSR	ABQUOT	; ELSE GET ABSOLUTE VALUE
10363   7F0F   AD 8E 6C    	RFLIP:	LDA	RSIGN	; SHOULD EMAINDER BE FLIPPED?
10364   7F12   10 11       		BPL	DIVEX	; NO, WE'RE DONE
10365                      	
10366                      		; ELSE FALL THROUGH ...
10367                      	
10368                      	
10369                      	; ----------------
10370                      	; CALC ABS(REMAIN)
10371                      	; ----------------
10372                      	
10373   7F14   A9 00       	ABREM:	LDA	#0	
10374   7F16   38          		SEC		
10375   7F17   ED 8B 6C    		SBC	REMAIN+LO	
10376   7F1A   8D 8B 6C    		STA	REMAIN+LO	
10377   7F1D   A9 00       		LDA	#0	
10378   7F1F   ED 8C 6C    		SBC	REMAIN+HI	
10379   7F22   8D 8C 6C    		STA	REMAIN+HI	
10380   7F25   60          	DIVEX:	RTS		
10381                      	
10382                      	
10383                      	; --------------
10384                      	; CALC ABS(QUOT)
10385                      	; --------------
10386                      	
10387   7F26   A9 00       	ABQUOT:	LDA	#0	
10388   7F28   38          		SEC		
10389   7F29   ED 89 6C    		SBC	QUOT+LO	
10390   7F2C   8D 89 6C    		STA	QUOT+LO	
10391   7F2F   A9 00       		LDA	#0	
10392   7F31   ED 8A 6C    		SBC	QUOT+HI	
10393   7F34   8D 8A 6C    		STA	QUOT+HI	
10394   7F37   60          		RTS		
10395                      	
10396                      	
10397                      	; -----------------
10398                      	; UNSIGNED DIVISION
10399                      	; -----------------
10400                      	; ENTRY: DIVIDEND IN [QUOT], DIVISOR IN [REMAIN]
10401                      	; EXIT: QUOTIENT IN [QUOT], REMAINDER IN [REMAIN]
10402                      	
10403   7F38               	UDIV:
10404   7F38   AD 8B 6C    		LDA	REMAIN+LO	; CHECK [REMAIN]
10405   7F3B   0D 8C 6C    		ORA	REMAIN+HI	; BEFORE PROCEEDING
10406   7F3E   F0 3B       		BEQ	DIVERR	; CAN'T DIVIDE BY ZERO!
10407   7F40   20 80 7F    		JSR	MINIT	; SET IT ALL UP
10408   7F43   2E 89 6C    	UDLOOP:	ROL	QUOT+LO	
10409   7F46   2E 8A 6C    		ROL	QUOT+HI	
10410   7F49   2E 8C 5B    		ROL	MTEMP+LO	
10411   7F4C   2E 8D 5B    		ROL	MTEMP+HI	
10412   7F4F   AD 8C 5B    		LDA	MTEMP+LO	
10413   7F52   38          		SEC		
10414   7F53   ED 8B 6C    		SBC	REMAIN+LO	
10415   7F56   A8          		TAY		; SAVE HERE
10416   7F57   AD 8D 5B    		LDA	MTEMP+HI	
10417   7F5A   ED 8C 6C    		SBC	REMAIN+HI	
10418   7F5D   90 06       		BCC	UDNEXT	
10419   7F5F   8C 8C 5B    		STY	MTEMP+LO	
10420   7F62   8D 8D 5B    		STA	MTEMP+HI	
10421   7F65   CA          	UDNEXT:	DEX		
10422   7F66   D0 DB       		BNE	UDLOOP	
10423   7F68   2E 89 6C    		ROL	QUOT+LO	; SHIFT LAST CARRY FOR QUOTIENT
10424   7F6B   2E 8A 6C    		ROL	QUOT+HI	
10425   7F6E   AD 8C 5B    		LDA	MTEMP+LO	; MOVE REMAINDER
10426   7F71   8D 8B 6C    		STA	REMAIN+LO	; INTO [REMAIN]
10427   7F74   AD 8D 5B    		LDA	MTEMP+HI	
  Tue Jun 13 1989 11:42                                                                                                  Page  157

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10428   7F77   8D 8C 6C    		STA	REMAIN+HI	
10429   7F7A   60          		RTS		
10430                      	
10431                      		; *** ERROR #8: DIVISION BY ZERO ***
10432                      	
10433   7F7B   A9 08       	DIVERR:	LDA	#8	
10434   7F7D   4C F9 51    		JMP	ZERROR	
10435                      	
10436                      	
10437                      	; ---------
10438                      	; MATH INIT
10439                      	; ---------
10440                      	
10441   7F80   A2 10       	MINIT:	LDX	#16		; INIT LOOPING INDEX
10442   7F82   A9 00       		LDA	#0
10443   7F84   8D 8C 5B    		STA	MTEMP+LO	; CLEAR TEMP
10444   7F87   8D 8D 5B    		STA	MTEMP+HI	; REGISTER
10445   7F8A   18          		CLC			; AND CARRY
10446   7F8B   60          		RTS
10447                      	
10448                      	
10449                      	; -----
10450                      	; THROW
10451                      	; -----
10452                      	
10453   7F8C               	ZTHROW:
10454   7F8C   A5 65       		lda	ARG2+LO		; check to see if we are ready to do return
10455   7F8E   CD A3 6C    		cmp	OLDZSP+LO
10456   7F91   D0 07       		bne	ZTHLOOP		; nope, keep unwinding the stack
10457   7F93   A5 66       		lda	ARG2+HI
10458   7F95   CD A4 6C    		cmp	OLDZSP+HI	; have we found the right frame yet?
10459   7F98   F0 06       		beq	ZTHDO		; yes
10460   7F9A               	ZTHLOOP:
10461   7F9A   20 84 7B    		jsr	ZRET		; do another return
10462   7F9D   4C 8C 7F    		jmp	ZTHROW		; and try again
10463   7FA0               	ZTHDO:	
10464   7FA0   A5 65       		lda	ARG2+LO		; SET ZSTACK POINTER
10465   7FA2   8D A3 6C    		sta	OLDZSP+LO	; UP FOR ZRET
10466   7FA5   A5 66       		lda	ARG2+HI
10467   7FA7   8D A4 6C    		sta	OLDZSP+HI
10468   7FAA   4C 84 7B    		jmp	ZRET
10469                      	
10470   7FAD               		END
10471                      	
10472   7FAD               		INCLUDE 	OPSX.ASM
10473                      		PAGE			
  Tue Jun 13 1989 11:42                                                                                                  Page  158

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- 2-OPS ---"

10474   7FAD               		STTL "--- X-OPS ---"
10475                      	
10476                      	
10477                      		; ------
10478                      		; EQUAL?
10479                      		; ------
10480                      		; IS [ARG1] = [ARG2] (OR [ARG3] OR [ARG4])?
10481                      	
10482   7FAD               	ZEQUAL:
10483   7FAD   C6 62       		DEC	NARGS	; DOUBLE-CHECK # ARGS
10484   7FAF   A5 63       		LDA	ARG1+LO	; FETCH LSB
10485   7FB1   A6 64       		LDX	ARG1+HI	; AND MSB OF [ARG1]
10486   7FB3   C5 65       		CMP	ARG2+LO	; TEST LSB OF [ARG2]
10487   7FB5   D0 04       		BNE	TRY2	; NO GOOD, LOOK FOR ANOTHER ARG
10488   7FB7   E4 66       		CPX	ARG2+HI	; ELSE TRY MSB OF [ARG2]
10489   7FB9   F0 18       		BEQ	EQOK	; MATCHED!
10490   7FBB   C6 62       	TRY2:	DEC	NARGS	; OUT OF ARGS YET?
10491   7FBD   F0 17       		BEQ	EQBAD	; YES, WE FAILED
10492   7FBF   C5 67       		CMP	ARG3+LO	; TRY LSB OF [ARG3]
10493   7FC1   D0 04       		BNE	TRY3	; NO GOOD, LOOK FOR ANOTHER ARG
10494   7FC3   E4 68       		CPX	ARG3+HI	; HOW ABOUT MSB OF [ARG3]?
10495   7FC5   F0 0C       		BEQ	EQOK	; YAY!
10496   7FC7   C6 62       	TRY3:	DEC	NARGS	; OUT OF ARGS YET?
10497   7FC9   F0 0B       		BEQ	EQBAD	; IF NOT ...
10498   7FCB   C5 69       		CMP	ARG4+LO	; TRY [ARG4]
10499   7FCD   D0 07       		BNE	EQBAD	; SORRY, CHUM
10500   7FCF   E4 6A       		CPX	ARG4+HI	; MSB MATCHED?
10501   7FD1   D0 03       		BNE	EQBAD	; TOO BAD
10502                      	
10503   7FD3   4C 2B 44    	EQOK:	JMP	PREDS	; FINALLY MATCHED!
10504                      	
10505   7FD6   4C 1F 44    	EQBAD:	JMP	PREDF	; FAILURE (SNIFF!)
10506                      	
10507                      	
10508                      	; ----------------------------
10509                      	; ICALL,ICALL1, ICALL2, IXCALL
10510                      	; ----------------------------
10511                      	
10512   7FD9               	ZICALL:
10513   7FD9               	ZICLL1:
10514   7FD9               	ZICLL2:
10515   7FD9   A9 01       	ZIXCLL:	LDA	#1	; SET FLAG FOR RETURNLESS CALL
10516   7FDB   8D 8B 5B    		STA	IRET
10517   7FDE   D0 05       		BNE	IENTR	; JMP OVER NORMAL SETTING
10518                      	
10519                      	
10520                      	; -------------------
10521                      	; XCALL, CALL1, CALL2
10522                      	; -------------------
10523                      	
10524                      	ZXCALL:			; DROP	THROUGH
10525                      	ZCALL1:			; CALL	RTN HANDLES ALL 4 KINDS
10526   7FE0               	ZCALL2:
10527                      	
10528                      	; ----
10529                      	; CALL
10530                      	; ----
10531                      	; BRANCH TO FUNCTION AT ([ARG1]*4), PASSING
10532                      	; OPTIONAL PARAMETERS IN [ARG2]-[ARG4]
10533                      	; ([ARG5]-[ARG8] FOR XCALL (EZIP))
10534                      	
10535   7FE0   A9 00       	ZCALL:	LDA	#0
10536   7FE2   8D 8B 5B    		STA	IRET		; SET FLAG TO RETURN SOMETHING
10537   7FE5   A5 63       	IENTR:	LDA	ARG1+LO
10538   7FE7   05 64       		ORA	ARG1+HI		; IS CALL ADDRESS ZERO?
10539   7FE9   D0 0B       		BNE	DOCALL		; NO, CONTINUE
10540   7FEB   AD 8B 5B    		LDA	IRET		; any ret value?
10541   7FEE   F0 01       		BEQ	Ij		; yes, so return a zero
10542                      	
10543   7FF0   60          		RTS			; otherwise, just end
10544   7FF1               	Ij:
10545   7FF1   A2 00       		LDX	#0
10546   7FF3   4C CD 43    		JMP	PUTBYT		; ELSE RETURN THE ZERO IN [A]
10547   7FF6   AE A3 6C    	DOCALL:	LDX	OLDZSP+LO	; SAVE OLD STACK POINTER
10548   7FF9   AD A4 6C    		LDA	OLDZSP+HI
  Tue Jun 13 1989 11:42                                                                                                  Page  159

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10549   7FFC   20 8B 43    		JSR	PUSHXA
10550   7FFF   A5 80       		LDA	ZPCL		; AND LSB OF [ZPC]
10551   8001   AE 8B 5B    		LDX	IRET		; AND RETURN FLAG
10552   8004   20 8B 43    		JSR	PUSHXA		; ON THE Z-STACK
10553   8007   A6 81       		LDX	ZPCM		; SAVE MIDDLE 8 BITS
10554   8009   A5 82       		LDA	ZPCH		; AND TOP BIT OF [ZPC]
10555   800B   20 8B 43    		JSR	PUSHXA		; AS WELL
10556                      	
10557                      		; FORM 16-BIT ADDRESS FROM [ARG1]
10558                      	
10559   800E   A9 00       		LDA	#0	
10560   8010   06 63       		ASL	ARG1+LO		; MULTIPLY [ARG1]
10561   8012   26 64       		ROL	ARG1+HI		; (BY 2)
10562   8014   2A          		ROL	A		; >BIT INTO [A]
10563   8015   06 63       		ASL	ARG1+LO		; BY 4 (EZIP)
10564   8017   26 64       		ROL	ARG1+HI	
10565   8019   2A          		ROL	A
10566   801A   85 82       		STA	ZPCH		; NEW >BIT OF [ZPC]
10567   801C   A5 64       		LDA	ARG1+HI		; GET NEW <BYTES
10568   801E   85 81       		STA	ZPCM	
10569   8020   A5 63       		LDA	ARG1+LO	
10570   8022   85 80       		STA	ZPCL	
10571                      	;
10572                      	; now add offset
10573                      	;
10574   8024   18          		clc			; doing adding
10575   8025   A5 80       		lda	ZPCL		; start at lo part
10576   8027   65 5D       		adc	FOFFL		; add in lo part
10577   8029   85 80       		sta	ZPCL
10578   802B   A5 81       		lda	ZPCM
10579   802D   65 5C       		adc	FOFFM
10580   802F   85 81       		sta	ZPCM
10581   8031   A5 82       		lda	ZPCH
10582   8033   65 5B       		adc	FOFFH
10583   8035   85 82       		sta	ZPCH
10584   8037   20 DC 90    		jsr	VLDZPC	
10585   803A   20 51 92    		jsr	NEXTPC		; FETCH # LOCALS TO PASS
10586   803D   85 7A       		sta	J+LO		; SAVE HERE FOR COUNTING
10587   803F   85 7B       		sta	J+HI		; AND HERE FOR LATER REFERENCE
10588   8041   F0 21       		beq	ZCLL2		; SKIP IF NO LOCALS
10589   8043   A9 00       		lda	#0	
10590   8045   85 78       		sta	I+LO		; ELSE INIT STORAGE INDEX
10591   8047               	ZCLL1:
10592   8047   A4 78       		LDY	I+LO	
10593   8049   BE 00 1E    		LDX	LOCALS+LO,Y	; GET LSB OF LOCAL INTO [X]
10594   804C   B9 01 1E    		LDA	LOCALS+HI,Y	; AND MSB INTO [A]
10595   804F   20 8B 43    		JSR	PUSHXA		; PUSH LOCAL IN [X/A] ONTO Z-STACK
10596   8052   A4 78       		LDY	I+LO		; RESTORE INDEX
10597   8054   A9 00       		LDA	#0		; ZERO ALL LOCALS (X)
10598   8056   99 00 1E    		STA	LOCALS+LO,Y
10599   8059   99 01 1E    		STA	LOCALS+HI,Y
10600   805C   C8          		INY		
10601   805D   C8          		INY			; UPDATE
10602   805E   84 78       		STY	I+LO		; THE STORAGE INDEX
10603   8060   C6 7A       		DEC	J+LO		; ANY MORE LOCALS?
10604   8062   D0 E3       		BNE	ZCLL1		; YES, KEEP LOOPING
10605                      	;
10606                      	; MOVE UP TO 7 ARGUMENTS TO [LOCALS]
10607                      	;
10608   8064               	ZCLL2:
10609   8064   AD 8F 5B    		LDA	ASSVLU		; get how many here
10610   8067   20 8B 43    		JSR	PUSHXA		; save how many args for ASSIGNED?
10611   806A   C6 62       		DEC	NARGS		; EXTRA ARGS IN THIS CALL?
10612   806C   A5 62       		LDA	NARGS		; SAVE FOR ASSIGNED? OP
10613   806E   8D 8F 5B    		STA	ASSVLU		; and save away
10614   8071   F0 5E       		BEQ	ZCALL3		; NO, CONTINUE
10615   8073   A5 65       		LDA	ARG2+LO		; MOVE [ARG2] TO LOCAL #1
10616   8075   8D 00 1E    		STA	LOCALS+LO	
10617   8078   A5 66       		LDA	ARG2+HI	
10618   807A   8D 01 1E    		STA	LOCALS+HI	
10619   807D   C6 62       		DEC	NARGS		; ANY LEFT?
10620   807F   F0 50       		BEQ	ZCALL3		; NO, SCRAM
10621   8081   A5 67       		LDA	ARG3+LO		; MOVE [ARG3] TO LOCAL #2
10622   8083   8D 02 1E    		STA	LOCALS+LO+2	
10623   8086   A5 68       		LDA	ARG3+HI	
  Tue Jun 13 1989 11:42                                                                                                  Page  160

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10624   8088   8D 03 1E    		STA	LOCALS+HI+2	
10625   808B   C6 62       		DEC	NARGS		; ANY LEFT?
10626   808D   F0 42       		BEQ	ZCALL3		; NO, EXUENT
10627   808F   A5 69       		LDA	ARG4+LO		; MOVE [ARG4] TO LOCAL #3
10628   8091   8D 04 1E    		STA	LOCALS+LO+4	
10629   8094   A5 6A       		LDA	ARG4+HI	
10630   8096   8D 05 1E    		STA	LOCALS+HI+4	
10631   8099   C6 62       		DEC	NARGS		; MORE (THAT MEANS IT'S AN XCALL)
10632   809B   F0 34       		BEQ	ZCALL3		; NO, JUST A CALL
10633   809D   A5 6B       		LDA	ARG5+LO		; MOVE [ARG5] TO LOCAL #4
10634   809F   8D 06 1E    		STA	LOCALS+LO+6	
10635   80A2   A5 6C       		LDA	ARG5+HI	
10636   80A4   8D 07 1E    		STA	LOCALS+HI+6	
10637   80A7   C6 62       		DEC	NARGS		; MORE?
10638   80A9   F0 26       		BEQ	ZCALL3		; NO
10639   80AB   A5 6D       		LDA	ARG6+LO		; MOVE [ARG6] TO LOCAL #5
10640   80AD   8D 08 1E    		STA	LOCALS+LO+8	
10641   80B0   A5 6E       		LDA	ARG6+HI	
10642   80B2   8D 09 1E    		STA	LOCALS+HI+8	
10643   80B5   C6 62       		DEC	NARGS		; MORE?
10644   80B7   F0 18       		BEQ	ZCALL3		; NO
10645   80B9   A5 6F       		LDA	ARG7+LO		; MOVE [ARG7] TO LOCAL #6
10646   80BB   8D 0A 1E    		STA	LOCALS+LO+10	
10647   80BE   A5 70       		LDA	ARG7+HI	
10648   80C0   8D 0B 1E    		STA	LOCALS+HI+10	
10649   80C3   C6 62       		DEC	NARGS		; MORE?
10650   80C5   F0 0A       		BEQ	ZCALL3		; NO
10651   80C7   A5 71       		LDA	ARG8+LO		; MOVE [ARG8] TO LOCAL #7
10652   80C9   8D 0C 1E    		STA	LOCALS+LO+12	
10653   80CC   A5 72       		LDA	ARG8+HI	
10654   80CE   8D 0D 1E    		STA	LOCALS+HI+12	
10655   80D1   A6 7B       	ZCALL3:	LDX	J+HI		; RETRIEVE # LOCALS
10656   80D3   8A          		TXA			; DUPE FOR NO GOOD REASON
10657   80D4   20 8B 43    		JSR	PUSHXA		; PUSH # LOCALS ONTO Z-STACK
10658   80D7   A5 B0       		LDA	ZSP+HI		; REMEMBER WHERE
10659   80D9   8D A4 6C    		STA	OLDZSP+HI	; WE CAME FROM
10660   80DC   A5 AF       		LDA	ZSP+LO	
10661   80DE   8D A3 6C    		STA	OLDZSP+LO	
10662   80E1   60          		RTS			; WHEW!
10663                      	
10664                      	
10665                      	; ---
10666                      	; PUT
10667                      	; ---
10668                      	; SET ITEM [ARG2] IN WORD-TABLE [ARG1] EQUAL TO [ARG3]
10669   80E2               	ZPUT:
10670   80E2   06 65       		asl	ARG2+LO	; WORD-ALIGN [ARG2]
10671   80E4   26 66       		rol	ARG2+HI	
10672   80E6   20 FD 80    		jsr	PCALC	; GET ITEM ADDR INTO [SPC]
10673   80E9   A5 68       		lda	ARG3+HI	; STORE MSB OF [ARG3]
10674   80EB   20 67 92    		jsr	STASHB	; and store it away
10675   80EE   20 D0 8F    		jsr	NEXTSPC	; POINT TO LSB
10676   80F1   4C F7 80    		jmp	PUTLSB	; and put in lsb
10677                      	
10678                      	
10679                      	; ----
10680                      	; PUTB
10681                      	; ----
10682                      	; SET ITEM [ARG2] IN BYTE-TABLE [ARG1] EQUAL TO [ARG3]
10683                      	
10684   80F4   20 FD 80    	ZPUTB:	JSR	PCALC	
10685                      	;
10686                      	; ENTRY FOR "PUT"
10687                      	;
10688   80F7               	PUTLSB:
10689   80F7   A5 67       		LDA	ARG3+LO	; GET LSB OF [ARG3]
10690   80F9   20 67 92    		jsr	STASHB	; and save it away
10691   80FC   60          		RTS		
10692                      	
10693                      	
10694                      	; ---------------------------
10695                      	; CALC ITEM ADDRESS FOR "PUT"
10696                      	; ---------------------------
10697                      	; put the 3 byte address into SPC
10698                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page  161

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10699   80FD   A5 65       	PCALC:	LDA	ARG2+LO	; ADD ITEM OFFSET IN [ARG2]
10700   80FF   18          		CLC		; TO TABLE ADDR IN [ARG1]
10701   8100   65 63       		ADC	ARG1+LO	; TO FORM A POINTER
10702   8102   85 8F       		STA	SPCL	; in [SPC]
10703   8104   A5 66       		LDA	ARG2+HI	; SAME FOR MSB
10704   8106   65 64       		ADC	ARG1+HI	
10705   8108   20 A9 8F    		jsr	SETPC	; and figger out where it is
10706   810B   85 90       		sta	SPCH	; set page
10707   810D   84 91       		sty	SPCBNK	; and bank
10708   810F   60          		rts
10709                      	
10710                      	; ----
10711                      	; PUTP
10712                      	; ----
10713                      	; SET PROPERTY [ARG2] IN OBJECT [ARG1] EQUAL TO [ARG3]
10714                      	
10715   8110               	ZPUTP:
10716   8110   20 59 95    		jsr	PROPB		; GET PROP TBL ADDR
10717   8113               	PUTP1:
10718   8113   20 84 95    		jsr	PROPN		; GET ID
10719   8116   C5 65       		cmp	ARG2+LO		; is it the wanted one?
10720   8118   F0 08       		beq	PUTP2		; ayyup
10721   811A   90 2F       		bcc	PNERR		; ERROR IF LOWER
10722   811C   20 A3 95    		jsr	PROPNX		; TRY NEXT PROPERTY, ALIGN [I] AT IT (EZIP)
10723   811F   4C 13 81    		jmp	PUTP1		; and check again
10724   8122               	PUTP2:
10725   8122   20 8A 95    		jsr	PROPL		; GET PROPERTY LENGTH INTO [A]
10726   8125   AA          		tax			; save length
10727   8126   20 F0 8F    		jsr	NEXTFPC		; and point to first prop. byte
10728   8129   A5 8E       		lda	FPCBNK		; and copy FPC to SPC for storage
10729   812B   85 91       		sta	SPCBNK
10730   812D   A5 8D       		lda	FPCH
10731   812F   85 90       		sta	SPCH
10732   8131   A5 8C       		lda	FPCL
10733   8133   85 8F       		sta	SPCL		; saved it
10734   8135   E0 01       		cpx	#1		; IF LENGTH = 1
10735   8137   F0 0C       		beq	PUTP3		; PUT A BYTE
10736   8139   E0 02       		cpx	#2		; PUT A WORD IF [A] = 2
10737   813B   D0 13       		bne	PLERR		; ELSE LENGTH IS BAD
10738   813D   A5 68       		lda	ARG3+HI		; GET MSB OF PROPERTY
10739   813F   20 67 92    		jsr	STASHB		; and store in object
10740   8142   20 D0 8F    		jsr	NEXTSPC		; POINT TO LSB SLOT
10741   8145               	PUTP3:
10742   8145   A5 67       		lda	ARG3+LO		; FETCH LSB of property
10743   8147   20 67 92    		jsr	STASHB		; AND STORE IN OBJECT
10744   814A   60          		rts
10745                      	
10746                      		; *** ERROR #10: BAD PROPERTY NUMBER ***
10747                      	
10748   814B   A9 0A       	PNERR:	LDA	#10	
10749   814D   4C F9 51    		JMP	ZERROR	
10750                      	
10751                      		; *** ERROR #11: PUTP PROPERTY LENGTH ***
10752                      	
10753   8150   A9 0B       	PLERR:	LDA	#11	
10754   8152   4C F9 51    		JMP	ZERROR	
10755                      	
10756                      	
10757                      	; ------
10758                      	; PRINTC
10759                      	; ------
10760                      	; PRINT CHAR WITH ASCII VALUE IN [ARG1]
10761                      	
10762   8155   A5 63       	ZPRC:	LDA	ARG1+LO	; GRAB THE CHAR
10763   8157   4C F5 52    		JMP	COUT	; AND SHIP IT OUT
10764                      	
10765                      	
10766                      	; ------
10767                      	; PRINTN
10768                      	; ------
10769                      	; PRINT VALUE OF [ARG1] AS A SIGNED INTEGER
10770                      	
10771   815A   A5 63       	ZPRN:	LDA	ARG1+LO	; MOVE [ARG1] TO [QUOT]
10772   815C   8D 89 6C    		STA	QUOT+LO	
10773   815F   A5 64       		LDA	ARG1+HI	
  Tue Jun 13 1989 11:42                                                                                                  Page  162

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10774   8161   8D 8A 6C    		STA	QUOT+HI	
10775                      	
10776                      		; PRINT [QUOT]
10777                      	
10778   8164   AD 8A 6C    	NUMBER:	LDA	QUOT+HI	; IF VALUE IS POSITIVE
10779   8167   10 08       		BPL	DIGCNT	; CONTINUE
10780   8169   A9 2D       		LDA	#'-'	; ELSE START WITH A MINUS SIGN
10781   816B   20 F5 52    		JSR	COUT	
10782   816E   20 26 7F    		JSR	ABQUOT	; AND CALC ABS([QUOT])
10783                      	
10784                      		; COUNT # OF DECIMAL DIGITS
10785                      	
10786   8171   A9 00       	DIGCNT:	LDA	#0	; RESET
10787   8173   8D 8F 6C    		STA	DIGITS	; DIGIT INDEX
10788   8176   AD 89 6C    	DGC:	LDA	QUOT+LO	; IS QUOTIENT
10789   8179   0D 8A 6C    		ORA	QUOT+HI	; ZERO YET?
10790   817C   F0 16       		BEQ	PRNTN3	; YES, READY TO PRINT
10791   817E   A9 0A       		LDA	#10	; ELSE DIVIDE [QUOT]
10792   8180   8D 8B 6C    		STA	REMAIN+LO	; BY 10 (LSB)
10793   8183   A9 00       		LDA	#0	
10794   8185   8D 8C 6C    		STA	REMAIN+HI	; 10 (MSB)
10795   8188   20 38 7F    		JSR	UDIV	; UNSIGNED DIVIDE
10796   818B   AD 8B 6C    		LDA	REMAIN+LO	; FETCH LSB OF REMAINDER (THE DIGIT)
10797   818E   48          		PHA		; SAVE IT ON STACK
10798   818F   EE 8F 6C    		INC	DIGITS	; UPDATE DIGIT COUNT
10799   8192   D0 E2       		BNE	DGC	; LOOP TILL QUOTIENT=0
10800   8194   AD 8F 6C    	PRNTN3:	LDA	DIGITS	; IF DIGIT COUNT IS NZ
10801   8197   D0 05       		BNE	PRNTN4	; CONTINUE
10802   8199   A9 30       		LDA	#'0'	; ELSE PRINT "0"
10803   819B   4C F5 52    		JMP	COUT	; AND RETURN
10804   819E   68          	PRNTN4:	PLA		; PULL A DIGIT OFF THE STACK
10805   819F   18          		CLC		
10806   81A0   69 30       		ADC	#'0'	; CONVERT TO DB	II
10807   81A2   20 F5 52    		JSR	COUT	; AND PRINT IT
10808   81A5   CE 8F 6C    		DEC	DIGITS	; OUT OF DIGITS YET?
10809   81A8   D0 F4       		BNE	PRNTN4	; NO, KEEP LOOPING
10810   81AA   60          		RTS		
10811                      	
10812                      	
10813                      	; ------
10814                      	; RANDOM
10815                      	; ------
10816                      	; RETURN A RANDOM VALUE BETWEEN 0 AND [ARG1]
10817                      	
10818   81AB   A5 63       	ZRAND:	LDA	ARG1+LO		; IF VALUE IS ZERO
10819   81AD   05 64       	 	ORA	ARG1+HI
10820   81AF   D0 09       		BNE	ZRAND1
10821   81B1   8D 9F 6C    		STA	SRHOLD+LO	; RETURN TO RANDOM RANDOM
10822   81B4   8D A0 6C    		STA	SRHOLD+HI	; CLEAR INDICATOR
10823   81B7   4C CA 43    		JMP	RET0		; AND RETURN THRU HERE SO ALIGNED
10824   81BA   AD 9F 6C    	ZRAND1:	LDA	SRHOLD+LO	; ARE WE NONRAMDOM INCREMENTING? (EZIP)
10825   81BD   0D A0 6C    		ORA	SRHOLD+HI
10826   81C0   D0 41       		BNE	ZRAND3		; YUP
10827   81C2   A5 64       		LDA	ARG1+HI
10828   81C4   10 17       		BPL	ZRAND2		; GENERATE A RANDOM #
10829   81C6   49 FF       		EOR	#$FF		; SET UP TO INCREMENT FROM 1 THRU INT
10830   81C8   8D A0 6C    		STA	SRHOLD+HI	; GET ABSOLUTE
10831   81CB   A5 63       		LDA	ARG1+LO
10832   81CD   49 FF       		EOR	#$FF
10833   81CF   8D 9F 6C    		STA	SRHOLD+LO
10834   81D2   EE 9F 6C    		INC	SRHOLD+LO
10835   81D5   A9 00       		LDA	#0		; W/ NO RAMDOMNESS
10836   81D7   85 A5       		STA	RAND+HI
10837   81D9   85 A4       		STA	RAND+LO
10838   81DB   F0 26       		BEQ	ZRAND3		; JMP  (END EZIP)
10839   81DD   A5 63       	ZRAND2:	LDA	ARG1+LO		; MAKE [ARG1] THE DIVISOR
10840   81DF   85 65       		STA	ARG2+LO
10841   81E1   A5 64       		LDA	ARG1+HI
10842   81E3   85 66       		STA	ARG2+HI
10843   81E5   20 D9 52    		JSR	RANDOM		; GET RANDOM BYTES INTO [A] AND [X]
10844   81E8   86 63       		STX	ARG1+LO		; MAKE THEM THE DIVIDEND
10845   81EA   29 7F       		AND	#$7F		; MAKE SURE MSB IS POSITIVE
10846   81EC   85 64       		STA	ARG1+HI
10847   81EE   20 DC 7E    		JSR	DIVIDE		; SIGNED DIVIDE, [ARG1] / [ARG2]
10848   81F1   AD 8B 6C    		LDA	REMAIN+LO	; MOVE REMAINDER
  Tue Jun 13 1989 11:42                                                                                                  Page  163

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10849   81F4   18          		CLC
10850   81F5   69 01       		ADC	#1		; ADD 1
10851   81F7   85 76       		STA	VALUE+LO	; INTO [VALUE]
10852   81F9   AD 8C 6C    		LDA	REMAIN+HI
10853   81FC   69 00       		ADC	#0
10854   81FE   85 77       		STA	VALUE+HI
10855   8200   4C D1 43    		JMP	PUTVAL		; AND RETURN RESULT
10856                      	
10857                      		; NON RANDOM INCREMENTING
10858                      	
10859   8203               	ZRAND3:
10860   8203   A5 A5       		LDA	RAND+HI	; (EZIP)
10861   8205   CD A0 6C    		CMP	SRHOLD+HI
10862   8208   90 11       		BCC	ZRAND4
10863   820A   A5 A4       		LDA	RAND+LO
10864   820C   CD 9F 6C    		CMP	SRHOLD+LO
10865   820F   90 0A       		BCC	ZRAND4
10866   8211   F0 08       		BEQ	ZRAND4
10867   8213   A9 01       		LDA	#1		; WENT THRU ALL
10868   8215   85 A4       		STA	RAND+LO	; START AGAIN
10869   8217   A9 00       		LDA	#0
10870   8219   85 A5       		STA	RAND+HI
10871   821B   A5 A4       	ZRAND4:	LDA	RAND+LO
10872   821D   85 76       		STA	VALUE+LO
10873   821F   A5 A5       		LDA	RAND+HI
10874   8221   85 77       		STA	VALUE+HI
10875   8223   E6 A4       		INC	RAND+LO	; FOR NEXT TIME
10876   8225   D0 02       		BNE	ZRAND5
10877   8227   E6 A5       		INC	RAND+HI
10878   8229   4C D1 43    	ZRAND5:	JMP	PUTVAL		; (END EZIP)
10879                      	
10880                      	
10881                      	; ----
10882                      	; PUSH
10883                      	; ----
10884                      	; PUSH [ARG1] ONTO THE Z-STACK
10885                      	
10886   822C   A6 63       	ZPUSH:	LDX	ARG1+LO	
10887   822E   A5 64       		LDA	ARG1+HI	
10888   8230   4C 8B 43    		JMP	PUSHXA	
10889                      	
10890                      	
10891                      	; ---
10892                      	; POP
10893                      	; ---
10894                      	; POP WORD OFF Z-STACK, STORE IN VARIABLE [ARG1]
10895                      	
10896   8233               	ZPOP:
10897   8233   A5 62       		lda	NARGS		; check whether it wants game or passed stack
10898   8235   F0 56       		beq	ZPOP1		; must want from game stack
10899                      	
10900   8237   A5 63       		lda	ARG1+LO		; get me the address of the LTABLE
10901   8239   85 8C       		sta	FPCL		; for munging with
10902   823B   A5 64       		lda	ARG1+HI		; this is page
10903   823D   20 A9 8F    		jsr	SETPC		; get me actual page/bank
10904   8240   85 8D       		sta	FPCH		; set page
10905   8242   84 8E       		sty	FPCBNK		; and bank
10906                      	
10907   8244   20 88 92    		jsr	FETCHB		; this is hi part of counter
10908   8247   85 7B       		sta	J+HI		; save it
10909   8249   20 F0 8F    		jsr	NEXTFPC		; point to lo part
10910   824C   20 88 92    		jsr	FETCHB		; get it
10911   824F   85 7A       		sta	J+LO		; save it
10912                      	;
10913                      	; now count popping this one and stash it into the table
10914                      	;
10915   8251   E6 7A       		inc	J+LO		; count it
10916   8253   D0 02       		bne	ZPOP2		; wrapped?
10917   8255   E6 7B       		inc	J+HI		; increment MSB
10918   8257               	ZPOP2:
10919   8257   20 A5 90    		jsr	FP2SP		; set up to stash back in beginning of LTABLE
10920   825A   A5 7A       		lda	J+LO		; LSB first
10921   825C   20 67 92    		jsr	STASHB		; saved it
10922   825F   20 80 90    		jsr	PREVSPC		; point to MSB
10923   8262   A5 7B       		lda	J+HI		; get it
  Tue Jun 13 1989 11:42                                                                                                  Page  164

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10924   8264   20 67 92    		jsr	STASHB		; saved it
10925                      	;
10926                      	; finally, we can save the arg into the stack
10927                      	;
10928   8267   06 7A       		asl	J+LO		; make a word offset (*2)
10929   8269   26 7B       		rol	J+HI		; pick up carry maybe
10930   826B   A5 7A       		lda	J+LO		; add in arg offset
10931   826D   18          		clc			; adding
10932   826E   65 63       		adc	ARG1+LO		; figger offset
10933   8270   85 8C       		sta	FPCL		; this goes here for fetching
10934   8272   A5 7B       		lda	J+HI		; now page
10935   8274   65 64       		adc	ARG1+HI		; add in start of table
10936   8276   20 A9 8F    		jsr	SETPC		; get me memory page
10937   8279   85 8D       		sta	FPCH		; page
10938   827B   84 8E       		sty	FPCBNK		; and bank
10939   827D   20 88 92    		jsr	FETCHB		; get MSB
10940   8280   85 77       		sta	VALUE+HI	; save value
10941   8282   20 F0 8F    		jsr	NEXTFPC		; and point to LSB
10942   8285   20 88 92    		jsr	FETCHB		; get LSB
10943   8288   85 76       		sta	VALUE+LO	; and save
10944   828A   4C 90 82    		jmp	ZPOP3		; and return it
10945   828D               	ZPOP1:
10946   828D   20 56 43    		jsr	POPVAL		; VALUE INTO [VALUE]
10947   8290               	ZPOP3:
10948   8290   4C D1 43    		jmp	PUTVAL		; AND put the data away
10949                      	
10950                      	
10951                      	; ------
10952                      	; INTBL?
10953                      	; ------
10954                      	
10955   8293               	ZINTBL:
10956   8293   A5 68       		LDA	ARG3+HI		; JIC COUNT IS 0,
10957   8295   30 7D       		BMI	INTNF		; >0, just ignore!
10958   8297   05 67       		ORA	ARG3+LO
10959   8299   F0 79       		BEQ	INTNF		; SAY NOT FOUND
10960                      	
10961   829B   A5 62       		LDA	NARGS		; IS THERE A RECORD SPEC?
10962   829D   C9 04       		CMP	#4
10963   829F   F0 04       		BEQ	SET4
10964   82A1   A9 82       	SETDEF:	LDA	#130		; NO, SET DEFAULT
10965   82A3   85 69       		STA	ARG4+LO
10966                      	
10967   82A5   A5 69       	SET4:	LDA	ARG4+LO
10968   82A7   F0 F8       		BEQ	SETDEF		; GO BACK AND GET VALUE
10969   82A9   A9 00       		LDA	#0		; COMPARE BYTE OR WORD?
10970   82AB   06 69       		ASL	ARG4+LO
10971   82AD   2A          		ROL	A		; PICK UP INDICATOR
10972   82AE   46 69       		LSR	ARG4+LO		; CLEAR FROM RECORD LENGTH
10973   82B0   8D 8E 5B    		STA	TYPE 		; BYTE (0) OR WORD (1)
10974   82B3   AD 8E 5B    		LDA	TYPE		; SET FLAG
10975   82B6   D0 04       		BNE	SETTBL
10976   82B8   A5 63       		LDA	ARG1+LO		; IF ONLY BYTE, MOVE IT
10977   82BA   85 64       		STA	ARG1+HI		; TO FIRST BYTE CHECKED
10978   82BC               	SETTBL:
10979   82BC   A5 65       		LDA	ARG2+LO		; PICK UP TBL ADDR
10980   82BE   85 86       		STA	MPCL
10981   82C0   A5 66       		LDA	ARG2+HI
10982   82C2   85 87       		STA	MPCM
10983   82C4   A9 00       		LDA	#0
10984   82C6   85 88       		STA	MPCH		; ONLY A WORD ADDR, SO IN 1ST 64K
10985   82C8   20 B2 90    		JSR	VLDMPC
10986                      	
10987   82CB   A5 86       	INTLP:	LDA	MPCL		; HOLD START ADDR, MPC WILL BE A MESS
10988   82CD   8D 7B 00    		STA	VWCUR+0
10989   82D0   A5 87       		LDA	MPCM
10990   82D2   8D 7C 00    		STA	VWCUR+1
10991   82D5   A5 88       		LDA	MPCH
10992   82D7   8D 7D 00    		STA	VWCUR+2
10993   82DA   20 3B 92    		JSR	GETBYT		; GET 1ST BYTE
10994   82DD   C5 64       		CMP	ARG1+HI		; DOES IT = THE VALUE LOOKING FOR?
10995   82DF   D0 0C       		BNE	INTNXT		; NO
10996   82E1   AD 8E 5B    		LDA	TYPE
10997   82E4   F0 3A       		BEQ	INTFND		; ONLY COMPARING A BYTE SO FOUND!
10998   82E6   20 3B 92    		JSR	GETBYT
  Tue Jun 13 1989 11:42                                                                                                  Page  165

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

10999   82E9   C5 63       		CMP	ARG1+LO
11000   82EB   F0 33       		BEQ	INTFND		; YES, FOUND IT
11001   82ED               	INTNXT:
11002   82ED   AD 7B 00    		LDA	VWCUR+0		; TO MOVE UP, JUST ADD
11003   82F0   18          		CLC			; OFFSET FROM START OF THIS
11004   82F1   65 69       		ADC	ARG4+LO		; ENTRY
11005   82F3   85 86       		STA	MPCL
11006   82F5   90 11       		BCC	INEXT0
11007                      	
11008   82F7   AD 7C 00    		LDA	VWCUR+1		; PICK UP CARRY
11009   82FA   69 00       		ADC	#0
11010   82FC   85 87       		STA	MPCM
11011   82FE   AD 7D 00    		LDA	VWCUR+2
11012   8301   69 00       		ADC	#0
11013   8303   85 88       		STA	MPCH
11014   8305   20 B2 90    		JSR	VLDMPC		; CROSSED PAGE SO RE-VALIDATE
11015                      	
11016   8308   C6 67       	INEXT0:	DEC	ARG3+LO		; CHECKED ALL ENTRIES?
11017   830A   D0 BF       		BNE	INTLP
11018   830C   A5 68       		LDA	ARG3+HI
11019   830E   F0 04       		BEQ	INTNF
11020   8310   C6 68       		DEC	ARG3+HI
11021   8312   D0 B7       		BNE	INTLP
11022                      	
11023   8314               	INTNF:
11024   8314   A9 00       		LDA	#0		; 0 = NOT FOUND
11025   8316   85 76       		STA	VALUE+LO
11026   8318   85 77       		STA	VALUE+HI
11027   831A   20 D1 43    		JSR	PUTVAL
11028   831D   4C 1F 44    		JMP	PREDF		; FAILED!
11029                      	
11030   8320               	INTFND:
11031   8320   AD 7B 00    		LDA	VWCUR+LO
11032   8323   85 76       		STA	VALUE+LO	; AND SET TO RETURN THE VALUE
11033   8325   AD 7C 00    		LDA	VWCUR+HI
11034   8328   85 77       		STA	VALUE+HI
11035   832A   20 D1 43    		JSR	PUTVAL		; SEND IT BACK
11036   832D   4C 2B 44    		JMP	PREDS		; AND SCREEM SUCCESS
11037                      	
11038                      	; ----
11039                      	; BCOM
11040                      	; ----
11041                      	; COMPLEMENT [ARG1]
11042                      	
11043   8330   A5 63       	ZBCOM:	LDA	ARG1+LO
11044   8332   49 FF       		EOR	#$FF
11045   8334   85 76       		STA	VALUE+LO
11046   8336   A5 64       		LDA	ARG1+HI
11047   8338   49 FF       		EOR	#$FF
11048   833A   85 77       		STA	VALUE+HI
11049   833C   4C D1 43    		JMP	PUTVAL
11050                      	
11051                      	
11052                      	; -----
11053                      	; COPYT
11054                      	; -----
11055                      	
11056   833F               	ZCOPYT:
11057   833F   A5 65       		LDA	ARG2+LO		; CHECK OUT WHAT'S TO BE DONE
11058   8341   05 66       		ORA	ARG2+HI
11059   8343   D0 03       		BNE	ZC0
11060   8345   4C F4 83    		JMP	CASE1		; ZERO LENGTH BYTES OF SOURCE
11061   8348               	ZC0:
11062   8348   A5 68       		LDA	ARG3+HI
11063   834A   C9 7F       		CMP	#$7F
11064   834C   90 03       		BCC	CASE2
11065   834E   4C 1A 84    		JMP	CASE3		; FORWARD COPY
11066                      	
11067                      		; CASE2 - CHECK IF FORWARD OR BACKWARD COPY
11068                      	
11069   8351   A5 64       	CASE2:	LDA	ARG1+HI		; IF SRC < DEST
11070   8353   C5 66       		CMP	ARG2+HI
11071   8355   90 0D       		BCC	CHK2
11072   8357   F0 03       		BEQ	ZC1
11073   8359   4C 7D 83    		JMP	FRWRD		; NO
  Tue Jun 13 1989 11:42                                                                                                  Page  166

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11074   835C   A5 63       	ZC1:	LDA	ARG1+LO
11075   835E   C5 65       		CMP	ARG2+LO
11076   8360   F0 02       		BEQ	CHK2
11077   8362   B0 19       		BCS	FRWRD		; NO
11078   8364   A5 63       	CHK2:	LDA	ARG1+LO		; AND SRC + LENGTH > DEST
11079   8366   18          		CLC
11080   8367   65 67       		ADC	ARG3+LO
11081   8369   85 78       		STA	I+LO
11082   836B   A5 64       		LDA	ARG1+HI
11083   836D   65 68       		ADC	ARG3+HI
11084   836F   C5 66       		CMP	ARG2+HI
11085   8371   90 0A       		BCC	FRWRD		; NO
11086   8373   D0 3E       		BNE	BKWRD		; YES
11087   8375   A5 78       		LDA	I+LO
11088   8377   C5 65       		CMP	ARG2+LO
11089   8379   F0 02       		BEQ	FRWRD		; DEBUG, IF EQUAL REALLY LESS
11090   837B   B0 36       		BCS	BKWRD		; OVERLAPS SO DO BACKWARD COPY
11091                      	
11092                      		; ELSE FALL THROUGH TO FORWARD COPY
11093                      	
11094   837D   A9 00       	FRWRD:	LDA	#0		; USE GETBYT CAUSE MAY  BE
11095   837F   85 88       		STA	MPCH		; BEYOND MAIN MEMORY
11096   8381   A5 64       		LDA	ARG1+HI
11097   8383   85 87       		STA	MPCM
11098   8385   A5 63       		LDA	ARG1+LO
11099   8387   85 86       		STA	MPCL
11100   8389   20 B2 90    		JSR	VLDMPC		; AND ALIGN TO CORRECT PAGE
11101   838C   A5 65       		LDA	ARG2+LO
11102   838E   85 8F       		STA	SPCL
11103   8390   A5 66       		LDA	ARG2+HI
11104   8392   20 A9 8F    		jsr	SETPC		; get memory spot
11105   8395   85 90       		sta	SPCH		; high part
11106   8397   84 91       		sty	SPCBNK		; and the bank part
11107   8399   A5 67       		LDA	ARG3+LO
11108   839B   85 7A       		STA	J+LO
11109   839D   A5 68       		LDA	ARG3+HI
11110   839F   85 7B       		STA	J+HI
11111   83A1               	FRLP:
11112   83A1   20 B6 44    		jsr	DECJ
11113   83A4   90 0C       		bcc	FRDUN		; CARRY CLEAR ON $FFFF
11114   83A6   20 3B 92    		jsr	GETBYT
11115   83A9   20 67 92    		jsr	STASHB		; and save it
11116   83AC   20 D0 8F    		jsr	NEXTSPC		; and point to next one
11117   83AF   4C A1 83    		jmp	FRLP
11118   83B2               	FRDUN:
11119   83B2   60          		rts
11120                      	
11121                      	
11122   83B3               	BKWRD:	
11123   83B3   A5 67       		LDA	ARG3+LO		; DECR 1ST TO GET CORRECT OFFSET
11124   83B5   85 7A       		STA	J+LO
11125   83B7   A5 68       		LDA	ARG3+HI
11126   83B9   85 7B       		STA	J+HI
11127   83BB   20 B6 44    		JSR	DECJ
11128   83BE   A5 63       		LDA	ARG1+LO		; SET TO END OF SOURCE & DEST.
11129   83C0   18          		CLC
11130   83C1   65 7A       		ADC	J+LO
11131   83C3   85 8C       		sta	FPCL		; set up fetch pointer
11132   83C5   A5 64       		LDA	ARG1+HI
11133   83C7   65 7B       		ADC	J+HI
11134   83C9   20 A9 8F    		jsr	SETPC		; and get mem locations
11135   83CC   85 8D       		sta	FPCH
11136   83CE   84 8E       		sty	FPCBNK
11137   83D0   A5 65       		LDA	ARG2+LO
11138   83D2   18          		CLC
11139   83D3   65 7A       		ADC	J+LO
11140   83D5   85 8F       		sta	SPCL		; and now set up stash pointer
11141   83D7   A5 66       		LDA	ARG2+HI
11142   83D9   65 7B       		ADC	J+HI
11143   83DB   20 A9 8F    		jsr	SETPC		; and get me page/bank
11144   83DE   85 90       		sta	SPCH
11145   83E0   84 91       		sty	SPCBNK
11146   83E2               	BKLP:
11147   83E2   20 88 92    		jsr	FETCHB		; get byte
11148   83E5   20 67 92    		jsr	STASHB		; and save it
  Tue Jun 13 1989 11:42                                                                                                  Page  167

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11149   83E8   20 56 90    		jsr	PREVFPC		; going backwards
11150   83EB   20 80 90    		jsr	PREVSPC		; and here too
11151   83EE   20 B6 44    		jsr	DECJ		; RETURNS CARRY CLEAR ON $FFFF
11152   83F1   B0 EF       		bcs	BKLP
11153   83F3               	BKDUN:
11154   83F3   60          		RTS
11155                      	
11156                      		; ZERO LENGTH # OF BYTES OF SOURCE
11157                      	
11158   83F4   A5 63       	CASE1:	LDA	ARG1+LO
11159   83F6   85 8F       		STA	SPCL		; set stash pointer
11160   83F8   A5 64       		LDA	ARG1+HI
11161   83FA   20 A9 8F    		jsr	SETPC		; get page/bank
11162   83FD   85 90       		sta	SPCH
11163   83FF   84 91       		sty	SPCBNK
11164   8401   A5 67       		LDA	ARG3+LO		; SET UP COUNTER
11165   8403   85 7A       		STA	J+LO
11166   8405   A5 68       		LDA	ARG3+HI
11167   8407   85 7B       		STA	J+HI
11168   8409               	C1LP:
11169   8409   20 B6 44    		jsr	DECJ		; CARRY CLEAR WHEN J = $FFFF
11170   840C   90 0B       		bcc	C1DUN
11171   840E   A9 00       		lda	#0
11172   8410   20 67 92    		jsr	STASHB		; and zero it
11173   8413   20 D0 8F    		jsr	NEXTSPC		; and point to next one
11174   8416   4C 09 84    		jmp	C1LP
11175   8419               	C1DUN:
11176   8419   60          		rts
11177                      	
11178                      		; 2'S COMPLEMENT LENGTH (XOR + 1) THEN DO FORWARD COPY
11179                      	
11180   841A               	CASE3:
11181   841A   A5 67       		LDA	ARG3+LO
11182   841C   49 FF       		EOR	#$FF
11183   841E   85 67       		STA	ARG3+LO
11184   8420   A5 68       		LDA	ARG3+HI
11185   8422   49 FF       		EOR	#$FF
11186   8424   85 68       		STA	ARG3+HI
11187   8426   E6 67       		INC	ARG3+LO
11188   8428   D0 02       		BNE	GOFRWD
11189   842A   E6 68       		INC	ARG3+HI
11190   842C   4C 7D 83    	GOFRWD:	JMP	FRWRD
11191                      	
11192                      	
11193                      	; ---------
11194                      	; ASSIGNED?
11195                      	; ---------
11196                      	
11197                      	
11198   842F               	ZASSND:
11199   842F   A5 63       		LDA	ARG1+LO		; COMPARE TO # OF OPTIONALS FROM LAST CALL
11200   8431   CD 8F 5B    		CMP	ASSVLU
11201   8434   90 05       		BCC	DOYES		; IF LESS OR EQUAL, WAS ASSIGNED
11202   8436   F0 03       		BEQ	DOYES
11203   8438   4C 1F 44    		JMP	PREDF
11204   843B               	DOYES:
11205   843B   4C 2B 44    		JMP	PREDS
11206                      	
11207                      	
11208                      	; -------------
11209                      	; LOGICAL SHIFT
11210                      	; -------------
11211                      	; SHIFT ARG1, ARG2 BITS (LEFT IF ARG2 IS POS. RIGHT IF NEG.)
11212                      	
11213   843E   A5 63       	ZSHIFT:	LDA	ARG1+LO		; SET UP FOR SHIFT
11214   8440   85 76       		STA	VALUE+LO
11215   8442   A5 64       		LDA	ARG1+HI
11216   8444   85 77       		STA	VALUE+HI
11217   8446   A5 65       		LDA	ARG2+LO		; IF NEGATIVE, SHIFT RIGHT
11218   8448   C9 80       		CMP	#$80
11219   844A   B0 0B       		BCS	SRIGHT
11220                      	
11221                      		; SHIFT LEFT
11222                      	
11223   844C   A8          		TAY			; COUNT
  Tue Jun 13 1989 11:42                                                                                                  Page  168

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11224   844D   06 76       	SLP1:	ASL	VALUE+LO
11225   844F   26 77       		ROL	VALUE+HI
11226   8451   88          		DEY
11227   8452   D0 F9       		BNE	SLP1
11228   8454   4C D1 43    		JMP	PUTVAL		; AND RETURN THE VALUE
11229                      	
11230   8457   49 FF       	SRIGHT:	EOR	#$FF		; COMPLEMENT
11231   8459   A8          		TAY
11232   845A   46 77       	SLP2:	LSR	VALUE+HI	; SHIFT
11233   845C   66 76       		ROR	VALUE+LO
11234   845E   88          		DEY
11235   845F   10 F9       		BPL	SLP2
11236   8461   4C D1 43    		JMP	PUTVAL
11237                      	
11238                      	
11239                      	; ----------------
11240                      	; ARITHMETIC SHIFT
11241                      	; ----------------
11242                      	; PROPAGATING SIGN BIT ON RIGHT SHIFT
11243                      	
11244   8464   A5 65       	ZASHFT:	LDA	ARG2+LO		; IF NEGATIVE, SHIFT RIGHT
11245   8466   C9 80       		CMP	#$80
11246   8468   90 D4       		BCC	ZSHIFT		; SAME AS LOGICAL SHIFT
11247   846A   A6 63       		LDX	ARG1+LO		; SET UP FOR SHIFT
11248   846C   86 76       		STX	VALUE+LO
11249   846E   A6 64       		LDX	ARG1+HI
11250   8470   86 77       		STX	VALUE+HI
11251                      	
11252   8472   49 FF       		EOR	#$FF		; COMPLEMENT COUNT
11253   8474   A8          		TAY
11254   8475   A5 64       	ASLP2:	LDA	ARG1+HI
11255   8477   0A          		ASL	A		; GET SIGN BIT
11256   8478   66 77       		ROR	VALUE+HI	; SHIFT
11257   847A   66 76       		ROR	VALUE+LO
11258   847C   88          		DEY
11259   847D   10 F6       		BPL	ASLP2
11260   847F   4C D1 43    		JMP	PUTVAL
11261   8482               		
11262                      	; --------
11263                      	; XPUSH
11264                      	; --------
11265   8482               	ZXPUSH:
11266   8482   A5 65       		lda	ARG2+LO		; get me the address of the LTABLE
11267   8484   85 8C       		sta	FPCL		; for munging with
11268   8486   A5 66       		lda	ARG2+HI		; this is page
11269   8488   20 A9 8F    		jsr	SETPC		; get me actual page/bank
11270   848B   85 8D       		sta	FPCH		; set page
11271   848D   84 8E       		sty	FPCBNK		; and bank
11272                      	
11273   848F   20 88 92    		jsr	FETCHB		; this is hi part of counter
11274   8492   85 7B       		sta	J+HI		; save it
11275   8494   20 F0 8F    		jsr	NEXTFPC		; point to lo part
11276   8497   20 88 92    		jsr	FETCHB		; get it
11277   849A   85 7A       		sta	J+LO		; thanx
11278   849C   05 7B       		ora	J+HI		; check for zero elements left
11279   849E   D0 03       		bne	ZXP0		; yes, there is room at the inn
11280                      	
11281   84A0   4C 1F 44    		jmp	PREDF		; no room here!
11282   84A3               	ZXP0:
11283   84A3   20 A5 90    		jsr	FP2SP		; set up to stash back in beginning of LTABLE
11284   84A6   A5 7B       		lda	J+HI		; now the MSB
11285   84A8   85 7D       		sta	K+HI		; and saved it
11286   84AA   A5 7A       		lda	J+LO		; save this
11287   84AC   85 7C       		sta	K+LO		; save it
11288                      	;
11289                      	; now count this one and stash it into the table
11290                      	;
11291   84AE   D0 02       		bne	ZXP1		; nope, dec okay
11292   84B0   C6 7B       		dec	J+HI		; decrement MSB
11293   84B2               	ZXP1:
11294   84B2   C6 7A       		dec	J+LO		; and the LSB
11295   84B4   A5 7A       		lda	J+LO		; LSB first
11296   84B6   20 67 92    		jsr	STASHB		; saved it
11297   84B9   20 80 90    		jsr	PREVSPC		; point to MSB
11298   84BC   A5 7B       		lda	J+HI		; get it
  Tue Jun 13 1989 11:42                                                                                                  Page  169

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11299   84BE   20 67 92    		jsr	STASHB		; saved it
11300                      	;
11301                      	; finally, we can save the arg into the stack
11302                      	;
11303   84C1   06 7C       		asl	K+LO		; make a word offset (*2)
11304   84C3   26 7D       		rol	K+HI		; pick up carry maybe
11305   84C5   A5 7C       		lda	K+LO		; add in arg offset
11306   84C7   18          		clc			; adding
11307   84C8   65 65       		adc	ARG2+LO		; figger offset
11308   84CA   85 8F       		sta	SPCL		; this goes here for stashing
11309   84CC   A5 7D       		lda	K+HI		; now page
11310   84CE   65 66       		adc	ARG2+HI		; add in start of table
11311   84D0   20 A9 8F    		jsr	SETPC		; get me memory page
11312   84D3   85 90       		sta	SPCH		; page
11313   84D5   84 91       		sty	SPCBNK		; and bank
11314                      	
11315   84D7   A5 64       		lda	ARG1+HI		; push MSB
11316   84D9   20 67 92    		jsr	STASHB		; saved
11317   84DC   20 D0 8F    		jsr	NEXTSPC		; point to next one
11318   84DF   A5 63       		lda	ARG1+LO		; and now LSB 
11319   84E1   20 67 92    		jsr	STASHB		; into the stack
11320   84E4   4C 2B 44    		jmp	PREDS		; show we worked good
11321                      	;---------
11322                      	; ZFSTACK
11323                      	;---------
11324   84E7               	ZFSTACK:
11325   84E7   C6 62       		dec	NARGS		; how many args there?
11326   84E9   D0 0E       		bne	ZFS1		; flush ARG2 stack
11327                      	;
11328                      	; pop from system stack
11329                      	;
11330   84EB   A5 63       		lda	ARG1+LO		; just add number to system counter
11331   84ED   18          		clc			; adding
11332   84EE   65 AF       		adc	ZSP+LO		; added
11333   84F0   85 AF       		sta	ZSP+LO		; and saved
11334   84F2   A5 64       		lda	ARG1+HI		; get hi part
11335   84F4   65 B0       		adc	ZSP+HI		; add in hi part
11336   84F6   85 B0       		sta	ZSP+HI		; save hi part
11337   84F8   60          		rts
11338   84F9               	ZFS1:
11339   84F9   A5 65       		lda	ARG2+LO		; get LTABLE we are interested in
11340   84FB   85 8C       		sta	FPCL		; set up FPC first
11341   84FD   A5 66       		lda	ARG2+HI		; and page
11342   84FF   20 A9 8F    		jsr	SETPC		; tell me where
11343   8502   85 8D       		sta	FPCH		; save me where
11344   8504   84 8E       		sty	FPCBNK		; FPC all set
11345   8506   20 A5 90    		jsr	FP2SP		; have SPC point to stack too
11346                      	
11347   8509   20 88 92    		jsr	FETCHB		; get MSB of counter
11348   850C   85 7B       		sta	J+HI		; save MSB
11349   850E   20 F0 8F    		jsr	NEXTFPC		; point to LSB
11350   8511   20 88 92    		jsr	FETCHB		; get LSB
11351   8514   85 7A       		sta	J+LO		; save LSB
11352   8516               		
11353   8516   A5 7A       		lda	J+LO		; get LSB back
11354   8518   18          		clc			; get ready for add
11355   8519   65 63       		adc	ARG1+LO		; add how many to get rid off
11356   851B   85 7A       		sta	J+LO		; save new counter
11357   851D   A5 7B       		lda	J+HI		; get MSB
11358   851F   65 64       		adc	ARG1+HI		; add MSB
11359                      	
11360   8521   20 67 92    		jsr	STASHB		; save Msb of new counter
11361   8524   20 D0 8F    		jsr	NEXTSPC		; point to LSB
11362   8527   A5 7A       		lda	J+LO		; get lsb
11363   8529   20 67 92    		jsr	STASHB		; okay, reset the counter
11364   852C   60          		rts
11365                      	
11366                      	;
11367                      	; no mouse stuff yet
11368                      	;
11369   852D               	ZMINFO:
11370   852D               	ZMLIMIT:
11371   852D   60          		rts
11372   852E               	ZMENU:
11373   852E   4C 1F 44    		jmp	PREDF		; no menu stuff either
  Tue Jun 13 1989 11:42                                                                                                  Page  170

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- X-OPS ---"

11374                      	
11375   8531               		END
11376                      	
11377   8531               		INCLUDE 	READ.ASM
11378   8531               		STTL "--- READ HANDLER ---"
11379                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page  171

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11380                      	; ----
11381                      	; READ
11382                      	; ----
11383                      	; READ LINE INTO TABLE [ARG1] ; PARSE INTO TABLE [ARG2] (IF ARG2 IS THERE)
11384                      	
11385   8531   00          	MAXWORDS DB	0		; maximum number of words in table
11386   8532   00          	WORDCNT	DB	0		; how many words read so far
11387   8533   00          	WORDSTART DB	0		; table offset of word
11388   8534               	SAVESPC	DS	3		; SPC that points to Word Count
11389                      	
11390   8537               	ZREAD:
11391   8537   A5 64       		lda	ARG1+HI		; MAKE THE TABLE ADDRESSES
11392   8539   8D A9 6C    		sta	RDTBL1+HI	; AND PLACE IT HERE TO USE
11393   853C   A5 63       		lda	ARG1+LO
11394   853E   8D A8 6C    		sta	RDTBL1+LO	; LSBS NEED NOT CHANGE
11395                      	
11396   8541   A9 00       		lda	#0		; TURN OFF FLAGS
11397   8543   8D 85 6C    		sta	PSVFLG		; FOR ZLEX
11398   8546   8D 86 6C    		sta	VOCFLG
11399                      	
11400   8549   A6 62       		ldx	NARGS
11401   854B   CA          		dex			; IF 2ND TBL ADDR 0 OR NOT THERE
11402   854C   F0 14       		beq	ONLYRD		; JUST READ IN DON'T DO CONVERSION (X)
11403   854E   A2 00       		ldx	#0		; JIC
11404   8550   A5 66       		lda	ARG2+HI
11405   8552   05 65       		ora	ARG2+LO
11406   8554   F0 0C       		beq	ONLYRD
11407                      	
11408   8556   A5 66       		lda	ARG2+HI
11409   8558   8D AB 6C    		sta	RDTBL2+HI
11410   855B   A5 65       		lda	ARG2+LO
11411   855D   8D AA 6C    		sta	RDTBL2+LO
11412                      	
11413   8560   A2 01       		ldx	#1		;  1 = DO IT ALL (X)
11414   8562               	ONLYRD:
11415   8562   8E 91 5B    		stx	RDFLAG		; CHECK AGAIN AFTER READ IN WHAT TO DO
11416   8565   20 24 59    		jsr	INPUT		; READ LINE; RETURN LENGTH IN [RDTBL1],1
11417                      	
11418   8568   AD 91 5B    		lda	RDFLAG		; FLAG (X)
11419   856B   F0 03       		beq	RDEX		; IF INPUT ONLY, LEAVE NOW
11420   856D   20 7D 85    		jsr	DOREST
11421   8570               	RDEX:
11422   8570   A9 F0       		lda	#$F0		; RETURN NOW ONLY WANTED READ PART
11423   8572   8D 91 5B    		sta	RDFLAG
11424   8575   AD 90 5B    		lda	BRKCHR		; GET BREAK CHAR
11425   8578   A2 00       		ldx	#0
11426   857A   4C CD 43    		jmp	PUTBYT		; RETURN IT 
11427                      	;
11428                      	; IF TIMEOUT, [A]=0 SO WILL QUIT W/NO RESULTS
11429                      	;
11430   857D               	DOREST:
11431   857D   AD AB 6C    		lda	RDTBL2+HI	; get max number of words
11432   8580   20 A9 8F    		jsr	SETPC		; tell me memory and bank
11433   8583   85 8D       		sta	FPCH		; save page
11434   8585   84 8E       		sty	FPCBNK		; and bank
11435   8587   AD AA 6C    		lda	RDTBL2+LO	; and for LSB
11436   858A   85 8C       		sta	FPCL		; it is same
11437   858C   20 88 92    		jsr	FETCHB		; get max # of words in table
11438   858F   F0 04       		beq	RDERR		; (5/14/85 - FORCE # WORDS TO
11439   8591   C9 3B       		cmp	#59		; BE BETWEEN 1 AND 59)
11440   8593   90 02       		bcc	RD0
11441   8595               	RDERR:
11442   8595   A9 3A       		lda	#58		; (5/16/86 - MAKE IT 58, 59 LOST)
11443   8597               	RD0:
11444   8597   8D 31 85    		sta	MAXWORDS	; save max words
11445   859A   A9 00       		lda	#0		; start at 0 words
11446   859C   8D 32 85    		sta	WORDCNT		; save it
11447   859F   85 94       		sta	WRDLEN		; INIT # CHARS IN WORD COUNTER
11448   85A1   A9 02       		lda	#2		
11449   85A3   85 93       		sta	SOURCE		; INIT SOURCE TABLE PNTR
11450                      	;
11451                      	; now futz with destination table a little
11452                      	;
11453   85A5   20 F0 8F    		jsr	NEXTFPC		; now we point to # words read
11454   85A8   A5 8E       		lda	FPCBNK		; and save this pointer
  Tue Jun 13 1989 11:42                                                                                                  Page  172

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11455   85AA   8D 34 85    		sta	SAVESPC		; for stashing at the end
11456   85AD   A5 8D       		lda	FPCH
11457   85AF   8D 35 85    		sta	SAVESPC+1
11458   85B2   A5 8C       		lda	FPCL
11459   85B4   8D 36 85    		sta	SAVESPC+2
11460                      	
11461   85B7   A9 04       		lda	#4		; offset to end of first entry
11462   85B9   20 10 90    		jsr	ADDFPC		; and point to end of first entry
11463   85BC   20 A5 90    		jsr	FP2SP		; now put RDTBL2 into stash pointer
11464                      	;
11465                      	; now get source table
11466                      	;	
11467   85BF   AD A9 6C    		lda	RDTBL1+HI	; get page
11468   85C2   20 A9 8F    		jsr	SETPC		; and tell me what mem page and bank
11469   85C5   85 8D       		sta	FPCH		; set up fetch counter
11470   85C7   84 8E       		sty	FPCBNK		; and bank
11471   85C9   AD A8 6C    		lda	RDTBL1+LO	; and lo stays the same
11472   85CC   85 8C       		sta	FPCL		; and save it
11473   85CE   20 F0 8F    		jsr	NEXTFPC		; get # of chars in buffer
11474   85D1   20 88 92    		jsr	FETCHB		; and tell me about it
11475   85D4   85 92       		sta	LINLEN		; SAVE # CHARS IN LINE
11476   85D6   20 F0 8F    		jsr	NEXTFPC		; now point to first char in line
11477                      	;
11478                      	; MAIN LOOP STARTS HERE
11479                      	;
11480   85D9               	READL:
11481   85D9   AD 31 85    		lda	MAXWORDS	; how we doin'?
11482   85DC   CD 32 85    		cmp	WORDCNT		; see if we have maxxed out
11483   85DF   90 06       		bcc	RLEX		; all done, thank you
11484                      	
11485   85E1   A5 92       		lda	LINLEN
11486   85E3   05 94       		ora	WRDLEN		; OUT OF CHARS AND WORDS?
11487   85E5   D0 16       		bne	RL2		; NOT YET
11488   85E7               	RLEX:
11489   85E7   AD 34 85    		lda	SAVESPC		; now set SPC to point to # words
11490   85EA   85 91       		sta	SPCBNK		; read byte, as saved at the beginning
11491   85EC   AD 35 85    		lda	SAVESPC+1
11492   85EF   85 90       		sta	SPCH
11493   85F1   AD 36 85    		lda	SAVESPC+2
11494   85F4   85 8F       		sta	SPCL
11495   85F6   AD 32 85    		lda	WORDCNT		; get word count
11496   85F9   20 67 92    		jsr	STASHB		; and save it
11497   85FC   60          		rts
11498   85FD               	RL2:
11499   85FD   A5 94       		lda	WRDLEN		; GET WORD LENGTH
11500   85FF   C9 09       		cmp	#9		; 9 CHARS DONE? (EZIP)
11501   8601   90 03       		bcc	RL3		; NO, KEEP GOING
11502   8603   20 34 87    		jsr	FLUSHW		; ELSE FLUSH REMAINDER OF WORD
11503   8606               	RL3:
11504   8606   A5 94       		lda	WRDLEN		; GET WORD LENGTH AGAIN
11505   8608   D0 24       		bne	READL2		; CONTINUE IF NOT FIRST CHAR
11506                      	;
11507                      	; START A NEW WORD
11508                      	;
11509   860A   A2 08       		ldx	#8		; CLEAR Z-WORD INPUT BUFFER
11510   860C   9D BE 6C    	RLL:	sta	IN,X		; [A] = 0
11511   860F   CA          		dex
11512   8610   10 FA       		bpl	RLL
11513                      	
11514   8612   A5 93       		lda	SOURCE		; STORE THE START POS OF THE WORD
11515   8614   8D 33 85    		sta	WORDSTART	; and save it for later
11516   8617   20 88 92    		jsr	FETCHB		; GET A CHAR FROM SOURCE BUFFER
11517   861A   20 65 87    		jsr	SIB		; IS IT A SELF-INSERTING BREAK?
11518   861D   B0 2C       		bcs	DOSIB		; YES IF CARRY WAS SET
11519   861F   20 59 87    		jsr	NORM		; IS IT A "NORMAL" BREAK?
11520   8622   90 0A       		bcc	READL2		; NO, CONTINUE
11521   8624   E6 93       		inc	SOURCE		; ELSE FLUSH THE STRANDED BREAK
11522   8626   20 F0 8F    		jsr	NEXTFPC		; and point to next char
11523   8629   C6 92       		dec	LINLEN		; UPDATE # CHARS LEFT IN LINE
11524   862B   4C D9 85    		jmp	READL		; AND LOOP
11525   862E               	READL2:
11526   862E   A5 92       		lda	LINLEN		; OUT OF CHARS YET?
11527   8630   F0 25       		beq	READL3		; LOOKS THAT WAY
11528   8632   20 88 92    		jsr	FETCHB		; Grab the char
11529   8635   20 54 87    		jsr	BREAK		; IS IT A BREAK?
  Tue Jun 13 1989 11:42                                                                                                  Page  173

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11530   8638   B0 1D       		bcs	READL3		; YES IF CARRY WAS SET
11531   863A   A6 94       		ldx	WRDLEN		; ELSE STORE THE CHAR
11532   863C   9D BE 6C    		sta	IN,X		; INTO THE INPUT BUFFER
11533   863F   C6 92       		dec	LINLEN		; ONE LESS CHAR IN LINE
11534   8641   E6 94       		inc	WRDLEN		; ONE MORE IN WORD
11535   8643   E6 93       		inc	SOURCE		; and update next source
11536   8645   20 F0 8F    		jsr	NEXTFPC		; POINT TO NEXT CHAR IN SOURCE
11537   8648   4C D9 85    		jmp	READL		; AND LOOP BACK
11538                      	;
11539                      	; handle self-inserting breaks
11540   864B               	DOSIB:
11541   864B   8D BE 6C    		sta	IN		; put the break into 1st word slot
11542   864E   C6 92       		dec	LINLEN		; one less char in line
11543   8650   E6 94       		inc	WRDLEN		; one more in word buffer
11544   8652   E6 93       		inc	SOURCE		; and update next source
11545   8654   20 F0 8F    		jsr	NEXTFPC		; point to next source char
11546   8657               	READL3:
11547   8657   A5 94       		lda	WRDLEN		; ANY CHARS IN WORD YET?
11548   8659   D0 03       		bne	READL31		; yup, so deal with word
11549   865B   4C D9 85    		jmp	READL		; then go get next word
11550   865E               	READL31:
11551   865E   20 44 94    		jsr	CONZST		; CONVERT ASCII IN [IN] TO Z-STRING
11552   8661   20 95 87    		jsr	FINDW		; AND LOOK IT UP IN VOCABULARY
11553                      	
11554   8664   AD 33 85    		lda	WORDSTART	; get where it starts
11555   8667   20 67 92    		jsr	STASHB		; and save it
11556   866A   20 80 90    		jsr	PREVSPC		; step backwards to point to length
11557   866D   A5 94       		lda	WRDLEN		; and get length
11558   866F   20 67 92    		jsr	STASHB		; and save it away
11559   8672   20 80 90    		jsr	PREVSPC		; and backwards to LSB of offset
11560   8675   A2 06       		ldx	#6		; offset to point to end of next entry
11561                      	
11562   8677   EE 32 85    		inc	WORDCNT		; increment # words read
11563                      	
11564   867A   AD 85 6C    		lda	PSVFLG		; IF SHOULD PRESERVE WHAT'S IN
11565   867D   F0 06       		beq	READL4
11566   867F   A5 77       		lda	VALUE+HI	; RDTBL2 AND NOT FOUND (VALUE = 0)
11567   8681   05 76       		ora	VALUE+LO
11568   8683   F0 0F       		beq	READL5		; JUST SKIP OVER
11569   8685               	READL4:
11570   8685   A5 76       		lda	VALUE+LO	; GET LSB OF VOCAB ENTRY ADDRESS
11571   8687   20 67 92    		jsr	STASHB		; and stash it away
11572   868A   20 80 90    		jsr	PREVSPC		; point to MSB part
11573   868D   A5 77       		lda	VALUE+HI	; ALSO STORE MSB IN 2ND SLOT
11574   868F   20 67 92    		jsr	STASHB		; and send it out
11575   8692   A2 07       		ldx	#7		; offset to point to end of next entry
11576   8694               	READL5:
11577   8694   A9 00       		lda	#0
11578   8696   85 94       		sta	WRDLEN		; CLEAR # CHARS IN WORD
11579   8698   8A          		txa			; get offset
11580   8699   20 33 90    		jsr	ADDSPC		; and point to end of next entry
11581   869C   4C D9 85    		jmp	READL		; AND LOOP BACK
11582                      	
11583                      	; ---
11584                      	; LEX
11585                      	; ---
11586                      	; DO PARSE OF TBL1 INTO TBL2 (2ND HALF OF READ)
11587                      	
11588   869F               	ZLEX:
11589   869F   A5 64       		LDA	ARG1+HI		; MAKE THE TABLE ADDRESSES
11590   86A1   8D A9 6C    		STA	RDTBL1+HI	; AND PLACE IT HERE TO USE
11591   86A4   A5 63       		LDA	ARG1+LO
11592   86A6   8D A8 6C    		STA	RDTBL1+LO	; LSBS NEED NOT CHANGE
11593                      	
11594   86A9   A5 66       		LDA	ARG2+HI
11595   86AB   8D AB 6C    		STA	RDTBL2+HI
11596   86AE   A5 65       		LDA	ARG2+LO
11597   86B0   8D AA 6C    		STA	RDTBL2+LO
11598                      	
11599   86B3   C6 62       		DEC	NARGS
11600   86B5   C6 62       		DEC	NARGS
11601   86B7   F0 13       		BEQ	NORMLEX		; USE NORMAL VOCAB TBL
11602                      	
11603   86B9   A9 01       		LDA	#1		; USE ARG3 VOCAB TBL
11604   86BB   8D 86 6C    		STA	VOCFLG
  Tue Jun 13 1989 11:42                                                                                                  Page  174

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11605   86BE   A9 00       		LDA	#0
11606   86C0   C6 62       		DEC	NARGS
11607   86C2   F0 02       		BEQ	NOSAVE		; ZERO UNFOUND WORDS
11608   86C4   A9 01       		LDA	#1		; PRESERVE UNFOUND WORD SLOT FLAG
11609   86C6   8D 85 6C    	NOSAVE:	STA	PSVFLG
11610   86C9   4C D4 86    		JMP	DOLEX
11611                      	
11612   86CC   A9 00       	NORMLEX: LDA	#0
11613   86CE   8D 86 6C    		STA	VOCFLG		; USE NORMAL VOCAB TBL
11614   86D1   8D 85 6C    		STA	PSVFLG		; AND WILL BE NO PRESERVING
11615                      	
11616   86D4   4C 7D 85    	DOLEX:	JMP	DOREST		; GO DO LEXICAL CONVERSION AND JUST RETURN
11617                      	
11618                      	
11619                      	; -----
11620                      	; ZWSTR
11621                      	; -----
11622                      	; CONVERT A WORD TO A ZWORD, PLACE IN ARG4 TBL
11623   86D7               	ZWSTR:
11624   86D7   A5 64       		lda	ARG1+HI		; Make ARG1 be the FPC
11625   86D9   20 A9 8F    		jsr	SETPC		; so get absolute mem bank/page
11626   86DC   84 8E       		sty	FPCBNK		; save bank and
11627   86DE   85 8D       		sta	FPCH		; page
11628   86E0   A5 63       		lda	ARG1+LO
11629   86E2   85 8C       		sta	FPCL		; LSBS NEED NOT CHANGE
11630                      	;
11631                      	; (IGNORE WORD LENGTH CAUSE CHECK FOR BREAK CHAR (9 CHAR MAX))
11632                      	;
11633   86E4   A5 67       		lda	ARG3+LO		; ADD OFFSET INTO INBUF
11634   86E6   20 10 90    		jsr	ADDFPC		; add it to the FPC
11635                      	
11636   86E9   A5 6A       		lda	ARG4+HI		; now fix the SPC too
11637   86EB   20 A9 8F    		jsr	SETPC		; get me bank and page
11638   86EE   84 91       		sty	SPCBNK		; save bank
11639   86F0   85 90       		sta	SPCH		; save page
11640   86F2   A5 69       		lda	ARG4+LO
11641   86F4   85 8F       		sta	SPCL		; LSB doesn't change
11642                      	;
11643                      	; START A NEW WORD
11644                      	;
11645   86F6   A9 09       		lda	#9
11646   86F8   85 92       		sta	LINLEN		; 1 WORD'S WORTH
11647   86FA   A9 00       		lda	#0
11648   86FC   85 94       		sta	WRDLEN
11649                      	
11650   86FE   A2 08       		ldx	#8		; CLEAR Z-WORD INPUT BUFFER
11651   8700   9D BE 6C    	WSTR1:	sta	IN,X		; [A] = 0
11652   8703   CA          		dex
11653   8704   10 FA       		bpl	WSTR1
11654                      	;
11655                      	; THIS LOOP READS FROM INBUF TIL BREAK OR 9 CHARS READ
11656                      	;
11657   8706               	WSTR2:
11658   8706   20 88 92    		jsr	FETCHB		; grab the next char
11659   8709   20 54 87    		jsr	BREAK		; IS IT A BREAK?
11660   870C   B0 0E       		bcs	WSTR3		; YES IF CARRY WAS SET
11661   870E   A6 94       		ldx	WRDLEN		; ELSE STORE THE CHAR
11662   8710   9D BE 6C    		sta	IN,X		; INTO THE INPUT BUFFER
11663   8713   E6 94       		inc	WRDLEN		; ONE MORE CHAR IN WORD
11664   8715   C6 92       		dec	LINLEN		; ONE LESS IN LINE
11665   8717   20 F0 8F    		jsr	NEXTFPC		; point to next char
11666   871A   D0 EA       		bne	WSTR2		; AND LOOP BACK TIL DONE
11667   871C               	WSTR3:
11668   871C   A5 94       		lda	WRDLEN		; ANY CHARS IN WORD YET?
11669   871E   F0 13       		beq	WOOPS		; APPARENTLY NOT, OOPS
11670   8720   20 44 94    		jsr	CONZST		; CONVERT ASCII IN [IN] TO Z-STRING
11671                      	
11672   8723   A2 00       		ldx	#0		; MOVE FROM [OUT] TO RDTBL2
11673   8725   BD C7 6C    	WSTR4:	lda	OUT,X
11674   8728   20 67 92    		jsr	STASHB		; and stash it into ZWORD table
11675   872B   20 D0 8F    		jsr	NEXTSPC		; and point to next byte
11676   872E   E8          		inx
11677   872F   E0 06       		cpx	#6		; max 6 word table
11678   8731   D0 F2       		bne	WSTR4		; not done yet
11679   8733               	WOOPS:
  Tue Jun 13 1989 11:42                                                                                                  Page  175

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11680   8733   60          		rts
11681                      	
11682                      	; ----------
11683                      	; FLUSH WORD
11684                      	; ----------
11685                      	
11686   8734               	FLUSHW:
11687   8734   A5 92       		lda	LINLEN		; ANY CHARS LEFT IN LINE?
11688   8736   F0 14       		beq	FLEX		; NO, SCRAM
11689   8738   20 88 92    		jsr	FETCHB		; GRAB A CHAR
11690   873B   20 54 87    		jsr	BREAK		; IS IT A BREAK?
11691   873E   B0 0C       		bcs	FLEX		; EXIT IF SO
11692   8740   C6 92       		dec	LINLEN		; ELSE UPDATE CHAR COUNT
11693   8742   E6 94       		inc	WRDLEN		; AND WORD-CHAR COUNT
11694   8744   E6 93       		inc	SOURCE		; AND CHAR POINTER
11695   8746   20 F0 8F    		jsr	NEXTFPC		; and FPC pointer too
11696   8749   4C 34 87    		jmp	FLUSHW		; AND LOOP BACK (ALWAYS)
11697   874C               	FLEX:
11698   874C   60          		rts
11699                      	
11700                      	
11701                      	; ---------------------------------
11702                      	; IS CHAR IN [A] ANY TYPE OF BREAK?
11703                      	; ---------------------------------
11704                      	; ------------------
11705                      	; NORMAL BREAK CHARS
11706                      	; ------------------
11707                      	
11708   874D   21 3F 2C 2E 	BRKTBL:	DB	'!?,.'		; IN ORDER OF
11709   8751   0D          		DB	$0D		; ASCII	ENDING FREQUENCY
11710   8752   20          		DB	SPACE		; SPACE CHAR IS TESTED FIRST FOR SPEED
11711   8753   00          		DB	0		; ZERO ADDED FOR ZWSTR (X)
11712          0007        	NBRKS	EQU	$-BRKTBL	; # NORMAL BREAKS
11713                      	
11714   8754   20 65 87    	BREAK:	JSR	SIB		; CHECK FOR A SIB FIRST
11715   8757   B0 3A       		BCS	FBRK		; EXIT NOW IF MATCHED
11716                      	
11717                      		; ELSE FALL THROUGH ...
11718                      	
11719                      	
11720                      	; --------------------------------
11721                      	; IS CHAR IN [A] A "NORMAL" BREAK?
11722                      	; --------------------------------
11723                      	
11724   8759   A2 06       	NORM:	LDX	#NBRKS-1	; NUMBER OF "NORMAL" BREAKS
11725   875B   DD 4D 87    	NBL:	CMP	BRKTBL,X	; MATCHED?
11726   875E   F0 33       		BEQ	FBRK		; YES, EXIT
11727   8760   CA          		DEX
11728   8761   10 F8       		BPL	NBL		; NO, KEEP LOOKING
11729   8763   18          		CLC			; NO MATCH, CLEAR CARRY
11730   8764   60          		RTS			; AND RETURN
11731                      	
11732                      	
11733                      	; ---------------------
11734                      	; IS CHAR IN [A] A SIB?
11735                      	; ---------------------
11736                      	
11737   8765   85 AC       	SIB:	STA	IOCHAR		; SAVE TEST CHAR
11738   8767   A5 54       		lda	VOCAB+ABANK	; get bank
11739   8769   85 8B       		sta	MPCBNK		; and save it
11740   876B   A5 53       		lda	VOCAB+HI	; and hi part
11741   876D   85 8A       		sta	MPCPNT+HI	; and save it
11742   876F   AD 08 96    		lda	ZBEGIN+ZVOCAB+0 ; GET 1ST BYTE IN VOCAB TABLE
11743   8772   AC 09 96    		LDY	ZBEGIN+ZVOCAB+1
11744   8775   85 87       		STA	MPCM
11745   8777   84 86       		STY	MPCL
11746   8779   A9 00       		LDA	#0
11747   877B   85 88       		STA	MPCH		; now everything is set up
11748   877D   20 3B 92    		JSR	GETBYT		; HAS # SIBS
11749   8780   85 7A       		STA	J		; USE AS AN INDEX
11750   8782   20 3B 92    	SBL:	JSR	GETBYT		; GET NEXT SIB
11751   8785   C5 AC       		CMP	IOCHAR		; MATCHED?
11752   8787   F0 08       		BEQ	FBRK0		; YES, REPORT IT
11753   8789   C6 7A       		DEC	J
11754   878B   D0 F5       		BNE	SBL		; ELSE KEEP LOOPING
  Tue Jun 13 1989 11:42                                                                                                  Page  176

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11755   878D   A5 AC       		LDA	IOCHAR
11756   878F   18          		CLC			; NO MATCH, SO
11757   8790   60          		RTS			; EXIT WITH CARRY CLEAR
11758   8791   A5 AC       	FBRK0:	LDA	IOCHAR
11759   8793   38          	FBRK:	SEC			; EXIT WITH CARRY SET
11760   8794   60          		RTS			; IF MATCHED WITH A BREAK CHAR
11761                      	
11762                      	
11763                      	; -----------------
11764                      	; VOCABULARY SEARCH
11765                      	; -----------------
11766                      	; ENTRY: 6-BYTE TARGET Z-WORD IN [OUT]
11767                      	; EXIT: VIRTUAL ENTRY ADDRESS IN [VALUE] IF FOUND ;
11768                      	; OTHERWISE [VALUE] = 0
11769                      	
11770          0078        	VWLEN	EQU	I		; **********
11771          007B        	VWCUR	EQU	J+HI
11772                      	
11773   8795               	FINDW:
11774   8795   AD 86 6C    		lda	VOCFLG		; USE WHAT VOCAB TBL?
11775   8798   F0 07       		beq	FWL2		; NORMAL
11776   879A   A5 68       		lda	ARG3+HI		; IF ALTERNATE VOCTBL
11777   879C   A4 67       		ldy	ARG3+LO		; IT'S ADDR IS IN ARG3
11778   879E   4C C8 87    		jmp	FWL3
11779   87A1               	FWL2:
11780   87A1   AD BD 6C    		lda	DIDVTBL		; have we done default vocab table?
11781   87A4   F0 17       		beq	FWLNEW		; nope, so do it the first time
11782   87A6   A2 02       		ldx	#2		; restore pointers
11783   87A8               	FWRSTL:
11784   87A8   BD B4 6C    		lda	VOCMPC,X	; get it
11785   87AB   95 86       		sta	MPC,X		; save it
11786   87AD   BD B7 6C    		lda	VCESVE,X	; save VOCEND too
11787   87B0   95 B3       		sta	VOCEND,X	; okay, we have
11788   87B2   BD BA 6C    		lda	VWLSVE,X	; and starting length
11789   87B5   95 78       		sta	VWLEN,X		; we have
11790   87B7   CA          		dex			; count
11791   87B8   10 EE       		bpl	FWRSTL		; okay, next one
11792   87BA   4C 9E 88    		jmp	FWLOOP		; and go do it
11793   87BD               	FWLNEW:
11794   87BD   A9 FF       		lda	#$FF		; show we are doing default table
11795   87BF   8D BD 6C    		sta	DIDVTBL		; we shall
11796                      	
11797   87C2   AD 08 96    		lda	ZBEGIN+ZVOCAB	; GET VIRTUAL ADDR OF VOCAB TBL
11798   87C5   AC 09 96    		ldy	ZBEGIN+ZVOCAB+1
11799   87C8               	FWL3:
11800   87C8   85 87       		STA	MPCM
11801   87CA   84 86       		STY	MPCL
11802   87CC   A9 00       		LDA	#0
11803   87CE   85 88       		STA	MPCH
11804   87D0   20 B2 90    		JSR	VLDMPC		; SET TO NEW PAGE
11805   87D3   20 3B 92    		JSR	GETBYT		; GET # SIBS
11806   87D6   18          		CLC
11807   87D7   65 86       		ADC	MPCL		; GET ACTUAL BASE ADDR OF VOCAB ENTRIES
11808   87D9   85 86       		STA	MPCL
11809   87DB   90 02       		BCC	FWL0
11810   87DD   E6 87       		INC	MPCM
11811   87DF   20 B2 90    	FWL0:	JSR	VLDMPC		; SET TO NEW PAGE
11812   87E2   20 3B 92    		JSR	GETBYT		; GET # BYTES PER ENTRY (AND MOVE TO NEXT BYTE)
11813   87E5   85 95       		STA	ESIZE		; SAVE IT HERE
11814   87E7   85 78       		STA	VWLEN+0		; AND HERE
11815   87E9   A9 00       		LDA	#0		; CLEAR REST OF COUNTER
11816   87EB   85 79       		STA	VWLEN+1
11817   87ED   85 7A       		STA	VWLEN+2
11818                      	
11819   87EF   20 3B 92    		JSR	GETBYT		; GET # OF ENTRIES IN TBL (MSB)
11820   87F2   8D AD 6C    		STA	NENTS+HI	; AND STUFF IT IN [NENTS]
11821   87F5   20 3B 92    		JSR	GETBYT		; DON'T FORGET THE LSB!
11822   87F8   8D AC 6C    		STA	NENTS+LO
11823   87FB   AD AD 6C    		LDA	NENTS+HI
11824   87FE   10 03       		BPL	SORTED
11825   8800   4C 57 89    		JMP	UNSORTED	; VOCAB LIST IS UNSORTED, HANDLE DIFFERENTLY
11826   8803               	SORTED:
11827   8803   A9 00       		LDA	#0		; FIND SIZE OF VAOCAB TBL
11828   8805   85 B3       		STA	VOCEND		; TO LOCATE THE END OF IT
11829   8807   85 B4       		STA	VOCEND+1
  Tue Jun 13 1989 11:42                                                                                                  Page  177

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11830   8809   85 B5       		STA	VOCEND+2
11831   880B   A6 95       		LDX	ESIZE
11832   880D               	FWL1:
11833   880D   18          		CLC
11834   880E   A5 B3       		LDA	VOCEND		; (# OF ENTRIES) * (ENTRY SIZE)
11835   8810   6D AC 6C    		ADC	NENTS+LO
11836   8813   85 B3       		STA	VOCEND
11837   8815   A5 B4       		LDA	VOCEND+1
11838   8817   6D AD 6C    		ADC	NENTS+HI
11839   881A   85 B4       		STA	VOCEND+1
11840   881C   90 02       		bcc	FWL11
11841   881E   E6 B5       		inc	VOCEND+2
11842   8820               	FWL11:
11843   8820   CA          		DEX
11844   8821   D0 EA       		BNE	FWL1
11845                      	
11846   8823   18          		CLC
11847   8824   A5 B3       		LDA	VOCEND		; AND ADD LENGTH TO START OF TBL
11848   8826   65 86       		ADC	MPCL		; TO GET END OF TBL
11849   8828   85 B3       		STA	VOCEND
11850   882A   A5 B4       		LDA	VOCEND+1
11851   882C   65 87       		ADC	MPCM
11852   882E   85 B4       		STA	VOCEND+1
11853   8830   A5 B5       		LDA	VOCEND+2
11854   8832   65 88       		ADC	MPCH
11855   8834   85 B5       		STA	VOCEND+2	; TO SAVE FOR TESTING IF PAST END
11856                      	
11857   8836   A5 B3       		LDA	VOCEND		; SUBTRACT [ESIZE] SO THAT
11858   8838   38          		SEC			; [VOCEND] POINTS TO REAL LAST ENTRY
11859   8839   E5 95       		SBC	ESIZE
11860   883B   85 B3       		STA	VOCEND
11861   883D   A5 B4       		LDA	VOCEND+1
11862   883F   E9 00       		SBC	#0
11863   8841   85 B4       		STA	VOCEND+1
11864                      	;
11865                      	; BEGIN THE SEARCH! [MPC] NOW POINTS TO 1ST ENTRY
11866                      	;
11867   8843   4E AD 6C    		LSR	NENTS+HI	; 2 ALIGN # OF ENTRIES
11868   8846   6E AC 6C    		ROR	NENTS+LO	; 2 point to middle of table
11869   8849   06 78       	FWCALC:	ASL	VWLEN+0		; CALCULATE INITIAL OFFSET FOR SEARCH
11870   884B   26 79       		ROL	VWLEN+1
11871   884D   26 7A       		ROL	VWLEN+2
11872   884F   4E AD 6C    		LSR	NENTS+HI
11873   8852   6E AC 6C    		ROR	NENTS+LO
11874   8855   D0 F2       		BNE	FWCALC
11875                      	
11876   8857   18          		CLC			; ADD 1ST OFFSET INTO START OF VOCABULARL
11877   8858   A5 86       		LDA	MPCL		; WHICH IS CURRENTLY IN MPC
11878   885A   65 78       		ADC	VWLEN+0
11879   885C   85 86       		STA	MPCL
11880   885E   A5 87       		LDA	MPCM
11881   8860   65 79       		ADC	VWLEN+1
11882   8862   85 87       		STA	MPCM
11883   8864   A5 88       		LDA	MPCH
11884   8866   65 7A       		ADC	VWLEN+2
11885   8868   85 88       		STA	MPCH
11886                      	
11887   886A   38          		SEC			; AVOID FENCE-POST BUG FOR
11888   886B   A5 86       		LDA	MPCL		; EXACT-POWER-OF-2 TBL (DUNCAN)
11889   886D   E5 95       		SBC	ESIZE
11890   886F   85 86       		STA	MPCL
11891   8871   B0 0F       		BCS	FWSAVE
11892   8873   A5 87       		LDA	MPCM
11893   8875   38          		SEC
11894   8876   E9 01       		SBC	#1
11895   8878   85 87       		STA	MPCM
11896   887A   B0 06       		BCS	FWSAVE
11897   887C   A5 88       		LDA	MPCH
11898   887E   E9 00       		SBC	#0
11899   8880   85 88       		STA	MPCH
11900   8882               	FWSAVE:
11901   8882   AD BD 6C    		lda	DIDVTBL		; are we installing default table?
11902   8885   10 17       		bpl	FWLOOP		; already have?	
11903   8887   A2 02       		ldx	#2		; save MPC
11904   8889   8E BD 6C    		stx	DIDVTBL		; show we have saved it
  Tue Jun 13 1989 11:42                                                                                                  Page  178

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11905   888C               	FWSVL:
11906   888C   B5 86       		lda	MPC,X		; get it
11907   888E   9D B4 6C    		sta	VOCMPC,X	; save it
11908   8891   B5 B3       		lda	VOCEND,X	; save VOCEND too
11909   8893   9D B7 6C    		sta	VCESVE,X	; okay, we have
11910   8896   B5 78       		lda	VWLEN,X		; and starting length
11911   8898   9D BA 6C    		sta	VWLSVE,X	; we have
11912   889B   CA          		dex			; count
11913   889C   10 EE       		bpl	FWSVL		; okay, next one
11914   889E               	FWLOOP:
11915   889E   46 7A       		lsr	VWLEN+2		; SET FOR NEXT OFFSET,
11916   88A0   66 79       		ror	VWLEN+1		; WHICH IS HALF THIS ONE
11917   88A2   66 78       		ror	VWLEN+0
11918                      	
11919   88A4   A5 86       		lda	MPCL		; HOLD START ADDR, MPC WILL BE A MESS
11920   88A6   85 7B       		sta	VWCUR+0
11921   88A8   A5 87       		lda	MPCM
11922   88AA   85 7C       		sta	VWCUR+1
11923   88AC   A5 88       		lda	MPCH
11924   88AE   85 7D       		sta	VWCUR+2
11925                      	
11926   88B0   20 B2 90    		jsr	VLDMPC		; SET TO NEW PAGE
11927   88B3   20 3B 92    		jsr	GETBYT		; GET 1ST BYTE OF ENTRY
11928   88B6   CD C7 6C    		cmp	OUT		; MATCH 1ST BYTE OF TARGET?
11929   88B9   90 34       		bcc	WNEXT		; LESS
11930   88BB   D0 66       		bne	FWPREV		; GREATER
11931   88BD   20 3B 92    		jsr	GETBYT	
11932   88C0   CD C8 6C    		cmp	OUT+1		; 2ND BYTE MATCHED?
11933   88C3   90 2A       		bcc	WNEXT
11934   88C5   D0 5C       		bne	FWPREV		; NOPE
11935   88C7   20 3B 92    		jsr	GETBYT
11936   88CA   CD C9 6C    		cmp	OUT+2		; 3RD BYTE?
11937   88CD   90 20       		bcc	WNEXT
11938   88CF   D0 52       		bne	FWPREV		; SORRY ...
11939   88D1   20 3B 92    		jsr	GETBYT
11940   88D4   CD CA 6C    		cmp	OUT+3		; 4TH BYTE
11941   88D7   90 16       		bcc	WNEXT
11942   88D9   D0 48       		BNE	FWPREV
11943   88DB   20 3B 92    		JSR	GETBYT
11944   88DE   CD CB 6C    		CMP	OUT+4		; 5TH BYTE?
11945   88E1   90 0C       		BCC	WNEXT
11946   88E3   D0 3E       		BNE	FWPREV		; SORRY ...
11947   88E5   20 3B 92    		JSR	GETBYT
11948   88E8   CD CC 6C    		CMP	OUT+5		; LAST BYTE?
11949   88EB   F0 5A       		BEQ	FWSUCC		; FOUND IT!
11950   88ED   B0 34       		BCS	FWPREV		; ELSE BACK UP ...
11951   88EF               	WNEXT:
11952   88EF   A5 7B       		LDA	VWCUR+0		; TO MOVE UP, JUST ADD
11953   88F1   18          		CLC			; OFFSET FROM START OF THIS
11954   88F2   65 78       		ADC	VWLEN+0		; ENTRY
11955   88F4   85 86       		STA	MPCL
11956   88F6   A5 7C       		LDA	VWCUR+1
11957   88F8   65 79       		ADC	VWLEN+1
11958   88FA   B0 18       		BCS	WNXT2		; SAVES CODE (?)
11959                      	
11960   88FC   85 87       		STA	MPCM
11961   88FE   A9 00       		LDA	#0
11962   8900   85 88       		STA	MPCH
11963   8902               	WNXT0:
11964   8902   A5 87       		LDA	MPCM		; GONE PAST END?
11965   8904   C5 B4       		CMP	VOCEND+1	
11966   8906   F0 04       		BEQ	WNXT1		; MAYBE
11967   8908   B0 0A       		BCS	WNXT2		; YES
11968   890A   90 2A       		BCC	FWMORE		; NO
11969   890C               	WNXT1:
11970   890C   A5 86       		LDA	MPCL
11971   890E   C5 B3       		CMP	VOCEND
11972   8910   90 24       		BCC	FWMORE		; NO
11973   8912   F0 22       		BEQ	FWMORE		; NO, EQUAL
11974   8914               	WNXT2:
11975   8914   A5 B3       		LDA	VOCEND		; YES, SO POINT TO END OF TBL
11976   8916   85 86       		STA	MPCL
11977   8918   A5 B4       		LDA	VOCEND+1
11978   891A   85 87       		STA	MPCM
11979   891C   A5 B5       		LDA	VOCEND+2
  Tue Jun 13 1989 11:42                                                                                                  Page  179

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

11980   891E   85 88       		STA	MPCH
11981   8920   4C 36 89    		JMP	FWMORE
11982   8923               	FWPREV:
11983   8923   A5 7B       		LDA	VWCUR+0		; TO MOVE DOWN, JUST SUBTRACT
11984   8925   38          		SEC			; OFFSET FROM START OF THIS
11985   8926   E5 78       		SBC	VWLEN+0		; ENTRY
11986   8928   85 86       		STA	MPCL
11987   892A   A5 7C       		LDA	VWCUR+1
11988   892C   E5 79       		SBC	VWLEN+1
11989   892E   85 87       		STA	MPCM
11990   8930   A5 7D       		LDA	VWCUR+2
11991   8932   E5 7A       		SBC	VWLEN+2
11992   8934   85 88       		STA	MPCH
11993   8936               	FWMORE:
11994   8936   A5 7A       		LDA	VWLEN+2		; IF OFFSET >GE< 1 WORD, CONTINUE
11995   8938   D0 0A       		BNE	FWM1
11996   893A   A5 79       		LDA	VWLEN+1
11997   893C   D0 06       		BNE	FWM1
11998   893E   A5 78       		LDA	VWLEN+0
11999   8940   C5 95       		CMP	ESIZE
12000   8942   90 0C       		BCC	FWFAIL
12001   8944               	FWM1:
12002   8944   4C 9E 88    		JMP	FWLOOP		; AND TRY AGAIN
12003                      	
12004   8947   A5 7B       	FWSUCC:	LDA	VWCUR+0		; ENTRY MATCHED!  RETRIEVE START OF WORD
12005   8949   85 76       		STA	VALUE+LO
12006   894B   A5 7C       		LDA	VWCUR+1
12007   894D   85 77       		STA	VALUE+HI	; MUST BE 64K LIMIT AS ONLY
12008   894F   60          		RTS			; WORD VALUE RETURNABLE
12009   8950               	FWFAIL:
12010   8950   A9 00       		LDA	#0		; NOT FOUND
12011   8952   85 76       		STA	VALUE+LO
12012   8954   85 77       		STA	VALUE+HI
12013   8956   60          		RTS			; THEN RETURN WITH [VALUE] = 0
12014                      	;
12015                      	; DO UNSORTED SEARCH ON VOCAB TBL IN MPC
12016                      	;
12017   8957               	UNSORTED:
12018   8957   A9 FF       		LDA	#$FF		; 2'S COMPLEMENT LENGTH
12019   8959   4D AD 6C    		EOR	NENTS+HI	; TO GET REAL LENGTH
12020   895C   8D AD 6C    		STA	NENTS+HI	; WAS NEGATIVE TO SIGNIFY
12021   895F   A9 FF       		LDA	#$FF		; UNSORTED VOCAB TBL
12022   8961   4D AC 6C    		EOR	NENTS+LO
12023   8964   8D AC 6C    		STA	NENTS+LO
12024   8967   EE AC 6C    		INC	NENTS+LO	; 2'S CMPL
12025   896A   D0 03       		BNE	UNSRT0
12026   896C   EE AD 6C    		INC	NENTS+HI
12027   896F               	UNSRT0:
12028   896F   A5 86       		LDA	MPCL		; HOLD START ADDR, MPC WILL BE A MESS
12029   8971   85 7B       		STA	VWCUR+0
12030   8973   A5 87       		LDA	MPCM
12031   8975   85 7C       		STA	VWCUR+1
12032   8977   A5 88       		LDA	MPCH
12033   8979   85 7D       		STA	VWCUR+2
12034                      	
12035   897B   20 3B 92    		JSR	GETBYT		; GET 1ST BYTE OF ENTRY
12036   897E   CD C7 6C    		CMP	OUT		; MATCH 1ST BYTE OF TARGET?
12037   8981   D0 28       		BNE	FNEXT		; LESS
12038   8983   20 3B 92    		JSR	GETBYT
12039   8986   CD C8 6C    		CMP	OUT+1		; 2ND BYTE MATCHED?
12040   8989   D0 20       		BNE	FNEXT
12041   898B   20 3B 92    		JSR	GETBYT
12042   898E   CD C9 6C    		CMP	OUT+2		; 3RD BYTE?
12043   8991   D0 18       		BNE	FNEXT
12044   8993   20 3B 92    		JSR	GETBYT
12045   8996   CD CA 6C    		CMP	OUT+3		; 4TH BYTE
12046   8999   D0 10       		BNE	FNEXT
12047   899B   20 3B 92    		JSR	GETBYT
12048   899E   CD CB 6C    		CMP	OUT+4		; 5TH BYTE?
12049   89A1   D0 08       		BNE	FNEXT
12050   89A3   20 3B 92    		JSR	GETBYT
12051   89A6   CD CC 6C    		CMP	OUT+5		; LAST BYTE?
12052   89A9   F0 9C       		BEQ	FWSUCC		; FOUND IT!
12053                      	
12054   89AB   A5 7B       	FNEXT:	LDA	VWCUR+LO	; TO MOVE UP, JUST ADD
  Tue Jun 13 1989 11:42                                                                                                  Page  180

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- READ HANDLER ---"

12055   89AD   18          		CLC			; OFFSET FROM START OF THIS
12056   89AE   65 95       		ADC	ESIZE		; ENTRY
12057   89B0   85 86       		STA	MPCL
12058   89B2   90 0D       		BCC	FNEXT0
12059                      	
12060   89B4   A5 7C       		LDA	VWCUR+HI	; PICK UP CARRY
12061   89B6   69 00       		ADC	#0
12062   89B8   85 87       		STA	MPCM
12063   89BA   A9 00       		LDA	#0
12064   89BC   85 88       		STA	MPCH
12065   89BE   20 B2 90    		JSR	VLDMPC		; CROSSED PAGE SO RE-VALIDATE
12066                      	
12067   89C1   CE AC 6C    	FNEXT0:	DEC	NENTS+LO	; CHECKED ALL ENTRIES?
12068   89C4   D0 A9       		BNE	UNSRT0
12069   89C6   AD AD 6C    		LDA	NENTS+HI
12070   89C9   F0 85       		BEQ	FWFAIL		; GO INDICATE NO FIND
12071   89CB   CE AD 6C    		DEC	NENTS+HI	; OR DO NEXT 256 ENTRIES
12072   89CE   4C 6F 89    		JMP	UNSRT0
12073                      	
12074   89D1               		END
12075                      	
12076   89D1               		INCLUDE		ZSAVRES.ASM
12077                      	
12078   89D1               		STTL	"--- ZIP SAVE AND RESTORE ROUTINES ---"
12079                      		PAGE
  Tue Jun 13 1989 11:42                                                                                                  Page  181

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12080                      	; -----------------------------
12081                      	; SET UP SAVE & RESTORE SCREENS
12082                      	; -----------------------------
12083   89D1               	SAVRES:
12084   89D1   20 E9 54    		jsr	ZCRLF	; CLEAR THE LINE BUFFER
12085   89D4   A9 00       		lda	#0	
12086   89D6   85 AA       		sta	SCRIPT	; DISABLE SCRIPTING
12087   89D8   AD 54 C0    		lda	PAGE2SW+MAIN	; just do this for the heck of it
12088   89DB   AD 83 C0    	        lda     BNK2SET		; this stuff too
12089   89DE   AD 83 C0    	        lda     BNK2SET
12090                      	
12091   89E1   60          		rts
12092                      	
12093                      	; -----------------------------
12094                      	; SAVE & RESTORE STRINGS
12095                      	; -----------------------------
12096   89E2   59 45 53    	YES:	DB	"YES"
12097   89E5   0D          		DB	EOL	
12098          0004        	YESL	EQU	$-YES	
12099   89E6   4E 4F       	NO:	DB	"NO"	
12100   89E8   0D          		DB	EOL	
12101          0003        	NOL	EQU	$-NO	
12102                      	
12103   89E9   0D          	NAMEQ:	db	EOL
12104   89EA   49 6E 73 65 72 		db	"Insert save disk and enter "
        89EF   74 20 73 61 76 
        89F4   65 20 64 69 73 
        89F9   6B 20 61 6E 64 
        89FE   20 65 6E 74 65 
        8A03   72 20 
12105   8A05   66 75 6C 6C 20 		db	"full pathname of save file: "
        8A0A   70 61 74 68 6E 
        8A0F   61 6D 65 20 6F 
        8A14   66 20 73 61 76 
        8A19   65 20 66 69 6C 
        8A1E   65 3A 20 
12106   8A21   0D          		db	EOL
12107   8A22   48 69 74 20 27 		db	"Hit '?' key to get a list of online volumes."
        8A27   3F 27 20 6B 65 
        8A2C   79 20 74 6F 20 
        8A31   67 65 74 20 61 
        8A36   20 6C 69 73 74 
        8A3B   20 6F 66 20 6F 
        8A40   6E 6C 69 6E 65 
        8A45   20 76 6F 6C 75 
        8A4A   6D 65 73 2E 
12108   8A4E   0D          		db	EOL
12109   8A4F   43 75 72 72 65 		db	"Current pathname is:",
        8A54   6E 74 20 70 61 
        8A59   74 68 6E 61 6D 
        8A5E   65 20 69 73 3A 
        8A63   00 
12110   8A64   0D          		db	EOL
12111          007C        	NAMEQL	EQU	$-NAMEQ
12112                      	SNDATA:		 	; show start of name and length
12113   8A65   00          	SNAMEL:	db	0	; place to save length of name
12114   8A66               	SAVENAME: ds	64+15	; save plenty of room for max name
12115                      	
12116   8AB5   0D 46 69 6C 65 	DELQ:	db	EOL,"File exists, delete it (Yes/No)? "
        8ABA   20 65 78 69 73 
        8ABF   74 73 2C 20 64 
        8AC4   65 6C 65 74 65 
        8AC9   20 69 74 20 28 
        8ACE   59 65 73 2F 4E 
        8AD3   6F 29 3F 20 
12117          0023        	DELQL	EQU	$-DELQ+1	; include this following EOL
12118   8AD7   0D 50 6C 65 61 	RETQ:	db	EOL,"Please hit [RETURN]",EOL
        8ADC   73 65 20 68 69 
        8AE1   74 20 5B 52 45 
        8AE6   54 55 52 4E 5D 
        8AEB   0D 
12119          0015        	RETQL	EQU	$-RETQ
12120   8AEC   0D 4E 61 6D 65 	PREFIX_ERR: db  EOL,"Name must have prefix, "
        8AF1   20 6D 75 73 74 
        8AF6   20 68 61 76 65 
  Tue Jun 13 1989 11:42                                                                                                  Page  182

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

        8AFB   20 70 72 65 66 
        8B00   69 78 2C 20 
12121   8B04   69 2E 65 2E 3A 	        db      "i.e.: /DISKNAME/FILENAME",EOL
        8B09   20 2F 44 49 53 
        8B0E   4B 4E 41 4D 45 
        8B13   2F 46 49 4C 45 
        8B18   4E 41 4D 45 0D 
12122          0031        	PREFIX_ERRL EQU  $-PREFIX_ERR
12123                      	
12124          002D        	MAX_SAVENAME EQU 45		; max # of chars allowed in save name
12125                      	
12126                      	; -----------------------------
12127                      	; SAVE/RESTORE Parameter Blocks
12128                      	; -----------------------------
12129   8B1D               	CREATE_PB:
12130   8B1D   07          		db	7		; 7 parameters
12131   8B1E   658A        		dw	SNDATA		; pointer to name
12132   8B20   C3          		db	$C3		; full access to file
12133   8B21   06          		db	$06		; BIN file type
12134   8B22   0000        		dw	0		; no aux data
12135   8B24   01          		db	$01		; standard file
12136   8B25   0000        		dw	0		; create date
12137   8B27   0000        		dw	0
12138                      		     ; creation time
12139   8B29               	SETEOF_PB:
12140   8B29   02          		db 	2		; 1 parameter
12141   8B2A   00          	        db      0               ; refnum
12142   8B2B   00 00 00    	        db      0,0,0           ; set to zero spot to clear it out
12143   8B2E               	OPEN_SV:
12144   8B2E   03          		db	3		; 3 parameters
12145   8B2F   658A        		dw	SNDATA		; name
12146   8B31   0011        		dw	GAME1FIO	; file buffer
12147   8B33   00          		db	0		; ref num
12148   8B34               	CLOSE_PB:
12149   8B34   01          		db	1		; only one parm
12150   8B35   00          		db	0		; the refnum
12151   8B36               	WRITE_SV:
12152   8B36   04          		db	4		; parm count
12153   8B37   00          		db	0		; refnum
12154   8B38   0008        		dw	IOBUFF		; data is always here
12155   8B3A   0002        		dw	512             ; 1 page worth
12156   8B3C   0000        		dw	0		; how many actually went
12157                      	
12158                      	; get the save file name.  If user hits the ESC key, then abort the
12159                      	; save by return with the carry set.
12160                      	;
12161   8B3E               	GET_SNAME:
12162   8B3E   20 C1 8C    		jsr	CLOSE_GAME	; close the game files
12163   8B41   20 99 4C    		jsr	SWAP2INFOW	; goto information window
12164   8B44               	GTSN0:
12165   8B44               		DLINE	NAMEQ		; ask about name
12166   8B44   A2 E9       		ldx	#<NAMEQ	; get part of NAMEQ
12167   8B46   A9 89       		lda	#>NAMEQ	; get other part of string
12168          [01]        		IFMA	2		; check to see if length passed in
12169                      		ldy			; then just fetch it
12170          [01]        		ELSE
12171   8B48   A0 7C       		ldy	#NAMEQL	; get length of string
12172          [00]        		ENDIF
12173   8B4A   20 5B 4C    		jsr	DLINE		; print the string
12174   8B4D               		.MACEND
12175   8B4D   AD 65 8A    		lda	SNAMEL		; is there a name yet?
12176   8B50   F0 0A       		beq	GTSN00		; nope
12177   8B52               		DLINE	SAVENAME,SNAMEL	; show current name of file
12178   8B52   A2 66       		ldx	#<SAVENAME	; get part of SAVENAME
12179   8B54   A9 8A       		lda	#>SAVENAME	; get other part of string
12180          [01]        		IFMA	2		; check to see if length passed in
12181   8B56   AC 65 8A    		ldy	SNAMEL		; then just fetch it
12182          [01]        		ELSE
12183                      		ldy	#SAVENAMEL	; get length of string
12184          [00]        		ENDIF
12185   8B59   20 5B 4C    		jsr	DLINE		; print the string
12186   8B5C               		.MACEND
12187   8B5C               	GTSN00:
12188   8B5C   A9 00       		lda	#0		; clear line count	
12189   8B5E   8D 35 8B    		sta	CLOSE_PB+CL_REFNUM ; clear this too
  Tue Jun 13 1989 11:42                                                                                                  Page  183

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12190   8B61   AE 65 8A    		ldx	SNAMEL		; get length
12191   8B64   86 A9       		stx	CHRCNT		; okay
12192   8B66   AC 65 8A    		ldy	SNAMEL		; point to copy
12193   8B69   88          		dey			; one less
12194   8B6A               	GCOPY:
12195   8B6A   BD 65 8A    		lda	SNAMEL,X	; get char
12196   8B6D   99 00 02    		sta	LBUFF,Y		; save it
12197   8B70   CA          		dex			; point to previous one
12198   8B71   88          		dey			; previous pointer
12199   8B72   10 F6       		bpl	GCOPY		; copy until length byte
12200   8B74               	GNAME:
12201   8B74   20 20 51    		jsr	GETKEY		; WAIT FOR A KEY
12202   8B77   C9 0D       		cmp	#EOL		; IF [RETURN],
12203   8B79   F0 63       		beq	GOTNAME		; got the name
12204   8B7B   C9 1B       		cmp	#ESCAPE		; hit escape key?
12205   8B7D   38          		sec			; just in case it does exit
12206   8B7E   D0 03       		bne     GNM2
12207   8B80   4C 22 8C    	        jmp     GNX             ; all done then
12208   8B83               	GNM2:
12209   8B83   C9 08       		cmp	#BACKSPACE	; erasing things?
12210   8B85   D0 15       		bne	GNM1		; nope
12211                      	
12212   8B87   A6 A9       		ldx	CHRCNT		; make sure there are chars there
12213   8B89   D0 06       		bne	GNMBP		; ayyup, do delete
12214   8B8B               	GNMBAD:
12215   8B8B   20 B3 4E    		jsr	BEEP		; no room for delete
12216   8B8E   4C 74 8B    		jmp	GNAME		; okay
12217   8B91               	GNMBP:
12218   8B91   CA          		dex			; point down one
12219   8B92   86 A9       		stx	CHRCNT		; count one down
12220   8B94   BD 00 02    		lda	LBUFF,X		; get char to delete
12221   8B97   AA          		tax			; show in [X]
12222   8B98   A9 08       		lda	#BACKSPACE	; and doing a backspace 
12223   8B9A   D0 39       		bne	GNMSHOW		; okay, delete char on screen
12224   8B9C               	GNM1:
12225   8B9C   C9 2F       		cmp	#'/'		; slash is the only good non-numeric char
12226   8B9E   F0 2A       		beq	GNMGOOD		; fine, use it
12227   8BA0   C9 2E       		cmp	#'.'		; well, maybe a . too
12228   8BA2   F0 26       		beq	GNMGOOD 	; fine, here it is
12229   8BA4   C9 3F       		cmp	#VOLCHAR	; does user want list of volumes?
12230   8BA6   D0 0A       		bne	GNM1x		; nope
12231                      	
12232   8BA8   A9 00       		lda	#0		; clear out current name
12233   8BAA   85 A9       		sta	CHRCNT		; okay, we did
12234   8BAC   20 4D 4B    		jsr	LISTVOLS	; show them
12235   8BAF   4C 44 8B    		jmp	GTSN0		; start over, kind of
12236   8BB2               	GNM1x:
12237   8BB2   C9 30       		cmp	#'0'		; is it a number
12238   8BB4   90 D5       		bcc	GNMBAD		; nope
12239   8BB6   C9 3A       		cmp	#'9'+1		; well?
12240   8BB8   90 10       		bcc	GNMGOOD		; yup
12241   8BBA   C9 7B       		cmp	#'z'+1		; make sure it is alpha numeric
12242   8BBC   B0 CD       		bcs	GNMBAD		; nope
12243   8BBE   C9 41       		cmp	#'A'		; well?
12244   8BC0   90 C9       		bcc	GNMBAD		; nope
12245   8BC2   C9 61       		cmp	#'a'		; little char?
12246   8BC4   B0 04       		bcs	GNMGOOD		; yup
12247   8BC6   C9 5B       		cmp	#'Z'+1		; big char
12248   8BC8   B0 C1       		bcs	GNMBAD		; nope
12249   8BCA               	GNMGOOD:
12250   8BCA   A6 A9       		ldx	CHRCNT		; get name index
12251   8BCC   E0 2D       		cpx	#MAX_SAVENAME	; just get so many characters
12252   8BCE   B0 BB       		bcs	GNMBAD		; beep at user
12253   8BD0   E6 A9       		inc	CHRCNT		; point to next char
12254   8BD2   9D 00 02    		sta	LBUFF,X		; save name char
12255   8BD5               	GNMSHOW:
12256   8BD5   20 A9 5D    		jsr	CHAR		; show character
12257   8BD8   20 1A 72    		jsr	DISP_LINE	; make sure it is there
12258   8BDB   4C 74 8B    		jmp	GNAME		; go get next char
12259                      	;
12260                      	; got the name, so copy it to the SAVENAME buffer
12261                      	;
12262   8BDE               	GOTNAME:
12263   8BDE   A5 A9       	        lda     CHRCNT          ; did we get any?
12264   8BE0   F0 07       	        beq     GTNMERR         ; nope
  Tue Jun 13 1989 11:42                                                                                                  Page  184

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12265   8BE2   AD 00 02    	        lda     LBUFF           ; make sure first name is a directory
12266   8BE5   C9 2F       	        cmp     #'/'            ; is it?
12267   8BE7   F0 10       	        beq     GTNM1           ; yup, probly okay then
12268   8BE9               	GTNMERR:
12269   8BE9   A9 00       		lda	#0		; clear CHRCNT so name doesn't get
12270   8BEB   85 A9       		sta	CHRCNT		; output again
12271   8BED               	        DLINE   PREFIX_ERR      ; complain and die
12272   8BED   A2 EC       		ldx	#<PREFIX_ERR	; get part of PREFIX_ERR
12273   8BEF   A9 8A       		lda	#>PREFIX_ERR	; get other part of string
12274          [01]        		IFMA	2		; check to see if length passed in
12275                      		ldy			; then just fetch it
12276          [01]        		ELSE
12277   8BF1   A0 31       		ldy	#PREFIX_ERRL	; get length of string
12278          [00]        		ENDIF
12279   8BF3   20 5B 4C    		jsr	DLINE		; print the string
12280   8BF6               		.MACEND
12281   8BF6   38          	        sec                     ; show bad name
12282   8BF7   B0 29       	        bcs     GNX             ; all done
12283   8BF9               	GTNM1:
12284   8BF9   A2 00       	        ldx     #0              ; now check to make sure there are 2
12285   8BFB   A0 FE       	        ldy     #$FE            ; use this as counter
12286   8BFD               	GTNMCHK:
12287   8BFD   BD 00 02    	        lda     LBUFF,X         ; get char
12288   8C00   E8          	        inx                     ; next char
12289   8C01   C9 2F       	        cmp     #'/'            ; prefix deliminator?
12290   8C03   D0 03       	        bne     GTNMCHK1        ; nope
12291   8C05   C8          	        iny                     ; count this one
12292   8C06   F0 06       	        beq     GTNM2           ; we have 2 of them
12293   8C08               	GTNMCHK1:
12294   8C08   E4 A9       	        cpx     CHRCNT          ; at end?
12295   8C0A   F0 DD       	        beq     GTNMERR         ; yes, and no 2 '/'s
12296   8C0C   D0 EF       	        bne     GTNMCHK         ; go check next char
12297   8C0E               	GTNM2:
12298   8C0E   E4 A9       	        cpx     CHRCNT          ; make sure there are chars after prefix
12299   8C10   F0 D7       	        beq     GTNMERR         ; nope, still an error
12300   8C12   A6 A9       	        ldx	CHRCNT		; get how many characters
12301   8C14   8E 65 8A    		stx	SNAMEL		; save in length byte
12302   8C17   CA          		dex			; points one too far
12303   8C18               	GNL:
12304   8C18   BD 00 02    		lda	LBUFF,X		; get the char
12305   8C1B   9D 66 8A    		sta	SAVENAME,X	; save the char
12306   8C1E   CA          		dex			; point to previous one
12307   8C1F   10 F7       		bpl	GNL		; and go get it
12308   8C21   18          		clc			; show did just fine
12309   8C22               	GNX:
12310   8C22   08          		php			; save status
12311   8C23   A9 00       		lda	#0		; and clear CHRCNT
12312   8C25   85 A9       		sta	CHRCNT		; okay
12313   8C27   A9 0D       		lda	#EOL		; print EOL
12314   8C29   20 A9 5D    		jsr	CHAR		; okay
12315   8C2C   20 B9 4C    		jsr	SWAPBACK	; change back to old window
12316   8C2F   28          		plp			; get status back
12317   8C30   60          		rts			; all done
12318                      	;
12319                      	; open up a save file, by first trying to create it.  If it already exists
12320                      	; then make sure the player wants to delete the file, then get rid of it.
12321                      	; Finally open the file.  Return with carry set if user aborts the save.
12322                      	; Store the ref number into the write parm block.
12323                      	;
12324   8C31               	OPEN_SAVE:
12325   8C31               		CREATE	CREATE_PB	; first try to create the file
12326   8C31               		PRODOS	$C0, CREATE_PB
12327   8C31   20 00 BF    		jsr	$BF00	; ProDOS handler
12328   8C34   C0          		DB	$C0	; ProDOS function code
12329   8C35   1D8B        		DW	CREATE_PB	; Function Parameter Block address
12330   8C37               		.MACEND
12331   8C37               		.MACEND
12332   8C37   90 16       		bcc	OPSV_OPEN	; created just fine, so open it
12333                      	;
12334                      	; can't create the file, check out why
12335                      	;
12336   8C39   C9 47       		cmp	#$47		; this means file already there	
12337   8C3B   F0 03       		beq	OPSV1		; nope, not that
12338   8C3D   4C 7A 47    		jmp	DISK_ERR	; show badness
12339   8C40               	OPSV1:
  Tue Jun 13 1989 11:42                                                                                                  Page  185

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12340   8C40               		DLINE	DELQ		; ask about deleting this file
12341   8C40   A2 B5       		ldx	#<DELQ	; get part of DELQ
12342   8C42   A9 8A       		lda	#>DELQ	; get other part of string
12343          [01]        		IFMA	2		; check to see if length passed in
12344                      		ldy			; then just fetch it
12345          [01]        		ELSE
12346   8C44   A0 23       		ldy	#DELQL	; get length of string
12347          [00]        		ENDIF
12348   8C46   20 5B 4C    		jsr	DLINE		; print the string
12349   8C49               		.MACEND
12350   8C49   20 D6 8C    		jsr	GETYN		; get me the yes or no
12351   8C4C   90 01       		bcc	OPSV_OPEN	; so then delete it if yes
12352   8C4E   60          		rts			; nope, so just quit
12353   8C4F               	OPSV_OPEN:
12354   8C4F               		OPEN	OPEN_SV		; open the save file
12355   8C4F               		PRODOS	$C8, OPEN_SV
12356   8C4F   20 00 BF    		jsr	$BF00	; ProDOS handler
12357   8C52   C8          		DB	$C8	; ProDOS function code
12358   8C53   2E8B        		DW	OPEN_SV	; Function Parameter Block address
12359   8C55               		.MACEND
12360   8C55               		.MACEND
12361   8C55   90 03       		bcc	OPSV_OP1	; okey, things worked just fine
12362   8C57   4C 7A 47    		jmp	DISK_ERR		; complain about error
12363   8C5A               	OPSV_OP1:
12364   8C5A   AD 33 8B    		lda	OPEN_SV+OP_REFNUM	; get the ref number
12365   8C5D   8D 37 8B    		sta	WRITE_SV+WR_REFNUM	; save the ref number
12366   8C60   8D 35 8B    		sta	CLOSE_PB+CL_REFNUM	; to close parm too
12367   8C63   8D 2A 8B    	        sta     SETEOF_PB+SE_REFNUM     ; for cleansing file
12368   8C66               	        SET_EOF SETEOF_PB       ; clear out file
12369   8C66               		PRODOS	$D0, SETEOF_PB
12370   8C66   20 00 BF    		jsr	$BF00	; ProDOS handler
12371   8C69   D0          		DB	$D0	; ProDOS function code
12372   8C6A   298B        		DW	SETEOF_PB	; Function Parameter Block address
12373   8C6C               		.MACEND
12374   8C6C               		.MACEND
12375   8C6C   90 03       	        bcc     OPSVEX          ; no problems
12376   8C6E   20 7A 47    	        jsr     DISK_ERR        ; complain
12377   8C71               	OPSVEX:
12378   8C71   60          		rts			; file has been opened, return
12379                      	;
12380                      	; OPEN_RES - open the save file
12381                      	;
12382   8C72               	OPEN_RES:
12383   8C72               		OPEN	OPEN_SV		; open it up
12384   8C72               		PRODOS	$C8, OPEN_SV
12385   8C72   20 00 BF    		jsr	$BF00	; ProDOS handler
12386   8C75   C8          		DB	$C8	; ProDOS function code
12387   8C76   2E8B        		DW	OPEN_SV	; Function Parameter Block address
12388   8C78               		.MACEND
12389   8C78               		.MACEND
12390   8C78   90 01       		bcc	OPR1		; okay, it worked
12391   8C7A   60          		rts			; okay, it didn't
12392   8C7B               	OPR1:
12393   8C7B   AD 33 8B    		lda	OPEN_SV+OP_REFNUM ; get reference number
12394   8C7E   8D BF 45    		sta	READ_PB+RD_REFNUM ; save for read
12395   8C81   8D 35 8B    		sta	CLOSE_PB+CL_REFNUM ; and for close
12396   8C84   60          		rts
12397                      	;
12398                      	; CLOSE_SAVE - close up the save file if it is open, and
12399                      	;       restore open game files
12400                      	;
12401   8C85               	CLOSE_SAVE:
12402   8C85   AD 35 8B    		lda	CLOSE_PB+CL_REFNUM ; check if it opened
12403   8C88   F0 06       		beq	CLSVX		; okay, nothing
12404   8C8A               		CLOSE	CLOSE_PB	; close the save file
12405   8C8A               		PRODOS	$CC, CLOSE_PB
12406   8C8A   20 00 BF    		jsr	$BF00	; ProDOS handler
12407   8C8D   CC          		DB	$CC	; ProDOS function code
12408   8C8E   348B        		DW	CLOSE_PB	; Function Parameter Block address
12409   8C90               		.MACEND
12410   8C90               		.MACEND
12411   8C90               	CLSVX:
12412                      	;	lda	#1              ; flag is true
12413                      	;	sta	SAVEDISK	; show we have a save disk in there
12414                      	;        jsr     SET_GAMEPRE     ; go get the last one used
  Tue Jun 13 1989 11:42                                                                                                  Page  186

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12415                      	;	jsr	FETCH_FILE	; this does it
12416   8C90   AE 67 46    		ldx	GAME1NML	; get length of current name
12417   8C93   BD 67 46    		lda	GAME1NM,X	; get the number of the file
12418   8C96   8D B5 49    		sta	SAVENUM 	; we need this to look for prefix
12419   8C99   8D 44 4A    	        sta     SAVEDISK        ; show taking out save disk, not game disk        
12420   8C9C   20 D1 4A    		jsr	DO_GAME1        ; open up GAME1 file
12421   8C9F   AD D3 1D    		lda	D2SEG+HI	; set DSEGS to point to #2
12422   8CA2   85 1F       		sta	DSEGS+HI
12423   8CA4   AD D2 1D    		lda	D2SEG+LO
12424   8CA7   85 1E       		sta	DSEGS+LO
12425   8CA9   AE 79 46    		ldx	GAME2NML	; get length of current name
12426   8CAC   BD 79 46    		lda	GAME2NM,X	; get the number of the file
12427   8CAF   8D B5 49    		sta	SAVENUM 	; we need this to look for prefix
12428   8CB2   20 0F 4A    		jsr	OPEN_GAME2	; open up GAME2 file
12429   8CB5   A0 00       		ldy	#0		; open up GAME2 file, just for kicks
12430   8CB7   8C 44 4A    		sty	SAVEDISK	; show we have a save disk in there
12431   8CBA   8C 35 8B    		sty	CLOSE_PB+CL_REFNUM	; clear close
12432   8CBD   C8          	        iny                     ; set for true        
12433   8CBE   84 AA       		sty	SCRIPT		; allow scripting again
12434   8CC0   60          		rts			; DONE
12435                      	;
12436                      	; CLOSE_GAME - close the current game file(s)
12437                      	;	and set DSEGS to point to preload so it will reopen them
12438                      	;
12439   8CC1               	CLOSE_GAME:
12440   8CC1   A9 00       		lda	#0			; show no files are open
12441   8CC3   8D 35 8B    		sta	CLOSE_PB+CL_REFNUM	; 0 closes all files
12442   8CC6   8D 77 46    		sta	GAME1REF		; zero out two game files too
12443   8CC9   8D 89 46    		sta	GAME2REF		; and here is number 2
12444   8CCC   8D FC 73    	        sta     PF_FID                  ; clear this too
12445   8CCF               		CLOSE	CLOSE_PB		; now all are closed
12446   8CCF               		PRODOS	$CC, CLOSE_PB
12447   8CCF   20 00 BF    		jsr	$BF00	; ProDOS handler
12448   8CD2   CC          		DB	$CC	; ProDOS function code
12449   8CD3   348B        		DW	CLOSE_PB	; Function Parameter Block address
12450   8CD5               		.MACEND
12451   8CD5               		.MACEND
12452   8CD5   60          		rts
12453                      	;
12454                      	; Get answer to Yes/No question.  Return with C==0 for yes, and C==1
12455                      	; for a no.  RETURN == Yes, ESCAPE == NO
12456                      	;
12457   8CD6               	GETYN:
12458   8CD6   20 20 51    		jsr	GETKEY		; get the key strok
12459   8CD9   C9 79       		cmp	#'y'		; IF REPLY IS "Y"
12460   8CDB   F0 25       		beq	ALLSET		; ACCEPT RESPONSES
12461   8CDD   C9 59       		cmp	#'Y'		; get both y's
12462   8CDF   F0 21       		beq	ALLSET	
12463   8CE1   C9 0D       		cmp	#EOL		; EOL IS ALSO ACCEPTABLE
12464   8CE3   F0 1D       		beq	ALLSET	
12465   8CE5   C9 6E       		cmp	#'n'		; IF REPLY IS "N"
12466   8CE7   F0 0E       		beq	NOTSAT		; return with carry set
12467   8CE9   C9 4E       		cmp	#'N'		; check both n's
12468   8CEB   F0 0A       		beq	NOTSAT	
12469   8CED   C9 1B       		cmp	#ESCAPE		; check for ESC key too
12470   8CEF   F0 06       		beq	NOTSAT		; which means no
12471   8CF1   20 B3 4E    		jsr	BEEP		; ELSE BEEP
12472   8CF4   4C D6 8C    		jmp	GETYN		; INSIST ON Y OR N
12473   8CF7               	NOTSAT:
12474   8CF7               		DLINE	NO		; PRINT "NO"/EOL
12475   8CF7   A2 E6       		ldx	#<NO	; get part of NO
12476   8CF9   A9 89       		lda	#>NO	; get other part of string
12477          [01]        		IFMA	2		; check to see if length passed in
12478                      		ldy			; then just fetch it
12479          [01]        		ELSE
12480   8CFB   A0 03       		ldy	#NOL	; get length of string
12481          [00]        		ENDIF
12482   8CFD   20 5B 4C    		jsr	DLINE		; print the string
12483   8D00               		.MACEND
12484   8D00   38          		sec			; set the carry
12485   8D01   60          		rts			; and show it
12486   8D02               	ALLSET:
12487   8D02               		DLINE	YES  		; Print "YES"/EOL
12488   8D02   A2 E2       		ldx	#<YES	; get part of YES
12489   8D04   A9 89       		lda	#>YES	; get other part of string
  Tue Jun 13 1989 11:42                                                                                                  Page  187

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12490          [01]        		IFMA	2		; check to see if length passed in
12491                      		ldy			; then just fetch it
12492          [01]        		ELSE
12493   8D06   A0 04       		ldy	#YESL	; get length of string
12494          [00]        		ENDIF
12495   8D08   20 5B 4C    		jsr	DLINE		; print the string
12496   8D0B               		.MACEND
12497   8D0B   18          		clc			; clear the carry
12498   8D0C   60          		rts
12499   8D0D               	GETRET:
12500   8D0D               		DLINE	RETQ		; ask for return
12501   8D0D   A2 D7       		ldx	#<RETQ	; get part of RETQ
12502   8D0F   A9 8A       		lda	#>RETQ	; get other part of string
12503          [01]        		IFMA	2		; check to see if length passed in
12504                      		ldy			; then just fetch it
12505          [01]        		ELSE
12506   8D11   A0 15       		ldy	#RETQL	; get length of string
12507          [00]        		ENDIF
12508   8D13   20 5B 4C    		jsr	DLINE		; print the string
12509   8D16               		.MACEND
12510   8D16               	GETRETL:
12511   8D16   20 20 51    		jsr	GETKEY		; get a key
12512   8D19   C9 0D       		cmp	#EOL		; return key?
12513   8D1B   D0 F9       		bne	GETRETL		; nope
12514   8D1D   20 A9 5D    		jsr	CHAR		; show the <CR>
12515   8D20   60          		rts
12516   8D21               			
12517                      	; ---------
12518                      	; SAVE GAME
12519                      	; ---------
12520   8D21               	ZSAVE:
12521   8D21   A9 4E       		lda	#'N'
12522   8D23   A6 62       		ldx	NARGS
12523   8D25   F0 02       		beq	OLDSAV		; NORMAL, COMPLETE SAVE
12524   8D27   A9 50       		lda	#'P'
12525   8D29               	OLDSAV:
12526   8D29   8D 8E 5B    		sta	TYPE
12527   8D2C   20 D1 89    		jsr	SAVRES		; set up screen
12528   8D2F   20 3E 8B    		jsr	GET_SNAME	; get the name of the save file
12529   8D32   B0 7B       		bcs	ZSEXIT		; don't wanna after all
12530   8D34   20 31 8C    		jsr	OPEN_SAVE	; open the file
12531   8D37   B0 76       		bcs	ZSEXIT		; don't really care to
12532                      	;
12533                      	; SAVE GAME PARAMETERS IN [BUFSAV]
12534                      	;		
12535   8D39   AD 02 96    		lda	ZBEGIN+ZID	; MOVE GAME ID
12536   8D3C   8D 20 1E    		sta	BUFSAV+0	; INTO 1ST 2 BYTES
12537   8D3F   AD 03 96    		lda	ZBEGIN+ZID+1	; OF THE A
12538   8D42   8D 21 1E    		sta	BUFSAV+1	
12539   8D45   A5 AF       		lda	ZSP+LO		; MOVE [ZSP]
12540   8D47   8D 22 1E    		sta	BUFSAV+2	
12541   8D4A   A5 B0       		lda	ZSP+HI	
12542   8D4C   8D 23 1E    		sta	BUFSAV+3	
12543   8D4F   AD A3 6C    		lda	OLDZSP+LO	
12544   8D52   8D 24 1E    		sta	BUFSAV+4	
12545   8D55   AD A4 6C    		lda	OLDZSP+HI	; MOVE [OLDZSP]
12546   8D58   8D 25 1E    		sta	BUFSAV+5	
12547   8D5B   A2 02       		ldx	#2		; MOVE CONTENTS OF [ZPC]
12548   8D5D   B5 80       	ZSL1:	lda	ZPC,X		; TO BYTES 7-9
12549   8D5F   9D 26 1E    		sta	BUFSAV+6,X	; OF [BUFSAV]
12550   8D62   CA          		dex		
12551   8D63   10 F8       		bpl	ZSL1	
12552   8D65   AD 8E 5B    		lda	TYPE
12553   8D68   8D 29 1E    		sta	BUFSAV+9	; NORMAL OR PARTIAL
12554   8D6B   C9 50       		cmp	#'P'
12555   8D6D   D0 2A       		bne	ZSNONM		; NORMAL SAVE SO NO name TO SAVE
12556                      	
12557   8D6F   A5 67       		lda	ARG3+LO		; set up FPC to get save name
12558   8D71   85 8C       		sta	FPCL		; lo part is okay
12559   8D73   A5 68       		lda	ARG3+HI		; get page
12560   8D75   20 A9 8F    		jsr	SETPC		; get memory addr
12561   8D78   85 8D       		sta	FPCH		; page number
12562   8D7A   84 8E       		sty	FPCBNK		; and bank
12563   8D7C   20 88 92    		jsr	FETCHB		; get count
12564   8D7F   85 78       		sta	I		; and save it
  Tue Jun 13 1989 11:42                                                                                                  Page  188

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12565   8D81   20 F0 8F    		jsr	NEXTFPC		; point to next byte
12566   8D84   A9 00       		lda	#0		; set up data offset
12567   8D86   85 7A       		sta	J		; did it
12568   8D88               	ZSL3:
12569   8D88   20 88 92    		jsr	FETCHB		; get data byte
12570   8D8B   A4 7A       		ldy	J		; get offset
12571   8D8D   99 2A 1E    		sta	BUFSAV+10,Y	; save into buffer
12572   8D90   20 F0 8F    		jsr	NEXTFPC		; point to next byte
12573   8D93   E6 7A       		inc	J		; next byte
12574   8D95   C6 78       		dec	I		; count it
12575   8D97   D0 EF       		bne	ZSL3		; loop again
12576   8D99               	ZSNONM:
12577                      	;
12578                      	; WRITE [LOCALS]/[BUFSAV] PAGE TO DISK
12579                      	;
12580   8D99   A9 00       		lda	#MAIN		; in the main bank
12581   8D9B   85 B8       		sta	DSKBNK		; thank you
12582   8D9D   A9 1E       		lda	#>LOCALS	; start at locals
12583   8D9F   85 B7       		sta	DBUFF+HI	; POINT TO THE PAGE
12584   8DA1   20 E6 47    		jsr	PUTDSK		; AND WRITE IT OUT
12585   8DA4   90 0F       		bcc	ZSOK		; IF SUCCEEDED, WRITE STACK
12586   8DA6               	ZSBAD:
12587   8DA6   20 7A 47    		jsr	DISK_ERR	; print error message
12588   8DA9               	        SET_EOF SETEOF_PB       ; clear out file, maybe
12589   8DA9               		PRODOS	$D0, SETEOF_PB
12590   8DA9   20 00 BF    		jsr	$BF00	; ProDOS handler
12591   8DAC   D0          		DB	$D0	; ProDOS function code
12592   8DAD   298B        		DW	SETEOF_PB	; Function Parameter Block address
12593   8DAF               		.MACEND
12594   8DAF               		.MACEND
12595   8DAF               	ZSEXIT:
12596   8DAF   20 85 8C    		jsr	CLOSE_SAVE	  ; else get game file back
12597   8DB2   4C CA 43    		jmp	RET0		; AND FAIL
12598                      	;
12599                      	; IF A PARTIAL SAVE WRITE FROM ARG1 FOR ARG2 BYTES TO DISK
12600                      	; (ROUNDED TO PGS) SKIPPING ZSTACK WRITE
12601                      	;
12602   8DB5               	ZSOK:
12603   8DB5   AD 8E 5B    		lda	TYPE
12604   8DB8   C9 50       		cmp	#'P'
12605   8DBA   D0 1F       		bne	ZSALL
12606   8DBC   A5 64       		lda	ARG1+HI		; find where to start & how far to go
12607   8DBE   20 A9 8F    		jsr	SETPC		; get page in memory
12608   8DC1   48          	        pha                     ; save for minute
12609   8DC2   29 01       	        and     #$01            ; check for odd page
12610   8DC4   F0 02       	        beq     ZSP1            ; nope, don't make one more page
12611   8DC6   E6 66       	        inc     ARG2+HI         ; go get one more page
12612   8DC8               	ZSP1:
12613   8DC8   68          	        pla                     ; get it back
12614   8DC9   29 FE       	        and     #$FE            ; must be on block boundary
12615   8DCB   85 B7       		sta	DBUFF+HI	; this is page
12616   8DCD   84 B8       		sty	DSKBNK		; which bank
12617   8DCF   A6 66       		ldx	ARG2+HI		; get MSB of count
12618   8DD1   A5 63       		lda	ARG1+LO		; get lo offset
12619   8DD3   18          		clc			; add
12620   8DD4   65 65       		adc	ARG2+LO		; lo count
12621   8DD6   90 01       		bcc	ZSPINC		; no extra page
12622   8DD8   E8          		inx			; wrapped extra page
12623   8DD9               	ZSPINC:
12624   8DD9   D0 15       	        bne     SAVE2DISK       ; go copy it now
12625                      	;
12626                      	; WRITE CONTENTS OF Z-STACK TO DISK
12627                      	;
12628   8DDB               	ZSALL:
12629   8DDB   A9 0D       		lda	#>ZSTKBL	; point to 1st page
12630   8DDD   85 B7       		sta	DBUFF+HI        
12631   8DDF   20 E6 47    		jsr	PUTDSK		; write them, first one
12632   8DE2   B0 C2       		bcs	ZSBAD
12633   8DE4   20 E6 47    		jsr	PUTDSK		; write them, second one
12634   8DE7   B0 BD       		bcs	ZSBAD
12635                      	;
12636                      	; WRITE ENTIRE GAME PRELOAD TO DISK
12637                      	;
12638   8DE9   A9 96       		lda	#>ZBEGIN	; POINT TO 1ST PAGE
12639   8DEB   85 B7       		sta	DBUFF+HI	; OF PRELOAD
  Tue Jun 13 1989 11:42                                                                                                  Page  189

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12640   8DED   AE 0E 96    		ldx	ZBEGIN+ZPURBT	; GET # IMPURE PAGES
12641   8DF0               	SAVE2DISK:
12642   8DF0   E8          		inx			; use for counting
12643   8DF1   86 78       		stx	I+LO
12644   8DF3   46 78       	        lsr     I+LO            ; /2 for 512byte pages
12645   8DF5   90 02       	        bcc     ZSL2            ; no wrapping
12646   8DF7   E6 78       	        inc     I+LO            ; wrapped once
12647   8DF9               	ZSL2:
12648   8DF9   20 E6 47    		jsr	PUTDSK          ; this does the write
12649   8DFC   B0 A8       		bcs	ZSBAD
12650   8DFE   C6 78       		dec	I+LO            ; count one page
12651   8E00   D0 F7       		bne	ZSL2            ; not done yet
12652                      	
12653   8E02   20 85 8C    		jsr	CLOSE_SAVE	; prompt for game file
12654                      	
12655          [01]        		IF	CHECKSUM == 1
12656                      		lda	CKS_COUNT
12657                      		jsr	HEXNUM
12658                      		lda	CKSB
12659                      		jsr	HEXNUM
12660                      		lda	#EOL
12661                      		jsr	CHAR
12662          [00]        		ENDIF
12663                      	
12664   8E05   A9 01       		lda	#1		; set to mark
12665   8E07   A2 00       		ldx	#0
12666   8E09   4C CD 43    		jmp	PUTBYT		; SUCCESS
12667                      	
12668                      	; ------------
12669                      	; RESTORE GAME
12670                      	; ------------
12671                      	
12672   8E0C               	ZREST:
12673   8E0C   A9 4E       		lda	#'N'
12674   8E0E   A6 62       		ldx	NARGS
12675   8E10   F0 02       		beq	OLDRES		; NORMAL, COMPLETE RESTORE
12676   8E12   A9 50       		lda	#'P'		; partial restore
12677   8E14               	OLDRES:
12678   8E14   8D 8E 5B    		sta	TYPE		; save which kind of restore
12679                      	;	
12680                      	; SAVE LOCALS IN CASE OF ERROR
12681                      	;
12682   8E17   A2 1F       		ldx	#31
12683   8E19   BD 00 1E    	LOCSAV:	lda	LOCALS,X	; COPY ALL LOCALS
12684   8E1C   9D E0 1D    		sta	LOCAL_SV,X	; to a save spot
12685   8E1F   CA          		dex
12686   8E20   10 F7       		bpl	LOCSAV
12687                      	
12688   8E22   20 3E 8B    		jsr	GET_SNAME	; get the name of the file
12689   8E25   B0 3C       		bcs	ZRQUIT		; okay, don't do it
12690   8E27   20 72 8C    		jsr	OPEN_RES	; open the restore file
12691   8E2A   B0 34       		bcs	ZRBAD		; can't do it
12692                      	
12693   8E2C   AD 8E 5B    		lda	TYPE		; PARTIAL SAVE DIFFERS STARTING HERE
12694   8E2F   C9 50       		cmp	#'P'
12695   8E31   D0 03       		bne	ZRNRML
12696   8E33   4C F4 8E    		jmp	ZPARTR		; just a partial restore
12697   8E36               	ZRNRML:
12698   8E36   A9 00       		lda	#MAIN
12699   8E38   85 B8       		sta	DSKBNK		; SET TO WRITE TO MAIN BANK
12700   8E3A   A9 1E       		lda	#>LOCALS
12701   8E3C   85 B7       		sta	DBUFF+HI
12702   8E3E   A9 02       		lda	#2              ; must read in two pages
12703   8E40   85 7E       		sta	L+LO
12704   8E42   20 01 48    		jsr	GETRES		; RETRIEVE 1ST BLOCK OF PRELOAD
12705   8E45   B0 19       		bcs	ZRBAD           ; didn't work!
12706   8E47   AD C5 45    	        lda     READ_PB+RD_LENGTH+HI ; see how much was read in
12707   8E4A   C9 02       	        cmp     #2              ; were 2 blocks read in?
12708   8E4C   D0 15       	        bne     ZRQUIT          ; wrong kind of file for complete save
12709                      	
12710   8E4E   AD 20 1E    		lda	BUFSAV+0	; DOES 1ST BYTE OF SAVED GAME ID
12711   8E51   CD 02 96    		cmp	ZBEGIN+ZID	; MATCH THE CURRENT ID?
12712   8E54   D0 0D       		bne	ZRQUIT		; WRONG DISK IF NOT
12713                      	
12714   8E56   AD 21 1E    		lda	BUFSAV+1	; WHAT ABOUT THE 2ND BYTE?
  Tue Jun 13 1989 11:42                                                                                                  Page  190

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12715   8E59   CD 03 96    		cmp	ZBEGIN+ZID+1
12716   8E5C   F0 16       		beq	ZROK		; CONTINUE IF BOTH BYTES MATCH
12717   8E5E   D0 03       	 	bne	ZRQUIT		; skip disk error message
12718                      	;
12719                      	; HANDLE RESTORE ERROR
12720                      	;
12721   8E60               	ZRBAD:
12722   8E60   20 7A 47    		jsr	DISK_ERR	; print error message
12723   8E63               	ZRQUIT:
12724   8E63   A2 1F       		ldx	#31		; RESTORE ALL SAVED LOCALS
12725   8E65   BD E0 1D    	ZRL2:	lda	LOCAL_SV,X
12726   8E68   9D 00 1E    		sta	LOCALS,X
12727   8E6B   CA          		dex
12728   8E6C   10 F7       		bpl	ZRL2
12729   8E6E               	BADRES:
12730   8E6E   20 85 8C    		jsr	CLOSE_SAVE	  ; PROMPT FOR GAME DISK
12731   8E71   4C CA 43    		jmp	RET0		; PREDICATE FAILS
12732                      	;
12733                      	; CONTINUE RESTORE
12734                      	;
12735   8E74               	ZROK:
12736   8E74   AD 10 96    		lda	ZBEGIN+ZFLAGS	; save both flag bytes
12737   8E77   85 7A       		sta	J+LO
12738   8E79   AD 11 96    		lda	ZBEGIN+ZFLAGS+1
12739   8E7C   85 7B       		sta	J+HI
12740                      	
12741   8E7E   A9 0D       		lda	#>ZSTKBL	; retrieve old contents of
12742   8E80   85 B7       		sta	DBUFF+HI	; z-stack
12743   8E82   A9 04       		lda	#4		; do 4 pages
12744   8E84   85 7E       		sta	L+LO		; tell GETRES how many pages
12745   8E86   20 01 48    		jsr	GETRES		; get 4 pages of z-stack
12746   8E89   90 03       		bcc	ZROKL1
12747   8E8B   4C 64 47    		jmp	DISK_FATAL	; if here, mix of good & bad so die
12748   8E8E               	ZROKL1:
12749   8E8E   A9 96       		lda	#>ZBEGIN	; get where we are
12750   8E90   85 B7       		sta	DBUFF+HI
12751   8E92   AD 0E 96    		lda	ZBEGIN+ZPURBT	; get # pages to load
12752   8E95   85 78       		sta	I+LO
12753   8E97   E6 78       	        inc     I+LO            ; go get last page if possible
12754   8E99               	LREST0:
12755   8E99   A5 78       		lda	I+LO		; how many pages left
12756   8E9B   F0 20       	        beq     LRESTj          ; finis
12757   8E9D   38          		sec			; doing subtract
12758   8E9E   E9 04       		sbc	#4		; doing it 4 blocks at a time
12759   8EA0   90 0E       		bcc	LREST1		; <4 blocks left so deal with it special
12760   8EA2   85 78       		sta	I+LO		; save remenants
12761   8EA4               	LREST:
12762   8EA4   A9 04       		lda	#4		; assume at least 4 pages
12763   8EA6   85 7E       		sta	L+LO		; this tells GETRES how many to read in
12764   8EA8   20 01 48    		jsr	GETRES		; fetch the remainder
12765   8EAB   90 EC       		bcc	LREST0
12766   8EAD   4C 64 47    		jmp	DISK_FATAL
12767   8EB0               	LREST1:
12768   8EB0   A5 78       		lda	I+LO		; get how many left
12769   8EB2   85 7E       		sta	L+LO		; and show it to GETRES
12770   8EB4   29 01       	        and     #$1             ; is it odd?
12771   8EB6   F0 02       	        beq     LREST2          ; nope
12772   8EB8   E6 7E       	        inc     L+LO            ; read one more
12773   8EBA               	LREST2:
12774   8EBA   20 01 48    		jsr	GETRES		; and finish it up
12775                      	;
12776                      	; RESTORE THE STATE OF THE SAVED GAME
12777                      	;
12778   8EBD               	LRESTj:
12779   8EBD   A5 7A       		lda	J+LO		; RESTORE THE STATE
12780   8EBF   8D 10 96    		sta	ZBEGIN+ZFLAGS	; OF THE FLAG WORD
12781   8EC2   A5 7B       		lda	J+HI
12782   8EC4   8D 11 96    		sta	ZBEGIN+ZFLAGS+1
12783                      	
12784   8EC7   AD 22 1E    		lda	BUFSAV+2	; RESTORE THE [ZSP]
12785   8ECA   85 AF       		sta	ZSP+LO
12786   8ECC   AD 23 1E    		lda	BUFSAV+3
12787   8ECF   85 B0       		sta	ZSP+HI
12788   8ED1   AD 24 1E    		lda	BUFSAV+4
12789   8ED4   8D A3 6C    		sta	OLDZSP+LO
  Tue Jun 13 1989 11:42                                                                                                  Page  191

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12790   8ED7   AD 25 1E    		lda	BUFSAV+5	; AND THE [OLDZSP]
12791   8EDA   8D A4 6C    		sta	OLDZSP+HI
12792                      	
12793   8EDD   A2 02       		ldx	#2		; RESTORE THE [ZPC]
12794   8EDF   BD 26 1E    	ZRL4:	lda	BUFSAV+6,X
12795   8EE2   95 80       		sta	ZPC,X
12796   8EE4   CA          		dex
12797   8EE5   10 F8       		bpl	ZRL4
12798                      	
12799   8EE7   20 85 8C    	ZROUT:	jsr	CLOSE_SAVE	  ; PROMPT FOR GAME DISK
12800   8EEA   20 DC 90    		jsr	VLDZPC		; MAKE VALID (MUST DO AFTER GET DISK)
12801                      	
12802          [01]        		IF	CHECKSUM == 1
12803                      		lda	CKS_COUNT
12804                      		jsr	HEXNUM
12805                      		lda	CKSB
12806                      		jsr	HEXNUM
12807                      		lda	#EOL
12808                      		jsr	CHAR
12809          [00]        		ENDIF
12810                      	
12811   8EED   A9 02       		lda	#2		; SET TO
12812   8EEF   A2 00       		ldx	#0
12813   8EF1   4C CD 43    		jmp	PUTBYT		; SUCCESS
12814                      	
12815                      	
12816                      		; DO PARTIAL RESTORE GETTING 1ST PAGE 
12817                      		; AND LAST PAGE BYTE ALIGNMENT CORRECT
12818                      	        ; WRITE LOCALS TO IOBUFF JUST TO LOOK AT NAME
12819   8EF4               	ZPARTR:	
12820   8EF4   A9 00       		lda	#MAIN
12821   8EF6   85 B8       		sta	DSKBNK
12822   8EF8   A9 08       		lda	#>IOBUFF	; DON'T READ TO LOCALS YET (X)
12823   8EFA   85 B7       		sta	DBUFF+HI
12824   8EFC   A9 02       		lda	#2		; just one block please
12825   8EFE   85 7E       		sta	L+LO
12826   8F00   20 01 48    		jsr	GETRES		; RETRIEVE 1ST BLOCK OF PRELOAD
12827   8F03   90 03       		bcc     ZRN2            ; worked just fine
12828   8F05               	ZPBAD:
12829   8F05   4C 6E 8E    	        jmp	BADRES		; names don't match, die
12830   8F08               	ZRN2:
12831   8F08   A5 67       		lda	ARG3+LO		; set up FPC to get save name
12832   8F0A   85 8C       		sta	FPCL		; lo part is okay
12833   8F0C   A5 68       		lda	ARG3+HI		; get page
12834   8F0E   20 A9 8F    		jsr	SETPC		; get memory addr
12835   8F11   85 8D       		sta	FPCH		; page number
12836   8F13   84 8E       		sty	FPCBNK		; and bank
12837   8F15   20 88 92    		jsr	FETCHB		; get count
12838   8F18   85 78       		sta	I		; and save it
12839   8F1A   20 F0 8F    		jsr	NEXTFPC		; point to next byte
12840   8F1D   A9 20       		lda	#<BUFSAV	; get bufsav offset
12841   8F1F   18          		clc			; and add
12842   8F20   69 0A       		adc	#10		; name offset
12843   8F22   85 7A       		sta	J		; did it
12844   8F24               	ZRN3:
12845   8F24   20 88 92    		jsr	FETCHB		; get data byte
12846   8F27   A4 7A       		ldy	J		; get offset
12847   8F29   D9 00 08    		cmp	IOBUFF,Y	; save into buffer
12848   8F2C   D0 D7       		bne	ZPBAD		; okay, then it's not it
12849   8F2E   20 F0 8F    		jsr	NEXTFPC		; point to next byte
12850   8F31   E6 7A       		inc	J		; next byte
12851   8F33   C6 78       		dec	I		; count it
12852   8F35   D0 ED       		bne	ZRN3		; loop again
12853                      	
12854   8F37   A5 64       		lda	ARG1+HI		; FIND WHERE TO START & HOW FAR TO GO
12855   8F39   20 A9 8F    		jsr	SETPC		; get page in memory
12856   8F3C   85 90       		sta	SPCH		; this is page
12857   8F3E   84 91       		sty	SPCBNK		; which bank
12858   8F40   A5 63       		lda	ARG1+LO		; START BYTE FIRST PAGE
12859   8F42   85 8F       		sta	SPCL
12860                      	
12861   8F44   A6 66       		ldx	ARG2+HI
12862   8F46   86 7B       		stx	J+HI
12863   8F48   A6 65       		ldx	ARG2+LO
12864   8F4A   86 7A       		stx	J+LO            ; how many to get
  Tue Jun 13 1989 11:42                                                                                                  Page  192

        "APPLE YZIP (c)Infocom, Inc.. --- OPCODE EXECUTORS"
        "--- ZIP SAVE AND RESTORE ROUTINES ---"

12865                      	
12866   8F4C   20 B6 44    		jsr	DECJ		; correct alignment for this usage
12867   8F4F               	POK:
12868   8F4F   A9 08       		lda	#>IOBUFF	; get 1st page
12869   8F51   85 B7       		sta	DBUFF+HI	; getres should keep in iobuff
12870   8F53   8D 6F 8F    	        sta     ZPARTMOD+2      ; and show where to get it from
12871   8F56   A9 01       	        lda     #$01            ; is it odd
12872   8F58   24 90       	        bit     SPCH            ; get page destination
12873   8F5A   F0 03       	        beq     ZPARTx          ; nope
12874   8F5C   EE 6F 8F    	        inc     ZPARTMOD+2      ; then get second page worth
12875   8F5F               	ZPARTx:
12876   8F5F   A9 02       		lda	#2		; just do one block
12877   8F61   85 7E       		sta	L+LO
12878   8F63   20 01 48    		jsr	GETRES
12879   8F66   90 03       		bcc	ZPART0
12880   8F68   4C 64 47    		jmp	DISK_FATAL	; ALL MESSED UP, JUST QUIT
12881   8F6B               	ZPART0:
12882   8F6B   A4 63       		ldy	ARG1+LO		; START BYTE FIRST PAGE
12883   8F6D               	ZPARTMOD:
12884   8F6D   B9 00 08    		lda	IOBUFF,Y        ; this gets modified with good page #
12885   8F70   20 67 92    		jsr	STASHB
12886   8F73   20 D0 8F    		jsr	NEXTSPC
12887   8F76   20 B6 44    		jsr	DECJ
12888   8F79   B0 03       		bcs	ZPART1		; CARRY CLEAR IF $FFFF RESULT
12889   8F7B   4C E7 8E    		jmp	ZROUT
12890   8F7E               	ZPART1:
12891   8F7E   E6 63       		inc	ARG1+LO
12892   8F80   D0 E9       		bne	ZPART0
12893   8F82   A9 09       	        lda     #>IOBUFF+1      ; this is second page address
12894   8F84   CD 6F 8F    	        cmp     ZPARTMOD+2      ; is it second one already?
12895   8F87   F0 C6       		beq	POK		; yes, so read in a new block
12896   8F89   8D 6F 8F    	        sta     ZPARTMOD+2      ; then update it 
12897   8F8C   D0 DD       	        bne     ZPART0          ; and do it again
12898                      	;
12899                      	; THE OLD SAVE & RESTORE STILL HAVE OPCODES
12900                      	; SO JUST PUT IN A PLACE FOR THEM HERE FOR NOW
12901                      	;
12902   8F8E               	OSAVE:
12903   8F8E   60          	OREST:	RTS
12904                      	
12905   8F8F               	ZISAVE:
12906   8F8F   4C CA 43    	ZIREST:	JMP	RET0	; NOT IMPLEMENTED ON APPLE
12907   8F92               		END
12908                      	
12909                      	
12910   8F92               		TITLE 	"APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
12911   8F92               		INCLUDE 	XPAGING.ASM
12912   8F92               		STTL "--- MEMORY PAGING ROUTINES ---"
12913                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page  193

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

12914                      	
12915                      	; -------------------------
12916                      	; POINT [MPC] TO V-ADDR [I]
12917                      	; -------------------------
12918                      	
12919   8F92   A5 78       	SETWRD:	LDA	I+LO	
12920   8F94   85 86       		STA	MPCL	
12921   8F96   A5 79       		LDA	I+HI	
12922   8F98   85 87       		STA	MPCM	
12923   8F9A   A9 00       		LDA	#0	
12924   8F9C   85 88       		STA	MPCH	; ZERO TOP BIT
12925   8F9E   4C B2 90    		JMP	VLDMPC	
12926                      	
12927                      	;
12928   8FA1   00 00       	WANTED:	DB	00,00	
12929                      	;
12930   8FA3   00          	NEXT:	DB	00	
12931   8FA4   00          	NSUBA:	DB	00	
12932   8FA5   00          	PSUBA:	DB	00	
12933                      	;
12934   8FA6   00          	YTEMP:	DB	00	
12935   8FA7   00          	ATEMP:	DB	00	
12936   8FA8   00          	NSUBY:	DB	00	
12937                      	;
12938                      	; set [A](page), [Y](bank) to point to memory page where page in [A] is
12939                      	;
12940   8FA9               	SETPC:			
12941   8FA9   85 BC       		sta	MEMPAGE		; save it for later addition
12942   8FAB   C9 29       		cmp	#P2PAGE 	; IS IT A PAGE IN MAIN
12943   8FAD   B0 06       		bcs	VF2		; No, it might be in aux mem
12944                      	
12945   8FAF   A9 96       		lda	#>ZBEGIN 	; ADD OFFSET TO GET RAM PAGE
12946   8FB1   A0 00       		ldy	#MAIN		; in the main bank
12947   8FB3   F0 12       		beq	VFEXI		; BRA to fetch
12948   8FB5               	VF2:
12949   8FB5   C9 D6       		cmp	#PGBEGIN	; is it paged?
12950   8FB7   B0 12       		bcs	VFERR		; yes it be paged, so can't deal with it
12951   8FB9   C9 A8       		cmp	#P3PAGE		; is it in Aux Mem, Part 2?
12952   8FBB   B0 06       		bcs	VF3		; yes, so subtract different amount
12953                      	;
12954                      	; this is in lower aux 
12955                      	;				
12956   8FBD   A9 17       		lda	#(Z2PAGE-Z1SIZE) ; subtract size from offset
12957   8FBF   A0 01       		ldy	#AUX		; show aux mem
12958   8FC1   D0 04       		bne	VFEXI		; jump to end
12959   8FC3               	VF3:
12960   8FC3   A9 28       		lda	#(Z3PAGE-(Z1SIZE+Z2SIZE)) ; subtract out first 2 sides
12961   8FC5   A0 FF       		ldy	#P3BANK		; show page 3 bank
12962   8FC7               	VFEXI:
12963   8FC7   18          		clc			; get ready for addition
12964   8FC8   65 BC       		adc	MEMPAGE		; now get actual offset
12965   8FCA   60          		rts	
12966   8FCB               	VFERR:
12967                      	;
12968                      	; out of range
12969                      	;
12970   8FCB   A9 12       		lda	#18
12971   8FCD   4C F9 51    		jmp	ZERROR
12972                      	;
12973                      	; NEXTSPC - inc SPCL and check for wrapping round to next bank
12974                      	;
12975   8FD0               	NEXTSPC:
12976   8FD0   E6 8F       		inc	SPCL		; next lo byte
12977   8FD2   D0 1B       		bne	NXSP_EXIT	; no change then
12978   8FD4   E6 90       		inc	SPCH		; next page
12979   8FD6   A5 90       		lda	SPCH		; so get page
12980   8FD8   C9 BF       		cmp	#>PRGLBL	; have we reached end of line?
12981   8FDA   D0 13       		bne	NXSP_EXIT	; we be okay
12982   8FDC   A5 91       		lda	SPCBNK		; get bank
12983   8FDE   D0 07       		bne	NXSP1		; must go to Part 3
12984   8FE0   E6 91       		inc	SPCBNK		; so point to aux bank
12985   8FE2   A9 40       		lda	#Z2PAGE		; first page in aux
12986   8FE4   85 90       		sta	SPCH		; and point to it
12987   8FE6   60          		rts			; and all done
12988   8FE7               	NXSP1:
  Tue Jun 13 1989 11:42                                                                                                  Page  194

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

12989   8FE7   A9 D0       		lda	#Z3PAGE		; get start of page 3
12990   8FE9   85 90       		sta	SPCH		; and point there
12991   8FEB   A9 FF       		lda	#P3BANK		; and point to this bank
12992   8FED   85 91       		sta	SPCBNK		; okey
12993   8FEF               	NXSP_EXIT:
12994   8FEF   60          		rts
12995                      	;
12996                      	; NEXTFPC - inc DPCL and check for wrapping round to next bank
12997                      	;
12998   8FF0               	NEXTFPC:
12999   8FF0   E6 8C       		inc	FPCL		; next lo byte
13000   8FF2   D0 1B       		bne	NXFP_EXIT	; no change then
13001   8FF4   E6 8D       		inc	FPCH		; next page
13002   8FF6   A5 8D       		lda	FPCH		; and get it for checking
13003   8FF8   C9 BF       		cmp	#>PRGLBL	; have we reached end of line?
13004   8FFA   D0 13       		bne	NXFP_EXIT	; we be okay
13005   8FFC   A5 8E       		lda	FPCBNK		; get bank
13006   8FFE   D0 07       		bne	NXFP1		; must skip over stuff in middle
13007   9000   E6 8E       		inc	FPCBNK		; so point to aux bank
13008   9002   A9 40       		lda	#Z2PAGE		; first page in aux
13009   9004   85 8D       		sta	FPCH		; and point to it
13010   9006   60          		rts			; toots finis
13011   9007               	NXFP1:
13012   9007   A9 D0       		lda	#Z3PAGE		; start of part 3
13013   9009   85 8D       		sta	FPCH		; so show me
13014   900B   A9 FF       		lda	#P3BANK		; and point to this bank
13015   900D   85 8E       		sta	FPCBNK		; okey
13016   900F               	NXFP_EXIT:
13017   900F   60          		rts
13018                      	;
13019                      	; ADDFPC - add amount in [A] to current FPC and check for bank wrap
13020                      	;
13021   9010               	ADDFPC:
13022   9010   18          		clc			; get ready for add
13023   9011   65 8C       		adc	FPCL		; add lo part
13024   9013   85 8C       		sta	FPCL		; and save it
13025   9015   90 1B       		bcc	AFPX		; all done if no page wrap
13026   9017   E6 8D       		inc	FPCH		; point to next page
13027   9019   A5 8D       		lda	FPCH		; get it for compare
13028   901B   C9 BF       		cmp	#>PRGLBL	; at end of line in main bank?
13029   901D   D0 13       		bne	AFPX		; nope, all done then
13030   901F   A5 8E       		lda	FPCBNK		; get bank
13031   9021   F0 09       		beq	AFP1		; it is main, so we be ok
13032   9023   A9 D0       		lda	#Z3PAGE		; must go to part 3 if in aux mem
13033   9025   85 8D       		sta	FPCH		; thanx
13034   9027   A9 FF       		lda	#P3BANK		; and point to this bank
13035   9029   85 8E       		sta	FPCBNK		; okey
13036   902B   60          		rts			; done
13037   902C               	AFP1:
13038   902C   E6 8E       		inc	FPCBNK		; point to aux
13039   902E   A9 40       		lda	#Z2PAGE		; get start in aux
13040   9030   85 8D       		sta	FPCH		; and save it
13041   9032               	AFPX:
13042   9032   60          		rts
13043                      	;
13044                      	; ADDSPC - add amount in [A] to current SPC and check for bank wrap
13045                      	;
13046   9033               	ADDSPC:
13047   9033   18          		clc			; get ready for add
13048   9034   65 8F       		adc	SPCL		; add lo part
13049   9036   85 8F       		sta	SPCL		; and save it
13050   9038   90 1B       		bcc	ASPX		; all done if no page wrap
13051   903A   E6 90       		inc	SPCH		; point to next page
13052   903C   A5 90       		lda	SPCH		; get it for compare
13053   903E   C9 BF       		cmp	#>PRGLBL	; at end of line in main bank?
13054   9040   D0 13       		bne	ASPX		; nope, all done then
13055   9042   A5 91       		lda	SPCBNK		; get bank
13056   9044   F0 09       		beq	ASP1		; it is main, so we be ok
13057   9046   A9 D0       		lda	#Z3PAGE		; must go to part 3 if in aux mem
13058   9048   85 90       		sta	SPCH		; thanx
13059   904A   A9 FF       		lda	#P3BANK		; and point to this bank
13060   904C   85 91       		sta	SPCBNK		; okey
13061   904E   60          		rts			; done
13062   904F               	ASP1:
13063   904F   E6 91       		inc	SPCBNK		; point to aux
  Tue Jun 13 1989 11:42                                                                                                  Page  195

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13064   9051   A9 40       		lda	#Z2PAGE		; get start in aux
13065   9053   85 90       		sta	SPCH		; and save it
13066   9055               	ASPX:
13067   9055   60          		rts
13068                      	;
13069                      	; PREVFPC - DEC FPCL and check for wrapping round to next bank
13070                      	;
13071   9056               	PREVFPC:
13072   9056   A5 8C       		lda	FPCL		; get lo part
13073   9058   D0 1E       		bne	PFPC2		; it's not zero, so no wrapping
13074   905A   A5 8D       		lda	FPCH		; get current page
13075   905C   C9 40       		cmp	#Z2PAGE		; have we reached beginning of page 2?
13076   905E   F0 08       		beq	PFPC1		; wrap to first bank
13077   9060   C9 D0       		cmp	#Z3PAGE		; beginning of part 3?
13078   9062   F0 0C       		beq	PFPC3		; ayyup
13079   9064   C6 8D       		dec	FPCH		; point to previous page
13080   9066   D0 10       		bne	PFPC2		; okay
13081   9068               	PFPC1:
13082   9068   A5 8E       		lda	FPCBNK		; get bank
13083   906A   F0 0F       		beq	VF1ERR		; oops, can't go backwards from main bank
13084   906C   A9 00       		lda	#MAIN		; so point to main bank
13085   906E   F0 02       		beq	PFPC4		; and store it away
13086   9070               	PFPC3:
13087   9070   A9 01       		lda	#AUX		; and point to this bank
13088   9072               	PFPC4:
13089   9072   85 8E       		sta	FPCBNK		; okey
13090   9074   A9 BE       		lda	#(>PRGLBL)-1	; get me last page in part 2
13091   9076   85 8D       		sta	FPCH		; and show me
13092   9078               	PFPC2:
13093   9078   C6 8C       		dec	FPCL		; and point to previous byte
13094   907A   60          		rts
13095   907B               	VF1ERR:
13096                      	;
13097                      	; out of range
13098                      	;
13099   907B   A9 13       		lda	#19
13100   907D   4C F9 51    		jmp	ZERROR
13101                      	;
13102                      	; PREVSPC - DEC SPCL and check for wrapping round to main bank
13103                      	;
13104   9080               	PREVSPC:
13105   9080   A5 8F       		lda	SPCL		; get lo part
13106   9082   D0 1E       		bne	PSPC2		; it's not zero, so no wrapping
13107   9084   A5 90       		lda	SPCH		; get current page
13108   9086   C9 40       		cmp	#Z2PAGE		; have we reached beginning of page 2?
13109   9088   F0 08       		beq	PSPC1		; wrap to first bank
13110   908A   C9 D0       		cmp	#Z3PAGE		; down past page 3?
13111   908C   F0 0C       		beq	PSPC3		; sure is
13112   908E   C6 90       		dec	SPCH		; point to previous page
13113   9090   D0 10       		bne	PSPC2		; okay
13114   9092               	PSPC1:
13115   9092   A5 91       		lda	SPCBNK		; get bank
13116   9094   F0 E5       		beq	VF1ERR		; oops, can't go backwards from main bank
13117   9096   A9 00       		lda	#MAIN		; so point to main bank
13118   9098   F0 02       		beq	PSPC4		; so save it
13119   909A               	PSPC3:
13120   909A   A9 01       		lda	#AUX		; and point to this bank
13121   909C               	PSPC4:
13122   909C   85 8E       		sta	FPCBNK		; okey
13123   909E   A9 BE       		lda	#>PRGLBL-1	; get me last page in low part
13124   90A0   85 90       		sta	SPCH		; and show me
13125   90A2               	PSPC2:
13126   90A2   C6 8F       		dec	SPCL		; and point to previous byte
13127   90A4   60          		rts
13128                      	;
13129                      	; FP2SP - copy the 3 parts of FPC to SPC
13130                      	;
13131   90A5               	FP2SP:
13132   90A5   A5 8E       		lda	FPCBNK
13133   90A7   85 91       		sta	SPCBNK
13134   90A9   A5 8D       		lda	FPCH
13135   90AB   85 90       		sta	SPCH
13136   90AD   A5 8C       		lda	FPCL
13137   90AF   85 8F       		sta	SPCL
13138   90B1   60          		rts
  Tue Jun 13 1989 11:42                                                                                                  Page  196

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13139   90B2               		
13140                      	; MAKE [MPCPNT],[MPCBNK] POINT TO
13141                      	; THE RAM PAGE AND BANK THAT HOLDS
13142                      	; THE V-PAGE MPCH,M
13143                      	;
13144   90B2               	VLDMPC:			
13145   90B2   A5 88       		lda	MPCH		; check hi part
13146   90B4   D0 0F       		bne	VLD3		; NOT IN FIRST V-64K, so must be paged
13147   90B6   A5 87       		lda	MPCM		; check to see if it is paged
13148   90B8   20 D4 91    		jsr	CHECKPRE	; is it preloaded?
13149   90BB   B0 08       		bcs	VLD3		; no, so it be paged
13150   90BD   20 A9 8F    		jsr	SETPC		; so put page/bank into A/Y
13151   90C0   84 8B       		sty	MPCBNK	
13152   90C2   85 8A       		sta	MPCPNT+HI	
13153   90C4               	NOMUCK:
13154   90C4   60          		rts	
13155                      	;
13156                      	; must be paged, so check for it or read it in
13157                      	;
13158   90C5               	VLD3:	
13159   90C5   A5 88       		lda	MPCH	
13160   90C7   A4 87       		ldy	MPCM	
13161   90C9   20 12 91    		jsr	PAGE	;RETURN BUFFER IN A THAT HAS VPAGE A,Y
13162   90CC   18          		clc		
13163   90CD   69 08       		adc	#>PBEGIN	
13164   90CF   85 8A       		sta	MPCPNT+HI	
13165   90D1   A0 01       		ldy	#PB_BANK	; paging buffers are in aux mem
13166   90D3   84 8B       		sty	MPCBNK	
13167                      	;
13168                      	; TEST FOR MUCK
13169                      	;
13170   90D5   AD 11 91    		lda	MUCKFLG	
13171   90D8   F0 EA       		beq	NOMUCK	
13172   90DA   D0 00       		bne	VLDZPC	;MAY HAVE MUCKED ZPC SO GO FIX
13173                      	;
13174                      	; SAME IDEA AS VLDMPC
13175                      	;
13176   90DC               	VLDZPC:
13177   90DC   A5 59       	        lda     INFODOS         ; check first for InfoDOS page
13178   90DE   F0 06       	        beq     VLDZ1           ; none
13179   90E0   20 E9 91    	        jsr     INFO_PAGE       ; well, is it?
13180   90E3   90 01       	        bcc     VLDZ1           ; nope
13181   90E5   60          	        rts                     ; all set otherwise
13182   90E6               	VLDZ1:
13183   90E6   A5 82       		lda	ZPCH	
13184   90E8   D0 0F       		bne	VLDZ3		;NOT IN FIRST V-64K, so must be paged
13185   90EA   A5 81       		lda	ZPCM		; check to see if it is paged
13186   90EC   20 D4 91    		jsr	CHECKPRE	; is it preloaded?
13187   90EF   B0 08       		bcs	VLDZ3		; no, so it must be paged
13188   90F1   20 A9 8F    		jsr	SETPC		; point to correct bank and page
13189   90F4   84 85       		sty	ZPCBNK		; set bank
13190   90F6   85 84       		sta	ZPCPNT+HI	; and MSB of pointer
13191   90F8               	NOZMUCK:
13192   90F8   60          		rts		
13193                      	VLDZ3:				;MUST BE PAGED
13194   90F9   A5 82       		lda	ZPCH	
13195   90FB   A4 81       		ldy	ZPCM	
13196   90FD   20 12 91    		jsr	PAGE		;RETURN BUFFER IN A THAT HAS VPAGE A,Y
13197   9100   18          		clc		
13198   9101   69 08       		adc	#>PBEGIN	
13199   9103   85 84       		sta	ZPCPNT+HI	
13200   9105   A0 01       		ldy	#PB_BANK
13201   9107   84 85       		sty	ZPCBNK	
13202                      	;
13203                      	; TEST MUCKING
13204                      	;
13205   9109   AD 11 91    		lda	MUCKFLG	
13206   910C   F0 EA       		beq	NOZMUCK	
13207   910E   4C B2 90    		jmp	VLDMPC	;MAY HAVE MUCKED MPC SO GO FIX
13208                      	
13209                      	
13210                      	; FIND V-PAGE A,Y IF IT IS IN MEM
13211                      	; AND RETURN WITH LINKED LIST
13212                      	; PROPERLY MAINTAINED
13213                      	; IF V-PAGE A,Y NOT IN MEM
  Tue Jun 13 1989 11:42                                                                                                  Page  197

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13214                      	; GET FROM DISK AND PUT IN RIGHT
13215                      	; PLACE
13216                      	
13217   9111   00          	MUCKFLG:	DB	00	;00 IF PAGING BUFFERS NOT MUCKED
13218                      	
13219   9112               	PAGE:
13220   9112   8D A2 8F    		sta	WANTED+HI	
13221   9115   8C A1 8F    		sty	WANTED+LO	
13222   9118   A2 00       		ldx	#0	
13223   911A   8E 11 91    		stx	MUCKFLG		; CLEAR MUCK FLAG
13224   911D   20 BC 91    		jsr	WHERE	
13225   9120   90 39       		bcc	TOUGH		; PAGE IS RESIDENT IN PAGING SPACE
13226                      	;
13227                      	; PAGE MUST BE BROUGHT IN FROM DISK
13228                      	;
13229   9122   A6 CD       		ldx	CURRENT		;GET BUFFER TO PUT PAGE INTO
13230   9124   BD 00 0C    		lda	NEXTPNT,X	;BY LOOKING AT NEXT POINTER
13231   9127   85 CD       		sta	CURRENT		;MAKE IT THE CURRENT BUFFER
13232   9129   AA          		tax		
13233   912A   AD A2 8F    		lda	WANTED+HI	;LET BUFFER MAP KNOW
13234   912D   9D 80 0C    		sta	VPAGEH,X	;WHICH PAGE
13235   9130   AD A1 8F    		lda	WANTED+LO	;IS GOING TO
13236   9133   29 FE       		and	#$FE		; make address be even
13237   9135   9D C0 0C    		sta	VPAGEL,X	;BE THERE
13238                      	;***
13239                      	; point to the next page too
13240                      	;
13241   9138   09 01       		ora	#1		; add one to point to next 256 byte page
13242   913A   48          		pha			; save it
13243   913B   8A          		txa			; get pointer
13244   913C   A8          		tay			; into y
13245   913D   C8          		iny			; point to next buffer
13246   913E   68          		pla			; get second buffer back
13247   913F   99 C0 0C    		sta	VPAGEL,Y	; so point to it
13248   9142   BD 80 0C    		lda	VPAGEH,X	; get MSB
13249   9145   99 80 0C    		sta	VPAGEH,Y	; and save it
13250                      	;
13251                      	; A = WANTED+HI
13252                      	; Y = WANTED+LO
13253                      	; X = BUFFER
13254                      	;
13255   9148   AD A1 8F    		lda	WANTED+LO	
13256   914B   29 FE       		and	#$FE		; clear low bit to make it even
13257   914D   A8          		tay			; want it in y
13258                      	;*** 
13259   914E   AD A2 8F    		lda	WANTED+HI	
13260   9151   A6 CD       		ldx	CURRENT
13261   9153   20 80 91    		jsr	GETVPAGE	; PUT V-PAGE A,Y INTO PAGING BUFFER X
13262                      	;***
13263   9156   CE 11 91    		dec	MUCKFLG		; INDICATE A MUCKING
13264   9159   D0 1C       		bne	PAGEXIT		; and return current buffer
13265   915B               	TOUGH:
13266   915B   29 FE       		and	#$FE		; make even page, please
13267   915D   8D A3 8F    		sta	NEXT	
13268   9160   C5 CD       		cmp	CURRENT		; GETS REALY SCREWED IF CURRENT==NEXT
13269   9162   F0 13       		beq	PAGEXIT		; DO NOT CHANGE POINTERS IF IT DOES
13270                      	;
13271                      	; Y=NEXT(CURRENT)
13272                      	; DO THE RIGHT THING TO THE POINTERS
13273                      	;
13274                      	;	ldy	CURRENT	
13275                      	;	lda	NEXTPNT,Y	
13276                      	;	sta	NSUBCUR	
13277   9164   AD A3 8F    		lda	NEXT	
13278   9167   20 AA 91    		jsr	DETATCH	
13279   916A   A4 CD       		ldy	CURRENT	
13280   916C   AD A3 8F    		lda	NEXT	
13281   916F   20 93 91    		jsr	INSERT	
13282   9172   AD A3 8F    		lda	NEXT	
13283   9175   85 CD       		sta	CURRENT	
13284   9177               	PAGEXIT:
13285                      	;*** perhaps add one to point to correct buffer
13286   9177   AD A1 8F    		lda	WANTED+LO	; get LSB
13287   917A   29 01       		and	#$01		; pick up even/odd bit
13288   917C   18          		clc			; doing add
  Tue Jun 13 1989 11:42                                                                                                  Page  198

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13289   917D   65 CD       		adc	CURRENT		; point to correct buffer
13290   917F   60          		rts
13291                      	
13292   9180               	GETVPAGE:			
13293   9180   8D 88 6C    		sta	DBLOCK+HI	
13294   9183   8C 87 6C    		sty	DBLOCK+LO	
13295   9186   8A          		txa			; get which paging buffer
13296   9187   18          		clc		
13297   9188   69 08       		adc	#>PBEGIN	; and set up abs addr
13298   918A   85 B7       		sta	DBUFF+HI	; thank you, that's much better
13299   918C   A2 01       		ldx	#PB_BANK
13300   918E   86 B8       		stx	DSKBNK	
13301   9190   4C BF 46    		jmp	GETDSK	
13302                      	
13303                      	; INSERT A AFTER Y
13304                      	; A.next = Y.next
13305                      	; Y.next = A
13306                      	; A.previous = Y
13307                      	; [Y.next].previous = A
13308   9193               	INSERT:
13309   9193   AA          		tax
13310   9194   B9 00 0C    		lda	NEXTPNT,Y	; Y.next
13311   9197   9D 00 0C    		sta	NEXTPNT,X	; A.next = Y.next
13312   919A   48          		pha			; save Y.next for later
13313   919B   8A          		txa
13314   919C   99 00 0C    		sta	NEXTPNT,Y	; Y.next = A
13315   919F   98          		tya
13316   91A0   9D 40 0C    		sta	PREVPNT,X	; A.prev = Y
13317   91A3   68          		pla			; get Y.next back
13318   91A4   A8          		tay			; [Y.next].previous
13319   91A5   8A          		txa
13320   91A6   99 40 0C    		sta	PREVPNT,Y	; [Y.next].previous = A
13321   91A9   60          		rts
13322                      	
13323          [01]        		IF	0	
13324                      	;
13325                      	; old one, which puts A AFTER! Y
13326                      	;
13327                      	; PREV(A)=Y
13328                      	; PREV(NEXT(Y))=A
13329                      	; NEXT(A)=NEXT(Y)
13330                      	; NEXT(Y)=A
13331                      	
13332                      		sta	ATEMP	
13333                      		sty	YTEMP	
13334                      		tax		
13335                      		tya		
13336                      		sta	PREVPNT,X	
13337                      	
13338                      		lda	NEXTPNT,Y	
13339                      		sta	NSUBY	
13340                      		txa		
13341                      		ldx	NSUBY	
13342                      		sta	PREVPNT,X	
13343                      	
13344                      		txa		
13345                      		ldx	ATEMP	
13346                      		sta	NEXTPNT,X	
13347                      	
13348                      		lda	ATEMP	
13349                      		sta	NEXTPNT,Y	
13350                      		rts		
13351          [00]        		ENDIF
13352                      	
13353                      	; DETATCH BUFFER >A<
13354                      	; NEXT(PREV(A))=NEXT(A)
13355                      	; PREV(NEXT(A))=PREV(A)
13356                      	
13357   91AA               	DETATCH:
13358   91AA   AA          		tax
13359   91AB   BD 00 0C    		lda	NEXTPNT,X
13360   91AE   A8          		tay			; Y == A.next
13361   91AF   BD 40 0C    		lda	PREVPNT,X	; get A.previous
13362   91B2   AA          		tax			; X == A.previous
13363   91B3   98          		tya			; get A.next
  Tue Jun 13 1989 11:42                                                                                                  Page  199

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13364   91B4   9D 00 0C    		sta	NEXTPNT,X	; [A.previous].next = A.next
13365   91B7   8A          		txa			; get A.previous
13366   91B8   99 40 0C    		sta	PREVPNT,Y	; [A.next].previous = A.previous
13367   91BB   60          		rts		
13368                      	
13369                      	
13370                      	; RETURN BUFFER OF PAGE [WANTED]
13371                      	; IN >A< ELSE SEC  (Y=WANTED+LO)
13372                      	
13373   91BC   A2 17       	WHERE:	LDX	#NUMBUFS-1	
13374   91BE               	WHLOOP:			
13375   91BE   AD A2 8F    		LDA	WANTED+HI	
13376   91C1   DD 80 0C    		CMP	VPAGEH,X	;>SAME
13377   91C4   F0 05       		BEQ	WHGOT	
13378   91C6               	WHNOGOT:			
13379   91C6   CA          		DEX		
13380   91C7   10 F5       		BPL	WHLOOP	
13381   91C9   38          		SEC		
13382   91CA   60          		RTS		
13383   91CB               	WHGOT:			
13384   91CB   98          		TYA		
13385   91CC   DD C0 0C    		CMP	VPAGEL,X	
13386   91CF   D0 F5       		BNE	WHNOGOT	
13387   91D1   8A          		TXA		
13388   91D2   18          		CLC		
13389   91D3   60          		RTS		
13390                      	;
13391                      	; CHECKPRE - check to see if page in [A] is in preloaded
13392                      	;
13393   91D4               	CHECKPRE:
13394   91D4   C5 C2       		cmp	TBLPUR		; check against PURE tables
13395   91D6   90 0B       		bcc	CHKPEXY		; must be preloaded then
13396   91D8               	CHKP1:
13397   91D8   C5 C3       		cmp	FUNPRE		; is it in function preload?
13398   91DA   90 09       		bcc	CHKPEXN		; preloaded function > desired, not preloaded
13399   91DC   C5 C4       		cmp	FUNPUR		; how bout at end?
13400   91DE   B0 05       		bcs	CHKPEXN		; it is not preloaded
13401   91E0               	CHKP3:
13402   91E0   18          		clc			; doing add
13403   91E1   65 C5       		adc	FUNPGE		; get me memory page for function
13404   91E3               	CHKPEXY:
13405   91E3   18          		clc			; show it is preloaded
13406   91E4   60          		rts			; then we got it
13407   91E5               	CHKPEXN:
13408   91E5   38          		sec			; show it ain't here
13409   91E6   60          		rts
13410                      	;
13411                      	; INFO_PAGE - is it one of the special preloaded pages for infoDOS?  If it
13412                      	;       is, then set up ZPCPNTR to point to it, and set carry.  Otherwise,
13413                      	;       clear carry to show it ain't.
13414   91E7               	IPAGE:	ds	2
13415   91E9               	INFO_PAGE:
13416   91E9   A5 82       	        lda     ZPCH            ; get 2 parts
13417   91EB   8D E8 91    	        sta     IPAGE+HI
13418   91EE   A5 81       	        lda     ZPCM
13419   91F0   8D E7 91    	        sta     IPAGE+LO
13420   91F3   4E E8 91    	        lsr     IPAGE+HI      ; /2 to get 512 block        
13421   91F6   6E E7 91    	        ror     IPAGE+LO
13422   91F9   A0 08       	        ldy     #SGTSEG         ; point to first segment, MSB
13423   91FB   B1 59       	        lda     (INFODOS),Y     ; howzit look?
13424   91FD   C8          	        iny                     ; point to LSB
13425   91FE   CD E8 91    	        cmp     IPAGE+HI
13426   9201   90 0B       	        bcc     INFP1           ; might be interesting
13427   9203   D0 34       	        bne     INFPNX          ; not here, < than minimum
13428   9205   B1 59       	        lda     (INFODOS),Y     ; how bout LSB
13429   9207   CD E7 91    	        cmp     IPAGE+LO
13430   920A   F0 14       	        beq     INFPYX          ; found it
13431   920C   B0 2B       	        bcs     INFPNX          ; nope, < than minimum again
13432                      	;
13433                      	; here, it's at least > than minimum
13434                      	;
13435   920E               	INFP1:
13436                      	;        iny                     ; point at end block, MSB
13437   920E   AD D4 6C    	        lda     INFODOS_END+HI  ; howz end segment look
13438   9211   CD E8 91    	        cmp     IPAGE+HI
  Tue Jun 13 1989 11:42                                                                                                  Page  200

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13439   9214   90 23       	        bcc     INFPNX          ; nope, > than maximum of special
13440   9216   D0 08       	        bne     INFPYX          ; yup, < than maximum of special
13441                      	;        iny                     ; LSB of last one
13442   9218   AD D3 6C    	        lda     INFODOS_END+LO     ; is LSB < special?
13443   921B   CD E7 91    	        cmp     IPAGE+LO      ; MSB of current one == MSB of special        
13444   921E   90 19       	        bcc     INFPNX          ; nope, not here
13445   9220               	INFPYX:
13446   9220   A0 09       	        ldy     #SGTSEG+1       ; point back to start block, LSB
13447   9222   B1 59       	        lda     (INFODOS),Y     ; get start block
13448   9224   0A          	        asl     A               ; *2 to get start page
13449   9225   8D E7 91    	        sta     IPAGE+LO      ; save it
13450   9228   A5 81       	        lda     ZPCM
13451   922A   38          	        sec                     ; doing sub
13452   922B   ED E7 91    	        sbc     IPAGE+LO      ; get offset into special block
13453   922E   18          	        clc                     ; now add in offset
13454   922F   69 D0       	        adc     #>SP_START      ; get the start of special area
13455   9231   85 84       	        sta     ZPCPNT+HI       ; show ZPCPNTR
13456   9233   A9 00       	        lda     #SP_BANK        ; which bank
13457   9235   85 85       	        sta     ZPCBNK          ; okey
13458   9237   38          	        sec                     ; show it was here
13459   9238   60          	        rts
13460   9239               	INFPNX:
13461   9239   18          	        clc                     ; show not here
13462   923A   60          	        rts                     ; g'day
13463   923B               	        
13464   923B               	        
13465   923B               	        
13466   923B               	CHKPEXN0:
13467                      	
13468   923B               	GETBYT:			
13469   923B   A4 86       		ldy	MPCL	
13470   923D   20 BA 92    		jsr	MFETCH		; go and get it
13471   9240   E6 86       		inc	MPCL		;POINT TO NEXT BYTE
13472   9242   D0 0B       		bne	GETGOT		;IF NO CROSS WE ARE STILL VALID
13473   9244   E6 87       		inc	MPCM	
13474   9246   D0 02       		bne	GET1
13475   9248   E6 88       		inc	MPCH
13476   924A               	GET1:
13477   924A   48          		pha			; save byte	
13478   924B   20 B2 90    		jsr	VLDMPC	
13479   924E   68          		pla			; and get it back
13480   924F               	GETGOT:
13481   924F   A8          		tay		;SET FLAGS
13482   9250   60          		rts		;RED SLIPPER TIME
13483                      	;
13484                      	; NEXTPC - Fetch the byte at the current ZPC, point to next byte and
13485                      	; 		validate pointer
13486                      	;
13487   9251               	NEXTPC:
13488   9251   A4 80       		ldy	ZPCL		; get low pointer
13489   9253   20 A2 92    		jsr	ZFETCH		; fetch @ZPCPNT
13490   9256   E6 80       		inc	ZPCL	
13491   9258   D0 0B       		bne	NXTGOT	
13492   925A   E6 81       		inc	ZPCM	
13493   925C   D0 02       		bne	CRSZ1	
13494   925E   E6 82       		inc	ZPCH	
13495   9260               	CRSZ1:
13496   9260   48          		pha			; save opcode
13497   9261   20 DC 90    		jsr	VLDZPC	
13498   9264   68          		pla			; and get it back
13499   9265               	NXTGOT:
13500   9265   A8          		tay		
13501   9266   60          		rts		
13502                      	
13503                      	;
13504                      	; STASHB - use SPC to save a byte in either aux or main mem
13505                      	;
13506   9267               	STASHB:	
13507   9267   A4 91       		ldy	SPCBNK		; get the bank
13508   9269   30 09       		bmi	SB1		; must be in upper RAM
13509   926B   99 04 C0    		sta	WRTBNK,Y	; set bank
13510   926E   A0 00       		ldy	#0		; can only do this with Y
13511   9270   91 8F       		sta	(SPC),Y		; get the sucker
13512   9272   F0 10       		beq	SBEXI		; jump to end it
13513                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page  201

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13514                      	; this is in aux mem, >$E000
13515                      	;
13516   9274               	SB1:
13517   9274   A4 90       		ldy	SPCH		; get high part
13518   9276   8C 80 92    		sty	SBMOD+2		; and self mod my code
13519   9279   A4 8F       		ldy	SPCL		; and get the low part
13520   927B   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
13521   927E               	SBMOD:
13522   927E   99 00 D0    		sta	Z3BEGIN,Y	; store the little byte
13523   9281   8D 08 C0    		sta	ALTZP+MAIN	; go back to main mem
13524   9284               	SBEXI:
13525   9284   8D 04 C0    		sta	WRTBNK+MAIN	; and write to main
13526   9287   60          		rts
13527                      	;
13528                      	; FETCHB - fetch a byte from either main memory, aux memory, or upper
13529                      	;	Aux memory
13530                      	;
13531   9288               	FETCHB:
13532   9288   A4 8E       		ldy	FPCBNK		; get the bank
13533   928A   30 04       		bmi	FB1		; must be in upper RAM
13534   928C   20 D1 00    		jsr	ZERO_FB		; go to low end fetch
13535   928F   60          		rts
13536                      	;
13537                      	; this is in aux mem, >$E000
13538                      	;
13539   9290               	FB1:
13540   9290   A5 8D       		lda	FPCH		; get which page
13541   9292   8D 9C 92    		sta	FBMOD+2		; and show in operand
13542   9295   A4 8C       		ldy	FPCL		; get which byte
13543   9297   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
13544   929A   B9 00 D0    	FBMOD:	lda	Z3BEGIN,Y	; get the sucker
13545   929D   8D 08 C0    		sta	ALTZP+MAIN	; go back to main mem
13546   92A0   A8          		tay			; set condition code
13547   92A1   60          		rts
13548                      	;
13549                      	; ZFETCH - after checking for which bank (main, aux 1 or aux 2), go get
13550                      	;  the byte @ ZPCPNT, with the offset being in [Y]
13551                      	;
13552   92A2               	ZFETCH:
13553   92A2   A6 85       		ldx	ZPCBNK		; get the bank
13554   92A4   30 04       		bmi	ZFB1		; must be in upper RAM
13555   92A6   20 DC 00    		jsr	ZERO_ZF		; go to low end fetch
13556   92A9   60          		rts
13557                      	;
13558                      	; this is in aux mem, >$D000
13559                      	;
13560   92AA               	ZFB1:
13561   92AA   A5 84       		lda	ZPNTH		; which page are we talking about
13562   92AC   8D B4 92    		sta	ZBMOD+2		; show in the operand
13563   92AF   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
13564   92B2   B9 00 D0    	ZBMOD:	lda	Z3BEGIN,Y	; get the sucker
13565   92B5   8D 08 C0    		sta	ALTZP+MAIN	; go back to main mem
13566   92B8   AA          		tax			; set condition code
13567   92B9   60          		rts
13568                      	;
13569                      	; MFETCH - after checking for which bank (main, aux 1 or aux 2), go get
13570                      	;  the byte @MPCPNT, with the offset being in [Y]
13571                      	;
13572   92BA               	MFETCH:
13573   92BA   A6 8B       		ldx	MPCBNK		; get the bank
13574   92BC   30 04       		bmi	MB1		; must be in upper RAM
13575   92BE   20 E5 00    		jsr	ZERO_MF		; go to low end fetch
13576   92C1   60          		rts
13577                      	;
13578                      	; this is in aux mem, >$D000
13579                      	;
13580   92C2               	MB1:
13581   92C2   A5 8A       		lda	MPNTH		; which page are we talking about
13582   92C4   8D CC 92    		sta	MBMOD+2		; show in the operand
13583   92C7   8D 09 C0    		sta	ALTZP+AUX	; talk about aux mem
13584                      	
13585   92CA   B9 00 D0    	MBMOD:	lda	Z3BEGIN,Y	; get the sucker
13586                      	
13587   92CD   8D 08 C0    		sta	ALTZP+MAIN	; go back to main mem
13588   92D0   AA          		tax			; set condition code
  Tue Jun 13 1989 11:42                                                                                                  Page  202

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13589   92D1   60          		rts
13590                      	
13591                      	
13592   92D2               		END
13593                      	
13594   92D2               		INCLUDE 	ZSTRING.ASM
13595                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page  203

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- MEMORY PAGING ROUTINES ---"

13596   92D2               		STTL "--- Z-STRING HANDLERS ---"
13597                      	
13598                      	; -----------------------
13599                      	; POINT MPC TO ZSTRING IN [I], using SOFF
13600                      	; -----------------------
13601                      	
13602   92D2               	SETSTR:
13603   92D2   A5 78       		lda	I+LO
13604   92D4   85 86       		sta	MPCL		; save in lo part	
13605   92D6   A5 79       		lda	I+HI
13606   92D8   85 87       		sta	MPCM		; middle part
13607   92DA   A9 00       		lda	#0		; clear hi part
13608   92DC   85 88       		sta	MPCH		; okay, we did
13609   92DE   06 86       		asl	MPCL		; *2
13610   92E0   26 87       		rol	MPCM
13611   92E2   26 88       		rol	MPCH
13612   92E4   06 86       		asl	MPCL		; *4
13613   92E6   26 87       		rol	MPCM
13614   92E8   26 88       		rol	MPCH
13615                      	;
13616                      	; now add the offset
13617                      	;
13618   92EA   A5 86       		lda	MPCL		; carry clear from above
13619   92EC   65 60       		adc	SOFFL		; add lo part of offset
13620   92EE   85 86       		sta	MPCL		; save
13621   92F0   A5 87       		lda	MPCM
13622   92F2   65 5F       		adc	SOFFM
13623   92F4   85 87       		sta	MPCM
13624   92F6   A5 88       		lda	MPCH
13625   92F8   65 5E       		adc	SOFFH
13626   92FA   85 88       		sta	MPCH
13627   92FC   4C B2 90    		jmp	VLDMPC		; make MPCPNT to it
13628                      	
13629                      	
13630   92FF   60          	ZSTEX:	RTS		
13631                      	
13632                      	; -----------------------
13633                      	; PRINT Z-STRING AT [MPC]
13634                      	; -----------------------
13635   9300               	PZSTR:
13636   9300   A2 00       	        ldx	#0	
13637   9302   86 96       		stx	PSET	        ; ASSUME PERMANENT CHARSET
13638   9304   86 9A       		stx	ZFLAG	        ; CLEAR BYTE FLAG
13639   9306   CA          		dex		        ; = $FF
13640   9307   86 97       		stx	TSET	        ; NO TEMPSET ACTIVE
13641   9309               	PZTOP:
13642   9309   20 FC 93    	        jsr	GETZCH	        ; GET A Z-CHAR
13643   930C   B0 F1       		bcs	ZSTEX	        ; END OF STRING IF CARRY IS SET
13644   930E   85 98       		sta	ZCHAR	        ; ELSE SAVE CHAR HERE
13645   9310   AA          		tax		        ; SET FLAGS
13646   9311   F0 45       		beq	BLANK	        ; PRINT SPACE IF CHAR = 0
13647   9313   C9 04       		cmp	#4	        ; IS THIS AN F-WORD?
13648   9315   90 5F       		bcc	DOFREQ	        ; APPARENTLY SO
13649   9317   C9 06       		cmp	#6	        ; PERHAPS A SHIFT CODE?
13650   9319   90 41       		bcc	NEWSET	        ; YES, CHANGE CHARSETS
13651   931B   20 DE 93    		jsr	GETSET	        ; ELSE GET CHARSET
13652   931E   AA          		tax		        ; SET FLAGS
13653   931F   D0 14       		bne	SET1	        ; SKIP IF NOT CHARSET #0
13654                      	;
13655                      	; PRINT A LOWER-CASE CHAR (CHARSET #0)
13656                      	;
13657   9321   A9 FA       	        lda     #$FA            ; what to add to get offset into char table
13658   9323               	TOASC:
13659   9323   8D 2A 93    	        sta     TOASCM+1        ; modify code
13660   9326   A5 98       	        lda     ZCHAR           ; use char as offset
13661   9328   18          	        clc                     ; make char be an index
13662   9329   69 06       	TOASCM: adc     #6              ; we just did
13663   932B   AA          	        tax                     ; now use as index
13664   932C   BD 8C 1F    	        lda     CHARSET,X       ; go get that char in charset zero
13665   932F               	SHOVE:
13666   932F   20 F5 52    	        jsr	COUT	        ; SHOW THE CHAR
13667   9332   4C 09 93    		jmp	PZTOP	        ; AND GRAB NEXT CHAR
13668                      	;
13669                      	; PRINT AN UPPER-CASE CHAR (CHARSET #1)
13670                      	;
  Tue Jun 13 1989 11:42                                                                                                  Page  204

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13671   9335               	SET1:
13672   9335   C9 01       	        cmp	#1	        ; make sure it's set #1
13673   9337   D0 04       		bne	SET2	        ; else must be set #2
13674   9339   A9 14       		lda	#20             ; skip into Charset 1 part of table
13675   933B   D0 E6       		bne	TOASC	        ; fix just like the others
13676                      	;
13677                      	; PRINT FROM CHARSET #2
13678                      	;
13679   933D               	SET2:
13680   933D   A5 98       	        lda	ZCHAR	        ; retrieve the z-char
13681   933F   C9 06       	        cmp     #6              ; is it a special ascii char?
13682   9341   F0 04       	        beq     DIRECT          ; yes, so do it special
13683   9343   A9 2E       	        lda     #46             ; nothing special, just get offset
13684   9345   D0 DC       	        bne     TOASC           ; and jump
13685                      	;
13686                      	; DECODE A "DIRECT" ASCII CHAR
13687                      	;
13688   9347               	DIRECT:
13689   9347   20 FC 93    	        jsr	GETZCH	        ; FETCH NEXT Z-CHAR
13690   934A   0A          		asl	A		
13691   934B   0A          		asl	A		
13692   934C   0A          		asl	A		
13693   934D   0A          		asl	A		
13694   934E   0A          		asl	A	        ; SHIFT INTO POSITION
13695   934F   85 98       		sta	ZCHAR	        ; AND SAVE HERE
13696   9351   20 FC 93    		jsr	GETZCH	        ; GRAB YET ANOTHER Z-CHAR
13697   9354   05 98       		ora	ZCHAR	        ; SUPERIMPOSE THE 2ND BYTE
13698   9356   D0 D7       		bne	SHOVE	        ; AND PRINT THE RESULT
13699                      	;
13700                      	; PRINT A SPACE
13701                      	;
13702   9358               	BLANK:
13703   9358   A9 20       	        lda	#SPACE	        ; ASCII SPACE CHAR
13704   935A   D0 D3       		bne	SHOVE	
13705                      	
13706                      		; CHANGE CHARSET
13707                      	
13708   935C   38          	NEWSET:	SEC		; CONVERT THE SHIFT CODE
13709   935D   E9 03       		SBC	#3	; TO 1 OR 2
13710   935F   A8          		TAY		
13711   9360   20 DE 93    		JSR	GETSET	; IS MODE TEMPORARY?
13712   9363   D0 05       		BNE	TOPERM	; YES, DO A PERMSHIFT
13713   9365   84 97       		STY	TSET	; ELSE JUST A TEMPSHIFT
13714   9367   4C 09 93    		JMP	PZTOP	; AND CONTINUE
13715   936A   84 96       	TOPERM:	STY	PSET	; SET PERM CHARSET
13716   936C   C5 96       		CMP	PSET	; SAME AS BEFORE?
13717   936E   F0 99       		BEQ	PZTOP	; YES, CONTINUE
13718   9370   A9 00       		LDA	#0	
13719   9372   85 96       		STA	PSET	; ELSE RESET CHARSET
13720   9374   F0 93       		BEQ	PZTOP	; BEFORE LOOPING BACK
13721                      	
13722                      		; PRINT AN F-WORD
13723                      	
13724   9376   38          	DOFREQ:	SEC		
13725   9377   E9 01       		SBC	#1	; ZERO-ALIGN THE CODE
13726   9379   0A          		ASL	A	; AND MULTIPLY TIMES 64
13727   937A   0A          		ASL	A	; TO OBTAIN THE SEGMENT OFFSET
13728   937B   0A          		ASL	A	; INTO THE F-WORDS TABLE
13729   937C   0A          		ASL	A		
13730   937D   0A          		ASL	A		
13731   937E   0A          		ASL	A		
13732   937F   85 99       		STA	OFFSET	; SAVE OFFSET FOR LATER
13733   9381   20 FC 93    		JSR	GETZCH	; NOW GET THE F-WORD POINTER
13734   9384   0A          		ASL	A	; WORD-ALIGN IT
13735   9385   18          		CLC		; AND
13736   9386   65 99       		ADC	OFFSET	; ADD THE SEGMENT OFFSET
13737                      	;
13738                      	; set up FPC to point to FWORDS table
13739                      	;
13740   9388   A6 57       		ldx	FWORDS+ABANK
13741   938A   86 8E       		stx	FPCBNK
13742   938C   A6 56       		ldx	FWORDS+HI
13743   938E   86 8D       		stx	FPCH
13744   9390   A6 55       		ldx	FWORDS+LO
13745   9392   86 8C       		stx	FPCL
  Tue Jun 13 1989 11:42                                                                                                  Page  205

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13746   9394   20 10 90    		jsr	ADDFPC		; add offset of the F-word
13747   9397   20 88 92    		jsr	FETCHB		; and get MSB of F-word
13748   939A   85 79       		sta	I+HI		; and save it
13749   939C   20 F0 8F    		jsr	NEXTFPC		; and point to LSB
13750   939F   20 88 92    		jsr	FETCHB		; and get it
13751   93A2   85 78       		sta	I+LO		; and save it
13752                      	;
13753                      	; SAVE THE STATE OF CURRENT Z-STRING
13754                      	;
13755   93A4   A5 88       		LDA	MPCH	
13756   93A6   48          		PHA		
13757   93A7   A5 87       		LDA	MPCM	
13758   93A9   48          		PHA		
13759   93AA   A5 86       		LDA	MPCL	
13760   93AC   48          		PHA		
13761   93AD   A5 96       		LDA	PSET	
13762   93AF   48          		PHA		
13763   93B0   A5 9A       		LDA	ZFLAG	
13764   93B2   48          		PHA		
13765   93B3   A5 9C       		LDA	ZWORD+HI	
13766   93B5   48          		PHA		
13767   93B6   A5 9B       		LDA	ZWORD+LO	
13768   93B8   48          		PHA		
13769   93B9   20 EA 93    		JSR	SETFWD	; PRINT THE Z-STRING
13770   93BC   20 00 93    		JSR	PZSTR	; IN [I]
13771                      	;
13772                      	; RESTORE OLD Z-STRING
13773                      	;
13774   93BF   68          		PLA		
13775   93C0   85 9B       		STA	ZWORD+LO	
13776   93C2   68          		PLA		
13777   93C3   85 9C       		STA	ZWORD+HI	
13778   93C5   68          		PLA		
13779   93C6   85 9A       		STA	ZFLAG	
13780   93C8   68          		PLA		
13781   93C9   85 96       		STA	PSET	
13782   93CB   68          		PLA		
13783   93CC   85 86       		STA	MPCL	
13784   93CE   68          		PLA		
13785   93CF   85 87       		STA	MPCM	
13786   93D1   68          		PLA		
13787   93D2   85 88       		STA	MPCH	
13788   93D4   A2 FF       		LDX	#$FF	
13789   93D6   86 97       		STX	TSET	; DISABLE TEMP CHARSET
13790   93D8   20 B2 90    		JSR	VLDMPC	
13791   93DB   4C 09 93    		JMP	PZTOP	; CONTINUE INNOCENTLY
13792                      	
13793                      	
13794                      	; ----------------------
13795                      	; RETURN CURRENT CHARSET
13796                      	; ----------------------
13797                      	
13798   93DE   A5 97       	GETSET:	LDA	TSET	
13799   93E0   10 03       		BPL	GS	
13800   93E2   A5 96       		LDA	PSET	
13801   93E4   60          		RTS		
13802   93E5   A0 FF       	GS:	LDY	#$FF	
13803   93E7   84 97       		STY	TSET	
13804   93E9   60          		RTS		
13805                      	
13806                      	
13807                      	; -------------------------
13808                      	; POINT [I] AT FWORD STRING
13809                      	; -------------------------
13810                      	
13811   93EA   A5 78       	SETFWD:	LDA	I+LO	; WORD-ALIGN THE ADDRESS
13812   93EC   0A          		ASL	A		
13813   93ED   85 86       		STA	MPCL	
13814   93EF   A5 79       		LDA	I+HI	
13815   93F1   2A          		ROL	A		
13816   93F2   85 87       		STA	MPCM	
13817   93F4   A9 00       		LDA	#0	
13818   93F6   2A          		ROL	A		
13819   93F7   85 88       		STA	MPCH	
13820   93F9   4C B2 90    		JMP	VLDMPC	
  Tue Jun 13 1989 11:42                                                                                                  Page  206

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13821                      	
13822                      	
13823                      	; -----------------
13824                      	; FETCH NEXT Z-CHAR
13825                      	; -----------------
13826                      	
13827   93FC   A5 9A       	GETZCH:	LDA	ZFLAG	; WHICH BYTE IS THIS?
13828   93FE   10 02       		BPL	GTZ0	; $FF = LAST
13829   9400   38          		SEC		; SET CARRY TO INDICATE
13830   9401   60          		RTS		; NO MORE CHARS
13831   9402   D0 13       	GTZ0:	BNE	GETZ1	; NOT FIRST CHAR, EITHER
13832                      	
13833                      		; GET A Z-WORD INTO [ZWORD], RETURN 1ST CHAR IN TRIPLET
13834                      	
13835   9404   E6 9A       		INC	ZFLAG	; UPDATE CHAR COUNT
13836   9406   20 3B 92    		JSR	GETBYT	; GET TRIPLET AT [MPC]
13837   9409   85 9C       		STA	ZWORD+HI	; INTO [ZWORD]
13838   940B   20 3B 92    		JSR	GETBYT	
13839   940E   85 9B       		STA	ZWORD+LO	
13840   9410   A5 9C       		LDA	ZWORD+HI	
13841   9412   4A          		LSR	A		
13842   9413   4A          		LSR	A	; SHIFT 1ST CHAR INTO PLACE
13843   9414   4C 40 94    		JMP	GTEXIT	; AND RETURN IT
13844   9417   38          	GETZ1:	SEC		
13845   9418   E9 01       		SBC	#1	
13846   941A   D0 16       		BNE	GETZ2	; LAST CHAR IN TRIPLET IF ZERO
13847   941C   A9 02       		LDA	#2	; ELSE
13848   941E   85 9A       		STA	ZFLAG	; RESET CHAR INDEX
13849   9420   A5 9B       		LDA	ZWORD+LO	; GET BOTTOM HALF OF TRIPLET
13850   9422   85 78       		STA	I+LO	; MOVE HERE FOR SHIFTING
13851   9424   A5 9C       		LDA	ZWORD+HI	; GET TOP HALF
13852   9426   06 78       		ASL	I+LO	; SHIFT THE TOP 3 BITS OF LOWER HALF
13853   9428   2A          		ROL	A	; INTO THE BOTTOM OF THE TOP HALF
13854   9429   06 78       		ASL	I+LO	
13855   942B   2A          		ROL	A		
13856   942C   06 78       		ASL	I+LO	
13857   942E   2A          		ROL	A		
13858   942F   4C 40 94    		JMP	GTEXIT	
13859   9432   A9 00       	GETZ2:	LDA	#0	; SET FLAG TO INDICATE
13860   9434   85 9A       		STA	ZFLAG	; END OF TRIPLET
13861   9436   A5 9C       		LDA	ZWORD+HI	; TEST TOP HALF OF TRIPLET
13862   9438   10 04       		BPL	GETZ3	; CONTINUE IF NOT END OF STRING
13863   943A   A9 FF       		LDA	#$FF	; ELSE
13864   943C   85 9A       		STA	ZFLAG	; INDICATE LAST TRIPLET IN STRING
13865   943E   A5 9B       	GETZ3:	LDA	ZWORD+LO	; GET BOTTOM HALF OF TRIPLET
13866   9440   29 1F       	GTEXIT:	AND	#%00011111	; MASK OUT GARBAGE BITS
13867   9442   18          		CLC		
13868   9443   60          		RTS		
13869                      	
13870                      	
13871                      	; ---------------------------------
13872                      	; CONVERT [IN] TO Z-STRING IN [OUT]
13873                      	; ---------------------------------
13874   9444               	CONZST:
13875   9444   A9 05       	        lda	#5	        ; FILL OUTPUT BUFFER
13876   9446   A2 08       		ldx	#8	        ; WITH PAD CHARS ($05)
13877   9448               	CZSL:
13878   9448   9D C7 6C    	        sta	OUT,X	
13879   944B   CA          		dex		
13880   944C   10 FA       		bpl	CZSL	
13881                      	
13882   944E   A9 09       		lda	#9	        ; INIT
13883   9450   85 9D       		sta	CONCNT	        ; CHAR COUNT
13884   9452   A9 00       		lda	#0	        ; CLEAR
13885   9454   85 9E       		sta	CONIN	        ; SOURCE AND
13886   9456   85 9F       		sta	CONOUT	        ; OUTPUT INDEXES
13887   9458               	CONTOP:
13888   9458   A6 9E       	        ldx	CONIN	        ; fetch source index
13889   945A   E6 9E       		inc	CONIN	        ; and update
13890   945C   BD BE 6C    		lda	IN,X	        ; grab an ascii char
13891   945F   85 98       		sta	ZCHAR	        ; save it here
13892   9461   D0 04       		bne	NEXTZ	        ; continue if char was nz
13893   9463   A9 05       		lda	#5	        ; else ship out
13894   9465   D0 27       		bne	CSHIP1	        ; a pad char
13895   9467               	NEXTZ:
  Tue Jun 13 1989 11:42                                                                                                  Page  207

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13896   9467   20 93 94    	        jsr     FINDCHAR        ; find out where it tis
13897   946A   F0 21       	        beq     CSHIP           ; no shift for charset zero
13898   946C   18          		clc		        ; else do a temp-shift
13899   946D   69 03       		adc	#3	        ; 4 = charset 1, 5 = charset 2
13900   946F   20 C1 94    	        jsr     CSTASH          ; save the char in outbuf
13901   9472   C9 05       	        cmp     #5              ; charset 2?
13902   9474   D0 17       	        bne     CSHIP           ; nope
13903   9476   E0 06       	        cpx     #6              ; ascii escape?
13904   9478   D0 13       	        bne     CSHIP           ; nope
13905                      	;
13906                      	; Handle special Ascii escape sequence
13907                      	;
13908   947A   8A          	        txa                     ; get ASCII alert char (#6)        
13909   947B   20 C1 94    	        jsr     CSTASH          ; shove it away
13910                      	;
13911                      	; do 1st half of "direct"
13912                      	;
13913   947E   A5 98       		lda	ZCHAR           ; re-fetch char        
13914   9480   4A          		lsr	A               ; get upper 2 bits in lower 2 bits
13915   9481   4A          		lsr	A
13916   9482   4A          		lsr	A
13917   9483   4A          		lsr	A
13918   9484   4A          		lsr	A
13919   9485   20 C1 94    	        jsr     CSTASH
13920                      	;
13921                      	; SEND 2ND HALF OF "DIRECT"
13922                      	;
13923   9488   A5 98       		lda	ZCHAR	        ; get char yet again
13924   948A   29 1F       		and	#%00011111	; and get lower 5 bits
13925   948C   AA          	        tax                     ; this is where it is expected
13926                      	;
13927                      	; SHIP Z-CHAR TO OUTPUT BUFFER
13928                      	;
13929   948D               	CSHIP:
13930   948D   8A          	        txa                     ; get char
13931   948E               	CSHIP1:
13932   948E   20 C1 94    	        jsr     CSTASH          ; put char away
13933   9491   D0 C5       	        bne     CONTOP          ; do again
13934                      	;
13935                      	; FINDCHAR - look through the charset table for the character.  If found,
13936                      	;       figger out which shift it is.  If not found, return charset 2, 
13937                      	;       character #6.
13938                      	;  Enter:
13939                      	;       [A] = Char we are looking for
13940                      	;  Returns:
13941                      	;       [A] = Charset (0-2)
13942                      	;       [X] = Character # (6-31)
13943                      	;
13944   9493               	FINDCHAR:
13945   9493   A2 00       	        ldx     #0              ; start at first char, first set
13946   9495   A0 4E       	        ldy     #78             ; there are 78 characters
13947   9497               	FNDCL:
13948   9497   DD 8C 1F    	        cmp     CHARSET,X       ; found it?
13949   949A   F0 09       	        beq     FNDCLX          ; yes
13950   949C   E8          	        inx                     ; next char
13951   949D   88          	        dey                     ; count char
13952   949E   D0 F7       	        bne     FNDCL           ; go check next char
13953                      	;
13954                      	; not found in table, use ASCII escape sequence
13955                      	;
13956   94A0   A9 02       	        lda     #2              ; escape sequence is char set 2
13957   94A2   A2 06       	        ldx     #6              ; character 6
13958   94A4   60          	        rts                     ; and done
13959   94A5               	FNDCLX:
13960   94A5   8A          	        txa                     ; put here for compares/action
13961   94A6   A0 00       	        ldy     #0              ; this is char set 0
13962   94A8   A2 FA       	        ldx     #$FA            ; what to "subtract" to get +6
13963   94AA   C9 1A       	        cmp     #26             ; how we doin'?
13964   94AC   90 0A       	        bcc     FNDCHX          ; all done
13965   94AE   C8          	        iny                     ; char set 1
13966   94AF   A2 14       	        ldx     #20             ; char set 1 offset
13967   94B1   C9 34       	        cmp     #52             ; well?
13968   94B3   90 03       	        bcc    FNDCHX           ; must be char set 1
13969   94B5   A2 2E       	        ldx     #46             ; for char set 2 setting up
13970   94B7   C8          	        iny                     ; must be char set 2 then
  Tue Jun 13 1989 11:42                                                                                                  Page  208

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- Z-STRING HANDLERS ---"

13971   94B8               	FNDCHX:
13972   94B8   8E BD 94    	        stx     FNDCHM+1        ; what to subtract to get offset
13973   94BB   38          	        sec                     ; doing subtract
13974   94BC   E9 06       	FNDCHM: sbc     #6              ; make good offset
13975   94BE   AA          	        tax                     ; put here for return
13976   94BF   98          	        tya                     ; and here to set flag
13977   94C0   60          	        rts
13978                      	;
13979                      	; CSTASH - put the char in OUT.  If we run out of room don't return, just
13980                      	;       jump to ZCRUSH as final destination
13981                      	;   [A] - char to be put away
13982                      	;
13983   94C1               	CSTASH:
13984   94C1   A4 9F       		ldy	CONOUT	        ; fetch output index
13985   94C3   99 C7 6C    		sta	OUT,Y	        ; send the shift char
13986   94C6   E6 9F       		inc	CONOUT	        ; update index
13987   94C8   C6 9D       		dec	CONCNT	        ; and char count
13988   94CA   D0 05       		bne	CSTX            ; plenty more room
13989   94CC   68          	        pla                     ; get rid of return spot
13990   94CD   68          	        pla                     ; fine
13991   94CE   4C D2 94    		jmp	ZCRUSH	        ; if out of room, crush 'em!
13992   94D1               	CSTX:
13993   94D1   60          	        rts
13994                      	; ----------------------
13995                      	; CRUSH Z-CHARS IN [OUT], mushing them into small 5 bit pieces
13996                      	; ----------------------
13997   94D2               	ZCRUSH:
13998   94D2   AD C8 6C    	        LDA	OUT+1	        ; GET 2ND Z-CHAR
13999   94D5   0A          		ASL	A	        ; SHIFT BITS INTO POSITION
14000   94D6   0A          		ASL	A		
14001   94D7   0A          		ASL	A		
14002   94D8   0A          		ASL	A		
14003   94D9   2E C7 6C    		ROL	OUT	        ; ALONG WITH 1ST Z-CHAR
14004   94DC   0A          		ASL	A		
14005   94DD   2E C7 6C    		ROL	OUT	
14006   94E0   0D C9 6C    		ORA	OUT+2	        ; SUPERIMPOSE 3RD Z-CHAR
14007   94E3   8D C8 6C    		STA	OUT+1	
14008   94E6   AD CB 6C    		LDA	OUT+4	        ; GET 5TH Z-CHAR
14009   94E9   0A          		ASL	A	        ; SHIFT BITS
14010   94EA   0A          		ASL	A		
14011   94EB   0A          		ASL	A		
14012   94EC   0A          		ASL	A		
14013   94ED   2E CA 6C    		ROL	OUT+3	        ; ALONG WITH 4TH Z-CHAR
14014   94F0   0A          		ASL	A		
14015   94F1   2E CA 6C    		ROL	OUT+3	
14016   94F4   0D CC 6C    		ORA	OUT+5	        ; SUPERIMPOSE 6TH Z-CHAR
14017   94F7   AA          		TAX		        ; SAVE HERE
14018   94F8   AD CA 6C    		LDA	OUT+3	        ; GRAB 4TH Z-CHAR
14019   94FB   8D C9 6C    		STA	OUT+2	        ; MOVE CRUSHED Z-WORD
14020   94FE   8E CA 6C    		STX	OUT+3	        ; INTO PLACE
14021   9501   AD CE 6C    		LDA	OUT+7	        ; GET 8TH Z-CHAR (EZIP)
14022   9504   0A          		ASL	A	        ; SHIFT BITS
14023   9505   0A          		ASL	A		
14024   9506   0A          		ASL	A		
14025   9507   0A          		ASL	A		
14026   9508   2E CD 6C    		ROL	OUT+6	        ; ALONG WITH 7TH Z-CHAR
14027   950B   0A          		ASL	A		
14028   950C   2E CD 6C    		ROL	OUT+6	
14029   950F   0D CF 6C    		ORA	OUT+8	        ; SUPERIMPOSE 9TH Z-CHAR
14030   9512   8D CC 6C    		STA	OUT+5	        ; SAVE HERE
14031   9515   AD CD 6C    		LDA	OUT+6	        ; GRAB 7TH Z-CHAR
14032   9518   09 80       		ORA	#%10000000	; SET HIGH BIT
14033   951A   8D CB 6C    		STA	OUT+4	        ; MOVE CRUSHED Z-WORD INTO PLACE
14034   951D   60          		RTS		
14035                      	
14036   951E               		END
14037                      	
14038   951E               		INCLUDE 	OBJECTS.ASM
14039   951E               		STTL "--- OBJECT & PROPERTY HANDLERS ---"
14040                      		PAGE	
  Tue Jun 13 1989 11:42                                                                                                  Page  209

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- OBJECT & PROPERTY HANDLERS ---"

14041                      	
14042                      	; ----------------------------------
14043                      	; GET ABSOLUTE ADDRESS OF OBJECT [A]
14044                      	; ----------------------------------
14045                      	; ENTER: OBJECT IN A/X (LO/HI)
14046                      	; EXIT: ADDRESS IN [FPC]
14047   951E               	OBJLOC:
14048   951E   86 79       		STX	I+HI		; SAVE MSB FOR SHIFTING
14049   9520   0A          		ASL	A		; MULTIPLY BY LENGTH OF AN ENTRY (14)
14050   9521   85 78       		STA	I+LO	
14051   9523   26 79       		ROL	I+HI	
14052   9525   A6 79       		LDX	I+HI	
14053   9527   0A          		ASL	A		
14054   9528   26 79       		ROL	I+HI	; *4
14055   952A   0A          		ASL	A		
14056   952B   26 79       		ROL	I+HI	; *8
14057   952D   0A          		ASL	A		
14058   952E   26 79       		ROL	I+HI	; *16
14059   9530   38          		SEC		
14060   9531   E5 78       		SBC	I+LO	; -(*2)
14061   9533   85 78       		STA	I+LO	; SO IS *14 TOTAL
14062   9535   A5 79       		LDA	I+HI	
14063   9537   86 79       		STX	I+HI	
14064   9539   E5 79       		SBC	I+HI	
14065   953B   85 79       		STA	I+HI	
14066   953D   A5 78       		LDA	I+LO	
14067   953F   18          		CLC		
14068   9540   69 70       		ADC	#112		; ADD OBJECT TABLE OFFSET
14069   9542   90 02       		BCC	OBJ3	
14070   9544   E6 79       		INC	I+HI	
14071   9546               	OBJ3:
14072   9546   18          		clc			; NEXT ADD THE relative ADDR
14073   9547   6D 0B 96    		adc	ZBEGIN+ZOBJEC+1	; OF THE OBJECT TABLE
14074   954A   85 8C       		sta	FPCL		; save lo byte
14075   954C   A5 79       		lda	I+HI	
14076   954E   6D 0A 96    		adc	ZBEGIN+ZOBJEC	; now work on page
14077   9551   20 A9 8F    		jsr	SETPC		; now get page/bank
14078   9554   85 8D       		sta	FPCH		; this is hi part
14079   9556   84 8E       		sty	FPCBNK		; and this is the bank
14080   9558   60          		rts
14081                      	; -----------------------------
14082                      	; GET ADDRESS OF PROPERTY TABLE
14083                      	; -----------------------------
14084                      	; EXIT: [FPC] HAS ABSOLUTE ADDR OF PROPERTY TABLE
14085                      	;		including OFFSET TO START OF PROP IDS
14086   9559               	PROPB:
14087   9559   A5 63       		lda	ARG1+LO	
14088   955B   A6 64       		ldx	ARG1+HI	; get address
14089   955D   20 1E 95    		jsr	OBJLOC	; put table location into FPC
14090   9560   A9 0C       		lda	#12	; add 12 to get to beginning
14091   9562   20 10 90    		jsr	ADDFPC	; and add it to FPC
14092   9565   20 88 92    		jsr	FETCHB	; get MSB of P-TABLE Address
14093   9568   48          		pha		; and save it for a moment
14094   9569   20 F0 8F    		jsr	NEXTFPC	; to get LSB
14095   956C   20 88 92    		jsr	FETCHB	; get LSB of P-TABLE Address
14096   956F   85 8C       		sta	FPCL	; and save lo part
14097   9571   68          		pla		; get page back
14098   9572   20 A9 8F    		jsr	SETPC	; and set up memory bank/page
14099   9575   85 8D       		sta	FPCH	; save page
14100   9577   84 8E       		sty	FPCBNK	; and bank
14101   9579   20 88 92    		jsr	FETCHB	; get length of short description
14102   957C   0A          		asl	A	; WORD-ALIGN IT
14103   957D   20 10 90    		jsr	ADDFPC	; and add it to FPC
14104   9580   20 F0 8F    		jsr	NEXTFPC	; POINT JUST PAST THE DESCRIPTION
14105   9583   60          		rts
14106                      	
14107                      	
14108                      	; -------------------
14109                      	; FETCH A PROPERTY ID
14110                      	; -------------------
14111                      	; ENTRY: LIKE "PROPB" EXIT (i.e. - address in FPC)
14112                      	;
14113   9584               	PROPN:
14114   9584   20 88 92    		jsr	FETCHB		; get the byte
14115   9587   29 3F       		and	#%00111111	; MASK OUT LENGTH BITS (EZIP)
  Tue Jun 13 1989 11:42                                                                                                  Page  210

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- OBJECT & PROPERTY HANDLERS ---"

14116   9589   60          		rts		
14117                      	
14118                      	; -------------------------------
14119                      	; FETCH # BYTES IN PROPERTY VALUE
14120                      	; -------------------------------
14121                      	; ENTRY: LIKE "PROPB" EXIT (i.e. - address in FPC)
14122                      	;
14123   958A               	PROPL:
14124   958A   20 88 92    		jsr	FETCHB		; CHECK LENGTH FLAGS
14125   958D   AA          		tax			; save it
14126   958E   10 09       		bpl	SHORT		; OFF, SO 1 OR 2 BYTES
14127   9590   20 F0 8F    		jsr	NEXTFPC
14128   9593   20 88 92    		jsr	FETCHB		; NEXT BYTE HAS LENGTH
14129   9596   29 3F       		and	#%00111111	; MASK OFF EXTRA BITS
14130   9598   60          		rts		
14131   9599               	SHORT:
14132   9599   29 40       		and	#%01000000	; BIT 6
14133   959B   F0 03       		beq	ONE	
14134   959D   A9 02       		lda	#2		; BIT 6 = 1, LENGTH =2
14135   959F   60          		rts		
14136   95A0               	ONE:
14137   95A0   A9 01       		lda	#1		; BIT 6 = 0, LENGTH =1
14138   95A2   60          		rts		
14139                      	
14140                      	; ----------------------
14141                      	; POINT TO NEXT PROPERTY
14142                      	; ----------------------
14143                      	; ENTRY: LIKE "PROPB" EXIT (i.e. - in [FPC])
14144                      	;
14145   95A3               	PROPNX:
14146   95A3   20 8A 95    		jsr	PROPL	; GET LENGTH OF CURRENT PROP
14147   95A6   A8          		tay		; move one more for correct alignment
14148   95A7   C8          		iny		; okay, done it
14149   95A8   98          		tya		; thanks
14150   95A9   20 10 90    		jsr	ADDFPC	; add to [FPC]
14151   95AC   60          		rts
14152                      	;
14153                      	; ----------------
14154                      	; GET OBJECT FLAGS
14155                      	; ----------------
14156                      	; ENTRY: OBJECT # IN [ARG1], FLAG # IN [ARG2]
14157                      	; EXIT: FLAG WORD IN [K], BIT ID IN [J],
14158                      	; FLAG WORD ADDRESS IN [FPC]
14159                      	;
14160   95AD               	FLAGSU:
14161   95AD   A5 63       		LDA	ARG1+LO	; get table offset
14162   95AF   A6 64       		LDX	ARG1+HI	
14163   95B1   20 1E 95    		JSR	OBJLOC	; GET OBJECT ADDR IN [FPC]
14164   95B4   A5 65       		LDA	ARG2+LO	; LOOK AT FLAG ID
14165   95B6   C9 10       		CMP	#$10	; FIRST SET OF FLAGS?
14166   95B8   90 14       		BCC	FLS1	; YES, ADDR IN [FPC] IS CORRECT
14167   95BA   E9 10       		SBC	#16	; ELSE ZERO-ALIGN FLAG INDEX
14168   95BC   AA          		TAX		; SAVE IT HERE
14169   95BD   C9 10       		CMP	#$10	; CHECK IF IN 2ND WORD
14170   95BF   90 07       		BCC	FLS	; YES, GO ALIGN FOR THAT
14171   95C1   E9 10       		SBC	#16	; ELSE ALIGN TO 3RD WORD
14172   95C3   AA          		TAX		
14173   95C4   A9 04       		lda	#4	; 3rd Flag word
14174   95C6   D0 02       		bne	FLSx	; and add it in
14175   95C8               	FLS:
14176   95C8   A9 02       		lda	#2	; 2nd Flag word
14177   95CA               	FLSx:
14178   95CA   20 10 90    		jsr	ADDFPC
14179   95CD               	FLS0:
14180   95CD   8A          		TXA		; RESTORE INDEX
14181   95CE               	FLS1:
14182   95CE   85 7C       		STA	K+LO	; SAVE FLAG ID HERE
14183   95D0   A2 01       		LDX	#1	; INIT THE
14184   95D2   86 7A       		STX	J+LO	; FLAG WORD TO
14185   95D4   CA          		DEX		; $0001
14186   95D5   86 7B       		STX	J+HI	
14187   95D7   A9 0F       		LDA	#15	; SUBTRACT THE BIT POSITION
14188   95D9   38          		SEC		; FROM 15
14189   95DA   E5 7C       		SBC	K+LO	; TO GET THE SHIFT LOOP
14190   95DC   AA          		TAX		; INDEX
  Tue Jun 13 1989 11:42                                                                                                  Page  211

        "APPLE YZIP (c)Infocom, Inc.. --- OP SUPPORT & MEMORY MANAGEMENT"
        "--- OBJECT & PROPERTY HANDLERS ---"

14191   95DD   F0 07       		BEQ	FLS2	; EXIT NOW IF NO SHIFT NEEDED
14192   95DF   06 7A       	FLSL:	ASL	J+LO	; SHIFT THE BIT
14193   95E1   26 7B       		ROL	J+HI	; INTO POSITION
14194   95E3   CA          		DEX		
14195   95E4   D0 F9       		BNE	FLSL	
14196   95E6               	FLS2:
14197   95E6   20 88 92    		jsr	FETCHB	; MOVE THE FLAG WORD
14198   95E9   85 7D       		sta	K+HI	; INTO [K] - FIRST THE MSB
14199   95EB   20 F0 8F    		jsr	NEXTFPC	; and then get get LSB
14200   95EE   20 88 92    		jsr	FETCHB
14201   95F1   85 7C       		sta	K+LO	; THEN THE LSB
14202   95F3   4C 56 90    		jmp	PREVFPC	; point back to flag word
14203                      	
14204   95F6               		END
14205                      	
14206                      	
14207   95F6               		BLKB	ZBEGIN-$,0
14208   9600               		END



           Lines Assembled :  14208             Assembly Errors :  0


