	PAGE
	SBTTL "--- MACHINE-DEPENDENT I/O: APPLE II ---"

	; ----------------------------
	; FETCH ASCII KEYCODE INTO [A]
	; ----------------------------

	; EXIT: ASCII IN [A] & [IOCHAR]

GETKEY:	CLD
	TXA			; SAVE [X] & [Y]
	PHA
	TYA
	PHA

GKEY0:	LDA	COL80		; ** THIS IS A TEMPORARY, CHEATER'S **
	BEQ	GKEY1		; ** PATCH THAT MUST BE MADE INTO   **
	LDA	EH		; ** A SENSIBLE SOLUTION AT THE     **
	STA	CH		; ** FIRST OPORTUNITY               **

GKEY1:	JSR	RDKEY		; GET A CHAR

	;CHECK TO MAKE SURE KEY IS VALID, ONLY ACCEPT IT IF IT IS

	AND #$7F		;SCREEN OUT SHIFTS
	CMP #EOL		;CHECK FOR GOOD (BAD) CHAR
	BNE GK1
	JMP OK
GK1:	CMP #BACKSP
	BNE GK2
	JMP OK
GK2:	CMP #ARROW
	BNE GK3
	JMP OK
GK3:	CMP #SPACE		;NO CTRL CHARS WANTED
	BCC BADKEY		;IF < SPACE, BAD
	CMP #$2B		;CLEAR OUT UNWANTED KEYS
	BEQ BADKEY

	CMP #$3C		;CHANGE <_>)@%^&*( TO ,-.0256789
	BNE B			;EXCHANGE THESE TO ELIMINATE 
	LDA #$2C		;UNWANTED VALUES
	BNE OK			;JMP
B:	CMP #$5F
	BNE C
	LDA #$2D
	BNE OK			;JMP
C:	CMP #$3E
	BNE D
	LDA #$2E
	BNE OK			;JMP
D:	CMP #$29
	BNE E
	LDA #$30
	BNE OK			;JMP
E:	CMP #$40
	BNE F
	LDA #$32
	BNE OK			;JMP
F:	CMP #$25
	BNE G
	LDA #$35
	BNE OK			;JMP
G:	CMP #$5E
	BNE H
	LDA #$36
	BNE OK			;JMP
H:	CMP #$26
	BNE L
	LDA #$37
	BNE OK			;JMP
L:	CMP #$2A
	BNE M
	LDA #$38
	BNE OK			;JMP
M:	CMP #$28
	BNE N
	LDA #$39
	BNE OK			;JMP

N:	CMP #$3C
	BCC OK
	CMP #$3F
	BEQ OK

MASK0:	CMP #'z'+1		;PICK OUT LETTERS NOW
	BCS BADKEY		;IF > BAD
	CMP #'a'
	BCS OK			;IF > OK
	CMP #'A'
	BCC BADKEY
	CMP #'Z'+1
	BCC OK			;IF < OK

BADKEY:	JSR BOOP		;BAD KEY, GIVE WARNING NOISE
	JMP GKEY0		;TRY AGAIN

OK:	STA IOCHAR		;HOLD ON TO IT

	ADC RNUM1		;FUTZ WITH RANDOM
	STA RNUM1
	EOR RNUM2
	STA RNUM2

	PLA			; RESTORE
	TAY			; EVERYTHING
	PLA
	TAX
	LDA	IOCHAR		; GET CHAR INTO [A]
	RTS			; AND RETURN IT


	; -----------------
	; PRINT CHAR IN [A]
	; -----------------

CHAR:	STA	IOCHAR		; SAVE HERE
	TXA			; SAVE [X] AND [Y]
	PHA
	TYA
	PHA

	LDA IOCHAR
	CMP #$60
	BCC CHAR1		;LESS THAN a
	CMP #$80
	BCS CHAR1		;GREATER THAN z
	LDX COL80
	BNE CHAR1		;ONLY CONVERT IF 40 COLUMN
	AND #%11011111		;STRIP LOWER CASE BIT

CHAR1:	ORA #%10000000		;SET BIT 7 SO WILL BE NORMAL IF WANTED
	JSR MCOUT

	PLA			; RESTORE [X] AND [Y]
	TAY
	PLA
	TAX
	RTS

	; ---------------------
	; FETCH A LINE OF INPUT
	; ---------------------

	; ENTRY: ABS ADDR OF READ BUFFER IN [ARG1]
	; EXIT: # CHARS READ IN [A]

INPUT:	JSR	LINOUT		; FLUSH [LBUFF]

	LDY 	WTOP
	STY	LINCNT		; RESET LINE COUNT
	INC	LINCNT		; 1 FOR THIS LINE
	LDY	#0		; AND CHAR COUNT

INLOOP:	JSR	GETKEY		; GET ASCII INTO [A] AND [IOCHAR]

	CMP	#EOL		; EOL?
	BEQ	ENDLIN		; LINE DONE IF SO
	CMP	#BACKSP		; BACKSPACE?
	BEQ	BACKUP		; SPECIAL HANDLING
	CMP	#ARROW		; LEFT ARROW (BACKSPACE)?
	BEQ	BACKUP

	STA	LBUFF,Y		; ELSE ADD CHAR TO INPUT BUFFER
	INY			; NEXT POSITION IN LINE

SHOWIT:	JSR	CHAR		; SEND TO SCREEN

	CPY	#77		; 2 SCREEN LINES FULL?
	BCC	INLOOP		; NO, GET ANOTHER CHAR

	; HANDLE LINE OVERFLOW

NOMORE:	JSR	GETKEY
	CMP	#EOL		; IF EOL,
	BEQ	ENDLIN		; WRAP UP THE LINE
	CMP	#BACKSP		; BACKSPACE
	BEQ	BACKUP		; IS OKAY TOO
	CMP	#ARROW		; BACKSPACE
	BEQ	BACKUP
	JSR	BOOP		; ELSE COMPLAIN
	JMP	NOMORE		; AND INSIST

	; HANDLE BACKSPACE

BACKUP:	DEY			; BACK UP THE POINTER
	BMI	BBAD
	LDA	#$08		;BACKSP STRANGE SO DO 082008
	JSR	CHAR
	LDA	#$20
	JSR	CHAR
	LDA	#$08
	BNE	SHOWIT		;JMP

BBAD:	JSR	BOOP		; ELSE SCREAM WITH PAIN
	LDY	#0		; RESET POINTER
	BEQ	INLOOP		; AND WAIT FOR SOMETHING BETTER

	; HANDLE END OF LINE

ENDLIN:	LDA	#$8D		; (MUST BE $8D FOR PRINTER  Le 5/8/85)
	STA	LBUFF,Y		; SHIP EOL TO BUFFER
	INY			; UPDATE INDEX
	STY	LINLEN		; SAVE HERE FOR "READ"
	STY	PRLEN		; AND HERE FOR "PPRINT"

	JSR	CHAR		; AND SEND EOL TO SCREEN

	; MOVE [LBUFF] TO [ARG1] W/LC CONVERSION

LEX0:	LDA	LBUFF-1,Y	; GET A CHAR FROM [LBUFF]

LEX1:	CMP	#'A'		; IF CHAR IS ALPHA,
	BCC	LEX2		; CONVERT TO LOWER CASE
	CMP	#'Z'+1
	BCS	LEX2
	ADC	#$20

LEX2:	STA	(ARG1),Y	; MOVE CHAR TO INPUT BUFFER AT [ARG1]
	DEY			; LOOP TILL
	BPL	LEX0		; ALL CHARS MOVED

	JSR	PPRINT		; SCRIPT [LBUFF] IF ENABLED

	LDA	LINLEN		; RESTORE # CHARS

	LDX	COL80
	BNE	LEX3		; 80 COL.
	CMP	#40
	BCC	LEX3
	INC	LINCNT		; USED 2 LINES

LEX3:	RTS			; INTO [A]

	; -----------------------
	; DIRECT PRINT LINE [X/A]
	; -----------------------

	; ENTRY: STRING ADDRESS IN [X/A] (LSB/MSB)
	;        STRING LENGTH IN [Y]

DLINE:	STX	STRING+LO	; DROP STRING ADDRESS
	STA	STRING+HI	; INTO DUMMY BYTES

	LDX	#0		; INIT CHAR-FETCH INDEX

DOUT:	DB	$BD		; 6502 "LDA nnnn,X" OPCODE
STRING:	DW	$0000		; DUMMY OPERAND BYTES

	JSR	CHAR
	INX
	DEY			; LOOP TILL
	BNE	DOUT		; OUT OF CHARS
	RTS


	; -----------------------
	; SEND [LBUFF] TO PRINTER
	; -----------------------

	; ENTRY: LENTH OF LINE IN [PRLEN]

PLEAV:	RTS

PPRINT:	LDA	SCRIPT		; SCRIPTING INTERNALLY ENABLED?
	BEQ	PLEAV		; NO, SCRAM IMMEDIATELY

	LDA	ZBEGIN+ZSCRIP+1	; CHECK SCRIPT FLAG
	AND	#%00000001	; SCRIPTING ON?
	BEQ	PLEAV		; NO, EXIT

	LDA CSW+LO		;SAVE NORMAL OUTPUT HOOK
	PHA
	LDA CSW+HI
	PHA

	LDA CH			;SAVE CURRENT CURSOR POSITION
	PHA
	LDA EH			; IF 80 COL
	PHA

	LDA ALTCSW+LO    	;LOAD SCRIPTING HOOK
	STA CSW+LO
	LDA ALTCSW+HI
	STA CSW+HI

	LDA #0
	STA CH
	STA EH

PP4:	LDY	#0
PP5:   	LDA	LBUFF,Y		;GET A CHAR TO SEND OUT
	JSR	MCOUT
	INY
	DEC	PRLEN		;LINE COUNT
	BNE	PP5   		;PRINT WHOLE LINE

	;ALL DONE, RESET TO NORMAL AND LEAVE

	PLA			;RETRIEVE CURRENT CURSOR POSITION
	STA EH
	PLA
	STA CH
	PLA
	STA CSW+HI
	PLA
	STA CSW+LO

PEX:	RTS


SLOTM:	DB	EOL
	DB	"Printer Slot 1-7: "
SLOTML	EQU	$-SLOTM

PSTAT:	DB	0	;SET TO CLEAR WHEN BOOT,
			;I PUT IT HERE SO RESTART WON'T ALTER
ALTCSW:	DB	0,0	;(WORD) PRINTER COUT

	; ------------
	; PRINTER INIT
	; ------------

PCHK:	LDX #LOW SLOTM		;ASK WHICH SLOT PRINTER IS IN
	LDA #HIGH SLOTM
	LDY #SLOTML
	JSR DLINE

	LDA #0			;ACTUALLY SLOT 1
	JSR DODEF		;DISPLAY IT AS DEFAULT

	JSR GETKEY
	CMP #EOL
	BEQ PC2			;USE DEFAULT
	SEC
	SBC #"0"
	CMP #8			;1-7
	BCS PCHK		;OOPS
	BCC PC3			;SKIP AROUND DEFAULT
PC2:	LDA #1			;WHICH IS 1
PC3:	CLC
	ADC #$C0
	STA ALTCSW+HI

	JSR PISSER		;SEND <CR> TO SCREEN FOR NEATNESS

	INC PSTAT		;SET TO ON

	LDA CSW+LO		;SAVE NORMAL OUTPUT HOOK
	PHA
	LDA CSW+HI
	PHA
	LDA ALTCSW+LO    	;LOAD SCRIPTING HOOK
	STA CSW+LO
	LDA ALTCSW+HI
	STA CSW+HI

PP0:	LDA	#$89		; OUTPUT PRINTER SETUP SEQUENCE
	JSR	MCOUT		; START WITH COMMAND CHAR <CTRL-I>
	LDA	#$B8		; 8	(80 COL WIDE)
	JSR	MCOUT
	LDA	#$B0		; 0
	JSR	MCOUT
	LDA	#$CE		; N	(LF AFTER CR)
	JSR	MCOUT

	LDA	CSW+LO		; SAVE REAL PRINTER OUTPUT
	STA	ALTCSW+LO	; LOC. FOR NEXT TIME
	LDA	CSW+HI
	STA	ALTCSW+HI

	PLA			; RESET NORMAL OUTPUT
	STA	CSW+HI
	PLA
	STA	CSW+LO

	; PRINTER SETUP ON THE IIc COPIES THE ROM INTERRUPT VECTOR
	; FROM $FFFE IN ROM TO BOTH MAIN & AUX. RAM PAGES @ $FFFE
	; THOSE PAGES ARE BEING USED TO CONTAIN A PAGE OF GAME
	; CODE. THE FOLLOWING RTN CAUSES THE NEXT USE OF THOSE
	; PAGES TO READ THEM IN NEW FROM THE DISK SO THAT THE VALUES 
	; WILL ALL BE CORRECT.  (6/14/85 Le)

	LDA	#HIGH PTABL	; SET TBL SO CAN 
	STA	I+HI		; ACCESS ALL OF IT
	LDA	#LOW PTABL
	STA	I+LO

	LDA	#$EE		; THIS IS ID OF MAIN RAM PG $FF
	SEC
	SBC	PAGE0		; GET OFFSET OF PAGE IN PTABL
	ASL	A		; WORD ALIGNED TBL
	CLC
	ADC	I+LO		; ALIGN AT THAT PAGE IN THE TABLE
	STA	I+LO
	BCC	PC4
	INC	I+HI		; PICK UP CARRY
PC4:	LDA	#$FF
	LDY	#0
	STA	(I),Y		; ERASE PAGE @ $FF
	INY			; AS IF NOT THERE
	STA	(I),Y
	LDA	#$F8		; LOW BYTE OF OFFSET TO 
	CLC			; AUX. MEMORY PAGE $FF
	ADC	I+LO
	STA	I+LO
	LDA	I+HI
	ADC	#1		; ADD CARRY AND HIGH BYTE OFFSET
	STA	I+HI

	LDA	#$FF		; AND ERASE PAGE 
	STA	(I),Y		; IN AUX. MEM LOCATION TOO
	DEY
	STA	(I),Y

	LDA	#0
	STA	ZPCFLG		; INVALIDATE ZPNT
	STA	MPCFLG		; AND MPNT TO FORCE NEW READ
	RTS


	; ------------
	; SPLIT SCREEN
	; ------------

	; SPLIT SCREEN AT LINE [ARG1]
	; DISABLE SPLIT IF [ARG1] = 0
	; IGNORE IF SPLIT ALREADY ENABLED OR [ARG1] >= 20

ZSPLIT:	LDA ZBEGIN+ZMODE
	AND #%00100000		;CHECK IF ENABLED
	BEQ ZSPOUT		;NOT, LEAVE

	LDA ARG1+LO		;GET # OF LINES FOR SCREEN
	BEQ NORL		;IF 0 THEN RESTORE SCREEN
	LDX SPSTAT		;CHECK IF ALREADY ENABLED
	BNE ZSPOUT		;IT IS
	CMP #20			;IS SPLIT REALLY = WHOLE SCREEN
	BCS ZSPOUT		;YES, IGNORE

	PHA
	CLC
	ADC #1			;ONE LINE ADDITIONAL TO SIZE GIVEN
				;TO MAKE UP FOR STATUS LINE
	STA WBOTM		;TEMPORARILY FOR TOP SCREEN CLEAR
	STA SPSTAT		;NON ZERO = SCREEN IS SPLIT
	JSR HOME		;CLEAR FROM TOP TO BOTTOM (OF TOP SCREEN)
	LDA #$18		;RESTORE BOTTOM FOR SCROLL
	STA WBOTM
	PLA			;GET @ OF LINES AGAIN
	CLC
	ADC #1			;ADD 1
	STA WTOP		;MAKE THAT THE TOP OF THE SECOND SCREEN
	LDA #1
	STA CH
	STA EH
	LDA #$16
	STA CV			;RESTORE CURSOR AFTER HOME CALL
	JMP PISSER		;<CR> TO MAKE CV WORK
ZSPOUT:	RTS

NORL:	;RESTORE SCREEN TO FULL SCREEN MODE

	LDA #1			;PUT CURSOR AT TOP OF SCREEN
	STA WTOP		;RESTORE FULL SCREEN ALIGNMENT
	LDA #0
	STA LINCNT
	STA SPSTAT		;FLAG NOT SPLIT
	RTS

	; ------
	; SCREEN
	; ------

	; GO TO TOP WINDOW (TOP OF SCREEN) IF [A] = 1
	; GO TO BOTTOM OF SCREEN IF [A] = 0
	; IGNORE IF SPLIT NOT ENABLED OR [A] <> 0 OR 1

	; FLAG SPLITF WILL BE SET FOR OUTPUT TO DETERMINE
	; IF AND WHICH WINDOW TO DISPLAY TO 
	; (0=BOTTOM 1=TOP)


ZSCRN:	LDA ZBEGIN+ZMODE
	AND #%00100000		;CHECK IF ENABLED
	BEQ ZSPOUT		;NOT, LEAVE

	LDA SPSTAT		;CHECK IF SCREEN IS SPLIT
	BEQ ZSPOUT		;NO, SO JUST LEAVE
	LDA ARG1+LO		;CHECK WHICH WINDOW
	BNE SCRN1		;TOP SCREEN

	STA SPLITF		;SET FLAG TO SPLIT SCREEN (0)
	LDA #01			;PUT CURSOR AT BOTTOM OF SCREEN
	STA CH
	STA EH
	LDA #$16
	STA CV
	BNE SCRNP		;JMP TO <CR> RTN
SCRN1:	CMP #01
	BNE ZSPOUT		;INVALID SCREEN ID
	STA SPLITF		;SET FLAG TO UNSCROLLING SCREEN (1)

	LDA #0
	STA CH
	STA EH
	STA CV			;ALIGN AT TOP OF SCREEN
SCRNP:	JMP PISSER		;CALL <CR> RTN TO SET CURSOR (+ LEAVE)


	; ---------
	; RAZZ USER
	; ---------

BOOP	EQU	BELL		;MONITOR BELL 

	; ------------
	; CLEAR SCREEN
	; ------------

CLS	EQU 	HOME		;CLEAR & HOME CURSOR

PISSER:	LDA COL80		;SEND APPROPRIATE <RET> TO SCREEN
	BEQ PISS		;IF = 0 THEN 40 COL.
	LDA #$0D
	BNE PIS			;JMP
PISS	LDA #$8D
PIS	JMP MCOUT


GETBUF:	LDA	ZPAGE+HI	; DIVIDE BY 2, WORD ALIGNED
	LSR	A
	STA	HOLD+HI
	LDA	ZPAGE+LO
	ROR	A
	CLC
	ADC	PAGE0+LO	; ADD TO PAGING START FOR
	STA	HOLD+LO		; ACTUAL BUFFER IN MEMORY TO USE
	LDA	HOLD+HI
	ADC	PAGE0+HI
	AND	#%00000001
	BNE	GETAUX		; PAGE BUFFER IS IN AUX. MEMORY

	LDA	HOLD+LO
	CMP	#$C0
	BCS	GETHI		; PAGE BUFFER IS IN HIGH MAIN MEMORY

	STA	DBUFF+HI	; SET PAGE TO READ TO
	JSR	GETDSK		; AND READ PAGE IN
	RTS

GETHI:	PHA			; SAVE DESTINATION BUFFER
	LDA	#HIGH IOBUFF	; FAKE GETDSK INTO NOT MOVING
	STA	DBUFF+HI	; THE PAGE ANYWHERE
	JSR	GETDSK
	PLA			; NOW GET DESTINATION OF PAGE
	BCS	GETBEX		; OOPS
	JSR	HIMOV		; AND MOVE IT THERE
	CLC			; CLEAR CARRY FOR OK
GETBEX:	RTS

GETAUX:	LDA	#HIGH IOBUFF	; FAKE GETDSK INTO NOT MOVING
	STA	DBUFF+HI	; THE PAGE ANYWHERE
	JSR	GETDSK
	LDA	HOLD+LO		; NOW GET DESTINATION OF PAGE
	BCS	GETBEX		; OOPS
	JSR	MOVBUF		; AND MOVE IT THERE
	CLC			; CLEAR CARRY FOR OK
	RTS

ALIGN:	RTS

ALIGNM:	RTS

	; -------------------------
	; SOFT SWITCHES FOR AUX RAM
	; -------------------------

BNK1RD	EQU	$C088		; ALLOWS READ OF BANK1 RAM (MAIN/AUX)
BNK2RD	EQU	$C080		; ALLOWS READ OF BANK2 RAM

BNK1RW	EQU	$C08B		; 2 READS ENABLES R/W TO BANK 1
BNK2RW	EQU	$C083		;                             2

RAMRDS	EQU	$C003		; ALLOWS READ OF 48K AUX MEM
RAMRDC	EQU	$C002		; SETS FOR READ OF MAIN 48K BANK

RAMWRTS	EQU	$C005		; SET WRITE TO AUX MEM
RAMWRTC	EQU	$C004		;              MAIN MEM

ALTZPS	EQU	$C009		; SETS FOR R/W OF AUX MEM
				; PAGES 0, 1, $D000-$FFFF
ALTZPC	EQU	$C008		; SETS FOR MAIN.

ROMRAM	EQU	$C089		; READ ROM, WRITE RAM, BANK1
				; REQUIRES 2 READS

	; **************
	;
	; TO USE 63K OF ALTERNATE RAM IN THE IIE OR IIC, VIEW
	; THE MEMORY AS A NUMBER OF BUFFERS.
	; EACH BUFFER IS ONE PAGE AND COINCIDES WITH ONE RAM PAGE.
	; (80 COL. USES $400 - $7FF FOR VIDEO DISPLAY)

	; ** THE BUFFER (NN) IS NOT NESSISARILY RAM (NNXX) **

	; BUFFER NUMBER			RAM PAGE
	; -------------			--------
	;    MAIN
	;
	;   C0 -> EE		:	D1 -> FF	BANK 1
	;   EF -> FE		:	D0 -> DF	BANK 2
	;
	;   AUXILIARY
	;
	;   FF -> 00		:	00 -> 01
	;   01 -> BA		:	02 -> 03, 08 -> BF
	;   BB -> EA		:	DO -> FF	BANK 1
	;   EB -> FA		:	DO -> DF	BANK 2

	; AS THIS INTERPRETER IS IN MAIN RAM 48K, RTNS TO HANDLE
	; READING FROM 48K AUX MEMORY MUST BE IN HIGH MEM
	; THOSE RTNS ARE PLACED AT $D000 IN COLDSTART

	; -----
	; HIBYT
	; -----

	; GET BYTE <Y> FROM HIGH MAIN MEMORY BUFFER <A>
	; EXIT BYTE IN <A> ALL ELSE UNCHANGED

HIBYT:	SEI
	CMP	#$EF
	BCC	BNK1

	SBC	#$1F		; CONVERT TO BANK2 ADDR
	STA	B2ADD+1+HI	; PLACE IT IN CODE
	LDA	BNK2RD		; READ BANK 2
	LDA	BNK2RD
B2ADD:	LDA	$FF00,Y		; GET CHAR FROM BANK 2
	LDX	ROMRAM		; RESET TO ROM
	LDX	ROMRAM
	CLI
	RTS

BNK1:	ADC	#$11		; CONVERT TO BANK1 ADDR
	STA	B1ADD+1+HI
	LDA	BNK1RD
	LDA	BNK1RD
B1ADD:	LDA	$FF00,Y		; (FAKE ADDR)
	LDX	ROMRAM		; RESET TO ROM
	LDX	ROMRAM
	CLI
	RTS

	; -----
	; HIMOV
	; -----

	; TRANSFER [IOBUFF] CONTENTS TO HIGH MAIN MEMORY BLOCK IN [A]

HIMOV:	SEI
	CMP	#$EF
	BCC	MBNK1

	SBC	#$1F		; SET TO WRITE TO BANK 2
	STA	M2ADD+1+HI
	LDA	BNK2RW
	LDA	BNK2RW
	JMP	HIMOV0

MBNK1:	ADC	#$11		; CONVERT TO BANK 1 ADDR
	STA	M2ADD+1+HI
	LDA	BNK1RW
	LDA	BNK1RW

HIMOV0:	LDY	#0
HIMLP:	LDA	IOBUFF,Y	; READ FROM LOW MEMORY BUFFER
M2ADD:	STA	$FF00,Y		; WRITE TO HIGH PAGE
	INY
	BNE	HIMLP

	LDA	ROMRAM		; RESET TO ROM
	LDA	ROMRAM
	CLI
	RTS


	; ------
	; BUFBYT
	; ------

	; GET BYT <Y> FROM AUX MEM BUFFER <A>
	; EXIT BYTE IN <A> ALL ELSE UNCHANGED

BUFBYT:	SEI			; COULD BE BAD IF AN INTERUPT OCCURED
	CMP	#$FF		; FF,0 = 0,1
	BEQ	BSKP1
	TAX
	BEQ	BSKP1		; TO PAGE 0 OR 1 BLOCK

	CMP	#$BB
	BCC	BUF48		; TO 48K BLOCK

	CMP	#$EB
	BCC	BSKP2		; TO BANK1

	; TO BANK 2
	SBC	#$1B		; C=1  ADJUST TO RAM LOC.
	STA	BADD+1+HI	; SET DUMMY ADDR TO CORRECT ONE

	LDA	BNK2RD
	LDA	BNK2RD
B1GET:	STA	ALTZPS		; SET TO AUX MEM
BADD:	LDA	$FF00,Y		; FAKE ADDR (WILL BE SET APPROPRIATELY)
	LDX	ROMRAM		; RESET WHEN DONE TO ROM
	LDX	ROMRAM
	STA	ALTZPC
	CLI
	RTS

	; TO BANK 1 AUX MEM
BSKP2:	ADC	#$14		; C=0   ADJUST TO RAM LOC. (+14, +1 LATER)
	LDX	BNK1RD		; SET FOR BANK 1
	LDX	BNK1RD

	; TO PAGE 0 OR 1 AUX MEM
BSKP1:	CLC
	ADC	#1
	STA	BADD+1+HI	; SET DUMMY ADDR

	JMP	B1GET		; GO DO MOVE

	; TO 48K AUX MEMORY

BUF48:	CLC
	ADC	#1
	CMP	#4		; IF PG 2 OR 3, OK
	BCC	BSKP0
	CLC
	ADC	#4		; ELSE SKIP OVER 4 VIDEO PAGES
BSKP0:	LDX	BNK1RW		; SET TO R/W TO MAIN BANK1
	LDX	BNK1RW
	STA	B48ADD+1+HI
	JSR	B48GET		; RTN IS @ $D000 MAIN HIGH MEM
	LDX	ROMRAM		; RESET TO ROM
	LDX	ROMRAM
	CLI
	RTS

;----------------------------------------------------------------
;	THIS IS RTN AT $D000 SO CAN READ FROM AUX MEM
;
;B48GET:STA	RAMRDS		; SET READ 48K AUX
;B48ADD:LDA	$FF00,Y		; PICK UP CHAR (FAKE ADDR)
;	STA	RAMRDC		; SET BACK TO MAIN 48K RAM
;	RTS
;
;-----------------------------------------------------------------

	; ------
	; MOVBUF
	; ------

	; TRANSFERS THE DATA AT (IOBUFF) INTO THE AUX MEMORY BLOCK <A>

MOVBUF:	SEI
	CMP	#$FF		; FF,0 = 0,1
	BEQ	MBSKP1
	TAX
	BEQ	MBSKP1		; TO PAGE 0 OR 1 BLOCK

	CMP	#$BB
	BCC	MOV48		; TO 48K BLOCK

	CMP	#$EB
	BCC	MBSKP2		; TO BANK1

	; TO BANK 2
	SBC	#$1B		; CARRY=1  ADJUST TO RAM LOC.
	LDY	BNK2RW		; SET TO WRITE TO BANK 2
	LDY	BNK2RW
	JMP	MBSKP3		; GO DO MOVE

	; TO BANK 1 AUX MEM
MBSKP2:	ADC	#$14		; CARRY=0   ADJUST TO RAM LOC. (+14, +1 LATER)
	LDX	BNK1RW
	LDX	BNK1RW

	; TO PAGE 0 OR 1 AUX MEM
MBSKP1:	CLC
	ADC	#1
MBSKP3:	STA	MOVADD+1+HI	; SET DUMMY ADDR TO CORRECT ONE
MOV1:	STA	ALTZPS		; SET TO AUX MEMORY

	LDY	#0		; INIT INDEX
MOVLP:	LDA	IOBUFF,Y	; GET A CHAR FROM WHERE STORING IT
MOVADD:	STA	$FF00,Y		; AND PLACE IT IN REAL ADDR (FAKE ADDR)
	INY
	BNE	MOVLP
	STA	ALTZPC		; AND RESET MEMORY WHEN DONE
	LDY	ROMRAM
	LDY	ROMRAM
	CLI
	RTS

	; TO 48K AUX MEMORY

MOV48:	CLC
	ADC	#1
	CMP	#4		; IF PG 2 OR 3, OK
	BCC	MSKP0
	CLC
	ADC	#4		; ELSE SKIP OVER 4 VIDEO PAGES
MSKP0:	STA	M48ADD+1+HI
	STA	RAMWRTS		; SET TO WRITE TO 48K AUX.

	LDY	#0		; INIT INDEX
MLP:	LDA	IOBUFF,Y	; READ FROM MAIN RAM BUFFER
M48ADD:	STA	$FF00,Y		; TO AUX RAM PAGE (FAKE ADDR)
	INY
	BNE	MLP

	STA	RAMWRTC
	CLI
	RTS

	END

