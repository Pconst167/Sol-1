	PAGE
	SBTTL "--- GAME I/O: CBM64 ---"

	; --------------
	; INTERNAL ERROR
	; --------------

	; ENTRY: ERROR CODE IN [A]

ERRM:	DB	"Internal error "
ENUMB:	DB	"00."
ERRML	EQU	$-ERRM

ZERROR:	LDY	#1		; CONVERT ERROR BYTE IN [A]
ECON:	JSR	DIV10		; TO ASCII DECIMAL IN [ENUMB]
	ORA	#'0'
	STA	ENUMB,Y
	TXA
	DEY
	BPL	ECON

	JSR	CLRCHN
	JSR	ZCRLF		; CLEAR BUFFER
	LDA	#0
	STA	SCRIPT		; DISABLE SCRIPTING

	LDX	#LOW ERRM
	LDA	#HIGH ERRM
	LDY	#ERRML
	JSR	DLINE

	; FALL THROUGH ...

	; ----
	; QUIT
	; ----

ZQUIT:	JSR	ZCRLF		; FLUSH BUFFER

	LDX	#LOW TOQ
	LDA	#HIGH TOQ
	LDY	#TOQL
	JSR	DLINE		; "END OF STORY"

	LDA	FAST		; FAST-READ ENGAGED?
	BEQ	FREEZE
	JSR	FOFF		; DISENGAGE IF SO
FREEZE:	JMP	FREEZE		; AND STOP

TOQ:	DB	"End of session."
	DB	EOL
TOQL	EQU	$-TOQ

	; -------
	; RESTART
	; -------

ZSTART:	JSR	ZCRLF

	LDA	FAST		; FAST-READ?
	BEQ	DOSTRT		; NO, GO
	JSR	FOFF		; ELSE DISENGAGE

DOSTRT:	LDA	ZBEGIN+ZSCRIP+1	; SAVE SCRIPT STATE
	AND	#%00000001	; FOR LATER
	STA	SFLAG		; (BM 5/14/85)

	JMP	WARM1		; AND DO A WARMSTART

	; --------------------
	; PRINT VERSION NUMBER
	; --------------------

VERS:	DB	"C64 Version F"
	DB	EOL
VERSL	EQU	$-VERS

VERNUM:	JSR	ZCRLF

	LDX	#LOW VERS
	LDA	#HIGH VERS
	LDY	#VERSL
	JMP	DLINE

	; --------------------------
	; RETURN TOP RAM PAGE IN [A]
	; --------------------------

MEMTOP:	LDA	#$CF		; IT'S A GIVEN
	RTS

	; --------------------------------
	; RETURN RANDOM BYTES IN [A] & [X]
	; --------------------------------

RANDOM:	LDA	RAND		; SOMETHING FROM HERE
	LDX	RASTER		; AND HERE
	RTS

	; -------------------
	; Z-PRINT A CHARACTER
	; -------------------

	; ENTRY: ASCII CHAR IN [A]

COUT:	CMP	#EOL		; IF EOL,
	BEQ	ZCRLF		; DO IT!
	CMP	#SPACE		; IGNORE ALL OTHER
	BCC	CEX		; CONTROLS

	LDX	LENGTH		; ELSE GET LINE POINTER
	STA	LBUFF,X		; ADD CHAR TO BUFFER
	CPX	#XSIZE		; END OF LINE?
	BCS	FLUSH		; YES, FLUSH THE LINE
	INC	LENGTH		; ELSE UPDATE POINTER

CEX:	RTS

	; -------------------
	; FLUSH OUTPUT BUFFER
	; -------------------

	; ENTRY: LENGTH OF BUFFER IN [X]

FLUSH:	LDA	#SPACE

FL0:	CMP	LBUFF,X		; FIND LAST SPACE CHAR
	BEQ	FL1		; IN THE LINE
	DEX
	BNE	FL0		; IF NONE FOUND,
	LDX	#XSIZE		; FLUSH ENTIRE LINE

FL1:	STX	OLDLEN		; SAVE OLD LINE POS HERE
	STX	LENGTH		; MAKE IT THE NEW LINE LENGTH

	JSR	ZCRLF		; PRINT LINE UP TO LAST SPACE

	; START NEW LINE WITH REMAINDER OF OLD

	LDX	OLDLEN		; GET OLD LINE POS
	LDY	#0		; START NEW LINE AT BEGINNING
FL2:	INX
	CPX	#XSIZE		; CONTINUE IF
	BCC	FL3		; INSIDE OR
	BEQ	FL3		; AT END OF LINE
	STY	LENGTH		; ELSE SET NEW LINE LENGTH
	RTS

FL3:	LDA	LBUFF,X		; GET CHAR FROM OLD LINE
	STA	LBUFF,Y		; MOVE TO START OF NEW LINE
	INY			; UPDATE LENGTH OF NEW LINE
	BNE	FL2

	; ---------------
	; CARRIAGE RETURN
	; ---------------

ZCRLF:	INC	LINCNT		; NEW LINE GOING OUT
	LDA	LINCNT		; IS IT TIME TO
	CMP	LMAX		; PRINT "MORE" YET?
	BCC	CR1		; NO, CONTINUE

	; SCREEN FULL; PRINT "MORE"

	JSR	ZUSL		; UPDATE STATUS LINE

	LDA	#0
	STA	LINCNT		; RESET LINE COUNTER
	STA	COLOR		; PRINT "MORE" IN BLACK
	STA	NDX		; CLEAR QUEUE

	SEC
	JSR	PLOT		; GET CURSOR POSITION
	STY	OLDX
	STX	OLDY

	LDX	#LOW MORE
	LDA	#HIGH MORE
	LDY	#MOREL
	JSR	DLINE		; PRINT "MORE" DIRECTLY

ZCR0:	JSR	GETIN		; GET ANY KEYPRESS
	TAX
	BEQ	ZCR0

	LDY	OLDX
	LDX	OLDY
	CLC
	JSR	PLOT		; RESTORE CURSOR

	LDA	#1
	STA	COLOR		; SWITCH BACK TO WHITE

	LDX	#LOW MCLR
	LDA	#HIGH MCLR
	LDY	#MOREL
	JSR	DLINE		; RUB OUT "MORE"

	LDY	OLDX
	LDX	OLDY
	CLC
	JSR	PLOT		; RESTORE CURSOR AGAIN

CR1:	LDX	LENGTH
	LDA	#EOL		; INSTALL EOL AT
	STA	LBUFF,X		; END OF CURRENT LINE
	INC	LENGTH		; UPDATE LINE LENGTH

LINOUT:	LDY	LENGTH		; IF BUFFER EMPTY,
	BEQ	LINEX		; DON'T PRINT ANYTHING

	STY	PRLEN		; SAVE LENGTH HERE FOR "PPRINT"
	LDX	#0		; SEND CONTENTS OF [LBUFF]
LOUT:	LDA	LBUFF,X		; TO SCREEN
	JSR	CHAR
	INX
	DEY
	BNE	LOUT

	JSR	PPRINT		; PRINT [LBUFF] IF ENABLED

LINEX:	LDA	#0		; RESET LINE LENGTH
	STA	LENGTH		; TO ZERO
	RTS			; AND RETURN

MORE:	DB	"[MORE]"
MOREL	EQU	$-MORE

MCLR:	DB	"      "

	; ----------------------
	; UPDATE THE STATUS LINE
	; ----------------------

SCORE:	DB	"Score: "
SCOREL	EQU	$-SCORE

CLOCK:	DB	"Time: "
CLOCKL	EQU	$-CLOCK

ZUSL:	SEC			; SAVE THE CURRENT
	JSR	PLOT		; CURSOR POSITION
	STY	OLDX
	STX	OLDY

	LDA	LENGTH		; SAVE ALL
	PHA			; STRING-PRINTING
	LDA	MPCH		; VARIABLES
	PHA
	LDA	MPCM
	PHA
	LDA	MPCL
	PHA
	LDA	TSET
	PHA
	LDA	PSET
	PHA
	LDA	ZWORD+HI
	PHA
	LDA	ZWORD+LO
	PHA
	LDA	ZFLAG
	PHA
	LDA	DIGITS
	PHA

	LDX	#XSIZE
USL0:	LDA	LBUFF,X		; MOVE CONTENTS OF [LBUFF]
	STA	BUFSAV,X	; TO [BUFSAV]
	LDA	#SPACE		; CLEAR
	STA	LBUFF,X		; [LBUFF] WITH SPACES
	DEX
	BPL	USL0

	LDA	#0
	STA	LENGTH		; RESET LINE LENGTH
	STA	SCRIPT		; DISABLE SCRIPTING
	STA	COLOR		; PRINT STATUS LINE IN BLACK

	LDA	#$13		; HOME THE
	JSR	CHROUT		; CURSOR
	LDA	#$12		; PRINT IN
	JSR	CHROUT		; INVERSE VIDEO

	; PRINT ROOM DESCRIPTION

	LDA	#16		; GLOBAL VAR #16 (ROOM ID)
	JSR	GETVRG		; GET IT INTO [VALUE]
	LDA	VALUE+LO
	JSR	PRNTDC		; PRINT SHORT ROOM DESCRIPTION

	LDA	#24		; MOVE LINE INDEX UP
	STA	LENGTH		; TO TIME/SCORE POSITION

	LDA	#17		; GLOBAL VAR #17 (SCORE/HOURS)
	JSR	GETVRG		; GET IT INTO [VALUE]

	LDA	TIMEFL		; GET MODE FLAG
	BNE	DOTIME		; USE TIME MODE IF NON-ZERO

	; PRINT "SCORE"

	LDA	#'S'
	JSR	COUT
	LDA	#'c'
	JSR	COUT
	LDA	#'o'
	JSR	COUT
	LDA	#'r'
	JSR	COUT
	LDA	#'e'
	JSR	COUT
	LDA	#':'
	JSR	COUT
	LDA	#SPACE
	JSR	COUT

	LDA	VALUE+LO	; MOVE SCORE VALUE
	STA	QUOT+LO		; INTO [QUOT]
	LDA	VALUE+HI	; FOR PRINTING
	STA	QUOT+HI
	JSR	NUMBER		; PRINT SCORE VALUE IN DECIMAL

	LDA	#'/'		; PRINT A SLASH
	BNE	MOVMIN		; BRANCH ALWAYS

	; PRINT "TIME"

DOTIME:	LDA	#'T'
	JSR	COUT
	LDA	#'i'
	JSR	COUT
	LDA	#'m'
	JSR	COUT
	LDA	#'e'
	JSR	COUT
	LDA	#':'
	JSR	COUT
	LDA	#SPACE
	JSR	COUT

	LDA	VALUE+LO	; 00 IS REALLY 24
	BNE	DT0
	LDA	#24
DT0:	CMP	#13		; IS HOURS > 12,
	BCC	DT1
	SBC	#12		; CONVERT TO 1-12
DT1:	STA	QUOT+LO		; MOVE FOR PRINTING
	LDA	#0
	STA	QUOT+HI		; CLEAR MSB
	JSR	NUMBER

	LDA	#':'		; COLON

MOVMIN:	JSR	COUT		; PRINT SLASH OR COLON

	LDA	#18		; GLOBAL VAR #18 (MOVES/MINUTES)
	JSR	GETVRG		; GET IT INTO [VALUE]
	LDA	VALUE+LO	; MOVE TO [QUOT]
	STA	QUOT+LO		; FOR EVENTUAL PRINTING
	LDA	VALUE+HI
	STA	QUOT+HI

	LDA	TIMEFL		; WHICH MODE?
	BNE	DOMINS		; TIME IF NZ

	; PRINT NUMBER OF MOVES

	JSR	NUMBER		; SHOW # MOVES
	JMP	STATEX		; ALL DONE

	; PRINT MINUTES

DOMINS:	LDA	VALUE+LO	; CHECK MINUTES
	CMP	#10		; IF MORE THAN TEN
	BCS	DOM0		; CONTINUE

	LDA	#'0'		; ELSE PRINT A
	JSR	COUT		; PADDING "0" FIRST

DOM0:	JSR	NUMBER		; SHOW MINUTES

	LDA	#SPACE
	JSR	COUT		; SEPARATE THINGS

	LDA	#17		; CHECK "HOURS" AGAIN
	JSR	GETVRG
	LDA	VALUE+LO
	CMP	#12		; PAST NOON?
	BCS	DOPM		; YES, PRINT "PM"

	LDA	#'A'		; ELSE PRINT "AM"
	BNE	DOXM		; BRANCH ALWAYS

DOPM:	LDA	#'P'

DOXM:	JSR	COUT
	LDA	#'M'
	JSR	COUT

	; STATUS LINE READY

STATEX:	LDA	#40		; PRINT THE ENTIRE
	STA	LENGTH		; STATUS LINE
	JSR	CR1

	LDX	#XSIZE		; RESTORE OLD [LBUFF]
USLX:	LDA	BUFSAV,X
	STA	LBUFF,X
	DEX
	BPL	USLX

	PLA			; RESTORE ALL
	STA	DIGITS		; SAVED VARIABLES
	PLA
	STA	ZFLAG
	PLA
	STA	ZWORD+LO
	PLA
	STA	ZWORD+HI
	PLA
	STA	PSET
	PLA
	STA	TSET
	PLA
	STA	MPCL
	PLA
	STA	MPCM
	PLA
	STA	MPCH
	PLA
	STA	LENGTH

	LDX	OLDY		; RESTORE CURSOR
	LDY	OLDX
	CLC
	JSR	PLOT

	LDX	#$FF
	STX	SCRIPT		; RE-ENABLE SCRIPTING
	INX			; = 0
	STX	MPCFLG		; INVALIDATE [MPC]
	INX			; = 1
	STX	COLOR		; PRINT IN WHITE AGAIN
	RTS

	END

