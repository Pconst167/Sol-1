

                               	    TITLE '         XZIP INTERPRETER FOR APPLE MACINTOSH '

                               	    PRINT NOGEN			; DON'T EXPAND MACROS
                               	    PRINT ON

                               	    BLANKS OFF		; ALLOW COMMENTS USING '*' NOT ';'
                               	    STRING ASIS		; NOT PASCAL OR C FORMAT

00000                          	    PROC
00000                          	    DATA
00000
00000                          	    IMPORT	firstRow
00000                          	    IMPORT	lastRow
00000                          	    IMPORT	firstCol
00000                          	    IMPORT	lastCol
00000
00000                          	    IMPORT	totRows		* [was totLines]
00000                          	    IMPORT	totCols		* [was totColumns]
00000                          	    IMPORT	curRow
00000                          	    IMPORT	curCol
00000
00000                          	    IMPORT	lineHeight	* height of font, in pixels
00000                          	    IMPORT	colWidth	* width of font (or of digit '0')
00000
00000                          	    IMPORT	margLeft
00000                          	    IMPORT	margRight
00000
00000                          	    IMPORT	currentHl	* inverse, etc
00000                          	    IMPORT	currentAttr	* wrap, etc
00000                          	**  IMPORT	currentFont	* DEAD, use ZFont
00000
00000                          	**    IMPORT	scr1Lines
00000                          	**    IMPORT	whichScr
00000
00000                          	**    IMPORT	_w0font
00000                          	**    IMPORT	_w1font
00000                          	    IMPORT	mColor		* [was _mono]
00000
00000                          	    IMPORT	xmouse		* mouse position (char units, zero origin)
00000                          	    IMPORT	ymouse
00000                          	    IMPORT	bmouse		* mouse button status
00000                          	    IMPORT	undoflag	* [boolean -- addr as byte from 68K]
00000
00000                          	    IMPORT	filename
00000                          	    IMPORT	filevol
00000                          	    IMPORT	actlen
00000
00000                          	    CODE
00000
00000   0000 0002              	    EXPORT	ZSTART
00000                          	**    EXPORT	_mov_mem	* (char *p1, *p2; LONG len)
00000                          	**    EXPORT	_clr_mem	* (char *p1; LONG len)
00000   0000 2A14              	    EXPORT	SqzRow		* (src, dst: Ptr; len: INTEGER);
00000   0000 2A38              	    EXPORT	FillCSpec	* (CSpec: Ptr; ix: INTEGER; bytePal: Ptr);
00000   0000 2A5C              	    EXPORT	BuildStips	* (table1, table2: Ptr);
00000   0000 2AB8              	    EXPORT	StipPic 	* (src, dst: Ptr; rowBytes, rows: INTEGER; maps: Ptr);
00000   0000 2B28              	    EXPORT	Shrink75	* (base: Ptr; rb1, rb2, rows: INTEGER);
00000   0000 2BAC              	    EXPORT	Scale2xPic 	* (src, dst, randTbl: Ptr; cols {rbSrc, rbDst}, rows: INTEGER);
00000
00000                          	*** IMPORT	ScrnSize
00000                          	    IMPORT	ClearWindow	* was ClearLines
00000                          	*** IMPORT	EraseEOL
00000                          	    IMPORT	EraseLine	* (start, len: INTEGER)
00000                          	    IMPORT	Scroll
00000
00000                          	*** IMPORT	HiLight		* dead
00000                          	    IMPORT	ZFont		* zid: INTEGER
00000                          	    IMPORT	SetColor
00000                          	    IMPORT	opPicinf
00000                          	    IMPORT	opDisplay
00000
00000                          	    IMPORT	SetUpInput	* was _do_input
00000                          	    IMPORT	EventIn		* was _char_in, MacttyIn
00000                          	    IMPORT	opMouseInfo

00000                          	    IMPORT	CharOut
00000                          	    IMPORT	LineOut
00000
00000                          	    IMPORT	MacInit
00000                          	    IMPORT	QuitGame
00000                          	    IMPORT	ZAlloc
00000
00000                          	*** IMPORT	_german_convert		* Mac: unimplemented
00000                          	*** IMPORT	MacSound
00000                          	    IMPORT	ZSound
00000                          	    IMPORT	EndZSound		* END-OF-SOUND CHECK
00000
00000                          	    IMPORT	NewDefault
00000                          	    IMPORT	FileSelect
00000
00000                          	    IMPORT	ExistFile
00000                          	    IMPORT	CreateFile
00000                          	    IMPORT	OpenFile
00000                          	    IMPORT	CloseFile
00000                          	    IMPORT	DeleteFile
00000                          	    IMPORT	ReadFile
00000                          	    IMPORT	WriteFile
00000
00000                          	    IMPORT	PrInit
00000                          	    IMPORT	PrLine
00000
00000                          	* ----------------------------------------------------------------------------
00000                          	* PROGRAM
00000                          	* ----------------------------------------------------------------------------
00000
00000                          	    INCLUDE	'MX1.a'
00000
00000                          	* ___________________________________________________________________________
00000                          	*
00000                          	* XZIP INTERPRETER FOR THE MACINTOSH
00000                          	*
00000                          	* INFOCOM, INC. COMPANY CONFIDENTIAL -- NOT FOR DISTRIBUTION
00000                          	*
00000                          	* WRITTEN BY DUNCAN BLANCHARD
00000                          	* ___________________________________________________________________________
00000                          	*
00000
00000                          	* YZIP-MAC MODIFICATION HISTORY:
00000                          	*
00000                          	*    01 APR 88	DBB	currow, curcol, clearLines - NOW 0-ORIGIN
00000                          	*    02 MAY 88	DBB	ADDED YZIP WINDOW CALLS, ETC
00000                          	*    06 JUL 88	DBB	ADDED ZBEEP, NOW READLN -> ZBEEP -> DOSOUND
00000                          	*			  WAS TRASHING D1-D3; I THINK THIS FIXES 'D3BUG'
00000                          	*
00000                          	*			YZIP 'D' FROZEN
00000
00000                          	* XZIP-MAC MODIFICATION HISTORY:
00000                          	*
00000                          	*    14 JUL 87  DBB	PORTED FROM ST
00000                          	*    14 SEP 87	DBB	XZIP 'A' FROZEN
00000                          	*    05 OCT 87	DBB	(PASCAL) ROW/COL VARS ALLOW BIG-SCREEN WINDOW
00000                          	*			TIMEOUT COUNTER STOPS WHEN DA ACTIVE
00000                          	*			PUTLIN1 <-> PUTLIN
00000                          	*			OPINPUT/OPPRNT CALL PUTLIN (FIX HINT-WRAP BUG)
00000                          	*			FKEYS THAT AREN'T TCHARS REJECTED IN OPREAD
00000                          	*			ADDED UNDO AND MOUSE SUPPORT CHECKS
00000                          	*			1-CHAR INPUT DISABLES MENU "CMD-STRINGS"
00000                          	*    13 OCT 87	DBB	DESKTOP RESTORE SETS SL REFRESH BIT
00000                          	*			BUFFER NOW DUMPED IN CURSET/SPLIT/SCREEN
00000                          	*    14 OCT 87	DBB	TO ALLOW SCREEN1 BUFFERING:
00000                          	*			  BUFFER ALSO ZEROED FOR ABOVE 3 (CURSOR MOVED)
00000                          	*			  SIZEQP NO LONGER SHRINKS BUF SIZE (ST ITALIC HACK)
00000                          	*    			XZIP 'B' FROZEN
00000                          	*    16 FEB 88	DBB	ADDED SOUND, SOUND INTERRUPTS (GAMINT)
00000                          	*			FIXED COPYT/PRINTT PAGING BUG
00000                          	*			MOVED 'UNDO' SETUP BEFORE PAGING
00000                          	*    			XZIP 'C' FROZEN
00000
00000                          	* XZIP-ATARI MODIFICATION HISTORY:
00000                          	*

00000                          	*    02 FEB 87	DBB	MODIFIED EZIP
00000                          	*    21 MAY 87	DBB	ADDED LOWCORE, MOUSE VARS
00000                          	*    02 JUN 87	DBB	MOVED DUPNAM CHECK (_exist_file) INTO C
00000                          	*    25 JUN 87	DBB	CHANGED OPFONT TO IGNORE REDUNDANT FONT CHANGES
00000                          	*			FIXED STACK BUG, RESTORE VS. TIMER INTERRUPT
00000                          	*    13 JUL 87	DBB	BUFFER FLUSHED IN OPSCRN, OPDIRO, OPERASE, OPCLEAR
00000                          	*			CHKDSK MODIFIED FOR FULL PRELOAD SITUATION,
00000                          	*			RESTART, $VER MAKE SPECIAL CHECKS FOR GAME DISK
00000                          	*			XZIP 'A' FROZEN
00000
00000                          	* ZIP/EZIP (ATARI) MODIFICATION HISTORY:
00000                          	*
00000                          	*    02 AUG 85	ZIP A	FROZEN
00000                          	*    09 AUG 85		CLSGAM CHECKS WHETHER GAME FILE WAS OPENED
00000                          	*    09 AUG 85		REBUILT OBJECT FILE WITH NEW LIBRARIES,
00000                          	*			  INCREASED MACHINE STACK TO 2K (IN ZIPSTART)
00000                          	*    09 AUG 85	ZIP B	FROZEN
00000                          	*    		EZIP A	FROZEN
00000                          	*    10 FEB 86		PURE PRELOAD MAY EXCEED 32K (PUT, PUTB, PTSIZE)
00000                          	*			OPSPLT (EZIP) NO LONGER CLEARS SCREEN
00000                          	*    10 APR 86		CHANGED PUTCHR (SPECIAL HANDLING FOR TABLE OUTPUT)
00000                          	*			ADDED SCRNAM, SCRIPTS SAVE/RESTORE FILENAMES
00000                          	*    18 APR 86		CHANGED NXTLIN/BUFOUT/LINOUT.  BUFOUT CALLS NXTLIN
00000                          	*			  SO [MORE] IS TIMED CORRECTLY DURING BOLDFACE, ETC
00000                          	*			CHANGED OPATTR AND DQUE INIT, FOR ITALICS HACK
00000                          	*			FIXED GETMEM, PREVENTS ST BUG WITH ODD MEM REQUEST
00000                          	*    08 MAY 86		FIXED QUECHR (QCX2A), ALLOW FOR EMPTY [DUMPED] BUFFER
00000                          	*			CHANGED OPREAD, ONLY OVERFLOW WORDS ARE FLUSHED
00000                          	*    13 MAY 86		LINES(A6) NOW NORMALLY RESET TO ZERO, UPDATED INCHR
00000                          	*			OPINPUT CHECKS VOBUFF(A6)
00000                          	*			OPSPLIT CHECKS MAXIMUM SIZE OF split_row
00000                          	*			NXTLIN TURNS OFF HIGHLIGHTING BEFORE PRINTING [MORE]
00000                          	*			COMBINED READLN AND INCHR
00000                          	*		EZIP B  FROZEN
00000
00000                          	* XZIP: SUGGESTIONS FOR FURTHER OVERHAUL
00000                          	*
00000                          	* -  MAKE ALL OPERATORS TAKE ARGS IN SLOTS (INDEXED OFF A6, NOT A0) RATHER
00000                          	*    THAN REGISTERS, NOW THAT MANY ARE OPTIONALS.  PASS A1 -> FIRST ARG
00000                          	*    FOR CONVENIENCE ((A1)++).  REDUCES NEED TO SAVE/RESTORE ARGS, SIMPLIFIES
00000                          	*    USAGE.
00000                          	*
00000                          	* -  IMPLEMENT HIGHLIGHTING USING SPECIAL CHARS, PUT DIRECTLY INTO THE OUTPUT
00000                          	*    STREAM/BUFFER.  LOW-LEVEL OUTPUT ROUTINE SCANS FOR THESE SPECIALS.
00000                          	*    AVOIDS NEED FOR MUCH SPECIAL FLUSHING OF BUFFER.
00000                          	*
00000
00000                          	* ---------------------------------------------------------------------------
00000                          	* REGISTER CONVENTIONS
00000                          	* ---------------------------------------------------------------------------
00000
00000                          	* GENERALLY, SINGLE ARGUMENTS ARE PASSED IN D0 OR A0.  SINGLE VALUES ARE
00000                          	* LIKEWISE RETURNED IN D0 OR A0.  IN ANY CASE, THESE ARE SCRATCH REGISTERS
00000                          	* AND NEED NOT BE PRESERVED.  ALL OTHER REGISTERS, EXCEPT WHERE OTHERWISE
00000                          	* SPECIFIED, MUST BE PRESERVED ACROSS EACH SUBROUTINE CALL.  NOTE THAT
00000                          	* TOP-LEVEL ROUTINES, OPx ROUTINES, ARE EXCLUDED FROM THIS RESTRICTION.
00000
00000                          	* DEDICATED REGISTERS:
00000                          	*   A7 = SYSTEM SP
00000                          	*   A6 = FRAME POINTER FOR ZIP VARIABLES	  *** STATIC ***
00000                          	*   A5 = unused in this version
00000                          	*   A4 = VIRTUAL SP
00000
00000                          	* ---------------------------------------------------------------------------
00000                          	* ASSEMBLY FLAGS
00000                          	* ---------------------------------------------------------------------------
00000
00000                          	* THE FIRST TWO FLAGS EXIST ONLY FOR COMPARATIVE PURPOSES:
00000                          	*   XZIP CAN'T BE CONDITIONALLY ASSEMBLED AS EZIP OR CLASSIC ZIP
00000
00000   0000 0001              	EZIP	EQU	1	* ALWAYS ON (XZIP)
00000   0000 0000              	CZIP	EQU	0	* ALWAYS OFF (XZIP)
00000
00000   0000 0000              	DEBUG	EQU	0	* IF ON, ASSEMBLES DEBUGGING CODE
00000   0000 0000              	D3BUG	EQU	0	* REG D3 BEING TRASHED; TRY TO PINPOINT IT

00000                          	*			    (FIXED BY READLN/ZBEEP, I THINK)
00000
00000                          	* ---------------------------------------------------------------------------
00000                          	* INDEXING BASE FOR THE DISPATCH TABLE
00000                          	* ---------------------------------------------------------------------------
00000
00000   4E71                   	ZBASE	NOP
00002
00002                          	*   DATA		* ST LATTICE: BEGIN THE DATA SEGMENT
00002                          	*	DC.W	0	*   (KLUGE TO AVOID AN OBSCURE LINKER BUG ASSOCIATED
00002                          	*   CODE		* WITH SUCCESSIVE 'DC' STATEMENTS)
00002
00002                          	* ---------------------------------------------------------------------------
00002                          	* GENERAL MACRO DEFINITIONS
00002                          	* ---------------------------------------------------------------------------
00002
00002                          	* MACRO   ZERO
00002                          	*	  MOVEQ   #0,%1		* CLEAR A REGISTER QUICKLY (BOTH WORDS)
00002                          	* ENDM
00002
00002                          	* MACRO   SOB			* SUBTRACT ONE AND BRANCH IF NOT ZERO
00002                          	*	  SUBQ.W  #1,%1
00002                          	*	  BNE.S	  %2
00002                          	* ENDM
00002
00002                          	* PRIOR TO CALLING A PASCAL FUNCTION, MUST MAKE SPACE ON THE STACK
00002                          	* FOR THE RESULT, WORD OR LONG.  [FOR 'C' FUNCTIONS THIS WOULD BE A NOP.]
00002
00002                          	    MACRO
00002                          	    RESWORD
00002                          		SUBQ.L	#2,SP		* QUICKEST INSTR
00002                          	***	TST.W	-(SP)
00002                          	    ENDM
00002
00002                          	    MACRO
00002                          	    RESLONG
00002                          		SUBQ.L	#4,SP
00002                          	    ENDM
00002
00002                          	* AFTER CALLING A PASCAL FUNCTION, POP THE RESULT FROM THE STACK
00002                          	* INTO D0 (THIS MIMICS COMMON 'C' INTERFACES TO INCREASE PORTABILITY).
00002
00002                          	    MACRO
00002                          	    POPWORD
00002                          		MOVE.W	(SP)+,D0
00002                          	***	TST.W	D0		* [C ONLY: SET FLAGS]
00002                          	    ENDM
00002
00002                          	    MACRO
00002                          	    POPLONG
00002                          		MOVE.L	(SP)+,D0
00002                          	***	TST.L	D0
00002                          	    ENDM
00002
00002                          	* WHEN CALLING ANY MAC PASCAL ROUTINE, THESE ARE THE REGISTERS THAT
00002                          	* SHOULD NORMALLY BE PRESERVED, AND WHICH PASCAL MIGHT TRASH.
00002
00002                          	    MACRO
00002                          	    SAVEREGS
00002                          	***	MOVEM.L	D1-D7/A1-A5,-(SP)	* ULTRA-CONSERVATIVE SET
00002                          		MOVEM.L	D1-D2/A1,-(SP)		* STANDARD SET FOR MAC PASCAL
00002                          	    ENDM
00002
00002                          	    MACRO
00002                          	    RESTREGS
00002                          	***	MOVEM.L	(SP)+,D1-D7/A1-A5
00002                          		MOVEM.L	(SP)+,D1-D2/A1		* (DON'T AFFECT FLAGS)
00002                          	    ENDM
00002
00002                          	* ---------------------------------------------------------------------------
00002                          	* GENERAL EQUATES
00002                          	* ---------------------------------------------------------------------------
00002
00002   0000 0000              	ARG0	EQU	0	* ARGUMENT COUNT
00002   0000 0002              	ARG1	EQU	2	* ARGUMENT OFFSETS IN PARAMETER BLOCK

00002   0000 0004              	ARG2	EQU	4
00002   0000 0006              	ARG3	EQU	6
00002   0000 0008              	ARG4	EQU	8
00002
00002   0000 0000              	SKIP	EQU	0	* 'PLACEHOLDER' IN DEFAULT-PARAMETER BLOCK
00002   0000 0010              	DBQLEN	EQU	16	* LENGTH OF DEBUGGER HISTORY QUEUE
00002
00002                          	*** THESE ARE NOW DERIVED ELSEWHERE ...
00002                          	* YCHAR	EQU	12	* CHAR CELL PIXEL SIZE (MAC, MONACO 9)
00002                          	* XCHAR	EQU	6
00002
00002                          	    IF EZIP THEN
00002
00002   0000 0009              	VCHARS  EQU	9	* MAX CHARS IN AN EZIP VOCAB WORD
00002   0000 0006              	ZCHARS	EQU	6	* EZIP: BYTES PER ZWORD
00002
00002   0000 007E              	OPLEN	EQU	63*2	* OBJECT PROPERTY DEFAULT TABLE LENGTH
00002   0000 000E              	OLEN	EQU	14	* OBJECT LENGTH
00002
00002   0000 0006              	LOC	EQU	6	* PARENT
00002   0000 0008              	NEXT	EQU	8	* NEXT SIBLING
00002   0000 000A              	FIRST	EQU	10	* FIRST CHILD
00002   0000 000C              	PROP	EQU	12	* PROPERTY TABLE POINTER
00002
00002   0000 003F              	PMASK	EQU	$003F	* PROPERTY NUMBER IS LOW 6 BITS (OF FIRST ID BYTE)
00002   0000 0006              	PLBIT	EQU	6	* PROPERTY LENGTH BIT (IF LENGTH IS TWO OR ONE)
00002
00002                          	    ENDIF
00002                          	    IF CZIP THEN
00002                          	    ENDIF
00002
00002                          	*--------------------------------------------------------------------------
00002                          	* GENERALIZED OUTPUT-FOLDING PARAMETER BLOCK
00002                          	*--------------------------------------------------------------------------
00002
00002                          	*    THE QUECHR ROUTINE IS CALLED WITH A POINTER TO A STRUCTURE CONTAINING
00002                          	* THE VARIABLES BELOW.  THIS ARRANGEMENT ALLOWS FOR THE EXISTANCE OF MORE THAN
00002                          	* ONE STRUCTURE, USEFUL IF DISPLAYED TEXT AND SCRIPTED TEXT ARE TO FOLD AT
00002                          	* DIFFERENT POINTS.
00002
00002                          	*    THE STRUCTURE IDENTIFIES TWO ACTION ROUTINES.  THE OUTPUT FUNCTION
00002                          	* DUMPS THE BUFFER WHEN IT BECOMES FULL.  THE SIZE FUNCTION ALLOWS FOR THE
00002                          	* HANDLING OF PROPORTIONALLY SPACED TEXT.
00002
00002                          	*    THE LAST TWO VARIABLES ARE CURRENTLY IGNORED, BUT MIGHT BE USEFUL
00002                          	* FOR IMPLEMENTING RECALCULATION OF THE FOLD POINTS FOR A PARAGRAPH OF TEXT,
00002                          	* AS WHEN A WINDOW CHANGES SIZE.
00002
00002                          	* DATA STRUCTURE FOR QUEUE-PARAMETERS BLOCK:
00002
00002   0000 0000              	BUFPTR	EQU	0	* START OF BUFFER
00002   0000 0004              	NXTPTR	EQU	4	* CURRENT POSITION WITHIN BUFFER
00002   0000 0008              	ENDPTR	EQU	8	* END OF BUFFER		>> current not used <<
00002
00002   0000 000C              	BUFSIZ	EQU	12	* MAXIMUM UNITS IN BUFFER
00002   0000 000E              	CURSIZ	EQU	14	* CURRENT UNITS IN BUFFER
00002
00002   0000 0010              	SIZFUN	EQU	16	* GIVEN A CHAR, RETURNS UNIT SIZE
00002   0000 0014              	OUTFUN	EQU	20	* GIVEN PTRS (BEG AND END), DUMPS BUFFER, ADDS CR
00002   0000 0018              	RETFUN	EQU	24	* (UNUSED -- THIS SHOULD ADD THE CR)
00002
00002                          	* FLAGS:
00002
00002   0000 001C              	DUMPED	EQU	28	* WAS BUFFER EMPTIED (WITHOUT CR) BEFORE FULL?
00002   0000 001D              	AUTOCR	EQU	29	* APPEND A CR TO EACH BUFFER DUMP?	*** YES
00002   0000 001E              	KEEPSP	EQU	30	* DON'T DISCARD TRAILING SPACE?		*** NO
00002   0000 001F              	INUSE	EQU	31	* SEMAPHORE TO AVOID RE-ENTRANCE
00002
00002   0000 0020              	QPLEN	EQU	32	* LENGTH OF BLOCK (ALWAYS EVEN)
00002
00002                          	*--------------------------------------------------------------------------
00002                          	* DATA STRUCTURE FOR YZIP WINDOWS:
00002                          	*--------------------------------------------------------------------------
00002
00002   0000 0000              	WYPOS	EQU	0	* WINDOW POSITION

00002   0000 0002              	WXPOS	EQU	2
00002   0000 0004              	WYSIZE	EQU	4	* WINDOW SIZE
00002   0000 0006              	WXSIZE	EQU	6
00002   0000 0008              	WYCURS	EQU	8	* CURSOR POSITION
00002   0000 000A              	WXCURS	EQU	10
00002   0000 000C              	WLMARG	EQU	12	* MARGINS
00002   0000 000E              	WRMARG	EQU	14
00002   0000 0010              	WCRINT	EQU	16	* CR INTERRUPT FUNCTION, COUNTER
00002   0000 0012              	WCRCNT	EQU	18
00002   0000 0014              	WHLIGHT	EQU	20	* HIGHLIGHT MODE
00002   0000 0016              	WCOLOR	EQU	22	* BACK/FORE COLORS
00002   0000 0018              	WFONTID	EQU	24	* FONT ID, SIZE
00002   0000 001A              	WFONTYX	EQU	26
00002   0000 001C              	WATTR	EQU	28	* WRAP BIT, SCROLL BIT, ETC
00002                          	* PRIVATE VARIABLES:
00002   0000 001E              	WLCNT	EQU	30	* LINES DISPLAYED SINCE LAST 'MORE'
00002   0000 0020              	WCSIZ	EQU	32	* "FULLNESS" OF LAST BUFFER (CURSIZ FROM DQUE)
00002                          	* END OF BLOCK:
00002   0000 0022              	WBLKLEN	EQU	34	* TOTAL LENGTH OF BLOCK (ALWAYS EVEN)
00002
00002   0000 0008              	MAXWIND EQU	8	* VALID WINDOW IDS ARE 0..7
00002
00002                          	* FLAG BITS IN WATTR:
00002   0000 0001              	WFWRAP	EQU	1	*   WRAP BIT
00002   0000 0002              	WFSCRL	EQU	2	*   SCROLL BIT
00002   0000 0004              	WFSCRP	EQU	4	*   SCRIPT BIT
00002   0000 0008              	WFBUFF	EQU	8	*   BUFFER BIT
00002
00002                          	* ---------------------------------------------------------------------------
00002                          	* ZIP VARIABLES - INDEXED OFF A6
00002                          	* ---------------------------------------------------------------------------
00002
00002   FFFF FFFE              	ZORKID  EQU	0-2		* UNIQUE GAME AND VERSION ID
00002   FFFF FFFC              	TIMEMD  EQU	ZORKID-2	* HOURS/MINUTES MODE FLAG
00002   FFFF FFFA              	ENDLOD  EQU	TIMEMD-2	* END OF PRELOAD (FIRST PAGED BLOCK NUMBER)
00002   FFFF FFF8              	PURBOT  EQU	ENDLOD-2	* END OF IMPURE (FIRST PURE BLOCK NUMBER)
00002
00002   FFFF FFF4              	VOCTAB  EQU	PURBOT-4	* VOCABULARY TABLE POINTER
00002   FFFF FFF0              	OBJTAB  EQU	VOCTAB-4	* OBJECT TABLE POINTER
00002   FFFF FFEC              	GLOTAB  EQU	OBJTAB-4	* GLOBAL TABLE POINTER
00002   FFFF FFE8              	WRDTAB  EQU	GLOTAB-4	* FREQUENT WORD TABLE POINTER
00002
00002   FFFF FFE4              	RBRKS	EQU	WRDTAB-4	* POINTER TO STRING OF READ-BREAK CHARS
00002   FFFF FFE0              	ESIBKS  EQU	RBRKS-4		* END OF SELF-INSERTING BREAK CHARS (+1)
00002
00002   FFFF FFDE              	VWLEN	EQU	ESIBKS-2	* NUMBER OF BYTES IN A VOCAB WORD ENTRY
00002   FFFF FFDC              	VWORDS  EQU	VWLEN-2		* NUMBER OF VOCABULARY WORDS
00002   FFFF FFD8              	VOCBEG  EQU	VWORDS-4	* POINTER TO FIRST VOCAB WORD
00002   FFFF FFD4              	VOCEND  EQU	VOCBEG-4	* POINTER TO LAST VOCAB WORD
00002
00002   FFFF FFD0              	PAGTAB  EQU	VOCEND-4	* POINTER TO PAGE INFORMATION TABLE
00002   FFFF FFCC              	PAGES	EQU	PAGTAB-4	* POINTER TO START OF PAGE BUFFERS
00002
00002   FFFF FFCA              	PAGTOT  EQU	PAGES-2		* NUMBER OF PAGE BUFFERS
00002   FFFF FFC8              	MAXLOD	EQU	PAGTOT-2	* TOTAL BLOCKS IN GAME
00002   FFFF FFC6              	MAXFLG	EQU	MAXLOD-2	* FLAG SET IF GAME FILE IS WHOLLY PRELOADED
00002
00002   FFFF FFC2              	TOPSP	EQU	MAXFLG-4	* TOP OF SYSTEM STACK
00002   FFFF FFBE              	STKBOT  EQU	TOPSP-4		* BOTTOM OF GAME STACK
00002
00002   FFFF FFBC              	ZPC1	EQU	STKBOT-2	* ZORK PC, BLOCK POINTER (RELATIVE ADDRESS)
00002   FFFF FFBA              	ZPC2	EQU	ZPC1-2		* ZORK PC, BYTE POINTER
00002   FFFF FFB8              	NARGS	EQU	ZPC2-2		* (LOW BYTE) OPTIONAL ARG COUNT
00002   FFFF FFB4              	ZLOCS	EQU	NARGS-4		* POINTER TO LOCALS (ABSOLUTE ADDRESS)
00002
00002   FFFF FFB2              	RSEED1  EQU	ZLOCS-2		* RANDOM NUMBER SEED, HIGH WORD
00002   FFFF FFB0              	RSEED2  EQU	RSEED1-2	* LOW WORD
00002   FFFF FFAE              	RCYCLE  EQU	RSEED2-2	* ZERO MEANS NORMAL, OTHERWISE TOP OF SEQUENCE
00002   FFFF FFAC              	RCONST	EQU	RCYCLE-2	* CURRENT PLACE IN SEQUENCE
00002
00002   FFFF FFA8              	BUFFER  EQU	RCONST-4	* START OF PRELOADED GAME CODE
00002   FFFF FF96              	ARGBLK  EQU	BUFFER-18	* 8 ARGS MAX FOR EZIP, PLUS COUNT
00002   FFFF FF8C              	DEFBLK	EQU	ARGBLK-10	* DEFAULT ARGUMENT BLOCK  (4 ARGS + COUNT)
00002
00002                          	***

00002
00002   FFFF FF82              	RDWSTR  EQU	DEFBLK-10	* ASCIZ STRING BUFFER (9 CHARS MAX FOR EZIP)
00002   FFFF FF7C              	RDZSTR  EQU	RDWSTR-6	* ZSTR BUFFER (3 WORDS MAX FOR EZIP)
00002
00002   FFFF FF78              	RDBOS	EQU	RDZSTR-4	* BEGINNING OF INPUT STRING BUFFER
00002   FFFF FF74              	RDEOS	EQU	RDBOS-4		* END OF INPUT STRING BUFFER (+1)
00002   FFFF FF70              	RDRET	EQU	RDEOS-4		* RETURN TABLE
00002
00002   FFFF FF6E              	VWSORT	EQU	RDRET-2		* FLAG: SET IF VOCTAB SORTED
00002   FFFF FF6C              	VWBOFF	EQU	VWSORT-2	* INITIAL OFFSET FOR BINARY SEARCH
00002
00002   FFFF FF6A              	WRDOFF  EQU	VWBOFF-2	* OFFSET INTO WORD TABLE FOR CURRENT SET
00002
00002                          	* VIRTUAL I/O DEVICES
00002
00002   FFFF FF68              	VOCONS	EQU	WRDOFF-2	* SET FOR SCREEN OUTPUT
00002   FFFF FF66              	VOPRNT	EQU	VOCONS-2	* SET FOR SCRIPTING
00002   FFFF FF64              	VOSTAT	EQU	VOPRNT-2	* SET FOR STATUS LINE OUTPUT
00002   FFFF FF62              	VOTABL	EQU	VOSTAT-2	* SET FOR TABLE OUTPUT
00002   FFFF FF60              	VOFILE	EQU	VOTABL-2	* SET FOR FILE OUTPUT
00002
00002   FFFF FF5E              	VIKEYB	EQU	VOFILE-2	* SET FOR KEYBOARD INPUT
00002   FFFF FF5C              	VIFILE	EQU	VIKEYB-2	* SET FOR FILE INPUT
00002
00002   FFFF FF5A              	VOBUFF	EQU	VIFILE-2	* SET IF OUTPUT TO SCREEN IS BUFFERED
00002   FFFF FF58              	VIECHO	EQU	VOBUFF-2	* SET IF INPUT IS ECHOED
00002
00002   FFFF FF54              	DQUE	EQU	VIECHO-4	* DISPLAY QUE PARAMETER BLOCK
00002   FFFF FF50              	SQUE	EQU	DQUE-4		* SCRIPT QUE PARAMETER BLOCK
00002
00002   FFFF FF4C              	TABOUT  EQU	SQUE-4		* POINTS TO CURRENT TABLE OUTPUT BUFFER (EZIP)
00002   FFFF FF48              	TABPTR  EQU	TABOUT-4	* POINTS TO NEXT TABLE POSITION
00002
00002   FFFF FF44              	CURPAG  EQU	TABPTR-4	* CURRENT PAGE (WHERE ZPC IS) POINTER
00002   FFFF FF42              	CURBLK  EQU	CURPAG-2	* CURRENT BLOCK, USUALLY SAME AS ZPC1
00002   FFFF FF3E              	CURTAB  EQU	CURBLK-4	* CURRENT PAGE TABLE POINTER
00002
00002   FFFF FF3A              	RTIME	EQU	CURTAB-4	* REFERENCE TIME, NOW USES 2 WORDS
00002   FFFF FF38              	LPAGE	EQU	RTIME-2		* LAST REFERENCED PAGE NUMBER
00002   FFFF FF34              	LPLOC	EQU	LPAGE-4		* AND ITS CORE LOCATION
00002   FFFF FF30              	LPTAB	EQU	LPLOC-4		* AND ITS TABLE POINTER
00002
00002   FFFF FF2E              	TWAIT	EQU	LPTAB-2		* DELAY, IN 1/10'S SEC, BETWEEN TIMEOUTS
00002   FFFF FF2C              	TFUNC	EQU	TWAIT-2		* FUNCTION TO CALL UPON TIMEOUT
00002   FFFF FF28              	TCLOCK	EQU	TFUNC-4		* REF TIME (60THS) OF LAST CHANGE IN TCOUNT
00002   FFFF FF26              	TCOUNT	EQU	TCLOCK-2	* DELAY REMAINING (10THS)
00002
00002   FFFF FF24              	SFUNC	EQU	TCOUNT-2	* FUNCTION TO CALL UPON SOUND-END
00002   FFFF FF22              	SCOUNT	EQU	SFUNC-2		* #OPS TO WAIT BEFORE NEXT SOUND-END CHECK
00002
00002   FFFF FF1E              	QFOFF	EQU	SCOUNT-4	* OFFSET OF FUNCTION AREA (QUADS, LONG)
00002   FFFF FF1A              	QSOFF	EQU	QFOFF-4		* OFFSET OF STRING AREA (QUADS, LONG)
00002
00002                          	* WIND1				* [DEAD]
00002                          	* ROW0				* WINDOW 0 (SAVED) CURSOR POSITION
00002                          	* COL0
00002                          	* ROW1				* WINDOW 1 (SAVED) CURSOR POSITION
00002                          	* COL1
00002                          	* LINES				* [MOVED INTO EACH WBLOCK]
00002
00002   FFFF FF18              	CURWIND	EQU	QSOFF-2		* CURRENT WINDOW
00002   FFFF FF14              	CURWP	EQU	CURWIND-4	* PTR TO CURWIND RECORD BLOCK
00002   FFFF FEF4              	WBLOCKP	EQU	CURWP-(MAXWIND*4)	* PTRS TO ALL BLOCKS
00002   FFFF FEF2              	MSWIND	EQU	WBLOCKP-2	* CURRENT MOUSE WINDOW
00002
00002   FFFF FEF0              	INLAST  EQU	MSWIND-2	* INPUT SETS IT, OUTPUT CLEARS IT, QUIT CHECKS
00002   FFFF FEEE              	CHRTOT	EQU	INLAST-2	* TOTAL CHARS INPUT SO FAR DURING OPREAD
00002
00002   FFFF FEEC              	GAMFIL  EQU	CHRTOT-2	* REF NUMBER OF OPENED GAME FILE
00002   FFFF FEEA              	SAVFIL  EQU	GAMFIL-2	* REF NUMBER OF OPENED SAVE FILE
00002
00002   FFFF FEE6              	MSAVEB	EQU	SAVFIL-4	* PTR TO A RAM BUFFER FOR ISAVE/IRESTORE
00002   FFFF FEE4              	MSAVEF	EQU	MSAVEB-2	* FLAG, SET FOR ISAVE/IRESTORE
00002
00002                          	***

00002
00002   FFFF FEE2              	FONT	EQU	MSAVEF-2	* NONZERO WHEN USING SPECIAL (MONOSPACED) FONT
00002   FFFF FEDE              	MACBUF  EQU	FONT-4		* NEW VALUE FOR ENDBUF WHEN FONTSIZE CHANGES
00002
00002   FFFF FEDA              	APPARM  EQU	MACBUF-4	* HANDLE TO APPLICATION PARAMETERS
00002   FFFF FED6              	SHOWVE  EQU	APPARM-4	* POINTER TO "VERSION" STRING, ZERO IF NONE
00002
00002                          	***
00002
00002   FFFF FED4              	DBZPC1  EQU	SHOWVE-2	* BREAK WHEN ZPC REACHES THIS ADDRESS
00002   FFFF FED2              	DBZPC2  EQU	DBZPC1-2
00002   FFFF FED0              	DBINST  EQU	DBZPC2-2	* BREAK WHEN NEXT INSTRUCTION HAS THIS VALUE
00002
00002   FFFF FECC              	DBITOT  EQU	DBINST-4	* TOTAL INSTRUCTIONS EXECUTED
00002   FFFF FEC8              	DBIBRK  EQU	DBITOT-4	* BREAK AFTER THIS MANY INSTRUCTIONS
00002
00002   FFFF FEB8              	DBQUE	EQU	DBIBRK-DBQLEN	* CIRCULAR QUEUE FOR INST HISTORY
00002   FFFF FEB4              	DBQPTR	EQU	DBQUE-4		* PTR, NEXT OPEN SLOT IN QUEUE
00002   FFFF FEB0              	DBQEND	EQU	DBQPTR-4	* PTR, END OF QUEUE
00002
00002                          	***
00002
00002   0000 0150              	ZVLEN	EQU	0-DBQEND	* TOTAL LENGTH OF ZIP'S VARIABLES FRAME
00002
00002

00002                          	* ---------------------------------------------------------------------------
00002                          	* INITIALIZATIONS
00002                          	* ---------------------------------------------------------------------------
00002
00002                          	* LOW-CORE GAME VARIABLES
00002
00002   0000 0000              	PVERS1  EQU	0		* ZVERSION VERSION BYTE
00002   0000 0001              	PVERS2  EQU	1		* ZVERSION MODE BYTE
00002   0000 0002              	PZRKID  EQU	2		* ZORK ID
00002   0000 0004              	PENDLD  EQU	4		* ENDLOD (BYTE OFFSET)
00002   0000 0006              	PSTART  EQU	6		* START
00002   0000 0008              	PVOCTB  EQU	8		* VOCTAB
00002   0000 000A              	POBJTB  EQU	10		* OBJTAB
00002   0000 000C              	PGLOTB  EQU	12		* GLOTAB
00002   0000 000E              	PPURBT  EQU	14		* PURBOT
00002   0000 0010              	PFLAGS  EQU	16		* USER FLAGS WORD
00002   0000 0012              	PSERNM  EQU	18		* SERIAL NUMBER (6 BYTES)
00002   0000 0018              	PWRDTB  EQU	24		* WRDTAB
00002   0000 001A              	PLENTH  EQU	26		* LENGTH (EZIP QUADS, ZIP WORDS)
00002   0000 001C              	PCHKSM  EQU	28		* CHECKSUM (ALL BYTES STARTING WITH BYTE 64)
00002   0000 001E              	PINTWD  EQU	30		* INTERPRETER ID/VERSION
00002   0000 0020              	PSCRWD  EQU	32		* SCREEN SIZE, ROWS/COLUMNS
00002
00002                          	* FOR XZIP:
00002
00002   0000 0022              	PHWRD	EQU	2*17	**	* WIDTH OF DISPLAY, IN PIXEL UNITS
00002   0000 0024              	PVWRD	EQU	2*18	**	* HEIGHT OF DISPLAY, IN PIXEL UNITS
00002   0000 0026              	PFWRD	EQU	2*19	**	* FONT HEIGHT, WIDTH
00002                          	* PLMRG	EQU	2*20	* DEAD	* LEFT MARGIN, IN PIXEL UNITS
00002                          	* PRMRG	EQU	2*21	* DEAD	* RIGHT MARGIN, IN PIXEL UNITS
00002   0000 002C              	PCLRWRD	EQU	2*22		* COLOR, BACKGROUND/FOREGROUND
00002   0000 002E              	PTCHARS	EQU	2*23		* BYTE PTR, TABLE OF TERMINATING CHARACTERS
00002   0000 0030              	PCRCNT  EQU	2*24	**	* CR COUNTER
00002   0000 0032              	PCRFUNC EQU	2*25	**	* CR FUNCTION
00002   0000 0034              	PCHRSET	EQU	2*26		* BYTE PTR, CHAR SET TABLE
00002   0000 0036              	PLCTBL	EQU	2*27		* BYTE PTR, LOW-CORE VARS EXTENSION TABLE
00002
00002                          	* FOR YZIP (REPLACEMENTS FOR ABOVE):
00002
00002   0000 0028              	PFOFF	EQU	2*20		* OFFSET OF FUNCTION AREA (x8)
00002   0000 002A              	PSOFF	EQU	2*21		* OFFSET OF STRING AREA (x8)
00002
00002                          	* LOW CORE EXTENSION TABLE VARIABLES
00002                          	*   (WORD OFFSETS -- ACCESS THROUGH 'LOWCORE' ROUTINE)
00002
00002   0000 0000              	PLCLEN	EQU	0		* TABLE LENGTH, IN WORDS
00002   0000 0001              	PMLOCX	EQU	1		* MOUSE LOCATION WHEN LAST CLICKED
00002   0000 0002              	PMLOCY	EQU	2
00002
00002                          	* "PFLAGS" BIT DEFINITIONS
00002
00002                          	* FSCRI	EQU	0	* INTERPRETER CURRENTLY SCRIPTING   >> DEAD <<
00002   0000 0001              	FFIXE	EQU	1	* FIXED-WIDTH FONT NEEDED
00002   0000 0002              	FSTAT	EQU	2	* REQUEST FOR STATUS LINE REFRESH
00002   0000 0003              	FDISP	EQU	3	* GAME USES DISPLAY OPS
00002   0000 0004              	FUNDO	EQU	4	* GAME USES UNDO
00002   0000 0005              	FMOUS	EQU	5	* GAME USES MOUSE
00002
00002                          	* MICRO'S ID CODE, INTERPRETER VERSION LETTER (SEE ALSO OPVERI)
00002
00000                          	    DATA
00000   03                     	INTWRD	DC.B	3	* MACHINE ID FOR MACINTOSH
00001   44                     		DC.B	'D'	* XZIP INTERPRETER VERSION
00002   0000                   	SUBVER	DC.W	0	* INTRPRETER SUB-VERSION, ZERO TO DISABLE
00002                          	    CODE
00002
00002                          	* INITIAL SET OF READ BREAK CHARS -- SPACE, TAB, CR, <.>, <,>, <?>
00002
00004                          	    DATA
00004   20 09 0D 2E 2C         	IRBRKS	DC.B	$20,$09,$0D,$2E,$2C,$3F,0	 * ASCIZ
00002                          	    CODE
00002
00002   0000 0006              	ZMVERS  EQU	6		* 'YZIP' Z-MACHINE VERSION NUMBER
00002   0000 0400              	STKLEN  EQU	512*2		* LENGTH OF GAME STACK  (MULTIPLE OF 512)
00002   0000 0002              	PAGMIN	EQU	2		* MINIMUM # PAGES (NEEDED BY $VER)

00002
00002                          	* ----------------------
00002                          	* ZSTART
00002                          	* ----------------------
00002
00002   4E56 FEB0              	ZSTART	LINK	A6,#-ZVLEN	* CREATE A FRAME FOR ZIP VARIABLES
00006 G 204E                   		MOVE.L  A6,A0		* TOP OF FRAME
00008
00008   303C 00A8              		MOVE.W  #ZVLEN/2,D0
0000C   4260                   	STRX1	CLR.W	-(A0)		* ALL INITIAL VALUES ARE ZERO
0000E   5340                   		SUBQ.W  #1,D0
00010   66FA            0000C  		BNE	STRX1
00012
00012   2D4F FFC2              		MOVE.L  SP,TOPSP(A6)	* SAVE THE SP FOR RESTARTS
00016   41ED 0352              		LEA	ZVARS,A0
0001A   208E                   		MOVE.L  A6,(A0)		* COPY A6 FOR EXTERNAL CALLS INTO ZIP ROUTINES
0001C
0001C                          	*** careful about error msgs before screen & buffers are initialized ...
0001C
0001C   3D7C 0001 FF68         		MOVE.W	#1,VOCONS(A6)	* OUTPUT ERRORS TO SCREEN FOR NOW (NO BUFFER)
00022   3D7C 0001 FF58         		MOVE.W	#1,VIECHO(A6)	* INPUT IS NORMALLY ECHOED
00028
00028                          	***	MOVE.W	#1,WIND1(A6)	* AVOID PUTCHR/TSTSCR (CZIP ONLY) BUG DURING INIT
00028   6100 234A       02374  		BSR	SYSIN1		* OPEN GAME FILE, WINDOW, ETC
0002C
0002C                          	* SET UP ZIP DEBUGGER (IF REQUESTED)
0002C
0002C                          	    IF DEBUG THEN
0002C                          	    ENDIF
0002C
0002C                          	*** READ GAME BLOCK 0 INTO A TEMP STACK BUFFER  ...
0002C
0002C   9EFC 0200              		SUBA.W  #512,SP		* CREATE THE BUFFER
00030 G 284F                   		MOVE.L  SP,A4		* SAVE POINTER HERE FOR NOW
00032
00032 G 204C                   		MOVE.L  A4,A0
00034   4240                   		CLR.W	D0		* BLOCK 0
00036   6100 27C8       02800  		BSR	GETBLK		* GET IT
0003A
0003A                          	*** CHECK FOR ID CODE ...
0003A
0003A   0C14 0006              		CMPI.B  #ZMVERS,(A4)	* PROPER Z-MACHINE VERSION?
0003E   670A            0004A  		BEQ.S	STRX3		* YES
00040
00040   4240                   	STRX2	CLR.W	D0		* SOMETHING WRONG, DIE
00042   41ED 000B              		LEA	MSGZMV,A0
00046   6000 2710       02758  		BRA	FATAL		* 'Wrong Z-machine'
0000B                          	    DATA
0000B   57726F6E67205A         	MSGZMV	DC.B	'Wrong Z-machine version',0
0004A                          	    CODE
0004A
0004A   3D6C 0002 FFFE         	STRX3	MOVE.W  PZRKID(A4),ZORKID(A6)  * UNIQUE GAME ID, CHECKED BY "RESTORE"
00050
00050   7000                   		MOVEQ	#0,D0
00052   302C 000E              		MOVE.W  PPURBT(A4),D0	* GET PURBOT BYTE POINTER
00056   6100 0362       003BA  		BSR	BYTBLK		* ROUND UP TO NEXT BLOCK BOUNDARY
0005A   3D40 FFF8              		MOVE.W  D0,PURBOT(A6)	* >> here for undo, below <<
0005E
0005E                          	* Allocate an "undo" buffer, if requested.  This allocation (now) comes
0005E                          	* BEFORE the preload/paging allocations.  It should really get skipped if
0005E                          	* it would leave either () not enough for preload, or () a critically low
0005E                          	* (defined in some heuristic way) amount for paging.
0005E
0005E   7200                   		MOVEQ	#0,D1		* ASSUME NO UNDO
00060   302C 0010              		MOVE.W  PFLAGS(A4),D0
00064   0800 0004              		BTST	#FUNDO,D0	* DOES THIS GAME USE UNDO?
00068   6718            00082  		BEQ.S	STRX3B		* NO
0006A
0006A   302E FFF8              	STRX3A	MOVE.W	PURBOT(A6),D0	* BLOCKS
0006E   5480                   		ADDQ.L	#STKLEN/512,D0
00070   6100 0340       003B2  		BSR	BLKBYT		* TOTAL BYTES NEEDED FOR AN UNDO-SAVE
00074   6100 2322       02398  		BSR	GETM		* GET IT, WITHOUT ERROR TRAPPING
00078   6708            00082  		BEQ.S	STRX3B		* ZERO: NOT ENOUGH MEM
0007A
0007A   4250                   		CLR.W	(A0)		* OK, MARK THE BUFFER AS EMPTY

0007C   2D48 FEE6              		MOVE.L	A0,MSAVEB(A6)	* AND STORE PTR
00080   7201                   		MOVEQ	#1,D1		* SUCCESS
00082   3001                   	STRX3B	MOVE.W	D1,D0
00084   6100 2288       0230E  		BSR	SETUNDO		* SET FLAG FOR PASCAL (MENU DISPLAY)
00088
00088                          	* ALLOC/INIT SOME WINDOW RECORDS (YZIP)
00088
00088   7208                   		MOVEQ	#MAXWIND,D1	* TOTAL RECORDS TO CREATE
0008A   43EE FEF4              		LEA	WBLOCKP(A6),A1
0008E
0008E   6100 021A       002AA  	INIWX1	BSR	INITWB		* CREATE A WINDOW RECORD
00092   22C8                   		MOVE.L	A0,(A1)+	*   AND STORE THE POINTER
00094   5341                   		SUBQ.W	#1,D1
00096   66F6            0008E  		BNE.S	INIWX1
00098
00098   6100 2100       0219A  		BSR	MAXSCRN		* GET D0.W = ROWS, D1.W = COLS
0009C   43EE FEF4              		LEA	WBLOCKP(A6),A1
000A0 G 2059                   		MOVE.L	(A1)+,A0	* GET POINTER TO WINDOW 0 RECORD
000A2
000A2   3140 0004              		MOVE.W	D0,WYSIZE(A0)	* WINDOW 0 GETS A FEW SPECIAL INIT VALS
000A6   3141 0006              		MOVE.W	D1,WXSIZE(A0)
000AA   0068 0003 001C         		ORI.W	#WFWRAP+WFSCRL,WATTR(A0)
000B0
000B0   2D48 FF14              		MOVE.L	A0,CURWP(A6)	* THIS IS INITIAL RECORD POINTER
000B4                          	*	CLR.W	CURWIND(A6)	* AND INITIAL WINDOW  [0 ALREADY]
000B4
000B4 G 2059                   		MOVE.L	(A1)+,A0	* GET POINTER TO WINDOW 1 RECORD
000B6   3141 0006              		MOVE.W	D1,WXSIZE(A0)	* IT GETS ONE SPECIAL INIT VAL
000BA
000BA                          	*** CHECK MEMORY, SET ENDLOD & PAGTOT, DO PRELOAD
000BA
000BA   6100 2320       023DC  	STRX4	BSR	MEMAVAIL	* DETERMINE HOW MUCH FREE MEMORY EXISTS
000BE   2E00                   		MOVE.L  D0,D7		* REMEMBER THE AMOUNT
000C0
000C0   7000                   		MOVEQ	#0,D0
000C2   302C 001A              		MOVE.W  PLENTH(A4),D0	* LENGTH OF GAME FILE (WORDS OR QUADS)
000C6   D080                   		ADD.L	D0,D0
000C8                          	    IF EZIP THEN
000C8   D080                   		ADD.L	D0,D0		* BYTES
000CA                          	    ENDIF
000CA
000CA                          	    IF DEBUG THEN
000CA                          	    ENDIF
000CA
000CA   B087                   		CMP.L	D7,D0		* ENOUGH ROOM TO PRELOAD ENTIRE GAME?
000CC   6D0E            000DC  		BLT.S	LOAD1		* YES
000CE
000CE   7000                   		MOVEQ	#0,D0
000D0   302C 0004              		MOVE.W  PENDLD(A4),D0	* LENGTH OF PRELOAD SEGMENT (BYTES)
000D4   B087                   		CMP.L	D7,D0		* ENOUGH ROOM FOR IT?
000D6   6D1A            000F2  		BLT.S	LOAD2		* YES
000D8
000D8   6000 22E4       023BE  		BRA	MEMERROR	* NO, FAIL
000DC
000DC                          	* WE HAVE MEGA-MEMORY, PRELOAD EVERYTHING ...
000DC
000DC   6100 02DC       003BA  	LOAD1	BSR	BYTBLK		* LENGTH OF GAME FILE (IN BLOCKS)
000E0   3D40 FFFA              		MOVE.W  D0,ENDLOD(A6)	* MAXIMIZE THE PRELOAD
000E4
000E4   3D7C 0002 FFCA         		MOVE.W  #PAGMIN,PAGTOT(A6)  * MINIMIZE THE PAGING SPACE (FOR $VER)
000EA   3D7C 0001 FFC6         		MOVE.W	#1,MAXFLG(A6)	* SET FLAG
000F0   601A            0010C  		BRA.S	LOAD3
000F2
000F2                          	* WE HAVE LIMITED MEMORY, PRELOAD ONLY WHAT'S NEEDED
000F2
000F2   9E80                   	LOAD2	SUB.L	D0,D7		* FIRST DETERMINE MEMORY LEFT AFTER PRELOAD
000F4   6100 02C4       003BA  		BSR	BYTBLK
000F8   3D40 FFFA              		MOVE.W  D0,ENDLOD(A6)	* LENGTH OF PRELOAD (IN BLOCKS)
000FC
000FC   8EFC 0208              		DIVU	#512+8,D7	* PAGES AVAIL (ALLOW 8 BYTES PER TABLE ENTRY)
00100   0C47 0002              		CMPI.W  #2,D7
00104   6C02            00108  		BGE.S	LOADX1
00106   7E02                   		MOVEQ	#2,D7		* MUST HAVE AT LEAST TWO (FOR $VERIFY)
00108   3D47 FFCA              	LOADX1	MOVE.W  D7,PAGTOT(A6)	* MAXIMIZE THE PAGING SPACE
0010C

0010C   302E FFFA              	LOAD3	MOVE.W  ENDLOD(A6),D0	* SPACE NEEDED FOR PRELOAD, IN BLOCKS
00110   6100 02A0       003B2  		BSR	BLKBYT		* CONVERT TO BYTES
00114   6100 22A0       023B6  		BSR	GETMEM		* GET IT
00118
00118   2D48 FFA8              		MOVE.L  A0,BUFFER(A6)	* SAVE POINTER
0011C G 2848                   		MOVE.L  A0,A4		* ALSO HERE FOR REMAINING INIT
0011E
0011E   322E FFFA              		MOVE.W  ENDLOD(A6),D1	* NUMBER OF BLOCKS TO PRELOAD
00122   4240                   		CLR.W	D0		* STARTING WITH BLOCK 0
00124   6100 26EA       02810  		BSR	GTBLKS		* READ THEM IN
00128
00128                          	***	CLR.W	WIND1(A6)	* RESTORE NORMAL VALUE (AFTER PREV KLUGE)
00128
00128                          	* ------------------------------------------------------------------------
00128
00128                          	*** INITIALIZE MAJOR TABLE POINTERS
00128
00128   7000                   	STRX6	MOVEQ	#0,D0
0012A   302C 0008              		MOVE.W  PVOCTB(A4),D0	* RELATIVE VOCAB TABLE POINTER
0012E   D08C                   		ADD.L	A4,D0		* ABSOLUTIZE IT
00130   2D40 FFF4              		MOVE.L  D0,VOCTAB(A6)	* AND SAVE IT
00134
00134   7000                   		MOVEQ	#0,D0
00136   302C 000A              		MOVE.W  POBJTB(A4),D0	* RELATIVE OBJECT TABLE POINTER
0013A   D08C                   		ADD.L	A4,D0
0013C   2D40 FFF0              		MOVE.L  D0,OBJTAB(A6)
00140   6100 020A       0034C  		BSR	EZERR		* CHECK OBJTAB ALIGNMENT
00144
00144   7000                   		MOVEQ	#0,D0
00146   302C 000C              		MOVE.W  PGLOTB(A4),D0	* RELATIVE GLOBAL TABLE POINTER
0014A   D08C                   		ADD.L	A4,D0
0014C   2D40 FFEC              		MOVE.L  D0,GLOTAB(A6)
00150
00150   7000                   		MOVEQ	#0,D0
00152   302C 0018              		MOVE.W  PWRDTB(A4),D0	* RELATIVE WORD TABLE POINTER
00156   D08C                   		ADD.L	A4,D0
00158   2D40 FFE8              		MOVE.L  D0,WRDTAB(A6)
0015C
0015C                          	* AND SEGMENT OFFSETS
0015C
0015C   7000                   		MOVEQ	#0,D0
0015E   302C 0028              		MOVE.W	PFOFF(A4),D0	* OFFSET OF FUNCTION AREA ("OCTS")
00162   D080                   		ADD.L	D0,D0		* STORE AS QUADS (LONG)
00164   2D40 FF1E              		MOVE.L	D0,QFOFF(A6)
00168
00168   7000                   		MOVEQ	#0,D0
0016A   302C 002A              		MOVE.W	PSOFF(A4),D0	* OFFSET OF STRING AREA ("OCTS")
0016E   D080                   		ADD.L	D0,D0		* STORE AS QUADS (LONG)
00170   2D40 FF1A              		MOVE.L	D0,QSOFF(A6)
00174
00174                          	*** ALLOCATE MEMORY FOR Z STACK
00174
00174   203C 0000 0400         		MOVE.L  #STKLEN,D0
0017A   6100 223A       023B6  		BSR	GETMEM
0017E   2D48 FFBE              		MOVE.L  A0,STKBOT(A6)	* THIS WILL BE BOTTOM OF GAME STACK
00182
00182                          	*** INITIALIZE LINE BUFFER, SCRIPT BUFFER
00182
00182   0000 00A0              	MAXLEN  EQU	160		* MAX LENGTH OF LINE BUFFER (BYTES)
00182   0000 0041              	SCRLEN  EQU	65  ** 80	* LENGTH OF SCRIPT BUFFER (BYTES)
00182
00182   6100 2016       0219A  		BSR	MAXSCRN		* FULL SCREEN WIDTH (UNITS)
00186   3401                   		MOVE.W	D1,D2
00188   323C 00A0              		MOVE.W	#MAXLEN,D1	* (BYTES)
0018C   43FA 2572       02700  		LEA	LINOUT,A1	* SCREEN DISPLAY FUNCTION
00190   45FA 2272       02404  		LEA	DCHSIZ,A2
00194   6100 1CFC       01E92  		BSR	INITQP		* SET UP DISPLAY QUEUE STUFF
00198   2D48 FF54              		MOVE.L	A0,DQUE(A6)	* SAVE BLOCK POINTER
0019C
0019C   323C 0041              		MOVE.W	#SCRLEN,D1	* SCRIPTING WIDTH, NEVER CHANGES
001A0   3401                   		MOVE.W	D1,D2
001A2   43FA 25F4       02798  		LEA	SCROUT,A1	* SCRIPTING DISPLAY FUNCTION
001A6   45FA 226E       02416  		LEA	SCHSIZ,A2
001AA   6100 1CE6       01E92  		BSR	INITQP		* SET UP SCRIPT QUEUE STUFF
001AE   2D48 FF50              		MOVE.L	A0,SQUE(A6)	* SAVE THIS POINTER TOO

001B2
001B2                          	* AND SET UP MACBUF ...
001B2
001B2                          	* ALLOCATE AND SET UP BREAK-CHAR TABLE
001B2
001B2 G 7040                   		MOVE.L	#64,D0		* MAX BREAK CHARS
001B4   6100 2200       023B6  		BSR	GETMEM		* ALLOCATE BUFFER FOR BREAK-CHAR TABLE
001B8   2D48 FFE4              		MOVE.L	A0,RBRKS(A6)
001BC
001BC G 226E FFF4              		MOVE.L	VOCTAB(A6),A1	* (DEFAULT) VOCAB TABLE
001C0   4240                   		CLR.W	D0
001C2   1019                   		MOVE.B	(A1)+,D0	* FIRST BYTE OF VOCTAB IS # OF SI BREAK CHARS
001C4   6002            001C8  		BRA.S	STRX11		* (ZERO CHECK)
001C6
001C6   10D9                   	STRX10	MOVE.B	(A1)+,(A0)+	* TRANSFER SI BREAKS FIRST
001C8   51C8 FFFC       001C6  	STRX11	DBF	D0,STRX10
001CC   2D48 FFE0              		MOVE.L	A0,ESIBKS(A6)	* REMEMBER END OF SI BREAKS
001D0
001D0   45ED 0004              		LEA	IRBRKS,A2	* THESE ARE THE "NORMAL" BREAK CHARS
001D4   10DA                   	STRX12	MOVE.B	(A2)+,(A0)+	* TRANSFER THEM TOO
001D6   66FC            001D4  		BNE	STRX12		* ASCIZ
001D8
001D8                          	*** ALLOCATE MEMORY FOR PAGE TABLE & BUFFERS
001D8
001D8   302E FFCA              		MOVE.W  PAGTOT(A6),D0	* PREVIOUSLY CALCULATED NUMBER OF PAGE BUFFERS
001DC   C0FC 0008              		MULU	#8,D0		* 8-BYTE TABLE ENTRY FOR EACH PAGE
001E0   5480                   		ADDQ.L  #2,D0		* ALLOW FOR THE END MARK
001E2   6100 21D2       023B6  		BSR	GETMEM
001E6   2D48 FFD0              		MOVE.L  A0,PAGTAB(A6)	* THIS WILL BE START OF PAGE TABLE
001EA
001EA   302E FFCA              		MOVE.W  PAGTOT(A6),D0	* PREVIOUSLY CALCULATED NUMBER OF PAGE BUFFERS
001EE   C0FC 0200              		MULU	#512,D0		* 512 BYTES EACH
001F2   6100 21C2       023B6  		BSR	GETMEM
001F6   2D48 FFCC              		MOVE.L  A0,PAGES(A6)	* PAGES THEMSELVES WILL START HERE
001FA
001FA                          	*** INITIALIZE THE PAGE TABLE
001FA
001FA   302E FFCA              		MOVE.W  PAGTOT(A6),D0	* PREVIOUSLY CALCULATED NUMBER OF PAGE BUFFERS
001FE G 206E FFD0              		MOVE.L  PAGTAB(A6),A0
00202
00202   30FC FFFE              	STRX16  MOVE.W  #-2,(A0)+	* BLOCK (NO BLOCK "$FFFE")
00206   4298                   		CLR.L	(A0)+		* REF TIME IS ZERO
00208   4258                   		CLR.W	(A0)+		* THIS SLOT UNUSED (BUT 8 BYTES SPEEDS CALCS)
0020A   5340                   		SUBQ.W  #1,D0
0020C   66F4            00202  		BNE	STRX16
0020E   30BC FFFF              		MOVE.W  #-1,(A0)	* MARK THE END OF THE TABLE (NO BLOCK "$FFFF")
00212
00212   3D7C FFFF FF42         		MOVE.W  #-1,CURBLK(A6)  * MUST INIT THESE PAGING VARS TOO!
00218   3D7C FFFF FF38         		MOVE.W  #-1,LPAGE(A6)
0021E
0021E                          	* ETCETERA ...
0021E
0021E   6100 21D8       023F8  	STRX17	BSR	GTSEED		* INITIALIZE THE RANDOM NUMBER SEEDS
00222   3D40 FFB2              		MOVE.W  D0,RSEED1(A6)
00226   4840                   		SWAP	D0
00228   3D40 FFB0              		MOVE.W  D0,RSEED2(A6)	* PUT HIGH WORD HERE, "RELATIVELY CONSTANT"
0022C
0022C   3D7C 0001 FF5A         		MOVE.W	#1,VOBUFF(A6)	* BEGIN BUFFERING OUTPUT
00232
00232   6100 213E       02372  		BSR	ENDTITLE	* PAUSE FOR TITLE SCREEN, IF SHOWING
00236   601A            00252  		BRA.S	START1
00238
00238                          	* ----------------------
00238                          	* RESTRT
00238                          	* ----------------------
00238
00238                          	* RESTART EXECUTION HERE
00238
00238 G 206E FFA8              	RESTRT	MOVE.L  BUFFER(A6),A0
0023C   3F28 0010              		MOVE.W  PFLAGS(A0),-(SP)  * PRESERVE THE USER FLAGS (SCRIPT ETC)
00240
00240   4240                   		CLR.W	D0		* REREAD ALL OF THE IMPURE STUFF
00242   322E FFF8              		MOVE.W  PURBOT(A6),D1
00246   6100 25C8       02810  		BSR	GTBLKS
0024A

0024A G 206E FFA8              		MOVE.L  BUFFER(A6),A0
0024E   315F 0010              		MOVE.W  (SP)+,PFLAGS(A0)  * RESTORE FLAGS
00252
00252 G 2E6E FFC2              	START1	MOVE.L  TOPSP(A6),SP	* RESET SYSTEM STACK POINTER
00256
00256 G 206E FF54              		MOVE.L	DQUE(A6),A0
0025A   2150 0004              		MOVE.L	BUFPTR(A0),NXTPTR(A0)	* INITIALIZE OUTPUT BUFFER POINTER
0025E
0025E G 286E FFBE              		MOVE.L  STKBOT(A6),A4
00262   D8FC 0400              		ADDA.W  #STKLEN,A4	* INITIALIZE GAME STACK POINTER
00266   2D4C FFB4              		MOVE.L  A4,ZLOCS(A6)	* INITIALIZE POINTER TO LOCALS/FRAME
0026A G 246E FFA8              		MOVE.L  BUFFER(A6),A2
0026E
0026E   002A 0002 0001         		ORI.B	#2,PVERS2(A2)		* DISPLAY OP IS AVAILABLE
00274   002A 003C 0001         		ORI.B	#32+16+8+4,PVERS2(A2)	* SOUND, MONOSPACE, ITALIC, BOLD
0027A
0027A   6100 0078       002F4  		BSR	INITDISP	* GET/STORE TTY-SPECIFIC LOWCORE VARS
0027E
0027E   356D 0000 001E         		MOVE.W  INTWRD,PINTWD(A2) * SET INTERPRETER ID/VERSION WORD
00284   426E FFAE              		CLR.W	RCYCLE(A6)	* ALWAYS RESTART WITH NORMAL RANDOMNESS
00288   3D7C 0001 FEF2         		MOVE.W	#1,MSWIND(A6)	* YZIP: INITIALLY CONSTRAIN MOUSE TO W1
0028E
0028E   302A 0006              		MOVE.W  PSTART(A2),D0	* GET STARTING LOCATION
00292   6100 02A6       0053A  		BSR	BSPLTB		* SPLIT BLOCK AND BYTE POINTERS
00296
00296   3D40 FFBC              		MOVE.W  D0,ZPC1(A6)	* INITIALIZE THE ZPC
0029A   3D41 FFBA              		MOVE.W  D1,ZPC2(A6)
0029E   6100 1E0A       020AA  		BSR	NEWZPC		* GET THE PAGE TO EXECUTE
002A2
002A2                          	* SYSIN2 SHOULD BE THE /LAST/ CALL BEFORE NXTINS, BECAUSE OF STACK HACKING
002A2                          	* (FOR KLUDGY TIMEOUTS) IN OPREST.
002A2
002A2   6100 2508       027AC  		BSR	SYSIN2		* MAC -- BUT LOAD A SAVED GAME IF REQUESTED
002A6   6000 18AC       01B54  		BRA	NXTINS		* TALLY HO
002AA
002AA                          	* ----------------------
002AA                          	* INITWB
002AA                          	* ----------------------
002AA
002AA                          	* ALLOCATE AND INITIALIZE A (GENERIC) WINDOW RECORD BLOCK
002AA                          	*   RETURN A0 -> BLOCK
002AA
002AA   48E7 4040              	INITWB	MOVEM.L	D1/A1,-(SP)
002AE   7022                   		MOVEQ	#WBLKLEN,D0	* SPACE FOR ONE BLOCK
002B0   6100 2104       023B6  		BSR	GETMEM		* GET IT
002B4 G 2248                   		MOVE.L	A0,A1		* SAVE HERE
002B6
002B6   7022                   		MOVEQ	#WBLKLEN,D0
002B8   4218                   	INWBX1	CLR.B	(A0)+		* ZERO THE BLOCK
002BA   5340                   		SUBQ.W	#1,D0
002BC   66FA            002B8  		BNE.S	INWBX1
002BE
002BE                          	* INIT ALL NON-ZERO SLOTS
002BE
002BE   7001                   		MOVEQ	#1,D0
002C0   3280                   		MOVE.W	D0,WYPOS(A1)	* EACH WINDOW LIVES INITIALLY AT 1,1
002C2   3340 0002              		MOVE.W	D0,WXPOS(A1)
002C6   3340 0008              		MOVE.W	D0,WYCURS(A1)	* CURSOR INITIALLY AT UPPER LEFT
002CA   3340 000A              		MOVE.W	D0,WXCURS(A1)
002CE
002CE   3340 0018              		MOVE.W	D0,WFONTID(A1)	* INITIALLY FONT #1
002D2   6100 1ED0       021A4  		BSR	GETFYX		* GET (DEFAULT) FONT SIZE
002D6   3340 001A              		MOVE.W	D0,WFONTYX(A1)
002DA
002DA   7000                   		MOVEQ	#0,D0		* GET DEFAULT COLORS
002DC   7200                   		MOVEQ	#0,D1
002DE   6100 2046       02326  		BSR	MDCOLOR
002E2   3340 0016              		MOVE.W	D0,WCOLOR(A1)	* (BACK/FORE)
002E6
002E6   337C 0008 001C         		MOVE.W	#WFBUFF,WATTR(A1)  * BUFFERING ON
002EC
002EC G 2049                   		MOVE.L	A1,A0		* RETURN PTR
002EE   4CDF 0202              		MOVEM.L	(SP)+,D1/A1
002F2   4E75                   		RTS
002F4

002F4                          	* ----------------------
002F4                          	* INITDISP
002F4                          	* ----------------------
002F4
002F4                          	* GET/STORE TTY-SPECIFIC LOWCORE VARS
002F4                          	* [MAY CHANGE BETWEEN MAC & MACII -- ALSO CALLED AFTER RESTORE]
002F4
002F4                          	INITDISP
002F4   48E7 7020              		MOVEM.L	D1-D3/A2,-(SP)
002F8 G 246E FFA8              		MOVE.L  BUFFER(A6),A2
002FC
002FC   6100 1EA6       021A4  		BSR	GETFYX
00300   3540 0026              		MOVE.W	D0,PFWRD(A2)	* FONT SIZE, HEIGHT/WIDTH (PIXELS)
00304                          	***	MOVE.W	D0,D2
00304                          	***	ROR.W	#8,D2		* SWAP BYTES (BUG IN YZIP20)
00304                          	***	MOVE.W	D2,PFWRD(A2)
00304
00304                          	** PFWRD/PVWRD/PHWRD DEAD IN 'YZIP', BUT KEEP FOR NOW, FOR BACKWARD COMPAT ...
00304
00304   3400                   		MOVE.W	D0,D2
00306   3600                   		MOVE.W	D0,D3
00308   E04A                   		LSR.W	#8,D2		* UNPACK HEIGHT
0030A   0243 00FF              		ANDI.W	#$FF,D3		* UNPACK WIDTH
0030E
0030E   6100 1E8A       0219A  		BSR	MAXSCRN		* SCREEN SIZE, PIXELS
00312   3540 0024              		MOVE.W	D0,PVWRD(A2)
00316   3541 0022              		MOVE.W	D1,PHWRD(A2)
0031A
0031A   48C0                   		EXT.L	D0
0031C   80C2                   		DIVU	D2,D0
0031E   E148                   		LSL.W	#8,D0		* ROWS (ROUNDED DOWN) IN HIGH BYTE
00320   48C1                   		EXT.L	D1
00322   82C3                   		DIVU	D3,D1
00324   1001                   		MOVE.B	D1,D0		* COLUMNS IN LOW
00326   3540 0020              		MOVE.W	D0,PSCRWD(A2)	* SCREEN SIZE, CHARS
0032A
0032A                          	* INIT COLOR STUFF TOO
0032A
0032A   7000                   		MOVEQ	#0,D0		* GET DEFAULT COLORS (OR BLACK/WHITE)
0032C   7200                   		MOVEQ	#0,D1
0032E   6100 1FF6       02326  		BSR	MDCOLOR
00332   3540 002C              		MOVE.W	D0,PCLRWRD(A2)	* (BACK/FORE)
00336
00336   022A 00FE 0001         		ANDI.B	#$FE,PVERS2(A2)	* ASSUME COLOR UNAVAILABLE (FORCE BIT -> 0)
0033C   4A41                   		TST.W	D1		* MONO MACHINE?
0033E   6706            00346  		BEQ.S	IDSPX9
00340   002A 0001 0001         		ORI.B	#1,PVERS2(A2)	* NO, COLOR IS AVAILABLE
00346
00346   4CDF 040E              	IDSPX9	MOVEM.L	(SP)+,D1-D3/A2
0034A   4E75                   		RTS
0034C
0034C                          	* ----------------------
0034C                          	* EZERR
0034C                          	* ----------------------
0034C
0034C                          	    IF EZIP THEN
0034C                          	* FOR EZIP/XZIP, MAKE SURE D0.L = OBJ TABLE BASE IS WORD ALIGNED
0034C
0034C   0800 0000              	EZERR	BTST	#0,D0		* WORD ALIGNED?
00350   6602            00354  		BNE.S	EZERX1		* NO, FAIL
00352   4E75                   		RTS
00354
00354   4240                   	EZERX1	CLR.W	D0
00356   41ED 0023              		LEA	MSGEZR,A0
0035A   6000 23FC       02758  		BRA	FATAL		* 'OBJTAB align err'
0035E
00023                          	    DATA
00023   4F424A54414220         	MSGEZR	DC.B	'OBJTAB align err',0
0035E                          	    CODE
0035E
0035E                          	    ENDIF
0035E

0035E                          	* ---------------------------------------------------------------------------
0035E                          	* MISC FUNCTIONS
0035E                          	* ---------------------------------------------------------------------------
0035E
0035E                          	* ------------------------------
0035E                          	* COPYB
0035E                          	* ------------------------------
0035E
0035E                          	* COPY BYTES
0035E                          	* GIVEN A0 -> SRC, D0 = LEN, A1 -> DEST
0035E
0035E   12D8                   	CPBX1	MOVE.B	(A0)+,(A1)+	* COPY THEM
00360   51C8 FFFC       0035E  	COPYB	DBF	D0,CPBX1	* ZERO CHECK  << ENTRY POINT >>
00364   4E75                   		RTS
00366
00366                          	* ------------------------------
00366                          	* COPYS
00366                          	* ------------------------------
00366
00366                          	* COPY A STRING, AND TACK ON A NULL BYTE
00366                          	* GIVEN A0 -> SRC, A1 -> DEST, D0 = LEN, D1 = MAX LEN
00366
00366   B041                   	COPYS	CMP.W	D1,D0		* LEN WITHIN MAX?
00368   6F02            0036C  		BLE.S	CPSX1
0036A   3001                   		MOVE.W	D1,D0		* NO, TRUNCATE IT
0036C   6002            00370  	CPSX1	BRA.S	CPSX3		* ZERO CHECK
0036E
0036E   12D8                   	CPSX2	MOVE.B	(A0)+,(A1)+
00370   51C8 FFFC       0036E  	CPSX3	DBF	D0,CPSX2
00374   4211                   		CLR.B	(A1)		* ASCIZ
00376   4E75                   		RTS
00378
00378                          	* --------------------------
00378                          	* COMPS
00378                          	* --------------------------
00378
00378                          	* COMPARE STRINGS, PTRS IN A0 AND A1, LENGTHS IN D0.W
00378                          	* RETURN FLAGS, 'EQ' IF SAME
00378
00378   4A40                   	COMPS	TST.W	D0
0037A   6F08            00384  		BLE.S	CMPSX4		* ZERO CHECK
0037C G B308                   	CMPSX2	CMP.B	(A0)+,(A1)+
0037E   6604            00384  		BNE.S	CMPSX4		* MISMATCH, RETURN "DIFFERENT"
00380   5340                   		SUBQ.W	#1,D0
00382   66F8            0037C  		BNE.S	CMPSX2		* IF DONE, RETURN "SAME"
00384   4E75                   	CMPSX4	RTS
00386
00386                          	* ----------------------
00386                          	* STRLEN
00386                          	* ----------------------
00386
00386                          	* FIND LENGTH OF AN NULL-TERMINATED STRING, POINTER IN A0
00386                          	*   RETURN POINTER IN A0, LENGTH IN D0
00386
00386   2F08                   	STRLEN	MOVE.L	A0,-(SP)	* SAVE START
00388   4A18                   	STRLX1  TST.B	(A0)+		* SEARCH FOR NULL
0038A   66FC            00388  		BNE.S	STRLX1
0038C   2008                   		MOVE.L	A0,D0		* FOUND IT
0038E   5380                   		SUBQ.L	#1,D0		* BACKUP TO THE NULL
00390 G 205F                   		MOVE.L	(SP)+,A0	* RETURN ORIGINAL POINTER
00392   9088                   		SUB.L	A0,D0		* RETURN LENGTH
00394   4E75                   		RTS
00396
00396                          	* ------------------------------
00396                          	* RELABS [RRELABS]
00396                          	* ------------------------------
00396
00396                          	* CONVERT A RELATIVE (BYTE) OFFSET (D0.W) TO AN ABSOLUTE PTR (A0)
00396
00396 G 206E FFA8              	RELABS	MOVE.L	BUFFER(A6),A0
0039A                          	***	CMP.W	PPURBT(A0),D0	* MAX FOR READ/WRITE
0039A   B068 0004              		CMP.W	PENDLD(A0),D0	* MAX FOR READ-ONLY (USED BY OPLEX!)
0039E   620A            003AA  		BHI.S	RLBSX2		* REQUEST TOO HIGH
003A0
003A0   4840                   	RLBSX1	SWAP	D0

003A2   4240                   		CLR.W	D0		* ZERO THE HIGH WORD (NO SIGN-EXTENDING)
003A4   4840                   		SWAP	D0		*   [14 cycles vs 16]
003A6   D1C0                   		ADDA.L	D0,A0		* ABSOLUTIZE IT
003A8   4E75                   		RTS
003AA
003AA   41ED 0034              	RLBSX2	LEA	MSGRLB,A0
003AE                          	***	CLR.W	D0
003AE   6000 23A8       02758  		BRA	FATAL
00034                          	    DATA
00034   4F7574206F6620         	MSGRLB	DC.B	'Out of range in RELABS',0
003B2                          	    CODE
003B2
003B2                          	* ----------------------
003B2                          	* BLKBYT
003B2                          	* ----------------------
003B2
003B2                          	* GIVEN A ZIP BLOCK COUNT IN D0.W, RETURN A BYTE COUNT IN D0.L
003B2
003B2   48C0                   	BLKBYT	EXT.L	D0		* CLEAR HIGH WORD
003B4   4840                   		SWAP	D0
003B6   EE88                   		LSR.L	#7,D0		* x512
003B8   4E75                   		RTS
003BA
003BA                          	* ----------------------
003BA                          	* BYTBLK
003BA                          	* ----------------------
003BA
003BA                          	* GIVEN A BYTE COUNT IN D0.L, RETURN A ZIP BLOCK COUNT IN D0.W, ROUNDING UP
003BA
003BA   3F00                   	BYTBLK  MOVE.W  D0,-(SP)	* SAVE LOW WORD
003BC   E088                   		LSR.L	#8,D0
003BE   E288                   		LSR.L	#1,D0		* EXTRACT BLOCK NUMBER
003C0
003C0   025F 01FF              		ANDI.W  #$01FF,(SP)+	* EXACT MULTIPLE OF 512?
003C4   6702            003C8  		BEQ.S	BYTBX1		* YES
003C6   5240                   		ADDQ.W  #1,D0		* NO, ROUND UP TO NEXT BLOCK
003C8   4E75                   	BYTBX1	RTS
003CA
003CA                          	* ----------------------
003CA                          	* LOWCORE
003CA                          	* ----------------------
003CA
003CA                          	* USE THIS ROUTINE TO ACCESS LOW-CORE EXTENSION-TABLE VARS
003CA
003CA                          	* GIVEN D0 = VAR (WORD OFFSET)
003CA                          	* RETURN A0 (MAY BE ODD) -> VAR, AND FLAGS (ZERO IF INVALID VAR)
003CA
003CA   48E7 4000              	LOWCORE	MOVEM.L	D1,-(SP)
003CE   3200                   		MOVE.W	D0,D1
003D0 G 206E FFA8              		MOVE.L	BUFFER(A6),A0
003D4   7000                   		MOVEQ	#0,D0		* GET EXTENSION TABLE OFFSET (MAY BE >32K, ODD)
003D6   3028 0036              		MOVE.W	PLCTBL(A0),D0	* EXISTS?
003DA   6712            003EE  		BEQ.S	LWCX1		* NO, ERROR
003DC
003DC   D1C0                   		ADDA.L	D0,A0		* TABLE BASE
003DE   6100 0016       003F6  		BSR	GTAWRD		* TABLE LEN (WORDS)
003E2   B240                   		CMP.W	D0,D1		* ENOUGH?
003E4   6E08            003EE  		BGT.S	LWCX1		* NO, ERROR
003E6
003E6   5588                   		SUBQ.L	#2,A0
003E8   D241                   		ADD.W	D1,D1		* BYTE OFFSET
003EA   D0C1                   		ADDA.W	D1,A0		* POINT TO DESIRED VAR
003EC   6002            003F0  		BRA.S	LWCX2		* NONZERO FLAGS
003EE
003EE   7000                   	LWCX1	MOVEQ	#0,D0		* ZERO FLAGS
003F0   4CDF 0002              	LWCX2	MOVEM.L	(SP)+,D1	* DON'T DISTURB FLAGS
003F4   4E75                   		RTS
003F6
003F6                          	* ----------------------
003F6                          	* GTAWRD
003F6                          	* ----------------------
003F6
003F6                          	* GET CORE WORD, ABSOLUTE POINTER IN A0, RETURN THE WORD IN D0, UPDATE POINTER
003F6
003F6                          	GTAWRD

003F6   1018                   		MOVE.B  (A0)+,D0	* GET HIGH-ORDER BYTE, ADVANCE A0
003F8   E140                   		ASL.W	#8,D0		* POSITION IT
003FA   1018                   		MOVE.B  (A0)+,D0	* GET LOW-ORDER BYTE, ADVANCE A0
003FC   4E75                   		RTS
003FE
003FE                          	* ----------------------
003FE                          	* PTAWRD
003FE                          	* ----------------------
003FE
003FE                          	* WRITE WORD TO CORE, ABSOLUTE POINTER IN A0, VALUE IN D0, UPDATE A0
003FE
003FE                          	PTAWRD
003FE   1140 0001              		MOVE.B  D0,1(A0)	* STORE LOW-ORDER BYTE
00402   E040                   		ASR.W	#8,D0
00404   1080                   		MOVE.B  D0,(A0)		* STORE HIGH-ORDER BYTE
00406   5488                   		ADDQ.L	#2,A0
00408   4E75                   		RTS
0040A
0040A                          	* ---------------------------------------------------------------------------
0040A                          	* LOW LEVEL ZIP FUNCTIONS
0040A                          	* ---------------------------------------------------------------------------
0040A
0040A                          	* ----------------------
0040A                          	* GETBYT
0040A                          	* ----------------------
0040A
0040A                          	* GET A BYTE FROM GAME, BLOCK-POINTER IN D0, BYTE-POINTER IN D1, RESULT IN D2
0040A                          	*   UPDATE D0 AND D1 TO REFLECT BYTE GOTTEN
0040A
0040A   3F00                   	GETBYT  MOVE.W  D0,-(SP)
0040C   B06E FFFA              		CMP.W	ENDLOD(A6),D0	* IS THIS A PRELOADED LOCATION?
00410   6C10            00422  		BGE.S	GETBX1		* NO
00412
00412   619E            003B2  		BSR	BLKBYT		* YES, RECONSTRUCT POINTER (MAY EXCEED 32K)
00414   8041                   		OR.W	D1,D0
00416
00416   4242                   		CLR.W	D2		* CLEAR THE UNWANTED HIGH BYTE
00418 G 206E FFA8              		MOVE.L  BUFFER(A6),A0	* ABSOLUTE POINTER
0041C   1430 0800              		MOVE.B  0(A0,D0.L),D2	* GET THE DESIRED BYTE
00420   600A            0042C  		BRA.S	GETBX2
00422
00422   6100 1CE8       0210C  	GETBX1	BSR	GETPAG		* FIND THE PROPER PAGE (POINTER RETURNED IN A0)
00426   4242                   		CLR.W	D2		* CLEAR THE UNWANTED HIGH BYTE
00428   1430 1000              		MOVE.B  0(A0,D1.W),D2	* GET THE DESIRED BYTE
0042C
0042C   301F                   	GETBX2	MOVE.W  (SP)+,D0
0042E   5241                   		ADDQ.W  #1,D1		* UPDATE BYTE-POINTER
00430   0C41 0200              		CMPI.W  #512,D1		* END OF PAGE?
00434   6604            0043A  		BNE.S	GETBX3		* NO, DONE
00436
00436   4241                   		CLR.W	D1		* YES, CLEAR BYTE-POINTER
00438   5240                   		ADDQ.W  #1,D0		* AND UPDATE BLOCK-POINTER
0043A   4E75                   	GETBX3	RTS
0043C
0043C                          	* ----------------------
0043C                          	* GETWRD
0043C                          	* ----------------------
0043C
0043C                          	* GET A WORD FROM GAME, BLOCK-POINTER IN D0, BYTE-POINTER IN D1, RESULT IN D2
0043C
0043C   61CC            0040A  	GETWRD  BSR	GETBYT		* GET HIGH-ORDER BYTE
0043E   E142                   		ASL.W	#8,D2		* POSITION IT
00440   3F02                   		MOVE.W  D2,-(SP)	* SAVE IT
00442
00442   61C6            0040A  		BSR	GETBYT		* GET LOW-ORDER BYTE
00444   845F                   		OR.W	(SP)+,D2	* OR IN THE OTHER BYTE
00446   4E75                   		RTS
00448
00448                          	* ----------------------
00448                          	* NXTBYT
00448                          	* ----------------------
00448
00448                          	* GET THE NEXT BYTE, RETURN IT IN D0
00448
00448 G 206E FF44              	NXTBYT  MOVE.L  CURPAG(A6),A0	* INDEX INTO CURRENT PAGE

0044C   D0EE FFBA              		ADDA.W  ZPC2(A6),A0
00450   4240                   		CLR.W	D0		* CLEAR HIGH REGISTER AND
00452   1010                   		MOVE.B  (A0),D0		* GET THE NEXT BYTE
00454
00454   526E FFBA              		ADDQ.W  #1,ZPC2(A6)	* UPDATE PC
00458   0C6E 0200 FFBA         		CMPI.W  #512,ZPC2(A6)	* END OF PAGE?
0045E   6D08            00468  		BLT.S	NXTBX1		* NO
00460
00460   3F00                   		MOVE.W  D0,-(SP)
00462   6100 1C46       020AA  		BSR	NEWZPC		* YES, UPDATE PAGE
00466   301F                   		MOVE.W  (SP)+,D0
00468   4E75                   	NXTBX1	RTS			* AND RETURN
0046A
0046A                          	* ----------------------
0046A                          	* NXTWRD
0046A                          	* ----------------------
0046A
0046A                          	* GET THE NEXT WORD, RETURN IT IN D0
0046A
0046A   61DC            00448  	NXTWRD  BSR	NXTBYT		* GET HIGH-ORDER BYTE
0046C   E140                   		ASL.W	#8,D0		* SHIFT TO PROPER POSITION
0046E   3F00                   		MOVE.W  D0,-(SP)	* SAVE IT
00470
00470   61D6            00448  		BSR	NXTBYT		* GET LOW-ORDER BYTE
00472   805F                   		OR.W   (SP)+,D0		* OR IN THE OTHER BYTE
00474   4E75                   		RTS
00476
00476                          	* ----------------------
00476                          	* GETARG
00476                          	* ----------------------
00476
00476                          	* GET AN ARGUMENT GIVEN ITS TYPE IN D0
00476
00476   5340                   	GETARG  SUBQ.W  #1,D0		* EXAMINE ARGUMENT
00478   6DF0            0046A  		BLT.S	NXTWRD		* 0 MEANT LONG IMMEDIATE
0047A   67CC            00448  		BEQ.S	NXTBYT		* 1 MEANT SHORT IMMEDIATE
0047C
0047C   61CA            00448  		BSR	NXTBYT		* 2 MEANT VARIABLE, GET THE VAR
0047E   4A40                   		TST.W	D0		* STACK?
00480   660C            0048E  		BNE.S	GETV1		* NO, JUST GET THE VAR'S VALUE
00482   301C                   		MOVE.W  (A4)+,D0	* YES, POP THE STACK
00484   4E75                   		RTS
00486
00486                          	* ----------------------
00486                          	* GETVAR
00486                          	* ----------------------
00486
00486                          	* GET VALUE OF A VARIABLE, VAR IN D0, VALUE RETURNED IN D0
00486
00486   4A40                   	GETVAR  TST.W	D0		* STACK?
00488   6604            0048E  		BNE.S	GETV1		* NO
0048A   3014                   		MOVE.W  (A4),D0		* YES, GET TOP-OF-STACK (DON'T POP)
0048C   4E75                   		RTS
0048E
0048E   0C40 0010              	GETV1	CMPI.W  #16,D0		* LOCAL?
00492   6C0C            004A0  		BGE.S	GETVX2		* NO
00494 G 206E FFB4              		MOVE.L  ZLOCS(A6),A0	* YES, POINT TO PROPER STACK ELEMENT
00498   D040                   		ADD.W	D0,D0
0049A   90C0                   		SUBA.W  D0,A0		* LOCALS BUILD DOWN
0049C   3010                   		MOVE.W  (A0),D0		* GET IT
0049E   4E75                   		RTS
004A0
004A0 G 0440 0010              	GETVX2	SUB.W	#16,D0		* GLOBAL, ADJUST FOR LOCALS
004A4 G 206E FFEC              		MOVE.L  GLOTAB(A6),A0	* POINT TO PROPER GLOBAL TABLE ELEMENT
004A8   D040                   		ADD.W	D0,D0
004AA   D0C0                   		ADDA.W  D0,A0
004AC   6000 FF48       003F6  		BRA	GTAWRD		* GET IT AND RETURN
004B0
004B0                          	* ----------------------
004B0                          	* PUTVAR
004B0                          	* ----------------------
004B0
004B0                          	* UPDATE VALUE OF A VARIABLE, VAR IN D0, NEW VALUE IN D1
004B0
004B0   4A40                   	PUTVAR  TST.W	D0		* STACK?

004B2   6604            004B8  		BNE.S	PUTVX1		* NO
004B4   3881                   		MOVE.W  D1,(A4)		* YES, UPDATE TOP-OF-STACK (DON'T PUSH)
004B6   4E75                   		RTS
004B8
004B8   0C40 0010              	PUTVX1	CMPI.W  #16,D0		* LOCAL?
004BC   6C0C            004CA  		BGE.S	PUTVX2		* NO
004BE G 206E FFB4              		MOVE.L  ZLOCS(A6),A0	* YES, POINT TO PROPER STACK ELEMENT
004C2   D040                   		ADD.W	D0,D0
004C4   90C0                   		SUBA.W  D0,A0		* LOCALS BUILD DOWN
004C6   3081                   		MOVE.W  D1,(A0)		* UPDATE IT
004C8   4E75                   		RTS
004CA
004CA G 0440 0010              	PUTVX2	SUB.W	#16,D0		* GLOBAL, ADJUST FOR LOCALS
004CE G 206E FFEC              		MOVE.L  GLOTAB(A6),A0	* POINT TO PROPER GLOBAL TABLE ELEMENT
004D2   D040                   		ADD.W	D0,D0
004D4   D0C0                   		ADDA.W  D0,A0
004D6   3001                   		MOVE.W  D1,D0
004D8   6000 FF24       003FE  		BRA	PTAWRD		* UPDATE IT AND RETURN
004DC
004DC                          	* ----------------------
004DC                          	* PUTVAL, BYTVAL
004DC                          	* ----------------------
004DC
004DC                          	* RETURN VAL IN D0 TO LOCATION SPECIFIED BY NEXTBYTE
004DC                          	* DESTROYS D1, BUT IS USUALLY CALLED AT END OF TOP-LEVEL FUNCTION
004DC
004DC   0240 00FF              	BYTVAL  ANDI.W  #$00FF,D0	* ENTER HERE TO CLEAR HIGH BYTE
004E0   3200                   	PUTVAL  MOVE.W  D0,D1		* NORMAL ENTRY
004E2   6100 FF64       00448  		BSR	NXTBYT		* GET VAR TO USE
004E6   4A40                   		TST.W	D0		* STACK?
004E8   66C6            004B0  		BNE.S	PUTVAR		* NO, GO STORE VALUE
004EA   3901                   		MOVE.W  D1,-(A4)	* YES, PUSH ONTO STACK
004EC   4E75                   		RTS
004EE
004EE                          	* ----------------------
004EE                          	* PFALSE, PTRUE
004EE                          	* ----------------------
004EE
004EE                          	* PREDICATE HANDLERS TRUE AND FALSE
004EE                          	* DESTROYS REGISTERS, BUT ARE ONLY CALLED FROM END OF TOP-LEVEL FUNCTIONS
004EE
004EE   4241                   	PFALSE  CLR.W	D1		* PREDICATE WAS FALSE, CLEAR FLAG
004F0   6002            004F4  		BRA.S	PTRUE1
004F2
004F2   7201                   	PTRUE	MOVEQ	#1,D1		* PREDICATE WAS TRUE, SET FLAG
004F4   6100 FF52       00448  	PTRUE1  BSR	NXTBYT		* GET FIRST (OR ONLY) PREDICATE JUMP BYTE
004F8   0880 0007              		BCLR	#7,D0		* NORMAL POLARITY PREDICATE?
004FC   6702            00500  		BEQ.S	PTRUX1		* NO, LEAVE FLAG ALONE
004FE   5241                   		ADDQ.W  #1,D1		* YES, INCREMENT FLAG
00500
00500   0880 0006              	PTRUX1	BCLR	#6,D0		* ONE-BYTE JUMP OFFSET?
00504   6614            0051A  		BNE.S	PTRUX3		* YES
00506
00506   E140                   		ASL.W	#8,D0		* NO, TWO-BYTE, POSITION HIGH-ORDER OFFSET BYTE
00508   3400                   		MOVE.W  D0,D2
0050A   6100 FF3C       00448  		BSR	NXTBYT		* GET LOW-ORDER BYTE
0050E   8042                   		OR.W	D2,D0		* OR IN HIGH-ORDER BITS
00510   0800 000D              		BTST	#13,D0		* IS NUMBER NEGATIVE (14-BIT 2'S COMP NUMBER)?
00514   6704            0051A  		BEQ.S	PTRUX3		* NO
00516   0040 C000              		ORI.W	#$C000,D0	* YES, MAKE 16-BIT NUMBER NEGATIVE
0051A
0051A   5341                   	PTRUX3	SUBQ.W  #1,D1		* TEST FLAG
0051C   671A            00538  		BEQ.S	PTRUX6		* WAS 1, THAT MEANS DO NOTHING
0051E   4A40                   		TST.W	D0		* ZERO JUMP?
00520   6604            00526  		BNE.S	PTRUX4		* NO
00522   6000 1250       01774  		BRA	OPRFAL		* YES, THAT MEANS DO AN RFALSE
00526
00526   5340                   	PTRUX4	SUBQ.W  #1,D0		* ONE JUMP?
00528   6604            0052E  		BNE.S	PTRUX5		* NO
0052A   6000 1244       01770  		BRA	OPRTRU		* YES, THAT MEANS DO AN RTRUE
0052E
0052E   5340                   	PTRUX5	SUBQ.W  #1,D0		* ADJUST OFFSET
00530   D16E FFBA              		ADD.W	D0,ZPC2(A6)	* ADD TO PC
00534   6000 1B74       020AA  		BRA	NEWZPC		* AND UPDATE ZPC STUFF
00538   4E75                   	PTRUX6	RTS

0053A
0053A                          	* ----------------------
0053A                          	* BSPLTB
0053A                          	* ----------------------
0053A
0053A                          	* SPLIT BYTE-POINTER IN D0.W (16 BIT UNSIGNED)
0053A                          	*     INTO BLOCK NUMBER IN D0 & BYTE OFFSET IN D1
0053A
0053A   3200                   	BSPLTB  MOVE.W  D0,D1
0053C   E048                   		LSR.W	#8,D0		* EXTRACT THE 7 BLOCK BITS (64K RANGE)
0053E   E248                   		LSR.W	#1,D0
00540   0241 01FF              		ANDI.W  #$01FF,D1	* EXTRACT THE 9 OFFSET BITS (0-511)
00544                          	    IF DEBUG THEN
00544                          	    ENDIF
00544   4E75                   		RTS
00546
00546                          	* ----------------------
00546                          	* BSPLIT
00546                          	* ----------------------
00546
00546                          	* SPLIT WORD-POINTER IN D0.W (16 BIT UNSIGNED)
00546                          	*     INTO BLOCK NUMBER IN D0 & BYTE OFFSET IN D1
00546
00546   3200                   	BSPLIT  MOVE.W  D0,D1
00548   E048                   		LSR.W	#8,D0		* EXTRACT THE 8 BLOCK BITS (128K RANGE)
0054A   0241 00FF              		ANDI.W  #$00FF,D1	* EXTRACT THE 8 OFFSET BITS (0-255)
0054E   D241                   		ADD.W	D1,D1		* CONVERT OFFSET TO BYTES
00550                          	    IF DEBUG THEN
00550                          	    ENDIF
00550   4E75                   		RTS
00552
00552                          	* ----------------------
00552                          	* BSPLTQ
00552                          	* ----------------------
00552
00552                          	* SPLIT QUAD-POINTER IN D0.W
00552                          	*     INTO BLOCK NUMBER IN D0.W & BYTE OFFSET IN D1.W -- EZIP ONLY
00552
00552                          	** BSPLTQ  MOVE.W  D0,D1
00552                          	** 	LSR.W	#7,D0		* EXTRACT THE 9 BLOCK BITS (256K RANGE)
00552                          	** 	ANDI.W  #$007F,D1	* EXTRACT THE 7 OFFSET BITS (0-127)
00552                          	** 	ADD.W	D1,D1		* CONVERT OFFSET TO BYTES
00552                          	** 	ADD.W	D1,D1
00552                          	**  IF DEBUG THEN
00552                          	** 	CMP.W	MAXLOD(A6),D0	* VALID BLOCK NUMBER?
00552                          	** 	BCC	BLKERR	* BHS	* NO, FAIL
00552                          	**  ENDIF
00552                          	** 	RTS
00552
00552                          	* ----------------------
00552                          	* BSPLTQ2
00552                          	* ----------------------
00552
00552                          	* COMBINE/SPLIT QUAD-POINTERS IN D0.L AND D1.L
00552                          	*     INTO BLOCK NUMBER IN D0.W & BYTE OFFSET IN D1.W -- EZIP ONLY
00552
00552   D081                   	BSPLTQ2 ADD.L	D1,D0
00554   3200                   		MOVE.W  D0,D1
00556   EE88                   		LSR.L	#7,D0		* EXTRACT THE 9 BLOCK BITS (256K RANGE)
00558   0241 007F              		ANDI.W  #$007F,D1	* EXTRACT THE 7 OFFSET BITS (0-127)
0055C   D241                   		ADD.W	D1,D1		* CONVERT OFFSET TO BYTES
0055E   D241                   		ADD.W	D1,D1
00560                          	    IF DEBUG THEN
00560                          	    ENDIF
00560   4E75                   		RTS
00562
00562                          	* ----------------------
00562                          	* BLKERR
00562                          	* ----------------------
00562
00562                          	    IF DEBUG THEN
00562                          	    ENDIF
00562
00562                          	    INCLUDE	'MX2.a'
00562

00562                          	* ----------------------------------------------------------------------------
00562                          	*	ARITHMETIC OPERATIONS
00562                          	* ----------------------------------------------------------------------------
00562
00562                          	* ----------------------
00562                          	* OPADD
00562                          	* ----------------------
00562
00562   D041                   	OPADD	ADD.W	D1,D0		* ADD OPR1 AND OPR2
00564   6000 FF7A       004E0  		BRA	PUTVAL		* RETURN THE VALUE
00568
00568                          	* ----------------------
00568                          	* OPSUB
00568                          	* ----------------------
00568
00568   9041                   	OPSUB	SUB.W	D1,D0		* SUBTRACT OPR2 FROM OPR1
0056A   6000 FF74       004E0  		BRA	PUTVAL		* RETURN THE VALUE
0056E
0056E                          	* ----------------------
0056E                          	* OPMUL
0056E                          	* ----------------------
0056E
0056E   C1C1                   	OPMUL	MULS	D1,D0		* MULTIPLY OPR1 BY OPR2 (16 BIT SIGNED)
00570   6000 FF6E       004E0  		BRA	PUTVAL		* RETURN THE PRODUCT, IGNORING OVERFLOW
00574
00574                          	* ----------------------
00574                          	* OPDIV
00574                          	* ----------------------
00574
00574                          	* DIVIDE BY ZERO AND MOD ZERO ARE CAUGHT, AVOIDING CONFUSING HARDWARE TRAPS
00574
00574   4A41                   	OPDIV	TST.W	D1
00576   6708            00580  		BEQ.S	ODIVX1		* TRAP DIVIDE-BY-ZERO
00578   48C0                   		EXT.L	D0		* SIGN-EXTEND OPR1 TO 32 BITS
0057A   81C1                   		DIVS	D1,D0		* DIVIDE OPR2 INTO OPR1
0057C   6000 FF62       004E0  		BRA	PUTVAL		* RETURN THE QUOTIENT, IGNORING REMAINDER
00580
00580                          	ODIVX1
00580                          	*	CLR.W	D0
00580   41ED 004B              		LEA	MSGODV,A0
00584   6000 21D2       02758  		BRA	FATAL
0004B                          	    DATA
0004B   42616420444956         	MSGODV	DC.B	'Bad DIV',0
00588                          	    CODE
00588
00588                          	* ----------------------
00588                          	* OPMOD
00588                          	* ----------------------
00588
00588   4A41                   	OPMOD	TST.W	D1
0058A   670A            00596  		BEQ.S	OMODX1		* TRAP DIVIDE-BY-ZERO
0058C   48C0                   		EXT.L	D0		* SIGN-EXTEND OPR1 TO 32 BITS
0058E   81C1                   		DIVS	D1,D0		* DIVIDE OPR2 INTO OPR1
00590   4840                   		SWAP	D0		* GET REMAINDER
00592   6000 FF4C       004E0  		BRA	PUTVAL		* RETURN IT
00596
00596                          	OMODX1
00596                          	*	CLR.W	D0
00596   41ED 0053              		LEA	MSGOMD,A0
0059A   6000 21BC       02758  		BRA	FATAL
00053                          	    DATA
00053   426164204D4F44         	MSGOMD	DC.B	'Bad MOD',0
0059E                          	    CODE
0059E
0059E                          	* ----------------------
0059E                          	* OPRAND
0059E                          	* ----------------------
0059E
0059E   4A47                   	OPRAND  TST.W	D7		* [GARBAGE FOR ST ASSEMBLER]
005A0
005A0                          	    IF EZIP THEN
005A0   4A40                   		TST.W	D0		* DISABLE RANDOMNESS NOW?
005A2   6D34            005D8  		BLT.S	RANDX1		* YES
005A4   6734            005DA  		BEQ.S	RANDX2		* ZERO, RE-ENABLE RANDOMNESS
005A6

005A6   4A6E FFAE              		TST.W	RCYCLE(A6)	* IS RANDOMNESS ALREADY DISABLED?
005AA   6634            005E0  		BNE.S	RANDX3		* YES
005AC                          	    ENDIF
005AC
005AC                          	* NORMAL RANDOMNESS, GENERATE A VALUE
005AC
005AC   322E FFB0              		MOVE.W  RSEED2(A6),D1	* GET BOTH SEEDS
005B0   4841                   		SWAP	D1
005B2   322E FFB2              		MOVE.W  RSEED1(A6),D1
005B6   3D41 FFB0              		MOVE.W  D1,RSEED2(A6)	* UPDATE LOW SEED
005BA   4841                   		SWAP	D1
005BC
005BC   E289                   		LSR.L	#1,D1		* SHIFT BOTH RIGHT BY 1 BIT
005BE   B36E FFB2              		EOR.W	D1,RSEED1(A6)	* GENERATE OUTPUT & UPDATE HIGH SEED
005C2   322E FFB2              		MOVE.W  RSEED1(A6),D1	* GET NEW HIGH SEED
005C6
005C6   0281 0000 7FFF         		ANDI.L  #$00007FFF,D1	* CLEAR HIGH BIT TO PREVENT POSSIBLE OVERFLOW
005CC   82C0                   		DIVU	D0,D1		* DIVIDE ARG INTO RANDOM NUMBER
005CE   4841                   		SWAP	D1		* GET REMAINDER
005D0   5241                   		ADDQ.W  #1,D1		* MUST BE BETWEEN 1 AND N, INCLUSIVE
005D2   3001                   		MOVE.W  D1,D0
005D4   6000 FF0A       004E0  		BRA	PUTVAL		* RETURN THE VALUE
005D8
005D8                          	    IF EZIP THEN
005D8
005D8                          	*** GENERATE A NON-RANDOM SEQUENCE HENCEFORTH
005D8
005D8   4440                   	RANDX1	NEG.W	D0		* THIS SPECIFIES UPPER LIMIT OF SEQUENCE
005DA   3D40 FFAE              	RANDX2	MOVE.W  D0,RCYCLE(A6)	* STORE IT
005DE   600E            005EE  		BRA.S	RANDX4		* AND INITIALIZE COUNTER (SEQ BEGINS NEXT PASS)
005E0
005E0   302E FFAC              	RANDX3	MOVE.W  RCONST(A6),D0	* GENERATE NEXT VALUE IN SEQUENCE
005E4   5240                   		ADDQ.W  #1,D0
005E6   B06E FFAE              		CMP.W	RCYCLE(A6),D0	* EXCEEDED THE UPPER LIMIT YET?
005EA   6F02            005EE  		BLE.S	RANDX4		* NO
005EC   7001                   		MOVEQ	#1,D0		* YES, RESTART THE SEQUENCE
005EE
005EE   3D40 FFAC              	RANDX4	MOVE.W  D0,RCONST(A6)	* UPDATE COUNTER
005F2   6000 FEEC       004E0  		BRA	PUTVAL		* RETURN THE VALUE
005F6
005F6                          	    ENDIF
005F6
005F6                          	* ----------------------
005F6                          	* OPQLES
005F6                          	* ----------------------
005F6
005F6   B041                   	OPQLES  CMP.W	D1,D0		* IS OPR1 LESS THAN OPR2?
005F8   6D00 FEF8       004F2  		BLT	PTRUE		* YES, PREDICATE TRUE
005FC   6000 FEF0       004EE  		BRA	PFALSE		* NO, PREDICATE FALSE
00600
00600                          	* ----------------------
00600                          	* OPQGRT
00600                          	* ----------------------
00600
00600   B041                   	OPQGRT  CMP.W	D1,D0		* IS OPR1 GREATER THAN OPR2?
00602   6E00 FEEE       004F2  		BGT	PTRUE		* YES, PREDICATE TRUE
00606   6000 FEE6       004EE  		BRA	PFALSE		* NO, PRECICATE FALSE
0060A
0060A                          	* ----------------------
0060A                          	* OPBTST
0060A                          	* ----------------------
0060A
0060A                          	* LOGICAL OPERATIONS
0060A
0060A   4640                   	OPBTST  NOT.W	D0		* TURN OFF ALL BITS IN OPR2 THAT ARE ON IN OPR1
0060C   C240                   		AND.W	D0,D1
0060E   6700 FEE2       004F2  		BEQ	PTRUE		* SUCCESS IF OPR2 COMPLETELY CLEARED
00612   6000 FEDA       004EE  		BRA	PFALSE
00616
00616                          	* ----------------------
00616                          	* OPBOR
00616                          	* ----------------------
00616
00616   8041                   	OPBOR	OR.W	D1,D0		* LOGICAL "OR"
00618   6000 FEC6       004E0  		BRA	PUTVAL		* RETURN THE VALUE

0061C
0061C                          	* ----------------------
0061C                          	* OPBCOM
0061C                          	* ----------------------
0061C
0061C   4640                   	OPBCOM  NOT.W	D0		* LOGICAL COMPLEMENT
0061E   6000 FEC0       004E0  		BRA	PUTVAL		* RETURN THE VALUE
00622
00622                          	* ----------------------
00622                          	* OPBAND
00622                          	* ----------------------
00622
00622   C041                   	OPBAND  AND.W	D1,D0		* LOGICAL "AND"
00624   6000 FEBA       004E0  		BRA	PUTVAL		* RETURN THE VALUE
00628
00628                          	* ----------------------
00628                          	* OPSHIFT
00628                          	* ----------------------
00628
00628                          	OPSHIFT
00628   4A41                   		TST.W	D1		* NEGATIVE?
0062A   6D06            00632  		BLT.S	SHFX1		* YES
0062C   E368                   		LSL.W	D1,D0		* NO, LOGICAL LEFT SHIFT
0062E   6000 FEB0       004E0  		BRA	PUTVAL
00632   4441                   	SHFX1	NEG.W	D1
00634   E268                   		LSR.W	D1,D0		* LOGICAL RIGHT SHIFT
00636   6000 FEA8       004E0  		BRA	PUTVAL
0063A
0063A                          	* ----------------------
0063A                          	* OPASHIFT
0063A                          	* ----------------------
0063A
0063A                          	OPASHIFT
0063A   4A41                   		TST.W	D1		* NEGATIVE?
0063C   6D06            00644  		BLT.S	ASHFX1		* YES
0063E   E360                   		ASL.W	D1,D0		* NO, ARITHMETIC LEFT SHIFT
00640   6000 FE9E       004E0  		BRA	PUTVAL
00644   4441                   	ASHFX1	NEG.W	D1
00646   E260                   		ASR.W	D1,D0		* ARITHMETIC RIGHT SHIFT
00648   6000 FE96       004E0  		BRA	PUTVAL
0064C
0064C                          	* ----------------------
0064C                          	* OPQEUQ
0064C                          	* ----------------------
0064C
0064C                          	* GENERAL PREDICATES
0064C
0064C   4E71                   	OPQEQU  NOP			* TELL CALLER TO USE ARGBLK
0064E   3218                   		MOVE.W  (A0)+,D1	* NUMBER OF OPERANDS
00650   3018                   		MOVE.W  (A0)+,D0	* OPR1
00652   5341                   		SUBQ.W  #1,D1
00654
00654   B058                   	QEQUX1	CMP.W	(A0)+,D0	* IS NEXT OPR EQUAL TO OPR1?
00656   6708            00660  		BEQ.S	QEQUX2		* YES
00658   5341                   		SUBQ.W  #1,D1		* NO, BUT LOOP IF MORE OPERANDS
0065A   66F8            00654  		BNE.S	QEQUX1
0065C
0065C   6000 FE90       004EE  		BRA	PFALSE		* PREDICATE FALSE
00660   6000 FE90       004F2  	QEQUX2	BRA	PTRUE		* PREDICATE TRUE
00664
00664
00664                          	* ----------------------
00664                          	* OPQZER
00664                          	* ----------------------
00664
00664   4A40                   	OPQZER  TST.W	D0		* IS OPR ZERO?
00666   6700 FE8A       004F2  		BEQ	PTRUE		* YES, PREDICATE TRUE
0066A   6000 FE82       004EE  		BRA	PFALSE		* NO, PREDICATE FALSE
0066E
0066E

0066E                          	* ----------------------------------------------------------------------------
0066E                          	* OBJECT-RELATED PRIMITIVES
0066E                          	* ----------------------------------------------------------------------------
0066E
0066E                          	* ----------------------
0066E                          	* OBJLOC
0066E                          	* ----------------------
0066E
0066E                          	* GIVEN OBJECT NUMBER IN D0.W, RETURN OBJECT LOCATION IN A0
0066E
0066E   C0FC 000E              	OBJLOC  MULU	#OLEN,D0	* CALCULATE OBJECT OFFSET
00672 G 206E FFF0              		MOVE.L  OBJTAB(A6),A0
00676   D1C0                   		ADDA.L  D0,A0		* INDEX INTO OBJECT TABLE
00678   D0FC 0070              		ADDA.W  #OPLEN-OLEN,A0  * SKIPPING OVER THE DEFAULT PROPERTY TABLE
0067C   4E75                   		RTS
0067E
0067E                          	* ----------------------
0067E                          	* FSTPRP
0067E                          	* ----------------------
0067E
0067E                          	* GIVEN OBJECT LOCATION IN A0, RETURN POINTER TO FIRST PROPERTY IN A0
0067E
0067E   D0FC 000C              	FSTPRP  ADDA.W  #PROP,A0	* POINT TO PROPERTY TABLE SLOT
00682   7000                   		MOVEQ	#0,D0
00684   6100 FD70       003F6  		BSR	GTAWRD		* GET ITS LOCATION
00688 G 206E FFA8              		MOVE.L  BUFFER(A6),A0	* ABSOLUTIZE THE LOCATION
0068C   D1C0                   		ADDA.L  D0,A0
0068E
0068E   4240                   		CLR.W	D0
00690   1018                   		MOVE.B  (A0)+,D0	* LENGTH OF SHORT DESCRIPTION IN WORDS
00692   D040                   		ADD.W	D0,D0
00694   D0C0                   		ADDA.W  D0,A0		* ADJUST POINTER TO SKIP IT
00696   4E75                   		RTS
00698
00698                          	* ----------------------
00698                          	* NXTPRP
00698                          	* ----------------------
00698
00698                          	* GIVEN POINTER TO A PROPERTY ID IN A0, UPDATE IT TO POINT TO NEXT PROPERTY ID
00698
00698                          	    IF EZIP THEN
00698
00698   1018                   	NXTPRP	MOVE.B  (A0)+,D0	* GET (FIRST) PROPERTY ID BYTE
0069A   0800 0007              		BTST	#7,D0		* PROPERTY LENGTH GREATER THAN 2?
0069E   660C            006AC  		BNE.S	NXTPX4		* YES
006A0
006A0   0800 0006              		BTST	#6,D0		* NO, PROPERTY LENGTH 2?
006A4   6702            006A8  		BEQ.S	NXTPX2		* NO, PROPERTY LENGTH IS 1
006A6   5288                   		ADDQ.L  #1,A0
006A8   5288                   	NXTPX2	ADDQ.L  #1,A0		* UPDATE POINTER
006AA   4E75                   		RTS
006AC
006AC   1018                   	NXTPX4	MOVE.B  (A0)+,D0	* GET (SECOND) PROPERTY LENGTH BYTE (LOW 6 BITS)
006AE   0240 003F              		ANDI.W  #$003F,D0	* CLEAR OFF HIGH BITS
006B2   D0C0                   		ADDA.W  D0,A0		* UPDATE POINTER
006B4   4E75                   		RTS
006B6                          	    ENDIF
006B6                          	    IF CZIP THEN
006B6                          	    ENDIF
006B6
006B6                          	* ----------------------------------------------------------------------------
006B6                          	* OBJECT OPERATIONS
006B6                          	* ----------------------------------------------------------------------------
006B6
006B6                          	* ----------------------
006B6                          	* OPMOVE
006B6                          	* ----------------------
006B6
006B6                          	* MOVE (OBJ1 INTO OBJ2)
006B6
006B6   48A7 C000              	OPMOVE  MOVEM.W D1/D0,-(SP)	* PROTECT OPERANDS FROM REMOVE CALL
006BA   6100 0022       006DE  		BSR	OPREMO		* REMOVE OBJ1 FROM WHEREVER IT IS
006BE
006BE   302F 0002              		MOVE.W  2(SP),D0	* OBJ2
006C2   61AA            0066E  		BSR	OBJLOC		* FIND ITS LOCATION

006C4 G 2248                   		MOVE.L  A0,A1		* SAVE IT
006C6   3017                   		MOVE.W  (SP),D0		* OBJ1
006C8   61A4            0066E  		BSR	OBJLOC		* FIND ITS LOCATION
006CA
006CA   4C9F 0003              		MOVEM.W (SP)+,D0/D1	* RESTORE THE OBJ NUMBERS
006CE
006CE                          	    IF EZIP THEN
006CE   3169 000A 0008         		MOVE.W  FIRST(A1),NEXT(A0) * PUT OBJ2'S CHILD INTO OBJ1'S SIBLING SLOT
006D4   3141 0006              		MOVE.W  D1,LOC(A0)	   * PUT OBJ2 IN OBJ1'S PARENT SLOT
006D8   3340 000A              		MOVE.W  D0,FIRST(A1)	   * PUT OBJ1 IN OBJ2'S CHILD SLOT
006DC                          	    ENDIF
006DC                          	    IF CZIP THEN
006DC                          	    ENDIF
006DC   4E75                   		RTS
006DE
006DE                          	* ----------------------
006DE                          	* OPREMO
006DE                          	* ----------------------
006DE
006DE                          	* REMOVE (OBJ FROM ITS PARENT)
006DE
006DE                          	    IF EZIP THEN
006DE
006DE   3200                   	OPREMO	MOVE.W  D0,D1		* SAVE OBJ
006E0   618C            0066E  		BSR	OBJLOC		* FIND ITS LOCATION
006E2 G 2248                   		MOVE.L  A0,A1
006E4   3029 0006              		MOVE.W  LOC(A1),D0	* GET ITS PARENT
006E8   672C            00716  		BEQ.S	REMOX3		* IF NO PARENT, WE'RE DONE
006EA
006EA   6182            0066E  		BSR	OBJLOC		* FIND PARENT'S LOCATION
006EC   3028 000A              		MOVE.W  FIRST(A0),D0	* GET PARENT'S FIRST CHILD
006F0   B240                   		CMP.W	D0,D1		* IS IT OBJ?
006F2   6608            006FC  		BNE.S	REMOX1		* NO
006F4
006F4   3169 0008 000A         		MOVE.W  NEXT(A1),FIRST(A0) * YES, CHANGE IT TO OBJ'S SIBLING
006FA   6012            0070E  		BRA.S	REMOX2		   * AND EXIT
006FC
006FC   6100 FF70       0066E  	REMOX1	BSR	OBJLOC		* FIND LOCATION OF CURRENT SIBLING
00700   3028 0008              		MOVE.W  NEXT(A0),D0	* GET NEXT SIBLING IN CHAIN
00704   B240                   		CMP.W	D0,D1		* IS IT OBJ?
00706   66F4            006FC  		BNE.S	REMOX1		* NO, CONTINUE SEARCH
00708
00708   3169 0008 0008         		MOVE.W  NEXT(A1),NEXT(A0) * YES, CHANGE IT TO OBJ'S SIBLING
0070E   4269 0006              	REMOX2	CLR.W	LOC(A1)		  * OBJ NOW HAS NO PARENT
00712   4269 0008              		CLR.W	NEXT(A1)	  * OR SIBLING
00716   4E75                   	REMOX3	RTS
00718
00718                          	    ENDIF
00718                          	    IF CZIP THEN
00718                          	    ENDIF
00718
00718                          	* ----------------------
00718                          	* OPLOC
00718                          	* ----------------------
00718
00718                          	* LOC (RETURN CONTAINER OF OBJ)
00718
00718   6100 FF54       0066E  	OPLOC	BSR	OBJLOC		* FIND OBJ'S LOCATION
0071C
0071C                          	    IF EZIP THEN
0071C   3028 0006              		MOVE.W  LOC(A0),D0	* GET PARENT
00720                          	    ENDIF
00720                          	    IF CZIP THEN
00720                          	    ENDIF
00720   6000 FDBE       004E0  		BRA	PUTVAL		* RETURN THE VALUE
00724
00724                          	* ----------------------
00724                          	* OPQFIR
00724                          	* ----------------------
00724
00724                          	* FIRST? (RETURN FIRST CHILD OF OBJ, FAIL IF NONE)
00724
00724   6100 FF48       0066E  	OPQFIR  BSR	OBJLOC		* FIND OBJ'S LOCATION
00728
00728                          	    IF EZIP THEN

00728   3028 000A              		MOVE.W  FIRST(A0),D0	* GET FIRST CHILD
0072C                          	    ENDIF
0072C                          	    IF CZIP THEN
0072C                          	    ENDIF
0072C   3F00                   		MOVE.W  D0,-(SP)
0072E   6100 FDB0       004E0  		BSR	PUTVAL		* RETURN THE VALUE
00732   4A5F                   		TST.W	(SP)+		* NONZERO?
00734   6600 FDBC       004F2  		BNE	PTRUE		* YES, PREDICATE TRUE
00738   6000 FDB4       004EE  		BRA	PFALSE		* NO, PREDICATE FALSE
0073C
0073C                          	* ----------------------
0073C                          	* OPQNEX
0073C                          	* ----------------------
0073C
0073C                          	* NEXT? (RETURN THE NEXT SIBLING OF OBJ, FAIL IF NONE)
0073C
0073C   6100 FF30       0066E  	OPQNEX  BSR	OBJLOC		* FIND OBJ'S LOCATION
00740
00740                          	    IF EZIP THEN
00740   3028 0008              		MOVE.W  NEXT(A0),D0	* GET SIBLING
00744                          	    ENDIF
00744                          	    IF CZIP THEN
00744                          	    ENDIF
00744   3F00                   		MOVE.W  D0,-(SP)
00746   6100 FD98       004E0  		BSR	PUTVAL		* RETURN THE VALUE
0074A   4A5F                   		TST.W	(SP)+		* NONZERO?
0074C   6600 FDA4       004F2  		BNE	PTRUE		* YES, PREDICATE TRUE
00750   6000 FD9C       004EE  		BRA	PFALSE		* NO, PREDICATE FALSE
00754
00754                          	* ----------------------
00754                          	* OPQIN
00754                          	* ----------------------
00754
00754                          	* IN? (IS OBJ1 CONTAINED IN OBJ2?)
00754
00754   6100 FF18       0066E  	OPQIN	BSR	OBJLOC		* FIND OBJ1'S LOCATION
00758
00758                          	    IF EZIP THEN
00758   B268 0006              		CMP.W	LOC(A0),D1	* IS OBJ1'S PARENT OBJ2?
0075C                          	    ENDIF
0075C                          	    IF CZIP THEN
0075C                          	    ENDIF
0075C   6700 FD94       004F2  		BEQ	PTRUE		* YES, PREDICATE TRUE
00760   6000 FD8C       004EE  		BRA	PFALSE		* NO, PREDICATE FALSE
00764
00764                          	* ----------------------
00764                          	* OPGETP
00764                          	* ----------------------
00764
00764                          	* GETP (GET SPECIFIED PROPERTY OF OBJ, DEFAULT IF NONE)
00764
00764   6100 FF08       0066E  	OPGETP  BSR	OBJLOC		* FIND OBJ'S LOCATION
00768   6100 FF14       0067E  		BSR	FSTPRP		* GET POINTER TO FIRST PROPERTY
0076C   6004            00772  		BRA.S	GETPX2		* SKIP NEXT LINE FIRST TIME THROUGH LOOP
0076E
0076E   6100 FF28       00698  	GETPX1	BSR	NXTPRP		* POINT TO NEXT PROPERTY
00772   1010                   	GETPX2	MOVE.B  (A0),D0		* GET PROPERTY IDENTIFIER
00774   0240 003F              		ANDI.W  #PMASK,D0	* CLEAN OFF (EZIP MODE AND) LENGTH BITS
00778
00778   B041                   		CMP.W	D1,D0		* COMPARE PROPERTY NUMBER WITH DESIRED ONE
0077A   6EF2            0076E  		BGT.S	GETPX1		* IF GREATER, LOOP (TABLE SORTED IN REVERSE)
0077C   6D0C            0078A  		BLT.S	GETPX3		* IF LESS, NO SUCH PROPERTY, USE DEFAULT
0077E
0077E                          	* (ASSUMIMG NO 2ND EZIP LENGTH BYTE EXISTS HERE)
0077E
0077E   0818 0006              		BTST	#PLBIT,(A0)+	* GOT IT, EXAMINE (LOW MODE OR) LOWEST LEN BIT
00782   6610            00794  		BNE.S	GETPX4		* ONE MEANS WORD VALUE, OTHERWISE BYTE VALUE
00784
00784   1010                   		MOVE.B  (A0),D0		* GET THE BYTE
00786   6000 FD54       004DC  		BRA	BYTVAL		* AND RETURN IT
0078A
0078A   5341                   	GETPX3	SUBQ.W  #1,D1		* PROPERTY NOT FOUND, USE DEFAULT PROP TABLE
0078C   D241                   		ADD.W	D1,D1		* WORD OFFSET
0078E G 206E FFF0              		MOVE.L  OBJTAB(A6),A0	* GET BASE OF DEFAULT TABLE
00792   D0C1                   		ADDA.W  D1,A0		* POINT TO THE DEFAULT PROPERTY

00794
00794   6100 FC60       003F6  	GETPX4	BSR	GTAWRD		* GET THE WORD VALUE
00798   6000 FD46       004E0  		BRA	PUTVAL		* AND RETURN IT
0079C
0079C                          	* ----------------------
0079C                          	* OPPUTP
0079C                          	* ----------------------
0079C
0079C                          	* PUTP (CHANGE VALUE OF SPECIFIED PROPERTY OF OBJ, ERROR IF BAD PROP NUMBER)
0079C
0079C   6100 FED0       0066E  	OPPUTP  BSR	OBJLOC		* FIND OBJ'S LOCATION
007A0   6100 FEDC       0067E  		BSR	FSTPRP		* GET POINTER TO FIRST PROPERTY
007A4   6004            007AA  		BRA.S	PUTPX2		* SKIP NEXT LINE FIRST TIME THROUGH LOOP
007A6
007A6   6100 FEF0       00698  	PUTPX1	BSR	NXTPRP		* POINT TO NEXT PROPERTY
007AA   1010                   	PUTPX2	MOVE.B  (A0),D0		* GET PROPERTY IDENTIFIER
007AC   0240 003F              		ANDI.W  #PMASK,D0	* CLEAN OFF (EZIP MODE AND) LENGTH BITS
007B0
007B0   B041                   		CMP.W	D1,D0		* COMPARE PROPERTY NUMBER WITH DESIRED ONE
007B2   6EF2            007A6  		BGT.S	PUTPX1		* IF GREATER, LOOP (TABLE SORTED IN REVERSE)
007B4   670A            007C0  		BEQ.S	PUTPX3		* IF EQUAL, GOT IT
007B6
007B6   4240                   		CLR.W	D0		* OTHERWISE, FATAL ERROR
007B8   41ED 005B              		LEA	MSGPUP,A0
007BC   6000 1F9A       02758  		BRA	FATAL		* 'Non-existant put property'
007C0
0005B                          	    DATA
0005B   4E6F6E2D657869         	MSGPUP	DC.B	'Non-existant put property',0
007C0                          	    CODE
007C0
007C0                          	* (ASSUMING NO 2ND EZIP LENGTH BYTE EXISTS HERE)
007C0
007C0   0818 0006              	PUTPX3	BTST	#PLBIT,(A0)+	* EXAMINE (LOW MODE OR) LOWEST LENGTH BIT
007C4   6604            007CA  		BNE.S	PUTPX4		* ZERO MEANS BYTE VALUE, OTHERWISE WORD VALUE
007C6
007C6   1082                   		MOVE.B  D2,(A0)		* STORE THE NEW BYTE
007C8   4E75                   		RTS
007CA
007CA   3002                   	PUTPX4	MOVE.W  D2,D0
007CC   6000 FC30       003FE  		BRA	PTAWRD  	* STORE THE NEW WORD
007D0
007D0                          	* ----------------------
007D0                          	* OPNEXT
007D0                          	* ----------------------
007D0
007D0                          	* NEXTP (RETURN NUMBER OF NEXT PROP FOLLOWING GIVEN PROP IN OBJ)
007D0
007D0   6100 FE9C       0066E  	OPNEXT  BSR	OBJLOC		* FIND OBJ'S LOCATION
007D4   6100 FEA8       0067E  		BSR	FSTPRP		* GET POINTER TO FIRST PROPERTY
007D8   4A41                   		TST.W	D1		* WERE WE GIVEN ZERO AS PROP?
007DA   6720            007FC  		BEQ.S	NEXTX4		* YES, JUST RETURN FIRST PROPERTY NUMBER
007DC   6004            007E2  		BRA.S	NEXTX2		* SKIP NEXT LINE FIRST TIME THROUGH LOOP
007DE
007DE   6100 FEB8       00698  	NEXTX1	BSR	NXTPRP		* POINT TO NEXT PROPERTY
007E2   1010                   	NEXTX2	MOVE.B  (A0),D0		* GET PROPERTY IDENTIFIER
007E4   0240 003F              		ANDI.W  #PMASK,D0	* CLEAN OFF (EZIP MODE AND) LENGTH BITS
007E8
007E8   B041                   		CMP.W	D1,D0		* COMPARE PROPERTY NUMBER WITH DESIRED ONE
007EA   6EF2            007DE  		BGT.S	NEXTX1		* IF GREATER, LOOP (TABLE SORTED IN REVERSE)
007EC   670A            007F8  		BEQ.S	NEXTX3		* IF EQUAL, GOT IT
007EE
007EE   4240                   		CLR.W	D0		* OTHERWISE, FATAL ERROR
007F0   41ED 0075              		LEA	MSGNXP,A0
007F4   6000 1F62       02758  		BRA	FATAL		* 'Non-existant next property'
007F8
00075                          	    DATA
00075   4E6F6E2D657869         	MSGNXP	DC.B	'Non-existant next property',0
007F8                          	    CODE
007F8
007F8   6100 FE9E       00698  	NEXTX3	BSR	NXTPRP		* POINT TO NEXT PROPERTY
007FC   1010                   	NEXTX4	MOVE.B  (A0),D0		* GET PROPERTY IDENTIFIER
007FE   0240 003F              		ANDI.W  #PMASK,D0	* EXTRACT PROPERTY NUMBER
00802   6000 FCDC       004E0  		BRA	PUTVAL		* AND RETURN IT
00806
00806                          	* ----------------------

00806                          	* FLGLOC
00806                          	* ----------------------
00806
00806                          	* PRIMITIVE TO LOCATE A FLAG BIT
00806                          	* GIVEN A POINTER TO FIRST FLAGS BYTE IN A0, TARGET FLAG NUMBER (0-47) IN D0
00806                          	* RETURN POINTER TO TARGET FLAGS BYTE IN A0, TARGET BIT NUMBER (7-0) IN D0
00806
00806   3F00                   	FLGLOC  MOVE.W	D0,-(SP)
00808   E648                   		LSR.W	#3,D0		* EXTRACT BYTE OFFSET
0080A G D0C0                   		ADD.W	D0,A0		* ADJUST FLAGS POINTER
0080C
0080C   301F                   		MOVE.W	(SP)+,D0
0080E   4640                   		NOT.W	D0		* FIX THE 3 LOW-ORDER BITS
00810   0240 0007              		ANDI.W	#$0007,D0	* MASK OFF THE REST
00814   4E75                   		RTS
00816
00816                          	*	ADDQ.L  #1,A0		* POINT TO NEXT FLAGS BYTE
00816                          	*	SUBQ.W  #8,D0		* WAS TARGET FLAG IN PREVIOUS BYTE?
00816                          	*	BGE.S	FLGLOC		* NO
00816                          	*	SUBQ.L  #1,A0		* YES, POINT TO PREVIOUS FLAGS BYTE
00816                          	*	NEG.W	D0		* AND COMPUTE THE TARGET BIT NUMBER (7-0)
00816                          	*	SUBQ.W  #1,D0
00816                          	*	RTS
00816
00816                          	* ----------------------
00816                          	* OPQFSE
00816                          	* ----------------------
00816
00816                          	* FSET? (IS FLAG SET IN OBJ?)
00816
00816   6100 FE56       0066E  	OPQFSE  BSR	OBJLOC		* FIND OBJ'S LOCATION
0081A   3001                   		MOVE.W  D1,D0
0081C   61E8            00806  		BSR	FLGLOC		* DETERMINE PROPER FLAGS BYTE & BIT NUMBER
0081E   0110                   		BTST	D0,(A0)		* IS THE SPECIFIED BIT SET?
00820   6600 FCD0       004F2  		BNE	PTRUE		* YES, PREDICATE TRUE
00824   6000 FCC8       004EE  		BRA	PFALSE		* NO, PREDICATE FALSE
00828
00828                          	* ----------------------
00828                          	* OPFSET
00828                          	* ----------------------
00828
00828                          	* FSET (SET A FLAG IN OBJ)
00828
00828   6100 FE44       0066E  	OPFSET  BSR	OBJLOC		* FIND OBJ'S LOCATION
0082C   3001                   		MOVE.W  D1,D0
0082E   61D6            00806  		BSR	FLGLOC		* DETERMINE PROPER FLAGS BYTE & BIT NUMBER
00830   01D0                   		BSET	D0,(A0)		* SET THE SPECIFIED BIT
00832   4E75                   		RTS
00834
00834                          	* ----------------------
00834                          	* OPFCLE
00834                          	* ----------------------
00834
00834                          	* FCLEAR (CLEAR A FLAG IN OBJ)
00834
00834   6100 FE38       0066E  	OPFCLE  BSR	OBJLOC		* FIND OBJ'S LOCATION
00838   3001                   		MOVE.W  D1,D0
0083A   61CA            00806  		BSR	FLGLOC		* DETERMINE PROPER FLAGS BYTE & BIT NUMBER
0083C   0190                   		BCLR	D0,(A0)		* CLEAR THE SPECIFIED BIT
0083E   4E75                   		RTS
00840

00840                          	* ----------------------------------------------------------------------------
00840                          	* TABLE OPERATIONS
00840                          	* ----------------------------------------------------------------------------
00840
00840                          	* ----------------------
00840                          	* OPGET
00840                          	* ----------------------
00840
00840                          	* GET (GET THE ITEM'TH WORD FROM TABLE)
00840
00840   E341                   	OPGET	ASL.W	#1,D1		* WORD OFFSET
00842   D041                   		ADD.W	D1,D0		* INDEX INTO TABLE
00844   6100 FCF4       0053A  		BSR	BSPLTB		* SPLIT THE POINTER
00848   6100 FBF2       0043C  		BSR	GETWRD		* GET THE WORD
0084C   3002                   		MOVE.W  D2,D0
0084E   6000 FC90       004E0  		BRA	PUTVAL		* AND RETURN IT
00852
00852                          	* ----------------------
00852                          	* OPGETB
00852                          	* ----------------------
00852
00852                          	* GETB (GET THE ITEM'TH BYTE FROM TABLE)
00852
00852   D041                   	OPGETB  ADD.W	D1,D0		* INDEX INTO TABLE
00854   6100 FCE4       0053A  		BSR	BSPLTB		* SPLIT THE POINTER
00858   6100 FBB0       0040A  		BSR	GETBYT		* GET THE BYTE
0085C   3002                   		MOVE.W  D2,D0
0085E   6000 FC7C       004DC  		BRA	BYTVAL		* AND RETURN IT
00862
00862                          	* ----------------------
00862                          	* OPPUT
00862                          	* ----------------------
00862
00862                          	* NOTE: PROPERTY TABLE POINTERS IN THE NEXT FOUR ROUTINES NOW !MAY!
00862                          	*   EXCEED 32K, SO SIGN-EXTENSIONS MUST BE AVOIDED.
00862
00862                          	* A "TABLE" ARGUMENT IS A 16-BIT UNSIGNED BYTE POINTER
00862
00862                          	* PUT (REPLACE THE ITEM'TH WORD IN TABLE)
00862
00862   E341                   	OPPUT	ASL.W	#1,D1		* WORD OFFSET
00864   D041                   		ADD.W	D1,D0		* INDEX INTO TABLE
00866   0280 0000 FFFF         		ANDI.L	#$FFFF,D0	* MAKE THE SUM A LONGWORD
0086C G 2040                   		MOVE.L  D0,A0
0086E G D1EE FFA8              		ADD.L	BUFFER(A6),A0	* ABSOLUTIZE POINTER
00872   3002                   		MOVE.W  D2,D0
00874   6000 FB88       003FE  		BRA	PTAWRD  	* STORE THE WORD
00878
00878                          	* ----------------------
00878                          	* OPPUTB
00878                          	* ----------------------
00878
00878                          	* PUTB (REPLACE THE ITEM'TH BYTE IN TABLE)
00878
00878   D041                   	OPPUTB  ADD.W	D1,D0		* INDEX INTO TABLE
0087A   0280 0000 FFFF         		ANDI.L	#$FFFF,D0	* MAKE THE SUM A LONGWORD
00880 G 206E FFA8              		MOVE.L  BUFFER(A6),A0
00884   1182 0800              		MOVE.B  D2,0(A0,D0.L)	* STORE THE BYTE
00888   4E75                   		RTS
0088A
0088A                          	* ----------------------
0088A                          	* OPGTPT
0088A                          	* ----------------------
0088A
0088A                          	* GETPT (GET POINTER TO PROPERTY TABLE FOR GIVEN OBJ, PROP)
0088A
0088A   6100 FDE2       0066E  	OPGTPT  BSR	OBJLOC		* FIND OBJ'S LOCATION
0088E   6100 FDEE       0067E  		BSR	FSTPRP		* GET POINTER TO FIRST PROPERTY
00892   6004            00898  		BRA.S	GTPTX2		* SKIP NEXT LINE FIRST TIME THROUGH LOOP
00894
00894   6100 FE02       00698  	GTPTX1	BSR	NXTPRP		* POINT TO NEXT PROPERTY
00898   1010                   	GTPTX2	MOVE.B  (A0),D0		* GET (FIRST) PROPERTY ID BYTE
0089A   0240 003F              		ANDI.W  #PMASK,D0	* CLEAN OFF MODE/LENGTH BITS
0089E
0089E   B041                   		CMP.W	D1,D0		* COMPARE PROPERTY NUMBER WITH DESIRED ONE

008A0   6EF2            00894  		BGT.S	GTPTX1		* IF GREATER, LOOP (TABLE SORTED IN REVERSE)
008A2   6704            008A8  		BEQ.S	GTPTX3		* IF EQUAL, GOT IT
008A4
008A4   4240                   		CLR.W	D0		* OTHERWISE, RETURN ZERO FOR NO SUCH PROPERTY
008A6   6010            008B8  		BRA.S	GTPTX5
008A8
008A8                          	    IF EZIP THEN
008A8   1018                   	GTPTX3	MOVE.B  (A0)+,D0	* GET (FIRST) PROPERTY ID BYTE
008AA   0800 0007              		BTST	#7,D0		* IS THERE A SECOND LENGTH BYTE?
008AE   6702            008B2  		BEQ.S	GTPTX4		* NO
008B0   5288                   		ADDQ.L  #1,A0		* YES, SKIP IT TOO
008B2                          	    ENDIF
008B2                          	    IF CZIP THEN
008B2                          	    ENDIF
008B2
008B2   2008                   	GTPTX4	MOVE.L  A0,D0
008B4   90AE FFA8              		SUB.L	BUFFER(A6),D0	* RE-RELATIVIZE POINTER
008B8   6000 FC26       004E0  	GTPTX5	BRA	PUTVAL		* AND RETURN IT
008BC
008BC                          	* ----------------------
008BC                          	* OPPTSI
008BC                          	* ----------------------
008BC
008BC                          	* PTSIZE (GIVEN POINTER TO PROPERTY TABLE, RETURN ITS SIZE)
008BC
008BC G 206E FFA8              	OPPTSI  MOVE.L  BUFFER(A6),A0
008C0   0280 0000 FFFF         		ANDI.L	#$FFFF,D0	* MAKE THE TABLE PTR A LONGWORD
008C6   D1C0                   		ADDA.L  D0,A0		* ABSOLUTIZE THE TABLE POINTER
008C8
008C8                          	    IF EZIP THEN
008C8   1028 FFFF              		MOVE.B  -1(A0),D0	* GET MODE/ID BYTE OR LEN BYTE (EITHER WORKS!)
008CC   0800 0007              		BTST	#7,D0		* PROPERTY LENGTH GREATER THAN 2?
008D0   6612            008E4  		BNE.S	PTSIX4		* YES
008D2
008D2   0800 0006              		BTST	#6,D0		* NO, PROPERTY LENGTH 2?
008D6   6606            008DE  		BNE.S	PTSIX2		* YES
008D8   7001                   		MOVEQ	#1,D0		* NO, PROPERTY LENGTH IS 1
008DA   6000 FC04       004E0  		BRA	PUTVAL		* RETURN IT
008DE
008DE   7002                   	PTSIX2	MOVEQ	#2,D0
008E0   6000 FBFE       004E0  		BRA	PUTVAL		* RETURN IT
008E4
008E4   0240 003F              	PTSIX4	ANDI.W  #PMASK,D0	* LENGTH IS LOW 6 BITS
008E8   6000 FBF6       004E0  		BRA	PUTVAL		* RETURN IT
008EC                          	    ENDIF
008EC                          	    IF CZIP THEN
008EC                          	    ENDIF
008EC
008EC                          	* ----------------------------------------------------------------------------
008EC                          	* BLOCK OPERATIONS
008EC                          	* ----------------------------------------------------------------------------
008EC
008EC                          	* ----------------------
008EC                          	* OPINTBL
008EC                          	* ----------------------
008EC
008EC                          	* INTBL? (SEARCH TABLE FOR A VALUE)
008EC
008EC   4E71                   	OPINTBL	NOP			* USE AN ARGUMENT BLOCK
008EE   43EE FF8C              		LEA	DEFBLK(A6),A1	* DEFAULT ARGBLK
008F2   32BC 0004              		MOVE.W	#4,(A1)		* 4 ARGS MAX
008F6   337C 0082 0008         		MOVE.W	#128+2,ARG4(A1)	* DEFAULT -- WORD SEARCH, RECORD LENGTH = 2
008FC   6100 13C4       01CC2  		BSR	SETDEF		* SET UP DEFAULTS
00900
00900 G 2248                   		MOVE.L	A0,A1
00902   3629 0008              		MOVE.W	ARG4(A1),D3
00906   0243 007F              		ANDI.W	#127,D3		* RECORD LENGTH
0090A   0269 0080 0008         		ANDI.W	#128,ARG4(A1)	* SEARCH MODE BIT -- WORD 1, BYTE 0
00910   6028            0093A  		BRA.S	ITBX4		* >>> ZERO CHECK <<<
00912
00912   3029 0004              	ITBX1	MOVE.W	ARG2(A1),D0	* RELATIVE BYTE ADDRESS OF TABLE
00916   6100 FC22       0053A  		BSR	BSPLTB		* SPLIT IT  [D0,D1]
0091A   4A69 0008              		TST.W	ARG4(A1)	* WORD SEARCH?
0091E   670C            0092C  		BEQ.S	ITBX2		* NO, BYTE
00920   6100 FB1A       0043C  		BSR	GETWRD

00924   B469 0002              		CMP.W	ARG1(A1),D2	* MATCH?
00928   6720            0094A  		BEQ.S	ITBX5		* YES
0092A   600A            00936  		BRA.S	ITBX3
0092C   6100 FADC       0040A  	ITBX2	BSR	GETBYT
00930   B429 0003              		CMP.B	ARG1+1(A1),D2	* MATCH?
00934   6714            0094A  		BEQ.S	ITBX5		* YES
00936
00936   D769 0004              	ITBX3	ADD.W	D3,ARG2(A1)	* NO, SKIP TO NEXT RECORD
0093A   5369 0006              	ITBX4	SUBQ.W	#1,ARG3(A1)	* ANY MORE RECORDS?
0093E   6CD2            00912  		BGE.S	ITBX1		* YES, CONTINUE SEARCHING
00940
00940   4240                   		CLR.W	D0		* FAILED, RETURN ZERO
00942   6100 FB9C       004E0  		BSR	PUTVAL
00946   6000 FBA6       004EE  		BRA	PFALSE		* PREDICATE FALSE
0094A
0094A   3029 0004              	ITBX5	MOVE.W	ARG2(A1),D0	* SUCCESS, RETURN THE RELATIVE POINTER
0094E   6100 FB90       004E0  		BSR	PUTVAL
00952   6000 FB9E       004F2  		BRA	PTRUE		* PREDICATE TRUE
00956
00956                          	* ----------------------
00956                          	* OPCOPYT
00956                          	* ----------------------
00956
00956                          	* COPYT (COPY OR CLEAR A TABLE)
00956
00956   4E71                   	OPCOPYT	NOP			* ASK FOR ARGBLK [JUST TO FREE UP REGS]
00958 G 2448                   		MOVE.L	A0,A2
0095A
0095A   302A 0002              		MOVE.W	ARG1(A2),D0
0095E   B06A 0004              		CMP.W	ARG2(A2),D0
00962   6700 0086       009EA  		BEQ	CPYTX8		* SAME, EXIT
00966
00966   322A 0006              		MOVE.W	ARG3(A2),D1	* CHECK LENGTH:
0096A   6700 007E       009EA  		BEQ	CPYTX8		*   ZERO, EXIT
0096E   6E04            00974  		BGT.S	CPYTX1		* POSITIVE
00970   446A 0006              		NEG.W	ARG3(A2)	* NEGATIVE, MAKE POSITIVE
00974
00974   4A6A 0004              	CPYTX1	TST.W	ARG2(A2)	* DEST
00978   6760            009DA  		BEQ.S	CPYTX6		* IF ZERO, SPECIAL CASE
0097A   4A41                   		TST.W	D1		* WAS LEN NEG?
0097C   6D3C            009BA  		BLT.S	CPYTX4		* IF SO, DO /NOT/ CHECK FOR OVERLAP
0097E
0097E                          	***	MOVE.W	ARG1(A2),D0	* SRC
0097E   B06A 0004              		CMP.W	ARG2(A2),D0	* ANY "FORWARD OVERLAP"?
00982   6236            009BA  		BHI.S	CPYTX4		* NO
00984
00984   D06A 0006              		ADD.W	ARG3(A2),D0	* MAYBE, SRC END (+1)
00988   B06A 0004              		CMP.W	ARG2(A2),D0	* ANY "FORWARD OVERLAP"?
0098C   632C            009BA  		BLS.S	CPYTX4		* NO
0098E
0098E                          	* "FORWARD OVERLAP" DOES EXIST, DO A REVERSE COPY
0098E
0098E   302A 0004              	CPYTX2	MOVE.W	ARG2(A2),D0	* DEST
00992   D06A 0006              		ADD.W	ARG3(A2),D0	* END (+1)
00996   6100 F9FE       00396  		BSR	RELABS		* ABSOLUTIZE IT  [MUST BE PRELOAD]
0099A G 2248                   		MOVE.L	A0,A1
0099C
0099C   362A 0002              		MOVE.W	ARG1(A2),D3	* SRC
009A0   D66A 0006              		ADD.W	ARG3(A2),D3	* END (+1)
009A4
009A4   5343                   	CPYTX3	SUBQ.W	#1,D3		* [PREDECREMENT]
009A6   3003                   		MOVE.W	D3,D0
009A8   6100 FB90       0053A  		BSR	BSPLTB		* --> D0/D1 = BLK/OFF
009AC
009AC   6100 FA5C       0040A  		BSR	GETBYT		* --> D0/D1 = NEW BLK/OFF, D2 = DATA
009B0   1302                   		MOVE.B	D2,-(A1)	* [PREDECREMENT]
009B2   536A 0006              		SUBQ.W	#1,ARG3(A2)
009B6   66EC            009A4  		BNE.S	CPYTX3		* LOOP  [UNSIGNED TEST]
009B8   4E75                   		RTS
009BA
009BA                          	* DO A NORMAL COPY
009BA
009BA   302A 0004              	CPYTX4	MOVE.W	ARG2(A2),D0	* DEST
009BE   6100 F9D6       00396  		BSR	RELABS		* ABSOLUTIZE IT  [MUST BE PRELOAD]
009C2 G 2248                   		MOVE.L	A0,A1

009C4
009C4   302A 0002              		MOVE.W	ARG1(A2),D0
009C8   6100 FB70       0053A  		BSR	BSPLTB		* --> D0/D1 = BLK/OFF
009CC
009CC   6100 FA3C       0040A  	CPYTX5	BSR	GETBYT		* --> D0/D1 = NEW BLK/OFF, D2 = DATA
009D0   12C2                   		MOVE.B	D2,(A1)+
009D2   536A 0006              		SUBQ.W	#1,ARG3(A2)
009D6   66F4            009CC  		BNE.S	CPYTX5		* LOOP  [UNSIGNED TEST]
009D8   4E75                   		RTS
009DA
009DA                          	* NO DEST, JUST CLEAR THE SOURCE TABLE
009DA
009DA   302A 0002              	CPYTX6	MOVE.W	ARG1(A2),D0	* SRC
009DE   6100 F9B6       00396  		BSR	RELABS		* ABSOLUTIZE IT  [MUST BE PRELOAD]
009E2   4218                   	CPYTX7	CLR.B	(A0)+
009E4   536A 0006              		SUBQ.W	#1,ARG3(A2)
009E8   66F8            009E2  		BNE.S	CPYTX7		* LOOP  [UNSIGNED TEST]
009EA   4E75                   	CPYTX8	RTS
009EC
009EC                          	* ----------------------
009EC                          	* OPPRNT
009EC                          	* ----------------------
009EC
009EC                          	* PRINTT (DISPLAY A TABLE IN BLOCK FORMAT)
009EC
009EC   4E71                   	OPPRNT	NOP			* USE AN ARGUMENT BLOCK
009EE   43EE FF8C              		LEA	DEFBLK(A6),A1	* DEFAULT ARGBLK
009F2   32BC 0003              		MOVE.W	#3,(A1)		* 3 ARGS MAX
009F6   337C 0001 0006         		MOVE.W	#1,ARG3(A1)	* DEFAULT # LINES = 1
009FC   6100 12C4       01CC2  		BSR	SETDEF		* SET UP DEFAULT
00A00 G 2448                   		MOVE.L	A0,A2
00A02
00A02   4A6A 0004              		TST.W	ARG2(A2)
00A06   6F48            00A50  		BLE.S	PRNTX3		* BAD COL COUNT, EXIT
00A08   4A6A 0006              		TST.W	ARG3(A2)
00A0C   6F42            00A50  		BLE.S	PRNTX3		* BAD ROW COUNT, EXIT
00A0E
00A0E   6100 15E6       01FF6  		BSR	PUTLIN		* MAKE SURE BUFFER IS EMPTY
00A12   6100 1894       022A8  		BSR	GETCURS
00A16 G 3241                   		MOVE.W	D1,A1		* INITIAL CURSOR COLUMN -- SAVE HERE
00A18
00A18                          	* WE NOW USE VIRTUAL MEMORY CALLS TO FETCH TABLE DATA
00A18
00A18   362A 0004              	PRNTX1	MOVE.W	ARG2(A2),D3	* COLS PER ROW
00A1C   302A 0002              		MOVE.W	ARG1(A2),D0	* TABLE BASE / START OF CURRENT ROW
00A20   6100 FB18       0053A  		BSR	BSPLTB		* --> D0/D1 = BLK/OFF
00A24
00A24   6100 F9E4       0040A  	PRNTX2	BSR	GETBYT		* --> D0/D1 = NEW BLK/OFF, D2 = CHAR
00A28   C142                   		EXG	D0,D2
00A2A   6100 1558       01F84  		BSR	PUTCHR		* QUEUE/SCRIPT CHAR, ETC
00A2E   C142                   		EXG	D0,D2
00A30
00A30   5343                   		SUBQ.W	#1,D3		* ANY MORE COLS IN THIS ROW?
00A32   6EF0            00A24  		BGT.S	PRNTX2		* YES, LOOP
00A34
00A34                          	* BEFORE, WE SAVED THE CURRENT FONT AND ENABLED FONT1, TO BE SURE THE CR
00A34                          	* WAS CORRECTLY INTERPRETED.  BUT (IN OTHER CONTEXTS) IT STILL GOT
00A34                          	* MISINTERPRETED.  NOWADAYS, #13 ALWAYS MEANS CR, REGARDLESS OF CONTEXT
00A34                          	* (SEE CharOut).  A BETTER SOLUTION WILL REQUIRE SOME STICKY RETHINKING.
00A34
00A34   536A 0006              		SUBQ.W	#1,ARG3(A2)	* ANY MORE ROWS IN TABLE?
00A38   6716            00A50  		BEQ.S	PRNTX3		* NO, DONE
00A3A   6100 1546       01F82  		BSR	PUTNEW		* YES, CR, SCROLL IF NEEDED  [PUTCHR #13]
00A3E
00A3E   70FF                   		MOVEQ	#-1,D0		* KEEP CURRENT ROW
00A40   3209                   		MOVE.W	A1,D1		* BUT RESET COLUMN TO ORIGINAL VALUE
00A42   6100 182A       0226E  		BSR	SETCURS
00A46
00A46   302A 0004              		MOVE.W	ARG2(A2),D0
00A4A   D16A 0002              		ADD.W	D0,ARG1(A2)	* START OF NEXT LINE
00A4E   60C8            00A18  		BRA.S	PRNTX1		* LOOP
00A50   4E75                   	PRNTX3	RTS
00A52
00A52                          	* ----------------------
00A52                          	* OPPRNF

00A52                          	* ----------------------
00A52
00A52                          	* DISPLAY A FORMATTED TABLE (AS FROM 3-ARG DIROUT)
00A52
00A52   4E75                   	OPPRNF	RTS
00A54

00A54                          	* ----------------------------------------------------------------------------
00A54                          	* VARIABLE OPERATIONS
00A54                          	* ----------------------------------------------------------------------------
00A54
00A54                          	* ----------------------
00A54                          	* OPVALU
00A54                          	* ----------------------
00A54
00A54                          	* VALUE (GET VALUE OF VARIABLE)
00A54
00A54   6100 FA30       00486  	OPVALU  BSR	GETVAR		* GET THE VALUE
00A58   6000 FA86       004E0  		BRA	PUTVAL		* AND RETURN IT
00A5C
00A5C                          	* ----------------------
00A5C                          	* OPSET
00A5C                          	* ----------------------
00A5C
00A5C                          	* SET (VAR TO VALUE)
00A5C
00A5C   6000 FA52       004B0  	OPSET	BRA	PUTVAR		* STORE THE VALUE
00A60
00A60                          	* ----------------------
00A60                          	* OPPUSH
00A60                          	* ----------------------
00A60
00A60                          	* PUSH (A VALUE ONTO THE GAME STACK)
00A60
00A60   3900                   	OPPUSH  MOVE.W  D0,-(A4)	* PUSH THE VALUE
00A62   4E75                   		RTS
00A64
00A64                          	* ----------------------
00A64                          	* OPXPUSH
00A64                          	* ----------------------
00A64
00A64                          	* PUSH (A VALUE ONTO A 'USER STACK')
00A64
00A64   C141                   	OPXPUSH	EXG	D0,D1		* SAVE VALUE IN D1
00A66   6100 F92E       00396  		BSR	RELABS		* GET A0 -> LTABLE
00A6A   6100 F98A       003F6  		BSR	GTAWRD		* GET D0.W = SPACE REMAINING, ADVANCE A0
00A6E   4A40                   		TST.W	D0
00A70   6F1A            00A8C  		BLE.S	XPSHX2		* NO MORE SPACE
00A72
00A72   5340                   		SUBQ.W	#1,D0
00A74 G 2248                   		MOVE.L	A0,A1
00A76   D2C0                   		ADDA.W	D0,A1
00A78   D2C0                   		ADDA.W	D0,A1		* A1 -> FREE SLOT
00A7A
00A7A   5548                   		SUBQ.W	#2,A0
00A7C   6100 F980       003FE  		BSR	PTAWRD		* UPDATE LENGTH SLOT
00A80 G 2049                   		MOVE.L	A1,A0
00A82   3001                   		MOVE.W	D1,D0
00A84   6100 F978       003FE  		BSR	PTAWRD		* AND STORE VALUE
00A88
00A88   6000 FA68       004F2  		BRA	PTRUE		* PREDICATE TRUE
00A8C   6000 FA60       004EE  	XPSHX2	BRA	PFALSE		* PREDICATE FALSE
00A90
00A90                          	* ----------------------
00A90                          	* OPPOP
00A90                          	* ----------------------
00A90
00A90                          	* POP (A VALUE FROM A STACK, AND RETURN IT  [NO LONGER PUTVAR - YZIP] )
00A90
00A90   4E71                   	OPPOP	NOP			* REQUEST AN ARGBLK
00A92   4A50                   		TST.W	(A0)		* STACK SUPPLIED?
00A94   6604            00A9A  		BNE.S	PPOPX2		* YES
00A96   301C                   		MOVE.W  (A4)+,D0	* NO, POP VAL FROM GAME STACK
00A98   6020            00ABA  		BRA.S	PPOPX4
00A9A
00A9A   3028 0002              	PPOPX2	MOVE.W	ARG1(A0),D0
00A9E   6100 F8F6       00396  		BSR	RELABS		* GET A0 -> LTABLE
00AA2   6100 F952       003F6  		BSR	GTAWRD		* GET D0.W = SPACE REMAINING, ADVANCE A0
00AA6 G 2248                   		MOVE.L	A0,A1
00AA8   D2C0                   		ADDA.W	D0,A1
00AAA   D2C0                   		ADDA.W	D0,A1		* A1 -> LATEST ITEM ON STACK
00AAC

00AAC   5548                   		SUBQ.W	#2,A0
00AAE   5240                   		ADDQ.W	#1,D0
00AB0   6100 F94C       003FE  		BSR	PTAWRD		* UPDATE LENGTH SLOT
00AB4
00AB4 G 2049                   		MOVE.L	A1,A0
00AB6   6100 F93E       003F6  		BSR	GTAWRD		* AND GET VALUE
00ABA   6000 FA24       004E0  	PPOPX4	BRA	PUTVAL		* RETURN IT
00ABE
00ABE                          	* ----------------------
00ABE                          	* OPINC
00ABE                          	* ----------------------
00ABE
00ABE                          	* INC (INCREMENT VAR)
00ABE
00ABE   3200                   	OPINC	MOVE.W  D0,D1		* SAVE A COPY HERE
00AC0   6100 F9C4       00486  		BSR	GETVAR		* GET THE VARIABLE'S VALUE
00AC4   5240                   		ADDQ.W  #1,D0		* INCREMENT IT
00AC6   C141                   		EXG	D0,D1		* POSITION IT
00AC8   6000 F9E6       004B0  		BRA	PUTVAR		* AND STORE THE NEW VALUE
00ACC
00ACC                          	* ----------------------
00ACC                          	* OPDEC
00ACC                          	* ----------------------
00ACC
00ACC                          	* DEC (DECREMENT VAR)
00ACC
00ACC   3200                   	OPDEC	MOVE.W  D0,D1		* SAVE A COPY HERE
00ACE   6100 F9B6       00486  		BSR	GETVAR		* GET THE VARIABLE'S VALUE
00AD2   5340                   		SUBQ.W  #1,D0		* DECREMENT IT
00AD4   C141                   		EXG	D0,D1		* POSITION IT
00AD6   6000 F9D8       004B0  		BRA	PUTVAR		* AND STORE NEW VALUE
00ADA
00ADA                          	* ----------------------
00ADA                          	* OPQIGR
00ADA                          	* ----------------------
00ADA
00ADA                          	* IGRTR? (INCREMENT VAR & TEST IF GREATER THAN VAL)
00ADA
00ADA   3401                   	OPQIGR  MOVE.W  D1,D2		* MOVE VAL HERE
00ADC   3200                   		MOVE.W  D0,D1		* COPY VAR HERE
00ADE   6100 F9A6       00486  		BSR	GETVAR		* GET THE VARIABLE'S VALUE
00AE2   5240                   		ADDQ.W  #1,D0		* INCREMENT IT
00AE4   C141                   		EXG	D0,D1		* POSITION IT
00AE6
00AE6   B242                   		CMP.W	D2,D1		* NEW VALUE GREATER THAN VAL?
00AE8   6E08            00AF2  		BGT.S	QIG2		* YES
00AEA   6100 F9C4       004B0  	QIG1	BSR	PUTVAR		* NO, STORE THE NEW VALUE
00AEE   6000 F9FE       004EE  		BRA	PFALSE		* AND RETURN PREDICATE FALSE
00AF2
00AF2   6100 F9BC       004B0  	QIG2	BSR	PUTVAR		* STORE THE NEW VALUE
00AF6   6000 F9FA       004F2  		BRA	PTRUE		* AND RETURN PREDICATE TRUE
00AFA
00AFA                          	* ----------------------
00AFA                          	* OPQDLE
00AFA                          	* ----------------------
00AFA
00AFA                          	* DLESS? (DECREMENT VAR & TEST IF LESS THAN VAL)
00AFA
00AFA   3401                   	OPQDLE  MOVE.W  D1,D2		* MOVE VAL HERE
00AFC   3200                   		MOVE.W  D0,D1		* COPY VAR HERE
00AFE   6100 F986       00486  		BSR	GETVAR		* GET THE VARIABLE'S VALUE
00B02   5340                   		SUBQ.W  #1,D0		* DECREMENT IT
00B04   C141                   		EXG	D0,D1		* POSITION IT
00B06
00B06   B242                   		CMP.W	D2,D1		* NEW VALUE LESS THAN VAL?
00B08   6DE8            00AF2  		BLT.S	QIG2		* YES
00B0A   60DE            00AEA  		BRA.S	QIG1		* NO
00B0C
00B0C                          	* ---------------------------------------------------------------------------
00B0C                          	* READ/INPUT OPERATIONS
00B0C                          	* ---------------------------------------------------------------------------
00B0C
00B0C                          	* 6/88 -- REGISTER D3 IS BEING TRASHED; TRY TO PINPOINT IT
00B0C
00B0C                          	    IF D3BUG THEN

00B0C                          	    ENDIF
00B0C
00B0C                          	* ------------------------------
00B0C                          	* OPREAD
00B0C                          	* ------------------------------
00B0C
00B0C                          	* READ (A LINE OF INPUT AND MASTICATE IT)
00B0C
00B0C   4E71                   	OPREAD	NOP			* USE AN ARGUMENT BLOCK
00B0E   43EE FF8C              		LEA	DEFBLK(A6),A1	* USE A DEFAULT ARGBLK, TOO
00B12   32BC 0004              		MOVE.W	#4,(A1)		* 4 ARGS MAX
00B16   4269 0004              		CLR.W	ARG2(A1)	* DEFAULT LEXV -- ZERO MEANS DON'T
00B1A   337C FFFF 0006         		MOVE.W	#-1,ARG3(A1)	* DEFAULT TIMOUT INTERVAL -- NEG MEANS DON'T
00B20   4269 0008              		CLR.W	ARG4(A1)	* DEFAULT TIMOUT HANDLER FUNCTION
00B24   6100 119C       01CC2  		BSR	SETDEF		* SET UP DEFAULTS
00B28
00B28   5488                   		ADDQ.L	#2,A0		* SKIP COUNT SLOT
00B2A   3018                   		MOVE.W	(A0)+,D0	* INBUF
00B2C   3618                   		MOVE.W	(A0)+,D3	*   [LEXV]
00B2E                          	    IF D3BUG THEN
00B2E                          	    ENDIF
00B2E   3D58 FF2E              		MOVE.W	(A0)+,TWAIT(A6) *   [TIME]
00B32   3D58 FF2C              		MOVE.W	(A0)+,TFUNC(A6)	*   [HANDLER]
00B36
00B36   6100 F85E       00396  		BSR	RELABS		* ABSOLUTIZE THE INBUF PTR
00B3A G 2448                   		MOVE.L	A0,A2		* KEEP IT HERE
00B3C   6100 041C       00F5A  		BSR	TRESET		* RESET THE TIMER, IF NEEDED
00B40
00B40                          	    IF CZIP THEN
00B40                          	    ENDIF
00B40
00B40 G 206E FF14              		MOVE.L	CURWP(A6),A0
00B44   4268 001E              		CLR.W	WLCNT(A0)	* RESET COUNTER (PREVENTS A SPURIOUS [MORE])
00B48   6100 14A4       01FEE  		BSR	PUTLIN1		* THEN FORCE OUT ANY QUEUED TEXT (THE PROMPT)
00B4C
00B4C                          	    IF D3BUG THEN
00B4C                          	    ENDIF
00B4C
00B4C                          	*** GATHER AND LOWER-CASIFY THE INPUT LINE ...
00B4C
00B4C G 204A                   		MOVE.L	A2,A0		* START OF INPUT LINE BUFFER
00B4E   7000                   		MOVEQ	#0,D0
00B50   1018                   		MOVE.B	(A0)+,D0	* 1ST HEADER BYTE == MAX LENGTH
00B52   7200                   		MOVEQ	#0,D1
00B54   1218                   		MOVE.B	(A0)+,D1	* 2ND HEADER BYTE == CURRENT LEN
00B56   6100 0200       00D58  		BSR	READLN		* GET IT
00B5A
00B5A                          	    IF D3BUG THEN
00B5A                          	    ENDIF
00B5A
00B5A   3400                   		MOVE.W	D0,D2		* RETURN D0: TERM CHAR
00B5C   2008                   		MOVE.L	A0,D0		* RETURN A0: END OF ACTUAL INPUT (+1)
00B5E G 204A                   		MOVE.L	A2,A0
00B60   5488                   		ADDQ.L	#2,A0		* START OF INPUT, SKIP HEADER
00B62
00B62   9088                   		SUB.L	A0,D0		* NEW TOTAL LENGTH
00B64   1540 0001              		MOVE.B	D0,1(A2)	* STORE THE NEW LENGTH IN THE HEADER
00B68   6100 02A4       00E0E  		BSR	LCASE		* AND LOWER-CASIFY EVERYTHING
00B6C
00B6C                          	*** TOKENIZE AND LOOKUP THE INPUT ...
00B6C
00B6C   3003                   		MOVE.W	D3,D0		* LEXV ARG
00B6E   6710            00B80  		BEQ.S	RDX4		* ZERO MEANS EXIT IMMEDIATELY
00B70   6100 F824       00396  		BSR	RELABS		* ABSOLUTIZE
00B74 G 2648                   		MOVE.L	A0,A3
00B76
00B76 G 226E FFF4              		MOVE.L	VOCTAB(A6),A1	* OPREAD: USE "STANDARD" VOCAB TABLE
00B7A   7200                   		MOVEQ	#0,D1		* OPREAD: NO PRESERVE FLAG
00B7C   6100 0042       00BC0  		BSR	LEX
00B80
00B80   3002                   	RDX4	MOVE.W	D2,D0
00B82   6000 F958       004DC  		BRA	BYTVAL		* RETURN THE TERM CHARACTER
00B86
00B86                          	* ------------------------------
00B86                          	* OPLEX

00B86                          	* ------------------------------
00B86
00B86                          	* TOKENIZE AND LOOKUP A LINE OF INPUT
00B86                          	*   (FIND EACH WORD, CONVERT IT TO ZWORD, AND STORE OFFSET INFO IN LEXV)
00B86
00B86   4E71                   	OPLEX	NOP			* USE AN ARGUMENT BLOCK
00B88   43EE FF8C              		LEA	DEFBLK(A6),A1	* USE A DEFAULT ARGBLK, TOO
00B8C   32BC 0004              		MOVE.W	#4,(A1)		* 4 ARGS MAX
00B90   4269 0006              		CLR.W	ARG3(A1)	* DEFAULT VOC TABLE (FLAG)
00B94   4269 0008              		CLR.W	ARG4(A1)	* DEFAULT PRESERVE FLAG = OFF
00B98   6100 1128       01CC2  		BSR	SETDEF		* SET UP DEFAULTS
00B9C
00B9C G 2248                   		MOVE.L	A0,A1		* ARGBLK
00B9E   4A59                   		TST.W	(A1)+		* SKIP ACTUAL ARG COUNT (NOT NEEDED)
00BA0   3019                   		MOVE.W	(A1)+,D0	* ARG1 == INBUF
00BA2   6100 F7F2       00396  		BSR	RELABS		* ABSOLUTIZE
00BA6 G 2448                   		MOVE.L	A0,A2		* AND PASS IT HERE
00BA8   3019                   		MOVE.W	(A1)+,D0	* ARG2 == LEXV
00BAA   6100 F7EA       00396  		BSR	RELABS		* ABSOLUTIZE
00BAE G 2648                   		MOVE.L	A0,A3		* AND PASS IT HERE
00BB0
00BB0 G 206E FFF4              		MOVE.L	VOCTAB(A6),A0	* "STANDARD" VOCTAB
00BB4   3019                   		MOVE.W	(A1)+,D0	* USE A SPECIAL VOCTAB?
00BB6   6704            00BBC  		BEQ.S	LXX0		* NO
00BB8   6100 F7DC       00396  		BSR	RELABS		* YES, ABSOLUTIZE
00BBC   C149                   	LXX0	EXG	A0,A1		* PASS VOCTAB IN A1
00BBE   3218                   		MOVE.W	(A0)+,D1	* AND PASS "PRESERVE" FLAG HERE
00BC0
00BC0                          	* INTERNAL ENTRY POINT
00BC0                          	*   GIVEN A1 -> VOCAB TABLE, A2 -> INBUF, A3 -> LEXV, D1 = PRESERVE FLAG
00BC0
00BC0   2F02                   	LEX	MOVE.L	D2,-(SP)
00BC2 G 2049                   		MOVE.L	A1,A0
00BC4   6100 02C8       00E8E  		BSR	INITLX		* SETUP VOCAB VARS (FOR LOOKUP)
00BC8
00BC8   2D4A FF78              		MOVE.L	A2,RDBOS(A6)	* REMEMBER INPUT BUFFER BASE
00BCC   7000                   		MOVEQ	#0,D0
00BCE   102A 0001              		MOVE.B	1(A2),D0	* >> ACTUAL LEN OF INPUT <<
00BD2   548A                   		ADDQ.L	#2,A2		* SKIP HEADER (MAX LEN, CUR LEN)
00BD4   D08A                   		ADD.L	A2,D0
00BD6   2D40 FF74              		MOVE.L	D0,RDEOS(A6)	* REMEMBER END OF INPUT
00BDA
00BDA   2D4B FF70              		MOVE.L	A3,RDRET(A6)	* REMEMBER RETURN BUFFER BASE
00BDE   422B 0001              		CLR.B	1(A3)		* BUFFER INITIALLY EMPTY
00BE2   548B                   		ADDQ.L	#2,A3		* SKIP HEADER (MAX WORDS, NWORDS)
00BE4
00BE4                          	* LOOP STARTS HERE, A2 -> CURRENT INBUF, A3 -> CURRENT LEXV
00BE4
00BE4 G 204A                   	LXX2	MOVE.L	A2,A0		* CURRENT INPUT START
00BE6   202E FF74              		MOVE.L	RDEOS(A6),D0
00BEA   908A                   		SUB.L	A2,D0		* CURRENT REMAINING LENGTH
00BEC   674A            00C38  		BEQ.S	LXX8		* NOTHING, EXIT
00BEE   6100 006A       00C5A  		BSR	ZWSTR		* FIND NEXT WORD, AND CONVERT IT
00BF2
00BF2 G 2448                   		MOVE.L	A0,A2		* RETURN: START OF CURRENT WORD
00BF4   3400                   		MOVE.W	D0,D2		* RETURN: LENGTH OF CURRENT WORD, OR ZERO
00BF6   6740            00C38  		BEQ.S	LXX8		* NOTHING, EXIT
00BF8
00BF8                          	*** BUILD THE LEX (RETURN) TABLE ...
00BF8
00BF8 G 206E FF70              		MOVE.L	RDRET(A6),A0	* RETURN TABLE POINTER
00BFC   1018                   		MOVE.B	(A0)+,D0	* MAX WORDS ALLOWED
00BFE   B010                   		CMP.B	(A0),D0		*  ROOM FOR ANOTHER?
00C00   672C            00C2E  		BEQ.S	LXX6		* NO, ERROR
00C02   5210                   		ADDQ.B	#1,(A0)		* INCREMENT FOUND-WORD COUNT
00C04
00C04   41EE FF7C              		LEA	RDZSTR(A6),A0	* ZWORD WAS LEFT HERE
00C08   6100 02DA       00EE4  		BSR	LOOKUP		* SEARCH VOCAB TABLE FOR IT, RETURN OFFSET
00C0C   4A40                   		TST.W	D0		* WORD FOUND?
00C0E   6604            00C14  		BNE.S	LXX3		* YES
00C10   4A41                   		TST.W	D1		* NO, PRESERVE OLD INFO?  >> OFFSET ONLY <<
00C12   6606            00C1A  		BNE.S	LXX4		* YES
00C14
00C14 G 204B                   	LXX3	MOVE.L	A3,A0		* CURRENT RETURN SLOT
00C16   6100 F7E6       003FE  		BSR	PTAWRD		* STORE THE OFFSET IN RETURN TABLE

00C1A
00C1A   1742 0002              	LXX4	MOVE.B	D2,2(A3)	* STORE WORD LENGTH IN RETURN TABLE
00C1E   200A                   		MOVE.L	A2,D0
00C20   90AE FF78              		SUB.L	RDBOS(A6),D0	* CALCULATE STARTING BYTE OFFSET OF WORD
00C24   1740 0003              		MOVE.B	D0,3(A3)	* STORE IT TOO
00C28
00C28   588B                   		ADDQ.L	#4,A3		* ADVANCE RETURN TABLE PTR
00C2A   D4C2                   		ADDA.W	D2,A2		* ADVANCE INPUT PTR
00C2C   60B6            00BE4  		BRA	LXX2		* GO FOR THE NEXT WORD
00C2E
00C2E                          	*** ERROR, RETURN BUFFER IS FULL, TELL USER, THEN EXIT
00C2E
00C2E G 204A                   	LXX6	MOVE.L	A2,A0		* START OF FLUSHED STRING
00C30 G 226E FF74              		MOVE.L	RDEOS(A6),A1	* END (+1)
00C34   6100 0230       00E66  		BSR	RDERR		* ECHO IT IN ERROR MESSAGE
00C38
00C38   241F                   	LXX8	MOVE.L	(SP)+,D2	* CLEAN UP AND EXIT
00C3A   4E75                   		RTS
00C3C
00C3C                          	* ------------------------------
00C3C                          	* OPZWSTR
00C3C                          	* ------------------------------
00C3C
00C3C                          	* IDENTIFY THE NEXT WORD (START/END), AND CONVERT IT TO A ZWORD
00C3C
00C3C                          	OPZWSTR
00C3C   D042                   		ADD.W	D2,D0		* INPUT BUFFER: BASE + OFFSET
00C3E   6100 F756       00396  		BSR	RELABS		* ABSOLUTIZE IT
00C42   7009                   		MOVEQ	#VCHARS,D0	* MAX LEN -- IGNORE 2ND ARG (SPEC ERROR)
00C44   6100 0014       00C5A  		BSR	ZWSTR		* GO FOR IT
00C48
00C48                          	* (IGNORE RETURNED INFO; WE'RE INTERESTED IN INITIAL WORD ONLY)
00C48
00C48   3003                   		MOVE.W	D3,D0		* REQUESTED ZWORD BUFFER
00C4A   6100 F74A       00396  		BSR	RELABS		* ABSOLUTIZE IT
00C4E G 2248                   		MOVE.L	A0,A1
00C50   41EE FF7C              		LEA	RDZSTR(A6),A0	* ZWORD WAS LEFT HERE
00C54   7006                   		MOVEQ	#ZCHARS,D0
00C56   6000 F708       00360  		BRA	COPYB		* COPY ZWORD TO FINAL DEST, AND EXIT
00C5A
00C5A                          	* INTERNAL ENTRY POINT
00C5A                          	*   GIVEN A0 -> INPUT START, D0.W = INPUT LENGTH (TOTAL)
00C5A                          	*   RETURN A0 -> FIRST WORD START, D0.W = FIRST WORD LENGTH, OR ZERO
00C5A
00C5A   6100 01CC       00E28  	ZWSTR	BSR	FINDBK		* FIND NEXT BREAK CHAR
00C5E   4A40                   		TST.W	D0
00C60   671E            00C80  		BEQ.S	ZWSX1		* EXIT IF NOTHING
00C62
00C62   48E7 C0C0              		MOVEM.L	D0-D1/A0-A1,-(SP)	* SAVE RESULTS
00C66   43EE FF82              		LEA	RDWSTR(A6),A1	* TEMP STRING BUFFER
00C6A   7209                   		MOVEQ	#VCHARS,D1	* MAX LENGTH
00C6C   6100 F6F8       00366  		BSR	COPYS		* COPY FIRST WORD, MAKE ASCIZ
00C70
00C70   43EE FF82              		LEA	RDWSTR(A6),A1
00C74   41EE FF7C              		LEA	RDZSTR(A6),A0	* TEMP OUTPUT BUFFER
00C78   6100 119E       01E18  		BSR	ZWORD		* CONVERT STRING, LEAVE ZWORD IN BUFFER
00C7C   4CDF 0303              		MOVEM.L	(SP)+,D0-D1/A0-A1	* RESTORE RESULTS
00C80   4E75                   	ZWSX1	RTS
00C82
00C82                          	* ------------------------------
00C82                          	* OPINPUT
00C82                          	* ------------------------------
00C82
00C82                          	* WAIT FOR A KEY (NO ECHO), HANDLE OPTIONAL TIMEOUTS
00C82
00C82   4E71                   	OPINPUT NOP			* USE ARGBLK
00C84   43EE FF8C              		LEA	DEFBLK(A6),A1	* USE A DEFAULT ARGBLK, TOO
00C88   32BC 0003              		MOVE.W	#3,(A1)		* 3 ARGS MAX
00C8C   337C FFFF 0004         		MOVE.W	#-1,ARG2(A1)	* DEFAULT TIMOUT INTERVAL -- "DON'T"
00C92   4269 0006              		CLR.W	ARG3(A1)	* DEFAULT TIMOUT HANDLER FUNCTION
00C96   6100 102A       01CC2  		BSR	SETDEF		* SET UP DEFAULTS
00C9A   5888                   		ADDQ.L	#ARG2,A0	* SKIP COUNT AND DEVICE
00C9C   3D58 FF2E              		MOVE.W	(A0)+,TWAIT(A6)   * DELAY IN 1/10'S SECOND
00CA0   3D58 FF2C              		MOVE.W	(A0)+,TFUNC(A6)   * FUNCTION TO CALL UPON TIMEOUT
00CA4   6100 02B4       00F5A  		BSR	TRESET		* RESET THE TIMER, IF NEEDED

00CA8
00CA8 G 206E FF14              		MOVE.L	CURWP(A6),A0
00CAC   4268 001E              		CLR.W	WLCNT(A0)	* RESET COUNTER, PREVENTS A SPURIOUS [MORE]
00CB0   4A6E FF5A              		TST.W	VOBUFF(A6)	* BUFFERED OUTPUT?
00CB4   6704            00CBA  		BEQ.S	INPX1		* NO
00CB6   6100 133E       01FF6  		BSR	PUTLIN		* YES, EMPTY THE BUFFER
00CBA
00CBA   7000                   	INPX1	MOVEQ	#0,D0		* SINGLE CHAR [SUPPRESS MENU CMD-STRINGS]
00CBC   6100 000C       00CCA  		BSR	INPUT		* GET KEY
00CC0   0C00 0001              		CMPI.B	#1,D0		* CONTINUE AFTER TIMEOUT?
00CC4   67F4            00CBA  		BEQ.S	INPX1		* YES
00CC6   6000 F814       004DC  		BRA	BYTVAL		* OTHERWISE, RETURN KEY
00CCA
00CCA                          	* INTERNAL ENTRY POINT  >> CALLED ALSO FROM READLN; HANDLES TIMEOUTS <<
00CCA                          	* GIVEN D0.W = LINE-INPUT FLAG (ZERO IF SINGLE-CHAR INPUT)
00CCA                          	*   WAIT FOR A KEY, RETURN D0.B = VALUE
00CCA                          	*   IN CASE OF A TIMEOUT, RETURN D0.B = 0 (ABORT) OR 1 (KEEP WAITING)
00CCA                          	*   IF WAITING, RETURN D0 (HI WORD) = NONZERO TO REDRAW INPUT LINE
00CCA
00CCA   48E7 6000              	INPUT	MOVEM.L	D1-D2,-(SP)
00CCE   3400                   		MOVE.W	D0,D2		* SAVE FLAG HERE
00CD0   7001                   		MOVEQ	#1,D0		* START OF INPUT
00CD2   3202                   		MOVE.W	D2,D1		* CHAR/LINE
00CD4   6100 17F0       024C6  		BSR	SETUPI
00CD8
00CD8   6100 1782       0245C  	INPX4	BSR	GAMINT1		* CHECK FOR GAME INTERRUPT (SOUND, ETC)
00CDC   6100 1820       024FE  		BSR	ITTYIN		* CHECK FOR A KEY  << DON'T WAIT! >>
00CE0   4A00                   		TST.B	D0		* GOT ONE?
00CE2   670E            00CF2  		BEQ.S	INPX6		* NOTHING YET
00CE4
00CE4   3F00                   		MOVE.W	D0,-(SP)
00CE6   4240                   		CLR.W	D0		* END OF INPUT
00CE8   3202                   		MOVE.W	D2,D1		* CHAR/LINE
00CEA   6100 17DA       024C6  		BSR	SETUPI
00CEE   301F                   		MOVE.W	(SP)+,D0
00CF0   603E            00D30  		BRA.S	INPX8		* EXIT WITH KEY
00CF2
00CF2   4A6E FF2E              	INPX6	TST.W	TWAIT(A6)	* TIMOUTS IN EFFECT?
00CF6   6DE0            00CD8  		BLT.S	INPX4		* NO, JUST LOOP
00CF8   6100 0276       00F70  		BSR	TCHECK		* TIME (10'S) REMAINING BEFORE NEXT TIMEOUT
00CFC   4A40                   		TST.W	D0		* HAS IT RUN OUT?
00CFE   6ED8            00CD8  		BGT.S	INPX4		* NO, CONTINUE LOOP
00D00
00D00   6100 0266       00F68  		BSR	TNEXT		* YES: UPDATE TIMER
00D04   4240                   		CLR.W	D0		* END OF INPUT (FOR THE MOMENT...)
00D06   3202                   		MOVE.W	D2,D1		* CHAR/LINE
00D08   6100 17BC       024C6  		BSR	SETUPI
00D0C
00D0C   6100 159A       022A8  		BSR	GETCURS
00D10   3401                   		MOVE.W	D1,D2		* REMEMBER CURRENT CURSOR POS (COLUMN)
00D12
00D12   302E FF2C              		MOVE.W  TFUNC(A6),D0	* TIMEOUT FUNCTION
00D16   6100 0AC2       017DA  		BSR	INCALL		* CALL IT (INTERNALLY)
00D1A   4A40                   		TST.W	D0		* IT RETURNS A BOOLEAN -- ABORT INPUT?
00D1C   6610            00D2E  		BNE.S	INPX7		* YES
00D1E
00D1E   6100 1588       022A8  		BSR	GETCURS
00D22   9242                   		SUB.W	D2,D1		* DID CURSOR POS (COLUMN) CHANGE?
00D24   3001                   		MOVE.W	D1,D0		* ZERO IF NO
00D26   4840                   		SWAP	D0		* RETURN THIS FLAG IN HIGH WORD
00D28   303C 0001              		MOVE.W	#1,D0		* 1 MEANS KEEP WAITING
00D2C   6002            00D30  		BRA.S	INPX8
00D2E
00D2E   7000                   	INPX7	MOVEQ	#0,D0		* NULL CHAR MEANS ABORT INPUT
00D30   4CDF 0006              	INPX8	MOVEM.L	(SP)+,D1-D2
00D34   4E75                   		RTS
00D36
00D36                          	* ----------------------
00D36                          	* OPMSINFO
00D36                          	* ----------------------
00D36
00D36                          	* GET MOUSE STATUS
00D36
00D36                          	OPMSINFO
00D36   6100 F65E       00396  		BSR	RELABS

00D3A G 2248                   		MOVE.L	A0,A1		* RETURN VALS IN TABLE
00D3C   6100 1886       025C4  		BSR	GETMOUSE
00D40
00D40 G 2049                   		MOVE.L	A1,A0
00D42   6100 F6BA       003FE  		BSR	PTAWRD		* STORE YPOS
00D46   3001                   		MOVE.W	D1,D0
00D48   6100 F6B4       003FE  		BSR	PTAWRD		* STORE XPOS
00D4C   3002                   		MOVE.W	D2,D0
00D4E   6000 F6AE       003FE  		BRA	PTAWRD		* STORE BUTTON STATUS
00D52
00D52                          	* ----------------------
00D52                          	* OPMSLMT
00D52                          	* ----------------------
00D52
00D52                          	* SET MOUSE LIMITS (WINDOW)
00D52
00D52   3D40 FEF2              	OPMSLMT	MOVE.W	D0,MSWIND(A6)	* UPDATE MOUSE-LIMIT WINDOW ...
00D56   4E75                   		RTS
00D58
00D58                          	* ---------------------------------------------------------------------------
00D58                          	* READ/INPUT PRIMITIVES
00D58                          	* ---------------------------------------------------------------------------
00D58
00D58                          	* ------------------------------
00D58                          	* READLN
00D58                          	* ------------------------------
00D58
00D58                          	* GATHER A LINE OF INPUT
00D58                          	*   GIVEN A0 -> INPUT BUFFER, D0 = MAX LENGTH, D1 = CURRENT LENGTH
00D58                          	*   RETURN A0 -> END OF ACTUAL INPUT (+1), D0 = TERM CHAR
00D58
00D58   0000 000D              	EOLCHR	EQU	$0D		* CARRIAGE RETURN
00D58   0000 0008              	DELCH1	EQU	$08		* BACKSPACE
00D58   0000 007F              	DELCH2	EQU	$7F		* ALSO ACCEPT "DELETE"
00D58
00D58   48E7 6070              	READLN	MOVEM.L D1-D2/A1-A3,-(SP)
00D5C G 2248                   		MOVE.L	A0,A1		* A1 -> START
00D5E G 2448                   		MOVE.L	A0,A2
00D60   D4C1                   		ADDA.W	D1,A2		* A2 -> CURRENT POSITION (MAY BE FULL)
00D62 G 2648                   		MOVE.L	A0,A3
00D64   D6C0                   		ADDA.W	D0,A3		* A3 -> END (+1)
00D66
00D66 G 206E FFA8              	RDLX1	MOVE.L	BUFFER(A6),A0
00D6A   3028 002E              		MOVE.W	PTCHARS(A0),D0	* TABLE OF TERMINATING CHARS
00D6E   6100 F626       00396  		BSR	RELABS		* ABSOLUTIZE
00D72   2408                   		MOVE.L	A0,D2		* KEEP PTR HERE
00D74
00D74                          	*** WAIT FOR A KEY, CHECK FOR A TCHAR ...
00D74
00D74   7001                   	RDLX2	MOVEQ	#1,D0		* LINE INPUT [ALLOW MENU CMD-STRINGS]
00D76   6100 FF52       00CCA  		BSR	INPUT		* NO ECHO, HANDLE TIMEOUTS
00D7A                          	    IF D3BUG THEN
00D7A                          	    ENDIF
00D7A                          	***	BSR	TTYIN
00D7A   4A00                   		TST.B	D0		* WAS THERE A TIME-OUT AND AN ABORT?
00D7C   6760            00DDE  		BEQ.S	RDLX10		* YES, BREAK
00D7E   0C00 0001              		CMPI.B	#1,D0		* WAS THERE A TIME-OUT WITHOUT AN ABORT?
00D82   6758            00DDC  		BEQ.S	RDLX9A		* YES, DO INPUT-ECHO HACK
00D84   0C00 000D              		CMPI.B	#EOLCHR,D0	* CR?
00D88   6754            00DDE  		BEQ.S	RDLX10		* YES, BREAK
00D8A
00D8A G 2042                   		MOVE.L	D2,A0		* TCHARS TABLE
00D8C   7200                   		MOVEQ	#0,D1		* FLAG FOR "FUNCTION-KEY TCHARS"
00D8E   0C10 00FF              	RDLX4	CMPI.B	#255,(A0)	* CONSIDER ALL FKEYS TO BE TCHARS?
00D92   6602            00D96  		BNE.S	RDLX5		* NO
00D94   7201                   		MOVEQ	#1,D1		* YES, SET FLAG
00D96   B010                   	RDLX5	CMP.B	(A0),D0		* CHECK TABLE FOR THIS CHAR
00D98   6744            00DDE  		BEQ.S	RDLX10		* >> FOUND IT, BREAK <<
00D9A   4A18                   		TST.B	(A0)+		* END OF TABLE?
00D9C   66F0            00D8E  		BNE	RDLX4		* NO, CONTINUE SEARCH
00D9E
00D9E                          	* LAST CHANCE TO BE A TCHAR ...
00D9E
00D9E   0C00 007F              		CMPI.B	#127,D0		* SPECIAL CASE: IS THIS CHAR AN FKEY?
00DA2   6306            00DAA  		BLS.S	RDLX6		* NO

00DA4
00DA4   4A41                   		TST.W	D1		* YES: "FUNCTION-KEY TCHARS" ACTIVE?
00DA6   6636            00DDE  		BNE.S	RDLX10		* YES, BREAK
00DA8   602C            00DD6  		BRA.S	RDLX9	* RDLX2	* NO  >> REJECT KEY <<
00DAA
00DAA                          	* NOT A TCHAR, CHECK FOR A BACKSPACE ...
00DAA
00DAA   0C00 0008              	RDLX6	CMPI.B	#DELCH1,D0	* BACKSPACE?
00DAE   6712            00DC2  		BEQ.S	RDLX8		* YES
00DB0   0C00 007F              		CMPI.B	#DELCH2,D0	* DELETE?
00DB4   670C            00DC2  		BEQ.S	RDLX8		* YES
00DB6
00DB6                          	*** NORMAL CHARACTER, HANDLE IT ...
00DB6
00DB6   B5CB                   		CMPA.L	A3,A2		* BUFFER OVERFLOW?
00DB8   641C            00DD6  		BCC.S	RDLX9	* BHS	* YES, IGNORE CHAR, JUST BEEP
00DBA
00DBA   14C0                   		MOVE.B	D0,(A2)+	* STORE CHAR
00DBC   6100 182A       025E8  		BSR	TTYOUT		* AND ECHO IT
00DC0   60B2            00D74  		BRA.S	RDLX2
00DC2
00DC2                          	* HANDLE A BACKSPACE
00DC2
00DC2   B5C9                   	RDLX8	CMPA.L	A1,A2		* BUFFER UNDERFLOW?
00DC4   6310            00DD6  		BLS.S	RDLX9		* YES, JUST BEEP
00DC6
00DC6   538A                   		SUBQ.L	#1,A2		* NO, BACK UP BUFFER POINTER
00DC8   1012                   		MOVE.B	(A2),D0		* (PASS PREVIOUS CHAR IN HIGH BYTE)
00DCA   E148                   		LSL.W	#8,D0
00DCC   103C 0008              		MOVE.B	#DELCH1,D0
00DD0   6100 1816       025E8  		BSR	TTYOUT		* AND ECHO A BS
00DD4   609E            00D74  		BRA	RDLX2
00DD6
00DD6                          	* ERROR, BEEP -- BUFFER TOO FULL/EMPTY. DISCARD CHAR, NO ECHO.
00DD6
00DD6                          	RDLX9
00DD6                          	***	MOVEQ	#1,D0
00DD6                          	***	BSR	DOSOUND
00DD6   6100 1662       0243A  		BSR	ZBEEP		* BEEP AT USER
00DDA                          	    IF D3BUG THEN
00DDA                          	    ENDIF
00DDA   6098            00D74  		BRA	RDLX2		* AND KEEP WAITING
00DDC
00DDC                          	* TIMEOUT OCCURRED (NO ABORT)
00DDC                          	*   RE-ECHO ENTIRE INPUT LINE, BUT ONLY IF GAME WROTE AFTER THE OLD ONE
00DDC                          	*   WE ASSUME GAME PRINTED A FRESH CR, AND A PROMPT (>) IF NEEDED
00DDC                          	*   >> MAJOR KLUDGE, DEAD IN YZIP <<
00DDC
00DDC                          	RDLX9A
00DDC                          	**	SWAP	D0		* "REDRAW" FLAG IS IN HIGH HALF OF REGISTER
00DDC                          	**	TST.W	D0		* DID CURSOR POSITION CHANGE DURING TIMEOUT?
00DDC                          	**	BEQ	RDLX2		* NO, DON'T REDRAW
00DDC
00DDC                          	**	MOVE.L	A1,-(SP)	* SAVE START PTR
00DDC                          	**	BRA.S	RDLX9C
00DDC                          	** X9B	MOVE.B	(A1)+,D0
00DDC                          	**	BSR	TTYOUT		* ECHO ONE-AT-A-TIME, SO WILL WRAP IF NEEDED
00DDC                          	** X9C	CMPA.L	A2,A1		* ANY MORE?
00DDC                          	**	BLT.S	RDLX9B		* YES
00DDC                          	**	MOVE.L	(SP)+,A1
00DDC   6096            00D74  		BRA	RDLX2		* START WAITING AGAIN
00DDE
00DDE                          	*** DONE, HANDLE THE TERMINATING CHAR  <<< DON'T STORE IN BUFFER >>>
00DDE
00DDE   3400                   	RDLX10	MOVE.W	D0,D2		* SAVE TCHAR
00DE0   0C02 000D              		CMPI.B	#EOLCHR,D2	* WAS THE CHAR A RETURN?
00DE4   6604            00DEA  		BNE.S	RDLX12		* NO  >>> SKIP THE ECHO? <<<
00DE6   6100 1800       025E8  		BSR	TTYOUT		* YES, ECHO IT
00DEA
00DEA   B5CB                   	RDLX12	CMPA.L	A3,A2		* ANY ROOM LEFT?
00DEC   6402            00DF0  		BCC.S	RDLX14	* BHS	* NO (SIGH)
00DEE   4212                   		CLR.B	(A2)		* INPUT SHOULD BE FOLLOWED BY A BREAK (ZWSTR)
00DF0
00DF0                          	* ADJUST THE [MORE] COUNTER AFTER MULTI-LINE INPUT (DEAD -- VERY KLUDGY)
00DF0

00DF0   0C02 000D              	RDLX14	CMPI.B	#EOLCHR,D2	* WAS THE CHAR A RETURN?
00DF4   660E            00E04  		BNE.S	RDLX20		* NO
00DF6 G 206E FF14              	RDLX16	MOVE.L	CURWP(A6),A0
00DFA   7000                   		MOVEQ	#0,D0
00DFC   1028 001A              		MOVE.B	WFONTYX(A0),D0	* VERTICAL LINE SIZE
00E00   D168 001E              		ADD.W	D0,WLCNT(A0)	* BUMP THE [MORE] COUNTER
00E04                          	***	ADDQ.W	#1,WLCNT(A0)
00E04
00E04                          	* SCRIPT THE USER INPUT LINE (IF SCRIPTING IS ACTIVE)
00E04                          	*   AVOID PROBLEMS WITH BACKSPACES, BY WAITING UNTIL INPUT IS COMPLETE
00E04                          	* [DEAD -- YZIP]
00E04                          	RDLX20
00E04                          	*	MOVEQ	#0,D1
00E04                          	***	CMPI.B	#EOLCHR,D2	* BUT WAS THE CHAR A RETURN?
00E04                          	***	BNE.S	RDLX22		* NO, AVOID SCRIPTING [XZIP]
00E04                          	***	MOVEQ	#1,D1		* YES, (AND ADD A CR)
00E04
00E04                          	***	MOVE.L	A1,A0		* START OF LINE
00E04                          	***	MOVE.L	A2,D0
00E04                          	***	SUB.L	A1,D0		* LENGTH
00E04                          	***	BSR	SCRINP
00E04
00E04   3002                   	RDLX22	MOVE.W	D2,D0		* RETURN TERM CHAR
00E06 G 204A                   		MOVE.L	A2,A0		* RETURN END-OF-INPUT (+1) POINTER
00E08   4CDF 0E06              		MOVEM.L (SP)+,D1-D2/A1-A3
00E0C   4E75                   		RTS
00E0E
00E0E                          	* ---------------------------
00E0E                          	* LCASE
00E0E                          	* ---------------------------
00E0E
00E0E                          	* LOWER-CASIFY A LINE OF INPUT, A0 -> INPUT, D0.W = LEN
00E0E
00E0E   6012            00E22  	LCASE	BRA.S	LCSX3
00E10   0C10 0041              	LCSX1	CMPI.B	#'A',(A0)	* UPPERCASE CHAR?
00E14   6D0A            00E20  		BLT.S	LCSX2		* NO
00E16   0C10 005A              		CMPI.B	#'Z',(A0)	* MAYBE?
00E1A   6E04            00E20  		BGT.S	LCSX2		* NO
00E1C   0610 0020              		ADDI.B	#32,(A0)	* YES, LOWER-CASIFY IT
00E20   5288                   	LCSX2	ADDQ.L	#1,A0
00E22   51C8 FFEC       00E10  	LCSX3	DBF	D0,LCSX1	* ZERO CHECK  << ENTRY POINT >>
00E26   4E75                   		RTS
00E28
00E28                          	* ------------------------------
00E28                          	* FINDBK
00E28                          	* ------------------------------
00E28
00E28                          	* FIND THE NEXT BREAK CHARACTER
00E28                          	*   GIVEN A0 -> INPUT START, D0.W = INPUT LENGTH
00E28                          	*   RETURN A0 -> FIRST WORD START, D0.W = FIRST WORD LENGTH, OR ZERO
00E28
00E28   48E7 4070              	FINDBK	MOVEM.L	D1/A1-A3,-(SP)
00E2C G 2448                   		MOVE.L	A0,A2
00E2E   D4C0                   		ADDA.W	D0,A2		* END OF INPUT (+1)
00E30   4241                   		CLR.W	D1		* COUNT OF SIGNIFICANT CHARS
00E32
00E32 G 2248                   	FBX1	MOVE.L	A0,A1		* REMEMBER START OF CURRENT WORD
00E34   B5C8                   	FBX2	CMPA.L	A0,A2		* END OF INPUT STRING?
00E36   6724            00E5C  		BEQ.S	FBX8		* YES
00E38   1018                   		MOVE.B	(A0)+,D0	* NO, PICK UP NEXT CHAR
00E3A
00E3A G 266E FFE4              		MOVE.L	RBRKS(A6),A3	* LIST OF READ-BREAK CHARACTERS
00E3E   0C00 007F              		CMPI.B	#127,D0		* BUT IS THIS A FUNCTION KEY?
00E42   620C            00E50  		BHI.S	FBX6		* YES, CONSIDER IT A S.I. BREAK (?)
00E44   B013                   	FBX4	CMP.B	(A3),D0		* SEARCH LIST FOR CHAR  << XZIP: "NULL" TOO >>
00E46   6708            00E50  		BEQ.S	FBX6		* FOUND IT
00E48   4A1B                   		TST.B	(A3)+		* END OF (ASCIZ) LIST?
00E4A   66F8            00E44  		BNE	FBX4		* NO, CONTINUE SEARCH
00E4C   5241                   		ADDQ.W	#1,D1		* YES, NOT A BREAK, BUMP COUNT
00E4E   60E4            00E34  		BRA	FBX2
00E50
00E50                          	*** BREAK CHAR FOUND ...
00E50
00E50   4A41                   	FBX6	TST.W	D1		* WORD READ /BEFORE/ THIS BREAK?
00E52   6608            00E5C  		BNE.S	FBX8		* YES, GO FOR IT

00E54   B7EE FFE0              		CMPA.L	ESIBKS(A6),A3	* NO, BUT WAS THIS A SELF-INSERTING BREAK?
00E58   64D8            00E32  		BCC.S	FBX1	* BHS	* NO, JUST SKIP IT, LOOP FOR NEXT
00E5A   5241                   		ADDQ.W	#1,D1		* YES, BUMP COUNT AND GO FOR ZWORD
00E5C
00E5C                          	*** CLEAN UP AND EXIT ...
00E5C
00E5C G 2049                   	FBX8	MOVE.L	A1,A0		* RETURN START OF CURRENT WORD
00E5E   3001                   		MOVE.W	D1,D0		* RETURN LENGTH OF CURRENT WORD
00E60   4CDF 0E02              		MOVEM.L	(SP)+,D1/A1-A3
00E64   4E75                   		RTS
00E66
00E66                          	* ------------------------------
00E66                          	* RDERR
00E66                          	* ------------------------------
00E66
00E66                          	* TOO MANY WORDS FOUND IN THE INPUT BUFFER, INFORM LOSER
00E66                          	*   A0 -> START OF EXCESS INPUT, A1 -> END OF INPUT (+1)
00E66
00E66   2F08                   	RDERR	MOVE.L	A0,-(SP)	* SAVE ARG HERE
00E68   6100 1118       01F82  		BSR	PUTNEW
00E6C   41ED 0090              		LEA	MSGIO1,A0
00E70   6100 18AE       02720  		BSR	OUTMSG0		* '[Too many words ... "'
00090                          	    DATA
00090   5B546F6F206D61         	MSGIO1	DC.B	'[Too many words typed, discarding ',$22,0
00E74                          	    CODE
00E74
00E74 G 205F                   		MOVE.L	(SP)+,A0	* START OF FLUSHED WORD/STRING
00E76   1F11                   		MOVE.B	(A1),-(SP)	* SAVE TERMINAL BYTE, TO BE SAFE
00E78   4211                   		CLR.B	(A1)		* MAKE STRING ASCIZ
00E7A   6100 18A4       02720  		BSR	OUTMSG0		* ECHO IT
00E7E   129F                   		MOVE.B	(SP)+,(A1)	* RESTORE THIS BYTE
00E80
00E80   41ED 00B4              		LEA	MSGIO2,A0
00E84   6100 18B8       0273E  		BSR	OUTMSG		* '."]'
000B4                          	    DATA
000B4   2E 22 5D 00            	MSGIO2	DC.B	'.',$22,']',0
00E88                          	    CODE
00E88
00E88   6100 10F8       01F82  		BSR	PUTNEW		* FINAL CR
00E8C   4E75                   		RTS
00E8E
00E8E                          	* ---------------------------
00E8E                          	* INITLX
00E8E                          	* ---------------------------
00E8E
00E8E                          	* INIT VOCABULARY VARS, GIVEN A VOCAB TABLE POINTER IN A0
00E8E                          	*   (CALLED AT BEGINNING OF EACH "LEX" CALL)
00E8E
00E8E   48E7 6060              	INITLX	MOVEM.L	D1-D2/A1-A2,-(SP)
00E92   4240                   		CLR.W	D0
00E94   1018                   		MOVE.B	(A0)+,D0	* THIS BYTE IS THE # OF SI BREAKS
00E96   D0C0                   		ADDA.W	D0,A0		* SKIP THEM (READ DURING STARTUP ONLY)
00E98
00E98   4240                   		CLR.W	D0
00E9A   1018                   		MOVE.B	(A0)+,D0	* THIS BYTE IS THE LENGTH OF EACH VOCTAB ENTRY
00E9C   3D40 FFDE              		MOVE.W	D0,VWLEN(A6)	* SAVE IT
00EA0
00EA0   1018                   		MOVE.B	(A0)+,D0	* THIS WORD IS # OF VOCTAB ENTRIES
00EA2   E140                   		ASL.W	#8,D0
00EA4   1018                   		MOVE.B	(A0)+,D0
00EA6   2D48 FFD8              		MOVE.L	A0,VOCBEG(A6)	* THIS IS BEGINNING OF ACTUAL VOCABULARY
00EAA
00EAA   4A40                   		TST.W	D0		* IF POSITIVE #, TABLE IS SORTED
00EAC   6E06            00EB4  		BGT.S	INLX4
00EAE   4440                   		NEG.W	D0		* OTHERWISE, NOT SORTED, POSITIVIZE COUNT
00EB0   4241                   		CLR.W	D1		* AND INDICATE UNSORTED TABLE
00EB2   6014            00EC8  		BRA.S	INLX6
00EB4
00EB4                          	* SORTED TABLE -- CALCULATE INITIAL OFFSET FOR BINARY SEARCH
00EB4
00EB4   3400                   	INLX4	MOVE.W	D0,D2
00EB6   322E FFDE              		MOVE.W	VWLEN(A6),D1	* NUMBER OF BYTES PER VOCAB ENTRY
00EBA   E242                   		ASR.W	#1,D2
00EBC   E341                   	INLX5	ASL.W	#1,D1
00EBE   E242                   		ASR.W	#1,D2

00EC0   66FA            00EBC  		BNE	INLX5
00EC2   3D41 FF6C              		MOVE.W	D1,VWBOFF(A6)	* SAVE INITIAL BINARY SEARCH OFFSET
00EC6
00EC6   7201                   		MOVEQ	#1,D1		* INDICATE A SORTED TABLE
00EC8   3D40 FFDC              	INLX6	MOVE.W	D0,VWORDS(A6)	* SAVE COUNT
00ECC   3D41 FF6E              		MOVE.W	D1,VWSORT(A6)	* SAVE FLAG
00ED0
00ED0   5340                   		SUBQ.W	#1,D0
00ED2   C1EE FFDE              		MULS	VWLEN(A6),D0
00ED6   D0AE FFD8              		ADD.L	VOCBEG(A6),D0	* CALCULATE POINTER TO LAST ENTRY
00EDA   2D40 FFD4              		MOVE.L	D0,VOCEND(A6)	* SAVE IT
00EDE
00EDE   4CDF 0606              		MOVEM.L	(SP)+,D1-D2/A1-A2
00EE2   4E75                   		RTS
00EE4
00EE4                          	* ------------------------------
00EE4                          	* LOOKUP
00EE4                          	* ------------------------------
00EE4
00EE4                          	* SEARCH (CURRENT) VOCAB TABLE FOR A ZWORD, POINTER TO ZWORD IN A0
00EE4                          	*   RETURN ZWORD'S TABLE ADDR (RELATIVIZED) IN D0.W, NULL IF NOT FOUND
00EE4
00EE4   48E7 4070              	LOOKUP	MOVEM.L D1/A1-A3,-(SP)
00EE8 G 2648                   		MOVE.L	A0,A3		* SAVE POINTER TO GIVEN ZWORD HERE
00EEA G 246E FFD8              		MOVE.L	VOCBEG(A6),A2	* BEGINNING OF (CURRENT) VOCABULARY TABLE
00EEE
00EEE   4A6E FFDC              		TST.W	VWORDS(A6)	* EMPTY TABLE?
00EF2   6754            00F48  		BEQ.S	LKX14		* YES, RETURN ZERO
00EF4   4A6E FF6E              		TST.W	VWSORT(A6)	* SORTED TABLE?
00EF8   6616            00F10  		BNE.S	LKX2		* YES
00EFA
00EFA G 204A                   	LKX1	MOVE.L	A2,A0		* NO, MUST DO LINEAR SEARCH
00EFC G 224B                   		MOVE.L	A3,A1
00EFE   6100 0050       00F50  		BSR	VCOMP		* COMPARE GIVEN WORD TO CURRENT WORD
00F02   673C            00F40  		BEQ.S	LKX12		* SAME, WE'VE FOUND IT
00F04
00F04   D4EE FFDE              		ADDA.W	VWLEN(A6),A2	* NEXT TABLE ITEM
00F08   B5EE FFD4              		CMPA.L	VOCEND(A6),A2	* HAVE WE MOVED PAST END OF TABLE?
00F0C   63EC            00EFA  		BLS	LKX1		* NO
00F0E   6038            00F48  		BRA.S	LKX14		* YES, WORD NOT FOUND, RETURN ZERO
00F10
00F10                          	*** SORTED TABLE
00F10
00F10   322E FF6C              	LKX2	MOVE.W	VWBOFF(A6),D1	* INITIAL OFFSET FOR BINARY SEARCH
00F14   D4C1                   		ADDA.W	D1,A2		* INITIAL POINTER INTO TABLE
00F16   94EE FFDE              		SUBA.W	VWLEN(A6),A2	* AVOID FENCE-POST BUG, EXACT-POWER-OF-2 TABLE
00F1A
00F1A   E241                   	LKX4	ASR.W	#1,D1		* NEXT OFFSET WILL BE HALF OF PREVIOUS ONE
00F1C G 204A                   		MOVE.L	A2,A0
00F1E G 224B                   		MOVE.L	A3,A1
00F20   6100 002E       00F50  		BSR	VCOMP		* COMPARE GIVEN WORD TO CURRENT WORD
00F24   6210            00F36  		BHI.S	LKX8		* GREATER, MOVE DOWN
00F26   6718            00F40  		BEQ.S	LKX12		* SAME, WE'VE FOUND IT
00F28                          	***	BCS.S	LKX6	* (BLO)	* LESS, MOVE UP
00F28
00F28   D4C1                   	LKX6	ADDA.W	D1,A2		* TO MOVE UP, ADD OFFSET
00F2A   B5EE FFD4              		CMPA.L	VOCEND(A6),A2	* HAVE WE MOVED PAST END OF TABLE?
00F2E   6308            00F38  		BLS.S	LKX10		* NO
00F30 G 246E FFD4              		MOVE.L	VOCEND(A6),A2	* YES, POINT TO END OF TABLE
00F34   6002            00F38  		BRA.S	LKX10
00F36   94C1                   	LKX8	SUBA.W	D1,A2		* TO MOVE DOWN, JUST SUBTRACT OFFSET
00F38
00F38   B26E FFDE              	LKX10	CMP.W	VWLEN(A6),D1	* IS OFFSET RESOLUTION AT LEAST ONE WORD?
00F3C   6CDC            00F1A  		BGE	LKX4		* YES, CONTINUE LOOP
00F3E   6008            00F48  		BRA.S	LKX14		* NO, WORD NOT FOUND
00F40
00F40                          	*** DONE, WINNING VOCAB POINTER LEFT IN A2
00F40
00F40   200A                   	LKX12	MOVE.L	A2,D0
00F42   90AE FFA8              		SUB.L	BUFFER(A6),D0	* RELATIVIZE THE ZWORD'S VOCAB TABLE OFFSET
00F46   6002            00F4A  		BRA.S	LKX16
00F48
00F48   7000                   	LKX14	MOVEQ	#0,D0		* WORD NOT FOUND, RETURN ZERO
00F4A   4CDF 0E02              	LKX16	MOVEM.L (SP)+,D1/A1-A3
00F4E   4E75                   		RTS

00F50
00F50                          	* ------------------------------
00F50                          	* VCOMP
00F50                          	* ------------------------------
00F50
00F50                          	* COMPARE GIVEN ZWORD (A1) TO CURRENT TABLE ZWORD (A0)
00F50                          	*   RETURN WITH FLAGS
00F50
00F50   7005                   	VCOMP	MOVEQ	#ZCHARS-1,D0	* CHECK THREE WORDS
00F52   B109                   	VCPX1	CMPM.B	(A1)+,(A0)+
00F54   56C8 FFFC       00F52  		DBNE	D0,VCPX1	* TAKE BRANCH IF EQUAL
00F58   4E75                   		RTS
00F5A
00F5A                          	* UNROLL THE LOOP (RUNS A BIT FASTER)
00F5A
00F5A                          	**	CMPM.B	(A1)+,(A0)+	* CHECK FIRST WORD
00F5A                          	**	BNE.S	VCPX2		* DIFFERENT, EXIT
00F5A                          	**	CMPM.B	(A1)+,(A0)+
00F5A                          	**	BNE.S	VCPX2
00F5A
00F5A                          	**	CMPM.B	(A1)+,(A0)+	* CHECK SECOND WORD
00F5A                          	**	BNE.S	VCPX2		* DIFFERENT, EXIT
00F5A                          	**	CMPM.B	(A1)+,(A0)+
00F5A                          	**	BNE.S	VCPX2
00F5A
00F5A                          	**    IF EZIP THEN
00F5A                          	**	CMPM.B	(A1)+,(A0)+	* CHECK THIRD WORD
00F5A                          	**	BNE.S	VCPX2		* DIFFERENT, EXIT
00F5A                          	**	CMPM.B	(A1)+,(A0)+
00F5A                          	**	BNE.S	VCPX2
00F5A                          	**    ENDIF
00F5A
00F5A                          	* VCPX2	RTS			* OTHERWISE SAME, EXIT
00F5A
00F5A
00F5A                          	* ------------------------------
00F5A                          	* TIMEOUT PRIMITIVES
00F5A                          	* ------------------------------
00F5A
00F5A                          	* NOTE: THIS TIMEOUT IMPLEMENTATION USES A SIMPLE "BUSY LOOP" RATHER THAN
00F5A                          	* A REAL CPU INTERRUPT.  THIS IS OK FOR SOME MACHINES BUT WOULD NOT BE GOOD
00F5A                          	* FOR MULTITASKING ONES.  IF AN INTERRUPT IS USED, ONE PROBLEM TO THINK
00F5A                          	* ABOUT:  THE LOW-LEVEL INPUT FUNCTION (TTYIN) MUST BE CANCEL-ABLE WHEN THE
00F5A                          	* TIMEOUT ABORT OCCURS.
00F5A                          	*
00F5A                          	* THE TIMEOUT COUNTDOWN MECHANISM HAS CHANGED A BIT; IT NOW FUNCTIONS ONLY
00F5A                          	* WHEN THE BUSY LOOP IS RUNNING.  IT'S SUSPENDED IF THE LOOP STOPS FOR
00F5A                          	* MORE THAT 1/10 SEC (E.G. WHEN A DESK ACCESSORY IS UP, OR A MENU IS PULLED
00F5A                          	* DOWN.  OTHERWISE, A TIMEOUT COULD OCCUR IN THE BACKGROUND, AND A NOXIOUS
00F5A                          	* EVENT COULD SPILL OUT THE MOMENT THE GAME IS SWITCHED BACK IN.)
00F5A                          	*
00F5A                          	* << WARNING: >> BE CAREFUL ABOUT REDUCING THE POLLING FREQUENCY, AS FOR
00F5A                          	* MULTIFINDER.  MUST LOOP AT LEAST EVERY 1/10 SEC FOR US TO WORK CORRECTLY.
00F5A
00F5A                          	* ----------------------
00F5A                          	* TRESET, TNEXT
00F5A                          	* ----------------------
00F5A
00F5A                          	* RESET THE TIMEOUT COUNTDOWN VARS
00F5A
00F5A   4A6E FF2E              	TRESET	TST.W	TWAIT(A6)	* BUT ARE TIMOUTS IN EFFECT?
00F5E   6D0E            00F6E  		BLT.S	TNEX1		* NO, EXIT
00F60
00F60   6100 149C       023FE  		BSR	TIME60
00F64   2D40 FF28              		MOVE.L	D0,TCLOCK(A6)	* INITIAL REFERENCE TIME (IN 60THS)
00F68
00F68   3D6E FF2E FF26         	TNEXT	MOVE.W	TWAIT(A6),TCOUNT(A6)	* TOTAL DELAY (IN 10THS)
00F6E   4E75                   	TNEX1	RTS
00F70
00F70                          	* ----------------------
00F70                          	* TCHECK
00F70                          	* ----------------------
00F70
00F70                          	* UPDATE THE TIMEOUT CLOCK & COUNTER,
00F70                          	*   RETURN TIME REMAINING (ZERO IF NONE) & FLAGS

00F70
00F70   6100 148C       023FE  	TCHECK  BSR	TIME60		* CURRENT TIME (IN 60THS)
00F74   90AE FF28              		SUB.L	TCLOCK(A6),D0	* ELAPSED TIME, SINCE LAST CHECK
00F78   0C80 0000 000C         		CMPI.L	#12,D0
00F7E   6C0A            00F8A  		BGE.S	TCHX2		* ET >= 2/10, RESET CLOCK, DON'T TOUCH COUNTER
00F80   5D80                   		SUBQ.L	#6,D0
00F82   6D0A            00F8E  		BLT.S	TCHX3		* ET < 1/10, DO NOTHING
00F84
00F84   536E FF26              		SUBQ.W	#1,TCOUNT(A6)	* 1/10 <= ET < 2/10, UPDATE CLOCK & COUNTER
00F88   7006                   		MOVEQ	#6,D0
00F8A   D1AE FF28              	TCHX2	ADD.L	D0,TCLOCK(A6)
00F8E
00F8E   302E FF26              	TCHX3	MOVE.W	TCOUNT(A6),D0	* RETURN COUNTER/FLAGS
00F92   4E75                   		RTS
00F94
00F94

00F94                          	* ---------------------------------------------------------------------------
00F94                          	* I/O OPERATIONS -- OUTPUT
00F94                          	* ---------------------------------------------------------------------------
00F94
00F94                          	* ----------------------
00F94                          	* OPUSL
00F94                          	* ----------------------
00F94
00F94                          	* OPUSL (UPDATE STATUS LINE)
00F94
00F94                          	    IF EZIP THEN
00F94   6000 0D4E       01CE4  	OPUSL	BRA	OPERR		* DEAD INSTRUCTION
00F98                          	    ENDIF
00F98
00F98                          	* ----------------------
00F98                          	* OPPRNC
00F98                          	* ----------------------
00F98
00F98                          	* PRINTC (PRINT CHAR WHOSE ASCII VALUE IS GIVEN)
00F98
00F98   6000 0FEA       01F84  	OPPRNC	BRA	PUTCHR		* HANDLE IT
00F9C
00F9C                          	* ----------------------
00F9C                          	* OPPRNN
00F9C                          	* ----------------------
00F9C
00F9C                          	* PRINTN (PRINT A NUMBER, USING CURRENT CHARACTER OUTPUT FUNCTION)
00F9C
00F9C   3200                   	OPPRNN  MOVE.W  D0,D1		* NON-ZERO NUMBER?
00F9E   6608            00FA8  		BNE.S	PRNNX1		* YES
00FA0   103C 0030              		MOVE.B  #'0',D0		* ZERO, SPECIAL CASE
00FA4   6000 0FDE       01F84  		BRA	PUTCHR		* PRINT A ZERO
00FA8
00FA8   6E0A            00FB4  	PRNNX1	BGT.S	PRNNX2		* POSITIVE?
00FAA   103C 002D              		MOVE.B  #'-',D0		* NO, PRINT A MINUS SIGN
00FAE   6100 0FD4       01F84  		BSR	PUTCHR
00FB2   4441                   		NEG.W	D1		* AND MAKE NUMBER POSITIVE
00FB4
00FB4   4242                   	PRNNX2	CLR.W	D2		* COUNT OF DIGITS ON STACK
00FB6   600E            00FC6  		BRA.S	PRNNX4		* START WITH GREATER-THAN-10 TEST
00FB8
00FB8   48C1                   	PRNNX3	EXT.L	D1		* CLEAR HIGH WORD FOR DIVISION
00FBA   82FC 000A              		DIVU	#10,D1		* EXTRACT A DIGIT (THE REMAINDER)
00FBE   4841                   		SWAP	D1
00FC0   3F01                   		MOVE.W  D1,-(SP)	* PUSH IT
00FC2   4841                   		SWAP	D1
00FC4   5242                   		ADDQ.W  #1,D2		* BUMP COUNT
00FC6
00FC6   0C41 000A              	PRNNX4	CMPI.W  #10,D1		* ANY MORE DIGITS TO EXTRACT?
00FCA   6CEC            00FB8  		BGE	PRNNX3		* YES
00FCC   3001                   		MOVE.W  D1,D0		* NO, POSITION LAST (FIRST) DIGIT
00FCE   6002            00FD2  		BRA.S	PRNNX6
00FD0
00FD0   301F                   	PRNNX5	MOVE.W  (SP)+,D0	* POP NEXT DIGIT
00FD2   0600 0030              	PRNNX6	ADDI.B  #'0',D0		* ASCIIZE IT
00FD6   6100 0FAC       01F84  		BSR	PUTCHR		* PRINT NEXT DIGIT
00FDA   5342                   		SUBQ.W  #1,D2		* ANY DIGITS LEFT ON STACK?
00FDC   6CF2            00FD0  		BGE	PRNNX5		* YES
00FDE   4E75                   		RTS
00FE0
00FE0                          	* ----------------------
00FE0                          	* OPPRIN
00FE0                          	* ----------------------
00FE0
00FE0                          	* PRINT (THE STRING POINTED TO)
00FE0
00FE0   7200                   	OPPRIN	MOVEQ	#0,D1		* ZERO HIGH WORD
00FE2   3200                   		MOVE.W	D0,D1		* QUAD PTR
00FE4   202E FF1A              		MOVE.L	QSOFF(A6),D0	* QUAD STRING OFFSET
00FE8
00FE8   6100 F568       00552  		BSR	BSPLTQ2		* SPLIT THE BLOCK AND OFFSET
00FEC   6000 0D00       01CEE  		BRA	PUTSTR		* PRINT THE STRING
00FF0
00FF0                          	* ----------------------
00FF0                          	* OPPRNB

00FF0                          	* ----------------------
00FF0
00FF0                          	* PRINTB (THE STRING POINTED TO)
00FF0
00FF0   6100 F548       0053A  	OPPRNB  BSR	BSPLTB		* SPLIT THE BLOCK AND OFFSET (BYTE)
00FF4   6000 0CF8       01CEE  		BRA	PUTSTR		* PRINT THE STRING
00FF8
00FF8                          	* ----------------------
00FF8                          	* OPPRND
00FF8                          	* ----------------------
00FF8
00FF8                          	* PRINTD (PRINT OBJ'S SHORT DESCRIPTION)
00FF8
00FF8   6100 F674       0066E  	OPPRND  BSR	OBJLOC		* FIND OBJECT'S LOCATION
00FFC   D0FC 000C              		ADDA.W  #PROP,A0	* PROPERTY TABLE POINTER (ZIP/EZIP)
01000   6100 F3F4       003F6  		BSR	GTAWRD		* GET IT
01004
01004   5240                   		ADDQ.W  #1,D0		* POINT TO SHORT DESCRIPTION STRING
01006   6100 F532       0053A  		BSR	BSPLTB		* SPLIT THE POINTER
0100A   6000 0CE2       01CEE  		BRA	PUTSTR		* AND PRINT THE STRING
0100E
0100E                          	* ----------------------
0100E                          	* OPPRNI
0100E                          	* ----------------------
0100E
0100E                          	* PRINTI (PRINT THE STRING FOLLOWING THIS INSTRUCTION)
0100E
0100E   302E FFBC              	OPPRNI  MOVE.W  ZPC1(A6),D0	* GET POINTER TO STRING
01012   322E FFBA              		MOVE.W  ZPC2(A6),D1
01016   6100 0CD6       01CEE  		BSR	PUTSTR		* PRINT IT
0101A   3D40 FFBC              		MOVE.W  D0,ZPC1(A6)	* AND UPDATE ZPC
0101E   3D41 FFBA              		MOVE.W  D1,ZPC2(A6)
01022   6000 1086       020AA  		BRA	NEWZPC
01026
01026                          	* ----------------------
01026                          	* OPPRNR
01026                          	* ----------------------
01026
01026                          	* PRINTR (PRINTI FOLLOWED BY RTRUE)
01026
01026   61E6            0100E  	OPPRNR  BSR	OPPRNI		* DO A PRINTI
01028   6100 0006       01030  		BSR	OPCRLF		* A CRLF
0102C   6000 0742       01770  		BRA	OPRTRU		* AND AN RTRUE
01030
01030                          	* ----------------------
01030                          	* OPCRLF
01030                          	* ----------------------
01030
01030                          	* CRLF (DO A NEWLINE)
01030
01030   6000 0F50       01F82  	OPCRLF	BRA	PUTNEW		* DO A NEWLINE
01034
01034
01034                          	* ------------------------------------------------------------------
01034                          	* WINDOW-RELATED PRIMITIVES
01034                          	* ------------------------------------------------------------------
01034
01034                          	* ----------------------
01034                          	* CALCWP
01034                          	* ----------------------
01034
01034                          	* GIVEN D0.W = WINDOW ID, RETURN A0 -> THE CORRESPONDING RECORD
01034
01034   4A40                   	CALCWP	TST.W	D0		* VALID WINDOW ID?
01036   6D14            0104C  		BLT.S	CLWPX2		* NO/MAYBE
01038   0C40 0008              		CMPI.W	#MAXWIND,D0
0103C   6C0E            0104C  		BGE.S	CLWPX2		* NO
0103E
0103E   D040                   		ADD.W	D0,D0
01040   D040                   		ADD.W	D0,D0		* OFFSET x4
01042   41EE FEF4              		LEA	WBLOCKP(A6),A0
01046 G 2070 0000              		MOVE.L	0(A0,D0.W),A0	* GET PTR TO NEW WINDOW RECORD
0104A   4E75                   		RTS
0104C
0104C                          	CLWPX2

0104C                          	***	CMPI.W	#-3,D0		* ID = -3 NOW MEANS USE CURRENT WP
0104C                          	***	BEQ.S	CLWPX3
0104C                          	***	BSR	ZWARN
0104C
0104C G 206E FF14              	CLWPX3	MOVE.L	CURWP(A6),A0	* IF ERROR, JUST RETURN CURRENT WP
01050   4E75                   		RTS
01052
01052                          	* ----------------------
01052                          	* WBOUNDS
01052                          	* ----------------------
01052
01052                          	* SET POSITION/SIZE OF THE DISPLAY WINDOW, GIVEN D0.W = ALTERNATE ID
01052                          	* (TEMPORARY, e.g. FOR SCROLL/CLEAR -- DOESN'T CHANGE ANY OTHER WINDOW VARS )
01052
01052   48E7 7000              	WBOUNDS	MOVEM.L	D1-D3,-(SP)
01056   61DC            01034  		BSR	CALCWP
01058   3010                   		MOVE.W	WYPOS(A0),D0
0105A   3228 0002              		MOVE.W	WXPOS(A0),D1
0105E   3428 0004              		MOVE.W	WYSIZE(A0),D2
01062   3628 0006              		MOVE.W	WXSIZE(A0),D3
01066   6100 11A8       02210  		BSR	NEWBOUNDS
0106A   4CDF 000E              		MOVEM.L	(SP)+,D1-D3
0106E   4E75                   		RTS
01070
01070                          	* ----------------------
01070                          	* TSTWFLG
01070                          	* ----------------------
01070
01070                          	* TEST A BIT IN THE CURRENT WINDOW ATTRIBUTES WORD (SCROLL, SCRIPT, ETC),
01070                          	*   GIVEN D0.W = BIT NUMBER, RETURN FLAGS   [MAKE THIS A MACRO?]
01070
01070 G 206E FF14              	TSTWFLG	MOVE.L	CURWP(A6),A0
01074   C068 001C              		AND.W	WATTR(A0),D0	* INDICATED BIT ON?
01078   4E75                   		RTS
0107A
0107A                          	* ------------------------------------------------------------------
0107A                          	* WINDOW OPERATIONS
0107A                          	* ------------------------------------------------------------------
0107A
0107A                          	* ----------------------
0107A                          	* OPSCRN
0107A                          	* ----------------------
0107A
0107A                          	* MAKE OUTPUT FALL INTO SPECIFIED WINDOW, D0.W = ID
0107A                          	* (OPSCRN MAY BE CALLED INTERNALLY, BY OPSPLT)
0107A
0107A   B06E FF18              	OPSCRN	CMP.W	CURWIND(A6),D0
0107E   6700 0088       01108  		BEQ	SCRNX9		* SAME, EXIT
01082
01082   3400                   		MOVE.W	D0,D2		* SAVE ARG
01084                          	***	BSR	PUTLIN1
01084   6100 0F70       01FF6  		BSR	PUTLIN		* EMPTY BUFFER IF NEEDED (KEEPING CURSIZ)
01088
01088                          	* SAVE CURRENT CURSOR POS IN CURRENT WINDOW REC
01088
01088   6100 121E       022A8  		BSR	GETCURS		* GET CURSOR POS [1-ORIGIN]
0108C G 226E FF14              		MOVE.L	CURWP(A6),A1
01090   3340 0008              		MOVE.W	D0,WYCURS(A1)	* AND STORE IT
01094   3341 000A              		MOVE.W	D1,WXCURS(A1)
01098
01098                          	* BUFFER "FULLNESS" INFO NOW /IS/ PRESERVED ACROSS WINDOWS
01098
01098 G 246E FF54              		MOVE.L	DQUE(A6),A2
0109C   336A 000E 0020         		MOVE.W	CURSIZ(A2),WCSIZ(A1)	* SAVE CURRENT BUFFER "FULLNESS"
010A2
010A2                          	* SWITCH WINDOWS (ALL OTHER PARAMS SHOULD BE VALID!)
010A2
010A2   3D42 FF18              		MOVE.W	D2,CURWIND(A6)	* STORE NEW WINDOW ID
010A6   3002                   		MOVE.W	D2,D0
010A8   618A            01034  		BSR	CALCWP
010AA   2D48 FF14              		MOVE.L	A0,CURWP(A6)	* AND NEW RECORD POINTER
010AE G 2248                   		MOVE.L	A0,A1
010B0
010B0                          	* SET UP NEW BUFFER "FULLNESS" INFO  ["BUFSIZ" IS SET ELSEWHERE]
010B0

010B0   3569 0020 000E         		MOVE.W	WCSIZ(A1),CURSIZ(A2)
010B6
010B6                          	* SET UP NEW WINDOW POS/SIZE, CURSOR POS, ETC
010B6
010B6   3029 000C              		MOVE.W	WLMARG(A1),D0
010BA   3229 000E              		MOVE.W	WRMARG(A1),D1
010BE   6100 1242       02302  		BSR	SETMARG
010C2
010C2   3011                   		MOVE.W	WYPOS(A1),D0
010C4   3229 0002              		MOVE.W	WXPOS(A1),D1
010C8   3429 0004              		MOVE.W	WYSIZE(A1),D2
010CC   3629 0006              		MOVE.W	WXSIZE(A1),D3
010D0   6100 10FA       021CC  		BSR	SETBOUNDS	* [MUST CALL /AFTER/ SETMARG]
010D4
010D4   3029 0008              		MOVE.W	WYCURS(A1),D0	* 1-ORIGIN
010D8   3229 000A              		MOVE.W	WXCURS(A1),D1
010DC   6100 1190       0226E  		BSR	SETCURS		* [MUST CALL /AFTER/ SETBOUNDS]
010E0
010E0   3029 0018              		MOVE.W	WFONTID(A1),D0
010E4                          	***	MOVE.W	WFONTXY(A1),D1	* [NOT HANDLED]
010E4   6100 11DC       022C2  		BSR	SETFONT
010E8
010E8   3029 0014              		MOVE.W	WHLIGHT(A1),D0
010EC   6100 11EA       022D8  		BSR	SETHL
010F0   3029 001C              		MOVE.W	WATTR(A1),D0
010F4   6100 11DC       022D2  		BSR	SETATTR
010F8
010F8   3029 0016              		MOVE.W	WCOLOR(A1),D0
010FC   3200                   		MOVE.W	D0,D1
010FE   0240 00FF              		ANDI.W	#$00FF,D0	* FORE
01102   E049                   		LSR.W	#8,D1		* BACK
01104   6100 1220       02326  		BSR	MDCOLOR		* UPDATE SCREEN COLORS
01108
01108   4E75                   	SCRNX9	RTS
0110A
0110A                          	* ----------------------
0110A                          	* OPSPLT
0110A                          	* ----------------------
0110A
0110A                          	* SPLIT THE SCREEN BETWEEN THE FIRST TWO WINDOWS (FOR BACKWARD COMPATIBILITY)
0110A                          	*   GIVEN D0 = LINES IN WINDOW 1 (UPPER)
0110A
0110A   3400                   	OPSPLT	MOVE.W	D0,D2		* SAVE SPLIT COUNT HERE
0110C   6100 0EE0       01FEE  		BSR	PUTLIN1		* EMPTY (&ZERO) BUFFER IF NEEDED
01110
01110                          	* CHECK FOR VALID ARG
01110
01110   6100 1088       0219A  		BSR	MAXSCRN		* GET TOTAL ROWS
01114   B440                   		CMP.W	D0,D2
01116   6F02            0111A  		BLE.S	SPLTX1
01118   3400                   		MOVE.W	D0,D2		* CAN'T HAVE MORE THAN FULL SCREEN
0111A                          	***	BSR	ZWARN
0111A
0111A                          	* READ CURRENT CURSOR POS INTO CURRENT WINDOW REC (ALL OTHER PARAMS SHOULD BE
0111A                          	* VALID!)  (THIS /NOT/ DONE IN OPSCRN, IF CURRENT WINDOW IS W0)
0111A
0111A   6100 118C       022A8  	SPLTX1	BSR	GETCURS		* GET Wx CURSOR POS [1-ORIGIN]
0111E G 226E FF14              		MOVE.L	CURWP(A6),A1
01122   3340 0008              		MOVE.W	D0,WYCURS(A1)	* AND STORE IT
01126   3341 000A              		MOVE.W	D1,WXCURS(A1)
0112A
0112A   3F02                   		MOVE.W	D2,-(SP)	* PROTECT REG(S) ACROSS OPx CALL
0112C   7000                   		MOVEQ	#0,D0		* MAKE SURE WE'RE IN W0
0112E   6100 FF4A       0107A  		BSR	OPSCRN
01132   341F                   		MOVE.W	(SP)+,D2
01134
01134                          	* GET RECORD POINTERS FOR FIRST TWO WINDOWS
01134
01134 G 246E FF14              		MOVE.L	CURWP(A6),A2	* WINDOW 0
01138   7001                   		MOVEQ	#1,D0
0113A   6100 FEF8       01034  		BSR	CALCWP
0113E G 2248                   		MOVE.L	A0,A1		* WINDOW 1
01140
01140                          	* SET NEW POSITIONS/SIZES
01140

01140   303C 0001              		MOVE.W	#1,D0
01144   3280                   		MOVE.W	D0,WYPOS(A1)
01146   3342 0004              		MOVE.W	D2,WYSIZE(A1)
0114A   3340 0008              		MOVE.W	D0,WYCURS(A1)	* "HOME THE W1 CURSOR"
0114E   3340 000A              		MOVE.W	D0,WXCURS(A1)
01152
01152   D042                   		ADD.W	D2,D0
01154   3212                   		MOVE.W	WYPOS(A2),D1	* OLD W0 POSITION
01156   3480                   		MOVE.W	D0,WYPOS(A2)
01158   9240                   		SUB.W	D0,D1
0115A   D26A 0004              		ADD.W	WYSIZE(A2),D1	* "ADJUST SIZE SO W0 BOTTOM DOESN'T MOVE"
0115E   6C02            01162  		BGE.S	SPLTX2
01160   7200                   		MOVEQ	#0,D1
01162   3541 0004              	SPLTX2	MOVE.W	D1,WYSIZE(A2)
01166
01166                          	***	MOVE.W	D2,D0
01166                          	***	BSR	SETSPLT		* [FOR BACKWARD COMPATIBILITY]
01166
01166   3012                   		MOVE.W	WYPOS(A2),D0
01168   322A 0002              		MOVE.W	WXPOS(A2),D1
0116C   342A 0004              		MOVE.W	WYSIZE(A2),D2
01170   362A 0006              		MOVE.W	WXSIZE(A2),D3
01174   6100 109A       02210  		BSR	NEWBOUNDS	* ADJUST BOUNDS, /DON'T/ ADJUST CURSOR
01178
01178   6100 112E       022A8  		BSR	GETCURS		* GET NEW >>RELATIVE<< W0 CURSOR POS
0117C   3540 0008              		MOVE.W	D0,WYCURS(A2)	* AND STORE IT
01180   3541 000A              		MOVE.W	D1,WXCURS(A2)
01184   6100 10E8       0226E  		BSR	SETCURS		* FORCE IT INBOUNDS, IF NEEDED
01188   4E75                   	SPLTX5	RTS
0118A
0118A                          	* ----------------------
0118A                          	* OPWPOS
0118A                          	* ----------------------
0118A
0118A   3600                   	OPWPOS	MOVE.W	D0,D3		* ID
0118C   6100 FEA6       01034  		BSR	CALCWP
01190 G 2648                   		MOVE.L	A0,A3
01192
01192                          	* CHECK FOR VALID POSITION  (SIZE NOT TAKEN INTO ACCOUNT HERE)
01192
01192 G 206E FFA8              		MOVE.L	BUFFER(A6),A0
01196   B268 0024              		CMP.W	PVWRD(A0),D1
0119A   6206            011A2  		BHI.S	WPOSX1		* OUT OF BOUNDS
0119C   B468 0022              		CMP.W	PHWRD(A0),D2
011A0   6308            011AA  		BLS.S	WPOSX2		* OK
011A2
000B8                          	    DATA
000B8   4261642057494E         	MSGWPS	DC.B	'Bad WINPOS',0
011A2                          	    CODE
011A2   41ED 00B8              	WPOSX1	LEA	MSGWPS,A0
011A6   6100 15A0       02748  		BSR	ZWARN		* SHOW A WARNING
011AA
011AA   3681                   	WPOSX2	MOVE.W	D1,WYPOS(A3)	* STORE NEW COORDS  (1-ORIGIN)
011AC   3742 0002              		MOVE.W	D2,WXPOS(A3)
011B0   B66E FF18              		CMP.W	CURWIND(A6),D3	* THIS THE CURRENT ACTIVE WINDOW?
011B4   6610            011C6  		BNE.S	WPOSX9		* NO
011B6
011B6   3001                   		MOVE.W	D1,D0		* YES, UPDATE SCREEN
011B8   3202                   		MOVE.W	D2,D1
011BA   342B 0004              		MOVE.W	WYSIZE(A3),D2
011BE   362B 0006              		MOVE.W	WXSIZE(A3),D3
011C2   6100 1008       021CC  		BSR	SETBOUNDS
011C6   4E75                   	WPOSX9	RTS
011C8
011C8                          	* ----------------------
011C8                          	* OPWSIZ
011C8                          	* ----------------------
011C8
011C8   3600                   	OPWSIZ	MOVE.W	D0,D3		* ID
011CA   6100 FE68       01034  		BSR	CALCWP
011CE G 2648                   		MOVE.L	A0,A3
011D0
011D0   3741 0004              		MOVE.W	D1,WYSIZE(A3)	* STORE NEW SIZE
011D4   3742 0006              		MOVE.W	D2,WXSIZE(A3)
011D8   426B 001E              		CLR.W	WLCNT(A3)	* RESET THE [MORE] COUNTER  [???]

011DC
011DC   B66E FF18              		CMP.W	CURWIND(A6),D3	* THIS THE CURRENT ACTIVE WINDOW?
011E0   660E            011F0  		BNE.S	WSIZX3		* NO
011E2
011E2   3602                   		MOVE.W	D2,D3		* YES, UPDATE SCREEN
011E4   3401                   		MOVE.W	D1,D2
011E6   3013                   		MOVE.W	WYPOS(A3),D0
011E8   322B 0002              		MOVE.W	WXPOS(A3),D1
011EC   6100 0FDE       021CC  		BSR	SETBOUNDS
011F0   4E75                   	WSIZX3	RTS
011F2
011F2                          	* ----------------------
011F2                          	* OPWATTR
011F2                          	* ----------------------
011F2
011F2   0003                   	OPWATTR	DC.W	3		* DEFAULT ARGBLK
011F4   0000 0000 0000         		DC.W	SKIP,SKIP,0	* DEFAULT OP = "MOVE"
011FA
011FA G 2248                   		MOVE.L	A0,A1
011FC   3029 0002              		MOVE.W	ARG1(A1),D0	* WINDOW ID
01200   6100 FE32       01034  		BSR	CALCWP
01204 G 2448                   		MOVE.L	A0,A2
01206
01206   3229 0004              		MOVE.W	ARG2(A1),D1	* ARG BITS
0120A   302A 001C              		MOVE.W	WATTR(A2),D0	* CURRENT BITS
0120E
0120E   3429 0006              		MOVE.W	ARG3(A1),D2	* BITWISE OP:
01212   670E            01222  		BEQ.S	WATTX1		* "MOVE"
01214   5342                   		SUBQ.W	#1,D2
01216   670E            01226  		BEQ.S	WATTX2		* "SET"
01218   5342                   		SUBQ.W	#1,D2
0121A   670E            0122A  		BEQ.S	WATTX3		* "CLEAR"
0121C   5342                   		SUBQ.W	#1,D2
0121E   670C            0122C  		BEQ.S	WATTX4		* "COMP"
01220                          	***	BSR	ZWARN
01220   6026            01248  		BRA.S	WATTX6		* NOT A VALID OP
01222
01222   3001                   	WATTX1	MOVE.W	D1,D0
01224   6008            0122E  		BRA.S	WATTX5
01226   8041                   	WATTX2	OR.W	D1,D0
01228   6004            0122E  		BRA.S	WATTX5
0122A   C240                   	WATTX3	AND.W	D0,D1		* FLIP ONLY THE GIVEN BITS THAT ARE "ON"
0122C   B340                   	WATTX4	EOR.W	D1,D0		* FLIP ALL GIVEN BITS
0122E   3540 001C              	WATTX5	MOVE.W	D0,WATTR(A2)	* STORE BITS
01232
01232   3200                   		MOVE.W	D0,D1
01234   3029 0002              		MOVE.W	ARG1(A1),D0	* WINDOW ID
01238   B06E FF18              		CMP.W	CURWIND(A6),D0	* THIS THE CURRENT ACTIVE WINDOW?
0123C   660A            01248  		BNE.S	WATTX6		* NO
0123E   6100 0DAE       01FEE  		BSR	PUTLIN1		* EMPTY(&ZERO) BUFFER IF NEEDED
01242   3001                   		MOVE.W	D1,D0
01244   6100 108C       022D2  		BSR	SETATTR
01248   4E75                   	WATTX6	RTS
0124A
0124A                          	* ----------------------
0124A                          	* OPCURS
0124A                          	* ----------------------
0124A
0124A                          	* SET CURSOR TO ROW/COLUMN
0124A
0124A   4E71                   	OPCURS	NOP			* REQUEST AN ARGBLK
0124C   0C50 0002              		CMPI.W	#2,(A0)
01250   6E06            01258  		BGT.S	OPCSX1
01252   316E FF18 0006         		MOVE.W	CURWIND(A6),ARG3(A0)	* USE CURRENT WINDOW
01258
01258 G 2248                   	OPCSX1	MOVE.L	A0,A1
0125A   3029 0006              		MOVE.W	ARG3(A1),D0	* WINDOW ID
0125E   6100 FDD4       01034  		BSR	CALCWP
01262 G 2448                   		MOVE.L	A0,A2
01264
01264   3029 0002              		MOVE.W	ARG1(A1),D0	* ROW
01268   3229 0004              		MOVE.W	ARG2(A1),D1	* COL
0126C
0126C   0C40 0001              		CMPI.W	#1,D0		* ROW: OUT OF BOUNDS?
01270   6C04            01276  		BGE.S	OPCSX2

01272   303C 0001              		MOVE.W	#1,D0		* YES, MOVE WITHIN BOUNDS
01276   B06A 0004              	OPCSX2	CMP.W	WYSIZE(A2),D0
0127A   6F04            01280  		BLE.S	OPCSX3
0127C   302A 0004              		MOVE.W	WYSIZE(A2),D0
01280   3540 0008              	OPCSX3	MOVE.W	D0,WYCURS(A2)
01284
01284   0C41 0001              		CMPI.W	#1,D1		* COL: OUT OF BOUNDS?
01288   6C04            0128E  		BGE.S	OPCSX4
0128A   323C 0001              		MOVE.W	#1,D1		* YES, MOVE WITHIN BOUNDS
0128E   B26A 0006              	OPCSX4	CMP.W	WXSIZE(A2),D1
01292   6F04            01298  		BLE.S	OPCSX5
01294   322A 0006              		MOVE.W	WXSIZE(A2),D1
01298   3541 000A              	OPCSX5	MOVE.W	D1,WXCURS(A2)
0129C
0129C   3400                   		MOVE.W	D0,D2		* PROTECT ARG
0129E   3029 0006              		MOVE.W	ARG3(A1),D0
012A2   B06E FF18              		CMP.W	CURWIND(A6),D0	* THIS THE CURRENT ACTIVE WINDOW?
012A6   660A            012B2  		BNE.S	OPCSX6		* NO
012A8
012A8   6100 0D44       01FEE  		BSR	PUTLIN1		* EMPTY(&ZERO) BUFFER IF NEEDED
012AC   3002                   		MOVE.W	D2,D0
012AE   6100 0FBE       0226E  		BSR	SETCURS		* D0 = ROW, D1 = COL
012B2   4E75                   	OPCSX6	RTS
012B4
012B4                          	* ----------------------
012B4                          	* OPCURG
012B4                          	* ----------------------
012B4
012B4                          	* GET CURSOR POSITION  [1-ORIGIN] [ALWAYS CURRENT WINDOW]
012B4
012B4                          	OPCURG
012B4                          	*	MOVE.W	D0,-(SP)
012B4                          	*	BSR	PUTLIN		* [DONE BY GETCURS]
012B4                          	*	MOVE.W	(SP)+,D0
012B4   6100 F0E0       00396  		BSR	RELABS		* TABLE FOR RETURN VALUES
012B8 G 2248                   		MOVE.L	A0,A1
012BA   6100 0FEC       022A8  		BSR	GETCURS
012BE G 2049                   		MOVE.L	A1,A0
012C0   6100 F13C       003FE  		BSR	PTAWRD		* STORE ROW
012C4 G 2049                   		MOVE.L	A1,A0
012C6   5488                   		ADDQ.L	#2,A0
012C8   3001                   		MOVE.W	D1,D0
012CA   6000 F132       003FE  		BRA	PTAWRD		* STORE COLUMN
012CE
012CE                          	* ----------------------
012CE                          	* OPWGET
012CE                          	* ----------------------
012CE
012CE   0003                   	OPWGET	DC.W	3		* DEFAULT ARGBLK
012D0   0000 0000 0000         		DC.W	SKIP,SKIP,0	* DEFAULT OFFSET = 0
012D6
012D6 G 2448                   		MOVE.L	A0,A2		* A2 -> ARGBLK
012D8   302A 0002              		MOVE.W	ARG1(A2),D0
012DC   B06E FF18              		CMP.W	CURWIND(A6),D0	* FROM THE CURRENT WINDOW?
012E0   6612            012F4  		BNE.S	OPWGX1		* NO
012E2
012E2   6100 0FC4       022A8  		BSR	GETCURS		* YES, FIRST GET CURSOR POS
012E6 G 206E FF14              		MOVE.L	CURWP(A6),A0
012EA   3140 0008              		MOVE.W	D0,WYCURS(A0)	* AND STORE IT
012EE   3141 000A              		MOVE.W	D1,WXCURS(A0)
012F2   6004            012F8  		BRA.S	OPWGX2
012F4
012F4   6100 FD3E       01034  	OPWGX1	BSR	CALCWP
012F8 G 2248                   	OPWGX2	MOVE.L	A0,A1		* A1 -> WREC
012FA   302A 0006              		MOVE.W	ARG3(A2),D0	* OFFSET (IN WREC)
012FE   6D2A            0132A  		BLT.S	OPWGX9		* EXIT
01300   7211                   		MOVEQ	#WBLKLEN/2,D1
01302   9240                   		SUB.W	D0,D1		* D1 = MAX #ITEMS (WORDS) TO COPY
01304   6F24            0132A  		BLE.S	OPWGX9		* EXIT
01306   D040                   		ADD.W	D0,D0
01308   D2C0                   		ADDA.W	D0,A1
0130A
0130A   302A 0004              		MOVE.W	ARG2(A2),D0
0130E   6100 F086       00396  		BSR	RELABS		* A0 -> LTABLE
01312   6100 F0E2       003F6  		BSR	GTAWRD		*   (ADVANCE PTR)

01316   3400                   		MOVE.W	D0,D2		* D2 = MAX TABLE LEN (WORDS)
01318   6F10            0132A  		BLE.S	OPWGX9		* EXIT
0131A   B441                   		CMP.W	D1,D2
0131C   6F02            01320  		BLE.S	OPWGX4		* USE SMALLER OF TWO
0131E   3401                   		MOVE.W	D1,D2
01320
01320   3019                   	OPWGX4	MOVE.W	(A1)+,D0
01322   6100 F0DA       003FE  		BSR	PTAWRD		* COPY A WORD, ADVANCE PTR
01326   5342                   		SUBQ.W	#1,D2
01328   6EF6            01320  		BGT.S	OPWGX4		* LOOP
0132A   4E75                   	OPWGX9	RTS
0132C
0132C                          	* ----------------------
0132C                          	* OPWPUT
0132C                          	* ----------------------
0132C
0132C   0003                   	OPWPUT	DC.W	3		* DEFAULT ARGBLK
0132E   0000 0000 0000         		DC.W	SKIP,SKIP,0	* DEFAULT OFFSET = 0
01334
01334 G 2448                   		MOVE.L	A0,A2		* A2 -> ARGBLK
01336   302A 0002              		MOVE.W	ARG1(A2),D0
0133A   6100 FCF8       01034  		BSR	CALCWP
0133E G 2648                   		MOVE.L	A0,A3		* A3 -> WREC
01340
01340   7022                   		MOVEQ	#WBLKLEN,D0
01342 G 9EC0                   		SUB.W	D0,SP		* MAKE SPACE FOR A TEMPORARY WREC
01344 G 224F                   		MOVE.L	SP,A1
01346   32D8                   	OPWPX2	MOVE.W	(A0)+,(A1)+	* COPY CONTENTS
01348   5540                   		SUBQ.W	#2,D0
0134A   66FA            01346  		BNE.S	OPWPX2
0134C G 224F                   		MOVE.L	SP,A1		* A1 -> TEMPORARY WREC
0134E
0134E   302A 0006              		MOVE.W	ARG3(A2),D0	* OFFSET (IN WREC)
01352   6D38            0138C  		BLT.S	OPWPX9		* EXIT
01354   7211                   		MOVEQ	#WBLKLEN/2,D1
01356   9240                   		SUB.W	D0,D1		* D1 = MAX #ITEMS (WORDS) TO COPY
01358   6F32            0138C  		BLE.S	OPWPX9		* EXIT
0135A   D040                   		ADD.W	D0,D0
0135C   D2C0                   		ADDA.W	D0,A1
0135E
0135E   302A 0004              		MOVE.W	ARG2(A2),D0
01362   6100 F032       00396  		BSR	RELABS		* A0 -> LTABLE
01366   6100 F08E       003F6  		BSR	GTAWRD		*   (ADVANCE PTR)
0136A   3400                   		MOVE.W	D0,D2		* D2 = MAX TABLE LEN (WORDS)
0136C   6F1E            0138C  		BLE.S	OPWPX9		* EXIT
0136E   B441                   		CMP.W	D1,D2
01370   6F02            01374  		BLE.S	OPWPX4		* USE SMALLER OF TWO
01372   3401                   		MOVE.W	D1,D2
01374
01374   6100 F080       003F6  	OPWPX4	BSR	GTAWRD		* PICKUP A WORD, ADVANCE PTR
01378   32C0                   		MOVE.W	D0,(A1)+	* COPY TO (TEMPORARY) WREC
0137A   5342                   		SUBQ.W	#1,D2
0137C   6EF6            01374  		BGT.S	OPWPX4		* LOOP
0137E
0137E                          	* FINALLY, UPDATE THE ACTUAL WREC
0137E                          	* THE CR FUNCTION/COUNT SLOTS ARE THE ONLY "LEGALLY WRITABLE" ONES
0137E
0137E G 224F                   		MOVE.L	SP,A1		* A1 -> TEMPORARY WREC
01380   3769 0010 0010         		MOVE.W	WCRINT(A1),WCRINT(A3)
01386   3769 0012 0012         		MOVE.W	WCRCNT(A1),WCRCNT(A3)
0138C
0138C   7022                   	OPWPX9	MOVEQ	#WBLKLEN,D0
0138E G DEC0                   		ADD.W	D0,SP		* CLEANUP STACK
01390   4E75                   		RTS
01392
01392                          	* ----------------------
01392                          	* OPSCROLL
01392                          	* ----------------------
01392
01392                          	OPSCROLL
01392   0002                   		DC.W	2		* DEFAULT ARGBLK
01394   0000 0001              		DC.W	SKIP,1		* DEFAULT DISTANCE = 1 UP
01398
01398 G 2448                   		MOVE.L	A0,A2		* A2 -> ARGBLK
0139A   6100 0C5A       01FF6  		BSR	PUTLIN		* FIRST EMPTY BUFFER, IF NEEDED

0139E   342E FF18              		MOVE.W	CURWIND(A6),D2	* SAVE ORIGINAL VALUE
013A2   302A 0002              		MOVE.W	ARG1(A2),D0
013A6   B440                   		CMP.W	D0,D2		* SAME?
013A8   670E            013B8  		BEQ.S	ROLLX1		* YES, JUST DO THE SCROLL
013AA
013AA   6100 FCA6       01052  		BSR	WBOUNDS		* OTHERWISE, TEMPORARILY RESET WINDOW BOUNDS
013AE   6100 0008       013B8  		BSR	ROLLX1		*  >> CALL AS SUBR <<
013B2   3002                   		MOVE.W	D2,D0		* THEN RESTORE THEM
013B4   6000 FC9C       01052  		BRA	WBOUNDS		*   AND EXIT
013B8
013B8   302A 0004              	ROLLX1	MOVE.W	ARG2(A2),D0
013BC   6100 0F24       022E2  		BSR	MDSCROLL
013C0   4E75                   		RTS
013C2
013C2                          	* ----------------------
013C2                          	* OPCLEAR
013C2                          	* ----------------------
013C2
013C2                          	* CLEAR A WINDOW, OR ENTIRE SCREEN
013C2
013C2   3400                   	OPCLEAR	MOVE.W	D0,D2
013C4   6100 0C28       01FEE  		BSR	PUTLIN1		* EMPTY & ZERO BUFFER, IF NEEDED
013C8   4A42                   		TST.W	D2		* ID NEGATIVE?
013CA   6D22            013EE  		BLT.S	OCLRX6		* YES, HANDLE SPECIALLY
013CC
013CC   362E FF18              		MOVE.W	CURWIND(A6),D3
013D0   B443                   		CMP.W	D3,D2		* IN CURRENT WINDOW?
013D2   6710            013E4  		BEQ.S	OCLRX2		* YES
013D4
013D4   3002                   		MOVE.W	D2,D0
013D6   6100 FC7A       01052  		BSR	WBOUNDS		* OTHERWISE, TEMPORARILY RESET WINDOW BOUNDS
013DA   6100 0008       013E4  		BSR	OCLRX2		*  >> CALL AS SUBR <<
013DE   3003                   		MOVE.W	D3,D0		* RESTORE CURRENT BOUNDS
013E0   6000 FC70       01052  		BRA	WBOUNDS		*   AND EXIT
013E4
013E4   7000                   	OCLRX2	MOVEQ	#0,D0
013E6   6100 0F0A       022F2  		BSR	MDCLEAR		* CLEAR TARGET WINDOW (VISIBLY)
013EA                          	*	MOVE.W	D2,xx
013EA   6000 001E       0140A  		BRA	OCLRX8		* HOME CURSOR
013EE
013EE                          	* HANDLE NEGATIVE ARGS:
013EE
013EE   3D7C 0001 FEF0         	OCLRX6	MOVE.W	#1,INLAST(A6)	* "DON'T PAUSE UPON EXIT IF SCREEN CLEARED"
013F4
013F4   70FF                   		MOVEQ	#-1,D0
013F6   6100 0EFA       022F2  		BSR	MDCLEAR		* CLEAR ENTIRE SCREEN
013FA   0C42 FFFF              		CMPI.W	#-1,D2		* SPLIT REQUESTED?
013FE   6606            01406  		BNE.S	OCLRX7		* NO
01400
01400                          	*	MOVE.L	XX,-(SP)	* PROTECT REG(S) ACROSS OPx CALL
01400   7000                   		MOVEQ	#0,D0
01402   6100 FD06       0110A  		BSR	OPSPLT		* DO A SPLIT-0
01406                          	*	MOVE.L	(SP)+,XX
01406
01406   342E FF18              	OCLRX7	MOVE.W	CURWIND(A6),D2
0140A
0140A                          	* HOME CURSOR AND RESET LINE COUNT, D2.W = TARGET WINDOW
0140A
0140A   3002                   	OCLRX8	MOVE.W	D2,D0
0140C   6100 FC26       01034  		BSR	CALCWP		* GET TARGET WREC
01410   7001                   		MOVEQ	#1,D0
01412   3140 0008              		MOVE.W	D0,WYCURS(A0)	* HOME CURSOR IN TARGET WINDOW
01416   7201                   		MOVEQ	#1,D1
01418   D268 000C              		ADD.W	WLMARG(A0),D1
0141C   3141 000A              		MOVE.W	D1,WXCURS(A0)
01420   4268 001E              		CLR.W	WLCNT(A0)	* RESET THE 'MORE' COUNTER
01424
01424   B46E FF18              		CMP.W	CURWIND(A6),D2	* IN CURRENT WINDOW?
01428   6604            0142E  		BNE.S	OCLRX9
0142A   6100 0E42       0226E  		BSR	SETCURS		* YES: UPDATE SCREEN CURSOR
0142E   4E75                   	OCLRX9	RTS
01430
01430                          	* ----------------------
01430                          	* OPERASE
01430                          	* ----------------------

01430
01430                          	* ERASE (CURRENT LINE, STARTING AT CURSOR)
01430
01430   5340                   	OPERASE	SUBQ.W	#1,D0
01432   660C            01440  		BNE.S	ERAX1		* "IGNORE ARG IF NOT 1"
01434   6100 0BC0       01FF6  		BSR	PUTLIN		* EMPTY BUFFER, IF NEEDED
01438   70FF                   		MOVEQ	#-1,D0		* FROM CURSOR ...
0143A   72FF                   		MOVEQ	#-1,D1		* ... TO EOL
0143C   6100 0ED6       02314  		BSR	MDERASE
01440   4E75                   	ERAX1	RTS
01442
01442                          	* ----------------------
01442                          	* OPHLIGHT  [WAS OPATTR]
01442                          	* ----------------------
01442
01442                          	* HIGHLIGHT (SET DISPLAY MODE FOR SUBSEQUENT OUTPUT)
01442                          	* D0.W = 0 PLAIN, 1 INVERSE, 2 BOLD, 4 ITALIC  (8 MONO)
01442
01442                          	OPHLIGHT
01442 G 206E FF14              		MOVE.L	CURWP(A6),A0	* [ALWAYS IN CURRENT WINDOW]
01446   3140 0014              		MOVE.W	D0,WHLIGHT(A0)	* STORE NEW MODE
0144A
0144A   3200                   		MOVE.W	D0,D1
0144C   6100 0BA8       01FF6  		BSR	PUTLIN		* EMPTY THE LINE BUFFER (IN OLD MODE)
01450   3001                   		MOVE.W	D1,D0
01452   6000 0E84       022D8  		BRA	SETHL
01456                          	***	BRA	MDATTR
01456
01456                          	* ----------------------
01456                          	* OPFONT
01456                          	* ----------------------
01456
01456   4E71                   	OPFONT	NOP			* REQUEST AN ARGBLK
01458 G 2248                   		MOVE.L	A0,A1
0145A   0C51 0001              		CMPI.W	#1,(A1)		* WINDOW ID SUPPLIED?
0145E   6E06            01466  		BGT.S	FONTX2
01460 G 206E FF14              		MOVE.L	CURWP(A6),A0	* NO, USE DEFAULT
01464   6008            0146E  		BRA.S	FONTX4
01466
01466   3029 0004              	FONTX2	MOVE.W	ARG2(A1),D0	* YES, GET PTR
0146A   6100 FBC8       01034  		BSR	CALCWP
0146E
0146E   3229 0002              	FONTX4	MOVE.W	ARG1(A1),D1	* NEW FONT ID
01472   3428 0018              		MOVE.W	WFONTID(A0),D2	* OLD FONT ID
01476   B242                   		CMP.W	D2,D1		* >>> IS THE FONT REALLY CHANGING? <<<
01478   6714            0148E  		BEQ.S	FONTX9		* NO, EXIT (WITHOUT EMPTYING BUFFER!)
0147A   3141 0018              		MOVE.W	D1,WFONTID(A0)	* STORE NEW FONT ID
0147E
0147E G B1EE FF14              		CMP.L	CURWP(A6),A0	* WORKING WITH THE CURRENT WINDOW?
01482   660A            0148E  		BNE.S	FONTX9		* NO, DONE
01484
01484   6100 0B70       01FF6  		BSR	PUTLIN		* EMPTY THE LINE BUFFER (IN OLD FONT)
01488   3001                   		MOVE.W	D1,D0
0148A   6100 0E36       022C2  		BSR	SETFONT		* UPDATE SCREEN FONT
0148E
0148E   3002                   	FONTX9	MOVE.W	D2,D0
01490   6000 F04E       004E0  		BRA	PUTVAL		* RETURN OLD FONT ID
01494
01494                          	* ----------------------
01494                          	* OPCOLOR
01494                          	* ----------------------
01494
01494   4E71                   	OPCOLOR	NOP			* REQUEST AN ARGBLK
01496 G 2248                   		MOVE.L	A0,A1
01498   0C51 0002              		CMPI.W	#2,(A1)		* WINDOW ID SUPPLIED?
0149C   6E06            014A4  		BGT.S	COLRX2
0149E G 206E FF14              		MOVE.L	CURWP(A6),A0	* NO, USE DEFAULT
014A2   6008            014AC  		BRA.S	COLRX4
014A4
014A4   3029 0006              	COLRX2	MOVE.W	ARG3(A1),D0	* YES, GET PTR
014A8   6100 FB8A       01034  		BSR	CALCWP
014AC
014AC   1229 0005              	COLRX4	MOVE.B	ARG2+1(A1),D1	* BACK
014B0   E149                   		LSL.W	#8,D1
014B2   1229 0003              		MOVE.B	ARG1+1(A1),D1	* FORE

014B6   3141 0016              		MOVE.W	D1,WCOLOR(A0)	* STORE NEW COLORS
014BA
014BA G B1EE FF14              		CMP.L	CURWP(A6),A0	* WORKING WITH THE CURRENT WINDOW?
014BE   6610            014D0  		BNE.S	COLRX9		* NO, DONE
014C0
014C0   6100 0B34       01FF6  		BSR	PUTLIN		* EMPTY THE LINE BUFFER (IN OLD FONT)
014C4   3029 0002              		MOVE.W	ARG1(A1),D0	* FORE
014C8   3229 0004              		MOVE.W	ARG2(A1),D1	* BACK
014CC   6100 0E58       02326  		BSR	MDCOLOR		* UPDATE SCREEN COLORS
014D0   4E75                   	COLRX9	RTS
014D2
014D2                          	* ----------------------
014D2                          	* OPMARG
014D2                          	* ----------------------
014D2
014D2                          	* SET MARGINS
014D2
014D2   4E71                   	OPMARG	NOP			* REQUEST AN ARGBLK
014D4 G 2248                   		MOVE.L	A0,A1
014D6   0C51 0002              		CMPI.W	#2,(A1)		* WINDOW ID SUPPLIED?
014DA   6E06            014E2  		BGT.S	MARGX2
014DC G 206E FF14              		MOVE.L	CURWP(A6),A0	* NO, USE DEFAULT
014E0   6008            014EA  		BRA.S	MARGX4
014E2
014E2   3029 0006              	MARGX2	MOVE.W	ARG3(A1),D0	* YES, GET PTR
014E6   6100 FB4C       01034  		BSR	CALCWP
014EA
014EA G 2448                   	MARGX4	MOVE.L	A0,A2
014EC   3429 0002              		MOVE.W	ARG1(A1),D2
014F0   3542 000C              		MOVE.W	D2,WLMARG(A2)
014F4   3629 0004              		MOVE.W	ARG2(A1),D3
014F8   3543 000E              		MOVE.W	D3,WRMARG(A2)
014FC
014FC   7201                   		MOVEQ	#1,D1
014FE   D242                   		ADD.W	D2,D1
01500   3541 000A              		MOVE.W	D1,WXCURS(A2)	* MOVE CURSOR TO LEFT MARGIN
01504
01504 G B5EE FF14              		CMP.L	CURWP(A6),A2	* WORKING WITH THE CURRENT WINDOW?
01508   6612            0151C  		BNE.S	MARGX9		* NO
0150A
0150A                          	*** NOTE: CR-INTERRUPT ROUTINES COMMONLY CALL OPMARG (TO FLOW AROUND PICTURES),
0150A                          	*** IN WHICH CASE WE SHOULD /NOT/ EMPTY THE BUFFER, BUT ALLOW IT TO WRAP.
0150A                          	*** [MOREOVER, PUTLIN/QUECHR IS /NOT/ RE-ENTRANT -- GARBAGE IS DISPLAYED]
0150A                          	*** IN OTHER CASES, THE GAME SHOULD ITSELF ENSURE THAT THE BUFFER IS EMPTY.
0150A                          	***	BSR	PUTLIN		* EMPTY THE LINE BUFFER
0150A   3002                   		MOVE.W	D2,D0
0150C   3203                   		MOVE.W	D3,D1
0150E   6100 0DF2       02302  		BSR	SETMARG		* UPDATE DISPLAY VARS
01512
01512   70FF                   		MOVEQ	#-1,D0		* [DON'T CHANGE ROW]
01514   7201                   		MOVEQ	#1,D1
01516   D242                   		ADD.W	D2,D1
01518   6100 0D54       0226E  		BSR	SETCURS		* MOVE CURSOR TO LEFT MARGIN
0151C   4E75                   	MARGX9	RTS
0151E
0151E                          	* ---------------------------------------------------------------------------
0151E                          	* MORE I/O OPERATIONS
0151E                          	* ---------------------------------------------------------------------------
0151E
0151E                          	* ----------------------
0151E                          	* OPBUFO
0151E                          	* ----------------------
0151E
0151E                          	* SET BUFFERING OF OUTPUT ACCORDING TO INT
0151E
0151E                          	OPBUFO
0151E                          	***	RTS		* [SEMI-OBSOLETE OP; SLOWS DRAWING ON MAC]
0151E
0151E   5340                   		SUBQ.W	#1,D0		* NORMAL BUFFERING?
01520   6706            01528  		BEQ.S	BUFOX1		* YES
01522   5240                   		ADDQ.W	#1,D0		* NO BUFFERING, OUTPUT DIRECTLY TO SCREEN?
01524   670A            01530  		BEQ.S	BUFOX2		* YES
01526   6018            01540  		BRA.S	BUFOX3		* ELSE DO NOTHING
01528
01528   3D7C 0001 FF5A         	BUFOX1	MOVE.W	#1,VOBUFF(A6)	* TURN ON BUFFERING

0152E   6010            01540  		BRA.S	BUFOX3
01530                          	BUFOX2
01530
000C3                          	    DATA
000C3   4255464F555420         	MSGBFO	DC.B	'BUFOUT off',0
01530                          	    CODE
01530   41ED 00C3              		LEA	MSGBFO,A0
01534   6100 1212       02748  		BSR	ZWARN		* SHOW A WARNING
01538
01538   6100 0ABC       01FF6  		BSR	PUTLIN		* FIRST EMPTY THE CURRENT OUTPUT BUFFER
0153C   426E FF5A              		CLR.W	VOBUFF(A6)	* THEN TURN OFF BUFFERING
01540   4E75                   	BUFOX3	RTS
01542
01542
01542                          	* ----------------------
01542                          	* TABCHR
01542                          	* ----------------------
01542
01542                          	* TABLE OUTPUT FUNCTION --- PUT THE CHAR IN D0 IN THE DEFINED TABLE
01542
01542 G 206E FF48              	TABCHR  MOVE.L  TABPTR(A6),A0	* CURRENT POSITION IN TABLE
01546   10C0                   		MOVE.B  D0,(A0)+	* STORE CHAR
01548   2D48 FF48              		MOVE.L  A0,TABPTR(A6)	* UPDATE POINTER
0154C   4E75                   		RTS
0154E
0154E                          	* ----------------------
0154E                          	* OPDIRO
0154E                          	* ----------------------
0154E
0154E                          	* REDIRECT OUTPUT (TABLE OR NORMAL) ACCORDING TO INT
0154E
0154E   4E71                   	OPDIRO  NOP			* TELL CALLER TO USE ARGBLK
01550   3028 0002              		MOVE.W	ARG1(A0),D0	* VIRTUAL OUTPUT DEVICE -- NEGATIVE?
01554   6D0E            01564  		BLT.S	DIRX0		* YES, MEANS TURN IT OFF
01556
01556   5340                   		SUBQ.W	#1,D0		* TURN ON SCREEN?
01558   6718            01572  		BEQ.S	DIRX1		* YES
0155A   5340                   		SUBQ.W	#1,D0		* TURN ON PRINTER?
0155C   6726            01584  		BEQ.S	DIRX3		* YES
0155E   5340                   		SUBQ.W	#1,D0		* TURN ON TABLE?
01560   675C            015BE  		BEQ.S	DIRX5		* YES
01562   4E75                   		RTS			* UNKNOWN DEVICE, IGNORE REQUEST
01564
01564   5240                   	DIRX0	ADDQ.W	#1,D0		* TURN OFF SCREEN?
01566   6712            0157A  		BEQ.S	DIRX2		* YES
01568   5240                   		ADDQ.W	#1,D0		* TURN OFF PRINTER?
0156A   6736            015A2  		BEQ.S	DIRX4		* YES
0156C   5240                   		ADDQ.W	#1,D0		* TURN OFF TABLE?
0156E   676A            015DA  		BEQ.S	DIRX6		* YES
01570   4E75                   		RTS			* UNKNOWN DEVICE, IGNORE REQUEST
01572
01572                          	*** TURN SCREEN OUTPUT ON, OFF
01572
01572   3D7C 0001 FF68         	DIRX1	MOVE.W	#1,VOCONS(A6)
01578   607A            015F4  		BRA.S	DIRX7
0157A   6100 0A7A       01FF6  	DIRX2	BSR	PUTLIN		* BUT FIRST DUMP BUFFER, IF NEEDED
0157E   426E FF68              		CLR.W	VOCONS(A6)
01582   6070            015F4  		BRA.S	DIRX7
01584
01584                          	*** TURN SCRIPTING OUTPUT ON, OFF
01584
01584   4A6E FF66              	DIRX3	TST.W	VOPRNT(A6)	* ALREADY ON?
01588   666A            015F4  		BNE.S	DIRX7		* YES
0158A
0158A   303C 0001              		MOVE.W	#1,D0
0158E   3D40 FF66              		MOVE.W	D0,VOPRNT(A6)
01592   6100 11F4       02788  		BSR	SCRINIT		* OPEN SCRIPT CHANNEL (IF NEEDED)
01596
01596 G 206E FFA8              		MOVE.L  BUFFER(A6),A0
0159A   08E8 0000 0011         		BSET	#0,PFLAGS+1(A0) * SET PRELOAD FLAG FOR GAME'S USE
015A0   6052            015F4  		BRA.S	DIRX7
015A2
015A2   4A6E FF66              	DIRX4 	TST.W	VOPRNT(A6)	* ALREADY OFF?
015A6   674C            015F4  		BEQ.S	DIRX7		* YES
015A8

015A8   7000                   		MOVEQ	#0,D0
015AA   3D40 FF66              		MOVE.W	D0,VOPRNT(A6)
015AE   6100 11D8       02788  		BSR	SCRINIT		* CLOSE SCRIPT CHANNEL (IF NEEDED)
015B2
015B2 G 206E FFA8              		MOVE.L  BUFFER(A6),A0
015B6   08A8 0000 0011         		BCLR	#0,PFLAGS+1(A0) * CLEAR THE PRELOAD FLAG
015BC   6036            015F4  		BRA.S	DIRX7
015BE
015BE                          	*** TURN TABLE ON, OFF
015BE
015BE   7000                   	DIRX5	MOVEQ	#0,D0
015C0   3028 0004              		MOVE.W  ARG2(A0),D0	* GET RELATIVE TABLE POINTER
015C4   D0AE FFA8              		ADD.L	BUFFER(A6),D0	* ABSOLUTIZE
015C8   2D40 FF4C              		MOVE.L  D0,TABOUT(A6)	* REMEMBER START OF TABLE
015CC
015CC   5480                   		ADDQ.L  #2,D0		* SKIP LENGTH SLOT
015CE   2D40 FF48              		MOVE.L  D0,TABPTR(A6)	* FIRST CHAR WILL GO HERE
015D2
015D2   3D7C 0001 FF62         		MOVE.W	#1,VOTABL(A6)	* SET TABLE-OUTPUT FLAG
015D8   601A            015F4  		BRA.S	DIRX7
015DA
015DA   4A6E FF62              	DIRX6	TST.W	VOTABL(A6)	* MAKE SURE A TABLE DOES EXIST
015DE   6714            015F4  		BEQ.S	DIRX7		* NO TABLE, IGNORE REQUEST
015E0   426E FF62              		CLR.W	VOTABL(A6)	* OK, TURN OFF TABLE-OUTPUT FLAG
015E4
015E4 G 206E FF4C              		MOVE.L  TABOUT(A6),A0	* COMPUTE LENGTH OF CURRENT TABLE CONTENTS
015E8   202E FF48              		MOVE.L  TABPTR(A6),D0
015EC   9088                   		SUB.L	A0,D0
015EE   5540                   		SUBQ.W  #2,D0		* ADJUST FOR LENGTH SLOT
015F0   6100 EE0C       003FE  		BSR	PTAWRD  	* AND STORE LENGTH IN LENGTH SLOT
015F4
015F4   4E75                   	DIRX7	RTS
015F6
015F6                          	* REDIRECT INPUT (NORMAL OR COMMAND FILE) ACCORDING TO INT
015F6
015F6                          	* ----------------------
015F6                          	* OPDIRI
015F6                          	* ----------------------
015F6
015F6   4E71                   	OPDIRI  NOP			* TELL CALLER TO USE ARGBLK
015F8                          	*** 0 MEANS KEYBOARD, 1 MEANS SPECIAL FILE -- NOT IMPLEMENTED
015F8   4E75                   		RTS
015FA
015FA                          	* ----------------------
015FA                          	* OPSOUND
015FA                          	* ----------------------
015FA
015FA                          	* MAKE A SOUND
015FA                          	*   ARG1 = ID: 1=BEEP, 2=BOOP, 3+ ARE SPECIAL, 0=MRU
015FA                          	*   [ARG2] = ACTION: 1=INIT, [2=START], 3=STOP, 4=CLEANUP
015FA                          	*   [ARG3] = COUNT (HIBYTE): -1=INFINITE, [0=USE MIDI COUNT], 1-254=FINITE
015FA                          	*	     VOL (LOBYTE): 0=MIN, 8=MAX, [-1=USE MIDI VOLUME]
015FA                          	*   [ARG4] = INTERRUPT FUNCTION
015FA
015FA   4E71                   	OPSOUND	NOP			* REQUEST AN ARGBLK
015FC   43EE FF8C              		LEA	DEFBLK(A6),A1	* USE A DEFAULT ARGBLK, TOO
01600   32BC 0004              		MOVE.W	#4,(A1)		* 4 ARGS MAX
01604   337C 0002 0004         		MOVE.W	#2,ARG2(A1)	* DEFAULT ACTION = "START"
0160A   337C 00FF 0006         		MOVE.W	#$00FF,ARG3(A1)	  * DEFAULT COUNT=0/VOL=-1 (USE MIDI DATA)
01610   4269 0008              		CLR.W	ARG4(A1)	* DEFAULT INTERRUPT HANDLER = NONE
01614   6100 06AC       01CC2  		BSR	SETDEF		* SET UP DEFAULTS
01618
01618   3D68 0008 FF24         		MOVE.W	ARG4(A0),SFUNC(A6)  * SAVE INTERRUPT HERE
0161E   3428 0006              		MOVE.W	ARG3(A0),D2	* COUNT/VOL
01622   3602                   		MOVE.W	D2,D3
01624   4882                   		EXT.W	D2		* VOL (16 BITS)
01626   E04B                   		LSR.W	#8,D3		* COUNT (16 BITS, UNLESS -1)
01628   0C03 00FF              		CMPI.B	#$FF,D3		* -1?
0162C   6602            01630  		BNE.S	OPSDX1
0162E   4883                   		EXT.W	D3		* YES, MAKE 16 BITS
01630
01630   3228 0004              	OPSDX1	MOVE.W	ARG2(A0),D1	* ACTION
01634   3028 0002              		MOVE.W	ARG1(A0),D0	* SOUND ID
01638   6000 0DE0       0241A  		BRA	DOSOUND
0163C

0163C                          	* ----------------------
0163C                          	* OPPICI
0163C                          	* ----------------------
0163C
0163C                          	* GET PICTURE INFO (SIZE)
0163C
0163C   598F                   	OPPICI	SUBQ.L	#4,SP		* TEMP TABLE, 2 WORDS, >> EVEN-ALIGNED <<
0163E G 204F                   		MOVE.L	SP,A0
01640   6100 0D00       02342  		BSR	PICINF		* GET SIZE INFO, STORE IN TABLE
01644
01644   C340                   		EXG	D1,D0		* GIVEN TABLE (MAY BE ODD)
01646   6100 ED4E       00396  		BSR	RELABS
0164A   301F                   		MOVE.W	(SP)+,D0
0164C   6100 EDB0       003FE  		BSR	PTAWRD		* COPY INFO TO GIVEN TABLE
01650   301F                   		MOVE.W	(SP)+,D0
01652   6100 EDAA       003FE  		BSR	PTAWRD
01656
01656   4A41                   		TST.W	D1		* PICINF RESULT
01658   6D04            0165E  		BLT.S	OPICX1		* NEG RESULT MEANS ERROR
0165A   6000 EE96       004F2  		BRA	PTRUE
0165E   6000 EE8E       004EE  	OPICX1	BRA	PFALSE
01662
01662                          	* ----------------------
01662                          	* OPDISP, OPDCLR
01662                          	* ----------------------
01662
01662                          	* DISPLAY [OR CLEAR] A PICTURE
01662
01662   0003                   	OPDISP	DC.W	3		* DEFAULT ARGBLK
01664   0000 FF9D FF9D         		DC.W	SKIP,-99,-99	* NEG POSITION MEANS READ PALETTE STUFF ONLY
0166A
0166A   7600                   		MOVEQ	#0,D3		* "CLEAR" FLAG OFF
0166C   600A            01678  		BRA.S	DISPX1
0166E
0166E   0003                   	OPDCLR	DC.W	3		* DEFAULT ARGBLK
01670   0000 FF9D FF9D         		DC.W	SKIP,-99,-99
01676
01676   7601                   		MOVEQ	#1,D3		* "CLEAR" FLAG ON
01678
01678   3028 0002              	DISPX1	MOVE.W	ARG1(A0),D0
0167C   3228 0004              		MOVE.W	ARG2(A0),D1
01680   3428 0006              		MOVE.W	ARG3(A0),D2
01684   6000 0CD2       02358  		BRA	PICDISP
01688
01688
01688
01688

01688                          	* ----------------------------------------------------------------------------
01688                          	* CONTROL OPERATIONS
01688                          	* ----------------------------------------------------------------------------
01688
01688   0000 000F              	MAXLOCS	EQU	15		* MAXIMUM LOCALS; VARS 16-255 ARE GLOBAL
01688   0000 0100              	CVFLAG	EQU	$0100		* FLAG SET (HIGH BYTE) IF CALL RETURNS A VALUE
01688
01688                          	* ----------------------
01688                          	* OPICALL, ETC
01688                          	* ----------------------
01688
01688                          	* CALL (A FUNCTION WITH OPTIONAL ARGUMENTS), NO RETURNED VALUE
01688
01688   41EE FF96              	OPICAL1	LEA	ARGBLK(A6),A0	* MUST SET UP AN ARGUMENT BLOCK FOR 1-OP
0168C   30BC 0001              		MOVE.W  #1,(A0)		* ONE ARG (THE FUNCTION)
01690   3140 0002              		MOVE.W  D0,ARG1(A0)
01694
01694                          	OPICAL2
01694                          	OPIXCAL
01694   4E71                   	OPICALL	NOP			* TELL CALLER TO USE ARGBLK
01696   7600                   		MOVEQ	#0,D3		* FLAG -- DON'T RETURN A VALUE
01698   6012            016AC  		BRA.S	CALLX1
0169A
0169A                          	* ----------------------
0169A                          	* OPCALL, ETC
0169A                          	* ----------------------
0169A
0169A                          	* CALL (A FUNCTION WITH OPTIONAL ARGUMENTS)
0169A
0169A   41EE FF96              	OPCAL1	LEA	ARGBLK(A6),A0	* MUST SET UP AN ARGUMENT BLOCK FOR 1-OP
0169E   30BC 0001              		MOVE.W  #1,(A0)		* ONE ARG (THE FUNCTION)
016A2   3140 0002              		MOVE.W  D0,ARG1(A0)
016A6
016A6                          	OPCAL2
016A6                          	OPXCAL
016A6   4E71                   	OPCALL	NOP			* TELL CALLER TO USE ARGBLK
016A8   363C 0100              		MOVE.W	#CVFLAG,D3	* FLAG (HIGH BYTE) -- RETURN A VALUE
016AC
016AC                          	*** COMMON ENTRY POINT, A0 -> ARGBLK, D3 (HIGH BYTE) = RETURN-VALUE FLAG
016AC
016AC G 2448                   	CALLX1	MOVE.L  A0,A2
016AE   341A                   		MOVE.W  (A2)+,D2	* ARG COUNT
016B0   301A                   		MOVE.W  (A2)+,D0	* FUNCTION TO CALL -- IS IT ZERO?
016B2   6608            016BC  		BNE.S	CALLX2		* NO
016B4
016B4   4A43                   		TST.W	D3		* SPECIAL CASE -- RETURN A VALUE?
016B6   6776            0172E  		BEQ.S	CALLX9		* NO, JUST EXIT
016B8                          	*	CLR.W	D0		* YES, RETURN A ZERO
016B8   6000 EE26       004E0  		BRA	PUTVAL
016BC
016BC                          	*** BUILD A STACK FRAME, THEN UPDATE THE ZPC AND STATE VARS ...
016BC
016BC   392E FFBC              	CALLX2	MOVE.W  ZPC1(A6),-(A4)  * SAVE OLD ZPC
016C0   392E FFBA              		MOVE.W  ZPC2(A6),-(A4)
016C4   162E FFB9              		MOVE.B	NARGS+1(A6),D3	* SAVE OLD "OPTIONALS" COUNT ...
016C8   3903                   		MOVE.W	D3,-(A4)	*   ALONG WITH /NEW/ RETURN FLAG
016CA
016CA                          	* >>> old locs pointer (rel) now stacked as word, instead of long <<<
016CA                          	* >>> new locs pointer now points to (pseudo) loc 0, instead of 1 <<<
016CA
016CA   222E FFB4              		MOVE.L	ZLOCS(A6),D1	* OLD LOCALS/FRAME POINTER
016CE   92AE FFBE              		SUB.L	STKBOT(A6),D1	* BUT RELATIVIZE IT, IN CASE OF GAME SAVE
016D2   3901                   		MOVE.W	D1,-(A4)	* SAVE IT
016D4   2D4C FFB4              		MOVE.L	A4,ZLOCS(A6)	* NEW LOCALS/FRAME POINTER
016D8
016D8   5342                   		SUBQ.W  #1,D2		* NUMBER OF PARAMETERS ("OPTIONALS")
016DA   1D42 FFB9              		MOVE.B	D2,NARGS+1(A6)	* REMEMBER IT (BYTE)
016DE
016DE   7200                   		MOVEQ	#0,D1		* ZERO HIGH WORD
016E0   3200                   		MOVE.W	D0,D1		* QUAD PTR
016E2   202E FF1E              		MOVE.L	QFOFF(A6),D0	* QUAD FUNCTION OFFSET
016E6   6100 EE6A       00552  		BSR	BSPLTQ2		* SPLIT THE BLOCK AND OFFSET
016EA
016EA   3D40 FFBC              		MOVE.W	D0,ZPC1(A6)	* MAKE IT THE NEW ZPC
016EE   3D41 FFBA              		MOVE.W	D1,ZPC2(A6)

016F2   6100 09B6       020AA  		BSR	NEWZPC		* UPDATE ZPC STUFF
016F6
016F6                          	*** GET FUNCTION HEADER
016F6
016F6   6100 ED50       00448  		BSR	NXTBYT		* TOTAL # DEFINED LOCALS
016FA   3200                   		MOVE.W	D0,D1
016FC   0C41 000F              		CMPI.W	#MAXLOCS,D1	* VALID?
01700   630A            0170C  		BLS.S	CALLX3
01702   41ED 00CE              		LEA	MSGCA1,A0	* TOO MANY LOCALS DEFINED
01706   6100 1040       02748  		BSR	ZWARN		* SHOW A WARNING
0170A   720F                   		MOVEQ	#MAXLOCS,D1	* (CUT BACK -- CAN'T BE TOUCHED ANYWAY)
0170C
0170C   B242                   	CALLX3	CMP.W	D2,D1		* VALID?
0170E   640A            0171A  		BCC.S	CALLX4	* BHS
01710   41ED 00DA              		LEA	MSGCA2,A0	* TOO MANY OPTIONALS SUPPLIED
01714   6100 1032       02748  		BSR	ZWARN		* SHOW A WARNING
01718   3401                   		MOVE.W	D1,D2		* (CUT BACK -- WON'T BE TOUCHED ANYWAY)
0171A
0171A   9242                   	CALLX4	SUB.W	D2,D1		* THIS IS NUMBER OF "DEFAULT" VALUES
0171C   6002            01720  		BRA.S	CALLX6
0171E
000CE                          	    DATA
000CE   426164206C6F63         	MSGCA1	DC.B	'Bad loc num',0
000DA   426164206F7074         	MSGCA2	DC.B	'Bad optional num',0
0171E                          	    CODE
0171E
0171E                          	*** BUILD & INITIALIZE A LOCALS FRAME ...
0171E
0171E   391A                   	CALLX5	MOVE.W  (A2)+,-(A4)	* POSITION THE OPTIONAL VALUES FIRST
01720   51CA FFFC       0171E  	CALLX6	DBF	D2,CALLX5	* ZERO CHECK -- ANY MORE?
01724   7000                   		MOVEQ	#0,D0
01726   6002            0172A  		BRA.S	CALLX8
01728
01728   3900                   	CALLX7	MOVE.W	D0,-(A4)	* CLEAR THE REMAINING DEFAULT VALUES  [XZIP]
0172A   51C9 FFFC       01728  	CALLX8	DBF	D1,CALLX7	* ZERO CHECK -- ANY MORE?
0172E   4E75                   	CALLX9	RTS			* DONE
01730
01730                          	* ----------------------
01730                          	* OPASSN
01730                          	* ----------------------
01730
01730                          	* ASSIGNED? (A LOCAL AN OPTIONAL VALUE)
01730
01730   B02E FFB9              	OPASSN	CMP.B	NARGS+1(A6),D0	* WAS THIS LOCAL ASSIGNED A VALUE?
01734   6E00 EDB8       004EE  		BGT	PFALSE		* NO, VALUE DEFAULTED TO ZERO
01738   6000 EDB8       004F2  		BRA	PTRUE		* YES
0173C
0173C                          	* ----------------------
0173C                          	* OPRETU
0173C                          	* ----------------------
0173C
0173C                          	* RETURN (FROM CURRENT FUNCTION CALL)
0173C
0173C G 286E FFB4              	OPRETU	MOVE.L  ZLOCS(A6),A4	* OLD TOP-OF-STACK
01740   7200                   		MOVEQ	#0,D1
01742   321C                   		MOVE.W  (A4)+,D1	* RESTORE OLD LOCALS POINTER
01744   D2AE FFBE              		ADD.L	STKBOT(A6),D1	* ABSOLUTIZE IT
01748   2D41 FFB4              		MOVE.L  D1,ZLOCS(A6)
0174C
0174C   341C                   		MOVE.W	(A4)+,D2	* RESTORE RETURN FLAG, OPTS COUNT
0174E   1D42 FFB9              		MOVE.B	D2,NARGS+1(A6)
01752   3D5C FFBA              		MOVE.W  (A4)+,ZPC2(A6)  * RESTORE OLD ZPC
01756   3D5C FFBC              		MOVE.W  (A4)+,ZPC1(A6)
0175A                          	    IF EZIP THEN
0175A   6D00 00A0       017FC  		BLT	INRETU		* SPECIAL INTERNAL CALL/RETURN, HANDLE IT
0175E                          	    ENDIF
0175E   3200                   		MOVE.W  D0,D1		* PROTECT VALUE  (IF ANY -- XZIP)
01760   6100 0948       020AA  		BSR	NEWZPC		* UPDATE ZPC STUFF
01764   3001                   		MOVE.W  D1,D0
01766
01766   0242 0100              		ANDI.W	#CVFLAG,D2	* WAS THIS A RETURN-VALUE CALL?  (XZIP)
0176A   6600 ED74       004E0  		BNE	PUTVAL		* YES, RETURN THE VALUE
0176E   4E75                   		RTS			* NO, JUST EXIT
01770
01770                          	* ----------------------

01770                          	* OPRTRU
01770                          	* ----------------------
01770
01770                          	* RTRUE
01770
01770   7001                   	OPRTRU  MOVEQ	#1,D0		* RETURN A "1"
01772   60C8            0173C  		BRA.S	OPRETU
01774
01774                          	* ----------------------
01774                          	* OPRFAL
01774                          	* ----------------------
01774
01774                          	* RFALSE
01774
01774   4240                   	OPRFAL  CLR.W	D0		* RETURN A "0"
01776   60C4            0173C  		BRA.S	OPRETU
01778
01778                          	* ----------------------
01778                          	* OPRSTA
01778                          	* ----------------------
01778
01778                          	* RSTACK (RETURN STACK)
01778
01778   301C                   	OPRSTA  MOVE.W  (A4)+,D0	* POP A VALUE
0177A   60C0            0173C  		BRA	OPRETU		* AND RETURN IT
0177C
0177C                          	* ----------------------
0177C                          	* OPFSTA
0177C                          	* ----------------------
0177C
0177C                          	* FSTACK (FLUSH 'N' ELEMENTS OFF A STACK)   *** REVIVED FOR YZIP
0177C
0177C   4E71                   	OPFSTA	NOP			* REQUEST AN ARGBLK
0177E   3228 0002              		MOVE.W	ARG1(A0),D1	* #ITEMS TO FLUSH
01782   0C50 0001              		CMPI.W	#1,(A0)		* STACK SUPPLIED?
01786   6E06            0178E  		BGT.S	FSTAX2		* YES
01788   D241                   		ADD.W	D1,D1
0178A   D8C1                   		ADDA.W  D1,A4		* NO, ADJUST GAME STACK
0178C   6014            017A2  		BRA.S	FSTAX4
0178E
0178E   3028 0004              	FSTAX2	MOVE.W	ARG2(A0),D0
01792   6100 EC02       00396  		BSR	RELABS		* GET A0 -> LTABLE
01796   6100 EC5E       003F6  		BSR	GTAWRD		* GET D0.W = SPACE REMAINING, ADVANCE A0
0179A   5548                   		SUBQ.W	#2,A0
0179C   D041                   		ADD.W	D1,D0
0179E   6100 EC5E       003FE  		BSR	PTAWRD		* UPDATE LENGTH SLOT
017A2   4E75                   	FSTAX4	RTS
017A4
017A4                          	* ----------------------
017A4                          	* OPJUMP
017A4                          	* ----------------------
017A4
017A4                          	* JUMP (TO A NEW LOCATION)
017A4
017A4   5540                   	OPJUMP  SUBQ.W  #2,D0		* ADJUST OFFSET
017A6   D16E FFBA              		ADD.W	D0,ZPC2(A6)	* ADD OFFSET TO CURRENT ZPC
017AA   6000 08FE       020AA  		BRA	NEWZPC		* NORMALIZE IT & UPDATE ZPC STUFF
017AE
017AE                          	* ----------------------
017AE                          	* OPNOOP
017AE                          	* ----------------------
017AE
017AE                          	* NOOP (NO OPERATION)
017AE
017AE   4E75                   	OPNOOP  RTS			* DO NOTHING
017B0
017B0                          	* ----------------------
017B0                          	* OPCATCH
017B0                          	* ----------------------
017B0
017B0                          	* CATCH
017B0
017B0   202E FFB4              	OPCATCH	MOVE.L	ZLOCS(A6),D0	* THE CURRENT "FRAME POINTER"
017B4   90AE FFBE              		SUB.L	STKBOT(A6),D0	* RELATIVIZE IT
017B8   6000 ED26       004E0  		BRA	PUTVAL

017BC
017BC                          	* ----------------------
017BC                          	* OPTHROW
017BC                          	* ----------------------
017BC
017BC                          	* THROW (NON-LOCAL RETURN)
017BC
017BC   48C1                   	OPTHROW	EXT.L	D1		* A PREVIOUS FRAME PTR
017BE   D2AE FFBE              		ADD.L	STKBOT(A6),D1	* ABSOLUTIZE
017C2   B2AE FFB4              		CMP.L	ZLOCS(A6),D1	* VALID FRAME?
017C6   6D08            017D0  		BLT.S	THRX1		* ERROR
017C8   2D41 FFB4              		MOVE.L	D1,ZLOCS(A6)	* OK, FLUSH ANY INTERMEDIATE FRAMES
017CC   6000 FF6E       0173C  		BRA	OPRETU		* AND RETURN VAL (STILL IN D0)
017D0
017D0   4240                   	THRX1	CLR.W	D0
017D2   41ED 00EB              		LEA	MSGTHR,A0
017D6   6000 0F80       02758  		BRA	FATAL
000EB                          	    DATA
000EB   42616420546872         	MSGTHR	DC.B	'Bad Throw',0
017DA                          	    CODE
017DA
017DA                          	* ----------------------
017DA                          	* INCALL
017DA                          	* ----------------------
017DA
017DA                          	    IF EZIP THEN
017DA
017DA                          	* INTERNALLY CALL A FUNCTION, FUNCTION IN D0, RETURN VALUE IN D0
017DA
017DA   48E7 7F70              	INCALL  MOVEM.L D1-D7/A1-A3,-(SP)	* SAVE EVERYTHING
017DE
017DE   3F2E FFBC              		MOVE.W  ZPC1(A6),-(SP)
017E2   3D7C FFFF FFBC         		MOVE.W  #-1,ZPC1(A6)	* FAKE ZPC1, SIGNALS AN INTERNAL CALL/RETURN
017E8
017E8   41EE FF96              		LEA	ARGBLK(A6),A0	* SET UP ARGBLK FOR OPCALL
017EC   3140 0002              		MOVE.W  D0,ARG1(A0)	* FUNCTION TO CALL
017F0   30BC 0001              		MOVE.W  #1,(A0)		* ONE ARG (FUNCTION ITSELF)
017F4
017F4   6100 FEB0       016A6  		BSR	OPCALL		* CALL THE TIMEOUT FUNCTION
017F8   6000 035A       01B54  		BRA	NXTINS		* GO EXECUTE IT
017FC
017FC                          	* ----------------------
017FC                          	* INRETU
017FC                          	* ----------------------
017FC
017FC                          	* JUMP BACK TO HERE UPON NEXT OPRETURN ...
017FC
017FC   588F                   	INRETU  ADDQ.L  #4,SP		* CAREFUL -- FLUSH TOP RETURN ADDR (NXTINS)
017FE   3D5F FFBC              		MOVE.W  (SP)+,ZPC1(A6)  * FIX THE ZPC
01802
01802   3200                   		MOVE.W  D0,D1
01804   6100 08A4       020AA  		BSR	NEWZPC		* RESTORE THE PROPER PAGE
01808   3001                   		MOVE.W  D1,D0
0180A
0180A   4CDF 0EFE              		MOVEM.L (SP)+,D1-D7/A1-A3
0180E   4E75                   		RTS			* RETURN TO ORIGINAL CALLER
01810                          	    ENDIF
01810

01810                          	* ----------------------------------------------------------------------------
01810                          	* GAME COMMANDS
01810                          	* ----------------------------------------------------------------------------
01810
01810                          	* ------------------------------
01810                          	* PRIMITIVES FOR SAVE/RESTORE
01810                          	* ------------------------------
01810
01810                          	* SAVE STATE VARIABLES ON GAME STACK
01810
01810   392E FFBC              	SAVSTA	MOVE.W  ZPC1(A6),-(A4)
01814   392E FFBA              		MOVE.W  ZPC2(A6),-(A4)
01818
01818 G 206E FFBE              		MOVE.L  STKBOT(A6),A0
0181C   202E FFB4              		MOVE.L  ZLOCS(A6),D0	* RELATIVIZE THIS ONE
01820   9088                   		SUB.L	A0,D0
01822   3900                   		MOVE.W	D0,-(A4)
01824   392E FFFE              		MOVE.W  ZORKID(A6),-(A4)
01828
01828   200C                   		MOVE.L  A4,D0
0182A   9088                   		SUB.L	A0,D0		* RELATIVIZE GAME SP, TOO
0182C   3080                   		MOVE.W	D0,(A0)		* AND SAVE IT IN KNOWN LOCATION
0182E G 504C                   		ADDA.W  #8,A4		* RESET THE GAME SP
01830   4E75                   		RTS
01832
01832                          	* RESTORE STATE VARIABLES FROM GAME STACK, RETURN ZORKID IN D0 AND FLAGS
01832
01832 G 206E FFBE              	RESSTA	MOVE.L  STKBOT(A6),A0
01836   7000                   		MOVEQ	#0,D0
01838   3010                   		MOVE.W  (A0),D0		* RESTORE GAME SP FROM KNOWN LOCATION
0183A   D088                   		ADD.L	A0,D0		* RE-ABSOLUTIZE IT
0183C G 2840                   		MOVE.L	D0,A4
0183E
0183E   3F1C                   		MOVE.W  (A4)+,-(SP)	* GET THE SAVED ZORKID
01840   7000                   		MOVEQ	#0,D0
01842   301C                   		MOVE.W	(A4)+,D0	* RESTORE OLD LOCALS POINTER
01844   D088                   		ADD.L	A0,D0		* RE-ABSOLUTIZE IT
01846   2D40 FFB4              		MOVE.L	D0,ZLOCS(A6)
0184A
0184A   3D5C FFBA              		MOVE.W  (A4)+,ZPC2(A6)	* RESTORE OTHER STUFF
0184E   3D5C FFBC              		MOVE.W  (A4)+,ZPC1(A6)
01852
01852   301F                   		MOVE.W	(SP)+,D0
01854   B06E FFFE              		CMP.W	ZORKID(A6),D0	* IS ID THE SAME AS OURS?
01858   4E75                   		RTS			* (RETURN WITH FLAGS)
0185A
0185A                          	* ----------------------
0185A                          	* OPISAV
0185A                          	* ----------------------
0185A
0185A                          	* ISAVE (SAVE TO MEMORY BUFFER)
0185A
0185A   61B4            01810  	OPISAV	BSR	SAVSTA		* SAVE STATE VARIABLES ON GAME STACK
0185C   242E FEE6              		MOVE.L	MSAVEB(A6),D2	* PTR, ISAVE BUFFER
01860   6700 00EE       01950  		BEQ	SAVERR		* ERROR, BUFFER DOESN'T EXIST
01864 G 206E FFBE              		MOVE.L  STKBOT(A6),A0
01868 G 2242                   		MOVE.L	D2,A1
0186A   203C 0000 0400         		MOVE.L	#STKLEN,D0
01870   6100 1130       029A2  		BSR	MOVMEM		* SAVE THE STACK (FAST BLOCKMOVE)
01874
01874 G 206E FFA8              		MOVE.L  BUFFER(A6),A0	* BEGINNING OF IMPURE STUFF IN CORE
01878 G 2242                   		MOVE.L	D2,A1
0187A   D2FC 0400              		ADDA.W	#STKLEN,A1	* START WRITING AFTER STACK
0187E   302E FFF8              		MOVE.W  PURBOT(A6),D0	* IMPURE BLOCKS
01882   6100 EB2E       003B2  		BSR	BLKBYT
01886   6100 111A       029A2  		BSR	MOVMEM		* SAVE IMPURE DATA (FAST BLOCKMOVE)
0188A   6000 00AC       01938  		BRA	SAVEOK		* SUCCESS
0188E
0188E                          	* ----------------------
0188E                          	* OPSAVE
0188E                          	* ----------------------
0188E
0188E   0000 0020              	PSNLEN	EQU	32		* MAX LENGTH OF SUGGESTED NAME
0188E
0188E                          	* SAVE (STATE OF GAME, OR SELECTED "PARTIAL" DATA)

0188E
0188E   4E71                   	OPSAVE	NOP
01890   4A50                   		TST.W	(A0)		* PARTIAL SAVE (ANY ARGS)?
01892   6700 0056       018EA  		BEQ	SVX2		* NO
01896
01896                          	*** HANDLE A PARTIAL SAVE, A0 -> ARGBLK ***
01896
01896 G 2448                   		MOVE.L	A0,A2
01898   4240                   		CLR.W	D0
0189A   6100 10EC       02988  		BSR	CHKDSK		* CHECK FOR GAME DISK AND CLOSE GAME FILE
0189E
0189E   302A 0006              		MOVE.W	ARG3(A2),D0	* "SUGGESTED" NAME, BYTE 0 = LENGTH
018A2   6100 EAF2       00396  		BSR	RELABS
018A6 G 2248                   		MOVE.L	A0,A1		* SAVE HERE, & PASS TO FSEL
018A8   7001                   		MOVEQ	#1,D0		* OPSAVE
018AA   7201                   		MOVEQ	#1,D1		* PARTIAL
018AC   6100 0F98       02846  		BSR	GETSFL		* GET A NAME FOR THE SAVE FILE
018B0   6600 0094       01946  		BNE	SVX14		* CANCELLED
018B4
018B4   6100 0FD6       0288C  		BSR	NEWSFL		* CREATE (IF NEEDED) AND OPEN THE FILE
018B8   6600 008C       01946  		BNE	SVX14		* ERROR, JUST EXIT (NEED NOT DELETE)
018BC
018BC                          	* WRITE SUGGESTED NAME TO FILE
018BC
018BC   7000                   		MOVEQ	#0,D0
018BE   7220                   		MOVEQ	#PSNLEN,D1	* MAX LENGTH OF SUGGESTED NAME
018C0 G 2049                   		MOVE.L	A1,A0		* STARTS HERE (WITH LENGTH BYTE)
018C2   6100 1038       028FC  		BSR	SFWRIT
018C6   6600 0076       0193E  		BNE	SVX12		* ERROR, CLOSE AND DELETE THE FILE
018CA
018CA                          	* WRITE DATA TO FILE
018CA
018CA   302A 0002              		MOVE.W	ARG1(A2),D0	* BASE OF PARTIAL SAVE
018CE   6100 EAC6       00396  		BSR	RELABS		*   ABSOLUTIZE
018D2   7020                   		MOVEQ	#PSNLEN,D0	* FILE OFFSET
018D4   7200                   		MOVEQ	#0,D1
018D6   322A 0004              		MOVE.W	ARG2(A2),D1	* LENGTH OF PARTIAL SAVE DATA
018DA   6100 1020       028FC  		BSR	SFWRIT
018DE   6600 005E       0193E  		BNE	SVX12		* ERROR, CLOSE AND DELETE THE FILE
018E2
018E2   6100 108C       02970  		BSR	DEFOLD		* OK  >>> BUT RESTORE "NORMAL" FILE NAMES <<<
018E6   6000 0042       0192A  		BRA	SVX10		* AND CLEAN UP
018EA
018EA                          	*** ENTER HERE FOR "STANDARD" SAVE ***
018EA
018EA   4240                   	SVX2	CLR.W	D0
018EC   6100 109A       02988  		BSR	CHKDSK		* CHECK FOR GAME DISK AND CLOSE GAME FILE
018F0
018F0   7001                   		MOVEQ	#1,D0		* OPSAVE
018F2   4241                   		CLR.W	D1		* STANDARD
018F4   6100 0F50       02846  		BSR	GETSFL		* GET A NAME FOR THE SAVE FILE
018F8   6600 004C       01946  		BNE	SVX14		* CANCELLED
018FC
018FC   6100 0F8E       0288C  		BSR	NEWSFL		* CREATE (IF NEEDED) AND OPEN THE FILE
01900   6600 0044       01946  		BNE	SVX14		* ERROR, JUST EXIT (NEED NOT DELETE)
01904
01904                          	* SAVE GAME STACK, THEN IMPURE PRELOAD
01904
01904   6100 FF0A       01810  		BSR	SAVSTA		* SAVE STATE VARIABLES ON GAME STACK
01908 G 206E FFBE              		MOVE.L  STKBOT(A6),A0
0190C   4240                   		CLR.W	D0		* THIS WILL BE BLOCK ZERO
0190E   7202                   		MOVEQ	#STKLEN/512,D1	* BLOCK LENGTH OF STACK
01910   6100 0FDE       028F0  		BSR	PTSBKS		* WRITE IT OUT
01914   6600 0028       0193E  		BNE	SVX12		* ERROR, CLOSE AND DELETE THE FILE
01918
01918 G 206E FFA8              		MOVE.L  BUFFER(A6),A0	* BEGINNING OF IMPURE STUFF IN CORE
0191C   7002                   		MOVEQ	#STKLEN/512,D0	* START WRITING AFTER STACK
0191E   322E FFF8              		MOVE.W  PURBOT(A6),D1	* NUMBER OF IMPURE BLOCKS
01922   6100 0FCC       028F0  		BSR	PTSBKS
01926   6600 0016       0193E  		BNE	SVX12		* ERROR, CLOSE AND DELETE THE FILE
0192A
0192A                          	* SAVE SUCCEEDED
0192A
0192A   6100 101C       02948  	SVX10	BSR	CLSSFL		* SUCCESS, CLOSE THE FILE [NO ERRORS]
0192E   6100 1046       02976  		BSR	DEFNEW		* UPDATE PREVIOUS DEFAULT NAMES

01932   7001                   		MOVEQ	#1,D0
01934   6100 1052       02988  		BSR	CHKDSK		* MAKE SURE GAME DISK IS BACK IN DRIVE
01938
01938   7001                   	SAVEOK	MOVEQ	#1,D0		* RETURN "SAVE OK"
0193A   6000 EBA4       004E0  		BRA	PUTVAL
0193E
0193E                          	* SAVE FAILED FOR SOME REASON ...
0193E
0193E   6100 1008       02948  	SVX12	BSR	CLSSFL		* CLOSE THE BAD FILE
01942   6100 101A       0295E  		BSR	DELSFL		* AND DELETE THE BAD FILE FROM THE DIRECTORY
01946
01946   6100 1028       02970  	SVX14	BSR	DEFOLD		* INSTALL PREVIOUS DEFAULT NAMES
0194A   7001                   		MOVEQ	#1,D0
0194C   6100 103A       02988  		BSR	CHKDSK		* MAKE SURE GAME DISK IS BACK IN DRIVE
01950
01950   4240                   	SAVERR	CLR.W	D0		* RETURN "SAVE FAILED"
01952   6000 EB8C       004E0  		BRA	PUTVAL
01956
01956                          	* ----------------------
01956                          	* OPIRES
01956                          	* ----------------------
01956
01956                          	* IRESTORE (RESTORE FROM MEMORY BUFFER)
01956
01956   242E FEE6              	OPIRES	MOVE.L	MSAVEB(A6),D2	* PTR, ISAVE BUFFER
0195A   6700 0138       01A94  		BEQ	RESERR		* ERROR, BUFFER DOESN'T EXIST
0195E G 2042                   		MOVE.L	D2,A0
01960   4A50                   		TST.W	(A0)
01962   6700 0130       01A94  		BEQ	RESERR		* ERROR, NO PREVIOUS ISAVE!
01966 G 226E FFBE              		MOVE.L  STKBOT(A6),A1
0196A   203C 0000 0400         		MOVE.L	#STKLEN,D0
01970   6100 1030       029A2  		BSR	MOVMEM		* RESTORE THE GAME STACK (FAST BLOCKMOVE)
01974
01974   6100 FEBC       01832  		BSR	RESSTA		* UNSTACK THE OLD STATE INFO
01978   6600 0128       01AA2  		BNE	RESX15		* ERROR, WRONG ZORKID
0197C
0197C G 2042                   		MOVE.L	D2,A0
0197E   D0FC 0400              		ADDA.W	#STKLEN,A0	* START READING AFTER STACK
01982 G 226E FFA8              		MOVE.L  BUFFER(A6),A1	* BEGINNING OF IMPURE STUFF IN CORE
01986   302E FFF8              		MOVE.W  PURBOT(A6),D0	* IMPURE BLOCKS
0198A   6100 EA26       003B2  		BSR	BLKBYT
0198E   6100 1012       029A2  		BSR	MOVMEM		* RESTORE IMPURE DATA (FAST BLOCKMOVE)
01992   6000 00E0       01A74  		BRA	RESTOK		* SUCCESS
01996
01996                          	* ----------------------
01996                          	* OPREST
01996                          	* ----------------------
01996
01996                          	* RESTORE (STATE OF GAME, OR SELECTED "PARTIAL" DATA)
01996
01996   4E71                   	OPREST	NOP
01998   4A50                   		TST.W	(A0)		* PARTIAL RESTORE (ANY ARGS)?
0199A   6700 0076       01A12  		BEQ	RESX2		* NO
0199E
0199E                          	*** HANDLE A PARTIAL RESTORE, A0 -> ARGBLK ***
0199E
0199E G 2448                   		MOVE.L	A0,A2
019A0   4240                   		CLR.W	D0
019A2   6100 0FE4       02988  		BSR	CHKDSK		* CHECK FOR GAME DISK AND CLOSE GAME FILE
019A6
019A6   302A 0006              		MOVE.W	ARG3(A2),D0	* "SUGGESTED" NAME, BYTE 0 = LENGTH
019AA   6100 E9EA       00396  		BSR	RELABS
019AE G 2248                   		MOVE.L	A0,A1		* SAVE HERE, & PASS TO FSEL
019B0   7000                   		MOVEQ	#0,D0		* RESTORE
019B2   7201                   		MOVEQ	#1,D1		* PARTIAL
019B4   6100 0E90       02846  		BSR	GETSFL		* GET A NAME FOR THE SAVE FILE
019B8   6600 00D0       01A8A  		BNE	RESX13		* CANCELLED
019BC
019BC   6100 0EEE       028AC  		BSR	OPNSFL		* OPEN THE FILE
019C0   6600 00C8       01A8A  		BNE	RESX13		* ERROR
019C4
019C4                          	* READ (PREVIOUS) SUGGESTED NAME FROM FILE, & CHECK FOR A MATCH
019C4
019C4   7000                   		MOVEQ	#0,D0
019C6   7220                   		MOVEQ	#PSNLEN,D1	* MAX LENGTH OF SUGGESTED NAME

019C8 G 206E FFBE              		MOVE.L	STKBOT(A6),A0	* (GRAB TEMP BUFFER AT BASE OF ZSTACK)
019CC   6100 0F00       028CE  		BSR	SFREAD
019D0   6600 00B4       01A86  		BNE	RESX12		* ERROR, CLOSE THE FILE  (NOT FATAL)
019D4
019D4 G 2049                   		MOVE.L	A1,A0		* CURRENT NAME STARTS HERE (WITH LENGTH BYTE)
019D6 G 226E FFBE              		MOVE.L	STKBOT(A6),A1
019DA   7001                   		MOVEQ	#1,D0		* COUNT LENGTH BYTE
019DC   D010                   		ADD.B	(A0),D0
019DE   6100 E998       00378  		BSR	COMPS		* COMPARE THE STRINGS
019E2   6600 00A2       01A86  		BNE	RESX12		* DIFFERENT, ERROR, CLOSE THE FILE
019E6
019E6                          	* READ DATA FROM FILE
019E6
019E6   302A 0002              		MOVE.W	ARG1(A2),D0	* BASE OF PARTIAL SAVE
019EA   6100 E9AA       00396  		BSR	RELABS		*   ABSOLUTIZE
019EE   7020                   		MOVEQ	#PSNLEN,D0	* FILE OFFSET
019F0   7200                   		MOVEQ	#0,D1
019F2   322A 0004              		MOVE.W	ARG2(A2),D1	* LENGTH OF PARTIAL SAVE DATA
019F6   6100 0ED6       028CE  		BSR	SFREAD		*   [RETURNS ACTUAL BYTES READ IN D1]
019FA   6600 008A       01A86  		BNE	RESX12		* ERROR, CLOSE THE FILE
019FE
019FE   6100 0F70       02970  		BSR	DEFOLD		* >>> RESTORE "NON-PARTIAL" FILE NAMES <<<
01A02   6100 0F44       02948  		BSR	CLSSFL		* CLOSE THE FILE
01A06   7001                   		MOVEQ	#1,D0
01A08   6100 0F7E       02988  		BSR	CHKDSK		* MAKE SURE GAME DISK IS BACK IN DRIVE
01A0C
01A0C                          	*** [SYSTEM STACK HACKING AND CALL TO NEWZPC NOT NEEDED AFTER PARTIAL OP]
01A0C
01A0C   3001                   		MOVE.W	D1,D0		* RETURN "ACTUAL BYTES READ"
01A0E   6000 EAD0       004E0  		BRA	PUTVAL
01A12
01A12                          	*** ENTER HERE FOR "STANDARD" RESTORE ***
01A12
01A12   4240                   	RESX2	CLR.W	D0
01A14   6100 0F72       02988  		BSR	CHKDSK		* CHECK FOR GAME DISK AND CLOSE GAME FILE
01A18
01A18   4240                   		CLR.W	D0		* RESTORE
01A1A   4241                   		CLR.W	D1		* STANDARD
01A1C   6100 0E28       02846  		BSR	GETSFL		* GET A NAME FOR THE SAVE FILE
01A20   6600 0068       01A8A  		BNE	RESX13		* CANCELLED
01A24
01A24                          	*** ENTER HERE IF DOING SPECIAL RESTORE DURING LAUNCH ***
01A24
01A24   6100 0E86       028AC  	RES1	BSR	OPNSFL		* OPEN THE FILE
01A28   6600 0060       01A8A  		BNE	RESX13		* ERROR
01A2C
01A2C   4240                   		CLR.W	D0		* FIRST READ IN STACK
01A2E   7202                   		MOVEQ	#STKLEN/512,D1	* BLOCK LENGTH OF STACK
01A30 G 206E FFBE              		MOVE.L  STKBOT(A6),A0	* PUT IT HERE
01A34   6100 0E8C       028C2  		BSR	GTSBKS
01A38   6600 0070       01AAA  		BNE	RESX16		* DIE IF DISK ERROR
01A3C
01A3C   6100 FDF4       01832  		BSR	RESSTA		* UNSTACK THE OLD STATE INFO
01A40   6600 0058       01A9A  		BNE	RESX14		* ERROR, WRONG ZORKID
01A44
01A44 G 206E FFA8              		MOVE.L  BUFFER(A6),A0
01A48   3F28 0010              		MOVE.W  PFLAGS(A0),-(SP)   * PRESERVE THE FLAGS (SCRIPT ETC)
01A4C
01A4C   7002                   		MOVEQ	#STKLEN/512,D0	* READ IMPURE STUFF STARTING AFTER STACK
01A4E   322E FFF8              		MOVE.W  PURBOT(A6),D1	* LENGTH OF IMPURE STUFF
01A52   6100 0E6E       028C2  		BSR	GTSBKS
01A56   6600 0052       01AAA  		BNE	RESX16		* DIE IF DISK ERROR
01A5A
01A5A G 206E FFA8              		MOVE.L  BUFFER(A6),A0
01A5E   315F 0010              		MOVE.W  (SP)+,PFLAGS(A0)  * RESTORE THE OLD FLAGS
01A62
01A62                          	* RESTORE SUCCEEDED
01A62
01A62   6100 0EE4       02948  	RESX10	BSR	CLSSFL		* CLOSE THE FILE
01A66   6100 0F0E       02976  		BSR	DEFNEW		* UPDATE PREVIOUS DEFAULT NAMES
01A6A   7001                   		MOVEQ	#1,D0
01A6C   6100 0F1A       02988  		BSR	CHKDSK		* (1) MAKE SURE GAME DISK IS BACK IN DRIVE
01A70
01A70   6100 E882       002F4  		BSR	INITDISP	* UPDATE TTY-SPECIFIC LOWCORE (IF NEEDED)
01A74

01A74                          	* A subtle bug was found in ZIP20 when certain calls that reset the game
01A74                          	* state (the ZPC and stack) occurred during a timer interrupt.  Since control
01A74                          	* never returned to the code that caused the interrupt, the system (machine)
01A74                          	* stack never got cleaned up.  After several such calls it overflowed.
01A74
01A74                          	* The questionable calls include (a successful) Restore or Irestore (Undo),
01A74                          	* and Restart.  The first two are handled here, the last elsewhere.
01A74
01A74 G 2E6E FFC2              	RESTOK	MOVE.L	TOPSP(A6),SP	* MAKE SURE THE SYSTEM STACK IS CLEAN
01A78   487A 00DA       01B54  		PEA	NXTINS		* AND HACK IT SO WE WILL RETURN TO MAIN LOOP
01A7C
01A7C   6100 062C       020AA  		BSR	NEWZPC		* (2) GET THE PROPER ZPC PAGE
01A80   7002                   		MOVEQ	#2,D0		* RETURN "RESTORE OK"
01A82   6000 EA5C       004E0  		BRA	PUTVAL
01A86
01A86                          	* SOMETHING WRONG, FAIL ...
01A86
01A86   6100 0EC0       02948  	RESX12	BSR	CLSSFL		* CLOSE THE FILE
01A8A   6100 0EE4       02970  	RESX13	BSR	DEFOLD		* INSTALL PREVIOUS DEFAULT NAMES
01A8E   7001                   		MOVEQ	#1,D0
01A90   6100 0EF6       02988  		BSR	CHKDSK		* MAKE SURE GAME DISK IS BACK IN DRIVE
01A94
01A94   4240                   	RESERR	CLR.W	D0		* RETURN "RESTORE FAILED"
01A96   6000 EA48       004E0  		BRA	PUTVAL
01A9A
01A9A                          	* FATAL ERROR: BAD ZORKID
01A9A
01A9A   3F00                   	RESX14	MOVE.W	D0,-(SP)
01A9C   6100 0EAA       02948  		BSR	CLSSFL		* CLOSE THE BAD FILE
01AA0   301F                   		MOVE.W	(SP)+,D0	* BAD VERSION ID
01AA2
01AA2   41ED 00F5              	RESX15	LEA	MSGRE2,A0
01AA6   6000 0CB0       02758  		BRA	FATAL		* 'Wrong save file version'
000F5                          	    DATA
000F5   57726F6E672073         	MSGRE2	DC.B	'Wrong save file version',0
01AAA                          	    CODE
01AAA
01AAA                          	* FATAL ERROR: RESTORE READ ERROR
01AAA
01AAA   3F00                   	RESX16	MOVE.W	D0,-(SP)
01AAC   6100 0E9A       02948  		BSR	CLSSFL		* CLOSE THE BAD FILE AND DIE
01AB0   301F                   		MOVE.W	(SP)+,D0	* ERROR CODE
01AB2
01AB2   41ED 010D              		LEA	MSGRE1,A0
01AB6   6000 0CA0       02758  		BRA	FATAL		* 'Save file read error'
0010D                          	    DATA
0010D   53617665206669         	MSGRE1	DC.B	'Save file read error',0
01ABA                          	    CODE
01ABA
01ABA                          	* ----------------------
01ABA                          	* OPRSTT
01ABA                          	* ----------------------
01ABA
01ABA                          	* RESTART (THE GAME)
01ABA
01ABA   6100 04C6       01F82  	OPRSTT	BSR	PUTNEW		* FORCE OUT ANY QUEUED TEXT
01ABE G 206E FF14              		MOVE.L	CURWP(A6),A0
01AC2   4268 001E              		CLR.W	WLCNT(A0)	* RESET COUNTER
01AC6
01AC6   4A6E FEEC              		TST.W	GAMFIL(A6)	* GAME FILE ALREADY OPEN?
01ACA   6606            01AD2  		BNE.S	RSTTX1		* YES
01ACC   7001                   		MOVEQ	#1,D0
01ACE   6100 0EB8       02988  		BSR	CHKDSK1		* NO, OPEN IT NOW (PROMPTING AS NEEDED)
01AD2
01AD2   70FF                   	RSTTX1	MOVEQ	#-1,D0
01AD4   6100 F8EC       013C2  		BSR	OPCLEAR		* CLEAR (AND UNSPLIT) SCREEN
01AD8   6000 E75E       00238  		BRA	RESTRT		* SKIP MOST INITIALIZATIONS
01ADC
01ADC                          	* ----------------------
01ADC                          	* OPQUIT
01ADC                          	* ----------------------
01ADC
01ADC                          	* QUIT
01ADC
01ADC   6000 099C       0247A  	OPQUIT  BRA	FINISH		* DIE PEACEFULLY

01AE0
01AE0                          	* ----------------------
01AE0                          	* OPVERI
01AE0                          	* ----------------------
01AE0
01AE0                          	* VERIFY (GAME FILE)
01AE0
01AE0                          	OPVERI
01AE0                          	    IF CZIP THEN		* VERSION INFO FOR ZIP ONLY
01AE0                          	    ENDIF
01AE0
01AE0   4A6D 0002              		TST.W	SUBVER		* DISPLAY SUB-VERSION ONLY IF NON-ZERO
01AE4   6714            01AFA  		BEQ.S	VERX0
01AE6
01AE6   41ED 0122              		LEA	MSGVR2,A0
01AEA   6100 0C34       02720  		BSR	OUTMSG0		* 'Sub-version '
00122                          	    DATA
00122   5375622D766572         	MSGVR2	DC.B	'Sub-version ',0
01AEE                          	    CODE
01AEE
01AEE   302D 0002              		MOVE.W	SUBVER,D0	* DISPLAY THE SUB-VERSION NUMBER
01AF2   6100 F4A8       00F9C  		BSR	OPPRNN
01AF6   6100 F538       01030  		BSR	OPCRLF
01AFA
01AFA   4A6E FEEC              	VERX0	TST.W	GAMFIL(A6)	* GAME FILE ALREADY OPEN?
01AFE   6606            01B06  		BNE.S	VERX05		* YES
01B00   7001                   		MOVEQ	#1,D0
01B02   6100 0E84       02988  		BSR	CHKDSK1		* NO, OPEN IT NOW (PROMPTING AS NEEDED)
01B06
01B06 G 206E FFA8              	VERX05	MOVE.L  BUFFER(A6),A0
01B0A   3028 001A              		MOVE.W  PLENTH(A0),D0	* GET LENGTH OF GAME FILE
01B0E
01B0E                          	    IF EZIP THEN
01B0E   7200                   		MOVEQ	#0,D1		* ZERO HIGH WORD
01B10   3200                   		MOVE.W	D0,D1		* QUAD PTR
01B12   7000                   		MOVEQ	#0,D0		* [QUAD FUNCTION OFFSET]
01B14   6100 EA3C       00552  		BSR	BSPLTQ2		* SPLIT INTO BLOCK AND OFFSET
01B18                          	    ENDIF
01B18                          	    IF CZIP THEN
01B18                          	    ENDIF
01B18   3800                   		MOVE.W  D0,D4		* THIS IS FINAL BLOCK
01B1A   3A01                   		MOVE.W  D1,D5		* FINAL BYTE
01B1C
01B1C   4240                   		CLR.W	D0		* STARTING BLOCK NUMBER
01B1E   7240                   		MOVEQ	#64,D1		* STARTING BYTE NUMBER
01B20   4243                   		CLR.W	D3		* CHECKSUM HERE
01B22   3F2E FFFA              		MOVE.W  ENDLOD(A6),-(SP)
01B26   426E FFFA              		CLR.W	ENDLOD(A6)	* FORCE LOADING FROM DISK
01B2A
01B2A   6100 E8DE       0040A  	VERX1	BSR	GETBYT		* GET NEXT BYTE
01B2E   D642                   		ADD.W	D2,D3		* ADD IN TO CHECKSUM
01B30   B840                   		CMP.W	D0,D4		* DONE YET?
01B32   66F6            01B2A  		BNE	VERX1		* NO
01B34   BA41                   		CMP.W	D1,D5		* MAYBE
01B36   66F2            01B2A  		BNE	VERX1		* NO
01B38
01B38   3D5F FFFA              		MOVE.W  (SP)+,ENDLOD(A6) * YES, RESTORE PROPER ENDLOD
01B3C
01B3C G 206E FFA8              		MOVE.L  BUFFER(A6),A0
01B40   3028 001C              		MOVE.W  PCHKSM(A0),D0	* GET THE REAL CHECKSUM
01B44   B640                   		CMP.W	D0,D3
01B46   6604            01B4C  		BNE.S	VERX2		* ERROR
01B48
01B48   6000 E9A8       004F2  		BRA	PTRUE		* SUCCESS
01B4C   6000 E9A0       004EE  	VERX2	BRA	PFALSE		* FAILURE
01B50
01B50                          	* ----------------------
01B50                          	* OPORIG
01B50                          	* ----------------------
01B50
01B50                          	* ORIGINAL (NOT A COPY) GAME DISK?
01B50
01B50   6000 E9A0       004F2  	OPORIG	BRA	PTRUE		* <Mac> NO COPY-PROTECTION, SO ALWAYS TRUE
01B54
01B54

01B54                          	* ------------------------------------------------------------------
01B54                          	* ZIP DEBUGGING
01B54                          	* ------------------------------------------------------------------
01B54                          	* NOTE: THIS STUFF SHOULD BE INCLUDED ONLY DURING DEVELOPMENT
01B54
01B54                          	    IF DEBUG THEN
01B54                          	    ENDIF		    * END OF CONDITIONAL ASSEMBLY
01B54
01B54                          	* ---------------------------------------------------------------------------
01B54                          	* MAIN LOOP, DISPATCHING
01B54                          	* ---------------------------------------------------------------------------
01B54
01B54                          	* OPERATORS WHICH ACCEPT A VARIABLE NUMBER OF ARGUMENTS (OPQEQU, OPCALL, ETC)
01B54                          	* ARE IDENTIFIED BY AN INITIAL NOP.  THEIR ARGUMENTS ARE PASSED IN AN ARGUMENT
01B54                          	* BLOCK, WITH THE NUMBER OF ARGUMENTS AS THE FIRST ENTRY.  ALL OTHER OPERATORS
01B54                          	* RECEIVE THEIR ARGUMENTS IN REGISTERS.
01B54
01B54   0000 4E71              	NOOP	EQU	$4E71		* MARKS ROUTINES WHICH TAKE OPTIONAL ARGS
01B54
01B54                          	*** Alternate NXTINS dispatch mechanism.  Would require that all entries in
01B54                          	*** dispatch table (ZIPOPS) be relative to ZIPOPS.
01B54
01B54                          	***	LEA	ZIPOPS,A1
01B54                          	***	MOVE.W  xxxOPS-ZIPOPS(A1,D0.W),D2   * GET THE OPx ROUTINE OFFSET
01B54                          	***	JSR	0(A1,D2.W)		    * CALL THE OPERATOR ROUTINE
01B54                          	***	BRA	NXTINS
01B54
01B54                          	* ----------------------
01B54                          	* NXTINS
01B54                          	* ----------------------
01B54
01B54   6100 08F8       0244E  	NXTINS	BSR	GAMINT		* CHECK FOR GAME INTERRUPT (SOUND, ETC)
01B58   6100 E8EE       00448  		BSR	NXTBYT		* GET THE NEXT INSTRUCTION BYTE
01B5C
01B5C   2E00                   		MOVE.L	D0,D7		* >> QUICK & DIRTY DEBUGGING <<
01B5E                          	    IF DEBUG THEN
01B5E                          	    ENDIF
01B5E   0C00 0080              		CMPI.B  #$80,D0		* IS IT A 2 OP?
01B62   6500 0068       01BCC  		BCS	NXT2	* BLO	* YES
01B66
01B66   0C00 00B0              		CMPI.B  #$B0,D0		* IS IT A 1 OP?
01B6A   6500 003C       01BA8  		BCS	NXT1	* BLO	* YES
01B6E
01B6E   0C00 00C0              		CMPI.B  #$C0,D0		* IS IT A 0 OP?
01B72   6400 00A8       01C1C  		BCC	NXT4	* BHS	* NO, MUST BE AN EXTENDED OP
01B76
01B76                          	*** HANDLE A ZERO-OP
01B76
01B76   0C00 00BE              	NXT0	CMPI.B	#190,D0		* SPECIAL "EXTOP" OPCODE?
01B7A   6718            01B94  		BEQ.S	N0X1		* YES
01B7C
01B7C   0240 000F              		ANDI.W  #$0F,D0		* 0 OP, EXTRACT OPERATOR CODE, "xxxx oooo"
01B80   D040                   		ADD.W	D0,D0		* WORD OFFSET
01B82
01B82   43ED 013E              		LEA	ZEROPS,A1
01B86   3431 0000              		MOVE.W  0(A1,D0.W),D2	* GET THE OPx ROUTINE OFFSET
01B8A   43FA E474       00000  		LEA	ZBASE,A1
01B8E
01B8E   4EB1 2000              		JSR	0(A1,D2.W)	* CALL THE OPERATOR ROUTINE
01B92   60C0            01B54  		BRA	NXTINS
01B94
01B94   6100 E8B2       00448  	N0X1	BSR	NXTBYT		* NEXT BYTE IS SPECIAL "EXTOP"
01B98   4847                   		SWAP	D7		* >> #190 IN HIGH WORD <<
01B9A   3E00                   		MOVE.W	D0,D7		* >> QUICK & DIRTY DEBUGGING <<
01B9C
01B9C   0240 003F              		ANDI.W	#$3F,D0		* EXTRACT OPERATOR CODE, "xxoo oooo"
01BA0   7440                   		MOVEQ	#64,D2		* MAXIMUM 2OPS/XOPS
01BA2   D440                   		ADD.W	D0,D2		* ADJUST OPCODE INTO "EXTOP" RANGE
01BA4   6000 00A6       01C4C  		BRA	NXT4A		* THEN HANDLE AS AN XOP
01BA8
01BA8                          	*** HANDLE A ONE-OP
01BA8
01BA8   3400                   	NXT1	MOVE.W  D0,D2		* 1 OP, MAKE A COPY, "xxmm oooo"
01BAA   0242 000F              		ANDI.W  #$0F,D2		* EXTRACT OPERATOR CODE
01BAE   D442                   		ADD.W	D2,D2		* WORD OFFSET

01BB0
01BB0   E848                   		LSR.W	#4,D0		* EXTRACT MODE BITS
01BB2   0240 0003              		ANDI.W  #3,D0
01BB6   6100 E8BE       00476  		BSR	GETARG		* GET THE ARGUMENT
01BBA
01BBA   43ED 015E              		LEA	ONEOPS,A1
01BBE   3431 2000              		MOVE.W  0(A1,D2.W),D2	* GET THE OPx ROUTINE OFFSET
01BC2   43FA E43C       00000  		LEA	ZBASE,A1
01BC6
01BC6   4EB1 2000              		JSR	0(A1,D2.W)	* CALL THE OPERATOR ROUTINE
01BCA   6088            01B54  		BRA	NXTINS
01BCC
01BCC                          	*** HANDLE A TWO-OP
01BCC
01BCC   3400                   	NXT2	MOVE.W  D0,D2		* 2 OP, MAKE A COPY, "xmmo oooo"
01BCE
01BCE   7001                   		MOVEQ	#1,D0		* ASSUME FIRST ARG IS AN IMMEDIATE
01BD0   0802 0006              		BTST	#6,D2		* IS IT INSTEAD A VARIABLE?
01BD4   6702            01BD8  		BEQ.S	N2X1		* NO
01BD6   7002                   		MOVEQ	#2,D0		* YES, CHANGE MODE
01BD8   6100 E89C       00476  	N2X1	BSR	GETARG		* GET THE FIRST ARG
01BDC   3200                   		MOVE.W  D0,D1
01BDE
01BDE   7001                   		MOVEQ	#1,D0		* ASSUME SECOND ARG IS AN IMMEDIATE
01BE0   0802 0005              		BTST	#5,D2		* IS IT INSTEAD A VAR?
01BE4   6702            01BE8  		BEQ.S	N2X2		* NO
01BE6   7002                   		MOVEQ	#2,D0		* YES, CHANGE MODE
01BE8   6100 E88C       00476  	N2X2	BSR	GETARG		* GET THE SECOND ARG
01BEC   C141                   		EXG	D0,D1		* POSITION THE ARGS
01BEE
01BEE   0242 001F              		ANDI.W  #$1F,D2		* EXTRACT OPERATOR CODE
01BF2   D442                   		ADD.W	D2,D2		* WORD OFFSET
01BF4
01BF4   43ED 017E              		LEA	TWOOPS,A1
01BF8   3431 2000              		MOVE.W  0(A1,D2.W),D2	* GET THE OPx ROUTINE OFFSET
01BFC   43FA E402       00000  		LEA	ZBASE,A1
01C00   43F1 2000              		LEA	0(A1,D2.W),A1	* CALCULATE THE OPx ROUTINE ADDRESS
01C04
01C04   0C51 4E71              		CMPI.W  #NOOP,(A1)	* BUT DOES THE OPERATOR EXPECT AN ARGBLK?
01C08   660C            01C16  		BNE.S	N2X3		* NO
01C0A
01C0A   41EE FF9C              		LEA	ARGBLK+6(A6),A0 * YES, MOVE ARGS TO ARGBLK
01C0E   3101                   		MOVE.W  D1,-(A0)
01C10   3100                   		MOVE.W  D0,-(A0)
01C12   313C 0002              		MOVE.W  #2,-(A0)	* ALWAYS 2 ARGS
01C16
01C16   4E91                   	N2X3	JSR	(A1)		* CALL THE OPERATOR ROUTINE
01C18   6000 FF3A       01B54  		BRA	NXTINS
01C1C
01C1C                          	*** HANDLE AN EXTENDED-OP ...
01C1C
01C1C   3400                   	NXT4	MOVE.W  D0,D2		* EXTENDED OP, SAVE A COPY, "xxoo oooo"
01C1E   0242 003F              		ANDI.W  #$3F,D2		* EXTRACT OPERATOR CODE
01C22
01C22   0C00 00EC              		CMPI.B  #236,D0		* IS THIS AN XCALL ($EC)?
01C26   6706            01C2E  		BEQ.S	N4X1		* YES
01C28   0C00 00FA              		CMPI.B  #250,D0		* IS THIS AN IXCALL ($FA)?
01C2C   661E            01C4C  		BNE.S	NXT4A		* NO
01C2E
01C2E                          	* GET THE 4 (OR 8) MODE SPECIFIERS, EXTRACT AND STACK THEM ...
01C2E
01C2E   7608                   	N4X1	MOVEQ	#8,D3		* SPECIAL XOP, 8 MODE SPECIFIERS
01C30   6100 E816       00448  		BSR	NXTBYT		* GET THE FIRST MODE BYTE, "aabb ccdd"
01C34   3200                   		MOVE.W  D0,D1
01C36   6100 E810       00448  		BSR	NXTBYT		* GET THE SECOND MODE BYTE, "eeff gghh"
01C3A
01C3A   3F00                   		MOVE.W  D0,-(SP)	* SAVE hh
01C3C   E448                   		LSR.W	#2,D0
01C3E   3F00                   		MOVE.W  D0,-(SP)	* SAVE gg
01C40   E448                   		LSR.W	#2,D0
01C42   3F00                   		MOVE.W  D0,-(SP)	* SAVE ff
01C44   E448                   		LSR.W	#2,D0
01C46   3F00                   		MOVE.W  D0,-(SP)	* SAVE ee
01C48
01C48   3001                   		MOVE.W  D1,D0

01C4A   6006            01C52  		BRA.S	N4X2
01C4C
01C4C                          	* ENTRY POINT TO DECODE SPECIAL "EXTOP"
01C4C                          	*   D2 = STRIPPED OPCODE (MAY BE 64+)
01C4C
01C4C   7604                   	NXT4A	MOVEQ	#4,D3		* 4 MODE SPECIFIERS
01C4E   6100 E7F8       00448  		BSR	NXTBYT		* GET THE MODE BYTE, "aabb ccdd"
01C52
01C52   3F00                   	N4X2	MOVE.W  D0,-(SP)	* SAVE dd
01C54   E448                   		LSR.W	#2,D0
01C56   3F00                   		MOVE.W  D0,-(SP)	* SAVE cc
01C58   E448                   		LSR.W	#2,D0
01C5A   3F00                   		MOVE.W  D0,-(SP)	* SAVE bb
01C5C   E448                   		LSR.W	#2,D0
01C5E   3F00                   		MOVE.W  D0,-(SP)	* SAVE aa
01C60
01C60                          	* DECODE ARGUMENTS, STORE IN ARGBLK
01C60
01C60   4244                   		CLR.W	D4		* KEEP A COUNT OF ACTUAL ARGUMENTS
01C62   43EE FF98              		LEA	ARGBLK+2(A6),A1 * ARGUMENT BLOCK, SKIP OVER COUNT SLOT
01C66
01C66   301F                   	N4X3	MOVE.W  (SP)+,D0	* POP NEXT MODE SPECIFIER
01C68   0240 0003              		ANDI.W  #3,D0		* EXTRACT MODE BITS
01C6C   0C40 0003              		CMPI.W  #3,D0		* ARE THERE ANY MORE ARGUMENTS?
01C70   670E            01C80  		BEQ.S	N4X4		* NO
01C72
01C72   5244                   		ADDQ.W  #1,D4		* YES, COUNT THIS ONE
01C74   6100 E800       00476  		BSR	GETARG		* DECODE AND FETCH IT
01C78   32C0                   		MOVE.W  D0,(A1)+	* STORE IT IN ARGUMENT BLOCK
01C7A
01C7A   5343                   		SUBQ.W  #1,D3		* GO FOR MORE
01C7C   66E8            01C66  		BNE	N4X3
01C7E   6006            01C86  		BRA.S	N4X5
01C80
01C80   5343                   	N4X4	SUBQ.W  #1,D3		* NUMBER OF EXTRA MODE SPECIFIERS
01C82   D643                   		ADD.W	D3,D3
01C84   DEC3                   		ADDA.W  D3,SP		* FLUSH THEM
01C86
01C86   41EE FF96              	N4X5	LEA	ARGBLK(A6),A0	* PASS ARGBLK POINTER TO THE OPERATOR HERE ...
01C8A   3084                   		MOVE.W  D4,(A0)		* STORE NUMBER OF ARGUMENTS
01C8C
01C8C                          	* CALCULATE THE OPERATOR ROUTINE ADDRESS
01C8C
01C8C   D442                   		ADD.W	D2,D2		* WORD OFFSET
01C8E   43ED 017E              		LEA	EXTOPS,A1
01C92   3431 2000              		MOVE.W  0(A1,D2.W),D2	* GET THE OPx ROUTINE OFFSET
01C96   43FA E368       00000  		LEA	ZBASE,A1
01C9A   43F1 2000              		LEA	0(A1,D2.W),A1	* CALCULATE THE OPx ROUTINE ADDRESS
01C9E
01C9E   3011                   		MOVE.W  (A1),D0
01CA0   0C40 4E71              		CMPI.W  #NOOP,D0	* ARGBLK EXPECTED?
01CA4   6716            01CBC  		BEQ.S	N4X6		* YES
01CA6                          	* THIS WORKS AS LONG AS NO ROUTINE EVER BEGINS WITH "ORI.B"!
01CA6   0C40 0004              		CMPI.W	#4,D0		* ARGBLK EXPECTED /AND/ DEFAULTS DEFINED?
01CAA   630C            01CB8  		BLS.S	N4X5A		* YES
01CAC
01CAC   5488                   		ADDQ.L  #2,A0		* NO, PASS ARGS IN REGISTERS
01CAE   3018                   		MOVE.W  (A0)+,D0
01CB0   3218                   		MOVE.W  (A0)+,D1
01CB2   3418                   		MOVE.W  (A0)+,D2
01CB4   3618                   		MOVE.W  (A0)+,D3	* MAXIMUM OF FOUR
01CB6   6004            01CBC  		BRA.S	N4X6
01CB8
01CB8   6100 0008       01CC2  	N4X5A	BSR	SETDEF		* GET DEFAULTS; ADVANCE A1
01CBC   4E91                   	N4X6	JSR	(A1)		* CALL THE OPERATOR ROUTINE
01CBE   6000 FE94       01B54  		BRA	NXTINS
01CC2
01CC2                          	* ----------------------
01CC2                          	* SETDEF
01CC2                          	* ----------------------
01CC2
01CC2                          	* SET UP DEFAULT ARGS IN ARGBLK[], USING VALUES FROM DEFBLK[]
01CC2                          	* CALLED BY INDIVIDUAL OPERATORS, SINCE DEFAULT COUNT/VALUES MAY VARY
01CC2                          	* CALLED AT BEGINNING OF OPS, SO NEED NOT SAVE REGISTERS
01CC2                          	* GIVEN A0 -> ARGBLK, A1 -> DEFBLK, (A1) = MAX ARGS,

01CC2                          	* RETURN A0 -> ARGBLK, A1 -> END OF DEFBLK
01CC2
01CC2 G 2448                   	SETDEF	MOVE.L	A0,A2
01CC4   3018                   		MOVE.W	(A0)+,D0	* ACTUAL # ARGS PASSED (REQS PLUS OPTS)
01CC6   3219                   		MOVE.W	(A1)+,D1	* MAX # ARGS POSSIBLE
01CC8 G 2649                   		MOVE.L	A1,A3
01CCA   D241                   		ADD.W	D1,D1
01CCC   D6C1                   		ADDA.W	D1,A3		* SAVE PTR TO END OF DEFBLK
01CCE   D040                   		ADD.W	D0,D0
01CD0   9240                   		SUB.W	D0,D1		* DIFFERENCE IS # DEFAULTS TO SET (x2)
01CD2   6F0A            01CDE  		BLE.S	SDFX4		* NONE
01CD4
01CD4   D0C0                   		ADDA.W	D0,A0		* SKIP OVER ACTUAL ARGS
01CD6   D2C0                   		ADDA.W	D0,A1
01CD8   30D9                   	SDFX2	MOVE.W	(A1)+,(A0)+	* COPY DEFAULT VALS
01CDA   5541                   		SUBQ.W	#2,D1
01CDC   66FA            01CD8  		BNE.S	SDFX2
01CDE
01CDE G 204A                   	SDFX4	MOVE.L	A2,A0		* RETURN ARGBLK PTR INTACT
01CE0 G 224B                   		MOVE.L	A3,A1		* RETURN PTR PAST DEFBLK
01CE2   4E75                   		RTS
01CE4

01CE4                          	* ---------------------------------------------------------------------------
01CE4                          	* DISPATCH TABLES
01CE4                          	* ---------------------------------------------------------------------------
01CE4
01CE4                          	* UNIMPLEMENTED OPCODES DISPATCH TO HERE ...
01CE4
01CE4   4240                   	OPERR	CLR.W	D0
01CE6   41ED 012F              		LEA	MSGBAD,A0
01CEA   6000 0A6C       02758  		BRA	FATAL		* 'Bad operation'
01CEE
0012F                          	    DATA
0012F   426164206F7065         	MSGBAD	DC.B	'Bad operation',0
01CEE                          	    CODE
01CEE
0013D                          	    DATA
0013E   1770                   	ZEROPS  DC.W	OPRTRU-ZBASE	* 176
00140   1774                   		DC.W	OPRFAL-ZBASE	* 177
00142   100E                   		DC.W	OPPRNI-ZBASE	* 178
00144   1026                   		DC.W	OPPRNR-ZBASE	* 179
00146   17AE                   		DC.W	OPNOOP-ZBASE	* 180
00148   1CE4                   		DC.W	OPERR-ZBASE
0014A   1CE4                   		DC.W	OPERR-ZBASE
0014C   1ABA                   		DC.W	OPRSTT-ZBASE	* 183
0014E   1778                   		DC.W	OPRSTA-ZBASE	* 184
00150   17B0                   		DC.W	OPCATCH-ZBASE	* 185 XZIP
00152   1ADC                   		DC.W	OPQUIT-ZBASE	* 186
00154   1030                   		DC.W	OPCRLF-ZBASE	* 187
00156   0F94                   		DC.W	OPUSL-ZBASE	* 188
00158   1AE0                   		DC.W	OPVERI-ZBASE	* 189
0015A   1CE4                   		DC.W	OPERR-ZBASE	* 190 XZIP ("EXTOP")
0015C   1B50                   		DC.W	OPORIG-ZBASE	* 191 XZIP
0015E
0015E   0664                   	ONEOPS  DC.W	OPQZER-ZBASE	* 128
00160   073C                   		DC.W	OPQNEX-ZBASE	* 129
00162   0724                   		DC.W	OPQFIR-ZBASE	* 130
00164   0718                   		DC.W	OPLOC-ZBASE	* 131
00166   08BC                   		DC.W	OPPTSI-ZBASE	* 132
00168   0ABE                   		DC.W	OPINC-ZBASE	* 133
0016A   0ACC                   		DC.W	OPDEC-ZBASE	* 134
0016C   0FF0                   		DC.W	OPPRNB-ZBASE	* 135
0016E   169A                   		DC.W	OPCAL1-ZBASE	* 136 EZIP
00170   06DE                   		DC.W	OPREMO-ZBASE	* 137
00172   0FF8                   		DC.W	OPPRND-ZBASE	* 138
00174   173C                   		DC.W	OPRETU-ZBASE	* 139
00176   17A4                   		DC.W	OPJUMP-ZBASE	* 140
00178   0FE0                   		DC.W	OPPRIN-ZBASE	* 141
0017A   0A54                   		DC.W	OPVALU-ZBASE	* 142
0017C   1688                   		DC.W	OPICAL1-ZBASE	* 143 XZIP
0017E
0017E                          	TWOOPS:
0017E   1CE4                   	EXTOPS:	DC.W	OPERR-ZBASE	* 0 (OR 192+0)
00180   064C                   		DC.W	OPQEQU-ZBASE	* 1
00182   05F6                   		DC.W	OPQLES-ZBASE	* 2
00184   0600                   		DC.W	OPQGRT-ZBASE	* 3
00186   0AFA                   		DC.W	OPQDLE-ZBASE	* 4
00188   0ADA                   		DC.W	OPQIGR-ZBASE	* 5
0018A   0754                   		DC.W	OPQIN-ZBASE	* 6
0018C   060A                   		DC.W	OPBTST-ZBASE	* 7
0018E   0616                   		DC.W	OPBOR-ZBASE	* 8
00190   0622                   		DC.W	OPBAND-ZBASE	* 9
00192   0816                   		DC.W	OPQFSE-ZBASE	* 10
00194   0828                   		DC.W	OPFSET-ZBASE	* 11
00196   0834                   		DC.W	OPFCLE-ZBASE	* 12
00198   0A5C                   		DC.W	OPSET-ZBASE	* 13
0019A   06B6                   		DC.W	OPMOVE-ZBASE	* 14
0019C   0840                   		DC.W	OPGET-ZBASE	* 15
0019E   0852                   		DC.W	OPGETB-ZBASE	* 16
001A0   0764                   		DC.W	OPGETP-ZBASE	* 17
001A2   088A                   		DC.W	OPGTPT-ZBASE	* 18
001A4   07D0                   		DC.W	OPNEXT-ZBASE	* 19
001A6   0562                   		DC.W	OPADD-ZBASE	* 20
001A8   0568                   		DC.W	OPSUB-ZBASE	* 21
001AA   056E                   		DC.W	OPMUL-ZBASE	* 22
001AC   0574                   		DC.W	OPDIV-ZBASE	* 23
001AE   0588                   		DC.W	OPMOD-ZBASE	* 24

001B0   16A6                   		DC.W	OPCAL2-ZBASE	* 25 EZIP
001B2   1694                   		DC.W	OPICAL2-ZBASE	* 26 XZIP
001B4   1494                   		DC.W	OPCOLOR-ZBASE	* 27 XZIP
001B6   17BC                   		DC.W	OPTHROW-ZBASE	* 28 XZIP
001B8   1CE4                   		DC.W	OPERR-ZBASE
001BA   1CE4                   		DC.W	OPERR-ZBASE
001BC   1CE4                   		DC.W	OPERR-ZBASE
001BE
001BE   16A6                   		DC.W	OPCALL-ZBASE	* 224 (192+32)
001C0   0862                   		DC.W	OPPUT-ZBASE	* 225
001C2   0878                   		DC.W	OPPUTB-ZBASE	* 226
001C4   079C                   		DC.W	OPPUTP-ZBASE	* 227
001C6   0B0C                   		DC.W	OPREAD-ZBASE	* 228
001C8   0F98                   		DC.W	OPPRNC-ZBASE	* 229
001CA   0F9C                   		DC.W	OPPRNN-ZBASE	* 230
001CC   059E                   		DC.W	OPRAND-ZBASE	* 231
001CE   0A60                   		DC.W	OPPUSH-ZBASE	* 232
001D0   0A90                   		DC.W	OPPOP-ZBASE	* 233
001D2   110A                   		DC.W	OPSPLT-ZBASE	* 234
001D4   107A                   		DC.W	OPSCRN-ZBASE	* 235
001D6   16A6                   		DC.W	OPXCAL-ZBASE	* 236 EZIP
001D8   13C2                   		DC.W	OPCLEAR-ZBASE	* 237 EZIP
001DA   1430                   		DC.W	OPERASE-ZBASE	* 238 EZIP
001DC   124A                   		DC.W	OPCURS-ZBASE	* 239 EZIP
001DE   12B4                   		DC.W	OPCURG-ZBASE	* 240  XZIP
001E0   1442                   		DC.W	OPHLIGHT-ZBASE	* 241 EZIP [WAS OPATTR]
001E2   151E                   		DC.W	OPBUFO-ZBASE	* 242 EZIP
001E4   154E                   		DC.W	OPDIRO-ZBASE	* 243 EZIP
001E6   15F6                   		DC.W	OPDIRI-ZBASE	* 244 EZIP
001E8   15FA                   		DC.W	OPSOUND-ZBASE	* 245 EZIP
001EA   0C82                   		DC.W	OPINPUT-ZBASE	* 246 EZIP
001EC   08EC                   		DC.W	OPINTBL-ZBASE	* 247 EZIP
001EE   061C                   		DC.W	OPBCOM-ZBASE	* 248  XZIP
001F0   1694                   		DC.W	OPICALL-ZBASE	* 249 XZIP
001F2   1694                   		DC.W	OPIXCAL-ZBASE	* 250 XZIP
001F4   0B86                   		DC.W	OPLEX-ZBASE	* 251 XZIP
001F6   0C3C                   		DC.W	OPZWSTR-ZBASE	* 252 XZIP
001F8   0956                   		DC.W	OPCOPYT-ZBASE	* 253 XZIP
001FA   09EC                   		DC.W	OPPRNT-ZBASE	* 254 XZIP
001FC   1730                   		DC.W	OPASSN-ZBASE	* 255 XZIP
001FE
001FE                          	* "EXTOPS" (XZIP)
001FE
001FE   188E                   		DC.W	OPSAVE-ZBASE	* 256 (192+64)
00200   1996                   		DC.W	OPREST-ZBASE	* 257
00202   0628                   		DC.W	OPSHIFT-ZBASE	* 258 XZIP
00204   063A                   		DC.W	OPASHIFT-ZBASE	* 259 XZIP
00206   1456                   		DC.W	OPFONT-ZBASE	* 260 XZIP
00208   1662                   		DC.W	OPDISP-ZBASE	* 261 XZIP
0020A   163C                   		DC.W	OPPICI-ZBASE	* 262 XZIP
0020C   166E                   		DC.W	OPDCLR-ZBASE	* 263 XZIP
0020E   14D2                   		DC.W	OPMARG-ZBASE	* 264 XZIP
00210   185A                   		DC.W	OPISAV-ZBASE	* 265 XZIP
00212   1956                   		DC.W	OPIRES-ZBASE	* 266 XZIP
00214   1CE4                   		DC.W	OPERR-ZBASE
00216   1CE4                   		DC.W	OPERR-ZBASE
00218   1CE4                   		DC.W	OPERR-ZBASE
0021A   1CE4                   		DC.W	OPERR-ZBASE
0021C   1CE4                   		DC.W	OPERR-ZBASE
0021E   118A                   		DC.W	OPWPOS-ZBASE	* 272 YZIP
00220   11C8                   		DC.W	OPWSIZ-ZBASE	* 273 YZIP
00222   11F2                   		DC.W	OPWATTR-ZBASE	* 274 YZIP
00224   12CE                   		DC.W	OPWGET-ZBASE	* 275 YZIP
00226   1392                   		DC.W	OPSCROLL-ZBASE	* 276 YZIP
00228   177C                   		DC.W	OPFSTA-ZBASE	* 277 YZIP
0022A   0D36                   		DC.W	OPMSINFO-ZBASE	* 278 YZIP
0022C   0D52                   		DC.W	OPMSLMT-ZBASE	* 279 YZIP
0022E   0A64                   		DC.W	OPXPUSH-ZBASE	* 280 YZIP
00230   132C                   		DC.W	OPWPUT-ZBASE	* 281 YZIP
00232   0A52                   		DC.W	OPPRNF-ZBASE	* 282 YZIP
00234   1CE4                   		DC.W	OPERR-ZBASE
00236   1CE4                   		DC.W	OPERR-ZBASE
00238   1CE4                   		DC.W	OPERR-ZBASE
0023A   1CE4                   		DC.W	OPERR-ZBASE
0023C   1CE4                   		DC.W	OPERR-ZBASE

0023E   1CE4                   		DC.W	OPERR-ZBASE
00240
01CEE                          	    CODE
01CEE                          	    INCLUDE	'MX3.a'
01CEE

01CEE                          	* ----------------------------------------------------------------------------
01CEE                          	* STRING FUNCTIONS
01CEE                          	* ----------------------------------------------------------------------------
01CEE
01CEE                          	* ZSTR CHARACTER CONVERSION VECTOR
01CEE
00240                          	    DATA
00240   61626364656667         	ZCHRS	DC.B	'abcdefghijklmnopqrstuvwxyz'	* CHAR SET 1
0025A   41424344454647         		DC.B	'ABCDEFGHIJKLMNOPQRSTUVWXYZ'	* CHAR SET 2
00274   20203031323334         		DC.B	'  0123456789.,!?_#'		* CHAR SET 3
00286
00286   27 22                  		DC.B	$27,$22		* <'>,<">
00288   2F5C2D3A2829           		DC.B	'/\-:()'
0028E   00                     		DC.B	0		* ASCIZ
01CEE                          	    CODE
01CEE
01CEE                          	* ----------------------
01CEE                          	* PUTSTR
01CEE                          	* ----------------------
01CEE
01CEE                          	* OUTPUT A ZSTR, BLOCK-POINTER IN D0, BYTE-POINTER IN D1
01CEE                          	* RETURN UPDATED POINTER
01CEE
01CEE   48E7 3C00              	PUTSTR  MOVEM.L D2-D5,-(SP)
01CF2   4244                   		CLR.W	D4		* TEMP CS STARTS AT 0
01CF4   4245                   		CLR.W	D5		* PERM CS STARTS AT 0
01CF6
01CF6   6100 E744       0043C  	PSX1	BSR	GETWRD		* GET NEXT STRING WORD
01CFA   48A7 E000              		MOVEM.W D0-D2,-(SP)	* SAVE POINTER & COPY OF STRING WORD
01CFE
01CFE   7602                   		MOVEQ	#2,D3		* 3 BYTES IN WORD
01D00   3F02                   	PSX2	MOVE.W  D2,-(SP)	* PUSH CURRENT BYTE
01D02   EA42                   		ASR.W	#5,D2		* SHIFT TO NEXT BYTE
01D04   51CB FFFA       01D00  		DBF	D3,PSX2		* LOOP UNTIL DONE
01D08
01D08   7602                   		MOVEQ	#2,D3		* RETRIEVE THE 3 BYTES ...
01D0A   341F                   	PSX3	MOVE.W  (SP)+,D2	* GET NEXT BYTE
01D0C   0242 001F              		ANDI.W  #$001F,D2	* CLEAR UNWANTED BITS
01D10   4A44                   		TST.W	D4		* IN WORD MODE? (NEGATIVE D4)
01D12   6A1A            01D2E  		BPL.S	PSX4		* NO
01D14
01D14   E342                   		ASL.W	#1,D2		* YES, CALCULATE WORD OFFSET
01D16 G 206E FFE8              		MOVE.L  WRDTAB(A6),A0	* GET WORD TABLE POINTER
01D1A   D46E FF6A              		ADD.W	WRDOFF(A6),D2	* USE PROPER 32 WORD BLOCK
01D1E   D0C2                   		ADDA.W  D2,A0		* INDEX INTO WORD TABLE
01D20   6100 E6D4       003F6  		BSR	GTAWRD		* GET A POINTER TO THE WORD ITSELF
01D24   6100 E820       00546  		BSR	BSPLIT		* SPLIT IT
01D28   61C4            01CEE  		BSR	PUTSTR		* AND PRINT IT
01D2A   6000 0082       01DAE  		BRA	PSX15		* CONTINUE WHERE WE LEFT OFF WITH TEMP CS RESET
01D2E
01D2E   0C44 0003              	PSX4	CMPI.W  #3,D4		* CS 3 (ASCII MODE) SELECTED?
01D32   6D16            01D4A  		BLT.S	PSX6		* NO, NORMAL CS
01D34   6E08            01D3E  		BGT.S	PSX5		* NO, BUT WE'RE ALREADY IN ASCII MODE
01D36   08C4 000E              		BSET	#14,D4		* YES (MAKE D4 LARGE POSITIVE)
01D3A   1802                   		MOVE.B  D2,D4		* SAVE HIGH-ORDER ASCII BITS (2) HERE
01D3C   6072            01DB0  		BRA.S	PSX16		* AND GO GET NEXT BYTE
01D3E   0244 0003              	PSX5	ANDI.W  #$0003,D4	* EXTRACT PREVIOUSLY SAVED HIGH-ORDER BITS
01D42   EB44                   		ASL.W	#5,D4		* POSITION THEM
01D44   8842                   		OR.W	D2,D4		* OR IN LOW-ORDER BITS
01D46   3004                   		MOVE.W  D4,D0
01D48   6060            01DAA  		BRA.S	PSX14		* GO PRINT THE CHARACTER
01D4A
01D4A   0C42 0006              	PSX6	CMPI.W  #6,D2		* SPECIAL CODE (0 TO 5)?
01D4E   6D2A            01D7A  		BLT.S	PSX9		* YES, SPACE, WORD, OR SHIFT
01D50   0C44 0002              		CMPI.W  #2,D4		* MIGHT ALSO BE SPECIAL IF IN CS 2
01D54   6612            01D68  		BNE.S	PSX8		* BUT WE'RE NOT
01D56
01D56   0C42 0007              		CMPI.W  #7,D2		* CS 2, SPECIAL CODE FOR CRLF?
01D5A   6706            01D62  		BEQ.S	PSX7		* YES
01D5C   6E0A            01D68  		BGT.S	PSX8		* NO, NOT ASCII MODE, EITHER?
01D5E   5244                   		ADDQ.W  #1,D4		* YES IT IS, SWITCH TO ASCII MODE (CS 3)
01D60   604E            01DB0  		BRA.S	PSX16		* AND GO GET NEXT BYTE
01D62   6100 021E       01F82  	PSX7	BSR	PUTNEW		* CRLF REQUESTED, DO A NEWLINE
01D66   6046            01DAE  		BRA.S	PSX15
01D68

01D68   3204                   	PSX8	MOVE.W  D4,D1		* NORMAL CHARACTER, GET CS
01D6A   C2FC 001A              		MULU	#26,D1		* CALCULATE OFFSET FOR THIS CS
01D6E   D242                   		ADD.W	D2,D1		* ADD IN CHARACTER OFFSET (+6)
01D70
01D70   41ED 0240              		LEA	ZCHRS,A0
01D74   1030 10FA              		MOVE.B  -6(A0,D1.W),D0  * GET THE CHARACTER FROM CONVERSION VECTOR
01D78   6030            01DAA  		BRA.S	PSX14		* GO PRINT IT
01D7A
01D7A   4A42                   	PSX9	TST.W	D2		* IS IT A SPACE?
01D7C   6604            01D82  		BNE.S	PSX10		* NO
01D7E   7020                   		MOVEQ	#32,D0		* YES, GO PRINT A SPACE
01D80   6028            01DAA  		BRA.S	PSX14
01D82
01D82   0C42 0003              	PSX10	CMPI.W  #3,D2		* IS IT A WORD?
01D86   6E0E            01D96  		BGT.S	PSX11		* NO, MUST BE A SHIFT
01D88   08C4 000F              		BSET	#15,D4		* SWITCH TO WORD MODE (NEG D4) FOR NEXT BYTE
01D8C   5342                   		SUBQ.W  #1,D2		* CALCULATE WORD-TABLE BLOCK OFFSET
01D8E   ED42                   		ASL.W	#6,D2		* 64 BYTES IN A BLOCK
01D90   3D42 FF6A              		MOVE.W  D2,WRDOFF(A6)	* SAVE IT AND LOOP
01D94   601A            01DB0  		BRA.S	PSX16
01D96
01D96   5742                   	PSX11	SUBQ.W  #3,D2		* CALCULATE NEW CS
01D98   4A44                   		TST.W	D4		* TEMPORARY SHIFT (FROM CS 0)?
01D9A   6604            01DA0  		BNE.S	PSX12		* NO
01D9C   3802                   		MOVE.W  D2,D4		* YES, JUST SAVE NEW TEMP CS
01D9E   6010            01DB0  		BRA.S	PSX16
01DA0
01DA0   B842                   	PSX12	CMP.W	D2,D4		* IS THIS THE CURRENT CS?
01DA2   6702            01DA6  		BEQ.S	PSX13		* YES, DO A PERM SHIFT TO IT
01DA4   4244                   		CLR.W	D4		* OTHERWISE, PERM SHIFT TO CS 0
01DA6   3A04                   	PSX13	MOVE.W  D4,D5		* TEMP AND PERM CS'S ARE THE SAME NOW
01DA8   6006            01DB0  		BRA.S	PSX16
01DAA
01DAA   6100 01D8       01F84  	PSX14	BSR	PUTCHR		* OUTPUT THE CHARACTER
01DAE   3805                   	PSX15	MOVE.W  D5,D4		* RESET TEMP CS TO PERM CS
01DB0   51CB FF58       01D0A  	PSX16	DBF	D3,PSX3		* LOOP FOR NEXT BYTE
01DB4
01DB4   4C9F 0007              		MOVEM.W (SP)+,D0-D2	* RESTORE POINTERS & ORIGINAL STRING WORD
01DB8   4A42                   		TST.W	D2		* END-OF-STRING (HIGH BIT SET)?
01DBA   6A00 FF3A       01CF6  		BPL	PSX1		* NO, GO GET NEXT WORD
01DBE   4CDF 003C              		MOVEM.L (SP)+,D2-D5	* YES, CLEAN UP & RETURN UPDATED POINTER
01DC2   4E75                   		RTS
01DC4
01DC4                          	* ----------------------
01DC4                          	* CHRCS
01DC4                          	* ----------------------
01DC4
01DC4                          	* GIVEN AN ASCII CHARACTER IN D0, RETURN THE CHARACTER SET # IN D0
01DC4
01DC4   4A00                   	CHRCS	TST.B	D0		* IS THIS A NULL?
01DC6   6604            01DCC  		BNE.S	CHRCX1		* NO
01DC8   7003                   		MOVEQ	#3,D0		* YES, RETURN DUMMY CS NUMBER
01DCA   6022            01DEE  		BRA.S	CHRCX4
01DCC
01DCC   0C00 0061              	CHRCX1	CMPI.B  #'a',D0		* LOWERCASE CHAR?
01DD0   6D0A            01DDC  		BLT.S	CHRCX2		* NO
01DD2   0C00 007A              		CMPI.B  #'z',D0
01DD6   6E04            01DDC  		BGT.S	CHRCX2		* NO
01DD8   4240                   		CLR.W	D0		* YES, RETURN CS 0
01DDA   6012            01DEE  		BRA.S	CHRCX4
01DDC
01DDC   0C00 0041              	CHRCX2	CMPI.B  #'A',D0		* UPPERCASE CHAR?
01DE0   6D0A            01DEC  		BLT.S	CHRCX3		* NO
01DE2   0C00 005A              		CMPI.B  #'Z',D0
01DE6   6E04            01DEC  		BGT.S	CHRCX3		* NO
01DE8   7001                   		MOVEQ	#1,D0		* YES, RETURN CS 1
01DEA   6002            01DEE  		BRA.S	CHRCX4
01DEC
01DEC   7002                   	CHRCX3	MOVEQ	#2,D0		* OTHERWISE CALL IT CS 2
01DEE   4E75                   	CHRCX4	RTS
01DF0
01DF0                          	* ----------------------
01DF0                          	* CHRBYT
01DF0                          	* ----------------------
01DF0

01DF0                          	* GIVEN AN ASCII CHARACTER IN D0, RETURN ZSTR BYTE VALUE IN D0 (6 TO 31, OR 0)
01DF0
01DF0   41ED 0240              	CHRBYT  LEA	ZCHRS,A0	* POINT TO CONVERSION VECTOR
01DF4
01DF4   B018                   	CHRBX1	CMP.B	(A0)+,D0	* FOUND THE CHARACTER?
01DF6   6708            01E00  		BEQ.S	CHRBX2		* YES
01DF8   4A10                   		TST.B	(A0)		* END OF STRING?
01DFA   66F8            01DF4  		BNE	CHRBX1		* NO, CONTINUE SEARCH
01DFC   4240                   		CLR.W	D0		* YES, RETURN ZERO FOR FAILURE
01DFE   6016            01E16  		BRA.S	CHRBX4
01E00
01E00   2008                   	CHRBX2	MOVE.L  A0,D0		* CALCULATE OFFSET OF CHAR INTO VECTOR
01E02   41ED 0240              		LEA	ZCHRS,A0
01E06   9088                   		SUB.L	A0,D0
01E08   5A40                   		ADDQ.W  #5,D0		* ADJUST OFFSET SO FIRST CHAR IS 6
01E0A
01E0A   0C40 0020              	CHRBX3	CMPI.W  #32,D0		* IN BASE CODE RANGE (6-31)?
01E0E   6D06            01E16  		BLT.S	CHRBX4		* YES
01E10   0440 001A              		SUBI.W  #26,D0		* SUBTRACT MULTIPLES OF 26 UNTIL BASE CODE
01E14   60F4            01E0A  		BRA	CHRBX3
01E16   4E75                   	CHRBX4	RTS
01E18
01E18                          	* ----------------------
01E18                          	* ZWORD
01E18                          	* ----------------------
01E18
01E18                          	* GIVEN UP TO 6 (EZIP 9) ASCIZ CHARACTERS, BUFFER POINTER IN A1,
01E18                          	*   CONVERT THEM TO A TWO (EZIP THREE) WORD ZSTR, BUFFER POINTER IN A0
01E18
01E18   0000 0005              	PADCHR  EQU	5		* ZSTR PADDING CHAR (SHIFT 2)
01E18
01E18   48E7 6020              	ZWORD	MOVEM.L D1-D2/A2,-(SP)
01E1C G 2448                   		MOVE.L  A0,A2
01E1E   343C 0009              		MOVE.W  #VCHARS,D2	* NUMBER OF PACKED CHARS IN A ZSTR (6 OR 9)
01E22
01E22   4241                   	ZWX1	CLR.W	D1
01E24   1219                   		MOVE.B  (A1)+,D1	* GET NEXT CHARACTER, END-OF-STRING?
01E26   6738            01E60  		BEQ.S	ZWX4		* YES
01E28
01E28   3001                   		MOVE.W  D1,D0
01E2A   6198            01DC4  		BSR	CHRCS		* FIND THE CS NUMBER FOR THIS CHAR
01E2C   4A40                   		TST.W	D0		* CS 0?
01E2E   6708            01E38  		BEQ.S	ZWX2		* YES
01E30   5640                   		ADDQ.W  #3,D0		* NO, CALCULATE TEMP SHIFT BYTE
01E32   3F00                   		MOVE.W  D0,-(SP)	* SAVE THE SHIFT BYTE
01E34   5342                   		SUBQ.W  #1,D2		* REDUCE BYTE COUNT, DONE YET?
01E36   6730            01E68  		BEQ.S	ZWX6		* YES
01E38
01E38   3001                   	ZWX2	MOVE.W  D1,D0
01E3A   61B4            01DF0  		BSR	CHRBYT		* FIND THE PROPER BYTE VALUE FOR THIS CHAR
01E3C   4A40                   		TST.W	D0		* IN NORMAL CS'S?
01E3E   6618            01E58  		BNE.S	ZWX3		* YES
01E40
01E40   7006                   		MOVEQ	#6,D0		* NO, USE ASCII SHIFT
01E42   3F00                   		MOVE.W  D0,-(SP)
01E44   5342                   		SUBQ.W  #1,D2		* DONE YET?
01E46   6720            01E68  		BEQ.S	ZWX6		* YES
01E48
01E48   3001                   		MOVE.W  D1,D0		* NO, SAVE HIGH-ORDER ASCII BITS (3)
01E4A   EA40                   		ASR.W	#5,D0
01E4C   3F00                   		MOVE.W  D0,-(SP)
01E4E   5342                   		SUBQ.W  #1,D2		* DONE YET?
01E50   6716            01E68  		BEQ.S	ZWX6		* YES
01E52
01E52   3001                   		MOVE.W  D1,D0		* NO, SAVE LOW-ORDER ASCII BITS (5)
01E54   0240 001F              		ANDI.W  #$001F,D0
01E58   3F00                   	ZWX3	MOVE.W  D0,-(SP)	* SAVE THIS BYTE
01E5A
01E5A   5342                   		SUBQ.W  #1,D2		* AND LOOP UNTIL ZWORD FULL
01E5C   66C4            01E22  		BNE	ZWX1
01E5E   6008            01E68  		BRA.S	ZWX6
01E60
01E60   3F3C 0005              	ZWX4	MOVE.W  #PADCHR,-(SP)	* END OF STRING, SAVE A PAD BYTE
01E64   5342                   		SUBQ.W  #1,D2		* LOOP UNTIL ZSTR FULL
01E66   66F8            01E60  		BNE	ZWX4

01E68
01E68                          	*** BUILD A ZSTR FROM THE SAVED BYTES ...
01E68
01E68   343C 0012              	ZWX6	MOVE.W  #VCHARS*2,D2	* 6 OR 9 CHARS (WORDS) ON STACK
01E6C G 204F                   		MOVE.L  SP,A0		* DON'T DISTURB SP YET (IN CASE OF INTERRUPTS)
01E6E   D0C2                   		ADDA.W  D2,A0
01E70   323C 0003              		MOVE.W	#VCHARS/3,D1	* 2 OR 3 TIMES THROUGH LOOP
01E74
01E74   3020                   	ZWX7	MOVE.W  -(A0),D0
01E76   EB40                   		ASL.W	#5,D0
01E78   8060                   		OR.W	-(A0),D0
01E7A   EB40                   		ASL.W	#5,D0
01E7C   8060                   		OR.W	-(A0),D0
01E7E   34C0                   		MOVE.W  D0,(A2)+	* STORE A PACKED ZWORD IN RETURN BUFFER
01E80
01E80   5341                   		SUBQ.W	#1,D1
01E82   66F0            01E74  		BNE	ZWX7		* GO FOR NEXT
01E84
01E84   08EA 0007 FFFE         		BSET	#7,-2(A2)	* SET HIGH-ORDER BIT IN LAST ZWORD
01E8A   DEC2                   		ADDA.W  D2,SP		* AND FLUSH THE STACK
01E8C
01E8C   4CDF 0406              		MOVEM.L (SP)+,D1-D2/A2
01E90   4E75                   		RTS
01E92
01E92

01E92                          	*--------------------------------------------------------------------------
01E92                          	* GENERALIZED OUTPUT FOLDING ROUTINE
01E92                          	*--------------------------------------------------------------------------
01E92
01E92                          	* ----------------------
01E92                          	* INITQP
01E92                          	* ----------------------
01E92
01E92                          	* ALLOCATE AND INITIALIZE A QUEUE PARAMETER BLOCK,
01E92                          	*   D1 IS MAXIMUM SIZE OF BUFFER (IN BYTES), D2 IS INITIAL UNIT SIZE
01E92                          	*   A1 -> LINE OUTPUT FUNCTION, A2 -> UNIT SIZE FUNCTION
01E92                          	*   RETURN A0 -> PARAMETER BLOCK
01E92
01E92   7020                   	INITQP	MOVEQ	#QPLEN,D0
01E94   48C1                   		EXT.L	D1
01E96   D081                   		ADD.L	D1,D0		* TOTAL SPACE TO ALLOCATE
01E98                          	***	BSR	GETMEM		* GET IT
01E98   6100 052E       023C8  		BSR	GETMEMC		* GET IT & CLEAR IT  (RETURN A0 -> PARAM BLK)
01E9C
01E9C   7020                   		MOVEQ	#QPLEN,D0
01E9E   D088                   		ADD.L	A0,D0		* LINE BUFFER STARTS HERE
01EA0   2080                   		MOVE.L	D0,BUFPTR(A0)
01EA2   2140 0004              		MOVE.L	D0,NXTPTR(A0)	* ALSO CURRENT POINTER
01EA6   D081                   		ADD.L	D1,D0
01EA8   2140 0008              		MOVE.L	D0,ENDPTR(A0)	* (PHYSICALLY) ENDS HERE
01EAC
01EAC   2149 0014              		MOVE.L	A1,OUTFUN(A0)	* INITIALIZE LINE OUTPUT FUNCTION
01EB0   214A 0010              		MOVE.L	A2,SIZFUN(A0)	* INITIALIZE CHAR SIZE FUNCTION
01EB4
01EB4                          	***	CLR.W	CURSIZ(A0)	* ALWAYS EMPTY INITIALLY
01EB4                          	***	CLR.B	DUMPED(A0)	* THIS ONE IS SET ONLY BY PUTLIN
01EB4                          	***	CLR.B	INUSE(A0)	* [RE]-ENTRANCY FLAG
01EB4   3002                   		MOVE.W	D2,D0		* UNIT CAPACITY OF BUFFER ...  [FALL THRU]
01EB6
01EB6                          	* CHANGE THE LINE WRAP POINT, A0 -> PARAMETER BLOCK, DO = NEW LENGTH (UNITS)
01EB6                          	*   RETURN A0 -> PARAMETER BLOCK
01EB6
01EB6                          	SIZEQP
01EB6                          	*** IN THE FUTURE, IF EXTRA ROOM IS NEEDED FOR ITALICS, CALLER SHOULD
01EB6                          	*** (TEMPORARILY) INCREMENT CURSIZ.  MUST LEAVE BUFSIZ AT MAX SO BUFFERING
01EB6                          	*** CAN WORK CORRECTLY IN SCREEN 1, IF USED.  (For example, printing 80
01EB6                          	*** inverse spaces to frame the status line.)
01EB6                          	***	SUBQ.W    #XCHAR,D0		* >>> ALLOW FOR ATARI ITALICS HACK <<<
01EB6
01EB6                          	*** >>> CANCEL THE ABOVE <<<.  FOR MAC, SEVERAL CHARS (r, 4, ^, f) "KERN"
01EB6                          	*** TO RIGHT.  LAST CHAR IN A LINE MUST NEVER KERN OUTSIDE WINDOW.
01EB6                          	*** (WHICH SUGGESTS ANOTHER POSSIBLE FIX: CHECK KERNING FOR EVERY LAST CHAR.)
01EB6   5340                   		SUBQ.W	#1,D0		* SEEMS TO BE 1 PIXEL MAX (GENEVA 9, 12)
01EB8
01EB8   3140 000C              		MOVE.W	D0,BUFSIZ(A0)	* STORE IT
01EBC   4E75                   		RTS
01EBE
01EBE                          	* ----------------------
01EBE                          	* QUECHR
01EBE                          	* ----------------------
01EBE
01EBE                          	* QUEUE THE CHAR IN D0 FOR OUTPUT, A0 -> QUEUE-PARAMETERS BLOCK
01EBE
01EBE   4A28 001F              	QUECHR	TST.B	INUSE(A0)	* ATTEMPT TO RE-ENTER? (E.G. CR INTERRUPT)
01EC2   6600 00BC       01F80  		BNE	QCX10		* YES, NOT SUPPORTED, JUST EXIT
01EC6   117C 0001 001F         		MOVE.B	#1,INUSE(A0)	* "ENTER"
01ECC
01ECC   48E7 0878              		MOVEM.L	D4/A1-A4,-(SP)
01ED0   3800                   		MOVE.W	D0,D4		* MOVE PARAMS TO A4/D4
01ED2 G 2848                   		MOVE.L	A0,A4
01ED4
01ED4 G 206C 0010              		MOVE.L	SIZFUN(A4),A0
01ED8   4E90                   		JSR	(A0)		* GET UNIT SIZE OF NEW CHAR
01EDA   4844                   		SWAP	D4
01EDC   3800                   		MOVE.W	D0,D4		* AND SAVE IN D4-HIGH
01EDE   4844                   		SWAP	D4
01EE0
01EE0                          	* NOTE: FOR PROPORTIONAL FONTS, NEED /TWO/ FULLNESS TESTS HERE:
01EE0                          	*   LOGICALLY FULL (UNITS) - WRAP WORDS, ADD CR
01EE0                          	*   PHYSICALLY FULL (BYTES) - [OUGHT NOT TO ADD CR]

01EE0
01EE0                          	***	MOVE.W	CURSIZ(A4),D0
01EE0   D06C 000E              		ADD.W	CURSIZ(A4),D0	* [TAKING INTO ACCOUNT THE NEW CHAR]
01EE4   B06C 000C              		CMP.W	BUFSIZ(A4),D0	* BUFFER (LOGICALLY) FULL YET?
01EE8                          	***	BGE.S	QCX0
01EE8   6E0C            01EF6  		BGT.S	QCX0		* YES
01EEA G 206C 0004              		MOVE.L	NXTPTR(A4),A0
01EEE G B1EC 0008              		CMP.L	ENDPTR(A4),A0	* BUFFER (PHYSICALLY) FULL YET?  ("iiiii...")
01EF2   6D00 0074       01F68  		BLT	QCX8		* NO
01EF6
01EF6   0C04 0020              	QCX0	CMPI.B  #32,D4		* YES, BUT DID A SPACE CAUSE OVERFLOW?
01EFA   661A            01F16  		BNE.S	QCX1		* NO
01EFC
01EFC   202C 0004              		MOVE.L  NXTPTR(A4),D0	* YES, JUST PRINT THE WHOLE BUFFER
01F00 G 2054                   		MOVE.L	BUFPTR(A4),A0
01F02
01F02 G 266C 0014              		MOVE.L	OUTFUN(A4),A3
01F06   4E93                   		JSR	(A3)
01F08
01F08   426C 000E              		CLR.W	CURSIZ(A4)		* RESET LENGTH COUNTER
01F0C   2954 0004              		MOVE.L  BUFPTR(A4),NXTPTR(A4)	* RESET CURRENT CHAR POINTER
01F10   422C 001C              		CLR.B	DUMPED(A4)		* STARTING A FRESH LINE
01F14   6062            01F78  		BRA.S	QCX9			* EXIT, IGNORING SPACE
01F16
01F16                          	* FOLDING ROUTINE, SEARCH FOR MOST-RECENT SPACE ...
01F16
01F16 G 2254                   	QCX1	MOVE.L  BUFPTR(A4),A1	* BEGINNING OF BUFFER
01F18 G 246C 0004              		MOVE.L  NXTPTR(A4),A2	* END OF BUFFER (+1)
01F1C   6006            01F24  		BRA.S	QCX2A		* ALLOW FOR EMPTY [DUMPED] BUFFER
01F1E
01F1E   0C22 0020              	QCX2	CMPI.B  #32,-(A2)	* SEARCH FOR SPACE BACKWARDS FROM END
01F22   6710            01F34  		BEQ.S	QCX4		* FOUND ONE
01F24   B5C9                   	QCX2A	CMPA.L  A1,A2		* REACHED BEGINNING OF BUFFER?
01F26   6EF6            01F1E  		BGT	QCX2		* NOT YET
01F28
01F28                          	* NO SPACES FOUND, DUMP WHOLE BUFFER ...
01F28
01F28   4A2C 001C              	QCX3	TST.B	DUMPED(A4)	* BUT WAS THIS BUFFER ALREADY PARTLY EMPTIED?
01F2C   660E            01F3C  		BNE.S	QCX5		* YES, CARRY EVERYTHING OVER TO NEXT LINE
01F2E
01F2E G 246C 0004              		MOVE.L	NXTPTR(A4),A2	* OTHERWISE, OUTPUT EVERYTHING
01F32   6008            01F3C  		BRA.S	QCX5
01F34
01F34                          	* SPACE WAS FOUND, DUMP THE BUFFER (THROUGH SPACE) ...
01F34
01F34 G 204A                   	QCX4	MOVE.L	A2,A0		* POINTER TO THE SPACE
01F36   528A                   		ADDQ.L	#1,A2		* POINTER PAST THE SPACE
01F38
01F38   B1C9                   		CMPA.L  A1,A0		* DEGENERATE CASE WITH SPACE AT BUFPTR?
01F3A   67EC            01F28  		BEQ	QCX3		* YES, OUTPUT WHOLE LINE
01F3C
01F3C   200A                   	QCX5	MOVE.L  A2,D0		* LAST CHAR TO PRINT (+1)
01F3E G 2049                   		MOVE.L	A1,A0		* START OF BUFFER
01F40
01F40 G 266C 0014              		MOVE.L	OUTFUN(A4),A3	* GO DUMP IT, ADDING A CR
01F44   4E93                   		JSR	(A3)
01F46
01F46                          	* SHIFT ANY REMAINING CHARS TO FRONT OF BUFFER ...
01F46
01F46   426C 000E              		CLR.W	CURSIZ(A4)	* ZERO THE UNIT COUNT
01F4A   422C 001C              		CLR.B	DUMPED(A4)	* START WITH A FRESH BUFFER
01F4E   600E            01F5E  		BRA.S	QCX7
01F50
01F50   101A                   	QCX6	MOVE.B  (A2)+,D0
01F52   12C0                   		MOVE.B	D0,(A1)+	* COPY NEXT CHAR TO BEGINNING OF BUF
01F54
01F54 G 206C 0010              		MOVE.L	SIZFUN(A4),A0	* CHAR STILL IN D0
01F58   4E90                   		JSR	(A0)
01F5A   D16C 000E              		ADD.W	D0,CURSIZ(A4)	* UPDATE THE UNIT COUNT
01F5E
01F5E   B5EC 0004              	QCX7	CMPA.L  NXTPTR(A4),A2	* ANY MORE CHARS AFTER SPACE?
01F62   6DEC            01F50  		BLT	QCX6		* YES
01F64   2949 0004              		MOVE.L  A1,NXTPTR(A4)	* NO, STORE NEW CURRENT POINTER HERE
01F68
01F68                          	* FINALLY, STORE THE NEW CHAR AND EXIT ...

01F68
01F68 G 206C 0004              	QCX8	MOVE.L	NXTPTR(A4),A0
01F6C   10C4                   		MOVE.B  D4,(A0)+	* STORE THE NEW CHARACTER IN BUFFER
01F6E   2948 0004              		MOVE.L  A0,NXTPTR(A4)	* AND UPDATE POINTER
01F72
01F72   4844                   		SWAP	D4		* (UNIT SIZE SAVED IN D4-HIGH)
01F74   D96C 000E              		ADD.W	D4,CURSIZ(A4)	* UPDATE COUNTER
01F78
01F78   422C 001F              	QCX9	CLR.B	INUSE(A4)	* "EXIT"
01F7C   4CDF 1E10              		MOVEM.L (SP)+,D4/A1-A4
01F80   4E75                   	QCX10	RTS
01F82
01F82                          	*--------------------------------------------------------------------------
01F82                          	* MAIN OUTPUT HANDLER
01F82                          	*--------------------------------------------------------------------------
01F82
01F82                          	* !ALL! OUTPUT GENERATED BY THE GAME (AND THE USER) SHOULD BE CHANNELED
01F82                          	*   THROUGH THE FOLLOWING TWO ROUTINES, WHICH REDIRECT IT APPROPRIATELY.
01F82
01F82                          	* ----------------------
01F82                          	* PUTNEW
01F82                          	* ----------------------
01F82
01F82                          	* OUTPUT A NEWLINE
01F82
01F82   700D                   	PUTNEW	MOVEQ	#13,D0		* JUST FALL THROUGH WITH A CR
01F84
01F84                          	* ----------------------
01F84                          	* PUTCHR
01F84                          	* ----------------------
01F84
01F84                          	* OUTPUT THE CHAR IN D0 (TO THE REQUESTED DEVICES)
01F84
01F84   0C00 0009              	PUTCHR	CMPI.B	#9,D0		* TAB? (OLD ZORK BUG, DISPLAYS GARBAGE)
01F88   6602            01F8C  		BNE.S	PCX1
01F8A   7020                   		MOVEQ	#32,D0		* YES, MAP TO A SPACE
01F8C   4E71                   	PCX1	NOP			* <ST ASSEMBLER>
01F8E
01F8E                          	*** STATUS LINE OUTPUT (ZIP INTERNAL FUNCTION ONLY) ...
01F8E
01F8E                          	    IF CZIP THEN
01F8E                          	    ENDIF
01F8E
01F8E                          	*** TABLE OUTPUT ...
01F8E
01F8E                          	    IF EZIP THEN
01F8E   4A6E FF62              		TST.W	VOTABL(A6)	* TABLE OUTPUT?
01F92   6600 F5AE       01542  		BNE	TABCHR		* YES (ABORT PUTCHR PER "DIROUT" SPEC)
01F96                          	    ENDIF
01F96
01F96   3F00                   		MOVE.W	D0,-(SP)	* OTHERWISE, SAVE THE CHAR HERE
01F98
01F98                          	*** SCRIPT (BEFORE SCREEN, SO "OPEN" ERROR DISPLAYS IN CORRECT SEQUENCE)
01F98
01F98                          	    IF EZIP THEN
01F98   4A6E FF66              		TST.W	VOPRNT(A6)	* [GLOBAL] SCRIPTING ACTIVE?
01F9C                          	    ENDIF
01F9C                          	    IF CZIP THEN
01F9C                          	    ENDIF
01F9C   6706            01FA4  		BEQ.S	PCX2		* NO
01F9E
01F9E                          	***	MOVEQ	#WFSCRP,D0	* [CHECKED IN SCRCHR -- MOVE HERE INSTEAD?]
01F9E                          	***	BSR	TSTWFLG		* SCRIPTING ACTIVE IN /CURRENT/ WINDOW?
01F9E                          	***	BEQ.S	PCX2		* NO
01F9E
01F9E   3017                   		MOVE.W	(SP),D0		* SCRIPT THIS CHAR
01FA0   6100 0086       02028  		BSR	SCRCHR
01FA4
01FA4                          	*** SCREEN DISPLAY ...
01FA4
01FA4   4A6E FF68              	PCX2	TST.W	VOCONS(A6)	* CONSOLE OUTPUT ACTIVE?
01FA8   6706            01FB0  		BEQ.S	PCX3		* NO
01FAA
01FAA   3017                   		MOVE.W	(SP),D0		* YES, DISPLAY THE CHAR
01FAC   6100 0008       01FB6  		BSR	QDCHR

01FB0
01FB0                          	*** FILE OUTPUT ...
01FB0
01FB0   4E71                   	PCX3	NOP			* NOT IMPLEMENTED
01FB2
01FB2   4A5F                   		TST.W	(SP)+		* FLUSH CHAR FROM STACK
01FB4   4E75                   		RTS
01FB6
01FB6                          	*--------------------------------------------------------------------------
01FB6                          	* TERMINAL DISPLAY FUNCTIONS
01FB6                          	*--------------------------------------------------------------------------
01FB6
01FB6                          	* ----------------------
01FB6                          	* QDCHR
01FB6                          	* ----------------------
01FB6
01FB6                          	* QUEUE/DISPLAY THE CHAR IN D0
01FB6
01FB6   4A6E FF5A              	QDCHR	TST.W	VOBUFF(A6)	* IS BUFFERING TURNED OFF?
01FBA   6700 0622       025DE  		BEQ	OUTCHR		* YES, GO TO SCREEN (THIS HANDLES CR'S ALSO)
01FBE
01FBE   0C00 000D              		CMPI.B	#13,D0		* CR?
01FC2   6700 000A       01FCE  		BEQ	NEWLIN		* YES, DUMP THE BUFFER
01FC6
01FC6 G 206E FF54              		MOVE.L	DQUE(A6),A0	* OTHERWISE, GO QUEUE IT
01FCA   6000 FEF2       01EBE  		BRA	QUECHR
01FCE
01FCE                          	* ----------------------
01FCE                          	* NEWLIN
01FCE                          	* ----------------------
01FCE
01FCE                          	* GO TO NEW LINE, OUTPUTTING CURRENT BUFFER
01FCE                          	*   (THIS ROUTINE NOW CALLED ONLY FROM THE PRECEEDING ROUTINE)
01FCE
01FCE   2F0C                   	NEWLIN	MOVE.L	A4,-(SP)
01FD0 G 286E FF54              		MOVE.L	DQUE(A6),A4	* SCREEN BUFFER
01FD4
01FD4 G 2054                   		MOVE.L	BUFPTR(A4),A0	* START OF LINE
01FD6   202C 0004              		MOVE.L  NXTPTR(A4),D0	* END OF CURRENT LINE
01FDA   6100 0724       02700  		BSR	LINOUT		* CHECK "MORE", OUTPUT LINE, ADD A CR
01FDE
01FDE   2954 0004              		MOVE.L  BUFPTR(A4),NXTPTR(A4)	* RESET CHARACTER POINTER
01FE2   426C 000E              		CLR.W	CURSIZ(A4)		* RESET UNIT COUNT
01FE6   422C 001C              		CLR.B	DUMPED(A4)		* NO OUTPUT ON NEW LINE YET
01FEA
01FEA G 285F                   		MOVE.L	(SP)+,A4
01FEC   4E75                   		RTS
01FEE
01FEE                          	* ----------------------
01FEE                          	* PUTLIN
01FEE                          	* ----------------------
01FEE
01FEE                          	* OUTPUT CURRENT BUFFER, WITHOUT A NEWLINE
01FEE                          	*   (ASSUMES SOMETHING LIKE OPREAD WILL SUPPLY THE NEWLINE)
01FEE
01FEE G 206E FF54              	PUTLIN1  MOVE.L	DQUE(A6),A0
01FF2   4268 000E              		CLR.W	CURSIZ(A0)	* RESET UNIT COUNT (BUFFER EMPTY)
01FF6
01FF6                          	* ENTER HERE IF BUFFERING WILL LATER RESUME FROM CURRENT POINT
01FF6
01FF6   2F0C                   	PUTLIN	MOVE.L	A4,-(SP)
01FF8 G 286E FF54              		MOVE.L	DQUE(A6),A4	* SCREEN BUFFER
01FFC
01FFC                          	* CHECK FOR RE-ENTRANCY [E.G. DURING A CR INTERRUPT]
01FFC                          	* GENERALLY, THE BUFFER IS ALREADY EMPTY, AND NOTHING SHOULD HAPPEN ANYWAY
01FFC   4A2C 001F              		TST.B	INUSE(A4)	* ATTEMPT TO RE-ENTER?
02000   6622            02024  		BNE.S	PTLNX2		* YES, NOT SUPPORTED, JUST EXIT
02002
02002 G 2054                   		MOVE.L	BUFPTR(A4),A0	* START OF LINE
02004   202C 0004              		MOVE.L  NXTPTR(A4),D0	* END OF CURRENT LINE
02008   B088                   		CMP.L	A0,D0
0200A   6712            0201E  		BEQ.S	PTLNX1		* SKIP IF EMPTY
0200C
0200C   197C 0001 001F         		MOVE.B	#1,INUSE(A4)	* "ENTER"
02012   6100 06D0       026E4  		BSR	BUFOUT		* OUTPUT IT (NO CR, BUT DOES CHECK [MORE])

02016   2954 0004              		MOVE.L  BUFPTR(A4),NXTPTR(A4)	* RESET CHARACTER POINTER
0201A   422C 001F              		CLR.B	INUSE(A4)	* "EXIT"
0201E
0201E   197C 0001 001C         	PTLNX1	MOVE.B	#1,DUMPED(A4)	* REMEMBER BUFFER IS PARTLY DUMPED
02024 G 285F                   	PTLNX2	MOVE.L	(SP)+,A4
02026   4E75                   		RTS
02028
02028                          	*--------------------------------------------------------------------------
02028                          	* SCRIPT BUFFERING
02028                          	*--------------------------------------------------------------------------
02028
02028                          	* ----------------------
02028                          	* SCRCHR
02028                          	* ----------------------
02028
02028                          	* /ALL/ SCRIPT OUTPUT IS CHANNELED THROUGH HERE
02028
02028                          	* QUEUE THE CHAR IN D0 FOR SCRIPTING
02028
02028   48A7 8000              	SCRCHR	MOVEM.W	D0,-(SP)
0202C   7004                   		MOVEQ	#WFSCRP,D0
0202E   6100 F040       01070  		BSR	TSTWFLG		* SCRIPTING ACTIVE IN /CURRENT/ WINDOW?
02032   4C9F 0001              		MOVEM.W	(SP)+,D0	* [RESTORE CHAR, BUT DON'T DISTURB FLAGS]
02036   6602            0203A  		BNE.S	SCRCX1		* YES
02038   4E75                   		RTS			* NO, EXIT
0203A
0203A   0C00 000D              	SCRCX1	CMPI.B	#13,D0		* CR?
0203E   6708            02048  		BEQ.S	SCRLIN		* YES, DUMP SCRIPT BUFFER
02040
02040 G 206E FF50              		MOVE.L	SQUE(A6),A0	* SCRIPTING PARAMETERS BLOCK
02044   6000 FE78       01EBE  		BRA	QUECHR		* GO QUEUE CHAR
02048
02048                          	* GOT A NEWLINE -- SCRIPT THE CURRENT BUFFER
02048
02048   2F0C                   	SCRLIN	MOVE.L	A4,-(SP)
0204A G 286E FF50              		MOVE.L	SQUE(A6),A4	* SCRIPTING PARAMETERS BLOCK
0204E
0204E G 2054                   		MOVE.L	BUFPTR(A4),A0	* START OF LINE
02050   202C 0004              		MOVE.L  NXTPTR(A4),D0	* END OF CURRENT LINE
02054   6100 0742       02798  		BSR	SCROUT		* OUTPUT LINE, ADD A CR ...
02058
02058   2954 0004              		MOVE.L  BUFPTR(A4),NXTPTR(A4)	* RESET CHARACTER POINTER
0205C   426C 000E              		CLR.W	CURSIZ(A4)		* RESET UNIT COUNT
02060
02060 G 285F                   		MOVE.L	(SP)+,A4
02062   4E75                   		RTS
02064
02064                          	* ----------------------
02064                          	* SCRINP
02064                          	* ----------------------
02064
02064                          	* OUTPUT A USER INPUT LINE TO THE TRANSCRIPT (IF SCRIPTING)
02064                          	*   START IN A0, LENGTH IN D0, FLAG IN D1 (NONZERO) FOR CR
02064
02064   48E7 2020              	SCRINP  MOVEM.L	A2/D2,-(SP)
02068 G 2448                   		MOVE.L	A0,A2		* PROTECT ARGS
0206A   3400                   		MOVE.W	D0,D2
0206C
0206C                          	    IF EZIP THEN
0206C   4A6E FF66              		TST.W	VOPRNT(A6)	* SCRIPTING?
02070                          	    ENDIF
02070                          	    IF CZIP THEN
02070                          	    ENDIF
02070   6714            02086  		BEQ.S	SCRIX3		* NO, EXIT
02072
02072   4A42                   		TST.W	D2		* LENGTH OF INPUT
02074   6708            0207E  		BEQ.S	SCRIX2		* ZERO, JUST DO THE CR
02076
02076   101A                   	SCRIX1	MOVE.B  (A2)+,D0	* SCRIPT NEXT CHAR
02078   61AE            02028  		BSR	SCRCHR		*   (USE BUFFERING, SO WRAP IS CORRECT)
0207A   5342                   		SUBQ.W	#1,D2
0207C   66F8            02076  		BNE.S	SCRIX1
0207E
0207E   4A41                   	SCRIX2	TST.W	D1		* CR REQUESTED?
02080   6704            02086  		BEQ.S	SCRIX3		* NO

02082   700D                   		MOVEQ	#13,D0		* YES, ADD THE CR
02084   61A2            02028  		BSR	SCRCHR
02086
02086   4CDF 0404              	SCRIX3	MOVEM.L (SP)+,D2/A2
0208A   4E75                   		RTS
0208C
0208C                          	* ----------------------
0208C                          	* SCRNAM
0208C                          	* ----------------------
0208C
0208C                          	* ECHO THE SAVE/RESTORE FILENAME TO THE TRANSCRIPT (IF SCRIPTING)
0208C                          	*   (USER SELECTED IT THRU A SPECIAL DIALOG)
0208C
0208C   2F01                   	SCRNAM	MOVE.L	D1,-(SP)
0208E
0208E   41ED 028F              		LEA	MSGSCN,A0	* 'File: '
02092   6100 E2F2       00386  		BSR	STRLEN		* LEAVE LENGTH OF STRING IN D0
02096   4241                   		CLR.W	D1		* NO CR YET
02098   61CA            02064  		BSR	SCRINP
0028F                          	    DATA
0028F   46696C653A20 0         	MSGSCN	DC.B	'File: ',0	* (PHRASE OKAY FOR SAVE & RESTORE)
0209A                          	    CODE
0209A
0209A   41ED 0000              		LEA	filename,A0	* SIMPLE NAME (NO DISK/PATH SPEC)
0209E   7000                   		MOVEQ	#0,D0
020A0   1018                   		MOVE.B	(A0)+,D0	* LENGTH  [MAC PASCAL FORMAT]
020A2   7201                   		MOVEQ	#1,D1		* END WITH CR
020A4   61BE            02064  		BSR	SCRINP
020A6
020A6   221F                   		MOVE.L	(SP)+,D1
020A8   4E75                   		RTS
020AA

020AA                          	* ----------------------------------------------------------------------------
020AA                          	* PAGING ROUTINES
020AA                          	* ----------------------------------------------------------------------------
020AA
020AA                          	* ----------------------
020AA                          	* NEWZPC
020AA                          	* ----------------------
020AA
020AA                          	* NORMALIZE ZPC & (IF NECESSARY) GET PROPER PAGE
020AA
020AA   302E FFBA              	NEWZPC  MOVE.W	ZPC2(A6),D0	* LOW ORDER ZPC
020AE   E040                   		ASR.W	#8,D0		* EXTRACT REQUIRED BLOCK ADJUSTMENT (+ OR -)
020B0   E240                   		ASR.W	#1,D0
020B2
020B2   D16E FFBC              		ADD.W	D0,ZPC1(A6)	* AND ADJUST HIGH ORDER ZPC
020B6   026E 01FF FFBA         		ANDI.W	#$01FF,ZPC2(A6)	* NORMALIZE LOW ORDER ZPC
020BC
020BC                          	* GET THE INDICATED PAGE
020BC
020BC   302E FFBC              		MOVE.W	ZPC1(A6),D0
020C0   B06E FF42              		CMP.W	CURBLK(A6),D0	* HAS THE BLOCK CHANGED?
020C4   6744            0210A  		BEQ.S	NZX4		* NO, EXIT
020C6   3D40 FF42              		MOVE.W  D0,CURBLK(A6)	* YES, REMEMBER NEW BLOCK
020CA
020CA   4AAE FF3E              		TST.L	CURTAB(A6)	* IS OLD PAGE PRELOADED?
020CE   670A            020DA  		BEQ.S	NZX2		* YES
020D0 G 206E FF3E              		MOVE.L  CURTAB(A6),A0	* NO, RESTORE CURRENT REF TIME FOR OLD PAGE
020D4   216E FF3A 0002         		MOVE.L  RTIME(A6),2(A0)
020DA
020DA   B06E FFFA              	NZX2	CMP.W	ENDLOD(A6),D0	* IS NEW PAGE PRELOADED?
020DE   6D1A            020FA  		BLT.S	NZX3		* YES
020E0   6100 002A       0210C  		BSR	GETPAG		* NO, GET THE NEW PAGE
020E4   2D48 FF44              		MOVE.L  A0,CURPAG(A6)	* REMEMBER NEW PAGE POINTER
020E8
020E8 G 206E FF30              		MOVE.L  LPTAB(A6),A0	* GET NEW TABLE POINTER
020EC   2D48 FF3E              		MOVE.L  A0,CURTAB(A6)	* SAVE THIS POINTER FOR LATER
020F0   217C FFFF FFFF         		MOVE.L  #-1,2(A0)	* FAKE A HIGH RTIME TO PROTECT ZPC PAGE FOR US
             0002 
020F8   6010            0210A  		BRA.S	NZX4
020FA
020FA   6100 E2B6       003B2  	NZX3	BSR	BLKBYT		* CALCULATE PRELOAD PAGE ADDRESS
020FE   D0AE FFA8              		ADD.L	BUFFER(A6),D0	* ABSOLUTIZE
02102   2D40 FF44              		MOVE.L  D0,CURPAG(A6)	* REMEMBER NEW PAGE POINTER
02106   42AE FF3E              		CLR.L	CURTAB(A6)	* ZERO TABLE POINTER MEANS PAGE IS PRELOADED
0210A
0210A   4E75                   	NZX4	RTS
0210C
0210C                          	* ----------------------
0210C                          	* GETPAG
0210C                          	* ----------------------
0210C
0210C                          	* GET THE PAGE WHOSE NUMBER IS IN D0, RETURN A POINTER TO IT IN A0
0210C
0210C   B06E FF38              	GETPAG  CMP.W	LPAGE(A6),D0	* IS THIS THE SAME PAGE AS LAST REFERENCED?
02110   6758            0216A  		BEQ.S	GPX4		* YES, RETURN ITS LOCATION
02112
02112   3D40 FF38              		MOVE.W  D0,LPAGE(A6)	* SAVE NEW PAGE NUMBER
02116   52AE FF3A              		ADDQ.L  #1,RTIME(A6)	* UPDATE REFERENCE COUNT
0211A G 206E FFD0              		MOVE.L  PAGTAB(A6),A0	* PAGE INFORMATION TABLE
0211E
0211E   B050                   	GPX1	CMP.W	(A0),D0		* SEARCH FOR DESIRED BLOCK
02120   6622            02144  		BNE.S	GPX3		* NOT IT
02122
02122   B06E FF42              		CMP.W	CURBLK(A6),D0	* FOUND IT, BUT IS IT THE CURRENT ZPC PAGE?
02126   6706            0212E  		BEQ.S	GPX2		* YES, DON'T TOUCH REF TIME (PAGE IS PROTECTED)
02128   216E FF3A 0002         		MOVE.L  RTIME(A6),2(A0)	* NO, UPDATE ITS REFERENCE TIME
0212E
0212E   2D48 FF30              	GPX2	MOVE.L  A0,LPTAB(A6)	* SAVE THE TABLE POINTER
02132   2008                   		MOVE.L  A0,D0
02134   90AE FFD0              		SUB.L	PAGTAB(A6),D0	* BUFFER NUMBER x8
02138   ED80                   		ASL.L	#6,D0		* CALCULATE CORE ADDRESS OF PAGE
0213A   D0AE FFCC              		ADD.L	PAGES(A6),D0
0213E   2D40 FF34              		MOVE.L  D0,LPLOC(A6)	* SAVE IT
02142   6026            0216A  		BRA.S	GPX4		* AND RETURN IT
02144

02144   5088                   	GPX3	ADDQ.L  #8,A0		* SKIP OVER REFERENCE TIME, ETC.
02146   0C50 FFFF              		CMPI.W  #-1,(A0)	* END OF TABLE?
0214A   66D2            0211E  		BNE	GPX1		* NO, CONTINUE SEARCH
0214C
0214C                          	* DESIRED PAGE NOT RESIDENT, MUST READ IT FROM DISK
0214C
0214C   2F09                   		MOVE.L  A1,-(SP)
0214E   6100 0020       02170  		BSR	FINDPG		* FIND AN OLD PAGE
02152   2D48 FF34              		MOVE.L  A0,LPLOC(A6)	* SAVE ITS PAGE POINTER
02156   2D49 FF30              		MOVE.L  A1,LPTAB(A6)	* SAVE ITS PAGTAB POINTER
0215A
0215A   302E FF38              		MOVE.W  LPAGE(A6),D0	* NEW PAGE NUMBER FOR GETBLK
0215E   32C0                   		MOVE.W  D0,(A1)+	* SAVE PAGE NUMBER IN FIRST SLOT
02160   22AE FF3A              		MOVE.L  RTIME(A6),(A1)  * SAVE CURRENT REF TIME
02164
02164   6100 069A       02800  		BSR	GETBLK		* GET THE BLOCK
02168 G 225F                   		MOVE.L  (SP)+,A1	* CLEAN UP
0216A
0216A G 206E FF34              	GPX4	MOVE.L  LPLOC(A6),A0	* RETURN THE PAGE POINTER
0216E   4E75                   		RTS
02170
02170                          	* ----------------------
02170                          	* FINDPG
02170                          	* ----------------------
02170
02170                          	* FIND A GOOD (LRU) PAGE, RETURN PAGE POINTER IN A0 & PAGTAB POINTER IN A1
02170
02170 G 206E FFD0              	FINDPG  MOVE.L  PAGTAB(A6),A0
02174   5488                   		ADDQ.L  #2,A0		* SKIP OVER FIRST PAGE NUMBER
02176 G 70FF                   		MOVE.L  #-1,D0		* FAKE A BEST-CASE REFERENCE COUNT
02178
02178   B090                   	FDPGX1	CMP.L	(A0),D0		* COMPARE PREV OLDEST REF TIME WITH THIS ONE
0217A   6304            02180  		BLS.S	FDPGX2		* STILL THE OLDEST
0217C
0217C   2010                   		MOVE.L  (A0),D0		* NEW OLDEST, SAVE THIS REFERENCE COUNT
0217E G 2248                   		MOVE.L  A0,A1		* AND PAGTAB LOCATION (+2)
02180
02180   5C88                   	FDPGX2	ADDQ.L  #6,A0		* SKIP OVER REF TIME, ETC.
02182   0C58 FFFF              		CMPI.W  #-1,(A0)+	* END OF TABLE?
02186   66F0            02178  		BNE	FDPGX1		* NO
02188
02188   5589                   		SUBQ.L  #2,A1		* RETURN THE PAGTAB LOCATION HERE
0218A   2009                   		MOVE.L  A1,D0
0218C   90AE FFD0              		SUB.L	PAGTAB(A6),D0	* BUFFER NUMBER x8
02190   ED80                   		ASL.L	#6,D0		* CALCULATE CORE ADDRESS OF PAGE
02192   D0AE FFCC              		ADD.L	PAGES(A6),D0
02196 G 2040                   		MOVE.L  D0,A0		* AND RETURN IT HERE
02198   4E75                   		RTS
0219A
0219A

0219A                          	* ----------------------------------------------------------------------
0219A                          	* MACHINE DEPENDENT ROUTINES -- MACINTOSH XZIP
0219A                          	* ----------------------------------------------------------------------
0219A
0219A                          	* ----------------------
0219A                          	* SETSPLT
0219A                          	* ----------------------
0219A
0219A                          	* >>> DEAD <<<
0219A                          	* SET THE SPLIT SIZE, D0 = LINES IN TOP SCREEN (0 IF UNSPLIT)
0219A
0219A                          	* ----------------------
0219A                          	* GETSPLT
0219A                          	* ----------------------
0219A
0219A                          	* >>> DEAD <<<
0219A                          	* RETURN D0 = SPLIT SIZE
0219A
0219A                          	* ----------------------
0219A                          	* SETSCRN
0219A                          	* ----------------------
0219A
0219A                          	* >>> DEAD <<<
0219A                          	* SET THE ACTIVE SCREEN, D0 = NEW VALUE (0 OR 1)
0219A
0219A                          	* ----------------------
0219A                          	* GETSCRN
0219A                          	* ----------------------
0219A
0219A                          	* >>> DEAD <<<
0219A                          	* RETURN D0 = CURRENTLY ACTIVE GAME SCREEN, PLUS FLAGS
0219A
0219A                          	* ----------------------
0219A                          	* MAXSCRN
0219A                          	* ----------------------
0219A
0219A                          	* GET FULL-SCREEN DIMENSIONS, RETURN D0.W = ROWS, D1.W = COLS
0219A
0219A                          	MAXSCRN
0219A   302D 0000              		MOVE.W	totRows,D0
0219E   322D 0000              		MOVE.W	totCols,D1
021A2   4E75                   		RTS
021A4
021A4                          	* ----------------------
021A4                          	* GETFYX
021A4                          	* ----------------------
021A4
021A4                          	* RETURN D0.W = CELL SIZE (IN PIXELS, Y/X) OF CURRENT FONT  (SEE ALSO CHSIZ)
021A4                          	*   IF PROPORTIONAL, RETURN SIZE OF A DIGIT
021A4
021A4   302D 0000              	GETFYX	MOVE.W	lineHeight,D0
021A8   E148                   		LSL.W	#8,D0
021AA   806D 0000              		OR.W	colWidth,D0
021AE
021AE                          	***	MOVE.W	#YCHAR*256+XCHAR,D0
021AE                          	***	MOVE.W	#$0101,D0	* 1 CHAR UNIT = 1 PIXEL
021AE   4E75                   		RTS
021B0
021B0                          	* ----------------------
021B0                          	* SETBUF
021B0                          	* ----------------------
021B0
021B0                          	* ADJUST BUFFERING LENGTH (AFTER CHANGE IN WINDOW SIZE, OR MARGINS)
021B0
021B0   302D 0000              	SETBUF	MOVE.W	lastCol,D0
021B4   906D 0000              		SUB.W	firstCol,D0	* CALC WIDTH
021B8   906D 0000              		SUB.W	margLeft,D0
021BC   906D 0000              		SUB.W	margRight,D0	* ADJUST FOR MARGINS
021C0   6E02            021C4  		BGT.S	SBFX0
021C2                          	***	MOVEQ	#'M',D0
021C2                          	***	BSR	DCHSIZ
021C2                          	***	MOVEQ	<maxchrsiz>,D0
021C2   7001                   		MOVEQ	#1,D0		* MINIMUM VALID LEN (UNITS...)
021C4 G 206E FF54              	SBFX0	MOVE.L	DQUE(A6),A0
021C8   6000 FCEC       01EB6  		BRA	SIZEQP		* AND UPDATE LINE-WRAP

021CC
021CC                          	* ----------------------
021CC                          	* SETBOUNDS
021CC                          	* ----------------------
021CC
021CC                          	* SET DISPLAY-WINDOW POSITION AND SIZE
021CC                          	* ALSO ADJUST CURSOR POSITION; HOME IT IF OUT OF BOUNDS
021CC                          	*   GIVEN D0/D1 = POSITION (ROW/COL, 1-ORIGIN), D2/D3 = SIZE (ROWS/COLS)
021CC
021CC                          	SETBOUNDS
021CC   48E7 0C00              		MOVEM.L	D4-D5,-(SP)
021D0   3800                   		MOVE.W	D0,D4
021D2   3A01                   		MOVE.W	D1,D5
021D4   6100 FE20       01FF6  		BSR	PUTLIN		* (MAKE SURE BUFFER IS EMPTY)
021D8   6100 00CE       022A8  		BSR	GETCURS		* READ CURSOR POS (RELATIVE, 1-ORG)
021DC   C144                   		EXG	D0,D4
021DE   C345                   		EXG	D1,D5
021E0   6100 002E       02210  		BSR	NEWBOUNDS
021E4
021E4   302D 0000              		MOVE.W	totRows,D0
021E8   906D 0000              		SUB.W	firstRow,D0	* CALC NEW HEIGHT
021EC   B840                   		CMP.W	D0,D4		* CURSOR NOW OUT OF BOUNDS?
021EE   6E0C            021FC  		BGT.S	SBNDX4		* YES
021F0
021F0   322D 0000              		MOVE.W	totCols,D1
021F4   926D 0000              		SUB.W	firstCol,D1	* CALC NEW WIDTH
021F8   BA41                   		CMP.W	D1,D5		* CURSOR NOW OUT OF BOUNDS?
021FA   6F04            02200  		BLE.S	SBNDX6		* NO
021FC
021FC   7801                   	SBNDX4	MOVEQ	#1,D4		* HOME CURSOR
021FE   7A01                   		MOVEQ	#1,D5
02200
02200   3004                   	SBNDX6	MOVE.W	D4,D0		* WRITE NEW CURSOR POS
02202   3205                   		MOVE.W	D5,D1
02204   6100 0068       0226E  		BSR	SETCURS
02208
02208   61A6            021B0  		BSR	SETBUF		 * ADJUST BUFFERING LENGTH
0220A   4CDF 0030              		MOVEM.L	(SP)+,D4-D5
0220E   4E75                   		RTS
02210
02210                          	* ----------------------
02210                          	* NEWBOUNDS
02210                          	* ----------------------
02210
02210                          	* SET DISPLAY-WINDOW POSITION AND SIZE
02210                          	*   GIVEN D0/D1 = POSITION (ROW/COL, 1-ORIGIN), D2/D3 = SIZE (ROWS/COLS)
02210
02210                          	NEWBOUNDS
02210   2F07                   		MOVE.L	D7,-(SP)
02212
02212   5340                   		SUBQ.W	#1,D0		* FIRST ROW, MAKE 0-ORIGIN
02214   3E2D 0000              		MOVE.W	totRows,D7
02218   5347                   		SUBQ.W	#1,D7		* (ONLY /LAST/ ROW CAN EQUAL totRows)
0221A   6100 0044       02260  		BSR	INBOUNDS	* MUST BE WITHIN SCREEN
0221E   3B40 0000              		MOVE.W	D0,firstRow
02222
02222   4A42                   		TST.W	D2		* HEIGHT
02224   6C02            02228  		BGE.S	NBNDX2		* MAKE SURE IT'S NON-NEGATIVE
02226   7400                   		MOVEQ	#0,D2
02228
02228   D042                   	NBNDX2	ADD.W	D2,D0		* LAST ROW (+1)
0222A   3E2D 0000              		MOVE.W	totRows,D7
0222E   6100 0030       02260  		BSR	INBOUNDS	* MUST BE WITHIN SCREEN
02232   3B40 0000              		MOVE.W	D0,lastRow
02236
02236   5341                   		SUBQ.W	#1,D1		* FIRST COL, MAKE 0-ORIGIN
02238   3001                   		MOVE.W	D1,D0
0223A   3E2D 0000              		MOVE.W	totCols,D7
0223E   5347                   		SUBQ.W	#1,D7
02240   6100 001E       02260  		BSR	INBOUNDS	* MUST BE WITHIN SCREEN
02244   3B40 0000              		MOVE.W	D0,firstCol
02248
02248   4A43                   		TST.W	D3		* WIDTH
0224A   6C02            0224E  		BGE.S	NBNDX4		* MAKE SURE IT'S NON-NEGATIVE
0224C   7600                   		MOVEQ	#0,D3

0224E
0224E   D043                   	NBNDX4	ADD.W	D3,D0		* LAST COL (+1)
02250   3E2D 0000              		MOVE.W	totCols,D7
02254   6100 000A       02260  		BSR	INBOUNDS	* MUST BE WITHIN SCREEN
02258   3B40 0000              		MOVE.W	D0,lastCol
0225C
0225C   2E1F                   		MOVE.L	(SP)+,D7
0225E   4E75                   		RTS
02260
02260                          	* ----------------------
02260                          	* INBOUNDS
02260                          	* ----------------------
02260
02260                          	* GIVEN D0.W = VALUE, D7.W = BOUNDS;  MAKE SURE 0 <= VAL <= BOUNDS
02260
02260                          	INBOUNDS
02260   B047                   		CMP.W	D7,D0
02262   6F02            02266  		BLE.S	IBNDX1		* CAN'T EXCEED BOUNDS
02264   3007                   		MOVE.W	D7,D0
02266   4A40                   	IBNDX1	TST.W	D0
02268   6C02            0226C  		BGE.S	IBNDX2		* [THEN] MUST BE NON-NEGATIVE
0226A   7000                   		MOVEQ	#0,D0
0226C   4E75                   	IBNDX2	RTS
0226E
0226E                          	* ----------------------
0226E                          	* SETCURS
0226E                          	* ----------------------
0226E
0226E                          	* SET CURSOR POSITION
0226E                          	*   GIVEN D0.W = ROW, D1.W = COL (1-ORIGIN, RELATIVE TO CURRENT WINDOW)
0226E                          	*   -1 MEANS DON'T CHANGE
0226E
0226E                          	SETCURS
0226E                          	***	bsr	putlin    ?? 	* done by caller
0226E                          	***	MOVEM.L	D1/D7,-(SP)
0226E   2F07                   		MOVE.L	D7,-(SP)
02270   4A40                   		TST.W	D0		* ROW [DON'T CHANGE?]
02272   6D16            0228A  		BLT.S	SCURX2
02274   5340                   		SUBQ.W	#1,D0		* MAKE 0-ORIGIN
02276
02276   3E2D 0000              		MOVE.W	lastRow,D7
0227A   9E6D 0000              		SUB.W	firstRow,D7	* CALC HEIGHT
0227E   5347                   		SUBQ.W	#1,D7
02280
02280                          	*** MAKE SURE AT LEAST 1 /CHAR/ IN FROM WINDOW EDGE (?)
02280                          	***	MOVE.L	CURWP(A6),A0
02280                          	***	MOVEQ	#0,D1
02280                          	***	MOVE.B	WFONTYX(A0),D1	* VERTICAL LINE SIZE
02280
02280   61DE            02260  		BSR	INBOUNDS	* "CLIP" (DON'T HOME) POSITION IF NEEDED
02282   D06D 0000              		ADD.W	firstRow,D0	* ABSOLUTIZE POSITION
02286   3B40 0000              		MOVE.W	D0,curRow
0228A
0228A   3001                   	SCURX2	MOVE.W	D1,D0		* COL [DON'T CHANGE?]
0228C   6D16            022A4  		BLT.S	SCURX4
0228E   5340                   		SUBQ.W	#1,D0		* MAKE 0-ORIGIN
02290
02290   3E2D 0000              		MOVE.W	lastCol,D7
02294   9E6D 0000              		SUB.W	firstCol,D7	* CALC WIDTH
02298   5347                   		SUBQ.W	#1,D7
0229A   61C4            02260  		BSR	INBOUNDS	* MAKE SURE CURSOR WITHIN WINDOW
0229C   D06D 0000              		ADD.W	firstCol,D0	* ABSOLUTIZE POSITION
022A0   3B40 0000              		MOVE.W	D0,curCol
022A4
022A4   2E1F                   	SCURX4	MOVE.L	(SP)+,D7
022A6                          	***	MOVEM.L	(SP)+,D1/D7
022A6   4E75                   		RTS
022A8
022A8                          	* ----------------------
022A8                          	* GETCURS
022A8                          	* ----------------------
022A8
022A8                          	* RETURN CURSOR POSITION (RELATIVE TO CURRENT WINDOW, 1-ORIGIN)
022A8                          	*   D0.W = ROW, D1.W = COL
022A8

022A8   6100 FD4C       01FF6  	GETCURS BSR	PUTLIN		* (FIRST, MAKE SURE BUFFER IS EMPTY)
022AC
022AC                          	* ENTER HERE FROM NXTLIN, ETC ...
022AC                          	GETCURS1
022AC   302D 0000              		MOVE.W	curRow,D0
022B0   906D 0000              		SUB.W	firstRow,D0	* RELATIVIZE IT
022B4   5240                   		ADDQ.W	#1,D0		* MAKE 1-ORIGIN
022B6   322D 0000              		MOVE.W	curCol,D1
022BA   926D 0000              		SUB.W	firstCol,D1	* RELATIVIZE IT
022BE   5241                   		ADDQ.W	#1,D1		* MAKE 1-ORIGIN
022C0   4E75                   		RTS
022C2
022C2                          	* ----------------------
022C2                          	* SETFONT
022C2                          	* ----------------------
022C2
022C2                          	* SET FONT (IN CURRENT WINDOW), D0.W = ID
022C2
022C2                          	* ZSTD = 1;		{ Geneva }
022C2                          	* ZGFX = 2;		{ "graphics font" -- NOT HANDLED }
022C2                          	* ZALT = 3;		{ BZ Font [currently 9-point] }
022C2                          	* ZMONO = -1;		{ Monaco }
022C2                          	* ZTOGGLE = -2;		{ switch proportional/mono (for debugging) }
022C2
022C2                          	SETFONT
022C2                          		SAVEREGS
022C6   3F00                   		MOVE.W	D0,-(SP)
022C8   4EBA 0000              		JSR	ZFont
022CC                          		RESTREGS
022D0
022D0                          	***	MOVE.W	D0,currentFont
022D0   4E75                   		RTS
022D2
022D2                          	* ----------------------
022D2                          	* GETFONT
022D2                          	* ----------------------
022D2
022D2                          	* RETURN FONT (IN CURRENT WINDOW), D0.W = ID
022D2                          	* >> DEAD <<
022D2
022D2                          	* ----------------------
022D2                          	* SETHL, SETATTR
022D2                          	* ----------------------
022D2
022D2   3B40 0000              	SETATTR	MOVE.W	D0,currentAttr	* wrap, etc
022D6   4E75                   		RTS
022D8
022D8   3F01                   	SETHL	MOVE.W	D1,-(SP)
022DA   3B40 0000              		MOVE.W	D0,currentHl	* UPDATE:  inverse, etc
022DE
022DE                          	* BIT 8 = MONOFONT -- CHECK AND HANDLE SEPARATELY  (TO BE IMPLEMENTED)
022DE                          	* IDEA: UNDER YZIP, MONOFONT SHOULD BE DEFINED UNDER OPFONT NOT OPHLIGHT
022DE
022DE                          	*	MOVE.W	currentHl,D1	* PREVIOUS VAL
022DE                          	*	XXX
022DE                          	*	BSR	SETFONT
022DE
022DE   321F                   		MOVE.W	(SP)+,D1
022E0   4E75                   		RTS
022E2
022E2                          	* ----------------------
022E2                          	* MDATTR
022E2                          	* ----------------------
022E2
022E2                          	* SET THE HIGHLIGHTING ("ATTRIBUTES"), ARGBIT(S) IN D0.W
022E2                          	*   IF D0 = -1, JUST RETURN OLD ATTRIBUTES
022E2                          	* >> DEAD <<
022E2
022E2                          	* ----------------------
022E2                          	* MDSCROLL
022E2                          	* ----------------------
022E2
022E2                          	* SCROLL CURRENT WINDOW, D0.W = DELTA (IN PIXELS) (NEGATIVE MEANS DOWN)
022E2
022E2                          	MDSCROLL

022E2                          		SAVEREGS
022E6   3F00                   		MOVE.W	D0,-(SP)
022E8   4EBA 0000              		JSR	Scroll
022EC                          		RESTREGS
022F0   4E75                   		RTS
022F2
022F2                          	* ----------------------
022F2                          	* MDCLEAR
022F2                          	* ----------------------
022F2
022F2                          	* CLEAR ACTIVE WINDOW
022F2                          	* D0.W = -1 MEANS CLEAR ENTIRE SCREEN
022F2
022F2                          	MDCLEAR	SAVEREGS
022F6   3F00                   		MOVE.W	D0,-(SP)
022F8   4EBA 0000              		JSR	ClearWindow	* [was ClearLines]
022FC                          		RESTREGS
02300   4E75                   		RTS
02302
02302                          	* ----------------------
02302                          	* SETMARG
02302                          	* ----------------------
02302
02302                          	* SET THE LEFT AND RIGHT MARGINS
02302                          	* D0.W = LEFT, D1.W = RIGHT (DEFAULTS ARE BOTH 0)
02302
02302   3B40 0000              	SETMARG	MOVE.W	D0,margLeft
02306   3B41 0000              		MOVE.W	D1,margRight
0230A   6000 FEA4       021B0  		BRA	SETBUF		 * ADJUST BUFFERING LENGTH
0230E
0230E                          	* ----------------------
0230E                          	* GETMARG
0230E                          	* ----------------------
0230E
0230E                          	* >>> DEAD <<<
0230E                          	* RETURN THE LEFT AND RIGHT MARGINS
0230E
0230E                          	* ----------------------
0230E                          	* SETUNDO
0230E                          	* ----------------------
0230E
0230E                          	* SET AN "UNDO-SUPPORTED" FLAG FOR PASCAL
0230E
0230E   1B40 0000              	SETUNDO	MOVE.B	D0,undoflag	* [BOOL, ADDRESS AS BYTE FROM 68K]
02312   4E75                   		RTS
02314
02314                          	* ----------------------
02314                          	* MDERASE
02314                          	* ----------------------
02314
02314                          	* CLEAR WITHIN CURRENT LINE, D0.W = START [ABSOLUTE!], D1.W = LEN
02314                          	* DEFAULTS VALS (-1) ARE CURSOR POSITION AND [TO] EOL
02314
02314                          	MDERASE	SAVEREGS
02318   3F00                   		MOVE.W	D0,-(SP)
0231A   3F01                   		MOVE.W	D1,-(SP)
0231C   4EBA 0000              		JSR	EraseLine	* (left, right: INTEGER)
02320                          		RESTREGS
02324   4E75                   		RTS
02326
02326                          	* ----------------------
02326                          	* MDCOLOR
02326                          	* ----------------------
02326
02326                          	* SET/GET SCREEN COLORS
02326                          	* GIVEN D0.W = FORE, D1.W = BACK,
02326                          	* RETURN D0.W = DEFAULT BACK/DEFAULT FORE, D1.W = COLOR FLAG (0 IF MONO)
02326
02326                          	MDCOLOR	SAVEREGS
0232A                          		RESWORD
0232C   3F00                   		MOVE.W	D0,-(SP)
0232E   3F01                   		MOVE.W	D1,-(SP)
02330   4EBA 0000              		JSR	SetColor
02334                          		POPWORD
02336                          		RESTREGS

0233A   7200                   		MOVEQ	#0,D1
0233C   122D 0000              		MOVE.B	mColor,D1	* Mac: Boolean var
02340   4E75                   		RTS
02342
02342                          	* ----------------------
02342                          	* PICINF
02342                          	* ----------------------
02342
02342                          	* LOOKUP PICTURE SIZE INFO
02342                          	* GIVEN D0.W = ID, A0 -> TABLE FOR RESULTS (Y,X)
02342                          	*   IF ID = 0, RETURN MAX ID IN TABLE WORD 0
02342                          	*   IF ID IS IN ERROR, RETURN FLAGS NEGATIVE, ELSE ZERO
02342                          	* EXTERN FUNCTION opPicinf (n: INTEGER; VAR tbl: ARRAY2): INTEGER;
02342
02342                          	PICINF	SAVEREGS
02346                          		RESWORD
02348   3F00                   		MOVE.W	D0,-(SP)
0234A   2F08                   		MOVE.L	A0,-(SP)
0234C   4EBA 0000              		JSR	opPicinf
02350                          		POPWORD
02352                          		RESTREGS
02356   4E75                   		RTS
02358
02358                          	* ----------------------
02358                          	* PICDISP
02358                          	* ----------------------
02358
02358                          	* DISPLAY [OR CLEAR] A PICTURE
02358                          	* D0.W = ID (1-ORIG), D1,D2 = YPOS,XPOS (1-ORIG), D3 = NONZERO TO CLEAR
02358                          	* EXTERN PROCEDURE opDisplay (id, ypos, xpos, erase: INTEGER);
02358
02358                          	PICDISP	SAVEREGS
0235C   3F00                   		MOVE.W	D0,-(SP)
0235E   5341                   		SUBQ.W	#1,D1		* MAKE POSITION 0-ORIGIN
02360   3F01                   		MOVE.W	D1,-(SP)
02362   5342                   		SUBQ.W	#1,D2
02364   3F02                   		MOVE.W	D2,-(SP)
02366   3F03                   		MOVE.W	D3,-(SP)
02368   4EBA 0000              		JSR	opDisplay
0236C                          		RESTREGS
02370   4E75                   		RTS
02372
02372                          	* ----------------------
02372                          	* ENDTITLE
02372                          	* ----------------------
02372
02372                          	* IF A TITLE SCREEN WAS DRAWN, WAIT FOR A KEY. DON'T ERASE SCREEN, LET
02372                          	* GAME. (OTHERWISE MAY CAUSE A FLASH AS GAME SETS UP ITS SCREEN COLORS.)
02372                          	* COME HERE AFTER GAME HAS BEEN LOADED BUT BEFORE STARTING.
02372
02372                          	ENDTITLE
02372   4E75                   		RTS		* Mac: NOT IMPLEMENTED
02374
02374                          	* ----------------------
02374                          	* SYSIN1
02374                          	* ----------------------
02374
02374                          	* MISC SYSTEM INITIALIZATION
02374
02374                          	SYSIN1	SAVEREGS
02378   486E FEEC              		PEA	GAMFIL(A6)	;OPEN GAME FILE, GET REF NUMBER ...
0237C   486E FEDA              		PEA	APPARM(A6)	;AND FINDER PARAMETERS HANDLE ...
02380   4EBA 0000              		JSR	MacInit 	;WHILE INITIALIZING MACINTOSH INTERFACE
02384                          		RESTREGS
02388
02388   4A6E FEEC              		TST.W	GAMFIL(A6)
0238C   6702            02390  		BEQ.S	SYSX1		* ERROR
0238E   4E75                   		RTS			* OK
02390
02390   41ED 0296              	SYSX1	LEA	MSGOPN,A0
02394   6000 03C2       02758  		BRA	FATAL		* 'Story file open error.'
02398
00296                          	    DATA
00296   53746F72792066         	MSGOPN	DC.B	'Story file open error.',0
02398                          	    CODE

02398
02398                          	* ----------------------
02398                          	* GETM, GETMEM, GETMEMC
02398                          	* ----------------------
02398
02398                          	* ALLOCATE MEMORY, NUMBER OF BYTES REQUESTED IN D0.L, RETURN POINTER IN A0
02398                          	*   (GETMEM TRAPS ERRORS, GETM DOESN'T)
02398
02398                          	GETM	SAVEREGS
0239C   0800 0000              		BTST	#0,D0		* ODD REQUEST?
023A0   6702            023A4  		BEQ.S	GETMX1		* NO
023A2   5280                   		ADDQ.L	#1,D0		* YES, ROUND UP (FIXES ST GEMDOS-48 BUG)
023A4
023A4                          	GETMX1	RESLONG
023A6   2F00                   		MOVE.L	D0,-(SP)	* REQUEST
023A8   4EBA 0000              		JSR	ZAlloc
023AC                          		POPLONG
023AE G 2040                   		MOVE.L	D0,A0		* RESULT, ZERO IF ERROR
023B0                          		RESTREGS
023B4   4E75                   		RTS
023B6
023B6                          	* ALLOCATE MEMORY AS ABOVE, AND CHECK FOR ERROR
023B6
023B6   61E0            02398  	GETMEM	BSR	GETM
023B8   2008                   		MOVE.L	A0,D0		* GOT IT?
023BA   6702            023BE  		BEQ.S	MEMERROR	* ZERO MEANS FAILURE
023BC   4E75                   		RTS
023BE
023BE                          	MEMERROR
023BE   4240                   		CLR.W	D0
023C0   41ED 02AD              		LEA	MSGME1,A0
023C4   6000 0392       02758  		BRA	FATAL		* 'Not enough memory.'
023C8
002AD                          	    DATA
002AD   4E6F7420656E6F         	MSGME1	DC.B	'Not enough memory.',0
023C8                          	    CODE
023C8
023C8                          	* ALLOCATE MEMORY AS ABOVE, CHECK FOR ERROR, AND CLEAR
023C8                          	*   (SLOW LOOP; SHOULD USE ONLY FOR SMALL BLOCKS)
023C8
023C8   2F00                   	GETMEMC	MOVE.L	D0,-(SP)
023CA   61EA            023B6  		BSR	GETMEM
023CC   201F                   		MOVE.L	(SP)+,D0
023CE
023CE   2F08                   		MOVE.L	A0,-(SP)
023D0   6002            023D4  		BRA.S	GTMCX2
023D2   4218                   	GTMCX1	CLR.B	(A0)+
023D4                          	***	CLR.W	(A0)+		* [ASSUME RETURNED PTR IS WORD ALIGNED]
023D4 G 51C8 FFFC       023D2  	GTMCX2	DBRA	D0,GTMCX1	* [ABSOLUTE MAX LEN = 32K]
023D8 G 205F                   		MOVE.L	(SP)+,A0
023DA   4E75                   		RTS
023DC
023DC                          	* ----------------------
023DC                          	* MEMAVAIL
023DC                          	* ----------------------
023DC
023DC                          	* DETERMINE AVAILABLE MEMORY, RETURN NUMBER OF BYTES AVAILABLE IN D0.L
023DC
023DC   0000 5000              	MEMSYS  EQU	40*512		* ALLOW FOR DA'S, PACKAGES, AND ZIP OVERHEAD
023DC
023DC                          	MEMAVAIL
023DC                          		SAVEREGS
023E0                          		RESLONG
023E2   70FF                   		MOVEQ	#-1,D0		* INQUIRE MAXIMUM AVAIL MEMORY
023E4   2F00                   		MOVE.L	D0,-(SP)
023E6   4EBA 0000              		JSR	ZAlloc
023EA                          		POPLONG
023EC G 0480 0000 5000         		SUB.L	#MEMSYS,D0	* "FUDGE FACTOR"
023F2                          		RESTREGS
023F6   4E75                   		RTS
023F8
023F8                          	* ----------------------
023F8                          	* GTSEED
023F8                          	* ----------------------
023F8

023F8                          	* RETURN A RANDOM NUMBER SEED IN D0, DIFFERENT EACH COLDSTART
023F8                          	* [FOR MAC, SECONDS ELAPSED SINCE MIDNIGHT, JAN 1, 1904, WILL WRAP IN 2040]
023F8
023F8   2038 020C              	GTSEED	MOVE.L	TIME,D0		* [MAC]
023FC   4E75                   		RTS
023FE
023FE                          	* ----------------------
023FE                          	* TIME60
023FE                          	* ----------------------
023FE
023FE                          	* ELAPSED TIME (IN 60THS SECOND) SINCE SYSTEM STARTUP
023FE
023FE   2038 016A              	TIME60	MOVE.L	TICKS,D0	* [MAC]
02402   4E75                   		RTS
02404
02404                          	* ----------------------
02404                          	* DCHSIZ, SCHSIZ
02404                          	* ----------------------
02404
02404                          	* GIVEN AN ASCII CHAR, RETURN ITS UNIT WIDTH (IN CURRENT FONT)
02404                          	* >> NOW SUPPORTS PROPORTIONAL FONTS <<
02404                          	* >> Call the Mac Toolbox directly, for speed <<
02404
02404   48E7 6040              	DCHSIZ	MOVEM.L	D1-D2/A1,-(SP)	* Save regs that Toolbox doesn't [need a new macro]
02408   558F                   		SUBQ.L	#2,SP		* [space for return val]
0240A                          	***	MOVE.B	D0,-(SP)	* [only for a boolean!]
0240A   3F00                   		MOVE.W	D0,-(SP)
0240C   A88D                   		_CharWidth
0240E   301F                   		MOVE.W	(SP)+,D0
02410   4CDF 0206              		MOVEM.L	(SP)+,D1-D2/A1
02414
02414                          	***	MOVEQ	#XCHAR,D0	* [IN PIXELS]
02414   4E75                   		RTS
02416
02416   7001                   	SCHSIZ	MOVEQ	#1,D0		* SCRIPTING: ALWAYS 1 UNIT
02418   4E75                   		RTS
0241A
0241A                          	* ----------------------
0241A                          	* DOSOUND
0241A                          	* ----------------------
0241A
0241A                          	* MAC: ADJUST ARG4
0241A                          	*   COUNT: 0=INFINITE, 1-254=FINITE, -1=USE MIDI COUNT
0241A
0241A   4A43                   	DOSOUND	TST.W	D3
0241C   6E06            02424  		BGT.S	DOSDX2		* IF 1-254, JUST PASS ALONG
0241E   5243                   		ADDQ.W	#1,D3		* MAP -1 TO 0
02420   6702            02424  		BEQ.S	DOSDX2
02422   76FF                   		MOVEQ	#-1,D3		* MAP 0 TO -1
02424
02424                          	DOSDX2	SAVEREGS
02428   3F00                   		MOVE.W	D0,-(SP)	* ID
0242A   3F01                   		MOVE.W	D1,-(SP)	* ACTION
0242C   3F02                   		MOVE.W	D2,-(SP)	* VOLUME
0242E   3F03                   		MOVE.W	D3,-(SP)	* COUNT
02430   4EBA 0000              		JSR	ZSound
02434                          		RESTREGS
02438   4E75                   		RTS
0243A
0243A                          	* ----------------------
0243A                          	* ZBEEP
0243A                          	* ----------------------
0243A
0243A   48E7 7000              	ZBEEP	MOVEM.L	D1-D3,-(SP)
0243E   7001                   		MOVEQ	#1,D0		* BEEP ID
02440   7202                   		MOVEQ	#2,D1		* START
02442   74FF                   		MOVEQ	#-1,D2		* DEFAULT VOL
02444   7601                   		MOVEQ	#1,D3		* SINGLE REPEAT
02446   61D2            0241A  		BSR	DOSOUND
02448   4CDF 000E              		MOVEM.L	(SP)+,D1-D3
0244C   4E75                   		RTS
0244E
0244E                          	* ----------------------
0244E                          	* GAMINT, GAMINT1
0244E                          	* ----------------------

0244E
0244E                          	* PERIODICALLY CHECK FOR GAME INTERRUPTS
0244E
0244E                          	* NOTE: BECAUSE THE INTERPRETER AS A WHOLE IS /NOT/ RE-ENTRANT, THIS
0244E                          	* ROUTINE SHOULD BE CALLED ONLY FROM THE TOP OF THE MAIN LOOP (NXTINS), AND
0244E                          	* (PERHAPS) FROM OPREAD/OPINPUT (SO SOUNDS CAN CHAIN BETWEEN MOVES).
0244E                          	* BUT IT SHOULD /NOT/ BE CALLED FROM ITTYIN, SINCE THAT IS ALSO CALLED
0244E                          	* FROM [MORE], AND THE INTERPRETER STATE IS UNDEFINED.
0244E
0244E   0000 0032              	SKPCNT	EQU	50	* 2500 ops/sec (max) ==> 50 ints/sec (max)
0244E
0244E                          	* ENTRY POINT FROM MAIN LOOP
0244E                          	* To avoid cutting into interpreter performance too much, we keep a
0244E                          	* simple counter, and only occasionally perform the (somewhat costlier)
0244E                          	* check for a sound interrupt.
0244E
0244E   536E FF22              	GAMINT	SUBQ.W	#1,SCOUNT(A6)	* TIME FOR A SOUND CHECK?
02452   6F02            02456  		BLE.S	GAMIX1
02454   4E75                   		RTS			* NO, QUICK EXIT
02456   3D7C 0032 FF22         	GAMIX1	MOVE.W	#SKPCNT,SCOUNT(A6)    * YES, RESET COUNTER AND FALL THRU
0245C
0245C                          	* ENTRY POINT FROM INPUT-WAIT LOOP
0245C                          	* While awaiting Mac input, check for sound every time around (or at least
0245C                          	* every 1/10 sec).  Note: called from OPREAD/OPINPUT; probably safe to call
0245C                          	* interrupt function as long as it doesn't itself call OPREAD/OPINPUT.
0245C
0245C                          	GAMINT1	SAVEREGS
02460
02460                          	* (could check first for valid SFUNC(A6), skip end-check if none,
02460                          	* but then end event would hang around unreported ...)
02460
02460                          		RESWORD
02462   4EBA 0000              		JSR	EndZSound	* END-OF-SOUND CHECK
02466   101F                   		MOVE.B	(SP)+,D0	* >> BOOLEAN <<  NON-ZERO IF END DETECTED
02468   670A            02474  		BEQ.S	GAMIX3
0246A
0246A   302E FF24              		MOVE.W	SFUNC(A6),D0	* SOUND-INTERRUPT FUNCTION ("START NEXT")
0246E   6704            02474  		BEQ.S	GAMIX3		* NONE
02470   6100 F368       017DA  		BSR	INCALL		* CALL IT (INTERNALLY)
02474                          	***	TST.W	D0		* (NO RETURN VAL)
02474
02474                          	GAMIX3	RESTREGS
02478   4E75                   		RTS
0247A
0247A                          	* ----------------------
0247A                          	* FINISH
0247A                          	* ----------------------
0247A
0247A                          	* RESTART THE SYSTEM (RETURN TO THE DESKTOP)
0247A
0247A   7000                   	FINISH	MOVEQ	#0,D0		* LAST-USED SOUND ID
0247C   7204                   		MOVEQ	#4,D1		* CLEANUP
0247E   74FF                   		MOVEQ	#-1,D2		* DEFAULT VOL
02480   76FF                   		MOVEQ	#-1,D3		* DEFAULT REPEAT
02482   6196            0241A  		BSR	DOSOUND		* MAKE SURE IT'S OFF
02484
02484   7000                   		MOVEQ	#0,D0
02486   6100 0300       02788  		BSR	SCRINIT		* MAKE SURE SCRIPTING'S OFF
0248A
0248A   4A6E FEF0              		TST.W	INLAST(A6)	* HAS THERE BEEN INPUT SINCE LAST OUTPUT?
0248E   6600 002A       024BA  		BNE	FINIX3		* YES, JUST EXIT
02492
02492   6100 FAEE       01F82  		BSR	PUTNEW		* NO, MUST FIRST PAUSE FOR A PROMPT
02496   41ED 02C0              		LEA	MSGKEY,A0
0249A   6100 0284       02720  		BSR	OUTMSG0		* 'Press any key to exit '
0249E
002C0                          	    DATA
002C0   50726573732061         	MSGKEY	DC.B	'Press any key to exit ',0
0249E                          	    CODE
0249E
0249E   7001                   		MOVEQ	#1,D0		* [ALWAYS SETUP AROUND ITTYIN]
024A0   7200                   		MOVEQ	#0,D1		* SINGLE CHAR
024A2   6100 0022       024C6  		BSR	SETUPI
024A6   6100 0056       024FE  	FINIX2	BSR	ITTYIN		* FIRST CHECK FOR ANY TYPED-AHEAD KEYS ...
024AA   4A00                   		TST.B	D0		* AND DISCARD THEM

024AC   66F8            024A6  		BNE	FINIX2		* UNTIL NO MORE
024AE   7000                   		MOVEQ	#0,D0
024B0   7200                   		MOVEQ	#0,D1		* SINGLE CHAR
024B2   6100 0012       024C6  		BSR	SETUPI
024B6   6100 00E6       0259E  		BSR	TTYIN		* THEN WAIT FOR ONE MORE
024BA
024BA   3F2E FEEC              	FINIX3	MOVE.W	GAMFIL(A6),-(SP)
024BE   4EBA 0000              		JSR	QuitGame	* CLOSE GAME FILE, WINDOWS, ETC.
024C2
024C2                          	* THIS LINE FIXES A BUG IN ONE OF THE MPW 1.0 LIBRARIES -- IT CORRECTLY
024C2                          	* RESETS A SYSTEM GLOBAL USED BY THE SOUND DRIVER.  MPW 2.0 IS SAID TO
024C2                          	* FIX THE BUG TOO, SO BEST TO REMOVE THIS LINE AFTER WE UPGRADE.
024C2                          	*
024C2                          	* NOPE, THE ZIP CAN'T DO THIS -- THE DEALLOC HASN'T HAPPENED YET!
024C2                          	****	MOVE.L	#$0A06,#$0AE8	* (RESETS PTR TO $FFFFFFFF AFTER DEALLOC)
024C2
024C2   4E5E                   		UNLK	A6		* FLUSH THE ZIP'S STACK FRAME
024C4   4E75                   		RTS			* RETURN TO ORIGINAL CALLER
024C6
024C6

024C6                          	* -----------------------------------------------
024C6                          	* SCREEN/KEY I/O
024C6                          	* -----------------------------------------------
024C6
024C6                          	* ----------------------
024C6                          	* SETUPI
024C6                          	* ----------------------
024C6
024C6                          	* MUST "BRACKET" CALLS TO TTYIN OR INCHR WITH CALLS TO HERE
024C6                          	* ACTIVATES/DEACTIVATES BLINKING CURSOR AND MENU COMMAND-STRINGS
024C6                          	*    D0.W = 1 TO BEGIN CURSOR, 0 TO END
024C6                          	*    D1.W = 1 IF STRING INPUT, 0 IF SINGLE-CHAR INPUT
024C6
024C6   4A40                   	SETUPI	TST.W	D0		* STARTING INPUT?
024C8   670E            024D8  		BEQ.S	SETUX1		* NO, ENDING
024CA   3D7C 0001 FEF0         		MOVE.W  #1,INLAST(A6)	* SET INPUT FLAG
024D0 G 206E FF14              		MOVE.L	CURWP(A6),A0
024D4   4268 001E              		CLR.W	WLCNT(A0)	* RESET THE [MORE] COUNTER
024D8
024D8                          	SETUX1	SAVEREGS
024DC   1F00                   		MOVE.B	D0,-(SP)
024DE   1F01                   		MOVE.B	D1,-(SP)
024E0   4EBA 0000              		JSR	SetUpInput
024E4                          		RESTREGS
024E8   4E75                   		RTS
024EA
024EA                          	* ----------------------
024EA                          	* INCHR
024EA                          	* ----------------------
024EA
024EA                          	* INPUT A CHAR AND ECHO IT, RETURN CHAR IN D0	*** DEAD, USE READLN ***
024EA                          	*   [CAREFUL WITH CR AND BACKSPACE]
024EA
024EA   6100 00B2       0259E  	INCHR	BSR	TTYIN		* GET CHAR
024EE   4A6E FF58              		TST.W	VIECHO(A6)	* IS ECHOING TURNED OFF?
024F2   6708            024FC  		BEQ.S	INCHX1		* YES, JUST EXIT
024F4
024F4   3F00                   		MOVE.W	D0,-(SP)
024F6   6100 00F0       025E8  		BSR	TTYOUT		* ECHO CHAR
024FA   301F                   		MOVE.W	(SP)+,D0
024FC   4E75                   	INCHX1	RTS
024FE
024FE                          	* ----------------------
024FE                          	* TTYIN, ITTYIN
024FE                          	* ----------------------
024FE
024FE                          	* INPUT A SINGLE CHAR (XZIP: or mouse clicks), NO ECHO
024FE                          	* IF NONE AVAILABLE, RETURN A ZERO IMMEDIATELY
024FE
024FE                          	ITTYIN	SAVEREGS
02502                          		RESWORD
02504   4EBA 0000              		JSR	EventIn
02508                          		POPWORD
0250A                          		RESTREGS
0250E   0240 00FF              		ANDI.W  #$00FF,D0
02512   0C00 00FD              		CMPI.B	#253,D0		* MOUSE BUTTON CLICK? (SINGLE OR DOUBLE)
02516   6726            0253E  		BEQ.S	ITTYX11		* YES
02518   0C00 00FE              		CMPI.B	#254,D0
0251C   6720            0253E  		BEQ.S	ITTYX11		* YES
0251E
0251E   0C00 000D              		CMPI.B	#13,D0		* CR,BS ARE ONLY VALID CONTROL CHARS
02522   6718            0253C  		BEQ.S	ITTYX2
02524   0C00 0008              		CMPI.B	#8,D0
02528   6712            0253C  		BEQ.S	ITTYX2
0252A
0252A   0C00 0003              		CMPI.B	#3,D0		* [MAC: MAP 'ENTER' TO 'RETURN']
0252E   6604            02534  		BNE.S	ITTYX1
02530   700D                   		MOVEQ	#13,D0
02532   6008            0253C  		BRA.S	ITTYX2
02534
02534   0C00 001F              	ITTYX1	CMPI.B	#31,D0		* SUPPRESS OTHERS (TAB, CLR, ETC)
02538   6202            0253C  		BHI.S	ITTYX2
0253A   7000                   		MOVEQ	#0,D0
0253C   4E75                   	ITTYX2	RTS			* RETURN CHAR OR FKEY CODE
0253E

0253E                          	* HERE AFTER MOUSE EVENT, STORE POSITION IN GLOBALS
0253E
0253E   48E7 7040              	ITTYX11	MOVEM.L	D1-D3/A1,-(SP)
02542   3600                   		MOVE.W	D0,D3		* SAVE MOUSE CODE (SINGLE OR DOUBLE)
02544
02544                          	*** ["BZ" ISN'T SETTING THE MOUSE BIT; DEPEND FOR NOW ON LOWCORE ERR-CHECK]
02544                          	***	MOVE.L	BUFFER(A6),A0
02544                          	***	MOVE.W	PFLAGS(A0),D0
02544                          	***	BTST	#FMOUS,D0	* BUT DOES GAME USE MOUSE?
02544                          	***	BEQ.S	ITTYX18		* NO
02544
02544                          	* CHECK IF MOUSE INBOUNDS
02544
02544   322D 0000              		MOVE.W	ymouse,D1	* (RELATIVE TO ENTIRE GAME WINDOW; 1-ORIGIN)
02548                          	**	ADDQ.W	#1,D1
02548   342D 0000              		MOVE.W	xmouse,D2
0254C                          	**	ADDQ.W	#1,D1
0254C
0254C   302E FEF2              		MOVE.W	MSWIND(A6),D0	* CONSTRAIN MOUSE TO THIS WINDOW
02550   6D24            02576  		BLT.S	ITTYX13		* -1 MEANS NO CONSTRAINT
02552   6100 EAE0       01034  		BSR	CALCWP
02556 G 2248                   		MOVE.L	A0,A1		* POINT TO WINDOW-RECORD
02558
02558   3011                   		MOVE.W	WYPOS(A1),D0
0255A   B240                   		CMP.W	D0,D1
0255C   6D36            02594  		BLT.S	ITTYX18		* OUT OF BOUNDS
0255E   D069 0004              		ADD.W	WYSIZE(A1),D0
02562   B240                   		CMP.W	D0,D1
02564   6C2E            02594  		BGE.S	ITTYX18		* OUT OF BOUNDS
02566
02566   3029 0002              		MOVE.W	WXPOS(A1),D0
0256A   B440                   		CMP.W	D0,D2
0256C   6D26            02594  		BLT.S	ITTYX18		* OUT OF BOUNDS
0256E   D069 0006              		ADD.W	WXSIZE(A1),D0
02572   B440                   		CMP.W	D0,D2
02574   6C1E            02594  		BGE.S	ITTYX18		* OUT OF BOUNDS
02576
02576                          	* STORE MOUSE Y POSITION
02576
02576   7002                   	ITTYX13	MOVEQ	#PMLOCY,D0	* LOWCORE-EXTENSION VAR FOR MOUSE YPOS
02578   6100 DE50       003CA  		BSR	LOWCORE		* GET ITS ADDR
0257C   6716            02594  		BEQ.S	ITTYX18		* ERROR (TABLE UNDEFINED, OR TOO SMALL)
0257E   3001                   		MOVE.W	D1,D0
02580   6100 DE7C       003FE  		BSR	PTAWRD
02584
02584                          	* STORE MOUSE X POSITION
02584
02584   7001                   		MOVEQ	#PMLOCX,D0
02586   6100 DE42       003CA  		BSR	LOWCORE
0258A   6708            02594  		BEQ.S	ITTYX18		* ERROR
0258C   3002                   		MOVE.W	D2,D0
0258E   6100 DE6E       003FE  		BSR	PTAWRD
02592   6002            02596  		BRA.S	ITTYX19
02594
02594   4243                   	ITTYX18	CLR.W	D3		* ERROR, DISCARD MOUSE EVENT
02596   3003                   	ITTYX19	MOVE.W	D3,D0		* RETURN MOUSE CODE
02598   4CDF 020E              		MOVEM.L	(SP)+,D1-D3/A1
0259C   4E75                   		RTS
0259E
0259E                          	* ENTER HERE TO LOOP UNTIL A CHAR IS AVAILABLE
0259E
0259E   48E7 6000              	TTYIN	MOVEM.L	D1-D2,-(SP)
025A2   7001                   		MOVEQ	#1,D0		* SET UP FOR INPUT
025A4   7200                   		MOVEQ	#0,D1		* SINGLE CHAR
025A6   6100 FF1E       024C6  		BSR	SETUPI
025AA
025AA   6100 FF52       024FE  	TTYX1	BSR	ITTYIN
025AE   4A00                   		TST.B	D0
025B0   67F8            025AA  		BEQ.S	TTYX1		* IF NONE, KEEP WAITING
025B2
025B2   3400                   		MOVE.W	D0,D2
025B4   7000                   		MOVEQ	#0,D0		* FINISHED INPUT
025B6   7200                   		MOVEQ	#0,D1		* SINGLE CHAR
025B8   6100 FF0C       024C6  		BSR	SETUPI
025BC   3002                   		MOVE.W	D2,D0		* RETURN THE CHAR

025BE   4CDF 0006              		MOVEM.L	(SP)+,D1-D2
025C2   4E75                   		RTS
025C4
025C4                          	* ----------------------
025C4                          	* GETMOUSE
025C4                          	* ----------------------
025C4
025C4                          	* GET MOUSE INFO, RETURN D0.W/D1.W = ROW/COL, D2.W = BUTTON FLAGS
025C4
025C4                          	GETMOUSE
025C4                          		SAVEREGS
025C8   4EBA 0000              		JSR	opMouseInfo
025CC   302D 0000              		MOVE.W	ymouse,D0
025D0   322D 0000              		MOVE.W	xmouse,D1
025D4   342D 0000              		MOVE.W	bmouse,D2
025D8                          		RESTREGS
025DC   4E75                   		RTS
025DE
025DE                          	* ----------------------
025DE                          	* OUTCHR
025DE                          	* ----------------------
025DE
025DE                          	* OUTPUT THE CHAR (OR CR) IN D0.B  (SCROLLING IF NECESSARY)
025DE
025DE   0C00 000D              	OUTCHR	CMPI.B	#13,D0		* [DON'T PAUSE AT FINISH JUST FOR CR'S]
025E2   6704            025E8  		BEQ.S	TTYOUT
025E4   426E FEF0              		CLR.W	INLAST(A6)	* CURRENT I/O IS OUTPUT
025E8
025E8                          	* IF CHAR = BS, THE PREVIOUS CHAR IS NOW PASSED IN THE HIGH BYTE
025E8
025E8                          	TTYOUT	SAVEREGS
025EC   3200                   		MOVE.W	D0,D1
025EE   0C01 0008              		CMPI.B	#DELCH1,D1	* BS?
025F2   6704            025F8  		BEQ.S	TTYOX1		* YES
025F4   7200                   		MOVEQ	#0,D1
025F6   1200                   		MOVE.B	D0,D1		* OTHERWISE, CLEAR HIGH BYTE
025F8
025F8   0C01 000D              	TTYOX1	CMPI.B	#13,D1		* IS THIS A CR?
025FC   6604            02602  		BNE.S	TTYOX2
025FE   6100 000E       0260E  		BSR	CRCHECK		* YES, CHECK FOR POSSIBLE INTERRUPT (XZIP)
02602                          	    IF D3BUG THEN
02602                          	    ENDIF
02602
02602   3F01                   	TTYOX2	MOVE.W	D1,-(SP)
02604   4EBA 0000              		JSR	CharOut
02608                          	    IF D3BUG THEN
02608                          	    ENDIF
02608                          		RESTREGS
0260C   4E75                   		RTS
0260E
0260E                          	* ----------------------
0260E                          	* CRCHECK
0260E                          	* ----------------------
0260E
0260E                          	* XZIP: WE'RE ABOUT TO OUTPUT A CR; CHECK FOR A SPECIAL INTERRUPT
0260E
0260E                          	CRCHECK
0260E                          	* XZIP: CHECK LOWCORE GLOBALS  [LEFT IN FOR BACK COMPATIBILITY (YZIPTEST)]
0260E G 206E FFA8              		MOVE.L	BUFFER(A6),A0
02612   2008                   		MOVE.L	A0,D0		* VALID? (MIGHT BE AN INIT ERROR)
02614   6746            0265C  		BEQ.S	CRCHX9
02616   4A68 0030              		TST.W	PCRCNT(A0)	* CR COUNTER ACTIVE?
0261A   670C            02628  		BEQ.S	CRCHX2		* NO
0261C   5368 0030              		SUBQ.W	#1,PCRCNT(A0)	* YES, DECREMENT IT; REACHED ZERO?
02620   663A            0265C  		BNE.S	CRCHX9		* NO
02622   3028 0032              		MOVE.W	PCRFUNC(A0),D0	* YES: FUNCTION TO CALL
02626   6018            02640  		BRA.S	CRCHX4
02628
02628                          	* YZIP: CHECK CURRENT WINDOW RECORD
02628 G 206E FF14              	CRCHX2	MOVE.L	CURWP(A6),A0
0262C   2008                   		MOVE.L	A0,D0		* VALID? (MIGHT BE AN INIT ERROR)
0262E   672C            0265C  		BEQ.S	CRCHX9
02630   4A68 0012              		TST.W	WCRCNT(A0)	* CR COUNTER ACTIVE?
02634   6726            0265C  		BEQ.S	CRCHX9		* NO
02636   5368 0012              		SUBQ.W	#1,WCRCNT(A0)	* YES, DECREMENT IT; REACHED ZERO?

0263A   6620            0265C  		BNE.S	CRCHX9		* NO
0263C   3028 0010              		MOVE.W	WCRINT(A0),D0	* YES: FUNCTION TO CALL
02640
02640                          	* AN INTERRUPT IS REQUESTED; INTERNALLY CALL THE INTERRUPT FUNCTION.
02640
02640                          	* Problem: register A4, dedicated to the game SP, is needed for this call
02640                          	* but is NOT currently valid.  That's because some of the I/O handlers
02640                          	* "borrow" it, assuming that such an value would never be needed during I/O.
02640                          	* [May be a good reason to avoid dedicating any other registers.]
02640
02640   2F0C                   	CRCHX4	MOVE.L	A4,-(SP)
02642   3F2E FF5A              		MOVE.W	VOBUFF(A6),-(SP)
02646   426E FF5A              		CLR.W	VOBUFF(A6)	* MAKE SURE BUFFERING OFF (NOT RE-ENTRANT!)
0264A
0264A G 286E FFBE              		MOVE.L	STKBOT(A6),A4	* FAKE A SMALL GAME STACK
0264E   D8FC 0064              		ADDA.W	#100,A4		* AT THE BOTTOM OF THE REAL ONE
02652   6100 F186       017DA  		BSR	INCALL		* AND HANDLE THE INTERRUPT
02656   3D5F FF5A              		MOVE.W	(SP)+,VOBUFF(A6)
0265A G 285F                   		MOVE.L	(SP)+,A4
0265C   4E75                   	CRCHX9	RTS
0265E
0265E                          	* ----------------------
0265E                          	* NXTLIN
0265E                          	* ----------------------
0265E
0265E                          	* CHECK FOR END-OF-PAGE CONDITION
0265E
0265E   48E7 7000              	NXTLIN	MOVEM.L	D1-D3,-(SP)
02662 G 206E FF14              		MOVE.L	CURWP(A6),A0
02666   3028 0004              		MOVE.W	WYSIZE(A0),D0	* VERTICAL WINDOW SIZE
0266A   7400                   		MOVEQ	#0,D2
0266C   1428 001A              		MOVE.B	WFONTYX(A0),D2	* VERTICAL LINE SIZE
02670
02670                          	* ALGORITHM: IF (WSIZ-LSIZ) - LCNT < LSIZ THEN PAUSE, WRITE [MORE]
02670
02670   9042                   		SUB.W	D2,D0		* RESERVE ONE LINE FOR [MORE] ITSELF
02672                          	***	SUBQ.W	#1,D0
02672   6F50            026C4  		BLE.S	NXTLX6		* DEGENERATE WINDOW (0+ LINES), DON'T PAUSE
02674   B042                   		CMP.W	D2,D0
02676   6D4C            026C4  		BLT.S	NXTLX6		* TINY WINDOW (1+ LINES), SKIP ALSO ("SHOGUN")
02678
02678   9068 001E              		SUB.W	WLCNT(A0),D0
0267C   B042                   		CMP.W	D2,D0		* PAGE FULL YET?
0267E   6C44            026C4  		BGE.S	NXTLX6		* NO, EXIT
02680
02680                          	***	MOVE.W	_v_italic,-(SP)	* SAVE ITALICS STATUS HERE
02680                          	***	TST.W	(SP)		* CURRENTLY IN ITALIC MODE?
02680                          	***	BEQ.S	NXTLX1		* NO
02680                          	***	CLR.L	-(SP)		* YES, SWITCH TO NORMAL FOR [MORE]
02680                          	***	JSR	_highlight	* 0 NORMAL, 4 ITALIC
02680                          	***	ADDQ.L	#4,SP
02680                          	*** NXTLX1
02680
02680   6100 FC2A       022AC  		BSR	GETCURS1	*   [DON'T TRY TO FLUSH BUFFER!]
02684   48A7 C000              		MOVEM.W	D0-D1,-(SP)	* REMEMBER INITIAL POSITION
02688
02688   41ED 02D7              		LEA	MSGMOR,A0	* DISPLAY A PROMPT (NO CR)
0268C   7006                   		MOVEQ	#6,D0
0268E   6100 003A       026CA  		BSR	PRINT		* WRITE DIRECTLY TO SCREEN
002D7                          	    DATA
002D7   5B4D4F52455D 0         	MSGMOR	DC.B	'[MORE]',0
02692                          	    CODE
02692
02692   362E FEF2              		MOVE.W	MSWIND(A6),D3	* SAVE THIS TEMPORARILY
02696   3D7C FFFF FEF2         		MOVE.W	#-1,MSWIND(A6)	* ENSURE THAT MOUSECLICKS UNPAUSE US, TOO
0269C   6100 FF00       0259E  		BSR	TTYIN		* WAIT FOR A KEY, NO ECHO
026A0   3D43 FEF2              		MOVE.W	D3,MSWIND(A6)
026A4
026A4                          	*	MOVEQ	#6,D1		* PROMPT LENGTH
026A4                          	*NXTLX2	MOVEQ	#8,D0
026A4                          	*	BSR	TTYOUT		* BACKUP CURSOR  >> ASSUMES MONOFONT <<<
026A4                          	*	SUBQ.W	#1,D1
026A4                          	*	BNE.S	NXTLX2
026A4
026A4   6100 FC06       022AC  		BSR	GETCURS1

026A8   3601                   		MOVE.W	D1,D3		* "END-OF-MORE" COL [RELATIVE]
026AA   4C9F 0003              		MOVEM.W	(SP)+,D0-D1	* BEGINNING COL
026AE   9641                   		SUB.W	D1,D3
026B0   6100 FBBC       0226E  		BSR	SETCURS		* RESTORE INITIAL POSITION
026B4
026B4   3203                   		MOVE.W	D3,D1		* END - BEG = LEN
026B6                          	*	MOVEQ	#-1,D1
026B6   70FF                   		MOVEQ	#-1,D0		* FROM CURSOR ...
026B8   6100 FC5A       02314  		BSR	MDERASE		* ERASE THE PROMPT
026BC
026BC                          	***	TST.W	(SP)		* FORMERLY IN ITALICS MODE?
026BC                          	***	BEQ.S	NXTLX4		* NO
026BC                          	***	MOVEQ	#4,D0		* YES, RESUME
026BC                          	***	MOVE.L	D0,-(SP)
026BC                          	***	JSR	_highlight	* 0 NORMAL, 4 ITALIC
026BC                          	***	ADDQ.L	#4,SP
026BC                          	*** NXTLX4
026BC
026BC G 206E FF14              		MOVE.L	CURWP(A6),A0
026C0   3142 001E              		MOVE.W	D2,WLCNT(A0)	* RESET COUNTER, ALLOWING ONE OVERLAP LINE
026C4                          	***	MOVE.W	#1,WLCNT(A0)
026C4   4CDF 000E              	NXTLX6	MOVEM.L	(SP)+,D1-D3
026C8   4E75                   		RTS
026CA
026CA                          	* ----------------------
026CA                          	* PRINT
026CA                          	* ----------------------
026CA
026CA                          	* OUTPUT A STRING, POINTER IN A0, LENGTH IN D0.W
026CA
026CA   426E FEF0              	PRINT	CLR.W	INLAST(A6)	* CURRENT I/O IS OUTPUT
026CE   4A40                   		TST.W	D0
026D0   6710            026E2  		BEQ.S	PRINTX1		* SKIP OUT IF NULL
026D2                          		SAVEREGS
026D6   2F08                   		MOVE.L	A0,-(SP)	* PASS THE STRING POINTER
026D8   3F00                   		MOVE.W	D0,-(SP)	* AND LENGTH
026DA   4EBA 0000              		JSR	LineOut
026DE                          		RESTREGS
026E2   4E75                   	PRINTX1	RTS
026E4
026E4                          	* ----------------------
026E4                          	* BUFOUT
026E4                          	* ----------------------
026E4
026E4                          	* OUTPUT THE LINE BUFFER, BEGINNING AND END IN A0, D0
026E4                          	*   FIRST CHECK FOR END-OF-SCREEN CONDITION (UNLESS IN WINDOW 1)
026E4
026E4   48E7 8080              	BUFOUT	MOVEM.L	D0/A0,-(SP)
026E8   7002                   		MOVEQ	#WFSCRL,D0
026EA   6100 E984       01070  		BSR	TSTWFLG		* SCROLLING ACTIVE?
026EE   6704            026F4  		BEQ.S	BUFUX1		* NO, SKIP THE SCREEN CHECK
026F0   6100 FF6C       0265E  		BSR	NXTLIN		* YES, PAUSE FOR [MORE] IF NECESSARY
026F4
026F4   4CDF 0101              	BUFUX1	MOVEM.L	(SP)+,D0/A0
026F8   9088                   		SUB.L	A0,D0		* CURRENT LENGTH OF BUFFER IN D0.W
026FA   6F02            026FE  		BLE.S	BUFUX2		* EXIT IF NOTHING
026FC   61CC            026CA  		BSR	PRINT		* OTHERWISE, DISPLAY IT
026FE   4E75                   	BUFUX2	RTS
02700
02700                          	* ----------------------
02700                          	* LINOUT
02700                          	* ----------------------
02700
02700                          	* OUTPUT THE LINE BUFFER THEN ADD A CR, BEGINNING AND END IN A0, D0
02700                          	*   ALSO UPDATE THE CUMULATIVE LINE COUNTER
02700
02700   61E2            026E4  	LINOUT	BSR	BUFOUT		* DISPLAY IT
02702   700D                   		MOVEQ	#13,D0
02704   6100 FED8       025DE  		BSR	OUTCHR		* AND TACK ON A CR
02708
02708   7002                   		MOVEQ	#WFSCRL,D0
0270A   6100 E964       01070  		BSR	TSTWFLG		* SCROLLING ACTIVE?
0270E   670E            0271E  		BEQ.S	LINOX1		* NO
02710
02710 G 206E FF14              		MOVE.L	CURWP(A6),A0	* YES, UPDATE THE [MORE] COUNTER

02714   7000                   		MOVEQ	#0,D0
02716   1028 001A              		MOVE.B	WFONTYX(A0),D0	* VERTICAL LINE SIZE
0271A   D168 001E              		ADD.W	D0,WLCNT(A0)
0271E                          	***	ADDQ.W	#1,WLCNT(A0)
0271E   4E75                   	LINOX1	RTS
02720
02720

02720                          	*----------------------------------------------------------------------------
02720                          	* ZIP MESSAGES
02720                          	*----------------------------------------------------------------------------
02720
02720                          	* ----------------------
02720                          	* OUTMSG
02720                          	* ----------------------
02720
02720                          	* OUTPUT AN ASCIZ MESSAGE, POINTER IN A0
02720
02720   2F09                   	OUTMSG0 MOVE.L	A1,-(SP)
02722 G 2248                   		MOVE.L  A0,A1		* STRING POINTER
02724
02724   4240                   	OUTMX1	CLR.W	D0
02726   1019                   		MOVE.B  (A1)+,D0	* GET NEXT CHAR, END OF STRING?
02728   6706            02730  		BEQ.S	OUTMX2		* YES
0272A
0272A   6100 F858       01F84  		BSR	PUTCHR		* NO, DISPLAY/QUEUE IT
0272E   60F4            02724  		BRA	OUTMX1
02730
02730   4A6E FF5A              	OUTMX2	TST.W	VOBUFF(A6)	* ARE WE BUFFERING OUTPUT?
02734   6704            0273A  		BEQ.S	OUTMX3		* NO
02736   6100 F8BE       01FF6  		BSR	PUTLIN		* YES, EMPTY THE BUFFER NOW
0273A
0273A G 225F                   	OUTMX3	MOVE.L	(SP)+,A1
0273C   4E75                   		RTS
0273E
0273E                          	* OUTPUT AN ASCIZ MESSAGE, POINTER IN A0 (NULL IF NONE)
0273E                          	*   THEN APPEND A CR
0273E
0273E   2008                   	OUTMSG  MOVE.L	A0,D0		* ANY MESSAGE?
02740   6702            02744  		BEQ.S	OUTMX9		* NO, JUST A CR
02742   61DC            02720  		BSR	OUTMSG0		* YES, OUTPUT THE STRING
02744   6000 F83C       01F82  	OUTMX9	BRA	PUTNEW
02748
02748                          	* ----------------------
02748                          	* ZWARN
02748                          	* ----------------------
02748
02748                          	* PRINT AN INTERPRETER WARNING, A0 -> MESSAGE
02748
02748   2F08                   	ZWARN	MOVE.L	A0,-(SP)
0274A   6100 F836       01F82  		BSR	PUTNEW		* CR
0274E   41ED 02DE              		LEA	MSGZWR,A0
02752   61CC            02720  		BSR	OUTMSG0		* MESSAGE HEADER
02754
002DE                          	    DATA
002DE   2A 2A 2A               	MSGZWR	DC.B	$2A,$2A,$2A	* [***]
002E1   20496E74657270         		DC.B	' Interpreter warning: ',0
02754                          	    CODE
02754
02754 G 205F                   		MOVE.L	(SP)+,A0	* MESSAGE
02756   60E6            0273E  		BRA	OUTMSG
02758
02758                          	* ----------------------
02758                          	* FATAL
02758                          	* ----------------------
02758
02758                          	* PRINT A FATAL ERROR HEADER, CODE NUMBER AND MESSAGE (LAST TWO ARE OPTIONALS)
02758                          	*   ERROR CODE IN D0.W, STRING IN A0, ZERO MEANS NONE
02758
02758 G 2248                   	FATAL	MOVE.L  A0,A1		* [TRASHES THESE REGS, BUT DOESN'T MATTER]
0275A   3200                   		MOVE.W  D0,D1
0275C   6100 F824       01F82  		BSR	PUTNEW		* NEW LINE
02760
02760   41ED 02F8              		LEA	MSGFTL,A0	* PRINT A STANDARD ERROR HEADER, NO CR
02764   61BA            02720  		BSR	OUTMSG0		* 'Internal Error '
02766
002F8                          	    DATA
002F8   496E7465726E61         	MSGFTL	DC.B	'Internal Error ',0
02766                          	    CODE
02766
02766   4A41                   		TST.W	D1		* GOT A NUMBER?
02768   670E            02778  		BEQ.S	FATLX1		* NO
0276A   103C 0023              		MOVE.B	#'#',D0		* YES, PRINT A PREFIX

0276E   6100 F814       01F84  		BSR	PUTCHR
02772   3001                   		MOVE.W  D1,D0		* PRINT THE ERROR NUMBER
02774   6100 E826       00F9C  		BSR	OPPRNN
02778
02778   6100 F808       01F82  	FATLX1	BSR	PUTNEW		* ANOTHER CR
0277C   2009                   		MOVE.L  A1,D0		* GOT A MESSAGE?
0277E   6704            02784  		BEQ.S	FATLX2
02780 G 2049                   		MOVE.L  A1,A0		* YES, DISPLAY IT
02782   61BA            0273E  		BSR	OUTMSG
02784   6000 FCF4       0247A  	FATLX2	BRA	FINISH		* WAIT FOR FINAL KEY, AND EXIT
02788
02788                          	* --------------------------------------------------------------
02788                          	* SCRIPTING STUFF
02788                          	* --------------------------------------------------------------
02788
02788                          	* ----------------------
02788                          	* SCRINIT
02788                          	* ----------------------
02788
02788                          	* SETUP SCRIPTING, FLAG IN D0: 1=START, 0=STOP
02788
02788                          	SCRINIT	SAVEREGS
0278C   1F00                   		MOVE.B	D0,-(SP)	* [PASCAL: PASS BOOL @ODD ADDR]
0278E   4EBA 0000              		JSR	PrInit
02792                          		RESTREGS
02796   4E75                   		RTS
02798
02798                          	* ----------------------
02798                          	* SCROUT
02798                          	* ----------------------
02798
02798                          	* SCRIPT OUT A LINE, START IN A0, END IN D0, THEN TACK ON A CR/LF
02798
02798                          	SCROUT  SAVEREGS
0279C   9088                   		SUB.L	A0,D0		* THIS IS THE LENGTH
0279E   2F08                   		MOVE.L	A0,-(SP)
027A0   3F00                   		MOVE.W	D0,-(SP)
027A2   4EBA 0000              		JSR	PrLine		* ALL HANDLED IN PASCAL
027A6                          		RESTREGS
027AA   4E75                   		RTS
027AC
027AC                          	* --------------------------------------------------------------
027AC                          	* *** PURE HACKERY ***
027AC                          	* --------------------------------------------------------------
027AC
027AC                          	* THIS ROUTINE EXISTS TO ALLOW MACINTOSH USERS TO LAUNCH DIRECTLY INTO
027AC                          	*   A SAVED GAME  (BY DOUBLE-CLICKING IT),  SKIPPING THE NORMAL GAME
027AC                          	*   OPENING.  IT CAN FUNCTION AT MOST ONCE.
027AC
027AC                          	* WE USED TO FORCE A "VERSION" DISPLAY (BY FAKING INPUT).  THIS PREVENTED
027AC                          	*   AN OPENING SCREEN THAT (IN SOME ZIP GAMES) SAID NOTHING BUT "OK".  BUT
027AC                          	*   SOME LATER GAMES PRINT LENGTHY DESCS, AND A "VERSION" LOOKS BAD.
027AC
027AC   202E FEDA              	SYSIN2	MOVE.L	APPARM(A6),D0	* GET THE "FINDER PARAMETERS" HANDLE
027B0   6720            027D2  		BEQ.S	SS2X1		* EXIT IF BEEN HERE ALREADY (HANDLE IS NULL)
027B2   42AE FEDA              		CLR.L	APPARM(A6)	* MARK HANDLE, SO THIS CODE ONLY RUNS ONCE!
027B6
027B6 G 2040                   		MOVE.L	D0,A0
027B8 G 2050                   		MOVE.L	(A0),A0 	* EXTRACT THE POINTER
027BA   4A68 0002              		TST.W	2(A0)		* WAS ZIP LAUNCHED VIA A SAVED GAME?
027BE   6712            027D2  		BEQ.S	SS2X1		* NO, NORMAL LAUNCH, JUST MARK THE HANDLE
027C0   6100 0012       027D4  		BSR	FNDRSF		* COPY FINDER INFO INTO SF REPLY RECORD
027C4
027C4 G 206E FFA8              		MOVE.L	BUFFER(A6),A0
027C8   08E8 0002 0011         		BSET	#FSTAT,PFLAGS+1(A0)	* REQUEST STATUS LINE BE REDRAWN
027CE
027CE                          	* WARNING: HACKING (FOR TIMEOUTS) IN RES1 MEANS THAT CONTROL MAY NEVER
027CE                          	* RETURN HERE (IT JUMPS TO DISPATCH).  DON'T ADD CODE BEYOND THIS POINT!.
027CE
027CE   6100 F254       01A24  		BSR	RES1		* DO A SPECIAL RESTORE, SKIPPING NORMAL DIALOG
027D2   4E75                   	SS2X1	RTS
027D4
027D4                          	* GIVEN A0 -> "FINDER PARAMETERS BLOCK" (AS FROM GetAppParm),
027D4                          	*   COPY THE SAVED GAME INFO (NAME AND VOL) INTO OUR RESTORE VARS
027D4                          	*   (USE ONLY FIRST GAME, IF MORE THAN ONE IS INDICATED)

027D4
027D4   48E7 4060              	FNDRSF	MOVEM.L D1/A1-A2,-(SP)
027D8 G 2448                   		MOVE.L	A0,A2		* PARAMS PTR HERE
027DA
027DA   41EA 000C              		LEA	12(A2),A0	* COPY FILE NAME
027DE   43ED 0000              		LEA	filename,A1
027E2   7001                   		MOVEQ	#1,D0		* ALLOW FOR LENGTH BYTE
027E4   D010                   		ADD.B	(A0),D0		* IN FIRST BYTE  [MAC PASCAL]
027E6   7240                   		MOVEQ	#64,D1		* MAX LEN  (OF filename)
027E8   6100 DB7C       00366  		BSR	COPYS
027EC
027EC   3B6A 0004 0000         		MOVE.W	4(A2),filevol	* AND COPY VOLUME REFNUM
027F2   4CDF 0602              		MOVEM.L (SP)+,D1/A1-A2
027F6   4E75                   		RTS
027F8
027F8

027F8                          	* ---------------------------------------------------------------------------
027F8                          	* DISK I/O ROUTINES
027F8                          	* ---------------------------------------------------------------------------
027F8
027F8                          	* ----------------------
027F8                          	* OPNGAM
027F8                          	* ----------------------
027F8
027F8                          	* OPEN THE GAME FILE, STORE REFNUM, RETURN FLAGS
027F8
027F8   7000                   	OPNGAM	MOVEQ	#0,D0
027FA   4E75                   		RTS			* [MAC: NOW DONE IN MACINIT]
027FC
027FC                          	* CLOSE THE GAME FILE, RETURN FLAGS
027FC
027FC   7000                   	CLSGAM	MOVEQ	#0,D0
027FE   4E75                   		RTS			* [MAC: NOW IN FINISH]
02800
02800                          	* ----------------------
02800                          	* GETBLK
02800                          	* ----------------------
02800
02800                          	* GET A GAME FILE BLOCK, BLOCK NUMBER IN D0, CORE TARGET LOCATION IN A0
02800
02800   48E7 4000              	GETBLK  MOVEM.L	D1,-(SP)
02804   7201                   		MOVEQ	#1,D1		* ONE BLOCK
02806   6100 0008       02810  		BSR	GTBLKS
0280A   4CDF 0002              		MOVEM.L	(SP)+,D1	* (DOESN'T ALTER FLAGS)
0280E   4E75                   		RTS
02810
02810                          	* GET A SERIES OF GAME FILE BLOCKS
02810                          	* FIRST BLOCK NUMBER IN D0, CORE TARGET LOCATION IN A0, TOTAL BLOCKS IN D1
02810
02810                          	GTBLKS  SAVEREGS
02814   6100 DB9C       003B2  		BSR	BLKBYT		* CONVERT BLOCKS TO BYTES
02818   C340                   		EXG	D1,D0
0281A   6100 DB96       003B2  		BSR	BLKBYT
0281E   C340                   		EXG	D1,D0
02820                          		RESWORD
02822   3F2E FEEC              		MOVE.W	GAMFIL(A6),-(SP)
02826   2F00                   		MOVE.L	D0,-(SP)	* OFFSET IN BYTES
02828   2F01                   		MOVE.L	D1,-(SP)	* LENGTH IN BYTES
0282A   2F08                   		MOVE.L	A0,-(SP)	* BUFFER
0282C   4EBA 0000              		JSR	ReadFile
02830                          		POPWORD			* ERROR ON READ?
02832   6606            0283A  		BNE.S	GTBKX2		* YES, FAIL
02834                          	GTBKX1	RESTREGS
02838   4E75                   		RTS
0283A
0283A                          	*	TST.W	DSKERR(A6)	* BUT WERE WE ASKED TO RETURN WITH FLAGS?
0283A                          	*	BNE	GTBKX1		* YES
0283A
0283A   41ED 0308              	GTBKX2	LEA	MSGREA,A0	* ERROR CODE IN D0
0283E   6000 FF18       02758  		BRA	FATAL		* 'Story file read error.'
02842
00308                          	    DATA
00308   53746F72792066         	MSGREA	DC.B	'Story file read error.',0
02842                          	    CODE
02842
02842

02842                          	* --------------------------------------------------------------------------
02842                          	* SAVE/RESTORE -- DISK I/O ROUTINES
02842                          	* --------------------------------------------------------------------------
02842
02842                          	* ----------------------
02842                          	* DKSWAP
02842                          	* ----------------------
02842
02842                          	* PRELIMINARY DIALOG FOR SAVE/RESTORE
02842                          	*   PROMPT USER TO SWAP DISKS AND IDENTIFY DRIVE BEING USED
02842                          	*   RETURN LETTER IN D0, ZERO FOR DEFAULT
02842
02842                          	* >>> THIS FUNCTION NOW HANDLED WITHIN FILE-SELECT CALL <<<
02842
02842                          	* ----------------------
02842                          	* DUPNAM
02842                          	* ----------------------
02842
02842                          	* DUPLICATE NAME CHECK/DIALOG (FOR SAVES ONLY)
02842                          	*   CHECK FOR FILENAME CONFLICT, IF SO, PROMPT USER FOR INSTRUCTIONS
02842                          	*   RETURN ZERO TO PROCEED NORMALLY, OTHERWISE ABORT
02842
02842   7000                   	DUPNAM	MOVEQ	#0,D0		* [MAC: THIS FUNC HANDLED BY OS (FSEL)]
02844   4E75                   		RTS
02846
02846                          	*	SAVEREGS
02846                          	*	RESWORD
02846                          	*	JSR	ExistFile
02846                          	*	POPWORD
02846                          	*	MOVE.W	D0,D1		* RESULT
02846                          	*	BEQ.S	DUPX3		* ZERO MEANS NONE
02846                          	*
02846                          	*DUPX1	LEA	MSGDUP,A0
02846                          	*	BSR	OUTMSG0		* PROMPT, DON'T ADD A CR
02846                          	*
02846                          	*    DATA
02846                          	*MSGDUP	DC.B	'You are about to write over an existing file.  '
02846                          	*	DC.B	'Proceed? (Y/N) ',0
02846                          	*    CODE
02846                          	*
02846                          	*	BSR	TTYIN		* GET A CHAR
02846                          	*	CLR.W	D1		* ASSUME A NORMAL SAVE
02846                          	*
02846                          	*	CMPI.B	#'Y',D0		* PROCEED?
02846                          	*	BEQ.S	DUPX2		* YES
02846                          	*	CMPI.B	#'y',D0
02846                          	*	BEQ.S	DUPX2		* YES
02846                          	*
02846                          	*	MOVEQ	#1,D1		* NO, ABORT (ANY KEY BESIDES 'Y')
02846                          	*	MOVE.B	#'N',D0
02846                          	*DUPX2	BSR	PUTCHR
02846                          	*	BSR	PUTNEW		* FOLLOW WITH A CR
02846                          	*
02846                          	*DUPX3	MOVE.W	D1,D0		* RETURN FLAGS FOR RESULT
02846                          	*	RESTREGS
02846                          	*	RTS
02846
02846                          	* ----------------------
02846                          	* GETSFL
02846                          	* ----------------------
02846
02846                          	* POLL USER FOR A FILE NAME, DRIVE, DIRECTORY, ETC  (LEAVE IN GLOBAL)
02846                          	*   GIVEN:
02846                          	*	D0.W = SET IF SAVE, 0 IF RESTORE,
02846                          	*	D1.W = SET IF PARTIAL, 0 IF NORMAL,
02846                          	*	A0 -> XZIP "SUGGESTED" NAME  (BYTE 0 IS LEN)
02846                          	*   RETURN WITH FLAGS SET, ZERO IF NO ERROR
02846
02846   48E7 3040              	GETSFL  MOVEM.L	D2-D3/A1,-(SP)
0284A   3400                   		MOVE.W	D0,D2		* REPOSITION THESE VALS
0284C   3601                   		MOVE.W	D1,D3
0284E
0284E   4A43                   		TST.W	D3
02850   670E            02860  		BEQ.S	GTSFX2		* IF NORMAL, NO XZIP NAME
02852   7001                   		MOVEQ	#1,D0

02854   D010                   		ADD.B	(A0),D0
02856   720D                   		MOVEQ	#12+1,D1	* MAX LEN  (ST/PC DOS)
02858   43ED 0000              		LEA	filename,A1
0285C   6100 DB08       00366  		BSR	COPYS		* IF PARTIAL, SUGGEST NAME TO USER
02860
02860                          	GTSFX2	SAVEREGS
02864                          		RESWORD
02866   1F03                   		MOVE.B	D3,-(SP)	* NORMAL/PARTIAL [PASCAL: PASS BOOL @ODD ADDR]
02868   1F02                   		MOVE.B	D2,-(SP)	* SAVE/RESTORE
0286A   4EBA 0000              		JSR	FileSelect
0286E                          		POPWORD
02870                          		RESTREGS
02874
02874   3200                   		MOVE.W	D0,D1		* FSEL RESULT, NON-ZERO IF CANCEL OR ERROR
02876   660C            02884  		BNE.S	GTSFX8
02878   6100 F812       0208C  		BSR	SCRNAM		* IF OK, OUTPUT FILENAME TO TRANSCRIPT
0287C
0287C   4A42                   		TST.W	D2		* WAS THIS A SAVE?
0287E   6704            02884  		BEQ.S	GTSFX8		* NO
02880   61C0            02842  		BSR	DUPNAM		* YES, CHECK FOR DUPLICATE FILENAME
02882   3200                   		MOVE.W	D0,D1		* NON-ZERO IF USER SAYS ABORT
02884
02884   4CDF 020C              	GTSFX8	MOVEM.L	(SP)+,D2-D3/A1
02888   4A41                   		TST.W	D1		* FINAL RESULT, RETURN FLAGS
0288A   4E75                   		RTS
0288C
0288C                          	* ----------------------
0288C                          	* NEWSFL
0288C                          	* ----------------------
0288C
0288C                          	* CREATE (IF NECESSARY) AND OPEN A SAVE FILE, USING GLOBAL FILENAME
0288C                          	*   RETURN WITH FLAGS SET, ZERO IF NO ERROR
0288C
0288C                          	NEWSFL  SAVEREGS
02890                          		RESWORD
02892   486E FEEA              		PEA	SAVFIL(A6)	* RETURN CHANNEL HERE
02896   4EBA 0000              		JSR	CreateFile
0289A                          		POPWORD
0289C                          		RESTREGS
028A0   6708            028AA  		BEQ.S	NEWSX2		* ZERO MEANS NO ERROR
028A2
028A2                          	*	CMPI.W  #-44,D0		* ST: DISK IS WRITE-PROTECTED? (SAY SO)
028A2                          	*	CMPI.W  #-48,D0		* ST: NAME EXISTS ALREADY? (IGNORE)
028A2
028A2   3F00                   		MOVE.W	D0,-(SP)
028A4   6100 0092       02938  		BSR	WPRCHK		* IF WRITE-PROTECT ERROR, INFORM USER
028A8   301F                   		MOVE.W	(SP)+,D0
028AA
028AA   4E75                   	NEWSX2	RTS			* RETURN FLAGS
028AC
028AC                          	* ----------------------
028AC                          	* OPNSFL
028AC                          	* ----------------------
028AC
028AC                          	* OPEN A (RESTORE) FILE, USING GLOBAL FILENAME, LEAVE CHANNEL IN SAVFIL(A6)
028AC                          	*   RETURN WITH FLAGS, ZERO IF NO ERROR
028AC
028AC                          	OPNSFL  SAVEREGS
028B0                          		RESWORD
028B2   486E FEEA              		PEA	SAVFIL(A6)	* RETURN CHANNEL HERE
028B6   4EBA 0000              		JSR	OpenFile
028BA                          		POPWORD			* ZERO MEANS NO ERROR
028BC                          		RESTREGS
028C0   4E75                   		RTS
028C2
028C2                          	* ----------------------
028C2                          	* GTSBKS, SFREAD
028C2                          	* ----------------------
028C2
028C2                          	* GET A SERIES OF SAVE FILE BLOCKS
028C2                          	*   FIRST BLOCK NUMBER IN D0, # OF BLOCKS IN D1, CORE TARGET LOCATION IN A0
028C2                          	*   RETURN WITH FLAGS, NONZERO IF ERROR
028C2
028C2   6100 DAEE       003B2  	GTSBKS	BSR	BLKBYT		* CONVERT BLOCKS TO BYTES
028C6   C340                   		EXG	D1,D0

028C8   6100 DAE8       003B2  		BSR	BLKBYT
028CC   C340                   		EXG	D1,D0
028CE
028CE                          	* ENTER HERE: BYTE OFFSET IN D0, BYTE LENGTH IN D1
028CE                          	* RETURN FLAGS, >> ALSO D1 = ACTUAL BYTES READ <<
028CE
028CE                          	SFREAD	SAVEREGS
028D2                          		RESWORD
028D4   3F2E FEEA              		MOVE.W	SAVFIL(A6),-(SP)
028D8   2F00                   		MOVE.L	D0,-(SP)	* OFFSET IN BYTES
028DA   2F01                   		MOVE.L	D1,-(SP)	* LENGTH IN BYTES
028DC   2F08                   		MOVE.L	A0,-(SP)	* BUFFER POINTER
028DE   4EBA 0000              		JSR	ReadFile
028E2                          		POPWORD
028E4                          		RESTREGS
028E8   222D 0000              		MOVE.L	actlen,D1
028EC   4A40                   		TST.W	D0		* NONZERO MEANS ERROR
028EE   4E75                   		RTS
028F0
028F0                          	* ----------------------
028F0                          	* PTSBKS, SFWRIT
028F0                          	* ----------------------
028F0
028F0                          	* WRITE A SERIES OF SAVE FILE BLOCKS,
028F0                          	*   FIRST BLOCK OFFSET IN D0, NUMBER OF BLOCKS IN D1, CORE LOCATION IN A0,
028F0                          	*   RETURN WITH FLAGS, NONZERO IF ERROR
028F0
028F0   6100 DAC0       003B2  	PTSBKS	BSR	BLKBYT		* CONVERT BLOCKS TO BYTES
028F4   C340                   		EXG	D1,D0
028F6   6100 DABA       003B2  		BSR	BLKBYT
028FA   C340                   		EXG	D1,D0
028FC
028FC                          	* ENTER HERE: BYTE OFFSET IN D0, BYTE LENGTH IN D1
028FC                          	* RETURN FLAGS, >> ALSO D1 = ACTUAL BYTES READ <<
028FC
028FC                          	SFWRIT	SAVEREGS
02900                          		RESWORD
02902   3F2E FEEA              		MOVE.W	SAVFIL(A6),-(SP)
02906   2F00                   		MOVE.L	D0,-(SP)	* OFFSET IN BYTES
02908   2F01                   		MOVE.L	D1,-(SP)	* LENGTH IN BYTES
0290A   2F08                   		MOVE.L	A0,-(SP)	* BUFFER POINTER
0290C   4EBA 0000              		JSR	WriteFile
02910                          		POPWORD
02912                          		RESTREGS
02916
02916   3200                   		MOVE.W	D0,D1		* ANY ERROR?
02918   6714            0292E  		BEQ.S	PTSBX2		* NO
0291A
0291A   0C40 FFDE              		CMPI.W	#dskFulErr,D0	* Mac: DISK-FULL ERROR?
0291E   6706            02926  		BEQ.S	PTSBX1		* YES, INFORM USER
02920
02920   6100 0016       02938  		BSR	WPRCHK		* ALSO CHECK FOR WRITE-PROTECT ERROR
02924   6008            0292E  		BRA.S	PTSBX2
02926
02926   41ED 031F              	PTSBX1	LEA	MSGFUL,A0
0292A   6100 FE12       0273E  		BSR	OUTMSG		* 'Not enough room on disk.'
0292E
0031F                          	    DATA
0031F   4E6F7420656E6F         	MSGFUL	DC.B	'Not enough room on disk.',0
0292E                          	    CODE
0292E
0292E   3001                   	PTSBX2	MOVE.W	D1,D0
02930   222D 0000              		MOVE.L	actlen,D1	* COUNT
02934   4A40                   		TST.W	D0		* FLAGS, NONZERO MEANS ERROR
02936   4E75                   		RTS
02938
02938                          	* ----------------------
02938                          	* WPRCHK
02938                          	* ----------------------
02938
02938                          	* CHECK FOR DISK WRITE-PROTECT ERROR, GIVEN D0 = RESULT CODE
02938                          	*  (MAY BE CALLED DURING FILE CREATE /OR/ FILE WRITE)
02938
02938   0C40 FFD4              	WPRCHK	CMPI.W	#wPrErr,D0	* Mac: WRITE-PROTECT ERROR?
0293C   6608            02946  		BNE.S	WPRCX1

0293E
0293E   41ED 0338              		LEA	MSGWPR,A0	* INFORM USER
02942   6100 FDFA       0273E  		BSR	OUTMSG		* 'Disk is write-protected.'
02946   4E75                   	WPRCX1	RTS
02948
00338                          	    DATA
00338   4469736B206973         	MSGWPR	DC.B	'Disk is write-protected.',0
02948                          	    CODE
02948
02948                          	* ----------------------
02948                          	* CLSSFL
02948                          	* ----------------------
02948
02948                          	* CLOSE A SAVE FILE, CHANNEL IN SAVFIL(A6)
02948                          	*   RETURN WITH FLAGS SET, ZERO IF NO ERROR
02948
02948                          	CLSSFL  SAVEREGS
0294C                          		RESWORD
0294E   3F2E FEEA              		MOVE.W	SAVFIL(A6),-(SP)
02952   4EBA 0000              		JSR	CloseFile
02956                          		POPWORD			* NON-ZERO IF ERROR
02958                          		RESTREGS
0295C   4E75                   		RTS
0295E
0295E                          	* ----------------------
0295E                          	* DELSFL
0295E                          	* ----------------------
0295E
0295E                          	* DELETE A BAD SAVE FILE, MUST HAVE BEEN ALREADY CLOSED (OR NOT OPENED)
0295E                          	*   RETURN WITH FLAGS SET, ZERO IF NO ERROR
0295E
0295E                          	DELSFL  SAVEREGS
02962                          		RESWORD
02964   4EBA 0000              		JSR	DeleteFile
02968                          		POPWORD			* NON-ZERO IF ERROR
0296A                          		RESTREGS
0296E   4E75                   		RTS
02970
02970                          	* ----------------------
02970                          	* DEFOLD
02970                          	* ----------------------
02970
02970   4240                   	DEFOLD	CLR.W	D0		* RETRIEVE PREVIOUS DEFAULT NAMES
02972   6000 0004       02978  		BRA	DEFNX1
02976   7001                   	DEFNEW  MOVEQ	#1,D0		* UPDATE PREVIOUS DEFAULT NAMES
02978
02978                          	DEFNX1	SAVEREGS
0297C   1F00                   		MOVE.B	D0,-(SP)	* [PASCAL: PASS BOOL @ODD ADDR]
0297E   4EBA 0000              		JSR	NewDefault	* (COPIES SOME GLOBAL STRINGS)
02982                          		RESTREGS
02986   4E75                   		RTS
02988
02988                          	* ----------------------
02988                          	* CHKDSK, CHKDSK1
02988                          	* ----------------------
02988
02988                          	* [MAC: THIS CALL ISN'T NEEDED, SINCE THE OS DOES A GOOD JOB OF KEEPING
02988                          	* TRACK OF WHEN THE GAME DISK HAS BEEN EJECTED, AND ASKING FOR IT WHEN
02988                          	* NECESSARY.]
02988
02988                          	CHKDSK
02988                          	CHKDSK1
02988   4E75                   		RTS
0298A
0298A                          	    INCLUDE	'MX4.a'
0298A

0298A                          	* ----------------------------------------------------------------------------
0298A                          	* 68000 CALLS FROM PASCAL/C 	(XDEFS REQUIRED)
0298A                          	* ----------------------------------------------------------------------------
0298A
00351                          	    DATA
00352   0000 0000              	ZVARS	DC.L	0	* CORRECT A6 STORED HERE, MUST RESTORE IF NEEDED
0298A                          	    CODE
0298A
0298A                          	* PROCEDURE OutBufLen (charCount: INTEGER) -- ADJUST MAC FOLDING
0298A                          	* RESET ENDBUF (WHEN NEXT EMPTIED, TO PREVENT BUGS)
0298A
0298A                          	* OUTBUFLEN
0298A                          	*	MOVE.L  ZVARS,A0	   * GET ZIP'S VALUE OF A6
0298A                          	*	MOVE.W	4(SP),CURSIZ
0298A                          	*	MOVE.L  D0,MACBUF(A0)
0298A                          	*	RTS
0298A
0298A                          	* ----------------------------------------------------------------------------
0298A                          	* FAST MEMORY ROUTINES
0298A                          	* USED FOR ST SCROLLING, ALSO FOR ISAVE/IRESTORE
0298A                          	* ----------------------------------------------------------------------------
0298A
0298A                          	* ----------------------
0298A                          	* _mov_mem, MOVMEM
0298A                          	* ----------------------
0298A
0298A                          	* THIS ROUTINE PERFORMS A FAST BLOCKMOVE.  ASSUMPTIONS ARE:
0298A                          	*    () COPY MUST BE FROM HIGH TO LOW MEMORY IF IT OVERLAPS ("SCROLL UP")
0298A                          	*    () MAX LENGTH IS 256K (32K x 16), DUE TO USE OF "DBxx"
0298A
0298A   0000 0008              	MMSRC	EQU	8+0		* 8 = 4 (REG) + 4 (RTS)
0298A   0000 000C              	MMDEST	EQU	8+4
0298A   0000 0010              	MMLEN	EQU	8+8
0298A
0298A                          	_mov_mem
0298A   2F09                   		MOVE.L	A1,-(SP)
0298C G 206F 0008              		MOVE.L	MMSRC(SP),A0
02990 G 226F 000C              		MOVE.L	MMDEST(SP),A1
02994   202F 0010              		MOVE.L	MMLEN(SP),D0
02998   6704            0299E  		BEQ.S	MMX0		* ZERO LENGTH, EXIT
0299A   6100 0006       029A2  		BSR	MOVMEM
0299E G 225F                   	MMX0	MOVE.L	(SP)+,A1
029A0   4E75                   		RTS
029A2
029A2                          	* ALTERNATE ENTRY POINT (FOR 68K USERS), JUST TAKES ARGS IN REGS
029A2                          	* A0 -> SOURCE, A1 -> DEST, D0.L = LENGTH
029A2
029A2   2F01                   	MOVMEM	MOVE.L	D1,-(SP)
029A4   3208                   		MOVE.W	A0,D1		* CHECK FOR ODD-ALIGNED SRC ADDRESS
029A6   0241 0001              		ANDI.W	#1,D1
029AA   6622            029CE  		BNE.S	MMX3		* IF SO, MUST USE SLOWER CODE
029AC   3209                   		MOVE.W	A1,D1		* CHECK DEST ADDRESS, TOO
029AE   0241 0001              		ANDI.W	#1,D1
029B2   661A            029CE  		BNE.S	MMX3
029B4
029B4   2200                   		MOVE.L	D0,D1
029B6   E881                   		ASR.L	#4,D1		* DIVIDE BY 16: QUOTIENT HERE
029B8   6008            029C2  		BRA.S	MMX2		* ENTER LOOP AT DBRA
029BA
029BA                          	* PHASE 1 COPY -- MAXIMIZE SPEED
029BA
029BA   22D8                   	MMX1	MOVE.L	(A0)+,(A1)+	* COPY 16 BYTES ("UNROLL" FOUR ITERATIONS)
029BC   22D8                   		MOVE.L	(A0)+,(A1)+
029BE   22D8                   		MOVE.L	(A0)+,(A1)+
029C0   22D8                   		MOVE.L	(A0)+,(A1)+
029C2 G 51C9 FFF6       029BA  	MMX2	DBRA	D1,MMX1		* LOOP (32K IS MAX COUNT)
029C6
029C6   0280 0000 000F         		ANDI.L	#$0F,D0		* DIVIDE BY 16: REMAINDER
029CC   6706            029D4  		BEQ.S	MMX5		* FALL THROUGH IF ANYTHING LEFT
029CE
029CE                          	* PHASE 2 COPY -- HANDLE EXTRA BYTES OR ODD CASES
029CE
029CE   12D8                   	MMX3	MOVE.B	(A0)+,(A1)+	* COPY ONE BYTE
029D0   5380                   		SUBQ.L	#1,D0
029D2   66FA            029CE  		BNE.S	MMX3		* LOOP (NO MAX COUNT)

029D4
029D4   221F                   	MMX5	MOVE.L	(SP)+,D1	* DONE
029D6   4E75                   		RTS
029D8
029D8                          	* ----------------------
029D8                          	* _clr_mem
029D8                          	* ----------------------
029D8
029D8   0000 000C              	CMSRC	EQU	12+0		* 12 = 8 (REGS) + 4 (RTS)
029D8   0000 0010              	CMLEN	EQU	12+4
029D8
029D8                          	_clr_mem
029D8   48E7 4040              		MOVEM.L	D1/A1,-(SP)
029DC   202F 0010              		MOVE.L	CMLEN(SP),D0
029E0   672C            02A0E  		BEQ.S	CMX5		* ZERO, EXIT
029E2 G 206F 000C              		MOVE.L	CMSRC(SP),A0
029E6
029E6   3208                   		MOVE.W	A0,D1		* CHECK FOR ODD SRC ADDRESS
029E8   0241 0001              		ANDI.W	#1,D1
029EC   661A            02A08  		BNE.S	CMX3
029EE
029EE   2200                   		MOVE.L	D0,D1
029F0   E881                   		ASR.L	#4,D1		* DIVIDE BY 16: QUOTIENT
029F2   6008            029FC  		BRA.S	CMX2		* ENTER LOOP AT DBRA
029F4
029F4                          	* PHASE 1 "CLEAR" -- MAXIMIZE SPEED
029F4
029F4   4298                   	CMX1	CLR.L	(A0)+		* CLEAR 16 BYTES ("UNROLL" FOUR ITERATIONS)
029F6   4298                   		CLR.L	(A0)+
029F8   4298                   		CLR.L	(A0)+
029FA   4298                   		CLR.L	(A0)+
029FC G 51C9 FFF6       029F4  	CMX2	DBRA	D1,CMX1		* LOOP (32K IS MAXIMUM COUNT)
02A00
02A00   0280 0000 000F         		ANDI.L	#$0F,D0		* DIVIDE BY 16: REMAINDER
02A06   6706            02A0E  		BEQ.S	CMX5		* FALL THROUGH IF ANYTHING LEFT
02A08
02A08                          	* PHASE 2 "CLEAR" -- HANDLE EXTRA BYTES OR ODD CASES
02A08
02A08   4218                   	CMX3	CLR.B	(A0)+		* CLEAR ONE BYTE
02A0A   5380                   		SUBQ.L	#1,D0
02A0C   66FA            02A08  		BNE.S	CMX3		* LOOP (NO MAXIMUM COUNT)
02A0E
02A0E   4CDF 0202              	CMX5	MOVEM.L	(SP)+,D1/A1
02A12   4E75                   		RTS
02A14
02A14                          	* ----------------------
02A14                          	* SqzRow
02A14                          	* ----------------------
02A14
02A14                          	* >> DEAD SOON <<
02A14                          	* PROCEDURE SqzRow (src, dst: Ptr; len: INTEGER);
02A14
02A14                          	SqzRow
02A14   302F 0004              		MOVE.W	4(SP),D0	* LEN
02A18 G 226F 0006              		MOVE.L  6(SP),A1	* DST
02A1C G 206F 000A              		MOVE.L	10(SP),A0	* SRC
02A20
02A20                          	* SQZROW: SQUEEZE BYTES INTO NIBBLES, THROWING AWAY THE HIGH NIBBLES
02A20                          	* GIVEN A0 -> SRC, A1 -> DST, D0.W = COUNT
02A20
02A20   1218                   	SQRWX1	MOVE.B	(A0)+,D1	* GET FIRST LOW-NIBBLE
02A22   E949                   		LSL.W	#4,D1		* POSITION IT
02A24   0210 000F              		ANDI.B	#$0F,(A0)	* [MAKE SURE HIGH NIBBLE = 0]
02A28   8218                   		OR.B	(A0)+,D1	* GET SECOND LOW-NIBBLE
02A2A   12C1                   		MOVE.B	D1,(A1)+
02A2C
02A2C   5540                   		SUBQ.W	#2,D0		* 2 BYTES INTO 1
02A2E   6EF0            02A20  		BGT.S	SQRWX1
02A30
02A30 G 205F                   		MOVE.L	(SP)+,A0	* RETURN ADDR
02A32   DEFC 000A              		ADDA.W	#10,SP		* CLEANUP, PASCAL STYLE
02A36   4ED0                   		JMP	(A0)
02A38
02A38                          	* ----------------------
02A38                          	* FillCSpec

02A38                          	* ----------------------
02A38
02A38                          	* PROCEDURE FillCSpec (CSpec: Ptr; ix: INTEGER; bytePal: Ptr);
02A38
02A38                          	FillCSpec
02A38 G 206F 0004              		MOVE.L	4(SP),A0	* bytePal = SRC
02A3C   302F 0008              		MOVE.W	8(SP),D0	* ix
02A40 G 226F 000A              		MOVE.L  10(SP),A1	* CSpec = DST
02A44
02A44                          	* FillCSpec: COPY INDEX/PALETTE INTO DEST, SCALING THE RGB (BYTE-TO-WORD)
02A44                          	* GIVEN A0 -> SRC, A1 -> DST, D0.W = INDEX
02A44
02A44   32C0                   		MOVE.W	D0,(A1)+	* COPY IX
02A46   7003                   		MOVEQ	#3,D0
02A48
02A48   1210                   	FLCSX1	MOVE.B	(A0),D1		* GET AN RGB BYTE
02A4A   E149                   		LSL.W	#8,D1		* SCALE UP TO A WORD
02A4C   8218                   		OR.B	(A0)+,D1	* DUP VAL IN LOW BYTE
02A4E   32C1                   		MOVE.W	D1,(A1)+
02A50
02A50   5340                   		SUBQ.W	#1,D0
02A52   6EF4            02A48  		BGT.S	FLCSX1
02A54
02A54 G 205F                   		MOVE.L	(SP)+,A0	* RETURN ADDR
02A56   DEFC 000A              		ADDA.W	#10,SP		* CLEANUP, PASCAL STYLE
02A5A   4ED0                   		JMP	(A0)
02A5C
02A5C                          	* ----------------------
02A5C                          	* BuildStips
02A5C                          	* ----------------------
02A5C
02A5C                          	* OFFSETS IN EXPANDED STIPPLE TABLE
02A5C
02A5C   0000 0000              	SH0	EQU	0		* 16 WORDS OF "SHIFT-0", ------xx ------xx
02A5C   0000 0020              	SH2	EQU	16*2		* 16 WORDS OF "SHIFT-2", ----xx-- ----xx--
02A5C   0000 0040              	SH4	EQU	32*2		* ETC
02A5C   0000 0060              	SH6	EQU	48*2
02A5C
02A5C                          	* MAP STIPPLE IDS TO VALUES
02A5C
00356                          	    DATA
00356   00                     	STPTAB	DC.B	$0		* NO BITS ON
00357   01 02 04 08            		DC.B	$1,$2,$4,$8	* 1 BIT ON
0035B   03 05 06 09            		DC.B	$3,$5,$6,$9	* 2 BITS ON  00/11, 01/01, 01/10, 10/01
0035F   0A 0C                  		DC.B	$A,$C		*   [NORMALLY UNUSED] 10/10, 11/00
00361   07 0B 0D 0E            		DC.B	$7,$B,$D,$E	* 3 BITS ON
00365   0F                     		DC.B	$F		* 4 BITS ON
02A5C                          	    CODE
02A5C
02A5C                          	* PROCEDURE BuildStips (table1, table2: Ptr);
02A5C
02A5C                          	* BUILD AN "EXPANDED" TABLE OF STIPPLE VALS (16 WORDS x4), FOR USE BY StipRow,
02A5C                          	*   GIVEN A TABLE OF STIPPLE IDS (16 BYTES, EACH 0..15)
02A5C
02A5C                          	BuildStips
02A5C G 226F 0004              		MOVE.L	04(SP),A1	* EXPANDED TABLE (RESERVED SPACE, ACTUALLY)
02A60 G 206F 0008              		MOVE.L	08(SP),A0	* ID TABLE
02A64
02A64   48E7 3020              		MOVEM.L	D2-D3/A2,-(SP)
02A68   45ED 0356              		LEA	STPTAB,A2
02A6C   7600                   		MOVEQ	#0,D3		* INITIAL COLOR INDEX
02A6E
02A6E   3403                   	BLDSX1	MOVE.W	D3,D2		* NEXT COLOR INDEX
02A70   7000                   		MOVEQ	#0,D0
02A72   1018                   		MOVE.B	(A0)+,D0	* GET CORRESPONDING STIPPLE ID
02A74   1032 0000              		MOVE.B	0(A2,D0.W),D0	* MAP TO "DARKNESS" VALUE
02A78   6100 0014       02A8E  		BSR	BuildOne
02A7C
02A7C   5243                   		ADDQ.W	#1,D3
02A7E   0C43 000F              		CMPI.W	#15,D3		* MAX COLOR INDEX
02A82   6FEA            02A6E  		BLE.S	BLDSX1
02A84
02A84   4CDF 040C              		MOVEM.L	(SP)+,D2-D3/A2
02A88 G 205F                   		MOVE.L	(SP)+,A0	* RETURN ADDR
02A8A G 504F                   		ADDA.W	#8,SP		* CLEANUP, PASCAL STYLE

02A8C   4ED0                   		JMP	(A0)
02A8E
02A8E                          	* STORE THE STIPPLE FOR ONE PARTICULAR COLOR INDEX
02A8E                          	* GIVEN D0.W = STIPPLE VALUE (0..15), D2.W = COLOR INDEX (0..15),
02A8E                          	*   A1 -> EXPANDED TABLE
02A8E
02A8E                          	BuildOne
02A8E   4640                   		NOT.W	D0		* >> MAC: REVERSE WHITE & BLACK! <<
02A90   3200                   		MOVE.W	D0,D1
02A92   0241 000C              		ANDI.W	#$000C,D1	* EXTRACT 1ST HALF-NIBBLE
02A96   ED49                   		LSL.W	#6,D1		* POSITION IT		   ------xx --------
02A98   0240 0003              		ANDI.W	#$0003,D0	* EXTRACT 2ND HALF-NIBBLE  -------- ------xx
02A9C   8041                   		OR.W	D1,D0		* RECOMBINE
02A9E
02A9E   D442                   		ADD.W	D2,D2		* 2x INDEX
02AA0   3380 2000              		MOVE.W	D0,SH0(A1,D2.W)	* STORE "SHIFT-0" POSITION
02AA4   E548                   		LSL.W	#2,D0
02AA6   3380 2020              		MOVE.W	D0,SH2(A1,D2.W)	* STORE "SHIFT-2" POSITION
02AAA   E548                   		LSL.W	#2,D0
02AAC   3380 2040              		MOVE.W	D0,SH4(A1,D2.W)	* STORE "SHIFT-4" POSITION
02AB0   E548                   		LSL.W	#2,D0
02AB2   3380 2060              		MOVE.W	D0,SH6(A1,D2.W)	* STORE "SHIFT-6" POSITION
02AB6   4E75                   		RTS
02AB8
02AB8                          	* ----------------------
02AB8                          	* StipPic
02AB8                          	* ----------------------
02AB8
02AB8                          	* PROCEDURE StipPic (src, dst: Ptr; rowBytes, rows: INTEGER; maps: Ptr);
02AB8
02AB8                          	StipPic
02AB8   48E7 3C30              		MOVEM.L	D2-D5/A2-A3,-(SP)	* [24 BYTES]
02ABC
02ABC G 266F 001C              		MOVE.L	24+04(SP),A3	* MAPS (16 WORDS X4)
02AC0   3A2F 0020              		MOVE.W	24+08(SP),D5	* ROWS [MONO]
02AC4   E245                   		ASR.W	#1,D5		* ROWS [COLOR]
02AC6   382F 0022              		MOVE.W	24+10(SP),D4	* ROWBYTES [MONO] -- MULTIPLE OF 2
02ACA G 246F 0024              		MOVE.L  24+12(SP),A2	* DST
02ACE G 206F 0028              		MOVE.L	24+16(SP),A0	* SRC
02AD2
02AD2 G 224A                   	STPPX1	MOVE.L	A2,A1		* NEW DST1
02AD4   D4C4                   		ADDA.W	D4,A2		* NEW DST2 - 2ND ROW OF STIPPLES
02AD6   3004                   		MOVE.W	D4,D0
02AD8   6100 0012       02AEC  		BSR	StipRow
02ADC   5345                   		SUBQ.W	#1,D5
02ADE   6EF2            02AD2  		BGT.S	STPPX1
02AE0
02AE0   4CDF 0C3C              		MOVEM.L	(SP)+,D2-D5/A2-A3
02AE4 G 205F                   		MOVE.L	(SP)+,A0	* RETURN ADDR
02AE6   DEFC 0010              		ADDA.W	#16,SP		* CLEANUP, PASCAL STYLE
02AEA   4ED0                   		JMP	(A0)
02AEC
02AEC                          	* StipRow: CONVERT EACH COLOR PIXEL INTO A 2x2 MONO STIPPLE
02AEC                          	* FOR SPEED, EACH LOOP CONVERTS /4/ COLOR PIXELS INTO AN 8x2 MONO STIPPLE
02AEC
02AEC                          	* GIVEN A0 -> SRC, D0.W = ROW LENGTH,  A1 -> DST1, A2 -> DST2,  A3 -> MAPS
02AEC                          	* USES	D1.W = PIX1, D2.W = PIX2,  D3.W = STIPPLE
02AEC                          	* RETURNS UPDATED PTRS
02AEC
02AEC                          	StipRow
02AEC   7200                   		MOVEQ	#0,D1		* ZERO ALL BYTES
02AEE   7600                   	STPRX1	MOVEQ	#0,D3		* ZERO RESULT
02AF0
02AF0   1218                   		MOVE.B	(A0)+,D1	* GET 2 PIXELS (2x4 BITS)
02AF2   1401                   		MOVE.B	D1,D2
02AF4   E849                   		LSR.W	#4,D1		* EXTRACT HIGH PIXEL
02AF6   D241                   		ADD.W	D1,D1		* 2x
02AF8   8673 1060              		OR.W	SH6(A3,D1.W),D3	* xx------ xx------
02AFC   0242 000F              		ANDI.W	#$0F,D2		* EXTRACT LOW PIXEL
02B00   D442                   		ADD.W	D2,D2		* 2x
02B02   8673 2040              		OR.W	SH4(A3,D2.W),D3	* --xx---- --xx----
02B06
02B06   1218                   		MOVE.B	(A0)+,D1	* GET 2 MORE PIXELS (2x4 BITS)
02B08   1401                   		MOVE.B	D1,D2
02B0A   E849                   		LSR.W	#4,D1		* EXTRACT HIGH PIXEL

02B0C   D241                   		ADD.W	D1,D1		* 2x
02B0E   8673 1020              		OR.W	SH2(A3,D1.W),D3	* ----xx-- ----xx--
02B12   0242 000F              		ANDI.W	#$0F,D2		* EXTRACT LOW PIXEL
02B16   D442                   		ADD.W	D2,D2		* 2x
02B18   8673 2000              		OR.W	SH0(A3,D2.W),D3	* ------xx ------xx
02B1C
02B1C                          	* AT THIS POINT, WE HAVE 4 FOUR-BIT STIPPLES
02B1C
02B1C   14C3                   		MOVE.B	D3,(A2)+	* STORE 2x4 LSBITS OF STIPPLES IN 2ND ROW
02B1E   E04B                   		LSR.W	#8,D3
02B20   12C3                   		MOVE.B	D3,(A1)+	* STORE 2x4 MSBITS OF STIPPLES IN PRIMARY ROW
02B22   5340                   		SUBQ.W	#1,D0
02B24   6EC8            02AEE  		BGT.S	STPRX1		* LOOP UNTIL END OF ROW
02B26   4E75                   		RTS
02B28
02B28                          	* ----------------------
02B28                          	* Shrink75
02B28                          	* ----------------------
02B28
02B28                          	* PROCEDURE Shrink75 (base: Ptr; rb1, rb2, rows: INTEGER);
02B28
02B28                          	* SCALE A GIVEN (COLOR) PICTURE BY 0.75 - DISCARD EVERY 4TH BYTE AND EVERY 4TH ROW
02B28                          	* NOTE: BOTH RB ARE ALWAYS MULTIPLES OF 4 (SINCE PRE-STIPPLE)
02B28
02B28                          	Shrink75
02B28   48E7 3F30              		MOVEM.L	D2-D7/A2-A3,-(SP)	* 8x4 BYTES
02B2C   382F 0024              		MOVE.W	32+04(SP),D4	* ROWS
02B30   362F 0026              		MOVE.W	32+06(SP),D3	* SHRUNK ROWBYTES
02B34   342F 0028              		MOVE.W	32+08(SP),D2	* ROWBYTES
02B38 G 266F 002A              		MOVE.L	32+10(SP),A3	* SRC AND (INITIAL) DST PTRS (IN-PLACE COPY)
02B3C G 244B                   		MOVE.L	A3,A2
02B3E
02B3E   6100 0030       02B70  	SK75X1	BSR	ShrinkOne	* COPY 1ST ROW
02B42   D4C2                   		ADDA.W	D2,A2		* NEXT SRC
02B44   D6C3                   		ADDA.W	D3,A3		* NEXT DST
02B46   5344                   		SUBQ.W	#1,D4		* DONE?
02B48   6F1A            02B64  		BLE.S	SK75X2
02B4A
02B4A   6100 0024       02B70  		BSR	ShrinkOne	* COPY 2ND ROW
02B4E   D4C2                   		ADDA.W	D2,A2
02B50   D6C3                   		ADDA.W	D3,A3
02B52   5344                   		SUBQ.W	#1,D4		* DONE?
02B54   6F0E            02B64  		BLE.S	SK75X2
02B56
02B56   6100 0018       02B70  		BSR	ShrinkOne	* COPY 3RD ROW
02B5A   D4C2                   		ADDA.W	D2,A2
02B5C   D6C3                   		ADDA.W	D3,A3
02B5E
02B5E   D4C2                   		ADDA.W	D2,A2		* SKIP 4TH ROW
02B60   5544                   		SUBQ.W	#2,D4		* DONE?
02B62   6EDA            02B3E  		BGT.S	SK75X1
02B64
02B64   4CDF 0CFC              	SK75X2	MOVEM.L	(SP)+,D2-D7/A2-A3
02B68 G 205F                   		MOVE.L	(SP)+,A0	* RETURN ADDR
02B6A   DEFC 000A              		ADDA.W	#10,SP		* CLEANUP, PASCAL STYLE
02B6E   4ED0                   		JMP	(A0)
02B70
02B70                          	ShrinkOne
02B70 G 204A                   		MOVE.L	A2,A0
02B72 G 224B                   		MOVE.L	A3,A1
02B74   3202                   		MOVE.W	D2,D1		* FULL ROWBYTES
02B76
02B76                          	* GIVEN A0 -> SRC, A1 -> DST, D1.W = FULL ROWBYTES
02B76                          	* NOTE: WE "UNROLL" 2x4 ITERATIONS FOR SPEED - MAY GO 4 BYTES BEYOND END OF DATA
02B76
02B76                          	SKONX1
02B76                          	**	MOVE.L	(A0)+,(A1)+	* COPY 3 BYTES, SKIP 4TH
02B76                          	**	SUBQ.L	#1,A1
02B76                          	**	MOVE.B	(A0)+,(A1)+	* COPY 3 BYTES (OUT OF PHASE), SKIP 4TH
02B76                          	**	MOVE.B	(A0)+,(A1)+
02B76                          	**	MOVE.B	(A0)+,(A1)+
02B76                          	**	ADDQ.L	#1,A0
02B76
02B76                          	* COPY 3 BYTES (6 NIBBLES/PIXELS), SKIP 4TH (2 NIBBLES/PIXELS)
02B76

02B76   2018                   		MOVE.L	(A0)+,D0
02B78   7E00                   		MOVEQ	#0,D7		* ZERO HIGH WORD
02B7A   3E00                   		MOVE.W	D0,D7
02B7C   E98F                   		LSL.L	#4,D7		* POSITION NIBBLES: 00 0e fg x0
02B7E   0280 FFF0 0000         		ANDI.L	#$FFF00000,D0	* EXTRACT NIBBLES:  ab c0 00 00
02B84   8087                   		OR.L	D7,D0
02B86
02B86   22C0                   		MOVE.L	D0,(A1)+	* STORE 3 BYTES
02B88   5389                   		SUBQ.L	#1,A1
02B8A
02B8A                          	* COPY 3 BYTES (OUT OF PHASE), SKIP 4TH
02B8A
02B8A   2018                   		MOVE.L	(A0)+,D0
02B8C   7E00                   		MOVEQ	#0,D7		* ZERO HIGH WORD
02B8E   3E00                   		MOVE.W	D0,D7
02B90   E98F                   		LSL.L	#4,D7		* POSITION NIBBLES: 00 0e fg x0
02B92   0280 FFF0 0000         		ANDI.L	#$FFF00000,D0	* EXTRACT NIBBLES:  ab c0 00 00
02B98   8087                   		OR.L	D7,D0
02B9A
02B9A   E198                   		ROL.L	#8,D0		* STORE 3 BYTES
02B9C   12C0                   		MOVE.B	D0,(A1)+
02B9E   E198                   		ROL.L	#8,D0
02BA0   12C0                   		MOVE.B	D0,(A1)+
02BA2   E198                   		ROL.L	#8,D0
02BA4   12C0                   		MOVE.B	D0,(A1)+
02BA6
02BA6   5141                   		SUBQ.W	#8,D1
02BA8   6ECC            02B76  		BGT.S	SKONX1		* LOOP
02BAA   4E75                   		RTS
02BAC
02BAC                          	* ----------------------
02BAC                          	* Scale2xPic
02BAC                          	* ----------------------
02BAC
02BAC                          	* PROCEDURE Scale2xPic (src, dst, randTbl: Ptr; cols {rbSrc, rbDst}, rows: INTEGER);
02BAC
02BAC                          	* SCALE A GIVEN (COLOR) PICTURE BY 2.0, INTERPOLATING /RANDOMLY/
02BAC                          	* HOPEFULLY THIS WILL MAKE IT LOOK LESS SCALED-UP AND BLOCKY
02BAC
02BAC                          	Scale2xPic
02BAC   48E7 3F3E              		MOVEM.L	D2-D7/A2-A6,-(SP)	* 11x4 BYTES
02BB0   3C2F 0030              		MOVE.W	44+04(SP),D6	* ROWS
02BB4   3A2F 0032              		MOVE.W	44+06(SP),D5	* COLS
02BB8 G 286F 0034              		MOVE.L	44+08(SP),A4	* PTR TO TABLE OF RANDOM BITS
02BBC   7800                   		MOVEQ	#0,D4		* INITIAL BIT OFFSET
02BBE G 226F 0038              		MOVE.L	44+12(SP),A1	* DST
02BC2 G 206F 003C              		MOVE.L	44+16(SP),A0	* SRC
02BC6
02BC6 G 2448                   		MOVE.L	A0,A2
02BC8   D4C5                   		ADDA.W	D5,A2		* SRC_AHEAD (NEXT ROW)
02BCA G 2649                   		MOVE.L	A1,A3
02BCC   D6C5                   		ADDA.W	D5,A3
02BCE   D6C5                   		ADDA.W	D5,A3		* DST_MID (NEXT ROW)
02BD0
02BD0   5346                   		SUBQ.W	#1,D6		* (LAST ROW IS HANDLED SPECIALLY)
02BD2   6F1E            02BF2  		BLE.S	SCXPX2	* BLT?
02BD4
02BD4   3605                   	SCXPX1	MOVE.W	D5,D3
02BD6   6100 0026       02BFE  		BSR	Scale2xRow
02BDA
02BDA G 224B                   		MOVE.L	A3,A1		* UPDATE DST
02BDC   D6C5                   		ADDA.W	D5,A3
02BDE   D6C5                   		ADDA.W	D5,A3		* AND DST_MID
02BE0
02BE0 G 286F 0034              		MOVE.L	44+08(SP),A4	* RESET: PTR TO TABLE OF RANDOM BITS
02BE4   5204                   		ADDQ.B	#1,D4		* UPDATE: BIT OFFSET (ONLY CARE ABOUT LOW 3 BITS)
02BE6   5346                   		SUBQ.W	#1,D6
02BE8   6EEA            02BD4  		BGT.S	SCXPX1
02BEA
02BEA                          	* LAST ROW, SPECIAL CASE: NO VERTICAL RANDOMIZATION
02BEA
02BEA G 2448                   		MOVE.L	A0,A2		* "SRC = SRC_AHEAD"
02BEC   3605                   		MOVE.W	D5,D3
02BEE   6100 000E       02BFE  		BSR	Scale2xRow
02BF2

02BF2   4CDF 7CFC              	SCXPX2	MOVEM.L	(SP)+,D2-D7/A2-A6
02BF6 G 205F                   		MOVE.L	(SP)+,A0	* RETURN ADDR
02BF8   DEFC 0010              		ADDA.W	#16,SP		* CLEANUP, PASCAL STYLE
02BFC   4ED0                   		JMP	(A0)
02BFE
02BFE
02BFE                          	* Scale2xRow
02BFE                          	*
02BFE                          	* EACH SRC PIXEL MAPS TO 4 DST PIXELS, ACCORDING TO THE FOLLOWING PATTERN:
02BFE                          	*
02BFE                          	*	1a	1a'	(1b)			1a' = 1a or 1b
02BFE                          	*	1'a	1'a'				1'a = 1a or 2a
02BFE                          	*	(2a)					1'a' = 1a' or 1'a
02BFE                          	*
02BFE                          	* 1a is copied directly from the src.  Each of its three spinoffs are generated
02BFE                          	* randomly from two neighbors of that spinoff.
02BFE                          	*
02BFE                          	* To avoid "feathering" lines and such, the algorithm is extended as follows:
02BFE                          	*
02BFE                          	*	if 2a = 1a then 1a' = 1a always  (and by implication, 1'a = 1'a' = 1a also)
02BFE                          	*	if 1b = 1a then 1'a = 1a always  (and by implication, 1a' = 1'a' = 1a also)
02BFE                          	*
02BFE                          	* >> NOTE: ALL PIXELS CURRENTLY /BYTE/ VALUES (NOT NIBBLES) <<
02BFE                          	*
02BFE                          	* GIVEN A0 -> SRC, A2 -> SRC_AHEAD	D3.W = SRC PIXELS (BYTES)
02BFE                          	*	A1 -> DST, A3 -> DST_MID
02BFE                          	* 	A4 -> TABLE OF RANDOM BYTES (4x200)	D4.B = BIT NUMBER (0-7)
02BFE                          	*
02BFE                          	* ALSO USES D7
02BFE                          	* RETURN UPDATED A0-A3
02BFE
02BFE                          	Scale2xRow
02BFE   5343                   		SUBQ.W	#1,D3		* (LAST PIXEL IS HANDLED SPECIALLY)
02C00   6F36            02C38  		BLE.S	SCXRX9
02C02   1018                   		MOVE.B	(A0)+,D0	* GET FIRST PIXEL
02C04
02C04                          	* A0 -> SRC+1,  D0.B = (A0)
02C04
02C04   12C0                   	SCXRX1	MOVE.B	D0,(A1)+	* STORE 1a
02C06
02C06   1218                   		MOVE.B	(A0)+,D1	* GET 1b
02C08   141A                   		MOVE.B	(A2)+,D2	* GET 2a
02C0A   1E00                   		MOVE.B	D0,D7
02C0C
02C0C   B200                   		CMP.B	D0,D1		* 1b = 1a?
02C0E   6706            02C16  		BEQ.S	SCXRX2		* YES, FORCE 1'a = 1a
02C10
02C10   091C                   		BTST.B	D4,(A4)+	* RANDOMIZE
02C12   6702            02C16  		BEQ.S	SCXRX2
02C14   1E02                   		MOVE.B	D2,D7
02C16   16C7                   	SCXRX2	MOVE.B	D7,(A3)+	* STORE 1'a
02C18
02C18   B400                   		CMP.B	D0,D2		* 2a = 1a?
02C1A   6706            02C22  		BEQ.S	SCXRX3		* YES, FORCE 1a' = 1a
02C1C
02C1C   091C                   		BTST.B	D4,(A4)+	* RANDOMIZE
02C1E   6702            02C22  		BEQ.S	SCXRX3
02C20   1001                   		MOVE.B	D1,D0
02C22   12C0                   	SCXRX3	MOVE.B	D0,(A1)+	* STORE 1a'
02C24
02C24   091C                   		BTST.B	D4,(A4)+	* RANDOMIZE
02C26   6702            02C2A  		BEQ.S	SCXRX4
02C28   1007                   		MOVE.B	D7,D0
02C2A   16C0                   	SCXRX4	MOVE.B	D0,(A3)+	* STORE 1'a'
02C2C
02C2C                          	* Each loop advances each src +1, each dst +2
02C2C
02C2C   1001                   		MOVE.B	D1,D0		* [POSITION 1b FOR NEXT ITERATION]
02C2E
02C2E   5343                   		SUBQ.W	#1,D3
02C30   6ED2            02C04  		BGT.S	SCXRX1
02C32   6D04            02C38  		BLT.S	SCXRX9
02C34
02C34                          	* For the final pixel, make 1b = 1a
02C34

02C34   5388                   		SUBQ.L	#1,A0
02C36   60CC            02C04  		BRA.S	SCXRX1
02C38
02C38   4E75                   	SCXRX9	RTS
02C3A
02C3A
02C3A                          	    END

#0001          00000000    CODE LABEL
#0002          00000000    DATA MODULE ENTRY
ACTLEN         --------    DATA IMPORT
APPARM         FFFFFEDA    EQU
ARG0           00000000    EQU
ARG1           00000002    EQU
ARG2           00000004    EQU
ARG3           00000006    EQU
ARG4           00000008    EQU
ARGBLK         FFFFFF96    EQU
ASHFX1         00000644    CODE LABEL
AUTOCR         0000001D    EQU
BLDSX1         00002A6E    CODE LABEL
BLKBYT         000003B2    CODE LABEL
BMOUSE         --------    DATA IMPORT
BSPLIT         00000546    CODE LABEL
BSPLTB         0000053A    CODE LABEL
BSPLTQ2        00000552    CODE LABEL
BUFFER         FFFFFFA8    EQU
BUFOUT         000026E4    CODE LABEL
BUFOX1         00001528    CODE LABEL
BUFOX2         00001530    CODE LABEL
BUFOX3         00001540    CODE LABEL
BUFPTR         00000000    EQU
BUFSIZ         0000000C    EQU
BUFUX1         000026F4    CODE LABEL
BUFUX2         000026FE    CODE LABEL
BUILDONE       00002A8E    CODE LABEL
BUILDSTIPS     00002A5C    CODE LABEL EXPORT
BYTBLK         000003BA    CODE LABEL
BYTBX1         000003C8    CODE LABEL
BYTVAL         000004DC    CODE LABEL
CALCWP         00001034    CODE LABEL
CALLX1         000016AC    CODE LABEL
CALLX2         000016BC    CODE LABEL
CALLX3         0000170C    CODE LABEL
CALLX4         0000171A    CODE LABEL
CALLX5         0000171E    CODE LABEL
CALLX6         00001720    CODE LABEL
CALLX7         00001728    CODE LABEL
CALLX8         0000172A    CODE LABEL
CALLX9         0000172E    CODE LABEL
CHAROUT        --------    CODE IMPORT
CHKDSK         00002988    CODE LABEL
CHKDSK1        00002988    CODE LABEL
CHRBX1         00001DF4    CODE LABEL
CHRBX2         00001E00    CODE LABEL
CHRBX3         00001E0A    CODE LABEL
CHRBX4         00001E16    CODE LABEL
CHRBYT         00001DF0    CODE LABEL
CHRCS          00001DC4    CODE LABEL
CHRCX1         00001DCC    CODE LABEL
CHRCX2         00001DDC    CODE LABEL
CHRCX3         00001DEC    CODE LABEL
CHRCX4         00001DEE    CODE LABEL
CHRTOT         FFFFFEEE    EQU
CLEARWINDOW    --------    CODE IMPORT
CLOSEFILE      --------    CODE IMPORT
CLSGAM         000027FC    CODE LABEL
CLSSFL         00002948    CODE LABEL
CLWPX2         0000104C    CODE LABEL
CLWPX3         0000104C    CODE LABEL
CMLEN          00000010    EQU
CMPSX2         0000037C    CODE LABEL
CMPSX4         00000384    CODE LABEL
CMSRC          0000000C    EQU
CMX1           000029F4    CODE LABEL
CMX2           000029FC    CODE LABEL
CMX3           00002A08    CODE LABEL
CMX5           00002A0E    CODE LABEL
COLRX2         000014A4    CODE LABEL
COLRX4         000014AC    CODE LABEL
COLRX9         000014D0    CODE LABEL
COLWIDTH       --------    DATA IMPORT
COMPS          00000378    CODE LABEL

COPYB          00000360    CODE LABEL
COPYS          00000366    CODE LABEL
CPBX1          0000035E    CODE LABEL
CPSX1          0000036C    CODE LABEL
CPSX2          0000036E    CODE LABEL
CPSX3          00000370    CODE LABEL
CPYTX1         00000974    CODE LABEL
CPYTX2         0000098E    CODE LABEL
CPYTX3         000009A4    CODE LABEL
CPYTX4         000009BA    CODE LABEL
CPYTX5         000009CC    CODE LABEL
CPYTX6         000009DA    CODE LABEL
CPYTX7         000009E2    CODE LABEL
CPYTX8         000009EA    CODE LABEL
CRCHECK        0000260E    CODE LABEL
CRCHX2         00002628    CODE LABEL
CRCHX4         00002640    CODE LABEL
CRCHX9         0000265C    CODE LABEL
CREATEFILE     --------    CODE IMPORT
CURBLK         FFFFFF42    EQU
CURCOL         --------    DATA IMPORT
CURPAG         FFFFFF44    EQU
CURRENTATTR    --------    DATA IMPORT
CURRENTHL      --------    DATA IMPORT
CURROW         --------    DATA IMPORT
CURSIZ         0000000E    EQU
CURTAB         FFFFFF3E    EQU
CURWIND        FFFFFF18    EQU
CURWP          FFFFFF14    EQU
CVFLAG         00000100    EQU
CZIP           00000000    EQU
D3BUG          00000000    EQU
DBIBRK         FFFFFEC8    EQU
DBINST         FFFFFED0    EQU
DBITOT         FFFFFECC    EQU
DBQEND         FFFFFEB0    EQU
DBQLEN         00000010    EQU
DBQPTR         FFFFFEB4    EQU
DBQUE          FFFFFEB8    EQU
DBZPC1         FFFFFED4    EQU
DBZPC2         FFFFFED2    EQU
DCHSIZ         00002404    CODE LABEL
DEBUG          00000000    EQU
DEFBLK         FFFFFF8C    EQU
DEFNEW         00002976    CODE LABEL
DEFNX1         00002978    CODE LABEL
DEFOLD         00002970    CODE LABEL
DELCH1         00000008    EQU
DELCH2         0000007F    EQU
DELETEFILE     --------    CODE IMPORT
DELSFL         0000295E    CODE LABEL
DIRX0          00001564    CODE LABEL
DIRX1          00001572    CODE LABEL
DIRX2          0000157A    CODE LABEL
DIRX3          00001584    CODE LABEL
DIRX4          000015A2    CODE LABEL
DIRX5          000015BE    CODE LABEL
DIRX6          000015DA    CODE LABEL
DIRX7          000015F4    CODE LABEL
DISPX1         00001678    CODE LABEL
DOSDX2         00002424    CODE LABEL
DOSOUND        0000241A    CODE LABEL
DQUE           FFFFFF54    EQU
DUMPED         0000001C    EQU
DUPNAM         00002842    CODE LABEL
ENDLOD         FFFFFFFA    EQU
ENDPTR         00000008    EQU
ENDTITLE       00002372    CODE LABEL
ENDZSOUND      --------    CODE IMPORT
EOLCHR         0000000D    EQU
ERASELINE      --------    CODE IMPORT
ERAX1          00001440    CODE LABEL
ESIBKS         FFFFFFE0    EQU
EVENTIN        --------    CODE IMPORT
EXISTFILE      --------    CODE IMPORT

EXTOPS         0000017E    DATA LABEL
EZERR          0000034C    CODE LABEL
EZERX1         00000354    CODE LABEL
EZIP           00000001    EQU
FATAL          00002758    CODE LABEL
FATLX1         00002778    CODE LABEL
FATLX2         00002784    CODE LABEL
FBX1           00000E32    CODE LABEL
FBX2           00000E34    CODE LABEL
FBX4           00000E44    CODE LABEL
FBX6           00000E50    CODE LABEL
FBX8           00000E5C    CODE LABEL
FDISP          00000003    EQU
FDPGX1         00002178    CODE LABEL
FDPGX2         00002180    CODE LABEL
FFIXE          00000001    EQU
FILENAME       --------    DATA IMPORT
FILESELECT     --------    CODE IMPORT
FILEVOL        --------    DATA IMPORT
FILLCSPEC      00002A38    CODE LABEL EXPORT
FINDBK         00000E28    CODE LABEL
FINDPG         00002170    CODE LABEL
FINISH         0000247A    CODE LABEL
FINIX2         000024A6    CODE LABEL
FINIX3         000024BA    CODE LABEL
FIRST          0000000A    EQU
FIRSTCOL       --------    DATA IMPORT
FIRSTROW       --------    DATA IMPORT
FLCSX1         00002A48    CODE LABEL
FLGLOC         00000806    CODE LABEL
FMOUS          00000005    EQU
FNDRSF         000027D4    CODE LABEL
FONT           FFFFFEE2    EQU
FONTX2         00001466    CODE LABEL
FONTX4         0000146E    CODE LABEL
FONTX9         0000148E    CODE LABEL
FSTAT          00000002    EQU
FSTAX2         0000178E    CODE LABEL
FSTAX4         000017A2    CODE LABEL
FSTPRP         0000067E    CODE LABEL
FUNDO          00000004    EQU
GAMFIL         FFFFFEEC    EQU
GAMINT         0000244E    CODE LABEL
GAMINT1        0000245C    CODE LABEL
GAMIX1         00002456    CODE LABEL
GAMIX3         00002474    CODE LABEL
GETARG         00000476    CODE LABEL
GETBLK         00002800    CODE LABEL
GETBX1         00000422    CODE LABEL
GETBX2         0000042C    CODE LABEL
GETBX3         0000043A    CODE LABEL
GETBYT         0000040A    CODE LABEL
GETCURS        000022A8    CODE LABEL
GETCURS1       000022AC    CODE LABEL
GETFYX         000021A4    CODE LABEL
GETM           00002398    CODE LABEL
GETMEM         000023B6    CODE LABEL
GETMEMC        000023C8    CODE LABEL
GETMOUSE       000025C4    CODE LABEL
GETMX1         000023A4    CODE LABEL
GETPAG         0000210C    CODE LABEL
GETPX1         0000076E    CODE LABEL
GETPX2         00000772    CODE LABEL
GETPX3         0000078A    CODE LABEL
GETPX4         00000794    CODE LABEL
GETSFL         00002846    CODE LABEL
GETV1          0000048E    CODE LABEL
GETVAR         00000486    CODE LABEL
GETVX2         000004A0    CODE LABEL
GETWRD         0000043C    CODE LABEL
GLOTAB         FFFFFFEC    EQU
GPX1           0000211E    CODE LABEL
GPX2           0000212E    CODE LABEL
GPX3           00002144    CODE LABEL
GPX4           0000216A    CODE LABEL

GTAWRD         000003F6    CODE LABEL
GTBKX1         00002834    CODE LABEL
GTBKX2         0000283A    CODE LABEL
GTBLKS         00002810    CODE LABEL
GTMCX1         000023D2    CODE LABEL
GTMCX2         000023D4    CODE LABEL
GTPTX1         00000894    CODE LABEL
GTPTX2         00000898    CODE LABEL
GTPTX3         000008A8    CODE LABEL
GTPTX4         000008B2    CODE LABEL
GTPTX5         000008B8    CODE LABEL
GTSBKS         000028C2    CODE LABEL
GTSEED         000023F8    CODE LABEL
GTSFX2         00002860    CODE LABEL
GTSFX8         00002884    CODE LABEL
IBNDX1         00002266    CODE LABEL
IBNDX2         0000226C    CODE LABEL
IDSPX9         00000346    CODE LABEL
INBOUNDS       00002260    CODE LABEL
INCALL         000017DA    CODE LABEL
INCHR          000024EA    CODE LABEL
INCHX1         000024FC    CODE LABEL
INITDISP       000002F4    CODE LABEL
INITLX         00000E8E    CODE LABEL
INITQP         00001E92    CODE LABEL
INITWB         000002AA    CODE LABEL
INIWX1         0000008E    CODE LABEL
INLAST         FFFFFEF0    EQU
INLX4          00000EB4    CODE LABEL
INLX5          00000EBC    CODE LABEL
INLX6          00000EC8    CODE LABEL
INPUT          00000CCA    CODE LABEL
INPX1          00000CBA    CODE LABEL
INPX4          00000CD8    CODE LABEL
INPX6          00000CF2    CODE LABEL
INPX7          00000D2E    CODE LABEL
INPX8          00000D30    CODE LABEL
INRETU         000017FC    CODE LABEL
INTWRD         00000000    DATA LABEL
INUSE          0000001F    EQU
INWBX1         000002B8    CODE LABEL
IRBRKS         00000004    DATA LABEL
ITBX1          00000912    CODE LABEL
ITBX2          0000092C    CODE LABEL
ITBX3          00000936    CODE LABEL
ITBX4          0000093A    CODE LABEL
ITBX5          0000094A    CODE LABEL
ITTYIN         000024FE    CODE LABEL
ITTYX1         00002534    CODE LABEL
ITTYX11        0000253E    CODE LABEL
ITTYX13        00002576    CODE LABEL
ITTYX18        00002594    CODE LABEL
ITTYX19        00002596    CODE LABEL
ITTYX2         0000253C    CODE LABEL
KEEPSP         0000001E    EQU
LASTCOL        --------    DATA IMPORT
LASTROW        --------    DATA IMPORT
LCASE          00000E0E    CODE LABEL
LCSX1          00000E10    CODE LABEL
LCSX2          00000E20    CODE LABEL
LCSX3          00000E22    CODE LABEL
LEX            00000BC0    CODE LABEL
LINEHEIGHT     --------    DATA IMPORT
LINEOUT        --------    CODE IMPORT
LINOUT         00002700    CODE LABEL
LINOX1         0000271E    CODE LABEL
LKX1           00000EFA    CODE LABEL
LKX10          00000F38    CODE LABEL
LKX12          00000F40    CODE LABEL
LKX14          00000F48    CODE LABEL
LKX16          00000F4A    CODE LABEL
LKX2           00000F10    CODE LABEL
LKX4           00000F1A    CODE LABEL
LKX6           00000F28    CODE LABEL
LKX8           00000F36    CODE LABEL

LOAD1          000000DC    CODE LABEL
LOAD2          000000F2    CODE LABEL
LOAD3          0000010C    CODE LABEL
LOADX1         00000108    CODE LABEL
LOC            00000006    EQU
LOOKUP         00000EE4    CODE LABEL
LOWCORE        000003CA    CODE LABEL
LPAGE          FFFFFF38    EQU
LPLOC          FFFFFF34    EQU
LPTAB          FFFFFF30    EQU
LWCX1          000003EE    CODE LABEL
LWCX2          000003F0    CODE LABEL
LXX0           00000BBC    CODE LABEL
LXX2           00000BE4    CODE LABEL
LXX3           00000C14    CODE LABEL
LXX4           00000C1A    CODE LABEL
LXX6           00000C2E    CODE LABEL
LXX8           00000C38    CODE LABEL
MACBUF         FFFFFEDE    EQU
MACINIT        --------    CODE IMPORT
MARGLEFT       --------    DATA IMPORT
MARGRIGHT      --------    DATA IMPORT
MARGX2         000014E2    CODE LABEL
MARGX4         000014EA    CODE LABEL
MARGX9         0000151C    CODE LABEL
MAXFLG         FFFFFFC6    EQU
MAXLEN         000000A0    EQU
MAXLOCS        0000000F    EQU
MAXLOD         FFFFFFC8    EQU
MAXSCRN        0000219A    CODE LABEL
MAXWIND        00000008    EQU
MCOLOR         --------    DATA IMPORT
MDCLEAR        000022F2    CODE LABEL
MDCOLOR        00002326    CODE LABEL
MDERASE        00002314    CODE LABEL
MDSCROLL       000022E2    CODE LABEL
MEMAVAIL       000023DC    CODE LABEL
MEMERROR       000023BE    CODE LABEL
MEMSYS         00005000    EQU
MMDEST         0000000C    EQU
MMLEN          00000010    EQU
MMSRC          00000008    EQU
MMX0           0000299E    CODE LABEL
MMX1           000029BA    CODE LABEL
MMX2           000029C2    CODE LABEL
MMX3           000029CE    CODE LABEL
MMX5           000029D4    CODE LABEL
MOVMEM         000029A2    CODE LABEL
MSAVEB         FFFFFEE6    EQU
MSAVEF         FFFFFEE4    EQU
MSGBAD         0000012F    DATA LABEL
MSGBFO         000000C3    DATA LABEL
MSGCA1         000000CE    DATA LABEL
MSGCA2         000000DA    DATA LABEL
MSGEZR         00000023    DATA LABEL
MSGFTL         000002F8    DATA LABEL
MSGFUL         0000031F    DATA LABEL
MSGIO1         00000090    DATA LABEL
MSGIO2         000000B4    DATA LABEL
MSGKEY         000002C0    DATA LABEL
MSGME1         000002AD    DATA LABEL
MSGMOR         000002D7    DATA LABEL
MSGNXP         00000075    DATA LABEL
MSGODV         0000004B    DATA LABEL
MSGOMD         00000053    DATA LABEL
MSGOPN         00000296    DATA LABEL
MSGPUP         0000005B    DATA LABEL
MSGRE1         0000010D    DATA LABEL
MSGRE2         000000F5    DATA LABEL
MSGREA         00000308    DATA LABEL
MSGRLB         00000034    DATA LABEL
MSGSCN         0000028F    DATA LABEL
MSGTHR         000000EB    DATA LABEL
MSGVR2         00000122    DATA LABEL
MSGWPR         00000338    DATA LABEL

MSGWPS         000000B8    DATA LABEL
MSGZMV         0000000B    DATA LABEL
MSGZWR         000002DE    DATA LABEL
MSWIND         FFFFFEF2    EQU
N0X1           00001B94    CODE LABEL
N2X1           00001BD8    CODE LABEL
N2X2           00001BE8    CODE LABEL
N2X3           00001C16    CODE LABEL
N4X1           00001C2E    CODE LABEL
N4X2           00001C52    CODE LABEL
N4X3           00001C66    CODE LABEL
N4X4           00001C80    CODE LABEL
N4X5           00001C86    CODE LABEL
N4X5A          00001CB8    CODE LABEL
N4X6           00001CBC    CODE LABEL
NARGS          FFFFFFB8    EQU
NBNDX2         00002228    CODE LABEL
NBNDX4         0000224E    CODE LABEL
NEWBOUNDS      00002210    CODE LABEL
NEWDEFAULT     --------    CODE IMPORT
NEWLIN         00001FCE    CODE LABEL
NEWSFL         0000288C    CODE LABEL
NEWSX2         000028AA    CODE LABEL
NEWZPC         000020AA    CODE LABEL
NEXT           00000008    EQU
NEXTX1         000007DE    CODE LABEL
NEXTX2         000007E2    CODE LABEL
NEXTX3         000007F8    CODE LABEL
NEXTX4         000007FC    CODE LABEL
NOOP           00004E71    EQU
NXT0           00001B76    CODE LABEL
NXT1           00001BA8    CODE LABEL
NXT2           00001BCC    CODE LABEL
NXT4           00001C1C    CODE LABEL
NXT4A          00001C4C    CODE LABEL
NXTBX1         00000468    CODE LABEL
NXTBYT         00000448    CODE LABEL
NXTINS         00001B54    CODE LABEL
NXTLIN         0000265E    CODE LABEL
NXTLX6         000026C4    CODE LABEL
NXTPRP         00000698    CODE LABEL
NXTPTR         00000004    EQU
NXTPX2         000006A8    CODE LABEL
NXTPX4         000006AC    CODE LABEL
NXTWRD         0000046A    CODE LABEL
NZX2           000020DA    CODE LABEL
NZX3           000020FA    CODE LABEL
NZX4           0000210A    CODE LABEL
OBJLOC         0000066E    CODE LABEL
OBJTAB         FFFFFFF0    EQU
OCLRX2         000013E4    CODE LABEL
OCLRX6         000013EE    CODE LABEL
OCLRX7         00001406    CODE LABEL
OCLRX8         0000140A    CODE LABEL
OCLRX9         0000142E    CODE LABEL
ODIVX1         00000580    CODE LABEL
OLEN           0000000E    EQU
OMODX1         00000596    CODE LABEL
ONEOPS         0000015E    DATA LABEL
OPADD          00000562    CODE LABEL
OPASHIFT       0000063A    CODE LABEL
OPASSN         00001730    CODE LABEL
OPBAND         00000622    CODE LABEL
OPBCOM         0000061C    CODE LABEL
OPBOR          00000616    CODE LABEL
OPBTST         0000060A    CODE LABEL
OPBUFO         0000151E    CODE LABEL
OPCAL1         0000169A    CODE LABEL
OPCAL2         000016A6    CODE LABEL
OPCALL         000016A6    CODE LABEL
OPCATCH        000017B0    CODE LABEL
OPCLEAR        000013C2    CODE LABEL
OPCOLOR        00001494    CODE LABEL
OPCOPYT        00000956    CODE LABEL
OPCRLF         00001030    CODE LABEL

OPCSX1         00001258    CODE LABEL
OPCSX2         00001276    CODE LABEL
OPCSX3         00001280    CODE LABEL
OPCSX4         0000128E    CODE LABEL
OPCSX5         00001298    CODE LABEL
OPCSX6         000012B2    CODE LABEL
OPCURG         000012B4    CODE LABEL
OPCURS         0000124A    CODE LABEL
OPDCLR         0000166E    CODE LABEL
OPDEC          00000ACC    CODE LABEL
OPDIRI         000015F6    CODE LABEL
OPDIRO         0000154E    CODE LABEL
OPDISP         00001662    CODE LABEL
OPDISPLAY      --------    CODE IMPORT
OPDIV          00000574    CODE LABEL
OPENFILE       --------    CODE IMPORT
OPERASE        00001430    CODE LABEL
OPERR          00001CE4    CODE LABEL
OPFCLE         00000834    CODE LABEL
OPFONT         00001456    CODE LABEL
OPFSET         00000828    CODE LABEL
OPFSTA         0000177C    CODE LABEL
OPGET          00000840    CODE LABEL
OPGETB         00000852    CODE LABEL
OPGETP         00000764    CODE LABEL
OPGTPT         0000088A    CODE LABEL
OPHLIGHT       00001442    CODE LABEL
OPICAL1        00001688    CODE LABEL
OPICAL2        00001694    CODE LABEL
OPICALL        00001694    CODE LABEL
OPICX1         0000165E    CODE LABEL
OPINC          00000ABE    CODE LABEL
OPINPUT        00000C82    CODE LABEL
OPINTBL        000008EC    CODE LABEL
OPIRES         00001956    CODE LABEL
OPISAV         0000185A    CODE LABEL
OPIXCAL        00001694    CODE LABEL
OPJUMP         000017A4    CODE LABEL
OPLEN          0000007E    EQU
OPLEX          00000B86    CODE LABEL
OPLOC          00000718    CODE LABEL
OPMARG         000014D2    CODE LABEL
OPMOD          00000588    CODE LABEL
OPMOUSEINFO    --------    CODE IMPORT
OPMOVE         000006B6    CODE LABEL
OPMSINFO       00000D36    CODE LABEL
OPMSLMT        00000D52    CODE LABEL
OPMUL          0000056E    CODE LABEL
OPNEXT         000007D0    CODE LABEL
OPNGAM         000027F8    CODE LABEL
OPNOOP         000017AE    CODE LABEL
OPNSFL         000028AC    CODE LABEL
OPORIG         00001B50    CODE LABEL
OPPICI         0000163C    CODE LABEL
OPPICINF       --------    CODE IMPORT
OPPOP          00000A90    CODE LABEL
OPPRIN         00000FE0    CODE LABEL
OPPRNB         00000FF0    CODE LABEL
OPPRNC         00000F98    CODE LABEL
OPPRND         00000FF8    CODE LABEL
OPPRNF         00000A52    CODE LABEL
OPPRNI         0000100E    CODE LABEL
OPPRNN         00000F9C    CODE LABEL
OPPRNR         00001026    CODE LABEL
OPPRNT         000009EC    CODE LABEL
OPPTSI         000008BC    CODE LABEL
OPPUSH         00000A60    CODE LABEL
OPPUT          00000862    CODE LABEL
OPPUTB         00000878    CODE LABEL
OPPUTP         0000079C    CODE LABEL
OPQDLE         00000AFA    CODE LABEL
OPQEQU         0000064C    CODE LABEL
OPQFIR         00000724    CODE LABEL
OPQFSE         00000816    CODE LABEL
OPQGRT         00000600    CODE LABEL

OPQIGR         00000ADA    CODE LABEL
OPQIN          00000754    CODE LABEL
OPQLES         000005F6    CODE LABEL
OPQNEX         0000073C    CODE LABEL
OPQUIT         00001ADC    CODE LABEL
OPQZER         00000664    CODE LABEL
OPRAND         0000059E    CODE LABEL
OPREAD         00000B0C    CODE LABEL
OPREMO         000006DE    CODE LABEL
OPREST         00001996    CODE LABEL
OPRETU         0000173C    CODE LABEL
OPRFAL         00001774    CODE LABEL
OPRSTA         00001778    CODE LABEL
OPRSTT         00001ABA    CODE LABEL
OPRTRU         00001770    CODE LABEL
OPSAVE         0000188E    CODE LABEL
OPSCRN         0000107A    CODE LABEL
OPSCROLL       00001392    CODE LABEL
OPSDX1         00001630    CODE LABEL
OPSET          00000A5C    CODE LABEL
OPSHIFT        00000628    CODE LABEL
OPSOUND        000015FA    CODE LABEL
OPSPLT         0000110A    CODE LABEL
OPSUB          00000568    CODE LABEL
OPTHROW        000017BC    CODE LABEL
OPUSL          00000F94    CODE LABEL
OPVALU         00000A54    CODE LABEL
OPVERI         00001AE0    CODE LABEL
OPWATTR        000011F2    CODE LABEL
OPWGET         000012CE    CODE LABEL
OPWGX1         000012F4    CODE LABEL
OPWGX2         000012F8    CODE LABEL
OPWGX4         00001320    CODE LABEL
OPWGX9         0000132A    CODE LABEL
OPWPOS         0000118A    CODE LABEL
OPWPUT         0000132C    CODE LABEL
OPWPX2         00001346    CODE LABEL
OPWPX4         00001374    CODE LABEL
OPWPX9         0000138C    CODE LABEL
OPWSIZ         000011C8    CODE LABEL
OPXCAL         000016A6    CODE LABEL
OPXPUSH        00000A64    CODE LABEL
OPZWSTR        00000C3C    CODE LABEL
OUTCHR         000025DE    CODE LABEL
OUTFUN         00000014    EQU
OUTMSG         0000273E    CODE LABEL
OUTMSG0        00002720    CODE LABEL
OUTMX1         00002724    CODE LABEL
OUTMX2         00002730    CODE LABEL
OUTMX3         0000273A    CODE LABEL
OUTMX9         00002744    CODE LABEL
PADCHR         00000005    EQU
PAGES          FFFFFFCC    EQU
PAGMIN         00000002    EQU
PAGTAB         FFFFFFD0    EQU
PAGTOT         FFFFFFCA    EQU
PCHKSM         0000001C    EQU
PCHRSET        00000034    EQU
PCLRWRD        0000002C    EQU
PCRCNT         00000030    EQU
PCRFUNC        00000032    EQU
PCX1           00001F8C    CODE LABEL
PCX2           00001FA4    CODE LABEL
PCX3           00001FB0    CODE LABEL
PENDLD         00000004    EQU
PFALSE         000004EE    CODE LABEL
PFLAGS         00000010    EQU
PFOFF          00000028    EQU
PFWRD          00000026    EQU
PGLOTB         0000000C    EQU
PHWRD          00000022    EQU
PICDISP        00002358    CODE LABEL
PICINF         00002342    CODE LABEL
PINTWD         0000001E    EQU
PLBIT          00000006    EQU

PLCLEN         00000000    EQU
PLCTBL         00000036    EQU
PLENTH         0000001A    EQU
PMASK          0000003F    EQU
PMLOCX         00000001    EQU
PMLOCY         00000002    EQU
POBJTB         0000000A    EQU
PPOPX2         00000A9A    CODE LABEL
PPOPX4         00000ABA    CODE LABEL
PPURBT         0000000E    EQU
PRINIT         --------    CODE IMPORT
PRINT          000026CA    CODE LABEL
PRINTX1        000026E2    CODE LABEL
PRLINE         --------    CODE IMPORT
PRNNX1         00000FA8    CODE LABEL
PRNNX2         00000FB4    CODE LABEL
PRNNX3         00000FB8    CODE LABEL
PRNNX4         00000FC6    CODE LABEL
PRNNX5         00000FD0    CODE LABEL
PRNNX6         00000FD2    CODE LABEL
PRNTX1         00000A18    CODE LABEL
PRNTX2         00000A24    CODE LABEL
PRNTX3         00000A50    CODE LABEL
PROP           0000000C    EQU
PSCRWD         00000020    EQU
PSERNM         00000012    EQU
PSNLEN         00000020    EQU
PSOFF          0000002A    EQU
PSTART         00000006    EQU
PSX1           00001CF6    CODE LABEL
PSX10          00001D82    CODE LABEL
PSX11          00001D96    CODE LABEL
PSX12          00001DA0    CODE LABEL
PSX13          00001DA6    CODE LABEL
PSX14          00001DAA    CODE LABEL
PSX15          00001DAE    CODE LABEL
PSX16          00001DB0    CODE LABEL
PSX2           00001D00    CODE LABEL
PSX3           00001D0A    CODE LABEL
PSX4           00001D2E    CODE LABEL
PSX5           00001D3E    CODE LABEL
PSX6           00001D4A    CODE LABEL
PSX7           00001D62    CODE LABEL
PSX8           00001D68    CODE LABEL
PSX9           00001D7A    CODE LABEL
PTAWRD         000003FE    CODE LABEL
PTCHARS        0000002E    EQU
PTLNX1         0000201E    CODE LABEL
PTLNX2         00002024    CODE LABEL
PTRUE          000004F2    CODE LABEL
PTRUE1         000004F4    CODE LABEL
PTRUX1         00000500    CODE LABEL
PTRUX3         0000051A    CODE LABEL
PTRUX4         00000526    CODE LABEL
PTRUX5         0000052E    CODE LABEL
PTRUX6         00000538    CODE LABEL
PTSBKS         000028F0    CODE LABEL
PTSBX1         00002926    CODE LABEL
PTSBX2         0000292E    CODE LABEL
PTSIX2         000008DE    CODE LABEL
PTSIX4         000008E4    CODE LABEL
PURBOT         FFFFFFF8    EQU
PUTCHR         00001F84    CODE LABEL
PUTLIN         00001FF6    CODE LABEL
PUTLIN1        00001FEE    CODE LABEL
PUTNEW         00001F82    CODE LABEL
PUTPX1         000007A6    CODE LABEL
PUTPX2         000007AA    CODE LABEL
PUTPX3         000007C0    CODE LABEL
PUTPX4         000007CA    CODE LABEL
PUTSTR         00001CEE    CODE LABEL
PUTVAL         000004E0    CODE LABEL
PUTVAR         000004B0    CODE LABEL
PUTVX1         000004B8    CODE LABEL
PUTVX2         000004CA    CODE LABEL

PVERS1         00000000    EQU
PVERS2         00000001    EQU
PVOCTB         00000008    EQU
PVWRD          00000024    EQU
PWRDTB         00000018    EQU
PZRKID         00000002    EQU
QCX0           00001EF6    CODE LABEL
QCX1           00001F16    CODE LABEL
QCX10          00001F80    CODE LABEL
QCX2           00001F1E    CODE LABEL
QCX2A          00001F24    CODE LABEL
QCX3           00001F28    CODE LABEL
QCX4           00001F34    CODE LABEL
QCX5           00001F3C    CODE LABEL
QCX6           00001F50    CODE LABEL
QCX7           00001F5E    CODE LABEL
QCX8           00001F68    CODE LABEL
QCX9           00001F78    CODE LABEL
QDCHR          00001FB6    CODE LABEL
QEQUX1         00000654    CODE LABEL
QEQUX2         00000660    CODE LABEL
QFOFF          FFFFFF1E    EQU
QIG1           00000AEA    CODE LABEL
QIG2           00000AF2    CODE LABEL
QPLEN          00000020    EQU
QSOFF          FFFFFF1A    EQU
QUECHR         00001EBE    CODE LABEL
QUITGAME       --------    CODE IMPORT
RANDX1         000005D8    CODE LABEL
RANDX2         000005DA    CODE LABEL
RANDX3         000005E0    CODE LABEL
RANDX4         000005EE    CODE LABEL
RBRKS          FFFFFFE4    EQU
RCONST         FFFFFFAC    EQU
RCYCLE         FFFFFFAE    EQU
RDBOS          FFFFFF78    EQU
RDEOS          FFFFFF74    EQU
RDERR          00000E66    CODE LABEL
RDLX1          00000D66    CODE LABEL
RDLX10         00000DDE    CODE LABEL
RDLX12         00000DEA    CODE LABEL
RDLX14         00000DF0    CODE LABEL
RDLX16         00000DF6    CODE LABEL
RDLX2          00000D74    CODE LABEL
RDLX20         00000E04    CODE LABEL
RDLX22         00000E04    CODE LABEL
RDLX4          00000D8E    CODE LABEL
RDLX5          00000D96    CODE LABEL
RDLX6          00000DAA    CODE LABEL
RDLX8          00000DC2    CODE LABEL
RDLX9          00000DD6    CODE LABEL
RDLX9A         00000DDC    CODE LABEL
RDRET          FFFFFF70    EQU
RDWSTR         FFFFFF82    EQU
RDX4           00000B80    CODE LABEL
RDZSTR         FFFFFF7C    EQU
READFILE       --------    CODE IMPORT
READLN         00000D58    CODE LABEL
RELABS         00000396    CODE LABEL
REMOX1         000006FC    CODE LABEL
REMOX2         0000070E    CODE LABEL
REMOX3         00000716    CODE LABEL
RES1           00001A24    CODE LABEL
RESERR         00001A94    CODE LABEL
RESSTA         00001832    CODE LABEL
RESTOK         00001A74    CODE LABEL
RESTRT         00000238    CODE LABEL
RESX10         00001A62    CODE LABEL
RESX12         00001A86    CODE LABEL
RESX13         00001A8A    CODE LABEL
RESX14         00001A9A    CODE LABEL
RESX15         00001AA2    CODE LABEL
RESX16         00001AAA    CODE LABEL
RESX2          00001A12    CODE LABEL
RETFUN         00000018    EQU

RLBSX1         000003A0    CODE LABEL
RLBSX2         000003AA    CODE LABEL
ROLLX1         000013B8    CODE LABEL
RSEED1         FFFFFFB2    EQU
RSEED2         FFFFFFB0    EQU
RSTTX1         00001AD2    CODE LABEL
RTIME          FFFFFF3A    EQU
SAVEOK         00001938    CODE LABEL
SAVERR         00001950    CODE LABEL
SAVFIL         FFFFFEEA    EQU
SAVSTA         00001810    CODE LABEL
SBFX0          000021C4    CODE LABEL
SBNDX4         000021FC    CODE LABEL
SBNDX6         00002200    CODE LABEL
SCALE2XPIC     00002BAC    CODE LABEL EXPORT
SCALE2XROW     00002BFE    CODE LABEL
SCHSIZ         00002416    CODE LABEL
SCOUNT         FFFFFF22    EQU
SCRCHR         00002028    CODE LABEL
SCRCX1         0000203A    CODE LABEL
SCRINIT        00002788    CODE LABEL
SCRINP         00002064    CODE LABEL
SCRIX1         00002076    CODE LABEL
SCRIX2         0000207E    CODE LABEL
SCRIX3         00002086    CODE LABEL
SCRLEN         00000041    EQU
SCRLIN         00002048    CODE LABEL
SCRNAM         0000208C    CODE LABEL
SCRNX9         00001108    CODE LABEL
SCROLL         --------    CODE IMPORT
SCROUT         00002798    CODE LABEL
SCURX2         0000228A    CODE LABEL
SCURX4         000022A4    CODE LABEL
SCXPX1         00002BD4    CODE LABEL
SCXPX2         00002BF2    CODE LABEL
SCXRX1         00002C04    CODE LABEL
SCXRX2         00002C16    CODE LABEL
SCXRX3         00002C22    CODE LABEL
SCXRX4         00002C2A    CODE LABEL
SCXRX9         00002C38    CODE LABEL
SDFX2          00001CD8    CODE LABEL
SDFX4          00001CDE    CODE LABEL
SETATTR        000022D2    CODE LABEL
SETBOUNDS      000021CC    CODE LABEL
SETBUF         000021B0    CODE LABEL
SETCOLOR       --------    CODE IMPORT
SETCURS        0000226E    CODE LABEL
SETDEF         00001CC2    CODE LABEL
SETFONT        000022C2    CODE LABEL
SETHL          000022D8    CODE LABEL
SETMARG        00002302    CODE LABEL
SETUNDO        0000230E    CODE LABEL
SETUPI         000024C6    CODE LABEL
SETUPINPUT     --------    CODE IMPORT
SETUX1         000024D8    CODE LABEL
SFREAD         000028CE    CODE LABEL
SFUNC          FFFFFF24    EQU
SFWRIT         000028FC    CODE LABEL
SH0            00000000    EQU
SH2            00000020    EQU
SH4            00000040    EQU
SH6            00000060    EQU
SHFX1          00000632    CODE LABEL
SHOWVE         FFFFFED6    EQU
SHRINK75       00002B28    CODE LABEL EXPORT
SHRINKONE      00002B70    CODE LABEL
SIZEQP         00001EB6    CODE LABEL
SIZFUN         00000010    EQU
SK75X1         00002B3E    CODE LABEL
SK75X2         00002B64    CODE LABEL
SKIP           00000000    EQU
SKONX1         00002B76    CODE LABEL
SKPCNT         00000032    EQU
SPLTX1         0000111A    CODE LABEL
SPLTX2         00001162    CODE LABEL

SPLTX5         00001188    CODE LABEL
SQRWX1         00002A20    CODE LABEL
SQUE           FFFFFF50    EQU
SQZROW         00002A14    CODE LABEL EXPORT
SS2X1          000027D2    CODE LABEL
START1         00000252    CODE LABEL
STIPPIC        00002AB8    CODE LABEL EXPORT
STIPROW        00002AEC    CODE LABEL
STKBOT         FFFFFFBE    EQU
STKLEN         00000400    EQU
STPPX1         00002AD2    CODE LABEL
STPRX1         00002AEE    CODE LABEL
STPTAB         00000356    DATA LABEL
STRLEN         00000386    CODE LABEL
STRLX1         00000388    CODE LABEL
STRX1          0000000C    CODE LABEL
STRX10         000001C6    CODE LABEL
STRX11         000001C8    CODE LABEL
STRX12         000001D4    CODE LABEL
STRX16         00000202    CODE LABEL
STRX17         0000021E    CODE LABEL
STRX2          00000040    CODE LABEL
STRX3          0000004A    CODE LABEL
STRX3A         0000006A    CODE LABEL
STRX3B         00000082    CODE LABEL
STRX4          000000BA    CODE LABEL
STRX6          00000128    CODE LABEL
SUBVER         00000002    DATA LABEL
SVX10          0000192A    CODE LABEL
SVX12          0000193E    CODE LABEL
SVX14          00001946    CODE LABEL
SVX2           000018EA    CODE LABEL
SYSIN1         00002374    CODE LABEL
SYSIN2         000027AC    CODE LABEL
SYSX1          00002390    CODE LABEL
TABCHR         00001542    CODE LABEL
TABOUT         FFFFFF4C    EQU
TABPTR         FFFFFF48    EQU
TCHECK         00000F70    CODE LABEL
TCHX2          00000F8A    CODE LABEL
TCHX3          00000F8E    CODE LABEL
TCLOCK         FFFFFF28    EQU
TCOUNT         FFFFFF26    EQU
TFUNC          FFFFFF2C    EQU
THRX1          000017D0    CODE LABEL
TIME60         000023FE    CODE LABEL
TIMEMD         FFFFFFFC    EQU
TNEX1          00000F6E    CODE LABEL
TNEXT          00000F68    CODE LABEL
TOPSP          FFFFFFC2    EQU
TOTCOLS        --------    DATA IMPORT
TOTROWS        --------    DATA IMPORT
TRESET         00000F5A    CODE LABEL
TSTWFLG        00001070    CODE LABEL
TTYIN          0000259E    CODE LABEL
TTYOUT         000025E8    CODE LABEL
TTYOX1         000025F8    CODE LABEL
TTYOX2         00002602    CODE LABEL
TTYX1          000025AA    CODE LABEL
TWAIT          FFFFFF2E    EQU
TWOOPS         0000017E    DATA LABEL
UNDOFLAG       --------    DATA IMPORT
VCHARS         00000009    EQU
VCOMP          00000F50    CODE LABEL
VCPX1          00000F52    CODE LABEL
VERX0          00001AFA    CODE LABEL
VERX05         00001B06    CODE LABEL
VERX1          00001B2A    CODE LABEL
VERX2          00001B4C    CODE LABEL
VIECHO         FFFFFF58    EQU
VIFILE         FFFFFF5C    EQU
VIKEYB         FFFFFF5E    EQU
VOBUFF         FFFFFF5A    EQU
VOCBEG         FFFFFFD8    EQU
VOCEND         FFFFFFD4    EQU

VOCONS         FFFFFF68    EQU
VOCTAB         FFFFFFF4    EQU
VOFILE         FFFFFF60    EQU
VOPRNT         FFFFFF66    EQU
VOSTAT         FFFFFF64    EQU
VOTABL         FFFFFF62    EQU
VWBOFF         FFFFFF6C    EQU
VWLEN          FFFFFFDE    EQU
VWORDS         FFFFFFDC    EQU
VWSORT         FFFFFF6E    EQU
WATTR          0000001C    EQU
WATTX1         00001222    CODE LABEL
WATTX2         00001226    CODE LABEL
WATTX3         0000122A    CODE LABEL
WATTX4         0000122C    CODE LABEL
WATTX5         0000122E    CODE LABEL
WATTX6         00001248    CODE LABEL
WBLKLEN        00000022    EQU
WBLOCKP        FFFFFEF4    EQU
WBOUNDS        00001052    CODE LABEL
WCOLOR         00000016    EQU
WCRCNT         00000012    EQU
WCRINT         00000010    EQU
WCSIZ          00000020    EQU
WFBUFF         00000008    EQU
WFONTID        00000018    EQU
WFONTYX        0000001A    EQU
WFSCRL         00000002    EQU
WFSCRP         00000004    EQU
WFWRAP         00000001    EQU
WHLIGHT        00000014    EQU
WLCNT          0000001E    EQU
WLMARG         0000000C    EQU
WPOSX1         000011A2    CODE LABEL
WPOSX2         000011AA    CODE LABEL
WPOSX9         000011C6    CODE LABEL
WPRCHK         00002938    CODE LABEL
WPRCX1         00002946    CODE LABEL
WRDOFF         FFFFFF6A    EQU
WRDTAB         FFFFFFE8    EQU
WRITEFILE      --------    CODE IMPORT
WRMARG         0000000E    EQU
WSIZX3         000011F0    CODE LABEL
WXCURS         0000000A    EQU
WXPOS          00000002    EQU
WXSIZE         00000006    EQU
WYCURS         00000008    EQU
WYPOS          00000000    EQU
WYSIZE         00000004    EQU
XMOUSE         --------    DATA IMPORT
XPSHX2         00000A8C    CODE LABEL
YMOUSE         --------    DATA IMPORT
ZALLOC         --------    CODE IMPORT
ZBASE          00000000    CODE LABEL
ZBEEP          0000243A    CODE LABEL
ZCHARS         00000006    EQU
ZCHRS          00000240    DATA LABEL
ZEROPS         0000013E    DATA LABEL
ZFONT          --------    CODE IMPORT
ZLOCS          FFFFFFB4    EQU
ZMVERS         00000006    EQU
ZORKID         FFFFFFFE    EQU
ZPC1           FFFFFFBC    EQU
ZPC2           FFFFFFBA    EQU
ZSOUND         --------    CODE IMPORT
ZSTART         00000002    CODE LABEL EXPORT
ZVARS          00000352    DATA LABEL
ZVLEN          00000150    EQU
ZWARN          00002748    CODE LABEL
ZWORD          00001E18    CODE LABEL
ZWSTR          00000C5A    CODE LABEL
ZWSX1          00000C80    CODE LABEL
ZWX1           00001E22    CODE LABEL
ZWX2           00001E38    CODE LABEL
ZWX3           00001E58    CODE LABEL

ZWX4           00001E60    CODE LABEL
ZWX6           00001E68    CODE LABEL
ZWX7           00001E74    CODE LABEL
_CLR_MEM       000029D8    CODE LABEL
_MOV_MEM       0000298A    CODE LABEL

#0001                   00000000    CODE MODULE ENTRY
ABORTERR                FFFFFFE5    EQU
ACCCLEAR                00000049    EQU
ACCCOPY                 00000047    EQU
ACCCURSOR               00000042    EQU
ACCCUT                  00000046    EQU
ACCEVENT                00000040    EQU
ACCMENU                 00000043    EQU
ACCPASTE                00000048    EQU
ACCRUN                  00000041    EQU
ACCUNDO                 00000044    EQU
ACTIVATEEVT             00000008    EQU
ACTIVDEV                00000005    EQU
ACTIVEFLAG              00000000    EQU
ACTLCMD                 00000004    EQU
ADBADDRMASK             00FF0000    EQU
ADBBASE                 00000CF8    EQU
ADDREFFAILED            FFFFFF3D    EQU
ADDRESFAILED            FFFFFF3E    EQU
AFPACCESSDENIED         FFFFEC78    EQU
AFPAUTHCONTINUE         FFFFEC77    EQU
AFPBADUAM               FFFFEC76    EQU
AFPBADVERSNUM           FFFFEC75    EQU
AFPBITMAPERR            FFFFEC74    EQU
AFPCALLNOTSUPPORTED     FFFFEC60    EQU
AFPCANTMOVE             FFFFEC73    EQU
AFPCANTRENAME           FFFFEC5C    EQU
AFPDENYCONFLICT         FFFFEC72    EQU
AFPDIRNOTEMPTY          FFFFEC71    EQU
AFPDIRNOTFOUND          FFFFEC5B    EQU
AFPDISKFULL             FFFFEC70    EQU
AFPEOFERROR             FFFFEC6F    EQU
AFPFILEBUSY             FFFFEC6E    EQU
AFPFLATVOL              FFFFEC6D    EQU
AFPICONTYPEERROR        FFFFEC5A    EQU
AFPITEMNOTFOUND         FFFFEC6C    EQU
AFPLOCKERR              FFFFEC6B    EQU
AFPMISCERR              FFFFEC6A    EQU
AFPNOMORELOCKS          FFFFEC69    EQU
AFPNOSERVER             FFFFEC68    EQU
AFPOBJECTEXISTS         FFFFEC67    EQU
AFPOBJECTNOTFOUND       FFFFEC66    EQU
AFPOBJECTTYPEERR        FFFFEC5F    EQU
AFPPARMERR              FFFFEC65    EQU
AFPRANGENOTLOCKED       FFFFEC64    EQU
AFPRANGEOVERLAP         FFFFEC63    EQU
AFPSERVERGOINGDOWN      FFFFEC5D    EQU
AFPSESSCLOSED           FFFFEC62    EQU
AFPTOOMANYFILESOPEN     FFFFEC5E    EQU
AFPUSERNOTAUTH          FFFFEC61    EQU
ALARMSTATE              0000021F    EQU
ALLOCPTR                00000030    EQU
ALPHALOCK               0000000A    EQU
ALRMFLENABLE            00000000    EQU
APP1EVT                 0000000C    EQU
APP2EVT                 0000000D    EQU
APP3EVT                 0000000E    EQU
APP4EVT                 0000000F    EQU
APPLLIMIT               00000130    EQU
APPLZONE                000002AA    EQU
ARDCMD                  00000002    EQU
ASCBASE                 00000CC0    EQU
ASPBADVERSNUM           FFFFFBD6    EQU
ASPBUFTOOSMALL          FFFFFBD5    EQU
ASPNOACK                FFFFFBCD    EQU
ASPNOMORESESS           FFFFFBD4    EQU
ASPNOSERVERS            FFFFFBD3    EQU
ASPPARAMERR             FFFFFBD2    EQU
ASPSERVERBUSY           FFFFFBD1    EQU
ASPSESSCLOSED           FFFFFBD0    EQU
ASPSIZEERR              FFFFFBCF    EQU
ASPTOOMANY              FFFFFBCE    EQU
ASTSCMD                 00000005    EQU
ASYNC                   00000400    EQU
ASYNCTRPBIT             0000000A    EQU

ATPBADRSP               FFFFF3DD    EQU
ATPLENERR               FFFFF3DE    EQU
AUTOKEYEVT              00000005    EQU
AUTOPOP                 00000400    EQU
AWRCMD                  00000003    EQU
BADATPSKT               FFFFFBB5    EQU
BADBTSLPERR             FFFFFFBA    EQU
BADBUFFNUM              FFFFFBB4    EQU
BADCHANNEL              FFFFFF33    EQU
BADCKSMERR              FFFFFFBB    EQU
BADDBTSLP               FFFFFFB7    EQU
BADDCKSUM               FFFFFFB8    EQU
BADFORMAT               FFFFFF32    EQU
BADMDBERR               FFFFFFC4    EQU
BADMOVERR               FFFFFF86    EQU
BADUNITERR              FFFFFFEB    EQU
BDNAMERR                FFFFFFDB    EQU
BGNSLOTREF              FFFFFFCF    EQU
BGNSLOTUNIT             00000030    EQU
BKLIM                   00000000    EQU
BLKDATA                 00000008    EQU
BOOTDRIVE               00000210    EQU
BREAKRECD               FFFFFFA6    EQU
BTNSTATE                00000007    EQU
BUF2SMALLERR            FFFFF3E3    EQU
BUFPTR                  0000010C    EQU
BUFTGDATE               00000304    EQU
BUFTGFBKNUM             00000302    EQU
BUFTGFFLG               00000300    EQU
BUFTGFNUM               000002FC    EQU
BUILDSTIPS              00002A5C    CODE LABEL EXPORT
BUSERRVCT               00000008    EQU
BUTTONMSG               00000013    EQU
CANTSTEPERR             FFFFFFB5    EQU
CARETTIME               000002F4    EQU
CASE                    00000400    EQU
CBNOTFOUND              FFFFFBB2    EQU
CDEVERR                 FFFFFF65    EQU
CDEVGENERR              FFFFFFFF    EQU
CDEVMEMERR              00000000    EQU
CDEVRESERR              00000001    EQU
CDEVUNSET               00000003    EQU
CHARCODEMASK            000000FF    EQU
CHOOSERID               00000001    EQU
CHUNKYDEPTH             00000D60    EQU
CKSUMERR                FFFFF3E1    EQU
CLEAR                   00000200    EQU
CLEARBIT                00000009    EQU
CLKRDERR                FFFFFFAB    EQU
CLKWRERR                FFFFFFAA    EQU
CLOSEDEV                00000002    EQU
CLOSERR                 FFFFFFE8    EQU
CMATCHERR               FFFFFF6A    EQU
CMDKEY                  00000008    EQU
CMOREMASTERS            00000008    EQU
CNOMEMERR               FFFFFF68    EQU
CNTEMPTY                00000020    EQU
CNTHANDLES              00000022    EQU
CNTNREL                 0000001C    EQU
CNTREL                  00000018    EQU
COLLINES                00000C22    EQU
CONTROLERR              FFFFFFEF    EQU
CONTROLKEY              0000000C    EQU
CORERR                  FFFFFFFD    EQU
CPROTECTERR             FFFFFF66    EQU
CPUFLAG                 0000012F    EQU
CQDGLOBALS              00000CCC    EQU
CRANGEERR               FFFFFF67    EQU
CRESERR                 FFFFFF64    EQU
CROSSCURSOR             00000002    EQU
CRSRADDR                00000888    EQU
CRSRBASE                00000898    EQU
CRSRBUSY                000008CD    EQU
CRSRCOUPLE              000008CF    EQU
CRSRDEVICE              0000089C    EQU

CRSRNEW                 000008CE    EQU
CRSROBSCURE             000008D2    EQU
CRSRPIN                 00000834    EQU
CRSRPTR                 00000D62    EQU
CRSRRECT                0000083C    EQU
CRSRROW                 000008AC    EQU
CRSRSAVE                0000088C    EQU
CRSRSCALE               000008D3    EQU
CRSRSTATE               000008D0    EQU
CRSRTHRESH              000008EC    EQU
CRSRVIS                 000008CC    EQU
CSCODE                  0000001A    EQU
CSPARAM                 0000001C    EQU
CTEMPMEMERR             FFFFFF69    EQU
CURAPNAME               00000910    EQU
CURAPREFNUM             00000900    EQU
CURDIRSTORE             00000398    EQU
CURJTOFFSET             00000934    EQU
CURPAGEOPTION           00000936    EQU
CURPITCH                00000280    EQU
CURRENTA5               00000904    EQU
CURSTACKBASE            00000908    EQU
DATAVERERR              FFFFFFBC    EQU
DCEEXTERR               FFFFFFE2    EQU
DCINIT                  00000019    EQU
DCREAD                  00000000    EQU
DCSCAN                  0000001A    EQU
DCSTATUS                00000003    EQU
DCTLCURTICKS            0000001A    EQU
DCTLDELAY               00000022    EQU
DCTLDEVBASE             0000002A    EQU
DCTLDRIVER              00000000    EQU
DCTLEMASK               00000024    EQU
DCTLENABLE              00000002    EQU
DCTLENTRYSIZE           00000034    EQU
DCTLEXTDEV              00000032    EQU
DCTLFLAGS               00000004    EQU
DCTLMENU                00000026    EQU
DCTLOWNER               0000002E    EQU
DCTLPOSITION            00000010    EQU
DCTLQHEAD               00000008    EQU
DCTLQTAIL               0000000C    EQU
DCTLQUEUE               00000006    EQU
DCTLREFNUM              00000018    EQU
DCTLSLOT                00000028    EQU
DCTLSLOTID              00000029    EQU
DCTLSTORAGE             00000014    EQU
DCTLWINDOW              0000001E    EQU
DCWRITE                 00000001    EQU
DDPLENERR               FFFFFFA4    EQU
DDPSKTERR               FFFFFFA5    EQU
DEACTIVDEV              00000006    EQU
DEFLTSTACK              00000322    EQU
DESELECTMSG             00000010    EQU
DESKCPAT                00000CD8    EQU
DESKPATDISABLE          00000CDC    EQU
DEVICELIST              000008A8    EQU
DFLTSTACKSIZE           00002000    EQU
DINSTERR                FFFFFFE6    EQU
DIRFULERR               FFFFFFDF    EQU
DIRNFERR                FFFFFF88    EQU
DISKINSERTEVT           00000007    EQU
DNEEDGOODBYE            00000004    EQU
DNEEDLOCK               00000006    EQU
DNEEDTIME               00000005    EQU
DOPENED                 00000005    EQU
DOUBLETIME              000002F0    EQU
DQDRIVE                 00000006    EQU
DQDRVSZ                 0000000C    EQU
DQDRVSZ2                0000000E    EQU
DQFSID                  0000000A    EQU
DQREFNUM                00000008    EQU
DRAMBASED               00000006    EQU
DRDRIVENUM              00000000    EQU
DREADENABLE             00000000    EQU

DREMOVERR               FFFFFFE7    EQU
DRREFNUM                00000002    EQU
DRVQHDR                 00000308    EQU
DRVQTYPE                00000003    EQU
DRVRACTIVE              00000007    EQU
DRVRCLOSE               00000010    EQU
DRVRCTL                 0000000C    EQU
DRVRDELAY               00000002    EQU
DRVREMASK               00000004    EQU
DRVRFLAGS               00000000    EQU
DRVRMENU                00000006    EQU
DRVRNAME                00000012    EQU
DRVROPEN                00000008    EQU
DRVRPRIME               0000000A    EQU
DRVRSTATUS              0000000E    EQU
DRVSTSCODE              00000008    EQU
DSALERTRECT             000003F8    EQU
DSALERTTAB              000002BA    EQU
DSBADSANEOPCODE         00000051    EQU
DSBADSLOTINT            00000033    EQU
DSCTRADJ                00000DA8    EQU
DSDISKERRS              00000014    EQU
DSDISKINPLACE           00000003    EQU
DSDQDRIVE               0000000C    EQU
DSDQFSID                00000010    EQU
DSDQREFNUM              0000000E    EQU
DSDQVERS                0000000A    EQU
DSDRAWPROC              00000334    EQU
DSDRVCHAR               0000001A    EQU
DSDRVMANF               00000018    EQU
DSDRVMISC               0000001C    EQU
DSDRVS1                 00000014    EQU
DSDRVSIZE               00000012    EQU
DSDRVTYPE               00000016    EQU
DSERRCODE               00000AF0    EQU
DSHMENUFINDERR          00000056    EQU
DSINSTALLED             00000004    EQU
DSKERR                  00000142    EQU
DSKFULERR               FFFFFFDE    EQU
DSKRFN                  0000FFFB    EQU
DSKVERIFY               0000012C    EQU
DSMBARNFND              00000055    EQU
DSQLINK                 00000006    EQU
DSSIDES                 00000005    EQU
DSTATENABLE             00000003    EQU
DSTRACK                 00000000    EQU
DSTWOSIDEFMT            00000012    EQU
DSWNDUPDATE             0000015D    EQU
DSWRITEPROT             00000002    EQU
DTADDR                  00000008    EQU
DTDAY                   00000004    EQU
DTDAYOFWEEK             0000000C    EQU
DTFLAGS                 00000006    EQU
DTHOUR                  00000006    EQU
DTLINK                  00000000    EQU
DTMINUTE                00000008    EQU
DTMONTH                 00000002    EQU
DTPARM                  0000000C    EQU
DTQELSIZE               00000014    EQU
DTQFLAGS                00000D92    EQU
DTQTYPE                 00000007    EQU
DTQUEUE                 00000D92    EQU
DTRESRVD                00000010    EQU
DTSECOND                0000000A    EQU
DTSKQHDR                00000D94    EQU
DTSKQTAIL               00000D98    EQU
DTTYPE                  00000004    EQU
DTYEAR                  00000000    EQU
DUPFNERR                FFFFFFD0    EQU
DWRITENABLE             00000001    EQU
EJECTCODE               00000007    EQU
EJECTNOTIFY             00000338    EQU
ENDSRTPTR               00000DB4    EQU
ENV512KE                00000001    EQU
ENV68000                00000001    EQU

ENV68010                00000002    EQU
ENV68020                00000003    EQU
ENVAEXTENDKBD           00000004    EQU
ENVBADVERS              FFFFEA83    EQU
ENVCPUUNKNOWN           00000000    EQU
ENVMAC                  FFFFFFFF    EQU
ENVMACANDPAD            00000002    EQU
ENVMACHUNKNOWN          00000000    EQU
ENVMACII                00000004    EQU
ENVMACKBD               00000001    EQU
ENVMACPLUS              00000002    EQU
ENVMACPLUSKBD           00000003    EQU
ENVNOTPRESENT           FFFFEA84    EQU
ENVSE                   00000003    EQU
ENVSTANDADBKBD          00000005    EQU
ENVUNKNOWNKBD           00000000    EQU
ENVVERSTOOBIG           FFFFEA82    EQU
ENVXL                   FFFFFFFE    EQU
EOFERR                  FFFFFFD9    EQU
EVENTQUEUE              0000014A    EQU
EVERYEVENT              FFFFFFFF    EQU
EVTBLKSIZE              00000010    EQU
EVTBUFCNT               00000154    EQU
EVTMBUT                 0000000F    EQU
EVTMESSAGE              00000002    EQU
EVTMETA                 0000000E    EQU
EVTMOUSE                0000000A    EQU
EVTNOTENB               00000001    EQU
EVTNUM                  00000000    EQU
EVTQBLKSIZE             00000016    EQU
EVTQMBUT                00000015    EQU
EVTQMESSAGE             00000008    EQU
EVTQMETA                00000014    EQU
EVTQWHAT                00000006    EQU
EVTQWHEN                0000000C    EQU
EVTQWHERE               00000010    EQU
EVTTICKS                00000006    EQU
EVTYPE                  00000004    EQU
EXCESSCOLLSNS           FFFFFFA1    EQU
EXPANDMEM               000002B6    EQU
EXPANDMEMREC            00000000    TEMPLATE
EXPANDSIZE              00000040    EQU
EXTFSERR                FFFFFFC6    EQU
EXTRACTERR              FFFFF3E0    EQU
EXTSTSDT                000002BE    EQU
EZIP                    00000001    EQU
FALSE32B                00000000    EQU
FBSYERR                 FFFFFFD1    EQU
FCHECKING               00000001    EQU
FDCOMMENT               0000000A    EQU
FDCREATOR               00000004    EQU
FDESKTOP                FFFFFFFE    EQU
FDFLAGS                 00000008    EQU
FDFLDR                  0000000E    EQU
FDICONID                00000000    EQU
FDISK                   00000000    EQU
FDLOCATION              0000000A    EQU
FDPUTAWAY               0000000C    EQU
FDTYPE                  00000000    EQU
FDUNUSED                00000002    EQU
FHASBUNDLE              00002000    EQU
FILLCSPEC               00002A38    CODE LABEL EXPORT
FILLLISTMSG             0000000D    EQU
FINVISIBLE              00004000    EQU
FIRSTDSKERR             FFFFFFAC    EQU
FLAGS                   00000016    EQU
FLCKDERR                FFFFFFD3    EQU
FMT1ERR                 FFFFFFAE    EQU
FMT2ERR                 FFFFFFAD    EQU
FMULTI                  00000000    EQU
FNFERR                  FFFFFFD5    EQU
FNOPNERR                FFFFFFDA    EQU
FNORVRALLOC             00000005    EQU
FNSELCOMPCT             00000004    EQU
FNSELPURGE              00000006    EQU

FONCHECK                00000000    EQU
FONDESK                 00000001    EQU
FONTDECERROR            FFFFFFC0    EQU
FONTNOTDECLARED         FFFFFFBF    EQU
FONTSUBERR              FFFFFFBE    EQU
FRCOMMENT               0000000A    EQU
FRELATEND               00000007    EQU
FRFLAGS                 00000008    EQU
FRLOCATION              0000000A    EQU
FROPENCHAIN             00000004    EQU
FRPUTAWAY               0000000C    EQU
FRRECT                  00000000    EQU
FRSCROLL                00000000    EQU
FRUNUSED                00000008    EQU
FRVIEW                  0000000E    EQU
FSATMARK                00000000    EQU
FSCTCNID                00000004    EQU
FSCURPERM               00000000    EQU
FSFROMLEOF              00000002    EQU
FSFROMMARK              00000003    EQU
FSFROMSTART             00000001    EQU
FSQTYPE                 00000005    EQU
FSRDPERM                00000001    EQU
FSRDWRPERM              00000003    EQU
FSRDWRSHPERM            00000004    EQU
FSRNERR                 FFFFFFC5    EQU
FSRTDIRID               00000002    EQU
FSRTPARID               00000001    EQU
FSUSRCNID               00000010    EQU
FSWRPERM                00000002    EQU
FSXTCNID                00000003    EQU
FTRASH                  FFFFFFFD    EQU
GDBADDEV                FFFFFFEE    EQU
GETPARAM                000001E4    EQU
GETSELMSG               0000000E    EQU
GFPERR                  FFFFFFCC    EQU
GOODBYE                 FFFFFFFF    EQU
GZMOVEHND               00000330    EQU
GZPROC                  00000010    EQU
GZROOTHND               00000328    EQU
GZROOTPTR               0000032C    EQU
HANDLE                  00000004    EQU
HEAPDATA                00000034    EQU
HEAPEND                 00000114    EQU
HFSTFREE                00000008    EQU
HIHEAPMARK              00000BAE    EQU
HIKEYLAST               00000216    EQU
HILITEMODE              00000938    EQU
HILITERGB               00000DA0    EQU
HITDEV                  00000001    EQU
HMENUFINDERR            FFFFFF81    EQU
HPCHK                   00000316    EQU
I2CRANGEERR             FFFFFFEF    EQU
IAZNOTIFY               0000033C    EQU
IBEAMCURSOR             00000001    EQU
ICONTLADDR              00000DAC    EQU
IIOABORTERR             FFFFFFE5    EQU
IMMED                   00000200    EQU
INDTQ                   00000006    EQU
INITDEV                 00000000    EQU
INITIWMERR              FFFFFFB3    EQU
INTFLAG                 0000015F    EQU
INTLSPEC                00000BA0    EQU
INVBL                   00000006    EQU
IOACTCOUNT              00000028    EQU
IOALBLST                00000038    EQU
IOBUFFER                00000020    EQU
IOBYTECOUNT             00000024    EQU
IOCMDADDR               00000008    EQU
IOCOMPLETION            0000000C    EQU
IODIRFLG                00000004    EQU
IODIRID                 00000030    EQU
IODRBKDAT               00000050    EQU
IODRCRDAT               00000048    EQU
IODRDIRID               00000030    EQU

IODRFNDRINFO            00000054    EQU
IODRMDDAT               0000004C    EQU
IODRNMFLS               00000034    EQU
IODRPARID               00000064    EQU
IODRUSRWDS              00000020    EQU
IODRVNUM                00000016    EQU
IODRVREVT               0000000B    EQU
IOERR                   FFFFFFDC    EQU
IOFCBCLPSIZ             00000036    EQU
IOFCBCRPS               00000030    EQU
IOFCBEOF                00000028    EQU
IOFCBFILLER1            0000001E    EQU
IOFCBFLAGS              00000024    EQU
IOFCBFLNM               00000020    EQU
IOFCBINDX               0000001C    EQU
IOFCBPARID              0000003A    EQU
IOFCBPLEN               0000002C    EQU
IOFCBQELSIZE            0000003E    EQU
IOFCBSTBLK              00000026    EQU
IOFCBVREFNUM            00000034    EQU
IOFDIRINDEX             0000001C    EQU
IOFFLNUM                00000030    EQU
IOFFLTYPE               0000001F    EQU
IOFILENAME              00000012    EQU
IOFILETYPE              0000001A    EQU
IOFLAGS                 00000020    EQU
IOFLATTRIB              0000001E    EQU
IOFLBKDAT               00000050    EQU
IOFLCLPSIZ              00000068    EQU
IOFLCRDAT               00000048    EQU
IOFLLGLEN               00000036    EQU
IOFLMDDAT               0000004C    EQU
IOFLPARID               00000064    EQU
IOFLPYLEN               0000003A    EQU
IOFLRLGLEN              00000040    EQU
IOFLRPYLEN              00000044    EQU
IOFLRSTBLK              0000003E    EQU
IOFLSTBLK               00000034    EQU
IOFLUSRWDS              00000020    EQU
IOFLXFNDRINFO           00000054    EQU
IOFQELSIZE              00000050    EQU
IOFSVRSN                00000020    EQU
IOHFQELSIZ              0000006C    EQU
IOHVQELSIZE             0000007A    EQU
IOID                    00000023    EQU
IOLEOF                  0000001C    EQU
IOLINK                  00000000    EQU
IOMIX                   0000001C    EQU
IONEWDIRID              00000024    EQU
IONEWNAME               0000001C    EQU
IONEWTYPE               0000001C    EQU
IONUMDONE               00000028    EQU
IOOWNBUF                0000001C    EQU
IOPERMSSN               0000001B    EQU
IOPMSPFLG               0000001A    EQU
IOPMSPHOOK              0000001C    EQU
IOPOSMODE               0000002C    EQU
IOPOSOFFSET             0000002E    EQU
IOQELSIZE               00000032    EQU
IOQTYPE                 00000002    EQU
IOREFNUM                00000018    EQU
IOREQCOUNT              00000024    EQU
IORESULT                00000010    EQU
IOSEBLKPTR              00000022    EQU
IOSLOT                  00000022    EQU
IOTRAP                  00000006    EQU
IOTYPE                  00000004    EQU
IOVALBLKSIZ             00000030    EQU
IOVATRB                 00000026    EQU
IOVBKUP                 00000048    EQU
IOVBLLN                 0000002C    EQU
IOVCBVBMST              0000002A    EQU
IOVCLPSIZ               00000034    EQU
IOVCRDATE               0000001E    EQU
IOVDIRCNT               00000056    EQU

IOVDIRST                0000002A    EQU
IOVDREFNUM              00000044    EQU
IOVDRVINFO              00000042    EQU
IOVDRVNUM               00000016    EQU
IOVFILCNT               00000052    EQU
IOVFNDRINFO             0000005A    EQU
IOVFRBLK                0000003E    EQU
IOVFSID                 00000046    EQU
IOVLSBKUP               00000022    EQU
IOVLSMOD                00000022    EQU
IOVNMALBLKS             0000002E    EQU
IOVNMFLS                00000028    EQU
IOVNPTR                 00000012    EQU
IOVNXTCNID              0000003A    EQU
IOVNXTFNUM              0000003A    EQU
IOVOLINDEX              0000001C    EQU
IOVQELSIZE              00000040    EQU
IOVREFNUM               00000016    EQU
IOVSEQNUM               0000004C    EQU
IOVSIGWORD              00000040    EQU
IOVWRCNT                0000004E    EQU
IOWDDIRID               00000030    EQU
IOWDINDEX               0000001A    EQU
IOWDPROCID              0000001C    EQU
IOWDVREFNUM             00000020    EQU
ITABPURGERR             FFFFFFF7    EQU
IWM                     000001E0    EQU
JALLOCCRSR              0000088C    EQU
JCBUTTON                00000002    EQU
JCEVENT                 00000004    EQU
JCGETKEYS               00000003    EQU
JCGETMOUSE              00000001    EQU
JCRSRTASK               000008EE    EQU
JCTICKCOUNT             00000000    EQU
JDTINSTALL              00000D9C    EQU
JFETCH                  000008F4    EQU
JGNEFILTER              0000029A    EQU
JIODONE                 000008FC    EQU
JKYBDTASK               0000021A    EQU
JOPCODEPROC             00000894    EQU
JOURNALFLAG             000008DE    EQU
JOURNALREF              000008E8    EQU
JPLAYCTL                00000010    EQU
JRECORDCTL              00000011    EQU
JSETCCRSR               00000890    EQU
JSTASH                  000008F8    EQU
JSWAPMMU                00000DBC    EQU
JVBLTASK                00000D28    EQU
KBDLAST                 00000218    EQU
KBDTYPE                 0000021E    EQU
KBDVARS                 00000216    EQU
KEY1TRANS               0000029E    EQU
KEY2TRANS               000002A2    EQU
KEYCODEMASK             0000FF00    EQU
KEYDWNEVT               00000003    EQU
KEYEVTDEV               00000007    EQU
KEYLAST                 00000184    EQU
KEYMAP                  00000174    EQU
KEYMVARS                00000B04    EQU
KEYPADMAP               0000017C    EQU
KEYREPTHRESH            00000190    EQU
KEYREPTIME              0000018A    EQU
KEYTHRESH               0000018E    EQU
KEYTIME                 00000186    EQU
KEYUPEVT                00000004    EQU
KILLCODE                00000001    EQU
LAPPROTERR              FFFFFFA2    EQU
LASTDSKERR              FFFFFFC0    EQU
LASTTXGDEVICE           00000DC4    EQU
LAUNCHFLAG              00000902    EQU
LIMITPTR                00000004    EQU
LO3BYTES                0000031A    EQU
LOADERPBLOCK            0000093A    EQU
LOADTRAP                0000012D    EQU
LOCK                    00000007    EQU

LVL1DT                  00000192    EQU
LVL2DT                  000001B2    EQU
MACDEV                  00000008    EQU
MAINDEVICE              000008A4    EQU
MALLOCCNT               00000014    EQU
MAPREADERR              FFFFFF39    EQU
MARKS                   00000200    EQU
MASKBC                  0000031A    EQU
MASKHANDLE              0000031A    EQU
MASKPTR                 0000031A    EQU
MAXNREL                 0000001E    EQU
MAXREL                  0000001A    EQU
MAXSIZE                 00800000    EQU
MAXUTENTRIES            00000080    EQU
MBARNFND                FFFFFF82    EQU
MBSTATE                 00000172    EQU
MBTICKS                 0000016E    EQU
MBUTDWNEVT              00000001    EQU
MBUTUPEVT               00000002    EQU
MEMADRERR               FFFFFF92    EQU
MEMAZERR                FFFFFF8F    EQU
MEMBCERR                FFFFFF8D    EQU
MEMERR                  00000220    EQU
MEMFULLERR              FFFFFF94    EQU
MEMLOCKEDERR            FFFFFF8B    EQU
MEMPCERR                FFFFFF8E    EQU
MEMPURERR               FFFFFF90    EQU
MEMROZERR               FFFFFF9D    EQU
MEMROZERROR             FFFFFF9D    EQU
MEMROZWARN              FFFFFF9D    EQU
MEMSCERR                FFFFFF8C    EQU
MEMTOP                  00000108    EQU
MEMWZERR                FFFFFF91    EQU
MFULERR                 FFFFFFD7    EQU
MICKEYBYTES             00000D6A    EQU
MINCBFREE               00000024    EQU
MINSTACK                0000031E    EQU
MINUSONE                00000A06    EQU
MMDEFFLAGS              00000326    EQU
MMINOK                  0000012E    EQU
MMU32BIT                00000CB2    EQU
MMUFLAGS                00000CB0    EQU
MMUFLUFF                00000CB3    EQU
MMUTBL                  00000CB4    EQU
MMUTBLSIZE              00000CB8    EQU
MMUTYPE                 00000CB1    EQU
MNSTACKSIZE             00000400    EQU
MONKEYLIVES             00000100    EQU
MOUSE                   00000830    EQU
MOUSEMASK               000008D6    EQU
MOUSEOFFSET             000008DA    EQU
MTEMP                   00000828    EQU
NBPBUFFOVR              FFFFFC00    EQU
NBPCONFDIFF             FFFFFBFE    EQU
NBPDUPLICATE            FFFFFBFD    EQU
NBPNISERR               FFFFFBFB    EQU
NBPNOCONFIRM            FFFFFBFF    EQU
NBPNOTFOUND             FFFFFBFC    EQU
NETWORKEVT              0000000A    EQU
NEWCRSRJCNT             00000001    EQU
NEWCRSRJTBL             0000088C    EQU
NEWOS                   00000200    EQU
NEWSELMSG               0000000C    EQU
NEWTOOL                 00000600    EQU
NILHANDLEERR            FFFFFF93    EQU
NMIFLAG                 00000C2C    EQU
NOADRMKERR              FFFFFFBD    EQU
NOBRIDGEERR             FFFFFFA3    EQU
NOCOLMATCH              FFFFFFF6    EQU
NODATAAREA              FFFFFBB0    EQU
NODRIVEERR              FFFFFFC0    EQU
NODTAMKERR              FFFFFFB9    EQU
NOERR                   00000000    EQU
NOHARDWARE              FFFFFF38    EQU
NOMACDSKERR             FFFFFFC7    EQU

NOMPPERR                FFFFF3E2    EQU
NONYBERR                FFFFFFBE    EQU
NOQUEUEBIT              00000009    EQU
NORELERR                FFFFFBB3    EQU
NOROOMERR               FFFFFFF2    EQU
NOSCRAPERR              FFFFFF9C    EQU
NOSENDRESP              FFFFFBB1    EQU
NOTENOUGHHARDWARE       FFFFFF37    EQU
NOTOPENERR              FFFFFFE4    EQU
NOTYPEERR               FFFFFF9A    EQU
NSDRVERR                FFFFFFC8    EQU
NSVERR                  FFFFFFDD    EQU
NULDEV                  00000003    EQU
NULLEVT                 00000000    EQU
OFFLINERR               FFFFFFBF    EQU
ONEONE                  00000A02    EQU
OPENERR                 FFFFFFE9    EQU
OPTIONKEY               0000000B    EQU
OPWRERR                 FFFFFFCF    EQU
OVERRUN                 FFFFFFF3    EQU
PARAMERR                FFFFFFCE    EQU
PCDESKPAT               0000020B    EQU
PERMERR                 FFFFFFCA    EQU
PGROWZONE               0000000A    EQU
PLUSCURSOR              00000003    EQU
PORTAUSE                00000290    EQU
PORTBUSE                00000291    EQU
PORTINUSE               FFFFFF9F    EQU
PORTLIST                00000D66    EQU
PORTNOTCF               FFFFFF9E    EQU
POSERR                  FFFFFFD8    EQU
PRINITERR               FFFFFFA8    EQU
PRWRERR                 FFFFFFA9    EQU
PSALERT                 00000006    EQU
PURGE                   00000006    EQU
PURGEPROC               00000028    EQU
PURGEPTR                00000004    EQU
PWMBUF2                 00000312    EQU
QALLOCERR               FFFFFFF5    EQU
QDCOLORS                000008B0    EQU
QDERR                   00000D6E    EQU
QDEXIST                 000008F3    EQU
QERR                    FFFFFFFF    EQU
QFLAGS                  00000000    EQU
QHEAD                   00000002    EQU
QHEADSIZE               0000000A    EQU
QINUSE                  00000007    EQU
QLINK                   00000000    EQU
QTAIL                   00000006    EQU
QTYPE                   00000004    EQU
QUEUEFULL               FFFFFF35    EQU
RAMBASE                 000002B2    EQU
RAWMOUSE                0000082C    EQU
RCVRERR                 FFFFFFA7    EQU
RDVERIFY                00000040    EQU
READERR                 FFFFFFED    EQU
READQERR                FFFFF3DF    EQU
RECNOTFND               FFFFF3DC    EQU
REQABORTED              FFFFFBAF    EQU
REQFAILED               FFFFFBB8    EQU
RERANGEERR              FFFFFFED    EQU
RESATTRERR              FFFFFF3A    EQU
RESFNOTFOUND            FFFFFF3F    EQU
RESNOTFOUND             FFFFFF40    EQU
RESOURCE                00000005    EQU
RESPROBLEM              FFFFFF34    EQU
RESTPROC                00000A8C    EQU
RESUMEPROC              00000A8C    EQU
RFNUMERR                FFFFFFCD    EQU
RGBBLACK                00000C10    EQU
RGBWHITE                00000C16    EQU
RMVREFFAILED            FFFFFF3B    EQU
RMVRESFAILED            FFFFFF3C    EQU
RNDSEED                 00000156    EQU
ROM85                   0000028E    EQU

ROMBASE                 000002AE    EQU
ROMMAPHNDL              00000B06    EQU
ROWBITS                 00000C20    EQU
ROZ                     00000000    EQU
SAVESEGHANDLE           00000930    EQU
SBSTATE0                00000000    EQU
SBSTATE1                00000001    EQU
SCALE2XPIC              00002BAC    CODE LABEL EXPORT
SCCASTS                 000002CE    EQU
SCCBSTS                 000002CF    EQU
SCCRD                   000001D8    EQU
SCCWR                   000001DC    EQU
SCRAPCOUNT              00000968    EQU
SCRAPEND                00000980    EQU
SCRAPHANDLE             00000964    EQU
SCRAPINFO               00000960    EQU
SCRAPNAME               0000096C    EQU
SCRAPSIZE               00000960    EQU
SCRAPSTATE              0000096A    EQU
SCRAPTAG                00000970    EQU
SCRAPVARS               00000960    EQU
SCRATCH20               000001E4    EQU
SCRATCH8                000009FA    EQU
SCRDMPENB               000002F8    EQU
SCRDMPTYPE              000002F9    EQU
SCREENBYTES             00000C24    EQU
SCREENROW               00000106    EQU
SCRHRES                 00000104    EQU
SCRNBASE                00000824    EQU
SCRNVBLPTR              00000D10    EQU
SCRVRES                 00000102    EQU
SCSIBASE                00000C00    EQU
SCSIDMA                 00000C04    EQU
SCSIGLOBALS             00000C0C    EQU
SCSIHSK                 00000C08    EQU
SCSIPOLL                00000C2F    EQU
SDEXTDEVID              00000000    EQU
SDMBUSERR               00000DC0    EQU
SDMINITERR              0000000B    EQU
SDMJMPTBLPTR            00000DB8    EQU
SDMJTINITERR            0000000A    EQU
SDMPRAMINITERR          0000000D    EQU
SDMPRIINITERR           0000000E    EQU
SDMSRTINITERR           0000000C    EQU
SDOSTYPE                00000001    EQU
SDPARTITION             00000001    EQU
SDREFNUM                00000002    EQU
SDRESERVED              00000000    EQU
SDRESERVED1             00000000    EQU
SDRESERVED2             00000001    EQU
SDSLOT                  00000000    EQU
SDSLOTNUM               00000002    EQU
SDSRESOURCE             00000001    EQU
SDSRSRCID               00000003    EQU
SDVOLUME                00000260    EQU
SECTNFERR               FFFFFFAF    EQU
SEEKERR                 FFFFFFB0    EQU
SEGHIENABLE             00000BB2    EQU
SEINVREQUEST            FFFFFFEC    EQU
SELECTMSG               0000000F    EQU
SENODB                  FFFFFFF8    EQU
SENOMEMERR              FFFFFFEB    EQU
SEOUTOFRANGE            FFFFFFF1    EQU
SEPROTERR               FFFFFFF0    EQU
SERIALVARS              000002D0    EQU
SEVARBASE               00000C30    EQU
SEVTENB                 0000015C    EQU
SFSAVEDISK              00000214    EQU
SHERRS                  00000004    EQU
SHEVTS                  00000005    EQU
SHFCTS                  00000001    EQU
SHFINX                  00000006    EQU
SHFXON                  00000000    EQU
SHIFTKEY                00000009    EQU
SHNULL                  00000007    EQU

SHRINK75                00002B28    CODE LABEL EXPORT
SHXOFF                  00000003    EQU
SHXON                   00000002    EQU
SIINITSDTBLERR          00000001    EQU
SIINITSPTBLERR          00000003    EQU
SIINITVBLQSERR          00000002    EQU
SINFOPTR                00000CBC    EQU
SINITFLAGS              00000D90    EQU
SIQTYPE                 00000006    EQU
SKTCLOSEDERR            FFFFF3DB    EQU
SLOTNUMERR              FFFFFE98    EQU
SLOTPRTBL               00000D08    EQU
SLOTQDT                 00000D04    EQU
SLOTTICKS               00000D14    EQU
SLOTVBLQ                00000D0C    EQU
SMBADBOARDID            FFFFFEC1    EQU
SMBADREFID              FFFFFEB6    EQU
SMBADSLIST              FFFFFEB5    EQU
SMBADSPTRERR            FFFFFEA6    EQU
SMBLFIELDBAD            FFFFFECB    EQU
SMBLKMOVEERR            FFFFFEAC    EQU
SMBUSERRTO              FFFFFEC0    EQU
SMBYTELANESERR          FFFFFEA5    EQU
SMCKSTATUSERR           FFFFFEAB    EQU
SMCODEREVERR            FFFFFEB3    EQU
SMCPUERR                FFFFFEB2    EQU
SMCRCFAIL               FFFFFED3    EQU
SMDISDRVRNAMERR         FFFFFEA9    EQU
SMDISPOSEPERR           FFFFFEC8    EQU
SMEMPTYSLOT             FFFFFED4    EQU
SMFHBLKDISPERR          FFFFFEC9    EQU
SMFHBLOCKRDERR          FFFFFECA    EQU
SMFORMATERR             FFFFFED2    EQU
SMGETDRVRNAMERR         FFFFFEAA    EQU
SMGETPRERR              FFFFFEC6    EQU
SMGLOBALS               00000CC4    EQU
SMINTSTATVERR           FFFFFEC4    EQU
SMINTTBLVERR            FFFFFEC3    EQU
SMLWTSTBAD              FFFFFECF    EQU
SMNEWPERR               FFFFFEAD    EQU
SMNILSBLOCKERR          FFFFFEB0    EQU
SMNOBOARDID             FFFFFEC5    EQU
SMNOBOARDSRSRC          FFFFFEC7    EQU
SMNODIR                 FFFFFED0    EQU
SMNOGOODOPENS           FFFFFEA3    EQU
SMNOJMPTBL              FFFFFEC2    EQU
SMNOMORESRSRCS          FFFFFEA8    EQU
SMNOSINFOARRAY          FFFFFECE    EQU
SMOFFSETERR             FFFFFEA4    EQU
SMPRAMINITERR           FFFFFEDC    EQU
SMPRIINITERR            FFFFFEDB    EQU
SMRECNOTFND             FFFFFEA1    EQU
SMRESERVEDERR           FFFFFEB4    EQU
SMRESRVERR              FFFFFECD    EQU
SMREVISIONERR           FFFFFED1    EQU
SMSDMINITERR            FFFFFEDE    EQU
SMSELOOBERR             FFFFFEAE    EQU
SMSGETDRVRERR           FFFFFEA7    EQU
SMSLOTOOBERR            FFFFFEAF    EQU
SMSPOINTERNIL           FFFFFEB1    EQU
SMSRTINITERR            FFFFFEDD    EQU
SMSRTOVRFLERR           FFFFFEA2    EQU
SMUNEXBUSERR            FFFFFECC    EQU
SORTSAFTER              00000001    EQU
SORTSBEFORE             FFFFFFFF    EQU
SORTSEQUAL              00000000    EQU
SOUNDACTIVE             0000027E    EQU
SOUNDBASE               00000266    EQU
SOUNDDCE                0000027A    EQU
SOUNDLEVEL              0000027F    EQU
SOUNDPTR                00000262    EQU
SOUNDVBL                0000026A    EQU
SPALARM                 00000200    EQU
SPATALKA                000001F9    EQU
SPATALKB                000001FA    EQU

SPCLIKCARET             00000209    EQU
SPCONFIG                000001FB    EQU
SPDADJERR               FFFFFFB1    EQU
SPFONT                  00000204    EQU
SPKBD                   00000206    EQU
SPMISC1                 0000020A    EQU
SPMISC2                 0000020B    EQU
SPPORTA                 000001FC    EQU
SPPORTB                 000001FE    EQU
SPPRINT                 00000207    EQU
SPVALID                 000001F8    EQU
SPVOLCTL                00000208    EQU
SQZROW                  00002A14    CODE LABEL EXPORT
SRCDEVICE               000008A0    EQU
SRSRCTBLPTR             00000D24    EQU
SSCTSHOLD               00000004    EQU
SSCUMERRS               00000000    EQU
SSRDPEND                00000002    EQU
SSWRPEND                00000003    EQU
SSXOFFHOLD              00000005    EQU
SSXOFFSENT              00000001    EQU
STARTPTR                00000000    EQU
STATUSERR               FFFFFFEE    EQU
STIPPIC                 00002AB8    CODE LABEL EXPORT
STKLOWPT                00000110    EQU
SWITCHERTPTR            00000286    EQU
SYS                     00000400    EQU
SYSENVREC               00000000    TEMPLATE
SYSEVTBUF               00000146    EQU
SYSEVTMASK              00000144    EQU
SYSPARAM                000001F8    EQU
SYSVERSION              0000015A    EQU
SYSZONE                 000002A6    EQU
TABLESEED               00000D20    EQU
TAGBC                   00000000    EQU
TAGDATA                 000002FA    EQU
TBLALLOCERR             FFFFFFF4    EQU
TERMINATEMSG            00000011    EQU
TGBUFFCODE              00000008    EQU
THECHOOSER              00000001    EQU
THECRSR                 00000844    EQU
THEGDEVICE              00000CC8    EQU
THEZONE                 00000118    EQU
TICKS                   0000016A    EQU
TIME                    0000020C    EQU
TIMEDBRA                00000D00    EQU
TIMESCCDB               00000D02    EQU
TIMESCSIDB              00000DA6    EQU
TK0BADERR               FFFFFFB4    EQU
TMFOERR                 FFFFFFD6    EQU
TMWDOERR                FFFFFF87    EQU
TOEXTFS                 000003F2    EQU
TOOMANYREQS             FFFFFBB7    EQU
TOOMANYSKTS             FFFFFBB6    EQU
TRUE32B                 00000001    EQU
TSYSORCURZONE           0000000A    EQU
TWOSIDEERR              FFFFFFB2    EQU
TYBKFREE                00000000    EQU
TYBKMASK                00000003    EQU
TYBKNREL                00000001    EQU
TYBKREL                 00000002    EQU
UNIMPERR                FFFFFFFC    EQU
UNITEMPTYERR            FFFFFFEA    EQU
UNITENTRIES             00000040    EQU
UNITNTRYCNT             000001D2    EQU
UNITTBLFULLERR          FFFFFFE3    EQU
UPDATEDEV               00000004    EQU
UPDATEVT                00000006    EQU
UPDPIXMEMERR            FFFFFF83    EQU
USEASYNC                00000002    EQU
USEATALK                00000001    EQU
USEEXTCLK               00000003    EQU
USEFREE                 00000000    EQU
UTABLEBASE              0000011C    EQU
VBLADDR                 00000006    EQU

VBLCOUNT                0000000A    EQU
VBLINK                  00000000    EQU
VBLPHASE                0000000C    EQU
VBLQUEUE                00000160    EQU
VBLTYPE                 00000004    EQU
VERERR                  FFFFFFAC    EQU
VERTRRATE               00000D30    EQU
VIA                     000001D4    EQU
VIA2DT                  00000D70    EQU
VIDEOINFOOK             00000DB0    EQU
VIDEOMAGIC              5A932BC7    EQU
VIDMODE                 00000C2E    EQU
VIDTYPE                 00000C2D    EQU
VLCKDERR                FFFFFFD2    EQU
VOLGONEERR              FFFFFF84    EQU
VOLOFFLINERR            FFFFFFCB    EQU
VOLONLINERR             FFFFFFC9    EQU
VTYPE                   00000001    EQU
VTYPERR                 FFFFFFFE    EQU
WARMSTART               00000CFC    EQU
WATCHCURSOR             00000004    EQU
WHOLEERRORS             00000000    EQU
WHOLESYSTEM             00000001    EQU
WMGRCPORT               00000D2C    EQU
WMSTCONST               574C5343    EQU
WPRERR                  FFFFFFD4    EQU
WRGVOLTYPERR            FFFFFF85    EQU
WRITERR                 FFFFFFEC    EQU
WRPERMERR               FFFFFFC3    EQU
WRUNDERRUN              FFFFFFB6    EQU
WWEXIST                 000008F2    EQU
ZCBFREE                 0000000C    EQU
ZSTART                  00000002    CODE LABEL EXPORT
_ADBOP                  0000A07C    OPWORD
_ADBREINIT              0000A07B    OPWORD
_ADDCOMP                0000AA3B    OPWORD
_ADDDRIVE               0000A04E    OPWORD
_ADDPT                  0000A87E    OPWORD
_ADDREFERENCE           0000A9AC    OPWORD
_ADDRESMENU             0000A94D    OPWORD
_ADDRESOURCE            0000A9AB    OPWORD
_ADDSEARCH              0000AA3A    OPWORD
_ALERT                  0000A985    OPWORD
_ALLOCATE               0000A010    OPWORD
_ALLOCCONTIG            0000A210    OPWORD
_ALLOCCURSOR            0000AA1D    OPWORD
_ANGLEFROMSLOPE         0000A8C4    OPWORD
_APPENDMENU             0000A933    OPWORD
_ATTACHVBL              0000A071    OPWORD
_BACKCOLOR              0000A863    OPWORD
_BACKPAT                0000A87C    OPWORD
_BACKPIXPAT             0000AA0B    OPWORD
_BEGINUPDATE            0000A922    OPWORD
_BITAND                 0000A858    OPWORD
_BITCLR                 0000A85F    OPWORD
_BITNOT                 0000A85A    OPWORD
_BITOR                  0000A85B    OPWORD
_BITSET                 0000A85E    OPWORD
_BITSHIFT               0000A85C    OPWORD
_BITTST                 0000A85D    OPWORD
_BITXOR                 0000A859    OPWORD
_BLOCKMOVE              0000A02E    OPWORD
_BRINGTOFRONT           0000A920    OPWORD
_BUTTON                 0000A974    OPWORD
_CALCCMASK              0000AA4F    OPWORD
_CALCMASK               0000A838    OPWORD
_CALCMENUSIZE           0000A948    OPWORD
_CALCVBEHIND            0000A90A    OPWORD
_CALCVIS                0000A909    OPWORD
_CAUTIONALERT           0000A988    OPWORD
_CHAIN                  0000A9F3    OPWORD
_CHANGEDRESOURCE        0000A9AA    OPWORD
_CHAREXTRA              0000AA23    OPWORD
_CHARWIDTH              0000A88D    OPWORD
_CHECKITEM              0000A945    OPWORD

_CHECKUPDATE            0000A911    OPWORD
_CLEARMENUBAR           0000A934    OPWORD
_CLIPABOVE              0000A90B    OPWORD
_CLIPRECT               0000A87B    OPWORD
_CLOSE                  0000A001    OPWORD
_CLOSECPORT             0000A87D    OPWORD
_CLOSEDESKACC           0000A9B7    OPWORD
_CLOSEDIALOG            0000A982    OPWORD
_CLOSEPGON              0000A8CC    OPWORD
_CLOSEPICTURE           0000A8F4    OPWORD
_CLOSEPORT              0000A87D    OPWORD
_CLOSERESFILE           0000A99A    OPWORD
_CLOSERGN               0000A8DB    OPWORD
_CLOSEWINDOW            0000A92D    OPWORD
_CMPSTRING              0000A03C    OPWORD
_COLOR2INDEX            0000AA33    OPWORD
_COLORBIT               0000A864    OPWORD
_COMPACTMEM             0000A04C    OPWORD
_CONTROL                0000A004    OPWORD
_COPYBITS               0000A8EC    OPWORD
_COPYMASK               0000A817    OPWORD
_COPYPIXMAP             0000AA05    OPWORD
_COPYPIXPAT             0000AA09    OPWORD
_COPYRGN                0000A8DC    OPWORD
_COULDALERT             0000A989    OPWORD
_COULDDIALOG            0000A979    OPWORD
_COUNT1RESOURCES        0000A80D    OPWORD
_COUNT1TYPES            0000A81C    OPWORD
_COUNTADBS              0000A077    OPWORD
_COUNTMITEMS            0000A950    OPWORD
_COUNTRESOURCES         0000A99C    OPWORD
_COUNTTYPES             0000A99E    OPWORD
_CREATE                 0000A008    OPWORD
_CREATERESFILE          0000A9B1    OPWORD
_CURRESFILE             0000A994    OPWORD
_DATE2SECS              0000A9C7    OPWORD
_DEBUGGER               0000A9FF    OPWORD
_DEBUGSTR               0000ABFF    OPWORD
_DECSTR68K              0000A9EE    OPWORD
_DELAY                  0000A03B    OPWORD
_DELCOMP                0000AA4D    OPWORD
_DELETE                 0000A009    OPWORD
_DELETEMENU             0000A936    OPWORD
_DELMCENTRIES           0000AA60    OPWORD
_DELMENUITEM            0000A952    OPWORD
_DELSEARCH              0000AA4C    OPWORD
_DELTAPOINT             0000A94F    OPWORD
_DEQUEUE                0000A96E    OPWORD
_DETACHRESOURCE         0000A992    OPWORD
_DIALOGSELECT           0000A980    OPWORD
_DIFFRGN                0000A8E6    OPWORD
_DISABLEITEM            0000A93A    OPWORD
_DISPMCINFO             0000AA63    OPWORD
_DISPOSCCURSOR          0000AA26    OPWORD
_DISPOSCICON            0000AA25    OPWORD
_DISPOSCONTROL          0000A955    OPWORD
_DISPOSCTABLE           0000AA24    OPWORD
_DISPOSDIALOG           0000A983    OPWORD
_DISPOSGDEVICE          0000AA30    OPWORD
_DISPOSHANDLE           0000A023    OPWORD
_DISPOSMENU             0000A932    OPWORD
_DISPOSPIXMAP           0000AA04    OPWORD
_DISPOSPIXPAT           0000AA08    OPWORD
_DISPOSPTR              0000A01F    OPWORD
_DISPOSRGN              0000A8D9    OPWORD
_DISPOSWINDOW           0000A914    OPWORD
_DOVBLTASK              0000A072    OPWORD
_DRAGCONTROL            0000A967    OPWORD
_DRAGGRAYRGN            0000A905    OPWORD
_DRAGTHERGN             0000A926    OPWORD
_DRAGWINDOW             0000A925    OPWORD
_DRAW1CONTROL           0000A96D    OPWORD
_DRAWCHAR               0000A883    OPWORD
_DRAWCONTROLS           0000A969    OPWORD
_DRAWDIALOG             0000A981    OPWORD

_DRAWGROWICON           0000A904    OPWORD
_DRAWMENUBAR            0000A937    OPWORD
_DRAWNEW                0000A90F    OPWORD
_DRAWPICTURE            0000A8F6    OPWORD
_DRAWSTRING             0000A884    OPWORD
_DRAWTEXT               0000A885    OPWORD
_DRVRINSTALL            0000A03D    OPWORD
_DRVRREMOVE             0000A03E    OPWORD
_DTINSTALL              0000A082    OPWORD
_EJECT                  0000A017    OPWORD
_ELEMS68K               0000A9EC    OPWORD
_EMPTYHANDLE            0000A02B    OPWORD
_EMPTYRECT              0000A8AE    OPWORD
_EMPTYRGN               0000A8E2    OPWORD
_ENABLEITEM             0000A939    OPWORD
_ENDUPDATE              0000A923    OPWORD
_ENQUEUE                0000A96F    OPWORD
_EQUALPT                0000A881    OPWORD
_EQUALRECT              0000A8A6    OPWORD
_EQUALRGN               0000A8E3    OPWORD
_ERASEARC               0000A8C0    OPWORD
_ERASEOVAL              0000A8B9    OPWORD
_ERASEPOLY              0000A8C8    OPWORD
_ERASERECT              0000A8A3    OPWORD
_ERASERGN               0000A8D4    OPWORD
_ERASEROUNDRECT         0000A8B2    OPWORD
_ERRORSOUND             0000A98C    OPWORD
_EVENTAVAIL             0000A971    OPWORD
_EXITTOSHELL            0000A9F4    OPWORD
_FILLARC                0000A8C2    OPWORD
_FILLCARC               0000AA11    OPWORD
_FILLCOVAL              0000AA0F    OPWORD
_FILLCPOLY              0000AA13    OPWORD
_FILLCRECT              0000AA0E    OPWORD
_FILLCRGN               0000AA12    OPWORD
_FILLCROUNDRECT         0000AA10    OPWORD
_FILLOVAL               0000A8BB    OPWORD
_FILLPOLY               0000A8CA    OPWORD
_FILLRECT               0000A8A5    OPWORD
_FILLRGN                0000A8D6    OPWORD
_FILLROUNDRECT          0000A8B4    OPWORD
_FINDCONTROL            0000A96C    OPWORD
_FINDDITEM              0000A984    OPWORD
_FINDWINDOW             0000A92C    OPWORD
_FINITQUEUE             0000A016    OPWORD
_FIXATAN2               0000A818    OPWORD
_FIXMUL                 0000A868    OPWORD
_FIXRATIO               0000A869    OPWORD
_FIXROUND               0000A86C    OPWORD
_FLASHMENUBAR           0000A94C    OPWORD
_FLUSHEVENTS            0000A032    OPWORD
_FLUSHFILE              0000A045    OPWORD
_FLUSHVOL               0000A013    OPWORD
_FMSWAPFONT             0000A901    OPWORD
_FONTMETRICS            0000A835    OPWORD
_FORECOLOR              0000A862    OPWORD
_FP68K                  0000A9EB    OPWORD
_FRAMEARC               0000A8BE    OPWORD
_FRAMEOVAL              0000A8B7    OPWORD
_FRAMEPOLY              0000A8C6    OPWORD
_FRAMERECT              0000A8A1    OPWORD
_FRAMERGN               0000A8D2    OPWORD
_FRAMEROUNDRECT         0000A8B0    OPWORD
_FREEALERT              0000A98A    OPWORD
_FREEDIALOG             0000A97A    OPWORD
_FREEMEM                0000A01C    OPWORD
_FRONTWINDOW            0000A924    OPWORD
_GET1IXRESOURCE         0000A80E    OPWORD
_GET1IXTYPE             0000A80F    OPWORD
_GET1NAMEDRESOURCE      0000A820    OPWORD
_GET1RESOURCE           0000A81F    OPWORD
_GETADBINFO             0000A079    OPWORD
_GETAPPPARMS            0000A9F5    OPWORD
_GETAUXCTL              0000AA44    OPWORD
_GETAUXWIN              0000AA42    OPWORD

_GETBACKCOLOR           0000AA1A    OPWORD
_GETCCURSOR             0000AA1B    OPWORD
_GETCICON               0000AA1E    OPWORD
_GETCLIP                0000A87A    OPWORD
_GETCPIXEL              0000AA17    OPWORD
_GETCREFCON             0000A95A    OPWORD
_GETCTABLE              0000AA18    OPWORD
_GETCTITLE              0000A95E    OPWORD
_GETCTLACTION           0000A96A    OPWORD
_GETCTLVALUE            0000A960    OPWORD
_GETCTSEED              0000AA28    OPWORD
_GETCURSOR              0000A9B9    OPWORD
_GETCVARIANT            0000A809    OPWORD
_GETCWMGRPORT           0000AA48    OPWORD
_GETDEFAULTSTARTUP      0000A07D    OPWORD
_GETDEVICELIST          0000AA29    OPWORD
_GETDITEM               0000A98D    OPWORD
_GETEOF                 0000A011    OPWORD
_GETFILEINFO            0000A00C    OPWORD
_GETFNAME               0000A8FF    OPWORD
_GETFNUM                0000A900    OPWORD
_GETFONTINFO            0000A88B    OPWORD
_GETFORECOLOR           0000AA19    OPWORD
_GETFPOS                0000A018    OPWORD
_GETGDEVICE             0000AA32    OPWORD
_GETHANDLESIZE          0000A025    OPWORD
_GETICON                0000A9BB    OPWORD
_GETINDADB              0000A078    OPWORD
_GETINDRESOURCE         0000A99D    OPWORD
_GETINDTYPE             0000A99F    OPWORD
_GETITEM                0000A946    OPWORD
_GETITEMCMD             0000A84E    OPWORD
_GETITEXT               0000A990    OPWORD
_GETITMICON             0000A93F    OPWORD
_GETITMMARK             0000A943    OPWORD
_GETITMSTYLE            0000A941    OPWORD
_GETKEYS                0000A976    OPWORD
_GETMAINDEVICE          0000AA2A    OPWORD
_GETMASKTABLE           0000A836    OPWORD
_GETMAXCTL              0000A962    OPWORD
_GETMAXDEVICE           0000AA27    OPWORD
_GETMCENTRY             0000AA64    OPWORD
_GETMCINFO              0000AA61    OPWORD
_GETMENUBAR             0000A93B    OPWORD
_GETMHANDLE             0000A949    OPWORD
_GETMINCTL              0000A961    OPWORD
_GETMOUSE               0000A972    OPWORD
_GETNAMEDRESOURCE       0000A9A1    OPWORD
_GETNEWCONTROL          0000A9BE    OPWORD
_GETNEWCWINDOW          0000AA46    OPWORD
_GETNEWDIALOG           0000A97C    OPWORD
_GETNEWMBAR             0000A9C0    OPWORD
_GETNEWWINDOW           0000A9BD    OPWORD
_GETNEXTDEVICE          0000AA2B    OPWORD
_GETNEXTEVENT           0000A970    OPWORD
_GETOSDEFAULT           0000A084    OPWORD
_GETOSEVENT             0000A031    OPWORD
_GETPATTERN             0000A9B8    OPWORD
_GETPEN                 0000A89A    OPWORD
_GETPENSTATE            0000A898    OPWORD
_GETPICTURE             0000A9BC    OPWORD
_GETPIXEL               0000A865    OPWORD
_GETPIXPAT              0000AA0C    OPWORD
_GETPORT                0000A874    OPWORD
_GETPTRSIZE             0000A021    OPWORD
_GETRESATTRS            0000A9A6    OPWORD
_GETRESFILEATTRS        0000A9F6    OPWORD
_GETRESINFO             0000A9A8    OPWORD
_GETRESOURCE            0000A9A0    OPWORD
_GETRMENU               0000A9BF    OPWORD
_GETSCRAP               0000A9FD    OPWORD
_GETSTRING              0000A9BA    OPWORD
_GETSUBTABLE            0000AA37    OPWORD
_GETTRAPADDRESS         0000A146    OPWORD
_GETVIDEODEFAULT        0000A080    OPWORD

_GETVOL                 0000A014    OPWORD
_GETVOLINFO             0000A007    OPWORD
_GETWINDOWPIC           0000A92F    OPWORD
_GETWMGRPORT            0000A910    OPWORD
_GETWREFCON             0000A917    OPWORD
_GETWTITLE              0000A919    OPWORD
_GETWVARIANT            0000A80A    OPWORD
_GETZONE                0000A11A    OPWORD
_GLOBALTOLOCAL          0000A871    OPWORD
_GRAFDEVICE             0000A872    OPWORD
_GROWWINDOW             0000A92B    OPWORD
_HANDANDHAND            0000A9E4    OPWORD
_HANDLEZONE             0000A126    OPWORD
_HANDTOHAND             0000A9E1    OPWORD
_HCLRRBIT               0000A068    OPWORD
_HCREATE                0000A208    OPWORD
_HDELETE                0000A209    OPWORD
_HGETFILEINFO           0000A20C    OPWORD
_HGETSTATE              0000A069    OPWORD
_HGETVINFO              0000A207    OPWORD
_HGETVOL                0000A214    OPWORD
_HIDECONTROL            0000A958    OPWORD
_HIDECURSOR             0000A852    OPWORD
_HIDEDITEM              0000A827    OPWORD
_HIDEPEN                0000A896    OPWORD
_HIDEWINDOW             0000A916    OPWORD
_HILITECOLOR            0000AA22    OPWORD
_HILITECONTROL          0000A95D    OPWORD
_HILITEMENU             0000A938    OPWORD
_HILITEWINDOW           0000A91C    OPWORD
_HIWORD                 0000A86A    OPWORD
_HLOCK                  0000A029    OPWORD
_HNOPURGE               0000A04A    OPWORD
_HOMERESFILE            0000A9A4    OPWORD
_HOPEN                  0000A200    OPWORD
_HOPENRF                0000A20A    OPWORD
_HPURGE                 0000A049    OPWORD
_HRENAME                0000A20B    OPWORD
_HRSTFLOCK              0000A242    OPWORD
_HSETFILEINFO           0000A20D    OPWORD
_HSETFLOCK              0000A241    OPWORD
_HSETRBIT               0000A067    OPWORD
_HSETSTATE              0000A06A    OPWORD
_HSETVOL                0000A215    OPWORD
_HUNLOCK                0000A02A    OPWORD
_INDEX2COLOR            0000AA34    OPWORD
_INFOSCRAP              0000A9F9    OPWORD
_INITALLPACKS           0000A9E6    OPWORD
_INITAPPLZONE           0000A02C    OPWORD
_INITCPORT              0000AA01    OPWORD
_INITCURSOR             0000A850    OPWORD
_INITDIALOGS            0000A97B    OPWORD
_INITEVENTS             0000A06D    OPWORD
_INITFONTS              0000A8FE    OPWORD
_INITFS                 0000A06C    OPWORD
_INITGDEVICE            0000AA2E    OPWORD
_INITGRAF               0000A86E    OPWORD
_INITMENUS              0000A930    OPWORD
_INITPACK               0000A9E5    OPWORD
_INITPORT               0000A86D    OPWORD
_INITPROCMENU           0000A808    OPWORD
_INITRESOURCES          0000A995    OPWORD
_INITUTIL               0000A03F    OPWORD
_INITWINDOWS            0000A912    OPWORD
_INITZONE               0000A019    OPWORD
_INSERTMENU             0000A935    OPWORD
_INSERTRESMENU          0000A951    OPWORD
_INSETRECT              0000A8A9    OPWORD
_INSETRGN               0000A8E1    OPWORD
_INSMENUITEM            0000A826    OPWORD
_INSTIME                0000A058    OPWORD
_INTERNALWAIT           0000A07F    OPWORD
_INVALRECT              0000A928    OPWORD
_INVALRGN               0000A927    OPWORD
_INVERRECT              0000A8A4    OPWORD

_INVERRGN               0000A8D5    OPWORD
_INVERROUNDRECT         0000A8B3    OPWORD
_INVERTARC              0000A8C1    OPWORD
_INVERTCOLOR            0000AA35    OPWORD
_INVERTOVAL             0000A8BA    OPWORD
_INVERTPOLY             0000A8C9    OPWORD
_ISDIALOGEVENT          0000A97F    OPWORD
_KEYTRANS               0000A9C3    OPWORD
_KILLCONTROLS           0000A956    OPWORD
_KILLIO                 0000A006    OPWORD
_KILLPICTURE            0000A8F5    OPWORD
_KILLPOLY               0000A8CD    OPWORD
_LAUNCH                 0000A9F2    OPWORD
_LINE                   0000A892    OPWORD
_LINETO                 0000A891    OPWORD
_LOADRESOURCE           0000A9A2    OPWORD
_LOADSEG                0000A9F0    OPWORD
_LOCALTOGLOBAL          0000A870    OPWORD
_LODESCRAP              0000A9FB    OPWORD
_LONGMUL                0000A867    OPWORD
_LOWORD                 0000A86B    OPWORD
_MAKEITABLE             0000AA39    OPWORD
_MAKERGBPAT             0000AA0D    OPWORD
_MAPPOLY                0000A8FC    OPWORD
_MAPPT                  0000A8F9    OPWORD
_MAPRECT                0000A8FA    OPWORD
_MAPRGN                 0000A8FB    OPWORD
_MAXAPPLZONE            0000A063    OPWORD
_MAXBLOCK               0000A061    OPWORD
_MAXMEM                 0000A11D    OPWORD
_MAXSIZERSRC            0000A821    OPWORD
_MEASURETEXT            0000A837    OPWORD
_MENUCHOICE             0000AA66    OPWORD
_MENUKEY                0000A93E    OPWORD
_MENUSELECT             0000A93D    OPWORD
_METHODDISPATCH         0000A9F8    OPWORD
_MODALDIALOG            0000A991    OPWORD
_MOOV                   0000A894    OPWORD
_MOREMASTERS            0000A036    OPWORD
_MOUNTVOL               0000A00F    OPWORD
_MOVE                   0000A894    OPWORD
_MOVECONTROL            0000A959    OPWORD
_MOVEHHI                0000A064    OPWORD
_MOVEPORTTO             0000A877    OPWORD
_MOVETO                 0000A893    OPWORD
_MOVEWINDOW             0000A91B    OPWORD
_MUNGER                 0000A9E0    OPWORD
_NEWCDIALOG             0000AA4B    OPWORD
_NEWCONTROL             0000A954    OPWORD
_NEWCWINDOW             0000AA45    OPWORD
_NEWDIALOG              0000A97D    OPWORD
_NEWEMPTYHANDLE         0000A166    OPWORD
_NEWGDEVICE             0000AA2F    OPWORD
_NEWHANDLE              0000A122    OPWORD
_NEWMENU                0000A931    OPWORD
_NEWPIXMAP              0000AA03    OPWORD
_NEWPIXPAT              0000AA07    OPWORD
_NEWPTR                 0000A11E    OPWORD
_NEWRGN                 0000A8D8    OPWORD
_NEWSTRING              0000A906    OPWORD
_NEWWINDOW              0000A913    OPWORD
_NOTEALERT              0000A987    OPWORD
_OBSCURECURSOR          0000A856    OPWORD
_OFFLINE                0000A035    OPWORD
_OFFSETPOLY             0000A8CE    OPWORD
_OFFSETRECT             0000A8A8    OPWORD
_OFSETRGN               0000A8E0    OPWORD
_OPCOLOR                0000AA21    OPWORD
_OPEN                   0000A000    OPWORD
_OPENCPORT              0000AA00    OPWORD
_OPENDESKACC            0000A9B6    OPWORD
_OPENPICTURE            0000A8F3    OPWORD
_OPENPOLY               0000A8CB    OPWORD
_OPENPORT               0000A86F    OPWORD
_OPENRESFILE            0000A997    OPWORD

_OPENRF                 0000A00A    OPWORD
_OPENRFPERM             0000A9C4    OPWORD
_OPENRGN                0000A8DA    OPWORD
_OSDISPATCH             0000A88F    OPWORD
_OSEVENTAVAIL           0000A030    OPWORD
_PACK0                  0000A9E7    OPWORD
_PACK1                  0000A9E8    OPWORD
_PACK10                 0000A82C    OPWORD
_PACK11                 0000A82D    OPWORD
_PACK12                 0000A82E    OPWORD
_PACK13                 0000A82F    OPWORD
_PACK14                 0000A830    OPWORD
_PACK15                 0000A831    OPWORD
_PACK2                  0000A9E9    OPWORD
_PACK3                  0000A9EA    OPWORD
_PACK4                  0000A9EB    OPWORD
_PACK5                  0000A9EC    OPWORD
_PACK6                  0000A9ED    OPWORD
_PACK7                  0000A9EE    OPWORD
_PACK8                  0000A816    OPWORD
_PACK9                  0000A82B    OPWORD
_PACKBITS               0000A8CF    OPWORD
_PAINTARC               0000A8BF    OPWORD
_PAINTBEHIND            0000A90D    OPWORD
_PAINTONE               0000A90C    OPWORD
_PAINTOVAL              0000A8B8    OPWORD
_PAINTPOLY              0000A8C7    OPWORD
_PAINTRECT              0000A8A2    OPWORD
_PAINTRGN               0000A8D3    OPWORD
_PAINTROUNDRECT         0000A8B1    OPWORD
_PARAMTEXT              0000A98B    OPWORD
_PENMODE                0000A89C    OPWORD
_PENNORMAL              0000A89E    OPWORD
_PENPAT                 0000A89D    OPWORD
_PENPIXPAT              0000AA0A    OPWORD
_PENSIZE                0000A89B    OPWORD
_PICCOMMENT             0000A8F2    OPWORD
_PINRECT                0000A94E    OPWORD
_PLOTCICON              0000AA1F    OPWORD
_PLOTICON               0000A94B    OPWORD
_POPUPMENUSELECT        0000A80B    OPWORD
_PORTSIZE               0000A876    OPWORD
_POSTEVENT              0000A02F    OPWORD
_PPOSTEVENT             0000A12F    OPWORD
_PRIMETIME              0000A05A    OPWORD
_PROTECTENTRY           0000AA3D    OPWORD
_PT2RECT                0000A8AC    OPWORD
_PTINRECT               0000A8AD    OPWORD
_PTINRGN                0000A8E8    OPWORD
_PTRANDHAND             0000A9EF    OPWORD
_PTRTOHAND              0000A9E3    OPWORD
_PTRTOXHAND             0000A9E2    OPWORD
_PTRZONE                0000A148    OPWORD
_PTTOANGLE              0000A8C3    OPWORD
_PURGEMEM               0000A04D    OPWORD
_PURGESPACE             0000A162    OPWORD
_PUTSCRAP               0000A9FE    OPWORD
_QDERROR                0000AA40    OPWORD
_RANDOM                 0000A861    OPWORD
_RDRVRINSTALL           0000A04F    OPWORD
_READ                   0000A002    OPWORD
_READDATETIME           0000A039    OPWORD
_READXPRAM              0000A051    OPWORD
_REALCOLOR              0000AA36    OPWORD
_REALFONT               0000A902    OPWORD
_REALLOCHANDLE          0000A027    OPWORD
_RECOVERHANDLE          0000A128    OPWORD
_RECTINRGN              0000A8E9    OPWORD
_RECTRGN                0000A8DF    OPWORD
_RELEASERESOURCE        0000A9A3    OPWORD
_RELSTRING              0000A050    OPWORD
_RENAME                 0000A00B    OPWORD
_RESERROR               0000A9AF    OPWORD
_RESERVEENTRY           0000AA3E    OPWORD
_RESRVMEM               0000A040    OPWORD

_RESTOREENTRIES         0000AA4A    OPWORD
_RGBBACKCOLOR           0000AA15    OPWORD
_RGBFORECOLOR           0000AA14    OPWORD
_RGETRESOURCE           0000A80C    OPWORD
_RMVEREFERENCE          0000A9AE    OPWORD
_RMVERESOURCE           0000A9AD    OPWORD
_RMVTIME                0000A059    OPWORD
_RSRCMAPENTRY           0000A9C5    OPWORD
_RSRCZONEINIT           0000A996    OPWORD
_RSTFILLOCK             0000A042    OPWORD
_SAVEENTRIES            0000AA49    OPWORD
_SAVEOLD                0000A90E    OPWORD
_SCALEPT                0000A8F8    OPWORD
_SCRNBITMAP             0000A833    OPWORD
_SCROLLRECT             0000A8EF    OPWORD
_SECS2DATE              0000A9C6    OPWORD
_SECTRECT               0000A8AA    OPWORD
_SECTRGN                0000A8E4    OPWORD
_SEEDCFILL              0000AA50    OPWORD
_SEEDFILL               0000A839    OPWORD
_SELECTWINDOW           0000A91F    OPWORD
_SELITEXT               0000A97E    OPWORD
_SENDBEHIND             0000A921    OPWORD
_SETADBINFO             0000A07A    OPWORD
_SETAPPBASE             0000A057    OPWORD
_SETAPPLBASE            0000A057    OPWORD
_SETAPPLLIMIT           0000A02D    OPWORD
_SETCCURSOR             0000AA1C    OPWORD
_SETCLIENTID            0000AA3C    OPWORD
_SETCLIP                0000A879    OPWORD
_SETCPIXEL              0000AA16    OPWORD
_SETCPORTPIX            0000AA06    OPWORD
_SETCREFCON             0000A95B    OPWORD
_SETCTITLE              0000A95F    OPWORD
_SETCTLACTION           0000A96B    OPWORD
_SETCTLCOLOR            0000AA43    OPWORD
_SETCTLVALUE            0000A963    OPWORD
_SETCURSOR              0000A851    OPWORD
_SETDATETIME            0000A03A    OPWORD
_SETDEFAULTSTARTUP      0000A07E    OPWORD
_SETDESKCPAT            0000AA47    OPWORD
_SETDEVICEATTRIBUTE     0000AA2D    OPWORD
_SETDITEM               0000A98E    OPWORD
_SETEMPTYRGN            0000A8DD    OPWORD
_SETENTRIES             0000AA3F    OPWORD
_SETEOF                 0000A012    OPWORD
_SETFILEINFO            0000A00D    OPWORD
_SETFILLOCK             0000A041    OPWORD
_SETFILTYPE             0000A043    OPWORD
_SETFONTLOCK            0000A903    OPWORD
_SETFPOS                0000A044    OPWORD
_SETFRACTENABLE         0000A814    OPWORD
_SETFSCALEDISABLE       0000A834    OPWORD
_SETGDEVICE             0000AA31    OPWORD
_SETGROWZONE            0000A04B    OPWORD
_SETHANDLESIZE          0000A024    OPWORD
_SETITEM                0000A947    OPWORD
_SETITEMCMD             0000A84F    OPWORD
_SETITEXT               0000A98F    OPWORD
_SETITMICON             0000A940    OPWORD
_SETITMMARK             0000A944    OPWORD
_SETITMSTYLE            0000A942    OPWORD
_SETMAXCTL              0000A965    OPWORD
_SETMCENTRIES           0000AA65    OPWORD
_SETMCINFO              0000AA62    OPWORD
_SETMENUBAR             0000A93C    OPWORD
_SETMFLASH              0000A94A    OPWORD
_SETMINCTL              0000A964    OPWORD
_SETORIGIN              0000A878    OPWORD
_SETOSDEFAULT           0000A083    OPWORD
_SETPBITS               0000A875    OPWORD
_SETPENSTATE            0000A899    OPWORD
_SETPORT                0000A873    OPWORD
_SETPT                  0000A880    OPWORD
_SETPTRSIZE             0000A020    OPWORD

_SETRECRGN              0000A8DE    OPWORD
_SETRECT                0000A8A7    OPWORD
_SETRESATTRS            0000A9A7    OPWORD
_SETRESFILEATTRS        0000A9F7    OPWORD
_SETRESINFO             0000A9A9    OPWORD
_SETRESLOAD             0000A99B    OPWORD
_SETRESPURGE            0000A993    OPWORD
_SETSTDCPROCS           0000AA4E    OPWORD
_SETSTDPROCS            0000A8EA    OPWORD
_SETSTRING              0000A907    OPWORD
_SETTRAPADDRESS         0000A047    OPWORD
_SETVIDEODEFAULT        0000A081    OPWORD
_SETVOL                 0000A015    OPWORD
_SETWINCOLOR            0000AA41    OPWORD
_SETWINDOWPIC           0000A92E    OPWORD
_SETWREFCON             0000A918    OPWORD
_SETWTITLE              0000A91A    OPWORD
_SETZONE                0000A01B    OPWORD
_SHIELDCURSOR           0000A855    OPWORD
_SHOWCONTROL            0000A957    OPWORD
_SHOWCURSOR             0000A853    OPWORD
_SHOWDITEM              0000A828    OPWORD
_SHOWHIDE               0000A908    OPWORD
_SHOWPEN                0000A897    OPWORD
_SHOWWINDOW             0000A915    OPWORD
_SHUTDOWN               0000A895    OPWORD
_SINTINSTALL            0000A075    OPWORD
_SINTREMOVE             0000A076    OPWORD
_SIZECONTROL            0000A95C    OPWORD
_SIZERSRC               0000A9A5    OPWORD
_SIZEWINDOW             0000A91D    OPWORD
_SLOPEFROMANGLE         0000A8BC    OPWORD
_SLOTVINSTALL           0000A06F    OPWORD
_SLOTVREMOVE            0000A070    OPWORD
_SPACEEXTRA             0000A88E    OPWORD
_STACKSPACE             0000A065    OPWORD
_STATUS                 0000A005    OPWORD
_STDARC                 0000A8BD    OPWORD
_STDBITS                0000A8EB    OPWORD
_STDCOMMENT             0000A8F1    OPWORD
_STDGETPIC              0000A8EE    OPWORD
_STDLINE                0000A890    OPWORD
_STDOPCODEPROC          0000ABF8    OPWORD
_STDOVAL                0000A8B6    OPWORD
_STDPOLY                0000A8C5    OPWORD
_STDPUTPIC              0000A8F0    OPWORD
_STDRECT                0000A8A0    OPWORD
_STDRGN                 0000A8D1    OPWORD
_STDRRECT               0000A8AF    OPWORD
_STDTEXT                0000A882    OPWORD
_STDTXMEAS              0000A8ED    OPWORD
_STILLDOWN              0000A973    OPWORD
_STOPALERT              0000A986    OPWORD
_STRINGWIDTH            0000A88C    OPWORD
_STRIPADDRESS           0000A055    OPWORD
_STUFFHEX               0000A866    OPWORD
_SUBPT                  0000A87F    OPWORD
_SWAPMMUMODE            0000A05D    OPWORD
_SYSBEEP                0000A9C8    OPWORD
_SYSEDIT                0000A9C2    OPWORD
_SYSENVIRONS            0000A090    OPWORD
_SYSERROR               0000A9C9    OPWORD
_SYSTEMCLICK            0000A9B3    OPWORD
_SYSTEMEVENT            0000A9B2    OPWORD
_SYSTEMMENU             0000A9B5    OPWORD
_SYSTEMTASK             0000A9B4    OPWORD
_TEACTIVATE             0000A9D8    OPWORD
_TEAUTOVIEW             0000A813    OPWORD
_TECALTEXT              0000A9D0    OPWORD
EXPANDMEMREC            00000000    TEMPLATE
   EMCURVERSION             0101    TEMPLATE FIELD
   EMINTLGLOBALS            0006    TEMPLATE FIELD
   EMKEYCACHE               000E    TEMPLATE FIELD
   EMKEYDEADSTATE           000A    TEMPLATE FIELD
   EMSIZE                   0002    TEMPLATE FIELD

   EMVERSION                0000    TEMPLATE FIELD
SYSENVREC               00000000    TEMPLATE
   ATDRVRVERSNUM            000C    TEMPLATE FIELD
   ENVIRONSVERSION          0000    TEMPLATE FIELD
   HASCOLORQD               0009    TEMPLATE FIELD
   HASFPU                   0008    TEMPLATE FIELD
   KEYBOARDTYPE             000A    TEMPLATE FIELD
   MACHINETYPE              0002    TEMPLATE FIELD
   PROCESSOR                0006    TEMPLATE FIELD
   SYSENV1SIZE              0010    TEMPLATE FIELD
   SYSTEMVERSION            0004    TEMPLATE FIELD
   SYSVREFNUM               000E    TEMPLATE FIELD
_TECLICK                0000A9D4    OPWORD
_TECOPY                 0000A9D5    OPWORD
_TECUT                  0000A9D6    OPWORD
_TEDEACTIVATE           0000A9D9    OPWORD
_TEDELETE               0000A9D7    OPWORD
_TEDISPATCH             0000A83D    OPWORD
_TEDISPOSE              0000A9CD    OPWORD
_TEGETOFFSET            0000A83C    OPWORD
_TEGETTEXT              0000A9CB    OPWORD
_TEIDLE                 0000A9DA    OPWORD
_TEINIT                 0000A9CC    OPWORD
_TEINSERT               0000A9DE    OPWORD
_TEKEY                  0000A9DC    OPWORD
_TENEW                  0000A9D2    OPWORD
_TEPASTE                0000A9DB    OPWORD
_TEPINSCROLL            0000A812    OPWORD
_TESCROLL               0000A9DD    OPWORD
_TESELVIEW              0000A811    OPWORD
_TESETJUST              0000A9DF    OPWORD
_TESETSELECT            0000A9D1    OPWORD
_TESETTEXT              0000A9CF    OPWORD
_TESTCONTROL            0000A966    OPWORD
_TESTDEVICEATTRIBUTE    0000AA2C    OPWORD
_TESTYLENEW             0000A83E    OPWORD
_TEUPDATE               0000A9D3    OPWORD
_TEXTBOX                0000A9CE    OPWORD
_TEXTFACE               0000A888    OPWORD
_TEXTFONT               0000A887    OPWORD
_TEXTMODE               0000A889    OPWORD
_TEXTSIZE               0000A88A    OPWORD
_TEXTWIDTH              0000A886    OPWORD
_TICKCOUNT              0000A975    OPWORD
_TRACKBOX               0000A83B    OPWORD
_TRACKCONTROL           0000A968    OPWORD
_TRACKGOAWAY            0000A91E    OPWORD
_UNIMPLEMENTED          0000A89F    OPWORD
_UNIONRECT              0000A8AB    OPWORD
_UNIONRGN               0000A8E5    OPWORD
_UNIQUE1ID              0000A810    OPWORD
_UNIQUEID               0000A9C1    OPWORD
_UNLOADSEG              0000A9F1    OPWORD
_UNLODESCRAP            0000A9FA    OPWORD
_UNMOUNTVOL             0000A00E    OPWORD
_UNPACKBITS             0000A8D0    OPWORD
_UPDATERESFILE          0000A999    OPWORD
_UPDTCONTROL            0000A953    OPWORD
_UPDTDIALOG             0000A978    OPWORD
_UPRSTRING              0000A054    OPWORD
_USERESFILE             0000A998    OPWORD
_VALIDRECT              0000A92A    OPWORD
_VALIDRGN               0000A929    OPWORD
_VINSTALL               0000A033    OPWORD
_VREMOVE                0000A034    OPWORD
_WAITMOUSEUP            0000A977    OPWORD
_WAITNEXTEVENT          0000A860    OPWORD
_WRITE                  0000A003    OPWORD
_WRITEPARAM             0000A038    OPWORD
_WRITERESOURCE          0000A9B0    OPWORD
_WRITEXPRAM             0000A052    OPWORD
_XMUNGER                0000A819    OPWORD
_XORRGN                 0000A8E7    OPWORD
_ZEROSCRAP              0000A9FC    OPWORD
_ZOOMWINDOW             0000A83A    OPWORD

POPLONG                POPWORD                RESLONG                RESTREGS               RESWORD
SAVEREGS               _CATMOVE               _CLOSEWD               _COPYFILE              _DIRCREATE
_FSCONTROL             _GETCATINFO            _GETDIRACCESS          _GETFCBINFO            _GETLOGININFO
_GETTIMEOUT            _GETVOLPARMS           _GETWDINFO             _LOCKRNG               _MAPID
_MAPNAME               _MFFREEMEM             _MFMAXMEM              _MFTEMPDISPOSHANDLE    _MFTEMPHLOCK
_MFTEMPHUNLOCK         _MFTEMPNEWHANDLE       _MOVERENAME            _OPENDENY              _OPENRFDENY
_OPENWD                _SETCATINFO            _SETDIRACCESS          _SETPMSP               _SETTIMEOUT
_SETVOLINFO            _TFSCORE               _UNLOCKRNG

Elapsed time: 25.75 seconds.

Assembly complete - no errors found.  11322 lines.
