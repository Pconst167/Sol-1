	PAGE	
	STTL "--- GAME I/O: C128 ---"

; --------------
; INTERNAL ERROR
; --------------
; ENTRY: ERROR CODE IN [A]
; EXIT: HA!

ERRM:	DB	"Internal error "
ENUMB:	DB	"00.  "
ERRML	EQU	$-ERRM

ZERROR:	LDY	#1	; CONVERT ERROR BYTE IN [A]
ZERR0:	LDX	#0	; TO ASCII AT "ENUMB"
ZERR1:	CMP	#10	
	BCC	ZERR2	
	SBC	#10	
	INX		
	BNE	ZERR1	
ZERR2:	ORA	#'0'	
	STA	ENUMB,Y	
	TXA		
	DEY		
	BPL	ZERR0	

	LDA	TOP
	STA	WTOP	; SCROLL NOT

	JSR	ZCRLF	; CLEAR BUFFER
	LDX	#<ERRM	
	LDA	#>ERRM	
	LDY	#ERRML	
	JSR	DLINE	; PRINT ERROR MESSAGE

	; FALL THROUGH


; ----
; QUIT
; ----

ZQUIT:	JSR	ZCRLF	; FLUSH BUFFER

	LDA	TOP	; AND IF ENTER HERE
	STA	WTOP	; SCROLL ONLY WHAT SHOULD

	LDX	#<ENDM	
	LDA	#>ENDM	
	LDY	#ENDML	
	JSR	DLINE	; "END OF STORY"
	JMP	DOWARM


; -------
; RESTART
; -------

ZSTART:	JSR	ZCRLF	; FLUSH BUFFER

	LDA	TOP	; AND IF ENTER HERE
	STA	WTOP	; SCROLL ONLY WHAT SHOULD

	LDX	#<RSTRT
	LDA	#>RSTRT
	LDY	#RSTRTL
	JSR	DLINE


DOWARM:	JSR	GETRET
	LDX	#0	
	STX	WTOP	; RESET FULL SCREEN FOR CLEAR
REX:	JSR	SIDE1	; NEED SIDE 1 AGAIN
	JMP	WARM1	; AND DO WARMSTART

ENDM:	DB	"End of session."
	DB	EOL	
RSTRT:	DB	"Press [RETURN] to restart."
	DB	EOL
ENDML	EQU	$-ENDM
RSTRTL	EQU	$-RSTRT


; --------------------------
; RETURN TOP RAM PAGE IN [A]
; --------------------------

MEMTOP:	LDA	#$FB	; FOR NOW, ASSUME LAST "BUFFER"
	RTS		; OF AUX MEMORY


; -------------------
; Z-PRINT A CHARACTER
; -------------------
; ENTRY: ASCII CHAR IN [A]
;
; COMMENT: SCRIPTING IS HANDLED IN UNBUFR AND FLUSH,
; SO CAN OUTPUT TO PRINTER AS A LINE.  TABLE AND SCREEN
; OUTPUT IS SET UP HERE, HANDLED A BYTE AT A TIME
; (DIROUT CHANGES 6/24/85)

COUT:	STA	IOCHAR	; HOLD IT A SEC
	LDX	TABLEF	; OUTPUT TO TABLE?
	BEQ	COUT4	; NO
	JMP	TBLRTN	; YES, DO IT (TBL ONLY 4.7.86)
COUT4:	LDX	SCREENF	; OUTPUT TO SCREEN?
	BNE	COUT5	; YES
	LDX	SCRIPTF	; OUTPUT TO PRINTER?
	BNE	COUT5	; YES
	RTS		; NO, SO DONE
COUT5:	LDA	IOCHAR	; RETRIEVE CHAR
	LDX	BUFFLG	; UNBUFFERED OUTPUT?
	BNE	UNBUFR	; YES, PLACE ON SCREEN IMMED.
	CMP	#EOL	; IF ASCII EOL,
	BNE	COUT0	
	JMP	ZCRLF	; DO IT
COUT0:	CMP	#SPACE	; IGNORE ALL OTHER
	BCC	CEX	; CONTROLS

COUT3:	LDX	CHRCNT	; GET LINE POINTER
	STA	LBUFF,X	; ADD CHAR TO BUFFER
	LDY	LENGTH	; GET LINE LENGTH COUNTER
	CPY	XSIZE	; END OF SCREEN LINE?
	BCC	COUT2	
	JMP	FLUSH	; YES, FLUSH THE LINE
COUT2:	INC	LENGTH	; ELSE UPDATE
	INC	CHRCNT	
CEX:	RTS		


; --------------------------
; DIRECT, UNBUFFERED DISPLAY
; --------------------------

UNBUFR:	STA	IOCHAR	; HOLD IN CASE NEED TO PRINT
	CMP	#SPACE	; IGNORE CONTROLS
	BCC	UNBEX	

	SEC
	JSR	PLOT
	CPY	#80	; CHECK IF BEYOND SCREEN
	BCS	UNBEX	; YES, LEAVE
	LDA	SPLITF	; CHECK WHICH WINDOW
	BEQ	UNBBOT	; BOTTOM WINDOW

	CPX	TOP	; CHECK IF WITHIN WINDOW
	BCS	UNBEX	; NO, JUST LEAVE
	BCC	UNBDIS	; YES, GO DISPLAY

UNBBOT:	CPX	TOP	
	BCC	UNBEX	; NOT WITHIN WINDOW, LEAVE

UNBDIS:	LDA	SCREENF	; DISPLAY TO SCREEN?
	BEQ	UNBPRN	; NO, CHECK IF PRINTING
	LDA	IOCHAR	
	JSR	LETTER	; DO VOODOO AND DISPLAY

UNBPRN:	LDA	SPLITF	; SPLIT (NON-TEXT) SCREEN
	BNE	UNBEX	; DON'T PRINT

	;SEND CHAR TO PRINTER

	LDA	#1	; SET FOR PRINT RTN
	STA	PRLEN
	LDA	IOCHAR
	STA	LBUFF
	JSR	PPRINT	; AND GO ATTEMPT IT
	LDA	#0	; MAKE SURE NO LEFTOVER
	STA	PRLEN
UNBEX:	RTS		


; ---------------
; OUTPUT TO TABLE
; ---------------

TBLRTN:	TAX		; HOLD CHAR A SEC.

	;PUT BYTE IN TABLE AT CURRENT OFFSET

	LDA	DIRITM+LO	; ADD IN OFFSET
	CLC		
	ADC	DIRTBL+LO	
	STA	I+LO	
	LDA	DIRITM+HI	
	ADC	DIRTBL+HI	
	STA	I+HI	
	LDY	#0	
	TXA		; PICK UP ASCII CHAR
	STA	(I),Y	; STORE IT IN TBL @ BYTE ALIGNED @

;SET ITM OFFSET TO NEXT POSITION, INCREMENT COUNTER

	INC	DIRITM+LO	; INC OFFSET TO NEXT BYTE
	BNE	TBLRTS	
	INC	DIRITM+HI	
TBLRTS:	RTS		


; -------------------
; FLUSH OUTPUT BUFFER
; -------------------
; ENTRY: LENGTH OF BUFFER IN [X]

FLUSH:	LDA	#SPACE	; SPACE
	STX	OLDEND	; SAVE CURRENT END OF LINE
FL0:	CMP	LBUFF,X	; FIND LAST SPACE CHAR
	BEQ	FL1	; IN THE LINE
	DEX		
	BNE	FL0	; IF NONE FOUND,
	LDX	XSIZE	; FLUSH ENTIRE LINE
FL1:	STX	OLDLEN	; SAVE OLD LINE POS HERE
	STX	CHRCNT	; MAKE IT THE NEW LINE LENGTH
	JSR	ZCRLF	; PRINT LINE UP TO LAST SPACE

; START NEW LINE WITH REMAINDER OF OLD

	LDX	OLDLEN	; GET OLD LINE POS
	LDY	#0	; START NEW LINE AT BEGINNING
FL2:	INX		
	CPX	OLDEND	; CONTINUE IF
	BCC	FL3	; INSIDE OR
	BEQ	FL3	; AT END OF LINE
	STY	LENGTH	; ELSE SET NEW LINE LENGTH
	STY	CHRCNT	
	RTS		
FL3:	LDA	LBUFF,X	; GET CHAR FROM OLD LINE
	STA	LBUFF,Y	; MOVE TO START OF NEW LINE
	INY		; UPDATE LENGTH OF NEW LINE
	BNE	FL2	; (ALWAYS)


; ---------------
; CARRIAGE RETURN
; ---------------

ZCRLF:	LDX	CHRCNT	
	LDA	#EOL	; INSTALL EOL AT
	STA	LBUFF,X	; END OF CURRENT LINE
	INC	CHRCNT	; UPDATE LINE LENGTH
	LDA	SCREENF	; CHECK IF DISPLAYING TO SCREEN
	BEQ	ZCRLFX	; NO, GO HANDLE IF PRINTING
	LDA	SPLITF	; AT SPLIT SCREEN
	BNE	ZCRLF0	; YES
	INC	LINCNT	; NEW LINE GOING OUT
ZCRLF0:	LDX	LINCNT	; IS IT TIME TO
	INX		; (A LINE FOR "MORE")
	CPX	WBOTM	; PRINT "MORE" YET?
	BCC	ZCRLFX	; NO, CONTINUE
	BEQ	ZCRLFX	; also no continue
	LDA	WTOP	
	STA	LINCNT	; RESET LINE COUNTER
	INC	LINCNT	; LEAVE 1 LINE ON SCREEN

	SEC
	JSR	PLOT	; GET CURSOR POSITION
	STY	OLDX
	STX	OLDY

	LDX	WBOTM	;#23p
	LDY	#0
	CLC
	JSR	PLOT	; BOTTOM LEFT OF SCREEN

	LDA	#146	; IF GET HERE INVERSE
	JSR	CHROUT	; SHOULD BE OFF SO TURN OFF

	LDX	#<MORE
	LDA	#>MORE
	LDY	#MOREL
	JSR	DLINE	; PRINT MORE DIRECTLY

	LDA	#0
	STA	NDX	; CLEAR INPUT QUEUE

ZCR0:	JSR	GETIN	; GET ANY KEYPRESS
	TAX
	BEQ	ZCR0

	LDX	WBOTM	;#23
	LDY	#0
	CLC
	JSR	PLOT	; RESTORE CURSOR

	LDX	#<MCLR
	LDA	#>MCLR
	LDY	#MOREL
	JSR	DLINE	; RUB OUT "MORE"

	LDY	OLDX
	LDX	OLDY
	CLC
	JSR	PLOT	; RESTORE CURSOR

ZCRLFX:	JSR	LINOUT	; DISPLAY LINE
	LDA	#0	
	STA	LENGTH	; AND RESET LINE COUNT
	STA	CHRCNT	
	RTS		

LINOUT:	LDY	CHRCNT	; IF BUFFER EMPTY,
	BEQ	LINEX	; DON'T PRINT ANYTHING
	STY	PRLEN	; SAVE LENGTH HERE FOR "PPRINT"
	LDA	SCREENF	; DISPLAY TO SCREEN?
	BEQ	LOUT1	; NO, GO CHECK IF PRINT

	LDA	WTOP
	PHA

	LDA	SPLITF
	BNE	LOUT2	; NON SCROLLING SCREEN
	LDA	TOP
	STA	WTOP

LOUT2:	LDX	#0	; SEND CONTENTS OF [LBUFF]
LOUT:	LDA	LBUFF,X	; TO SCREEN
	JSR	CHAR	
	INX		
	DEY		
	BNE	LOUT	

	PLA		; RESET FOR FULL SCREEN ACCESS
	STA	WTOP

LOUT1:	LDA	SPLITF	; DON'T PRINT IF SPLIT (NON-TEXT) SCREEN (EZIP)
	BNE	LINEX	
	JSR	PPRINT	; PRINT [LBUFF] IF ENABLED
LINEX:	RTS		; AND RETURN


; ----------------------
; UPDATE THE STATUS LINE
; ----------------------
; NOT APPLICABLE IN EZIP.
ZUSL:	RTS		


; ------
; BUFOUT
; ------
; INPUT: ARG1 = BUFFERED (1) OR NONBUFFERED (0) OUTPUT CHOICE
; EXIT: FLAG (BUFFLG) IS SET TO TELL COUT WHICH TO DO

ZBUFOUT: LDX	ARG1+LO	
	BNE	ZBUF1	; SET TO BUFFERED OUTPUT
	JSR	LINOUT	; CLEAR BUFFER (DON'T RESET LINE COUNT)

	LDX	#0	
	STX	CHRCNT	
	INX		
	STX	BUFFLG	; SET FUTURE OUTPUT TO BE UNBUFFERED
	RTS		
ZBUF1:	DEX		
	BNE	ZBUFEX	; INVALID
	STX	BUFFLG	; SET TO BUFFERED
ZBUFEX:	RTS		


; ------
; DIROUT
; ------
; ARG1 CONTAINS VALUE OF WHICH DEVICE TO SELECT
; OR DESELECT, ARG2 = THE TABLE ADDR FOR TABLE OUTPUT
; MULTIPLE DEVICE USAGE IS POSSIBLE.

ZDIRT:	LDX	ARG1+LO
	BMI	DIRRES		; NEGATIVE VALUE, DESELECTING
	DEX
	BEQ	DIR1		; 1 = SET OUTPUT TO SCREEN
	DEX
	BEQ	DIR2		; 2 = SCRIPTING
	DEX
	BEQ	DIR3		; 3 = TABLE
	DEX
	BEQ	DIR4		; 4 = RECORDING DEVICE (NOT IMPLEMENTED)
DIR4:	RTS			; INVALID VALUE
DIRRES:	INX
	BEQ	DRES1		; -1 = RESET TO SCREEN
	INX
	BEQ	DRES2
	INX
	BEQ	DRES3
	INX
	BEQ	DRES4
DRES4:	RTS			; INVALID VALUE, JUST LEAVE

DIR1:	INX			; 1, TURN SCREEN OUTPUT ON
	STX	SCREENF
	RTS

DRES1:	STX	SCREENF		; 0, TURN SCREEN OFF
	RTS

DIR2:	INX
	STX	SCRIPTF		; SET SCRIPT FLAG ON
	LDA	ZBEGIN+ZSCRIP+1	; SET GAME FLAG ALSO
	ORA	#%00000001
	STA	ZBEGIN+ZSCRIP+1
	RTS			; YES, READY TO LEAVE

DRES2:	STX	SCRIPTF		; TURN PRINTER OFF
	LDA	ZBEGIN+ZSCRIP+1	; AND TURN OFF GAME FLAG TOO
	AND	#%11111110
	STA	ZBEGIN+ZSCRIP+1
	RTS

DIR3:	INX
	STX	TABLEF		; TURN TABLE OUTPUT FLAG ON
	LDA	ARG2+HI		; SET UP TBL
	CLC
	ADC	ZCODE
	LDX	ARG2+LO		; TO STORE CHARS IN
	STX	DIRTBL+LO
	STA	DIRTBL+HI
	LDA	#2
	STA	DIRITM+LO
	LDA	#0
	STA	DIRITM+HI
	RTS

DRES3:	LDA	TABLEF		; IF ALREADY OFF
	BEQ	DROUT		; LEAVE AS IS

	STX	TABLEF		; TURN TBL OUTPUT OFF
	LDA	DIRITM+LO	; MARK END OF CHARS IN TBL
	CLC			; WITH A NULL CHAR
	ADC	DIRTBL+LO
	STA	I+LO
	LDA	DIRITM+HI
	ADC	DIRTBL+HI
	STA	I+HI		; ALIGNED AT EOL
	LDA	#0
	TAY
	STA	(I),Y		; PLACE 0 IN TBL
	LDY	#1		; GET CHAR COUNT
	LDA	DIRITM+LO	; (2 LESS THAN [DIRITM])
	SEC
	SBC	#2
	STA	(DIRTBL),Y
	BCS	RESET0
	DEC	DIRITM+HI
RESET0:	LDA	DIRITM+HI
	DEY
	STA	(DIRTBL),Y	; STORE CHAR COUNT IN TBL
	LDA	#0		; CLEAR COUNT FOR NEXT TIME
	STA	DIRFLG		; SET OUTPUT TO SCREEN
DROUT:	RTS


; ------
; CURSET
; ------
; SET CURSOR AT LINE (ARG1) AS OFFSET FROM TOP OF WINDOW
; AND AT COLUMN (ARG2)

ZCURST:	LDA	ZBEGIN+ZMODE	
	AND	#%00010000	
	BEQ	ZCUREX	; NOT ENABLED
	LDA	SPLITF	
	BEQ	ZCUREX	; OOPS, IN SCROLLING TOP
	LDA	BUFFLG	
	BEQ	ZCUREX	; OOPS, UNBUFFERED

	LDX	ARG1+LO	; GET LINE
	DEX		; ZERO ALIGN IT
	LDY	ARG2+LO	; GET COLUMN
	DEY		; ZERO ALIGN IT
	CLC
	JSR	PLOT	; MOVE THE CURSOR
ZCUREX:	RTS


; --------------
; CURGET & DIRIN
; --------------
; NOT YET IMPLEMENTED, BUT RESERVED

ZCURGT:			
ZDIRIN:	RTS		


; ------
; HLIGHT
; ------

ZLIGHT:	LDA	ZBEGIN+ZMODE	; CHECK IF ENABLED
	AND	#%00001010	
	BEQ	ZLEX	; NOPE

	LDX	ARG1+LO	; GET CHOICE OF MODE
	BNE	ZL1	

	LDA	#146	; REVERSE OFF
	JSR	HLIGHT
	LDA	#130	; UNDERLINE OFF
	JMP	HLIGHT
ZLEX:	RTS		

ZL1:	CPX	#1	; INVERSE?
	BNE	ZL2

	LDA	#$12	; INVERSE
	JMP	HLIGHT

ZL2:	CPX	#4	; UNDERLINE?
	BNE	ZLEX	; NO OTHER ON C128

	LDA	#$02	; UNDERLINE

HLIGHT:	STA	IOCHAR		; HOLD COMMAND CHAR
	LDA	SCREENF		; IF NOT PRINTING TO
	BNE	DOLIGHT		; SCREEN OR PRINTER, SKIP THIS
	LDA	SCRIPTF
	BNE	DOLIGHT
	RTS
DOLIGHT:	LDA	IOCHAR
	LDX	BUFFLG
	BEQ	BUFFD
	JMP	CHROUT		; UNBUFFERED, CHANGE IMMEDIATELY

BUFFD:	LDX	CHRCNT		; BUFFERED, PLACE
	STA	LBUFF,X		; DISPLAY BUFFER
	INC	CHRCNT		; INC CHRCNT BUT NOT! LINE LENGTH
	RTS


; -----
; ERASE
; -----

ZERASE:	LDA	ZBEGIN+ZMODE	; ENABLED?
	AND	#%00010000	
	BEQ	ZEROUT		; NO
	LDA	ARG1+LO
	CMP	#1
	BNE	ZEROUT		; INVALID

	SEC			; CLEAR TO END OF LINE
	JSR	PLOT
	STX	OLDX
	STY	OLDY

ZERLP:	INY
	CPY	#80
	BCS	ZERDUN
	LDA	#SPACE
	JSR	CHROUT
	JMP	ZERLP

ZERDUN:	LDX	OLDX		; RESET CURSOR
	LDY	OLDY
	CLC
	JSR	PLOT

ZEROUT:	RTS


; -----
; CLEAR
; -----

ZCLR:	LDA	ZBEGIN+ZMODE	
	AND	#%00000001	
	BEQ	ZEROUT	; NOT ENABLED
	LDA	ARG1+LO	; CHECK WHAT TO DO
	BEQ	CLR0	; BOTTOM SCREEN
	CMP	#1	
	BEQ	CLR1	; TOP SCREEN
	CMP	#$FF	
	BNE	ZEROUT	; INVALID

; UNSPLIT SCREEN & CLEAR IT

	JSR	NORL	; RESET TO FULL
	LDA	#CLS	; & CLEAR IT
	JSR	CHROUT
	RTS

CLR0:	LDA	WTOP	; KEEP
	PHA
	LDA	TOP	; SET COUNT
	STA	LINCNT	; FOR "MORE"
	STA	WTOP	; AND PROPER WINDOW TOP
	LDA	#CLS	; CLEAR & HOME
	JSR	CHROUT
	PLA
	STA	WTOP
	LDX	WBOTM	;#$17	; SET CURSOR @
	LDY	#0	; BOTTOM OF SCREEN
	CLC
	JMP	PLOT
CLR1:	LDA	WBOTM
	PHA

	LDY	#0	; TOP OF SCREEN
	STY	WTOP
	LDX	TOP
	STX	WBOTM	; MAKE BOTTOM OF TOP SCREEN
	LDA	#CLS
	JSR	CHROUT

	PLA		; RESET TOP & BOTTOM
	STA	WBOTM
	CLC
	JMP	PLOT


; -----
; INPUT
; -----

ZINPUT:	LDA	ARG1+LO	
	CMP	#1	; KEYBOARD?
	BEQ	ZINP7
	JMP	RET0	; NO, INVALID

ZINP7:	LDA	WTOP	; RESET LINE COUNT
	STA	LINCNT	
	LDA	#0	
	STA	LENGTH	; SET LINE COUNT TO 0
	STA	CHRCNT	
	STA	NDX	; CLEAR INPUT QUEUE

	DEC	NARGS	
	BNE	ZINP8
	JMP	ZINP3	; NO TIME LIMIT

ZINP8:	LDA	ARG2+LO	; GET DELAY WANTED
	STA	I+HI	
	LDA	#0	; SET FCN IF IS ONE
	STA	J+HI	
	STA	J+LO	
	DEC	NARGS	
	BEQ	ZINP4	; NO FCN
	LDA	ARG3+LO	
	STA	J+LO	
	LDA	ARG3+HI	
	STA	J+HI	

ZINP4:	SEC
	JSR	PLOT
	STX	OLDX
	STY	OLDY

	LDA	#$E4		; TURN CURSOR ON
	STA	ULINE
	JSR	CHROUT

	LDX	OLDX
	LDY	OLDY
	CLC
	JSR	PLOT

	LDX	#0
	STX	BLINK+LO	; RESET THE BLINK COUNTER
	STX	BLINK+HI	; FOR A LONG DELAY

ZINP0:	LDA	I+HI	
	STA	I+LO	; RESET EA TIME THRU

ZINP1:	LDA	#249	; = 7, TIME COUNTS UP
	STA	TIME
ZINP2:	LDA	TIME
	BNE	ZINP2

	JSR	GETIN		; GET A KEY
	CMP	#0
	BEQ	ZINP6		; NO KEY YET
	JSR	GOTKEY
	JMP	ZINP5		; [A] NOW HAS PROPER CODE

ZINP6:	INC	BLINK+LO	; TIME TO BLINK YET?
	BNE	NOBLNK		; NOT TILL BOTH BLINK TIMERS
	INC	BLINK+HI	; ARE ZERO
	BNE	NOBLNK

	LDA	ULINE
	AND	#$C4		; MAKE _ OR BLANK, SO "BLINKS"
	JSR	CHROUT

	LDX	OLDX
	LDY	OLDY
	CLC
	JSR	PLOT

NOBLNK:	DEC	I+LO	
	BNE	ZINP1		; SOME TIME LEFT, TRY AGAIN

; TIME OUT, CHECK IF THERE IS A FCN TO CALL

	LDA	J+LO	; FCN IN J IF THERE IS ONE
	ORA	J+HI	
	BEQ	ZINPEX	; NO FCN, SEND 0 FOR FAILED
	JSR	INTCLL	; INTERNAL CALL
	LDA	VALUE+LO	; GET RESULTS
	BNE	ZINPEX	; ABORT
	BEQ	ZINP0	; TRY AGAIN

ZINP3:	JSR	GETKEY	; OK, FIND WHICH CHAR WAS PRESSED

ZINP5:	CMP	#BACKSP		; GAME EXPECTS ASCII BS
	BNE	ZINP9
	LDA	#$08		; WHICH IS $08
ZINP9:	LDX	#0	
	JMP	PUTBYT	; RETURN CHAR

ZINPEX:	JMP	RET0	; OOPS


INTCLL:	LDA	#>ZIRET	; SET ZRETURN TO RETURN HERE
	STA	PATCHI+HI	
	LDA	#<ZIRET	
	STA	PATCHI+LO	
	LDA	I+HI	; SAVE VALUES FOR CALLING RTN
	PHA		
	LDA	J+HI	
	PHA		
	LDA	J+LO	
	PHA		
	LDX	OLDZSP+LO	; STUFF TAKEN FROM CALL.
	LDA	OLDZSP+HI	
	JSR	PUSHXA	
	LDA	ZPCL	
	JSR	PUSHXA	
	LDX	ZPCM	
	LDA	ZPCH	
	JSR	PUSHXA	

; FORM QUAD ALIGNED ADDR FROM [ARG3]

	LDA	#0	
	ASL	J+LO	; *4
	ROL	J+HI	
	ROL	A		
	STA	ZPCH	
	ASL	J+LO	
	ROL	J+HI	
	ROL	ZPCH	
	LDA	J+HI	; PICK UP NEW LOW BYTES
	STA	ZPCM	
	LDA	J+LO	
	STA	ZPCL	
	JSR	VLDZPC	
	JSR	NEXTPC	; FETCH # LOCALS TO PASS
	STA	J+LO	; SAVE HERE FOR COUNTING
	STA	J+HI	; AND HERE FOR LATER REFERENCE
	BEQ	INT2	; SKIP IF NO LOCALS
	LDA	#0	
	STA	I+LO	; ELSE INIT STORAGE INDEX
INT1:	LDY	I+LO	
	LDX	LOCALS+LO,Y	; GET LSB OF LOCAL INTO [X]
	LDA	LOCALS+HI,Y	; AND MSB INTO [A]
	JSR	PUSHXA	; PUSH LOCAL IN [X/A] ONTO Z-STACK
	JSR	NEXTPC	; GET MSB OF NEW LOCAL
	STA	I+HI	; SAVE IT HERE
	JSR	NEXTPC	; NOW GET LSB
	LDY	I+LO	; RESTORE INDEX
	STA	LOCALS+LO,Y	; STORE LSB INTO [LOCALS]
	LDA	I+HI	; RETRIEVE MSB
	STA	LOCALS+HI,Y	; STORE IT INTO [LOCALS]
	INY		
	INY		; UPDATE
	STY	I+LO	; THE STORAGE INDEX
	DEC	J+LO	; ANY MORE LOCALS?
	BNE	INT1	; YES, KEEP LOOPING
INT2:	LDX	J+HI	; # OF LOCALS
	TXA		
	JSR	PUSHXA	
	LDA	ZSP+LO	
	STA	OLDZSP+LO	
	LDA	ZSP+HI	
	STA	OLDZSP+HI	
	JMP	MLOOP	; GO DO FCN

	; RETURN FROM FCN WILL COME HERE

ZIRET:	LDA	#>PUTVAL	; REPAIR ZRETURN
	STA	PATCHI+HI	
	LDA	#<PUTVAL	
	STA	PATCHI+LO	
	PLA		; GET RID OF RTS FROM ZRET
	PLA		
	PLA		; RESTORE FOR CALLING RTN
	STA	J+LO	
	PLA		
	STA	J+HI	
	PLA		
	STA	I+HI	
	RTS		; GO BACK TO CALLER


;NARGS:	DB	00		; OPCODE+1	; (BYTE) # ARGUMENTS
;ARG1:	DB	00,00		; OPCODE+2	; (WORD) ARGUMENT #1
;ARG2:	DB	00,00		; OPCODE+4	; (WORD) ARGUMENT #2
;ARG3:	DB	00,00		; OPCODE+6	; (WORD) ARGUMENT #3
;ARG4:	DB	00,00		; OPCODE+8	; (WORD) ARGUMENT #4
;ARG5:	DB	00,00		; OPCODE+10	; (WORD)
;ARG6:	DB	00,00		; OPCODE+12	; (WORD)
;ARG7:	DB	00,00		; OPCODE+14	; (WORD)
;ARG8:	DB	00,00		; OPCODE+16	; (WORD)
;ABYTE:	DB	00		; OPCODE+18	; (BYTE) X-OP ARGUMENT BYTE
;BBYTE:	DB	00		; OPCODE+19	; (BYTE) XCALL ARG BYTE (EZIP)
;ADEX:	DB	00		; OPCODE+20	; (BYTE) X-OP ARGUMENT INDEX


IN:	DB	00,00,00,00,00,00,00,00,00
OUT:	DB	00,00,00,00,00,00,00,00,00

QUOT:	DB	00,00		; RDTBL1+4	; (WORD) QUOTIENT FOR DIVISION
REMAIN:	DB	00,00		; QUOT+2	; (WORD) REMAINDER FOR DIVISION
MTEMP:	DB	00,00		; REMAIN+2	; (WORD) MATH TEMPORARY REGISTER
QSIGN:	DB	00		; MTEMP+2	; (BYTE) SIGN OF QUOTIENT
RSIGN:	DB	00		; QSIGN+1	; (BYTE) SIGN OF REMAINDER
DIGITS:	DB	00		; RSIGN+1	; (BYTE) DIGIT COUNT FOR "PRINTN"
BLINK:	DB	00,00		; (WORD) COUNT CYCLE BETWEEN CURSOR BLINKS
ULINE:	DB	00		; (BYTE) UNDERLINE VALUE FOR CURSOR


MORE:	DB	"[MORE]"
MOREL	EQU	$-MORE
MCLR:	DB	"      "

SLOTM:	DB	EOL
	DB	"Printer Slot 1-7: "
SLOTML	EQU	$-SLOTM

STRYM:	DB	"The story is loading ..."
STRYML	EQU	$-STRYM

	END
