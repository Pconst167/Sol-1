	SUBTTL	MAINLOOP
	PAGE

	;MAIN INSTRUCTION INTERPRETATION LOOP
	PUBLIC	NXTINS,NXI0A$,NXI0B$,NXI0C$,NXI1$,NXI2$,NXI3$,NXI4$,NXI5$
	PUBLIC	NXI6$,NXI7$,NXI8$,NXI8A$,NXI9$,NXI10$,NXI11$,NXI12$,NXI14$
	PUBLIC	NXI15$
NXTINS	PROC
	CALL	NXTBYT		;GET THE OPERATION BYTE
	MOV	DX,AX		;SAVE A COPY
	CMP	AX,80H		;IS IT A 2OP?
	JAE	NXI00$		;YES
	JMP	NXI9$
NXI00$:	CMP	AX,0B0H		;NO, IS IT A 1OP?
	JGE	NXI0A$		;NO
	JMP	NXI12$		;YES
NXI0A$:	CMP	AX,0C0H		;IS IT A 0OP?
	JG	NXI0B$		;NO
	JMP	NXI13$		;YES
NXI0B$:	AND	AX,3FH		;IT'S EXTENDED, GET THE OPCODE
	SHL	AX,1		;MAKE IT A WORD OFFSET
	MOV	BP,AX		;GET THE OPERATOR POINTER
	MOV	SI,[BP+EXTOP]	; (6) REMOVED DS OVERRIDE
	CMP	SI,0
	JNE	NXI0C$		;OPERATION EXISTS
	JMP	NXI14$		;NO SUCH OPERATION
NXI0C$:	MOV	BP,4		; (A0) DEFAULT NUMBER OF MODE BITS
	CMP	DX,0ECH		; (A0) IS IT XCALL?
	JNZ	NXI0D$		; (A0) NO, GO ON AS USUAL
	MOV	BP,8		; (A0) 8 MODE SPECIFIERS
	CALL	NXTBYT		; (A0) GET THE FIRST MODE BYTE
	MOV	DX,AX		; (A0) SAVE IT
	CALL	NXTBYT		; (A0) GET THE SECOND MODE BYTE

	MOV	CX,4		; (A0) LOOP COUNT
NXI0E$:	PUSH	AX		; (A0) SAVE BITS IN PROPER ORDER hh
	SHR	AX,1		; (A0) MOVE THE BITS TO THE RIGHT
	SHR	AX,1		; (A0) MOVE THE BITS TO THE RIGHT
	LOOP	NXI0E$

	MOV	AX,DX		; (A0) GET SECOND BYTE
	JMP	NXI0F$		; (A0) FALL THROUGH TO PROCESS aabbccdd
	
NXI0D$:	CALL	NXTBYT		;GET THE ARGUMENT BYTE
NXI0F$:	MOV	CX,4		;SPLIT IT INTO 4 2-BIT MODE BYTES
NXI1$:	PUSH	AX
	SAR	AX,1
	SAR	AX,1
	LOOP	NXI1$
	MOV	CX,BP		;RETRIEVE THE 4 (OR 8) BYTES IN PROPER ORDER
	SUB	DX,DX
	MOV	BX,OFFSET ARGBLK;FIRST ARGUMENT SLOT
NXI2$:	POP	AX		;GET NEXT MODE BYTE?
	AND	AX,3		;CLEAR OFF UNWANTED BITS
	CMP	AX,3		;NO MORE ARGUMENTS?
	JE	NXI4$		;YES, FLUSH ANY OTHER MODE BYTES
	CALL	GETARG		;ELSE, GET THE NEXT ARGUMENT
	MOV	[BX],AX		;SAVE IT IN ARGUMENT BLOCK
	ADD	BX,2
	INC	DX		;REMEMBER NUMBER OF ARGS GOTTEN
NXI3$:	LOOP	NXI2$		;LOOP FOR REST OF MODE BYTES
	JMP	NXI5$
NXI4$:	DEC	CX		;DETERMINE NUMBER OF REMAINING MODE BYTES
	SHL	CX,1		;WORD COUNT
	ADD	SP,CX		;FLUSH THEM
NXI5$:	XCHG	CX,DX
	MOV	AX,CX		;NUMBER OF ARGS GOES HERE FOR OPERATOR TO USE
	CMP	BYTE PTR [SI],90H  ;(6)DOES OPERATOR WANT ARGBLK POINTER?
	JE	NXI8A$		;YES, CALL OPERATOR NOW
	DEC	CX		;NO, IT WANTS ARGS IN REGISTERS
	JL	NXI8A$		;NO ARGS, JUST CALL OPERATOR
	JE	NXI8$		;1 ARG, GET IT
	SUB	CX,2
	JL	NXI7$		;2 ARGS
	JE	NXI6$		;3 ARGS
	MOV	DX,ARGBLK[6]	;ELSE, 4 ARGS, GET 4TH
NXI6$:	MOV	CX,ARGBLK[4]	;GET 3RD
NXI7$:	MOV	BX,ARGBLK[2]	;GET 2ND
NXI8$:	MOV	AX,ARGBLK	;GET FIRST ARG
NXI8A$:	JMP	NXI15$		;AND CALL OPERATOR
NXI9$:	AND	AX,1FH		;2OP, EXTRACT OPERATION BITS
	SHL	AX,1		;MAKE IT A WORD OFFSET
	MOV	BP,AX		;FIND POINTER TO OPERATOR ROUTINE
	MOV	SI,[BP+EXTOP]	;(6) REMOVED DS OVERRIDE
	CMP	SI,0
	JE	NXI14$		;NO SUCH OPERATION
	MOV	AX,1		;ASSUME FIRST ARG IS AN IMMEDIATE
	TEST	DX,40H		;IS IT INSTEAD A VARIABLE?
	JE	NXI10$		;NO
	INC	AX		;YES, CHANGE MODE
NXI10$:	CALL	GETARG		;GET THE FIRST ARG
	PUSH	AX		;SAVE IT
	MOV	AX,1		;ASSUME SECOND ARG IS AN IMMEDIATE
	TEST	DX,20H		;IS IT INSTEAD A VARIABLE?
	JE	NXI11$		;NO
	INC	AX		;YES, CHANGE MODE
NXI11$:	CALL	GETARG		;GET THE SECOND ARG
	MOV	BX,AX		;POSITION IT
	POP	AX		;RECOVER FIRST ARG
	CMP	BYTE PTR [SI],90H  ;(6)DOES ROUTINE WANT ARGUMENT BLOCK?
	JNE	NXI15$		;NO, GO CALL IT
	MOV	ARGBLK,AX	;YES, MOVE ARGS TO ARGBLK
	MOV	ARGBLK[2],BX
	MOV	AX,2		;ALWAYS 2 ARGS
	JMP	NXI15$		;NOW CALL OPERATOR
NXI12$:	AND	DX,0FH		;1OP, EXTRACT OPERATION BITS
	SHL	DX,1		;MAKE IT A WORD OFFSET
	MOV	BP,DX		;GET OPERATOR ROUTINE POINTER
	MOV	SI,[BP+ONEOP]	;(6) REMOVED DS OVERRIDE
	CMP	SI,0
	JE	NXI14$		;ILLEGAL OPERATION
	SAR	AX,1		;EXTRACT MODE BITS
	SAR	AX,1
	SAR	AX,1
	SAR	AX,1
	AND	AX,3
	CALL	GETARG		;GET THE ARGUMENT
	JMP	NXI15$		;AND CALL OPERATOR
NXI13$:	AND	AX,0FH		;0OP, EXTRACT OPERATION BITS
	SHL	AX,1		;MAKE IT A WORD OFFSET
	MOV	BP,AX		;GET OPERATOR ROUTINE POINTER
	MOV	SI,[BP+ZEROOP]	; (6) REMOVED DS OVERRIDE
	CMP	SI,0
	JNE	NXI15$		;IT'S A LEGAL OPERATION
NXI14$:	FATAL	FTL5		;OTHERWISE, COMPLAIN
NXI15$:	CALL	SI		;CALL THE OPERATOR ROUTINE
	JMP	NXTINS		;AND LOOP FOR NEXT INSTRUCTION
NXTINS	ENDP
