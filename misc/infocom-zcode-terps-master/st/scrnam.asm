* SCRIPT A USER INPUT LINE, START IN A0, LEN IN D0, FLAG IN D1 FOR CR
*   (CALLED AFTER USER INPUT IS FINISHED, TO AVOID PROBLEMS WITH BACKSPACES)

SCRINP  MOVEM.L	A2/D2,-(SP)
	MOVE.L	A0,A2		* PROTECT ARGS
	MOVE.W	D0,D2

    IFEQ EZIP
	TST.W	VOPRNT(A6)	* SCRIPTING?
    ENDC
    IFEQ CZIP
	BSR	TSTSCR		* CHECK FOR SCRIPT REQUEST -- ACTIVE?
    ENDC
	BEQ.B	SCRIX3		* NO, EXIT

	TST.W	D2		* LENGTH OF INPUT
	BEQ.B	SCRIX2		* ZERO, JUST DO THE CR

SCRIX1	MOVE.B  (A2)+,D0	* SCRIPT NEXT CHAR
	BSR	SCRCHR		*   (USE BUFFERING, SO WRAP IS CORRECT)
	SUBQ.W	#1,D2
	BNE.B	SCRIX1

SCRIX2	TST.W	D1		* CR REQUESTED?
	BEQ	SCRIX3		* NO
	MOVEQ	#13,D0		* YES, ADD THE CR
	BSR	SCRCHR

SCRIX3	MOVEM.L (SP)+,D2/A2
	RTS

* OUTPUT THE SAVE/RESTORE FILENAME TO THE TRANSCRIPT (IF SCRIPTING)
*   (USER SELECTED NAME THROUGH A SPECIAL FILE DIALOG)

SCRNAM	MOVE.L	D1,-(SP)

	LEA	MSGSCN,A0	* 'File is '
	BSR	STRLEN		* LEAVE LENGTH OF STRING IN D0
	CLR.W	D1		* NO CR YET
	BSR	SCRINP
    DATA
MSGSCN	DC.B	'File is ',0
    TEXT

	LEA	_filename,A0	* NO PATHSPEC, TYPE IS ALWAYS '.SAV'
	BSR	STRLEN		* LEAVE LENGTH OF STRING IN D0
	MOVEQ	#1,D1		* END WITH CR
	BSR	SCRINP

	MOVE.L	(SP)+,D1
	RTS

* FIND LENGTH OF ASCIZ STRING, POINTER IN A0
*   RETURN POINTER IN A0 AND LENGTH IN D0

STRLEN	MOVE.L	A1,-(SP)
	MOVE.L	A0,A1
STRLX1  TST.B	(A1)+		* SEARCH FOR NULL
	BNE.B	STRLX1
	TST.B	-(A1)		* FOUND IT, BACKUP TO THE NULL
	MOVE.L	A1,D0
	SUB.L	A0,D0		* RETURN LENGTH
	MOVE.L	(SP)+,A1
	RTS

