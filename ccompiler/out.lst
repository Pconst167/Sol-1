0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; printf("%c %d %s\n", my_struct[0].c, my_struct[0].i, my_struct[0].m); 
0011   0408                            
0012   0408             ; --- START FUNCTION CALL
0013   0408                            
0014   0408 3B D4 0D      mov d, _my_struct_data ; $my_struct
0015   040B D7            push a
0016   040C DA            push d
0017   040D                            
0018   040D FD 2E 00 00   mov32 cb, $00000000
0018   0411 00 00 
0019   0413 E7            pop d
0020   0414 FD 13 05 00   mma 5 ; mov a, 5; mul a, b; add d, b
0021   0418 E4            pop a
0022   0419 58 03 00      add d, 3
0023   041C 2A            mov b, [d]
0024   041D 38 00 00      mov c, 0
0025   0420 FD AB         swp b
0026   0422 D8            push b
0027   0423                            
0028   0423 3B D4 0D      mov d, _my_struct_data ; $my_struct
0029   0426 D7            push a
0030   0427 DA            push d
0031   0428                            
0032   0428 FD 2E 00 00   mov32 cb, $00000000
0032   042C 00 00 
0033   042E E7            pop d
0034   042F FD 13 05 00   mma 5 ; mov a, 5; mul a, b; add d, b
0035   0433 E4            pop a
0036   0434 58 01 00      add d, 1
0037   0437 2A            mov b, [d]
0038   0438 38 00 00      mov c, 0
0039   043B FD AB         swp b
0040   043D D8            push b
0041   043E                            
0042   043E 3B D4 0D      mov d, _my_struct_data ; $my_struct
0043   0441 D7            push a
0044   0442 DA            push d
0045   0443                            
0046   0443 FD 2E 00 00   mov32 cb, $00000000
0046   0447 00 00 
0047   0449 E7            pop d
0048   044A FD 13 05 00   mma 5 ; mov a, 5; mul a, b; add d, b
0049   044E E4            pop a
0050   044F 58 00 00      add d, 0
0051   0452 32            mov bl, [d]
0052   0453 A7 00         mov bh, 0
0053   0455 38 00 00      mov c, 0
0054   0458 DD            push bl
0055   0459                            
0056   0459 26 12 0E      mov b, _s2 ; "%c %d %s\n"
0057   045C FD AB         swp b
0058   045E D8            push b
0059   045F 07 C7 04      call printf
0060   0462 51 07 00      add sp, 7
0061   0465             ; --- END FUNCTION CALL
0062   0465             ; return; 
0063   0465 F9            leave
0064   0466 05 0B         syscall sys_terminate_proc
0065   0468             ; printf("%c %d %s\n", my_struct[1].c, my_struct[1].i, my_struct[1].m); 
0066   0468                            
0067   0468             ; --- START FUNCTION CALL
0068   0468                            
0069   0468 3B D4 0D      mov d, _my_struct_data ; $my_struct
0070   046B D7            push a
0071   046C DA            push d
0072   046D                            
0073   046D FD 2E 01 00   mov32 cb, $00000001
0073   0471 00 00 
0074   0473 E7            pop d
0075   0474 FD 13 05 00   mma 5 ; mov a, 5; mul a, b; add d, b
0076   0478 E4            pop a
0077   0479 58 03 00      add d, 3
0078   047C 2A            mov b, [d]
0079   047D 38 00 00      mov c, 0
0080   0480 FD AB         swp b
0081   0482 D8            push b
0082   0483                            
0083   0483 3B D4 0D      mov d, _my_struct_data ; $my_struct
0084   0486 D7            push a
0085   0487 DA            push d
0086   0488                            
0087   0488 FD 2E 01 00   mov32 cb, $00000001
0087   048C 00 00 
0088   048E E7            pop d
0089   048F FD 13 05 00   mma 5 ; mov a, 5; mul a, b; add d, b
0090   0493 E4            pop a
0091   0494 58 01 00      add d, 1
0092   0497 2A            mov b, [d]
0093   0498 38 00 00      mov c, 0
0094   049B FD AB         swp b
0095   049D D8            push b
0096   049E                            
0097   049E 3B D4 0D      mov d, _my_struct_data ; $my_struct
0098   04A1 D7            push a
0099   04A2 DA            push d
0100   04A3                            
0101   04A3 FD 2E 01 00   mov32 cb, $00000001
0101   04A7 00 00 
0102   04A9 E7            pop d
0103   04AA FD 13 05 00   mma 5 ; mov a, 5; mul a, b; add d, b
0104   04AE E4            pop a
0105   04AF 58 00 00      add d, 0
0106   04B2 32            mov bl, [d]
0107   04B3 A7 00         mov bh, 0
0108   04B5 38 00 00      mov c, 0
0109   04B8 DD            push bl
0110   04B9                            
0111   04B9 26 12 0E      mov b, _s2 ; "%c %d %s\n"
0112   04BC FD AB         swp b
0113   04BE D8            push b
0114   04BF 07 C7 04      call printf
0115   04C2 51 07 00      add sp, 7
0116   04C5             ; --- END FUNCTION CALL
0117   04C5 05 0B         syscall sys_terminate_proc
0118   04C7             
0119   04C7             printf:
0120   04C7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0121   04CA             ; char *p, *format_p; 
0122   04CA 52 02 00      sub sp, 2
0123   04CD 52 02 00      sub sp, 2
0124   04D0             ; format_p = format; 
0125   04D0 FA FD FF      lea d, [bp + -3] ; $format_p
0126   04D3 DA            push d
0127   04D4                            
0128   04D4 FA 05 00      lea d, [bp + 5] ; $format
0129   04D7 2A            mov b, [d]
0130   04D8 38 00 00      mov c, 0
0131   04DB E7            pop d
0132   04DC FD 43         mov [d], b
0133   04DE             ; p = &format + 2; 
0134   04DE FA FF FF      lea d, [bp + -1] ; $p
0135   04E1 DA            push d
0136   04E2                            
0137   04E2 FA 05 00      lea d, [bp + 5] ; $format
0138   04E5 2D            mov b, d
0139   04E6             ; --- START TERMS
0140   04E6 D7            push a
0141   04E7 11            mov a, b
0142   04E8 FD 2E 02 00   mov32 cb, $00000002
0142   04EC 00 00 
0143   04EE 56            add b, a
0144   04EF E4            pop a
0145   04F0             ; --- END TERMS
0146   04F0 E7            pop d
0147   04F1 FD 43         mov [d], b
0148   04F3             ; for(;;){ 
0149   04F3             _for1_init:
0150   04F3             _for1_cond:
0151   04F3             _for1_block:
0152   04F3             ; if(!*format_p) break; 
0153   04F3             _if2_cond:
0154   04F3                            
0155   04F3 FA FD FF      lea d, [bp + -3] ; $format_p
0156   04F6 2A            mov b, [d]
0157   04F7 38 00 00      mov c, 0
0158   04FA 74            mov d, b
0159   04FB 32            mov bl, [d]
0160   04FC A7 00         mov bh, 0
0161   04FE 38 00 00      mov c, 0
0162   0501 C0 00 00      cmp b, 0
0163   0504 FD 71         seq ; !
0164   0506 C0 00 00      cmp b, 0
0165   0509 C6 12 05      je _if2_else
0166   050C             _if2_TRUE:
0167   050C             ; break; 
0168   050C 0A C2 07      jmp _for1_exit ; for break
0169   050F 0A BF 07      jmp _if2_exit
0170   0512             _if2_else:
0171   0512             ; if(*format_p == '%'){ 
0172   0512             _if3_cond:
0173   0512                            
0174   0512 FA FD FF      lea d, [bp + -3] ; $format_p
0175   0515 2A            mov b, [d]
0176   0516 38 00 00      mov c, 0
0177   0519 74            mov d, b
0178   051A 32            mov bl, [d]
0179   051B A7 00         mov bh, 0
0180   051D 38 00 00      mov c, 0
0181   0520             ; --- START RELATIONAL
0182   0520 D7            push a
0183   0521 11            mov a, b
0184   0522 FD 2E 25 00   mov32 cb, $00000025
0184   0526 00 00 
0185   0528 B0            cmp a, b
0186   0529 FD 71         seq ; ==
0187   052B E4            pop a
0188   052C             ; --- END RELATIONAL
0189   052C C0 00 00      cmp b, 0
0190   052F C6 9A 07      je _if3_else
0191   0532             _if3_TRUE:
0192   0532             ; format_p++; 
0193   0532                            
0194   0532 FA FD FF      lea d, [bp + -3] ; $format_p
0195   0535 2A            mov b, [d]
0196   0536 38 00 00      mov c, 0
0197   0539 FD 77         inc b
0198   053B FA FD FF      lea d, [bp + -3] ; $format_p
0199   053E FD 43         mov [d], b
0200   0540 FD 7D         dec b
0201   0542             ; switch(*format_p){ 
0202   0542             _switch4_expr:
0203   0542                            
0204   0542 FA FD FF      lea d, [bp + -3] ; $format_p
0205   0545 2A            mov b, [d]
0206   0546 38 00 00      mov c, 0
0207   0549 74            mov d, b
0208   054A 32            mov bl, [d]
0209   054B A7 00         mov bh, 0
0210   054D 38 00 00      mov c, 0
0211   0550             _switch4_comparisons:
0212   0550 C1 6C         cmp bl, $6c
0213   0552 C6 7E 05      je _switch4_case0
0214   0555 C1 4C         cmp bl, $4c
0215   0557 C6 7E 05      je _switch4_case1
0216   055A C1 64         cmp bl, $64
0217   055C C6 8E 06      je _switch4_case2
0218   055F C1 69         cmp bl, $69
0219   0561 C6 8E 06      je _switch4_case3
0220   0564 C1 75         cmp bl, $75
0221   0566 C6 BE 06      je _switch4_case4
0222   0569 C1 78         cmp bl, $78
0223   056B C6 EE 06      je _switch4_case5
0224   056E C1 63         cmp bl, $63
0225   0570 C6 1E 07      je _switch4_case6
0226   0573 C1 73         cmp bl, $73
0227   0575 C6 4E 07      je _switch4_case7
0228   0578 0A 7B 07      jmp _switch4_default
0229   057B 0A 87 07      jmp _switch4_exit
0230   057E             _switch4_case0:
0231   057E             _switch4_case1:
0232   057E             ; format_p++; 
0233   057E                            
0234   057E FA FD FF      lea d, [bp + -3] ; $format_p
0235   0581 2A            mov b, [d]
0236   0582 38 00 00      mov c, 0
0237   0585 FD 77         inc b
0238   0587 FA FD FF      lea d, [bp + -3] ; $format_p
0239   058A FD 43         mov [d], b
0240   058C FD 7D         dec b
0241   058E             ; if(*format_p == 'd' || *format_p == 'i') 
0242   058E             _if5_cond:
0243   058E                            
0244   058E FA FD FF      lea d, [bp + -3] ; $format_p
0245   0591 2A            mov b, [d]
0246   0592 38 00 00      mov c, 0
0247   0595 74            mov d, b
0248   0596 32            mov bl, [d]
0249   0597 A7 00         mov bh, 0
0250   0599 38 00 00      mov c, 0
0251   059C             ; --- START RELATIONAL
0252   059C D7            push a
0253   059D 11            mov a, b
0254   059E FD 2E 64 00   mov32 cb, $00000064
0254   05A2 00 00 
0255   05A4 B0            cmp a, b
0256   05A5 FD 71         seq ; ==
0257   05A7 E4            pop a
0258   05A8             ; --- END RELATIONAL
0259   05A8             ; --- START LOGICAL OR
0260   05A8 D7            push a
0261   05A9 11            mov a, b
0262   05AA FA FD FF      lea d, [bp + -3] ; $format_p
0263   05AD 2A            mov b, [d]
0264   05AE 38 00 00      mov c, 0
0265   05B1 74            mov d, b
0266   05B2 32            mov bl, [d]
0267   05B3 A7 00         mov bh, 0
0268   05B5 38 00 00      mov c, 0
0269   05B8             ; --- START RELATIONAL
0270   05B8 D7            push a
0271   05B9 11            mov a, b
0272   05BA FD 2E 69 00   mov32 cb, $00000069
0272   05BE 00 00 
0273   05C0 B0            cmp a, b
0274   05C1 FD 71         seq ; ==
0275   05C3 E4            pop a
0276   05C4             ; --- END RELATIONAL
0277   05C4 FD A8         sor a, b ; ||
0278   05C6 E4            pop a
0279   05C7             ; --- END LOGICAL OR
0280   05C7 C0 00 00      cmp b, 0
0281   05CA C6 EB 05      je _if5_else
0282   05CD             _if5_TRUE:
0283   05CD             ; print_signed_long(*(long *)p); 
0284   05CD                            
0285   05CD             ; --- START FUNCTION CALL
0286   05CD                            
0287   05CD FA FF FF      lea d, [bp + -1] ; $p
0288   05D0 2A            mov b, [d]
0289   05D1 38 00 00      mov c, 0
0290   05D4 74            mov d, b
0291   05D5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0292   05D8 FD 39         mov c, b ; And place it into C
0293   05DA 2A            mov b, [d] ; Lower Word in B
0294   05DB 12            mov a, c
0295   05DC FD AA         swp a
0296   05DE D7            push a
0297   05DF FD AB         swp b
0298   05E1 D8            push b
0299   05E2 07 C4 07      call print_signed_long
0300   05E5 51 04 00      add sp, 4
0301   05E8             ; --- END FUNCTION CALL
0302   05E8 0A 73 06      jmp _if5_exit
0303   05EB             _if5_else:
0304   05EB             ; if(*format_p == 'u') 
0305   05EB             _if6_cond:
0306   05EB                            
0307   05EB FA FD FF      lea d, [bp + -3] ; $format_p
0308   05EE 2A            mov b, [d]
0309   05EF 38 00 00      mov c, 0
0310   05F2 74            mov d, b
0311   05F3 32            mov bl, [d]
0312   05F4 A7 00         mov bh, 0
0313   05F6 38 00 00      mov c, 0
0314   05F9             ; --- START RELATIONAL
0315   05F9 D7            push a
0316   05FA 11            mov a, b
0317   05FB FD 2E 75 00   mov32 cb, $00000075
0317   05FF 00 00 
0318   0601 B0            cmp a, b
0319   0602 FD 71         seq ; ==
0320   0604 E4            pop a
0321   0605             ; --- END RELATIONAL
0322   0605 C0 00 00      cmp b, 0
0323   0608 C6 29 06      je _if6_else
0324   060B             _if6_TRUE:
0325   060B             ; print_unsigned_long(*(unsigned long *)p); 
0326   060B                            
0327   060B             ; --- START FUNCTION CALL
0328   060B                            
0329   060B FA FF FF      lea d, [bp + -1] ; $p
0330   060E 2A            mov b, [d]
0331   060F 38 00 00      mov c, 0
0332   0612 74            mov d, b
0333   0613 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0334   0616 FD 39         mov c, b ; And place it into C
0335   0618 2A            mov b, [d] ; Lower Word in B
0336   0619 12            mov a, c
0337   061A FD AA         swp a
0338   061C D7            push a
0339   061D FD AB         swp b
0340   061F D8            push b
0341   0620 07 57 09      call print_unsigned_long
0342   0623 51 04 00      add sp, 4
0343   0626             ; --- END FUNCTION CALL
0344   0626 0A 73 06      jmp _if6_exit
0345   0629             _if6_else:
0346   0629             ; if(*format_p == 'x') 
0347   0629             _if7_cond:
0348   0629                            
0349   0629 FA FD FF      lea d, [bp + -3] ; $format_p
0350   062C 2A            mov b, [d]
0351   062D 38 00 00      mov c, 0
0352   0630 74            mov d, b
0353   0631 32            mov bl, [d]
0354   0632 A7 00         mov bh, 0
0355   0634 38 00 00      mov c, 0
0356   0637             ; --- START RELATIONAL
0357   0637 D7            push a
0358   0638 11            mov a, b
0359   0639 FD 2E 78 00   mov32 cb, $00000078
0359   063D 00 00 
0360   063F B0            cmp a, b
0361   0640 FD 71         seq ; ==
0362   0642 E4            pop a
0363   0643             ; --- END RELATIONAL
0364   0643 C0 00 00      cmp b, 0
0365   0646 C6 67 06      je _if7_else
0366   0649             _if7_TRUE:
0367   0649             ; printx32(*(long int *)p); 
0368   0649                            
0369   0649             ; --- START FUNCTION CALL
0370   0649                            
0371   0649 FA FF FF      lea d, [bp + -1] ; $p
0372   064C 2A            mov b, [d]
0373   064D 38 00 00      mov c, 0
0374   0650 74            mov d, b
0375   0651 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0376   0654 FD 39         mov c, b ; And place it into C
0377   0656 2A            mov b, [d] ; Lower Word in B
0378   0657 12            mov a, c
0379   0658 FD AA         swp a
0380   065A D7            push a
0381   065B FD AB         swp b
0382   065D D8            push b
0383   065E 07 8B 0A      call printx32
0384   0661 51 04 00      add sp, 4
0385   0664             ; --- END FUNCTION CALL
0386   0664 0A 73 06      jmp _if7_exit
0387   0667             _if7_else:
0388   0667             ; err("Unexpected format in printf."); 
0389   0667                            
0390   0667             ; --- START FUNCTION CALL
0391   0667                            
0392   0667 26 1C 0E      mov b, _s3 ; "Unexpected format in printf."
0393   066A FD AB         swp b
0394   066C D8            push b
0395   066D 07 EB 0A      call err
0396   0670 51 02 00      add sp, 2
0397   0673             ; --- END FUNCTION CALL
0398   0673             _if7_exit:
0399   0673             _if6_exit:
0400   0673             _if5_exit:
0401   0673             ; p = p + 4; 
0402   0673 FA FF FF      lea d, [bp + -1] ; $p
0403   0676 DA            push d
0404   0677                            
0405   0677 FA FF FF      lea d, [bp + -1] ; $p
0406   067A 2A            mov b, [d]
0407   067B 38 00 00      mov c, 0
0408   067E             ; --- START TERMS
0409   067E D7            push a
0410   067F 11            mov a, b
0411   0680 FD 2E 04 00   mov32 cb, $00000004
0411   0684 00 00 
0412   0686 56            add b, a
0413   0687 E4            pop a
0414   0688             ; --- END TERMS
0415   0688 E7            pop d
0416   0689 FD 43         mov [d], b
0417   068B             ; break; 
0418   068B 0A 87 07      jmp _switch4_exit ; case break
0419   068E             _switch4_case2:
0420   068E             _switch4_case3:
0421   068E             ; print_signed(*(int*)p); 
0422   068E                            
0423   068E             ; --- START FUNCTION CALL
0424   068E                            
0425   068E FA FF FF      lea d, [bp + -1] ; $p
0426   0691 2A            mov b, [d]
0427   0692 38 00 00      mov c, 0
0428   0695 74            mov d, b
0429   0696 2A            mov b, [d]
0430   0697 38 00 00      mov c, 0
0431   069A FD AB         swp b
0432   069C D8            push b
0433   069D 07 19 0B      call print_signed
0434   06A0 51 02 00      add sp, 2
0435   06A3             ; --- END FUNCTION CALL
0436   06A3             ; p = p + 2; 
0437   06A3 FA FF FF      lea d, [bp + -1] ; $p
0438   06A6 DA            push d
0439   06A7                            
0440   06A7 FA FF FF      lea d, [bp + -1] ; $p
0441   06AA 2A            mov b, [d]
0442   06AB 38 00 00      mov c, 0
0443   06AE             ; --- START TERMS
0444   06AE D7            push a
0445   06AF 11            mov a, b
0446   06B0 FD 2E 02 00   mov32 cb, $00000002
0446   06B4 00 00 
0447   06B6 56            add b, a
0448   06B7 E4            pop a
0449   06B8             ; --- END TERMS
0450   06B8 E7            pop d
0451   06B9 FD 43         mov [d], b
0452   06BB             ; break; 
0453   06BB 0A 87 07      jmp _switch4_exit ; case break
0454   06BE             _switch4_case4:
0455   06BE             ; print_unsigned(*(unsigned int*)p); 
0456   06BE                            
0457   06BE             ; --- START FUNCTION CALL
0458   06BE                            
0459   06BE FA FF FF      lea d, [bp + -1] ; $p
0460   06C1 2A            mov b, [d]
0461   06C2 38 00 00      mov c, 0
0462   06C5 74            mov d, b
0463   06C6 2A            mov b, [d]
0464   06C7 38 00 00      mov c, 0
0465   06CA FD AB         swp b
0466   06CC D8            push b
0467   06CD 07 6A 0C      call print_unsigned
0468   06D0 51 02 00      add sp, 2
0469   06D3             ; --- END FUNCTION CALL
0470   06D3             ; p = p + 2; 
0471   06D3 FA FF FF      lea d, [bp + -1] ; $p
0472   06D6 DA            push d
0473   06D7                            
0474   06D7 FA FF FF      lea d, [bp + -1] ; $p
0475   06DA 2A            mov b, [d]
0476   06DB 38 00 00      mov c, 0
0477   06DE             ; --- START TERMS
0478   06DE D7            push a
0479   06DF 11            mov a, b
0480   06E0 FD 2E 02 00   mov32 cb, $00000002
0480   06E4 00 00 
0481   06E6 56            add b, a
0482   06E7 E4            pop a
0483   06E8             ; --- END TERMS
0484   06E8 E7            pop d
0485   06E9 FD 43         mov [d], b
0486   06EB             ; break; 
0487   06EB 0A 87 07      jmp _switch4_exit ; case break
0488   06EE             _switch4_case5:
0489   06EE             ; printx16(*(int*)p); 
0490   06EE                            
0491   06EE             ; --- START FUNCTION CALL
0492   06EE                            
0493   06EE FA FF FF      lea d, [bp + -1] ; $p
0494   06F1 2A            mov b, [d]
0495   06F2 38 00 00      mov c, 0
0496   06F5 74            mov d, b
0497   06F6 2A            mov b, [d]
0498   06F7 38 00 00      mov c, 0
0499   06FA FD AB         swp b
0500   06FC D8            push b
0501   06FD 07 82 0D      call printx16
0502   0700 51 02 00      add sp, 2
0503   0703             ; --- END FUNCTION CALL
0504   0703             ; p = p + 2; 
0505   0703 FA FF FF      lea d, [bp + -1] ; $p
0506   0706 DA            push d
0507   0707                            
0508   0707 FA FF FF      lea d, [bp + -1] ; $p
0509   070A 2A            mov b, [d]
0510   070B 38 00 00      mov c, 0
0511   070E             ; --- START TERMS
0512   070E D7            push a
0513   070F 11            mov a, b
0514   0710 FD 2E 02 00   mov32 cb, $00000002
0514   0714 00 00 
0515   0716 56            add b, a
0516   0717 E4            pop a
0517   0718             ; --- END TERMS
0518   0718 E7            pop d
0519   0719 FD 43         mov [d], b
0520   071B             ; break; 
0521   071B 0A 87 07      jmp _switch4_exit ; case break
0522   071E             _switch4_case6:
0523   071E             ; putchar(*(char*)p); 
0524   071E                            
0525   071E             ; --- START FUNCTION CALL
0526   071E                            
0527   071E FA FF FF      lea d, [bp + -1] ; $p
0528   0721 2A            mov b, [d]
0529   0722 38 00 00      mov c, 0
0530   0725 74            mov d, b
0531   0726 32            mov bl, [d]
0532   0727 A7 00         mov bh, 0
0533   0729 38 00 00      mov c, 0
0534   072C DD            push bl
0535   072D 07 49 09      call putchar
0536   0730 51 01 00      add sp, 1
0537   0733             ; --- END FUNCTION CALL
0538   0733             ; p = p + 1; 
0539   0733 FA FF FF      lea d, [bp + -1] ; $p
0540   0736 DA            push d
0541   0737                            
0542   0737 FA FF FF      lea d, [bp + -1] ; $p
0543   073A 2A            mov b, [d]
0544   073B 38 00 00      mov c, 0
0545   073E             ; --- START TERMS
0546   073E D7            push a
0547   073F 11            mov a, b
0548   0740 FD 2E 01 00   mov32 cb, $00000001
0548   0744 00 00 
0549   0746 56            add b, a
0550   0747 E4            pop a
0551   0748             ; --- END TERMS
0552   0748 E7            pop d
0553   0749 FD 43         mov [d], b
0554   074B             ; break; 
0555   074B 0A 87 07      jmp _switch4_exit ; case break
0556   074E             _switch4_case7:
0557   074E             ; print(*(char**)p); 
0558   074E                            
0559   074E             ; --- START FUNCTION CALL
0560   074E                            
0561   074E FA FF FF      lea d, [bp + -1] ; $p
0562   0751 2A            mov b, [d]
0563   0752 38 00 00      mov c, 0
0564   0755 74            mov d, b
0565   0756 2A            mov b, [d]
0566   0757 FD AB         swp b
0567   0759 D8            push b
0568   075A 07 00 0B      call print
0569   075D 51 02 00      add sp, 2
0570   0760             ; --- END FUNCTION CALL
0571   0760             ; p = p + 2; 
0572   0760 FA FF FF      lea d, [bp + -1] ; $p
0573   0763 DA            push d
0574   0764                            
0575   0764 FA FF FF      lea d, [bp + -1] ; $p
0576   0767 2A            mov b, [d]
0577   0768 38 00 00      mov c, 0
0578   076B             ; --- START TERMS
0579   076B D7            push a
0580   076C 11            mov a, b
0581   076D FD 2E 02 00   mov32 cb, $00000002
0581   0771 00 00 
0582   0773 56            add b, a
0583   0774 E4            pop a
0584   0775             ; --- END TERMS
0585   0775 E7            pop d
0586   0776 FD 43         mov [d], b
0587   0778             ; break; 
0588   0778 0A 87 07      jmp _switch4_exit ; case break
0589   077B             _switch4_default:
0590   077B             ; print("Error: Unknown argument type.\n"); 
0591   077B                            
0592   077B             ; --- START FUNCTION CALL
0593   077B                            
0594   077B 26 39 0E      mov b, _s4 ; "Error: Unknown argument type.\n"
0595   077E FD AB         swp b
0596   0780 D8            push b
0597   0781 07 00 0B      call print
0598   0784 51 02 00      add sp, 2
0599   0787             ; --- END FUNCTION CALL
0600   0787             _switch4_exit:
0601   0787             ; format_p++; 
0602   0787                            
0603   0787 FA FD FF      lea d, [bp + -3] ; $format_p
0604   078A 2A            mov b, [d]
0605   078B 38 00 00      mov c, 0
0606   078E FD 77         inc b
0607   0790 FA FD FF      lea d, [bp + -3] ; $format_p
0608   0793 FD 43         mov [d], b
0609   0795 FD 7D         dec b
0610   0797 0A BF 07      jmp _if3_exit
0611   079A             _if3_else:
0612   079A             ; putchar(*format_p); 
0613   079A                            
0614   079A             ; --- START FUNCTION CALL
0615   079A                            
0616   079A FA FD FF      lea d, [bp + -3] ; $format_p
0617   079D 2A            mov b, [d]
0618   079E 38 00 00      mov c, 0
0619   07A1 74            mov d, b
0620   07A2 32            mov bl, [d]
0621   07A3 A7 00         mov bh, 0
0622   07A5 38 00 00      mov c, 0
0623   07A8 DD            push bl
0624   07A9 07 49 09      call putchar
0625   07AC 51 01 00      add sp, 1
0626   07AF             ; --- END FUNCTION CALL
0627   07AF             ; format_p++; 
0628   07AF                            
0629   07AF FA FD FF      lea d, [bp + -3] ; $format_p
0630   07B2 2A            mov b, [d]
0631   07B3 38 00 00      mov c, 0
0632   07B6 FD 77         inc b
0633   07B8 FA FD FF      lea d, [bp + -3] ; $format_p
0634   07BB FD 43         mov [d], b
0635   07BD FD 7D         dec b
0636   07BF             _if3_exit:
0637   07BF             _if2_exit:
0638   07BF             _for1_update:
0639   07BF 0A F3 04      jmp _for1_cond
0640   07C2             _for1_exit:
0641   07C2 F9            leave
0642   07C3 09            ret
0643   07C4             
0644   07C4             print_signed_long:
0645   07C4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0646   07C7             ; char digits[10]; 
0647   07C7 52 0A 00      sub sp, 10
0648   07CA             ; int i = 0; 
0649   07CA 52 02 00      sub sp, 2
0650   07CD             ; --- START LOCAL VAR INITIALIZATION
0651   07CD FA F5 FF      lea d, [bp + -11] ; $i
0652   07D0 DA            push d
0653   07D1                            
0654   07D1 FD 2E 00 00   mov32 cb, $00000000
0654   07D5 00 00 
0655   07D7 E7            pop d
0656   07D8 FD 43         mov [d], b
0657   07DA             ; --- END LOCAL VAR INITIALIZATION
0658   07DA             ; if (num < 0) { 
0659   07DA             _if8_cond:
0660   07DA                            
0661   07DA FA 05 00      lea d, [bp + 5] ; $num
0662   07DD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0663   07E0 FD 39         mov c, b ; And place it into C
0664   07E2 2A            mov b, [d] ; Lower Word in B
0665   07E3             ; --- START RELATIONAL
0666   07E3 D7            push a
0667   07E4 FD D8         push g
0668   07E6 11            mov a, b
0669   07E7 FD 7A         mov g, c
0670   07E9 FD 2E 00 00   mov32 cb, $00000000
0670   07ED 00 00 
0671   07EF FD AF         cmp32 ga, cb
0672   07F1 FD 73         slt ; <
0673   07F3 FD F1         pop g
0674   07F5 E4            pop a
0675   07F6             ; --- END RELATIONAL
0676   07F6 C0 00 00      cmp b, 0
0677   07F9 C6 2B 08      je _if8_else
0678   07FC             _if8_TRUE:
0679   07FC             ; putchar('-'); 
0680   07FC                            
0681   07FC             ; --- START FUNCTION CALL
0682   07FC                            
0683   07FC FD 2E 2D 00   mov32 cb, $0000002d
0683   0800 00 00 
0684   0802 DD            push bl
0685   0803 07 49 09      call putchar
0686   0806 51 01 00      add sp, 1
0687   0809             ; --- END FUNCTION CALL
0688   0809             ; num = -num; 
0689   0809 FA 05 00      lea d, [bp + 5] ; $num
0690   080C DA            push d
0691   080D                            
0692   080D FA 05 00      lea d, [bp + 5] ; $num
0693   0810 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0694   0813 FD 39         mov c, b ; And place it into C
0695   0815 2A            mov b, [d] ; Lower Word in B
0696   0816 12            mov a, c
0697   0817 95            not a
0698   0818 97            not b
0699   0819 55 01 00      add b, 1
0700   081C 5B 00 00      adc a, 0
0701   081F 39            mov c, a
0702   0820 E7            pop d
0703   0821 FD 43         mov [d], b
0704   0823 28            mov b, c
0705   0824 FD 44 02 00   mov [d + 2], b
0706   0828 0A 5F 08      jmp _if8_exit
0707   082B             _if8_else:
0708   082B             ; if (num == 0) { 
0709   082B             _if9_cond:
0710   082B                             
0711   082B FA 05 00      lea d, [bp + 5] ; $num
0712   082E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0713   0831 FD 39         mov c, b ; And place it into C
0714   0833 2A            mov b, [d] ; Lower Word in B
0715   0834             ; --- START RELATIONAL
0716   0834 D7            push a
0717   0835 FD D8         push g
0718   0837 11            mov a, b
0719   0838 FD 7A         mov g, c
0720   083A FD 2E 00 00   mov32 cb, $00000000
0720   083E 00 00 
0721   0840 FD AF         cmp32 ga, cb
0722   0842 FD 71         seq ; ==
0723   0844 FD F1         pop g
0724   0846 E4            pop a
0725   0847             ; --- END RELATIONAL
0726   0847 C0 00 00      cmp b, 0
0727   084A C6 5F 08      je _if9_exit
0728   084D             _if9_TRUE:
0729   084D             ; putchar('0'); 
0730   084D                             
0731   084D             ; --- START FUNCTION CALL
0732   084D                             
0733   084D FD 2E 30 00   mov32 cb, $00000030
0733   0851 00 00 
0734   0853 DD            push bl
0735   0854 07 49 09      call putchar
0736   0857 51 01 00      add sp, 1
0737   085A             ; --- END FUNCTION CALL
0738   085A             ; return; 
0739   085A F9            leave
0740   085B 09            ret
0741   085C 0A 5F 08      jmp _if9_exit
0742   085F             _if9_exit:
0743   085F             _if8_exit:
0744   085F             ; while (num > 0) { 
0745   085F             _while10_cond:
0746   085F                             
0747   085F FA 05 00      lea d, [bp + 5] ; $num
0748   0862 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0749   0865 FD 39         mov c, b ; And place it into C
0750   0867 2A            mov b, [d] ; Lower Word in B
0751   0868             ; --- START RELATIONAL
0752   0868 D7            push a
0753   0869 FD D8         push g
0754   086B 11            mov a, b
0755   086C FD 7A         mov g, c
0756   086E FD 2E 00 00   mov32 cb, $00000000
0756   0872 00 00 
0757   0874 FD AF         cmp32 ga, cb
0758   0876 FD 7F         sgt
0759   0878 FD F1         pop g
0760   087A E4            pop a
0761   087B             ; --- END RELATIONAL
0762   087B C0 00 00      cmp b, 0
0763   087E C6 FF 08      je _while10_exit
0764   0881             _while10_block:
0765   0881             ; digits[i] = '0' + (num % 10); 
0766   0881 FA F7 FF      lea d, [bp + -9] ; $digits
0767   0884 D7            push a
0768   0885 DA            push d
0769   0886                             
0770   0886 FA F5 FF      lea d, [bp + -11] ; $i
0771   0889 2A            mov b, [d]
0772   088A 38 00 00      mov c, 0
0773   088D E7            pop d
0774   088E 5A            add d, b
0775   088F E4            pop a
0776   0890 DA            push d
0777   0891                             
0778   0891 FD 2E 30 00   mov32 cb, $00000030
0778   0895 00 00 
0779   0897             ; --- START TERMS
0780   0897 D7            push a
0781   0898 11            mov a, b
0782   0899                             
0783   0899 FA 05 00      lea d, [bp + 5] ; $num
0784   089C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0785   089F FD 39         mov c, b ; And place it into C
0786   08A1 2A            mov b, [d] ; Lower Word in B
0787   08A2             ; --- START FACTORS
0788   08A2 D7            push a
0789   08A3 FD D8         push g
0790   08A5 11            mov a, b
0791   08A6 FD 7A         mov g, c
0792   08A8 FD 2E 0A 00   mov32 cb, $0000000a
0792   08AC 00 00 
0793   08AE FD D8         push g ; save 'g' as the div instruction uses it
0794   08B0 AE            div a, b ; %, a: quotient, b: remainder
0795   08B1 11            mov a, b
0796   08B2 FD F1         pop g
0797   08B4 FD 38         mov c, g
0798   08B6 27            mov b, a
0799   08B7 FD F1         pop g
0800   08B9 E4            pop a
0801   08BA             ; --- END FACTORS
0802   08BA FD 15         add32 cb, ga
0803   08BC E4            pop a
0804   08BD             ; --- END TERMS
0805   08BD E7            pop d
0806   08BE FD 3E         mov [d], bl
0807   08C0             ; num = num / 10; 
0808   08C0 FA 05 00      lea d, [bp + 5] ; $num
0809   08C3 DA            push d
0810   08C4                             
0811   08C4 FA 05 00      lea d, [bp + 5] ; $num
0812   08C7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0813   08CA FD 39         mov c, b ; And place it into C
0814   08CC 2A            mov b, [d] ; Lower Word in B
0815   08CD             ; --- START FACTORS
0816   08CD D7            push a
0817   08CE FD D8         push g
0818   08D0 11            mov a, b
0819   08D1 FD 7A         mov g, c
0820   08D3 FD 2E 0A 00   mov32 cb, $0000000a
0820   08D7 00 00 
0821   08D9 FD D8         push g ; save 'g' as the div instruction uses it
0822   08DB AE            div a, b ; /, a: quotient, b: remainder
0823   08DC FD F1         pop g
0824   08DE FD 38         mov c, g
0825   08E0 27            mov b, a
0826   08E1 FD F1         pop g
0827   08E3 E4            pop a
0828   08E4             ; --- END FACTORS
0829   08E4 E7            pop d
0830   08E5 FD 43         mov [d], b
0831   08E7 28            mov b, c
0832   08E8 FD 44 02 00   mov [d + 2], b
0833   08EC             ; i++; 
0834   08EC                             
0835   08EC FA F5 FF      lea d, [bp + -11] ; $i
0836   08EF 2A            mov b, [d]
0837   08F0 38 00 00      mov c, 0
0838   08F3 11            mov a, b
0839   08F4 FD 77         inc b
0840   08F6 FA F5 FF      lea d, [bp + -11] ; $i
0841   08F9 FD 43         mov [d], b
0842   08FB 27            mov b, a
0843   08FC 0A 5F 08      jmp _while10_cond
0844   08FF             _while10_exit:
0845   08FF             ; while (i > 0) { 
0846   08FF             _while13_cond:
0847   08FF                             
0848   08FF FA F5 FF      lea d, [bp + -11] ; $i
0849   0902 2A            mov b, [d]
0850   0903 38 00 00      mov c, 0
0851   0906             ; --- START RELATIONAL
0852   0906 D7            push a
0853   0907 11            mov a, b
0854   0908 FD 2E 00 00   mov32 cb, $00000000
0854   090C 00 00 
0855   090E B0            cmp a, b
0856   090F FD 7F         sgt ; >
0857   0911 E4            pop a
0858   0912             ; --- END RELATIONAL
0859   0912 C0 00 00      cmp b, 0
0860   0915 C6 47 09      je _while13_exit
0861   0918             _while13_block:
0862   0918             ; i--; 
0863   0918                             
0864   0918 FA F5 FF      lea d, [bp + -11] ; $i
0865   091B 2A            mov b, [d]
0866   091C 38 00 00      mov c, 0
0867   091F 11            mov a, b
0868   0920 FD 7D         dec b
0869   0922 FA F5 FF      lea d, [bp + -11] ; $i
0870   0925 FD 43         mov [d], b
0871   0927 27            mov b, a
0872   0928             ; putchar(digits[i]); 
0873   0928                             
0874   0928             ; --- START FUNCTION CALL
0875   0928                             
0876   0928 FA F7 FF      lea d, [bp + -9] ; $digits
0877   092B D7            push a
0878   092C DA            push d
0879   092D                             
0880   092D FA F5 FF      lea d, [bp + -11] ; $i
0881   0930 2A            mov b, [d]
0882   0931 38 00 00      mov c, 0
0883   0934 E7            pop d
0884   0935 5A            add d, b
0885   0936 E4            pop a
0886   0937 32            mov bl, [d]
0887   0938 A7 00         mov bh, 0
0888   093A 38 00 00      mov c, 0
0889   093D DD            push bl
0890   093E 07 49 09      call putchar
0891   0941 51 01 00      add sp, 1
0892   0944             ; --- END FUNCTION CALL
0893   0944 0A FF 08      jmp _while13_cond
0894   0947             _while13_exit:
0895   0947 F9            leave
0896   0948 09            ret
0897   0949             
0898   0949             putchar:
0899   0949 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0900   094C             ; --- BEGIN INLINE ASM SEGMENT
0901   094C FA 05 00      lea d, [bp + 5] ; $c
0902   094F 1E            mov al, [d]
0903   0950 23            mov ah, al
0904   0951 19 00         mov al, 0
0905   0953 05 03         syscall sys_io      ; char in AH
0906   0955             ; --- END INLINE ASM SEGMENT
0907   0955 F9            leave
0908   0956 09            ret
0909   0957             
0910   0957             print_unsigned_long:
0911   0957 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0912   095A             ; char digits[10]; 
0913   095A 52 0A 00      sub sp, 10
0914   095D             ; int i; 
0915   095D 52 02 00      sub sp, 2
0916   0960             ; i = 0; 
0917   0960 FA F5 FF      lea d, [bp + -11] ; $i
0918   0963 DA            push d
0919   0964                             
0920   0964 FD 2E 00 00   mov32 cb, $00000000
0920   0968 00 00 
0921   096A E7            pop d
0922   096B FD 43         mov [d], b
0923   096D             ; if(num == 0){ 
0924   096D             _if14_cond:
0925   096D                             
0926   096D FA 05 00      lea d, [bp + 5] ; $num
0927   0970 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0928   0973 FD 39         mov c, b ; And place it into C
0929   0975 2A            mov b, [d] ; Lower Word in B
0930   0976             ; --- START RELATIONAL
0931   0976 D7            push a
0932   0977 FD D8         push g
0933   0979 11            mov a, b
0934   097A FD 7A         mov g, c
0935   097C FD 2E 00 00   mov32 cb, $00000000
0935   0980 00 00 
0936   0982 FD AF         cmp32 ga, cb
0937   0984 FD 71         seq ; ==
0938   0986 FD F1         pop g
0939   0988 E4            pop a
0940   0989             ; --- END RELATIONAL
0941   0989 C0 00 00      cmp b, 0
0942   098C C6 A1 09      je _if14_exit
0943   098F             _if14_TRUE:
0944   098F             ; putchar('0'); 
0945   098F                             
0946   098F             ; --- START FUNCTION CALL
0947   098F                             
0948   098F FD 2E 30 00   mov32 cb, $00000030
0948   0993 00 00 
0949   0995 DD            push bl
0950   0996 07 49 09      call putchar
0951   0999 51 01 00      add sp, 1
0952   099C             ; --- END FUNCTION CALL
0953   099C             ; return; 
0954   099C F9            leave
0955   099D 09            ret
0956   099E 0A A1 09      jmp _if14_exit
0957   09A1             _if14_exit:
0958   09A1             ; while (num > 0) { 
0959   09A1             _while15_cond:
0960   09A1                             
0961   09A1 FA 05 00      lea d, [bp + 5] ; $num
0962   09A4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0963   09A7 FD 39         mov c, b ; And place it into C
0964   09A9 2A            mov b, [d] ; Lower Word in B
0965   09AA             ; --- START RELATIONAL
0966   09AA D7            push a
0967   09AB FD D8         push g
0968   09AD 11            mov a, b
0969   09AE FD 7A         mov g, c
0970   09B0 FD 2E 00 00   mov32 cb, $00000000
0970   09B4 00 00 
0971   09B6 FD AF         cmp32 ga, cb
0972   09B8 FD 81         sgu
0973   09BA FD F1         pop g
0974   09BC E4            pop a
0975   09BD             ; --- END RELATIONAL
0976   09BD C0 00 00      cmp b, 0
0977   09C0 C6 41 0A      je _while15_exit
0978   09C3             _while15_block:
0979   09C3             ; digits[i] = '0' + (num % 10); 
0980   09C3 FA F7 FF      lea d, [bp + -9] ; $digits
0981   09C6 D7            push a
0982   09C7 DA            push d
0983   09C8                             
0984   09C8 FA F5 FF      lea d, [bp + -11] ; $i
0985   09CB 2A            mov b, [d]
0986   09CC 38 00 00      mov c, 0
0987   09CF E7            pop d
0988   09D0 5A            add d, b
0989   09D1 E4            pop a
0990   09D2 DA            push d
0991   09D3                             
0992   09D3 FD 2E 30 00   mov32 cb, $00000030
0992   09D7 00 00 
0993   09D9             ; --- START TERMS
0994   09D9 D7            push a
0995   09DA 11            mov a, b
0996   09DB                             
0997   09DB FA 05 00      lea d, [bp + 5] ; $num
0998   09DE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0999   09E1 FD 39         mov c, b ; And place it into C
1000   09E3 2A            mov b, [d] ; Lower Word in B
1001   09E4             ; --- START FACTORS
1002   09E4 D7            push a
1003   09E5 FD D8         push g
1004   09E7 11            mov a, b
1005   09E8 FD 7A         mov g, c
1006   09EA FD 2E 0A 00   mov32 cb, $0000000a
1006   09EE 00 00 
1007   09F0 FD D8         push g ; save 'g' as the div instruction uses it
1008   09F2 AE            div a, b ; %, a: quotient, b: remainder
1009   09F3 11            mov a, b
1010   09F4 FD F1         pop g
1011   09F6 FD 38         mov c, g
1012   09F8 27            mov b, a
1013   09F9 FD F1         pop g
1014   09FB E4            pop a
1015   09FC             ; --- END FACTORS
1016   09FC FD 15         add32 cb, ga
1017   09FE E4            pop a
1018   09FF             ; --- END TERMS
1019   09FF E7            pop d
1020   0A00 FD 3E         mov [d], bl
1021   0A02             ; num = num / 10; 
1022   0A02 FA 05 00      lea d, [bp + 5] ; $num
1023   0A05 DA            push d
1024   0A06                             
1025   0A06 FA 05 00      lea d, [bp + 5] ; $num
1026   0A09 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1027   0A0C FD 39         mov c, b ; And place it into C
1028   0A0E 2A            mov b, [d] ; Lower Word in B
1029   0A0F             ; --- START FACTORS
1030   0A0F D7            push a
1031   0A10 FD D8         push g
1032   0A12 11            mov a, b
1033   0A13 FD 7A         mov g, c
1034   0A15 FD 2E 0A 00   mov32 cb, $0000000a
1034   0A19 00 00 
1035   0A1B FD D8         push g ; save 'g' as the div instruction uses it
1036   0A1D AE            div a, b ; /, a: quotient, b: remainder
1037   0A1E FD F1         pop g
1038   0A20 FD 38         mov c, g
1039   0A22 27            mov b, a
1040   0A23 FD F1         pop g
1041   0A25 E4            pop a
1042   0A26             ; --- END FACTORS
1043   0A26 E7            pop d
1044   0A27 FD 43         mov [d], b
1045   0A29 28            mov b, c
1046   0A2A FD 44 02 00   mov [d + 2], b
1047   0A2E             ; i++; 
1048   0A2E                             
1049   0A2E FA F5 FF      lea d, [bp + -11] ; $i
1050   0A31 2A            mov b, [d]
1051   0A32 38 00 00      mov c, 0
1052   0A35 11            mov a, b
1053   0A36 FD 77         inc b
1054   0A38 FA F5 FF      lea d, [bp + -11] ; $i
1055   0A3B FD 43         mov [d], b
1056   0A3D 27            mov b, a
1057   0A3E 0A A1 09      jmp _while15_cond
1058   0A41             _while15_exit:
1059   0A41             ; while (i > 0) { 
1060   0A41             _while18_cond:
1061   0A41                             
1062   0A41 FA F5 FF      lea d, [bp + -11] ; $i
1063   0A44 2A            mov b, [d]
1064   0A45 38 00 00      mov c, 0
1065   0A48             ; --- START RELATIONAL
1066   0A48 D7            push a
1067   0A49 11            mov a, b
1068   0A4A FD 2E 00 00   mov32 cb, $00000000
1068   0A4E 00 00 
1069   0A50 B0            cmp a, b
1070   0A51 FD 7F         sgt ; >
1071   0A53 E4            pop a
1072   0A54             ; --- END RELATIONAL
1073   0A54 C0 00 00      cmp b, 0
1074   0A57 C6 89 0A      je _while18_exit
1075   0A5A             _while18_block:
1076   0A5A             ; i--; 
1077   0A5A                             
1078   0A5A FA F5 FF      lea d, [bp + -11] ; $i
1079   0A5D 2A            mov b, [d]
1080   0A5E 38 00 00      mov c, 0
1081   0A61 11            mov a, b
1082   0A62 FD 7D         dec b
1083   0A64 FA F5 FF      lea d, [bp + -11] ; $i
1084   0A67 FD 43         mov [d], b
1085   0A69 27            mov b, a
1086   0A6A             ; putchar(digits[i]); 
1087   0A6A                             
1088   0A6A             ; --- START FUNCTION CALL
1089   0A6A                             
1090   0A6A FA F7 FF      lea d, [bp + -9] ; $digits
1091   0A6D D7            push a
1092   0A6E DA            push d
1093   0A6F                             
1094   0A6F FA F5 FF      lea d, [bp + -11] ; $i
1095   0A72 2A            mov b, [d]
1096   0A73 38 00 00      mov c, 0
1097   0A76 E7            pop d
1098   0A77 5A            add d, b
1099   0A78 E4            pop a
1100   0A79 32            mov bl, [d]
1101   0A7A A7 00         mov bh, 0
1102   0A7C 38 00 00      mov c, 0
1103   0A7F DD            push bl
1104   0A80 07 49 09      call putchar
1105   0A83 51 01 00      add sp, 1
1106   0A86             ; --- END FUNCTION CALL
1107   0A86 0A 41 0A      jmp _while18_cond
1108   0A89             _while18_exit:
1109   0A89 F9            leave
1110   0A8A 09            ret
1111   0A8B             
1112   0A8B             printx32:
1113   0A8B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1114   0A8E             ; --- BEGIN INLINE ASM SEGMENT
1115   0A8E FA 05 00      lea d, [bp + 5] ; $hex
1116   0A91 2B 02 00      mov b, [d+2]
1117   0A94 07 9D 0A      call print_u16x_printx32
1118   0A97 2A            mov b, [d]
1119   0A98 07 9D 0A      call print_u16x_printx32
1120   0A9B             ; --- END INLINE ASM SEGMENT
1121   0A9B             ; return; 
1122   0A9B F9            leave
1123   0A9C 09            ret
1124   0A9D             ; --- BEGIN INLINE ASM SEGMENT
1125   0A9D             print_u16x_printx32:
1126   0A9D D7            push a
1127   0A9E D8            push b
1128   0A9F DD            push bl
1129   0AA0 30            mov bl, bh
1130   0AA1 07 BF 0A      call _itoa_printx32        ; convert bh to char in A
1131   0AA4 2F            mov bl, al        ; save al
1132   0AA5 19 00         mov al, 0
1133   0AA7 05 03         syscall sys_io        ; display AH
1134   0AA9 24            mov ah, bl        ; retrieve al
1135   0AAA 19 00         mov al, 0
1136   0AAC 05 03         syscall sys_io        ; display AL
1137   0AAE EA            pop bl
1138   0AAF 07 BF 0A      call _itoa_printx32        ; convert bh to char in A
1139   0AB2 2F            mov bl, al        ; save al
1140   0AB3 19 00         mov al, 0
1141   0AB5 05 03         syscall sys_io        ; display AH
1142   0AB7 24            mov ah, bl        ; retrieve al
1143   0AB8 19 00         mov al, 0
1144   0ABA 05 03         syscall sys_io        ; display AL
1145   0ABC E5            pop b
1146   0ABD E4            pop a
1147   0ABE 09            ret
1148   0ABF             _itoa_printx32:
1149   0ABF DA            push d
1150   0AC0 D8            push b
1151   0AC1 A7 00         mov bh, 0
1152   0AC3 FD A4 04      shr bl, 4  
1153   0AC6 74            mov d, b
1154   0AC7 1F D9 0A      mov al, [d + s_hex_digits_printx32]
1155   0ACA 23            mov ah, al
1156   0ACB E5            pop b
1157   0ACC D8            push b
1158   0ACD A7 00         mov bh, 0
1159   0ACF FD 87 0F      and bl, $0F
1160   0AD2 74            mov d, b
1161   0AD3 1F D9 0A      mov al, [d + s_hex_digits_printx32]
1162   0AD6 E5            pop b
1163   0AD7 E7            pop d
1164   0AD8 09            ret
1165   0AD9 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1165   0ADD 34 35 36 37 
1165   0AE1 38 39 41 42 
1165   0AE5 43 44 45 46 
1166   0AE9             ; --- END INLINE ASM SEGMENT
1167   0AE9 F9            leave
1168   0AEA 09            ret
1169   0AEB             
1170   0AEB             err:
1171   0AEB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1172   0AEE             ; print(e); 
1173   0AEE                             
1174   0AEE             ; --- START FUNCTION CALL
1175   0AEE                             
1176   0AEE FA 05 00      lea d, [bp + 5] ; $e
1177   0AF1 2A            mov b, [d]
1178   0AF2 38 00 00      mov c, 0
1179   0AF5 FD AB         swp b
1180   0AF7 D8            push b
1181   0AF8 07 00 0B      call print
1182   0AFB 51 02 00      add sp, 2
1183   0AFE             ; --- END FUNCTION CALL
1184   0AFE F9            leave
1185   0AFF 09            ret
1186   0B00             
1187   0B00             print:
1188   0B00 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1189   0B03             ; --- BEGIN INLINE ASM SEGMENT
1190   0B03 FA 05 00      lea d, [bp + 5] ; $s
1191   0B06 FD 2A         mov d, [d]
1192   0B08             _puts_L1_print:
1193   0B08 1E            mov al, [d]
1194   0B09 B9 00         cmp al, 0
1195   0B0B C6 17 0B      jz _puts_END_print
1196   0B0E 23            mov ah, al
1197   0B0F 19 00         mov al, 0
1198   0B11 05 03         syscall sys_io
1199   0B13 79            inc d
1200   0B14 0A 08 0B      jmp _puts_L1_print
1201   0B17             _puts_END_print:
1202   0B17             ; --- END INLINE ASM SEGMENT
1203   0B17 F9            leave
1204   0B18 09            ret
1205   0B19             
1206   0B19             print_signed:
1207   0B19 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1208   0B1C             ; char digits[5]; 
1209   0B1C 52 05 00      sub sp, 5
1210   0B1F             ; int i = 0; 
1211   0B1F 52 02 00      sub sp, 2
1212   0B22             ; --- START LOCAL VAR INITIALIZATION
1213   0B22 FA FA FF      lea d, [bp + -6] ; $i
1214   0B25 DA            push d
1215   0B26                             
1216   0B26 FD 2E 00 00   mov32 cb, $00000000
1216   0B2A 00 00 
1217   0B2C E7            pop d
1218   0B2D FD 43         mov [d], b
1219   0B2F             ; --- END LOCAL VAR INITIALIZATION
1220   0B2F             ; if (num < 0) { 
1221   0B2F             _if19_cond:
1222   0B2F                             
1223   0B2F FA 05 00      lea d, [bp + 5] ; $num
1224   0B32 2A            mov b, [d]
1225   0B33 38 00 00      mov c, 0
1226   0B36             ; --- START RELATIONAL
1227   0B36 D7            push a
1228   0B37 11            mov a, b
1229   0B38 FD 2E 00 00   mov32 cb, $00000000
1229   0B3C 00 00 
1230   0B3E B0            cmp a, b
1231   0B3F FD 73         slt ; < (signed)
1232   0B41 E4            pop a
1233   0B42             ; --- END RELATIONAL
1234   0B42 C0 00 00      cmp b, 0
1235   0B45 C6 68 0B      je _if19_else
1236   0B48             _if19_TRUE:
1237   0B48             ; putchar('-'); 
1238   0B48                             
1239   0B48             ; --- START FUNCTION CALL
1240   0B48                             
1241   0B48 FD 2E 2D 00   mov32 cb, $0000002d
1241   0B4C 00 00 
1242   0B4E DD            push bl
1243   0B4F 07 49 09      call putchar
1244   0B52 51 01 00      add sp, 1
1245   0B55             ; --- END FUNCTION CALL
1246   0B55             ; num = -num; 
1247   0B55 FA 05 00      lea d, [bp + 5] ; $num
1248   0B58 DA            push d
1249   0B59                             
1250   0B59 FA 05 00      lea d, [bp + 5] ; $num
1251   0B5C 2A            mov b, [d]
1252   0B5D 38 00 00      mov c, 0
1253   0B60 FD 97         neg b
1254   0B62 E7            pop d
1255   0B63 FD 43         mov [d], b
1256   0B65 0A 93 0B      jmp _if19_exit
1257   0B68             _if19_else:
1258   0B68             ; if (num == 0) { 
1259   0B68             _if20_cond:
1260   0B68                             
1261   0B68 FA 05 00      lea d, [bp + 5] ; $num
1262   0B6B 2A            mov b, [d]
1263   0B6C 38 00 00      mov c, 0
1264   0B6F             ; --- START RELATIONAL
1265   0B6F D7            push a
1266   0B70 11            mov a, b
1267   0B71 FD 2E 00 00   mov32 cb, $00000000
1267   0B75 00 00 
1268   0B77 B0            cmp a, b
1269   0B78 FD 71         seq ; ==
1270   0B7A E4            pop a
1271   0B7B             ; --- END RELATIONAL
1272   0B7B C0 00 00      cmp b, 0
1273   0B7E C6 93 0B      je _if20_exit
1274   0B81             _if20_TRUE:
1275   0B81             ; putchar('0'); 
1276   0B81                             
1277   0B81             ; --- START FUNCTION CALL
1278   0B81                             
1279   0B81 FD 2E 30 00   mov32 cb, $00000030
1279   0B85 00 00 
1280   0B87 DD            push bl
1281   0B88 07 49 09      call putchar
1282   0B8B 51 01 00      add sp, 1
1283   0B8E             ; --- END FUNCTION CALL
1284   0B8E             ; return; 
1285   0B8E F9            leave
1286   0B8F 09            ret
1287   0B90 0A 93 0B      jmp _if20_exit
1288   0B93             _if20_exit:
1289   0B93             _if19_exit:
1290   0B93             ; while (num > 0) { 
1291   0B93             _while21_cond:
1292   0B93                             
1293   0B93 FA 05 00      lea d, [bp + 5] ; $num
1294   0B96 2A            mov b, [d]
1295   0B97 38 00 00      mov c, 0
1296   0B9A             ; --- START RELATIONAL
1297   0B9A D7            push a
1298   0B9B 11            mov a, b
1299   0B9C FD 2E 00 00   mov32 cb, $00000000
1299   0BA0 00 00 
1300   0BA2 B0            cmp a, b
1301   0BA3 FD 7F         sgt ; >
1302   0BA5 E4            pop a
1303   0BA6             ; --- END RELATIONAL
1304   0BA6 C0 00 00      cmp b, 0
1305   0BA9 C6 20 0C      je _while21_exit
1306   0BAC             _while21_block:
1307   0BAC             ; digits[i] = '0' + (num % 10); 
1308   0BAC FA FC FF      lea d, [bp + -4] ; $digits
1309   0BAF D7            push a
1310   0BB0 DA            push d
1311   0BB1                             
1312   0BB1 FA FA FF      lea d, [bp + -6] ; $i
1313   0BB4 2A            mov b, [d]
1314   0BB5 38 00 00      mov c, 0
1315   0BB8 E7            pop d
1316   0BB9 5A            add d, b
1317   0BBA E4            pop a
1318   0BBB DA            push d
1319   0BBC                             
1320   0BBC FD 2E 30 00   mov32 cb, $00000030
1320   0BC0 00 00 
1321   0BC2             ; --- START TERMS
1322   0BC2 D7            push a
1323   0BC3 11            mov a, b
1324   0BC4                             
1325   0BC4 FA 05 00      lea d, [bp + 5] ; $num
1326   0BC7 2A            mov b, [d]
1327   0BC8 38 00 00      mov c, 0
1328   0BCB             ; --- START FACTORS
1329   0BCB D7            push a
1330   0BCC FD D8         push g
1331   0BCE 11            mov a, b
1332   0BCF FD 7A         mov g, c
1333   0BD1 FD 2E 0A 00   mov32 cb, $0000000a
1333   0BD5 00 00 
1334   0BD7 FD D8         push g ; save 'g' as the div instruction uses it
1335   0BD9 AE            div a, b ; %, a: quotient, b: remainder
1336   0BDA 11            mov a, b
1337   0BDB FD F1         pop g
1338   0BDD FD 38         mov c, g
1339   0BDF 27            mov b, a
1340   0BE0 FD F1         pop g
1341   0BE2 E4            pop a
1342   0BE3             ; --- END FACTORS
1343   0BE3 56            add b, a
1344   0BE4 E4            pop a
1345   0BE5             ; --- END TERMS
1346   0BE5 E7            pop d
1347   0BE6 FD 3E         mov [d], bl
1348   0BE8             ; num = num / 10; 
1349   0BE8 FA 05 00      lea d, [bp + 5] ; $num
1350   0BEB DA            push d
1351   0BEC                             
1352   0BEC FA 05 00      lea d, [bp + 5] ; $num
1353   0BEF 2A            mov b, [d]
1354   0BF0 38 00 00      mov c, 0
1355   0BF3             ; --- START FACTORS
1356   0BF3 D7            push a
1357   0BF4 FD D8         push g
1358   0BF6 11            mov a, b
1359   0BF7 FD 7A         mov g, c
1360   0BF9 FD 2E 0A 00   mov32 cb, $0000000a
1360   0BFD 00 00 
1361   0BFF FD D8         push g ; save 'g' as the div instruction uses it
1362   0C01 AE            div a, b ; /, a: quotient, b: remainder
1363   0C02 FD F1         pop g
1364   0C04 FD 38         mov c, g
1365   0C06 27            mov b, a
1366   0C07 FD F1         pop g
1367   0C09 E4            pop a
1368   0C0A             ; --- END FACTORS
1369   0C0A E7            pop d
1370   0C0B FD 43         mov [d], b
1371   0C0D             ; i++; 
1372   0C0D                             
1373   0C0D FA FA FF      lea d, [bp + -6] ; $i
1374   0C10 2A            mov b, [d]
1375   0C11 38 00 00      mov c, 0
1376   0C14 11            mov a, b
1377   0C15 FD 77         inc b
1378   0C17 FA FA FF      lea d, [bp + -6] ; $i
1379   0C1A FD 43         mov [d], b
1380   0C1C 27            mov b, a
1381   0C1D 0A 93 0B      jmp _while21_cond
1382   0C20             _while21_exit:
1383   0C20             ; while (i > 0) { 
1384   0C20             _while24_cond:
1385   0C20                             
1386   0C20 FA FA FF      lea d, [bp + -6] ; $i
1387   0C23 2A            mov b, [d]
1388   0C24 38 00 00      mov c, 0
1389   0C27             ; --- START RELATIONAL
1390   0C27 D7            push a
1391   0C28 11            mov a, b
1392   0C29 FD 2E 00 00   mov32 cb, $00000000
1392   0C2D 00 00 
1393   0C2F B0            cmp a, b
1394   0C30 FD 7F         sgt ; >
1395   0C32 E4            pop a
1396   0C33             ; --- END RELATIONAL
1397   0C33 C0 00 00      cmp b, 0
1398   0C36 C6 68 0C      je _while24_exit
1399   0C39             _while24_block:
1400   0C39             ; i--; 
1401   0C39                             
1402   0C39 FA FA FF      lea d, [bp + -6] ; $i
1403   0C3C 2A            mov b, [d]
1404   0C3D 38 00 00      mov c, 0
1405   0C40 11            mov a, b
1406   0C41 FD 7D         dec b
1407   0C43 FA FA FF      lea d, [bp + -6] ; $i
1408   0C46 FD 43         mov [d], b
1409   0C48 27            mov b, a
1410   0C49             ; putchar(digits[i]); 
1411   0C49                             
1412   0C49             ; --- START FUNCTION CALL
1413   0C49                             
1414   0C49 FA FC FF      lea d, [bp + -4] ; $digits
1415   0C4C D7            push a
1416   0C4D DA            push d
1417   0C4E                             
1418   0C4E FA FA FF      lea d, [bp + -6] ; $i
1419   0C51 2A            mov b, [d]
1420   0C52 38 00 00      mov c, 0
1421   0C55 E7            pop d
1422   0C56 5A            add d, b
1423   0C57 E4            pop a
1424   0C58 32            mov bl, [d]
1425   0C59 A7 00         mov bh, 0
1426   0C5B 38 00 00      mov c, 0
1427   0C5E DD            push bl
1428   0C5F 07 49 09      call putchar
1429   0C62 51 01 00      add sp, 1
1430   0C65             ; --- END FUNCTION CALL
1431   0C65 0A 20 0C      jmp _while24_cond
1432   0C68             _while24_exit:
1433   0C68 F9            leave
1434   0C69 09            ret
1435   0C6A             
1436   0C6A             print_unsigned:
1437   0C6A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1438   0C6D             ; char digits[5]; 
1439   0C6D 52 05 00      sub sp, 5
1440   0C70             ; int i; 
1441   0C70 52 02 00      sub sp, 2
1442   0C73             ; i = 0; 
1443   0C73 FA FA FF      lea d, [bp + -6] ; $i
1444   0C76 DA            push d
1445   0C77                             
1446   0C77 FD 2E 00 00   mov32 cb, $00000000
1446   0C7B 00 00 
1447   0C7D E7            pop d
1448   0C7E FD 43         mov [d], b
1449   0C80             ; if(num == 0){ 
1450   0C80             _if25_cond:
1451   0C80                             
1452   0C80 FA 05 00      lea d, [bp + 5] ; $num
1453   0C83 2A            mov b, [d]
1454   0C84 38 00 00      mov c, 0
1455   0C87             ; --- START RELATIONAL
1456   0C87 D7            push a
1457   0C88 11            mov a, b
1458   0C89 FD 2E 00 00   mov32 cb, $00000000
1458   0C8D 00 00 
1459   0C8F B0            cmp a, b
1460   0C90 FD 71         seq ; ==
1461   0C92 E4            pop a
1462   0C93             ; --- END RELATIONAL
1463   0C93 C0 00 00      cmp b, 0
1464   0C96 C6 AB 0C      je _if25_exit
1465   0C99             _if25_TRUE:
1466   0C99             ; putchar('0'); 
1467   0C99                             
1468   0C99             ; --- START FUNCTION CALL
1469   0C99                             
1470   0C99 FD 2E 30 00   mov32 cb, $00000030
1470   0C9D 00 00 
1471   0C9F DD            push bl
1472   0CA0 07 49 09      call putchar
1473   0CA3 51 01 00      add sp, 1
1474   0CA6             ; --- END FUNCTION CALL
1475   0CA6             ; return; 
1476   0CA6 F9            leave
1477   0CA7 09            ret
1478   0CA8 0A AB 0C      jmp _if25_exit
1479   0CAB             _if25_exit:
1480   0CAB             ; while (num > 0) { 
1481   0CAB             _while26_cond:
1482   0CAB                             
1483   0CAB FA 05 00      lea d, [bp + 5] ; $num
1484   0CAE 2A            mov b, [d]
1485   0CAF 38 00 00      mov c, 0
1486   0CB2             ; --- START RELATIONAL
1487   0CB2 D7            push a
1488   0CB3 11            mov a, b
1489   0CB4 FD 2E 00 00   mov32 cb, $00000000
1489   0CB8 00 00 
1490   0CBA B0            cmp a, b
1491   0CBB FD 81         sgu ; > (unsigned)
1492   0CBD E4            pop a
1493   0CBE             ; --- END RELATIONAL
1494   0CBE C0 00 00      cmp b, 0
1495   0CC1 C6 38 0D      je _while26_exit
1496   0CC4             _while26_block:
1497   0CC4             ; digits[i] = '0' + (num % 10); 
1498   0CC4 FA FC FF      lea d, [bp + -4] ; $digits
1499   0CC7 D7            push a
1500   0CC8 DA            push d
1501   0CC9                             
1502   0CC9 FA FA FF      lea d, [bp + -6] ; $i
1503   0CCC 2A            mov b, [d]
1504   0CCD 38 00 00      mov c, 0
1505   0CD0 E7            pop d
1506   0CD1 5A            add d, b
1507   0CD2 E4            pop a
1508   0CD3 DA            push d
1509   0CD4                             
1510   0CD4 FD 2E 30 00   mov32 cb, $00000030
1510   0CD8 00 00 
1511   0CDA             ; --- START TERMS
1512   0CDA D7            push a
1513   0CDB 11            mov a, b
1514   0CDC                             
1515   0CDC FA 05 00      lea d, [bp + 5] ; $num
1516   0CDF 2A            mov b, [d]
1517   0CE0 38 00 00      mov c, 0
1518   0CE3             ; --- START FACTORS
1519   0CE3 D7            push a
1520   0CE4 FD D8         push g
1521   0CE6 11            mov a, b
1522   0CE7 FD 7A         mov g, c
1523   0CE9 FD 2E 0A 00   mov32 cb, $0000000a
1523   0CED 00 00 
1524   0CEF FD D8         push g ; save 'g' as the div instruction uses it
1525   0CF1 AE            div a, b ; %, a: quotient, b: remainder
1526   0CF2 11            mov a, b
1527   0CF3 FD F1         pop g
1528   0CF5 FD 38         mov c, g
1529   0CF7 27            mov b, a
1530   0CF8 FD F1         pop g
1531   0CFA E4            pop a
1532   0CFB             ; --- END FACTORS
1533   0CFB 56            add b, a
1534   0CFC E4            pop a
1535   0CFD             ; --- END TERMS
1536   0CFD E7            pop d
1537   0CFE FD 3E         mov [d], bl
1538   0D00             ; num = num / 10; 
1539   0D00 FA 05 00      lea d, [bp + 5] ; $num
1540   0D03 DA            push d
1541   0D04                             
1542   0D04 FA 05 00      lea d, [bp + 5] ; $num
1543   0D07 2A            mov b, [d]
1544   0D08 38 00 00      mov c, 0
1545   0D0B             ; --- START FACTORS
1546   0D0B D7            push a
1547   0D0C FD D8         push g
1548   0D0E 11            mov a, b
1549   0D0F FD 7A         mov g, c
1550   0D11 FD 2E 0A 00   mov32 cb, $0000000a
1550   0D15 00 00 
1551   0D17 FD D8         push g ; save 'g' as the div instruction uses it
1552   0D19 AE            div a, b ; /, a: quotient, b: remainder
1553   0D1A FD F1         pop g
1554   0D1C FD 38         mov c, g
1555   0D1E 27            mov b, a
1556   0D1F FD F1         pop g
1557   0D21 E4            pop a
1558   0D22             ; --- END FACTORS
1559   0D22 E7            pop d
1560   0D23 FD 43         mov [d], b
1561   0D25             ; i++; 
1562   0D25                             
1563   0D25 FA FA FF      lea d, [bp + -6] ; $i
1564   0D28 2A            mov b, [d]
1565   0D29 38 00 00      mov c, 0
1566   0D2C 11            mov a, b
1567   0D2D FD 77         inc b
1568   0D2F FA FA FF      lea d, [bp + -6] ; $i
1569   0D32 FD 43         mov [d], b
1570   0D34 27            mov b, a
1571   0D35 0A AB 0C      jmp _while26_cond
1572   0D38             _while26_exit:
1573   0D38             ; while (i > 0) { 
1574   0D38             _while29_cond:
1575   0D38                             
1576   0D38 FA FA FF      lea d, [bp + -6] ; $i
1577   0D3B 2A            mov b, [d]
1578   0D3C 38 00 00      mov c, 0
1579   0D3F             ; --- START RELATIONAL
1580   0D3F D7            push a
1581   0D40 11            mov a, b
1582   0D41 FD 2E 00 00   mov32 cb, $00000000
1582   0D45 00 00 
1583   0D47 B0            cmp a, b
1584   0D48 FD 7F         sgt ; >
1585   0D4A E4            pop a
1586   0D4B             ; --- END RELATIONAL
1587   0D4B C0 00 00      cmp b, 0
1588   0D4E C6 80 0D      je _while29_exit
1589   0D51             _while29_block:
1590   0D51             ; i--; 
1591   0D51                             
1592   0D51 FA FA FF      lea d, [bp + -6] ; $i
1593   0D54 2A            mov b, [d]
1594   0D55 38 00 00      mov c, 0
1595   0D58 11            mov a, b
1596   0D59 FD 7D         dec b
1597   0D5B FA FA FF      lea d, [bp + -6] ; $i
1598   0D5E FD 43         mov [d], b
1599   0D60 27            mov b, a
1600   0D61             ; putchar(digits[i]); 
1601   0D61                             
1602   0D61             ; --- START FUNCTION CALL
1603   0D61                             
1604   0D61 FA FC FF      lea d, [bp + -4] ; $digits
1605   0D64 D7            push a
1606   0D65 DA            push d
1607   0D66                             
1608   0D66 FA FA FF      lea d, [bp + -6] ; $i
1609   0D69 2A            mov b, [d]
1610   0D6A 38 00 00      mov c, 0
1611   0D6D E7            pop d
1612   0D6E 5A            add d, b
1613   0D6F E4            pop a
1614   0D70 32            mov bl, [d]
1615   0D71 A7 00         mov bh, 0
1616   0D73 38 00 00      mov c, 0
1617   0D76 DD            push bl
1618   0D77 07 49 09      call putchar
1619   0D7A 51 01 00      add sp, 1
1620   0D7D             ; --- END FUNCTION CALL
1621   0D7D 0A 38 0D      jmp _while29_cond
1622   0D80             _while29_exit:
1623   0D80 F9            leave
1624   0D81 09            ret
1625   0D82             
1626   0D82             printx16:
1627   0D82 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1628   0D85             ; --- BEGIN INLINE ASM SEGMENT
1629   0D85 FA 05 00      lea d, [bp + 5] ; $hex
1630   0D88 2A            mov b, [d]
1631   0D89             print_u16x_printx16:
1632   0D89 DD            push bl
1633   0D8A 30            mov bl, bh
1634   0D8B 07 A8 0D      call _itoa_printx16        ; convert bh to char in A
1635   0D8E 2F            mov bl, al        ; save al
1636   0D8F 19 00         mov al, 0
1637   0D91 05 03         syscall sys_io        ; display AH
1638   0D93 24            mov ah, bl        ; retrieve al
1639   0D94 19 00         mov al, 0
1640   0D96 05 03         syscall sys_io        ; display AL
1641   0D98 EA            pop bl
1642   0D99 07 A8 0D      call _itoa_printx16        ; convert bh to char in A
1643   0D9C 2F            mov bl, al        ; save al
1644   0D9D 19 00         mov al, 0
1645   0D9F 05 03         syscall sys_io        ; display AH
1646   0DA1 24            mov ah, bl        ; retrieve al
1647   0DA2 19 00         mov al, 0
1648   0DA4 05 03         syscall sys_io        ; display AL
1649   0DA6             ; --- END INLINE ASM SEGMENT
1650   0DA6             ; return; 
1651   0DA6 F9            leave
1652   0DA7 09            ret
1653   0DA8             ; --- BEGIN INLINE ASM SEGMENT
1654   0DA8             _itoa_printx16:
1655   0DA8 DA            push d
1656   0DA9 D8            push b
1657   0DAA A7 00         mov bh, 0
1658   0DAC FD A4 04      shr bl, 4  
1659   0DAF 74            mov d, b
1660   0DB0 1F C2 0D      mov al, [d + s_hex_digits_printx16]
1661   0DB3 23            mov ah, al
1662   0DB4 E5            pop b
1663   0DB5 D8            push b
1664   0DB6 A7 00         mov bh, 0
1665   0DB8 FD 87 0F      and bl, $0F
1666   0DBB 74            mov d, b
1667   0DBC 1F C2 0D      mov al, [d + s_hex_digits_printx16]
1668   0DBF E5            pop b
1669   0DC0 E7            pop d
1670   0DC1 09            ret
1671   0DC2 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1671   0DC6 34 35 36 37 
1671   0DCA 38 39 41 42 
1671   0DCE 43 44 45 46 
1672   0DD2             ; --- END INLINE ASM SEGMENT
1673   0DD2 F9            leave
1674   0DD3 09            ret
1675   0DD4             ; --- END TEXT SEGMENT
1676   0DD4             
1677   0DD4             ; --- BEGIN DATA SEGMENT
1678   0DD4             _my_struct_data:
1679   0DD4 61          .db $61,
1680   0DD5 7B 00 06 0E .dw $007b,_s0, 
1681   0DD9 62          .db $62,
1682   0DDA C8 01 0C 0E .dw $01c8,_s1, 
1683   0DDE 00 00 00 00 .fill 40, 0
1683   0DE2 00 00 00 00 
1683   0DE6 00 00 00 00 
1683   0DEA 00 00 00 00 
1683   0DEE 00 00 00 00 
1683   0DF2 00 00 00 00 
1683   0DF6 00 00 00 00 
1683   0DFA 00 00 00 00 
1683   0DFE 00 00 00 00 
1683   0E02 00 00 00 00 
1684   0E06 68 65 6C 6C _s0: .db "hello", 0
1684   0E0A 6F 00 
1685   0E0C 77 6F 72 6C _s1: .db "world", 0
1685   0E10 64 00 
1686   0E12 25 63 20 25 _s2: .db "%c %d %s\n", 0
1686   0E16 64 20 25 73 
1686   0E1A 0A 00 
1687   0E1C 55 6E 65 78 _s3: .db "Unexpected format in printf.", 0
1687   0E20 70 65 63 74 
1687   0E24 65 64 20 66 
1687   0E28 6F 72 6D 61 
1687   0E2C 74 20 69 6E 
1687   0E30 20 70 72 69 
1687   0E34 6E 74 66 2E 
1687   0E38 00 
1688   0E39 45 72 72 6F _s4: .db "Error: Unknown argument type.\n", 0
1688   0E3D 72 3A 20 55 
1688   0E41 6E 6B 6E 6F 
1688   0E45 77 6E 20 61 
1688   0E49 72 67 75 6D 
1688   0E4D 65 6E 74 20 
1688   0E51 74 79 70 65 
1688   0E55 2E 0A 00 
1689   0E58             
1690   0E58 5A 0E       _heap_top: .dw _heap
1691   0E5A 00          _heap: .db 0
1692   0E5B             ; --- END DATA SEGMENT
1693   0E5B             
1694   0E5B             .end
tasm: Number of errors = 0
