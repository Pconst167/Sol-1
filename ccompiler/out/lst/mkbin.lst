0001   0000             ; --- FILENAME: ../solarium/usr/bin/mkbin.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; char *s; 
0011   0408 52 02 00      sub sp, 2
0012   040B             ; prog = 0x0000; // Beginning of arguments buffer 
0013   040B 3B DD 0F      mov d, _prog ; $prog
0014   040E DA            push d
0015   040F FD 2E 00 00   mov32 cb, $00000000
0015   0413 00 00 
0016   0415 E7            pop d
0017   0416 FD 43         mov [d], b
0018   0418             ; s = arg; 
0019   0418 FA FF FF      lea d, [bp + -1] ; $s
0020   041B DA            push d
0021   041C 3B D9 0D      mov d, _arg_data ; $arg
0022   041F 2D            mov b, d
0023   0420 38 00 00      mov c, 0
0024   0423 E7            pop d
0025   0424 FD 43         mov [d], b
0026   0426             ; for(;;){ 
0027   0426             _for1_init:
0028   0426             _for1_cond:
0029   0426             _for1_block:
0030   0426             ; if(*prog == '\0' || *prog == ';' || *prog == ' '){ 
0031   0426             _if2_cond:
0032   0426 3B DD 0F      mov d, _prog ; $prog
0033   0429 2A            mov b, [d]
0034   042A 38 00 00      mov c, 0
0035   042D 74            mov d, b
0036   042E 32            mov bl, [d]
0037   042F A7 00         mov bh, 0
0038   0431 38 00 00      mov c, 0
0039   0434             ; --- START RELATIONAL
0040   0434 D7            push a
0041   0435 11            mov a, b
0042   0436 FD 2E 00 00   mov32 cb, $00000000
0042   043A 00 00 
0043   043C B0            cmp a, b
0044   043D FD 71         seq ; ==
0045   043F E4            pop a
0046   0440             ; --- END RELATIONAL
0047   0440             ; --- START LOGICAL OR
0048   0440 D7            push a
0049   0441 11            mov a, b
0050   0442 3B DD 0F      mov d, _prog ; $prog
0051   0445 2A            mov b, [d]
0052   0446 38 00 00      mov c, 0
0053   0449 74            mov d, b
0054   044A 32            mov bl, [d]
0055   044B A7 00         mov bh, 0
0056   044D 38 00 00      mov c, 0
0057   0450             ; --- START RELATIONAL
0058   0450 D7            push a
0059   0451 11            mov a, b
0060   0452 FD 2E 3B 00   mov32 cb, $0000003b
0060   0456 00 00 
0061   0458 B0            cmp a, b
0062   0459 FD 71         seq ; ==
0063   045B E4            pop a
0064   045C             ; --- END RELATIONAL
0065   045C FD A8         sor a, b ; ||
0066   045E 11            mov a, b
0067   045F 3B DD 0F      mov d, _prog ; $prog
0068   0462 2A            mov b, [d]
0069   0463 38 00 00      mov c, 0
0070   0466 74            mov d, b
0071   0467 32            mov bl, [d]
0072   0468 A7 00         mov bh, 0
0073   046A 38 00 00      mov c, 0
0074   046D             ; --- START RELATIONAL
0075   046D D7            push a
0076   046E 11            mov a, b
0077   046F FD 2E 20 00   mov32 cb, $00000020
0077   0473 00 00 
0078   0475 B0            cmp a, b
0079   0476 FD 71         seq ; ==
0080   0478 E4            pop a
0081   0479             ; --- END RELATIONAL
0082   0479 FD A8         sor a, b ; ||
0083   047B E4            pop a
0084   047C             ; --- END LOGICAL OR
0085   047C C0 00 00      cmp b, 0
0086   047F C6 99 04      je _if2_else
0087   0482             _if2_TRUE:
0088   0482             ; *s = '\0'; 
0089   0482 FA FF FF      lea d, [bp + -1] ; $s
0090   0485 2A            mov b, [d]
0091   0486 38 00 00      mov c, 0
0092   0489 D8            push b
0093   048A FD 2E 00 00   mov32 cb, $00000000
0093   048E 00 00 
0094   0490 E7            pop d
0095   0491 FD 3E         mov [d], bl
0096   0493             ; break; 
0097   0493 0A C7 04      jmp _for1_exit ; for break
0098   0496 0A C4 04      jmp _if2_exit
0099   0499             _if2_else:
0100   0499             ; *s++ = *prog++; 
0101   0499 FA FF FF      lea d, [bp + -1] ; $s
0102   049C 2A            mov b, [d]
0103   049D 38 00 00      mov c, 0
0104   04A0 FD 77         inc b
0105   04A2 FA FF FF      lea d, [bp + -1] ; $s
0106   04A5 FD 43         mov [d], b
0107   04A7 FD 7D         dec b
0108   04A9 D8            push b
0109   04AA 3B DD 0F      mov d, _prog ; $prog
0110   04AD 2A            mov b, [d]
0111   04AE 38 00 00      mov c, 0
0112   04B1 FD 77         inc b
0113   04B3 3B DD 0F      mov d, _prog ; $prog
0114   04B6 FD 43         mov [d], b
0115   04B8 FD 7D         dec b
0116   04BA 74            mov d, b
0117   04BB 32            mov bl, [d]
0118   04BC A7 00         mov bh, 0
0119   04BE 38 00 00      mov c, 0
0120   04C1 E7            pop d
0121   04C2 FD 3E         mov [d], bl
0122   04C4             _if2_exit:
0123   04C4             _for1_update:
0124   04C4 0A 26 04      jmp _for1_cond
0125   04C7             _for1_exit:
0126   04C7             ; printf("> "); 
0127   04C7             ; --- START FUNCTION CALL
0128   04C7 26 DF 11      mov b, _s0 ; "> "
0129   04CA FD AB         swp b
0130   04CC D8            push b
0131   04CD 07 DC 04      call printf
0132   04D0 51 02 00      add sp, 2
0133   04D3             ; --- END FUNCTION CALL
0134   04D3             ; --- BEGIN INLINE ASM SEGMENT
0135   04D3 3B D9 0D      mov d, _arg_data ; $arg
0136   04D6 19 06         mov al, 6
0137   04D8 05 04         syscall sys_filesystem
0138   04DA             ; --- END INLINE ASM SEGMENT
0139   04DA 05 0B         syscall sys_terminate_proc
0140   04DC             
0141   04DC             printf:
0142   04DC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0143   04DF             ; char *p, *format_p; 
0144   04DF 52 02 00      sub sp, 2
0145   04E2 52 02 00      sub sp, 2
0146   04E5             ; format_p = format; 
0147   04E5 FA FD FF      lea d, [bp + -3] ; $format_p
0148   04E8 DA            push d
0149   04E9 FA 05 00      lea d, [bp + 5] ; $format
0150   04EC 2A            mov b, [d]
0151   04ED 38 00 00      mov c, 0
0152   04F0 E7            pop d
0153   04F1 FD 43         mov [d], b
0154   04F3             ; p = &format + 2; 
0155   04F3 FA FF FF      lea d, [bp + -1] ; $p
0156   04F6 DA            push d
0157   04F7 FA 05 00      lea d, [bp + 5] ; $format
0158   04FA 2D            mov b, d
0159   04FB             ; --- START TERMS
0160   04FB D7            push a
0161   04FC 11            mov a, b
0162   04FD FD 2E 02 00   mov32 cb, $00000002
0162   0501 00 00 
0163   0503 56            add b, a
0164   0504 E4            pop a
0165   0505             ; --- END TERMS
0166   0505 E7            pop d
0167   0506 FD 43         mov [d], b
0168   0508             ; for(;;){ 
0169   0508             _for3_init:
0170   0508             _for3_cond:
0171   0508             _for3_block:
0172   0508             ; if(!*format_p) break; 
0173   0508             _if4_cond:
0174   0508 FA FD FF      lea d, [bp + -3] ; $format_p
0175   050B 2A            mov b, [d]
0176   050C 38 00 00      mov c, 0
0177   050F 74            mov d, b
0178   0510 32            mov bl, [d]
0179   0511 A7 00         mov bh, 0
0180   0513 38 00 00      mov c, 0
0181   0516 C0 00 00      cmp b, 0
0182   0519 FD 71         seq ; !
0183   051B C0 00 00      cmp b, 0
0184   051E C6 27 05      je _if4_else
0185   0521             _if4_TRUE:
0186   0521             ; break; 
0187   0521 0A C7 07      jmp _for3_exit ; for break
0188   0524 0A B4 07      jmp _if4_exit
0189   0527             _if4_else:
0190   0527             ; if(*format_p == '%'){ 
0191   0527             _if5_cond:
0192   0527 FA FD FF      lea d, [bp + -3] ; $format_p
0193   052A 2A            mov b, [d]
0194   052B 38 00 00      mov c, 0
0195   052E 74            mov d, b
0196   052F 32            mov bl, [d]
0197   0530 A7 00         mov bh, 0
0198   0532 38 00 00      mov c, 0
0199   0535             ; --- START RELATIONAL
0200   0535 D7            push a
0201   0536 11            mov a, b
0202   0537 FD 2E 25 00   mov32 cb, $00000025
0202   053B 00 00 
0203   053D B0            cmp a, b
0204   053E FD 71         seq ; ==
0205   0540 E4            pop a
0206   0541             ; --- END RELATIONAL
0207   0541 C0 00 00      cmp b, 0
0208   0544 C6 9F 07      je _if5_else
0209   0547             _if5_TRUE:
0210   0547             ; format_p++; 
0211   0547 FA FD FF      lea d, [bp + -3] ; $format_p
0212   054A 2A            mov b, [d]
0213   054B 38 00 00      mov c, 0
0214   054E FD 77         inc b
0215   0550 FA FD FF      lea d, [bp + -3] ; $format_p
0216   0553 FD 43         mov [d], b
0217   0555 FD 7D         dec b
0218   0557             ; switch(*format_p){ 
0219   0557             _switch6_expr:
0220   0557 FA FD FF      lea d, [bp + -3] ; $format_p
0221   055A 2A            mov b, [d]
0222   055B 38 00 00      mov c, 0
0223   055E 74            mov d, b
0224   055F 32            mov bl, [d]
0225   0560 A7 00         mov bh, 0
0226   0562 38 00 00      mov c, 0
0227   0565             _switch6_comparisons:
0228   0565 C1 6C         cmp bl, $6c
0229   0567 C6 93 05      je _switch6_case0
0230   056A C1 4C         cmp bl, $4c
0231   056C C6 93 05      je _switch6_case1
0232   056F C1 64         cmp bl, $64
0233   0571 C6 A3 06      je _switch6_case2
0234   0574 C1 69         cmp bl, $69
0235   0576 C6 A3 06      je _switch6_case3
0236   0579 C1 75         cmp bl, $75
0237   057B C6 D3 06      je _switch6_case4
0238   057E C1 78         cmp bl, $78
0239   0580 C6 03 07      je _switch6_case5
0240   0583 C1 63         cmp bl, $63
0241   0585 C6 33 07      je _switch6_case6
0242   0588 C1 73         cmp bl, $73
0243   058A C6 63 07      je _switch6_case7
0244   058D 0A 90 07      jmp _switch6_default
0245   0590 0A 9C 07      jmp _switch6_exit
0246   0593             _switch6_case0:
0247   0593             _switch6_case1:
0248   0593             ; format_p++; 
0249   0593 FA FD FF      lea d, [bp + -3] ; $format_p
0250   0596 2A            mov b, [d]
0251   0597 38 00 00      mov c, 0
0252   059A FD 77         inc b
0253   059C FA FD FF      lea d, [bp + -3] ; $format_p
0254   059F FD 43         mov [d], b
0255   05A1 FD 7D         dec b
0256   05A3             ; if(*format_p == 'd' || *format_p == 'i') 
0257   05A3             _if7_cond:
0258   05A3 FA FD FF      lea d, [bp + -3] ; $format_p
0259   05A6 2A            mov b, [d]
0260   05A7 38 00 00      mov c, 0
0261   05AA 74            mov d, b
0262   05AB 32            mov bl, [d]
0263   05AC A7 00         mov bh, 0
0264   05AE 38 00 00      mov c, 0
0265   05B1             ; --- START RELATIONAL
0266   05B1 D7            push a
0267   05B2 11            mov a, b
0268   05B3 FD 2E 64 00   mov32 cb, $00000064
0268   05B7 00 00 
0269   05B9 B0            cmp a, b
0270   05BA FD 71         seq ; ==
0271   05BC E4            pop a
0272   05BD             ; --- END RELATIONAL
0273   05BD             ; --- START LOGICAL OR
0274   05BD D7            push a
0275   05BE 11            mov a, b
0276   05BF FA FD FF      lea d, [bp + -3] ; $format_p
0277   05C2 2A            mov b, [d]
0278   05C3 38 00 00      mov c, 0
0279   05C6 74            mov d, b
0280   05C7 32            mov bl, [d]
0281   05C8 A7 00         mov bh, 0
0282   05CA 38 00 00      mov c, 0
0283   05CD             ; --- START RELATIONAL
0284   05CD D7            push a
0285   05CE 11            mov a, b
0286   05CF FD 2E 69 00   mov32 cb, $00000069
0286   05D3 00 00 
0287   05D5 B0            cmp a, b
0288   05D6 FD 71         seq ; ==
0289   05D8 E4            pop a
0290   05D9             ; --- END RELATIONAL
0291   05D9 FD A8         sor a, b ; ||
0292   05DB E4            pop a
0293   05DC             ; --- END LOGICAL OR
0294   05DC C0 00 00      cmp b, 0
0295   05DF C6 00 06      je _if7_else
0296   05E2             _if7_TRUE:
0297   05E2             ; print_signed_long(*(long *)p); 
0298   05E2             ; --- START FUNCTION CALL
0299   05E2 FA FF FF      lea d, [bp + -1] ; $p
0300   05E5 2A            mov b, [d]
0301   05E6 38 00 00      mov c, 0
0302   05E9 74            mov d, b
0303   05EA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0304   05ED FD 39         mov c, b ; And place it into C
0305   05EF 2A            mov b, [d] ; Lower Word in B
0306   05F0 12            mov a, c
0307   05F1 FD AA         swp a
0308   05F3 D7            push a
0309   05F4 FD AB         swp b
0310   05F6 D8            push b
0311   05F7 07 C9 07      call print_signed_long
0312   05FA 51 04 00      add sp, 4
0313   05FD             ; --- END FUNCTION CALL
0314   05FD 0A 88 06      jmp _if7_exit
0315   0600             _if7_else:
0316   0600             ; if(*format_p == 'u') 
0317   0600             _if8_cond:
0318   0600 FA FD FF      lea d, [bp + -3] ; $format_p
0319   0603 2A            mov b, [d]
0320   0604 38 00 00      mov c, 0
0321   0607 74            mov d, b
0322   0608 32            mov bl, [d]
0323   0609 A7 00         mov bh, 0
0324   060B 38 00 00      mov c, 0
0325   060E             ; --- START RELATIONAL
0326   060E D7            push a
0327   060F 11            mov a, b
0328   0610 FD 2E 75 00   mov32 cb, $00000075
0328   0614 00 00 
0329   0616 B0            cmp a, b
0330   0617 FD 71         seq ; ==
0331   0619 E4            pop a
0332   061A             ; --- END RELATIONAL
0333   061A C0 00 00      cmp b, 0
0334   061D C6 3E 06      je _if8_else
0335   0620             _if8_TRUE:
0336   0620             ; print_unsigned_long(*(unsigned long *)p); 
0337   0620             ; --- START FUNCTION CALL
0338   0620 FA FF FF      lea d, [bp + -1] ; $p
0339   0623 2A            mov b, [d]
0340   0624 38 00 00      mov c, 0
0341   0627 74            mov d, b
0342   0628 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0343   062B FD 39         mov c, b ; And place it into C
0344   062D 2A            mov b, [d] ; Lower Word in B
0345   062E 12            mov a, c
0346   062F FD AA         swp a
0347   0631 D7            push a
0348   0632 FD AB         swp b
0349   0634 D8            push b
0350   0635 07 5C 09      call print_unsigned_long
0351   0638 51 04 00      add sp, 4
0352   063B             ; --- END FUNCTION CALL
0353   063B 0A 88 06      jmp _if8_exit
0354   063E             _if8_else:
0355   063E             ; if(*format_p == 'x') 
0356   063E             _if9_cond:
0357   063E FA FD FF      lea d, [bp + -3] ; $format_p
0358   0641 2A            mov b, [d]
0359   0642 38 00 00      mov c, 0
0360   0645 74            mov d, b
0361   0646 32            mov bl, [d]
0362   0647 A7 00         mov bh, 0
0363   0649 38 00 00      mov c, 0
0364   064C             ; --- START RELATIONAL
0365   064C D7            push a
0366   064D 11            mov a, b
0367   064E FD 2E 78 00   mov32 cb, $00000078
0367   0652 00 00 
0368   0654 B0            cmp a, b
0369   0655 FD 71         seq ; ==
0370   0657 E4            pop a
0371   0658             ; --- END RELATIONAL
0372   0658 C0 00 00      cmp b, 0
0373   065B C6 7C 06      je _if9_else
0374   065E             _if9_TRUE:
0375   065E             ; printx32(*(long int *)p); 
0376   065E             ; --- START FUNCTION CALL
0377   065E FA FF FF      lea d, [bp + -1] ; $p
0378   0661 2A            mov b, [d]
0379   0662 38 00 00      mov c, 0
0380   0665 74            mov d, b
0381   0666 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0382   0669 FD 39         mov c, b ; And place it into C
0383   066B 2A            mov b, [d] ; Lower Word in B
0384   066C 12            mov a, c
0385   066D FD AA         swp a
0386   066F D7            push a
0387   0670 FD AB         swp b
0388   0672 D8            push b
0389   0673 07 90 0A      call printx32
0390   0676 51 04 00      add sp, 4
0391   0679             ; --- END FUNCTION CALL
0392   0679 0A 88 06      jmp _if9_exit
0393   067C             _if9_else:
0394   067C             ; err("Unexpected format in printf."); 
0395   067C             ; --- START FUNCTION CALL
0396   067C 26 E2 11      mov b, _s1 ; "Unexpected format in printf."
0397   067F FD AB         swp b
0398   0681 D8            push b
0399   0682 07 F0 0A      call err
0400   0685 51 02 00      add sp, 2
0401   0688             ; --- END FUNCTION CALL
0402   0688             _if9_exit:
0403   0688             _if8_exit:
0404   0688             _if7_exit:
0405   0688             ; p = p + 4; 
0406   0688 FA FF FF      lea d, [bp + -1] ; $p
0407   068B DA            push d
0408   068C FA FF FF      lea d, [bp + -1] ; $p
0409   068F 2A            mov b, [d]
0410   0690 38 00 00      mov c, 0
0411   0693             ; --- START TERMS
0412   0693 D7            push a
0413   0694 11            mov a, b
0414   0695 FD 2E 04 00   mov32 cb, $00000004
0414   0699 00 00 
0415   069B 56            add b, a
0416   069C E4            pop a
0417   069D             ; --- END TERMS
0418   069D E7            pop d
0419   069E FD 43         mov [d], b
0420   06A0             ; break; 
0421   06A0 0A 9C 07      jmp _switch6_exit ; case break
0422   06A3             _switch6_case2:
0423   06A3             _switch6_case3:
0424   06A3             ; print_signed(*(int*)p); 
0425   06A3             ; --- START FUNCTION CALL
0426   06A3 FA FF FF      lea d, [bp + -1] ; $p
0427   06A6 2A            mov b, [d]
0428   06A7 38 00 00      mov c, 0
0429   06AA 74            mov d, b
0430   06AB 2A            mov b, [d]
0431   06AC 38 00 00      mov c, 0
0432   06AF FD AB         swp b
0433   06B1 D8            push b
0434   06B2 07 1E 0B      call print_signed
0435   06B5 51 02 00      add sp, 2
0436   06B8             ; --- END FUNCTION CALL
0437   06B8             ; p = p + 2; 
0438   06B8 FA FF FF      lea d, [bp + -1] ; $p
0439   06BB DA            push d
0440   06BC FA FF FF      lea d, [bp + -1] ; $p
0441   06BF 2A            mov b, [d]
0442   06C0 38 00 00      mov c, 0
0443   06C3             ; --- START TERMS
0444   06C3 D7            push a
0445   06C4 11            mov a, b
0446   06C5 FD 2E 02 00   mov32 cb, $00000002
0446   06C9 00 00 
0447   06CB 56            add b, a
0448   06CC E4            pop a
0449   06CD             ; --- END TERMS
0450   06CD E7            pop d
0451   06CE FD 43         mov [d], b
0452   06D0             ; break; 
0453   06D0 0A 9C 07      jmp _switch6_exit ; case break
0454   06D3             _switch6_case4:
0455   06D3             ; print_unsigned(*(unsigned int*)p); 
0456   06D3             ; --- START FUNCTION CALL
0457   06D3 FA FF FF      lea d, [bp + -1] ; $p
0458   06D6 2A            mov b, [d]
0459   06D7 38 00 00      mov c, 0
0460   06DA 74            mov d, b
0461   06DB 2A            mov b, [d]
0462   06DC 38 00 00      mov c, 0
0463   06DF FD AB         swp b
0464   06E1 D8            push b
0465   06E2 07 6F 0C      call print_unsigned
0466   06E5 51 02 00      add sp, 2
0467   06E8             ; --- END FUNCTION CALL
0468   06E8             ; p = p + 2; 
0469   06E8 FA FF FF      lea d, [bp + -1] ; $p
0470   06EB DA            push d
0471   06EC FA FF FF      lea d, [bp + -1] ; $p
0472   06EF 2A            mov b, [d]
0473   06F0 38 00 00      mov c, 0
0474   06F3             ; --- START TERMS
0475   06F3 D7            push a
0476   06F4 11            mov a, b
0477   06F5 FD 2E 02 00   mov32 cb, $00000002
0477   06F9 00 00 
0478   06FB 56            add b, a
0479   06FC E4            pop a
0480   06FD             ; --- END TERMS
0481   06FD E7            pop d
0482   06FE FD 43         mov [d], b
0483   0700             ; break; 
0484   0700 0A 9C 07      jmp _switch6_exit ; case break
0485   0703             _switch6_case5:
0486   0703             ; printx16(*(int*)p); 
0487   0703             ; --- START FUNCTION CALL
0488   0703 FA FF FF      lea d, [bp + -1] ; $p
0489   0706 2A            mov b, [d]
0490   0707 38 00 00      mov c, 0
0491   070A 74            mov d, b
0492   070B 2A            mov b, [d]
0493   070C 38 00 00      mov c, 0
0494   070F FD AB         swp b
0495   0711 D8            push b
0496   0712 07 87 0D      call printx16
0497   0715 51 02 00      add sp, 2
0498   0718             ; --- END FUNCTION CALL
0499   0718             ; p = p + 2; 
0500   0718 FA FF FF      lea d, [bp + -1] ; $p
0501   071B DA            push d
0502   071C FA FF FF      lea d, [bp + -1] ; $p
0503   071F 2A            mov b, [d]
0504   0720 38 00 00      mov c, 0
0505   0723             ; --- START TERMS
0506   0723 D7            push a
0507   0724 11            mov a, b
0508   0725 FD 2E 02 00   mov32 cb, $00000002
0508   0729 00 00 
0509   072B 56            add b, a
0510   072C E4            pop a
0511   072D             ; --- END TERMS
0512   072D E7            pop d
0513   072E FD 43         mov [d], b
0514   0730             ; break; 
0515   0730 0A 9C 07      jmp _switch6_exit ; case break
0516   0733             _switch6_case6:
0517   0733             ; putchar(*(char*)p); 
0518   0733             ; --- START FUNCTION CALL
0519   0733 FA FF FF      lea d, [bp + -1] ; $p
0520   0736 2A            mov b, [d]
0521   0737 38 00 00      mov c, 0
0522   073A 74            mov d, b
0523   073B 32            mov bl, [d]
0524   073C A7 00         mov bh, 0
0525   073E 38 00 00      mov c, 0
0526   0741 DD            push bl
0527   0742 07 4E 09      call putchar
0528   0745 51 01 00      add sp, 1
0529   0748             ; --- END FUNCTION CALL
0530   0748             ; p = p + 2; 
0531   0748 FA FF FF      lea d, [bp + -1] ; $p
0532   074B DA            push d
0533   074C FA FF FF      lea d, [bp + -1] ; $p
0534   074F 2A            mov b, [d]
0535   0750 38 00 00      mov c, 0
0536   0753             ; --- START TERMS
0537   0753 D7            push a
0538   0754 11            mov a, b
0539   0755 FD 2E 02 00   mov32 cb, $00000002
0539   0759 00 00 
0540   075B 56            add b, a
0541   075C E4            pop a
0542   075D             ; --- END TERMS
0543   075D E7            pop d
0544   075E FD 43         mov [d], b
0545   0760             ; break; 
0546   0760 0A 9C 07      jmp _switch6_exit ; case break
0547   0763             _switch6_case7:
0548   0763             ; print(*(char**)p); 
0549   0763             ; --- START FUNCTION CALL
0550   0763 FA FF FF      lea d, [bp + -1] ; $p
0551   0766 2A            mov b, [d]
0552   0767 38 00 00      mov c, 0
0553   076A 74            mov d, b
0554   076B 2A            mov b, [d]
0555   076C FD AB         swp b
0556   076E D8            push b
0557   076F 07 05 0B      call print
0558   0772 51 02 00      add sp, 2
0559   0775             ; --- END FUNCTION CALL
0560   0775             ; p = p + 2; 
0561   0775 FA FF FF      lea d, [bp + -1] ; $p
0562   0778 DA            push d
0563   0779 FA FF FF      lea d, [bp + -1] ; $p
0564   077C 2A            mov b, [d]
0565   077D 38 00 00      mov c, 0
0566   0780             ; --- START TERMS
0567   0780 D7            push a
0568   0781 11            mov a, b
0569   0782 FD 2E 02 00   mov32 cb, $00000002
0569   0786 00 00 
0570   0788 56            add b, a
0571   0789 E4            pop a
0572   078A             ; --- END TERMS
0573   078A E7            pop d
0574   078B FD 43         mov [d], b
0575   078D             ; break; 
0576   078D 0A 9C 07      jmp _switch6_exit ; case break
0577   0790             _switch6_default:
0578   0790             ; print("Error: Unknown argument type.\n"); 
0579   0790             ; --- START FUNCTION CALL
0580   0790 26 FF 11      mov b, _s2 ; "Error: Unknown argument type.\n"
0581   0793 FD AB         swp b
0582   0795 D8            push b
0583   0796 07 05 0B      call print
0584   0799 51 02 00      add sp, 2
0585   079C             ; --- END FUNCTION CALL
0586   079C             _switch6_exit:
0587   079C 0A B4 07      jmp _if5_exit
0588   079F             _if5_else:
0589   079F             ; putchar(*format_p); 
0590   079F             ; --- START FUNCTION CALL
0591   079F FA FD FF      lea d, [bp + -3] ; $format_p
0592   07A2 2A            mov b, [d]
0593   07A3 38 00 00      mov c, 0
0594   07A6 74            mov d, b
0595   07A7 32            mov bl, [d]
0596   07A8 A7 00         mov bh, 0
0597   07AA 38 00 00      mov c, 0
0598   07AD DD            push bl
0599   07AE 07 4E 09      call putchar
0600   07B1 51 01 00      add sp, 1
0601   07B4             ; --- END FUNCTION CALL
0602   07B4             _if5_exit:
0603   07B4             _if4_exit:
0604   07B4             ; format_p++; 
0605   07B4 FA FD FF      lea d, [bp + -3] ; $format_p
0606   07B7 2A            mov b, [d]
0607   07B8 38 00 00      mov c, 0
0608   07BB FD 77         inc b
0609   07BD FA FD FF      lea d, [bp + -3] ; $format_p
0610   07C0 FD 43         mov [d], b
0611   07C2 FD 7D         dec b
0612   07C4             _for3_update:
0613   07C4 0A 08 05      jmp _for3_cond
0614   07C7             _for3_exit:
0615   07C7 F9            leave
0616   07C8 09            ret
0617   07C9             
0618   07C9             print_signed_long:
0619   07C9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0620   07CC             ; char digits[10]; 
0621   07CC 52 0A 00      sub sp, 10
0622   07CF             ; int i = 0; 
0623   07CF 52 02 00      sub sp, 2
0624   07D2             ; --- START LOCAL VAR INITIALIZATION
0625   07D2 FA F5 FF      lea d, [bp + -11] ; $i
0626   07D5 DA            push d
0627   07D6 FD 2E 00 00   mov32 cb, $00000000
0627   07DA 00 00 
0628   07DC E7            pop d
0629   07DD FD 43         mov [d], b
0630   07DF             ; --- END LOCAL VAR INITIALIZATION
0631   07DF             ; if (num < 0) { 
0632   07DF             _if10_cond:
0633   07DF FA 05 00      lea d, [bp + 5] ; $num
0634   07E2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0635   07E5 FD 39         mov c, b ; And place it into C
0636   07E7 2A            mov b, [d] ; Lower Word in B
0637   07E8             ; --- START RELATIONAL
0638   07E8 D7            push a
0639   07E9 FD D8         push g
0640   07EB 11            mov a, b
0641   07EC FD 7A         mov g, c
0642   07EE FD 2E 00 00   mov32 cb, $00000000
0642   07F2 00 00 
0643   07F4 FD AF         cmp32 ga, cb
0644   07F6 FD 73         slt ; <
0645   07F8 FD F1         pop g
0646   07FA E4            pop a
0647   07FB             ; --- END RELATIONAL
0648   07FB C0 00 00      cmp b, 0
0649   07FE C6 30 08      je _if10_else
0650   0801             _if10_TRUE:
0651   0801             ; putchar('-'); 
0652   0801             ; --- START FUNCTION CALL
0653   0801 FD 2E 2D 00   mov32 cb, $0000002d
0653   0805 00 00 
0654   0807 DD            push bl
0655   0808 07 4E 09      call putchar
0656   080B 51 01 00      add sp, 1
0657   080E             ; --- END FUNCTION CALL
0658   080E             ; num = -num; 
0659   080E FA 05 00      lea d, [bp + 5] ; $num
0660   0811 DA            push d
0661   0812 FA 05 00      lea d, [bp + 5] ; $num
0662   0815 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0663   0818 FD 39         mov c, b ; And place it into C
0664   081A 2A            mov b, [d] ; Lower Word in B
0665   081B 12            mov a, c
0666   081C 95            not a
0667   081D 97            not b
0668   081E 55 01 00      add b, 1
0669   0821 5B 00 00      adc a, 0
0670   0824 39            mov c, a
0671   0825 E7            pop d
0672   0826 FD 43         mov [d], b
0673   0828 28            mov b, c
0674   0829 FD 44 02 00   mov [d + 2], b
0675   082D 0A 64 08      jmp _if10_exit
0676   0830             _if10_else:
0677   0830             ; if (num == 0) { 
0678   0830             _if11_cond:
0679   0830 FA 05 00      lea d, [bp + 5] ; $num
0680   0833 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0681   0836 FD 39         mov c, b ; And place it into C
0682   0838 2A            mov b, [d] ; Lower Word in B
0683   0839             ; --- START RELATIONAL
0684   0839 D7            push a
0685   083A FD D8         push g
0686   083C 11            mov a, b
0687   083D FD 7A         mov g, c
0688   083F FD 2E 00 00   mov32 cb, $00000000
0688   0843 00 00 
0689   0845 FD AF         cmp32 ga, cb
0690   0847 FD 71         seq ; ==
0691   0849 FD F1         pop g
0692   084B E4            pop a
0693   084C             ; --- END RELATIONAL
0694   084C C0 00 00      cmp b, 0
0695   084F C6 64 08      je _if11_exit
0696   0852             _if11_TRUE:
0697   0852             ; putchar('0'); 
0698   0852             ; --- START FUNCTION CALL
0699   0852 FD 2E 30 00   mov32 cb, $00000030
0699   0856 00 00 
0700   0858 DD            push bl
0701   0859 07 4E 09      call putchar
0702   085C 51 01 00      add sp, 1
0703   085F             ; --- END FUNCTION CALL
0704   085F             ; return; 
0705   085F F9            leave
0706   0860 09            ret
0707   0861 0A 64 08      jmp _if11_exit
0708   0864             _if11_exit:
0709   0864             _if10_exit:
0710   0864             ; while (num > 0) { 
0711   0864             _while12_cond:
0712   0864 FA 05 00      lea d, [bp + 5] ; $num
0713   0867 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0714   086A FD 39         mov c, b ; And place it into C
0715   086C 2A            mov b, [d] ; Lower Word in B
0716   086D             ; --- START RELATIONAL
0717   086D D7            push a
0718   086E FD D8         push g
0719   0870 11            mov a, b
0720   0871 FD 7A         mov g, c
0721   0873 FD 2E 00 00   mov32 cb, $00000000
0721   0877 00 00 
0722   0879 FD AF         cmp32 ga, cb
0723   087B FD 7F         sgt
0724   087D FD F1         pop g
0725   087F E4            pop a
0726   0880             ; --- END RELATIONAL
0727   0880 C0 00 00      cmp b, 0
0728   0883 C6 04 09      je _while12_exit
0729   0886             _while12_block:
0730   0886             ; digits[i] = '0' + (num % 10); 
0731   0886 FA F7 FF      lea d, [bp + -9] ; $digits
0732   0889 D7            push a
0733   088A DA            push d
0734   088B FA F5 FF      lea d, [bp + -11] ; $i
0735   088E 2A            mov b, [d]
0736   088F 38 00 00      mov c, 0
0737   0892 E7            pop d
0738   0893 5A            add d, b
0739   0894 E4            pop a
0740   0895 DA            push d
0741   0896 FD 2E 30 00   mov32 cb, $00000030
0741   089A 00 00 
0742   089C             ; --- START TERMS
0743   089C D7            push a
0744   089D 11            mov a, b
0745   089E FA 05 00      lea d, [bp + 5] ; $num
0746   08A1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0747   08A4 FD 39         mov c, b ; And place it into C
0748   08A6 2A            mov b, [d] ; Lower Word in B
0749   08A7             ; --- START FACTORS
0750   08A7 D7            push a
0751   08A8 FD D8         push g
0752   08AA 11            mov a, b
0753   08AB FD 7A         mov g, c
0754   08AD FD 2E 0A 00   mov32 cb, $0000000a
0754   08B1 00 00 
0755   08B3 FD D8         push g ; save 'g' as the div instruction uses it
0756   08B5 AE            div a, b ; %, a: quotient, b: remainder
0757   08B6 11            mov a, b
0758   08B7 FD F1         pop g
0759   08B9 FD 38         mov c, g
0760   08BB 27            mov b, a
0761   08BC FD F1         pop g
0762   08BE E4            pop a
0763   08BF             ; --- END FACTORS
0764   08BF FD 15         add32 cb, ga
0765   08C1 E4            pop a
0766   08C2             ; --- END TERMS
0767   08C2 E7            pop d
0768   08C3 FD 3E         mov [d], bl
0769   08C5             ; num = num / 10; 
0770   08C5 FA 05 00      lea d, [bp + 5] ; $num
0771   08C8 DA            push d
0772   08C9 FA 05 00      lea d, [bp + 5] ; $num
0773   08CC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0774   08CF FD 39         mov c, b ; And place it into C
0775   08D1 2A            mov b, [d] ; Lower Word in B
0776   08D2             ; --- START FACTORS
0777   08D2 D7            push a
0778   08D3 FD D8         push g
0779   08D5 11            mov a, b
0780   08D6 FD 7A         mov g, c
0781   08D8 FD 2E 0A 00   mov32 cb, $0000000a
0781   08DC 00 00 
0782   08DE FD D8         push g ; save 'g' as the div instruction uses it
0783   08E0 AE            div a, b ; /, a: quotient, b: remainder
0784   08E1 FD F1         pop g
0785   08E3 FD 38         mov c, g
0786   08E5 27            mov b, a
0787   08E6 FD F1         pop g
0788   08E8 E4            pop a
0789   08E9             ; --- END FACTORS
0790   08E9 E7            pop d
0791   08EA FD 43         mov [d], b
0792   08EC 28            mov b, c
0793   08ED FD 44 02 00   mov [d + 2], b
0794   08F1             ; i++; 
0795   08F1 FA F5 FF      lea d, [bp + -11] ; $i
0796   08F4 2A            mov b, [d]
0797   08F5 38 00 00      mov c, 0
0798   08F8 11            mov a, b
0799   08F9 FD 77         inc b
0800   08FB FA F5 FF      lea d, [bp + -11] ; $i
0801   08FE FD 43         mov [d], b
0802   0900 27            mov b, a
0803   0901 0A 64 08      jmp _while12_cond
0804   0904             _while12_exit:
0805   0904             ; while (i > 0) { 
0806   0904             _while19_cond:
0807   0904 FA F5 FF      lea d, [bp + -11] ; $i
0808   0907 2A            mov b, [d]
0809   0908 38 00 00      mov c, 0
0810   090B             ; --- START RELATIONAL
0811   090B D7            push a
0812   090C 11            mov a, b
0813   090D FD 2E 00 00   mov32 cb, $00000000
0813   0911 00 00 
0814   0913 B0            cmp a, b
0815   0914 FD 7F         sgt ; >
0816   0916 E4            pop a
0817   0917             ; --- END RELATIONAL
0818   0917 C0 00 00      cmp b, 0
0819   091A C6 4C 09      je _while19_exit
0820   091D             _while19_block:
0821   091D             ; i--; 
0822   091D FA F5 FF      lea d, [bp + -11] ; $i
0823   0920 2A            mov b, [d]
0824   0921 38 00 00      mov c, 0
0825   0924 11            mov a, b
0826   0925 FD 7D         dec b
0827   0927 FA F5 FF      lea d, [bp + -11] ; $i
0828   092A FD 43         mov [d], b
0829   092C 27            mov b, a
0830   092D             ; putchar(digits[i]); 
0831   092D             ; --- START FUNCTION CALL
0832   092D FA F7 FF      lea d, [bp + -9] ; $digits
0833   0930 D7            push a
0834   0931 DA            push d
0835   0932 FA F5 FF      lea d, [bp + -11] ; $i
0836   0935 2A            mov b, [d]
0837   0936 38 00 00      mov c, 0
0838   0939 E7            pop d
0839   093A 5A            add d, b
0840   093B E4            pop a
0841   093C 32            mov bl, [d]
0842   093D A7 00         mov bh, 0
0843   093F 38 00 00      mov c, 0
0844   0942 DD            push bl
0845   0943 07 4E 09      call putchar
0846   0946 51 01 00      add sp, 1
0847   0949             ; --- END FUNCTION CALL
0848   0949 0A 04 09      jmp _while19_cond
0849   094C             _while19_exit:
0850   094C F9            leave
0851   094D 09            ret
0852   094E             
0853   094E             putchar:
0854   094E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0855   0951             ; --- BEGIN INLINE ASM SEGMENT
0856   0951 FA 05 00      lea d, [bp + 5] ; $c
0857   0954 1E            mov al, [d]
0858   0955 23            mov ah, al
0859   0956 19 00         mov al, 0
0860   0958 05 03         syscall sys_io      ; char in AH
0861   095A             ; --- END INLINE ASM SEGMENT
0862   095A F9            leave
0863   095B 09            ret
0864   095C             
0865   095C             print_unsigned_long:
0866   095C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0867   095F             ; char digits[10]; 
0868   095F 52 0A 00      sub sp, 10
0869   0962             ; int i; 
0870   0962 52 02 00      sub sp, 2
0871   0965             ; i = 0; 
0872   0965 FA F5 FF      lea d, [bp + -11] ; $i
0873   0968 DA            push d
0874   0969 FD 2E 00 00   mov32 cb, $00000000
0874   096D 00 00 
0875   096F E7            pop d
0876   0970 FD 43         mov [d], b
0877   0972             ; if(num == 0){ 
0878   0972             _if20_cond:
0879   0972 FA 05 00      lea d, [bp + 5] ; $num
0880   0975 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0881   0978 FD 39         mov c, b ; And place it into C
0882   097A 2A            mov b, [d] ; Lower Word in B
0883   097B             ; --- START RELATIONAL
0884   097B D7            push a
0885   097C FD D8         push g
0886   097E 11            mov a, b
0887   097F FD 7A         mov g, c
0888   0981 FD 2E 00 00   mov32 cb, $00000000
0888   0985 00 00 
0889   0987 FD AF         cmp32 ga, cb
0890   0989 FD 71         seq ; ==
0891   098B FD F1         pop g
0892   098D E4            pop a
0893   098E             ; --- END RELATIONAL
0894   098E C0 00 00      cmp b, 0
0895   0991 C6 A6 09      je _if20_exit
0896   0994             _if20_TRUE:
0897   0994             ; putchar('0'); 
0898   0994             ; --- START FUNCTION CALL
0899   0994 FD 2E 30 00   mov32 cb, $00000030
0899   0998 00 00 
0900   099A DD            push bl
0901   099B 07 4E 09      call putchar
0902   099E 51 01 00      add sp, 1
0903   09A1             ; --- END FUNCTION CALL
0904   09A1             ; return; 
0905   09A1 F9            leave
0906   09A2 09            ret
0907   09A3 0A A6 09      jmp _if20_exit
0908   09A6             _if20_exit:
0909   09A6             ; while (num > 0) { 
0910   09A6             _while21_cond:
0911   09A6 FA 05 00      lea d, [bp + 5] ; $num
0912   09A9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0913   09AC FD 39         mov c, b ; And place it into C
0914   09AE 2A            mov b, [d] ; Lower Word in B
0915   09AF             ; --- START RELATIONAL
0916   09AF D7            push a
0917   09B0 FD D8         push g
0918   09B2 11            mov a, b
0919   09B3 FD 7A         mov g, c
0920   09B5 FD 2E 00 00   mov32 cb, $00000000
0920   09B9 00 00 
0921   09BB FD AF         cmp32 ga, cb
0922   09BD FD 81         sgu
0923   09BF FD F1         pop g
0924   09C1 E4            pop a
0925   09C2             ; --- END RELATIONAL
0926   09C2 C0 00 00      cmp b, 0
0927   09C5 C6 46 0A      je _while21_exit
0928   09C8             _while21_block:
0929   09C8             ; digits[i] = '0' + (num % 10); 
0930   09C8 FA F7 FF      lea d, [bp + -9] ; $digits
0931   09CB D7            push a
0932   09CC DA            push d
0933   09CD FA F5 FF      lea d, [bp + -11] ; $i
0934   09D0 2A            mov b, [d]
0935   09D1 38 00 00      mov c, 0
0936   09D4 E7            pop d
0937   09D5 5A            add d, b
0938   09D6 E4            pop a
0939   09D7 DA            push d
0940   09D8 FD 2E 30 00   mov32 cb, $00000030
0940   09DC 00 00 
0941   09DE             ; --- START TERMS
0942   09DE D7            push a
0943   09DF 11            mov a, b
0944   09E0 FA 05 00      lea d, [bp + 5] ; $num
0945   09E3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0946   09E6 FD 39         mov c, b ; And place it into C
0947   09E8 2A            mov b, [d] ; Lower Word in B
0948   09E9             ; --- START FACTORS
0949   09E9 D7            push a
0950   09EA FD D8         push g
0951   09EC 11            mov a, b
0952   09ED FD 7A         mov g, c
0953   09EF FD 2E 0A 00   mov32 cb, $0000000a
0953   09F3 00 00 
0954   09F5 FD D8         push g ; save 'g' as the div instruction uses it
0955   09F7 AE            div a, b ; %, a: quotient, b: remainder
0956   09F8 11            mov a, b
0957   09F9 FD F1         pop g
0958   09FB FD 38         mov c, g
0959   09FD 27            mov b, a
0960   09FE FD F1         pop g
0961   0A00 E4            pop a
0962   0A01             ; --- END FACTORS
0963   0A01 FD 15         add32 cb, ga
0964   0A03 E4            pop a
0965   0A04             ; --- END TERMS
0966   0A04 E7            pop d
0967   0A05 FD 3E         mov [d], bl
0968   0A07             ; num = num / 10; 
0969   0A07 FA 05 00      lea d, [bp + 5] ; $num
0970   0A0A DA            push d
0971   0A0B FA 05 00      lea d, [bp + 5] ; $num
0972   0A0E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0973   0A11 FD 39         mov c, b ; And place it into C
0974   0A13 2A            mov b, [d] ; Lower Word in B
0975   0A14             ; --- START FACTORS
0976   0A14 D7            push a
0977   0A15 FD D8         push g
0978   0A17 11            mov a, b
0979   0A18 FD 7A         mov g, c
0980   0A1A FD 2E 0A 00   mov32 cb, $0000000a
0980   0A1E 00 00 
0981   0A20 FD D8         push g ; save 'g' as the div instruction uses it
0982   0A22 AE            div a, b ; /, a: quotient, b: remainder
0983   0A23 FD F1         pop g
0984   0A25 FD 38         mov c, g
0985   0A27 27            mov b, a
0986   0A28 FD F1         pop g
0987   0A2A E4            pop a
0988   0A2B             ; --- END FACTORS
0989   0A2B E7            pop d
0990   0A2C FD 43         mov [d], b
0991   0A2E 28            mov b, c
0992   0A2F FD 44 02 00   mov [d + 2], b
0993   0A33             ; i++; 
0994   0A33 FA F5 FF      lea d, [bp + -11] ; $i
0995   0A36 2A            mov b, [d]
0996   0A37 38 00 00      mov c, 0
0997   0A3A 11            mov a, b
0998   0A3B FD 77         inc b
0999   0A3D FA F5 FF      lea d, [bp + -11] ; $i
1000   0A40 FD 43         mov [d], b
1001   0A42 27            mov b, a
1002   0A43 0A A6 09      jmp _while21_cond
1003   0A46             _while21_exit:
1004   0A46             ; while (i > 0) { 
1005   0A46             _while28_cond:
1006   0A46 FA F5 FF      lea d, [bp + -11] ; $i
1007   0A49 2A            mov b, [d]
1008   0A4A 38 00 00      mov c, 0
1009   0A4D             ; --- START RELATIONAL
1010   0A4D D7            push a
1011   0A4E 11            mov a, b
1012   0A4F FD 2E 00 00   mov32 cb, $00000000
1012   0A53 00 00 
1013   0A55 B0            cmp a, b
1014   0A56 FD 7F         sgt ; >
1015   0A58 E4            pop a
1016   0A59             ; --- END RELATIONAL
1017   0A59 C0 00 00      cmp b, 0
1018   0A5C C6 8E 0A      je _while28_exit
1019   0A5F             _while28_block:
1020   0A5F             ; i--; 
1021   0A5F FA F5 FF      lea d, [bp + -11] ; $i
1022   0A62 2A            mov b, [d]
1023   0A63 38 00 00      mov c, 0
1024   0A66 11            mov a, b
1025   0A67 FD 7D         dec b
1026   0A69 FA F5 FF      lea d, [bp + -11] ; $i
1027   0A6C FD 43         mov [d], b
1028   0A6E 27            mov b, a
1029   0A6F             ; putchar(digits[i]); 
1030   0A6F             ; --- START FUNCTION CALL
1031   0A6F FA F7 FF      lea d, [bp + -9] ; $digits
1032   0A72 D7            push a
1033   0A73 DA            push d
1034   0A74 FA F5 FF      lea d, [bp + -11] ; $i
1035   0A77 2A            mov b, [d]
1036   0A78 38 00 00      mov c, 0
1037   0A7B E7            pop d
1038   0A7C 5A            add d, b
1039   0A7D E4            pop a
1040   0A7E 32            mov bl, [d]
1041   0A7F A7 00         mov bh, 0
1042   0A81 38 00 00      mov c, 0
1043   0A84 DD            push bl
1044   0A85 07 4E 09      call putchar
1045   0A88 51 01 00      add sp, 1
1046   0A8B             ; --- END FUNCTION CALL
1047   0A8B 0A 46 0A      jmp _while28_cond
1048   0A8E             _while28_exit:
1049   0A8E F9            leave
1050   0A8F 09            ret
1051   0A90             
1052   0A90             printx32:
1053   0A90 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1054   0A93             ; --- BEGIN INLINE ASM SEGMENT
1055   0A93 FA 05 00      lea d, [bp + 5] ; $hex
1056   0A96 2B 02 00      mov b, [d+2]
1057   0A99 07 A2 0A      call print_u16x_printx32
1058   0A9C 2A            mov b, [d]
1059   0A9D 07 A2 0A      call print_u16x_printx32
1060   0AA0             ; --- END INLINE ASM SEGMENT
1061   0AA0             ; return; 
1062   0AA0 F9            leave
1063   0AA1 09            ret
1064   0AA2             ; --- BEGIN INLINE ASM SEGMENT
1065   0AA2             print_u16x_printx32:
1066   0AA2 D7            push a
1067   0AA3 D8            push b
1068   0AA4 DD            push bl
1069   0AA5 30            mov bl, bh
1070   0AA6 07 C4 0A      call _itoa_printx32        ; convert bh to char in A
1071   0AA9 2F            mov bl, al        ; save al
1072   0AAA 19 00         mov al, 0
1073   0AAC 05 03         syscall sys_io        ; display AH
1074   0AAE 24            mov ah, bl        ; retrieve al
1075   0AAF 19 00         mov al, 0
1076   0AB1 05 03         syscall sys_io        ; display AL
1077   0AB3 EA            pop bl
1078   0AB4 07 C4 0A      call _itoa_printx32        ; convert bh to char in A
1079   0AB7 2F            mov bl, al        ; save al
1080   0AB8 19 00         mov al, 0
1081   0ABA 05 03         syscall sys_io        ; display AH
1082   0ABC 24            mov ah, bl        ; retrieve al
1083   0ABD 19 00         mov al, 0
1084   0ABF 05 03         syscall sys_io        ; display AL
1085   0AC1 E5            pop b
1086   0AC2 E4            pop a
1087   0AC3 09            ret
1088   0AC4             _itoa_printx32:
1089   0AC4 DA            push d
1090   0AC5 D8            push b
1091   0AC6 A7 00         mov bh, 0
1092   0AC8 FD A4 04      shr bl, 4  
1093   0ACB 74            mov d, b
1094   0ACC 1F DE 0A      mov al, [d + s_hex_digits_printx32]
1095   0ACF 23            mov ah, al
1096   0AD0 E5            pop b
1097   0AD1 D8            push b
1098   0AD2 A7 00         mov bh, 0
1099   0AD4 FD 87 0F      and bl, $0F
1100   0AD7 74            mov d, b
1101   0AD8 1F DE 0A      mov al, [d + s_hex_digits_printx32]
1102   0ADB E5            pop b
1103   0ADC E7            pop d
1104   0ADD 09            ret
1105   0ADE 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1105   0AE2 34 35 36 37 
1105   0AE6 38 39 41 42 
1105   0AEA 43 44 45 46 
1106   0AEE             ; --- END INLINE ASM SEGMENT
1107   0AEE F9            leave
1108   0AEF 09            ret
1109   0AF0             
1110   0AF0             err:
1111   0AF0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1112   0AF3             ; print(e); 
1113   0AF3             ; --- START FUNCTION CALL
1114   0AF3 FA 05 00      lea d, [bp + 5] ; $e
1115   0AF6 2A            mov b, [d]
1116   0AF7 38 00 00      mov c, 0
1117   0AFA FD AB         swp b
1118   0AFC D8            push b
1119   0AFD 07 05 0B      call print
1120   0B00 51 02 00      add sp, 2
1121   0B03             ; --- END FUNCTION CALL
1122   0B03 F9            leave
1123   0B04 09            ret
1124   0B05             
1125   0B05             print:
1126   0B05 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1127   0B08             ; --- BEGIN INLINE ASM SEGMENT
1128   0B08 FA 05 00      lea d, [bp + 5] ; $s
1129   0B0B FD 2A         mov d, [d]
1130   0B0D             _puts_L1_print:
1131   0B0D 1E            mov al, [d]
1132   0B0E B9 00         cmp al, 0
1133   0B10 C6 1C 0B      jz _puts_END_print
1134   0B13 23            mov ah, al
1135   0B14 19 00         mov al, 0
1136   0B16 05 03         syscall sys_io
1137   0B18 79            inc d
1138   0B19 0A 0D 0B      jmp _puts_L1_print
1139   0B1C             _puts_END_print:
1140   0B1C             ; --- END INLINE ASM SEGMENT
1141   0B1C F9            leave
1142   0B1D 09            ret
1143   0B1E             
1144   0B1E             print_signed:
1145   0B1E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1146   0B21             ; char digits[5]; 
1147   0B21 52 05 00      sub sp, 5
1148   0B24             ; int i = 0; 
1149   0B24 52 02 00      sub sp, 2
1150   0B27             ; --- START LOCAL VAR INITIALIZATION
1151   0B27 FA FA FF      lea d, [bp + -6] ; $i
1152   0B2A DA            push d
1153   0B2B FD 2E 00 00   mov32 cb, $00000000
1153   0B2F 00 00 
1154   0B31 E7            pop d
1155   0B32 FD 43         mov [d], b
1156   0B34             ; --- END LOCAL VAR INITIALIZATION
1157   0B34             ; if (num < 0) { 
1158   0B34             _if29_cond:
1159   0B34 FA 05 00      lea d, [bp + 5] ; $num
1160   0B37 2A            mov b, [d]
1161   0B38 38 00 00      mov c, 0
1162   0B3B             ; --- START RELATIONAL
1163   0B3B D7            push a
1164   0B3C 11            mov a, b
1165   0B3D FD 2E 00 00   mov32 cb, $00000000
1165   0B41 00 00 
1166   0B43 B0            cmp a, b
1167   0B44 FD 73         slt ; < (signed)
1168   0B46 E4            pop a
1169   0B47             ; --- END RELATIONAL
1170   0B47 C0 00 00      cmp b, 0
1171   0B4A C6 6D 0B      je _if29_else
1172   0B4D             _if29_TRUE:
1173   0B4D             ; putchar('-'); 
1174   0B4D             ; --- START FUNCTION CALL
1175   0B4D FD 2E 2D 00   mov32 cb, $0000002d
1175   0B51 00 00 
1176   0B53 DD            push bl
1177   0B54 07 4E 09      call putchar
1178   0B57 51 01 00      add sp, 1
1179   0B5A             ; --- END FUNCTION CALL
1180   0B5A             ; num = -num; 
1181   0B5A FA 05 00      lea d, [bp + 5] ; $num
1182   0B5D DA            push d
1183   0B5E FA 05 00      lea d, [bp + 5] ; $num
1184   0B61 2A            mov b, [d]
1185   0B62 38 00 00      mov c, 0
1186   0B65 FD 97         neg b
1187   0B67 E7            pop d
1188   0B68 FD 43         mov [d], b
1189   0B6A 0A 98 0B      jmp _if29_exit
1190   0B6D             _if29_else:
1191   0B6D             ; if (num == 0) { 
1192   0B6D             _if30_cond:
1193   0B6D FA 05 00      lea d, [bp + 5] ; $num
1194   0B70 2A            mov b, [d]
1195   0B71 38 00 00      mov c, 0
1196   0B74             ; --- START RELATIONAL
1197   0B74 D7            push a
1198   0B75 11            mov a, b
1199   0B76 FD 2E 00 00   mov32 cb, $00000000
1199   0B7A 00 00 
1200   0B7C B0            cmp a, b
1201   0B7D FD 71         seq ; ==
1202   0B7F E4            pop a
1203   0B80             ; --- END RELATIONAL
1204   0B80 C0 00 00      cmp b, 0
1205   0B83 C6 98 0B      je _if30_exit
1206   0B86             _if30_TRUE:
1207   0B86             ; putchar('0'); 
1208   0B86             ; --- START FUNCTION CALL
1209   0B86 FD 2E 30 00   mov32 cb, $00000030
1209   0B8A 00 00 
1210   0B8C DD            push bl
1211   0B8D 07 4E 09      call putchar
1212   0B90 51 01 00      add sp, 1
1213   0B93             ; --- END FUNCTION CALL
1214   0B93             ; return; 
1215   0B93 F9            leave
1216   0B94 09            ret
1217   0B95 0A 98 0B      jmp _if30_exit
1218   0B98             _if30_exit:
1219   0B98             _if29_exit:
1220   0B98             ; while (num > 0) { 
1221   0B98             _while31_cond:
1222   0B98 FA 05 00      lea d, [bp + 5] ; $num
1223   0B9B 2A            mov b, [d]
1224   0B9C 38 00 00      mov c, 0
1225   0B9F             ; --- START RELATIONAL
1226   0B9F D7            push a
1227   0BA0 11            mov a, b
1228   0BA1 FD 2E 00 00   mov32 cb, $00000000
1228   0BA5 00 00 
1229   0BA7 B0            cmp a, b
1230   0BA8 FD 7F         sgt ; >
1231   0BAA E4            pop a
1232   0BAB             ; --- END RELATIONAL
1233   0BAB C0 00 00      cmp b, 0
1234   0BAE C6 25 0C      je _while31_exit
1235   0BB1             _while31_block:
1236   0BB1             ; digits[i] = '0' + (num % 10); 
1237   0BB1 FA FC FF      lea d, [bp + -4] ; $digits
1238   0BB4 D7            push a
1239   0BB5 DA            push d
1240   0BB6 FA FA FF      lea d, [bp + -6] ; $i
1241   0BB9 2A            mov b, [d]
1242   0BBA 38 00 00      mov c, 0
1243   0BBD E7            pop d
1244   0BBE 5A            add d, b
1245   0BBF E4            pop a
1246   0BC0 DA            push d
1247   0BC1 FD 2E 30 00   mov32 cb, $00000030
1247   0BC5 00 00 
1248   0BC7             ; --- START TERMS
1249   0BC7 D7            push a
1250   0BC8 11            mov a, b
1251   0BC9 FA 05 00      lea d, [bp + 5] ; $num
1252   0BCC 2A            mov b, [d]
1253   0BCD 38 00 00      mov c, 0
1254   0BD0             ; --- START FACTORS
1255   0BD0 D7            push a
1256   0BD1 FD D8         push g
1257   0BD3 11            mov a, b
1258   0BD4 FD 7A         mov g, c
1259   0BD6 FD 2E 0A 00   mov32 cb, $0000000a
1259   0BDA 00 00 
1260   0BDC FD D8         push g ; save 'g' as the div instruction uses it
1261   0BDE AE            div a, b ; %, a: quotient, b: remainder
1262   0BDF 11            mov a, b
1263   0BE0 FD F1         pop g
1264   0BE2 FD 38         mov c, g
1265   0BE4 27            mov b, a
1266   0BE5 FD F1         pop g
1267   0BE7 E4            pop a
1268   0BE8             ; --- END FACTORS
1269   0BE8 56            add b, a
1270   0BE9 E4            pop a
1271   0BEA             ; --- END TERMS
1272   0BEA E7            pop d
1273   0BEB FD 3E         mov [d], bl
1274   0BED             ; num = num / 10; 
1275   0BED FA 05 00      lea d, [bp + 5] ; $num
1276   0BF0 DA            push d
1277   0BF1 FA 05 00      lea d, [bp + 5] ; $num
1278   0BF4 2A            mov b, [d]
1279   0BF5 38 00 00      mov c, 0
1280   0BF8             ; --- START FACTORS
1281   0BF8 D7            push a
1282   0BF9 FD D8         push g
1283   0BFB 11            mov a, b
1284   0BFC FD 7A         mov g, c
1285   0BFE FD 2E 0A 00   mov32 cb, $0000000a
1285   0C02 00 00 
1286   0C04 FD D8         push g ; save 'g' as the div instruction uses it
1287   0C06 AE            div a, b ; /, a: quotient, b: remainder
1288   0C07 FD F1         pop g
1289   0C09 FD 38         mov c, g
1290   0C0B 27            mov b, a
1291   0C0C FD F1         pop g
1292   0C0E E4            pop a
1293   0C0F             ; --- END FACTORS
1294   0C0F E7            pop d
1295   0C10 FD 43         mov [d], b
1296   0C12             ; i++; 
1297   0C12 FA FA FF      lea d, [bp + -6] ; $i
1298   0C15 2A            mov b, [d]
1299   0C16 38 00 00      mov c, 0
1300   0C19 11            mov a, b
1301   0C1A FD 77         inc b
1302   0C1C FA FA FF      lea d, [bp + -6] ; $i
1303   0C1F FD 43         mov [d], b
1304   0C21 27            mov b, a
1305   0C22 0A 98 0B      jmp _while31_cond
1306   0C25             _while31_exit:
1307   0C25             ; while (i > 0) { 
1308   0C25             _while38_cond:
1309   0C25 FA FA FF      lea d, [bp + -6] ; $i
1310   0C28 2A            mov b, [d]
1311   0C29 38 00 00      mov c, 0
1312   0C2C             ; --- START RELATIONAL
1313   0C2C D7            push a
1314   0C2D 11            mov a, b
1315   0C2E FD 2E 00 00   mov32 cb, $00000000
1315   0C32 00 00 
1316   0C34 B0            cmp a, b
1317   0C35 FD 7F         sgt ; >
1318   0C37 E4            pop a
1319   0C38             ; --- END RELATIONAL
1320   0C38 C0 00 00      cmp b, 0
1321   0C3B C6 6D 0C      je _while38_exit
1322   0C3E             _while38_block:
1323   0C3E             ; i--; 
1324   0C3E FA FA FF      lea d, [bp + -6] ; $i
1325   0C41 2A            mov b, [d]
1326   0C42 38 00 00      mov c, 0
1327   0C45 11            mov a, b
1328   0C46 FD 7D         dec b
1329   0C48 FA FA FF      lea d, [bp + -6] ; $i
1330   0C4B FD 43         mov [d], b
1331   0C4D 27            mov b, a
1332   0C4E             ; putchar(digits[i]); 
1333   0C4E             ; --- START FUNCTION CALL
1334   0C4E FA FC FF      lea d, [bp + -4] ; $digits
1335   0C51 D7            push a
1336   0C52 DA            push d
1337   0C53 FA FA FF      lea d, [bp + -6] ; $i
1338   0C56 2A            mov b, [d]
1339   0C57 38 00 00      mov c, 0
1340   0C5A E7            pop d
1341   0C5B 5A            add d, b
1342   0C5C E4            pop a
1343   0C5D 32            mov bl, [d]
1344   0C5E A7 00         mov bh, 0
1345   0C60 38 00 00      mov c, 0
1346   0C63 DD            push bl
1347   0C64 07 4E 09      call putchar
1348   0C67 51 01 00      add sp, 1
1349   0C6A             ; --- END FUNCTION CALL
1350   0C6A 0A 25 0C      jmp _while38_cond
1351   0C6D             _while38_exit:
1352   0C6D F9            leave
1353   0C6E 09            ret
1354   0C6F             
1355   0C6F             print_unsigned:
1356   0C6F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1357   0C72             ; char digits[5]; 
1358   0C72 52 05 00      sub sp, 5
1359   0C75             ; int i; 
1360   0C75 52 02 00      sub sp, 2
1361   0C78             ; i = 0; 
1362   0C78 FA FA FF      lea d, [bp + -6] ; $i
1363   0C7B DA            push d
1364   0C7C FD 2E 00 00   mov32 cb, $00000000
1364   0C80 00 00 
1365   0C82 E7            pop d
1366   0C83 FD 43         mov [d], b
1367   0C85             ; if(num == 0){ 
1368   0C85             _if39_cond:
1369   0C85 FA 05 00      lea d, [bp + 5] ; $num
1370   0C88 2A            mov b, [d]
1371   0C89 38 00 00      mov c, 0
1372   0C8C             ; --- START RELATIONAL
1373   0C8C D7            push a
1374   0C8D 11            mov a, b
1375   0C8E FD 2E 00 00   mov32 cb, $00000000
1375   0C92 00 00 
1376   0C94 B0            cmp a, b
1377   0C95 FD 71         seq ; ==
1378   0C97 E4            pop a
1379   0C98             ; --- END RELATIONAL
1380   0C98 C0 00 00      cmp b, 0
1381   0C9B C6 B0 0C      je _if39_exit
1382   0C9E             _if39_TRUE:
1383   0C9E             ; putchar('0'); 
1384   0C9E             ; --- START FUNCTION CALL
1385   0C9E FD 2E 30 00   mov32 cb, $00000030
1385   0CA2 00 00 
1386   0CA4 DD            push bl
1387   0CA5 07 4E 09      call putchar
1388   0CA8 51 01 00      add sp, 1
1389   0CAB             ; --- END FUNCTION CALL
1390   0CAB             ; return; 
1391   0CAB F9            leave
1392   0CAC 09            ret
1393   0CAD 0A B0 0C      jmp _if39_exit
1394   0CB0             _if39_exit:
1395   0CB0             ; while (num > 0) { 
1396   0CB0             _while40_cond:
1397   0CB0 FA 05 00      lea d, [bp + 5] ; $num
1398   0CB3 2A            mov b, [d]
1399   0CB4 38 00 00      mov c, 0
1400   0CB7             ; --- START RELATIONAL
1401   0CB7 D7            push a
1402   0CB8 11            mov a, b
1403   0CB9 FD 2E 00 00   mov32 cb, $00000000
1403   0CBD 00 00 
1404   0CBF B0            cmp a, b
1405   0CC0 FD 81         sgu ; > (unsigned)
1406   0CC2 E4            pop a
1407   0CC3             ; --- END RELATIONAL
1408   0CC3 C0 00 00      cmp b, 0
1409   0CC6 C6 3D 0D      je _while40_exit
1410   0CC9             _while40_block:
1411   0CC9             ; digits[i] = '0' + (num % 10); 
1412   0CC9 FA FC FF      lea d, [bp + -4] ; $digits
1413   0CCC D7            push a
1414   0CCD DA            push d
1415   0CCE FA FA FF      lea d, [bp + -6] ; $i
1416   0CD1 2A            mov b, [d]
1417   0CD2 38 00 00      mov c, 0
1418   0CD5 E7            pop d
1419   0CD6 5A            add d, b
1420   0CD7 E4            pop a
1421   0CD8 DA            push d
1422   0CD9 FD 2E 30 00   mov32 cb, $00000030
1422   0CDD 00 00 
1423   0CDF             ; --- START TERMS
1424   0CDF D7            push a
1425   0CE0 11            mov a, b
1426   0CE1 FA 05 00      lea d, [bp + 5] ; $num
1427   0CE4 2A            mov b, [d]
1428   0CE5 38 00 00      mov c, 0
1429   0CE8             ; --- START FACTORS
1430   0CE8 D7            push a
1431   0CE9 FD D8         push g
1432   0CEB 11            mov a, b
1433   0CEC FD 7A         mov g, c
1434   0CEE FD 2E 0A 00   mov32 cb, $0000000a
1434   0CF2 00 00 
1435   0CF4 FD D8         push g ; save 'g' as the div instruction uses it
1436   0CF6 AE            div a, b ; %, a: quotient, b: remainder
1437   0CF7 11            mov a, b
1438   0CF8 FD F1         pop g
1439   0CFA FD 38         mov c, g
1440   0CFC 27            mov b, a
1441   0CFD FD F1         pop g
1442   0CFF E4            pop a
1443   0D00             ; --- END FACTORS
1444   0D00 56            add b, a
1445   0D01 E4            pop a
1446   0D02             ; --- END TERMS
1447   0D02 E7            pop d
1448   0D03 FD 3E         mov [d], bl
1449   0D05             ; num = num / 10; 
1450   0D05 FA 05 00      lea d, [bp + 5] ; $num
1451   0D08 DA            push d
1452   0D09 FA 05 00      lea d, [bp + 5] ; $num
1453   0D0C 2A            mov b, [d]
1454   0D0D 38 00 00      mov c, 0
1455   0D10             ; --- START FACTORS
1456   0D10 D7            push a
1457   0D11 FD D8         push g
1458   0D13 11            mov a, b
1459   0D14 FD 7A         mov g, c
1460   0D16 FD 2E 0A 00   mov32 cb, $0000000a
1460   0D1A 00 00 
1461   0D1C FD D8         push g ; save 'g' as the div instruction uses it
1462   0D1E AE            div a, b ; /, a: quotient, b: remainder
1463   0D1F FD F1         pop g
1464   0D21 FD 38         mov c, g
1465   0D23 27            mov b, a
1466   0D24 FD F1         pop g
1467   0D26 E4            pop a
1468   0D27             ; --- END FACTORS
1469   0D27 E7            pop d
1470   0D28 FD 43         mov [d], b
1471   0D2A             ; i++; 
1472   0D2A FA FA FF      lea d, [bp + -6] ; $i
1473   0D2D 2A            mov b, [d]
1474   0D2E 38 00 00      mov c, 0
1475   0D31 11            mov a, b
1476   0D32 FD 77         inc b
1477   0D34 FA FA FF      lea d, [bp + -6] ; $i
1478   0D37 FD 43         mov [d], b
1479   0D39 27            mov b, a
1480   0D3A 0A B0 0C      jmp _while40_cond
1481   0D3D             _while40_exit:
1482   0D3D             ; while (i > 0) { 
1483   0D3D             _while47_cond:
1484   0D3D FA FA FF      lea d, [bp + -6] ; $i
1485   0D40 2A            mov b, [d]
1486   0D41 38 00 00      mov c, 0
1487   0D44             ; --- START RELATIONAL
1488   0D44 D7            push a
1489   0D45 11            mov a, b
1490   0D46 FD 2E 00 00   mov32 cb, $00000000
1490   0D4A 00 00 
1491   0D4C B0            cmp a, b
1492   0D4D FD 7F         sgt ; >
1493   0D4F E4            pop a
1494   0D50             ; --- END RELATIONAL
1495   0D50 C0 00 00      cmp b, 0
1496   0D53 C6 85 0D      je _while47_exit
1497   0D56             _while47_block:
1498   0D56             ; i--; 
1499   0D56 FA FA FF      lea d, [bp + -6] ; $i
1500   0D59 2A            mov b, [d]
1501   0D5A 38 00 00      mov c, 0
1502   0D5D 11            mov a, b
1503   0D5E FD 7D         dec b
1504   0D60 FA FA FF      lea d, [bp + -6] ; $i
1505   0D63 FD 43         mov [d], b
1506   0D65 27            mov b, a
1507   0D66             ; putchar(digits[i]); 
1508   0D66             ; --- START FUNCTION CALL
1509   0D66 FA FC FF      lea d, [bp + -4] ; $digits
1510   0D69 D7            push a
1511   0D6A DA            push d
1512   0D6B FA FA FF      lea d, [bp + -6] ; $i
1513   0D6E 2A            mov b, [d]
1514   0D6F 38 00 00      mov c, 0
1515   0D72 E7            pop d
1516   0D73 5A            add d, b
1517   0D74 E4            pop a
1518   0D75 32            mov bl, [d]
1519   0D76 A7 00         mov bh, 0
1520   0D78 38 00 00      mov c, 0
1521   0D7B DD            push bl
1522   0D7C 07 4E 09      call putchar
1523   0D7F 51 01 00      add sp, 1
1524   0D82             ; --- END FUNCTION CALL
1525   0D82 0A 3D 0D      jmp _while47_cond
1526   0D85             _while47_exit:
1527   0D85 F9            leave
1528   0D86 09            ret
1529   0D87             
1530   0D87             printx16:
1531   0D87 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1532   0D8A             ; --- BEGIN INLINE ASM SEGMENT
1533   0D8A FA 05 00      lea d, [bp + 5] ; $hex
1534   0D8D 2A            mov b, [d]
1535   0D8E             print_u16x_printx16:
1536   0D8E DD            push bl
1537   0D8F 30            mov bl, bh
1538   0D90 07 AD 0D      call _itoa_printx16        ; convert bh to char in A
1539   0D93 2F            mov bl, al        ; save al
1540   0D94 19 00         mov al, 0
1541   0D96 05 03         syscall sys_io        ; display AH
1542   0D98 24            mov ah, bl        ; retrieve al
1543   0D99 19 00         mov al, 0
1544   0D9B 05 03         syscall sys_io        ; display AL
1545   0D9D EA            pop bl
1546   0D9E 07 AD 0D      call _itoa_printx16        ; convert bh to char in A
1547   0DA1 2F            mov bl, al        ; save al
1548   0DA2 19 00         mov al, 0
1549   0DA4 05 03         syscall sys_io        ; display AH
1550   0DA6 24            mov ah, bl        ; retrieve al
1551   0DA7 19 00         mov al, 0
1552   0DA9 05 03         syscall sys_io        ; display AL
1553   0DAB             ; --- END INLINE ASM SEGMENT
1554   0DAB             ; return; 
1555   0DAB F9            leave
1556   0DAC 09            ret
1557   0DAD             ; --- BEGIN INLINE ASM SEGMENT
1558   0DAD             _itoa_printx16:
1559   0DAD DA            push d
1560   0DAE D8            push b
1561   0DAF A7 00         mov bh, 0
1562   0DB1 FD A4 04      shr bl, 4  
1563   0DB4 74            mov d, b
1564   0DB5 1F C7 0D      mov al, [d + s_hex_digits_printx16]
1565   0DB8 23            mov ah, al
1566   0DB9 E5            pop b
1567   0DBA D8            push b
1568   0DBB A7 00         mov bh, 0
1569   0DBD FD 87 0F      and bl, $0F
1570   0DC0 74            mov d, b
1571   0DC1 1F C7 0D      mov al, [d + s_hex_digits_printx16]
1572   0DC4 E5            pop b
1573   0DC5 E7            pop d
1574   0DC6 09            ret
1575   0DC7 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1575   0DCB 34 35 36 37 
1575   0DCF 38 39 41 42 
1575   0DD3 43 44 45 46 
1576   0DD7             ; --- END INLINE ASM SEGMENT
1577   0DD7 F9            leave
1578   0DD8 09            ret
1579   0DD9             ; --- END TEXT SEGMENT
1580   0DD9             
1581   0DD9             ; --- BEGIN DATA SEGMENT
1582   0DD9 00 00 00 00 _arg_data: .fill 512, 0
1582   0DDD 00 00 00 00 
1582   0DE1 00 00 00 00 
1582   0DE5 00 00 00 00 
1582   0DE9 00 00 00 00 
1582   0DED 00 00 00 00 
1582   0DF1 00 00 00 00 
1582   0DF5 00 00 00 00 
1582   0DF9 00 00 00 00 
1582   0DFD 00 00 00 00 
1582   0E01 00 00 00 00 
1582   0E05 00 00 00 00 
1582   0E09 00 00 00 00 
1582   0E0D 00 00 00 00 
1582   0E11 00 00 00 00 
1582   0E15 00 00 00 00 
1582   0E19 00 00 00 00 
1582   0E1D 00 00 00 00 
1582   0E21 00 00 00 00 
1582   0E25 00 00 00 00 
1582   0E29 00 00 00 00 
1582   0E2D 00 00 00 00 
1582   0E31 00 00 00 00 
1582   0E35 00 00 00 00 
1582   0E39 00 00 00 00 
1582   0E3D 00 00 00 00 
1582   0E41 00 00 00 00 
1582   0E45 00 00 00 00 
1582   0E49 00 00 00 00 
1582   0E4D 00 00 00 00 
1582   0E51 00 00 00 00 
1582   0E55 00 00 00 00 
1582   0E59 00 00 00 00 
1582   0E5D 00 00 00 00 
1582   0E61 00 00 00 00 
1582   0E65 00 00 00 00 
1582   0E69 00 00 00 00 
1582   0E6D 00 00 00 00 
1582   0E71 00 00 00 00 
1582   0E75 00 00 00 00 
1582   0E79 00 00 00 00 
1582   0E7D 00 00 00 00 
1582   0E81 00 00 00 00 
1582   0E85 00 00 00 00 
1582   0E89 00 00 00 00 
1582   0E8D 00 00 00 00 
1582   0E91 00 00 00 00 
1582   0E95 00 00 00 00 
1582   0E99 00 00 00 00 
1582   0E9D 00 00 00 00 
1582   0EA1 00 00 00 00 
1582   0EA5 00 00 00 00 
1582   0EA9 00 00 00 00 
1582   0EAD 00 00 00 00 
1582   0EB1 00 00 00 00 
1582   0EB5 00 00 00 00 
1582   0EB9 00 00 00 00 
1582   0EBD 00 00 00 00 
1582   0EC1 00 00 00 00 
1582   0EC5 00 00 00 00 
1582   0EC9 00 00 00 00 
1582   0ECD 00 00 00 00 
1582   0ED1 00 00 00 00 
1582   0ED5 00 00 00 00 
1582   0ED9 00 00 00 00 
1582   0EDD 00 00 00 00 
1582   0EE1 00 00 00 00 
1582   0EE5 00 00 00 00 
1582   0EE9 00 00 00 00 
1582   0EED 00 00 00 00 
1582   0EF1 00 00 00 00 
1582   0EF5 00 00 00 00 
1582   0EF9 00 00 00 00 
1582   0EFD 00 00 00 00 
1582   0F01 00 00 00 00 
1582   0F05 00 00 00 00 
1582   0F09 00 00 00 00 
1582   0F0D 00 00 00 00 
1582   0F11 00 00 00 00 
1582   0F15 00 00 00 00 
1582   0F19 00 00 00 00 
1582   0F1D 00 00 00 00 
1582   0F21 00 00 00 00 
1582   0F25 00 00 00 00 
1582   0F29 00 00 00 00 
1582   0F2D 00 00 00 00 
1582   0F31 00 00 00 00 
1582   0F35 00 00 00 00 
1582   0F39 00 00 00 00 
1582   0F3D 00 00 00 00 
1582   0F41 00 00 00 00 
1582   0F45 00 00 00 00 
1582   0F49 00 00 00 00 
1582   0F4D 00 00 00 00 
1582   0F51 00 00 00 00 
1582   0F55 00 00 00 00 
1582   0F59 00 00 00 00 
1582   0F5D 00 00 00 00 
1582   0F61 00 00 00 00 
1582   0F65 00 00 00 00 
1582   0F69 00 00 00 00 
1582   0F6D 00 00 00 00 
1582   0F71 00 00 00 00 
1582   0F75 00 00 00 00 
1582   0F79 00 00 00 00 
1582   0F7D 00 00 00 00 
1582   0F81 00 00 00 00 
1582   0F85 00 00 00 00 
1582   0F89 00 00 00 00 
1582   0F8D 00 00 00 00 
1582   0F91 00 00 00 00 
1582   0F95 00 00 00 00 
1582   0F99 00 00 00 00 
1582   0F9D 00 00 00 00 
1582   0FA1 00 00 00 00 
1582   0FA5 00 00 00 00 
1582   0FA9 00 00 00 00 
1582   0FAD 00 00 00 00 
1582   0FB1 00 00 00 00 
1582   0FB5 00 00 00 00 
1582   0FB9 00 00 00 00 
1582   0FBD 00 00 00 00 
1582   0FC1 00 00 00 00 
1582   0FC5 00 00 00 00 
1582   0FC9 00 00 00 00 
1582   0FCD 00 00 00 00 
1582   0FD1 00 00 00 00 
1582   0FD5 00 00 00 00 
1583   0FD9 00 00       _tok: .fill 2, 0
1584   0FDB 00 00       _toktype: .fill 2, 0
1585   0FDD 00 00       _prog: .fill 2, 0
1586   0FDF 00 00 00 00 _token_data: .fill 256, 0
1586   0FE3 00 00 00 00 
1586   0FE7 00 00 00 00 
1586   0FEB 00 00 00 00 
1586   0FEF 00 00 00 00 
1586   0FF3 00 00 00 00 
1586   0FF7 00 00 00 00 
1586   0FFB 00 00 00 00 
1586   0FFF 00 00 00 00 
1586   1003 00 00 00 00 
1586   1007 00 00 00 00 
1586   100B 00 00 00 00 
1586   100F 00 00 00 00 
1586   1013 00 00 00 00 
1586   1017 00 00 00 00 
1586   101B 00 00 00 00 
1586   101F 00 00 00 00 
1586   1023 00 00 00 00 
1586   1027 00 00 00 00 
1586   102B 00 00 00 00 
1586   102F 00 00 00 00 
1586   1033 00 00 00 00 
1586   1037 00 00 00 00 
1586   103B 00 00 00 00 
1586   103F 00 00 00 00 
1586   1043 00 00 00 00 
1586   1047 00 00 00 00 
1586   104B 00 00 00 00 
1586   104F 00 00 00 00 
1586   1053 00 00 00 00 
1586   1057 00 00 00 00 
1586   105B 00 00 00 00 
1586   105F 00 00 00 00 
1586   1063 00 00 00 00 
1586   1067 00 00 00 00 
1586   106B 00 00 00 00 
1586   106F 00 00 00 00 
1586   1073 00 00 00 00 
1586   1077 00 00 00 00 
1586   107B 00 00 00 00 
1586   107F 00 00 00 00 
1586   1083 00 00 00 00 
1586   1087 00 00 00 00 
1586   108B 00 00 00 00 
1586   108F 00 00 00 00 
1586   1093 00 00 00 00 
1586   1097 00 00 00 00 
1586   109B 00 00 00 00 
1586   109F 00 00 00 00 
1586   10A3 00 00 00 00 
1586   10A7 00 00 00 00 
1586   10AB 00 00 00 00 
1586   10AF 00 00 00 00 
1586   10B3 00 00 00 00 
1586   10B7 00 00 00 00 
1586   10BB 00 00 00 00 
1586   10BF 00 00 00 00 
1586   10C3 00 00 00 00 
1586   10C7 00 00 00 00 
1586   10CB 00 00 00 00 
1586   10CF 00 00 00 00 
1586   10D3 00 00 00 00 
1586   10D7 00 00 00 00 
1586   10DB 00 00 00 00 
1587   10DF 00 00 00 00 _string_const_data: .fill 256, 0
1587   10E3 00 00 00 00 
1587   10E7 00 00 00 00 
1587   10EB 00 00 00 00 
1587   10EF 00 00 00 00 
1587   10F3 00 00 00 00 
1587   10F7 00 00 00 00 
1587   10FB 00 00 00 00 
1587   10FF 00 00 00 00 
1587   1103 00 00 00 00 
1587   1107 00 00 00 00 
1587   110B 00 00 00 00 
1587   110F 00 00 00 00 
1587   1113 00 00 00 00 
1587   1117 00 00 00 00 
1587   111B 00 00 00 00 
1587   111F 00 00 00 00 
1587   1123 00 00 00 00 
1587   1127 00 00 00 00 
1587   112B 00 00 00 00 
1587   112F 00 00 00 00 
1587   1133 00 00 00 00 
1587   1137 00 00 00 00 
1587   113B 00 00 00 00 
1587   113F 00 00 00 00 
1587   1143 00 00 00 00 
1587   1147 00 00 00 00 
1587   114B 00 00 00 00 
1587   114F 00 00 00 00 
1587   1153 00 00 00 00 
1587   1157 00 00 00 00 
1587   115B 00 00 00 00 
1587   115F 00 00 00 00 
1587   1163 00 00 00 00 
1587   1167 00 00 00 00 
1587   116B 00 00 00 00 
1587   116F 00 00 00 00 
1587   1173 00 00 00 00 
1587   1177 00 00 00 00 
1587   117B 00 00 00 00 
1587   117F 00 00 00 00 
1587   1183 00 00 00 00 
1587   1187 00 00 00 00 
1587   118B 00 00 00 00 
1587   118F 00 00 00 00 
1587   1193 00 00 00 00 
1587   1197 00 00 00 00 
1587   119B 00 00 00 00 
1587   119F 00 00 00 00 
1587   11A3 00 00 00 00 
1587   11A7 00 00 00 00 
1587   11AB 00 00 00 00 
1587   11AF 00 00 00 00 
1587   11B3 00 00 00 00 
1587   11B7 00 00 00 00 
1587   11BB 00 00 00 00 
1587   11BF 00 00 00 00 
1587   11C3 00 00 00 00 
1587   11C7 00 00 00 00 
1587   11CB 00 00 00 00 
1587   11CF 00 00 00 00 
1587   11D3 00 00 00 00 
1587   11D7 00 00 00 00 
1587   11DB 00 00 00 00 
1588   11DF 3E 20 00    _s0: .db "> ", 0
1589   11E2 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1589   11E6 70 65 63 74 
1589   11EA 65 64 20 66 
1589   11EE 6F 72 6D 61 
1589   11F2 74 20 69 6E 
1589   11F6 20 70 72 69 
1589   11FA 6E 74 66 2E 
1589   11FE 00 
1590   11FF 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1590   1203 72 3A 20 55 
1590   1207 6E 6B 6E 6F 
1590   120B 77 6E 20 61 
1590   120F 72 67 75 6D 
1590   1213 65 6E 74 20 
1590   1217 74 79 70 65 
1590   121B 2E 0A 00 
1591   121E             
1592   121E 20 12       _heap_top: .dw _heap
1593   1220 00          _heap: .db 0
1594   1221             ; --- END DATA SEGMENT
1595   1221             
1596   1221             .end
tasm: Number of errors = 0
