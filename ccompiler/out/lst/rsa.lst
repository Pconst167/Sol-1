0001   0000             ; --- FILENAME: programs/rsa
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $p 
0011   0408             ; $q 
0012   0408             ; $n 
0013   0408             ; $phi 
0014   0408             ; $e 
0015   0408             ; $d 
0016   0408             ; $input_str 
0017   0408             ; $encrypted_chars 
0018   0408             ; $encrypted_chars_len 
0019   0408             ; $i 
0020   0408             ; $decrypted_char 
0021   0408             ; $c 
0022   0408 52 3F 01      sub sp, 319
0023   040B             ;; p = 13; 
0024   040B FA FF FF      lea d, [bp + -1] ; $p
0025   040E DA            push d
0026   040F 26 0D 00      mov b, $d
0027   0412 E7            pop d
0028   0413 FD 43         mov [d], b
0029   0415             ;; q = 11; 
0030   0415 FA FD FF      lea d, [bp + -3] ; $q
0031   0418 DA            push d
0032   0419 26 0B 00      mov b, $b
0033   041C E7            pop d
0034   041D FD 43         mov [d], b
0035   041F             ;; n = p * q; 
0036   041F FA FB FF      lea d, [bp + -5] ; $n
0037   0422 DA            push d
0038   0423 FA FF FF      lea d, [bp + -1] ; $p
0039   0426 2A            mov b, [d]
0040   0427             ; START FACTORS
0041   0427 D7            push a
0042   0428 11            mov a, b
0043   0429 FA FD FF      lea d, [bp + -3] ; $q
0044   042C 2A            mov b, [d]
0045   042D AC            mul a, b ; *
0046   042E 11            mov a, b
0047   042F 27            mov b, a
0048   0430 E4            pop a
0049   0431             ; END FACTORS
0050   0431 E7            pop d
0051   0432 FD 43         mov [d], b
0052   0434             ;; phi = (p - 1) * (q - 1); 
0053   0434 FA F9 FF      lea d, [bp + -7] ; $phi
0054   0437 DA            push d
0055   0438 FA FF FF      lea d, [bp + -1] ; $p
0056   043B 2A            mov b, [d]
0057   043C             ; START TERMS
0058   043C D7            push a
0059   043D 11            mov a, b
0060   043E 26 01 00      mov b, $1
0061   0441 60            sub a, b
0062   0442 27            mov b, a
0063   0443 E4            pop a
0064   0444             ; END TERMS
0065   0444             ; START FACTORS
0066   0444 D7            push a
0067   0445 11            mov a, b
0068   0446 FA FD FF      lea d, [bp + -3] ; $q
0069   0449 2A            mov b, [d]
0070   044A             ; START TERMS
0071   044A D7            push a
0072   044B 11            mov a, b
0073   044C 26 01 00      mov b, $1
0074   044F 60            sub a, b
0075   0450 27            mov b, a
0076   0451 E4            pop a
0077   0452             ; END TERMS
0078   0452 AC            mul a, b ; *
0079   0453 11            mov a, b
0080   0454 27            mov b, a
0081   0455 E4            pop a
0082   0456             ; END FACTORS
0083   0456 E7            pop d
0084   0457 FD 43         mov [d], b
0085   0459             ;; e = find_e(phi); 
0086   0459 FA F7 FF      lea d, [bp + -9] ; $e
0087   045C DA            push d
0088   045D FA F9 FF      lea d, [bp + -7] ; $phi
0089   0460 2A            mov b, [d]
0090   0461 FD AB         swp b
0091   0463 D8            push b
0092   0464 07 7A 14      call find_e
0093   0467 51 02 00      add sp, 2
0094   046A E7            pop d
0095   046B FD 43         mov [d], b
0096   046D             ;; d = find_d(e, phi); 
0097   046D FA F5 FF      lea d, [bp + -11] ; $d
0098   0470 DA            push d
0099   0471 FA F7 FF      lea d, [bp + -9] ; $e
0100   0474 2A            mov b, [d]
0101   0475 FD AB         swp b
0102   0477 D8            push b
0103   0478 FA F9 FF      lea d, [bp + -7] ; $phi
0104   047B 2A            mov b, [d]
0105   047C FD AB         swp b
0106   047E D8            push b
0107   047F 07 E1 14      call find_d
0108   0482 51 04 00      add sp, 4
0109   0485 E7            pop d
0110   0486 FD 43         mov [d], b
0111   0488             ;; print("Public Key: ("); 
0112   0488 26 4C 15      mov b, __s0 ; "Public Key: ("
0113   048B FD AB         swp b
0114   048D D8            push b
0115   048E 07 26 0F      call print
0116   0491 51 02 00      add sp, 2
0117   0494             ;; printu(n); 
0118   0494 FA FB FF      lea d, [bp + -5] ; $n
0119   0497 2A            mov b, [d]
0120   0498 FD AB         swp b
0121   049A D8            push b
0122   049B 07 F2 0D      call printu
0123   049E 51 02 00      add sp, 2
0124   04A1             ;; print(", "); 
0125   04A1 26 5A 15      mov b, __s1 ; ", "
0126   04A4 FD AB         swp b
0127   04A6 D8            push b
0128   04A7 07 26 0F      call print
0129   04AA 51 02 00      add sp, 2
0130   04AD             ;; printu(e); 
0131   04AD FA F7 FF      lea d, [bp + -9] ; $e
0132   04B0 2A            mov b, [d]
0133   04B1 FD AB         swp b
0134   04B3 D8            push b
0135   04B4 07 F2 0D      call printu
0136   04B7 51 02 00      add sp, 2
0137   04BA             ;; print(")\n"); 
0138   04BA 26 5D 15      mov b, __s2 ; ")\n"
0139   04BD FD AB         swp b
0140   04BF D8            push b
0141   04C0 07 26 0F      call print
0142   04C3 51 02 00      add sp, 2
0143   04C6             ;; print("Private Key: ("); 
0144   04C6 26 60 15      mov b, __s3 ; "Private Key: ("
0145   04C9 FD AB         swp b
0146   04CB D8            push b
0147   04CC 07 26 0F      call print
0148   04CF 51 02 00      add sp, 2
0149   04D2             ;; printu(n); 
0150   04D2 FA FB FF      lea d, [bp + -5] ; $n
0151   04D5 2A            mov b, [d]
0152   04D6 FD AB         swp b
0153   04D8 D8            push b
0154   04D9 07 F2 0D      call printu
0155   04DC 51 02 00      add sp, 2
0156   04DF             ;; print(", "); 
0157   04DF 26 5A 15      mov b, __s1 ; ", "
0158   04E2 FD AB         swp b
0159   04E4 D8            push b
0160   04E5 07 26 0F      call print
0161   04E8 51 02 00      add sp, 2
0162   04EB             ;; printu(d); 
0163   04EB FA F5 FF      lea d, [bp + -11] ; $d
0164   04EE 2A            mov b, [d]
0165   04EF FD AB         swp b
0166   04F1 D8            push b
0167   04F2 07 F2 0D      call printu
0168   04F5 51 02 00      add sp, 2
0169   04F8             ;; print(")\n"); 
0170   04F8 26 5D 15      mov b, __s2 ; ")\n"
0171   04FB FD AB         swp b
0172   04FD D8            push b
0173   04FE 07 26 0F      call print
0174   0501 51 02 00      add sp, 2
0175   0504             ;; print("Enter a string: "); 
0176   0504 26 6F 15      mov b, __s4 ; "Enter a string: "
0177   0507 FD AB         swp b
0178   0509 D8            push b
0179   050A 07 26 0F      call print
0180   050D 51 02 00      add sp, 2
0181   0510             ;; gets(input_str); 
0182   0510 FA 91 FF      lea d, [bp + -111] ; $input_str
0183   0513 2D            mov b, d
0184   0514 FD AB         swp b
0185   0516 D8            push b
0186   0517 07 E3 0C      call gets
0187   051A 51 02 00      add sp, 2
0188   051D             ;; encrypted_chars_len = 0; 
0189   051D FA C7 FE      lea d, [bp + -313] ; $encrypted_chars_len
0190   0520 DA            push d
0191   0521 26 00 00      mov b, $0
0192   0524 E7            pop d
0193   0525 FD 43         mov [d], b
0194   0527             ;; print("Encrypted text: "); 
0195   0527 26 80 15      mov b, __s5 ; "Encrypted text: "
0196   052A FD AB         swp b
0197   052C D8            push b
0198   052D 07 26 0F      call print
0199   0530 51 02 00      add sp, 2
0200   0533             ;; for (i = 0; input_str[i] != '\0' && input_str[i] != '\n'; i++) { 
0201   0533             _for1_init:
0202   0533 FA C5 FE      lea d, [bp + -315] ; $i
0203   0536 DA            push d
0204   0537 26 00 00      mov b, $0
0205   053A E7            pop d
0206   053B FD 43         mov [d], b
0207   053D             _for1_cond:
0208   053D FA 91 FF      lea d, [bp + -111] ; $input_str
0209   0540 D7            push a
0210   0541 DA            push d
0211   0542 FA C5 FE      lea d, [bp + -315] ; $i
0212   0545 2A            mov b, [d]
0213   0546 E7            pop d
0214   0547 5A            add d, b
0215   0548 E4            pop a
0216   0549 32            mov bl, [d]
0217   054A A7 00         mov bh, 0
0218   054C             ; START RELATIONAL
0219   054C D7            push a
0220   054D 11            mov a, b
0221   054E 26 00 00      mov b, $0
0222   0551 B0            cmp a, b
0223   0552 FD 72         sneq ; !=
0224   0554 E4            pop a
0225   0555             ; END RELATIONAL
0226   0555 D7            push a
0227   0556 11            mov a, b
0228   0557 FA 91 FF      lea d, [bp + -111] ; $input_str
0229   055A D7            push a
0230   055B DA            push d
0231   055C FA C5 FE      lea d, [bp + -315] ; $i
0232   055F 2A            mov b, [d]
0233   0560 E7            pop d
0234   0561 5A            add d, b
0235   0562 E4            pop a
0236   0563 32            mov bl, [d]
0237   0564 A7 00         mov bh, 0
0238   0566             ; START RELATIONAL
0239   0566 D7            push a
0240   0567 11            mov a, b
0241   0568 26 0A 00      mov b, $a
0242   056B B0            cmp a, b
0243   056C FD 72         sneq ; !=
0244   056E E4            pop a
0245   056F             ; END RELATIONAL
0246   056F FD A7         sand a, b ; &&
0247   0571 E4            pop a
0248   0572 C0 00 00      cmp b, 0
0249   0575 C6 F7 05      je _for1_exit
0250   0578             _for1_block:
0251   0578             ;; encrypted_chars[i] = mod_exp(input_str[i], e, n); 
0252   0578 FA C9 FE      lea d, [bp + -311] ; $encrypted_chars
0253   057B D7            push a
0254   057C DA            push d
0255   057D FA C5 FE      lea d, [bp + -315] ; $i
0256   0580 2A            mov b, [d]
0257   0581 E7            pop d
0258   0582 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0259   0586 E4            pop a
0260   0587 DA            push d
0261   0588 FA 91 FF      lea d, [bp + -111] ; $input_str
0262   058B D7            push a
0263   058C DA            push d
0264   058D FA C5 FE      lea d, [bp + -315] ; $i
0265   0590 2A            mov b, [d]
0266   0591 E7            pop d
0267   0592 5A            add d, b
0268   0593 E4            pop a
0269   0594 32            mov bl, [d]
0270   0595 A7 00         mov bh, 0
0271   0597 FD AB         swp b
0272   0599 D8            push b
0273   059A FA F7 FF      lea d, [bp + -9] ; $e
0274   059D 2A            mov b, [d]
0275   059E FD AB         swp b
0276   05A0 D8            push b
0277   05A1 FA FB FF      lea d, [bp + -5] ; $n
0278   05A4 2A            mov b, [d]
0279   05A5 FD AB         swp b
0280   05A7 D8            push b
0281   05A8 07 E6 13      call mod_exp
0282   05AB 51 06 00      add sp, 6
0283   05AE E7            pop d
0284   05AF FD 43         mov [d], b
0285   05B1             ;; printu(encrypted_chars[i]); 
0286   05B1 FA C9 FE      lea d, [bp + -311] ; $encrypted_chars
0287   05B4 D7            push a
0288   05B5 DA            push d
0289   05B6 FA C5 FE      lea d, [bp + -315] ; $i
0290   05B9 2A            mov b, [d]
0291   05BA E7            pop d
0292   05BB FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0293   05BF E4            pop a
0294   05C0 2A            mov b, [d]
0295   05C1 FD AB         swp b
0296   05C3 D8            push b
0297   05C4 07 F2 0D      call printu
0298   05C7 51 02 00      add sp, 2
0299   05CA             ;; print(" "); 
0300   05CA 26 91 15      mov b, __s6 ; " "
0301   05CD FD AB         swp b
0302   05CF D8            push b
0303   05D0 07 26 0F      call print
0304   05D3 51 02 00      add sp, 2
0305   05D6             ;; encrypted_chars_len++; 
0306   05D6 FA C7 FE      lea d, [bp + -313] ; $encrypted_chars_len
0307   05D9 2A            mov b, [d]
0308   05DA FD 79         mov g, b
0309   05DC FD 77         inc b
0310   05DE FA C7 FE      lea d, [bp + -313] ; $encrypted_chars_len
0311   05E1 FD 43         mov [d], b
0312   05E3 FD 27         mov b, g
0313   05E5             _for1_update:
0314   05E5 FA C5 FE      lea d, [bp + -315] ; $i
0315   05E8 2A            mov b, [d]
0316   05E9 FD 79         mov g, b
0317   05EB FD 77         inc b
0318   05ED FA C5 FE      lea d, [bp + -315] ; $i
0319   05F0 FD 43         mov [d], b
0320   05F2 FD 27         mov b, g
0321   05F4 0A 3D 05      jmp _for1_cond
0322   05F7             _for1_exit:
0323   05F7             ;; print("\n"); 
0324   05F7 26 93 15      mov b, __s7 ; "\n"
0325   05FA FD AB         swp b
0326   05FC D8            push b
0327   05FD 07 26 0F      call print
0328   0600 51 02 00      add sp, 2
0329   0603             ;; print("Decrypted text: "); 
0330   0603 26 95 15      mov b, __s8 ; "Decrypted text: "
0331   0606 FD AB         swp b
0332   0608 D8            push b
0333   0609 07 26 0F      call print
0334   060C 51 02 00      add sp, 2
0335   060F             ;; for (i = 0; i < encrypted_chars_len; i++) { 
0336   060F             _for2_init:
0337   060F FA C5 FE      lea d, [bp + -315] ; $i
0338   0612 DA            push d
0339   0613 26 00 00      mov b, $0
0340   0616 E7            pop d
0341   0617 FD 43         mov [d], b
0342   0619             _for2_cond:
0343   0619 FA C5 FE      lea d, [bp + -315] ; $i
0344   061C 2A            mov b, [d]
0345   061D             ; START RELATIONAL
0346   061D D7            push a
0347   061E 11            mov a, b
0348   061F FA C7 FE      lea d, [bp + -313] ; $encrypted_chars_len
0349   0622 2A            mov b, [d]
0350   0623 B0            cmp a, b
0351   0624 FD 73         slt ; < 
0352   0626 E4            pop a
0353   0627             ; END RELATIONAL
0354   0627 C0 00 00      cmp b, 0
0355   062A C6 85 06      je _for2_exit
0356   062D             _for2_block:
0357   062D             ;; decrypted_char = mod_exp(encrypted_chars[i], d, n); 
0358   062D FA C3 FE      lea d, [bp + -317] ; $decrypted_char
0359   0630 DA            push d
0360   0631 FA C9 FE      lea d, [bp + -311] ; $encrypted_chars
0361   0634 D7            push a
0362   0635 DA            push d
0363   0636 FA C5 FE      lea d, [bp + -315] ; $i
0364   0639 2A            mov b, [d]
0365   063A E7            pop d
0366   063B FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0367   063F E4            pop a
0368   0640 2A            mov b, [d]
0369   0641 FD AB         swp b
0370   0643 D8            push b
0371   0644 FA F5 FF      lea d, [bp + -11] ; $d
0372   0647 2A            mov b, [d]
0373   0648 FD AB         swp b
0374   064A D8            push b
0375   064B FA FB FF      lea d, [bp + -5] ; $n
0376   064E 2A            mov b, [d]
0377   064F FD AB         swp b
0378   0651 D8            push b
0379   0652 07 E6 13      call mod_exp
0380   0655 51 06 00      add sp, 6
0381   0658 E7            pop d
0382   0659 FD 43         mov [d], b
0383   065B             ;; c = decrypted_char; 
0384   065B FA C2 FE      lea d, [bp + -318] ; $c
0385   065E DA            push d
0386   065F FA C3 FE      lea d, [bp + -317] ; $decrypted_char
0387   0662 2A            mov b, [d]
0388   0663 E7            pop d
0389   0664 FD 3E         mov [d], bl
0390   0666             ;; putchar(c); 
0391   0666 FA C2 FE      lea d, [bp + -318] ; $c
0392   0669 32            mov bl, [d]
0393   066A A7 00         mov bh, 0
0394   066C DD            push bl
0395   066D 07 DE 0E      call putchar
0396   0670 51 01 00      add sp, 1
0397   0673             _for2_update:
0398   0673 FA C5 FE      lea d, [bp + -315] ; $i
0399   0676 2A            mov b, [d]
0400   0677 FD 79         mov g, b
0401   0679 FD 77         inc b
0402   067B FA C5 FE      lea d, [bp + -315] ; $i
0403   067E FD 43         mov [d], b
0404   0680 FD 27         mov b, g
0405   0682 0A 19 06      jmp _for2_cond
0406   0685             _for2_exit:
0407   0685             ;; print("\n"); 
0408   0685 26 93 15      mov b, __s7 ; "\n"
0409   0688 FD AB         swp b
0410   068A D8            push b
0411   068B 07 26 0F      call print
0412   068E 51 02 00      add sp, 2
0413   0691             ;; return 0; 
0414   0691 26 00 00      mov b, $0
0415   0694 F9            leave
0416   0695 05 0B         syscall sys_terminate_proc
0417   0697             
0418   0697             strcpy:
0419   0697 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0420   069A             ; $psrc 
0421   069A             ; $pdest 
0422   069A 52 04 00      sub sp, 4
0423   069D             ;; psrc = src; 
0424   069D FA FF FF      lea d, [bp + -1] ; $psrc
0425   06A0 DA            push d
0426   06A1 FA 05 00      lea d, [bp + 5] ; $src
0427   06A4 2A            mov b, [d]
0428   06A5 E7            pop d
0429   06A6 FD 43         mov [d], b
0430   06A8             ;; pdest = dest; 
0431   06A8 FA FD FF      lea d, [bp + -3] ; $pdest
0432   06AB DA            push d
0433   06AC FA 07 00      lea d, [bp + 7] ; $dest
0434   06AF 2A            mov b, [d]
0435   06B0 E7            pop d
0436   06B1 FD 43         mov [d], b
0437   06B3             ;; while(*psrc) *pdest++ = *psrc++; 
0438   06B3             _while3_cond:
0439   06B3 FA FF FF      lea d, [bp + -1] ; $psrc
0440   06B6 2A            mov b, [d]
0441   06B7 74            mov d, b
0442   06B8 32            mov bl, [d]
0443   06B9 A7 00         mov bh, 0
0444   06BB C0 00 00      cmp b, 0
0445   06BE C6 EA 06      je _while3_exit
0446   06C1             _while3_block:
0447   06C1             ;; *pdest++ = *psrc++; 
0448   06C1 FA FD FF      lea d, [bp + -3] ; $pdest
0449   06C4 2A            mov b, [d]
0450   06C5 FD 79         mov g, b
0451   06C7 FD 77         inc b
0452   06C9 FA FD FF      lea d, [bp + -3] ; $pdest
0453   06CC FD 43         mov [d], b
0454   06CE FD 27         mov b, g
0455   06D0 D8            push b
0456   06D1 FA FF FF      lea d, [bp + -1] ; $psrc
0457   06D4 2A            mov b, [d]
0458   06D5 FD 79         mov g, b
0459   06D7 FD 77         inc b
0460   06D9 FA FF FF      lea d, [bp + -1] ; $psrc
0461   06DC FD 43         mov [d], b
0462   06DE FD 27         mov b, g
0463   06E0 74            mov d, b
0464   06E1 32            mov bl, [d]
0465   06E2 A7 00         mov bh, 0
0466   06E4 E7            pop d
0467   06E5 FD 3E         mov [d], bl
0468   06E7 0A B3 06      jmp _while3_cond
0469   06EA             _while3_exit:
0470   06EA             ;; *pdest = '\0'; 
0471   06EA FA FD FF      lea d, [bp + -3] ; $pdest
0472   06ED 2A            mov b, [d]
0473   06EE D8            push b
0474   06EF 26 00 00      mov b, $0
0475   06F2 E7            pop d
0476   06F3 FD 3E         mov [d], bl
0477   06F5 F9            leave
0478   06F6 09            ret
0479   06F7             
0480   06F7             strcmp:
0481   06F7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0482   06FA             ;; while (*s1 && (*s1 == *s2)) { 
0483   06FA             _while4_cond:
0484   06FA FA 07 00      lea d, [bp + 7] ; $s1
0485   06FD 2A            mov b, [d]
0486   06FE 74            mov d, b
0487   06FF 32            mov bl, [d]
0488   0700 A7 00         mov bh, 0
0489   0702 D7            push a
0490   0703 11            mov a, b
0491   0704 FA 07 00      lea d, [bp + 7] ; $s1
0492   0707 2A            mov b, [d]
0493   0708 74            mov d, b
0494   0709 32            mov bl, [d]
0495   070A A7 00         mov bh, 0
0496   070C             ; START RELATIONAL
0497   070C D7            push a
0498   070D 11            mov a, b
0499   070E FA 05 00      lea d, [bp + 5] ; $s2
0500   0711 2A            mov b, [d]
0501   0712 74            mov d, b
0502   0713 32            mov bl, [d]
0503   0714 A7 00         mov bh, 0
0504   0716 B0            cmp a, b
0505   0717 FD 71         seq ; ==
0506   0719 E4            pop a
0507   071A             ; END RELATIONAL
0508   071A FD A7         sand a, b ; &&
0509   071C E4            pop a
0510   071D C0 00 00      cmp b, 0
0511   0720 C6 44 07      je _while4_exit
0512   0723             _while4_block:
0513   0723             ;; s1++; 
0514   0723 FA 07 00      lea d, [bp + 7] ; $s1
0515   0726 2A            mov b, [d]
0516   0727 FD 79         mov g, b
0517   0729 FD 77         inc b
0518   072B FA 07 00      lea d, [bp + 7] ; $s1
0519   072E FD 43         mov [d], b
0520   0730 FD 27         mov b, g
0521   0732             ;; s2++; 
0522   0732 FA 05 00      lea d, [bp + 5] ; $s2
0523   0735 2A            mov b, [d]
0524   0736 FD 79         mov g, b
0525   0738 FD 77         inc b
0526   073A FA 05 00      lea d, [bp + 5] ; $s2
0527   073D FD 43         mov [d], b
0528   073F FD 27         mov b, g
0529   0741 0A FA 06      jmp _while4_cond
0530   0744             _while4_exit:
0531   0744             ;; return *s1 - *s2; 
0532   0744 FA 07 00      lea d, [bp + 7] ; $s1
0533   0747 2A            mov b, [d]
0534   0748 74            mov d, b
0535   0749 32            mov bl, [d]
0536   074A A7 00         mov bh, 0
0537   074C             ; START TERMS
0538   074C D7            push a
0539   074D 11            mov a, b
0540   074E FA 05 00      lea d, [bp + 5] ; $s2
0541   0751 2A            mov b, [d]
0542   0752 74            mov d, b
0543   0753 32            mov bl, [d]
0544   0754 A7 00         mov bh, 0
0545   0756 60            sub a, b
0546   0757 27            mov b, a
0547   0758 E4            pop a
0548   0759             ; END TERMS
0549   0759 F9            leave
0550   075A 09            ret
0551   075B             
0552   075B             strcat:
0553   075B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0554   075E             ; $dest_len 
0555   075E             ; $i 
0556   075E 52 04 00      sub sp, 4
0557   0761             ;; dest_len = strlen(dest); 
0558   0761 FA FF FF      lea d, [bp + -1] ; $dest_len
0559   0764 DA            push d
0560   0765 FA 07 00      lea d, [bp + 7] ; $dest
0561   0768 2A            mov b, [d]
0562   0769 FD AB         swp b
0563   076B D8            push b
0564   076C 07 11 08      call strlen
0565   076F 51 02 00      add sp, 2
0566   0772 E7            pop d
0567   0773 FD 43         mov [d], b
0568   0775             ;; for (i = 0; src[i] != 0; i=i+1) { 
0569   0775             _for5_init:
0570   0775 FA FD FF      lea d, [bp + -3] ; $i
0571   0778 DA            push d
0572   0779 26 00 00      mov b, $0
0573   077C E7            pop d
0574   077D FD 43         mov [d], b
0575   077F             _for5_cond:
0576   077F FA 05 00      lea d, [bp + 5] ; $src
0577   0782 FD 2A         mov d, [d]
0578   0784 D7            push a
0579   0785 DA            push d
0580   0786 FA FD FF      lea d, [bp + -3] ; $i
0581   0789 2A            mov b, [d]
0582   078A E7            pop d
0583   078B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0584   078F E4            pop a
0585   0790 32            mov bl, [d]
0586   0791 A7 00         mov bh, 0
0587   0793             ; START RELATIONAL
0588   0793 D7            push a
0589   0794 11            mov a, b
0590   0795 26 00 00      mov b, $0
0591   0798 B0            cmp a, b
0592   0799 FD 72         sneq ; !=
0593   079B E4            pop a
0594   079C             ; END RELATIONAL
0595   079C C0 00 00      cmp b, 0
0596   079F C6 EA 07      je _for5_exit
0597   07A2             _for5_block:
0598   07A2             ;; dest[dest_len + i] = src[i]; 
0599   07A2 FA 07 00      lea d, [bp + 7] ; $dest
0600   07A5 FD 2A         mov d, [d]
0601   07A7 D7            push a
0602   07A8 DA            push d
0603   07A9 FA FF FF      lea d, [bp + -1] ; $dest_len
0604   07AC 2A            mov b, [d]
0605   07AD             ; START TERMS
0606   07AD D7            push a
0607   07AE 11            mov a, b
0608   07AF FA FD FF      lea d, [bp + -3] ; $i
0609   07B2 2A            mov b, [d]
0610   07B3 54            add a, b
0611   07B4 27            mov b, a
0612   07B5 E4            pop a
0613   07B6             ; END TERMS
0614   07B6 E7            pop d
0615   07B7 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0616   07BB E4            pop a
0617   07BC DA            push d
0618   07BD FA 05 00      lea d, [bp + 5] ; $src
0619   07C0 FD 2A         mov d, [d]
0620   07C2 D7            push a
0621   07C3 DA            push d
0622   07C4 FA FD FF      lea d, [bp + -3] ; $i
0623   07C7 2A            mov b, [d]
0624   07C8 E7            pop d
0625   07C9 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0626   07CD E4            pop a
0627   07CE 32            mov bl, [d]
0628   07CF A7 00         mov bh, 0
0629   07D1 E7            pop d
0630   07D2 FD 3E         mov [d], bl
0631   07D4             _for5_update:
0632   07D4 FA FD FF      lea d, [bp + -3] ; $i
0633   07D7 DA            push d
0634   07D8 FA FD FF      lea d, [bp + -3] ; $i
0635   07DB 2A            mov b, [d]
0636   07DC             ; START TERMS
0637   07DC D7            push a
0638   07DD 11            mov a, b
0639   07DE 26 01 00      mov b, $1
0640   07E1 54            add a, b
0641   07E2 27            mov b, a
0642   07E3 E4            pop a
0643   07E4             ; END TERMS
0644   07E4 E7            pop d
0645   07E5 FD 43         mov [d], b
0646   07E7 0A 7F 07      jmp _for5_cond
0647   07EA             _for5_exit:
0648   07EA             ;; dest[dest_len + i] = 0; 
0649   07EA FA 07 00      lea d, [bp + 7] ; $dest
0650   07ED FD 2A         mov d, [d]
0651   07EF D7            push a
0652   07F0 DA            push d
0653   07F1 FA FF FF      lea d, [bp + -1] ; $dest_len
0654   07F4 2A            mov b, [d]
0655   07F5             ; START TERMS
0656   07F5 D7            push a
0657   07F6 11            mov a, b
0658   07F7 FA FD FF      lea d, [bp + -3] ; $i
0659   07FA 2A            mov b, [d]
0660   07FB 54            add a, b
0661   07FC 27            mov b, a
0662   07FD E4            pop a
0663   07FE             ; END TERMS
0664   07FE E7            pop d
0665   07FF FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0666   0803 E4            pop a
0667   0804 DA            push d
0668   0805 26 00 00      mov b, $0
0669   0808 E7            pop d
0670   0809 FD 3E         mov [d], bl
0671   080B             ;; return dest; 
0672   080B FA 07 00      lea d, [bp + 7] ; $dest
0673   080E 2A            mov b, [d]
0674   080F F9            leave
0675   0810 09            ret
0676   0811             
0677   0811             strlen:
0678   0811 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0679   0814             ; $length 
0680   0814 52 02 00      sub sp, 2
0681   0817             ;; length = 0; 
0682   0817 FA FF FF      lea d, [bp + -1] ; $length
0683   081A DA            push d
0684   081B 26 00 00      mov b, $0
0685   081E E7            pop d
0686   081F FD 43         mov [d], b
0687   0821             ;; while (str[length] != 0) { 
0688   0821             _while6_cond:
0689   0821 FA 05 00      lea d, [bp + 5] ; $str
0690   0824 FD 2A         mov d, [d]
0691   0826 D7            push a
0692   0827 DA            push d
0693   0828 FA FF FF      lea d, [bp + -1] ; $length
0694   082B 2A            mov b, [d]
0695   082C E7            pop d
0696   082D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0697   0831 E4            pop a
0698   0832 32            mov bl, [d]
0699   0833 A7 00         mov bh, 0
0700   0835             ; START RELATIONAL
0701   0835 D7            push a
0702   0836 11            mov a, b
0703   0837 26 00 00      mov b, $0
0704   083A B0            cmp a, b
0705   083B FD 72         sneq ; !=
0706   083D E4            pop a
0707   083E             ; END RELATIONAL
0708   083E C0 00 00      cmp b, 0
0709   0841 C6 56 08      je _while6_exit
0710   0844             _while6_block:
0711   0844             ;; length++; 
0712   0844 FA FF FF      lea d, [bp + -1] ; $length
0713   0847 2A            mov b, [d]
0714   0848 FD 79         mov g, b
0715   084A FD 77         inc b
0716   084C FA FF FF      lea d, [bp + -1] ; $length
0717   084F FD 43         mov [d], b
0718   0851 FD 27         mov b, g
0719   0853 0A 21 08      jmp _while6_cond
0720   0856             _while6_exit:
0721   0856             ;; return length; 
0722   0856 FA FF FF      lea d, [bp + -1] ; $length
0723   0859 2A            mov b, [d]
0724   085A F9            leave
0725   085B 09            ret
0726   085C             
0727   085C             va_arg:
0728   085C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0729   085F             ; $val 
0730   085F 52 02 00      sub sp, 2
0731   0862             ;; if(size == 1){ 
0732   0862             _if7_cond:
0733   0862 FA 05 00      lea d, [bp + 5] ; $size
0734   0865 2A            mov b, [d]
0735   0866             ; START RELATIONAL
0736   0866 D7            push a
0737   0867 11            mov a, b
0738   0868 26 01 00      mov b, $1
0739   086B B0            cmp a, b
0740   086C FD 71         seq ; ==
0741   086E E4            pop a
0742   086F             ; END RELATIONAL
0743   086F C0 00 00      cmp b, 0
0744   0872 C6 8E 08      je _if7_else
0745   0875             _if7_true:
0746   0875             ;; val = *(char*)arg->p; 
0747   0875 FA FF FF      lea d, [bp + -1] ; $val
0748   0878 DA            push d
0749   0879 FA 07 00      lea d, [bp + 7] ; $arg
0750   087C FD 2A         mov d, [d]
0751   087E 58 00 00      add d, 0
0752   0881 FD 14         clb
0753   0883 2A            mov b, [d]
0754   0884 74            mov d, b
0755   0885 32            mov bl, [d]
0756   0886 A7 00         mov bh, 0
0757   0888 E7            pop d
0758   0889 FD 43         mov [d], b
0759   088B 0A C4 08      jmp _if7_exit
0760   088E             _if7_else:
0761   088E             ;; if(size == 2){ 
0762   088E             _if8_cond:
0763   088E FA 05 00      lea d, [bp + 5] ; $size
0764   0891 2A            mov b, [d]
0765   0892             ; START RELATIONAL
0766   0892 D7            push a
0767   0893 11            mov a, b
0768   0894 26 02 00      mov b, $2
0769   0897 B0            cmp a, b
0770   0898 FD 71         seq ; ==
0771   089A E4            pop a
0772   089B             ; END RELATIONAL
0773   089B C0 00 00      cmp b, 0
0774   089E C6 B8 08      je _if8_else
0775   08A1             _if8_true:
0776   08A1             ;; val = *(int*)arg->p; 
0777   08A1 FA FF FF      lea d, [bp + -1] ; $val
0778   08A4 DA            push d
0779   08A5 FA 07 00      lea d, [bp + 7] ; $arg
0780   08A8 FD 2A         mov d, [d]
0781   08AA 58 00 00      add d, 0
0782   08AD FD 14         clb
0783   08AF 2A            mov b, [d]
0784   08B0 74            mov d, b
0785   08B1 2A            mov b, [d]
0786   08B2 E7            pop d
0787   08B3 FD 43         mov [d], b
0788   08B5 0A C4 08      jmp _if8_exit
0789   08B8             _if8_else:
0790   08B8             ;; print("Unknown type size in va_arg() call. Size needs to be either 1 or 2."); 
0791   08B8 26 A6 15      mov b, __s9 ; "Unknown type size in va_arg() call. Size needs to be either 1 or 2."
0792   08BB FD AB         swp b
0793   08BD D8            push b
0794   08BE 07 26 0F      call print
0795   08C1 51 02 00      add sp, 2
0796   08C4             _if8_exit:
0797   08C4             _if7_exit:
0798   08C4             ;; arg->p = arg->p + size; 
0799   08C4 FA 07 00      lea d, [bp + 7] ; $arg
0800   08C7 FD 2A         mov d, [d]
0801   08C9 58 00 00      add d, 0
0802   08CC FD 14         clb
0803   08CE DA            push d
0804   08CF FA 07 00      lea d, [bp + 7] ; $arg
0805   08D2 FD 2A         mov d, [d]
0806   08D4 58 00 00      add d, 0
0807   08D7 FD 14         clb
0808   08D9 2A            mov b, [d]
0809   08DA             ; START TERMS
0810   08DA D7            push a
0811   08DB 11            mov a, b
0812   08DC FA 05 00      lea d, [bp + 5] ; $size
0813   08DF 2A            mov b, [d]
0814   08E0 54            add a, b
0815   08E1 27            mov b, a
0816   08E2 E4            pop a
0817   08E3             ; END TERMS
0818   08E3 E7            pop d
0819   08E4 FD 43         mov [d], b
0820   08E6             ;; return val; 
0821   08E6 FA FF FF      lea d, [bp + -1] ; $val
0822   08E9 2A            mov b, [d]
0823   08EA F9            leave
0824   08EB 09            ret
0825   08EC             
0826   08EC             printf:
0827   08EC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0828   08EF             ; $p 
0829   08EF             ; $fp 
0830   08EF             ; $i 
0831   08EF 52 06 00      sub sp, 6
0832   08F2             ;; fp = format; 
0833   08F2 FA FD FF      lea d, [bp + -3] ; $fp
0834   08F5 DA            push d
0835   08F6 FA 05 00      lea d, [bp + 5] ; $format
0836   08F9 2A            mov b, [d]
0837   08FA E7            pop d
0838   08FB FD 43         mov [d], b
0839   08FD             ;; p = &format; 
0840   08FD FA FF FF      lea d, [bp + -1] ; $p
0841   0900 DA            push d
0842   0901 FA 05 00      lea d, [bp + 5] ; $format
0843   0904 2D            mov b, d
0844   0905 E7            pop d
0845   0906 FD 43         mov [d], b
0846   0908             ;; for(;;){ 
0847   0908             _for9_init:
0848   0908             _for9_cond:
0849   0908             _for9_block:
0850   0908             ;; if(!*fp) break; 
0851   0908             _if10_cond:
0852   0908 FA FD FF      lea d, [bp + -3] ; $fp
0853   090B 2A            mov b, [d]
0854   090C 74            mov d, b
0855   090D 32            mov bl, [d]
0856   090E A7 00         mov bh, 0
0857   0910 C0 00 00      cmp b, 0
0858   0913 FD 71         seq ; !
0859   0915 C0 00 00      cmp b, 0
0860   0918 C6 21 09      je _if10_exit
0861   091B             _if10_true:
0862   091B             ;; break; 
0863   091B 0A 6B 0A      jmp _for9_exit ; for break
0864   091E 0A 21 09      jmp _if10_exit
0865   0921             _if10_exit:
0866   0921             ;; if(*fp == '%'){ 
0867   0921             _if11_cond:
0868   0921 FA FD FF      lea d, [bp + -3] ; $fp
0869   0924 2A            mov b, [d]
0870   0925 74            mov d, b
0871   0926 32            mov bl, [d]
0872   0927 A7 00         mov bh, 0
0873   0929             ; START RELATIONAL
0874   0929 D7            push a
0875   092A 11            mov a, b
0876   092B 26 25 00      mov b, $25
0877   092E B0            cmp a, b
0878   092F FD 71         seq ; ==
0879   0931 E4            pop a
0880   0932             ; END RELATIONAL
0881   0932 C0 00 00      cmp b, 0
0882   0935 C6 4A 0A      je _if11_else
0883   0938             _if11_true:
0884   0938             ;; fp++; 
0885   0938 FA FD FF      lea d, [bp + -3] ; $fp
0886   093B 2A            mov b, [d]
0887   093C FD 79         mov g, b
0888   093E FD 77         inc b
0889   0940 FA FD FF      lea d, [bp + -3] ; $fp
0890   0943 FD 43         mov [d], b
0891   0945 FD 27         mov b, g
0892   0947             ;; switch(*fp){ 
0893   0947             _switch12_expr:
0894   0947 FA FD FF      lea d, [bp + -3] ; $fp
0895   094A 2A            mov b, [d]
0896   094B 74            mov d, b
0897   094C 32            mov bl, [d]
0898   094D A7 00         mov bh, 0
0899   094F             _switch12_comparisons:
0900   094F C1 64         cmp bl, $64
0901   0951 C6 73 09      je _switch12_case0
0902   0954 C1 69         cmp bl, $69
0903   0956 C6 73 09      je _switch12_case1
0904   0959 C1 75         cmp bl, $75
0905   095B C6 98 09      je _switch12_case2
0906   095E C1 78         cmp bl, $78
0907   0960 C6 BD 09      je _switch12_case3
0908   0963 C1 63         cmp bl, $63
0909   0965 C6 E2 09      je _switch12_case4
0910   0968 C1 73         cmp bl, $73
0911   096A C6 07 0A      je _switch12_case5
0912   096D 0A 2C 0A      jmp _switch12_default
0913   0970 0A 38 0A      jmp _switch12_exit
0914   0973             _switch12_case0:
0915   0973             _switch12_case1:
0916   0973             ;; p = p - 2; 
0917   0973 FA FF FF      lea d, [bp + -1] ; $p
0918   0976 DA            push d
0919   0977 FA FF FF      lea d, [bp + -1] ; $p
0920   097A 2A            mov b, [d]
0921   097B             ; START TERMS
0922   097B D7            push a
0923   097C 11            mov a, b
0924   097D 26 02 00      mov b, $2
0925   0980 60            sub a, b
0926   0981 27            mov b, a
0927   0982 E4            pop a
0928   0983             ; END TERMS
0929   0983 E7            pop d
0930   0984 FD 43         mov [d], b
0931   0986             ;; prints(*(int*)p); 
0932   0986 FA FF FF      lea d, [bp + -1] ; $p
0933   0989 2A            mov b, [d]
0934   098A 74            mov d, b
0935   098B 2A            mov b, [d]
0936   098C FD AB         swp b
0937   098E D8            push b
0938   098F 07 FD 0C      call prints
0939   0992 51 02 00      add sp, 2
0940   0995             ;; break; 
0941   0995 0A 38 0A      jmp _switch12_exit ; case break
0942   0998             _switch12_case2:
0943   0998             ;; p = p - 2; 
0944   0998 FA FF FF      lea d, [bp + -1] ; $p
0945   099B DA            push d
0946   099C FA FF FF      lea d, [bp + -1] ; $p
0947   099F 2A            mov b, [d]
0948   09A0             ; START TERMS
0949   09A0 D7            push a
0950   09A1 11            mov a, b
0951   09A2 26 02 00      mov b, $2
0952   09A5 60            sub a, b
0953   09A6 27            mov b, a
0954   09A7 E4            pop a
0955   09A8             ; END TERMS
0956   09A8 E7            pop d
0957   09A9 FD 43         mov [d], b
0958   09AB             ;; printu(*(unsigned int*)p); 
0959   09AB FA FF FF      lea d, [bp + -1] ; $p
0960   09AE 2A            mov b, [d]
0961   09AF 74            mov d, b
0962   09B0 2A            mov b, [d]
0963   09B1 FD AB         swp b
0964   09B3 D8            push b
0965   09B4 07 F2 0D      call printu
0966   09B7 51 02 00      add sp, 2
0967   09BA             ;; break; 
0968   09BA 0A 38 0A      jmp _switch12_exit ; case break
0969   09BD             _switch12_case3:
0970   09BD             ;; p = p - 2; 
0971   09BD FA FF FF      lea d, [bp + -1] ; $p
0972   09C0 DA            push d
0973   09C1 FA FF FF      lea d, [bp + -1] ; $p
0974   09C4 2A            mov b, [d]
0975   09C5             ; START TERMS
0976   09C5 D7            push a
0977   09C6 11            mov a, b
0978   09C7 26 02 00      mov b, $2
0979   09CA 60            sub a, b
0980   09CB 27            mov b, a
0981   09CC E4            pop a
0982   09CD             ; END TERMS
0983   09CD E7            pop d
0984   09CE FD 43         mov [d], b
0985   09D0             ;; printx16(*(unsigned int*)p); 
0986   09D0 FA FF FF      lea d, [bp + -1] ; $p
0987   09D3 2A            mov b, [d]
0988   09D4 74            mov d, b
0989   09D5 2A            mov b, [d]
0990   09D6 FD AB         swp b
0991   09D8 D8            push b
0992   09D9 07 6D 0A      call printx16
0993   09DC 51 02 00      add sp, 2
0994   09DF             ;; break; 
0995   09DF 0A 38 0A      jmp _switch12_exit ; case break
0996   09E2             _switch12_case4:
0997   09E2             ;; p = p - 2; 
0998   09E2 FA FF FF      lea d, [bp + -1] ; $p
0999   09E5 DA            push d
1000   09E6 FA FF FF      lea d, [bp + -1] ; $p
1001   09E9 2A            mov b, [d]
1002   09EA             ; START TERMS
1003   09EA D7            push a
1004   09EB 11            mov a, b
1005   09EC 26 02 00      mov b, $2
1006   09EF 60            sub a, b
1007   09F0 27            mov b, a
1008   09F1 E4            pop a
1009   09F2             ; END TERMS
1010   09F2 E7            pop d
1011   09F3 FD 43         mov [d], b
1012   09F5             ;; putchar(*(char*)p); 
1013   09F5 FA FF FF      lea d, [bp + -1] ; $p
1014   09F8 2A            mov b, [d]
1015   09F9 74            mov d, b
1016   09FA 32            mov bl, [d]
1017   09FB A7 00         mov bh, 0
1018   09FD DD            push bl
1019   09FE 07 DE 0E      call putchar
1020   0A01 51 01 00      add sp, 1
1021   0A04             ;; break; 
1022   0A04 0A 38 0A      jmp _switch12_exit ; case break
1023   0A07             _switch12_case5:
1024   0A07             ;; p = p - 2; 
1025   0A07 FA FF FF      lea d, [bp + -1] ; $p
1026   0A0A DA            push d
1027   0A0B FA FF FF      lea d, [bp + -1] ; $p
1028   0A0E 2A            mov b, [d]
1029   0A0F             ; START TERMS
1030   0A0F D7            push a
1031   0A10 11            mov a, b
1032   0A11 26 02 00      mov b, $2
1033   0A14 60            sub a, b
1034   0A15 27            mov b, a
1035   0A16 E4            pop a
1036   0A17             ; END TERMS
1037   0A17 E7            pop d
1038   0A18 FD 43         mov [d], b
1039   0A1A             ;; print(*(char**)p); 
1040   0A1A FA FF FF      lea d, [bp + -1] ; $p
1041   0A1D 2A            mov b, [d]
1042   0A1E 74            mov d, b
1043   0A1F 2A            mov b, [d]
1044   0A20 FD AB         swp b
1045   0A22 D8            push b
1046   0A23 07 26 0F      call print
1047   0A26 51 02 00      add sp, 2
1048   0A29             ;; break; 
1049   0A29 0A 38 0A      jmp _switch12_exit ; case break
1050   0A2C             _switch12_default:
1051   0A2C             ;; print("Error: Unknown argument type.\n"); 
1052   0A2C 26 EA 15      mov b, __s10 ; "Error: Unknown argument type.\n"
1053   0A2F FD AB         swp b
1054   0A31 D8            push b
1055   0A32 07 26 0F      call print
1056   0A35 51 02 00      add sp, 2
1057   0A38             _switch12_exit:
1058   0A38             ;; fp++; 
1059   0A38 FA FD FF      lea d, [bp + -3] ; $fp
1060   0A3B 2A            mov b, [d]
1061   0A3C FD 79         mov g, b
1062   0A3E FD 77         inc b
1063   0A40 FA FD FF      lea d, [bp + -3] ; $fp
1064   0A43 FD 43         mov [d], b
1065   0A45 FD 27         mov b, g
1066   0A47 0A 68 0A      jmp _if11_exit
1067   0A4A             _if11_else:
1068   0A4A             ;; putchar(*fp); 
1069   0A4A FA FD FF      lea d, [bp + -3] ; $fp
1070   0A4D 2A            mov b, [d]
1071   0A4E 74            mov d, b
1072   0A4F 32            mov bl, [d]
1073   0A50 A7 00         mov bh, 0
1074   0A52 DD            push bl
1075   0A53 07 DE 0E      call putchar
1076   0A56 51 01 00      add sp, 1
1077   0A59             ;; fp++; 
1078   0A59 FA FD FF      lea d, [bp + -3] ; $fp
1079   0A5C 2A            mov b, [d]
1080   0A5D FD 79         mov g, b
1081   0A5F FD 77         inc b
1082   0A61 FA FD FF      lea d, [bp + -3] ; $fp
1083   0A64 FD 43         mov [d], b
1084   0A66 FD 27         mov b, g
1085   0A68             _if11_exit:
1086   0A68             _for9_update:
1087   0A68 0A 08 09      jmp _for9_cond
1088   0A6B             _for9_exit:
1089   0A6B F9            leave
1090   0A6C 09            ret
1091   0A6D             
1092   0A6D             printx16:
1093   0A6D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1094   0A70             
1095   0A70             ; --- BEGIN INLINE ASM BLOCK
1096   0A70 FA 05 00      lea d, [bp + 5] ; $hex
1097   0A73 2A            mov b, [d]
1098   0A74 07 A7 12      call print_u16x
1099   0A77             ; --- END INLINE ASM BLOCK
1100   0A77             
1101   0A77 F9            leave
1102   0A78 09            ret
1103   0A79             
1104   0A79             printx8:
1105   0A79 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1106   0A7C             
1107   0A7C             ; --- BEGIN INLINE ASM BLOCK
1108   0A7C FA 05 00      lea d, [bp + 5] ; $hex
1109   0A7F 32            mov bl, [d]
1110   0A80 07 EB 12      call print_u8x
1111   0A83             ; --- END INLINE ASM BLOCK
1112   0A83             
1113   0A83 F9            leave
1114   0A84 09            ret
1115   0A85             
1116   0A85             hex_to_int:
1117   0A85 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1118   0A88             ; $value 
1119   0A88 10 00 00      mov a, $0
1120   0A8B 45 FF FF      mov [bp + -1], a
1121   0A8E             ; $i 
1122   0A8E             ; $hex_char 
1123   0A8E             ; $len 
1124   0A8E 52 07 00      sub sp, 7
1125   0A91             ;; len = strlen(hex_string); 
1126   0A91 FA FA FF      lea d, [bp + -6] ; $len
1127   0A94 DA            push d
1128   0A95 FA 05 00      lea d, [bp + 5] ; $hex_string
1129   0A98 2A            mov b, [d]
1130   0A99 FD AB         swp b
1131   0A9B D8            push b
1132   0A9C 07 11 08      call strlen
1133   0A9F 51 02 00      add sp, 2
1134   0AA2 E7            pop d
1135   0AA3 FD 43         mov [d], b
1136   0AA5             ;; for (i = 0; i < len; i++) { 
1137   0AA5             _for13_init:
1138   0AA5 FA FD FF      lea d, [bp + -3] ; $i
1139   0AA8 DA            push d
1140   0AA9 26 00 00      mov b, $0
1141   0AAC E7            pop d
1142   0AAD FD 43         mov [d], b
1143   0AAF             _for13_cond:
1144   0AAF FA FD FF      lea d, [bp + -3] ; $i
1145   0AB2 2A            mov b, [d]
1146   0AB3             ; START RELATIONAL
1147   0AB3 D7            push a
1148   0AB4 11            mov a, b
1149   0AB5 FA FA FF      lea d, [bp + -6] ; $len
1150   0AB8 2A            mov b, [d]
1151   0AB9 B0            cmp a, b
1152   0ABA FD 73         slt ; < 
1153   0ABC E4            pop a
1154   0ABD             ; END RELATIONAL
1155   0ABD C0 00 00      cmp b, 0
1156   0AC0 C6 C5 0B      je _for13_exit
1157   0AC3             _for13_block:
1158   0AC3             ;; hex_char = hex_string[i]; 
1159   0AC3 FA FC FF      lea d, [bp + -4] ; $hex_char
1160   0AC6 DA            push d
1161   0AC7 FA 05 00      lea d, [bp + 5] ; $hex_string
1162   0ACA FD 2A         mov d, [d]
1163   0ACC D7            push a
1164   0ACD DA            push d
1165   0ACE FA FD FF      lea d, [bp + -3] ; $i
1166   0AD1 2A            mov b, [d]
1167   0AD2 E7            pop d
1168   0AD3 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1169   0AD7 E4            pop a
1170   0AD8 32            mov bl, [d]
1171   0AD9 A7 00         mov bh, 0
1172   0ADB E7            pop d
1173   0ADC FD 3E         mov [d], bl
1174   0ADE             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1175   0ADE             _if14_cond:
1176   0ADE FA FC FF      lea d, [bp + -4] ; $hex_char
1177   0AE1 32            mov bl, [d]
1178   0AE2 A7 00         mov bh, 0
1179   0AE4             ; START RELATIONAL
1180   0AE4 D7            push a
1181   0AE5 11            mov a, b
1182   0AE6 26 61 00      mov b, $61
1183   0AE9 B0            cmp a, b
1184   0AEA FD 80         sge ; >=
1185   0AEC E4            pop a
1186   0AED             ; END RELATIONAL
1187   0AED D7            push a
1188   0AEE 11            mov a, b
1189   0AEF FA FC FF      lea d, [bp + -4] ; $hex_char
1190   0AF2 32            mov bl, [d]
1191   0AF3 A7 00         mov bh, 0
1192   0AF5             ; START RELATIONAL
1193   0AF5 D7            push a
1194   0AF6 11            mov a, b
1195   0AF7 26 66 00      mov b, $66
1196   0AFA B0            cmp a, b
1197   0AFB FD 74         sle ; <=
1198   0AFD E4            pop a
1199   0AFE             ; END RELATIONAL
1200   0AFE FD A7         sand a, b ; &&
1201   0B00 E4            pop a
1202   0B01 C0 00 00      cmp b, 0
1203   0B04 C6 35 0B      je _if14_else
1204   0B07             _if14_true:
1205   0B07             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1206   0B07 FA FF FF      lea d, [bp + -1] ; $value
1207   0B0A DA            push d
1208   0B0B FA FF FF      lea d, [bp + -1] ; $value
1209   0B0E 2A            mov b, [d]
1210   0B0F             ; START FACTORS
1211   0B0F D7            push a
1212   0B10 11            mov a, b
1213   0B11 26 10 00      mov b, $10
1214   0B14 AC            mul a, b ; *
1215   0B15 11            mov a, b
1216   0B16 27            mov b, a
1217   0B17 E4            pop a
1218   0B18             ; END FACTORS
1219   0B18             ; START TERMS
1220   0B18 D7            push a
1221   0B19 11            mov a, b
1222   0B1A FA FC FF      lea d, [bp + -4] ; $hex_char
1223   0B1D 32            mov bl, [d]
1224   0B1E A7 00         mov bh, 0
1225   0B20             ; START TERMS
1226   0B20 D7            push a
1227   0B21 11            mov a, b
1228   0B22 26 61 00      mov b, $61
1229   0B25 60            sub a, b
1230   0B26 26 0A 00      mov b, $a
1231   0B29 54            add a, b
1232   0B2A 27            mov b, a
1233   0B2B E4            pop a
1234   0B2C             ; END TERMS
1235   0B2C 54            add a, b
1236   0B2D 27            mov b, a
1237   0B2E E4            pop a
1238   0B2F             ; END TERMS
1239   0B2F E7            pop d
1240   0B30 FD 43         mov [d], b
1241   0B32 0A B3 0B      jmp _if14_exit
1242   0B35             _if14_else:
1243   0B35             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1244   0B35             _if15_cond:
1245   0B35 FA FC FF      lea d, [bp + -4] ; $hex_char
1246   0B38 32            mov bl, [d]
1247   0B39 A7 00         mov bh, 0
1248   0B3B             ; START RELATIONAL
1249   0B3B D7            push a
1250   0B3C 11            mov a, b
1251   0B3D 26 41 00      mov b, $41
1252   0B40 B0            cmp a, b
1253   0B41 FD 80         sge ; >=
1254   0B43 E4            pop a
1255   0B44             ; END RELATIONAL
1256   0B44 D7            push a
1257   0B45 11            mov a, b
1258   0B46 FA FC FF      lea d, [bp + -4] ; $hex_char
1259   0B49 32            mov bl, [d]
1260   0B4A A7 00         mov bh, 0
1261   0B4C             ; START RELATIONAL
1262   0B4C D7            push a
1263   0B4D 11            mov a, b
1264   0B4E 26 46 00      mov b, $46
1265   0B51 B0            cmp a, b
1266   0B52 FD 74         sle ; <=
1267   0B54 E4            pop a
1268   0B55             ; END RELATIONAL
1269   0B55 FD A7         sand a, b ; &&
1270   0B57 E4            pop a
1271   0B58 C0 00 00      cmp b, 0
1272   0B5B C6 8C 0B      je _if15_else
1273   0B5E             _if15_true:
1274   0B5E             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1275   0B5E FA FF FF      lea d, [bp + -1] ; $value
1276   0B61 DA            push d
1277   0B62 FA FF FF      lea d, [bp + -1] ; $value
1278   0B65 2A            mov b, [d]
1279   0B66             ; START FACTORS
1280   0B66 D7            push a
1281   0B67 11            mov a, b
1282   0B68 26 10 00      mov b, $10
1283   0B6B AC            mul a, b ; *
1284   0B6C 11            mov a, b
1285   0B6D 27            mov b, a
1286   0B6E E4            pop a
1287   0B6F             ; END FACTORS
1288   0B6F             ; START TERMS
1289   0B6F D7            push a
1290   0B70 11            mov a, b
1291   0B71 FA FC FF      lea d, [bp + -4] ; $hex_char
1292   0B74 32            mov bl, [d]
1293   0B75 A7 00         mov bh, 0
1294   0B77             ; START TERMS
1295   0B77 D7            push a
1296   0B78 11            mov a, b
1297   0B79 26 41 00      mov b, $41
1298   0B7C 60            sub a, b
1299   0B7D 26 0A 00      mov b, $a
1300   0B80 54            add a, b
1301   0B81 27            mov b, a
1302   0B82 E4            pop a
1303   0B83             ; END TERMS
1304   0B83 54            add a, b
1305   0B84 27            mov b, a
1306   0B85 E4            pop a
1307   0B86             ; END TERMS
1308   0B86 E7            pop d
1309   0B87 FD 43         mov [d], b
1310   0B89 0A B3 0B      jmp _if15_exit
1311   0B8C             _if15_else:
1312   0B8C             ;; value = (value * 16) + (hex_char - '0'); 
1313   0B8C FA FF FF      lea d, [bp + -1] ; $value
1314   0B8F DA            push d
1315   0B90 FA FF FF      lea d, [bp + -1] ; $value
1316   0B93 2A            mov b, [d]
1317   0B94             ; START FACTORS
1318   0B94 D7            push a
1319   0B95 11            mov a, b
1320   0B96 26 10 00      mov b, $10
1321   0B99 AC            mul a, b ; *
1322   0B9A 11            mov a, b
1323   0B9B 27            mov b, a
1324   0B9C E4            pop a
1325   0B9D             ; END FACTORS
1326   0B9D             ; START TERMS
1327   0B9D D7            push a
1328   0B9E 11            mov a, b
1329   0B9F FA FC FF      lea d, [bp + -4] ; $hex_char
1330   0BA2 32            mov bl, [d]
1331   0BA3 A7 00         mov bh, 0
1332   0BA5             ; START TERMS
1333   0BA5 D7            push a
1334   0BA6 11            mov a, b
1335   0BA7 26 30 00      mov b, $30
1336   0BAA 60            sub a, b
1337   0BAB 27            mov b, a
1338   0BAC E4            pop a
1339   0BAD             ; END TERMS
1340   0BAD 54            add a, b
1341   0BAE 27            mov b, a
1342   0BAF E4            pop a
1343   0BB0             ; END TERMS
1344   0BB0 E7            pop d
1345   0BB1 FD 43         mov [d], b
1346   0BB3             _if15_exit:
1347   0BB3             _if14_exit:
1348   0BB3             _for13_update:
1349   0BB3 FA FD FF      lea d, [bp + -3] ; $i
1350   0BB6 2A            mov b, [d]
1351   0BB7 FD 79         mov g, b
1352   0BB9 FD 77         inc b
1353   0BBB FA FD FF      lea d, [bp + -3] ; $i
1354   0BBE FD 43         mov [d], b
1355   0BC0 FD 27         mov b, g
1356   0BC2 0A AF 0A      jmp _for13_cond
1357   0BC5             _for13_exit:
1358   0BC5             ;; return value; 
1359   0BC5 FA FF FF      lea d, [bp + -1] ; $value
1360   0BC8 2A            mov b, [d]
1361   0BC9 F9            leave
1362   0BCA 09            ret
1363   0BCB             
1364   0BCB             atoi:
1365   0BCB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1366   0BCE             ; $result 
1367   0BCE 10 00 00      mov a, $0
1368   0BD1 45 FF FF      mov [bp + -1], a
1369   0BD4             ; $sign 
1370   0BD4 10 01 00      mov a, $1
1371   0BD7 45 FD FF      mov [bp + -3], a
1372   0BDA 52 04 00      sub sp, 4
1373   0BDD             ;; while (*str == ' ') str++; 
1374   0BDD             _while16_cond:
1375   0BDD FA 05 00      lea d, [bp + 5] ; $str
1376   0BE0 2A            mov b, [d]
1377   0BE1 74            mov d, b
1378   0BE2 32            mov bl, [d]
1379   0BE3 A7 00         mov bh, 0
1380   0BE5             ; START RELATIONAL
1381   0BE5 D7            push a
1382   0BE6 11            mov a, b
1383   0BE7 26 20 00      mov b, $20
1384   0BEA B0            cmp a, b
1385   0BEB FD 71         seq ; ==
1386   0BED E4            pop a
1387   0BEE             ; END RELATIONAL
1388   0BEE C0 00 00      cmp b, 0
1389   0BF1 C6 06 0C      je _while16_exit
1390   0BF4             _while16_block:
1391   0BF4             ;; str++; 
1392   0BF4 FA 05 00      lea d, [bp + 5] ; $str
1393   0BF7 2A            mov b, [d]
1394   0BF8 FD 79         mov g, b
1395   0BFA FD 77         inc b
1396   0BFC FA 05 00      lea d, [bp + 5] ; $str
1397   0BFF FD 43         mov [d], b
1398   0C01 FD 27         mov b, g
1399   0C03 0A DD 0B      jmp _while16_cond
1400   0C06             _while16_exit:
1401   0C06             ;; if (*str == '-' || *str == '+') { 
1402   0C06             _if17_cond:
1403   0C06 FA 05 00      lea d, [bp + 5] ; $str
1404   0C09 2A            mov b, [d]
1405   0C0A 74            mov d, b
1406   0C0B 32            mov bl, [d]
1407   0C0C A7 00         mov bh, 0
1408   0C0E             ; START RELATIONAL
1409   0C0E D7            push a
1410   0C0F 11            mov a, b
1411   0C10 26 2D 00      mov b, $2d
1412   0C13 B0            cmp a, b
1413   0C14 FD 71         seq ; ==
1414   0C16 E4            pop a
1415   0C17             ; END RELATIONAL
1416   0C17 D7            push a
1417   0C18 11            mov a, b
1418   0C19 FA 05 00      lea d, [bp + 5] ; $str
1419   0C1C 2A            mov b, [d]
1420   0C1D 74            mov d, b
1421   0C1E 32            mov bl, [d]
1422   0C1F A7 00         mov bh, 0
1423   0C21             ; START RELATIONAL
1424   0C21 D7            push a
1425   0C22 11            mov a, b
1426   0C23 26 2B 00      mov b, $2b
1427   0C26 B0            cmp a, b
1428   0C27 FD 71         seq ; ==
1429   0C29 E4            pop a
1430   0C2A             ; END RELATIONAL
1431   0C2A FD A8         sor a, b ; ||
1432   0C2C E4            pop a
1433   0C2D C0 00 00      cmp b, 0
1434   0C30 C6 6B 0C      je _if17_exit
1435   0C33             _if17_true:
1436   0C33             ;; if (*str == '-') sign = -1; 
1437   0C33             _if18_cond:
1438   0C33 FA 05 00      lea d, [bp + 5] ; $str
1439   0C36 2A            mov b, [d]
1440   0C37 74            mov d, b
1441   0C38 32            mov bl, [d]
1442   0C39 A7 00         mov bh, 0
1443   0C3B             ; START RELATIONAL
1444   0C3B D7            push a
1445   0C3C 11            mov a, b
1446   0C3D 26 2D 00      mov b, $2d
1447   0C40 B0            cmp a, b
1448   0C41 FD 71         seq ; ==
1449   0C43 E4            pop a
1450   0C44             ; END RELATIONAL
1451   0C44 C0 00 00      cmp b, 0
1452   0C47 C6 59 0C      je _if18_exit
1453   0C4A             _if18_true:
1454   0C4A             ;; sign = -1; 
1455   0C4A FA FD FF      lea d, [bp + -3] ; $sign
1456   0C4D DA            push d
1457   0C4E 26 01 00      mov b, $1
1458   0C51 FD 97         neg b
1459   0C53 E7            pop d
1460   0C54 FD 43         mov [d], b
1461   0C56 0A 59 0C      jmp _if18_exit
1462   0C59             _if18_exit:
1463   0C59             ;; str++; 
1464   0C59 FA 05 00      lea d, [bp + 5] ; $str
1465   0C5C 2A            mov b, [d]
1466   0C5D FD 79         mov g, b
1467   0C5F FD 77         inc b
1468   0C61 FA 05 00      lea d, [bp + 5] ; $str
1469   0C64 FD 43         mov [d], b
1470   0C66 FD 27         mov b, g
1471   0C68 0A 6B 0C      jmp _if17_exit
1472   0C6B             _if17_exit:
1473   0C6B             ;; while (*str >= '0' && *str <= '9') { 
1474   0C6B             _while19_cond:
1475   0C6B FA 05 00      lea d, [bp + 5] ; $str
1476   0C6E 2A            mov b, [d]
1477   0C6F 74            mov d, b
1478   0C70 32            mov bl, [d]
1479   0C71 A7 00         mov bh, 0
1480   0C73             ; START RELATIONAL
1481   0C73 D7            push a
1482   0C74 11            mov a, b
1483   0C75 26 30 00      mov b, $30
1484   0C78 B0            cmp a, b
1485   0C79 FD 80         sge ; >=
1486   0C7B E4            pop a
1487   0C7C             ; END RELATIONAL
1488   0C7C D7            push a
1489   0C7D 11            mov a, b
1490   0C7E FA 05 00      lea d, [bp + 5] ; $str
1491   0C81 2A            mov b, [d]
1492   0C82 74            mov d, b
1493   0C83 32            mov bl, [d]
1494   0C84 A7 00         mov bh, 0
1495   0C86             ; START RELATIONAL
1496   0C86 D7            push a
1497   0C87 11            mov a, b
1498   0C88 26 39 00      mov b, $39
1499   0C8B B0            cmp a, b
1500   0C8C FD 74         sle ; <=
1501   0C8E E4            pop a
1502   0C8F             ; END RELATIONAL
1503   0C8F FD A7         sand a, b ; &&
1504   0C91 E4            pop a
1505   0C92 C0 00 00      cmp b, 0
1506   0C95 C6 D3 0C      je _while19_exit
1507   0C98             _while19_block:
1508   0C98             ;; result = result * 10 + (*str - '0'); 
1509   0C98 FA FF FF      lea d, [bp + -1] ; $result
1510   0C9B DA            push d
1511   0C9C FA FF FF      lea d, [bp + -1] ; $result
1512   0C9F 2A            mov b, [d]
1513   0CA0             ; START FACTORS
1514   0CA0 D7            push a
1515   0CA1 11            mov a, b
1516   0CA2 26 0A 00      mov b, $a
1517   0CA5 AC            mul a, b ; *
1518   0CA6 11            mov a, b
1519   0CA7 27            mov b, a
1520   0CA8 E4            pop a
1521   0CA9             ; END FACTORS
1522   0CA9             ; START TERMS
1523   0CA9 D7            push a
1524   0CAA 11            mov a, b
1525   0CAB FA 05 00      lea d, [bp + 5] ; $str
1526   0CAE 2A            mov b, [d]
1527   0CAF 74            mov d, b
1528   0CB0 32            mov bl, [d]
1529   0CB1 A7 00         mov bh, 0
1530   0CB3             ; START TERMS
1531   0CB3 D7            push a
1532   0CB4 11            mov a, b
1533   0CB5 26 30 00      mov b, $30
1534   0CB8 60            sub a, b
1535   0CB9 27            mov b, a
1536   0CBA E4            pop a
1537   0CBB             ; END TERMS
1538   0CBB 54            add a, b
1539   0CBC 27            mov b, a
1540   0CBD E4            pop a
1541   0CBE             ; END TERMS
1542   0CBE E7            pop d
1543   0CBF FD 43         mov [d], b
1544   0CC1             ;; str++; 
1545   0CC1 FA 05 00      lea d, [bp + 5] ; $str
1546   0CC4 2A            mov b, [d]
1547   0CC5 FD 79         mov g, b
1548   0CC7 FD 77         inc b
1549   0CC9 FA 05 00      lea d, [bp + 5] ; $str
1550   0CCC FD 43         mov [d], b
1551   0CCE FD 27         mov b, g
1552   0CD0 0A 6B 0C      jmp _while19_cond
1553   0CD3             _while19_exit:
1554   0CD3             ;; return sign * result; 
1555   0CD3 FA FD FF      lea d, [bp + -3] ; $sign
1556   0CD6 2A            mov b, [d]
1557   0CD7             ; START FACTORS
1558   0CD7 D7            push a
1559   0CD8 11            mov a, b
1560   0CD9 FA FF FF      lea d, [bp + -1] ; $result
1561   0CDC 2A            mov b, [d]
1562   0CDD AC            mul a, b ; *
1563   0CDE 11            mov a, b
1564   0CDF 27            mov b, a
1565   0CE0 E4            pop a
1566   0CE1             ; END FACTORS
1567   0CE1 F9            leave
1568   0CE2 09            ret
1569   0CE3             
1570   0CE3             gets:
1571   0CE3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1572   0CE6             
1573   0CE6             ; --- BEGIN INLINE ASM BLOCK
1574   0CE6 FA 05 00      lea d, [bp + 5] ; $s
1575   0CE9 15            mov a, [d]
1576   0CEA 3C            mov d, a
1577   0CEB 07 0C 11      call _gets
1578   0CEE             ; --- END INLINE ASM BLOCK
1579   0CEE             
1580   0CEE             ;; return strlen(s); 
1581   0CEE FA 05 00      lea d, [bp + 5] ; $s
1582   0CF1 2A            mov b, [d]
1583   0CF2 FD AB         swp b
1584   0CF4 D8            push b
1585   0CF5 07 11 08      call strlen
1586   0CF8 51 02 00      add sp, 2
1587   0CFB F9            leave
1588   0CFC 09            ret
1589   0CFD             
1590   0CFD             prints:
1591   0CFD F8 00 00      enter 0 ; (push bp; mov bp, sp)
1592   0D00             ; $digits 
1593   0D00             ; $i 
1594   0D00 10 00 00      mov a, $0
1595   0D03 45 FA FF      mov [bp + -6], a
1596   0D06 52 07 00      sub sp, 7
1597   0D09             ;; if (num < 0) { 
1598   0D09             _if20_cond:
1599   0D09 FA 05 00      lea d, [bp + 5] ; $num
1600   0D0C 2A            mov b, [d]
1601   0D0D             ; START RELATIONAL
1602   0D0D D7            push a
1603   0D0E 11            mov a, b
1604   0D0F 26 00 00      mov b, $0
1605   0D12 B0            cmp a, b
1606   0D13 FD 73         slt ; < 
1607   0D15 E4            pop a
1608   0D16             ; END RELATIONAL
1609   0D16 C0 00 00      cmp b, 0
1610   0D19 C6 36 0D      je _if20_else
1611   0D1C             _if20_true:
1612   0D1C             ;; putchar('-'); 
1613   0D1C 26 2D 00      mov b, $2d
1614   0D1F DD            push bl
1615   0D20 07 DE 0E      call putchar
1616   0D23 51 01 00      add sp, 1
1617   0D26             ;; num = -num; 
1618   0D26 FA 05 00      lea d, [bp + 5] ; $num
1619   0D29 DA            push d
1620   0D2A FA 05 00      lea d, [bp + 5] ; $num
1621   0D2D 2A            mov b, [d]
1622   0D2E FD 97         neg b
1623   0D30 E7            pop d
1624   0D31 FD 43         mov [d], b
1625   0D33 0A 58 0D      jmp _if20_exit
1626   0D36             _if20_else:
1627   0D36             ;; if (num == 0) { 
1628   0D36             _if21_cond:
1629   0D36 FA 05 00      lea d, [bp + 5] ; $num
1630   0D39 2A            mov b, [d]
1631   0D3A             ; START RELATIONAL
1632   0D3A D7            push a
1633   0D3B 11            mov a, b
1634   0D3C 26 00 00      mov b, $0
1635   0D3F B0            cmp a, b
1636   0D40 FD 71         seq ; ==
1637   0D42 E4            pop a
1638   0D43             ; END RELATIONAL
1639   0D43 C0 00 00      cmp b, 0
1640   0D46 C6 58 0D      je _if21_exit
1641   0D49             _if21_true:
1642   0D49             ;; putchar('0'); 
1643   0D49 26 30 00      mov b, $30
1644   0D4C DD            push bl
1645   0D4D 07 DE 0E      call putchar
1646   0D50 51 01 00      add sp, 1
1647   0D53             ;; return; 
1648   0D53 F9            leave
1649   0D54 09            ret
1650   0D55 0A 58 0D      jmp _if21_exit
1651   0D58             _if21_exit:
1652   0D58             _if20_exit:
1653   0D58             ;; while (num > 0) { 
1654   0D58             _while22_cond:
1655   0D58 FA 05 00      lea d, [bp + 5] ; $num
1656   0D5B 2A            mov b, [d]
1657   0D5C             ; START RELATIONAL
1658   0D5C D7            push a
1659   0D5D 11            mov a, b
1660   0D5E 26 00 00      mov b, $0
1661   0D61 B0            cmp a, b
1662   0D62 FD 7F         sgt ; >
1663   0D64 E4            pop a
1664   0D65             ; END RELATIONAL
1665   0D65 C0 00 00      cmp b, 0
1666   0D68 C6 B5 0D      je _while22_exit
1667   0D6B             _while22_block:
1668   0D6B             ;; digits[i] = '0' + (num % 10); 
1669   0D6B FA FC FF      lea d, [bp + -4] ; $digits
1670   0D6E D7            push a
1671   0D6F DA            push d
1672   0D70 FA FA FF      lea d, [bp + -6] ; $i
1673   0D73 2A            mov b, [d]
1674   0D74 E7            pop d
1675   0D75 5A            add d, b
1676   0D76 E4            pop a
1677   0D77 DA            push d
1678   0D78 26 30 00      mov b, $30
1679   0D7B             ; START TERMS
1680   0D7B D7            push a
1681   0D7C 11            mov a, b
1682   0D7D FA 05 00      lea d, [bp + 5] ; $num
1683   0D80 2A            mov b, [d]
1684   0D81             ; START FACTORS
1685   0D81 D7            push a
1686   0D82 11            mov a, b
1687   0D83 26 0A 00      mov b, $a
1688   0D86 AE            div a, b ; 
1689   0D87 11            mov a, b
1690   0D88 27            mov b, a
1691   0D89 E4            pop a
1692   0D8A             ; END FACTORS
1693   0D8A 54            add a, b
1694   0D8B 27            mov b, a
1695   0D8C E4            pop a
1696   0D8D             ; END TERMS
1697   0D8D E7            pop d
1698   0D8E FD 3E         mov [d], bl
1699   0D90             ;; num = num / 10; 
1700   0D90 FA 05 00      lea d, [bp + 5] ; $num
1701   0D93 DA            push d
1702   0D94 FA 05 00      lea d, [bp + 5] ; $num
1703   0D97 2A            mov b, [d]
1704   0D98             ; START FACTORS
1705   0D98 D7            push a
1706   0D99 11            mov a, b
1707   0D9A 26 0A 00      mov b, $a
1708   0D9D AE            div a, b
1709   0D9E 27            mov b, a
1710   0D9F E4            pop a
1711   0DA0             ; END FACTORS
1712   0DA0 E7            pop d
1713   0DA1 FD 43         mov [d], b
1714   0DA3             ;; i++; 
1715   0DA3 FA FA FF      lea d, [bp + -6] ; $i
1716   0DA6 2A            mov b, [d]
1717   0DA7 FD 79         mov g, b
1718   0DA9 FD 77         inc b
1719   0DAB FA FA FF      lea d, [bp + -6] ; $i
1720   0DAE FD 43         mov [d], b
1721   0DB0 FD 27         mov b, g
1722   0DB2 0A 58 0D      jmp _while22_cond
1723   0DB5             _while22_exit:
1724   0DB5             ;; while (i > 0) { 
1725   0DB5             _while23_cond:
1726   0DB5 FA FA FF      lea d, [bp + -6] ; $i
1727   0DB8 2A            mov b, [d]
1728   0DB9             ; START RELATIONAL
1729   0DB9 D7            push a
1730   0DBA 11            mov a, b
1731   0DBB 26 00 00      mov b, $0
1732   0DBE B0            cmp a, b
1733   0DBF FD 7F         sgt ; >
1734   0DC1 E4            pop a
1735   0DC2             ; END RELATIONAL
1736   0DC2 C0 00 00      cmp b, 0
1737   0DC5 C6 F0 0D      je _while23_exit
1738   0DC8             _while23_block:
1739   0DC8             ;; i--; 
1740   0DC8 FA FA FF      lea d, [bp + -6] ; $i
1741   0DCB 2A            mov b, [d]
1742   0DCC FD 79         mov g, b
1743   0DCE FD 7D         dec b
1744   0DD0 FA FA FF      lea d, [bp + -6] ; $i
1745   0DD3 FD 43         mov [d], b
1746   0DD5 FD 27         mov b, g
1747   0DD7             ;; putchar(digits[i]); 
1748   0DD7 FA FC FF      lea d, [bp + -4] ; $digits
1749   0DDA D7            push a
1750   0DDB DA            push d
1751   0DDC FA FA FF      lea d, [bp + -6] ; $i
1752   0DDF 2A            mov b, [d]
1753   0DE0 E7            pop d
1754   0DE1 5A            add d, b
1755   0DE2 E4            pop a
1756   0DE3 32            mov bl, [d]
1757   0DE4 A7 00         mov bh, 0
1758   0DE6 DD            push bl
1759   0DE7 07 DE 0E      call putchar
1760   0DEA 51 01 00      add sp, 1
1761   0DED 0A B5 0D      jmp _while23_cond
1762   0DF0             _while23_exit:
1763   0DF0 F9            leave
1764   0DF1 09            ret
1765   0DF2             
1766   0DF2             printu:
1767   0DF2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1768   0DF5             ; $digits 
1769   0DF5             ; $i 
1770   0DF5 52 07 00      sub sp, 7
1771   0DF8             ;; i = 0; 
1772   0DF8 FA FA FF      lea d, [bp + -6] ; $i
1773   0DFB DA            push d
1774   0DFC 26 00 00      mov b, $0
1775   0DFF E7            pop d
1776   0E00 FD 43         mov [d], b
1777   0E02             ;; if(num == 0){ 
1778   0E02             _if24_cond:
1779   0E02 FA 05 00      lea d, [bp + 5] ; $num
1780   0E05 2A            mov b, [d]
1781   0E06             ; START RELATIONAL
1782   0E06 D7            push a
1783   0E07 11            mov a, b
1784   0E08 26 00 00      mov b, $0
1785   0E0B B0            cmp a, b
1786   0E0C FD 71         seq ; ==
1787   0E0E E4            pop a
1788   0E0F             ; END RELATIONAL
1789   0E0F C0 00 00      cmp b, 0
1790   0E12 C6 24 0E      je _if24_exit
1791   0E15             _if24_true:
1792   0E15             ;; putchar('0'); 
1793   0E15 26 30 00      mov b, $30
1794   0E18 DD            push bl
1795   0E19 07 DE 0E      call putchar
1796   0E1C 51 01 00      add sp, 1
1797   0E1F             ;; return; 
1798   0E1F F9            leave
1799   0E20 09            ret
1800   0E21 0A 24 0E      jmp _if24_exit
1801   0E24             _if24_exit:
1802   0E24             ;; while (num > 0) { 
1803   0E24             _while25_cond:
1804   0E24 FA 05 00      lea d, [bp + 5] ; $num
1805   0E27 2A            mov b, [d]
1806   0E28             ; START RELATIONAL
1807   0E28 D7            push a
1808   0E29 11            mov a, b
1809   0E2A 26 00 00      mov b, $0
1810   0E2D B0            cmp a, b
1811   0E2E FD 81         sgu ; > (unsigned)
1812   0E30 E4            pop a
1813   0E31             ; END RELATIONAL
1814   0E31 C0 00 00      cmp b, 0
1815   0E34 C6 81 0E      je _while25_exit
1816   0E37             _while25_block:
1817   0E37             ;; digits[i] = '0' + (num % 10); 
1818   0E37 FA FC FF      lea d, [bp + -4] ; $digits
1819   0E3A D7            push a
1820   0E3B DA            push d
1821   0E3C FA FA FF      lea d, [bp + -6] ; $i
1822   0E3F 2A            mov b, [d]
1823   0E40 E7            pop d
1824   0E41 5A            add d, b
1825   0E42 E4            pop a
1826   0E43 DA            push d
1827   0E44 26 30 00      mov b, $30
1828   0E47             ; START TERMS
1829   0E47 D7            push a
1830   0E48 11            mov a, b
1831   0E49 FA 05 00      lea d, [bp + 5] ; $num
1832   0E4C 2A            mov b, [d]
1833   0E4D             ; START FACTORS
1834   0E4D D7            push a
1835   0E4E 11            mov a, b
1836   0E4F 26 0A 00      mov b, $a
1837   0E52 AE            div a, b ; 
1838   0E53 11            mov a, b
1839   0E54 27            mov b, a
1840   0E55 E4            pop a
1841   0E56             ; END FACTORS
1842   0E56 54            add a, b
1843   0E57 27            mov b, a
1844   0E58 E4            pop a
1845   0E59             ; END TERMS
1846   0E59 E7            pop d
1847   0E5A FD 3E         mov [d], bl
1848   0E5C             ;; num = num / 10; 
1849   0E5C FA 05 00      lea d, [bp + 5] ; $num
1850   0E5F DA            push d
1851   0E60 FA 05 00      lea d, [bp + 5] ; $num
1852   0E63 2A            mov b, [d]
1853   0E64             ; START FACTORS
1854   0E64 D7            push a
1855   0E65 11            mov a, b
1856   0E66 26 0A 00      mov b, $a
1857   0E69 AE            div a, b
1858   0E6A 27            mov b, a
1859   0E6B E4            pop a
1860   0E6C             ; END FACTORS
1861   0E6C E7            pop d
1862   0E6D FD 43         mov [d], b
1863   0E6F             ;; i++; 
1864   0E6F FA FA FF      lea d, [bp + -6] ; $i
1865   0E72 2A            mov b, [d]
1866   0E73 FD 79         mov g, b
1867   0E75 FD 77         inc b
1868   0E77 FA FA FF      lea d, [bp + -6] ; $i
1869   0E7A FD 43         mov [d], b
1870   0E7C FD 27         mov b, g
1871   0E7E 0A 24 0E      jmp _while25_cond
1872   0E81             _while25_exit:
1873   0E81             ;; while (i > 0) { 
1874   0E81             _while26_cond:
1875   0E81 FA FA FF      lea d, [bp + -6] ; $i
1876   0E84 2A            mov b, [d]
1877   0E85             ; START RELATIONAL
1878   0E85 D7            push a
1879   0E86 11            mov a, b
1880   0E87 26 00 00      mov b, $0
1881   0E8A B0            cmp a, b
1882   0E8B FD 7F         sgt ; >
1883   0E8D E4            pop a
1884   0E8E             ; END RELATIONAL
1885   0E8E C0 00 00      cmp b, 0
1886   0E91 C6 BC 0E      je _while26_exit
1887   0E94             _while26_block:
1888   0E94             ;; i--; 
1889   0E94 FA FA FF      lea d, [bp + -6] ; $i
1890   0E97 2A            mov b, [d]
1891   0E98 FD 79         mov g, b
1892   0E9A FD 7D         dec b
1893   0E9C FA FA FF      lea d, [bp + -6] ; $i
1894   0E9F FD 43         mov [d], b
1895   0EA1 FD 27         mov b, g
1896   0EA3             ;; putchar(digits[i]); 
1897   0EA3 FA FC FF      lea d, [bp + -4] ; $digits
1898   0EA6 D7            push a
1899   0EA7 DA            push d
1900   0EA8 FA FA FF      lea d, [bp + -6] ; $i
1901   0EAB 2A            mov b, [d]
1902   0EAC E7            pop d
1903   0EAD 5A            add d, b
1904   0EAE E4            pop a
1905   0EAF 32            mov bl, [d]
1906   0EB0 A7 00         mov bh, 0
1907   0EB2 DD            push bl
1908   0EB3 07 DE 0E      call putchar
1909   0EB6 51 01 00      add sp, 1
1910   0EB9 0A 81 0E      jmp _while26_cond
1911   0EBC             _while26_exit:
1912   0EBC F9            leave
1913   0EBD 09            ret
1914   0EBE             
1915   0EBE             rand:
1916   0EBE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1917   0EC1             ; $sec 
1918   0EC1 52 01 00      sub sp, 1
1919   0EC4             
1920   0EC4             ; --- BEGIN INLINE ASM BLOCK
1921   0EC4 19 00         mov al, 0
1922   0EC6 05 01         syscall sys_rtc					
1923   0EC8 1A            mov al, ah
1924   0EC9 FA 00 00      lea d, [bp + 0] ; $sec
1925   0ECC 1E            mov al, [d]
1926   0ECD             ; --- END INLINE ASM BLOCK
1927   0ECD             
1928   0ECD             ;; return sec; 
1929   0ECD FA 00 00      lea d, [bp + 0] ; $sec
1930   0ED0 32            mov bl, [d]
1931   0ED1 A7 00         mov bh, 0
1932   0ED3 F9            leave
1933   0ED4 09            ret
1934   0ED5             
1935   0ED5             date:
1936   0ED5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1937   0ED8             
1938   0ED8             ; --- BEGIN INLINE ASM BLOCK
1939   0ED8 19 00         mov al, 0 
1940   0EDA 05 07         syscall sys_datetime
1941   0EDC             ; --- END INLINE ASM BLOCK
1942   0EDC             
1943   0EDC F9            leave
1944   0EDD 09            ret
1945   0EDE             
1946   0EDE             putchar:
1947   0EDE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1948   0EE1             
1949   0EE1             ; --- BEGIN INLINE ASM BLOCK
1950   0EE1 FA 05 00      lea d, [bp + 5] ; $c
1951   0EE4 1E            mov al, [d]
1952   0EE5 23            mov ah, al
1953   0EE6 07 05 11      call _putchar
1954   0EE9             ; --- END INLINE ASM BLOCK
1955   0EE9             
1956   0EE9 F9            leave
1957   0EEA 09            ret
1958   0EEB             
1959   0EEB             getchar:
1960   0EEB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1961   0EEE             ; $c 
1962   0EEE 52 01 00      sub sp, 1
1963   0EF1             
1964   0EF1             ; --- BEGIN INLINE ASM BLOCK
1965   0EF1 07 FE 10      call getch
1966   0EF4 1A            mov al, ah
1967   0EF5 FA 00 00      lea d, [bp + 0] ; $c
1968   0EF8 3E            mov [d], al
1969   0EF9             ; --- END INLINE ASM BLOCK
1970   0EF9             
1971   0EF9             ;; return c; 
1972   0EF9 FA 00 00      lea d, [bp + 0] ; $c
1973   0EFC 32            mov bl, [d]
1974   0EFD A7 00         mov bh, 0
1975   0EFF F9            leave
1976   0F00 09            ret
1977   0F01             
1978   0F01             scann:
1979   0F01 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1980   0F04             ; $m 
1981   0F04 52 02 00      sub sp, 2
1982   0F07             
1983   0F07             ; --- BEGIN INLINE ASM BLOCK
1984   0F07 07 49 13      call scan_u16d
1985   0F0A FA FF FF      lea d, [bp + -1] ; $m
1986   0F0D 43            mov [d], a
1987   0F0E             ; --- END INLINE ASM BLOCK
1988   0F0E             
1989   0F0E             ;; return m; 
1990   0F0E FA FF FF      lea d, [bp + -1] ; $m
1991   0F11 2A            mov b, [d]
1992   0F12 F9            leave
1993   0F13 09            ret
1994   0F14             
1995   0F14             puts:
1996   0F14 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1997   0F17             
1998   0F17             ; --- BEGIN INLINE ASM BLOCK
1999   0F17 FA 05 00      lea d, [bp + 5] ; $s
2000   0F1A 15            mov a, [d]
2001   0F1B 3C            mov d, a
2002   0F1C 07 4F 12      call _puts
2003   0F1F 10 00 0A      mov a, $0A00
2004   0F22 05 03         syscall sys_io
2005   0F24             ; --- END INLINE ASM BLOCK
2006   0F24             
2007   0F24 F9            leave
2008   0F25 09            ret
2009   0F26             
2010   0F26             print:
2011   0F26 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2012   0F29             
2013   0F29             ; --- BEGIN INLINE ASM BLOCK
2014   0F29 FA 05 00      lea d, [bp + 5] ; $s
2015   0F2C FD 2A         mov d, [d]
2016   0F2E 07 4F 12      call _puts
2017   0F31             ; --- END INLINE ASM BLOCK
2018   0F31             
2019   0F31 F9            leave
2020   0F32 09            ret
2021   0F33             
2022   0F33             loadfile:
2023   0F33 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2024   0F36             
2025   0F36             ; --- BEGIN INLINE ASM BLOCK
2026   0F36 FA 05 00      lea d, [bp + 5] ; $destination
2027   0F39 15            mov a, [d]
2028   0F3A 4F            mov di, a
2029   0F3B FA 07 00      lea d, [bp + 7] ; $filename
2030   0F3E FD 2A         mov d, [d]
2031   0F40 19 14         mov al, 20
2032   0F42 05 04         syscall sys_filesystem
2033   0F44             ; --- END INLINE ASM BLOCK
2034   0F44             
2035   0F44 F9            leave
2036   0F45 09            ret
2037   0F46             
2038   0F46             create_file:
2039   0F46 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2040   0F49 F9            leave
2041   0F4A 09            ret
2042   0F4B             
2043   0F4B             delete_file:
2044   0F4B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2045   0F4E             
2046   0F4E             ; --- BEGIN INLINE ASM BLOCK
2047   0F4E FA 05 00      lea d, [bp + 5] ; $filename
2048   0F51 19 0A         mov al, 10
2049   0F53 05 04         syscall sys_filesystem
2050   0F55             ; --- END INLINE ASM BLOCK
2051   0F55             
2052   0F55 F9            leave
2053   0F56 09            ret
2054   0F57             
2055   0F57             fopen:
2056   0F57 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2057   0F5A F9            leave
2058   0F5B 09            ret
2059   0F5C             
2060   0F5C             fclose:
2061   0F5C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2062   0F5F F9            leave
2063   0F60 09            ret
2064   0F61             
2065   0F61             alloc:
2066   0F61 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2067   0F64             ;; heap_top = heap_top + bytes; 
2068   0F64 3B 11 16      mov d, _heap_top ; $heap_top
2069   0F67 DA            push d
2070   0F68 3B 11 16      mov d, _heap_top ; $heap_top
2071   0F6B 2A            mov b, [d]
2072   0F6C             ; START TERMS
2073   0F6C D7            push a
2074   0F6D 11            mov a, b
2075   0F6E FA 05 00      lea d, [bp + 5] ; $bytes
2076   0F71 2A            mov b, [d]
2077   0F72 54            add a, b
2078   0F73 27            mov b, a
2079   0F74 E4            pop a
2080   0F75             ; END TERMS
2081   0F75 E7            pop d
2082   0F76 FD 43         mov [d], b
2083   0F78             ;; return heap_top - bytes; 
2084   0F78 3B 11 16      mov d, _heap_top ; $heap_top
2085   0F7B 2A            mov b, [d]
2086   0F7C             ; START TERMS
2087   0F7C D7            push a
2088   0F7D 11            mov a, b
2089   0F7E FA 05 00      lea d, [bp + 5] ; $bytes
2090   0F81 2A            mov b, [d]
2091   0F82 60            sub a, b
2092   0F83 27            mov b, a
2093   0F84 E4            pop a
2094   0F85             ; END TERMS
2095   0F85 F9            leave
2096   0F86 09            ret
2097   0F87             
2098   0F87             free:
2099   0F87 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2100   0F8A             ;; return heap_top = heap_top - bytes; 
2101   0F8A 3B 11 16      mov d, _heap_top ; $heap_top
2102   0F8D DA            push d
2103   0F8E 3B 11 16      mov d, _heap_top ; $heap_top
2104   0F91 2A            mov b, [d]
2105   0F92             ; START TERMS
2106   0F92 D7            push a
2107   0F93 11            mov a, b
2108   0F94 FA 05 00      lea d, [bp + 5] ; $bytes
2109   0F97 2A            mov b, [d]
2110   0F98 60            sub a, b
2111   0F99 27            mov b, a
2112   0F9A E4            pop a
2113   0F9B             ; END TERMS
2114   0F9B E7            pop d
2115   0F9C FD 43         mov [d], b
2116   0F9E F9            leave
2117   0F9F 09            ret
2118   0FA0             
2119   0FA0             exit:
2120   0FA0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2121   0FA3             
2122   0FA3             ; --- BEGIN INLINE ASM BLOCK
2123   0FA3 05 0B         syscall sys_terminate_proc
2124   0FA5             ; --- END INLINE ASM BLOCK
2125   0FA5             
2126   0FA5 F9            leave
2127   0FA6 09            ret
2128   0FA7             
2129   0FA7             load_hex:
2130   0FA7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2131   0FAA             ; $temp 
2132   0FAA 52 02 00      sub sp, 2
2133   0FAD             ;; temp = alloc(32768); 
2134   0FAD FA FF FF      lea d, [bp + -1] ; $temp
2135   0FB0 DA            push d
2136   0FB1 26 00 80      mov b, $8000
2137   0FB4 FD AB         swp b
2138   0FB6 D8            push b
2139   0FB7 07 61 0F      call alloc
2140   0FBA 51 02 00      add sp, 2
2141   0FBD E7            pop d
2142   0FBE FD 43         mov [d], b
2143   0FC0             
2144   0FC0             ; --- BEGIN INLINE ASM BLOCK
2145   0FC0               
2146   0FC0               
2147   0FC0               
2148   0FC0               
2149   0FC0               
2150   0FC0             _load_hex:
2151   0FC0 D7            push a
2152   0FC1 D8            push b
2153   0FC2 DA            push d
2154   0FC3 E2            push si
2155   0FC4 E3            push di
2156   0FC5 52 00 80      sub sp, $8000      
2157   0FC8 38 00 00      mov c, 0
2158   0FCB 48            mov a, sp
2159   0FCC 77            inc a
2160   0FCD 3C            mov d, a          
2161   0FCE 07 0C 11      call _gets        
2162   0FD1 4D            mov si, a
2163   0FD2             __load_hex_loop:
2164   0FD2 F6            lodsb             
2165   0FD3 B9 00         cmp al, 0         
2166   0FD5 C6 E3 0F      jz __load_hex_ret
2167   0FD8 36            mov bh, al
2168   0FD9 F6            lodsb
2169   0FDA 2F            mov bl, al
2170   0FDB 07 C2 10      call _atoi        
2171   0FDE F7            stosb             
2172   0FDF 78            inc c
2173   0FE0 0A D2 0F      jmp __load_hex_loop
2174   0FE3             __load_hex_ret:
2175   0FE3 51 00 80      add sp, $8000
2176   0FE6 F0            pop di
2177   0FE7 EF            pop si
2178   0FE8 E7            pop d
2179   0FE9 E5            pop b
2180   0FEA E4            pop a
2181   0FEB             ; --- END INLINE ASM BLOCK
2182   0FEB             
2183   0FEB F9            leave
2184   0FEC 09            ret
2185   0FED             
2186   0FED             getparam:
2187   0FED F8 00 00      enter 0 ; (push bp; mov bp, sp)
2188   0FF0             ; $data 
2189   0FF0 52 01 00      sub sp, 1
2190   0FF3             
2191   0FF3             ; --- BEGIN INLINE ASM BLOCK
2192   0FF3 19 04         mov al, 4
2193   0FF5 FA 05 00      lea d, [bp + 5] ; $address
2194   0FF8 FD 2A         mov d, [d]
2195   0FFA 05 0C         syscall sys_system
2196   0FFC FA 00 00      lea d, [bp + 0] ; $data
2197   0FFF FD 3E         mov [d], bl
2198   1001             ; --- END INLINE ASM BLOCK
2199   1001             
2200   1001             ;; return data; 
2201   1001 FA 00 00      lea d, [bp + 0] ; $data
2202   1004 32            mov bl, [d]
2203   1005 A7 00         mov bh, 0
2204   1007 F9            leave
2205   1008 09            ret
2206   1009             
2207   1009             clear:
2208   1009 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2209   100C             ;; print("\033[2J\033[H"); 
2210   100C 26 09 16      mov b, __s11 ; "\033[2J\033[H"
2211   100F FD AB         swp b
2212   1011 D8            push b
2213   1012 07 26 0F      call print
2214   1015 51 02 00      add sp, 2
2215   1018 F9            leave
2216   1019 09            ret
2217   101A             
2218   101A             include_stdio_asm:
2219   101A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2220   101D             
2221   101D             ; --- BEGIN INLINE ASM BLOCK
2222   101D             .include "lib/stdio.asm"
0001+  101D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  101D             ; stdio.s
0003+  101D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  101D             .include "lib/string.asm"
0001++ 101D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 101D             ; string.s
0003++ 101D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 101D             
0005++ 101D             
0006++ 101D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 101D             ; _strrev
0008++ 101D             ; reverse a string
0009++ 101D             ; D = string address
0010++ 101D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 101D             ; 01234
0012++ 101D             _strrev:
0013++ 101D 4B          	pusha
0014++ 101E 07 64 10    	call _strlen	; length in C
0015++ 1021 12          	mov a, c
0016++ 1022 AF 01 00    	cmp a, 1
0017++ 1025 D0 3F 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1028 7D          	dec a
0019++ 1029 FD 4E       	mov si, d	; beginning of string
0020++ 102B FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 102D 59          	add d, a	; end of string
0022++ 102E 12          	mov a, c
0023++ 102F FD 9B       	shr a		; divide by 2
0024++ 1031 39          	mov c, a	; C now counts the steps
0025++ 1032             _strrev_L0:
0026++ 1032 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1033 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1034 3E          	mov [d], al	; store left char into right side
0029++ 1035 1B          	mov al, bl
0030++ 1036 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1037 7E          	dec c
0032++ 1038 7F          	dec d
0033++ 1039 C2 00 00    	cmp c, 0
0034++ 103C C7 32 10    	jne _strrev_L0
0035++ 103F             _strrev_end:
0036++ 103F 4C          	popa
0037++ 1040 09          	ret
0038++ 1041             	
0039++ 1041             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1041             ; _strchr
0041++ 1041             ; search string in D for char in AL
0042++ 1041             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1041             _strchr:
0044++ 1041             _strchr_L0:
0045++ 1041 32          	mov bl, [d]
0046++ 1042 C1 00       	cmp bl, 0
0047++ 1044 C6 4F 10    	je _strchr_end
0048++ 1047 BA          	cmp al, bl
0049++ 1048 C6 4F 10    	je _strchr_end
0050++ 104B 79          	inc d
0051++ 104C 0A 41 10    	jmp _strchr_L0
0052++ 104F             _strchr_end:
0053++ 104F 1B          	mov al, bl
0054++ 1050 09          	ret
0055++ 1051             
0056++ 1051             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1051             ; _strstr
0058++ 1051             ; find sub-string
0059++ 1051             ; str1 in SI
0060++ 1051             ; str2 in DI
0061++ 1051             ; SI points to end of source string
0062++ 1051             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1051             _strstr:
0064++ 1051 DB          	push al
0065++ 1052 DA          	push d
0066++ 1053 E3          	push di
0067++ 1054             _strstr_loop:
0068++ 1054 F3          	cmpsb					; compare a byte of the strings
0069++ 1055 C7 60 10    	jne _strstr_ret
0070++ 1058 FC 00 00    	lea d, [di + 0]
0071++ 105B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 105D C7 54 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1060             _strstr_ret:
0074++ 1060 F0          	pop di
0075++ 1061 E7          	pop d
0076++ 1062 E8          	pop al
0077++ 1063 09          	ret
0078++ 1064             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1064             ; length of null terminated string
0080++ 1064             ; result in C
0081++ 1064             ; pointer in D
0082++ 1064             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1064             _strlen:
0084++ 1064 DA          	push d
0085++ 1065 38 00 00    	mov c, 0
0086++ 1068             _strlen_L1:
0087++ 1068 BD 00       	cmp byte [d], 0
0088++ 106A C6 72 10    	je _strlen_ret
0089++ 106D 79          	inc d
0090++ 106E 78          	inc c
0091++ 106F 0A 68 10    	jmp _strlen_L1
0092++ 1072             _strlen_ret:
0093++ 1072 E7          	pop d
0094++ 1073 09          	ret
0095++ 1074             
0096++ 1074             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1074             ; STRCMP
0098++ 1074             ; compare two strings
0099++ 1074             ; str1 in SI
0100++ 1074             ; str2 in DI
0101++ 1074             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1074             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1074             _strcmp:
0104++ 1074 DB          	push al
0105++ 1075 DA          	push d
0106++ 1076 E3          	push di
0107++ 1077 E2          	push si
0108++ 1078             _strcmp_loop:
0109++ 1078 F3          	cmpsb					; compare a byte of the strings
0110++ 1079 C7 84 10    	jne _strcmp_ret
0111++ 107C FB FF FF    	lea d, [si +- 1]
0112++ 107F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1081 C7 78 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1084             _strcmp_ret:
0115++ 1084 EF          	pop si
0116++ 1085 F0          	pop di
0117++ 1086 E7          	pop d
0118++ 1087 E8          	pop al
0119++ 1088 09          	ret
0120++ 1089             
0121++ 1089             
0122++ 1089             ; STRCPY
0123++ 1089             ; copy null terminated string from SI to DI
0124++ 1089             ; source in SI
0125++ 1089             ; destination in DI
0126++ 1089             _strcpy:
0127++ 1089 E2          	push si
0128++ 108A E3          	push di
0129++ 108B DB          	push al
0130++ 108C             _strcpy_L1:
0131++ 108C F6          	lodsb
0132++ 108D F7          	stosb
0133++ 108E B9 00       	cmp al, 0
0134++ 1090 C7 8C 10    	jne _strcpy_L1
0135++ 1093             _strcpy_end:
0136++ 1093 E8          	pop al
0137++ 1094 F0          	pop di
0138++ 1095 EF          	pop si
0139++ 1096 09          	ret
0140++ 1097             
0141++ 1097             ; STRCAT
0142++ 1097             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1097             ; source in SI
0144++ 1097             ; destination in DI
0145++ 1097             _strcat:
0146++ 1097 E2          	push si
0147++ 1098 E3          	push di
0148++ 1099 D7          	push a
0149++ 109A DA          	push d
0150++ 109B 50          	mov a, di
0151++ 109C 3C          	mov d, a
0152++ 109D             _strcat_goto_end_L1:
0153++ 109D BD 00       	cmp byte[d], 0
0154++ 109F C6 A6 10    	je _strcat_start
0155++ 10A2 79          	inc d
0156++ 10A3 0A 9D 10    	jmp _strcat_goto_end_L1
0157++ 10A6             _strcat_start:
0158++ 10A6 FD 50       	mov di, d
0159++ 10A8             _strcat_L1:
0160++ 10A8 F6          	lodsb
0161++ 10A9 F7          	stosb
0162++ 10AA B9 00       	cmp al, 0
0163++ 10AC C7 A8 10    	jne _strcat_L1
0164++ 10AF             _strcat_end:
0165++ 10AF E7          	pop d
0166++ 10B0 E4          	pop a
0167++ 10B1 F0          	pop di
0168++ 10B2 EF          	pop si
0169++ 10B3 09          	ret
0170++ 10B4             
0171++ 10B4             
0005+  10B4             
0006+  10B4             
0007+  10B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  10B4             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  10B4             ; ASCII in BL
0010+  10B4             ; result in AL
0011+  10B4             ; ascii for F = 0100 0110
0012+  10B4             ; ascii for 9 = 0011 1001
0013+  10B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  10B4             hex_ascii_encode:
0015+  10B4 1B            mov al, bl
0016+  10B5 93 40         test al, $40        ; test if letter or number
0017+  10B7 C7 BD 10      jnz hex_letter
0018+  10BA 87 0F         and al, $0F        ; get number
0019+  10BC 09            ret
0020+  10BD             hex_letter:
0021+  10BD 87 0F         and al, $0F        ; get letter
0022+  10BF 6A 09         add al, 9
0023+  10C1 09            ret
0024+  10C2             
0025+  10C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  10C2             ; ATOI
0027+  10C2             ; 2 letter hex string in B
0028+  10C2             ; 8bit integer returned in AL
0029+  10C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  10C2             _atoi:
0031+  10C2 D8            push b
0032+  10C3 07 B4 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  10C6 30            mov bl, bh
0034+  10C7 DB            push al          ; save a
0035+  10C8 07 B4 10      call hex_ascii_encode
0036+  10CB EA            pop bl  
0037+  10CC FD 9E 04      shl al, 4
0038+  10CF 8C            or al, bl
0039+  10D0 E5            pop b
0040+  10D1 09            ret  
0041+  10D2             
0042+  10D2             
0043+  10D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  10D2             ; scanf
0045+  10D2             ; no need for explanations!
0046+  10D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  10D2             scanf:
0048+  10D2 09            ret
0049+  10D3             
0050+  10D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  10D3             ; ITOA
0052+  10D3             ; 8bit value in BL
0053+  10D3             ; 2 byte ASCII result in A
0054+  10D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  10D3             _itoa:
0056+  10D3 DA            push d
0057+  10D4 D8            push b
0058+  10D5 A7 00         mov bh, 0
0059+  10D7 FD A4 04      shr bl, 4  
0060+  10DA 74            mov d, b
0061+  10DB 1F 83 13      mov al, [d + s_hex_digits]
0062+  10DE 23            mov ah, al
0063+  10DF               
0064+  10DF E5            pop b
0065+  10E0 D8            push b
0066+  10E1 A7 00         mov bh, 0
0067+  10E3 FD 87 0F      and bl, $0F
0068+  10E6 74            mov d, b
0069+  10E7 1F 83 13      mov al, [d + s_hex_digits]
0070+  10EA E5            pop b
0071+  10EB E7            pop d
0072+  10EC 09            ret
0073+  10ED             
0074+  10ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  10ED             ; HEX STRING TO BINARY
0076+  10ED             ; di = destination address
0077+  10ED             ; si = source
0078+  10ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  10ED             _hex_to_int:
0080+  10ED             _hex_to_int_L1:
0081+  10ED F6            lodsb          ; load from [SI] to AL
0082+  10EE B9 00         cmp al, 0        ; check if ASCII 0
0083+  10F0 C6 FD 10      jz _hex_to_int_ret
0084+  10F3 36            mov bh, al
0085+  10F4 F6            lodsb
0086+  10F5 2F            mov bl, al
0087+  10F6 07 C2 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  10F9 F7            stosb          ; store AL to [DI]
0089+  10FA 0A ED 10      jmp _hex_to_int_L1
0090+  10FD             _hex_to_int_ret:
0091+  10FD 09            ret    
0092+  10FE             
0093+  10FE             
0094+  10FE             
0095+  10FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  10FE             ; GETCHAR
0097+  10FE             ; char in ah
0098+  10FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  10FE             getch:
0100+  10FE DB            push al
0101+  10FF             getch_retry:
0102+  10FF 19 01         mov al, 1
0103+  1101 05 03         syscall sys_io      ; receive in AH
0104+  1103 E8            pop al
0105+  1104 09            ret
0106+  1105             
0107+  1105             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  1105             ; PUTCHAR
0109+  1105             ; char in ah
0110+  1105             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  1105             _putchar:
0112+  1105 D7            push a
0113+  1106 19 00         mov al, 0
0114+  1108 05 03         syscall sys_io      ; char in AH
0115+  110A E4            pop a
0116+  110B 09            ret
0117+  110C             
0118+  110C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  110C             ;; INPUT A STRING
0120+  110C             ;; terminates with null
0121+  110C             ;; pointer in D
0122+  110C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  110C             _gets:
0124+  110C D7            push a
0125+  110D DA            push d
0126+  110E             _gets_loop:
0127+  110E 19 01         mov al, 1
0128+  1110 05 03         syscall sys_io      ; receive in AH
0129+  1112 B9 00         cmp al, 0        ; check error code (AL)
0130+  1114 C6 0E 11      je _gets_loop      ; if no char received, retry
0131+  1117             
0132+  1117 76 1B         cmp ah, 27
0133+  1119 C6 3A 11      je _gets_ansi_esc
0134+  111C 76 0A         cmp ah, $0A        ; LF
0135+  111E C6 A5 11      je _gets_end
0136+  1121 76 0D         cmp ah, $0D        ; CR
0137+  1123 C6 A5 11      je _gets_end
0138+  1126 76 5C         cmp ah, $5C        ; '\\'
0139+  1128 C6 66 11      je _gets_escape
0140+  112B               
0141+  112B 76 08         cmp ah, $08      ; check for backspace
0142+  112D C6 36 11      je _gets_backspace
0143+  1130             
0144+  1130 1A            mov al, ah
0145+  1131 3E            mov [d], al
0146+  1132 79            inc d
0147+  1133 0A 0E 11      jmp _gets_loop
0148+  1136             _gets_backspace:
0149+  1136 7F            dec d
0150+  1137 0A 0E 11      jmp _gets_loop
0151+  113A             _gets_ansi_esc:
0152+  113A 19 01         mov al, 1
0153+  113C 05 03         syscall sys_io        ; receive in AH without echo
0154+  113E B9 00         cmp al, 0          ; check error code (AL)
0155+  1140 C6 3A 11      je _gets_ansi_esc    ; if no char received, retry
0156+  1143 76 5B         cmp ah, '['
0157+  1145 C7 0E 11      jne _gets_loop
0158+  1148             _gets_ansi_esc_2:
0159+  1148 19 01         mov al, 1
0160+  114A 05 03         syscall sys_io          ; receive in AH without echo
0161+  114C B9 00         cmp al, 0            ; check error code (AL)
0162+  114E C6 48 11      je _gets_ansi_esc_2  ; if no char received, retry
0163+  1151 76 44         cmp ah, 'D'
0164+  1153 C6 5E 11      je _gets_left_arrow
0165+  1156 76 43         cmp ah, 'C'
0166+  1158 C6 62 11      je _gets_right_arrow
0167+  115B 0A 0E 11      jmp _gets_loop
0168+  115E             _gets_left_arrow:
0169+  115E 7F            dec d
0170+  115F 0A 0E 11      jmp _gets_loop
0171+  1162             _gets_right_arrow:
0172+  1162 79            inc d
0173+  1163 0A 0E 11      jmp _gets_loop
0174+  1166             _gets_escape:
0175+  1166 19 01         mov al, 1
0176+  1168 05 03         syscall sys_io      ; receive in AH
0177+  116A B9 00         cmp al, 0        ; check error code (AL)
0178+  116C C6 66 11      je _gets_escape      ; if no char received, retry
0179+  116F 76 6E         cmp ah, 'n'
0180+  1171 C6 90 11      je _gets_LF
0181+  1174 76 72         cmp ah, 'r'
0182+  1176 C6 97 11      je _gets_CR
0183+  1179 76 30         cmp ah, '0'
0184+  117B C6 9E 11      je _gets_NULL
0185+  117E 76 5C         cmp ah, $5C  ; '\'
0186+  1180 C6 89 11      je _gets_slash
0187+  1183 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  1184 3E            mov [d], al
0189+  1185 79            inc d
0190+  1186 0A 0E 11      jmp _gets_loop
0191+  1189             _gets_slash:
0192+  1189 19 5C         mov al, $5C
0193+  118B 3E            mov [d], al
0194+  118C 79            inc d
0195+  118D 0A 0E 11      jmp _gets_loop
0196+  1190             _gets_LF:
0197+  1190 19 0A         mov al, $0A
0198+  1192 3E            mov [d], al
0199+  1193 79            inc d
0200+  1194 0A 0E 11      jmp _gets_loop
0201+  1197             _gets_CR:
0202+  1197 19 0D         mov al, $0D
0203+  1199 3E            mov [d], al
0204+  119A 79            inc d
0205+  119B 0A 0E 11      jmp _gets_loop
0206+  119E             _gets_NULL:
0207+  119E 19 00         mov al, $00
0208+  11A0 3E            mov [d], al
0209+  11A1 79            inc d
0210+  11A2 0A 0E 11      jmp _gets_loop
0211+  11A5             _gets_end:
0212+  11A5 19 00         mov al, 0
0213+  11A7 3E            mov [d], al        ; terminate string
0214+  11A8 E7            pop d
0215+  11A9 E4            pop a
0216+  11AA 09            ret
0217+  11AB             
0218+  11AB             
0219+  11AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  11AB             ;; INPUT TEXT
0221+  11AB             ;; terminated with CTRL+D
0222+  11AB             ;; pointer in D
0223+  11AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  11AB             _gettxt:
0225+  11AB D7            push a
0226+  11AC DA            push d
0227+  11AD             _gettxt_loop:
0228+  11AD 19 01         mov al, 1
0229+  11AF 05 03         syscall sys_io      ; receive in AH
0230+  11B1 B9 00         cmp al, 0        ; check error code (AL)
0231+  11B3 C6 AD 11      je _gettxt_loop    ; if no char received, retry
0232+  11B6 76 04         cmp ah, 4      ; EOT
0233+  11B8 C6 F6 11      je _gettxt_end
0234+  11BB 76 08         cmp ah, $08      ; check for backspace
0235+  11BD C6 F2 11      je _gettxt_backspace
0236+  11C0 76 5C         cmp ah, $5C        ; '\'
0237+  11C2 C6 CB 11      je _gettxt_escape
0238+  11C5 1A            mov al, ah
0239+  11C6 3E            mov [d], al
0240+  11C7 79            inc d
0241+  11C8 0A AD 11      jmp _gettxt_loop
0242+  11CB             _gettxt_escape:
0243+  11CB 19 01         mov al, 1
0244+  11CD 05 03         syscall sys_io      ; receive in AH
0245+  11CF B9 00         cmp al, 0        ; check error code (AL)
0246+  11D1 C6 CB 11      je _gettxt_escape    ; if no char received, retry
0247+  11D4 76 6E         cmp ah, 'n'
0248+  11D6 C6 E4 11      je _gettxt_LF
0249+  11D9 76 72         cmp ah, 'r'
0250+  11DB C6 EB 11      je _gettxt_CR
0251+  11DE 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  11DF 3E            mov [d], al
0253+  11E0 79            inc d
0254+  11E1 0A AD 11      jmp _gettxt_loop
0255+  11E4             _gettxt_LF:
0256+  11E4 19 0A         mov al, $0A
0257+  11E6 3E            mov [d], al
0258+  11E7 79            inc d
0259+  11E8 0A AD 11      jmp _gettxt_loop
0260+  11EB             _gettxt_CR:
0261+  11EB 19 0D         mov al, $0D
0262+  11ED 3E            mov [d], al
0263+  11EE 79            inc d
0264+  11EF 0A AD 11      jmp _gettxt_loop
0265+  11F2             _gettxt_backspace:
0266+  11F2 7F            dec d
0267+  11F3 0A AD 11      jmp _gettxt_loop
0268+  11F6             _gettxt_end:
0269+  11F6 19 00         mov al, 0
0270+  11F8 3E            mov [d], al        ; terminate string
0271+  11F9 E7            pop d
0272+  11FA E4            pop a
0273+  11FB 09            ret
0274+  11FC             
0275+  11FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  11FC             ; PRINT NEW LINE
0277+  11FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  11FC             printnl:
0279+  11FC D7            push a
0280+  11FD 10 00 0A      mov a, $0A00
0281+  1200 05 03         syscall sys_io
0282+  1202 10 00 0D      mov a, $0D00
0283+  1205 05 03         syscall sys_io
0284+  1207 E4            pop a
0285+  1208 09            ret
0286+  1209             
0287+  1209             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  1209             ; _strtoint
0289+  1209             ; 4 digit hex string number in d
0290+  1209             ; integer returned in A
0291+  1209             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  1209             _strtointx:
0293+  1209 D8            push b
0294+  120A 32            mov bl, [d]
0295+  120B 37            mov bh, bl
0296+  120C 33 01 00      mov bl, [d + 1]
0297+  120F 07 C2 10      call _atoi        ; convert to int in AL
0298+  1212 23            mov ah, al        ; move to AH
0299+  1213 33 02 00      mov bl, [d + 2]
0300+  1216 37            mov bh, bl
0301+  1217 33 03 00      mov bl, [d + 3]
0302+  121A 07 C2 10      call _atoi        ; convert to int in AL
0303+  121D E5            pop b
0304+  121E 09            ret
0305+  121F             
0306+  121F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  121F             ; _strtoint
0308+  121F             ; 5 digit base10 string number in d
0309+  121F             ; integer returned in A
0310+  121F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  121F             _strtoint:
0312+  121F E2            push si
0313+  1220 D8            push b
0314+  1221 D9            push c
0315+  1222 DA            push d
0316+  1223 07 64 10      call _strlen      ; get string length in C
0317+  1226 7E            dec c
0318+  1227 FD 4E         mov si, d
0319+  1229 12            mov a, c
0320+  122A FD 99         shl a
0321+  122C 3B 9B 13      mov d, table_power
0322+  122F 59            add d, a
0323+  1230 38 00 00      mov c, 0
0324+  1233             _strtoint_L0:
0325+  1233 F6            lodsb      ; load ASCII to al
0326+  1234 B9 00         cmp al, 0
0327+  1236 C6 49 12      je _strtoint_end
0328+  1239 6F 30         sub al, $30    ; make into integer
0329+  123B 22 00         mov ah, 0
0330+  123D 2A            mov b, [d]
0331+  123E AC            mul a, b      ; result in B since it fits in 16bits
0332+  123F 11            mov a, b
0333+  1240 28            mov b, c
0334+  1241 54            add a, b
0335+  1242 39            mov c, a
0336+  1243 63 02 00      sub d, 2
0337+  1246 0A 33 12      jmp _strtoint_L0
0338+  1249             _strtoint_end:
0339+  1249 12            mov a, c
0340+  124A E7            pop d
0341+  124B E6            pop c
0342+  124C E5            pop b
0343+  124D EF            pop si
0344+  124E 09            ret
0345+  124F             
0346+  124F             
0347+  124F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  124F             ; PRINT NULL TERMINATED STRING
0349+  124F             ; pointer in D
0350+  124F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  124F             _puts:
0352+  124F D7            push a
0353+  1250 DA            push d
0354+  1251             _puts_L1:
0355+  1251 1E            mov al, [d]
0356+  1252 B9 00         cmp al, 0
0357+  1254 C6 60 12      jz _puts_END
0358+  1257 23            mov ah, al
0359+  1258 19 00         mov al, 0
0360+  125A 05 03         syscall sys_io
0361+  125C 79            inc d
0362+  125D 0A 51 12      jmp _puts_L1
0363+  1260             _puts_END:
0364+  1260 E7            pop d
0365+  1261 E4            pop a
0366+  1262 09            ret
0367+  1263             
0368+  1263             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  1263             ; PRINT N SIZE STRING
0370+  1263             ; pointer in D
0371+  1263             ; size in C
0372+  1263             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  1263             _putsn:
0374+  1263 DB            push al
0375+  1264 DA            push d
0376+  1265 D9            push c
0377+  1266             _putsn_L0:
0378+  1266 1E            mov al, [d]
0379+  1267 23            mov ah, al
0380+  1268 19 00         mov al, 0
0381+  126A 05 03         syscall sys_io
0382+  126C 79            inc d
0383+  126D 7E            dec c  
0384+  126E C2 00 00      cmp c, 0
0385+  1271 C7 66 12      jne _putsn_L0
0386+  1274             _putsn_end:
0387+  1274 E6            pop c
0388+  1275 E7            pop d
0389+  1276 E8            pop al
0390+  1277 09            ret
0391+  1278             
0392+  1278             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1278             ; print 16bit decimal number
0394+  1278             ; input number in A
0395+  1278             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1278             print_u16d:
0397+  1278 D7            push a
0398+  1279 D8            push b
0399+  127A 26 10 27      mov b, 10000
0400+  127D AE            div a, b      ; get 10000's coeff.
0401+  127E 07 A0 12      call print_number
0402+  1281 11            mov a, b
0403+  1282 26 E8 03      mov b, 1000
0404+  1285 AE            div a, b      ; get 1000's coeff.
0405+  1286 07 A0 12      call print_number
0406+  1289 11            mov a, b
0407+  128A 26 64 00      mov b, 100
0408+  128D AE            div a, b
0409+  128E 07 A0 12      call print_number
0410+  1291 11            mov a, b
0411+  1292 26 0A 00      mov b, 10
0412+  1295 AE            div a, b
0413+  1296 07 A0 12      call print_number
0414+  1299 1B            mov al, bl      ; 1's coeff in bl
0415+  129A 07 A0 12      call print_number
0416+  129D E5            pop b
0417+  129E E4            pop a
0418+  129F 09            ret
0419+  12A0             
0420+  12A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  12A0             ; print AL
0422+  12A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  12A0             print_number:
0424+  12A0 6A 30         add al, $30
0425+  12A2 23            mov ah, al
0426+  12A3 07 05 11      call _putchar
0427+  12A6 09            ret
0428+  12A7             
0429+  12A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  12A7             ; PRINT 16BIT HEX INTEGER
0431+  12A7             ; integer value in reg B
0432+  12A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  12A7             print_u16x:
0434+  12A7 D7            push a
0435+  12A8 D8            push b
0436+  12A9 DD            push bl
0437+  12AA 30            mov bl, bh
0438+  12AB 07 D3 10      call _itoa        ; convert bh to char in A
0439+  12AE 2F            mov bl, al        ; save al
0440+  12AF 19 00         mov al, 0
0441+  12B1 05 03         syscall sys_io        ; display AH
0442+  12B3 24            mov ah, bl        ; retrieve al
0443+  12B4 19 00         mov al, 0
0444+  12B6 05 03         syscall sys_io        ; display AL
0445+  12B8             
0446+  12B8 EA            pop bl
0447+  12B9 07 D3 10      call _itoa        ; convert bh to char in A
0448+  12BC 2F            mov bl, al        ; save al
0449+  12BD 19 00         mov al, 0
0450+  12BF 05 03         syscall sys_io        ; display AH
0451+  12C1 24            mov ah, bl        ; retrieve al
0452+  12C2 19 00         mov al, 0
0453+  12C4 05 03         syscall sys_io        ; display AL
0454+  12C6             
0455+  12C6 E5            pop b
0456+  12C7 E4            pop a
0457+  12C8 09            ret
0458+  12C9             
0459+  12C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  12C9             ; INPUT 16BIT HEX INTEGER
0461+  12C9             ; read 16bit integer into A
0462+  12C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  12C9             scan_u16x:
0464+  12C9 F8 10 00      enter 16
0465+  12CC D8            push b
0466+  12CD DA            push d
0467+  12CE             
0468+  12CE FA F1 FF      lea d, [bp + -15]
0469+  12D1 07 0C 11      call _gets        ; get number
0470+  12D4             
0471+  12D4 32            mov bl, [d]
0472+  12D5 37            mov bh, bl
0473+  12D6 33 01 00      mov bl, [d + 1]
0474+  12D9 07 C2 10      call _atoi        ; convert to int in AL
0475+  12DC 23            mov ah, al        ; move to AH
0476+  12DD             
0477+  12DD 33 02 00      mov bl, [d + 2]
0478+  12E0 37            mov bh, bl
0479+  12E1 33 03 00      mov bl, [d + 3]
0480+  12E4 07 C2 10      call _atoi        ; convert to int in AL
0481+  12E7             
0482+  12E7 E7            pop d
0483+  12E8 E5            pop b
0484+  12E9 F9            leave
0485+  12EA 09            ret
0486+  12EB             
0487+  12EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  12EB             ; PRINT 8bit HEX INTEGER
0489+  12EB             ; integer value in reg bl
0490+  12EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  12EB             print_u8x:
0492+  12EB D7            push a
0493+  12EC DD            push bl
0494+  12ED             
0495+  12ED 07 D3 10      call _itoa        ; convert bl to char in A
0496+  12F0 2F            mov bl, al        ; save al
0497+  12F1 19 00         mov al, 0
0498+  12F3 05 03         syscall sys_io        ; display AH
0499+  12F5 24            mov ah, bl        ; retrieve al
0500+  12F6 19 00         mov al, 0
0501+  12F8 05 03         syscall sys_io        ; display AL
0502+  12FA             
0503+  12FA EA            pop bl
0504+  12FB E4            pop a
0505+  12FC 09            ret
0506+  12FD             
0507+  12FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  12FD             ; print 8bit decimal unsigned number
0509+  12FD             ; input number in AL
0510+  12FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  12FD             print_u8d:
0512+  12FD D7            push a
0513+  12FE D8            push b
0514+  12FF             
0515+  12FF 22 00         mov ah, 0
0516+  1301 26 64 00      mov b, 100
0517+  1304 AE            div a, b
0518+  1305 D8            push b      ; save remainder
0519+  1306 B9 00         cmp al, 0
0520+  1308 C6 12 13      je skip100
0521+  130B 6A 30         add al, $30
0522+  130D 23            mov ah, al
0523+  130E 19 00         mov al, 0
0524+  1310 05 03         syscall sys_io  ; print coeff
0525+  1312             skip100:
0526+  1312 E4            pop a
0527+  1313 22 00         mov ah, 0
0528+  1315 26 0A 00      mov b, 10
0529+  1318 AE            div a, b
0530+  1319 D8            push b      ; save remainder
0531+  131A B9 00         cmp al, 0
0532+  131C C6 26 13      je skip10
0533+  131F 6A 30         add al, $30
0534+  1321 23            mov ah, al
0535+  1322 19 00         mov al, 0
0536+  1324 05 03         syscall sys_io  ; print coeff
0537+  1326             skip10:
0538+  1326 E4            pop a
0539+  1327 1B            mov al, bl
0540+  1328 6A 30         add al, $30
0541+  132A 23            mov ah, al
0542+  132B 19 00         mov al, 0
0543+  132D 05 03         syscall sys_io  ; print coeff
0544+  132F E5            pop b
0545+  1330 E4            pop a
0546+  1331 09            ret
0547+  1332             
0548+  1332             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  1332             ; INPUT 8BIT HEX INTEGER
0550+  1332             ; read 8bit integer into AL
0551+  1332             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  1332             scan_u8x:
0553+  1332 F8 04 00      enter 4
0554+  1335 D8            push b
0555+  1336 DA            push d
0556+  1337             
0557+  1337 FA FD FF      lea d, [bp + -3]
0558+  133A 07 0C 11      call _gets        ; get number
0559+  133D             
0560+  133D 32            mov bl, [d]
0561+  133E 37            mov bh, bl
0562+  133F 33 01 00      mov bl, [d + 1]
0563+  1342 07 C2 10      call _atoi        ; convert to int in AL
0564+  1345             
0565+  1345 E7            pop d
0566+  1346 E5            pop b
0567+  1347 F9            leave
0568+  1348 09            ret
0569+  1349             
0570+  1349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  1349             ; input decimal number
0572+  1349             ; result in A
0573+  1349             ; 655'\0'
0574+  1349             ; low--------high
0575+  1349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  1349             scan_u16d:
0577+  1349 F8 08 00      enter 8
0578+  134C E2            push si
0579+  134D D8            push b
0580+  134E D9            push c
0581+  134F DA            push d
0582+  1350 FA F9 FF      lea d, [bp +- 7]
0583+  1353 07 0C 11      call _gets
0584+  1356 07 64 10      call _strlen      ; get string length in C
0585+  1359 7E            dec c
0586+  135A FD 4E         mov si, d
0587+  135C 12            mov a, c
0588+  135D FD 99         shl a
0589+  135F 3B 9B 13      mov d, table_power
0590+  1362 59            add d, a
0591+  1363 38 00 00      mov c, 0
0592+  1366             mul_loop:
0593+  1366 F6            lodsb      ; load ASCII to al
0594+  1367 B9 00         cmp al, 0
0595+  1369 C6 7C 13      je mul_exit
0596+  136C 6F 30         sub al, $30    ; make into integer
0597+  136E 22 00         mov ah, 0
0598+  1370 2A            mov b, [d]
0599+  1371 AC            mul a, b      ; result in B since it fits in 16bits
0600+  1372 11            mov a, b
0601+  1373 28            mov b, c
0602+  1374 54            add a, b
0603+  1375 39            mov c, a
0604+  1376 63 02 00      sub d, 2
0605+  1379 0A 66 13      jmp mul_loop
0606+  137C             mul_exit:
0607+  137C 12            mov a, c
0608+  137D E7            pop d
0609+  137E E6            pop c
0610+  137F E5            pop b
0611+  1380 EF            pop si
0612+  1381 F9            leave
0613+  1382 09            ret
0614+  1383             
0615+  1383             
0616+  1383 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1387 34 35 36 37 
0616+  138B 38 39 41 42 
0616+  138F 43 44 45 46 
0617+  1393 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1397 1B 5B 48 00 
0618+  139B             
0619+  139B             table_power:
0620+  139B 01 00         .dw 1
0621+  139D 0A 00         .dw 10
0622+  139F 64 00         .dw 100
0623+  13A1 E8 03         .dw 1000
0624+  13A3 10 27         .dw 100002223   13A5             ; --- END INLINE ASM BLOCK
2224   13A5             
2225   13A5 F9            leave
2226   13A6 09            ret
2227   13A7             
2228   13A7             gcd:
2229   13A7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2230   13AA             ;; if (b == 0) { 
2231   13AA             _if27_cond:
2232   13AA FA 05 00      lea d, [bp + 5] ; $b
2233   13AD 2A            mov b, [d]
2234   13AE             ; START RELATIONAL
2235   13AE D7            push a
2236   13AF 11            mov a, b
2237   13B0 26 00 00      mov b, $0
2238   13B3 B0            cmp a, b
2239   13B4 FD 71         seq ; ==
2240   13B6 E4            pop a
2241   13B7             ; END RELATIONAL
2242   13B7 C0 00 00      cmp b, 0
2243   13BA C6 C6 13      je _if27_exit
2244   13BD             _if27_true:
2245   13BD             ;; return a; 
2246   13BD FA 07 00      lea d, [bp + 7] ; $a
2247   13C0 2A            mov b, [d]
2248   13C1 F9            leave
2249   13C2 09            ret
2250   13C3 0A C6 13      jmp _if27_exit
2251   13C6             _if27_exit:
2252   13C6             ;; return gcd(b, a % b); 
2253   13C6 FA 05 00      lea d, [bp + 5] ; $b
2254   13C9 2A            mov b, [d]
2255   13CA FD AB         swp b
2256   13CC D8            push b
2257   13CD FA 07 00      lea d, [bp + 7] ; $a
2258   13D0 2A            mov b, [d]
2259   13D1             ; START FACTORS
2260   13D1 D7            push a
2261   13D2 11            mov a, b
2262   13D3 FA 05 00      lea d, [bp + 5] ; $b
2263   13D6 2A            mov b, [d]
2264   13D7 AE            div a, b ; 
2265   13D8 11            mov a, b
2266   13D9 27            mov b, a
2267   13DA E4            pop a
2268   13DB             ; END FACTORS
2269   13DB FD AB         swp b
2270   13DD D8            push b
2271   13DE 07 A7 13      call gcd
2272   13E1 51 04 00      add sp, 4
2273   13E4 F9            leave
2274   13E5 09            ret
2275   13E6             
2276   13E6             mod_exp:
2277   13E6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2278   13E9             ; $result 
2279   13E9 52 02 00      sub sp, 2
2280   13EC             ;; result = 1; 
2281   13EC FA FF FF      lea d, [bp + -1] ; $result
2282   13EF DA            push d
2283   13F0 26 01 00      mov b, $1
2284   13F3 E7            pop d
2285   13F4 FD 43         mov [d], b
2286   13F6             ;; while (exp > 0) { 
2287   13F6             _while28_cond:
2288   13F6 FA 07 00      lea d, [bp + 7] ; $exp
2289   13F9 2A            mov b, [d]
2290   13FA             ; START RELATIONAL
2291   13FA D7            push a
2292   13FB 11            mov a, b
2293   13FC 26 00 00      mov b, $0
2294   13FF B0            cmp a, b
2295   1400 FD 7F         sgt ; >
2296   1402 E4            pop a
2297   1403             ; END RELATIONAL
2298   1403 C0 00 00      cmp b, 0
2299   1406 C6 74 14      je _while28_exit
2300   1409             _while28_block:
2301   1409             ;; if (exp & 1) { 
2302   1409             _if29_cond:
2303   1409 FA 07 00      lea d, [bp + 7] ; $exp
2304   140C 2A            mov b, [d]
2305   140D D7            push a
2306   140E 11            mov a, b
2307   140F 26 01 00      mov b, $1
2308   1412 86            and a, b ; &
2309   1413 27            mov b, a
2310   1414 E4            pop a
2311   1415 C0 00 00      cmp b, 0
2312   1418 C6 3D 14      je _if29_exit
2313   141B             _if29_true:
2314   141B             ;; result = (result * base) % mod; 
2315   141B FA FF FF      lea d, [bp + -1] ; $result
2316   141E DA            push d
2317   141F FA FF FF      lea d, [bp + -1] ; $result
2318   1422 2A            mov b, [d]
2319   1423             ; START FACTORS
2320   1423 D7            push a
2321   1424 11            mov a, b
2322   1425 FA 09 00      lea d, [bp + 9] ; $base
2323   1428 2A            mov b, [d]
2324   1429 AC            mul a, b ; *
2325   142A 11            mov a, b
2326   142B 27            mov b, a
2327   142C E4            pop a
2328   142D             ; END FACTORS
2329   142D             ; START FACTORS
2330   142D D7            push a
2331   142E 11            mov a, b
2332   142F FA 05 00      lea d, [bp + 5] ; $mod
2333   1432 2A            mov b, [d]
2334   1433 AE            div a, b ; 
2335   1434 11            mov a, b
2336   1435 27            mov b, a
2337   1436 E4            pop a
2338   1437             ; END FACTORS
2339   1437 E7            pop d
2340   1438 FD 43         mov [d], b
2341   143A 0A 3D 14      jmp _if29_exit
2342   143D             _if29_exit:
2343   143D             ;; exp = exp >> 1; 
2344   143D FA 07 00      lea d, [bp + 7] ; $exp
2345   1440 DA            push d
2346   1441 FA 07 00      lea d, [bp + 7] ; $exp
2347   1444 2A            mov b, [d]
2348   1445             ; START SHIFT
2349   1445 D7            push a
2350   1446 11            mov a, b
2351   1447 26 01 00      mov b, $1
2352   144A FD 39         mov c, b
2353   144C A5            ashr a, cl
2354   144D 27            mov b, a
2355   144E E4            pop a
2356   144F             ; END SHIFT
2357   144F E7            pop d
2358   1450 FD 43         mov [d], b
2359   1452             ;; base = (base * base) % mod; 
2360   1452 FA 09 00      lea d, [bp + 9] ; $base
2361   1455 DA            push d
2362   1456 FA 09 00      lea d, [bp + 9] ; $base
2363   1459 2A            mov b, [d]
2364   145A             ; START FACTORS
2365   145A D7            push a
2366   145B 11            mov a, b
2367   145C FA 09 00      lea d, [bp + 9] ; $base
2368   145F 2A            mov b, [d]
2369   1460 AC            mul a, b ; *
2370   1461 11            mov a, b
2371   1462 27            mov b, a
2372   1463 E4            pop a
2373   1464             ; END FACTORS
2374   1464             ; START FACTORS
2375   1464 D7            push a
2376   1465 11            mov a, b
2377   1466 FA 05 00      lea d, [bp + 5] ; $mod
2378   1469 2A            mov b, [d]
2379   146A AE            div a, b ; 
2380   146B 11            mov a, b
2381   146C 27            mov b, a
2382   146D E4            pop a
2383   146E             ; END FACTORS
2384   146E E7            pop d
2385   146F FD 43         mov [d], b
2386   1471 0A F6 13      jmp _while28_cond
2387   1474             _while28_exit:
2388   1474             ;; return result; 
2389   1474 FA FF FF      lea d, [bp + -1] ; $result
2390   1477 2A            mov b, [d]
2391   1478 F9            leave
2392   1479 09            ret
2393   147A             
2394   147A             find_e:
2395   147A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2396   147D             ; $e 
2397   147D 52 02 00      sub sp, 2
2398   1480             ;; for (e = 2; e < phi; e++) { 
2399   1480             _for30_init:
2400   1480 FA FF FF      lea d, [bp + -1] ; $e
2401   1483 DA            push d
2402   1484 26 02 00      mov b, $2
2403   1487 E7            pop d
2404   1488 FD 43         mov [d], b
2405   148A             _for30_cond:
2406   148A FA FF FF      lea d, [bp + -1] ; $e
2407   148D 2A            mov b, [d]
2408   148E             ; START RELATIONAL
2409   148E D7            push a
2410   148F 11            mov a, b
2411   1490 FA 05 00      lea d, [bp + 5] ; $phi
2412   1493 2A            mov b, [d]
2413   1494 B0            cmp a, b
2414   1495 FD 73         slt ; < 
2415   1497 E4            pop a
2416   1498             ; END RELATIONAL
2417   1498 C0 00 00      cmp b, 0
2418   149B C6 DC 14      je _for30_exit
2419   149E             _for30_block:
2420   149E             ;; if (gcd(e, phi) == 1) { 
2421   149E             _if31_cond:
2422   149E FA FF FF      lea d, [bp + -1] ; $e
2423   14A1 2A            mov b, [d]
2424   14A2 FD AB         swp b
2425   14A4 D8            push b
2426   14A5 FA 05 00      lea d, [bp + 5] ; $phi
2427   14A8 2A            mov b, [d]
2428   14A9 FD AB         swp b
2429   14AB D8            push b
2430   14AC 07 A7 13      call gcd
2431   14AF 51 04 00      add sp, 4
2432   14B2             ; START RELATIONAL
2433   14B2 D7            push a
2434   14B3 11            mov a, b
2435   14B4 26 01 00      mov b, $1
2436   14B7 B0            cmp a, b
2437   14B8 FD 71         seq ; ==
2438   14BA E4            pop a
2439   14BB             ; END RELATIONAL
2440   14BB C0 00 00      cmp b, 0
2441   14BE C6 CA 14      je _if31_exit
2442   14C1             _if31_true:
2443   14C1             ;; return e; 
2444   14C1 FA FF FF      lea d, [bp + -1] ; $e
2445   14C4 2A            mov b, [d]
2446   14C5 F9            leave
2447   14C6 09            ret
2448   14C7 0A CA 14      jmp _if31_exit
2449   14CA             _if31_exit:
2450   14CA             _for30_update:
2451   14CA FA FF FF      lea d, [bp + -1] ; $e
2452   14CD 2A            mov b, [d]
2453   14CE FD 79         mov g, b
2454   14D0 FD 77         inc b
2455   14D2 FA FF FF      lea d, [bp + -1] ; $e
2456   14D5 FD 43         mov [d], b
2457   14D7 FD 27         mov b, g
2458   14D9 0A 8A 14      jmp _for30_cond
2459   14DC             _for30_exit:
2460   14DC             ;; return 0; 
2461   14DC 26 00 00      mov b, $0
2462   14DF F9            leave
2463   14E0 09            ret
2464   14E1             
2465   14E1             find_d:
2466   14E1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2467   14E4             ; $d 
2468   14E4 52 02 00      sub sp, 2
2469   14E7             ;; for (d = 2; d < phi; d++) { 
2470   14E7             _for32_init:
2471   14E7 FA FF FF      lea d, [bp + -1] ; $d
2472   14EA DA            push d
2473   14EB 26 02 00      mov b, $2
2474   14EE E7            pop d
2475   14EF FD 43         mov [d], b
2476   14F1             _for32_cond:
2477   14F1 FA FF FF      lea d, [bp + -1] ; $d
2478   14F4 2A            mov b, [d]
2479   14F5             ; START RELATIONAL
2480   14F5 D7            push a
2481   14F6 11            mov a, b
2482   14F7 FA 05 00      lea d, [bp + 5] ; $phi
2483   14FA 2A            mov b, [d]
2484   14FB B0            cmp a, b
2485   14FC FD 73         slt ; < 
2486   14FE E4            pop a
2487   14FF             ; END RELATIONAL
2488   14FF C0 00 00      cmp b, 0
2489   1502 C6 47 15      je _for32_exit
2490   1505             _for32_block:
2491   1505             ;; if ((d * e) % phi == 1) { 
2492   1505             _if33_cond:
2493   1505 FA FF FF      lea d, [bp + -1] ; $d
2494   1508 2A            mov b, [d]
2495   1509             ; START FACTORS
2496   1509 D7            push a
2497   150A 11            mov a, b
2498   150B FA 07 00      lea d, [bp + 7] ; $e
2499   150E 2A            mov b, [d]
2500   150F AC            mul a, b ; *
2501   1510 11            mov a, b
2502   1511 27            mov b, a
2503   1512 E4            pop a
2504   1513             ; END FACTORS
2505   1513             ; START FACTORS
2506   1513 D7            push a
2507   1514 11            mov a, b
2508   1515 FA 05 00      lea d, [bp + 5] ; $phi
2509   1518 2A            mov b, [d]
2510   1519 AE            div a, b ; 
2511   151A 11            mov a, b
2512   151B 27            mov b, a
2513   151C E4            pop a
2514   151D             ; END FACTORS
2515   151D             ; START RELATIONAL
2516   151D D7            push a
2517   151E 11            mov a, b
2518   151F 26 01 00      mov b, $1
2519   1522 B0            cmp a, b
2520   1523 FD 71         seq ; ==
2521   1525 E4            pop a
2522   1526             ; END RELATIONAL
2523   1526 C0 00 00      cmp b, 0
2524   1529 C6 35 15      je _if33_exit
2525   152C             _if33_true:
2526   152C             ;; return d; 
2527   152C FA FF FF      lea d, [bp + -1] ; $d
2528   152F 2A            mov b, [d]
2529   1530 F9            leave
2530   1531 09            ret
2531   1532 0A 35 15      jmp _if33_exit
2532   1535             _if33_exit:
2533   1535             _for32_update:
2534   1535 FA FF FF      lea d, [bp + -1] ; $d
2535   1538 2A            mov b, [d]
2536   1539 FD 79         mov g, b
2537   153B FD 77         inc b
2538   153D FA FF FF      lea d, [bp + -1] ; $d
2539   1540 FD 43         mov [d], b
2540   1542 FD 27         mov b, g
2541   1544 0A F1 14      jmp _for32_cond
2542   1547             _for32_exit:
2543   1547             ;; return 0; 
2544   1547 26 00 00      mov b, $0
2545   154A F9            leave
2546   154B 09            ret
2547   154C             ; --- END TEXT BLOCK
2548   154C             
2549   154C             ; --- BEGIN DATA BLOCK
2550   154C 50 75 62 6C __s0: .db "Public Key: (", 0
2550   1550 69 63 20 4B 
2550   1554 65 79 3A 20 
2550   1558 28 00 
2551   155A 2C 20 00    __s1: .db ", ", 0
2552   155D 29 0A 00    __s2: .db ")\n", 0
2553   1560 50 72 69 76 __s3: .db "Private Key: (", 0
2553   1564 61 74 65 20 
2553   1568 4B 65 79 3A 
2553   156C 20 28 00 
2554   156F 45 6E 74 65 __s4: .db "Enter a string: ", 0
2554   1573 72 20 61 20 
2554   1577 73 74 72 69 
2554   157B 6E 67 3A 20 
2554   157F 00 
2555   1580 45 6E 63 72 __s5: .db "Encrypted text: ", 0
2555   1584 79 70 74 65 
2555   1588 64 20 74 65 
2555   158C 78 74 3A 20 
2555   1590 00 
2556   1591 20 00       __s6: .db " ", 0
2557   1593 0A 00       __s7: .db "\n", 0
2558   1595 44 65 63 72 __s8: .db "Decrypted text: ", 0
2558   1599 79 70 74 65 
2558   159D 64 20 74 65 
2558   15A1 78 74 3A 20 
2558   15A5 00 
2559   15A6 55 6E 6B 6E __s9: .db "Unknown type size in va_arg() call. Size needs to be either 1 or 2.", 0
2559   15AA 6F 77 6E 20 
2559   15AE 74 79 70 65 
2559   15B2 20 73 69 7A 
2559   15B6 65 20 69 6E 
2559   15BA 20 76 61 5F 
2559   15BE 61 72 67 28 
2559   15C2 29 20 63 61 
2559   15C6 6C 6C 2E 20 
2559   15CA 53 69 7A 65 
2559   15CE 20 6E 65 65 
2559   15D2 64 73 20 74 
2559   15D6 6F 20 62 65 
2559   15DA 20 65 69 74 
2559   15DE 68 65 72 20 
2559   15E2 31 20 6F 72 
2559   15E6 20 32 2E 00 
2560   15EA 45 72 72 6F __s10: .db "Error: Unknown argument type.\n", 0
2560   15EE 72 3A 20 55 
2560   15F2 6E 6B 6E 6F 
2560   15F6 77 6E 20 61 
2560   15FA 72 67 75 6D 
2560   15FE 65 6E 74 20 
2560   1602 74 79 70 65 
2560   1606 2E 0A 00 
2561   1609 1B 5B 32 4A __s11: .db "\033[2J\033[H", 0
2561   160D 1B 5B 48 00 
2562   1611             
2563   1611 13 16       _heap_top: .dw _heap
2564   1613 00          _heap: .db 0
2565   1614             ; --- END DATA BLOCK
2566   1614             
2567   1614             .end
tasm: Number of errors = 0
