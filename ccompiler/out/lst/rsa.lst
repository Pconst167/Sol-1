0001   0000             ; --- FILENAME: programs/rsa.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; int p, q, n, phi, e, d; 
0011   0408 52 02 00      sub sp, 2
0012   040B 52 02 00      sub sp, 2
0013   040E 52 02 00      sub sp, 2
0014   0411 52 02 00      sub sp, 2
0015   0414 52 02 00      sub sp, 2
0016   0417 52 02 00      sub sp, 2
0017   041A             ; int i; 
0018   041A 52 02 00      sub sp, 2
0019   041D             ; char input_str[100]; 
0020   041D 52 64 00      sub sp, 100
0021   0420             ; int encrypted_chars[100]; 
0022   0420 52 C8 00      sub sp, 200
0023   0423             ; int encrypted_chars_len ; 
0024   0423 52 02 00      sub sp, 2
0025   0426             ; int decrypted_char; 
0026   0426 52 02 00      sub sp, 2
0027   0429             ; char c; 
0028   0429 52 01 00      sub sp, 1
0029   042C             ; p = 13; 
0030   042C FA FF FF      lea d, [bp + -1] ; $p
0031   042F DA            push d
0032   0430 FD 2E 0D 00   mov32 cb, $0000000d
0032   0434 00 00 
0033   0436 E7            pop d
0034   0437 FD 43         mov [d], b
0035   0439             ; q = 11; 
0036   0439 FA FD FF      lea d, [bp + -3] ; $q
0037   043C DA            push d
0038   043D FD 2E 0B 00   mov32 cb, $0000000b
0038   0441 00 00 
0039   0443 E7            pop d
0040   0444 FD 43         mov [d], b
0041   0446             ; n = p * q; 
0042   0446 FA FB FF      lea d, [bp + -5] ; $n
0043   0449 DA            push d
0044   044A FA FF FF      lea d, [bp + -1] ; $p
0045   044D 2A            mov b, [d]
0046   044E 38 00 00      mov c, 0
0047   0451             ; --- START FACTORS
0048   0451 D7            push a
0049   0452 FD D8         push g
0050   0454 11            mov a, b
0051   0455 FD 7A         mov g, c
0052   0457 FA FD FF      lea d, [bp + -3] ; $q
0053   045A 2A            mov b, [d]
0054   045B 38 00 00      mov c, 0
0055   045E D7            push a     ; save left operand
0056   045F 8E            xor a, b   ; xor sign bits
0057   0460 FD AA         swp a      ; swap bytes
0058   0462 83            mov cl, al ; save result of xor into 'dl'
0059   0463 E4            pop a      ; restore left side operator
0060   0464 DF            push cl    ; save result of xor above
0061   0465 FD AA         swp a  
0062   0467 93 80         test al, $80  
0063   0469 FD AA         swp a  
0064   046B C6 70 04      jz skip_invert_a_2  
0065   046E FD 95         neg a 
0066   0470             skip_invert_a_2:   
0067   0470 FD AB         swp b
0068   0472 FD 93 80      test bl, $80  
0069   0475 FD AB         swp b
0070   0477 C6 7C 04      jz skip_invert_b_2  
0071   047A FD 97         neg b 
0072   047C             skip_invert_b_2:   
0073   047C AC            mul a, b ; *
0074   047D FD 78         mov g, a
0075   047F 11            mov a, b
0076   0480 EA            pop bl
0077   0481 FD 93 80      test bl, $80
0078   0484 C6 91 04      jz _same_signs_2
0079   0487 2F            mov bl, al
0080   0488 95            not a
0081   0489 FD 97         neg b
0082   048B 5B 00 00      adc a, 0
0083   048E FD 78         mov g, a
0084   0490 11            mov a, b
0085   0491             _same_signs_2:
0086   0491 FD 38         mov c, g
0087   0493 27            mov b, a
0088   0494 FD F1         pop g
0089   0496 E4            pop a
0090   0497             ; --- END FACTORS
0091   0497 E7            pop d
0092   0498 FD 43         mov [d], b
0093   049A             ; phi = (p - 1) * (q - 1); 
0094   049A FA F9 FF      lea d, [bp + -7] ; $phi
0095   049D DA            push d
0096   049E FA FF FF      lea d, [bp + -1] ; $p
0097   04A1 2A            mov b, [d]
0098   04A2 38 00 00      mov c, 0
0099   04A5             ; --- START TERMS
0100   04A5 D7            push a
0101   04A6 11            mov a, b
0102   04A7 FD 2E 01 00   mov32 cb, $00000001
0102   04AB 00 00 
0103   04AD 60            sub a, b
0104   04AE 27            mov b, a
0105   04AF E4            pop a
0106   04B0             ; --- END TERMS
0107   04B0             ; --- START FACTORS
0108   04B0 D7            push a
0109   04B1 FD D8         push g
0110   04B3 11            mov a, b
0111   04B4 FD 7A         mov g, c
0112   04B6 FA FD FF      lea d, [bp + -3] ; $q
0113   04B9 2A            mov b, [d]
0114   04BA 38 00 00      mov c, 0
0115   04BD             ; --- START TERMS
0116   04BD D7            push a
0117   04BE 11            mov a, b
0118   04BF FD 2E 01 00   mov32 cb, $00000001
0118   04C3 00 00 
0119   04C5 60            sub a, b
0120   04C6 27            mov b, a
0121   04C7 E4            pop a
0122   04C8             ; --- END TERMS
0123   04C8 D7            push a     ; save left operand
0124   04C9 8E            xor a, b   ; xor sign bits
0125   04CA FD AA         swp a      ; swap bytes
0126   04CC 83            mov cl, al ; save result of xor into 'dl'
0127   04CD E4            pop a      ; restore left side operator
0128   04CE DF            push cl    ; save result of xor above
0129   04CF FD AA         swp a  
0130   04D1 93 80         test al, $80  
0131   04D3 FD AA         swp a  
0132   04D5 C6 DA 04      jz skip_invert_a_4  
0133   04D8 FD 95         neg a 
0134   04DA             skip_invert_a_4:   
0135   04DA FD AB         swp b
0136   04DC FD 93 80      test bl, $80  
0137   04DF FD AB         swp b
0138   04E1 C6 E6 04      jz skip_invert_b_4  
0139   04E4 FD 97         neg b 
0140   04E6             skip_invert_b_4:   
0141   04E6 AC            mul a, b ; *
0142   04E7 FD 78         mov g, a
0143   04E9 11            mov a, b
0144   04EA EA            pop bl
0145   04EB FD 93 80      test bl, $80
0146   04EE C6 FB 04      jz _same_signs_4
0147   04F1 2F            mov bl, al
0148   04F2 95            not a
0149   04F3 FD 97         neg b
0150   04F5 5B 00 00      adc a, 0
0151   04F8 FD 78         mov g, a
0152   04FA 11            mov a, b
0153   04FB             _same_signs_4:
0154   04FB FD 38         mov c, g
0155   04FD 27            mov b, a
0156   04FE FD F1         pop g
0157   0500 E4            pop a
0158   0501             ; --- END FACTORS
0159   0501 E7            pop d
0160   0502 FD 43         mov [d], b
0161   0504             ; e = find_e(phi); 
0162   0504 FA F7 FF      lea d, [bp + -9] ; $e
0163   0507 DA            push d
0164   0508             ; --- START FUNCTION CALL
0165   0508 FA F9 FF      lea d, [bp + -7] ; $phi
0166   050B 2A            mov b, [d]
0167   050C 38 00 00      mov c, 0
0168   050F FD AB         swp b
0169   0511 D8            push b
0170   0512 07 F3 08      call find_e
0171   0515 51 02 00      add sp, 2
0172   0518             ; --- END FUNCTION CALL
0173   0518 E7            pop d
0174   0519 FD 43         mov [d], b
0175   051B             ; d = find_d(e, phi); 
0176   051B FA F5 FF      lea d, [bp + -11] ; $d
0177   051E DA            push d
0178   051F             ; --- START FUNCTION CALL
0179   051F FA F9 FF      lea d, [bp + -7] ; $phi
0180   0522 2A            mov b, [d]
0181   0523 38 00 00      mov c, 0
0182   0526 FD AB         swp b
0183   0528 D8            push b
0184   0529 FA F7 FF      lea d, [bp + -9] ; $e
0185   052C 2A            mov b, [d]
0186   052D 38 00 00      mov c, 0
0187   0530 FD AB         swp b
0188   0532 D8            push b
0189   0533 07 73 09      call find_d
0190   0536 51 04 00      add sp, 4
0191   0539             ; --- END FUNCTION CALL
0192   0539 E7            pop d
0193   053A FD 43         mov [d], b
0194   053C             ; printf("Public Key: %d, %d\n", n, e); 
0195   053C             ; --- START FUNCTION CALL
0196   053C FA F7 FF      lea d, [bp + -9] ; $e
0197   053F 2A            mov b, [d]
0198   0540 38 00 00      mov c, 0
0199   0543 FD AB         swp b
0200   0545 D8            push b
0201   0546 FA FB FF      lea d, [bp + -5] ; $n
0202   0549 2A            mov b, [d]
0203   054A 38 00 00      mov c, 0
0204   054D FD AB         swp b
0205   054F D8            push b
0206   0550 26 69 14      mov b, _s0 ; "Public Key: %d, %d\n"
0207   0553 FD AB         swp b
0208   0555 D8            push b
0209   0556 07 3F 0A      call printf
0210   0559 51 06 00      add sp, 6
0211   055C             ; --- END FUNCTION CALL
0212   055C             ; printf("Private Key: %d, %d\n", n, d); 
0213   055C             ; --- START FUNCTION CALL
0214   055C FA F5 FF      lea d, [bp + -11] ; $d
0215   055F 2A            mov b, [d]
0216   0560 38 00 00      mov c, 0
0217   0563 FD AB         swp b
0218   0565 D8            push b
0219   0566 FA FB FF      lea d, [bp + -5] ; $n
0220   0569 2A            mov b, [d]
0221   056A 38 00 00      mov c, 0
0222   056D FD AB         swp b
0223   056F D8            push b
0224   0570 26 7D 14      mov b, _s1 ; "Private Key: %d, %d\n"
0225   0573 FD AB         swp b
0226   0575 D8            push b
0227   0576 07 3F 0A      call printf
0228   0579 51 06 00      add sp, 6
0229   057C             ; --- END FUNCTION CALL
0230   057C             ; printf("Enter a string: "); 
0231   057C             ; --- START FUNCTION CALL
0232   057C 26 92 14      mov b, _s2 ; "Enter a string: "
0233   057F FD AB         swp b
0234   0581 D8            push b
0235   0582 07 3F 0A      call printf
0236   0585 51 02 00      add sp, 2
0237   0588             ; --- END FUNCTION CALL
0238   0588             ; gets(input_str); 
0239   0588             ; --- START FUNCTION CALL
0240   0588 FA 8F FF      lea d, [bp + -113] ; $input_str
0241   058B 2D            mov b, d
0242   058C 38 00 00      mov c, 0
0243   058F FD AB         swp b
0244   0591 D8            push b
0245   0592 07 50 13      call gets
0246   0595 51 02 00      add sp, 2
0247   0598             ; --- END FUNCTION CALL
0248   0598             ; encrypted_chars_len = 0; 
0249   0598 FA C5 FE      lea d, [bp + -315] ; $encrypted_chars_len
0250   059B DA            push d
0251   059C FD 2E 00 00   mov32 cb, $00000000
0251   05A0 00 00 
0252   05A2 E7            pop d
0253   05A3 FD 43         mov [d], b
0254   05A5             ; printf("\nEncrypted text: "); 
0255   05A5             ; --- START FUNCTION CALL
0256   05A5 26 A3 14      mov b, _s3 ; "\nEncrypted text: "
0257   05A8 FD AB         swp b
0258   05AA D8            push b
0259   05AB 07 3F 0A      call printf
0260   05AE 51 02 00      add sp, 2
0261   05B1             ; --- END FUNCTION CALL
0262   05B1             ; for (i = 0; input_str[i] != '\0' && input_str[i] != '\n'; i++) { 
0263   05B1             _for5_init:
0264   05B1 FA F3 FF      lea d, [bp + -13] ; $i
0265   05B4 DA            push d
0266   05B5 FD 2E 00 00   mov32 cb, $00000000
0266   05B9 00 00 
0267   05BB E7            pop d
0268   05BC FD 43         mov [d], b
0269   05BE             _for5_cond:
0270   05BE FA 8F FF      lea d, [bp + -113] ; $input_str
0271   05C1 D7            push a
0272   05C2 DA            push d
0273   05C3 FA F3 FF      lea d, [bp + -13] ; $i
0274   05C6 2A            mov b, [d]
0275   05C7 38 00 00      mov c, 0
0276   05CA E7            pop d
0277   05CB 5A            add d, b
0278   05CC E4            pop a
0279   05CD 32            mov bl, [d]
0280   05CE A7 00         mov bh, 0
0281   05D0 38 00 00      mov c, 0
0282   05D3             ; --- START RELATIONAL
0283   05D3 D7            push a
0284   05D4 11            mov a, b
0285   05D5 FD 2E 00 00   mov32 cb, $00000000
0285   05D9 00 00 
0286   05DB B0            cmp a, b
0287   05DC FD 72         sneq ; !=
0288   05DE E4            pop a
0289   05DF             ; --- END RELATIONAL
0290   05DF             ; --- START LOGICAL AND
0291   05DF D7            push a
0292   05E0 11            mov a, b
0293   05E1 FA 8F FF      lea d, [bp + -113] ; $input_str
0294   05E4 D7            push a
0295   05E5 DA            push d
0296   05E6 FA F3 FF      lea d, [bp + -13] ; $i
0297   05E9 2A            mov b, [d]
0298   05EA 38 00 00      mov c, 0
0299   05ED E7            pop d
0300   05EE 5A            add d, b
0301   05EF E4            pop a
0302   05F0 32            mov bl, [d]
0303   05F1 A7 00         mov bh, 0
0304   05F3 38 00 00      mov c, 0
0305   05F6             ; --- START RELATIONAL
0306   05F6 D7            push a
0307   05F7 11            mov a, b
0308   05F8 FD 2E 0A 00   mov32 cb, $0000000a
0308   05FC 00 00 
0309   05FE B0            cmp a, b
0310   05FF FD 72         sneq ; !=
0311   0601 E4            pop a
0312   0602             ; --- END RELATIONAL
0313   0602 FD A7         sand a, b
0314   0604 E4            pop a
0315   0605             ; --- END LOGICAL AND
0316   0605 C0 00 00      cmp b, 0
0317   0608 C6 9B 06      je _for5_exit
0318   060B             _for5_block:
0319   060B             ; encrypted_chars[i] = mod_exp(input_str[i], e, n); 
0320   060B FA C7 FE      lea d, [bp + -313] ; $encrypted_chars
0321   060E D7            push a
0322   060F DA            push d
0323   0610 FA F3 FF      lea d, [bp + -13] ; $i
0324   0613 2A            mov b, [d]
0325   0614 38 00 00      mov c, 0
0326   0617 E7            pop d
0327   0618 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0328   061C E4            pop a
0329   061D DA            push d
0330   061E             ; --- START FUNCTION CALL
0331   061E FA FB FF      lea d, [bp + -5] ; $n
0332   0621 2A            mov b, [d]
0333   0622 38 00 00      mov c, 0
0334   0625 FD AB         swp b
0335   0627 D8            push b
0336   0628 FA F7 FF      lea d, [bp + -9] ; $e
0337   062B 2A            mov b, [d]
0338   062C 38 00 00      mov c, 0
0339   062F FD AB         swp b
0340   0631 D8            push b
0341   0632 FA 8F FF      lea d, [bp + -113] ; $input_str
0342   0635 D7            push a
0343   0636 DA            push d
0344   0637 FA F3 FF      lea d, [bp + -13] ; $i
0345   063A 2A            mov b, [d]
0346   063B 38 00 00      mov c, 0
0347   063E E7            pop d
0348   063F 5A            add d, b
0349   0640 E4            pop a
0350   0641 32            mov bl, [d]
0351   0642 A7 00         mov bh, 0
0352   0644 38 00 00      mov c, 0
0353   0647 FD AB         swp b
0354   0649 D8            push b
0355   064A 07 AB 07      call mod_exp
0356   064D 51 06 00      add sp, 6
0357   0650             ; --- END FUNCTION CALL
0358   0650 E7            pop d
0359   0651 FD 43         mov [d], b
0360   0653             ; printf("%d ", encrypted_chars[i]); 
0361   0653             ; --- START FUNCTION CALL
0362   0653 FA C7 FE      lea d, [bp + -313] ; $encrypted_chars
0363   0656 D7            push a
0364   0657 DA            push d
0365   0658 FA F3 FF      lea d, [bp + -13] ; $i
0366   065B 2A            mov b, [d]
0367   065C 38 00 00      mov c, 0
0368   065F E7            pop d
0369   0660 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0370   0664 E4            pop a
0371   0665 2A            mov b, [d]
0372   0666 38 00 00      mov c, 0
0373   0669 FD AB         swp b
0374   066B D8            push b
0375   066C 26 B5 14      mov b, _s4 ; "%d "
0376   066F FD AB         swp b
0377   0671 D8            push b
0378   0672 07 3F 0A      call printf
0379   0675 51 04 00      add sp, 4
0380   0678             ; --- END FUNCTION CALL
0381   0678             ; encrypted_chars_len++; 
0382   0678 FA C5 FE      lea d, [bp + -315] ; $encrypted_chars_len
0383   067B 2A            mov b, [d]
0384   067C 38 00 00      mov c, 0
0385   067F 11            mov a, b
0386   0680 FD 77         inc b
0387   0682 FA C5 FE      lea d, [bp + -315] ; $encrypted_chars_len
0388   0685 FD 43         mov [d], b
0389   0687 27            mov b, a
0390   0688             _for5_update:
0391   0688 FA F3 FF      lea d, [bp + -13] ; $i
0392   068B 2A            mov b, [d]
0393   068C 38 00 00      mov c, 0
0394   068F 11            mov a, b
0395   0690 FD 77         inc b
0396   0692 FA F3 FF      lea d, [bp + -13] ; $i
0397   0695 FD 43         mov [d], b
0398   0697 27            mov b, a
0399   0698 0A BE 05      jmp _for5_cond
0400   069B             _for5_exit:
0401   069B             ; printf("\nDecrypted text: "); 
0402   069B             ; --- START FUNCTION CALL
0403   069B 26 B9 14      mov b, _s5 ; "\nDecrypted text: "
0404   069E FD AB         swp b
0405   06A0 D8            push b
0406   06A1 07 3F 0A      call printf
0407   06A4 51 02 00      add sp, 2
0408   06A7             ; --- END FUNCTION CALL
0409   06A7             ; for (i = 0; i < encrypted_chars_len; i++) { 
0410   06A7             _for6_init:
0411   06A7 FA F3 FF      lea d, [bp + -13] ; $i
0412   06AA DA            push d
0413   06AB FD 2E 00 00   mov32 cb, $00000000
0413   06AF 00 00 
0414   06B1 E7            pop d
0415   06B2 FD 43         mov [d], b
0416   06B4             _for6_cond:
0417   06B4 FA F3 FF      lea d, [bp + -13] ; $i
0418   06B7 2A            mov b, [d]
0419   06B8 38 00 00      mov c, 0
0420   06BB             ; --- START RELATIONAL
0421   06BB D7            push a
0422   06BC 11            mov a, b
0423   06BD FA C5 FE      lea d, [bp + -315] ; $encrypted_chars_len
0424   06C0 2A            mov b, [d]
0425   06C1 38 00 00      mov c, 0
0426   06C4 B0            cmp a, b
0427   06C5 FD 73         slt ; < (signed)
0428   06C7 E4            pop a
0429   06C8             ; --- END RELATIONAL
0430   06C8 C0 00 00      cmp b, 0
0431   06CB C6 39 07      je _for6_exit
0432   06CE             _for6_block:
0433   06CE             ; decrypted_char = mod_exp(encrypted_chars[i], d, n); 
0434   06CE FA C3 FE      lea d, [bp + -317] ; $decrypted_char
0435   06D1 DA            push d
0436   06D2             ; --- START FUNCTION CALL
0437   06D2 FA FB FF      lea d, [bp + -5] ; $n
0438   06D5 2A            mov b, [d]
0439   06D6 38 00 00      mov c, 0
0440   06D9 FD AB         swp b
0441   06DB D8            push b
0442   06DC FA F5 FF      lea d, [bp + -11] ; $d
0443   06DF 2A            mov b, [d]
0444   06E0 38 00 00      mov c, 0
0445   06E3 FD AB         swp b
0446   06E5 D8            push b
0447   06E6 FA C7 FE      lea d, [bp + -313] ; $encrypted_chars
0448   06E9 D7            push a
0449   06EA DA            push d
0450   06EB FA F3 FF      lea d, [bp + -13] ; $i
0451   06EE 2A            mov b, [d]
0452   06EF 38 00 00      mov c, 0
0453   06F2 E7            pop d
0454   06F3 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0455   06F7 E4            pop a
0456   06F8 2A            mov b, [d]
0457   06F9 38 00 00      mov c, 0
0458   06FC FD AB         swp b
0459   06FE D8            push b
0460   06FF 07 AB 07      call mod_exp
0461   0702 51 06 00      add sp, 6
0462   0705             ; --- END FUNCTION CALL
0463   0705 E7            pop d
0464   0706 FD 43         mov [d], b
0465   0708             ; c = decrypted_char; 
0466   0708 FA C2 FE      lea d, [bp + -318] ; $c
0467   070B DA            push d
0468   070C FA C3 FE      lea d, [bp + -317] ; $decrypted_char
0469   070F 2A            mov b, [d]
0470   0710 38 00 00      mov c, 0
0471   0713 E7            pop d
0472   0714 FD 3E         mov [d], bl
0473   0716             ; putchar(c); 
0474   0716             ; --- START FUNCTION CALL
0475   0716 FA C2 FE      lea d, [bp + -318] ; $c
0476   0719 32            mov bl, [d]
0477   071A A7 00         mov bh, 0
0478   071C 38 00 00      mov c, 0
0479   071F DD            push bl
0480   0720 07 C4 0E      call putchar
0481   0723 51 01 00      add sp, 1
0482   0726             ; --- END FUNCTION CALL
0483   0726             _for6_update:
0484   0726 FA F3 FF      lea d, [bp + -13] ; $i
0485   0729 2A            mov b, [d]
0486   072A 38 00 00      mov c, 0
0487   072D 11            mov a, b
0488   072E FD 77         inc b
0489   0730 FA F3 FF      lea d, [bp + -13] ; $i
0490   0733 FD 43         mov [d], b
0491   0735 27            mov b, a
0492   0736 0A B4 06      jmp _for6_cond
0493   0739             _for6_exit:
0494   0739             ; printf("\n"); 
0495   0739             ; --- START FUNCTION CALL
0496   0739 26 CB 14      mov b, _s6 ; "\n"
0497   073C FD AB         swp b
0498   073E D8            push b
0499   073F 07 3F 0A      call printf
0500   0742 51 02 00      add sp, 2
0501   0745             ; --- END FUNCTION CALL
0502   0745             ; return 0; 
0503   0745 FD 2E 00 00   mov32 cb, $00000000
0503   0749 00 00 
0504   074B F9            leave
0505   074C 05 0B         syscall sys_terminate_proc
0506   074E             
0507   074E             gcd:
0508   074E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0509   0751             ; if (b == 0) { 
0510   0751             _if7_cond:
0511   0751 FA 07 00      lea d, [bp + 7] ; $b
0512   0754 2A            mov b, [d]
0513   0755 38 00 00      mov c, 0
0514   0758             ; --- START RELATIONAL
0515   0758 D7            push a
0516   0759 11            mov a, b
0517   075A FD 2E 00 00   mov32 cb, $00000000
0517   075E 00 00 
0518   0760 B0            cmp a, b
0519   0761 FD 71         seq ; ==
0520   0763 E4            pop a
0521   0764             ; --- END RELATIONAL
0522   0764 C0 00 00      cmp b, 0
0523   0767 C6 76 07      je _if7_exit
0524   076A             _if7_TRUE:
0525   076A             ; return a; 
0526   076A FA 05 00      lea d, [bp + 5] ; $a
0527   076D 2A            mov b, [d]
0528   076E 38 00 00      mov c, 0
0529   0771 F9            leave
0530   0772 09            ret
0531   0773 0A 76 07      jmp _if7_exit
0532   0776             _if7_exit:
0533   0776             ; return gcd(b, a % b); 
0534   0776             ; --- START FUNCTION CALL
0535   0776 FA 05 00      lea d, [bp + 5] ; $a
0536   0779 2A            mov b, [d]
0537   077A 38 00 00      mov c, 0
0538   077D             ; --- START FACTORS
0539   077D D7            push a
0540   077E FD D8         push g
0541   0780 11            mov a, b
0542   0781 FD 7A         mov g, c
0543   0783 FA 07 00      lea d, [bp + 7] ; $b
0544   0786 2A            mov b, [d]
0545   0787 38 00 00      mov c, 0
0546   078A FD D8         push g ; save 'g' as the div instruction uses it
0547   078C AE            div a, b ; %, a: quotient, b: remainder
0548   078D 11            mov a, b
0549   078E FD F1         pop g
0550   0790 FD 38         mov c, g
0551   0792 27            mov b, a
0552   0793 FD F1         pop g
0553   0795 E4            pop a
0554   0796             ; --- END FACTORS
0555   0796 FD AB         swp b
0556   0798 D8            push b
0557   0799 FA 07 00      lea d, [bp + 7] ; $b
0558   079C 2A            mov b, [d]
0559   079D 38 00 00      mov c, 0
0560   07A0 FD AB         swp b
0561   07A2 D8            push b
0562   07A3 07 4E 07      call gcd
0563   07A6 51 04 00      add sp, 4
0564   07A9             ; --- END FUNCTION CALL
0565   07A9 F9            leave
0566   07AA 09            ret
0567   07AB             
0568   07AB             mod_exp:
0569   07AB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0570   07AE             ; int result; 
0571   07AE 52 02 00      sub sp, 2
0572   07B1             ; result = 1; 
0573   07B1 FA FF FF      lea d, [bp + -1] ; $result
0574   07B4 DA            push d
0575   07B5 FD 2E 01 00   mov32 cb, $00000001
0575   07B9 00 00 
0576   07BB E7            pop d
0577   07BC FD 43         mov [d], b
0578   07BE             ; while (exp > 0) { 
0579   07BE             _while12_cond:
0580   07BE FA 07 00      lea d, [bp + 7] ; $exp
0581   07C1 2A            mov b, [d]
0582   07C2 38 00 00      mov c, 0
0583   07C5             ; --- START RELATIONAL
0584   07C5 D7            push a
0585   07C6 11            mov a, b
0586   07C7 FD 2E 00 00   mov32 cb, $00000000
0586   07CB 00 00 
0587   07CD B0            cmp a, b
0588   07CE FD 7F         sgt ; >
0589   07D0 E4            pop a
0590   07D1             ; --- END RELATIONAL
0591   07D1 C0 00 00      cmp b, 0
0592   07D4 C6 EA 08      je _while12_exit
0593   07D7             _while12_block:
0594   07D7             ; if (exp & 1) { 
0595   07D7             _if13_cond:
0596   07D7 FA 07 00      lea d, [bp + 7] ; $exp
0597   07DA 2A            mov b, [d]
0598   07DB 38 00 00      mov c, 0
0599   07DE D7            push a
0600   07DF 11            mov a, b
0601   07E0 FD 2E 01 00   mov32 cb, $00000001
0601   07E4 00 00 
0602   07E6 FD 92         and b, a ; &
0603   07E8 E4            pop a
0604   07E9 C0 00 00      cmp b, 0
0605   07EC C6 5F 08      je _if13_exit
0606   07EF             _if13_TRUE:
0607   07EF             ; result = (result * base) % mod; 
0608   07EF FA FF FF      lea d, [bp + -1] ; $result
0609   07F2 DA            push d
0610   07F3 FA FF FF      lea d, [bp + -1] ; $result
0611   07F6 2A            mov b, [d]
0612   07F7 38 00 00      mov c, 0
0613   07FA             ; --- START FACTORS
0614   07FA D7            push a
0615   07FB FD D8         push g
0616   07FD 11            mov a, b
0617   07FE FD 7A         mov g, c
0618   0800 FA 05 00      lea d, [bp + 5] ; $base
0619   0803 2A            mov b, [d]
0620   0804 38 00 00      mov c, 0
0621   0807 D7            push a     ; save left operand
0622   0808 8E            xor a, b   ; xor sign bits
0623   0809 FD AA         swp a      ; swap bytes
0624   080B 83            mov cl, al ; save result of xor into 'dl'
0625   080C E4            pop a      ; restore left side operator
0626   080D DF            push cl    ; save result of xor above
0627   080E FD AA         swp a  
0628   0810 93 80         test al, $80  
0629   0812 FD AA         swp a  
0630   0814 C6 19 08      jz skip_invert_a_18  
0631   0817 FD 95         neg a 
0632   0819             skip_invert_a_18:   
0633   0819 FD AB         swp b
0634   081B FD 93 80      test bl, $80  
0635   081E FD AB         swp b
0636   0820 C6 25 08      jz skip_invert_b_18  
0637   0823 FD 97         neg b 
0638   0825             skip_invert_b_18:   
0639   0825 AC            mul a, b ; *
0640   0826 FD 78         mov g, a
0641   0828 11            mov a, b
0642   0829 EA            pop bl
0643   082A FD 93 80      test bl, $80
0644   082D C6 3A 08      jz _same_signs_18
0645   0830 2F            mov bl, al
0646   0831 95            not a
0647   0832 FD 97         neg b
0648   0834 5B 00 00      adc a, 0
0649   0837 FD 78         mov g, a
0650   0839 11            mov a, b
0651   083A             _same_signs_18:
0652   083A FD 38         mov c, g
0653   083C 27            mov b, a
0654   083D FD F1         pop g
0655   083F E4            pop a
0656   0840             ; --- END FACTORS
0657   0840             ; --- START FACTORS
0658   0840 D7            push a
0659   0841 FD D8         push g
0660   0843 11            mov a, b
0661   0844 FD 7A         mov g, c
0662   0846 FA 09 00      lea d, [bp + 9] ; $mod
0663   0849 2A            mov b, [d]
0664   084A 38 00 00      mov c, 0
0665   084D FD D8         push g ; save 'g' as the div instruction uses it
0666   084F AE            div a, b ; %, a: quotient, b: remainder
0667   0850 11            mov a, b
0668   0851 FD F1         pop g
0669   0853 FD 38         mov c, g
0670   0855 27            mov b, a
0671   0856 FD F1         pop g
0672   0858 E4            pop a
0673   0859             ; --- END FACTORS
0674   0859 E7            pop d
0675   085A FD 43         mov [d], b
0676   085C 0A 5F 08      jmp _if13_exit
0677   085F             _if13_exit:
0678   085F             ; exp = exp >> 1; 
0679   085F FA 07 00      lea d, [bp + 7] ; $exp
0680   0862 DA            push d
0681   0863 FA 07 00      lea d, [bp + 7] ; $exp
0682   0866 2A            mov b, [d]
0683   0867 38 00 00      mov c, 0
0684   086A             ; --- START SHIFT
0685   086A D7            push a
0686   086B 11            mov a, b
0687   086C FD 2E 01 00   mov32 cb, $00000001
0687   0870 00 00 
0688   0872 FD 39         mov c, b
0689   0874 A5            ashr a, cl
0690   0875 27            mov b, a
0691   0876 E4            pop a
0692   0877             ; --- END SHIFT
0693   0877 E7            pop d
0694   0878 FD 43         mov [d], b
0695   087A             ; base = (base * base) % mod; 
0696   087A FA 05 00      lea d, [bp + 5] ; $base
0697   087D DA            push d
0698   087E FA 05 00      lea d, [bp + 5] ; $base
0699   0881 2A            mov b, [d]
0700   0882 38 00 00      mov c, 0
0701   0885             ; --- START FACTORS
0702   0885 D7            push a
0703   0886 FD D8         push g
0704   0888 11            mov a, b
0705   0889 FD 7A         mov g, c
0706   088B FA 05 00      lea d, [bp + 5] ; $base
0707   088E 2A            mov b, [d]
0708   088F 38 00 00      mov c, 0
0709   0892 D7            push a     ; save left operand
0710   0893 8E            xor a, b   ; xor sign bits
0711   0894 FD AA         swp a      ; swap bytes
0712   0896 83            mov cl, al ; save result of xor into 'dl'
0713   0897 E4            pop a      ; restore left side operator
0714   0898 DF            push cl    ; save result of xor above
0715   0899 FD AA         swp a  
0716   089B 93 80         test al, $80  
0717   089D FD AA         swp a  
0718   089F C6 A4 08      jz skip_invert_a_24  
0719   08A2 FD 95         neg a 
0720   08A4             skip_invert_a_24:   
0721   08A4 FD AB         swp b
0722   08A6 FD 93 80      test bl, $80  
0723   08A9 FD AB         swp b
0724   08AB C6 B0 08      jz skip_invert_b_24  
0725   08AE FD 97         neg b 
0726   08B0             skip_invert_b_24:   
0727   08B0 AC            mul a, b ; *
0728   08B1 FD 78         mov g, a
0729   08B3 11            mov a, b
0730   08B4 EA            pop bl
0731   08B5 FD 93 80      test bl, $80
0732   08B8 C6 C5 08      jz _same_signs_24
0733   08BB 2F            mov bl, al
0734   08BC 95            not a
0735   08BD FD 97         neg b
0736   08BF 5B 00 00      adc a, 0
0737   08C2 FD 78         mov g, a
0738   08C4 11            mov a, b
0739   08C5             _same_signs_24:
0740   08C5 FD 38         mov c, g
0741   08C7 27            mov b, a
0742   08C8 FD F1         pop g
0743   08CA E4            pop a
0744   08CB             ; --- END FACTORS
0745   08CB             ; --- START FACTORS
0746   08CB D7            push a
0747   08CC FD D8         push g
0748   08CE 11            mov a, b
0749   08CF FD 7A         mov g, c
0750   08D1 FA 09 00      lea d, [bp + 9] ; $mod
0751   08D4 2A            mov b, [d]
0752   08D5 38 00 00      mov c, 0
0753   08D8 FD D8         push g ; save 'g' as the div instruction uses it
0754   08DA AE            div a, b ; %, a: quotient, b: remainder
0755   08DB 11            mov a, b
0756   08DC FD F1         pop g
0757   08DE FD 38         mov c, g
0758   08E0 27            mov b, a
0759   08E1 FD F1         pop g
0760   08E3 E4            pop a
0761   08E4             ; --- END FACTORS
0762   08E4 E7            pop d
0763   08E5 FD 43         mov [d], b
0764   08E7 0A BE 07      jmp _while12_cond
0765   08EA             _while12_exit:
0766   08EA             ; return result; 
0767   08EA FA FF FF      lea d, [bp + -1] ; $result
0768   08ED 2A            mov b, [d]
0769   08EE 38 00 00      mov c, 0
0770   08F1 F9            leave
0771   08F2 09            ret
0772   08F3             
0773   08F3             find_e:
0774   08F3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0775   08F6             ; int e; 
0776   08F6 52 02 00      sub sp, 2
0777   08F9             ; for (e = 2; e < phi; e++) { 
0778   08F9             _for26_init:
0779   08F9 FA FF FF      lea d, [bp + -1] ; $e
0780   08FC DA            push d
0781   08FD FD 2E 02 00   mov32 cb, $00000002
0781   0901 00 00 
0782   0903 E7            pop d
0783   0904 FD 43         mov [d], b
0784   0906             _for26_cond:
0785   0906 FA FF FF      lea d, [bp + -1] ; $e
0786   0909 2A            mov b, [d]
0787   090A 38 00 00      mov c, 0
0788   090D             ; --- START RELATIONAL
0789   090D D7            push a
0790   090E 11            mov a, b
0791   090F FA 05 00      lea d, [bp + 5] ; $phi
0792   0912 2A            mov b, [d]
0793   0913 38 00 00      mov c, 0
0794   0916 B0            cmp a, b
0795   0917 FD 73         slt ; < (signed)
0796   0919 E4            pop a
0797   091A             ; --- END RELATIONAL
0798   091A C0 00 00      cmp b, 0
0799   091D C6 6B 09      je _for26_exit
0800   0920             _for26_block:
0801   0920             ; if (gcd(e, phi) == 1) { 
0802   0920             _if27_cond:
0803   0920             ; --- START FUNCTION CALL
0804   0920 FA 05 00      lea d, [bp + 5] ; $phi
0805   0923 2A            mov b, [d]
0806   0924 38 00 00      mov c, 0
0807   0927 FD AB         swp b
0808   0929 D8            push b
0809   092A FA FF FF      lea d, [bp + -1] ; $e
0810   092D 2A            mov b, [d]
0811   092E 38 00 00      mov c, 0
0812   0931 FD AB         swp b
0813   0933 D8            push b
0814   0934 07 4E 07      call gcd
0815   0937 51 04 00      add sp, 4
0816   093A             ; --- END FUNCTION CALL
0817   093A             ; --- START RELATIONAL
0818   093A D7            push a
0819   093B 11            mov a, b
0820   093C FD 2E 01 00   mov32 cb, $00000001
0820   0940 00 00 
0821   0942 B0            cmp a, b
0822   0943 FD 71         seq ; ==
0823   0945 E4            pop a
0824   0946             ; --- END RELATIONAL
0825   0946 C0 00 00      cmp b, 0
0826   0949 C6 58 09      je _if27_exit
0827   094C             _if27_TRUE:
0828   094C             ; return e; 
0829   094C FA FF FF      lea d, [bp + -1] ; $e
0830   094F 2A            mov b, [d]
0831   0950 38 00 00      mov c, 0
0832   0953 F9            leave
0833   0954 09            ret
0834   0955 0A 58 09      jmp _if27_exit
0835   0958             _if27_exit:
0836   0958             _for26_update:
0837   0958 FA FF FF      lea d, [bp + -1] ; $e
0838   095B 2A            mov b, [d]
0839   095C 38 00 00      mov c, 0
0840   095F 11            mov a, b
0841   0960 FD 77         inc b
0842   0962 FA FF FF      lea d, [bp + -1] ; $e
0843   0965 FD 43         mov [d], b
0844   0967 27            mov b, a
0845   0968 0A 06 09      jmp _for26_cond
0846   096B             _for26_exit:
0847   096B             ; return 0; 
0848   096B FD 2E 00 00   mov32 cb, $00000000
0848   096F 00 00 
0849   0971 F9            leave
0850   0972 09            ret
0851   0973             
0852   0973             find_d:
0853   0973 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0854   0976             ; int d; 
0855   0976 52 02 00      sub sp, 2
0856   0979             ; for (d = 2; d < phi; d++) { 
0857   0979             _for28_init:
0858   0979 FA FF FF      lea d, [bp + -1] ; $d
0859   097C DA            push d
0860   097D FD 2E 02 00   mov32 cb, $00000002
0860   0981 00 00 
0861   0983 E7            pop d
0862   0984 FD 43         mov [d], b
0863   0986             _for28_cond:
0864   0986 FA FF FF      lea d, [bp + -1] ; $d
0865   0989 2A            mov b, [d]
0866   098A 38 00 00      mov c, 0
0867   098D             ; --- START RELATIONAL
0868   098D D7            push a
0869   098E 11            mov a, b
0870   098F FA 07 00      lea d, [bp + 7] ; $phi
0871   0992 2A            mov b, [d]
0872   0993 38 00 00      mov c, 0
0873   0996 B0            cmp a, b
0874   0997 FD 73         slt ; < (signed)
0875   0999 E4            pop a
0876   099A             ; --- END RELATIONAL
0877   099A C0 00 00      cmp b, 0
0878   099D C6 37 0A      je _for28_exit
0879   09A0             _for28_block:
0880   09A0             ; if ((d * e) % phi == 1) {   
0881   09A0             _if29_cond:
0882   09A0 FA FF FF      lea d, [bp + -1] ; $d
0883   09A3 2A            mov b, [d]
0884   09A4 38 00 00      mov c, 0
0885   09A7             ; --- START FACTORS
0886   09A7 D7            push a
0887   09A8 FD D8         push g
0888   09AA 11            mov a, b
0889   09AB FD 7A         mov g, c
0890   09AD FA 05 00      lea d, [bp + 5] ; $e
0891   09B0 2A            mov b, [d]
0892   09B1 38 00 00      mov c, 0
0893   09B4 D7            push a     ; save left operand
0894   09B5 8E            xor a, b   ; xor sign bits
0895   09B6 FD AA         swp a      ; swap bytes
0896   09B8 83            mov cl, al ; save result of xor into 'dl'
0897   09B9 E4            pop a      ; restore left side operator
0898   09BA DF            push cl    ; save result of xor above
0899   09BB FD AA         swp a  
0900   09BD 93 80         test al, $80  
0901   09BF FD AA         swp a  
0902   09C1 C6 C6 09      jz skip_invert_a_34  
0903   09C4 FD 95         neg a 
0904   09C6             skip_invert_a_34:   
0905   09C6 FD AB         swp b
0906   09C8 FD 93 80      test bl, $80  
0907   09CB FD AB         swp b
0908   09CD C6 D2 09      jz skip_invert_b_34  
0909   09D0 FD 97         neg b 
0910   09D2             skip_invert_b_34:   
0911   09D2 AC            mul a, b ; *
0912   09D3 FD 78         mov g, a
0913   09D5 11            mov a, b
0914   09D6 EA            pop bl
0915   09D7 FD 93 80      test bl, $80
0916   09DA C6 E7 09      jz _same_signs_34
0917   09DD 2F            mov bl, al
0918   09DE 95            not a
0919   09DF FD 97         neg b
0920   09E1 5B 00 00      adc a, 0
0921   09E4 FD 78         mov g, a
0922   09E6 11            mov a, b
0923   09E7             _same_signs_34:
0924   09E7 FD 38         mov c, g
0925   09E9 27            mov b, a
0926   09EA FD F1         pop g
0927   09EC E4            pop a
0928   09ED             ; --- END FACTORS
0929   09ED             ; --- START FACTORS
0930   09ED D7            push a
0931   09EE FD D8         push g
0932   09F0 11            mov a, b
0933   09F1 FD 7A         mov g, c
0934   09F3 FA 07 00      lea d, [bp + 7] ; $phi
0935   09F6 2A            mov b, [d]
0936   09F7 38 00 00      mov c, 0
0937   09FA FD D8         push g ; save 'g' as the div instruction uses it
0938   09FC AE            div a, b ; %, a: quotient, b: remainder
0939   09FD 11            mov a, b
0940   09FE FD F1         pop g
0941   0A00 FD 38         mov c, g
0942   0A02 27            mov b, a
0943   0A03 FD F1         pop g
0944   0A05 E4            pop a
0945   0A06             ; --- END FACTORS
0946   0A06             ; --- START RELATIONAL
0947   0A06 D7            push a
0948   0A07 11            mov a, b
0949   0A08 FD 2E 01 00   mov32 cb, $00000001
0949   0A0C 00 00 
0950   0A0E B0            cmp a, b
0951   0A0F FD 71         seq ; ==
0952   0A11 E4            pop a
0953   0A12             ; --- END RELATIONAL
0954   0A12 C0 00 00      cmp b, 0
0955   0A15 C6 24 0A      je _if29_exit
0956   0A18             _if29_TRUE:
0957   0A18             ; return d; 
0958   0A18 FA FF FF      lea d, [bp + -1] ; $d
0959   0A1B 2A            mov b, [d]
0960   0A1C 38 00 00      mov c, 0
0961   0A1F F9            leave
0962   0A20 09            ret
0963   0A21 0A 24 0A      jmp _if29_exit
0964   0A24             _if29_exit:
0965   0A24             _for28_update:
0966   0A24 FA FF FF      lea d, [bp + -1] ; $d
0967   0A27 2A            mov b, [d]
0968   0A28 38 00 00      mov c, 0
0969   0A2B 11            mov a, b
0970   0A2C FD 77         inc b
0971   0A2E FA FF FF      lea d, [bp + -1] ; $d
0972   0A31 FD 43         mov [d], b
0973   0A33 27            mov b, a
0974   0A34 0A 86 09      jmp _for28_cond
0975   0A37             _for28_exit:
0976   0A37             ; return 0; 
0977   0A37 FD 2E 00 00   mov32 cb, $00000000
0977   0A3B 00 00 
0978   0A3D F9            leave
0979   0A3E 09            ret
0980   0A3F             
0981   0A3F             printf:
0982   0A3F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0983   0A42             ; char *p, *format_p; 
0984   0A42 52 02 00      sub sp, 2
0985   0A45 52 02 00      sub sp, 2
0986   0A48             ; format_p = format; 
0987   0A48 FA FD FF      lea d, [bp + -3] ; $format_p
0988   0A4B DA            push d
0989   0A4C FA 05 00      lea d, [bp + 5] ; $format
0990   0A4F 2A            mov b, [d]
0991   0A50 38 00 00      mov c, 0
0992   0A53 E7            pop d
0993   0A54 FD 43         mov [d], b
0994   0A56             ; p = &format + 2; 
0995   0A56 FA FF FF      lea d, [bp + -1] ; $p
0996   0A59 DA            push d
0997   0A5A FA 05 00      lea d, [bp + 5] ; $format
0998   0A5D 2D            mov b, d
0999   0A5E             ; --- START TERMS
1000   0A5E D7            push a
1001   0A5F 11            mov a, b
1002   0A60 FD 2E 02 00   mov32 cb, $00000002
1002   0A64 00 00 
1003   0A66 56            add b, a
1004   0A67 E4            pop a
1005   0A68             ; --- END TERMS
1006   0A68 E7            pop d
1007   0A69 FD 43         mov [d], b
1008   0A6B             ; for(;;){ 
1009   0A6B             _for36_init:
1010   0A6B             _for36_cond:
1011   0A6B             _for36_block:
1012   0A6B             ; if(!*format_p) break; 
1013   0A6B             _if37_cond:
1014   0A6B FA FD FF      lea d, [bp + -3] ; $format_p
1015   0A6E 2A            mov b, [d]
1016   0A6F 38 00 00      mov c, 0
1017   0A72 74            mov d, b
1018   0A73 32            mov bl, [d]
1019   0A74 A7 00         mov bh, 0
1020   0A76 38 00 00      mov c, 0
1021   0A79 C0 00 00      cmp b, 0
1022   0A7C FD 71         seq ; !
1023   0A7E C0 00 00      cmp b, 0
1024   0A81 C6 8A 0A      je _if37_else
1025   0A84             _if37_TRUE:
1026   0A84             ; break; 
1027   0A84 0A 3A 0D      jmp _for36_exit ; for break
1028   0A87 0A 37 0D      jmp _if37_exit
1029   0A8A             _if37_else:
1030   0A8A             ; if(*format_p == '%'){ 
1031   0A8A             _if38_cond:
1032   0A8A FA FD FF      lea d, [bp + -3] ; $format_p
1033   0A8D 2A            mov b, [d]
1034   0A8E 38 00 00      mov c, 0
1035   0A91 74            mov d, b
1036   0A92 32            mov bl, [d]
1037   0A93 A7 00         mov bh, 0
1038   0A95 38 00 00      mov c, 0
1039   0A98             ; --- START RELATIONAL
1040   0A98 D7            push a
1041   0A99 11            mov a, b
1042   0A9A FD 2E 25 00   mov32 cb, $00000025
1042   0A9E 00 00 
1043   0AA0 B0            cmp a, b
1044   0AA1 FD 71         seq ; ==
1045   0AA3 E4            pop a
1046   0AA4             ; --- END RELATIONAL
1047   0AA4 C0 00 00      cmp b, 0
1048   0AA7 C6 12 0D      je _if38_else
1049   0AAA             _if38_TRUE:
1050   0AAA             ; format_p++; 
1051   0AAA FA FD FF      lea d, [bp + -3] ; $format_p
1052   0AAD 2A            mov b, [d]
1053   0AAE 38 00 00      mov c, 0
1054   0AB1 FD 77         inc b
1055   0AB3 FA FD FF      lea d, [bp + -3] ; $format_p
1056   0AB6 FD 43         mov [d], b
1057   0AB8 FD 7D         dec b
1058   0ABA             ; switch(*format_p){ 
1059   0ABA             _switch39_expr:
1060   0ABA FA FD FF      lea d, [bp + -3] ; $format_p
1061   0ABD 2A            mov b, [d]
1062   0ABE 38 00 00      mov c, 0
1063   0AC1 74            mov d, b
1064   0AC2 32            mov bl, [d]
1065   0AC3 A7 00         mov bh, 0
1066   0AC5 38 00 00      mov c, 0
1067   0AC8             _switch39_comparisons:
1068   0AC8 C1 6C         cmp bl, $6c
1069   0ACA C6 F6 0A      je _switch39_case0
1070   0ACD C1 4C         cmp bl, $4c
1071   0ACF C6 F6 0A      je _switch39_case1
1072   0AD2 C1 64         cmp bl, $64
1073   0AD4 C6 06 0C      je _switch39_case2
1074   0AD7 C1 69         cmp bl, $69
1075   0AD9 C6 06 0C      je _switch39_case3
1076   0ADC C1 75         cmp bl, $75
1077   0ADE C6 36 0C      je _switch39_case4
1078   0AE1 C1 78         cmp bl, $78
1079   0AE3 C6 66 0C      je _switch39_case5
1080   0AE6 C1 63         cmp bl, $63
1081   0AE8 C6 96 0C      je _switch39_case6
1082   0AEB C1 73         cmp bl, $73
1083   0AED C6 C6 0C      je _switch39_case7
1084   0AF0 0A F3 0C      jmp _switch39_default
1085   0AF3 0A FF 0C      jmp _switch39_exit
1086   0AF6             _switch39_case0:
1087   0AF6             _switch39_case1:
1088   0AF6             ; format_p++; 
1089   0AF6 FA FD FF      lea d, [bp + -3] ; $format_p
1090   0AF9 2A            mov b, [d]
1091   0AFA 38 00 00      mov c, 0
1092   0AFD FD 77         inc b
1093   0AFF FA FD FF      lea d, [bp + -3] ; $format_p
1094   0B02 FD 43         mov [d], b
1095   0B04 FD 7D         dec b
1096   0B06             ; if(*format_p == 'd' || *format_p == 'i') 
1097   0B06             _if40_cond:
1098   0B06 FA FD FF      lea d, [bp + -3] ; $format_p
1099   0B09 2A            mov b, [d]
1100   0B0A 38 00 00      mov c, 0
1101   0B0D 74            mov d, b
1102   0B0E 32            mov bl, [d]
1103   0B0F A7 00         mov bh, 0
1104   0B11 38 00 00      mov c, 0
1105   0B14             ; --- START RELATIONAL
1106   0B14 D7            push a
1107   0B15 11            mov a, b
1108   0B16 FD 2E 64 00   mov32 cb, $00000064
1108   0B1A 00 00 
1109   0B1C B0            cmp a, b
1110   0B1D FD 71         seq ; ==
1111   0B1F E4            pop a
1112   0B20             ; --- END RELATIONAL
1113   0B20             ; --- START LOGICAL OR
1114   0B20 D7            push a
1115   0B21 11            mov a, b
1116   0B22 FA FD FF      lea d, [bp + -3] ; $format_p
1117   0B25 2A            mov b, [d]
1118   0B26 38 00 00      mov c, 0
1119   0B29 74            mov d, b
1120   0B2A 32            mov bl, [d]
1121   0B2B A7 00         mov bh, 0
1122   0B2D 38 00 00      mov c, 0
1123   0B30             ; --- START RELATIONAL
1124   0B30 D7            push a
1125   0B31 11            mov a, b
1126   0B32 FD 2E 69 00   mov32 cb, $00000069
1126   0B36 00 00 
1127   0B38 B0            cmp a, b
1128   0B39 FD 71         seq ; ==
1129   0B3B E4            pop a
1130   0B3C             ; --- END RELATIONAL
1131   0B3C FD A8         sor a, b ; ||
1132   0B3E E4            pop a
1133   0B3F             ; --- END LOGICAL OR
1134   0B3F C0 00 00      cmp b, 0
1135   0B42 C6 63 0B      je _if40_else
1136   0B45             _if40_TRUE:
1137   0B45             ; print_signed_long(*(long *)p); 
1138   0B45             ; --- START FUNCTION CALL
1139   0B45 FA FF FF      lea d, [bp + -1] ; $p
1140   0B48 2A            mov b, [d]
1141   0B49 38 00 00      mov c, 0
1142   0B4C 74            mov d, b
1143   0B4D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1144   0B50 FD 39         mov c, b ; And place it into C
1145   0B52 2A            mov b, [d] ; Lower Word in B
1146   0B53 12            mov a, c
1147   0B54 FD AA         swp a
1148   0B56 D7            push a
1149   0B57 FD AB         swp b
1150   0B59 D8            push b
1151   0B5A 07 3C 0D      call print_signed_long
1152   0B5D 51 04 00      add sp, 4
1153   0B60             ; --- END FUNCTION CALL
1154   0B60 0A EB 0B      jmp _if40_exit
1155   0B63             _if40_else:
1156   0B63             ; if(*format_p == 'u') 
1157   0B63             _if41_cond:
1158   0B63 FA FD FF      lea d, [bp + -3] ; $format_p
1159   0B66 2A            mov b, [d]
1160   0B67 38 00 00      mov c, 0
1161   0B6A 74            mov d, b
1162   0B6B 32            mov bl, [d]
1163   0B6C A7 00         mov bh, 0
1164   0B6E 38 00 00      mov c, 0
1165   0B71             ; --- START RELATIONAL
1166   0B71 D7            push a
1167   0B72 11            mov a, b
1168   0B73 FD 2E 75 00   mov32 cb, $00000075
1168   0B77 00 00 
1169   0B79 B0            cmp a, b
1170   0B7A FD 71         seq ; ==
1171   0B7C E4            pop a
1172   0B7D             ; --- END RELATIONAL
1173   0B7D C0 00 00      cmp b, 0
1174   0B80 C6 A1 0B      je _if41_else
1175   0B83             _if41_TRUE:
1176   0B83             ; print_unsigned_long(*(unsigned long *)p); 
1177   0B83             ; --- START FUNCTION CALL
1178   0B83 FA FF FF      lea d, [bp + -1] ; $p
1179   0B86 2A            mov b, [d]
1180   0B87 38 00 00      mov c, 0
1181   0B8A 74            mov d, b
1182   0B8B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1183   0B8E FD 39         mov c, b ; And place it into C
1184   0B90 2A            mov b, [d] ; Lower Word in B
1185   0B91 12            mov a, c
1186   0B92 FD AA         swp a
1187   0B94 D7            push a
1188   0B95 FD AB         swp b
1189   0B97 D8            push b
1190   0B98 07 D2 0E      call print_unsigned_long
1191   0B9B 51 04 00      add sp, 4
1192   0B9E             ; --- END FUNCTION CALL
1193   0B9E 0A EB 0B      jmp _if41_exit
1194   0BA1             _if41_else:
1195   0BA1             ; if(*format_p == 'x') 
1196   0BA1             _if42_cond:
1197   0BA1 FA FD FF      lea d, [bp + -3] ; $format_p
1198   0BA4 2A            mov b, [d]
1199   0BA5 38 00 00      mov c, 0
1200   0BA8 74            mov d, b
1201   0BA9 32            mov bl, [d]
1202   0BAA A7 00         mov bh, 0
1203   0BAC 38 00 00      mov c, 0
1204   0BAF             ; --- START RELATIONAL
1205   0BAF D7            push a
1206   0BB0 11            mov a, b
1207   0BB1 FD 2E 78 00   mov32 cb, $00000078
1207   0BB5 00 00 
1208   0BB7 B0            cmp a, b
1209   0BB8 FD 71         seq ; ==
1210   0BBA E4            pop a
1211   0BBB             ; --- END RELATIONAL
1212   0BBB C0 00 00      cmp b, 0
1213   0BBE C6 DF 0B      je _if42_else
1214   0BC1             _if42_TRUE:
1215   0BC1             ; printx32(*(long int *)p); 
1216   0BC1             ; --- START FUNCTION CALL
1217   0BC1 FA FF FF      lea d, [bp + -1] ; $p
1218   0BC4 2A            mov b, [d]
1219   0BC5 38 00 00      mov c, 0
1220   0BC8 74            mov d, b
1221   0BC9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1222   0BCC FD 39         mov c, b ; And place it into C
1223   0BCE 2A            mov b, [d] ; Lower Word in B
1224   0BCF 12            mov a, c
1225   0BD0 FD AA         swp a
1226   0BD2 D7            push a
1227   0BD3 FD AB         swp b
1228   0BD5 D8            push b
1229   0BD6 07 07 10      call printx32
1230   0BD9 51 04 00      add sp, 4
1231   0BDC             ; --- END FUNCTION CALL
1232   0BDC 0A EB 0B      jmp _if42_exit
1233   0BDF             _if42_else:
1234   0BDF             ; err("Unexpected format in printf."); 
1235   0BDF             ; --- START FUNCTION CALL
1236   0BDF 26 CD 14      mov b, _s7 ; "Unexpected format in printf."
1237   0BE2 FD AB         swp b
1238   0BE4 D8            push b
1239   0BE5 07 67 10      call err
1240   0BE8 51 02 00      add sp, 2
1241   0BEB             ; --- END FUNCTION CALL
1242   0BEB             _if42_exit:
1243   0BEB             _if41_exit:
1244   0BEB             _if40_exit:
1245   0BEB             ; p = p + 4; 
1246   0BEB FA FF FF      lea d, [bp + -1] ; $p
1247   0BEE DA            push d
1248   0BEF FA FF FF      lea d, [bp + -1] ; $p
1249   0BF2 2A            mov b, [d]
1250   0BF3 38 00 00      mov c, 0
1251   0BF6             ; --- START TERMS
1252   0BF6 D7            push a
1253   0BF7 11            mov a, b
1254   0BF8 FD 2E 04 00   mov32 cb, $00000004
1254   0BFC 00 00 
1255   0BFE 56            add b, a
1256   0BFF E4            pop a
1257   0C00             ; --- END TERMS
1258   0C00 E7            pop d
1259   0C01 FD 43         mov [d], b
1260   0C03             ; break; 
1261   0C03 0A FF 0C      jmp _switch39_exit ; case break
1262   0C06             _switch39_case2:
1263   0C06             _switch39_case3:
1264   0C06             ; print_signed(*(int*)p); 
1265   0C06             ; --- START FUNCTION CALL
1266   0C06 FA FF FF      lea d, [bp + -1] ; $p
1267   0C09 2A            mov b, [d]
1268   0C0A 38 00 00      mov c, 0
1269   0C0D 74            mov d, b
1270   0C0E 2A            mov b, [d]
1271   0C0F 38 00 00      mov c, 0
1272   0C12 FD AB         swp b
1273   0C14 D8            push b
1274   0C15 07 95 10      call print_signed
1275   0C18 51 02 00      add sp, 2
1276   0C1B             ; --- END FUNCTION CALL
1277   0C1B             ; p = p + 2; 
1278   0C1B FA FF FF      lea d, [bp + -1] ; $p
1279   0C1E DA            push d
1280   0C1F FA FF FF      lea d, [bp + -1] ; $p
1281   0C22 2A            mov b, [d]
1282   0C23 38 00 00      mov c, 0
1283   0C26             ; --- START TERMS
1284   0C26 D7            push a
1285   0C27 11            mov a, b
1286   0C28 FD 2E 02 00   mov32 cb, $00000002
1286   0C2C 00 00 
1287   0C2E 56            add b, a
1288   0C2F E4            pop a
1289   0C30             ; --- END TERMS
1290   0C30 E7            pop d
1291   0C31 FD 43         mov [d], b
1292   0C33             ; break; 
1293   0C33 0A FF 0C      jmp _switch39_exit ; case break
1294   0C36             _switch39_case4:
1295   0C36             ; print_unsigned(*(unsigned int*)p); 
1296   0C36             ; --- START FUNCTION CALL
1297   0C36 FA FF FF      lea d, [bp + -1] ; $p
1298   0C39 2A            mov b, [d]
1299   0C3A 38 00 00      mov c, 0
1300   0C3D 74            mov d, b
1301   0C3E 2A            mov b, [d]
1302   0C3F 38 00 00      mov c, 0
1303   0C42 FD AB         swp b
1304   0C44 D8            push b
1305   0C45 07 E6 11      call print_unsigned
1306   0C48 51 02 00      add sp, 2
1307   0C4B             ; --- END FUNCTION CALL
1308   0C4B             ; p = p + 2; 
1309   0C4B FA FF FF      lea d, [bp + -1] ; $p
1310   0C4E DA            push d
1311   0C4F FA FF FF      lea d, [bp + -1] ; $p
1312   0C52 2A            mov b, [d]
1313   0C53 38 00 00      mov c, 0
1314   0C56             ; --- START TERMS
1315   0C56 D7            push a
1316   0C57 11            mov a, b
1317   0C58 FD 2E 02 00   mov32 cb, $00000002
1317   0C5C 00 00 
1318   0C5E 56            add b, a
1319   0C5F E4            pop a
1320   0C60             ; --- END TERMS
1321   0C60 E7            pop d
1322   0C61 FD 43         mov [d], b
1323   0C63             ; break; 
1324   0C63 0A FF 0C      jmp _switch39_exit ; case break
1325   0C66             _switch39_case5:
1326   0C66             ; printx16(*(int*)p); 
1327   0C66             ; --- START FUNCTION CALL
1328   0C66 FA FF FF      lea d, [bp + -1] ; $p
1329   0C69 2A            mov b, [d]
1330   0C6A 38 00 00      mov c, 0
1331   0C6D 74            mov d, b
1332   0C6E 2A            mov b, [d]
1333   0C6F 38 00 00      mov c, 0
1334   0C72 FD AB         swp b
1335   0C74 D8            push b
1336   0C75 07 FE 12      call printx16
1337   0C78 51 02 00      add sp, 2
1338   0C7B             ; --- END FUNCTION CALL
1339   0C7B             ; p = p + 2; 
1340   0C7B FA FF FF      lea d, [bp + -1] ; $p
1341   0C7E DA            push d
1342   0C7F FA FF FF      lea d, [bp + -1] ; $p
1343   0C82 2A            mov b, [d]
1344   0C83 38 00 00      mov c, 0
1345   0C86             ; --- START TERMS
1346   0C86 D7            push a
1347   0C87 11            mov a, b
1348   0C88 FD 2E 02 00   mov32 cb, $00000002
1348   0C8C 00 00 
1349   0C8E 56            add b, a
1350   0C8F E4            pop a
1351   0C90             ; --- END TERMS
1352   0C90 E7            pop d
1353   0C91 FD 43         mov [d], b
1354   0C93             ; break; 
1355   0C93 0A FF 0C      jmp _switch39_exit ; case break
1356   0C96             _switch39_case6:
1357   0C96             ; putchar(*(char*)p); 
1358   0C96             ; --- START FUNCTION CALL
1359   0C96 FA FF FF      lea d, [bp + -1] ; $p
1360   0C99 2A            mov b, [d]
1361   0C9A 38 00 00      mov c, 0
1362   0C9D 74            mov d, b
1363   0C9E 32            mov bl, [d]
1364   0C9F A7 00         mov bh, 0
1365   0CA1 38 00 00      mov c, 0
1366   0CA4 DD            push bl
1367   0CA5 07 C4 0E      call putchar
1368   0CA8 51 01 00      add sp, 1
1369   0CAB             ; --- END FUNCTION CALL
1370   0CAB             ; p = p + 1; 
1371   0CAB FA FF FF      lea d, [bp + -1] ; $p
1372   0CAE DA            push d
1373   0CAF FA FF FF      lea d, [bp + -1] ; $p
1374   0CB2 2A            mov b, [d]
1375   0CB3 38 00 00      mov c, 0
1376   0CB6             ; --- START TERMS
1377   0CB6 D7            push a
1378   0CB7 11            mov a, b
1379   0CB8 FD 2E 01 00   mov32 cb, $00000001
1379   0CBC 00 00 
1380   0CBE 56            add b, a
1381   0CBF E4            pop a
1382   0CC0             ; --- END TERMS
1383   0CC0 E7            pop d
1384   0CC1 FD 43         mov [d], b
1385   0CC3             ; break; 
1386   0CC3 0A FF 0C      jmp _switch39_exit ; case break
1387   0CC6             _switch39_case7:
1388   0CC6             ; print(*(char**)p); 
1389   0CC6             ; --- START FUNCTION CALL
1390   0CC6 FA FF FF      lea d, [bp + -1] ; $p
1391   0CC9 2A            mov b, [d]
1392   0CCA 38 00 00      mov c, 0
1393   0CCD 74            mov d, b
1394   0CCE 2A            mov b, [d]
1395   0CCF FD AB         swp b
1396   0CD1 D8            push b
1397   0CD2 07 7C 10      call print
1398   0CD5 51 02 00      add sp, 2
1399   0CD8             ; --- END FUNCTION CALL
1400   0CD8             ; p = p + 2; 
1401   0CD8 FA FF FF      lea d, [bp + -1] ; $p
1402   0CDB DA            push d
1403   0CDC FA FF FF      lea d, [bp + -1] ; $p
1404   0CDF 2A            mov b, [d]
1405   0CE0 38 00 00      mov c, 0
1406   0CE3             ; --- START TERMS
1407   0CE3 D7            push a
1408   0CE4 11            mov a, b
1409   0CE5 FD 2E 02 00   mov32 cb, $00000002
1409   0CE9 00 00 
1410   0CEB 56            add b, a
1411   0CEC E4            pop a
1412   0CED             ; --- END TERMS
1413   0CED E7            pop d
1414   0CEE FD 43         mov [d], b
1415   0CF0             ; break; 
1416   0CF0 0A FF 0C      jmp _switch39_exit ; case break
1417   0CF3             _switch39_default:
1418   0CF3             ; print("Error: Unknown argument type.\n"); 
1419   0CF3             ; --- START FUNCTION CALL
1420   0CF3 26 EA 14      mov b, _s8 ; "Error: Unknown argument type.\n"
1421   0CF6 FD AB         swp b
1422   0CF8 D8            push b
1423   0CF9 07 7C 10      call print
1424   0CFC 51 02 00      add sp, 2
1425   0CFF             ; --- END FUNCTION CALL
1426   0CFF             _switch39_exit:
1427   0CFF             ; format_p++; 
1428   0CFF FA FD FF      lea d, [bp + -3] ; $format_p
1429   0D02 2A            mov b, [d]
1430   0D03 38 00 00      mov c, 0
1431   0D06 FD 77         inc b
1432   0D08 FA FD FF      lea d, [bp + -3] ; $format_p
1433   0D0B FD 43         mov [d], b
1434   0D0D FD 7D         dec b
1435   0D0F 0A 37 0D      jmp _if38_exit
1436   0D12             _if38_else:
1437   0D12             ; putchar(*format_p); 
1438   0D12             ; --- START FUNCTION CALL
1439   0D12 FA FD FF      lea d, [bp + -3] ; $format_p
1440   0D15 2A            mov b, [d]
1441   0D16 38 00 00      mov c, 0
1442   0D19 74            mov d, b
1443   0D1A 32            mov bl, [d]
1444   0D1B A7 00         mov bh, 0
1445   0D1D 38 00 00      mov c, 0
1446   0D20 DD            push bl
1447   0D21 07 C4 0E      call putchar
1448   0D24 51 01 00      add sp, 1
1449   0D27             ; --- END FUNCTION CALL
1450   0D27             ; format_p++; 
1451   0D27 FA FD FF      lea d, [bp + -3] ; $format_p
1452   0D2A 2A            mov b, [d]
1453   0D2B 38 00 00      mov c, 0
1454   0D2E FD 77         inc b
1455   0D30 FA FD FF      lea d, [bp + -3] ; $format_p
1456   0D33 FD 43         mov [d], b
1457   0D35 FD 7D         dec b
1458   0D37             _if38_exit:
1459   0D37             _if37_exit:
1460   0D37             _for36_update:
1461   0D37 0A 6B 0A      jmp _for36_cond
1462   0D3A             _for36_exit:
1463   0D3A F9            leave
1464   0D3B 09            ret
1465   0D3C             
1466   0D3C             print_signed_long:
1467   0D3C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1468   0D3F             ; char digits[10]; 
1469   0D3F 52 0A 00      sub sp, 10
1470   0D42             ; int i = 0; 
1471   0D42 52 02 00      sub sp, 2
1472   0D45             ; --- START LOCAL VAR INITIALIZATION
1473   0D45 FA F5 FF      lea d, [bp + -11] ; $i
1474   0D48 DA            push d
1475   0D49 FD 2E 00 00   mov32 cb, $00000000
1475   0D4D 00 00 
1476   0D4F E7            pop d
1477   0D50 FD 43         mov [d], b
1478   0D52             ; --- END LOCAL VAR INITIALIZATION
1479   0D52             ; if (num < 0) { 
1480   0D52             _if43_cond:
1481   0D52 FA 05 00      lea d, [bp + 5] ; $num
1482   0D55 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1483   0D58 FD 39         mov c, b ; And place it into C
1484   0D5A 2A            mov b, [d] ; Lower Word in B
1485   0D5B             ; --- START RELATIONAL
1486   0D5B D7            push a
1487   0D5C FD D8         push g
1488   0D5E 11            mov a, b
1489   0D5F FD 7A         mov g, c
1490   0D61 FD 2E 00 00   mov32 cb, $00000000
1490   0D65 00 00 
1491   0D67 FD AF         cmp32 ga, cb
1492   0D69 FD 73         slt ; <
1493   0D6B FD F1         pop g
1494   0D6D E4            pop a
1495   0D6E             ; --- END RELATIONAL
1496   0D6E C0 00 00      cmp b, 0
1497   0D71 C6 A5 0D      je _if43_else
1498   0D74             _if43_TRUE:
1499   0D74             ; putchar('-'); 
1500   0D74             ; --- START FUNCTION CALL
1501   0D74 FD 2E 2D 00   mov32 cb, $0000002d
1501   0D78 00 00 
1502   0D7A DD            push bl
1503   0D7B 07 C4 0E      call putchar
1504   0D7E 51 01 00      add sp, 1
1505   0D81             ; --- END FUNCTION CALL
1506   0D81             ; num = -num; 
1507   0D81 FA 05 00      lea d, [bp + 5] ; $num
1508   0D84 DA            push d
1509   0D85 FA 05 00      lea d, [bp + 5] ; $num
1510   0D88 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1511   0D8B FD 39         mov c, b ; And place it into C
1512   0D8D 2A            mov b, [d] ; Lower Word in B
1513   0D8E 12            mov a, c
1514   0D8F 95            not a
1515   0D90 97            not b
1516   0D91 55 01 00      add b, 1
1517   0D94 5B 00 00      adc a, 0
1518   0D97 39            mov c, a
1519   0D98 E7            pop d
1520   0D99 FD 43         mov [d], b
1521   0D9B 26 00 00      mov b, 0
1522   0D9E FD 44 02 00   mov [d + 2], b
1523   0DA2 0A D9 0D      jmp _if43_exit
1524   0DA5             _if43_else:
1525   0DA5             ; if (num == 0) { 
1526   0DA5             _if44_cond:
1527   0DA5 FA 05 00      lea d, [bp + 5] ; $num
1528   0DA8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1529   0DAB FD 39         mov c, b ; And place it into C
1530   0DAD 2A            mov b, [d] ; Lower Word in B
1531   0DAE             ; --- START RELATIONAL
1532   0DAE D7            push a
1533   0DAF FD D8         push g
1534   0DB1 11            mov a, b
1535   0DB2 FD 7A         mov g, c
1536   0DB4 FD 2E 00 00   mov32 cb, $00000000
1536   0DB8 00 00 
1537   0DBA FD AF         cmp32 ga, cb
1538   0DBC FD 71         seq ; ==
1539   0DBE FD F1         pop g
1540   0DC0 E4            pop a
1541   0DC1             ; --- END RELATIONAL
1542   0DC1 C0 00 00      cmp b, 0
1543   0DC4 C6 D9 0D      je _if44_exit
1544   0DC7             _if44_TRUE:
1545   0DC7             ; putchar('0'); 
1546   0DC7             ; --- START FUNCTION CALL
1547   0DC7 FD 2E 30 00   mov32 cb, $00000030
1547   0DCB 00 00 
1548   0DCD DD            push bl
1549   0DCE 07 C4 0E      call putchar
1550   0DD1 51 01 00      add sp, 1
1551   0DD4             ; --- END FUNCTION CALL
1552   0DD4             ; return; 
1553   0DD4 F9            leave
1554   0DD5 09            ret
1555   0DD6 0A D9 0D      jmp _if44_exit
1556   0DD9             _if44_exit:
1557   0DD9             _if43_exit:
1558   0DD9             ; while (num > 0) { 
1559   0DD9             _while45_cond:
1560   0DD9 FA 05 00      lea d, [bp + 5] ; $num
1561   0DDC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1562   0DDF FD 39         mov c, b ; And place it into C
1563   0DE1 2A            mov b, [d] ; Lower Word in B
1564   0DE2             ; --- START RELATIONAL
1565   0DE2 D7            push a
1566   0DE3 FD D8         push g
1567   0DE5 11            mov a, b
1568   0DE6 FD 7A         mov g, c
1569   0DE8 FD 2E 00 00   mov32 cb, $00000000
1569   0DEC 00 00 
1570   0DEE FD AF         cmp32 ga, cb
1571   0DF0 FD 7F         sgt
1572   0DF2 FD F1         pop g
1573   0DF4 E4            pop a
1574   0DF5             ; --- END RELATIONAL
1575   0DF5 C0 00 00      cmp b, 0
1576   0DF8 C6 7A 0E      je _while45_exit
1577   0DFB             _while45_block:
1578   0DFB             ; digits[i] = '0' + (num % 10); 
1579   0DFB FA F7 FF      lea d, [bp + -9] ; $digits
1580   0DFE D7            push a
1581   0DFF DA            push d
1582   0E00 FA F5 FF      lea d, [bp + -11] ; $i
1583   0E03 2A            mov b, [d]
1584   0E04 38 00 00      mov c, 0
1585   0E07 E7            pop d
1586   0E08 5A            add d, b
1587   0E09 E4            pop a
1588   0E0A DA            push d
1589   0E0B FD 2E 30 00   mov32 cb, $00000030
1589   0E0F 00 00 
1590   0E11             ; --- START TERMS
1591   0E11 D7            push a
1592   0E12 11            mov a, b
1593   0E13 FA 05 00      lea d, [bp + 5] ; $num
1594   0E16 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1595   0E19 FD 39         mov c, b ; And place it into C
1596   0E1B 2A            mov b, [d] ; Lower Word in B
1597   0E1C             ; --- START FACTORS
1598   0E1C D7            push a
1599   0E1D FD D8         push g
1600   0E1F 11            mov a, b
1601   0E20 FD 7A         mov g, c
1602   0E22 FD 2E 0A 00   mov32 cb, $0000000a
1602   0E26 00 00 
1603   0E28 FD D8         push g ; save 'g' as the div instruction uses it
1604   0E2A AE            div a, b ; %, a: quotient, b: remainder
1605   0E2B 11            mov a, b
1606   0E2C FD F1         pop g
1607   0E2E FD 38         mov c, g
1608   0E30 27            mov b, a
1609   0E31 FD F1         pop g
1610   0E33 E4            pop a
1611   0E34             ; --- END FACTORS
1612   0E34 56            add b, a
1613   0E35 E4            pop a
1614   0E36             ; --- END TERMS
1615   0E36 E7            pop d
1616   0E37 FD 3E         mov [d], bl
1617   0E39             ; num = num / 10; 
1618   0E39 FA 05 00      lea d, [bp + 5] ; $num
1619   0E3C DA            push d
1620   0E3D FA 05 00      lea d, [bp + 5] ; $num
1621   0E40 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1622   0E43 FD 39         mov c, b ; And place it into C
1623   0E45 2A            mov b, [d] ; Lower Word in B
1624   0E46             ; --- START FACTORS
1625   0E46 D7            push a
1626   0E47 FD D8         push g
1627   0E49 11            mov a, b
1628   0E4A FD 7A         mov g, c
1629   0E4C FD 2E 0A 00   mov32 cb, $0000000a
1629   0E50 00 00 
1630   0E52 FD D8         push g ; save 'g' as the div instruction uses it
1631   0E54 AE            div a, b ; /, a: quotient, b: remainder
1632   0E55 FD F1         pop g
1633   0E57 FD 38         mov c, g
1634   0E59 27            mov b, a
1635   0E5A FD F1         pop g
1636   0E5C E4            pop a
1637   0E5D             ; --- END FACTORS
1638   0E5D E7            pop d
1639   0E5E FD 43         mov [d], b
1640   0E60 26 00 00      mov b, 0
1641   0E63 FD 44 02 00   mov [d + 2], b
1642   0E67             ; i++; 
1643   0E67 FA F5 FF      lea d, [bp + -11] ; $i
1644   0E6A 2A            mov b, [d]
1645   0E6B 38 00 00      mov c, 0
1646   0E6E 11            mov a, b
1647   0E6F FD 77         inc b
1648   0E71 FA F5 FF      lea d, [bp + -11] ; $i
1649   0E74 FD 43         mov [d], b
1650   0E76 27            mov b, a
1651   0E77 0A D9 0D      jmp _while45_cond
1652   0E7A             _while45_exit:
1653   0E7A             ; while (i > 0) { 
1654   0E7A             _while52_cond:
1655   0E7A FA F5 FF      lea d, [bp + -11] ; $i
1656   0E7D 2A            mov b, [d]
1657   0E7E 38 00 00      mov c, 0
1658   0E81             ; --- START RELATIONAL
1659   0E81 D7            push a
1660   0E82 11            mov a, b
1661   0E83 FD 2E 00 00   mov32 cb, $00000000
1661   0E87 00 00 
1662   0E89 B0            cmp a, b
1663   0E8A FD 7F         sgt ; >
1664   0E8C E4            pop a
1665   0E8D             ; --- END RELATIONAL
1666   0E8D C0 00 00      cmp b, 0
1667   0E90 C6 C2 0E      je _while52_exit
1668   0E93             _while52_block:
1669   0E93             ; i--; 
1670   0E93 FA F5 FF      lea d, [bp + -11] ; $i
1671   0E96 2A            mov b, [d]
1672   0E97 38 00 00      mov c, 0
1673   0E9A 11            mov a, b
1674   0E9B FD 7D         dec b
1675   0E9D FA F5 FF      lea d, [bp + -11] ; $i
1676   0EA0 FD 43         mov [d], b
1677   0EA2 27            mov b, a
1678   0EA3             ; putchar(digits[i]); 
1679   0EA3             ; --- START FUNCTION CALL
1680   0EA3 FA F7 FF      lea d, [bp + -9] ; $digits
1681   0EA6 D7            push a
1682   0EA7 DA            push d
1683   0EA8 FA F5 FF      lea d, [bp + -11] ; $i
1684   0EAB 2A            mov b, [d]
1685   0EAC 38 00 00      mov c, 0
1686   0EAF E7            pop d
1687   0EB0 5A            add d, b
1688   0EB1 E4            pop a
1689   0EB2 32            mov bl, [d]
1690   0EB3 A7 00         mov bh, 0
1691   0EB5 38 00 00      mov c, 0
1692   0EB8 DD            push bl
1693   0EB9 07 C4 0E      call putchar
1694   0EBC 51 01 00      add sp, 1
1695   0EBF             ; --- END FUNCTION CALL
1696   0EBF 0A 7A 0E      jmp _while52_cond
1697   0EC2             _while52_exit:
1698   0EC2 F9            leave
1699   0EC3 09            ret
1700   0EC4             
1701   0EC4             putchar:
1702   0EC4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1703   0EC7             ; --- BEGIN INLINE ASM SEGMENT
1704   0EC7 FA 05 00      lea d, [bp + 5] ; $c
1705   0ECA 1E            mov al, [d]
1706   0ECB 23            mov ah, al
1707   0ECC 19 00         mov al, 0
1708   0ECE 05 03         syscall sys_io      ; char in AH
1709   0ED0             ; --- END INLINE ASM SEGMENT
1710   0ED0 F9            leave
1711   0ED1 09            ret
1712   0ED2             
1713   0ED2             print_unsigned_long:
1714   0ED2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1715   0ED5             ; char digits[10]; 
1716   0ED5 52 0A 00      sub sp, 10
1717   0ED8             ; int i; 
1718   0ED8 52 02 00      sub sp, 2
1719   0EDB             ; i = 0; 
1720   0EDB FA F5 FF      lea d, [bp + -11] ; $i
1721   0EDE DA            push d
1722   0EDF FD 2E 00 00   mov32 cb, $00000000
1722   0EE3 00 00 
1723   0EE5 E7            pop d
1724   0EE6 FD 43         mov [d], b
1725   0EE8             ; if(num == 0){ 
1726   0EE8             _if53_cond:
1727   0EE8 FA 05 00      lea d, [bp + 5] ; $num
1728   0EEB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1729   0EEE FD 39         mov c, b ; And place it into C
1730   0EF0 2A            mov b, [d] ; Lower Word in B
1731   0EF1             ; --- START RELATIONAL
1732   0EF1 D7            push a
1733   0EF2 FD D8         push g
1734   0EF4 11            mov a, b
1735   0EF5 FD 7A         mov g, c
1736   0EF7 FD 2E 00 00   mov32 cb, $00000000
1736   0EFB 00 00 
1737   0EFD FD AF         cmp32 ga, cb
1738   0EFF FD 71         seq ; ==
1739   0F01 FD F1         pop g
1740   0F03 E4            pop a
1741   0F04             ; --- END RELATIONAL
1742   0F04 C0 00 00      cmp b, 0
1743   0F07 C6 1C 0F      je _if53_exit
1744   0F0A             _if53_TRUE:
1745   0F0A             ; putchar('0'); 
1746   0F0A             ; --- START FUNCTION CALL
1747   0F0A FD 2E 30 00   mov32 cb, $00000030
1747   0F0E 00 00 
1748   0F10 DD            push bl
1749   0F11 07 C4 0E      call putchar
1750   0F14 51 01 00      add sp, 1
1751   0F17             ; --- END FUNCTION CALL
1752   0F17             ; return; 
1753   0F17 F9            leave
1754   0F18 09            ret
1755   0F19 0A 1C 0F      jmp _if53_exit
1756   0F1C             _if53_exit:
1757   0F1C             ; while (num > 0) { 
1758   0F1C             _while54_cond:
1759   0F1C FA 05 00      lea d, [bp + 5] ; $num
1760   0F1F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1761   0F22 FD 39         mov c, b ; And place it into C
1762   0F24 2A            mov b, [d] ; Lower Word in B
1763   0F25             ; --- START RELATIONAL
1764   0F25 D7            push a
1765   0F26 FD D8         push g
1766   0F28 11            mov a, b
1767   0F29 FD 7A         mov g, c
1768   0F2B FD 2E 00 00   mov32 cb, $00000000
1768   0F2F 00 00 
1769   0F31 FD AF         cmp32 ga, cb
1770   0F33 FD 81         sgu
1771   0F35 FD F1         pop g
1772   0F37 E4            pop a
1773   0F38             ; --- END RELATIONAL
1774   0F38 C0 00 00      cmp b, 0
1775   0F3B C6 BD 0F      je _while54_exit
1776   0F3E             _while54_block:
1777   0F3E             ; digits[i] = '0' + (num % 10); 
1778   0F3E FA F7 FF      lea d, [bp + -9] ; $digits
1779   0F41 D7            push a
1780   0F42 DA            push d
1781   0F43 FA F5 FF      lea d, [bp + -11] ; $i
1782   0F46 2A            mov b, [d]
1783   0F47 38 00 00      mov c, 0
1784   0F4A E7            pop d
1785   0F4B 5A            add d, b
1786   0F4C E4            pop a
1787   0F4D DA            push d
1788   0F4E FD 2E 30 00   mov32 cb, $00000030
1788   0F52 00 00 
1789   0F54             ; --- START TERMS
1790   0F54 D7            push a
1791   0F55 11            mov a, b
1792   0F56 FA 05 00      lea d, [bp + 5] ; $num
1793   0F59 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1794   0F5C FD 39         mov c, b ; And place it into C
1795   0F5E 2A            mov b, [d] ; Lower Word in B
1796   0F5F             ; --- START FACTORS
1797   0F5F D7            push a
1798   0F60 FD D8         push g
1799   0F62 11            mov a, b
1800   0F63 FD 7A         mov g, c
1801   0F65 FD 2E 0A 00   mov32 cb, $0000000a
1801   0F69 00 00 
1802   0F6B FD D8         push g ; save 'g' as the div instruction uses it
1803   0F6D AE            div a, b ; %, a: quotient, b: remainder
1804   0F6E 11            mov a, b
1805   0F6F FD F1         pop g
1806   0F71 FD 38         mov c, g
1807   0F73 27            mov b, a
1808   0F74 FD F1         pop g
1809   0F76 E4            pop a
1810   0F77             ; --- END FACTORS
1811   0F77 56            add b, a
1812   0F78 E4            pop a
1813   0F79             ; --- END TERMS
1814   0F79 E7            pop d
1815   0F7A FD 3E         mov [d], bl
1816   0F7C             ; num = num / 10; 
1817   0F7C FA 05 00      lea d, [bp + 5] ; $num
1818   0F7F DA            push d
1819   0F80 FA 05 00      lea d, [bp + 5] ; $num
1820   0F83 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1821   0F86 FD 39         mov c, b ; And place it into C
1822   0F88 2A            mov b, [d] ; Lower Word in B
1823   0F89             ; --- START FACTORS
1824   0F89 D7            push a
1825   0F8A FD D8         push g
1826   0F8C 11            mov a, b
1827   0F8D FD 7A         mov g, c
1828   0F8F FD 2E 0A 00   mov32 cb, $0000000a
1828   0F93 00 00 
1829   0F95 FD D8         push g ; save 'g' as the div instruction uses it
1830   0F97 AE            div a, b ; /, a: quotient, b: remainder
1831   0F98 FD F1         pop g
1832   0F9A FD 38         mov c, g
1833   0F9C 27            mov b, a
1834   0F9D FD F1         pop g
1835   0F9F E4            pop a
1836   0FA0             ; --- END FACTORS
1837   0FA0 E7            pop d
1838   0FA1 FD 43         mov [d], b
1839   0FA3 26 00 00      mov b, 0
1840   0FA6 FD 44 02 00   mov [d + 2], b
1841   0FAA             ; i++; 
1842   0FAA FA F5 FF      lea d, [bp + -11] ; $i
1843   0FAD 2A            mov b, [d]
1844   0FAE 38 00 00      mov c, 0
1845   0FB1 11            mov a, b
1846   0FB2 FD 77         inc b
1847   0FB4 FA F5 FF      lea d, [bp + -11] ; $i
1848   0FB7 FD 43         mov [d], b
1849   0FB9 27            mov b, a
1850   0FBA 0A 1C 0F      jmp _while54_cond
1851   0FBD             _while54_exit:
1852   0FBD             ; while (i > 0) { 
1853   0FBD             _while61_cond:
1854   0FBD FA F5 FF      lea d, [bp + -11] ; $i
1855   0FC0 2A            mov b, [d]
1856   0FC1 38 00 00      mov c, 0
1857   0FC4             ; --- START RELATIONAL
1858   0FC4 D7            push a
1859   0FC5 11            mov a, b
1860   0FC6 FD 2E 00 00   mov32 cb, $00000000
1860   0FCA 00 00 
1861   0FCC B0            cmp a, b
1862   0FCD FD 7F         sgt ; >
1863   0FCF E4            pop a
1864   0FD0             ; --- END RELATIONAL
1865   0FD0 C0 00 00      cmp b, 0
1866   0FD3 C6 05 10      je _while61_exit
1867   0FD6             _while61_block:
1868   0FD6             ; i--; 
1869   0FD6 FA F5 FF      lea d, [bp + -11] ; $i
1870   0FD9 2A            mov b, [d]
1871   0FDA 38 00 00      mov c, 0
1872   0FDD 11            mov a, b
1873   0FDE FD 7D         dec b
1874   0FE0 FA F5 FF      lea d, [bp + -11] ; $i
1875   0FE3 FD 43         mov [d], b
1876   0FE5 27            mov b, a
1877   0FE6             ; putchar(digits[i]); 
1878   0FE6             ; --- START FUNCTION CALL
1879   0FE6 FA F7 FF      lea d, [bp + -9] ; $digits
1880   0FE9 D7            push a
1881   0FEA DA            push d
1882   0FEB FA F5 FF      lea d, [bp + -11] ; $i
1883   0FEE 2A            mov b, [d]
1884   0FEF 38 00 00      mov c, 0
1885   0FF2 E7            pop d
1886   0FF3 5A            add d, b
1887   0FF4 E4            pop a
1888   0FF5 32            mov bl, [d]
1889   0FF6 A7 00         mov bh, 0
1890   0FF8 38 00 00      mov c, 0
1891   0FFB DD            push bl
1892   0FFC 07 C4 0E      call putchar
1893   0FFF 51 01 00      add sp, 1
1894   1002             ; --- END FUNCTION CALL
1895   1002 0A BD 0F      jmp _while61_cond
1896   1005             _while61_exit:
1897   1005 F9            leave
1898   1006 09            ret
1899   1007             
1900   1007             printx32:
1901   1007 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1902   100A             ; --- BEGIN INLINE ASM SEGMENT
1903   100A FA 05 00      lea d, [bp + 5] ; $hex
1904   100D 2B 02 00      mov b, [d+2]
1905   1010 07 19 10      call print_u16x_printx32
1906   1013 2A            mov b, [d]
1907   1014 07 19 10      call print_u16x_printx32
1908   1017             ; --- END INLINE ASM SEGMENT
1909   1017             ; return; 
1910   1017 F9            leave
1911   1018 09            ret
1912   1019             ; --- BEGIN INLINE ASM SEGMENT
1913   1019             print_u16x_printx32:
1914   1019 D7            push a
1915   101A D8            push b
1916   101B DD            push bl
1917   101C 30            mov bl, bh
1918   101D 07 3B 10      call _itoa_printx32        ; convert bh to char in A
1919   1020 2F            mov bl, al        ; save al
1920   1021 19 00         mov al, 0
1921   1023 05 03         syscall sys_io        ; display AH
1922   1025 24            mov ah, bl        ; retrieve al
1923   1026 19 00         mov al, 0
1924   1028 05 03         syscall sys_io        ; display AL
1925   102A EA            pop bl
1926   102B 07 3B 10      call _itoa_printx32        ; convert bh to char in A
1927   102E 2F            mov bl, al        ; save al
1928   102F 19 00         mov al, 0
1929   1031 05 03         syscall sys_io        ; display AH
1930   1033 24            mov ah, bl        ; retrieve al
1931   1034 19 00         mov al, 0
1932   1036 05 03         syscall sys_io        ; display AL
1933   1038 E5            pop b
1934   1039 E4            pop a
1935   103A 09            ret
1936   103B             _itoa_printx32:
1937   103B DA            push d
1938   103C D8            push b
1939   103D A7 00         mov bh, 0
1940   103F FD A4 04      shr bl, 4  
1941   1042 74            mov d, b
1942   1043 1F 55 10      mov al, [d + s_hex_digits_printx32]
1943   1046 23            mov ah, al
1944   1047 E5            pop b
1945   1048 D8            push b
1946   1049 A7 00         mov bh, 0
1947   104B FD 87 0F      and bl, $0F
1948   104E 74            mov d, b
1949   104F 1F 55 10      mov al, [d + s_hex_digits_printx32]
1950   1052 E5            pop b
1951   1053 E7            pop d
1952   1054 09            ret
1953   1055 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1953   1059 34 35 36 37 
1953   105D 38 39 41 42 
1953   1061 43 44 45 46 
1954   1065             ; --- END INLINE ASM SEGMENT
1955   1065 F9            leave
1956   1066 09            ret
1957   1067             
1958   1067             err:
1959   1067 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1960   106A             ; print(e); 
1961   106A             ; --- START FUNCTION CALL
1962   106A FA 05 00      lea d, [bp + 5] ; $e
1963   106D 2A            mov b, [d]
1964   106E 38 00 00      mov c, 0
1965   1071 FD AB         swp b
1966   1073 D8            push b
1967   1074 07 7C 10      call print
1968   1077 51 02 00      add sp, 2
1969   107A             ; --- END FUNCTION CALL
1970   107A F9            leave
1971   107B 09            ret
1972   107C             
1973   107C             print:
1974   107C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1975   107F             ; --- BEGIN INLINE ASM SEGMENT
1976   107F FA 05 00      lea d, [bp + 5] ; $s
1977   1082 FD 2A         mov d, [d]
1978   1084             _puts_L1_print:
1979   1084 1E            mov al, [d]
1980   1085 B9 00         cmp al, 0
1981   1087 C6 93 10      jz _puts_END_print
1982   108A 23            mov ah, al
1983   108B 19 00         mov al, 0
1984   108D 05 03         syscall sys_io
1985   108F 79            inc d
1986   1090 0A 84 10      jmp _puts_L1_print
1987   1093             _puts_END_print:
1988   1093             ; --- END INLINE ASM SEGMENT
1989   1093 F9            leave
1990   1094 09            ret
1991   1095             
1992   1095             print_signed:
1993   1095 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1994   1098             ; char digits[5]; 
1995   1098 52 05 00      sub sp, 5
1996   109B             ; int i = 0; 
1997   109B 52 02 00      sub sp, 2
1998   109E             ; --- START LOCAL VAR INITIALIZATION
1999   109E FA FA FF      lea d, [bp + -6] ; $i
2000   10A1 DA            push d
2001   10A2 FD 2E 00 00   mov32 cb, $00000000
2001   10A6 00 00 
2002   10A8 E7            pop d
2003   10A9 FD 43         mov [d], b
2004   10AB             ; --- END LOCAL VAR INITIALIZATION
2005   10AB             ; if (num < 0) { 
2006   10AB             _if62_cond:
2007   10AB FA 05 00      lea d, [bp + 5] ; $num
2008   10AE 2A            mov b, [d]
2009   10AF 38 00 00      mov c, 0
2010   10B2             ; --- START RELATIONAL
2011   10B2 D7            push a
2012   10B3 11            mov a, b
2013   10B4 FD 2E 00 00   mov32 cb, $00000000
2013   10B8 00 00 
2014   10BA B0            cmp a, b
2015   10BB FD 73         slt ; < (signed)
2016   10BD E4            pop a
2017   10BE             ; --- END RELATIONAL
2018   10BE C0 00 00      cmp b, 0
2019   10C1 C6 E4 10      je _if62_else
2020   10C4             _if62_TRUE:
2021   10C4             ; putchar('-'); 
2022   10C4             ; --- START FUNCTION CALL
2023   10C4 FD 2E 2D 00   mov32 cb, $0000002d
2023   10C8 00 00 
2024   10CA DD            push bl
2025   10CB 07 C4 0E      call putchar
2026   10CE 51 01 00      add sp, 1
2027   10D1             ; --- END FUNCTION CALL
2028   10D1             ; num = -num; 
2029   10D1 FA 05 00      lea d, [bp + 5] ; $num
2030   10D4 DA            push d
2031   10D5 FA 05 00      lea d, [bp + 5] ; $num
2032   10D8 2A            mov b, [d]
2033   10D9 38 00 00      mov c, 0
2034   10DC FD 97         neg b
2035   10DE E7            pop d
2036   10DF FD 43         mov [d], b
2037   10E1 0A 0F 11      jmp _if62_exit
2038   10E4             _if62_else:
2039   10E4             ; if (num == 0) { 
2040   10E4             _if63_cond:
2041   10E4 FA 05 00      lea d, [bp + 5] ; $num
2042   10E7 2A            mov b, [d]
2043   10E8 38 00 00      mov c, 0
2044   10EB             ; --- START RELATIONAL
2045   10EB D7            push a
2046   10EC 11            mov a, b
2047   10ED FD 2E 00 00   mov32 cb, $00000000
2047   10F1 00 00 
2048   10F3 B0            cmp a, b
2049   10F4 FD 71         seq ; ==
2050   10F6 E4            pop a
2051   10F7             ; --- END RELATIONAL
2052   10F7 C0 00 00      cmp b, 0
2053   10FA C6 0F 11      je _if63_exit
2054   10FD             _if63_TRUE:
2055   10FD             ; putchar('0'); 
2056   10FD             ; --- START FUNCTION CALL
2057   10FD FD 2E 30 00   mov32 cb, $00000030
2057   1101 00 00 
2058   1103 DD            push bl
2059   1104 07 C4 0E      call putchar
2060   1107 51 01 00      add sp, 1
2061   110A             ; --- END FUNCTION CALL
2062   110A             ; return; 
2063   110A F9            leave
2064   110B 09            ret
2065   110C 0A 0F 11      jmp _if63_exit
2066   110F             _if63_exit:
2067   110F             _if62_exit:
2068   110F             ; while (num > 0) { 
2069   110F             _while64_cond:
2070   110F FA 05 00      lea d, [bp + 5] ; $num
2071   1112 2A            mov b, [d]
2072   1113 38 00 00      mov c, 0
2073   1116             ; --- START RELATIONAL
2074   1116 D7            push a
2075   1117 11            mov a, b
2076   1118 FD 2E 00 00   mov32 cb, $00000000
2076   111C 00 00 
2077   111E B0            cmp a, b
2078   111F FD 7F         sgt ; >
2079   1121 E4            pop a
2080   1122             ; --- END RELATIONAL
2081   1122 C0 00 00      cmp b, 0
2082   1125 C6 9C 11      je _while64_exit
2083   1128             _while64_block:
2084   1128             ; digits[i] = '0' + (num % 10); 
2085   1128 FA FC FF      lea d, [bp + -4] ; $digits
2086   112B D7            push a
2087   112C DA            push d
2088   112D FA FA FF      lea d, [bp + -6] ; $i
2089   1130 2A            mov b, [d]
2090   1131 38 00 00      mov c, 0
2091   1134 E7            pop d
2092   1135 5A            add d, b
2093   1136 E4            pop a
2094   1137 DA            push d
2095   1138 FD 2E 30 00   mov32 cb, $00000030
2095   113C 00 00 
2096   113E             ; --- START TERMS
2097   113E D7            push a
2098   113F 11            mov a, b
2099   1140 FA 05 00      lea d, [bp + 5] ; $num
2100   1143 2A            mov b, [d]
2101   1144 38 00 00      mov c, 0
2102   1147             ; --- START FACTORS
2103   1147 D7            push a
2104   1148 FD D8         push g
2105   114A 11            mov a, b
2106   114B FD 7A         mov g, c
2107   114D FD 2E 0A 00   mov32 cb, $0000000a
2107   1151 00 00 
2108   1153 FD D8         push g ; save 'g' as the div instruction uses it
2109   1155 AE            div a, b ; %, a: quotient, b: remainder
2110   1156 11            mov a, b
2111   1157 FD F1         pop g
2112   1159 FD 38         mov c, g
2113   115B 27            mov b, a
2114   115C FD F1         pop g
2115   115E E4            pop a
2116   115F             ; --- END FACTORS
2117   115F 56            add b, a
2118   1160 E4            pop a
2119   1161             ; --- END TERMS
2120   1161 E7            pop d
2121   1162 FD 3E         mov [d], bl
2122   1164             ; num = num / 10; 
2123   1164 FA 05 00      lea d, [bp + 5] ; $num
2124   1167 DA            push d
2125   1168 FA 05 00      lea d, [bp + 5] ; $num
2126   116B 2A            mov b, [d]
2127   116C 38 00 00      mov c, 0
2128   116F             ; --- START FACTORS
2129   116F D7            push a
2130   1170 FD D8         push g
2131   1172 11            mov a, b
2132   1173 FD 7A         mov g, c
2133   1175 FD 2E 0A 00   mov32 cb, $0000000a
2133   1179 00 00 
2134   117B FD D8         push g ; save 'g' as the div instruction uses it
2135   117D AE            div a, b ; /, a: quotient, b: remainder
2136   117E FD F1         pop g
2137   1180 FD 38         mov c, g
2138   1182 27            mov b, a
2139   1183 FD F1         pop g
2140   1185 E4            pop a
2141   1186             ; --- END FACTORS
2142   1186 E7            pop d
2143   1187 FD 43         mov [d], b
2144   1189             ; i++; 
2145   1189 FA FA FF      lea d, [bp + -6] ; $i
2146   118C 2A            mov b, [d]
2147   118D 38 00 00      mov c, 0
2148   1190 11            mov a, b
2149   1191 FD 77         inc b
2150   1193 FA FA FF      lea d, [bp + -6] ; $i
2151   1196 FD 43         mov [d], b
2152   1198 27            mov b, a
2153   1199 0A 0F 11      jmp _while64_cond
2154   119C             _while64_exit:
2155   119C             ; while (i > 0) { 
2156   119C             _while71_cond:
2157   119C FA FA FF      lea d, [bp + -6] ; $i
2158   119F 2A            mov b, [d]
2159   11A0 38 00 00      mov c, 0
2160   11A3             ; --- START RELATIONAL
2161   11A3 D7            push a
2162   11A4 11            mov a, b
2163   11A5 FD 2E 00 00   mov32 cb, $00000000
2163   11A9 00 00 
2164   11AB B0            cmp a, b
2165   11AC FD 7F         sgt ; >
2166   11AE E4            pop a
2167   11AF             ; --- END RELATIONAL
2168   11AF C0 00 00      cmp b, 0
2169   11B2 C6 E4 11      je _while71_exit
2170   11B5             _while71_block:
2171   11B5             ; i--; 
2172   11B5 FA FA FF      lea d, [bp + -6] ; $i
2173   11B8 2A            mov b, [d]
2174   11B9 38 00 00      mov c, 0
2175   11BC 11            mov a, b
2176   11BD FD 7D         dec b
2177   11BF FA FA FF      lea d, [bp + -6] ; $i
2178   11C2 FD 43         mov [d], b
2179   11C4 27            mov b, a
2180   11C5             ; putchar(digits[i]); 
2181   11C5             ; --- START FUNCTION CALL
2182   11C5 FA FC FF      lea d, [bp + -4] ; $digits
2183   11C8 D7            push a
2184   11C9 DA            push d
2185   11CA FA FA FF      lea d, [bp + -6] ; $i
2186   11CD 2A            mov b, [d]
2187   11CE 38 00 00      mov c, 0
2188   11D1 E7            pop d
2189   11D2 5A            add d, b
2190   11D3 E4            pop a
2191   11D4 32            mov bl, [d]
2192   11D5 A7 00         mov bh, 0
2193   11D7 38 00 00      mov c, 0
2194   11DA DD            push bl
2195   11DB 07 C4 0E      call putchar
2196   11DE 51 01 00      add sp, 1
2197   11E1             ; --- END FUNCTION CALL
2198   11E1 0A 9C 11      jmp _while71_cond
2199   11E4             _while71_exit:
2200   11E4 F9            leave
2201   11E5 09            ret
2202   11E6             
2203   11E6             print_unsigned:
2204   11E6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2205   11E9             ; char digits[5]; 
2206   11E9 52 05 00      sub sp, 5
2207   11EC             ; int i; 
2208   11EC 52 02 00      sub sp, 2
2209   11EF             ; i = 0; 
2210   11EF FA FA FF      lea d, [bp + -6] ; $i
2211   11F2 DA            push d
2212   11F3 FD 2E 00 00   mov32 cb, $00000000
2212   11F7 00 00 
2213   11F9 E7            pop d
2214   11FA FD 43         mov [d], b
2215   11FC             ; if(num == 0){ 
2216   11FC             _if72_cond:
2217   11FC FA 05 00      lea d, [bp + 5] ; $num
2218   11FF 2A            mov b, [d]
2219   1200 38 00 00      mov c, 0
2220   1203             ; --- START RELATIONAL
2221   1203 D7            push a
2222   1204 11            mov a, b
2223   1205 FD 2E 00 00   mov32 cb, $00000000
2223   1209 00 00 
2224   120B B0            cmp a, b
2225   120C FD 71         seq ; ==
2226   120E E4            pop a
2227   120F             ; --- END RELATIONAL
2228   120F C0 00 00      cmp b, 0
2229   1212 C6 27 12      je _if72_exit
2230   1215             _if72_TRUE:
2231   1215             ; putchar('0'); 
2232   1215             ; --- START FUNCTION CALL
2233   1215 FD 2E 30 00   mov32 cb, $00000030
2233   1219 00 00 
2234   121B DD            push bl
2235   121C 07 C4 0E      call putchar
2236   121F 51 01 00      add sp, 1
2237   1222             ; --- END FUNCTION CALL
2238   1222             ; return; 
2239   1222 F9            leave
2240   1223 09            ret
2241   1224 0A 27 12      jmp _if72_exit
2242   1227             _if72_exit:
2243   1227             ; while (num > 0) { 
2244   1227             _while73_cond:
2245   1227 FA 05 00      lea d, [bp + 5] ; $num
2246   122A 2A            mov b, [d]
2247   122B 38 00 00      mov c, 0
2248   122E             ; --- START RELATIONAL
2249   122E D7            push a
2250   122F 11            mov a, b
2251   1230 FD 2E 00 00   mov32 cb, $00000000
2251   1234 00 00 
2252   1236 B0            cmp a, b
2253   1237 FD 81         sgu ; > (unsigned)
2254   1239 E4            pop a
2255   123A             ; --- END RELATIONAL
2256   123A C0 00 00      cmp b, 0
2257   123D C6 B4 12      je _while73_exit
2258   1240             _while73_block:
2259   1240             ; digits[i] = '0' + (num % 10); 
2260   1240 FA FC FF      lea d, [bp + -4] ; $digits
2261   1243 D7            push a
2262   1244 DA            push d
2263   1245 FA FA FF      lea d, [bp + -6] ; $i
2264   1248 2A            mov b, [d]
2265   1249 38 00 00      mov c, 0
2266   124C E7            pop d
2267   124D 5A            add d, b
2268   124E E4            pop a
2269   124F DA            push d
2270   1250 FD 2E 30 00   mov32 cb, $00000030
2270   1254 00 00 
2271   1256             ; --- START TERMS
2272   1256 D7            push a
2273   1257 11            mov a, b
2274   1258 FA 05 00      lea d, [bp + 5] ; $num
2275   125B 2A            mov b, [d]
2276   125C 38 00 00      mov c, 0
2277   125F             ; --- START FACTORS
2278   125F D7            push a
2279   1260 FD D8         push g
2280   1262 11            mov a, b
2281   1263 FD 7A         mov g, c
2282   1265 FD 2E 0A 00   mov32 cb, $0000000a
2282   1269 00 00 
2283   126B FD D8         push g ; save 'g' as the div instruction uses it
2284   126D AE            div a, b ; %, a: quotient, b: remainder
2285   126E 11            mov a, b
2286   126F FD F1         pop g
2287   1271 FD 38         mov c, g
2288   1273 27            mov b, a
2289   1274 FD F1         pop g
2290   1276 E4            pop a
2291   1277             ; --- END FACTORS
2292   1277 56            add b, a
2293   1278 E4            pop a
2294   1279             ; --- END TERMS
2295   1279 E7            pop d
2296   127A FD 3E         mov [d], bl
2297   127C             ; num = num / 10; 
2298   127C FA 05 00      lea d, [bp + 5] ; $num
2299   127F DA            push d
2300   1280 FA 05 00      lea d, [bp + 5] ; $num
2301   1283 2A            mov b, [d]
2302   1284 38 00 00      mov c, 0
2303   1287             ; --- START FACTORS
2304   1287 D7            push a
2305   1288 FD D8         push g
2306   128A 11            mov a, b
2307   128B FD 7A         mov g, c
2308   128D FD 2E 0A 00   mov32 cb, $0000000a
2308   1291 00 00 
2309   1293 FD D8         push g ; save 'g' as the div instruction uses it
2310   1295 AE            div a, b ; /, a: quotient, b: remainder
2311   1296 FD F1         pop g
2312   1298 FD 38         mov c, g
2313   129A 27            mov b, a
2314   129B FD F1         pop g
2315   129D E4            pop a
2316   129E             ; --- END FACTORS
2317   129E E7            pop d
2318   129F FD 43         mov [d], b
2319   12A1             ; i++; 
2320   12A1 FA FA FF      lea d, [bp + -6] ; $i
2321   12A4 2A            mov b, [d]
2322   12A5 38 00 00      mov c, 0
2323   12A8 11            mov a, b
2324   12A9 FD 77         inc b
2325   12AB FA FA FF      lea d, [bp + -6] ; $i
2326   12AE FD 43         mov [d], b
2327   12B0 27            mov b, a
2328   12B1 0A 27 12      jmp _while73_cond
2329   12B4             _while73_exit:
2330   12B4             ; while (i > 0) { 
2331   12B4             _while80_cond:
2332   12B4 FA FA FF      lea d, [bp + -6] ; $i
2333   12B7 2A            mov b, [d]
2334   12B8 38 00 00      mov c, 0
2335   12BB             ; --- START RELATIONAL
2336   12BB D7            push a
2337   12BC 11            mov a, b
2338   12BD FD 2E 00 00   mov32 cb, $00000000
2338   12C1 00 00 
2339   12C3 B0            cmp a, b
2340   12C4 FD 7F         sgt ; >
2341   12C6 E4            pop a
2342   12C7             ; --- END RELATIONAL
2343   12C7 C0 00 00      cmp b, 0
2344   12CA C6 FC 12      je _while80_exit
2345   12CD             _while80_block:
2346   12CD             ; i--; 
2347   12CD FA FA FF      lea d, [bp + -6] ; $i
2348   12D0 2A            mov b, [d]
2349   12D1 38 00 00      mov c, 0
2350   12D4 11            mov a, b
2351   12D5 FD 7D         dec b
2352   12D7 FA FA FF      lea d, [bp + -6] ; $i
2353   12DA FD 43         mov [d], b
2354   12DC 27            mov b, a
2355   12DD             ; putchar(digits[i]); 
2356   12DD             ; --- START FUNCTION CALL
2357   12DD FA FC FF      lea d, [bp + -4] ; $digits
2358   12E0 D7            push a
2359   12E1 DA            push d
2360   12E2 FA FA FF      lea d, [bp + -6] ; $i
2361   12E5 2A            mov b, [d]
2362   12E6 38 00 00      mov c, 0
2363   12E9 E7            pop d
2364   12EA 5A            add d, b
2365   12EB E4            pop a
2366   12EC 32            mov bl, [d]
2367   12ED A7 00         mov bh, 0
2368   12EF 38 00 00      mov c, 0
2369   12F2 DD            push bl
2370   12F3 07 C4 0E      call putchar
2371   12F6 51 01 00      add sp, 1
2372   12F9             ; --- END FUNCTION CALL
2373   12F9 0A B4 12      jmp _while80_cond
2374   12FC             _while80_exit:
2375   12FC F9            leave
2376   12FD 09            ret
2377   12FE             
2378   12FE             printx16:
2379   12FE F8 00 00      enter 0 ; (push bp; mov bp, sp)
2380   1301             ; --- BEGIN INLINE ASM SEGMENT
2381   1301 FA 05 00      lea d, [bp + 5] ; $hex
2382   1304 2A            mov b, [d]
2383   1305             print_u16x_printx16:
2384   1305 DD            push bl
2385   1306 30            mov bl, bh
2386   1307 07 24 13      call _itoa_printx16        ; convert bh to char in A
2387   130A 2F            mov bl, al        ; save al
2388   130B 19 00         mov al, 0
2389   130D 05 03         syscall sys_io        ; display AH
2390   130F 24            mov ah, bl        ; retrieve al
2391   1310 19 00         mov al, 0
2392   1312 05 03         syscall sys_io        ; display AL
2393   1314 EA            pop bl
2394   1315 07 24 13      call _itoa_printx16        ; convert bh to char in A
2395   1318 2F            mov bl, al        ; save al
2396   1319 19 00         mov al, 0
2397   131B 05 03         syscall sys_io        ; display AH
2398   131D 24            mov ah, bl        ; retrieve al
2399   131E 19 00         mov al, 0
2400   1320 05 03         syscall sys_io        ; display AL
2401   1322             ; --- END INLINE ASM SEGMENT
2402   1322             ; return; 
2403   1322 F9            leave
2404   1323 09            ret
2405   1324             ; --- BEGIN INLINE ASM SEGMENT
2406   1324             _itoa_printx16:
2407   1324 DA            push d
2408   1325 D8            push b
2409   1326 A7 00         mov bh, 0
2410   1328 FD A4 04      shr bl, 4  
2411   132B 74            mov d, b
2412   132C 1F 3E 13      mov al, [d + s_hex_digits_printx16]
2413   132F 23            mov ah, al
2414   1330 E5            pop b
2415   1331 D8            push b
2416   1332 A7 00         mov bh, 0
2417   1334 FD 87 0F      and bl, $0F
2418   1337 74            mov d, b
2419   1338 1F 3E 13      mov al, [d + s_hex_digits_printx16]
2420   133B E5            pop b
2421   133C E7            pop d
2422   133D 09            ret
2423   133E 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
2423   1342 34 35 36 37 
2423   1346 38 39 41 42 
2423   134A 43 44 45 46 
2424   134E             ; --- END INLINE ASM SEGMENT
2425   134E F9            leave
2426   134F 09            ret
2427   1350             
2428   1350             gets:
2429   1350 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2430   1353             ; --- BEGIN INLINE ASM SEGMENT
2431   1353 FA 05 00      lea d, [bp + 5] ; $s
2432   1356 15            mov a, [d]
2433   1357 3C            mov d, a
2434   1358 07 6D 13      call _gets_gets
2435   135B             ; --- END INLINE ASM SEGMENT
2436   135B             ; return strlen(s); 
2437   135B             ; --- START FUNCTION CALL
2438   135B FA 05 00      lea d, [bp + 5] ; $s
2439   135E 2A            mov b, [d]
2440   135F 38 00 00      mov c, 0
2441   1362 FD AB         swp b
2442   1364 D8            push b
2443   1365 07 0E 14      call strlen
2444   1368 51 02 00      add sp, 2
2445   136B             ; --- END FUNCTION CALL
2446   136B F9            leave
2447   136C 09            ret
2448   136D             ; --- BEGIN INLINE ASM SEGMENT
2449   136D             _gets_gets:
2450   136D D7            push a
2451   136E DA            push d
2452   136F             _gets_loop_gets:
2453   136F 19 01         mov al, 1
2454   1371 05 03         syscall sys_io      ; receive in AH
2455   1373 B9 00         cmp al, 0        ; check error code (AL)
2456   1375 C6 6F 13      je _gets_loop_gets      ; if no char received, retry
2457   1378 76 1B         cmp ah, 27
2458   137A C6 9B 13      je _gets_ansi_esc_gets
2459   137D 76 0A         cmp ah, $0A        ; LF
2460   137F C6 06 14      je _gets_end_gets
2461   1382 76 0D         cmp ah, $0D        ; CR
2462   1384 C6 06 14      je _gets_end_gets
2463   1387 76 5C         cmp ah, $5C        ; '\\'
2464   1389 C6 C7 13      je _gets_escape_gets
2465   138C 76 08         cmp ah, $08      ; check for backspace
2466   138E C6 97 13      je _gets_backspace_gets
2467   1391 1A            mov al, ah
2468   1392 3E            mov [d], al
2469   1393 79            inc d
2470   1394 0A 6F 13      jmp _gets_loop_gets
2471   1397             _gets_backspace_gets:
2472   1397 7F            dec d
2473   1398 0A 6F 13      jmp _gets_loop_gets
2474   139B             _gets_ansi_esc_gets:
2475   139B 19 01         mov al, 1
2476   139D 05 03         syscall sys_io        ; receive in AH without echo
2477   139F B9 00         cmp al, 0          ; check error code (AL)
2478   13A1 C6 9B 13      je _gets_ansi_esc_gets    ; if no char received, retry
2479   13A4 76 5B         cmp ah, '['
2480   13A6 C7 6F 13      jne _gets_loop_gets
2481   13A9             _gets_ansi_esc_2_gets:
2482   13A9 19 01         mov al, 1
2483   13AB 05 03         syscall sys_io          ; receive in AH without echo
2484   13AD B9 00         cmp al, 0            ; check error code (AL)
2485   13AF C6 A9 13      je _gets_ansi_esc_2_gets  ; if no char received, retry
2486   13B2 76 44         cmp ah, 'D'
2487   13B4 C6 BF 13      je _gets_left_arrow_gets
2488   13B7 76 43         cmp ah, 'C'
2489   13B9 C6 C3 13      je _gets_right_arrow_gets
2490   13BC 0A 6F 13      jmp _gets_loop_gets
2491   13BF             _gets_left_arrow_gets:
2492   13BF 7F            dec d
2493   13C0 0A 6F 13      jmp _gets_loop_gets
2494   13C3             _gets_right_arrow_gets:
2495   13C3 79            inc d
2496   13C4 0A 6F 13      jmp _gets_loop_gets
2497   13C7             _gets_escape_gets:
2498   13C7 19 01         mov al, 1
2499   13C9 05 03         syscall sys_io      ; receive in AH
2500   13CB B9 00         cmp al, 0        ; check error code (AL)
2501   13CD C6 C7 13      je _gets_escape_gets      ; if no char received, retry
2502   13D0 76 6E         cmp ah, 'n'
2503   13D2 C6 F1 13      je _gets_LF_gets
2504   13D5 76 72         cmp ah, 'r'
2505   13D7 C6 F8 13      je _gets_CR_gets
2506   13DA 76 30         cmp ah, '0'
2507   13DC C6 FF 13      je _gets_NULL_gets
2508   13DF 76 5C         cmp ah, $5C  
2509   13E1 C6 EA 13      je _gets_slash_gets
2510   13E4 1A            mov al, ah        ; if not a known escape, it is just a normal letter
2511   13E5 3E            mov [d], al
2512   13E6 79            inc d
2513   13E7 0A 6F 13      jmp _gets_loop_gets
2514   13EA             _gets_slash_gets:
2515   13EA 19 5C         mov al, $5C
2516   13EC 3E            mov [d], al
2517   13ED 79            inc d
2518   13EE 0A 6F 13      jmp _gets_loop_gets
2519   13F1             _gets_LF_gets:
2520   13F1 19 0A         mov al, $0A
2521   13F3 3E            mov [d], al
2522   13F4 79            inc d
2523   13F5 0A 6F 13      jmp _gets_loop_gets
2524   13F8             _gets_CR_gets:
2525   13F8 19 0D         mov al, $0D
2526   13FA 3E            mov [d], al
2527   13FB 79            inc d
2528   13FC 0A 6F 13      jmp _gets_loop_gets
2529   13FF             _gets_NULL_gets:
2530   13FF 19 00         mov al, $00
2531   1401 3E            mov [d], al
2532   1402 79            inc d
2533   1403 0A 6F 13      jmp _gets_loop_gets
2534   1406             _gets_end_gets:
2535   1406 19 00         mov al, 0
2536   1408 3E            mov [d], al        ; terminate string
2537   1409 E7            pop d
2538   140A E4            pop a
2539   140B 09            ret
2540   140C             ; --- END INLINE ASM SEGMENT
2541   140C F9            leave
2542   140D 09            ret
2543   140E             
2544   140E             strlen:
2545   140E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2546   1411             ; int length; 
2547   1411 52 02 00      sub sp, 2
2548   1414             ; length = 0; 
2549   1414 FA FF FF      lea d, [bp + -1] ; $length
2550   1417 DA            push d
2551   1418 FD 2E 00 00   mov32 cb, $00000000
2551   141C 00 00 
2552   141E E7            pop d
2553   141F FD 43         mov [d], b
2554   1421             ; while (str[length] != 0) { 
2555   1421             _while81_cond:
2556   1421 FA 05 00      lea d, [bp + 5] ; $str
2557   1424 FD 2A         mov d, [d]
2558   1426 D7            push a
2559   1427 DA            push d
2560   1428 FA FF FF      lea d, [bp + -1] ; $length
2561   142B 2A            mov b, [d]
2562   142C 38 00 00      mov c, 0
2563   142F E7            pop d
2564   1430 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2565   1434 E4            pop a
2566   1435 32            mov bl, [d]
2567   1436 A7 00         mov bh, 0
2568   1438 38 00 00      mov c, 0
2569   143B             ; --- START RELATIONAL
2570   143B D7            push a
2571   143C 11            mov a, b
2572   143D FD 2E 00 00   mov32 cb, $00000000
2572   1441 00 00 
2573   1443 B0            cmp a, b
2574   1444 FD 72         sneq ; !=
2575   1446 E4            pop a
2576   1447             ; --- END RELATIONAL
2577   1447 C0 00 00      cmp b, 0
2578   144A C6 60 14      je _while81_exit
2579   144D             _while81_block:
2580   144D             ; length++; 
2581   144D FA FF FF      lea d, [bp + -1] ; $length
2582   1450 2A            mov b, [d]
2583   1451 38 00 00      mov c, 0
2584   1454 11            mov a, b
2585   1455 FD 77         inc b
2586   1457 FA FF FF      lea d, [bp + -1] ; $length
2587   145A FD 43         mov [d], b
2588   145C 27            mov b, a
2589   145D 0A 21 14      jmp _while81_cond
2590   1460             _while81_exit:
2591   1460             ; return length; 
2592   1460 FA FF FF      lea d, [bp + -1] ; $length
2593   1463 2A            mov b, [d]
2594   1464 38 00 00      mov c, 0
2595   1467 F9            leave
2596   1468 09            ret
2597   1469             ; --- END TEXT SEGMENT
2598   1469             
2599   1469             ; --- BEGIN DATA SEGMENT
2600   1469 50 75 62 6C _s0: .db "Public Key: %d, %d\n", 0
2600   146D 69 63 20 4B 
2600   1471 65 79 3A 20 
2600   1475 25 64 2C 20 
2600   1479 25 64 0A 00 
2601   147D 50 72 69 76 _s1: .db "Private Key: %d, %d\n", 0
2601   1481 61 74 65 20 
2601   1485 4B 65 79 3A 
2601   1489 20 25 64 2C 
2601   148D 20 25 64 0A 
2601   1491 00 
2602   1492 45 6E 74 65 _s2: .db "Enter a string: ", 0
2602   1496 72 20 61 20 
2602   149A 73 74 72 69 
2602   149E 6E 67 3A 20 
2602   14A2 00 
2603   14A3 0A 45 6E 63 _s3: .db "\nEncrypted text: ", 0
2603   14A7 72 79 70 74 
2603   14AB 65 64 20 74 
2603   14AF 65 78 74 3A 
2603   14B3 20 00 
2604   14B5 25 64 20 00 _s4: .db "%d ", 0
2605   14B9 0A 44 65 63 _s5: .db "\nDecrypted text: ", 0
2605   14BD 72 79 70 74 
2605   14C1 65 64 20 74 
2605   14C5 65 78 74 3A 
2605   14C9 20 00 
2606   14CB 0A 00       _s6: .db "\n", 0
2607   14CD 55 6E 65 78 _s7: .db "Unexpected format in printf.", 0
2607   14D1 70 65 63 74 
2607   14D5 65 64 20 66 
2607   14D9 6F 72 6D 61 
2607   14DD 74 20 69 6E 
2607   14E1 20 70 72 69 
2607   14E5 6E 74 66 2E 
2607   14E9 00 
2608   14EA 45 72 72 6F _s8: .db "Error: Unknown argument type.\n", 0
2608   14EE 72 3A 20 55 
2608   14F2 6E 6B 6E 6F 
2608   14F6 77 6E 20 61 
2608   14FA 72 67 75 6D 
2608   14FE 65 6E 74 20 
2608   1502 74 79 70 65 
2608   1506 2E 0A 00 
2609   1509             
2610   1509 0B 15       _heap_top: .dw _heap
2611   150B 00          _heap: .db 0
2612   150C             ; --- END DATA SEGMENT
2613   150C             
2614   150C             .end
tasm: Number of errors = 0
