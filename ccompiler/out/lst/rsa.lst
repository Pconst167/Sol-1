0001   0000             ; --- FILENAME: programs/rsa
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $p 
0011   0408             ; $q 
0012   0408             ; $n 
0013   0408             ; $phi 
0014   0408             ; $e 
0015   0408             ; $d 
0016   0408             ; $input_str 
0017   0408             ; $encrypted_chars 
0018   0408             ; $encrypted_chars_len 
0019   0408             ; $i 
0020   0408             ; $decrypted_char 
0021   0408             ; $c 
0022   0408 52 3F 01      sub sp, 319
0023   040B             ;; p = 13; 
0024   040B FA FF FF      lea d, [bp + -1] ; $p
0025   040E DA            push d
0026   040F 26 0D 00      mov b, $d
0027   0412 E7            pop d
0028   0413 FD 43         mov [d], b
0029   0415             ;; q = 11; 
0030   0415 FA FD FF      lea d, [bp + -3] ; $q
0031   0418 DA            push d
0032   0419 26 0B 00      mov b, $b
0033   041C E7            pop d
0034   041D FD 43         mov [d], b
0035   041F             ;; n = p * q; 
0036   041F FA FB FF      lea d, [bp + -5] ; $n
0037   0422 DA            push d
0038   0423 FA FF FF      lea d, [bp + -1] ; $p
0039   0426 2A            mov b, [d]
0040   0427             ; START FACTORS
0041   0427 D7            push a
0042   0428 11            mov a, b
0043   0429 FA FD FF      lea d, [bp + -3] ; $q
0044   042C 2A            mov b, [d]
0045   042D AC            mul a, b ; *
0046   042E 11            mov a, b
0047   042F 27            mov b, a
0048   0430 E4            pop a
0049   0431             ; END FACTORS
0050   0431 E7            pop d
0051   0432 FD 43         mov [d], b
0052   0434             ;; phi = (p - 1) * (q - 1); 
0053   0434 FA F9 FF      lea d, [bp + -7] ; $phi
0054   0437 DA            push d
0055   0438 FA FF FF      lea d, [bp + -1] ; $p
0056   043B 2A            mov b, [d]
0057   043C             ; START TERMS
0058   043C D7            push a
0059   043D 11            mov a, b
0060   043E 26 01 00      mov b, $1
0061   0441 60            sub a, b
0062   0442 27            mov b, a
0063   0443 E4            pop a
0064   0444             ; END TERMS
0065   0444             ; START FACTORS
0066   0444 D7            push a
0067   0445 11            mov a, b
0068   0446 FA FD FF      lea d, [bp + -3] ; $q
0069   0449 2A            mov b, [d]
0070   044A             ; START TERMS
0071   044A D7            push a
0072   044B 11            mov a, b
0073   044C 26 01 00      mov b, $1
0074   044F 60            sub a, b
0075   0450 27            mov b, a
0076   0451 E4            pop a
0077   0452             ; END TERMS
0078   0452 AC            mul a, b ; *
0079   0453 11            mov a, b
0080   0454 27            mov b, a
0081   0455 E4            pop a
0082   0456             ; END FACTORS
0083   0456 E7            pop d
0084   0457 FD 43         mov [d], b
0085   0459             ;; e = find_e(phi); 
0086   0459 FA F7 FF      lea d, [bp + -9] ; $e
0087   045C DA            push d
0088   045D FA F9 FF      lea d, [bp + -7] ; $phi
0089   0460 2A            mov b, [d]
0090   0461 FD AB         swp b
0091   0463 D8            push b
0092   0464 07 48 14      call find_e
0093   0467 51 02 00      add sp, 2
0094   046A E7            pop d
0095   046B FD 43         mov [d], b
0096   046D             ;; d = find_d(e, phi); 
0097   046D FA F5 FF      lea d, [bp + -11] ; $d
0098   0470 DA            push d
0099   0471 FA F9 FF      lea d, [bp + -7] ; $phi
0100   0474 2A            mov b, [d]
0101   0475 FD AB         swp b
0102   0477 D8            push b
0103   0478 FA F7 FF      lea d, [bp + -9] ; $e
0104   047B 2A            mov b, [d]
0105   047C FD AB         swp b
0106   047E D8            push b
0107   047F 07 AF 14      call find_d
0108   0482 51 04 00      add sp, 4
0109   0485 E7            pop d
0110   0486 FD 43         mov [d], b
0111   0488             ;; print("Public Key: ("); 
0112   0488 26 1A 15      mov b, __s0 ; "Public Key: ("
0113   048B FD AB         swp b
0114   048D D8            push b
0115   048E 07 9E 0E      call print
0116   0491 51 02 00      add sp, 2
0117   0494             ;; printu(n); 
0118   0494 FA FB FF      lea d, [bp + -5] ; $n
0119   0497 2A            mov b, [d]
0120   0498 FD AB         swp b
0121   049A D8            push b
0122   049B 07 6A 0D      call printu
0123   049E 51 02 00      add sp, 2
0124   04A1             ;; print(", "); 
0125   04A1 26 28 15      mov b, __s1 ; ", "
0126   04A4 FD AB         swp b
0127   04A6 D8            push b
0128   04A7 07 9E 0E      call print
0129   04AA 51 02 00      add sp, 2
0130   04AD             ;; printu(e); 
0131   04AD FA F7 FF      lea d, [bp + -9] ; $e
0132   04B0 2A            mov b, [d]
0133   04B1 FD AB         swp b
0134   04B3 D8            push b
0135   04B4 07 6A 0D      call printu
0136   04B7 51 02 00      add sp, 2
0137   04BA             ;; print(")\n"); 
0138   04BA 26 2B 15      mov b, __s2 ; ")\n"
0139   04BD FD AB         swp b
0140   04BF D8            push b
0141   04C0 07 9E 0E      call print
0142   04C3 51 02 00      add sp, 2
0143   04C6             ;; print("Private Key: ("); 
0144   04C6 26 2E 15      mov b, __s3 ; "Private Key: ("
0145   04C9 FD AB         swp b
0146   04CB D8            push b
0147   04CC 07 9E 0E      call print
0148   04CF 51 02 00      add sp, 2
0149   04D2             ;; printu(n); 
0150   04D2 FA FB FF      lea d, [bp + -5] ; $n
0151   04D5 2A            mov b, [d]
0152   04D6 FD AB         swp b
0153   04D8 D8            push b
0154   04D9 07 6A 0D      call printu
0155   04DC 51 02 00      add sp, 2
0156   04DF             ;; print(", "); 
0157   04DF 26 28 15      mov b, __s1 ; ", "
0158   04E2 FD AB         swp b
0159   04E4 D8            push b
0160   04E5 07 9E 0E      call print
0161   04E8 51 02 00      add sp, 2
0162   04EB             ;; printu(d); 
0163   04EB FA F5 FF      lea d, [bp + -11] ; $d
0164   04EE 2A            mov b, [d]
0165   04EF FD AB         swp b
0166   04F1 D8            push b
0167   04F2 07 6A 0D      call printu
0168   04F5 51 02 00      add sp, 2
0169   04F8             ;; print(")\n"); 
0170   04F8 26 2B 15      mov b, __s2 ; ")\n"
0171   04FB FD AB         swp b
0172   04FD D8            push b
0173   04FE 07 9E 0E      call print
0174   0501 51 02 00      add sp, 2
0175   0504             ;; print("Enter a string: "); 
0176   0504 26 3D 15      mov b, __s4 ; "Enter a string: "
0177   0507 FD AB         swp b
0178   0509 D8            push b
0179   050A 07 9E 0E      call print
0180   050D 51 02 00      add sp, 2
0181   0510             ;; gets(input_str); 
0182   0510 FA 91 FF      lea d, [bp + -111] ; $input_str
0183   0513 2D            mov b, d
0184   0514 FD AB         swp b
0185   0516 D8            push b
0186   0517 07 5B 0C      call gets
0187   051A 51 02 00      add sp, 2
0188   051D             ;; encrypted_chars_len = 0; 
0189   051D FA C7 FE      lea d, [bp + -313] ; $encrypted_chars_len
0190   0520 DA            push d
0191   0521 26 00 00      mov b, $0
0192   0524 E7            pop d
0193   0525 FD 43         mov [d], b
0194   0527             ;; print("Encrypted text: "); 
0195   0527 26 4E 15      mov b, __s5 ; "Encrypted text: "
0196   052A FD AB         swp b
0197   052C D8            push b
0198   052D 07 9E 0E      call print
0199   0530 51 02 00      add sp, 2
0200   0533             ;; for (i = 0; input_str[i] != '\0' && input_str[i] != '\n'; i++) { 
0201   0533             _for1_init:
0202   0533 FA C5 FE      lea d, [bp + -315] ; $i
0203   0536 DA            push d
0204   0537 26 00 00      mov b, $0
0205   053A E7            pop d
0206   053B FD 43         mov [d], b
0207   053D             _for1_cond:
0208   053D FA 91 FF      lea d, [bp + -111] ; $input_str
0209   0540 D7            push a
0210   0541 DA            push d
0211   0542 FA C5 FE      lea d, [bp + -315] ; $i
0212   0545 2A            mov b, [d]
0213   0546 E7            pop d
0214   0547 5A            add d, b
0215   0548 E4            pop a
0216   0549 32            mov bl, [d]
0217   054A A7 00         mov bh, 0
0218   054C             ; START RELATIONAL
0219   054C D7            push a
0220   054D 11            mov a, b
0221   054E 26 00 00      mov b, $0
0222   0551 B0            cmp a, b
0223   0552 FD 72         sneq ; !=
0224   0554 E4            pop a
0225   0555             ; END RELATIONAL
0226   0555 D7            push a
0227   0556 11            mov a, b
0228   0557 FA 91 FF      lea d, [bp + -111] ; $input_str
0229   055A D7            push a
0230   055B DA            push d
0231   055C FA C5 FE      lea d, [bp + -315] ; $i
0232   055F 2A            mov b, [d]
0233   0560 E7            pop d
0234   0561 5A            add d, b
0235   0562 E4            pop a
0236   0563 32            mov bl, [d]
0237   0564 A7 00         mov bh, 0
0238   0566             ; START RELATIONAL
0239   0566 D7            push a
0240   0567 11            mov a, b
0241   0568 26 0A 00      mov b, $a
0242   056B B0            cmp a, b
0243   056C FD 72         sneq ; !=
0244   056E E4            pop a
0245   056F             ; END RELATIONAL
0246   056F FD A7         sand a, b ; &&
0247   0571 E4            pop a
0248   0572 C0 00 00      cmp b, 0
0249   0575 C6 F7 05      je _for1_exit
0250   0578             _for1_block:
0251   0578             ;; encrypted_chars[i] = mod_exp(input_str[i], e, n); 
0252   0578 FA C9 FE      lea d, [bp + -311] ; $encrypted_chars
0253   057B D7            push a
0254   057C DA            push d
0255   057D FA C5 FE      lea d, [bp + -315] ; $i
0256   0580 2A            mov b, [d]
0257   0581 E7            pop d
0258   0582 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0259   0586 E4            pop a
0260   0587 DA            push d
0261   0588 FA FB FF      lea d, [bp + -5] ; $n
0262   058B 2A            mov b, [d]
0263   058C FD AB         swp b
0264   058E D8            push b
0265   058F FA F7 FF      lea d, [bp + -9] ; $e
0266   0592 2A            mov b, [d]
0267   0593 FD AB         swp b
0268   0595 D8            push b
0269   0596 FA 91 FF      lea d, [bp + -111] ; $input_str
0270   0599 D7            push a
0271   059A DA            push d
0272   059B FA C5 FE      lea d, [bp + -315] ; $i
0273   059E 2A            mov b, [d]
0274   059F E7            pop d
0275   05A0 5A            add d, b
0276   05A1 E4            pop a
0277   05A2 32            mov bl, [d]
0278   05A3 A7 00         mov bh, 0
0279   05A5 FD AB         swp b
0280   05A7 D8            push b
0281   05A8 07 B4 13      call mod_exp
0282   05AB 51 06 00      add sp, 6
0283   05AE E7            pop d
0284   05AF FD 43         mov [d], b
0285   05B1             ;; printu(encrypted_chars[i]); 
0286   05B1 FA C9 FE      lea d, [bp + -311] ; $encrypted_chars
0287   05B4 D7            push a
0288   05B5 DA            push d
0289   05B6 FA C5 FE      lea d, [bp + -315] ; $i
0290   05B9 2A            mov b, [d]
0291   05BA E7            pop d
0292   05BB FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0293   05BF E4            pop a
0294   05C0 2A            mov b, [d]
0295   05C1 FD AB         swp b
0296   05C3 D8            push b
0297   05C4 07 6A 0D      call printu
0298   05C7 51 02 00      add sp, 2
0299   05CA             ;; print(" "); 
0300   05CA 26 5F 15      mov b, __s6 ; " "
0301   05CD FD AB         swp b
0302   05CF D8            push b
0303   05D0 07 9E 0E      call print
0304   05D3 51 02 00      add sp, 2
0305   05D6             ;; encrypted_chars_len++; 
0306   05D6 FA C7 FE      lea d, [bp + -313] ; $encrypted_chars_len
0307   05D9 2A            mov b, [d]
0308   05DA FD 79         mov g, b
0309   05DC FD 77         inc b
0310   05DE FA C7 FE      lea d, [bp + -313] ; $encrypted_chars_len
0311   05E1 FD 43         mov [d], b
0312   05E3 FD 27         mov b, g
0313   05E5             _for1_update:
0314   05E5 FA C5 FE      lea d, [bp + -315] ; $i
0315   05E8 2A            mov b, [d]
0316   05E9 FD 79         mov g, b
0317   05EB FD 77         inc b
0318   05ED FA C5 FE      lea d, [bp + -315] ; $i
0319   05F0 FD 43         mov [d], b
0320   05F2 FD 27         mov b, g
0321   05F4 0A 3D 05      jmp _for1_cond
0322   05F7             _for1_exit:
0323   05F7             ;; print("\n"); 
0324   05F7 26 61 15      mov b, __s7 ; "\n"
0325   05FA FD AB         swp b
0326   05FC D8            push b
0327   05FD 07 9E 0E      call print
0328   0600 51 02 00      add sp, 2
0329   0603             ;; print("Decrypted text: "); 
0330   0603 26 63 15      mov b, __s8 ; "Decrypted text: "
0331   0606 FD AB         swp b
0332   0608 D8            push b
0333   0609 07 9E 0E      call print
0334   060C 51 02 00      add sp, 2
0335   060F             ;; for (i = 0; i < encrypted_chars_len; i++) { 
0336   060F             _for2_init:
0337   060F FA C5 FE      lea d, [bp + -315] ; $i
0338   0612 DA            push d
0339   0613 26 00 00      mov b, $0
0340   0616 E7            pop d
0341   0617 FD 43         mov [d], b
0342   0619             _for2_cond:
0343   0619 FA C5 FE      lea d, [bp + -315] ; $i
0344   061C 2A            mov b, [d]
0345   061D             ; START RELATIONAL
0346   061D D7            push a
0347   061E 11            mov a, b
0348   061F FA C7 FE      lea d, [bp + -313] ; $encrypted_chars_len
0349   0622 2A            mov b, [d]
0350   0623 B0            cmp a, b
0351   0624 FD 73         slt ; < 
0352   0626 E4            pop a
0353   0627             ; END RELATIONAL
0354   0627 C0 00 00      cmp b, 0
0355   062A C6 85 06      je _for2_exit
0356   062D             _for2_block:
0357   062D             ;; decrypted_char = mod_exp(encrypted_chars[i], d, n); 
0358   062D FA C3 FE      lea d, [bp + -317] ; $decrypted_char
0359   0630 DA            push d
0360   0631 FA FB FF      lea d, [bp + -5] ; $n
0361   0634 2A            mov b, [d]
0362   0635 FD AB         swp b
0363   0637 D8            push b
0364   0638 FA F5 FF      lea d, [bp + -11] ; $d
0365   063B 2A            mov b, [d]
0366   063C FD AB         swp b
0367   063E D8            push b
0368   063F FA C9 FE      lea d, [bp + -311] ; $encrypted_chars
0369   0642 D7            push a
0370   0643 DA            push d
0371   0644 FA C5 FE      lea d, [bp + -315] ; $i
0372   0647 2A            mov b, [d]
0373   0648 E7            pop d
0374   0649 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0375   064D E4            pop a
0376   064E 2A            mov b, [d]
0377   064F FD AB         swp b
0378   0651 D8            push b
0379   0652 07 B4 13      call mod_exp
0380   0655 51 06 00      add sp, 6
0381   0658 E7            pop d
0382   0659 FD 43         mov [d], b
0383   065B             ;; c = decrypted_char; 
0384   065B FA C2 FE      lea d, [bp + -318] ; $c
0385   065E DA            push d
0386   065F FA C3 FE      lea d, [bp + -317] ; $decrypted_char
0387   0662 2A            mov b, [d]
0388   0663 E7            pop d
0389   0664 FD 3E         mov [d], bl
0390   0666             ;; putchar(c); 
0391   0666 FA C2 FE      lea d, [bp + -318] ; $c
0392   0669 32            mov bl, [d]
0393   066A A7 00         mov bh, 0
0394   066C DD            push bl
0395   066D 07 56 0E      call putchar
0396   0670 51 01 00      add sp, 1
0397   0673             _for2_update:
0398   0673 FA C5 FE      lea d, [bp + -315] ; $i
0399   0676 2A            mov b, [d]
0400   0677 FD 79         mov g, b
0401   0679 FD 77         inc b
0402   067B FA C5 FE      lea d, [bp + -315] ; $i
0403   067E FD 43         mov [d], b
0404   0680 FD 27         mov b, g
0405   0682 0A 19 06      jmp _for2_cond
0406   0685             _for2_exit:
0407   0685             ;; print("\n"); 
0408   0685 26 61 15      mov b, __s7 ; "\n"
0409   0688 FD AB         swp b
0410   068A D8            push b
0411   068B 07 9E 0E      call print
0412   068E 51 02 00      add sp, 2
0413   0691             ;; return 0; 
0414   0691 26 00 00      mov b, $0
0415   0694 F9            leave
0416   0695 05 0B         syscall sys_terminate_proc
0417   0697             
0418   0697             strcpy:
0419   0697 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0420   069A             ; $psrc 
0421   069A             ; $pdest 
0422   069A 52 04 00      sub sp, 4
0423   069D             ;; psrc = src; 
0424   069D FA FF FF      lea d, [bp + -1] ; $psrc
0425   06A0 DA            push d
0426   06A1 FA 07 00      lea d, [bp + 7] ; $src
0427   06A4 2A            mov b, [d]
0428   06A5 E7            pop d
0429   06A6 FD 43         mov [d], b
0430   06A8             ;; pdest = dest; 
0431   06A8 FA FD FF      lea d, [bp + -3] ; $pdest
0432   06AB DA            push d
0433   06AC FA 05 00      lea d, [bp + 5] ; $dest
0434   06AF 2A            mov b, [d]
0435   06B0 E7            pop d
0436   06B1 FD 43         mov [d], b
0437   06B3             ;; while(*psrc) *pdest++ = *psrc++; 
0438   06B3             _while3_cond:
0439   06B3 FA FF FF      lea d, [bp + -1] ; $psrc
0440   06B6 2A            mov b, [d]
0441   06B7 74            mov d, b
0442   06B8 32            mov bl, [d]
0443   06B9 A7 00         mov bh, 0
0444   06BB C0 00 00      cmp b, 0
0445   06BE C6 EA 06      je _while3_exit
0446   06C1             _while3_block:
0447   06C1             ;; *pdest++ = *psrc++; 
0448   06C1 FA FD FF      lea d, [bp + -3] ; $pdest
0449   06C4 2A            mov b, [d]
0450   06C5 FD 79         mov g, b
0451   06C7 FD 77         inc b
0452   06C9 FA FD FF      lea d, [bp + -3] ; $pdest
0453   06CC FD 43         mov [d], b
0454   06CE FD 27         mov b, g
0455   06D0 D8            push b
0456   06D1 FA FF FF      lea d, [bp + -1] ; $psrc
0457   06D4 2A            mov b, [d]
0458   06D5 FD 79         mov g, b
0459   06D7 FD 77         inc b
0460   06D9 FA FF FF      lea d, [bp + -1] ; $psrc
0461   06DC FD 43         mov [d], b
0462   06DE FD 27         mov b, g
0463   06E0 74            mov d, b
0464   06E1 32            mov bl, [d]
0465   06E2 A7 00         mov bh, 0
0466   06E4 E7            pop d
0467   06E5 FD 3E         mov [d], bl
0468   06E7 0A B3 06      jmp _while3_cond
0469   06EA             _while3_exit:
0470   06EA             ;; *pdest = '\0'; 
0471   06EA FA FD FF      lea d, [bp + -3] ; $pdest
0472   06ED 2A            mov b, [d]
0473   06EE D8            push b
0474   06EF 26 00 00      mov b, $0
0475   06F2 E7            pop d
0476   06F3 FD 3E         mov [d], bl
0477   06F5 F9            leave
0478   06F6 09            ret
0479   06F7             
0480   06F7             strcmp:
0481   06F7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0482   06FA             ;; while (*s1 && (*s1 == *s2)) { 
0483   06FA             _while4_cond:
0484   06FA FA 05 00      lea d, [bp + 5] ; $s1
0485   06FD 2A            mov b, [d]
0486   06FE 74            mov d, b
0487   06FF 32            mov bl, [d]
0488   0700 A7 00         mov bh, 0
0489   0702 D7            push a
0490   0703 11            mov a, b
0491   0704 FA 05 00      lea d, [bp + 5] ; $s1
0492   0707 2A            mov b, [d]
0493   0708 74            mov d, b
0494   0709 32            mov bl, [d]
0495   070A A7 00         mov bh, 0
0496   070C             ; START RELATIONAL
0497   070C D7            push a
0498   070D 11            mov a, b
0499   070E FA 07 00      lea d, [bp + 7] ; $s2
0500   0711 2A            mov b, [d]
0501   0712 74            mov d, b
0502   0713 32            mov bl, [d]
0503   0714 A7 00         mov bh, 0
0504   0716 B0            cmp a, b
0505   0717 FD 71         seq ; ==
0506   0719 E4            pop a
0507   071A             ; END RELATIONAL
0508   071A FD A7         sand a, b ; &&
0509   071C E4            pop a
0510   071D C0 00 00      cmp b, 0
0511   0720 C6 44 07      je _while4_exit
0512   0723             _while4_block:
0513   0723             ;; s1++; 
0514   0723 FA 05 00      lea d, [bp + 5] ; $s1
0515   0726 2A            mov b, [d]
0516   0727 FD 79         mov g, b
0517   0729 FD 77         inc b
0518   072B FA 05 00      lea d, [bp + 5] ; $s1
0519   072E FD 43         mov [d], b
0520   0730 FD 27         mov b, g
0521   0732             ;; s2++; 
0522   0732 FA 07 00      lea d, [bp + 7] ; $s2
0523   0735 2A            mov b, [d]
0524   0736 FD 79         mov g, b
0525   0738 FD 77         inc b
0526   073A FA 07 00      lea d, [bp + 7] ; $s2
0527   073D FD 43         mov [d], b
0528   073F FD 27         mov b, g
0529   0741 0A FA 06      jmp _while4_cond
0530   0744             _while4_exit:
0531   0744             ;; return *s1 - *s2; 
0532   0744 FA 05 00      lea d, [bp + 5] ; $s1
0533   0747 2A            mov b, [d]
0534   0748 74            mov d, b
0535   0749 32            mov bl, [d]
0536   074A A7 00         mov bh, 0
0537   074C             ; START TERMS
0538   074C D7            push a
0539   074D 11            mov a, b
0540   074E FA 07 00      lea d, [bp + 7] ; $s2
0541   0751 2A            mov b, [d]
0542   0752 74            mov d, b
0543   0753 32            mov bl, [d]
0544   0754 A7 00         mov bh, 0
0545   0756 60            sub a, b
0546   0757 27            mov b, a
0547   0758 E4            pop a
0548   0759             ; END TERMS
0549   0759 F9            leave
0550   075A 09            ret
0551   075B             
0552   075B             strcat:
0553   075B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0554   075E             ; $dest_len 
0555   075E             ; $i 
0556   075E 52 04 00      sub sp, 4
0557   0761             ;; dest_len = strlen(dest); 
0558   0761 FA FF FF      lea d, [bp + -1] ; $dest_len
0559   0764 DA            push d
0560   0765 FA 05 00      lea d, [bp + 5] ; $dest
0561   0768 2A            mov b, [d]
0562   0769 FD AB         swp b
0563   076B D8            push b
0564   076C 07 11 08      call strlen
0565   076F 51 02 00      add sp, 2
0566   0772 E7            pop d
0567   0773 FD 43         mov [d], b
0568   0775             ;; for (i = 0; src[i] != 0; i=i+1) { 
0569   0775             _for5_init:
0570   0775 FA FD FF      lea d, [bp + -3] ; $i
0571   0778 DA            push d
0572   0779 26 00 00      mov b, $0
0573   077C E7            pop d
0574   077D FD 43         mov [d], b
0575   077F             _for5_cond:
0576   077F FA 07 00      lea d, [bp + 7] ; $src
0577   0782 FD 2A         mov d, [d]
0578   0784 D7            push a
0579   0785 DA            push d
0580   0786 FA FD FF      lea d, [bp + -3] ; $i
0581   0789 2A            mov b, [d]
0582   078A E7            pop d
0583   078B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0584   078F E4            pop a
0585   0790 32            mov bl, [d]
0586   0791 A7 00         mov bh, 0
0587   0793             ; START RELATIONAL
0588   0793 D7            push a
0589   0794 11            mov a, b
0590   0795 26 00 00      mov b, $0
0591   0798 B0            cmp a, b
0592   0799 FD 72         sneq ; !=
0593   079B E4            pop a
0594   079C             ; END RELATIONAL
0595   079C C0 00 00      cmp b, 0
0596   079F C6 EA 07      je _for5_exit
0597   07A2             _for5_block:
0598   07A2             ;; dest[dest_len + i] = src[i]; 
0599   07A2 FA 05 00      lea d, [bp + 5] ; $dest
0600   07A5 FD 2A         mov d, [d]
0601   07A7 D7            push a
0602   07A8 DA            push d
0603   07A9 FA FF FF      lea d, [bp + -1] ; $dest_len
0604   07AC 2A            mov b, [d]
0605   07AD             ; START TERMS
0606   07AD D7            push a
0607   07AE 11            mov a, b
0608   07AF FA FD FF      lea d, [bp + -3] ; $i
0609   07B2 2A            mov b, [d]
0610   07B3 54            add a, b
0611   07B4 27            mov b, a
0612   07B5 E4            pop a
0613   07B6             ; END TERMS
0614   07B6 E7            pop d
0615   07B7 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0616   07BB E4            pop a
0617   07BC DA            push d
0618   07BD FA 07 00      lea d, [bp + 7] ; $src
0619   07C0 FD 2A         mov d, [d]
0620   07C2 D7            push a
0621   07C3 DA            push d
0622   07C4 FA FD FF      lea d, [bp + -3] ; $i
0623   07C7 2A            mov b, [d]
0624   07C8 E7            pop d
0625   07C9 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0626   07CD E4            pop a
0627   07CE 32            mov bl, [d]
0628   07CF A7 00         mov bh, 0
0629   07D1 E7            pop d
0630   07D2 FD 3E         mov [d], bl
0631   07D4             _for5_update:
0632   07D4 FA FD FF      lea d, [bp + -3] ; $i
0633   07D7 DA            push d
0634   07D8 FA FD FF      lea d, [bp + -3] ; $i
0635   07DB 2A            mov b, [d]
0636   07DC             ; START TERMS
0637   07DC D7            push a
0638   07DD 11            mov a, b
0639   07DE 26 01 00      mov b, $1
0640   07E1 54            add a, b
0641   07E2 27            mov b, a
0642   07E3 E4            pop a
0643   07E4             ; END TERMS
0644   07E4 E7            pop d
0645   07E5 FD 43         mov [d], b
0646   07E7 0A 7F 07      jmp _for5_cond
0647   07EA             _for5_exit:
0648   07EA             ;; dest[dest_len + i] = 0; 
0649   07EA FA 05 00      lea d, [bp + 5] ; $dest
0650   07ED FD 2A         mov d, [d]
0651   07EF D7            push a
0652   07F0 DA            push d
0653   07F1 FA FF FF      lea d, [bp + -1] ; $dest_len
0654   07F4 2A            mov b, [d]
0655   07F5             ; START TERMS
0656   07F5 D7            push a
0657   07F6 11            mov a, b
0658   07F7 FA FD FF      lea d, [bp + -3] ; $i
0659   07FA 2A            mov b, [d]
0660   07FB 54            add a, b
0661   07FC 27            mov b, a
0662   07FD E4            pop a
0663   07FE             ; END TERMS
0664   07FE E7            pop d
0665   07FF FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0666   0803 E4            pop a
0667   0804 DA            push d
0668   0805 26 00 00      mov b, $0
0669   0808 E7            pop d
0670   0809 FD 3E         mov [d], bl
0671   080B             ;; return dest; 
0672   080B FA 05 00      lea d, [bp + 5] ; $dest
0673   080E 2A            mov b, [d]
0674   080F F9            leave
0675   0810 09            ret
0676   0811             
0677   0811             strlen:
0678   0811 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0679   0814             ; $length 
0680   0814 52 02 00      sub sp, 2
0681   0817             ;; length = 0; 
0682   0817 FA FF FF      lea d, [bp + -1] ; $length
0683   081A DA            push d
0684   081B 26 00 00      mov b, $0
0685   081E E7            pop d
0686   081F FD 43         mov [d], b
0687   0821             ;; while (str[length] != 0) { 
0688   0821             _while6_cond:
0689   0821 FA 05 00      lea d, [bp + 5] ; $str
0690   0824 FD 2A         mov d, [d]
0691   0826 D7            push a
0692   0827 DA            push d
0693   0828 FA FF FF      lea d, [bp + -1] ; $length
0694   082B 2A            mov b, [d]
0695   082C E7            pop d
0696   082D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0697   0831 E4            pop a
0698   0832 32            mov bl, [d]
0699   0833 A7 00         mov bh, 0
0700   0835             ; START RELATIONAL
0701   0835 D7            push a
0702   0836 11            mov a, b
0703   0837 26 00 00      mov b, $0
0704   083A B0            cmp a, b
0705   083B FD 72         sneq ; !=
0706   083D E4            pop a
0707   083E             ; END RELATIONAL
0708   083E C0 00 00      cmp b, 0
0709   0841 C6 56 08      je _while6_exit
0710   0844             _while6_block:
0711   0844             ;; length++; 
0712   0844 FA FF FF      lea d, [bp + -1] ; $length
0713   0847 2A            mov b, [d]
0714   0848 FD 79         mov g, b
0715   084A FD 77         inc b
0716   084C FA FF FF      lea d, [bp + -1] ; $length
0717   084F FD 43         mov [d], b
0718   0851 FD 27         mov b, g
0719   0853 0A 21 08      jmp _while6_cond
0720   0856             _while6_exit:
0721   0856             ;; return length; 
0722   0856 FA FF FF      lea d, [bp + -1] ; $length
0723   0859 2A            mov b, [d]
0724   085A F9            leave
0725   085B 09            ret
0726   085C             
0727   085C             printf:
0728   085C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0729   085F             ; $p 
0730   085F             ; $fp 
0731   085F             ; $i 
0732   085F 52 06 00      sub sp, 6
0733   0862             ;; fp = format; 
0734   0862 FA FD FF      lea d, [bp + -3] ; $fp
0735   0865 DA            push d
0736   0866 FA 05 00      lea d, [bp + 5] ; $format
0737   0869 2A            mov b, [d]
0738   086A E7            pop d
0739   086B FD 43         mov [d], b
0740   086D             ;; p = &format + 2; 
0741   086D FA FF FF      lea d, [bp + -1] ; $p
0742   0870 DA            push d
0743   0871 FA 05 00      lea d, [bp + 5] ; $format
0744   0874 2D            mov b, d
0745   0875             ; START TERMS
0746   0875 D7            push a
0747   0876 11            mov a, b
0748   0877 26 02 00      mov b, $2
0749   087A 54            add a, b
0750   087B 27            mov b, a
0751   087C E4            pop a
0752   087D             ; END TERMS
0753   087D E7            pop d
0754   087E FD 43         mov [d], b
0755   0880             ;; for(;;){ 
0756   0880             _for7_init:
0757   0880             _for7_cond:
0758   0880             _for7_block:
0759   0880             ;; if(!*fp) break; 
0760   0880             _if8_cond:
0761   0880 FA FD FF      lea d, [bp + -3] ; $fp
0762   0883 2A            mov b, [d]
0763   0884 74            mov d, b
0764   0885 32            mov bl, [d]
0765   0886 A7 00         mov bh, 0
0766   0888 C0 00 00      cmp b, 0
0767   088B FD 71         seq ; !
0768   088D C0 00 00      cmp b, 0
0769   0890 C6 99 08      je _if8_else
0770   0893             _if8_true:
0771   0893             ;; break; 
0772   0893 0A E3 09      jmp _for7_exit ; for break
0773   0896 0A E0 09      jmp _if8_exit
0774   0899             _if8_else:
0775   0899             ;; if(*fp == '%'){ 
0776   0899             _if9_cond:
0777   0899 FA FD FF      lea d, [bp + -3] ; $fp
0778   089C 2A            mov b, [d]
0779   089D 74            mov d, b
0780   089E 32            mov bl, [d]
0781   089F A7 00         mov bh, 0
0782   08A1             ; START RELATIONAL
0783   08A1 D7            push a
0784   08A2 11            mov a, b
0785   08A3 26 25 00      mov b, $25
0786   08A6 B0            cmp a, b
0787   08A7 FD 71         seq ; ==
0788   08A9 E4            pop a
0789   08AA             ; END RELATIONAL
0790   08AA C0 00 00      cmp b, 0
0791   08AD C6 C2 09      je _if9_else
0792   08B0             _if9_true:
0793   08B0             ;; fp++; 
0794   08B0 FA FD FF      lea d, [bp + -3] ; $fp
0795   08B3 2A            mov b, [d]
0796   08B4 FD 79         mov g, b
0797   08B6 FD 77         inc b
0798   08B8 FA FD FF      lea d, [bp + -3] ; $fp
0799   08BB FD 43         mov [d], b
0800   08BD FD 27         mov b, g
0801   08BF             ;; switch(*fp){ 
0802   08BF             _switch10_expr:
0803   08BF FA FD FF      lea d, [bp + -3] ; $fp
0804   08C2 2A            mov b, [d]
0805   08C3 74            mov d, b
0806   08C4 32            mov bl, [d]
0807   08C5 A7 00         mov bh, 0
0808   08C7             _switch10_comparisons:
0809   08C7 C1 64         cmp bl, $64
0810   08C9 C6 EB 08      je _switch10_case0
0811   08CC C1 69         cmp bl, $69
0812   08CE C6 EB 08      je _switch10_case1
0813   08D1 C1 75         cmp bl, $75
0814   08D3 C6 10 09      je _switch10_case2
0815   08D6 C1 78         cmp bl, $78
0816   08D8 C6 35 09      je _switch10_case3
0817   08DB C1 63         cmp bl, $63
0818   08DD C6 5A 09      je _switch10_case4
0819   08E0 C1 73         cmp bl, $73
0820   08E2 C6 7F 09      je _switch10_case5
0821   08E5 0A A4 09      jmp _switch10_default
0822   08E8 0A B0 09      jmp _switch10_exit
0823   08EB             _switch10_case0:
0824   08EB             _switch10_case1:
0825   08EB             ;; prints(*(int*)p); 
0826   08EB FA FF FF      lea d, [bp + -1] ; $p
0827   08EE 2A            mov b, [d]
0828   08EF 74            mov d, b
0829   08F0 2A            mov b, [d]
0830   08F1 FD AB         swp b
0831   08F3 D8            push b
0832   08F4 07 75 0C      call prints
0833   08F7 51 02 00      add sp, 2
0834   08FA             ;; p = p + 2; 
0835   08FA FA FF FF      lea d, [bp + -1] ; $p
0836   08FD DA            push d
0837   08FE FA FF FF      lea d, [bp + -1] ; $p
0838   0901 2A            mov b, [d]
0839   0902             ; START TERMS
0840   0902 D7            push a
0841   0903 11            mov a, b
0842   0904 26 02 00      mov b, $2
0843   0907 54            add a, b
0844   0908 27            mov b, a
0845   0909 E4            pop a
0846   090A             ; END TERMS
0847   090A E7            pop d
0848   090B FD 43         mov [d], b
0849   090D             ;; break; 
0850   090D 0A B0 09      jmp _switch10_exit ; case break
0851   0910             _switch10_case2:
0852   0910             ;; printu(*(unsigned int*)p); 
0853   0910 FA FF FF      lea d, [bp + -1] ; $p
0854   0913 2A            mov b, [d]
0855   0914 74            mov d, b
0856   0915 2A            mov b, [d]
0857   0916 FD AB         swp b
0858   0918 D8            push b
0859   0919 07 6A 0D      call printu
0860   091C 51 02 00      add sp, 2
0861   091F             ;; p = p + 2; 
0862   091F FA FF FF      lea d, [bp + -1] ; $p
0863   0922 DA            push d
0864   0923 FA FF FF      lea d, [bp + -1] ; $p
0865   0926 2A            mov b, [d]
0866   0927             ; START TERMS
0867   0927 D7            push a
0868   0928 11            mov a, b
0869   0929 26 02 00      mov b, $2
0870   092C 54            add a, b
0871   092D 27            mov b, a
0872   092E E4            pop a
0873   092F             ; END TERMS
0874   092F E7            pop d
0875   0930 FD 43         mov [d], b
0876   0932             ;; break; 
0877   0932 0A B0 09      jmp _switch10_exit ; case break
0878   0935             _switch10_case3:
0879   0935             ;; printx16(*(unsigned int*)p); 
0880   0935 FA FF FF      lea d, [bp + -1] ; $p
0881   0938 2A            mov b, [d]
0882   0939 74            mov d, b
0883   093A 2A            mov b, [d]
0884   093B FD AB         swp b
0885   093D D8            push b
0886   093E 07 E5 09      call printx16
0887   0941 51 02 00      add sp, 2
0888   0944             ;; p = p + 2; 
0889   0944 FA FF FF      lea d, [bp + -1] ; $p
0890   0947 DA            push d
0891   0948 FA FF FF      lea d, [bp + -1] ; $p
0892   094B 2A            mov b, [d]
0893   094C             ; START TERMS
0894   094C D7            push a
0895   094D 11            mov a, b
0896   094E 26 02 00      mov b, $2
0897   0951 54            add a, b
0898   0952 27            mov b, a
0899   0953 E4            pop a
0900   0954             ; END TERMS
0901   0954 E7            pop d
0902   0955 FD 43         mov [d], b
0903   0957             ;; break; 
0904   0957 0A B0 09      jmp _switch10_exit ; case break
0905   095A             _switch10_case4:
0906   095A             ;; putchar(*(char*)p); 
0907   095A FA FF FF      lea d, [bp + -1] ; $p
0908   095D 2A            mov b, [d]
0909   095E 74            mov d, b
0910   095F 32            mov bl, [d]
0911   0960 A7 00         mov bh, 0
0912   0962 DD            push bl
0913   0963 07 56 0E      call putchar
0914   0966 51 01 00      add sp, 1
0915   0969             ;; p = p + 2; 
0916   0969 FA FF FF      lea d, [bp + -1] ; $p
0917   096C DA            push d
0918   096D FA FF FF      lea d, [bp + -1] ; $p
0919   0970 2A            mov b, [d]
0920   0971             ; START TERMS
0921   0971 D7            push a
0922   0972 11            mov a, b
0923   0973 26 02 00      mov b, $2
0924   0976 54            add a, b
0925   0977 27            mov b, a
0926   0978 E4            pop a
0927   0979             ; END TERMS
0928   0979 E7            pop d
0929   097A FD 43         mov [d], b
0930   097C             ;; break; 
0931   097C 0A B0 09      jmp _switch10_exit ; case break
0932   097F             _switch10_case5:
0933   097F             ;; print(*(char**)p); 
0934   097F FA FF FF      lea d, [bp + -1] ; $p
0935   0982 2A            mov b, [d]
0936   0983 74            mov d, b
0937   0984 2A            mov b, [d]
0938   0985 FD AB         swp b
0939   0987 D8            push b
0940   0988 07 9E 0E      call print
0941   098B 51 02 00      add sp, 2
0942   098E             ;; p = p + 2; 
0943   098E FA FF FF      lea d, [bp + -1] ; $p
0944   0991 DA            push d
0945   0992 FA FF FF      lea d, [bp + -1] ; $p
0946   0995 2A            mov b, [d]
0947   0996             ; START TERMS
0948   0996 D7            push a
0949   0997 11            mov a, b
0950   0998 26 02 00      mov b, $2
0951   099B 54            add a, b
0952   099C 27            mov b, a
0953   099D E4            pop a
0954   099E             ; END TERMS
0955   099E E7            pop d
0956   099F FD 43         mov [d], b
0957   09A1             ;; break; 
0958   09A1 0A B0 09      jmp _switch10_exit ; case break
0959   09A4             _switch10_default:
0960   09A4             ;; print("Error: Unknown argument type.\n"); 
0961   09A4 26 74 15      mov b, __s9 ; "Error: Unknown argument type.\n"
0962   09A7 FD AB         swp b
0963   09A9 D8            push b
0964   09AA 07 9E 0E      call print
0965   09AD 51 02 00      add sp, 2
0966   09B0             _switch10_exit:
0967   09B0             ;; fp++; 
0968   09B0 FA FD FF      lea d, [bp + -3] ; $fp
0969   09B3 2A            mov b, [d]
0970   09B4 FD 79         mov g, b
0971   09B6 FD 77         inc b
0972   09B8 FA FD FF      lea d, [bp + -3] ; $fp
0973   09BB FD 43         mov [d], b
0974   09BD FD 27         mov b, g
0975   09BF 0A E0 09      jmp _if9_exit
0976   09C2             _if9_else:
0977   09C2             ;; putchar(*fp); 
0978   09C2 FA FD FF      lea d, [bp + -3] ; $fp
0979   09C5 2A            mov b, [d]
0980   09C6 74            mov d, b
0981   09C7 32            mov bl, [d]
0982   09C8 A7 00         mov bh, 0
0983   09CA DD            push bl
0984   09CB 07 56 0E      call putchar
0985   09CE 51 01 00      add sp, 1
0986   09D1             ;; fp++; 
0987   09D1 FA FD FF      lea d, [bp + -3] ; $fp
0988   09D4 2A            mov b, [d]
0989   09D5 FD 79         mov g, b
0990   09D7 FD 77         inc b
0991   09D9 FA FD FF      lea d, [bp + -3] ; $fp
0992   09DC FD 43         mov [d], b
0993   09DE FD 27         mov b, g
0994   09E0             _if9_exit:
0995   09E0             _if8_exit:
0996   09E0             _for7_update:
0997   09E0 0A 80 08      jmp _for7_cond
0998   09E3             _for7_exit:
0999   09E3 F9            leave
1000   09E4 09            ret
1001   09E5             
1002   09E5             printx16:
1003   09E5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1004   09E8             
1005   09E8             ; --- BEGIN INLINE ASM BLOCK
1006   09E8 FA 05 00      lea d, [bp + 5] ; $hex
1007   09EB 2A            mov b, [d]
1008   09EC 07 75 12      call print_u16x
1009   09EF             ; --- END INLINE ASM BLOCK
1010   09EF             
1011   09EF F9            leave
1012   09F0 09            ret
1013   09F1             
1014   09F1             printx8:
1015   09F1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1016   09F4             
1017   09F4             ; --- BEGIN INLINE ASM BLOCK
1018   09F4 FA 05 00      lea d, [bp + 5] ; $hex
1019   09F7 32            mov bl, [d]
1020   09F8 07 B9 12      call print_u8x
1021   09FB             ; --- END INLINE ASM BLOCK
1022   09FB             
1023   09FB F9            leave
1024   09FC 09            ret
1025   09FD             
1026   09FD             hex_to_int:
1027   09FD F8 00 00      enter 0 ; (push bp; mov bp, sp)
1028   0A00             ; $value 
1029   0A00 10 00 00      mov a, $0
1030   0A03 45 FF FF      mov [bp + -1], a
1031   0A06             ; $i 
1032   0A06             ; $hex_char 
1033   0A06             ; $len 
1034   0A06 52 07 00      sub sp, 7
1035   0A09             ;; len = strlen(hex_string); 
1036   0A09 FA FA FF      lea d, [bp + -6] ; $len
1037   0A0C DA            push d
1038   0A0D FA 05 00      lea d, [bp + 5] ; $hex_string
1039   0A10 2A            mov b, [d]
1040   0A11 FD AB         swp b
1041   0A13 D8            push b
1042   0A14 07 11 08      call strlen
1043   0A17 51 02 00      add sp, 2
1044   0A1A E7            pop d
1045   0A1B FD 43         mov [d], b
1046   0A1D             ;; for (i = 0; i < len; i++) { 
1047   0A1D             _for11_init:
1048   0A1D FA FD FF      lea d, [bp + -3] ; $i
1049   0A20 DA            push d
1050   0A21 26 00 00      mov b, $0
1051   0A24 E7            pop d
1052   0A25 FD 43         mov [d], b
1053   0A27             _for11_cond:
1054   0A27 FA FD FF      lea d, [bp + -3] ; $i
1055   0A2A 2A            mov b, [d]
1056   0A2B             ; START RELATIONAL
1057   0A2B D7            push a
1058   0A2C 11            mov a, b
1059   0A2D FA FA FF      lea d, [bp + -6] ; $len
1060   0A30 2A            mov b, [d]
1061   0A31 B0            cmp a, b
1062   0A32 FD 73         slt ; < 
1063   0A34 E4            pop a
1064   0A35             ; END RELATIONAL
1065   0A35 C0 00 00      cmp b, 0
1066   0A38 C6 3D 0B      je _for11_exit
1067   0A3B             _for11_block:
1068   0A3B             ;; hex_char = hex_string[i]; 
1069   0A3B FA FC FF      lea d, [bp + -4] ; $hex_char
1070   0A3E DA            push d
1071   0A3F FA 05 00      lea d, [bp + 5] ; $hex_string
1072   0A42 FD 2A         mov d, [d]
1073   0A44 D7            push a
1074   0A45 DA            push d
1075   0A46 FA FD FF      lea d, [bp + -3] ; $i
1076   0A49 2A            mov b, [d]
1077   0A4A E7            pop d
1078   0A4B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1079   0A4F E4            pop a
1080   0A50 32            mov bl, [d]
1081   0A51 A7 00         mov bh, 0
1082   0A53 E7            pop d
1083   0A54 FD 3E         mov [d], bl
1084   0A56             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1085   0A56             _if12_cond:
1086   0A56 FA FC FF      lea d, [bp + -4] ; $hex_char
1087   0A59 32            mov bl, [d]
1088   0A5A A7 00         mov bh, 0
1089   0A5C             ; START RELATIONAL
1090   0A5C D7            push a
1091   0A5D 11            mov a, b
1092   0A5E 26 61 00      mov b, $61
1093   0A61 B0            cmp a, b
1094   0A62 FD 80         sge ; >=
1095   0A64 E4            pop a
1096   0A65             ; END RELATIONAL
1097   0A65 D7            push a
1098   0A66 11            mov a, b
1099   0A67 FA FC FF      lea d, [bp + -4] ; $hex_char
1100   0A6A 32            mov bl, [d]
1101   0A6B A7 00         mov bh, 0
1102   0A6D             ; START RELATIONAL
1103   0A6D D7            push a
1104   0A6E 11            mov a, b
1105   0A6F 26 66 00      mov b, $66
1106   0A72 B0            cmp a, b
1107   0A73 FD 74         sle ; <=
1108   0A75 E4            pop a
1109   0A76             ; END RELATIONAL
1110   0A76 FD A7         sand a, b ; &&
1111   0A78 E4            pop a
1112   0A79 C0 00 00      cmp b, 0
1113   0A7C C6 AD 0A      je _if12_else
1114   0A7F             _if12_true:
1115   0A7F             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1116   0A7F FA FF FF      lea d, [bp + -1] ; $value
1117   0A82 DA            push d
1118   0A83 FA FF FF      lea d, [bp + -1] ; $value
1119   0A86 2A            mov b, [d]
1120   0A87             ; START FACTORS
1121   0A87 D7            push a
1122   0A88 11            mov a, b
1123   0A89 26 10 00      mov b, $10
1124   0A8C AC            mul a, b ; *
1125   0A8D 11            mov a, b
1126   0A8E 27            mov b, a
1127   0A8F E4            pop a
1128   0A90             ; END FACTORS
1129   0A90             ; START TERMS
1130   0A90 D7            push a
1131   0A91 11            mov a, b
1132   0A92 FA FC FF      lea d, [bp + -4] ; $hex_char
1133   0A95 32            mov bl, [d]
1134   0A96 A7 00         mov bh, 0
1135   0A98             ; START TERMS
1136   0A98 D7            push a
1137   0A99 11            mov a, b
1138   0A9A 26 61 00      mov b, $61
1139   0A9D 60            sub a, b
1140   0A9E 26 0A 00      mov b, $a
1141   0AA1 54            add a, b
1142   0AA2 27            mov b, a
1143   0AA3 E4            pop a
1144   0AA4             ; END TERMS
1145   0AA4 54            add a, b
1146   0AA5 27            mov b, a
1147   0AA6 E4            pop a
1148   0AA7             ; END TERMS
1149   0AA7 E7            pop d
1150   0AA8 FD 43         mov [d], b
1151   0AAA 0A 2B 0B      jmp _if12_exit
1152   0AAD             _if12_else:
1153   0AAD             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1154   0AAD             _if13_cond:
1155   0AAD FA FC FF      lea d, [bp + -4] ; $hex_char
1156   0AB0 32            mov bl, [d]
1157   0AB1 A7 00         mov bh, 0
1158   0AB3             ; START RELATIONAL
1159   0AB3 D7            push a
1160   0AB4 11            mov a, b
1161   0AB5 26 41 00      mov b, $41
1162   0AB8 B0            cmp a, b
1163   0AB9 FD 80         sge ; >=
1164   0ABB E4            pop a
1165   0ABC             ; END RELATIONAL
1166   0ABC D7            push a
1167   0ABD 11            mov a, b
1168   0ABE FA FC FF      lea d, [bp + -4] ; $hex_char
1169   0AC1 32            mov bl, [d]
1170   0AC2 A7 00         mov bh, 0
1171   0AC4             ; START RELATIONAL
1172   0AC4 D7            push a
1173   0AC5 11            mov a, b
1174   0AC6 26 46 00      mov b, $46
1175   0AC9 B0            cmp a, b
1176   0ACA FD 74         sle ; <=
1177   0ACC E4            pop a
1178   0ACD             ; END RELATIONAL
1179   0ACD FD A7         sand a, b ; &&
1180   0ACF E4            pop a
1181   0AD0 C0 00 00      cmp b, 0
1182   0AD3 C6 04 0B      je _if13_else
1183   0AD6             _if13_true:
1184   0AD6             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1185   0AD6 FA FF FF      lea d, [bp + -1] ; $value
1186   0AD9 DA            push d
1187   0ADA FA FF FF      lea d, [bp + -1] ; $value
1188   0ADD 2A            mov b, [d]
1189   0ADE             ; START FACTORS
1190   0ADE D7            push a
1191   0ADF 11            mov a, b
1192   0AE0 26 10 00      mov b, $10
1193   0AE3 AC            mul a, b ; *
1194   0AE4 11            mov a, b
1195   0AE5 27            mov b, a
1196   0AE6 E4            pop a
1197   0AE7             ; END FACTORS
1198   0AE7             ; START TERMS
1199   0AE7 D7            push a
1200   0AE8 11            mov a, b
1201   0AE9 FA FC FF      lea d, [bp + -4] ; $hex_char
1202   0AEC 32            mov bl, [d]
1203   0AED A7 00         mov bh, 0
1204   0AEF             ; START TERMS
1205   0AEF D7            push a
1206   0AF0 11            mov a, b
1207   0AF1 26 41 00      mov b, $41
1208   0AF4 60            sub a, b
1209   0AF5 26 0A 00      mov b, $a
1210   0AF8 54            add a, b
1211   0AF9 27            mov b, a
1212   0AFA E4            pop a
1213   0AFB             ; END TERMS
1214   0AFB 54            add a, b
1215   0AFC 27            mov b, a
1216   0AFD E4            pop a
1217   0AFE             ; END TERMS
1218   0AFE E7            pop d
1219   0AFF FD 43         mov [d], b
1220   0B01 0A 2B 0B      jmp _if13_exit
1221   0B04             _if13_else:
1222   0B04             ;; value = (value * 16) + (hex_char - '0'); 
1223   0B04 FA FF FF      lea d, [bp + -1] ; $value
1224   0B07 DA            push d
1225   0B08 FA FF FF      lea d, [bp + -1] ; $value
1226   0B0B 2A            mov b, [d]
1227   0B0C             ; START FACTORS
1228   0B0C D7            push a
1229   0B0D 11            mov a, b
1230   0B0E 26 10 00      mov b, $10
1231   0B11 AC            mul a, b ; *
1232   0B12 11            mov a, b
1233   0B13 27            mov b, a
1234   0B14 E4            pop a
1235   0B15             ; END FACTORS
1236   0B15             ; START TERMS
1237   0B15 D7            push a
1238   0B16 11            mov a, b
1239   0B17 FA FC FF      lea d, [bp + -4] ; $hex_char
1240   0B1A 32            mov bl, [d]
1241   0B1B A7 00         mov bh, 0
1242   0B1D             ; START TERMS
1243   0B1D D7            push a
1244   0B1E 11            mov a, b
1245   0B1F 26 30 00      mov b, $30
1246   0B22 60            sub a, b
1247   0B23 27            mov b, a
1248   0B24 E4            pop a
1249   0B25             ; END TERMS
1250   0B25 54            add a, b
1251   0B26 27            mov b, a
1252   0B27 E4            pop a
1253   0B28             ; END TERMS
1254   0B28 E7            pop d
1255   0B29 FD 43         mov [d], b
1256   0B2B             _if13_exit:
1257   0B2B             _if12_exit:
1258   0B2B             _for11_update:
1259   0B2B FA FD FF      lea d, [bp + -3] ; $i
1260   0B2E 2A            mov b, [d]
1261   0B2F FD 79         mov g, b
1262   0B31 FD 77         inc b
1263   0B33 FA FD FF      lea d, [bp + -3] ; $i
1264   0B36 FD 43         mov [d], b
1265   0B38 FD 27         mov b, g
1266   0B3A 0A 27 0A      jmp _for11_cond
1267   0B3D             _for11_exit:
1268   0B3D             ;; return value; 
1269   0B3D FA FF FF      lea d, [bp + -1] ; $value
1270   0B40 2A            mov b, [d]
1271   0B41 F9            leave
1272   0B42 09            ret
1273   0B43             
1274   0B43             atoi:
1275   0B43 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1276   0B46             ; $result 
1277   0B46 10 00 00      mov a, $0
1278   0B49 45 FF FF      mov [bp + -1], a
1279   0B4C             ; $sign 
1280   0B4C 10 01 00      mov a, $1
1281   0B4F 45 FD FF      mov [bp + -3], a
1282   0B52 52 04 00      sub sp, 4
1283   0B55             ;; while (*str == ' ') str++; 
1284   0B55             _while14_cond:
1285   0B55 FA 05 00      lea d, [bp + 5] ; $str
1286   0B58 2A            mov b, [d]
1287   0B59 74            mov d, b
1288   0B5A 32            mov bl, [d]
1289   0B5B A7 00         mov bh, 0
1290   0B5D             ; START RELATIONAL
1291   0B5D D7            push a
1292   0B5E 11            mov a, b
1293   0B5F 26 20 00      mov b, $20
1294   0B62 B0            cmp a, b
1295   0B63 FD 71         seq ; ==
1296   0B65 E4            pop a
1297   0B66             ; END RELATIONAL
1298   0B66 C0 00 00      cmp b, 0
1299   0B69 C6 7E 0B      je _while14_exit
1300   0B6C             _while14_block:
1301   0B6C             ;; str++; 
1302   0B6C FA 05 00      lea d, [bp + 5] ; $str
1303   0B6F 2A            mov b, [d]
1304   0B70 FD 79         mov g, b
1305   0B72 FD 77         inc b
1306   0B74 FA 05 00      lea d, [bp + 5] ; $str
1307   0B77 FD 43         mov [d], b
1308   0B79 FD 27         mov b, g
1309   0B7B 0A 55 0B      jmp _while14_cond
1310   0B7E             _while14_exit:
1311   0B7E             ;; if (*str == '-' || *str == '+') { 
1312   0B7E             _if15_cond:
1313   0B7E FA 05 00      lea d, [bp + 5] ; $str
1314   0B81 2A            mov b, [d]
1315   0B82 74            mov d, b
1316   0B83 32            mov bl, [d]
1317   0B84 A7 00         mov bh, 0
1318   0B86             ; START RELATIONAL
1319   0B86 D7            push a
1320   0B87 11            mov a, b
1321   0B88 26 2D 00      mov b, $2d
1322   0B8B B0            cmp a, b
1323   0B8C FD 71         seq ; ==
1324   0B8E E4            pop a
1325   0B8F             ; END RELATIONAL
1326   0B8F D7            push a
1327   0B90 11            mov a, b
1328   0B91 FA 05 00      lea d, [bp + 5] ; $str
1329   0B94 2A            mov b, [d]
1330   0B95 74            mov d, b
1331   0B96 32            mov bl, [d]
1332   0B97 A7 00         mov bh, 0
1333   0B99             ; START RELATIONAL
1334   0B99 D7            push a
1335   0B9A 11            mov a, b
1336   0B9B 26 2B 00      mov b, $2b
1337   0B9E B0            cmp a, b
1338   0B9F FD 71         seq ; ==
1339   0BA1 E4            pop a
1340   0BA2             ; END RELATIONAL
1341   0BA2 FD A8         sor a, b ; ||
1342   0BA4 E4            pop a
1343   0BA5 C0 00 00      cmp b, 0
1344   0BA8 C6 E3 0B      je _if15_exit
1345   0BAB             _if15_true:
1346   0BAB             ;; if (*str == '-') sign = -1; 
1347   0BAB             _if16_cond:
1348   0BAB FA 05 00      lea d, [bp + 5] ; $str
1349   0BAE 2A            mov b, [d]
1350   0BAF 74            mov d, b
1351   0BB0 32            mov bl, [d]
1352   0BB1 A7 00         mov bh, 0
1353   0BB3             ; START RELATIONAL
1354   0BB3 D7            push a
1355   0BB4 11            mov a, b
1356   0BB5 26 2D 00      mov b, $2d
1357   0BB8 B0            cmp a, b
1358   0BB9 FD 71         seq ; ==
1359   0BBB E4            pop a
1360   0BBC             ; END RELATIONAL
1361   0BBC C0 00 00      cmp b, 0
1362   0BBF C6 D1 0B      je _if16_exit
1363   0BC2             _if16_true:
1364   0BC2             ;; sign = -1; 
1365   0BC2 FA FD FF      lea d, [bp + -3] ; $sign
1366   0BC5 DA            push d
1367   0BC6 26 01 00      mov b, $1
1368   0BC9 FD 97         neg b
1369   0BCB E7            pop d
1370   0BCC FD 43         mov [d], b
1371   0BCE 0A D1 0B      jmp _if16_exit
1372   0BD1             _if16_exit:
1373   0BD1             ;; str++; 
1374   0BD1 FA 05 00      lea d, [bp + 5] ; $str
1375   0BD4 2A            mov b, [d]
1376   0BD5 FD 79         mov g, b
1377   0BD7 FD 77         inc b
1378   0BD9 FA 05 00      lea d, [bp + 5] ; $str
1379   0BDC FD 43         mov [d], b
1380   0BDE FD 27         mov b, g
1381   0BE0 0A E3 0B      jmp _if15_exit
1382   0BE3             _if15_exit:
1383   0BE3             ;; while (*str >= '0' && *str <= '9') { 
1384   0BE3             _while17_cond:
1385   0BE3 FA 05 00      lea d, [bp + 5] ; $str
1386   0BE6 2A            mov b, [d]
1387   0BE7 74            mov d, b
1388   0BE8 32            mov bl, [d]
1389   0BE9 A7 00         mov bh, 0
1390   0BEB             ; START RELATIONAL
1391   0BEB D7            push a
1392   0BEC 11            mov a, b
1393   0BED 26 30 00      mov b, $30
1394   0BF0 B0            cmp a, b
1395   0BF1 FD 80         sge ; >=
1396   0BF3 E4            pop a
1397   0BF4             ; END RELATIONAL
1398   0BF4 D7            push a
1399   0BF5 11            mov a, b
1400   0BF6 FA 05 00      lea d, [bp + 5] ; $str
1401   0BF9 2A            mov b, [d]
1402   0BFA 74            mov d, b
1403   0BFB 32            mov bl, [d]
1404   0BFC A7 00         mov bh, 0
1405   0BFE             ; START RELATIONAL
1406   0BFE D7            push a
1407   0BFF 11            mov a, b
1408   0C00 26 39 00      mov b, $39
1409   0C03 B0            cmp a, b
1410   0C04 FD 74         sle ; <=
1411   0C06 E4            pop a
1412   0C07             ; END RELATIONAL
1413   0C07 FD A7         sand a, b ; &&
1414   0C09 E4            pop a
1415   0C0A C0 00 00      cmp b, 0
1416   0C0D C6 4B 0C      je _while17_exit
1417   0C10             _while17_block:
1418   0C10             ;; result = result * 10 + (*str - '0'); 
1419   0C10 FA FF FF      lea d, [bp + -1] ; $result
1420   0C13 DA            push d
1421   0C14 FA FF FF      lea d, [bp + -1] ; $result
1422   0C17 2A            mov b, [d]
1423   0C18             ; START FACTORS
1424   0C18 D7            push a
1425   0C19 11            mov a, b
1426   0C1A 26 0A 00      mov b, $a
1427   0C1D AC            mul a, b ; *
1428   0C1E 11            mov a, b
1429   0C1F 27            mov b, a
1430   0C20 E4            pop a
1431   0C21             ; END FACTORS
1432   0C21             ; START TERMS
1433   0C21 D7            push a
1434   0C22 11            mov a, b
1435   0C23 FA 05 00      lea d, [bp + 5] ; $str
1436   0C26 2A            mov b, [d]
1437   0C27 74            mov d, b
1438   0C28 32            mov bl, [d]
1439   0C29 A7 00         mov bh, 0
1440   0C2B             ; START TERMS
1441   0C2B D7            push a
1442   0C2C 11            mov a, b
1443   0C2D 26 30 00      mov b, $30
1444   0C30 60            sub a, b
1445   0C31 27            mov b, a
1446   0C32 E4            pop a
1447   0C33             ; END TERMS
1448   0C33 54            add a, b
1449   0C34 27            mov b, a
1450   0C35 E4            pop a
1451   0C36             ; END TERMS
1452   0C36 E7            pop d
1453   0C37 FD 43         mov [d], b
1454   0C39             ;; str++; 
1455   0C39 FA 05 00      lea d, [bp + 5] ; $str
1456   0C3C 2A            mov b, [d]
1457   0C3D FD 79         mov g, b
1458   0C3F FD 77         inc b
1459   0C41 FA 05 00      lea d, [bp + 5] ; $str
1460   0C44 FD 43         mov [d], b
1461   0C46 FD 27         mov b, g
1462   0C48 0A E3 0B      jmp _while17_cond
1463   0C4B             _while17_exit:
1464   0C4B             ;; return sign * result; 
1465   0C4B FA FD FF      lea d, [bp + -3] ; $sign
1466   0C4E 2A            mov b, [d]
1467   0C4F             ; START FACTORS
1468   0C4F D7            push a
1469   0C50 11            mov a, b
1470   0C51 FA FF FF      lea d, [bp + -1] ; $result
1471   0C54 2A            mov b, [d]
1472   0C55 AC            mul a, b ; *
1473   0C56 11            mov a, b
1474   0C57 27            mov b, a
1475   0C58 E4            pop a
1476   0C59             ; END FACTORS
1477   0C59 F9            leave
1478   0C5A 09            ret
1479   0C5B             
1480   0C5B             gets:
1481   0C5B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1482   0C5E             
1483   0C5E             ; --- BEGIN INLINE ASM BLOCK
1484   0C5E FA 05 00      lea d, [bp + 5] ; $s
1485   0C61 15            mov a, [d]
1486   0C62 3C            mov d, a
1487   0C63 07 DA 10      call _gets
1488   0C66             ; --- END INLINE ASM BLOCK
1489   0C66             
1490   0C66             ;; return strlen(s); 
1491   0C66 FA 05 00      lea d, [bp + 5] ; $s
1492   0C69 2A            mov b, [d]
1493   0C6A FD AB         swp b
1494   0C6C D8            push b
1495   0C6D 07 11 08      call strlen
1496   0C70 51 02 00      add sp, 2
1497   0C73 F9            leave
1498   0C74 09            ret
1499   0C75             
1500   0C75             prints:
1501   0C75 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1502   0C78             ; $digits 
1503   0C78             ; $i 
1504   0C78 10 00 00      mov a, $0
1505   0C7B 45 FA FF      mov [bp + -6], a
1506   0C7E 52 07 00      sub sp, 7
1507   0C81             ;; if (num < 0) { 
1508   0C81             _if18_cond:
1509   0C81 FA 05 00      lea d, [bp + 5] ; $num
1510   0C84 2A            mov b, [d]
1511   0C85             ; START RELATIONAL
1512   0C85 D7            push a
1513   0C86 11            mov a, b
1514   0C87 26 00 00      mov b, $0
1515   0C8A B0            cmp a, b
1516   0C8B FD 73         slt ; < 
1517   0C8D E4            pop a
1518   0C8E             ; END RELATIONAL
1519   0C8E C0 00 00      cmp b, 0
1520   0C91 C6 AE 0C      je _if18_else
1521   0C94             _if18_true:
1522   0C94             ;; putchar('-'); 
1523   0C94 26 2D 00      mov b, $2d
1524   0C97 DD            push bl
1525   0C98 07 56 0E      call putchar
1526   0C9B 51 01 00      add sp, 1
1527   0C9E             ;; num = -num; 
1528   0C9E FA 05 00      lea d, [bp + 5] ; $num
1529   0CA1 DA            push d
1530   0CA2 FA 05 00      lea d, [bp + 5] ; $num
1531   0CA5 2A            mov b, [d]
1532   0CA6 FD 97         neg b
1533   0CA8 E7            pop d
1534   0CA9 FD 43         mov [d], b
1535   0CAB 0A D0 0C      jmp _if18_exit
1536   0CAE             _if18_else:
1537   0CAE             ;; if (num == 0) { 
1538   0CAE             _if19_cond:
1539   0CAE FA 05 00      lea d, [bp + 5] ; $num
1540   0CB1 2A            mov b, [d]
1541   0CB2             ; START RELATIONAL
1542   0CB2 D7            push a
1543   0CB3 11            mov a, b
1544   0CB4 26 00 00      mov b, $0
1545   0CB7 B0            cmp a, b
1546   0CB8 FD 71         seq ; ==
1547   0CBA E4            pop a
1548   0CBB             ; END RELATIONAL
1549   0CBB C0 00 00      cmp b, 0
1550   0CBE C6 D0 0C      je _if19_exit
1551   0CC1             _if19_true:
1552   0CC1             ;; putchar('0'); 
1553   0CC1 26 30 00      mov b, $30
1554   0CC4 DD            push bl
1555   0CC5 07 56 0E      call putchar
1556   0CC8 51 01 00      add sp, 1
1557   0CCB             ;; return; 
1558   0CCB F9            leave
1559   0CCC 09            ret
1560   0CCD 0A D0 0C      jmp _if19_exit
1561   0CD0             _if19_exit:
1562   0CD0             _if18_exit:
1563   0CD0             ;; while (num > 0) { 
1564   0CD0             _while20_cond:
1565   0CD0 FA 05 00      lea d, [bp + 5] ; $num
1566   0CD3 2A            mov b, [d]
1567   0CD4             ; START RELATIONAL
1568   0CD4 D7            push a
1569   0CD5 11            mov a, b
1570   0CD6 26 00 00      mov b, $0
1571   0CD9 B0            cmp a, b
1572   0CDA FD 7F         sgt ; >
1573   0CDC E4            pop a
1574   0CDD             ; END RELATIONAL
1575   0CDD C0 00 00      cmp b, 0
1576   0CE0 C6 2D 0D      je _while20_exit
1577   0CE3             _while20_block:
1578   0CE3             ;; digits[i] = '0' + (num % 10); 
1579   0CE3 FA FC FF      lea d, [bp + -4] ; $digits
1580   0CE6 D7            push a
1581   0CE7 DA            push d
1582   0CE8 FA FA FF      lea d, [bp + -6] ; $i
1583   0CEB 2A            mov b, [d]
1584   0CEC E7            pop d
1585   0CED 5A            add d, b
1586   0CEE E4            pop a
1587   0CEF DA            push d
1588   0CF0 26 30 00      mov b, $30
1589   0CF3             ; START TERMS
1590   0CF3 D7            push a
1591   0CF4 11            mov a, b
1592   0CF5 FA 05 00      lea d, [bp + 5] ; $num
1593   0CF8 2A            mov b, [d]
1594   0CF9             ; START FACTORS
1595   0CF9 D7            push a
1596   0CFA 11            mov a, b
1597   0CFB 26 0A 00      mov b, $a
1598   0CFE AE            div a, b ; 
1599   0CFF 11            mov a, b
1600   0D00 27            mov b, a
1601   0D01 E4            pop a
1602   0D02             ; END FACTORS
1603   0D02 54            add a, b
1604   0D03 27            mov b, a
1605   0D04 E4            pop a
1606   0D05             ; END TERMS
1607   0D05 E7            pop d
1608   0D06 FD 3E         mov [d], bl
1609   0D08             ;; num = num / 10; 
1610   0D08 FA 05 00      lea d, [bp + 5] ; $num
1611   0D0B DA            push d
1612   0D0C FA 05 00      lea d, [bp + 5] ; $num
1613   0D0F 2A            mov b, [d]
1614   0D10             ; START FACTORS
1615   0D10 D7            push a
1616   0D11 11            mov a, b
1617   0D12 26 0A 00      mov b, $a
1618   0D15 AE            div a, b
1619   0D16 27            mov b, a
1620   0D17 E4            pop a
1621   0D18             ; END FACTORS
1622   0D18 E7            pop d
1623   0D19 FD 43         mov [d], b
1624   0D1B             ;; i++; 
1625   0D1B FA FA FF      lea d, [bp + -6] ; $i
1626   0D1E 2A            mov b, [d]
1627   0D1F FD 79         mov g, b
1628   0D21 FD 77         inc b
1629   0D23 FA FA FF      lea d, [bp + -6] ; $i
1630   0D26 FD 43         mov [d], b
1631   0D28 FD 27         mov b, g
1632   0D2A 0A D0 0C      jmp _while20_cond
1633   0D2D             _while20_exit:
1634   0D2D             ;; while (i > 0) { 
1635   0D2D             _while21_cond:
1636   0D2D FA FA FF      lea d, [bp + -6] ; $i
1637   0D30 2A            mov b, [d]
1638   0D31             ; START RELATIONAL
1639   0D31 D7            push a
1640   0D32 11            mov a, b
1641   0D33 26 00 00      mov b, $0
1642   0D36 B0            cmp a, b
1643   0D37 FD 7F         sgt ; >
1644   0D39 E4            pop a
1645   0D3A             ; END RELATIONAL
1646   0D3A C0 00 00      cmp b, 0
1647   0D3D C6 68 0D      je _while21_exit
1648   0D40             _while21_block:
1649   0D40             ;; i--; 
1650   0D40 FA FA FF      lea d, [bp + -6] ; $i
1651   0D43 2A            mov b, [d]
1652   0D44 FD 79         mov g, b
1653   0D46 FD 7D         dec b
1654   0D48 FA FA FF      lea d, [bp + -6] ; $i
1655   0D4B FD 43         mov [d], b
1656   0D4D FD 27         mov b, g
1657   0D4F             ;; putchar(digits[i]); 
1658   0D4F FA FC FF      lea d, [bp + -4] ; $digits
1659   0D52 D7            push a
1660   0D53 DA            push d
1661   0D54 FA FA FF      lea d, [bp + -6] ; $i
1662   0D57 2A            mov b, [d]
1663   0D58 E7            pop d
1664   0D59 5A            add d, b
1665   0D5A E4            pop a
1666   0D5B 32            mov bl, [d]
1667   0D5C A7 00         mov bh, 0
1668   0D5E DD            push bl
1669   0D5F 07 56 0E      call putchar
1670   0D62 51 01 00      add sp, 1
1671   0D65 0A 2D 0D      jmp _while21_cond
1672   0D68             _while21_exit:
1673   0D68 F9            leave
1674   0D69 09            ret
1675   0D6A             
1676   0D6A             printu:
1677   0D6A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1678   0D6D             ; $digits 
1679   0D6D             ; $i 
1680   0D6D 52 07 00      sub sp, 7
1681   0D70             ;; i = 0; 
1682   0D70 FA FA FF      lea d, [bp + -6] ; $i
1683   0D73 DA            push d
1684   0D74 26 00 00      mov b, $0
1685   0D77 E7            pop d
1686   0D78 FD 43         mov [d], b
1687   0D7A             ;; if(num == 0){ 
1688   0D7A             _if22_cond:
1689   0D7A FA 05 00      lea d, [bp + 5] ; $num
1690   0D7D 2A            mov b, [d]
1691   0D7E             ; START RELATIONAL
1692   0D7E D7            push a
1693   0D7F 11            mov a, b
1694   0D80 26 00 00      mov b, $0
1695   0D83 B0            cmp a, b
1696   0D84 FD 71         seq ; ==
1697   0D86 E4            pop a
1698   0D87             ; END RELATIONAL
1699   0D87 C0 00 00      cmp b, 0
1700   0D8A C6 9C 0D      je _if22_exit
1701   0D8D             _if22_true:
1702   0D8D             ;; putchar('0'); 
1703   0D8D 26 30 00      mov b, $30
1704   0D90 DD            push bl
1705   0D91 07 56 0E      call putchar
1706   0D94 51 01 00      add sp, 1
1707   0D97             ;; return; 
1708   0D97 F9            leave
1709   0D98 09            ret
1710   0D99 0A 9C 0D      jmp _if22_exit
1711   0D9C             _if22_exit:
1712   0D9C             ;; while (num > 0) { 
1713   0D9C             _while23_cond:
1714   0D9C FA 05 00      lea d, [bp + 5] ; $num
1715   0D9F 2A            mov b, [d]
1716   0DA0             ; START RELATIONAL
1717   0DA0 D7            push a
1718   0DA1 11            mov a, b
1719   0DA2 26 00 00      mov b, $0
1720   0DA5 B0            cmp a, b
1721   0DA6 FD 81         sgu ; > (unsigned)
1722   0DA8 E4            pop a
1723   0DA9             ; END RELATIONAL
1724   0DA9 C0 00 00      cmp b, 0
1725   0DAC C6 F9 0D      je _while23_exit
1726   0DAF             _while23_block:
1727   0DAF             ;; digits[i] = '0' + (num % 10); 
1728   0DAF FA FC FF      lea d, [bp + -4] ; $digits
1729   0DB2 D7            push a
1730   0DB3 DA            push d
1731   0DB4 FA FA FF      lea d, [bp + -6] ; $i
1732   0DB7 2A            mov b, [d]
1733   0DB8 E7            pop d
1734   0DB9 5A            add d, b
1735   0DBA E4            pop a
1736   0DBB DA            push d
1737   0DBC 26 30 00      mov b, $30
1738   0DBF             ; START TERMS
1739   0DBF D7            push a
1740   0DC0 11            mov a, b
1741   0DC1 FA 05 00      lea d, [bp + 5] ; $num
1742   0DC4 2A            mov b, [d]
1743   0DC5             ; START FACTORS
1744   0DC5 D7            push a
1745   0DC6 11            mov a, b
1746   0DC7 26 0A 00      mov b, $a
1747   0DCA AE            div a, b ; 
1748   0DCB 11            mov a, b
1749   0DCC 27            mov b, a
1750   0DCD E4            pop a
1751   0DCE             ; END FACTORS
1752   0DCE 54            add a, b
1753   0DCF 27            mov b, a
1754   0DD0 E4            pop a
1755   0DD1             ; END TERMS
1756   0DD1 E7            pop d
1757   0DD2 FD 3E         mov [d], bl
1758   0DD4             ;; num = num / 10; 
1759   0DD4 FA 05 00      lea d, [bp + 5] ; $num
1760   0DD7 DA            push d
1761   0DD8 FA 05 00      lea d, [bp + 5] ; $num
1762   0DDB 2A            mov b, [d]
1763   0DDC             ; START FACTORS
1764   0DDC D7            push a
1765   0DDD 11            mov a, b
1766   0DDE 26 0A 00      mov b, $a
1767   0DE1 AE            div a, b
1768   0DE2 27            mov b, a
1769   0DE3 E4            pop a
1770   0DE4             ; END FACTORS
1771   0DE4 E7            pop d
1772   0DE5 FD 43         mov [d], b
1773   0DE7             ;; i++; 
1774   0DE7 FA FA FF      lea d, [bp + -6] ; $i
1775   0DEA 2A            mov b, [d]
1776   0DEB FD 79         mov g, b
1777   0DED FD 77         inc b
1778   0DEF FA FA FF      lea d, [bp + -6] ; $i
1779   0DF2 FD 43         mov [d], b
1780   0DF4 FD 27         mov b, g
1781   0DF6 0A 9C 0D      jmp _while23_cond
1782   0DF9             _while23_exit:
1783   0DF9             ;; while (i > 0) { 
1784   0DF9             _while24_cond:
1785   0DF9 FA FA FF      lea d, [bp + -6] ; $i
1786   0DFC 2A            mov b, [d]
1787   0DFD             ; START RELATIONAL
1788   0DFD D7            push a
1789   0DFE 11            mov a, b
1790   0DFF 26 00 00      mov b, $0
1791   0E02 B0            cmp a, b
1792   0E03 FD 7F         sgt ; >
1793   0E05 E4            pop a
1794   0E06             ; END RELATIONAL
1795   0E06 C0 00 00      cmp b, 0
1796   0E09 C6 34 0E      je _while24_exit
1797   0E0C             _while24_block:
1798   0E0C             ;; i--; 
1799   0E0C FA FA FF      lea d, [bp + -6] ; $i
1800   0E0F 2A            mov b, [d]
1801   0E10 FD 79         mov g, b
1802   0E12 FD 7D         dec b
1803   0E14 FA FA FF      lea d, [bp + -6] ; $i
1804   0E17 FD 43         mov [d], b
1805   0E19 FD 27         mov b, g
1806   0E1B             ;; putchar(digits[i]); 
1807   0E1B FA FC FF      lea d, [bp + -4] ; $digits
1808   0E1E D7            push a
1809   0E1F DA            push d
1810   0E20 FA FA FF      lea d, [bp + -6] ; $i
1811   0E23 2A            mov b, [d]
1812   0E24 E7            pop d
1813   0E25 5A            add d, b
1814   0E26 E4            pop a
1815   0E27 32            mov bl, [d]
1816   0E28 A7 00         mov bh, 0
1817   0E2A DD            push bl
1818   0E2B 07 56 0E      call putchar
1819   0E2E 51 01 00      add sp, 1
1820   0E31 0A F9 0D      jmp _while24_cond
1821   0E34             _while24_exit:
1822   0E34 F9            leave
1823   0E35 09            ret
1824   0E36             
1825   0E36             rand:
1826   0E36 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1827   0E39             ; $sec 
1828   0E39 52 01 00      sub sp, 1
1829   0E3C             
1830   0E3C             ; --- BEGIN INLINE ASM BLOCK
1831   0E3C 19 00         mov al, 0
1832   0E3E 05 01         syscall sys_rtc					
1833   0E40 1A            mov al, ah
1834   0E41 FA 00 00      lea d, [bp + 0] ; $sec
1835   0E44 1E            mov al, [d]
1836   0E45             ; --- END INLINE ASM BLOCK
1837   0E45             
1838   0E45             ;; return sec; 
1839   0E45 FA 00 00      lea d, [bp + 0] ; $sec
1840   0E48 32            mov bl, [d]
1841   0E49 A7 00         mov bh, 0
1842   0E4B F9            leave
1843   0E4C 09            ret
1844   0E4D             
1845   0E4D             date:
1846   0E4D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1847   0E50             
1848   0E50             ; --- BEGIN INLINE ASM BLOCK
1849   0E50 19 00         mov al, 0 
1850   0E52 05 07         syscall sys_datetime
1851   0E54             ; --- END INLINE ASM BLOCK
1852   0E54             
1853   0E54 F9            leave
1854   0E55 09            ret
1855   0E56             
1856   0E56             putchar:
1857   0E56 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1858   0E59             
1859   0E59             ; --- BEGIN INLINE ASM BLOCK
1860   0E59 FA 05 00      lea d, [bp + 5] ; $c
1861   0E5C 1E            mov al, [d]
1862   0E5D 23            mov ah, al
1863   0E5E 07 D3 10      call _putchar
1864   0E61             ; --- END INLINE ASM BLOCK
1865   0E61             
1866   0E61 F9            leave
1867   0E62 09            ret
1868   0E63             
1869   0E63             getchar:
1870   0E63 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1871   0E66             ; $c 
1872   0E66 52 01 00      sub sp, 1
1873   0E69             
1874   0E69             ; --- BEGIN INLINE ASM BLOCK
1875   0E69 07 CC 10      call getch
1876   0E6C 1A            mov al, ah
1877   0E6D FA 00 00      lea d, [bp + 0] ; $c
1878   0E70 3E            mov [d], al
1879   0E71             ; --- END INLINE ASM BLOCK
1880   0E71             
1881   0E71             ;; return c; 
1882   0E71 FA 00 00      lea d, [bp + 0] ; $c
1883   0E74 32            mov bl, [d]
1884   0E75 A7 00         mov bh, 0
1885   0E77 F9            leave
1886   0E78 09            ret
1887   0E79             
1888   0E79             scann:
1889   0E79 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1890   0E7C             ; $m 
1891   0E7C 52 02 00      sub sp, 2
1892   0E7F             
1893   0E7F             ; --- BEGIN INLINE ASM BLOCK
1894   0E7F 07 17 13      call scan_u16d
1895   0E82 FA FF FF      lea d, [bp + -1] ; $m
1896   0E85 43            mov [d], a
1897   0E86             ; --- END INLINE ASM BLOCK
1898   0E86             
1899   0E86             ;; return m; 
1900   0E86 FA FF FF      lea d, [bp + -1] ; $m
1901   0E89 2A            mov b, [d]
1902   0E8A F9            leave
1903   0E8B 09            ret
1904   0E8C             
1905   0E8C             puts:
1906   0E8C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1907   0E8F             
1908   0E8F             ; --- BEGIN INLINE ASM BLOCK
1909   0E8F FA 05 00      lea d, [bp + 5] ; $s
1910   0E92 15            mov a, [d]
1911   0E93 3C            mov d, a
1912   0E94 07 1D 12      call _puts
1913   0E97 10 00 0A      mov a, $0A00
1914   0E9A 05 03         syscall sys_io
1915   0E9C             ; --- END INLINE ASM BLOCK
1916   0E9C             
1917   0E9C F9            leave
1918   0E9D 09            ret
1919   0E9E             
1920   0E9E             print:
1921   0E9E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1922   0EA1             
1923   0EA1             ; --- BEGIN INLINE ASM BLOCK
1924   0EA1 FA 05 00      lea d, [bp + 5] ; $s
1925   0EA4 FD 2A         mov d, [d]
1926   0EA6 07 1D 12      call _puts
1927   0EA9             ; --- END INLINE ASM BLOCK
1928   0EA9             
1929   0EA9 F9            leave
1930   0EAA 09            ret
1931   0EAB             
1932   0EAB             loadfile:
1933   0EAB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1934   0EAE             
1935   0EAE             ; --- BEGIN INLINE ASM BLOCK
1936   0EAE FA 07 00      lea d, [bp + 7] ; $destination
1937   0EB1 15            mov a, [d]
1938   0EB2 4F            mov di, a
1939   0EB3 FA 05 00      lea d, [bp + 5] ; $filename
1940   0EB6 FD 2A         mov d, [d]
1941   0EB8 19 14         mov al, 20
1942   0EBA 05 04         syscall sys_filesystem
1943   0EBC             ; --- END INLINE ASM BLOCK
1944   0EBC             
1945   0EBC F9            leave
1946   0EBD 09            ret
1947   0EBE             
1948   0EBE             create_file:
1949   0EBE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1950   0EC1 F9            leave
1951   0EC2 09            ret
1952   0EC3             
1953   0EC3             delete_file:
1954   0EC3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1955   0EC6             
1956   0EC6             ; --- BEGIN INLINE ASM BLOCK
1957   0EC6 FA 05 00      lea d, [bp + 5] ; $filename
1958   0EC9 19 0A         mov al, 10
1959   0ECB 05 04         syscall sys_filesystem
1960   0ECD             ; --- END INLINE ASM BLOCK
1961   0ECD             
1962   0ECD F9            leave
1963   0ECE 09            ret
1964   0ECF             
1965   0ECF             fopen:
1966   0ECF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1967   0ED2 F9            leave
1968   0ED3 09            ret
1969   0ED4             
1970   0ED4             fclose:
1971   0ED4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1972   0ED7 F9            leave
1973   0ED8 09            ret
1974   0ED9             
1975   0ED9             alloc:
1976   0ED9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1977   0EDC             ;; heap_top = heap_top + bytes; 
1978   0EDC 3B 9B 15      mov d, _heap_top ; $heap_top
1979   0EDF DA            push d
1980   0EE0 3B 9B 15      mov d, _heap_top ; $heap_top
1981   0EE3 2A            mov b, [d]
1982   0EE4             ; START TERMS
1983   0EE4 D7            push a
1984   0EE5 11            mov a, b
1985   0EE6 FA 05 00      lea d, [bp + 5] ; $bytes
1986   0EE9 2A            mov b, [d]
1987   0EEA 54            add a, b
1988   0EEB 27            mov b, a
1989   0EEC E4            pop a
1990   0EED             ; END TERMS
1991   0EED E7            pop d
1992   0EEE FD 43         mov [d], b
1993   0EF0             ;; return heap_top - bytes; 
1994   0EF0 3B 9B 15      mov d, _heap_top ; $heap_top
1995   0EF3 2A            mov b, [d]
1996   0EF4             ; START TERMS
1997   0EF4 D7            push a
1998   0EF5 11            mov a, b
1999   0EF6 FA 05 00      lea d, [bp + 5] ; $bytes
2000   0EF9 2A            mov b, [d]
2001   0EFA 60            sub a, b
2002   0EFB 27            mov b, a
2003   0EFC E4            pop a
2004   0EFD             ; END TERMS
2005   0EFD F9            leave
2006   0EFE 09            ret
2007   0EFF             
2008   0EFF             free:
2009   0EFF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2010   0F02             ;; return heap_top = heap_top - bytes; 
2011   0F02 3B 9B 15      mov d, _heap_top ; $heap_top
2012   0F05 DA            push d
2013   0F06 3B 9B 15      mov d, _heap_top ; $heap_top
2014   0F09 2A            mov b, [d]
2015   0F0A             ; START TERMS
2016   0F0A D7            push a
2017   0F0B 11            mov a, b
2018   0F0C FA 05 00      lea d, [bp + 5] ; $bytes
2019   0F0F 2A            mov b, [d]
2020   0F10 60            sub a, b
2021   0F11 27            mov b, a
2022   0F12 E4            pop a
2023   0F13             ; END TERMS
2024   0F13 E7            pop d
2025   0F14 FD 43         mov [d], b
2026   0F16 F9            leave
2027   0F17 09            ret
2028   0F18             
2029   0F18             exit:
2030   0F18 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2031   0F1B             
2032   0F1B             ; --- BEGIN INLINE ASM BLOCK
2033   0F1B 05 0B         syscall sys_terminate_proc
2034   0F1D             ; --- END INLINE ASM BLOCK
2035   0F1D             
2036   0F1D F9            leave
2037   0F1E 09            ret
2038   0F1F             
2039   0F1F             load_hex:
2040   0F1F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2041   0F22             ; $temp 
2042   0F22 52 02 00      sub sp, 2
2043   0F25             ;; temp = alloc(32768); 
2044   0F25 FA FF FF      lea d, [bp + -1] ; $temp
2045   0F28 DA            push d
2046   0F29 26 00 80      mov b, $8000
2047   0F2C FD AB         swp b
2048   0F2E D8            push b
2049   0F2F 07 D9 0E      call alloc
2050   0F32 51 02 00      add sp, 2
2051   0F35 E7            pop d
2052   0F36 FD 43         mov [d], b
2053   0F38             
2054   0F38             ; --- BEGIN INLINE ASM BLOCK
2055   0F38               
2056   0F38               
2057   0F38               
2058   0F38               
2059   0F38               
2060   0F38             _load_hex:
2061   0F38 D7            push a
2062   0F39 D8            push b
2063   0F3A DA            push d
2064   0F3B E2            push si
2065   0F3C E3            push di
2066   0F3D 52 00 80      sub sp, $8000      
2067   0F40 38 00 00      mov c, 0
2068   0F43 48            mov a, sp
2069   0F44 77            inc a
2070   0F45 3C            mov d, a          
2071   0F46 07 DA 10      call _gets        
2072   0F49 4D            mov si, a
2073   0F4A             __load_hex_loop:
2074   0F4A F6            lodsb             
2075   0F4B B9 00         cmp al, 0         
2076   0F4D C6 5B 0F      jz __load_hex_ret
2077   0F50 36            mov bh, al
2078   0F51 F6            lodsb
2079   0F52 2F            mov bl, al
2080   0F53 07 90 10      call _atoi        
2081   0F56 F7            stosb             
2082   0F57 78            inc c
2083   0F58 0A 4A 0F      jmp __load_hex_loop
2084   0F5B             __load_hex_ret:
2085   0F5B 51 00 80      add sp, $8000
2086   0F5E F0            pop di
2087   0F5F EF            pop si
2088   0F60 E7            pop d
2089   0F61 E5            pop b
2090   0F62 E4            pop a
2091   0F63             ; --- END INLINE ASM BLOCK
2092   0F63             
2093   0F63 F9            leave
2094   0F64 09            ret
2095   0F65             
2096   0F65             getparam:
2097   0F65 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2098   0F68             ; $data 
2099   0F68 52 01 00      sub sp, 1
2100   0F6B             
2101   0F6B             ; --- BEGIN INLINE ASM BLOCK
2102   0F6B 19 04         mov al, 4
2103   0F6D FA 05 00      lea d, [bp + 5] ; $address
2104   0F70 FD 2A         mov d, [d]
2105   0F72 05 0C         syscall sys_system
2106   0F74 FA 00 00      lea d, [bp + 0] ; $data
2107   0F77 FD 3E         mov [d], bl
2108   0F79             ; --- END INLINE ASM BLOCK
2109   0F79             
2110   0F79             ;; return data; 
2111   0F79 FA 00 00      lea d, [bp + 0] ; $data
2112   0F7C 32            mov bl, [d]
2113   0F7D A7 00         mov bh, 0
2114   0F7F F9            leave
2115   0F80 09            ret
2116   0F81             
2117   0F81             clear:
2118   0F81 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2119   0F84             ;; print("\033[2J\033[H"); 
2120   0F84 26 93 15      mov b, __s10 ; "\033[2J\033[H"
2121   0F87 FD AB         swp b
2122   0F89 D8            push b
2123   0F8A 07 9E 0E      call print
2124   0F8D 51 02 00      add sp, 2
2125   0F90 F9            leave
2126   0F91 09            ret
2127   0F92             
2128   0F92             printun:
2129   0F92 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2130   0F95             ;; print(prompt); 
2131   0F95 FA 05 00      lea d, [bp + 5] ; $prompt
2132   0F98 2A            mov b, [d]
2133   0F99 FD AB         swp b
2134   0F9B D8            push b
2135   0F9C 07 9E 0E      call print
2136   0F9F 51 02 00      add sp, 2
2137   0FA2             ;; printu(n); 
2138   0FA2 FA 07 00      lea d, [bp + 7] ; $n
2139   0FA5 2A            mov b, [d]
2140   0FA6 FD AB         swp b
2141   0FA8 D8            push b
2142   0FA9 07 6A 0D      call printu
2143   0FAC 51 02 00      add sp, 2
2144   0FAF             ;; print("\n"); 
2145   0FAF 26 61 15      mov b, __s7 ; "\n"
2146   0FB2 FD AB         swp b
2147   0FB4 D8            push b
2148   0FB5 07 9E 0E      call print
2149   0FB8 51 02 00      add sp, 2
2150   0FBB F9            leave
2151   0FBC 09            ret
2152   0FBD             
2153   0FBD             printsn:
2154   0FBD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2155   0FC0             ;; print(prompt); 
2156   0FC0 FA 05 00      lea d, [bp + 5] ; $prompt
2157   0FC3 2A            mov b, [d]
2158   0FC4 FD AB         swp b
2159   0FC6 D8            push b
2160   0FC7 07 9E 0E      call print
2161   0FCA 51 02 00      add sp, 2
2162   0FCD             ;; prints(n); 
2163   0FCD FA 07 00      lea d, [bp + 7] ; $n
2164   0FD0 2A            mov b, [d]
2165   0FD1 FD AB         swp b
2166   0FD3 D8            push b
2167   0FD4 07 75 0C      call prints
2168   0FD7 51 02 00      add sp, 2
2169   0FDA             ;; print("\n"); 
2170   0FDA 26 61 15      mov b, __s7 ; "\n"
2171   0FDD FD AB         swp b
2172   0FDF D8            push b
2173   0FE0 07 9E 0E      call print
2174   0FE3 51 02 00      add sp, 2
2175   0FE6 F9            leave
2176   0FE7 09            ret
2177   0FE8             
2178   0FE8             include_stdio_asm:
2179   0FE8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2180   0FEB             
2181   0FEB             ; --- BEGIN INLINE ASM BLOCK
2182   0FEB             .include "lib/stdio.asm"
0001+  0FEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0FEB             ; stdio.s
0003+  0FEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0FEB             .include "lib/string.asm"
0001++ 0FEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0FEB             ; string.s
0003++ 0FEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0FEB             
0005++ 0FEB             
0006++ 0FEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0FEB             ; _strrev
0008++ 0FEB             ; reverse a string
0009++ 0FEB             ; D = string address
0010++ 0FEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0FEB             ; 01234
0012++ 0FEB             _strrev:
0013++ 0FEB 4B          	pusha
0014++ 0FEC 07 32 10    	call _strlen	; length in C
0015++ 0FEF 12          	mov a, c
0016++ 0FF0 AF 01 00    	cmp a, 1
0017++ 0FF3 D0 0D 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0FF6 7D          	dec a
0019++ 0FF7 FD 4E       	mov si, d	; beginning of string
0020++ 0FF9 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0FFB 59          	add d, a	; end of string
0022++ 0FFC 12          	mov a, c
0023++ 0FFD FD 9B       	shr a		; divide by 2
0024++ 0FFF 39          	mov c, a	; C now counts the steps
0025++ 1000             _strrev_L0:
0026++ 1000 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1001 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1002 3E          	mov [d], al	; store left char into right side
0029++ 1003 1B          	mov al, bl
0030++ 1004 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1005 7E          	dec c
0032++ 1006 7F          	dec d
0033++ 1007 C2 00 00    	cmp c, 0
0034++ 100A C7 00 10    	jne _strrev_L0
0035++ 100D             _strrev_end:
0036++ 100D 4C          	popa
0037++ 100E 09          	ret
0038++ 100F             	
0039++ 100F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 100F             ; _strchr
0041++ 100F             ; search string in D for char in AL
0042++ 100F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 100F             _strchr:
0044++ 100F             _strchr_L0:
0045++ 100F 32          	mov bl, [d]
0046++ 1010 C1 00       	cmp bl, 0
0047++ 1012 C6 1D 10    	je _strchr_end
0048++ 1015 BA          	cmp al, bl
0049++ 1016 C6 1D 10    	je _strchr_end
0050++ 1019 79          	inc d
0051++ 101A 0A 0F 10    	jmp _strchr_L0
0052++ 101D             _strchr_end:
0053++ 101D 1B          	mov al, bl
0054++ 101E 09          	ret
0055++ 101F             
0056++ 101F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 101F             ; _strstr
0058++ 101F             ; find sub-string
0059++ 101F             ; str1 in SI
0060++ 101F             ; str2 in DI
0061++ 101F             ; SI points to end of source string
0062++ 101F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 101F             _strstr:
0064++ 101F DB          	push al
0065++ 1020 DA          	push d
0066++ 1021 E3          	push di
0067++ 1022             _strstr_loop:
0068++ 1022 F3          	cmpsb					; compare a byte of the strings
0069++ 1023 C7 2E 10    	jne _strstr_ret
0070++ 1026 FC 00 00    	lea d, [di + 0]
0071++ 1029 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 102B C7 22 10    	jne _strstr_loop				; equal chars but not at end
0073++ 102E             _strstr_ret:
0074++ 102E F0          	pop di
0075++ 102F E7          	pop d
0076++ 1030 E8          	pop al
0077++ 1031 09          	ret
0078++ 1032             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1032             ; length of null terminated string
0080++ 1032             ; result in C
0081++ 1032             ; pointer in D
0082++ 1032             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1032             _strlen:
0084++ 1032 DA          	push d
0085++ 1033 38 00 00    	mov c, 0
0086++ 1036             _strlen_L1:
0087++ 1036 BD 00       	cmp byte [d], 0
0088++ 1038 C6 40 10    	je _strlen_ret
0089++ 103B 79          	inc d
0090++ 103C 78          	inc c
0091++ 103D 0A 36 10    	jmp _strlen_L1
0092++ 1040             _strlen_ret:
0093++ 1040 E7          	pop d
0094++ 1041 09          	ret
0095++ 1042             
0096++ 1042             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1042             ; STRCMP
0098++ 1042             ; compare two strings
0099++ 1042             ; str1 in SI
0100++ 1042             ; str2 in DI
0101++ 1042             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1042             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1042             _strcmp:
0104++ 1042 DB          	push al
0105++ 1043 DA          	push d
0106++ 1044 E3          	push di
0107++ 1045 E2          	push si
0108++ 1046             _strcmp_loop:
0109++ 1046 F3          	cmpsb					; compare a byte of the strings
0110++ 1047 C7 52 10    	jne _strcmp_ret
0111++ 104A FB FF FF    	lea d, [si +- 1]
0112++ 104D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 104F C7 46 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1052             _strcmp_ret:
0115++ 1052 EF          	pop si
0116++ 1053 F0          	pop di
0117++ 1054 E7          	pop d
0118++ 1055 E8          	pop al
0119++ 1056 09          	ret
0120++ 1057             
0121++ 1057             
0122++ 1057             ; STRCPY
0123++ 1057             ; copy null terminated string from SI to DI
0124++ 1057             ; source in SI
0125++ 1057             ; destination in DI
0126++ 1057             _strcpy:
0127++ 1057 E2          	push si
0128++ 1058 E3          	push di
0129++ 1059 DB          	push al
0130++ 105A             _strcpy_L1:
0131++ 105A F6          	lodsb
0132++ 105B F7          	stosb
0133++ 105C B9 00       	cmp al, 0
0134++ 105E C7 5A 10    	jne _strcpy_L1
0135++ 1061             _strcpy_end:
0136++ 1061 E8          	pop al
0137++ 1062 F0          	pop di
0138++ 1063 EF          	pop si
0139++ 1064 09          	ret
0140++ 1065             
0141++ 1065             ; STRCAT
0142++ 1065             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1065             ; source in SI
0144++ 1065             ; destination in DI
0145++ 1065             _strcat:
0146++ 1065 E2          	push si
0147++ 1066 E3          	push di
0148++ 1067 D7          	push a
0149++ 1068 DA          	push d
0150++ 1069 50          	mov a, di
0151++ 106A 3C          	mov d, a
0152++ 106B             _strcat_goto_end_L1:
0153++ 106B BD 00       	cmp byte[d], 0
0154++ 106D C6 74 10    	je _strcat_start
0155++ 1070 79          	inc d
0156++ 1071 0A 6B 10    	jmp _strcat_goto_end_L1
0157++ 1074             _strcat_start:
0158++ 1074 FD 50       	mov di, d
0159++ 1076             _strcat_L1:
0160++ 1076 F6          	lodsb
0161++ 1077 F7          	stosb
0162++ 1078 B9 00       	cmp al, 0
0163++ 107A C7 76 10    	jne _strcat_L1
0164++ 107D             _strcat_end:
0165++ 107D E7          	pop d
0166++ 107E E4          	pop a
0167++ 107F F0          	pop di
0168++ 1080 EF          	pop si
0169++ 1081 09          	ret
0170++ 1082             
0171++ 1082             
0005+  1082             
0006+  1082             
0007+  1082             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1082             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  1082             ; ASCII in BL
0010+  1082             ; result in AL
0011+  1082             ; ascii for F = 0100 0110
0012+  1082             ; ascii for 9 = 0011 1001
0013+  1082             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1082             hex_ascii_encode:
0015+  1082 1B            mov al, bl
0016+  1083 93 40         test al, $40        ; test if letter or number
0017+  1085 C7 8B 10      jnz hex_letter
0018+  1088 87 0F         and al, $0F        ; get number
0019+  108A 09            ret
0020+  108B             hex_letter:
0021+  108B 87 0F         and al, $0F        ; get letter
0022+  108D 6A 09         add al, 9
0023+  108F 09            ret
0024+  1090             
0025+  1090             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1090             ; ATOI
0027+  1090             ; 2 letter hex string in B
0028+  1090             ; 8bit integer returned in AL
0029+  1090             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1090             _atoi:
0031+  1090 D8            push b
0032+  1091 07 82 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  1094 30            mov bl, bh
0034+  1095 DB            push al          ; save a
0035+  1096 07 82 10      call hex_ascii_encode
0036+  1099 EA            pop bl  
0037+  109A FD 9E 04      shl al, 4
0038+  109D 8C            or al, bl
0039+  109E E5            pop b
0040+  109F 09            ret  
0041+  10A0             
0042+  10A0             
0043+  10A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  10A0             ; scanf
0045+  10A0             ; no need for explanations!
0046+  10A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  10A0             scanf:
0048+  10A0 09            ret
0049+  10A1             
0050+  10A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  10A1             ; ITOA
0052+  10A1             ; 8bit value in BL
0053+  10A1             ; 2 byte ASCII result in A
0054+  10A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  10A1             _itoa:
0056+  10A1 DA            push d
0057+  10A2 D8            push b
0058+  10A3 A7 00         mov bh, 0
0059+  10A5 FD A4 04      shr bl, 4  
0060+  10A8 74            mov d, b
0061+  10A9 1F 51 13      mov al, [d + s_hex_digits]
0062+  10AC 23            mov ah, al
0063+  10AD               
0064+  10AD E5            pop b
0065+  10AE D8            push b
0066+  10AF A7 00         mov bh, 0
0067+  10B1 FD 87 0F      and bl, $0F
0068+  10B4 74            mov d, b
0069+  10B5 1F 51 13      mov al, [d + s_hex_digits]
0070+  10B8 E5            pop b
0071+  10B9 E7            pop d
0072+  10BA 09            ret
0073+  10BB             
0074+  10BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  10BB             ; HEX STRING TO BINARY
0076+  10BB             ; di = destination address
0077+  10BB             ; si = source
0078+  10BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  10BB             _hex_to_int:
0080+  10BB             _hex_to_int_L1:
0081+  10BB F6            lodsb          ; load from [SI] to AL
0082+  10BC B9 00         cmp al, 0        ; check if ASCII 0
0083+  10BE C6 CB 10      jz _hex_to_int_ret
0084+  10C1 36            mov bh, al
0085+  10C2 F6            lodsb
0086+  10C3 2F            mov bl, al
0087+  10C4 07 90 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  10C7 F7            stosb          ; store AL to [DI]
0089+  10C8 0A BB 10      jmp _hex_to_int_L1
0090+  10CB             _hex_to_int_ret:
0091+  10CB 09            ret    
0092+  10CC             
0093+  10CC             
0094+  10CC             
0095+  10CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  10CC             ; GETCHAR
0097+  10CC             ; char in ah
0098+  10CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  10CC             getch:
0100+  10CC DB            push al
0101+  10CD             getch_retry:
0102+  10CD 19 01         mov al, 1
0103+  10CF 05 03         syscall sys_io      ; receive in AH
0104+  10D1 E8            pop al
0105+  10D2 09            ret
0106+  10D3             
0107+  10D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  10D3             ; PUTCHAR
0109+  10D3             ; char in ah
0110+  10D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  10D3             _putchar:
0112+  10D3 D7            push a
0113+  10D4 19 00         mov al, 0
0114+  10D6 05 03         syscall sys_io      ; char in AH
0115+  10D8 E4            pop a
0116+  10D9 09            ret
0117+  10DA             
0118+  10DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  10DA             ;; INPUT A STRING
0120+  10DA             ;; terminates with null
0121+  10DA             ;; pointer in D
0122+  10DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  10DA             _gets:
0124+  10DA D7            push a
0125+  10DB DA            push d
0126+  10DC             _gets_loop:
0127+  10DC 19 01         mov al, 1
0128+  10DE 05 03         syscall sys_io      ; receive in AH
0129+  10E0 B9 00         cmp al, 0        ; check error code (AL)
0130+  10E2 C6 DC 10      je _gets_loop      ; if no char received, retry
0131+  10E5             
0132+  10E5 76 1B         cmp ah, 27
0133+  10E7 C6 08 11      je _gets_ansi_esc
0134+  10EA 76 0A         cmp ah, $0A        ; LF
0135+  10EC C6 73 11      je _gets_end
0136+  10EF 76 0D         cmp ah, $0D        ; CR
0137+  10F1 C6 73 11      je _gets_end
0138+  10F4 76 5C         cmp ah, $5C        ; '\\'
0139+  10F6 C6 34 11      je _gets_escape
0140+  10F9               
0141+  10F9 76 08         cmp ah, $08      ; check for backspace
0142+  10FB C6 04 11      je _gets_backspace
0143+  10FE             
0144+  10FE 1A            mov al, ah
0145+  10FF 3E            mov [d], al
0146+  1100 79            inc d
0147+  1101 0A DC 10      jmp _gets_loop
0148+  1104             _gets_backspace:
0149+  1104 7F            dec d
0150+  1105 0A DC 10      jmp _gets_loop
0151+  1108             _gets_ansi_esc:
0152+  1108 19 01         mov al, 1
0153+  110A 05 03         syscall sys_io        ; receive in AH without echo
0154+  110C B9 00         cmp al, 0          ; check error code (AL)
0155+  110E C6 08 11      je _gets_ansi_esc    ; if no char received, retry
0156+  1111 76 5B         cmp ah, '['
0157+  1113 C7 DC 10      jne _gets_loop
0158+  1116             _gets_ansi_esc_2:
0159+  1116 19 01         mov al, 1
0160+  1118 05 03         syscall sys_io          ; receive in AH without echo
0161+  111A B9 00         cmp al, 0            ; check error code (AL)
0162+  111C C6 16 11      je _gets_ansi_esc_2  ; if no char received, retry
0163+  111F 76 44         cmp ah, 'D'
0164+  1121 C6 2C 11      je _gets_left_arrow
0165+  1124 76 43         cmp ah, 'C'
0166+  1126 C6 30 11      je _gets_right_arrow
0167+  1129 0A DC 10      jmp _gets_loop
0168+  112C             _gets_left_arrow:
0169+  112C 7F            dec d
0170+  112D 0A DC 10      jmp _gets_loop
0171+  1130             _gets_right_arrow:
0172+  1130 79            inc d
0173+  1131 0A DC 10      jmp _gets_loop
0174+  1134             _gets_escape:
0175+  1134 19 01         mov al, 1
0176+  1136 05 03         syscall sys_io      ; receive in AH
0177+  1138 B9 00         cmp al, 0        ; check error code (AL)
0178+  113A C6 34 11      je _gets_escape      ; if no char received, retry
0179+  113D 76 6E         cmp ah, 'n'
0180+  113F C6 5E 11      je _gets_LF
0181+  1142 76 72         cmp ah, 'r'
0182+  1144 C6 65 11      je _gets_CR
0183+  1147 76 30         cmp ah, '0'
0184+  1149 C6 6C 11      je _gets_NULL
0185+  114C 76 5C         cmp ah, $5C  ; '\'
0186+  114E C6 57 11      je _gets_slash
0187+  1151 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  1152 3E            mov [d], al
0189+  1153 79            inc d
0190+  1154 0A DC 10      jmp _gets_loop
0191+  1157             _gets_slash:
0192+  1157 19 5C         mov al, $5C
0193+  1159 3E            mov [d], al
0194+  115A 79            inc d
0195+  115B 0A DC 10      jmp _gets_loop
0196+  115E             _gets_LF:
0197+  115E 19 0A         mov al, $0A
0198+  1160 3E            mov [d], al
0199+  1161 79            inc d
0200+  1162 0A DC 10      jmp _gets_loop
0201+  1165             _gets_CR:
0202+  1165 19 0D         mov al, $0D
0203+  1167 3E            mov [d], al
0204+  1168 79            inc d
0205+  1169 0A DC 10      jmp _gets_loop
0206+  116C             _gets_NULL:
0207+  116C 19 00         mov al, $00
0208+  116E 3E            mov [d], al
0209+  116F 79            inc d
0210+  1170 0A DC 10      jmp _gets_loop
0211+  1173             _gets_end:
0212+  1173 19 00         mov al, 0
0213+  1175 3E            mov [d], al        ; terminate string
0214+  1176 E7            pop d
0215+  1177 E4            pop a
0216+  1178 09            ret
0217+  1179             
0218+  1179             
0219+  1179             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  1179             ;; INPUT TEXT
0221+  1179             ;; terminated with CTRL+D
0222+  1179             ;; pointer in D
0223+  1179             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  1179             _gettxt:
0225+  1179 D7            push a
0226+  117A DA            push d
0227+  117B             _gettxt_loop:
0228+  117B 19 01         mov al, 1
0229+  117D 05 03         syscall sys_io      ; receive in AH
0230+  117F B9 00         cmp al, 0        ; check error code (AL)
0231+  1181 C6 7B 11      je _gettxt_loop    ; if no char received, retry
0232+  1184 76 04         cmp ah, 4      ; EOT
0233+  1186 C6 C4 11      je _gettxt_end
0234+  1189 76 08         cmp ah, $08      ; check for backspace
0235+  118B C6 C0 11      je _gettxt_backspace
0236+  118E 76 5C         cmp ah, $5C        ; '\'
0237+  1190 C6 99 11      je _gettxt_escape
0238+  1193 1A            mov al, ah
0239+  1194 3E            mov [d], al
0240+  1195 79            inc d
0241+  1196 0A 7B 11      jmp _gettxt_loop
0242+  1199             _gettxt_escape:
0243+  1199 19 01         mov al, 1
0244+  119B 05 03         syscall sys_io      ; receive in AH
0245+  119D B9 00         cmp al, 0        ; check error code (AL)
0246+  119F C6 99 11      je _gettxt_escape    ; if no char received, retry
0247+  11A2 76 6E         cmp ah, 'n'
0248+  11A4 C6 B2 11      je _gettxt_LF
0249+  11A7 76 72         cmp ah, 'r'
0250+  11A9 C6 B9 11      je _gettxt_CR
0251+  11AC 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  11AD 3E            mov [d], al
0253+  11AE 79            inc d
0254+  11AF 0A 7B 11      jmp _gettxt_loop
0255+  11B2             _gettxt_LF:
0256+  11B2 19 0A         mov al, $0A
0257+  11B4 3E            mov [d], al
0258+  11B5 79            inc d
0259+  11B6 0A 7B 11      jmp _gettxt_loop
0260+  11B9             _gettxt_CR:
0261+  11B9 19 0D         mov al, $0D
0262+  11BB 3E            mov [d], al
0263+  11BC 79            inc d
0264+  11BD 0A 7B 11      jmp _gettxt_loop
0265+  11C0             _gettxt_backspace:
0266+  11C0 7F            dec d
0267+  11C1 0A 7B 11      jmp _gettxt_loop
0268+  11C4             _gettxt_end:
0269+  11C4 19 00         mov al, 0
0270+  11C6 3E            mov [d], al        ; terminate string
0271+  11C7 E7            pop d
0272+  11C8 E4            pop a
0273+  11C9 09            ret
0274+  11CA             
0275+  11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  11CA             ; PRINT NEW LINE
0277+  11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  11CA             printnl:
0279+  11CA D7            push a
0280+  11CB 10 00 0A      mov a, $0A00
0281+  11CE 05 03         syscall sys_io
0282+  11D0 10 00 0D      mov a, $0D00
0283+  11D3 05 03         syscall sys_io
0284+  11D5 E4            pop a
0285+  11D6 09            ret
0286+  11D7             
0287+  11D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  11D7             ; _strtoint
0289+  11D7             ; 4 digit hex string number in d
0290+  11D7             ; integer returned in A
0291+  11D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  11D7             _strtointx:
0293+  11D7 D8            push b
0294+  11D8 32            mov bl, [d]
0295+  11D9 37            mov bh, bl
0296+  11DA 33 01 00      mov bl, [d + 1]
0297+  11DD 07 90 10      call _atoi        ; convert to int in AL
0298+  11E0 23            mov ah, al        ; move to AH
0299+  11E1 33 02 00      mov bl, [d + 2]
0300+  11E4 37            mov bh, bl
0301+  11E5 33 03 00      mov bl, [d + 3]
0302+  11E8 07 90 10      call _atoi        ; convert to int in AL
0303+  11EB E5            pop b
0304+  11EC 09            ret
0305+  11ED             
0306+  11ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  11ED             ; _strtoint
0308+  11ED             ; 5 digit base10 string number in d
0309+  11ED             ; integer returned in A
0310+  11ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  11ED             _strtoint:
0312+  11ED E2            push si
0313+  11EE D8            push b
0314+  11EF D9            push c
0315+  11F0 DA            push d
0316+  11F1 07 32 10      call _strlen      ; get string length in C
0317+  11F4 7E            dec c
0318+  11F5 FD 4E         mov si, d
0319+  11F7 12            mov a, c
0320+  11F8 FD 99         shl a
0321+  11FA 3B 69 13      mov d, table_power
0322+  11FD 59            add d, a
0323+  11FE 38 00 00      mov c, 0
0324+  1201             _strtoint_L0:
0325+  1201 F6            lodsb      ; load ASCII to al
0326+  1202 B9 00         cmp al, 0
0327+  1204 C6 17 12      je _strtoint_end
0328+  1207 6F 30         sub al, $30    ; make into integer
0329+  1209 22 00         mov ah, 0
0330+  120B 2A            mov b, [d]
0331+  120C AC            mul a, b      ; result in B since it fits in 16bits
0332+  120D 11            mov a, b
0333+  120E 28            mov b, c
0334+  120F 54            add a, b
0335+  1210 39            mov c, a
0336+  1211 63 02 00      sub d, 2
0337+  1214 0A 01 12      jmp _strtoint_L0
0338+  1217             _strtoint_end:
0339+  1217 12            mov a, c
0340+  1218 E7            pop d
0341+  1219 E6            pop c
0342+  121A E5            pop b
0343+  121B EF            pop si
0344+  121C 09            ret
0345+  121D             
0346+  121D             
0347+  121D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  121D             ; PRINT NULL TERMINATED STRING
0349+  121D             ; pointer in D
0350+  121D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  121D             _puts:
0352+  121D D7            push a
0353+  121E DA            push d
0354+  121F             _puts_L1:
0355+  121F 1E            mov al, [d]
0356+  1220 B9 00         cmp al, 0
0357+  1222 C6 2E 12      jz _puts_END
0358+  1225 23            mov ah, al
0359+  1226 19 00         mov al, 0
0360+  1228 05 03         syscall sys_io
0361+  122A 79            inc d
0362+  122B 0A 1F 12      jmp _puts_L1
0363+  122E             _puts_END:
0364+  122E E7            pop d
0365+  122F E4            pop a
0366+  1230 09            ret
0367+  1231             
0368+  1231             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  1231             ; PRINT N SIZE STRING
0370+  1231             ; pointer in D
0371+  1231             ; size in C
0372+  1231             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  1231             _putsn:
0374+  1231 DB            push al
0375+  1232 DA            push d
0376+  1233 D9            push c
0377+  1234             _putsn_L0:
0378+  1234 1E            mov al, [d]
0379+  1235 23            mov ah, al
0380+  1236 19 00         mov al, 0
0381+  1238 05 03         syscall sys_io
0382+  123A 79            inc d
0383+  123B 7E            dec c  
0384+  123C C2 00 00      cmp c, 0
0385+  123F C7 34 12      jne _putsn_L0
0386+  1242             _putsn_end:
0387+  1242 E6            pop c
0388+  1243 E7            pop d
0389+  1244 E8            pop al
0390+  1245 09            ret
0391+  1246             
0392+  1246             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1246             ; print 16bit decimal number
0394+  1246             ; input number in A
0395+  1246             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1246             print_u16d:
0397+  1246 D7            push a
0398+  1247 D8            push b
0399+  1248 26 10 27      mov b, 10000
0400+  124B AE            div a, b      ; get 10000's coeff.
0401+  124C 07 6E 12      call print_number
0402+  124F 11            mov a, b
0403+  1250 26 E8 03      mov b, 1000
0404+  1253 AE            div a, b      ; get 1000's coeff.
0405+  1254 07 6E 12      call print_number
0406+  1257 11            mov a, b
0407+  1258 26 64 00      mov b, 100
0408+  125B AE            div a, b
0409+  125C 07 6E 12      call print_number
0410+  125F 11            mov a, b
0411+  1260 26 0A 00      mov b, 10
0412+  1263 AE            div a, b
0413+  1264 07 6E 12      call print_number
0414+  1267 1B            mov al, bl      ; 1's coeff in bl
0415+  1268 07 6E 12      call print_number
0416+  126B E5            pop b
0417+  126C E4            pop a
0418+  126D 09            ret
0419+  126E             
0420+  126E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  126E             ; print AL
0422+  126E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  126E             print_number:
0424+  126E 6A 30         add al, $30
0425+  1270 23            mov ah, al
0426+  1271 07 D3 10      call _putchar
0427+  1274 09            ret
0428+  1275             
0429+  1275             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1275             ; PRINT 16BIT HEX INTEGER
0431+  1275             ; integer value in reg B
0432+  1275             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1275             print_u16x:
0434+  1275 D7            push a
0435+  1276 D8            push b
0436+  1277 DD            push bl
0437+  1278 30            mov bl, bh
0438+  1279 07 A1 10      call _itoa        ; convert bh to char in A
0439+  127C 2F            mov bl, al        ; save al
0440+  127D 19 00         mov al, 0
0441+  127F 05 03         syscall sys_io        ; display AH
0442+  1281 24            mov ah, bl        ; retrieve al
0443+  1282 19 00         mov al, 0
0444+  1284 05 03         syscall sys_io        ; display AL
0445+  1286             
0446+  1286 EA            pop bl
0447+  1287 07 A1 10      call _itoa        ; convert bh to char in A
0448+  128A 2F            mov bl, al        ; save al
0449+  128B 19 00         mov al, 0
0450+  128D 05 03         syscall sys_io        ; display AH
0451+  128F 24            mov ah, bl        ; retrieve al
0452+  1290 19 00         mov al, 0
0453+  1292 05 03         syscall sys_io        ; display AL
0454+  1294             
0455+  1294 E5            pop b
0456+  1295 E4            pop a
0457+  1296 09            ret
0458+  1297             
0459+  1297             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  1297             ; INPUT 16BIT HEX INTEGER
0461+  1297             ; read 16bit integer into A
0462+  1297             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  1297             scan_u16x:
0464+  1297 F8 10 00      enter 16
0465+  129A D8            push b
0466+  129B DA            push d
0467+  129C             
0468+  129C FA F1 FF      lea d, [bp + -15]
0469+  129F 07 DA 10      call _gets        ; get number
0470+  12A2             
0471+  12A2 32            mov bl, [d]
0472+  12A3 37            mov bh, bl
0473+  12A4 33 01 00      mov bl, [d + 1]
0474+  12A7 07 90 10      call _atoi        ; convert to int in AL
0475+  12AA 23            mov ah, al        ; move to AH
0476+  12AB             
0477+  12AB 33 02 00      mov bl, [d + 2]
0478+  12AE 37            mov bh, bl
0479+  12AF 33 03 00      mov bl, [d + 3]
0480+  12B2 07 90 10      call _atoi        ; convert to int in AL
0481+  12B5             
0482+  12B5 E7            pop d
0483+  12B6 E5            pop b
0484+  12B7 F9            leave
0485+  12B8 09            ret
0486+  12B9             
0487+  12B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  12B9             ; PRINT 8bit HEX INTEGER
0489+  12B9             ; integer value in reg bl
0490+  12B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  12B9             print_u8x:
0492+  12B9 D7            push a
0493+  12BA DD            push bl
0494+  12BB             
0495+  12BB 07 A1 10      call _itoa        ; convert bl to char in A
0496+  12BE 2F            mov bl, al        ; save al
0497+  12BF 19 00         mov al, 0
0498+  12C1 05 03         syscall sys_io        ; display AH
0499+  12C3 24            mov ah, bl        ; retrieve al
0500+  12C4 19 00         mov al, 0
0501+  12C6 05 03         syscall sys_io        ; display AL
0502+  12C8             
0503+  12C8 EA            pop bl
0504+  12C9 E4            pop a
0505+  12CA 09            ret
0506+  12CB             
0507+  12CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  12CB             ; print 8bit decimal unsigned number
0509+  12CB             ; input number in AL
0510+  12CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  12CB             print_u8d:
0512+  12CB D7            push a
0513+  12CC D8            push b
0514+  12CD             
0515+  12CD 22 00         mov ah, 0
0516+  12CF 26 64 00      mov b, 100
0517+  12D2 AE            div a, b
0518+  12D3 D8            push b      ; save remainder
0519+  12D4 B9 00         cmp al, 0
0520+  12D6 C6 E0 12      je skip100
0521+  12D9 6A 30         add al, $30
0522+  12DB 23            mov ah, al
0523+  12DC 19 00         mov al, 0
0524+  12DE 05 03         syscall sys_io  ; print coeff
0525+  12E0             skip100:
0526+  12E0 E4            pop a
0527+  12E1 22 00         mov ah, 0
0528+  12E3 26 0A 00      mov b, 10
0529+  12E6 AE            div a, b
0530+  12E7 D8            push b      ; save remainder
0531+  12E8 B9 00         cmp al, 0
0532+  12EA C6 F4 12      je skip10
0533+  12ED 6A 30         add al, $30
0534+  12EF 23            mov ah, al
0535+  12F0 19 00         mov al, 0
0536+  12F2 05 03         syscall sys_io  ; print coeff
0537+  12F4             skip10:
0538+  12F4 E4            pop a
0539+  12F5 1B            mov al, bl
0540+  12F6 6A 30         add al, $30
0541+  12F8 23            mov ah, al
0542+  12F9 19 00         mov al, 0
0543+  12FB 05 03         syscall sys_io  ; print coeff
0544+  12FD E5            pop b
0545+  12FE E4            pop a
0546+  12FF 09            ret
0547+  1300             
0548+  1300             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  1300             ; INPUT 8BIT HEX INTEGER
0550+  1300             ; read 8bit integer into AL
0551+  1300             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  1300             scan_u8x:
0553+  1300 F8 04 00      enter 4
0554+  1303 D8            push b
0555+  1304 DA            push d
0556+  1305             
0557+  1305 FA FD FF      lea d, [bp + -3]
0558+  1308 07 DA 10      call _gets        ; get number
0559+  130B             
0560+  130B 32            mov bl, [d]
0561+  130C 37            mov bh, bl
0562+  130D 33 01 00      mov bl, [d + 1]
0563+  1310 07 90 10      call _atoi        ; convert to int in AL
0564+  1313             
0565+  1313 E7            pop d
0566+  1314 E5            pop b
0567+  1315 F9            leave
0568+  1316 09            ret
0569+  1317             
0570+  1317             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  1317             ; input decimal number
0572+  1317             ; result in A
0573+  1317             ; 655'\0'
0574+  1317             ; low--------high
0575+  1317             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  1317             scan_u16d:
0577+  1317 F8 08 00      enter 8
0578+  131A E2            push si
0579+  131B D8            push b
0580+  131C D9            push c
0581+  131D DA            push d
0582+  131E FA F9 FF      lea d, [bp +- 7]
0583+  1321 07 DA 10      call _gets
0584+  1324 07 32 10      call _strlen      ; get string length in C
0585+  1327 7E            dec c
0586+  1328 FD 4E         mov si, d
0587+  132A 12            mov a, c
0588+  132B FD 99         shl a
0589+  132D 3B 69 13      mov d, table_power
0590+  1330 59            add d, a
0591+  1331 38 00 00      mov c, 0
0592+  1334             mul_loop:
0593+  1334 F6            lodsb      ; load ASCII to al
0594+  1335 B9 00         cmp al, 0
0595+  1337 C6 4A 13      je mul_exit
0596+  133A 6F 30         sub al, $30    ; make into integer
0597+  133C 22 00         mov ah, 0
0598+  133E 2A            mov b, [d]
0599+  133F AC            mul a, b      ; result in B since it fits in 16bits
0600+  1340 11            mov a, b
0601+  1341 28            mov b, c
0602+  1342 54            add a, b
0603+  1343 39            mov c, a
0604+  1344 63 02 00      sub d, 2
0605+  1347 0A 34 13      jmp mul_loop
0606+  134A             mul_exit:
0607+  134A 12            mov a, c
0608+  134B E7            pop d
0609+  134C E6            pop c
0610+  134D E5            pop b
0611+  134E EF            pop si
0612+  134F F9            leave
0613+  1350 09            ret
0614+  1351             
0615+  1351             
0616+  1351 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1355 34 35 36 37 
0616+  1359 38 39 41 42 
0616+  135D 43 44 45 46 
0617+  1361 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1365 1B 5B 48 00 
0618+  1369             
0619+  1369             table_power:
0620+  1369 01 00         .dw 1
0621+  136B 0A 00         .dw 10
0622+  136D 64 00         .dw 100
0623+  136F E8 03         .dw 1000
0624+  1371 10 27         .dw 100002183   1373             ; --- END INLINE ASM BLOCK
2184   1373             
2185   1373 F9            leave
2186   1374 09            ret
2187   1375             
2188   1375             gcd:
2189   1375 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2190   1378             ;; if (b == 0) { 
2191   1378             _if25_cond:
2192   1378 FA 07 00      lea d, [bp + 7] ; $b
2193   137B 2A            mov b, [d]
2194   137C             ; START RELATIONAL
2195   137C D7            push a
2196   137D 11            mov a, b
2197   137E 26 00 00      mov b, $0
2198   1381 B0            cmp a, b
2199   1382 FD 71         seq ; ==
2200   1384 E4            pop a
2201   1385             ; END RELATIONAL
2202   1385 C0 00 00      cmp b, 0
2203   1388 C6 94 13      je _if25_exit
2204   138B             _if25_true:
2205   138B             ;; return a; 
2206   138B FA 05 00      lea d, [bp + 5] ; $a
2207   138E 2A            mov b, [d]
2208   138F F9            leave
2209   1390 09            ret
2210   1391 0A 94 13      jmp _if25_exit
2211   1394             _if25_exit:
2212   1394             ;; return gcd(b, a % b); 
2213   1394 FA 05 00      lea d, [bp + 5] ; $a
2214   1397 2A            mov b, [d]
2215   1398             ; START FACTORS
2216   1398 D7            push a
2217   1399 11            mov a, b
2218   139A FA 07 00      lea d, [bp + 7] ; $b
2219   139D 2A            mov b, [d]
2220   139E AE            div a, b ; 
2221   139F 11            mov a, b
2222   13A0 27            mov b, a
2223   13A1 E4            pop a
2224   13A2             ; END FACTORS
2225   13A2 FD AB         swp b
2226   13A4 D8            push b
2227   13A5 FA 07 00      lea d, [bp + 7] ; $b
2228   13A8 2A            mov b, [d]
2229   13A9 FD AB         swp b
2230   13AB D8            push b
2231   13AC 07 75 13      call gcd
2232   13AF 51 04 00      add sp, 4
2233   13B2 F9            leave
2234   13B3 09            ret
2235   13B4             
2236   13B4             mod_exp:
2237   13B4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2238   13B7             ; $result 
2239   13B7 52 02 00      sub sp, 2
2240   13BA             ;; result = 1; 
2241   13BA FA FF FF      lea d, [bp + -1] ; $result
2242   13BD DA            push d
2243   13BE 26 01 00      mov b, $1
2244   13C1 E7            pop d
2245   13C2 FD 43         mov [d], b
2246   13C4             ;; while (exp > 0) { 
2247   13C4             _while26_cond:
2248   13C4 FA 07 00      lea d, [bp + 7] ; $exp
2249   13C7 2A            mov b, [d]
2250   13C8             ; START RELATIONAL
2251   13C8 D7            push a
2252   13C9 11            mov a, b
2253   13CA 26 00 00      mov b, $0
2254   13CD B0            cmp a, b
2255   13CE FD 7F         sgt ; >
2256   13D0 E4            pop a
2257   13D1             ; END RELATIONAL
2258   13D1 C0 00 00      cmp b, 0
2259   13D4 C6 42 14      je _while26_exit
2260   13D7             _while26_block:
2261   13D7             ;; if (exp & 1) { 
2262   13D7             _if27_cond:
2263   13D7 FA 07 00      lea d, [bp + 7] ; $exp
2264   13DA 2A            mov b, [d]
2265   13DB D7            push a
2266   13DC 11            mov a, b
2267   13DD 26 01 00      mov b, $1
2268   13E0 86            and a, b ; &
2269   13E1 27            mov b, a
2270   13E2 E4            pop a
2271   13E3 C0 00 00      cmp b, 0
2272   13E6 C6 0B 14      je _if27_exit
2273   13E9             _if27_true:
2274   13E9             ;; result = (result * base) % mod; 
2275   13E9 FA FF FF      lea d, [bp + -1] ; $result
2276   13EC DA            push d
2277   13ED FA FF FF      lea d, [bp + -1] ; $result
2278   13F0 2A            mov b, [d]
2279   13F1             ; START FACTORS
2280   13F1 D7            push a
2281   13F2 11            mov a, b
2282   13F3 FA 05 00      lea d, [bp + 5] ; $base
2283   13F6 2A            mov b, [d]
2284   13F7 AC            mul a, b ; *
2285   13F8 11            mov a, b
2286   13F9 27            mov b, a
2287   13FA E4            pop a
2288   13FB             ; END FACTORS
2289   13FB             ; START FACTORS
2290   13FB D7            push a
2291   13FC 11            mov a, b
2292   13FD FA 09 00      lea d, [bp + 9] ; $mod
2293   1400 2A            mov b, [d]
2294   1401 AE            div a, b ; 
2295   1402 11            mov a, b
2296   1403 27            mov b, a
2297   1404 E4            pop a
2298   1405             ; END FACTORS
2299   1405 E7            pop d
2300   1406 FD 43         mov [d], b
2301   1408 0A 0B 14      jmp _if27_exit
2302   140B             _if27_exit:
2303   140B             ;; exp = exp >> 1; 
2304   140B FA 07 00      lea d, [bp + 7] ; $exp
2305   140E DA            push d
2306   140F FA 07 00      lea d, [bp + 7] ; $exp
2307   1412 2A            mov b, [d]
2308   1413             ; START SHIFT
2309   1413 D7            push a
2310   1414 11            mov a, b
2311   1415 26 01 00      mov b, $1
2312   1418 FD 39         mov c, b
2313   141A A5            ashr a, cl
2314   141B 27            mov b, a
2315   141C E4            pop a
2316   141D             ; END SHIFT
2317   141D E7            pop d
2318   141E FD 43         mov [d], b
2319   1420             ;; base = (base * base) % mod; 
2320   1420 FA 05 00      lea d, [bp + 5] ; $base
2321   1423 DA            push d
2322   1424 FA 05 00      lea d, [bp + 5] ; $base
2323   1427 2A            mov b, [d]
2324   1428             ; START FACTORS
2325   1428 D7            push a
2326   1429 11            mov a, b
2327   142A FA 05 00      lea d, [bp + 5] ; $base
2328   142D 2A            mov b, [d]
2329   142E AC            mul a, b ; *
2330   142F 11            mov a, b
2331   1430 27            mov b, a
2332   1431 E4            pop a
2333   1432             ; END FACTORS
2334   1432             ; START FACTORS
2335   1432 D7            push a
2336   1433 11            mov a, b
2337   1434 FA 09 00      lea d, [bp + 9] ; $mod
2338   1437 2A            mov b, [d]
2339   1438 AE            div a, b ; 
2340   1439 11            mov a, b
2341   143A 27            mov b, a
2342   143B E4            pop a
2343   143C             ; END FACTORS
2344   143C E7            pop d
2345   143D FD 43         mov [d], b
2346   143F 0A C4 13      jmp _while26_cond
2347   1442             _while26_exit:
2348   1442             ;; return result; 
2349   1442 FA FF FF      lea d, [bp + -1] ; $result
2350   1445 2A            mov b, [d]
2351   1446 F9            leave
2352   1447 09            ret
2353   1448             
2354   1448             find_e:
2355   1448 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2356   144B             ; $e 
2357   144B 52 02 00      sub sp, 2
2358   144E             ;; for (e = 2; e < phi; e++) { 
2359   144E             _for28_init:
2360   144E FA FF FF      lea d, [bp + -1] ; $e
2361   1451 DA            push d
2362   1452 26 02 00      mov b, $2
2363   1455 E7            pop d
2364   1456 FD 43         mov [d], b
2365   1458             _for28_cond:
2366   1458 FA FF FF      lea d, [bp + -1] ; $e
2367   145B 2A            mov b, [d]
2368   145C             ; START RELATIONAL
2369   145C D7            push a
2370   145D 11            mov a, b
2371   145E FA 05 00      lea d, [bp + 5] ; $phi
2372   1461 2A            mov b, [d]
2373   1462 B0            cmp a, b
2374   1463 FD 73         slt ; < 
2375   1465 E4            pop a
2376   1466             ; END RELATIONAL
2377   1466 C0 00 00      cmp b, 0
2378   1469 C6 AA 14      je _for28_exit
2379   146C             _for28_block:
2380   146C             ;; if (gcd(e, phi) == 1) { 
2381   146C             _if29_cond:
2382   146C FA 05 00      lea d, [bp + 5] ; $phi
2383   146F 2A            mov b, [d]
2384   1470 FD AB         swp b
2385   1472 D8            push b
2386   1473 FA FF FF      lea d, [bp + -1] ; $e
2387   1476 2A            mov b, [d]
2388   1477 FD AB         swp b
2389   1479 D8            push b
2390   147A 07 75 13      call gcd
2391   147D 51 04 00      add sp, 4
2392   1480             ; START RELATIONAL
2393   1480 D7            push a
2394   1481 11            mov a, b
2395   1482 26 01 00      mov b, $1
2396   1485 B0            cmp a, b
2397   1486 FD 71         seq ; ==
2398   1488 E4            pop a
2399   1489             ; END RELATIONAL
2400   1489 C0 00 00      cmp b, 0
2401   148C C6 98 14      je _if29_exit
2402   148F             _if29_true:
2403   148F             ;; return e; 
2404   148F FA FF FF      lea d, [bp + -1] ; $e
2405   1492 2A            mov b, [d]
2406   1493 F9            leave
2407   1494 09            ret
2408   1495 0A 98 14      jmp _if29_exit
2409   1498             _if29_exit:
2410   1498             _for28_update:
2411   1498 FA FF FF      lea d, [bp + -1] ; $e
2412   149B 2A            mov b, [d]
2413   149C FD 79         mov g, b
2414   149E FD 77         inc b
2415   14A0 FA FF FF      lea d, [bp + -1] ; $e
2416   14A3 FD 43         mov [d], b
2417   14A5 FD 27         mov b, g
2418   14A7 0A 58 14      jmp _for28_cond
2419   14AA             _for28_exit:
2420   14AA             ;; return 0; 
2421   14AA 26 00 00      mov b, $0
2422   14AD F9            leave
2423   14AE 09            ret
2424   14AF             
2425   14AF             find_d:
2426   14AF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2427   14B2             ; $d 
2428   14B2 52 02 00      sub sp, 2
2429   14B5             ;; for (d = 2; d < phi; d++) { 
2430   14B5             _for30_init:
2431   14B5 FA FF FF      lea d, [bp + -1] ; $d
2432   14B8 DA            push d
2433   14B9 26 02 00      mov b, $2
2434   14BC E7            pop d
2435   14BD FD 43         mov [d], b
2436   14BF             _for30_cond:
2437   14BF FA FF FF      lea d, [bp + -1] ; $d
2438   14C2 2A            mov b, [d]
2439   14C3             ; START RELATIONAL
2440   14C3 D7            push a
2441   14C4 11            mov a, b
2442   14C5 FA 07 00      lea d, [bp + 7] ; $phi
2443   14C8 2A            mov b, [d]
2444   14C9 B0            cmp a, b
2445   14CA FD 73         slt ; < 
2446   14CC E4            pop a
2447   14CD             ; END RELATIONAL
2448   14CD C0 00 00      cmp b, 0
2449   14D0 C6 15 15      je _for30_exit
2450   14D3             _for30_block:
2451   14D3             ;; if ((d * e) % phi == 1) { 
2452   14D3             _if31_cond:
2453   14D3 FA FF FF      lea d, [bp + -1] ; $d
2454   14D6 2A            mov b, [d]
2455   14D7             ; START FACTORS
2456   14D7 D7            push a
2457   14D8 11            mov a, b
2458   14D9 FA 05 00      lea d, [bp + 5] ; $e
2459   14DC 2A            mov b, [d]
2460   14DD AC            mul a, b ; *
2461   14DE 11            mov a, b
2462   14DF 27            mov b, a
2463   14E0 E4            pop a
2464   14E1             ; END FACTORS
2465   14E1             ; START FACTORS
2466   14E1 D7            push a
2467   14E2 11            mov a, b
2468   14E3 FA 07 00      lea d, [bp + 7] ; $phi
2469   14E6 2A            mov b, [d]
2470   14E7 AE            div a, b ; 
2471   14E8 11            mov a, b
2472   14E9 27            mov b, a
2473   14EA E4            pop a
2474   14EB             ; END FACTORS
2475   14EB             ; START RELATIONAL
2476   14EB D7            push a
2477   14EC 11            mov a, b
2478   14ED 26 01 00      mov b, $1
2479   14F0 B0            cmp a, b
2480   14F1 FD 71         seq ; ==
2481   14F3 E4            pop a
2482   14F4             ; END RELATIONAL
2483   14F4 C0 00 00      cmp b, 0
2484   14F7 C6 03 15      je _if31_exit
2485   14FA             _if31_true:
2486   14FA             ;; return d; 
2487   14FA FA FF FF      lea d, [bp + -1] ; $d
2488   14FD 2A            mov b, [d]
2489   14FE F9            leave
2490   14FF 09            ret
2491   1500 0A 03 15      jmp _if31_exit
2492   1503             _if31_exit:
2493   1503             _for30_update:
2494   1503 FA FF FF      lea d, [bp + -1] ; $d
2495   1506 2A            mov b, [d]
2496   1507 FD 79         mov g, b
2497   1509 FD 77         inc b
2498   150B FA FF FF      lea d, [bp + -1] ; $d
2499   150E FD 43         mov [d], b
2500   1510 FD 27         mov b, g
2501   1512 0A BF 14      jmp _for30_cond
2502   1515             _for30_exit:
2503   1515             ;; return 0; 
2504   1515 26 00 00      mov b, $0
2505   1518 F9            leave
2506   1519 09            ret
2507   151A             ; --- END TEXT BLOCK
2508   151A             
2509   151A             ; --- BEGIN DATA BLOCK
2510   151A 50 75 62 6C __s0: .db "Public Key: (", 0
2510   151E 69 63 20 4B 
2510   1522 65 79 3A 20 
2510   1526 28 00 
2511   1528 2C 20 00    __s1: .db ", ", 0
2512   152B 29 0A 00    __s2: .db ")\n", 0
2513   152E 50 72 69 76 __s3: .db "Private Key: (", 0
2513   1532 61 74 65 20 
2513   1536 4B 65 79 3A 
2513   153A 20 28 00 
2514   153D 45 6E 74 65 __s4: .db "Enter a string: ", 0
2514   1541 72 20 61 20 
2514   1545 73 74 72 69 
2514   1549 6E 67 3A 20 
2514   154D 00 
2515   154E 45 6E 63 72 __s5: .db "Encrypted text: ", 0
2515   1552 79 70 74 65 
2515   1556 64 20 74 65 
2515   155A 78 74 3A 20 
2515   155E 00 
2516   155F 20 00       __s6: .db " ", 0
2517   1561 0A 00       __s7: .db "\n", 0
2518   1563 44 65 63 72 __s8: .db "Decrypted text: ", 0
2518   1567 79 70 74 65 
2518   156B 64 20 74 65 
2518   156F 78 74 3A 20 
2518   1573 00 
2519   1574 45 72 72 6F __s9: .db "Error: Unknown argument type.\n", 0
2519   1578 72 3A 20 55 
2519   157C 6E 6B 6E 6F 
2519   1580 77 6E 20 61 
2519   1584 72 67 75 6D 
2519   1588 65 6E 74 20 
2519   158C 74 79 70 65 
2519   1590 2E 0A 00 
2520   1593 1B 5B 32 4A __s10: .db "\033[2J\033[H", 0
2520   1597 1B 5B 48 00 
2521   159B             
2522   159B 9D 15       _heap_top: .dw _heap
2523   159D 00          _heap: .db 0
2524   159E             ; --- END DATA BLOCK
2525   159E             
2526   159E             .end
tasm: Number of errors = 0
