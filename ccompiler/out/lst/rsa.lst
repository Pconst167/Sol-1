0001   0000             ; --- FILENAME: programs/rsa.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; int p, q, n, phi, e, d; 
0011   0408 52 02 00      sub sp, 2
0012   040B 52 02 00      sub sp, 2
0013   040E 52 02 00      sub sp, 2
0014   0411 52 02 00      sub sp, 2
0015   0414 52 02 00      sub sp, 2
0016   0417 52 02 00      sub sp, 2
0017   041A             ; int i; 
0018   041A 52 02 00      sub sp, 2
0019   041D             ; char input_str[100]; 
0020   041D 52 64 00      sub sp, 100
0021   0420             ; int encrypted_chars[100]; 
0022   0420 52 C8 00      sub sp, 200
0023   0423             ; int encrypted_chars_len ; 
0024   0423 52 02 00      sub sp, 2
0025   0426             ; int decrypted_char; 
0026   0426 52 02 00      sub sp, 2
0027   0429             ; char c; 
0028   0429 52 01 00      sub sp, 1
0029   042C             ; p = 13; 
0030   042C FA FF FF      lea d, [bp + -1] ; $p
0031   042F DA            push d
0032   0430 FD 2E 0D 00   mov32 cb, $0000000d
0032   0434 00 00 
0033   0436 E7            pop d
0034   0437 FD 43         mov [d], b
0035   0439             ; q = 11; 
0036   0439 FA FD FF      lea d, [bp + -3] ; $q
0037   043C DA            push d
0038   043D FD 2E 0B 00   mov32 cb, $0000000b
0038   0441 00 00 
0039   0443 E7            pop d
0040   0444 FD 43         mov [d], b
0041   0446             ; n = p * q; 
0042   0446 FA FB FF      lea d, [bp + -5] ; $n
0043   0449 DA            push d
0044   044A FA FF FF      lea d, [bp + -1] ; $p
0045   044D 2A            mov b, [d]
0046   044E 38 00 00      mov c, 0
0047   0451             ; --- START FACTORS
0048   0451 D7            push a
0049   0452 FD D8         push g
0050   0454 11            mov a, b
0051   0455 FD 7A         mov g, c
0052   0457 FA FD FF      lea d, [bp + -3] ; $q
0053   045A 2A            mov b, [d]
0054   045B 38 00 00      mov c, 0
0055   045E D7            push a     ; save left operand
0056   045F 8E            xor a, b   ; xor sign bits
0057   0460 FD AA         swp a      ; swap bytes
0058   0462 83            mov cl, al ; save result of xor into 'dl'
0059   0463 E4            pop a      ; restore left side operator
0060   0464 DF            push cl    ; save result of xor above
0061   0465 FD AA         swp a  
0062   0467 93 80         test al, $80  
0063   0469 FD AA         swp a  
0064   046B C6 70 04      jz skip_invert_a_2  
0065   046E FD 95          neg a 
0066   0470             skip_invert_a_2:   
0067   0470 FD AB         swp b
0068   0472 FD 93 80      test bl, $80  
0069   0475 FD AB         swp b
0070   0477 C6 7C 04      jz skip_invert_b_2  
0071   047A FD 97          neg b 
0072   047C             skip_invert_b_2:   
0073   047C AC            mul a, b ; *
0074   047D FD 78         mov g, a
0075   047F 11            mov a, b
0076   0480 EA            pop bl
0077   0481 FD 93 80      test bl, $80
0078   0484 C6 96 04      jz _same_signs_2
0079   0487 27            mov b, a
0080   0488 FD 12         mov a, g
0081   048A 95            not a
0082   048B 97            not b
0083   048C 55 01 00      add b, 1
0084   048F 5B 00 00      adc a, 0
0085   0492 39            mov c, a
0086   0493 FD 7A         mov g, c
0087   0495 11            mov a, b
0088   0496             _same_signs_2:
0089   0496 FD 38         mov c, g
0090   0498 27            mov b, a
0091   0499 FD F1         pop g
0092   049B E4            pop a
0093   049C             ; --- END FACTORS
0094   049C E7            pop d
0095   049D FD 43         mov [d], b
0096   049F             ; phi = (p - 1) * (q - 1); 
0097   049F FA F9 FF      lea d, [bp + -7] ; $phi
0098   04A2 DA            push d
0099   04A3 FA FF FF      lea d, [bp + -1] ; $p
0100   04A6 2A            mov b, [d]
0101   04A7 38 00 00      mov c, 0
0102   04AA             ; --- START TERMS
0103   04AA D7            push a
0104   04AB 11            mov a, b
0105   04AC FD 2E 01 00   mov32 cb, $00000001
0105   04B0 00 00 
0106   04B2 60            sub a, b
0107   04B3 27            mov b, a
0108   04B4 E4            pop a
0109   04B5             ; --- END TERMS
0110   04B5             ; --- START FACTORS
0111   04B5 D7            push a
0112   04B6 FD D8         push g
0113   04B8 11            mov a, b
0114   04B9 FD 7A         mov g, c
0115   04BB FA FD FF      lea d, [bp + -3] ; $q
0116   04BE 2A            mov b, [d]
0117   04BF 38 00 00      mov c, 0
0118   04C2             ; --- START TERMS
0119   04C2 D7            push a
0120   04C3 11            mov a, b
0121   04C4 FD 2E 01 00   mov32 cb, $00000001
0121   04C8 00 00 
0122   04CA 60            sub a, b
0123   04CB 27            mov b, a
0124   04CC E4            pop a
0125   04CD             ; --- END TERMS
0126   04CD D7            push a     ; save left operand
0127   04CE 8E            xor a, b   ; xor sign bits
0128   04CF FD AA         swp a      ; swap bytes
0129   04D1 83            mov cl, al ; save result of xor into 'dl'
0130   04D2 E4            pop a      ; restore left side operator
0131   04D3 DF            push cl    ; save result of xor above
0132   04D4 FD AA         swp a  
0133   04D6 93 80         test al, $80  
0134   04D8 FD AA         swp a  
0135   04DA C6 DF 04      jz skip_invert_a_4  
0136   04DD FD 95          neg a 
0137   04DF             skip_invert_a_4:   
0138   04DF FD AB         swp b
0139   04E1 FD 93 80      test bl, $80  
0140   04E4 FD AB         swp b
0141   04E6 C6 EB 04      jz skip_invert_b_4  
0142   04E9 FD 97          neg b 
0143   04EB             skip_invert_b_4:   
0144   04EB AC            mul a, b ; *
0145   04EC FD 78         mov g, a
0146   04EE 11            mov a, b
0147   04EF EA            pop bl
0148   04F0 FD 93 80      test bl, $80
0149   04F3 C6 05 05      jz _same_signs_4
0150   04F6 27            mov b, a
0151   04F7 FD 12         mov a, g
0152   04F9 95            not a
0153   04FA 97            not b
0154   04FB 55 01 00      add b, 1
0155   04FE 5B 00 00      adc a, 0
0156   0501 39            mov c, a
0157   0502 FD 7A         mov g, c
0158   0504 11            mov a, b
0159   0505             _same_signs_4:
0160   0505 FD 38         mov c, g
0161   0507 27            mov b, a
0162   0508 FD F1         pop g
0163   050A E4            pop a
0164   050B             ; --- END FACTORS
0165   050B E7            pop d
0166   050C FD 43         mov [d], b
0167   050E             ; e = find_e(phi); 
0168   050E FA F7 FF      lea d, [bp + -9] ; $e
0169   0511 DA            push d
0170   0512             ; --- START FUNCTION CALL
0171   0512 FA F9 FF      lea d, [bp + -7] ; $phi
0172   0515 2A            mov b, [d]
0173   0516 38 00 00      mov c, 0
0174   0519 FD AB         swp b
0175   051B D8            push b
0176   051C 07 07 09      call find_e
0177   051F 51 02 00      add sp, 2
0178   0522             ; --- END FUNCTION CALL
0179   0522 E7            pop d
0180   0523 FD 43         mov [d], b
0181   0525             ; d = find_d(e, phi); 
0182   0525 FA F5 FF      lea d, [bp + -11] ; $d
0183   0528 DA            push d
0184   0529             ; --- START FUNCTION CALL
0185   0529 FA F9 FF      lea d, [bp + -7] ; $phi
0186   052C 2A            mov b, [d]
0187   052D 38 00 00      mov c, 0
0188   0530 FD AB         swp b
0189   0532 D8            push b
0190   0533 FA F7 FF      lea d, [bp + -9] ; $e
0191   0536 2A            mov b, [d]
0192   0537 38 00 00      mov c, 0
0193   053A FD AB         swp b
0194   053C D8            push b
0195   053D 07 87 09      call find_d
0196   0540 51 04 00      add sp, 4
0197   0543             ; --- END FUNCTION CALL
0198   0543 E7            pop d
0199   0544 FD 43         mov [d], b
0200   0546             ; printf("Public Key: %d, %d\n", n, e); 
0201   0546             ; --- START FUNCTION CALL
0202   0546 FA F7 FF      lea d, [bp + -9] ; $e
0203   0549 2A            mov b, [d]
0204   054A 38 00 00      mov c, 0
0205   054D FD AB         swp b
0206   054F D8            push b
0207   0550 FA FB FF      lea d, [bp + -5] ; $n
0208   0553 2A            mov b, [d]
0209   0554 38 00 00      mov c, 0
0210   0557 FD AB         swp b
0211   0559 D8            push b
0212   055A 26 77 14      mov b, _s0 ; "Public Key: %d, %d\n"
0213   055D FD AB         swp b
0214   055F D8            push b
0215   0560 07 71 0A      call printf
0216   0563 51 06 00      add sp, 6
0217   0566             ; --- END FUNCTION CALL
0218   0566             ; printf("Private Key: %d, %d\n", n, d); 
0219   0566             ; --- START FUNCTION CALL
0220   0566 FA F5 FF      lea d, [bp + -11] ; $d
0221   0569 2A            mov b, [d]
0222   056A 38 00 00      mov c, 0
0223   056D FD AB         swp b
0224   056F D8            push b
0225   0570 FA FB FF      lea d, [bp + -5] ; $n
0226   0573 2A            mov b, [d]
0227   0574 38 00 00      mov c, 0
0228   0577 FD AB         swp b
0229   0579 D8            push b
0230   057A 26 8B 14      mov b, _s1 ; "Private Key: %d, %d\n"
0231   057D FD AB         swp b
0232   057F D8            push b
0233   0580 07 71 0A      call printf
0234   0583 51 06 00      add sp, 6
0235   0586             ; --- END FUNCTION CALL
0236   0586             ; printf("Enter a string: "); 
0237   0586             ; --- START FUNCTION CALL
0238   0586 26 A0 14      mov b, _s2 ; "Enter a string: "
0239   0589 FD AB         swp b
0240   058B D8            push b
0241   058C 07 71 0A      call printf
0242   058F 51 02 00      add sp, 2
0243   0592             ; --- END FUNCTION CALL
0244   0592             ; gets(input_str); 
0245   0592             ; --- START FUNCTION CALL
0246   0592 FA 8F FF      lea d, [bp + -113] ; $input_str
0247   0595 2D            mov b, d
0248   0596 38 00 00      mov c, 0
0249   0599 FD AB         swp b
0250   059B D8            push b
0251   059C 07 5E 13      call gets
0252   059F 51 02 00      add sp, 2
0253   05A2             ; --- END FUNCTION CALL
0254   05A2             ; encrypted_chars_len = 0; 
0255   05A2 FA C5 FE      lea d, [bp + -315] ; $encrypted_chars_len
0256   05A5 DA            push d
0257   05A6 FD 2E 00 00   mov32 cb, $00000000
0257   05AA 00 00 
0258   05AC E7            pop d
0259   05AD FD 43         mov [d], b
0260   05AF             ; printf("Encrypted text: \n"); 
0261   05AF             ; --- START FUNCTION CALL
0262   05AF 26 B1 14      mov b, _s3 ; "Encrypted text: \n"
0263   05B2 FD AB         swp b
0264   05B4 D8            push b
0265   05B5 07 71 0A      call printf
0266   05B8 51 02 00      add sp, 2
0267   05BB             ; --- END FUNCTION CALL
0268   05BB             ; for (i = 0; input_str[i] != '\0' && input_str[i] != '\n'; i++) { 
0269   05BB             _for5_init:
0270   05BB FA F3 FF      lea d, [bp + -13] ; $i
0271   05BE DA            push d
0272   05BF FD 2E 00 00   mov32 cb, $00000000
0272   05C3 00 00 
0273   05C5 E7            pop d
0274   05C6 FD 43         mov [d], b
0275   05C8             _for5_cond:
0276   05C8 FA 8F FF      lea d, [bp + -113] ; $input_str
0277   05CB D7            push a
0278   05CC DA            push d
0279   05CD FA F3 FF      lea d, [bp + -13] ; $i
0280   05D0 2A            mov b, [d]
0281   05D1 38 00 00      mov c, 0
0282   05D4 E7            pop d
0283   05D5 5A            add d, b
0284   05D6 E4            pop a
0285   05D7 32            mov bl, [d]
0286   05D8 A7 00         mov bh, 0
0287   05DA 38 00 00      mov c, 0
0288   05DD             ; --- START RELATIONAL
0289   05DD D7            push a
0290   05DE 11            mov a, b
0291   05DF FD 2E 00 00   mov32 cb, $00000000
0291   05E3 00 00 
0292   05E5 B0            cmp a, b
0293   05E6 FD 72         sneq ; !=
0294   05E8 E4            pop a
0295   05E9             ; --- END RELATIONAL
0296   05E9             ; --- START LOGICAL AND
0297   05E9 D7            push a
0298   05EA 11            mov a, b
0299   05EB FA 8F FF      lea d, [bp + -113] ; $input_str
0300   05EE D7            push a
0301   05EF DA            push d
0302   05F0 FA F3 FF      lea d, [bp + -13] ; $i
0303   05F3 2A            mov b, [d]
0304   05F4 38 00 00      mov c, 0
0305   05F7 E7            pop d
0306   05F8 5A            add d, b
0307   05F9 E4            pop a
0308   05FA 32            mov bl, [d]
0309   05FB A7 00         mov bh, 0
0310   05FD 38 00 00      mov c, 0
0311   0600             ; --- START RELATIONAL
0312   0600 D7            push a
0313   0601 11            mov a, b
0314   0602 FD 2E 0A 00   mov32 cb, $0000000a
0314   0606 00 00 
0315   0608 B0            cmp a, b
0316   0609 FD 72         sneq ; !=
0317   060B E4            pop a
0318   060C             ; --- END RELATIONAL
0319   060C FD A7         sand a, b
0320   060E E4            pop a
0321   060F             ; --- END LOGICAL AND
0322   060F C0 00 00      cmp b, 0
0323   0612 C6 A5 06      je _for5_exit
0324   0615             _for5_block:
0325   0615             ; encrypted_chars[i] = mod_exp(input_str[i], e, n); 
0326   0615 FA C7 FE      lea d, [bp + -313] ; $encrypted_chars
0327   0618 D7            push a
0328   0619 DA            push d
0329   061A FA F3 FF      lea d, [bp + -13] ; $i
0330   061D 2A            mov b, [d]
0331   061E 38 00 00      mov c, 0
0332   0621 E7            pop d
0333   0622 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0334   0626 E4            pop a
0335   0627 DA            push d
0336   0628             ; --- START FUNCTION CALL
0337   0628 FA FB FF      lea d, [bp + -5] ; $n
0338   062B 2A            mov b, [d]
0339   062C 38 00 00      mov c, 0
0340   062F FD AB         swp b
0341   0631 D8            push b
0342   0632 FA F7 FF      lea d, [bp + -9] ; $e
0343   0635 2A            mov b, [d]
0344   0636 38 00 00      mov c, 0
0345   0639 FD AB         swp b
0346   063B D8            push b
0347   063C FA 8F FF      lea d, [bp + -113] ; $input_str
0348   063F D7            push a
0349   0640 DA            push d
0350   0641 FA F3 FF      lea d, [bp + -13] ; $i
0351   0644 2A            mov b, [d]
0352   0645 38 00 00      mov c, 0
0353   0648 E7            pop d
0354   0649 5A            add d, b
0355   064A E4            pop a
0356   064B 32            mov bl, [d]
0357   064C A7 00         mov bh, 0
0358   064E 38 00 00      mov c, 0
0359   0651 FD AB         swp b
0360   0653 D8            push b
0361   0654 07 BD 07      call mod_exp
0362   0657 51 06 00      add sp, 6
0363   065A             ; --- END FUNCTION CALL
0364   065A E7            pop d
0365   065B FD 43         mov [d], b
0366   065D             ; printf("%d ", encrypted_chars[i]); 
0367   065D             ; --- START FUNCTION CALL
0368   065D FA C7 FE      lea d, [bp + -313] ; $encrypted_chars
0369   0660 D7            push a
0370   0661 DA            push d
0371   0662 FA F3 FF      lea d, [bp + -13] ; $i
0372   0665 2A            mov b, [d]
0373   0666 38 00 00      mov c, 0
0374   0669 E7            pop d
0375   066A FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0376   066E E4            pop a
0377   066F 2A            mov b, [d]
0378   0670 38 00 00      mov c, 0
0379   0673 FD AB         swp b
0380   0675 D8            push b
0381   0676 26 C3 14      mov b, _s4 ; "%d "
0382   0679 FD AB         swp b
0383   067B D8            push b
0384   067C 07 71 0A      call printf
0385   067F 51 04 00      add sp, 4
0386   0682             ; --- END FUNCTION CALL
0387   0682             ; encrypted_chars_len++; 
0388   0682 FA C5 FE      lea d, [bp + -315] ; $encrypted_chars_len
0389   0685 2A            mov b, [d]
0390   0686 38 00 00      mov c, 0
0391   0689 11            mov a, b
0392   068A FD 77         inc b
0393   068C FA C5 FE      lea d, [bp + -315] ; $encrypted_chars_len
0394   068F FD 43         mov [d], b
0395   0691 27            mov b, a
0396   0692             _for5_update:
0397   0692 FA F3 FF      lea d, [bp + -13] ; $i
0398   0695 2A            mov b, [d]
0399   0696 38 00 00      mov c, 0
0400   0699 11            mov a, b
0401   069A FD 77         inc b
0402   069C FA F3 FF      lea d, [bp + -13] ; $i
0403   069F FD 43         mov [d], b
0404   06A1 27            mov b, a
0405   06A2 0A C8 05      jmp _for5_cond
0406   06A5             _for5_exit:
0407   06A5             ; printf("\n"); 
0408   06A5             ; --- START FUNCTION CALL
0409   06A5 26 C7 14      mov b, _s5 ; "\n"
0410   06A8 FD AB         swp b
0411   06AA D8            push b
0412   06AB 07 71 0A      call printf
0413   06AE 51 02 00      add sp, 2
0414   06B1             ; --- END FUNCTION CALL
0415   06B1             ; printf("Decrypted text: \n"); 
0416   06B1             ; --- START FUNCTION CALL
0417   06B1 26 C9 14      mov b, _s6 ; "Decrypted text: \n"
0418   06B4 FD AB         swp b
0419   06B6 D8            push b
0420   06B7 07 71 0A      call printf
0421   06BA 51 02 00      add sp, 2
0422   06BD             ; --- END FUNCTION CALL
0423   06BD             ; for (i = 0; i < encrypted_chars_len; i++) { 
0424   06BD             _for6_init:
0425   06BD FA F3 FF      lea d, [bp + -13] ; $i
0426   06C0 DA            push d
0427   06C1 FD 2E 00 00   mov32 cb, $00000000
0427   06C5 00 00 
0428   06C7 E7            pop d
0429   06C8 FD 43         mov [d], b
0430   06CA             _for6_cond:
0431   06CA FA F3 FF      lea d, [bp + -13] ; $i
0432   06CD 2A            mov b, [d]
0433   06CE 38 00 00      mov c, 0
0434   06D1             ; --- START RELATIONAL
0435   06D1 D7            push a
0436   06D2 11            mov a, b
0437   06D3 FA C5 FE      lea d, [bp + -315] ; $encrypted_chars_len
0438   06D6 2A            mov b, [d]
0439   06D7 38 00 00      mov c, 0
0440   06DA B0            cmp a, b
0441   06DB FD 73         slt ; < (signed)
0442   06DD E4            pop a
0443   06DE             ; --- END RELATIONAL
0444   06DE C0 00 00      cmp b, 0
0445   06E1 C6 4F 07      je _for6_exit
0446   06E4             _for6_block:
0447   06E4             ; decrypted_char = mod_exp(encrypted_chars[i], d, n); 
0448   06E4 FA C3 FE      lea d, [bp + -317] ; $decrypted_char
0449   06E7 DA            push d
0450   06E8             ; --- START FUNCTION CALL
0451   06E8 FA FB FF      lea d, [bp + -5] ; $n
0452   06EB 2A            mov b, [d]
0453   06EC 38 00 00      mov c, 0
0454   06EF FD AB         swp b
0455   06F1 D8            push b
0456   06F2 FA F5 FF      lea d, [bp + -11] ; $d
0457   06F5 2A            mov b, [d]
0458   06F6 38 00 00      mov c, 0
0459   06F9 FD AB         swp b
0460   06FB D8            push b
0461   06FC FA C7 FE      lea d, [bp + -313] ; $encrypted_chars
0462   06FF D7            push a
0463   0700 DA            push d
0464   0701 FA F3 FF      lea d, [bp + -13] ; $i
0465   0704 2A            mov b, [d]
0466   0705 38 00 00      mov c, 0
0467   0708 E7            pop d
0468   0709 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0469   070D E4            pop a
0470   070E 2A            mov b, [d]
0471   070F 38 00 00      mov c, 0
0472   0712 FD AB         swp b
0473   0714 D8            push b
0474   0715 07 BD 07      call mod_exp
0475   0718 51 06 00      add sp, 6
0476   071B             ; --- END FUNCTION CALL
0477   071B E7            pop d
0478   071C FD 43         mov [d], b
0479   071E             ; c = decrypted_char; 
0480   071E FA C2 FE      lea d, [bp + -318] ; $c
0481   0721 DA            push d
0482   0722 FA C3 FE      lea d, [bp + -317] ; $decrypted_char
0483   0725 2A            mov b, [d]
0484   0726 38 00 00      mov c, 0
0485   0729 E7            pop d
0486   072A FD 3E         mov [d], bl
0487   072C             ; putchar(c); 
0488   072C             ; --- START FUNCTION CALL
0489   072C FA C2 FE      lea d, [bp + -318] ; $c
0490   072F 32            mov bl, [d]
0491   0730 A7 00         mov bh, 0
0492   0732 38 00 00      mov c, 0
0493   0735 DD            push bl
0494   0736 07 EB 0E      call putchar
0495   0739 51 01 00      add sp, 1
0496   073C             ; --- END FUNCTION CALL
0497   073C             _for6_update:
0498   073C FA F3 FF      lea d, [bp + -13] ; $i
0499   073F 2A            mov b, [d]
0500   0740 38 00 00      mov c, 0
0501   0743 11            mov a, b
0502   0744 FD 77         inc b
0503   0746 FA F3 FF      lea d, [bp + -13] ; $i
0504   0749 FD 43         mov [d], b
0505   074B 27            mov b, a
0506   074C 0A CA 06      jmp _for6_cond
0507   074F             _for6_exit:
0508   074F             ; printf("\n"); 
0509   074F             ; --- START FUNCTION CALL
0510   074F 26 C7 14      mov b, _s5 ; "\n"
0511   0752 FD AB         swp b
0512   0754 D8            push b
0513   0755 07 71 0A      call printf
0514   0758 51 02 00      add sp, 2
0515   075B             ; --- END FUNCTION CALL
0516   075B             ; return 0; 
0517   075B FD 2E 00 00   mov32 cb, $00000000
0517   075F 00 00 
0518   0761 F9            leave
0519   0762 05 0B         syscall sys_terminate_proc
0520   0764             
0521   0764             gcd:
0522   0764 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0523   0767             ; if (b == 0) { 
0524   0767             _if7_cond:
0525   0767 FA 07 00      lea d, [bp + 7] ; $b
0526   076A 2A            mov b, [d]
0527   076B 38 00 00      mov c, 0
0528   076E             ; --- START RELATIONAL
0529   076E D7            push a
0530   076F 11            mov a, b
0531   0770 FD 2E 00 00   mov32 cb, $00000000
0531   0774 00 00 
0532   0776 B0            cmp a, b
0533   0777 FD 71         seq ; ==
0534   0779 E4            pop a
0535   077A             ; --- END RELATIONAL
0536   077A C0 00 00      cmp b, 0
0537   077D C6 8C 07      je _if7_exit
0538   0780             _if7_TRUE:
0539   0780             ; return a; 
0540   0780 FA 05 00      lea d, [bp + 5] ; $a
0541   0783 2A            mov b, [d]
0542   0784 38 00 00      mov c, 0
0543   0787 F9            leave
0544   0788 09            ret
0545   0789 0A 8C 07      jmp _if7_exit
0546   078C             _if7_exit:
0547   078C             ; return gcd(b, a % b); 
0548   078C             ; --- START FUNCTION CALL
0549   078C FA 05 00      lea d, [bp + 5] ; $a
0550   078F 2A            mov b, [d]
0551   0790 38 00 00      mov c, 0
0552   0793             ; --- START FACTORS
0553   0793 D7            push a
0554   0794 FD D8         push g
0555   0796 11            mov a, b
0556   0797 FD 7A         mov g, c
0557   0799 FA 07 00      lea d, [bp + 7] ; $b
0558   079C 2A            mov b, [d]
0559   079D 38 00 00      mov c, 0
0560   07A0 AE            div a, b ; 
0561   07A1 11            mov a, b
0562   07A2 FD 38         mov c, g
0563   07A4 27            mov b, a
0564   07A5 FD F1         pop g
0565   07A7 E4            pop a
0566   07A8             ; --- END FACTORS
0567   07A8 FD AB         swp b
0568   07AA D8            push b
0569   07AB FA 07 00      lea d, [bp + 7] ; $b
0570   07AE 2A            mov b, [d]
0571   07AF 38 00 00      mov c, 0
0572   07B2 FD AB         swp b
0573   07B4 D8            push b
0574   07B5 07 64 07      call gcd
0575   07B8 51 04 00      add sp, 4
0576   07BB             ; --- END FUNCTION CALL
0577   07BB F9            leave
0578   07BC 09            ret
0579   07BD             
0580   07BD             mod_exp:
0581   07BD F8 00 00      enter 0 ; (push bp; mov bp, sp)
0582   07C0             ; int result; 
0583   07C0 52 02 00      sub sp, 2
0584   07C3             ; result = 1; 
0585   07C3 FA FF FF      lea d, [bp + -1] ; $result
0586   07C6 DA            push d
0587   07C7 FD 2E 01 00   mov32 cb, $00000001
0587   07CB 00 00 
0588   07CD E7            pop d
0589   07CE FD 43         mov [d], b
0590   07D0             ; while (exp > 0) { 
0591   07D0             _while12_cond:
0592   07D0 FA 07 00      lea d, [bp + 7] ; $exp
0593   07D3 2A            mov b, [d]
0594   07D4 38 00 00      mov c, 0
0595   07D7             ; --- START RELATIONAL
0596   07D7 D7            push a
0597   07D8 11            mov a, b
0598   07D9 FD 2E 00 00   mov32 cb, $00000000
0598   07DD 00 00 
0599   07DF B0            cmp a, b
0600   07E0 FD 7F         sgt ; >
0601   07E2 E4            pop a
0602   07E3             ; --- END RELATIONAL
0603   07E3 C0 00 00      cmp b, 0
0604   07E6 C6 FE 08      je _while12_exit
0605   07E9             _while12_block:
0606   07E9             ; if (exp & 1) { 
0607   07E9             _if13_cond:
0608   07E9 FA 07 00      lea d, [bp + 7] ; $exp
0609   07EC 2A            mov b, [d]
0610   07ED 38 00 00      mov c, 0
0611   07F0 D7            push a
0612   07F1 11            mov a, b
0613   07F2 FD 2E 01 00   mov32 cb, $00000001
0613   07F6 00 00 
0614   07F8 FD 92         and b, a ; &
0615   07FA E4            pop a
0616   07FB C0 00 00      cmp b, 0
0617   07FE C6 72 08      je _if13_exit
0618   0801             _if13_TRUE:
0619   0801             ; result = (result * base) % mod; 
0620   0801 FA FF FF      lea d, [bp + -1] ; $result
0621   0804 DA            push d
0622   0805 FA FF FF      lea d, [bp + -1] ; $result
0623   0808 2A            mov b, [d]
0624   0809 38 00 00      mov c, 0
0625   080C             ; --- START FACTORS
0626   080C D7            push a
0627   080D FD D8         push g
0628   080F 11            mov a, b
0629   0810 FD 7A         mov g, c
0630   0812 FA 05 00      lea d, [bp + 5] ; $base
0631   0815 2A            mov b, [d]
0632   0816 38 00 00      mov c, 0
0633   0819 D7            push a     ; save left operand
0634   081A 8E            xor a, b   ; xor sign bits
0635   081B FD AA         swp a      ; swap bytes
0636   081D 83            mov cl, al ; save result of xor into 'dl'
0637   081E E4            pop a      ; restore left side operator
0638   081F DF            push cl    ; save result of xor above
0639   0820 FD AA         swp a  
0640   0822 93 80         test al, $80  
0641   0824 FD AA         swp a  
0642   0826 C6 2B 08      jz skip_invert_a_18  
0643   0829 FD 95          neg a 
0644   082B             skip_invert_a_18:   
0645   082B FD AB         swp b
0646   082D FD 93 80      test bl, $80  
0647   0830 FD AB         swp b
0648   0832 C6 37 08      jz skip_invert_b_18  
0649   0835 FD 97          neg b 
0650   0837             skip_invert_b_18:   
0651   0837 AC            mul a, b ; *
0652   0838 FD 78         mov g, a
0653   083A 11            mov a, b
0654   083B EA            pop bl
0655   083C FD 93 80      test bl, $80
0656   083F C6 51 08      jz _same_signs_18
0657   0842 27            mov b, a
0658   0843 FD 12         mov a, g
0659   0845 95            not a
0660   0846 97            not b
0661   0847 55 01 00      add b, 1
0662   084A 5B 00 00      adc a, 0
0663   084D 39            mov c, a
0664   084E FD 7A         mov g, c
0665   0850 11            mov a, b
0666   0851             _same_signs_18:
0667   0851 FD 38         mov c, g
0668   0853 27            mov b, a
0669   0854 FD F1         pop g
0670   0856 E4            pop a
0671   0857             ; --- END FACTORS
0672   0857             ; --- START FACTORS
0673   0857 D7            push a
0674   0858 FD D8         push g
0675   085A 11            mov a, b
0676   085B FD 7A         mov g, c
0677   085D FA 09 00      lea d, [bp + 9] ; $mod
0678   0860 2A            mov b, [d]
0679   0861 38 00 00      mov c, 0
0680   0864 AE            div a, b ; 
0681   0865 11            mov a, b
0682   0866 FD 38         mov c, g
0683   0868 27            mov b, a
0684   0869 FD F1         pop g
0685   086B E4            pop a
0686   086C             ; --- END FACTORS
0687   086C E7            pop d
0688   086D FD 43         mov [d], b
0689   086F 0A 72 08      jmp _if13_exit
0690   0872             _if13_exit:
0691   0872             ; exp = exp >> 1; 
0692   0872 FA 07 00      lea d, [bp + 7] ; $exp
0693   0875 DA            push d
0694   0876 FA 07 00      lea d, [bp + 7] ; $exp
0695   0879 2A            mov b, [d]
0696   087A 38 00 00      mov c, 0
0697   087D             ; --- START SHIFT
0698   087D D7            push a
0699   087E 11            mov a, b
0700   087F FD 2E 01 00   mov32 cb, $00000001
0700   0883 00 00 
0701   0885 FD 39         mov c, b
0702   0887 A5            ashr a, cl
0703   0888 27            mov b, a
0704   0889 E4            pop a
0705   088A             ; --- END SHIFT
0706   088A E7            pop d
0707   088B FD 43         mov [d], b
0708   088D             ; base = (base * base) % mod; 
0709   088D FA 05 00      lea d, [bp + 5] ; $base
0710   0890 DA            push d
0711   0891 FA 05 00      lea d, [bp + 5] ; $base
0712   0894 2A            mov b, [d]
0713   0895 38 00 00      mov c, 0
0714   0898             ; --- START FACTORS
0715   0898 D7            push a
0716   0899 FD D8         push g
0717   089B 11            mov a, b
0718   089C FD 7A         mov g, c
0719   089E FA 05 00      lea d, [bp + 5] ; $base
0720   08A1 2A            mov b, [d]
0721   08A2 38 00 00      mov c, 0
0722   08A5 D7            push a     ; save left operand
0723   08A6 8E            xor a, b   ; xor sign bits
0724   08A7 FD AA         swp a      ; swap bytes
0725   08A9 83            mov cl, al ; save result of xor into 'dl'
0726   08AA E4            pop a      ; restore left side operator
0727   08AB DF            push cl    ; save result of xor above
0728   08AC FD AA         swp a  
0729   08AE 93 80         test al, $80  
0730   08B0 FD AA         swp a  
0731   08B2 C6 B7 08      jz skip_invert_a_24  
0732   08B5 FD 95          neg a 
0733   08B7             skip_invert_a_24:   
0734   08B7 FD AB         swp b
0735   08B9 FD 93 80      test bl, $80  
0736   08BC FD AB         swp b
0737   08BE C6 C3 08      jz skip_invert_b_24  
0738   08C1 FD 97          neg b 
0739   08C3             skip_invert_b_24:   
0740   08C3 AC            mul a, b ; *
0741   08C4 FD 78         mov g, a
0742   08C6 11            mov a, b
0743   08C7 EA            pop bl
0744   08C8 FD 93 80      test bl, $80
0745   08CB C6 DD 08      jz _same_signs_24
0746   08CE 27            mov b, a
0747   08CF FD 12         mov a, g
0748   08D1 95            not a
0749   08D2 97            not b
0750   08D3 55 01 00      add b, 1
0751   08D6 5B 00 00      adc a, 0
0752   08D9 39            mov c, a
0753   08DA FD 7A         mov g, c
0754   08DC 11            mov a, b
0755   08DD             _same_signs_24:
0756   08DD FD 38         mov c, g
0757   08DF 27            mov b, a
0758   08E0 FD F1         pop g
0759   08E2 E4            pop a
0760   08E3             ; --- END FACTORS
0761   08E3             ; --- START FACTORS
0762   08E3 D7            push a
0763   08E4 FD D8         push g
0764   08E6 11            mov a, b
0765   08E7 FD 7A         mov g, c
0766   08E9 FA 09 00      lea d, [bp + 9] ; $mod
0767   08EC 2A            mov b, [d]
0768   08ED 38 00 00      mov c, 0
0769   08F0 AE            div a, b ; 
0770   08F1 11            mov a, b
0771   08F2 FD 38         mov c, g
0772   08F4 27            mov b, a
0773   08F5 FD F1         pop g
0774   08F7 E4            pop a
0775   08F8             ; --- END FACTORS
0776   08F8 E7            pop d
0777   08F9 FD 43         mov [d], b
0778   08FB 0A D0 07      jmp _while12_cond
0779   08FE             _while12_exit:
0780   08FE             ; return result; 
0781   08FE FA FF FF      lea d, [bp + -1] ; $result
0782   0901 2A            mov b, [d]
0783   0902 38 00 00      mov c, 0
0784   0905 F9            leave
0785   0906 09            ret
0786   0907             
0787   0907             find_e:
0788   0907 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0789   090A             ; int e; 
0790   090A 52 02 00      sub sp, 2
0791   090D             ; for (e = 2; e < phi; e++) { 
0792   090D             _for26_init:
0793   090D FA FF FF      lea d, [bp + -1] ; $e
0794   0910 DA            push d
0795   0911 FD 2E 02 00   mov32 cb, $00000002
0795   0915 00 00 
0796   0917 E7            pop d
0797   0918 FD 43         mov [d], b
0798   091A             _for26_cond:
0799   091A FA FF FF      lea d, [bp + -1] ; $e
0800   091D 2A            mov b, [d]
0801   091E 38 00 00      mov c, 0
0802   0921             ; --- START RELATIONAL
0803   0921 D7            push a
0804   0922 11            mov a, b
0805   0923 FA 05 00      lea d, [bp + 5] ; $phi
0806   0926 2A            mov b, [d]
0807   0927 38 00 00      mov c, 0
0808   092A B0            cmp a, b
0809   092B FD 73         slt ; < (signed)
0810   092D E4            pop a
0811   092E             ; --- END RELATIONAL
0812   092E C0 00 00      cmp b, 0
0813   0931 C6 7F 09      je _for26_exit
0814   0934             _for26_block:
0815   0934             ; if (gcd(e, phi) == 1) { 
0816   0934             _if27_cond:
0817   0934             ; --- START FUNCTION CALL
0818   0934 FA 05 00      lea d, [bp + 5] ; $phi
0819   0937 2A            mov b, [d]
0820   0938 38 00 00      mov c, 0
0821   093B FD AB         swp b
0822   093D D8            push b
0823   093E FA FF FF      lea d, [bp + -1] ; $e
0824   0941 2A            mov b, [d]
0825   0942 38 00 00      mov c, 0
0826   0945 FD AB         swp b
0827   0947 D8            push b
0828   0948 07 64 07      call gcd
0829   094B 51 04 00      add sp, 4
0830   094E             ; --- END FUNCTION CALL
0831   094E             ; --- START RELATIONAL
0832   094E D7            push a
0833   094F 11            mov a, b
0834   0950 FD 2E 01 00   mov32 cb, $00000001
0834   0954 00 00 
0835   0956 B0            cmp a, b
0836   0957 FD 71         seq ; ==
0837   0959 E4            pop a
0838   095A             ; --- END RELATIONAL
0839   095A C0 00 00      cmp b, 0
0840   095D C6 6C 09      je _if27_exit
0841   0960             _if27_TRUE:
0842   0960             ; return e; 
0843   0960 FA FF FF      lea d, [bp + -1] ; $e
0844   0963 2A            mov b, [d]
0845   0964 38 00 00      mov c, 0
0846   0967 F9            leave
0847   0968 09            ret
0848   0969 0A 6C 09      jmp _if27_exit
0849   096C             _if27_exit:
0850   096C             _for26_update:
0851   096C FA FF FF      lea d, [bp + -1] ; $e
0852   096F 2A            mov b, [d]
0853   0970 38 00 00      mov c, 0
0854   0973 11            mov a, b
0855   0974 FD 77         inc b
0856   0976 FA FF FF      lea d, [bp + -1] ; $e
0857   0979 FD 43         mov [d], b
0858   097B 27            mov b, a
0859   097C 0A 1A 09      jmp _for26_cond
0860   097F             _for26_exit:
0861   097F             ; return 0; 
0862   097F FD 2E 00 00   mov32 cb, $00000000
0862   0983 00 00 
0863   0985 F9            leave
0864   0986 09            ret
0865   0987             
0866   0987             find_d:
0867   0987 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0868   098A             ; int d; 
0869   098A 52 02 00      sub sp, 2
0870   098D             ; for (d = 2; d < phi; d++) { 
0871   098D             _for28_init:
0872   098D FA FF FF      lea d, [bp + -1] ; $d
0873   0990 DA            push d
0874   0991 FD 2E 02 00   mov32 cb, $00000002
0874   0995 00 00 
0875   0997 E7            pop d
0876   0998 FD 43         mov [d], b
0877   099A             _for28_cond:
0878   099A FA FF FF      lea d, [bp + -1] ; $d
0879   099D 2A            mov b, [d]
0880   099E 38 00 00      mov c, 0
0881   09A1             ; --- START RELATIONAL
0882   09A1 D7            push a
0883   09A2 11            mov a, b
0884   09A3 FA 07 00      lea d, [bp + 7] ; $phi
0885   09A6 2A            mov b, [d]
0886   09A7 38 00 00      mov c, 0
0887   09AA B0            cmp a, b
0888   09AB FD 73         slt ; < (signed)
0889   09AD E4            pop a
0890   09AE             ; --- END RELATIONAL
0891   09AE C0 00 00      cmp b, 0
0892   09B1 C6 69 0A      je _for28_exit
0893   09B4             _for28_block:
0894   09B4             ; printf("%d\n", d); 
0895   09B4             ; --- START FUNCTION CALL
0896   09B4 FA FF FF      lea d, [bp + -1] ; $d
0897   09B7 2A            mov b, [d]
0898   09B8 38 00 00      mov c, 0
0899   09BB FD AB         swp b
0900   09BD D8            push b
0901   09BE 26 DB 14      mov b, _s7 ; "%d\n"
0902   09C1 FD AB         swp b
0903   09C3 D8            push b
0904   09C4 07 71 0A      call printf
0905   09C7 51 04 00      add sp, 4
0906   09CA             ; --- END FUNCTION CALL
0907   09CA             ; if ((d * e) % phi == 1) { 
0908   09CA             _if29_cond:
0909   09CA FA FF FF      lea d, [bp + -1] ; $d
0910   09CD 2A            mov b, [d]
0911   09CE 38 00 00      mov c, 0
0912   09D1             ; --- START FACTORS
0913   09D1 D7            push a
0914   09D2 FD D8         push g
0915   09D4 11            mov a, b
0916   09D5 FD 7A         mov g, c
0917   09D7 FA 05 00      lea d, [bp + 5] ; $e
0918   09DA 2A            mov b, [d]
0919   09DB 38 00 00      mov c, 0
0920   09DE D7            push a     ; save left operand
0921   09DF 8E            xor a, b   ; xor sign bits
0922   09E0 FD AA         swp a      ; swap bytes
0923   09E2 83            mov cl, al ; save result of xor into 'dl'
0924   09E3 E4            pop a      ; restore left side operator
0925   09E4 DF            push cl    ; save result of xor above
0926   09E5 FD AA         swp a  
0927   09E7 93 80         test al, $80  
0928   09E9 FD AA         swp a  
0929   09EB C6 F0 09      jz skip_invert_a_34  
0930   09EE FD 95          neg a 
0931   09F0             skip_invert_a_34:   
0932   09F0 FD AB         swp b
0933   09F2 FD 93 80      test bl, $80  
0934   09F5 FD AB         swp b
0935   09F7 C6 FC 09      jz skip_invert_b_34  
0936   09FA FD 97          neg b 
0937   09FC             skip_invert_b_34:   
0938   09FC AC            mul a, b ; *
0939   09FD FD 78         mov g, a
0940   09FF 11            mov a, b
0941   0A00 EA            pop bl
0942   0A01 FD 93 80      test bl, $80
0943   0A04 C6 16 0A      jz _same_signs_34
0944   0A07 27            mov b, a
0945   0A08 FD 12         mov a, g
0946   0A0A 95            not a
0947   0A0B 97            not b
0948   0A0C 55 01 00      add b, 1
0949   0A0F 5B 00 00      adc a, 0
0950   0A12 39            mov c, a
0951   0A13 FD 7A         mov g, c
0952   0A15 11            mov a, b
0953   0A16             _same_signs_34:
0954   0A16 FD 38         mov c, g
0955   0A18 27            mov b, a
0956   0A19 FD F1         pop g
0957   0A1B E4            pop a
0958   0A1C             ; --- END FACTORS
0959   0A1C             ; --- START FACTORS
0960   0A1C D7            push a
0961   0A1D FD D8         push g
0962   0A1F 11            mov a, b
0963   0A20 FD 7A         mov g, c
0964   0A22 FA 07 00      lea d, [bp + 7] ; $phi
0965   0A25 2A            mov b, [d]
0966   0A26 38 00 00      mov c, 0
0967   0A29 AE            div a, b ; 
0968   0A2A 11            mov a, b
0969   0A2B FD 38         mov c, g
0970   0A2D 27            mov b, a
0971   0A2E FD F1         pop g
0972   0A30 E4            pop a
0973   0A31             ; --- END FACTORS
0974   0A31             ; --- START RELATIONAL
0975   0A31 D7            push a
0976   0A32 FD D8         push g
0977   0A34 11            mov a, b
0978   0A35 FD 7A         mov g, c
0979   0A37 FD 2E 01 00   mov32 cb, $00000001
0979   0A3B 00 00 
0980   0A3D FD AF         cmp32 ga, cb
0981   0A3F FD 71         seq ; ==
0982   0A41 FD F1         pop g
0983   0A43 E4            pop a
0984   0A44             ; --- END RELATIONAL
0985   0A44 C0 00 00      cmp b, 0
0986   0A47 C6 56 0A      je _if29_exit
0987   0A4A             _if29_TRUE:
0988   0A4A             ; return d; 
0989   0A4A FA FF FF      lea d, [bp + -1] ; $d
0990   0A4D 2A            mov b, [d]
0991   0A4E 38 00 00      mov c, 0
0992   0A51 F9            leave
0993   0A52 09            ret
0994   0A53 0A 56 0A      jmp _if29_exit
0995   0A56             _if29_exit:
0996   0A56             _for28_update:
0997   0A56 FA FF FF      lea d, [bp + -1] ; $d
0998   0A59 2A            mov b, [d]
0999   0A5A 38 00 00      mov c, 0
1000   0A5D 11            mov a, b
1001   0A5E FD 77         inc b
1002   0A60 FA FF FF      lea d, [bp + -1] ; $d
1003   0A63 FD 43         mov [d], b
1004   0A65 27            mov b, a
1005   0A66 0A 9A 09      jmp _for28_cond
1006   0A69             _for28_exit:
1007   0A69             ; return 0; 
1008   0A69 FD 2E 00 00   mov32 cb, $00000000
1008   0A6D 00 00 
1009   0A6F F9            leave
1010   0A70 09            ret
1011   0A71             
1012   0A71             printf:
1013   0A71 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1014   0A74             ; char *p, *format_p; 
1015   0A74 52 02 00      sub sp, 2
1016   0A77 52 02 00      sub sp, 2
1017   0A7A             ; format_p = format; 
1018   0A7A FA FD FF      lea d, [bp + -3] ; $format_p
1019   0A7D DA            push d
1020   0A7E FA 05 00      lea d, [bp + 5] ; $format
1021   0A81 2A            mov b, [d]
1022   0A82 38 00 00      mov c, 0
1023   0A85 E7            pop d
1024   0A86 FD 43         mov [d], b
1025   0A88             ; p = &format + 2; 
1026   0A88 FA FF FF      lea d, [bp + -1] ; $p
1027   0A8B DA            push d
1028   0A8C FA 05 00      lea d, [bp + 5] ; $format
1029   0A8F 2D            mov b, d
1030   0A90             ; --- START TERMS
1031   0A90 D7            push a
1032   0A91 11            mov a, b
1033   0A92 FD 2E 02 00   mov32 cb, $00000002
1033   0A96 00 00 
1034   0A98 56            add b, a
1035   0A99 E4            pop a
1036   0A9A             ; --- END TERMS
1037   0A9A E7            pop d
1038   0A9B FD 43         mov [d], b
1039   0A9D             ; for(;;){ 
1040   0A9D             _for36_init:
1041   0A9D             _for36_cond:
1042   0A9D             _for36_block:
1043   0A9D             ; if(!*format_p) break; 
1044   0A9D             _if37_cond:
1045   0A9D FA FD FF      lea d, [bp + -3] ; $format_p
1046   0AA0 2A            mov b, [d]
1047   0AA1 38 00 00      mov c, 0
1048   0AA4 74            mov d, b
1049   0AA5 32            mov bl, [d]
1050   0AA6 A7 00         mov bh, 0
1051   0AA8 38 00 00      mov c, 0
1052   0AAB C0 00 00      cmp b, 0
1053   0AAE FD 71         seq ; !
1054   0AB0 C0 00 00      cmp b, 0
1055   0AB3 C6 BC 0A      je _if37_else
1056   0AB6             _if37_TRUE:
1057   0AB6             ; break; 
1058   0AB6 0A 6C 0D      jmp _for36_exit ; for break
1059   0AB9 0A 69 0D      jmp _if37_exit
1060   0ABC             _if37_else:
1061   0ABC             ; if(*format_p == '%'){ 
1062   0ABC             _if38_cond:
1063   0ABC FA FD FF      lea d, [bp + -3] ; $format_p
1064   0ABF 2A            mov b, [d]
1065   0AC0 38 00 00      mov c, 0
1066   0AC3 74            mov d, b
1067   0AC4 32            mov bl, [d]
1068   0AC5 A7 00         mov bh, 0
1069   0AC7 38 00 00      mov c, 0
1070   0ACA             ; --- START RELATIONAL
1071   0ACA D7            push a
1072   0ACB 11            mov a, b
1073   0ACC FD 2E 25 00   mov32 cb, $00000025
1073   0AD0 00 00 
1074   0AD2 B0            cmp a, b
1075   0AD3 FD 71         seq ; ==
1076   0AD5 E4            pop a
1077   0AD6             ; --- END RELATIONAL
1078   0AD6 C0 00 00      cmp b, 0
1079   0AD9 C6 44 0D      je _if38_else
1080   0ADC             _if38_TRUE:
1081   0ADC             ; format_p++; 
1082   0ADC FA FD FF      lea d, [bp + -3] ; $format_p
1083   0ADF 2A            mov b, [d]
1084   0AE0 38 00 00      mov c, 0
1085   0AE3 FD 77         inc b
1086   0AE5 FA FD FF      lea d, [bp + -3] ; $format_p
1087   0AE8 FD 43         mov [d], b
1088   0AEA FD 7D         dec b
1089   0AEC             ; switch(*format_p){ 
1090   0AEC             _switch39_expr:
1091   0AEC FA FD FF      lea d, [bp + -3] ; $format_p
1092   0AEF 2A            mov b, [d]
1093   0AF0 38 00 00      mov c, 0
1094   0AF3 74            mov d, b
1095   0AF4 32            mov bl, [d]
1096   0AF5 A7 00         mov bh, 0
1097   0AF7 38 00 00      mov c, 0
1098   0AFA             _switch39_comparisons:
1099   0AFA C1 6C         cmp bl, $6c
1100   0AFC C6 28 0B      je _switch39_case0
1101   0AFF C1 4C         cmp bl, $4c
1102   0B01 C6 28 0B      je _switch39_case1
1103   0B04 C1 64         cmp bl, $64
1104   0B06 C6 38 0C      je _switch39_case2
1105   0B09 C1 69         cmp bl, $69
1106   0B0B C6 38 0C      je _switch39_case3
1107   0B0E C1 75         cmp bl, $75
1108   0B10 C6 68 0C      je _switch39_case4
1109   0B13 C1 78         cmp bl, $78
1110   0B15 C6 98 0C      je _switch39_case5
1111   0B18 C1 63         cmp bl, $63
1112   0B1A C6 C8 0C      je _switch39_case6
1113   0B1D C1 73         cmp bl, $73
1114   0B1F C6 F8 0C      je _switch39_case7
1115   0B22 0A 25 0D      jmp _switch39_default
1116   0B25 0A 31 0D      jmp _switch39_exit
1117   0B28             _switch39_case0:
1118   0B28             _switch39_case1:
1119   0B28             ; format_p++; 
1120   0B28 FA FD FF      lea d, [bp + -3] ; $format_p
1121   0B2B 2A            mov b, [d]
1122   0B2C 38 00 00      mov c, 0
1123   0B2F FD 77         inc b
1124   0B31 FA FD FF      lea d, [bp + -3] ; $format_p
1125   0B34 FD 43         mov [d], b
1126   0B36 FD 7D         dec b
1127   0B38             ; if(*format_p == 'd' || *format_p == 'i') 
1128   0B38             _if40_cond:
1129   0B38 FA FD FF      lea d, [bp + -3] ; $format_p
1130   0B3B 2A            mov b, [d]
1131   0B3C 38 00 00      mov c, 0
1132   0B3F 74            mov d, b
1133   0B40 32            mov bl, [d]
1134   0B41 A7 00         mov bh, 0
1135   0B43 38 00 00      mov c, 0
1136   0B46             ; --- START RELATIONAL
1137   0B46 D7            push a
1138   0B47 11            mov a, b
1139   0B48 FD 2E 64 00   mov32 cb, $00000064
1139   0B4C 00 00 
1140   0B4E B0            cmp a, b
1141   0B4F FD 71         seq ; ==
1142   0B51 E4            pop a
1143   0B52             ; --- END RELATIONAL
1144   0B52             ; --- START LOGICAL OR
1145   0B52 D7            push a
1146   0B53 11            mov a, b
1147   0B54 FA FD FF      lea d, [bp + -3] ; $format_p
1148   0B57 2A            mov b, [d]
1149   0B58 38 00 00      mov c, 0
1150   0B5B 74            mov d, b
1151   0B5C 32            mov bl, [d]
1152   0B5D A7 00         mov bh, 0
1153   0B5F 38 00 00      mov c, 0
1154   0B62             ; --- START RELATIONAL
1155   0B62 D7            push a
1156   0B63 11            mov a, b
1157   0B64 FD 2E 69 00   mov32 cb, $00000069
1157   0B68 00 00 
1158   0B6A B0            cmp a, b
1159   0B6B FD 71         seq ; ==
1160   0B6D E4            pop a
1161   0B6E             ; --- END RELATIONAL
1162   0B6E FD A8         sor a, b ; ||
1163   0B70 E4            pop a
1164   0B71             ; --- END LOGICAL OR
1165   0B71 C0 00 00      cmp b, 0
1166   0B74 C6 95 0B      je _if40_else
1167   0B77             _if40_TRUE:
1168   0B77             ; print_signed_long(*(long *)p); 
1169   0B77             ; --- START FUNCTION CALL
1170   0B77 FA FF FF      lea d, [bp + -1] ; $p
1171   0B7A 2A            mov b, [d]
1172   0B7B 38 00 00      mov c, 0
1173   0B7E 74            mov d, b
1174   0B7F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1175   0B82 FD 39         mov c, b ; And place it into C
1176   0B84 2A            mov b, [d] ; Lower Word in B
1177   0B85 12            mov a, c
1178   0B86 FD AA         swp a
1179   0B88 D7            push a
1180   0B89 FD AB         swp b
1181   0B8B D8            push b
1182   0B8C 07 6E 0D      call print_signed_long
1183   0B8F 51 04 00      add sp, 4
1184   0B92             ; --- END FUNCTION CALL
1185   0B92 0A 1D 0C      jmp _if40_exit
1186   0B95             _if40_else:
1187   0B95             ; if(*format_p == 'u') 
1188   0B95             _if41_cond:
1189   0B95 FA FD FF      lea d, [bp + -3] ; $format_p
1190   0B98 2A            mov b, [d]
1191   0B99 38 00 00      mov c, 0
1192   0B9C 74            mov d, b
1193   0B9D 32            mov bl, [d]
1194   0B9E A7 00         mov bh, 0
1195   0BA0 38 00 00      mov c, 0
1196   0BA3             ; --- START RELATIONAL
1197   0BA3 D7            push a
1198   0BA4 11            mov a, b
1199   0BA5 FD 2E 75 00   mov32 cb, $00000075
1199   0BA9 00 00 
1200   0BAB B0            cmp a, b
1201   0BAC FD 71         seq ; ==
1202   0BAE E4            pop a
1203   0BAF             ; --- END RELATIONAL
1204   0BAF C0 00 00      cmp b, 0
1205   0BB2 C6 D3 0B      je _if41_else
1206   0BB5             _if41_TRUE:
1207   0BB5             ; print_unsigned_long(*(unsigned long *)p); 
1208   0BB5             ; --- START FUNCTION CALL
1209   0BB5 FA FF FF      lea d, [bp + -1] ; $p
1210   0BB8 2A            mov b, [d]
1211   0BB9 38 00 00      mov c, 0
1212   0BBC 74            mov d, b
1213   0BBD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1214   0BC0 FD 39         mov c, b ; And place it into C
1215   0BC2 2A            mov b, [d] ; Lower Word in B
1216   0BC3 12            mov a, c
1217   0BC4 FD AA         swp a
1218   0BC6 D7            push a
1219   0BC7 FD AB         swp b
1220   0BC9 D8            push b
1221   0BCA 07 F9 0E      call print_unsigned_long
1222   0BCD 51 04 00      add sp, 4
1223   0BD0             ; --- END FUNCTION CALL
1224   0BD0 0A 1D 0C      jmp _if41_exit
1225   0BD3             _if41_else:
1226   0BD3             ; if(*format_p == 'x') 
1227   0BD3             _if42_cond:
1228   0BD3 FA FD FF      lea d, [bp + -3] ; $format_p
1229   0BD6 2A            mov b, [d]
1230   0BD7 38 00 00      mov c, 0
1231   0BDA 74            mov d, b
1232   0BDB 32            mov bl, [d]
1233   0BDC A7 00         mov bh, 0
1234   0BDE 38 00 00      mov c, 0
1235   0BE1             ; --- START RELATIONAL
1236   0BE1 D7            push a
1237   0BE2 11            mov a, b
1238   0BE3 FD 2E 78 00   mov32 cb, $00000078
1238   0BE7 00 00 
1239   0BE9 B0            cmp a, b
1240   0BEA FD 71         seq ; ==
1241   0BEC E4            pop a
1242   0BED             ; --- END RELATIONAL
1243   0BED C0 00 00      cmp b, 0
1244   0BF0 C6 11 0C      je _if42_else
1245   0BF3             _if42_TRUE:
1246   0BF3             ; printx32(*(long int *)p); 
1247   0BF3             ; --- START FUNCTION CALL
1248   0BF3 FA FF FF      lea d, [bp + -1] ; $p
1249   0BF6 2A            mov b, [d]
1250   0BF7 38 00 00      mov c, 0
1251   0BFA 74            mov d, b
1252   0BFB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1253   0BFE FD 39         mov c, b ; And place it into C
1254   0C00 2A            mov b, [d] ; Lower Word in B
1255   0C01 12            mov a, c
1256   0C02 FD AA         swp a
1257   0C04 D7            push a
1258   0C05 FD AB         swp b
1259   0C07 D8            push b
1260   0C08 07 25 10      call printx32
1261   0C0B 51 04 00      add sp, 4
1262   0C0E             ; --- END FUNCTION CALL
1263   0C0E 0A 1D 0C      jmp _if42_exit
1264   0C11             _if42_else:
1265   0C11             ; err("Unexpected format in printf."); 
1266   0C11             ; --- START FUNCTION CALL
1267   0C11 26 DF 14      mov b, _s8 ; "Unexpected format in printf."
1268   0C14 FD AB         swp b
1269   0C16 D8            push b
1270   0C17 07 85 10      call err
1271   0C1A 51 02 00      add sp, 2
1272   0C1D             ; --- END FUNCTION CALL
1273   0C1D             _if42_exit:
1274   0C1D             _if41_exit:
1275   0C1D             _if40_exit:
1276   0C1D             ; p = p + 4; 
1277   0C1D FA FF FF      lea d, [bp + -1] ; $p
1278   0C20 DA            push d
1279   0C21 FA FF FF      lea d, [bp + -1] ; $p
1280   0C24 2A            mov b, [d]
1281   0C25 38 00 00      mov c, 0
1282   0C28             ; --- START TERMS
1283   0C28 D7            push a
1284   0C29 11            mov a, b
1285   0C2A FD 2E 04 00   mov32 cb, $00000004
1285   0C2E 00 00 
1286   0C30 56            add b, a
1287   0C31 E4            pop a
1288   0C32             ; --- END TERMS
1289   0C32 E7            pop d
1290   0C33 FD 43         mov [d], b
1291   0C35             ; break; 
1292   0C35 0A 31 0D      jmp _switch39_exit ; case break
1293   0C38             _switch39_case2:
1294   0C38             _switch39_case3:
1295   0C38             ; print_signed(*(int*)p); 
1296   0C38             ; --- START FUNCTION CALL
1297   0C38 FA FF FF      lea d, [bp + -1] ; $p
1298   0C3B 2A            mov b, [d]
1299   0C3C 38 00 00      mov c, 0
1300   0C3F 74            mov d, b
1301   0C40 2A            mov b, [d]
1302   0C41 38 00 00      mov c, 0
1303   0C44 FD AB         swp b
1304   0C46 D8            push b
1305   0C47 07 B3 10      call print_signed
1306   0C4A 51 02 00      add sp, 2
1307   0C4D             ; --- END FUNCTION CALL
1308   0C4D             ; p = p + 2; 
1309   0C4D FA FF FF      lea d, [bp + -1] ; $p
1310   0C50 DA            push d
1311   0C51 FA FF FF      lea d, [bp + -1] ; $p
1312   0C54 2A            mov b, [d]
1313   0C55 38 00 00      mov c, 0
1314   0C58             ; --- START TERMS
1315   0C58 D7            push a
1316   0C59 11            mov a, b
1317   0C5A FD 2E 02 00   mov32 cb, $00000002
1317   0C5E 00 00 
1318   0C60 56            add b, a
1319   0C61 E4            pop a
1320   0C62             ; --- END TERMS
1321   0C62 E7            pop d
1322   0C63 FD 43         mov [d], b
1323   0C65             ; break; 
1324   0C65 0A 31 0D      jmp _switch39_exit ; case break
1325   0C68             _switch39_case4:
1326   0C68             ; print_unsigned(*(unsigned int*)p); 
1327   0C68             ; --- START FUNCTION CALL
1328   0C68 FA FF FF      lea d, [bp + -1] ; $p
1329   0C6B 2A            mov b, [d]
1330   0C6C 38 00 00      mov c, 0
1331   0C6F 74            mov d, b
1332   0C70 2A            mov b, [d]
1333   0C71 38 00 00      mov c, 0
1334   0C74 FD AB         swp b
1335   0C76 D8            push b
1336   0C77 07 FC 11      call print_unsigned
1337   0C7A 51 02 00      add sp, 2
1338   0C7D             ; --- END FUNCTION CALL
1339   0C7D             ; p = p + 2; 
1340   0C7D FA FF FF      lea d, [bp + -1] ; $p
1341   0C80 DA            push d
1342   0C81 FA FF FF      lea d, [bp + -1] ; $p
1343   0C84 2A            mov b, [d]
1344   0C85 38 00 00      mov c, 0
1345   0C88             ; --- START TERMS
1346   0C88 D7            push a
1347   0C89 11            mov a, b
1348   0C8A FD 2E 02 00   mov32 cb, $00000002
1348   0C8E 00 00 
1349   0C90 56            add b, a
1350   0C91 E4            pop a
1351   0C92             ; --- END TERMS
1352   0C92 E7            pop d
1353   0C93 FD 43         mov [d], b
1354   0C95             ; break; 
1355   0C95 0A 31 0D      jmp _switch39_exit ; case break
1356   0C98             _switch39_case5:
1357   0C98             ; printx16(*(int*)p); 
1358   0C98             ; --- START FUNCTION CALL
1359   0C98 FA FF FF      lea d, [bp + -1] ; $p
1360   0C9B 2A            mov b, [d]
1361   0C9C 38 00 00      mov c, 0
1362   0C9F 74            mov d, b
1363   0CA0 2A            mov b, [d]
1364   0CA1 38 00 00      mov c, 0
1365   0CA4 FD AB         swp b
1366   0CA6 D8            push b
1367   0CA7 07 0C 13      call printx16
1368   0CAA 51 02 00      add sp, 2
1369   0CAD             ; --- END FUNCTION CALL
1370   0CAD             ; p = p + 2; 
1371   0CAD FA FF FF      lea d, [bp + -1] ; $p
1372   0CB0 DA            push d
1373   0CB1 FA FF FF      lea d, [bp + -1] ; $p
1374   0CB4 2A            mov b, [d]
1375   0CB5 38 00 00      mov c, 0
1376   0CB8             ; --- START TERMS
1377   0CB8 D7            push a
1378   0CB9 11            mov a, b
1379   0CBA FD 2E 02 00   mov32 cb, $00000002
1379   0CBE 00 00 
1380   0CC0 56            add b, a
1381   0CC1 E4            pop a
1382   0CC2             ; --- END TERMS
1383   0CC2 E7            pop d
1384   0CC3 FD 43         mov [d], b
1385   0CC5             ; break; 
1386   0CC5 0A 31 0D      jmp _switch39_exit ; case break
1387   0CC8             _switch39_case6:
1388   0CC8             ; putchar(*(char*)p); 
1389   0CC8             ; --- START FUNCTION CALL
1390   0CC8 FA FF FF      lea d, [bp + -1] ; $p
1391   0CCB 2A            mov b, [d]
1392   0CCC 38 00 00      mov c, 0
1393   0CCF 74            mov d, b
1394   0CD0 32            mov bl, [d]
1395   0CD1 A7 00         mov bh, 0
1396   0CD3 38 00 00      mov c, 0
1397   0CD6 DD            push bl
1398   0CD7 07 EB 0E      call putchar
1399   0CDA 51 01 00      add sp, 1
1400   0CDD             ; --- END FUNCTION CALL
1401   0CDD             ; p = p + 1; 
1402   0CDD FA FF FF      lea d, [bp + -1] ; $p
1403   0CE0 DA            push d
1404   0CE1 FA FF FF      lea d, [bp + -1] ; $p
1405   0CE4 2A            mov b, [d]
1406   0CE5 38 00 00      mov c, 0
1407   0CE8             ; --- START TERMS
1408   0CE8 D7            push a
1409   0CE9 11            mov a, b
1410   0CEA FD 2E 01 00   mov32 cb, $00000001
1410   0CEE 00 00 
1411   0CF0 56            add b, a
1412   0CF1 E4            pop a
1413   0CF2             ; --- END TERMS
1414   0CF2 E7            pop d
1415   0CF3 FD 43         mov [d], b
1416   0CF5             ; break; 
1417   0CF5 0A 31 0D      jmp _switch39_exit ; case break
1418   0CF8             _switch39_case7:
1419   0CF8             ; print(*(char**)p); 
1420   0CF8             ; --- START FUNCTION CALL
1421   0CF8 FA FF FF      lea d, [bp + -1] ; $p
1422   0CFB 2A            mov b, [d]
1423   0CFC 38 00 00      mov c, 0
1424   0CFF 74            mov d, b
1425   0D00 2A            mov b, [d]
1426   0D01 FD AB         swp b
1427   0D03 D8            push b
1428   0D04 07 9A 10      call print
1429   0D07 51 02 00      add sp, 2
1430   0D0A             ; --- END FUNCTION CALL
1431   0D0A             ; p = p + 2; 
1432   0D0A FA FF FF      lea d, [bp + -1] ; $p
1433   0D0D DA            push d
1434   0D0E FA FF FF      lea d, [bp + -1] ; $p
1435   0D11 2A            mov b, [d]
1436   0D12 38 00 00      mov c, 0
1437   0D15             ; --- START TERMS
1438   0D15 D7            push a
1439   0D16 11            mov a, b
1440   0D17 FD 2E 02 00   mov32 cb, $00000002
1440   0D1B 00 00 
1441   0D1D 56            add b, a
1442   0D1E E4            pop a
1443   0D1F             ; --- END TERMS
1444   0D1F E7            pop d
1445   0D20 FD 43         mov [d], b
1446   0D22             ; break; 
1447   0D22 0A 31 0D      jmp _switch39_exit ; case break
1448   0D25             _switch39_default:
1449   0D25             ; print("Error: Unknown argument type.\n"); 
1450   0D25             ; --- START FUNCTION CALL
1451   0D25 26 FC 14      mov b, _s9 ; "Error: Unknown argument type.\n"
1452   0D28 FD AB         swp b
1453   0D2A D8            push b
1454   0D2B 07 9A 10      call print
1455   0D2E 51 02 00      add sp, 2
1456   0D31             ; --- END FUNCTION CALL
1457   0D31             _switch39_exit:
1458   0D31             ; format_p++; 
1459   0D31 FA FD FF      lea d, [bp + -3] ; $format_p
1460   0D34 2A            mov b, [d]
1461   0D35 38 00 00      mov c, 0
1462   0D38 FD 77         inc b
1463   0D3A FA FD FF      lea d, [bp + -3] ; $format_p
1464   0D3D FD 43         mov [d], b
1465   0D3F FD 7D         dec b
1466   0D41 0A 69 0D      jmp _if38_exit
1467   0D44             _if38_else:
1468   0D44             ; putchar(*format_p); 
1469   0D44             ; --- START FUNCTION CALL
1470   0D44 FA FD FF      lea d, [bp + -3] ; $format_p
1471   0D47 2A            mov b, [d]
1472   0D48 38 00 00      mov c, 0
1473   0D4B 74            mov d, b
1474   0D4C 32            mov bl, [d]
1475   0D4D A7 00         mov bh, 0
1476   0D4F 38 00 00      mov c, 0
1477   0D52 DD            push bl
1478   0D53 07 EB 0E      call putchar
1479   0D56 51 01 00      add sp, 1
1480   0D59             ; --- END FUNCTION CALL
1481   0D59             ; format_p++; 
1482   0D59 FA FD FF      lea d, [bp + -3] ; $format_p
1483   0D5C 2A            mov b, [d]
1484   0D5D 38 00 00      mov c, 0
1485   0D60 FD 77         inc b
1486   0D62 FA FD FF      lea d, [bp + -3] ; $format_p
1487   0D65 FD 43         mov [d], b
1488   0D67 FD 7D         dec b
1489   0D69             _if38_exit:
1490   0D69             _if37_exit:
1491   0D69             _for36_update:
1492   0D69 0A 9D 0A      jmp _for36_cond
1493   0D6C             _for36_exit:
1494   0D6C F9            leave
1495   0D6D 09            ret
1496   0D6E             
1497   0D6E             print_signed_long:
1498   0D6E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1499   0D71             ; char digits[10]; 
1500   0D71 52 0A 00      sub sp, 10
1501   0D74             ; int i = 0; 
1502   0D74 52 02 00      sub sp, 2
1503   0D77             ; --- START LOCAL VAR INITIALIZATION
1504   0D77 FA F5 FF      lea d, [bp + -11] ; $i
1505   0D7A DA            push d
1506   0D7B FD 2E 00 00   mov32 cb, $00000000
1506   0D7F 00 00 
1507   0D81 E7            pop d
1508   0D82 FD 43         mov [d], b
1509   0D84             ; --- END LOCAL VAR INITIALIZATION
1510   0D84             ; if (num < 0) { 
1511   0D84             _if43_cond:
1512   0D84 FA 05 00      lea d, [bp + 5] ; $num
1513   0D87 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1514   0D8A FD 39         mov c, b ; And place it into C
1515   0D8C 2A            mov b, [d] ; Lower Word in B
1516   0D8D             ; --- START RELATIONAL
1517   0D8D D7            push a
1518   0D8E FD D8         push g
1519   0D90 11            mov a, b
1520   0D91 FD 7A         mov g, c
1521   0D93 FD 2E 00 00   mov32 cb, $00000000
1521   0D97 00 00 
1522   0D99 FD AF         cmp32 ga, cb
1523   0D9B FD 73         slt ; <
1524   0D9D FD F1         pop g
1525   0D9F E4            pop a
1526   0DA0             ; --- END RELATIONAL
1527   0DA0 C0 00 00      cmp b, 0
1528   0DA3 C6 D5 0D      je _if43_else
1529   0DA6             _if43_TRUE:
1530   0DA6             ; putchar('-'); 
1531   0DA6             ; --- START FUNCTION CALL
1532   0DA6 FD 2E 2D 00   mov32 cb, $0000002d
1532   0DAA 00 00 
1533   0DAC DD            push bl
1534   0DAD 07 EB 0E      call putchar
1535   0DB0 51 01 00      add sp, 1
1536   0DB3             ; --- END FUNCTION CALL
1537   0DB3             ; num = -num; 
1538   0DB3 FA 05 00      lea d, [bp + 5] ; $num
1539   0DB6 DA            push d
1540   0DB7 FA 05 00      lea d, [bp + 5] ; $num
1541   0DBA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1542   0DBD FD 39         mov c, b ; And place it into C
1543   0DBF 2A            mov b, [d] ; Lower Word in B
1544   0DC0 12            mov a, c
1545   0DC1 95            not a
1546   0DC2 97            not b
1547   0DC3 55 01 00      add b, 1
1548   0DC6 5B 00 00      adc a, 0
1549   0DC9 39            mov c, a
1550   0DCA E7            pop d
1551   0DCB FD 43         mov [d], b
1552   0DCD 28            mov b, c
1553   0DCE FD 44 02 00   mov [d + 2], b
1554   0DD2 0A 09 0E      jmp _if43_exit
1555   0DD5             _if43_else:
1556   0DD5             ; if (num == 0) { 
1557   0DD5             _if44_cond:
1558   0DD5 FA 05 00      lea d, [bp + 5] ; $num
1559   0DD8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1560   0DDB FD 39         mov c, b ; And place it into C
1561   0DDD 2A            mov b, [d] ; Lower Word in B
1562   0DDE             ; --- START RELATIONAL
1563   0DDE D7            push a
1564   0DDF FD D8         push g
1565   0DE1 11            mov a, b
1566   0DE2 FD 7A         mov g, c
1567   0DE4 FD 2E 00 00   mov32 cb, $00000000
1567   0DE8 00 00 
1568   0DEA FD AF         cmp32 ga, cb
1569   0DEC FD 71         seq ; ==
1570   0DEE FD F1         pop g
1571   0DF0 E4            pop a
1572   0DF1             ; --- END RELATIONAL
1573   0DF1 C0 00 00      cmp b, 0
1574   0DF4 C6 09 0E      je _if44_exit
1575   0DF7             _if44_TRUE:
1576   0DF7             ; putchar('0'); 
1577   0DF7             ; --- START FUNCTION CALL
1578   0DF7 FD 2E 30 00   mov32 cb, $00000030
1578   0DFB 00 00 
1579   0DFD DD            push bl
1580   0DFE 07 EB 0E      call putchar
1581   0E01 51 01 00      add sp, 1
1582   0E04             ; --- END FUNCTION CALL
1583   0E04             ; return; 
1584   0E04 F9            leave
1585   0E05 09            ret
1586   0E06 0A 09 0E      jmp _if44_exit
1587   0E09             _if44_exit:
1588   0E09             _if43_exit:
1589   0E09             ; while (num > 0) { 
1590   0E09             _while45_cond:
1591   0E09 FA 05 00      lea d, [bp + 5] ; $num
1592   0E0C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1593   0E0F FD 39         mov c, b ; And place it into C
1594   0E11 2A            mov b, [d] ; Lower Word in B
1595   0E12             ; --- START RELATIONAL
1596   0E12 D7            push a
1597   0E13 FD D8         push g
1598   0E15 11            mov a, b
1599   0E16 FD 7A         mov g, c
1600   0E18 FD 2E 00 00   mov32 cb, $00000000
1600   0E1C 00 00 
1601   0E1E FD AF         cmp32 ga, cb
1602   0E20 FD 7F         sgt
1603   0E22 FD F1         pop g
1604   0E24 E4            pop a
1605   0E25             ; --- END RELATIONAL
1606   0E25 C0 00 00      cmp b, 0
1607   0E28 C6 A1 0E      je _while45_exit
1608   0E2B             _while45_block:
1609   0E2B             ; digits[i] = '0' + (num % 10); 
1610   0E2B FA F7 FF      lea d, [bp + -9] ; $digits
1611   0E2E D7            push a
1612   0E2F DA            push d
1613   0E30 FA F5 FF      lea d, [bp + -11] ; $i
1614   0E33 2A            mov b, [d]
1615   0E34 38 00 00      mov c, 0
1616   0E37 E7            pop d
1617   0E38 5A            add d, b
1618   0E39 E4            pop a
1619   0E3A DA            push d
1620   0E3B FD 2E 30 00   mov32 cb, $00000030
1620   0E3F 00 00 
1621   0E41             ; --- START TERMS
1622   0E41 D7            push a
1623   0E42 11            mov a, b
1624   0E43 FA 05 00      lea d, [bp + 5] ; $num
1625   0E46 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1626   0E49 FD 39         mov c, b ; And place it into C
1627   0E4B 2A            mov b, [d] ; Lower Word in B
1628   0E4C             ; --- START FACTORS
1629   0E4C D7            push a
1630   0E4D FD D8         push g
1631   0E4F 11            mov a, b
1632   0E50 FD 7A         mov g, c
1633   0E52 FD 2E 0A 00   mov32 cb, $0000000a
1633   0E56 00 00 
1634   0E58 AE            div a, b ; 
1635   0E59 11            mov a, b
1636   0E5A FD 38         mov c, g
1637   0E5C 27            mov b, a
1638   0E5D FD F1         pop g
1639   0E5F E4            pop a
1640   0E60             ; --- END FACTORS
1641   0E60 FD 15         add32 cb, ga
1642   0E62 E4            pop a
1643   0E63             ; --- END TERMS
1644   0E63 E7            pop d
1645   0E64 FD 3E         mov [d], bl
1646   0E66             ; num = num / 10; 
1647   0E66 FA 05 00      lea d, [bp + 5] ; $num
1648   0E69 DA            push d
1649   0E6A FA 05 00      lea d, [bp + 5] ; $num
1650   0E6D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1651   0E70 FD 39         mov c, b ; And place it into C
1652   0E72 2A            mov b, [d] ; Lower Word in B
1653   0E73             ; --- START FACTORS
1654   0E73 D7            push a
1655   0E74 FD D8         push g
1656   0E76 11            mov a, b
1657   0E77 FD 7A         mov g, c
1658   0E79 FD 2E 0A 00   mov32 cb, $0000000a
1658   0E7D 00 00 
1659   0E7F AE            div a, b
1660   0E80 FD 38         mov c, g
1661   0E82 27            mov b, a
1662   0E83 FD F1         pop g
1663   0E85 E4            pop a
1664   0E86             ; --- END FACTORS
1665   0E86 E7            pop d
1666   0E87 FD 43         mov [d], b
1667   0E89 28            mov b, c
1668   0E8A FD 44 02 00   mov [d + 2], b
1669   0E8E             ; i++; 
1670   0E8E FA F5 FF      lea d, [bp + -11] ; $i
1671   0E91 2A            mov b, [d]
1672   0E92 38 00 00      mov c, 0
1673   0E95 11            mov a, b
1674   0E96 FD 77         inc b
1675   0E98 FA F5 FF      lea d, [bp + -11] ; $i
1676   0E9B FD 43         mov [d], b
1677   0E9D 27            mov b, a
1678   0E9E 0A 09 0E      jmp _while45_cond
1679   0EA1             _while45_exit:
1680   0EA1             ; while (i > 0) { 
1681   0EA1             _while52_cond:
1682   0EA1 FA F5 FF      lea d, [bp + -11] ; $i
1683   0EA4 2A            mov b, [d]
1684   0EA5 38 00 00      mov c, 0
1685   0EA8             ; --- START RELATIONAL
1686   0EA8 D7            push a
1687   0EA9 11            mov a, b
1688   0EAA FD 2E 00 00   mov32 cb, $00000000
1688   0EAE 00 00 
1689   0EB0 B0            cmp a, b
1690   0EB1 FD 7F         sgt ; >
1691   0EB3 E4            pop a
1692   0EB4             ; --- END RELATIONAL
1693   0EB4 C0 00 00      cmp b, 0
1694   0EB7 C6 E9 0E      je _while52_exit
1695   0EBA             _while52_block:
1696   0EBA             ; i--; 
1697   0EBA FA F5 FF      lea d, [bp + -11] ; $i
1698   0EBD 2A            mov b, [d]
1699   0EBE 38 00 00      mov c, 0
1700   0EC1 11            mov a, b
1701   0EC2 FD 7D         dec b
1702   0EC4 FA F5 FF      lea d, [bp + -11] ; $i
1703   0EC7 FD 43         mov [d], b
1704   0EC9 27            mov b, a
1705   0ECA             ; putchar(digits[i]); 
1706   0ECA             ; --- START FUNCTION CALL
1707   0ECA FA F7 FF      lea d, [bp + -9] ; $digits
1708   0ECD D7            push a
1709   0ECE DA            push d
1710   0ECF FA F5 FF      lea d, [bp + -11] ; $i
1711   0ED2 2A            mov b, [d]
1712   0ED3 38 00 00      mov c, 0
1713   0ED6 E7            pop d
1714   0ED7 5A            add d, b
1715   0ED8 E4            pop a
1716   0ED9 32            mov bl, [d]
1717   0EDA A7 00         mov bh, 0
1718   0EDC 38 00 00      mov c, 0
1719   0EDF DD            push bl
1720   0EE0 07 EB 0E      call putchar
1721   0EE3 51 01 00      add sp, 1
1722   0EE6             ; --- END FUNCTION CALL
1723   0EE6 0A A1 0E      jmp _while52_cond
1724   0EE9             _while52_exit:
1725   0EE9 F9            leave
1726   0EEA 09            ret
1727   0EEB             
1728   0EEB             putchar:
1729   0EEB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1730   0EEE             ; --- BEGIN INLINE ASM SEGMENT
1731   0EEE FA 05 00      lea d, [bp + 5] ; $c
1732   0EF1 1E            mov al, [d]
1733   0EF2 23            mov ah, al
1734   0EF3 19 00         mov al, 0
1735   0EF5 05 03         syscall sys_io      ; char in AH
1736   0EF7             ; --- END INLINE ASM SEGMENT
1737   0EF7 F9            leave
1738   0EF8 09            ret
1739   0EF9             
1740   0EF9             print_unsigned_long:
1741   0EF9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1742   0EFC             ; char digits[10]; 
1743   0EFC 52 0A 00      sub sp, 10
1744   0EFF             ; int i; 
1745   0EFF 52 02 00      sub sp, 2
1746   0F02             ; i = 0; 
1747   0F02 FA F5 FF      lea d, [bp + -11] ; $i
1748   0F05 DA            push d
1749   0F06 FD 2E 00 00   mov32 cb, $00000000
1749   0F0A 00 00 
1750   0F0C E7            pop d
1751   0F0D FD 43         mov [d], b
1752   0F0F             ; if(num == 0){ 
1753   0F0F             _if53_cond:
1754   0F0F FA 05 00      lea d, [bp + 5] ; $num
1755   0F12 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1756   0F15 FD 39         mov c, b ; And place it into C
1757   0F17 2A            mov b, [d] ; Lower Word in B
1758   0F18             ; --- START RELATIONAL
1759   0F18 D7            push a
1760   0F19 FD D8         push g
1761   0F1B 11            mov a, b
1762   0F1C FD 7A         mov g, c
1763   0F1E FD 2E 00 00   mov32 cb, $00000000
1763   0F22 00 00 
1764   0F24 FD AF         cmp32 ga, cb
1765   0F26 FD 71         seq ; ==
1766   0F28 FD F1         pop g
1767   0F2A E4            pop a
1768   0F2B             ; --- END RELATIONAL
1769   0F2B C0 00 00      cmp b, 0
1770   0F2E C6 43 0F      je _if53_exit
1771   0F31             _if53_TRUE:
1772   0F31             ; putchar('0'); 
1773   0F31             ; --- START FUNCTION CALL
1774   0F31 FD 2E 30 00   mov32 cb, $00000030
1774   0F35 00 00 
1775   0F37 DD            push bl
1776   0F38 07 EB 0E      call putchar
1777   0F3B 51 01 00      add sp, 1
1778   0F3E             ; --- END FUNCTION CALL
1779   0F3E             ; return; 
1780   0F3E F9            leave
1781   0F3F 09            ret
1782   0F40 0A 43 0F      jmp _if53_exit
1783   0F43             _if53_exit:
1784   0F43             ; while (num > 0) { 
1785   0F43             _while54_cond:
1786   0F43 FA 05 00      lea d, [bp + 5] ; $num
1787   0F46 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1788   0F49 FD 39         mov c, b ; And place it into C
1789   0F4B 2A            mov b, [d] ; Lower Word in B
1790   0F4C             ; --- START RELATIONAL
1791   0F4C D7            push a
1792   0F4D FD D8         push g
1793   0F4F 11            mov a, b
1794   0F50 FD 7A         mov g, c
1795   0F52 FD 2E 00 00   mov32 cb, $00000000
1795   0F56 00 00 
1796   0F58 FD AF         cmp32 ga, cb
1797   0F5A FD 81         sgu
1798   0F5C FD F1         pop g
1799   0F5E E4            pop a
1800   0F5F             ; --- END RELATIONAL
1801   0F5F C0 00 00      cmp b, 0
1802   0F62 C6 DB 0F      je _while54_exit
1803   0F65             _while54_block:
1804   0F65             ; digits[i] = '0' + (num % 10); 
1805   0F65 FA F7 FF      lea d, [bp + -9] ; $digits
1806   0F68 D7            push a
1807   0F69 DA            push d
1808   0F6A FA F5 FF      lea d, [bp + -11] ; $i
1809   0F6D 2A            mov b, [d]
1810   0F6E 38 00 00      mov c, 0
1811   0F71 E7            pop d
1812   0F72 5A            add d, b
1813   0F73 E4            pop a
1814   0F74 DA            push d
1815   0F75 FD 2E 30 00   mov32 cb, $00000030
1815   0F79 00 00 
1816   0F7B             ; --- START TERMS
1817   0F7B D7            push a
1818   0F7C 11            mov a, b
1819   0F7D FA 05 00      lea d, [bp + 5] ; $num
1820   0F80 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1821   0F83 FD 39         mov c, b ; And place it into C
1822   0F85 2A            mov b, [d] ; Lower Word in B
1823   0F86             ; --- START FACTORS
1824   0F86 D7            push a
1825   0F87 FD D8         push g
1826   0F89 11            mov a, b
1827   0F8A FD 7A         mov g, c
1828   0F8C FD 2E 0A 00   mov32 cb, $0000000a
1828   0F90 00 00 
1829   0F92 AE            div a, b ; 
1830   0F93 11            mov a, b
1831   0F94 FD 38         mov c, g
1832   0F96 27            mov b, a
1833   0F97 FD F1         pop g
1834   0F99 E4            pop a
1835   0F9A             ; --- END FACTORS
1836   0F9A FD 15         add32 cb, ga
1837   0F9C E4            pop a
1838   0F9D             ; --- END TERMS
1839   0F9D E7            pop d
1840   0F9E FD 3E         mov [d], bl
1841   0FA0             ; num = num / 10; 
1842   0FA0 FA 05 00      lea d, [bp + 5] ; $num
1843   0FA3 DA            push d
1844   0FA4 FA 05 00      lea d, [bp + 5] ; $num
1845   0FA7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1846   0FAA FD 39         mov c, b ; And place it into C
1847   0FAC 2A            mov b, [d] ; Lower Word in B
1848   0FAD             ; --- START FACTORS
1849   0FAD D7            push a
1850   0FAE FD D8         push g
1851   0FB0 11            mov a, b
1852   0FB1 FD 7A         mov g, c
1853   0FB3 FD 2E 0A 00   mov32 cb, $0000000a
1853   0FB7 00 00 
1854   0FB9 AE            div a, b
1855   0FBA FD 38         mov c, g
1856   0FBC 27            mov b, a
1857   0FBD FD F1         pop g
1858   0FBF E4            pop a
1859   0FC0             ; --- END FACTORS
1860   0FC0 E7            pop d
1861   0FC1 FD 43         mov [d], b
1862   0FC3 28            mov b, c
1863   0FC4 FD 44 02 00   mov [d + 2], b
1864   0FC8             ; i++; 
1865   0FC8 FA F5 FF      lea d, [bp + -11] ; $i
1866   0FCB 2A            mov b, [d]
1867   0FCC 38 00 00      mov c, 0
1868   0FCF 11            mov a, b
1869   0FD0 FD 77         inc b
1870   0FD2 FA F5 FF      lea d, [bp + -11] ; $i
1871   0FD5 FD 43         mov [d], b
1872   0FD7 27            mov b, a
1873   0FD8 0A 43 0F      jmp _while54_cond
1874   0FDB             _while54_exit:
1875   0FDB             ; while (i > 0) { 
1876   0FDB             _while61_cond:
1877   0FDB FA F5 FF      lea d, [bp + -11] ; $i
1878   0FDE 2A            mov b, [d]
1879   0FDF 38 00 00      mov c, 0
1880   0FE2             ; --- START RELATIONAL
1881   0FE2 D7            push a
1882   0FE3 11            mov a, b
1883   0FE4 FD 2E 00 00   mov32 cb, $00000000
1883   0FE8 00 00 
1884   0FEA B0            cmp a, b
1885   0FEB FD 7F         sgt ; >
1886   0FED E4            pop a
1887   0FEE             ; --- END RELATIONAL
1888   0FEE C0 00 00      cmp b, 0
1889   0FF1 C6 23 10      je _while61_exit
1890   0FF4             _while61_block:
1891   0FF4             ; i--; 
1892   0FF4 FA F5 FF      lea d, [bp + -11] ; $i
1893   0FF7 2A            mov b, [d]
1894   0FF8 38 00 00      mov c, 0
1895   0FFB 11            mov a, b
1896   0FFC FD 7D         dec b
1897   0FFE FA F5 FF      lea d, [bp + -11] ; $i
1898   1001 FD 43         mov [d], b
1899   1003 27            mov b, a
1900   1004             ; putchar(digits[i]); 
1901   1004             ; --- START FUNCTION CALL
1902   1004 FA F7 FF      lea d, [bp + -9] ; $digits
1903   1007 D7            push a
1904   1008 DA            push d
1905   1009 FA F5 FF      lea d, [bp + -11] ; $i
1906   100C 2A            mov b, [d]
1907   100D 38 00 00      mov c, 0
1908   1010 E7            pop d
1909   1011 5A            add d, b
1910   1012 E4            pop a
1911   1013 32            mov bl, [d]
1912   1014 A7 00         mov bh, 0
1913   1016 38 00 00      mov c, 0
1914   1019 DD            push bl
1915   101A 07 EB 0E      call putchar
1916   101D 51 01 00      add sp, 1
1917   1020             ; --- END FUNCTION CALL
1918   1020 0A DB 0F      jmp _while61_cond
1919   1023             _while61_exit:
1920   1023 F9            leave
1921   1024 09            ret
1922   1025             
1923   1025             printx32:
1924   1025 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1925   1028             ; --- BEGIN INLINE ASM SEGMENT
1926   1028 FA 05 00      lea d, [bp + 5] ; $hex
1927   102B 2B 02 00      mov b, [d+2]
1928   102E 07 37 10      call print_u16x_printx32
1929   1031 2A            mov b, [d]
1930   1032 07 37 10      call print_u16x_printx32
1931   1035             ; --- END INLINE ASM SEGMENT
1932   1035             ; return; 
1933   1035 F9            leave
1934   1036 09            ret
1935   1037             ; --- BEGIN INLINE ASM SEGMENT
1936   1037             print_u16x_printx32:
1937   1037 D7            push a
1938   1038 D8            push b
1939   1039 DD            push bl
1940   103A 30            mov bl, bh
1941   103B 07 59 10      call _itoa_printx32        ; convert bh to char in A
1942   103E 2F            mov bl, al        ; save al
1943   103F 19 00         mov al, 0
1944   1041 05 03         syscall sys_io        ; display AH
1945   1043 24            mov ah, bl        ; retrieve al
1946   1044 19 00         mov al, 0
1947   1046 05 03         syscall sys_io        ; display AL
1948   1048 EA            pop bl
1949   1049 07 59 10      call _itoa_printx32        ; convert bh to char in A
1950   104C 2F            mov bl, al        ; save al
1951   104D 19 00         mov al, 0
1952   104F 05 03         syscall sys_io        ; display AH
1953   1051 24            mov ah, bl        ; retrieve al
1954   1052 19 00         mov al, 0
1955   1054 05 03         syscall sys_io        ; display AL
1956   1056 E5            pop b
1957   1057 E4            pop a
1958   1058 09            ret
1959   1059             _itoa_printx32:
1960   1059 DA            push d
1961   105A D8            push b
1962   105B A7 00         mov bh, 0
1963   105D FD A4 04      shr bl, 4  
1964   1060 74            mov d, b
1965   1061 1F 73 10      mov al, [d + s_hex_digits_printx32]
1966   1064 23            mov ah, al
1967   1065 E5            pop b
1968   1066 D8            push b
1969   1067 A7 00         mov bh, 0
1970   1069 FD 87 0F      and bl, $0F
1971   106C 74            mov d, b
1972   106D 1F 73 10      mov al, [d + s_hex_digits_printx32]
1973   1070 E5            pop b
1974   1071 E7            pop d
1975   1072 09            ret
1976   1073 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1976   1077 34 35 36 37 
1976   107B 38 39 41 42 
1976   107F 43 44 45 46 
1977   1083             ; --- END INLINE ASM SEGMENT
1978   1083 F9            leave
1979   1084 09            ret
1980   1085             
1981   1085             err:
1982   1085 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1983   1088             ; print(e); 
1984   1088             ; --- START FUNCTION CALL
1985   1088 FA 05 00      lea d, [bp + 5] ; $e
1986   108B 2A            mov b, [d]
1987   108C 38 00 00      mov c, 0
1988   108F FD AB         swp b
1989   1091 D8            push b
1990   1092 07 9A 10      call print
1991   1095 51 02 00      add sp, 2
1992   1098             ; --- END FUNCTION CALL
1993   1098 F9            leave
1994   1099 09            ret
1995   109A             
1996   109A             print:
1997   109A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1998   109D             ; --- BEGIN INLINE ASM SEGMENT
1999   109D FA 05 00      lea d, [bp + 5] ; $s
2000   10A0 FD 2A         mov d, [d]
2001   10A2             _puts_L1_print:
2002   10A2 1E            mov al, [d]
2003   10A3 B9 00         cmp al, 0
2004   10A5 C6 B1 10      jz _puts_END_print
2005   10A8 23            mov ah, al
2006   10A9 19 00         mov al, 0
2007   10AB 05 03         syscall sys_io
2008   10AD 79            inc d
2009   10AE 0A A2 10      jmp _puts_L1_print
2010   10B1             _puts_END_print:
2011   10B1             ; --- END INLINE ASM SEGMENT
2012   10B1 F9            leave
2013   10B2 09            ret
2014   10B3             
2015   10B3             print_signed:
2016   10B3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2017   10B6             ; char digits[5]; 
2018   10B6 52 05 00      sub sp, 5
2019   10B9             ; int i = 0; 
2020   10B9 52 02 00      sub sp, 2
2021   10BC             ; --- START LOCAL VAR INITIALIZATION
2022   10BC FA FA FF      lea d, [bp + -6] ; $i
2023   10BF DA            push d
2024   10C0 FD 2E 00 00   mov32 cb, $00000000
2024   10C4 00 00 
2025   10C6 E7            pop d
2026   10C7 FD 43         mov [d], b
2027   10C9             ; --- END LOCAL VAR INITIALIZATION
2028   10C9             ; if (num < 0) { 
2029   10C9             _if62_cond:
2030   10C9 FA 05 00      lea d, [bp + 5] ; $num
2031   10CC 2A            mov b, [d]
2032   10CD 38 00 00      mov c, 0
2033   10D0             ; --- START RELATIONAL
2034   10D0 D7            push a
2035   10D1 11            mov a, b
2036   10D2 FD 2E 00 00   mov32 cb, $00000000
2036   10D6 00 00 
2037   10D8 B0            cmp a, b
2038   10D9 FD 73         slt ; < (signed)
2039   10DB E4            pop a
2040   10DC             ; --- END RELATIONAL
2041   10DC C0 00 00      cmp b, 0
2042   10DF C6 02 11      je _if62_else
2043   10E2             _if62_TRUE:
2044   10E2             ; putchar('-'); 
2045   10E2             ; --- START FUNCTION CALL
2046   10E2 FD 2E 2D 00   mov32 cb, $0000002d
2046   10E6 00 00 
2047   10E8 DD            push bl
2048   10E9 07 EB 0E      call putchar
2049   10EC 51 01 00      add sp, 1
2050   10EF             ; --- END FUNCTION CALL
2051   10EF             ; num = -num; 
2052   10EF FA 05 00      lea d, [bp + 5] ; $num
2053   10F2 DA            push d
2054   10F3 FA 05 00      lea d, [bp + 5] ; $num
2055   10F6 2A            mov b, [d]
2056   10F7 38 00 00      mov c, 0
2057   10FA FD 97         neg b
2058   10FC E7            pop d
2059   10FD FD 43         mov [d], b
2060   10FF 0A 2D 11      jmp _if62_exit
2061   1102             _if62_else:
2062   1102             ; if (num == 0) { 
2063   1102             _if63_cond:
2064   1102 FA 05 00      lea d, [bp + 5] ; $num
2065   1105 2A            mov b, [d]
2066   1106 38 00 00      mov c, 0
2067   1109             ; --- START RELATIONAL
2068   1109 D7            push a
2069   110A 11            mov a, b
2070   110B FD 2E 00 00   mov32 cb, $00000000
2070   110F 00 00 
2071   1111 B0            cmp a, b
2072   1112 FD 71         seq ; ==
2073   1114 E4            pop a
2074   1115             ; --- END RELATIONAL
2075   1115 C0 00 00      cmp b, 0
2076   1118 C6 2D 11      je _if63_exit
2077   111B             _if63_TRUE:
2078   111B             ; putchar('0'); 
2079   111B             ; --- START FUNCTION CALL
2080   111B FD 2E 30 00   mov32 cb, $00000030
2080   111F 00 00 
2081   1121 DD            push bl
2082   1122 07 EB 0E      call putchar
2083   1125 51 01 00      add sp, 1
2084   1128             ; --- END FUNCTION CALL
2085   1128             ; return; 
2086   1128 F9            leave
2087   1129 09            ret
2088   112A 0A 2D 11      jmp _if63_exit
2089   112D             _if63_exit:
2090   112D             _if62_exit:
2091   112D             ; while (num > 0) { 
2092   112D             _while64_cond:
2093   112D FA 05 00      lea d, [bp + 5] ; $num
2094   1130 2A            mov b, [d]
2095   1131 38 00 00      mov c, 0
2096   1134             ; --- START RELATIONAL
2097   1134 D7            push a
2098   1135 11            mov a, b
2099   1136 FD 2E 00 00   mov32 cb, $00000000
2099   113A 00 00 
2100   113C B0            cmp a, b
2101   113D FD 7F         sgt ; >
2102   113F E4            pop a
2103   1140             ; --- END RELATIONAL
2104   1140 C0 00 00      cmp b, 0
2105   1143 C6 B2 11      je _while64_exit
2106   1146             _while64_block:
2107   1146             ; digits[i] = '0' + (num % 10); 
2108   1146 FA FC FF      lea d, [bp + -4] ; $digits
2109   1149 D7            push a
2110   114A DA            push d
2111   114B FA FA FF      lea d, [bp + -6] ; $i
2112   114E 2A            mov b, [d]
2113   114F 38 00 00      mov c, 0
2114   1152 E7            pop d
2115   1153 5A            add d, b
2116   1154 E4            pop a
2117   1155 DA            push d
2118   1156 FD 2E 30 00   mov32 cb, $00000030
2118   115A 00 00 
2119   115C             ; --- START TERMS
2120   115C D7            push a
2121   115D 11            mov a, b
2122   115E FA 05 00      lea d, [bp + 5] ; $num
2123   1161 2A            mov b, [d]
2124   1162 38 00 00      mov c, 0
2125   1165             ; --- START FACTORS
2126   1165 D7            push a
2127   1166 FD D8         push g
2128   1168 11            mov a, b
2129   1169 FD 7A         mov g, c
2130   116B FD 2E 0A 00   mov32 cb, $0000000a
2130   116F 00 00 
2131   1171 AE            div a, b ; 
2132   1172 11            mov a, b
2133   1173 FD 38         mov c, g
2134   1175 27            mov b, a
2135   1176 FD F1         pop g
2136   1178 E4            pop a
2137   1179             ; --- END FACTORS
2138   1179 56            add b, a
2139   117A E4            pop a
2140   117B             ; --- END TERMS
2141   117B E7            pop d
2142   117C FD 3E         mov [d], bl
2143   117E             ; num = num / 10; 
2144   117E FA 05 00      lea d, [bp + 5] ; $num
2145   1181 DA            push d
2146   1182 FA 05 00      lea d, [bp + 5] ; $num
2147   1185 2A            mov b, [d]
2148   1186 38 00 00      mov c, 0
2149   1189             ; --- START FACTORS
2150   1189 D7            push a
2151   118A FD D8         push g
2152   118C 11            mov a, b
2153   118D FD 7A         mov g, c
2154   118F FD 2E 0A 00   mov32 cb, $0000000a
2154   1193 00 00 
2155   1195 AE            div a, b
2156   1196 FD 38         mov c, g
2157   1198 27            mov b, a
2158   1199 FD F1         pop g
2159   119B E4            pop a
2160   119C             ; --- END FACTORS
2161   119C E7            pop d
2162   119D FD 43         mov [d], b
2163   119F             ; i++; 
2164   119F FA FA FF      lea d, [bp + -6] ; $i
2165   11A2 2A            mov b, [d]
2166   11A3 38 00 00      mov c, 0
2167   11A6 11            mov a, b
2168   11A7 FD 77         inc b
2169   11A9 FA FA FF      lea d, [bp + -6] ; $i
2170   11AC FD 43         mov [d], b
2171   11AE 27            mov b, a
2172   11AF 0A 2D 11      jmp _while64_cond
2173   11B2             _while64_exit:
2174   11B2             ; while (i > 0) { 
2175   11B2             _while71_cond:
2176   11B2 FA FA FF      lea d, [bp + -6] ; $i
2177   11B5 2A            mov b, [d]
2178   11B6 38 00 00      mov c, 0
2179   11B9             ; --- START RELATIONAL
2180   11B9 D7            push a
2181   11BA 11            mov a, b
2182   11BB FD 2E 00 00   mov32 cb, $00000000
2182   11BF 00 00 
2183   11C1 B0            cmp a, b
2184   11C2 FD 7F         sgt ; >
2185   11C4 E4            pop a
2186   11C5             ; --- END RELATIONAL
2187   11C5 C0 00 00      cmp b, 0
2188   11C8 C6 FA 11      je _while71_exit
2189   11CB             _while71_block:
2190   11CB             ; i--; 
2191   11CB FA FA FF      lea d, [bp + -6] ; $i
2192   11CE 2A            mov b, [d]
2193   11CF 38 00 00      mov c, 0
2194   11D2 11            mov a, b
2195   11D3 FD 7D         dec b
2196   11D5 FA FA FF      lea d, [bp + -6] ; $i
2197   11D8 FD 43         mov [d], b
2198   11DA 27            mov b, a
2199   11DB             ; putchar(digits[i]); 
2200   11DB             ; --- START FUNCTION CALL
2201   11DB FA FC FF      lea d, [bp + -4] ; $digits
2202   11DE D7            push a
2203   11DF DA            push d
2204   11E0 FA FA FF      lea d, [bp + -6] ; $i
2205   11E3 2A            mov b, [d]
2206   11E4 38 00 00      mov c, 0
2207   11E7 E7            pop d
2208   11E8 5A            add d, b
2209   11E9 E4            pop a
2210   11EA 32            mov bl, [d]
2211   11EB A7 00         mov bh, 0
2212   11ED 38 00 00      mov c, 0
2213   11F0 DD            push bl
2214   11F1 07 EB 0E      call putchar
2215   11F4 51 01 00      add sp, 1
2216   11F7             ; --- END FUNCTION CALL
2217   11F7 0A B2 11      jmp _while71_cond
2218   11FA             _while71_exit:
2219   11FA F9            leave
2220   11FB 09            ret
2221   11FC             
2222   11FC             print_unsigned:
2223   11FC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2224   11FF             ; char digits[5]; 
2225   11FF 52 05 00      sub sp, 5
2226   1202             ; int i; 
2227   1202 52 02 00      sub sp, 2
2228   1205             ; i = 0; 
2229   1205 FA FA FF      lea d, [bp + -6] ; $i
2230   1208 DA            push d
2231   1209 FD 2E 00 00   mov32 cb, $00000000
2231   120D 00 00 
2232   120F E7            pop d
2233   1210 FD 43         mov [d], b
2234   1212             ; if(num == 0){ 
2235   1212             _if72_cond:
2236   1212 FA 05 00      lea d, [bp + 5] ; $num
2237   1215 2A            mov b, [d]
2238   1216 38 00 00      mov c, 0
2239   1219             ; --- START RELATIONAL
2240   1219 D7            push a
2241   121A 11            mov a, b
2242   121B FD 2E 00 00   mov32 cb, $00000000
2242   121F 00 00 
2243   1221 B0            cmp a, b
2244   1222 FD 71         seq ; ==
2245   1224 E4            pop a
2246   1225             ; --- END RELATIONAL
2247   1225 C0 00 00      cmp b, 0
2248   1228 C6 3D 12      je _if72_exit
2249   122B             _if72_TRUE:
2250   122B             ; putchar('0'); 
2251   122B             ; --- START FUNCTION CALL
2252   122B FD 2E 30 00   mov32 cb, $00000030
2252   122F 00 00 
2253   1231 DD            push bl
2254   1232 07 EB 0E      call putchar
2255   1235 51 01 00      add sp, 1
2256   1238             ; --- END FUNCTION CALL
2257   1238             ; return; 
2258   1238 F9            leave
2259   1239 09            ret
2260   123A 0A 3D 12      jmp _if72_exit
2261   123D             _if72_exit:
2262   123D             ; while (num > 0) { 
2263   123D             _while73_cond:
2264   123D FA 05 00      lea d, [bp + 5] ; $num
2265   1240 2A            mov b, [d]
2266   1241 38 00 00      mov c, 0
2267   1244             ; --- START RELATIONAL
2268   1244 D7            push a
2269   1245 11            mov a, b
2270   1246 FD 2E 00 00   mov32 cb, $00000000
2270   124A 00 00 
2271   124C B0            cmp a, b
2272   124D FD 81         sgu ; > (unsigned)
2273   124F E4            pop a
2274   1250             ; --- END RELATIONAL
2275   1250 C0 00 00      cmp b, 0
2276   1253 C6 C2 12      je _while73_exit
2277   1256             _while73_block:
2278   1256             ; digits[i] = '0' + (num % 10); 
2279   1256 FA FC FF      lea d, [bp + -4] ; $digits
2280   1259 D7            push a
2281   125A DA            push d
2282   125B FA FA FF      lea d, [bp + -6] ; $i
2283   125E 2A            mov b, [d]
2284   125F 38 00 00      mov c, 0
2285   1262 E7            pop d
2286   1263 5A            add d, b
2287   1264 E4            pop a
2288   1265 DA            push d
2289   1266 FD 2E 30 00   mov32 cb, $00000030
2289   126A 00 00 
2290   126C             ; --- START TERMS
2291   126C D7            push a
2292   126D 11            mov a, b
2293   126E FA 05 00      lea d, [bp + 5] ; $num
2294   1271 2A            mov b, [d]
2295   1272 38 00 00      mov c, 0
2296   1275             ; --- START FACTORS
2297   1275 D7            push a
2298   1276 FD D8         push g
2299   1278 11            mov a, b
2300   1279 FD 7A         mov g, c
2301   127B FD 2E 0A 00   mov32 cb, $0000000a
2301   127F 00 00 
2302   1281 AE            div a, b ; 
2303   1282 11            mov a, b
2304   1283 FD 38         mov c, g
2305   1285 27            mov b, a
2306   1286 FD F1         pop g
2307   1288 E4            pop a
2308   1289             ; --- END FACTORS
2309   1289 56            add b, a
2310   128A E4            pop a
2311   128B             ; --- END TERMS
2312   128B E7            pop d
2313   128C FD 3E         mov [d], bl
2314   128E             ; num = num / 10; 
2315   128E FA 05 00      lea d, [bp + 5] ; $num
2316   1291 DA            push d
2317   1292 FA 05 00      lea d, [bp + 5] ; $num
2318   1295 2A            mov b, [d]
2319   1296 38 00 00      mov c, 0
2320   1299             ; --- START FACTORS
2321   1299 D7            push a
2322   129A FD D8         push g
2323   129C 11            mov a, b
2324   129D FD 7A         mov g, c
2325   129F FD 2E 0A 00   mov32 cb, $0000000a
2325   12A3 00 00 
2326   12A5 AE            div a, b
2327   12A6 FD 38         mov c, g
2328   12A8 27            mov b, a
2329   12A9 FD F1         pop g
2330   12AB E4            pop a
2331   12AC             ; --- END FACTORS
2332   12AC E7            pop d
2333   12AD FD 43         mov [d], b
2334   12AF             ; i++; 
2335   12AF FA FA FF      lea d, [bp + -6] ; $i
2336   12B2 2A            mov b, [d]
2337   12B3 38 00 00      mov c, 0
2338   12B6 11            mov a, b
2339   12B7 FD 77         inc b
2340   12B9 FA FA FF      lea d, [bp + -6] ; $i
2341   12BC FD 43         mov [d], b
2342   12BE 27            mov b, a
2343   12BF 0A 3D 12      jmp _while73_cond
2344   12C2             _while73_exit:
2345   12C2             ; while (i > 0) { 
2346   12C2             _while80_cond:
2347   12C2 FA FA FF      lea d, [bp + -6] ; $i
2348   12C5 2A            mov b, [d]
2349   12C6 38 00 00      mov c, 0
2350   12C9             ; --- START RELATIONAL
2351   12C9 D7            push a
2352   12CA 11            mov a, b
2353   12CB FD 2E 00 00   mov32 cb, $00000000
2353   12CF 00 00 
2354   12D1 B0            cmp a, b
2355   12D2 FD 7F         sgt ; >
2356   12D4 E4            pop a
2357   12D5             ; --- END RELATIONAL
2358   12D5 C0 00 00      cmp b, 0
2359   12D8 C6 0A 13      je _while80_exit
2360   12DB             _while80_block:
2361   12DB             ; i--; 
2362   12DB FA FA FF      lea d, [bp + -6] ; $i
2363   12DE 2A            mov b, [d]
2364   12DF 38 00 00      mov c, 0
2365   12E2 11            mov a, b
2366   12E3 FD 7D         dec b
2367   12E5 FA FA FF      lea d, [bp + -6] ; $i
2368   12E8 FD 43         mov [d], b
2369   12EA 27            mov b, a
2370   12EB             ; putchar(digits[i]); 
2371   12EB             ; --- START FUNCTION CALL
2372   12EB FA FC FF      lea d, [bp + -4] ; $digits
2373   12EE D7            push a
2374   12EF DA            push d
2375   12F0 FA FA FF      lea d, [bp + -6] ; $i
2376   12F3 2A            mov b, [d]
2377   12F4 38 00 00      mov c, 0
2378   12F7 E7            pop d
2379   12F8 5A            add d, b
2380   12F9 E4            pop a
2381   12FA 32            mov bl, [d]
2382   12FB A7 00         mov bh, 0
2383   12FD 38 00 00      mov c, 0
2384   1300 DD            push bl
2385   1301 07 EB 0E      call putchar
2386   1304 51 01 00      add sp, 1
2387   1307             ; --- END FUNCTION CALL
2388   1307 0A C2 12      jmp _while80_cond
2389   130A             _while80_exit:
2390   130A F9            leave
2391   130B 09            ret
2392   130C             
2393   130C             printx16:
2394   130C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2395   130F             ; --- BEGIN INLINE ASM SEGMENT
2396   130F FA 05 00      lea d, [bp + 5] ; $hex
2397   1312 2A            mov b, [d]
2398   1313             print_u16x_printx16:
2399   1313 DD            push bl
2400   1314 30            mov bl, bh
2401   1315 07 32 13      call _itoa_printx16        ; convert bh to char in A
2402   1318 2F            mov bl, al        ; save al
2403   1319 19 00         mov al, 0
2404   131B 05 03         syscall sys_io        ; display AH
2405   131D 24            mov ah, bl        ; retrieve al
2406   131E 19 00         mov al, 0
2407   1320 05 03         syscall sys_io        ; display AL
2408   1322 EA            pop bl
2409   1323 07 32 13      call _itoa_printx16        ; convert bh to char in A
2410   1326 2F            mov bl, al        ; save al
2411   1327 19 00         mov al, 0
2412   1329 05 03         syscall sys_io        ; display AH
2413   132B 24            mov ah, bl        ; retrieve al
2414   132C 19 00         mov al, 0
2415   132E 05 03         syscall sys_io        ; display AL
2416   1330             ; --- END INLINE ASM SEGMENT
2417   1330             ; return; 
2418   1330 F9            leave
2419   1331 09            ret
2420   1332             ; --- BEGIN INLINE ASM SEGMENT
2421   1332             _itoa_printx16:
2422   1332 DA            push d
2423   1333 D8            push b
2424   1334 A7 00         mov bh, 0
2425   1336 FD A4 04      shr bl, 4  
2426   1339 74            mov d, b
2427   133A 1F 4C 13      mov al, [d + s_hex_digits_printx16]
2428   133D 23            mov ah, al
2429   133E E5            pop b
2430   133F D8            push b
2431   1340 A7 00         mov bh, 0
2432   1342 FD 87 0F      and bl, $0F
2433   1345 74            mov d, b
2434   1346 1F 4C 13      mov al, [d + s_hex_digits_printx16]
2435   1349 E5            pop b
2436   134A E7            pop d
2437   134B 09            ret
2438   134C 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
2438   1350 34 35 36 37 
2438   1354 38 39 41 42 
2438   1358 43 44 45 46 
2439   135C             ; --- END INLINE ASM SEGMENT
2440   135C F9            leave
2441   135D 09            ret
2442   135E             
2443   135E             gets:
2444   135E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2445   1361             ; --- BEGIN INLINE ASM SEGMENT
2446   1361 FA 05 00      lea d, [bp + 5] ; $s
2447   1364 15            mov a, [d]
2448   1365 3C            mov d, a
2449   1366 07 7B 13      call _gets_gets
2450   1369             ; --- END INLINE ASM SEGMENT
2451   1369             ; return strlen(s); 
2452   1369             ; --- START FUNCTION CALL
2453   1369 FA 05 00      lea d, [bp + 5] ; $s
2454   136C 2A            mov b, [d]
2455   136D 38 00 00      mov c, 0
2456   1370 FD AB         swp b
2457   1372 D8            push b
2458   1373 07 1C 14      call strlen
2459   1376 51 02 00      add sp, 2
2460   1379             ; --- END FUNCTION CALL
2461   1379 F9            leave
2462   137A 09            ret
2463   137B             ; --- BEGIN INLINE ASM SEGMENT
2464   137B             _gets_gets:
2465   137B D7            push a
2466   137C DA            push d
2467   137D             _gets_loop_gets:
2468   137D 19 01         mov al, 1
2469   137F 05 03         syscall sys_io      ; receive in AH
2470   1381 B9 00         cmp al, 0        ; check error code (AL)
2471   1383 C6 7D 13      je _gets_loop_gets      ; if no char received, retry
2472   1386 76 1B         cmp ah, 27
2473   1388 C6 A9 13      je _gets_ansi_esc_gets
2474   138B 76 0A         cmp ah, $0A        ; LF
2475   138D C6 14 14      je _gets_end_gets
2476   1390 76 0D         cmp ah, $0D        ; CR
2477   1392 C6 14 14      je _gets_end_gets
2478   1395 76 5C         cmp ah, $5C        ; '\\'
2479   1397 C6 D5 13      je _gets_escape_gets
2480   139A 76 08         cmp ah, $08      ; check for backspace
2481   139C C6 A5 13      je _gets_backspace_gets
2482   139F 1A            mov al, ah
2483   13A0 3E            mov [d], al
2484   13A1 79            inc d
2485   13A2 0A 7D 13      jmp _gets_loop_gets
2486   13A5             _gets_backspace_gets:
2487   13A5 7F            dec d
2488   13A6 0A 7D 13      jmp _gets_loop_gets
2489   13A9             _gets_ansi_esc_gets:
2490   13A9 19 01         mov al, 1
2491   13AB 05 03         syscall sys_io        ; receive in AH without echo
2492   13AD B9 00         cmp al, 0          ; check error code (AL)
2493   13AF C6 A9 13      je _gets_ansi_esc_gets    ; if no char received, retry
2494   13B2 76 5B         cmp ah, '['
2495   13B4 C7 7D 13      jne _gets_loop_gets
2496   13B7             _gets_ansi_esc_2_gets:
2497   13B7 19 01         mov al, 1
2498   13B9 05 03         syscall sys_io          ; receive in AH without echo
2499   13BB B9 00         cmp al, 0            ; check error code (AL)
2500   13BD C6 B7 13      je _gets_ansi_esc_2_gets  ; if no char received, retry
2501   13C0 76 44         cmp ah, 'D'
2502   13C2 C6 CD 13      je _gets_left_arrow_gets
2503   13C5 76 43         cmp ah, 'C'
2504   13C7 C6 D1 13      je _gets_right_arrow_gets
2505   13CA 0A 7D 13      jmp _gets_loop_gets
2506   13CD             _gets_left_arrow_gets:
2507   13CD 7F            dec d
2508   13CE 0A 7D 13      jmp _gets_loop_gets
2509   13D1             _gets_right_arrow_gets:
2510   13D1 79            inc d
2511   13D2 0A 7D 13      jmp _gets_loop_gets
2512   13D5             _gets_escape_gets:
2513   13D5 19 01         mov al, 1
2514   13D7 05 03         syscall sys_io      ; receive in AH
2515   13D9 B9 00         cmp al, 0        ; check error code (AL)
2516   13DB C6 D5 13      je _gets_escape_gets      ; if no char received, retry
2517   13DE 76 6E         cmp ah, 'n'
2518   13E0 C6 FF 13      je _gets_LF_gets
2519   13E3 76 72         cmp ah, 'r'
2520   13E5 C6 06 14      je _gets_CR_gets
2521   13E8 76 30         cmp ah, '0'
2522   13EA C6 0D 14      je _gets_NULL_gets
2523   13ED 76 5C         cmp ah, $5C  
2524   13EF C6 F8 13      je _gets_slash_gets
2525   13F2 1A            mov al, ah        ; if not a known escape, it is just a normal letter
2526   13F3 3E            mov [d], al
2527   13F4 79            inc d
2528   13F5 0A 7D 13      jmp _gets_loop_gets
2529   13F8             _gets_slash_gets:
2530   13F8 19 5C         mov al, $5C
2531   13FA 3E            mov [d], al
2532   13FB 79            inc d
2533   13FC 0A 7D 13      jmp _gets_loop_gets
2534   13FF             _gets_LF_gets:
2535   13FF 19 0A         mov al, $0A
2536   1401 3E            mov [d], al
2537   1402 79            inc d
2538   1403 0A 7D 13      jmp _gets_loop_gets
2539   1406             _gets_CR_gets:
2540   1406 19 0D         mov al, $0D
2541   1408 3E            mov [d], al
2542   1409 79            inc d
2543   140A 0A 7D 13      jmp _gets_loop_gets
2544   140D             _gets_NULL_gets:
2545   140D 19 00         mov al, $00
2546   140F 3E            mov [d], al
2547   1410 79            inc d
2548   1411 0A 7D 13      jmp _gets_loop_gets
2549   1414             _gets_end_gets:
2550   1414 19 00         mov al, 0
2551   1416 3E            mov [d], al        ; terminate string
2552   1417 E7            pop d
2553   1418 E4            pop a
2554   1419 09            ret
2555   141A             ; --- END INLINE ASM SEGMENT
2556   141A F9            leave
2557   141B 09            ret
2558   141C             
2559   141C             strlen:
2560   141C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2561   141F             ; int length; 
2562   141F 52 02 00      sub sp, 2
2563   1422             ; length = 0; 
2564   1422 FA FF FF      lea d, [bp + -1] ; $length
2565   1425 DA            push d
2566   1426 FD 2E 00 00   mov32 cb, $00000000
2566   142A 00 00 
2567   142C E7            pop d
2568   142D FD 43         mov [d], b
2569   142F             ; while (str[length] != 0) { 
2570   142F             _while81_cond:
2571   142F FA 05 00      lea d, [bp + 5] ; $str
2572   1432 FD 2A         mov d, [d]
2573   1434 D7            push a
2574   1435 DA            push d
2575   1436 FA FF FF      lea d, [bp + -1] ; $length
2576   1439 2A            mov b, [d]
2577   143A 38 00 00      mov c, 0
2578   143D E7            pop d
2579   143E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2580   1442 E4            pop a
2581   1443 32            mov bl, [d]
2582   1444 A7 00         mov bh, 0
2583   1446 38 00 00      mov c, 0
2584   1449             ; --- START RELATIONAL
2585   1449 D7            push a
2586   144A 11            mov a, b
2587   144B FD 2E 00 00   mov32 cb, $00000000
2587   144F 00 00 
2588   1451 B0            cmp a, b
2589   1452 FD 72         sneq ; !=
2590   1454 E4            pop a
2591   1455             ; --- END RELATIONAL
2592   1455 C0 00 00      cmp b, 0
2593   1458 C6 6E 14      je _while81_exit
2594   145B             _while81_block:
2595   145B             ; length++; 
2596   145B FA FF FF      lea d, [bp + -1] ; $length
2597   145E 2A            mov b, [d]
2598   145F 38 00 00      mov c, 0
2599   1462 11            mov a, b
2600   1463 FD 77         inc b
2601   1465 FA FF FF      lea d, [bp + -1] ; $length
2602   1468 FD 43         mov [d], b
2603   146A 27            mov b, a
2604   146B 0A 2F 14      jmp _while81_cond
2605   146E             _while81_exit:
2606   146E             ; return length; 
2607   146E FA FF FF      lea d, [bp + -1] ; $length
2608   1471 2A            mov b, [d]
2609   1472 38 00 00      mov c, 0
2610   1475 F9            leave
2611   1476 09            ret
2612   1477             ; --- END TEXT SEGMENT
2613   1477             
2614   1477             ; --- BEGIN DATA SEGMENT
2615   1477 50 75 62 6C _s0: .db "Public Key: %d, %d\n", 0
2615   147B 69 63 20 4B 
2615   147F 65 79 3A 20 
2615   1483 25 64 2C 20 
2615   1487 25 64 0A 00 
2616   148B 50 72 69 76 _s1: .db "Private Key: %d, %d\n", 0
2616   148F 61 74 65 20 
2616   1493 4B 65 79 3A 
2616   1497 20 25 64 2C 
2616   149B 20 25 64 0A 
2616   149F 00 
2617   14A0 45 6E 74 65 _s2: .db "Enter a string: ", 0
2617   14A4 72 20 61 20 
2617   14A8 73 74 72 69 
2617   14AC 6E 67 3A 20 
2617   14B0 00 
2618   14B1 45 6E 63 72 _s3: .db "Encrypted text: \n", 0
2618   14B5 79 70 74 65 
2618   14B9 64 20 74 65 
2618   14BD 78 74 3A 20 
2618   14C1 0A 00 
2619   14C3 25 64 20 00 _s4: .db "%d ", 0
2620   14C7 0A 00       _s5: .db "\n", 0
2621   14C9 44 65 63 72 _s6: .db "Decrypted text: \n", 0
2621   14CD 79 70 74 65 
2621   14D1 64 20 74 65 
2621   14D5 78 74 3A 20 
2621   14D9 0A 00 
2622   14DB 25 64 0A 00 _s7: .db "%d\n", 0
2623   14DF 55 6E 65 78 _s8: .db "Unexpected format in printf.", 0
2623   14E3 70 65 63 74 
2623   14E7 65 64 20 66 
2623   14EB 6F 72 6D 61 
2623   14EF 74 20 69 6E 
2623   14F3 20 70 72 69 
2623   14F7 6E 74 66 2E 
2623   14FB 00 
2624   14FC 45 72 72 6F _s9: .db "Error: Unknown argument type.\n", 0
2624   1500 72 3A 20 55 
2624   1504 6E 6B 6E 6F 
2624   1508 77 6E 20 61 
2624   150C 72 67 75 6D 
2624   1510 65 6E 74 20 
2624   1514 74 79 70 65 
2624   1518 2E 0A 00 
2625   151B             
2626   151B 1D 15       _heap_top: .dw _heap
2627   151D 00          _heap: .db 0
2628   151E             ; --- END DATA SEGMENT
2629   151E             
2630   151E             .end
tasm: Number of errors = 0
