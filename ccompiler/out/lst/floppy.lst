0001   0000             ; --- FILENAME: programs/floppy.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; char option; 
0011   0408 52 01 00      sub sp, 1
0012   040B             ; char byte; 
0013   040B 52 01 00      sub sp, 1
0014   040E             ; unsigned int word; 
0015   040E 52 02 00      sub sp, 2
0016   0411             ; printf("Test of 5.25 inch Floppy Drive Interface.\n"); 
0017   0411             ; --- START FUNCTION CALL
0018   0411 26 3A 0F      mov b, _s0 ; "Test of 5.25 inch Floppy Drive Interface.\n"
0019   0414 FD AB         swp b
0020   0416 D8            push b
0021   0417 07 23 06      call printf
0022   041A 51 02 00      add sp, 2
0023   041D             ; --- END FUNCTION CALL
0024   041D             ; --- BEGIN INLINE ASM SEGMENT
0025   041D 3B C0 FF      mov d, $FFC0    ; wd1770 data register
0026   0420 19 02         mov al, 2       ; setparam call
0027   0422 2E 09         mov bl, $09     
0028   0424 05 0C         syscall sys_system
0029   0426             ; --- END INLINE ASM SEGMENT
0030   0426             ; for(;;){ 
0031   0426             _for1_init:
0032   0426             _for1_cond:
0033   0426             _for1_block:
0034   0426             ; printf("a. set reset bit and select drive 0\n"); 
0035   0426             ; --- START FUNCTION CALL
0036   0426 26 65 0F      mov b, _s1 ; "a. set reset bit and select drive 0\n"
0037   0429 FD AB         swp b
0038   042B D8            push b
0039   042C 07 23 06      call printf
0040   042F 51 02 00      add sp, 2
0041   0432             ; --- END FUNCTION CALL
0042   0432             ; printf("b. clear reset bit, and select drive 0\n"); 
0043   0432             ; --- START FUNCTION CALL
0044   0432 26 8A 0F      mov b, _s2 ; "b. clear reset bit, and select drive 0\n"
0045   0435 FD AB         swp b
0046   0437 D8            push b
0047   0438 07 23 06      call printf
0048   043B 51 02 00      add sp, 2
0049   043E             ; --- END FUNCTION CALL
0050   043E             ; printf("0. select drive 0\n"); 
0051   043E             ; --- START FUNCTION CALL
0052   043E 26 B2 0F      mov b, _s3 ; "0. select drive 0\n"
0053   0441 FD AB         swp b
0054   0443 D8            push b
0055   0444 07 23 06      call printf
0056   0447 51 02 00      add sp, 2
0057   044A             ; --- END FUNCTION CALL
0058   044A             ; printf("1. select drive 1\n"); 
0059   044A             ; --- START FUNCTION CALL
0060   044A 26 C5 0F      mov b, _s4 ; "1. select drive 1\n"
0061   044D FD AB         swp b
0062   044F D8            push b
0063   0450 07 23 06      call printf
0064   0453 51 02 00      add sp, 2
0065   0456             ; --- END FUNCTION CALL
0066   0456             ; printf("w. write 16 to data register\n"); 
0067   0456             ; --- START FUNCTION CALL
0068   0456 26 D8 0F      mov b, _s5 ; "w. write 16 to data register\n"
0069   0459 FD AB         swp b
0070   045B D8            push b
0071   045C 07 23 06      call printf
0072   045F 51 02 00      add sp, 2
0073   0462             ; --- END FUNCTION CALL
0074   0462             ; printf("d. read data register\n"); 
0075   0462             ; --- START FUNCTION CALL
0076   0462 26 F6 0F      mov b, _s6 ; "d. read data register\n"
0077   0465 FD AB         swp b
0078   0467 D8            push b
0079   0468 07 23 06      call printf
0080   046B 51 02 00      add sp, 2
0081   046E             ; --- END FUNCTION CALL
0082   046E             ; printf("t. read track register\n"); 
0083   046E             ; --- START FUNCTION CALL
0084   046E 26 0D 10      mov b, _s7 ; "t. read track register\n"
0085   0471 FD AB         swp b
0086   0473 D8            push b
0087   0474 07 23 06      call printf
0088   0477 51 02 00      add sp, 2
0089   047A             ; --- END FUNCTION CALL
0090   047A             ; printf("s. step\n"); 
0091   047A             ; --- START FUNCTION CALL
0092   047A 26 25 10      mov b, _s8 ; "s. step\n"
0093   047D FD AB         swp b
0094   047F D8            push b
0095   0480 07 23 06      call printf
0096   0483 51 02 00      add sp, 2
0097   0486             ; --- END FUNCTION CALL
0098   0486             ; printf("k. seek\n"); 
0099   0486             ; --- START FUNCTION CALL
0100   0486 26 2E 10      mov b, _s9 ; "k. seek\n"
0101   0489 FD AB         swp b
0102   048B D8            push b
0103   048C 07 23 06      call printf
0104   048F 51 02 00      add sp, 2
0105   0492             ; --- END FUNCTION CALL
0106   0492             ; printf("r. restore\n"); 
0107   0492             ; --- START FUNCTION CALL
0108   0492 26 37 10      mov b, _s10 ; "r. restore\n"
0109   0495 FD AB         swp b
0110   0497 D8            push b
0111   0498 07 23 06      call printf
0112   049B 51 02 00      add sp, 2
0113   049E             ; --- END FUNCTION CALL
0114   049E             ; printf("i. step in\n"); 
0115   049E             ; --- START FUNCTION CALL
0116   049E 26 43 10      mov b, _s11 ; "i. step in\n"
0117   04A1 FD AB         swp b
0118   04A3 D8            push b
0119   04A4 07 23 06      call printf
0120   04A7 51 02 00      add sp, 2
0121   04AA             ; --- END FUNCTION CALL
0122   04AA             ; printf("o. step out\n"); 
0123   04AA             ; --- START FUNCTION CALL
0124   04AA 26 4F 10      mov b, _s12 ; "o. step out\n"
0125   04AD FD AB         swp b
0126   04AF D8            push b
0127   04B0 07 23 06      call printf
0128   04B3 51 02 00      add sp, 2
0129   04B6             ; --- END FUNCTION CALL
0130   04B6             ; printf("e. exit\n"); 
0131   04B6             ; --- START FUNCTION CALL
0132   04B6 26 5C 10      mov b, _s13 ; "e. exit\n"
0133   04B9 FD AB         swp b
0134   04BB D8            push b
0135   04BC 07 23 06      call printf
0136   04BF 51 02 00      add sp, 2
0137   04C2             ; --- END FUNCTION CALL
0138   04C2             ; printf("q. read pending irq status register\n"); 
0139   04C2             ; --- START FUNCTION CALL
0140   04C2 26 65 10      mov b, _s14 ; "q. read pending irq status register\n"
0141   04C5 FD AB         swp b
0142   04C7 D8            push b
0143   04C8 07 23 06      call printf
0144   04CB 51 02 00      add sp, 2
0145   04CE             ; --- END FUNCTION CALL
0146   04CE             ; printf("\nOption: "); 
0147   04CE             ; --- START FUNCTION CALL
0148   04CE 26 8A 10      mov b, _s15 ; "\nOption: "
0149   04D1 FD AB         swp b
0150   04D3 D8            push b
0151   04D4 07 23 06      call printf
0152   04D7 51 02 00      add sp, 2
0153   04DA             ; --- END FUNCTION CALL
0154   04DA             ; option = getchar(); 
0155   04DA FA 00 00      lea d, [bp + 0] ; $option
0156   04DD DA            push d
0157   04DE             ; --- START FUNCTION CALL
0158   04DE 07 20 0F      call getchar
0159   04E1 E7            pop d
0160   04E2 FD 3E         mov [d], bl
0161   04E4             ; switch(option){ 
0162   04E4             _switch2_expr:
0163   04E4 FA 00 00      lea d, [bp + 0] ; $option
0164   04E7 32            mov bl, [d]
0165   04E8 A7 00         mov bh, 0
0166   04EA 38 00 00      mov c, 0
0167   04ED             _switch2_comparisons:
0168   04ED C1 61         cmp bl, $61
0169   04EF C6 36 05      je _switch2_case0
0170   04F2 C1 62         cmp bl, $62
0171   04F4 C6 42 05      je _switch2_case1
0172   04F7 C1 30         cmp bl, $30
0173   04F9 C6 4E 05      je _switch2_case2
0174   04FC C1 31         cmp bl, $31
0175   04FE C6 5A 05      je _switch2_case3
0176   0501 C1 77         cmp bl, $77
0177   0503 C6 66 05      je _switch2_case4
0178   0506 C1 64         cmp bl, $64
0179   0508 C6 72 05      je _switch2_case5
0180   050B C1 74         cmp bl, $74
0181   050D C6 99 05      je _switch2_case6
0182   0510 C1 73         cmp bl, $73
0183   0512 C6 C0 05      je _switch2_case7
0184   0515 C1 6B         cmp bl, $6b
0185   0517 C6 CC 05      je _switch2_case8
0186   051A C1 72         cmp bl, $72
0187   051C C6 D8 05      je _switch2_case9
0188   051F C1 69         cmp bl, $69
0189   0521 C6 E4 05      je _switch2_case10
0190   0524 C1 6F         cmp bl, $6f
0191   0526 C6 F0 05      je _switch2_case11
0192   0529 C1 71         cmp bl, $71
0193   052B C6 FC 05      je _switch2_case12
0194   052E C1 65         cmp bl, $65
0195   0530 C6 1B 06      je _switch2_case13
0196   0533 0A 1E 06      jmp _switch2_exit
0197   0536             _switch2_case0:
0198   0536             ; --- BEGIN INLINE ASM SEGMENT
0199   0536 3B C0 FF      mov d, $FFC0    ; fdc output register
0200   0539 19 02         mov al, 2       ; setparam call
0201   053B 2E 2A         mov bl, $2A     ; set reset bit, select drive 0
0202   053D 05 0C         syscall sys_system
0203   053F             ; --- END INLINE ASM SEGMENT
0204   053F             ; break; 
0205   053F 0A 1E 06      jmp _switch2_exit ; case break
0206   0542             _switch2_case1:
0207   0542             ; --- BEGIN INLINE ASM SEGMENT
0208   0542 3B C0 FF      mov d, $FFC0    ; fdc output register
0209   0545 19 02         mov al, 2       ; setparam call
0210   0547 2E 0A         mov bl, $0A     ; clear reset bit, select drive 0
0211   0549 05 0C         syscall sys_system
0212   054B             ; --- END INLINE ASM SEGMENT
0213   054B             ; break; 
0214   054B 0A 1E 06      jmp _switch2_exit ; case break
0215   054E             _switch2_case2:
0216   054E             ; --- BEGIN INLINE ASM SEGMENT
0217   054E 3B C0 FF      mov d, $FFC0    ; fdc output register
0218   0551 19 02         mov al, 2       ; setparam call
0219   0553 2E 0A         mov bl, $0A     ; select drive 0
0220   0555 05 0C         syscall sys_system
0221   0557             ; --- END INLINE ASM SEGMENT
0222   0557             ; break; 
0223   0557 0A 1E 06      jmp _switch2_exit ; case break
0224   055A             _switch2_case3:
0225   055A             ; --- BEGIN INLINE ASM SEGMENT
0226   055A 3B C0 FF      mov d, $FFC0    ; fdc output register
0227   055D 19 02         mov al, 2       ; setparam call
0228   055F 2E 09         mov bl, $09     ; select drive 1
0229   0561 05 0C         syscall sys_system
0230   0563             ; --- END INLINE ASM SEGMENT
0231   0563             ; break; 
0232   0563 0A 1E 06      jmp _switch2_exit ; case break
0233   0566             _switch2_case4:
0234   0566             ; --- BEGIN INLINE ASM SEGMENT
0235   0566 3B CB FF      mov d, $FFCB    ; wd1770 data register
0236   0569 19 02         mov al, 2       ; setparam call
0237   056B 2E 10         mov bl, $10     ; track 16
0238   056D 05 0C         syscall sys_system
0239   056F             ; --- END INLINE ASM SEGMENT
0240   056F             ; break; 
0241   056F 0A 1E 06      jmp _switch2_exit ; case break
0242   0572             _switch2_case5:
0243   0572             ; --- BEGIN INLINE ASM SEGMENT
0244   0572 3B CB FF      mov d, $FFCB    ; wd1770 data register
0245   0575 19 04         mov al, 4       ; getparam call
0246   0577 05 0C         syscall sys_system
0247   0579 FA FF FF      lea d, [bp + -1] ; $byte
0248   057C FD 3E         mov [d], bl
0249   057E             ; --- END INLINE ASM SEGMENT
0250   057E             ; printf("\nData register value: %d\n", byte); 
0251   057E             ; --- START FUNCTION CALL
0252   057E FA FF FF      lea d, [bp + -1] ; $byte
0253   0581 32            mov bl, [d]
0254   0582 A7 00         mov bh, 0
0255   0584 38 00 00      mov c, 0
0256   0587 FD AB         swp b
0257   0589 D8            push b
0258   058A 26 94 10      mov b, _s16 ; "\nData register value: %d\n"
0259   058D FD AB         swp b
0260   058F D8            push b
0261   0590 07 23 06      call printf
0262   0593 51 03 00      add sp, 3
0263   0596             ; --- END FUNCTION CALL
0264   0596             ; break; 
0265   0596 0A 1E 06      jmp _switch2_exit ; case break
0266   0599             _switch2_case6:
0267   0599             ; --- BEGIN INLINE ASM SEGMENT
0268   0599 3B C9 FF      mov d, $FFC9    ; wd1770 track register
0269   059C 19 04         mov al, 4       ; getparam call
0270   059E 05 0C         syscall sys_system
0271   05A0 FA FF FF      lea d, [bp + -1] ; $byte
0272   05A3 FD 3E         mov [d], bl
0273   05A5             ; --- END INLINE ASM SEGMENT
0274   05A5             ; printf("\nTrack register value: %d\n", byte); 
0275   05A5             ; --- START FUNCTION CALL
0276   05A5 FA FF FF      lea d, [bp + -1] ; $byte
0277   05A8 32            mov bl, [d]
0278   05A9 A7 00         mov bh, 0
0279   05AB 38 00 00      mov c, 0
0280   05AE FD AB         swp b
0281   05B0 D8            push b
0282   05B1 26 AE 10      mov b, _s17 ; "\nTrack register value: %d\n"
0283   05B4 FD AB         swp b
0284   05B6 D8            push b
0285   05B7 07 23 06      call printf
0286   05BA 51 03 00      add sp, 3
0287   05BD             ; --- END FUNCTION CALL
0288   05BD             ; break; 
0289   05BD 0A 1E 06      jmp _switch2_exit ; case break
0290   05C0             _switch2_case7:
0291   05C0             ; --- BEGIN INLINE ASM SEGMENT
0292   05C0 3B C8 FF      mov d, $FFC8    ; wd1770 command register
0293   05C3 19 02         mov al, 2       ; setparam call
0294   05C5 2E 23         mov bl, $23     ; STEP command, 30ms rate
0295   05C7 05 0C         syscall sys_system
0296   05C9             ; --- END INLINE ASM SEGMENT
0297   05C9             ; break; 
0298   05C9 0A 1E 06      jmp _switch2_exit ; case break
0299   05CC             _switch2_case8:
0300   05CC             ; --- BEGIN INLINE ASM SEGMENT
0301   05CC 3B C8 FF      mov d, $FFC8    ; wd1770 command register
0302   05CF 19 02         mov al, 2       ; setparam call
0303   05D1 2E 13         mov bl, $13     ; seek command
0304   05D3 05 0C         syscall sys_system
0305   05D5             ; --- END INLINE ASM SEGMENT
0306   05D5             ; break; 
0307   05D5 0A 1E 06      jmp _switch2_exit ; case break
0308   05D8             _switch2_case9:
0309   05D8             ; --- BEGIN INLINE ASM SEGMENT
0310   05D8               ; send restore command
0311   05D8 3B C8 FF      mov d, $FFC8    ; wd1770
0312   05DB 19 02         mov al, 2       ; setparam call
0313   05DD 2E 03         mov bl, $03     ; restore command, 30ms rate
0314   05DF 05 0C         syscall sys_system
0315   05E1             ; --- END INLINE ASM SEGMENT
0316   05E1             ; break; 
0317   05E1 0A 1E 06      jmp _switch2_exit ; case break
0318   05E4             _switch2_case10:
0319   05E4             ; --- BEGIN INLINE ASM SEGMENT
0320   05E4               ; send step in command
0321   05E4 3B C8 FF      mov d, $FFC8    ; wd1770
0322   05E7 19 02         mov al, 2       ; setparam call
0323   05E9 2E 43         mov bl, $43     ; step in command, 30ms rate
0324   05EB 05 0C         syscall sys_system
0325   05ED             ; --- END INLINE ASM SEGMENT
0326   05ED             ; break; 
0327   05ED 0A 1E 06      jmp _switch2_exit ; case break
0328   05F0             _switch2_case11:
0329   05F0             ; --- BEGIN INLINE ASM SEGMENT
0330   05F0               ; send step out command
0331   05F0 3B C8 FF      mov d, $FFC8    ; wd1770
0332   05F3 19 02         mov al, 2       ; setparam call
0333   05F5 2E 63         mov bl, $63     ; step out command, 30ms rate
0334   05F7 05 0C         syscall sys_system
0335   05F9             ; --- END INLINE ASM SEGMENT
0336   05F9             ; break; 
0337   05F9 0A 1E 06      jmp _switch2_exit ; case break
0338   05FC             _switch2_case12:
0339   05FC             ; --- BEGIN INLINE ASM SEGMENT
0340   05FC FD 0E         lodmsk          ; load masks register/irq status register
0341   05FE FA FD FF      lea d, [bp + -3] ; $word
0342   0601               ; load address of word into d
0343   0601 43            mov [d], a      ; al = masks, ah = irq status
0344   0602             ; --- END INLINE ASM SEGMENT
0345   0602             ; printf("\nMasks: %x\n", word); 
0346   0602             ; --- START FUNCTION CALL
0347   0602 FA FD FF      lea d, [bp + -3] ; $word
0348   0605 2A            mov b, [d]
0349   0606 38 00 00      mov c, 0
0350   0609 FD AB         swp b
0351   060B D8            push b
0352   060C 26 C9 10      mov b, _s18 ; "\nMasks: %x\n"
0353   060F FD AB         swp b
0354   0611 D8            push b
0355   0612 07 23 06      call printf
0356   0615 51 04 00      add sp, 4
0357   0618             ; --- END FUNCTION CALL
0358   0618             ; break; 
0359   0618 0A 1E 06      jmp _switch2_exit ; case break
0360   061B             _switch2_case13:
0361   061B             ; return; 
0362   061B F9            leave
0363   061C 05 0B         syscall sys_terminate_proc
0364   061E             _switch2_exit:
0365   061E             _for1_update:
0366   061E 0A 26 04      jmp _for1_cond
0367   0621             _for1_exit:
0368   0621 05 0B         syscall sys_terminate_proc
0369   0623             
0370   0623             printf:
0371   0623 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0372   0626             ; char *p, *format_p; 
0373   0626 52 02 00      sub sp, 2
0374   0629 52 02 00      sub sp, 2
0375   062C             ; format_p = format; 
0376   062C FA FD FF      lea d, [bp + -3] ; $format_p
0377   062F DA            push d
0378   0630 FA 05 00      lea d, [bp + 5] ; $format
0379   0633 2A            mov b, [d]
0380   0634 38 00 00      mov c, 0
0381   0637 E7            pop d
0382   0638 FD 43         mov [d], b
0383   063A             ; p = &format + 2; 
0384   063A FA FF FF      lea d, [bp + -1] ; $p
0385   063D DA            push d
0386   063E FA 05 00      lea d, [bp + 5] ; $format
0387   0641 2D            mov b, d
0388   0642             ; --- START TERMS
0389   0642 D7            push a
0390   0643 11            mov a, b
0391   0644 FD 2E 02 00   mov32 cb, $00000002
0391   0648 00 00 
0392   064A 56            add b, a
0393   064B E4            pop a
0394   064C             ; --- END TERMS
0395   064C E7            pop d
0396   064D FD 43         mov [d], b
0397   064F             ; for(;;){ 
0398   064F             _for3_init:
0399   064F             _for3_cond:
0400   064F             _for3_block:
0401   064F             ; if(!*format_p) break; 
0402   064F             _if4_cond:
0403   064F FA FD FF      lea d, [bp + -3] ; $format_p
0404   0652 2A            mov b, [d]
0405   0653 38 00 00      mov c, 0
0406   0656 74            mov d, b
0407   0657 32            mov bl, [d]
0408   0658 A7 00         mov bh, 0
0409   065A 38 00 00      mov c, 0
0410   065D C0 00 00      cmp b, 0
0411   0660 FD 71         seq ; !
0412   0662 C0 00 00      cmp b, 0
0413   0665 C6 6E 06      je _if4_else
0414   0668             _if4_TRUE:
0415   0668             ; break; 
0416   0668 0A 0E 09      jmp _for3_exit ; for break
0417   066B 0A FB 08      jmp _if4_exit
0418   066E             _if4_else:
0419   066E             ; if(*format_p == '%'){ 
0420   066E             _if5_cond:
0421   066E FA FD FF      lea d, [bp + -3] ; $format_p
0422   0671 2A            mov b, [d]
0423   0672 38 00 00      mov c, 0
0424   0675 74            mov d, b
0425   0676 32            mov bl, [d]
0426   0677 A7 00         mov bh, 0
0427   0679 38 00 00      mov c, 0
0428   067C             ; --- START RELATIONAL
0429   067C D7            push a
0430   067D 11            mov a, b
0431   067E FD 2E 25 00   mov32 cb, $00000025
0431   0682 00 00 
0432   0684 B0            cmp a, b
0433   0685 FD 71         seq ; ==
0434   0687 E4            pop a
0435   0688             ; --- END RELATIONAL
0436   0688 C0 00 00      cmp b, 0
0437   068B C6 E6 08      je _if5_else
0438   068E             _if5_TRUE:
0439   068E             ; format_p++; 
0440   068E FA FD FF      lea d, [bp + -3] ; $format_p
0441   0691 2A            mov b, [d]
0442   0692 38 00 00      mov c, 0
0443   0695 FD 77         inc b
0444   0697 FA FD FF      lea d, [bp + -3] ; $format_p
0445   069A FD 43         mov [d], b
0446   069C FD 7D         dec b
0447   069E             ; switch(*format_p){ 
0448   069E             _switch6_expr:
0449   069E FA FD FF      lea d, [bp + -3] ; $format_p
0450   06A1 2A            mov b, [d]
0451   06A2 38 00 00      mov c, 0
0452   06A5 74            mov d, b
0453   06A6 32            mov bl, [d]
0454   06A7 A7 00         mov bh, 0
0455   06A9 38 00 00      mov c, 0
0456   06AC             _switch6_comparisons:
0457   06AC C1 6C         cmp bl, $6c
0458   06AE C6 DA 06      je _switch6_case0
0459   06B1 C1 4C         cmp bl, $4c
0460   06B3 C6 DA 06      je _switch6_case1
0461   06B6 C1 64         cmp bl, $64
0462   06B8 C6 EA 07      je _switch6_case2
0463   06BB C1 69         cmp bl, $69
0464   06BD C6 EA 07      je _switch6_case3
0465   06C0 C1 75         cmp bl, $75
0466   06C2 C6 1A 08      je _switch6_case4
0467   06C5 C1 78         cmp bl, $78
0468   06C7 C6 4A 08      je _switch6_case5
0469   06CA C1 63         cmp bl, $63
0470   06CC C6 7A 08      je _switch6_case6
0471   06CF C1 73         cmp bl, $73
0472   06D1 C6 AA 08      je _switch6_case7
0473   06D4 0A D7 08      jmp _switch6_default
0474   06D7 0A E3 08      jmp _switch6_exit
0475   06DA             _switch6_case0:
0476   06DA             _switch6_case1:
0477   06DA             ; format_p++; 
0478   06DA FA FD FF      lea d, [bp + -3] ; $format_p
0479   06DD 2A            mov b, [d]
0480   06DE 38 00 00      mov c, 0
0481   06E1 FD 77         inc b
0482   06E3 FA FD FF      lea d, [bp + -3] ; $format_p
0483   06E6 FD 43         mov [d], b
0484   06E8 FD 7D         dec b
0485   06EA             ; if(*format_p == 'd' || *format_p == 'i') 
0486   06EA             _if7_cond:
0487   06EA FA FD FF      lea d, [bp + -3] ; $format_p
0488   06ED 2A            mov b, [d]
0489   06EE 38 00 00      mov c, 0
0490   06F1 74            mov d, b
0491   06F2 32            mov bl, [d]
0492   06F3 A7 00         mov bh, 0
0493   06F5 38 00 00      mov c, 0
0494   06F8             ; --- START RELATIONAL
0495   06F8 D7            push a
0496   06F9 11            mov a, b
0497   06FA FD 2E 64 00   mov32 cb, $00000064
0497   06FE 00 00 
0498   0700 B0            cmp a, b
0499   0701 FD 71         seq ; ==
0500   0703 E4            pop a
0501   0704             ; --- END RELATIONAL
0502   0704             ; --- START LOGICAL OR
0503   0704 D7            push a
0504   0705 11            mov a, b
0505   0706 FA FD FF      lea d, [bp + -3] ; $format_p
0506   0709 2A            mov b, [d]
0507   070A 38 00 00      mov c, 0
0508   070D 74            mov d, b
0509   070E 32            mov bl, [d]
0510   070F A7 00         mov bh, 0
0511   0711 38 00 00      mov c, 0
0512   0714             ; --- START RELATIONAL
0513   0714 D7            push a
0514   0715 11            mov a, b
0515   0716 FD 2E 69 00   mov32 cb, $00000069
0515   071A 00 00 
0516   071C B0            cmp a, b
0517   071D FD 71         seq ; ==
0518   071F E4            pop a
0519   0720             ; --- END RELATIONAL
0520   0720 FD A8         sor a, b ; ||
0521   0722 E4            pop a
0522   0723             ; --- END LOGICAL OR
0523   0723 C0 00 00      cmp b, 0
0524   0726 C6 47 07      je _if7_else
0525   0729             _if7_TRUE:
0526   0729             ; print_signed_long(*(long *)p); 
0527   0729             ; --- START FUNCTION CALL
0528   0729 FA FF FF      lea d, [bp + -1] ; $p
0529   072C 2A            mov b, [d]
0530   072D 38 00 00      mov c, 0
0531   0730 74            mov d, b
0532   0731 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0533   0734 FD 39         mov c, b ; And place it into C
0534   0736 2A            mov b, [d] ; Lower Word in B
0535   0737 12            mov a, c
0536   0738 FD AA         swp a
0537   073A D7            push a
0538   073B FD AB         swp b
0539   073D D8            push b
0540   073E 07 10 09      call print_signed_long
0541   0741 51 04 00      add sp, 4
0542   0744             ; --- END FUNCTION CALL
0543   0744 0A CF 07      jmp _if7_exit
0544   0747             _if7_else:
0545   0747             ; if(*format_p == 'u') 
0546   0747             _if8_cond:
0547   0747 FA FD FF      lea d, [bp + -3] ; $format_p
0548   074A 2A            mov b, [d]
0549   074B 38 00 00      mov c, 0
0550   074E 74            mov d, b
0551   074F 32            mov bl, [d]
0552   0750 A7 00         mov bh, 0
0553   0752 38 00 00      mov c, 0
0554   0755             ; --- START RELATIONAL
0555   0755 D7            push a
0556   0756 11            mov a, b
0557   0757 FD 2E 75 00   mov32 cb, $00000075
0557   075B 00 00 
0558   075D B0            cmp a, b
0559   075E FD 71         seq ; ==
0560   0760 E4            pop a
0561   0761             ; --- END RELATIONAL
0562   0761 C0 00 00      cmp b, 0
0563   0764 C6 85 07      je _if8_else
0564   0767             _if8_TRUE:
0565   0767             ; print_unsigned_long(*(unsigned long *)p); 
0566   0767             ; --- START FUNCTION CALL
0567   0767 FA FF FF      lea d, [bp + -1] ; $p
0568   076A 2A            mov b, [d]
0569   076B 38 00 00      mov c, 0
0570   076E 74            mov d, b
0571   076F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0572   0772 FD 39         mov c, b ; And place it into C
0573   0774 2A            mov b, [d] ; Lower Word in B
0574   0775 12            mov a, c
0575   0776 FD AA         swp a
0576   0778 D7            push a
0577   0779 FD AB         swp b
0578   077B D8            push b
0579   077C 07 A3 0A      call print_unsigned_long
0580   077F 51 04 00      add sp, 4
0581   0782             ; --- END FUNCTION CALL
0582   0782 0A CF 07      jmp _if8_exit
0583   0785             _if8_else:
0584   0785             ; if(*format_p == 'x') 
0585   0785             _if9_cond:
0586   0785 FA FD FF      lea d, [bp + -3] ; $format_p
0587   0788 2A            mov b, [d]
0588   0789 38 00 00      mov c, 0
0589   078C 74            mov d, b
0590   078D 32            mov bl, [d]
0591   078E A7 00         mov bh, 0
0592   0790 38 00 00      mov c, 0
0593   0793             ; --- START RELATIONAL
0594   0793 D7            push a
0595   0794 11            mov a, b
0596   0795 FD 2E 78 00   mov32 cb, $00000078
0596   0799 00 00 
0597   079B B0            cmp a, b
0598   079C FD 71         seq ; ==
0599   079E E4            pop a
0600   079F             ; --- END RELATIONAL
0601   079F C0 00 00      cmp b, 0
0602   07A2 C6 C3 07      je _if9_else
0603   07A5             _if9_TRUE:
0604   07A5             ; printx32(*(long int *)p); 
0605   07A5             ; --- START FUNCTION CALL
0606   07A5 FA FF FF      lea d, [bp + -1] ; $p
0607   07A8 2A            mov b, [d]
0608   07A9 38 00 00      mov c, 0
0609   07AC 74            mov d, b
0610   07AD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0611   07B0 FD 39         mov c, b ; And place it into C
0612   07B2 2A            mov b, [d] ; Lower Word in B
0613   07B3 12            mov a, c
0614   07B4 FD AA         swp a
0615   07B6 D7            push a
0616   07B7 FD AB         swp b
0617   07B9 D8            push b
0618   07BA 07 D7 0B      call printx32
0619   07BD 51 04 00      add sp, 4
0620   07C0             ; --- END FUNCTION CALL
0621   07C0 0A CF 07      jmp _if9_exit
0622   07C3             _if9_else:
0623   07C3             ; err("Unexpected format in printf."); 
0624   07C3             ; --- START FUNCTION CALL
0625   07C3 26 D5 10      mov b, _s19 ; "Unexpected format in printf."
0626   07C6 FD AB         swp b
0627   07C8 D8            push b
0628   07C9 07 37 0C      call err
0629   07CC 51 02 00      add sp, 2
0630   07CF             ; --- END FUNCTION CALL
0631   07CF             _if9_exit:
0632   07CF             _if8_exit:
0633   07CF             _if7_exit:
0634   07CF             ; p = p + 4; 
0635   07CF FA FF FF      lea d, [bp + -1] ; $p
0636   07D2 DA            push d
0637   07D3 FA FF FF      lea d, [bp + -1] ; $p
0638   07D6 2A            mov b, [d]
0639   07D7 38 00 00      mov c, 0
0640   07DA             ; --- START TERMS
0641   07DA D7            push a
0642   07DB 11            mov a, b
0643   07DC FD 2E 04 00   mov32 cb, $00000004
0643   07E0 00 00 
0644   07E2 56            add b, a
0645   07E3 E4            pop a
0646   07E4             ; --- END TERMS
0647   07E4 E7            pop d
0648   07E5 FD 43         mov [d], b
0649   07E7             ; break; 
0650   07E7 0A E3 08      jmp _switch6_exit ; case break
0651   07EA             _switch6_case2:
0652   07EA             _switch6_case3:
0653   07EA             ; print_signed(*(int*)p); 
0654   07EA             ; --- START FUNCTION CALL
0655   07EA FA FF FF      lea d, [bp + -1] ; $p
0656   07ED 2A            mov b, [d]
0657   07EE 38 00 00      mov c, 0
0658   07F1 74            mov d, b
0659   07F2 2A            mov b, [d]
0660   07F3 38 00 00      mov c, 0
0661   07F6 FD AB         swp b
0662   07F8 D8            push b
0663   07F9 07 65 0C      call print_signed
0664   07FC 51 02 00      add sp, 2
0665   07FF             ; --- END FUNCTION CALL
0666   07FF             ; p = p + 2; 
0667   07FF FA FF FF      lea d, [bp + -1] ; $p
0668   0802 DA            push d
0669   0803 FA FF FF      lea d, [bp + -1] ; $p
0670   0806 2A            mov b, [d]
0671   0807 38 00 00      mov c, 0
0672   080A             ; --- START TERMS
0673   080A D7            push a
0674   080B 11            mov a, b
0675   080C FD 2E 02 00   mov32 cb, $00000002
0675   0810 00 00 
0676   0812 56            add b, a
0677   0813 E4            pop a
0678   0814             ; --- END TERMS
0679   0814 E7            pop d
0680   0815 FD 43         mov [d], b
0681   0817             ; break; 
0682   0817 0A E3 08      jmp _switch6_exit ; case break
0683   081A             _switch6_case4:
0684   081A             ; print_unsigned(*(unsigned int*)p); 
0685   081A             ; --- START FUNCTION CALL
0686   081A FA FF FF      lea d, [bp + -1] ; $p
0687   081D 2A            mov b, [d]
0688   081E 38 00 00      mov c, 0
0689   0821 74            mov d, b
0690   0822 2A            mov b, [d]
0691   0823 38 00 00      mov c, 0
0692   0826 FD AB         swp b
0693   0828 D8            push b
0694   0829 07 B6 0D      call print_unsigned
0695   082C 51 02 00      add sp, 2
0696   082F             ; --- END FUNCTION CALL
0697   082F             ; p = p + 2; 
0698   082F FA FF FF      lea d, [bp + -1] ; $p
0699   0832 DA            push d
0700   0833 FA FF FF      lea d, [bp + -1] ; $p
0701   0836 2A            mov b, [d]
0702   0837 38 00 00      mov c, 0
0703   083A             ; --- START TERMS
0704   083A D7            push a
0705   083B 11            mov a, b
0706   083C FD 2E 02 00   mov32 cb, $00000002
0706   0840 00 00 
0707   0842 56            add b, a
0708   0843 E4            pop a
0709   0844             ; --- END TERMS
0710   0844 E7            pop d
0711   0845 FD 43         mov [d], b
0712   0847             ; break; 
0713   0847 0A E3 08      jmp _switch6_exit ; case break
0714   084A             _switch6_case5:
0715   084A             ; printx16(*(int*)p); 
0716   084A             ; --- START FUNCTION CALL
0717   084A FA FF FF      lea d, [bp + -1] ; $p
0718   084D 2A            mov b, [d]
0719   084E 38 00 00      mov c, 0
0720   0851 74            mov d, b
0721   0852 2A            mov b, [d]
0722   0853 38 00 00      mov c, 0
0723   0856 FD AB         swp b
0724   0858 D8            push b
0725   0859 07 CE 0E      call printx16
0726   085C 51 02 00      add sp, 2
0727   085F             ; --- END FUNCTION CALL
0728   085F             ; p = p + 2; 
0729   085F FA FF FF      lea d, [bp + -1] ; $p
0730   0862 DA            push d
0731   0863 FA FF FF      lea d, [bp + -1] ; $p
0732   0866 2A            mov b, [d]
0733   0867 38 00 00      mov c, 0
0734   086A             ; --- START TERMS
0735   086A D7            push a
0736   086B 11            mov a, b
0737   086C FD 2E 02 00   mov32 cb, $00000002
0737   0870 00 00 
0738   0872 56            add b, a
0739   0873 E4            pop a
0740   0874             ; --- END TERMS
0741   0874 E7            pop d
0742   0875 FD 43         mov [d], b
0743   0877             ; break; 
0744   0877 0A E3 08      jmp _switch6_exit ; case break
0745   087A             _switch6_case6:
0746   087A             ; putchar(*(char*)p); 
0747   087A             ; --- START FUNCTION CALL
0748   087A FA FF FF      lea d, [bp + -1] ; $p
0749   087D 2A            mov b, [d]
0750   087E 38 00 00      mov c, 0
0751   0881 74            mov d, b
0752   0882 32            mov bl, [d]
0753   0883 A7 00         mov bh, 0
0754   0885 38 00 00      mov c, 0
0755   0888 DD            push bl
0756   0889 07 95 0A      call putchar
0757   088C 51 01 00      add sp, 1
0758   088F             ; --- END FUNCTION CALL
0759   088F             ; p = p + 2; 
0760   088F FA FF FF      lea d, [bp + -1] ; $p
0761   0892 DA            push d
0762   0893 FA FF FF      lea d, [bp + -1] ; $p
0763   0896 2A            mov b, [d]
0764   0897 38 00 00      mov c, 0
0765   089A             ; --- START TERMS
0766   089A D7            push a
0767   089B 11            mov a, b
0768   089C FD 2E 02 00   mov32 cb, $00000002
0768   08A0 00 00 
0769   08A2 56            add b, a
0770   08A3 E4            pop a
0771   08A4             ; --- END TERMS
0772   08A4 E7            pop d
0773   08A5 FD 43         mov [d], b
0774   08A7             ; break; 
0775   08A7 0A E3 08      jmp _switch6_exit ; case break
0776   08AA             _switch6_case7:
0777   08AA             ; print(*(char**)p); 
0778   08AA             ; --- START FUNCTION CALL
0779   08AA FA FF FF      lea d, [bp + -1] ; $p
0780   08AD 2A            mov b, [d]
0781   08AE 38 00 00      mov c, 0
0782   08B1 74            mov d, b
0783   08B2 2A            mov b, [d]
0784   08B3 FD AB         swp b
0785   08B5 D8            push b
0786   08B6 07 4C 0C      call print
0787   08B9 51 02 00      add sp, 2
0788   08BC             ; --- END FUNCTION CALL
0789   08BC             ; p = p + 2; 
0790   08BC FA FF FF      lea d, [bp + -1] ; $p
0791   08BF DA            push d
0792   08C0 FA FF FF      lea d, [bp + -1] ; $p
0793   08C3 2A            mov b, [d]
0794   08C4 38 00 00      mov c, 0
0795   08C7             ; --- START TERMS
0796   08C7 D7            push a
0797   08C8 11            mov a, b
0798   08C9 FD 2E 02 00   mov32 cb, $00000002
0798   08CD 00 00 
0799   08CF 56            add b, a
0800   08D0 E4            pop a
0801   08D1             ; --- END TERMS
0802   08D1 E7            pop d
0803   08D2 FD 43         mov [d], b
0804   08D4             ; break; 
0805   08D4 0A E3 08      jmp _switch6_exit ; case break
0806   08D7             _switch6_default:
0807   08D7             ; print("Error: Unknown argument type.\n"); 
0808   08D7             ; --- START FUNCTION CALL
0809   08D7 26 F2 10      mov b, _s20 ; "Error: Unknown argument type.\n"
0810   08DA FD AB         swp b
0811   08DC D8            push b
0812   08DD 07 4C 0C      call print
0813   08E0 51 02 00      add sp, 2
0814   08E3             ; --- END FUNCTION CALL
0815   08E3             _switch6_exit:
0816   08E3 0A FB 08      jmp _if5_exit
0817   08E6             _if5_else:
0818   08E6             ; putchar(*format_p); 
0819   08E6             ; --- START FUNCTION CALL
0820   08E6 FA FD FF      lea d, [bp + -3] ; $format_p
0821   08E9 2A            mov b, [d]
0822   08EA 38 00 00      mov c, 0
0823   08ED 74            mov d, b
0824   08EE 32            mov bl, [d]
0825   08EF A7 00         mov bh, 0
0826   08F1 38 00 00      mov c, 0
0827   08F4 DD            push bl
0828   08F5 07 95 0A      call putchar
0829   08F8 51 01 00      add sp, 1
0830   08FB             ; --- END FUNCTION CALL
0831   08FB             _if5_exit:
0832   08FB             _if4_exit:
0833   08FB             ; format_p++; 
0834   08FB FA FD FF      lea d, [bp + -3] ; $format_p
0835   08FE 2A            mov b, [d]
0836   08FF 38 00 00      mov c, 0
0837   0902 FD 77         inc b
0838   0904 FA FD FF      lea d, [bp + -3] ; $format_p
0839   0907 FD 43         mov [d], b
0840   0909 FD 7D         dec b
0841   090B             _for3_update:
0842   090B 0A 4F 06      jmp _for3_cond
0843   090E             _for3_exit:
0844   090E F9            leave
0845   090F 09            ret
0846   0910             
0847   0910             print_signed_long:
0848   0910 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0849   0913             ; char digits[10]; 
0850   0913 52 0A 00      sub sp, 10
0851   0916             ; int i = 0; 
0852   0916 52 02 00      sub sp, 2
0853   0919             ; --- START LOCAL VAR INITIALIZATION
0854   0919 FA F5 FF      lea d, [bp + -11] ; $i
0855   091C DA            push d
0856   091D FD 2E 00 00   mov32 cb, $00000000
0856   0921 00 00 
0857   0923 E7            pop d
0858   0924 FD 43         mov [d], b
0859   0926             ; --- END LOCAL VAR INITIALIZATION
0860   0926             ; if (num < 0) { 
0861   0926             _if10_cond:
0862   0926 FA 05 00      lea d, [bp + 5] ; $num
0863   0929 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0864   092C FD 39         mov c, b ; And place it into C
0865   092E 2A            mov b, [d] ; Lower Word in B
0866   092F             ; --- START RELATIONAL
0867   092F D7            push a
0868   0930 FD D8         push g
0869   0932 11            mov a, b
0870   0933 FD 7A         mov g, c
0871   0935 FD 2E 00 00   mov32 cb, $00000000
0871   0939 00 00 
0872   093B FD AF         cmp32 ga, cb
0873   093D FD 73         slt ; <
0874   093F FD F1         pop g
0875   0941 E4            pop a
0876   0942             ; --- END RELATIONAL
0877   0942 C0 00 00      cmp b, 0
0878   0945 C6 77 09      je _if10_else
0879   0948             _if10_TRUE:
0880   0948             ; putchar('-'); 
0881   0948             ; --- START FUNCTION CALL
0882   0948 FD 2E 2D 00   mov32 cb, $0000002d
0882   094C 00 00 
0883   094E DD            push bl
0884   094F 07 95 0A      call putchar
0885   0952 51 01 00      add sp, 1
0886   0955             ; --- END FUNCTION CALL
0887   0955             ; num = -num; 
0888   0955 FA 05 00      lea d, [bp + 5] ; $num
0889   0958 DA            push d
0890   0959 FA 05 00      lea d, [bp + 5] ; $num
0891   095C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0892   095F FD 39         mov c, b ; And place it into C
0893   0961 2A            mov b, [d] ; Lower Word in B
0894   0962 12            mov a, c
0895   0963 95            not a
0896   0964 97            not b
0897   0965 55 01 00      add b, 1
0898   0968 5B 00 00      adc a, 0
0899   096B 39            mov c, a
0900   096C E7            pop d
0901   096D FD 43         mov [d], b
0902   096F 28            mov b, c
0903   0970 FD 44 02 00   mov [d + 2], b
0904   0974 0A AB 09      jmp _if10_exit
0905   0977             _if10_else:
0906   0977             ; if (num == 0) { 
0907   0977             _if11_cond:
0908   0977 FA 05 00      lea d, [bp + 5] ; $num
0909   097A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0910   097D FD 39         mov c, b ; And place it into C
0911   097F 2A            mov b, [d] ; Lower Word in B
0912   0980             ; --- START RELATIONAL
0913   0980 D7            push a
0914   0981 FD D8         push g
0915   0983 11            mov a, b
0916   0984 FD 7A         mov g, c
0917   0986 FD 2E 00 00   mov32 cb, $00000000
0917   098A 00 00 
0918   098C FD AF         cmp32 ga, cb
0919   098E FD 71         seq ; ==
0920   0990 FD F1         pop g
0921   0992 E4            pop a
0922   0993             ; --- END RELATIONAL
0923   0993 C0 00 00      cmp b, 0
0924   0996 C6 AB 09      je _if11_exit
0925   0999             _if11_TRUE:
0926   0999             ; putchar('0'); 
0927   0999             ; --- START FUNCTION CALL
0928   0999 FD 2E 30 00   mov32 cb, $00000030
0928   099D 00 00 
0929   099F DD            push bl
0930   09A0 07 95 0A      call putchar
0931   09A3 51 01 00      add sp, 1
0932   09A6             ; --- END FUNCTION CALL
0933   09A6             ; return; 
0934   09A6 F9            leave
0935   09A7 09            ret
0936   09A8 0A AB 09      jmp _if11_exit
0937   09AB             _if11_exit:
0938   09AB             _if10_exit:
0939   09AB             ; while (num > 0) { 
0940   09AB             _while12_cond:
0941   09AB FA 05 00      lea d, [bp + 5] ; $num
0942   09AE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0943   09B1 FD 39         mov c, b ; And place it into C
0944   09B3 2A            mov b, [d] ; Lower Word in B
0945   09B4             ; --- START RELATIONAL
0946   09B4 D7            push a
0947   09B5 FD D8         push g
0948   09B7 11            mov a, b
0949   09B8 FD 7A         mov g, c
0950   09BA FD 2E 00 00   mov32 cb, $00000000
0950   09BE 00 00 
0951   09C0 FD AF         cmp32 ga, cb
0952   09C2 FD 7F         sgt
0953   09C4 FD F1         pop g
0954   09C6 E4            pop a
0955   09C7             ; --- END RELATIONAL
0956   09C7 C0 00 00      cmp b, 0
0957   09CA C6 4B 0A      je _while12_exit
0958   09CD             _while12_block:
0959   09CD             ; digits[i] = '0' + (num % 10); 
0960   09CD FA F7 FF      lea d, [bp + -9] ; $digits
0961   09D0 D7            push a
0962   09D1 DA            push d
0963   09D2 FA F5 FF      lea d, [bp + -11] ; $i
0964   09D5 2A            mov b, [d]
0965   09D6 38 00 00      mov c, 0
0966   09D9 E7            pop d
0967   09DA 5A            add d, b
0968   09DB E4            pop a
0969   09DC DA            push d
0970   09DD FD 2E 30 00   mov32 cb, $00000030
0970   09E1 00 00 
0971   09E3             ; --- START TERMS
0972   09E3 D7            push a
0973   09E4 11            mov a, b
0974   09E5 FA 05 00      lea d, [bp + 5] ; $num
0975   09E8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0976   09EB FD 39         mov c, b ; And place it into C
0977   09ED 2A            mov b, [d] ; Lower Word in B
0978   09EE             ; --- START FACTORS
0979   09EE D7            push a
0980   09EF FD D8         push g
0981   09F1 11            mov a, b
0982   09F2 FD 7A         mov g, c
0983   09F4 FD 2E 0A 00   mov32 cb, $0000000a
0983   09F8 00 00 
0984   09FA FD D8         push g ; save 'g' as the div instruction uses it
0985   09FC AE            div a, b ; %, a: quotient, b: remainder
0986   09FD 11            mov a, b
0987   09FE FD F1         pop g
0988   0A00 FD 38         mov c, g
0989   0A02 27            mov b, a
0990   0A03 FD F1         pop g
0991   0A05 E4            pop a
0992   0A06             ; --- END FACTORS
0993   0A06 FD 15         add32 cb, ga
0994   0A08 E4            pop a
0995   0A09             ; --- END TERMS
0996   0A09 E7            pop d
0997   0A0A FD 3E         mov [d], bl
0998   0A0C             ; num = num / 10; 
0999   0A0C FA 05 00      lea d, [bp + 5] ; $num
1000   0A0F DA            push d
1001   0A10 FA 05 00      lea d, [bp + 5] ; $num
1002   0A13 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1003   0A16 FD 39         mov c, b ; And place it into C
1004   0A18 2A            mov b, [d] ; Lower Word in B
1005   0A19             ; --- START FACTORS
1006   0A19 D7            push a
1007   0A1A FD D8         push g
1008   0A1C 11            mov a, b
1009   0A1D FD 7A         mov g, c
1010   0A1F FD 2E 0A 00   mov32 cb, $0000000a
1010   0A23 00 00 
1011   0A25 FD D8         push g ; save 'g' as the div instruction uses it
1012   0A27 AE            div a, b ; /, a: quotient, b: remainder
1013   0A28 FD F1         pop g
1014   0A2A FD 38         mov c, g
1015   0A2C 27            mov b, a
1016   0A2D FD F1         pop g
1017   0A2F E4            pop a
1018   0A30             ; --- END FACTORS
1019   0A30 E7            pop d
1020   0A31 FD 43         mov [d], b
1021   0A33 28            mov b, c
1022   0A34 FD 44 02 00   mov [d + 2], b
1023   0A38             ; i++; 
1024   0A38 FA F5 FF      lea d, [bp + -11] ; $i
1025   0A3B 2A            mov b, [d]
1026   0A3C 38 00 00      mov c, 0
1027   0A3F 11            mov a, b
1028   0A40 FD 77         inc b
1029   0A42 FA F5 FF      lea d, [bp + -11] ; $i
1030   0A45 FD 43         mov [d], b
1031   0A47 27            mov b, a
1032   0A48 0A AB 09      jmp _while12_cond
1033   0A4B             _while12_exit:
1034   0A4B             ; while (i > 0) { 
1035   0A4B             _while19_cond:
1036   0A4B FA F5 FF      lea d, [bp + -11] ; $i
1037   0A4E 2A            mov b, [d]
1038   0A4F 38 00 00      mov c, 0
1039   0A52             ; --- START RELATIONAL
1040   0A52 D7            push a
1041   0A53 11            mov a, b
1042   0A54 FD 2E 00 00   mov32 cb, $00000000
1042   0A58 00 00 
1043   0A5A B0            cmp a, b
1044   0A5B FD 7F         sgt ; >
1045   0A5D E4            pop a
1046   0A5E             ; --- END RELATIONAL
1047   0A5E C0 00 00      cmp b, 0
1048   0A61 C6 93 0A      je _while19_exit
1049   0A64             _while19_block:
1050   0A64             ; i--; 
1051   0A64 FA F5 FF      lea d, [bp + -11] ; $i
1052   0A67 2A            mov b, [d]
1053   0A68 38 00 00      mov c, 0
1054   0A6B 11            mov a, b
1055   0A6C FD 7D         dec b
1056   0A6E FA F5 FF      lea d, [bp + -11] ; $i
1057   0A71 FD 43         mov [d], b
1058   0A73 27            mov b, a
1059   0A74             ; putchar(digits[i]); 
1060   0A74             ; --- START FUNCTION CALL
1061   0A74 FA F7 FF      lea d, [bp + -9] ; $digits
1062   0A77 D7            push a
1063   0A78 DA            push d
1064   0A79 FA F5 FF      lea d, [bp + -11] ; $i
1065   0A7C 2A            mov b, [d]
1066   0A7D 38 00 00      mov c, 0
1067   0A80 E7            pop d
1068   0A81 5A            add d, b
1069   0A82 E4            pop a
1070   0A83 32            mov bl, [d]
1071   0A84 A7 00         mov bh, 0
1072   0A86 38 00 00      mov c, 0
1073   0A89 DD            push bl
1074   0A8A 07 95 0A      call putchar
1075   0A8D 51 01 00      add sp, 1
1076   0A90             ; --- END FUNCTION CALL
1077   0A90 0A 4B 0A      jmp _while19_cond
1078   0A93             _while19_exit:
1079   0A93 F9            leave
1080   0A94 09            ret
1081   0A95             
1082   0A95             putchar:
1083   0A95 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1084   0A98             ; --- BEGIN INLINE ASM SEGMENT
1085   0A98 FA 05 00      lea d, [bp + 5] ; $c
1086   0A9B 1E            mov al, [d]
1087   0A9C 23            mov ah, al
1088   0A9D 19 00         mov al, 0
1089   0A9F 05 03         syscall sys_io      ; char in AH
1090   0AA1             ; --- END INLINE ASM SEGMENT
1091   0AA1 F9            leave
1092   0AA2 09            ret
1093   0AA3             
1094   0AA3             print_unsigned_long:
1095   0AA3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1096   0AA6             ; char digits[10]; 
1097   0AA6 52 0A 00      sub sp, 10
1098   0AA9             ; int i; 
1099   0AA9 52 02 00      sub sp, 2
1100   0AAC             ; i = 0; 
1101   0AAC FA F5 FF      lea d, [bp + -11] ; $i
1102   0AAF DA            push d
1103   0AB0 FD 2E 00 00   mov32 cb, $00000000
1103   0AB4 00 00 
1104   0AB6 E7            pop d
1105   0AB7 FD 43         mov [d], b
1106   0AB9             ; if(num == 0){ 
1107   0AB9             _if20_cond:
1108   0AB9 FA 05 00      lea d, [bp + 5] ; $num
1109   0ABC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1110   0ABF FD 39         mov c, b ; And place it into C
1111   0AC1 2A            mov b, [d] ; Lower Word in B
1112   0AC2             ; --- START RELATIONAL
1113   0AC2 D7            push a
1114   0AC3 FD D8         push g
1115   0AC5 11            mov a, b
1116   0AC6 FD 7A         mov g, c
1117   0AC8 FD 2E 00 00   mov32 cb, $00000000
1117   0ACC 00 00 
1118   0ACE FD AF         cmp32 ga, cb
1119   0AD0 FD 71         seq ; ==
1120   0AD2 FD F1         pop g
1121   0AD4 E4            pop a
1122   0AD5             ; --- END RELATIONAL
1123   0AD5 C0 00 00      cmp b, 0
1124   0AD8 C6 ED 0A      je _if20_exit
1125   0ADB             _if20_TRUE:
1126   0ADB             ; putchar('0'); 
1127   0ADB             ; --- START FUNCTION CALL
1128   0ADB FD 2E 30 00   mov32 cb, $00000030
1128   0ADF 00 00 
1129   0AE1 DD            push bl
1130   0AE2 07 95 0A      call putchar
1131   0AE5 51 01 00      add sp, 1
1132   0AE8             ; --- END FUNCTION CALL
1133   0AE8             ; return; 
1134   0AE8 F9            leave
1135   0AE9 09            ret
1136   0AEA 0A ED 0A      jmp _if20_exit
1137   0AED             _if20_exit:
1138   0AED             ; while (num > 0) { 
1139   0AED             _while21_cond:
1140   0AED FA 05 00      lea d, [bp + 5] ; $num
1141   0AF0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1142   0AF3 FD 39         mov c, b ; And place it into C
1143   0AF5 2A            mov b, [d] ; Lower Word in B
1144   0AF6             ; --- START RELATIONAL
1145   0AF6 D7            push a
1146   0AF7 FD D8         push g
1147   0AF9 11            mov a, b
1148   0AFA FD 7A         mov g, c
1149   0AFC FD 2E 00 00   mov32 cb, $00000000
1149   0B00 00 00 
1150   0B02 FD AF         cmp32 ga, cb
1151   0B04 FD 81         sgu
1152   0B06 FD F1         pop g
1153   0B08 E4            pop a
1154   0B09             ; --- END RELATIONAL
1155   0B09 C0 00 00      cmp b, 0
1156   0B0C C6 8D 0B      je _while21_exit
1157   0B0F             _while21_block:
1158   0B0F             ; digits[i] = '0' + (num % 10); 
1159   0B0F FA F7 FF      lea d, [bp + -9] ; $digits
1160   0B12 D7            push a
1161   0B13 DA            push d
1162   0B14 FA F5 FF      lea d, [bp + -11] ; $i
1163   0B17 2A            mov b, [d]
1164   0B18 38 00 00      mov c, 0
1165   0B1B E7            pop d
1166   0B1C 5A            add d, b
1167   0B1D E4            pop a
1168   0B1E DA            push d
1169   0B1F FD 2E 30 00   mov32 cb, $00000030
1169   0B23 00 00 
1170   0B25             ; --- START TERMS
1171   0B25 D7            push a
1172   0B26 11            mov a, b
1173   0B27 FA 05 00      lea d, [bp + 5] ; $num
1174   0B2A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1175   0B2D FD 39         mov c, b ; And place it into C
1176   0B2F 2A            mov b, [d] ; Lower Word in B
1177   0B30             ; --- START FACTORS
1178   0B30 D7            push a
1179   0B31 FD D8         push g
1180   0B33 11            mov a, b
1181   0B34 FD 7A         mov g, c
1182   0B36 FD 2E 0A 00   mov32 cb, $0000000a
1182   0B3A 00 00 
1183   0B3C FD D8         push g ; save 'g' as the div instruction uses it
1184   0B3E AE            div a, b ; %, a: quotient, b: remainder
1185   0B3F 11            mov a, b
1186   0B40 FD F1         pop g
1187   0B42 FD 38         mov c, g
1188   0B44 27            mov b, a
1189   0B45 FD F1         pop g
1190   0B47 E4            pop a
1191   0B48             ; --- END FACTORS
1192   0B48 FD 15         add32 cb, ga
1193   0B4A E4            pop a
1194   0B4B             ; --- END TERMS
1195   0B4B E7            pop d
1196   0B4C FD 3E         mov [d], bl
1197   0B4E             ; num = num / 10; 
1198   0B4E FA 05 00      lea d, [bp + 5] ; $num
1199   0B51 DA            push d
1200   0B52 FA 05 00      lea d, [bp + 5] ; $num
1201   0B55 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1202   0B58 FD 39         mov c, b ; And place it into C
1203   0B5A 2A            mov b, [d] ; Lower Word in B
1204   0B5B             ; --- START FACTORS
1205   0B5B D7            push a
1206   0B5C FD D8         push g
1207   0B5E 11            mov a, b
1208   0B5F FD 7A         mov g, c
1209   0B61 FD 2E 0A 00   mov32 cb, $0000000a
1209   0B65 00 00 
1210   0B67 FD D8         push g ; save 'g' as the div instruction uses it
1211   0B69 AE            div a, b ; /, a: quotient, b: remainder
1212   0B6A FD F1         pop g
1213   0B6C FD 38         mov c, g
1214   0B6E 27            mov b, a
1215   0B6F FD F1         pop g
1216   0B71 E4            pop a
1217   0B72             ; --- END FACTORS
1218   0B72 E7            pop d
1219   0B73 FD 43         mov [d], b
1220   0B75 28            mov b, c
1221   0B76 FD 44 02 00   mov [d + 2], b
1222   0B7A             ; i++; 
1223   0B7A FA F5 FF      lea d, [bp + -11] ; $i
1224   0B7D 2A            mov b, [d]
1225   0B7E 38 00 00      mov c, 0
1226   0B81 11            mov a, b
1227   0B82 FD 77         inc b
1228   0B84 FA F5 FF      lea d, [bp + -11] ; $i
1229   0B87 FD 43         mov [d], b
1230   0B89 27            mov b, a
1231   0B8A 0A ED 0A      jmp _while21_cond
1232   0B8D             _while21_exit:
1233   0B8D             ; while (i > 0) { 
1234   0B8D             _while28_cond:
1235   0B8D FA F5 FF      lea d, [bp + -11] ; $i
1236   0B90 2A            mov b, [d]
1237   0B91 38 00 00      mov c, 0
1238   0B94             ; --- START RELATIONAL
1239   0B94 D7            push a
1240   0B95 11            mov a, b
1241   0B96 FD 2E 00 00   mov32 cb, $00000000
1241   0B9A 00 00 
1242   0B9C B0            cmp a, b
1243   0B9D FD 7F         sgt ; >
1244   0B9F E4            pop a
1245   0BA0             ; --- END RELATIONAL
1246   0BA0 C0 00 00      cmp b, 0
1247   0BA3 C6 D5 0B      je _while28_exit
1248   0BA6             _while28_block:
1249   0BA6             ; i--; 
1250   0BA6 FA F5 FF      lea d, [bp + -11] ; $i
1251   0BA9 2A            mov b, [d]
1252   0BAA 38 00 00      mov c, 0
1253   0BAD 11            mov a, b
1254   0BAE FD 7D         dec b
1255   0BB0 FA F5 FF      lea d, [bp + -11] ; $i
1256   0BB3 FD 43         mov [d], b
1257   0BB5 27            mov b, a
1258   0BB6             ; putchar(digits[i]); 
1259   0BB6             ; --- START FUNCTION CALL
1260   0BB6 FA F7 FF      lea d, [bp + -9] ; $digits
1261   0BB9 D7            push a
1262   0BBA DA            push d
1263   0BBB FA F5 FF      lea d, [bp + -11] ; $i
1264   0BBE 2A            mov b, [d]
1265   0BBF 38 00 00      mov c, 0
1266   0BC2 E7            pop d
1267   0BC3 5A            add d, b
1268   0BC4 E4            pop a
1269   0BC5 32            mov bl, [d]
1270   0BC6 A7 00         mov bh, 0
1271   0BC8 38 00 00      mov c, 0
1272   0BCB DD            push bl
1273   0BCC 07 95 0A      call putchar
1274   0BCF 51 01 00      add sp, 1
1275   0BD2             ; --- END FUNCTION CALL
1276   0BD2 0A 8D 0B      jmp _while28_cond
1277   0BD5             _while28_exit:
1278   0BD5 F9            leave
1279   0BD6 09            ret
1280   0BD7             
1281   0BD7             printx32:
1282   0BD7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1283   0BDA             ; --- BEGIN INLINE ASM SEGMENT
1284   0BDA FA 05 00      lea d, [bp + 5] ; $hex
1285   0BDD 2B 02 00      mov b, [d+2]
1286   0BE0 07 E9 0B      call print_u16x_printx32
1287   0BE3 2A            mov b, [d]
1288   0BE4 07 E9 0B      call print_u16x_printx32
1289   0BE7             ; --- END INLINE ASM SEGMENT
1290   0BE7             ; return; 
1291   0BE7 F9            leave
1292   0BE8 09            ret
1293   0BE9             ; --- BEGIN INLINE ASM SEGMENT
1294   0BE9             print_u16x_printx32:
1295   0BE9 D7            push a
1296   0BEA D8            push b
1297   0BEB DD            push bl
1298   0BEC 30            mov bl, bh
1299   0BED 07 0B 0C      call _itoa_printx32        ; convert bh to char in A
1300   0BF0 2F            mov bl, al        ; save al
1301   0BF1 19 00         mov al, 0
1302   0BF3 05 03         syscall sys_io        ; display AH
1303   0BF5 24            mov ah, bl        ; retrieve al
1304   0BF6 19 00         mov al, 0
1305   0BF8 05 03         syscall sys_io        ; display AL
1306   0BFA EA            pop bl
1307   0BFB 07 0B 0C      call _itoa_printx32        ; convert bh to char in A
1308   0BFE 2F            mov bl, al        ; save al
1309   0BFF 19 00         mov al, 0
1310   0C01 05 03         syscall sys_io        ; display AH
1311   0C03 24            mov ah, bl        ; retrieve al
1312   0C04 19 00         mov al, 0
1313   0C06 05 03         syscall sys_io        ; display AL
1314   0C08 E5            pop b
1315   0C09 E4            pop a
1316   0C0A 09            ret
1317   0C0B             _itoa_printx32:
1318   0C0B DA            push d
1319   0C0C D8            push b
1320   0C0D A7 00         mov bh, 0
1321   0C0F FD A4 04      shr bl, 4  
1322   0C12 74            mov d, b
1323   0C13 1F 25 0C      mov al, [d + s_hex_digits_printx32]
1324   0C16 23            mov ah, al
1325   0C17 E5            pop b
1326   0C18 D8            push b
1327   0C19 A7 00         mov bh, 0
1328   0C1B FD 87 0F      and bl, $0F
1329   0C1E 74            mov d, b
1330   0C1F 1F 25 0C      mov al, [d + s_hex_digits_printx32]
1331   0C22 E5            pop b
1332   0C23 E7            pop d
1333   0C24 09            ret
1334   0C25 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1334   0C29 34 35 36 37 
1334   0C2D 38 39 41 42 
1334   0C31 43 44 45 46 
1335   0C35             ; --- END INLINE ASM SEGMENT
1336   0C35 F9            leave
1337   0C36 09            ret
1338   0C37             
1339   0C37             err:
1340   0C37 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1341   0C3A             ; print(e); 
1342   0C3A             ; --- START FUNCTION CALL
1343   0C3A FA 05 00      lea d, [bp + 5] ; $e
1344   0C3D 2A            mov b, [d]
1345   0C3E 38 00 00      mov c, 0
1346   0C41 FD AB         swp b
1347   0C43 D8            push b
1348   0C44 07 4C 0C      call print
1349   0C47 51 02 00      add sp, 2
1350   0C4A             ; --- END FUNCTION CALL
1351   0C4A F9            leave
1352   0C4B 09            ret
1353   0C4C             
1354   0C4C             print:
1355   0C4C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1356   0C4F             ; --- BEGIN INLINE ASM SEGMENT
1357   0C4F FA 05 00      lea d, [bp + 5] ; $s
1358   0C52 FD 2A         mov d, [d]
1359   0C54             _puts_L1_print:
1360   0C54 1E            mov al, [d]
1361   0C55 B9 00         cmp al, 0
1362   0C57 C6 63 0C      jz _puts_END_print
1363   0C5A 23            mov ah, al
1364   0C5B 19 00         mov al, 0
1365   0C5D 05 03         syscall sys_io
1366   0C5F 79            inc d
1367   0C60 0A 54 0C      jmp _puts_L1_print
1368   0C63             _puts_END_print:
1369   0C63             ; --- END INLINE ASM SEGMENT
1370   0C63 F9            leave
1371   0C64 09            ret
1372   0C65             
1373   0C65             print_signed:
1374   0C65 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1375   0C68             ; char digits[5]; 
1376   0C68 52 05 00      sub sp, 5
1377   0C6B             ; int i = 0; 
1378   0C6B 52 02 00      sub sp, 2
1379   0C6E             ; --- START LOCAL VAR INITIALIZATION
1380   0C6E FA FA FF      lea d, [bp + -6] ; $i
1381   0C71 DA            push d
1382   0C72 FD 2E 00 00   mov32 cb, $00000000
1382   0C76 00 00 
1383   0C78 E7            pop d
1384   0C79 FD 43         mov [d], b
1385   0C7B             ; --- END LOCAL VAR INITIALIZATION
1386   0C7B             ; if (num < 0) { 
1387   0C7B             _if29_cond:
1388   0C7B FA 05 00      lea d, [bp + 5] ; $num
1389   0C7E 2A            mov b, [d]
1390   0C7F 38 00 00      mov c, 0
1391   0C82             ; --- START RELATIONAL
1392   0C82 D7            push a
1393   0C83 11            mov a, b
1394   0C84 FD 2E 00 00   mov32 cb, $00000000
1394   0C88 00 00 
1395   0C8A B0            cmp a, b
1396   0C8B FD 73         slt ; < (signed)
1397   0C8D E4            pop a
1398   0C8E             ; --- END RELATIONAL
1399   0C8E C0 00 00      cmp b, 0
1400   0C91 C6 B4 0C      je _if29_else
1401   0C94             _if29_TRUE:
1402   0C94             ; putchar('-'); 
1403   0C94             ; --- START FUNCTION CALL
1404   0C94 FD 2E 2D 00   mov32 cb, $0000002d
1404   0C98 00 00 
1405   0C9A DD            push bl
1406   0C9B 07 95 0A      call putchar
1407   0C9E 51 01 00      add sp, 1
1408   0CA1             ; --- END FUNCTION CALL
1409   0CA1             ; num = -num; 
1410   0CA1 FA 05 00      lea d, [bp + 5] ; $num
1411   0CA4 DA            push d
1412   0CA5 FA 05 00      lea d, [bp + 5] ; $num
1413   0CA8 2A            mov b, [d]
1414   0CA9 38 00 00      mov c, 0
1415   0CAC FD 97         neg b
1416   0CAE E7            pop d
1417   0CAF FD 43         mov [d], b
1418   0CB1 0A DF 0C      jmp _if29_exit
1419   0CB4             _if29_else:
1420   0CB4             ; if (num == 0) { 
1421   0CB4             _if30_cond:
1422   0CB4 FA 05 00      lea d, [bp + 5] ; $num
1423   0CB7 2A            mov b, [d]
1424   0CB8 38 00 00      mov c, 0
1425   0CBB             ; --- START RELATIONAL
1426   0CBB D7            push a
1427   0CBC 11            mov a, b
1428   0CBD FD 2E 00 00   mov32 cb, $00000000
1428   0CC1 00 00 
1429   0CC3 B0            cmp a, b
1430   0CC4 FD 71         seq ; ==
1431   0CC6 E4            pop a
1432   0CC7             ; --- END RELATIONAL
1433   0CC7 C0 00 00      cmp b, 0
1434   0CCA C6 DF 0C      je _if30_exit
1435   0CCD             _if30_TRUE:
1436   0CCD             ; putchar('0'); 
1437   0CCD             ; --- START FUNCTION CALL
1438   0CCD FD 2E 30 00   mov32 cb, $00000030
1438   0CD1 00 00 
1439   0CD3 DD            push bl
1440   0CD4 07 95 0A      call putchar
1441   0CD7 51 01 00      add sp, 1
1442   0CDA             ; --- END FUNCTION CALL
1443   0CDA             ; return; 
1444   0CDA F9            leave
1445   0CDB 09            ret
1446   0CDC 0A DF 0C      jmp _if30_exit
1447   0CDF             _if30_exit:
1448   0CDF             _if29_exit:
1449   0CDF             ; while (num > 0) { 
1450   0CDF             _while31_cond:
1451   0CDF FA 05 00      lea d, [bp + 5] ; $num
1452   0CE2 2A            mov b, [d]
1453   0CE3 38 00 00      mov c, 0
1454   0CE6             ; --- START RELATIONAL
1455   0CE6 D7            push a
1456   0CE7 11            mov a, b
1457   0CE8 FD 2E 00 00   mov32 cb, $00000000
1457   0CEC 00 00 
1458   0CEE B0            cmp a, b
1459   0CEF FD 7F         sgt ; >
1460   0CF1 E4            pop a
1461   0CF2             ; --- END RELATIONAL
1462   0CF2 C0 00 00      cmp b, 0
1463   0CF5 C6 6C 0D      je _while31_exit
1464   0CF8             _while31_block:
1465   0CF8             ; digits[i] = '0' + (num % 10); 
1466   0CF8 FA FC FF      lea d, [bp + -4] ; $digits
1467   0CFB D7            push a
1468   0CFC DA            push d
1469   0CFD FA FA FF      lea d, [bp + -6] ; $i
1470   0D00 2A            mov b, [d]
1471   0D01 38 00 00      mov c, 0
1472   0D04 E7            pop d
1473   0D05 5A            add d, b
1474   0D06 E4            pop a
1475   0D07 DA            push d
1476   0D08 FD 2E 30 00   mov32 cb, $00000030
1476   0D0C 00 00 
1477   0D0E             ; --- START TERMS
1478   0D0E D7            push a
1479   0D0F 11            mov a, b
1480   0D10 FA 05 00      lea d, [bp + 5] ; $num
1481   0D13 2A            mov b, [d]
1482   0D14 38 00 00      mov c, 0
1483   0D17             ; --- START FACTORS
1484   0D17 D7            push a
1485   0D18 FD D8         push g
1486   0D1A 11            mov a, b
1487   0D1B FD 7A         mov g, c
1488   0D1D FD 2E 0A 00   mov32 cb, $0000000a
1488   0D21 00 00 
1489   0D23 FD D8         push g ; save 'g' as the div instruction uses it
1490   0D25 AE            div a, b ; %, a: quotient, b: remainder
1491   0D26 11            mov a, b
1492   0D27 FD F1         pop g
1493   0D29 FD 38         mov c, g
1494   0D2B 27            mov b, a
1495   0D2C FD F1         pop g
1496   0D2E E4            pop a
1497   0D2F             ; --- END FACTORS
1498   0D2F 56            add b, a
1499   0D30 E4            pop a
1500   0D31             ; --- END TERMS
1501   0D31 E7            pop d
1502   0D32 FD 3E         mov [d], bl
1503   0D34             ; num = num / 10; 
1504   0D34 FA 05 00      lea d, [bp + 5] ; $num
1505   0D37 DA            push d
1506   0D38 FA 05 00      lea d, [bp + 5] ; $num
1507   0D3B 2A            mov b, [d]
1508   0D3C 38 00 00      mov c, 0
1509   0D3F             ; --- START FACTORS
1510   0D3F D7            push a
1511   0D40 FD D8         push g
1512   0D42 11            mov a, b
1513   0D43 FD 7A         mov g, c
1514   0D45 FD 2E 0A 00   mov32 cb, $0000000a
1514   0D49 00 00 
1515   0D4B FD D8         push g ; save 'g' as the div instruction uses it
1516   0D4D AE            div a, b ; /, a: quotient, b: remainder
1517   0D4E FD F1         pop g
1518   0D50 FD 38         mov c, g
1519   0D52 27            mov b, a
1520   0D53 FD F1         pop g
1521   0D55 E4            pop a
1522   0D56             ; --- END FACTORS
1523   0D56 E7            pop d
1524   0D57 FD 43         mov [d], b
1525   0D59             ; i++; 
1526   0D59 FA FA FF      lea d, [bp + -6] ; $i
1527   0D5C 2A            mov b, [d]
1528   0D5D 38 00 00      mov c, 0
1529   0D60 11            mov a, b
1530   0D61 FD 77         inc b
1531   0D63 FA FA FF      lea d, [bp + -6] ; $i
1532   0D66 FD 43         mov [d], b
1533   0D68 27            mov b, a
1534   0D69 0A DF 0C      jmp _while31_cond
1535   0D6C             _while31_exit:
1536   0D6C             ; while (i > 0) { 
1537   0D6C             _while38_cond:
1538   0D6C FA FA FF      lea d, [bp + -6] ; $i
1539   0D6F 2A            mov b, [d]
1540   0D70 38 00 00      mov c, 0
1541   0D73             ; --- START RELATIONAL
1542   0D73 D7            push a
1543   0D74 11            mov a, b
1544   0D75 FD 2E 00 00   mov32 cb, $00000000
1544   0D79 00 00 
1545   0D7B B0            cmp a, b
1546   0D7C FD 7F         sgt ; >
1547   0D7E E4            pop a
1548   0D7F             ; --- END RELATIONAL
1549   0D7F C0 00 00      cmp b, 0
1550   0D82 C6 B4 0D      je _while38_exit
1551   0D85             _while38_block:
1552   0D85             ; i--; 
1553   0D85 FA FA FF      lea d, [bp + -6] ; $i
1554   0D88 2A            mov b, [d]
1555   0D89 38 00 00      mov c, 0
1556   0D8C 11            mov a, b
1557   0D8D FD 7D         dec b
1558   0D8F FA FA FF      lea d, [bp + -6] ; $i
1559   0D92 FD 43         mov [d], b
1560   0D94 27            mov b, a
1561   0D95             ; putchar(digits[i]); 
1562   0D95             ; --- START FUNCTION CALL
1563   0D95 FA FC FF      lea d, [bp + -4] ; $digits
1564   0D98 D7            push a
1565   0D99 DA            push d
1566   0D9A FA FA FF      lea d, [bp + -6] ; $i
1567   0D9D 2A            mov b, [d]
1568   0D9E 38 00 00      mov c, 0
1569   0DA1 E7            pop d
1570   0DA2 5A            add d, b
1571   0DA3 E4            pop a
1572   0DA4 32            mov bl, [d]
1573   0DA5 A7 00         mov bh, 0
1574   0DA7 38 00 00      mov c, 0
1575   0DAA DD            push bl
1576   0DAB 07 95 0A      call putchar
1577   0DAE 51 01 00      add sp, 1
1578   0DB1             ; --- END FUNCTION CALL
1579   0DB1 0A 6C 0D      jmp _while38_cond
1580   0DB4             _while38_exit:
1581   0DB4 F9            leave
1582   0DB5 09            ret
1583   0DB6             
1584   0DB6             print_unsigned:
1585   0DB6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1586   0DB9             ; char digits[5]; 
1587   0DB9 52 05 00      sub sp, 5
1588   0DBC             ; int i; 
1589   0DBC 52 02 00      sub sp, 2
1590   0DBF             ; i = 0; 
1591   0DBF FA FA FF      lea d, [bp + -6] ; $i
1592   0DC2 DA            push d
1593   0DC3 FD 2E 00 00   mov32 cb, $00000000
1593   0DC7 00 00 
1594   0DC9 E7            pop d
1595   0DCA FD 43         mov [d], b
1596   0DCC             ; if(num == 0){ 
1597   0DCC             _if39_cond:
1598   0DCC FA 05 00      lea d, [bp + 5] ; $num
1599   0DCF 2A            mov b, [d]
1600   0DD0 38 00 00      mov c, 0
1601   0DD3             ; --- START RELATIONAL
1602   0DD3 D7            push a
1603   0DD4 11            mov a, b
1604   0DD5 FD 2E 00 00   mov32 cb, $00000000
1604   0DD9 00 00 
1605   0DDB B0            cmp a, b
1606   0DDC FD 71         seq ; ==
1607   0DDE E4            pop a
1608   0DDF             ; --- END RELATIONAL
1609   0DDF C0 00 00      cmp b, 0
1610   0DE2 C6 F7 0D      je _if39_exit
1611   0DE5             _if39_TRUE:
1612   0DE5             ; putchar('0'); 
1613   0DE5             ; --- START FUNCTION CALL
1614   0DE5 FD 2E 30 00   mov32 cb, $00000030
1614   0DE9 00 00 
1615   0DEB DD            push bl
1616   0DEC 07 95 0A      call putchar
1617   0DEF 51 01 00      add sp, 1
1618   0DF2             ; --- END FUNCTION CALL
1619   0DF2             ; return; 
1620   0DF2 F9            leave
1621   0DF3 09            ret
1622   0DF4 0A F7 0D      jmp _if39_exit
1623   0DF7             _if39_exit:
1624   0DF7             ; while (num > 0) { 
1625   0DF7             _while40_cond:
1626   0DF7 FA 05 00      lea d, [bp + 5] ; $num
1627   0DFA 2A            mov b, [d]
1628   0DFB 38 00 00      mov c, 0
1629   0DFE             ; --- START RELATIONAL
1630   0DFE D7            push a
1631   0DFF 11            mov a, b
1632   0E00 FD 2E 00 00   mov32 cb, $00000000
1632   0E04 00 00 
1633   0E06 B0            cmp a, b
1634   0E07 FD 81         sgu ; > (unsigned)
1635   0E09 E4            pop a
1636   0E0A             ; --- END RELATIONAL
1637   0E0A C0 00 00      cmp b, 0
1638   0E0D C6 84 0E      je _while40_exit
1639   0E10             _while40_block:
1640   0E10             ; digits[i] = '0' + (num % 10); 
1641   0E10 FA FC FF      lea d, [bp + -4] ; $digits
1642   0E13 D7            push a
1643   0E14 DA            push d
1644   0E15 FA FA FF      lea d, [bp + -6] ; $i
1645   0E18 2A            mov b, [d]
1646   0E19 38 00 00      mov c, 0
1647   0E1C E7            pop d
1648   0E1D 5A            add d, b
1649   0E1E E4            pop a
1650   0E1F DA            push d
1651   0E20 FD 2E 30 00   mov32 cb, $00000030
1651   0E24 00 00 
1652   0E26             ; --- START TERMS
1653   0E26 D7            push a
1654   0E27 11            mov a, b
1655   0E28 FA 05 00      lea d, [bp + 5] ; $num
1656   0E2B 2A            mov b, [d]
1657   0E2C 38 00 00      mov c, 0
1658   0E2F             ; --- START FACTORS
1659   0E2F D7            push a
1660   0E30 FD D8         push g
1661   0E32 11            mov a, b
1662   0E33 FD 7A         mov g, c
1663   0E35 FD 2E 0A 00   mov32 cb, $0000000a
1663   0E39 00 00 
1664   0E3B FD D8         push g ; save 'g' as the div instruction uses it
1665   0E3D AE            div a, b ; %, a: quotient, b: remainder
1666   0E3E 11            mov a, b
1667   0E3F FD F1         pop g
1668   0E41 FD 38         mov c, g
1669   0E43 27            mov b, a
1670   0E44 FD F1         pop g
1671   0E46 E4            pop a
1672   0E47             ; --- END FACTORS
1673   0E47 56            add b, a
1674   0E48 E4            pop a
1675   0E49             ; --- END TERMS
1676   0E49 E7            pop d
1677   0E4A FD 3E         mov [d], bl
1678   0E4C             ; num = num / 10; 
1679   0E4C FA 05 00      lea d, [bp + 5] ; $num
1680   0E4F DA            push d
1681   0E50 FA 05 00      lea d, [bp + 5] ; $num
1682   0E53 2A            mov b, [d]
1683   0E54 38 00 00      mov c, 0
1684   0E57             ; --- START FACTORS
1685   0E57 D7            push a
1686   0E58 FD D8         push g
1687   0E5A 11            mov a, b
1688   0E5B FD 7A         mov g, c
1689   0E5D FD 2E 0A 00   mov32 cb, $0000000a
1689   0E61 00 00 
1690   0E63 FD D8         push g ; save 'g' as the div instruction uses it
1691   0E65 AE            div a, b ; /, a: quotient, b: remainder
1692   0E66 FD F1         pop g
1693   0E68 FD 38         mov c, g
1694   0E6A 27            mov b, a
1695   0E6B FD F1         pop g
1696   0E6D E4            pop a
1697   0E6E             ; --- END FACTORS
1698   0E6E E7            pop d
1699   0E6F FD 43         mov [d], b
1700   0E71             ; i++; 
1701   0E71 FA FA FF      lea d, [bp + -6] ; $i
1702   0E74 2A            mov b, [d]
1703   0E75 38 00 00      mov c, 0
1704   0E78 11            mov a, b
1705   0E79 FD 77         inc b
1706   0E7B FA FA FF      lea d, [bp + -6] ; $i
1707   0E7E FD 43         mov [d], b
1708   0E80 27            mov b, a
1709   0E81 0A F7 0D      jmp _while40_cond
1710   0E84             _while40_exit:
1711   0E84             ; while (i > 0) { 
1712   0E84             _while47_cond:
1713   0E84 FA FA FF      lea d, [bp + -6] ; $i
1714   0E87 2A            mov b, [d]
1715   0E88 38 00 00      mov c, 0
1716   0E8B             ; --- START RELATIONAL
1717   0E8B D7            push a
1718   0E8C 11            mov a, b
1719   0E8D FD 2E 00 00   mov32 cb, $00000000
1719   0E91 00 00 
1720   0E93 B0            cmp a, b
1721   0E94 FD 7F         sgt ; >
1722   0E96 E4            pop a
1723   0E97             ; --- END RELATIONAL
1724   0E97 C0 00 00      cmp b, 0
1725   0E9A C6 CC 0E      je _while47_exit
1726   0E9D             _while47_block:
1727   0E9D             ; i--; 
1728   0E9D FA FA FF      lea d, [bp + -6] ; $i
1729   0EA0 2A            mov b, [d]
1730   0EA1 38 00 00      mov c, 0
1731   0EA4 11            mov a, b
1732   0EA5 FD 7D         dec b
1733   0EA7 FA FA FF      lea d, [bp + -6] ; $i
1734   0EAA FD 43         mov [d], b
1735   0EAC 27            mov b, a
1736   0EAD             ; putchar(digits[i]); 
1737   0EAD             ; --- START FUNCTION CALL
1738   0EAD FA FC FF      lea d, [bp + -4] ; $digits
1739   0EB0 D7            push a
1740   0EB1 DA            push d
1741   0EB2 FA FA FF      lea d, [bp + -6] ; $i
1742   0EB5 2A            mov b, [d]
1743   0EB6 38 00 00      mov c, 0
1744   0EB9 E7            pop d
1745   0EBA 5A            add d, b
1746   0EBB E4            pop a
1747   0EBC 32            mov bl, [d]
1748   0EBD A7 00         mov bh, 0
1749   0EBF 38 00 00      mov c, 0
1750   0EC2 DD            push bl
1751   0EC3 07 95 0A      call putchar
1752   0EC6 51 01 00      add sp, 1
1753   0EC9             ; --- END FUNCTION CALL
1754   0EC9 0A 84 0E      jmp _while47_cond
1755   0ECC             _while47_exit:
1756   0ECC F9            leave
1757   0ECD 09            ret
1758   0ECE             
1759   0ECE             printx16:
1760   0ECE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1761   0ED1             ; --- BEGIN INLINE ASM SEGMENT
1762   0ED1 FA 05 00      lea d, [bp + 5] ; $hex
1763   0ED4 2A            mov b, [d]
1764   0ED5             print_u16x_printx16:
1765   0ED5 DD            push bl
1766   0ED6 30            mov bl, bh
1767   0ED7 07 F4 0E      call _itoa_printx16        ; convert bh to char in A
1768   0EDA 2F            mov bl, al        ; save al
1769   0EDB 19 00         mov al, 0
1770   0EDD 05 03         syscall sys_io        ; display AH
1771   0EDF 24            mov ah, bl        ; retrieve al
1772   0EE0 19 00         mov al, 0
1773   0EE2 05 03         syscall sys_io        ; display AL
1774   0EE4 EA            pop bl
1775   0EE5 07 F4 0E      call _itoa_printx16        ; convert bh to char in A
1776   0EE8 2F            mov bl, al        ; save al
1777   0EE9 19 00         mov al, 0
1778   0EEB 05 03         syscall sys_io        ; display AH
1779   0EED 24            mov ah, bl        ; retrieve al
1780   0EEE 19 00         mov al, 0
1781   0EF0 05 03         syscall sys_io        ; display AL
1782   0EF2             ; --- END INLINE ASM SEGMENT
1783   0EF2             ; return; 
1784   0EF2 F9            leave
1785   0EF3 09            ret
1786   0EF4             ; --- BEGIN INLINE ASM SEGMENT
1787   0EF4             _itoa_printx16:
1788   0EF4 DA            push d
1789   0EF5 D8            push b
1790   0EF6 A7 00         mov bh, 0
1791   0EF8 FD A4 04      shr bl, 4  
1792   0EFB 74            mov d, b
1793   0EFC 1F 0E 0F      mov al, [d + s_hex_digits_printx16]
1794   0EFF 23            mov ah, al
1795   0F00 E5            pop b
1796   0F01 D8            push b
1797   0F02 A7 00         mov bh, 0
1798   0F04 FD 87 0F      and bl, $0F
1799   0F07 74            mov d, b
1800   0F08 1F 0E 0F      mov al, [d + s_hex_digits_printx16]
1801   0F0B E5            pop b
1802   0F0C E7            pop d
1803   0F0D 09            ret
1804   0F0E 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1804   0F12 34 35 36 37 
1804   0F16 38 39 41 42 
1804   0F1A 43 44 45 46 
1805   0F1E             ; --- END INLINE ASM SEGMENT
1806   0F1E F9            leave
1807   0F1F 09            ret
1808   0F20             
1809   0F20             getchar:
1810   0F20 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1811   0F23             ; char c; 
1812   0F23 52 01 00      sub sp, 1
1813   0F26             ; --- BEGIN INLINE ASM SEGMENT
1814   0F26 19 01         mov al, 1
1815   0F28 05 03         syscall sys_io      ; receive in AH
1816   0F2A 1A            mov al, ah
1817   0F2B FA 00 00      lea d, [bp + 0] ; $c
1818   0F2E 3E            mov [d], al
1819   0F2F             ; --- END INLINE ASM SEGMENT
1820   0F2F             ; return c; 
1821   0F2F FA 00 00      lea d, [bp + 0] ; $c
1822   0F32 32            mov bl, [d]
1823   0F33 A7 00         mov bh, 0
1824   0F35 38 00 00      mov c, 0
1825   0F38 F9            leave
1826   0F39 09            ret
1827   0F3A             ; --- END TEXT SEGMENT
1828   0F3A             
1829   0F3A             ; --- BEGIN DATA SEGMENT
1830   0F3A 54 65 73 74 _s0: .db "Test of 5.25 inch Floppy Drive Interface.\n", 0
1830   0F3E 20 6F 66 20 
1830   0F42 35 2E 32 35 
1830   0F46 20 69 6E 63 
1830   0F4A 68 20 46 6C 
1830   0F4E 6F 70 70 79 
1830   0F52 20 44 72 69 
1830   0F56 76 65 20 49 
1830   0F5A 6E 74 65 72 
1830   0F5E 66 61 63 65 
1830   0F62 2E 0A 00 
1831   0F65 61 2E 20 73 _s1: .db "a. set reset bit and select drive 0\n", 0
1831   0F69 65 74 20 72 
1831   0F6D 65 73 65 74 
1831   0F71 20 62 69 74 
1831   0F75 20 61 6E 64 
1831   0F79 20 73 65 6C 
1831   0F7D 65 63 74 20 
1831   0F81 64 72 69 76 
1831   0F85 65 20 30 0A 
1831   0F89 00 
1832   0F8A 62 2E 20 63 _s2: .db "b. clear reset bit, and select drive 0\n", 0
1832   0F8E 6C 65 61 72 
1832   0F92 20 72 65 73 
1832   0F96 65 74 20 62 
1832   0F9A 69 74 2C 20 
1832   0F9E 61 6E 64 20 
1832   0FA2 73 65 6C 65 
1832   0FA6 63 74 20 64 
1832   0FAA 72 69 76 65 
1832   0FAE 20 30 0A 00 
1833   0FB2 30 2E 20 73 _s3: .db "0. select drive 0\n", 0
1833   0FB6 65 6C 65 63 
1833   0FBA 74 20 64 72 
1833   0FBE 69 76 65 20 
1833   0FC2 30 0A 00 
1834   0FC5 31 2E 20 73 _s4: .db "1. select drive 1\n", 0
1834   0FC9 65 6C 65 63 
1834   0FCD 74 20 64 72 
1834   0FD1 69 76 65 20 
1834   0FD5 31 0A 00 
1835   0FD8 77 2E 20 77 _s5: .db "w. write 16 to data register\n", 0
1835   0FDC 72 69 74 65 
1835   0FE0 20 31 36 20 
1835   0FE4 74 6F 20 64 
1835   0FE8 61 74 61 20 
1835   0FEC 72 65 67 69 
1835   0FF0 73 74 65 72 
1835   0FF4 0A 00 
1836   0FF6 64 2E 20 72 _s6: .db "d. read data register\n", 0
1836   0FFA 65 61 64 20 
1836   0FFE 64 61 74 61 
1836   1002 20 72 65 67 
1836   1006 69 73 74 65 
1836   100A 72 0A 00 
1837   100D 74 2E 20 72 _s7: .db "t. read track register\n", 0
1837   1011 65 61 64 20 
1837   1015 74 72 61 63 
1837   1019 6B 20 72 65 
1837   101D 67 69 73 74 
1837   1021 65 72 0A 00 
1838   1025 73 2E 20 73 _s8: .db "s. step\n", 0
1838   1029 74 65 70 0A 
1838   102D 00 
1839   102E 6B 2E 20 73 _s9: .db "k. seek\n", 0
1839   1032 65 65 6B 0A 
1839   1036 00 
1840   1037 72 2E 20 72 _s10: .db "r. restore\n", 0
1840   103B 65 73 74 6F 
1840   103F 72 65 0A 00 
1841   1043 69 2E 20 73 _s11: .db "i. step in\n", 0
1841   1047 74 65 70 20 
1841   104B 69 6E 0A 00 
1842   104F 6F 2E 20 73 _s12: .db "o. step out\n", 0
1842   1053 74 65 70 20 
1842   1057 6F 75 74 0A 
1842   105B 00 
1843   105C 65 2E 20 65 _s13: .db "e. exit\n", 0
1843   1060 78 69 74 0A 
1843   1064 00 
1844   1065 71 2E 20 72 _s14: .db "q. read pending irq status register\n", 0
1844   1069 65 61 64 20 
1844   106D 70 65 6E 64 
1844   1071 69 6E 67 20 
1844   1075 69 72 71 20 
1844   1079 73 74 61 74 
1844   107D 75 73 20 72 
1844   1081 65 67 69 73 
1844   1085 74 65 72 0A 
1844   1089 00 
1845   108A 0A 4F 70 74 _s15: .db "\nOption: ", 0
1845   108E 69 6F 6E 3A 
1845   1092 20 00 
1846   1094 0A 44 61 74 _s16: .db "\nData register value: %d\n", 0
1846   1098 61 20 72 65 
1846   109C 67 69 73 74 
1846   10A0 65 72 20 76 
1846   10A4 61 6C 75 65 
1846   10A8 3A 20 25 64 
1846   10AC 0A 00 
1847   10AE 0A 54 72 61 _s17: .db "\nTrack register value: %d\n", 0
1847   10B2 63 6B 20 72 
1847   10B6 65 67 69 73 
1847   10BA 74 65 72 20 
1847   10BE 76 61 6C 75 
1847   10C2 65 3A 20 25 
1847   10C6 64 0A 00 
1848   10C9 0A 4D 61 73 _s18: .db "\nMasks: %x\n", 0
1848   10CD 6B 73 3A 20 
1848   10D1 25 78 0A 00 
1849   10D5 55 6E 65 78 _s19: .db "Unexpected format in printf.", 0
1849   10D9 70 65 63 74 
1849   10DD 65 64 20 66 
1849   10E1 6F 72 6D 61 
1849   10E5 74 20 69 6E 
1849   10E9 20 70 72 69 
1849   10ED 6E 74 66 2E 
1849   10F1 00 
1850   10F2 45 72 72 6F _s20: .db "Error: Unknown argument type.\n", 0
1850   10F6 72 3A 20 55 
1850   10FA 6E 6B 6E 6F 
1850   10FE 77 6E 20 61 
1850   1102 72 67 75 6D 
1850   1106 65 6E 74 20 
1850   110A 74 79 70 65 
1850   110E 2E 0A 00 
1851   1111             
1852   1111 13 11       _heap_top: .dw _heap
1853   1113 00          _heap: .db 0
1854   1114             ; --- END DATA SEGMENT
1855   1114             
1856   1114             .end
tasm: Number of errors = 0
