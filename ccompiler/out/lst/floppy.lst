0001   0000             ; --- FILENAME: programs/floppy.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; char option; 
0011   0408 52 01 00      sub sp, 1
0012   040B             ; char byte; 
0013   040B 52 01 00      sub sp, 1
0014   040E             ; unsigned int word; 
0015   040E 52 02 00      sub sp, 2
0016   0411             ; printf("Test of 5.25 inch Floppy Drive Interface.\n"); 
0017   0411             ; --- START FUNCTION CALL
0018   0411 26 C6 0E      mov b, _s0 ; "Test of 5.25 inch Floppy Drive Interface.\n"
0019   0414 FD AB         swp b
0020   0416 D8            push b
0021   0417 07 AF 05      call printf
0022   041A 51 02 00      add sp, 2
0023   041D             ; --- END FUNCTION CALL
0024   041D             ; --- BEGIN INLINE ASM SEGMENT
0025   041D 3B C0 FF      mov d, $FFC0    ; wd1770 data register
0026   0420 19 02         mov al, 2       ; setparam call
0027   0422 2E 09         mov bl, $09     
0028   0424 05 0C         syscall sys_system
0029   0426             ; --- END INLINE ASM SEGMENT
0030   0426             ; for(;;){ 
0031   0426             _for1_init:
0032   0426             _for1_cond:
0033   0426             _for1_block:
0034   0426             ; printf("w. write 16 to data register\n"); 
0035   0426             ; --- START FUNCTION CALL
0036   0426 26 F1 0E      mov b, _s1 ; "w. write 16 to data register\n"
0037   0429 FD AB         swp b
0038   042B D8            push b
0039   042C 07 AF 05      call printf
0040   042F 51 02 00      add sp, 2
0041   0432             ; --- END FUNCTION CALL
0042   0432             ; printf("d. read data register\n"); 
0043   0432             ; --- START FUNCTION CALL
0044   0432 26 0F 0F      mov b, _s2 ; "d. read data register\n"
0045   0435 FD AB         swp b
0046   0437 D8            push b
0047   0438 07 AF 05      call printf
0048   043B 51 02 00      add sp, 2
0049   043E             ; --- END FUNCTION CALL
0050   043E             ; printf("t. read track register\n"); 
0051   043E             ; --- START FUNCTION CALL
0052   043E 26 26 0F      mov b, _s3 ; "t. read track register\n"
0053   0441 FD AB         swp b
0054   0443 D8            push b
0055   0444 07 AF 05      call printf
0056   0447 51 02 00      add sp, 2
0057   044A             ; --- END FUNCTION CALL
0058   044A             ; printf("s. step\n"); 
0059   044A             ; --- START FUNCTION CALL
0060   044A 26 3E 0F      mov b, _s4 ; "s. step\n"
0061   044D FD AB         swp b
0062   044F D8            push b
0063   0450 07 AF 05      call printf
0064   0453 51 02 00      add sp, 2
0065   0456             ; --- END FUNCTION CALL
0066   0456             ; printf("k. seek\n"); 
0067   0456             ; --- START FUNCTION CALL
0068   0456 26 47 0F      mov b, _s5 ; "k. seek\n"
0069   0459 FD AB         swp b
0070   045B D8            push b
0071   045C 07 AF 05      call printf
0072   045F 51 02 00      add sp, 2
0073   0462             ; --- END FUNCTION CALL
0074   0462             ; printf("r. restore\n"); 
0075   0462             ; --- START FUNCTION CALL
0076   0462 26 50 0F      mov b, _s6 ; "r. restore\n"
0077   0465 FD AB         swp b
0078   0467 D8            push b
0079   0468 07 AF 05      call printf
0080   046B 51 02 00      add sp, 2
0081   046E             ; --- END FUNCTION CALL
0082   046E             ; printf("i. step in\n"); 
0083   046E             ; --- START FUNCTION CALL
0084   046E 26 5C 0F      mov b, _s7 ; "i. step in\n"
0085   0471 FD AB         swp b
0086   0473 D8            push b
0087   0474 07 AF 05      call printf
0088   0477 51 02 00      add sp, 2
0089   047A             ; --- END FUNCTION CALL
0090   047A             ; printf("o. step out\n"); 
0091   047A             ; --- START FUNCTION CALL
0092   047A 26 68 0F      mov b, _s8 ; "o. step out\n"
0093   047D FD AB         swp b
0094   047F D8            push b
0095   0480 07 AF 05      call printf
0096   0483 51 02 00      add sp, 2
0097   0486             ; --- END FUNCTION CALL
0098   0486             ; printf("e. exit\n"); 
0099   0486             ; --- START FUNCTION CALL
0100   0486 26 75 0F      mov b, _s9 ; "e. exit\n"
0101   0489 FD AB         swp b
0102   048B D8            push b
0103   048C 07 AF 05      call printf
0104   048F 51 02 00      add sp, 2
0105   0492             ; --- END FUNCTION CALL
0106   0492             ; printf("q. read pending irq status register\n"); 
0107   0492             ; --- START FUNCTION CALL
0108   0492 26 7E 0F      mov b, _s10 ; "q. read pending irq status register\n"
0109   0495 FD AB         swp b
0110   0497 D8            push b
0111   0498 07 AF 05      call printf
0112   049B 51 02 00      add sp, 2
0113   049E             ; --- END FUNCTION CALL
0114   049E             ; printf("\nOption: "); 
0115   049E             ; --- START FUNCTION CALL
0116   049E 26 A3 0F      mov b, _s11 ; "\nOption: "
0117   04A1 FD AB         swp b
0118   04A3 D8            push b
0119   04A4 07 AF 05      call printf
0120   04A7 51 02 00      add sp, 2
0121   04AA             ; --- END FUNCTION CALL
0122   04AA             ; option = getchar(); 
0123   04AA FA 00 00      lea d, [bp + 0] ; $option
0124   04AD DA            push d
0125   04AE             ; --- START FUNCTION CALL
0126   04AE 07 AC 0E      call getchar
0127   04B1 E7            pop d
0128   04B2 FD 3E         mov [d], bl
0129   04B4             ; switch(option){ 
0130   04B4             _switch2_expr:
0131   04B4 FA 00 00      lea d, [bp + 0] ; $option
0132   04B7 32            mov bl, [d]
0133   04B8 A7 00         mov bh, 0
0134   04BA 38 00 00      mov c, 0
0135   04BD             _switch2_comparisons:
0136   04BD C1 77         cmp bl, $77
0137   04BF C6 F2 04      je _switch2_case0
0138   04C2 C1 64         cmp bl, $64
0139   04C4 C6 FE 04      je _switch2_case1
0140   04C7 C1 74         cmp bl, $74
0141   04C9 C6 25 05      je _switch2_case2
0142   04CC C1 73         cmp bl, $73
0143   04CE C6 4C 05      je _switch2_case3
0144   04D1 C1 6B         cmp bl, $6b
0145   04D3 C6 58 05      je _switch2_case4
0146   04D6 C1 72         cmp bl, $72
0147   04D8 C6 64 05      je _switch2_case5
0148   04DB C1 69         cmp bl, $69
0149   04DD C6 70 05      je _switch2_case6
0150   04E0 C1 6F         cmp bl, $6f
0151   04E2 C6 7C 05      je _switch2_case7
0152   04E5 C1 71         cmp bl, $71
0153   04E7 C6 88 05      je _switch2_case8
0154   04EA C1 65         cmp bl, $65
0155   04EC C6 A7 05      je _switch2_case9
0156   04EF 0A AA 05      jmp _switch2_exit
0157   04F2             _switch2_case0:
0158   04F2             ; --- BEGIN INLINE ASM SEGMENT
0159   04F2 3B CB FF      mov d, $FFCB    ; wd1770 data register
0160   04F5 19 02         mov al, 2       ; setparam call
0161   04F7 2E 10         mov bl, $10     ; track 16
0162   04F9 05 0C         syscall sys_system
0163   04FB             ; --- END INLINE ASM SEGMENT
0164   04FB             ; break; 
0165   04FB 0A AA 05      jmp _switch2_exit ; case break
0166   04FE             _switch2_case1:
0167   04FE             ; --- BEGIN INLINE ASM SEGMENT
0168   04FE 3B CB FF      mov d, $FFCB    ; wd1770 data register
0169   0501 19 04         mov al, 4       ; getparam call
0170   0503 05 0C         syscall sys_system
0171   0505 FA FF FF      lea d, [bp + -1] ; $byte
0172   0508 FD 3E         mov [d], bl
0173   050A             ; --- END INLINE ASM SEGMENT
0174   050A             ; printf("\nData register value: %d\n", byte); 
0175   050A             ; --- START FUNCTION CALL
0176   050A FA FF FF      lea d, [bp + -1] ; $byte
0177   050D 32            mov bl, [d]
0178   050E A7 00         mov bh, 0
0179   0510 38 00 00      mov c, 0
0180   0513 FD AB         swp b
0181   0515 D8            push b
0182   0516 26 AD 0F      mov b, _s12 ; "\nData register value: %d\n"
0183   0519 FD AB         swp b
0184   051B D8            push b
0185   051C 07 AF 05      call printf
0186   051F 51 03 00      add sp, 3
0187   0522             ; --- END FUNCTION CALL
0188   0522             ; break; 
0189   0522 0A AA 05      jmp _switch2_exit ; case break
0190   0525             _switch2_case2:
0191   0525             ; --- BEGIN INLINE ASM SEGMENT
0192   0525 3B C9 FF      mov d, $FFC9    ; wd1770 track register
0193   0528 19 04         mov al, 4       ; getparam call
0194   052A 05 0C         syscall sys_system
0195   052C FA FF FF      lea d, [bp + -1] ; $byte
0196   052F FD 3E         mov [d], bl
0197   0531             ; --- END INLINE ASM SEGMENT
0198   0531             ; printf("\nTrack register value: %d\n", byte); 
0199   0531             ; --- START FUNCTION CALL
0200   0531 FA FF FF      lea d, [bp + -1] ; $byte
0201   0534 32            mov bl, [d]
0202   0535 A7 00         mov bh, 0
0203   0537 38 00 00      mov c, 0
0204   053A FD AB         swp b
0205   053C D8            push b
0206   053D 26 C7 0F      mov b, _s13 ; "\nTrack register value: %d\n"
0207   0540 FD AB         swp b
0208   0542 D8            push b
0209   0543 07 AF 05      call printf
0210   0546 51 03 00      add sp, 3
0211   0549             ; --- END FUNCTION CALL
0212   0549             ; break; 
0213   0549 0A AA 05      jmp _switch2_exit ; case break
0214   054C             _switch2_case3:
0215   054C             ; --- BEGIN INLINE ASM SEGMENT
0216   054C 3B C8 FF      mov d, $FFC8    ; wd1770 command register
0217   054F 19 02         mov al, 2       ; setparam call
0218   0551 2E 23         mov bl, $23     ; STEP command, 30ms rate
0219   0553 05 0C         syscall sys_system
0220   0555             ; --- END INLINE ASM SEGMENT
0221   0555             ; break; 
0222   0555 0A AA 05      jmp _switch2_exit ; case break
0223   0558             _switch2_case4:
0224   0558             ; --- BEGIN INLINE ASM SEGMENT
0225   0558 3B C8 FF      mov d, $FFC8    ; wd1770 command register
0226   055B 19 02         mov al, 2       ; setparam call
0227   055D 2E 13         mov bl, $13     ; seek command
0228   055F 05 0C         syscall sys_system
0229   0561             ; --- END INLINE ASM SEGMENT
0230   0561             ; break; 
0231   0561 0A AA 05      jmp _switch2_exit ; case break
0232   0564             _switch2_case5:
0233   0564             ; --- BEGIN INLINE ASM SEGMENT
0234   0564               ; send restore command
0235   0564 3B C8 FF      mov d, $FFC8    ; wd1770
0236   0567 19 02         mov al, 2       ; setparam call
0237   0569 2E 03         mov bl, $03     ; restore command, 30ms rate
0238   056B 05 0C         syscall sys_system
0239   056D             ; --- END INLINE ASM SEGMENT
0240   056D             ; break; 
0241   056D 0A AA 05      jmp _switch2_exit ; case break
0242   0570             _switch2_case6:
0243   0570             ; --- BEGIN INLINE ASM SEGMENT
0244   0570               ; send step in command
0245   0570 3B C8 FF      mov d, $FFC8    ; wd1770
0246   0573 19 02         mov al, 2       ; setparam call
0247   0575 2E 43         mov bl, $43     ; step in command, 30ms rate
0248   0577 05 0C         syscall sys_system
0249   0579             ; --- END INLINE ASM SEGMENT
0250   0579             ; break; 
0251   0579 0A AA 05      jmp _switch2_exit ; case break
0252   057C             _switch2_case7:
0253   057C             ; --- BEGIN INLINE ASM SEGMENT
0254   057C               ; send step out command
0255   057C 3B C8 FF      mov d, $FFC8    ; wd1770
0256   057F 19 02         mov al, 2       ; setparam call
0257   0581 2E 63         mov bl, $63     ; step out command, 30ms rate
0258   0583 05 0C         syscall sys_system
0259   0585             ; --- END INLINE ASM SEGMENT
0260   0585             ; break; 
0261   0585 0A AA 05      jmp _switch2_exit ; case break
0262   0588             _switch2_case8:
0263   0588             ; --- BEGIN INLINE ASM SEGMENT
0264   0588 FD 0E         lodmsk          ; load masks register/irq status register
0265   058A FA FD FF      lea d, [bp + -3] ; $word
0266   058D               ; load address of word into d
0267   058D 43            mov [d], a      ; al = masks, ah = irq status
0268   058E             ; --- END INLINE ASM SEGMENT
0269   058E             ; printf("\nMasks: %x\n", word); 
0270   058E             ; --- START FUNCTION CALL
0271   058E FA FD FF      lea d, [bp + -3] ; $word
0272   0591 2A            mov b, [d]
0273   0592 38 00 00      mov c, 0
0274   0595 FD AB         swp b
0275   0597 D8            push b
0276   0598 26 E2 0F      mov b, _s14 ; "\nMasks: %x\n"
0277   059B FD AB         swp b
0278   059D D8            push b
0279   059E 07 AF 05      call printf
0280   05A1 51 04 00      add sp, 4
0281   05A4             ; --- END FUNCTION CALL
0282   05A4             ; break; 
0283   05A4 0A AA 05      jmp _switch2_exit ; case break
0284   05A7             _switch2_case9:
0285   05A7             ; return; 
0286   05A7 F9            leave
0287   05A8 05 0B         syscall sys_terminate_proc
0288   05AA             _switch2_exit:
0289   05AA             _for1_update:
0290   05AA 0A 26 04      jmp _for1_cond
0291   05AD             _for1_exit:
0292   05AD 05 0B         syscall sys_terminate_proc
0293   05AF             
0294   05AF             printf:
0295   05AF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0296   05B2             ; char *p, *format_p; 
0297   05B2 52 02 00      sub sp, 2
0298   05B5 52 02 00      sub sp, 2
0299   05B8             ; format_p = format; 
0300   05B8 FA FD FF      lea d, [bp + -3] ; $format_p
0301   05BB DA            push d
0302   05BC FA 05 00      lea d, [bp + 5] ; $format
0303   05BF 2A            mov b, [d]
0304   05C0 38 00 00      mov c, 0
0305   05C3 E7            pop d
0306   05C4 FD 43         mov [d], b
0307   05C6             ; p = &format + 2; 
0308   05C6 FA FF FF      lea d, [bp + -1] ; $p
0309   05C9 DA            push d
0310   05CA FA 05 00      lea d, [bp + 5] ; $format
0311   05CD 2D            mov b, d
0312   05CE             ; --- START TERMS
0313   05CE D7            push a
0314   05CF 11            mov a, b
0315   05D0 FD 2E 02 00   mov32 cb, $00000002
0315   05D4 00 00 
0316   05D6 56            add b, a
0317   05D7 E4            pop a
0318   05D8             ; --- END TERMS
0319   05D8 E7            pop d
0320   05D9 FD 43         mov [d], b
0321   05DB             ; for(;;){ 
0322   05DB             _for3_init:
0323   05DB             _for3_cond:
0324   05DB             _for3_block:
0325   05DB             ; if(!*format_p) break; 
0326   05DB             _if4_cond:
0327   05DB FA FD FF      lea d, [bp + -3] ; $format_p
0328   05DE 2A            mov b, [d]
0329   05DF 38 00 00      mov c, 0
0330   05E2 74            mov d, b
0331   05E3 32            mov bl, [d]
0332   05E4 A7 00         mov bh, 0
0333   05E6 38 00 00      mov c, 0
0334   05E9 C0 00 00      cmp b, 0
0335   05EC FD 71         seq ; !
0336   05EE C0 00 00      cmp b, 0
0337   05F1 C6 FA 05      je _if4_else
0338   05F4             _if4_TRUE:
0339   05F4             ; break; 
0340   05F4 0A 9A 08      jmp _for3_exit ; for break
0341   05F7 0A 87 08      jmp _if4_exit
0342   05FA             _if4_else:
0343   05FA             ; if(*format_p == '%'){ 
0344   05FA             _if5_cond:
0345   05FA FA FD FF      lea d, [bp + -3] ; $format_p
0346   05FD 2A            mov b, [d]
0347   05FE 38 00 00      mov c, 0
0348   0601 74            mov d, b
0349   0602 32            mov bl, [d]
0350   0603 A7 00         mov bh, 0
0351   0605 38 00 00      mov c, 0
0352   0608             ; --- START RELATIONAL
0353   0608 D7            push a
0354   0609 11            mov a, b
0355   060A FD 2E 25 00   mov32 cb, $00000025
0355   060E 00 00 
0356   0610 B0            cmp a, b
0357   0611 FD 71         seq ; ==
0358   0613 E4            pop a
0359   0614             ; --- END RELATIONAL
0360   0614 C0 00 00      cmp b, 0
0361   0617 C6 72 08      je _if5_else
0362   061A             _if5_TRUE:
0363   061A             ; format_p++; 
0364   061A FA FD FF      lea d, [bp + -3] ; $format_p
0365   061D 2A            mov b, [d]
0366   061E 38 00 00      mov c, 0
0367   0621 FD 77         inc b
0368   0623 FA FD FF      lea d, [bp + -3] ; $format_p
0369   0626 FD 43         mov [d], b
0370   0628 FD 7D         dec b
0371   062A             ; switch(*format_p){ 
0372   062A             _switch6_expr:
0373   062A FA FD FF      lea d, [bp + -3] ; $format_p
0374   062D 2A            mov b, [d]
0375   062E 38 00 00      mov c, 0
0376   0631 74            mov d, b
0377   0632 32            mov bl, [d]
0378   0633 A7 00         mov bh, 0
0379   0635 38 00 00      mov c, 0
0380   0638             _switch6_comparisons:
0381   0638 C1 6C         cmp bl, $6c
0382   063A C6 66 06      je _switch6_case0
0383   063D C1 4C         cmp bl, $4c
0384   063F C6 66 06      je _switch6_case1
0385   0642 C1 64         cmp bl, $64
0386   0644 C6 76 07      je _switch6_case2
0387   0647 C1 69         cmp bl, $69
0388   0649 C6 76 07      je _switch6_case3
0389   064C C1 75         cmp bl, $75
0390   064E C6 A6 07      je _switch6_case4
0391   0651 C1 78         cmp bl, $78
0392   0653 C6 D6 07      je _switch6_case5
0393   0656 C1 63         cmp bl, $63
0394   0658 C6 06 08      je _switch6_case6
0395   065B C1 73         cmp bl, $73
0396   065D C6 36 08      je _switch6_case7
0397   0660 0A 63 08      jmp _switch6_default
0398   0663 0A 6F 08      jmp _switch6_exit
0399   0666             _switch6_case0:
0400   0666             _switch6_case1:
0401   0666             ; format_p++; 
0402   0666 FA FD FF      lea d, [bp + -3] ; $format_p
0403   0669 2A            mov b, [d]
0404   066A 38 00 00      mov c, 0
0405   066D FD 77         inc b
0406   066F FA FD FF      lea d, [bp + -3] ; $format_p
0407   0672 FD 43         mov [d], b
0408   0674 FD 7D         dec b
0409   0676             ; if(*format_p == 'd' || *format_p == 'i') 
0410   0676             _if7_cond:
0411   0676 FA FD FF      lea d, [bp + -3] ; $format_p
0412   0679 2A            mov b, [d]
0413   067A 38 00 00      mov c, 0
0414   067D 74            mov d, b
0415   067E 32            mov bl, [d]
0416   067F A7 00         mov bh, 0
0417   0681 38 00 00      mov c, 0
0418   0684             ; --- START RELATIONAL
0419   0684 D7            push a
0420   0685 11            mov a, b
0421   0686 FD 2E 64 00   mov32 cb, $00000064
0421   068A 00 00 
0422   068C B0            cmp a, b
0423   068D FD 71         seq ; ==
0424   068F E4            pop a
0425   0690             ; --- END RELATIONAL
0426   0690             ; --- START LOGICAL OR
0427   0690 D7            push a
0428   0691 11            mov a, b
0429   0692 FA FD FF      lea d, [bp + -3] ; $format_p
0430   0695 2A            mov b, [d]
0431   0696 38 00 00      mov c, 0
0432   0699 74            mov d, b
0433   069A 32            mov bl, [d]
0434   069B A7 00         mov bh, 0
0435   069D 38 00 00      mov c, 0
0436   06A0             ; --- START RELATIONAL
0437   06A0 D7            push a
0438   06A1 11            mov a, b
0439   06A2 FD 2E 69 00   mov32 cb, $00000069
0439   06A6 00 00 
0440   06A8 B0            cmp a, b
0441   06A9 FD 71         seq ; ==
0442   06AB E4            pop a
0443   06AC             ; --- END RELATIONAL
0444   06AC FD A8         sor a, b ; ||
0445   06AE E4            pop a
0446   06AF             ; --- END LOGICAL OR
0447   06AF C0 00 00      cmp b, 0
0448   06B2 C6 D3 06      je _if7_else
0449   06B5             _if7_TRUE:
0450   06B5             ; print_signed_long(*(long *)p); 
0451   06B5             ; --- START FUNCTION CALL
0452   06B5 FA FF FF      lea d, [bp + -1] ; $p
0453   06B8 2A            mov b, [d]
0454   06B9 38 00 00      mov c, 0
0455   06BC 74            mov d, b
0456   06BD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0457   06C0 FD 39         mov c, b ; And place it into C
0458   06C2 2A            mov b, [d] ; Lower Word in B
0459   06C3 12            mov a, c
0460   06C4 FD AA         swp a
0461   06C6 D7            push a
0462   06C7 FD AB         swp b
0463   06C9 D8            push b
0464   06CA 07 9C 08      call print_signed_long
0465   06CD 51 04 00      add sp, 4
0466   06D0             ; --- END FUNCTION CALL
0467   06D0 0A 5B 07      jmp _if7_exit
0468   06D3             _if7_else:
0469   06D3             ; if(*format_p == 'u') 
0470   06D3             _if8_cond:
0471   06D3 FA FD FF      lea d, [bp + -3] ; $format_p
0472   06D6 2A            mov b, [d]
0473   06D7 38 00 00      mov c, 0
0474   06DA 74            mov d, b
0475   06DB 32            mov bl, [d]
0476   06DC A7 00         mov bh, 0
0477   06DE 38 00 00      mov c, 0
0478   06E1             ; --- START RELATIONAL
0479   06E1 D7            push a
0480   06E2 11            mov a, b
0481   06E3 FD 2E 75 00   mov32 cb, $00000075
0481   06E7 00 00 
0482   06E9 B0            cmp a, b
0483   06EA FD 71         seq ; ==
0484   06EC E4            pop a
0485   06ED             ; --- END RELATIONAL
0486   06ED C0 00 00      cmp b, 0
0487   06F0 C6 11 07      je _if8_else
0488   06F3             _if8_TRUE:
0489   06F3             ; print_unsigned_long(*(unsigned long *)p); 
0490   06F3             ; --- START FUNCTION CALL
0491   06F3 FA FF FF      lea d, [bp + -1] ; $p
0492   06F6 2A            mov b, [d]
0493   06F7 38 00 00      mov c, 0
0494   06FA 74            mov d, b
0495   06FB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0496   06FE FD 39         mov c, b ; And place it into C
0497   0700 2A            mov b, [d] ; Lower Word in B
0498   0701 12            mov a, c
0499   0702 FD AA         swp a
0500   0704 D7            push a
0501   0705 FD AB         swp b
0502   0707 D8            push b
0503   0708 07 2F 0A      call print_unsigned_long
0504   070B 51 04 00      add sp, 4
0505   070E             ; --- END FUNCTION CALL
0506   070E 0A 5B 07      jmp _if8_exit
0507   0711             _if8_else:
0508   0711             ; if(*format_p == 'x') 
0509   0711             _if9_cond:
0510   0711 FA FD FF      lea d, [bp + -3] ; $format_p
0511   0714 2A            mov b, [d]
0512   0715 38 00 00      mov c, 0
0513   0718 74            mov d, b
0514   0719 32            mov bl, [d]
0515   071A A7 00         mov bh, 0
0516   071C 38 00 00      mov c, 0
0517   071F             ; --- START RELATIONAL
0518   071F D7            push a
0519   0720 11            mov a, b
0520   0721 FD 2E 78 00   mov32 cb, $00000078
0520   0725 00 00 
0521   0727 B0            cmp a, b
0522   0728 FD 71         seq ; ==
0523   072A E4            pop a
0524   072B             ; --- END RELATIONAL
0525   072B C0 00 00      cmp b, 0
0526   072E C6 4F 07      je _if9_else
0527   0731             _if9_TRUE:
0528   0731             ; printx32(*(long int *)p); 
0529   0731             ; --- START FUNCTION CALL
0530   0731 FA FF FF      lea d, [bp + -1] ; $p
0531   0734 2A            mov b, [d]
0532   0735 38 00 00      mov c, 0
0533   0738 74            mov d, b
0534   0739 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0535   073C FD 39         mov c, b ; And place it into C
0536   073E 2A            mov b, [d] ; Lower Word in B
0537   073F 12            mov a, c
0538   0740 FD AA         swp a
0539   0742 D7            push a
0540   0743 FD AB         swp b
0541   0745 D8            push b
0542   0746 07 63 0B      call printx32
0543   0749 51 04 00      add sp, 4
0544   074C             ; --- END FUNCTION CALL
0545   074C 0A 5B 07      jmp _if9_exit
0546   074F             _if9_else:
0547   074F             ; err("Unexpected format in printf."); 
0548   074F             ; --- START FUNCTION CALL
0549   074F 26 EE 0F      mov b, _s15 ; "Unexpected format in printf."
0550   0752 FD AB         swp b
0551   0754 D8            push b
0552   0755 07 C3 0B      call err
0553   0758 51 02 00      add sp, 2
0554   075B             ; --- END FUNCTION CALL
0555   075B             _if9_exit:
0556   075B             _if8_exit:
0557   075B             _if7_exit:
0558   075B             ; p = p + 4; 
0559   075B FA FF FF      lea d, [bp + -1] ; $p
0560   075E DA            push d
0561   075F FA FF FF      lea d, [bp + -1] ; $p
0562   0762 2A            mov b, [d]
0563   0763 38 00 00      mov c, 0
0564   0766             ; --- START TERMS
0565   0766 D7            push a
0566   0767 11            mov a, b
0567   0768 FD 2E 04 00   mov32 cb, $00000004
0567   076C 00 00 
0568   076E 56            add b, a
0569   076F E4            pop a
0570   0770             ; --- END TERMS
0571   0770 E7            pop d
0572   0771 FD 43         mov [d], b
0573   0773             ; break; 
0574   0773 0A 6F 08      jmp _switch6_exit ; case break
0575   0776             _switch6_case2:
0576   0776             _switch6_case3:
0577   0776             ; print_signed(*(int*)p); 
0578   0776             ; --- START FUNCTION CALL
0579   0776 FA FF FF      lea d, [bp + -1] ; $p
0580   0779 2A            mov b, [d]
0581   077A 38 00 00      mov c, 0
0582   077D 74            mov d, b
0583   077E 2A            mov b, [d]
0584   077F 38 00 00      mov c, 0
0585   0782 FD AB         swp b
0586   0784 D8            push b
0587   0785 07 F1 0B      call print_signed
0588   0788 51 02 00      add sp, 2
0589   078B             ; --- END FUNCTION CALL
0590   078B             ; p = p + 2; 
0591   078B FA FF FF      lea d, [bp + -1] ; $p
0592   078E DA            push d
0593   078F FA FF FF      lea d, [bp + -1] ; $p
0594   0792 2A            mov b, [d]
0595   0793 38 00 00      mov c, 0
0596   0796             ; --- START TERMS
0597   0796 D7            push a
0598   0797 11            mov a, b
0599   0798 FD 2E 02 00   mov32 cb, $00000002
0599   079C 00 00 
0600   079E 56            add b, a
0601   079F E4            pop a
0602   07A0             ; --- END TERMS
0603   07A0 E7            pop d
0604   07A1 FD 43         mov [d], b
0605   07A3             ; break; 
0606   07A3 0A 6F 08      jmp _switch6_exit ; case break
0607   07A6             _switch6_case4:
0608   07A6             ; print_unsigned(*(unsigned int*)p); 
0609   07A6             ; --- START FUNCTION CALL
0610   07A6 FA FF FF      lea d, [bp + -1] ; $p
0611   07A9 2A            mov b, [d]
0612   07AA 38 00 00      mov c, 0
0613   07AD 74            mov d, b
0614   07AE 2A            mov b, [d]
0615   07AF 38 00 00      mov c, 0
0616   07B2 FD AB         swp b
0617   07B4 D8            push b
0618   07B5 07 42 0D      call print_unsigned
0619   07B8 51 02 00      add sp, 2
0620   07BB             ; --- END FUNCTION CALL
0621   07BB             ; p = p + 2; 
0622   07BB FA FF FF      lea d, [bp + -1] ; $p
0623   07BE DA            push d
0624   07BF FA FF FF      lea d, [bp + -1] ; $p
0625   07C2 2A            mov b, [d]
0626   07C3 38 00 00      mov c, 0
0627   07C6             ; --- START TERMS
0628   07C6 D7            push a
0629   07C7 11            mov a, b
0630   07C8 FD 2E 02 00   mov32 cb, $00000002
0630   07CC 00 00 
0631   07CE 56            add b, a
0632   07CF E4            pop a
0633   07D0             ; --- END TERMS
0634   07D0 E7            pop d
0635   07D1 FD 43         mov [d], b
0636   07D3             ; break; 
0637   07D3 0A 6F 08      jmp _switch6_exit ; case break
0638   07D6             _switch6_case5:
0639   07D6             ; printx16(*(int*)p); 
0640   07D6             ; --- START FUNCTION CALL
0641   07D6 FA FF FF      lea d, [bp + -1] ; $p
0642   07D9 2A            mov b, [d]
0643   07DA 38 00 00      mov c, 0
0644   07DD 74            mov d, b
0645   07DE 2A            mov b, [d]
0646   07DF 38 00 00      mov c, 0
0647   07E2 FD AB         swp b
0648   07E4 D8            push b
0649   07E5 07 5A 0E      call printx16
0650   07E8 51 02 00      add sp, 2
0651   07EB             ; --- END FUNCTION CALL
0652   07EB             ; p = p + 2; 
0653   07EB FA FF FF      lea d, [bp + -1] ; $p
0654   07EE DA            push d
0655   07EF FA FF FF      lea d, [bp + -1] ; $p
0656   07F2 2A            mov b, [d]
0657   07F3 38 00 00      mov c, 0
0658   07F6             ; --- START TERMS
0659   07F6 D7            push a
0660   07F7 11            mov a, b
0661   07F8 FD 2E 02 00   mov32 cb, $00000002
0661   07FC 00 00 
0662   07FE 56            add b, a
0663   07FF E4            pop a
0664   0800             ; --- END TERMS
0665   0800 E7            pop d
0666   0801 FD 43         mov [d], b
0667   0803             ; break; 
0668   0803 0A 6F 08      jmp _switch6_exit ; case break
0669   0806             _switch6_case6:
0670   0806             ; putchar(*(char*)p); 
0671   0806             ; --- START FUNCTION CALL
0672   0806 FA FF FF      lea d, [bp + -1] ; $p
0673   0809 2A            mov b, [d]
0674   080A 38 00 00      mov c, 0
0675   080D 74            mov d, b
0676   080E 32            mov bl, [d]
0677   080F A7 00         mov bh, 0
0678   0811 38 00 00      mov c, 0
0679   0814 DD            push bl
0680   0815 07 21 0A      call putchar
0681   0818 51 01 00      add sp, 1
0682   081B             ; --- END FUNCTION CALL
0683   081B             ; p = p + 2; 
0684   081B FA FF FF      lea d, [bp + -1] ; $p
0685   081E DA            push d
0686   081F FA FF FF      lea d, [bp + -1] ; $p
0687   0822 2A            mov b, [d]
0688   0823 38 00 00      mov c, 0
0689   0826             ; --- START TERMS
0690   0826 D7            push a
0691   0827 11            mov a, b
0692   0828 FD 2E 02 00   mov32 cb, $00000002
0692   082C 00 00 
0693   082E 56            add b, a
0694   082F E4            pop a
0695   0830             ; --- END TERMS
0696   0830 E7            pop d
0697   0831 FD 43         mov [d], b
0698   0833             ; break; 
0699   0833 0A 6F 08      jmp _switch6_exit ; case break
0700   0836             _switch6_case7:
0701   0836             ; print(*(char**)p); 
0702   0836             ; --- START FUNCTION CALL
0703   0836 FA FF FF      lea d, [bp + -1] ; $p
0704   0839 2A            mov b, [d]
0705   083A 38 00 00      mov c, 0
0706   083D 74            mov d, b
0707   083E 2A            mov b, [d]
0708   083F FD AB         swp b
0709   0841 D8            push b
0710   0842 07 D8 0B      call print
0711   0845 51 02 00      add sp, 2
0712   0848             ; --- END FUNCTION CALL
0713   0848             ; p = p + 2; 
0714   0848 FA FF FF      lea d, [bp + -1] ; $p
0715   084B DA            push d
0716   084C FA FF FF      lea d, [bp + -1] ; $p
0717   084F 2A            mov b, [d]
0718   0850 38 00 00      mov c, 0
0719   0853             ; --- START TERMS
0720   0853 D7            push a
0721   0854 11            mov a, b
0722   0855 FD 2E 02 00   mov32 cb, $00000002
0722   0859 00 00 
0723   085B 56            add b, a
0724   085C E4            pop a
0725   085D             ; --- END TERMS
0726   085D E7            pop d
0727   085E FD 43         mov [d], b
0728   0860             ; break; 
0729   0860 0A 6F 08      jmp _switch6_exit ; case break
0730   0863             _switch6_default:
0731   0863             ; print("Error: Unknown argument type.\n"); 
0732   0863             ; --- START FUNCTION CALL
0733   0863 26 0B 10      mov b, _s16 ; "Error: Unknown argument type.\n"
0734   0866 FD AB         swp b
0735   0868 D8            push b
0736   0869 07 D8 0B      call print
0737   086C 51 02 00      add sp, 2
0738   086F             ; --- END FUNCTION CALL
0739   086F             _switch6_exit:
0740   086F 0A 87 08      jmp _if5_exit
0741   0872             _if5_else:
0742   0872             ; putchar(*format_p); 
0743   0872             ; --- START FUNCTION CALL
0744   0872 FA FD FF      lea d, [bp + -3] ; $format_p
0745   0875 2A            mov b, [d]
0746   0876 38 00 00      mov c, 0
0747   0879 74            mov d, b
0748   087A 32            mov bl, [d]
0749   087B A7 00         mov bh, 0
0750   087D 38 00 00      mov c, 0
0751   0880 DD            push bl
0752   0881 07 21 0A      call putchar
0753   0884 51 01 00      add sp, 1
0754   0887             ; --- END FUNCTION CALL
0755   0887             _if5_exit:
0756   0887             _if4_exit:
0757   0887             ; format_p++; 
0758   0887 FA FD FF      lea d, [bp + -3] ; $format_p
0759   088A 2A            mov b, [d]
0760   088B 38 00 00      mov c, 0
0761   088E FD 77         inc b
0762   0890 FA FD FF      lea d, [bp + -3] ; $format_p
0763   0893 FD 43         mov [d], b
0764   0895 FD 7D         dec b
0765   0897             _for3_update:
0766   0897 0A DB 05      jmp _for3_cond
0767   089A             _for3_exit:
0768   089A F9            leave
0769   089B 09            ret
0770   089C             
0771   089C             print_signed_long:
0772   089C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0773   089F             ; char digits[10]; 
0774   089F 52 0A 00      sub sp, 10
0775   08A2             ; int i = 0; 
0776   08A2 52 02 00      sub sp, 2
0777   08A5             ; --- START LOCAL VAR INITIALIZATION
0778   08A5 FA F5 FF      lea d, [bp + -11] ; $i
0779   08A8 DA            push d
0780   08A9 FD 2E 00 00   mov32 cb, $00000000
0780   08AD 00 00 
0781   08AF E7            pop d
0782   08B0 FD 43         mov [d], b
0783   08B2             ; --- END LOCAL VAR INITIALIZATION
0784   08B2             ; if (num < 0) { 
0785   08B2             _if10_cond:
0786   08B2 FA 05 00      lea d, [bp + 5] ; $num
0787   08B5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0788   08B8 FD 39         mov c, b ; And place it into C
0789   08BA 2A            mov b, [d] ; Lower Word in B
0790   08BB             ; --- START RELATIONAL
0791   08BB D7            push a
0792   08BC FD D8         push g
0793   08BE 11            mov a, b
0794   08BF FD 7A         mov g, c
0795   08C1 FD 2E 00 00   mov32 cb, $00000000
0795   08C5 00 00 
0796   08C7 FD AF         cmp32 ga, cb
0797   08C9 FD 73         slt ; <
0798   08CB FD F1         pop g
0799   08CD E4            pop a
0800   08CE             ; --- END RELATIONAL
0801   08CE C0 00 00      cmp b, 0
0802   08D1 C6 03 09      je _if10_else
0803   08D4             _if10_TRUE:
0804   08D4             ; putchar('-'); 
0805   08D4             ; --- START FUNCTION CALL
0806   08D4 FD 2E 2D 00   mov32 cb, $0000002d
0806   08D8 00 00 
0807   08DA DD            push bl
0808   08DB 07 21 0A      call putchar
0809   08DE 51 01 00      add sp, 1
0810   08E1             ; --- END FUNCTION CALL
0811   08E1             ; num = -num; 
0812   08E1 FA 05 00      lea d, [bp + 5] ; $num
0813   08E4 DA            push d
0814   08E5 FA 05 00      lea d, [bp + 5] ; $num
0815   08E8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0816   08EB FD 39         mov c, b ; And place it into C
0817   08ED 2A            mov b, [d] ; Lower Word in B
0818   08EE 12            mov a, c
0819   08EF 95            not a
0820   08F0 97            not b
0821   08F1 55 01 00      add b, 1
0822   08F4 5B 00 00      adc a, 0
0823   08F7 39            mov c, a
0824   08F8 E7            pop d
0825   08F9 FD 43         mov [d], b
0826   08FB 28            mov b, c
0827   08FC FD 44 02 00   mov [d + 2], b
0828   0900 0A 37 09      jmp _if10_exit
0829   0903             _if10_else:
0830   0903             ; if (num == 0) { 
0831   0903             _if11_cond:
0832   0903 FA 05 00      lea d, [bp + 5] ; $num
0833   0906 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0834   0909 FD 39         mov c, b ; And place it into C
0835   090B 2A            mov b, [d] ; Lower Word in B
0836   090C             ; --- START RELATIONAL
0837   090C D7            push a
0838   090D FD D8         push g
0839   090F 11            mov a, b
0840   0910 FD 7A         mov g, c
0841   0912 FD 2E 00 00   mov32 cb, $00000000
0841   0916 00 00 
0842   0918 FD AF         cmp32 ga, cb
0843   091A FD 71         seq ; ==
0844   091C FD F1         pop g
0845   091E E4            pop a
0846   091F             ; --- END RELATIONAL
0847   091F C0 00 00      cmp b, 0
0848   0922 C6 37 09      je _if11_exit
0849   0925             _if11_TRUE:
0850   0925             ; putchar('0'); 
0851   0925             ; --- START FUNCTION CALL
0852   0925 FD 2E 30 00   mov32 cb, $00000030
0852   0929 00 00 
0853   092B DD            push bl
0854   092C 07 21 0A      call putchar
0855   092F 51 01 00      add sp, 1
0856   0932             ; --- END FUNCTION CALL
0857   0932             ; return; 
0858   0932 F9            leave
0859   0933 09            ret
0860   0934 0A 37 09      jmp _if11_exit
0861   0937             _if11_exit:
0862   0937             _if10_exit:
0863   0937             ; while (num > 0) { 
0864   0937             _while12_cond:
0865   0937 FA 05 00      lea d, [bp + 5] ; $num
0866   093A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0867   093D FD 39         mov c, b ; And place it into C
0868   093F 2A            mov b, [d] ; Lower Word in B
0869   0940             ; --- START RELATIONAL
0870   0940 D7            push a
0871   0941 FD D8         push g
0872   0943 11            mov a, b
0873   0944 FD 7A         mov g, c
0874   0946 FD 2E 00 00   mov32 cb, $00000000
0874   094A 00 00 
0875   094C FD AF         cmp32 ga, cb
0876   094E FD 7F         sgt
0877   0950 FD F1         pop g
0878   0952 E4            pop a
0879   0953             ; --- END RELATIONAL
0880   0953 C0 00 00      cmp b, 0
0881   0956 C6 D7 09      je _while12_exit
0882   0959             _while12_block:
0883   0959             ; digits[i] = '0' + (num % 10); 
0884   0959 FA F7 FF      lea d, [bp + -9] ; $digits
0885   095C D7            push a
0886   095D DA            push d
0887   095E FA F5 FF      lea d, [bp + -11] ; $i
0888   0961 2A            mov b, [d]
0889   0962 38 00 00      mov c, 0
0890   0965 E7            pop d
0891   0966 5A            add d, b
0892   0967 E4            pop a
0893   0968 DA            push d
0894   0969 FD 2E 30 00   mov32 cb, $00000030
0894   096D 00 00 
0895   096F             ; --- START TERMS
0896   096F D7            push a
0897   0970 11            mov a, b
0898   0971 FA 05 00      lea d, [bp + 5] ; $num
0899   0974 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0900   0977 FD 39         mov c, b ; And place it into C
0901   0979 2A            mov b, [d] ; Lower Word in B
0902   097A             ; --- START FACTORS
0903   097A D7            push a
0904   097B FD D8         push g
0905   097D 11            mov a, b
0906   097E FD 7A         mov g, c
0907   0980 FD 2E 0A 00   mov32 cb, $0000000a
0907   0984 00 00 
0908   0986 FD D8         push g ; save 'g' as the div instruction uses it
0909   0988 AE            div a, b ; %, a: quotient, b: remainder
0910   0989 11            mov a, b
0911   098A FD F1         pop g
0912   098C FD 38         mov c, g
0913   098E 27            mov b, a
0914   098F FD F1         pop g
0915   0991 E4            pop a
0916   0992             ; --- END FACTORS
0917   0992 FD 15         add32 cb, ga
0918   0994 E4            pop a
0919   0995             ; --- END TERMS
0920   0995 E7            pop d
0921   0996 FD 3E         mov [d], bl
0922   0998             ; num = num / 10; 
0923   0998 FA 05 00      lea d, [bp + 5] ; $num
0924   099B DA            push d
0925   099C FA 05 00      lea d, [bp + 5] ; $num
0926   099F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0927   09A2 FD 39         mov c, b ; And place it into C
0928   09A4 2A            mov b, [d] ; Lower Word in B
0929   09A5             ; --- START FACTORS
0930   09A5 D7            push a
0931   09A6 FD D8         push g
0932   09A8 11            mov a, b
0933   09A9 FD 7A         mov g, c
0934   09AB FD 2E 0A 00   mov32 cb, $0000000a
0934   09AF 00 00 
0935   09B1 FD D8         push g ; save 'g' as the div instruction uses it
0936   09B3 AE            div a, b ; /, a: quotient, b: remainder
0937   09B4 FD F1         pop g
0938   09B6 FD 38         mov c, g
0939   09B8 27            mov b, a
0940   09B9 FD F1         pop g
0941   09BB E4            pop a
0942   09BC             ; --- END FACTORS
0943   09BC E7            pop d
0944   09BD FD 43         mov [d], b
0945   09BF 28            mov b, c
0946   09C0 FD 44 02 00   mov [d + 2], b
0947   09C4             ; i++; 
0948   09C4 FA F5 FF      lea d, [bp + -11] ; $i
0949   09C7 2A            mov b, [d]
0950   09C8 38 00 00      mov c, 0
0951   09CB 11            mov a, b
0952   09CC FD 77         inc b
0953   09CE FA F5 FF      lea d, [bp + -11] ; $i
0954   09D1 FD 43         mov [d], b
0955   09D3 27            mov b, a
0956   09D4 0A 37 09      jmp _while12_cond
0957   09D7             _while12_exit:
0958   09D7             ; while (i > 0) { 
0959   09D7             _while19_cond:
0960   09D7 FA F5 FF      lea d, [bp + -11] ; $i
0961   09DA 2A            mov b, [d]
0962   09DB 38 00 00      mov c, 0
0963   09DE             ; --- START RELATIONAL
0964   09DE D7            push a
0965   09DF 11            mov a, b
0966   09E0 FD 2E 00 00   mov32 cb, $00000000
0966   09E4 00 00 
0967   09E6 B0            cmp a, b
0968   09E7 FD 7F         sgt ; >
0969   09E9 E4            pop a
0970   09EA             ; --- END RELATIONAL
0971   09EA C0 00 00      cmp b, 0
0972   09ED C6 1F 0A      je _while19_exit
0973   09F0             _while19_block:
0974   09F0             ; i--; 
0975   09F0 FA F5 FF      lea d, [bp + -11] ; $i
0976   09F3 2A            mov b, [d]
0977   09F4 38 00 00      mov c, 0
0978   09F7 11            mov a, b
0979   09F8 FD 7D         dec b
0980   09FA FA F5 FF      lea d, [bp + -11] ; $i
0981   09FD FD 43         mov [d], b
0982   09FF 27            mov b, a
0983   0A00             ; putchar(digits[i]); 
0984   0A00             ; --- START FUNCTION CALL
0985   0A00 FA F7 FF      lea d, [bp + -9] ; $digits
0986   0A03 D7            push a
0987   0A04 DA            push d
0988   0A05 FA F5 FF      lea d, [bp + -11] ; $i
0989   0A08 2A            mov b, [d]
0990   0A09 38 00 00      mov c, 0
0991   0A0C E7            pop d
0992   0A0D 5A            add d, b
0993   0A0E E4            pop a
0994   0A0F 32            mov bl, [d]
0995   0A10 A7 00         mov bh, 0
0996   0A12 38 00 00      mov c, 0
0997   0A15 DD            push bl
0998   0A16 07 21 0A      call putchar
0999   0A19 51 01 00      add sp, 1
1000   0A1C             ; --- END FUNCTION CALL
1001   0A1C 0A D7 09      jmp _while19_cond
1002   0A1F             _while19_exit:
1003   0A1F F9            leave
1004   0A20 09            ret
1005   0A21             
1006   0A21             putchar:
1007   0A21 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1008   0A24             ; --- BEGIN INLINE ASM SEGMENT
1009   0A24 FA 05 00      lea d, [bp + 5] ; $c
1010   0A27 1E            mov al, [d]
1011   0A28 23            mov ah, al
1012   0A29 19 00         mov al, 0
1013   0A2B 05 03         syscall sys_io      ; char in AH
1014   0A2D             ; --- END INLINE ASM SEGMENT
1015   0A2D F9            leave
1016   0A2E 09            ret
1017   0A2F             
1018   0A2F             print_unsigned_long:
1019   0A2F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1020   0A32             ; char digits[10]; 
1021   0A32 52 0A 00      sub sp, 10
1022   0A35             ; int i; 
1023   0A35 52 02 00      sub sp, 2
1024   0A38             ; i = 0; 
1025   0A38 FA F5 FF      lea d, [bp + -11] ; $i
1026   0A3B DA            push d
1027   0A3C FD 2E 00 00   mov32 cb, $00000000
1027   0A40 00 00 
1028   0A42 E7            pop d
1029   0A43 FD 43         mov [d], b
1030   0A45             ; if(num == 0){ 
1031   0A45             _if20_cond:
1032   0A45 FA 05 00      lea d, [bp + 5] ; $num
1033   0A48 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1034   0A4B FD 39         mov c, b ; And place it into C
1035   0A4D 2A            mov b, [d] ; Lower Word in B
1036   0A4E             ; --- START RELATIONAL
1037   0A4E D7            push a
1038   0A4F FD D8         push g
1039   0A51 11            mov a, b
1040   0A52 FD 7A         mov g, c
1041   0A54 FD 2E 00 00   mov32 cb, $00000000
1041   0A58 00 00 
1042   0A5A FD AF         cmp32 ga, cb
1043   0A5C FD 71         seq ; ==
1044   0A5E FD F1         pop g
1045   0A60 E4            pop a
1046   0A61             ; --- END RELATIONAL
1047   0A61 C0 00 00      cmp b, 0
1048   0A64 C6 79 0A      je _if20_exit
1049   0A67             _if20_TRUE:
1050   0A67             ; putchar('0'); 
1051   0A67             ; --- START FUNCTION CALL
1052   0A67 FD 2E 30 00   mov32 cb, $00000030
1052   0A6B 00 00 
1053   0A6D DD            push bl
1054   0A6E 07 21 0A      call putchar
1055   0A71 51 01 00      add sp, 1
1056   0A74             ; --- END FUNCTION CALL
1057   0A74             ; return; 
1058   0A74 F9            leave
1059   0A75 09            ret
1060   0A76 0A 79 0A      jmp _if20_exit
1061   0A79             _if20_exit:
1062   0A79             ; while (num > 0) { 
1063   0A79             _while21_cond:
1064   0A79 FA 05 00      lea d, [bp + 5] ; $num
1065   0A7C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1066   0A7F FD 39         mov c, b ; And place it into C
1067   0A81 2A            mov b, [d] ; Lower Word in B
1068   0A82             ; --- START RELATIONAL
1069   0A82 D7            push a
1070   0A83 FD D8         push g
1071   0A85 11            mov a, b
1072   0A86 FD 7A         mov g, c
1073   0A88 FD 2E 00 00   mov32 cb, $00000000
1073   0A8C 00 00 
1074   0A8E FD AF         cmp32 ga, cb
1075   0A90 FD 81         sgu
1076   0A92 FD F1         pop g
1077   0A94 E4            pop a
1078   0A95             ; --- END RELATIONAL
1079   0A95 C0 00 00      cmp b, 0
1080   0A98 C6 19 0B      je _while21_exit
1081   0A9B             _while21_block:
1082   0A9B             ; digits[i] = '0' + (num % 10); 
1083   0A9B FA F7 FF      lea d, [bp + -9] ; $digits
1084   0A9E D7            push a
1085   0A9F DA            push d
1086   0AA0 FA F5 FF      lea d, [bp + -11] ; $i
1087   0AA3 2A            mov b, [d]
1088   0AA4 38 00 00      mov c, 0
1089   0AA7 E7            pop d
1090   0AA8 5A            add d, b
1091   0AA9 E4            pop a
1092   0AAA DA            push d
1093   0AAB FD 2E 30 00   mov32 cb, $00000030
1093   0AAF 00 00 
1094   0AB1             ; --- START TERMS
1095   0AB1 D7            push a
1096   0AB2 11            mov a, b
1097   0AB3 FA 05 00      lea d, [bp + 5] ; $num
1098   0AB6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1099   0AB9 FD 39         mov c, b ; And place it into C
1100   0ABB 2A            mov b, [d] ; Lower Word in B
1101   0ABC             ; --- START FACTORS
1102   0ABC D7            push a
1103   0ABD FD D8         push g
1104   0ABF 11            mov a, b
1105   0AC0 FD 7A         mov g, c
1106   0AC2 FD 2E 0A 00   mov32 cb, $0000000a
1106   0AC6 00 00 
1107   0AC8 FD D8         push g ; save 'g' as the div instruction uses it
1108   0ACA AE            div a, b ; %, a: quotient, b: remainder
1109   0ACB 11            mov a, b
1110   0ACC FD F1         pop g
1111   0ACE FD 38         mov c, g
1112   0AD0 27            mov b, a
1113   0AD1 FD F1         pop g
1114   0AD3 E4            pop a
1115   0AD4             ; --- END FACTORS
1116   0AD4 FD 15         add32 cb, ga
1117   0AD6 E4            pop a
1118   0AD7             ; --- END TERMS
1119   0AD7 E7            pop d
1120   0AD8 FD 3E         mov [d], bl
1121   0ADA             ; num = num / 10; 
1122   0ADA FA 05 00      lea d, [bp + 5] ; $num
1123   0ADD DA            push d
1124   0ADE FA 05 00      lea d, [bp + 5] ; $num
1125   0AE1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1126   0AE4 FD 39         mov c, b ; And place it into C
1127   0AE6 2A            mov b, [d] ; Lower Word in B
1128   0AE7             ; --- START FACTORS
1129   0AE7 D7            push a
1130   0AE8 FD D8         push g
1131   0AEA 11            mov a, b
1132   0AEB FD 7A         mov g, c
1133   0AED FD 2E 0A 00   mov32 cb, $0000000a
1133   0AF1 00 00 
1134   0AF3 FD D8         push g ; save 'g' as the div instruction uses it
1135   0AF5 AE            div a, b ; /, a: quotient, b: remainder
1136   0AF6 FD F1         pop g
1137   0AF8 FD 38         mov c, g
1138   0AFA 27            mov b, a
1139   0AFB FD F1         pop g
1140   0AFD E4            pop a
1141   0AFE             ; --- END FACTORS
1142   0AFE E7            pop d
1143   0AFF FD 43         mov [d], b
1144   0B01 28            mov b, c
1145   0B02 FD 44 02 00   mov [d + 2], b
1146   0B06             ; i++; 
1147   0B06 FA F5 FF      lea d, [bp + -11] ; $i
1148   0B09 2A            mov b, [d]
1149   0B0A 38 00 00      mov c, 0
1150   0B0D 11            mov a, b
1151   0B0E FD 77         inc b
1152   0B10 FA F5 FF      lea d, [bp + -11] ; $i
1153   0B13 FD 43         mov [d], b
1154   0B15 27            mov b, a
1155   0B16 0A 79 0A      jmp _while21_cond
1156   0B19             _while21_exit:
1157   0B19             ; while (i > 0) { 
1158   0B19             _while28_cond:
1159   0B19 FA F5 FF      lea d, [bp + -11] ; $i
1160   0B1C 2A            mov b, [d]
1161   0B1D 38 00 00      mov c, 0
1162   0B20             ; --- START RELATIONAL
1163   0B20 D7            push a
1164   0B21 11            mov a, b
1165   0B22 FD 2E 00 00   mov32 cb, $00000000
1165   0B26 00 00 
1166   0B28 B0            cmp a, b
1167   0B29 FD 7F         sgt ; >
1168   0B2B E4            pop a
1169   0B2C             ; --- END RELATIONAL
1170   0B2C C0 00 00      cmp b, 0
1171   0B2F C6 61 0B      je _while28_exit
1172   0B32             _while28_block:
1173   0B32             ; i--; 
1174   0B32 FA F5 FF      lea d, [bp + -11] ; $i
1175   0B35 2A            mov b, [d]
1176   0B36 38 00 00      mov c, 0
1177   0B39 11            mov a, b
1178   0B3A FD 7D         dec b
1179   0B3C FA F5 FF      lea d, [bp + -11] ; $i
1180   0B3F FD 43         mov [d], b
1181   0B41 27            mov b, a
1182   0B42             ; putchar(digits[i]); 
1183   0B42             ; --- START FUNCTION CALL
1184   0B42 FA F7 FF      lea d, [bp + -9] ; $digits
1185   0B45 D7            push a
1186   0B46 DA            push d
1187   0B47 FA F5 FF      lea d, [bp + -11] ; $i
1188   0B4A 2A            mov b, [d]
1189   0B4B 38 00 00      mov c, 0
1190   0B4E E7            pop d
1191   0B4F 5A            add d, b
1192   0B50 E4            pop a
1193   0B51 32            mov bl, [d]
1194   0B52 A7 00         mov bh, 0
1195   0B54 38 00 00      mov c, 0
1196   0B57 DD            push bl
1197   0B58 07 21 0A      call putchar
1198   0B5B 51 01 00      add sp, 1
1199   0B5E             ; --- END FUNCTION CALL
1200   0B5E 0A 19 0B      jmp _while28_cond
1201   0B61             _while28_exit:
1202   0B61 F9            leave
1203   0B62 09            ret
1204   0B63             
1205   0B63             printx32:
1206   0B63 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1207   0B66             ; --- BEGIN INLINE ASM SEGMENT
1208   0B66 FA 05 00      lea d, [bp + 5] ; $hex
1209   0B69 2B 02 00      mov b, [d+2]
1210   0B6C 07 75 0B      call print_u16x_printx32
1211   0B6F 2A            mov b, [d]
1212   0B70 07 75 0B      call print_u16x_printx32
1213   0B73             ; --- END INLINE ASM SEGMENT
1214   0B73             ; return; 
1215   0B73 F9            leave
1216   0B74 09            ret
1217   0B75             ; --- BEGIN INLINE ASM SEGMENT
1218   0B75             print_u16x_printx32:
1219   0B75 D7            push a
1220   0B76 D8            push b
1221   0B77 DD            push bl
1222   0B78 30            mov bl, bh
1223   0B79 07 97 0B      call _itoa_printx32        ; convert bh to char in A
1224   0B7C 2F            mov bl, al        ; save al
1225   0B7D 19 00         mov al, 0
1226   0B7F 05 03         syscall sys_io        ; display AH
1227   0B81 24            mov ah, bl        ; retrieve al
1228   0B82 19 00         mov al, 0
1229   0B84 05 03         syscall sys_io        ; display AL
1230   0B86 EA            pop bl
1231   0B87 07 97 0B      call _itoa_printx32        ; convert bh to char in A
1232   0B8A 2F            mov bl, al        ; save al
1233   0B8B 19 00         mov al, 0
1234   0B8D 05 03         syscall sys_io        ; display AH
1235   0B8F 24            mov ah, bl        ; retrieve al
1236   0B90 19 00         mov al, 0
1237   0B92 05 03         syscall sys_io        ; display AL
1238   0B94 E5            pop b
1239   0B95 E4            pop a
1240   0B96 09            ret
1241   0B97             _itoa_printx32:
1242   0B97 DA            push d
1243   0B98 D8            push b
1244   0B99 A7 00         mov bh, 0
1245   0B9B FD A4 04      shr bl, 4  
1246   0B9E 74            mov d, b
1247   0B9F 1F B1 0B      mov al, [d + s_hex_digits_printx32]
1248   0BA2 23            mov ah, al
1249   0BA3 E5            pop b
1250   0BA4 D8            push b
1251   0BA5 A7 00         mov bh, 0
1252   0BA7 FD 87 0F      and bl, $0F
1253   0BAA 74            mov d, b
1254   0BAB 1F B1 0B      mov al, [d + s_hex_digits_printx32]
1255   0BAE E5            pop b
1256   0BAF E7            pop d
1257   0BB0 09            ret
1258   0BB1 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1258   0BB5 34 35 36 37 
1258   0BB9 38 39 41 42 
1258   0BBD 43 44 45 46 
1259   0BC1             ; --- END INLINE ASM SEGMENT
1260   0BC1 F9            leave
1261   0BC2 09            ret
1262   0BC3             
1263   0BC3             err:
1264   0BC3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1265   0BC6             ; print(e); 
1266   0BC6             ; --- START FUNCTION CALL
1267   0BC6 FA 05 00      lea d, [bp + 5] ; $e
1268   0BC9 2A            mov b, [d]
1269   0BCA 38 00 00      mov c, 0
1270   0BCD FD AB         swp b
1271   0BCF D8            push b
1272   0BD0 07 D8 0B      call print
1273   0BD3 51 02 00      add sp, 2
1274   0BD6             ; --- END FUNCTION CALL
1275   0BD6 F9            leave
1276   0BD7 09            ret
1277   0BD8             
1278   0BD8             print:
1279   0BD8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1280   0BDB             ; --- BEGIN INLINE ASM SEGMENT
1281   0BDB FA 05 00      lea d, [bp + 5] ; $s
1282   0BDE FD 2A         mov d, [d]
1283   0BE0             _puts_L1_print:
1284   0BE0 1E            mov al, [d]
1285   0BE1 B9 00         cmp al, 0
1286   0BE3 C6 EF 0B      jz _puts_END_print
1287   0BE6 23            mov ah, al
1288   0BE7 19 00         mov al, 0
1289   0BE9 05 03         syscall sys_io
1290   0BEB 79            inc d
1291   0BEC 0A E0 0B      jmp _puts_L1_print
1292   0BEF             _puts_END_print:
1293   0BEF             ; --- END INLINE ASM SEGMENT
1294   0BEF F9            leave
1295   0BF0 09            ret
1296   0BF1             
1297   0BF1             print_signed:
1298   0BF1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1299   0BF4             ; char digits[5]; 
1300   0BF4 52 05 00      sub sp, 5
1301   0BF7             ; int i = 0; 
1302   0BF7 52 02 00      sub sp, 2
1303   0BFA             ; --- START LOCAL VAR INITIALIZATION
1304   0BFA FA FA FF      lea d, [bp + -6] ; $i
1305   0BFD DA            push d
1306   0BFE FD 2E 00 00   mov32 cb, $00000000
1306   0C02 00 00 
1307   0C04 E7            pop d
1308   0C05 FD 43         mov [d], b
1309   0C07             ; --- END LOCAL VAR INITIALIZATION
1310   0C07             ; if (num < 0) { 
1311   0C07             _if29_cond:
1312   0C07 FA 05 00      lea d, [bp + 5] ; $num
1313   0C0A 2A            mov b, [d]
1314   0C0B 38 00 00      mov c, 0
1315   0C0E             ; --- START RELATIONAL
1316   0C0E D7            push a
1317   0C0F 11            mov a, b
1318   0C10 FD 2E 00 00   mov32 cb, $00000000
1318   0C14 00 00 
1319   0C16 B0            cmp a, b
1320   0C17 FD 73         slt ; < (signed)
1321   0C19 E4            pop a
1322   0C1A             ; --- END RELATIONAL
1323   0C1A C0 00 00      cmp b, 0
1324   0C1D C6 40 0C      je _if29_else
1325   0C20             _if29_TRUE:
1326   0C20             ; putchar('-'); 
1327   0C20             ; --- START FUNCTION CALL
1328   0C20 FD 2E 2D 00   mov32 cb, $0000002d
1328   0C24 00 00 
1329   0C26 DD            push bl
1330   0C27 07 21 0A      call putchar
1331   0C2A 51 01 00      add sp, 1
1332   0C2D             ; --- END FUNCTION CALL
1333   0C2D             ; num = -num; 
1334   0C2D FA 05 00      lea d, [bp + 5] ; $num
1335   0C30 DA            push d
1336   0C31 FA 05 00      lea d, [bp + 5] ; $num
1337   0C34 2A            mov b, [d]
1338   0C35 38 00 00      mov c, 0
1339   0C38 FD 97         neg b
1340   0C3A E7            pop d
1341   0C3B FD 43         mov [d], b
1342   0C3D 0A 6B 0C      jmp _if29_exit
1343   0C40             _if29_else:
1344   0C40             ; if (num == 0) { 
1345   0C40             _if30_cond:
1346   0C40 FA 05 00      lea d, [bp + 5] ; $num
1347   0C43 2A            mov b, [d]
1348   0C44 38 00 00      mov c, 0
1349   0C47             ; --- START RELATIONAL
1350   0C47 D7            push a
1351   0C48 11            mov a, b
1352   0C49 FD 2E 00 00   mov32 cb, $00000000
1352   0C4D 00 00 
1353   0C4F B0            cmp a, b
1354   0C50 FD 71         seq ; ==
1355   0C52 E4            pop a
1356   0C53             ; --- END RELATIONAL
1357   0C53 C0 00 00      cmp b, 0
1358   0C56 C6 6B 0C      je _if30_exit
1359   0C59             _if30_TRUE:
1360   0C59             ; putchar('0'); 
1361   0C59             ; --- START FUNCTION CALL
1362   0C59 FD 2E 30 00   mov32 cb, $00000030
1362   0C5D 00 00 
1363   0C5F DD            push bl
1364   0C60 07 21 0A      call putchar
1365   0C63 51 01 00      add sp, 1
1366   0C66             ; --- END FUNCTION CALL
1367   0C66             ; return; 
1368   0C66 F9            leave
1369   0C67 09            ret
1370   0C68 0A 6B 0C      jmp _if30_exit
1371   0C6B             _if30_exit:
1372   0C6B             _if29_exit:
1373   0C6B             ; while (num > 0) { 
1374   0C6B             _while31_cond:
1375   0C6B FA 05 00      lea d, [bp + 5] ; $num
1376   0C6E 2A            mov b, [d]
1377   0C6F 38 00 00      mov c, 0
1378   0C72             ; --- START RELATIONAL
1379   0C72 D7            push a
1380   0C73 11            mov a, b
1381   0C74 FD 2E 00 00   mov32 cb, $00000000
1381   0C78 00 00 
1382   0C7A B0            cmp a, b
1383   0C7B FD 7F         sgt ; >
1384   0C7D E4            pop a
1385   0C7E             ; --- END RELATIONAL
1386   0C7E C0 00 00      cmp b, 0
1387   0C81 C6 F8 0C      je _while31_exit
1388   0C84             _while31_block:
1389   0C84             ; digits[i] = '0' + (num % 10); 
1390   0C84 FA FC FF      lea d, [bp + -4] ; $digits
1391   0C87 D7            push a
1392   0C88 DA            push d
1393   0C89 FA FA FF      lea d, [bp + -6] ; $i
1394   0C8C 2A            mov b, [d]
1395   0C8D 38 00 00      mov c, 0
1396   0C90 E7            pop d
1397   0C91 5A            add d, b
1398   0C92 E4            pop a
1399   0C93 DA            push d
1400   0C94 FD 2E 30 00   mov32 cb, $00000030
1400   0C98 00 00 
1401   0C9A             ; --- START TERMS
1402   0C9A D7            push a
1403   0C9B 11            mov a, b
1404   0C9C FA 05 00      lea d, [bp + 5] ; $num
1405   0C9F 2A            mov b, [d]
1406   0CA0 38 00 00      mov c, 0
1407   0CA3             ; --- START FACTORS
1408   0CA3 D7            push a
1409   0CA4 FD D8         push g
1410   0CA6 11            mov a, b
1411   0CA7 FD 7A         mov g, c
1412   0CA9 FD 2E 0A 00   mov32 cb, $0000000a
1412   0CAD 00 00 
1413   0CAF FD D8         push g ; save 'g' as the div instruction uses it
1414   0CB1 AE            div a, b ; %, a: quotient, b: remainder
1415   0CB2 11            mov a, b
1416   0CB3 FD F1         pop g
1417   0CB5 FD 38         mov c, g
1418   0CB7 27            mov b, a
1419   0CB8 FD F1         pop g
1420   0CBA E4            pop a
1421   0CBB             ; --- END FACTORS
1422   0CBB 56            add b, a
1423   0CBC E4            pop a
1424   0CBD             ; --- END TERMS
1425   0CBD E7            pop d
1426   0CBE FD 3E         mov [d], bl
1427   0CC0             ; num = num / 10; 
1428   0CC0 FA 05 00      lea d, [bp + 5] ; $num
1429   0CC3 DA            push d
1430   0CC4 FA 05 00      lea d, [bp + 5] ; $num
1431   0CC7 2A            mov b, [d]
1432   0CC8 38 00 00      mov c, 0
1433   0CCB             ; --- START FACTORS
1434   0CCB D7            push a
1435   0CCC FD D8         push g
1436   0CCE 11            mov a, b
1437   0CCF FD 7A         mov g, c
1438   0CD1 FD 2E 0A 00   mov32 cb, $0000000a
1438   0CD5 00 00 
1439   0CD7 FD D8         push g ; save 'g' as the div instruction uses it
1440   0CD9 AE            div a, b ; /, a: quotient, b: remainder
1441   0CDA FD F1         pop g
1442   0CDC FD 38         mov c, g
1443   0CDE 27            mov b, a
1444   0CDF FD F1         pop g
1445   0CE1 E4            pop a
1446   0CE2             ; --- END FACTORS
1447   0CE2 E7            pop d
1448   0CE3 FD 43         mov [d], b
1449   0CE5             ; i++; 
1450   0CE5 FA FA FF      lea d, [bp + -6] ; $i
1451   0CE8 2A            mov b, [d]
1452   0CE9 38 00 00      mov c, 0
1453   0CEC 11            mov a, b
1454   0CED FD 77         inc b
1455   0CEF FA FA FF      lea d, [bp + -6] ; $i
1456   0CF2 FD 43         mov [d], b
1457   0CF4 27            mov b, a
1458   0CF5 0A 6B 0C      jmp _while31_cond
1459   0CF8             _while31_exit:
1460   0CF8             ; while (i > 0) { 
1461   0CF8             _while38_cond:
1462   0CF8 FA FA FF      lea d, [bp + -6] ; $i
1463   0CFB 2A            mov b, [d]
1464   0CFC 38 00 00      mov c, 0
1465   0CFF             ; --- START RELATIONAL
1466   0CFF D7            push a
1467   0D00 11            mov a, b
1468   0D01 FD 2E 00 00   mov32 cb, $00000000
1468   0D05 00 00 
1469   0D07 B0            cmp a, b
1470   0D08 FD 7F         sgt ; >
1471   0D0A E4            pop a
1472   0D0B             ; --- END RELATIONAL
1473   0D0B C0 00 00      cmp b, 0
1474   0D0E C6 40 0D      je _while38_exit
1475   0D11             _while38_block:
1476   0D11             ; i--; 
1477   0D11 FA FA FF      lea d, [bp + -6] ; $i
1478   0D14 2A            mov b, [d]
1479   0D15 38 00 00      mov c, 0
1480   0D18 11            mov a, b
1481   0D19 FD 7D         dec b
1482   0D1B FA FA FF      lea d, [bp + -6] ; $i
1483   0D1E FD 43         mov [d], b
1484   0D20 27            mov b, a
1485   0D21             ; putchar(digits[i]); 
1486   0D21             ; --- START FUNCTION CALL
1487   0D21 FA FC FF      lea d, [bp + -4] ; $digits
1488   0D24 D7            push a
1489   0D25 DA            push d
1490   0D26 FA FA FF      lea d, [bp + -6] ; $i
1491   0D29 2A            mov b, [d]
1492   0D2A 38 00 00      mov c, 0
1493   0D2D E7            pop d
1494   0D2E 5A            add d, b
1495   0D2F E4            pop a
1496   0D30 32            mov bl, [d]
1497   0D31 A7 00         mov bh, 0
1498   0D33 38 00 00      mov c, 0
1499   0D36 DD            push bl
1500   0D37 07 21 0A      call putchar
1501   0D3A 51 01 00      add sp, 1
1502   0D3D             ; --- END FUNCTION CALL
1503   0D3D 0A F8 0C      jmp _while38_cond
1504   0D40             _while38_exit:
1505   0D40 F9            leave
1506   0D41 09            ret
1507   0D42             
1508   0D42             print_unsigned:
1509   0D42 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1510   0D45             ; char digits[5]; 
1511   0D45 52 05 00      sub sp, 5
1512   0D48             ; int i; 
1513   0D48 52 02 00      sub sp, 2
1514   0D4B             ; i = 0; 
1515   0D4B FA FA FF      lea d, [bp + -6] ; $i
1516   0D4E DA            push d
1517   0D4F FD 2E 00 00   mov32 cb, $00000000
1517   0D53 00 00 
1518   0D55 E7            pop d
1519   0D56 FD 43         mov [d], b
1520   0D58             ; if(num == 0){ 
1521   0D58             _if39_cond:
1522   0D58 FA 05 00      lea d, [bp + 5] ; $num
1523   0D5B 2A            mov b, [d]
1524   0D5C 38 00 00      mov c, 0
1525   0D5F             ; --- START RELATIONAL
1526   0D5F D7            push a
1527   0D60 11            mov a, b
1528   0D61 FD 2E 00 00   mov32 cb, $00000000
1528   0D65 00 00 
1529   0D67 B0            cmp a, b
1530   0D68 FD 71         seq ; ==
1531   0D6A E4            pop a
1532   0D6B             ; --- END RELATIONAL
1533   0D6B C0 00 00      cmp b, 0
1534   0D6E C6 83 0D      je _if39_exit
1535   0D71             _if39_TRUE:
1536   0D71             ; putchar('0'); 
1537   0D71             ; --- START FUNCTION CALL
1538   0D71 FD 2E 30 00   mov32 cb, $00000030
1538   0D75 00 00 
1539   0D77 DD            push bl
1540   0D78 07 21 0A      call putchar
1541   0D7B 51 01 00      add sp, 1
1542   0D7E             ; --- END FUNCTION CALL
1543   0D7E             ; return; 
1544   0D7E F9            leave
1545   0D7F 09            ret
1546   0D80 0A 83 0D      jmp _if39_exit
1547   0D83             _if39_exit:
1548   0D83             ; while (num > 0) { 
1549   0D83             _while40_cond:
1550   0D83 FA 05 00      lea d, [bp + 5] ; $num
1551   0D86 2A            mov b, [d]
1552   0D87 38 00 00      mov c, 0
1553   0D8A             ; --- START RELATIONAL
1554   0D8A D7            push a
1555   0D8B 11            mov a, b
1556   0D8C FD 2E 00 00   mov32 cb, $00000000
1556   0D90 00 00 
1557   0D92 B0            cmp a, b
1558   0D93 FD 81         sgu ; > (unsigned)
1559   0D95 E4            pop a
1560   0D96             ; --- END RELATIONAL
1561   0D96 C0 00 00      cmp b, 0
1562   0D99 C6 10 0E      je _while40_exit
1563   0D9C             _while40_block:
1564   0D9C             ; digits[i] = '0' + (num % 10); 
1565   0D9C FA FC FF      lea d, [bp + -4] ; $digits
1566   0D9F D7            push a
1567   0DA0 DA            push d
1568   0DA1 FA FA FF      lea d, [bp + -6] ; $i
1569   0DA4 2A            mov b, [d]
1570   0DA5 38 00 00      mov c, 0
1571   0DA8 E7            pop d
1572   0DA9 5A            add d, b
1573   0DAA E4            pop a
1574   0DAB DA            push d
1575   0DAC FD 2E 30 00   mov32 cb, $00000030
1575   0DB0 00 00 
1576   0DB2             ; --- START TERMS
1577   0DB2 D7            push a
1578   0DB3 11            mov a, b
1579   0DB4 FA 05 00      lea d, [bp + 5] ; $num
1580   0DB7 2A            mov b, [d]
1581   0DB8 38 00 00      mov c, 0
1582   0DBB             ; --- START FACTORS
1583   0DBB D7            push a
1584   0DBC FD D8         push g
1585   0DBE 11            mov a, b
1586   0DBF FD 7A         mov g, c
1587   0DC1 FD 2E 0A 00   mov32 cb, $0000000a
1587   0DC5 00 00 
1588   0DC7 FD D8         push g ; save 'g' as the div instruction uses it
1589   0DC9 AE            div a, b ; %, a: quotient, b: remainder
1590   0DCA 11            mov a, b
1591   0DCB FD F1         pop g
1592   0DCD FD 38         mov c, g
1593   0DCF 27            mov b, a
1594   0DD0 FD F1         pop g
1595   0DD2 E4            pop a
1596   0DD3             ; --- END FACTORS
1597   0DD3 56            add b, a
1598   0DD4 E4            pop a
1599   0DD5             ; --- END TERMS
1600   0DD5 E7            pop d
1601   0DD6 FD 3E         mov [d], bl
1602   0DD8             ; num = num / 10; 
1603   0DD8 FA 05 00      lea d, [bp + 5] ; $num
1604   0DDB DA            push d
1605   0DDC FA 05 00      lea d, [bp + 5] ; $num
1606   0DDF 2A            mov b, [d]
1607   0DE0 38 00 00      mov c, 0
1608   0DE3             ; --- START FACTORS
1609   0DE3 D7            push a
1610   0DE4 FD D8         push g
1611   0DE6 11            mov a, b
1612   0DE7 FD 7A         mov g, c
1613   0DE9 FD 2E 0A 00   mov32 cb, $0000000a
1613   0DED 00 00 
1614   0DEF FD D8         push g ; save 'g' as the div instruction uses it
1615   0DF1 AE            div a, b ; /, a: quotient, b: remainder
1616   0DF2 FD F1         pop g
1617   0DF4 FD 38         mov c, g
1618   0DF6 27            mov b, a
1619   0DF7 FD F1         pop g
1620   0DF9 E4            pop a
1621   0DFA             ; --- END FACTORS
1622   0DFA E7            pop d
1623   0DFB FD 43         mov [d], b
1624   0DFD             ; i++; 
1625   0DFD FA FA FF      lea d, [bp + -6] ; $i
1626   0E00 2A            mov b, [d]
1627   0E01 38 00 00      mov c, 0
1628   0E04 11            mov a, b
1629   0E05 FD 77         inc b
1630   0E07 FA FA FF      lea d, [bp + -6] ; $i
1631   0E0A FD 43         mov [d], b
1632   0E0C 27            mov b, a
1633   0E0D 0A 83 0D      jmp _while40_cond
1634   0E10             _while40_exit:
1635   0E10             ; while (i > 0) { 
1636   0E10             _while47_cond:
1637   0E10 FA FA FF      lea d, [bp + -6] ; $i
1638   0E13 2A            mov b, [d]
1639   0E14 38 00 00      mov c, 0
1640   0E17             ; --- START RELATIONAL
1641   0E17 D7            push a
1642   0E18 11            mov a, b
1643   0E19 FD 2E 00 00   mov32 cb, $00000000
1643   0E1D 00 00 
1644   0E1F B0            cmp a, b
1645   0E20 FD 7F         sgt ; >
1646   0E22 E4            pop a
1647   0E23             ; --- END RELATIONAL
1648   0E23 C0 00 00      cmp b, 0
1649   0E26 C6 58 0E      je _while47_exit
1650   0E29             _while47_block:
1651   0E29             ; i--; 
1652   0E29 FA FA FF      lea d, [bp + -6] ; $i
1653   0E2C 2A            mov b, [d]
1654   0E2D 38 00 00      mov c, 0
1655   0E30 11            mov a, b
1656   0E31 FD 7D         dec b
1657   0E33 FA FA FF      lea d, [bp + -6] ; $i
1658   0E36 FD 43         mov [d], b
1659   0E38 27            mov b, a
1660   0E39             ; putchar(digits[i]); 
1661   0E39             ; --- START FUNCTION CALL
1662   0E39 FA FC FF      lea d, [bp + -4] ; $digits
1663   0E3C D7            push a
1664   0E3D DA            push d
1665   0E3E FA FA FF      lea d, [bp + -6] ; $i
1666   0E41 2A            mov b, [d]
1667   0E42 38 00 00      mov c, 0
1668   0E45 E7            pop d
1669   0E46 5A            add d, b
1670   0E47 E4            pop a
1671   0E48 32            mov bl, [d]
1672   0E49 A7 00         mov bh, 0
1673   0E4B 38 00 00      mov c, 0
1674   0E4E DD            push bl
1675   0E4F 07 21 0A      call putchar
1676   0E52 51 01 00      add sp, 1
1677   0E55             ; --- END FUNCTION CALL
1678   0E55 0A 10 0E      jmp _while47_cond
1679   0E58             _while47_exit:
1680   0E58 F9            leave
1681   0E59 09            ret
1682   0E5A             
1683   0E5A             printx16:
1684   0E5A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1685   0E5D             ; --- BEGIN INLINE ASM SEGMENT
1686   0E5D FA 05 00      lea d, [bp + 5] ; $hex
1687   0E60 2A            mov b, [d]
1688   0E61             print_u16x_printx16:
1689   0E61 DD            push bl
1690   0E62 30            mov bl, bh
1691   0E63 07 80 0E      call _itoa_printx16        ; convert bh to char in A
1692   0E66 2F            mov bl, al        ; save al
1693   0E67 19 00         mov al, 0
1694   0E69 05 03         syscall sys_io        ; display AH
1695   0E6B 24            mov ah, bl        ; retrieve al
1696   0E6C 19 00         mov al, 0
1697   0E6E 05 03         syscall sys_io        ; display AL
1698   0E70 EA            pop bl
1699   0E71 07 80 0E      call _itoa_printx16        ; convert bh to char in A
1700   0E74 2F            mov bl, al        ; save al
1701   0E75 19 00         mov al, 0
1702   0E77 05 03         syscall sys_io        ; display AH
1703   0E79 24            mov ah, bl        ; retrieve al
1704   0E7A 19 00         mov al, 0
1705   0E7C 05 03         syscall sys_io        ; display AL
1706   0E7E             ; --- END INLINE ASM SEGMENT
1707   0E7E             ; return; 
1708   0E7E F9            leave
1709   0E7F 09            ret
1710   0E80             ; --- BEGIN INLINE ASM SEGMENT
1711   0E80             _itoa_printx16:
1712   0E80 DA            push d
1713   0E81 D8            push b
1714   0E82 A7 00         mov bh, 0
1715   0E84 FD A4 04      shr bl, 4  
1716   0E87 74            mov d, b
1717   0E88 1F 9A 0E      mov al, [d + s_hex_digits_printx16]
1718   0E8B 23            mov ah, al
1719   0E8C E5            pop b
1720   0E8D D8            push b
1721   0E8E A7 00         mov bh, 0
1722   0E90 FD 87 0F      and bl, $0F
1723   0E93 74            mov d, b
1724   0E94 1F 9A 0E      mov al, [d + s_hex_digits_printx16]
1725   0E97 E5            pop b
1726   0E98 E7            pop d
1727   0E99 09            ret
1728   0E9A 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1728   0E9E 34 35 36 37 
1728   0EA2 38 39 41 42 
1728   0EA6 43 44 45 46 
1729   0EAA             ; --- END INLINE ASM SEGMENT
1730   0EAA F9            leave
1731   0EAB 09            ret
1732   0EAC             
1733   0EAC             getchar:
1734   0EAC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1735   0EAF             ; char c; 
1736   0EAF 52 01 00      sub sp, 1
1737   0EB2             ; --- BEGIN INLINE ASM SEGMENT
1738   0EB2 19 01         mov al, 1
1739   0EB4 05 03         syscall sys_io      ; receive in AH
1740   0EB6 1A            mov al, ah
1741   0EB7 FA 00 00      lea d, [bp + 0] ; $c
1742   0EBA 3E            mov [d], al
1743   0EBB             ; --- END INLINE ASM SEGMENT
1744   0EBB             ; return c; 
1745   0EBB FA 00 00      lea d, [bp + 0] ; $c
1746   0EBE 32            mov bl, [d]
1747   0EBF A7 00         mov bh, 0
1748   0EC1 38 00 00      mov c, 0
1749   0EC4 F9            leave
1750   0EC5 09            ret
1751   0EC6             ; --- END TEXT SEGMENT
1752   0EC6             
1753   0EC6             ; --- BEGIN DATA SEGMENT
1754   0EC6 54 65 73 74 _s0: .db "Test of 5.25 inch Floppy Drive Interface.\n", 0
1754   0ECA 20 6F 66 20 
1754   0ECE 35 2E 32 35 
1754   0ED2 20 69 6E 63 
1754   0ED6 68 20 46 6C 
1754   0EDA 6F 70 70 79 
1754   0EDE 20 44 72 69 
1754   0EE2 76 65 20 49 
1754   0EE6 6E 74 65 72 
1754   0EEA 66 61 63 65 
1754   0EEE 2E 0A 00 
1755   0EF1 77 2E 20 77 _s1: .db "w. write 16 to data register\n", 0
1755   0EF5 72 69 74 65 
1755   0EF9 20 31 36 20 
1755   0EFD 74 6F 20 64 
1755   0F01 61 74 61 20 
1755   0F05 72 65 67 69 
1755   0F09 73 74 65 72 
1755   0F0D 0A 00 
1756   0F0F 64 2E 20 72 _s2: .db "d. read data register\n", 0
1756   0F13 65 61 64 20 
1756   0F17 64 61 74 61 
1756   0F1B 20 72 65 67 
1756   0F1F 69 73 74 65 
1756   0F23 72 0A 00 
1757   0F26 74 2E 20 72 _s3: .db "t. read track register\n", 0
1757   0F2A 65 61 64 20 
1757   0F2E 74 72 61 63 
1757   0F32 6B 20 72 65 
1757   0F36 67 69 73 74 
1757   0F3A 65 72 0A 00 
1758   0F3E 73 2E 20 73 _s4: .db "s. step\n", 0
1758   0F42 74 65 70 0A 
1758   0F46 00 
1759   0F47 6B 2E 20 73 _s5: .db "k. seek\n", 0
1759   0F4B 65 65 6B 0A 
1759   0F4F 00 
1760   0F50 72 2E 20 72 _s6: .db "r. restore\n", 0
1760   0F54 65 73 74 6F 
1760   0F58 72 65 0A 00 
1761   0F5C 69 2E 20 73 _s7: .db "i. step in\n", 0
1761   0F60 74 65 70 20 
1761   0F64 69 6E 0A 00 
1762   0F68 6F 2E 20 73 _s8: .db "o. step out\n", 0
1762   0F6C 74 65 70 20 
1762   0F70 6F 75 74 0A 
1762   0F74 00 
1763   0F75 65 2E 20 65 _s9: .db "e. exit\n", 0
1763   0F79 78 69 74 0A 
1763   0F7D 00 
1764   0F7E 71 2E 20 72 _s10: .db "q. read pending irq status register\n", 0
1764   0F82 65 61 64 20 
1764   0F86 70 65 6E 64 
1764   0F8A 69 6E 67 20 
1764   0F8E 69 72 71 20 
1764   0F92 73 74 61 74 
1764   0F96 75 73 20 72 
1764   0F9A 65 67 69 73 
1764   0F9E 74 65 72 0A 
1764   0FA2 00 
1765   0FA3 0A 4F 70 74 _s11: .db "\nOption: ", 0
1765   0FA7 69 6F 6E 3A 
1765   0FAB 20 00 
1766   0FAD 0A 44 61 74 _s12: .db "\nData register value: %d\n", 0
1766   0FB1 61 20 72 65 
1766   0FB5 67 69 73 74 
1766   0FB9 65 72 20 76 
1766   0FBD 61 6C 75 65 
1766   0FC1 3A 20 25 64 
1766   0FC5 0A 00 
1767   0FC7 0A 54 72 61 _s13: .db "\nTrack register value: %d\n", 0
1767   0FCB 63 6B 20 72 
1767   0FCF 65 67 69 73 
1767   0FD3 74 65 72 20 
1767   0FD7 76 61 6C 75 
1767   0FDB 65 3A 20 25 
1767   0FDF 64 0A 00 
1768   0FE2 0A 4D 61 73 _s14: .db "\nMasks: %x\n", 0
1768   0FE6 6B 73 3A 20 
1768   0FEA 25 78 0A 00 
1769   0FEE 55 6E 65 78 _s15: .db "Unexpected format in printf.", 0
1769   0FF2 70 65 63 74 
1769   0FF6 65 64 20 66 
1769   0FFA 6F 72 6D 61 
1769   0FFE 74 20 69 6E 
1769   1002 20 70 72 69 
1769   1006 6E 74 66 2E 
1769   100A 00 
1770   100B 45 72 72 6F _s16: .db "Error: Unknown argument type.\n", 0
1770   100F 72 3A 20 55 
1770   1013 6E 6B 6E 6F 
1770   1017 77 6E 20 61 
1770   101B 72 67 75 6D 
1770   101F 65 6E 74 20 
1770   1023 74 79 70 65 
1770   1027 2E 0A 00 
1771   102A             
1772   102A 2C 10       _heap_top: .dw _heap
1773   102C 00          _heap: .db 0
1774   102D             ; --- END DATA SEGMENT
1775   102D             
1776   102D             .end
tasm: Number of errors = 0
