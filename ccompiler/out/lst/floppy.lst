0001   0000             ; --- FILENAME: programs/floppy.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             sys_break        .EQU  $0000
0002+  0000             sys_rtc          .EQU  $0001
0003+  0000             sys_ide          .EQU  $0002
0004+  0000             sys_io           .EQU  $0003
0005+  0000             sys_filesystem   .EQU  $0004
0006+  0000             sys_create_proc  .EQU  $0005
0007+  0000             sys_list_proc    .EQU  $0006
0008+  0000             sys_datetime     .EQU  $0007
0009+  0000             sys_reboot       .EQU  $0008
0010+  0000             sys_pause_proc   .EQU  $0009
0011+  0000             sys_resume_proc  .EQU  $000a
0012+  0000             sys_terminate_proc .EQU  $000b
0013+  0000             sys_system       .EQU  $000c
0014+  0000             sys_fdc          .EQU  $000d
0015+  0000             text_org         .EQU  $0400
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; char option; 
0011   0408 52 01 00      sub sp, 1
0012   040B             ; char byte; 
0013   040B 52 01 00      sub sp, 1
0014   040E             ; unsigned int word; 
0015   040E 52 02 00      sub sp, 2
0016   0411             ; printf("Test of 5.25 inch Floppy Drive Interface.\n"); 
0017   0411             ; --- START FUNCTION CALL
0018   0411 26 52 0F      mov b, _s0 ; "Test of 5.25 inch Floppy Drive Interface.\n"
0019   0414 FD AB         swp b
0020   0416 D8            push b
0021   0417 07 3B 06      call printf
0022   041A 51 02 00      add sp, 2
0023   041D             ; --- END FUNCTION CALL
0024   041D             ; --- BEGIN INLINE ASM SEGMENT
0025   041D 3B C0 FF      mov d, $FFC0    ; wd1770 data register
0026   0420 19 02         mov al, 2       ; setparam call
0027   0422 2E 09         mov bl, $09     
0028   0424 05 0C         syscall sys_system
0029   0426             ; --- END INLINE ASM SEGMENT
0030   0426             ; for(;;){ 
0031   0426             _for1_init:
0032   0426             _for1_cond:
0033   0426             _for1_block:
0034   0426             ; printf("0. select drive 0\n"); 
0035   0426             ; --- START FUNCTION CALL
0036   0426 26 7D 0F      mov b, _s1 ; "0. select drive 0\n"
0037   0429 FD AB         swp b
0038   042B D8            push b
0039   042C 07 3B 06      call printf
0040   042F 51 02 00      add sp, 2
0041   0432             ; --- END FUNCTION CALL
0042   0432             ; printf("1. select drive 1\n"); 
0043   0432             ; --- START FUNCTION CALL
0044   0432 26 90 0F      mov b, _s2 ; "1. select drive 1\n"
0045   0435 FD AB         swp b
0046   0437 D8            push b
0047   0438 07 3B 06      call printf
0048   043B 51 02 00      add sp, 2
0049   043E             ; --- END FUNCTION CALL
0050   043E             ; printf("f. format\n"); 
0051   043E             ; --- START FUNCTION CALL
0052   043E 26 A3 0F      mov b, _s3 ; "f. format\n"
0053   0441 FD AB         swp b
0054   0443 D8            push b
0055   0444 07 3B 06      call printf
0056   0447 51 02 00      add sp, 2
0057   044A             ; --- END FUNCTION CALL
0058   044A             ; printf("a. set reset bit and select drive 0\n"); 
0059   044A             ; --- START FUNCTION CALL
0060   044A 26 AE 0F      mov b, _s4 ; "a. set reset bit and select drive 0\n"
0061   044D FD AB         swp b
0062   044F D8            push b
0063   0450 07 3B 06      call printf
0064   0453 51 02 00      add sp, 2
0065   0456             ; --- END FUNCTION CALL
0066   0456             ; printf("b. clear reset bit, and select drive 0\n"); 
0067   0456             ; --- START FUNCTION CALL
0068   0456 26 D3 0F      mov b, _s5 ; "b. clear reset bit, and select drive 0\n"
0069   0459 FD AB         swp b
0070   045B D8            push b
0071   045C 07 3B 06      call printf
0072   045F 51 02 00      add sp, 2
0073   0462             ; --- END FUNCTION CALL
0074   0462             ; printf("w. write 16 to data register\n"); 
0075   0462             ; --- START FUNCTION CALL
0076   0462 26 FB 0F      mov b, _s6 ; "w. write 16 to data register\n"
0077   0465 FD AB         swp b
0078   0467 D8            push b
0079   0468 07 3B 06      call printf
0080   046B 51 02 00      add sp, 2
0081   046E             ; --- END FUNCTION CALL
0082   046E             ; printf("d. read data register\n"); 
0083   046E             ; --- START FUNCTION CALL
0084   046E 26 19 10      mov b, _s7 ; "d. read data register\n"
0085   0471 FD AB         swp b
0086   0473 D8            push b
0087   0474 07 3B 06      call printf
0088   0477 51 02 00      add sp, 2
0089   047A             ; --- END FUNCTION CALL
0090   047A             ; printf("t. read track register\n"); 
0091   047A             ; --- START FUNCTION CALL
0092   047A 26 30 10      mov b, _s8 ; "t. read track register\n"
0093   047D FD AB         swp b
0094   047F D8            push b
0095   0480 07 3B 06      call printf
0096   0483 51 02 00      add sp, 2
0097   0486             ; --- END FUNCTION CALL
0098   0486             ; printf("s. step\n"); 
0099   0486             ; --- START FUNCTION CALL
0100   0486 26 48 10      mov b, _s9 ; "s. step\n"
0101   0489 FD AB         swp b
0102   048B D8            push b
0103   048C 07 3B 06      call printf
0104   048F 51 02 00      add sp, 2
0105   0492             ; --- END FUNCTION CALL
0106   0492             ; printf("k. seek\n"); 
0107   0492             ; --- START FUNCTION CALL
0108   0492 26 51 10      mov b, _s10 ; "k. seek\n"
0109   0495 FD AB         swp b
0110   0497 D8            push b
0111   0498 07 3B 06      call printf
0112   049B 51 02 00      add sp, 2
0113   049E             ; --- END FUNCTION CALL
0114   049E             ; printf("r. restore\n"); 
0115   049E             ; --- START FUNCTION CALL
0116   049E 26 5A 10      mov b, _s11 ; "r. restore\n"
0117   04A1 FD AB         swp b
0118   04A3 D8            push b
0119   04A4 07 3B 06      call printf
0120   04A7 51 02 00      add sp, 2
0121   04AA             ; --- END FUNCTION CALL
0122   04AA             ; printf("i. step in\n"); 
0123   04AA             ; --- START FUNCTION CALL
0124   04AA 26 66 10      mov b, _s12 ; "i. step in\n"
0125   04AD FD AB         swp b
0126   04AF D8            push b
0127   04B0 07 3B 06      call printf
0128   04B3 51 02 00      add sp, 2
0129   04B6             ; --- END FUNCTION CALL
0130   04B6             ; printf("o. step out\n"); 
0131   04B6             ; --- START FUNCTION CALL
0132   04B6 26 72 10      mov b, _s13 ; "o. step out\n"
0133   04B9 FD AB         swp b
0134   04BB D8            push b
0135   04BC 07 3B 06      call printf
0136   04BF 51 02 00      add sp, 2
0137   04C2             ; --- END FUNCTION CALL
0138   04C2             ; printf("e. exit\n"); 
0139   04C2             ; --- START FUNCTION CALL
0140   04C2 26 7F 10      mov b, _s14 ; "e. exit\n"
0141   04C5 FD AB         swp b
0142   04C7 D8            push b
0143   04C8 07 3B 06      call printf
0144   04CB 51 02 00      add sp, 2
0145   04CE             ; --- END FUNCTION CALL
0146   04CE             ; printf("q. read pending irq status register\n"); 
0147   04CE             ; --- START FUNCTION CALL
0148   04CE 26 88 10      mov b, _s15 ; "q. read pending irq status register\n"
0149   04D1 FD AB         swp b
0150   04D3 D8            push b
0151   04D4 07 3B 06      call printf
0152   04D7 51 02 00      add sp, 2
0153   04DA             ; --- END FUNCTION CALL
0154   04DA             ; printf("\nOption: "); 
0155   04DA             ; --- START FUNCTION CALL
0156   04DA 26 AD 10      mov b, _s16 ; "\nOption: "
0157   04DD FD AB         swp b
0158   04DF D8            push b
0159   04E0 07 3B 06      call printf
0160   04E3 51 02 00      add sp, 2
0161   04E6             ; --- END FUNCTION CALL
0162   04E6             ; option = getchar(); 
0163   04E6 FA 00 00      lea d, [bp + 0] ; $option
0164   04E9 DA            push d
0165   04EA             ; --- START FUNCTION CALL
0166   04EA 07 38 0F      call getchar
0167   04ED E7            pop d
0168   04EE FD 3E         mov [d], bl
0169   04F0             ; switch(option){ 
0170   04F0             _switch2_expr:
0171   04F0 FA 00 00      lea d, [bp + 0] ; $option
0172   04F3 32            mov bl, [d]
0173   04F4 A7 00         mov bh, 0
0174   04F6 38 00 00      mov c, 0
0175   04F9             _switch2_comparisons:
0176   04F9 C1 66         cmp bl, $66
0177   04FB C6 47 05      je _switch2_case0
0178   04FE C1 61         cmp bl, $61
0179   0500 C6 4E 05      je _switch2_case1
0180   0503 C1 62         cmp bl, $62
0181   0505 C6 5A 05      je _switch2_case2
0182   0508 C1 30         cmp bl, $30
0183   050A C6 66 05      je _switch2_case3
0184   050D C1 31         cmp bl, $31
0185   050F C6 72 05      je _switch2_case4
0186   0512 C1 77         cmp bl, $77
0187   0514 C6 7E 05      je _switch2_case5
0188   0517 C1 64         cmp bl, $64
0189   0519 C6 8A 05      je _switch2_case6
0190   051C C1 74         cmp bl, $74
0191   051E C6 B1 05      je _switch2_case7
0192   0521 C1 73         cmp bl, $73
0193   0523 C6 D8 05      je _switch2_case8
0194   0526 C1 6B         cmp bl, $6b
0195   0528 C6 E4 05      je _switch2_case9
0196   052B C1 72         cmp bl, $72
0197   052D C6 F0 05      je _switch2_case10
0198   0530 C1 69         cmp bl, $69
0199   0532 C6 FC 05      je _switch2_case11
0200   0535 C1 6F         cmp bl, $6f
0201   0537 C6 08 06      je _switch2_case12
0202   053A C1 71         cmp bl, $71
0203   053C C6 14 06      je _switch2_case13
0204   053F C1 65         cmp bl, $65
0205   0541 C6 33 06      je _switch2_case14
0206   0544 0A 36 06      jmp _switch2_exit
0207   0547             _switch2_case0:
0208   0547             ; --- BEGIN INLINE ASM SEGMENT
0209   0547 19 00         mov al, 0       ; format track
0210   0549 05 0D         syscall sys_fdc
0211   054B             ; --- END INLINE ASM SEGMENT
0212   054B             ; break; 
0213   054B 0A 36 06      jmp _switch2_exit ; case break
0214   054E             _switch2_case1:
0215   054E             ; --- BEGIN INLINE ASM SEGMENT
0216   054E 3B C0 FF      mov d, $FFC0    ; fdc output register
0217   0551 19 02         mov al, 2       ; setparam call
0218   0553 2E 2A         mov bl, $2A     ; set reset bit, select drive 0
0219   0555 05 0C         syscall sys_system
0220   0557             ; --- END INLINE ASM SEGMENT
0221   0557             ; break; 
0222   0557 0A 36 06      jmp _switch2_exit ; case break
0223   055A             _switch2_case2:
0224   055A             ; --- BEGIN INLINE ASM SEGMENT
0225   055A 3B C0 FF      mov d, $FFC0    ; fdc output register
0226   055D 19 02         mov al, 2       ; setparam call
0227   055F 2E 0A         mov bl, $0A     ; clear reset bit, select drive 0
0228   0561 05 0C         syscall sys_system
0229   0563             ; --- END INLINE ASM SEGMENT
0230   0563             ; break; 
0231   0563 0A 36 06      jmp _switch2_exit ; case break
0232   0566             _switch2_case3:
0233   0566             ; --- BEGIN INLINE ASM SEGMENT
0234   0566 3B C0 FF      mov d, $FFC0    ; fdc output register
0235   0569 19 02         mov al, 2       ; setparam call
0236   056B 2E 0A         mov bl, $0A     ; select drive 0
0237   056D 05 0C         syscall sys_system
0238   056F             ; --- END INLINE ASM SEGMENT
0239   056F             ; break; 
0240   056F 0A 36 06      jmp _switch2_exit ; case break
0241   0572             _switch2_case4:
0242   0572             ; --- BEGIN INLINE ASM SEGMENT
0243   0572 3B C0 FF      mov d, $FFC0    ; fdc output register
0244   0575 19 02         mov al, 2       ; setparam call
0245   0577 2E 09         mov bl, $09     ; select drive 1
0246   0579 05 0C         syscall sys_system
0247   057B             ; --- END INLINE ASM SEGMENT
0248   057B             ; break; 
0249   057B 0A 36 06      jmp _switch2_exit ; case break
0250   057E             _switch2_case5:
0251   057E             ; --- BEGIN INLINE ASM SEGMENT
0252   057E 3B CB FF      mov d, $FFCB    ; wd1770 data register
0253   0581 19 02         mov al, 2       ; setparam call
0254   0583 2E 10         mov bl, $10     ; track 16
0255   0585 05 0C         syscall sys_system
0256   0587             ; --- END INLINE ASM SEGMENT
0257   0587             ; break; 
0258   0587 0A 36 06      jmp _switch2_exit ; case break
0259   058A             _switch2_case6:
0260   058A             ; --- BEGIN INLINE ASM SEGMENT
0261   058A 3B CB FF      mov d, $FFCB    ; wd1770 data register
0262   058D 19 04         mov al, 4       ; getparam call
0263   058F 05 0C         syscall sys_system
0264   0591 FA FF FF      lea d, [bp + -1] ; $byte
0265   0594 FD 3E         mov [d], bl
0266   0596             ; --- END INLINE ASM SEGMENT
0267   0596             ; printf("\nData register value: %d\n", byte); 
0268   0596             ; --- START FUNCTION CALL
0269   0596 FA FF FF      lea d, [bp + -1] ; $byte
0270   0599 32            mov bl, [d]
0271   059A A7 00         mov bh, 0
0272   059C 38 00 00      mov c, 0
0273   059F FD AB         swp b
0274   05A1 D8            push b
0275   05A2 26 B7 10      mov b, _s17 ; "\nData register value: %d\n"
0276   05A5 FD AB         swp b
0277   05A7 D8            push b
0278   05A8 07 3B 06      call printf
0279   05AB 51 03 00      add sp, 3
0280   05AE             ; --- END FUNCTION CALL
0281   05AE             ; break; 
0282   05AE 0A 36 06      jmp _switch2_exit ; case break
0283   05B1             _switch2_case7:
0284   05B1             ; --- BEGIN INLINE ASM SEGMENT
0285   05B1 3B C9 FF      mov d, $FFC9    ; wd1770 track register
0286   05B4 19 04         mov al, 4       ; getparam call
0287   05B6 05 0C         syscall sys_system
0288   05B8 FA FF FF      lea d, [bp + -1] ; $byte
0289   05BB FD 3E         mov [d], bl
0290   05BD             ; --- END INLINE ASM SEGMENT
0291   05BD             ; printf("\nTrack register value: %d\n", byte); 
0292   05BD             ; --- START FUNCTION CALL
0293   05BD FA FF FF      lea d, [bp + -1] ; $byte
0294   05C0 32            mov bl, [d]
0295   05C1 A7 00         mov bh, 0
0296   05C3 38 00 00      mov c, 0
0297   05C6 FD AB         swp b
0298   05C8 D8            push b
0299   05C9 26 D1 10      mov b, _s18 ; "\nTrack register value: %d\n"
0300   05CC FD AB         swp b
0301   05CE D8            push b
0302   05CF 07 3B 06      call printf
0303   05D2 51 03 00      add sp, 3
0304   05D5             ; --- END FUNCTION CALL
0305   05D5             ; break; 
0306   05D5 0A 36 06      jmp _switch2_exit ; case break
0307   05D8             _switch2_case8:
0308   05D8             ; --- BEGIN INLINE ASM SEGMENT
0309   05D8 3B C8 FF      mov d, $FFC8    ; wd1770 command register
0310   05DB 19 02         mov al, 2       ; setparam call
0311   05DD 2E 23         mov bl, $23     ; STEP command, 30ms rate
0312   05DF 05 0C         syscall sys_system
0313   05E1             ; --- END INLINE ASM SEGMENT
0314   05E1             ; break; 
0315   05E1 0A 36 06      jmp _switch2_exit ; case break
0316   05E4             _switch2_case9:
0317   05E4             ; --- BEGIN INLINE ASM SEGMENT
0318   05E4 3B C8 FF      mov d, $FFC8    ; wd1770 command register
0319   05E7 19 02         mov al, 2       ; setparam call
0320   05E9 2E 13         mov bl, $13     ; seek command
0321   05EB 05 0C         syscall sys_system
0322   05ED             ; --- END INLINE ASM SEGMENT
0323   05ED             ; break; 
0324   05ED 0A 36 06      jmp _switch2_exit ; case break
0325   05F0             _switch2_case10:
0326   05F0             ; --- BEGIN INLINE ASM SEGMENT
0327   05F0               ; send restore command
0328   05F0 3B C8 FF      mov d, $FFC8    ; wd1770
0329   05F3 19 02         mov al, 2       ; setparam call
0330   05F5 2E 03         mov bl, $03     ; restore command, 30ms rate
0331   05F7 05 0C         syscall sys_system
0332   05F9             ; --- END INLINE ASM SEGMENT
0333   05F9             ; break; 
0334   05F9 0A 36 06      jmp _switch2_exit ; case break
0335   05FC             _switch2_case11:
0336   05FC             ; --- BEGIN INLINE ASM SEGMENT
0337   05FC               ; send step in command
0338   05FC 3B C8 FF      mov d, $FFC8    ; wd1770
0339   05FF 19 02         mov al, 2       ; setparam call
0340   0601 2E 43         mov bl, $43     ; step in command, 30ms rate
0341   0603 05 0C         syscall sys_system
0342   0605             ; --- END INLINE ASM SEGMENT
0343   0605             ; break; 
0344   0605 0A 36 06      jmp _switch2_exit ; case break
0345   0608             _switch2_case12:
0346   0608             ; --- BEGIN INLINE ASM SEGMENT
0347   0608               ; send step out command
0348   0608 3B C8 FF      mov d, $FFC8    ; wd1770
0349   060B 19 02         mov al, 2       ; setparam call
0350   060D 2E 63         mov bl, $63     ; step out command, 30ms rate
0351   060F 05 0C         syscall sys_system
0352   0611             ; --- END INLINE ASM SEGMENT
0353   0611             ; break; 
0354   0611 0A 36 06      jmp _switch2_exit ; case break
0355   0614             _switch2_case13:
0356   0614             ; --- BEGIN INLINE ASM SEGMENT
0357   0614 FD 0E         lodmsk          ; load masks register/irq status register
0358   0616 FA FD FF      lea d, [bp + -3] ; $word
0359   0619               ; load address of word into d
0360   0619 43            mov [d], a      ; al = masks, ah = irq status
0361   061A             ; --- END INLINE ASM SEGMENT
0362   061A             ; printf("\nMasks: %x\n", word); 
0363   061A             ; --- START FUNCTION CALL
0364   061A FA FD FF      lea d, [bp + -3] ; $word
0365   061D 2A            mov b, [d]
0366   061E 38 00 00      mov c, 0
0367   0621 FD AB         swp b
0368   0623 D8            push b
0369   0624 26 EC 10      mov b, _s19 ; "\nMasks: %x\n"
0370   0627 FD AB         swp b
0371   0629 D8            push b
0372   062A 07 3B 06      call printf
0373   062D 51 04 00      add sp, 4
0374   0630             ; --- END FUNCTION CALL
0375   0630             ; break; 
0376   0630 0A 36 06      jmp _switch2_exit ; case break
0377   0633             _switch2_case14:
0378   0633             ; return; 
0379   0633 F9            leave
0380   0634 05 0B         syscall sys_terminate_proc
0381   0636             _switch2_exit:
0382   0636             _for1_update:
0383   0636 0A 26 04      jmp _for1_cond
0384   0639             _for1_exit:
0385   0639 05 0B         syscall sys_terminate_proc
0386   063B             
0387   063B             printf:
0388   063B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0389   063E             ; char *p, *format_p; 
0390   063E 52 02 00      sub sp, 2
0391   0641 52 02 00      sub sp, 2
0392   0644             ; format_p = format; 
0393   0644 FA FD FF      lea d, [bp + -3] ; $format_p
0394   0647 DA            push d
0395   0648 FA 05 00      lea d, [bp + 5] ; $format
0396   064B 2A            mov b, [d]
0397   064C 38 00 00      mov c, 0
0398   064F E7            pop d
0399   0650 FD 43         mov [d], b
0400   0652             ; p = &format + 2; 
0401   0652 FA FF FF      lea d, [bp + -1] ; $p
0402   0655 DA            push d
0403   0656 FA 05 00      lea d, [bp + 5] ; $format
0404   0659 2D            mov b, d
0405   065A             ; --- START TERMS
0406   065A D7            push a
0407   065B 11            mov a, b
0408   065C FD 2E 02 00   mov32 cb, $00000002
0408   0660 00 00 
0409   0662 56            add b, a
0410   0663 E4            pop a
0411   0664             ; --- END TERMS
0412   0664 E7            pop d
0413   0665 FD 43         mov [d], b
0414   0667             ; for(;;){ 
0415   0667             _for3_init:
0416   0667             _for3_cond:
0417   0667             _for3_block:
0418   0667             ; if(!*format_p) break; 
0419   0667             _if4_cond:
0420   0667 FA FD FF      lea d, [bp + -3] ; $format_p
0421   066A 2A            mov b, [d]
0422   066B 38 00 00      mov c, 0
0423   066E 74            mov d, b
0424   066F 32            mov bl, [d]
0425   0670 A7 00         mov bh, 0
0426   0672 38 00 00      mov c, 0
0427   0675 C0 00 00      cmp b, 0
0428   0678 FD 71         seq ; !
0429   067A C0 00 00      cmp b, 0
0430   067D C6 86 06      je _if4_else
0431   0680             _if4_TRUE:
0432   0680             ; break; 
0433   0680 0A 26 09      jmp _for3_exit ; for break
0434   0683 0A 13 09      jmp _if4_exit
0435   0686             _if4_else:
0436   0686             ; if(*format_p == '%'){ 
0437   0686             _if5_cond:
0438   0686 FA FD FF      lea d, [bp + -3] ; $format_p
0439   0689 2A            mov b, [d]
0440   068A 38 00 00      mov c, 0
0441   068D 74            mov d, b
0442   068E 32            mov bl, [d]
0443   068F A7 00         mov bh, 0
0444   0691 38 00 00      mov c, 0
0445   0694             ; --- START RELATIONAL
0446   0694 D7            push a
0447   0695 11            mov a, b
0448   0696 FD 2E 25 00   mov32 cb, $00000025
0448   069A 00 00 
0449   069C B0            cmp a, b
0450   069D FD 71         seq ; ==
0451   069F E4            pop a
0452   06A0             ; --- END RELATIONAL
0453   06A0 C0 00 00      cmp b, 0
0454   06A3 C6 FE 08      je _if5_else
0455   06A6             _if5_TRUE:
0456   06A6             ; format_p++; 
0457   06A6 FA FD FF      lea d, [bp + -3] ; $format_p
0458   06A9 2A            mov b, [d]
0459   06AA 38 00 00      mov c, 0
0460   06AD FD 77         inc b
0461   06AF FA FD FF      lea d, [bp + -3] ; $format_p
0462   06B2 FD 43         mov [d], b
0463   06B4 FD 7D         dec b
0464   06B6             ; switch(*format_p){ 
0465   06B6             _switch6_expr:
0466   06B6 FA FD FF      lea d, [bp + -3] ; $format_p
0467   06B9 2A            mov b, [d]
0468   06BA 38 00 00      mov c, 0
0469   06BD 74            mov d, b
0470   06BE 32            mov bl, [d]
0471   06BF A7 00         mov bh, 0
0472   06C1 38 00 00      mov c, 0
0473   06C4             _switch6_comparisons:
0474   06C4 C1 6C         cmp bl, $6c
0475   06C6 C6 F2 06      je _switch6_case0
0476   06C9 C1 4C         cmp bl, $4c
0477   06CB C6 F2 06      je _switch6_case1
0478   06CE C1 64         cmp bl, $64
0479   06D0 C6 02 08      je _switch6_case2
0480   06D3 C1 69         cmp bl, $69
0481   06D5 C6 02 08      je _switch6_case3
0482   06D8 C1 75         cmp bl, $75
0483   06DA C6 32 08      je _switch6_case4
0484   06DD C1 78         cmp bl, $78
0485   06DF C6 62 08      je _switch6_case5
0486   06E2 C1 63         cmp bl, $63
0487   06E4 C6 92 08      je _switch6_case6
0488   06E7 C1 73         cmp bl, $73
0489   06E9 C6 C2 08      je _switch6_case7
0490   06EC 0A EF 08      jmp _switch6_default
0491   06EF 0A FB 08      jmp _switch6_exit
0492   06F2             _switch6_case0:
0493   06F2             _switch6_case1:
0494   06F2             ; format_p++; 
0495   06F2 FA FD FF      lea d, [bp + -3] ; $format_p
0496   06F5 2A            mov b, [d]
0497   06F6 38 00 00      mov c, 0
0498   06F9 FD 77         inc b
0499   06FB FA FD FF      lea d, [bp + -3] ; $format_p
0500   06FE FD 43         mov [d], b
0501   0700 FD 7D         dec b
0502   0702             ; if(*format_p == 'd' || *format_p == 'i') 
0503   0702             _if7_cond:
0504   0702 FA FD FF      lea d, [bp + -3] ; $format_p
0505   0705 2A            mov b, [d]
0506   0706 38 00 00      mov c, 0
0507   0709 74            mov d, b
0508   070A 32            mov bl, [d]
0509   070B A7 00         mov bh, 0
0510   070D 38 00 00      mov c, 0
0511   0710             ; --- START RELATIONAL
0512   0710 D7            push a
0513   0711 11            mov a, b
0514   0712 FD 2E 64 00   mov32 cb, $00000064
0514   0716 00 00 
0515   0718 B0            cmp a, b
0516   0719 FD 71         seq ; ==
0517   071B E4            pop a
0518   071C             ; --- END RELATIONAL
0519   071C             ; --- START LOGICAL OR
0520   071C D7            push a
0521   071D 11            mov a, b
0522   071E FA FD FF      lea d, [bp + -3] ; $format_p
0523   0721 2A            mov b, [d]
0524   0722 38 00 00      mov c, 0
0525   0725 74            mov d, b
0526   0726 32            mov bl, [d]
0527   0727 A7 00         mov bh, 0
0528   0729 38 00 00      mov c, 0
0529   072C             ; --- START RELATIONAL
0530   072C D7            push a
0531   072D 11            mov a, b
0532   072E FD 2E 69 00   mov32 cb, $00000069
0532   0732 00 00 
0533   0734 B0            cmp a, b
0534   0735 FD 71         seq ; ==
0535   0737 E4            pop a
0536   0738             ; --- END RELATIONAL
0537   0738 FD A8         sor a, b ; ||
0538   073A E4            pop a
0539   073B             ; --- END LOGICAL OR
0540   073B C0 00 00      cmp b, 0
0541   073E C6 5F 07      je _if7_else
0542   0741             _if7_TRUE:
0543   0741             ; print_signed_long(*(long *)p); 
0544   0741             ; --- START FUNCTION CALL
0545   0741 FA FF FF      lea d, [bp + -1] ; $p
0546   0744 2A            mov b, [d]
0547   0745 38 00 00      mov c, 0
0548   0748 74            mov d, b
0549   0749 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0550   074C FD 39         mov c, b ; And place it into C
0551   074E 2A            mov b, [d] ; Lower Word in B
0552   074F 12            mov a, c
0553   0750 FD AA         swp a
0554   0752 D7            push a
0555   0753 FD AB         swp b
0556   0755 D8            push b
0557   0756 07 28 09      call print_signed_long
0558   0759 51 04 00      add sp, 4
0559   075C             ; --- END FUNCTION CALL
0560   075C 0A E7 07      jmp _if7_exit
0561   075F             _if7_else:
0562   075F             ; if(*format_p == 'u') 
0563   075F             _if8_cond:
0564   075F FA FD FF      lea d, [bp + -3] ; $format_p
0565   0762 2A            mov b, [d]
0566   0763 38 00 00      mov c, 0
0567   0766 74            mov d, b
0568   0767 32            mov bl, [d]
0569   0768 A7 00         mov bh, 0
0570   076A 38 00 00      mov c, 0
0571   076D             ; --- START RELATIONAL
0572   076D D7            push a
0573   076E 11            mov a, b
0574   076F FD 2E 75 00   mov32 cb, $00000075
0574   0773 00 00 
0575   0775 B0            cmp a, b
0576   0776 FD 71         seq ; ==
0577   0778 E4            pop a
0578   0779             ; --- END RELATIONAL
0579   0779 C0 00 00      cmp b, 0
0580   077C C6 9D 07      je _if8_else
0581   077F             _if8_TRUE:
0582   077F             ; print_unsigned_long(*(unsigned long *)p); 
0583   077F             ; --- START FUNCTION CALL
0584   077F FA FF FF      lea d, [bp + -1] ; $p
0585   0782 2A            mov b, [d]
0586   0783 38 00 00      mov c, 0
0587   0786 74            mov d, b
0588   0787 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0589   078A FD 39         mov c, b ; And place it into C
0590   078C 2A            mov b, [d] ; Lower Word in B
0591   078D 12            mov a, c
0592   078E FD AA         swp a
0593   0790 D7            push a
0594   0791 FD AB         swp b
0595   0793 D8            push b
0596   0794 07 BB 0A      call print_unsigned_long
0597   0797 51 04 00      add sp, 4
0598   079A             ; --- END FUNCTION CALL
0599   079A 0A E7 07      jmp _if8_exit
0600   079D             _if8_else:
0601   079D             ; if(*format_p == 'x') 
0602   079D             _if9_cond:
0603   079D FA FD FF      lea d, [bp + -3] ; $format_p
0604   07A0 2A            mov b, [d]
0605   07A1 38 00 00      mov c, 0
0606   07A4 74            mov d, b
0607   07A5 32            mov bl, [d]
0608   07A6 A7 00         mov bh, 0
0609   07A8 38 00 00      mov c, 0
0610   07AB             ; --- START RELATIONAL
0611   07AB D7            push a
0612   07AC 11            mov a, b
0613   07AD FD 2E 78 00   mov32 cb, $00000078
0613   07B1 00 00 
0614   07B3 B0            cmp a, b
0615   07B4 FD 71         seq ; ==
0616   07B6 E4            pop a
0617   07B7             ; --- END RELATIONAL
0618   07B7 C0 00 00      cmp b, 0
0619   07BA C6 DB 07      je _if9_else
0620   07BD             _if9_TRUE:
0621   07BD             ; printx32(*(long int *)p); 
0622   07BD             ; --- START FUNCTION CALL
0623   07BD FA FF FF      lea d, [bp + -1] ; $p
0624   07C0 2A            mov b, [d]
0625   07C1 38 00 00      mov c, 0
0626   07C4 74            mov d, b
0627   07C5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0628   07C8 FD 39         mov c, b ; And place it into C
0629   07CA 2A            mov b, [d] ; Lower Word in B
0630   07CB 12            mov a, c
0631   07CC FD AA         swp a
0632   07CE D7            push a
0633   07CF FD AB         swp b
0634   07D1 D8            push b
0635   07D2 07 EF 0B      call printx32
0636   07D5 51 04 00      add sp, 4
0637   07D8             ; --- END FUNCTION CALL
0638   07D8 0A E7 07      jmp _if9_exit
0639   07DB             _if9_else:
0640   07DB             ; err("Unexpected format in printf."); 
0641   07DB             ; --- START FUNCTION CALL
0642   07DB 26 F8 10      mov b, _s20 ; "Unexpected format in printf."
0643   07DE FD AB         swp b
0644   07E0 D8            push b
0645   07E1 07 4F 0C      call err
0646   07E4 51 02 00      add sp, 2
0647   07E7             ; --- END FUNCTION CALL
0648   07E7             _if9_exit:
0649   07E7             _if8_exit:
0650   07E7             _if7_exit:
0651   07E7             ; p = p + 4; 
0652   07E7 FA FF FF      lea d, [bp + -1] ; $p
0653   07EA DA            push d
0654   07EB FA FF FF      lea d, [bp + -1] ; $p
0655   07EE 2A            mov b, [d]
0656   07EF 38 00 00      mov c, 0
0657   07F2             ; --- START TERMS
0658   07F2 D7            push a
0659   07F3 11            mov a, b
0660   07F4 FD 2E 04 00   mov32 cb, $00000004
0660   07F8 00 00 
0661   07FA 56            add b, a
0662   07FB E4            pop a
0663   07FC             ; --- END TERMS
0664   07FC E7            pop d
0665   07FD FD 43         mov [d], b
0666   07FF             ; break; 
0667   07FF 0A FB 08      jmp _switch6_exit ; case break
0668   0802             _switch6_case2:
0669   0802             _switch6_case3:
0670   0802             ; print_signed(*(int*)p); 
0671   0802             ; --- START FUNCTION CALL
0672   0802 FA FF FF      lea d, [bp + -1] ; $p
0673   0805 2A            mov b, [d]
0674   0806 38 00 00      mov c, 0
0675   0809 74            mov d, b
0676   080A 2A            mov b, [d]
0677   080B 38 00 00      mov c, 0
0678   080E FD AB         swp b
0679   0810 D8            push b
0680   0811 07 7D 0C      call print_signed
0681   0814 51 02 00      add sp, 2
0682   0817             ; --- END FUNCTION CALL
0683   0817             ; p = p + 2; 
0684   0817 FA FF FF      lea d, [bp + -1] ; $p
0685   081A DA            push d
0686   081B FA FF FF      lea d, [bp + -1] ; $p
0687   081E 2A            mov b, [d]
0688   081F 38 00 00      mov c, 0
0689   0822             ; --- START TERMS
0690   0822 D7            push a
0691   0823 11            mov a, b
0692   0824 FD 2E 02 00   mov32 cb, $00000002
0692   0828 00 00 
0693   082A 56            add b, a
0694   082B E4            pop a
0695   082C             ; --- END TERMS
0696   082C E7            pop d
0697   082D FD 43         mov [d], b
0698   082F             ; break; 
0699   082F 0A FB 08      jmp _switch6_exit ; case break
0700   0832             _switch6_case4:
0701   0832             ; print_unsigned(*(unsigned int*)p); 
0702   0832             ; --- START FUNCTION CALL
0703   0832 FA FF FF      lea d, [bp + -1] ; $p
0704   0835 2A            mov b, [d]
0705   0836 38 00 00      mov c, 0
0706   0839 74            mov d, b
0707   083A 2A            mov b, [d]
0708   083B 38 00 00      mov c, 0
0709   083E FD AB         swp b
0710   0840 D8            push b
0711   0841 07 CE 0D      call print_unsigned
0712   0844 51 02 00      add sp, 2
0713   0847             ; --- END FUNCTION CALL
0714   0847             ; p = p + 2; 
0715   0847 FA FF FF      lea d, [bp + -1] ; $p
0716   084A DA            push d
0717   084B FA FF FF      lea d, [bp + -1] ; $p
0718   084E 2A            mov b, [d]
0719   084F 38 00 00      mov c, 0
0720   0852             ; --- START TERMS
0721   0852 D7            push a
0722   0853 11            mov a, b
0723   0854 FD 2E 02 00   mov32 cb, $00000002
0723   0858 00 00 
0724   085A 56            add b, a
0725   085B E4            pop a
0726   085C             ; --- END TERMS
0727   085C E7            pop d
0728   085D FD 43         mov [d], b
0729   085F             ; break; 
0730   085F 0A FB 08      jmp _switch6_exit ; case break
0731   0862             _switch6_case5:
0732   0862             ; printx16(*(int*)p); 
0733   0862             ; --- START FUNCTION CALL
0734   0862 FA FF FF      lea d, [bp + -1] ; $p
0735   0865 2A            mov b, [d]
0736   0866 38 00 00      mov c, 0
0737   0869 74            mov d, b
0738   086A 2A            mov b, [d]
0739   086B 38 00 00      mov c, 0
0740   086E FD AB         swp b
0741   0870 D8            push b
0742   0871 07 E6 0E      call printx16
0743   0874 51 02 00      add sp, 2
0744   0877             ; --- END FUNCTION CALL
0745   0877             ; p = p + 2; 
0746   0877 FA FF FF      lea d, [bp + -1] ; $p
0747   087A DA            push d
0748   087B FA FF FF      lea d, [bp + -1] ; $p
0749   087E 2A            mov b, [d]
0750   087F 38 00 00      mov c, 0
0751   0882             ; --- START TERMS
0752   0882 D7            push a
0753   0883 11            mov a, b
0754   0884 FD 2E 02 00   mov32 cb, $00000002
0754   0888 00 00 
0755   088A 56            add b, a
0756   088B E4            pop a
0757   088C             ; --- END TERMS
0758   088C E7            pop d
0759   088D FD 43         mov [d], b
0760   088F             ; break; 
0761   088F 0A FB 08      jmp _switch6_exit ; case break
0762   0892             _switch6_case6:
0763   0892             ; putchar(*(char*)p); 
0764   0892             ; --- START FUNCTION CALL
0765   0892 FA FF FF      lea d, [bp + -1] ; $p
0766   0895 2A            mov b, [d]
0767   0896 38 00 00      mov c, 0
0768   0899 74            mov d, b
0769   089A 32            mov bl, [d]
0770   089B A7 00         mov bh, 0
0771   089D 38 00 00      mov c, 0
0772   08A0 DD            push bl
0773   08A1 07 AD 0A      call putchar
0774   08A4 51 01 00      add sp, 1
0775   08A7             ; --- END FUNCTION CALL
0776   08A7             ; p = p + 2; 
0777   08A7 FA FF FF      lea d, [bp + -1] ; $p
0778   08AA DA            push d
0779   08AB FA FF FF      lea d, [bp + -1] ; $p
0780   08AE 2A            mov b, [d]
0781   08AF 38 00 00      mov c, 0
0782   08B2             ; --- START TERMS
0783   08B2 D7            push a
0784   08B3 11            mov a, b
0785   08B4 FD 2E 02 00   mov32 cb, $00000002
0785   08B8 00 00 
0786   08BA 56            add b, a
0787   08BB E4            pop a
0788   08BC             ; --- END TERMS
0789   08BC E7            pop d
0790   08BD FD 43         mov [d], b
0791   08BF             ; break; 
0792   08BF 0A FB 08      jmp _switch6_exit ; case break
0793   08C2             _switch6_case7:
0794   08C2             ; print(*(char**)p); 
0795   08C2             ; --- START FUNCTION CALL
0796   08C2 FA FF FF      lea d, [bp + -1] ; $p
0797   08C5 2A            mov b, [d]
0798   08C6 38 00 00      mov c, 0
0799   08C9 74            mov d, b
0800   08CA 2A            mov b, [d]
0801   08CB FD AB         swp b
0802   08CD D8            push b
0803   08CE 07 64 0C      call print
0804   08D1 51 02 00      add sp, 2
0805   08D4             ; --- END FUNCTION CALL
0806   08D4             ; p = p + 2; 
0807   08D4 FA FF FF      lea d, [bp + -1] ; $p
0808   08D7 DA            push d
0809   08D8 FA FF FF      lea d, [bp + -1] ; $p
0810   08DB 2A            mov b, [d]
0811   08DC 38 00 00      mov c, 0
0812   08DF             ; --- START TERMS
0813   08DF D7            push a
0814   08E0 11            mov a, b
0815   08E1 FD 2E 02 00   mov32 cb, $00000002
0815   08E5 00 00 
0816   08E7 56            add b, a
0817   08E8 E4            pop a
0818   08E9             ; --- END TERMS
0819   08E9 E7            pop d
0820   08EA FD 43         mov [d], b
0821   08EC             ; break; 
0822   08EC 0A FB 08      jmp _switch6_exit ; case break
0823   08EF             _switch6_default:
0824   08EF             ; print("Error: Unknown argument type.\n"); 
0825   08EF             ; --- START FUNCTION CALL
0826   08EF 26 15 11      mov b, _s21 ; "Error: Unknown argument type.\n"
0827   08F2 FD AB         swp b
0828   08F4 D8            push b
0829   08F5 07 64 0C      call print
0830   08F8 51 02 00      add sp, 2
0831   08FB             ; --- END FUNCTION CALL
0832   08FB             _switch6_exit:
0833   08FB 0A 13 09      jmp _if5_exit
0834   08FE             _if5_else:
0835   08FE             ; putchar(*format_p); 
0836   08FE             ; --- START FUNCTION CALL
0837   08FE FA FD FF      lea d, [bp + -3] ; $format_p
0838   0901 2A            mov b, [d]
0839   0902 38 00 00      mov c, 0
0840   0905 74            mov d, b
0841   0906 32            mov bl, [d]
0842   0907 A7 00         mov bh, 0
0843   0909 38 00 00      mov c, 0
0844   090C DD            push bl
0845   090D 07 AD 0A      call putchar
0846   0910 51 01 00      add sp, 1
0847   0913             ; --- END FUNCTION CALL
0848   0913             _if5_exit:
0849   0913             _if4_exit:
0850   0913             ; format_p++; 
0851   0913 FA FD FF      lea d, [bp + -3] ; $format_p
0852   0916 2A            mov b, [d]
0853   0917 38 00 00      mov c, 0
0854   091A FD 77         inc b
0855   091C FA FD FF      lea d, [bp + -3] ; $format_p
0856   091F FD 43         mov [d], b
0857   0921 FD 7D         dec b
0858   0923             _for3_update:
0859   0923 0A 67 06      jmp _for3_cond
0860   0926             _for3_exit:
0861   0926 F9            leave
0862   0927 09            ret
0863   0928             
0864   0928             print_signed_long:
0865   0928 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0866   092B             ; char digits[10]; 
0867   092B 52 0A 00      sub sp, 10
0868   092E             ; int i = 0; 
0869   092E 52 02 00      sub sp, 2
0870   0931             ; --- START LOCAL VAR INITIALIZATION
0871   0931 FA F5 FF      lea d, [bp + -11] ; $i
0872   0934 DA            push d
0873   0935 FD 2E 00 00   mov32 cb, $00000000
0873   0939 00 00 
0874   093B E7            pop d
0875   093C FD 43         mov [d], b
0876   093E             ; --- END LOCAL VAR INITIALIZATION
0877   093E             ; if (num < 0) { 
0878   093E             _if10_cond:
0879   093E FA 05 00      lea d, [bp + 5] ; $num
0880   0941 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0881   0944 FD 39         mov c, b ; And place it into C
0882   0946 2A            mov b, [d] ; Lower Word in B
0883   0947             ; --- START RELATIONAL
0884   0947 D7            push a
0885   0948 FD D8         push g
0886   094A 11            mov a, b
0887   094B FD 7A         mov g, c
0888   094D FD 2E 00 00   mov32 cb, $00000000
0888   0951 00 00 
0889   0953 FD AF         cmp32 ga, cb
0890   0955 FD 73         slt ; <
0891   0957 FD F1         pop g
0892   0959 E4            pop a
0893   095A             ; --- END RELATIONAL
0894   095A C0 00 00      cmp b, 0
0895   095D C6 8F 09      je _if10_else
0896   0960             _if10_TRUE:
0897   0960             ; putchar('-'); 
0898   0960             ; --- START FUNCTION CALL
0899   0960 FD 2E 2D 00   mov32 cb, $0000002d
0899   0964 00 00 
0900   0966 DD            push bl
0901   0967 07 AD 0A      call putchar
0902   096A 51 01 00      add sp, 1
0903   096D             ; --- END FUNCTION CALL
0904   096D             ; num = -num; 
0905   096D FA 05 00      lea d, [bp + 5] ; $num
0906   0970 DA            push d
0907   0971 FA 05 00      lea d, [bp + 5] ; $num
0908   0974 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0909   0977 FD 39         mov c, b ; And place it into C
0910   0979 2A            mov b, [d] ; Lower Word in B
0911   097A 12            mov a, c
0912   097B 95            not a
0913   097C 97            not b
0914   097D 55 01 00      add b, 1
0915   0980 5B 00 00      adc a, 0
0916   0983 39            mov c, a
0917   0984 E7            pop d
0918   0985 FD 43         mov [d], b
0919   0987 28            mov b, c
0920   0988 FD 44 02 00   mov [d + 2], b
0921   098C 0A C3 09      jmp _if10_exit
0922   098F             _if10_else:
0923   098F             ; if (num == 0) { 
0924   098F             _if11_cond:
0925   098F FA 05 00      lea d, [bp + 5] ; $num
0926   0992 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0927   0995 FD 39         mov c, b ; And place it into C
0928   0997 2A            mov b, [d] ; Lower Word in B
0929   0998             ; --- START RELATIONAL
0930   0998 D7            push a
0931   0999 FD D8         push g
0932   099B 11            mov a, b
0933   099C FD 7A         mov g, c
0934   099E FD 2E 00 00   mov32 cb, $00000000
0934   09A2 00 00 
0935   09A4 FD AF         cmp32 ga, cb
0936   09A6 FD 71         seq ; ==
0937   09A8 FD F1         pop g
0938   09AA E4            pop a
0939   09AB             ; --- END RELATIONAL
0940   09AB C0 00 00      cmp b, 0
0941   09AE C6 C3 09      je _if11_exit
0942   09B1             _if11_TRUE:
0943   09B1             ; putchar('0'); 
0944   09B1             ; --- START FUNCTION CALL
0945   09B1 FD 2E 30 00   mov32 cb, $00000030
0945   09B5 00 00 
0946   09B7 DD            push bl
0947   09B8 07 AD 0A      call putchar
0948   09BB 51 01 00      add sp, 1
0949   09BE             ; --- END FUNCTION CALL
0950   09BE             ; return; 
0951   09BE F9            leave
0952   09BF 09            ret
0953   09C0 0A C3 09      jmp _if11_exit
0954   09C3             _if11_exit:
0955   09C3             _if10_exit:
0956   09C3             ; while (num > 0) { 
0957   09C3             _while12_cond:
0958   09C3 FA 05 00      lea d, [bp + 5] ; $num
0959   09C6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0960   09C9 FD 39         mov c, b ; And place it into C
0961   09CB 2A            mov b, [d] ; Lower Word in B
0962   09CC             ; --- START RELATIONAL
0963   09CC D7            push a
0964   09CD FD D8         push g
0965   09CF 11            mov a, b
0966   09D0 FD 7A         mov g, c
0967   09D2 FD 2E 00 00   mov32 cb, $00000000
0967   09D6 00 00 
0968   09D8 FD AF         cmp32 ga, cb
0969   09DA FD 7F         sgt
0970   09DC FD F1         pop g
0971   09DE E4            pop a
0972   09DF             ; --- END RELATIONAL
0973   09DF C0 00 00      cmp b, 0
0974   09E2 C6 63 0A      je _while12_exit
0975   09E5             _while12_block:
0976   09E5             ; digits[i] = '0' + (num % 10); 
0977   09E5 FA F7 FF      lea d, [bp + -9] ; $digits
0978   09E8 D7            push a
0979   09E9 DA            push d
0980   09EA FA F5 FF      lea d, [bp + -11] ; $i
0981   09ED 2A            mov b, [d]
0982   09EE 38 00 00      mov c, 0
0983   09F1 E7            pop d
0984   09F2 5A            add d, b
0985   09F3 E4            pop a
0986   09F4 DA            push d
0987   09F5 FD 2E 30 00   mov32 cb, $00000030
0987   09F9 00 00 
0988   09FB             ; --- START TERMS
0989   09FB D7            push a
0990   09FC 11            mov a, b
0991   09FD FA 05 00      lea d, [bp + 5] ; $num
0992   0A00 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0993   0A03 FD 39         mov c, b ; And place it into C
0994   0A05 2A            mov b, [d] ; Lower Word in B
0995   0A06             ; --- START FACTORS
0996   0A06 D7            push a
0997   0A07 FD D8         push g
0998   0A09 11            mov a, b
0999   0A0A FD 7A         mov g, c
1000   0A0C FD 2E 0A 00   mov32 cb, $0000000a
1000   0A10 00 00 
1001   0A12 FD D8         push g ; save 'g' as the div instruction uses it
1002   0A14 AE            div a, b ; %, a: quotient, b: remainder
1003   0A15 11            mov a, b
1004   0A16 FD F1         pop g
1005   0A18 FD 38         mov c, g
1006   0A1A 27            mov b, a
1007   0A1B FD F1         pop g
1008   0A1D E4            pop a
1009   0A1E             ; --- END FACTORS
1010   0A1E FD 15         add32 cb, ga
1011   0A20 E4            pop a
1012   0A21             ; --- END TERMS
1013   0A21 E7            pop d
1014   0A22 FD 3E         mov [d], bl
1015   0A24             ; num = num / 10; 
1016   0A24 FA 05 00      lea d, [bp + 5] ; $num
1017   0A27 DA            push d
1018   0A28 FA 05 00      lea d, [bp + 5] ; $num
1019   0A2B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1020   0A2E FD 39         mov c, b ; And place it into C
1021   0A30 2A            mov b, [d] ; Lower Word in B
1022   0A31             ; --- START FACTORS
1023   0A31 D7            push a
1024   0A32 FD D8         push g
1025   0A34 11            mov a, b
1026   0A35 FD 7A         mov g, c
1027   0A37 FD 2E 0A 00   mov32 cb, $0000000a
1027   0A3B 00 00 
1028   0A3D FD D8         push g ; save 'g' as the div instruction uses it
1029   0A3F AE            div a, b ; /, a: quotient, b: remainder
1030   0A40 FD F1         pop g
1031   0A42 FD 38         mov c, g
1032   0A44 27            mov b, a
1033   0A45 FD F1         pop g
1034   0A47 E4            pop a
1035   0A48             ; --- END FACTORS
1036   0A48 E7            pop d
1037   0A49 FD 43         mov [d], b
1038   0A4B 28            mov b, c
1039   0A4C FD 44 02 00   mov [d + 2], b
1040   0A50             ; i++; 
1041   0A50 FA F5 FF      lea d, [bp + -11] ; $i
1042   0A53 2A            mov b, [d]
1043   0A54 38 00 00      mov c, 0
1044   0A57 11            mov a, b
1045   0A58 FD 77         inc b
1046   0A5A FA F5 FF      lea d, [bp + -11] ; $i
1047   0A5D FD 43         mov [d], b
1048   0A5F 27            mov b, a
1049   0A60 0A C3 09      jmp _while12_cond
1050   0A63             _while12_exit:
1051   0A63             ; while (i > 0) { 
1052   0A63             _while19_cond:
1053   0A63 FA F5 FF      lea d, [bp + -11] ; $i
1054   0A66 2A            mov b, [d]
1055   0A67 38 00 00      mov c, 0
1056   0A6A             ; --- START RELATIONAL
1057   0A6A D7            push a
1058   0A6B 11            mov a, b
1059   0A6C FD 2E 00 00   mov32 cb, $00000000
1059   0A70 00 00 
1060   0A72 B0            cmp a, b
1061   0A73 FD 7F         sgt ; >
1062   0A75 E4            pop a
1063   0A76             ; --- END RELATIONAL
1064   0A76 C0 00 00      cmp b, 0
1065   0A79 C6 AB 0A      je _while19_exit
1066   0A7C             _while19_block:
1067   0A7C             ; i--; 
1068   0A7C FA F5 FF      lea d, [bp + -11] ; $i
1069   0A7F 2A            mov b, [d]
1070   0A80 38 00 00      mov c, 0
1071   0A83 11            mov a, b
1072   0A84 FD 7D         dec b
1073   0A86 FA F5 FF      lea d, [bp + -11] ; $i
1074   0A89 FD 43         mov [d], b
1075   0A8B 27            mov b, a
1076   0A8C             ; putchar(digits[i]); 
1077   0A8C             ; --- START FUNCTION CALL
1078   0A8C FA F7 FF      lea d, [bp + -9] ; $digits
1079   0A8F D7            push a
1080   0A90 DA            push d
1081   0A91 FA F5 FF      lea d, [bp + -11] ; $i
1082   0A94 2A            mov b, [d]
1083   0A95 38 00 00      mov c, 0
1084   0A98 E7            pop d
1085   0A99 5A            add d, b
1086   0A9A E4            pop a
1087   0A9B 32            mov bl, [d]
1088   0A9C A7 00         mov bh, 0
1089   0A9E 38 00 00      mov c, 0
1090   0AA1 DD            push bl
1091   0AA2 07 AD 0A      call putchar
1092   0AA5 51 01 00      add sp, 1
1093   0AA8             ; --- END FUNCTION CALL
1094   0AA8 0A 63 0A      jmp _while19_cond
1095   0AAB             _while19_exit:
1096   0AAB F9            leave
1097   0AAC 09            ret
1098   0AAD             
1099   0AAD             putchar:
1100   0AAD F8 00 00      enter 0 ; (push bp; mov bp, sp)
1101   0AB0             ; --- BEGIN INLINE ASM SEGMENT
1102   0AB0 FA 05 00      lea d, [bp + 5] ; $c
1103   0AB3 1E            mov al, [d]
1104   0AB4 23            mov ah, al
1105   0AB5 19 00         mov al, 0
1106   0AB7 05 03         syscall sys_io      ; char in AH
1107   0AB9             ; --- END INLINE ASM SEGMENT
1108   0AB9 F9            leave
1109   0ABA 09            ret
1110   0ABB             
1111   0ABB             print_unsigned_long:
1112   0ABB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1113   0ABE             ; char digits[10]; 
1114   0ABE 52 0A 00      sub sp, 10
1115   0AC1             ; int i; 
1116   0AC1 52 02 00      sub sp, 2
1117   0AC4             ; i = 0; 
1118   0AC4 FA F5 FF      lea d, [bp + -11] ; $i
1119   0AC7 DA            push d
1120   0AC8 FD 2E 00 00   mov32 cb, $00000000
1120   0ACC 00 00 
1121   0ACE E7            pop d
1122   0ACF FD 43         mov [d], b
1123   0AD1             ; if(num == 0){ 
1124   0AD1             _if20_cond:
1125   0AD1 FA 05 00      lea d, [bp + 5] ; $num
1126   0AD4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1127   0AD7 FD 39         mov c, b ; And place it into C
1128   0AD9 2A            mov b, [d] ; Lower Word in B
1129   0ADA             ; --- START RELATIONAL
1130   0ADA D7            push a
1131   0ADB FD D8         push g
1132   0ADD 11            mov a, b
1133   0ADE FD 7A         mov g, c
1134   0AE0 FD 2E 00 00   mov32 cb, $00000000
1134   0AE4 00 00 
1135   0AE6 FD AF         cmp32 ga, cb
1136   0AE8 FD 71         seq ; ==
1137   0AEA FD F1         pop g
1138   0AEC E4            pop a
1139   0AED             ; --- END RELATIONAL
1140   0AED C0 00 00      cmp b, 0
1141   0AF0 C6 05 0B      je _if20_exit
1142   0AF3             _if20_TRUE:
1143   0AF3             ; putchar('0'); 
1144   0AF3             ; --- START FUNCTION CALL
1145   0AF3 FD 2E 30 00   mov32 cb, $00000030
1145   0AF7 00 00 
1146   0AF9 DD            push bl
1147   0AFA 07 AD 0A      call putchar
1148   0AFD 51 01 00      add sp, 1
1149   0B00             ; --- END FUNCTION CALL
1150   0B00             ; return; 
1151   0B00 F9            leave
1152   0B01 09            ret
1153   0B02 0A 05 0B      jmp _if20_exit
1154   0B05             _if20_exit:
1155   0B05             ; while (num > 0) { 
1156   0B05             _while21_cond:
1157   0B05 FA 05 00      lea d, [bp + 5] ; $num
1158   0B08 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1159   0B0B FD 39         mov c, b ; And place it into C
1160   0B0D 2A            mov b, [d] ; Lower Word in B
1161   0B0E             ; --- START RELATIONAL
1162   0B0E D7            push a
1163   0B0F FD D8         push g
1164   0B11 11            mov a, b
1165   0B12 FD 7A         mov g, c
1166   0B14 FD 2E 00 00   mov32 cb, $00000000
1166   0B18 00 00 
1167   0B1A FD AF         cmp32 ga, cb
1168   0B1C FD 81         sgu
1169   0B1E FD F1         pop g
1170   0B20 E4            pop a
1171   0B21             ; --- END RELATIONAL
1172   0B21 C0 00 00      cmp b, 0
1173   0B24 C6 A5 0B      je _while21_exit
1174   0B27             _while21_block:
1175   0B27             ; digits[i] = '0' + (num % 10); 
1176   0B27 FA F7 FF      lea d, [bp + -9] ; $digits
1177   0B2A D7            push a
1178   0B2B DA            push d
1179   0B2C FA F5 FF      lea d, [bp + -11] ; $i
1180   0B2F 2A            mov b, [d]
1181   0B30 38 00 00      mov c, 0
1182   0B33 E7            pop d
1183   0B34 5A            add d, b
1184   0B35 E4            pop a
1185   0B36 DA            push d
1186   0B37 FD 2E 30 00   mov32 cb, $00000030
1186   0B3B 00 00 
1187   0B3D             ; --- START TERMS
1188   0B3D D7            push a
1189   0B3E 11            mov a, b
1190   0B3F FA 05 00      lea d, [bp + 5] ; $num
1191   0B42 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1192   0B45 FD 39         mov c, b ; And place it into C
1193   0B47 2A            mov b, [d] ; Lower Word in B
1194   0B48             ; --- START FACTORS
1195   0B48 D7            push a
1196   0B49 FD D8         push g
1197   0B4B 11            mov a, b
1198   0B4C FD 7A         mov g, c
1199   0B4E FD 2E 0A 00   mov32 cb, $0000000a
1199   0B52 00 00 
1200   0B54 FD D8         push g ; save 'g' as the div instruction uses it
1201   0B56 AE            div a, b ; %, a: quotient, b: remainder
1202   0B57 11            mov a, b
1203   0B58 FD F1         pop g
1204   0B5A FD 38         mov c, g
1205   0B5C 27            mov b, a
1206   0B5D FD F1         pop g
1207   0B5F E4            pop a
1208   0B60             ; --- END FACTORS
1209   0B60 FD 15         add32 cb, ga
1210   0B62 E4            pop a
1211   0B63             ; --- END TERMS
1212   0B63 E7            pop d
1213   0B64 FD 3E         mov [d], bl
1214   0B66             ; num = num / 10; 
1215   0B66 FA 05 00      lea d, [bp + 5] ; $num
1216   0B69 DA            push d
1217   0B6A FA 05 00      lea d, [bp + 5] ; $num
1218   0B6D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1219   0B70 FD 39         mov c, b ; And place it into C
1220   0B72 2A            mov b, [d] ; Lower Word in B
1221   0B73             ; --- START FACTORS
1222   0B73 D7            push a
1223   0B74 FD D8         push g
1224   0B76 11            mov a, b
1225   0B77 FD 7A         mov g, c
1226   0B79 FD 2E 0A 00   mov32 cb, $0000000a
1226   0B7D 00 00 
1227   0B7F FD D8         push g ; save 'g' as the div instruction uses it
1228   0B81 AE            div a, b ; /, a: quotient, b: remainder
1229   0B82 FD F1         pop g
1230   0B84 FD 38         mov c, g
1231   0B86 27            mov b, a
1232   0B87 FD F1         pop g
1233   0B89 E4            pop a
1234   0B8A             ; --- END FACTORS
1235   0B8A E7            pop d
1236   0B8B FD 43         mov [d], b
1237   0B8D 28            mov b, c
1238   0B8E FD 44 02 00   mov [d + 2], b
1239   0B92             ; i++; 
1240   0B92 FA F5 FF      lea d, [bp + -11] ; $i
1241   0B95 2A            mov b, [d]
1242   0B96 38 00 00      mov c, 0
1243   0B99 11            mov a, b
1244   0B9A FD 77         inc b
1245   0B9C FA F5 FF      lea d, [bp + -11] ; $i
1246   0B9F FD 43         mov [d], b
1247   0BA1 27            mov b, a
1248   0BA2 0A 05 0B      jmp _while21_cond
1249   0BA5             _while21_exit:
1250   0BA5             ; while (i > 0) { 
1251   0BA5             _while28_cond:
1252   0BA5 FA F5 FF      lea d, [bp + -11] ; $i
1253   0BA8 2A            mov b, [d]
1254   0BA9 38 00 00      mov c, 0
1255   0BAC             ; --- START RELATIONAL
1256   0BAC D7            push a
1257   0BAD 11            mov a, b
1258   0BAE FD 2E 00 00   mov32 cb, $00000000
1258   0BB2 00 00 
1259   0BB4 B0            cmp a, b
1260   0BB5 FD 7F         sgt ; >
1261   0BB7 E4            pop a
1262   0BB8             ; --- END RELATIONAL
1263   0BB8 C0 00 00      cmp b, 0
1264   0BBB C6 ED 0B      je _while28_exit
1265   0BBE             _while28_block:
1266   0BBE             ; i--; 
1267   0BBE FA F5 FF      lea d, [bp + -11] ; $i
1268   0BC1 2A            mov b, [d]
1269   0BC2 38 00 00      mov c, 0
1270   0BC5 11            mov a, b
1271   0BC6 FD 7D         dec b
1272   0BC8 FA F5 FF      lea d, [bp + -11] ; $i
1273   0BCB FD 43         mov [d], b
1274   0BCD 27            mov b, a
1275   0BCE             ; putchar(digits[i]); 
1276   0BCE             ; --- START FUNCTION CALL
1277   0BCE FA F7 FF      lea d, [bp + -9] ; $digits
1278   0BD1 D7            push a
1279   0BD2 DA            push d
1280   0BD3 FA F5 FF      lea d, [bp + -11] ; $i
1281   0BD6 2A            mov b, [d]
1282   0BD7 38 00 00      mov c, 0
1283   0BDA E7            pop d
1284   0BDB 5A            add d, b
1285   0BDC E4            pop a
1286   0BDD 32            mov bl, [d]
1287   0BDE A7 00         mov bh, 0
1288   0BE0 38 00 00      mov c, 0
1289   0BE3 DD            push bl
1290   0BE4 07 AD 0A      call putchar
1291   0BE7 51 01 00      add sp, 1
1292   0BEA             ; --- END FUNCTION CALL
1293   0BEA 0A A5 0B      jmp _while28_cond
1294   0BED             _while28_exit:
1295   0BED F9            leave
1296   0BEE 09            ret
1297   0BEF             
1298   0BEF             printx32:
1299   0BEF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1300   0BF2             ; --- BEGIN INLINE ASM SEGMENT
1301   0BF2 FA 05 00      lea d, [bp + 5] ; $hex
1302   0BF5 2B 02 00      mov b, [d+2]
1303   0BF8 07 01 0C      call print_u16x_printx32
1304   0BFB 2A            mov b, [d]
1305   0BFC 07 01 0C      call print_u16x_printx32
1306   0BFF             ; --- END INLINE ASM SEGMENT
1307   0BFF             ; return; 
1308   0BFF F9            leave
1309   0C00 09            ret
1310   0C01             ; --- BEGIN INLINE ASM SEGMENT
1311   0C01             print_u16x_printx32:
1312   0C01 D7            push a
1313   0C02 D8            push b
1314   0C03 DD            push bl
1315   0C04 30            mov bl, bh
1316   0C05 07 23 0C      call _itoa_printx32        ; convert bh to char in A
1317   0C08 2F            mov bl, al        ; save al
1318   0C09 19 00         mov al, 0
1319   0C0B 05 03         syscall sys_io        ; display AH
1320   0C0D 24            mov ah, bl        ; retrieve al
1321   0C0E 19 00         mov al, 0
1322   0C10 05 03         syscall sys_io        ; display AL
1323   0C12 EA            pop bl
1324   0C13 07 23 0C      call _itoa_printx32        ; convert bh to char in A
1325   0C16 2F            mov bl, al        ; save al
1326   0C17 19 00         mov al, 0
1327   0C19 05 03         syscall sys_io        ; display AH
1328   0C1B 24            mov ah, bl        ; retrieve al
1329   0C1C 19 00         mov al, 0
1330   0C1E 05 03         syscall sys_io        ; display AL
1331   0C20 E5            pop b
1332   0C21 E4            pop a
1333   0C22 09            ret
1334   0C23             _itoa_printx32:
1335   0C23 DA            push d
1336   0C24 D8            push b
1337   0C25 A7 00         mov bh, 0
1338   0C27 FD A4 04      shr bl, 4  
1339   0C2A 74            mov d, b
1340   0C2B 1F 3D 0C      mov al, [d + s_hex_digits_printx32]
1341   0C2E 23            mov ah, al
1342   0C2F E5            pop b
1343   0C30 D8            push b
1344   0C31 A7 00         mov bh, 0
1345   0C33 FD 87 0F      and bl, $0F
1346   0C36 74            mov d, b
1347   0C37 1F 3D 0C      mov al, [d + s_hex_digits_printx32]
1348   0C3A E5            pop b
1349   0C3B E7            pop d
1350   0C3C 09            ret
1351   0C3D 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1351   0C41 34 35 36 37 
1351   0C45 38 39 41 42 
1351   0C49 43 44 45 46 
1352   0C4D             ; --- END INLINE ASM SEGMENT
1353   0C4D F9            leave
1354   0C4E 09            ret
1355   0C4F             
1356   0C4F             err:
1357   0C4F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1358   0C52             ; print(e); 
1359   0C52             ; --- START FUNCTION CALL
1360   0C52 FA 05 00      lea d, [bp + 5] ; $e
1361   0C55 2A            mov b, [d]
1362   0C56 38 00 00      mov c, 0
1363   0C59 FD AB         swp b
1364   0C5B D8            push b
1365   0C5C 07 64 0C      call print
1366   0C5F 51 02 00      add sp, 2
1367   0C62             ; --- END FUNCTION CALL
1368   0C62 F9            leave
1369   0C63 09            ret
1370   0C64             
1371   0C64             print:
1372   0C64 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1373   0C67             ; --- BEGIN INLINE ASM SEGMENT
1374   0C67 FA 05 00      lea d, [bp + 5] ; $s
1375   0C6A FD 2A         mov d, [d]
1376   0C6C             _puts_L1_print:
1377   0C6C 1E            mov al, [d]
1378   0C6D B9 00         cmp al, 0
1379   0C6F C6 7B 0C      jz _puts_END_print
1380   0C72 23            mov ah, al
1381   0C73 19 00         mov al, 0
1382   0C75 05 03         syscall sys_io
1383   0C77 79            inc d
1384   0C78 0A 6C 0C      jmp _puts_L1_print
1385   0C7B             _puts_END_print:
1386   0C7B             ; --- END INLINE ASM SEGMENT
1387   0C7B F9            leave
1388   0C7C 09            ret
1389   0C7D             
1390   0C7D             print_signed:
1391   0C7D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1392   0C80             ; char digits[5]; 
1393   0C80 52 05 00      sub sp, 5
1394   0C83             ; int i = 0; 
1395   0C83 52 02 00      sub sp, 2
1396   0C86             ; --- START LOCAL VAR INITIALIZATION
1397   0C86 FA FA FF      lea d, [bp + -6] ; $i
1398   0C89 DA            push d
1399   0C8A FD 2E 00 00   mov32 cb, $00000000
1399   0C8E 00 00 
1400   0C90 E7            pop d
1401   0C91 FD 43         mov [d], b
1402   0C93             ; --- END LOCAL VAR INITIALIZATION
1403   0C93             ; if (num < 0) { 
1404   0C93             _if29_cond:
1405   0C93 FA 05 00      lea d, [bp + 5] ; $num
1406   0C96 2A            mov b, [d]
1407   0C97 38 00 00      mov c, 0
1408   0C9A             ; --- START RELATIONAL
1409   0C9A D7            push a
1410   0C9B 11            mov a, b
1411   0C9C FD 2E 00 00   mov32 cb, $00000000
1411   0CA0 00 00 
1412   0CA2 B0            cmp a, b
1413   0CA3 FD 73         slt ; < (signed)
1414   0CA5 E4            pop a
1415   0CA6             ; --- END RELATIONAL
1416   0CA6 C0 00 00      cmp b, 0
1417   0CA9 C6 CC 0C      je _if29_else
1418   0CAC             _if29_TRUE:
1419   0CAC             ; putchar('-'); 
1420   0CAC             ; --- START FUNCTION CALL
1421   0CAC FD 2E 2D 00   mov32 cb, $0000002d
1421   0CB0 00 00 
1422   0CB2 DD            push bl
1423   0CB3 07 AD 0A      call putchar
1424   0CB6 51 01 00      add sp, 1
1425   0CB9             ; --- END FUNCTION CALL
1426   0CB9             ; num = -num; 
1427   0CB9 FA 05 00      lea d, [bp + 5] ; $num
1428   0CBC DA            push d
1429   0CBD FA 05 00      lea d, [bp + 5] ; $num
1430   0CC0 2A            mov b, [d]
1431   0CC1 38 00 00      mov c, 0
1432   0CC4 FD 97         neg b
1433   0CC6 E7            pop d
1434   0CC7 FD 43         mov [d], b
1435   0CC9 0A F7 0C      jmp _if29_exit
1436   0CCC             _if29_else:
1437   0CCC             ; if (num == 0) { 
1438   0CCC             _if30_cond:
1439   0CCC FA 05 00      lea d, [bp + 5] ; $num
1440   0CCF 2A            mov b, [d]
1441   0CD0 38 00 00      mov c, 0
1442   0CD3             ; --- START RELATIONAL
1443   0CD3 D7            push a
1444   0CD4 11            mov a, b
1445   0CD5 FD 2E 00 00   mov32 cb, $00000000
1445   0CD9 00 00 
1446   0CDB B0            cmp a, b
1447   0CDC FD 71         seq ; ==
1448   0CDE E4            pop a
1449   0CDF             ; --- END RELATIONAL
1450   0CDF C0 00 00      cmp b, 0
1451   0CE2 C6 F7 0C      je _if30_exit
1452   0CE5             _if30_TRUE:
1453   0CE5             ; putchar('0'); 
1454   0CE5             ; --- START FUNCTION CALL
1455   0CE5 FD 2E 30 00   mov32 cb, $00000030
1455   0CE9 00 00 
1456   0CEB DD            push bl
1457   0CEC 07 AD 0A      call putchar
1458   0CEF 51 01 00      add sp, 1
1459   0CF2             ; --- END FUNCTION CALL
1460   0CF2             ; return; 
1461   0CF2 F9            leave
1462   0CF3 09            ret
1463   0CF4 0A F7 0C      jmp _if30_exit
1464   0CF7             _if30_exit:
1465   0CF7             _if29_exit:
1466   0CF7             ; while (num > 0) { 
1467   0CF7             _while31_cond:
1468   0CF7 FA 05 00      lea d, [bp + 5] ; $num
1469   0CFA 2A            mov b, [d]
1470   0CFB 38 00 00      mov c, 0
1471   0CFE             ; --- START RELATIONAL
1472   0CFE D7            push a
1473   0CFF 11            mov a, b
1474   0D00 FD 2E 00 00   mov32 cb, $00000000
1474   0D04 00 00 
1475   0D06 B0            cmp a, b
1476   0D07 FD 7F         sgt ; >
1477   0D09 E4            pop a
1478   0D0A             ; --- END RELATIONAL
1479   0D0A C0 00 00      cmp b, 0
1480   0D0D C6 84 0D      je _while31_exit
1481   0D10             _while31_block:
1482   0D10             ; digits[i] = '0' + (num % 10); 
1483   0D10 FA FC FF      lea d, [bp + -4] ; $digits
1484   0D13 D7            push a
1485   0D14 DA            push d
1486   0D15 FA FA FF      lea d, [bp + -6] ; $i
1487   0D18 2A            mov b, [d]
1488   0D19 38 00 00      mov c, 0
1489   0D1C E7            pop d
1490   0D1D 5A            add d, b
1491   0D1E E4            pop a
1492   0D1F DA            push d
1493   0D20 FD 2E 30 00   mov32 cb, $00000030
1493   0D24 00 00 
1494   0D26             ; --- START TERMS
1495   0D26 D7            push a
1496   0D27 11            mov a, b
1497   0D28 FA 05 00      lea d, [bp + 5] ; $num
1498   0D2B 2A            mov b, [d]
1499   0D2C 38 00 00      mov c, 0
1500   0D2F             ; --- START FACTORS
1501   0D2F D7            push a
1502   0D30 FD D8         push g
1503   0D32 11            mov a, b
1504   0D33 FD 7A         mov g, c
1505   0D35 FD 2E 0A 00   mov32 cb, $0000000a
1505   0D39 00 00 
1506   0D3B FD D8         push g ; save 'g' as the div instruction uses it
1507   0D3D AE            div a, b ; %, a: quotient, b: remainder
1508   0D3E 11            mov a, b
1509   0D3F FD F1         pop g
1510   0D41 FD 38         mov c, g
1511   0D43 27            mov b, a
1512   0D44 FD F1         pop g
1513   0D46 E4            pop a
1514   0D47             ; --- END FACTORS
1515   0D47 56            add b, a
1516   0D48 E4            pop a
1517   0D49             ; --- END TERMS
1518   0D49 E7            pop d
1519   0D4A FD 3E         mov [d], bl
1520   0D4C             ; num = num / 10; 
1521   0D4C FA 05 00      lea d, [bp + 5] ; $num
1522   0D4F DA            push d
1523   0D50 FA 05 00      lea d, [bp + 5] ; $num
1524   0D53 2A            mov b, [d]
1525   0D54 38 00 00      mov c, 0
1526   0D57             ; --- START FACTORS
1527   0D57 D7            push a
1528   0D58 FD D8         push g
1529   0D5A 11            mov a, b
1530   0D5B FD 7A         mov g, c
1531   0D5D FD 2E 0A 00   mov32 cb, $0000000a
1531   0D61 00 00 
1532   0D63 FD D8         push g ; save 'g' as the div instruction uses it
1533   0D65 AE            div a, b ; /, a: quotient, b: remainder
1534   0D66 FD F1         pop g
1535   0D68 FD 38         mov c, g
1536   0D6A 27            mov b, a
1537   0D6B FD F1         pop g
1538   0D6D E4            pop a
1539   0D6E             ; --- END FACTORS
1540   0D6E E7            pop d
1541   0D6F FD 43         mov [d], b
1542   0D71             ; i++; 
1543   0D71 FA FA FF      lea d, [bp + -6] ; $i
1544   0D74 2A            mov b, [d]
1545   0D75 38 00 00      mov c, 0
1546   0D78 11            mov a, b
1547   0D79 FD 77         inc b
1548   0D7B FA FA FF      lea d, [bp + -6] ; $i
1549   0D7E FD 43         mov [d], b
1550   0D80 27            mov b, a
1551   0D81 0A F7 0C      jmp _while31_cond
1552   0D84             _while31_exit:
1553   0D84             ; while (i > 0) { 
1554   0D84             _while38_cond:
1555   0D84 FA FA FF      lea d, [bp + -6] ; $i
1556   0D87 2A            mov b, [d]
1557   0D88 38 00 00      mov c, 0
1558   0D8B             ; --- START RELATIONAL
1559   0D8B D7            push a
1560   0D8C 11            mov a, b
1561   0D8D FD 2E 00 00   mov32 cb, $00000000
1561   0D91 00 00 
1562   0D93 B0            cmp a, b
1563   0D94 FD 7F         sgt ; >
1564   0D96 E4            pop a
1565   0D97             ; --- END RELATIONAL
1566   0D97 C0 00 00      cmp b, 0
1567   0D9A C6 CC 0D      je _while38_exit
1568   0D9D             _while38_block:
1569   0D9D             ; i--; 
1570   0D9D FA FA FF      lea d, [bp + -6] ; $i
1571   0DA0 2A            mov b, [d]
1572   0DA1 38 00 00      mov c, 0
1573   0DA4 11            mov a, b
1574   0DA5 FD 7D         dec b
1575   0DA7 FA FA FF      lea d, [bp + -6] ; $i
1576   0DAA FD 43         mov [d], b
1577   0DAC 27            mov b, a
1578   0DAD             ; putchar(digits[i]); 
1579   0DAD             ; --- START FUNCTION CALL
1580   0DAD FA FC FF      lea d, [bp + -4] ; $digits
1581   0DB0 D7            push a
1582   0DB1 DA            push d
1583   0DB2 FA FA FF      lea d, [bp + -6] ; $i
1584   0DB5 2A            mov b, [d]
1585   0DB6 38 00 00      mov c, 0
1586   0DB9 E7            pop d
1587   0DBA 5A            add d, b
1588   0DBB E4            pop a
1589   0DBC 32            mov bl, [d]
1590   0DBD A7 00         mov bh, 0
1591   0DBF 38 00 00      mov c, 0
1592   0DC2 DD            push bl
1593   0DC3 07 AD 0A      call putchar
1594   0DC6 51 01 00      add sp, 1
1595   0DC9             ; --- END FUNCTION CALL
1596   0DC9 0A 84 0D      jmp _while38_cond
1597   0DCC             _while38_exit:
1598   0DCC F9            leave
1599   0DCD 09            ret
1600   0DCE             
1601   0DCE             print_unsigned:
1602   0DCE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1603   0DD1             ; char digits[5]; 
1604   0DD1 52 05 00      sub sp, 5
1605   0DD4             ; int i; 
1606   0DD4 52 02 00      sub sp, 2
1607   0DD7             ; i = 0; 
1608   0DD7 FA FA FF      lea d, [bp + -6] ; $i
1609   0DDA DA            push d
1610   0DDB FD 2E 00 00   mov32 cb, $00000000
1610   0DDF 00 00 
1611   0DE1 E7            pop d
1612   0DE2 FD 43         mov [d], b
1613   0DE4             ; if(num == 0){ 
1614   0DE4             _if39_cond:
1615   0DE4 FA 05 00      lea d, [bp + 5] ; $num
1616   0DE7 2A            mov b, [d]
1617   0DE8 38 00 00      mov c, 0
1618   0DEB             ; --- START RELATIONAL
1619   0DEB D7            push a
1620   0DEC 11            mov a, b
1621   0DED FD 2E 00 00   mov32 cb, $00000000
1621   0DF1 00 00 
1622   0DF3 B0            cmp a, b
1623   0DF4 FD 71         seq ; ==
1624   0DF6 E4            pop a
1625   0DF7             ; --- END RELATIONAL
1626   0DF7 C0 00 00      cmp b, 0
1627   0DFA C6 0F 0E      je _if39_exit
1628   0DFD             _if39_TRUE:
1629   0DFD             ; putchar('0'); 
1630   0DFD             ; --- START FUNCTION CALL
1631   0DFD FD 2E 30 00   mov32 cb, $00000030
1631   0E01 00 00 
1632   0E03 DD            push bl
1633   0E04 07 AD 0A      call putchar
1634   0E07 51 01 00      add sp, 1
1635   0E0A             ; --- END FUNCTION CALL
1636   0E0A             ; return; 
1637   0E0A F9            leave
1638   0E0B 09            ret
1639   0E0C 0A 0F 0E      jmp _if39_exit
1640   0E0F             _if39_exit:
1641   0E0F             ; while (num > 0) { 
1642   0E0F             _while40_cond:
1643   0E0F FA 05 00      lea d, [bp + 5] ; $num
1644   0E12 2A            mov b, [d]
1645   0E13 38 00 00      mov c, 0
1646   0E16             ; --- START RELATIONAL
1647   0E16 D7            push a
1648   0E17 11            mov a, b
1649   0E18 FD 2E 00 00   mov32 cb, $00000000
1649   0E1C 00 00 
1650   0E1E B0            cmp a, b
1651   0E1F FD 81         sgu ; > (unsigned)
1652   0E21 E4            pop a
1653   0E22             ; --- END RELATIONAL
1654   0E22 C0 00 00      cmp b, 0
1655   0E25 C6 9C 0E      je _while40_exit
1656   0E28             _while40_block:
1657   0E28             ; digits[i] = '0' + (num % 10); 
1658   0E28 FA FC FF      lea d, [bp + -4] ; $digits
1659   0E2B D7            push a
1660   0E2C DA            push d
1661   0E2D FA FA FF      lea d, [bp + -6] ; $i
1662   0E30 2A            mov b, [d]
1663   0E31 38 00 00      mov c, 0
1664   0E34 E7            pop d
1665   0E35 5A            add d, b
1666   0E36 E4            pop a
1667   0E37 DA            push d
1668   0E38 FD 2E 30 00   mov32 cb, $00000030
1668   0E3C 00 00 
1669   0E3E             ; --- START TERMS
1670   0E3E D7            push a
1671   0E3F 11            mov a, b
1672   0E40 FA 05 00      lea d, [bp + 5] ; $num
1673   0E43 2A            mov b, [d]
1674   0E44 38 00 00      mov c, 0
1675   0E47             ; --- START FACTORS
1676   0E47 D7            push a
1677   0E48 FD D8         push g
1678   0E4A 11            mov a, b
1679   0E4B FD 7A         mov g, c
1680   0E4D FD 2E 0A 00   mov32 cb, $0000000a
1680   0E51 00 00 
1681   0E53 FD D8         push g ; save 'g' as the div instruction uses it
1682   0E55 AE            div a, b ; %, a: quotient, b: remainder
1683   0E56 11            mov a, b
1684   0E57 FD F1         pop g
1685   0E59 FD 38         mov c, g
1686   0E5B 27            mov b, a
1687   0E5C FD F1         pop g
1688   0E5E E4            pop a
1689   0E5F             ; --- END FACTORS
1690   0E5F 56            add b, a
1691   0E60 E4            pop a
1692   0E61             ; --- END TERMS
1693   0E61 E7            pop d
1694   0E62 FD 3E         mov [d], bl
1695   0E64             ; num = num / 10; 
1696   0E64 FA 05 00      lea d, [bp + 5] ; $num
1697   0E67 DA            push d
1698   0E68 FA 05 00      lea d, [bp + 5] ; $num
1699   0E6B 2A            mov b, [d]
1700   0E6C 38 00 00      mov c, 0
1701   0E6F             ; --- START FACTORS
1702   0E6F D7            push a
1703   0E70 FD D8         push g
1704   0E72 11            mov a, b
1705   0E73 FD 7A         mov g, c
1706   0E75 FD 2E 0A 00   mov32 cb, $0000000a
1706   0E79 00 00 
1707   0E7B FD D8         push g ; save 'g' as the div instruction uses it
1708   0E7D AE            div a, b ; /, a: quotient, b: remainder
1709   0E7E FD F1         pop g
1710   0E80 FD 38         mov c, g
1711   0E82 27            mov b, a
1712   0E83 FD F1         pop g
1713   0E85 E4            pop a
1714   0E86             ; --- END FACTORS
1715   0E86 E7            pop d
1716   0E87 FD 43         mov [d], b
1717   0E89             ; i++; 
1718   0E89 FA FA FF      lea d, [bp + -6] ; $i
1719   0E8C 2A            mov b, [d]
1720   0E8D 38 00 00      mov c, 0
1721   0E90 11            mov a, b
1722   0E91 FD 77         inc b
1723   0E93 FA FA FF      lea d, [bp + -6] ; $i
1724   0E96 FD 43         mov [d], b
1725   0E98 27            mov b, a
1726   0E99 0A 0F 0E      jmp _while40_cond
1727   0E9C             _while40_exit:
1728   0E9C             ; while (i > 0) { 
1729   0E9C             _while47_cond:
1730   0E9C FA FA FF      lea d, [bp + -6] ; $i
1731   0E9F 2A            mov b, [d]
1732   0EA0 38 00 00      mov c, 0
1733   0EA3             ; --- START RELATIONAL
1734   0EA3 D7            push a
1735   0EA4 11            mov a, b
1736   0EA5 FD 2E 00 00   mov32 cb, $00000000
1736   0EA9 00 00 
1737   0EAB B0            cmp a, b
1738   0EAC FD 7F         sgt ; >
1739   0EAE E4            pop a
1740   0EAF             ; --- END RELATIONAL
1741   0EAF C0 00 00      cmp b, 0
1742   0EB2 C6 E4 0E      je _while47_exit
1743   0EB5             _while47_block:
1744   0EB5             ; i--; 
1745   0EB5 FA FA FF      lea d, [bp + -6] ; $i
1746   0EB8 2A            mov b, [d]
1747   0EB9 38 00 00      mov c, 0
1748   0EBC 11            mov a, b
1749   0EBD FD 7D         dec b
1750   0EBF FA FA FF      lea d, [bp + -6] ; $i
1751   0EC2 FD 43         mov [d], b
1752   0EC4 27            mov b, a
1753   0EC5             ; putchar(digits[i]); 
1754   0EC5             ; --- START FUNCTION CALL
1755   0EC5 FA FC FF      lea d, [bp + -4] ; $digits
1756   0EC8 D7            push a
1757   0EC9 DA            push d
1758   0ECA FA FA FF      lea d, [bp + -6] ; $i
1759   0ECD 2A            mov b, [d]
1760   0ECE 38 00 00      mov c, 0
1761   0ED1 E7            pop d
1762   0ED2 5A            add d, b
1763   0ED3 E4            pop a
1764   0ED4 32            mov bl, [d]
1765   0ED5 A7 00         mov bh, 0
1766   0ED7 38 00 00      mov c, 0
1767   0EDA DD            push bl
1768   0EDB 07 AD 0A      call putchar
1769   0EDE 51 01 00      add sp, 1
1770   0EE1             ; --- END FUNCTION CALL
1771   0EE1 0A 9C 0E      jmp _while47_cond
1772   0EE4             _while47_exit:
1773   0EE4 F9            leave
1774   0EE5 09            ret
1775   0EE6             
1776   0EE6             printx16:
1777   0EE6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1778   0EE9             ; --- BEGIN INLINE ASM SEGMENT
1779   0EE9 FA 05 00      lea d, [bp + 5] ; $hex
1780   0EEC 2A            mov b, [d]
1781   0EED             print_u16x_printx16:
1782   0EED DD            push bl
1783   0EEE 30            mov bl, bh
1784   0EEF 07 0C 0F      call _itoa_printx16        ; convert bh to char in A
1785   0EF2 2F            mov bl, al        ; save al
1786   0EF3 19 00         mov al, 0
1787   0EF5 05 03         syscall sys_io        ; display AH
1788   0EF7 24            mov ah, bl        ; retrieve al
1789   0EF8 19 00         mov al, 0
1790   0EFA 05 03         syscall sys_io        ; display AL
1791   0EFC EA            pop bl
1792   0EFD 07 0C 0F      call _itoa_printx16        ; convert bh to char in A
1793   0F00 2F            mov bl, al        ; save al
1794   0F01 19 00         mov al, 0
1795   0F03 05 03         syscall sys_io        ; display AH
1796   0F05 24            mov ah, bl        ; retrieve al
1797   0F06 19 00         mov al, 0
1798   0F08 05 03         syscall sys_io        ; display AL
1799   0F0A             ; --- END INLINE ASM SEGMENT
1800   0F0A             ; return; 
1801   0F0A F9            leave
1802   0F0B 09            ret
1803   0F0C             ; --- BEGIN INLINE ASM SEGMENT
1804   0F0C             _itoa_printx16:
1805   0F0C DA            push d
1806   0F0D D8            push b
1807   0F0E A7 00         mov bh, 0
1808   0F10 FD A4 04      shr bl, 4  
1809   0F13 74            mov d, b
1810   0F14 1F 26 0F      mov al, [d + s_hex_digits_printx16]
1811   0F17 23            mov ah, al
1812   0F18 E5            pop b
1813   0F19 D8            push b
1814   0F1A A7 00         mov bh, 0
1815   0F1C FD 87 0F      and bl, $0F
1816   0F1F 74            mov d, b
1817   0F20 1F 26 0F      mov al, [d + s_hex_digits_printx16]
1818   0F23 E5            pop b
1819   0F24 E7            pop d
1820   0F25 09            ret
1821   0F26 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1821   0F2A 34 35 36 37 
1821   0F2E 38 39 41 42 
1821   0F32 43 44 45 46 
1822   0F36             ; --- END INLINE ASM SEGMENT
1823   0F36 F9            leave
1824   0F37 09            ret
1825   0F38             
1826   0F38             getchar:
1827   0F38 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1828   0F3B             ; char c; 
1829   0F3B 52 01 00      sub sp, 1
1830   0F3E             ; --- BEGIN INLINE ASM SEGMENT
1831   0F3E 19 01         mov al, 1
1832   0F40 05 03         syscall sys_io      ; receive in AH
1833   0F42 1A            mov al, ah
1834   0F43 FA 00 00      lea d, [bp + 0] ; $c
1835   0F46 3E            mov [d], al
1836   0F47             ; --- END INLINE ASM SEGMENT
1837   0F47             ; return c; 
1838   0F47 FA 00 00      lea d, [bp + 0] ; $c
1839   0F4A 32            mov bl, [d]
1840   0F4B A7 00         mov bh, 0
1841   0F4D 38 00 00      mov c, 0
1842   0F50 F9            leave
1843   0F51 09            ret
1844   0F52             ; --- END TEXT SEGMENT
1845   0F52             
1846   0F52             ; --- BEGIN DATA SEGMENT
1847   0F52 54 65 73 74 _s0: .db "Test of 5.25 inch Floppy Drive Interface.\n", 0
1847   0F56 20 6F 66 20 
1847   0F5A 35 2E 32 35 
1847   0F5E 20 69 6E 63 
1847   0F62 68 20 46 6C 
1847   0F66 6F 70 70 79 
1847   0F6A 20 44 72 69 
1847   0F6E 76 65 20 49 
1847   0F72 6E 74 65 72 
1847   0F76 66 61 63 65 
1847   0F7A 2E 0A 00 
1848   0F7D 30 2E 20 73 _s1: .db "0. select drive 0\n", 0
1848   0F81 65 6C 65 63 
1848   0F85 74 20 64 72 
1848   0F89 69 76 65 20 
1848   0F8D 30 0A 00 
1849   0F90 31 2E 20 73 _s2: .db "1. select drive 1\n", 0
1849   0F94 65 6C 65 63 
1849   0F98 74 20 64 72 
1849   0F9C 69 76 65 20 
1849   0FA0 31 0A 00 
1850   0FA3 66 2E 20 66 _s3: .db "f. format\n", 0
1850   0FA7 6F 72 6D 61 
1850   0FAB 74 0A 00 
1851   0FAE 61 2E 20 73 _s4: .db "a. set reset bit and select drive 0\n", 0
1851   0FB2 65 74 20 72 
1851   0FB6 65 73 65 74 
1851   0FBA 20 62 69 74 
1851   0FBE 20 61 6E 64 
1851   0FC2 20 73 65 6C 
1851   0FC6 65 63 74 20 
1851   0FCA 64 72 69 76 
1851   0FCE 65 20 30 0A 
1851   0FD2 00 
1852   0FD3 62 2E 20 63 _s5: .db "b. clear reset bit, and select drive 0\n", 0
1852   0FD7 6C 65 61 72 
1852   0FDB 20 72 65 73 
1852   0FDF 65 74 20 62 
1852   0FE3 69 74 2C 20 
1852   0FE7 61 6E 64 20 
1852   0FEB 73 65 6C 65 
1852   0FEF 63 74 20 64 
1852   0FF3 72 69 76 65 
1852   0FF7 20 30 0A 00 
1853   0FFB 77 2E 20 77 _s6: .db "w. write 16 to data register\n", 0
1853   0FFF 72 69 74 65 
1853   1003 20 31 36 20 
1853   1007 74 6F 20 64 
1853   100B 61 74 61 20 
1853   100F 72 65 67 69 
1853   1013 73 74 65 72 
1853   1017 0A 00 
1854   1019 64 2E 20 72 _s7: .db "d. read data register\n", 0
1854   101D 65 61 64 20 
1854   1021 64 61 74 61 
1854   1025 20 72 65 67 
1854   1029 69 73 74 65 
1854   102D 72 0A 00 
1855   1030 74 2E 20 72 _s8: .db "t. read track register\n", 0
1855   1034 65 61 64 20 
1855   1038 74 72 61 63 
1855   103C 6B 20 72 65 
1855   1040 67 69 73 74 
1855   1044 65 72 0A 00 
1856   1048 73 2E 20 73 _s9: .db "s. step\n", 0
1856   104C 74 65 70 0A 
1856   1050 00 
1857   1051 6B 2E 20 73 _s10: .db "k. seek\n", 0
1857   1055 65 65 6B 0A 
1857   1059 00 
1858   105A 72 2E 20 72 _s11: .db "r. restore\n", 0
1858   105E 65 73 74 6F 
1858   1062 72 65 0A 00 
1859   1066 69 2E 20 73 _s12: .db "i. step in\n", 0
1859   106A 74 65 70 20 
1859   106E 69 6E 0A 00 
1860   1072 6F 2E 20 73 _s13: .db "o. step out\n", 0
1860   1076 74 65 70 20 
1860   107A 6F 75 74 0A 
1860   107E 00 
1861   107F 65 2E 20 65 _s14: .db "e. exit\n", 0
1861   1083 78 69 74 0A 
1861   1087 00 
1862   1088 71 2E 20 72 _s15: .db "q. read pending irq status register\n", 0
1862   108C 65 61 64 20 
1862   1090 70 65 6E 64 
1862   1094 69 6E 67 20 
1862   1098 69 72 71 20 
1862   109C 73 74 61 74 
1862   10A0 75 73 20 72 
1862   10A4 65 67 69 73 
1862   10A8 74 65 72 0A 
1862   10AC 00 
1863   10AD 0A 4F 70 74 _s16: .db "\nOption: ", 0
1863   10B1 69 6F 6E 3A 
1863   10B5 20 00 
1864   10B7 0A 44 61 74 _s17: .db "\nData register value: %d\n", 0
1864   10BB 61 20 72 65 
1864   10BF 67 69 73 74 
1864   10C3 65 72 20 76 
1864   10C7 61 6C 75 65 
1864   10CB 3A 20 25 64 
1864   10CF 0A 00 
1865   10D1 0A 54 72 61 _s18: .db "\nTrack register value: %d\n", 0
1865   10D5 63 6B 20 72 
1865   10D9 65 67 69 73 
1865   10DD 74 65 72 20 
1865   10E1 76 61 6C 75 
1865   10E5 65 3A 20 25 
1865   10E9 64 0A 00 
1866   10EC 0A 4D 61 73 _s19: .db "\nMasks: %x\n", 0
1866   10F0 6B 73 3A 20 
1866   10F4 25 78 0A 00 
1867   10F8 55 6E 65 78 _s20: .db "Unexpected format in printf.", 0
1867   10FC 70 65 63 74 
1867   1100 65 64 20 66 
1867   1104 6F 72 6D 61 
1867   1108 74 20 69 6E 
1867   110C 20 70 72 69 
1867   1110 6E 74 66 2E 
1867   1114 00 
1868   1115 45 72 72 6F _s21: .db "Error: Unknown argument type.\n", 0
1868   1119 72 3A 20 55 
1868   111D 6E 6B 6E 6F 
1868   1121 77 6E 20 61 
1868   1125 72 67 75 6D 
1868   1129 65 6E 74 20 
1868   112D 74 79 70 65 
1868   1131 2E 0A 00 
1869   1134             
1870   1134 36 11       _heap_top: .dw _heap
1871   1136 00          _heap: .db 0
1872   1137             ; --- END DATA SEGMENT
1873   1137             
1874   1137             .end
tasm: Number of errors = 0
