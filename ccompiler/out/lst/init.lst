0001   0000             ; --- FILENAME: ../solarium/sbin/init.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; printf("init process started.\n\r"); 
0011   0408             ; --- START FUNCTION CALL
0012   0408 26 38 0D      mov b, _s0 ; "init process started.\n\r"
0013   040B FD AB         swp b
0014   040D D8            push b
0015   040E 07 29 04      call printf
0016   0411 51 02 00      add sp, 2
0017   0414             ; --- END FUNCTION CALL
0018   0414             ; printf("starting shell...\n\r"); 
0019   0414             ; --- START FUNCTION CALL
0020   0414 26 50 0D      mov b, _s1 ; "starting shell...\n\r"
0021   0417 FD AB         swp b
0022   0419 D8            push b
0023   041A 07 29 04      call printf
0024   041D 51 02 00      add sp, 2
0025   0420             ; --- END FUNCTION CALL
0026   0420             ; --- BEGIN INLINE ASM SEGMENT
0027   0420 3B 36 0D      mov d, _shell_path ; $shell_path
0028   0423 FD 2A         mov d, [d]
0029   0425 05 05         syscall sys_spawn_proc
0030   0427             ; --- END INLINE ASM SEGMENT
0031   0427 05 0B         syscall sys_terminate_proc
0032   0429             
0033   0429             printf:
0034   0429 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0035   042C             ; char *p, *format_p; 
0036   042C 52 02 00      sub sp, 2
0037   042F 52 02 00      sub sp, 2
0038   0432             ; format_p = format; 
0039   0432 FA FD FF      lea d, [bp + -3] ; $format_p
0040   0435 DA            push d
0041   0436 FA 05 00      lea d, [bp + 5] ; $format
0042   0439 2A            mov b, [d]
0043   043A 38 00 00      mov c, 0
0044   043D E7            pop d
0045   043E FD 43         mov [d], b
0046   0440             ; p = &format + 2; 
0047   0440 FA FF FF      lea d, [bp + -1] ; $p
0048   0443 DA            push d
0049   0444 FA 05 00      lea d, [bp + 5] ; $format
0050   0447 2D            mov b, d
0051   0448             ; --- START TERMS
0052   0448 D7            push a
0053   0449 11            mov a, b
0054   044A FD 2E 02 00   mov32 cb, $00000002
0054   044E 00 00 
0055   0450 56            add b, a
0056   0451 E4            pop a
0057   0452             ; --- END TERMS
0058   0452 E7            pop d
0059   0453 FD 43         mov [d], b
0060   0455             ; for(;;){ 
0061   0455             _for1_init:
0062   0455             _for1_cond:
0063   0455             _for1_block:
0064   0455             ; if(!*format_p) break; 
0065   0455             _if2_cond:
0066   0455 FA FD FF      lea d, [bp + -3] ; $format_p
0067   0458 2A            mov b, [d]
0068   0459 38 00 00      mov c, 0
0069   045C 74            mov d, b
0070   045D 32            mov bl, [d]
0071   045E A7 00         mov bh, 0
0072   0460 38 00 00      mov c, 0
0073   0463 C0 00 00      cmp b, 0
0074   0466 FD 71         seq ; !
0075   0468 C0 00 00      cmp b, 0
0076   046B C6 74 04      je _if2_else
0077   046E             _if2_TRUE:
0078   046E             ; break; 
0079   046E 0A 14 07      jmp _for1_exit ; for break
0080   0471 0A 01 07      jmp _if2_exit
0081   0474             _if2_else:
0082   0474             ; if(*format_p == '%'){ 
0083   0474             _if3_cond:
0084   0474 FA FD FF      lea d, [bp + -3] ; $format_p
0085   0477 2A            mov b, [d]
0086   0478 38 00 00      mov c, 0
0087   047B 74            mov d, b
0088   047C 32            mov bl, [d]
0089   047D A7 00         mov bh, 0
0090   047F 38 00 00      mov c, 0
0091   0482             ; --- START RELATIONAL
0092   0482 D7            push a
0093   0483 11            mov a, b
0094   0484 FD 2E 25 00   mov32 cb, $00000025
0094   0488 00 00 
0095   048A B0            cmp a, b
0096   048B FD 71         seq ; ==
0097   048D E4            pop a
0098   048E             ; --- END RELATIONAL
0099   048E C0 00 00      cmp b, 0
0100   0491 C6 EC 06      je _if3_else
0101   0494             _if3_TRUE:
0102   0494             ; format_p++; 
0103   0494 FA FD FF      lea d, [bp + -3] ; $format_p
0104   0497 2A            mov b, [d]
0105   0498 38 00 00      mov c, 0
0106   049B FD 77         inc b
0107   049D FA FD FF      lea d, [bp + -3] ; $format_p
0108   04A0 FD 43         mov [d], b
0109   04A2 FD 7D         dec b
0110   04A4             ; switch(*format_p){ 
0111   04A4             _switch4_expr:
0112   04A4 FA FD FF      lea d, [bp + -3] ; $format_p
0113   04A7 2A            mov b, [d]
0114   04A8 38 00 00      mov c, 0
0115   04AB 74            mov d, b
0116   04AC 32            mov bl, [d]
0117   04AD A7 00         mov bh, 0
0118   04AF 38 00 00      mov c, 0
0119   04B2             _switch4_comparisons:
0120   04B2 C1 6C         cmp bl, $6c
0121   04B4 C6 E0 04      je _switch4_case0
0122   04B7 C1 4C         cmp bl, $4c
0123   04B9 C6 E0 04      je _switch4_case1
0124   04BC C1 64         cmp bl, $64
0125   04BE C6 F0 05      je _switch4_case2
0126   04C1 C1 69         cmp bl, $69
0127   04C3 C6 F0 05      je _switch4_case3
0128   04C6 C1 75         cmp bl, $75
0129   04C8 C6 20 06      je _switch4_case4
0130   04CB C1 78         cmp bl, $78
0131   04CD C6 50 06      je _switch4_case5
0132   04D0 C1 63         cmp bl, $63
0133   04D2 C6 80 06      je _switch4_case6
0134   04D5 C1 73         cmp bl, $73
0135   04D7 C6 B0 06      je _switch4_case7
0136   04DA 0A DD 06      jmp _switch4_default
0137   04DD 0A E9 06      jmp _switch4_exit
0138   04E0             _switch4_case0:
0139   04E0             _switch4_case1:
0140   04E0             ; format_p++; 
0141   04E0 FA FD FF      lea d, [bp + -3] ; $format_p
0142   04E3 2A            mov b, [d]
0143   04E4 38 00 00      mov c, 0
0144   04E7 FD 77         inc b
0145   04E9 FA FD FF      lea d, [bp + -3] ; $format_p
0146   04EC FD 43         mov [d], b
0147   04EE FD 7D         dec b
0148   04F0             ; if(*format_p == 'd' || *format_p == 'i') 
0149   04F0             _if5_cond:
0150   04F0 FA FD FF      lea d, [bp + -3] ; $format_p
0151   04F3 2A            mov b, [d]
0152   04F4 38 00 00      mov c, 0
0153   04F7 74            mov d, b
0154   04F8 32            mov bl, [d]
0155   04F9 A7 00         mov bh, 0
0156   04FB 38 00 00      mov c, 0
0157   04FE             ; --- START RELATIONAL
0158   04FE D7            push a
0159   04FF 11            mov a, b
0160   0500 FD 2E 64 00   mov32 cb, $00000064
0160   0504 00 00 
0161   0506 B0            cmp a, b
0162   0507 FD 71         seq ; ==
0163   0509 E4            pop a
0164   050A             ; --- END RELATIONAL
0165   050A             ; --- START LOGICAL OR
0166   050A D7            push a
0167   050B 11            mov a, b
0168   050C FA FD FF      lea d, [bp + -3] ; $format_p
0169   050F 2A            mov b, [d]
0170   0510 38 00 00      mov c, 0
0171   0513 74            mov d, b
0172   0514 32            mov bl, [d]
0173   0515 A7 00         mov bh, 0
0174   0517 38 00 00      mov c, 0
0175   051A             ; --- START RELATIONAL
0176   051A D7            push a
0177   051B 11            mov a, b
0178   051C FD 2E 69 00   mov32 cb, $00000069
0178   0520 00 00 
0179   0522 B0            cmp a, b
0180   0523 FD 71         seq ; ==
0181   0525 E4            pop a
0182   0526             ; --- END RELATIONAL
0183   0526 FD A8         sor a, b ; ||
0184   0528 E4            pop a
0185   0529             ; --- END LOGICAL OR
0186   0529 C0 00 00      cmp b, 0
0187   052C C6 4D 05      je _if5_else
0188   052F             _if5_TRUE:
0189   052F             ; print_signed_long(*(long *)p); 
0190   052F             ; --- START FUNCTION CALL
0191   052F FA FF FF      lea d, [bp + -1] ; $p
0192   0532 2A            mov b, [d]
0193   0533 38 00 00      mov c, 0
0194   0536 74            mov d, b
0195   0537 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0196   053A FD 39         mov c, b ; And place it into C
0197   053C 2A            mov b, [d] ; Lower Word in B
0198   053D 12            mov a, c
0199   053E FD AA         swp a
0200   0540 D7            push a
0201   0541 FD AB         swp b
0202   0543 D8            push b
0203   0544 07 16 07      call print_signed_long
0204   0547 51 04 00      add sp, 4
0205   054A             ; --- END FUNCTION CALL
0206   054A 0A D5 05      jmp _if5_exit
0207   054D             _if5_else:
0208   054D             ; if(*format_p == 'u') 
0209   054D             _if6_cond:
0210   054D FA FD FF      lea d, [bp + -3] ; $format_p
0211   0550 2A            mov b, [d]
0212   0551 38 00 00      mov c, 0
0213   0554 74            mov d, b
0214   0555 32            mov bl, [d]
0215   0556 A7 00         mov bh, 0
0216   0558 38 00 00      mov c, 0
0217   055B             ; --- START RELATIONAL
0218   055B D7            push a
0219   055C 11            mov a, b
0220   055D FD 2E 75 00   mov32 cb, $00000075
0220   0561 00 00 
0221   0563 B0            cmp a, b
0222   0564 FD 71         seq ; ==
0223   0566 E4            pop a
0224   0567             ; --- END RELATIONAL
0225   0567 C0 00 00      cmp b, 0
0226   056A C6 8B 05      je _if6_else
0227   056D             _if6_TRUE:
0228   056D             ; print_unsigned_long(*(unsigned long *)p); 
0229   056D             ; --- START FUNCTION CALL
0230   056D FA FF FF      lea d, [bp + -1] ; $p
0231   0570 2A            mov b, [d]
0232   0571 38 00 00      mov c, 0
0233   0574 74            mov d, b
0234   0575 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0235   0578 FD 39         mov c, b ; And place it into C
0236   057A 2A            mov b, [d] ; Lower Word in B
0237   057B 12            mov a, c
0238   057C FD AA         swp a
0239   057E D7            push a
0240   057F FD AB         swp b
0241   0581 D8            push b
0242   0582 07 A9 08      call print_unsigned_long
0243   0585 51 04 00      add sp, 4
0244   0588             ; --- END FUNCTION CALL
0245   0588 0A D5 05      jmp _if6_exit
0246   058B             _if6_else:
0247   058B             ; if(*format_p == 'x') 
0248   058B             _if7_cond:
0249   058B FA FD FF      lea d, [bp + -3] ; $format_p
0250   058E 2A            mov b, [d]
0251   058F 38 00 00      mov c, 0
0252   0592 74            mov d, b
0253   0593 32            mov bl, [d]
0254   0594 A7 00         mov bh, 0
0255   0596 38 00 00      mov c, 0
0256   0599             ; --- START RELATIONAL
0257   0599 D7            push a
0258   059A 11            mov a, b
0259   059B FD 2E 78 00   mov32 cb, $00000078
0259   059F 00 00 
0260   05A1 B0            cmp a, b
0261   05A2 FD 71         seq ; ==
0262   05A4 E4            pop a
0263   05A5             ; --- END RELATIONAL
0264   05A5 C0 00 00      cmp b, 0
0265   05A8 C6 C9 05      je _if7_else
0266   05AB             _if7_TRUE:
0267   05AB             ; printx32(*(long int *)p); 
0268   05AB             ; --- START FUNCTION CALL
0269   05AB FA FF FF      lea d, [bp + -1] ; $p
0270   05AE 2A            mov b, [d]
0271   05AF 38 00 00      mov c, 0
0272   05B2 74            mov d, b
0273   05B3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0274   05B6 FD 39         mov c, b ; And place it into C
0275   05B8 2A            mov b, [d] ; Lower Word in B
0276   05B9 12            mov a, c
0277   05BA FD AA         swp a
0278   05BC D7            push a
0279   05BD FD AB         swp b
0280   05BF D8            push b
0281   05C0 07 DD 09      call printx32
0282   05C3 51 04 00      add sp, 4
0283   05C6             ; --- END FUNCTION CALL
0284   05C6 0A D5 05      jmp _if7_exit
0285   05C9             _if7_else:
0286   05C9             ; err("Unexpected format in printf."); 
0287   05C9             ; --- START FUNCTION CALL
0288   05C9 26 64 0D      mov b, _s2 ; "Unexpected format in printf."
0289   05CC FD AB         swp b
0290   05CE D8            push b
0291   05CF 07 3D 0A      call err
0292   05D2 51 02 00      add sp, 2
0293   05D5             ; --- END FUNCTION CALL
0294   05D5             _if7_exit:
0295   05D5             _if6_exit:
0296   05D5             _if5_exit:
0297   05D5             ; p = p + 4; 
0298   05D5 FA FF FF      lea d, [bp + -1] ; $p
0299   05D8 DA            push d
0300   05D9 FA FF FF      lea d, [bp + -1] ; $p
0301   05DC 2A            mov b, [d]
0302   05DD 38 00 00      mov c, 0
0303   05E0             ; --- START TERMS
0304   05E0 D7            push a
0305   05E1 11            mov a, b
0306   05E2 FD 2E 04 00   mov32 cb, $00000004
0306   05E6 00 00 
0307   05E8 56            add b, a
0308   05E9 E4            pop a
0309   05EA             ; --- END TERMS
0310   05EA E7            pop d
0311   05EB FD 43         mov [d], b
0312   05ED             ; break; 
0313   05ED 0A E9 06      jmp _switch4_exit ; case break
0314   05F0             _switch4_case2:
0315   05F0             _switch4_case3:
0316   05F0             ; print_signed(*(int*)p); 
0317   05F0             ; --- START FUNCTION CALL
0318   05F0 FA FF FF      lea d, [bp + -1] ; $p
0319   05F3 2A            mov b, [d]
0320   05F4 38 00 00      mov c, 0
0321   05F7 74            mov d, b
0322   05F8 2A            mov b, [d]
0323   05F9 38 00 00      mov c, 0
0324   05FC FD AB         swp b
0325   05FE D8            push b
0326   05FF 07 6B 0A      call print_signed
0327   0602 51 02 00      add sp, 2
0328   0605             ; --- END FUNCTION CALL
0329   0605             ; p = p + 2; 
0330   0605 FA FF FF      lea d, [bp + -1] ; $p
0331   0608 DA            push d
0332   0609 FA FF FF      lea d, [bp + -1] ; $p
0333   060C 2A            mov b, [d]
0334   060D 38 00 00      mov c, 0
0335   0610             ; --- START TERMS
0336   0610 D7            push a
0337   0611 11            mov a, b
0338   0612 FD 2E 02 00   mov32 cb, $00000002
0338   0616 00 00 
0339   0618 56            add b, a
0340   0619 E4            pop a
0341   061A             ; --- END TERMS
0342   061A E7            pop d
0343   061B FD 43         mov [d], b
0344   061D             ; break; 
0345   061D 0A E9 06      jmp _switch4_exit ; case break
0346   0620             _switch4_case4:
0347   0620             ; print_unsigned(*(unsigned int*)p); 
0348   0620             ; --- START FUNCTION CALL
0349   0620 FA FF FF      lea d, [bp + -1] ; $p
0350   0623 2A            mov b, [d]
0351   0624 38 00 00      mov c, 0
0352   0627 74            mov d, b
0353   0628 2A            mov b, [d]
0354   0629 38 00 00      mov c, 0
0355   062C FD AB         swp b
0356   062E D8            push b
0357   062F 07 BC 0B      call print_unsigned
0358   0632 51 02 00      add sp, 2
0359   0635             ; --- END FUNCTION CALL
0360   0635             ; p = p + 2; 
0361   0635 FA FF FF      lea d, [bp + -1] ; $p
0362   0638 DA            push d
0363   0639 FA FF FF      lea d, [bp + -1] ; $p
0364   063C 2A            mov b, [d]
0365   063D 38 00 00      mov c, 0
0366   0640             ; --- START TERMS
0367   0640 D7            push a
0368   0641 11            mov a, b
0369   0642 FD 2E 02 00   mov32 cb, $00000002
0369   0646 00 00 
0370   0648 56            add b, a
0371   0649 E4            pop a
0372   064A             ; --- END TERMS
0373   064A E7            pop d
0374   064B FD 43         mov [d], b
0375   064D             ; break; 
0376   064D 0A E9 06      jmp _switch4_exit ; case break
0377   0650             _switch4_case5:
0378   0650             ; printx16(*(int*)p); 
0379   0650             ; --- START FUNCTION CALL
0380   0650 FA FF FF      lea d, [bp + -1] ; $p
0381   0653 2A            mov b, [d]
0382   0654 38 00 00      mov c, 0
0383   0657 74            mov d, b
0384   0658 2A            mov b, [d]
0385   0659 38 00 00      mov c, 0
0386   065C FD AB         swp b
0387   065E D8            push b
0388   065F 07 D4 0C      call printx16
0389   0662 51 02 00      add sp, 2
0390   0665             ; --- END FUNCTION CALL
0391   0665             ; p = p + 2; 
0392   0665 FA FF FF      lea d, [bp + -1] ; $p
0393   0668 DA            push d
0394   0669 FA FF FF      lea d, [bp + -1] ; $p
0395   066C 2A            mov b, [d]
0396   066D 38 00 00      mov c, 0
0397   0670             ; --- START TERMS
0398   0670 D7            push a
0399   0671 11            mov a, b
0400   0672 FD 2E 02 00   mov32 cb, $00000002
0400   0676 00 00 
0401   0678 56            add b, a
0402   0679 E4            pop a
0403   067A             ; --- END TERMS
0404   067A E7            pop d
0405   067B FD 43         mov [d], b
0406   067D             ; break; 
0407   067D 0A E9 06      jmp _switch4_exit ; case break
0408   0680             _switch4_case6:
0409   0680             ; putchar(*(char*)p); 
0410   0680             ; --- START FUNCTION CALL
0411   0680 FA FF FF      lea d, [bp + -1] ; $p
0412   0683 2A            mov b, [d]
0413   0684 38 00 00      mov c, 0
0414   0687 74            mov d, b
0415   0688 32            mov bl, [d]
0416   0689 A7 00         mov bh, 0
0417   068B 38 00 00      mov c, 0
0418   068E DD            push bl
0419   068F 07 9B 08      call putchar
0420   0692 51 01 00      add sp, 1
0421   0695             ; --- END FUNCTION CALL
0422   0695             ; p = p + 2; 
0423   0695 FA FF FF      lea d, [bp + -1] ; $p
0424   0698 DA            push d
0425   0699 FA FF FF      lea d, [bp + -1] ; $p
0426   069C 2A            mov b, [d]
0427   069D 38 00 00      mov c, 0
0428   06A0             ; --- START TERMS
0429   06A0 D7            push a
0430   06A1 11            mov a, b
0431   06A2 FD 2E 02 00   mov32 cb, $00000002
0431   06A6 00 00 
0432   06A8 56            add b, a
0433   06A9 E4            pop a
0434   06AA             ; --- END TERMS
0435   06AA E7            pop d
0436   06AB FD 43         mov [d], b
0437   06AD             ; break; 
0438   06AD 0A E9 06      jmp _switch4_exit ; case break
0439   06B0             _switch4_case7:
0440   06B0             ; print(*(char**)p); 
0441   06B0             ; --- START FUNCTION CALL
0442   06B0 FA FF FF      lea d, [bp + -1] ; $p
0443   06B3 2A            mov b, [d]
0444   06B4 38 00 00      mov c, 0
0445   06B7 74            mov d, b
0446   06B8 2A            mov b, [d]
0447   06B9 FD AB         swp b
0448   06BB D8            push b
0449   06BC 07 52 0A      call print
0450   06BF 51 02 00      add sp, 2
0451   06C2             ; --- END FUNCTION CALL
0452   06C2             ; p = p + 2; 
0453   06C2 FA FF FF      lea d, [bp + -1] ; $p
0454   06C5 DA            push d
0455   06C6 FA FF FF      lea d, [bp + -1] ; $p
0456   06C9 2A            mov b, [d]
0457   06CA 38 00 00      mov c, 0
0458   06CD             ; --- START TERMS
0459   06CD D7            push a
0460   06CE 11            mov a, b
0461   06CF FD 2E 02 00   mov32 cb, $00000002
0461   06D3 00 00 
0462   06D5 56            add b, a
0463   06D6 E4            pop a
0464   06D7             ; --- END TERMS
0465   06D7 E7            pop d
0466   06D8 FD 43         mov [d], b
0467   06DA             ; break; 
0468   06DA 0A E9 06      jmp _switch4_exit ; case break
0469   06DD             _switch4_default:
0470   06DD             ; print("Error: Unknown argument type.\n"); 
0471   06DD             ; --- START FUNCTION CALL
0472   06DD 26 81 0D      mov b, _s3 ; "Error: Unknown argument type.\n"
0473   06E0 FD AB         swp b
0474   06E2 D8            push b
0475   06E3 07 52 0A      call print
0476   06E6 51 02 00      add sp, 2
0477   06E9             ; --- END FUNCTION CALL
0478   06E9             _switch4_exit:
0479   06E9 0A 01 07      jmp _if3_exit
0480   06EC             _if3_else:
0481   06EC             ; putchar(*format_p); 
0482   06EC             ; --- START FUNCTION CALL
0483   06EC FA FD FF      lea d, [bp + -3] ; $format_p
0484   06EF 2A            mov b, [d]
0485   06F0 38 00 00      mov c, 0
0486   06F3 74            mov d, b
0487   06F4 32            mov bl, [d]
0488   06F5 A7 00         mov bh, 0
0489   06F7 38 00 00      mov c, 0
0490   06FA DD            push bl
0491   06FB 07 9B 08      call putchar
0492   06FE 51 01 00      add sp, 1
0493   0701             ; --- END FUNCTION CALL
0494   0701             _if3_exit:
0495   0701             _if2_exit:
0496   0701             ; format_p++; 
0497   0701 FA FD FF      lea d, [bp + -3] ; $format_p
0498   0704 2A            mov b, [d]
0499   0705 38 00 00      mov c, 0
0500   0708 FD 77         inc b
0501   070A FA FD FF      lea d, [bp + -3] ; $format_p
0502   070D FD 43         mov [d], b
0503   070F FD 7D         dec b
0504   0711             _for1_update:
0505   0711 0A 55 04      jmp _for1_cond
0506   0714             _for1_exit:
0507   0714 F9            leave
0508   0715 09            ret
0509   0716             
0510   0716             print_signed_long:
0511   0716 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0512   0719             ; char digits[10]; 
0513   0719 52 0A 00      sub sp, 10
0514   071C             ; int i = 0; 
0515   071C 52 02 00      sub sp, 2
0516   071F             ; --- START LOCAL VAR INITIALIZATION
0517   071F FA F5 FF      lea d, [bp + -11] ; $i
0518   0722 DA            push d
0519   0723 FD 2E 00 00   mov32 cb, $00000000
0519   0727 00 00 
0520   0729 E7            pop d
0521   072A FD 43         mov [d], b
0522   072C             ; --- END LOCAL VAR INITIALIZATION
0523   072C             ; if (num < 0) { 
0524   072C             _if8_cond:
0525   072C FA 05 00      lea d, [bp + 5] ; $num
0526   072F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0527   0732 FD 39         mov c, b ; And place it into C
0528   0734 2A            mov b, [d] ; Lower Word in B
0529   0735             ; --- START RELATIONAL
0530   0735 D7            push a
0531   0736 FD D8         push g
0532   0738 11            mov a, b
0533   0739 FD 7A         mov g, c
0534   073B FD 2E 00 00   mov32 cb, $00000000
0534   073F 00 00 
0535   0741 FD AF         cmp32 ga, cb
0536   0743 FD 73         slt ; <
0537   0745 FD F1         pop g
0538   0747 E4            pop a
0539   0748             ; --- END RELATIONAL
0540   0748 C0 00 00      cmp b, 0
0541   074B C6 7D 07      je _if8_else
0542   074E             _if8_TRUE:
0543   074E             ; putchar('-'); 
0544   074E             ; --- START FUNCTION CALL
0545   074E FD 2E 2D 00   mov32 cb, $0000002d
0545   0752 00 00 
0546   0754 DD            push bl
0547   0755 07 9B 08      call putchar
0548   0758 51 01 00      add sp, 1
0549   075B             ; --- END FUNCTION CALL
0550   075B             ; num = -num; 
0551   075B FA 05 00      lea d, [bp + 5] ; $num
0552   075E DA            push d
0553   075F FA 05 00      lea d, [bp + 5] ; $num
0554   0762 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0555   0765 FD 39         mov c, b ; And place it into C
0556   0767 2A            mov b, [d] ; Lower Word in B
0557   0768 12            mov a, c
0558   0769 95            not a
0559   076A 97            not b
0560   076B 55 01 00      add b, 1
0561   076E 5B 00 00      adc a, 0
0562   0771 39            mov c, a
0563   0772 E7            pop d
0564   0773 FD 43         mov [d], b
0565   0775 28            mov b, c
0566   0776 FD 44 02 00   mov [d + 2], b
0567   077A 0A B1 07      jmp _if8_exit
0568   077D             _if8_else:
0569   077D             ; if (num == 0) { 
0570   077D             _if9_cond:
0571   077D FA 05 00      lea d, [bp + 5] ; $num
0572   0780 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0573   0783 FD 39         mov c, b ; And place it into C
0574   0785 2A            mov b, [d] ; Lower Word in B
0575   0786             ; --- START RELATIONAL
0576   0786 D7            push a
0577   0787 FD D8         push g
0578   0789 11            mov a, b
0579   078A FD 7A         mov g, c
0580   078C FD 2E 00 00   mov32 cb, $00000000
0580   0790 00 00 
0581   0792 FD AF         cmp32 ga, cb
0582   0794 FD 71         seq ; ==
0583   0796 FD F1         pop g
0584   0798 E4            pop a
0585   0799             ; --- END RELATIONAL
0586   0799 C0 00 00      cmp b, 0
0587   079C C6 B1 07      je _if9_exit
0588   079F             _if9_TRUE:
0589   079F             ; putchar('0'); 
0590   079F             ; --- START FUNCTION CALL
0591   079F FD 2E 30 00   mov32 cb, $00000030
0591   07A3 00 00 
0592   07A5 DD            push bl
0593   07A6 07 9B 08      call putchar
0594   07A9 51 01 00      add sp, 1
0595   07AC             ; --- END FUNCTION CALL
0596   07AC             ; return; 
0597   07AC F9            leave
0598   07AD 09            ret
0599   07AE 0A B1 07      jmp _if9_exit
0600   07B1             _if9_exit:
0601   07B1             _if8_exit:
0602   07B1             ; while (num > 0) { 
0603   07B1             _while10_cond:
0604   07B1 FA 05 00      lea d, [bp + 5] ; $num
0605   07B4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0606   07B7 FD 39         mov c, b ; And place it into C
0607   07B9 2A            mov b, [d] ; Lower Word in B
0608   07BA             ; --- START RELATIONAL
0609   07BA D7            push a
0610   07BB FD D8         push g
0611   07BD 11            mov a, b
0612   07BE FD 7A         mov g, c
0613   07C0 FD 2E 00 00   mov32 cb, $00000000
0613   07C4 00 00 
0614   07C6 FD AF         cmp32 ga, cb
0615   07C8 FD 7F         sgt
0616   07CA FD F1         pop g
0617   07CC E4            pop a
0618   07CD             ; --- END RELATIONAL
0619   07CD C0 00 00      cmp b, 0
0620   07D0 C6 51 08      je _while10_exit
0621   07D3             _while10_block:
0622   07D3             ; digits[i] = '0' + (num % 10); 
0623   07D3 FA F7 FF      lea d, [bp + -9] ; $digits
0624   07D6 D7            push a
0625   07D7 DA            push d
0626   07D8 FA F5 FF      lea d, [bp + -11] ; $i
0627   07DB 2A            mov b, [d]
0628   07DC 38 00 00      mov c, 0
0629   07DF E7            pop d
0630   07E0 5A            add d, b
0631   07E1 E4            pop a
0632   07E2 DA            push d
0633   07E3 FD 2E 30 00   mov32 cb, $00000030
0633   07E7 00 00 
0634   07E9             ; --- START TERMS
0635   07E9 D7            push a
0636   07EA 11            mov a, b
0637   07EB FA 05 00      lea d, [bp + 5] ; $num
0638   07EE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0639   07F1 FD 39         mov c, b ; And place it into C
0640   07F3 2A            mov b, [d] ; Lower Word in B
0641   07F4             ; --- START FACTORS
0642   07F4 D7            push a
0643   07F5 FD D8         push g
0644   07F7 11            mov a, b
0645   07F8 FD 7A         mov g, c
0646   07FA FD 2E 0A 00   mov32 cb, $0000000a
0646   07FE 00 00 
0647   0800 FD D8         push g ; save 'g' as the div instruction uses it
0648   0802 AE            div a, b ; %, a: quotient, b: remainder
0649   0803 11            mov a, b
0650   0804 FD F1         pop g
0651   0806 FD 38         mov c, g
0652   0808 27            mov b, a
0653   0809 FD F1         pop g
0654   080B E4            pop a
0655   080C             ; --- END FACTORS
0656   080C FD 15         add32 cb, ga
0657   080E E4            pop a
0658   080F             ; --- END TERMS
0659   080F E7            pop d
0660   0810 FD 3E         mov [d], bl
0661   0812             ; num = num / 10; 
0662   0812 FA 05 00      lea d, [bp + 5] ; $num
0663   0815 DA            push d
0664   0816 FA 05 00      lea d, [bp + 5] ; $num
0665   0819 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0666   081C FD 39         mov c, b ; And place it into C
0667   081E 2A            mov b, [d] ; Lower Word in B
0668   081F             ; --- START FACTORS
0669   081F D7            push a
0670   0820 FD D8         push g
0671   0822 11            mov a, b
0672   0823 FD 7A         mov g, c
0673   0825 FD 2E 0A 00   mov32 cb, $0000000a
0673   0829 00 00 
0674   082B FD D8         push g ; save 'g' as the div instruction uses it
0675   082D AE            div a, b ; /, a: quotient, b: remainder
0676   082E FD F1         pop g
0677   0830 FD 38         mov c, g
0678   0832 27            mov b, a
0679   0833 FD F1         pop g
0680   0835 E4            pop a
0681   0836             ; --- END FACTORS
0682   0836 E7            pop d
0683   0837 FD 43         mov [d], b
0684   0839 28            mov b, c
0685   083A FD 44 02 00   mov [d + 2], b
0686   083E             ; i++; 
0687   083E FA F5 FF      lea d, [bp + -11] ; $i
0688   0841 2A            mov b, [d]
0689   0842 38 00 00      mov c, 0
0690   0845 11            mov a, b
0691   0846 FD 77         inc b
0692   0848 FA F5 FF      lea d, [bp + -11] ; $i
0693   084B FD 43         mov [d], b
0694   084D 27            mov b, a
0695   084E 0A B1 07      jmp _while10_cond
0696   0851             _while10_exit:
0697   0851             ; while (i > 0) { 
0698   0851             _while17_cond:
0699   0851 FA F5 FF      lea d, [bp + -11] ; $i
0700   0854 2A            mov b, [d]
0701   0855 38 00 00      mov c, 0
0702   0858             ; --- START RELATIONAL
0703   0858 D7            push a
0704   0859 11            mov a, b
0705   085A FD 2E 00 00   mov32 cb, $00000000
0705   085E 00 00 
0706   0860 B0            cmp a, b
0707   0861 FD 7F         sgt ; >
0708   0863 E4            pop a
0709   0864             ; --- END RELATIONAL
0710   0864 C0 00 00      cmp b, 0
0711   0867 C6 99 08      je _while17_exit
0712   086A             _while17_block:
0713   086A             ; i--; 
0714   086A FA F5 FF      lea d, [bp + -11] ; $i
0715   086D 2A            mov b, [d]
0716   086E 38 00 00      mov c, 0
0717   0871 11            mov a, b
0718   0872 FD 7D         dec b
0719   0874 FA F5 FF      lea d, [bp + -11] ; $i
0720   0877 FD 43         mov [d], b
0721   0879 27            mov b, a
0722   087A             ; putchar(digits[i]); 
0723   087A             ; --- START FUNCTION CALL
0724   087A FA F7 FF      lea d, [bp + -9] ; $digits
0725   087D D7            push a
0726   087E DA            push d
0727   087F FA F5 FF      lea d, [bp + -11] ; $i
0728   0882 2A            mov b, [d]
0729   0883 38 00 00      mov c, 0
0730   0886 E7            pop d
0731   0887 5A            add d, b
0732   0888 E4            pop a
0733   0889 32            mov bl, [d]
0734   088A A7 00         mov bh, 0
0735   088C 38 00 00      mov c, 0
0736   088F DD            push bl
0737   0890 07 9B 08      call putchar
0738   0893 51 01 00      add sp, 1
0739   0896             ; --- END FUNCTION CALL
0740   0896 0A 51 08      jmp _while17_cond
0741   0899             _while17_exit:
0742   0899 F9            leave
0743   089A 09            ret
0744   089B             
0745   089B             putchar:
0746   089B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0747   089E             ; --- BEGIN INLINE ASM SEGMENT
0748   089E FA 05 00      lea d, [bp + 5] ; $c
0749   08A1 1E            mov al, [d]
0750   08A2 23            mov ah, al
0751   08A3 19 00         mov al, 0
0752   08A5 05 03         syscall sys_io      ; char in AH
0753   08A7             ; --- END INLINE ASM SEGMENT
0754   08A7 F9            leave
0755   08A8 09            ret
0756   08A9             
0757   08A9             print_unsigned_long:
0758   08A9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0759   08AC             ; char digits[10]; 
0760   08AC 52 0A 00      sub sp, 10
0761   08AF             ; int i; 
0762   08AF 52 02 00      sub sp, 2
0763   08B2             ; i = 0; 
0764   08B2 FA F5 FF      lea d, [bp + -11] ; $i
0765   08B5 DA            push d
0766   08B6 FD 2E 00 00   mov32 cb, $00000000
0766   08BA 00 00 
0767   08BC E7            pop d
0768   08BD FD 43         mov [d], b
0769   08BF             ; if(num == 0){ 
0770   08BF             _if18_cond:
0771   08BF FA 05 00      lea d, [bp + 5] ; $num
0772   08C2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0773   08C5 FD 39         mov c, b ; And place it into C
0774   08C7 2A            mov b, [d] ; Lower Word in B
0775   08C8             ; --- START RELATIONAL
0776   08C8 D7            push a
0777   08C9 FD D8         push g
0778   08CB 11            mov a, b
0779   08CC FD 7A         mov g, c
0780   08CE FD 2E 00 00   mov32 cb, $00000000
0780   08D2 00 00 
0781   08D4 FD AF         cmp32 ga, cb
0782   08D6 FD 71         seq ; ==
0783   08D8 FD F1         pop g
0784   08DA E4            pop a
0785   08DB             ; --- END RELATIONAL
0786   08DB C0 00 00      cmp b, 0
0787   08DE C6 F3 08      je _if18_exit
0788   08E1             _if18_TRUE:
0789   08E1             ; putchar('0'); 
0790   08E1             ; --- START FUNCTION CALL
0791   08E1 FD 2E 30 00   mov32 cb, $00000030
0791   08E5 00 00 
0792   08E7 DD            push bl
0793   08E8 07 9B 08      call putchar
0794   08EB 51 01 00      add sp, 1
0795   08EE             ; --- END FUNCTION CALL
0796   08EE             ; return; 
0797   08EE F9            leave
0798   08EF 09            ret
0799   08F0 0A F3 08      jmp _if18_exit
0800   08F3             _if18_exit:
0801   08F3             ; while (num > 0) { 
0802   08F3             _while19_cond:
0803   08F3 FA 05 00      lea d, [bp + 5] ; $num
0804   08F6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0805   08F9 FD 39         mov c, b ; And place it into C
0806   08FB 2A            mov b, [d] ; Lower Word in B
0807   08FC             ; --- START RELATIONAL
0808   08FC D7            push a
0809   08FD FD D8         push g
0810   08FF 11            mov a, b
0811   0900 FD 7A         mov g, c
0812   0902 FD 2E 00 00   mov32 cb, $00000000
0812   0906 00 00 
0813   0908 FD AF         cmp32 ga, cb
0814   090A FD 81         sgu
0815   090C FD F1         pop g
0816   090E E4            pop a
0817   090F             ; --- END RELATIONAL
0818   090F C0 00 00      cmp b, 0
0819   0912 C6 93 09      je _while19_exit
0820   0915             _while19_block:
0821   0915             ; digits[i] = '0' + (num % 10); 
0822   0915 FA F7 FF      lea d, [bp + -9] ; $digits
0823   0918 D7            push a
0824   0919 DA            push d
0825   091A FA F5 FF      lea d, [bp + -11] ; $i
0826   091D 2A            mov b, [d]
0827   091E 38 00 00      mov c, 0
0828   0921 E7            pop d
0829   0922 5A            add d, b
0830   0923 E4            pop a
0831   0924 DA            push d
0832   0925 FD 2E 30 00   mov32 cb, $00000030
0832   0929 00 00 
0833   092B             ; --- START TERMS
0834   092B D7            push a
0835   092C 11            mov a, b
0836   092D FA 05 00      lea d, [bp + 5] ; $num
0837   0930 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0838   0933 FD 39         mov c, b ; And place it into C
0839   0935 2A            mov b, [d] ; Lower Word in B
0840   0936             ; --- START FACTORS
0841   0936 D7            push a
0842   0937 FD D8         push g
0843   0939 11            mov a, b
0844   093A FD 7A         mov g, c
0845   093C FD 2E 0A 00   mov32 cb, $0000000a
0845   0940 00 00 
0846   0942 FD D8         push g ; save 'g' as the div instruction uses it
0847   0944 AE            div a, b ; %, a: quotient, b: remainder
0848   0945 11            mov a, b
0849   0946 FD F1         pop g
0850   0948 FD 38         mov c, g
0851   094A 27            mov b, a
0852   094B FD F1         pop g
0853   094D E4            pop a
0854   094E             ; --- END FACTORS
0855   094E FD 15         add32 cb, ga
0856   0950 E4            pop a
0857   0951             ; --- END TERMS
0858   0951 E7            pop d
0859   0952 FD 3E         mov [d], bl
0860   0954             ; num = num / 10; 
0861   0954 FA 05 00      lea d, [bp + 5] ; $num
0862   0957 DA            push d
0863   0958 FA 05 00      lea d, [bp + 5] ; $num
0864   095B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0865   095E FD 39         mov c, b ; And place it into C
0866   0960 2A            mov b, [d] ; Lower Word in B
0867   0961             ; --- START FACTORS
0868   0961 D7            push a
0869   0962 FD D8         push g
0870   0964 11            mov a, b
0871   0965 FD 7A         mov g, c
0872   0967 FD 2E 0A 00   mov32 cb, $0000000a
0872   096B 00 00 
0873   096D FD D8         push g ; save 'g' as the div instruction uses it
0874   096F AE            div a, b ; /, a: quotient, b: remainder
0875   0970 FD F1         pop g
0876   0972 FD 38         mov c, g
0877   0974 27            mov b, a
0878   0975 FD F1         pop g
0879   0977 E4            pop a
0880   0978             ; --- END FACTORS
0881   0978 E7            pop d
0882   0979 FD 43         mov [d], b
0883   097B 28            mov b, c
0884   097C FD 44 02 00   mov [d + 2], b
0885   0980             ; i++; 
0886   0980 FA F5 FF      lea d, [bp + -11] ; $i
0887   0983 2A            mov b, [d]
0888   0984 38 00 00      mov c, 0
0889   0987 11            mov a, b
0890   0988 FD 77         inc b
0891   098A FA F5 FF      lea d, [bp + -11] ; $i
0892   098D FD 43         mov [d], b
0893   098F 27            mov b, a
0894   0990 0A F3 08      jmp _while19_cond
0895   0993             _while19_exit:
0896   0993             ; while (i > 0) { 
0897   0993             _while26_cond:
0898   0993 FA F5 FF      lea d, [bp + -11] ; $i
0899   0996 2A            mov b, [d]
0900   0997 38 00 00      mov c, 0
0901   099A             ; --- START RELATIONAL
0902   099A D7            push a
0903   099B 11            mov a, b
0904   099C FD 2E 00 00   mov32 cb, $00000000
0904   09A0 00 00 
0905   09A2 B0            cmp a, b
0906   09A3 FD 7F         sgt ; >
0907   09A5 E4            pop a
0908   09A6             ; --- END RELATIONAL
0909   09A6 C0 00 00      cmp b, 0
0910   09A9 C6 DB 09      je _while26_exit
0911   09AC             _while26_block:
0912   09AC             ; i--; 
0913   09AC FA F5 FF      lea d, [bp + -11] ; $i
0914   09AF 2A            mov b, [d]
0915   09B0 38 00 00      mov c, 0
0916   09B3 11            mov a, b
0917   09B4 FD 7D         dec b
0918   09B6 FA F5 FF      lea d, [bp + -11] ; $i
0919   09B9 FD 43         mov [d], b
0920   09BB 27            mov b, a
0921   09BC             ; putchar(digits[i]); 
0922   09BC             ; --- START FUNCTION CALL
0923   09BC FA F7 FF      lea d, [bp + -9] ; $digits
0924   09BF D7            push a
0925   09C0 DA            push d
0926   09C1 FA F5 FF      lea d, [bp + -11] ; $i
0927   09C4 2A            mov b, [d]
0928   09C5 38 00 00      mov c, 0
0929   09C8 E7            pop d
0930   09C9 5A            add d, b
0931   09CA E4            pop a
0932   09CB 32            mov bl, [d]
0933   09CC A7 00         mov bh, 0
0934   09CE 38 00 00      mov c, 0
0935   09D1 DD            push bl
0936   09D2 07 9B 08      call putchar
0937   09D5 51 01 00      add sp, 1
0938   09D8             ; --- END FUNCTION CALL
0939   09D8 0A 93 09      jmp _while26_cond
0940   09DB             _while26_exit:
0941   09DB F9            leave
0942   09DC 09            ret
0943   09DD             
0944   09DD             printx32:
0945   09DD F8 00 00      enter 0 ; (push bp; mov bp, sp)
0946   09E0             ; --- BEGIN INLINE ASM SEGMENT
0947   09E0 FA 05 00      lea d, [bp + 5] ; $hex
0948   09E3 2B 02 00      mov b, [d+2]
0949   09E6 07 EF 09      call print_u16x_printx32
0950   09E9 2A            mov b, [d]
0951   09EA 07 EF 09      call print_u16x_printx32
0952   09ED             ; --- END INLINE ASM SEGMENT
0953   09ED             ; return; 
0954   09ED F9            leave
0955   09EE 09            ret
0956   09EF             ; --- BEGIN INLINE ASM SEGMENT
0957   09EF             print_u16x_printx32:
0958   09EF D7            push a
0959   09F0 D8            push b
0960   09F1 DD            push bl
0961   09F2 30            mov bl, bh
0962   09F3 07 11 0A      call _itoa_printx32        ; convert bh to char in A
0963   09F6 2F            mov bl, al        ; save al
0964   09F7 19 00         mov al, 0
0965   09F9 05 03         syscall sys_io        ; display AH
0966   09FB 24            mov ah, bl        ; retrieve al
0967   09FC 19 00         mov al, 0
0968   09FE 05 03         syscall sys_io        ; display AL
0969   0A00 EA            pop bl
0970   0A01 07 11 0A      call _itoa_printx32        ; convert bh to char in A
0971   0A04 2F            mov bl, al        ; save al
0972   0A05 19 00         mov al, 0
0973   0A07 05 03         syscall sys_io        ; display AH
0974   0A09 24            mov ah, bl        ; retrieve al
0975   0A0A 19 00         mov al, 0
0976   0A0C 05 03         syscall sys_io        ; display AL
0977   0A0E E5            pop b
0978   0A0F E4            pop a
0979   0A10 09            ret
0980   0A11             _itoa_printx32:
0981   0A11 DA            push d
0982   0A12 D8            push b
0983   0A13 A7 00         mov bh, 0
0984   0A15 FD A4 04      shr bl, 4  
0985   0A18 74            mov d, b
0986   0A19 1F 2B 0A      mov al, [d + s_hex_digits_printx32]
0987   0A1C 23            mov ah, al
0988   0A1D E5            pop b
0989   0A1E D8            push b
0990   0A1F A7 00         mov bh, 0
0991   0A21 FD 87 0F      and bl, $0F
0992   0A24 74            mov d, b
0993   0A25 1F 2B 0A      mov al, [d + s_hex_digits_printx32]
0994   0A28 E5            pop b
0995   0A29 E7            pop d
0996   0A2A 09            ret
0997   0A2B 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
0997   0A2F 34 35 36 37 
0997   0A33 38 39 41 42 
0997   0A37 43 44 45 46 
0998   0A3B             ; --- END INLINE ASM SEGMENT
0999   0A3B F9            leave
1000   0A3C 09            ret
1001   0A3D             
1002   0A3D             err:
1003   0A3D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1004   0A40             ; print(e); 
1005   0A40             ; --- START FUNCTION CALL
1006   0A40 FA 05 00      lea d, [bp + 5] ; $e
1007   0A43 2A            mov b, [d]
1008   0A44 38 00 00      mov c, 0
1009   0A47 FD AB         swp b
1010   0A49 D8            push b
1011   0A4A 07 52 0A      call print
1012   0A4D 51 02 00      add sp, 2
1013   0A50             ; --- END FUNCTION CALL
1014   0A50 F9            leave
1015   0A51 09            ret
1016   0A52             
1017   0A52             print:
1018   0A52 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1019   0A55             ; --- BEGIN INLINE ASM SEGMENT
1020   0A55 FA 05 00      lea d, [bp + 5] ; $s
1021   0A58 FD 2A         mov d, [d]
1022   0A5A             _puts_L1_print:
1023   0A5A 1E            mov al, [d]
1024   0A5B B9 00         cmp al, 0
1025   0A5D C6 69 0A      jz _puts_END_print
1026   0A60 23            mov ah, al
1027   0A61 19 00         mov al, 0
1028   0A63 05 03         syscall sys_io
1029   0A65 79            inc d
1030   0A66 0A 5A 0A      jmp _puts_L1_print
1031   0A69             _puts_END_print:
1032   0A69             ; --- END INLINE ASM SEGMENT
1033   0A69 F9            leave
1034   0A6A 09            ret
1035   0A6B             
1036   0A6B             print_signed:
1037   0A6B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1038   0A6E             ; char digits[5]; 
1039   0A6E 52 05 00      sub sp, 5
1040   0A71             ; int i = 0; 
1041   0A71 52 02 00      sub sp, 2
1042   0A74             ; --- START LOCAL VAR INITIALIZATION
1043   0A74 FA FA FF      lea d, [bp + -6] ; $i
1044   0A77 DA            push d
1045   0A78 FD 2E 00 00   mov32 cb, $00000000
1045   0A7C 00 00 
1046   0A7E E7            pop d
1047   0A7F FD 43         mov [d], b
1048   0A81             ; --- END LOCAL VAR INITIALIZATION
1049   0A81             ; if (num < 0) { 
1050   0A81             _if27_cond:
1051   0A81 FA 05 00      lea d, [bp + 5] ; $num
1052   0A84 2A            mov b, [d]
1053   0A85 38 00 00      mov c, 0
1054   0A88             ; --- START RELATIONAL
1055   0A88 D7            push a
1056   0A89 11            mov a, b
1057   0A8A FD 2E 00 00   mov32 cb, $00000000
1057   0A8E 00 00 
1058   0A90 B0            cmp a, b
1059   0A91 FD 73         slt ; < (signed)
1060   0A93 E4            pop a
1061   0A94             ; --- END RELATIONAL
1062   0A94 C0 00 00      cmp b, 0
1063   0A97 C6 BA 0A      je _if27_else
1064   0A9A             _if27_TRUE:
1065   0A9A             ; putchar('-'); 
1066   0A9A             ; --- START FUNCTION CALL
1067   0A9A FD 2E 2D 00   mov32 cb, $0000002d
1067   0A9E 00 00 
1068   0AA0 DD            push bl
1069   0AA1 07 9B 08      call putchar
1070   0AA4 51 01 00      add sp, 1
1071   0AA7             ; --- END FUNCTION CALL
1072   0AA7             ; num = -num; 
1073   0AA7 FA 05 00      lea d, [bp + 5] ; $num
1074   0AAA DA            push d
1075   0AAB FA 05 00      lea d, [bp + 5] ; $num
1076   0AAE 2A            mov b, [d]
1077   0AAF 38 00 00      mov c, 0
1078   0AB2 FD 97         neg b
1079   0AB4 E7            pop d
1080   0AB5 FD 43         mov [d], b
1081   0AB7 0A E5 0A      jmp _if27_exit
1082   0ABA             _if27_else:
1083   0ABA             ; if (num == 0) { 
1084   0ABA             _if28_cond:
1085   0ABA FA 05 00      lea d, [bp + 5] ; $num
1086   0ABD 2A            mov b, [d]
1087   0ABE 38 00 00      mov c, 0
1088   0AC1             ; --- START RELATIONAL
1089   0AC1 D7            push a
1090   0AC2 11            mov a, b
1091   0AC3 FD 2E 00 00   mov32 cb, $00000000
1091   0AC7 00 00 
1092   0AC9 B0            cmp a, b
1093   0ACA FD 71         seq ; ==
1094   0ACC E4            pop a
1095   0ACD             ; --- END RELATIONAL
1096   0ACD C0 00 00      cmp b, 0
1097   0AD0 C6 E5 0A      je _if28_exit
1098   0AD3             _if28_TRUE:
1099   0AD3             ; putchar('0'); 
1100   0AD3             ; --- START FUNCTION CALL
1101   0AD3 FD 2E 30 00   mov32 cb, $00000030
1101   0AD7 00 00 
1102   0AD9 DD            push bl
1103   0ADA 07 9B 08      call putchar
1104   0ADD 51 01 00      add sp, 1
1105   0AE0             ; --- END FUNCTION CALL
1106   0AE0             ; return; 
1107   0AE0 F9            leave
1108   0AE1 09            ret
1109   0AE2 0A E5 0A      jmp _if28_exit
1110   0AE5             _if28_exit:
1111   0AE5             _if27_exit:
1112   0AE5             ; while (num > 0) { 
1113   0AE5             _while29_cond:
1114   0AE5 FA 05 00      lea d, [bp + 5] ; $num
1115   0AE8 2A            mov b, [d]
1116   0AE9 38 00 00      mov c, 0
1117   0AEC             ; --- START RELATIONAL
1118   0AEC D7            push a
1119   0AED 11            mov a, b
1120   0AEE FD 2E 00 00   mov32 cb, $00000000
1120   0AF2 00 00 
1121   0AF4 B0            cmp a, b
1122   0AF5 FD 7F         sgt ; >
1123   0AF7 E4            pop a
1124   0AF8             ; --- END RELATIONAL
1125   0AF8 C0 00 00      cmp b, 0
1126   0AFB C6 72 0B      je _while29_exit
1127   0AFE             _while29_block:
1128   0AFE             ; digits[i] = '0' + (num % 10); 
1129   0AFE FA FC FF      lea d, [bp + -4] ; $digits
1130   0B01 D7            push a
1131   0B02 DA            push d
1132   0B03 FA FA FF      lea d, [bp + -6] ; $i
1133   0B06 2A            mov b, [d]
1134   0B07 38 00 00      mov c, 0
1135   0B0A E7            pop d
1136   0B0B 5A            add d, b
1137   0B0C E4            pop a
1138   0B0D DA            push d
1139   0B0E FD 2E 30 00   mov32 cb, $00000030
1139   0B12 00 00 
1140   0B14             ; --- START TERMS
1141   0B14 D7            push a
1142   0B15 11            mov a, b
1143   0B16 FA 05 00      lea d, [bp + 5] ; $num
1144   0B19 2A            mov b, [d]
1145   0B1A 38 00 00      mov c, 0
1146   0B1D             ; --- START FACTORS
1147   0B1D D7            push a
1148   0B1E FD D8         push g
1149   0B20 11            mov a, b
1150   0B21 FD 7A         mov g, c
1151   0B23 FD 2E 0A 00   mov32 cb, $0000000a
1151   0B27 00 00 
1152   0B29 FD D8         push g ; save 'g' as the div instruction uses it
1153   0B2B AE            div a, b ; %, a: quotient, b: remainder
1154   0B2C 11            mov a, b
1155   0B2D FD F1         pop g
1156   0B2F FD 38         mov c, g
1157   0B31 27            mov b, a
1158   0B32 FD F1         pop g
1159   0B34 E4            pop a
1160   0B35             ; --- END FACTORS
1161   0B35 56            add b, a
1162   0B36 E4            pop a
1163   0B37             ; --- END TERMS
1164   0B37 E7            pop d
1165   0B38 FD 3E         mov [d], bl
1166   0B3A             ; num = num / 10; 
1167   0B3A FA 05 00      lea d, [bp + 5] ; $num
1168   0B3D DA            push d
1169   0B3E FA 05 00      lea d, [bp + 5] ; $num
1170   0B41 2A            mov b, [d]
1171   0B42 38 00 00      mov c, 0
1172   0B45             ; --- START FACTORS
1173   0B45 D7            push a
1174   0B46 FD D8         push g
1175   0B48 11            mov a, b
1176   0B49 FD 7A         mov g, c
1177   0B4B FD 2E 0A 00   mov32 cb, $0000000a
1177   0B4F 00 00 
1178   0B51 FD D8         push g ; save 'g' as the div instruction uses it
1179   0B53 AE            div a, b ; /, a: quotient, b: remainder
1180   0B54 FD F1         pop g
1181   0B56 FD 38         mov c, g
1182   0B58 27            mov b, a
1183   0B59 FD F1         pop g
1184   0B5B E4            pop a
1185   0B5C             ; --- END FACTORS
1186   0B5C E7            pop d
1187   0B5D FD 43         mov [d], b
1188   0B5F             ; i++; 
1189   0B5F FA FA FF      lea d, [bp + -6] ; $i
1190   0B62 2A            mov b, [d]
1191   0B63 38 00 00      mov c, 0
1192   0B66 11            mov a, b
1193   0B67 FD 77         inc b
1194   0B69 FA FA FF      lea d, [bp + -6] ; $i
1195   0B6C FD 43         mov [d], b
1196   0B6E 27            mov b, a
1197   0B6F 0A E5 0A      jmp _while29_cond
1198   0B72             _while29_exit:
1199   0B72             ; while (i > 0) { 
1200   0B72             _while36_cond:
1201   0B72 FA FA FF      lea d, [bp + -6] ; $i
1202   0B75 2A            mov b, [d]
1203   0B76 38 00 00      mov c, 0
1204   0B79             ; --- START RELATIONAL
1205   0B79 D7            push a
1206   0B7A 11            mov a, b
1207   0B7B FD 2E 00 00   mov32 cb, $00000000
1207   0B7F 00 00 
1208   0B81 B0            cmp a, b
1209   0B82 FD 7F         sgt ; >
1210   0B84 E4            pop a
1211   0B85             ; --- END RELATIONAL
1212   0B85 C0 00 00      cmp b, 0
1213   0B88 C6 BA 0B      je _while36_exit
1214   0B8B             _while36_block:
1215   0B8B             ; i--; 
1216   0B8B FA FA FF      lea d, [bp + -6] ; $i
1217   0B8E 2A            mov b, [d]
1218   0B8F 38 00 00      mov c, 0
1219   0B92 11            mov a, b
1220   0B93 FD 7D         dec b
1221   0B95 FA FA FF      lea d, [bp + -6] ; $i
1222   0B98 FD 43         mov [d], b
1223   0B9A 27            mov b, a
1224   0B9B             ; putchar(digits[i]); 
1225   0B9B             ; --- START FUNCTION CALL
1226   0B9B FA FC FF      lea d, [bp + -4] ; $digits
1227   0B9E D7            push a
1228   0B9F DA            push d
1229   0BA0 FA FA FF      lea d, [bp + -6] ; $i
1230   0BA3 2A            mov b, [d]
1231   0BA4 38 00 00      mov c, 0
1232   0BA7 E7            pop d
1233   0BA8 5A            add d, b
1234   0BA9 E4            pop a
1235   0BAA 32            mov bl, [d]
1236   0BAB A7 00         mov bh, 0
1237   0BAD 38 00 00      mov c, 0
1238   0BB0 DD            push bl
1239   0BB1 07 9B 08      call putchar
1240   0BB4 51 01 00      add sp, 1
1241   0BB7             ; --- END FUNCTION CALL
1242   0BB7 0A 72 0B      jmp _while36_cond
1243   0BBA             _while36_exit:
1244   0BBA F9            leave
1245   0BBB 09            ret
1246   0BBC             
1247   0BBC             print_unsigned:
1248   0BBC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1249   0BBF             ; char digits[5]; 
1250   0BBF 52 05 00      sub sp, 5
1251   0BC2             ; int i; 
1252   0BC2 52 02 00      sub sp, 2
1253   0BC5             ; i = 0; 
1254   0BC5 FA FA FF      lea d, [bp + -6] ; $i
1255   0BC8 DA            push d
1256   0BC9 FD 2E 00 00   mov32 cb, $00000000
1256   0BCD 00 00 
1257   0BCF E7            pop d
1258   0BD0 FD 43         mov [d], b
1259   0BD2             ; if(num == 0){ 
1260   0BD2             _if37_cond:
1261   0BD2 FA 05 00      lea d, [bp + 5] ; $num
1262   0BD5 2A            mov b, [d]
1263   0BD6 38 00 00      mov c, 0
1264   0BD9             ; --- START RELATIONAL
1265   0BD9 D7            push a
1266   0BDA 11            mov a, b
1267   0BDB FD 2E 00 00   mov32 cb, $00000000
1267   0BDF 00 00 
1268   0BE1 B0            cmp a, b
1269   0BE2 FD 71         seq ; ==
1270   0BE4 E4            pop a
1271   0BE5             ; --- END RELATIONAL
1272   0BE5 C0 00 00      cmp b, 0
1273   0BE8 C6 FD 0B      je _if37_exit
1274   0BEB             _if37_TRUE:
1275   0BEB             ; putchar('0'); 
1276   0BEB             ; --- START FUNCTION CALL
1277   0BEB FD 2E 30 00   mov32 cb, $00000030
1277   0BEF 00 00 
1278   0BF1 DD            push bl
1279   0BF2 07 9B 08      call putchar
1280   0BF5 51 01 00      add sp, 1
1281   0BF8             ; --- END FUNCTION CALL
1282   0BF8             ; return; 
1283   0BF8 F9            leave
1284   0BF9 09            ret
1285   0BFA 0A FD 0B      jmp _if37_exit
1286   0BFD             _if37_exit:
1287   0BFD             ; while (num > 0) { 
1288   0BFD             _while38_cond:
1289   0BFD FA 05 00      lea d, [bp + 5] ; $num
1290   0C00 2A            mov b, [d]
1291   0C01 38 00 00      mov c, 0
1292   0C04             ; --- START RELATIONAL
1293   0C04 D7            push a
1294   0C05 11            mov a, b
1295   0C06 FD 2E 00 00   mov32 cb, $00000000
1295   0C0A 00 00 
1296   0C0C B0            cmp a, b
1297   0C0D FD 81         sgu ; > (unsigned)
1298   0C0F E4            pop a
1299   0C10             ; --- END RELATIONAL
1300   0C10 C0 00 00      cmp b, 0
1301   0C13 C6 8A 0C      je _while38_exit
1302   0C16             _while38_block:
1303   0C16             ; digits[i] = '0' + (num % 10); 
1304   0C16 FA FC FF      lea d, [bp + -4] ; $digits
1305   0C19 D7            push a
1306   0C1A DA            push d
1307   0C1B FA FA FF      lea d, [bp + -6] ; $i
1308   0C1E 2A            mov b, [d]
1309   0C1F 38 00 00      mov c, 0
1310   0C22 E7            pop d
1311   0C23 5A            add d, b
1312   0C24 E4            pop a
1313   0C25 DA            push d
1314   0C26 FD 2E 30 00   mov32 cb, $00000030
1314   0C2A 00 00 
1315   0C2C             ; --- START TERMS
1316   0C2C D7            push a
1317   0C2D 11            mov a, b
1318   0C2E FA 05 00      lea d, [bp + 5] ; $num
1319   0C31 2A            mov b, [d]
1320   0C32 38 00 00      mov c, 0
1321   0C35             ; --- START FACTORS
1322   0C35 D7            push a
1323   0C36 FD D8         push g
1324   0C38 11            mov a, b
1325   0C39 FD 7A         mov g, c
1326   0C3B FD 2E 0A 00   mov32 cb, $0000000a
1326   0C3F 00 00 
1327   0C41 FD D8         push g ; save 'g' as the div instruction uses it
1328   0C43 AE            div a, b ; %, a: quotient, b: remainder
1329   0C44 11            mov a, b
1330   0C45 FD F1         pop g
1331   0C47 FD 38         mov c, g
1332   0C49 27            mov b, a
1333   0C4A FD F1         pop g
1334   0C4C E4            pop a
1335   0C4D             ; --- END FACTORS
1336   0C4D 56            add b, a
1337   0C4E E4            pop a
1338   0C4F             ; --- END TERMS
1339   0C4F E7            pop d
1340   0C50 FD 3E         mov [d], bl
1341   0C52             ; num = num / 10; 
1342   0C52 FA 05 00      lea d, [bp + 5] ; $num
1343   0C55 DA            push d
1344   0C56 FA 05 00      lea d, [bp + 5] ; $num
1345   0C59 2A            mov b, [d]
1346   0C5A 38 00 00      mov c, 0
1347   0C5D             ; --- START FACTORS
1348   0C5D D7            push a
1349   0C5E FD D8         push g
1350   0C60 11            mov a, b
1351   0C61 FD 7A         mov g, c
1352   0C63 FD 2E 0A 00   mov32 cb, $0000000a
1352   0C67 00 00 
1353   0C69 FD D8         push g ; save 'g' as the div instruction uses it
1354   0C6B AE            div a, b ; /, a: quotient, b: remainder
1355   0C6C FD F1         pop g
1356   0C6E FD 38         mov c, g
1357   0C70 27            mov b, a
1358   0C71 FD F1         pop g
1359   0C73 E4            pop a
1360   0C74             ; --- END FACTORS
1361   0C74 E7            pop d
1362   0C75 FD 43         mov [d], b
1363   0C77             ; i++; 
1364   0C77 FA FA FF      lea d, [bp + -6] ; $i
1365   0C7A 2A            mov b, [d]
1366   0C7B 38 00 00      mov c, 0
1367   0C7E 11            mov a, b
1368   0C7F FD 77         inc b
1369   0C81 FA FA FF      lea d, [bp + -6] ; $i
1370   0C84 FD 43         mov [d], b
1371   0C86 27            mov b, a
1372   0C87 0A FD 0B      jmp _while38_cond
1373   0C8A             _while38_exit:
1374   0C8A             ; while (i > 0) { 
1375   0C8A             _while45_cond:
1376   0C8A FA FA FF      lea d, [bp + -6] ; $i
1377   0C8D 2A            mov b, [d]
1378   0C8E 38 00 00      mov c, 0
1379   0C91             ; --- START RELATIONAL
1380   0C91 D7            push a
1381   0C92 11            mov a, b
1382   0C93 FD 2E 00 00   mov32 cb, $00000000
1382   0C97 00 00 
1383   0C99 B0            cmp a, b
1384   0C9A FD 7F         sgt ; >
1385   0C9C E4            pop a
1386   0C9D             ; --- END RELATIONAL
1387   0C9D C0 00 00      cmp b, 0
1388   0CA0 C6 D2 0C      je _while45_exit
1389   0CA3             _while45_block:
1390   0CA3             ; i--; 
1391   0CA3 FA FA FF      lea d, [bp + -6] ; $i
1392   0CA6 2A            mov b, [d]
1393   0CA7 38 00 00      mov c, 0
1394   0CAA 11            mov a, b
1395   0CAB FD 7D         dec b
1396   0CAD FA FA FF      lea d, [bp + -6] ; $i
1397   0CB0 FD 43         mov [d], b
1398   0CB2 27            mov b, a
1399   0CB3             ; putchar(digits[i]); 
1400   0CB3             ; --- START FUNCTION CALL
1401   0CB3 FA FC FF      lea d, [bp + -4] ; $digits
1402   0CB6 D7            push a
1403   0CB7 DA            push d
1404   0CB8 FA FA FF      lea d, [bp + -6] ; $i
1405   0CBB 2A            mov b, [d]
1406   0CBC 38 00 00      mov c, 0
1407   0CBF E7            pop d
1408   0CC0 5A            add d, b
1409   0CC1 E4            pop a
1410   0CC2 32            mov bl, [d]
1411   0CC3 A7 00         mov bh, 0
1412   0CC5 38 00 00      mov c, 0
1413   0CC8 DD            push bl
1414   0CC9 07 9B 08      call putchar
1415   0CCC 51 01 00      add sp, 1
1416   0CCF             ; --- END FUNCTION CALL
1417   0CCF 0A 8A 0C      jmp _while45_cond
1418   0CD2             _while45_exit:
1419   0CD2 F9            leave
1420   0CD3 09            ret
1421   0CD4             
1422   0CD4             printx16:
1423   0CD4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1424   0CD7             ; --- BEGIN INLINE ASM SEGMENT
1425   0CD7 FA 05 00      lea d, [bp + 5] ; $hex
1426   0CDA 2A            mov b, [d]
1427   0CDB             print_u16x_printx16:
1428   0CDB DD            push bl
1429   0CDC 30            mov bl, bh
1430   0CDD 07 FA 0C      call _itoa_printx16        ; convert bh to char in A
1431   0CE0 2F            mov bl, al        ; save al
1432   0CE1 19 00         mov al, 0
1433   0CE3 05 03         syscall sys_io        ; display AH
1434   0CE5 24            mov ah, bl        ; retrieve al
1435   0CE6 19 00         mov al, 0
1436   0CE8 05 03         syscall sys_io        ; display AL
1437   0CEA EA            pop bl
1438   0CEB 07 FA 0C      call _itoa_printx16        ; convert bh to char in A
1439   0CEE 2F            mov bl, al        ; save al
1440   0CEF 19 00         mov al, 0
1441   0CF1 05 03         syscall sys_io        ; display AH
1442   0CF3 24            mov ah, bl        ; retrieve al
1443   0CF4 19 00         mov al, 0
1444   0CF6 05 03         syscall sys_io        ; display AL
1445   0CF8             ; --- END INLINE ASM SEGMENT
1446   0CF8             ; return; 
1447   0CF8 F9            leave
1448   0CF9 09            ret
1449   0CFA             ; --- BEGIN INLINE ASM SEGMENT
1450   0CFA             _itoa_printx16:
1451   0CFA DA            push d
1452   0CFB D8            push b
1453   0CFC A7 00         mov bh, 0
1454   0CFE FD A4 04      shr bl, 4  
1455   0D01 74            mov d, b
1456   0D02 1F 14 0D      mov al, [d + s_hex_digits_printx16]
1457   0D05 23            mov ah, al
1458   0D06 E5            pop b
1459   0D07 D8            push b
1460   0D08 A7 00         mov bh, 0
1461   0D0A FD 87 0F      and bl, $0F
1462   0D0D 74            mov d, b
1463   0D0E 1F 14 0D      mov al, [d + s_hex_digits_printx16]
1464   0D11 E5            pop b
1465   0D12 E7            pop d
1466   0D13 09            ret
1467   0D14 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1467   0D18 34 35 36 37 
1467   0D1C 38 39 41 42 
1467   0D20 43 44 45 46 
1468   0D24             ; --- END INLINE ASM SEGMENT
1469   0D24 F9            leave
1470   0D25 09            ret
1471   0D26             ; --- END TEXT SEGMENT
1472   0D26             
1473   0D26             ; --- BEGIN DATA SEGMENT
1474   0D26 2F 75 73 72 _shell_path_data: .db "/usr/bin0/shell", 0
1474   0D2A 2F 62 69 6E 
1474   0D2E 30 2F 73 68 
1474   0D32 65 6C 6C 00 
1475   0D36 26 0D       _shell_path: .dw _shell_path_data
1476   0D38 69 6E 69 74 _s0: .db "init process started.\n\r", 0
1476   0D3C 20 70 72 6F 
1476   0D40 63 65 73 73 
1476   0D44 20 73 74 61 
1476   0D48 72 74 65 64 
1476   0D4C 2E 0A 0D 00 
1477   0D50 73 74 61 72 _s1: .db "starting shell...\n\r", 0
1477   0D54 74 69 6E 67 
1477   0D58 20 73 68 65 
1477   0D5C 6C 6C 2E 2E 
1477   0D60 2E 0A 0D 00 
1478   0D64 55 6E 65 78 _s2: .db "Unexpected format in printf.", 0
1478   0D68 70 65 63 74 
1478   0D6C 65 64 20 66 
1478   0D70 6F 72 6D 61 
1478   0D74 74 20 69 6E 
1478   0D78 20 70 72 69 
1478   0D7C 6E 74 66 2E 
1478   0D80 00 
1479   0D81 45 72 72 6F _s3: .db "Error: Unknown argument type.\n", 0
1479   0D85 72 3A 20 55 
1479   0D89 6E 6B 6E 6F 
1479   0D8D 77 6E 20 61 
1479   0D91 72 67 75 6D 
1479   0D95 65 6E 74 20 
1479   0D99 74 79 70 65 
1479   0D9D 2E 0A 00 
1480   0DA0             
1481   0DA0 A2 0D       _heap_top: .dw _heap
1482   0DA2 00          _heap: .db 0
1483   0DA3             ; --- END DATA SEGMENT
1484   0DA3             
1485   0DA3             .end
tasm: Number of errors = 0
