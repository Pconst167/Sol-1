0001   0000             ; --- FILENAME: programs/sha256
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $hash 
0011   0408             ; $i 
0012   0408 52 12 00      sub sp, 18
0013   040B             ;; simple_hash(text, hash); 
0014   040B FA F1 FF      lea d, [bp + -15] ; $hash
0015   040E 2D            mov b, d
0016   040F FD AB         swp b
0017   0411 D8            push b
0018   0412 3B 49 14      mov d, _text ; $text
0019   0415 2A            mov b, [d]
0020   0416 FD AB         swp b
0021   0418 D8            push b
0022   0419 07 90 11      call simple_hash
0023   041C 51 04 00      add sp, 4
0024   041F             ;; printf("Hash: "); 
0025   041F 26 4B 14      mov b, __s0 ; "Hash: "
0026   0422 FD AB         swp b
0027   0424 D8            push b
0028   0425 07 47 06      call printf
0029   0428 51 02 00      add sp, 2
0030   042B             ;; for (i = 0; i <  16        ; i++) { 
0031   042B             _for1_init:
0032   042B FA EF FF      lea d, [bp + -17] ; $i
0033   042E DA            push d
0034   042F 26 00 00      mov b, $0
0035   0432 E7            pop d
0036   0433 FD 43         mov [d], b
0037   0435             _for1_cond:
0038   0435 FA EF FF      lea d, [bp + -17] ; $i
0039   0438 2A            mov b, [d]
0040   0439             ; START RELATIONAL
0041   0439 D7            push a
0042   043A 11            mov a, b
0043   043B 26 10 00      mov b, $10
0044   043E B0            cmp a, b
0045   043F FD 73         slt ; < 
0046   0441 E4            pop a
0047   0442             ; END RELATIONAL
0048   0442 C0 00 00      cmp b, 0
0049   0445 C6 70 04      je _for1_exit
0050   0448             _for1_block:
0051   0448             ;; printx8(hash[i]); 
0052   0448 FA F1 FF      lea d, [bp + -15] ; $hash
0053   044B D7            push a
0054   044C DA            push d
0055   044D FA EF FF      lea d, [bp + -17] ; $i
0056   0450 2A            mov b, [d]
0057   0451 E7            pop d
0058   0452 5A            add d, b
0059   0453 E4            pop a
0060   0454 32            mov bl, [d]
0061   0455 A7 00         mov bh, 0
0062   0457 DD            push bl
0063   0458 07 DC 07      call printx8
0064   045B 51 01 00      add sp, 1
0065   045E             _for1_update:
0066   045E FA EF FF      lea d, [bp + -17] ; $i
0067   0461 2A            mov b, [d]
0068   0462 FD 79         mov g, b
0069   0464 FD 77         inc b
0070   0466 FA EF FF      lea d, [bp + -17] ; $i
0071   0469 FD 43         mov [d], b
0072   046B FD 27         mov b, g
0073   046D 0A 35 04      jmp _for1_cond
0074   0470             _for1_exit:
0075   0470             ;; printf("\n"); 
0076   0470 26 52 14      mov b, __s1 ; "\n"
0077   0473 FD AB         swp b
0078   0475 D8            push b
0079   0476 07 47 06      call printf
0080   0479 51 02 00      add sp, 2
0081   047C             ;; return 0; 
0082   047C 26 00 00      mov b, $0
0083   047F F9            leave
0084   0480 05 0B         syscall sys_terminate_proc
0085   0482             
0086   0482             strcpy:
0087   0482 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0088   0485             ; $psrc 
0089   0485             ; $pdest 
0090   0485 52 04 00      sub sp, 4
0091   0488             ;; psrc = src; 
0092   0488 FA FF FF      lea d, [bp + -1] ; $psrc
0093   048B DA            push d
0094   048C FA 05 00      lea d, [bp + 5] ; $src
0095   048F 2A            mov b, [d]
0096   0490 E7            pop d
0097   0491 FD 43         mov [d], b
0098   0493             ;; pdest = dest; 
0099   0493 FA FD FF      lea d, [bp + -3] ; $pdest
0100   0496 DA            push d
0101   0497 FA 07 00      lea d, [bp + 7] ; $dest
0102   049A 2A            mov b, [d]
0103   049B E7            pop d
0104   049C FD 43         mov [d], b
0105   049E             ;; while(*psrc) *pdest++ = *psrc++; 
0106   049E             _while2_cond:
0107   049E FA FF FF      lea d, [bp + -1] ; $psrc
0108   04A1 2A            mov b, [d]
0109   04A2 74            mov d, b
0110   04A3 32            mov bl, [d]
0111   04A4 A7 00         mov bh, 0
0112   04A6 C0 00 00      cmp b, 0
0113   04A9 C6 D5 04      je _while2_exit
0114   04AC             _while2_block:
0115   04AC             ;; *pdest++ = *psrc++; 
0116   04AC FA FD FF      lea d, [bp + -3] ; $pdest
0117   04AF 2A            mov b, [d]
0118   04B0 FD 79         mov g, b
0119   04B2 FD 77         inc b
0120   04B4 FA FD FF      lea d, [bp + -3] ; $pdest
0121   04B7 FD 43         mov [d], b
0122   04B9 FD 27         mov b, g
0123   04BB D8            push b
0124   04BC FA FF FF      lea d, [bp + -1] ; $psrc
0125   04BF 2A            mov b, [d]
0126   04C0 FD 79         mov g, b
0127   04C2 FD 77         inc b
0128   04C4 FA FF FF      lea d, [bp + -1] ; $psrc
0129   04C7 FD 43         mov [d], b
0130   04C9 FD 27         mov b, g
0131   04CB 74            mov d, b
0132   04CC 32            mov bl, [d]
0133   04CD A7 00         mov bh, 0
0134   04CF E7            pop d
0135   04D0 FD 3E         mov [d], bl
0136   04D2 0A 9E 04      jmp _while2_cond
0137   04D5             _while2_exit:
0138   04D5             ;; *pdest = '\0'; 
0139   04D5 FA FD FF      lea d, [bp + -3] ; $pdest
0140   04D8 2A            mov b, [d]
0141   04D9 D8            push b
0142   04DA 26 00 00      mov b, $0
0143   04DD E7            pop d
0144   04DE FD 3E         mov [d], bl
0145   04E0 F9            leave
0146   04E1 09            ret
0147   04E2             
0148   04E2             strcmp:
0149   04E2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0150   04E5             ;; while (*s1 && (*s1 == *s2)) { 
0151   04E5             _while3_cond:
0152   04E5 FA 07 00      lea d, [bp + 7] ; $s1
0153   04E8 2A            mov b, [d]
0154   04E9 74            mov d, b
0155   04EA 32            mov bl, [d]
0156   04EB A7 00         mov bh, 0
0157   04ED D7            push a
0158   04EE 11            mov a, b
0159   04EF FA 07 00      lea d, [bp + 7] ; $s1
0160   04F2 2A            mov b, [d]
0161   04F3 74            mov d, b
0162   04F4 32            mov bl, [d]
0163   04F5 A7 00         mov bh, 0
0164   04F7             ; START RELATIONAL
0165   04F7 D7            push a
0166   04F8 11            mov a, b
0167   04F9 FA 05 00      lea d, [bp + 5] ; $s2
0168   04FC 2A            mov b, [d]
0169   04FD 74            mov d, b
0170   04FE 32            mov bl, [d]
0171   04FF A7 00         mov bh, 0
0172   0501 B0            cmp a, b
0173   0502 FD 71         seq ; ==
0174   0504 E4            pop a
0175   0505             ; END RELATIONAL
0176   0505 FD A7         sand a, b ; &&
0177   0507 E4            pop a
0178   0508 C0 00 00      cmp b, 0
0179   050B C6 2F 05      je _while3_exit
0180   050E             _while3_block:
0181   050E             ;; s1++; 
0182   050E FA 07 00      lea d, [bp + 7] ; $s1
0183   0511 2A            mov b, [d]
0184   0512 FD 79         mov g, b
0185   0514 FD 77         inc b
0186   0516 FA 07 00      lea d, [bp + 7] ; $s1
0187   0519 FD 43         mov [d], b
0188   051B FD 27         mov b, g
0189   051D             ;; s2++; 
0190   051D FA 05 00      lea d, [bp + 5] ; $s2
0191   0520 2A            mov b, [d]
0192   0521 FD 79         mov g, b
0193   0523 FD 77         inc b
0194   0525 FA 05 00      lea d, [bp + 5] ; $s2
0195   0528 FD 43         mov [d], b
0196   052A FD 27         mov b, g
0197   052C 0A E5 04      jmp _while3_cond
0198   052F             _while3_exit:
0199   052F             ;; return *s1 - *s2; 
0200   052F FA 07 00      lea d, [bp + 7] ; $s1
0201   0532 2A            mov b, [d]
0202   0533 74            mov d, b
0203   0534 32            mov bl, [d]
0204   0535 A7 00         mov bh, 0
0205   0537             ; START TERMS
0206   0537 D7            push a
0207   0538 11            mov a, b
0208   0539 FA 05 00      lea d, [bp + 5] ; $s2
0209   053C 2A            mov b, [d]
0210   053D 74            mov d, b
0211   053E 32            mov bl, [d]
0212   053F A7 00         mov bh, 0
0213   0541 60            sub a, b
0214   0542 27            mov b, a
0215   0543 E4            pop a
0216   0544             ; END TERMS
0217   0544 F9            leave
0218   0545 09            ret
0219   0546             
0220   0546             strcat:
0221   0546 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0222   0549             ; $dest_len 
0223   0549             ; $i 
0224   0549 52 04 00      sub sp, 4
0225   054C             ;; dest_len = strlen(dest); 
0226   054C FA FF FF      lea d, [bp + -1] ; $dest_len
0227   054F DA            push d
0228   0550 FA 07 00      lea d, [bp + 7] ; $dest
0229   0553 2A            mov b, [d]
0230   0554 FD AB         swp b
0231   0556 D8            push b
0232   0557 07 FC 05      call strlen
0233   055A 51 02 00      add sp, 2
0234   055D E7            pop d
0235   055E FD 43         mov [d], b
0236   0560             ;; for (i = 0; src[i] != 0; i=i+1) { 
0237   0560             _for4_init:
0238   0560 FA FD FF      lea d, [bp + -3] ; $i
0239   0563 DA            push d
0240   0564 26 00 00      mov b, $0
0241   0567 E7            pop d
0242   0568 FD 43         mov [d], b
0243   056A             _for4_cond:
0244   056A FA 05 00      lea d, [bp + 5] ; $src
0245   056D FD 2A         mov d, [d]
0246   056F D7            push a
0247   0570 DA            push d
0248   0571 FA FD FF      lea d, [bp + -3] ; $i
0249   0574 2A            mov b, [d]
0250   0575 E7            pop d
0251   0576 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0252   057A E4            pop a
0253   057B 32            mov bl, [d]
0254   057C A7 00         mov bh, 0
0255   057E             ; START RELATIONAL
0256   057E D7            push a
0257   057F 11            mov a, b
0258   0580 26 00 00      mov b, $0
0259   0583 B0            cmp a, b
0260   0584 FD 72         sneq ; !=
0261   0586 E4            pop a
0262   0587             ; END RELATIONAL
0263   0587 C0 00 00      cmp b, 0
0264   058A C6 D5 05      je _for4_exit
0265   058D             _for4_block:
0266   058D             ;; dest[dest_len + i] = src[i]; 
0267   058D FA 07 00      lea d, [bp + 7] ; $dest
0268   0590 FD 2A         mov d, [d]
0269   0592 D7            push a
0270   0593 DA            push d
0271   0594 FA FF FF      lea d, [bp + -1] ; $dest_len
0272   0597 2A            mov b, [d]
0273   0598             ; START TERMS
0274   0598 D7            push a
0275   0599 11            mov a, b
0276   059A FA FD FF      lea d, [bp + -3] ; $i
0277   059D 2A            mov b, [d]
0278   059E 54            add a, b
0279   059F 27            mov b, a
0280   05A0 E4            pop a
0281   05A1             ; END TERMS
0282   05A1 E7            pop d
0283   05A2 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0284   05A6 E4            pop a
0285   05A7 DA            push d
0286   05A8 FA 05 00      lea d, [bp + 5] ; $src
0287   05AB FD 2A         mov d, [d]
0288   05AD D7            push a
0289   05AE DA            push d
0290   05AF FA FD FF      lea d, [bp + -3] ; $i
0291   05B2 2A            mov b, [d]
0292   05B3 E7            pop d
0293   05B4 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0294   05B8 E4            pop a
0295   05B9 32            mov bl, [d]
0296   05BA A7 00         mov bh, 0
0297   05BC E7            pop d
0298   05BD FD 3E         mov [d], bl
0299   05BF             _for4_update:
0300   05BF FA FD FF      lea d, [bp + -3] ; $i
0301   05C2 DA            push d
0302   05C3 FA FD FF      lea d, [bp + -3] ; $i
0303   05C6 2A            mov b, [d]
0304   05C7             ; START TERMS
0305   05C7 D7            push a
0306   05C8 11            mov a, b
0307   05C9 26 01 00      mov b, $1
0308   05CC 54            add a, b
0309   05CD 27            mov b, a
0310   05CE E4            pop a
0311   05CF             ; END TERMS
0312   05CF E7            pop d
0313   05D0 FD 43         mov [d], b
0314   05D2 0A 6A 05      jmp _for4_cond
0315   05D5             _for4_exit:
0316   05D5             ;; dest[dest_len + i] = 0; 
0317   05D5 FA 07 00      lea d, [bp + 7] ; $dest
0318   05D8 FD 2A         mov d, [d]
0319   05DA D7            push a
0320   05DB DA            push d
0321   05DC FA FF FF      lea d, [bp + -1] ; $dest_len
0322   05DF 2A            mov b, [d]
0323   05E0             ; START TERMS
0324   05E0 D7            push a
0325   05E1 11            mov a, b
0326   05E2 FA FD FF      lea d, [bp + -3] ; $i
0327   05E5 2A            mov b, [d]
0328   05E6 54            add a, b
0329   05E7 27            mov b, a
0330   05E8 E4            pop a
0331   05E9             ; END TERMS
0332   05E9 E7            pop d
0333   05EA FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0334   05EE E4            pop a
0335   05EF DA            push d
0336   05F0 26 00 00      mov b, $0
0337   05F3 E7            pop d
0338   05F4 FD 3E         mov [d], bl
0339   05F6             ;; return dest; 
0340   05F6 FA 07 00      lea d, [bp + 7] ; $dest
0341   05F9 2A            mov b, [d]
0342   05FA F9            leave
0343   05FB 09            ret
0344   05FC             
0345   05FC             strlen:
0346   05FC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0347   05FF             ; $length 
0348   05FF 52 02 00      sub sp, 2
0349   0602             ;; length = 0; 
0350   0602 FA FF FF      lea d, [bp + -1] ; $length
0351   0605 DA            push d
0352   0606 26 00 00      mov b, $0
0353   0609 E7            pop d
0354   060A FD 43         mov [d], b
0355   060C             ;; while (str[length] != 0) { 
0356   060C             _while5_cond:
0357   060C FA 05 00      lea d, [bp + 5] ; $str
0358   060F FD 2A         mov d, [d]
0359   0611 D7            push a
0360   0612 DA            push d
0361   0613 FA FF FF      lea d, [bp + -1] ; $length
0362   0616 2A            mov b, [d]
0363   0617 E7            pop d
0364   0618 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0365   061C E4            pop a
0366   061D 32            mov bl, [d]
0367   061E A7 00         mov bh, 0
0368   0620             ; START RELATIONAL
0369   0620 D7            push a
0370   0621 11            mov a, b
0371   0622 26 00 00      mov b, $0
0372   0625 B0            cmp a, b
0373   0626 FD 72         sneq ; !=
0374   0628 E4            pop a
0375   0629             ; END RELATIONAL
0376   0629 C0 00 00      cmp b, 0
0377   062C C6 41 06      je _while5_exit
0378   062F             _while5_block:
0379   062F             ;; length++; 
0380   062F FA FF FF      lea d, [bp + -1] ; $length
0381   0632 2A            mov b, [d]
0382   0633 FD 79         mov g, b
0383   0635 FD 77         inc b
0384   0637 FA FF FF      lea d, [bp + -1] ; $length
0385   063A FD 43         mov [d], b
0386   063C FD 27         mov b, g
0387   063E 0A 0C 06      jmp _while5_cond
0388   0641             _while5_exit:
0389   0641             ;; return length; 
0390   0641 FA FF FF      lea d, [bp + -1] ; $length
0391   0644 2A            mov b, [d]
0392   0645 F9            leave
0393   0646 09            ret
0394   0647             
0395   0647             printf:
0396   0647 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0397   064A             ; $p 
0398   064A             ; $fp 
0399   064A             ; $i 
0400   064A 52 06 00      sub sp, 6
0401   064D             ;; fp = format; 
0402   064D FA FD FF      lea d, [bp + -3] ; $fp
0403   0650 DA            push d
0404   0651 FA 05 00      lea d, [bp + 5] ; $format
0405   0654 2A            mov b, [d]
0406   0655 E7            pop d
0407   0656 FD 43         mov [d], b
0408   0658             ;; p = &format + 2; 
0409   0658 FA FF FF      lea d, [bp + -1] ; $p
0410   065B DA            push d
0411   065C FA 05 00      lea d, [bp + 5] ; $format
0412   065F 2D            mov b, d
0413   0660             ; START TERMS
0414   0660 D7            push a
0415   0661 11            mov a, b
0416   0662 26 02 00      mov b, $2
0417   0665 54            add a, b
0418   0666 27            mov b, a
0419   0667 E4            pop a
0420   0668             ; END TERMS
0421   0668 E7            pop d
0422   0669 FD 43         mov [d], b
0423   066B             ;; for(;;){ 
0424   066B             _for6_init:
0425   066B             _for6_cond:
0426   066B             _for6_block:
0427   066B             ;; if(!*fp) break; 
0428   066B             _if7_cond:
0429   066B FA FD FF      lea d, [bp + -3] ; $fp
0430   066E 2A            mov b, [d]
0431   066F 74            mov d, b
0432   0670 32            mov bl, [d]
0433   0671 A7 00         mov bh, 0
0434   0673 C0 00 00      cmp b, 0
0435   0676 FD 71         seq ; !
0436   0678 C0 00 00      cmp b, 0
0437   067B C6 84 06      je _if7_else
0438   067E             _if7_true:
0439   067E             ;; break; 
0440   067E 0A CE 07      jmp _for6_exit ; for break
0441   0681 0A CB 07      jmp _if7_exit
0442   0684             _if7_else:
0443   0684             ;; if(*fp == '%'){ 
0444   0684             _if8_cond:
0445   0684 FA FD FF      lea d, [bp + -3] ; $fp
0446   0687 2A            mov b, [d]
0447   0688 74            mov d, b
0448   0689 32            mov bl, [d]
0449   068A A7 00         mov bh, 0
0450   068C             ; START RELATIONAL
0451   068C D7            push a
0452   068D 11            mov a, b
0453   068E 26 25 00      mov b, $25
0454   0691 B0            cmp a, b
0455   0692 FD 71         seq ; ==
0456   0694 E4            pop a
0457   0695             ; END RELATIONAL
0458   0695 C0 00 00      cmp b, 0
0459   0698 C6 AD 07      je _if8_else
0460   069B             _if8_true:
0461   069B             ;; fp++; 
0462   069B FA FD FF      lea d, [bp + -3] ; $fp
0463   069E 2A            mov b, [d]
0464   069F FD 79         mov g, b
0465   06A1 FD 77         inc b
0466   06A3 FA FD FF      lea d, [bp + -3] ; $fp
0467   06A6 FD 43         mov [d], b
0468   06A8 FD 27         mov b, g
0469   06AA             ;; switch(*fp){ 
0470   06AA             _switch9_expr:
0471   06AA FA FD FF      lea d, [bp + -3] ; $fp
0472   06AD 2A            mov b, [d]
0473   06AE 74            mov d, b
0474   06AF 32            mov bl, [d]
0475   06B0 A7 00         mov bh, 0
0476   06B2             _switch9_comparisons:
0477   06B2 C1 64         cmp bl, $64
0478   06B4 C6 D6 06      je _switch9_case0
0479   06B7 C1 69         cmp bl, $69
0480   06B9 C6 D6 06      je _switch9_case1
0481   06BC C1 75         cmp bl, $75
0482   06BE C6 FB 06      je _switch9_case2
0483   06C1 C1 78         cmp bl, $78
0484   06C3 C6 20 07      je _switch9_case3
0485   06C6 C1 63         cmp bl, $63
0486   06C8 C6 45 07      je _switch9_case4
0487   06CB C1 73         cmp bl, $73
0488   06CD C6 6A 07      je _switch9_case5
0489   06D0 0A 8F 07      jmp _switch9_default
0490   06D3 0A 9B 07      jmp _switch9_exit
0491   06D6             _switch9_case0:
0492   06D6             _switch9_case1:
0493   06D6             ;; prints(*(int*)p); 
0494   06D6 FA FF FF      lea d, [bp + -1] ; $p
0495   06D9 2A            mov b, [d]
0496   06DA 74            mov d, b
0497   06DB 2A            mov b, [d]
0498   06DC FD AB         swp b
0499   06DE D8            push b
0500   06DF 07 60 0A      call prints
0501   06E2 51 02 00      add sp, 2
0502   06E5             ;; p = p + 2; 
0503   06E5 FA FF FF      lea d, [bp + -1] ; $p
0504   06E8 DA            push d
0505   06E9 FA FF FF      lea d, [bp + -1] ; $p
0506   06EC 2A            mov b, [d]
0507   06ED             ; START TERMS
0508   06ED D7            push a
0509   06EE 11            mov a, b
0510   06EF 26 02 00      mov b, $2
0511   06F2 54            add a, b
0512   06F3 27            mov b, a
0513   06F4 E4            pop a
0514   06F5             ; END TERMS
0515   06F5 E7            pop d
0516   06F6 FD 43         mov [d], b
0517   06F8             ;; break; 
0518   06F8 0A 9B 07      jmp _switch9_exit ; case break
0519   06FB             _switch9_case2:
0520   06FB             ;; printu(*(unsigned int*)p); 
0521   06FB FA FF FF      lea d, [bp + -1] ; $p
0522   06FE 2A            mov b, [d]
0523   06FF 74            mov d, b
0524   0700 2A            mov b, [d]
0525   0701 FD AB         swp b
0526   0703 D8            push b
0527   0704 07 55 0B      call printu
0528   0707 51 02 00      add sp, 2
0529   070A             ;; p = p + 2; 
0530   070A FA FF FF      lea d, [bp + -1] ; $p
0531   070D DA            push d
0532   070E FA FF FF      lea d, [bp + -1] ; $p
0533   0711 2A            mov b, [d]
0534   0712             ; START TERMS
0535   0712 D7            push a
0536   0713 11            mov a, b
0537   0714 26 02 00      mov b, $2
0538   0717 54            add a, b
0539   0718 27            mov b, a
0540   0719 E4            pop a
0541   071A             ; END TERMS
0542   071A E7            pop d
0543   071B FD 43         mov [d], b
0544   071D             ;; break; 
0545   071D 0A 9B 07      jmp _switch9_exit ; case break
0546   0720             _switch9_case3:
0547   0720             ;; printx16(*(unsigned int*)p); 
0548   0720 FA FF FF      lea d, [bp + -1] ; $p
0549   0723 2A            mov b, [d]
0550   0724 74            mov d, b
0551   0725 2A            mov b, [d]
0552   0726 FD AB         swp b
0553   0728 D8            push b
0554   0729 07 D0 07      call printx16
0555   072C 51 02 00      add sp, 2
0556   072F             ;; p = p + 2; 
0557   072F FA FF FF      lea d, [bp + -1] ; $p
0558   0732 DA            push d
0559   0733 FA FF FF      lea d, [bp + -1] ; $p
0560   0736 2A            mov b, [d]
0561   0737             ; START TERMS
0562   0737 D7            push a
0563   0738 11            mov a, b
0564   0739 26 02 00      mov b, $2
0565   073C 54            add a, b
0566   073D 27            mov b, a
0567   073E E4            pop a
0568   073F             ; END TERMS
0569   073F E7            pop d
0570   0740 FD 43         mov [d], b
0571   0742             ;; break; 
0572   0742 0A 9B 07      jmp _switch9_exit ; case break
0573   0745             _switch9_case4:
0574   0745             ;; putchar(*(char*)p); 
0575   0745 FA FF FF      lea d, [bp + -1] ; $p
0576   0748 2A            mov b, [d]
0577   0749 74            mov d, b
0578   074A 32            mov bl, [d]
0579   074B A7 00         mov bh, 0
0580   074D DD            push bl
0581   074E 07 41 0C      call putchar
0582   0751 51 01 00      add sp, 1
0583   0754             ;; p = p + 2; 
0584   0754 FA FF FF      lea d, [bp + -1] ; $p
0585   0757 DA            push d
0586   0758 FA FF FF      lea d, [bp + -1] ; $p
0587   075B 2A            mov b, [d]
0588   075C             ; START TERMS
0589   075C D7            push a
0590   075D 11            mov a, b
0591   075E 26 02 00      mov b, $2
0592   0761 54            add a, b
0593   0762 27            mov b, a
0594   0763 E4            pop a
0595   0764             ; END TERMS
0596   0764 E7            pop d
0597   0765 FD 43         mov [d], b
0598   0767             ;; break; 
0599   0767 0A 9B 07      jmp _switch9_exit ; case break
0600   076A             _switch9_case5:
0601   076A             ;; print(*(char**)p); 
0602   076A FA FF FF      lea d, [bp + -1] ; $p
0603   076D 2A            mov b, [d]
0604   076E 74            mov d, b
0605   076F 2A            mov b, [d]
0606   0770 FD AB         swp b
0607   0772 D8            push b
0608   0773 07 89 0C      call print
0609   0776 51 02 00      add sp, 2
0610   0779             ;; p = p + 2; 
0611   0779 FA FF FF      lea d, [bp + -1] ; $p
0612   077C DA            push d
0613   077D FA FF FF      lea d, [bp + -1] ; $p
0614   0780 2A            mov b, [d]
0615   0781             ; START TERMS
0616   0781 D7            push a
0617   0782 11            mov a, b
0618   0783 26 02 00      mov b, $2
0619   0786 54            add a, b
0620   0787 27            mov b, a
0621   0788 E4            pop a
0622   0789             ; END TERMS
0623   0789 E7            pop d
0624   078A FD 43         mov [d], b
0625   078C             ;; break; 
0626   078C 0A 9B 07      jmp _switch9_exit ; case break
0627   078F             _switch9_default:
0628   078F             ;; print("Error: Unknown argument type.\n"); 
0629   078F 26 54 14      mov b, __s2 ; "Error: Unknown argument type.\n"
0630   0792 FD AB         swp b
0631   0794 D8            push b
0632   0795 07 89 0C      call print
0633   0798 51 02 00      add sp, 2
0634   079B             _switch9_exit:
0635   079B             ;; fp++; 
0636   079B FA FD FF      lea d, [bp + -3] ; $fp
0637   079E 2A            mov b, [d]
0638   079F FD 79         mov g, b
0639   07A1 FD 77         inc b
0640   07A3 FA FD FF      lea d, [bp + -3] ; $fp
0641   07A6 FD 43         mov [d], b
0642   07A8 FD 27         mov b, g
0643   07AA 0A CB 07      jmp _if8_exit
0644   07AD             _if8_else:
0645   07AD             ;; putchar(*fp); 
0646   07AD FA FD FF      lea d, [bp + -3] ; $fp
0647   07B0 2A            mov b, [d]
0648   07B1 74            mov d, b
0649   07B2 32            mov bl, [d]
0650   07B3 A7 00         mov bh, 0
0651   07B5 DD            push bl
0652   07B6 07 41 0C      call putchar
0653   07B9 51 01 00      add sp, 1
0654   07BC             ;; fp++; 
0655   07BC FA FD FF      lea d, [bp + -3] ; $fp
0656   07BF 2A            mov b, [d]
0657   07C0 FD 79         mov g, b
0658   07C2 FD 77         inc b
0659   07C4 FA FD FF      lea d, [bp + -3] ; $fp
0660   07C7 FD 43         mov [d], b
0661   07C9 FD 27         mov b, g
0662   07CB             _if8_exit:
0663   07CB             _if7_exit:
0664   07CB             _for6_update:
0665   07CB 0A 6B 06      jmp _for6_cond
0666   07CE             _for6_exit:
0667   07CE F9            leave
0668   07CF 09            ret
0669   07D0             
0670   07D0             printx16:
0671   07D0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0672   07D3             
0673   07D3             ; --- BEGIN INLINE ASM BLOCK
0674   07D3 FA 05 00      lea d, [bp + 5] ; $hex
0675   07D6 2A            mov b, [d]
0676   07D7 07 60 10      call print_u16x
0677   07DA             ; --- END INLINE ASM BLOCK
0678   07DA             
0679   07DA F9            leave
0680   07DB 09            ret
0681   07DC             
0682   07DC             printx8:
0683   07DC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0684   07DF             
0685   07DF             ; --- BEGIN INLINE ASM BLOCK
0686   07DF FA 05 00      lea d, [bp + 5] ; $hex
0687   07E2 32            mov bl, [d]
0688   07E3 07 A4 10      call print_u8x
0689   07E6             ; --- END INLINE ASM BLOCK
0690   07E6             
0691   07E6 F9            leave
0692   07E7 09            ret
0693   07E8             
0694   07E8             hex_to_int:
0695   07E8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0696   07EB             ; $value 
0697   07EB 10 00 00      mov a, $0
0698   07EE 45 FF FF      mov [bp + -1], a
0699   07F1             ; $i 
0700   07F1             ; $hex_char 
0701   07F1             ; $len 
0702   07F1 52 07 00      sub sp, 7
0703   07F4             ;; len = strlen(hex_string); 
0704   07F4 FA FA FF      lea d, [bp + -6] ; $len
0705   07F7 DA            push d
0706   07F8 FA 05 00      lea d, [bp + 5] ; $hex_string
0707   07FB 2A            mov b, [d]
0708   07FC FD AB         swp b
0709   07FE D8            push b
0710   07FF 07 FC 05      call strlen
0711   0802 51 02 00      add sp, 2
0712   0805 E7            pop d
0713   0806 FD 43         mov [d], b
0714   0808             ;; for (i = 0; i < len; i++) { 
0715   0808             _for10_init:
0716   0808 FA FD FF      lea d, [bp + -3] ; $i
0717   080B DA            push d
0718   080C 26 00 00      mov b, $0
0719   080F E7            pop d
0720   0810 FD 43         mov [d], b
0721   0812             _for10_cond:
0722   0812 FA FD FF      lea d, [bp + -3] ; $i
0723   0815 2A            mov b, [d]
0724   0816             ; START RELATIONAL
0725   0816 D7            push a
0726   0817 11            mov a, b
0727   0818 FA FA FF      lea d, [bp + -6] ; $len
0728   081B 2A            mov b, [d]
0729   081C B0            cmp a, b
0730   081D FD 73         slt ; < 
0731   081F E4            pop a
0732   0820             ; END RELATIONAL
0733   0820 C0 00 00      cmp b, 0
0734   0823 C6 28 09      je _for10_exit
0735   0826             _for10_block:
0736   0826             ;; hex_char = hex_string[i]; 
0737   0826 FA FC FF      lea d, [bp + -4] ; $hex_char
0738   0829 DA            push d
0739   082A FA 05 00      lea d, [bp + 5] ; $hex_string
0740   082D FD 2A         mov d, [d]
0741   082F D7            push a
0742   0830 DA            push d
0743   0831 FA FD FF      lea d, [bp + -3] ; $i
0744   0834 2A            mov b, [d]
0745   0835 E7            pop d
0746   0836 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0747   083A E4            pop a
0748   083B 32            mov bl, [d]
0749   083C A7 00         mov bh, 0
0750   083E E7            pop d
0751   083F FD 3E         mov [d], bl
0752   0841             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0753   0841             _if11_cond:
0754   0841 FA FC FF      lea d, [bp + -4] ; $hex_char
0755   0844 32            mov bl, [d]
0756   0845 A7 00         mov bh, 0
0757   0847             ; START RELATIONAL
0758   0847 D7            push a
0759   0848 11            mov a, b
0760   0849 26 61 00      mov b, $61
0761   084C B0            cmp a, b
0762   084D FD 80         sge ; >=
0763   084F E4            pop a
0764   0850             ; END RELATIONAL
0765   0850 D7            push a
0766   0851 11            mov a, b
0767   0852 FA FC FF      lea d, [bp + -4] ; $hex_char
0768   0855 32            mov bl, [d]
0769   0856 A7 00         mov bh, 0
0770   0858             ; START RELATIONAL
0771   0858 D7            push a
0772   0859 11            mov a, b
0773   085A 26 66 00      mov b, $66
0774   085D B0            cmp a, b
0775   085E FD 74         sle ; <=
0776   0860 E4            pop a
0777   0861             ; END RELATIONAL
0778   0861 FD A7         sand a, b ; &&
0779   0863 E4            pop a
0780   0864 C0 00 00      cmp b, 0
0781   0867 C6 98 08      je _if11_else
0782   086A             _if11_true:
0783   086A             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0784   086A FA FF FF      lea d, [bp + -1] ; $value
0785   086D DA            push d
0786   086E FA FF FF      lea d, [bp + -1] ; $value
0787   0871 2A            mov b, [d]
0788   0872             ; START FACTORS
0789   0872 D7            push a
0790   0873 11            mov a, b
0791   0874 26 10 00      mov b, $10
0792   0877 AC            mul a, b ; *
0793   0878 11            mov a, b
0794   0879 27            mov b, a
0795   087A E4            pop a
0796   087B             ; END FACTORS
0797   087B             ; START TERMS
0798   087B D7            push a
0799   087C 11            mov a, b
0800   087D FA FC FF      lea d, [bp + -4] ; $hex_char
0801   0880 32            mov bl, [d]
0802   0881 A7 00         mov bh, 0
0803   0883             ; START TERMS
0804   0883 D7            push a
0805   0884 11            mov a, b
0806   0885 26 61 00      mov b, $61
0807   0888 60            sub a, b
0808   0889 26 0A 00      mov b, $a
0809   088C 54            add a, b
0810   088D 27            mov b, a
0811   088E E4            pop a
0812   088F             ; END TERMS
0813   088F 54            add a, b
0814   0890 27            mov b, a
0815   0891 E4            pop a
0816   0892             ; END TERMS
0817   0892 E7            pop d
0818   0893 FD 43         mov [d], b
0819   0895 0A 16 09      jmp _if11_exit
0820   0898             _if11_else:
0821   0898             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0822   0898             _if12_cond:
0823   0898 FA FC FF      lea d, [bp + -4] ; $hex_char
0824   089B 32            mov bl, [d]
0825   089C A7 00         mov bh, 0
0826   089E             ; START RELATIONAL
0827   089E D7            push a
0828   089F 11            mov a, b
0829   08A0 26 41 00      mov b, $41
0830   08A3 B0            cmp a, b
0831   08A4 FD 80         sge ; >=
0832   08A6 E4            pop a
0833   08A7             ; END RELATIONAL
0834   08A7 D7            push a
0835   08A8 11            mov a, b
0836   08A9 FA FC FF      lea d, [bp + -4] ; $hex_char
0837   08AC 32            mov bl, [d]
0838   08AD A7 00         mov bh, 0
0839   08AF             ; START RELATIONAL
0840   08AF D7            push a
0841   08B0 11            mov a, b
0842   08B1 26 46 00      mov b, $46
0843   08B4 B0            cmp a, b
0844   08B5 FD 74         sle ; <=
0845   08B7 E4            pop a
0846   08B8             ; END RELATIONAL
0847   08B8 FD A7         sand a, b ; &&
0848   08BA E4            pop a
0849   08BB C0 00 00      cmp b, 0
0850   08BE C6 EF 08      je _if12_else
0851   08C1             _if12_true:
0852   08C1             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0853   08C1 FA FF FF      lea d, [bp + -1] ; $value
0854   08C4 DA            push d
0855   08C5 FA FF FF      lea d, [bp + -1] ; $value
0856   08C8 2A            mov b, [d]
0857   08C9             ; START FACTORS
0858   08C9 D7            push a
0859   08CA 11            mov a, b
0860   08CB 26 10 00      mov b, $10
0861   08CE AC            mul a, b ; *
0862   08CF 11            mov a, b
0863   08D0 27            mov b, a
0864   08D1 E4            pop a
0865   08D2             ; END FACTORS
0866   08D2             ; START TERMS
0867   08D2 D7            push a
0868   08D3 11            mov a, b
0869   08D4 FA FC FF      lea d, [bp + -4] ; $hex_char
0870   08D7 32            mov bl, [d]
0871   08D8 A7 00         mov bh, 0
0872   08DA             ; START TERMS
0873   08DA D7            push a
0874   08DB 11            mov a, b
0875   08DC 26 41 00      mov b, $41
0876   08DF 60            sub a, b
0877   08E0 26 0A 00      mov b, $a
0878   08E3 54            add a, b
0879   08E4 27            mov b, a
0880   08E5 E4            pop a
0881   08E6             ; END TERMS
0882   08E6 54            add a, b
0883   08E7 27            mov b, a
0884   08E8 E4            pop a
0885   08E9             ; END TERMS
0886   08E9 E7            pop d
0887   08EA FD 43         mov [d], b
0888   08EC 0A 16 09      jmp _if12_exit
0889   08EF             _if12_else:
0890   08EF             ;; value = (value * 16) + (hex_char - '0'); 
0891   08EF FA FF FF      lea d, [bp + -1] ; $value
0892   08F2 DA            push d
0893   08F3 FA FF FF      lea d, [bp + -1] ; $value
0894   08F6 2A            mov b, [d]
0895   08F7             ; START FACTORS
0896   08F7 D7            push a
0897   08F8 11            mov a, b
0898   08F9 26 10 00      mov b, $10
0899   08FC AC            mul a, b ; *
0900   08FD 11            mov a, b
0901   08FE 27            mov b, a
0902   08FF E4            pop a
0903   0900             ; END FACTORS
0904   0900             ; START TERMS
0905   0900 D7            push a
0906   0901 11            mov a, b
0907   0902 FA FC FF      lea d, [bp + -4] ; $hex_char
0908   0905 32            mov bl, [d]
0909   0906 A7 00         mov bh, 0
0910   0908             ; START TERMS
0911   0908 D7            push a
0912   0909 11            mov a, b
0913   090A 26 30 00      mov b, $30
0914   090D 60            sub a, b
0915   090E 27            mov b, a
0916   090F E4            pop a
0917   0910             ; END TERMS
0918   0910 54            add a, b
0919   0911 27            mov b, a
0920   0912 E4            pop a
0921   0913             ; END TERMS
0922   0913 E7            pop d
0923   0914 FD 43         mov [d], b
0924   0916             _if12_exit:
0925   0916             _if11_exit:
0926   0916             _for10_update:
0927   0916 FA FD FF      lea d, [bp + -3] ; $i
0928   0919 2A            mov b, [d]
0929   091A FD 79         mov g, b
0930   091C FD 77         inc b
0931   091E FA FD FF      lea d, [bp + -3] ; $i
0932   0921 FD 43         mov [d], b
0933   0923 FD 27         mov b, g
0934   0925 0A 12 08      jmp _for10_cond
0935   0928             _for10_exit:
0936   0928             ;; return value; 
0937   0928 FA FF FF      lea d, [bp + -1] ; $value
0938   092B 2A            mov b, [d]
0939   092C F9            leave
0940   092D 09            ret
0941   092E             
0942   092E             atoi:
0943   092E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0944   0931             ; $result 
0945   0931 10 00 00      mov a, $0
0946   0934 45 FF FF      mov [bp + -1], a
0947   0937             ; $sign 
0948   0937 10 01 00      mov a, $1
0949   093A 45 FD FF      mov [bp + -3], a
0950   093D 52 04 00      sub sp, 4
0951   0940             ;; while (*str == ' ') str++; 
0952   0940             _while13_cond:
0953   0940 FA 05 00      lea d, [bp + 5] ; $str
0954   0943 2A            mov b, [d]
0955   0944 74            mov d, b
0956   0945 32            mov bl, [d]
0957   0946 A7 00         mov bh, 0
0958   0948             ; START RELATIONAL
0959   0948 D7            push a
0960   0949 11            mov a, b
0961   094A 26 20 00      mov b, $20
0962   094D B0            cmp a, b
0963   094E FD 71         seq ; ==
0964   0950 E4            pop a
0965   0951             ; END RELATIONAL
0966   0951 C0 00 00      cmp b, 0
0967   0954 C6 69 09      je _while13_exit
0968   0957             _while13_block:
0969   0957             ;; str++; 
0970   0957 FA 05 00      lea d, [bp + 5] ; $str
0971   095A 2A            mov b, [d]
0972   095B FD 79         mov g, b
0973   095D FD 77         inc b
0974   095F FA 05 00      lea d, [bp + 5] ; $str
0975   0962 FD 43         mov [d], b
0976   0964 FD 27         mov b, g
0977   0966 0A 40 09      jmp _while13_cond
0978   0969             _while13_exit:
0979   0969             ;; if (*str == '-' || *str == '+') { 
0980   0969             _if14_cond:
0981   0969 FA 05 00      lea d, [bp + 5] ; $str
0982   096C 2A            mov b, [d]
0983   096D 74            mov d, b
0984   096E 32            mov bl, [d]
0985   096F A7 00         mov bh, 0
0986   0971             ; START RELATIONAL
0987   0971 D7            push a
0988   0972 11            mov a, b
0989   0973 26 2D 00      mov b, $2d
0990   0976 B0            cmp a, b
0991   0977 FD 71         seq ; ==
0992   0979 E4            pop a
0993   097A             ; END RELATIONAL
0994   097A D7            push a
0995   097B 11            mov a, b
0996   097C FA 05 00      lea d, [bp + 5] ; $str
0997   097F 2A            mov b, [d]
0998   0980 74            mov d, b
0999   0981 32            mov bl, [d]
1000   0982 A7 00         mov bh, 0
1001   0984             ; START RELATIONAL
1002   0984 D7            push a
1003   0985 11            mov a, b
1004   0986 26 2B 00      mov b, $2b
1005   0989 B0            cmp a, b
1006   098A FD 71         seq ; ==
1007   098C E4            pop a
1008   098D             ; END RELATIONAL
1009   098D FD A8         sor a, b ; ||
1010   098F E4            pop a
1011   0990 C0 00 00      cmp b, 0
1012   0993 C6 CE 09      je _if14_exit
1013   0996             _if14_true:
1014   0996             ;; if (*str == '-') sign = -1; 
1015   0996             _if15_cond:
1016   0996 FA 05 00      lea d, [bp + 5] ; $str
1017   0999 2A            mov b, [d]
1018   099A 74            mov d, b
1019   099B 32            mov bl, [d]
1020   099C A7 00         mov bh, 0
1021   099E             ; START RELATIONAL
1022   099E D7            push a
1023   099F 11            mov a, b
1024   09A0 26 2D 00      mov b, $2d
1025   09A3 B0            cmp a, b
1026   09A4 FD 71         seq ; ==
1027   09A6 E4            pop a
1028   09A7             ; END RELATIONAL
1029   09A7 C0 00 00      cmp b, 0
1030   09AA C6 BC 09      je _if15_exit
1031   09AD             _if15_true:
1032   09AD             ;; sign = -1; 
1033   09AD FA FD FF      lea d, [bp + -3] ; $sign
1034   09B0 DA            push d
1035   09B1 26 01 00      mov b, $1
1036   09B4 FD 97         neg b
1037   09B6 E7            pop d
1038   09B7 FD 43         mov [d], b
1039   09B9 0A BC 09      jmp _if15_exit
1040   09BC             _if15_exit:
1041   09BC             ;; str++; 
1042   09BC FA 05 00      lea d, [bp + 5] ; $str
1043   09BF 2A            mov b, [d]
1044   09C0 FD 79         mov g, b
1045   09C2 FD 77         inc b
1046   09C4 FA 05 00      lea d, [bp + 5] ; $str
1047   09C7 FD 43         mov [d], b
1048   09C9 FD 27         mov b, g
1049   09CB 0A CE 09      jmp _if14_exit
1050   09CE             _if14_exit:
1051   09CE             ;; while (*str >= '0' && *str <= '9') { 
1052   09CE             _while16_cond:
1053   09CE FA 05 00      lea d, [bp + 5] ; $str
1054   09D1 2A            mov b, [d]
1055   09D2 74            mov d, b
1056   09D3 32            mov bl, [d]
1057   09D4 A7 00         mov bh, 0
1058   09D6             ; START RELATIONAL
1059   09D6 D7            push a
1060   09D7 11            mov a, b
1061   09D8 26 30 00      mov b, $30
1062   09DB B0            cmp a, b
1063   09DC FD 80         sge ; >=
1064   09DE E4            pop a
1065   09DF             ; END RELATIONAL
1066   09DF D7            push a
1067   09E0 11            mov a, b
1068   09E1 FA 05 00      lea d, [bp + 5] ; $str
1069   09E4 2A            mov b, [d]
1070   09E5 74            mov d, b
1071   09E6 32            mov bl, [d]
1072   09E7 A7 00         mov bh, 0
1073   09E9             ; START RELATIONAL
1074   09E9 D7            push a
1075   09EA 11            mov a, b
1076   09EB 26 39 00      mov b, $39
1077   09EE B0            cmp a, b
1078   09EF FD 74         sle ; <=
1079   09F1 E4            pop a
1080   09F2             ; END RELATIONAL
1081   09F2 FD A7         sand a, b ; &&
1082   09F4 E4            pop a
1083   09F5 C0 00 00      cmp b, 0
1084   09F8 C6 36 0A      je _while16_exit
1085   09FB             _while16_block:
1086   09FB             ;; result = result * 10 + (*str - '0'); 
1087   09FB FA FF FF      lea d, [bp + -1] ; $result
1088   09FE DA            push d
1089   09FF FA FF FF      lea d, [bp + -1] ; $result
1090   0A02 2A            mov b, [d]
1091   0A03             ; START FACTORS
1092   0A03 D7            push a
1093   0A04 11            mov a, b
1094   0A05 26 0A 00      mov b, $a
1095   0A08 AC            mul a, b ; *
1096   0A09 11            mov a, b
1097   0A0A 27            mov b, a
1098   0A0B E4            pop a
1099   0A0C             ; END FACTORS
1100   0A0C             ; START TERMS
1101   0A0C D7            push a
1102   0A0D 11            mov a, b
1103   0A0E FA 05 00      lea d, [bp + 5] ; $str
1104   0A11 2A            mov b, [d]
1105   0A12 74            mov d, b
1106   0A13 32            mov bl, [d]
1107   0A14 A7 00         mov bh, 0
1108   0A16             ; START TERMS
1109   0A16 D7            push a
1110   0A17 11            mov a, b
1111   0A18 26 30 00      mov b, $30
1112   0A1B 60            sub a, b
1113   0A1C 27            mov b, a
1114   0A1D E4            pop a
1115   0A1E             ; END TERMS
1116   0A1E 54            add a, b
1117   0A1F 27            mov b, a
1118   0A20 E4            pop a
1119   0A21             ; END TERMS
1120   0A21 E7            pop d
1121   0A22 FD 43         mov [d], b
1122   0A24             ;; str++; 
1123   0A24 FA 05 00      lea d, [bp + 5] ; $str
1124   0A27 2A            mov b, [d]
1125   0A28 FD 79         mov g, b
1126   0A2A FD 77         inc b
1127   0A2C FA 05 00      lea d, [bp + 5] ; $str
1128   0A2F FD 43         mov [d], b
1129   0A31 FD 27         mov b, g
1130   0A33 0A CE 09      jmp _while16_cond
1131   0A36             _while16_exit:
1132   0A36             ;; return sign * result; 
1133   0A36 FA FD FF      lea d, [bp + -3] ; $sign
1134   0A39 2A            mov b, [d]
1135   0A3A             ; START FACTORS
1136   0A3A D7            push a
1137   0A3B 11            mov a, b
1138   0A3C FA FF FF      lea d, [bp + -1] ; $result
1139   0A3F 2A            mov b, [d]
1140   0A40 AC            mul a, b ; *
1141   0A41 11            mov a, b
1142   0A42 27            mov b, a
1143   0A43 E4            pop a
1144   0A44             ; END FACTORS
1145   0A44 F9            leave
1146   0A45 09            ret
1147   0A46             
1148   0A46             gets:
1149   0A46 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1150   0A49             
1151   0A49             ; --- BEGIN INLINE ASM BLOCK
1152   0A49 FA 05 00      lea d, [bp + 5] ; $s
1153   0A4C 15            mov a, [d]
1154   0A4D 3C            mov d, a
1155   0A4E 07 C5 0E      call _gets
1156   0A51             ; --- END INLINE ASM BLOCK
1157   0A51             
1158   0A51             ;; return strlen(s); 
1159   0A51 FA 05 00      lea d, [bp + 5] ; $s
1160   0A54 2A            mov b, [d]
1161   0A55 FD AB         swp b
1162   0A57 D8            push b
1163   0A58 07 FC 05      call strlen
1164   0A5B 51 02 00      add sp, 2
1165   0A5E F9            leave
1166   0A5F 09            ret
1167   0A60             
1168   0A60             prints:
1169   0A60 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1170   0A63             ; $digits 
1171   0A63             ; $i 
1172   0A63 10 00 00      mov a, $0
1173   0A66 45 FA FF      mov [bp + -6], a
1174   0A69 52 07 00      sub sp, 7
1175   0A6C             ;; if (num < 0) { 
1176   0A6C             _if17_cond:
1177   0A6C FA 05 00      lea d, [bp + 5] ; $num
1178   0A6F 2A            mov b, [d]
1179   0A70             ; START RELATIONAL
1180   0A70 D7            push a
1181   0A71 11            mov a, b
1182   0A72 26 00 00      mov b, $0
1183   0A75 B0            cmp a, b
1184   0A76 FD 73         slt ; < 
1185   0A78 E4            pop a
1186   0A79             ; END RELATIONAL
1187   0A79 C0 00 00      cmp b, 0
1188   0A7C C6 99 0A      je _if17_else
1189   0A7F             _if17_true:
1190   0A7F             ;; putchar('-'); 
1191   0A7F 26 2D 00      mov b, $2d
1192   0A82 DD            push bl
1193   0A83 07 41 0C      call putchar
1194   0A86 51 01 00      add sp, 1
1195   0A89             ;; num = -num; 
1196   0A89 FA 05 00      lea d, [bp + 5] ; $num
1197   0A8C DA            push d
1198   0A8D FA 05 00      lea d, [bp + 5] ; $num
1199   0A90 2A            mov b, [d]
1200   0A91 FD 97         neg b
1201   0A93 E7            pop d
1202   0A94 FD 43         mov [d], b
1203   0A96 0A BB 0A      jmp _if17_exit
1204   0A99             _if17_else:
1205   0A99             ;; if (num == 0) { 
1206   0A99             _if18_cond:
1207   0A99 FA 05 00      lea d, [bp + 5] ; $num
1208   0A9C 2A            mov b, [d]
1209   0A9D             ; START RELATIONAL
1210   0A9D D7            push a
1211   0A9E 11            mov a, b
1212   0A9F 26 00 00      mov b, $0
1213   0AA2 B0            cmp a, b
1214   0AA3 FD 71         seq ; ==
1215   0AA5 E4            pop a
1216   0AA6             ; END RELATIONAL
1217   0AA6 C0 00 00      cmp b, 0
1218   0AA9 C6 BB 0A      je _if18_exit
1219   0AAC             _if18_true:
1220   0AAC             ;; putchar('0'); 
1221   0AAC 26 30 00      mov b, $30
1222   0AAF DD            push bl
1223   0AB0 07 41 0C      call putchar
1224   0AB3 51 01 00      add sp, 1
1225   0AB6             ;; return; 
1226   0AB6 F9            leave
1227   0AB7 09            ret
1228   0AB8 0A BB 0A      jmp _if18_exit
1229   0ABB             _if18_exit:
1230   0ABB             _if17_exit:
1231   0ABB             ;; while (num > 0) { 
1232   0ABB             _while19_cond:
1233   0ABB FA 05 00      lea d, [bp + 5] ; $num
1234   0ABE 2A            mov b, [d]
1235   0ABF             ; START RELATIONAL
1236   0ABF D7            push a
1237   0AC0 11            mov a, b
1238   0AC1 26 00 00      mov b, $0
1239   0AC4 B0            cmp a, b
1240   0AC5 FD 7F         sgt ; >
1241   0AC7 E4            pop a
1242   0AC8             ; END RELATIONAL
1243   0AC8 C0 00 00      cmp b, 0
1244   0ACB C6 18 0B      je _while19_exit
1245   0ACE             _while19_block:
1246   0ACE             ;; digits[i] = '0' + (num % 10); 
1247   0ACE FA FC FF      lea d, [bp + -4] ; $digits
1248   0AD1 D7            push a
1249   0AD2 DA            push d
1250   0AD3 FA FA FF      lea d, [bp + -6] ; $i
1251   0AD6 2A            mov b, [d]
1252   0AD7 E7            pop d
1253   0AD8 5A            add d, b
1254   0AD9 E4            pop a
1255   0ADA DA            push d
1256   0ADB 26 30 00      mov b, $30
1257   0ADE             ; START TERMS
1258   0ADE D7            push a
1259   0ADF 11            mov a, b
1260   0AE0 FA 05 00      lea d, [bp + 5] ; $num
1261   0AE3 2A            mov b, [d]
1262   0AE4             ; START FACTORS
1263   0AE4 D7            push a
1264   0AE5 11            mov a, b
1265   0AE6 26 0A 00      mov b, $a
1266   0AE9 AE            div a, b ; 
1267   0AEA 11            mov a, b
1268   0AEB 27            mov b, a
1269   0AEC E4            pop a
1270   0AED             ; END FACTORS
1271   0AED 54            add a, b
1272   0AEE 27            mov b, a
1273   0AEF E4            pop a
1274   0AF0             ; END TERMS
1275   0AF0 E7            pop d
1276   0AF1 FD 3E         mov [d], bl
1277   0AF3             ;; num = num / 10; 
1278   0AF3 FA 05 00      lea d, [bp + 5] ; $num
1279   0AF6 DA            push d
1280   0AF7 FA 05 00      lea d, [bp + 5] ; $num
1281   0AFA 2A            mov b, [d]
1282   0AFB             ; START FACTORS
1283   0AFB D7            push a
1284   0AFC 11            mov a, b
1285   0AFD 26 0A 00      mov b, $a
1286   0B00 AE            div a, b
1287   0B01 27            mov b, a
1288   0B02 E4            pop a
1289   0B03             ; END FACTORS
1290   0B03 E7            pop d
1291   0B04 FD 43         mov [d], b
1292   0B06             ;; i++; 
1293   0B06 FA FA FF      lea d, [bp + -6] ; $i
1294   0B09 2A            mov b, [d]
1295   0B0A FD 79         mov g, b
1296   0B0C FD 77         inc b
1297   0B0E FA FA FF      lea d, [bp + -6] ; $i
1298   0B11 FD 43         mov [d], b
1299   0B13 FD 27         mov b, g
1300   0B15 0A BB 0A      jmp _while19_cond
1301   0B18             _while19_exit:
1302   0B18             ;; while (i > 0) { 
1303   0B18             _while20_cond:
1304   0B18 FA FA FF      lea d, [bp + -6] ; $i
1305   0B1B 2A            mov b, [d]
1306   0B1C             ; START RELATIONAL
1307   0B1C D7            push a
1308   0B1D 11            mov a, b
1309   0B1E 26 00 00      mov b, $0
1310   0B21 B0            cmp a, b
1311   0B22 FD 7F         sgt ; >
1312   0B24 E4            pop a
1313   0B25             ; END RELATIONAL
1314   0B25 C0 00 00      cmp b, 0
1315   0B28 C6 53 0B      je _while20_exit
1316   0B2B             _while20_block:
1317   0B2B             ;; i--; 
1318   0B2B FA FA FF      lea d, [bp + -6] ; $i
1319   0B2E 2A            mov b, [d]
1320   0B2F FD 79         mov g, b
1321   0B31 FD 7D         dec b
1322   0B33 FA FA FF      lea d, [bp + -6] ; $i
1323   0B36 FD 43         mov [d], b
1324   0B38 FD 27         mov b, g
1325   0B3A             ;; putchar(digits[i]); 
1326   0B3A FA FC FF      lea d, [bp + -4] ; $digits
1327   0B3D D7            push a
1328   0B3E DA            push d
1329   0B3F FA FA FF      lea d, [bp + -6] ; $i
1330   0B42 2A            mov b, [d]
1331   0B43 E7            pop d
1332   0B44 5A            add d, b
1333   0B45 E4            pop a
1334   0B46 32            mov bl, [d]
1335   0B47 A7 00         mov bh, 0
1336   0B49 DD            push bl
1337   0B4A 07 41 0C      call putchar
1338   0B4D 51 01 00      add sp, 1
1339   0B50 0A 18 0B      jmp _while20_cond
1340   0B53             _while20_exit:
1341   0B53 F9            leave
1342   0B54 09            ret
1343   0B55             
1344   0B55             printu:
1345   0B55 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1346   0B58             ; $digits 
1347   0B58             ; $i 
1348   0B58 52 07 00      sub sp, 7
1349   0B5B             ;; i = 0; 
1350   0B5B FA FA FF      lea d, [bp + -6] ; $i
1351   0B5E DA            push d
1352   0B5F 26 00 00      mov b, $0
1353   0B62 E7            pop d
1354   0B63 FD 43         mov [d], b
1355   0B65             ;; if(num == 0){ 
1356   0B65             _if21_cond:
1357   0B65 FA 05 00      lea d, [bp + 5] ; $num
1358   0B68 2A            mov b, [d]
1359   0B69             ; START RELATIONAL
1360   0B69 D7            push a
1361   0B6A 11            mov a, b
1362   0B6B 26 00 00      mov b, $0
1363   0B6E B0            cmp a, b
1364   0B6F FD 71         seq ; ==
1365   0B71 E4            pop a
1366   0B72             ; END RELATIONAL
1367   0B72 C0 00 00      cmp b, 0
1368   0B75 C6 87 0B      je _if21_exit
1369   0B78             _if21_true:
1370   0B78             ;; putchar('0'); 
1371   0B78 26 30 00      mov b, $30
1372   0B7B DD            push bl
1373   0B7C 07 41 0C      call putchar
1374   0B7F 51 01 00      add sp, 1
1375   0B82             ;; return; 
1376   0B82 F9            leave
1377   0B83 09            ret
1378   0B84 0A 87 0B      jmp _if21_exit
1379   0B87             _if21_exit:
1380   0B87             ;; while (num > 0) { 
1381   0B87             _while22_cond:
1382   0B87 FA 05 00      lea d, [bp + 5] ; $num
1383   0B8A 2A            mov b, [d]
1384   0B8B             ; START RELATIONAL
1385   0B8B D7            push a
1386   0B8C 11            mov a, b
1387   0B8D 26 00 00      mov b, $0
1388   0B90 B0            cmp a, b
1389   0B91 FD 81         sgu ; > (unsigned)
1390   0B93 E4            pop a
1391   0B94             ; END RELATIONAL
1392   0B94 C0 00 00      cmp b, 0
1393   0B97 C6 E4 0B      je _while22_exit
1394   0B9A             _while22_block:
1395   0B9A             ;; digits[i] = '0' + (num % 10); 
1396   0B9A FA FC FF      lea d, [bp + -4] ; $digits
1397   0B9D D7            push a
1398   0B9E DA            push d
1399   0B9F FA FA FF      lea d, [bp + -6] ; $i
1400   0BA2 2A            mov b, [d]
1401   0BA3 E7            pop d
1402   0BA4 5A            add d, b
1403   0BA5 E4            pop a
1404   0BA6 DA            push d
1405   0BA7 26 30 00      mov b, $30
1406   0BAA             ; START TERMS
1407   0BAA D7            push a
1408   0BAB 11            mov a, b
1409   0BAC FA 05 00      lea d, [bp + 5] ; $num
1410   0BAF 2A            mov b, [d]
1411   0BB0             ; START FACTORS
1412   0BB0 D7            push a
1413   0BB1 11            mov a, b
1414   0BB2 26 0A 00      mov b, $a
1415   0BB5 AE            div a, b ; 
1416   0BB6 11            mov a, b
1417   0BB7 27            mov b, a
1418   0BB8 E4            pop a
1419   0BB9             ; END FACTORS
1420   0BB9 54            add a, b
1421   0BBA 27            mov b, a
1422   0BBB E4            pop a
1423   0BBC             ; END TERMS
1424   0BBC E7            pop d
1425   0BBD FD 3E         mov [d], bl
1426   0BBF             ;; num = num / 10; 
1427   0BBF FA 05 00      lea d, [bp + 5] ; $num
1428   0BC2 DA            push d
1429   0BC3 FA 05 00      lea d, [bp + 5] ; $num
1430   0BC6 2A            mov b, [d]
1431   0BC7             ; START FACTORS
1432   0BC7 D7            push a
1433   0BC8 11            mov a, b
1434   0BC9 26 0A 00      mov b, $a
1435   0BCC AE            div a, b
1436   0BCD 27            mov b, a
1437   0BCE E4            pop a
1438   0BCF             ; END FACTORS
1439   0BCF E7            pop d
1440   0BD0 FD 43         mov [d], b
1441   0BD2             ;; i++; 
1442   0BD2 FA FA FF      lea d, [bp + -6] ; $i
1443   0BD5 2A            mov b, [d]
1444   0BD6 FD 79         mov g, b
1445   0BD8 FD 77         inc b
1446   0BDA FA FA FF      lea d, [bp + -6] ; $i
1447   0BDD FD 43         mov [d], b
1448   0BDF FD 27         mov b, g
1449   0BE1 0A 87 0B      jmp _while22_cond
1450   0BE4             _while22_exit:
1451   0BE4             ;; while (i > 0) { 
1452   0BE4             _while23_cond:
1453   0BE4 FA FA FF      lea d, [bp + -6] ; $i
1454   0BE7 2A            mov b, [d]
1455   0BE8             ; START RELATIONAL
1456   0BE8 D7            push a
1457   0BE9 11            mov a, b
1458   0BEA 26 00 00      mov b, $0
1459   0BED B0            cmp a, b
1460   0BEE FD 7F         sgt ; >
1461   0BF0 E4            pop a
1462   0BF1             ; END RELATIONAL
1463   0BF1 C0 00 00      cmp b, 0
1464   0BF4 C6 1F 0C      je _while23_exit
1465   0BF7             _while23_block:
1466   0BF7             ;; i--; 
1467   0BF7 FA FA FF      lea d, [bp + -6] ; $i
1468   0BFA 2A            mov b, [d]
1469   0BFB FD 79         mov g, b
1470   0BFD FD 7D         dec b
1471   0BFF FA FA FF      lea d, [bp + -6] ; $i
1472   0C02 FD 43         mov [d], b
1473   0C04 FD 27         mov b, g
1474   0C06             ;; putchar(digits[i]); 
1475   0C06 FA FC FF      lea d, [bp + -4] ; $digits
1476   0C09 D7            push a
1477   0C0A DA            push d
1478   0C0B FA FA FF      lea d, [bp + -6] ; $i
1479   0C0E 2A            mov b, [d]
1480   0C0F E7            pop d
1481   0C10 5A            add d, b
1482   0C11 E4            pop a
1483   0C12 32            mov bl, [d]
1484   0C13 A7 00         mov bh, 0
1485   0C15 DD            push bl
1486   0C16 07 41 0C      call putchar
1487   0C19 51 01 00      add sp, 1
1488   0C1C 0A E4 0B      jmp _while23_cond
1489   0C1F             _while23_exit:
1490   0C1F F9            leave
1491   0C20 09            ret
1492   0C21             
1493   0C21             rand:
1494   0C21 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1495   0C24             ; $sec 
1496   0C24 52 01 00      sub sp, 1
1497   0C27             
1498   0C27             ; --- BEGIN INLINE ASM BLOCK
1499   0C27 19 00         mov al, 0
1500   0C29 05 01         syscall sys_rtc					
1501   0C2B 1A            mov al, ah
1502   0C2C FA 00 00      lea d, [bp + 0] ; $sec
1503   0C2F 1E            mov al, [d]
1504   0C30             ; --- END INLINE ASM BLOCK
1505   0C30             
1506   0C30             ;; return sec; 
1507   0C30 FA 00 00      lea d, [bp + 0] ; $sec
1508   0C33 32            mov bl, [d]
1509   0C34 A7 00         mov bh, 0
1510   0C36 F9            leave
1511   0C37 09            ret
1512   0C38             
1513   0C38             date:
1514   0C38 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1515   0C3B             
1516   0C3B             ; --- BEGIN INLINE ASM BLOCK
1517   0C3B 19 00         mov al, 0 
1518   0C3D 05 07         syscall sys_datetime
1519   0C3F             ; --- END INLINE ASM BLOCK
1520   0C3F             
1521   0C3F F9            leave
1522   0C40 09            ret
1523   0C41             
1524   0C41             putchar:
1525   0C41 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1526   0C44             
1527   0C44             ; --- BEGIN INLINE ASM BLOCK
1528   0C44 FA 05 00      lea d, [bp + 5] ; $c
1529   0C47 1E            mov al, [d]
1530   0C48 23            mov ah, al
1531   0C49 07 BE 0E      call _putchar
1532   0C4C             ; --- END INLINE ASM BLOCK
1533   0C4C             
1534   0C4C F9            leave
1535   0C4D 09            ret
1536   0C4E             
1537   0C4E             getchar:
1538   0C4E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1539   0C51             ; $c 
1540   0C51 52 01 00      sub sp, 1
1541   0C54             
1542   0C54             ; --- BEGIN INLINE ASM BLOCK
1543   0C54 07 B7 0E      call getch
1544   0C57 1A            mov al, ah
1545   0C58 FA 00 00      lea d, [bp + 0] ; $c
1546   0C5B 3E            mov [d], al
1547   0C5C             ; --- END INLINE ASM BLOCK
1548   0C5C             
1549   0C5C             ;; return c; 
1550   0C5C FA 00 00      lea d, [bp + 0] ; $c
1551   0C5F 32            mov bl, [d]
1552   0C60 A7 00         mov bh, 0
1553   0C62 F9            leave
1554   0C63 09            ret
1555   0C64             
1556   0C64             scann:
1557   0C64 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1558   0C67             ; $m 
1559   0C67 52 02 00      sub sp, 2
1560   0C6A             
1561   0C6A             ; --- BEGIN INLINE ASM BLOCK
1562   0C6A 07 02 11      call scan_u16d
1563   0C6D FA FF FF      lea d, [bp + -1] ; $m
1564   0C70 43            mov [d], a
1565   0C71             ; --- END INLINE ASM BLOCK
1566   0C71             
1567   0C71             ;; return m; 
1568   0C71 FA FF FF      lea d, [bp + -1] ; $m
1569   0C74 2A            mov b, [d]
1570   0C75 F9            leave
1571   0C76 09            ret
1572   0C77             
1573   0C77             puts:
1574   0C77 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1575   0C7A             
1576   0C7A             ; --- BEGIN INLINE ASM BLOCK
1577   0C7A FA 05 00      lea d, [bp + 5] ; $s
1578   0C7D 15            mov a, [d]
1579   0C7E 3C            mov d, a
1580   0C7F 07 08 10      call _puts
1581   0C82 10 00 0A      mov a, $0A00
1582   0C85 05 03         syscall sys_io
1583   0C87             ; --- END INLINE ASM BLOCK
1584   0C87             
1585   0C87 F9            leave
1586   0C88 09            ret
1587   0C89             
1588   0C89             print:
1589   0C89 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1590   0C8C             
1591   0C8C             ; --- BEGIN INLINE ASM BLOCK
1592   0C8C FA 05 00      lea d, [bp + 5] ; $s
1593   0C8F FD 2A         mov d, [d]
1594   0C91 07 08 10      call _puts
1595   0C94             ; --- END INLINE ASM BLOCK
1596   0C94             
1597   0C94 F9            leave
1598   0C95 09            ret
1599   0C96             
1600   0C96             loadfile:
1601   0C96 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1602   0C99             
1603   0C99             ; --- BEGIN INLINE ASM BLOCK
1604   0C99 FA 05 00      lea d, [bp + 5] ; $destination
1605   0C9C 15            mov a, [d]
1606   0C9D 4F            mov di, a
1607   0C9E FA 07 00      lea d, [bp + 7] ; $filename
1608   0CA1 FD 2A         mov d, [d]
1609   0CA3 19 14         mov al, 20
1610   0CA5 05 04         syscall sys_filesystem
1611   0CA7             ; --- END INLINE ASM BLOCK
1612   0CA7             
1613   0CA7 F9            leave
1614   0CA8 09            ret
1615   0CA9             
1616   0CA9             create_file:
1617   0CA9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1618   0CAC F9            leave
1619   0CAD 09            ret
1620   0CAE             
1621   0CAE             delete_file:
1622   0CAE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1623   0CB1             
1624   0CB1             ; --- BEGIN INLINE ASM BLOCK
1625   0CB1 FA 05 00      lea d, [bp + 5] ; $filename
1626   0CB4 19 0A         mov al, 10
1627   0CB6 05 04         syscall sys_filesystem
1628   0CB8             ; --- END INLINE ASM BLOCK
1629   0CB8             
1630   0CB8 F9            leave
1631   0CB9 09            ret
1632   0CBA             
1633   0CBA             fopen:
1634   0CBA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1635   0CBD F9            leave
1636   0CBE 09            ret
1637   0CBF             
1638   0CBF             fclose:
1639   0CBF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1640   0CC2 F9            leave
1641   0CC3 09            ret
1642   0CC4             
1643   0CC4             alloc:
1644   0CC4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1645   0CC7             ;; heap_top = heap_top + bytes; 
1646   0CC7 3B 7B 14      mov d, _heap_top ; $heap_top
1647   0CCA DA            push d
1648   0CCB 3B 7B 14      mov d, _heap_top ; $heap_top
1649   0CCE 2A            mov b, [d]
1650   0CCF             ; START TERMS
1651   0CCF D7            push a
1652   0CD0 11            mov a, b
1653   0CD1 FA 05 00      lea d, [bp + 5] ; $bytes
1654   0CD4 2A            mov b, [d]
1655   0CD5 54            add a, b
1656   0CD6 27            mov b, a
1657   0CD7 E4            pop a
1658   0CD8             ; END TERMS
1659   0CD8 E7            pop d
1660   0CD9 FD 43         mov [d], b
1661   0CDB             ;; return heap_top - bytes; 
1662   0CDB 3B 7B 14      mov d, _heap_top ; $heap_top
1663   0CDE 2A            mov b, [d]
1664   0CDF             ; START TERMS
1665   0CDF D7            push a
1666   0CE0 11            mov a, b
1667   0CE1 FA 05 00      lea d, [bp + 5] ; $bytes
1668   0CE4 2A            mov b, [d]
1669   0CE5 60            sub a, b
1670   0CE6 27            mov b, a
1671   0CE7 E4            pop a
1672   0CE8             ; END TERMS
1673   0CE8 F9            leave
1674   0CE9 09            ret
1675   0CEA             
1676   0CEA             free:
1677   0CEA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1678   0CED             ;; return heap_top = heap_top - bytes; 
1679   0CED 3B 7B 14      mov d, _heap_top ; $heap_top
1680   0CF0 DA            push d
1681   0CF1 3B 7B 14      mov d, _heap_top ; $heap_top
1682   0CF4 2A            mov b, [d]
1683   0CF5             ; START TERMS
1684   0CF5 D7            push a
1685   0CF6 11            mov a, b
1686   0CF7 FA 05 00      lea d, [bp + 5] ; $bytes
1687   0CFA 2A            mov b, [d]
1688   0CFB 60            sub a, b
1689   0CFC 27            mov b, a
1690   0CFD E4            pop a
1691   0CFE             ; END TERMS
1692   0CFE E7            pop d
1693   0CFF FD 43         mov [d], b
1694   0D01 F9            leave
1695   0D02 09            ret
1696   0D03             
1697   0D03             exit:
1698   0D03 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1699   0D06             
1700   0D06             ; --- BEGIN INLINE ASM BLOCK
1701   0D06 05 0B         syscall sys_terminate_proc
1702   0D08             ; --- END INLINE ASM BLOCK
1703   0D08             
1704   0D08 F9            leave
1705   0D09 09            ret
1706   0D0A             
1707   0D0A             load_hex:
1708   0D0A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1709   0D0D             ; $temp 
1710   0D0D 52 02 00      sub sp, 2
1711   0D10             ;; temp = alloc(32768); 
1712   0D10 FA FF FF      lea d, [bp + -1] ; $temp
1713   0D13 DA            push d
1714   0D14 26 00 80      mov b, $8000
1715   0D17 FD AB         swp b
1716   0D19 D8            push b
1717   0D1A 07 C4 0C      call alloc
1718   0D1D 51 02 00      add sp, 2
1719   0D20 E7            pop d
1720   0D21 FD 43         mov [d], b
1721   0D23             
1722   0D23             ; --- BEGIN INLINE ASM BLOCK
1723   0D23               
1724   0D23               
1725   0D23               
1726   0D23               
1727   0D23               
1728   0D23             _load_hex:
1729   0D23 D7            push a
1730   0D24 D8            push b
1731   0D25 DA            push d
1732   0D26 E2            push si
1733   0D27 E3            push di
1734   0D28 52 00 80      sub sp, $8000      
1735   0D2B 38 00 00      mov c, 0
1736   0D2E 48            mov a, sp
1737   0D2F 77            inc a
1738   0D30 3C            mov d, a          
1739   0D31 07 C5 0E      call _gets        
1740   0D34 4D            mov si, a
1741   0D35             __load_hex_loop:
1742   0D35 F6            lodsb             
1743   0D36 B9 00         cmp al, 0         
1744   0D38 C6 46 0D      jz __load_hex_ret
1745   0D3B 36            mov bh, al
1746   0D3C F6            lodsb
1747   0D3D 2F            mov bl, al
1748   0D3E 07 7B 0E      call _atoi        
1749   0D41 F7            stosb             
1750   0D42 78            inc c
1751   0D43 0A 35 0D      jmp __load_hex_loop
1752   0D46             __load_hex_ret:
1753   0D46 51 00 80      add sp, $8000
1754   0D49 F0            pop di
1755   0D4A EF            pop si
1756   0D4B E7            pop d
1757   0D4C E5            pop b
1758   0D4D E4            pop a
1759   0D4E             ; --- END INLINE ASM BLOCK
1760   0D4E             
1761   0D4E F9            leave
1762   0D4F 09            ret
1763   0D50             
1764   0D50             getparam:
1765   0D50 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1766   0D53             ; $data 
1767   0D53 52 01 00      sub sp, 1
1768   0D56             
1769   0D56             ; --- BEGIN INLINE ASM BLOCK
1770   0D56 19 04         mov al, 4
1771   0D58 FA 05 00      lea d, [bp + 5] ; $address
1772   0D5B FD 2A         mov d, [d]
1773   0D5D 05 0C         syscall sys_system
1774   0D5F FA 00 00      lea d, [bp + 0] ; $data
1775   0D62 FD 3E         mov [d], bl
1776   0D64             ; --- END INLINE ASM BLOCK
1777   0D64             
1778   0D64             ;; return data; 
1779   0D64 FA 00 00      lea d, [bp + 0] ; $data
1780   0D67 32            mov bl, [d]
1781   0D68 A7 00         mov bh, 0
1782   0D6A F9            leave
1783   0D6B 09            ret
1784   0D6C             
1785   0D6C             clear:
1786   0D6C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1787   0D6F             ;; print("\033[2J\033[H"); 
1788   0D6F 26 73 14      mov b, __s3 ; "\033[2J\033[H"
1789   0D72 FD AB         swp b
1790   0D74 D8            push b
1791   0D75 07 89 0C      call print
1792   0D78 51 02 00      add sp, 2
1793   0D7B F9            leave
1794   0D7C 09            ret
1795   0D7D             
1796   0D7D             printun:
1797   0D7D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1798   0D80             ;; print(prompt); 
1799   0D80 FA 07 00      lea d, [bp + 7] ; $prompt
1800   0D83 2A            mov b, [d]
1801   0D84 FD AB         swp b
1802   0D86 D8            push b
1803   0D87 07 89 0C      call print
1804   0D8A 51 02 00      add sp, 2
1805   0D8D             ;; printu(n); 
1806   0D8D FA 05 00      lea d, [bp + 5] ; $n
1807   0D90 2A            mov b, [d]
1808   0D91 FD AB         swp b
1809   0D93 D8            push b
1810   0D94 07 55 0B      call printu
1811   0D97 51 02 00      add sp, 2
1812   0D9A             ;; print("\n"); 
1813   0D9A 26 52 14      mov b, __s1 ; "\n"
1814   0D9D FD AB         swp b
1815   0D9F D8            push b
1816   0DA0 07 89 0C      call print
1817   0DA3 51 02 00      add sp, 2
1818   0DA6 F9            leave
1819   0DA7 09            ret
1820   0DA8             
1821   0DA8             printsn:
1822   0DA8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1823   0DAB             ;; print(prompt); 
1824   0DAB FA 07 00      lea d, [bp + 7] ; $prompt
1825   0DAE 2A            mov b, [d]
1826   0DAF FD AB         swp b
1827   0DB1 D8            push b
1828   0DB2 07 89 0C      call print
1829   0DB5 51 02 00      add sp, 2
1830   0DB8             ;; prints(n); 
1831   0DB8 FA 05 00      lea d, [bp + 5] ; $n
1832   0DBB 2A            mov b, [d]
1833   0DBC FD AB         swp b
1834   0DBE D8            push b
1835   0DBF 07 60 0A      call prints
1836   0DC2 51 02 00      add sp, 2
1837   0DC5             ;; print("\n"); 
1838   0DC5 26 52 14      mov b, __s1 ; "\n"
1839   0DC8 FD AB         swp b
1840   0DCA D8            push b
1841   0DCB 07 89 0C      call print
1842   0DCE 51 02 00      add sp, 2
1843   0DD1 F9            leave
1844   0DD2 09            ret
1845   0DD3             
1846   0DD3             include_stdio_asm:
1847   0DD3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1848   0DD6             
1849   0DD6             ; --- BEGIN INLINE ASM BLOCK
1850   0DD6             .include "lib/stdio.asm"
0001+  0DD6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0DD6             ; stdio.s
0003+  0DD6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0DD6             .include "lib/string.asm"
0001++ 0DD6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0DD6             ; string.s
0003++ 0DD6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0DD6             
0005++ 0DD6             
0006++ 0DD6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0DD6             ; _strrev
0008++ 0DD6             ; reverse a string
0009++ 0DD6             ; D = string address
0010++ 0DD6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0DD6             ; 01234
0012++ 0DD6             _strrev:
0013++ 0DD6 4B          	pusha
0014++ 0DD7 07 1D 0E    	call _strlen	; length in C
0015++ 0DDA 12          	mov a, c
0016++ 0DDB AF 01 00    	cmp a, 1
0017++ 0DDE D0 F8 0D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0DE1 7D          	dec a
0019++ 0DE2 FD 4E       	mov si, d	; beginning of string
0020++ 0DE4 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0DE6 59          	add d, a	; end of string
0022++ 0DE7 12          	mov a, c
0023++ 0DE8 FD 9B       	shr a		; divide by 2
0024++ 0DEA 39          	mov c, a	; C now counts the steps
0025++ 0DEB             _strrev_L0:
0026++ 0DEB 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0DEC F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0DED 3E          	mov [d], al	; store left char into right side
0029++ 0DEE 1B          	mov al, bl
0030++ 0DEF F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0DF0 7E          	dec c
0032++ 0DF1 7F          	dec d
0033++ 0DF2 C2 00 00    	cmp c, 0
0034++ 0DF5 C7 EB 0D    	jne _strrev_L0
0035++ 0DF8             _strrev_end:
0036++ 0DF8 4C          	popa
0037++ 0DF9 09          	ret
0038++ 0DFA             	
0039++ 0DFA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0DFA             ; _strchr
0041++ 0DFA             ; search string in D for char in AL
0042++ 0DFA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0DFA             _strchr:
0044++ 0DFA             _strchr_L0:
0045++ 0DFA 32          	mov bl, [d]
0046++ 0DFB C1 00       	cmp bl, 0
0047++ 0DFD C6 08 0E    	je _strchr_end
0048++ 0E00 BA          	cmp al, bl
0049++ 0E01 C6 08 0E    	je _strchr_end
0050++ 0E04 79          	inc d
0051++ 0E05 0A FA 0D    	jmp _strchr_L0
0052++ 0E08             _strchr_end:
0053++ 0E08 1B          	mov al, bl
0054++ 0E09 09          	ret
0055++ 0E0A             
0056++ 0E0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0E0A             ; _strstr
0058++ 0E0A             ; find sub-string
0059++ 0E0A             ; str1 in SI
0060++ 0E0A             ; str2 in DI
0061++ 0E0A             ; SI points to end of source string
0062++ 0E0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0E0A             _strstr:
0064++ 0E0A DB          	push al
0065++ 0E0B DA          	push d
0066++ 0E0C E3          	push di
0067++ 0E0D             _strstr_loop:
0068++ 0E0D F3          	cmpsb					; compare a byte of the strings
0069++ 0E0E C7 19 0E    	jne _strstr_ret
0070++ 0E11 FC 00 00    	lea d, [di + 0]
0071++ 0E14 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0E16 C7 0D 0E    	jne _strstr_loop				; equal chars but not at end
0073++ 0E19             _strstr_ret:
0074++ 0E19 F0          	pop di
0075++ 0E1A E7          	pop d
0076++ 0E1B E8          	pop al
0077++ 0E1C 09          	ret
0078++ 0E1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0E1D             ; length of null terminated string
0080++ 0E1D             ; result in C
0081++ 0E1D             ; pointer in D
0082++ 0E1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0E1D             _strlen:
0084++ 0E1D DA          	push d
0085++ 0E1E 38 00 00    	mov c, 0
0086++ 0E21             _strlen_L1:
0087++ 0E21 BD 00       	cmp byte [d], 0
0088++ 0E23 C6 2B 0E    	je _strlen_ret
0089++ 0E26 79          	inc d
0090++ 0E27 78          	inc c
0091++ 0E28 0A 21 0E    	jmp _strlen_L1
0092++ 0E2B             _strlen_ret:
0093++ 0E2B E7          	pop d
0094++ 0E2C 09          	ret
0095++ 0E2D             
0096++ 0E2D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0E2D             ; STRCMP
0098++ 0E2D             ; compare two strings
0099++ 0E2D             ; str1 in SI
0100++ 0E2D             ; str2 in DI
0101++ 0E2D             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0E2D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0E2D             _strcmp:
0104++ 0E2D DB          	push al
0105++ 0E2E DA          	push d
0106++ 0E2F E3          	push di
0107++ 0E30 E2          	push si
0108++ 0E31             _strcmp_loop:
0109++ 0E31 F3          	cmpsb					; compare a byte of the strings
0110++ 0E32 C7 3D 0E    	jne _strcmp_ret
0111++ 0E35 FB FF FF    	lea d, [si +- 1]
0112++ 0E38 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0E3A C7 31 0E    	jne _strcmp_loop				; equal chars but not at end
0114++ 0E3D             _strcmp_ret:
0115++ 0E3D EF          	pop si
0116++ 0E3E F0          	pop di
0117++ 0E3F E7          	pop d
0118++ 0E40 E8          	pop al
0119++ 0E41 09          	ret
0120++ 0E42             
0121++ 0E42             
0122++ 0E42             ; STRCPY
0123++ 0E42             ; copy null terminated string from SI to DI
0124++ 0E42             ; source in SI
0125++ 0E42             ; destination in DI
0126++ 0E42             _strcpy:
0127++ 0E42 E2          	push si
0128++ 0E43 E3          	push di
0129++ 0E44 DB          	push al
0130++ 0E45             _strcpy_L1:
0131++ 0E45 F6          	lodsb
0132++ 0E46 F7          	stosb
0133++ 0E47 B9 00       	cmp al, 0
0134++ 0E49 C7 45 0E    	jne _strcpy_L1
0135++ 0E4C             _strcpy_end:
0136++ 0E4C E8          	pop al
0137++ 0E4D F0          	pop di
0138++ 0E4E EF          	pop si
0139++ 0E4F 09          	ret
0140++ 0E50             
0141++ 0E50             ; STRCAT
0142++ 0E50             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0E50             ; source in SI
0144++ 0E50             ; destination in DI
0145++ 0E50             _strcat:
0146++ 0E50 E2          	push si
0147++ 0E51 E3          	push di
0148++ 0E52 D7          	push a
0149++ 0E53 DA          	push d
0150++ 0E54 50          	mov a, di
0151++ 0E55 3C          	mov d, a
0152++ 0E56             _strcat_goto_end_L1:
0153++ 0E56 BD 00       	cmp byte[d], 0
0154++ 0E58 C6 5F 0E    	je _strcat_start
0155++ 0E5B 79          	inc d
0156++ 0E5C 0A 56 0E    	jmp _strcat_goto_end_L1
0157++ 0E5F             _strcat_start:
0158++ 0E5F FD 50       	mov di, d
0159++ 0E61             _strcat_L1:
0160++ 0E61 F6          	lodsb
0161++ 0E62 F7          	stosb
0162++ 0E63 B9 00       	cmp al, 0
0163++ 0E65 C7 61 0E    	jne _strcat_L1
0164++ 0E68             _strcat_end:
0165++ 0E68 E7          	pop d
0166++ 0E69 E4          	pop a
0167++ 0E6A F0          	pop di
0168++ 0E6B EF          	pop si
0169++ 0E6C 09          	ret
0170++ 0E6D             
0171++ 0E6D             
0005+  0E6D             
0006+  0E6D             
0007+  0E6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0E6D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0E6D             ; ASCII in BL
0010+  0E6D             ; result in AL
0011+  0E6D             ; ascii for F = 0100 0110
0012+  0E6D             ; ascii for 9 = 0011 1001
0013+  0E6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0E6D             hex_ascii_encode:
0015+  0E6D 1B            mov al, bl
0016+  0E6E 93 40         test al, $40        ; test if letter or number
0017+  0E70 C7 76 0E      jnz hex_letter
0018+  0E73 87 0F         and al, $0F        ; get number
0019+  0E75 09            ret
0020+  0E76             hex_letter:
0021+  0E76 87 0F         and al, $0F        ; get letter
0022+  0E78 6A 09         add al, 9
0023+  0E7A 09            ret
0024+  0E7B             
0025+  0E7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0E7B             ; ATOI
0027+  0E7B             ; 2 letter hex string in B
0028+  0E7B             ; 8bit integer returned in AL
0029+  0E7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0E7B             _atoi:
0031+  0E7B D8            push b
0032+  0E7C 07 6D 0E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0E7F 30            mov bl, bh
0034+  0E80 DB            push al          ; save a
0035+  0E81 07 6D 0E      call hex_ascii_encode
0036+  0E84 EA            pop bl  
0037+  0E85 FD 9E 04      shl al, 4
0038+  0E88 8C            or al, bl
0039+  0E89 E5            pop b
0040+  0E8A 09            ret  
0041+  0E8B             
0042+  0E8B             
0043+  0E8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0E8B             ; scanf
0045+  0E8B             ; no need for explanations!
0046+  0E8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0E8B             scanf:
0048+  0E8B 09            ret
0049+  0E8C             
0050+  0E8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0E8C             ; ITOA
0052+  0E8C             ; 8bit value in BL
0053+  0E8C             ; 2 byte ASCII result in A
0054+  0E8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0E8C             _itoa:
0056+  0E8C DA            push d
0057+  0E8D D8            push b
0058+  0E8E A7 00         mov bh, 0
0059+  0E90 FD A4 04      shr bl, 4  
0060+  0E93 74            mov d, b
0061+  0E94 1F 3C 11      mov al, [d + s_hex_digits]
0062+  0E97 23            mov ah, al
0063+  0E98               
0064+  0E98 E5            pop b
0065+  0E99 D8            push b
0066+  0E9A A7 00         mov bh, 0
0067+  0E9C FD 87 0F      and bl, $0F
0068+  0E9F 74            mov d, b
0069+  0EA0 1F 3C 11      mov al, [d + s_hex_digits]
0070+  0EA3 E5            pop b
0071+  0EA4 E7            pop d
0072+  0EA5 09            ret
0073+  0EA6             
0074+  0EA6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0EA6             ; HEX STRING TO BINARY
0076+  0EA6             ; di = destination address
0077+  0EA6             ; si = source
0078+  0EA6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0EA6             _hex_to_int:
0080+  0EA6             _hex_to_int_L1:
0081+  0EA6 F6            lodsb          ; load from [SI] to AL
0082+  0EA7 B9 00         cmp al, 0        ; check if ASCII 0
0083+  0EA9 C6 B6 0E      jz _hex_to_int_ret
0084+  0EAC 36            mov bh, al
0085+  0EAD F6            lodsb
0086+  0EAE 2F            mov bl, al
0087+  0EAF 07 7B 0E      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0EB2 F7            stosb          ; store AL to [DI]
0089+  0EB3 0A A6 0E      jmp _hex_to_int_L1
0090+  0EB6             _hex_to_int_ret:
0091+  0EB6 09            ret    
0092+  0EB7             
0093+  0EB7             
0094+  0EB7             
0095+  0EB7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0EB7             ; GETCHAR
0097+  0EB7             ; char in ah
0098+  0EB7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0EB7             getch:
0100+  0EB7 DB            push al
0101+  0EB8             getch_retry:
0102+  0EB8 19 01         mov al, 1
0103+  0EBA 05 03         syscall sys_io      ; receive in AH
0104+  0EBC E8            pop al
0105+  0EBD 09            ret
0106+  0EBE             
0107+  0EBE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0EBE             ; PUTCHAR
0109+  0EBE             ; char in ah
0110+  0EBE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0EBE             _putchar:
0112+  0EBE D7            push a
0113+  0EBF 19 00         mov al, 0
0114+  0EC1 05 03         syscall sys_io      ; char in AH
0115+  0EC3 E4            pop a
0116+  0EC4 09            ret
0117+  0EC5             
0118+  0EC5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0EC5             ;; INPUT A STRING
0120+  0EC5             ;; terminates with null
0121+  0EC5             ;; pointer in D
0122+  0EC5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0EC5             _gets:
0124+  0EC5 D7            push a
0125+  0EC6 DA            push d
0126+  0EC7             _gets_loop:
0127+  0EC7 19 01         mov al, 1
0128+  0EC9 05 03         syscall sys_io      ; receive in AH
0129+  0ECB B9 00         cmp al, 0        ; check error code (AL)
0130+  0ECD C6 C7 0E      je _gets_loop      ; if no char received, retry
0131+  0ED0             
0132+  0ED0 76 1B         cmp ah, 27
0133+  0ED2 C6 F3 0E      je _gets_ansi_esc
0134+  0ED5 76 0A         cmp ah, $0A        ; LF
0135+  0ED7 C6 5E 0F      je _gets_end
0136+  0EDA 76 0D         cmp ah, $0D        ; CR
0137+  0EDC C6 5E 0F      je _gets_end
0138+  0EDF 76 5C         cmp ah, $5C        ; '\\'
0139+  0EE1 C6 1F 0F      je _gets_escape
0140+  0EE4               
0141+  0EE4 76 08         cmp ah, $08      ; check for backspace
0142+  0EE6 C6 EF 0E      je _gets_backspace
0143+  0EE9             
0144+  0EE9 1A            mov al, ah
0145+  0EEA 3E            mov [d], al
0146+  0EEB 79            inc d
0147+  0EEC 0A C7 0E      jmp _gets_loop
0148+  0EEF             _gets_backspace:
0149+  0EEF 7F            dec d
0150+  0EF0 0A C7 0E      jmp _gets_loop
0151+  0EF3             _gets_ansi_esc:
0152+  0EF3 19 01         mov al, 1
0153+  0EF5 05 03         syscall sys_io        ; receive in AH without echo
0154+  0EF7 B9 00         cmp al, 0          ; check error code (AL)
0155+  0EF9 C6 F3 0E      je _gets_ansi_esc    ; if no char received, retry
0156+  0EFC 76 5B         cmp ah, '['
0157+  0EFE C7 C7 0E      jne _gets_loop
0158+  0F01             _gets_ansi_esc_2:
0159+  0F01 19 01         mov al, 1
0160+  0F03 05 03         syscall sys_io          ; receive in AH without echo
0161+  0F05 B9 00         cmp al, 0            ; check error code (AL)
0162+  0F07 C6 01 0F      je _gets_ansi_esc_2  ; if no char received, retry
0163+  0F0A 76 44         cmp ah, 'D'
0164+  0F0C C6 17 0F      je _gets_left_arrow
0165+  0F0F 76 43         cmp ah, 'C'
0166+  0F11 C6 1B 0F      je _gets_right_arrow
0167+  0F14 0A C7 0E      jmp _gets_loop
0168+  0F17             _gets_left_arrow:
0169+  0F17 7F            dec d
0170+  0F18 0A C7 0E      jmp _gets_loop
0171+  0F1B             _gets_right_arrow:
0172+  0F1B 79            inc d
0173+  0F1C 0A C7 0E      jmp _gets_loop
0174+  0F1F             _gets_escape:
0175+  0F1F 19 01         mov al, 1
0176+  0F21 05 03         syscall sys_io      ; receive in AH
0177+  0F23 B9 00         cmp al, 0        ; check error code (AL)
0178+  0F25 C6 1F 0F      je _gets_escape      ; if no char received, retry
0179+  0F28 76 6E         cmp ah, 'n'
0180+  0F2A C6 49 0F      je _gets_LF
0181+  0F2D 76 72         cmp ah, 'r'
0182+  0F2F C6 50 0F      je _gets_CR
0183+  0F32 76 30         cmp ah, '0'
0184+  0F34 C6 57 0F      je _gets_NULL
0185+  0F37 76 5C         cmp ah, $5C  ; '\'
0186+  0F39 C6 42 0F      je _gets_slash
0187+  0F3C 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  0F3D 3E            mov [d], al
0189+  0F3E 79            inc d
0190+  0F3F 0A C7 0E      jmp _gets_loop
0191+  0F42             _gets_slash:
0192+  0F42 19 5C         mov al, $5C
0193+  0F44 3E            mov [d], al
0194+  0F45 79            inc d
0195+  0F46 0A C7 0E      jmp _gets_loop
0196+  0F49             _gets_LF:
0197+  0F49 19 0A         mov al, $0A
0198+  0F4B 3E            mov [d], al
0199+  0F4C 79            inc d
0200+  0F4D 0A C7 0E      jmp _gets_loop
0201+  0F50             _gets_CR:
0202+  0F50 19 0D         mov al, $0D
0203+  0F52 3E            mov [d], al
0204+  0F53 79            inc d
0205+  0F54 0A C7 0E      jmp _gets_loop
0206+  0F57             _gets_NULL:
0207+  0F57 19 00         mov al, $00
0208+  0F59 3E            mov [d], al
0209+  0F5A 79            inc d
0210+  0F5B 0A C7 0E      jmp _gets_loop
0211+  0F5E             _gets_end:
0212+  0F5E 19 00         mov al, 0
0213+  0F60 3E            mov [d], al        ; terminate string
0214+  0F61 E7            pop d
0215+  0F62 E4            pop a
0216+  0F63 09            ret
0217+  0F64             
0218+  0F64             
0219+  0F64             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  0F64             ;; INPUT TEXT
0221+  0F64             ;; terminated with CTRL+D
0222+  0F64             ;; pointer in D
0223+  0F64             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  0F64             _gettxt:
0225+  0F64 D7            push a
0226+  0F65 DA            push d
0227+  0F66             _gettxt_loop:
0228+  0F66 19 01         mov al, 1
0229+  0F68 05 03         syscall sys_io      ; receive in AH
0230+  0F6A B9 00         cmp al, 0        ; check error code (AL)
0231+  0F6C C6 66 0F      je _gettxt_loop    ; if no char received, retry
0232+  0F6F 76 04         cmp ah, 4      ; EOT
0233+  0F71 C6 AF 0F      je _gettxt_end
0234+  0F74 76 08         cmp ah, $08      ; check for backspace
0235+  0F76 C6 AB 0F      je _gettxt_backspace
0236+  0F79 76 5C         cmp ah, $5C        ; '\'
0237+  0F7B C6 84 0F      je _gettxt_escape
0238+  0F7E 1A            mov al, ah
0239+  0F7F 3E            mov [d], al
0240+  0F80 79            inc d
0241+  0F81 0A 66 0F      jmp _gettxt_loop
0242+  0F84             _gettxt_escape:
0243+  0F84 19 01         mov al, 1
0244+  0F86 05 03         syscall sys_io      ; receive in AH
0245+  0F88 B9 00         cmp al, 0        ; check error code (AL)
0246+  0F8A C6 84 0F      je _gettxt_escape    ; if no char received, retry
0247+  0F8D 76 6E         cmp ah, 'n'
0248+  0F8F C6 9D 0F      je _gettxt_LF
0249+  0F92 76 72         cmp ah, 'r'
0250+  0F94 C6 A4 0F      je _gettxt_CR
0251+  0F97 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0F98 3E            mov [d], al
0253+  0F99 79            inc d
0254+  0F9A 0A 66 0F      jmp _gettxt_loop
0255+  0F9D             _gettxt_LF:
0256+  0F9D 19 0A         mov al, $0A
0257+  0F9F 3E            mov [d], al
0258+  0FA0 79            inc d
0259+  0FA1 0A 66 0F      jmp _gettxt_loop
0260+  0FA4             _gettxt_CR:
0261+  0FA4 19 0D         mov al, $0D
0262+  0FA6 3E            mov [d], al
0263+  0FA7 79            inc d
0264+  0FA8 0A 66 0F      jmp _gettxt_loop
0265+  0FAB             _gettxt_backspace:
0266+  0FAB 7F            dec d
0267+  0FAC 0A 66 0F      jmp _gettxt_loop
0268+  0FAF             _gettxt_end:
0269+  0FAF 19 00         mov al, 0
0270+  0FB1 3E            mov [d], al        ; terminate string
0271+  0FB2 E7            pop d
0272+  0FB3 E4            pop a
0273+  0FB4 09            ret
0274+  0FB5             
0275+  0FB5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0FB5             ; PRINT NEW LINE
0277+  0FB5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  0FB5             printnl:
0279+  0FB5 D7            push a
0280+  0FB6 10 00 0A      mov a, $0A00
0281+  0FB9 05 03         syscall sys_io
0282+  0FBB 10 00 0D      mov a, $0D00
0283+  0FBE 05 03         syscall sys_io
0284+  0FC0 E4            pop a
0285+  0FC1 09            ret
0286+  0FC2             
0287+  0FC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0FC2             ; _strtoint
0289+  0FC2             ; 4 digit hex string number in d
0290+  0FC2             ; integer returned in A
0291+  0FC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  0FC2             _strtointx:
0293+  0FC2 D8            push b
0294+  0FC3 32            mov bl, [d]
0295+  0FC4 37            mov bh, bl
0296+  0FC5 33 01 00      mov bl, [d + 1]
0297+  0FC8 07 7B 0E      call _atoi        ; convert to int in AL
0298+  0FCB 23            mov ah, al        ; move to AH
0299+  0FCC 33 02 00      mov bl, [d + 2]
0300+  0FCF 37            mov bh, bl
0301+  0FD0 33 03 00      mov bl, [d + 3]
0302+  0FD3 07 7B 0E      call _atoi        ; convert to int in AL
0303+  0FD6 E5            pop b
0304+  0FD7 09            ret
0305+  0FD8             
0306+  0FD8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  0FD8             ; _strtoint
0308+  0FD8             ; 5 digit base10 string number in d
0309+  0FD8             ; integer returned in A
0310+  0FD8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  0FD8             _strtoint:
0312+  0FD8 E2            push si
0313+  0FD9 D8            push b
0314+  0FDA D9            push c
0315+  0FDB DA            push d
0316+  0FDC 07 1D 0E      call _strlen      ; get string length in C
0317+  0FDF 7E            dec c
0318+  0FE0 FD 4E         mov si, d
0319+  0FE2 12            mov a, c
0320+  0FE3 FD 99         shl a
0321+  0FE5 3B 54 11      mov d, table_power
0322+  0FE8 59            add d, a
0323+  0FE9 38 00 00      mov c, 0
0324+  0FEC             _strtoint_L0:
0325+  0FEC F6            lodsb      ; load ASCII to al
0326+  0FED B9 00         cmp al, 0
0327+  0FEF C6 02 10      je _strtoint_end
0328+  0FF2 6F 30         sub al, $30    ; make into integer
0329+  0FF4 22 00         mov ah, 0
0330+  0FF6 2A            mov b, [d]
0331+  0FF7 AC            mul a, b      ; result in B since it fits in 16bits
0332+  0FF8 11            mov a, b
0333+  0FF9 28            mov b, c
0334+  0FFA 54            add a, b
0335+  0FFB 39            mov c, a
0336+  0FFC 63 02 00      sub d, 2
0337+  0FFF 0A EC 0F      jmp _strtoint_L0
0338+  1002             _strtoint_end:
0339+  1002 12            mov a, c
0340+  1003 E7            pop d
0341+  1004 E6            pop c
0342+  1005 E5            pop b
0343+  1006 EF            pop si
0344+  1007 09            ret
0345+  1008             
0346+  1008             
0347+  1008             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  1008             ; PRINT NULL TERMINATED STRING
0349+  1008             ; pointer in D
0350+  1008             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  1008             _puts:
0352+  1008 D7            push a
0353+  1009 DA            push d
0354+  100A             _puts_L1:
0355+  100A 1E            mov al, [d]
0356+  100B B9 00         cmp al, 0
0357+  100D C6 19 10      jz _puts_END
0358+  1010 23            mov ah, al
0359+  1011 19 00         mov al, 0
0360+  1013 05 03         syscall sys_io
0361+  1015 79            inc d
0362+  1016 0A 0A 10      jmp _puts_L1
0363+  1019             _puts_END:
0364+  1019 E7            pop d
0365+  101A E4            pop a
0366+  101B 09            ret
0367+  101C             
0368+  101C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  101C             ; PRINT N SIZE STRING
0370+  101C             ; pointer in D
0371+  101C             ; size in C
0372+  101C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  101C             _putsn:
0374+  101C DB            push al
0375+  101D DA            push d
0376+  101E D9            push c
0377+  101F             _putsn_L0:
0378+  101F 1E            mov al, [d]
0379+  1020 23            mov ah, al
0380+  1021 19 00         mov al, 0
0381+  1023 05 03         syscall sys_io
0382+  1025 79            inc d
0383+  1026 7E            dec c  
0384+  1027 C2 00 00      cmp c, 0
0385+  102A C7 1F 10      jne _putsn_L0
0386+  102D             _putsn_end:
0387+  102D E6            pop c
0388+  102E E7            pop d
0389+  102F E8            pop al
0390+  1030 09            ret
0391+  1031             
0392+  1031             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1031             ; print 16bit decimal number
0394+  1031             ; input number in A
0395+  1031             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1031             print_u16d:
0397+  1031 D7            push a
0398+  1032 D8            push b
0399+  1033 26 10 27      mov b, 10000
0400+  1036 AE            div a, b      ; get 10000's coeff.
0401+  1037 07 59 10      call print_number
0402+  103A 11            mov a, b
0403+  103B 26 E8 03      mov b, 1000
0404+  103E AE            div a, b      ; get 1000's coeff.
0405+  103F 07 59 10      call print_number
0406+  1042 11            mov a, b
0407+  1043 26 64 00      mov b, 100
0408+  1046 AE            div a, b
0409+  1047 07 59 10      call print_number
0410+  104A 11            mov a, b
0411+  104B 26 0A 00      mov b, 10
0412+  104E AE            div a, b
0413+  104F 07 59 10      call print_number
0414+  1052 1B            mov al, bl      ; 1's coeff in bl
0415+  1053 07 59 10      call print_number
0416+  1056 E5            pop b
0417+  1057 E4            pop a
0418+  1058 09            ret
0419+  1059             
0420+  1059             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  1059             ; print AL
0422+  1059             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  1059             print_number:
0424+  1059 6A 30         add al, $30
0425+  105B 23            mov ah, al
0426+  105C 07 BE 0E      call _putchar
0427+  105F 09            ret
0428+  1060             
0429+  1060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1060             ; PRINT 16BIT HEX INTEGER
0431+  1060             ; integer value in reg B
0432+  1060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1060             print_u16x:
0434+  1060 D7            push a
0435+  1061 D8            push b
0436+  1062 DD            push bl
0437+  1063 30            mov bl, bh
0438+  1064 07 8C 0E      call _itoa        ; convert bh to char in A
0439+  1067 2F            mov bl, al        ; save al
0440+  1068 19 00         mov al, 0
0441+  106A 05 03         syscall sys_io        ; display AH
0442+  106C 24            mov ah, bl        ; retrieve al
0443+  106D 19 00         mov al, 0
0444+  106F 05 03         syscall sys_io        ; display AL
0445+  1071             
0446+  1071 EA            pop bl
0447+  1072 07 8C 0E      call _itoa        ; convert bh to char in A
0448+  1075 2F            mov bl, al        ; save al
0449+  1076 19 00         mov al, 0
0450+  1078 05 03         syscall sys_io        ; display AH
0451+  107A 24            mov ah, bl        ; retrieve al
0452+  107B 19 00         mov al, 0
0453+  107D 05 03         syscall sys_io        ; display AL
0454+  107F             
0455+  107F E5            pop b
0456+  1080 E4            pop a
0457+  1081 09            ret
0458+  1082             
0459+  1082             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  1082             ; INPUT 16BIT HEX INTEGER
0461+  1082             ; read 16bit integer into A
0462+  1082             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  1082             scan_u16x:
0464+  1082 F8 10 00      enter 16
0465+  1085 D8            push b
0466+  1086 DA            push d
0467+  1087             
0468+  1087 FA F1 FF      lea d, [bp + -15]
0469+  108A 07 C5 0E      call _gets        ; get number
0470+  108D             
0471+  108D 32            mov bl, [d]
0472+  108E 37            mov bh, bl
0473+  108F 33 01 00      mov bl, [d + 1]
0474+  1092 07 7B 0E      call _atoi        ; convert to int in AL
0475+  1095 23            mov ah, al        ; move to AH
0476+  1096             
0477+  1096 33 02 00      mov bl, [d + 2]
0478+  1099 37            mov bh, bl
0479+  109A 33 03 00      mov bl, [d + 3]
0480+  109D 07 7B 0E      call _atoi        ; convert to int in AL
0481+  10A0             
0482+  10A0 E7            pop d
0483+  10A1 E5            pop b
0484+  10A2 F9            leave
0485+  10A3 09            ret
0486+  10A4             
0487+  10A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  10A4             ; PRINT 8bit HEX INTEGER
0489+  10A4             ; integer value in reg bl
0490+  10A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  10A4             print_u8x:
0492+  10A4 D7            push a
0493+  10A5 DD            push bl
0494+  10A6             
0495+  10A6 07 8C 0E      call _itoa        ; convert bl to char in A
0496+  10A9 2F            mov bl, al        ; save al
0497+  10AA 19 00         mov al, 0
0498+  10AC 05 03         syscall sys_io        ; display AH
0499+  10AE 24            mov ah, bl        ; retrieve al
0500+  10AF 19 00         mov al, 0
0501+  10B1 05 03         syscall sys_io        ; display AL
0502+  10B3             
0503+  10B3 EA            pop bl
0504+  10B4 E4            pop a
0505+  10B5 09            ret
0506+  10B6             
0507+  10B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  10B6             ; print 8bit decimal unsigned number
0509+  10B6             ; input number in AL
0510+  10B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  10B6             print_u8d:
0512+  10B6 D7            push a
0513+  10B7 D8            push b
0514+  10B8             
0515+  10B8 22 00         mov ah, 0
0516+  10BA 26 64 00      mov b, 100
0517+  10BD AE            div a, b
0518+  10BE D8            push b      ; save remainder
0519+  10BF B9 00         cmp al, 0
0520+  10C1 C6 CB 10      je skip100
0521+  10C4 6A 30         add al, $30
0522+  10C6 23            mov ah, al
0523+  10C7 19 00         mov al, 0
0524+  10C9 05 03         syscall sys_io  ; print coeff
0525+  10CB             skip100:
0526+  10CB E4            pop a
0527+  10CC 22 00         mov ah, 0
0528+  10CE 26 0A 00      mov b, 10
0529+  10D1 AE            div a, b
0530+  10D2 D8            push b      ; save remainder
0531+  10D3 B9 00         cmp al, 0
0532+  10D5 C6 DF 10      je skip10
0533+  10D8 6A 30         add al, $30
0534+  10DA 23            mov ah, al
0535+  10DB 19 00         mov al, 0
0536+  10DD 05 03         syscall sys_io  ; print coeff
0537+  10DF             skip10:
0538+  10DF E4            pop a
0539+  10E0 1B            mov al, bl
0540+  10E1 6A 30         add al, $30
0541+  10E3 23            mov ah, al
0542+  10E4 19 00         mov al, 0
0543+  10E6 05 03         syscall sys_io  ; print coeff
0544+  10E8 E5            pop b
0545+  10E9 E4            pop a
0546+  10EA 09            ret
0547+  10EB             
0548+  10EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  10EB             ; INPUT 8BIT HEX INTEGER
0550+  10EB             ; read 8bit integer into AL
0551+  10EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  10EB             scan_u8x:
0553+  10EB F8 04 00      enter 4
0554+  10EE D8            push b
0555+  10EF DA            push d
0556+  10F0             
0557+  10F0 FA FD FF      lea d, [bp + -3]
0558+  10F3 07 C5 0E      call _gets        ; get number
0559+  10F6             
0560+  10F6 32            mov bl, [d]
0561+  10F7 37            mov bh, bl
0562+  10F8 33 01 00      mov bl, [d + 1]
0563+  10FB 07 7B 0E      call _atoi        ; convert to int in AL
0564+  10FE             
0565+  10FE E7            pop d
0566+  10FF E5            pop b
0567+  1100 F9            leave
0568+  1101 09            ret
0569+  1102             
0570+  1102             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  1102             ; input decimal number
0572+  1102             ; result in A
0573+  1102             ; 655'\0'
0574+  1102             ; low--------high
0575+  1102             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  1102             scan_u16d:
0577+  1102 F8 08 00      enter 8
0578+  1105 E2            push si
0579+  1106 D8            push b
0580+  1107 D9            push c
0581+  1108 DA            push d
0582+  1109 FA F9 FF      lea d, [bp +- 7]
0583+  110C 07 C5 0E      call _gets
0584+  110F 07 1D 0E      call _strlen      ; get string length in C
0585+  1112 7E            dec c
0586+  1113 FD 4E         mov si, d
0587+  1115 12            mov a, c
0588+  1116 FD 99         shl a
0589+  1118 3B 54 11      mov d, table_power
0590+  111B 59            add d, a
0591+  111C 38 00 00      mov c, 0
0592+  111F             mul_loop:
0593+  111F F6            lodsb      ; load ASCII to al
0594+  1120 B9 00         cmp al, 0
0595+  1122 C6 35 11      je mul_exit
0596+  1125 6F 30         sub al, $30    ; make into integer
0597+  1127 22 00         mov ah, 0
0598+  1129 2A            mov b, [d]
0599+  112A AC            mul a, b      ; result in B since it fits in 16bits
0600+  112B 11            mov a, b
0601+  112C 28            mov b, c
0602+  112D 54            add a, b
0603+  112E 39            mov c, a
0604+  112F 63 02 00      sub d, 2
0605+  1132 0A 1F 11      jmp mul_loop
0606+  1135             mul_exit:
0607+  1135 12            mov a, c
0608+  1136 E7            pop d
0609+  1137 E6            pop c
0610+  1138 E5            pop b
0611+  1139 EF            pop si
0612+  113A F9            leave
0613+  113B 09            ret
0614+  113C             
0615+  113C             
0616+  113C 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1140 34 35 36 37 
0616+  1144 38 39 41 42 
0616+  1148 43 44 45 46 
0617+  114C 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1150 1B 5B 48 00 
0618+  1154             
0619+  1154             table_power:
0620+  1154 01 00         .dw 1
0621+  1156 0A 00         .dw 10
0622+  1158 64 00         .dw 100
0623+  115A E8 03         .dw 1000
0624+  115C 10 27         .dw 100001851   115E             ; --- END INLINE ASM BLOCK
1852   115E             
1853   115E F9            leave
1854   115F 09            ret
1855   1160             
1856   1160             rotr:
1857   1160 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1858   1163             ;; return (x >> n) | (x << (16 - n)); 
1859   1163 FA 07 00      lea d, [bp + 7] ; $x
1860   1166 2A            mov b, [d]
1861   1167             ; START SHIFT
1862   1167 D7            push a
1863   1168 11            mov a, b
1864   1169 FA 05 00      lea d, [bp + 5] ; $n
1865   116C 2A            mov b, [d]
1866   116D FD 39         mov c, b
1867   116F A1            shr a, cl
1868   1170 27            mov b, a
1869   1171 E4            pop a
1870   1172             ; END SHIFT
1871   1172 D7            push a
1872   1173 11            mov a, b
1873   1174 FA 07 00      lea d, [bp + 7] ; $x
1874   1177 2A            mov b, [d]
1875   1178             ; START SHIFT
1876   1178 D7            push a
1877   1179 11            mov a, b
1878   117A 26 10 00      mov b, $10
1879   117D             ; START TERMS
1880   117D D7            push a
1881   117E 11            mov a, b
1882   117F FA 05 00      lea d, [bp + 5] ; $n
1883   1182 2A            mov b, [d]
1884   1183 60            sub a, b
1885   1184 27            mov b, a
1886   1185 E4            pop a
1887   1186             ; END TERMS
1888   1186 FD 39         mov c, b
1889   1188 9D            shl a, cl
1890   1189 27            mov b, a
1891   118A E4            pop a
1892   118B             ; END SHIFT
1893   118B 8A            or a, b ; &
1894   118C 27            mov b, a
1895   118D E4            pop a
1896   118E F9            leave
1897   118F 09            ret
1898   1190             
1899   1190             simple_hash:
1900   1190 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1901   1193             ; $h 
1902   1193             ; $k 
1903   1193             ; $i 
1904   1193             ; $j 
1905   1193             ; $val 
1906   1193             ; $len 
1907   1193 52 20 00      sub sp, 32
1908   1196             ;; h[0]=0x6745; 
1909   1196 FA F1 FF      lea d, [bp + -15] ; $h
1910   1199 D7            push a
1911   119A DA            push d
1912   119B 26 00 00      mov b, $0
1913   119E E7            pop d
1914   119F FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
1915   11A3 E4            pop a
1916   11A4 DA            push d
1917   11A5 26 45 67      mov b, $6745
1918   11A8 E7            pop d
1919   11A9 FD 43         mov [d], b
1920   11AB             ;; h[1]=0xEFCD; 
1921   11AB FA F1 FF      lea d, [bp + -15] ; $h
1922   11AE D7            push a
1923   11AF DA            push d
1924   11B0 26 01 00      mov b, $1
1925   11B3 E7            pop d
1926   11B4 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
1927   11B8 E4            pop a
1928   11B9 DA            push d
1929   11BA 26 CD EF      mov b, $efcd
1930   11BD E7            pop d
1931   11BE FD 43         mov [d], b
1932   11C0             ;; h[2]=0x98AB; 
1933   11C0 FA F1 FF      lea d, [bp + -15] ; $h
1934   11C3 D7            push a
1935   11C4 DA            push d
1936   11C5 26 02 00      mov b, $2
1937   11C8 E7            pop d
1938   11C9 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
1939   11CD E4            pop a
1940   11CE DA            push d
1941   11CF 26 AB 98      mov b, $98ab
1942   11D2 E7            pop d
1943   11D3 FD 43         mov [d], b
1944   11D5             ;; h[3]=0xCDEF; 
1945   11D5 FA F1 FF      lea d, [bp + -15] ; $h
1946   11D8 D7            push a
1947   11D9 DA            push d
1948   11DA 26 03 00      mov b, $3
1949   11DD E7            pop d
1950   11DE FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
1951   11E2 E4            pop a
1952   11E3 DA            push d
1953   11E4 26 EF CD      mov b, $cdef
1954   11E7 E7            pop d
1955   11E8 FD 43         mov [d], b
1956   11EA             ;; k[0]=0x1234; 
1957   11EA FA E9 FF      lea d, [bp + -23] ; $k
1958   11ED D7            push a
1959   11EE DA            push d
1960   11EF 26 00 00      mov b, $0
1961   11F2 E7            pop d
1962   11F3 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
1963   11F7 E4            pop a
1964   11F8 DA            push d
1965   11F9 26 34 12      mov b, $1234
1966   11FC E7            pop d
1967   11FD FD 43         mov [d], b
1968   11FF             ;; k[1]=0x5678; 
1969   11FF FA E9 FF      lea d, [bp + -23] ; $k
1970   1202 D7            push a
1971   1203 DA            push d
1972   1204 26 01 00      mov b, $1
1973   1207 E7            pop d
1974   1208 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
1975   120C E4            pop a
1976   120D DA            push d
1977   120E 26 78 56      mov b, $5678
1978   1211 E7            pop d
1979   1212 FD 43         mov [d], b
1980   1214             ;; k[2]=0x9ABC; 
1981   1214 FA E9 FF      lea d, [bp + -23] ; $k
1982   1217 D7            push a
1983   1218 DA            push d
1984   1219 26 02 00      mov b, $2
1985   121C E7            pop d
1986   121D FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
1987   1221 E4            pop a
1988   1222 DA            push d
1989   1223 26 BC 9A      mov b, $9abc
1990   1226 E7            pop d
1991   1227 FD 43         mov [d], b
1992   1229             ;; k[3]=0xDEF0; 
1993   1229 FA E9 FF      lea d, [bp + -23] ; $k
1994   122C D7            push a
1995   122D DA            push d
1996   122E 26 03 00      mov b, $3
1997   1231 E7            pop d
1998   1232 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
1999   1236 E4            pop a
2000   1237 DA            push d
2001   1238 26 F0 DE      mov b, $def0
2002   123B E7            pop d
2003   123C FD 43         mov [d], b
2004   123E             ;; ; 
2005   123E             ;; len = strlen(input); 
2006   123E FA E1 FF      lea d, [bp + -31] ; $len
2007   1241 DA            push d
2008   1242 FA 07 00      lea d, [bp + 7] ; $input
2009   1245 2A            mov b, [d]
2010   1246 FD AB         swp b
2011   1248 D8            push b
2012   1249 07 FC 05      call strlen
2013   124C 51 02 00      add sp, 2
2014   124F E7            pop d
2015   1250 FD 43         mov [d], b
2016   1252             ;; for (i = 0; i < len; i++) { 
2017   1252             _for24_init:
2018   1252 FA E7 FF      lea d, [bp + -25] ; $i
2019   1255 DA            push d
2020   1256 26 00 00      mov b, $0
2021   1259 E7            pop d
2022   125A FD 43         mov [d], b
2023   125C             _for24_cond:
2024   125C FA E7 FF      lea d, [bp + -25] ; $i
2025   125F 2A            mov b, [d]
2026   1260             ; START RELATIONAL
2027   1260 D7            push a
2028   1261 11            mov a, b
2029   1262 FA E1 FF      lea d, [bp + -31] ; $len
2030   1265 2A            mov b, [d]
2031   1266 B0            cmp a, b
2032   1267 FD 73         slt ; < 
2033   1269 E4            pop a
2034   126A             ; END RELATIONAL
2035   126A C0 00 00      cmp b, 0
2036   126D C6 8E 13      je _for24_exit
2037   1270             _for24_block:
2038   1270             ;; val = (unsigned char)input[i]; 
2039   1270 FA E3 FF      lea d, [bp + -29] ; $val
2040   1273 DA            push d
2041   1274 FA 07 00      lea d, [bp + 7] ; $input
2042   1277 FD 2A         mov d, [d]
2043   1279 D7            push a
2044   127A DA            push d
2045   127B FA E7 FF      lea d, [bp + -25] ; $i
2046   127E 2A            mov b, [d]
2047   127F E7            pop d
2048   1280 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2049   1284 E4            pop a
2050   1285 32            mov bl, [d]
2051   1286 A7 00         mov bh, 0
2052   1288 A7 00         mov bh, 0
2053   128A E7            pop d
2054   128B FD 43         mov [d], b
2055   128D             ;; for (j = 0; j < 4; j++) { 
2056   128D             _for25_init:
2057   128D FA E5 FF      lea d, [bp + -27] ; $j
2058   1290 DA            push d
2059   1291 26 00 00      mov b, $0
2060   1294 E7            pop d
2061   1295 FD 43         mov [d], b
2062   1297             _for25_cond:
2063   1297 FA E5 FF      lea d, [bp + -27] ; $j
2064   129A 2A            mov b, [d]
2065   129B             ; START RELATIONAL
2066   129B D7            push a
2067   129C 11            mov a, b
2068   129D 26 04 00      mov b, $4
2069   12A0 B0            cmp a, b
2070   12A1 FD 73         slt ; < 
2071   12A3 E4            pop a
2072   12A4             ; END RELATIONAL
2073   12A4 C0 00 00      cmp b, 0
2074   12A7 C6 7C 13      je _for25_exit
2075   12AA             _for25_block:
2076   12AA             ;; h[j] = h[j] ^ rotr(val + k[j], j + 1); 
2077   12AA FA F1 FF      lea d, [bp + -15] ; $h
2078   12AD D7            push a
2079   12AE DA            push d
2080   12AF FA E5 FF      lea d, [bp + -27] ; $j
2081   12B2 2A            mov b, [d]
2082   12B3 E7            pop d
2083   12B4 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
2084   12B8 E4            pop a
2085   12B9 DA            push d
2086   12BA FA F1 FF      lea d, [bp + -15] ; $h
2087   12BD D7            push a
2088   12BE DA            push d
2089   12BF FA E5 FF      lea d, [bp + -27] ; $j
2090   12C2 2A            mov b, [d]
2091   12C3 E7            pop d
2092   12C4 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
2093   12C8 E4            pop a
2094   12C9 2A            mov b, [d]
2095   12CA D7            push a
2096   12CB 11            mov a, b
2097   12CC FA E5 FF      lea d, [bp + -27] ; $j
2098   12CF 2A            mov b, [d]
2099   12D0             ; START TERMS
2100   12D0 D7            push a
2101   12D1 11            mov a, b
2102   12D2 26 01 00      mov b, $1
2103   12D5 54            add a, b
2104   12D6 27            mov b, a
2105   12D7 E4            pop a
2106   12D8             ; END TERMS
2107   12D8 FD AB         swp b
2108   12DA D8            push b
2109   12DB FA E3 FF      lea d, [bp + -29] ; $val
2110   12DE 2A            mov b, [d]
2111   12DF             ; START TERMS
2112   12DF D7            push a
2113   12E0 11            mov a, b
2114   12E1 FA E9 FF      lea d, [bp + -23] ; $k
2115   12E4 D7            push a
2116   12E5 DA            push d
2117   12E6 FA E5 FF      lea d, [bp + -27] ; $j
2118   12E9 2A            mov b, [d]
2119   12EA E7            pop d
2120   12EB FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
2121   12EF E4            pop a
2122   12F0 2A            mov b, [d]
2123   12F1 54            add a, b
2124   12F2 27            mov b, a
2125   12F3 E4            pop a
2126   12F4             ; END TERMS
2127   12F4 FD AB         swp b
2128   12F6 D8            push b
2129   12F7 07 60 11      call rotr
2130   12FA 51 04 00      add sp, 4
2131   12FD 8E            xor a, b ; ^
2132   12FE 27            mov b, a
2133   12FF E4            pop a
2134   1300 E7            pop d
2135   1301 FD 43         mov [d], b
2136   1303             ;; h[j] = h[j] + val; 
2137   1303 FA F1 FF      lea d, [bp + -15] ; $h
2138   1306 D7            push a
2139   1307 DA            push d
2140   1308 FA E5 FF      lea d, [bp + -27] ; $j
2141   130B 2A            mov b, [d]
2142   130C E7            pop d
2143   130D FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
2144   1311 E4            pop a
2145   1312 DA            push d
2146   1313 FA F1 FF      lea d, [bp + -15] ; $h
2147   1316 D7            push a
2148   1317 DA            push d
2149   1318 FA E5 FF      lea d, [bp + -27] ; $j
2150   131B 2A            mov b, [d]
2151   131C E7            pop d
2152   131D FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
2153   1321 E4            pop a
2154   1322 2A            mov b, [d]
2155   1323             ; START TERMS
2156   1323 D7            push a
2157   1324 11            mov a, b
2158   1325 FA E3 FF      lea d, [bp + -29] ; $val
2159   1328 2A            mov b, [d]
2160   1329 54            add a, b
2161   132A 27            mov b, a
2162   132B E4            pop a
2163   132C             ; END TERMS
2164   132C E7            pop d
2165   132D FD 43         mov [d], b
2166   132F             ;; h[j] = rotr(h[j], j + 1); 
2167   132F FA F1 FF      lea d, [bp + -15] ; $h
2168   1332 D7            push a
2169   1333 DA            push d
2170   1334 FA E5 FF      lea d, [bp + -27] ; $j
2171   1337 2A            mov b, [d]
2172   1338 E7            pop d
2173   1339 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
2174   133D E4            pop a
2175   133E DA            push d
2176   133F FA E5 FF      lea d, [bp + -27] ; $j
2177   1342 2A            mov b, [d]
2178   1343             ; START TERMS
2179   1343 D7            push a
2180   1344 11            mov a, b
2181   1345 26 01 00      mov b, $1
2182   1348 54            add a, b
2183   1349 27            mov b, a
2184   134A E4            pop a
2185   134B             ; END TERMS
2186   134B FD AB         swp b
2187   134D D8            push b
2188   134E FA F1 FF      lea d, [bp + -15] ; $h
2189   1351 D7            push a
2190   1352 DA            push d
2191   1353 FA E5 FF      lea d, [bp + -27] ; $j
2192   1356 2A            mov b, [d]
2193   1357 E7            pop d
2194   1358 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
2195   135C E4            pop a
2196   135D 2A            mov b, [d]
2197   135E FD AB         swp b
2198   1360 D8            push b
2199   1361 07 60 11      call rotr
2200   1364 51 04 00      add sp, 4
2201   1367 E7            pop d
2202   1368 FD 43         mov [d], b
2203   136A             _for25_update:
2204   136A FA E5 FF      lea d, [bp + -27] ; $j
2205   136D 2A            mov b, [d]
2206   136E FD 79         mov g, b
2207   1370 FD 77         inc b
2208   1372 FA E5 FF      lea d, [bp + -27] ; $j
2209   1375 FD 43         mov [d], b
2210   1377 FD 27         mov b, g
2211   1379 0A 97 12      jmp _for25_cond
2212   137C             _for25_exit:
2213   137C             _for24_update:
2214   137C FA E7 FF      lea d, [bp + -25] ; $i
2215   137F 2A            mov b, [d]
2216   1380 FD 79         mov g, b
2217   1382 FD 77         inc b
2218   1384 FA E7 FF      lea d, [bp + -25] ; $i
2219   1387 FD 43         mov [d], b
2220   1389 FD 27         mov b, g
2221   138B 0A 5C 12      jmp _for24_cond
2222   138E             _for24_exit:
2223   138E             ;; for (i = 0; i <  16         / 2; i++) { 
2224   138E             _for26_init:
2225   138E FA E7 FF      lea d, [bp + -25] ; $i
2226   1391 DA            push d
2227   1392 26 00 00      mov b, $0
2228   1395 E7            pop d
2229   1396 FD 43         mov [d], b
2230   1398             _for26_cond:
2231   1398 FA E7 FF      lea d, [bp + -25] ; $i
2232   139B 2A            mov b, [d]
2233   139C             ; START RELATIONAL
2234   139C D7            push a
2235   139D 11            mov a, b
2236   139E 26 10 00      mov b, $10
2237   13A1             ; START FACTORS
2238   13A1 D7            push a
2239   13A2 11            mov a, b
2240   13A3 26 02 00      mov b, $2
2241   13A6 AE            div a, b
2242   13A7 27            mov b, a
2243   13A8 E4            pop a
2244   13A9             ; END FACTORS
2245   13A9 B0            cmp a, b
2246   13AA FD 73         slt ; < 
2247   13AC E4            pop a
2248   13AD             ; END RELATIONAL
2249   13AD C0 00 00      cmp b, 0
2250   13B0 C6 3B 14      je _for26_exit
2251   13B3             _for26_block:
2252   13B3             ;; output[i * 2] = h[i] & 0xFF; 
2253   13B3 2C 05 00      mov b, [bp + 5] ; $output
2254   13B6 74            mov d, b
2255   13B7 D7            push a
2256   13B8 DA            push d
2257   13B9 FA E7 FF      lea d, [bp + -25] ; $i
2258   13BC 2A            mov b, [d]
2259   13BD             ; START FACTORS
2260   13BD D7            push a
2261   13BE 11            mov a, b
2262   13BF 26 02 00      mov b, $2
2263   13C2 AC            mul a, b ; *
2264   13C3 11            mov a, b
2265   13C4 27            mov b, a
2266   13C5 E4            pop a
2267   13C6             ; END FACTORS
2268   13C6 E7            pop d
2269   13C7 5A            add d, b
2270   13C8 E4            pop a
2271   13C9 DA            push d
2272   13CA FA F1 FF      lea d, [bp + -15] ; $h
2273   13CD D7            push a
2274   13CE DA            push d
2275   13CF FA E7 FF      lea d, [bp + -25] ; $i
2276   13D2 2A            mov b, [d]
2277   13D3 E7            pop d
2278   13D4 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
2279   13D8 E4            pop a
2280   13D9 2A            mov b, [d]
2281   13DA D7            push a
2282   13DB 11            mov a, b
2283   13DC 26 FF 00      mov b, $ff
2284   13DF 86            and a, b ; &
2285   13E0 27            mov b, a
2286   13E1 E4            pop a
2287   13E2 E7            pop d
2288   13E3 FD 3E         mov [d], bl
2289   13E5             ;; output[i * 2 + 1] = (h[i] >> 8) & 0xFF; 
2290   13E5 2C 05 00      mov b, [bp + 5] ; $output
2291   13E8 74            mov d, b
2292   13E9 D7            push a
2293   13EA DA            push d
2294   13EB FA E7 FF      lea d, [bp + -25] ; $i
2295   13EE 2A            mov b, [d]
2296   13EF             ; START FACTORS
2297   13EF D7            push a
2298   13F0 11            mov a, b
2299   13F1 26 02 00      mov b, $2
2300   13F4 AC            mul a, b ; *
2301   13F5 11            mov a, b
2302   13F6 27            mov b, a
2303   13F7 E4            pop a
2304   13F8             ; END FACTORS
2305   13F8             ; START TERMS
2306   13F8 D7            push a
2307   13F9 11            mov a, b
2308   13FA 26 01 00      mov b, $1
2309   13FD 54            add a, b
2310   13FE 27            mov b, a
2311   13FF E4            pop a
2312   1400             ; END TERMS
2313   1400 E7            pop d
2314   1401 5A            add d, b
2315   1402 E4            pop a
2316   1403 DA            push d
2317   1404 FA F1 FF      lea d, [bp + -15] ; $h
2318   1407 D7            push a
2319   1408 DA            push d
2320   1409 FA E7 FF      lea d, [bp + -25] ; $i
2321   140C 2A            mov b, [d]
2322   140D E7            pop d
2323   140E FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
2324   1412 E4            pop a
2325   1413 2A            mov b, [d]
2326   1414             ; START SHIFT
2327   1414 D7            push a
2328   1415 11            mov a, b
2329   1416 26 08 00      mov b, $8
2330   1419 FD 39         mov c, b
2331   141B A5            ashr a, cl
2332   141C 27            mov b, a
2333   141D E4            pop a
2334   141E             ; END SHIFT
2335   141E D7            push a
2336   141F 11            mov a, b
2337   1420 26 FF 00      mov b, $ff
2338   1423 86            and a, b ; &
2339   1424 27            mov b, a
2340   1425 E4            pop a
2341   1426 E7            pop d
2342   1427 FD 3E         mov [d], bl
2343   1429             _for26_update:
2344   1429 FA E7 FF      lea d, [bp + -25] ; $i
2345   142C 2A            mov b, [d]
2346   142D FD 79         mov g, b
2347   142F FD 77         inc b
2348   1431 FA E7 FF      lea d, [bp + -25] ; $i
2349   1434 FD 43         mov [d], b
2350   1436 FD 27         mov b, g
2351   1438 0A 98 13      jmp _for26_cond
2352   143B             _for26_exit:
2353   143B F9            leave
2354   143C 09            ret
2355   143D             ; --- END TEXT BLOCK
2356   143D             
2357   143D             ; --- BEGIN DATA BLOCK
2358   143D 48 65 6C 6C _text_data: .db "Hello World", 0
2358   1441 6F 20 57 6F 
2358   1445 72 6C 64 00 
2359   1449 3D 14       _text: .dw _text_data
2360   144B 48 61 73 68 __s0: .db "Hash: ", 0
2360   144F 3A 20 00 
2361   1452 0A 00       __s1: .db "\n", 0
2362   1454 45 72 72 6F __s2: .db "Error: Unknown argument type.\n", 0
2362   1458 72 3A 20 55 
2362   145C 6E 6B 6E 6F 
2362   1460 77 6E 20 61 
2362   1464 72 67 75 6D 
2362   1468 65 6E 74 20 
2362   146C 74 79 70 65 
2362   1470 2E 0A 00 
2363   1473 1B 5B 32 4A __s3: .db "\033[2J\033[H", 0
2363   1477 1B 5B 48 00 
2364   147B             
2365   147B 7D 14       _heap_top: .dw _heap
2366   147D 00          _heap: .db 0
2367   147E             ; --- END DATA BLOCK
2368   147E             
2369   147E             .end
tasm: Number of errors = 0
