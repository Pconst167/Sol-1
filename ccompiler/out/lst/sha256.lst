0001   0000             ; --- FILENAME: programs/sha256.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; unsigned char hash[ 16            ]; 
0011   0408 52 10 00      sub sp, 16
0012   040B             ; int i; 
0013   040B 52 02 00      sub sp, 2
0014   040E             ; printf("Hash: "); 
0015   040E             ; --- START FUNCTION CALL
0016   040E 26 D3 0F      mov b, _s0 ; "Hash: "
0017   0411 FD AB         swp b
0018   0413 D8            push b
0019   0414 07 84 04      call printf
0020   0417 51 02 00      add sp, 2
0021   041A             ; --- END FUNCTION CALL
0022   041A             ; for (i = 0; i < 16; i++) { 
0023   041A             _for1_init:
0024   041A FA EF FF      lea d, [bp + -17] ; $i
0025   041D DA            push d
0026   041E FD 2E 00 00   mov32 cb, $00000000
0026   0422 00 00 
0027   0424 E7            pop d
0028   0425 FD 43         mov [d], b
0029   0427             _for1_cond:
0030   0427 FA EF FF      lea d, [bp + -17] ; $i
0031   042A 2A            mov b, [d]
0032   042B 38 00 00      mov c, 0
0033   042E             ; --- START RELATIONAL
0034   042E D7            push a
0035   042F 11            mov a, b
0036   0430 FD 2E 10 00   mov32 cb, $00000010
0036   0434 00 00 
0037   0436 B0            cmp a, b
0038   0437 FD 73         slt ; < (signed)
0039   0439 E4            pop a
0040   043A             ; --- END RELATIONAL
0041   043A C0 00 00      cmp b, 0
0042   043D C6 6F 04      je _for1_exit
0043   0440             _for1_block:
0044   0440             ; printx8(hash[i]); 
0045   0440             ; --- START FUNCTION CALL
0046   0440 FA F1 FF      lea d, [bp + -15] ; $hash
0047   0443 D7            push a
0048   0444 DA            push d
0049   0445 FA EF FF      lea d, [bp + -17] ; $i
0050   0448 2A            mov b, [d]
0051   0449 38 00 00      mov c, 0
0052   044C E7            pop d
0053   044D 5A            add d, b
0054   044E E4            pop a
0055   044F 32            mov bl, [d]
0056   0450 A7 00         mov bh, 0
0057   0452 38 00 00      mov c, 0
0058   0455 DD            push bl
0059   0456 07 91 0D      call printx8
0060   0459 51 01 00      add sp, 1
0061   045C             ; --- END FUNCTION CALL
0062   045C             _for1_update:
0063   045C FA EF FF      lea d, [bp + -17] ; $i
0064   045F 2A            mov b, [d]
0065   0460 38 00 00      mov c, 0
0066   0463 11            mov a, b
0067   0464 FD 77         inc b
0068   0466 FA EF FF      lea d, [bp + -17] ; $i
0069   0469 FD 43         mov [d], b
0070   046B 27            mov b, a
0071   046C 0A 27 04      jmp _for1_cond
0072   046F             _for1_exit:
0073   046F             ; printf("\n"); 
0074   046F             ; --- START FUNCTION CALL
0075   046F 26 DA 0F      mov b, _s1 ; "\n"
0076   0472 FD AB         swp b
0077   0474 D8            push b
0078   0475 07 84 04      call printf
0079   0478 51 02 00      add sp, 2
0080   047B             ; --- END FUNCTION CALL
0081   047B             ; return 0; 
0082   047B FD 2E 00 00   mov32 cb, $00000000
0082   047F 00 00 
0083   0481 F9            leave
0084   0482 05 0B         syscall sys_terminate_proc
0085   0484             
0086   0484             printf:
0087   0484 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0088   0487             ; char *p, *format_p; 
0089   0487 52 02 00      sub sp, 2
0090   048A 52 02 00      sub sp, 2
0091   048D             ; format_p = format; 
0092   048D FA FD FF      lea d, [bp + -3] ; $format_p
0093   0490 DA            push d
0094   0491 FA 05 00      lea d, [bp + 5] ; $format
0095   0494 2A            mov b, [d]
0096   0495 38 00 00      mov c, 0
0097   0498 E7            pop d
0098   0499 FD 43         mov [d], b
0099   049B             ; p = &format + 2; 
0100   049B FA FF FF      lea d, [bp + -1] ; $p
0101   049E DA            push d
0102   049F FA 05 00      lea d, [bp + 5] ; $format
0103   04A2 2D            mov b, d
0104   04A3             ; --- START TERMS
0105   04A3 D7            push a
0106   04A4 11            mov a, b
0107   04A5 FD 2E 02 00   mov32 cb, $00000002
0107   04A9 00 00 
0108   04AB 56            add b, a
0109   04AC E4            pop a
0110   04AD             ; --- END TERMS
0111   04AD E7            pop d
0112   04AE FD 43         mov [d], b
0113   04B0             ; for(;;){ 
0114   04B0             _for2_init:
0115   04B0             _for2_cond:
0116   04B0             _for2_block:
0117   04B0             ; if(!*format_p) break; 
0118   04B0             _if3_cond:
0119   04B0 FA FD FF      lea d, [bp + -3] ; $format_p
0120   04B3 2A            mov b, [d]
0121   04B4 38 00 00      mov c, 0
0122   04B7 74            mov d, b
0123   04B8 32            mov bl, [d]
0124   04B9 A7 00         mov bh, 0
0125   04BB 38 00 00      mov c, 0
0126   04BE C0 00 00      cmp b, 0
0127   04C1 FD 71         seq ; !
0128   04C3 C0 00 00      cmp b, 0
0129   04C6 C6 CF 04      je _if3_else
0130   04C9             _if3_TRUE:
0131   04C9             ; break; 
0132   04C9 0A 7F 07      jmp _for2_exit ; for break
0133   04CC 0A 7C 07      jmp _if3_exit
0134   04CF             _if3_else:
0135   04CF             ; if(*format_p == '%'){ 
0136   04CF             _if4_cond:
0137   04CF FA FD FF      lea d, [bp + -3] ; $format_p
0138   04D2 2A            mov b, [d]
0139   04D3 38 00 00      mov c, 0
0140   04D6 74            mov d, b
0141   04D7 32            mov bl, [d]
0142   04D8 A7 00         mov bh, 0
0143   04DA 38 00 00      mov c, 0
0144   04DD             ; --- START RELATIONAL
0145   04DD D7            push a
0146   04DE 11            mov a, b
0147   04DF FD 2E 25 00   mov32 cb, $00000025
0147   04E3 00 00 
0148   04E5 B0            cmp a, b
0149   04E6 FD 71         seq ; ==
0150   04E8 E4            pop a
0151   04E9             ; --- END RELATIONAL
0152   04E9 C0 00 00      cmp b, 0
0153   04EC C6 57 07      je _if4_else
0154   04EF             _if4_TRUE:
0155   04EF             ; format_p++; 
0156   04EF FA FD FF      lea d, [bp + -3] ; $format_p
0157   04F2 2A            mov b, [d]
0158   04F3 38 00 00      mov c, 0
0159   04F6 FD 77         inc b
0160   04F8 FA FD FF      lea d, [bp + -3] ; $format_p
0161   04FB FD 43         mov [d], b
0162   04FD FD 7D         dec b
0163   04FF             ; switch(*format_p){ 
0164   04FF             _switch5_expr:
0165   04FF FA FD FF      lea d, [bp + -3] ; $format_p
0166   0502 2A            mov b, [d]
0167   0503 38 00 00      mov c, 0
0168   0506 74            mov d, b
0169   0507 32            mov bl, [d]
0170   0508 A7 00         mov bh, 0
0171   050A 38 00 00      mov c, 0
0172   050D             _switch5_comparisons:
0173   050D C1 6C         cmp bl, $6c
0174   050F C6 3B 05      je _switch5_case0
0175   0512 C1 4C         cmp bl, $4c
0176   0514 C6 3B 05      je _switch5_case1
0177   0517 C1 64         cmp bl, $64
0178   0519 C6 4B 06      je _switch5_case2
0179   051C C1 69         cmp bl, $69
0180   051E C6 4B 06      je _switch5_case3
0181   0521 C1 75         cmp bl, $75
0182   0523 C6 7B 06      je _switch5_case4
0183   0526 C1 78         cmp bl, $78
0184   0528 C6 AB 06      je _switch5_case5
0185   052B C1 63         cmp bl, $63
0186   052D C6 DB 06      je _switch5_case6
0187   0530 C1 73         cmp bl, $73
0188   0532 C6 0B 07      je _switch5_case7
0189   0535 0A 38 07      jmp _switch5_default
0190   0538 0A 44 07      jmp _switch5_exit
0191   053B             _switch5_case0:
0192   053B             _switch5_case1:
0193   053B             ; format_p++; 
0194   053B FA FD FF      lea d, [bp + -3] ; $format_p
0195   053E 2A            mov b, [d]
0196   053F 38 00 00      mov c, 0
0197   0542 FD 77         inc b
0198   0544 FA FD FF      lea d, [bp + -3] ; $format_p
0199   0547 FD 43         mov [d], b
0200   0549 FD 7D         dec b
0201   054B             ; if(*format_p == 'd' || *format_p == 'i') 
0202   054B             _if6_cond:
0203   054B FA FD FF      lea d, [bp + -3] ; $format_p
0204   054E 2A            mov b, [d]
0205   054F 38 00 00      mov c, 0
0206   0552 74            mov d, b
0207   0553 32            mov bl, [d]
0208   0554 A7 00         mov bh, 0
0209   0556 38 00 00      mov c, 0
0210   0559             ; --- START RELATIONAL
0211   0559 D7            push a
0212   055A 11            mov a, b
0213   055B FD 2E 64 00   mov32 cb, $00000064
0213   055F 00 00 
0214   0561 B0            cmp a, b
0215   0562 FD 71         seq ; ==
0216   0564 E4            pop a
0217   0565             ; --- END RELATIONAL
0218   0565             ; --- START LOGICAL OR
0219   0565 D7            push a
0220   0566 11            mov a, b
0221   0567 FA FD FF      lea d, [bp + -3] ; $format_p
0222   056A 2A            mov b, [d]
0223   056B 38 00 00      mov c, 0
0224   056E 74            mov d, b
0225   056F 32            mov bl, [d]
0226   0570 A7 00         mov bh, 0
0227   0572 38 00 00      mov c, 0
0228   0575             ; --- START RELATIONAL
0229   0575 D7            push a
0230   0576 11            mov a, b
0231   0577 FD 2E 69 00   mov32 cb, $00000069
0231   057B 00 00 
0232   057D B0            cmp a, b
0233   057E FD 71         seq ; ==
0234   0580 E4            pop a
0235   0581             ; --- END RELATIONAL
0236   0581 FD A8         sor a, b ; ||
0237   0583 E4            pop a
0238   0584             ; --- END LOGICAL OR
0239   0584 C0 00 00      cmp b, 0
0240   0587 C6 A8 05      je _if6_else
0241   058A             _if6_TRUE:
0242   058A             ; print_signed_long(*(long *)p); 
0243   058A             ; --- START FUNCTION CALL
0244   058A FA FF FF      lea d, [bp + -1] ; $p
0245   058D 2A            mov b, [d]
0246   058E 38 00 00      mov c, 0
0247   0591 74            mov d, b
0248   0592 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0249   0595 FD 39         mov c, b ; And place it into C
0250   0597 2A            mov b, [d] ; Lower Word in B
0251   0598 12            mov a, c
0252   0599 FD AA         swp a
0253   059B D7            push a
0254   059C FD AB         swp b
0255   059E D8            push b
0256   059F 07 81 07      call print_signed_long
0257   05A2 51 04 00      add sp, 4
0258   05A5             ; --- END FUNCTION CALL
0259   05A5 0A 30 06      jmp _if6_exit
0260   05A8             _if6_else:
0261   05A8             ; if(*format_p == 'u') 
0262   05A8             _if7_cond:
0263   05A8 FA FD FF      lea d, [bp + -3] ; $format_p
0264   05AB 2A            mov b, [d]
0265   05AC 38 00 00      mov c, 0
0266   05AF 74            mov d, b
0267   05B0 32            mov bl, [d]
0268   05B1 A7 00         mov bh, 0
0269   05B3 38 00 00      mov c, 0
0270   05B6             ; --- START RELATIONAL
0271   05B6 D7            push a
0272   05B7 11            mov a, b
0273   05B8 FD 2E 75 00   mov32 cb, $00000075
0273   05BC 00 00 
0274   05BE B0            cmp a, b
0275   05BF FD 71         seq ; ==
0276   05C1 E4            pop a
0277   05C2             ; --- END RELATIONAL
0278   05C2 C0 00 00      cmp b, 0
0279   05C5 C6 E6 05      je _if7_else
0280   05C8             _if7_TRUE:
0281   05C8             ; print_unsigned_long(*(unsigned long *)p); 
0282   05C8             ; --- START FUNCTION CALL
0283   05C8 FA FF FF      lea d, [bp + -1] ; $p
0284   05CB 2A            mov b, [d]
0285   05CC 38 00 00      mov c, 0
0286   05CF 74            mov d, b
0287   05D0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0288   05D3 FD 39         mov c, b ; And place it into C
0289   05D5 2A            mov b, [d] ; Lower Word in B
0290   05D6 12            mov a, c
0291   05D7 FD AA         swp a
0292   05D9 D7            push a
0293   05DA FD AB         swp b
0294   05DC D8            push b
0295   05DD 07 14 09      call print_unsigned_long
0296   05E0 51 04 00      add sp, 4
0297   05E3             ; --- END FUNCTION CALL
0298   05E3 0A 30 06      jmp _if7_exit
0299   05E6             _if7_else:
0300   05E6             ; if(*format_p == 'x') 
0301   05E6             _if8_cond:
0302   05E6 FA FD FF      lea d, [bp + -3] ; $format_p
0303   05E9 2A            mov b, [d]
0304   05EA 38 00 00      mov c, 0
0305   05ED 74            mov d, b
0306   05EE 32            mov bl, [d]
0307   05EF A7 00         mov bh, 0
0308   05F1 38 00 00      mov c, 0
0309   05F4             ; --- START RELATIONAL
0310   05F4 D7            push a
0311   05F5 11            mov a, b
0312   05F6 FD 2E 78 00   mov32 cb, $00000078
0312   05FA 00 00 
0313   05FC B0            cmp a, b
0314   05FD FD 71         seq ; ==
0315   05FF E4            pop a
0316   0600             ; --- END RELATIONAL
0317   0600 C0 00 00      cmp b, 0
0318   0603 C6 24 06      je _if8_else
0319   0606             _if8_TRUE:
0320   0606             ; printx32(*(long int *)p); 
0321   0606             ; --- START FUNCTION CALL
0322   0606 FA FF FF      lea d, [bp + -1] ; $p
0323   0609 2A            mov b, [d]
0324   060A 38 00 00      mov c, 0
0325   060D 74            mov d, b
0326   060E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0327   0611 FD 39         mov c, b ; And place it into C
0328   0613 2A            mov b, [d] ; Lower Word in B
0329   0614 12            mov a, c
0330   0615 FD AA         swp a
0331   0617 D7            push a
0332   0618 FD AB         swp b
0333   061A D8            push b
0334   061B 07 48 0A      call printx32
0335   061E 51 04 00      add sp, 4
0336   0621             ; --- END FUNCTION CALL
0337   0621 0A 30 06      jmp _if8_exit
0338   0624             _if8_else:
0339   0624             ; err("Unexpected format in printf."); 
0340   0624             ; --- START FUNCTION CALL
0341   0624 26 DC 0F      mov b, _s2 ; "Unexpected format in printf."
0342   0627 FD AB         swp b
0343   0629 D8            push b
0344   062A 07 A8 0A      call err
0345   062D 51 02 00      add sp, 2
0346   0630             ; --- END FUNCTION CALL
0347   0630             _if8_exit:
0348   0630             _if7_exit:
0349   0630             _if6_exit:
0350   0630             ; p = p + 4; 
0351   0630 FA FF FF      lea d, [bp + -1] ; $p
0352   0633 DA            push d
0353   0634 FA FF FF      lea d, [bp + -1] ; $p
0354   0637 2A            mov b, [d]
0355   0638 38 00 00      mov c, 0
0356   063B             ; --- START TERMS
0357   063B D7            push a
0358   063C 11            mov a, b
0359   063D FD 2E 04 00   mov32 cb, $00000004
0359   0641 00 00 
0360   0643 56            add b, a
0361   0644 E4            pop a
0362   0645             ; --- END TERMS
0363   0645 E7            pop d
0364   0646 FD 43         mov [d], b
0365   0648             ; break; 
0366   0648 0A 44 07      jmp _switch5_exit ; case break
0367   064B             _switch5_case2:
0368   064B             _switch5_case3:
0369   064B             ; print_signed(*(int*)p); 
0370   064B             ; --- START FUNCTION CALL
0371   064B FA FF FF      lea d, [bp + -1] ; $p
0372   064E 2A            mov b, [d]
0373   064F 38 00 00      mov c, 0
0374   0652 74            mov d, b
0375   0653 2A            mov b, [d]
0376   0654 38 00 00      mov c, 0
0377   0657 FD AB         swp b
0378   0659 D8            push b
0379   065A 07 D6 0A      call print_signed
0380   065D 51 02 00      add sp, 2
0381   0660             ; --- END FUNCTION CALL
0382   0660             ; p = p + 2; 
0383   0660 FA FF FF      lea d, [bp + -1] ; $p
0384   0663 DA            push d
0385   0664 FA FF FF      lea d, [bp + -1] ; $p
0386   0667 2A            mov b, [d]
0387   0668 38 00 00      mov c, 0
0388   066B             ; --- START TERMS
0389   066B D7            push a
0390   066C 11            mov a, b
0391   066D FD 2E 02 00   mov32 cb, $00000002
0391   0671 00 00 
0392   0673 56            add b, a
0393   0674 E4            pop a
0394   0675             ; --- END TERMS
0395   0675 E7            pop d
0396   0676 FD 43         mov [d], b
0397   0678             ; break; 
0398   0678 0A 44 07      jmp _switch5_exit ; case break
0399   067B             _switch5_case4:
0400   067B             ; print_unsigned(*(unsigned int*)p); 
0401   067B             ; --- START FUNCTION CALL
0402   067B FA FF FF      lea d, [bp + -1] ; $p
0403   067E 2A            mov b, [d]
0404   067F 38 00 00      mov c, 0
0405   0682 74            mov d, b
0406   0683 2A            mov b, [d]
0407   0684 38 00 00      mov c, 0
0408   0687 FD AB         swp b
0409   0689 D8            push b
0410   068A 07 27 0C      call print_unsigned
0411   068D 51 02 00      add sp, 2
0412   0690             ; --- END FUNCTION CALL
0413   0690             ; p = p + 2; 
0414   0690 FA FF FF      lea d, [bp + -1] ; $p
0415   0693 DA            push d
0416   0694 FA FF FF      lea d, [bp + -1] ; $p
0417   0697 2A            mov b, [d]
0418   0698 38 00 00      mov c, 0
0419   069B             ; --- START TERMS
0420   069B D7            push a
0421   069C 11            mov a, b
0422   069D FD 2E 02 00   mov32 cb, $00000002
0422   06A1 00 00 
0423   06A3 56            add b, a
0424   06A4 E4            pop a
0425   06A5             ; --- END TERMS
0426   06A5 E7            pop d
0427   06A6 FD 43         mov [d], b
0428   06A8             ; break; 
0429   06A8 0A 44 07      jmp _switch5_exit ; case break
0430   06AB             _switch5_case5:
0431   06AB             ; printx16(*(int*)p); 
0432   06AB             ; --- START FUNCTION CALL
0433   06AB FA FF FF      lea d, [bp + -1] ; $p
0434   06AE 2A            mov b, [d]
0435   06AF 38 00 00      mov c, 0
0436   06B2 74            mov d, b
0437   06B3 2A            mov b, [d]
0438   06B4 38 00 00      mov c, 0
0439   06B7 FD AB         swp b
0440   06B9 D8            push b
0441   06BA 07 3F 0D      call printx16
0442   06BD 51 02 00      add sp, 2
0443   06C0             ; --- END FUNCTION CALL
0444   06C0             ; p = p + 2; 
0445   06C0 FA FF FF      lea d, [bp + -1] ; $p
0446   06C3 DA            push d
0447   06C4 FA FF FF      lea d, [bp + -1] ; $p
0448   06C7 2A            mov b, [d]
0449   06C8 38 00 00      mov c, 0
0450   06CB             ; --- START TERMS
0451   06CB D7            push a
0452   06CC 11            mov a, b
0453   06CD FD 2E 02 00   mov32 cb, $00000002
0453   06D1 00 00 
0454   06D3 56            add b, a
0455   06D4 E4            pop a
0456   06D5             ; --- END TERMS
0457   06D5 E7            pop d
0458   06D6 FD 43         mov [d], b
0459   06D8             ; break; 
0460   06D8 0A 44 07      jmp _switch5_exit ; case break
0461   06DB             _switch5_case6:
0462   06DB             ; putchar(*(char*)p); 
0463   06DB             ; --- START FUNCTION CALL
0464   06DB FA FF FF      lea d, [bp + -1] ; $p
0465   06DE 2A            mov b, [d]
0466   06DF 38 00 00      mov c, 0
0467   06E2 74            mov d, b
0468   06E3 32            mov bl, [d]
0469   06E4 A7 00         mov bh, 0
0470   06E6 38 00 00      mov c, 0
0471   06E9 DD            push bl
0472   06EA 07 06 09      call putchar
0473   06ED 51 01 00      add sp, 1
0474   06F0             ; --- END FUNCTION CALL
0475   06F0             ; p = p + 2; 
0476   06F0 FA FF FF      lea d, [bp + -1] ; $p
0477   06F3 DA            push d
0478   06F4 FA FF FF      lea d, [bp + -1] ; $p
0479   06F7 2A            mov b, [d]
0480   06F8 38 00 00      mov c, 0
0481   06FB             ; --- START TERMS
0482   06FB D7            push a
0483   06FC 11            mov a, b
0484   06FD FD 2E 02 00   mov32 cb, $00000002
0484   0701 00 00 
0485   0703 56            add b, a
0486   0704 E4            pop a
0487   0705             ; --- END TERMS
0488   0705 E7            pop d
0489   0706 FD 43         mov [d], b
0490   0708             ; break; 
0491   0708 0A 44 07      jmp _switch5_exit ; case break
0492   070B             _switch5_case7:
0493   070B             ; print(*(char**)p); 
0494   070B             ; --- START FUNCTION CALL
0495   070B FA FF FF      lea d, [bp + -1] ; $p
0496   070E 2A            mov b, [d]
0497   070F 38 00 00      mov c, 0
0498   0712 74            mov d, b
0499   0713 2A            mov b, [d]
0500   0714 FD AB         swp b
0501   0716 D8            push b
0502   0717 07 BD 0A      call print
0503   071A 51 02 00      add sp, 2
0504   071D             ; --- END FUNCTION CALL
0505   071D             ; p = p + 2; 
0506   071D FA FF FF      lea d, [bp + -1] ; $p
0507   0720 DA            push d
0508   0721 FA FF FF      lea d, [bp + -1] ; $p
0509   0724 2A            mov b, [d]
0510   0725 38 00 00      mov c, 0
0511   0728             ; --- START TERMS
0512   0728 D7            push a
0513   0729 11            mov a, b
0514   072A FD 2E 02 00   mov32 cb, $00000002
0514   072E 00 00 
0515   0730 56            add b, a
0516   0731 E4            pop a
0517   0732             ; --- END TERMS
0518   0732 E7            pop d
0519   0733 FD 43         mov [d], b
0520   0735             ; break; 
0521   0735 0A 44 07      jmp _switch5_exit ; case break
0522   0738             _switch5_default:
0523   0738             ; print("Error: Unknown argument type.\n"); 
0524   0738             ; --- START FUNCTION CALL
0525   0738 26 F9 0F      mov b, _s3 ; "Error: Unknown argument type.\n"
0526   073B FD AB         swp b
0527   073D D8            push b
0528   073E 07 BD 0A      call print
0529   0741 51 02 00      add sp, 2
0530   0744             ; --- END FUNCTION CALL
0531   0744             _switch5_exit:
0532   0744             ; format_p++; 
0533   0744 FA FD FF      lea d, [bp + -3] ; $format_p
0534   0747 2A            mov b, [d]
0535   0748 38 00 00      mov c, 0
0536   074B FD 77         inc b
0537   074D FA FD FF      lea d, [bp + -3] ; $format_p
0538   0750 FD 43         mov [d], b
0539   0752 FD 7D         dec b
0540   0754 0A 7C 07      jmp _if4_exit
0541   0757             _if4_else:
0542   0757             ; putchar(*format_p); 
0543   0757             ; --- START FUNCTION CALL
0544   0757 FA FD FF      lea d, [bp + -3] ; $format_p
0545   075A 2A            mov b, [d]
0546   075B 38 00 00      mov c, 0
0547   075E 74            mov d, b
0548   075F 32            mov bl, [d]
0549   0760 A7 00         mov bh, 0
0550   0762 38 00 00      mov c, 0
0551   0765 DD            push bl
0552   0766 07 06 09      call putchar
0553   0769 51 01 00      add sp, 1
0554   076C             ; --- END FUNCTION CALL
0555   076C             ; format_p++; 
0556   076C FA FD FF      lea d, [bp + -3] ; $format_p
0557   076F 2A            mov b, [d]
0558   0770 38 00 00      mov c, 0
0559   0773 FD 77         inc b
0560   0775 FA FD FF      lea d, [bp + -3] ; $format_p
0561   0778 FD 43         mov [d], b
0562   077A FD 7D         dec b
0563   077C             _if4_exit:
0564   077C             _if3_exit:
0565   077C             _for2_update:
0566   077C 0A B0 04      jmp _for2_cond
0567   077F             _for2_exit:
0568   077F F9            leave
0569   0780 09            ret
0570   0781             
0571   0781             print_signed_long:
0572   0781 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0573   0784             ; char digits[10]; 
0574   0784 52 0A 00      sub sp, 10
0575   0787             ; int i = 0; 
0576   0787 52 02 00      sub sp, 2
0577   078A             ; --- START LOCAL VAR INITIALIZATION
0578   078A FA F5 FF      lea d, [bp + -11] ; $i
0579   078D DA            push d
0580   078E FD 2E 00 00   mov32 cb, $00000000
0580   0792 00 00 
0581   0794 E7            pop d
0582   0795 FD 43         mov [d], b
0583   0797             ; --- END LOCAL VAR INITIALIZATION
0584   0797             ; if (num < 0) { 
0585   0797             _if9_cond:
0586   0797 FA 05 00      lea d, [bp + 5] ; $num
0587   079A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0588   079D FD 39         mov c, b ; And place it into C
0589   079F 2A            mov b, [d] ; Lower Word in B
0590   07A0             ; --- START RELATIONAL
0591   07A0 D7            push a
0592   07A1 FD D8         push g
0593   07A3 11            mov a, b
0594   07A4 FD 7A         mov g, c
0595   07A6 FD 2E 00 00   mov32 cb, $00000000
0595   07AA 00 00 
0596   07AC FD AF         cmp32 ga, cb
0597   07AE FD 73         slt ; <
0598   07B0 FD F1         pop g
0599   07B2 E4            pop a
0600   07B3             ; --- END RELATIONAL
0601   07B3 C0 00 00      cmp b, 0
0602   07B6 C6 E8 07      je _if9_else
0603   07B9             _if9_TRUE:
0604   07B9             ; putchar('-'); 
0605   07B9             ; --- START FUNCTION CALL
0606   07B9 FD 2E 2D 00   mov32 cb, $0000002d
0606   07BD 00 00 
0607   07BF DD            push bl
0608   07C0 07 06 09      call putchar
0609   07C3 51 01 00      add sp, 1
0610   07C6             ; --- END FUNCTION CALL
0611   07C6             ; num = -num; 
0612   07C6 FA 05 00      lea d, [bp + 5] ; $num
0613   07C9 DA            push d
0614   07CA FA 05 00      lea d, [bp + 5] ; $num
0615   07CD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0616   07D0 FD 39         mov c, b ; And place it into C
0617   07D2 2A            mov b, [d] ; Lower Word in B
0618   07D3 12            mov a, c
0619   07D4 95            not a
0620   07D5 97            not b
0621   07D6 55 01 00      add b, 1
0622   07D9 5B 00 00      adc a, 0
0623   07DC 39            mov c, a
0624   07DD E7            pop d
0625   07DE FD 43         mov [d], b
0626   07E0 28            mov b, c
0627   07E1 FD 44 02 00   mov [d + 2], b
0628   07E5 0A 1C 08      jmp _if9_exit
0629   07E8             _if9_else:
0630   07E8             ; if (num == 0) { 
0631   07E8             _if10_cond:
0632   07E8 FA 05 00      lea d, [bp + 5] ; $num
0633   07EB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0634   07EE FD 39         mov c, b ; And place it into C
0635   07F0 2A            mov b, [d] ; Lower Word in B
0636   07F1             ; --- START RELATIONAL
0637   07F1 D7            push a
0638   07F2 FD D8         push g
0639   07F4 11            mov a, b
0640   07F5 FD 7A         mov g, c
0641   07F7 FD 2E 00 00   mov32 cb, $00000000
0641   07FB 00 00 
0642   07FD FD AF         cmp32 ga, cb
0643   07FF FD 71         seq ; ==
0644   0801 FD F1         pop g
0645   0803 E4            pop a
0646   0804             ; --- END RELATIONAL
0647   0804 C0 00 00      cmp b, 0
0648   0807 C6 1C 08      je _if10_exit
0649   080A             _if10_TRUE:
0650   080A             ; putchar('0'); 
0651   080A             ; --- START FUNCTION CALL
0652   080A FD 2E 30 00   mov32 cb, $00000030
0652   080E 00 00 
0653   0810 DD            push bl
0654   0811 07 06 09      call putchar
0655   0814 51 01 00      add sp, 1
0656   0817             ; --- END FUNCTION CALL
0657   0817             ; return; 
0658   0817 F9            leave
0659   0818 09            ret
0660   0819 0A 1C 08      jmp _if10_exit
0661   081C             _if10_exit:
0662   081C             _if9_exit:
0663   081C             ; while (num > 0) { 
0664   081C             _while11_cond:
0665   081C FA 05 00      lea d, [bp + 5] ; $num
0666   081F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0667   0822 FD 39         mov c, b ; And place it into C
0668   0824 2A            mov b, [d] ; Lower Word in B
0669   0825             ; --- START RELATIONAL
0670   0825 D7            push a
0671   0826 FD D8         push g
0672   0828 11            mov a, b
0673   0829 FD 7A         mov g, c
0674   082B FD 2E 00 00   mov32 cb, $00000000
0674   082F 00 00 
0675   0831 FD AF         cmp32 ga, cb
0676   0833 FD 7F         sgt
0677   0835 FD F1         pop g
0678   0837 E4            pop a
0679   0838             ; --- END RELATIONAL
0680   0838 C0 00 00      cmp b, 0
0681   083B C6 BC 08      je _while11_exit
0682   083E             _while11_block:
0683   083E             ; digits[i] = '0' + (num % 10); 
0684   083E FA F7 FF      lea d, [bp + -9] ; $digits
0685   0841 D7            push a
0686   0842 DA            push d
0687   0843 FA F5 FF      lea d, [bp + -11] ; $i
0688   0846 2A            mov b, [d]
0689   0847 38 00 00      mov c, 0
0690   084A E7            pop d
0691   084B 5A            add d, b
0692   084C E4            pop a
0693   084D DA            push d
0694   084E FD 2E 30 00   mov32 cb, $00000030
0694   0852 00 00 
0695   0854             ; --- START TERMS
0696   0854 D7            push a
0697   0855 11            mov a, b
0698   0856 FA 05 00      lea d, [bp + 5] ; $num
0699   0859 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0700   085C FD 39         mov c, b ; And place it into C
0701   085E 2A            mov b, [d] ; Lower Word in B
0702   085F             ; --- START FACTORS
0703   085F D7            push a
0704   0860 FD D8         push g
0705   0862 11            mov a, b
0706   0863 FD 7A         mov g, c
0707   0865 FD 2E 0A 00   mov32 cb, $0000000a
0707   0869 00 00 
0708   086B FD D8         push g ; save 'g' as the div instruction uses it
0709   086D AE            div a, b ; %, a: quotient, b: remainder
0710   086E 11            mov a, b
0711   086F FD F1         pop g
0712   0871 FD 38         mov c, g
0713   0873 27            mov b, a
0714   0874 FD F1         pop g
0715   0876 E4            pop a
0716   0877             ; --- END FACTORS
0717   0877 FD 15         add32 cb, ga
0718   0879 E4            pop a
0719   087A             ; --- END TERMS
0720   087A E7            pop d
0721   087B FD 3E         mov [d], bl
0722   087D             ; num = num / 10; 
0723   087D FA 05 00      lea d, [bp + 5] ; $num
0724   0880 DA            push d
0725   0881 FA 05 00      lea d, [bp + 5] ; $num
0726   0884 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0727   0887 FD 39         mov c, b ; And place it into C
0728   0889 2A            mov b, [d] ; Lower Word in B
0729   088A             ; --- START FACTORS
0730   088A D7            push a
0731   088B FD D8         push g
0732   088D 11            mov a, b
0733   088E FD 7A         mov g, c
0734   0890 FD 2E 0A 00   mov32 cb, $0000000a
0734   0894 00 00 
0735   0896 FD D8         push g ; save 'g' as the div instruction uses it
0736   0898 AE            div a, b ; /, a: quotient, b: remainder
0737   0899 FD F1         pop g
0738   089B FD 38         mov c, g
0739   089D 27            mov b, a
0740   089E FD F1         pop g
0741   08A0 E4            pop a
0742   08A1             ; --- END FACTORS
0743   08A1 E7            pop d
0744   08A2 FD 43         mov [d], b
0745   08A4 28            mov b, c
0746   08A5 FD 44 02 00   mov [d + 2], b
0747   08A9             ; i++; 
0748   08A9 FA F5 FF      lea d, [bp + -11] ; $i
0749   08AC 2A            mov b, [d]
0750   08AD 38 00 00      mov c, 0
0751   08B0 11            mov a, b
0752   08B1 FD 77         inc b
0753   08B3 FA F5 FF      lea d, [bp + -11] ; $i
0754   08B6 FD 43         mov [d], b
0755   08B8 27            mov b, a
0756   08B9 0A 1C 08      jmp _while11_cond
0757   08BC             _while11_exit:
0758   08BC             ; while (i > 0) { 
0759   08BC             _while18_cond:
0760   08BC FA F5 FF      lea d, [bp + -11] ; $i
0761   08BF 2A            mov b, [d]
0762   08C0 38 00 00      mov c, 0
0763   08C3             ; --- START RELATIONAL
0764   08C3 D7            push a
0765   08C4 11            mov a, b
0766   08C5 FD 2E 00 00   mov32 cb, $00000000
0766   08C9 00 00 
0767   08CB B0            cmp a, b
0768   08CC FD 7F         sgt ; >
0769   08CE E4            pop a
0770   08CF             ; --- END RELATIONAL
0771   08CF C0 00 00      cmp b, 0
0772   08D2 C6 04 09      je _while18_exit
0773   08D5             _while18_block:
0774   08D5             ; i--; 
0775   08D5 FA F5 FF      lea d, [bp + -11] ; $i
0776   08D8 2A            mov b, [d]
0777   08D9 38 00 00      mov c, 0
0778   08DC 11            mov a, b
0779   08DD FD 7D         dec b
0780   08DF FA F5 FF      lea d, [bp + -11] ; $i
0781   08E2 FD 43         mov [d], b
0782   08E4 27            mov b, a
0783   08E5             ; putchar(digits[i]); 
0784   08E5             ; --- START FUNCTION CALL
0785   08E5 FA F7 FF      lea d, [bp + -9] ; $digits
0786   08E8 D7            push a
0787   08E9 DA            push d
0788   08EA FA F5 FF      lea d, [bp + -11] ; $i
0789   08ED 2A            mov b, [d]
0790   08EE 38 00 00      mov c, 0
0791   08F1 E7            pop d
0792   08F2 5A            add d, b
0793   08F3 E4            pop a
0794   08F4 32            mov bl, [d]
0795   08F5 A7 00         mov bh, 0
0796   08F7 38 00 00      mov c, 0
0797   08FA DD            push bl
0798   08FB 07 06 09      call putchar
0799   08FE 51 01 00      add sp, 1
0800   0901             ; --- END FUNCTION CALL
0801   0901 0A BC 08      jmp _while18_cond
0802   0904             _while18_exit:
0803   0904 F9            leave
0804   0905 09            ret
0805   0906             
0806   0906             putchar:
0807   0906 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0808   0909             ; --- BEGIN INLINE ASM SEGMENT
0809   0909 FA 05 00      lea d, [bp + 5] ; $c
0810   090C 1E            mov al, [d]
0811   090D 23            mov ah, al
0812   090E 19 00         mov al, 0
0813   0910 05 03         syscall sys_io      ; char in AH
0814   0912             ; --- END INLINE ASM SEGMENT
0815   0912 F9            leave
0816   0913 09            ret
0817   0914             
0818   0914             print_unsigned_long:
0819   0914 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0820   0917             ; char digits[10]; 
0821   0917 52 0A 00      sub sp, 10
0822   091A             ; int i; 
0823   091A 52 02 00      sub sp, 2
0824   091D             ; i = 0; 
0825   091D FA F5 FF      lea d, [bp + -11] ; $i
0826   0920 DA            push d
0827   0921 FD 2E 00 00   mov32 cb, $00000000
0827   0925 00 00 
0828   0927 E7            pop d
0829   0928 FD 43         mov [d], b
0830   092A             ; if(num == 0){ 
0831   092A             _if19_cond:
0832   092A FA 05 00      lea d, [bp + 5] ; $num
0833   092D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0834   0930 FD 39         mov c, b ; And place it into C
0835   0932 2A            mov b, [d] ; Lower Word in B
0836   0933             ; --- START RELATIONAL
0837   0933 D7            push a
0838   0934 FD D8         push g
0839   0936 11            mov a, b
0840   0937 FD 7A         mov g, c
0841   0939 FD 2E 00 00   mov32 cb, $00000000
0841   093D 00 00 
0842   093F FD AF         cmp32 ga, cb
0843   0941 FD 71         seq ; ==
0844   0943 FD F1         pop g
0845   0945 E4            pop a
0846   0946             ; --- END RELATIONAL
0847   0946 C0 00 00      cmp b, 0
0848   0949 C6 5E 09      je _if19_exit
0849   094C             _if19_TRUE:
0850   094C             ; putchar('0'); 
0851   094C             ; --- START FUNCTION CALL
0852   094C FD 2E 30 00   mov32 cb, $00000030
0852   0950 00 00 
0853   0952 DD            push bl
0854   0953 07 06 09      call putchar
0855   0956 51 01 00      add sp, 1
0856   0959             ; --- END FUNCTION CALL
0857   0959             ; return; 
0858   0959 F9            leave
0859   095A 09            ret
0860   095B 0A 5E 09      jmp _if19_exit
0861   095E             _if19_exit:
0862   095E             ; while (num > 0) { 
0863   095E             _while20_cond:
0864   095E FA 05 00      lea d, [bp + 5] ; $num
0865   0961 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0866   0964 FD 39         mov c, b ; And place it into C
0867   0966 2A            mov b, [d] ; Lower Word in B
0868   0967             ; --- START RELATIONAL
0869   0967 D7            push a
0870   0968 FD D8         push g
0871   096A 11            mov a, b
0872   096B FD 7A         mov g, c
0873   096D FD 2E 00 00   mov32 cb, $00000000
0873   0971 00 00 
0874   0973 FD AF         cmp32 ga, cb
0875   0975 FD 81         sgu
0876   0977 FD F1         pop g
0877   0979 E4            pop a
0878   097A             ; --- END RELATIONAL
0879   097A C0 00 00      cmp b, 0
0880   097D C6 FE 09      je _while20_exit
0881   0980             _while20_block:
0882   0980             ; digits[i] = '0' + (num % 10); 
0883   0980 FA F7 FF      lea d, [bp + -9] ; $digits
0884   0983 D7            push a
0885   0984 DA            push d
0886   0985 FA F5 FF      lea d, [bp + -11] ; $i
0887   0988 2A            mov b, [d]
0888   0989 38 00 00      mov c, 0
0889   098C E7            pop d
0890   098D 5A            add d, b
0891   098E E4            pop a
0892   098F DA            push d
0893   0990 FD 2E 30 00   mov32 cb, $00000030
0893   0994 00 00 
0894   0996             ; --- START TERMS
0895   0996 D7            push a
0896   0997 11            mov a, b
0897   0998 FA 05 00      lea d, [bp + 5] ; $num
0898   099B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0899   099E FD 39         mov c, b ; And place it into C
0900   09A0 2A            mov b, [d] ; Lower Word in B
0901   09A1             ; --- START FACTORS
0902   09A1 D7            push a
0903   09A2 FD D8         push g
0904   09A4 11            mov a, b
0905   09A5 FD 7A         mov g, c
0906   09A7 FD 2E 0A 00   mov32 cb, $0000000a
0906   09AB 00 00 
0907   09AD FD D8         push g ; save 'g' as the div instruction uses it
0908   09AF AE            div a, b ; %, a: quotient, b: remainder
0909   09B0 11            mov a, b
0910   09B1 FD F1         pop g
0911   09B3 FD 38         mov c, g
0912   09B5 27            mov b, a
0913   09B6 FD F1         pop g
0914   09B8 E4            pop a
0915   09B9             ; --- END FACTORS
0916   09B9 FD 15         add32 cb, ga
0917   09BB E4            pop a
0918   09BC             ; --- END TERMS
0919   09BC E7            pop d
0920   09BD FD 3E         mov [d], bl
0921   09BF             ; num = num / 10; 
0922   09BF FA 05 00      lea d, [bp + 5] ; $num
0923   09C2 DA            push d
0924   09C3 FA 05 00      lea d, [bp + 5] ; $num
0925   09C6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0926   09C9 FD 39         mov c, b ; And place it into C
0927   09CB 2A            mov b, [d] ; Lower Word in B
0928   09CC             ; --- START FACTORS
0929   09CC D7            push a
0930   09CD FD D8         push g
0931   09CF 11            mov a, b
0932   09D0 FD 7A         mov g, c
0933   09D2 FD 2E 0A 00   mov32 cb, $0000000a
0933   09D6 00 00 
0934   09D8 FD D8         push g ; save 'g' as the div instruction uses it
0935   09DA AE            div a, b ; /, a: quotient, b: remainder
0936   09DB FD F1         pop g
0937   09DD FD 38         mov c, g
0938   09DF 27            mov b, a
0939   09E0 FD F1         pop g
0940   09E2 E4            pop a
0941   09E3             ; --- END FACTORS
0942   09E3 E7            pop d
0943   09E4 FD 43         mov [d], b
0944   09E6 28            mov b, c
0945   09E7 FD 44 02 00   mov [d + 2], b
0946   09EB             ; i++; 
0947   09EB FA F5 FF      lea d, [bp + -11] ; $i
0948   09EE 2A            mov b, [d]
0949   09EF 38 00 00      mov c, 0
0950   09F2 11            mov a, b
0951   09F3 FD 77         inc b
0952   09F5 FA F5 FF      lea d, [bp + -11] ; $i
0953   09F8 FD 43         mov [d], b
0954   09FA 27            mov b, a
0955   09FB 0A 5E 09      jmp _while20_cond
0956   09FE             _while20_exit:
0957   09FE             ; while (i > 0) { 
0958   09FE             _while27_cond:
0959   09FE FA F5 FF      lea d, [bp + -11] ; $i
0960   0A01 2A            mov b, [d]
0961   0A02 38 00 00      mov c, 0
0962   0A05             ; --- START RELATIONAL
0963   0A05 D7            push a
0964   0A06 11            mov a, b
0965   0A07 FD 2E 00 00   mov32 cb, $00000000
0965   0A0B 00 00 
0966   0A0D B0            cmp a, b
0967   0A0E FD 7F         sgt ; >
0968   0A10 E4            pop a
0969   0A11             ; --- END RELATIONAL
0970   0A11 C0 00 00      cmp b, 0
0971   0A14 C6 46 0A      je _while27_exit
0972   0A17             _while27_block:
0973   0A17             ; i--; 
0974   0A17 FA F5 FF      lea d, [bp + -11] ; $i
0975   0A1A 2A            mov b, [d]
0976   0A1B 38 00 00      mov c, 0
0977   0A1E 11            mov a, b
0978   0A1F FD 7D         dec b
0979   0A21 FA F5 FF      lea d, [bp + -11] ; $i
0980   0A24 FD 43         mov [d], b
0981   0A26 27            mov b, a
0982   0A27             ; putchar(digits[i]); 
0983   0A27             ; --- START FUNCTION CALL
0984   0A27 FA F7 FF      lea d, [bp + -9] ; $digits
0985   0A2A D7            push a
0986   0A2B DA            push d
0987   0A2C FA F5 FF      lea d, [bp + -11] ; $i
0988   0A2F 2A            mov b, [d]
0989   0A30 38 00 00      mov c, 0
0990   0A33 E7            pop d
0991   0A34 5A            add d, b
0992   0A35 E4            pop a
0993   0A36 32            mov bl, [d]
0994   0A37 A7 00         mov bh, 0
0995   0A39 38 00 00      mov c, 0
0996   0A3C DD            push bl
0997   0A3D 07 06 09      call putchar
0998   0A40 51 01 00      add sp, 1
0999   0A43             ; --- END FUNCTION CALL
1000   0A43 0A FE 09      jmp _while27_cond
1001   0A46             _while27_exit:
1002   0A46 F9            leave
1003   0A47 09            ret
1004   0A48             
1005   0A48             printx32:
1006   0A48 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1007   0A4B             ; --- BEGIN INLINE ASM SEGMENT
1008   0A4B FA 05 00      lea d, [bp + 5] ; $hex
1009   0A4E 2B 02 00      mov b, [d+2]
1010   0A51 07 5A 0A      call print_u16x_printx32
1011   0A54 2A            mov b, [d]
1012   0A55 07 5A 0A      call print_u16x_printx32
1013   0A58             ; --- END INLINE ASM SEGMENT
1014   0A58             ; return; 
1015   0A58 F9            leave
1016   0A59 09            ret
1017   0A5A             ; --- BEGIN INLINE ASM SEGMENT
1018   0A5A             print_u16x_printx32:
1019   0A5A D7            push a
1020   0A5B D8            push b
1021   0A5C DD            push bl
1022   0A5D 30            mov bl, bh
1023   0A5E 07 7C 0A      call _itoa_printx32        ; convert bh to char in A
1024   0A61 2F            mov bl, al        ; save al
1025   0A62 19 00         mov al, 0
1026   0A64 05 03         syscall sys_io        ; display AH
1027   0A66 24            mov ah, bl        ; retrieve al
1028   0A67 19 00         mov al, 0
1029   0A69 05 03         syscall sys_io        ; display AL
1030   0A6B EA            pop bl
1031   0A6C 07 7C 0A      call _itoa_printx32        ; convert bh to char in A
1032   0A6F 2F            mov bl, al        ; save al
1033   0A70 19 00         mov al, 0
1034   0A72 05 03         syscall sys_io        ; display AH
1035   0A74 24            mov ah, bl        ; retrieve al
1036   0A75 19 00         mov al, 0
1037   0A77 05 03         syscall sys_io        ; display AL
1038   0A79 E5            pop b
1039   0A7A E4            pop a
1040   0A7B 09            ret
1041   0A7C             _itoa_printx32:
1042   0A7C DA            push d
1043   0A7D D8            push b
1044   0A7E A7 00         mov bh, 0
1045   0A80 FD A4 04      shr bl, 4  
1046   0A83 74            mov d, b
1047   0A84 1F 96 0A      mov al, [d + s_hex_digits_printx32]
1048   0A87 23            mov ah, al
1049   0A88 E5            pop b
1050   0A89 D8            push b
1051   0A8A A7 00         mov bh, 0
1052   0A8C FD 87 0F      and bl, $0F
1053   0A8F 74            mov d, b
1054   0A90 1F 96 0A      mov al, [d + s_hex_digits_printx32]
1055   0A93 E5            pop b
1056   0A94 E7            pop d
1057   0A95 09            ret
1058   0A96 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1058   0A9A 34 35 36 37 
1058   0A9E 38 39 41 42 
1058   0AA2 43 44 45 46 
1059   0AA6             ; --- END INLINE ASM SEGMENT
1060   0AA6 F9            leave
1061   0AA7 09            ret
1062   0AA8             
1063   0AA8             err:
1064   0AA8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1065   0AAB             ; print(e); 
1066   0AAB             ; --- START FUNCTION CALL
1067   0AAB FA 05 00      lea d, [bp + 5] ; $e
1068   0AAE 2A            mov b, [d]
1069   0AAF 38 00 00      mov c, 0
1070   0AB2 FD AB         swp b
1071   0AB4 D8            push b
1072   0AB5 07 BD 0A      call print
1073   0AB8 51 02 00      add sp, 2
1074   0ABB             ; --- END FUNCTION CALL
1075   0ABB F9            leave
1076   0ABC 09            ret
1077   0ABD             
1078   0ABD             print:
1079   0ABD F8 00 00      enter 0 ; (push bp; mov bp, sp)
1080   0AC0             ; --- BEGIN INLINE ASM SEGMENT
1081   0AC0 FA 05 00      lea d, [bp + 5] ; $s
1082   0AC3 FD 2A         mov d, [d]
1083   0AC5             _puts_L1_print:
1084   0AC5 1E            mov al, [d]
1085   0AC6 B9 00         cmp al, 0
1086   0AC8 C6 D4 0A      jz _puts_END_print
1087   0ACB 23            mov ah, al
1088   0ACC 19 00         mov al, 0
1089   0ACE 05 03         syscall sys_io
1090   0AD0 79            inc d
1091   0AD1 0A C5 0A      jmp _puts_L1_print
1092   0AD4             _puts_END_print:
1093   0AD4             ; --- END INLINE ASM SEGMENT
1094   0AD4 F9            leave
1095   0AD5 09            ret
1096   0AD6             
1097   0AD6             print_signed:
1098   0AD6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1099   0AD9             ; char digits[5]; 
1100   0AD9 52 05 00      sub sp, 5
1101   0ADC             ; int i = 0; 
1102   0ADC 52 02 00      sub sp, 2
1103   0ADF             ; --- START LOCAL VAR INITIALIZATION
1104   0ADF FA FA FF      lea d, [bp + -6] ; $i
1105   0AE2 DA            push d
1106   0AE3 FD 2E 00 00   mov32 cb, $00000000
1106   0AE7 00 00 
1107   0AE9 E7            pop d
1108   0AEA FD 43         mov [d], b
1109   0AEC             ; --- END LOCAL VAR INITIALIZATION
1110   0AEC             ; if (num < 0) { 
1111   0AEC             _if28_cond:
1112   0AEC FA 05 00      lea d, [bp + 5] ; $num
1113   0AEF 2A            mov b, [d]
1114   0AF0 38 00 00      mov c, 0
1115   0AF3             ; --- START RELATIONAL
1116   0AF3 D7            push a
1117   0AF4 11            mov a, b
1118   0AF5 FD 2E 00 00   mov32 cb, $00000000
1118   0AF9 00 00 
1119   0AFB B0            cmp a, b
1120   0AFC FD 73         slt ; < (signed)
1121   0AFE E4            pop a
1122   0AFF             ; --- END RELATIONAL
1123   0AFF C0 00 00      cmp b, 0
1124   0B02 C6 25 0B      je _if28_else
1125   0B05             _if28_TRUE:
1126   0B05             ; putchar('-'); 
1127   0B05             ; --- START FUNCTION CALL
1128   0B05 FD 2E 2D 00   mov32 cb, $0000002d
1128   0B09 00 00 
1129   0B0B DD            push bl
1130   0B0C 07 06 09      call putchar
1131   0B0F 51 01 00      add sp, 1
1132   0B12             ; --- END FUNCTION CALL
1133   0B12             ; num = -num; 
1134   0B12 FA 05 00      lea d, [bp + 5] ; $num
1135   0B15 DA            push d
1136   0B16 FA 05 00      lea d, [bp + 5] ; $num
1137   0B19 2A            mov b, [d]
1138   0B1A 38 00 00      mov c, 0
1139   0B1D FD 97         neg b
1140   0B1F E7            pop d
1141   0B20 FD 43         mov [d], b
1142   0B22 0A 50 0B      jmp _if28_exit
1143   0B25             _if28_else:
1144   0B25             ; if (num == 0) { 
1145   0B25             _if29_cond:
1146   0B25 FA 05 00      lea d, [bp + 5] ; $num
1147   0B28 2A            mov b, [d]
1148   0B29 38 00 00      mov c, 0
1149   0B2C             ; --- START RELATIONAL
1150   0B2C D7            push a
1151   0B2D 11            mov a, b
1152   0B2E FD 2E 00 00   mov32 cb, $00000000
1152   0B32 00 00 
1153   0B34 B0            cmp a, b
1154   0B35 FD 71         seq ; ==
1155   0B37 E4            pop a
1156   0B38             ; --- END RELATIONAL
1157   0B38 C0 00 00      cmp b, 0
1158   0B3B C6 50 0B      je _if29_exit
1159   0B3E             _if29_TRUE:
1160   0B3E             ; putchar('0'); 
1161   0B3E             ; --- START FUNCTION CALL
1162   0B3E FD 2E 30 00   mov32 cb, $00000030
1162   0B42 00 00 
1163   0B44 DD            push bl
1164   0B45 07 06 09      call putchar
1165   0B48 51 01 00      add sp, 1
1166   0B4B             ; --- END FUNCTION CALL
1167   0B4B             ; return; 
1168   0B4B F9            leave
1169   0B4C 09            ret
1170   0B4D 0A 50 0B      jmp _if29_exit
1171   0B50             _if29_exit:
1172   0B50             _if28_exit:
1173   0B50             ; while (num > 0) { 
1174   0B50             _while30_cond:
1175   0B50 FA 05 00      lea d, [bp + 5] ; $num
1176   0B53 2A            mov b, [d]
1177   0B54 38 00 00      mov c, 0
1178   0B57             ; --- START RELATIONAL
1179   0B57 D7            push a
1180   0B58 11            mov a, b
1181   0B59 FD 2E 00 00   mov32 cb, $00000000
1181   0B5D 00 00 
1182   0B5F B0            cmp a, b
1183   0B60 FD 7F         sgt ; >
1184   0B62 E4            pop a
1185   0B63             ; --- END RELATIONAL
1186   0B63 C0 00 00      cmp b, 0
1187   0B66 C6 DD 0B      je _while30_exit
1188   0B69             _while30_block:
1189   0B69             ; digits[i] = '0' + (num % 10); 
1190   0B69 FA FC FF      lea d, [bp + -4] ; $digits
1191   0B6C D7            push a
1192   0B6D DA            push d
1193   0B6E FA FA FF      lea d, [bp + -6] ; $i
1194   0B71 2A            mov b, [d]
1195   0B72 38 00 00      mov c, 0
1196   0B75 E7            pop d
1197   0B76 5A            add d, b
1198   0B77 E4            pop a
1199   0B78 DA            push d
1200   0B79 FD 2E 30 00   mov32 cb, $00000030
1200   0B7D 00 00 
1201   0B7F             ; --- START TERMS
1202   0B7F D7            push a
1203   0B80 11            mov a, b
1204   0B81 FA 05 00      lea d, [bp + 5] ; $num
1205   0B84 2A            mov b, [d]
1206   0B85 38 00 00      mov c, 0
1207   0B88             ; --- START FACTORS
1208   0B88 D7            push a
1209   0B89 FD D8         push g
1210   0B8B 11            mov a, b
1211   0B8C FD 7A         mov g, c
1212   0B8E FD 2E 0A 00   mov32 cb, $0000000a
1212   0B92 00 00 
1213   0B94 FD D8         push g ; save 'g' as the div instruction uses it
1214   0B96 AE            div a, b ; %, a: quotient, b: remainder
1215   0B97 11            mov a, b
1216   0B98 FD F1         pop g
1217   0B9A FD 38         mov c, g
1218   0B9C 27            mov b, a
1219   0B9D FD F1         pop g
1220   0B9F E4            pop a
1221   0BA0             ; --- END FACTORS
1222   0BA0 56            add b, a
1223   0BA1 E4            pop a
1224   0BA2             ; --- END TERMS
1225   0BA2 E7            pop d
1226   0BA3 FD 3E         mov [d], bl
1227   0BA5             ; num = num / 10; 
1228   0BA5 FA 05 00      lea d, [bp + 5] ; $num
1229   0BA8 DA            push d
1230   0BA9 FA 05 00      lea d, [bp + 5] ; $num
1231   0BAC 2A            mov b, [d]
1232   0BAD 38 00 00      mov c, 0
1233   0BB0             ; --- START FACTORS
1234   0BB0 D7            push a
1235   0BB1 FD D8         push g
1236   0BB3 11            mov a, b
1237   0BB4 FD 7A         mov g, c
1238   0BB6 FD 2E 0A 00   mov32 cb, $0000000a
1238   0BBA 00 00 
1239   0BBC FD D8         push g ; save 'g' as the div instruction uses it
1240   0BBE AE            div a, b ; /, a: quotient, b: remainder
1241   0BBF FD F1         pop g
1242   0BC1 FD 38         mov c, g
1243   0BC3 27            mov b, a
1244   0BC4 FD F1         pop g
1245   0BC6 E4            pop a
1246   0BC7             ; --- END FACTORS
1247   0BC7 E7            pop d
1248   0BC8 FD 43         mov [d], b
1249   0BCA             ; i++; 
1250   0BCA FA FA FF      lea d, [bp + -6] ; $i
1251   0BCD 2A            mov b, [d]
1252   0BCE 38 00 00      mov c, 0
1253   0BD1 11            mov a, b
1254   0BD2 FD 77         inc b
1255   0BD4 FA FA FF      lea d, [bp + -6] ; $i
1256   0BD7 FD 43         mov [d], b
1257   0BD9 27            mov b, a
1258   0BDA 0A 50 0B      jmp _while30_cond
1259   0BDD             _while30_exit:
1260   0BDD             ; while (i > 0) { 
1261   0BDD             _while37_cond:
1262   0BDD FA FA FF      lea d, [bp + -6] ; $i
1263   0BE0 2A            mov b, [d]
1264   0BE1 38 00 00      mov c, 0
1265   0BE4             ; --- START RELATIONAL
1266   0BE4 D7            push a
1267   0BE5 11            mov a, b
1268   0BE6 FD 2E 00 00   mov32 cb, $00000000
1268   0BEA 00 00 
1269   0BEC B0            cmp a, b
1270   0BED FD 7F         sgt ; >
1271   0BEF E4            pop a
1272   0BF0             ; --- END RELATIONAL
1273   0BF0 C0 00 00      cmp b, 0
1274   0BF3 C6 25 0C      je _while37_exit
1275   0BF6             _while37_block:
1276   0BF6             ; i--; 
1277   0BF6 FA FA FF      lea d, [bp + -6] ; $i
1278   0BF9 2A            mov b, [d]
1279   0BFA 38 00 00      mov c, 0
1280   0BFD 11            mov a, b
1281   0BFE FD 7D         dec b
1282   0C00 FA FA FF      lea d, [bp + -6] ; $i
1283   0C03 FD 43         mov [d], b
1284   0C05 27            mov b, a
1285   0C06             ; putchar(digits[i]); 
1286   0C06             ; --- START FUNCTION CALL
1287   0C06 FA FC FF      lea d, [bp + -4] ; $digits
1288   0C09 D7            push a
1289   0C0A DA            push d
1290   0C0B FA FA FF      lea d, [bp + -6] ; $i
1291   0C0E 2A            mov b, [d]
1292   0C0F 38 00 00      mov c, 0
1293   0C12 E7            pop d
1294   0C13 5A            add d, b
1295   0C14 E4            pop a
1296   0C15 32            mov bl, [d]
1297   0C16 A7 00         mov bh, 0
1298   0C18 38 00 00      mov c, 0
1299   0C1B DD            push bl
1300   0C1C 07 06 09      call putchar
1301   0C1F 51 01 00      add sp, 1
1302   0C22             ; --- END FUNCTION CALL
1303   0C22 0A DD 0B      jmp _while37_cond
1304   0C25             _while37_exit:
1305   0C25 F9            leave
1306   0C26 09            ret
1307   0C27             
1308   0C27             print_unsigned:
1309   0C27 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1310   0C2A             ; char digits[5]; 
1311   0C2A 52 05 00      sub sp, 5
1312   0C2D             ; int i; 
1313   0C2D 52 02 00      sub sp, 2
1314   0C30             ; i = 0; 
1315   0C30 FA FA FF      lea d, [bp + -6] ; $i
1316   0C33 DA            push d
1317   0C34 FD 2E 00 00   mov32 cb, $00000000
1317   0C38 00 00 
1318   0C3A E7            pop d
1319   0C3B FD 43         mov [d], b
1320   0C3D             ; if(num == 0){ 
1321   0C3D             _if38_cond:
1322   0C3D FA 05 00      lea d, [bp + 5] ; $num
1323   0C40 2A            mov b, [d]
1324   0C41 38 00 00      mov c, 0
1325   0C44             ; --- START RELATIONAL
1326   0C44 D7            push a
1327   0C45 11            mov a, b
1328   0C46 FD 2E 00 00   mov32 cb, $00000000
1328   0C4A 00 00 
1329   0C4C B0            cmp a, b
1330   0C4D FD 71         seq ; ==
1331   0C4F E4            pop a
1332   0C50             ; --- END RELATIONAL
1333   0C50 C0 00 00      cmp b, 0
1334   0C53 C6 68 0C      je _if38_exit
1335   0C56             _if38_TRUE:
1336   0C56             ; putchar('0'); 
1337   0C56             ; --- START FUNCTION CALL
1338   0C56 FD 2E 30 00   mov32 cb, $00000030
1338   0C5A 00 00 
1339   0C5C DD            push bl
1340   0C5D 07 06 09      call putchar
1341   0C60 51 01 00      add sp, 1
1342   0C63             ; --- END FUNCTION CALL
1343   0C63             ; return; 
1344   0C63 F9            leave
1345   0C64 09            ret
1346   0C65 0A 68 0C      jmp _if38_exit
1347   0C68             _if38_exit:
1348   0C68             ; while (num > 0) { 
1349   0C68             _while39_cond:
1350   0C68 FA 05 00      lea d, [bp + 5] ; $num
1351   0C6B 2A            mov b, [d]
1352   0C6C 38 00 00      mov c, 0
1353   0C6F             ; --- START RELATIONAL
1354   0C6F D7            push a
1355   0C70 11            mov a, b
1356   0C71 FD 2E 00 00   mov32 cb, $00000000
1356   0C75 00 00 
1357   0C77 B0            cmp a, b
1358   0C78 FD 81         sgu ; > (unsigned)
1359   0C7A E4            pop a
1360   0C7B             ; --- END RELATIONAL
1361   0C7B C0 00 00      cmp b, 0
1362   0C7E C6 F5 0C      je _while39_exit
1363   0C81             _while39_block:
1364   0C81             ; digits[i] = '0' + (num % 10); 
1365   0C81 FA FC FF      lea d, [bp + -4] ; $digits
1366   0C84 D7            push a
1367   0C85 DA            push d
1368   0C86 FA FA FF      lea d, [bp + -6] ; $i
1369   0C89 2A            mov b, [d]
1370   0C8A 38 00 00      mov c, 0
1371   0C8D E7            pop d
1372   0C8E 5A            add d, b
1373   0C8F E4            pop a
1374   0C90 DA            push d
1375   0C91 FD 2E 30 00   mov32 cb, $00000030
1375   0C95 00 00 
1376   0C97             ; --- START TERMS
1377   0C97 D7            push a
1378   0C98 11            mov a, b
1379   0C99 FA 05 00      lea d, [bp + 5] ; $num
1380   0C9C 2A            mov b, [d]
1381   0C9D 38 00 00      mov c, 0
1382   0CA0             ; --- START FACTORS
1383   0CA0 D7            push a
1384   0CA1 FD D8         push g
1385   0CA3 11            mov a, b
1386   0CA4 FD 7A         mov g, c
1387   0CA6 FD 2E 0A 00   mov32 cb, $0000000a
1387   0CAA 00 00 
1388   0CAC FD D8         push g ; save 'g' as the div instruction uses it
1389   0CAE AE            div a, b ; %, a: quotient, b: remainder
1390   0CAF 11            mov a, b
1391   0CB0 FD F1         pop g
1392   0CB2 FD 38         mov c, g
1393   0CB4 27            mov b, a
1394   0CB5 FD F1         pop g
1395   0CB7 E4            pop a
1396   0CB8             ; --- END FACTORS
1397   0CB8 56            add b, a
1398   0CB9 E4            pop a
1399   0CBA             ; --- END TERMS
1400   0CBA E7            pop d
1401   0CBB FD 3E         mov [d], bl
1402   0CBD             ; num = num / 10; 
1403   0CBD FA 05 00      lea d, [bp + 5] ; $num
1404   0CC0 DA            push d
1405   0CC1 FA 05 00      lea d, [bp + 5] ; $num
1406   0CC4 2A            mov b, [d]
1407   0CC5 38 00 00      mov c, 0
1408   0CC8             ; --- START FACTORS
1409   0CC8 D7            push a
1410   0CC9 FD D8         push g
1411   0CCB 11            mov a, b
1412   0CCC FD 7A         mov g, c
1413   0CCE FD 2E 0A 00   mov32 cb, $0000000a
1413   0CD2 00 00 
1414   0CD4 FD D8         push g ; save 'g' as the div instruction uses it
1415   0CD6 AE            div a, b ; /, a: quotient, b: remainder
1416   0CD7 FD F1         pop g
1417   0CD9 FD 38         mov c, g
1418   0CDB 27            mov b, a
1419   0CDC FD F1         pop g
1420   0CDE E4            pop a
1421   0CDF             ; --- END FACTORS
1422   0CDF E7            pop d
1423   0CE0 FD 43         mov [d], b
1424   0CE2             ; i++; 
1425   0CE2 FA FA FF      lea d, [bp + -6] ; $i
1426   0CE5 2A            mov b, [d]
1427   0CE6 38 00 00      mov c, 0
1428   0CE9 11            mov a, b
1429   0CEA FD 77         inc b
1430   0CEC FA FA FF      lea d, [bp + -6] ; $i
1431   0CEF FD 43         mov [d], b
1432   0CF1 27            mov b, a
1433   0CF2 0A 68 0C      jmp _while39_cond
1434   0CF5             _while39_exit:
1435   0CF5             ; while (i > 0) { 
1436   0CF5             _while46_cond:
1437   0CF5 FA FA FF      lea d, [bp + -6] ; $i
1438   0CF8 2A            mov b, [d]
1439   0CF9 38 00 00      mov c, 0
1440   0CFC             ; --- START RELATIONAL
1441   0CFC D7            push a
1442   0CFD 11            mov a, b
1443   0CFE FD 2E 00 00   mov32 cb, $00000000
1443   0D02 00 00 
1444   0D04 B0            cmp a, b
1445   0D05 FD 7F         sgt ; >
1446   0D07 E4            pop a
1447   0D08             ; --- END RELATIONAL
1448   0D08 C0 00 00      cmp b, 0
1449   0D0B C6 3D 0D      je _while46_exit
1450   0D0E             _while46_block:
1451   0D0E             ; i--; 
1452   0D0E FA FA FF      lea d, [bp + -6] ; $i
1453   0D11 2A            mov b, [d]
1454   0D12 38 00 00      mov c, 0
1455   0D15 11            mov a, b
1456   0D16 FD 7D         dec b
1457   0D18 FA FA FF      lea d, [bp + -6] ; $i
1458   0D1B FD 43         mov [d], b
1459   0D1D 27            mov b, a
1460   0D1E             ; putchar(digits[i]); 
1461   0D1E             ; --- START FUNCTION CALL
1462   0D1E FA FC FF      lea d, [bp + -4] ; $digits
1463   0D21 D7            push a
1464   0D22 DA            push d
1465   0D23 FA FA FF      lea d, [bp + -6] ; $i
1466   0D26 2A            mov b, [d]
1467   0D27 38 00 00      mov c, 0
1468   0D2A E7            pop d
1469   0D2B 5A            add d, b
1470   0D2C E4            pop a
1471   0D2D 32            mov bl, [d]
1472   0D2E A7 00         mov bh, 0
1473   0D30 38 00 00      mov c, 0
1474   0D33 DD            push bl
1475   0D34 07 06 09      call putchar
1476   0D37 51 01 00      add sp, 1
1477   0D3A             ; --- END FUNCTION CALL
1478   0D3A 0A F5 0C      jmp _while46_cond
1479   0D3D             _while46_exit:
1480   0D3D F9            leave
1481   0D3E 09            ret
1482   0D3F             
1483   0D3F             printx16:
1484   0D3F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1485   0D42             ; --- BEGIN INLINE ASM SEGMENT
1486   0D42 FA 05 00      lea d, [bp + 5] ; $hex
1487   0D45 2A            mov b, [d]
1488   0D46             print_u16x_printx16:
1489   0D46 DD            push bl
1490   0D47 30            mov bl, bh
1491   0D48 07 65 0D      call _itoa_printx16        ; convert bh to char in A
1492   0D4B 2F            mov bl, al        ; save al
1493   0D4C 19 00         mov al, 0
1494   0D4E 05 03         syscall sys_io        ; display AH
1495   0D50 24            mov ah, bl        ; retrieve al
1496   0D51 19 00         mov al, 0
1497   0D53 05 03         syscall sys_io        ; display AL
1498   0D55 EA            pop bl
1499   0D56 07 65 0D      call _itoa_printx16        ; convert bh to char in A
1500   0D59 2F            mov bl, al        ; save al
1501   0D5A 19 00         mov al, 0
1502   0D5C 05 03         syscall sys_io        ; display AH
1503   0D5E 24            mov ah, bl        ; retrieve al
1504   0D5F 19 00         mov al, 0
1505   0D61 05 03         syscall sys_io        ; display AL
1506   0D63             ; --- END INLINE ASM SEGMENT
1507   0D63             ; return; 
1508   0D63 F9            leave
1509   0D64 09            ret
1510   0D65             ; --- BEGIN INLINE ASM SEGMENT
1511   0D65             _itoa_printx16:
1512   0D65 DA            push d
1513   0D66 D8            push b
1514   0D67 A7 00         mov bh, 0
1515   0D69 FD A4 04      shr bl, 4  
1516   0D6C 74            mov d, b
1517   0D6D 1F 7F 0D      mov al, [d + s_hex_digits_printx16]
1518   0D70 23            mov ah, al
1519   0D71 E5            pop b
1520   0D72 D8            push b
1521   0D73 A7 00         mov bh, 0
1522   0D75 FD 87 0F      and bl, $0F
1523   0D78 74            mov d, b
1524   0D79 1F 7F 0D      mov al, [d + s_hex_digits_printx16]
1525   0D7C E5            pop b
1526   0D7D E7            pop d
1527   0D7E 09            ret
1528   0D7F 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1528   0D83 34 35 36 37 
1528   0D87 38 39 41 42 
1528   0D8B 43 44 45 46 
1529   0D8F             ; --- END INLINE ASM SEGMENT
1530   0D8F F9            leave
1531   0D90 09            ret
1532   0D91             
1533   0D91             printx8:
1534   0D91 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1535   0D94             ; --- BEGIN INLINE ASM SEGMENT
1536   0D94 FA 05 00      lea d, [bp + 5] ; $hex
1537   0D97 32            mov bl, [d]
1538   0D98 07 A7 0D      call _itoa_printx8        ; convert bl to char in A
1539   0D9B 2F            mov bl, al        ; save al
1540   0D9C 19 00         mov al, 0
1541   0D9E 05 03         syscall sys_io        ; display AH
1542   0DA0 24            mov ah, bl        ; retrieve al
1543   0DA1 19 00         mov al, 0
1544   0DA3 05 03         syscall sys_io        ; display AL
1545   0DA5             ; --- END INLINE ASM SEGMENT
1546   0DA5             ; return; 
1547   0DA5 F9            leave
1548   0DA6 09            ret
1549   0DA7             ; --- BEGIN INLINE ASM SEGMENT
1550   0DA7             _itoa_printx8:
1551   0DA7 DA            push d
1552   0DA8 D8            push b
1553   0DA9 A7 00         mov bh, 0
1554   0DAB FD A4 04      shr bl, 4  
1555   0DAE 74            mov d, b
1556   0DAF 1F C1 0D      mov al, [d + s_hex_digits_printx8]
1557   0DB2 23            mov ah, al
1558   0DB3 E5            pop b
1559   0DB4 D8            push b
1560   0DB5 A7 00         mov bh, 0
1561   0DB7 FD 87 0F      and bl, $0F
1562   0DBA 74            mov d, b
1563   0DBB 1F C1 0D      mov al, [d + s_hex_digits_printx8]
1564   0DBE E5            pop b
1565   0DBF E7            pop d
1566   0DC0 09            ret
1567   0DC1 30 31 32 33 s_hex_digits_printx8:    .db "0123456789ABCDEF"  
1567   0DC5 34 35 36 37 
1567   0DC9 38 39 41 42 
1567   0DCD 43 44 45 46 
1568   0DD1             ; --- END INLINE ASM SEGMENT
1569   0DD1 F9            leave
1570   0DD2 09            ret
1571   0DD3             ; --- END TEXT SEGMENT
1572   0DD3             
1573   0DD3             ; --- BEGIN DATA SEGMENT
1574   0DD3 00 00 00 00 _text_data: .fill 512, 0
1574   0DD7 00 00 00 00 
1574   0DDB 00 00 00 00 
1574   0DDF 00 00 00 00 
1574   0DE3 00 00 00 00 
1574   0DE7 00 00 00 00 
1574   0DEB 00 00 00 00 
1574   0DEF 00 00 00 00 
1574   0DF3 00 00 00 00 
1574   0DF7 00 00 00 00 
1574   0DFB 00 00 00 00 
1574   0DFF 00 00 00 00 
1574   0E03 00 00 00 00 
1574   0E07 00 00 00 00 
1574   0E0B 00 00 00 00 
1574   0E0F 00 00 00 00 
1574   0E13 00 00 00 00 
1574   0E17 00 00 00 00 
1574   0E1B 00 00 00 00 
1574   0E1F 00 00 00 00 
1574   0E23 00 00 00 00 
1574   0E27 00 00 00 00 
1574   0E2B 00 00 00 00 
1574   0E2F 00 00 00 00 
1574   0E33 00 00 00 00 
1574   0E37 00 00 00 00 
1574   0E3B 00 00 00 00 
1574   0E3F 00 00 00 00 
1574   0E43 00 00 00 00 
1574   0E47 00 00 00 00 
1574   0E4B 00 00 00 00 
1574   0E4F 00 00 00 00 
1574   0E53 00 00 00 00 
1574   0E57 00 00 00 00 
1574   0E5B 00 00 00 00 
1574   0E5F 00 00 00 00 
1574   0E63 00 00 00 00 
1574   0E67 00 00 00 00 
1574   0E6B 00 00 00 00 
1574   0E6F 00 00 00 00 
1574   0E73 00 00 00 00 
1574   0E77 00 00 00 00 
1574   0E7B 00 00 00 00 
1574   0E7F 00 00 00 00 
1574   0E83 00 00 00 00 
1574   0E87 00 00 00 00 
1574   0E8B 00 00 00 00 
1574   0E8F 00 00 00 00 
1574   0E93 00 00 00 00 
1574   0E97 00 00 00 00 
1574   0E9B 00 00 00 00 
1574   0E9F 00 00 00 00 
1574   0EA3 00 00 00 00 
1574   0EA7 00 00 00 00 
1574   0EAB 00 00 00 00 
1574   0EAF 00 00 00 00 
1574   0EB3 00 00 00 00 
1574   0EB7 00 00 00 00 
1574   0EBB 00 00 00 00 
1574   0EBF 00 00 00 00 
1574   0EC3 00 00 00 00 
1574   0EC7 00 00 00 00 
1574   0ECB 00 00 00 00 
1574   0ECF 00 00 00 00 
1574   0ED3 00 00 00 00 
1574   0ED7 00 00 00 00 
1574   0EDB 00 00 00 00 
1574   0EDF 00 00 00 00 
1574   0EE3 00 00 00 00 
1574   0EE7 00 00 00 00 
1574   0EEB 00 00 00 00 
1574   0EEF 00 00 00 00 
1574   0EF3 00 00 00 00 
1574   0EF7 00 00 00 00 
1574   0EFB 00 00 00 00 
1574   0EFF 00 00 00 00 
1574   0F03 00 00 00 00 
1574   0F07 00 00 00 00 
1574   0F0B 00 00 00 00 
1574   0F0F 00 00 00 00 
1574   0F13 00 00 00 00 
1574   0F17 00 00 00 00 
1574   0F1B 00 00 00 00 
1574   0F1F 00 00 00 00 
1574   0F23 00 00 00 00 
1574   0F27 00 00 00 00 
1574   0F2B 00 00 00 00 
1574   0F2F 00 00 00 00 
1574   0F33 00 00 00 00 
1574   0F37 00 00 00 00 
1574   0F3B 00 00 00 00 
1574   0F3F 00 00 00 00 
1574   0F43 00 00 00 00 
1574   0F47 00 00 00 00 
1574   0F4B 00 00 00 00 
1574   0F4F 00 00 00 00 
1574   0F53 00 00 00 00 
1574   0F57 00 00 00 00 
1574   0F5B 00 00 00 00 
1574   0F5F 00 00 00 00 
1574   0F63 00 00 00 00 
1574   0F67 00 00 00 00 
1574   0F6B 00 00 00 00 
1574   0F6F 00 00 00 00 
1574   0F73 00 00 00 00 
1574   0F77 00 00 00 00 
1574   0F7B 00 00 00 00 
1574   0F7F 00 00 00 00 
1574   0F83 00 00 00 00 
1574   0F87 00 00 00 00 
1574   0F8B 00 00 00 00 
1574   0F8F 00 00 00 00 
1574   0F93 00 00 00 00 
1574   0F97 00 00 00 00 
1574   0F9B 00 00 00 00 
1574   0F9F 00 00 00 00 
1574   0FA3 00 00 00 00 
1574   0FA7 00 00 00 00 
1574   0FAB 00 00 00 00 
1574   0FAF 00 00 00 00 
1574   0FB3 00 00 00 00 
1574   0FB7 00 00 00 00 
1574   0FBB 00 00 00 00 
1574   0FBF 00 00 00 00 
1574   0FC3 00 00 00 00 
1574   0FC7 00 00 00 00 
1574   0FCB 00 00 00 00 
1574   0FCF 00 00 00 00 
1575   0FD3 48 61 73 68 _s0: .db "Hash: ", 0
1575   0FD7 3A 20 00 
1576   0FDA 0A 00       _s1: .db "\n", 0
1577   0FDC 55 6E 65 78 _s2: .db "Unexpected format in printf.", 0
1577   0FE0 70 65 63 74 
1577   0FE4 65 64 20 66 
1577   0FE8 6F 72 6D 61 
1577   0FEC 74 20 69 6E 
1577   0FF0 20 70 72 69 
1577   0FF4 6E 74 66 2E 
1577   0FF8 00 
1578   0FF9 45 72 72 6F _s3: .db "Error: Unknown argument type.\n", 0
1578   0FFD 72 3A 20 55 
1578   1001 6E 6B 6E 6F 
1578   1005 77 6E 20 61 
1578   1009 72 67 75 6D 
1578   100D 65 6E 74 20 
1578   1011 74 79 70 65 
1578   1015 2E 0A 00 
1579   1018             
1580   1018 1A 10       _heap_top: .dw _heap
1581   101A 00          _heap: .db 0
1582   101B             ; --- END DATA SEGMENT
1583   101B             
1584   101B             .end
tasm: Number of errors = 0
