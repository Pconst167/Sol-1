0001   0000             ; --- FILENAME: programs/float.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; struct t_float16 a, b; 
0011   0408 52 03 00      sub sp, 3
0012   040B 52 03 00      sub sp, 3
0013   040E             ; struct t_float16 sum; 
0014   040E 52 03 00      sub sp, 3
0015   0411             ; printf("a mantissa: "); 
0016   0411             ; --- START FUNCTION CALL
0017   0411 26 FB 12      mov b, _s0 ; "a mantissa: "
0018   0414 FD AB         swp b
0019   0416 D8            push b
0020   0417 07 F1 08      call printf
0021   041A 51 02 00      add sp, 2
0022   041D             ; --- END FUNCTION CALL
0023   041D             ; a.mantissa = scann(); 
0024   041D FA FE FF      lea d, [bp + -2] ; $a
0025   0420 58 00 00      add d, 0
0026   0423 DA            push d
0027   0424             ; --- START FUNCTION CALL
0028   0424 07 FE 11      call scann
0029   0427 E7            pop d
0030   0428 FD 43         mov [d], b
0031   042A             ; printf("a exponent: "); 
0032   042A             ; --- START FUNCTION CALL
0033   042A 26 08 13      mov b, _s1 ; "a exponent: "
0034   042D FD AB         swp b
0035   042F D8            push b
0036   0430 07 F1 08      call printf
0037   0433 51 02 00      add sp, 2
0038   0436             ; --- END FUNCTION CALL
0039   0436             ; a.exponent = scann(); 
0040   0436 FA FE FF      lea d, [bp + -2] ; $a
0041   0439 58 02 00      add d, 2
0042   043C DA            push d
0043   043D             ; --- START FUNCTION CALL
0044   043D 07 FE 11      call scann
0045   0440 E7            pop d
0046   0441 FD 3E         mov [d], bl
0047   0443             ; printf("b mantissa: "); 
0048   0443             ; --- START FUNCTION CALL
0049   0443 26 15 13      mov b, _s2 ; "b mantissa: "
0050   0446 FD AB         swp b
0051   0448 D8            push b
0052   0449 07 F1 08      call printf
0053   044C 51 02 00      add sp, 2
0054   044F             ; --- END FUNCTION CALL
0055   044F             ; b.mantissa = scann(); 
0056   044F FA FB FF      lea d, [bp + -5] ; $b
0057   0452 58 00 00      add d, 0
0058   0455 DA            push d
0059   0456             ; --- START FUNCTION CALL
0060   0456 07 FE 11      call scann
0061   0459 E7            pop d
0062   045A FD 43         mov [d], b
0063   045C             ; printf("b exponent: "); 
0064   045C             ; --- START FUNCTION CALL
0065   045C 26 22 13      mov b, _s3 ; "b exponent: "
0066   045F FD AB         swp b
0067   0461 D8            push b
0068   0462 07 F1 08      call printf
0069   0465 51 02 00      add sp, 2
0070   0468             ; --- END FUNCTION CALL
0071   0468             ; b.exponent = scann(); 
0072   0468 FA FB FF      lea d, [bp + -5] ; $b
0073   046B 58 02 00      add d, 2
0074   046E DA            push d
0075   046F             ; --- START FUNCTION CALL
0076   046F 07 FE 11      call scann
0077   0472 E7            pop d
0078   0473 FD 3E         mov [d], bl
0079   0475             ; sum = add(a, b); 
0080   0475 FA F8 FF      lea d, [bp + -8] ; $sum
0081   0478 DA            push d
0082   0479             ; --- START FUNCTION CALL
0083   0479 FA FB FF      lea d, [bp + -5] ; $b
0084   047C 2D            mov b, d
0085   047D 38 00 00      mov c, 0
0086   0480 52 03 00      sub sp, 3
0087   0483 FD 28         mov si, b
0088   0485 FD FA 01 00   lea d, [sp + 1]
0089   0489 FD 50         mov di, d
0090   048B 38 03 00      mov c, 3
0091   048E FD F5         rep movsb
0092   0490 FA FE FF      lea d, [bp + -2] ; $a
0093   0493 2D            mov b, d
0094   0494 38 00 00      mov c, 0
0095   0497 52 03 00      sub sp, 3
0096   049A FD 28         mov si, b
0097   049C FD FA 01 00   lea d, [sp + 1]
0098   04A0 FD 50         mov di, d
0099   04A2 38 03 00      mov c, 3
0100   04A5 FD F5         rep movsb
0101   04A7 07 F4 04      call add
0102   04AA 51 06 00      add sp, 6
0103   04AD             ; --- END FUNCTION CALL
0104   04AD E7            pop d
0105   04AE FD 28         mov si, b
0106   04B0 FD 50         mov di, d
0107   04B2 38 03 00      mov c, 3
0108   04B5 FD F5         rep movsb
0109   04B7             ; printf("Sum mantissa: %d\n", sum.mantissa); 
0110   04B7             ; --- START FUNCTION CALL
0111   04B7 FA F8 FF      lea d, [bp + -8] ; $sum
0112   04BA 58 00 00      add d, 0
0113   04BD 2A            mov b, [d]
0114   04BE 38 00 00      mov c, 0
0115   04C1 FD AB         swp b
0116   04C3 D8            push b
0117   04C4 26 2F 13      mov b, _s4 ; "Sum mantissa: %d\n"
0118   04C7 FD AB         swp b
0119   04C9 D8            push b
0120   04CA 07 F1 08      call printf
0121   04CD 51 04 00      add sp, 4
0122   04D0             ; --- END FUNCTION CALL
0123   04D0             ; printf("Sum exponent: %d\n", sum.exponent); 
0124   04D0             ; --- START FUNCTION CALL
0125   04D0 FA F8 FF      lea d, [bp + -8] ; $sum
0126   04D3 58 02 00      add d, 2
0127   04D6 32            mov bl, [d]
0128   04D7 A7 00         mov bh, 0
0129   04D9 38 00 00      mov c, 0
0130   04DC FD AB         swp b
0131   04DE D8            push b
0132   04DF 26 41 13      mov b, _s5 ; "Sum exponent: %d\n"
0133   04E2 FD AB         swp b
0134   04E4 D8            push b
0135   04E5 07 F1 08      call printf
0136   04E8 51 03 00      add sp, 3
0137   04EB             ; --- END FUNCTION CALL
0138   04EB             ; return 0; 
0139   04EB FD 2E 00 00   mov32 cb, $00000000
0139   04EF 00 00 
0140   04F1 F9            leave
0141   04F2 05 0B         syscall sys_terminate_proc
0142   04F4             
0143   04F4             add:
0144   04F4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0145   04F7             ; struct t_float16 result; 
0146   04F7 52 03 00      sub sp, 3
0147   04FA             ; if (a.exponent < b.exponent) { 
0148   04FA             _if1_cond:
0149   04FA FA 05 00      lea d, [bp + 5] ; $a
0150   04FD 58 02 00      add d, 2
0151   0500 32            mov bl, [d]
0152   0501 A7 00         mov bh, 0
0153   0503 38 00 00      mov c, 0
0154   0506             ; --- START RELATIONAL
0155   0506 D7            push a
0156   0507 11            mov a, b
0157   0508 FA 08 00      lea d, [bp + 8] ; $b
0158   050B 58 02 00      add d, 2
0159   050E 32            mov bl, [d]
0160   050F A7 00         mov bh, 0
0161   0511 38 00 00      mov c, 0
0162   0514 B0            cmp a, b
0163   0515 FD 73         slt ; < (signed)
0164   0517 E4            pop a
0165   0518             ; --- END RELATIONAL
0166   0518 C0 00 00      cmp b, 0
0167   051B C6 93 05      je _if1_else
0168   051E             _if1_TRUE:
0169   051E             ; while (a.exponent < b.exponent) { 
0170   051E             _while2_cond:
0171   051E FA 05 00      lea d, [bp + 5] ; $a
0172   0521 58 02 00      add d, 2
0173   0524 32            mov bl, [d]
0174   0525 A7 00         mov bh, 0
0175   0527 38 00 00      mov c, 0
0176   052A             ; --- START RELATIONAL
0177   052A D7            push a
0178   052B 11            mov a, b
0179   052C FA 08 00      lea d, [bp + 8] ; $b
0180   052F 58 02 00      add d, 2
0181   0532 32            mov bl, [d]
0182   0533 A7 00         mov bh, 0
0183   0535 38 00 00      mov c, 0
0184   0538 B0            cmp a, b
0185   0539 FD 73         slt ; < (signed)
0186   053B E4            pop a
0187   053C             ; --- END RELATIONAL
0188   053C C0 00 00      cmp b, 0
0189   053F C6 90 05      je _while2_exit
0190   0542             _while2_block:
0191   0542             ; a.mantissa = a.mantissa / 2; 
0192   0542 FA 05 00      lea d, [bp + 5] ; $a
0193   0545 58 00 00      add d, 0
0194   0548 DA            push d
0195   0549 FA 05 00      lea d, [bp + 5] ; $a
0196   054C 58 00 00      add d, 0
0197   054F 2A            mov b, [d]
0198   0550 38 00 00      mov c, 0
0199   0553             ; --- START FACTORS
0200   0553 D7            push a
0201   0554 FD D8         push g
0202   0556 11            mov a, b
0203   0557 FD 7A         mov g, c
0204   0559 FD 2E 02 00   mov32 cb, $00000002
0204   055D 00 00 
0205   055F FD D8         push g ; save 'g' as the div instruction uses it
0206   0561 AE            div a, b ; /, a: quotient, b: remainder
0207   0562 FD F1         pop g
0208   0564 FD 38         mov c, g
0209   0566 27            mov b, a
0210   0567 FD F1         pop g
0211   0569 E4            pop a
0212   056A             ; --- END FACTORS
0213   056A E7            pop d
0214   056B FD 43         mov [d], b
0215   056D             ; a.exponent = a.exponent + 1; 
0216   056D FA 05 00      lea d, [bp + 5] ; $a
0217   0570 58 02 00      add d, 2
0218   0573 DA            push d
0219   0574 FA 05 00      lea d, [bp + 5] ; $a
0220   0577 58 02 00      add d, 2
0221   057A 32            mov bl, [d]
0222   057B A7 00         mov bh, 0
0223   057D 38 00 00      mov c, 0
0224   0580             ; --- START TERMS
0225   0580 D7            push a
0226   0581 11            mov a, b
0227   0582 FD 2E 01 00   mov32 cb, $00000001
0227   0586 00 00 
0228   0588 56            add b, a
0229   0589 E4            pop a
0230   058A             ; --- END TERMS
0231   058A E7            pop d
0232   058B FD 3E         mov [d], bl
0233   058D 0A 1E 05      jmp _while2_cond
0234   0590             _while2_exit:
0235   0590 0A 2C 06      jmp _if1_exit
0236   0593             _if1_else:
0237   0593             ; if (b.exponent < a.exponent) { 
0238   0593             _if5_cond:
0239   0593 FA 08 00      lea d, [bp + 8] ; $b
0240   0596 58 02 00      add d, 2
0241   0599 32            mov bl, [d]
0242   059A A7 00         mov bh, 0
0243   059C 38 00 00      mov c, 0
0244   059F             ; --- START RELATIONAL
0245   059F D7            push a
0246   05A0 11            mov a, b
0247   05A1 FA 05 00      lea d, [bp + 5] ; $a
0248   05A4 58 02 00      add d, 2
0249   05A7 32            mov bl, [d]
0250   05A8 A7 00         mov bh, 0
0251   05AA 38 00 00      mov c, 0
0252   05AD B0            cmp a, b
0253   05AE FD 73         slt ; < (signed)
0254   05B0 E4            pop a
0255   05B1             ; --- END RELATIONAL
0256   05B1 C0 00 00      cmp b, 0
0257   05B4 C6 2C 06      je _if5_exit
0258   05B7             _if5_TRUE:
0259   05B7             ; while (b.exponent < a.exponent) { 
0260   05B7             _while6_cond:
0261   05B7 FA 08 00      lea d, [bp + 8] ; $b
0262   05BA 58 02 00      add d, 2
0263   05BD 32            mov bl, [d]
0264   05BE A7 00         mov bh, 0
0265   05C0 38 00 00      mov c, 0
0266   05C3             ; --- START RELATIONAL
0267   05C3 D7            push a
0268   05C4 11            mov a, b
0269   05C5 FA 05 00      lea d, [bp + 5] ; $a
0270   05C8 58 02 00      add d, 2
0271   05CB 32            mov bl, [d]
0272   05CC A7 00         mov bh, 0
0273   05CE 38 00 00      mov c, 0
0274   05D1 B0            cmp a, b
0275   05D2 FD 73         slt ; < (signed)
0276   05D4 E4            pop a
0277   05D5             ; --- END RELATIONAL
0278   05D5 C0 00 00      cmp b, 0
0279   05D8 C6 29 06      je _while6_exit
0280   05DB             _while6_block:
0281   05DB             ; b.mantissa = b.mantissa / 2; 
0282   05DB FA 08 00      lea d, [bp + 8] ; $b
0283   05DE 58 00 00      add d, 0
0284   05E1 DA            push d
0285   05E2 FA 08 00      lea d, [bp + 8] ; $b
0286   05E5 58 00 00      add d, 0
0287   05E8 2A            mov b, [d]
0288   05E9 38 00 00      mov c, 0
0289   05EC             ; --- START FACTORS
0290   05EC D7            push a
0291   05ED FD D8         push g
0292   05EF 11            mov a, b
0293   05F0 FD 7A         mov g, c
0294   05F2 FD 2E 02 00   mov32 cb, $00000002
0294   05F6 00 00 
0295   05F8 FD D8         push g ; save 'g' as the div instruction uses it
0296   05FA AE            div a, b ; /, a: quotient, b: remainder
0297   05FB FD F1         pop g
0298   05FD FD 38         mov c, g
0299   05FF 27            mov b, a
0300   0600 FD F1         pop g
0301   0602 E4            pop a
0302   0603             ; --- END FACTORS
0303   0603 E7            pop d
0304   0604 FD 43         mov [d], b
0305   0606             ; b.exponent = b.exponent + 1; 
0306   0606 FA 08 00      lea d, [bp + 8] ; $b
0307   0609 58 02 00      add d, 2
0308   060C DA            push d
0309   060D FA 08 00      lea d, [bp + 8] ; $b
0310   0610 58 02 00      add d, 2
0311   0613 32            mov bl, [d]
0312   0614 A7 00         mov bh, 0
0313   0616 38 00 00      mov c, 0
0314   0619             ; --- START TERMS
0315   0619 D7            push a
0316   061A 11            mov a, b
0317   061B FD 2E 01 00   mov32 cb, $00000001
0317   061F 00 00 
0318   0621 56            add b, a
0319   0622 E4            pop a
0320   0623             ; --- END TERMS
0321   0623 E7            pop d
0322   0624 FD 3E         mov [d], bl
0323   0626 0A B7 05      jmp _while6_cond
0324   0629             _while6_exit:
0325   0629 0A 2C 06      jmp _if5_exit
0326   062C             _if5_exit:
0327   062C             _if1_exit:
0328   062C             ; result.mantissa = a.mantissa + b.mantissa; 
0329   062C FA FE FF      lea d, [bp + -2] ; $result
0330   062F 58 00 00      add d, 0
0331   0632 DA            push d
0332   0633 FA 05 00      lea d, [bp + 5] ; $a
0333   0636 58 00 00      add d, 0
0334   0639 2A            mov b, [d]
0335   063A 38 00 00      mov c, 0
0336   063D             ; --- START TERMS
0337   063D D7            push a
0338   063E 11            mov a, b
0339   063F FA 08 00      lea d, [bp + 8] ; $b
0340   0642 58 00 00      add d, 0
0341   0645 2A            mov b, [d]
0342   0646 38 00 00      mov c, 0
0343   0649 56            add b, a
0344   064A E4            pop a
0345   064B             ; --- END TERMS
0346   064B E7            pop d
0347   064C FD 43         mov [d], b
0348   064E             ; result.exponent = a.exponent; 
0349   064E FA FE FF      lea d, [bp + -2] ; $result
0350   0651 58 02 00      add d, 2
0351   0654 DA            push d
0352   0655 FA 05 00      lea d, [bp + 5] ; $a
0353   0658 58 02 00      add d, 2
0354   065B 32            mov bl, [d]
0355   065C A7 00         mov bh, 0
0356   065E 38 00 00      mov c, 0
0357   0661 E7            pop d
0358   0662 FD 3E         mov [d], bl
0359   0664             ; while (result.mantissa > 32767 || result.mantissa < -32767) { 
0360   0664             _while9_cond:
0361   0664 FA FE FF      lea d, [bp + -2] ; $result
0362   0667 58 00 00      add d, 0
0363   066A 2A            mov b, [d]
0364   066B 38 00 00      mov c, 0
0365   066E             ; --- START RELATIONAL
0366   066E D7            push a
0367   066F 11            mov a, b
0368   0670 FD 2E FF 7F   mov32 cb, $00007fff
0368   0674 00 00 
0369   0676 B0            cmp a, b
0370   0677 FD 7F         sgt ; >
0371   0679 E4            pop a
0372   067A             ; --- END RELATIONAL
0373   067A             ; --- START LOGICAL OR
0374   067A D7            push a
0375   067B 11            mov a, b
0376   067C FA FE FF      lea d, [bp + -2] ; $result
0377   067F 58 00 00      add d, 0
0378   0682 2A            mov b, [d]
0379   0683 38 00 00      mov c, 0
0380   0686             ; --- START RELATIONAL
0381   0686 D7            push a
0382   0687 11            mov a, b
0383   0688 FD 2E 01 80   mov32 cb, $ffff8001
0383   068C FF FF 
0384   068E B0            cmp a, b
0385   068F FD 73         slt ; < (signed)
0386   0691 E4            pop a
0387   0692             ; --- END RELATIONAL
0388   0692 FD A8         sor a, b ; ||
0389   0694 E4            pop a
0390   0695             ; --- END LOGICAL OR
0391   0695 C0 00 00      cmp b, 0
0392   0698 C6 E9 06      je _while9_exit
0393   069B             _while9_block:
0394   069B             ; result.mantissa = result.mantissa / 2; 
0395   069B FA FE FF      lea d, [bp + -2] ; $result
0396   069E 58 00 00      add d, 0
0397   06A1 DA            push d
0398   06A2 FA FE FF      lea d, [bp + -2] ; $result
0399   06A5 58 00 00      add d, 0
0400   06A8 2A            mov b, [d]
0401   06A9 38 00 00      mov c, 0
0402   06AC             ; --- START FACTORS
0403   06AC D7            push a
0404   06AD FD D8         push g
0405   06AF 11            mov a, b
0406   06B0 FD 7A         mov g, c
0407   06B2 FD 2E 02 00   mov32 cb, $00000002
0407   06B6 00 00 
0408   06B8 FD D8         push g ; save 'g' as the div instruction uses it
0409   06BA AE            div a, b ; /, a: quotient, b: remainder
0410   06BB FD F1         pop g
0411   06BD FD 38         mov c, g
0412   06BF 27            mov b, a
0413   06C0 FD F1         pop g
0414   06C2 E4            pop a
0415   06C3             ; --- END FACTORS
0416   06C3 E7            pop d
0417   06C4 FD 43         mov [d], b
0418   06C6             ; result.exponent = result.exponent + 1; 
0419   06C6 FA FE FF      lea d, [bp + -2] ; $result
0420   06C9 58 02 00      add d, 2
0421   06CC DA            push d
0422   06CD FA FE FF      lea d, [bp + -2] ; $result
0423   06D0 58 02 00      add d, 2
0424   06D3 32            mov bl, [d]
0425   06D4 A7 00         mov bh, 0
0426   06D6 38 00 00      mov c, 0
0427   06D9             ; --- START TERMS
0428   06D9 D7            push a
0429   06DA 11            mov a, b
0430   06DB FD 2E 01 00   mov32 cb, $00000001
0430   06DF 00 00 
0431   06E1 56            add b, a
0432   06E2 E4            pop a
0433   06E3             ; --- END TERMS
0434   06E3 E7            pop d
0435   06E4 FD 3E         mov [d], bl
0436   06E6 0A 64 06      jmp _while9_cond
0437   06E9             _while9_exit:
0438   06E9             ; return result; 
0439   06E9 FA FE FF      lea d, [bp + -2] ; $result
0440   06EC 2D            mov b, d
0441   06ED 38 00 00      mov c, 0
0442   06F0 F9            leave
0443   06F1 09            ret
0444   06F2             
0445   06F2             subtract:
0446   06F2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0447   06F5             ; struct t_float16 result; 
0448   06F5 52 03 00      sub sp, 3
0449   06F8             ; if (a.exponent < b.exponent) { 
0450   06F8             _if12_cond:
0451   06F8 FA 05 00      lea d, [bp + 5] ; $a
0452   06FB 58 02 00      add d, 2
0453   06FE 32            mov bl, [d]
0454   06FF A7 00         mov bh, 0
0455   0701 38 00 00      mov c, 0
0456   0704             ; --- START RELATIONAL
0457   0704 D7            push a
0458   0705 11            mov a, b
0459   0706 FA 08 00      lea d, [bp + 8] ; $b
0460   0709 58 02 00      add d, 2
0461   070C 32            mov bl, [d]
0462   070D A7 00         mov bh, 0
0463   070F 38 00 00      mov c, 0
0464   0712 B0            cmp a, b
0465   0713 FD 73         slt ; < (signed)
0466   0715 E4            pop a
0467   0716             ; --- END RELATIONAL
0468   0716 C0 00 00      cmp b, 0
0469   0719 C6 91 07      je _if12_else
0470   071C             _if12_TRUE:
0471   071C             ; while (a.exponent < b.exponent) { 
0472   071C             _while13_cond:
0473   071C FA 05 00      lea d, [bp + 5] ; $a
0474   071F 58 02 00      add d, 2
0475   0722 32            mov bl, [d]
0476   0723 A7 00         mov bh, 0
0477   0725 38 00 00      mov c, 0
0478   0728             ; --- START RELATIONAL
0479   0728 D7            push a
0480   0729 11            mov a, b
0481   072A FA 08 00      lea d, [bp + 8] ; $b
0482   072D 58 02 00      add d, 2
0483   0730 32            mov bl, [d]
0484   0731 A7 00         mov bh, 0
0485   0733 38 00 00      mov c, 0
0486   0736 B0            cmp a, b
0487   0737 FD 73         slt ; < (signed)
0488   0739 E4            pop a
0489   073A             ; --- END RELATIONAL
0490   073A C0 00 00      cmp b, 0
0491   073D C6 8E 07      je _while13_exit
0492   0740             _while13_block:
0493   0740             ; a.mantissa = a.mantissa / 2; 
0494   0740 FA 05 00      lea d, [bp + 5] ; $a
0495   0743 58 00 00      add d, 0
0496   0746 DA            push d
0497   0747 FA 05 00      lea d, [bp + 5] ; $a
0498   074A 58 00 00      add d, 0
0499   074D 2A            mov b, [d]
0500   074E 38 00 00      mov c, 0
0501   0751             ; --- START FACTORS
0502   0751 D7            push a
0503   0752 FD D8         push g
0504   0754 11            mov a, b
0505   0755 FD 7A         mov g, c
0506   0757 FD 2E 02 00   mov32 cb, $00000002
0506   075B 00 00 
0507   075D FD D8         push g ; save 'g' as the div instruction uses it
0508   075F AE            div a, b ; /, a: quotient, b: remainder
0509   0760 FD F1         pop g
0510   0762 FD 38         mov c, g
0511   0764 27            mov b, a
0512   0765 FD F1         pop g
0513   0767 E4            pop a
0514   0768             ; --- END FACTORS
0515   0768 E7            pop d
0516   0769 FD 43         mov [d], b
0517   076B             ; a.exponent = a.exponent + 1; 
0518   076B FA 05 00      lea d, [bp + 5] ; $a
0519   076E 58 02 00      add d, 2
0520   0771 DA            push d
0521   0772 FA 05 00      lea d, [bp + 5] ; $a
0522   0775 58 02 00      add d, 2
0523   0778 32            mov bl, [d]
0524   0779 A7 00         mov bh, 0
0525   077B 38 00 00      mov c, 0
0526   077E             ; --- START TERMS
0527   077E D7            push a
0528   077F 11            mov a, b
0529   0780 FD 2E 01 00   mov32 cb, $00000001
0529   0784 00 00 
0530   0786 56            add b, a
0531   0787 E4            pop a
0532   0788             ; --- END TERMS
0533   0788 E7            pop d
0534   0789 FD 3E         mov [d], bl
0535   078B 0A 1C 07      jmp _while13_cond
0536   078E             _while13_exit:
0537   078E 0A 2A 08      jmp _if12_exit
0538   0791             _if12_else:
0539   0791             ; if (b.exponent < a.exponent) { 
0540   0791             _if16_cond:
0541   0791 FA 08 00      lea d, [bp + 8] ; $b
0542   0794 58 02 00      add d, 2
0543   0797 32            mov bl, [d]
0544   0798 A7 00         mov bh, 0
0545   079A 38 00 00      mov c, 0
0546   079D             ; --- START RELATIONAL
0547   079D D7            push a
0548   079E 11            mov a, b
0549   079F FA 05 00      lea d, [bp + 5] ; $a
0550   07A2 58 02 00      add d, 2
0551   07A5 32            mov bl, [d]
0552   07A6 A7 00         mov bh, 0
0553   07A8 38 00 00      mov c, 0
0554   07AB B0            cmp a, b
0555   07AC FD 73         slt ; < (signed)
0556   07AE E4            pop a
0557   07AF             ; --- END RELATIONAL
0558   07AF C0 00 00      cmp b, 0
0559   07B2 C6 2A 08      je _if16_exit
0560   07B5             _if16_TRUE:
0561   07B5             ; while (b.exponent < a.exponent) { 
0562   07B5             _while17_cond:
0563   07B5 FA 08 00      lea d, [bp + 8] ; $b
0564   07B8 58 02 00      add d, 2
0565   07BB 32            mov bl, [d]
0566   07BC A7 00         mov bh, 0
0567   07BE 38 00 00      mov c, 0
0568   07C1             ; --- START RELATIONAL
0569   07C1 D7            push a
0570   07C2 11            mov a, b
0571   07C3 FA 05 00      lea d, [bp + 5] ; $a
0572   07C6 58 02 00      add d, 2
0573   07C9 32            mov bl, [d]
0574   07CA A7 00         mov bh, 0
0575   07CC 38 00 00      mov c, 0
0576   07CF B0            cmp a, b
0577   07D0 FD 73         slt ; < (signed)
0578   07D2 E4            pop a
0579   07D3             ; --- END RELATIONAL
0580   07D3 C0 00 00      cmp b, 0
0581   07D6 C6 27 08      je _while17_exit
0582   07D9             _while17_block:
0583   07D9             ; b.mantissa = b.mantissa / 2; 
0584   07D9 FA 08 00      lea d, [bp + 8] ; $b
0585   07DC 58 00 00      add d, 0
0586   07DF DA            push d
0587   07E0 FA 08 00      lea d, [bp + 8] ; $b
0588   07E3 58 00 00      add d, 0
0589   07E6 2A            mov b, [d]
0590   07E7 38 00 00      mov c, 0
0591   07EA             ; --- START FACTORS
0592   07EA D7            push a
0593   07EB FD D8         push g
0594   07ED 11            mov a, b
0595   07EE FD 7A         mov g, c
0596   07F0 FD 2E 02 00   mov32 cb, $00000002
0596   07F4 00 00 
0597   07F6 FD D8         push g ; save 'g' as the div instruction uses it
0598   07F8 AE            div a, b ; /, a: quotient, b: remainder
0599   07F9 FD F1         pop g
0600   07FB FD 38         mov c, g
0601   07FD 27            mov b, a
0602   07FE FD F1         pop g
0603   0800 E4            pop a
0604   0801             ; --- END FACTORS
0605   0801 E7            pop d
0606   0802 FD 43         mov [d], b
0607   0804             ; b.exponent = b.exponent + 1; 
0608   0804 FA 08 00      lea d, [bp + 8] ; $b
0609   0807 58 02 00      add d, 2
0610   080A DA            push d
0611   080B FA 08 00      lea d, [bp + 8] ; $b
0612   080E 58 02 00      add d, 2
0613   0811 32            mov bl, [d]
0614   0812 A7 00         mov bh, 0
0615   0814 38 00 00      mov c, 0
0616   0817             ; --- START TERMS
0617   0817 D7            push a
0618   0818 11            mov a, b
0619   0819 FD 2E 01 00   mov32 cb, $00000001
0619   081D 00 00 
0620   081F 56            add b, a
0621   0820 E4            pop a
0622   0821             ; --- END TERMS
0623   0821 E7            pop d
0624   0822 FD 3E         mov [d], bl
0625   0824 0A B5 07      jmp _while17_cond
0626   0827             _while17_exit:
0627   0827 0A 2A 08      jmp _if16_exit
0628   082A             _if16_exit:
0629   082A             _if12_exit:
0630   082A             ; result.mantissa = a.mantissa - b.mantissa; 
0631   082A FA FE FF      lea d, [bp + -2] ; $result
0632   082D 58 00 00      add d, 0
0633   0830 DA            push d
0634   0831 FA 05 00      lea d, [bp + 5] ; $a
0635   0834 58 00 00      add d, 0
0636   0837 2A            mov b, [d]
0637   0838 38 00 00      mov c, 0
0638   083B             ; --- START TERMS
0639   083B D7            push a
0640   083C 11            mov a, b
0641   083D FA 08 00      lea d, [bp + 8] ; $b
0642   0840 58 00 00      add d, 0
0643   0843 2A            mov b, [d]
0644   0844 38 00 00      mov c, 0
0645   0847 60            sub a, b
0646   0848 27            mov b, a
0647   0849 E4            pop a
0648   084A             ; --- END TERMS
0649   084A E7            pop d
0650   084B FD 43         mov [d], b
0651   084D             ; result.exponent = a.exponent; 
0652   084D FA FE FF      lea d, [bp + -2] ; $result
0653   0850 58 02 00      add d, 2
0654   0853 DA            push d
0655   0854 FA 05 00      lea d, [bp + 5] ; $a
0656   0857 58 02 00      add d, 2
0657   085A 32            mov bl, [d]
0658   085B A7 00         mov bh, 0
0659   085D 38 00 00      mov c, 0
0660   0860 E7            pop d
0661   0861 FD 3E         mov [d], bl
0662   0863             ; while (result.mantissa > 32767 || result.mantissa < -32767) { 
0663   0863             _while20_cond:
0664   0863 FA FE FF      lea d, [bp + -2] ; $result
0665   0866 58 00 00      add d, 0
0666   0869 2A            mov b, [d]
0667   086A 38 00 00      mov c, 0
0668   086D             ; --- START RELATIONAL
0669   086D D7            push a
0670   086E 11            mov a, b
0671   086F FD 2E FF 7F   mov32 cb, $00007fff
0671   0873 00 00 
0672   0875 B0            cmp a, b
0673   0876 FD 7F         sgt ; >
0674   0878 E4            pop a
0675   0879             ; --- END RELATIONAL
0676   0879             ; --- START LOGICAL OR
0677   0879 D7            push a
0678   087A 11            mov a, b
0679   087B FA FE FF      lea d, [bp + -2] ; $result
0680   087E 58 00 00      add d, 0
0681   0881 2A            mov b, [d]
0682   0882 38 00 00      mov c, 0
0683   0885             ; --- START RELATIONAL
0684   0885 D7            push a
0685   0886 11            mov a, b
0686   0887 FD 2E 01 80   mov32 cb, $ffff8001
0686   088B FF FF 
0687   088D B0            cmp a, b
0688   088E FD 73         slt ; < (signed)
0689   0890 E4            pop a
0690   0891             ; --- END RELATIONAL
0691   0891 FD A8         sor a, b ; ||
0692   0893 E4            pop a
0693   0894             ; --- END LOGICAL OR
0694   0894 C0 00 00      cmp b, 0
0695   0897 C6 E8 08      je _while20_exit
0696   089A             _while20_block:
0697   089A             ; result.mantissa = result.mantissa / 2; 
0698   089A FA FE FF      lea d, [bp + -2] ; $result
0699   089D 58 00 00      add d, 0
0700   08A0 DA            push d
0701   08A1 FA FE FF      lea d, [bp + -2] ; $result
0702   08A4 58 00 00      add d, 0
0703   08A7 2A            mov b, [d]
0704   08A8 38 00 00      mov c, 0
0705   08AB             ; --- START FACTORS
0706   08AB D7            push a
0707   08AC FD D8         push g
0708   08AE 11            mov a, b
0709   08AF FD 7A         mov g, c
0710   08B1 FD 2E 02 00   mov32 cb, $00000002
0710   08B5 00 00 
0711   08B7 FD D8         push g ; save 'g' as the div instruction uses it
0712   08B9 AE            div a, b ; /, a: quotient, b: remainder
0713   08BA FD F1         pop g
0714   08BC FD 38         mov c, g
0715   08BE 27            mov b, a
0716   08BF FD F1         pop g
0717   08C1 E4            pop a
0718   08C2             ; --- END FACTORS
0719   08C2 E7            pop d
0720   08C3 FD 43         mov [d], b
0721   08C5             ; result.exponent = result.exponent + 1; 
0722   08C5 FA FE FF      lea d, [bp + -2] ; $result
0723   08C8 58 02 00      add d, 2
0724   08CB DA            push d
0725   08CC FA FE FF      lea d, [bp + -2] ; $result
0726   08CF 58 02 00      add d, 2
0727   08D2 32            mov bl, [d]
0728   08D3 A7 00         mov bh, 0
0729   08D5 38 00 00      mov c, 0
0730   08D8             ; --- START TERMS
0731   08D8 D7            push a
0732   08D9 11            mov a, b
0733   08DA FD 2E 01 00   mov32 cb, $00000001
0733   08DE 00 00 
0734   08E0 56            add b, a
0735   08E1 E4            pop a
0736   08E2             ; --- END TERMS
0737   08E2 E7            pop d
0738   08E3 FD 3E         mov [d], bl
0739   08E5 0A 63 08      jmp _while20_cond
0740   08E8             _while20_exit:
0741   08E8             ; return result; 
0742   08E8 FA FE FF      lea d, [bp + -2] ; $result
0743   08EB 2D            mov b, d
0744   08EC 38 00 00      mov c, 0
0745   08EF F9            leave
0746   08F0 09            ret
0747   08F1             
0748   08F1             printf:
0749   08F1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0750   08F4             ; char *p, *format_p; 
0751   08F4 52 02 00      sub sp, 2
0752   08F7 52 02 00      sub sp, 2
0753   08FA             ; format_p = format; 
0754   08FA FA FD FF      lea d, [bp + -3] ; $format_p
0755   08FD DA            push d
0756   08FE FA 05 00      lea d, [bp + 5] ; $format
0757   0901 2A            mov b, [d]
0758   0902 38 00 00      mov c, 0
0759   0905 E7            pop d
0760   0906 FD 43         mov [d], b
0761   0908             ; p = &format + 2; 
0762   0908 FA FF FF      lea d, [bp + -1] ; $p
0763   090B DA            push d
0764   090C FA 05 00      lea d, [bp + 5] ; $format
0765   090F 2D            mov b, d
0766   0910             ; --- START TERMS
0767   0910 D7            push a
0768   0911 11            mov a, b
0769   0912 FD 2E 02 00   mov32 cb, $00000002
0769   0916 00 00 
0770   0918 56            add b, a
0771   0919 E4            pop a
0772   091A             ; --- END TERMS
0773   091A E7            pop d
0774   091B FD 43         mov [d], b
0775   091D             ; for(;;){ 
0776   091D             _for23_init:
0777   091D             _for23_cond:
0778   091D             _for23_block:
0779   091D             ; if(!*format_p) break; 
0780   091D             _if24_cond:
0781   091D FA FD FF      lea d, [bp + -3] ; $format_p
0782   0920 2A            mov b, [d]
0783   0921 38 00 00      mov c, 0
0784   0924 74            mov d, b
0785   0925 32            mov bl, [d]
0786   0926 A7 00         mov bh, 0
0787   0928 38 00 00      mov c, 0
0788   092B C0 00 00      cmp b, 0
0789   092E FD 71         seq ; !
0790   0930 C0 00 00      cmp b, 0
0791   0933 C6 3C 09      je _if24_else
0792   0936             _if24_TRUE:
0793   0936             ; break; 
0794   0936 0A EC 0B      jmp _for23_exit ; for break
0795   0939 0A E9 0B      jmp _if24_exit
0796   093C             _if24_else:
0797   093C             ; if(*format_p == '%'){ 
0798   093C             _if25_cond:
0799   093C FA FD FF      lea d, [bp + -3] ; $format_p
0800   093F 2A            mov b, [d]
0801   0940 38 00 00      mov c, 0
0802   0943 74            mov d, b
0803   0944 32            mov bl, [d]
0804   0945 A7 00         mov bh, 0
0805   0947 38 00 00      mov c, 0
0806   094A             ; --- START RELATIONAL
0807   094A D7            push a
0808   094B 11            mov a, b
0809   094C FD 2E 25 00   mov32 cb, $00000025
0809   0950 00 00 
0810   0952 B0            cmp a, b
0811   0953 FD 71         seq ; ==
0812   0955 E4            pop a
0813   0956             ; --- END RELATIONAL
0814   0956 C0 00 00      cmp b, 0
0815   0959 C6 C4 0B      je _if25_else
0816   095C             _if25_TRUE:
0817   095C             ; format_p++; 
0818   095C FA FD FF      lea d, [bp + -3] ; $format_p
0819   095F 2A            mov b, [d]
0820   0960 38 00 00      mov c, 0
0821   0963 FD 77         inc b
0822   0965 FA FD FF      lea d, [bp + -3] ; $format_p
0823   0968 FD 43         mov [d], b
0824   096A FD 7D         dec b
0825   096C             ; switch(*format_p){ 
0826   096C             _switch26_expr:
0827   096C FA FD FF      lea d, [bp + -3] ; $format_p
0828   096F 2A            mov b, [d]
0829   0970 38 00 00      mov c, 0
0830   0973 74            mov d, b
0831   0974 32            mov bl, [d]
0832   0975 A7 00         mov bh, 0
0833   0977 38 00 00      mov c, 0
0834   097A             _switch26_comparisons:
0835   097A C1 6C         cmp bl, $6c
0836   097C C6 A8 09      je _switch26_case0
0837   097F C1 4C         cmp bl, $4c
0838   0981 C6 A8 09      je _switch26_case1
0839   0984 C1 64         cmp bl, $64
0840   0986 C6 B8 0A      je _switch26_case2
0841   0989 C1 69         cmp bl, $69
0842   098B C6 B8 0A      je _switch26_case3
0843   098E C1 75         cmp bl, $75
0844   0990 C6 E8 0A      je _switch26_case4
0845   0993 C1 78         cmp bl, $78
0846   0995 C6 18 0B      je _switch26_case5
0847   0998 C1 63         cmp bl, $63
0848   099A C6 48 0B      je _switch26_case6
0849   099D C1 73         cmp bl, $73
0850   099F C6 78 0B      je _switch26_case7
0851   09A2 0A A5 0B      jmp _switch26_default
0852   09A5 0A B1 0B      jmp _switch26_exit
0853   09A8             _switch26_case0:
0854   09A8             _switch26_case1:
0855   09A8             ; format_p++; 
0856   09A8 FA FD FF      lea d, [bp + -3] ; $format_p
0857   09AB 2A            mov b, [d]
0858   09AC 38 00 00      mov c, 0
0859   09AF FD 77         inc b
0860   09B1 FA FD FF      lea d, [bp + -3] ; $format_p
0861   09B4 FD 43         mov [d], b
0862   09B6 FD 7D         dec b
0863   09B8             ; if(*format_p == 'd' || *format_p == 'i') 
0864   09B8             _if27_cond:
0865   09B8 FA FD FF      lea d, [bp + -3] ; $format_p
0866   09BB 2A            mov b, [d]
0867   09BC 38 00 00      mov c, 0
0868   09BF 74            mov d, b
0869   09C0 32            mov bl, [d]
0870   09C1 A7 00         mov bh, 0
0871   09C3 38 00 00      mov c, 0
0872   09C6             ; --- START RELATIONAL
0873   09C6 D7            push a
0874   09C7 11            mov a, b
0875   09C8 FD 2E 64 00   mov32 cb, $00000064
0875   09CC 00 00 
0876   09CE B0            cmp a, b
0877   09CF FD 71         seq ; ==
0878   09D1 E4            pop a
0879   09D2             ; --- END RELATIONAL
0880   09D2             ; --- START LOGICAL OR
0881   09D2 D7            push a
0882   09D3 11            mov a, b
0883   09D4 FA FD FF      lea d, [bp + -3] ; $format_p
0884   09D7 2A            mov b, [d]
0885   09D8 38 00 00      mov c, 0
0886   09DB 74            mov d, b
0887   09DC 32            mov bl, [d]
0888   09DD A7 00         mov bh, 0
0889   09DF 38 00 00      mov c, 0
0890   09E2             ; --- START RELATIONAL
0891   09E2 D7            push a
0892   09E3 11            mov a, b
0893   09E4 FD 2E 69 00   mov32 cb, $00000069
0893   09E8 00 00 
0894   09EA B0            cmp a, b
0895   09EB FD 71         seq ; ==
0896   09ED E4            pop a
0897   09EE             ; --- END RELATIONAL
0898   09EE FD A8         sor a, b ; ||
0899   09F0 E4            pop a
0900   09F1             ; --- END LOGICAL OR
0901   09F1 C0 00 00      cmp b, 0
0902   09F4 C6 15 0A      je _if27_else
0903   09F7             _if27_TRUE:
0904   09F7             ; print_signed_long(*(long *)p); 
0905   09F7             ; --- START FUNCTION CALL
0906   09F7 FA FF FF      lea d, [bp + -1] ; $p
0907   09FA 2A            mov b, [d]
0908   09FB 38 00 00      mov c, 0
0909   09FE 74            mov d, b
0910   09FF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0911   0A02 FD 39         mov c, b ; And place it into C
0912   0A04 2A            mov b, [d] ; Lower Word in B
0913   0A05 12            mov a, c
0914   0A06 FD AA         swp a
0915   0A08 D7            push a
0916   0A09 FD AB         swp b
0917   0A0B D8            push b
0918   0A0C 07 EE 0B      call print_signed_long
0919   0A0F 51 04 00      add sp, 4
0920   0A12             ; --- END FUNCTION CALL
0921   0A12 0A 9D 0A      jmp _if27_exit
0922   0A15             _if27_else:
0923   0A15             ; if(*format_p == 'u') 
0924   0A15             _if28_cond:
0925   0A15 FA FD FF      lea d, [bp + -3] ; $format_p
0926   0A18 2A            mov b, [d]
0927   0A19 38 00 00      mov c, 0
0928   0A1C 74            mov d, b
0929   0A1D 32            mov bl, [d]
0930   0A1E A7 00         mov bh, 0
0931   0A20 38 00 00      mov c, 0
0932   0A23             ; --- START RELATIONAL
0933   0A23 D7            push a
0934   0A24 11            mov a, b
0935   0A25 FD 2E 75 00   mov32 cb, $00000075
0935   0A29 00 00 
0936   0A2B B0            cmp a, b
0937   0A2C FD 71         seq ; ==
0938   0A2E E4            pop a
0939   0A2F             ; --- END RELATIONAL
0940   0A2F C0 00 00      cmp b, 0
0941   0A32 C6 53 0A      je _if28_else
0942   0A35             _if28_TRUE:
0943   0A35             ; print_unsigned_long(*(unsigned long *)p); 
0944   0A35             ; --- START FUNCTION CALL
0945   0A35 FA FF FF      lea d, [bp + -1] ; $p
0946   0A38 2A            mov b, [d]
0947   0A39 38 00 00      mov c, 0
0948   0A3C 74            mov d, b
0949   0A3D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0950   0A40 FD 39         mov c, b ; And place it into C
0951   0A42 2A            mov b, [d] ; Lower Word in B
0952   0A43 12            mov a, c
0953   0A44 FD AA         swp a
0954   0A46 D7            push a
0955   0A47 FD AB         swp b
0956   0A49 D8            push b
0957   0A4A 07 81 0D      call print_unsigned_long
0958   0A4D 51 04 00      add sp, 4
0959   0A50             ; --- END FUNCTION CALL
0960   0A50 0A 9D 0A      jmp _if28_exit
0961   0A53             _if28_else:
0962   0A53             ; if(*format_p == 'x') 
0963   0A53             _if29_cond:
0964   0A53 FA FD FF      lea d, [bp + -3] ; $format_p
0965   0A56 2A            mov b, [d]
0966   0A57 38 00 00      mov c, 0
0967   0A5A 74            mov d, b
0968   0A5B 32            mov bl, [d]
0969   0A5C A7 00         mov bh, 0
0970   0A5E 38 00 00      mov c, 0
0971   0A61             ; --- START RELATIONAL
0972   0A61 D7            push a
0973   0A62 11            mov a, b
0974   0A63 FD 2E 78 00   mov32 cb, $00000078
0974   0A67 00 00 
0975   0A69 B0            cmp a, b
0976   0A6A FD 71         seq ; ==
0977   0A6C E4            pop a
0978   0A6D             ; --- END RELATIONAL
0979   0A6D C0 00 00      cmp b, 0
0980   0A70 C6 91 0A      je _if29_else
0981   0A73             _if29_TRUE:
0982   0A73             ; printx32(*(long int *)p); 
0983   0A73             ; --- START FUNCTION CALL
0984   0A73 FA FF FF      lea d, [bp + -1] ; $p
0985   0A76 2A            mov b, [d]
0986   0A77 38 00 00      mov c, 0
0987   0A7A 74            mov d, b
0988   0A7B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0989   0A7E FD 39         mov c, b ; And place it into C
0990   0A80 2A            mov b, [d] ; Lower Word in B
0991   0A81 12            mov a, c
0992   0A82 FD AA         swp a
0993   0A84 D7            push a
0994   0A85 FD AB         swp b
0995   0A87 D8            push b
0996   0A88 07 B5 0E      call printx32
0997   0A8B 51 04 00      add sp, 4
0998   0A8E             ; --- END FUNCTION CALL
0999   0A8E 0A 9D 0A      jmp _if29_exit
1000   0A91             _if29_else:
1001   0A91             ; err("Unexpected format in printf."); 
1002   0A91             ; --- START FUNCTION CALL
1003   0A91 26 53 13      mov b, _s6 ; "Unexpected format in printf."
1004   0A94 FD AB         swp b
1005   0A96 D8            push b
1006   0A97 07 15 0F      call err
1007   0A9A 51 02 00      add sp, 2
1008   0A9D             ; --- END FUNCTION CALL
1009   0A9D             _if29_exit:
1010   0A9D             _if28_exit:
1011   0A9D             _if27_exit:
1012   0A9D             ; p = p + 4; 
1013   0A9D FA FF FF      lea d, [bp + -1] ; $p
1014   0AA0 DA            push d
1015   0AA1 FA FF FF      lea d, [bp + -1] ; $p
1016   0AA4 2A            mov b, [d]
1017   0AA5 38 00 00      mov c, 0
1018   0AA8             ; --- START TERMS
1019   0AA8 D7            push a
1020   0AA9 11            mov a, b
1021   0AAA FD 2E 04 00   mov32 cb, $00000004
1021   0AAE 00 00 
1022   0AB0 56            add b, a
1023   0AB1 E4            pop a
1024   0AB2             ; --- END TERMS
1025   0AB2 E7            pop d
1026   0AB3 FD 43         mov [d], b
1027   0AB5             ; break; 
1028   0AB5 0A B1 0B      jmp _switch26_exit ; case break
1029   0AB8             _switch26_case2:
1030   0AB8             _switch26_case3:
1031   0AB8             ; print_signed(*(int*)p); 
1032   0AB8             ; --- START FUNCTION CALL
1033   0AB8 FA FF FF      lea d, [bp + -1] ; $p
1034   0ABB 2A            mov b, [d]
1035   0ABC 38 00 00      mov c, 0
1036   0ABF 74            mov d, b
1037   0AC0 2A            mov b, [d]
1038   0AC1 38 00 00      mov c, 0
1039   0AC4 FD AB         swp b
1040   0AC6 D8            push b
1041   0AC7 07 43 0F      call print_signed
1042   0ACA 51 02 00      add sp, 2
1043   0ACD             ; --- END FUNCTION CALL
1044   0ACD             ; p = p + 2; 
1045   0ACD FA FF FF      lea d, [bp + -1] ; $p
1046   0AD0 DA            push d
1047   0AD1 FA FF FF      lea d, [bp + -1] ; $p
1048   0AD4 2A            mov b, [d]
1049   0AD5 38 00 00      mov c, 0
1050   0AD8             ; --- START TERMS
1051   0AD8 D7            push a
1052   0AD9 11            mov a, b
1053   0ADA FD 2E 02 00   mov32 cb, $00000002
1053   0ADE 00 00 
1054   0AE0 56            add b, a
1055   0AE1 E4            pop a
1056   0AE2             ; --- END TERMS
1057   0AE2 E7            pop d
1058   0AE3 FD 43         mov [d], b
1059   0AE5             ; break; 
1060   0AE5 0A B1 0B      jmp _switch26_exit ; case break
1061   0AE8             _switch26_case4:
1062   0AE8             ; print_unsigned(*(unsigned int*)p); 
1063   0AE8             ; --- START FUNCTION CALL
1064   0AE8 FA FF FF      lea d, [bp + -1] ; $p
1065   0AEB 2A            mov b, [d]
1066   0AEC 38 00 00      mov c, 0
1067   0AEF 74            mov d, b
1068   0AF0 2A            mov b, [d]
1069   0AF1 38 00 00      mov c, 0
1070   0AF4 FD AB         swp b
1071   0AF6 D8            push b
1072   0AF7 07 94 10      call print_unsigned
1073   0AFA 51 02 00      add sp, 2
1074   0AFD             ; --- END FUNCTION CALL
1075   0AFD             ; p = p + 2; 
1076   0AFD FA FF FF      lea d, [bp + -1] ; $p
1077   0B00 DA            push d
1078   0B01 FA FF FF      lea d, [bp + -1] ; $p
1079   0B04 2A            mov b, [d]
1080   0B05 38 00 00      mov c, 0
1081   0B08             ; --- START TERMS
1082   0B08 D7            push a
1083   0B09 11            mov a, b
1084   0B0A FD 2E 02 00   mov32 cb, $00000002
1084   0B0E 00 00 
1085   0B10 56            add b, a
1086   0B11 E4            pop a
1087   0B12             ; --- END TERMS
1088   0B12 E7            pop d
1089   0B13 FD 43         mov [d], b
1090   0B15             ; break; 
1091   0B15 0A B1 0B      jmp _switch26_exit ; case break
1092   0B18             _switch26_case5:
1093   0B18             ; printx16(*(int*)p); 
1094   0B18             ; --- START FUNCTION CALL
1095   0B18 FA FF FF      lea d, [bp + -1] ; $p
1096   0B1B 2A            mov b, [d]
1097   0B1C 38 00 00      mov c, 0
1098   0B1F 74            mov d, b
1099   0B20 2A            mov b, [d]
1100   0B21 38 00 00      mov c, 0
1101   0B24 FD AB         swp b
1102   0B26 D8            push b
1103   0B27 07 AC 11      call printx16
1104   0B2A 51 02 00      add sp, 2
1105   0B2D             ; --- END FUNCTION CALL
1106   0B2D             ; p = p + 2; 
1107   0B2D FA FF FF      lea d, [bp + -1] ; $p
1108   0B30 DA            push d
1109   0B31 FA FF FF      lea d, [bp + -1] ; $p
1110   0B34 2A            mov b, [d]
1111   0B35 38 00 00      mov c, 0
1112   0B38             ; --- START TERMS
1113   0B38 D7            push a
1114   0B39 11            mov a, b
1115   0B3A FD 2E 02 00   mov32 cb, $00000002
1115   0B3E 00 00 
1116   0B40 56            add b, a
1117   0B41 E4            pop a
1118   0B42             ; --- END TERMS
1119   0B42 E7            pop d
1120   0B43 FD 43         mov [d], b
1121   0B45             ; break; 
1122   0B45 0A B1 0B      jmp _switch26_exit ; case break
1123   0B48             _switch26_case6:
1124   0B48             ; putchar(*(char*)p); 
1125   0B48             ; --- START FUNCTION CALL
1126   0B48 FA FF FF      lea d, [bp + -1] ; $p
1127   0B4B 2A            mov b, [d]
1128   0B4C 38 00 00      mov c, 0
1129   0B4F 74            mov d, b
1130   0B50 32            mov bl, [d]
1131   0B51 A7 00         mov bh, 0
1132   0B53 38 00 00      mov c, 0
1133   0B56 DD            push bl
1134   0B57 07 73 0D      call putchar
1135   0B5A 51 01 00      add sp, 1
1136   0B5D             ; --- END FUNCTION CALL
1137   0B5D             ; p = p + 2; 
1138   0B5D FA FF FF      lea d, [bp + -1] ; $p
1139   0B60 DA            push d
1140   0B61 FA FF FF      lea d, [bp + -1] ; $p
1141   0B64 2A            mov b, [d]
1142   0B65 38 00 00      mov c, 0
1143   0B68             ; --- START TERMS
1144   0B68 D7            push a
1145   0B69 11            mov a, b
1146   0B6A FD 2E 02 00   mov32 cb, $00000002
1146   0B6E 00 00 
1147   0B70 56            add b, a
1148   0B71 E4            pop a
1149   0B72             ; --- END TERMS
1150   0B72 E7            pop d
1151   0B73 FD 43         mov [d], b
1152   0B75             ; break; 
1153   0B75 0A B1 0B      jmp _switch26_exit ; case break
1154   0B78             _switch26_case7:
1155   0B78             ; print(*(char**)p); 
1156   0B78             ; --- START FUNCTION CALL
1157   0B78 FA FF FF      lea d, [bp + -1] ; $p
1158   0B7B 2A            mov b, [d]
1159   0B7C 38 00 00      mov c, 0
1160   0B7F 74            mov d, b
1161   0B80 2A            mov b, [d]
1162   0B81 FD AB         swp b
1163   0B83 D8            push b
1164   0B84 07 2A 0F      call print
1165   0B87 51 02 00      add sp, 2
1166   0B8A             ; --- END FUNCTION CALL
1167   0B8A             ; p = p + 2; 
1168   0B8A FA FF FF      lea d, [bp + -1] ; $p
1169   0B8D DA            push d
1170   0B8E FA FF FF      lea d, [bp + -1] ; $p
1171   0B91 2A            mov b, [d]
1172   0B92 38 00 00      mov c, 0
1173   0B95             ; --- START TERMS
1174   0B95 D7            push a
1175   0B96 11            mov a, b
1176   0B97 FD 2E 02 00   mov32 cb, $00000002
1176   0B9B 00 00 
1177   0B9D 56            add b, a
1178   0B9E E4            pop a
1179   0B9F             ; --- END TERMS
1180   0B9F E7            pop d
1181   0BA0 FD 43         mov [d], b
1182   0BA2             ; break; 
1183   0BA2 0A B1 0B      jmp _switch26_exit ; case break
1184   0BA5             _switch26_default:
1185   0BA5             ; print("Error: Unknown argument type.\n"); 
1186   0BA5             ; --- START FUNCTION CALL
1187   0BA5 26 70 13      mov b, _s7 ; "Error: Unknown argument type.\n"
1188   0BA8 FD AB         swp b
1189   0BAA D8            push b
1190   0BAB 07 2A 0F      call print
1191   0BAE 51 02 00      add sp, 2
1192   0BB1             ; --- END FUNCTION CALL
1193   0BB1             _switch26_exit:
1194   0BB1             ; format_p++; 
1195   0BB1 FA FD FF      lea d, [bp + -3] ; $format_p
1196   0BB4 2A            mov b, [d]
1197   0BB5 38 00 00      mov c, 0
1198   0BB8 FD 77         inc b
1199   0BBA FA FD FF      lea d, [bp + -3] ; $format_p
1200   0BBD FD 43         mov [d], b
1201   0BBF FD 7D         dec b
1202   0BC1 0A E9 0B      jmp _if25_exit
1203   0BC4             _if25_else:
1204   0BC4             ; putchar(*format_p); 
1205   0BC4             ; --- START FUNCTION CALL
1206   0BC4 FA FD FF      lea d, [bp + -3] ; $format_p
1207   0BC7 2A            mov b, [d]
1208   0BC8 38 00 00      mov c, 0
1209   0BCB 74            mov d, b
1210   0BCC 32            mov bl, [d]
1211   0BCD A7 00         mov bh, 0
1212   0BCF 38 00 00      mov c, 0
1213   0BD2 DD            push bl
1214   0BD3 07 73 0D      call putchar
1215   0BD6 51 01 00      add sp, 1
1216   0BD9             ; --- END FUNCTION CALL
1217   0BD9             ; format_p++; 
1218   0BD9 FA FD FF      lea d, [bp + -3] ; $format_p
1219   0BDC 2A            mov b, [d]
1220   0BDD 38 00 00      mov c, 0
1221   0BE0 FD 77         inc b
1222   0BE2 FA FD FF      lea d, [bp + -3] ; $format_p
1223   0BE5 FD 43         mov [d], b
1224   0BE7 FD 7D         dec b
1225   0BE9             _if25_exit:
1226   0BE9             _if24_exit:
1227   0BE9             _for23_update:
1228   0BE9 0A 1D 09      jmp _for23_cond
1229   0BEC             _for23_exit:
1230   0BEC F9            leave
1231   0BED 09            ret
1232   0BEE             
1233   0BEE             print_signed_long:
1234   0BEE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1235   0BF1             ; char digits[10]; 
1236   0BF1 52 0A 00      sub sp, 10
1237   0BF4             ; int i = 0; 
1238   0BF4 52 02 00      sub sp, 2
1239   0BF7             ; --- START LOCAL VAR INITIALIZATION
1240   0BF7 FA F5 FF      lea d, [bp + -11] ; $i
1241   0BFA DA            push d
1242   0BFB FD 2E 00 00   mov32 cb, $00000000
1242   0BFF 00 00 
1243   0C01 E7            pop d
1244   0C02 FD 43         mov [d], b
1245   0C04             ; --- END LOCAL VAR INITIALIZATION
1246   0C04             ; if (num < 0) { 
1247   0C04             _if30_cond:
1248   0C04 FA 05 00      lea d, [bp + 5] ; $num
1249   0C07 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1250   0C0A FD 39         mov c, b ; And place it into C
1251   0C0C 2A            mov b, [d] ; Lower Word in B
1252   0C0D             ; --- START RELATIONAL
1253   0C0D D7            push a
1254   0C0E FD D8         push g
1255   0C10 11            mov a, b
1256   0C11 FD 7A         mov g, c
1257   0C13 FD 2E 00 00   mov32 cb, $00000000
1257   0C17 00 00 
1258   0C19 FD AF         cmp32 ga, cb
1259   0C1B FD 73         slt ; <
1260   0C1D FD F1         pop g
1261   0C1F E4            pop a
1262   0C20             ; --- END RELATIONAL
1263   0C20 C0 00 00      cmp b, 0
1264   0C23 C6 55 0C      je _if30_else
1265   0C26             _if30_TRUE:
1266   0C26             ; putchar('-'); 
1267   0C26             ; --- START FUNCTION CALL
1268   0C26 FD 2E 2D 00   mov32 cb, $0000002d
1268   0C2A 00 00 
1269   0C2C DD            push bl
1270   0C2D 07 73 0D      call putchar
1271   0C30 51 01 00      add sp, 1
1272   0C33             ; --- END FUNCTION CALL
1273   0C33             ; num = -num; 
1274   0C33 FA 05 00      lea d, [bp + 5] ; $num
1275   0C36 DA            push d
1276   0C37 FA 05 00      lea d, [bp + 5] ; $num
1277   0C3A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1278   0C3D FD 39         mov c, b ; And place it into C
1279   0C3F 2A            mov b, [d] ; Lower Word in B
1280   0C40 12            mov a, c
1281   0C41 95            not a
1282   0C42 97            not b
1283   0C43 55 01 00      add b, 1
1284   0C46 5B 00 00      adc a, 0
1285   0C49 39            mov c, a
1286   0C4A E7            pop d
1287   0C4B FD 43         mov [d], b
1288   0C4D 28            mov b, c
1289   0C4E FD 44 02 00   mov [d + 2], b
1290   0C52 0A 89 0C      jmp _if30_exit
1291   0C55             _if30_else:
1292   0C55             ; if (num == 0) { 
1293   0C55             _if31_cond:
1294   0C55 FA 05 00      lea d, [bp + 5] ; $num
1295   0C58 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1296   0C5B FD 39         mov c, b ; And place it into C
1297   0C5D 2A            mov b, [d] ; Lower Word in B
1298   0C5E             ; --- START RELATIONAL
1299   0C5E D7            push a
1300   0C5F FD D8         push g
1301   0C61 11            mov a, b
1302   0C62 FD 7A         mov g, c
1303   0C64 FD 2E 00 00   mov32 cb, $00000000
1303   0C68 00 00 
1304   0C6A FD AF         cmp32 ga, cb
1305   0C6C FD 71         seq ; ==
1306   0C6E FD F1         pop g
1307   0C70 E4            pop a
1308   0C71             ; --- END RELATIONAL
1309   0C71 C0 00 00      cmp b, 0
1310   0C74 C6 89 0C      je _if31_exit
1311   0C77             _if31_TRUE:
1312   0C77             ; putchar('0'); 
1313   0C77             ; --- START FUNCTION CALL
1314   0C77 FD 2E 30 00   mov32 cb, $00000030
1314   0C7B 00 00 
1315   0C7D DD            push bl
1316   0C7E 07 73 0D      call putchar
1317   0C81 51 01 00      add sp, 1
1318   0C84             ; --- END FUNCTION CALL
1319   0C84             ; return; 
1320   0C84 F9            leave
1321   0C85 09            ret
1322   0C86 0A 89 0C      jmp _if31_exit
1323   0C89             _if31_exit:
1324   0C89             _if30_exit:
1325   0C89             ; while (num > 0) { 
1326   0C89             _while32_cond:
1327   0C89 FA 05 00      lea d, [bp + 5] ; $num
1328   0C8C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1329   0C8F FD 39         mov c, b ; And place it into C
1330   0C91 2A            mov b, [d] ; Lower Word in B
1331   0C92             ; --- START RELATIONAL
1332   0C92 D7            push a
1333   0C93 FD D8         push g
1334   0C95 11            mov a, b
1335   0C96 FD 7A         mov g, c
1336   0C98 FD 2E 00 00   mov32 cb, $00000000
1336   0C9C 00 00 
1337   0C9E FD AF         cmp32 ga, cb
1338   0CA0 FD 7F         sgt
1339   0CA2 FD F1         pop g
1340   0CA4 E4            pop a
1341   0CA5             ; --- END RELATIONAL
1342   0CA5 C0 00 00      cmp b, 0
1343   0CA8 C6 29 0D      je _while32_exit
1344   0CAB             _while32_block:
1345   0CAB             ; digits[i] = '0' + (num % 10); 
1346   0CAB FA F7 FF      lea d, [bp + -9] ; $digits
1347   0CAE D7            push a
1348   0CAF DA            push d
1349   0CB0 FA F5 FF      lea d, [bp + -11] ; $i
1350   0CB3 2A            mov b, [d]
1351   0CB4 38 00 00      mov c, 0
1352   0CB7 E7            pop d
1353   0CB8 5A            add d, b
1354   0CB9 E4            pop a
1355   0CBA DA            push d
1356   0CBB FD 2E 30 00   mov32 cb, $00000030
1356   0CBF 00 00 
1357   0CC1             ; --- START TERMS
1358   0CC1 D7            push a
1359   0CC2 11            mov a, b
1360   0CC3 FA 05 00      lea d, [bp + 5] ; $num
1361   0CC6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1362   0CC9 FD 39         mov c, b ; And place it into C
1363   0CCB 2A            mov b, [d] ; Lower Word in B
1364   0CCC             ; --- START FACTORS
1365   0CCC D7            push a
1366   0CCD FD D8         push g
1367   0CCF 11            mov a, b
1368   0CD0 FD 7A         mov g, c
1369   0CD2 FD 2E 0A 00   mov32 cb, $0000000a
1369   0CD6 00 00 
1370   0CD8 FD D8         push g ; save 'g' as the div instruction uses it
1371   0CDA AE            div a, b ; %, a: quotient, b: remainder
1372   0CDB 11            mov a, b
1373   0CDC FD F1         pop g
1374   0CDE FD 38         mov c, g
1375   0CE0 27            mov b, a
1376   0CE1 FD F1         pop g
1377   0CE3 E4            pop a
1378   0CE4             ; --- END FACTORS
1379   0CE4 FD 15         add32 cb, ga
1380   0CE6 E4            pop a
1381   0CE7             ; --- END TERMS
1382   0CE7 E7            pop d
1383   0CE8 FD 3E         mov [d], bl
1384   0CEA             ; num = num / 10; 
1385   0CEA FA 05 00      lea d, [bp + 5] ; $num
1386   0CED DA            push d
1387   0CEE FA 05 00      lea d, [bp + 5] ; $num
1388   0CF1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1389   0CF4 FD 39         mov c, b ; And place it into C
1390   0CF6 2A            mov b, [d] ; Lower Word in B
1391   0CF7             ; --- START FACTORS
1392   0CF7 D7            push a
1393   0CF8 FD D8         push g
1394   0CFA 11            mov a, b
1395   0CFB FD 7A         mov g, c
1396   0CFD FD 2E 0A 00   mov32 cb, $0000000a
1396   0D01 00 00 
1397   0D03 FD D8         push g ; save 'g' as the div instruction uses it
1398   0D05 AE            div a, b ; /, a: quotient, b: remainder
1399   0D06 FD F1         pop g
1400   0D08 FD 38         mov c, g
1401   0D0A 27            mov b, a
1402   0D0B FD F1         pop g
1403   0D0D E4            pop a
1404   0D0E             ; --- END FACTORS
1405   0D0E E7            pop d
1406   0D0F FD 43         mov [d], b
1407   0D11 28            mov b, c
1408   0D12 FD 44 02 00   mov [d + 2], b
1409   0D16             ; i++; 
1410   0D16 FA F5 FF      lea d, [bp + -11] ; $i
1411   0D19 2A            mov b, [d]
1412   0D1A 38 00 00      mov c, 0
1413   0D1D 11            mov a, b
1414   0D1E FD 77         inc b
1415   0D20 FA F5 FF      lea d, [bp + -11] ; $i
1416   0D23 FD 43         mov [d], b
1417   0D25 27            mov b, a
1418   0D26 0A 89 0C      jmp _while32_cond
1419   0D29             _while32_exit:
1420   0D29             ; while (i > 0) { 
1421   0D29             _while39_cond:
1422   0D29 FA F5 FF      lea d, [bp + -11] ; $i
1423   0D2C 2A            mov b, [d]
1424   0D2D 38 00 00      mov c, 0
1425   0D30             ; --- START RELATIONAL
1426   0D30 D7            push a
1427   0D31 11            mov a, b
1428   0D32 FD 2E 00 00   mov32 cb, $00000000
1428   0D36 00 00 
1429   0D38 B0            cmp a, b
1430   0D39 FD 7F         sgt ; >
1431   0D3B E4            pop a
1432   0D3C             ; --- END RELATIONAL
1433   0D3C C0 00 00      cmp b, 0
1434   0D3F C6 71 0D      je _while39_exit
1435   0D42             _while39_block:
1436   0D42             ; i--; 
1437   0D42 FA F5 FF      lea d, [bp + -11] ; $i
1438   0D45 2A            mov b, [d]
1439   0D46 38 00 00      mov c, 0
1440   0D49 11            mov a, b
1441   0D4A FD 7D         dec b
1442   0D4C FA F5 FF      lea d, [bp + -11] ; $i
1443   0D4F FD 43         mov [d], b
1444   0D51 27            mov b, a
1445   0D52             ; putchar(digits[i]); 
1446   0D52             ; --- START FUNCTION CALL
1447   0D52 FA F7 FF      lea d, [bp + -9] ; $digits
1448   0D55 D7            push a
1449   0D56 DA            push d
1450   0D57 FA F5 FF      lea d, [bp + -11] ; $i
1451   0D5A 2A            mov b, [d]
1452   0D5B 38 00 00      mov c, 0
1453   0D5E E7            pop d
1454   0D5F 5A            add d, b
1455   0D60 E4            pop a
1456   0D61 32            mov bl, [d]
1457   0D62 A7 00         mov bh, 0
1458   0D64 38 00 00      mov c, 0
1459   0D67 DD            push bl
1460   0D68 07 73 0D      call putchar
1461   0D6B 51 01 00      add sp, 1
1462   0D6E             ; --- END FUNCTION CALL
1463   0D6E 0A 29 0D      jmp _while39_cond
1464   0D71             _while39_exit:
1465   0D71 F9            leave
1466   0D72 09            ret
1467   0D73             
1468   0D73             putchar:
1469   0D73 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1470   0D76             ; --- BEGIN INLINE ASM SEGMENT
1471   0D76 FA 05 00      lea d, [bp + 5] ; $c
1472   0D79 1E            mov al, [d]
1473   0D7A 23            mov ah, al
1474   0D7B 19 00         mov al, 0
1475   0D7D 05 03         syscall sys_io      ; char in AH
1476   0D7F             ; --- END INLINE ASM SEGMENT
1477   0D7F F9            leave
1478   0D80 09            ret
1479   0D81             
1480   0D81             print_unsigned_long:
1481   0D81 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1482   0D84             ; char digits[10]; 
1483   0D84 52 0A 00      sub sp, 10
1484   0D87             ; int i; 
1485   0D87 52 02 00      sub sp, 2
1486   0D8A             ; i = 0; 
1487   0D8A FA F5 FF      lea d, [bp + -11] ; $i
1488   0D8D DA            push d
1489   0D8E FD 2E 00 00   mov32 cb, $00000000
1489   0D92 00 00 
1490   0D94 E7            pop d
1491   0D95 FD 43         mov [d], b
1492   0D97             ; if(num == 0){ 
1493   0D97             _if40_cond:
1494   0D97 FA 05 00      lea d, [bp + 5] ; $num
1495   0D9A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1496   0D9D FD 39         mov c, b ; And place it into C
1497   0D9F 2A            mov b, [d] ; Lower Word in B
1498   0DA0             ; --- START RELATIONAL
1499   0DA0 D7            push a
1500   0DA1 FD D8         push g
1501   0DA3 11            mov a, b
1502   0DA4 FD 7A         mov g, c
1503   0DA6 FD 2E 00 00   mov32 cb, $00000000
1503   0DAA 00 00 
1504   0DAC FD AF         cmp32 ga, cb
1505   0DAE FD 71         seq ; ==
1506   0DB0 FD F1         pop g
1507   0DB2 E4            pop a
1508   0DB3             ; --- END RELATIONAL
1509   0DB3 C0 00 00      cmp b, 0
1510   0DB6 C6 CB 0D      je _if40_exit
1511   0DB9             _if40_TRUE:
1512   0DB9             ; putchar('0'); 
1513   0DB9             ; --- START FUNCTION CALL
1514   0DB9 FD 2E 30 00   mov32 cb, $00000030
1514   0DBD 00 00 
1515   0DBF DD            push bl
1516   0DC0 07 73 0D      call putchar
1517   0DC3 51 01 00      add sp, 1
1518   0DC6             ; --- END FUNCTION CALL
1519   0DC6             ; return; 
1520   0DC6 F9            leave
1521   0DC7 09            ret
1522   0DC8 0A CB 0D      jmp _if40_exit
1523   0DCB             _if40_exit:
1524   0DCB             ; while (num > 0) { 
1525   0DCB             _while41_cond:
1526   0DCB FA 05 00      lea d, [bp + 5] ; $num
1527   0DCE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1528   0DD1 FD 39         mov c, b ; And place it into C
1529   0DD3 2A            mov b, [d] ; Lower Word in B
1530   0DD4             ; --- START RELATIONAL
1531   0DD4 D7            push a
1532   0DD5 FD D8         push g
1533   0DD7 11            mov a, b
1534   0DD8 FD 7A         mov g, c
1535   0DDA FD 2E 00 00   mov32 cb, $00000000
1535   0DDE 00 00 
1536   0DE0 FD AF         cmp32 ga, cb
1537   0DE2 FD 81         sgu
1538   0DE4 FD F1         pop g
1539   0DE6 E4            pop a
1540   0DE7             ; --- END RELATIONAL
1541   0DE7 C0 00 00      cmp b, 0
1542   0DEA C6 6B 0E      je _while41_exit
1543   0DED             _while41_block:
1544   0DED             ; digits[i] = '0' + (num % 10); 
1545   0DED FA F7 FF      lea d, [bp + -9] ; $digits
1546   0DF0 D7            push a
1547   0DF1 DA            push d
1548   0DF2 FA F5 FF      lea d, [bp + -11] ; $i
1549   0DF5 2A            mov b, [d]
1550   0DF6 38 00 00      mov c, 0
1551   0DF9 E7            pop d
1552   0DFA 5A            add d, b
1553   0DFB E4            pop a
1554   0DFC DA            push d
1555   0DFD FD 2E 30 00   mov32 cb, $00000030
1555   0E01 00 00 
1556   0E03             ; --- START TERMS
1557   0E03 D7            push a
1558   0E04 11            mov a, b
1559   0E05 FA 05 00      lea d, [bp + 5] ; $num
1560   0E08 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1561   0E0B FD 39         mov c, b ; And place it into C
1562   0E0D 2A            mov b, [d] ; Lower Word in B
1563   0E0E             ; --- START FACTORS
1564   0E0E D7            push a
1565   0E0F FD D8         push g
1566   0E11 11            mov a, b
1567   0E12 FD 7A         mov g, c
1568   0E14 FD 2E 0A 00   mov32 cb, $0000000a
1568   0E18 00 00 
1569   0E1A FD D8         push g ; save 'g' as the div instruction uses it
1570   0E1C AE            div a, b ; %, a: quotient, b: remainder
1571   0E1D 11            mov a, b
1572   0E1E FD F1         pop g
1573   0E20 FD 38         mov c, g
1574   0E22 27            mov b, a
1575   0E23 FD F1         pop g
1576   0E25 E4            pop a
1577   0E26             ; --- END FACTORS
1578   0E26 FD 15         add32 cb, ga
1579   0E28 E4            pop a
1580   0E29             ; --- END TERMS
1581   0E29 E7            pop d
1582   0E2A FD 3E         mov [d], bl
1583   0E2C             ; num = num / 10; 
1584   0E2C FA 05 00      lea d, [bp + 5] ; $num
1585   0E2F DA            push d
1586   0E30 FA 05 00      lea d, [bp + 5] ; $num
1587   0E33 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1588   0E36 FD 39         mov c, b ; And place it into C
1589   0E38 2A            mov b, [d] ; Lower Word in B
1590   0E39             ; --- START FACTORS
1591   0E39 D7            push a
1592   0E3A FD D8         push g
1593   0E3C 11            mov a, b
1594   0E3D FD 7A         mov g, c
1595   0E3F FD 2E 0A 00   mov32 cb, $0000000a
1595   0E43 00 00 
1596   0E45 FD D8         push g ; save 'g' as the div instruction uses it
1597   0E47 AE            div a, b ; /, a: quotient, b: remainder
1598   0E48 FD F1         pop g
1599   0E4A FD 38         mov c, g
1600   0E4C 27            mov b, a
1601   0E4D FD F1         pop g
1602   0E4F E4            pop a
1603   0E50             ; --- END FACTORS
1604   0E50 E7            pop d
1605   0E51 FD 43         mov [d], b
1606   0E53 28            mov b, c
1607   0E54 FD 44 02 00   mov [d + 2], b
1608   0E58             ; i++; 
1609   0E58 FA F5 FF      lea d, [bp + -11] ; $i
1610   0E5B 2A            mov b, [d]
1611   0E5C 38 00 00      mov c, 0
1612   0E5F 11            mov a, b
1613   0E60 FD 77         inc b
1614   0E62 FA F5 FF      lea d, [bp + -11] ; $i
1615   0E65 FD 43         mov [d], b
1616   0E67 27            mov b, a
1617   0E68 0A CB 0D      jmp _while41_cond
1618   0E6B             _while41_exit:
1619   0E6B             ; while (i > 0) { 
1620   0E6B             _while48_cond:
1621   0E6B FA F5 FF      lea d, [bp + -11] ; $i
1622   0E6E 2A            mov b, [d]
1623   0E6F 38 00 00      mov c, 0
1624   0E72             ; --- START RELATIONAL
1625   0E72 D7            push a
1626   0E73 11            mov a, b
1627   0E74 FD 2E 00 00   mov32 cb, $00000000
1627   0E78 00 00 
1628   0E7A B0            cmp a, b
1629   0E7B FD 7F         sgt ; >
1630   0E7D E4            pop a
1631   0E7E             ; --- END RELATIONAL
1632   0E7E C0 00 00      cmp b, 0
1633   0E81 C6 B3 0E      je _while48_exit
1634   0E84             _while48_block:
1635   0E84             ; i--; 
1636   0E84 FA F5 FF      lea d, [bp + -11] ; $i
1637   0E87 2A            mov b, [d]
1638   0E88 38 00 00      mov c, 0
1639   0E8B 11            mov a, b
1640   0E8C FD 7D         dec b
1641   0E8E FA F5 FF      lea d, [bp + -11] ; $i
1642   0E91 FD 43         mov [d], b
1643   0E93 27            mov b, a
1644   0E94             ; putchar(digits[i]); 
1645   0E94             ; --- START FUNCTION CALL
1646   0E94 FA F7 FF      lea d, [bp + -9] ; $digits
1647   0E97 D7            push a
1648   0E98 DA            push d
1649   0E99 FA F5 FF      lea d, [bp + -11] ; $i
1650   0E9C 2A            mov b, [d]
1651   0E9D 38 00 00      mov c, 0
1652   0EA0 E7            pop d
1653   0EA1 5A            add d, b
1654   0EA2 E4            pop a
1655   0EA3 32            mov bl, [d]
1656   0EA4 A7 00         mov bh, 0
1657   0EA6 38 00 00      mov c, 0
1658   0EA9 DD            push bl
1659   0EAA 07 73 0D      call putchar
1660   0EAD 51 01 00      add sp, 1
1661   0EB0             ; --- END FUNCTION CALL
1662   0EB0 0A 6B 0E      jmp _while48_cond
1663   0EB3             _while48_exit:
1664   0EB3 F9            leave
1665   0EB4 09            ret
1666   0EB5             
1667   0EB5             printx32:
1668   0EB5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1669   0EB8             ; --- BEGIN INLINE ASM SEGMENT
1670   0EB8 FA 05 00      lea d, [bp + 5] ; $hex
1671   0EBB 2B 02 00      mov b, [d+2]
1672   0EBE 07 C7 0E      call print_u16x_printx32
1673   0EC1 2A            mov b, [d]
1674   0EC2 07 C7 0E      call print_u16x_printx32
1675   0EC5             ; --- END INLINE ASM SEGMENT
1676   0EC5             ; return; 
1677   0EC5 F9            leave
1678   0EC6 09            ret
1679   0EC7             ; --- BEGIN INLINE ASM SEGMENT
1680   0EC7             print_u16x_printx32:
1681   0EC7 D7            push a
1682   0EC8 D8            push b
1683   0EC9 DD            push bl
1684   0ECA 30            mov bl, bh
1685   0ECB 07 E9 0E      call _itoa_printx32        ; convert bh to char in A
1686   0ECE 2F            mov bl, al        ; save al
1687   0ECF 19 00         mov al, 0
1688   0ED1 05 03         syscall sys_io        ; display AH
1689   0ED3 24            mov ah, bl        ; retrieve al
1690   0ED4 19 00         mov al, 0
1691   0ED6 05 03         syscall sys_io        ; display AL
1692   0ED8 EA            pop bl
1693   0ED9 07 E9 0E      call _itoa_printx32        ; convert bh to char in A
1694   0EDC 2F            mov bl, al        ; save al
1695   0EDD 19 00         mov al, 0
1696   0EDF 05 03         syscall sys_io        ; display AH
1697   0EE1 24            mov ah, bl        ; retrieve al
1698   0EE2 19 00         mov al, 0
1699   0EE4 05 03         syscall sys_io        ; display AL
1700   0EE6 E5            pop b
1701   0EE7 E4            pop a
1702   0EE8 09            ret
1703   0EE9             _itoa_printx32:
1704   0EE9 DA            push d
1705   0EEA D8            push b
1706   0EEB A7 00         mov bh, 0
1707   0EED FD A4 04      shr bl, 4  
1708   0EF0 74            mov d, b
1709   0EF1 1F 03 0F      mov al, [d + s_hex_digits_printx32]
1710   0EF4 23            mov ah, al
1711   0EF5 E5            pop b
1712   0EF6 D8            push b
1713   0EF7 A7 00         mov bh, 0
1714   0EF9 FD 87 0F      and bl, $0F
1715   0EFC 74            mov d, b
1716   0EFD 1F 03 0F      mov al, [d + s_hex_digits_printx32]
1717   0F00 E5            pop b
1718   0F01 E7            pop d
1719   0F02 09            ret
1720   0F03 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1720   0F07 34 35 36 37 
1720   0F0B 38 39 41 42 
1720   0F0F 43 44 45 46 
1721   0F13             ; --- END INLINE ASM SEGMENT
1722   0F13 F9            leave
1723   0F14 09            ret
1724   0F15             
1725   0F15             err:
1726   0F15 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1727   0F18             ; print(e); 
1728   0F18             ; --- START FUNCTION CALL
1729   0F18 FA 05 00      lea d, [bp + 5] ; $e
1730   0F1B 2A            mov b, [d]
1731   0F1C 38 00 00      mov c, 0
1732   0F1F FD AB         swp b
1733   0F21 D8            push b
1734   0F22 07 2A 0F      call print
1735   0F25 51 02 00      add sp, 2
1736   0F28             ; --- END FUNCTION CALL
1737   0F28 F9            leave
1738   0F29 09            ret
1739   0F2A             
1740   0F2A             print:
1741   0F2A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1742   0F2D             ; --- BEGIN INLINE ASM SEGMENT
1743   0F2D FA 05 00      lea d, [bp + 5] ; $s
1744   0F30 FD 2A         mov d, [d]
1745   0F32             _puts_L1_print:
1746   0F32 1E            mov al, [d]
1747   0F33 B9 00         cmp al, 0
1748   0F35 C6 41 0F      jz _puts_END_print
1749   0F38 23            mov ah, al
1750   0F39 19 00         mov al, 0
1751   0F3B 05 03         syscall sys_io
1752   0F3D 79            inc d
1753   0F3E 0A 32 0F      jmp _puts_L1_print
1754   0F41             _puts_END_print:
1755   0F41             ; --- END INLINE ASM SEGMENT
1756   0F41 F9            leave
1757   0F42 09            ret
1758   0F43             
1759   0F43             print_signed:
1760   0F43 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1761   0F46             ; char digits[5]; 
1762   0F46 52 05 00      sub sp, 5
1763   0F49             ; int i = 0; 
1764   0F49 52 02 00      sub sp, 2
1765   0F4C             ; --- START LOCAL VAR INITIALIZATION
1766   0F4C FA FA FF      lea d, [bp + -6] ; $i
1767   0F4F DA            push d
1768   0F50 FD 2E 00 00   mov32 cb, $00000000
1768   0F54 00 00 
1769   0F56 E7            pop d
1770   0F57 FD 43         mov [d], b
1771   0F59             ; --- END LOCAL VAR INITIALIZATION
1772   0F59             ; if (num < 0) { 
1773   0F59             _if49_cond:
1774   0F59 FA 05 00      lea d, [bp + 5] ; $num
1775   0F5C 2A            mov b, [d]
1776   0F5D 38 00 00      mov c, 0
1777   0F60             ; --- START RELATIONAL
1778   0F60 D7            push a
1779   0F61 11            mov a, b
1780   0F62 FD 2E 00 00   mov32 cb, $00000000
1780   0F66 00 00 
1781   0F68 B0            cmp a, b
1782   0F69 FD 73         slt ; < (signed)
1783   0F6B E4            pop a
1784   0F6C             ; --- END RELATIONAL
1785   0F6C C0 00 00      cmp b, 0
1786   0F6F C6 92 0F      je _if49_else
1787   0F72             _if49_TRUE:
1788   0F72             ; putchar('-'); 
1789   0F72             ; --- START FUNCTION CALL
1790   0F72 FD 2E 2D 00   mov32 cb, $0000002d
1790   0F76 00 00 
1791   0F78 DD            push bl
1792   0F79 07 73 0D      call putchar
1793   0F7C 51 01 00      add sp, 1
1794   0F7F             ; --- END FUNCTION CALL
1795   0F7F             ; num = -num; 
1796   0F7F FA 05 00      lea d, [bp + 5] ; $num
1797   0F82 DA            push d
1798   0F83 FA 05 00      lea d, [bp + 5] ; $num
1799   0F86 2A            mov b, [d]
1800   0F87 38 00 00      mov c, 0
1801   0F8A FD 97         neg b
1802   0F8C E7            pop d
1803   0F8D FD 43         mov [d], b
1804   0F8F 0A BD 0F      jmp _if49_exit
1805   0F92             _if49_else:
1806   0F92             ; if (num == 0) { 
1807   0F92             _if50_cond:
1808   0F92 FA 05 00      lea d, [bp + 5] ; $num
1809   0F95 2A            mov b, [d]
1810   0F96 38 00 00      mov c, 0
1811   0F99             ; --- START RELATIONAL
1812   0F99 D7            push a
1813   0F9A 11            mov a, b
1814   0F9B FD 2E 00 00   mov32 cb, $00000000
1814   0F9F 00 00 
1815   0FA1 B0            cmp a, b
1816   0FA2 FD 71         seq ; ==
1817   0FA4 E4            pop a
1818   0FA5             ; --- END RELATIONAL
1819   0FA5 C0 00 00      cmp b, 0
1820   0FA8 C6 BD 0F      je _if50_exit
1821   0FAB             _if50_TRUE:
1822   0FAB             ; putchar('0'); 
1823   0FAB             ; --- START FUNCTION CALL
1824   0FAB FD 2E 30 00   mov32 cb, $00000030
1824   0FAF 00 00 
1825   0FB1 DD            push bl
1826   0FB2 07 73 0D      call putchar
1827   0FB5 51 01 00      add sp, 1
1828   0FB8             ; --- END FUNCTION CALL
1829   0FB8             ; return; 
1830   0FB8 F9            leave
1831   0FB9 09            ret
1832   0FBA 0A BD 0F      jmp _if50_exit
1833   0FBD             _if50_exit:
1834   0FBD             _if49_exit:
1835   0FBD             ; while (num > 0) { 
1836   0FBD             _while51_cond:
1837   0FBD FA 05 00      lea d, [bp + 5] ; $num
1838   0FC0 2A            mov b, [d]
1839   0FC1 38 00 00      mov c, 0
1840   0FC4             ; --- START RELATIONAL
1841   0FC4 D7            push a
1842   0FC5 11            mov a, b
1843   0FC6 FD 2E 00 00   mov32 cb, $00000000
1843   0FCA 00 00 
1844   0FCC B0            cmp a, b
1845   0FCD FD 7F         sgt ; >
1846   0FCF E4            pop a
1847   0FD0             ; --- END RELATIONAL
1848   0FD0 C0 00 00      cmp b, 0
1849   0FD3 C6 4A 10      je _while51_exit
1850   0FD6             _while51_block:
1851   0FD6             ; digits[i] = '0' + (num % 10); 
1852   0FD6 FA FC FF      lea d, [bp + -4] ; $digits
1853   0FD9 D7            push a
1854   0FDA DA            push d
1855   0FDB FA FA FF      lea d, [bp + -6] ; $i
1856   0FDE 2A            mov b, [d]
1857   0FDF 38 00 00      mov c, 0
1858   0FE2 E7            pop d
1859   0FE3 5A            add d, b
1860   0FE4 E4            pop a
1861   0FE5 DA            push d
1862   0FE6 FD 2E 30 00   mov32 cb, $00000030
1862   0FEA 00 00 
1863   0FEC             ; --- START TERMS
1864   0FEC D7            push a
1865   0FED 11            mov a, b
1866   0FEE FA 05 00      lea d, [bp + 5] ; $num
1867   0FF1 2A            mov b, [d]
1868   0FF2 38 00 00      mov c, 0
1869   0FF5             ; --- START FACTORS
1870   0FF5 D7            push a
1871   0FF6 FD D8         push g
1872   0FF8 11            mov a, b
1873   0FF9 FD 7A         mov g, c
1874   0FFB FD 2E 0A 00   mov32 cb, $0000000a
1874   0FFF 00 00 
1875   1001 FD D8         push g ; save 'g' as the div instruction uses it
1876   1003 AE            div a, b ; %, a: quotient, b: remainder
1877   1004 11            mov a, b
1878   1005 FD F1         pop g
1879   1007 FD 38         mov c, g
1880   1009 27            mov b, a
1881   100A FD F1         pop g
1882   100C E4            pop a
1883   100D             ; --- END FACTORS
1884   100D 56            add b, a
1885   100E E4            pop a
1886   100F             ; --- END TERMS
1887   100F E7            pop d
1888   1010 FD 3E         mov [d], bl
1889   1012             ; num = num / 10; 
1890   1012 FA 05 00      lea d, [bp + 5] ; $num
1891   1015 DA            push d
1892   1016 FA 05 00      lea d, [bp + 5] ; $num
1893   1019 2A            mov b, [d]
1894   101A 38 00 00      mov c, 0
1895   101D             ; --- START FACTORS
1896   101D D7            push a
1897   101E FD D8         push g
1898   1020 11            mov a, b
1899   1021 FD 7A         mov g, c
1900   1023 FD 2E 0A 00   mov32 cb, $0000000a
1900   1027 00 00 
1901   1029 FD D8         push g ; save 'g' as the div instruction uses it
1902   102B AE            div a, b ; /, a: quotient, b: remainder
1903   102C FD F1         pop g
1904   102E FD 38         mov c, g
1905   1030 27            mov b, a
1906   1031 FD F1         pop g
1907   1033 E4            pop a
1908   1034             ; --- END FACTORS
1909   1034 E7            pop d
1910   1035 FD 43         mov [d], b
1911   1037             ; i++; 
1912   1037 FA FA FF      lea d, [bp + -6] ; $i
1913   103A 2A            mov b, [d]
1914   103B 38 00 00      mov c, 0
1915   103E 11            mov a, b
1916   103F FD 77         inc b
1917   1041 FA FA FF      lea d, [bp + -6] ; $i
1918   1044 FD 43         mov [d], b
1919   1046 27            mov b, a
1920   1047 0A BD 0F      jmp _while51_cond
1921   104A             _while51_exit:
1922   104A             ; while (i > 0) { 
1923   104A             _while58_cond:
1924   104A FA FA FF      lea d, [bp + -6] ; $i
1925   104D 2A            mov b, [d]
1926   104E 38 00 00      mov c, 0
1927   1051             ; --- START RELATIONAL
1928   1051 D7            push a
1929   1052 11            mov a, b
1930   1053 FD 2E 00 00   mov32 cb, $00000000
1930   1057 00 00 
1931   1059 B0            cmp a, b
1932   105A FD 7F         sgt ; >
1933   105C E4            pop a
1934   105D             ; --- END RELATIONAL
1935   105D C0 00 00      cmp b, 0
1936   1060 C6 92 10      je _while58_exit
1937   1063             _while58_block:
1938   1063             ; i--; 
1939   1063 FA FA FF      lea d, [bp + -6] ; $i
1940   1066 2A            mov b, [d]
1941   1067 38 00 00      mov c, 0
1942   106A 11            mov a, b
1943   106B FD 7D         dec b
1944   106D FA FA FF      lea d, [bp + -6] ; $i
1945   1070 FD 43         mov [d], b
1946   1072 27            mov b, a
1947   1073             ; putchar(digits[i]); 
1948   1073             ; --- START FUNCTION CALL
1949   1073 FA FC FF      lea d, [bp + -4] ; $digits
1950   1076 D7            push a
1951   1077 DA            push d
1952   1078 FA FA FF      lea d, [bp + -6] ; $i
1953   107B 2A            mov b, [d]
1954   107C 38 00 00      mov c, 0
1955   107F E7            pop d
1956   1080 5A            add d, b
1957   1081 E4            pop a
1958   1082 32            mov bl, [d]
1959   1083 A7 00         mov bh, 0
1960   1085 38 00 00      mov c, 0
1961   1088 DD            push bl
1962   1089 07 73 0D      call putchar
1963   108C 51 01 00      add sp, 1
1964   108F             ; --- END FUNCTION CALL
1965   108F 0A 4A 10      jmp _while58_cond
1966   1092             _while58_exit:
1967   1092 F9            leave
1968   1093 09            ret
1969   1094             
1970   1094             print_unsigned:
1971   1094 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1972   1097             ; char digits[5]; 
1973   1097 52 05 00      sub sp, 5
1974   109A             ; int i; 
1975   109A 52 02 00      sub sp, 2
1976   109D             ; i = 0; 
1977   109D FA FA FF      lea d, [bp + -6] ; $i
1978   10A0 DA            push d
1979   10A1 FD 2E 00 00   mov32 cb, $00000000
1979   10A5 00 00 
1980   10A7 E7            pop d
1981   10A8 FD 43         mov [d], b
1982   10AA             ; if(num == 0){ 
1983   10AA             _if59_cond:
1984   10AA FA 05 00      lea d, [bp + 5] ; $num
1985   10AD 2A            mov b, [d]
1986   10AE 38 00 00      mov c, 0
1987   10B1             ; --- START RELATIONAL
1988   10B1 D7            push a
1989   10B2 11            mov a, b
1990   10B3 FD 2E 00 00   mov32 cb, $00000000
1990   10B7 00 00 
1991   10B9 B0            cmp a, b
1992   10BA FD 71         seq ; ==
1993   10BC E4            pop a
1994   10BD             ; --- END RELATIONAL
1995   10BD C0 00 00      cmp b, 0
1996   10C0 C6 D5 10      je _if59_exit
1997   10C3             _if59_TRUE:
1998   10C3             ; putchar('0'); 
1999   10C3             ; --- START FUNCTION CALL
2000   10C3 FD 2E 30 00   mov32 cb, $00000030
2000   10C7 00 00 
2001   10C9 DD            push bl
2002   10CA 07 73 0D      call putchar
2003   10CD 51 01 00      add sp, 1
2004   10D0             ; --- END FUNCTION CALL
2005   10D0             ; return; 
2006   10D0 F9            leave
2007   10D1 09            ret
2008   10D2 0A D5 10      jmp _if59_exit
2009   10D5             _if59_exit:
2010   10D5             ; while (num > 0) { 
2011   10D5             _while60_cond:
2012   10D5 FA 05 00      lea d, [bp + 5] ; $num
2013   10D8 2A            mov b, [d]
2014   10D9 38 00 00      mov c, 0
2015   10DC             ; --- START RELATIONAL
2016   10DC D7            push a
2017   10DD 11            mov a, b
2018   10DE FD 2E 00 00   mov32 cb, $00000000
2018   10E2 00 00 
2019   10E4 B0            cmp a, b
2020   10E5 FD 81         sgu ; > (unsigned)
2021   10E7 E4            pop a
2022   10E8             ; --- END RELATIONAL
2023   10E8 C0 00 00      cmp b, 0
2024   10EB C6 62 11      je _while60_exit
2025   10EE             _while60_block:
2026   10EE             ; digits[i] = '0' + (num % 10); 
2027   10EE FA FC FF      lea d, [bp + -4] ; $digits
2028   10F1 D7            push a
2029   10F2 DA            push d
2030   10F3 FA FA FF      lea d, [bp + -6] ; $i
2031   10F6 2A            mov b, [d]
2032   10F7 38 00 00      mov c, 0
2033   10FA E7            pop d
2034   10FB 5A            add d, b
2035   10FC E4            pop a
2036   10FD DA            push d
2037   10FE FD 2E 30 00   mov32 cb, $00000030
2037   1102 00 00 
2038   1104             ; --- START TERMS
2039   1104 D7            push a
2040   1105 11            mov a, b
2041   1106 FA 05 00      lea d, [bp + 5] ; $num
2042   1109 2A            mov b, [d]
2043   110A 38 00 00      mov c, 0
2044   110D             ; --- START FACTORS
2045   110D D7            push a
2046   110E FD D8         push g
2047   1110 11            mov a, b
2048   1111 FD 7A         mov g, c
2049   1113 FD 2E 0A 00   mov32 cb, $0000000a
2049   1117 00 00 
2050   1119 FD D8         push g ; save 'g' as the div instruction uses it
2051   111B AE            div a, b ; %, a: quotient, b: remainder
2052   111C 11            mov a, b
2053   111D FD F1         pop g
2054   111F FD 38         mov c, g
2055   1121 27            mov b, a
2056   1122 FD F1         pop g
2057   1124 E4            pop a
2058   1125             ; --- END FACTORS
2059   1125 56            add b, a
2060   1126 E4            pop a
2061   1127             ; --- END TERMS
2062   1127 E7            pop d
2063   1128 FD 3E         mov [d], bl
2064   112A             ; num = num / 10; 
2065   112A FA 05 00      lea d, [bp + 5] ; $num
2066   112D DA            push d
2067   112E FA 05 00      lea d, [bp + 5] ; $num
2068   1131 2A            mov b, [d]
2069   1132 38 00 00      mov c, 0
2070   1135             ; --- START FACTORS
2071   1135 D7            push a
2072   1136 FD D8         push g
2073   1138 11            mov a, b
2074   1139 FD 7A         mov g, c
2075   113B FD 2E 0A 00   mov32 cb, $0000000a
2075   113F 00 00 
2076   1141 FD D8         push g ; save 'g' as the div instruction uses it
2077   1143 AE            div a, b ; /, a: quotient, b: remainder
2078   1144 FD F1         pop g
2079   1146 FD 38         mov c, g
2080   1148 27            mov b, a
2081   1149 FD F1         pop g
2082   114B E4            pop a
2083   114C             ; --- END FACTORS
2084   114C E7            pop d
2085   114D FD 43         mov [d], b
2086   114F             ; i++; 
2087   114F FA FA FF      lea d, [bp + -6] ; $i
2088   1152 2A            mov b, [d]
2089   1153 38 00 00      mov c, 0
2090   1156 11            mov a, b
2091   1157 FD 77         inc b
2092   1159 FA FA FF      lea d, [bp + -6] ; $i
2093   115C FD 43         mov [d], b
2094   115E 27            mov b, a
2095   115F 0A D5 10      jmp _while60_cond
2096   1162             _while60_exit:
2097   1162             ; while (i > 0) { 
2098   1162             _while67_cond:
2099   1162 FA FA FF      lea d, [bp + -6] ; $i
2100   1165 2A            mov b, [d]
2101   1166 38 00 00      mov c, 0
2102   1169             ; --- START RELATIONAL
2103   1169 D7            push a
2104   116A 11            mov a, b
2105   116B FD 2E 00 00   mov32 cb, $00000000
2105   116F 00 00 
2106   1171 B0            cmp a, b
2107   1172 FD 7F         sgt ; >
2108   1174 E4            pop a
2109   1175             ; --- END RELATIONAL
2110   1175 C0 00 00      cmp b, 0
2111   1178 C6 AA 11      je _while67_exit
2112   117B             _while67_block:
2113   117B             ; i--; 
2114   117B FA FA FF      lea d, [bp + -6] ; $i
2115   117E 2A            mov b, [d]
2116   117F 38 00 00      mov c, 0
2117   1182 11            mov a, b
2118   1183 FD 7D         dec b
2119   1185 FA FA FF      lea d, [bp + -6] ; $i
2120   1188 FD 43         mov [d], b
2121   118A 27            mov b, a
2122   118B             ; putchar(digits[i]); 
2123   118B             ; --- START FUNCTION CALL
2124   118B FA FC FF      lea d, [bp + -4] ; $digits
2125   118E D7            push a
2126   118F DA            push d
2127   1190 FA FA FF      lea d, [bp + -6] ; $i
2128   1193 2A            mov b, [d]
2129   1194 38 00 00      mov c, 0
2130   1197 E7            pop d
2131   1198 5A            add d, b
2132   1199 E4            pop a
2133   119A 32            mov bl, [d]
2134   119B A7 00         mov bh, 0
2135   119D 38 00 00      mov c, 0
2136   11A0 DD            push bl
2137   11A1 07 73 0D      call putchar
2138   11A4 51 01 00      add sp, 1
2139   11A7             ; --- END FUNCTION CALL
2140   11A7 0A 62 11      jmp _while67_cond
2141   11AA             _while67_exit:
2142   11AA F9            leave
2143   11AB 09            ret
2144   11AC             
2145   11AC             printx16:
2146   11AC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2147   11AF             ; --- BEGIN INLINE ASM SEGMENT
2148   11AF FA 05 00      lea d, [bp + 5] ; $hex
2149   11B2 2A            mov b, [d]
2150   11B3             print_u16x_printx16:
2151   11B3 DD            push bl
2152   11B4 30            mov bl, bh
2153   11B5 07 D2 11      call _itoa_printx16        ; convert bh to char in A
2154   11B8 2F            mov bl, al        ; save al
2155   11B9 19 00         mov al, 0
2156   11BB 05 03         syscall sys_io        ; display AH
2157   11BD 24            mov ah, bl        ; retrieve al
2158   11BE 19 00         mov al, 0
2159   11C0 05 03         syscall sys_io        ; display AL
2160   11C2 EA            pop bl
2161   11C3 07 D2 11      call _itoa_printx16        ; convert bh to char in A
2162   11C6 2F            mov bl, al        ; save al
2163   11C7 19 00         mov al, 0
2164   11C9 05 03         syscall sys_io        ; display AH
2165   11CB 24            mov ah, bl        ; retrieve al
2166   11CC 19 00         mov al, 0
2167   11CE 05 03         syscall sys_io        ; display AL
2168   11D0             ; --- END INLINE ASM SEGMENT
2169   11D0             ; return; 
2170   11D0 F9            leave
2171   11D1 09            ret
2172   11D2             ; --- BEGIN INLINE ASM SEGMENT
2173   11D2             _itoa_printx16:
2174   11D2 DA            push d
2175   11D3 D8            push b
2176   11D4 A7 00         mov bh, 0
2177   11D6 FD A4 04      shr bl, 4  
2178   11D9 74            mov d, b
2179   11DA 1F EC 11      mov al, [d + s_hex_digits_printx16]
2180   11DD 23            mov ah, al
2181   11DE E5            pop b
2182   11DF D8            push b
2183   11E0 A7 00         mov bh, 0
2184   11E2 FD 87 0F      and bl, $0F
2185   11E5 74            mov d, b
2186   11E6 1F EC 11      mov al, [d + s_hex_digits_printx16]
2187   11E9 E5            pop b
2188   11EA E7            pop d
2189   11EB 09            ret
2190   11EC 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
2190   11F0 34 35 36 37 
2190   11F4 38 39 41 42 
2190   11F8 43 44 45 46 
2191   11FC             ; --- END INLINE ASM SEGMENT
2192   11FC F9            leave
2193   11FD 09            ret
2194   11FE             
2195   11FE             scann:
2196   11FE F8 00 00      enter 0 ; (push bp; mov bp, sp)
2197   1201             ; int m; 
2198   1201 52 02 00      sub sp, 2
2199   1204             ; --- BEGIN INLINE ASM SEGMENT
2200   1204 F8 08 00      enter 8
2201   1207 FA F9 FF      lea d, [bp +- 7]
2202   120A 07 52 12      call _gets_scann
2203   120D 07 42 12      call _strlen_scann      ; get string length in C
2204   1210 7E            dec c
2205   1211 FD 4E         mov si, d
2206   1213 12            mov a, c
2207   1214 FD 99         shl a
2208   1216 3B EF 12      mov d, table_power_scann
2209   1219 59            add d, a
2210   121A 38 00 00      mov c, 0
2211   121D             mul_loop_scann:
2212   121D F6            lodsb      ; load ASCII to al
2213   121E B9 00         cmp al, 0
2214   1220 C6 33 12      je mul_exit_scann
2215   1223 6F 30         sub al, $30    ; make into integer
2216   1225 22 00         mov ah, 0
2217   1227 2A            mov b, [d]
2218   1228 AC            mul a, b      ; result in B since it fits in 16bits
2219   1229 11            mov a, b
2220   122A 28            mov b, c
2221   122B 54            add a, b
2222   122C 39            mov c, a
2223   122D 63 02 00      sub d, 2
2224   1230 0A 1D 12      jmp mul_loop_scann
2225   1233             mul_exit_scann:
2226   1233 12            mov a, c
2227   1234 F9            leave
2228   1235 FA FF FF      lea d, [bp + -1] ; $m
2229   1238 43            mov [d], a
2230   1239             ; --- END INLINE ASM SEGMENT
2231   1239             ; return m; 
2232   1239 FA FF FF      lea d, [bp + -1] ; $m
2233   123C 2A            mov b, [d]
2234   123D 38 00 00      mov c, 0
2235   1240 F9            leave
2236   1241 09            ret
2237   1242             ; --- BEGIN INLINE ASM SEGMENT
2238   1242             _strlen_scann:
2239   1242 DA            push d
2240   1243 38 00 00      mov c, 0
2241   1246             _strlen_L1_scann:
2242   1246 BD 00         cmp byte [d], 0
2243   1248 C6 50 12      je _strlen_ret_scann
2244   124B 79            inc d
2245   124C 78            inc c
2246   124D 0A 46 12      jmp _strlen_L1_scann
2247   1250             _strlen_ret_scann:
2248   1250 E7            pop d
2249   1251 09            ret
2250   1252             _gets_scann:
2251   1252 DA            push d
2252   1253             _gets_loop_scann:
2253   1253 19 01         mov al, 1
2254   1255 05 03         syscall sys_io      ; receive in AH
2255   1257 B9 00         cmp al, 0        ; check error code (AL)
2256   1259 C6 53 12      je _gets_loop_scann      ; if no char received, retry
2257   125C 76 1B         cmp ah, 27
2258   125E C6 7F 12      je _gets_ansi_esc_scann
2259   1261 76 0A         cmp ah, $0A        ; LF
2260   1263 C6 EA 12      je _gets_end_scann
2261   1266 76 0D         cmp ah, $0D        ; CR
2262   1268 C6 EA 12      je _gets_end_scann
2263   126B 76 5C         cmp ah, $5C        ; '\\'
2264   126D C6 AB 12      je _gets_escape_scann
2265   1270 76 08         cmp ah, $08      ; check for backspace
2266   1272 C6 7B 12      je _gets_backspace_scann
2267   1275 1A            mov al, ah
2268   1276 3E            mov [d], al
2269   1277 79            inc d
2270   1278 0A 53 12      jmp _gets_loop_scann
2271   127B             _gets_backspace_scann:
2272   127B 7F            dec d
2273   127C 0A 53 12      jmp _gets_loop_scann
2274   127F             _gets_ansi_esc_scann:
2275   127F 19 01         mov al, 1
2276   1281 05 03         syscall sys_io        ; receive in AH without echo
2277   1283 B9 00         cmp al, 0          ; check error code (AL)
2278   1285 C6 7F 12      je _gets_ansi_esc_scann    ; if no char received, retry
2279   1288 76 5B         cmp ah, '['
2280   128A C7 53 12      jne _gets_loop_scann
2281   128D             _gets_ansi_esc_2_scann:
2282   128D 19 01         mov al, 1
2283   128F 05 03         syscall sys_io          ; receive in AH without echo
2284   1291 B9 00         cmp al, 0            ; check error code (AL)
2285   1293 C6 8D 12      je _gets_ansi_esc_2_scann  ; if no char received, retry
2286   1296 76 44         cmp ah, 'D'
2287   1298 C6 A3 12      je _gets_left_arrow_scann
2288   129B 76 43         cmp ah, 'C'
2289   129D C6 A7 12      je _gets_right_arrow_scann
2290   12A0 0A 53 12      jmp _gets_loop_scann
2291   12A3             _gets_left_arrow_scann:
2292   12A3 7F            dec d
2293   12A4 0A 53 12      jmp _gets_loop_scann
2294   12A7             _gets_right_arrow_scann:
2295   12A7 79            inc d
2296   12A8 0A 53 12      jmp _gets_loop_scann
2297   12AB             _gets_escape_scann:
2298   12AB 19 01         mov al, 1
2299   12AD 05 03         syscall sys_io      ; receive in AH
2300   12AF B9 00         cmp al, 0        ; check error code (AL)
2301   12B1 C6 AB 12      je _gets_escape_scann      ; if no char received, retry
2302   12B4 76 6E         cmp ah, 'n'
2303   12B6 C6 D5 12      je _gets_LF_scann
2304   12B9 76 72         cmp ah, 'r'
2305   12BB C6 DC 12      je _gets_CR_scann
2306   12BE 76 30         cmp ah, '0'
2307   12C0 C6 E3 12      je _gets_NULL_scann
2308   12C3 76 5C         cmp ah, $5C  
2309   12C5 C6 CE 12      je _gets_slash_scann
2310   12C8 1A            mov al, ah        ; if not a known escape, it is just a normal letter
2311   12C9 3E            mov [d], al
2312   12CA 79            inc d
2313   12CB 0A 53 12      jmp _gets_loop_scann
2314   12CE             _gets_slash_scann:
2315   12CE 19 5C         mov al, $5C
2316   12D0 3E            mov [d], al
2317   12D1 79            inc d
2318   12D2 0A 53 12      jmp _gets_loop_scann
2319   12D5             _gets_LF_scann:
2320   12D5 19 0A         mov al, $0A
2321   12D7 3E            mov [d], al
2322   12D8 79            inc d
2323   12D9 0A 53 12      jmp _gets_loop_scann
2324   12DC             _gets_CR_scann:
2325   12DC 19 0D         mov al, $0D
2326   12DE 3E            mov [d], al
2327   12DF 79            inc d
2328   12E0 0A 53 12      jmp _gets_loop_scann
2329   12E3             _gets_NULL_scann:
2330   12E3 19 00         mov al, $00
2331   12E5 3E            mov [d], al
2332   12E6 79            inc d
2333   12E7 0A 53 12      jmp _gets_loop_scann
2334   12EA             _gets_end_scann:
2335   12EA 19 00         mov al, 0
2336   12EC 3E            mov [d], al        ; terminate string
2337   12ED E7            pop d
2338   12EE 09            ret
2339   12EF             table_power_scann:
2340   12EF 01 00       .dw 1
2341   12F1 0A 00       .dw 10
2342   12F3 64 00       .dw 100
2343   12F5 E8 03       .dw 1000
2344   12F7 10 27       .dw 10000
2345   12F9             ; --- END INLINE ASM SEGMENT
2346   12F9 F9            leave
2347   12FA 09            ret
2348   12FB             ; --- END TEXT SEGMENT
2349   12FB             
2350   12FB             ; --- BEGIN DATA SEGMENT
2351   12FB 61 20 6D 61 _s0: .db "a mantissa: ", 0
2351   12FF 6E 74 69 73 
2351   1303 73 61 3A 20 
2351   1307 00 
2352   1308 61 20 65 78 _s1: .db "a exponent: ", 0
2352   130C 70 6F 6E 65 
2352   1310 6E 74 3A 20 
2352   1314 00 
2353   1315 62 20 6D 61 _s2: .db "b mantissa: ", 0
2353   1319 6E 74 69 73 
2353   131D 73 61 3A 20 
2353   1321 00 
2354   1322 62 20 65 78 _s3: .db "b exponent: ", 0
2354   1326 70 6F 6E 65 
2354   132A 6E 74 3A 20 
2354   132E 00 
2355   132F 53 75 6D 20 _s4: .db "Sum mantissa: %d\n", 0
2355   1333 6D 61 6E 74 
2355   1337 69 73 73 61 
2355   133B 3A 20 25 64 
2355   133F 0A 00 
2356   1341 53 75 6D 20 _s5: .db "Sum exponent: %d\n", 0
2356   1345 65 78 70 6F 
2356   1349 6E 65 6E 74 
2356   134D 3A 20 25 64 
2356   1351 0A 00 
2357   1353 55 6E 65 78 _s6: .db "Unexpected format in printf.", 0
2357   1357 70 65 63 74 
2357   135B 65 64 20 66 
2357   135F 6F 72 6D 61 
2357   1363 74 20 69 6E 
2357   1367 20 70 72 69 
2357   136B 6E 74 66 2E 
2357   136F 00 
2358   1370 45 72 72 6F _s7: .db "Error: Unknown argument type.\n", 0
2358   1374 72 3A 20 55 
2358   1378 6E 6B 6E 6F 
2358   137C 77 6E 20 61 
2358   1380 72 67 75 6D 
2358   1384 65 6E 74 20 
2358   1388 74 79 70 65 
2358   138C 2E 0A 00 
2359   138F             
2360   138F 91 13       _heap_top: .dw _heap
2361   1391 00          _heap: .db 0
2362   1392             ; --- END DATA SEGMENT
2363   1392             
2364   1392             .end
tasm: Number of errors = 0
