0001   0000             ; --- FILENAME: programs/float.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             sys_break        .EQU  $0000
0002+  0000             sys_rtc          .EQU  $0001
0003+  0000             sys_ide          .EQU  $0002
0004+  0000             sys_io           .EQU  $0003
0005+  0000             sys_filesystem   .EQU  $0004
0006+  0000             sys_create_proc  .EQU  $0005
0007+  0000             sys_list_proc    .EQU  $0006
0008+  0000             sys_datetime     .EQU  $0007
0009+  0000             sys_reboot       .EQU  $0008
0010+  0000             sys_pause_proc   .EQU  $0009
0011+  0000             sys_resume_proc  .EQU  $000a
0012+  0000             sys_terminate_proc .EQU  $000b
0013+  0000             sys_system       .EQU  $000c
0014+  0000             sys_fdc          .EQU  $000d
0015+  0000             text_org         .EQU  $0400
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; struct t_float16 a, b; 
0011   0408 52 03 00      sub sp, 3
0012   040B 52 03 00      sub sp, 3
0013   040E             ; struct t_float16 sum; 
0014   040E 52 03 00      sub sp, 3
0015   0411             ; printf("a mantissa: "); 
0016   0411             ; --- START FUNCTION CALL
0017   0411 26 6F 12      mov b, _s0 ; "a mantissa: "
0018   0414 FD AB         swp b
0019   0416 D8            push b
0020   0417 07 61 08      call printf
0021   041A 51 02 00      add sp, 2
0022   041D             ; --- END FUNCTION CALL
0023   041D             ; a.mantissa = scann(); 
0024   041D FA FE FF      lea d, [bp + -2] ; $a
0025   0420 58 00 00      add d, 0
0026   0423 DA            push d
0027   0424             ; --- START FUNCTION CALL
0028   0424 07 5E 11      call scann
0029   0427 E7            pop d
0030   0428 FD 43         mov [d], b
0031   042A             ; printf("a exponent: "); 
0032   042A             ; --- START FUNCTION CALL
0033   042A 26 7C 12      mov b, _s1 ; "a exponent: "
0034   042D FD AB         swp b
0035   042F D8            push b
0036   0430 07 61 08      call printf
0037   0433 51 02 00      add sp, 2
0038   0436             ; --- END FUNCTION CALL
0039   0436             ; a.exponent = scann(); 
0040   0436 FA FE FF      lea d, [bp + -2] ; $a
0041   0439 58 02 00      add d, 2
0042   043C DA            push d
0043   043D             ; --- START FUNCTION CALL
0044   043D 07 5E 11      call scann
0045   0440 E7            pop d
0046   0441 FD 3E         mov [d], bl
0047   0443             ; printf("b mantissa: "); 
0048   0443             ; --- START FUNCTION CALL
0049   0443 26 89 12      mov b, _s2 ; "b mantissa: "
0050   0446 FD AB         swp b
0051   0448 D8            push b
0052   0449 07 61 08      call printf
0053   044C 51 02 00      add sp, 2
0054   044F             ; --- END FUNCTION CALL
0055   044F             ; b.mantissa = scann(); 
0056   044F FA FB FF      lea d, [bp + -5] ; $b
0057   0452 58 00 00      add d, 0
0058   0455 DA            push d
0059   0456             ; --- START FUNCTION CALL
0060   0456 07 5E 11      call scann
0061   0459 E7            pop d
0062   045A FD 43         mov [d], b
0063   045C             ; printf("b exponent: "); 
0064   045C             ; --- START FUNCTION CALL
0065   045C 26 96 12      mov b, _s3 ; "b exponent: "
0066   045F FD AB         swp b
0067   0461 D8            push b
0068   0462 07 61 08      call printf
0069   0465 51 02 00      add sp, 2
0070   0468             ; --- END FUNCTION CALL
0071   0468             ; b.exponent = scann(); 
0072   0468 FA FB FF      lea d, [bp + -5] ; $b
0073   046B 58 02 00      add d, 2
0074   046E DA            push d
0075   046F             ; --- START FUNCTION CALL
0076   046F 07 5E 11      call scann
0077   0472 E7            pop d
0078   0473 FD 3E         mov [d], bl
0079   0475             ; sum = add(a, b); 
0080   0475 FA F8 FF      lea d, [bp + -8] ; $sum
0081   0478 DA            push d
0082   0479             ; --- START FUNCTION CALL
0083   0479 FA FB FF      lea d, [bp + -5] ; $b
0084   047C 2D            mov b, d
0085   047D 38 00 00      mov c, 0
0086   0480 52 03 00      sub sp, 3
0087   0483 FD 28         mov si, b
0088   0485 FD FA 01 00   lea d, [sp + 1]
0089   0489 FD 50         mov di, d
0090   048B 38 03 00      mov c, 3
0091   048E FD F5         rep movsb
0092   0490 FA FE FF      lea d, [bp + -2] ; $a
0093   0493 2D            mov b, d
0094   0494 38 00 00      mov c, 0
0095   0497 52 03 00      sub sp, 3
0096   049A FD 28         mov si, b
0097   049C FD FA 01 00   lea d, [sp + 1]
0098   04A0 FD 50         mov di, d
0099   04A2 38 03 00      mov c, 3
0100   04A5 FD F5         rep movsb
0101   04A7 07 F4 04      call add
0102   04AA 51 06 00      add sp, 6
0103   04AD             ; --- END FUNCTION CALL
0104   04AD E7            pop d
0105   04AE FD 28         mov si, b
0106   04B0 FD 50         mov di, d
0107   04B2 38 03 00      mov c, 3
0108   04B5 FD F5         rep movsb
0109   04B7             ; printf("Sum mantissa: %d\n", sum.mantissa); 
0110   04B7             ; --- START FUNCTION CALL
0111   04B7 FA F8 FF      lea d, [bp + -8] ; $sum
0112   04BA 58 00 00      add d, 0
0113   04BD 2A            mov b, [d]
0114   04BE 38 00 00      mov c, 0
0115   04C1 FD AB         swp b
0116   04C3 D8            push b
0117   04C4 26 A3 12      mov b, _s4 ; "Sum mantissa: %d\n"
0118   04C7 FD AB         swp b
0119   04C9 D8            push b
0120   04CA 07 61 08      call printf
0121   04CD 51 04 00      add sp, 4
0122   04D0             ; --- END FUNCTION CALL
0123   04D0             ; printf("Sum exponent: %d\n", sum.exponent); 
0124   04D0             ; --- START FUNCTION CALL
0125   04D0 FA F8 FF      lea d, [bp + -8] ; $sum
0126   04D3 58 02 00      add d, 2
0127   04D6 32            mov bl, [d]
0128   04D7 A7 00         mov bh, 0
0129   04D9 38 00 00      mov c, 0
0130   04DC FD AB         swp b
0131   04DE D8            push b
0132   04DF 26 B5 12      mov b, _s5 ; "Sum exponent: %d\n"
0133   04E2 FD AB         swp b
0134   04E4 D8            push b
0135   04E5 07 61 08      call printf
0136   04E8 51 03 00      add sp, 3
0137   04EB             ; --- END FUNCTION CALL
0138   04EB             ; return 0; 
0139   04EB FD 2E 00 00   mov32 cb, $00000000
0139   04EF 00 00 
0140   04F1 F9            leave
0141   04F2 05 0B         syscall sys_terminate_proc
0142   04F4             
0143   04F4             add:
0144   04F4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0145   04F7             ; struct t_float16 result; 
0146   04F7 52 03 00      sub sp, 3
0147   04FA             ; if (a.exponent < b.exponent) { 
0148   04FA             _if1_cond:
0149   04FA FA 05 00      lea d, [bp + 5] ; $a
0150   04FD 58 02 00      add d, 2
0151   0500 32            mov bl, [d]
0152   0501 A7 00         mov bh, 0
0153   0503 38 00 00      mov c, 0
0154   0506             ; --- START RELATIONAL
0155   0506 D7            push a
0156   0507 11            mov a, b
0157   0508 FA 08 00      lea d, [bp + 8] ; $b
0158   050B 58 02 00      add d, 2
0159   050E 32            mov bl, [d]
0160   050F A7 00         mov bh, 0
0161   0511 38 00 00      mov c, 0
0162   0514 B0            cmp a, b
0163   0515 FD 73         slt ; < (signed)
0164   0517 E4            pop a
0165   0518             ; --- END RELATIONAL
0166   0518 C0 00 00      cmp b, 0
0167   051B C6 6F 05      je _if1_else
0168   051E             _if1_TRUE:
0169   051E             ; a.mantissa = a.mantissa >> (b.exponent - a.exponent); 
0170   051E FA 05 00      lea d, [bp + 5] ; $a
0171   0521 58 00 00      add d, 0
0172   0524 DA            push d
0173   0525 FA 05 00      lea d, [bp + 5] ; $a
0174   0528 58 00 00      add d, 0
0175   052B 2A            mov b, [d]
0176   052C 38 00 00      mov c, 0
0177   052F             ; --- START SHIFT
0178   052F D7            push a
0179   0530 11            mov a, b
0180   0531 FA 08 00      lea d, [bp + 8] ; $b
0181   0534 58 02 00      add d, 2
0182   0537 32            mov bl, [d]
0183   0538 A7 00         mov bh, 0
0184   053A 38 00 00      mov c, 0
0185   053D             ; --- START TERMS
0186   053D D7            push a
0187   053E 11            mov a, b
0188   053F FA 05 00      lea d, [bp + 5] ; $a
0189   0542 58 02 00      add d, 2
0190   0545 32            mov bl, [d]
0191   0546 A7 00         mov bh, 0
0192   0548 38 00 00      mov c, 0
0193   054B 60            sub a, b
0194   054C 27            mov b, a
0195   054D E4            pop a
0196   054E             ; --- END TERMS
0197   054E FD 39         mov c, b
0198   0550 A5            ashr a, cl
0199   0551 27            mov b, a
0200   0552 E4            pop a
0201   0553             ; --- END SHIFT
0202   0553 E7            pop d
0203   0554 FD 43         mov [d], b
0204   0556             ; a.exponent = b.exponent; 
0205   0556 FA 05 00      lea d, [bp + 5] ; $a
0206   0559 58 02 00      add d, 2
0207   055C DA            push d
0208   055D FA 08 00      lea d, [bp + 8] ; $b
0209   0560 58 02 00      add d, 2
0210   0563 32            mov bl, [d]
0211   0564 A7 00         mov bh, 0
0212   0566 38 00 00      mov c, 0
0213   0569 E7            pop d
0214   056A FD 3E         mov [d], bl
0215   056C 0A E4 05      jmp _if1_exit
0216   056F             _if1_else:
0217   056F             ; if (b.exponent < a.exponent) { 
0218   056F             _if2_cond:
0219   056F FA 08 00      lea d, [bp + 8] ; $b
0220   0572 58 02 00      add d, 2
0221   0575 32            mov bl, [d]
0222   0576 A7 00         mov bh, 0
0223   0578 38 00 00      mov c, 0
0224   057B             ; --- START RELATIONAL
0225   057B D7            push a
0226   057C 11            mov a, b
0227   057D FA 05 00      lea d, [bp + 5] ; $a
0228   0580 58 02 00      add d, 2
0229   0583 32            mov bl, [d]
0230   0584 A7 00         mov bh, 0
0231   0586 38 00 00      mov c, 0
0232   0589 B0            cmp a, b
0233   058A FD 73         slt ; < (signed)
0234   058C E4            pop a
0235   058D             ; --- END RELATIONAL
0236   058D C0 00 00      cmp b, 0
0237   0590 C6 E4 05      je _if2_exit
0238   0593             _if2_TRUE:
0239   0593             ; b.mantissa = b.mantissa >> (a.exponent - b.exponent); 
0240   0593 FA 08 00      lea d, [bp + 8] ; $b
0241   0596 58 00 00      add d, 0
0242   0599 DA            push d
0243   059A FA 08 00      lea d, [bp + 8] ; $b
0244   059D 58 00 00      add d, 0
0245   05A0 2A            mov b, [d]
0246   05A1 38 00 00      mov c, 0
0247   05A4             ; --- START SHIFT
0248   05A4 D7            push a
0249   05A5 11            mov a, b
0250   05A6 FA 05 00      lea d, [bp + 5] ; $a
0251   05A9 58 02 00      add d, 2
0252   05AC 32            mov bl, [d]
0253   05AD A7 00         mov bh, 0
0254   05AF 38 00 00      mov c, 0
0255   05B2             ; --- START TERMS
0256   05B2 D7            push a
0257   05B3 11            mov a, b
0258   05B4 FA 08 00      lea d, [bp + 8] ; $b
0259   05B7 58 02 00      add d, 2
0260   05BA 32            mov bl, [d]
0261   05BB A7 00         mov bh, 0
0262   05BD 38 00 00      mov c, 0
0263   05C0 60            sub a, b
0264   05C1 27            mov b, a
0265   05C2 E4            pop a
0266   05C3             ; --- END TERMS
0267   05C3 FD 39         mov c, b
0268   05C5 A5            ashr a, cl
0269   05C6 27            mov b, a
0270   05C7 E4            pop a
0271   05C8             ; --- END SHIFT
0272   05C8 E7            pop d
0273   05C9 FD 43         mov [d], b
0274   05CB             ; b.exponent = a.exponent; 
0275   05CB FA 08 00      lea d, [bp + 8] ; $b
0276   05CE 58 02 00      add d, 2
0277   05D1 DA            push d
0278   05D2 FA 05 00      lea d, [bp + 5] ; $a
0279   05D5 58 02 00      add d, 2
0280   05D8 32            mov bl, [d]
0281   05D9 A7 00         mov bh, 0
0282   05DB 38 00 00      mov c, 0
0283   05DE E7            pop d
0284   05DF FD 3E         mov [d], bl
0285   05E1 0A E4 05      jmp _if2_exit
0286   05E4             _if2_exit:
0287   05E4             _if1_exit:
0288   05E4             ; result.mantissa = a.mantissa + b.mantissa; 
0289   05E4 FA FE FF      lea d, [bp + -2] ; $result
0290   05E7 58 00 00      add d, 0
0291   05EA DA            push d
0292   05EB FA 05 00      lea d, [bp + 5] ; $a
0293   05EE 58 00 00      add d, 0
0294   05F1 2A            mov b, [d]
0295   05F2 38 00 00      mov c, 0
0296   05F5             ; --- START TERMS
0297   05F5 D7            push a
0298   05F6 11            mov a, b
0299   05F7 FA 08 00      lea d, [bp + 8] ; $b
0300   05FA 58 00 00      add d, 0
0301   05FD 2A            mov b, [d]
0302   05FE 38 00 00      mov c, 0
0303   0601 56            add b, a
0304   0602 E4            pop a
0305   0603             ; --- END TERMS
0306   0603 E7            pop d
0307   0604 FD 43         mov [d], b
0308   0606             ; result.exponent = a.exponent; 
0309   0606 FA FE FF      lea d, [bp + -2] ; $result
0310   0609 58 02 00      add d, 2
0311   060C DA            push d
0312   060D FA 05 00      lea d, [bp + 5] ; $a
0313   0610 58 02 00      add d, 2
0314   0613 32            mov bl, [d]
0315   0614 A7 00         mov bh, 0
0316   0616 38 00 00      mov c, 0
0317   0619 E7            pop d
0318   061A FD 3E         mov [d], bl
0319   061C             ; while (result.mantissa > 32767 || result.mantissa < -32767) { 
0320   061C             _while3_cond:
0321   061C FA FE FF      lea d, [bp + -2] ; $result
0322   061F 58 00 00      add d, 0
0323   0622 2A            mov b, [d]
0324   0623 38 00 00      mov c, 0
0325   0626             ; --- START RELATIONAL
0326   0626 D7            push a
0327   0627 11            mov a, b
0328   0628 FD 2E FF 7F   mov32 cb, $00007fff
0328   062C 00 00 
0329   062E B0            cmp a, b
0330   062F FD 7F         sgt ; >
0331   0631 E4            pop a
0332   0632             ; --- END RELATIONAL
0333   0632             ; --- START LOGICAL OR
0334   0632 D7            push a
0335   0633 11            mov a, b
0336   0634 FA FE FF      lea d, [bp + -2] ; $result
0337   0637 58 00 00      add d, 0
0338   063A 2A            mov b, [d]
0339   063B 38 00 00      mov c, 0
0340   063E             ; --- START RELATIONAL
0341   063E D7            push a
0342   063F 11            mov a, b
0343   0640 FD 2E 01 80   mov32 cb, $ffff8001
0343   0644 FF FF 
0344   0646 B0            cmp a, b
0345   0647 FD 73         slt ; < (signed)
0346   0649 E4            pop a
0347   064A             ; --- END RELATIONAL
0348   064A FD A8         sor a, b ; ||
0349   064C E4            pop a
0350   064D             ; --- END LOGICAL OR
0351   064D C0 00 00      cmp b, 0
0352   0650 C6 A1 06      je _while3_exit
0353   0653             _while3_block:
0354   0653             ; result.mantissa = result.mantissa / 2; 
0355   0653 FA FE FF      lea d, [bp + -2] ; $result
0356   0656 58 00 00      add d, 0
0357   0659 DA            push d
0358   065A FA FE FF      lea d, [bp + -2] ; $result
0359   065D 58 00 00      add d, 0
0360   0660 2A            mov b, [d]
0361   0661 38 00 00      mov c, 0
0362   0664             ; --- START FACTORS
0363   0664 D7            push a
0364   0665 FD D8         push g
0365   0667 11            mov a, b
0366   0668 FD 7A         mov g, c
0367   066A FD 2E 02 00   mov32 cb, $00000002
0367   066E 00 00 
0368   0670 FD D8         push g ; save 'g' as the div instruction uses it
0369   0672 AE            div a, b ; /, a: quotient, b: remainder
0370   0673 FD F1         pop g
0371   0675 FD 38         mov c, g
0372   0677 27            mov b, a
0373   0678 FD F1         pop g
0374   067A E4            pop a
0375   067B             ; --- END FACTORS
0376   067B E7            pop d
0377   067C FD 43         mov [d], b
0378   067E             ; result.exponent = result.exponent + 1; 
0379   067E FA FE FF      lea d, [bp + -2] ; $result
0380   0681 58 02 00      add d, 2
0381   0684 DA            push d
0382   0685 FA FE FF      lea d, [bp + -2] ; $result
0383   0688 58 02 00      add d, 2
0384   068B 32            mov bl, [d]
0385   068C A7 00         mov bh, 0
0386   068E 38 00 00      mov c, 0
0387   0691             ; --- START TERMS
0388   0691 D7            push a
0389   0692 11            mov a, b
0390   0693 FD 2E 01 00   mov32 cb, $00000001
0390   0697 00 00 
0391   0699 56            add b, a
0392   069A E4            pop a
0393   069B             ; --- END TERMS
0394   069B E7            pop d
0395   069C FD 3E         mov [d], bl
0396   069E 0A 1C 06      jmp _while3_cond
0397   06A1             _while3_exit:
0398   06A1             ; return result; 
0399   06A1 FA FE FF      lea d, [bp + -2] ; $result
0400   06A4 2D            mov b, d
0401   06A5 38 00 00      mov c, 0
0402   06A8 F9            leave
0403   06A9 09            ret
0404   06AA             
0405   06AA             subtract:
0406   06AA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0407   06AD             ; struct t_float16 result; 
0408   06AD 52 03 00      sub sp, 3
0409   06B0             ; if (a.exponent < b.exponent) { 
0410   06B0             _if6_cond:
0411   06B0 FA 05 00      lea d, [bp + 5] ; $a
0412   06B3 58 02 00      add d, 2
0413   06B6 32            mov bl, [d]
0414   06B7 A7 00         mov bh, 0
0415   06B9 38 00 00      mov c, 0
0416   06BC             ; --- START RELATIONAL
0417   06BC D7            push a
0418   06BD 11            mov a, b
0419   06BE FA 08 00      lea d, [bp + 8] ; $b
0420   06C1 58 02 00      add d, 2
0421   06C4 32            mov bl, [d]
0422   06C5 A7 00         mov bh, 0
0423   06C7 38 00 00      mov c, 0
0424   06CA B0            cmp a, b
0425   06CB FD 73         slt ; < (signed)
0426   06CD E4            pop a
0427   06CE             ; --- END RELATIONAL
0428   06CE C0 00 00      cmp b, 0
0429   06D1 C6 25 07      je _if6_else
0430   06D4             _if6_TRUE:
0431   06D4             ; a.mantissa = a.mantissa >> (b.exponent - a.exponent); 
0432   06D4 FA 05 00      lea d, [bp + 5] ; $a
0433   06D7 58 00 00      add d, 0
0434   06DA DA            push d
0435   06DB FA 05 00      lea d, [bp + 5] ; $a
0436   06DE 58 00 00      add d, 0
0437   06E1 2A            mov b, [d]
0438   06E2 38 00 00      mov c, 0
0439   06E5             ; --- START SHIFT
0440   06E5 D7            push a
0441   06E6 11            mov a, b
0442   06E7 FA 08 00      lea d, [bp + 8] ; $b
0443   06EA 58 02 00      add d, 2
0444   06ED 32            mov bl, [d]
0445   06EE A7 00         mov bh, 0
0446   06F0 38 00 00      mov c, 0
0447   06F3             ; --- START TERMS
0448   06F3 D7            push a
0449   06F4 11            mov a, b
0450   06F5 FA 05 00      lea d, [bp + 5] ; $a
0451   06F8 58 02 00      add d, 2
0452   06FB 32            mov bl, [d]
0453   06FC A7 00         mov bh, 0
0454   06FE 38 00 00      mov c, 0
0455   0701 60            sub a, b
0456   0702 27            mov b, a
0457   0703 E4            pop a
0458   0704             ; --- END TERMS
0459   0704 FD 39         mov c, b
0460   0706 A5            ashr a, cl
0461   0707 27            mov b, a
0462   0708 E4            pop a
0463   0709             ; --- END SHIFT
0464   0709 E7            pop d
0465   070A FD 43         mov [d], b
0466   070C             ; a.exponent = b.exponent; 
0467   070C FA 05 00      lea d, [bp + 5] ; $a
0468   070F 58 02 00      add d, 2
0469   0712 DA            push d
0470   0713 FA 08 00      lea d, [bp + 8] ; $b
0471   0716 58 02 00      add d, 2
0472   0719 32            mov bl, [d]
0473   071A A7 00         mov bh, 0
0474   071C 38 00 00      mov c, 0
0475   071F E7            pop d
0476   0720 FD 3E         mov [d], bl
0477   0722 0A 9A 07      jmp _if6_exit
0478   0725             _if6_else:
0479   0725             ; if (b.exponent < a.exponent) { 
0480   0725             _if7_cond:
0481   0725 FA 08 00      lea d, [bp + 8] ; $b
0482   0728 58 02 00      add d, 2
0483   072B 32            mov bl, [d]
0484   072C A7 00         mov bh, 0
0485   072E 38 00 00      mov c, 0
0486   0731             ; --- START RELATIONAL
0487   0731 D7            push a
0488   0732 11            mov a, b
0489   0733 FA 05 00      lea d, [bp + 5] ; $a
0490   0736 58 02 00      add d, 2
0491   0739 32            mov bl, [d]
0492   073A A7 00         mov bh, 0
0493   073C 38 00 00      mov c, 0
0494   073F B0            cmp a, b
0495   0740 FD 73         slt ; < (signed)
0496   0742 E4            pop a
0497   0743             ; --- END RELATIONAL
0498   0743 C0 00 00      cmp b, 0
0499   0746 C6 9A 07      je _if7_exit
0500   0749             _if7_TRUE:
0501   0749             ; b.mantissa = b.mantissa >> (a.exponent - b.exponent); 
0502   0749 FA 08 00      lea d, [bp + 8] ; $b
0503   074C 58 00 00      add d, 0
0504   074F DA            push d
0505   0750 FA 08 00      lea d, [bp + 8] ; $b
0506   0753 58 00 00      add d, 0
0507   0756 2A            mov b, [d]
0508   0757 38 00 00      mov c, 0
0509   075A             ; --- START SHIFT
0510   075A D7            push a
0511   075B 11            mov a, b
0512   075C FA 05 00      lea d, [bp + 5] ; $a
0513   075F 58 02 00      add d, 2
0514   0762 32            mov bl, [d]
0515   0763 A7 00         mov bh, 0
0516   0765 38 00 00      mov c, 0
0517   0768             ; --- START TERMS
0518   0768 D7            push a
0519   0769 11            mov a, b
0520   076A FA 08 00      lea d, [bp + 8] ; $b
0521   076D 58 02 00      add d, 2
0522   0770 32            mov bl, [d]
0523   0771 A7 00         mov bh, 0
0524   0773 38 00 00      mov c, 0
0525   0776 60            sub a, b
0526   0777 27            mov b, a
0527   0778 E4            pop a
0528   0779             ; --- END TERMS
0529   0779 FD 39         mov c, b
0530   077B A5            ashr a, cl
0531   077C 27            mov b, a
0532   077D E4            pop a
0533   077E             ; --- END SHIFT
0534   077E E7            pop d
0535   077F FD 43         mov [d], b
0536   0781             ; b.exponent = a.exponent; 
0537   0781 FA 08 00      lea d, [bp + 8] ; $b
0538   0784 58 02 00      add d, 2
0539   0787 DA            push d
0540   0788 FA 05 00      lea d, [bp + 5] ; $a
0541   078B 58 02 00      add d, 2
0542   078E 32            mov bl, [d]
0543   078F A7 00         mov bh, 0
0544   0791 38 00 00      mov c, 0
0545   0794 E7            pop d
0546   0795 FD 3E         mov [d], bl
0547   0797 0A 9A 07      jmp _if7_exit
0548   079A             _if7_exit:
0549   079A             _if6_exit:
0550   079A             ; result.mantissa = a.mantissa - b.mantissa; 
0551   079A FA FE FF      lea d, [bp + -2] ; $result
0552   079D 58 00 00      add d, 0
0553   07A0 DA            push d
0554   07A1 FA 05 00      lea d, [bp + 5] ; $a
0555   07A4 58 00 00      add d, 0
0556   07A7 2A            mov b, [d]
0557   07A8 38 00 00      mov c, 0
0558   07AB             ; --- START TERMS
0559   07AB D7            push a
0560   07AC 11            mov a, b
0561   07AD FA 08 00      lea d, [bp + 8] ; $b
0562   07B0 58 00 00      add d, 0
0563   07B3 2A            mov b, [d]
0564   07B4 38 00 00      mov c, 0
0565   07B7 60            sub a, b
0566   07B8 27            mov b, a
0567   07B9 E4            pop a
0568   07BA             ; --- END TERMS
0569   07BA E7            pop d
0570   07BB FD 43         mov [d], b
0571   07BD             ; result.exponent = a.exponent; 
0572   07BD FA FE FF      lea d, [bp + -2] ; $result
0573   07C0 58 02 00      add d, 2
0574   07C3 DA            push d
0575   07C4 FA 05 00      lea d, [bp + 5] ; $a
0576   07C7 58 02 00      add d, 2
0577   07CA 32            mov bl, [d]
0578   07CB A7 00         mov bh, 0
0579   07CD 38 00 00      mov c, 0
0580   07D0 E7            pop d
0581   07D1 FD 3E         mov [d], bl
0582   07D3             ; while (result.mantissa > 32767 || result.mantissa < -32767) { 
0583   07D3             _while8_cond:
0584   07D3 FA FE FF      lea d, [bp + -2] ; $result
0585   07D6 58 00 00      add d, 0
0586   07D9 2A            mov b, [d]
0587   07DA 38 00 00      mov c, 0
0588   07DD             ; --- START RELATIONAL
0589   07DD D7            push a
0590   07DE 11            mov a, b
0591   07DF FD 2E FF 7F   mov32 cb, $00007fff
0591   07E3 00 00 
0592   07E5 B0            cmp a, b
0593   07E6 FD 7F         sgt ; >
0594   07E8 E4            pop a
0595   07E9             ; --- END RELATIONAL
0596   07E9             ; --- START LOGICAL OR
0597   07E9 D7            push a
0598   07EA 11            mov a, b
0599   07EB FA FE FF      lea d, [bp + -2] ; $result
0600   07EE 58 00 00      add d, 0
0601   07F1 2A            mov b, [d]
0602   07F2 38 00 00      mov c, 0
0603   07F5             ; --- START RELATIONAL
0604   07F5 D7            push a
0605   07F6 11            mov a, b
0606   07F7 FD 2E 01 80   mov32 cb, $ffff8001
0606   07FB FF FF 
0607   07FD B0            cmp a, b
0608   07FE FD 73         slt ; < (signed)
0609   0800 E4            pop a
0610   0801             ; --- END RELATIONAL
0611   0801 FD A8         sor a, b ; ||
0612   0803 E4            pop a
0613   0804             ; --- END LOGICAL OR
0614   0804 C0 00 00      cmp b, 0
0615   0807 C6 58 08      je _while8_exit
0616   080A             _while8_block:
0617   080A             ; result.mantissa = result.mantissa / 2; 
0618   080A FA FE FF      lea d, [bp + -2] ; $result
0619   080D 58 00 00      add d, 0
0620   0810 DA            push d
0621   0811 FA FE FF      lea d, [bp + -2] ; $result
0622   0814 58 00 00      add d, 0
0623   0817 2A            mov b, [d]
0624   0818 38 00 00      mov c, 0
0625   081B             ; --- START FACTORS
0626   081B D7            push a
0627   081C FD D8         push g
0628   081E 11            mov a, b
0629   081F FD 7A         mov g, c
0630   0821 FD 2E 02 00   mov32 cb, $00000002
0630   0825 00 00 
0631   0827 FD D8         push g ; save 'g' as the div instruction uses it
0632   0829 AE            div a, b ; /, a: quotient, b: remainder
0633   082A FD F1         pop g
0634   082C FD 38         mov c, g
0635   082E 27            mov b, a
0636   082F FD F1         pop g
0637   0831 E4            pop a
0638   0832             ; --- END FACTORS
0639   0832 E7            pop d
0640   0833 FD 43         mov [d], b
0641   0835             ; result.exponent = result.exponent + 1; 
0642   0835 FA FE FF      lea d, [bp + -2] ; $result
0643   0838 58 02 00      add d, 2
0644   083B DA            push d
0645   083C FA FE FF      lea d, [bp + -2] ; $result
0646   083F 58 02 00      add d, 2
0647   0842 32            mov bl, [d]
0648   0843 A7 00         mov bh, 0
0649   0845 38 00 00      mov c, 0
0650   0848             ; --- START TERMS
0651   0848 D7            push a
0652   0849 11            mov a, b
0653   084A FD 2E 01 00   mov32 cb, $00000001
0653   084E 00 00 
0654   0850 56            add b, a
0655   0851 E4            pop a
0656   0852             ; --- END TERMS
0657   0852 E7            pop d
0658   0853 FD 3E         mov [d], bl
0659   0855 0A D3 07      jmp _while8_cond
0660   0858             _while8_exit:
0661   0858             ; return result; 
0662   0858 FA FE FF      lea d, [bp + -2] ; $result
0663   085B 2D            mov b, d
0664   085C 38 00 00      mov c, 0
0665   085F F9            leave
0666   0860 09            ret
0667   0861             
0668   0861             printf:
0669   0861 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0670   0864             ; char *p, *format_p; 
0671   0864 52 02 00      sub sp, 2
0672   0867 52 02 00      sub sp, 2
0673   086A             ; format_p = format; 
0674   086A FA FD FF      lea d, [bp + -3] ; $format_p
0675   086D DA            push d
0676   086E FA 05 00      lea d, [bp + 5] ; $format
0677   0871 2A            mov b, [d]
0678   0872 38 00 00      mov c, 0
0679   0875 E7            pop d
0680   0876 FD 43         mov [d], b
0681   0878             ; p = &format + 2; 
0682   0878 FA FF FF      lea d, [bp + -1] ; $p
0683   087B DA            push d
0684   087C FA 05 00      lea d, [bp + 5] ; $format
0685   087F 2D            mov b, d
0686   0880             ; --- START TERMS
0687   0880 D7            push a
0688   0881 11            mov a, b
0689   0882 FD 2E 02 00   mov32 cb, $00000002
0689   0886 00 00 
0690   0888 56            add b, a
0691   0889 E4            pop a
0692   088A             ; --- END TERMS
0693   088A E7            pop d
0694   088B FD 43         mov [d], b
0695   088D             ; for(;;){ 
0696   088D             _for11_init:
0697   088D             _for11_cond:
0698   088D             _for11_block:
0699   088D             ; if(!*format_p) break; 
0700   088D             _if12_cond:
0701   088D FA FD FF      lea d, [bp + -3] ; $format_p
0702   0890 2A            mov b, [d]
0703   0891 38 00 00      mov c, 0
0704   0894 74            mov d, b
0705   0895 32            mov bl, [d]
0706   0896 A7 00         mov bh, 0
0707   0898 38 00 00      mov c, 0
0708   089B C0 00 00      cmp b, 0
0709   089E FD 71         seq ; !
0710   08A0 C0 00 00      cmp b, 0
0711   08A3 C6 AC 08      je _if12_else
0712   08A6             _if12_TRUE:
0713   08A6             ; break; 
0714   08A6 0A 4C 0B      jmp _for11_exit ; for break
0715   08A9 0A 39 0B      jmp _if12_exit
0716   08AC             _if12_else:
0717   08AC             ; if(*format_p == '%'){ 
0718   08AC             _if13_cond:
0719   08AC FA FD FF      lea d, [bp + -3] ; $format_p
0720   08AF 2A            mov b, [d]
0721   08B0 38 00 00      mov c, 0
0722   08B3 74            mov d, b
0723   08B4 32            mov bl, [d]
0724   08B5 A7 00         mov bh, 0
0725   08B7 38 00 00      mov c, 0
0726   08BA             ; --- START RELATIONAL
0727   08BA D7            push a
0728   08BB 11            mov a, b
0729   08BC FD 2E 25 00   mov32 cb, $00000025
0729   08C0 00 00 
0730   08C2 B0            cmp a, b
0731   08C3 FD 71         seq ; ==
0732   08C5 E4            pop a
0733   08C6             ; --- END RELATIONAL
0734   08C6 C0 00 00      cmp b, 0
0735   08C9 C6 24 0B      je _if13_else
0736   08CC             _if13_TRUE:
0737   08CC             ; format_p++; 
0738   08CC FA FD FF      lea d, [bp + -3] ; $format_p
0739   08CF 2A            mov b, [d]
0740   08D0 38 00 00      mov c, 0
0741   08D3 FD 77         inc b
0742   08D5 FA FD FF      lea d, [bp + -3] ; $format_p
0743   08D8 FD 43         mov [d], b
0744   08DA FD 7D         dec b
0745   08DC             ; switch(*format_p){ 
0746   08DC             _switch14_expr:
0747   08DC FA FD FF      lea d, [bp + -3] ; $format_p
0748   08DF 2A            mov b, [d]
0749   08E0 38 00 00      mov c, 0
0750   08E3 74            mov d, b
0751   08E4 32            mov bl, [d]
0752   08E5 A7 00         mov bh, 0
0753   08E7 38 00 00      mov c, 0
0754   08EA             _switch14_comparisons:
0755   08EA C1 6C         cmp bl, $6c
0756   08EC C6 18 09      je _switch14_case0
0757   08EF C1 4C         cmp bl, $4c
0758   08F1 C6 18 09      je _switch14_case1
0759   08F4 C1 64         cmp bl, $64
0760   08F6 C6 28 0A      je _switch14_case2
0761   08F9 C1 69         cmp bl, $69
0762   08FB C6 28 0A      je _switch14_case3
0763   08FE C1 75         cmp bl, $75
0764   0900 C6 58 0A      je _switch14_case4
0765   0903 C1 78         cmp bl, $78
0766   0905 C6 88 0A      je _switch14_case5
0767   0908 C1 63         cmp bl, $63
0768   090A C6 B8 0A      je _switch14_case6
0769   090D C1 73         cmp bl, $73
0770   090F C6 E8 0A      je _switch14_case7
0771   0912 0A 15 0B      jmp _switch14_default
0772   0915 0A 21 0B      jmp _switch14_exit
0773   0918             _switch14_case0:
0774   0918             _switch14_case1:
0775   0918             ; format_p++; 
0776   0918 FA FD FF      lea d, [bp + -3] ; $format_p
0777   091B 2A            mov b, [d]
0778   091C 38 00 00      mov c, 0
0779   091F FD 77         inc b
0780   0921 FA FD FF      lea d, [bp + -3] ; $format_p
0781   0924 FD 43         mov [d], b
0782   0926 FD 7D         dec b
0783   0928             ; if(*format_p == 'd' || *format_p == 'i') 
0784   0928             _if15_cond:
0785   0928 FA FD FF      lea d, [bp + -3] ; $format_p
0786   092B 2A            mov b, [d]
0787   092C 38 00 00      mov c, 0
0788   092F 74            mov d, b
0789   0930 32            mov bl, [d]
0790   0931 A7 00         mov bh, 0
0791   0933 38 00 00      mov c, 0
0792   0936             ; --- START RELATIONAL
0793   0936 D7            push a
0794   0937 11            mov a, b
0795   0938 FD 2E 64 00   mov32 cb, $00000064
0795   093C 00 00 
0796   093E B0            cmp a, b
0797   093F FD 71         seq ; ==
0798   0941 E4            pop a
0799   0942             ; --- END RELATIONAL
0800   0942             ; --- START LOGICAL OR
0801   0942 D7            push a
0802   0943 11            mov a, b
0803   0944 FA FD FF      lea d, [bp + -3] ; $format_p
0804   0947 2A            mov b, [d]
0805   0948 38 00 00      mov c, 0
0806   094B 74            mov d, b
0807   094C 32            mov bl, [d]
0808   094D A7 00         mov bh, 0
0809   094F 38 00 00      mov c, 0
0810   0952             ; --- START RELATIONAL
0811   0952 D7            push a
0812   0953 11            mov a, b
0813   0954 FD 2E 69 00   mov32 cb, $00000069
0813   0958 00 00 
0814   095A B0            cmp a, b
0815   095B FD 71         seq ; ==
0816   095D E4            pop a
0817   095E             ; --- END RELATIONAL
0818   095E FD A8         sor a, b ; ||
0819   0960 E4            pop a
0820   0961             ; --- END LOGICAL OR
0821   0961 C0 00 00      cmp b, 0
0822   0964 C6 85 09      je _if15_else
0823   0967             _if15_TRUE:
0824   0967             ; print_signed_long(*(long *)p); 
0825   0967             ; --- START FUNCTION CALL
0826   0967 FA FF FF      lea d, [bp + -1] ; $p
0827   096A 2A            mov b, [d]
0828   096B 38 00 00      mov c, 0
0829   096E 74            mov d, b
0830   096F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0831   0972 FD 39         mov c, b ; And place it into C
0832   0974 2A            mov b, [d] ; Lower Word in B
0833   0975 12            mov a, c
0834   0976 FD AA         swp a
0835   0978 D7            push a
0836   0979 FD AB         swp b
0837   097B D8            push b
0838   097C 07 4E 0B      call print_signed_long
0839   097F 51 04 00      add sp, 4
0840   0982             ; --- END FUNCTION CALL
0841   0982 0A 0D 0A      jmp _if15_exit
0842   0985             _if15_else:
0843   0985             ; if(*format_p == 'u') 
0844   0985             _if16_cond:
0845   0985 FA FD FF      lea d, [bp + -3] ; $format_p
0846   0988 2A            mov b, [d]
0847   0989 38 00 00      mov c, 0
0848   098C 74            mov d, b
0849   098D 32            mov bl, [d]
0850   098E A7 00         mov bh, 0
0851   0990 38 00 00      mov c, 0
0852   0993             ; --- START RELATIONAL
0853   0993 D7            push a
0854   0994 11            mov a, b
0855   0995 FD 2E 75 00   mov32 cb, $00000075
0855   0999 00 00 
0856   099B B0            cmp a, b
0857   099C FD 71         seq ; ==
0858   099E E4            pop a
0859   099F             ; --- END RELATIONAL
0860   099F C0 00 00      cmp b, 0
0861   09A2 C6 C3 09      je _if16_else
0862   09A5             _if16_TRUE:
0863   09A5             ; print_unsigned_long(*(unsigned long *)p); 
0864   09A5             ; --- START FUNCTION CALL
0865   09A5 FA FF FF      lea d, [bp + -1] ; $p
0866   09A8 2A            mov b, [d]
0867   09A9 38 00 00      mov c, 0
0868   09AC 74            mov d, b
0869   09AD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0870   09B0 FD 39         mov c, b ; And place it into C
0871   09B2 2A            mov b, [d] ; Lower Word in B
0872   09B3 12            mov a, c
0873   09B4 FD AA         swp a
0874   09B6 D7            push a
0875   09B7 FD AB         swp b
0876   09B9 D8            push b
0877   09BA 07 E1 0C      call print_unsigned_long
0878   09BD 51 04 00      add sp, 4
0879   09C0             ; --- END FUNCTION CALL
0880   09C0 0A 0D 0A      jmp _if16_exit
0881   09C3             _if16_else:
0882   09C3             ; if(*format_p == 'x') 
0883   09C3             _if17_cond:
0884   09C3 FA FD FF      lea d, [bp + -3] ; $format_p
0885   09C6 2A            mov b, [d]
0886   09C7 38 00 00      mov c, 0
0887   09CA 74            mov d, b
0888   09CB 32            mov bl, [d]
0889   09CC A7 00         mov bh, 0
0890   09CE 38 00 00      mov c, 0
0891   09D1             ; --- START RELATIONAL
0892   09D1 D7            push a
0893   09D2 11            mov a, b
0894   09D3 FD 2E 78 00   mov32 cb, $00000078
0894   09D7 00 00 
0895   09D9 B0            cmp a, b
0896   09DA FD 71         seq ; ==
0897   09DC E4            pop a
0898   09DD             ; --- END RELATIONAL
0899   09DD C0 00 00      cmp b, 0
0900   09E0 C6 01 0A      je _if17_else
0901   09E3             _if17_TRUE:
0902   09E3             ; printx32(*(long int *)p); 
0903   09E3             ; --- START FUNCTION CALL
0904   09E3 FA FF FF      lea d, [bp + -1] ; $p
0905   09E6 2A            mov b, [d]
0906   09E7 38 00 00      mov c, 0
0907   09EA 74            mov d, b
0908   09EB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0909   09EE FD 39         mov c, b ; And place it into C
0910   09F0 2A            mov b, [d] ; Lower Word in B
0911   09F1 12            mov a, c
0912   09F2 FD AA         swp a
0913   09F4 D7            push a
0914   09F5 FD AB         swp b
0915   09F7 D8            push b
0916   09F8 07 15 0E      call printx32
0917   09FB 51 04 00      add sp, 4
0918   09FE             ; --- END FUNCTION CALL
0919   09FE 0A 0D 0A      jmp _if17_exit
0920   0A01             _if17_else:
0921   0A01             ; err("Unexpected format in printf."); 
0922   0A01             ; --- START FUNCTION CALL
0923   0A01 26 C7 12      mov b, _s6 ; "Unexpected format in printf."
0924   0A04 FD AB         swp b
0925   0A06 D8            push b
0926   0A07 07 75 0E      call err
0927   0A0A 51 02 00      add sp, 2
0928   0A0D             ; --- END FUNCTION CALL
0929   0A0D             _if17_exit:
0930   0A0D             _if16_exit:
0931   0A0D             _if15_exit:
0932   0A0D             ; p = p + 4; 
0933   0A0D FA FF FF      lea d, [bp + -1] ; $p
0934   0A10 DA            push d
0935   0A11 FA FF FF      lea d, [bp + -1] ; $p
0936   0A14 2A            mov b, [d]
0937   0A15 38 00 00      mov c, 0
0938   0A18             ; --- START TERMS
0939   0A18 D7            push a
0940   0A19 11            mov a, b
0941   0A1A FD 2E 04 00   mov32 cb, $00000004
0941   0A1E 00 00 
0942   0A20 56            add b, a
0943   0A21 E4            pop a
0944   0A22             ; --- END TERMS
0945   0A22 E7            pop d
0946   0A23 FD 43         mov [d], b
0947   0A25             ; break; 
0948   0A25 0A 21 0B      jmp _switch14_exit ; case break
0949   0A28             _switch14_case2:
0950   0A28             _switch14_case3:
0951   0A28             ; print_signed(*(int*)p); 
0952   0A28             ; --- START FUNCTION CALL
0953   0A28 FA FF FF      lea d, [bp + -1] ; $p
0954   0A2B 2A            mov b, [d]
0955   0A2C 38 00 00      mov c, 0
0956   0A2F 74            mov d, b
0957   0A30 2A            mov b, [d]
0958   0A31 38 00 00      mov c, 0
0959   0A34 FD AB         swp b
0960   0A36 D8            push b
0961   0A37 07 A3 0E      call print_signed
0962   0A3A 51 02 00      add sp, 2
0963   0A3D             ; --- END FUNCTION CALL
0964   0A3D             ; p = p + 2; 
0965   0A3D FA FF FF      lea d, [bp + -1] ; $p
0966   0A40 DA            push d
0967   0A41 FA FF FF      lea d, [bp + -1] ; $p
0968   0A44 2A            mov b, [d]
0969   0A45 38 00 00      mov c, 0
0970   0A48             ; --- START TERMS
0971   0A48 D7            push a
0972   0A49 11            mov a, b
0973   0A4A FD 2E 02 00   mov32 cb, $00000002
0973   0A4E 00 00 
0974   0A50 56            add b, a
0975   0A51 E4            pop a
0976   0A52             ; --- END TERMS
0977   0A52 E7            pop d
0978   0A53 FD 43         mov [d], b
0979   0A55             ; break; 
0980   0A55 0A 21 0B      jmp _switch14_exit ; case break
0981   0A58             _switch14_case4:
0982   0A58             ; print_unsigned(*(unsigned int*)p); 
0983   0A58             ; --- START FUNCTION CALL
0984   0A58 FA FF FF      lea d, [bp + -1] ; $p
0985   0A5B 2A            mov b, [d]
0986   0A5C 38 00 00      mov c, 0
0987   0A5F 74            mov d, b
0988   0A60 2A            mov b, [d]
0989   0A61 38 00 00      mov c, 0
0990   0A64 FD AB         swp b
0991   0A66 D8            push b
0992   0A67 07 F4 0F      call print_unsigned
0993   0A6A 51 02 00      add sp, 2
0994   0A6D             ; --- END FUNCTION CALL
0995   0A6D             ; p = p + 2; 
0996   0A6D FA FF FF      lea d, [bp + -1] ; $p
0997   0A70 DA            push d
0998   0A71 FA FF FF      lea d, [bp + -1] ; $p
0999   0A74 2A            mov b, [d]
1000   0A75 38 00 00      mov c, 0
1001   0A78             ; --- START TERMS
1002   0A78 D7            push a
1003   0A79 11            mov a, b
1004   0A7A FD 2E 02 00   mov32 cb, $00000002
1004   0A7E 00 00 
1005   0A80 56            add b, a
1006   0A81 E4            pop a
1007   0A82             ; --- END TERMS
1008   0A82 E7            pop d
1009   0A83 FD 43         mov [d], b
1010   0A85             ; break; 
1011   0A85 0A 21 0B      jmp _switch14_exit ; case break
1012   0A88             _switch14_case5:
1013   0A88             ; printx16(*(int*)p); 
1014   0A88             ; --- START FUNCTION CALL
1015   0A88 FA FF FF      lea d, [bp + -1] ; $p
1016   0A8B 2A            mov b, [d]
1017   0A8C 38 00 00      mov c, 0
1018   0A8F 74            mov d, b
1019   0A90 2A            mov b, [d]
1020   0A91 38 00 00      mov c, 0
1021   0A94 FD AB         swp b
1022   0A96 D8            push b
1023   0A97 07 0C 11      call printx16
1024   0A9A 51 02 00      add sp, 2
1025   0A9D             ; --- END FUNCTION CALL
1026   0A9D             ; p = p + 2; 
1027   0A9D FA FF FF      lea d, [bp + -1] ; $p
1028   0AA0 DA            push d
1029   0AA1 FA FF FF      lea d, [bp + -1] ; $p
1030   0AA4 2A            mov b, [d]
1031   0AA5 38 00 00      mov c, 0
1032   0AA8             ; --- START TERMS
1033   0AA8 D7            push a
1034   0AA9 11            mov a, b
1035   0AAA FD 2E 02 00   mov32 cb, $00000002
1035   0AAE 00 00 
1036   0AB0 56            add b, a
1037   0AB1 E4            pop a
1038   0AB2             ; --- END TERMS
1039   0AB2 E7            pop d
1040   0AB3 FD 43         mov [d], b
1041   0AB5             ; break; 
1042   0AB5 0A 21 0B      jmp _switch14_exit ; case break
1043   0AB8             _switch14_case6:
1044   0AB8             ; putchar(*(char*)p); 
1045   0AB8             ; --- START FUNCTION CALL
1046   0AB8 FA FF FF      lea d, [bp + -1] ; $p
1047   0ABB 2A            mov b, [d]
1048   0ABC 38 00 00      mov c, 0
1049   0ABF 74            mov d, b
1050   0AC0 32            mov bl, [d]
1051   0AC1 A7 00         mov bh, 0
1052   0AC3 38 00 00      mov c, 0
1053   0AC6 DD            push bl
1054   0AC7 07 D3 0C      call putchar
1055   0ACA 51 01 00      add sp, 1
1056   0ACD             ; --- END FUNCTION CALL
1057   0ACD             ; p = p + 2; 
1058   0ACD FA FF FF      lea d, [bp + -1] ; $p
1059   0AD0 DA            push d
1060   0AD1 FA FF FF      lea d, [bp + -1] ; $p
1061   0AD4 2A            mov b, [d]
1062   0AD5 38 00 00      mov c, 0
1063   0AD8             ; --- START TERMS
1064   0AD8 D7            push a
1065   0AD9 11            mov a, b
1066   0ADA FD 2E 02 00   mov32 cb, $00000002
1066   0ADE 00 00 
1067   0AE0 56            add b, a
1068   0AE1 E4            pop a
1069   0AE2             ; --- END TERMS
1070   0AE2 E7            pop d
1071   0AE3 FD 43         mov [d], b
1072   0AE5             ; break; 
1073   0AE5 0A 21 0B      jmp _switch14_exit ; case break
1074   0AE8             _switch14_case7:
1075   0AE8             ; print(*(char**)p); 
1076   0AE8             ; --- START FUNCTION CALL
1077   0AE8 FA FF FF      lea d, [bp + -1] ; $p
1078   0AEB 2A            mov b, [d]
1079   0AEC 38 00 00      mov c, 0
1080   0AEF 74            mov d, b
1081   0AF0 2A            mov b, [d]
1082   0AF1 FD AB         swp b
1083   0AF3 D8            push b
1084   0AF4 07 8A 0E      call print
1085   0AF7 51 02 00      add sp, 2
1086   0AFA             ; --- END FUNCTION CALL
1087   0AFA             ; p = p + 2; 
1088   0AFA FA FF FF      lea d, [bp + -1] ; $p
1089   0AFD DA            push d
1090   0AFE FA FF FF      lea d, [bp + -1] ; $p
1091   0B01 2A            mov b, [d]
1092   0B02 38 00 00      mov c, 0
1093   0B05             ; --- START TERMS
1094   0B05 D7            push a
1095   0B06 11            mov a, b
1096   0B07 FD 2E 02 00   mov32 cb, $00000002
1096   0B0B 00 00 
1097   0B0D 56            add b, a
1098   0B0E E4            pop a
1099   0B0F             ; --- END TERMS
1100   0B0F E7            pop d
1101   0B10 FD 43         mov [d], b
1102   0B12             ; break; 
1103   0B12 0A 21 0B      jmp _switch14_exit ; case break
1104   0B15             _switch14_default:
1105   0B15             ; print("Error: Unknown argument type.\n"); 
1106   0B15             ; --- START FUNCTION CALL
1107   0B15 26 E4 12      mov b, _s7 ; "Error: Unknown argument type.\n"
1108   0B18 FD AB         swp b
1109   0B1A D8            push b
1110   0B1B 07 8A 0E      call print
1111   0B1E 51 02 00      add sp, 2
1112   0B21             ; --- END FUNCTION CALL
1113   0B21             _switch14_exit:
1114   0B21 0A 39 0B      jmp _if13_exit
1115   0B24             _if13_else:
1116   0B24             ; putchar(*format_p); 
1117   0B24             ; --- START FUNCTION CALL
1118   0B24 FA FD FF      lea d, [bp + -3] ; $format_p
1119   0B27 2A            mov b, [d]
1120   0B28 38 00 00      mov c, 0
1121   0B2B 74            mov d, b
1122   0B2C 32            mov bl, [d]
1123   0B2D A7 00         mov bh, 0
1124   0B2F 38 00 00      mov c, 0
1125   0B32 DD            push bl
1126   0B33 07 D3 0C      call putchar
1127   0B36 51 01 00      add sp, 1
1128   0B39             ; --- END FUNCTION CALL
1129   0B39             _if13_exit:
1130   0B39             _if12_exit:
1131   0B39             ; format_p++; 
1132   0B39 FA FD FF      lea d, [bp + -3] ; $format_p
1133   0B3C 2A            mov b, [d]
1134   0B3D 38 00 00      mov c, 0
1135   0B40 FD 77         inc b
1136   0B42 FA FD FF      lea d, [bp + -3] ; $format_p
1137   0B45 FD 43         mov [d], b
1138   0B47 FD 7D         dec b
1139   0B49             _for11_update:
1140   0B49 0A 8D 08      jmp _for11_cond
1141   0B4C             _for11_exit:
1142   0B4C F9            leave
1143   0B4D 09            ret
1144   0B4E             
1145   0B4E             print_signed_long:
1146   0B4E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1147   0B51             ; char digits[10]; 
1148   0B51 52 0A 00      sub sp, 10
1149   0B54             ; int i = 0; 
1150   0B54 52 02 00      sub sp, 2
1151   0B57             ; --- START LOCAL VAR INITIALIZATION
1152   0B57 FA F5 FF      lea d, [bp + -11] ; $i
1153   0B5A DA            push d
1154   0B5B FD 2E 00 00   mov32 cb, $00000000
1154   0B5F 00 00 
1155   0B61 E7            pop d
1156   0B62 FD 43         mov [d], b
1157   0B64             ; --- END LOCAL VAR INITIALIZATION
1158   0B64             ; if (num < 0) { 
1159   0B64             _if18_cond:
1160   0B64 FA 05 00      lea d, [bp + 5] ; $num
1161   0B67 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1162   0B6A FD 39         mov c, b ; And place it into C
1163   0B6C 2A            mov b, [d] ; Lower Word in B
1164   0B6D             ; --- START RELATIONAL
1165   0B6D D7            push a
1166   0B6E FD D8         push g
1167   0B70 11            mov a, b
1168   0B71 FD 7A         mov g, c
1169   0B73 FD 2E 00 00   mov32 cb, $00000000
1169   0B77 00 00 
1170   0B79 FD AF         cmp32 ga, cb
1171   0B7B FD 73         slt ; <
1172   0B7D FD F1         pop g
1173   0B7F E4            pop a
1174   0B80             ; --- END RELATIONAL
1175   0B80 C0 00 00      cmp b, 0
1176   0B83 C6 B5 0B      je _if18_else
1177   0B86             _if18_TRUE:
1178   0B86             ; putchar('-'); 
1179   0B86             ; --- START FUNCTION CALL
1180   0B86 FD 2E 2D 00   mov32 cb, $0000002d
1180   0B8A 00 00 
1181   0B8C DD            push bl
1182   0B8D 07 D3 0C      call putchar
1183   0B90 51 01 00      add sp, 1
1184   0B93             ; --- END FUNCTION CALL
1185   0B93             ; num = -num; 
1186   0B93 FA 05 00      lea d, [bp + 5] ; $num
1187   0B96 DA            push d
1188   0B97 FA 05 00      lea d, [bp + 5] ; $num
1189   0B9A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1190   0B9D FD 39         mov c, b ; And place it into C
1191   0B9F 2A            mov b, [d] ; Lower Word in B
1192   0BA0 12            mov a, c
1193   0BA1 95            not a
1194   0BA2 97            not b
1195   0BA3 55 01 00      add b, 1
1196   0BA6 5B 00 00      adc a, 0
1197   0BA9 39            mov c, a
1198   0BAA E7            pop d
1199   0BAB FD 43         mov [d], b
1200   0BAD 28            mov b, c
1201   0BAE FD 44 02 00   mov [d + 2], b
1202   0BB2 0A E9 0B      jmp _if18_exit
1203   0BB5             _if18_else:
1204   0BB5             ; if (num == 0) { 
1205   0BB5             _if19_cond:
1206   0BB5 FA 05 00      lea d, [bp + 5] ; $num
1207   0BB8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1208   0BBB FD 39         mov c, b ; And place it into C
1209   0BBD 2A            mov b, [d] ; Lower Word in B
1210   0BBE             ; --- START RELATIONAL
1211   0BBE D7            push a
1212   0BBF FD D8         push g
1213   0BC1 11            mov a, b
1214   0BC2 FD 7A         mov g, c
1215   0BC4 FD 2E 00 00   mov32 cb, $00000000
1215   0BC8 00 00 
1216   0BCA FD AF         cmp32 ga, cb
1217   0BCC FD 71         seq ; ==
1218   0BCE FD F1         pop g
1219   0BD0 E4            pop a
1220   0BD1             ; --- END RELATIONAL
1221   0BD1 C0 00 00      cmp b, 0
1222   0BD4 C6 E9 0B      je _if19_exit
1223   0BD7             _if19_TRUE:
1224   0BD7             ; putchar('0'); 
1225   0BD7             ; --- START FUNCTION CALL
1226   0BD7 FD 2E 30 00   mov32 cb, $00000030
1226   0BDB 00 00 
1227   0BDD DD            push bl
1228   0BDE 07 D3 0C      call putchar
1229   0BE1 51 01 00      add sp, 1
1230   0BE4             ; --- END FUNCTION CALL
1231   0BE4             ; return; 
1232   0BE4 F9            leave
1233   0BE5 09            ret
1234   0BE6 0A E9 0B      jmp _if19_exit
1235   0BE9             _if19_exit:
1236   0BE9             _if18_exit:
1237   0BE9             ; while (num > 0) { 
1238   0BE9             _while20_cond:
1239   0BE9 FA 05 00      lea d, [bp + 5] ; $num
1240   0BEC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1241   0BEF FD 39         mov c, b ; And place it into C
1242   0BF1 2A            mov b, [d] ; Lower Word in B
1243   0BF2             ; --- START RELATIONAL
1244   0BF2 D7            push a
1245   0BF3 FD D8         push g
1246   0BF5 11            mov a, b
1247   0BF6 FD 7A         mov g, c
1248   0BF8 FD 2E 00 00   mov32 cb, $00000000
1248   0BFC 00 00 
1249   0BFE FD AF         cmp32 ga, cb
1250   0C00 FD 7F         sgt
1251   0C02 FD F1         pop g
1252   0C04 E4            pop a
1253   0C05             ; --- END RELATIONAL
1254   0C05 C0 00 00      cmp b, 0
1255   0C08 C6 89 0C      je _while20_exit
1256   0C0B             _while20_block:
1257   0C0B             ; digits[i] = '0' + (num % 10); 
1258   0C0B FA F7 FF      lea d, [bp + -9] ; $digits
1259   0C0E D7            push a
1260   0C0F DA            push d
1261   0C10 FA F5 FF      lea d, [bp + -11] ; $i
1262   0C13 2A            mov b, [d]
1263   0C14 38 00 00      mov c, 0
1264   0C17 E7            pop d
1265   0C18 5A            add d, b
1266   0C19 E4            pop a
1267   0C1A DA            push d
1268   0C1B FD 2E 30 00   mov32 cb, $00000030
1268   0C1F 00 00 
1269   0C21             ; --- START TERMS
1270   0C21 D7            push a
1271   0C22 11            mov a, b
1272   0C23 FA 05 00      lea d, [bp + 5] ; $num
1273   0C26 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1274   0C29 FD 39         mov c, b ; And place it into C
1275   0C2B 2A            mov b, [d] ; Lower Word in B
1276   0C2C             ; --- START FACTORS
1277   0C2C D7            push a
1278   0C2D FD D8         push g
1279   0C2F 11            mov a, b
1280   0C30 FD 7A         mov g, c
1281   0C32 FD 2E 0A 00   mov32 cb, $0000000a
1281   0C36 00 00 
1282   0C38 FD D8         push g ; save 'g' as the div instruction uses it
1283   0C3A AE            div a, b ; %, a: quotient, b: remainder
1284   0C3B 11            mov a, b
1285   0C3C FD F1         pop g
1286   0C3E FD 38         mov c, g
1287   0C40 27            mov b, a
1288   0C41 FD F1         pop g
1289   0C43 E4            pop a
1290   0C44             ; --- END FACTORS
1291   0C44 FD 15         add32 cb, ga
1292   0C46 E4            pop a
1293   0C47             ; --- END TERMS
1294   0C47 E7            pop d
1295   0C48 FD 3E         mov [d], bl
1296   0C4A             ; num = num / 10; 
1297   0C4A FA 05 00      lea d, [bp + 5] ; $num
1298   0C4D DA            push d
1299   0C4E FA 05 00      lea d, [bp + 5] ; $num
1300   0C51 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1301   0C54 FD 39         mov c, b ; And place it into C
1302   0C56 2A            mov b, [d] ; Lower Word in B
1303   0C57             ; --- START FACTORS
1304   0C57 D7            push a
1305   0C58 FD D8         push g
1306   0C5A 11            mov a, b
1307   0C5B FD 7A         mov g, c
1308   0C5D FD 2E 0A 00   mov32 cb, $0000000a
1308   0C61 00 00 
1309   0C63 FD D8         push g ; save 'g' as the div instruction uses it
1310   0C65 AE            div a, b ; /, a: quotient, b: remainder
1311   0C66 FD F1         pop g
1312   0C68 FD 38         mov c, g
1313   0C6A 27            mov b, a
1314   0C6B FD F1         pop g
1315   0C6D E4            pop a
1316   0C6E             ; --- END FACTORS
1317   0C6E E7            pop d
1318   0C6F FD 43         mov [d], b
1319   0C71 28            mov b, c
1320   0C72 FD 44 02 00   mov [d + 2], b
1321   0C76             ; i++; 
1322   0C76 FA F5 FF      lea d, [bp + -11] ; $i
1323   0C79 2A            mov b, [d]
1324   0C7A 38 00 00      mov c, 0
1325   0C7D 11            mov a, b
1326   0C7E FD 77         inc b
1327   0C80 FA F5 FF      lea d, [bp + -11] ; $i
1328   0C83 FD 43         mov [d], b
1329   0C85 27            mov b, a
1330   0C86 0A E9 0B      jmp _while20_cond
1331   0C89             _while20_exit:
1332   0C89             ; while (i > 0) { 
1333   0C89             _while27_cond:
1334   0C89 FA F5 FF      lea d, [bp + -11] ; $i
1335   0C8C 2A            mov b, [d]
1336   0C8D 38 00 00      mov c, 0
1337   0C90             ; --- START RELATIONAL
1338   0C90 D7            push a
1339   0C91 11            mov a, b
1340   0C92 FD 2E 00 00   mov32 cb, $00000000
1340   0C96 00 00 
1341   0C98 B0            cmp a, b
1342   0C99 FD 7F         sgt ; >
1343   0C9B E4            pop a
1344   0C9C             ; --- END RELATIONAL
1345   0C9C C0 00 00      cmp b, 0
1346   0C9F C6 D1 0C      je _while27_exit
1347   0CA2             _while27_block:
1348   0CA2             ; i--; 
1349   0CA2 FA F5 FF      lea d, [bp + -11] ; $i
1350   0CA5 2A            mov b, [d]
1351   0CA6 38 00 00      mov c, 0
1352   0CA9 11            mov a, b
1353   0CAA FD 7D         dec b
1354   0CAC FA F5 FF      lea d, [bp + -11] ; $i
1355   0CAF FD 43         mov [d], b
1356   0CB1 27            mov b, a
1357   0CB2             ; putchar(digits[i]); 
1358   0CB2             ; --- START FUNCTION CALL
1359   0CB2 FA F7 FF      lea d, [bp + -9] ; $digits
1360   0CB5 D7            push a
1361   0CB6 DA            push d
1362   0CB7 FA F5 FF      lea d, [bp + -11] ; $i
1363   0CBA 2A            mov b, [d]
1364   0CBB 38 00 00      mov c, 0
1365   0CBE E7            pop d
1366   0CBF 5A            add d, b
1367   0CC0 E4            pop a
1368   0CC1 32            mov bl, [d]
1369   0CC2 A7 00         mov bh, 0
1370   0CC4 38 00 00      mov c, 0
1371   0CC7 DD            push bl
1372   0CC8 07 D3 0C      call putchar
1373   0CCB 51 01 00      add sp, 1
1374   0CCE             ; --- END FUNCTION CALL
1375   0CCE 0A 89 0C      jmp _while27_cond
1376   0CD1             _while27_exit:
1377   0CD1 F9            leave
1378   0CD2 09            ret
1379   0CD3             
1380   0CD3             putchar:
1381   0CD3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1382   0CD6             ; --- BEGIN INLINE ASM SEGMENT
1383   0CD6 FA 05 00      lea d, [bp + 5] ; $c
1384   0CD9 1E            mov al, [d]
1385   0CDA 23            mov ah, al
1386   0CDB 19 00         mov al, 0
1387   0CDD 05 03         syscall sys_io      ; char in AH
1388   0CDF             ; --- END INLINE ASM SEGMENT
1389   0CDF F9            leave
1390   0CE0 09            ret
1391   0CE1             
1392   0CE1             print_unsigned_long:
1393   0CE1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1394   0CE4             ; char digits[10]; 
1395   0CE4 52 0A 00      sub sp, 10
1396   0CE7             ; int i; 
1397   0CE7 52 02 00      sub sp, 2
1398   0CEA             ; i = 0; 
1399   0CEA FA F5 FF      lea d, [bp + -11] ; $i
1400   0CED DA            push d
1401   0CEE FD 2E 00 00   mov32 cb, $00000000
1401   0CF2 00 00 
1402   0CF4 E7            pop d
1403   0CF5 FD 43         mov [d], b
1404   0CF7             ; if(num == 0){ 
1405   0CF7             _if28_cond:
1406   0CF7 FA 05 00      lea d, [bp + 5] ; $num
1407   0CFA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1408   0CFD FD 39         mov c, b ; And place it into C
1409   0CFF 2A            mov b, [d] ; Lower Word in B
1410   0D00             ; --- START RELATIONAL
1411   0D00 D7            push a
1412   0D01 FD D8         push g
1413   0D03 11            mov a, b
1414   0D04 FD 7A         mov g, c
1415   0D06 FD 2E 00 00   mov32 cb, $00000000
1415   0D0A 00 00 
1416   0D0C FD AF         cmp32 ga, cb
1417   0D0E FD 71         seq ; ==
1418   0D10 FD F1         pop g
1419   0D12 E4            pop a
1420   0D13             ; --- END RELATIONAL
1421   0D13 C0 00 00      cmp b, 0
1422   0D16 C6 2B 0D      je _if28_exit
1423   0D19             _if28_TRUE:
1424   0D19             ; putchar('0'); 
1425   0D19             ; --- START FUNCTION CALL
1426   0D19 FD 2E 30 00   mov32 cb, $00000030
1426   0D1D 00 00 
1427   0D1F DD            push bl
1428   0D20 07 D3 0C      call putchar
1429   0D23 51 01 00      add sp, 1
1430   0D26             ; --- END FUNCTION CALL
1431   0D26             ; return; 
1432   0D26 F9            leave
1433   0D27 09            ret
1434   0D28 0A 2B 0D      jmp _if28_exit
1435   0D2B             _if28_exit:
1436   0D2B             ; while (num > 0) { 
1437   0D2B             _while29_cond:
1438   0D2B FA 05 00      lea d, [bp + 5] ; $num
1439   0D2E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1440   0D31 FD 39         mov c, b ; And place it into C
1441   0D33 2A            mov b, [d] ; Lower Word in B
1442   0D34             ; --- START RELATIONAL
1443   0D34 D7            push a
1444   0D35 FD D8         push g
1445   0D37 11            mov a, b
1446   0D38 FD 7A         mov g, c
1447   0D3A FD 2E 00 00   mov32 cb, $00000000
1447   0D3E 00 00 
1448   0D40 FD AF         cmp32 ga, cb
1449   0D42 FD 81         sgu
1450   0D44 FD F1         pop g
1451   0D46 E4            pop a
1452   0D47             ; --- END RELATIONAL
1453   0D47 C0 00 00      cmp b, 0
1454   0D4A C6 CB 0D      je _while29_exit
1455   0D4D             _while29_block:
1456   0D4D             ; digits[i] = '0' + (num % 10); 
1457   0D4D FA F7 FF      lea d, [bp + -9] ; $digits
1458   0D50 D7            push a
1459   0D51 DA            push d
1460   0D52 FA F5 FF      lea d, [bp + -11] ; $i
1461   0D55 2A            mov b, [d]
1462   0D56 38 00 00      mov c, 0
1463   0D59 E7            pop d
1464   0D5A 5A            add d, b
1465   0D5B E4            pop a
1466   0D5C DA            push d
1467   0D5D FD 2E 30 00   mov32 cb, $00000030
1467   0D61 00 00 
1468   0D63             ; --- START TERMS
1469   0D63 D7            push a
1470   0D64 11            mov a, b
1471   0D65 FA 05 00      lea d, [bp + 5] ; $num
1472   0D68 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1473   0D6B FD 39         mov c, b ; And place it into C
1474   0D6D 2A            mov b, [d] ; Lower Word in B
1475   0D6E             ; --- START FACTORS
1476   0D6E D7            push a
1477   0D6F FD D8         push g
1478   0D71 11            mov a, b
1479   0D72 FD 7A         mov g, c
1480   0D74 FD 2E 0A 00   mov32 cb, $0000000a
1480   0D78 00 00 
1481   0D7A FD D8         push g ; save 'g' as the div instruction uses it
1482   0D7C AE            div a, b ; %, a: quotient, b: remainder
1483   0D7D 11            mov a, b
1484   0D7E FD F1         pop g
1485   0D80 FD 38         mov c, g
1486   0D82 27            mov b, a
1487   0D83 FD F1         pop g
1488   0D85 E4            pop a
1489   0D86             ; --- END FACTORS
1490   0D86 FD 15         add32 cb, ga
1491   0D88 E4            pop a
1492   0D89             ; --- END TERMS
1493   0D89 E7            pop d
1494   0D8A FD 3E         mov [d], bl
1495   0D8C             ; num = num / 10; 
1496   0D8C FA 05 00      lea d, [bp + 5] ; $num
1497   0D8F DA            push d
1498   0D90 FA 05 00      lea d, [bp + 5] ; $num
1499   0D93 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1500   0D96 FD 39         mov c, b ; And place it into C
1501   0D98 2A            mov b, [d] ; Lower Word in B
1502   0D99             ; --- START FACTORS
1503   0D99 D7            push a
1504   0D9A FD D8         push g
1505   0D9C 11            mov a, b
1506   0D9D FD 7A         mov g, c
1507   0D9F FD 2E 0A 00   mov32 cb, $0000000a
1507   0DA3 00 00 
1508   0DA5 FD D8         push g ; save 'g' as the div instruction uses it
1509   0DA7 AE            div a, b ; /, a: quotient, b: remainder
1510   0DA8 FD F1         pop g
1511   0DAA FD 38         mov c, g
1512   0DAC 27            mov b, a
1513   0DAD FD F1         pop g
1514   0DAF E4            pop a
1515   0DB0             ; --- END FACTORS
1516   0DB0 E7            pop d
1517   0DB1 FD 43         mov [d], b
1518   0DB3 28            mov b, c
1519   0DB4 FD 44 02 00   mov [d + 2], b
1520   0DB8             ; i++; 
1521   0DB8 FA F5 FF      lea d, [bp + -11] ; $i
1522   0DBB 2A            mov b, [d]
1523   0DBC 38 00 00      mov c, 0
1524   0DBF 11            mov a, b
1525   0DC0 FD 77         inc b
1526   0DC2 FA F5 FF      lea d, [bp + -11] ; $i
1527   0DC5 FD 43         mov [d], b
1528   0DC7 27            mov b, a
1529   0DC8 0A 2B 0D      jmp _while29_cond
1530   0DCB             _while29_exit:
1531   0DCB             ; while (i > 0) { 
1532   0DCB             _while36_cond:
1533   0DCB FA F5 FF      lea d, [bp + -11] ; $i
1534   0DCE 2A            mov b, [d]
1535   0DCF 38 00 00      mov c, 0
1536   0DD2             ; --- START RELATIONAL
1537   0DD2 D7            push a
1538   0DD3 11            mov a, b
1539   0DD4 FD 2E 00 00   mov32 cb, $00000000
1539   0DD8 00 00 
1540   0DDA B0            cmp a, b
1541   0DDB FD 7F         sgt ; >
1542   0DDD E4            pop a
1543   0DDE             ; --- END RELATIONAL
1544   0DDE C0 00 00      cmp b, 0
1545   0DE1 C6 13 0E      je _while36_exit
1546   0DE4             _while36_block:
1547   0DE4             ; i--; 
1548   0DE4 FA F5 FF      lea d, [bp + -11] ; $i
1549   0DE7 2A            mov b, [d]
1550   0DE8 38 00 00      mov c, 0
1551   0DEB 11            mov a, b
1552   0DEC FD 7D         dec b
1553   0DEE FA F5 FF      lea d, [bp + -11] ; $i
1554   0DF1 FD 43         mov [d], b
1555   0DF3 27            mov b, a
1556   0DF4             ; putchar(digits[i]); 
1557   0DF4             ; --- START FUNCTION CALL
1558   0DF4 FA F7 FF      lea d, [bp + -9] ; $digits
1559   0DF7 D7            push a
1560   0DF8 DA            push d
1561   0DF9 FA F5 FF      lea d, [bp + -11] ; $i
1562   0DFC 2A            mov b, [d]
1563   0DFD 38 00 00      mov c, 0
1564   0E00 E7            pop d
1565   0E01 5A            add d, b
1566   0E02 E4            pop a
1567   0E03 32            mov bl, [d]
1568   0E04 A7 00         mov bh, 0
1569   0E06 38 00 00      mov c, 0
1570   0E09 DD            push bl
1571   0E0A 07 D3 0C      call putchar
1572   0E0D 51 01 00      add sp, 1
1573   0E10             ; --- END FUNCTION CALL
1574   0E10 0A CB 0D      jmp _while36_cond
1575   0E13             _while36_exit:
1576   0E13 F9            leave
1577   0E14 09            ret
1578   0E15             
1579   0E15             printx32:
1580   0E15 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1581   0E18             ; --- BEGIN INLINE ASM SEGMENT
1582   0E18 FA 05 00      lea d, [bp + 5] ; $hex
1583   0E1B 2B 02 00      mov b, [d+2]
1584   0E1E 07 27 0E      call print_u16x_printx32
1585   0E21 2A            mov b, [d]
1586   0E22 07 27 0E      call print_u16x_printx32
1587   0E25             ; --- END INLINE ASM SEGMENT
1588   0E25             ; return; 
1589   0E25 F9            leave
1590   0E26 09            ret
1591   0E27             ; --- BEGIN INLINE ASM SEGMENT
1592   0E27             print_u16x_printx32:
1593   0E27 D7            push a
1594   0E28 D8            push b
1595   0E29 DD            push bl
1596   0E2A 30            mov bl, bh
1597   0E2B 07 49 0E      call _itoa_printx32        ; convert bh to char in A
1598   0E2E 2F            mov bl, al        ; save al
1599   0E2F 19 00         mov al, 0
1600   0E31 05 03         syscall sys_io        ; display AH
1601   0E33 24            mov ah, bl        ; retrieve al
1602   0E34 19 00         mov al, 0
1603   0E36 05 03         syscall sys_io        ; display AL
1604   0E38 EA            pop bl
1605   0E39 07 49 0E      call _itoa_printx32        ; convert bh to char in A
1606   0E3C 2F            mov bl, al        ; save al
1607   0E3D 19 00         mov al, 0
1608   0E3F 05 03         syscall sys_io        ; display AH
1609   0E41 24            mov ah, bl        ; retrieve al
1610   0E42 19 00         mov al, 0
1611   0E44 05 03         syscall sys_io        ; display AL
1612   0E46 E5            pop b
1613   0E47 E4            pop a
1614   0E48 09            ret
1615   0E49             _itoa_printx32:
1616   0E49 DA            push d
1617   0E4A D8            push b
1618   0E4B A7 00         mov bh, 0
1619   0E4D FD A4 04      shr bl, 4  
1620   0E50 74            mov d, b
1621   0E51 1F 63 0E      mov al, [d + s_hex_digits_printx32]
1622   0E54 23            mov ah, al
1623   0E55 E5            pop b
1624   0E56 D8            push b
1625   0E57 A7 00         mov bh, 0
1626   0E59 FD 87 0F      and bl, $0F
1627   0E5C 74            mov d, b
1628   0E5D 1F 63 0E      mov al, [d + s_hex_digits_printx32]
1629   0E60 E5            pop b
1630   0E61 E7            pop d
1631   0E62 09            ret
1632   0E63 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1632   0E67 34 35 36 37 
1632   0E6B 38 39 41 42 
1632   0E6F 43 44 45 46 
1633   0E73             ; --- END INLINE ASM SEGMENT
1634   0E73 F9            leave
1635   0E74 09            ret
1636   0E75             
1637   0E75             err:
1638   0E75 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1639   0E78             ; print(e); 
1640   0E78             ; --- START FUNCTION CALL
1641   0E78 FA 05 00      lea d, [bp + 5] ; $e
1642   0E7B 2A            mov b, [d]
1643   0E7C 38 00 00      mov c, 0
1644   0E7F FD AB         swp b
1645   0E81 D8            push b
1646   0E82 07 8A 0E      call print
1647   0E85 51 02 00      add sp, 2
1648   0E88             ; --- END FUNCTION CALL
1649   0E88 F9            leave
1650   0E89 09            ret
1651   0E8A             
1652   0E8A             print:
1653   0E8A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1654   0E8D             ; --- BEGIN INLINE ASM SEGMENT
1655   0E8D FA 05 00      lea d, [bp + 5] ; $s
1656   0E90 FD 2A         mov d, [d]
1657   0E92             _puts_L1_print:
1658   0E92 1E            mov al, [d]
1659   0E93 B9 00         cmp al, 0
1660   0E95 C6 A1 0E      jz _puts_END_print
1661   0E98 23            mov ah, al
1662   0E99 19 00         mov al, 0
1663   0E9B 05 03         syscall sys_io
1664   0E9D 79            inc d
1665   0E9E 0A 92 0E      jmp _puts_L1_print
1666   0EA1             _puts_END_print:
1667   0EA1             ; --- END INLINE ASM SEGMENT
1668   0EA1 F9            leave
1669   0EA2 09            ret
1670   0EA3             
1671   0EA3             print_signed:
1672   0EA3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1673   0EA6             ; char digits[5]; 
1674   0EA6 52 05 00      sub sp, 5
1675   0EA9             ; int i = 0; 
1676   0EA9 52 02 00      sub sp, 2
1677   0EAC             ; --- START LOCAL VAR INITIALIZATION
1678   0EAC FA FA FF      lea d, [bp + -6] ; $i
1679   0EAF DA            push d
1680   0EB0 FD 2E 00 00   mov32 cb, $00000000
1680   0EB4 00 00 
1681   0EB6 E7            pop d
1682   0EB7 FD 43         mov [d], b
1683   0EB9             ; --- END LOCAL VAR INITIALIZATION
1684   0EB9             ; if (num < 0) { 
1685   0EB9             _if37_cond:
1686   0EB9 FA 05 00      lea d, [bp + 5] ; $num
1687   0EBC 2A            mov b, [d]
1688   0EBD 38 00 00      mov c, 0
1689   0EC0             ; --- START RELATIONAL
1690   0EC0 D7            push a
1691   0EC1 11            mov a, b
1692   0EC2 FD 2E 00 00   mov32 cb, $00000000
1692   0EC6 00 00 
1693   0EC8 B0            cmp a, b
1694   0EC9 FD 73         slt ; < (signed)
1695   0ECB E4            pop a
1696   0ECC             ; --- END RELATIONAL
1697   0ECC C0 00 00      cmp b, 0
1698   0ECF C6 F2 0E      je _if37_else
1699   0ED2             _if37_TRUE:
1700   0ED2             ; putchar('-'); 
1701   0ED2             ; --- START FUNCTION CALL
1702   0ED2 FD 2E 2D 00   mov32 cb, $0000002d
1702   0ED6 00 00 
1703   0ED8 DD            push bl
1704   0ED9 07 D3 0C      call putchar
1705   0EDC 51 01 00      add sp, 1
1706   0EDF             ; --- END FUNCTION CALL
1707   0EDF             ; num = -num; 
1708   0EDF FA 05 00      lea d, [bp + 5] ; $num
1709   0EE2 DA            push d
1710   0EE3 FA 05 00      lea d, [bp + 5] ; $num
1711   0EE6 2A            mov b, [d]
1712   0EE7 38 00 00      mov c, 0
1713   0EEA FD 97         neg b
1714   0EEC E7            pop d
1715   0EED FD 43         mov [d], b
1716   0EEF 0A 1D 0F      jmp _if37_exit
1717   0EF2             _if37_else:
1718   0EF2             ; if (num == 0) { 
1719   0EF2             _if38_cond:
1720   0EF2 FA 05 00      lea d, [bp + 5] ; $num
1721   0EF5 2A            mov b, [d]
1722   0EF6 38 00 00      mov c, 0
1723   0EF9             ; --- START RELATIONAL
1724   0EF9 D7            push a
1725   0EFA 11            mov a, b
1726   0EFB FD 2E 00 00   mov32 cb, $00000000
1726   0EFF 00 00 
1727   0F01 B0            cmp a, b
1728   0F02 FD 71         seq ; ==
1729   0F04 E4            pop a
1730   0F05             ; --- END RELATIONAL
1731   0F05 C0 00 00      cmp b, 0
1732   0F08 C6 1D 0F      je _if38_exit
1733   0F0B             _if38_TRUE:
1734   0F0B             ; putchar('0'); 
1735   0F0B             ; --- START FUNCTION CALL
1736   0F0B FD 2E 30 00   mov32 cb, $00000030
1736   0F0F 00 00 
1737   0F11 DD            push bl
1738   0F12 07 D3 0C      call putchar
1739   0F15 51 01 00      add sp, 1
1740   0F18             ; --- END FUNCTION CALL
1741   0F18             ; return; 
1742   0F18 F9            leave
1743   0F19 09            ret
1744   0F1A 0A 1D 0F      jmp _if38_exit
1745   0F1D             _if38_exit:
1746   0F1D             _if37_exit:
1747   0F1D             ; while (num > 0) { 
1748   0F1D             _while39_cond:
1749   0F1D FA 05 00      lea d, [bp + 5] ; $num
1750   0F20 2A            mov b, [d]
1751   0F21 38 00 00      mov c, 0
1752   0F24             ; --- START RELATIONAL
1753   0F24 D7            push a
1754   0F25 11            mov a, b
1755   0F26 FD 2E 00 00   mov32 cb, $00000000
1755   0F2A 00 00 
1756   0F2C B0            cmp a, b
1757   0F2D FD 7F         sgt ; >
1758   0F2F E4            pop a
1759   0F30             ; --- END RELATIONAL
1760   0F30 C0 00 00      cmp b, 0
1761   0F33 C6 AA 0F      je _while39_exit
1762   0F36             _while39_block:
1763   0F36             ; digits[i] = '0' + (num % 10); 
1764   0F36 FA FC FF      lea d, [bp + -4] ; $digits
1765   0F39 D7            push a
1766   0F3A DA            push d
1767   0F3B FA FA FF      lea d, [bp + -6] ; $i
1768   0F3E 2A            mov b, [d]
1769   0F3F 38 00 00      mov c, 0
1770   0F42 E7            pop d
1771   0F43 5A            add d, b
1772   0F44 E4            pop a
1773   0F45 DA            push d
1774   0F46 FD 2E 30 00   mov32 cb, $00000030
1774   0F4A 00 00 
1775   0F4C             ; --- START TERMS
1776   0F4C D7            push a
1777   0F4D 11            mov a, b
1778   0F4E FA 05 00      lea d, [bp + 5] ; $num
1779   0F51 2A            mov b, [d]
1780   0F52 38 00 00      mov c, 0
1781   0F55             ; --- START FACTORS
1782   0F55 D7            push a
1783   0F56 FD D8         push g
1784   0F58 11            mov a, b
1785   0F59 FD 7A         mov g, c
1786   0F5B FD 2E 0A 00   mov32 cb, $0000000a
1786   0F5F 00 00 
1787   0F61 FD D8         push g ; save 'g' as the div instruction uses it
1788   0F63 AE            div a, b ; %, a: quotient, b: remainder
1789   0F64 11            mov a, b
1790   0F65 FD F1         pop g
1791   0F67 FD 38         mov c, g
1792   0F69 27            mov b, a
1793   0F6A FD F1         pop g
1794   0F6C E4            pop a
1795   0F6D             ; --- END FACTORS
1796   0F6D 56            add b, a
1797   0F6E E4            pop a
1798   0F6F             ; --- END TERMS
1799   0F6F E7            pop d
1800   0F70 FD 3E         mov [d], bl
1801   0F72             ; num = num / 10; 
1802   0F72 FA 05 00      lea d, [bp + 5] ; $num
1803   0F75 DA            push d
1804   0F76 FA 05 00      lea d, [bp + 5] ; $num
1805   0F79 2A            mov b, [d]
1806   0F7A 38 00 00      mov c, 0
1807   0F7D             ; --- START FACTORS
1808   0F7D D7            push a
1809   0F7E FD D8         push g
1810   0F80 11            mov a, b
1811   0F81 FD 7A         mov g, c
1812   0F83 FD 2E 0A 00   mov32 cb, $0000000a
1812   0F87 00 00 
1813   0F89 FD D8         push g ; save 'g' as the div instruction uses it
1814   0F8B AE            div a, b ; /, a: quotient, b: remainder
1815   0F8C FD F1         pop g
1816   0F8E FD 38         mov c, g
1817   0F90 27            mov b, a
1818   0F91 FD F1         pop g
1819   0F93 E4            pop a
1820   0F94             ; --- END FACTORS
1821   0F94 E7            pop d
1822   0F95 FD 43         mov [d], b
1823   0F97             ; i++; 
1824   0F97 FA FA FF      lea d, [bp + -6] ; $i
1825   0F9A 2A            mov b, [d]
1826   0F9B 38 00 00      mov c, 0
1827   0F9E 11            mov a, b
1828   0F9F FD 77         inc b
1829   0FA1 FA FA FF      lea d, [bp + -6] ; $i
1830   0FA4 FD 43         mov [d], b
1831   0FA6 27            mov b, a
1832   0FA7 0A 1D 0F      jmp _while39_cond
1833   0FAA             _while39_exit:
1834   0FAA             ; while (i > 0) { 
1835   0FAA             _while46_cond:
1836   0FAA FA FA FF      lea d, [bp + -6] ; $i
1837   0FAD 2A            mov b, [d]
1838   0FAE 38 00 00      mov c, 0
1839   0FB1             ; --- START RELATIONAL
1840   0FB1 D7            push a
1841   0FB2 11            mov a, b
1842   0FB3 FD 2E 00 00   mov32 cb, $00000000
1842   0FB7 00 00 
1843   0FB9 B0            cmp a, b
1844   0FBA FD 7F         sgt ; >
1845   0FBC E4            pop a
1846   0FBD             ; --- END RELATIONAL
1847   0FBD C0 00 00      cmp b, 0
1848   0FC0 C6 F2 0F      je _while46_exit
1849   0FC3             _while46_block:
1850   0FC3             ; i--; 
1851   0FC3 FA FA FF      lea d, [bp + -6] ; $i
1852   0FC6 2A            mov b, [d]
1853   0FC7 38 00 00      mov c, 0
1854   0FCA 11            mov a, b
1855   0FCB FD 7D         dec b
1856   0FCD FA FA FF      lea d, [bp + -6] ; $i
1857   0FD0 FD 43         mov [d], b
1858   0FD2 27            mov b, a
1859   0FD3             ; putchar(digits[i]); 
1860   0FD3             ; --- START FUNCTION CALL
1861   0FD3 FA FC FF      lea d, [bp + -4] ; $digits
1862   0FD6 D7            push a
1863   0FD7 DA            push d
1864   0FD8 FA FA FF      lea d, [bp + -6] ; $i
1865   0FDB 2A            mov b, [d]
1866   0FDC 38 00 00      mov c, 0
1867   0FDF E7            pop d
1868   0FE0 5A            add d, b
1869   0FE1 E4            pop a
1870   0FE2 32            mov bl, [d]
1871   0FE3 A7 00         mov bh, 0
1872   0FE5 38 00 00      mov c, 0
1873   0FE8 DD            push bl
1874   0FE9 07 D3 0C      call putchar
1875   0FEC 51 01 00      add sp, 1
1876   0FEF             ; --- END FUNCTION CALL
1877   0FEF 0A AA 0F      jmp _while46_cond
1878   0FF2             _while46_exit:
1879   0FF2 F9            leave
1880   0FF3 09            ret
1881   0FF4             
1882   0FF4             print_unsigned:
1883   0FF4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1884   0FF7             ; char digits[5]; 
1885   0FF7 52 05 00      sub sp, 5
1886   0FFA             ; int i; 
1887   0FFA 52 02 00      sub sp, 2
1888   0FFD             ; i = 0; 
1889   0FFD FA FA FF      lea d, [bp + -6] ; $i
1890   1000 DA            push d
1891   1001 FD 2E 00 00   mov32 cb, $00000000
1891   1005 00 00 
1892   1007 E7            pop d
1893   1008 FD 43         mov [d], b
1894   100A             ; if(num == 0){ 
1895   100A             _if47_cond:
1896   100A FA 05 00      lea d, [bp + 5] ; $num
1897   100D 2A            mov b, [d]
1898   100E 38 00 00      mov c, 0
1899   1011             ; --- START RELATIONAL
1900   1011 D7            push a
1901   1012 11            mov a, b
1902   1013 FD 2E 00 00   mov32 cb, $00000000
1902   1017 00 00 
1903   1019 B0            cmp a, b
1904   101A FD 71         seq ; ==
1905   101C E4            pop a
1906   101D             ; --- END RELATIONAL
1907   101D C0 00 00      cmp b, 0
1908   1020 C6 35 10      je _if47_exit
1909   1023             _if47_TRUE:
1910   1023             ; putchar('0'); 
1911   1023             ; --- START FUNCTION CALL
1912   1023 FD 2E 30 00   mov32 cb, $00000030
1912   1027 00 00 
1913   1029 DD            push bl
1914   102A 07 D3 0C      call putchar
1915   102D 51 01 00      add sp, 1
1916   1030             ; --- END FUNCTION CALL
1917   1030             ; return; 
1918   1030 F9            leave
1919   1031 09            ret
1920   1032 0A 35 10      jmp _if47_exit
1921   1035             _if47_exit:
1922   1035             ; while (num > 0) { 
1923   1035             _while48_cond:
1924   1035 FA 05 00      lea d, [bp + 5] ; $num
1925   1038 2A            mov b, [d]
1926   1039 38 00 00      mov c, 0
1927   103C             ; --- START RELATIONAL
1928   103C D7            push a
1929   103D 11            mov a, b
1930   103E FD 2E 00 00   mov32 cb, $00000000
1930   1042 00 00 
1931   1044 B0            cmp a, b
1932   1045 FD 81         sgu ; > (unsigned)
1933   1047 E4            pop a
1934   1048             ; --- END RELATIONAL
1935   1048 C0 00 00      cmp b, 0
1936   104B C6 C2 10      je _while48_exit
1937   104E             _while48_block:
1938   104E             ; digits[i] = '0' + (num % 10); 
1939   104E FA FC FF      lea d, [bp + -4] ; $digits
1940   1051 D7            push a
1941   1052 DA            push d
1942   1053 FA FA FF      lea d, [bp + -6] ; $i
1943   1056 2A            mov b, [d]
1944   1057 38 00 00      mov c, 0
1945   105A E7            pop d
1946   105B 5A            add d, b
1947   105C E4            pop a
1948   105D DA            push d
1949   105E FD 2E 30 00   mov32 cb, $00000030
1949   1062 00 00 
1950   1064             ; --- START TERMS
1951   1064 D7            push a
1952   1065 11            mov a, b
1953   1066 FA 05 00      lea d, [bp + 5] ; $num
1954   1069 2A            mov b, [d]
1955   106A 38 00 00      mov c, 0
1956   106D             ; --- START FACTORS
1957   106D D7            push a
1958   106E FD D8         push g
1959   1070 11            mov a, b
1960   1071 FD 7A         mov g, c
1961   1073 FD 2E 0A 00   mov32 cb, $0000000a
1961   1077 00 00 
1962   1079 FD D8         push g ; save 'g' as the div instruction uses it
1963   107B AE            div a, b ; %, a: quotient, b: remainder
1964   107C 11            mov a, b
1965   107D FD F1         pop g
1966   107F FD 38         mov c, g
1967   1081 27            mov b, a
1968   1082 FD F1         pop g
1969   1084 E4            pop a
1970   1085             ; --- END FACTORS
1971   1085 56            add b, a
1972   1086 E4            pop a
1973   1087             ; --- END TERMS
1974   1087 E7            pop d
1975   1088 FD 3E         mov [d], bl
1976   108A             ; num = num / 10; 
1977   108A FA 05 00      lea d, [bp + 5] ; $num
1978   108D DA            push d
1979   108E FA 05 00      lea d, [bp + 5] ; $num
1980   1091 2A            mov b, [d]
1981   1092 38 00 00      mov c, 0
1982   1095             ; --- START FACTORS
1983   1095 D7            push a
1984   1096 FD D8         push g
1985   1098 11            mov a, b
1986   1099 FD 7A         mov g, c
1987   109B FD 2E 0A 00   mov32 cb, $0000000a
1987   109F 00 00 
1988   10A1 FD D8         push g ; save 'g' as the div instruction uses it
1989   10A3 AE            div a, b ; /, a: quotient, b: remainder
1990   10A4 FD F1         pop g
1991   10A6 FD 38         mov c, g
1992   10A8 27            mov b, a
1993   10A9 FD F1         pop g
1994   10AB E4            pop a
1995   10AC             ; --- END FACTORS
1996   10AC E7            pop d
1997   10AD FD 43         mov [d], b
1998   10AF             ; i++; 
1999   10AF FA FA FF      lea d, [bp + -6] ; $i
2000   10B2 2A            mov b, [d]
2001   10B3 38 00 00      mov c, 0
2002   10B6 11            mov a, b
2003   10B7 FD 77         inc b
2004   10B9 FA FA FF      lea d, [bp + -6] ; $i
2005   10BC FD 43         mov [d], b
2006   10BE 27            mov b, a
2007   10BF 0A 35 10      jmp _while48_cond
2008   10C2             _while48_exit:
2009   10C2             ; while (i > 0) { 
2010   10C2             _while55_cond:
2011   10C2 FA FA FF      lea d, [bp + -6] ; $i
2012   10C5 2A            mov b, [d]
2013   10C6 38 00 00      mov c, 0
2014   10C9             ; --- START RELATIONAL
2015   10C9 D7            push a
2016   10CA 11            mov a, b
2017   10CB FD 2E 00 00   mov32 cb, $00000000
2017   10CF 00 00 
2018   10D1 B0            cmp a, b
2019   10D2 FD 7F         sgt ; >
2020   10D4 E4            pop a
2021   10D5             ; --- END RELATIONAL
2022   10D5 C0 00 00      cmp b, 0
2023   10D8 C6 0A 11      je _while55_exit
2024   10DB             _while55_block:
2025   10DB             ; i--; 
2026   10DB FA FA FF      lea d, [bp + -6] ; $i
2027   10DE 2A            mov b, [d]
2028   10DF 38 00 00      mov c, 0
2029   10E2 11            mov a, b
2030   10E3 FD 7D         dec b
2031   10E5 FA FA FF      lea d, [bp + -6] ; $i
2032   10E8 FD 43         mov [d], b
2033   10EA 27            mov b, a
2034   10EB             ; putchar(digits[i]); 
2035   10EB             ; --- START FUNCTION CALL
2036   10EB FA FC FF      lea d, [bp + -4] ; $digits
2037   10EE D7            push a
2038   10EF DA            push d
2039   10F0 FA FA FF      lea d, [bp + -6] ; $i
2040   10F3 2A            mov b, [d]
2041   10F4 38 00 00      mov c, 0
2042   10F7 E7            pop d
2043   10F8 5A            add d, b
2044   10F9 E4            pop a
2045   10FA 32            mov bl, [d]
2046   10FB A7 00         mov bh, 0
2047   10FD 38 00 00      mov c, 0
2048   1100 DD            push bl
2049   1101 07 D3 0C      call putchar
2050   1104 51 01 00      add sp, 1
2051   1107             ; --- END FUNCTION CALL
2052   1107 0A C2 10      jmp _while55_cond
2053   110A             _while55_exit:
2054   110A F9            leave
2055   110B 09            ret
2056   110C             
2057   110C             printx16:
2058   110C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2059   110F             ; --- BEGIN INLINE ASM SEGMENT
2060   110F FA 05 00      lea d, [bp + 5] ; $hex
2061   1112 2A            mov b, [d]
2062   1113             print_u16x_printx16:
2063   1113 DD            push bl
2064   1114 30            mov bl, bh
2065   1115 07 32 11      call _itoa_printx16        ; convert bh to char in A
2066   1118 2F            mov bl, al        ; save al
2067   1119 19 00         mov al, 0
2068   111B 05 03         syscall sys_io        ; display AH
2069   111D 24            mov ah, bl        ; retrieve al
2070   111E 19 00         mov al, 0
2071   1120 05 03         syscall sys_io        ; display AL
2072   1122 EA            pop bl
2073   1123 07 32 11      call _itoa_printx16        ; convert bh to char in A
2074   1126 2F            mov bl, al        ; save al
2075   1127 19 00         mov al, 0
2076   1129 05 03         syscall sys_io        ; display AH
2077   112B 24            mov ah, bl        ; retrieve al
2078   112C 19 00         mov al, 0
2079   112E 05 03         syscall sys_io        ; display AL
2080   1130             ; --- END INLINE ASM SEGMENT
2081   1130             ; return; 
2082   1130 F9            leave
2083   1131 09            ret
2084   1132             ; --- BEGIN INLINE ASM SEGMENT
2085   1132             _itoa_printx16:
2086   1132 DA            push d
2087   1133 D8            push b
2088   1134 A7 00         mov bh, 0
2089   1136 FD A4 04      shr bl, 4  
2090   1139 74            mov d, b
2091   113A 1F 4C 11      mov al, [d + s_hex_digits_printx16]
2092   113D 23            mov ah, al
2093   113E E5            pop b
2094   113F D8            push b
2095   1140 A7 00         mov bh, 0
2096   1142 FD 87 0F      and bl, $0F
2097   1145 74            mov d, b
2098   1146 1F 4C 11      mov al, [d + s_hex_digits_printx16]
2099   1149 E5            pop b
2100   114A E7            pop d
2101   114B 09            ret
2102   114C 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
2102   1150 34 35 36 37 
2102   1154 38 39 41 42 
2102   1158 43 44 45 46 
2103   115C             ; --- END INLINE ASM SEGMENT
2104   115C F9            leave
2105   115D 09            ret
2106   115E             
2107   115E             scann:
2108   115E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2109   1161             ; int m; 
2110   1161 52 02 00      sub sp, 2
2111   1164             ; --- BEGIN INLINE ASM SEGMENT
2112   1164 F8 08 00      enter 8
2113   1167 FA F9 FF      lea d, [bp +- 7]
2114   116A 07 B2 11      call _gets_scann
2115   116D 07 A2 11      call _strlen_scann      ; get string length in C
2116   1170 7E            dec c
2117   1171 FD 4E         mov si, d
2118   1173 12            mov a, c
2119   1174 FD 99         shl a
2120   1176 3B 4F 12      mov d, table_power_scann
2121   1179 59            add d, a
2122   117A 38 00 00      mov c, 0
2123   117D             mul_loop_scann:
2124   117D F6            lodsb      ; load ASCII to al
2125   117E B9 00         cmp al, 0
2126   1180 C6 93 11      je mul_exit_scann
2127   1183 6F 30         sub al, $30    ; make into integer
2128   1185 22 00         mov ah, 0
2129   1187 2A            mov b, [d]
2130   1188 AC            mul a, b      ; result in B since it fits in 16bits
2131   1189 11            mov a, b
2132   118A 28            mov b, c
2133   118B 54            add a, b
2134   118C 39            mov c, a
2135   118D 63 02 00      sub d, 2
2136   1190 0A 7D 11      jmp mul_loop_scann
2137   1193             mul_exit_scann:
2138   1193 12            mov a, c
2139   1194 F9            leave
2140   1195 FA FF FF      lea d, [bp + -1] ; $m
2141   1198 43            mov [d], a
2142   1199             ; --- END INLINE ASM SEGMENT
2143   1199             ; return m; 
2144   1199 FA FF FF      lea d, [bp + -1] ; $m
2145   119C 2A            mov b, [d]
2146   119D 38 00 00      mov c, 0
2147   11A0 F9            leave
2148   11A1 09            ret
2149   11A2             ; --- BEGIN INLINE ASM SEGMENT
2150   11A2             _strlen_scann:
2151   11A2 DA            push d
2152   11A3 38 00 00      mov c, 0
2153   11A6             _strlen_L1_scann:
2154   11A6 BD 00         cmp byte [d], 0
2155   11A8 C6 B0 11      je _strlen_ret_scann
2156   11AB 79            inc d
2157   11AC 78            inc c
2158   11AD 0A A6 11      jmp _strlen_L1_scann
2159   11B0             _strlen_ret_scann:
2160   11B0 E7            pop d
2161   11B1 09            ret
2162   11B2             _gets_scann:
2163   11B2 DA            push d
2164   11B3             _gets_loop_scann:
2165   11B3 19 01         mov al, 1
2166   11B5 05 03         syscall sys_io      ; receive in AH
2167   11B7 B9 00         cmp al, 0        ; check error code (AL)
2168   11B9 C6 B3 11      je _gets_loop_scann      ; if no char received, retry
2169   11BC 76 1B         cmp ah, 27
2170   11BE C6 DF 11      je _gets_ansi_esc_scann
2171   11C1 76 0A         cmp ah, $0A        ; LF
2172   11C3 C6 4A 12      je _gets_end_scann
2173   11C6 76 0D         cmp ah, $0D        ; CR
2174   11C8 C6 4A 12      je _gets_end_scann
2175   11CB 76 5C         cmp ah, $5C        ; '\\'
2176   11CD C6 0B 12      je _gets_escape_scann
2177   11D0 76 08         cmp ah, $08      ; check for backspace
2178   11D2 C6 DB 11      je _gets_backspace_scann
2179   11D5 1A            mov al, ah
2180   11D6 3E            mov [d], al
2181   11D7 79            inc d
2182   11D8 0A B3 11      jmp _gets_loop_scann
2183   11DB             _gets_backspace_scann:
2184   11DB 7F            dec d
2185   11DC 0A B3 11      jmp _gets_loop_scann
2186   11DF             _gets_ansi_esc_scann:
2187   11DF 19 01         mov al, 1
2188   11E1 05 03         syscall sys_io        ; receive in AH without echo
2189   11E3 B9 00         cmp al, 0          ; check error code (AL)
2190   11E5 C6 DF 11      je _gets_ansi_esc_scann    ; if no char received, retry
2191   11E8 76 5B         cmp ah, '['
2192   11EA C7 B3 11      jne _gets_loop_scann
2193   11ED             _gets_ansi_esc_2_scann:
2194   11ED 19 01         mov al, 1
2195   11EF 05 03         syscall sys_io          ; receive in AH without echo
2196   11F1 B9 00         cmp al, 0            ; check error code (AL)
2197   11F3 C6 ED 11      je _gets_ansi_esc_2_scann  ; if no char received, retry
2198   11F6 76 44         cmp ah, 'D'
2199   11F8 C6 03 12      je _gets_left_arrow_scann
2200   11FB 76 43         cmp ah, 'C'
2201   11FD C6 07 12      je _gets_right_arrow_scann
2202   1200 0A B3 11      jmp _gets_loop_scann
2203   1203             _gets_left_arrow_scann:
2204   1203 7F            dec d
2205   1204 0A B3 11      jmp _gets_loop_scann
2206   1207             _gets_right_arrow_scann:
2207   1207 79            inc d
2208   1208 0A B3 11      jmp _gets_loop_scann
2209   120B             _gets_escape_scann:
2210   120B 19 01         mov al, 1
2211   120D 05 03         syscall sys_io      ; receive in AH
2212   120F B9 00         cmp al, 0        ; check error code (AL)
2213   1211 C6 0B 12      je _gets_escape_scann      ; if no char received, retry
2214   1214 76 6E         cmp ah, 'n'
2215   1216 C6 35 12      je _gets_LF_scann
2216   1219 76 72         cmp ah, 'r'
2217   121B C6 3C 12      je _gets_CR_scann
2218   121E 76 30         cmp ah, '0'
2219   1220 C6 43 12      je _gets_NULL_scann
2220   1223 76 5C         cmp ah, $5C  
2221   1225 C6 2E 12      je _gets_slash_scann
2222   1228 1A            mov al, ah        ; if not a known escape, it is just a normal letter
2223   1229 3E            mov [d], al
2224   122A 79            inc d
2225   122B 0A B3 11      jmp _gets_loop_scann
2226   122E             _gets_slash_scann:
2227   122E 19 5C         mov al, $5C
2228   1230 3E            mov [d], al
2229   1231 79            inc d
2230   1232 0A B3 11      jmp _gets_loop_scann
2231   1235             _gets_LF_scann:
2232   1235 19 0A         mov al, $0A
2233   1237 3E            mov [d], al
2234   1238 79            inc d
2235   1239 0A B3 11      jmp _gets_loop_scann
2236   123C             _gets_CR_scann:
2237   123C 19 0D         mov al, $0D
2238   123E 3E            mov [d], al
2239   123F 79            inc d
2240   1240 0A B3 11      jmp _gets_loop_scann
2241   1243             _gets_NULL_scann:
2242   1243 19 00         mov al, $00
2243   1245 3E            mov [d], al
2244   1246 79            inc d
2245   1247 0A B3 11      jmp _gets_loop_scann
2246   124A             _gets_end_scann:
2247   124A 19 00         mov al, 0
2248   124C 3E            mov [d], al        ; terminate string
2249   124D E7            pop d
2250   124E 09            ret
2251   124F             table_power_scann:
2252   124F 01 00       .dw 1              ; 1
2253   1251 0A 00       .dw $A             ; 10
2254   1253 64 00       .dw $64            ; 100
2255   1255 E8 03       .dw $3E8           ; 1000
2256   1257 10 27       .dw $2710          ; 10000
2257   1259 A0 86 01 00 .dw $86A0, $1      ; 100000
2258   125D 40 42 0F 00 .dw $4240, $F      ; 1000000
2259   1261 80 96 98 00 .dw $9680, $98     ; 10000000
2260   1265 00 E1 F5 05 .dw $E100, $5F5    ; 100000000
2261   1269 00 CA 9A 3B .dw $CA00, $3B9A   ; 1000000000
2262   126D             ; --- END INLINE ASM SEGMENT
2263   126D F9            leave
2264   126E 09            ret
2265   126F             ; --- END TEXT SEGMENT
2266   126F             
2267   126F             ; --- BEGIN DATA SEGMENT
2268   126F 61 20 6D 61 _s0: .db "a mantissa: ", 0
2268   1273 6E 74 69 73 
2268   1277 73 61 3A 20 
2268   127B 00 
2269   127C 61 20 65 78 _s1: .db "a exponent: ", 0
2269   1280 70 6F 6E 65 
2269   1284 6E 74 3A 20 
2269   1288 00 
2270   1289 62 20 6D 61 _s2: .db "b mantissa: ", 0
2270   128D 6E 74 69 73 
2270   1291 73 61 3A 20 
2270   1295 00 
2271   1296 62 20 65 78 _s3: .db "b exponent: ", 0
2271   129A 70 6F 6E 65 
2271   129E 6E 74 3A 20 
2271   12A2 00 
2272   12A3 53 75 6D 20 _s4: .db "Sum mantissa: %d\n", 0
2272   12A7 6D 61 6E 74 
2272   12AB 69 73 73 61 
2272   12AF 3A 20 25 64 
2272   12B3 0A 00 
2273   12B5 53 75 6D 20 _s5: .db "Sum exponent: %d\n", 0
2273   12B9 65 78 70 6F 
2273   12BD 6E 65 6E 74 
2273   12C1 3A 20 25 64 
2273   12C5 0A 00 
2274   12C7 55 6E 65 78 _s6: .db "Unexpected format in printf.", 0
2274   12CB 70 65 63 74 
2274   12CF 65 64 20 66 
2274   12D3 6F 72 6D 61 
2274   12D7 74 20 69 6E 
2274   12DB 20 70 72 69 
2274   12DF 6E 74 66 2E 
2274   12E3 00 
2275   12E4 45 72 72 6F _s7: .db "Error: Unknown argument type.\n", 0
2275   12E8 72 3A 20 55 
2275   12EC 6E 6B 6E 6F 
2275   12F0 77 6E 20 61 
2275   12F4 72 67 75 6D 
2275   12F8 65 6E 74 20 
2275   12FC 74 79 70 65 
2275   1300 2E 0A 00 
2276   1303             
2277   1303 05 13       _heap_top: .dw _heap
2278   1305 00          _heap: .db 0
2279   1306             ; --- END DATA SEGMENT
2280   1306             
2281   1306             .end
tasm: Number of errors = 0
