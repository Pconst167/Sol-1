0001   0000             ; --- FILENAME: programs/float.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; struct Float16 a, b; 
0011   0408 52 03 00      sub sp, 3
0012   040B 52 03 00      sub sp, 3
0013   040E             ; struct Float16 sum; 
0014   040E 52 03 00      sub sp, 3
0015   0411             ; a.mantissa = 1234; 
0016   0411 FA FE FF      lea d, [bp + -2] ; $a
0017   0414 58 00 00      add d, 0
0018   0417 DA            push d
0019   0418 FD 2E D2 04   mov32 cb, $000004d2
0019   041C 00 00 
0020   041E E7            pop d
0021   041F FD 43         mov [d], b
0022   0421             ; a.exponent = 1; 
0023   0421 FA FE FF      lea d, [bp + -2] ; $a
0024   0424 58 02 00      add d, 2
0025   0427 DA            push d
0026   0428 FD 2E 01 00   mov32 cb, $00000001
0026   042C 00 00 
0027   042E E7            pop d
0028   042F FD 3E         mov [d], bl
0029   0431             ; b.mantissa = 1789; 
0030   0431 FA FB FF      lea d, [bp + -5] ; $b
0031   0434 58 00 00      add d, 0
0032   0437 DA            push d
0033   0438 FD 2E FD 06   mov32 cb, $000006fd
0033   043C 00 00 
0034   043E E7            pop d
0035   043F FD 43         mov [d], b
0036   0441             ; b.exponent = 2; 
0037   0441 FA FB FF      lea d, [bp + -5] ; $b
0038   0444 58 02 00      add d, 2
0039   0447 DA            push d
0040   0448 FD 2E 02 00   mov32 cb, $00000002
0040   044C 00 00 
0041   044E E7            pop d
0042   044F FD 3E         mov [d], bl
0043   0451             ; puts("Starting...\n"); 
0044   0451             ; --- START FUNCTION CALL
0045   0451 26 1B 12      mov b, _s0 ; "Starting...\n"
0046   0454 FD AB         swp b
0047   0456 D8            push b
0048   0457 07 F0 08      call puts
0049   045A 51 02 00      add sp, 2
0050   045D             ; --- END FUNCTION CALL
0051   045D             ; sum = add(a, b); 
0052   045D FA F8 FF      lea d, [bp + -8] ; $sum
0053   0460 DA            push d
0054   0461             ; --- START FUNCTION CALL
0055   0461 FA FB FF      lea d, [bp + -5] ; $b
0056   0464 2D            mov b, d
0057   0465 38 00 00      mov c, 0
0058   0468 52 03 00      sub sp, 3
0059   046B FD 28         mov si, b
0060   046D FD FA 01 00   lea d, [sp + 1]
0061   0471 FD 50         mov di, d
0062   0473 38 03 00      mov c, 3
0063   0476 FD F5         rep movsb
0064   0478 FA FE FF      lea d, [bp + -2] ; $a
0065   047B 2D            mov b, d
0066   047C 38 00 00      mov c, 0
0067   047F 52 03 00      sub sp, 3
0068   0482 FD 28         mov si, b
0069   0484 FD FA 01 00   lea d, [sp + 1]
0070   0488 FD 50         mov di, d
0071   048A 38 03 00      mov c, 3
0072   048D FD F5         rep movsb
0073   048F 07 DA 04      call add
0074   0492 51 06 00      add sp, 6
0075   0495             ; --- END FUNCTION CALL
0076   0495 E7            pop d
0077   0496 FD 28         mov si, b
0078   0498 FD 50         mov di, d
0079   049A 38 03 00      mov c, 3
0080   049D FD F5         rep movsb
0081   049F             ; printf("Sum mantissa: %d\n", sum.mantissa); 
0082   049F             ; --- START FUNCTION CALL
0083   049F FA F8 FF      lea d, [bp + -8] ; $sum
0084   04A2 58 00 00      add d, 0
0085   04A5 2A            mov b, [d]
0086   04A6 38 00 00      mov c, 0
0087   04A9 FD AB         swp b
0088   04AB D8            push b
0089   04AC 26 28 12      mov b, _s1 ; "Sum mantissa: %d\n"
0090   04AF FD AB         swp b
0091   04B1 D8            push b
0092   04B2 07 0E 09      call printf
0093   04B5 51 04 00      add sp, 4
0094   04B8             ; --- END FUNCTION CALL
0095   04B8             ; printf("Sum exponent: %d\n", sum.exponent); 
0096   04B8             ; --- START FUNCTION CALL
0097   04B8 FA F8 FF      lea d, [bp + -8] ; $sum
0098   04BB 58 02 00      add d, 2
0099   04BE 32            mov bl, [d]
0100   04BF A7 00         mov bh, 0
0101   04C1 38 00 00      mov c, 0
0102   04C4 DD            push bl
0103   04C5 26 3A 12      mov b, _s2 ; "Sum exponent: %d\n"
0104   04C8 FD AB         swp b
0105   04CA D8            push b
0106   04CB 07 0E 09      call printf
0107   04CE 51 03 00      add sp, 3
0108   04D1             ; --- END FUNCTION CALL
0109   04D1             ; return 0; 
0110   04D1 FD 2E 00 00   mov32 cb, $00000000
0110   04D5 00 00 
0111   04D7 F9            leave
0112   04D8 05 0B         syscall sys_terminate_proc
0113   04DA             
0114   04DA             add:
0115   04DA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0116   04DD             ; if (a.exponent < b.exponent) { 
0117   04DD             _if1_cond:
0118   04DD FA 05 00      lea d, [bp + 5] ; $a
0119   04E0 58 02 00      add d, 2
0120   04E3 32            mov bl, [d]
0121   04E4 A7 00         mov bh, 0
0122   04E6 38 00 00      mov c, 0
0123   04E9             ; --- START RELATIONAL
0124   04E9 D7            push a
0125   04EA 11            mov a, b
0126   04EB FA 08 00      lea d, [bp + 8] ; $b
0127   04EE 58 02 00      add d, 2
0128   04F1 32            mov bl, [d]
0129   04F2 A7 00         mov bh, 0
0130   04F4 38 00 00      mov c, 0
0131   04F7 B0            cmp a, b
0132   04F8 FD 73         slt ; < (signed)
0133   04FA E4            pop a
0134   04FB             ; --- END RELATIONAL
0135   04FB C0 00 00      cmp b, 0
0136   04FE C6 8F 05      je _if1_else
0137   0501             _if1_TRUE:
0138   0501             ; while (a.exponent < b.exponent) { 
0139   0501             _while2_cond:
0140   0501 FA 05 00      lea d, [bp + 5] ; $a
0141   0504 58 02 00      add d, 2
0142   0507 32            mov bl, [d]
0143   0508 A7 00         mov bh, 0
0144   050A 38 00 00      mov c, 0
0145   050D             ; --- START RELATIONAL
0146   050D D7            push a
0147   050E 11            mov a, b
0148   050F FA 08 00      lea d, [bp + 8] ; $b
0149   0512 58 02 00      add d, 2
0150   0515 32            mov bl, [d]
0151   0516 A7 00         mov bh, 0
0152   0518 38 00 00      mov c, 0
0153   051B B0            cmp a, b
0154   051C FD 73         slt ; < (signed)
0155   051E E4            pop a
0156   051F             ; --- END RELATIONAL
0157   051F C0 00 00      cmp b, 0
0158   0522 C6 8C 05      je _while2_exit
0159   0525             _while2_block:
0160   0525             ; a.mantissa = a.mantissa / 2; 
0161   0525 FA 05 00      lea d, [bp + 5] ; $a
0162   0528 58 00 00      add d, 0
0163   052B DA            push d
0164   052C FA 05 00      lea d, [bp + 5] ; $a
0165   052F 58 00 00      add d, 0
0166   0532 2A            mov b, [d]
0167   0533 38 00 00      mov c, 0
0168   0536             ; --- START FACTORS
0169   0536 D7            push a
0170   0537 FD D8         push g
0171   0539 11            mov a, b
0172   053A FD 7A         mov g, c
0173   053C FD 2E 02 00   mov32 cb, $00000002
0173   0540 00 00 
0174   0542 FD D8         push g ; save 'g' as the div instruction uses it
0175   0544 AE            div a, b ; /, a: quotient, b: remainder
0176   0545 FD F1         pop g
0177   0547 FD 38         mov c, g
0178   0549 27            mov b, a
0179   054A FD F1         pop g
0180   054C E4            pop a
0181   054D             ; --- END FACTORS
0182   054D E7            pop d
0183   054E FD 43         mov [d], b
0184   0550             ; a.exponent = a.exponent + 1; 
0185   0550 FA 05 00      lea d, [bp + 5] ; $a
0186   0553 58 02 00      add d, 2
0187   0556 DA            push d
0188   0557 FA 05 00      lea d, [bp + 5] ; $a
0189   055A 58 02 00      add d, 2
0190   055D 32            mov bl, [d]
0191   055E A7 00         mov bh, 0
0192   0560 38 00 00      mov c, 0
0193   0563             ; --- START TERMS
0194   0563 D7            push a
0195   0564 11            mov a, b
0196   0565 FD 2E 01 00   mov32 cb, $00000001
0196   0569 00 00 
0197   056B 56            add b, a
0198   056C E4            pop a
0199   056D             ; --- END TERMS
0200   056D E7            pop d
0201   056E FD 3E         mov [d], bl
0202   0570             ; printf("%d\n", a.exponent); 
0203   0570             ; --- START FUNCTION CALL
0204   0570 FA 05 00      lea d, [bp + 5] ; $a
0205   0573 58 02 00      add d, 2
0206   0576 32            mov bl, [d]
0207   0577 A7 00         mov bh, 0
0208   0579 38 00 00      mov c, 0
0209   057C DD            push bl
0210   057D 26 4C 12      mov b, _s3 ; "%d\n"
0211   0580 FD AB         swp b
0212   0582 D8            push b
0213   0583 07 0E 09      call printf
0214   0586 51 03 00      add sp, 3
0215   0589             ; --- END FUNCTION CALL
0216   0589 0A 01 05      jmp _while2_cond
0217   058C             _while2_exit:
0218   058C 0A 28 06      jmp _if1_exit
0219   058F             _if1_else:
0220   058F             ; if (b.exponent < a.exponent) { 
0221   058F             _if5_cond:
0222   058F FA 08 00      lea d, [bp + 8] ; $b
0223   0592 58 02 00      add d, 2
0224   0595 32            mov bl, [d]
0225   0596 A7 00         mov bh, 0
0226   0598 38 00 00      mov c, 0
0227   059B             ; --- START RELATIONAL
0228   059B D7            push a
0229   059C 11            mov a, b
0230   059D FA 05 00      lea d, [bp + 5] ; $a
0231   05A0 58 02 00      add d, 2
0232   05A3 32            mov bl, [d]
0233   05A4 A7 00         mov bh, 0
0234   05A6 38 00 00      mov c, 0
0235   05A9 B0            cmp a, b
0236   05AA FD 73         slt ; < (signed)
0237   05AC E4            pop a
0238   05AD             ; --- END RELATIONAL
0239   05AD C0 00 00      cmp b, 0
0240   05B0 C6 28 06      je _if5_exit
0241   05B3             _if5_TRUE:
0242   05B3             ; while (b.exponent < a.exponent) { 
0243   05B3             _while6_cond:
0244   05B3 FA 08 00      lea d, [bp + 8] ; $b
0245   05B6 58 02 00      add d, 2
0246   05B9 32            mov bl, [d]
0247   05BA A7 00         mov bh, 0
0248   05BC 38 00 00      mov c, 0
0249   05BF             ; --- START RELATIONAL
0250   05BF D7            push a
0251   05C0 11            mov a, b
0252   05C1 FA 05 00      lea d, [bp + 5] ; $a
0253   05C4 58 02 00      add d, 2
0254   05C7 32            mov bl, [d]
0255   05C8 A7 00         mov bh, 0
0256   05CA 38 00 00      mov c, 0
0257   05CD B0            cmp a, b
0258   05CE FD 73         slt ; < (signed)
0259   05D0 E4            pop a
0260   05D1             ; --- END RELATIONAL
0261   05D1 C0 00 00      cmp b, 0
0262   05D4 C6 25 06      je _while6_exit
0263   05D7             _while6_block:
0264   05D7             ; b.mantissa = b.mantissa / 2; 
0265   05D7 FA 08 00      lea d, [bp + 8] ; $b
0266   05DA 58 00 00      add d, 0
0267   05DD DA            push d
0268   05DE FA 08 00      lea d, [bp + 8] ; $b
0269   05E1 58 00 00      add d, 0
0270   05E4 2A            mov b, [d]
0271   05E5 38 00 00      mov c, 0
0272   05E8             ; --- START FACTORS
0273   05E8 D7            push a
0274   05E9 FD D8         push g
0275   05EB 11            mov a, b
0276   05EC FD 7A         mov g, c
0277   05EE FD 2E 02 00   mov32 cb, $00000002
0277   05F2 00 00 
0278   05F4 FD D8         push g ; save 'g' as the div instruction uses it
0279   05F6 AE            div a, b ; /, a: quotient, b: remainder
0280   05F7 FD F1         pop g
0281   05F9 FD 38         mov c, g
0282   05FB 27            mov b, a
0283   05FC FD F1         pop g
0284   05FE E4            pop a
0285   05FF             ; --- END FACTORS
0286   05FF E7            pop d
0287   0600 FD 43         mov [d], b
0288   0602             ; b.exponent = b.exponent + 1; 
0289   0602 FA 08 00      lea d, [bp + 8] ; $b
0290   0605 58 02 00      add d, 2
0291   0608 DA            push d
0292   0609 FA 08 00      lea d, [bp + 8] ; $b
0293   060C 58 02 00      add d, 2
0294   060F 32            mov bl, [d]
0295   0610 A7 00         mov bh, 0
0296   0612 38 00 00      mov c, 0
0297   0615             ; --- START TERMS
0298   0615 D7            push a
0299   0616 11            mov a, b
0300   0617 FD 2E 01 00   mov32 cb, $00000001
0300   061B 00 00 
0301   061D 56            add b, a
0302   061E E4            pop a
0303   061F             ; --- END TERMS
0304   061F E7            pop d
0305   0620 FD 3E         mov [d], bl
0306   0622 0A B3 05      jmp _while6_cond
0307   0625             _while6_exit:
0308   0625 0A 28 06      jmp _if5_exit
0309   0628             _if5_exit:
0310   0628             _if1_exit:
0311   0628             ; struct Float16 result; 
0312   0628 52 03 00      sub sp, 3
0313   062B             ; result.mantissa = a.mantissa + b.mantissa; 
0314   062B FA FE FF      lea d, [bp + -2] ; $result
0315   062E 58 00 00      add d, 0
0316   0631 DA            push d
0317   0632 FA 05 00      lea d, [bp + 5] ; $a
0318   0635 58 00 00      add d, 0
0319   0638 2A            mov b, [d]
0320   0639 38 00 00      mov c, 0
0321   063C             ; --- START TERMS
0322   063C D7            push a
0323   063D 11            mov a, b
0324   063E FA 08 00      lea d, [bp + 8] ; $b
0325   0641 58 00 00      add d, 0
0326   0644 2A            mov b, [d]
0327   0645 38 00 00      mov c, 0
0328   0648 56            add b, a
0329   0649 E4            pop a
0330   064A             ; --- END TERMS
0331   064A E7            pop d
0332   064B FD 43         mov [d], b
0333   064D             ; result.exponent = a.exponent; 
0334   064D FA FE FF      lea d, [bp + -2] ; $result
0335   0650 58 02 00      add d, 2
0336   0653 DA            push d
0337   0654 FA 05 00      lea d, [bp + 5] ; $a
0338   0657 58 02 00      add d, 2
0339   065A 32            mov bl, [d]
0340   065B A7 00         mov bh, 0
0341   065D 38 00 00      mov c, 0
0342   0660 E7            pop d
0343   0661 FD 3E         mov [d], bl
0344   0663             ; while (result.mantissa > 32767 || result.mantissa < -32767) { 
0345   0663             _while9_cond:
0346   0663 FA FE FF      lea d, [bp + -2] ; $result
0347   0666 58 00 00      add d, 0
0348   0669 2A            mov b, [d]
0349   066A 38 00 00      mov c, 0
0350   066D             ; --- START RELATIONAL
0351   066D D7            push a
0352   066E 11            mov a, b
0353   066F FD 2E FF 7F   mov32 cb, $00007fff
0353   0673 00 00 
0354   0675 B0            cmp a, b
0355   0676 FD 7F         sgt ; >
0356   0678 E4            pop a
0357   0679             ; --- END RELATIONAL
0358   0679             ; --- START LOGICAL OR
0359   0679 D7            push a
0360   067A 11            mov a, b
0361   067B FA FE FF      lea d, [bp + -2] ; $result
0362   067E 58 00 00      add d, 0
0363   0681 2A            mov b, [d]
0364   0682 38 00 00      mov c, 0
0365   0685             ; --- START RELATIONAL
0366   0685 D7            push a
0367   0686 11            mov a, b
0368   0687 FD 2E 01 80   mov32 cb, $ffff8001
0368   068B FF FF 
0369   068D B0            cmp a, b
0370   068E FD 73         slt ; < (signed)
0371   0690 E4            pop a
0372   0691             ; --- END RELATIONAL
0373   0691 FD A8         sor a, b ; ||
0374   0693 E4            pop a
0375   0694             ; --- END LOGICAL OR
0376   0694 C0 00 00      cmp b, 0
0377   0697 C6 E8 06      je _while9_exit
0378   069A             _while9_block:
0379   069A             ; result.mantissa = result.mantissa / 2; 
0380   069A FA FE FF      lea d, [bp + -2] ; $result
0381   069D 58 00 00      add d, 0
0382   06A0 DA            push d
0383   06A1 FA FE FF      lea d, [bp + -2] ; $result
0384   06A4 58 00 00      add d, 0
0385   06A7 2A            mov b, [d]
0386   06A8 38 00 00      mov c, 0
0387   06AB             ; --- START FACTORS
0388   06AB D7            push a
0389   06AC FD D8         push g
0390   06AE 11            mov a, b
0391   06AF FD 7A         mov g, c
0392   06B1 FD 2E 02 00   mov32 cb, $00000002
0392   06B5 00 00 
0393   06B7 FD D8         push g ; save 'g' as the div instruction uses it
0394   06B9 AE            div a, b ; /, a: quotient, b: remainder
0395   06BA FD F1         pop g
0396   06BC FD 38         mov c, g
0397   06BE 27            mov b, a
0398   06BF FD F1         pop g
0399   06C1 E4            pop a
0400   06C2             ; --- END FACTORS
0401   06C2 E7            pop d
0402   06C3 FD 43         mov [d], b
0403   06C5             ; result.exponent = result.exponent + 1; 
0404   06C5 FA FE FF      lea d, [bp + -2] ; $result
0405   06C8 58 02 00      add d, 2
0406   06CB DA            push d
0407   06CC FA FE FF      lea d, [bp + -2] ; $result
0408   06CF 58 02 00      add d, 2
0409   06D2 32            mov bl, [d]
0410   06D3 A7 00         mov bh, 0
0411   06D5 38 00 00      mov c, 0
0412   06D8             ; --- START TERMS
0413   06D8 D7            push a
0414   06D9 11            mov a, b
0415   06DA FD 2E 01 00   mov32 cb, $00000001
0415   06DE 00 00 
0416   06E0 56            add b, a
0417   06E1 E4            pop a
0418   06E2             ; --- END TERMS
0419   06E2 E7            pop d
0420   06E3 FD 3E         mov [d], bl
0421   06E5 0A 63 06      jmp _while9_cond
0422   06E8             _while9_exit:
0423   06E8             ; return result; 
0424   06E8 FA FE FF      lea d, [bp + -2] ; $result
0425   06EB 2D            mov b, d
0426   06EC 38 00 00      mov c, 0
0427   06EF F9            leave
0428   06F0 09            ret
0429   06F1             
0430   06F1             subtract:
0431   06F1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0432   06F4             ; if (a.exponent < b.exponent) { 
0433   06F4             _if12_cond:
0434   06F4 FA 05 00      lea d, [bp + 5] ; $a
0435   06F7 58 02 00      add d, 2
0436   06FA 32            mov bl, [d]
0437   06FB A7 00         mov bh, 0
0438   06FD 38 00 00      mov c, 0
0439   0700             ; --- START RELATIONAL
0440   0700 D7            push a
0441   0701 11            mov a, b
0442   0702 FA 08 00      lea d, [bp + 8] ; $b
0443   0705 58 02 00      add d, 2
0444   0708 32            mov bl, [d]
0445   0709 A7 00         mov bh, 0
0446   070B 38 00 00      mov c, 0
0447   070E B0            cmp a, b
0448   070F FD 73         slt ; < (signed)
0449   0711 E4            pop a
0450   0712             ; --- END RELATIONAL
0451   0712 C0 00 00      cmp b, 0
0452   0715 C6 8D 07      je _if12_else
0453   0718             _if12_TRUE:
0454   0718             ; while (a.exponent < b.exponent) { 
0455   0718             _while13_cond:
0456   0718 FA 05 00      lea d, [bp + 5] ; $a
0457   071B 58 02 00      add d, 2
0458   071E 32            mov bl, [d]
0459   071F A7 00         mov bh, 0
0460   0721 38 00 00      mov c, 0
0461   0724             ; --- START RELATIONAL
0462   0724 D7            push a
0463   0725 11            mov a, b
0464   0726 FA 08 00      lea d, [bp + 8] ; $b
0465   0729 58 02 00      add d, 2
0466   072C 32            mov bl, [d]
0467   072D A7 00         mov bh, 0
0468   072F 38 00 00      mov c, 0
0469   0732 B0            cmp a, b
0470   0733 FD 73         slt ; < (signed)
0471   0735 E4            pop a
0472   0736             ; --- END RELATIONAL
0473   0736 C0 00 00      cmp b, 0
0474   0739 C6 8A 07      je _while13_exit
0475   073C             _while13_block:
0476   073C             ; a.mantissa = a.mantissa / 2; 
0477   073C FA 05 00      lea d, [bp + 5] ; $a
0478   073F 58 00 00      add d, 0
0479   0742 DA            push d
0480   0743 FA 05 00      lea d, [bp + 5] ; $a
0481   0746 58 00 00      add d, 0
0482   0749 2A            mov b, [d]
0483   074A 38 00 00      mov c, 0
0484   074D             ; --- START FACTORS
0485   074D D7            push a
0486   074E FD D8         push g
0487   0750 11            mov a, b
0488   0751 FD 7A         mov g, c
0489   0753 FD 2E 02 00   mov32 cb, $00000002
0489   0757 00 00 
0490   0759 FD D8         push g ; save 'g' as the div instruction uses it
0491   075B AE            div a, b ; /, a: quotient, b: remainder
0492   075C FD F1         pop g
0493   075E FD 38         mov c, g
0494   0760 27            mov b, a
0495   0761 FD F1         pop g
0496   0763 E4            pop a
0497   0764             ; --- END FACTORS
0498   0764 E7            pop d
0499   0765 FD 43         mov [d], b
0500   0767             ; a.exponent = a.exponent + 1; 
0501   0767 FA 05 00      lea d, [bp + 5] ; $a
0502   076A 58 02 00      add d, 2
0503   076D DA            push d
0504   076E FA 05 00      lea d, [bp + 5] ; $a
0505   0771 58 02 00      add d, 2
0506   0774 32            mov bl, [d]
0507   0775 A7 00         mov bh, 0
0508   0777 38 00 00      mov c, 0
0509   077A             ; --- START TERMS
0510   077A D7            push a
0511   077B 11            mov a, b
0512   077C FD 2E 01 00   mov32 cb, $00000001
0512   0780 00 00 
0513   0782 56            add b, a
0514   0783 E4            pop a
0515   0784             ; --- END TERMS
0516   0784 E7            pop d
0517   0785 FD 3E         mov [d], bl
0518   0787 0A 18 07      jmp _while13_cond
0519   078A             _while13_exit:
0520   078A 0A 26 08      jmp _if12_exit
0521   078D             _if12_else:
0522   078D             ; if (b.exponent < a.exponent) { 
0523   078D             _if16_cond:
0524   078D FA 08 00      lea d, [bp + 8] ; $b
0525   0790 58 02 00      add d, 2
0526   0793 32            mov bl, [d]
0527   0794 A7 00         mov bh, 0
0528   0796 38 00 00      mov c, 0
0529   0799             ; --- START RELATIONAL
0530   0799 D7            push a
0531   079A 11            mov a, b
0532   079B FA 05 00      lea d, [bp + 5] ; $a
0533   079E 58 02 00      add d, 2
0534   07A1 32            mov bl, [d]
0535   07A2 A7 00         mov bh, 0
0536   07A4 38 00 00      mov c, 0
0537   07A7 B0            cmp a, b
0538   07A8 FD 73         slt ; < (signed)
0539   07AA E4            pop a
0540   07AB             ; --- END RELATIONAL
0541   07AB C0 00 00      cmp b, 0
0542   07AE C6 26 08      je _if16_exit
0543   07B1             _if16_TRUE:
0544   07B1             ; while (b.exponent < a.exponent) { 
0545   07B1             _while17_cond:
0546   07B1 FA 08 00      lea d, [bp + 8] ; $b
0547   07B4 58 02 00      add d, 2
0548   07B7 32            mov bl, [d]
0549   07B8 A7 00         mov bh, 0
0550   07BA 38 00 00      mov c, 0
0551   07BD             ; --- START RELATIONAL
0552   07BD D7            push a
0553   07BE 11            mov a, b
0554   07BF FA 05 00      lea d, [bp + 5] ; $a
0555   07C2 58 02 00      add d, 2
0556   07C5 32            mov bl, [d]
0557   07C6 A7 00         mov bh, 0
0558   07C8 38 00 00      mov c, 0
0559   07CB B0            cmp a, b
0560   07CC FD 73         slt ; < (signed)
0561   07CE E4            pop a
0562   07CF             ; --- END RELATIONAL
0563   07CF C0 00 00      cmp b, 0
0564   07D2 C6 23 08      je _while17_exit
0565   07D5             _while17_block:
0566   07D5             ; b.mantissa = b.mantissa / 2; 
0567   07D5 FA 08 00      lea d, [bp + 8] ; $b
0568   07D8 58 00 00      add d, 0
0569   07DB DA            push d
0570   07DC FA 08 00      lea d, [bp + 8] ; $b
0571   07DF 58 00 00      add d, 0
0572   07E2 2A            mov b, [d]
0573   07E3 38 00 00      mov c, 0
0574   07E6             ; --- START FACTORS
0575   07E6 D7            push a
0576   07E7 FD D8         push g
0577   07E9 11            mov a, b
0578   07EA FD 7A         mov g, c
0579   07EC FD 2E 02 00   mov32 cb, $00000002
0579   07F0 00 00 
0580   07F2 FD D8         push g ; save 'g' as the div instruction uses it
0581   07F4 AE            div a, b ; /, a: quotient, b: remainder
0582   07F5 FD F1         pop g
0583   07F7 FD 38         mov c, g
0584   07F9 27            mov b, a
0585   07FA FD F1         pop g
0586   07FC E4            pop a
0587   07FD             ; --- END FACTORS
0588   07FD E7            pop d
0589   07FE FD 43         mov [d], b
0590   0800             ; b.exponent = b.exponent + 1; 
0591   0800 FA 08 00      lea d, [bp + 8] ; $b
0592   0803 58 02 00      add d, 2
0593   0806 DA            push d
0594   0807 FA 08 00      lea d, [bp + 8] ; $b
0595   080A 58 02 00      add d, 2
0596   080D 32            mov bl, [d]
0597   080E A7 00         mov bh, 0
0598   0810 38 00 00      mov c, 0
0599   0813             ; --- START TERMS
0600   0813 D7            push a
0601   0814 11            mov a, b
0602   0815 FD 2E 01 00   mov32 cb, $00000001
0602   0819 00 00 
0603   081B 56            add b, a
0604   081C E4            pop a
0605   081D             ; --- END TERMS
0606   081D E7            pop d
0607   081E FD 3E         mov [d], bl
0608   0820 0A B1 07      jmp _while17_cond
0609   0823             _while17_exit:
0610   0823 0A 26 08      jmp _if16_exit
0611   0826             _if16_exit:
0612   0826             _if12_exit:
0613   0826             ; struct Float16 result; 
0614   0826 52 03 00      sub sp, 3
0615   0829             ; result.mantissa = a.mantissa - b.mantissa; 
0616   0829 FA FE FF      lea d, [bp + -2] ; $result
0617   082C 58 00 00      add d, 0
0618   082F DA            push d
0619   0830 FA 05 00      lea d, [bp + 5] ; $a
0620   0833 58 00 00      add d, 0
0621   0836 2A            mov b, [d]
0622   0837 38 00 00      mov c, 0
0623   083A             ; --- START TERMS
0624   083A D7            push a
0625   083B 11            mov a, b
0626   083C FA 08 00      lea d, [bp + 8] ; $b
0627   083F 58 00 00      add d, 0
0628   0842 2A            mov b, [d]
0629   0843 38 00 00      mov c, 0
0630   0846 60            sub a, b
0631   0847 27            mov b, a
0632   0848 E4            pop a
0633   0849             ; --- END TERMS
0634   0849 E7            pop d
0635   084A FD 43         mov [d], b
0636   084C             ; result.exponent = a.exponent; 
0637   084C FA FE FF      lea d, [bp + -2] ; $result
0638   084F 58 02 00      add d, 2
0639   0852 DA            push d
0640   0853 FA 05 00      lea d, [bp + 5] ; $a
0641   0856 58 02 00      add d, 2
0642   0859 32            mov bl, [d]
0643   085A A7 00         mov bh, 0
0644   085C 38 00 00      mov c, 0
0645   085F E7            pop d
0646   0860 FD 3E         mov [d], bl
0647   0862             ; while (result.mantissa > 32767 || result.mantissa < -32767) { 
0648   0862             _while20_cond:
0649   0862 FA FE FF      lea d, [bp + -2] ; $result
0650   0865 58 00 00      add d, 0
0651   0868 2A            mov b, [d]
0652   0869 38 00 00      mov c, 0
0653   086C             ; --- START RELATIONAL
0654   086C D7            push a
0655   086D 11            mov a, b
0656   086E FD 2E FF 7F   mov32 cb, $00007fff
0656   0872 00 00 
0657   0874 B0            cmp a, b
0658   0875 FD 7F         sgt ; >
0659   0877 E4            pop a
0660   0878             ; --- END RELATIONAL
0661   0878             ; --- START LOGICAL OR
0662   0878 D7            push a
0663   0879 11            mov a, b
0664   087A FA FE FF      lea d, [bp + -2] ; $result
0665   087D 58 00 00      add d, 0
0666   0880 2A            mov b, [d]
0667   0881 38 00 00      mov c, 0
0668   0884             ; --- START RELATIONAL
0669   0884 D7            push a
0670   0885 11            mov a, b
0671   0886 FD 2E 01 80   mov32 cb, $ffff8001
0671   088A FF FF 
0672   088C B0            cmp a, b
0673   088D FD 73         slt ; < (signed)
0674   088F E4            pop a
0675   0890             ; --- END RELATIONAL
0676   0890 FD A8         sor a, b ; ||
0677   0892 E4            pop a
0678   0893             ; --- END LOGICAL OR
0679   0893 C0 00 00      cmp b, 0
0680   0896 C6 E7 08      je _while20_exit
0681   0899             _while20_block:
0682   0899             ; result.mantissa = result.mantissa / 2; 
0683   0899 FA FE FF      lea d, [bp + -2] ; $result
0684   089C 58 00 00      add d, 0
0685   089F DA            push d
0686   08A0 FA FE FF      lea d, [bp + -2] ; $result
0687   08A3 58 00 00      add d, 0
0688   08A6 2A            mov b, [d]
0689   08A7 38 00 00      mov c, 0
0690   08AA             ; --- START FACTORS
0691   08AA D7            push a
0692   08AB FD D8         push g
0693   08AD 11            mov a, b
0694   08AE FD 7A         mov g, c
0695   08B0 FD 2E 02 00   mov32 cb, $00000002
0695   08B4 00 00 
0696   08B6 FD D8         push g ; save 'g' as the div instruction uses it
0697   08B8 AE            div a, b ; /, a: quotient, b: remainder
0698   08B9 FD F1         pop g
0699   08BB FD 38         mov c, g
0700   08BD 27            mov b, a
0701   08BE FD F1         pop g
0702   08C0 E4            pop a
0703   08C1             ; --- END FACTORS
0704   08C1 E7            pop d
0705   08C2 FD 43         mov [d], b
0706   08C4             ; result.exponent = result.exponent + 1; 
0707   08C4 FA FE FF      lea d, [bp + -2] ; $result
0708   08C7 58 02 00      add d, 2
0709   08CA DA            push d
0710   08CB FA FE FF      lea d, [bp + -2] ; $result
0711   08CE 58 02 00      add d, 2
0712   08D1 32            mov bl, [d]
0713   08D2 A7 00         mov bh, 0
0714   08D4 38 00 00      mov c, 0
0715   08D7             ; --- START TERMS
0716   08D7 D7            push a
0717   08D8 11            mov a, b
0718   08D9 FD 2E 01 00   mov32 cb, $00000001
0718   08DD 00 00 
0719   08DF 56            add b, a
0720   08E0 E4            pop a
0721   08E1             ; --- END TERMS
0722   08E1 E7            pop d
0723   08E2 FD 3E         mov [d], bl
0724   08E4 0A 62 08      jmp _while20_cond
0725   08E7             _while20_exit:
0726   08E7             ; return result; 
0727   08E7 FA FE FF      lea d, [bp + -2] ; $result
0728   08EA 2D            mov b, d
0729   08EB 38 00 00      mov c, 0
0730   08EE F9            leave
0731   08EF 09            ret
0732   08F0             
0733   08F0             puts:
0734   08F0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0735   08F3             ; --- BEGIN INLINE ASM SEGMENT
0736   08F3 FA 05 00      lea d, [bp + 5] ; $s
0737   08F6 FD 2A         mov d, [d]
0738   08F8             _puts_L1_puts:
0739   08F8 1E            mov al, [d]
0740   08F9 B9 00         cmp al, 0
0741   08FB C6 07 09      jz _puts_END_puts
0742   08FE 23            mov ah, al
0743   08FF 19 00         mov al, 0
0744   0901 05 03         syscall sys_io
0745   0903 79            inc d
0746   0904 0A F8 08      jmp _puts_L1_puts
0747   0907             _puts_END_puts:
0748   0907 10 00 0A      mov a, $0A00
0749   090A 05 03         syscall sys_io
0750   090C             ; --- END INLINE ASM SEGMENT
0751   090C F9            leave
0752   090D 09            ret
0753   090E             
0754   090E             printf:
0755   090E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0756   0911             ; char *p, *format_p; 
0757   0911 52 02 00      sub sp, 2
0758   0914 52 02 00      sub sp, 2
0759   0917             ; format_p = format; 
0760   0917 FA FD FF      lea d, [bp + -3] ; $format_p
0761   091A DA            push d
0762   091B FA 05 00      lea d, [bp + 5] ; $format
0763   091E 2A            mov b, [d]
0764   091F 38 00 00      mov c, 0
0765   0922 E7            pop d
0766   0923 FD 43         mov [d], b
0767   0925             ; p = &format + 2; 
0768   0925 FA FF FF      lea d, [bp + -1] ; $p
0769   0928 DA            push d
0770   0929 FA 05 00      lea d, [bp + 5] ; $format
0771   092C 2D            mov b, d
0772   092D             ; --- START TERMS
0773   092D D7            push a
0774   092E 11            mov a, b
0775   092F FD 2E 02 00   mov32 cb, $00000002
0775   0933 00 00 
0776   0935 56            add b, a
0777   0936 E4            pop a
0778   0937             ; --- END TERMS
0779   0937 E7            pop d
0780   0938 FD 43         mov [d], b
0781   093A             ; for(;;){ 
0782   093A             _for23_init:
0783   093A             _for23_cond:
0784   093A             _for23_block:
0785   093A             ; if(!*format_p) break; 
0786   093A             _if24_cond:
0787   093A FA FD FF      lea d, [bp + -3] ; $format_p
0788   093D 2A            mov b, [d]
0789   093E 38 00 00      mov c, 0
0790   0941 74            mov d, b
0791   0942 32            mov bl, [d]
0792   0943 A7 00         mov bh, 0
0793   0945 38 00 00      mov c, 0
0794   0948 C0 00 00      cmp b, 0
0795   094B FD 71         seq ; !
0796   094D C0 00 00      cmp b, 0
0797   0950 C6 59 09      je _if24_else
0798   0953             _if24_TRUE:
0799   0953             ; break; 
0800   0953 0A 09 0C      jmp _for23_exit ; for break
0801   0956 0A 06 0C      jmp _if24_exit
0802   0959             _if24_else:
0803   0959             ; if(*format_p == '%'){ 
0804   0959             _if25_cond:
0805   0959 FA FD FF      lea d, [bp + -3] ; $format_p
0806   095C 2A            mov b, [d]
0807   095D 38 00 00      mov c, 0
0808   0960 74            mov d, b
0809   0961 32            mov bl, [d]
0810   0962 A7 00         mov bh, 0
0811   0964 38 00 00      mov c, 0
0812   0967             ; --- START RELATIONAL
0813   0967 D7            push a
0814   0968 11            mov a, b
0815   0969 FD 2E 25 00   mov32 cb, $00000025
0815   096D 00 00 
0816   096F B0            cmp a, b
0817   0970 FD 71         seq ; ==
0818   0972 E4            pop a
0819   0973             ; --- END RELATIONAL
0820   0973 C0 00 00      cmp b, 0
0821   0976 C6 E1 0B      je _if25_else
0822   0979             _if25_TRUE:
0823   0979             ; format_p++; 
0824   0979 FA FD FF      lea d, [bp + -3] ; $format_p
0825   097C 2A            mov b, [d]
0826   097D 38 00 00      mov c, 0
0827   0980 FD 77         inc b
0828   0982 FA FD FF      lea d, [bp + -3] ; $format_p
0829   0985 FD 43         mov [d], b
0830   0987 FD 7D         dec b
0831   0989             ; switch(*format_p){ 
0832   0989             _switch26_expr:
0833   0989 FA FD FF      lea d, [bp + -3] ; $format_p
0834   098C 2A            mov b, [d]
0835   098D 38 00 00      mov c, 0
0836   0990 74            mov d, b
0837   0991 32            mov bl, [d]
0838   0992 A7 00         mov bh, 0
0839   0994 38 00 00      mov c, 0
0840   0997             _switch26_comparisons:
0841   0997 C1 6C         cmp bl, $6c
0842   0999 C6 C5 09      je _switch26_case0
0843   099C C1 4C         cmp bl, $4c
0844   099E C6 C5 09      je _switch26_case1
0845   09A1 C1 64         cmp bl, $64
0846   09A3 C6 D5 0A      je _switch26_case2
0847   09A6 C1 69         cmp bl, $69
0848   09A8 C6 D5 0A      je _switch26_case3
0849   09AB C1 75         cmp bl, $75
0850   09AD C6 05 0B      je _switch26_case4
0851   09B0 C1 78         cmp bl, $78
0852   09B2 C6 35 0B      je _switch26_case5
0853   09B5 C1 63         cmp bl, $63
0854   09B7 C6 65 0B      je _switch26_case6
0855   09BA C1 73         cmp bl, $73
0856   09BC C6 95 0B      je _switch26_case7
0857   09BF 0A C2 0B      jmp _switch26_default
0858   09C2 0A CE 0B      jmp _switch26_exit
0859   09C5             _switch26_case0:
0860   09C5             _switch26_case1:
0861   09C5             ; format_p++; 
0862   09C5 FA FD FF      lea d, [bp + -3] ; $format_p
0863   09C8 2A            mov b, [d]
0864   09C9 38 00 00      mov c, 0
0865   09CC FD 77         inc b
0866   09CE FA FD FF      lea d, [bp + -3] ; $format_p
0867   09D1 FD 43         mov [d], b
0868   09D3 FD 7D         dec b
0869   09D5             ; if(*format_p == 'd' || *format_p == 'i') 
0870   09D5             _if27_cond:
0871   09D5 FA FD FF      lea d, [bp + -3] ; $format_p
0872   09D8 2A            mov b, [d]
0873   09D9 38 00 00      mov c, 0
0874   09DC 74            mov d, b
0875   09DD 32            mov bl, [d]
0876   09DE A7 00         mov bh, 0
0877   09E0 38 00 00      mov c, 0
0878   09E3             ; --- START RELATIONAL
0879   09E3 D7            push a
0880   09E4 11            mov a, b
0881   09E5 FD 2E 64 00   mov32 cb, $00000064
0881   09E9 00 00 
0882   09EB B0            cmp a, b
0883   09EC FD 71         seq ; ==
0884   09EE E4            pop a
0885   09EF             ; --- END RELATIONAL
0886   09EF             ; --- START LOGICAL OR
0887   09EF D7            push a
0888   09F0 11            mov a, b
0889   09F1 FA FD FF      lea d, [bp + -3] ; $format_p
0890   09F4 2A            mov b, [d]
0891   09F5 38 00 00      mov c, 0
0892   09F8 74            mov d, b
0893   09F9 32            mov bl, [d]
0894   09FA A7 00         mov bh, 0
0895   09FC 38 00 00      mov c, 0
0896   09FF             ; --- START RELATIONAL
0897   09FF D7            push a
0898   0A00 11            mov a, b
0899   0A01 FD 2E 69 00   mov32 cb, $00000069
0899   0A05 00 00 
0900   0A07 B0            cmp a, b
0901   0A08 FD 71         seq ; ==
0902   0A0A E4            pop a
0903   0A0B             ; --- END RELATIONAL
0904   0A0B FD A8         sor a, b ; ||
0905   0A0D E4            pop a
0906   0A0E             ; --- END LOGICAL OR
0907   0A0E C0 00 00      cmp b, 0
0908   0A11 C6 32 0A      je _if27_else
0909   0A14             _if27_TRUE:
0910   0A14             ; print_signed_long(*(long *)p); 
0911   0A14             ; --- START FUNCTION CALL
0912   0A14 FA FF FF      lea d, [bp + -1] ; $p
0913   0A17 2A            mov b, [d]
0914   0A18 38 00 00      mov c, 0
0915   0A1B 74            mov d, b
0916   0A1C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0917   0A1F FD 39         mov c, b ; And place it into C
0918   0A21 2A            mov b, [d] ; Lower Word in B
0919   0A22 12            mov a, c
0920   0A23 FD AA         swp a
0921   0A25 D7            push a
0922   0A26 FD AB         swp b
0923   0A28 D8            push b
0924   0A29 07 0B 0C      call print_signed_long
0925   0A2C 51 04 00      add sp, 4
0926   0A2F             ; --- END FUNCTION CALL
0927   0A2F 0A BA 0A      jmp _if27_exit
0928   0A32             _if27_else:
0929   0A32             ; if(*format_p == 'u') 
0930   0A32             _if28_cond:
0931   0A32 FA FD FF      lea d, [bp + -3] ; $format_p
0932   0A35 2A            mov b, [d]
0933   0A36 38 00 00      mov c, 0
0934   0A39 74            mov d, b
0935   0A3A 32            mov bl, [d]
0936   0A3B A7 00         mov bh, 0
0937   0A3D 38 00 00      mov c, 0
0938   0A40             ; --- START RELATIONAL
0939   0A40 D7            push a
0940   0A41 11            mov a, b
0941   0A42 FD 2E 75 00   mov32 cb, $00000075
0941   0A46 00 00 
0942   0A48 B0            cmp a, b
0943   0A49 FD 71         seq ; ==
0944   0A4B E4            pop a
0945   0A4C             ; --- END RELATIONAL
0946   0A4C C0 00 00      cmp b, 0
0947   0A4F C6 70 0A      je _if28_else
0948   0A52             _if28_TRUE:
0949   0A52             ; print_unsigned_long(*(unsigned long *)p); 
0950   0A52             ; --- START FUNCTION CALL
0951   0A52 FA FF FF      lea d, [bp + -1] ; $p
0952   0A55 2A            mov b, [d]
0953   0A56 38 00 00      mov c, 0
0954   0A59 74            mov d, b
0955   0A5A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0956   0A5D FD 39         mov c, b ; And place it into C
0957   0A5F 2A            mov b, [d] ; Lower Word in B
0958   0A60 12            mov a, c
0959   0A61 FD AA         swp a
0960   0A63 D7            push a
0961   0A64 FD AB         swp b
0962   0A66 D8            push b
0963   0A67 07 9E 0D      call print_unsigned_long
0964   0A6A 51 04 00      add sp, 4
0965   0A6D             ; --- END FUNCTION CALL
0966   0A6D 0A BA 0A      jmp _if28_exit
0967   0A70             _if28_else:
0968   0A70             ; if(*format_p == 'x') 
0969   0A70             _if29_cond:
0970   0A70 FA FD FF      lea d, [bp + -3] ; $format_p
0971   0A73 2A            mov b, [d]
0972   0A74 38 00 00      mov c, 0
0973   0A77 74            mov d, b
0974   0A78 32            mov bl, [d]
0975   0A79 A7 00         mov bh, 0
0976   0A7B 38 00 00      mov c, 0
0977   0A7E             ; --- START RELATIONAL
0978   0A7E D7            push a
0979   0A7F 11            mov a, b
0980   0A80 FD 2E 78 00   mov32 cb, $00000078
0980   0A84 00 00 
0981   0A86 B0            cmp a, b
0982   0A87 FD 71         seq ; ==
0983   0A89 E4            pop a
0984   0A8A             ; --- END RELATIONAL
0985   0A8A C0 00 00      cmp b, 0
0986   0A8D C6 AE 0A      je _if29_else
0987   0A90             _if29_TRUE:
0988   0A90             ; printx32(*(long int *)p); 
0989   0A90             ; --- START FUNCTION CALL
0990   0A90 FA FF FF      lea d, [bp + -1] ; $p
0991   0A93 2A            mov b, [d]
0992   0A94 38 00 00      mov c, 0
0993   0A97 74            mov d, b
0994   0A98 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0995   0A9B FD 39         mov c, b ; And place it into C
0996   0A9D 2A            mov b, [d] ; Lower Word in B
0997   0A9E 12            mov a, c
0998   0A9F FD AA         swp a
0999   0AA1 D7            push a
1000   0AA2 FD AB         swp b
1001   0AA4 D8            push b
1002   0AA5 07 D2 0E      call printx32
1003   0AA8 51 04 00      add sp, 4
1004   0AAB             ; --- END FUNCTION CALL
1005   0AAB 0A BA 0A      jmp _if29_exit
1006   0AAE             _if29_else:
1007   0AAE             ; err("Unexpected format in printf."); 
1008   0AAE             ; --- START FUNCTION CALL
1009   0AAE 26 50 12      mov b, _s4 ; "Unexpected format in printf."
1010   0AB1 FD AB         swp b
1011   0AB3 D8            push b
1012   0AB4 07 32 0F      call err
1013   0AB7 51 02 00      add sp, 2
1014   0ABA             ; --- END FUNCTION CALL
1015   0ABA             _if29_exit:
1016   0ABA             _if28_exit:
1017   0ABA             _if27_exit:
1018   0ABA             ; p = p + 4; 
1019   0ABA FA FF FF      lea d, [bp + -1] ; $p
1020   0ABD DA            push d
1021   0ABE FA FF FF      lea d, [bp + -1] ; $p
1022   0AC1 2A            mov b, [d]
1023   0AC2 38 00 00      mov c, 0
1024   0AC5             ; --- START TERMS
1025   0AC5 D7            push a
1026   0AC6 11            mov a, b
1027   0AC7 FD 2E 04 00   mov32 cb, $00000004
1027   0ACB 00 00 
1028   0ACD 56            add b, a
1029   0ACE E4            pop a
1030   0ACF             ; --- END TERMS
1031   0ACF E7            pop d
1032   0AD0 FD 43         mov [d], b
1033   0AD2             ; break; 
1034   0AD2 0A CE 0B      jmp _switch26_exit ; case break
1035   0AD5             _switch26_case2:
1036   0AD5             _switch26_case3:
1037   0AD5             ; print_signed(*(int*)p); 
1038   0AD5             ; --- START FUNCTION CALL
1039   0AD5 FA FF FF      lea d, [bp + -1] ; $p
1040   0AD8 2A            mov b, [d]
1041   0AD9 38 00 00      mov c, 0
1042   0ADC 74            mov d, b
1043   0ADD 2A            mov b, [d]
1044   0ADE 38 00 00      mov c, 0
1045   0AE1 FD AB         swp b
1046   0AE3 D8            push b
1047   0AE4 07 60 0F      call print_signed
1048   0AE7 51 02 00      add sp, 2
1049   0AEA             ; --- END FUNCTION CALL
1050   0AEA             ; p = p + 2; 
1051   0AEA FA FF FF      lea d, [bp + -1] ; $p
1052   0AED DA            push d
1053   0AEE FA FF FF      lea d, [bp + -1] ; $p
1054   0AF1 2A            mov b, [d]
1055   0AF2 38 00 00      mov c, 0
1056   0AF5             ; --- START TERMS
1057   0AF5 D7            push a
1058   0AF6 11            mov a, b
1059   0AF7 FD 2E 02 00   mov32 cb, $00000002
1059   0AFB 00 00 
1060   0AFD 56            add b, a
1061   0AFE E4            pop a
1062   0AFF             ; --- END TERMS
1063   0AFF E7            pop d
1064   0B00 FD 43         mov [d], b
1065   0B02             ; break; 
1066   0B02 0A CE 0B      jmp _switch26_exit ; case break
1067   0B05             _switch26_case4:
1068   0B05             ; print_unsigned(*(unsigned int*)p); 
1069   0B05             ; --- START FUNCTION CALL
1070   0B05 FA FF FF      lea d, [bp + -1] ; $p
1071   0B08 2A            mov b, [d]
1072   0B09 38 00 00      mov c, 0
1073   0B0C 74            mov d, b
1074   0B0D 2A            mov b, [d]
1075   0B0E 38 00 00      mov c, 0
1076   0B11 FD AB         swp b
1077   0B13 D8            push b
1078   0B14 07 B1 10      call print_unsigned
1079   0B17 51 02 00      add sp, 2
1080   0B1A             ; --- END FUNCTION CALL
1081   0B1A             ; p = p + 2; 
1082   0B1A FA FF FF      lea d, [bp + -1] ; $p
1083   0B1D DA            push d
1084   0B1E FA FF FF      lea d, [bp + -1] ; $p
1085   0B21 2A            mov b, [d]
1086   0B22 38 00 00      mov c, 0
1087   0B25             ; --- START TERMS
1088   0B25 D7            push a
1089   0B26 11            mov a, b
1090   0B27 FD 2E 02 00   mov32 cb, $00000002
1090   0B2B 00 00 
1091   0B2D 56            add b, a
1092   0B2E E4            pop a
1093   0B2F             ; --- END TERMS
1094   0B2F E7            pop d
1095   0B30 FD 43         mov [d], b
1096   0B32             ; break; 
1097   0B32 0A CE 0B      jmp _switch26_exit ; case break
1098   0B35             _switch26_case5:
1099   0B35             ; printx16(*(int*)p); 
1100   0B35             ; --- START FUNCTION CALL
1101   0B35 FA FF FF      lea d, [bp + -1] ; $p
1102   0B38 2A            mov b, [d]
1103   0B39 38 00 00      mov c, 0
1104   0B3C 74            mov d, b
1105   0B3D 2A            mov b, [d]
1106   0B3E 38 00 00      mov c, 0
1107   0B41 FD AB         swp b
1108   0B43 D8            push b
1109   0B44 07 C9 11      call printx16
1110   0B47 51 02 00      add sp, 2
1111   0B4A             ; --- END FUNCTION CALL
1112   0B4A             ; p = p + 2; 
1113   0B4A FA FF FF      lea d, [bp + -1] ; $p
1114   0B4D DA            push d
1115   0B4E FA FF FF      lea d, [bp + -1] ; $p
1116   0B51 2A            mov b, [d]
1117   0B52 38 00 00      mov c, 0
1118   0B55             ; --- START TERMS
1119   0B55 D7            push a
1120   0B56 11            mov a, b
1121   0B57 FD 2E 02 00   mov32 cb, $00000002
1121   0B5B 00 00 
1122   0B5D 56            add b, a
1123   0B5E E4            pop a
1124   0B5F             ; --- END TERMS
1125   0B5F E7            pop d
1126   0B60 FD 43         mov [d], b
1127   0B62             ; break; 
1128   0B62 0A CE 0B      jmp _switch26_exit ; case break
1129   0B65             _switch26_case6:
1130   0B65             ; putchar(*(char*)p); 
1131   0B65             ; --- START FUNCTION CALL
1132   0B65 FA FF FF      lea d, [bp + -1] ; $p
1133   0B68 2A            mov b, [d]
1134   0B69 38 00 00      mov c, 0
1135   0B6C 74            mov d, b
1136   0B6D 32            mov bl, [d]
1137   0B6E A7 00         mov bh, 0
1138   0B70 38 00 00      mov c, 0
1139   0B73 DD            push bl
1140   0B74 07 90 0D      call putchar
1141   0B77 51 01 00      add sp, 1
1142   0B7A             ; --- END FUNCTION CALL
1143   0B7A             ; p = p + 1; 
1144   0B7A FA FF FF      lea d, [bp + -1] ; $p
1145   0B7D DA            push d
1146   0B7E FA FF FF      lea d, [bp + -1] ; $p
1147   0B81 2A            mov b, [d]
1148   0B82 38 00 00      mov c, 0
1149   0B85             ; --- START TERMS
1150   0B85 D7            push a
1151   0B86 11            mov a, b
1152   0B87 FD 2E 01 00   mov32 cb, $00000001
1152   0B8B 00 00 
1153   0B8D 56            add b, a
1154   0B8E E4            pop a
1155   0B8F             ; --- END TERMS
1156   0B8F E7            pop d
1157   0B90 FD 43         mov [d], b
1158   0B92             ; break; 
1159   0B92 0A CE 0B      jmp _switch26_exit ; case break
1160   0B95             _switch26_case7:
1161   0B95             ; print(*(char**)p); 
1162   0B95             ; --- START FUNCTION CALL
1163   0B95 FA FF FF      lea d, [bp + -1] ; $p
1164   0B98 2A            mov b, [d]
1165   0B99 38 00 00      mov c, 0
1166   0B9C 74            mov d, b
1167   0B9D 2A            mov b, [d]
1168   0B9E FD AB         swp b
1169   0BA0 D8            push b
1170   0BA1 07 47 0F      call print
1171   0BA4 51 02 00      add sp, 2
1172   0BA7             ; --- END FUNCTION CALL
1173   0BA7             ; p = p + 2; 
1174   0BA7 FA FF FF      lea d, [bp + -1] ; $p
1175   0BAA DA            push d
1176   0BAB FA FF FF      lea d, [bp + -1] ; $p
1177   0BAE 2A            mov b, [d]
1178   0BAF 38 00 00      mov c, 0
1179   0BB2             ; --- START TERMS
1180   0BB2 D7            push a
1181   0BB3 11            mov a, b
1182   0BB4 FD 2E 02 00   mov32 cb, $00000002
1182   0BB8 00 00 
1183   0BBA 56            add b, a
1184   0BBB E4            pop a
1185   0BBC             ; --- END TERMS
1186   0BBC E7            pop d
1187   0BBD FD 43         mov [d], b
1188   0BBF             ; break; 
1189   0BBF 0A CE 0B      jmp _switch26_exit ; case break
1190   0BC2             _switch26_default:
1191   0BC2             ; print("Error: Unknown argument type.\n"); 
1192   0BC2             ; --- START FUNCTION CALL
1193   0BC2 26 6D 12      mov b, _s5 ; "Error: Unknown argument type.\n"
1194   0BC5 FD AB         swp b
1195   0BC7 D8            push b
1196   0BC8 07 47 0F      call print
1197   0BCB 51 02 00      add sp, 2
1198   0BCE             ; --- END FUNCTION CALL
1199   0BCE             _switch26_exit:
1200   0BCE             ; format_p++; 
1201   0BCE FA FD FF      lea d, [bp + -3] ; $format_p
1202   0BD1 2A            mov b, [d]
1203   0BD2 38 00 00      mov c, 0
1204   0BD5 FD 77         inc b
1205   0BD7 FA FD FF      lea d, [bp + -3] ; $format_p
1206   0BDA FD 43         mov [d], b
1207   0BDC FD 7D         dec b
1208   0BDE 0A 06 0C      jmp _if25_exit
1209   0BE1             _if25_else:
1210   0BE1             ; putchar(*format_p); 
1211   0BE1             ; --- START FUNCTION CALL
1212   0BE1 FA FD FF      lea d, [bp + -3] ; $format_p
1213   0BE4 2A            mov b, [d]
1214   0BE5 38 00 00      mov c, 0
1215   0BE8 74            mov d, b
1216   0BE9 32            mov bl, [d]
1217   0BEA A7 00         mov bh, 0
1218   0BEC 38 00 00      mov c, 0
1219   0BEF DD            push bl
1220   0BF0 07 90 0D      call putchar
1221   0BF3 51 01 00      add sp, 1
1222   0BF6             ; --- END FUNCTION CALL
1223   0BF6             ; format_p++; 
1224   0BF6 FA FD FF      lea d, [bp + -3] ; $format_p
1225   0BF9 2A            mov b, [d]
1226   0BFA 38 00 00      mov c, 0
1227   0BFD FD 77         inc b
1228   0BFF FA FD FF      lea d, [bp + -3] ; $format_p
1229   0C02 FD 43         mov [d], b
1230   0C04 FD 7D         dec b
1231   0C06             _if25_exit:
1232   0C06             _if24_exit:
1233   0C06             _for23_update:
1234   0C06 0A 3A 09      jmp _for23_cond
1235   0C09             _for23_exit:
1236   0C09 F9            leave
1237   0C0A 09            ret
1238   0C0B             
1239   0C0B             print_signed_long:
1240   0C0B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1241   0C0E             ; char digits[10]; 
1242   0C0E 52 0A 00      sub sp, 10
1243   0C11             ; int i = 0; 
1244   0C11 52 02 00      sub sp, 2
1245   0C14             ; --- START LOCAL VAR INITIALIZATION
1246   0C14 FA F5 FF      lea d, [bp + -11] ; $i
1247   0C17 DA            push d
1248   0C18 FD 2E 00 00   mov32 cb, $00000000
1248   0C1C 00 00 
1249   0C1E E7            pop d
1250   0C1F FD 43         mov [d], b
1251   0C21             ; --- END LOCAL VAR INITIALIZATION
1252   0C21             ; if (num < 0) { 
1253   0C21             _if30_cond:
1254   0C21 FA 05 00      lea d, [bp + 5] ; $num
1255   0C24 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1256   0C27 FD 39         mov c, b ; And place it into C
1257   0C29 2A            mov b, [d] ; Lower Word in B
1258   0C2A             ; --- START RELATIONAL
1259   0C2A D7            push a
1260   0C2B FD D8         push g
1261   0C2D 11            mov a, b
1262   0C2E FD 7A         mov g, c
1263   0C30 FD 2E 00 00   mov32 cb, $00000000
1263   0C34 00 00 
1264   0C36 FD AF         cmp32 ga, cb
1265   0C38 FD 73         slt ; <
1266   0C3A FD F1         pop g
1267   0C3C E4            pop a
1268   0C3D             ; --- END RELATIONAL
1269   0C3D C0 00 00      cmp b, 0
1270   0C40 C6 72 0C      je _if30_else
1271   0C43             _if30_TRUE:
1272   0C43             ; putchar('-'); 
1273   0C43             ; --- START FUNCTION CALL
1274   0C43 FD 2E 2D 00   mov32 cb, $0000002d
1274   0C47 00 00 
1275   0C49 DD            push bl
1276   0C4A 07 90 0D      call putchar
1277   0C4D 51 01 00      add sp, 1
1278   0C50             ; --- END FUNCTION CALL
1279   0C50             ; num = -num; 
1280   0C50 FA 05 00      lea d, [bp + 5] ; $num
1281   0C53 DA            push d
1282   0C54 FA 05 00      lea d, [bp + 5] ; $num
1283   0C57 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1284   0C5A FD 39         mov c, b ; And place it into C
1285   0C5C 2A            mov b, [d] ; Lower Word in B
1286   0C5D 12            mov a, c
1287   0C5E 95            not a
1288   0C5F 97            not b
1289   0C60 55 01 00      add b, 1
1290   0C63 5B 00 00      adc a, 0
1291   0C66 39            mov c, a
1292   0C67 E7            pop d
1293   0C68 FD 43         mov [d], b
1294   0C6A 28            mov b, c
1295   0C6B FD 44 02 00   mov [d + 2], b
1296   0C6F 0A A6 0C      jmp _if30_exit
1297   0C72             _if30_else:
1298   0C72             ; if (num == 0) { 
1299   0C72             _if31_cond:
1300   0C72 FA 05 00      lea d, [bp + 5] ; $num
1301   0C75 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1302   0C78 FD 39         mov c, b ; And place it into C
1303   0C7A 2A            mov b, [d] ; Lower Word in B
1304   0C7B             ; --- START RELATIONAL
1305   0C7B D7            push a
1306   0C7C FD D8         push g
1307   0C7E 11            mov a, b
1308   0C7F FD 7A         mov g, c
1309   0C81 FD 2E 00 00   mov32 cb, $00000000
1309   0C85 00 00 
1310   0C87 FD AF         cmp32 ga, cb
1311   0C89 FD 71         seq ; ==
1312   0C8B FD F1         pop g
1313   0C8D E4            pop a
1314   0C8E             ; --- END RELATIONAL
1315   0C8E C0 00 00      cmp b, 0
1316   0C91 C6 A6 0C      je _if31_exit
1317   0C94             _if31_TRUE:
1318   0C94             ; putchar('0'); 
1319   0C94             ; --- START FUNCTION CALL
1320   0C94 FD 2E 30 00   mov32 cb, $00000030
1320   0C98 00 00 
1321   0C9A DD            push bl
1322   0C9B 07 90 0D      call putchar
1323   0C9E 51 01 00      add sp, 1
1324   0CA1             ; --- END FUNCTION CALL
1325   0CA1             ; return; 
1326   0CA1 F9            leave
1327   0CA2 09            ret
1328   0CA3 0A A6 0C      jmp _if31_exit
1329   0CA6             _if31_exit:
1330   0CA6             _if30_exit:
1331   0CA6             ; while (num > 0) { 
1332   0CA6             _while32_cond:
1333   0CA6 FA 05 00      lea d, [bp + 5] ; $num
1334   0CA9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1335   0CAC FD 39         mov c, b ; And place it into C
1336   0CAE 2A            mov b, [d] ; Lower Word in B
1337   0CAF             ; --- START RELATIONAL
1338   0CAF D7            push a
1339   0CB0 FD D8         push g
1340   0CB2 11            mov a, b
1341   0CB3 FD 7A         mov g, c
1342   0CB5 FD 2E 00 00   mov32 cb, $00000000
1342   0CB9 00 00 
1343   0CBB FD AF         cmp32 ga, cb
1344   0CBD FD 7F         sgt
1345   0CBF FD F1         pop g
1346   0CC1 E4            pop a
1347   0CC2             ; --- END RELATIONAL
1348   0CC2 C0 00 00      cmp b, 0
1349   0CC5 C6 46 0D      je _while32_exit
1350   0CC8             _while32_block:
1351   0CC8             ; digits[i] = '0' + (num % 10); 
1352   0CC8 FA F7 FF      lea d, [bp + -9] ; $digits
1353   0CCB D7            push a
1354   0CCC DA            push d
1355   0CCD FA F5 FF      lea d, [bp + -11] ; $i
1356   0CD0 2A            mov b, [d]
1357   0CD1 38 00 00      mov c, 0
1358   0CD4 E7            pop d
1359   0CD5 5A            add d, b
1360   0CD6 E4            pop a
1361   0CD7 DA            push d
1362   0CD8 FD 2E 30 00   mov32 cb, $00000030
1362   0CDC 00 00 
1363   0CDE             ; --- START TERMS
1364   0CDE D7            push a
1365   0CDF 11            mov a, b
1366   0CE0 FA 05 00      lea d, [bp + 5] ; $num
1367   0CE3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1368   0CE6 FD 39         mov c, b ; And place it into C
1369   0CE8 2A            mov b, [d] ; Lower Word in B
1370   0CE9             ; --- START FACTORS
1371   0CE9 D7            push a
1372   0CEA FD D8         push g
1373   0CEC 11            mov a, b
1374   0CED FD 7A         mov g, c
1375   0CEF FD 2E 0A 00   mov32 cb, $0000000a
1375   0CF3 00 00 
1376   0CF5 FD D8         push g ; save 'g' as the div instruction uses it
1377   0CF7 AE            div a, b ; %, a: quotient, b: remainder
1378   0CF8 11            mov a, b
1379   0CF9 FD F1         pop g
1380   0CFB FD 38         mov c, g
1381   0CFD 27            mov b, a
1382   0CFE FD F1         pop g
1383   0D00 E4            pop a
1384   0D01             ; --- END FACTORS
1385   0D01 FD 15         add32 cb, ga
1386   0D03 E4            pop a
1387   0D04             ; --- END TERMS
1388   0D04 E7            pop d
1389   0D05 FD 3E         mov [d], bl
1390   0D07             ; num = num / 10; 
1391   0D07 FA 05 00      lea d, [bp + 5] ; $num
1392   0D0A DA            push d
1393   0D0B FA 05 00      lea d, [bp + 5] ; $num
1394   0D0E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1395   0D11 FD 39         mov c, b ; And place it into C
1396   0D13 2A            mov b, [d] ; Lower Word in B
1397   0D14             ; --- START FACTORS
1398   0D14 D7            push a
1399   0D15 FD D8         push g
1400   0D17 11            mov a, b
1401   0D18 FD 7A         mov g, c
1402   0D1A FD 2E 0A 00   mov32 cb, $0000000a
1402   0D1E 00 00 
1403   0D20 FD D8         push g ; save 'g' as the div instruction uses it
1404   0D22 AE            div a, b ; /, a: quotient, b: remainder
1405   0D23 FD F1         pop g
1406   0D25 FD 38         mov c, g
1407   0D27 27            mov b, a
1408   0D28 FD F1         pop g
1409   0D2A E4            pop a
1410   0D2B             ; --- END FACTORS
1411   0D2B E7            pop d
1412   0D2C FD 43         mov [d], b
1413   0D2E 28            mov b, c
1414   0D2F FD 44 02 00   mov [d + 2], b
1415   0D33             ; i++; 
1416   0D33 FA F5 FF      lea d, [bp + -11] ; $i
1417   0D36 2A            mov b, [d]
1418   0D37 38 00 00      mov c, 0
1419   0D3A 11            mov a, b
1420   0D3B FD 77         inc b
1421   0D3D FA F5 FF      lea d, [bp + -11] ; $i
1422   0D40 FD 43         mov [d], b
1423   0D42 27            mov b, a
1424   0D43 0A A6 0C      jmp _while32_cond
1425   0D46             _while32_exit:
1426   0D46             ; while (i > 0) { 
1427   0D46             _while39_cond:
1428   0D46 FA F5 FF      lea d, [bp + -11] ; $i
1429   0D49 2A            mov b, [d]
1430   0D4A 38 00 00      mov c, 0
1431   0D4D             ; --- START RELATIONAL
1432   0D4D D7            push a
1433   0D4E 11            mov a, b
1434   0D4F FD 2E 00 00   mov32 cb, $00000000
1434   0D53 00 00 
1435   0D55 B0            cmp a, b
1436   0D56 FD 7F         sgt ; >
1437   0D58 E4            pop a
1438   0D59             ; --- END RELATIONAL
1439   0D59 C0 00 00      cmp b, 0
1440   0D5C C6 8E 0D      je _while39_exit
1441   0D5F             _while39_block:
1442   0D5F             ; i--; 
1443   0D5F FA F5 FF      lea d, [bp + -11] ; $i
1444   0D62 2A            mov b, [d]
1445   0D63 38 00 00      mov c, 0
1446   0D66 11            mov a, b
1447   0D67 FD 7D         dec b
1448   0D69 FA F5 FF      lea d, [bp + -11] ; $i
1449   0D6C FD 43         mov [d], b
1450   0D6E 27            mov b, a
1451   0D6F             ; putchar(digits[i]); 
1452   0D6F             ; --- START FUNCTION CALL
1453   0D6F FA F7 FF      lea d, [bp + -9] ; $digits
1454   0D72 D7            push a
1455   0D73 DA            push d
1456   0D74 FA F5 FF      lea d, [bp + -11] ; $i
1457   0D77 2A            mov b, [d]
1458   0D78 38 00 00      mov c, 0
1459   0D7B E7            pop d
1460   0D7C 5A            add d, b
1461   0D7D E4            pop a
1462   0D7E 32            mov bl, [d]
1463   0D7F A7 00         mov bh, 0
1464   0D81 38 00 00      mov c, 0
1465   0D84 DD            push bl
1466   0D85 07 90 0D      call putchar
1467   0D88 51 01 00      add sp, 1
1468   0D8B             ; --- END FUNCTION CALL
1469   0D8B 0A 46 0D      jmp _while39_cond
1470   0D8E             _while39_exit:
1471   0D8E F9            leave
1472   0D8F 09            ret
1473   0D90             
1474   0D90             putchar:
1475   0D90 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1476   0D93             ; --- BEGIN INLINE ASM SEGMENT
1477   0D93 FA 05 00      lea d, [bp + 5] ; $c
1478   0D96 1E            mov al, [d]
1479   0D97 23            mov ah, al
1480   0D98 19 00         mov al, 0
1481   0D9A 05 03         syscall sys_io      ; char in AH
1482   0D9C             ; --- END INLINE ASM SEGMENT
1483   0D9C F9            leave
1484   0D9D 09            ret
1485   0D9E             
1486   0D9E             print_unsigned_long:
1487   0D9E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1488   0DA1             ; char digits[10]; 
1489   0DA1 52 0A 00      sub sp, 10
1490   0DA4             ; int i; 
1491   0DA4 52 02 00      sub sp, 2
1492   0DA7             ; i = 0; 
1493   0DA7 FA F5 FF      lea d, [bp + -11] ; $i
1494   0DAA DA            push d
1495   0DAB FD 2E 00 00   mov32 cb, $00000000
1495   0DAF 00 00 
1496   0DB1 E7            pop d
1497   0DB2 FD 43         mov [d], b
1498   0DB4             ; if(num == 0){ 
1499   0DB4             _if40_cond:
1500   0DB4 FA 05 00      lea d, [bp + 5] ; $num
1501   0DB7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1502   0DBA FD 39         mov c, b ; And place it into C
1503   0DBC 2A            mov b, [d] ; Lower Word in B
1504   0DBD             ; --- START RELATIONAL
1505   0DBD D7            push a
1506   0DBE FD D8         push g
1507   0DC0 11            mov a, b
1508   0DC1 FD 7A         mov g, c
1509   0DC3 FD 2E 00 00   mov32 cb, $00000000
1509   0DC7 00 00 
1510   0DC9 FD AF         cmp32 ga, cb
1511   0DCB FD 71         seq ; ==
1512   0DCD FD F1         pop g
1513   0DCF E4            pop a
1514   0DD0             ; --- END RELATIONAL
1515   0DD0 C0 00 00      cmp b, 0
1516   0DD3 C6 E8 0D      je _if40_exit
1517   0DD6             _if40_TRUE:
1518   0DD6             ; putchar('0'); 
1519   0DD6             ; --- START FUNCTION CALL
1520   0DD6 FD 2E 30 00   mov32 cb, $00000030
1520   0DDA 00 00 
1521   0DDC DD            push bl
1522   0DDD 07 90 0D      call putchar
1523   0DE0 51 01 00      add sp, 1
1524   0DE3             ; --- END FUNCTION CALL
1525   0DE3             ; return; 
1526   0DE3 F9            leave
1527   0DE4 09            ret
1528   0DE5 0A E8 0D      jmp _if40_exit
1529   0DE8             _if40_exit:
1530   0DE8             ; while (num > 0) { 
1531   0DE8             _while41_cond:
1532   0DE8 FA 05 00      lea d, [bp + 5] ; $num
1533   0DEB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1534   0DEE FD 39         mov c, b ; And place it into C
1535   0DF0 2A            mov b, [d] ; Lower Word in B
1536   0DF1             ; --- START RELATIONAL
1537   0DF1 D7            push a
1538   0DF2 FD D8         push g
1539   0DF4 11            mov a, b
1540   0DF5 FD 7A         mov g, c
1541   0DF7 FD 2E 00 00   mov32 cb, $00000000
1541   0DFB 00 00 
1542   0DFD FD AF         cmp32 ga, cb
1543   0DFF FD 81         sgu
1544   0E01 FD F1         pop g
1545   0E03 E4            pop a
1546   0E04             ; --- END RELATIONAL
1547   0E04 C0 00 00      cmp b, 0
1548   0E07 C6 88 0E      je _while41_exit
1549   0E0A             _while41_block:
1550   0E0A             ; digits[i] = '0' + (num % 10); 
1551   0E0A FA F7 FF      lea d, [bp + -9] ; $digits
1552   0E0D D7            push a
1553   0E0E DA            push d
1554   0E0F FA F5 FF      lea d, [bp + -11] ; $i
1555   0E12 2A            mov b, [d]
1556   0E13 38 00 00      mov c, 0
1557   0E16 E7            pop d
1558   0E17 5A            add d, b
1559   0E18 E4            pop a
1560   0E19 DA            push d
1561   0E1A FD 2E 30 00   mov32 cb, $00000030
1561   0E1E 00 00 
1562   0E20             ; --- START TERMS
1563   0E20 D7            push a
1564   0E21 11            mov a, b
1565   0E22 FA 05 00      lea d, [bp + 5] ; $num
1566   0E25 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1567   0E28 FD 39         mov c, b ; And place it into C
1568   0E2A 2A            mov b, [d] ; Lower Word in B
1569   0E2B             ; --- START FACTORS
1570   0E2B D7            push a
1571   0E2C FD D8         push g
1572   0E2E 11            mov a, b
1573   0E2F FD 7A         mov g, c
1574   0E31 FD 2E 0A 00   mov32 cb, $0000000a
1574   0E35 00 00 
1575   0E37 FD D8         push g ; save 'g' as the div instruction uses it
1576   0E39 AE            div a, b ; %, a: quotient, b: remainder
1577   0E3A 11            mov a, b
1578   0E3B FD F1         pop g
1579   0E3D FD 38         mov c, g
1580   0E3F 27            mov b, a
1581   0E40 FD F1         pop g
1582   0E42 E4            pop a
1583   0E43             ; --- END FACTORS
1584   0E43 FD 15         add32 cb, ga
1585   0E45 E4            pop a
1586   0E46             ; --- END TERMS
1587   0E46 E7            pop d
1588   0E47 FD 3E         mov [d], bl
1589   0E49             ; num = num / 10; 
1590   0E49 FA 05 00      lea d, [bp + 5] ; $num
1591   0E4C DA            push d
1592   0E4D FA 05 00      lea d, [bp + 5] ; $num
1593   0E50 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1594   0E53 FD 39         mov c, b ; And place it into C
1595   0E55 2A            mov b, [d] ; Lower Word in B
1596   0E56             ; --- START FACTORS
1597   0E56 D7            push a
1598   0E57 FD D8         push g
1599   0E59 11            mov a, b
1600   0E5A FD 7A         mov g, c
1601   0E5C FD 2E 0A 00   mov32 cb, $0000000a
1601   0E60 00 00 
1602   0E62 FD D8         push g ; save 'g' as the div instruction uses it
1603   0E64 AE            div a, b ; /, a: quotient, b: remainder
1604   0E65 FD F1         pop g
1605   0E67 FD 38         mov c, g
1606   0E69 27            mov b, a
1607   0E6A FD F1         pop g
1608   0E6C E4            pop a
1609   0E6D             ; --- END FACTORS
1610   0E6D E7            pop d
1611   0E6E FD 43         mov [d], b
1612   0E70 28            mov b, c
1613   0E71 FD 44 02 00   mov [d + 2], b
1614   0E75             ; i++; 
1615   0E75 FA F5 FF      lea d, [bp + -11] ; $i
1616   0E78 2A            mov b, [d]
1617   0E79 38 00 00      mov c, 0
1618   0E7C 11            mov a, b
1619   0E7D FD 77         inc b
1620   0E7F FA F5 FF      lea d, [bp + -11] ; $i
1621   0E82 FD 43         mov [d], b
1622   0E84 27            mov b, a
1623   0E85 0A E8 0D      jmp _while41_cond
1624   0E88             _while41_exit:
1625   0E88             ; while (i > 0) { 
1626   0E88             _while48_cond:
1627   0E88 FA F5 FF      lea d, [bp + -11] ; $i
1628   0E8B 2A            mov b, [d]
1629   0E8C 38 00 00      mov c, 0
1630   0E8F             ; --- START RELATIONAL
1631   0E8F D7            push a
1632   0E90 11            mov a, b
1633   0E91 FD 2E 00 00   mov32 cb, $00000000
1633   0E95 00 00 
1634   0E97 B0            cmp a, b
1635   0E98 FD 7F         sgt ; >
1636   0E9A E4            pop a
1637   0E9B             ; --- END RELATIONAL
1638   0E9B C0 00 00      cmp b, 0
1639   0E9E C6 D0 0E      je _while48_exit
1640   0EA1             _while48_block:
1641   0EA1             ; i--; 
1642   0EA1 FA F5 FF      lea d, [bp + -11] ; $i
1643   0EA4 2A            mov b, [d]
1644   0EA5 38 00 00      mov c, 0
1645   0EA8 11            mov a, b
1646   0EA9 FD 7D         dec b
1647   0EAB FA F5 FF      lea d, [bp + -11] ; $i
1648   0EAE FD 43         mov [d], b
1649   0EB0 27            mov b, a
1650   0EB1             ; putchar(digits[i]); 
1651   0EB1             ; --- START FUNCTION CALL
1652   0EB1 FA F7 FF      lea d, [bp + -9] ; $digits
1653   0EB4 D7            push a
1654   0EB5 DA            push d
1655   0EB6 FA F5 FF      lea d, [bp + -11] ; $i
1656   0EB9 2A            mov b, [d]
1657   0EBA 38 00 00      mov c, 0
1658   0EBD E7            pop d
1659   0EBE 5A            add d, b
1660   0EBF E4            pop a
1661   0EC0 32            mov bl, [d]
1662   0EC1 A7 00         mov bh, 0
1663   0EC3 38 00 00      mov c, 0
1664   0EC6 DD            push bl
1665   0EC7 07 90 0D      call putchar
1666   0ECA 51 01 00      add sp, 1
1667   0ECD             ; --- END FUNCTION CALL
1668   0ECD 0A 88 0E      jmp _while48_cond
1669   0ED0             _while48_exit:
1670   0ED0 F9            leave
1671   0ED1 09            ret
1672   0ED2             
1673   0ED2             printx32:
1674   0ED2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1675   0ED5             ; --- BEGIN INLINE ASM SEGMENT
1676   0ED5 FA 05 00      lea d, [bp + 5] ; $hex
1677   0ED8 2B 02 00      mov b, [d+2]
1678   0EDB 07 E4 0E      call print_u16x_printx32
1679   0EDE 2A            mov b, [d]
1680   0EDF 07 E4 0E      call print_u16x_printx32
1681   0EE2             ; --- END INLINE ASM SEGMENT
1682   0EE2             ; return; 
1683   0EE2 F9            leave
1684   0EE3 09            ret
1685   0EE4             ; --- BEGIN INLINE ASM SEGMENT
1686   0EE4             print_u16x_printx32:
1687   0EE4 D7            push a
1688   0EE5 D8            push b
1689   0EE6 DD            push bl
1690   0EE7 30            mov bl, bh
1691   0EE8 07 06 0F      call _itoa_printx32        ; convert bh to char in A
1692   0EEB 2F            mov bl, al        ; save al
1693   0EEC 19 00         mov al, 0
1694   0EEE 05 03         syscall sys_io        ; display AH
1695   0EF0 24            mov ah, bl        ; retrieve al
1696   0EF1 19 00         mov al, 0
1697   0EF3 05 03         syscall sys_io        ; display AL
1698   0EF5 EA            pop bl
1699   0EF6 07 06 0F      call _itoa_printx32        ; convert bh to char in A
1700   0EF9 2F            mov bl, al        ; save al
1701   0EFA 19 00         mov al, 0
1702   0EFC 05 03         syscall sys_io        ; display AH
1703   0EFE 24            mov ah, bl        ; retrieve al
1704   0EFF 19 00         mov al, 0
1705   0F01 05 03         syscall sys_io        ; display AL
1706   0F03 E5            pop b
1707   0F04 E4            pop a
1708   0F05 09            ret
1709   0F06             _itoa_printx32:
1710   0F06 DA            push d
1711   0F07 D8            push b
1712   0F08 A7 00         mov bh, 0
1713   0F0A FD A4 04      shr bl, 4  
1714   0F0D 74            mov d, b
1715   0F0E 1F 20 0F      mov al, [d + s_hex_digits_printx32]
1716   0F11 23            mov ah, al
1717   0F12 E5            pop b
1718   0F13 D8            push b
1719   0F14 A7 00         mov bh, 0
1720   0F16 FD 87 0F      and bl, $0F
1721   0F19 74            mov d, b
1722   0F1A 1F 20 0F      mov al, [d + s_hex_digits_printx32]
1723   0F1D E5            pop b
1724   0F1E E7            pop d
1725   0F1F 09            ret
1726   0F20 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1726   0F24 34 35 36 37 
1726   0F28 38 39 41 42 
1726   0F2C 43 44 45 46 
1727   0F30             ; --- END INLINE ASM SEGMENT
1728   0F30 F9            leave
1729   0F31 09            ret
1730   0F32             
1731   0F32             err:
1732   0F32 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1733   0F35             ; print(e); 
1734   0F35             ; --- START FUNCTION CALL
1735   0F35 FA 05 00      lea d, [bp + 5] ; $e
1736   0F38 2A            mov b, [d]
1737   0F39 38 00 00      mov c, 0
1738   0F3C FD AB         swp b
1739   0F3E D8            push b
1740   0F3F 07 47 0F      call print
1741   0F42 51 02 00      add sp, 2
1742   0F45             ; --- END FUNCTION CALL
1743   0F45 F9            leave
1744   0F46 09            ret
1745   0F47             
1746   0F47             print:
1747   0F47 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1748   0F4A             ; --- BEGIN INLINE ASM SEGMENT
1749   0F4A FA 05 00      lea d, [bp + 5] ; $s
1750   0F4D FD 2A         mov d, [d]
1751   0F4F             _puts_L1_print:
1752   0F4F 1E            mov al, [d]
1753   0F50 B9 00         cmp al, 0
1754   0F52 C6 5E 0F      jz _puts_END_print
1755   0F55 23            mov ah, al
1756   0F56 19 00         mov al, 0
1757   0F58 05 03         syscall sys_io
1758   0F5A 79            inc d
1759   0F5B 0A 4F 0F      jmp _puts_L1_print
1760   0F5E             _puts_END_print:
1761   0F5E             ; --- END INLINE ASM SEGMENT
1762   0F5E F9            leave
1763   0F5F 09            ret
1764   0F60             
1765   0F60             print_signed:
1766   0F60 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1767   0F63             ; char digits[5]; 
1768   0F63 52 05 00      sub sp, 5
1769   0F66             ; int i = 0; 
1770   0F66 52 02 00      sub sp, 2
1771   0F69             ; --- START LOCAL VAR INITIALIZATION
1772   0F69 FA FA FF      lea d, [bp + -6] ; $i
1773   0F6C DA            push d
1774   0F6D FD 2E 00 00   mov32 cb, $00000000
1774   0F71 00 00 
1775   0F73 E7            pop d
1776   0F74 FD 43         mov [d], b
1777   0F76             ; --- END LOCAL VAR INITIALIZATION
1778   0F76             ; if (num < 0) { 
1779   0F76             _if49_cond:
1780   0F76 FA 05 00      lea d, [bp + 5] ; $num
1781   0F79 2A            mov b, [d]
1782   0F7A 38 00 00      mov c, 0
1783   0F7D             ; --- START RELATIONAL
1784   0F7D D7            push a
1785   0F7E 11            mov a, b
1786   0F7F FD 2E 00 00   mov32 cb, $00000000
1786   0F83 00 00 
1787   0F85 B0            cmp a, b
1788   0F86 FD 73         slt ; < (signed)
1789   0F88 E4            pop a
1790   0F89             ; --- END RELATIONAL
1791   0F89 C0 00 00      cmp b, 0
1792   0F8C C6 AF 0F      je _if49_else
1793   0F8F             _if49_TRUE:
1794   0F8F             ; putchar('-'); 
1795   0F8F             ; --- START FUNCTION CALL
1796   0F8F FD 2E 2D 00   mov32 cb, $0000002d
1796   0F93 00 00 
1797   0F95 DD            push bl
1798   0F96 07 90 0D      call putchar
1799   0F99 51 01 00      add sp, 1
1800   0F9C             ; --- END FUNCTION CALL
1801   0F9C             ; num = -num; 
1802   0F9C FA 05 00      lea d, [bp + 5] ; $num
1803   0F9F DA            push d
1804   0FA0 FA 05 00      lea d, [bp + 5] ; $num
1805   0FA3 2A            mov b, [d]
1806   0FA4 38 00 00      mov c, 0
1807   0FA7 FD 97         neg b
1808   0FA9 E7            pop d
1809   0FAA FD 43         mov [d], b
1810   0FAC 0A DA 0F      jmp _if49_exit
1811   0FAF             _if49_else:
1812   0FAF             ; if (num == 0) { 
1813   0FAF             _if50_cond:
1814   0FAF FA 05 00      lea d, [bp + 5] ; $num
1815   0FB2 2A            mov b, [d]
1816   0FB3 38 00 00      mov c, 0
1817   0FB6             ; --- START RELATIONAL
1818   0FB6 D7            push a
1819   0FB7 11            mov a, b
1820   0FB8 FD 2E 00 00   mov32 cb, $00000000
1820   0FBC 00 00 
1821   0FBE B0            cmp a, b
1822   0FBF FD 71         seq ; ==
1823   0FC1 E4            pop a
1824   0FC2             ; --- END RELATIONAL
1825   0FC2 C0 00 00      cmp b, 0
1826   0FC5 C6 DA 0F      je _if50_exit
1827   0FC8             _if50_TRUE:
1828   0FC8             ; putchar('0'); 
1829   0FC8             ; --- START FUNCTION CALL
1830   0FC8 FD 2E 30 00   mov32 cb, $00000030
1830   0FCC 00 00 
1831   0FCE DD            push bl
1832   0FCF 07 90 0D      call putchar
1833   0FD2 51 01 00      add sp, 1
1834   0FD5             ; --- END FUNCTION CALL
1835   0FD5             ; return; 
1836   0FD5 F9            leave
1837   0FD6 09            ret
1838   0FD7 0A DA 0F      jmp _if50_exit
1839   0FDA             _if50_exit:
1840   0FDA             _if49_exit:
1841   0FDA             ; while (num > 0) { 
1842   0FDA             _while51_cond:
1843   0FDA FA 05 00      lea d, [bp + 5] ; $num
1844   0FDD 2A            mov b, [d]
1845   0FDE 38 00 00      mov c, 0
1846   0FE1             ; --- START RELATIONAL
1847   0FE1 D7            push a
1848   0FE2 11            mov a, b
1849   0FE3 FD 2E 00 00   mov32 cb, $00000000
1849   0FE7 00 00 
1850   0FE9 B0            cmp a, b
1851   0FEA FD 7F         sgt ; >
1852   0FEC E4            pop a
1853   0FED             ; --- END RELATIONAL
1854   0FED C0 00 00      cmp b, 0
1855   0FF0 C6 67 10      je _while51_exit
1856   0FF3             _while51_block:
1857   0FF3             ; digits[i] = '0' + (num % 10); 
1858   0FF3 FA FC FF      lea d, [bp + -4] ; $digits
1859   0FF6 D7            push a
1860   0FF7 DA            push d
1861   0FF8 FA FA FF      lea d, [bp + -6] ; $i
1862   0FFB 2A            mov b, [d]
1863   0FFC 38 00 00      mov c, 0
1864   0FFF E7            pop d
1865   1000 5A            add d, b
1866   1001 E4            pop a
1867   1002 DA            push d
1868   1003 FD 2E 30 00   mov32 cb, $00000030
1868   1007 00 00 
1869   1009             ; --- START TERMS
1870   1009 D7            push a
1871   100A 11            mov a, b
1872   100B FA 05 00      lea d, [bp + 5] ; $num
1873   100E 2A            mov b, [d]
1874   100F 38 00 00      mov c, 0
1875   1012             ; --- START FACTORS
1876   1012 D7            push a
1877   1013 FD D8         push g
1878   1015 11            mov a, b
1879   1016 FD 7A         mov g, c
1880   1018 FD 2E 0A 00   mov32 cb, $0000000a
1880   101C 00 00 
1881   101E FD D8         push g ; save 'g' as the div instruction uses it
1882   1020 AE            div a, b ; %, a: quotient, b: remainder
1883   1021 11            mov a, b
1884   1022 FD F1         pop g
1885   1024 FD 38         mov c, g
1886   1026 27            mov b, a
1887   1027 FD F1         pop g
1888   1029 E4            pop a
1889   102A             ; --- END FACTORS
1890   102A 56            add b, a
1891   102B E4            pop a
1892   102C             ; --- END TERMS
1893   102C E7            pop d
1894   102D FD 3E         mov [d], bl
1895   102F             ; num = num / 10; 
1896   102F FA 05 00      lea d, [bp + 5] ; $num
1897   1032 DA            push d
1898   1033 FA 05 00      lea d, [bp + 5] ; $num
1899   1036 2A            mov b, [d]
1900   1037 38 00 00      mov c, 0
1901   103A             ; --- START FACTORS
1902   103A D7            push a
1903   103B FD D8         push g
1904   103D 11            mov a, b
1905   103E FD 7A         mov g, c
1906   1040 FD 2E 0A 00   mov32 cb, $0000000a
1906   1044 00 00 
1907   1046 FD D8         push g ; save 'g' as the div instruction uses it
1908   1048 AE            div a, b ; /, a: quotient, b: remainder
1909   1049 FD F1         pop g
1910   104B FD 38         mov c, g
1911   104D 27            mov b, a
1912   104E FD F1         pop g
1913   1050 E4            pop a
1914   1051             ; --- END FACTORS
1915   1051 E7            pop d
1916   1052 FD 43         mov [d], b
1917   1054             ; i++; 
1918   1054 FA FA FF      lea d, [bp + -6] ; $i
1919   1057 2A            mov b, [d]
1920   1058 38 00 00      mov c, 0
1921   105B 11            mov a, b
1922   105C FD 77         inc b
1923   105E FA FA FF      lea d, [bp + -6] ; $i
1924   1061 FD 43         mov [d], b
1925   1063 27            mov b, a
1926   1064 0A DA 0F      jmp _while51_cond
1927   1067             _while51_exit:
1928   1067             ; while (i > 0) { 
1929   1067             _while58_cond:
1930   1067 FA FA FF      lea d, [bp + -6] ; $i
1931   106A 2A            mov b, [d]
1932   106B 38 00 00      mov c, 0
1933   106E             ; --- START RELATIONAL
1934   106E D7            push a
1935   106F 11            mov a, b
1936   1070 FD 2E 00 00   mov32 cb, $00000000
1936   1074 00 00 
1937   1076 B0            cmp a, b
1938   1077 FD 7F         sgt ; >
1939   1079 E4            pop a
1940   107A             ; --- END RELATIONAL
1941   107A C0 00 00      cmp b, 0
1942   107D C6 AF 10      je _while58_exit
1943   1080             _while58_block:
1944   1080             ; i--; 
1945   1080 FA FA FF      lea d, [bp + -6] ; $i
1946   1083 2A            mov b, [d]
1947   1084 38 00 00      mov c, 0
1948   1087 11            mov a, b
1949   1088 FD 7D         dec b
1950   108A FA FA FF      lea d, [bp + -6] ; $i
1951   108D FD 43         mov [d], b
1952   108F 27            mov b, a
1953   1090             ; putchar(digits[i]); 
1954   1090             ; --- START FUNCTION CALL
1955   1090 FA FC FF      lea d, [bp + -4] ; $digits
1956   1093 D7            push a
1957   1094 DA            push d
1958   1095 FA FA FF      lea d, [bp + -6] ; $i
1959   1098 2A            mov b, [d]
1960   1099 38 00 00      mov c, 0
1961   109C E7            pop d
1962   109D 5A            add d, b
1963   109E E4            pop a
1964   109F 32            mov bl, [d]
1965   10A0 A7 00         mov bh, 0
1966   10A2 38 00 00      mov c, 0
1967   10A5 DD            push bl
1968   10A6 07 90 0D      call putchar
1969   10A9 51 01 00      add sp, 1
1970   10AC             ; --- END FUNCTION CALL
1971   10AC 0A 67 10      jmp _while58_cond
1972   10AF             _while58_exit:
1973   10AF F9            leave
1974   10B0 09            ret
1975   10B1             
1976   10B1             print_unsigned:
1977   10B1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1978   10B4             ; char digits[5]; 
1979   10B4 52 05 00      sub sp, 5
1980   10B7             ; int i; 
1981   10B7 52 02 00      sub sp, 2
1982   10BA             ; i = 0; 
1983   10BA FA FA FF      lea d, [bp + -6] ; $i
1984   10BD DA            push d
1985   10BE FD 2E 00 00   mov32 cb, $00000000
1985   10C2 00 00 
1986   10C4 E7            pop d
1987   10C5 FD 43         mov [d], b
1988   10C7             ; if(num == 0){ 
1989   10C7             _if59_cond:
1990   10C7 FA 05 00      lea d, [bp + 5] ; $num
1991   10CA 2A            mov b, [d]
1992   10CB 38 00 00      mov c, 0
1993   10CE             ; --- START RELATIONAL
1994   10CE D7            push a
1995   10CF 11            mov a, b
1996   10D0 FD 2E 00 00   mov32 cb, $00000000
1996   10D4 00 00 
1997   10D6 B0            cmp a, b
1998   10D7 FD 71         seq ; ==
1999   10D9 E4            pop a
2000   10DA             ; --- END RELATIONAL
2001   10DA C0 00 00      cmp b, 0
2002   10DD C6 F2 10      je _if59_exit
2003   10E0             _if59_TRUE:
2004   10E0             ; putchar('0'); 
2005   10E0             ; --- START FUNCTION CALL
2006   10E0 FD 2E 30 00   mov32 cb, $00000030
2006   10E4 00 00 
2007   10E6 DD            push bl
2008   10E7 07 90 0D      call putchar
2009   10EA 51 01 00      add sp, 1
2010   10ED             ; --- END FUNCTION CALL
2011   10ED             ; return; 
2012   10ED F9            leave
2013   10EE 09            ret
2014   10EF 0A F2 10      jmp _if59_exit
2015   10F2             _if59_exit:
2016   10F2             ; while (num > 0) { 
2017   10F2             _while60_cond:
2018   10F2 FA 05 00      lea d, [bp + 5] ; $num
2019   10F5 2A            mov b, [d]
2020   10F6 38 00 00      mov c, 0
2021   10F9             ; --- START RELATIONAL
2022   10F9 D7            push a
2023   10FA 11            mov a, b
2024   10FB FD 2E 00 00   mov32 cb, $00000000
2024   10FF 00 00 
2025   1101 B0            cmp a, b
2026   1102 FD 81         sgu ; > (unsigned)
2027   1104 E4            pop a
2028   1105             ; --- END RELATIONAL
2029   1105 C0 00 00      cmp b, 0
2030   1108 C6 7F 11      je _while60_exit
2031   110B             _while60_block:
2032   110B             ; digits[i] = '0' + (num % 10); 
2033   110B FA FC FF      lea d, [bp + -4] ; $digits
2034   110E D7            push a
2035   110F DA            push d
2036   1110 FA FA FF      lea d, [bp + -6] ; $i
2037   1113 2A            mov b, [d]
2038   1114 38 00 00      mov c, 0
2039   1117 E7            pop d
2040   1118 5A            add d, b
2041   1119 E4            pop a
2042   111A DA            push d
2043   111B FD 2E 30 00   mov32 cb, $00000030
2043   111F 00 00 
2044   1121             ; --- START TERMS
2045   1121 D7            push a
2046   1122 11            mov a, b
2047   1123 FA 05 00      lea d, [bp + 5] ; $num
2048   1126 2A            mov b, [d]
2049   1127 38 00 00      mov c, 0
2050   112A             ; --- START FACTORS
2051   112A D7            push a
2052   112B FD D8         push g
2053   112D 11            mov a, b
2054   112E FD 7A         mov g, c
2055   1130 FD 2E 0A 00   mov32 cb, $0000000a
2055   1134 00 00 
2056   1136 FD D8         push g ; save 'g' as the div instruction uses it
2057   1138 AE            div a, b ; %, a: quotient, b: remainder
2058   1139 11            mov a, b
2059   113A FD F1         pop g
2060   113C FD 38         mov c, g
2061   113E 27            mov b, a
2062   113F FD F1         pop g
2063   1141 E4            pop a
2064   1142             ; --- END FACTORS
2065   1142 56            add b, a
2066   1143 E4            pop a
2067   1144             ; --- END TERMS
2068   1144 E7            pop d
2069   1145 FD 3E         mov [d], bl
2070   1147             ; num = num / 10; 
2071   1147 FA 05 00      lea d, [bp + 5] ; $num
2072   114A DA            push d
2073   114B FA 05 00      lea d, [bp + 5] ; $num
2074   114E 2A            mov b, [d]
2075   114F 38 00 00      mov c, 0
2076   1152             ; --- START FACTORS
2077   1152 D7            push a
2078   1153 FD D8         push g
2079   1155 11            mov a, b
2080   1156 FD 7A         mov g, c
2081   1158 FD 2E 0A 00   mov32 cb, $0000000a
2081   115C 00 00 
2082   115E FD D8         push g ; save 'g' as the div instruction uses it
2083   1160 AE            div a, b ; /, a: quotient, b: remainder
2084   1161 FD F1         pop g
2085   1163 FD 38         mov c, g
2086   1165 27            mov b, a
2087   1166 FD F1         pop g
2088   1168 E4            pop a
2089   1169             ; --- END FACTORS
2090   1169 E7            pop d
2091   116A FD 43         mov [d], b
2092   116C             ; i++; 
2093   116C FA FA FF      lea d, [bp + -6] ; $i
2094   116F 2A            mov b, [d]
2095   1170 38 00 00      mov c, 0
2096   1173 11            mov a, b
2097   1174 FD 77         inc b
2098   1176 FA FA FF      lea d, [bp + -6] ; $i
2099   1179 FD 43         mov [d], b
2100   117B 27            mov b, a
2101   117C 0A F2 10      jmp _while60_cond
2102   117F             _while60_exit:
2103   117F             ; while (i > 0) { 
2104   117F             _while67_cond:
2105   117F FA FA FF      lea d, [bp + -6] ; $i
2106   1182 2A            mov b, [d]
2107   1183 38 00 00      mov c, 0
2108   1186             ; --- START RELATIONAL
2109   1186 D7            push a
2110   1187 11            mov a, b
2111   1188 FD 2E 00 00   mov32 cb, $00000000
2111   118C 00 00 
2112   118E B0            cmp a, b
2113   118F FD 7F         sgt ; >
2114   1191 E4            pop a
2115   1192             ; --- END RELATIONAL
2116   1192 C0 00 00      cmp b, 0
2117   1195 C6 C7 11      je _while67_exit
2118   1198             _while67_block:
2119   1198             ; i--; 
2120   1198 FA FA FF      lea d, [bp + -6] ; $i
2121   119B 2A            mov b, [d]
2122   119C 38 00 00      mov c, 0
2123   119F 11            mov a, b
2124   11A0 FD 7D         dec b
2125   11A2 FA FA FF      lea d, [bp + -6] ; $i
2126   11A5 FD 43         mov [d], b
2127   11A7 27            mov b, a
2128   11A8             ; putchar(digits[i]); 
2129   11A8             ; --- START FUNCTION CALL
2130   11A8 FA FC FF      lea d, [bp + -4] ; $digits
2131   11AB D7            push a
2132   11AC DA            push d
2133   11AD FA FA FF      lea d, [bp + -6] ; $i
2134   11B0 2A            mov b, [d]
2135   11B1 38 00 00      mov c, 0
2136   11B4 E7            pop d
2137   11B5 5A            add d, b
2138   11B6 E4            pop a
2139   11B7 32            mov bl, [d]
2140   11B8 A7 00         mov bh, 0
2141   11BA 38 00 00      mov c, 0
2142   11BD DD            push bl
2143   11BE 07 90 0D      call putchar
2144   11C1 51 01 00      add sp, 1
2145   11C4             ; --- END FUNCTION CALL
2146   11C4 0A 7F 11      jmp _while67_cond
2147   11C7             _while67_exit:
2148   11C7 F9            leave
2149   11C8 09            ret
2150   11C9             
2151   11C9             printx16:
2152   11C9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2153   11CC             ; --- BEGIN INLINE ASM SEGMENT
2154   11CC FA 05 00      lea d, [bp + 5] ; $hex
2155   11CF 2A            mov b, [d]
2156   11D0             print_u16x_printx16:
2157   11D0 DD            push bl
2158   11D1 30            mov bl, bh
2159   11D2 07 EF 11      call _itoa_printx16        ; convert bh to char in A
2160   11D5 2F            mov bl, al        ; save al
2161   11D6 19 00         mov al, 0
2162   11D8 05 03         syscall sys_io        ; display AH
2163   11DA 24            mov ah, bl        ; retrieve al
2164   11DB 19 00         mov al, 0
2165   11DD 05 03         syscall sys_io        ; display AL
2166   11DF EA            pop bl
2167   11E0 07 EF 11      call _itoa_printx16        ; convert bh to char in A
2168   11E3 2F            mov bl, al        ; save al
2169   11E4 19 00         mov al, 0
2170   11E6 05 03         syscall sys_io        ; display AH
2171   11E8 24            mov ah, bl        ; retrieve al
2172   11E9 19 00         mov al, 0
2173   11EB 05 03         syscall sys_io        ; display AL
2174   11ED             ; --- END INLINE ASM SEGMENT
2175   11ED             ; return; 
2176   11ED F9            leave
2177   11EE 09            ret
2178   11EF             ; --- BEGIN INLINE ASM SEGMENT
2179   11EF             _itoa_printx16:
2180   11EF DA            push d
2181   11F0 D8            push b
2182   11F1 A7 00         mov bh, 0
2183   11F3 FD A4 04      shr bl, 4  
2184   11F6 74            mov d, b
2185   11F7 1F 09 12      mov al, [d + s_hex_digits_printx16]
2186   11FA 23            mov ah, al
2187   11FB E5            pop b
2188   11FC D8            push b
2189   11FD A7 00         mov bh, 0
2190   11FF FD 87 0F      and bl, $0F
2191   1202 74            mov d, b
2192   1203 1F 09 12      mov al, [d + s_hex_digits_printx16]
2193   1206 E5            pop b
2194   1207 E7            pop d
2195   1208 09            ret
2196   1209 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
2196   120D 34 35 36 37 
2196   1211 38 39 41 42 
2196   1215 43 44 45 46 
2197   1219             ; --- END INLINE ASM SEGMENT
2198   1219 F9            leave
2199   121A 09            ret
2200   121B             ; --- END TEXT SEGMENT
2201   121B             
2202   121B             ; --- BEGIN DATA SEGMENT
2203   121B 53 74 61 72 _s0: .db "Starting...\n", 0
2203   121F 74 69 6E 67 
2203   1223 2E 2E 2E 0A 
2203   1227 00 
2204   1228 53 75 6D 20 _s1: .db "Sum mantissa: %d\n", 0
2204   122C 6D 61 6E 74 
2204   1230 69 73 73 61 
2204   1234 3A 20 25 64 
2204   1238 0A 00 
2205   123A 53 75 6D 20 _s2: .db "Sum exponent: %d\n", 0
2205   123E 65 78 70 6F 
2205   1242 6E 65 6E 74 
2205   1246 3A 20 25 64 
2205   124A 0A 00 
2206   124C 25 64 0A 00 _s3: .db "%d\n", 0
2207   1250 55 6E 65 78 _s4: .db "Unexpected format in printf.", 0
2207   1254 70 65 63 74 
2207   1258 65 64 20 66 
2207   125C 6F 72 6D 61 
2207   1260 74 20 69 6E 
2207   1264 20 70 72 69 
2207   1268 6E 74 66 2E 
2207   126C 00 
2208   126D 45 72 72 6F _s5: .db "Error: Unknown argument type.\n", 0
2208   1271 72 3A 20 55 
2208   1275 6E 6B 6E 6F 
2208   1279 77 6E 20 61 
2208   127D 72 67 75 6D 
2208   1281 65 6E 74 20 
2208   1285 74 79 70 65 
2208   1289 2E 0A 00 
2209   128C             
2210   128C 8E 12       _heap_top: .dw _heap
2211   128E 00          _heap: .db 0
2212   128F             ; --- END DATA SEGMENT
2213   128F             
2214   128F             .end
tasm: Number of errors = 0
