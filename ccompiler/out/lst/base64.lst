0001   0000             ; --- FILENAME: programs/base64
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $input 
0011   0408             ; $output 
0012   0408 52 00 03      sub sp, 768
0013   040B             ;; printf("Enter a string to encode in base64: "); 
0014   040B 26 76 15      mov b, __s0 ; "Enter a string to encode in base64: "
0015   040E FD AB         swp b
0016   0410 D8            push b
0017   0411 07 28 06      call printf
0018   0414 51 02 00      add sp, 2
0019   0417             ;; gets(input); 
0020   0417 FA 01 FF      lea d, [bp + -255] ; $input
0021   041A 2D            mov b, d
0022   041B FD AB         swp b
0023   041D D8            push b
0024   041E 07 27 0A      call gets
0025   0421 51 02 00      add sp, 2
0026   0424             ;; base64_encode(input, output); 
0027   0424 FA 01 FD      lea d, [bp + -767] ; $output
0028   0427 2D            mov b, d
0029   0428 FD AB         swp b
0030   042A D8            push b
0031   042B FA 01 FF      lea d, [bp + -255] ; $input
0032   042E 2D            mov b, d
0033   042F FD AB         swp b
0034   0431 D8            push b
0035   0432 07 41 11      call base64_encode
0036   0435 51 04 00      add sp, 4
0037   0438             ;; printf("Base64 encoded string: "); 
0038   0438 26 9B 15      mov b, __s1 ; "Base64 encoded string: "
0039   043B FD AB         swp b
0040   043D D8            push b
0041   043E 07 28 06      call printf
0042   0441 51 02 00      add sp, 2
0043   0444             ;; printf(output); 
0044   0444 FA 01 FD      lea d, [bp + -767] ; $output
0045   0447 2D            mov b, d
0046   0448 FD AB         swp b
0047   044A D8            push b
0048   044B 07 28 06      call printf
0049   044E 51 02 00      add sp, 2
0050   0451             ;; printf("\n"); 
0051   0451 26 B3 15      mov b, __s2 ; "\n"
0052   0454 FD AB         swp b
0053   0456 D8            push b
0054   0457 07 28 06      call printf
0055   045A 51 02 00      add sp, 2
0056   045D             ;; return 0; 
0057   045D 26 00 00      mov b, $0
0058   0460 F9            leave
0059   0461 05 0B         syscall sys_terminate_proc
0060   0463             
0061   0463             strcpy:
0062   0463 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0063   0466             ; $psrc 
0064   0466             ; $pdest 
0065   0466 52 04 00      sub sp, 4
0066   0469             ;; psrc = src; 
0067   0469 FA FF FF      lea d, [bp + -1] ; $psrc
0068   046C DA            push d
0069   046D FA 05 00      lea d, [bp + 5] ; $src
0070   0470 2A            mov b, [d]
0071   0471 E7            pop d
0072   0472 FD 43         mov [d], b
0073   0474             ;; pdest = dest; 
0074   0474 FA FD FF      lea d, [bp + -3] ; $pdest
0075   0477 DA            push d
0076   0478 FA 07 00      lea d, [bp + 7] ; $dest
0077   047B 2A            mov b, [d]
0078   047C E7            pop d
0079   047D FD 43         mov [d], b
0080   047F             ;; while(*psrc) *pdest++ = *psrc++; 
0081   047F             _while1_cond:
0082   047F FA FF FF      lea d, [bp + -1] ; $psrc
0083   0482 2A            mov b, [d]
0084   0483 74            mov d, b
0085   0484 32            mov bl, [d]
0086   0485 A7 00         mov bh, 0
0087   0487 C0 00 00      cmp b, 0
0088   048A C6 B6 04      je _while1_exit
0089   048D             _while1_block:
0090   048D             ;; *pdest++ = *psrc++; 
0091   048D FA FD FF      lea d, [bp + -3] ; $pdest
0092   0490 2A            mov b, [d]
0093   0491 FD 79         mov g, b
0094   0493 FD 77         inc b
0095   0495 FA FD FF      lea d, [bp + -3] ; $pdest
0096   0498 FD 43         mov [d], b
0097   049A FD 27         mov b, g
0098   049C D8            push b
0099   049D FA FF FF      lea d, [bp + -1] ; $psrc
0100   04A0 2A            mov b, [d]
0101   04A1 FD 79         mov g, b
0102   04A3 FD 77         inc b
0103   04A5 FA FF FF      lea d, [bp + -1] ; $psrc
0104   04A8 FD 43         mov [d], b
0105   04AA FD 27         mov b, g
0106   04AC 74            mov d, b
0107   04AD 32            mov bl, [d]
0108   04AE A7 00         mov bh, 0
0109   04B0 E7            pop d
0110   04B1 FD 3E         mov [d], bl
0111   04B3 0A 7F 04      jmp _while1_cond
0112   04B6             _while1_exit:
0113   04B6             ;; *pdest = '\0'; 
0114   04B6 FA FD FF      lea d, [bp + -3] ; $pdest
0115   04B9 2A            mov b, [d]
0116   04BA D8            push b
0117   04BB 26 00 00      mov b, $0
0118   04BE E7            pop d
0119   04BF FD 3E         mov [d], bl
0120   04C1 F9            leave
0121   04C2 09            ret
0122   04C3             
0123   04C3             strcmp:
0124   04C3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0125   04C6             ;; while (*s1 && (*s1 == *s2)) { 
0126   04C6             _while2_cond:
0127   04C6 FA 07 00      lea d, [bp + 7] ; $s1
0128   04C9 2A            mov b, [d]
0129   04CA 74            mov d, b
0130   04CB 32            mov bl, [d]
0131   04CC A7 00         mov bh, 0
0132   04CE D7            push a
0133   04CF 11            mov a, b
0134   04D0 FA 07 00      lea d, [bp + 7] ; $s1
0135   04D3 2A            mov b, [d]
0136   04D4 74            mov d, b
0137   04D5 32            mov bl, [d]
0138   04D6 A7 00         mov bh, 0
0139   04D8             ; START RELATIONAL
0140   04D8 D7            push a
0141   04D9 11            mov a, b
0142   04DA FA 05 00      lea d, [bp + 5] ; $s2
0143   04DD 2A            mov b, [d]
0144   04DE 74            mov d, b
0145   04DF 32            mov bl, [d]
0146   04E0 A7 00         mov bh, 0
0147   04E2 B0            cmp a, b
0148   04E3 FD 71         seq ; ==
0149   04E5 E4            pop a
0150   04E6             ; END RELATIONAL
0151   04E6 FD A7         sand a, b ; &&
0152   04E8 E4            pop a
0153   04E9 C0 00 00      cmp b, 0
0154   04EC C6 10 05      je _while2_exit
0155   04EF             _while2_block:
0156   04EF             ;; s1++; 
0157   04EF FA 07 00      lea d, [bp + 7] ; $s1
0158   04F2 2A            mov b, [d]
0159   04F3 FD 79         mov g, b
0160   04F5 FD 77         inc b
0161   04F7 FA 07 00      lea d, [bp + 7] ; $s1
0162   04FA FD 43         mov [d], b
0163   04FC FD 27         mov b, g
0164   04FE             ;; s2++; 
0165   04FE FA 05 00      lea d, [bp + 5] ; $s2
0166   0501 2A            mov b, [d]
0167   0502 FD 79         mov g, b
0168   0504 FD 77         inc b
0169   0506 FA 05 00      lea d, [bp + 5] ; $s2
0170   0509 FD 43         mov [d], b
0171   050B FD 27         mov b, g
0172   050D 0A C6 04      jmp _while2_cond
0173   0510             _while2_exit:
0174   0510             ;; return *s1 - *s2; 
0175   0510 FA 07 00      lea d, [bp + 7] ; $s1
0176   0513 2A            mov b, [d]
0177   0514 74            mov d, b
0178   0515 32            mov bl, [d]
0179   0516 A7 00         mov bh, 0
0180   0518             ; START TERMS
0181   0518 D7            push a
0182   0519 11            mov a, b
0183   051A FA 05 00      lea d, [bp + 5] ; $s2
0184   051D 2A            mov b, [d]
0185   051E 74            mov d, b
0186   051F 32            mov bl, [d]
0187   0520 A7 00         mov bh, 0
0188   0522 60            sub a, b
0189   0523 27            mov b, a
0190   0524 E4            pop a
0191   0525             ; END TERMS
0192   0525 F9            leave
0193   0526 09            ret
0194   0527             
0195   0527             strcat:
0196   0527 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0197   052A             ; $dest_len 
0198   052A             ; $i 
0199   052A 52 04 00      sub sp, 4
0200   052D             ;; dest_len = strlen(dest); 
0201   052D FA FF FF      lea d, [bp + -1] ; $dest_len
0202   0530 DA            push d
0203   0531 FA 07 00      lea d, [bp + 7] ; $dest
0204   0534 2A            mov b, [d]
0205   0535 FD AB         swp b
0206   0537 D8            push b
0207   0538 07 DD 05      call strlen
0208   053B 51 02 00      add sp, 2
0209   053E E7            pop d
0210   053F FD 43         mov [d], b
0211   0541             ;; for (i = 0; src[i] != 0; i=i+1) { 
0212   0541             _for3_init:
0213   0541 FA FD FF      lea d, [bp + -3] ; $i
0214   0544 DA            push d
0215   0545 26 00 00      mov b, $0
0216   0548 E7            pop d
0217   0549 FD 43         mov [d], b
0218   054B             _for3_cond:
0219   054B FA 05 00      lea d, [bp + 5] ; $src
0220   054E FD 2A         mov d, [d]
0221   0550 D7            push a
0222   0551 DA            push d
0223   0552 FA FD FF      lea d, [bp + -3] ; $i
0224   0555 2A            mov b, [d]
0225   0556 E7            pop d
0226   0557 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0227   055B E4            pop a
0228   055C 32            mov bl, [d]
0229   055D A7 00         mov bh, 0
0230   055F             ; START RELATIONAL
0231   055F D7            push a
0232   0560 11            mov a, b
0233   0561 26 00 00      mov b, $0
0234   0564 B0            cmp a, b
0235   0565 FD 72         sneq ; !=
0236   0567 E4            pop a
0237   0568             ; END RELATIONAL
0238   0568 C0 00 00      cmp b, 0
0239   056B C6 B6 05      je _for3_exit
0240   056E             _for3_block:
0241   056E             ;; dest[dest_len + i] = src[i]; 
0242   056E FA 07 00      lea d, [bp + 7] ; $dest
0243   0571 FD 2A         mov d, [d]
0244   0573 D7            push a
0245   0574 DA            push d
0246   0575 FA FF FF      lea d, [bp + -1] ; $dest_len
0247   0578 2A            mov b, [d]
0248   0579             ; START TERMS
0249   0579 D7            push a
0250   057A 11            mov a, b
0251   057B FA FD FF      lea d, [bp + -3] ; $i
0252   057E 2A            mov b, [d]
0253   057F 54            add a, b
0254   0580 27            mov b, a
0255   0581 E4            pop a
0256   0582             ; END TERMS
0257   0582 E7            pop d
0258   0583 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0259   0587 E4            pop a
0260   0588 DA            push d
0261   0589 FA 05 00      lea d, [bp + 5] ; $src
0262   058C FD 2A         mov d, [d]
0263   058E D7            push a
0264   058F DA            push d
0265   0590 FA FD FF      lea d, [bp + -3] ; $i
0266   0593 2A            mov b, [d]
0267   0594 E7            pop d
0268   0595 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0269   0599 E4            pop a
0270   059A 32            mov bl, [d]
0271   059B A7 00         mov bh, 0
0272   059D E7            pop d
0273   059E FD 3E         mov [d], bl
0274   05A0             _for3_update:
0275   05A0 FA FD FF      lea d, [bp + -3] ; $i
0276   05A3 DA            push d
0277   05A4 FA FD FF      lea d, [bp + -3] ; $i
0278   05A7 2A            mov b, [d]
0279   05A8             ; START TERMS
0280   05A8 D7            push a
0281   05A9 11            mov a, b
0282   05AA 26 01 00      mov b, $1
0283   05AD 54            add a, b
0284   05AE 27            mov b, a
0285   05AF E4            pop a
0286   05B0             ; END TERMS
0287   05B0 E7            pop d
0288   05B1 FD 43         mov [d], b
0289   05B3 0A 4B 05      jmp _for3_cond
0290   05B6             _for3_exit:
0291   05B6             ;; dest[dest_len + i] = 0; 
0292   05B6 FA 07 00      lea d, [bp + 7] ; $dest
0293   05B9 FD 2A         mov d, [d]
0294   05BB D7            push a
0295   05BC DA            push d
0296   05BD FA FF FF      lea d, [bp + -1] ; $dest_len
0297   05C0 2A            mov b, [d]
0298   05C1             ; START TERMS
0299   05C1 D7            push a
0300   05C2 11            mov a, b
0301   05C3 FA FD FF      lea d, [bp + -3] ; $i
0302   05C6 2A            mov b, [d]
0303   05C7 54            add a, b
0304   05C8 27            mov b, a
0305   05C9 E4            pop a
0306   05CA             ; END TERMS
0307   05CA E7            pop d
0308   05CB FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0309   05CF E4            pop a
0310   05D0 DA            push d
0311   05D1 26 00 00      mov b, $0
0312   05D4 E7            pop d
0313   05D5 FD 3E         mov [d], bl
0314   05D7             ;; return dest; 
0315   05D7 FA 07 00      lea d, [bp + 7] ; $dest
0316   05DA 2A            mov b, [d]
0317   05DB F9            leave
0318   05DC 09            ret
0319   05DD             
0320   05DD             strlen:
0321   05DD F8 00 00      enter 0 ; (push bp; mov bp, sp)
0322   05E0             ; $length 
0323   05E0 52 02 00      sub sp, 2
0324   05E3             ;; length = 0; 
0325   05E3 FA FF FF      lea d, [bp + -1] ; $length
0326   05E6 DA            push d
0327   05E7 26 00 00      mov b, $0
0328   05EA E7            pop d
0329   05EB FD 43         mov [d], b
0330   05ED             ;; while (str[length] != 0) { 
0331   05ED             _while4_cond:
0332   05ED FA 05 00      lea d, [bp + 5] ; $str
0333   05F0 FD 2A         mov d, [d]
0334   05F2 D7            push a
0335   05F3 DA            push d
0336   05F4 FA FF FF      lea d, [bp + -1] ; $length
0337   05F7 2A            mov b, [d]
0338   05F8 E7            pop d
0339   05F9 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0340   05FD E4            pop a
0341   05FE 32            mov bl, [d]
0342   05FF A7 00         mov bh, 0
0343   0601             ; START RELATIONAL
0344   0601 D7            push a
0345   0602 11            mov a, b
0346   0603 26 00 00      mov b, $0
0347   0606 B0            cmp a, b
0348   0607 FD 72         sneq ; !=
0349   0609 E4            pop a
0350   060A             ; END RELATIONAL
0351   060A C0 00 00      cmp b, 0
0352   060D C6 22 06      je _while4_exit
0353   0610             _while4_block:
0354   0610             ;; length++; 
0355   0610 FA FF FF      lea d, [bp + -1] ; $length
0356   0613 2A            mov b, [d]
0357   0614 FD 79         mov g, b
0358   0616 FD 77         inc b
0359   0618 FA FF FF      lea d, [bp + -1] ; $length
0360   061B FD 43         mov [d], b
0361   061D FD 27         mov b, g
0362   061F 0A ED 05      jmp _while4_cond
0363   0622             _while4_exit:
0364   0622             ;; return length; 
0365   0622 FA FF FF      lea d, [bp + -1] ; $length
0366   0625 2A            mov b, [d]
0367   0626 F9            leave
0368   0627 09            ret
0369   0628             
0370   0628             printf:
0371   0628 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0372   062B             ; $p 
0373   062B             ; $fp 
0374   062B             ; $i 
0375   062B 52 06 00      sub sp, 6
0376   062E             ;; fp = format; 
0377   062E FA FD FF      lea d, [bp + -3] ; $fp
0378   0631 DA            push d
0379   0632 FA 05 00      lea d, [bp + 5] ; $format
0380   0635 2A            mov b, [d]
0381   0636 E7            pop d
0382   0637 FD 43         mov [d], b
0383   0639             ;; p = &format + 2; 
0384   0639 FA FF FF      lea d, [bp + -1] ; $p
0385   063C DA            push d
0386   063D FA 05 00      lea d, [bp + 5] ; $format
0387   0640 2D            mov b, d
0388   0641             ; START TERMS
0389   0641 D7            push a
0390   0642 11            mov a, b
0391   0643 26 02 00      mov b, $2
0392   0646 54            add a, b
0393   0647 27            mov b, a
0394   0648 E4            pop a
0395   0649             ; END TERMS
0396   0649 E7            pop d
0397   064A FD 43         mov [d], b
0398   064C             ;; for(;;){ 
0399   064C             _for5_init:
0400   064C             _for5_cond:
0401   064C             _for5_block:
0402   064C             ;; if(!*fp) break; 
0403   064C             _if6_cond:
0404   064C FA FD FF      lea d, [bp + -3] ; $fp
0405   064F 2A            mov b, [d]
0406   0650 74            mov d, b
0407   0651 32            mov bl, [d]
0408   0652 A7 00         mov bh, 0
0409   0654 C0 00 00      cmp b, 0
0410   0657 FD 71         seq ; !
0411   0659 C0 00 00      cmp b, 0
0412   065C C6 65 06      je _if6_else
0413   065F             _if6_true:
0414   065F             ;; break; 
0415   065F 0A AF 07      jmp _for5_exit ; for break
0416   0662 0A AC 07      jmp _if6_exit
0417   0665             _if6_else:
0418   0665             ;; if(*fp == '%'){ 
0419   0665             _if7_cond:
0420   0665 FA FD FF      lea d, [bp + -3] ; $fp
0421   0668 2A            mov b, [d]
0422   0669 74            mov d, b
0423   066A 32            mov bl, [d]
0424   066B A7 00         mov bh, 0
0425   066D             ; START RELATIONAL
0426   066D D7            push a
0427   066E 11            mov a, b
0428   066F 26 25 00      mov b, $25
0429   0672 B0            cmp a, b
0430   0673 FD 71         seq ; ==
0431   0675 E4            pop a
0432   0676             ; END RELATIONAL
0433   0676 C0 00 00      cmp b, 0
0434   0679 C6 8E 07      je _if7_else
0435   067C             _if7_true:
0436   067C             ;; fp++; 
0437   067C FA FD FF      lea d, [bp + -3] ; $fp
0438   067F 2A            mov b, [d]
0439   0680 FD 79         mov g, b
0440   0682 FD 77         inc b
0441   0684 FA FD FF      lea d, [bp + -3] ; $fp
0442   0687 FD 43         mov [d], b
0443   0689 FD 27         mov b, g
0444   068B             ;; switch(*fp){ 
0445   068B             _switch8_expr:
0446   068B FA FD FF      lea d, [bp + -3] ; $fp
0447   068E 2A            mov b, [d]
0448   068F 74            mov d, b
0449   0690 32            mov bl, [d]
0450   0691 A7 00         mov bh, 0
0451   0693             _switch8_comparisons:
0452   0693 C1 64         cmp bl, $64
0453   0695 C6 B7 06      je _switch8_case0
0454   0698 C1 69         cmp bl, $69
0455   069A C6 B7 06      je _switch8_case1
0456   069D C1 75         cmp bl, $75
0457   069F C6 DC 06      je _switch8_case2
0458   06A2 C1 78         cmp bl, $78
0459   06A4 C6 01 07      je _switch8_case3
0460   06A7 C1 63         cmp bl, $63
0461   06A9 C6 26 07      je _switch8_case4
0462   06AC C1 73         cmp bl, $73
0463   06AE C6 4B 07      je _switch8_case5
0464   06B1 0A 70 07      jmp _switch8_default
0465   06B4 0A 7C 07      jmp _switch8_exit
0466   06B7             _switch8_case0:
0467   06B7             _switch8_case1:
0468   06B7             ;; prints(*(int*)p); 
0469   06B7 FA FF FF      lea d, [bp + -1] ; $p
0470   06BA 2A            mov b, [d]
0471   06BB 74            mov d, b
0472   06BC 2A            mov b, [d]
0473   06BD FD AB         swp b
0474   06BF D8            push b
0475   06C0 07 41 0A      call prints
0476   06C3 51 02 00      add sp, 2
0477   06C6             ;; p = p + 2; 
0478   06C6 FA FF FF      lea d, [bp + -1] ; $p
0479   06C9 DA            push d
0480   06CA FA FF FF      lea d, [bp + -1] ; $p
0481   06CD 2A            mov b, [d]
0482   06CE             ; START TERMS
0483   06CE D7            push a
0484   06CF 11            mov a, b
0485   06D0 26 02 00      mov b, $2
0486   06D3 54            add a, b
0487   06D4 27            mov b, a
0488   06D5 E4            pop a
0489   06D6             ; END TERMS
0490   06D6 E7            pop d
0491   06D7 FD 43         mov [d], b
0492   06D9             ;; break; 
0493   06D9 0A 7C 07      jmp _switch8_exit ; case break
0494   06DC             _switch8_case2:
0495   06DC             ;; printu(*(unsigned int*)p); 
0496   06DC FA FF FF      lea d, [bp + -1] ; $p
0497   06DF 2A            mov b, [d]
0498   06E0 74            mov d, b
0499   06E1 2A            mov b, [d]
0500   06E2 FD AB         swp b
0501   06E4 D8            push b
0502   06E5 07 36 0B      call printu
0503   06E8 51 02 00      add sp, 2
0504   06EB             ;; p = p + 2; 
0505   06EB FA FF FF      lea d, [bp + -1] ; $p
0506   06EE DA            push d
0507   06EF FA FF FF      lea d, [bp + -1] ; $p
0508   06F2 2A            mov b, [d]
0509   06F3             ; START TERMS
0510   06F3 D7            push a
0511   06F4 11            mov a, b
0512   06F5 26 02 00      mov b, $2
0513   06F8 54            add a, b
0514   06F9 27            mov b, a
0515   06FA E4            pop a
0516   06FB             ; END TERMS
0517   06FB E7            pop d
0518   06FC FD 43         mov [d], b
0519   06FE             ;; break; 
0520   06FE 0A 7C 07      jmp _switch8_exit ; case break
0521   0701             _switch8_case3:
0522   0701             ;; printx16(*(unsigned int*)p); 
0523   0701 FA FF FF      lea d, [bp + -1] ; $p
0524   0704 2A            mov b, [d]
0525   0705 74            mov d, b
0526   0706 2A            mov b, [d]
0527   0707 FD AB         swp b
0528   0709 D8            push b
0529   070A 07 B1 07      call printx16
0530   070D 51 02 00      add sp, 2
0531   0710             ;; p = p + 2; 
0532   0710 FA FF FF      lea d, [bp + -1] ; $p
0533   0713 DA            push d
0534   0714 FA FF FF      lea d, [bp + -1] ; $p
0535   0717 2A            mov b, [d]
0536   0718             ; START TERMS
0537   0718 D7            push a
0538   0719 11            mov a, b
0539   071A 26 02 00      mov b, $2
0540   071D 54            add a, b
0541   071E 27            mov b, a
0542   071F E4            pop a
0543   0720             ; END TERMS
0544   0720 E7            pop d
0545   0721 FD 43         mov [d], b
0546   0723             ;; break; 
0547   0723 0A 7C 07      jmp _switch8_exit ; case break
0548   0726             _switch8_case4:
0549   0726             ;; putchar(*(char*)p); 
0550   0726 FA FF FF      lea d, [bp + -1] ; $p
0551   0729 2A            mov b, [d]
0552   072A 74            mov d, b
0553   072B 32            mov bl, [d]
0554   072C A7 00         mov bh, 0
0555   072E DD            push bl
0556   072F 07 22 0C      call putchar
0557   0732 51 01 00      add sp, 1
0558   0735             ;; p = p + 2; 
0559   0735 FA FF FF      lea d, [bp + -1] ; $p
0560   0738 DA            push d
0561   0739 FA FF FF      lea d, [bp + -1] ; $p
0562   073C 2A            mov b, [d]
0563   073D             ; START TERMS
0564   073D D7            push a
0565   073E 11            mov a, b
0566   073F 26 02 00      mov b, $2
0567   0742 54            add a, b
0568   0743 27            mov b, a
0569   0744 E4            pop a
0570   0745             ; END TERMS
0571   0745 E7            pop d
0572   0746 FD 43         mov [d], b
0573   0748             ;; break; 
0574   0748 0A 7C 07      jmp _switch8_exit ; case break
0575   074B             _switch8_case5:
0576   074B             ;; print(*(char**)p); 
0577   074B FA FF FF      lea d, [bp + -1] ; $p
0578   074E 2A            mov b, [d]
0579   074F 74            mov d, b
0580   0750 2A            mov b, [d]
0581   0751 FD AB         swp b
0582   0753 D8            push b
0583   0754 07 6A 0C      call print
0584   0757 51 02 00      add sp, 2
0585   075A             ;; p = p + 2; 
0586   075A FA FF FF      lea d, [bp + -1] ; $p
0587   075D DA            push d
0588   075E FA FF FF      lea d, [bp + -1] ; $p
0589   0761 2A            mov b, [d]
0590   0762             ; START TERMS
0591   0762 D7            push a
0592   0763 11            mov a, b
0593   0764 26 02 00      mov b, $2
0594   0767 54            add a, b
0595   0768 27            mov b, a
0596   0769 E4            pop a
0597   076A             ; END TERMS
0598   076A E7            pop d
0599   076B FD 43         mov [d], b
0600   076D             ;; break; 
0601   076D 0A 7C 07      jmp _switch8_exit ; case break
0602   0770             _switch8_default:
0603   0770             ;; print("Error: Unknown argument type.\n"); 
0604   0770 26 B5 15      mov b, __s3 ; "Error: Unknown argument type.\n"
0605   0773 FD AB         swp b
0606   0775 D8            push b
0607   0776 07 6A 0C      call print
0608   0779 51 02 00      add sp, 2
0609   077C             _switch8_exit:
0610   077C             ;; fp++; 
0611   077C FA FD FF      lea d, [bp + -3] ; $fp
0612   077F 2A            mov b, [d]
0613   0780 FD 79         mov g, b
0614   0782 FD 77         inc b
0615   0784 FA FD FF      lea d, [bp + -3] ; $fp
0616   0787 FD 43         mov [d], b
0617   0789 FD 27         mov b, g
0618   078B 0A AC 07      jmp _if7_exit
0619   078E             _if7_else:
0620   078E             ;; putchar(*fp); 
0621   078E FA FD FF      lea d, [bp + -3] ; $fp
0622   0791 2A            mov b, [d]
0623   0792 74            mov d, b
0624   0793 32            mov bl, [d]
0625   0794 A7 00         mov bh, 0
0626   0796 DD            push bl
0627   0797 07 22 0C      call putchar
0628   079A 51 01 00      add sp, 1
0629   079D             ;; fp++; 
0630   079D FA FD FF      lea d, [bp + -3] ; $fp
0631   07A0 2A            mov b, [d]
0632   07A1 FD 79         mov g, b
0633   07A3 FD 77         inc b
0634   07A5 FA FD FF      lea d, [bp + -3] ; $fp
0635   07A8 FD 43         mov [d], b
0636   07AA FD 27         mov b, g
0637   07AC             _if7_exit:
0638   07AC             _if6_exit:
0639   07AC             _for5_update:
0640   07AC 0A 4C 06      jmp _for5_cond
0641   07AF             _for5_exit:
0642   07AF F9            leave
0643   07B0 09            ret
0644   07B1             
0645   07B1             printx16:
0646   07B1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0647   07B4             
0648   07B4             ; --- BEGIN INLINE ASM BLOCK
0649   07B4 FA 05 00      lea d, [bp + 5] ; $hex
0650   07B7 2A            mov b, [d]
0651   07B8 07 41 10      call print_u16x
0652   07BB             ; --- END INLINE ASM BLOCK
0653   07BB             
0654   07BB F9            leave
0655   07BC 09            ret
0656   07BD             
0657   07BD             printx8:
0658   07BD F8 00 00      enter 0 ; (push bp; mov bp, sp)
0659   07C0             
0660   07C0             ; --- BEGIN INLINE ASM BLOCK
0661   07C0 FA 05 00      lea d, [bp + 5] ; $hex
0662   07C3 32            mov bl, [d]
0663   07C4 07 85 10      call print_u8x
0664   07C7             ; --- END INLINE ASM BLOCK
0665   07C7             
0666   07C7 F9            leave
0667   07C8 09            ret
0668   07C9             
0669   07C9             hex_to_int:
0670   07C9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0671   07CC             ; $value 
0672   07CC 10 00 00      mov a, $0
0673   07CF 45 FF FF      mov [bp + -1], a
0674   07D2             ; $i 
0675   07D2             ; $hex_char 
0676   07D2             ; $len 
0677   07D2 52 07 00      sub sp, 7
0678   07D5             ;; len = strlen(hex_string); 
0679   07D5 FA FA FF      lea d, [bp + -6] ; $len
0680   07D8 DA            push d
0681   07D9 FA 05 00      lea d, [bp + 5] ; $hex_string
0682   07DC 2A            mov b, [d]
0683   07DD FD AB         swp b
0684   07DF D8            push b
0685   07E0 07 DD 05      call strlen
0686   07E3 51 02 00      add sp, 2
0687   07E6 E7            pop d
0688   07E7 FD 43         mov [d], b
0689   07E9             ;; for (i = 0; i < len; i++) { 
0690   07E9             _for9_init:
0691   07E9 FA FD FF      lea d, [bp + -3] ; $i
0692   07EC DA            push d
0693   07ED 26 00 00      mov b, $0
0694   07F0 E7            pop d
0695   07F1 FD 43         mov [d], b
0696   07F3             _for9_cond:
0697   07F3 FA FD FF      lea d, [bp + -3] ; $i
0698   07F6 2A            mov b, [d]
0699   07F7             ; START RELATIONAL
0700   07F7 D7            push a
0701   07F8 11            mov a, b
0702   07F9 FA FA FF      lea d, [bp + -6] ; $len
0703   07FC 2A            mov b, [d]
0704   07FD B0            cmp a, b
0705   07FE FD 73         slt ; < 
0706   0800 E4            pop a
0707   0801             ; END RELATIONAL
0708   0801 C0 00 00      cmp b, 0
0709   0804 C6 09 09      je _for9_exit
0710   0807             _for9_block:
0711   0807             ;; hex_char = hex_string[i]; 
0712   0807 FA FC FF      lea d, [bp + -4] ; $hex_char
0713   080A DA            push d
0714   080B FA 05 00      lea d, [bp + 5] ; $hex_string
0715   080E FD 2A         mov d, [d]
0716   0810 D7            push a
0717   0811 DA            push d
0718   0812 FA FD FF      lea d, [bp + -3] ; $i
0719   0815 2A            mov b, [d]
0720   0816 E7            pop d
0721   0817 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0722   081B E4            pop a
0723   081C 32            mov bl, [d]
0724   081D A7 00         mov bh, 0
0725   081F E7            pop d
0726   0820 FD 3E         mov [d], bl
0727   0822             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0728   0822             _if10_cond:
0729   0822 FA FC FF      lea d, [bp + -4] ; $hex_char
0730   0825 32            mov bl, [d]
0731   0826 A7 00         mov bh, 0
0732   0828             ; START RELATIONAL
0733   0828 D7            push a
0734   0829 11            mov a, b
0735   082A 26 61 00      mov b, $61
0736   082D B0            cmp a, b
0737   082E FD 80         sge ; >=
0738   0830 E4            pop a
0739   0831             ; END RELATIONAL
0740   0831 D7            push a
0741   0832 11            mov a, b
0742   0833 FA FC FF      lea d, [bp + -4] ; $hex_char
0743   0836 32            mov bl, [d]
0744   0837 A7 00         mov bh, 0
0745   0839             ; START RELATIONAL
0746   0839 D7            push a
0747   083A 11            mov a, b
0748   083B 26 66 00      mov b, $66
0749   083E B0            cmp a, b
0750   083F FD 74         sle ; <=
0751   0841 E4            pop a
0752   0842             ; END RELATIONAL
0753   0842 FD A7         sand a, b ; &&
0754   0844 E4            pop a
0755   0845 C0 00 00      cmp b, 0
0756   0848 C6 79 08      je _if10_else
0757   084B             _if10_true:
0758   084B             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0759   084B FA FF FF      lea d, [bp + -1] ; $value
0760   084E DA            push d
0761   084F FA FF FF      lea d, [bp + -1] ; $value
0762   0852 2A            mov b, [d]
0763   0853             ; START FACTORS
0764   0853 D7            push a
0765   0854 11            mov a, b
0766   0855 26 10 00      mov b, $10
0767   0858 AC            mul a, b ; *
0768   0859 11            mov a, b
0769   085A 27            mov b, a
0770   085B E4            pop a
0771   085C             ; END FACTORS
0772   085C             ; START TERMS
0773   085C D7            push a
0774   085D 11            mov a, b
0775   085E FA FC FF      lea d, [bp + -4] ; $hex_char
0776   0861 32            mov bl, [d]
0777   0862 A7 00         mov bh, 0
0778   0864             ; START TERMS
0779   0864 D7            push a
0780   0865 11            mov a, b
0781   0866 26 61 00      mov b, $61
0782   0869 60            sub a, b
0783   086A 26 0A 00      mov b, $a
0784   086D 54            add a, b
0785   086E 27            mov b, a
0786   086F E4            pop a
0787   0870             ; END TERMS
0788   0870 54            add a, b
0789   0871 27            mov b, a
0790   0872 E4            pop a
0791   0873             ; END TERMS
0792   0873 E7            pop d
0793   0874 FD 43         mov [d], b
0794   0876 0A F7 08      jmp _if10_exit
0795   0879             _if10_else:
0796   0879             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0797   0879             _if11_cond:
0798   0879 FA FC FF      lea d, [bp + -4] ; $hex_char
0799   087C 32            mov bl, [d]
0800   087D A7 00         mov bh, 0
0801   087F             ; START RELATIONAL
0802   087F D7            push a
0803   0880 11            mov a, b
0804   0881 26 41 00      mov b, $41
0805   0884 B0            cmp a, b
0806   0885 FD 80         sge ; >=
0807   0887 E4            pop a
0808   0888             ; END RELATIONAL
0809   0888 D7            push a
0810   0889 11            mov a, b
0811   088A FA FC FF      lea d, [bp + -4] ; $hex_char
0812   088D 32            mov bl, [d]
0813   088E A7 00         mov bh, 0
0814   0890             ; START RELATIONAL
0815   0890 D7            push a
0816   0891 11            mov a, b
0817   0892 26 46 00      mov b, $46
0818   0895 B0            cmp a, b
0819   0896 FD 74         sle ; <=
0820   0898 E4            pop a
0821   0899             ; END RELATIONAL
0822   0899 FD A7         sand a, b ; &&
0823   089B E4            pop a
0824   089C C0 00 00      cmp b, 0
0825   089F C6 D0 08      je _if11_else
0826   08A2             _if11_true:
0827   08A2             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0828   08A2 FA FF FF      lea d, [bp + -1] ; $value
0829   08A5 DA            push d
0830   08A6 FA FF FF      lea d, [bp + -1] ; $value
0831   08A9 2A            mov b, [d]
0832   08AA             ; START FACTORS
0833   08AA D7            push a
0834   08AB 11            mov a, b
0835   08AC 26 10 00      mov b, $10
0836   08AF AC            mul a, b ; *
0837   08B0 11            mov a, b
0838   08B1 27            mov b, a
0839   08B2 E4            pop a
0840   08B3             ; END FACTORS
0841   08B3             ; START TERMS
0842   08B3 D7            push a
0843   08B4 11            mov a, b
0844   08B5 FA FC FF      lea d, [bp + -4] ; $hex_char
0845   08B8 32            mov bl, [d]
0846   08B9 A7 00         mov bh, 0
0847   08BB             ; START TERMS
0848   08BB D7            push a
0849   08BC 11            mov a, b
0850   08BD 26 41 00      mov b, $41
0851   08C0 60            sub a, b
0852   08C1 26 0A 00      mov b, $a
0853   08C4 54            add a, b
0854   08C5 27            mov b, a
0855   08C6 E4            pop a
0856   08C7             ; END TERMS
0857   08C7 54            add a, b
0858   08C8 27            mov b, a
0859   08C9 E4            pop a
0860   08CA             ; END TERMS
0861   08CA E7            pop d
0862   08CB FD 43         mov [d], b
0863   08CD 0A F7 08      jmp _if11_exit
0864   08D0             _if11_else:
0865   08D0             ;; value = (value * 16) + (hex_char - '0'); 
0866   08D0 FA FF FF      lea d, [bp + -1] ; $value
0867   08D3 DA            push d
0868   08D4 FA FF FF      lea d, [bp + -1] ; $value
0869   08D7 2A            mov b, [d]
0870   08D8             ; START FACTORS
0871   08D8 D7            push a
0872   08D9 11            mov a, b
0873   08DA 26 10 00      mov b, $10
0874   08DD AC            mul a, b ; *
0875   08DE 11            mov a, b
0876   08DF 27            mov b, a
0877   08E0 E4            pop a
0878   08E1             ; END FACTORS
0879   08E1             ; START TERMS
0880   08E1 D7            push a
0881   08E2 11            mov a, b
0882   08E3 FA FC FF      lea d, [bp + -4] ; $hex_char
0883   08E6 32            mov bl, [d]
0884   08E7 A7 00         mov bh, 0
0885   08E9             ; START TERMS
0886   08E9 D7            push a
0887   08EA 11            mov a, b
0888   08EB 26 30 00      mov b, $30
0889   08EE 60            sub a, b
0890   08EF 27            mov b, a
0891   08F0 E4            pop a
0892   08F1             ; END TERMS
0893   08F1 54            add a, b
0894   08F2 27            mov b, a
0895   08F3 E4            pop a
0896   08F4             ; END TERMS
0897   08F4 E7            pop d
0898   08F5 FD 43         mov [d], b
0899   08F7             _if11_exit:
0900   08F7             _if10_exit:
0901   08F7             _for9_update:
0902   08F7 FA FD FF      lea d, [bp + -3] ; $i
0903   08FA 2A            mov b, [d]
0904   08FB FD 79         mov g, b
0905   08FD FD 77         inc b
0906   08FF FA FD FF      lea d, [bp + -3] ; $i
0907   0902 FD 43         mov [d], b
0908   0904 FD 27         mov b, g
0909   0906 0A F3 07      jmp _for9_cond
0910   0909             _for9_exit:
0911   0909             ;; return value; 
0912   0909 FA FF FF      lea d, [bp + -1] ; $value
0913   090C 2A            mov b, [d]
0914   090D F9            leave
0915   090E 09            ret
0916   090F             
0917   090F             atoi:
0918   090F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0919   0912             ; $result 
0920   0912 10 00 00      mov a, $0
0921   0915 45 FF FF      mov [bp + -1], a
0922   0918             ; $sign 
0923   0918 10 01 00      mov a, $1
0924   091B 45 FD FF      mov [bp + -3], a
0925   091E 52 04 00      sub sp, 4
0926   0921             ;; while (*str == ' ') str++; 
0927   0921             _while12_cond:
0928   0921 FA 05 00      lea d, [bp + 5] ; $str
0929   0924 2A            mov b, [d]
0930   0925 74            mov d, b
0931   0926 32            mov bl, [d]
0932   0927 A7 00         mov bh, 0
0933   0929             ; START RELATIONAL
0934   0929 D7            push a
0935   092A 11            mov a, b
0936   092B 26 20 00      mov b, $20
0937   092E B0            cmp a, b
0938   092F FD 71         seq ; ==
0939   0931 E4            pop a
0940   0932             ; END RELATIONAL
0941   0932 C0 00 00      cmp b, 0
0942   0935 C6 4A 09      je _while12_exit
0943   0938             _while12_block:
0944   0938             ;; str++; 
0945   0938 FA 05 00      lea d, [bp + 5] ; $str
0946   093B 2A            mov b, [d]
0947   093C FD 79         mov g, b
0948   093E FD 77         inc b
0949   0940 FA 05 00      lea d, [bp + 5] ; $str
0950   0943 FD 43         mov [d], b
0951   0945 FD 27         mov b, g
0952   0947 0A 21 09      jmp _while12_cond
0953   094A             _while12_exit:
0954   094A             ;; if (*str == '-' || *str == '+') { 
0955   094A             _if13_cond:
0956   094A FA 05 00      lea d, [bp + 5] ; $str
0957   094D 2A            mov b, [d]
0958   094E 74            mov d, b
0959   094F 32            mov bl, [d]
0960   0950 A7 00         mov bh, 0
0961   0952             ; START RELATIONAL
0962   0952 D7            push a
0963   0953 11            mov a, b
0964   0954 26 2D 00      mov b, $2d
0965   0957 B0            cmp a, b
0966   0958 FD 71         seq ; ==
0967   095A E4            pop a
0968   095B             ; END RELATIONAL
0969   095B D7            push a
0970   095C 11            mov a, b
0971   095D FA 05 00      lea d, [bp + 5] ; $str
0972   0960 2A            mov b, [d]
0973   0961 74            mov d, b
0974   0962 32            mov bl, [d]
0975   0963 A7 00         mov bh, 0
0976   0965             ; START RELATIONAL
0977   0965 D7            push a
0978   0966 11            mov a, b
0979   0967 26 2B 00      mov b, $2b
0980   096A B0            cmp a, b
0981   096B FD 71         seq ; ==
0982   096D E4            pop a
0983   096E             ; END RELATIONAL
0984   096E FD A8         sor a, b ; ||
0985   0970 E4            pop a
0986   0971 C0 00 00      cmp b, 0
0987   0974 C6 AF 09      je _if13_exit
0988   0977             _if13_true:
0989   0977             ;; if (*str == '-') sign = -1; 
0990   0977             _if14_cond:
0991   0977 FA 05 00      lea d, [bp + 5] ; $str
0992   097A 2A            mov b, [d]
0993   097B 74            mov d, b
0994   097C 32            mov bl, [d]
0995   097D A7 00         mov bh, 0
0996   097F             ; START RELATIONAL
0997   097F D7            push a
0998   0980 11            mov a, b
0999   0981 26 2D 00      mov b, $2d
1000   0984 B0            cmp a, b
1001   0985 FD 71         seq ; ==
1002   0987 E4            pop a
1003   0988             ; END RELATIONAL
1004   0988 C0 00 00      cmp b, 0
1005   098B C6 9D 09      je _if14_exit
1006   098E             _if14_true:
1007   098E             ;; sign = -1; 
1008   098E FA FD FF      lea d, [bp + -3] ; $sign
1009   0991 DA            push d
1010   0992 26 01 00      mov b, $1
1011   0995 FD 97         neg b
1012   0997 E7            pop d
1013   0998 FD 43         mov [d], b
1014   099A 0A 9D 09      jmp _if14_exit
1015   099D             _if14_exit:
1016   099D             ;; str++; 
1017   099D FA 05 00      lea d, [bp + 5] ; $str
1018   09A0 2A            mov b, [d]
1019   09A1 FD 79         mov g, b
1020   09A3 FD 77         inc b
1021   09A5 FA 05 00      lea d, [bp + 5] ; $str
1022   09A8 FD 43         mov [d], b
1023   09AA FD 27         mov b, g
1024   09AC 0A AF 09      jmp _if13_exit
1025   09AF             _if13_exit:
1026   09AF             ;; while (*str >= '0' && *str <= '9') { 
1027   09AF             _while15_cond:
1028   09AF FA 05 00      lea d, [bp + 5] ; $str
1029   09B2 2A            mov b, [d]
1030   09B3 74            mov d, b
1031   09B4 32            mov bl, [d]
1032   09B5 A7 00         mov bh, 0
1033   09B7             ; START RELATIONAL
1034   09B7 D7            push a
1035   09B8 11            mov a, b
1036   09B9 26 30 00      mov b, $30
1037   09BC B0            cmp a, b
1038   09BD FD 80         sge ; >=
1039   09BF E4            pop a
1040   09C0             ; END RELATIONAL
1041   09C0 D7            push a
1042   09C1 11            mov a, b
1043   09C2 FA 05 00      lea d, [bp + 5] ; $str
1044   09C5 2A            mov b, [d]
1045   09C6 74            mov d, b
1046   09C7 32            mov bl, [d]
1047   09C8 A7 00         mov bh, 0
1048   09CA             ; START RELATIONAL
1049   09CA D7            push a
1050   09CB 11            mov a, b
1051   09CC 26 39 00      mov b, $39
1052   09CF B0            cmp a, b
1053   09D0 FD 74         sle ; <=
1054   09D2 E4            pop a
1055   09D3             ; END RELATIONAL
1056   09D3 FD A7         sand a, b ; &&
1057   09D5 E4            pop a
1058   09D6 C0 00 00      cmp b, 0
1059   09D9 C6 17 0A      je _while15_exit
1060   09DC             _while15_block:
1061   09DC             ;; result = result * 10 + (*str - '0'); 
1062   09DC FA FF FF      lea d, [bp + -1] ; $result
1063   09DF DA            push d
1064   09E0 FA FF FF      lea d, [bp + -1] ; $result
1065   09E3 2A            mov b, [d]
1066   09E4             ; START FACTORS
1067   09E4 D7            push a
1068   09E5 11            mov a, b
1069   09E6 26 0A 00      mov b, $a
1070   09E9 AC            mul a, b ; *
1071   09EA 11            mov a, b
1072   09EB 27            mov b, a
1073   09EC E4            pop a
1074   09ED             ; END FACTORS
1075   09ED             ; START TERMS
1076   09ED D7            push a
1077   09EE 11            mov a, b
1078   09EF FA 05 00      lea d, [bp + 5] ; $str
1079   09F2 2A            mov b, [d]
1080   09F3 74            mov d, b
1081   09F4 32            mov bl, [d]
1082   09F5 A7 00         mov bh, 0
1083   09F7             ; START TERMS
1084   09F7 D7            push a
1085   09F8 11            mov a, b
1086   09F9 26 30 00      mov b, $30
1087   09FC 60            sub a, b
1088   09FD 27            mov b, a
1089   09FE E4            pop a
1090   09FF             ; END TERMS
1091   09FF 54            add a, b
1092   0A00 27            mov b, a
1093   0A01 E4            pop a
1094   0A02             ; END TERMS
1095   0A02 E7            pop d
1096   0A03 FD 43         mov [d], b
1097   0A05             ;; str++; 
1098   0A05 FA 05 00      lea d, [bp + 5] ; $str
1099   0A08 2A            mov b, [d]
1100   0A09 FD 79         mov g, b
1101   0A0B FD 77         inc b
1102   0A0D FA 05 00      lea d, [bp + 5] ; $str
1103   0A10 FD 43         mov [d], b
1104   0A12 FD 27         mov b, g
1105   0A14 0A AF 09      jmp _while15_cond
1106   0A17             _while15_exit:
1107   0A17             ;; return sign * result; 
1108   0A17 FA FD FF      lea d, [bp + -3] ; $sign
1109   0A1A 2A            mov b, [d]
1110   0A1B             ; START FACTORS
1111   0A1B D7            push a
1112   0A1C 11            mov a, b
1113   0A1D FA FF FF      lea d, [bp + -1] ; $result
1114   0A20 2A            mov b, [d]
1115   0A21 AC            mul a, b ; *
1116   0A22 11            mov a, b
1117   0A23 27            mov b, a
1118   0A24 E4            pop a
1119   0A25             ; END FACTORS
1120   0A25 F9            leave
1121   0A26 09            ret
1122   0A27             
1123   0A27             gets:
1124   0A27 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1125   0A2A             
1126   0A2A             ; --- BEGIN INLINE ASM BLOCK
1127   0A2A FA 05 00      lea d, [bp + 5] ; $s
1128   0A2D 15            mov a, [d]
1129   0A2E 3C            mov d, a
1130   0A2F 07 A6 0E      call _gets
1131   0A32             ; --- END INLINE ASM BLOCK
1132   0A32             
1133   0A32             ;; return strlen(s); 
1134   0A32 FA 05 00      lea d, [bp + 5] ; $s
1135   0A35 2A            mov b, [d]
1136   0A36 FD AB         swp b
1137   0A38 D8            push b
1138   0A39 07 DD 05      call strlen
1139   0A3C 51 02 00      add sp, 2
1140   0A3F F9            leave
1141   0A40 09            ret
1142   0A41             
1143   0A41             prints:
1144   0A41 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1145   0A44             ; $digits 
1146   0A44             ; $i 
1147   0A44 10 00 00      mov a, $0
1148   0A47 45 FA FF      mov [bp + -6], a
1149   0A4A 52 07 00      sub sp, 7
1150   0A4D             ;; if (num < 0) { 
1151   0A4D             _if16_cond:
1152   0A4D FA 05 00      lea d, [bp + 5] ; $num
1153   0A50 2A            mov b, [d]
1154   0A51             ; START RELATIONAL
1155   0A51 D7            push a
1156   0A52 11            mov a, b
1157   0A53 26 00 00      mov b, $0
1158   0A56 B0            cmp a, b
1159   0A57 FD 73         slt ; < 
1160   0A59 E4            pop a
1161   0A5A             ; END RELATIONAL
1162   0A5A C0 00 00      cmp b, 0
1163   0A5D C6 7A 0A      je _if16_else
1164   0A60             _if16_true:
1165   0A60             ;; putchar('-'); 
1166   0A60 26 2D 00      mov b, $2d
1167   0A63 DD            push bl
1168   0A64 07 22 0C      call putchar
1169   0A67 51 01 00      add sp, 1
1170   0A6A             ;; num = -num; 
1171   0A6A FA 05 00      lea d, [bp + 5] ; $num
1172   0A6D DA            push d
1173   0A6E FA 05 00      lea d, [bp + 5] ; $num
1174   0A71 2A            mov b, [d]
1175   0A72 FD 97         neg b
1176   0A74 E7            pop d
1177   0A75 FD 43         mov [d], b
1178   0A77 0A 9C 0A      jmp _if16_exit
1179   0A7A             _if16_else:
1180   0A7A             ;; if (num == 0) { 
1181   0A7A             _if17_cond:
1182   0A7A FA 05 00      lea d, [bp + 5] ; $num
1183   0A7D 2A            mov b, [d]
1184   0A7E             ; START RELATIONAL
1185   0A7E D7            push a
1186   0A7F 11            mov a, b
1187   0A80 26 00 00      mov b, $0
1188   0A83 B0            cmp a, b
1189   0A84 FD 71         seq ; ==
1190   0A86 E4            pop a
1191   0A87             ; END RELATIONAL
1192   0A87 C0 00 00      cmp b, 0
1193   0A8A C6 9C 0A      je _if17_exit
1194   0A8D             _if17_true:
1195   0A8D             ;; putchar('0'); 
1196   0A8D 26 30 00      mov b, $30
1197   0A90 DD            push bl
1198   0A91 07 22 0C      call putchar
1199   0A94 51 01 00      add sp, 1
1200   0A97             ;; return; 
1201   0A97 F9            leave
1202   0A98 09            ret
1203   0A99 0A 9C 0A      jmp _if17_exit
1204   0A9C             _if17_exit:
1205   0A9C             _if16_exit:
1206   0A9C             ;; while (num > 0) { 
1207   0A9C             _while18_cond:
1208   0A9C FA 05 00      lea d, [bp + 5] ; $num
1209   0A9F 2A            mov b, [d]
1210   0AA0             ; START RELATIONAL
1211   0AA0 D7            push a
1212   0AA1 11            mov a, b
1213   0AA2 26 00 00      mov b, $0
1214   0AA5 B0            cmp a, b
1215   0AA6 FD 7F         sgt ; >
1216   0AA8 E4            pop a
1217   0AA9             ; END RELATIONAL
1218   0AA9 C0 00 00      cmp b, 0
1219   0AAC C6 F9 0A      je _while18_exit
1220   0AAF             _while18_block:
1221   0AAF             ;; digits[i] = '0' + (num % 10); 
1222   0AAF FA FC FF      lea d, [bp + -4] ; $digits
1223   0AB2 D7            push a
1224   0AB3 DA            push d
1225   0AB4 FA FA FF      lea d, [bp + -6] ; $i
1226   0AB7 2A            mov b, [d]
1227   0AB8 E7            pop d
1228   0AB9 5A            add d, b
1229   0ABA E4            pop a
1230   0ABB DA            push d
1231   0ABC 26 30 00      mov b, $30
1232   0ABF             ; START TERMS
1233   0ABF D7            push a
1234   0AC0 11            mov a, b
1235   0AC1 FA 05 00      lea d, [bp + 5] ; $num
1236   0AC4 2A            mov b, [d]
1237   0AC5             ; START FACTORS
1238   0AC5 D7            push a
1239   0AC6 11            mov a, b
1240   0AC7 26 0A 00      mov b, $a
1241   0ACA AE            div a, b ; 
1242   0ACB 11            mov a, b
1243   0ACC 27            mov b, a
1244   0ACD E4            pop a
1245   0ACE             ; END FACTORS
1246   0ACE 54            add a, b
1247   0ACF 27            mov b, a
1248   0AD0 E4            pop a
1249   0AD1             ; END TERMS
1250   0AD1 E7            pop d
1251   0AD2 FD 3E         mov [d], bl
1252   0AD4             ;; num = num / 10; 
1253   0AD4 FA 05 00      lea d, [bp + 5] ; $num
1254   0AD7 DA            push d
1255   0AD8 FA 05 00      lea d, [bp + 5] ; $num
1256   0ADB 2A            mov b, [d]
1257   0ADC             ; START FACTORS
1258   0ADC D7            push a
1259   0ADD 11            mov a, b
1260   0ADE 26 0A 00      mov b, $a
1261   0AE1 AE            div a, b
1262   0AE2 27            mov b, a
1263   0AE3 E4            pop a
1264   0AE4             ; END FACTORS
1265   0AE4 E7            pop d
1266   0AE5 FD 43         mov [d], b
1267   0AE7             ;; i++; 
1268   0AE7 FA FA FF      lea d, [bp + -6] ; $i
1269   0AEA 2A            mov b, [d]
1270   0AEB FD 79         mov g, b
1271   0AED FD 77         inc b
1272   0AEF FA FA FF      lea d, [bp + -6] ; $i
1273   0AF2 FD 43         mov [d], b
1274   0AF4 FD 27         mov b, g
1275   0AF6 0A 9C 0A      jmp _while18_cond
1276   0AF9             _while18_exit:
1277   0AF9             ;; while (i > 0) { 
1278   0AF9             _while19_cond:
1279   0AF9 FA FA FF      lea d, [bp + -6] ; $i
1280   0AFC 2A            mov b, [d]
1281   0AFD             ; START RELATIONAL
1282   0AFD D7            push a
1283   0AFE 11            mov a, b
1284   0AFF 26 00 00      mov b, $0
1285   0B02 B0            cmp a, b
1286   0B03 FD 7F         sgt ; >
1287   0B05 E4            pop a
1288   0B06             ; END RELATIONAL
1289   0B06 C0 00 00      cmp b, 0
1290   0B09 C6 34 0B      je _while19_exit
1291   0B0C             _while19_block:
1292   0B0C             ;; i--; 
1293   0B0C FA FA FF      lea d, [bp + -6] ; $i
1294   0B0F 2A            mov b, [d]
1295   0B10 FD 79         mov g, b
1296   0B12 FD 7D         dec b
1297   0B14 FA FA FF      lea d, [bp + -6] ; $i
1298   0B17 FD 43         mov [d], b
1299   0B19 FD 27         mov b, g
1300   0B1B             ;; putchar(digits[i]); 
1301   0B1B FA FC FF      lea d, [bp + -4] ; $digits
1302   0B1E D7            push a
1303   0B1F DA            push d
1304   0B20 FA FA FF      lea d, [bp + -6] ; $i
1305   0B23 2A            mov b, [d]
1306   0B24 E7            pop d
1307   0B25 5A            add d, b
1308   0B26 E4            pop a
1309   0B27 32            mov bl, [d]
1310   0B28 A7 00         mov bh, 0
1311   0B2A DD            push bl
1312   0B2B 07 22 0C      call putchar
1313   0B2E 51 01 00      add sp, 1
1314   0B31 0A F9 0A      jmp _while19_cond
1315   0B34             _while19_exit:
1316   0B34 F9            leave
1317   0B35 09            ret
1318   0B36             
1319   0B36             printu:
1320   0B36 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1321   0B39             ; $digits 
1322   0B39             ; $i 
1323   0B39 52 07 00      sub sp, 7
1324   0B3C             ;; i = 0; 
1325   0B3C FA FA FF      lea d, [bp + -6] ; $i
1326   0B3F DA            push d
1327   0B40 26 00 00      mov b, $0
1328   0B43 E7            pop d
1329   0B44 FD 43         mov [d], b
1330   0B46             ;; if(num == 0){ 
1331   0B46             _if20_cond:
1332   0B46 FA 05 00      lea d, [bp + 5] ; $num
1333   0B49 2A            mov b, [d]
1334   0B4A             ; START RELATIONAL
1335   0B4A D7            push a
1336   0B4B 11            mov a, b
1337   0B4C 26 00 00      mov b, $0
1338   0B4F B0            cmp a, b
1339   0B50 FD 71         seq ; ==
1340   0B52 E4            pop a
1341   0B53             ; END RELATIONAL
1342   0B53 C0 00 00      cmp b, 0
1343   0B56 C6 68 0B      je _if20_exit
1344   0B59             _if20_true:
1345   0B59             ;; putchar('0'); 
1346   0B59 26 30 00      mov b, $30
1347   0B5C DD            push bl
1348   0B5D 07 22 0C      call putchar
1349   0B60 51 01 00      add sp, 1
1350   0B63             ;; return; 
1351   0B63 F9            leave
1352   0B64 09            ret
1353   0B65 0A 68 0B      jmp _if20_exit
1354   0B68             _if20_exit:
1355   0B68             ;; while (num > 0) { 
1356   0B68             _while21_cond:
1357   0B68 FA 05 00      lea d, [bp + 5] ; $num
1358   0B6B 2A            mov b, [d]
1359   0B6C             ; START RELATIONAL
1360   0B6C D7            push a
1361   0B6D 11            mov a, b
1362   0B6E 26 00 00      mov b, $0
1363   0B71 B0            cmp a, b
1364   0B72 FD 81         sgu ; > (unsigned)
1365   0B74 E4            pop a
1366   0B75             ; END RELATIONAL
1367   0B75 C0 00 00      cmp b, 0
1368   0B78 C6 C5 0B      je _while21_exit
1369   0B7B             _while21_block:
1370   0B7B             ;; digits[i] = '0' + (num % 10); 
1371   0B7B FA FC FF      lea d, [bp + -4] ; $digits
1372   0B7E D7            push a
1373   0B7F DA            push d
1374   0B80 FA FA FF      lea d, [bp + -6] ; $i
1375   0B83 2A            mov b, [d]
1376   0B84 E7            pop d
1377   0B85 5A            add d, b
1378   0B86 E4            pop a
1379   0B87 DA            push d
1380   0B88 26 30 00      mov b, $30
1381   0B8B             ; START TERMS
1382   0B8B D7            push a
1383   0B8C 11            mov a, b
1384   0B8D FA 05 00      lea d, [bp + 5] ; $num
1385   0B90 2A            mov b, [d]
1386   0B91             ; START FACTORS
1387   0B91 D7            push a
1388   0B92 11            mov a, b
1389   0B93 26 0A 00      mov b, $a
1390   0B96 AE            div a, b ; 
1391   0B97 11            mov a, b
1392   0B98 27            mov b, a
1393   0B99 E4            pop a
1394   0B9A             ; END FACTORS
1395   0B9A 54            add a, b
1396   0B9B 27            mov b, a
1397   0B9C E4            pop a
1398   0B9D             ; END TERMS
1399   0B9D E7            pop d
1400   0B9E FD 3E         mov [d], bl
1401   0BA0             ;; num = num / 10; 
1402   0BA0 FA 05 00      lea d, [bp + 5] ; $num
1403   0BA3 DA            push d
1404   0BA4 FA 05 00      lea d, [bp + 5] ; $num
1405   0BA7 2A            mov b, [d]
1406   0BA8             ; START FACTORS
1407   0BA8 D7            push a
1408   0BA9 11            mov a, b
1409   0BAA 26 0A 00      mov b, $a
1410   0BAD AE            div a, b
1411   0BAE 27            mov b, a
1412   0BAF E4            pop a
1413   0BB0             ; END FACTORS
1414   0BB0 E7            pop d
1415   0BB1 FD 43         mov [d], b
1416   0BB3             ;; i++; 
1417   0BB3 FA FA FF      lea d, [bp + -6] ; $i
1418   0BB6 2A            mov b, [d]
1419   0BB7 FD 79         mov g, b
1420   0BB9 FD 77         inc b
1421   0BBB FA FA FF      lea d, [bp + -6] ; $i
1422   0BBE FD 43         mov [d], b
1423   0BC0 FD 27         mov b, g
1424   0BC2 0A 68 0B      jmp _while21_cond
1425   0BC5             _while21_exit:
1426   0BC5             ;; while (i > 0) { 
1427   0BC5             _while22_cond:
1428   0BC5 FA FA FF      lea d, [bp + -6] ; $i
1429   0BC8 2A            mov b, [d]
1430   0BC9             ; START RELATIONAL
1431   0BC9 D7            push a
1432   0BCA 11            mov a, b
1433   0BCB 26 00 00      mov b, $0
1434   0BCE B0            cmp a, b
1435   0BCF FD 7F         sgt ; >
1436   0BD1 E4            pop a
1437   0BD2             ; END RELATIONAL
1438   0BD2 C0 00 00      cmp b, 0
1439   0BD5 C6 00 0C      je _while22_exit
1440   0BD8             _while22_block:
1441   0BD8             ;; i--; 
1442   0BD8 FA FA FF      lea d, [bp + -6] ; $i
1443   0BDB 2A            mov b, [d]
1444   0BDC FD 79         mov g, b
1445   0BDE FD 7D         dec b
1446   0BE0 FA FA FF      lea d, [bp + -6] ; $i
1447   0BE3 FD 43         mov [d], b
1448   0BE5 FD 27         mov b, g
1449   0BE7             ;; putchar(digits[i]); 
1450   0BE7 FA FC FF      lea d, [bp + -4] ; $digits
1451   0BEA D7            push a
1452   0BEB DA            push d
1453   0BEC FA FA FF      lea d, [bp + -6] ; $i
1454   0BEF 2A            mov b, [d]
1455   0BF0 E7            pop d
1456   0BF1 5A            add d, b
1457   0BF2 E4            pop a
1458   0BF3 32            mov bl, [d]
1459   0BF4 A7 00         mov bh, 0
1460   0BF6 DD            push bl
1461   0BF7 07 22 0C      call putchar
1462   0BFA 51 01 00      add sp, 1
1463   0BFD 0A C5 0B      jmp _while22_cond
1464   0C00             _while22_exit:
1465   0C00 F9            leave
1466   0C01 09            ret
1467   0C02             
1468   0C02             rand:
1469   0C02 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1470   0C05             ; $sec 
1471   0C05 52 01 00      sub sp, 1
1472   0C08             
1473   0C08             ; --- BEGIN INLINE ASM BLOCK
1474   0C08 19 00         mov al, 0
1475   0C0A 05 01         syscall sys_rtc					
1476   0C0C 1A            mov al, ah
1477   0C0D FA 00 00      lea d, [bp + 0] ; $sec
1478   0C10 1E            mov al, [d]
1479   0C11             ; --- END INLINE ASM BLOCK
1480   0C11             
1481   0C11             ;; return sec; 
1482   0C11 FA 00 00      lea d, [bp + 0] ; $sec
1483   0C14 32            mov bl, [d]
1484   0C15 A7 00         mov bh, 0
1485   0C17 F9            leave
1486   0C18 09            ret
1487   0C19             
1488   0C19             date:
1489   0C19 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1490   0C1C             
1491   0C1C             ; --- BEGIN INLINE ASM BLOCK
1492   0C1C 19 00         mov al, 0 
1493   0C1E 05 07         syscall sys_datetime
1494   0C20             ; --- END INLINE ASM BLOCK
1495   0C20             
1496   0C20 F9            leave
1497   0C21 09            ret
1498   0C22             
1499   0C22             putchar:
1500   0C22 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1501   0C25             
1502   0C25             ; --- BEGIN INLINE ASM BLOCK
1503   0C25 FA 05 00      lea d, [bp + 5] ; $c
1504   0C28 1E            mov al, [d]
1505   0C29 23            mov ah, al
1506   0C2A 07 9F 0E      call _putchar
1507   0C2D             ; --- END INLINE ASM BLOCK
1508   0C2D             
1509   0C2D F9            leave
1510   0C2E 09            ret
1511   0C2F             
1512   0C2F             getchar:
1513   0C2F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1514   0C32             ; $c 
1515   0C32 52 01 00      sub sp, 1
1516   0C35             
1517   0C35             ; --- BEGIN INLINE ASM BLOCK
1518   0C35 07 98 0E      call getch
1519   0C38 1A            mov al, ah
1520   0C39 FA 00 00      lea d, [bp + 0] ; $c
1521   0C3C 3E            mov [d], al
1522   0C3D             ; --- END INLINE ASM BLOCK
1523   0C3D             
1524   0C3D             ;; return c; 
1525   0C3D FA 00 00      lea d, [bp + 0] ; $c
1526   0C40 32            mov bl, [d]
1527   0C41 A7 00         mov bh, 0
1528   0C43 F9            leave
1529   0C44 09            ret
1530   0C45             
1531   0C45             scann:
1532   0C45 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1533   0C48             ; $m 
1534   0C48 52 02 00      sub sp, 2
1535   0C4B             
1536   0C4B             ; --- BEGIN INLINE ASM BLOCK
1537   0C4B 07 E3 10      call scan_u16d
1538   0C4E FA FF FF      lea d, [bp + -1] ; $m
1539   0C51 43            mov [d], a
1540   0C52             ; --- END INLINE ASM BLOCK
1541   0C52             
1542   0C52             ;; return m; 
1543   0C52 FA FF FF      lea d, [bp + -1] ; $m
1544   0C55 2A            mov b, [d]
1545   0C56 F9            leave
1546   0C57 09            ret
1547   0C58             
1548   0C58             puts:
1549   0C58 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1550   0C5B             
1551   0C5B             ; --- BEGIN INLINE ASM BLOCK
1552   0C5B FA 05 00      lea d, [bp + 5] ; $s
1553   0C5E 15            mov a, [d]
1554   0C5F 3C            mov d, a
1555   0C60 07 E9 0F      call _puts
1556   0C63 10 00 0A      mov a, $0A00
1557   0C66 05 03         syscall sys_io
1558   0C68             ; --- END INLINE ASM BLOCK
1559   0C68             
1560   0C68 F9            leave
1561   0C69 09            ret
1562   0C6A             
1563   0C6A             print:
1564   0C6A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1565   0C6D             
1566   0C6D             ; --- BEGIN INLINE ASM BLOCK
1567   0C6D FA 05 00      lea d, [bp + 5] ; $s
1568   0C70 FD 2A         mov d, [d]
1569   0C72 07 E9 0F      call _puts
1570   0C75             ; --- END INLINE ASM BLOCK
1571   0C75             
1572   0C75 F9            leave
1573   0C76 09            ret
1574   0C77             
1575   0C77             loadfile:
1576   0C77 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1577   0C7A             
1578   0C7A             ; --- BEGIN INLINE ASM BLOCK
1579   0C7A FA 05 00      lea d, [bp + 5] ; $destination
1580   0C7D 15            mov a, [d]
1581   0C7E 4F            mov di, a
1582   0C7F FA 07 00      lea d, [bp + 7] ; $filename
1583   0C82 FD 2A         mov d, [d]
1584   0C84 19 14         mov al, 20
1585   0C86 05 04         syscall sys_filesystem
1586   0C88             ; --- END INLINE ASM BLOCK
1587   0C88             
1588   0C88 F9            leave
1589   0C89 09            ret
1590   0C8A             
1591   0C8A             create_file:
1592   0C8A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1593   0C8D F9            leave
1594   0C8E 09            ret
1595   0C8F             
1596   0C8F             delete_file:
1597   0C8F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1598   0C92             
1599   0C92             ; --- BEGIN INLINE ASM BLOCK
1600   0C92 FA 05 00      lea d, [bp + 5] ; $filename
1601   0C95 19 0A         mov al, 10
1602   0C97 05 04         syscall sys_filesystem
1603   0C99             ; --- END INLINE ASM BLOCK
1604   0C99             
1605   0C99 F9            leave
1606   0C9A 09            ret
1607   0C9B             
1608   0C9B             fopen:
1609   0C9B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1610   0C9E F9            leave
1611   0C9F 09            ret
1612   0CA0             
1613   0CA0             fclose:
1614   0CA0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1615   0CA3 F9            leave
1616   0CA4 09            ret
1617   0CA5             
1618   0CA5             alloc:
1619   0CA5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1620   0CA8             ;; heap_top = heap_top + bytes; 
1621   0CA8 3B DC 15      mov d, _heap_top ; $heap_top
1622   0CAB DA            push d
1623   0CAC 3B DC 15      mov d, _heap_top ; $heap_top
1624   0CAF 2A            mov b, [d]
1625   0CB0             ; START TERMS
1626   0CB0 D7            push a
1627   0CB1 11            mov a, b
1628   0CB2 FA 05 00      lea d, [bp + 5] ; $bytes
1629   0CB5 2A            mov b, [d]
1630   0CB6 54            add a, b
1631   0CB7 27            mov b, a
1632   0CB8 E4            pop a
1633   0CB9             ; END TERMS
1634   0CB9 E7            pop d
1635   0CBA FD 43         mov [d], b
1636   0CBC             ;; return heap_top - bytes; 
1637   0CBC 3B DC 15      mov d, _heap_top ; $heap_top
1638   0CBF 2A            mov b, [d]
1639   0CC0             ; START TERMS
1640   0CC0 D7            push a
1641   0CC1 11            mov a, b
1642   0CC2 FA 05 00      lea d, [bp + 5] ; $bytes
1643   0CC5 2A            mov b, [d]
1644   0CC6 60            sub a, b
1645   0CC7 27            mov b, a
1646   0CC8 E4            pop a
1647   0CC9             ; END TERMS
1648   0CC9 F9            leave
1649   0CCA 09            ret
1650   0CCB             
1651   0CCB             free:
1652   0CCB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1653   0CCE             ;; return heap_top = heap_top - bytes; 
1654   0CCE 3B DC 15      mov d, _heap_top ; $heap_top
1655   0CD1 DA            push d
1656   0CD2 3B DC 15      mov d, _heap_top ; $heap_top
1657   0CD5 2A            mov b, [d]
1658   0CD6             ; START TERMS
1659   0CD6 D7            push a
1660   0CD7 11            mov a, b
1661   0CD8 FA 05 00      lea d, [bp + 5] ; $bytes
1662   0CDB 2A            mov b, [d]
1663   0CDC 60            sub a, b
1664   0CDD 27            mov b, a
1665   0CDE E4            pop a
1666   0CDF             ; END TERMS
1667   0CDF E7            pop d
1668   0CE0 FD 43         mov [d], b
1669   0CE2 F9            leave
1670   0CE3 09            ret
1671   0CE4             
1672   0CE4             exit:
1673   0CE4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1674   0CE7             
1675   0CE7             ; --- BEGIN INLINE ASM BLOCK
1676   0CE7 05 0B         syscall sys_terminate_proc
1677   0CE9             ; --- END INLINE ASM BLOCK
1678   0CE9             
1679   0CE9 F9            leave
1680   0CEA 09            ret
1681   0CEB             
1682   0CEB             load_hex:
1683   0CEB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1684   0CEE             ; $temp 
1685   0CEE 52 02 00      sub sp, 2
1686   0CF1             ;; temp = alloc(32768); 
1687   0CF1 FA FF FF      lea d, [bp + -1] ; $temp
1688   0CF4 DA            push d
1689   0CF5 26 00 80      mov b, $8000
1690   0CF8 FD AB         swp b
1691   0CFA D8            push b
1692   0CFB 07 A5 0C      call alloc
1693   0CFE 51 02 00      add sp, 2
1694   0D01 E7            pop d
1695   0D02 FD 43         mov [d], b
1696   0D04             
1697   0D04             ; --- BEGIN INLINE ASM BLOCK
1698   0D04               
1699   0D04               
1700   0D04               
1701   0D04               
1702   0D04               
1703   0D04             _load_hex:
1704   0D04 D7            push a
1705   0D05 D8            push b
1706   0D06 DA            push d
1707   0D07 E2            push si
1708   0D08 E3            push di
1709   0D09 52 00 80      sub sp, $8000      
1710   0D0C 38 00 00      mov c, 0
1711   0D0F 48            mov a, sp
1712   0D10 77            inc a
1713   0D11 3C            mov d, a          
1714   0D12 07 A6 0E      call _gets        
1715   0D15 4D            mov si, a
1716   0D16             __load_hex_loop:
1717   0D16 F6            lodsb             
1718   0D17 B9 00         cmp al, 0         
1719   0D19 C6 27 0D      jz __load_hex_ret
1720   0D1C 36            mov bh, al
1721   0D1D F6            lodsb
1722   0D1E 2F            mov bl, al
1723   0D1F 07 5C 0E      call _atoi        
1724   0D22 F7            stosb             
1725   0D23 78            inc c
1726   0D24 0A 16 0D      jmp __load_hex_loop
1727   0D27             __load_hex_ret:
1728   0D27 51 00 80      add sp, $8000
1729   0D2A F0            pop di
1730   0D2B EF            pop si
1731   0D2C E7            pop d
1732   0D2D E5            pop b
1733   0D2E E4            pop a
1734   0D2F             ; --- END INLINE ASM BLOCK
1735   0D2F             
1736   0D2F F9            leave
1737   0D30 09            ret
1738   0D31             
1739   0D31             getparam:
1740   0D31 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1741   0D34             ; $data 
1742   0D34 52 01 00      sub sp, 1
1743   0D37             
1744   0D37             ; --- BEGIN INLINE ASM BLOCK
1745   0D37 19 04         mov al, 4
1746   0D39 FA 05 00      lea d, [bp + 5] ; $address
1747   0D3C FD 2A         mov d, [d]
1748   0D3E 05 0C         syscall sys_system
1749   0D40 FA 00 00      lea d, [bp + 0] ; $data
1750   0D43 FD 3E         mov [d], bl
1751   0D45             ; --- END INLINE ASM BLOCK
1752   0D45             
1753   0D45             ;; return data; 
1754   0D45 FA 00 00      lea d, [bp + 0] ; $data
1755   0D48 32            mov bl, [d]
1756   0D49 A7 00         mov bh, 0
1757   0D4B F9            leave
1758   0D4C 09            ret
1759   0D4D             
1760   0D4D             clear:
1761   0D4D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1762   0D50             ;; print("\033[2J\033[H"); 
1763   0D50 26 D4 15      mov b, __s4 ; "\033[2J\033[H"
1764   0D53 FD AB         swp b
1765   0D55 D8            push b
1766   0D56 07 6A 0C      call print
1767   0D59 51 02 00      add sp, 2
1768   0D5C F9            leave
1769   0D5D 09            ret
1770   0D5E             
1771   0D5E             printun:
1772   0D5E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1773   0D61             ;; print(prompt); 
1774   0D61 FA 07 00      lea d, [bp + 7] ; $prompt
1775   0D64 2A            mov b, [d]
1776   0D65 FD AB         swp b
1777   0D67 D8            push b
1778   0D68 07 6A 0C      call print
1779   0D6B 51 02 00      add sp, 2
1780   0D6E             ;; printu(n); 
1781   0D6E FA 05 00      lea d, [bp + 5] ; $n
1782   0D71 2A            mov b, [d]
1783   0D72 FD AB         swp b
1784   0D74 D8            push b
1785   0D75 07 36 0B      call printu
1786   0D78 51 02 00      add sp, 2
1787   0D7B             ;; print("\n"); 
1788   0D7B 26 B3 15      mov b, __s2 ; "\n"
1789   0D7E FD AB         swp b
1790   0D80 D8            push b
1791   0D81 07 6A 0C      call print
1792   0D84 51 02 00      add sp, 2
1793   0D87 F9            leave
1794   0D88 09            ret
1795   0D89             
1796   0D89             printsn:
1797   0D89 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1798   0D8C             ;; print(prompt); 
1799   0D8C FA 07 00      lea d, [bp + 7] ; $prompt
1800   0D8F 2A            mov b, [d]
1801   0D90 FD AB         swp b
1802   0D92 D8            push b
1803   0D93 07 6A 0C      call print
1804   0D96 51 02 00      add sp, 2
1805   0D99             ;; prints(n); 
1806   0D99 FA 05 00      lea d, [bp + 5] ; $n
1807   0D9C 2A            mov b, [d]
1808   0D9D FD AB         swp b
1809   0D9F D8            push b
1810   0DA0 07 41 0A      call prints
1811   0DA3 51 02 00      add sp, 2
1812   0DA6             ;; print("\n"); 
1813   0DA6 26 B3 15      mov b, __s2 ; "\n"
1814   0DA9 FD AB         swp b
1815   0DAB D8            push b
1816   0DAC 07 6A 0C      call print
1817   0DAF 51 02 00      add sp, 2
1818   0DB2 F9            leave
1819   0DB3 09            ret
1820   0DB4             
1821   0DB4             include_stdio_asm:
1822   0DB4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1823   0DB7             
1824   0DB7             ; --- BEGIN INLINE ASM BLOCK
1825   0DB7             .include "lib/stdio.asm"
0001+  0DB7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0DB7             ; stdio.s
0003+  0DB7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0DB7             .include "lib/string.asm"
0001++ 0DB7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0DB7             ; string.s
0003++ 0DB7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0DB7             
0005++ 0DB7             
0006++ 0DB7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0DB7             ; _strrev
0008++ 0DB7             ; reverse a string
0009++ 0DB7             ; D = string address
0010++ 0DB7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0DB7             ; 01234
0012++ 0DB7             _strrev:
0013++ 0DB7 4B          	pusha
0014++ 0DB8 07 FE 0D    	call _strlen	; length in C
0015++ 0DBB 12          	mov a, c
0016++ 0DBC AF 01 00    	cmp a, 1
0017++ 0DBF D0 D9 0D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0DC2 7D          	dec a
0019++ 0DC3 FD 4E       	mov si, d	; beginning of string
0020++ 0DC5 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0DC7 59          	add d, a	; end of string
0022++ 0DC8 12          	mov a, c
0023++ 0DC9 FD 9B       	shr a		; divide by 2
0024++ 0DCB 39          	mov c, a	; C now counts the steps
0025++ 0DCC             _strrev_L0:
0026++ 0DCC 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0DCD F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0DCE 3E          	mov [d], al	; store left char into right side
0029++ 0DCF 1B          	mov al, bl
0030++ 0DD0 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0DD1 7E          	dec c
0032++ 0DD2 7F          	dec d
0033++ 0DD3 C2 00 00    	cmp c, 0
0034++ 0DD6 C7 CC 0D    	jne _strrev_L0
0035++ 0DD9             _strrev_end:
0036++ 0DD9 4C          	popa
0037++ 0DDA 09          	ret
0038++ 0DDB             	
0039++ 0DDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0DDB             ; _strchr
0041++ 0DDB             ; search string in D for char in AL
0042++ 0DDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0DDB             _strchr:
0044++ 0DDB             _strchr_L0:
0045++ 0DDB 32          	mov bl, [d]
0046++ 0DDC C1 00       	cmp bl, 0
0047++ 0DDE C6 E9 0D    	je _strchr_end
0048++ 0DE1 BA          	cmp al, bl
0049++ 0DE2 C6 E9 0D    	je _strchr_end
0050++ 0DE5 79          	inc d
0051++ 0DE6 0A DB 0D    	jmp _strchr_L0
0052++ 0DE9             _strchr_end:
0053++ 0DE9 1B          	mov al, bl
0054++ 0DEA 09          	ret
0055++ 0DEB             
0056++ 0DEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0DEB             ; _strstr
0058++ 0DEB             ; find sub-string
0059++ 0DEB             ; str1 in SI
0060++ 0DEB             ; str2 in DI
0061++ 0DEB             ; SI points to end of source string
0062++ 0DEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0DEB             _strstr:
0064++ 0DEB DB          	push al
0065++ 0DEC DA          	push d
0066++ 0DED E3          	push di
0067++ 0DEE             _strstr_loop:
0068++ 0DEE F3          	cmpsb					; compare a byte of the strings
0069++ 0DEF C7 FA 0D    	jne _strstr_ret
0070++ 0DF2 FC 00 00    	lea d, [di + 0]
0071++ 0DF5 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0DF7 C7 EE 0D    	jne _strstr_loop				; equal chars but not at end
0073++ 0DFA             _strstr_ret:
0074++ 0DFA F0          	pop di
0075++ 0DFB E7          	pop d
0076++ 0DFC E8          	pop al
0077++ 0DFD 09          	ret
0078++ 0DFE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0DFE             ; length of null terminated string
0080++ 0DFE             ; result in C
0081++ 0DFE             ; pointer in D
0082++ 0DFE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0DFE             _strlen:
0084++ 0DFE DA          	push d
0085++ 0DFF 38 00 00    	mov c, 0
0086++ 0E02             _strlen_L1:
0087++ 0E02 BD 00       	cmp byte [d], 0
0088++ 0E04 C6 0C 0E    	je _strlen_ret
0089++ 0E07 79          	inc d
0090++ 0E08 78          	inc c
0091++ 0E09 0A 02 0E    	jmp _strlen_L1
0092++ 0E0C             _strlen_ret:
0093++ 0E0C E7          	pop d
0094++ 0E0D 09          	ret
0095++ 0E0E             
0096++ 0E0E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0E0E             ; STRCMP
0098++ 0E0E             ; compare two strings
0099++ 0E0E             ; str1 in SI
0100++ 0E0E             ; str2 in DI
0101++ 0E0E             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0E0E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0E0E             _strcmp:
0104++ 0E0E DB          	push al
0105++ 0E0F DA          	push d
0106++ 0E10 E3          	push di
0107++ 0E11 E2          	push si
0108++ 0E12             _strcmp_loop:
0109++ 0E12 F3          	cmpsb					; compare a byte of the strings
0110++ 0E13 C7 1E 0E    	jne _strcmp_ret
0111++ 0E16 FB FF FF    	lea d, [si +- 1]
0112++ 0E19 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0E1B C7 12 0E    	jne _strcmp_loop				; equal chars but not at end
0114++ 0E1E             _strcmp_ret:
0115++ 0E1E EF          	pop si
0116++ 0E1F F0          	pop di
0117++ 0E20 E7          	pop d
0118++ 0E21 E8          	pop al
0119++ 0E22 09          	ret
0120++ 0E23             
0121++ 0E23             
0122++ 0E23             ; STRCPY
0123++ 0E23             ; copy null terminated string from SI to DI
0124++ 0E23             ; source in SI
0125++ 0E23             ; destination in DI
0126++ 0E23             _strcpy:
0127++ 0E23 E2          	push si
0128++ 0E24 E3          	push di
0129++ 0E25 DB          	push al
0130++ 0E26             _strcpy_L1:
0131++ 0E26 F6          	lodsb
0132++ 0E27 F7          	stosb
0133++ 0E28 B9 00       	cmp al, 0
0134++ 0E2A C7 26 0E    	jne _strcpy_L1
0135++ 0E2D             _strcpy_end:
0136++ 0E2D E8          	pop al
0137++ 0E2E F0          	pop di
0138++ 0E2F EF          	pop si
0139++ 0E30 09          	ret
0140++ 0E31             
0141++ 0E31             ; STRCAT
0142++ 0E31             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0E31             ; source in SI
0144++ 0E31             ; destination in DI
0145++ 0E31             _strcat:
0146++ 0E31 E2          	push si
0147++ 0E32 E3          	push di
0148++ 0E33 D7          	push a
0149++ 0E34 DA          	push d
0150++ 0E35 50          	mov a, di
0151++ 0E36 3C          	mov d, a
0152++ 0E37             _strcat_goto_end_L1:
0153++ 0E37 BD 00       	cmp byte[d], 0
0154++ 0E39 C6 40 0E    	je _strcat_start
0155++ 0E3C 79          	inc d
0156++ 0E3D 0A 37 0E    	jmp _strcat_goto_end_L1
0157++ 0E40             _strcat_start:
0158++ 0E40 FD 50       	mov di, d
0159++ 0E42             _strcat_L1:
0160++ 0E42 F6          	lodsb
0161++ 0E43 F7          	stosb
0162++ 0E44 B9 00       	cmp al, 0
0163++ 0E46 C7 42 0E    	jne _strcat_L1
0164++ 0E49             _strcat_end:
0165++ 0E49 E7          	pop d
0166++ 0E4A E4          	pop a
0167++ 0E4B F0          	pop di
0168++ 0E4C EF          	pop si
0169++ 0E4D 09          	ret
0170++ 0E4E             
0171++ 0E4E             
0005+  0E4E             
0006+  0E4E             
0007+  0E4E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0E4E             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0E4E             ; ASCII in BL
0010+  0E4E             ; result in AL
0011+  0E4E             ; ascii for F = 0100 0110
0012+  0E4E             ; ascii for 9 = 0011 1001
0013+  0E4E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0E4E             hex_ascii_encode:
0015+  0E4E 1B            mov al, bl
0016+  0E4F 93 40         test al, $40        ; test if letter or number
0017+  0E51 C7 57 0E      jnz hex_letter
0018+  0E54 87 0F         and al, $0F        ; get number
0019+  0E56 09            ret
0020+  0E57             hex_letter:
0021+  0E57 87 0F         and al, $0F        ; get letter
0022+  0E59 6A 09         add al, 9
0023+  0E5B 09            ret
0024+  0E5C             
0025+  0E5C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0E5C             ; ATOI
0027+  0E5C             ; 2 letter hex string in B
0028+  0E5C             ; 8bit integer returned in AL
0029+  0E5C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0E5C             _atoi:
0031+  0E5C D8            push b
0032+  0E5D 07 4E 0E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0E60 30            mov bl, bh
0034+  0E61 DB            push al          ; save a
0035+  0E62 07 4E 0E      call hex_ascii_encode
0036+  0E65 EA            pop bl  
0037+  0E66 FD 9E 04      shl al, 4
0038+  0E69 8C            or al, bl
0039+  0E6A E5            pop b
0040+  0E6B 09            ret  
0041+  0E6C             
0042+  0E6C             
0043+  0E6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0E6C             ; scanf
0045+  0E6C             ; no need for explanations!
0046+  0E6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0E6C             scanf:
0048+  0E6C 09            ret
0049+  0E6D             
0050+  0E6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0E6D             ; ITOA
0052+  0E6D             ; 8bit value in BL
0053+  0E6D             ; 2 byte ASCII result in A
0054+  0E6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0E6D             _itoa:
0056+  0E6D DA            push d
0057+  0E6E D8            push b
0058+  0E6F A7 00         mov bh, 0
0059+  0E71 FD A4 04      shr bl, 4  
0060+  0E74 74            mov d, b
0061+  0E75 1F 1D 11      mov al, [d + s_hex_digits]
0062+  0E78 23            mov ah, al
0063+  0E79               
0064+  0E79 E5            pop b
0065+  0E7A D8            push b
0066+  0E7B A7 00         mov bh, 0
0067+  0E7D FD 87 0F      and bl, $0F
0068+  0E80 74            mov d, b
0069+  0E81 1F 1D 11      mov al, [d + s_hex_digits]
0070+  0E84 E5            pop b
0071+  0E85 E7            pop d
0072+  0E86 09            ret
0073+  0E87             
0074+  0E87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0E87             ; HEX STRING TO BINARY
0076+  0E87             ; di = destination address
0077+  0E87             ; si = source
0078+  0E87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0E87             _hex_to_int:
0080+  0E87             _hex_to_int_L1:
0081+  0E87 F6            lodsb          ; load from [SI] to AL
0082+  0E88 B9 00         cmp al, 0        ; check if ASCII 0
0083+  0E8A C6 97 0E      jz _hex_to_int_ret
0084+  0E8D 36            mov bh, al
0085+  0E8E F6            lodsb
0086+  0E8F 2F            mov bl, al
0087+  0E90 07 5C 0E      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0E93 F7            stosb          ; store AL to [DI]
0089+  0E94 0A 87 0E      jmp _hex_to_int_L1
0090+  0E97             _hex_to_int_ret:
0091+  0E97 09            ret    
0092+  0E98             
0093+  0E98             
0094+  0E98             
0095+  0E98             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0E98             ; GETCHAR
0097+  0E98             ; char in ah
0098+  0E98             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0E98             getch:
0100+  0E98 DB            push al
0101+  0E99             getch_retry:
0102+  0E99 19 01         mov al, 1
0103+  0E9B 05 03         syscall sys_io      ; receive in AH
0104+  0E9D E8            pop al
0105+  0E9E 09            ret
0106+  0E9F             
0107+  0E9F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0E9F             ; PUTCHAR
0109+  0E9F             ; char in ah
0110+  0E9F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0E9F             _putchar:
0112+  0E9F D7            push a
0113+  0EA0 19 00         mov al, 0
0114+  0EA2 05 03         syscall sys_io      ; char in AH
0115+  0EA4 E4            pop a
0116+  0EA5 09            ret
0117+  0EA6             
0118+  0EA6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0EA6             ;; INPUT A STRING
0120+  0EA6             ;; terminates with null
0121+  0EA6             ;; pointer in D
0122+  0EA6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0EA6             _gets:
0124+  0EA6 D7            push a
0125+  0EA7 DA            push d
0126+  0EA8             _gets_loop:
0127+  0EA8 19 01         mov al, 1
0128+  0EAA 05 03         syscall sys_io      ; receive in AH
0129+  0EAC B9 00         cmp al, 0        ; check error code (AL)
0130+  0EAE C6 A8 0E      je _gets_loop      ; if no char received, retry
0131+  0EB1             
0132+  0EB1 76 1B         cmp ah, 27
0133+  0EB3 C6 D4 0E      je _gets_ansi_esc
0134+  0EB6 76 0A         cmp ah, $0A        ; LF
0135+  0EB8 C6 3F 0F      je _gets_end
0136+  0EBB 76 0D         cmp ah, $0D        ; CR
0137+  0EBD C6 3F 0F      je _gets_end
0138+  0EC0 76 5C         cmp ah, $5C        ; '\\'
0139+  0EC2 C6 00 0F      je _gets_escape
0140+  0EC5               
0141+  0EC5 76 08         cmp ah, $08      ; check for backspace
0142+  0EC7 C6 D0 0E      je _gets_backspace
0143+  0ECA             
0144+  0ECA 1A            mov al, ah
0145+  0ECB 3E            mov [d], al
0146+  0ECC 79            inc d
0147+  0ECD 0A A8 0E      jmp _gets_loop
0148+  0ED0             _gets_backspace:
0149+  0ED0 7F            dec d
0150+  0ED1 0A A8 0E      jmp _gets_loop
0151+  0ED4             _gets_ansi_esc:
0152+  0ED4 19 01         mov al, 1
0153+  0ED6 05 03         syscall sys_io        ; receive in AH without echo
0154+  0ED8 B9 00         cmp al, 0          ; check error code (AL)
0155+  0EDA C6 D4 0E      je _gets_ansi_esc    ; if no char received, retry
0156+  0EDD 76 5B         cmp ah, '['
0157+  0EDF C7 A8 0E      jne _gets_loop
0158+  0EE2             _gets_ansi_esc_2:
0159+  0EE2 19 01         mov al, 1
0160+  0EE4 05 03         syscall sys_io          ; receive in AH without echo
0161+  0EE6 B9 00         cmp al, 0            ; check error code (AL)
0162+  0EE8 C6 E2 0E      je _gets_ansi_esc_2  ; if no char received, retry
0163+  0EEB 76 44         cmp ah, 'D'
0164+  0EED C6 F8 0E      je _gets_left_arrow
0165+  0EF0 76 43         cmp ah, 'C'
0166+  0EF2 C6 FC 0E      je _gets_right_arrow
0167+  0EF5 0A A8 0E      jmp _gets_loop
0168+  0EF8             _gets_left_arrow:
0169+  0EF8 7F            dec d
0170+  0EF9 0A A8 0E      jmp _gets_loop
0171+  0EFC             _gets_right_arrow:
0172+  0EFC 79            inc d
0173+  0EFD 0A A8 0E      jmp _gets_loop
0174+  0F00             _gets_escape:
0175+  0F00 19 01         mov al, 1
0176+  0F02 05 03         syscall sys_io      ; receive in AH
0177+  0F04 B9 00         cmp al, 0        ; check error code (AL)
0178+  0F06 C6 00 0F      je _gets_escape      ; if no char received, retry
0179+  0F09 76 6E         cmp ah, 'n'
0180+  0F0B C6 2A 0F      je _gets_LF
0181+  0F0E 76 72         cmp ah, 'r'
0182+  0F10 C6 31 0F      je _gets_CR
0183+  0F13 76 30         cmp ah, '0'
0184+  0F15 C6 38 0F      je _gets_NULL
0185+  0F18 76 5C         cmp ah, $5C  ; '\'
0186+  0F1A C6 23 0F      je _gets_slash
0187+  0F1D 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  0F1E 3E            mov [d], al
0189+  0F1F 79            inc d
0190+  0F20 0A A8 0E      jmp _gets_loop
0191+  0F23             _gets_slash:
0192+  0F23 19 5C         mov al, $5C
0193+  0F25 3E            mov [d], al
0194+  0F26 79            inc d
0195+  0F27 0A A8 0E      jmp _gets_loop
0196+  0F2A             _gets_LF:
0197+  0F2A 19 0A         mov al, $0A
0198+  0F2C 3E            mov [d], al
0199+  0F2D 79            inc d
0200+  0F2E 0A A8 0E      jmp _gets_loop
0201+  0F31             _gets_CR:
0202+  0F31 19 0D         mov al, $0D
0203+  0F33 3E            mov [d], al
0204+  0F34 79            inc d
0205+  0F35 0A A8 0E      jmp _gets_loop
0206+  0F38             _gets_NULL:
0207+  0F38 19 00         mov al, $00
0208+  0F3A 3E            mov [d], al
0209+  0F3B 79            inc d
0210+  0F3C 0A A8 0E      jmp _gets_loop
0211+  0F3F             _gets_end:
0212+  0F3F 19 00         mov al, 0
0213+  0F41 3E            mov [d], al        ; terminate string
0214+  0F42 E7            pop d
0215+  0F43 E4            pop a
0216+  0F44 09            ret
0217+  0F45             
0218+  0F45             
0219+  0F45             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  0F45             ;; INPUT TEXT
0221+  0F45             ;; terminated with CTRL+D
0222+  0F45             ;; pointer in D
0223+  0F45             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  0F45             _gettxt:
0225+  0F45 D7            push a
0226+  0F46 DA            push d
0227+  0F47             _gettxt_loop:
0228+  0F47 19 01         mov al, 1
0229+  0F49 05 03         syscall sys_io      ; receive in AH
0230+  0F4B B9 00         cmp al, 0        ; check error code (AL)
0231+  0F4D C6 47 0F      je _gettxt_loop    ; if no char received, retry
0232+  0F50 76 04         cmp ah, 4      ; EOT
0233+  0F52 C6 90 0F      je _gettxt_end
0234+  0F55 76 08         cmp ah, $08      ; check for backspace
0235+  0F57 C6 8C 0F      je _gettxt_backspace
0236+  0F5A 76 5C         cmp ah, $5C        ; '\'
0237+  0F5C C6 65 0F      je _gettxt_escape
0238+  0F5F 1A            mov al, ah
0239+  0F60 3E            mov [d], al
0240+  0F61 79            inc d
0241+  0F62 0A 47 0F      jmp _gettxt_loop
0242+  0F65             _gettxt_escape:
0243+  0F65 19 01         mov al, 1
0244+  0F67 05 03         syscall sys_io      ; receive in AH
0245+  0F69 B9 00         cmp al, 0        ; check error code (AL)
0246+  0F6B C6 65 0F      je _gettxt_escape    ; if no char received, retry
0247+  0F6E 76 6E         cmp ah, 'n'
0248+  0F70 C6 7E 0F      je _gettxt_LF
0249+  0F73 76 72         cmp ah, 'r'
0250+  0F75 C6 85 0F      je _gettxt_CR
0251+  0F78 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0F79 3E            mov [d], al
0253+  0F7A 79            inc d
0254+  0F7B 0A 47 0F      jmp _gettxt_loop
0255+  0F7E             _gettxt_LF:
0256+  0F7E 19 0A         mov al, $0A
0257+  0F80 3E            mov [d], al
0258+  0F81 79            inc d
0259+  0F82 0A 47 0F      jmp _gettxt_loop
0260+  0F85             _gettxt_CR:
0261+  0F85 19 0D         mov al, $0D
0262+  0F87 3E            mov [d], al
0263+  0F88 79            inc d
0264+  0F89 0A 47 0F      jmp _gettxt_loop
0265+  0F8C             _gettxt_backspace:
0266+  0F8C 7F            dec d
0267+  0F8D 0A 47 0F      jmp _gettxt_loop
0268+  0F90             _gettxt_end:
0269+  0F90 19 00         mov al, 0
0270+  0F92 3E            mov [d], al        ; terminate string
0271+  0F93 E7            pop d
0272+  0F94 E4            pop a
0273+  0F95 09            ret
0274+  0F96             
0275+  0F96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0F96             ; PRINT NEW LINE
0277+  0F96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  0F96             printnl:
0279+  0F96 D7            push a
0280+  0F97 10 00 0A      mov a, $0A00
0281+  0F9A 05 03         syscall sys_io
0282+  0F9C 10 00 0D      mov a, $0D00
0283+  0F9F 05 03         syscall sys_io
0284+  0FA1 E4            pop a
0285+  0FA2 09            ret
0286+  0FA3             
0287+  0FA3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0FA3             ; _strtoint
0289+  0FA3             ; 4 digit hex string number in d
0290+  0FA3             ; integer returned in A
0291+  0FA3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  0FA3             _strtointx:
0293+  0FA3 D8            push b
0294+  0FA4 32            mov bl, [d]
0295+  0FA5 37            mov bh, bl
0296+  0FA6 33 01 00      mov bl, [d + 1]
0297+  0FA9 07 5C 0E      call _atoi        ; convert to int in AL
0298+  0FAC 23            mov ah, al        ; move to AH
0299+  0FAD 33 02 00      mov bl, [d + 2]
0300+  0FB0 37            mov bh, bl
0301+  0FB1 33 03 00      mov bl, [d + 3]
0302+  0FB4 07 5C 0E      call _atoi        ; convert to int in AL
0303+  0FB7 E5            pop b
0304+  0FB8 09            ret
0305+  0FB9             
0306+  0FB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  0FB9             ; _strtoint
0308+  0FB9             ; 5 digit base10 string number in d
0309+  0FB9             ; integer returned in A
0310+  0FB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  0FB9             _strtoint:
0312+  0FB9 E2            push si
0313+  0FBA D8            push b
0314+  0FBB D9            push c
0315+  0FBC DA            push d
0316+  0FBD 07 FE 0D      call _strlen      ; get string length in C
0317+  0FC0 7E            dec c
0318+  0FC1 FD 4E         mov si, d
0319+  0FC3 12            mov a, c
0320+  0FC4 FD 99         shl a
0321+  0FC6 3B 35 11      mov d, table_power
0322+  0FC9 59            add d, a
0323+  0FCA 38 00 00      mov c, 0
0324+  0FCD             _strtoint_L0:
0325+  0FCD F6            lodsb      ; load ASCII to al
0326+  0FCE B9 00         cmp al, 0
0327+  0FD0 C6 E3 0F      je _strtoint_end
0328+  0FD3 6F 30         sub al, $30    ; make into integer
0329+  0FD5 22 00         mov ah, 0
0330+  0FD7 2A            mov b, [d]
0331+  0FD8 AC            mul a, b      ; result in B since it fits in 16bits
0332+  0FD9 11            mov a, b
0333+  0FDA 28            mov b, c
0334+  0FDB 54            add a, b
0335+  0FDC 39            mov c, a
0336+  0FDD 63 02 00      sub d, 2
0337+  0FE0 0A CD 0F      jmp _strtoint_L0
0338+  0FE3             _strtoint_end:
0339+  0FE3 12            mov a, c
0340+  0FE4 E7            pop d
0341+  0FE5 E6            pop c
0342+  0FE6 E5            pop b
0343+  0FE7 EF            pop si
0344+  0FE8 09            ret
0345+  0FE9             
0346+  0FE9             
0347+  0FE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  0FE9             ; PRINT NULL TERMINATED STRING
0349+  0FE9             ; pointer in D
0350+  0FE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  0FE9             _puts:
0352+  0FE9 D7            push a
0353+  0FEA DA            push d
0354+  0FEB             _puts_L1:
0355+  0FEB 1E            mov al, [d]
0356+  0FEC B9 00         cmp al, 0
0357+  0FEE C6 FA 0F      jz _puts_END
0358+  0FF1 23            mov ah, al
0359+  0FF2 19 00         mov al, 0
0360+  0FF4 05 03         syscall sys_io
0361+  0FF6 79            inc d
0362+  0FF7 0A EB 0F      jmp _puts_L1
0363+  0FFA             _puts_END:
0364+  0FFA E7            pop d
0365+  0FFB E4            pop a
0366+  0FFC 09            ret
0367+  0FFD             
0368+  0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  0FFD             ; PRINT N SIZE STRING
0370+  0FFD             ; pointer in D
0371+  0FFD             ; size in C
0372+  0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  0FFD             _putsn:
0374+  0FFD DB            push al
0375+  0FFE DA            push d
0376+  0FFF D9            push c
0377+  1000             _putsn_L0:
0378+  1000 1E            mov al, [d]
0379+  1001 23            mov ah, al
0380+  1002 19 00         mov al, 0
0381+  1004 05 03         syscall sys_io
0382+  1006 79            inc d
0383+  1007 7E            dec c  
0384+  1008 C2 00 00      cmp c, 0
0385+  100B C7 00 10      jne _putsn_L0
0386+  100E             _putsn_end:
0387+  100E E6            pop c
0388+  100F E7            pop d
0389+  1010 E8            pop al
0390+  1011 09            ret
0391+  1012             
0392+  1012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1012             ; print 16bit decimal number
0394+  1012             ; input number in A
0395+  1012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1012             print_u16d:
0397+  1012 D7            push a
0398+  1013 D8            push b
0399+  1014 26 10 27      mov b, 10000
0400+  1017 AE            div a, b      ; get 10000's coeff.
0401+  1018 07 3A 10      call print_number
0402+  101B 11            mov a, b
0403+  101C 26 E8 03      mov b, 1000
0404+  101F AE            div a, b      ; get 1000's coeff.
0405+  1020 07 3A 10      call print_number
0406+  1023 11            mov a, b
0407+  1024 26 64 00      mov b, 100
0408+  1027 AE            div a, b
0409+  1028 07 3A 10      call print_number
0410+  102B 11            mov a, b
0411+  102C 26 0A 00      mov b, 10
0412+  102F AE            div a, b
0413+  1030 07 3A 10      call print_number
0414+  1033 1B            mov al, bl      ; 1's coeff in bl
0415+  1034 07 3A 10      call print_number
0416+  1037 E5            pop b
0417+  1038 E4            pop a
0418+  1039 09            ret
0419+  103A             
0420+  103A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  103A             ; print AL
0422+  103A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  103A             print_number:
0424+  103A 6A 30         add al, $30
0425+  103C 23            mov ah, al
0426+  103D 07 9F 0E      call _putchar
0427+  1040 09            ret
0428+  1041             
0429+  1041             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1041             ; PRINT 16BIT HEX INTEGER
0431+  1041             ; integer value in reg B
0432+  1041             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1041             print_u16x:
0434+  1041 D7            push a
0435+  1042 D8            push b
0436+  1043 DD            push bl
0437+  1044 30            mov bl, bh
0438+  1045 07 6D 0E      call _itoa        ; convert bh to char in A
0439+  1048 2F            mov bl, al        ; save al
0440+  1049 19 00         mov al, 0
0441+  104B 05 03         syscall sys_io        ; display AH
0442+  104D 24            mov ah, bl        ; retrieve al
0443+  104E 19 00         mov al, 0
0444+  1050 05 03         syscall sys_io        ; display AL
0445+  1052             
0446+  1052 EA            pop bl
0447+  1053 07 6D 0E      call _itoa        ; convert bh to char in A
0448+  1056 2F            mov bl, al        ; save al
0449+  1057 19 00         mov al, 0
0450+  1059 05 03         syscall sys_io        ; display AH
0451+  105B 24            mov ah, bl        ; retrieve al
0452+  105C 19 00         mov al, 0
0453+  105E 05 03         syscall sys_io        ; display AL
0454+  1060             
0455+  1060 E5            pop b
0456+  1061 E4            pop a
0457+  1062 09            ret
0458+  1063             
0459+  1063             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  1063             ; INPUT 16BIT HEX INTEGER
0461+  1063             ; read 16bit integer into A
0462+  1063             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  1063             scan_u16x:
0464+  1063 F8 10 00      enter 16
0465+  1066 D8            push b
0466+  1067 DA            push d
0467+  1068             
0468+  1068 FA F1 FF      lea d, [bp + -15]
0469+  106B 07 A6 0E      call _gets        ; get number
0470+  106E             
0471+  106E 32            mov bl, [d]
0472+  106F 37            mov bh, bl
0473+  1070 33 01 00      mov bl, [d + 1]
0474+  1073 07 5C 0E      call _atoi        ; convert to int in AL
0475+  1076 23            mov ah, al        ; move to AH
0476+  1077             
0477+  1077 33 02 00      mov bl, [d + 2]
0478+  107A 37            mov bh, bl
0479+  107B 33 03 00      mov bl, [d + 3]
0480+  107E 07 5C 0E      call _atoi        ; convert to int in AL
0481+  1081             
0482+  1081 E7            pop d
0483+  1082 E5            pop b
0484+  1083 F9            leave
0485+  1084 09            ret
0486+  1085             
0487+  1085             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  1085             ; PRINT 8bit HEX INTEGER
0489+  1085             ; integer value in reg bl
0490+  1085             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  1085             print_u8x:
0492+  1085 D7            push a
0493+  1086 DD            push bl
0494+  1087             
0495+  1087 07 6D 0E      call _itoa        ; convert bl to char in A
0496+  108A 2F            mov bl, al        ; save al
0497+  108B 19 00         mov al, 0
0498+  108D 05 03         syscall sys_io        ; display AH
0499+  108F 24            mov ah, bl        ; retrieve al
0500+  1090 19 00         mov al, 0
0501+  1092 05 03         syscall sys_io        ; display AL
0502+  1094             
0503+  1094 EA            pop bl
0504+  1095 E4            pop a
0505+  1096 09            ret
0506+  1097             
0507+  1097             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  1097             ; print 8bit decimal unsigned number
0509+  1097             ; input number in AL
0510+  1097             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  1097             print_u8d:
0512+  1097 D7            push a
0513+  1098 D8            push b
0514+  1099             
0515+  1099 22 00         mov ah, 0
0516+  109B 26 64 00      mov b, 100
0517+  109E AE            div a, b
0518+  109F D8            push b      ; save remainder
0519+  10A0 B9 00         cmp al, 0
0520+  10A2 C6 AC 10      je skip100
0521+  10A5 6A 30         add al, $30
0522+  10A7 23            mov ah, al
0523+  10A8 19 00         mov al, 0
0524+  10AA 05 03         syscall sys_io  ; print coeff
0525+  10AC             skip100:
0526+  10AC E4            pop a
0527+  10AD 22 00         mov ah, 0
0528+  10AF 26 0A 00      mov b, 10
0529+  10B2 AE            div a, b
0530+  10B3 D8            push b      ; save remainder
0531+  10B4 B9 00         cmp al, 0
0532+  10B6 C6 C0 10      je skip10
0533+  10B9 6A 30         add al, $30
0534+  10BB 23            mov ah, al
0535+  10BC 19 00         mov al, 0
0536+  10BE 05 03         syscall sys_io  ; print coeff
0537+  10C0             skip10:
0538+  10C0 E4            pop a
0539+  10C1 1B            mov al, bl
0540+  10C2 6A 30         add al, $30
0541+  10C4 23            mov ah, al
0542+  10C5 19 00         mov al, 0
0543+  10C7 05 03         syscall sys_io  ; print coeff
0544+  10C9 E5            pop b
0545+  10CA E4            pop a
0546+  10CB 09            ret
0547+  10CC             
0548+  10CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  10CC             ; INPUT 8BIT HEX INTEGER
0550+  10CC             ; read 8bit integer into AL
0551+  10CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  10CC             scan_u8x:
0553+  10CC F8 04 00      enter 4
0554+  10CF D8            push b
0555+  10D0 DA            push d
0556+  10D1             
0557+  10D1 FA FD FF      lea d, [bp + -3]
0558+  10D4 07 A6 0E      call _gets        ; get number
0559+  10D7             
0560+  10D7 32            mov bl, [d]
0561+  10D8 37            mov bh, bl
0562+  10D9 33 01 00      mov bl, [d + 1]
0563+  10DC 07 5C 0E      call _atoi        ; convert to int in AL
0564+  10DF             
0565+  10DF E7            pop d
0566+  10E0 E5            pop b
0567+  10E1 F9            leave
0568+  10E2 09            ret
0569+  10E3             
0570+  10E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  10E3             ; input decimal number
0572+  10E3             ; result in A
0573+  10E3             ; 655'\0'
0574+  10E3             ; low--------high
0575+  10E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  10E3             scan_u16d:
0577+  10E3 F8 08 00      enter 8
0578+  10E6 E2            push si
0579+  10E7 D8            push b
0580+  10E8 D9            push c
0581+  10E9 DA            push d
0582+  10EA FA F9 FF      lea d, [bp +- 7]
0583+  10ED 07 A6 0E      call _gets
0584+  10F0 07 FE 0D      call _strlen      ; get string length in C
0585+  10F3 7E            dec c
0586+  10F4 FD 4E         mov si, d
0587+  10F6 12            mov a, c
0588+  10F7 FD 99         shl a
0589+  10F9 3B 35 11      mov d, table_power
0590+  10FC 59            add d, a
0591+  10FD 38 00 00      mov c, 0
0592+  1100             mul_loop:
0593+  1100 F6            lodsb      ; load ASCII to al
0594+  1101 B9 00         cmp al, 0
0595+  1103 C6 16 11      je mul_exit
0596+  1106 6F 30         sub al, $30    ; make into integer
0597+  1108 22 00         mov ah, 0
0598+  110A 2A            mov b, [d]
0599+  110B AC            mul a, b      ; result in B since it fits in 16bits
0600+  110C 11            mov a, b
0601+  110D 28            mov b, c
0602+  110E 54            add a, b
0603+  110F 39            mov c, a
0604+  1110 63 02 00      sub d, 2
0605+  1113 0A 00 11      jmp mul_loop
0606+  1116             mul_exit:
0607+  1116 12            mov a, c
0608+  1117 E7            pop d
0609+  1118 E6            pop c
0610+  1119 E5            pop b
0611+  111A EF            pop si
0612+  111B F9            leave
0613+  111C 09            ret
0614+  111D             
0615+  111D             
0616+  111D 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1121 34 35 36 37 
0616+  1125 38 39 41 42 
0616+  1129 43 44 45 46 
0617+  112D 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1131 1B 5B 48 00 
0618+  1135             
0619+  1135             table_power:
0620+  1135 01 00         .dw 1
0621+  1137 0A 00         .dw 10
0622+  1139 64 00         .dw 100
0623+  113B E8 03         .dw 1000
0624+  113D 10 27         .dw 100001826   113F             ; --- END INLINE ASM BLOCK
1827   113F             
1828   113F F9            leave
1829   1140 09            ret
1830   1141             
1831   1141             base64_encode:
1832   1141 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1833   1144             ; $i 
1834   1144 10 00 00      mov a, $0
1835   1147 45 FF FF      mov [bp + -1], a
1836   114A             ; $j 
1837   114A 10 00 00      mov a, $0
1838   114D 45 FD FF      mov [bp + -3], a
1839   1150             ; $k 
1840   1150             ; $input_len 
1841   1150             ; $input_buffer 
1842   1150             ; $output_buffer 
1843   1150 52 0F 00      sub sp, 15
1844   1153             ;; input_len = strlen(input); 
1845   1153 FA F9 FF      lea d, [bp + -7] ; $input_len
1846   1156 DA            push d
1847   1157 FA 07 00      lea d, [bp + 7] ; $input
1848   115A 2A            mov b, [d]
1849   115B FD AB         swp b
1850   115D D8            push b
1851   115E 07 DD 05      call strlen
1852   1161 51 02 00      add sp, 2
1853   1164 E7            pop d
1854   1165 FD 43         mov [d], b
1855   1167             ;; while (input_len--) { 
1856   1167             _while23_cond:
1857   1167 FA F9 FF      lea d, [bp + -7] ; $input_len
1858   116A 2A            mov b, [d]
1859   116B FD 79         mov g, b
1860   116D FD 7D         dec b
1861   116F FA F9 FF      lea d, [bp + -7] ; $input_len
1862   1172 FD 43         mov [d], b
1863   1174 FD 27         mov b, g
1864   1176 C0 00 00      cmp b, 0
1865   1179 C6 37 13      je _while23_exit
1866   117C             _while23_block:
1867   117C             ;; input_buffer[i++] = *(input++); 
1868   117C FA F6 FF      lea d, [bp + -10] ; $input_buffer
1869   117F D7            push a
1870   1180 DA            push d
1871   1181 FA FF FF      lea d, [bp + -1] ; $i
1872   1184 2A            mov b, [d]
1873   1185 FD 79         mov g, b
1874   1187 FD 77         inc b
1875   1189 FA FF FF      lea d, [bp + -1] ; $i
1876   118C FD 43         mov [d], b
1877   118E FD 27         mov b, g
1878   1190 E7            pop d
1879   1191 5A            add d, b
1880   1192 E4            pop a
1881   1193 DA            push d
1882   1194 FA 07 00      lea d, [bp + 7] ; $input
1883   1197 2A            mov b, [d]
1884   1198 FD 79         mov g, b
1885   119A FD 77         inc b
1886   119C FA 07 00      lea d, [bp + 7] ; $input
1887   119F FD 43         mov [d], b
1888   11A1 FD 27         mov b, g
1889   11A3 74            mov d, b
1890   11A4 32            mov bl, [d]
1891   11A5 A7 00         mov bh, 0
1892   11A7 E7            pop d
1893   11A8 FD 3E         mov [d], bl
1894   11AA             ;; if (i == 3) { 
1895   11AA             _if24_cond:
1896   11AA FA FF FF      lea d, [bp + -1] ; $i
1897   11AD 2A            mov b, [d]
1898   11AE             ; START RELATIONAL
1899   11AE D7            push a
1900   11AF 11            mov a, b
1901   11B0 26 03 00      mov b, $3
1902   11B3 B0            cmp a, b
1903   11B4 FD 71         seq ; ==
1904   11B6 E4            pop a
1905   11B7             ; END RELATIONAL
1906   11B7 C0 00 00      cmp b, 0
1907   11BA C6 34 13      je _if24_exit
1908   11BD             _if24_true:
1909   11BD             ;; output_buffer[0] = (input_buffer[0] & 0xFC) >> 2; 
1910   11BD FA F2 FF      lea d, [bp + -14] ; $output_buffer
1911   11C0 D7            push a
1912   11C1 DA            push d
1913   11C2 26 00 00      mov b, $0
1914   11C5 E7            pop d
1915   11C6 5A            add d, b
1916   11C7 E4            pop a
1917   11C8 DA            push d
1918   11C9 FA F6 FF      lea d, [bp + -10] ; $input_buffer
1919   11CC D7            push a
1920   11CD DA            push d
1921   11CE 26 00 00      mov b, $0
1922   11D1 E7            pop d
1923   11D2 5A            add d, b
1924   11D3 E4            pop a
1925   11D4 32            mov bl, [d]
1926   11D5 A7 00         mov bh, 0
1927   11D7 D7            push a
1928   11D8 11            mov a, b
1929   11D9 26 FC 00      mov b, $fc
1930   11DC 86            and a, b ; &
1931   11DD 27            mov b, a
1932   11DE E4            pop a
1933   11DF             ; START SHIFT
1934   11DF D7            push a
1935   11E0 11            mov a, b
1936   11E1 26 02 00      mov b, $2
1937   11E4 FD 39         mov c, b
1938   11E6 A5            ashr a, cl
1939   11E7 27            mov b, a
1940   11E8 E4            pop a
1941   11E9             ; END SHIFT
1942   11E9 E7            pop d
1943   11EA FD 3E         mov [d], bl
1944   11EC             ;; output_buffer[1] = ((input_buffer[0] & 0x03) << 4) + ((input_buffer[1] & 0xF0) >> 4); 
1945   11EC FA F2 FF      lea d, [bp + -14] ; $output_buffer
1946   11EF D7            push a
1947   11F0 DA            push d
1948   11F1 26 01 00      mov b, $1
1949   11F4 E7            pop d
1950   11F5 5A            add d, b
1951   11F6 E4            pop a
1952   11F7 DA            push d
1953   11F8 FA F6 FF      lea d, [bp + -10] ; $input_buffer
1954   11FB D7            push a
1955   11FC DA            push d
1956   11FD 26 00 00      mov b, $0
1957   1200 E7            pop d
1958   1201 5A            add d, b
1959   1202 E4            pop a
1960   1203 32            mov bl, [d]
1961   1204 A7 00         mov bh, 0
1962   1206 D7            push a
1963   1207 11            mov a, b
1964   1208 26 03 00      mov b, $3
1965   120B 86            and a, b ; &
1966   120C 27            mov b, a
1967   120D E4            pop a
1968   120E             ; START SHIFT
1969   120E D7            push a
1970   120F 11            mov a, b
1971   1210 26 04 00      mov b, $4
1972   1213 FD 39         mov c, b
1973   1215 9D            shl a, cl
1974   1216 27            mov b, a
1975   1217 E4            pop a
1976   1218             ; END SHIFT
1977   1218             ; START TERMS
1978   1218 D7            push a
1979   1219 11            mov a, b
1980   121A FA F6 FF      lea d, [bp + -10] ; $input_buffer
1981   121D D7            push a
1982   121E DA            push d
1983   121F 26 01 00      mov b, $1
1984   1222 E7            pop d
1985   1223 5A            add d, b
1986   1224 E4            pop a
1987   1225 32            mov bl, [d]
1988   1226 A7 00         mov bh, 0
1989   1228 D7            push a
1990   1229 11            mov a, b
1991   122A 26 F0 00      mov b, $f0
1992   122D 86            and a, b ; &
1993   122E 27            mov b, a
1994   122F E4            pop a
1995   1230             ; START SHIFT
1996   1230 D7            push a
1997   1231 11            mov a, b
1998   1232 26 04 00      mov b, $4
1999   1235 FD 39         mov c, b
2000   1237 A5            ashr a, cl
2001   1238 27            mov b, a
2002   1239 E4            pop a
2003   123A             ; END SHIFT
2004   123A 54            add a, b
2005   123B 27            mov b, a
2006   123C E4            pop a
2007   123D             ; END TERMS
2008   123D E7            pop d
2009   123E FD 3E         mov [d], bl
2010   1240             ;; output_buffer[2] = ((input_buffer[1] & 0x0F) << 2) + ((input_buffer[2] & 0xC0) >> 6); 
2011   1240 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2012   1243 D7            push a
2013   1244 DA            push d
2014   1245 26 02 00      mov b, $2
2015   1248 E7            pop d
2016   1249 5A            add d, b
2017   124A E4            pop a
2018   124B DA            push d
2019   124C FA F6 FF      lea d, [bp + -10] ; $input_buffer
2020   124F D7            push a
2021   1250 DA            push d
2022   1251 26 01 00      mov b, $1
2023   1254 E7            pop d
2024   1255 5A            add d, b
2025   1256 E4            pop a
2026   1257 32            mov bl, [d]
2027   1258 A7 00         mov bh, 0
2028   125A D7            push a
2029   125B 11            mov a, b
2030   125C 26 0F 00      mov b, $f
2031   125F 86            and a, b ; &
2032   1260 27            mov b, a
2033   1261 E4            pop a
2034   1262             ; START SHIFT
2035   1262 D7            push a
2036   1263 11            mov a, b
2037   1264 26 02 00      mov b, $2
2038   1267 FD 39         mov c, b
2039   1269 9D            shl a, cl
2040   126A 27            mov b, a
2041   126B E4            pop a
2042   126C             ; END SHIFT
2043   126C             ; START TERMS
2044   126C D7            push a
2045   126D 11            mov a, b
2046   126E FA F6 FF      lea d, [bp + -10] ; $input_buffer
2047   1271 D7            push a
2048   1272 DA            push d
2049   1273 26 02 00      mov b, $2
2050   1276 E7            pop d
2051   1277 5A            add d, b
2052   1278 E4            pop a
2053   1279 32            mov bl, [d]
2054   127A A7 00         mov bh, 0
2055   127C D7            push a
2056   127D 11            mov a, b
2057   127E 26 C0 00      mov b, $c0
2058   1281 86            and a, b ; &
2059   1282 27            mov b, a
2060   1283 E4            pop a
2061   1284             ; START SHIFT
2062   1284 D7            push a
2063   1285 11            mov a, b
2064   1286 26 06 00      mov b, $6
2065   1289 FD 39         mov c, b
2066   128B A5            ashr a, cl
2067   128C 27            mov b, a
2068   128D E4            pop a
2069   128E             ; END SHIFT
2070   128E 54            add a, b
2071   128F 27            mov b, a
2072   1290 E4            pop a
2073   1291             ; END TERMS
2074   1291 E7            pop d
2075   1292 FD 3E         mov [d], bl
2076   1294             ;; output_buffer[3] = input_buffer[2] & 0x3F; 
2077   1294 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2078   1297 D7            push a
2079   1298 DA            push d
2080   1299 26 03 00      mov b, $3
2081   129C E7            pop d
2082   129D 5A            add d, b
2083   129E E4            pop a
2084   129F DA            push d
2085   12A0 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2086   12A3 D7            push a
2087   12A4 DA            push d
2088   12A5 26 02 00      mov b, $2
2089   12A8 E7            pop d
2090   12A9 5A            add d, b
2091   12AA E4            pop a
2092   12AB 32            mov bl, [d]
2093   12AC A7 00         mov bh, 0
2094   12AE D7            push a
2095   12AF 11            mov a, b
2096   12B0 26 3F 00      mov b, $3f
2097   12B3 86            and a, b ; &
2098   12B4 27            mov b, a
2099   12B5 E4            pop a
2100   12B6 E7            pop d
2101   12B7 FD 3E         mov [d], bl
2102   12B9             ;; for (i = 0; i < 4; i++) { 
2103   12B9             _for25_init:
2104   12B9 FA FF FF      lea d, [bp + -1] ; $i
2105   12BC DA            push d
2106   12BD 26 00 00      mov b, $0
2107   12C0 E7            pop d
2108   12C1 FD 43         mov [d], b
2109   12C3             _for25_cond:
2110   12C3 FA FF FF      lea d, [bp + -1] ; $i
2111   12C6 2A            mov b, [d]
2112   12C7             ; START RELATIONAL
2113   12C7 D7            push a
2114   12C8 11            mov a, b
2115   12C9 26 04 00      mov b, $4
2116   12CC B0            cmp a, b
2117   12CD FD 73         slt ; < 
2118   12CF E4            pop a
2119   12D0             ; END RELATIONAL
2120   12D0 C0 00 00      cmp b, 0
2121   12D3 C6 27 13      je _for25_exit
2122   12D6             _for25_block:
2123   12D6             ;; output[j++] = base64_table[output_buffer[i]]; 
2124   12D6 FA 05 00      lea d, [bp + 5] ; $output
2125   12D9 FD 2A         mov d, [d]
2126   12DB D7            push a
2127   12DC DA            push d
2128   12DD FA FD FF      lea d, [bp + -3] ; $j
2129   12E0 2A            mov b, [d]
2130   12E1 FD 79         mov g, b
2131   12E3 FD 77         inc b
2132   12E5 FA FD FF      lea d, [bp + -3] ; $j
2133   12E8 FD 43         mov [d], b
2134   12EA FD 27         mov b, g
2135   12EC E7            pop d
2136   12ED FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2137   12F1 E4            pop a
2138   12F2 DA            push d
2139   12F3 3B 74 15      mov d, _base64_table ; $base64_table
2140   12F6 FD 2A         mov d, [d]
2141   12F8 D7            push a
2142   12F9 DA            push d
2143   12FA FA F2 FF      lea d, [bp + -14] ; $output_buffer
2144   12FD D7            push a
2145   12FE DA            push d
2146   12FF FA FF FF      lea d, [bp + -1] ; $i
2147   1302 2A            mov b, [d]
2148   1303 E7            pop d
2149   1304 5A            add d, b
2150   1305 E4            pop a
2151   1306 32            mov bl, [d]
2152   1307 A7 00         mov bh, 0
2153   1309 E7            pop d
2154   130A FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2155   130E E4            pop a
2156   130F 32            mov bl, [d]
2157   1310 A7 00         mov bh, 0
2158   1312 E7            pop d
2159   1313 FD 3E         mov [d], bl
2160   1315             _for25_update:
2161   1315 FA FF FF      lea d, [bp + -1] ; $i
2162   1318 2A            mov b, [d]
2163   1319 FD 79         mov g, b
2164   131B FD 77         inc b
2165   131D FA FF FF      lea d, [bp + -1] ; $i
2166   1320 FD 43         mov [d], b
2167   1322 FD 27         mov b, g
2168   1324 0A C3 12      jmp _for25_cond
2169   1327             _for25_exit:
2170   1327             ;; i = 0; 
2171   1327 FA FF FF      lea d, [bp + -1] ; $i
2172   132A DA            push d
2173   132B 26 00 00      mov b, $0
2174   132E E7            pop d
2175   132F FD 43         mov [d], b
2176   1331 0A 34 13      jmp _if24_exit
2177   1334             _if24_exit:
2178   1334 0A 67 11      jmp _while23_cond
2179   1337             _while23_exit:
2180   1337             ;; if (i) { 
2181   1337             _if26_cond:
2182   1337 FA FF FF      lea d, [bp + -1] ; $i
2183   133A 2A            mov b, [d]
2184   133B C0 00 00      cmp b, 0
2185   133E C6 19 15      je _if26_exit
2186   1341             _if26_true:
2187   1341             ;; for (k = i; k < 3; k++) { 
2188   1341             _for27_init:
2189   1341 FA FB FF      lea d, [bp + -5] ; $k
2190   1344 DA            push d
2191   1345 FA FF FF      lea d, [bp + -1] ; $i
2192   1348 2A            mov b, [d]
2193   1349 E7            pop d
2194   134A FD 43         mov [d], b
2195   134C             _for27_cond:
2196   134C FA FB FF      lea d, [bp + -5] ; $k
2197   134F 2A            mov b, [d]
2198   1350             ; START RELATIONAL
2199   1350 D7            push a
2200   1351 11            mov a, b
2201   1352 26 03 00      mov b, $3
2202   1355 B0            cmp a, b
2203   1356 FD 73         slt ; < 
2204   1358 E4            pop a
2205   1359             ; END RELATIONAL
2206   1359 C0 00 00      cmp b, 0
2207   135C C6 84 13      je _for27_exit
2208   135F             _for27_block:
2209   135F             ;; input_buffer[k] = '\0'; 
2210   135F FA F6 FF      lea d, [bp + -10] ; $input_buffer
2211   1362 D7            push a
2212   1363 DA            push d
2213   1364 FA FB FF      lea d, [bp + -5] ; $k
2214   1367 2A            mov b, [d]
2215   1368 E7            pop d
2216   1369 5A            add d, b
2217   136A E4            pop a
2218   136B DA            push d
2219   136C 26 00 00      mov b, $0
2220   136F E7            pop d
2221   1370 FD 3E         mov [d], bl
2222   1372             _for27_update:
2223   1372 FA FB FF      lea d, [bp + -5] ; $k
2224   1375 2A            mov b, [d]
2225   1376 FD 79         mov g, b
2226   1378 FD 77         inc b
2227   137A FA FB FF      lea d, [bp + -5] ; $k
2228   137D FD 43         mov [d], b
2229   137F FD 27         mov b, g
2230   1381 0A 4C 13      jmp _for27_cond
2231   1384             _for27_exit:
2232   1384             ;; output_buffer[0] = (input_buffer[0] & 0xFC) >> 2; 
2233   1384 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2234   1387 D7            push a
2235   1388 DA            push d
2236   1389 26 00 00      mov b, $0
2237   138C E7            pop d
2238   138D 5A            add d, b
2239   138E E4            pop a
2240   138F DA            push d
2241   1390 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2242   1393 D7            push a
2243   1394 DA            push d
2244   1395 26 00 00      mov b, $0
2245   1398 E7            pop d
2246   1399 5A            add d, b
2247   139A E4            pop a
2248   139B 32            mov bl, [d]
2249   139C A7 00         mov bh, 0
2250   139E D7            push a
2251   139F 11            mov a, b
2252   13A0 26 FC 00      mov b, $fc
2253   13A3 86            and a, b ; &
2254   13A4 27            mov b, a
2255   13A5 E4            pop a
2256   13A6             ; START SHIFT
2257   13A6 D7            push a
2258   13A7 11            mov a, b
2259   13A8 26 02 00      mov b, $2
2260   13AB FD 39         mov c, b
2261   13AD A5            ashr a, cl
2262   13AE 27            mov b, a
2263   13AF E4            pop a
2264   13B0             ; END SHIFT
2265   13B0 E7            pop d
2266   13B1 FD 3E         mov [d], bl
2267   13B3             ;; output_buffer[1] = ((input_buffer[0] & 0x03) << 4) + ((input_buffer[1] & 0xF0) >> 4); 
2268   13B3 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2269   13B6 D7            push a
2270   13B7 DA            push d
2271   13B8 26 01 00      mov b, $1
2272   13BB E7            pop d
2273   13BC 5A            add d, b
2274   13BD E4            pop a
2275   13BE DA            push d
2276   13BF FA F6 FF      lea d, [bp + -10] ; $input_buffer
2277   13C2 D7            push a
2278   13C3 DA            push d
2279   13C4 26 00 00      mov b, $0
2280   13C7 E7            pop d
2281   13C8 5A            add d, b
2282   13C9 E4            pop a
2283   13CA 32            mov bl, [d]
2284   13CB A7 00         mov bh, 0
2285   13CD D7            push a
2286   13CE 11            mov a, b
2287   13CF 26 03 00      mov b, $3
2288   13D2 86            and a, b ; &
2289   13D3 27            mov b, a
2290   13D4 E4            pop a
2291   13D5             ; START SHIFT
2292   13D5 D7            push a
2293   13D6 11            mov a, b
2294   13D7 26 04 00      mov b, $4
2295   13DA FD 39         mov c, b
2296   13DC 9D            shl a, cl
2297   13DD 27            mov b, a
2298   13DE E4            pop a
2299   13DF             ; END SHIFT
2300   13DF             ; START TERMS
2301   13DF D7            push a
2302   13E0 11            mov a, b
2303   13E1 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2304   13E4 D7            push a
2305   13E5 DA            push d
2306   13E6 26 01 00      mov b, $1
2307   13E9 E7            pop d
2308   13EA 5A            add d, b
2309   13EB E4            pop a
2310   13EC 32            mov bl, [d]
2311   13ED A7 00         mov bh, 0
2312   13EF D7            push a
2313   13F0 11            mov a, b
2314   13F1 26 F0 00      mov b, $f0
2315   13F4 86            and a, b ; &
2316   13F5 27            mov b, a
2317   13F6 E4            pop a
2318   13F7             ; START SHIFT
2319   13F7 D7            push a
2320   13F8 11            mov a, b
2321   13F9 26 04 00      mov b, $4
2322   13FC FD 39         mov c, b
2323   13FE A5            ashr a, cl
2324   13FF 27            mov b, a
2325   1400 E4            pop a
2326   1401             ; END SHIFT
2327   1401 54            add a, b
2328   1402 27            mov b, a
2329   1403 E4            pop a
2330   1404             ; END TERMS
2331   1404 E7            pop d
2332   1405 FD 3E         mov [d], bl
2333   1407             ;; output_buffer[2] = ((input_buffer[1] & 0x0F) << 2) + ((input_buffer[2] & 0xC0) >> 6); 
2334   1407 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2335   140A D7            push a
2336   140B DA            push d
2337   140C 26 02 00      mov b, $2
2338   140F E7            pop d
2339   1410 5A            add d, b
2340   1411 E4            pop a
2341   1412 DA            push d
2342   1413 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2343   1416 D7            push a
2344   1417 DA            push d
2345   1418 26 01 00      mov b, $1
2346   141B E7            pop d
2347   141C 5A            add d, b
2348   141D E4            pop a
2349   141E 32            mov bl, [d]
2350   141F A7 00         mov bh, 0
2351   1421 D7            push a
2352   1422 11            mov a, b
2353   1423 26 0F 00      mov b, $f
2354   1426 86            and a, b ; &
2355   1427 27            mov b, a
2356   1428 E4            pop a
2357   1429             ; START SHIFT
2358   1429 D7            push a
2359   142A 11            mov a, b
2360   142B 26 02 00      mov b, $2
2361   142E FD 39         mov c, b
2362   1430 9D            shl a, cl
2363   1431 27            mov b, a
2364   1432 E4            pop a
2365   1433             ; END SHIFT
2366   1433             ; START TERMS
2367   1433 D7            push a
2368   1434 11            mov a, b
2369   1435 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2370   1438 D7            push a
2371   1439 DA            push d
2372   143A 26 02 00      mov b, $2
2373   143D E7            pop d
2374   143E 5A            add d, b
2375   143F E4            pop a
2376   1440 32            mov bl, [d]
2377   1441 A7 00         mov bh, 0
2378   1443 D7            push a
2379   1444 11            mov a, b
2380   1445 26 C0 00      mov b, $c0
2381   1448 86            and a, b ; &
2382   1449 27            mov b, a
2383   144A E4            pop a
2384   144B             ; START SHIFT
2385   144B D7            push a
2386   144C 11            mov a, b
2387   144D 26 06 00      mov b, $6
2388   1450 FD 39         mov c, b
2389   1452 A5            ashr a, cl
2390   1453 27            mov b, a
2391   1454 E4            pop a
2392   1455             ; END SHIFT
2393   1455 54            add a, b
2394   1456 27            mov b, a
2395   1457 E4            pop a
2396   1458             ; END TERMS
2397   1458 E7            pop d
2398   1459 FD 3E         mov [d], bl
2399   145B             ;; for (k = 0; k < i + 1; k++) { 
2400   145B             _for28_init:
2401   145B FA FB FF      lea d, [bp + -5] ; $k
2402   145E DA            push d
2403   145F 26 00 00      mov b, $0
2404   1462 E7            pop d
2405   1463 FD 43         mov [d], b
2406   1465             _for28_cond:
2407   1465 FA FB FF      lea d, [bp + -5] ; $k
2408   1468 2A            mov b, [d]
2409   1469             ; START RELATIONAL
2410   1469 D7            push a
2411   146A 11            mov a, b
2412   146B FA FF FF      lea d, [bp + -1] ; $i
2413   146E 2A            mov b, [d]
2414   146F             ; START TERMS
2415   146F D7            push a
2416   1470 11            mov a, b
2417   1471 26 01 00      mov b, $1
2418   1474 54            add a, b
2419   1475 27            mov b, a
2420   1476 E4            pop a
2421   1477             ; END TERMS
2422   1477 B0            cmp a, b
2423   1478 FD 73         slt ; < 
2424   147A E4            pop a
2425   147B             ; END RELATIONAL
2426   147B C0 00 00      cmp b, 0
2427   147E C6 D2 14      je _for28_exit
2428   1481             _for28_block:
2429   1481             ;; output[j++] = base64_table[output_buffer[k]]; 
2430   1481 FA 05 00      lea d, [bp + 5] ; $output
2431   1484 FD 2A         mov d, [d]
2432   1486 D7            push a
2433   1487 DA            push d
2434   1488 FA FD FF      lea d, [bp + -3] ; $j
2435   148B 2A            mov b, [d]
2436   148C FD 79         mov g, b
2437   148E FD 77         inc b
2438   1490 FA FD FF      lea d, [bp + -3] ; $j
2439   1493 FD 43         mov [d], b
2440   1495 FD 27         mov b, g
2441   1497 E7            pop d
2442   1498 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2443   149C E4            pop a
2444   149D DA            push d
2445   149E 3B 74 15      mov d, _base64_table ; $base64_table
2446   14A1 FD 2A         mov d, [d]
2447   14A3 D7            push a
2448   14A4 DA            push d
2449   14A5 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2450   14A8 D7            push a
2451   14A9 DA            push d
2452   14AA FA FB FF      lea d, [bp + -5] ; $k
2453   14AD 2A            mov b, [d]
2454   14AE E7            pop d
2455   14AF 5A            add d, b
2456   14B0 E4            pop a
2457   14B1 32            mov bl, [d]
2458   14B2 A7 00         mov bh, 0
2459   14B4 E7            pop d
2460   14B5 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2461   14B9 E4            pop a
2462   14BA 32            mov bl, [d]
2463   14BB A7 00         mov bh, 0
2464   14BD E7            pop d
2465   14BE FD 3E         mov [d], bl
2466   14C0             _for28_update:
2467   14C0 FA FB FF      lea d, [bp + -5] ; $k
2468   14C3 2A            mov b, [d]
2469   14C4 FD 79         mov g, b
2470   14C6 FD 77         inc b
2471   14C8 FA FB FF      lea d, [bp + -5] ; $k
2472   14CB FD 43         mov [d], b
2473   14CD FD 27         mov b, g
2474   14CF 0A 65 14      jmp _for28_cond
2475   14D2             _for28_exit:
2476   14D2             ;; while (i++ < 3) { 
2477   14D2             _while29_cond:
2478   14D2 FA FF FF      lea d, [bp + -1] ; $i
2479   14D5 2A            mov b, [d]
2480   14D6 FD 79         mov g, b
2481   14D8 FD 77         inc b
2482   14DA FA FF FF      lea d, [bp + -1] ; $i
2483   14DD FD 43         mov [d], b
2484   14DF FD 27         mov b, g
2485   14E1             ; START RELATIONAL
2486   14E1 D7            push a
2487   14E2 11            mov a, b
2488   14E3 26 03 00      mov b, $3
2489   14E6 B0            cmp a, b
2490   14E7 FD 73         slt ; < 
2491   14E9 E4            pop a
2492   14EA             ; END RELATIONAL
2493   14EA C0 00 00      cmp b, 0
2494   14ED C6 16 15      je _while29_exit
2495   14F0             _while29_block:
2496   14F0             ;; output[j++] = '='; 
2497   14F0 FA 05 00      lea d, [bp + 5] ; $output
2498   14F3 FD 2A         mov d, [d]
2499   14F5 D7            push a
2500   14F6 DA            push d
2501   14F7 FA FD FF      lea d, [bp + -3] ; $j
2502   14FA 2A            mov b, [d]
2503   14FB FD 79         mov g, b
2504   14FD FD 77         inc b
2505   14FF FA FD FF      lea d, [bp + -3] ; $j
2506   1502 FD 43         mov [d], b
2507   1504 FD 27         mov b, g
2508   1506 E7            pop d
2509   1507 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2510   150B E4            pop a
2511   150C DA            push d
2512   150D 26 3D 00      mov b, $3d
2513   1510 E7            pop d
2514   1511 FD 3E         mov [d], bl
2515   1513 0A D2 14      jmp _while29_cond
2516   1516             _while29_exit:
2517   1516 0A 19 15      jmp _if26_exit
2518   1519             _if26_exit:
2519   1519             ;; output[j] = '\0'; 
2520   1519 FA 05 00      lea d, [bp + 5] ; $output
2521   151C FD 2A         mov d, [d]
2522   151E D7            push a
2523   151F DA            push d
2524   1520 FA FD FF      lea d, [bp + -3] ; $j
2525   1523 2A            mov b, [d]
2526   1524 E7            pop d
2527   1525 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2528   1529 E4            pop a
2529   152A DA            push d
2530   152B 26 00 00      mov b, $0
2531   152E E7            pop d
2532   152F FD 3E         mov [d], bl
2533   1531 F9            leave
2534   1532 09            ret
2535   1533             ; --- END TEXT BLOCK
2536   1533             
2537   1533             ; --- BEGIN DATA BLOCK
2538   1533 41 42 43 44 _base64_table_data: .db "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0
2538   1537 45 46 47 48 
2538   153B 49 4A 4B 4C 
2538   153F 4D 4E 4F 50 
2538   1543 51 52 53 54 
2538   1547 55 56 57 58 
2538   154B 59 5A 61 62 
2538   154F 63 64 65 66 
2538   1553 67 68 69 6A 
2538   1557 6B 6C 6D 6E 
2538   155B 6F 70 71 72 
2538   155F 73 74 75 76 
2538   1563 77 78 79 7A 
2538   1567 30 31 32 33 
2538   156B 34 35 36 37 
2538   156F 38 39 2B 2F 
2538   1573 00 
2539   1574 33 15       _base64_table: .dw _base64_table_data
2540   1576 45 6E 74 65 __s0: .db "Enter a string to encode in base64: ", 0
2540   157A 72 20 61 20 
2540   157E 73 74 72 69 
2540   1582 6E 67 20 74 
2540   1586 6F 20 65 6E 
2540   158A 63 6F 64 65 
2540   158E 20 69 6E 20 
2540   1592 62 61 73 65 
2540   1596 36 34 3A 20 
2540   159A 00 
2541   159B 42 61 73 65 __s1: .db "Base64 encoded string: ", 0
2541   159F 36 34 20 65 
2541   15A3 6E 63 6F 64 
2541   15A7 65 64 20 73 
2541   15AB 74 72 69 6E 
2541   15AF 67 3A 20 00 
2542   15B3 0A 00       __s2: .db "\n", 0
2543   15B5 45 72 72 6F __s3: .db "Error: Unknown argument type.\n", 0
2543   15B9 72 3A 20 55 
2543   15BD 6E 6B 6E 6F 
2543   15C1 77 6E 20 61 
2543   15C5 72 67 75 6D 
2543   15C9 65 6E 74 20 
2543   15CD 74 79 70 65 
2543   15D1 2E 0A 00 
2544   15D4 1B 5B 32 4A __s4: .db "\033[2J\033[H", 0
2544   15D8 1B 5B 48 00 
2545   15DC             
2546   15DC DE 15       _heap_top: .dw _heap
2547   15DE 00          _heap: .db 0
2548   15DF             ; --- END DATA BLOCK
2549   15DF             
2550   15DF             .end
tasm: Number of errors = 0
