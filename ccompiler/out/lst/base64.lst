0001   0000             ; --- FILENAME: programs/base64
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $input 
0011   0408             ; $output 
0012   0408 52 00 03      sub sp, 768
0013   040B             ;; printf("Enter a string to encode in base64: "); 
0014   040B 26 74 18      mov b, __s0 ; "Enter a string to encode in base64: "
0015   040E FD AB         swp b
0016   0410 D8            push b
0017   0411 07 1E 06      call printf
0018   0414 51 02 00      add sp, 2
0019   0417             ;; gets(input); 
0020   0417 FA 01 FF      lea d, [bp + -255] ; $input
0021   041A 2D            mov b, d
0022   041B FD AB         swp b
0023   041D D8            push b
0024   041E 07 15 0B      call gets
0025   0421 51 02 00      add sp, 2
0026   0424             ;; base64_encode(input, output); 
0027   0424 FA 01 FD      lea d, [bp + -767] ; $output
0028   0427 2D            mov b, d
0029   0428 FD AB         swp b
0030   042A D8            push b
0031   042B FA 01 FF      lea d, [bp + -255] ; $input
0032   042E 2D            mov b, d
0033   042F FD AB         swp b
0034   0431 D8            push b
0035   0432 07 53 14      call base64_encode
0036   0435 51 04 00      add sp, 4
0037   0438             ;; printf("Base64 encoded string: "); 
0038   0438 26 99 18      mov b, __s1 ; "Base64 encoded string: "
0039   043B FD AB         swp b
0040   043D D8            push b
0041   043E 07 1E 06      call printf
0042   0441 51 02 00      add sp, 2
0043   0444             ;; printf(output); 
0044   0444 FA 01 FD      lea d, [bp + -767] ; $output
0045   0447 2D            mov b, d
0046   0448 FD AB         swp b
0047   044A D8            push b
0048   044B 07 1E 06      call printf
0049   044E 51 02 00      add sp, 2
0050   0451             ;; printf("\n"); 
0051   0451 26 B1 18      mov b, __s2 ; "\n"
0052   0454 FD AB         swp b
0053   0456 D8            push b
0054   0457 07 1E 06      call printf
0055   045A 51 02 00      add sp, 2
0056   045D             ;; return 0; 
0057   045D 26 00 00      mov b, $0
0058   0460 F9            leave
0059   0461 05 0B         syscall sys_terminate_proc
0060   0463             
0061   0463             strcpy:
0062   0463 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0063   0466             ; $psrc 
0064   0466             ; $pdest 
0065   0466 52 04 00      sub sp, 4
0066   0469             ;; psrc = src; 
0067   0469 FA FF FF      lea d, [bp + -1] ; $psrc
0068   046C DA            push d
0069   046D FA 07 00      lea d, [bp + 7] ; $src
0070   0470 2A            mov b, [d]
0071   0471 E7            pop d
0072   0472 FD 43         mov [d], b
0073   0474             ;; pdest = dest; 
0074   0474 FA FD FF      lea d, [bp + -3] ; $pdest
0075   0477 DA            push d
0076   0478 FA 05 00      lea d, [bp + 5] ; $dest
0077   047B 2A            mov b, [d]
0078   047C E7            pop d
0079   047D FD 43         mov [d], b
0080   047F             ;; while(*psrc) *pdest++ = *psrc++; 
0081   047F             _while1_cond:
0082   047F FA FF FF      lea d, [bp + -1] ; $psrc
0083   0482 2A            mov b, [d]
0084   0483 74            mov d, b
0085   0484 32            mov bl, [d]
0086   0485 A7 00         mov bh, 0
0087   0487 C0 00 00      cmp b, 0
0088   048A C6 B2 04      je _while1_exit
0089   048D             _while1_block:
0090   048D             ;; *pdest++ = *psrc++; 
0091   048D FA FD FF      lea d, [bp + -3] ; $pdest
0092   0490 2A            mov b, [d]
0093   0491 D8            push b
0094   0492 FD 77         inc b
0095   0494 FA FD FF      lea d, [bp + -3] ; $pdest
0096   0497 FD 43         mov [d], b
0097   0499 E5            pop b
0098   049A D8            push b
0099   049B FA FF FF      lea d, [bp + -1] ; $psrc
0100   049E 2A            mov b, [d]
0101   049F D8            push b
0102   04A0 FD 77         inc b
0103   04A2 FA FF FF      lea d, [bp + -1] ; $psrc
0104   04A5 FD 43         mov [d], b
0105   04A7 E5            pop b
0106   04A8 74            mov d, b
0107   04A9 32            mov bl, [d]
0108   04AA A7 00         mov bh, 0
0109   04AC E7            pop d
0110   04AD FD 3E         mov [d], bl
0111   04AF 0A 7F 04      jmp _while1_cond
0112   04B2             _while1_exit:
0113   04B2             ;; *pdest = '\0'; 
0114   04B2 FA FD FF      lea d, [bp + -3] ; $pdest
0115   04B5 2A            mov b, [d]
0116   04B6 D8            push b
0117   04B7 26 00 00      mov b, $0
0118   04BA E7            pop d
0119   04BB FD 3E         mov [d], bl
0120   04BD F9            leave
0121   04BE 09            ret
0122   04BF             
0123   04BF             strcmp:
0124   04BF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0125   04C2             ;; while (*s1 && (*s1 == *s2)) { 
0126   04C2             _while2_cond:
0127   04C2 FA 05 00      lea d, [bp + 5] ; $s1
0128   04C5 2A            mov b, [d]
0129   04C6 74            mov d, b
0130   04C7 32            mov bl, [d]
0131   04C8 A7 00         mov bh, 0
0132   04CA D7            push a
0133   04CB 11            mov a, b
0134   04CC FA 05 00      lea d, [bp + 5] ; $s1
0135   04CF 2A            mov b, [d]
0136   04D0 74            mov d, b
0137   04D1 32            mov bl, [d]
0138   04D2 A7 00         mov bh, 0
0139   04D4             ; START RELATIONAL
0140   04D4 D7            push a
0141   04D5 11            mov a, b
0142   04D6 FA 07 00      lea d, [bp + 7] ; $s2
0143   04D9 2A            mov b, [d]
0144   04DA 74            mov d, b
0145   04DB 32            mov bl, [d]
0146   04DC A7 00         mov bh, 0
0147   04DE B0            cmp a, b
0148   04DF FD 71         seq ; ==
0149   04E1 E4            pop a
0150   04E2             ; END RELATIONAL
0151   04E2 FD A7         sand a, b ; &&
0152   04E4 E4            pop a
0153   04E5 C0 00 00      cmp b, 0
0154   04E8 C6 08 05      je _while2_exit
0155   04EB             _while2_block:
0156   04EB             ;; s1++; 
0157   04EB FA 05 00      lea d, [bp + 5] ; $s1
0158   04EE 2A            mov b, [d]
0159   04EF D8            push b
0160   04F0 FD 77         inc b
0161   04F2 FA 05 00      lea d, [bp + 5] ; $s1
0162   04F5 FD 43         mov [d], b
0163   04F7 E5            pop b
0164   04F8             ;; s2++; 
0165   04F8 FA 07 00      lea d, [bp + 7] ; $s2
0166   04FB 2A            mov b, [d]
0167   04FC D8            push b
0168   04FD FD 77         inc b
0169   04FF FA 07 00      lea d, [bp + 7] ; $s2
0170   0502 FD 43         mov [d], b
0171   0504 E5            pop b
0172   0505 0A C2 04      jmp _while2_cond
0173   0508             _while2_exit:
0174   0508             ;; return *s1 - *s2; 
0175   0508 FA 05 00      lea d, [bp + 5] ; $s1
0176   050B 2A            mov b, [d]
0177   050C 74            mov d, b
0178   050D 32            mov bl, [d]
0179   050E A7 00         mov bh, 0
0180   0510             ; START TERMS
0181   0510 D7            push a
0182   0511 11            mov a, b
0183   0512 FA 07 00      lea d, [bp + 7] ; $s2
0184   0515 2A            mov b, [d]
0185   0516 74            mov d, b
0186   0517 32            mov bl, [d]
0187   0518 A7 00         mov bh, 0
0188   051A 60            sub a, b
0189   051B 27            mov b, a
0190   051C E4            pop a
0191   051D             ; END TERMS
0192   051D F9            leave
0193   051E 09            ret
0194   051F             
0195   051F             strcat:
0196   051F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0197   0522             ; $dest_len 
0198   0522             ; $i 
0199   0522 52 04 00      sub sp, 4
0200   0525             ;; dest_len = strlen(dest); 
0201   0525 FA FF FF      lea d, [bp + -1] ; $dest_len
0202   0528 DA            push d
0203   0529 FA 05 00      lea d, [bp + 5] ; $dest
0204   052C 2A            mov b, [d]
0205   052D FD AB         swp b
0206   052F D8            push b
0207   0530 07 D5 05      call strlen
0208   0533 51 02 00      add sp, 2
0209   0536 E7            pop d
0210   0537 FD 43         mov [d], b
0211   0539             ;; for (i = 0; src[i] != 0; i=i+1) { 
0212   0539             _for3_init:
0213   0539 FA FD FF      lea d, [bp + -3] ; $i
0214   053C DA            push d
0215   053D 26 00 00      mov b, $0
0216   0540 E7            pop d
0217   0541 FD 43         mov [d], b
0218   0543             _for3_cond:
0219   0543 FA 07 00      lea d, [bp + 7] ; $src
0220   0546 FD 2A         mov d, [d]
0221   0548 D7            push a
0222   0549 DA            push d
0223   054A FA FD FF      lea d, [bp + -3] ; $i
0224   054D 2A            mov b, [d]
0225   054E E7            pop d
0226   054F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0227   0553 E4            pop a
0228   0554 32            mov bl, [d]
0229   0555 A7 00         mov bh, 0
0230   0557             ; START RELATIONAL
0231   0557 D7            push a
0232   0558 11            mov a, b
0233   0559 26 00 00      mov b, $0
0234   055C B0            cmp a, b
0235   055D FD 72         sneq ; !=
0236   055F E4            pop a
0237   0560             ; END RELATIONAL
0238   0560 C0 00 00      cmp b, 0
0239   0563 C6 AE 05      je _for3_exit
0240   0566             _for3_block:
0241   0566             ;; dest[dest_len + i] = src[i]; 
0242   0566 FA 05 00      lea d, [bp + 5] ; $dest
0243   0569 FD 2A         mov d, [d]
0244   056B D7            push a
0245   056C DA            push d
0246   056D FA FF FF      lea d, [bp + -1] ; $dest_len
0247   0570 2A            mov b, [d]
0248   0571             ; START TERMS
0249   0571 D7            push a
0250   0572 11            mov a, b
0251   0573 FA FD FF      lea d, [bp + -3] ; $i
0252   0576 2A            mov b, [d]
0253   0577 54            add a, b
0254   0578 27            mov b, a
0255   0579 E4            pop a
0256   057A             ; END TERMS
0257   057A E7            pop d
0258   057B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0259   057F E4            pop a
0260   0580 DA            push d
0261   0581 FA 07 00      lea d, [bp + 7] ; $src
0262   0584 FD 2A         mov d, [d]
0263   0586 D7            push a
0264   0587 DA            push d
0265   0588 FA FD FF      lea d, [bp + -3] ; $i
0266   058B 2A            mov b, [d]
0267   058C E7            pop d
0268   058D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0269   0591 E4            pop a
0270   0592 32            mov bl, [d]
0271   0593 A7 00         mov bh, 0
0272   0595 E7            pop d
0273   0596 FD 3E         mov [d], bl
0274   0598             _for3_update:
0275   0598 FA FD FF      lea d, [bp + -3] ; $i
0276   059B DA            push d
0277   059C FA FD FF      lea d, [bp + -3] ; $i
0278   059F 2A            mov b, [d]
0279   05A0             ; START TERMS
0280   05A0 D7            push a
0281   05A1 11            mov a, b
0282   05A2 26 01 00      mov b, $1
0283   05A5 54            add a, b
0284   05A6 27            mov b, a
0285   05A7 E4            pop a
0286   05A8             ; END TERMS
0287   05A8 E7            pop d
0288   05A9 FD 43         mov [d], b
0289   05AB 0A 43 05      jmp _for3_cond
0290   05AE             _for3_exit:
0291   05AE             ;; dest[dest_len + i] = 0; 
0292   05AE FA 05 00      lea d, [bp + 5] ; $dest
0293   05B1 FD 2A         mov d, [d]
0294   05B3 D7            push a
0295   05B4 DA            push d
0296   05B5 FA FF FF      lea d, [bp + -1] ; $dest_len
0297   05B8 2A            mov b, [d]
0298   05B9             ; START TERMS
0299   05B9 D7            push a
0300   05BA 11            mov a, b
0301   05BB FA FD FF      lea d, [bp + -3] ; $i
0302   05BE 2A            mov b, [d]
0303   05BF 54            add a, b
0304   05C0 27            mov b, a
0305   05C1 E4            pop a
0306   05C2             ; END TERMS
0307   05C2 E7            pop d
0308   05C3 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0309   05C7 E4            pop a
0310   05C8 DA            push d
0311   05C9 26 00 00      mov b, $0
0312   05CC E7            pop d
0313   05CD FD 3E         mov [d], bl
0314   05CF             ;; return dest; 
0315   05CF FA 05 00      lea d, [bp + 5] ; $dest
0316   05D2 2A            mov b, [d]
0317   05D3 F9            leave
0318   05D4 09            ret
0319   05D5             
0320   05D5             strlen:
0321   05D5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0322   05D8             ; $length 
0323   05D8 52 02 00      sub sp, 2
0324   05DB             ;; length = 0; 
0325   05DB FA FF FF      lea d, [bp + -1] ; $length
0326   05DE DA            push d
0327   05DF 26 00 00      mov b, $0
0328   05E2 E7            pop d
0329   05E3 FD 43         mov [d], b
0330   05E5             ;; while (str[length] != 0) { 
0331   05E5             _while4_cond:
0332   05E5 FA 05 00      lea d, [bp + 5] ; $str
0333   05E8 FD 2A         mov d, [d]
0334   05EA D7            push a
0335   05EB DA            push d
0336   05EC FA FF FF      lea d, [bp + -1] ; $length
0337   05EF 2A            mov b, [d]
0338   05F0 E7            pop d
0339   05F1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0340   05F5 E4            pop a
0341   05F6 32            mov bl, [d]
0342   05F7 A7 00         mov bh, 0
0343   05F9             ; START RELATIONAL
0344   05F9 D7            push a
0345   05FA 11            mov a, b
0346   05FB 26 00 00      mov b, $0
0347   05FE B0            cmp a, b
0348   05FF FD 72         sneq ; !=
0349   0601 E4            pop a
0350   0602             ; END RELATIONAL
0351   0602 C0 00 00      cmp b, 0
0352   0605 C6 18 06      je _while4_exit
0353   0608             _while4_block:
0354   0608             ;; length++; 
0355   0608 FA FF FF      lea d, [bp + -1] ; $length
0356   060B 2A            mov b, [d]
0357   060C D8            push b
0358   060D FD 77         inc b
0359   060F FA FF FF      lea d, [bp + -1] ; $length
0360   0612 FD 43         mov [d], b
0361   0614 E5            pop b
0362   0615 0A E5 05      jmp _while4_cond
0363   0618             _while4_exit:
0364   0618             ;; return length; 
0365   0618 FA FF FF      lea d, [bp + -1] ; $length
0366   061B 2A            mov b, [d]
0367   061C F9            leave
0368   061D 09            ret
0369   061E             
0370   061E             printf:
0371   061E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0372   0621             ; $p 
0373   0621             ; $fp 
0374   0621             ; $i 
0375   0621 52 06 00      sub sp, 6
0376   0624             ;; fp = format; 
0377   0624 FA FD FF      lea d, [bp + -3] ; $fp
0378   0627 DA            push d
0379   0628 FA 05 00      lea d, [bp + 5] ; $format
0380   062B 2A            mov b, [d]
0381   062C E7            pop d
0382   062D FD 43         mov [d], b
0383   062F             ;; p = &format + 2; 
0384   062F FA FF FF      lea d, [bp + -1] ; $p
0385   0632 DA            push d
0386   0633 FA 05 00      lea d, [bp + 5] ; $format
0387   0636 2D            mov b, d
0388   0637             ; START TERMS
0389   0637 D7            push a
0390   0638 11            mov a, b
0391   0639 26 02 00      mov b, $2
0392   063C 54            add a, b
0393   063D 27            mov b, a
0394   063E E4            pop a
0395   063F             ; END TERMS
0396   063F E7            pop d
0397   0640 FD 43         mov [d], b
0398   0642             ;; for(;;){ 
0399   0642             _for5_init:
0400   0642             _for5_cond:
0401   0642             _for5_block:
0402   0642             ;; if(!*fp) break; 
0403   0642             _if6_cond:
0404   0642 FA FD FF      lea d, [bp + -3] ; $fp
0405   0645 2A            mov b, [d]
0406   0646 74            mov d, b
0407   0647 32            mov bl, [d]
0408   0648 A7 00         mov bh, 0
0409   064A C0 00 00      cmp b, 0
0410   064D FD 71         seq ; !
0411   064F C0 00 00      cmp b, 0
0412   0652 C6 5B 06      je _if6_else
0413   0655             _if6_true:
0414   0655             ;; break; 
0415   0655 0A 7C 08      jmp _for5_exit ; for break
0416   0658 0A 79 08      jmp _if6_exit
0417   065B             _if6_else:
0418   065B             ;; if(*fp == '%'){ 
0419   065B             _if7_cond:
0420   065B FA FD FF      lea d, [bp + -3] ; $fp
0421   065E 2A            mov b, [d]
0422   065F 74            mov d, b
0423   0660 32            mov bl, [d]
0424   0661 A7 00         mov bh, 0
0425   0663             ; START RELATIONAL
0426   0663 D7            push a
0427   0664 11            mov a, b
0428   0665 26 25 00      mov b, $25
0429   0668 B0            cmp a, b
0430   0669 FD 71         seq ; ==
0431   066B E4            pop a
0432   066C             ; END RELATIONAL
0433   066C C0 00 00      cmp b, 0
0434   066F C6 5D 08      je _if7_else
0435   0672             _if7_true:
0436   0672             ;; fp++; 
0437   0672 FA FD FF      lea d, [bp + -3] ; $fp
0438   0675 2A            mov b, [d]
0439   0676 D8            push b
0440   0677 FD 77         inc b
0441   0679 FA FD FF      lea d, [bp + -3] ; $fp
0442   067C FD 43         mov [d], b
0443   067E E5            pop b
0444   067F             ;; switch(*fp){ 
0445   067F             _switch8_expr:
0446   067F FA FD FF      lea d, [bp + -3] ; $fp
0447   0682 2A            mov b, [d]
0448   0683 74            mov d, b
0449   0684 32            mov bl, [d]
0450   0685 A7 00         mov bh, 0
0451   0687             _switch8_comparisons:
0452   0687 C1 6C         cmp bl, $6c
0453   0689 C6 B5 06      je _switch8_case0
0454   068C C1 4C         cmp bl, $4c
0455   068E C6 B5 06      je _switch8_case1
0456   0691 C1 64         cmp bl, $64
0457   0693 C6 88 07      je _switch8_case2
0458   0696 C1 69         cmp bl, $69
0459   0698 C6 88 07      je _switch8_case3
0460   069B C1 75         cmp bl, $75
0461   069D C6 AD 07      je _switch8_case4
0462   06A0 C1 78         cmp bl, $78
0463   06A2 C6 D2 07      je _switch8_case5
0464   06A5 C1 63         cmp bl, $63
0465   06A7 C6 F7 07      je _switch8_case6
0466   06AA C1 73         cmp bl, $73
0467   06AC C6 1C 08      je _switch8_case7
0468   06AF 0A 41 08      jmp _switch8_default
0469   06B2 0A 4D 08      jmp _switch8_exit
0470   06B5             _switch8_case0:
0471   06B5             _switch8_case1:
0472   06B5             ;; fp++; 
0473   06B5 FA FD FF      lea d, [bp + -3] ; $fp
0474   06B8 2A            mov b, [d]
0475   06B9 D8            push b
0476   06BA FD 77         inc b
0477   06BC FA FD FF      lea d, [bp + -3] ; $fp
0478   06BF FD 43         mov [d], b
0479   06C1 E5            pop b
0480   06C2             ;; if(*fp == 'd' || *fp == 'i') 
0481   06C2             _if9_cond:
0482   06C2 FA FD FF      lea d, [bp + -3] ; $fp
0483   06C5 2A            mov b, [d]
0484   06C6 74            mov d, b
0485   06C7 32            mov bl, [d]
0486   06C8 A7 00         mov bh, 0
0487   06CA             ; START RELATIONAL
0488   06CA D7            push a
0489   06CB 11            mov a, b
0490   06CC 26 64 00      mov b, $64
0491   06CF B0            cmp a, b
0492   06D0 FD 71         seq ; ==
0493   06D2 E4            pop a
0494   06D3             ; END RELATIONAL
0495   06D3 D7            push a
0496   06D4 11            mov a, b
0497   06D5 FA FD FF      lea d, [bp + -3] ; $fp
0498   06D8 2A            mov b, [d]
0499   06D9 74            mov d, b
0500   06DA 32            mov bl, [d]
0501   06DB A7 00         mov bh, 0
0502   06DD             ; START RELATIONAL
0503   06DD D7            push a
0504   06DE 11            mov a, b
0505   06DF 26 69 00      mov b, $69
0506   06E2 B0            cmp a, b
0507   06E3 FD 71         seq ; ==
0508   06E5 E4            pop a
0509   06E6             ; END RELATIONAL
0510   06E6 FD A8         sor a, b ; ||
0511   06E8 E4            pop a
0512   06E9 C0 00 00      cmp b, 0
0513   06EC C6 04 07      je _if9_else
0514   06EF             _if9_true:
0515   06EF             ;; print_signed_long(*(long *)p); 
0516   06EF 74            mov d, b
0517   06F0 FD 79         mov g, b
0518   06F2 28            mov b, c
0519   06F3 FD AB         swp b
0520   06F5 D8            push b
0521   06F6 FD 27         mov b, g
0522   06F8 FD AB         swp b
0523   06FA D8            push b
0524   06FB 07 20 0C      call print_signed_long
0525   06FE 51 04 00      add sp, 4
0526   0701 0A 72 07      jmp _if9_exit
0527   0704             _if9_else:
0528   0704             ;; if(*fp == 'u') 
0529   0704             _if10_cond:
0530   0704 FA FD FF      lea d, [bp + -3] ; $fp
0531   0707 2A            mov b, [d]
0532   0708 74            mov d, b
0533   0709 32            mov bl, [d]
0534   070A A7 00         mov bh, 0
0535   070C             ; START RELATIONAL
0536   070C D7            push a
0537   070D 11            mov a, b
0538   070E 26 75 00      mov b, $75
0539   0711 B0            cmp a, b
0540   0712 FD 71         seq ; ==
0541   0714 E4            pop a
0542   0715             ; END RELATIONAL
0543   0715 C0 00 00      cmp b, 0
0544   0718 C6 30 07      je _if10_else
0545   071B             _if10_true:
0546   071B             ;; print_unsigned_long(*(unsigned long *)p); 
0547   071B 74            mov d, b
0548   071C FD 79         mov g, b
0549   071E 28            mov b, c
0550   071F FD AB         swp b
0551   0721 D8            push b
0552   0722 FD 27         mov b, g
0553   0724 FD AB         swp b
0554   0726 D8            push b
0555   0727 07 55 0D      call print_unsigned_long
0556   072A 51 04 00      add sp, 4
0557   072D 0A 72 07      jmp _if10_exit
0558   0730             _if10_else:
0559   0730             ;; if(*fp == 'x') 
0560   0730             _if11_cond:
0561   0730 FA FD FF      lea d, [bp + -3] ; $fp
0562   0733 2A            mov b, [d]
0563   0734 74            mov d, b
0564   0735 32            mov bl, [d]
0565   0736 A7 00         mov bh, 0
0566   0738             ; START RELATIONAL
0567   0738 D7            push a
0568   0739 11            mov a, b
0569   073A 26 78 00      mov b, $78
0570   073D B0            cmp a, b
0571   073E FD 71         seq ; ==
0572   0740 E4            pop a
0573   0741             ; END RELATIONAL
0574   0741 C0 00 00      cmp b, 0
0575   0744 C6 66 07      je _if11_else
0576   0747             _if11_true:
0577   0747             ;; printx32(*(long int *)p); 
0578   0747 FA FF FF      lea d, [bp + -1] ; $p
0579   074A 2A            mov b, [d]
0580   074B 74            mov d, b
0581   074C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0582   074F FD 39         mov c, b ; And place it into C
0583   0751 2A            mov b, [d] ; Lower Word in B
0584   0752 FD 79         mov g, b
0585   0754 28            mov b, c
0586   0755 FD AB         swp b
0587   0757 D8            push b
0588   0758 FD 27         mov b, g
0589   075A FD AB         swp b
0590   075C D8            push b
0591   075D 07 93 08      call printx32
0592   0760 51 04 00      add sp, 4
0593   0763 0A 72 07      jmp _if11_exit
0594   0766             _if11_else:
0595   0766             ;; err("Unexpected format in printf."); 
0596   0766 26 B3 18      mov b, __s3 ; "Unexpected format in printf."
0597   0769 FD AB         swp b
0598   076B D8            push b
0599   076C 07 7E 08      call err
0600   076F 51 02 00      add sp, 2
0601   0772             _if11_exit:
0602   0772             _if10_exit:
0603   0772             _if9_exit:
0604   0772             ;; p = p + 4; 
0605   0772 FA FF FF      lea d, [bp + -1] ; $p
0606   0775 DA            push d
0607   0776 FA FF FF      lea d, [bp + -1] ; $p
0608   0779 2A            mov b, [d]
0609   077A             ; START TERMS
0610   077A D7            push a
0611   077B 11            mov a, b
0612   077C 26 04 00      mov b, $4
0613   077F 54            add a, b
0614   0780 27            mov b, a
0615   0781 E4            pop a
0616   0782             ; END TERMS
0617   0782 E7            pop d
0618   0783 FD 43         mov [d], b
0619   0785             ;; break; 
0620   0785 0A 4D 08      jmp _switch8_exit ; case break
0621   0788             _switch8_case2:
0622   0788             _switch8_case3:
0623   0788             ;; print_signed(*(int*)p); 
0624   0788 FA FF FF      lea d, [bp + -1] ; $p
0625   078B 2A            mov b, [d]
0626   078C 74            mov d, b
0627   078D 2A            mov b, [d]
0628   078E FD AB         swp b
0629   0790 D8            push b
0630   0791 07 2F 0B      call print_signed
0631   0794 51 02 00      add sp, 2
0632   0797             ;; p = p + 2; 
0633   0797 FA FF FF      lea d, [bp + -1] ; $p
0634   079A DA            push d
0635   079B FA FF FF      lea d, [bp + -1] ; $p
0636   079E 2A            mov b, [d]
0637   079F             ; START TERMS
0638   079F D7            push a
0639   07A0 11            mov a, b
0640   07A1 26 02 00      mov b, $2
0641   07A4 54            add a, b
0642   07A5 27            mov b, a
0643   07A6 E4            pop a
0644   07A7             ; END TERMS
0645   07A7 E7            pop d
0646   07A8 FD 43         mov [d], b
0647   07AA             ;; break; 
0648   07AA 0A 4D 08      jmp _switch8_exit ; case break
0649   07AD             _switch8_case4:
0650   07AD             ;; print_unsigned(*(unsigned int*)p); 
0651   07AD FA FF FF      lea d, [bp + -1] ; $p
0652   07B0 2A            mov b, [d]
0653   07B1 74            mov d, b
0654   07B2 2A            mov b, [d]
0655   07B3 FD AB         swp b
0656   07B5 D8            push b
0657   07B6 07 4C 0E      call print_unsigned
0658   07B9 51 02 00      add sp, 2
0659   07BC             ;; p = p + 2; 
0660   07BC FA FF FF      lea d, [bp + -1] ; $p
0661   07BF DA            push d
0662   07C0 FA FF FF      lea d, [bp + -1] ; $p
0663   07C3 2A            mov b, [d]
0664   07C4             ; START TERMS
0665   07C4 D7            push a
0666   07C5 11            mov a, b
0667   07C6 26 02 00      mov b, $2
0668   07C9 54            add a, b
0669   07CA 27            mov b, a
0670   07CB E4            pop a
0671   07CC             ; END TERMS
0672   07CC E7            pop d
0673   07CD FD 43         mov [d], b
0674   07CF             ;; break; 
0675   07CF 0A 4D 08      jmp _switch8_exit ; case break
0676   07D2             _switch8_case5:
0677   07D2             ;; printx16(*(int*)p); 
0678   07D2 FA FF FF      lea d, [bp + -1] ; $p
0679   07D5 2A            mov b, [d]
0680   07D6 74            mov d, b
0681   07D7 2A            mov b, [d]
0682   07D8 FD AB         swp b
0683   07DA D8            push b
0684   07DB 07 A5 08      call printx16
0685   07DE 51 02 00      add sp, 2
0686   07E1             ;; p = p + 2; 
0687   07E1 FA FF FF      lea d, [bp + -1] ; $p
0688   07E4 DA            push d
0689   07E5 FA FF FF      lea d, [bp + -1] ; $p
0690   07E8 2A            mov b, [d]
0691   07E9             ; START TERMS
0692   07E9 D7            push a
0693   07EA 11            mov a, b
0694   07EB 26 02 00      mov b, $2
0695   07EE 54            add a, b
0696   07EF 27            mov b, a
0697   07F0 E4            pop a
0698   07F1             ; END TERMS
0699   07F1 E7            pop d
0700   07F2 FD 43         mov [d], b
0701   07F4             ;; break; 
0702   07F4 0A 4D 08      jmp _switch8_exit ; case break
0703   07F7             _switch8_case6:
0704   07F7             ;; putchar(*(char*)p); 
0705   07F7 FA FF FF      lea d, [bp + -1] ; $p
0706   07FA 2A            mov b, [d]
0707   07FB 74            mov d, b
0708   07FC 32            mov bl, [d]
0709   07FD A7 00         mov bh, 0
0710   07FF DD            push bl
0711   0800 07 34 0F      call putchar
0712   0803 51 01 00      add sp, 1
0713   0806             ;; p = p + 2; 
0714   0806 FA FF FF      lea d, [bp + -1] ; $p
0715   0809 DA            push d
0716   080A FA FF FF      lea d, [bp + -1] ; $p
0717   080D 2A            mov b, [d]
0718   080E             ; START TERMS
0719   080E D7            push a
0720   080F 11            mov a, b
0721   0810 26 02 00      mov b, $2
0722   0813 54            add a, b
0723   0814 27            mov b, a
0724   0815 E4            pop a
0725   0816             ; END TERMS
0726   0816 E7            pop d
0727   0817 FD 43         mov [d], b
0728   0819             ;; break; 
0729   0819 0A 4D 08      jmp _switch8_exit ; case break
0730   081C             _switch8_case7:
0731   081C             ;; print(*(char**)p); 
0732   081C FA FF FF      lea d, [bp + -1] ; $p
0733   081F 2A            mov b, [d]
0734   0820 74            mov d, b
0735   0821 2A            mov b, [d]
0736   0822 FD AB         swp b
0737   0824 D8            push b
0738   0825 07 7C 0F      call print
0739   0828 51 02 00      add sp, 2
0740   082B             ;; p = p + 2; 
0741   082B FA FF FF      lea d, [bp + -1] ; $p
0742   082E DA            push d
0743   082F FA FF FF      lea d, [bp + -1] ; $p
0744   0832 2A            mov b, [d]
0745   0833             ; START TERMS
0746   0833 D7            push a
0747   0834 11            mov a, b
0748   0835 26 02 00      mov b, $2
0749   0838 54            add a, b
0750   0839 27            mov b, a
0751   083A E4            pop a
0752   083B             ; END TERMS
0753   083B E7            pop d
0754   083C FD 43         mov [d], b
0755   083E             ;; break; 
0756   083E 0A 4D 08      jmp _switch8_exit ; case break
0757   0841             _switch8_default:
0758   0841             ;; print("Error: Unknown argument type.\n"); 
0759   0841 26 D0 18      mov b, __s4 ; "Error: Unknown argument type.\n"
0760   0844 FD AB         swp b
0761   0846 D8            push b
0762   0847 07 7C 0F      call print
0763   084A 51 02 00      add sp, 2
0764   084D             _switch8_exit:
0765   084D             ;; fp++; 
0766   084D FA FD FF      lea d, [bp + -3] ; $fp
0767   0850 2A            mov b, [d]
0768   0851 D8            push b
0769   0852 FD 77         inc b
0770   0854 FA FD FF      lea d, [bp + -3] ; $fp
0771   0857 FD 43         mov [d], b
0772   0859 E5            pop b
0773   085A 0A 79 08      jmp _if7_exit
0774   085D             _if7_else:
0775   085D             ;; putchar(*fp); 
0776   085D FA FD FF      lea d, [bp + -3] ; $fp
0777   0860 2A            mov b, [d]
0778   0861 74            mov d, b
0779   0862 32            mov bl, [d]
0780   0863 A7 00         mov bh, 0
0781   0865 DD            push bl
0782   0866 07 34 0F      call putchar
0783   0869 51 01 00      add sp, 1
0784   086C             ;; fp++; 
0785   086C FA FD FF      lea d, [bp + -3] ; $fp
0786   086F 2A            mov b, [d]
0787   0870 D8            push b
0788   0871 FD 77         inc b
0789   0873 FA FD FF      lea d, [bp + -3] ; $fp
0790   0876 FD 43         mov [d], b
0791   0878 E5            pop b
0792   0879             _if7_exit:
0793   0879             _if6_exit:
0794   0879             _for5_update:
0795   0879 0A 42 06      jmp _for5_cond
0796   087C             _for5_exit:
0797   087C F9            leave
0798   087D 09            ret
0799   087E             
0800   087E             err:
0801   087E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0802   0881             ;; print(e); 
0803   0881 FA 05 00      lea d, [bp + 5] ; $e
0804   0884 2A            mov b, [d]
0805   0885 FD AB         swp b
0806   0887 D8            push b
0807   0888 07 7C 0F      call print
0808   088B 51 02 00      add sp, 2
0809   088E             ;; exit(); 
0810   088E 07 F6 0F      call exit
0811   0891 F9            leave
0812   0892 09            ret
0813   0893             
0814   0893             printx32:
0815   0893 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0816   0896             
0817   0896             ; --- BEGIN INLINE ASM BLOCK
0818   0896 FA 05 00      lea d, [bp + 5] ; $hex
0819   0899 2B 02 00      mov b, [d+2]
0820   089C 07 53 13      call print_u16x
0821   089F 2A            mov b, [d]
0822   08A0 07 53 13      call print_u16x
0823   08A3             ; --- END INLINE ASM BLOCK
0824   08A3             
0825   08A3 F9            leave
0826   08A4 09            ret
0827   08A5             
0828   08A5             printx16:
0829   08A5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0830   08A8             
0831   08A8             ; --- BEGIN INLINE ASM BLOCK
0832   08A8 FA 05 00      lea d, [bp + 5] ; $hex
0833   08AB 2A            mov b, [d]
0834   08AC 07 53 13      call print_u16x
0835   08AF             ; --- END INLINE ASM BLOCK
0836   08AF             
0837   08AF F9            leave
0838   08B0 09            ret
0839   08B1             
0840   08B1             printx8:
0841   08B1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0842   08B4             
0843   08B4             ; --- BEGIN INLINE ASM BLOCK
0844   08B4 FA 05 00      lea d, [bp + 5] ; $hex
0845   08B7 32            mov bl, [d]
0846   08B8 07 97 13      call print_u8x
0847   08BB             ; --- END INLINE ASM BLOCK
0848   08BB             
0849   08BB F9            leave
0850   08BC 09            ret
0851   08BD             
0852   08BD             hex_to_int:
0853   08BD F8 00 00      enter 0 ; (push bp; mov bp, sp)
0854   08C0             ; $value 
0855   08C0 10 00 00      mov a, $0
0856   08C3 45 FF FF      mov [bp + -1], a
0857   08C6             ; $i 
0858   08C6             ; $hex_char 
0859   08C6             ; $len 
0860   08C6 52 07 00      sub sp, 7
0861   08C9             ;; len = strlen(hex_string); 
0862   08C9 FA FA FF      lea d, [bp + -6] ; $len
0863   08CC DA            push d
0864   08CD FA 05 00      lea d, [bp + 5] ; $hex_string
0865   08D0 2A            mov b, [d]
0866   08D1 FD AB         swp b
0867   08D3 D8            push b
0868   08D4 07 D5 05      call strlen
0869   08D7 51 02 00      add sp, 2
0870   08DA E7            pop d
0871   08DB FD 43         mov [d], b
0872   08DD             ;; for (i = 0; i < len; i++) { 
0873   08DD             _for12_init:
0874   08DD FA FD FF      lea d, [bp + -3] ; $i
0875   08E0 DA            push d
0876   08E1 26 00 00      mov b, $0
0877   08E4 E7            pop d
0878   08E5 FD 43         mov [d], b
0879   08E7             _for12_cond:
0880   08E7 FA FD FF      lea d, [bp + -3] ; $i
0881   08EA 2A            mov b, [d]
0882   08EB             ; START RELATIONAL
0883   08EB D7            push a
0884   08EC 11            mov a, b
0885   08ED FA FA FF      lea d, [bp + -6] ; $len
0886   08F0 2A            mov b, [d]
0887   08F1 B0            cmp a, b
0888   08F2 FD 73         slt ; < 
0889   08F4 E4            pop a
0890   08F5             ; END RELATIONAL
0891   08F5 C0 00 00      cmp b, 0
0892   08F8 C6 FD 09      je _for12_exit
0893   08FB             _for12_block:
0894   08FB             ;; hex_char = hex_string[i]; 
0895   08FB FA FC FF      lea d, [bp + -4] ; $hex_char
0896   08FE DA            push d
0897   08FF FA 05 00      lea d, [bp + 5] ; $hex_string
0898   0902 FD 2A         mov d, [d]
0899   0904 D7            push a
0900   0905 DA            push d
0901   0906 FA FD FF      lea d, [bp + -3] ; $i
0902   0909 2A            mov b, [d]
0903   090A E7            pop d
0904   090B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0905   090F E4            pop a
0906   0910 32            mov bl, [d]
0907   0911 A7 00         mov bh, 0
0908   0913 E7            pop d
0909   0914 FD 3E         mov [d], bl
0910   0916             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0911   0916             _if13_cond:
0912   0916 FA FC FF      lea d, [bp + -4] ; $hex_char
0913   0919 32            mov bl, [d]
0914   091A A7 00         mov bh, 0
0915   091C             ; START RELATIONAL
0916   091C D7            push a
0917   091D 11            mov a, b
0918   091E 26 61 00      mov b, $61
0919   0921 B0            cmp a, b
0920   0922 FD 80         sge ; >=
0921   0924 E4            pop a
0922   0925             ; END RELATIONAL
0923   0925 D7            push a
0924   0926 11            mov a, b
0925   0927 FA FC FF      lea d, [bp + -4] ; $hex_char
0926   092A 32            mov bl, [d]
0927   092B A7 00         mov bh, 0
0928   092D             ; START RELATIONAL
0929   092D D7            push a
0930   092E 11            mov a, b
0931   092F 26 66 00      mov b, $66
0932   0932 B0            cmp a, b
0933   0933 FD 74         sle ; <=
0934   0935 E4            pop a
0935   0936             ; END RELATIONAL
0936   0936 FD A7         sand a, b ; &&
0937   0938 E4            pop a
0938   0939 C0 00 00      cmp b, 0
0939   093C C6 6E 09      je _if13_else
0940   093F             _if13_true:
0941   093F             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0942   093F FA FF FF      lea d, [bp + -1] ; $value
0943   0942 DA            push d
0944   0943 FA FF FF      lea d, [bp + -1] ; $value
0945   0946 2A            mov b, [d]
0946   0947             ; START FACTORS
0947   0947 D7            push a
0948   0948 11            mov a, b
0949   0949 26 10 00      mov b, $10
0950   094C AC            mul a, b ; *
0951   094D 11            mov a, b
0952   094E 27            mov b, a
0953   094F E4            pop a
0954   0950             ; END FACTORS
0955   0950             ; START TERMS
0956   0950 D7            push a
0957   0951 11            mov a, b
0958   0952 FA FC FF      lea d, [bp + -4] ; $hex_char
0959   0955 32            mov bl, [d]
0960   0956 A7 00         mov bh, 0
0961   0958             ; START TERMS
0962   0958 D7            push a
0963   0959 11            mov a, b
0964   095A 26 61 00      mov b, $61
0965   095D 60            sub a, b
0966   095E 11            mov a, b
0967   095F 26 0A 00      mov b, $a
0968   0962 54            add a, b
0969   0963 27            mov b, a
0970   0964 E4            pop a
0971   0965             ; END TERMS
0972   0965 54            add a, b
0973   0966 27            mov b, a
0974   0967 E4            pop a
0975   0968             ; END TERMS
0976   0968 E7            pop d
0977   0969 FD 43         mov [d], b
0978   096B 0A ED 09      jmp _if13_exit
0979   096E             _if13_else:
0980   096E             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0981   096E             _if14_cond:
0982   096E FA FC FF      lea d, [bp + -4] ; $hex_char
0983   0971 32            mov bl, [d]
0984   0972 A7 00         mov bh, 0
0985   0974             ; START RELATIONAL
0986   0974 D7            push a
0987   0975 11            mov a, b
0988   0976 26 41 00      mov b, $41
0989   0979 B0            cmp a, b
0990   097A FD 80         sge ; >=
0991   097C E4            pop a
0992   097D             ; END RELATIONAL
0993   097D D7            push a
0994   097E 11            mov a, b
0995   097F FA FC FF      lea d, [bp + -4] ; $hex_char
0996   0982 32            mov bl, [d]
0997   0983 A7 00         mov bh, 0
0998   0985             ; START RELATIONAL
0999   0985 D7            push a
1000   0986 11            mov a, b
1001   0987 26 46 00      mov b, $46
1002   098A B0            cmp a, b
1003   098B FD 74         sle ; <=
1004   098D E4            pop a
1005   098E             ; END RELATIONAL
1006   098E FD A7         sand a, b ; &&
1007   0990 E4            pop a
1008   0991 C0 00 00      cmp b, 0
1009   0994 C6 C6 09      je _if14_else
1010   0997             _if14_true:
1011   0997             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1012   0997 FA FF FF      lea d, [bp + -1] ; $value
1013   099A DA            push d
1014   099B FA FF FF      lea d, [bp + -1] ; $value
1015   099E 2A            mov b, [d]
1016   099F             ; START FACTORS
1017   099F D7            push a
1018   09A0 11            mov a, b
1019   09A1 26 10 00      mov b, $10
1020   09A4 AC            mul a, b ; *
1021   09A5 11            mov a, b
1022   09A6 27            mov b, a
1023   09A7 E4            pop a
1024   09A8             ; END FACTORS
1025   09A8             ; START TERMS
1026   09A8 D7            push a
1027   09A9 11            mov a, b
1028   09AA FA FC FF      lea d, [bp + -4] ; $hex_char
1029   09AD 32            mov bl, [d]
1030   09AE A7 00         mov bh, 0
1031   09B0             ; START TERMS
1032   09B0 D7            push a
1033   09B1 11            mov a, b
1034   09B2 26 41 00      mov b, $41
1035   09B5 60            sub a, b
1036   09B6 11            mov a, b
1037   09B7 26 0A 00      mov b, $a
1038   09BA 54            add a, b
1039   09BB 27            mov b, a
1040   09BC E4            pop a
1041   09BD             ; END TERMS
1042   09BD 54            add a, b
1043   09BE 27            mov b, a
1044   09BF E4            pop a
1045   09C0             ; END TERMS
1046   09C0 E7            pop d
1047   09C1 FD 43         mov [d], b
1048   09C3 0A ED 09      jmp _if14_exit
1049   09C6             _if14_else:
1050   09C6             ;; value = (value * 16) + (hex_char - '0'); 
1051   09C6 FA FF FF      lea d, [bp + -1] ; $value
1052   09C9 DA            push d
1053   09CA FA FF FF      lea d, [bp + -1] ; $value
1054   09CD 2A            mov b, [d]
1055   09CE             ; START FACTORS
1056   09CE D7            push a
1057   09CF 11            mov a, b
1058   09D0 26 10 00      mov b, $10
1059   09D3 AC            mul a, b ; *
1060   09D4 11            mov a, b
1061   09D5 27            mov b, a
1062   09D6 E4            pop a
1063   09D7             ; END FACTORS
1064   09D7             ; START TERMS
1065   09D7 D7            push a
1066   09D8 11            mov a, b
1067   09D9 FA FC FF      lea d, [bp + -4] ; $hex_char
1068   09DC 32            mov bl, [d]
1069   09DD A7 00         mov bh, 0
1070   09DF             ; START TERMS
1071   09DF D7            push a
1072   09E0 11            mov a, b
1073   09E1 26 30 00      mov b, $30
1074   09E4 60            sub a, b
1075   09E5 27            mov b, a
1076   09E6 E4            pop a
1077   09E7             ; END TERMS
1078   09E7 54            add a, b
1079   09E8 27            mov b, a
1080   09E9 E4            pop a
1081   09EA             ; END TERMS
1082   09EA E7            pop d
1083   09EB FD 43         mov [d], b
1084   09ED             _if14_exit:
1085   09ED             _if13_exit:
1086   09ED             _for12_update:
1087   09ED FA FD FF      lea d, [bp + -3] ; $i
1088   09F0 2A            mov b, [d]
1089   09F1 D8            push b
1090   09F2 FD 77         inc b
1091   09F4 FA FD FF      lea d, [bp + -3] ; $i
1092   09F7 FD 43         mov [d], b
1093   09F9 E5            pop b
1094   09FA 0A E7 08      jmp _for12_cond
1095   09FD             _for12_exit:
1096   09FD             ;; return value; 
1097   09FD FA FF FF      lea d, [bp + -1] ; $value
1098   0A00 2A            mov b, [d]
1099   0A01 F9            leave
1100   0A02 09            ret
1101   0A03             
1102   0A03             atoi:
1103   0A03 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1104   0A06             ; $result 
1105   0A06 10 00 00      mov a, $0
1106   0A09 45 FF FF      mov [bp + -1], a
1107   0A0C             ; $sign 
1108   0A0C 10 01 00      mov a, $1
1109   0A0F 45 FD FF      mov [bp + -3], a
1110   0A12 52 04 00      sub sp, 4
1111   0A15             ;; while (*str == ' ') str++; 
1112   0A15             _while15_cond:
1113   0A15 FA 05 00      lea d, [bp + 5] ; $str
1114   0A18 2A            mov b, [d]
1115   0A19 74            mov d, b
1116   0A1A 32            mov bl, [d]
1117   0A1B A7 00         mov bh, 0
1118   0A1D             ; START RELATIONAL
1119   0A1D D7            push a
1120   0A1E 11            mov a, b
1121   0A1F 26 20 00      mov b, $20
1122   0A22 B0            cmp a, b
1123   0A23 FD 71         seq ; ==
1124   0A25 E4            pop a
1125   0A26             ; END RELATIONAL
1126   0A26 C0 00 00      cmp b, 0
1127   0A29 C6 3C 0A      je _while15_exit
1128   0A2C             _while15_block:
1129   0A2C             ;; str++; 
1130   0A2C FA 05 00      lea d, [bp + 5] ; $str
1131   0A2F 2A            mov b, [d]
1132   0A30 D8            push b
1133   0A31 FD 77         inc b
1134   0A33 FA 05 00      lea d, [bp + 5] ; $str
1135   0A36 FD 43         mov [d], b
1136   0A38 E5            pop b
1137   0A39 0A 15 0A      jmp _while15_cond
1138   0A3C             _while15_exit:
1139   0A3C             ;; if (*str == '-' || *str == '+') { 
1140   0A3C             _if16_cond:
1141   0A3C FA 05 00      lea d, [bp + 5] ; $str
1142   0A3F 2A            mov b, [d]
1143   0A40 74            mov d, b
1144   0A41 32            mov bl, [d]
1145   0A42 A7 00         mov bh, 0
1146   0A44             ; START RELATIONAL
1147   0A44 D7            push a
1148   0A45 11            mov a, b
1149   0A46 26 2D 00      mov b, $2d
1150   0A49 B0            cmp a, b
1151   0A4A FD 71         seq ; ==
1152   0A4C E4            pop a
1153   0A4D             ; END RELATIONAL
1154   0A4D D7            push a
1155   0A4E 11            mov a, b
1156   0A4F FA 05 00      lea d, [bp + 5] ; $str
1157   0A52 2A            mov b, [d]
1158   0A53 74            mov d, b
1159   0A54 32            mov bl, [d]
1160   0A55 A7 00         mov bh, 0
1161   0A57             ; START RELATIONAL
1162   0A57 D7            push a
1163   0A58 11            mov a, b
1164   0A59 26 2B 00      mov b, $2b
1165   0A5C B0            cmp a, b
1166   0A5D FD 71         seq ; ==
1167   0A5F E4            pop a
1168   0A60             ; END RELATIONAL
1169   0A60 FD A8         sor a, b ; ||
1170   0A62 E4            pop a
1171   0A63 C0 00 00      cmp b, 0
1172   0A66 C6 9F 0A      je _if16_exit
1173   0A69             _if16_true:
1174   0A69             ;; if (*str == '-') sign = -1; 
1175   0A69             _if17_cond:
1176   0A69 FA 05 00      lea d, [bp + 5] ; $str
1177   0A6C 2A            mov b, [d]
1178   0A6D 74            mov d, b
1179   0A6E 32            mov bl, [d]
1180   0A6F A7 00         mov bh, 0
1181   0A71             ; START RELATIONAL
1182   0A71 D7            push a
1183   0A72 11            mov a, b
1184   0A73 26 2D 00      mov b, $2d
1185   0A76 B0            cmp a, b
1186   0A77 FD 71         seq ; ==
1187   0A79 E4            pop a
1188   0A7A             ; END RELATIONAL
1189   0A7A C0 00 00      cmp b, 0
1190   0A7D C6 8F 0A      je _if17_exit
1191   0A80             _if17_true:
1192   0A80             ;; sign = -1; 
1193   0A80 FA FD FF      lea d, [bp + -3] ; $sign
1194   0A83 DA            push d
1195   0A84 26 01 00      mov b, $1
1196   0A87 FD 97         neg b
1197   0A89 E7            pop d
1198   0A8A FD 43         mov [d], b
1199   0A8C 0A 8F 0A      jmp _if17_exit
1200   0A8F             _if17_exit:
1201   0A8F             ;; str++; 
1202   0A8F FA 05 00      lea d, [bp + 5] ; $str
1203   0A92 2A            mov b, [d]
1204   0A93 D8            push b
1205   0A94 FD 77         inc b
1206   0A96 FA 05 00      lea d, [bp + 5] ; $str
1207   0A99 FD 43         mov [d], b
1208   0A9B E5            pop b
1209   0A9C 0A 9F 0A      jmp _if16_exit
1210   0A9F             _if16_exit:
1211   0A9F             ;; while (*str >= '0' && *str <= '9') { 
1212   0A9F             _while18_cond:
1213   0A9F FA 05 00      lea d, [bp + 5] ; $str
1214   0AA2 2A            mov b, [d]
1215   0AA3 74            mov d, b
1216   0AA4 32            mov bl, [d]
1217   0AA5 A7 00         mov bh, 0
1218   0AA7             ; START RELATIONAL
1219   0AA7 D7            push a
1220   0AA8 11            mov a, b
1221   0AA9 26 30 00      mov b, $30
1222   0AAC B0            cmp a, b
1223   0AAD FD 82         sgeu ; >= (unsigned)
1224   0AAF E4            pop a
1225   0AB0             ; END RELATIONAL
1226   0AB0 D7            push a
1227   0AB1 11            mov a, b
1228   0AB2 FA 05 00      lea d, [bp + 5] ; $str
1229   0AB5 2A            mov b, [d]
1230   0AB6 74            mov d, b
1231   0AB7 32            mov bl, [d]
1232   0AB8 A7 00         mov bh, 0
1233   0ABA             ; START RELATIONAL
1234   0ABA D7            push a
1235   0ABB 11            mov a, b
1236   0ABC 26 39 00      mov b, $39
1237   0ABF B0            cmp a, b
1238   0AC0 FD 76         sleu ; <= (unsigned)
1239   0AC2 E4            pop a
1240   0AC3             ; END RELATIONAL
1241   0AC3 FD A7         sand a, b ; &&
1242   0AC5 E4            pop a
1243   0AC6 C0 00 00      cmp b, 0
1244   0AC9 C6 05 0B      je _while18_exit
1245   0ACC             _while18_block:
1246   0ACC             ;; result = result * 10 + (*str - '0'); 
1247   0ACC FA FF FF      lea d, [bp + -1] ; $result
1248   0ACF DA            push d
1249   0AD0 FA FF FF      lea d, [bp + -1] ; $result
1250   0AD3 2A            mov b, [d]
1251   0AD4             ; START FACTORS
1252   0AD4 D7            push a
1253   0AD5 11            mov a, b
1254   0AD6 26 0A 00      mov b, $a
1255   0AD9 AC            mul a, b ; *
1256   0ADA 11            mov a, b
1257   0ADB 27            mov b, a
1258   0ADC E4            pop a
1259   0ADD             ; END FACTORS
1260   0ADD             ; START TERMS
1261   0ADD D7            push a
1262   0ADE 11            mov a, b
1263   0ADF FA 05 00      lea d, [bp + 5] ; $str
1264   0AE2 2A            mov b, [d]
1265   0AE3 74            mov d, b
1266   0AE4 32            mov bl, [d]
1267   0AE5 A7 00         mov bh, 0
1268   0AE7             ; START TERMS
1269   0AE7 D7            push a
1270   0AE8 11            mov a, b
1271   0AE9 26 30 00      mov b, $30
1272   0AEC 60            sub a, b
1273   0AED 27            mov b, a
1274   0AEE E4            pop a
1275   0AEF             ; END TERMS
1276   0AEF 54            add a, b
1277   0AF0 27            mov b, a
1278   0AF1 E4            pop a
1279   0AF2             ; END TERMS
1280   0AF2 E7            pop d
1281   0AF3 FD 43         mov [d], b
1282   0AF5             ;; str++; 
1283   0AF5 FA 05 00      lea d, [bp + 5] ; $str
1284   0AF8 2A            mov b, [d]
1285   0AF9 D8            push b
1286   0AFA FD 77         inc b
1287   0AFC FA 05 00      lea d, [bp + 5] ; $str
1288   0AFF FD 43         mov [d], b
1289   0B01 E5            pop b
1290   0B02 0A 9F 0A      jmp _while18_cond
1291   0B05             _while18_exit:
1292   0B05             ;; return sign * result; 
1293   0B05 FA FD FF      lea d, [bp + -3] ; $sign
1294   0B08 2A            mov b, [d]
1295   0B09             ; START FACTORS
1296   0B09 D7            push a
1297   0B0A 11            mov a, b
1298   0B0B FA FF FF      lea d, [bp + -1] ; $result
1299   0B0E 2A            mov b, [d]
1300   0B0F AC            mul a, b ; *
1301   0B10 11            mov a, b
1302   0B11 27            mov b, a
1303   0B12 E4            pop a
1304   0B13             ; END FACTORS
1305   0B13 F9            leave
1306   0B14 09            ret
1307   0B15             
1308   0B15             gets:
1309   0B15 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1310   0B18             
1311   0B18             ; --- BEGIN INLINE ASM BLOCK
1312   0B18 FA 05 00      lea d, [bp + 5] ; $s
1313   0B1B 15            mov a, [d]
1314   0B1C 3C            mov d, a
1315   0B1D 07 B8 11      call _gets
1316   0B20             ; --- END INLINE ASM BLOCK
1317   0B20             
1318   0B20             ;; return strlen(s); 
1319   0B20 FA 05 00      lea d, [bp + 5] ; $s
1320   0B23 2A            mov b, [d]
1321   0B24 FD AB         swp b
1322   0B26 D8            push b
1323   0B27 07 D5 05      call strlen
1324   0B2A 51 02 00      add sp, 2
1325   0B2D F9            leave
1326   0B2E 09            ret
1327   0B2F             
1328   0B2F             print_signed:
1329   0B2F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1330   0B32             ; $digits 
1331   0B32             ; $i 
1332   0B32 10 00 00      mov a, $0
1333   0B35 45 FA FF      mov [bp + -6], a
1334   0B38 52 07 00      sub sp, 7
1335   0B3B             ;; if (num < 0) { 
1336   0B3B             _if19_cond:
1337   0B3B FA 05 00      lea d, [bp + 5] ; $num
1338   0B3E 2A            mov b, [d]
1339   0B3F             ; START RELATIONAL
1340   0B3F D7            push a
1341   0B40 11            mov a, b
1342   0B41 26 00 00      mov b, $0
1343   0B44 B0            cmp a, b
1344   0B45 FD 73         slt ; < 
1345   0B47 E4            pop a
1346   0B48             ; END RELATIONAL
1347   0B48 C0 00 00      cmp b, 0
1348   0B4B C6 68 0B      je _if19_else
1349   0B4E             _if19_true:
1350   0B4E             ;; putchar('-'); 
1351   0B4E 26 2D 00      mov b, $2d
1352   0B51 DD            push bl
1353   0B52 07 34 0F      call putchar
1354   0B55 51 01 00      add sp, 1
1355   0B58             ;; num = -num; 
1356   0B58 FA 05 00      lea d, [bp + 5] ; $num
1357   0B5B DA            push d
1358   0B5C FA 05 00      lea d, [bp + 5] ; $num
1359   0B5F 2A            mov b, [d]
1360   0B60 FD 97         neg b
1361   0B62 E7            pop d
1362   0B63 FD 43         mov [d], b
1363   0B65 0A 8A 0B      jmp _if19_exit
1364   0B68             _if19_else:
1365   0B68             ;; if (num == 0) { 
1366   0B68             _if20_cond:
1367   0B68 FA 05 00      lea d, [bp + 5] ; $num
1368   0B6B 2A            mov b, [d]
1369   0B6C             ; START RELATIONAL
1370   0B6C D7            push a
1371   0B6D 11            mov a, b
1372   0B6E 26 00 00      mov b, $0
1373   0B71 B0            cmp a, b
1374   0B72 FD 71         seq ; ==
1375   0B74 E4            pop a
1376   0B75             ; END RELATIONAL
1377   0B75 C0 00 00      cmp b, 0
1378   0B78 C6 8A 0B      je _if20_exit
1379   0B7B             _if20_true:
1380   0B7B             ;; putchar('0'); 
1381   0B7B 26 30 00      mov b, $30
1382   0B7E DD            push bl
1383   0B7F 07 34 0F      call putchar
1384   0B82 51 01 00      add sp, 1
1385   0B85             ;; return; 
1386   0B85 F9            leave
1387   0B86 09            ret
1388   0B87 0A 8A 0B      jmp _if20_exit
1389   0B8A             _if20_exit:
1390   0B8A             _if19_exit:
1391   0B8A             ;; while (num > 0) { 
1392   0B8A             _while21_cond:
1393   0B8A FA 05 00      lea d, [bp + 5] ; $num
1394   0B8D 2A            mov b, [d]
1395   0B8E             ; START RELATIONAL
1396   0B8E D7            push a
1397   0B8F 11            mov a, b
1398   0B90 26 00 00      mov b, $0
1399   0B93 B0            cmp a, b
1400   0B94 FD 7F         sgt ; >
1401   0B96 E4            pop a
1402   0B97             ; END RELATIONAL
1403   0B97 C0 00 00      cmp b, 0
1404   0B9A C6 E5 0B      je _while21_exit
1405   0B9D             _while21_block:
1406   0B9D             ;; digits[i] = '0' + (num % 10); 
1407   0B9D FA FC FF      lea d, [bp + -4] ; $digits
1408   0BA0 D7            push a
1409   0BA1 DA            push d
1410   0BA2 FA FA FF      lea d, [bp + -6] ; $i
1411   0BA5 2A            mov b, [d]
1412   0BA6 E7            pop d
1413   0BA7 5A            add d, b
1414   0BA8 E4            pop a
1415   0BA9 DA            push d
1416   0BAA 26 30 00      mov b, $30
1417   0BAD             ; START TERMS
1418   0BAD D7            push a
1419   0BAE 11            mov a, b
1420   0BAF FA 05 00      lea d, [bp + 5] ; $num
1421   0BB2 2A            mov b, [d]
1422   0BB3             ; START FACTORS
1423   0BB3 D7            push a
1424   0BB4 11            mov a, b
1425   0BB5 26 0A 00      mov b, $a
1426   0BB8 AE            div a, b ; 
1427   0BB9 11            mov a, b
1428   0BBA 27            mov b, a
1429   0BBB E4            pop a
1430   0BBC             ; END FACTORS
1431   0BBC 54            add a, b
1432   0BBD 27            mov b, a
1433   0BBE E4            pop a
1434   0BBF             ; END TERMS
1435   0BBF E7            pop d
1436   0BC0 FD 3E         mov [d], bl
1437   0BC2             ;; num = num / 10; 
1438   0BC2 FA 05 00      lea d, [bp + 5] ; $num
1439   0BC5 DA            push d
1440   0BC6 FA 05 00      lea d, [bp + 5] ; $num
1441   0BC9 2A            mov b, [d]
1442   0BCA             ; START FACTORS
1443   0BCA D7            push a
1444   0BCB 11            mov a, b
1445   0BCC 26 0A 00      mov b, $a
1446   0BCF AE            div a, b
1447   0BD0 27            mov b, a
1448   0BD1 E4            pop a
1449   0BD2             ; END FACTORS
1450   0BD2 E7            pop d
1451   0BD3 FD 43         mov [d], b
1452   0BD5             ;; i++; 
1453   0BD5 FA FA FF      lea d, [bp + -6] ; $i
1454   0BD8 2A            mov b, [d]
1455   0BD9 D8            push b
1456   0BDA FD 77         inc b
1457   0BDC FA FA FF      lea d, [bp + -6] ; $i
1458   0BDF FD 43         mov [d], b
1459   0BE1 E5            pop b
1460   0BE2 0A 8A 0B      jmp _while21_cond
1461   0BE5             _while21_exit:
1462   0BE5             ;; while (i > 0) { 
1463   0BE5             _while22_cond:
1464   0BE5 FA FA FF      lea d, [bp + -6] ; $i
1465   0BE8 2A            mov b, [d]
1466   0BE9             ; START RELATIONAL
1467   0BE9 D7            push a
1468   0BEA 11            mov a, b
1469   0BEB 26 00 00      mov b, $0
1470   0BEE B0            cmp a, b
1471   0BEF FD 7F         sgt ; >
1472   0BF1 E4            pop a
1473   0BF2             ; END RELATIONAL
1474   0BF2 C0 00 00      cmp b, 0
1475   0BF5 C6 1E 0C      je _while22_exit
1476   0BF8             _while22_block:
1477   0BF8             ;; i--; 
1478   0BF8 FA FA FF      lea d, [bp + -6] ; $i
1479   0BFB 2A            mov b, [d]
1480   0BFC D8            push b
1481   0BFD FD 7D         dec b
1482   0BFF FA FA FF      lea d, [bp + -6] ; $i
1483   0C02 FD 43         mov [d], b
1484   0C04 E5            pop b
1485   0C05             ;; putchar(digits[i]); 
1486   0C05 FA FC FF      lea d, [bp + -4] ; $digits
1487   0C08 D7            push a
1488   0C09 DA            push d
1489   0C0A FA FA FF      lea d, [bp + -6] ; $i
1490   0C0D 2A            mov b, [d]
1491   0C0E E7            pop d
1492   0C0F 5A            add d, b
1493   0C10 E4            pop a
1494   0C11 32            mov bl, [d]
1495   0C12 A7 00         mov bh, 0
1496   0C14 DD            push bl
1497   0C15 07 34 0F      call putchar
1498   0C18 51 01 00      add sp, 1
1499   0C1B 0A E5 0B      jmp _while22_cond
1500   0C1E             _while22_exit:
1501   0C1E F9            leave
1502   0C1F 09            ret
1503   0C20             
1504   0C20             print_signed_long:
1505   0C20 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1506   0C23             ; $digits 
1507   0C23             ; $i 
1508   0C23 10 00 00      mov a, $0
1509   0C26 45 F5 FF      mov [bp + -11], a
1510   0C29 52 0C 00      sub sp, 12
1511   0C2C             ;; if (num < 0) { 
1512   0C2C             _if23_cond:
1513   0C2C FA 05 00      lea d, [bp + 5] ; $num
1514   0C2F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1515   0C32 FD 39         mov c, b ; And place it into C
1516   0C34 2A            mov b, [d] ; Lower Word in B
1517   0C35             ; START RELATIONAL
1518   0C35 D7            push a
1519   0C36 FD D8         push g
1520   0C38 11            mov a, b
1521   0C39 FD 7A         mov g, c
1522   0C3B 26 00 00      mov b, $0
1523   0C3E B0            cmp a, b
1524   0C3F FD 73         slt ; < 
1525   0C41 FD F1         pop g
1526   0C43 E4            pop a
1527   0C44             ; END RELATIONAL
1528   0C44 C0 00 00      cmp b, 0
1529   0C47 C6 6E 0C      je _if23_else
1530   0C4A             _if23_true:
1531   0C4A             ;; putchar('-'); 
1532   0C4A 26 2D 00      mov b, $2d
1533   0C4D DD            push bl
1534   0C4E 07 34 0F      call putchar
1535   0C51 51 01 00      add sp, 1
1536   0C54             ;; num = -num; 
1537   0C54 FA 05 00      lea d, [bp + 5] ; $num
1538   0C57 DA            push d
1539   0C58 FA 05 00      lea d, [bp + 5] ; $num
1540   0C5B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1541   0C5E FD 39         mov c, b ; And place it into C
1542   0C60 2A            mov b, [d] ; Lower Word in B
1543   0C61 FD 97         neg b
1544   0C63 E7            pop d
1545   0C64 FD 43         mov [d], b
1546   0C66 28            mov b, c
1547   0C67 FD 44 02 00   mov [d + 2], b
1548   0C6B 0A A5 0C      jmp _if23_exit
1549   0C6E             _if23_else:
1550   0C6E             ;; if (num == 0) { 
1551   0C6E             _if24_cond:
1552   0C6E FA 05 00      lea d, [bp + 5] ; $num
1553   0C71 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1554   0C74 FD 39         mov c, b ; And place it into C
1555   0C76 2A            mov b, [d] ; Lower Word in B
1556   0C77             ; START RELATIONAL
1557   0C77 D7            push a
1558   0C78 FD D8         push g
1559   0C7A 11            mov a, b
1560   0C7B FD 7A         mov g, c
1561   0C7D 26 00 00      mov b, $0
1562   0C80 B0            cmp a, b
1563   0C81 FD 71         seq ; ==
1564   0C83 D8            push b
1565   0C84 12            mov a, c
1566   0C85 FD 27         mov b, g
1567   0C87 B0            cmp a, b
1568   0C88 FD 71         seq ; ==
1569   0C8A E4            pop a
1570   0C8B FD A7         sand a, b
1571   0C8D FD F1         pop g
1572   0C8F E4            pop a
1573   0C90             ; END RELATIONAL
1574   0C90 C0 00 00      cmp b, 0
1575   0C93 C6 A5 0C      je _if24_exit
1576   0C96             _if24_true:
1577   0C96             ;; putchar('0'); 
1578   0C96 26 30 00      mov b, $30
1579   0C99 DD            push bl
1580   0C9A 07 34 0F      call putchar
1581   0C9D 51 01 00      add sp, 1
1582   0CA0             ;; return; 
1583   0CA0 F9            leave
1584   0CA1 09            ret
1585   0CA2 0A A5 0C      jmp _if24_exit
1586   0CA5             _if24_exit:
1587   0CA5             _if23_exit:
1588   0CA5             ;; while (num > 0) { 
1589   0CA5             _while25_cond:
1590   0CA5 FA 05 00      lea d, [bp + 5] ; $num
1591   0CA8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1592   0CAB FD 39         mov c, b ; And place it into C
1593   0CAD 2A            mov b, [d] ; Lower Word in B
1594   0CAE             ; START RELATIONAL
1595   0CAE D7            push a
1596   0CAF FD D8         push g
1597   0CB1 11            mov a, b
1598   0CB2 FD 7A         mov g, c
1599   0CB4 26 00 00      mov b, $0
1600   0CB7 B0            cmp a, b
1601   0CB8 FD 7F         sgt ; >
1602   0CBA FD F1         pop g
1603   0CBC E4            pop a
1604   0CBD             ; END RELATIONAL
1605   0CBD C0 00 00      cmp b, 0
1606   0CC0 C6 1A 0D      je _while25_exit
1607   0CC3             _while25_block:
1608   0CC3             ;; digits[i] = '0' + (num % 10); 
1609   0CC3 FA F7 FF      lea d, [bp + -9] ; $digits
1610   0CC6 D7            push a
1611   0CC7 DA            push d
1612   0CC8 FA F5 FF      lea d, [bp + -11] ; $i
1613   0CCB 2A            mov b, [d]
1614   0CCC E7            pop d
1615   0CCD 5A            add d, b
1616   0CCE E4            pop a
1617   0CCF DA            push d
1618   0CD0 26 30 00      mov b, $30
1619   0CD3             ; START TERMS
1620   0CD3 D7            push a
1621   0CD4 11            mov a, b
1622   0CD5 FA 05 00      lea d, [bp + 5] ; $num
1623   0CD8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1624   0CDB FD 39         mov c, b ; And place it into C
1625   0CDD 2A            mov b, [d] ; Lower Word in B
1626   0CDE             ; START FACTORS
1627   0CDE D7            push a
1628   0CDF 11            mov a, b
1629   0CE0 26 0A 00      mov b, $a
1630   0CE3 AE            div a, b ; 
1631   0CE4 11            mov a, b
1632   0CE5 27            mov b, a
1633   0CE6 E4            pop a
1634   0CE7             ; END FACTORS
1635   0CE7 54            add a, b
1636   0CE8 27            mov b, a
1637   0CE9 E4            pop a
1638   0CEA             ; END TERMS
1639   0CEA E7            pop d
1640   0CEB FD 3E         mov [d], bl
1641   0CED             ;; num = num / 10; 
1642   0CED FA 05 00      lea d, [bp + 5] ; $num
1643   0CF0 DA            push d
1644   0CF1 FA 05 00      lea d, [bp + 5] ; $num
1645   0CF4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1646   0CF7 FD 39         mov c, b ; And place it into C
1647   0CF9 2A            mov b, [d] ; Lower Word in B
1648   0CFA             ; START FACTORS
1649   0CFA D7            push a
1650   0CFB 11            mov a, b
1651   0CFC 26 0A 00      mov b, $a
1652   0CFF AE            div a, b
1653   0D00 27            mov b, a
1654   0D01 E4            pop a
1655   0D02             ; END FACTORS
1656   0D02 E7            pop d
1657   0D03 FD 43         mov [d], b
1658   0D05 28            mov b, c
1659   0D06 FD 44 02 00   mov [d + 2], b
1660   0D0A             ;; i++; 
1661   0D0A FA F5 FF      lea d, [bp + -11] ; $i
1662   0D0D 2A            mov b, [d]
1663   0D0E D8            push b
1664   0D0F FD 77         inc b
1665   0D11 FA F5 FF      lea d, [bp + -11] ; $i
1666   0D14 FD 43         mov [d], b
1667   0D16 E5            pop b
1668   0D17 0A A5 0C      jmp _while25_cond
1669   0D1A             _while25_exit:
1670   0D1A             ;; while (i > 0) { 
1671   0D1A             _while26_cond:
1672   0D1A FA F5 FF      lea d, [bp + -11] ; $i
1673   0D1D 2A            mov b, [d]
1674   0D1E             ; START RELATIONAL
1675   0D1E D7            push a
1676   0D1F 11            mov a, b
1677   0D20 26 00 00      mov b, $0
1678   0D23 B0            cmp a, b
1679   0D24 FD 7F         sgt ; >
1680   0D26 E4            pop a
1681   0D27             ; END RELATIONAL
1682   0D27 C0 00 00      cmp b, 0
1683   0D2A C6 53 0D      je _while26_exit
1684   0D2D             _while26_block:
1685   0D2D             ;; i--; 
1686   0D2D FA F5 FF      lea d, [bp + -11] ; $i
1687   0D30 2A            mov b, [d]
1688   0D31 D8            push b
1689   0D32 FD 7D         dec b
1690   0D34 FA F5 FF      lea d, [bp + -11] ; $i
1691   0D37 FD 43         mov [d], b
1692   0D39 E5            pop b
1693   0D3A             ;; putchar(digits[i]); 
1694   0D3A FA F7 FF      lea d, [bp + -9] ; $digits
1695   0D3D D7            push a
1696   0D3E DA            push d
1697   0D3F FA F5 FF      lea d, [bp + -11] ; $i
1698   0D42 2A            mov b, [d]
1699   0D43 E7            pop d
1700   0D44 5A            add d, b
1701   0D45 E4            pop a
1702   0D46 32            mov bl, [d]
1703   0D47 A7 00         mov bh, 0
1704   0D49 DD            push bl
1705   0D4A 07 34 0F      call putchar
1706   0D4D 51 01 00      add sp, 1
1707   0D50 0A 1A 0D      jmp _while26_cond
1708   0D53             _while26_exit:
1709   0D53 F9            leave
1710   0D54 09            ret
1711   0D55             
1712   0D55             print_unsigned_long:
1713   0D55 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1714   0D58             ; $digits 
1715   0D58             ; $i 
1716   0D58 52 0C 00      sub sp, 12
1717   0D5B             ;; i = 0; 
1718   0D5B FA F5 FF      lea d, [bp + -11] ; $i
1719   0D5E DA            push d
1720   0D5F 26 00 00      mov b, $0
1721   0D62 E7            pop d
1722   0D63 FD 43         mov [d], b
1723   0D65             ;; if(num == 0){ 
1724   0D65             _if27_cond:
1725   0D65 FA 05 00      lea d, [bp + 5] ; $num
1726   0D68 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1727   0D6B FD 39         mov c, b ; And place it into C
1728   0D6D 2A            mov b, [d] ; Lower Word in B
1729   0D6E             ; START RELATIONAL
1730   0D6E D7            push a
1731   0D6F FD D8         push g
1732   0D71 11            mov a, b
1733   0D72 FD 7A         mov g, c
1734   0D74 26 00 00      mov b, $0
1735   0D77 B0            cmp a, b
1736   0D78 FD 71         seq ; ==
1737   0D7A D8            push b
1738   0D7B 12            mov a, c
1739   0D7C FD 27         mov b, g
1740   0D7E B0            cmp a, b
1741   0D7F FD 71         seq ; ==
1742   0D81 E4            pop a
1743   0D82 FD A7         sand a, b
1744   0D84 FD F1         pop g
1745   0D86 E4            pop a
1746   0D87             ; END RELATIONAL
1747   0D87 C0 00 00      cmp b, 0
1748   0D8A C6 9C 0D      je _if27_exit
1749   0D8D             _if27_true:
1750   0D8D             ;; putchar('0'); 
1751   0D8D 26 30 00      mov b, $30
1752   0D90 DD            push bl
1753   0D91 07 34 0F      call putchar
1754   0D94 51 01 00      add sp, 1
1755   0D97             ;; return; 
1756   0D97 F9            leave
1757   0D98 09            ret
1758   0D99 0A 9C 0D      jmp _if27_exit
1759   0D9C             _if27_exit:
1760   0D9C             ;; while (num > 0) { 
1761   0D9C             _while28_cond:
1762   0D9C FA 05 00      lea d, [bp + 5] ; $num
1763   0D9F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1764   0DA2 FD 39         mov c, b ; And place it into C
1765   0DA4 2A            mov b, [d] ; Lower Word in B
1766   0DA5             ; START RELATIONAL
1767   0DA5 D7            push a
1768   0DA6 FD D8         push g
1769   0DA8 11            mov a, b
1770   0DA9 FD 7A         mov g, c
1771   0DAB 26 00 00      mov b, $0
1772   0DAE B0            cmp a, b
1773   0DAF FD 81         sgu ; > (unsigned)
1774   0DB1 FD F1         pop g
1775   0DB3 E4            pop a
1776   0DB4             ; END RELATIONAL
1777   0DB4 C0 00 00      cmp b, 0
1778   0DB7 C6 11 0E      je _while28_exit
1779   0DBA             _while28_block:
1780   0DBA             ;; digits[i] = '0' + (num % 10); 
1781   0DBA FA F7 FF      lea d, [bp + -9] ; $digits
1782   0DBD D7            push a
1783   0DBE DA            push d
1784   0DBF FA F5 FF      lea d, [bp + -11] ; $i
1785   0DC2 2A            mov b, [d]
1786   0DC3 E7            pop d
1787   0DC4 5A            add d, b
1788   0DC5 E4            pop a
1789   0DC6 DA            push d
1790   0DC7 26 30 00      mov b, $30
1791   0DCA             ; START TERMS
1792   0DCA D7            push a
1793   0DCB 11            mov a, b
1794   0DCC FA 05 00      lea d, [bp + 5] ; $num
1795   0DCF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1796   0DD2 FD 39         mov c, b ; And place it into C
1797   0DD4 2A            mov b, [d] ; Lower Word in B
1798   0DD5             ; START FACTORS
1799   0DD5 D7            push a
1800   0DD6 11            mov a, b
1801   0DD7 26 0A 00      mov b, $a
1802   0DDA AE            div a, b ; 
1803   0DDB 11            mov a, b
1804   0DDC 27            mov b, a
1805   0DDD E4            pop a
1806   0DDE             ; END FACTORS
1807   0DDE 54            add a, b
1808   0DDF 27            mov b, a
1809   0DE0 E4            pop a
1810   0DE1             ; END TERMS
1811   0DE1 E7            pop d
1812   0DE2 FD 3E         mov [d], bl
1813   0DE4             ;; num = num / 10; 
1814   0DE4 FA 05 00      lea d, [bp + 5] ; $num
1815   0DE7 DA            push d
1816   0DE8 FA 05 00      lea d, [bp + 5] ; $num
1817   0DEB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1818   0DEE FD 39         mov c, b ; And place it into C
1819   0DF0 2A            mov b, [d] ; Lower Word in B
1820   0DF1             ; START FACTORS
1821   0DF1 D7            push a
1822   0DF2 11            mov a, b
1823   0DF3 26 0A 00      mov b, $a
1824   0DF6 AE            div a, b
1825   0DF7 27            mov b, a
1826   0DF8 E4            pop a
1827   0DF9             ; END FACTORS
1828   0DF9 E7            pop d
1829   0DFA FD 43         mov [d], b
1830   0DFC 28            mov b, c
1831   0DFD FD 44 02 00   mov [d + 2], b
1832   0E01             ;; i++; 
1833   0E01 FA F5 FF      lea d, [bp + -11] ; $i
1834   0E04 2A            mov b, [d]
1835   0E05 D8            push b
1836   0E06 FD 77         inc b
1837   0E08 FA F5 FF      lea d, [bp + -11] ; $i
1838   0E0B FD 43         mov [d], b
1839   0E0D E5            pop b
1840   0E0E 0A 9C 0D      jmp _while28_cond
1841   0E11             _while28_exit:
1842   0E11             ;; while (i > 0) { 
1843   0E11             _while29_cond:
1844   0E11 FA F5 FF      lea d, [bp + -11] ; $i
1845   0E14 2A            mov b, [d]
1846   0E15             ; START RELATIONAL
1847   0E15 D7            push a
1848   0E16 11            mov a, b
1849   0E17 26 00 00      mov b, $0
1850   0E1A B0            cmp a, b
1851   0E1B FD 7F         sgt ; >
1852   0E1D E4            pop a
1853   0E1E             ; END RELATIONAL
1854   0E1E C0 00 00      cmp b, 0
1855   0E21 C6 4A 0E      je _while29_exit
1856   0E24             _while29_block:
1857   0E24             ;; i--; 
1858   0E24 FA F5 FF      lea d, [bp + -11] ; $i
1859   0E27 2A            mov b, [d]
1860   0E28 D8            push b
1861   0E29 FD 7D         dec b
1862   0E2B FA F5 FF      lea d, [bp + -11] ; $i
1863   0E2E FD 43         mov [d], b
1864   0E30 E5            pop b
1865   0E31             ;; putchar(digits[i]); 
1866   0E31 FA F7 FF      lea d, [bp + -9] ; $digits
1867   0E34 D7            push a
1868   0E35 DA            push d
1869   0E36 FA F5 FF      lea d, [bp + -11] ; $i
1870   0E39 2A            mov b, [d]
1871   0E3A E7            pop d
1872   0E3B 5A            add d, b
1873   0E3C E4            pop a
1874   0E3D 32            mov bl, [d]
1875   0E3E A7 00         mov bh, 0
1876   0E40 DD            push bl
1877   0E41 07 34 0F      call putchar
1878   0E44 51 01 00      add sp, 1
1879   0E47 0A 11 0E      jmp _while29_cond
1880   0E4A             _while29_exit:
1881   0E4A F9            leave
1882   0E4B 09            ret
1883   0E4C             
1884   0E4C             print_unsigned:
1885   0E4C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1886   0E4F             ; $digits 
1887   0E4F             ; $i 
1888   0E4F 52 07 00      sub sp, 7
1889   0E52             ;; i = 0; 
1890   0E52 FA FA FF      lea d, [bp + -6] ; $i
1891   0E55 DA            push d
1892   0E56 26 00 00      mov b, $0
1893   0E59 E7            pop d
1894   0E5A FD 43         mov [d], b
1895   0E5C             ;; if(num == 0){ 
1896   0E5C             _if30_cond:
1897   0E5C FA 05 00      lea d, [bp + 5] ; $num
1898   0E5F 2A            mov b, [d]
1899   0E60             ; START RELATIONAL
1900   0E60 D7            push a
1901   0E61 11            mov a, b
1902   0E62 26 00 00      mov b, $0
1903   0E65 B0            cmp a, b
1904   0E66 FD 71         seq ; ==
1905   0E68 E4            pop a
1906   0E69             ; END RELATIONAL
1907   0E69 C0 00 00      cmp b, 0
1908   0E6C C6 7E 0E      je _if30_exit
1909   0E6F             _if30_true:
1910   0E6F             ;; putchar('0'); 
1911   0E6F 26 30 00      mov b, $30
1912   0E72 DD            push bl
1913   0E73 07 34 0F      call putchar
1914   0E76 51 01 00      add sp, 1
1915   0E79             ;; return; 
1916   0E79 F9            leave
1917   0E7A 09            ret
1918   0E7B 0A 7E 0E      jmp _if30_exit
1919   0E7E             _if30_exit:
1920   0E7E             ;; while (num > 0) { 
1921   0E7E             _while31_cond:
1922   0E7E FA 05 00      lea d, [bp + 5] ; $num
1923   0E81 2A            mov b, [d]
1924   0E82             ; START RELATIONAL
1925   0E82 D7            push a
1926   0E83 11            mov a, b
1927   0E84 26 00 00      mov b, $0
1928   0E87 B0            cmp a, b
1929   0E88 FD 81         sgu ; > (unsigned)
1930   0E8A E4            pop a
1931   0E8B             ; END RELATIONAL
1932   0E8B C0 00 00      cmp b, 0
1933   0E8E C6 D9 0E      je _while31_exit
1934   0E91             _while31_block:
1935   0E91             ;; digits[i] = '0' + (num % 10); 
1936   0E91 FA FC FF      lea d, [bp + -4] ; $digits
1937   0E94 D7            push a
1938   0E95 DA            push d
1939   0E96 FA FA FF      lea d, [bp + -6] ; $i
1940   0E99 2A            mov b, [d]
1941   0E9A E7            pop d
1942   0E9B 5A            add d, b
1943   0E9C E4            pop a
1944   0E9D DA            push d
1945   0E9E 26 30 00      mov b, $30
1946   0EA1             ; START TERMS
1947   0EA1 D7            push a
1948   0EA2 11            mov a, b
1949   0EA3 FA 05 00      lea d, [bp + 5] ; $num
1950   0EA6 2A            mov b, [d]
1951   0EA7             ; START FACTORS
1952   0EA7 D7            push a
1953   0EA8 11            mov a, b
1954   0EA9 26 0A 00      mov b, $a
1955   0EAC AE            div a, b ; 
1956   0EAD 11            mov a, b
1957   0EAE 27            mov b, a
1958   0EAF E4            pop a
1959   0EB0             ; END FACTORS
1960   0EB0 54            add a, b
1961   0EB1 27            mov b, a
1962   0EB2 E4            pop a
1963   0EB3             ; END TERMS
1964   0EB3 E7            pop d
1965   0EB4 FD 3E         mov [d], bl
1966   0EB6             ;; num = num / 10; 
1967   0EB6 FA 05 00      lea d, [bp + 5] ; $num
1968   0EB9 DA            push d
1969   0EBA FA 05 00      lea d, [bp + 5] ; $num
1970   0EBD 2A            mov b, [d]
1971   0EBE             ; START FACTORS
1972   0EBE D7            push a
1973   0EBF 11            mov a, b
1974   0EC0 26 0A 00      mov b, $a
1975   0EC3 AE            div a, b
1976   0EC4 27            mov b, a
1977   0EC5 E4            pop a
1978   0EC6             ; END FACTORS
1979   0EC6 E7            pop d
1980   0EC7 FD 43         mov [d], b
1981   0EC9             ;; i++; 
1982   0EC9 FA FA FF      lea d, [bp + -6] ; $i
1983   0ECC 2A            mov b, [d]
1984   0ECD D8            push b
1985   0ECE FD 77         inc b
1986   0ED0 FA FA FF      lea d, [bp + -6] ; $i
1987   0ED3 FD 43         mov [d], b
1988   0ED5 E5            pop b
1989   0ED6 0A 7E 0E      jmp _while31_cond
1990   0ED9             _while31_exit:
1991   0ED9             ;; while (i > 0) { 
1992   0ED9             _while32_cond:
1993   0ED9 FA FA FF      lea d, [bp + -6] ; $i
1994   0EDC 2A            mov b, [d]
1995   0EDD             ; START RELATIONAL
1996   0EDD D7            push a
1997   0EDE 11            mov a, b
1998   0EDF 26 00 00      mov b, $0
1999   0EE2 B0            cmp a, b
2000   0EE3 FD 7F         sgt ; >
2001   0EE5 E4            pop a
2002   0EE6             ; END RELATIONAL
2003   0EE6 C0 00 00      cmp b, 0
2004   0EE9 C6 12 0F      je _while32_exit
2005   0EEC             _while32_block:
2006   0EEC             ;; i--; 
2007   0EEC FA FA FF      lea d, [bp + -6] ; $i
2008   0EEF 2A            mov b, [d]
2009   0EF0 D8            push b
2010   0EF1 FD 7D         dec b
2011   0EF3 FA FA FF      lea d, [bp + -6] ; $i
2012   0EF6 FD 43         mov [d], b
2013   0EF8 E5            pop b
2014   0EF9             ;; putchar(digits[i]); 
2015   0EF9 FA FC FF      lea d, [bp + -4] ; $digits
2016   0EFC D7            push a
2017   0EFD DA            push d
2018   0EFE FA FA FF      lea d, [bp + -6] ; $i
2019   0F01 2A            mov b, [d]
2020   0F02 E7            pop d
2021   0F03 5A            add d, b
2022   0F04 E4            pop a
2023   0F05 32            mov bl, [d]
2024   0F06 A7 00         mov bh, 0
2025   0F08 DD            push bl
2026   0F09 07 34 0F      call putchar
2027   0F0C 51 01 00      add sp, 1
2028   0F0F 0A D9 0E      jmp _while32_cond
2029   0F12             _while32_exit:
2030   0F12 F9            leave
2031   0F13 09            ret
2032   0F14             
2033   0F14             rand:
2034   0F14 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2035   0F17             ; $sec 
2036   0F17 52 01 00      sub sp, 1
2037   0F1A             
2038   0F1A             ; --- BEGIN INLINE ASM BLOCK
2039   0F1A 19 00         mov al, 0
2040   0F1C 05 01         syscall sys_rtc					
2041   0F1E 1A            mov al, ah
2042   0F1F FA 00 00      lea d, [bp + 0] ; $sec
2043   0F22 1E            mov al, [d]
2044   0F23             ; --- END INLINE ASM BLOCK
2045   0F23             
2046   0F23             ;; return sec; 
2047   0F23 FA 00 00      lea d, [bp + 0] ; $sec
2048   0F26 32            mov bl, [d]
2049   0F27 A7 00         mov bh, 0
2050   0F29 F9            leave
2051   0F2A 09            ret
2052   0F2B             
2053   0F2B             date:
2054   0F2B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2055   0F2E             
2056   0F2E             ; --- BEGIN INLINE ASM BLOCK
2057   0F2E 19 00         mov al, 0 
2058   0F30 05 07         syscall sys_datetime
2059   0F32             ; --- END INLINE ASM BLOCK
2060   0F32             
2061   0F32 F9            leave
2062   0F33 09            ret
2063   0F34             
2064   0F34             putchar:
2065   0F34 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2066   0F37             
2067   0F37             ; --- BEGIN INLINE ASM BLOCK
2068   0F37 FA 05 00      lea d, [bp + 5] ; $c
2069   0F3A 1E            mov al, [d]
2070   0F3B 23            mov ah, al
2071   0F3C 07 B1 11      call _putchar
2072   0F3F             ; --- END INLINE ASM BLOCK
2073   0F3F             
2074   0F3F F9            leave
2075   0F40 09            ret
2076   0F41             
2077   0F41             getchar:
2078   0F41 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2079   0F44             ; $c 
2080   0F44 52 01 00      sub sp, 1
2081   0F47             
2082   0F47             ; --- BEGIN INLINE ASM BLOCK
2083   0F47 07 AA 11      call getch
2084   0F4A 1A            mov al, ah
2085   0F4B FA 00 00      lea d, [bp + 0] ; $c
2086   0F4E 3E            mov [d], al
2087   0F4F             ; --- END INLINE ASM BLOCK
2088   0F4F             
2089   0F4F             ;; return c; 
2090   0F4F FA 00 00      lea d, [bp + 0] ; $c
2091   0F52 32            mov bl, [d]
2092   0F53 A7 00         mov bh, 0
2093   0F55 F9            leave
2094   0F56 09            ret
2095   0F57             
2096   0F57             scann:
2097   0F57 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2098   0F5A             ; $m 
2099   0F5A 52 02 00      sub sp, 2
2100   0F5D             
2101   0F5D             ; --- BEGIN INLINE ASM BLOCK
2102   0F5D 07 F5 13      call scan_u16d
2103   0F60 FA FF FF      lea d, [bp + -1] ; $m
2104   0F63 43            mov [d], a
2105   0F64             ; --- END INLINE ASM BLOCK
2106   0F64             
2107   0F64             ;; return m; 
2108   0F64 FA FF FF      lea d, [bp + -1] ; $m
2109   0F67 2A            mov b, [d]
2110   0F68 F9            leave
2111   0F69 09            ret
2112   0F6A             
2113   0F6A             puts:
2114   0F6A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2115   0F6D             
2116   0F6D             ; --- BEGIN INLINE ASM BLOCK
2117   0F6D FA 05 00      lea d, [bp + 5] ; $s
2118   0F70 15            mov a, [d]
2119   0F71 3C            mov d, a
2120   0F72 07 FB 12      call _puts
2121   0F75 10 00 0A      mov a, $0A00
2122   0F78 05 03         syscall sys_io
2123   0F7A             ; --- END INLINE ASM BLOCK
2124   0F7A             
2125   0F7A F9            leave
2126   0F7B 09            ret
2127   0F7C             
2128   0F7C             print:
2129   0F7C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2130   0F7F             
2131   0F7F             ; --- BEGIN INLINE ASM BLOCK
2132   0F7F FA 05 00      lea d, [bp + 5] ; $s
2133   0F82 FD 2A         mov d, [d]
2134   0F84 07 FB 12      call _puts
2135   0F87             ; --- END INLINE ASM BLOCK
2136   0F87             
2137   0F87 F9            leave
2138   0F88 09            ret
2139   0F89             
2140   0F89             loadfile:
2141   0F89 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2142   0F8C             
2143   0F8C             ; --- BEGIN INLINE ASM BLOCK
2144   0F8C FA 07 00      lea d, [bp + 7] ; $destination
2145   0F8F 15            mov a, [d]
2146   0F90 4F            mov di, a
2147   0F91 FA 05 00      lea d, [bp + 5] ; $filename
2148   0F94 FD 2A         mov d, [d]
2149   0F96 19 14         mov al, 20
2150   0F98 05 04         syscall sys_filesystem
2151   0F9A             ; --- END INLINE ASM BLOCK
2152   0F9A             
2153   0F9A F9            leave
2154   0F9B 09            ret
2155   0F9C             
2156   0F9C             create_file:
2157   0F9C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2158   0F9F F9            leave
2159   0FA0 09            ret
2160   0FA1             
2161   0FA1             delete_file:
2162   0FA1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2163   0FA4             
2164   0FA4             ; --- BEGIN INLINE ASM BLOCK
2165   0FA4 FA 05 00      lea d, [bp + 5] ; $filename
2166   0FA7 19 0A         mov al, 10
2167   0FA9 05 04         syscall sys_filesystem
2168   0FAB             ; --- END INLINE ASM BLOCK
2169   0FAB             
2170   0FAB F9            leave
2171   0FAC 09            ret
2172   0FAD             
2173   0FAD             fopen:
2174   0FAD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2175   0FB0 F9            leave
2176   0FB1 09            ret
2177   0FB2             
2178   0FB2             fclose:
2179   0FB2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2180   0FB5 F9            leave
2181   0FB6 09            ret
2182   0FB7             
2183   0FB7             alloc:
2184   0FB7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2185   0FBA             ;; heap_top = heap_top + bytes; 
2186   0FBA 3B F7 18      mov d, _heap_top ; $heap_top
2187   0FBD DA            push d
2188   0FBE 3B F7 18      mov d, _heap_top ; $heap_top
2189   0FC1 2A            mov b, [d]
2190   0FC2             ; START TERMS
2191   0FC2 D7            push a
2192   0FC3 11            mov a, b
2193   0FC4 FA 05 00      lea d, [bp + 5] ; $bytes
2194   0FC7 2A            mov b, [d]
2195   0FC8 54            add a, b
2196   0FC9 27            mov b, a
2197   0FCA E4            pop a
2198   0FCB             ; END TERMS
2199   0FCB E7            pop d
2200   0FCC FD 43         mov [d], b
2201   0FCE             ;; return heap_top - bytes; 
2202   0FCE 3B F7 18      mov d, _heap_top ; $heap_top
2203   0FD1 2A            mov b, [d]
2204   0FD2             ; START TERMS
2205   0FD2 D7            push a
2206   0FD3 11            mov a, b
2207   0FD4 FA 05 00      lea d, [bp + 5] ; $bytes
2208   0FD7 2A            mov b, [d]
2209   0FD8 60            sub a, b
2210   0FD9 27            mov b, a
2211   0FDA E4            pop a
2212   0FDB             ; END TERMS
2213   0FDB F9            leave
2214   0FDC 09            ret
2215   0FDD             
2216   0FDD             free:
2217   0FDD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2218   0FE0             ;; return heap_top = heap_top - bytes; 
2219   0FE0 3B F7 18      mov d, _heap_top ; $heap_top
2220   0FE3 DA            push d
2221   0FE4 3B F7 18      mov d, _heap_top ; $heap_top
2222   0FE7 2A            mov b, [d]
2223   0FE8             ; START TERMS
2224   0FE8 D7            push a
2225   0FE9 11            mov a, b
2226   0FEA FA 05 00      lea d, [bp + 5] ; $bytes
2227   0FED 2A            mov b, [d]
2228   0FEE 60            sub a, b
2229   0FEF 27            mov b, a
2230   0FF0 E4            pop a
2231   0FF1             ; END TERMS
2232   0FF1 E7            pop d
2233   0FF2 FD 43         mov [d], b
2234   0FF4 F9            leave
2235   0FF5 09            ret
2236   0FF6             
2237   0FF6             exit:
2238   0FF6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2239   0FF9             
2240   0FF9             ; --- BEGIN INLINE ASM BLOCK
2241   0FF9 05 0B         syscall sys_terminate_proc
2242   0FFB             ; --- END INLINE ASM BLOCK
2243   0FFB             
2244   0FFB F9            leave
2245   0FFC 09            ret
2246   0FFD             
2247   0FFD             load_hex:
2248   0FFD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2249   1000             ; $temp 
2250   1000 52 02 00      sub sp, 2
2251   1003             ;; temp = alloc(32768); 
2252   1003 FA FF FF      lea d, [bp + -1] ; $temp
2253   1006 DA            push d
2254   1007 26 00 80      mov b, $8000
2255   100A FD AB         swp b
2256   100C D8            push b
2257   100D 07 B7 0F      call alloc
2258   1010 51 02 00      add sp, 2
2259   1013 E7            pop d
2260   1014 FD 43         mov [d], b
2261   1016             
2262   1016             ; --- BEGIN INLINE ASM BLOCK
2263   1016               
2264   1016               
2265   1016               
2266   1016               
2267   1016               
2268   1016             _load_hex:
2269   1016 D7            push a
2270   1017 D8            push b
2271   1018 DA            push d
2272   1019 E2            push si
2273   101A E3            push di
2274   101B 52 00 80      sub sp, $8000      
2275   101E 38 00 00      mov c, 0
2276   1021 48            mov a, sp
2277   1022 77            inc a
2278   1023 3C            mov d, a          
2279   1024 07 B8 11      call _gets        
2280   1027 4D            mov si, a
2281   1028             __load_hex_loop:
2282   1028 F6            lodsb             
2283   1029 B9 00         cmp al, 0         
2284   102B C6 39 10      jz __load_hex_ret
2285   102E 36            mov bh, al
2286   102F F6            lodsb
2287   1030 2F            mov bl, al
2288   1031 07 6E 11      call _atoi        
2289   1034 F7            stosb             
2290   1035 78            inc c
2291   1036 0A 28 10      jmp __load_hex_loop
2292   1039             __load_hex_ret:
2293   1039 51 00 80      add sp, $8000
2294   103C F0            pop di
2295   103D EF            pop si
2296   103E E7            pop d
2297   103F E5            pop b
2298   1040 E4            pop a
2299   1041             ; --- END INLINE ASM BLOCK
2300   1041             
2301   1041 F9            leave
2302   1042 09            ret
2303   1043             
2304   1043             getparam:
2305   1043 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2306   1046             ; $data 
2307   1046 52 01 00      sub sp, 1
2308   1049             
2309   1049             ; --- BEGIN INLINE ASM BLOCK
2310   1049 19 04         mov al, 4
2311   104B FA 05 00      lea d, [bp + 5] ; $address
2312   104E FD 2A         mov d, [d]
2313   1050 05 0C         syscall sys_system
2314   1052 FA 00 00      lea d, [bp + 0] ; $data
2315   1055 FD 3E         mov [d], bl
2316   1057             ; --- END INLINE ASM BLOCK
2317   1057             
2318   1057             ;; return data; 
2319   1057 FA 00 00      lea d, [bp + 0] ; $data
2320   105A 32            mov bl, [d]
2321   105B A7 00         mov bh, 0
2322   105D F9            leave
2323   105E 09            ret
2324   105F             
2325   105F             clear:
2326   105F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2327   1062             ;; print("\033[2J\033[H"); 
2328   1062 26 EF 18      mov b, __s5 ; "\033[2J\033[H"
2329   1065 FD AB         swp b
2330   1067 D8            push b
2331   1068 07 7C 0F      call print
2332   106B 51 02 00      add sp, 2
2333   106E F9            leave
2334   106F 09            ret
2335   1070             
2336   1070             printun:
2337   1070 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2338   1073             ;; print(prompt); 
2339   1073 FA 05 00      lea d, [bp + 5] ; $prompt
2340   1076 2A            mov b, [d]
2341   1077 FD AB         swp b
2342   1079 D8            push b
2343   107A 07 7C 0F      call print
2344   107D 51 02 00      add sp, 2
2345   1080             ;; print_unsigned(n); 
2346   1080 FA 07 00      lea d, [bp + 7] ; $n
2347   1083 2A            mov b, [d]
2348   1084 FD AB         swp b
2349   1086 D8            push b
2350   1087 07 4C 0E      call print_unsigned
2351   108A 51 02 00      add sp, 2
2352   108D             ;; print("\n"); 
2353   108D 26 B1 18      mov b, __s2 ; "\n"
2354   1090 FD AB         swp b
2355   1092 D8            push b
2356   1093 07 7C 0F      call print
2357   1096 51 02 00      add sp, 2
2358   1099 F9            leave
2359   109A 09            ret
2360   109B             
2361   109B             printsn:
2362   109B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2363   109E             ;; print(prompt); 
2364   109E FA 05 00      lea d, [bp + 5] ; $prompt
2365   10A1 2A            mov b, [d]
2366   10A2 FD AB         swp b
2367   10A4 D8            push b
2368   10A5 07 7C 0F      call print
2369   10A8 51 02 00      add sp, 2
2370   10AB             ;; print_signed(n); 
2371   10AB FA 07 00      lea d, [bp + 7] ; $n
2372   10AE 2A            mov b, [d]
2373   10AF FD AB         swp b
2374   10B1 D8            push b
2375   10B2 07 2F 0B      call print_signed
2376   10B5 51 02 00      add sp, 2
2377   10B8             ;; print("\n"); 
2378   10B8 26 B1 18      mov b, __s2 ; "\n"
2379   10BB FD AB         swp b
2380   10BD D8            push b
2381   10BE 07 7C 0F      call print
2382   10C1 51 02 00      add sp, 2
2383   10C4 F9            leave
2384   10C5 09            ret
2385   10C6             
2386   10C6             include_stdio_asm:
2387   10C6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2388   10C9             
2389   10C9             ; --- BEGIN INLINE ASM BLOCK
2390   10C9             .include "lib/asm/stdio.asm"
0001+  10C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  10C9             ; stdio.s
0003+  10C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  10C9             .include "lib/asm/string.asm"
0001++ 10C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 10C9             ; string.s
0003++ 10C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 10C9             
0005++ 10C9             
0006++ 10C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 10C9             ; _strrev
0008++ 10C9             ; reverse a string
0009++ 10C9             ; D = string address
0010++ 10C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 10C9             ; 01234
0012++ 10C9             _strrev:
0013++ 10C9 4B          	pusha
0014++ 10CA 07 10 11    	call _strlen	; length in C
0015++ 10CD 12          	mov a, c
0016++ 10CE AF 01 00    	cmp a, 1
0017++ 10D1 D0 EB 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 10D4 7D          	dec a
0019++ 10D5 FD 4E       	mov si, d	; beginning of string
0020++ 10D7 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 10D9 59          	add d, a	; end of string
0022++ 10DA 12          	mov a, c
0023++ 10DB FD 9B       	shr a		; divide by 2
0024++ 10DD 39          	mov c, a	; C now counts the steps
0025++ 10DE             _strrev_L0:
0026++ 10DE 32          	mov bl, [d]	; save load right-side char into BL
0027++ 10DF F6          	lodsb		; load left-side char into AL; increase SI
0028++ 10E0 3E          	mov [d], al	; store left char into right side
0029++ 10E1 1B          	mov al, bl
0030++ 10E2 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 10E3 7E          	dec c
0032++ 10E4 7F          	dec d
0033++ 10E5 C2 00 00    	cmp c, 0
0034++ 10E8 C7 DE 10    	jne _strrev_L0
0035++ 10EB             _strrev_end:
0036++ 10EB 4C          	popa
0037++ 10EC 09          	ret
0038++ 10ED             	
0039++ 10ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10ED             ; _strchr
0041++ 10ED             ; search string in D for char in AL
0042++ 10ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10ED             _strchr:
0044++ 10ED             _strchr_L0:
0045++ 10ED 32          	mov bl, [d]
0046++ 10EE C1 00       	cmp bl, 0
0047++ 10F0 C6 FB 10    	je _strchr_end
0048++ 10F3 BA          	cmp al, bl
0049++ 10F4 C6 FB 10    	je _strchr_end
0050++ 10F7 79          	inc d
0051++ 10F8 0A ED 10    	jmp _strchr_L0
0052++ 10FB             _strchr_end:
0053++ 10FB 1B          	mov al, bl
0054++ 10FC 09          	ret
0055++ 10FD             
0056++ 10FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10FD             ; _strstr
0058++ 10FD             ; find sub-string
0059++ 10FD             ; str1 in SI
0060++ 10FD             ; str2 in DI
0061++ 10FD             ; SI points to end of source string
0062++ 10FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10FD             _strstr:
0064++ 10FD DB          	push al
0065++ 10FE DA          	push d
0066++ 10FF E3          	push di
0067++ 1100             _strstr_loop:
0068++ 1100 F3          	cmpsb					; compare a byte of the strings
0069++ 1101 C7 0C 11    	jne _strstr_ret
0070++ 1104 FC 00 00    	lea d, [di + 0]
0071++ 1107 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1109 C7 00 11    	jne _strstr_loop				; equal chars but not at end
0073++ 110C             _strstr_ret:
0074++ 110C F0          	pop di
0075++ 110D E7          	pop d
0076++ 110E E8          	pop al
0077++ 110F 09          	ret
0078++ 1110             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1110             ; length of null terminated string
0080++ 1110             ; result in C
0081++ 1110             ; pointer in D
0082++ 1110             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1110             _strlen:
0084++ 1110 DA          	push d
0085++ 1111 38 00 00    	mov c, 0
0086++ 1114             _strlen_L1:
0087++ 1114 BD 00       	cmp byte [d], 0
0088++ 1116 C6 1E 11    	je _strlen_ret
0089++ 1119 79          	inc d
0090++ 111A 78          	inc c
0091++ 111B 0A 14 11    	jmp _strlen_L1
0092++ 111E             _strlen_ret:
0093++ 111E E7          	pop d
0094++ 111F 09          	ret
0095++ 1120             
0096++ 1120             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1120             ; STRCMP
0098++ 1120             ; compare two strings
0099++ 1120             ; str1 in SI
0100++ 1120             ; str2 in DI
0101++ 1120             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1120             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1120             _strcmp:
0104++ 1120 DB          	push al
0105++ 1121 DA          	push d
0106++ 1122 E3          	push di
0107++ 1123 E2          	push si
0108++ 1124             _strcmp_loop:
0109++ 1124 F3          	cmpsb					; compare a byte of the strings
0110++ 1125 C7 30 11    	jne _strcmp_ret
0111++ 1128 FB FF FF    	lea d, [si +- 1]
0112++ 112B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 112D C7 24 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 1130             _strcmp_ret:
0115++ 1130 EF          	pop si
0116++ 1131 F0          	pop di
0117++ 1132 E7          	pop d
0118++ 1133 E8          	pop al
0119++ 1134 09          	ret
0120++ 1135             
0121++ 1135             
0122++ 1135             ; STRCPY
0123++ 1135             ; copy null terminated string from SI to DI
0124++ 1135             ; source in SI
0125++ 1135             ; destination in DI
0126++ 1135             _strcpy:
0127++ 1135 E2          	push si
0128++ 1136 E3          	push di
0129++ 1137 DB          	push al
0130++ 1138             _strcpy_L1:
0131++ 1138 F6          	lodsb
0132++ 1139 F7          	stosb
0133++ 113A B9 00       	cmp al, 0
0134++ 113C C7 38 11    	jne _strcpy_L1
0135++ 113F             _strcpy_end:
0136++ 113F E8          	pop al
0137++ 1140 F0          	pop di
0138++ 1141 EF          	pop si
0139++ 1142 09          	ret
0140++ 1143             
0141++ 1143             ; STRCAT
0142++ 1143             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1143             ; source in SI
0144++ 1143             ; destination in DI
0145++ 1143             _strcat:
0146++ 1143 E2          	push si
0147++ 1144 E3          	push di
0148++ 1145 D7          	push a
0149++ 1146 DA          	push d
0150++ 1147 50          	mov a, di
0151++ 1148 3C          	mov d, a
0152++ 1149             _strcat_goto_end_L1:
0153++ 1149 BD 00       	cmp byte[d], 0
0154++ 114B C6 52 11    	je _strcat_start
0155++ 114E 79          	inc d
0156++ 114F 0A 49 11    	jmp _strcat_goto_end_L1
0157++ 1152             _strcat_start:
0158++ 1152 FD 50       	mov di, d
0159++ 1154             _strcat_L1:
0160++ 1154 F6          	lodsb
0161++ 1155 F7          	stosb
0162++ 1156 B9 00       	cmp al, 0
0163++ 1158 C7 54 11    	jne _strcat_L1
0164++ 115B             _strcat_end:
0165++ 115B E7          	pop d
0166++ 115C E4          	pop a
0167++ 115D F0          	pop di
0168++ 115E EF          	pop si
0169++ 115F 09          	ret
0170++ 1160             
0171++ 1160             
0005+  1160             
0006+  1160             
0007+  1160             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1160             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  1160             ; ASCII in BL
0010+  1160             ; result in AL
0011+  1160             ; ascii for F = 0100 0110
0012+  1160             ; ascii for 9 = 0011 1001
0013+  1160             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1160             hex_ascii_encode:
0015+  1160 1B            mov al, bl
0016+  1161 93 40         test al, $40        ; test if letter or number
0017+  1163 C7 69 11      jnz hex_letter
0018+  1166 87 0F         and al, $0F        ; get number
0019+  1168 09            ret
0020+  1169             hex_letter:
0021+  1169 87 0F         and al, $0F        ; get letter
0022+  116B 6A 09         add al, 9
0023+  116D 09            ret
0024+  116E             
0025+  116E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  116E             ; ATOI
0027+  116E             ; 2 letter hex string in B
0028+  116E             ; 8bit integer returned in AL
0029+  116E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  116E             _atoi:
0031+  116E D8            push b
0032+  116F 07 60 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  1172 30            mov bl, bh
0034+  1173 DB            push al          ; save a
0035+  1174 07 60 11      call hex_ascii_encode
0036+  1177 EA            pop bl  
0037+  1178 FD 9E 04      shl al, 4
0038+  117B 8C            or al, bl
0039+  117C E5            pop b
0040+  117D 09            ret  
0041+  117E             
0042+  117E             
0043+  117E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  117E             ; scanf
0045+  117E             ; no need for explanations!
0046+  117E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  117E             scanf:
0048+  117E 09            ret
0049+  117F             
0050+  117F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  117F             ; ITOA
0052+  117F             ; 8bit value in BL
0053+  117F             ; 2 byte ASCII result in A
0054+  117F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  117F             _itoa:
0056+  117F DA            push d
0057+  1180 D8            push b
0058+  1181 A7 00         mov bh, 0
0059+  1183 FD A4 04      shr bl, 4  
0060+  1186 74            mov d, b
0061+  1187 1F 2F 14      mov al, [d + s_hex_digits]
0062+  118A 23            mov ah, al
0063+  118B               
0064+  118B E5            pop b
0065+  118C D8            push b
0066+  118D A7 00         mov bh, 0
0067+  118F FD 87 0F      and bl, $0F
0068+  1192 74            mov d, b
0069+  1193 1F 2F 14      mov al, [d + s_hex_digits]
0070+  1196 E5            pop b
0071+  1197 E7            pop d
0072+  1198 09            ret
0073+  1199             
0074+  1199             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1199             ; HEX STRING TO BINARY
0076+  1199             ; di = destination address
0077+  1199             ; si = source
0078+  1199             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1199             _hex_to_int:
0080+  1199             _hex_to_int_L1:
0081+  1199 F6            lodsb          ; load from [SI] to AL
0082+  119A B9 00         cmp al, 0        ; check if ASCII 0
0083+  119C C6 A9 11      jz _hex_to_int_ret
0084+  119F 36            mov bh, al
0085+  11A0 F6            lodsb
0086+  11A1 2F            mov bl, al
0087+  11A2 07 6E 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  11A5 F7            stosb          ; store AL to [DI]
0089+  11A6 0A 99 11      jmp _hex_to_int_L1
0090+  11A9             _hex_to_int_ret:
0091+  11A9 09            ret    
0092+  11AA             
0093+  11AA             
0094+  11AA             
0095+  11AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  11AA             ; GETCHAR
0097+  11AA             ; char in ah
0098+  11AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  11AA             getch:
0100+  11AA DB            push al
0101+  11AB             getch_retry:
0102+  11AB 19 01         mov al, 1
0103+  11AD 05 03         syscall sys_io      ; receive in AH
0104+  11AF E8            pop al
0105+  11B0 09            ret
0106+  11B1             
0107+  11B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  11B1             ; PUTCHAR
0109+  11B1             ; char in ah
0110+  11B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  11B1             _putchar:
0112+  11B1 D7            push a
0113+  11B2 19 00         mov al, 0
0114+  11B4 05 03         syscall sys_io      ; char in AH
0115+  11B6 E4            pop a
0116+  11B7 09            ret
0117+  11B8             
0118+  11B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  11B8             ;; INPUT A STRING
0120+  11B8             ;; terminates with null
0121+  11B8             ;; pointer in D
0122+  11B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  11B8             _gets:
0124+  11B8 D7            push a
0125+  11B9 DA            push d
0126+  11BA             _gets_loop:
0127+  11BA 19 01         mov al, 1
0128+  11BC 05 03         syscall sys_io      ; receive in AH
0129+  11BE B9 00         cmp al, 0        ; check error code (AL)
0130+  11C0 C6 BA 11      je _gets_loop      ; if no char received, retry
0131+  11C3             
0132+  11C3 76 1B         cmp ah, 27
0133+  11C5 C6 E6 11      je _gets_ansi_esc
0134+  11C8 76 0A         cmp ah, $0A        ; LF
0135+  11CA C6 51 12      je _gets_end
0136+  11CD 76 0D         cmp ah, $0D        ; CR
0137+  11CF C6 51 12      je _gets_end
0138+  11D2 76 5C         cmp ah, $5C        ; '\\'
0139+  11D4 C6 12 12      je _gets_escape
0140+  11D7               
0141+  11D7 76 08         cmp ah, $08      ; check for backspace
0142+  11D9 C6 E2 11      je _gets_backspace
0143+  11DC             
0144+  11DC 1A            mov al, ah
0145+  11DD 3E            mov [d], al
0146+  11DE 79            inc d
0147+  11DF 0A BA 11      jmp _gets_loop
0148+  11E2             _gets_backspace:
0149+  11E2 7F            dec d
0150+  11E3 0A BA 11      jmp _gets_loop
0151+  11E6             _gets_ansi_esc:
0152+  11E6 19 01         mov al, 1
0153+  11E8 05 03         syscall sys_io        ; receive in AH without echo
0154+  11EA B9 00         cmp al, 0          ; check error code (AL)
0155+  11EC C6 E6 11      je _gets_ansi_esc    ; if no char received, retry
0156+  11EF 76 5B         cmp ah, '['
0157+  11F1 C7 BA 11      jne _gets_loop
0158+  11F4             _gets_ansi_esc_2:
0159+  11F4 19 01         mov al, 1
0160+  11F6 05 03         syscall sys_io          ; receive in AH without echo
0161+  11F8 B9 00         cmp al, 0            ; check error code (AL)
0162+  11FA C6 F4 11      je _gets_ansi_esc_2  ; if no char received, retry
0163+  11FD 76 44         cmp ah, 'D'
0164+  11FF C6 0A 12      je _gets_left_arrow
0165+  1202 76 43         cmp ah, 'C'
0166+  1204 C6 0E 12      je _gets_right_arrow
0167+  1207 0A BA 11      jmp _gets_loop
0168+  120A             _gets_left_arrow:
0169+  120A 7F            dec d
0170+  120B 0A BA 11      jmp _gets_loop
0171+  120E             _gets_right_arrow:
0172+  120E 79            inc d
0173+  120F 0A BA 11      jmp _gets_loop
0174+  1212             _gets_escape:
0175+  1212 19 01         mov al, 1
0176+  1214 05 03         syscall sys_io      ; receive in AH
0177+  1216 B9 00         cmp al, 0        ; check error code (AL)
0178+  1218 C6 12 12      je _gets_escape      ; if no char received, retry
0179+  121B 76 6E         cmp ah, 'n'
0180+  121D C6 3C 12      je _gets_LF
0181+  1220 76 72         cmp ah, 'r'
0182+  1222 C6 43 12      je _gets_CR
0183+  1225 76 30         cmp ah, '0'
0184+  1227 C6 4A 12      je _gets_NULL
0185+  122A 76 5C         cmp ah, $5C  ; '\'
0186+  122C C6 35 12      je _gets_slash
0187+  122F 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  1230 3E            mov [d], al
0189+  1231 79            inc d
0190+  1232 0A BA 11      jmp _gets_loop
0191+  1235             _gets_slash:
0192+  1235 19 5C         mov al, $5C
0193+  1237 3E            mov [d], al
0194+  1238 79            inc d
0195+  1239 0A BA 11      jmp _gets_loop
0196+  123C             _gets_LF:
0197+  123C 19 0A         mov al, $0A
0198+  123E 3E            mov [d], al
0199+  123F 79            inc d
0200+  1240 0A BA 11      jmp _gets_loop
0201+  1243             _gets_CR:
0202+  1243 19 0D         mov al, $0D
0203+  1245 3E            mov [d], al
0204+  1246 79            inc d
0205+  1247 0A BA 11      jmp _gets_loop
0206+  124A             _gets_NULL:
0207+  124A 19 00         mov al, $00
0208+  124C 3E            mov [d], al
0209+  124D 79            inc d
0210+  124E 0A BA 11      jmp _gets_loop
0211+  1251             _gets_end:
0212+  1251 19 00         mov al, 0
0213+  1253 3E            mov [d], al        ; terminate string
0214+  1254 E7            pop d
0215+  1255 E4            pop a
0216+  1256 09            ret
0217+  1257             
0218+  1257             
0219+  1257             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  1257             ;; INPUT TEXT
0221+  1257             ;; terminated with CTRL+D
0222+  1257             ;; pointer in D
0223+  1257             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  1257             _gettxt:
0225+  1257 D7            push a
0226+  1258 DA            push d
0227+  1259             _gettxt_loop:
0228+  1259 19 01         mov al, 1
0229+  125B 05 03         syscall sys_io      ; receive in AH
0230+  125D B9 00         cmp al, 0        ; check error code (AL)
0231+  125F C6 59 12      je _gettxt_loop    ; if no char received, retry
0232+  1262 76 04         cmp ah, 4      ; EOT
0233+  1264 C6 A2 12      je _gettxt_end
0234+  1267 76 08         cmp ah, $08      ; check for backspace
0235+  1269 C6 9E 12      je _gettxt_backspace
0236+  126C 76 5C         cmp ah, $5C        ; '\'
0237+  126E C6 77 12      je _gettxt_escape
0238+  1271 1A            mov al, ah
0239+  1272 3E            mov [d], al
0240+  1273 79            inc d
0241+  1274 0A 59 12      jmp _gettxt_loop
0242+  1277             _gettxt_escape:
0243+  1277 19 01         mov al, 1
0244+  1279 05 03         syscall sys_io      ; receive in AH
0245+  127B B9 00         cmp al, 0        ; check error code (AL)
0246+  127D C6 77 12      je _gettxt_escape    ; if no char received, retry
0247+  1280 76 6E         cmp ah, 'n'
0248+  1282 C6 90 12      je _gettxt_LF
0249+  1285 76 72         cmp ah, 'r'
0250+  1287 C6 97 12      je _gettxt_CR
0251+  128A 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  128B 3E            mov [d], al
0253+  128C 79            inc d
0254+  128D 0A 59 12      jmp _gettxt_loop
0255+  1290             _gettxt_LF:
0256+  1290 19 0A         mov al, $0A
0257+  1292 3E            mov [d], al
0258+  1293 79            inc d
0259+  1294 0A 59 12      jmp _gettxt_loop
0260+  1297             _gettxt_CR:
0261+  1297 19 0D         mov al, $0D
0262+  1299 3E            mov [d], al
0263+  129A 79            inc d
0264+  129B 0A 59 12      jmp _gettxt_loop
0265+  129E             _gettxt_backspace:
0266+  129E 7F            dec d
0267+  129F 0A 59 12      jmp _gettxt_loop
0268+  12A2             _gettxt_end:
0269+  12A2 19 00         mov al, 0
0270+  12A4 3E            mov [d], al        ; terminate string
0271+  12A5 E7            pop d
0272+  12A6 E4            pop a
0273+  12A7 09            ret
0274+  12A8             
0275+  12A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  12A8             ; PRINT NEW LINE
0277+  12A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  12A8             printnl:
0279+  12A8 D7            push a
0280+  12A9 10 00 0A      mov a, $0A00
0281+  12AC 05 03         syscall sys_io
0282+  12AE 10 00 0D      mov a, $0D00
0283+  12B1 05 03         syscall sys_io
0284+  12B3 E4            pop a
0285+  12B4 09            ret
0286+  12B5             
0287+  12B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  12B5             ; _strtoint
0289+  12B5             ; 4 digit hex string number in d
0290+  12B5             ; integer returned in A
0291+  12B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  12B5             _strtointx:
0293+  12B5 D8            push b
0294+  12B6 32            mov bl, [d]
0295+  12B7 37            mov bh, bl
0296+  12B8 33 01 00      mov bl, [d + 1]
0297+  12BB 07 6E 11      call _atoi        ; convert to int in AL
0298+  12BE 23            mov ah, al        ; move to AH
0299+  12BF 33 02 00      mov bl, [d + 2]
0300+  12C2 37            mov bh, bl
0301+  12C3 33 03 00      mov bl, [d + 3]
0302+  12C6 07 6E 11      call _atoi        ; convert to int in AL
0303+  12C9 E5            pop b
0304+  12CA 09            ret
0305+  12CB             
0306+  12CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  12CB             ; _strtoint
0308+  12CB             ; 5 digit base10 string number in d
0309+  12CB             ; integer returned in A
0310+  12CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  12CB             _strtoint:
0312+  12CB E2            push si
0313+  12CC D8            push b
0314+  12CD D9            push c
0315+  12CE DA            push d
0316+  12CF 07 10 11      call _strlen      ; get string length in C
0317+  12D2 7E            dec c
0318+  12D3 FD 4E         mov si, d
0319+  12D5 12            mov a, c
0320+  12D6 FD 99         shl a
0321+  12D8 3B 47 14      mov d, table_power
0322+  12DB 59            add d, a
0323+  12DC 38 00 00      mov c, 0
0324+  12DF             _strtoint_L0:
0325+  12DF F6            lodsb      ; load ASCII to al
0326+  12E0 B9 00         cmp al, 0
0327+  12E2 C6 F5 12      je _strtoint_end
0328+  12E5 6F 30         sub al, $30    ; make into integer
0329+  12E7 22 00         mov ah, 0
0330+  12E9 2A            mov b, [d]
0331+  12EA AC            mul a, b      ; result in B since it fits in 16bits
0332+  12EB 11            mov a, b
0333+  12EC 28            mov b, c
0334+  12ED 54            add a, b
0335+  12EE 39            mov c, a
0336+  12EF 63 02 00      sub d, 2
0337+  12F2 0A DF 12      jmp _strtoint_L0
0338+  12F5             _strtoint_end:
0339+  12F5 12            mov a, c
0340+  12F6 E7            pop d
0341+  12F7 E6            pop c
0342+  12F8 E5            pop b
0343+  12F9 EF            pop si
0344+  12FA 09            ret
0345+  12FB             
0346+  12FB             
0347+  12FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  12FB             ; PRINT NULL TERMINATED STRING
0349+  12FB             ; pointer in D
0350+  12FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  12FB             _puts:
0352+  12FB D7            push a
0353+  12FC DA            push d
0354+  12FD             _puts_L1:
0355+  12FD 1E            mov al, [d]
0356+  12FE B9 00         cmp al, 0
0357+  1300 C6 0C 13      jz _puts_END
0358+  1303 23            mov ah, al
0359+  1304 19 00         mov al, 0
0360+  1306 05 03         syscall sys_io
0361+  1308 79            inc d
0362+  1309 0A FD 12      jmp _puts_L1
0363+  130C             _puts_END:
0364+  130C E7            pop d
0365+  130D E4            pop a
0366+  130E 09            ret
0367+  130F             
0368+  130F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  130F             ; PRINT N SIZE STRING
0370+  130F             ; pointer in D
0371+  130F             ; size in C
0372+  130F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  130F             _putsn:
0374+  130F DB            push al
0375+  1310 DA            push d
0376+  1311 D9            push c
0377+  1312             _putsn_L0:
0378+  1312 1E            mov al, [d]
0379+  1313 23            mov ah, al
0380+  1314 19 00         mov al, 0
0381+  1316 05 03         syscall sys_io
0382+  1318 79            inc d
0383+  1319 7E            dec c  
0384+  131A C2 00 00      cmp c, 0
0385+  131D C7 12 13      jne _putsn_L0
0386+  1320             _putsn_end:
0387+  1320 E6            pop c
0388+  1321 E7            pop d
0389+  1322 E8            pop al
0390+  1323 09            ret
0391+  1324             
0392+  1324             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1324             ; print 16bit decimal number
0394+  1324             ; input number in A
0395+  1324             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1324             print_u16d:
0397+  1324 D7            push a
0398+  1325 D8            push b
0399+  1326 26 10 27      mov b, 10000
0400+  1329 AE            div a, b      ; get 10000's coeff.
0401+  132A 07 4C 13      call print_number
0402+  132D 11            mov a, b
0403+  132E 26 E8 03      mov b, 1000
0404+  1331 AE            div a, b      ; get 1000's coeff.
0405+  1332 07 4C 13      call print_number
0406+  1335 11            mov a, b
0407+  1336 26 64 00      mov b, 100
0408+  1339 AE            div a, b
0409+  133A 07 4C 13      call print_number
0410+  133D 11            mov a, b
0411+  133E 26 0A 00      mov b, 10
0412+  1341 AE            div a, b
0413+  1342 07 4C 13      call print_number
0414+  1345 1B            mov al, bl      ; 1's coeff in bl
0415+  1346 07 4C 13      call print_number
0416+  1349 E5            pop b
0417+  134A E4            pop a
0418+  134B 09            ret
0419+  134C             
0420+  134C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  134C             ; print AL
0422+  134C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  134C             print_number:
0424+  134C 6A 30         add al, $30
0425+  134E 23            mov ah, al
0426+  134F 07 B1 11      call _putchar
0427+  1352 09            ret
0428+  1353             
0429+  1353             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1353             ; PRINT 16BIT HEX INTEGER
0431+  1353             ; integer value in reg B
0432+  1353             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1353             print_u16x:
0434+  1353 D7            push a
0435+  1354 D8            push b
0436+  1355 DD            push bl
0437+  1356 30            mov bl, bh
0438+  1357 07 7F 11      call _itoa        ; convert bh to char in A
0439+  135A 2F            mov bl, al        ; save al
0440+  135B 19 00         mov al, 0
0441+  135D 05 03         syscall sys_io        ; display AH
0442+  135F 24            mov ah, bl        ; retrieve al
0443+  1360 19 00         mov al, 0
0444+  1362 05 03         syscall sys_io        ; display AL
0445+  1364             
0446+  1364 EA            pop bl
0447+  1365 07 7F 11      call _itoa        ; convert bh to char in A
0448+  1368 2F            mov bl, al        ; save al
0449+  1369 19 00         mov al, 0
0450+  136B 05 03         syscall sys_io        ; display AH
0451+  136D 24            mov ah, bl        ; retrieve al
0452+  136E 19 00         mov al, 0
0453+  1370 05 03         syscall sys_io        ; display AL
0454+  1372             
0455+  1372 E5            pop b
0456+  1373 E4            pop a
0457+  1374 09            ret
0458+  1375             
0459+  1375             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  1375             ; INPUT 16BIT HEX INTEGER
0461+  1375             ; read 16bit integer into A
0462+  1375             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  1375             scan_u16x:
0464+  1375 F8 10 00      enter 16
0465+  1378 D8            push b
0466+  1379 DA            push d
0467+  137A             
0468+  137A FA F1 FF      lea d, [bp + -15]
0469+  137D 07 B8 11      call _gets        ; get number
0470+  1380             
0471+  1380 32            mov bl, [d]
0472+  1381 37            mov bh, bl
0473+  1382 33 01 00      mov bl, [d + 1]
0474+  1385 07 6E 11      call _atoi        ; convert to int in AL
0475+  1388 23            mov ah, al        ; move to AH
0476+  1389             
0477+  1389 33 02 00      mov bl, [d + 2]
0478+  138C 37            mov bh, bl
0479+  138D 33 03 00      mov bl, [d + 3]
0480+  1390 07 6E 11      call _atoi        ; convert to int in AL
0481+  1393             
0482+  1393 E7            pop d
0483+  1394 E5            pop b
0484+  1395 F9            leave
0485+  1396 09            ret
0486+  1397             
0487+  1397             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  1397             ; PRINT 8bit HEX INTEGER
0489+  1397             ; integer value in reg bl
0490+  1397             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  1397             print_u8x:
0492+  1397 D7            push a
0493+  1398 DD            push bl
0494+  1399             
0495+  1399 07 7F 11      call _itoa        ; convert bl to char in A
0496+  139C 2F            mov bl, al        ; save al
0497+  139D 19 00         mov al, 0
0498+  139F 05 03         syscall sys_io        ; display AH
0499+  13A1 24            mov ah, bl        ; retrieve al
0500+  13A2 19 00         mov al, 0
0501+  13A4 05 03         syscall sys_io        ; display AL
0502+  13A6             
0503+  13A6 EA            pop bl
0504+  13A7 E4            pop a
0505+  13A8 09            ret
0506+  13A9             
0507+  13A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  13A9             ; print 8bit decimal unsigned number
0509+  13A9             ; input number in AL
0510+  13A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  13A9             print_u8d:
0512+  13A9 D7            push a
0513+  13AA D8            push b
0514+  13AB             
0515+  13AB 22 00         mov ah, 0
0516+  13AD 26 64 00      mov b, 100
0517+  13B0 AE            div a, b
0518+  13B1 D8            push b      ; save remainder
0519+  13B2 B9 00         cmp al, 0
0520+  13B4 C6 BE 13      je skip100
0521+  13B7 6A 30         add al, $30
0522+  13B9 23            mov ah, al
0523+  13BA 19 00         mov al, 0
0524+  13BC 05 03         syscall sys_io  ; print coeff
0525+  13BE             skip100:
0526+  13BE E4            pop a
0527+  13BF 22 00         mov ah, 0
0528+  13C1 26 0A 00      mov b, 10
0529+  13C4 AE            div a, b
0530+  13C5 D8            push b      ; save remainder
0531+  13C6 B9 00         cmp al, 0
0532+  13C8 C6 D2 13      je skip10
0533+  13CB 6A 30         add al, $30
0534+  13CD 23            mov ah, al
0535+  13CE 19 00         mov al, 0
0536+  13D0 05 03         syscall sys_io  ; print coeff
0537+  13D2             skip10:
0538+  13D2 E4            pop a
0539+  13D3 1B            mov al, bl
0540+  13D4 6A 30         add al, $30
0541+  13D6 23            mov ah, al
0542+  13D7 19 00         mov al, 0
0543+  13D9 05 03         syscall sys_io  ; print coeff
0544+  13DB E5            pop b
0545+  13DC E4            pop a
0546+  13DD 09            ret
0547+  13DE             
0548+  13DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  13DE             ; INPUT 8BIT HEX INTEGER
0550+  13DE             ; read 8bit integer into AL
0551+  13DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  13DE             scan_u8x:
0553+  13DE F8 04 00      enter 4
0554+  13E1 D8            push b
0555+  13E2 DA            push d
0556+  13E3             
0557+  13E3 FA FD FF      lea d, [bp + -3]
0558+  13E6 07 B8 11      call _gets        ; get number
0559+  13E9             
0560+  13E9 32            mov bl, [d]
0561+  13EA 37            mov bh, bl
0562+  13EB 33 01 00      mov bl, [d + 1]
0563+  13EE 07 6E 11      call _atoi        ; convert to int in AL
0564+  13F1             
0565+  13F1 E7            pop d
0566+  13F2 E5            pop b
0567+  13F3 F9            leave
0568+  13F4 09            ret
0569+  13F5             
0570+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  13F5             ; input decimal number
0572+  13F5             ; result in A
0573+  13F5             ; 655'\0'
0574+  13F5             ; low--------high
0575+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  13F5             scan_u16d:
0577+  13F5 F8 08 00      enter 8
0578+  13F8 E2            push si
0579+  13F9 D8            push b
0580+  13FA D9            push c
0581+  13FB DA            push d
0582+  13FC FA F9 FF      lea d, [bp +- 7]
0583+  13FF 07 B8 11      call _gets
0584+  1402 07 10 11      call _strlen      ; get string length in C
0585+  1405 7E            dec c
0586+  1406 FD 4E         mov si, d
0587+  1408 12            mov a, c
0588+  1409 FD 99         shl a
0589+  140B 3B 47 14      mov d, table_power
0590+  140E 59            add d, a
0591+  140F 38 00 00      mov c, 0
0592+  1412             mul_loop:
0593+  1412 F6            lodsb      ; load ASCII to al
0594+  1413 B9 00         cmp al, 0
0595+  1415 C6 28 14      je mul_exit
0596+  1418 6F 30         sub al, $30    ; make into integer
0597+  141A 22 00         mov ah, 0
0598+  141C 2A            mov b, [d]
0599+  141D AC            mul a, b      ; result in B since it fits in 16bits
0600+  141E 11            mov a, b
0601+  141F 28            mov b, c
0602+  1420 54            add a, b
0603+  1421 39            mov c, a
0604+  1422 63 02 00      sub d, 2
0605+  1425 0A 12 14      jmp mul_loop
0606+  1428             mul_exit:
0607+  1428 12            mov a, c
0608+  1429 E7            pop d
0609+  142A E6            pop c
0610+  142B E5            pop b
0611+  142C EF            pop si
0612+  142D F9            leave
0613+  142E 09            ret
0614+  142F             
0615+  142F             
0616+  142F 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1433 34 35 36 37 
0616+  1437 38 39 41 42 
0616+  143B 43 44 45 46 
0617+  143F 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1443 1B 5B 48 00 
0618+  1447             
0619+  1447             table_power:
0620+  1447 01 00         .dw 1
0621+  1449 0A 00         .dw 10
0622+  144B 64 00         .dw 100
0623+  144D E8 03         .dw 1000
0624+  144F 10 27         .dw 100002391   1451             ; --- END INLINE ASM BLOCK
2392   1451             
2393   1451 F9            leave
2394   1452 09            ret
2395   1453             
2396   1453             base64_encode:
2397   1453 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2398   1456             ; $i 
2399   1456 10 00 00      mov a, $0
2400   1459 45 FF FF      mov [bp + -1], a
2401   145C             ; $j 
2402   145C 10 00 00      mov a, $0
2403   145F 45 FD FF      mov [bp + -3], a
2404   1462             ; $k 
2405   1462             ; $input_len 
2406   1462             ; $input_buffer 
2407   1462             ; $output_buffer 
2408   1462 52 0F 00      sub sp, 15
2409   1465             ;; input_len = strlen(input); 
2410   1465 FA F9 FF      lea d, [bp + -7] ; $input_len
2411   1468 DA            push d
2412   1469 FA 05 00      lea d, [bp + 5] ; $input
2413   146C 2A            mov b, [d]
2414   146D FD AB         swp b
2415   146F D8            push b
2416   1470 07 D5 05      call strlen
2417   1473 51 02 00      add sp, 2
2418   1476 E7            pop d
2419   1477 FD 43         mov [d], b
2420   1479             ;; while (input_len--) { 
2421   1479             _while33_cond:
2422   1479 FA F9 FF      lea d, [bp + -7] ; $input_len
2423   147C 2A            mov b, [d]
2424   147D D8            push b
2425   147E FD 7D         dec b
2426   1480 FA F9 FF      lea d, [bp + -7] ; $input_len
2427   1483 FD 43         mov [d], b
2428   1485 E5            pop b
2429   1486 C0 00 00      cmp b, 0
2430   1489 C6 3F 16      je _while33_exit
2431   148C             _while33_block:
2432   148C             ;; input_buffer[i++] = *(input++); 
2433   148C FA F6 FF      lea d, [bp + -10] ; $input_buffer
2434   148F D7            push a
2435   1490 DA            push d
2436   1491 FA FF FF      lea d, [bp + -1] ; $i
2437   1494 2A            mov b, [d]
2438   1495 D8            push b
2439   1496 FD 77         inc b
2440   1498 FA FF FF      lea d, [bp + -1] ; $i
2441   149B FD 43         mov [d], b
2442   149D E5            pop b
2443   149E E7            pop d
2444   149F 5A            add d, b
2445   14A0 E4            pop a
2446   14A1 DA            push d
2447   14A2 FA 05 00      lea d, [bp + 5] ; $input
2448   14A5 2A            mov b, [d]
2449   14A6 D8            push b
2450   14A7 FD 77         inc b
2451   14A9 FA 05 00      lea d, [bp + 5] ; $input
2452   14AC FD 43         mov [d], b
2453   14AE E5            pop b
2454   14AF 74            mov d, b
2455   14B0 32            mov bl, [d]
2456   14B1 A7 00         mov bh, 0
2457   14B3 E7            pop d
2458   14B4 FD 3E         mov [d], bl
2459   14B6             ;; if (i == 3) { 
2460   14B6             _if34_cond:
2461   14B6 FA FF FF      lea d, [bp + -1] ; $i
2462   14B9 2A            mov b, [d]
2463   14BA             ; START RELATIONAL
2464   14BA D7            push a
2465   14BB 11            mov a, b
2466   14BC 26 03 00      mov b, $3
2467   14BF B0            cmp a, b
2468   14C0 FD 71         seq ; ==
2469   14C2 E4            pop a
2470   14C3             ; END RELATIONAL
2471   14C3 C0 00 00      cmp b, 0
2472   14C6 C6 3C 16      je _if34_exit
2473   14C9             _if34_true:
2474   14C9             ;; output_buffer[0] = (input_buffer[0] & 0xFC) >> 2; 
2475   14C9 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2476   14CC D7            push a
2477   14CD DA            push d
2478   14CE 26 00 00      mov b, $0
2479   14D1 E7            pop d
2480   14D2 5A            add d, b
2481   14D3 E4            pop a
2482   14D4 DA            push d
2483   14D5 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2484   14D8 D7            push a
2485   14D9 DA            push d
2486   14DA 26 00 00      mov b, $0
2487   14DD E7            pop d
2488   14DE 5A            add d, b
2489   14DF E4            pop a
2490   14E0 32            mov bl, [d]
2491   14E1 A7 00         mov bh, 0
2492   14E3 D7            push a
2493   14E4 11            mov a, b
2494   14E5 26 FC 00      mov b, $fc
2495   14E8 86            and a, b ; &
2496   14E9 27            mov b, a
2497   14EA E4            pop a
2498   14EB             ; START SHIFT
2499   14EB D7            push a
2500   14EC 11            mov a, b
2501   14ED 26 02 00      mov b, $2
2502   14F0 FD 39         mov c, b
2503   14F2 A5            ashr a, cl
2504   14F3 27            mov b, a
2505   14F4 E4            pop a
2506   14F5             ; END SHIFT
2507   14F5 E7            pop d
2508   14F6 FD 3E         mov [d], bl
2509   14F8             ;; output_buffer[1] = ((input_buffer[0] & 0x03) << 4) + ((input_buffer[1] & 0xF0) >> 4); 
2510   14F8 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2511   14FB D7            push a
2512   14FC DA            push d
2513   14FD 26 01 00      mov b, $1
2514   1500 E7            pop d
2515   1501 5A            add d, b
2516   1502 E4            pop a
2517   1503 DA            push d
2518   1504 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2519   1507 D7            push a
2520   1508 DA            push d
2521   1509 26 00 00      mov b, $0
2522   150C E7            pop d
2523   150D 5A            add d, b
2524   150E E4            pop a
2525   150F 32            mov bl, [d]
2526   1510 A7 00         mov bh, 0
2527   1512 D7            push a
2528   1513 11            mov a, b
2529   1514 26 03 00      mov b, $3
2530   1517 86            and a, b ; &
2531   1518 27            mov b, a
2532   1519 E4            pop a
2533   151A             ; START SHIFT
2534   151A D7            push a
2535   151B 11            mov a, b
2536   151C 26 04 00      mov b, $4
2537   151F FD 39         mov c, b
2538   1521 9D            shl a, cl
2539   1522 27            mov b, a
2540   1523 E4            pop a
2541   1524             ; END SHIFT
2542   1524             ; START TERMS
2543   1524 D7            push a
2544   1525 11            mov a, b
2545   1526 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2546   1529 D7            push a
2547   152A DA            push d
2548   152B 26 01 00      mov b, $1
2549   152E E7            pop d
2550   152F 5A            add d, b
2551   1530 E4            pop a
2552   1531 32            mov bl, [d]
2553   1532 A7 00         mov bh, 0
2554   1534 D7            push a
2555   1535 11            mov a, b
2556   1536 26 F0 00      mov b, $f0
2557   1539 86            and a, b ; &
2558   153A 27            mov b, a
2559   153B E4            pop a
2560   153C             ; START SHIFT
2561   153C D7            push a
2562   153D 11            mov a, b
2563   153E 26 04 00      mov b, $4
2564   1541 FD 39         mov c, b
2565   1543 A5            ashr a, cl
2566   1544 27            mov b, a
2567   1545 E4            pop a
2568   1546             ; END SHIFT
2569   1546 54            add a, b
2570   1547 27            mov b, a
2571   1548 E4            pop a
2572   1549             ; END TERMS
2573   1549 E7            pop d
2574   154A FD 3E         mov [d], bl
2575   154C             ;; output_buffer[2] = ((input_buffer[1] & 0x0F) << 2) + ((input_buffer[2] & 0xC0) >> 6); 
2576   154C FA F2 FF      lea d, [bp + -14] ; $output_buffer
2577   154F D7            push a
2578   1550 DA            push d
2579   1551 26 02 00      mov b, $2
2580   1554 E7            pop d
2581   1555 5A            add d, b
2582   1556 E4            pop a
2583   1557 DA            push d
2584   1558 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2585   155B D7            push a
2586   155C DA            push d
2587   155D 26 01 00      mov b, $1
2588   1560 E7            pop d
2589   1561 5A            add d, b
2590   1562 E4            pop a
2591   1563 32            mov bl, [d]
2592   1564 A7 00         mov bh, 0
2593   1566 D7            push a
2594   1567 11            mov a, b
2595   1568 26 0F 00      mov b, $f
2596   156B 86            and a, b ; &
2597   156C 27            mov b, a
2598   156D E4            pop a
2599   156E             ; START SHIFT
2600   156E D7            push a
2601   156F 11            mov a, b
2602   1570 26 02 00      mov b, $2
2603   1573 FD 39         mov c, b
2604   1575 9D            shl a, cl
2605   1576 27            mov b, a
2606   1577 E4            pop a
2607   1578             ; END SHIFT
2608   1578             ; START TERMS
2609   1578 D7            push a
2610   1579 11            mov a, b
2611   157A FA F6 FF      lea d, [bp + -10] ; $input_buffer
2612   157D D7            push a
2613   157E DA            push d
2614   157F 26 02 00      mov b, $2
2615   1582 E7            pop d
2616   1583 5A            add d, b
2617   1584 E4            pop a
2618   1585 32            mov bl, [d]
2619   1586 A7 00         mov bh, 0
2620   1588 D7            push a
2621   1589 11            mov a, b
2622   158A 26 C0 00      mov b, $c0
2623   158D 86            and a, b ; &
2624   158E 27            mov b, a
2625   158F E4            pop a
2626   1590             ; START SHIFT
2627   1590 D7            push a
2628   1591 11            mov a, b
2629   1592 26 06 00      mov b, $6
2630   1595 FD 39         mov c, b
2631   1597 A5            ashr a, cl
2632   1598 27            mov b, a
2633   1599 E4            pop a
2634   159A             ; END SHIFT
2635   159A 54            add a, b
2636   159B 27            mov b, a
2637   159C E4            pop a
2638   159D             ; END TERMS
2639   159D E7            pop d
2640   159E FD 3E         mov [d], bl
2641   15A0             ;; output_buffer[3] = input_buffer[2] & 0x3F; 
2642   15A0 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2643   15A3 D7            push a
2644   15A4 DA            push d
2645   15A5 26 03 00      mov b, $3
2646   15A8 E7            pop d
2647   15A9 5A            add d, b
2648   15AA E4            pop a
2649   15AB DA            push d
2650   15AC FA F6 FF      lea d, [bp + -10] ; $input_buffer
2651   15AF D7            push a
2652   15B0 DA            push d
2653   15B1 26 02 00      mov b, $2
2654   15B4 E7            pop d
2655   15B5 5A            add d, b
2656   15B6 E4            pop a
2657   15B7 32            mov bl, [d]
2658   15B8 A7 00         mov bh, 0
2659   15BA D7            push a
2660   15BB 11            mov a, b
2661   15BC 26 3F 00      mov b, $3f
2662   15BF 86            and a, b ; &
2663   15C0 27            mov b, a
2664   15C1 E4            pop a
2665   15C2 E7            pop d
2666   15C3 FD 3E         mov [d], bl
2667   15C5             ;; for (i = 0; i < 4; i++) { 
2668   15C5             _for35_init:
2669   15C5 FA FF FF      lea d, [bp + -1] ; $i
2670   15C8 DA            push d
2671   15C9 26 00 00      mov b, $0
2672   15CC E7            pop d
2673   15CD FD 43         mov [d], b
2674   15CF             _for35_cond:
2675   15CF FA FF FF      lea d, [bp + -1] ; $i
2676   15D2 2A            mov b, [d]
2677   15D3             ; START RELATIONAL
2678   15D3 D7            push a
2679   15D4 11            mov a, b
2680   15D5 26 04 00      mov b, $4
2681   15D8 B0            cmp a, b
2682   15D9 FD 73         slt ; < 
2683   15DB E4            pop a
2684   15DC             ; END RELATIONAL
2685   15DC C0 00 00      cmp b, 0
2686   15DF C6 2F 16      je _for35_exit
2687   15E2             _for35_block:
2688   15E2             ;; output[j++] = base64_table[output_buffer[i]]; 
2689   15E2 FA 07 00      lea d, [bp + 7] ; $output
2690   15E5 FD 2A         mov d, [d]
2691   15E7 D7            push a
2692   15E8 DA            push d
2693   15E9 FA FD FF      lea d, [bp + -3] ; $j
2694   15EC 2A            mov b, [d]
2695   15ED D8            push b
2696   15EE FD 77         inc b
2697   15F0 FA FD FF      lea d, [bp + -3] ; $j
2698   15F3 FD 43         mov [d], b
2699   15F5 E5            pop b
2700   15F6 E7            pop d
2701   15F7 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2702   15FB E4            pop a
2703   15FC DA            push d
2704   15FD 3B 72 18      mov d, _base64_table ; $base64_table
2705   1600 FD 2A         mov d, [d]
2706   1602 D7            push a
2707   1603 DA            push d
2708   1604 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2709   1607 D7            push a
2710   1608 DA            push d
2711   1609 FA FF FF      lea d, [bp + -1] ; $i
2712   160C 2A            mov b, [d]
2713   160D E7            pop d
2714   160E 5A            add d, b
2715   160F E4            pop a
2716   1610 32            mov bl, [d]
2717   1611 A7 00         mov bh, 0
2718   1613 E7            pop d
2719   1614 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2720   1618 E4            pop a
2721   1619 32            mov bl, [d]
2722   161A A7 00         mov bh, 0
2723   161C E7            pop d
2724   161D FD 3E         mov [d], bl
2725   161F             _for35_update:
2726   161F FA FF FF      lea d, [bp + -1] ; $i
2727   1622 2A            mov b, [d]
2728   1623 D8            push b
2729   1624 FD 77         inc b
2730   1626 FA FF FF      lea d, [bp + -1] ; $i
2731   1629 FD 43         mov [d], b
2732   162B E5            pop b
2733   162C 0A CF 15      jmp _for35_cond
2734   162F             _for35_exit:
2735   162F             ;; i = 0; 
2736   162F FA FF FF      lea d, [bp + -1] ; $i
2737   1632 DA            push d
2738   1633 26 00 00      mov b, $0
2739   1636 E7            pop d
2740   1637 FD 43         mov [d], b
2741   1639 0A 3C 16      jmp _if34_exit
2742   163C             _if34_exit:
2743   163C 0A 79 14      jmp _while33_cond
2744   163F             _while33_exit:
2745   163F             ;; if (i) { 
2746   163F             _if36_cond:
2747   163F FA FF FF      lea d, [bp + -1] ; $i
2748   1642 2A            mov b, [d]
2749   1643 C0 00 00      cmp b, 0
2750   1646 C6 17 18      je _if36_exit
2751   1649             _if36_true:
2752   1649             ;; for (k = i; k < 3; k++) { 
2753   1649             _for37_init:
2754   1649 FA FB FF      lea d, [bp + -5] ; $k
2755   164C DA            push d
2756   164D FA FF FF      lea d, [bp + -1] ; $i
2757   1650 2A            mov b, [d]
2758   1651 E7            pop d
2759   1652 FD 43         mov [d], b
2760   1654             _for37_cond:
2761   1654 FA FB FF      lea d, [bp + -5] ; $k
2762   1657 2A            mov b, [d]
2763   1658             ; START RELATIONAL
2764   1658 D7            push a
2765   1659 11            mov a, b
2766   165A 26 03 00      mov b, $3
2767   165D B0            cmp a, b
2768   165E FD 73         slt ; < 
2769   1660 E4            pop a
2770   1661             ; END RELATIONAL
2771   1661 C0 00 00      cmp b, 0
2772   1664 C6 8A 16      je _for37_exit
2773   1667             _for37_block:
2774   1667             ;; input_buffer[k] = '\0'; 
2775   1667 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2776   166A D7            push a
2777   166B DA            push d
2778   166C FA FB FF      lea d, [bp + -5] ; $k
2779   166F 2A            mov b, [d]
2780   1670 E7            pop d
2781   1671 5A            add d, b
2782   1672 E4            pop a
2783   1673 DA            push d
2784   1674 26 00 00      mov b, $0
2785   1677 E7            pop d
2786   1678 FD 3E         mov [d], bl
2787   167A             _for37_update:
2788   167A FA FB FF      lea d, [bp + -5] ; $k
2789   167D 2A            mov b, [d]
2790   167E D8            push b
2791   167F FD 77         inc b
2792   1681 FA FB FF      lea d, [bp + -5] ; $k
2793   1684 FD 43         mov [d], b
2794   1686 E5            pop b
2795   1687 0A 54 16      jmp _for37_cond
2796   168A             _for37_exit:
2797   168A             ;; output_buffer[0] = (input_buffer[0] & 0xFC) >> 2; 
2798   168A FA F2 FF      lea d, [bp + -14] ; $output_buffer
2799   168D D7            push a
2800   168E DA            push d
2801   168F 26 00 00      mov b, $0
2802   1692 E7            pop d
2803   1693 5A            add d, b
2804   1694 E4            pop a
2805   1695 DA            push d
2806   1696 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2807   1699 D7            push a
2808   169A DA            push d
2809   169B 26 00 00      mov b, $0
2810   169E E7            pop d
2811   169F 5A            add d, b
2812   16A0 E4            pop a
2813   16A1 32            mov bl, [d]
2814   16A2 A7 00         mov bh, 0
2815   16A4 D7            push a
2816   16A5 11            mov a, b
2817   16A6 26 FC 00      mov b, $fc
2818   16A9 86            and a, b ; &
2819   16AA 27            mov b, a
2820   16AB E4            pop a
2821   16AC             ; START SHIFT
2822   16AC D7            push a
2823   16AD 11            mov a, b
2824   16AE 26 02 00      mov b, $2
2825   16B1 FD 39         mov c, b
2826   16B3 A5            ashr a, cl
2827   16B4 27            mov b, a
2828   16B5 E4            pop a
2829   16B6             ; END SHIFT
2830   16B6 E7            pop d
2831   16B7 FD 3E         mov [d], bl
2832   16B9             ;; output_buffer[1] = ((input_buffer[0] & 0x03) << 4) + ((input_buffer[1] & 0xF0) >> 4); 
2833   16B9 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2834   16BC D7            push a
2835   16BD DA            push d
2836   16BE 26 01 00      mov b, $1
2837   16C1 E7            pop d
2838   16C2 5A            add d, b
2839   16C3 E4            pop a
2840   16C4 DA            push d
2841   16C5 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2842   16C8 D7            push a
2843   16C9 DA            push d
2844   16CA 26 00 00      mov b, $0
2845   16CD E7            pop d
2846   16CE 5A            add d, b
2847   16CF E4            pop a
2848   16D0 32            mov bl, [d]
2849   16D1 A7 00         mov bh, 0
2850   16D3 D7            push a
2851   16D4 11            mov a, b
2852   16D5 26 03 00      mov b, $3
2853   16D8 86            and a, b ; &
2854   16D9 27            mov b, a
2855   16DA E4            pop a
2856   16DB             ; START SHIFT
2857   16DB D7            push a
2858   16DC 11            mov a, b
2859   16DD 26 04 00      mov b, $4
2860   16E0 FD 39         mov c, b
2861   16E2 9D            shl a, cl
2862   16E3 27            mov b, a
2863   16E4 E4            pop a
2864   16E5             ; END SHIFT
2865   16E5             ; START TERMS
2866   16E5 D7            push a
2867   16E6 11            mov a, b
2868   16E7 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2869   16EA D7            push a
2870   16EB DA            push d
2871   16EC 26 01 00      mov b, $1
2872   16EF E7            pop d
2873   16F0 5A            add d, b
2874   16F1 E4            pop a
2875   16F2 32            mov bl, [d]
2876   16F3 A7 00         mov bh, 0
2877   16F5 D7            push a
2878   16F6 11            mov a, b
2879   16F7 26 F0 00      mov b, $f0
2880   16FA 86            and a, b ; &
2881   16FB 27            mov b, a
2882   16FC E4            pop a
2883   16FD             ; START SHIFT
2884   16FD D7            push a
2885   16FE 11            mov a, b
2886   16FF 26 04 00      mov b, $4
2887   1702 FD 39         mov c, b
2888   1704 A5            ashr a, cl
2889   1705 27            mov b, a
2890   1706 E4            pop a
2891   1707             ; END SHIFT
2892   1707 54            add a, b
2893   1708 27            mov b, a
2894   1709 E4            pop a
2895   170A             ; END TERMS
2896   170A E7            pop d
2897   170B FD 3E         mov [d], bl
2898   170D             ;; output_buffer[2] = ((input_buffer[1] & 0x0F) << 2) + ((input_buffer[2] & 0xC0) >> 6); 
2899   170D FA F2 FF      lea d, [bp + -14] ; $output_buffer
2900   1710 D7            push a
2901   1711 DA            push d
2902   1712 26 02 00      mov b, $2
2903   1715 E7            pop d
2904   1716 5A            add d, b
2905   1717 E4            pop a
2906   1718 DA            push d
2907   1719 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2908   171C D7            push a
2909   171D DA            push d
2910   171E 26 01 00      mov b, $1
2911   1721 E7            pop d
2912   1722 5A            add d, b
2913   1723 E4            pop a
2914   1724 32            mov bl, [d]
2915   1725 A7 00         mov bh, 0
2916   1727 D7            push a
2917   1728 11            mov a, b
2918   1729 26 0F 00      mov b, $f
2919   172C 86            and a, b ; &
2920   172D 27            mov b, a
2921   172E E4            pop a
2922   172F             ; START SHIFT
2923   172F D7            push a
2924   1730 11            mov a, b
2925   1731 26 02 00      mov b, $2
2926   1734 FD 39         mov c, b
2927   1736 9D            shl a, cl
2928   1737 27            mov b, a
2929   1738 E4            pop a
2930   1739             ; END SHIFT
2931   1739             ; START TERMS
2932   1739 D7            push a
2933   173A 11            mov a, b
2934   173B FA F6 FF      lea d, [bp + -10] ; $input_buffer
2935   173E D7            push a
2936   173F DA            push d
2937   1740 26 02 00      mov b, $2
2938   1743 E7            pop d
2939   1744 5A            add d, b
2940   1745 E4            pop a
2941   1746 32            mov bl, [d]
2942   1747 A7 00         mov bh, 0
2943   1749 D7            push a
2944   174A 11            mov a, b
2945   174B 26 C0 00      mov b, $c0
2946   174E 86            and a, b ; &
2947   174F 27            mov b, a
2948   1750 E4            pop a
2949   1751             ; START SHIFT
2950   1751 D7            push a
2951   1752 11            mov a, b
2952   1753 26 06 00      mov b, $6
2953   1756 FD 39         mov c, b
2954   1758 A5            ashr a, cl
2955   1759 27            mov b, a
2956   175A E4            pop a
2957   175B             ; END SHIFT
2958   175B 54            add a, b
2959   175C 27            mov b, a
2960   175D E4            pop a
2961   175E             ; END TERMS
2962   175E E7            pop d
2963   175F FD 3E         mov [d], bl
2964   1761             ;; for (k = 0; k < i + 1; k++) { 
2965   1761             _for38_init:
2966   1761 FA FB FF      lea d, [bp + -5] ; $k
2967   1764 DA            push d
2968   1765 26 00 00      mov b, $0
2969   1768 E7            pop d
2970   1769 FD 43         mov [d], b
2971   176B             _for38_cond:
2972   176B FA FB FF      lea d, [bp + -5] ; $k
2973   176E 2A            mov b, [d]
2974   176F             ; START RELATIONAL
2975   176F D7            push a
2976   1770 11            mov a, b
2977   1771 FA FF FF      lea d, [bp + -1] ; $i
2978   1774 2A            mov b, [d]
2979   1775             ; START TERMS
2980   1775 D7            push a
2981   1776 11            mov a, b
2982   1777 26 01 00      mov b, $1
2983   177A 54            add a, b
2984   177B 27            mov b, a
2985   177C E4            pop a
2986   177D             ; END TERMS
2987   177D B0            cmp a, b
2988   177E FD 73         slt ; < 
2989   1780 E4            pop a
2990   1781             ; END RELATIONAL
2991   1781 C0 00 00      cmp b, 0
2992   1784 C6 D4 17      je _for38_exit
2993   1787             _for38_block:
2994   1787             ;; output[j++] = base64_table[output_buffer[k]]; 
2995   1787 FA 07 00      lea d, [bp + 7] ; $output
2996   178A FD 2A         mov d, [d]
2997   178C D7            push a
2998   178D DA            push d
2999   178E FA FD FF      lea d, [bp + -3] ; $j
3000   1791 2A            mov b, [d]
3001   1792 D8            push b
3002   1793 FD 77         inc b
3003   1795 FA FD FF      lea d, [bp + -3] ; $j
3004   1798 FD 43         mov [d], b
3005   179A E5            pop b
3006   179B E7            pop d
3007   179C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3008   17A0 E4            pop a
3009   17A1 DA            push d
3010   17A2 3B 72 18      mov d, _base64_table ; $base64_table
3011   17A5 FD 2A         mov d, [d]
3012   17A7 D7            push a
3013   17A8 DA            push d
3014   17A9 FA F2 FF      lea d, [bp + -14] ; $output_buffer
3015   17AC D7            push a
3016   17AD DA            push d
3017   17AE FA FB FF      lea d, [bp + -5] ; $k
3018   17B1 2A            mov b, [d]
3019   17B2 E7            pop d
3020   17B3 5A            add d, b
3021   17B4 E4            pop a
3022   17B5 32            mov bl, [d]
3023   17B6 A7 00         mov bh, 0
3024   17B8 E7            pop d
3025   17B9 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3026   17BD E4            pop a
3027   17BE 32            mov bl, [d]
3028   17BF A7 00         mov bh, 0
3029   17C1 E7            pop d
3030   17C2 FD 3E         mov [d], bl
3031   17C4             _for38_update:
3032   17C4 FA FB FF      lea d, [bp + -5] ; $k
3033   17C7 2A            mov b, [d]
3034   17C8 D8            push b
3035   17C9 FD 77         inc b
3036   17CB FA FB FF      lea d, [bp + -5] ; $k
3037   17CE FD 43         mov [d], b
3038   17D0 E5            pop b
3039   17D1 0A 6B 17      jmp _for38_cond
3040   17D4             _for38_exit:
3041   17D4             ;; while (i++ < 3) { 
3042   17D4             _while39_cond:
3043   17D4 FA FF FF      lea d, [bp + -1] ; $i
3044   17D7 2A            mov b, [d]
3045   17D8 D8            push b
3046   17D9 FD 77         inc b
3047   17DB FA FF FF      lea d, [bp + -1] ; $i
3048   17DE FD 43         mov [d], b
3049   17E0 E5            pop b
3050   17E1             ; START RELATIONAL
3051   17E1 D7            push a
3052   17E2 11            mov a, b
3053   17E3 26 03 00      mov b, $3
3054   17E6 B0            cmp a, b
3055   17E7 FD 73         slt ; < 
3056   17E9 E4            pop a
3057   17EA             ; END RELATIONAL
3058   17EA C0 00 00      cmp b, 0
3059   17ED C6 14 18      je _while39_exit
3060   17F0             _while39_block:
3061   17F0             ;; output[j++] = '='; 
3062   17F0 FA 07 00      lea d, [bp + 7] ; $output
3063   17F3 FD 2A         mov d, [d]
3064   17F5 D7            push a
3065   17F6 DA            push d
3066   17F7 FA FD FF      lea d, [bp + -3] ; $j
3067   17FA 2A            mov b, [d]
3068   17FB D8            push b
3069   17FC FD 77         inc b
3070   17FE FA FD FF      lea d, [bp + -3] ; $j
3071   1801 FD 43         mov [d], b
3072   1803 E5            pop b
3073   1804 E7            pop d
3074   1805 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3075   1809 E4            pop a
3076   180A DA            push d
3077   180B 26 3D 00      mov b, $3d
3078   180E E7            pop d
3079   180F FD 3E         mov [d], bl
3080   1811 0A D4 17      jmp _while39_cond
3081   1814             _while39_exit:
3082   1814 0A 17 18      jmp _if36_exit
3083   1817             _if36_exit:
3084   1817             ;; output[j] = '\0'; 
3085   1817 FA 07 00      lea d, [bp + 7] ; $output
3086   181A FD 2A         mov d, [d]
3087   181C D7            push a
3088   181D DA            push d
3089   181E FA FD FF      lea d, [bp + -3] ; $j
3090   1821 2A            mov b, [d]
3091   1822 E7            pop d
3092   1823 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3093   1827 E4            pop a
3094   1828 DA            push d
3095   1829 26 00 00      mov b, $0
3096   182C E7            pop d
3097   182D FD 3E         mov [d], bl
3098   182F F9            leave
3099   1830 09            ret
3100   1831             ; --- END TEXT BLOCK
3101   1831             
3102   1831             ; --- BEGIN DATA BLOCK
3103   1831 41 42 43 44 _base64_table_data: .db "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0
3103   1835 45 46 47 48 
3103   1839 49 4A 4B 4C 
3103   183D 4D 4E 4F 50 
3103   1841 51 52 53 54 
3103   1845 55 56 57 58 
3103   1849 59 5A 61 62 
3103   184D 63 64 65 66 
3103   1851 67 68 69 6A 
3103   1855 6B 6C 6D 6E 
3103   1859 6F 70 71 72 
3103   185D 73 74 75 76 
3103   1861 77 78 79 7A 
3103   1865 30 31 32 33 
3103   1869 34 35 36 37 
3103   186D 38 39 2B 2F 
3103   1871 00 
3104   1872 31 18       _base64_table: .dw _base64_table_data
3105   1874 45 6E 74 65 __s0: .db "Enter a string to encode in base64: ", 0
3105   1878 72 20 61 20 
3105   187C 73 74 72 69 
3105   1880 6E 67 20 74 
3105   1884 6F 20 65 6E 
3105   1888 63 6F 64 65 
3105   188C 20 69 6E 20 
3105   1890 62 61 73 65 
3105   1894 36 34 3A 20 
3105   1898 00 
3106   1899 42 61 73 65 __s1: .db "Base64 encoded string: ", 0
3106   189D 36 34 20 65 
3106   18A1 6E 63 6F 64 
3106   18A5 65 64 20 73 
3106   18A9 74 72 69 6E 
3106   18AD 67 3A 20 00 
3107   18B1 0A 00       __s2: .db "\n", 0
3108   18B3 55 6E 65 78 __s3: .db "Unexpected format in printf.", 0
3108   18B7 70 65 63 74 
3108   18BB 65 64 20 66 
3108   18BF 6F 72 6D 61 
3108   18C3 74 20 69 6E 
3108   18C7 20 70 72 69 
3108   18CB 6E 74 66 2E 
3108   18CF 00 
3109   18D0 45 72 72 6F __s4: .db "Error: Unknown argument type.\n", 0
3109   18D4 72 3A 20 55 
3109   18D8 6E 6B 6E 6F 
3109   18DC 77 6E 20 61 
3109   18E0 72 67 75 6D 
3109   18E4 65 6E 74 20 
3109   18E8 74 79 70 65 
3109   18EC 2E 0A 00 
3110   18EF 1B 5B 32 4A __s5: .db "\033[2J\033[H", 0
3110   18F3 1B 5B 48 00 
3111   18F7             
3112   18F7 F9 18       _heap_top: .dw _heap
3113   18F9 00          _heap: .db 0
3114   18FA             ; --- END DATA BLOCK
3115   18FA             
3116   18FA             .end
tasm: Number of errors = 0
