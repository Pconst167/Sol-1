0001   0000             ; --- FILENAME: programs/base64
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $input 
0011   0408             ; $output 
0012   0408 52 00 03      sub sp, 768
0013   040B             ;; printf("Enter a string to encode in base64: "); 
0014   040B 26 72 18      mov b, __s0 ; "Enter a string to encode in base64: "
0015   040E FD AB         swp b
0016   0410 D8            push b
0017   0411 07 1E 06      call printf
0018   0414 51 02 00      add sp, 2
0019   0417             ;; gets(input); 
0020   0417 FA 01 FF      lea d, [bp + -255] ; $input
0021   041A 2D            mov b, d
0022   041B FD AB         swp b
0023   041D D8            push b
0024   041E 07 13 0B      call gets
0025   0421 51 02 00      add sp, 2
0026   0424             ;; base64_encode(input, output); 
0027   0424 FA 01 FD      lea d, [bp + -767] ; $output
0028   0427 2D            mov b, d
0029   0428 FD AB         swp b
0030   042A D8            push b
0031   042B FA 01 FF      lea d, [bp + -255] ; $input
0032   042E 2D            mov b, d
0033   042F FD AB         swp b
0034   0431 D8            push b
0035   0432 07 51 14      call base64_encode
0036   0435 51 04 00      add sp, 4
0037   0438             ;; printf("Base64 encoded string: "); 
0038   0438 26 97 18      mov b, __s1 ; "Base64 encoded string: "
0039   043B FD AB         swp b
0040   043D D8            push b
0041   043E 07 1E 06      call printf
0042   0441 51 02 00      add sp, 2
0043   0444             ;; printf(output); 
0044   0444 FA 01 FD      lea d, [bp + -767] ; $output
0045   0447 2D            mov b, d
0046   0448 FD AB         swp b
0047   044A D8            push b
0048   044B 07 1E 06      call printf
0049   044E 51 02 00      add sp, 2
0050   0451             ;; printf("\n"); 
0051   0451 26 AF 18      mov b, __s2 ; "\n"
0052   0454 FD AB         swp b
0053   0456 D8            push b
0054   0457 07 1E 06      call printf
0055   045A 51 02 00      add sp, 2
0056   045D             ;; return 0; 
0057   045D 26 00 00      mov b, $0
0058   0460 F9            leave
0059   0461 05 0B         syscall sys_terminate_proc
0060   0463             
0061   0463             strcpy:
0062   0463 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0063   0466             ; $psrc 
0064   0466             ; $pdest 
0065   0466 52 04 00      sub sp, 4
0066   0469             ;; psrc = src; 
0067   0469 FA FF FF      lea d, [bp + -1] ; $psrc
0068   046C DA            push d
0069   046D FA 07 00      lea d, [bp + 7] ; $src
0070   0470 2A            mov b, [d]
0071   0471 E7            pop d
0072   0472 FD 43         mov [d], b
0073   0474             ;; pdest = dest; 
0074   0474 FA FD FF      lea d, [bp + -3] ; $pdest
0075   0477 DA            push d
0076   0478 FA 05 00      lea d, [bp + 5] ; $dest
0077   047B 2A            mov b, [d]
0078   047C E7            pop d
0079   047D FD 43         mov [d], b
0080   047F             ;; while(*psrc) *pdest++ = *psrc++; 
0081   047F             _while1_cond:
0082   047F FA FF FF      lea d, [bp + -1] ; $psrc
0083   0482 2A            mov b, [d]
0084   0483 74            mov d, b
0085   0484 32            mov bl, [d]
0086   0485 A7 00         mov bh, 0
0087   0487 C0 00 00      cmp b, 0
0088   048A C6 B2 04      je _while1_exit
0089   048D             _while1_block:
0090   048D             ;; *pdest++ = *psrc++; 
0091   048D FA FD FF      lea d, [bp + -3] ; $pdest
0092   0490 2A            mov b, [d]
0093   0491 D8            push b
0094   0492 FD 77         inc b
0095   0494 FA FD FF      lea d, [bp + -3] ; $pdest
0096   0497 FD 43         mov [d], b
0097   0499 E5            pop b
0098   049A D8            push b
0099   049B FA FF FF      lea d, [bp + -1] ; $psrc
0100   049E 2A            mov b, [d]
0101   049F D8            push b
0102   04A0 FD 77         inc b
0103   04A2 FA FF FF      lea d, [bp + -1] ; $psrc
0104   04A5 FD 43         mov [d], b
0105   04A7 E5            pop b
0106   04A8 74            mov d, b
0107   04A9 32            mov bl, [d]
0108   04AA A7 00         mov bh, 0
0109   04AC E7            pop d
0110   04AD FD 3E         mov [d], bl
0111   04AF 0A 7F 04      jmp _while1_cond
0112   04B2             _while1_exit:
0113   04B2             ;; *pdest = '\0'; 
0114   04B2 FA FD FF      lea d, [bp + -3] ; $pdest
0115   04B5 2A            mov b, [d]
0116   04B6 D8            push b
0117   04B7 26 00 00      mov b, $0
0118   04BA E7            pop d
0119   04BB FD 3E         mov [d], bl
0120   04BD F9            leave
0121   04BE 09            ret
0122   04BF             
0123   04BF             strcmp:
0124   04BF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0125   04C2             ;; while (*s1 && (*s1 == *s2)) { 
0126   04C2             _while2_cond:
0127   04C2 FA 05 00      lea d, [bp + 5] ; $s1
0128   04C5 2A            mov b, [d]
0129   04C6 74            mov d, b
0130   04C7 32            mov bl, [d]
0131   04C8 A7 00         mov bh, 0
0132   04CA D7            push a
0133   04CB 11            mov a, b
0134   04CC FA 05 00      lea d, [bp + 5] ; $s1
0135   04CF 2A            mov b, [d]
0136   04D0 74            mov d, b
0137   04D1 32            mov bl, [d]
0138   04D2 A7 00         mov bh, 0
0139   04D4             ; START RELATIONAL
0140   04D4 D7            push a
0141   04D5 11            mov a, b
0142   04D6 FA 07 00      lea d, [bp + 7] ; $s2
0143   04D9 2A            mov b, [d]
0144   04DA 74            mov d, b
0145   04DB 32            mov bl, [d]
0146   04DC A7 00         mov bh, 0
0147   04DE B0            cmp a, b
0148   04DF FD 71         seq ; ==
0149   04E1 E4            pop a
0150   04E2             ; END RELATIONAL
0151   04E2 FD A7         sand a, b ; &&
0152   04E4 E4            pop a
0153   04E5 C0 00 00      cmp b, 0
0154   04E8 C6 08 05      je _while2_exit
0155   04EB             _while2_block:
0156   04EB             ;; s1++; 
0157   04EB FA 05 00      lea d, [bp + 5] ; $s1
0158   04EE 2A            mov b, [d]
0159   04EF D8            push b
0160   04F0 FD 77         inc b
0161   04F2 FA 05 00      lea d, [bp + 5] ; $s1
0162   04F5 FD 43         mov [d], b
0163   04F7 E5            pop b
0164   04F8             ;; s2++; 
0165   04F8 FA 07 00      lea d, [bp + 7] ; $s2
0166   04FB 2A            mov b, [d]
0167   04FC D8            push b
0168   04FD FD 77         inc b
0169   04FF FA 07 00      lea d, [bp + 7] ; $s2
0170   0502 FD 43         mov [d], b
0171   0504 E5            pop b
0172   0505 0A C2 04      jmp _while2_cond
0173   0508             _while2_exit:
0174   0508             ;; return *s1 - *s2; 
0175   0508 FA 05 00      lea d, [bp + 5] ; $s1
0176   050B 2A            mov b, [d]
0177   050C 74            mov d, b
0178   050D 32            mov bl, [d]
0179   050E A7 00         mov bh, 0
0180   0510             ; START TERMS
0181   0510 D7            push a
0182   0511 11            mov a, b
0183   0512 FA 07 00      lea d, [bp + 7] ; $s2
0184   0515 2A            mov b, [d]
0185   0516 74            mov d, b
0186   0517 32            mov bl, [d]
0187   0518 A7 00         mov bh, 0
0188   051A 60            sub a, b
0189   051B 27            mov b, a
0190   051C E4            pop a
0191   051D             ; END TERMS
0192   051D F9            leave
0193   051E 09            ret
0194   051F             
0195   051F             strcat:
0196   051F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0197   0522             ; $dest_len 
0198   0522             ; $i 
0199   0522 52 04 00      sub sp, 4
0200   0525             ;; dest_len = strlen(dest); 
0201   0525 FA FF FF      lea d, [bp + -1] ; $dest_len
0202   0528 DA            push d
0203   0529 FA 05 00      lea d, [bp + 5] ; $dest
0204   052C 2A            mov b, [d]
0205   052D FD AB         swp b
0206   052F D8            push b
0207   0530 07 D5 05      call strlen
0208   0533 51 02 00      add sp, 2
0209   0536 E7            pop d
0210   0537 FD 43         mov [d], b
0211   0539             ;; for (i = 0; src[i] != 0; i=i+1) { 
0212   0539             _for3_init:
0213   0539 FA FD FF      lea d, [bp + -3] ; $i
0214   053C DA            push d
0215   053D 26 00 00      mov b, $0
0216   0540 E7            pop d
0217   0541 FD 43         mov [d], b
0218   0543             _for3_cond:
0219   0543 FA 07 00      lea d, [bp + 7] ; $src
0220   0546 FD 2A         mov d, [d]
0221   0548 D7            push a
0222   0549 DA            push d
0223   054A FA FD FF      lea d, [bp + -3] ; $i
0224   054D 2A            mov b, [d]
0225   054E E7            pop d
0226   054F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0227   0553 E4            pop a
0228   0554 32            mov bl, [d]
0229   0555 A7 00         mov bh, 0
0230   0557             ; START RELATIONAL
0231   0557 D7            push a
0232   0558 11            mov a, b
0233   0559 26 00 00      mov b, $0
0234   055C B0            cmp a, b
0235   055D FD 72         sneq ; !=
0236   055F E4            pop a
0237   0560             ; END RELATIONAL
0238   0560 C0 00 00      cmp b, 0
0239   0563 C6 AE 05      je _for3_exit
0240   0566             _for3_block:
0241   0566             ;; dest[dest_len + i] = src[i]; 
0242   0566 FA 05 00      lea d, [bp + 5] ; $dest
0243   0569 FD 2A         mov d, [d]
0244   056B D7            push a
0245   056C DA            push d
0246   056D FA FF FF      lea d, [bp + -1] ; $dest_len
0247   0570 2A            mov b, [d]
0248   0571             ; START TERMS
0249   0571 D7            push a
0250   0572 11            mov a, b
0251   0573 FA FD FF      lea d, [bp + -3] ; $i
0252   0576 2A            mov b, [d]
0253   0577 54            add a, b
0254   0578 27            mov b, a
0255   0579 E4            pop a
0256   057A             ; END TERMS
0257   057A E7            pop d
0258   057B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0259   057F E4            pop a
0260   0580 DA            push d
0261   0581 FA 07 00      lea d, [bp + 7] ; $src
0262   0584 FD 2A         mov d, [d]
0263   0586 D7            push a
0264   0587 DA            push d
0265   0588 FA FD FF      lea d, [bp + -3] ; $i
0266   058B 2A            mov b, [d]
0267   058C E7            pop d
0268   058D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0269   0591 E4            pop a
0270   0592 32            mov bl, [d]
0271   0593 A7 00         mov bh, 0
0272   0595 E7            pop d
0273   0596 FD 3E         mov [d], bl
0274   0598             _for3_update:
0275   0598 FA FD FF      lea d, [bp + -3] ; $i
0276   059B DA            push d
0277   059C FA FD FF      lea d, [bp + -3] ; $i
0278   059F 2A            mov b, [d]
0279   05A0             ; START TERMS
0280   05A0 D7            push a
0281   05A1 11            mov a, b
0282   05A2 26 01 00      mov b, $1
0283   05A5 54            add a, b
0284   05A6 27            mov b, a
0285   05A7 E4            pop a
0286   05A8             ; END TERMS
0287   05A8 E7            pop d
0288   05A9 FD 43         mov [d], b
0289   05AB 0A 43 05      jmp _for3_cond
0290   05AE             _for3_exit:
0291   05AE             ;; dest[dest_len + i] = 0; 
0292   05AE FA 05 00      lea d, [bp + 5] ; $dest
0293   05B1 FD 2A         mov d, [d]
0294   05B3 D7            push a
0295   05B4 DA            push d
0296   05B5 FA FF FF      lea d, [bp + -1] ; $dest_len
0297   05B8 2A            mov b, [d]
0298   05B9             ; START TERMS
0299   05B9 D7            push a
0300   05BA 11            mov a, b
0301   05BB FA FD FF      lea d, [bp + -3] ; $i
0302   05BE 2A            mov b, [d]
0303   05BF 54            add a, b
0304   05C0 27            mov b, a
0305   05C1 E4            pop a
0306   05C2             ; END TERMS
0307   05C2 E7            pop d
0308   05C3 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0309   05C7 E4            pop a
0310   05C8 DA            push d
0311   05C9 26 00 00      mov b, $0
0312   05CC E7            pop d
0313   05CD FD 3E         mov [d], bl
0314   05CF             ;; return dest; 
0315   05CF FA 05 00      lea d, [bp + 5] ; $dest
0316   05D2 2A            mov b, [d]
0317   05D3 F9            leave
0318   05D4 09            ret
0319   05D5             
0320   05D5             strlen:
0321   05D5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0322   05D8             ; $length 
0323   05D8 52 02 00      sub sp, 2
0324   05DB             ;; length = 0; 
0325   05DB FA FF FF      lea d, [bp + -1] ; $length
0326   05DE DA            push d
0327   05DF 26 00 00      mov b, $0
0328   05E2 E7            pop d
0329   05E3 FD 43         mov [d], b
0330   05E5             ;; while (str[length] != 0) { 
0331   05E5             _while4_cond:
0332   05E5 FA 05 00      lea d, [bp + 5] ; $str
0333   05E8 FD 2A         mov d, [d]
0334   05EA D7            push a
0335   05EB DA            push d
0336   05EC FA FF FF      lea d, [bp + -1] ; $length
0337   05EF 2A            mov b, [d]
0338   05F0 E7            pop d
0339   05F1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0340   05F5 E4            pop a
0341   05F6 32            mov bl, [d]
0342   05F7 A7 00         mov bh, 0
0343   05F9             ; START RELATIONAL
0344   05F9 D7            push a
0345   05FA 11            mov a, b
0346   05FB 26 00 00      mov b, $0
0347   05FE B0            cmp a, b
0348   05FF FD 72         sneq ; !=
0349   0601 E4            pop a
0350   0602             ; END RELATIONAL
0351   0602 C0 00 00      cmp b, 0
0352   0605 C6 18 06      je _while4_exit
0353   0608             _while4_block:
0354   0608             ;; length++; 
0355   0608 FA FF FF      lea d, [bp + -1] ; $length
0356   060B 2A            mov b, [d]
0357   060C D8            push b
0358   060D FD 77         inc b
0359   060F FA FF FF      lea d, [bp + -1] ; $length
0360   0612 FD 43         mov [d], b
0361   0614 E5            pop b
0362   0615 0A E5 05      jmp _while4_cond
0363   0618             _while4_exit:
0364   0618             ;; return length; 
0365   0618 FA FF FF      lea d, [bp + -1] ; $length
0366   061B 2A            mov b, [d]
0367   061C F9            leave
0368   061D 09            ret
0369   061E             
0370   061E             printf:
0371   061E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0372   0621             ; $p 
0373   0621             ; $fp 
0374   0621             ; $i 
0375   0621 52 06 00      sub sp, 6
0376   0624             ;; fp = format; 
0377   0624 FA FD FF      lea d, [bp + -3] ; $fp
0378   0627 DA            push d
0379   0628 FA 05 00      lea d, [bp + 5] ; $format
0380   062B 2A            mov b, [d]
0381   062C E7            pop d
0382   062D FD 43         mov [d], b
0383   062F             ;; p = &format + 2; 
0384   062F FA FF FF      lea d, [bp + -1] ; $p
0385   0632 DA            push d
0386   0633 FA 05 00      lea d, [bp + 5] ; $format
0387   0636 2D            mov b, d
0388   0637             ; START TERMS
0389   0637 D7            push a
0390   0638 11            mov a, b
0391   0639 26 02 00      mov b, $2
0392   063C 54            add a, b
0393   063D 27            mov b, a
0394   063E E4            pop a
0395   063F             ; END TERMS
0396   063F E7            pop d
0397   0640 FD 43         mov [d], b
0398   0642             ;; for(;;){ 
0399   0642             _for5_init:
0400   0642             _for5_cond:
0401   0642             _for5_block:
0402   0642             ;; if(!*fp) break; 
0403   0642             _if6_cond:
0404   0642 FA FD FF      lea d, [bp + -3] ; $fp
0405   0645 2A            mov b, [d]
0406   0646 74            mov d, b
0407   0647 32            mov bl, [d]
0408   0648 A7 00         mov bh, 0
0409   064A C0 00 00      cmp b, 0
0410   064D FD 71         seq ; !
0411   064F C0 00 00      cmp b, 0
0412   0652 C6 5B 06      je _if6_else
0413   0655             _if6_true:
0414   0655             ;; break; 
0415   0655 0A 7A 08      jmp _for5_exit ; for break
0416   0658 0A 77 08      jmp _if6_exit
0417   065B             _if6_else:
0418   065B             ;; if(*fp == '%'){ 
0419   065B             _if7_cond:
0420   065B FA FD FF      lea d, [bp + -3] ; $fp
0421   065E 2A            mov b, [d]
0422   065F 74            mov d, b
0423   0660 32            mov bl, [d]
0424   0661 A7 00         mov bh, 0
0425   0663             ; START RELATIONAL
0426   0663 D7            push a
0427   0664 11            mov a, b
0428   0665 26 25 00      mov b, $25
0429   0668 B0            cmp a, b
0430   0669 FD 71         seq ; ==
0431   066B E4            pop a
0432   066C             ; END RELATIONAL
0433   066C C0 00 00      cmp b, 0
0434   066F C6 5B 08      je _if7_else
0435   0672             _if7_true:
0436   0672             ;; fp++; 
0437   0672 FA FD FF      lea d, [bp + -3] ; $fp
0438   0675 2A            mov b, [d]
0439   0676 D8            push b
0440   0677 FD 77         inc b
0441   0679 FA FD FF      lea d, [bp + -3] ; $fp
0442   067C FD 43         mov [d], b
0443   067E E5            pop b
0444   067F             ;; switch(*fp){ 
0445   067F             _switch8_expr:
0446   067F FA FD FF      lea d, [bp + -3] ; $fp
0447   0682 2A            mov b, [d]
0448   0683 74            mov d, b
0449   0684 32            mov bl, [d]
0450   0685 A7 00         mov bh, 0
0451   0687             _switch8_comparisons:
0452   0687 C1 6C         cmp bl, $6c
0453   0689 C6 B5 06      je _switch8_case0
0454   068C C1 4C         cmp bl, $4c
0455   068E C6 B5 06      je _switch8_case1
0456   0691 C1 64         cmp bl, $64
0457   0693 C6 86 07      je _switch8_case2
0458   0696 C1 69         cmp bl, $69
0459   0698 C6 86 07      je _switch8_case3
0460   069B C1 75         cmp bl, $75
0461   069D C6 AB 07      je _switch8_case4
0462   06A0 C1 78         cmp bl, $78
0463   06A2 C6 D0 07      je _switch8_case5
0464   06A5 C1 63         cmp bl, $63
0465   06A7 C6 F5 07      je _switch8_case6
0466   06AA C1 73         cmp bl, $73
0467   06AC C6 1A 08      je _switch8_case7
0468   06AF 0A 3F 08      jmp _switch8_default
0469   06B2 0A 4B 08      jmp _switch8_exit
0470   06B5             _switch8_case0:
0471   06B5             _switch8_case1:
0472   06B5             ;; fp++; 
0473   06B5 FA FD FF      lea d, [bp + -3] ; $fp
0474   06B8 2A            mov b, [d]
0475   06B9 D8            push b
0476   06BA FD 77         inc b
0477   06BC FA FD FF      lea d, [bp + -3] ; $fp
0478   06BF FD 43         mov [d], b
0479   06C1 E5            pop b
0480   06C2             ;; if(*fp == 'd' || *fp == 'i') 
0481   06C2             _if9_cond:
0482   06C2 FA FD FF      lea d, [bp + -3] ; $fp
0483   06C5 2A            mov b, [d]
0484   06C6 74            mov d, b
0485   06C7 32            mov bl, [d]
0486   06C8 A7 00         mov bh, 0
0487   06CA             ; START RELATIONAL
0488   06CA D7            push a
0489   06CB 11            mov a, b
0490   06CC 26 64 00      mov b, $64
0491   06CF B0            cmp a, b
0492   06D0 FD 71         seq ; ==
0493   06D2 E4            pop a
0494   06D3             ; END RELATIONAL
0495   06D3 D7            push a
0496   06D4 11            mov a, b
0497   06D5 FA FD FF      lea d, [bp + -3] ; $fp
0498   06D8 2A            mov b, [d]
0499   06D9 74            mov d, b
0500   06DA 32            mov bl, [d]
0501   06DB A7 00         mov bh, 0
0502   06DD             ; START RELATIONAL
0503   06DD D7            push a
0504   06DE 11            mov a, b
0505   06DF 26 69 00      mov b, $69
0506   06E2 B0            cmp a, b
0507   06E3 FD 71         seq ; ==
0508   06E5 E4            pop a
0509   06E6             ; END RELATIONAL
0510   06E6 FD A8         sor a, b ; ||
0511   06E8 E4            pop a
0512   06E9 C0 00 00      cmp b, 0
0513   06EC C6 03 07      je _if9_else
0514   06EF             _if9_true:
0515   06EF             ;; print_signed_long(*(long *)p); 
0516   06EF FD 79         mov g, b
0517   06F1 28            mov b, c
0518   06F2 FD AB         swp b
0519   06F4 D8            push b
0520   06F5 FD 27         mov b, g
0521   06F7 FD AB         swp b
0522   06F9 D8            push b
0523   06FA 07 1E 0C      call print_signed_long
0524   06FD 51 04 00      add sp, 4
0525   0700 0A 70 07      jmp _if9_exit
0526   0703             _if9_else:
0527   0703             ;; if(*fp == 'u') 
0528   0703             _if10_cond:
0529   0703 FA FD FF      lea d, [bp + -3] ; $fp
0530   0706 2A            mov b, [d]
0531   0707 74            mov d, b
0532   0708 32            mov bl, [d]
0533   0709 A7 00         mov bh, 0
0534   070B             ; START RELATIONAL
0535   070B D7            push a
0536   070C 11            mov a, b
0537   070D 26 75 00      mov b, $75
0538   0710 B0            cmp a, b
0539   0711 FD 71         seq ; ==
0540   0713 E4            pop a
0541   0714             ; END RELATIONAL
0542   0714 C0 00 00      cmp b, 0
0543   0717 C6 2E 07      je _if10_else
0544   071A             _if10_true:
0545   071A             ;; print_unsigned_long(*(unsigned long *)p); 
0546   071A FD 79         mov g, b
0547   071C 28            mov b, c
0548   071D FD AB         swp b
0549   071F D8            push b
0550   0720 FD 27         mov b, g
0551   0722 FD AB         swp b
0552   0724 D8            push b
0553   0725 07 53 0D      call print_unsigned_long
0554   0728 51 04 00      add sp, 4
0555   072B 0A 70 07      jmp _if10_exit
0556   072E             _if10_else:
0557   072E             ;; if(*fp == 'x') 
0558   072E             _if11_cond:
0559   072E FA FD FF      lea d, [bp + -3] ; $fp
0560   0731 2A            mov b, [d]
0561   0732 74            mov d, b
0562   0733 32            mov bl, [d]
0563   0734 A7 00         mov bh, 0
0564   0736             ; START RELATIONAL
0565   0736 D7            push a
0566   0737 11            mov a, b
0567   0738 26 78 00      mov b, $78
0568   073B B0            cmp a, b
0569   073C FD 71         seq ; ==
0570   073E E4            pop a
0571   073F             ; END RELATIONAL
0572   073F C0 00 00      cmp b, 0
0573   0742 C6 64 07      je _if11_else
0574   0745             _if11_true:
0575   0745             ;; printx32(*(long int *)p); 
0576   0745 FA FF FF      lea d, [bp + -1] ; $p
0577   0748 2A            mov b, [d]
0578   0749 74            mov d, b
0579   074A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0580   074D FD 39         mov c, b ; And place it into C
0581   074F 2A            mov b, [d] ; Lower Word in B
0582   0750 FD 79         mov g, b
0583   0752 28            mov b, c
0584   0753 FD AB         swp b
0585   0755 D8            push b
0586   0756 FD 27         mov b, g
0587   0758 FD AB         swp b
0588   075A D8            push b
0589   075B 07 91 08      call printx32
0590   075E 51 04 00      add sp, 4
0591   0761 0A 70 07      jmp _if11_exit
0592   0764             _if11_else:
0593   0764             ;; err("Unexpected format in printf."); 
0594   0764 26 B1 18      mov b, __s3 ; "Unexpected format in printf."
0595   0767 FD AB         swp b
0596   0769 D8            push b
0597   076A 07 7C 08      call err
0598   076D 51 02 00      add sp, 2
0599   0770             _if11_exit:
0600   0770             _if10_exit:
0601   0770             _if9_exit:
0602   0770             ;; p = p + 4; 
0603   0770 FA FF FF      lea d, [bp + -1] ; $p
0604   0773 DA            push d
0605   0774 FA FF FF      lea d, [bp + -1] ; $p
0606   0777 2A            mov b, [d]
0607   0778             ; START TERMS
0608   0778 D7            push a
0609   0779 11            mov a, b
0610   077A 26 04 00      mov b, $4
0611   077D 54            add a, b
0612   077E 27            mov b, a
0613   077F E4            pop a
0614   0780             ; END TERMS
0615   0780 E7            pop d
0616   0781 FD 43         mov [d], b
0617   0783             ;; break; 
0618   0783 0A 4B 08      jmp _switch8_exit ; case break
0619   0786             _switch8_case2:
0620   0786             _switch8_case3:
0621   0786             ;; print_signed(*(int*)p); 
0622   0786 FA FF FF      lea d, [bp + -1] ; $p
0623   0789 2A            mov b, [d]
0624   078A 74            mov d, b
0625   078B 2A            mov b, [d]
0626   078C FD AB         swp b
0627   078E D8            push b
0628   078F 07 2D 0B      call print_signed
0629   0792 51 02 00      add sp, 2
0630   0795             ;; p = p + 2; 
0631   0795 FA FF FF      lea d, [bp + -1] ; $p
0632   0798 DA            push d
0633   0799 FA FF FF      lea d, [bp + -1] ; $p
0634   079C 2A            mov b, [d]
0635   079D             ; START TERMS
0636   079D D7            push a
0637   079E 11            mov a, b
0638   079F 26 02 00      mov b, $2
0639   07A2 54            add a, b
0640   07A3 27            mov b, a
0641   07A4 E4            pop a
0642   07A5             ; END TERMS
0643   07A5 E7            pop d
0644   07A6 FD 43         mov [d], b
0645   07A8             ;; break; 
0646   07A8 0A 4B 08      jmp _switch8_exit ; case break
0647   07AB             _switch8_case4:
0648   07AB             ;; print_unsigned(*(unsigned int*)p); 
0649   07AB FA FF FF      lea d, [bp + -1] ; $p
0650   07AE 2A            mov b, [d]
0651   07AF 74            mov d, b
0652   07B0 2A            mov b, [d]
0653   07B1 FD AB         swp b
0654   07B3 D8            push b
0655   07B4 07 4A 0E      call print_unsigned
0656   07B7 51 02 00      add sp, 2
0657   07BA             ;; p = p + 2; 
0658   07BA FA FF FF      lea d, [bp + -1] ; $p
0659   07BD DA            push d
0660   07BE FA FF FF      lea d, [bp + -1] ; $p
0661   07C1 2A            mov b, [d]
0662   07C2             ; START TERMS
0663   07C2 D7            push a
0664   07C3 11            mov a, b
0665   07C4 26 02 00      mov b, $2
0666   07C7 54            add a, b
0667   07C8 27            mov b, a
0668   07C9 E4            pop a
0669   07CA             ; END TERMS
0670   07CA E7            pop d
0671   07CB FD 43         mov [d], b
0672   07CD             ;; break; 
0673   07CD 0A 4B 08      jmp _switch8_exit ; case break
0674   07D0             _switch8_case5:
0675   07D0             ;; printx16(*(int*)p); 
0676   07D0 FA FF FF      lea d, [bp + -1] ; $p
0677   07D3 2A            mov b, [d]
0678   07D4 74            mov d, b
0679   07D5 2A            mov b, [d]
0680   07D6 FD AB         swp b
0681   07D8 D8            push b
0682   07D9 07 A3 08      call printx16
0683   07DC 51 02 00      add sp, 2
0684   07DF             ;; p = p + 2; 
0685   07DF FA FF FF      lea d, [bp + -1] ; $p
0686   07E2 DA            push d
0687   07E3 FA FF FF      lea d, [bp + -1] ; $p
0688   07E6 2A            mov b, [d]
0689   07E7             ; START TERMS
0690   07E7 D7            push a
0691   07E8 11            mov a, b
0692   07E9 26 02 00      mov b, $2
0693   07EC 54            add a, b
0694   07ED 27            mov b, a
0695   07EE E4            pop a
0696   07EF             ; END TERMS
0697   07EF E7            pop d
0698   07F0 FD 43         mov [d], b
0699   07F2             ;; break; 
0700   07F2 0A 4B 08      jmp _switch8_exit ; case break
0701   07F5             _switch8_case6:
0702   07F5             ;; putchar(*(char*)p); 
0703   07F5 FA FF FF      lea d, [bp + -1] ; $p
0704   07F8 2A            mov b, [d]
0705   07F9 74            mov d, b
0706   07FA 32            mov bl, [d]
0707   07FB A7 00         mov bh, 0
0708   07FD DD            push bl
0709   07FE 07 32 0F      call putchar
0710   0801 51 01 00      add sp, 1
0711   0804             ;; p = p + 2; 
0712   0804 FA FF FF      lea d, [bp + -1] ; $p
0713   0807 DA            push d
0714   0808 FA FF FF      lea d, [bp + -1] ; $p
0715   080B 2A            mov b, [d]
0716   080C             ; START TERMS
0717   080C D7            push a
0718   080D 11            mov a, b
0719   080E 26 02 00      mov b, $2
0720   0811 54            add a, b
0721   0812 27            mov b, a
0722   0813 E4            pop a
0723   0814             ; END TERMS
0724   0814 E7            pop d
0725   0815 FD 43         mov [d], b
0726   0817             ;; break; 
0727   0817 0A 4B 08      jmp _switch8_exit ; case break
0728   081A             _switch8_case7:
0729   081A             ;; print(*(char**)p); 
0730   081A FA FF FF      lea d, [bp + -1] ; $p
0731   081D 2A            mov b, [d]
0732   081E 74            mov d, b
0733   081F 2A            mov b, [d]
0734   0820 FD AB         swp b
0735   0822 D8            push b
0736   0823 07 7A 0F      call print
0737   0826 51 02 00      add sp, 2
0738   0829             ;; p = p + 2; 
0739   0829 FA FF FF      lea d, [bp + -1] ; $p
0740   082C DA            push d
0741   082D FA FF FF      lea d, [bp + -1] ; $p
0742   0830 2A            mov b, [d]
0743   0831             ; START TERMS
0744   0831 D7            push a
0745   0832 11            mov a, b
0746   0833 26 02 00      mov b, $2
0747   0836 54            add a, b
0748   0837 27            mov b, a
0749   0838 E4            pop a
0750   0839             ; END TERMS
0751   0839 E7            pop d
0752   083A FD 43         mov [d], b
0753   083C             ;; break; 
0754   083C 0A 4B 08      jmp _switch8_exit ; case break
0755   083F             _switch8_default:
0756   083F             ;; print("Error: Unknown argument type.\n"); 
0757   083F 26 CE 18      mov b, __s4 ; "Error: Unknown argument type.\n"
0758   0842 FD AB         swp b
0759   0844 D8            push b
0760   0845 07 7A 0F      call print
0761   0848 51 02 00      add sp, 2
0762   084B             _switch8_exit:
0763   084B             ;; fp++; 
0764   084B FA FD FF      lea d, [bp + -3] ; $fp
0765   084E 2A            mov b, [d]
0766   084F D8            push b
0767   0850 FD 77         inc b
0768   0852 FA FD FF      lea d, [bp + -3] ; $fp
0769   0855 FD 43         mov [d], b
0770   0857 E5            pop b
0771   0858 0A 77 08      jmp _if7_exit
0772   085B             _if7_else:
0773   085B             ;; putchar(*fp); 
0774   085B FA FD FF      lea d, [bp + -3] ; $fp
0775   085E 2A            mov b, [d]
0776   085F 74            mov d, b
0777   0860 32            mov bl, [d]
0778   0861 A7 00         mov bh, 0
0779   0863 DD            push bl
0780   0864 07 32 0F      call putchar
0781   0867 51 01 00      add sp, 1
0782   086A             ;; fp++; 
0783   086A FA FD FF      lea d, [bp + -3] ; $fp
0784   086D 2A            mov b, [d]
0785   086E D8            push b
0786   086F FD 77         inc b
0787   0871 FA FD FF      lea d, [bp + -3] ; $fp
0788   0874 FD 43         mov [d], b
0789   0876 E5            pop b
0790   0877             _if7_exit:
0791   0877             _if6_exit:
0792   0877             _for5_update:
0793   0877 0A 42 06      jmp _for5_cond
0794   087A             _for5_exit:
0795   087A F9            leave
0796   087B 09            ret
0797   087C             
0798   087C             err:
0799   087C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0800   087F             ;; print(e); 
0801   087F FA 05 00      lea d, [bp + 5] ; $e
0802   0882 2A            mov b, [d]
0803   0883 FD AB         swp b
0804   0885 D8            push b
0805   0886 07 7A 0F      call print
0806   0889 51 02 00      add sp, 2
0807   088C             ;; exit(); 
0808   088C 07 F4 0F      call exit
0809   088F F9            leave
0810   0890 09            ret
0811   0891             
0812   0891             printx32:
0813   0891 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0814   0894             
0815   0894             ; --- BEGIN INLINE ASM BLOCK
0816   0894 FA 05 00      lea d, [bp + 5] ; $hex
0817   0897 2B 02 00      mov b, [d+2]
0818   089A 07 51 13      call print_u16x
0819   089D 2A            mov b, [d]
0820   089E 07 51 13      call print_u16x
0821   08A1             ; --- END INLINE ASM BLOCK
0822   08A1             
0823   08A1 F9            leave
0824   08A2 09            ret
0825   08A3             
0826   08A3             printx16:
0827   08A3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0828   08A6             
0829   08A6             ; --- BEGIN INLINE ASM BLOCK
0830   08A6 FA 05 00      lea d, [bp + 5] ; $hex
0831   08A9 2A            mov b, [d]
0832   08AA 07 51 13      call print_u16x
0833   08AD             ; --- END INLINE ASM BLOCK
0834   08AD             
0835   08AD F9            leave
0836   08AE 09            ret
0837   08AF             
0838   08AF             printx8:
0839   08AF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0840   08B2             
0841   08B2             ; --- BEGIN INLINE ASM BLOCK
0842   08B2 FA 05 00      lea d, [bp + 5] ; $hex
0843   08B5 32            mov bl, [d]
0844   08B6 07 95 13      call print_u8x
0845   08B9             ; --- END INLINE ASM BLOCK
0846   08B9             
0847   08B9 F9            leave
0848   08BA 09            ret
0849   08BB             
0850   08BB             hex_to_int:
0851   08BB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0852   08BE             ; $value 
0853   08BE 10 00 00      mov a, $0
0854   08C1 45 FF FF      mov [bp + -1], a
0855   08C4             ; $i 
0856   08C4             ; $hex_char 
0857   08C4             ; $len 
0858   08C4 52 07 00      sub sp, 7
0859   08C7             ;; len = strlen(hex_string); 
0860   08C7 FA FA FF      lea d, [bp + -6] ; $len
0861   08CA DA            push d
0862   08CB FA 05 00      lea d, [bp + 5] ; $hex_string
0863   08CE 2A            mov b, [d]
0864   08CF FD AB         swp b
0865   08D1 D8            push b
0866   08D2 07 D5 05      call strlen
0867   08D5 51 02 00      add sp, 2
0868   08D8 E7            pop d
0869   08D9 FD 43         mov [d], b
0870   08DB             ;; for (i = 0; i < len; i++) { 
0871   08DB             _for12_init:
0872   08DB FA FD FF      lea d, [bp + -3] ; $i
0873   08DE DA            push d
0874   08DF 26 00 00      mov b, $0
0875   08E2 E7            pop d
0876   08E3 FD 43         mov [d], b
0877   08E5             _for12_cond:
0878   08E5 FA FD FF      lea d, [bp + -3] ; $i
0879   08E8 2A            mov b, [d]
0880   08E9             ; START RELATIONAL
0881   08E9 D7            push a
0882   08EA 11            mov a, b
0883   08EB FA FA FF      lea d, [bp + -6] ; $len
0884   08EE 2A            mov b, [d]
0885   08EF B0            cmp a, b
0886   08F0 FD 73         slt ; < 
0887   08F2 E4            pop a
0888   08F3             ; END RELATIONAL
0889   08F3 C0 00 00      cmp b, 0
0890   08F6 C6 FB 09      je _for12_exit
0891   08F9             _for12_block:
0892   08F9             ;; hex_char = hex_string[i]; 
0893   08F9 FA FC FF      lea d, [bp + -4] ; $hex_char
0894   08FC DA            push d
0895   08FD FA 05 00      lea d, [bp + 5] ; $hex_string
0896   0900 FD 2A         mov d, [d]
0897   0902 D7            push a
0898   0903 DA            push d
0899   0904 FA FD FF      lea d, [bp + -3] ; $i
0900   0907 2A            mov b, [d]
0901   0908 E7            pop d
0902   0909 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0903   090D E4            pop a
0904   090E 32            mov bl, [d]
0905   090F A7 00         mov bh, 0
0906   0911 E7            pop d
0907   0912 FD 3E         mov [d], bl
0908   0914             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0909   0914             _if13_cond:
0910   0914 FA FC FF      lea d, [bp + -4] ; $hex_char
0911   0917 32            mov bl, [d]
0912   0918 A7 00         mov bh, 0
0913   091A             ; START RELATIONAL
0914   091A D7            push a
0915   091B 11            mov a, b
0916   091C 26 61 00      mov b, $61
0917   091F B0            cmp a, b
0918   0920 FD 80         sge ; >=
0919   0922 E4            pop a
0920   0923             ; END RELATIONAL
0921   0923 D7            push a
0922   0924 11            mov a, b
0923   0925 FA FC FF      lea d, [bp + -4] ; $hex_char
0924   0928 32            mov bl, [d]
0925   0929 A7 00         mov bh, 0
0926   092B             ; START RELATIONAL
0927   092B D7            push a
0928   092C 11            mov a, b
0929   092D 26 66 00      mov b, $66
0930   0930 B0            cmp a, b
0931   0931 FD 74         sle ; <=
0932   0933 E4            pop a
0933   0934             ; END RELATIONAL
0934   0934 FD A7         sand a, b ; &&
0935   0936 E4            pop a
0936   0937 C0 00 00      cmp b, 0
0937   093A C6 6C 09      je _if13_else
0938   093D             _if13_true:
0939   093D             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0940   093D FA FF FF      lea d, [bp + -1] ; $value
0941   0940 DA            push d
0942   0941 FA FF FF      lea d, [bp + -1] ; $value
0943   0944 2A            mov b, [d]
0944   0945             ; START FACTORS
0945   0945 D7            push a
0946   0946 11            mov a, b
0947   0947 26 10 00      mov b, $10
0948   094A AC            mul a, b ; *
0949   094B 11            mov a, b
0950   094C 27            mov b, a
0951   094D E4            pop a
0952   094E             ; END FACTORS
0953   094E             ; START TERMS
0954   094E D7            push a
0955   094F 11            mov a, b
0956   0950 FA FC FF      lea d, [bp + -4] ; $hex_char
0957   0953 32            mov bl, [d]
0958   0954 A7 00         mov bh, 0
0959   0956             ; START TERMS
0960   0956 D7            push a
0961   0957 11            mov a, b
0962   0958 26 61 00      mov b, $61
0963   095B 60            sub a, b
0964   095C 11            mov a, b
0965   095D 26 0A 00      mov b, $a
0966   0960 54            add a, b
0967   0961 27            mov b, a
0968   0962 E4            pop a
0969   0963             ; END TERMS
0970   0963 54            add a, b
0971   0964 27            mov b, a
0972   0965 E4            pop a
0973   0966             ; END TERMS
0974   0966 E7            pop d
0975   0967 FD 43         mov [d], b
0976   0969 0A EB 09      jmp _if13_exit
0977   096C             _if13_else:
0978   096C             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0979   096C             _if14_cond:
0980   096C FA FC FF      lea d, [bp + -4] ; $hex_char
0981   096F 32            mov bl, [d]
0982   0970 A7 00         mov bh, 0
0983   0972             ; START RELATIONAL
0984   0972 D7            push a
0985   0973 11            mov a, b
0986   0974 26 41 00      mov b, $41
0987   0977 B0            cmp a, b
0988   0978 FD 80         sge ; >=
0989   097A E4            pop a
0990   097B             ; END RELATIONAL
0991   097B D7            push a
0992   097C 11            mov a, b
0993   097D FA FC FF      lea d, [bp + -4] ; $hex_char
0994   0980 32            mov bl, [d]
0995   0981 A7 00         mov bh, 0
0996   0983             ; START RELATIONAL
0997   0983 D7            push a
0998   0984 11            mov a, b
0999   0985 26 46 00      mov b, $46
1000   0988 B0            cmp a, b
1001   0989 FD 74         sle ; <=
1002   098B E4            pop a
1003   098C             ; END RELATIONAL
1004   098C FD A7         sand a, b ; &&
1005   098E E4            pop a
1006   098F C0 00 00      cmp b, 0
1007   0992 C6 C4 09      je _if14_else
1008   0995             _if14_true:
1009   0995             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1010   0995 FA FF FF      lea d, [bp + -1] ; $value
1011   0998 DA            push d
1012   0999 FA FF FF      lea d, [bp + -1] ; $value
1013   099C 2A            mov b, [d]
1014   099D             ; START FACTORS
1015   099D D7            push a
1016   099E 11            mov a, b
1017   099F 26 10 00      mov b, $10
1018   09A2 AC            mul a, b ; *
1019   09A3 11            mov a, b
1020   09A4 27            mov b, a
1021   09A5 E4            pop a
1022   09A6             ; END FACTORS
1023   09A6             ; START TERMS
1024   09A6 D7            push a
1025   09A7 11            mov a, b
1026   09A8 FA FC FF      lea d, [bp + -4] ; $hex_char
1027   09AB 32            mov bl, [d]
1028   09AC A7 00         mov bh, 0
1029   09AE             ; START TERMS
1030   09AE D7            push a
1031   09AF 11            mov a, b
1032   09B0 26 41 00      mov b, $41
1033   09B3 60            sub a, b
1034   09B4 11            mov a, b
1035   09B5 26 0A 00      mov b, $a
1036   09B8 54            add a, b
1037   09B9 27            mov b, a
1038   09BA E4            pop a
1039   09BB             ; END TERMS
1040   09BB 54            add a, b
1041   09BC 27            mov b, a
1042   09BD E4            pop a
1043   09BE             ; END TERMS
1044   09BE E7            pop d
1045   09BF FD 43         mov [d], b
1046   09C1 0A EB 09      jmp _if14_exit
1047   09C4             _if14_else:
1048   09C4             ;; value = (value * 16) + (hex_char - '0'); 
1049   09C4 FA FF FF      lea d, [bp + -1] ; $value
1050   09C7 DA            push d
1051   09C8 FA FF FF      lea d, [bp + -1] ; $value
1052   09CB 2A            mov b, [d]
1053   09CC             ; START FACTORS
1054   09CC D7            push a
1055   09CD 11            mov a, b
1056   09CE 26 10 00      mov b, $10
1057   09D1 AC            mul a, b ; *
1058   09D2 11            mov a, b
1059   09D3 27            mov b, a
1060   09D4 E4            pop a
1061   09D5             ; END FACTORS
1062   09D5             ; START TERMS
1063   09D5 D7            push a
1064   09D6 11            mov a, b
1065   09D7 FA FC FF      lea d, [bp + -4] ; $hex_char
1066   09DA 32            mov bl, [d]
1067   09DB A7 00         mov bh, 0
1068   09DD             ; START TERMS
1069   09DD D7            push a
1070   09DE 11            mov a, b
1071   09DF 26 30 00      mov b, $30
1072   09E2 60            sub a, b
1073   09E3 27            mov b, a
1074   09E4 E4            pop a
1075   09E5             ; END TERMS
1076   09E5 54            add a, b
1077   09E6 27            mov b, a
1078   09E7 E4            pop a
1079   09E8             ; END TERMS
1080   09E8 E7            pop d
1081   09E9 FD 43         mov [d], b
1082   09EB             _if14_exit:
1083   09EB             _if13_exit:
1084   09EB             _for12_update:
1085   09EB FA FD FF      lea d, [bp + -3] ; $i
1086   09EE 2A            mov b, [d]
1087   09EF D8            push b
1088   09F0 FD 77         inc b
1089   09F2 FA FD FF      lea d, [bp + -3] ; $i
1090   09F5 FD 43         mov [d], b
1091   09F7 E5            pop b
1092   09F8 0A E5 08      jmp _for12_cond
1093   09FB             _for12_exit:
1094   09FB             ;; return value; 
1095   09FB FA FF FF      lea d, [bp + -1] ; $value
1096   09FE 2A            mov b, [d]
1097   09FF F9            leave
1098   0A00 09            ret
1099   0A01             
1100   0A01             atoi:
1101   0A01 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1102   0A04             ; $result 
1103   0A04 10 00 00      mov a, $0
1104   0A07 45 FF FF      mov [bp + -1], a
1105   0A0A             ; $sign 
1106   0A0A 10 01 00      mov a, $1
1107   0A0D 45 FD FF      mov [bp + -3], a
1108   0A10 52 04 00      sub sp, 4
1109   0A13             ;; while (*str == ' ') str++; 
1110   0A13             _while15_cond:
1111   0A13 FA 05 00      lea d, [bp + 5] ; $str
1112   0A16 2A            mov b, [d]
1113   0A17 74            mov d, b
1114   0A18 32            mov bl, [d]
1115   0A19 A7 00         mov bh, 0
1116   0A1B             ; START RELATIONAL
1117   0A1B D7            push a
1118   0A1C 11            mov a, b
1119   0A1D 26 20 00      mov b, $20
1120   0A20 B0            cmp a, b
1121   0A21 FD 71         seq ; ==
1122   0A23 E4            pop a
1123   0A24             ; END RELATIONAL
1124   0A24 C0 00 00      cmp b, 0
1125   0A27 C6 3A 0A      je _while15_exit
1126   0A2A             _while15_block:
1127   0A2A             ;; str++; 
1128   0A2A FA 05 00      lea d, [bp + 5] ; $str
1129   0A2D 2A            mov b, [d]
1130   0A2E D8            push b
1131   0A2F FD 77         inc b
1132   0A31 FA 05 00      lea d, [bp + 5] ; $str
1133   0A34 FD 43         mov [d], b
1134   0A36 E5            pop b
1135   0A37 0A 13 0A      jmp _while15_cond
1136   0A3A             _while15_exit:
1137   0A3A             ;; if (*str == '-' || *str == '+') { 
1138   0A3A             _if16_cond:
1139   0A3A FA 05 00      lea d, [bp + 5] ; $str
1140   0A3D 2A            mov b, [d]
1141   0A3E 74            mov d, b
1142   0A3F 32            mov bl, [d]
1143   0A40 A7 00         mov bh, 0
1144   0A42             ; START RELATIONAL
1145   0A42 D7            push a
1146   0A43 11            mov a, b
1147   0A44 26 2D 00      mov b, $2d
1148   0A47 B0            cmp a, b
1149   0A48 FD 71         seq ; ==
1150   0A4A E4            pop a
1151   0A4B             ; END RELATIONAL
1152   0A4B D7            push a
1153   0A4C 11            mov a, b
1154   0A4D FA 05 00      lea d, [bp + 5] ; $str
1155   0A50 2A            mov b, [d]
1156   0A51 74            mov d, b
1157   0A52 32            mov bl, [d]
1158   0A53 A7 00         mov bh, 0
1159   0A55             ; START RELATIONAL
1160   0A55 D7            push a
1161   0A56 11            mov a, b
1162   0A57 26 2B 00      mov b, $2b
1163   0A5A B0            cmp a, b
1164   0A5B FD 71         seq ; ==
1165   0A5D E4            pop a
1166   0A5E             ; END RELATIONAL
1167   0A5E FD A8         sor a, b ; ||
1168   0A60 E4            pop a
1169   0A61 C0 00 00      cmp b, 0
1170   0A64 C6 9D 0A      je _if16_exit
1171   0A67             _if16_true:
1172   0A67             ;; if (*str == '-') sign = -1; 
1173   0A67             _if17_cond:
1174   0A67 FA 05 00      lea d, [bp + 5] ; $str
1175   0A6A 2A            mov b, [d]
1176   0A6B 74            mov d, b
1177   0A6C 32            mov bl, [d]
1178   0A6D A7 00         mov bh, 0
1179   0A6F             ; START RELATIONAL
1180   0A6F D7            push a
1181   0A70 11            mov a, b
1182   0A71 26 2D 00      mov b, $2d
1183   0A74 B0            cmp a, b
1184   0A75 FD 71         seq ; ==
1185   0A77 E4            pop a
1186   0A78             ; END RELATIONAL
1187   0A78 C0 00 00      cmp b, 0
1188   0A7B C6 8D 0A      je _if17_exit
1189   0A7E             _if17_true:
1190   0A7E             ;; sign = -1; 
1191   0A7E FA FD FF      lea d, [bp + -3] ; $sign
1192   0A81 DA            push d
1193   0A82 26 01 00      mov b, $1
1194   0A85 FD 97         neg b
1195   0A87 E7            pop d
1196   0A88 FD 43         mov [d], b
1197   0A8A 0A 8D 0A      jmp _if17_exit
1198   0A8D             _if17_exit:
1199   0A8D             ;; str++; 
1200   0A8D FA 05 00      lea d, [bp + 5] ; $str
1201   0A90 2A            mov b, [d]
1202   0A91 D8            push b
1203   0A92 FD 77         inc b
1204   0A94 FA 05 00      lea d, [bp + 5] ; $str
1205   0A97 FD 43         mov [d], b
1206   0A99 E5            pop b
1207   0A9A 0A 9D 0A      jmp _if16_exit
1208   0A9D             _if16_exit:
1209   0A9D             ;; while (*str >= '0' && *str <= '9') { 
1210   0A9D             _while18_cond:
1211   0A9D FA 05 00      lea d, [bp + 5] ; $str
1212   0AA0 2A            mov b, [d]
1213   0AA1 74            mov d, b
1214   0AA2 32            mov bl, [d]
1215   0AA3 A7 00         mov bh, 0
1216   0AA5             ; START RELATIONAL
1217   0AA5 D7            push a
1218   0AA6 11            mov a, b
1219   0AA7 26 30 00      mov b, $30
1220   0AAA B0            cmp a, b
1221   0AAB FD 82         sgeu ; >= (unsigned)
1222   0AAD E4            pop a
1223   0AAE             ; END RELATIONAL
1224   0AAE D7            push a
1225   0AAF 11            mov a, b
1226   0AB0 FA 05 00      lea d, [bp + 5] ; $str
1227   0AB3 2A            mov b, [d]
1228   0AB4 74            mov d, b
1229   0AB5 32            mov bl, [d]
1230   0AB6 A7 00         mov bh, 0
1231   0AB8             ; START RELATIONAL
1232   0AB8 D7            push a
1233   0AB9 11            mov a, b
1234   0ABA 26 39 00      mov b, $39
1235   0ABD B0            cmp a, b
1236   0ABE FD 76         sleu ; <= (unsigned)
1237   0AC0 E4            pop a
1238   0AC1             ; END RELATIONAL
1239   0AC1 FD A7         sand a, b ; &&
1240   0AC3 E4            pop a
1241   0AC4 C0 00 00      cmp b, 0
1242   0AC7 C6 03 0B      je _while18_exit
1243   0ACA             _while18_block:
1244   0ACA             ;; result = result * 10 + (*str - '0'); 
1245   0ACA FA FF FF      lea d, [bp + -1] ; $result
1246   0ACD DA            push d
1247   0ACE FA FF FF      lea d, [bp + -1] ; $result
1248   0AD1 2A            mov b, [d]
1249   0AD2             ; START FACTORS
1250   0AD2 D7            push a
1251   0AD3 11            mov a, b
1252   0AD4 26 0A 00      mov b, $a
1253   0AD7 AC            mul a, b ; *
1254   0AD8 11            mov a, b
1255   0AD9 27            mov b, a
1256   0ADA E4            pop a
1257   0ADB             ; END FACTORS
1258   0ADB             ; START TERMS
1259   0ADB D7            push a
1260   0ADC 11            mov a, b
1261   0ADD FA 05 00      lea d, [bp + 5] ; $str
1262   0AE0 2A            mov b, [d]
1263   0AE1 74            mov d, b
1264   0AE2 32            mov bl, [d]
1265   0AE3 A7 00         mov bh, 0
1266   0AE5             ; START TERMS
1267   0AE5 D7            push a
1268   0AE6 11            mov a, b
1269   0AE7 26 30 00      mov b, $30
1270   0AEA 60            sub a, b
1271   0AEB 27            mov b, a
1272   0AEC E4            pop a
1273   0AED             ; END TERMS
1274   0AED 54            add a, b
1275   0AEE 27            mov b, a
1276   0AEF E4            pop a
1277   0AF0             ; END TERMS
1278   0AF0 E7            pop d
1279   0AF1 FD 43         mov [d], b
1280   0AF3             ;; str++; 
1281   0AF3 FA 05 00      lea d, [bp + 5] ; $str
1282   0AF6 2A            mov b, [d]
1283   0AF7 D8            push b
1284   0AF8 FD 77         inc b
1285   0AFA FA 05 00      lea d, [bp + 5] ; $str
1286   0AFD FD 43         mov [d], b
1287   0AFF E5            pop b
1288   0B00 0A 9D 0A      jmp _while18_cond
1289   0B03             _while18_exit:
1290   0B03             ;; return sign * result; 
1291   0B03 FA FD FF      lea d, [bp + -3] ; $sign
1292   0B06 2A            mov b, [d]
1293   0B07             ; START FACTORS
1294   0B07 D7            push a
1295   0B08 11            mov a, b
1296   0B09 FA FF FF      lea d, [bp + -1] ; $result
1297   0B0C 2A            mov b, [d]
1298   0B0D AC            mul a, b ; *
1299   0B0E 11            mov a, b
1300   0B0F 27            mov b, a
1301   0B10 E4            pop a
1302   0B11             ; END FACTORS
1303   0B11 F9            leave
1304   0B12 09            ret
1305   0B13             
1306   0B13             gets:
1307   0B13 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1308   0B16             
1309   0B16             ; --- BEGIN INLINE ASM BLOCK
1310   0B16 FA 05 00      lea d, [bp + 5] ; $s
1311   0B19 15            mov a, [d]
1312   0B1A 3C            mov d, a
1313   0B1B 07 B6 11      call _gets
1314   0B1E             ; --- END INLINE ASM BLOCK
1315   0B1E             
1316   0B1E             ;; return strlen(s); 
1317   0B1E FA 05 00      lea d, [bp + 5] ; $s
1318   0B21 2A            mov b, [d]
1319   0B22 FD AB         swp b
1320   0B24 D8            push b
1321   0B25 07 D5 05      call strlen
1322   0B28 51 02 00      add sp, 2
1323   0B2B F9            leave
1324   0B2C 09            ret
1325   0B2D             
1326   0B2D             print_signed:
1327   0B2D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1328   0B30             ; $digits 
1329   0B30             ; $i 
1330   0B30 10 00 00      mov a, $0
1331   0B33 45 FA FF      mov [bp + -6], a
1332   0B36 52 07 00      sub sp, 7
1333   0B39             ;; if (num < 0) { 
1334   0B39             _if19_cond:
1335   0B39 FA 05 00      lea d, [bp + 5] ; $num
1336   0B3C 2A            mov b, [d]
1337   0B3D             ; START RELATIONAL
1338   0B3D D7            push a
1339   0B3E 11            mov a, b
1340   0B3F 26 00 00      mov b, $0
1341   0B42 B0            cmp a, b
1342   0B43 FD 73         slt ; < 
1343   0B45 E4            pop a
1344   0B46             ; END RELATIONAL
1345   0B46 C0 00 00      cmp b, 0
1346   0B49 C6 66 0B      je _if19_else
1347   0B4C             _if19_true:
1348   0B4C             ;; putchar('-'); 
1349   0B4C 26 2D 00      mov b, $2d
1350   0B4F DD            push bl
1351   0B50 07 32 0F      call putchar
1352   0B53 51 01 00      add sp, 1
1353   0B56             ;; num = -num; 
1354   0B56 FA 05 00      lea d, [bp + 5] ; $num
1355   0B59 DA            push d
1356   0B5A FA 05 00      lea d, [bp + 5] ; $num
1357   0B5D 2A            mov b, [d]
1358   0B5E FD 97         neg b
1359   0B60 E7            pop d
1360   0B61 FD 43         mov [d], b
1361   0B63 0A 88 0B      jmp _if19_exit
1362   0B66             _if19_else:
1363   0B66             ;; if (num == 0) { 
1364   0B66             _if20_cond:
1365   0B66 FA 05 00      lea d, [bp + 5] ; $num
1366   0B69 2A            mov b, [d]
1367   0B6A             ; START RELATIONAL
1368   0B6A D7            push a
1369   0B6B 11            mov a, b
1370   0B6C 26 00 00      mov b, $0
1371   0B6F B0            cmp a, b
1372   0B70 FD 71         seq ; ==
1373   0B72 E4            pop a
1374   0B73             ; END RELATIONAL
1375   0B73 C0 00 00      cmp b, 0
1376   0B76 C6 88 0B      je _if20_exit
1377   0B79             _if20_true:
1378   0B79             ;; putchar('0'); 
1379   0B79 26 30 00      mov b, $30
1380   0B7C DD            push bl
1381   0B7D 07 32 0F      call putchar
1382   0B80 51 01 00      add sp, 1
1383   0B83             ;; return; 
1384   0B83 F9            leave
1385   0B84 09            ret
1386   0B85 0A 88 0B      jmp _if20_exit
1387   0B88             _if20_exit:
1388   0B88             _if19_exit:
1389   0B88             ;; while (num > 0) { 
1390   0B88             _while21_cond:
1391   0B88 FA 05 00      lea d, [bp + 5] ; $num
1392   0B8B 2A            mov b, [d]
1393   0B8C             ; START RELATIONAL
1394   0B8C D7            push a
1395   0B8D 11            mov a, b
1396   0B8E 26 00 00      mov b, $0
1397   0B91 B0            cmp a, b
1398   0B92 FD 7F         sgt ; >
1399   0B94 E4            pop a
1400   0B95             ; END RELATIONAL
1401   0B95 C0 00 00      cmp b, 0
1402   0B98 C6 E3 0B      je _while21_exit
1403   0B9B             _while21_block:
1404   0B9B             ;; digits[i] = '0' + (num % 10); 
1405   0B9B FA FC FF      lea d, [bp + -4] ; $digits
1406   0B9E D7            push a
1407   0B9F DA            push d
1408   0BA0 FA FA FF      lea d, [bp + -6] ; $i
1409   0BA3 2A            mov b, [d]
1410   0BA4 E7            pop d
1411   0BA5 5A            add d, b
1412   0BA6 E4            pop a
1413   0BA7 DA            push d
1414   0BA8 26 30 00      mov b, $30
1415   0BAB             ; START TERMS
1416   0BAB D7            push a
1417   0BAC 11            mov a, b
1418   0BAD FA 05 00      lea d, [bp + 5] ; $num
1419   0BB0 2A            mov b, [d]
1420   0BB1             ; START FACTORS
1421   0BB1 D7            push a
1422   0BB2 11            mov a, b
1423   0BB3 26 0A 00      mov b, $a
1424   0BB6 AE            div a, b ; 
1425   0BB7 11            mov a, b
1426   0BB8 27            mov b, a
1427   0BB9 E4            pop a
1428   0BBA             ; END FACTORS
1429   0BBA 54            add a, b
1430   0BBB 27            mov b, a
1431   0BBC E4            pop a
1432   0BBD             ; END TERMS
1433   0BBD E7            pop d
1434   0BBE FD 3E         mov [d], bl
1435   0BC0             ;; num = num / 10; 
1436   0BC0 FA 05 00      lea d, [bp + 5] ; $num
1437   0BC3 DA            push d
1438   0BC4 FA 05 00      lea d, [bp + 5] ; $num
1439   0BC7 2A            mov b, [d]
1440   0BC8             ; START FACTORS
1441   0BC8 D7            push a
1442   0BC9 11            mov a, b
1443   0BCA 26 0A 00      mov b, $a
1444   0BCD AE            div a, b
1445   0BCE 27            mov b, a
1446   0BCF E4            pop a
1447   0BD0             ; END FACTORS
1448   0BD0 E7            pop d
1449   0BD1 FD 43         mov [d], b
1450   0BD3             ;; i++; 
1451   0BD3 FA FA FF      lea d, [bp + -6] ; $i
1452   0BD6 2A            mov b, [d]
1453   0BD7 D8            push b
1454   0BD8 FD 77         inc b
1455   0BDA FA FA FF      lea d, [bp + -6] ; $i
1456   0BDD FD 43         mov [d], b
1457   0BDF E5            pop b
1458   0BE0 0A 88 0B      jmp _while21_cond
1459   0BE3             _while21_exit:
1460   0BE3             ;; while (i > 0) { 
1461   0BE3             _while22_cond:
1462   0BE3 FA FA FF      lea d, [bp + -6] ; $i
1463   0BE6 2A            mov b, [d]
1464   0BE7             ; START RELATIONAL
1465   0BE7 D7            push a
1466   0BE8 11            mov a, b
1467   0BE9 26 00 00      mov b, $0
1468   0BEC B0            cmp a, b
1469   0BED FD 7F         sgt ; >
1470   0BEF E4            pop a
1471   0BF0             ; END RELATIONAL
1472   0BF0 C0 00 00      cmp b, 0
1473   0BF3 C6 1C 0C      je _while22_exit
1474   0BF6             _while22_block:
1475   0BF6             ;; i--; 
1476   0BF6 FA FA FF      lea d, [bp + -6] ; $i
1477   0BF9 2A            mov b, [d]
1478   0BFA D8            push b
1479   0BFB FD 7D         dec b
1480   0BFD FA FA FF      lea d, [bp + -6] ; $i
1481   0C00 FD 43         mov [d], b
1482   0C02 E5            pop b
1483   0C03             ;; putchar(digits[i]); 
1484   0C03 FA FC FF      lea d, [bp + -4] ; $digits
1485   0C06 D7            push a
1486   0C07 DA            push d
1487   0C08 FA FA FF      lea d, [bp + -6] ; $i
1488   0C0B 2A            mov b, [d]
1489   0C0C E7            pop d
1490   0C0D 5A            add d, b
1491   0C0E E4            pop a
1492   0C0F 32            mov bl, [d]
1493   0C10 A7 00         mov bh, 0
1494   0C12 DD            push bl
1495   0C13 07 32 0F      call putchar
1496   0C16 51 01 00      add sp, 1
1497   0C19 0A E3 0B      jmp _while22_cond
1498   0C1C             _while22_exit:
1499   0C1C F9            leave
1500   0C1D 09            ret
1501   0C1E             
1502   0C1E             print_signed_long:
1503   0C1E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1504   0C21             ; $digits 
1505   0C21             ; $i 
1506   0C21 10 00 00      mov a, $0
1507   0C24 45 F5 FF      mov [bp + -11], a
1508   0C27 52 0C 00      sub sp, 12
1509   0C2A             ;; if (num < 0) { 
1510   0C2A             _if23_cond:
1511   0C2A FA 05 00      lea d, [bp + 5] ; $num
1512   0C2D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1513   0C30 FD 39         mov c, b ; And place it into C
1514   0C32 2A            mov b, [d] ; Lower Word in B
1515   0C33             ; START RELATIONAL
1516   0C33 D7            push a
1517   0C34 FD D8         push g
1518   0C36 11            mov a, b
1519   0C37 FD 7A         mov g, c
1520   0C39 26 00 00      mov b, $0
1521   0C3C B0            cmp a, b
1522   0C3D FD 73         slt ; < 
1523   0C3F FD F1         pop g
1524   0C41 E4            pop a
1525   0C42             ; END RELATIONAL
1526   0C42 C0 00 00      cmp b, 0
1527   0C45 C6 6C 0C      je _if23_else
1528   0C48             _if23_true:
1529   0C48             ;; putchar('-'); 
1530   0C48 26 2D 00      mov b, $2d
1531   0C4B DD            push bl
1532   0C4C 07 32 0F      call putchar
1533   0C4F 51 01 00      add sp, 1
1534   0C52             ;; num = -num; 
1535   0C52 FA 05 00      lea d, [bp + 5] ; $num
1536   0C55 DA            push d
1537   0C56 FA 05 00      lea d, [bp + 5] ; $num
1538   0C59 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1539   0C5C FD 39         mov c, b ; And place it into C
1540   0C5E 2A            mov b, [d] ; Lower Word in B
1541   0C5F FD 97         neg b
1542   0C61 E7            pop d
1543   0C62 FD 43         mov [d], b
1544   0C64 28            mov b, c
1545   0C65 FD 44 02 00   mov [d + 2], b
1546   0C69 0A A3 0C      jmp _if23_exit
1547   0C6C             _if23_else:
1548   0C6C             ;; if (num == 0) { 
1549   0C6C             _if24_cond:
1550   0C6C FA 05 00      lea d, [bp + 5] ; $num
1551   0C6F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1552   0C72 FD 39         mov c, b ; And place it into C
1553   0C74 2A            mov b, [d] ; Lower Word in B
1554   0C75             ; START RELATIONAL
1555   0C75 D7            push a
1556   0C76 FD D8         push g
1557   0C78 11            mov a, b
1558   0C79 FD 7A         mov g, c
1559   0C7B 26 00 00      mov b, $0
1560   0C7E B0            cmp a, b
1561   0C7F FD 71         seq ; ==
1562   0C81 D8            push b
1563   0C82 12            mov a, c
1564   0C83 FD 27         mov b, g
1565   0C85 B0            cmp a, b
1566   0C86 FD 71         seq ; ==
1567   0C88 E4            pop a
1568   0C89 FD A7         sand a, b
1569   0C8B FD F1         pop g
1570   0C8D E4            pop a
1571   0C8E             ; END RELATIONAL
1572   0C8E C0 00 00      cmp b, 0
1573   0C91 C6 A3 0C      je _if24_exit
1574   0C94             _if24_true:
1575   0C94             ;; putchar('0'); 
1576   0C94 26 30 00      mov b, $30
1577   0C97 DD            push bl
1578   0C98 07 32 0F      call putchar
1579   0C9B 51 01 00      add sp, 1
1580   0C9E             ;; return; 
1581   0C9E F9            leave
1582   0C9F 09            ret
1583   0CA0 0A A3 0C      jmp _if24_exit
1584   0CA3             _if24_exit:
1585   0CA3             _if23_exit:
1586   0CA3             ;; while (num > 0) { 
1587   0CA3             _while25_cond:
1588   0CA3 FA 05 00      lea d, [bp + 5] ; $num
1589   0CA6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1590   0CA9 FD 39         mov c, b ; And place it into C
1591   0CAB 2A            mov b, [d] ; Lower Word in B
1592   0CAC             ; START RELATIONAL
1593   0CAC D7            push a
1594   0CAD FD D8         push g
1595   0CAF 11            mov a, b
1596   0CB0 FD 7A         mov g, c
1597   0CB2 26 00 00      mov b, $0
1598   0CB5 B0            cmp a, b
1599   0CB6 FD 7F         sgt ; >
1600   0CB8 FD F1         pop g
1601   0CBA E4            pop a
1602   0CBB             ; END RELATIONAL
1603   0CBB C0 00 00      cmp b, 0
1604   0CBE C6 18 0D      je _while25_exit
1605   0CC1             _while25_block:
1606   0CC1             ;; digits[i] = '0' + (num % 10); 
1607   0CC1 FA F7 FF      lea d, [bp + -9] ; $digits
1608   0CC4 D7            push a
1609   0CC5 DA            push d
1610   0CC6 FA F5 FF      lea d, [bp + -11] ; $i
1611   0CC9 2A            mov b, [d]
1612   0CCA E7            pop d
1613   0CCB 5A            add d, b
1614   0CCC E4            pop a
1615   0CCD DA            push d
1616   0CCE 26 30 00      mov b, $30
1617   0CD1             ; START TERMS
1618   0CD1 D7            push a
1619   0CD2 11            mov a, b
1620   0CD3 FA 05 00      lea d, [bp + 5] ; $num
1621   0CD6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1622   0CD9 FD 39         mov c, b ; And place it into C
1623   0CDB 2A            mov b, [d] ; Lower Word in B
1624   0CDC             ; START FACTORS
1625   0CDC D7            push a
1626   0CDD 11            mov a, b
1627   0CDE 26 0A 00      mov b, $a
1628   0CE1 AE            div a, b ; 
1629   0CE2 11            mov a, b
1630   0CE3 27            mov b, a
1631   0CE4 E4            pop a
1632   0CE5             ; END FACTORS
1633   0CE5 54            add a, b
1634   0CE6 27            mov b, a
1635   0CE7 E4            pop a
1636   0CE8             ; END TERMS
1637   0CE8 E7            pop d
1638   0CE9 FD 3E         mov [d], bl
1639   0CEB             ;; num = num / 10; 
1640   0CEB FA 05 00      lea d, [bp + 5] ; $num
1641   0CEE DA            push d
1642   0CEF FA 05 00      lea d, [bp + 5] ; $num
1643   0CF2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1644   0CF5 FD 39         mov c, b ; And place it into C
1645   0CF7 2A            mov b, [d] ; Lower Word in B
1646   0CF8             ; START FACTORS
1647   0CF8 D7            push a
1648   0CF9 11            mov a, b
1649   0CFA 26 0A 00      mov b, $a
1650   0CFD AE            div a, b
1651   0CFE 27            mov b, a
1652   0CFF E4            pop a
1653   0D00             ; END FACTORS
1654   0D00 E7            pop d
1655   0D01 FD 43         mov [d], b
1656   0D03 28            mov b, c
1657   0D04 FD 44 02 00   mov [d + 2], b
1658   0D08             ;; i++; 
1659   0D08 FA F5 FF      lea d, [bp + -11] ; $i
1660   0D0B 2A            mov b, [d]
1661   0D0C D8            push b
1662   0D0D FD 77         inc b
1663   0D0F FA F5 FF      lea d, [bp + -11] ; $i
1664   0D12 FD 43         mov [d], b
1665   0D14 E5            pop b
1666   0D15 0A A3 0C      jmp _while25_cond
1667   0D18             _while25_exit:
1668   0D18             ;; while (i > 0) { 
1669   0D18             _while26_cond:
1670   0D18 FA F5 FF      lea d, [bp + -11] ; $i
1671   0D1B 2A            mov b, [d]
1672   0D1C             ; START RELATIONAL
1673   0D1C D7            push a
1674   0D1D 11            mov a, b
1675   0D1E 26 00 00      mov b, $0
1676   0D21 B0            cmp a, b
1677   0D22 FD 7F         sgt ; >
1678   0D24 E4            pop a
1679   0D25             ; END RELATIONAL
1680   0D25 C0 00 00      cmp b, 0
1681   0D28 C6 51 0D      je _while26_exit
1682   0D2B             _while26_block:
1683   0D2B             ;; i--; 
1684   0D2B FA F5 FF      lea d, [bp + -11] ; $i
1685   0D2E 2A            mov b, [d]
1686   0D2F D8            push b
1687   0D30 FD 7D         dec b
1688   0D32 FA F5 FF      lea d, [bp + -11] ; $i
1689   0D35 FD 43         mov [d], b
1690   0D37 E5            pop b
1691   0D38             ;; putchar(digits[i]); 
1692   0D38 FA F7 FF      lea d, [bp + -9] ; $digits
1693   0D3B D7            push a
1694   0D3C DA            push d
1695   0D3D FA F5 FF      lea d, [bp + -11] ; $i
1696   0D40 2A            mov b, [d]
1697   0D41 E7            pop d
1698   0D42 5A            add d, b
1699   0D43 E4            pop a
1700   0D44 32            mov bl, [d]
1701   0D45 A7 00         mov bh, 0
1702   0D47 DD            push bl
1703   0D48 07 32 0F      call putchar
1704   0D4B 51 01 00      add sp, 1
1705   0D4E 0A 18 0D      jmp _while26_cond
1706   0D51             _while26_exit:
1707   0D51 F9            leave
1708   0D52 09            ret
1709   0D53             
1710   0D53             print_unsigned_long:
1711   0D53 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1712   0D56             ; $digits 
1713   0D56             ; $i 
1714   0D56 52 0C 00      sub sp, 12
1715   0D59             ;; i = 0; 
1716   0D59 FA F5 FF      lea d, [bp + -11] ; $i
1717   0D5C DA            push d
1718   0D5D 26 00 00      mov b, $0
1719   0D60 E7            pop d
1720   0D61 FD 43         mov [d], b
1721   0D63             ;; if(num == 0){ 
1722   0D63             _if27_cond:
1723   0D63 FA 05 00      lea d, [bp + 5] ; $num
1724   0D66 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1725   0D69 FD 39         mov c, b ; And place it into C
1726   0D6B 2A            mov b, [d] ; Lower Word in B
1727   0D6C             ; START RELATIONAL
1728   0D6C D7            push a
1729   0D6D FD D8         push g
1730   0D6F 11            mov a, b
1731   0D70 FD 7A         mov g, c
1732   0D72 26 00 00      mov b, $0
1733   0D75 B0            cmp a, b
1734   0D76 FD 71         seq ; ==
1735   0D78 D8            push b
1736   0D79 12            mov a, c
1737   0D7A FD 27         mov b, g
1738   0D7C B0            cmp a, b
1739   0D7D FD 71         seq ; ==
1740   0D7F E4            pop a
1741   0D80 FD A7         sand a, b
1742   0D82 FD F1         pop g
1743   0D84 E4            pop a
1744   0D85             ; END RELATIONAL
1745   0D85 C0 00 00      cmp b, 0
1746   0D88 C6 9A 0D      je _if27_exit
1747   0D8B             _if27_true:
1748   0D8B             ;; putchar('0'); 
1749   0D8B 26 30 00      mov b, $30
1750   0D8E DD            push bl
1751   0D8F 07 32 0F      call putchar
1752   0D92 51 01 00      add sp, 1
1753   0D95             ;; return; 
1754   0D95 F9            leave
1755   0D96 09            ret
1756   0D97 0A 9A 0D      jmp _if27_exit
1757   0D9A             _if27_exit:
1758   0D9A             ;; while (num > 0) { 
1759   0D9A             _while28_cond:
1760   0D9A FA 05 00      lea d, [bp + 5] ; $num
1761   0D9D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1762   0DA0 FD 39         mov c, b ; And place it into C
1763   0DA2 2A            mov b, [d] ; Lower Word in B
1764   0DA3             ; START RELATIONAL
1765   0DA3 D7            push a
1766   0DA4 FD D8         push g
1767   0DA6 11            mov a, b
1768   0DA7 FD 7A         mov g, c
1769   0DA9 26 00 00      mov b, $0
1770   0DAC B0            cmp a, b
1771   0DAD FD 81         sgu ; > (unsigned)
1772   0DAF FD F1         pop g
1773   0DB1 E4            pop a
1774   0DB2             ; END RELATIONAL
1775   0DB2 C0 00 00      cmp b, 0
1776   0DB5 C6 0F 0E      je _while28_exit
1777   0DB8             _while28_block:
1778   0DB8             ;; digits[i] = '0' + (num % 10); 
1779   0DB8 FA F7 FF      lea d, [bp + -9] ; $digits
1780   0DBB D7            push a
1781   0DBC DA            push d
1782   0DBD FA F5 FF      lea d, [bp + -11] ; $i
1783   0DC0 2A            mov b, [d]
1784   0DC1 E7            pop d
1785   0DC2 5A            add d, b
1786   0DC3 E4            pop a
1787   0DC4 DA            push d
1788   0DC5 26 30 00      mov b, $30
1789   0DC8             ; START TERMS
1790   0DC8 D7            push a
1791   0DC9 11            mov a, b
1792   0DCA FA 05 00      lea d, [bp + 5] ; $num
1793   0DCD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1794   0DD0 FD 39         mov c, b ; And place it into C
1795   0DD2 2A            mov b, [d] ; Lower Word in B
1796   0DD3             ; START FACTORS
1797   0DD3 D7            push a
1798   0DD4 11            mov a, b
1799   0DD5 26 0A 00      mov b, $a
1800   0DD8 AE            div a, b ; 
1801   0DD9 11            mov a, b
1802   0DDA 27            mov b, a
1803   0DDB E4            pop a
1804   0DDC             ; END FACTORS
1805   0DDC 54            add a, b
1806   0DDD 27            mov b, a
1807   0DDE E4            pop a
1808   0DDF             ; END TERMS
1809   0DDF E7            pop d
1810   0DE0 FD 3E         mov [d], bl
1811   0DE2             ;; num = num / 10; 
1812   0DE2 FA 05 00      lea d, [bp + 5] ; $num
1813   0DE5 DA            push d
1814   0DE6 FA 05 00      lea d, [bp + 5] ; $num
1815   0DE9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1816   0DEC FD 39         mov c, b ; And place it into C
1817   0DEE 2A            mov b, [d] ; Lower Word in B
1818   0DEF             ; START FACTORS
1819   0DEF D7            push a
1820   0DF0 11            mov a, b
1821   0DF1 26 0A 00      mov b, $a
1822   0DF4 AE            div a, b
1823   0DF5 27            mov b, a
1824   0DF6 E4            pop a
1825   0DF7             ; END FACTORS
1826   0DF7 E7            pop d
1827   0DF8 FD 43         mov [d], b
1828   0DFA 28            mov b, c
1829   0DFB FD 44 02 00   mov [d + 2], b
1830   0DFF             ;; i++; 
1831   0DFF FA F5 FF      lea d, [bp + -11] ; $i
1832   0E02 2A            mov b, [d]
1833   0E03 D8            push b
1834   0E04 FD 77         inc b
1835   0E06 FA F5 FF      lea d, [bp + -11] ; $i
1836   0E09 FD 43         mov [d], b
1837   0E0B E5            pop b
1838   0E0C 0A 9A 0D      jmp _while28_cond
1839   0E0F             _while28_exit:
1840   0E0F             ;; while (i > 0) { 
1841   0E0F             _while29_cond:
1842   0E0F FA F5 FF      lea d, [bp + -11] ; $i
1843   0E12 2A            mov b, [d]
1844   0E13             ; START RELATIONAL
1845   0E13 D7            push a
1846   0E14 11            mov a, b
1847   0E15 26 00 00      mov b, $0
1848   0E18 B0            cmp a, b
1849   0E19 FD 7F         sgt ; >
1850   0E1B E4            pop a
1851   0E1C             ; END RELATIONAL
1852   0E1C C0 00 00      cmp b, 0
1853   0E1F C6 48 0E      je _while29_exit
1854   0E22             _while29_block:
1855   0E22             ;; i--; 
1856   0E22 FA F5 FF      lea d, [bp + -11] ; $i
1857   0E25 2A            mov b, [d]
1858   0E26 D8            push b
1859   0E27 FD 7D         dec b
1860   0E29 FA F5 FF      lea d, [bp + -11] ; $i
1861   0E2C FD 43         mov [d], b
1862   0E2E E5            pop b
1863   0E2F             ;; putchar(digits[i]); 
1864   0E2F FA F7 FF      lea d, [bp + -9] ; $digits
1865   0E32 D7            push a
1866   0E33 DA            push d
1867   0E34 FA F5 FF      lea d, [bp + -11] ; $i
1868   0E37 2A            mov b, [d]
1869   0E38 E7            pop d
1870   0E39 5A            add d, b
1871   0E3A E4            pop a
1872   0E3B 32            mov bl, [d]
1873   0E3C A7 00         mov bh, 0
1874   0E3E DD            push bl
1875   0E3F 07 32 0F      call putchar
1876   0E42 51 01 00      add sp, 1
1877   0E45 0A 0F 0E      jmp _while29_cond
1878   0E48             _while29_exit:
1879   0E48 F9            leave
1880   0E49 09            ret
1881   0E4A             
1882   0E4A             print_unsigned:
1883   0E4A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1884   0E4D             ; $digits 
1885   0E4D             ; $i 
1886   0E4D 52 07 00      sub sp, 7
1887   0E50             ;; i = 0; 
1888   0E50 FA FA FF      lea d, [bp + -6] ; $i
1889   0E53 DA            push d
1890   0E54 26 00 00      mov b, $0
1891   0E57 E7            pop d
1892   0E58 FD 43         mov [d], b
1893   0E5A             ;; if(num == 0){ 
1894   0E5A             _if30_cond:
1895   0E5A FA 05 00      lea d, [bp + 5] ; $num
1896   0E5D 2A            mov b, [d]
1897   0E5E             ; START RELATIONAL
1898   0E5E D7            push a
1899   0E5F 11            mov a, b
1900   0E60 26 00 00      mov b, $0
1901   0E63 B0            cmp a, b
1902   0E64 FD 71         seq ; ==
1903   0E66 E4            pop a
1904   0E67             ; END RELATIONAL
1905   0E67 C0 00 00      cmp b, 0
1906   0E6A C6 7C 0E      je _if30_exit
1907   0E6D             _if30_true:
1908   0E6D             ;; putchar('0'); 
1909   0E6D 26 30 00      mov b, $30
1910   0E70 DD            push bl
1911   0E71 07 32 0F      call putchar
1912   0E74 51 01 00      add sp, 1
1913   0E77             ;; return; 
1914   0E77 F9            leave
1915   0E78 09            ret
1916   0E79 0A 7C 0E      jmp _if30_exit
1917   0E7C             _if30_exit:
1918   0E7C             ;; while (num > 0) { 
1919   0E7C             _while31_cond:
1920   0E7C FA 05 00      lea d, [bp + 5] ; $num
1921   0E7F 2A            mov b, [d]
1922   0E80             ; START RELATIONAL
1923   0E80 D7            push a
1924   0E81 11            mov a, b
1925   0E82 26 00 00      mov b, $0
1926   0E85 B0            cmp a, b
1927   0E86 FD 81         sgu ; > (unsigned)
1928   0E88 E4            pop a
1929   0E89             ; END RELATIONAL
1930   0E89 C0 00 00      cmp b, 0
1931   0E8C C6 D7 0E      je _while31_exit
1932   0E8F             _while31_block:
1933   0E8F             ;; digits[i] = '0' + (num % 10); 
1934   0E8F FA FC FF      lea d, [bp + -4] ; $digits
1935   0E92 D7            push a
1936   0E93 DA            push d
1937   0E94 FA FA FF      lea d, [bp + -6] ; $i
1938   0E97 2A            mov b, [d]
1939   0E98 E7            pop d
1940   0E99 5A            add d, b
1941   0E9A E4            pop a
1942   0E9B DA            push d
1943   0E9C 26 30 00      mov b, $30
1944   0E9F             ; START TERMS
1945   0E9F D7            push a
1946   0EA0 11            mov a, b
1947   0EA1 FA 05 00      lea d, [bp + 5] ; $num
1948   0EA4 2A            mov b, [d]
1949   0EA5             ; START FACTORS
1950   0EA5 D7            push a
1951   0EA6 11            mov a, b
1952   0EA7 26 0A 00      mov b, $a
1953   0EAA AE            div a, b ; 
1954   0EAB 11            mov a, b
1955   0EAC 27            mov b, a
1956   0EAD E4            pop a
1957   0EAE             ; END FACTORS
1958   0EAE 54            add a, b
1959   0EAF 27            mov b, a
1960   0EB0 E4            pop a
1961   0EB1             ; END TERMS
1962   0EB1 E7            pop d
1963   0EB2 FD 3E         mov [d], bl
1964   0EB4             ;; num = num / 10; 
1965   0EB4 FA 05 00      lea d, [bp + 5] ; $num
1966   0EB7 DA            push d
1967   0EB8 FA 05 00      lea d, [bp + 5] ; $num
1968   0EBB 2A            mov b, [d]
1969   0EBC             ; START FACTORS
1970   0EBC D7            push a
1971   0EBD 11            mov a, b
1972   0EBE 26 0A 00      mov b, $a
1973   0EC1 AE            div a, b
1974   0EC2 27            mov b, a
1975   0EC3 E4            pop a
1976   0EC4             ; END FACTORS
1977   0EC4 E7            pop d
1978   0EC5 FD 43         mov [d], b
1979   0EC7             ;; i++; 
1980   0EC7 FA FA FF      lea d, [bp + -6] ; $i
1981   0ECA 2A            mov b, [d]
1982   0ECB D8            push b
1983   0ECC FD 77         inc b
1984   0ECE FA FA FF      lea d, [bp + -6] ; $i
1985   0ED1 FD 43         mov [d], b
1986   0ED3 E5            pop b
1987   0ED4 0A 7C 0E      jmp _while31_cond
1988   0ED7             _while31_exit:
1989   0ED7             ;; while (i > 0) { 
1990   0ED7             _while32_cond:
1991   0ED7 FA FA FF      lea d, [bp + -6] ; $i
1992   0EDA 2A            mov b, [d]
1993   0EDB             ; START RELATIONAL
1994   0EDB D7            push a
1995   0EDC 11            mov a, b
1996   0EDD 26 00 00      mov b, $0
1997   0EE0 B0            cmp a, b
1998   0EE1 FD 7F         sgt ; >
1999   0EE3 E4            pop a
2000   0EE4             ; END RELATIONAL
2001   0EE4 C0 00 00      cmp b, 0
2002   0EE7 C6 10 0F      je _while32_exit
2003   0EEA             _while32_block:
2004   0EEA             ;; i--; 
2005   0EEA FA FA FF      lea d, [bp + -6] ; $i
2006   0EED 2A            mov b, [d]
2007   0EEE D8            push b
2008   0EEF FD 7D         dec b
2009   0EF1 FA FA FF      lea d, [bp + -6] ; $i
2010   0EF4 FD 43         mov [d], b
2011   0EF6 E5            pop b
2012   0EF7             ;; putchar(digits[i]); 
2013   0EF7 FA FC FF      lea d, [bp + -4] ; $digits
2014   0EFA D7            push a
2015   0EFB DA            push d
2016   0EFC FA FA FF      lea d, [bp + -6] ; $i
2017   0EFF 2A            mov b, [d]
2018   0F00 E7            pop d
2019   0F01 5A            add d, b
2020   0F02 E4            pop a
2021   0F03 32            mov bl, [d]
2022   0F04 A7 00         mov bh, 0
2023   0F06 DD            push bl
2024   0F07 07 32 0F      call putchar
2025   0F0A 51 01 00      add sp, 1
2026   0F0D 0A D7 0E      jmp _while32_cond
2027   0F10             _while32_exit:
2028   0F10 F9            leave
2029   0F11 09            ret
2030   0F12             
2031   0F12             rand:
2032   0F12 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2033   0F15             ; $sec 
2034   0F15 52 01 00      sub sp, 1
2035   0F18             
2036   0F18             ; --- BEGIN INLINE ASM BLOCK
2037   0F18 19 00         mov al, 0
2038   0F1A 05 01         syscall sys_rtc					
2039   0F1C 1A            mov al, ah
2040   0F1D FA 00 00      lea d, [bp + 0] ; $sec
2041   0F20 1E            mov al, [d]
2042   0F21             ; --- END INLINE ASM BLOCK
2043   0F21             
2044   0F21             ;; return sec; 
2045   0F21 FA 00 00      lea d, [bp + 0] ; $sec
2046   0F24 32            mov bl, [d]
2047   0F25 A7 00         mov bh, 0
2048   0F27 F9            leave
2049   0F28 09            ret
2050   0F29             
2051   0F29             date:
2052   0F29 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2053   0F2C             
2054   0F2C             ; --- BEGIN INLINE ASM BLOCK
2055   0F2C 19 00         mov al, 0 
2056   0F2E 05 07         syscall sys_datetime
2057   0F30             ; --- END INLINE ASM BLOCK
2058   0F30             
2059   0F30 F9            leave
2060   0F31 09            ret
2061   0F32             
2062   0F32             putchar:
2063   0F32 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2064   0F35             
2065   0F35             ; --- BEGIN INLINE ASM BLOCK
2066   0F35 FA 05 00      lea d, [bp + 5] ; $c
2067   0F38 1E            mov al, [d]
2068   0F39 23            mov ah, al
2069   0F3A 07 AF 11      call _putchar
2070   0F3D             ; --- END INLINE ASM BLOCK
2071   0F3D             
2072   0F3D F9            leave
2073   0F3E 09            ret
2074   0F3F             
2075   0F3F             getchar:
2076   0F3F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2077   0F42             ; $c 
2078   0F42 52 01 00      sub sp, 1
2079   0F45             
2080   0F45             ; --- BEGIN INLINE ASM BLOCK
2081   0F45 07 A8 11      call getch
2082   0F48 1A            mov al, ah
2083   0F49 FA 00 00      lea d, [bp + 0] ; $c
2084   0F4C 3E            mov [d], al
2085   0F4D             ; --- END INLINE ASM BLOCK
2086   0F4D             
2087   0F4D             ;; return c; 
2088   0F4D FA 00 00      lea d, [bp + 0] ; $c
2089   0F50 32            mov bl, [d]
2090   0F51 A7 00         mov bh, 0
2091   0F53 F9            leave
2092   0F54 09            ret
2093   0F55             
2094   0F55             scann:
2095   0F55 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2096   0F58             ; $m 
2097   0F58 52 02 00      sub sp, 2
2098   0F5B             
2099   0F5B             ; --- BEGIN INLINE ASM BLOCK
2100   0F5B 07 F3 13      call scan_u16d
2101   0F5E FA FF FF      lea d, [bp + -1] ; $m
2102   0F61 43            mov [d], a
2103   0F62             ; --- END INLINE ASM BLOCK
2104   0F62             
2105   0F62             ;; return m; 
2106   0F62 FA FF FF      lea d, [bp + -1] ; $m
2107   0F65 2A            mov b, [d]
2108   0F66 F9            leave
2109   0F67 09            ret
2110   0F68             
2111   0F68             puts:
2112   0F68 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2113   0F6B             
2114   0F6B             ; --- BEGIN INLINE ASM BLOCK
2115   0F6B FA 05 00      lea d, [bp + 5] ; $s
2116   0F6E 15            mov a, [d]
2117   0F6F 3C            mov d, a
2118   0F70 07 F9 12      call _puts
2119   0F73 10 00 0A      mov a, $0A00
2120   0F76 05 03         syscall sys_io
2121   0F78             ; --- END INLINE ASM BLOCK
2122   0F78             
2123   0F78 F9            leave
2124   0F79 09            ret
2125   0F7A             
2126   0F7A             print:
2127   0F7A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2128   0F7D             
2129   0F7D             ; --- BEGIN INLINE ASM BLOCK
2130   0F7D FA 05 00      lea d, [bp + 5] ; $s
2131   0F80 FD 2A         mov d, [d]
2132   0F82 07 F9 12      call _puts
2133   0F85             ; --- END INLINE ASM BLOCK
2134   0F85             
2135   0F85 F9            leave
2136   0F86 09            ret
2137   0F87             
2138   0F87             loadfile:
2139   0F87 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2140   0F8A             
2141   0F8A             ; --- BEGIN INLINE ASM BLOCK
2142   0F8A FA 07 00      lea d, [bp + 7] ; $destination
2143   0F8D 15            mov a, [d]
2144   0F8E 4F            mov di, a
2145   0F8F FA 05 00      lea d, [bp + 5] ; $filename
2146   0F92 FD 2A         mov d, [d]
2147   0F94 19 14         mov al, 20
2148   0F96 05 04         syscall sys_filesystem
2149   0F98             ; --- END INLINE ASM BLOCK
2150   0F98             
2151   0F98 F9            leave
2152   0F99 09            ret
2153   0F9A             
2154   0F9A             create_file:
2155   0F9A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2156   0F9D F9            leave
2157   0F9E 09            ret
2158   0F9F             
2159   0F9F             delete_file:
2160   0F9F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2161   0FA2             
2162   0FA2             ; --- BEGIN INLINE ASM BLOCK
2163   0FA2 FA 05 00      lea d, [bp + 5] ; $filename
2164   0FA5 19 0A         mov al, 10
2165   0FA7 05 04         syscall sys_filesystem
2166   0FA9             ; --- END INLINE ASM BLOCK
2167   0FA9             
2168   0FA9 F9            leave
2169   0FAA 09            ret
2170   0FAB             
2171   0FAB             fopen:
2172   0FAB F8 00 00      enter 0 ; (push bp; mov bp, sp)
2173   0FAE F9            leave
2174   0FAF 09            ret
2175   0FB0             
2176   0FB0             fclose:
2177   0FB0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2178   0FB3 F9            leave
2179   0FB4 09            ret
2180   0FB5             
2181   0FB5             alloc:
2182   0FB5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2183   0FB8             ;; heap_top = heap_top + bytes; 
2184   0FB8 3B F5 18      mov d, _heap_top ; $heap_top
2185   0FBB DA            push d
2186   0FBC 3B F5 18      mov d, _heap_top ; $heap_top
2187   0FBF 2A            mov b, [d]
2188   0FC0             ; START TERMS
2189   0FC0 D7            push a
2190   0FC1 11            mov a, b
2191   0FC2 FA 05 00      lea d, [bp + 5] ; $bytes
2192   0FC5 2A            mov b, [d]
2193   0FC6 54            add a, b
2194   0FC7 27            mov b, a
2195   0FC8 E4            pop a
2196   0FC9             ; END TERMS
2197   0FC9 E7            pop d
2198   0FCA FD 43         mov [d], b
2199   0FCC             ;; return heap_top - bytes; 
2200   0FCC 3B F5 18      mov d, _heap_top ; $heap_top
2201   0FCF 2A            mov b, [d]
2202   0FD0             ; START TERMS
2203   0FD0 D7            push a
2204   0FD1 11            mov a, b
2205   0FD2 FA 05 00      lea d, [bp + 5] ; $bytes
2206   0FD5 2A            mov b, [d]
2207   0FD6 60            sub a, b
2208   0FD7 27            mov b, a
2209   0FD8 E4            pop a
2210   0FD9             ; END TERMS
2211   0FD9 F9            leave
2212   0FDA 09            ret
2213   0FDB             
2214   0FDB             free:
2215   0FDB F8 00 00      enter 0 ; (push bp; mov bp, sp)
2216   0FDE             ;; return heap_top = heap_top - bytes; 
2217   0FDE 3B F5 18      mov d, _heap_top ; $heap_top
2218   0FE1 DA            push d
2219   0FE2 3B F5 18      mov d, _heap_top ; $heap_top
2220   0FE5 2A            mov b, [d]
2221   0FE6             ; START TERMS
2222   0FE6 D7            push a
2223   0FE7 11            mov a, b
2224   0FE8 FA 05 00      lea d, [bp + 5] ; $bytes
2225   0FEB 2A            mov b, [d]
2226   0FEC 60            sub a, b
2227   0FED 27            mov b, a
2228   0FEE E4            pop a
2229   0FEF             ; END TERMS
2230   0FEF E7            pop d
2231   0FF0 FD 43         mov [d], b
2232   0FF2 F9            leave
2233   0FF3 09            ret
2234   0FF4             
2235   0FF4             exit:
2236   0FF4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2237   0FF7             
2238   0FF7             ; --- BEGIN INLINE ASM BLOCK
2239   0FF7 05 0B         syscall sys_terminate_proc
2240   0FF9             ; --- END INLINE ASM BLOCK
2241   0FF9             
2242   0FF9 F9            leave
2243   0FFA 09            ret
2244   0FFB             
2245   0FFB             load_hex:
2246   0FFB F8 00 00      enter 0 ; (push bp; mov bp, sp)
2247   0FFE             ; $temp 
2248   0FFE 52 02 00      sub sp, 2
2249   1001             ;; temp = alloc(32768); 
2250   1001 FA FF FF      lea d, [bp + -1] ; $temp
2251   1004 DA            push d
2252   1005 26 00 80      mov b, $8000
2253   1008 FD AB         swp b
2254   100A D8            push b
2255   100B 07 B5 0F      call alloc
2256   100E 51 02 00      add sp, 2
2257   1011 E7            pop d
2258   1012 FD 43         mov [d], b
2259   1014             
2260   1014             ; --- BEGIN INLINE ASM BLOCK
2261   1014               
2262   1014               
2263   1014               
2264   1014               
2265   1014               
2266   1014             _load_hex:
2267   1014 D7            push a
2268   1015 D8            push b
2269   1016 DA            push d
2270   1017 E2            push si
2271   1018 E3            push di
2272   1019 52 00 80      sub sp, $8000      
2273   101C 38 00 00      mov c, 0
2274   101F 48            mov a, sp
2275   1020 77            inc a
2276   1021 3C            mov d, a          
2277   1022 07 B6 11      call _gets        
2278   1025 4D            mov si, a
2279   1026             __load_hex_loop:
2280   1026 F6            lodsb             
2281   1027 B9 00         cmp al, 0         
2282   1029 C6 37 10      jz __load_hex_ret
2283   102C 36            mov bh, al
2284   102D F6            lodsb
2285   102E 2F            mov bl, al
2286   102F 07 6C 11      call _atoi        
2287   1032 F7            stosb             
2288   1033 78            inc c
2289   1034 0A 26 10      jmp __load_hex_loop
2290   1037             __load_hex_ret:
2291   1037 51 00 80      add sp, $8000
2292   103A F0            pop di
2293   103B EF            pop si
2294   103C E7            pop d
2295   103D E5            pop b
2296   103E E4            pop a
2297   103F             ; --- END INLINE ASM BLOCK
2298   103F             
2299   103F F9            leave
2300   1040 09            ret
2301   1041             
2302   1041             getparam:
2303   1041 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2304   1044             ; $data 
2305   1044 52 01 00      sub sp, 1
2306   1047             
2307   1047             ; --- BEGIN INLINE ASM BLOCK
2308   1047 19 04         mov al, 4
2309   1049 FA 05 00      lea d, [bp + 5] ; $address
2310   104C FD 2A         mov d, [d]
2311   104E 05 0C         syscall sys_system
2312   1050 FA 00 00      lea d, [bp + 0] ; $data
2313   1053 FD 3E         mov [d], bl
2314   1055             ; --- END INLINE ASM BLOCK
2315   1055             
2316   1055             ;; return data; 
2317   1055 FA 00 00      lea d, [bp + 0] ; $data
2318   1058 32            mov bl, [d]
2319   1059 A7 00         mov bh, 0
2320   105B F9            leave
2321   105C 09            ret
2322   105D             
2323   105D             clear:
2324   105D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2325   1060             ;; print("\033[2J\033[H"); 
2326   1060 26 ED 18      mov b, __s5 ; "\033[2J\033[H"
2327   1063 FD AB         swp b
2328   1065 D8            push b
2329   1066 07 7A 0F      call print
2330   1069 51 02 00      add sp, 2
2331   106C F9            leave
2332   106D 09            ret
2333   106E             
2334   106E             printun:
2335   106E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2336   1071             ;; print(prompt); 
2337   1071 FA 05 00      lea d, [bp + 5] ; $prompt
2338   1074 2A            mov b, [d]
2339   1075 FD AB         swp b
2340   1077 D8            push b
2341   1078 07 7A 0F      call print
2342   107B 51 02 00      add sp, 2
2343   107E             ;; print_unsigned(n); 
2344   107E FA 07 00      lea d, [bp + 7] ; $n
2345   1081 2A            mov b, [d]
2346   1082 FD AB         swp b
2347   1084 D8            push b
2348   1085 07 4A 0E      call print_unsigned
2349   1088 51 02 00      add sp, 2
2350   108B             ;; print("\n"); 
2351   108B 26 AF 18      mov b, __s2 ; "\n"
2352   108E FD AB         swp b
2353   1090 D8            push b
2354   1091 07 7A 0F      call print
2355   1094 51 02 00      add sp, 2
2356   1097 F9            leave
2357   1098 09            ret
2358   1099             
2359   1099             printsn:
2360   1099 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2361   109C             ;; print(prompt); 
2362   109C FA 05 00      lea d, [bp + 5] ; $prompt
2363   109F 2A            mov b, [d]
2364   10A0 FD AB         swp b
2365   10A2 D8            push b
2366   10A3 07 7A 0F      call print
2367   10A6 51 02 00      add sp, 2
2368   10A9             ;; print_signed(n); 
2369   10A9 FA 07 00      lea d, [bp + 7] ; $n
2370   10AC 2A            mov b, [d]
2371   10AD FD AB         swp b
2372   10AF D8            push b
2373   10B0 07 2D 0B      call print_signed
2374   10B3 51 02 00      add sp, 2
2375   10B6             ;; print("\n"); 
2376   10B6 26 AF 18      mov b, __s2 ; "\n"
2377   10B9 FD AB         swp b
2378   10BB D8            push b
2379   10BC 07 7A 0F      call print
2380   10BF 51 02 00      add sp, 2
2381   10C2 F9            leave
2382   10C3 09            ret
2383   10C4             
2384   10C4             include_stdio_asm:
2385   10C4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2386   10C7             
2387   10C7             ; --- BEGIN INLINE ASM BLOCK
2388   10C7             .include "lib/asm/stdio.asm"
0001+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  10C7             ; stdio.s
0003+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  10C7             .include "lib/asm/string.asm"
0001++ 10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 10C7             ; string.s
0003++ 10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 10C7             
0005++ 10C7             
0006++ 10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 10C7             ; _strrev
0008++ 10C7             ; reverse a string
0009++ 10C7             ; D = string address
0010++ 10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 10C7             ; 01234
0012++ 10C7             _strrev:
0013++ 10C7 4B          	pusha
0014++ 10C8 07 0E 11    	call _strlen	; length in C
0015++ 10CB 12          	mov a, c
0016++ 10CC AF 01 00    	cmp a, 1
0017++ 10CF D0 E9 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 10D2 7D          	dec a
0019++ 10D3 FD 4E       	mov si, d	; beginning of string
0020++ 10D5 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 10D7 59          	add d, a	; end of string
0022++ 10D8 12          	mov a, c
0023++ 10D9 FD 9B       	shr a		; divide by 2
0024++ 10DB 39          	mov c, a	; C now counts the steps
0025++ 10DC             _strrev_L0:
0026++ 10DC 32          	mov bl, [d]	; save load right-side char into BL
0027++ 10DD F6          	lodsb		; load left-side char into AL; increase SI
0028++ 10DE 3E          	mov [d], al	; store left char into right side
0029++ 10DF 1B          	mov al, bl
0030++ 10E0 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 10E1 7E          	dec c
0032++ 10E2 7F          	dec d
0033++ 10E3 C2 00 00    	cmp c, 0
0034++ 10E6 C7 DC 10    	jne _strrev_L0
0035++ 10E9             _strrev_end:
0036++ 10E9 4C          	popa
0037++ 10EA 09          	ret
0038++ 10EB             	
0039++ 10EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10EB             ; _strchr
0041++ 10EB             ; search string in D for char in AL
0042++ 10EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10EB             _strchr:
0044++ 10EB             _strchr_L0:
0045++ 10EB 32          	mov bl, [d]
0046++ 10EC C1 00       	cmp bl, 0
0047++ 10EE C6 F9 10    	je _strchr_end
0048++ 10F1 BA          	cmp al, bl
0049++ 10F2 C6 F9 10    	je _strchr_end
0050++ 10F5 79          	inc d
0051++ 10F6 0A EB 10    	jmp _strchr_L0
0052++ 10F9             _strchr_end:
0053++ 10F9 1B          	mov al, bl
0054++ 10FA 09          	ret
0055++ 10FB             
0056++ 10FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10FB             ; _strstr
0058++ 10FB             ; find sub-string
0059++ 10FB             ; str1 in SI
0060++ 10FB             ; str2 in DI
0061++ 10FB             ; SI points to end of source string
0062++ 10FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10FB             _strstr:
0064++ 10FB DB          	push al
0065++ 10FC DA          	push d
0066++ 10FD E3          	push di
0067++ 10FE             _strstr_loop:
0068++ 10FE F3          	cmpsb					; compare a byte of the strings
0069++ 10FF C7 0A 11    	jne _strstr_ret
0070++ 1102 FC 00 00    	lea d, [di + 0]
0071++ 1105 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1107 C7 FE 10    	jne _strstr_loop				; equal chars but not at end
0073++ 110A             _strstr_ret:
0074++ 110A F0          	pop di
0075++ 110B E7          	pop d
0076++ 110C E8          	pop al
0077++ 110D 09          	ret
0078++ 110E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 110E             ; length of null terminated string
0080++ 110E             ; result in C
0081++ 110E             ; pointer in D
0082++ 110E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 110E             _strlen:
0084++ 110E DA          	push d
0085++ 110F 38 00 00    	mov c, 0
0086++ 1112             _strlen_L1:
0087++ 1112 BD 00       	cmp byte [d], 0
0088++ 1114 C6 1C 11    	je _strlen_ret
0089++ 1117 79          	inc d
0090++ 1118 78          	inc c
0091++ 1119 0A 12 11    	jmp _strlen_L1
0092++ 111C             _strlen_ret:
0093++ 111C E7          	pop d
0094++ 111D 09          	ret
0095++ 111E             
0096++ 111E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 111E             ; STRCMP
0098++ 111E             ; compare two strings
0099++ 111E             ; str1 in SI
0100++ 111E             ; str2 in DI
0101++ 111E             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 111E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 111E             _strcmp:
0104++ 111E DB          	push al
0105++ 111F DA          	push d
0106++ 1120 E3          	push di
0107++ 1121 E2          	push si
0108++ 1122             _strcmp_loop:
0109++ 1122 F3          	cmpsb					; compare a byte of the strings
0110++ 1123 C7 2E 11    	jne _strcmp_ret
0111++ 1126 FB FF FF    	lea d, [si +- 1]
0112++ 1129 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 112B C7 22 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 112E             _strcmp_ret:
0115++ 112E EF          	pop si
0116++ 112F F0          	pop di
0117++ 1130 E7          	pop d
0118++ 1131 E8          	pop al
0119++ 1132 09          	ret
0120++ 1133             
0121++ 1133             
0122++ 1133             ; STRCPY
0123++ 1133             ; copy null terminated string from SI to DI
0124++ 1133             ; source in SI
0125++ 1133             ; destination in DI
0126++ 1133             _strcpy:
0127++ 1133 E2          	push si
0128++ 1134 E3          	push di
0129++ 1135 DB          	push al
0130++ 1136             _strcpy_L1:
0131++ 1136 F6          	lodsb
0132++ 1137 F7          	stosb
0133++ 1138 B9 00       	cmp al, 0
0134++ 113A C7 36 11    	jne _strcpy_L1
0135++ 113D             _strcpy_end:
0136++ 113D E8          	pop al
0137++ 113E F0          	pop di
0138++ 113F EF          	pop si
0139++ 1140 09          	ret
0140++ 1141             
0141++ 1141             ; STRCAT
0142++ 1141             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1141             ; source in SI
0144++ 1141             ; destination in DI
0145++ 1141             _strcat:
0146++ 1141 E2          	push si
0147++ 1142 E3          	push di
0148++ 1143 D7          	push a
0149++ 1144 DA          	push d
0150++ 1145 50          	mov a, di
0151++ 1146 3C          	mov d, a
0152++ 1147             _strcat_goto_end_L1:
0153++ 1147 BD 00       	cmp byte[d], 0
0154++ 1149 C6 50 11    	je _strcat_start
0155++ 114C 79          	inc d
0156++ 114D 0A 47 11    	jmp _strcat_goto_end_L1
0157++ 1150             _strcat_start:
0158++ 1150 FD 50       	mov di, d
0159++ 1152             _strcat_L1:
0160++ 1152 F6          	lodsb
0161++ 1153 F7          	stosb
0162++ 1154 B9 00       	cmp al, 0
0163++ 1156 C7 52 11    	jne _strcat_L1
0164++ 1159             _strcat_end:
0165++ 1159 E7          	pop d
0166++ 115A E4          	pop a
0167++ 115B F0          	pop di
0168++ 115C EF          	pop si
0169++ 115D 09          	ret
0170++ 115E             
0171++ 115E             
0005+  115E             
0006+  115E             
0007+  115E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  115E             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  115E             ; ASCII in BL
0010+  115E             ; result in AL
0011+  115E             ; ascii for F = 0100 0110
0012+  115E             ; ascii for 9 = 0011 1001
0013+  115E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  115E             hex_ascii_encode:
0015+  115E 1B            mov al, bl
0016+  115F 93 40         test al, $40        ; test if letter or number
0017+  1161 C7 67 11      jnz hex_letter
0018+  1164 87 0F         and al, $0F        ; get number
0019+  1166 09            ret
0020+  1167             hex_letter:
0021+  1167 87 0F         and al, $0F        ; get letter
0022+  1169 6A 09         add al, 9
0023+  116B 09            ret
0024+  116C             
0025+  116C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  116C             ; ATOI
0027+  116C             ; 2 letter hex string in B
0028+  116C             ; 8bit integer returned in AL
0029+  116C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  116C             _atoi:
0031+  116C D8            push b
0032+  116D 07 5E 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  1170 30            mov bl, bh
0034+  1171 DB            push al          ; save a
0035+  1172 07 5E 11      call hex_ascii_encode
0036+  1175 EA            pop bl  
0037+  1176 FD 9E 04      shl al, 4
0038+  1179 8C            or al, bl
0039+  117A E5            pop b
0040+  117B 09            ret  
0041+  117C             
0042+  117C             
0043+  117C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  117C             ; scanf
0045+  117C             ; no need for explanations!
0046+  117C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  117C             scanf:
0048+  117C 09            ret
0049+  117D             
0050+  117D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  117D             ; ITOA
0052+  117D             ; 8bit value in BL
0053+  117D             ; 2 byte ASCII result in A
0054+  117D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  117D             _itoa:
0056+  117D DA            push d
0057+  117E D8            push b
0058+  117F A7 00         mov bh, 0
0059+  1181 FD A4 04      shr bl, 4  
0060+  1184 74            mov d, b
0061+  1185 1F 2D 14      mov al, [d + s_hex_digits]
0062+  1188 23            mov ah, al
0063+  1189               
0064+  1189 E5            pop b
0065+  118A D8            push b
0066+  118B A7 00         mov bh, 0
0067+  118D FD 87 0F      and bl, $0F
0068+  1190 74            mov d, b
0069+  1191 1F 2D 14      mov al, [d + s_hex_digits]
0070+  1194 E5            pop b
0071+  1195 E7            pop d
0072+  1196 09            ret
0073+  1197             
0074+  1197             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1197             ; HEX STRING TO BINARY
0076+  1197             ; di = destination address
0077+  1197             ; si = source
0078+  1197             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1197             _hex_to_int:
0080+  1197             _hex_to_int_L1:
0081+  1197 F6            lodsb          ; load from [SI] to AL
0082+  1198 B9 00         cmp al, 0        ; check if ASCII 0
0083+  119A C6 A7 11      jz _hex_to_int_ret
0084+  119D 36            mov bh, al
0085+  119E F6            lodsb
0086+  119F 2F            mov bl, al
0087+  11A0 07 6C 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  11A3 F7            stosb          ; store AL to [DI]
0089+  11A4 0A 97 11      jmp _hex_to_int_L1
0090+  11A7             _hex_to_int_ret:
0091+  11A7 09            ret    
0092+  11A8             
0093+  11A8             
0094+  11A8             
0095+  11A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  11A8             ; GETCHAR
0097+  11A8             ; char in ah
0098+  11A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  11A8             getch:
0100+  11A8 DB            push al
0101+  11A9             getch_retry:
0102+  11A9 19 01         mov al, 1
0103+  11AB 05 03         syscall sys_io      ; receive in AH
0104+  11AD E8            pop al
0105+  11AE 09            ret
0106+  11AF             
0107+  11AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  11AF             ; PUTCHAR
0109+  11AF             ; char in ah
0110+  11AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  11AF             _putchar:
0112+  11AF D7            push a
0113+  11B0 19 00         mov al, 0
0114+  11B2 05 03         syscall sys_io      ; char in AH
0115+  11B4 E4            pop a
0116+  11B5 09            ret
0117+  11B6             
0118+  11B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  11B6             ;; INPUT A STRING
0120+  11B6             ;; terminates with null
0121+  11B6             ;; pointer in D
0122+  11B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  11B6             _gets:
0124+  11B6 D7            push a
0125+  11B7 DA            push d
0126+  11B8             _gets_loop:
0127+  11B8 19 01         mov al, 1
0128+  11BA 05 03         syscall sys_io      ; receive in AH
0129+  11BC B9 00         cmp al, 0        ; check error code (AL)
0130+  11BE C6 B8 11      je _gets_loop      ; if no char received, retry
0131+  11C1             
0132+  11C1 76 1B         cmp ah, 27
0133+  11C3 C6 E4 11      je _gets_ansi_esc
0134+  11C6 76 0A         cmp ah, $0A        ; LF
0135+  11C8 C6 4F 12      je _gets_end
0136+  11CB 76 0D         cmp ah, $0D        ; CR
0137+  11CD C6 4F 12      je _gets_end
0138+  11D0 76 5C         cmp ah, $5C        ; '\\'
0139+  11D2 C6 10 12      je _gets_escape
0140+  11D5               
0141+  11D5 76 08         cmp ah, $08      ; check for backspace
0142+  11D7 C6 E0 11      je _gets_backspace
0143+  11DA             
0144+  11DA 1A            mov al, ah
0145+  11DB 3E            mov [d], al
0146+  11DC 79            inc d
0147+  11DD 0A B8 11      jmp _gets_loop
0148+  11E0             _gets_backspace:
0149+  11E0 7F            dec d
0150+  11E1 0A B8 11      jmp _gets_loop
0151+  11E4             _gets_ansi_esc:
0152+  11E4 19 01         mov al, 1
0153+  11E6 05 03         syscall sys_io        ; receive in AH without echo
0154+  11E8 B9 00         cmp al, 0          ; check error code (AL)
0155+  11EA C6 E4 11      je _gets_ansi_esc    ; if no char received, retry
0156+  11ED 76 5B         cmp ah, '['
0157+  11EF C7 B8 11      jne _gets_loop
0158+  11F2             _gets_ansi_esc_2:
0159+  11F2 19 01         mov al, 1
0160+  11F4 05 03         syscall sys_io          ; receive in AH without echo
0161+  11F6 B9 00         cmp al, 0            ; check error code (AL)
0162+  11F8 C6 F2 11      je _gets_ansi_esc_2  ; if no char received, retry
0163+  11FB 76 44         cmp ah, 'D'
0164+  11FD C6 08 12      je _gets_left_arrow
0165+  1200 76 43         cmp ah, 'C'
0166+  1202 C6 0C 12      je _gets_right_arrow
0167+  1205 0A B8 11      jmp _gets_loop
0168+  1208             _gets_left_arrow:
0169+  1208 7F            dec d
0170+  1209 0A B8 11      jmp _gets_loop
0171+  120C             _gets_right_arrow:
0172+  120C 79            inc d
0173+  120D 0A B8 11      jmp _gets_loop
0174+  1210             _gets_escape:
0175+  1210 19 01         mov al, 1
0176+  1212 05 03         syscall sys_io      ; receive in AH
0177+  1214 B9 00         cmp al, 0        ; check error code (AL)
0178+  1216 C6 10 12      je _gets_escape      ; if no char received, retry
0179+  1219 76 6E         cmp ah, 'n'
0180+  121B C6 3A 12      je _gets_LF
0181+  121E 76 72         cmp ah, 'r'
0182+  1220 C6 41 12      je _gets_CR
0183+  1223 76 30         cmp ah, '0'
0184+  1225 C6 48 12      je _gets_NULL
0185+  1228 76 5C         cmp ah, $5C  ; '\'
0186+  122A C6 33 12      je _gets_slash
0187+  122D 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  122E 3E            mov [d], al
0189+  122F 79            inc d
0190+  1230 0A B8 11      jmp _gets_loop
0191+  1233             _gets_slash:
0192+  1233 19 5C         mov al, $5C
0193+  1235 3E            mov [d], al
0194+  1236 79            inc d
0195+  1237 0A B8 11      jmp _gets_loop
0196+  123A             _gets_LF:
0197+  123A 19 0A         mov al, $0A
0198+  123C 3E            mov [d], al
0199+  123D 79            inc d
0200+  123E 0A B8 11      jmp _gets_loop
0201+  1241             _gets_CR:
0202+  1241 19 0D         mov al, $0D
0203+  1243 3E            mov [d], al
0204+  1244 79            inc d
0205+  1245 0A B8 11      jmp _gets_loop
0206+  1248             _gets_NULL:
0207+  1248 19 00         mov al, $00
0208+  124A 3E            mov [d], al
0209+  124B 79            inc d
0210+  124C 0A B8 11      jmp _gets_loop
0211+  124F             _gets_end:
0212+  124F 19 00         mov al, 0
0213+  1251 3E            mov [d], al        ; terminate string
0214+  1252 E7            pop d
0215+  1253 E4            pop a
0216+  1254 09            ret
0217+  1255             
0218+  1255             
0219+  1255             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  1255             ;; INPUT TEXT
0221+  1255             ;; terminated with CTRL+D
0222+  1255             ;; pointer in D
0223+  1255             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  1255             _gettxt:
0225+  1255 D7            push a
0226+  1256 DA            push d
0227+  1257             _gettxt_loop:
0228+  1257 19 01         mov al, 1
0229+  1259 05 03         syscall sys_io      ; receive in AH
0230+  125B B9 00         cmp al, 0        ; check error code (AL)
0231+  125D C6 57 12      je _gettxt_loop    ; if no char received, retry
0232+  1260 76 04         cmp ah, 4      ; EOT
0233+  1262 C6 A0 12      je _gettxt_end
0234+  1265 76 08         cmp ah, $08      ; check for backspace
0235+  1267 C6 9C 12      je _gettxt_backspace
0236+  126A 76 5C         cmp ah, $5C        ; '\'
0237+  126C C6 75 12      je _gettxt_escape
0238+  126F 1A            mov al, ah
0239+  1270 3E            mov [d], al
0240+  1271 79            inc d
0241+  1272 0A 57 12      jmp _gettxt_loop
0242+  1275             _gettxt_escape:
0243+  1275 19 01         mov al, 1
0244+  1277 05 03         syscall sys_io      ; receive in AH
0245+  1279 B9 00         cmp al, 0        ; check error code (AL)
0246+  127B C6 75 12      je _gettxt_escape    ; if no char received, retry
0247+  127E 76 6E         cmp ah, 'n'
0248+  1280 C6 8E 12      je _gettxt_LF
0249+  1283 76 72         cmp ah, 'r'
0250+  1285 C6 95 12      je _gettxt_CR
0251+  1288 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  1289 3E            mov [d], al
0253+  128A 79            inc d
0254+  128B 0A 57 12      jmp _gettxt_loop
0255+  128E             _gettxt_LF:
0256+  128E 19 0A         mov al, $0A
0257+  1290 3E            mov [d], al
0258+  1291 79            inc d
0259+  1292 0A 57 12      jmp _gettxt_loop
0260+  1295             _gettxt_CR:
0261+  1295 19 0D         mov al, $0D
0262+  1297 3E            mov [d], al
0263+  1298 79            inc d
0264+  1299 0A 57 12      jmp _gettxt_loop
0265+  129C             _gettxt_backspace:
0266+  129C 7F            dec d
0267+  129D 0A 57 12      jmp _gettxt_loop
0268+  12A0             _gettxt_end:
0269+  12A0 19 00         mov al, 0
0270+  12A2 3E            mov [d], al        ; terminate string
0271+  12A3 E7            pop d
0272+  12A4 E4            pop a
0273+  12A5 09            ret
0274+  12A6             
0275+  12A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  12A6             ; PRINT NEW LINE
0277+  12A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  12A6             printnl:
0279+  12A6 D7            push a
0280+  12A7 10 00 0A      mov a, $0A00
0281+  12AA 05 03         syscall sys_io
0282+  12AC 10 00 0D      mov a, $0D00
0283+  12AF 05 03         syscall sys_io
0284+  12B1 E4            pop a
0285+  12B2 09            ret
0286+  12B3             
0287+  12B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  12B3             ; _strtoint
0289+  12B3             ; 4 digit hex string number in d
0290+  12B3             ; integer returned in A
0291+  12B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  12B3             _strtointx:
0293+  12B3 D8            push b
0294+  12B4 32            mov bl, [d]
0295+  12B5 37            mov bh, bl
0296+  12B6 33 01 00      mov bl, [d + 1]
0297+  12B9 07 6C 11      call _atoi        ; convert to int in AL
0298+  12BC 23            mov ah, al        ; move to AH
0299+  12BD 33 02 00      mov bl, [d + 2]
0300+  12C0 37            mov bh, bl
0301+  12C1 33 03 00      mov bl, [d + 3]
0302+  12C4 07 6C 11      call _atoi        ; convert to int in AL
0303+  12C7 E5            pop b
0304+  12C8 09            ret
0305+  12C9             
0306+  12C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  12C9             ; _strtoint
0308+  12C9             ; 5 digit base10 string number in d
0309+  12C9             ; integer returned in A
0310+  12C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  12C9             _strtoint:
0312+  12C9 E2            push si
0313+  12CA D8            push b
0314+  12CB D9            push c
0315+  12CC DA            push d
0316+  12CD 07 0E 11      call _strlen      ; get string length in C
0317+  12D0 7E            dec c
0318+  12D1 FD 4E         mov si, d
0319+  12D3 12            mov a, c
0320+  12D4 FD 99         shl a
0321+  12D6 3B 45 14      mov d, table_power
0322+  12D9 59            add d, a
0323+  12DA 38 00 00      mov c, 0
0324+  12DD             _strtoint_L0:
0325+  12DD F6            lodsb      ; load ASCII to al
0326+  12DE B9 00         cmp al, 0
0327+  12E0 C6 F3 12      je _strtoint_end
0328+  12E3 6F 30         sub al, $30    ; make into integer
0329+  12E5 22 00         mov ah, 0
0330+  12E7 2A            mov b, [d]
0331+  12E8 AC            mul a, b      ; result in B since it fits in 16bits
0332+  12E9 11            mov a, b
0333+  12EA 28            mov b, c
0334+  12EB 54            add a, b
0335+  12EC 39            mov c, a
0336+  12ED 63 02 00      sub d, 2
0337+  12F0 0A DD 12      jmp _strtoint_L0
0338+  12F3             _strtoint_end:
0339+  12F3 12            mov a, c
0340+  12F4 E7            pop d
0341+  12F5 E6            pop c
0342+  12F6 E5            pop b
0343+  12F7 EF            pop si
0344+  12F8 09            ret
0345+  12F9             
0346+  12F9             
0347+  12F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  12F9             ; PRINT NULL TERMINATED STRING
0349+  12F9             ; pointer in D
0350+  12F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  12F9             _puts:
0352+  12F9 D7            push a
0353+  12FA DA            push d
0354+  12FB             _puts_L1:
0355+  12FB 1E            mov al, [d]
0356+  12FC B9 00         cmp al, 0
0357+  12FE C6 0A 13      jz _puts_END
0358+  1301 23            mov ah, al
0359+  1302 19 00         mov al, 0
0360+  1304 05 03         syscall sys_io
0361+  1306 79            inc d
0362+  1307 0A FB 12      jmp _puts_L1
0363+  130A             _puts_END:
0364+  130A E7            pop d
0365+  130B E4            pop a
0366+  130C 09            ret
0367+  130D             
0368+  130D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  130D             ; PRINT N SIZE STRING
0370+  130D             ; pointer in D
0371+  130D             ; size in C
0372+  130D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  130D             _putsn:
0374+  130D DB            push al
0375+  130E DA            push d
0376+  130F D9            push c
0377+  1310             _putsn_L0:
0378+  1310 1E            mov al, [d]
0379+  1311 23            mov ah, al
0380+  1312 19 00         mov al, 0
0381+  1314 05 03         syscall sys_io
0382+  1316 79            inc d
0383+  1317 7E            dec c  
0384+  1318 C2 00 00      cmp c, 0
0385+  131B C7 10 13      jne _putsn_L0
0386+  131E             _putsn_end:
0387+  131E E6            pop c
0388+  131F E7            pop d
0389+  1320 E8            pop al
0390+  1321 09            ret
0391+  1322             
0392+  1322             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1322             ; print 16bit decimal number
0394+  1322             ; input number in A
0395+  1322             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1322             print_u16d:
0397+  1322 D7            push a
0398+  1323 D8            push b
0399+  1324 26 10 27      mov b, 10000
0400+  1327 AE            div a, b      ; get 10000's coeff.
0401+  1328 07 4A 13      call print_number
0402+  132B 11            mov a, b
0403+  132C 26 E8 03      mov b, 1000
0404+  132F AE            div a, b      ; get 1000's coeff.
0405+  1330 07 4A 13      call print_number
0406+  1333 11            mov a, b
0407+  1334 26 64 00      mov b, 100
0408+  1337 AE            div a, b
0409+  1338 07 4A 13      call print_number
0410+  133B 11            mov a, b
0411+  133C 26 0A 00      mov b, 10
0412+  133F AE            div a, b
0413+  1340 07 4A 13      call print_number
0414+  1343 1B            mov al, bl      ; 1's coeff in bl
0415+  1344 07 4A 13      call print_number
0416+  1347 E5            pop b
0417+  1348 E4            pop a
0418+  1349 09            ret
0419+  134A             
0420+  134A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  134A             ; print AL
0422+  134A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  134A             print_number:
0424+  134A 6A 30         add al, $30
0425+  134C 23            mov ah, al
0426+  134D 07 AF 11      call _putchar
0427+  1350 09            ret
0428+  1351             
0429+  1351             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1351             ; PRINT 16BIT HEX INTEGER
0431+  1351             ; integer value in reg B
0432+  1351             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1351             print_u16x:
0434+  1351 D7            push a
0435+  1352 D8            push b
0436+  1353 DD            push bl
0437+  1354 30            mov bl, bh
0438+  1355 07 7D 11      call _itoa        ; convert bh to char in A
0439+  1358 2F            mov bl, al        ; save al
0440+  1359 19 00         mov al, 0
0441+  135B 05 03         syscall sys_io        ; display AH
0442+  135D 24            mov ah, bl        ; retrieve al
0443+  135E 19 00         mov al, 0
0444+  1360 05 03         syscall sys_io        ; display AL
0445+  1362             
0446+  1362 EA            pop bl
0447+  1363 07 7D 11      call _itoa        ; convert bh to char in A
0448+  1366 2F            mov bl, al        ; save al
0449+  1367 19 00         mov al, 0
0450+  1369 05 03         syscall sys_io        ; display AH
0451+  136B 24            mov ah, bl        ; retrieve al
0452+  136C 19 00         mov al, 0
0453+  136E 05 03         syscall sys_io        ; display AL
0454+  1370             
0455+  1370 E5            pop b
0456+  1371 E4            pop a
0457+  1372 09            ret
0458+  1373             
0459+  1373             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  1373             ; INPUT 16BIT HEX INTEGER
0461+  1373             ; read 16bit integer into A
0462+  1373             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  1373             scan_u16x:
0464+  1373 F8 10 00      enter 16
0465+  1376 D8            push b
0466+  1377 DA            push d
0467+  1378             
0468+  1378 FA F1 FF      lea d, [bp + -15]
0469+  137B 07 B6 11      call _gets        ; get number
0470+  137E             
0471+  137E 32            mov bl, [d]
0472+  137F 37            mov bh, bl
0473+  1380 33 01 00      mov bl, [d + 1]
0474+  1383 07 6C 11      call _atoi        ; convert to int in AL
0475+  1386 23            mov ah, al        ; move to AH
0476+  1387             
0477+  1387 33 02 00      mov bl, [d + 2]
0478+  138A 37            mov bh, bl
0479+  138B 33 03 00      mov bl, [d + 3]
0480+  138E 07 6C 11      call _atoi        ; convert to int in AL
0481+  1391             
0482+  1391 E7            pop d
0483+  1392 E5            pop b
0484+  1393 F9            leave
0485+  1394 09            ret
0486+  1395             
0487+  1395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  1395             ; PRINT 8bit HEX INTEGER
0489+  1395             ; integer value in reg bl
0490+  1395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  1395             print_u8x:
0492+  1395 D7            push a
0493+  1396 DD            push bl
0494+  1397             
0495+  1397 07 7D 11      call _itoa        ; convert bl to char in A
0496+  139A 2F            mov bl, al        ; save al
0497+  139B 19 00         mov al, 0
0498+  139D 05 03         syscall sys_io        ; display AH
0499+  139F 24            mov ah, bl        ; retrieve al
0500+  13A0 19 00         mov al, 0
0501+  13A2 05 03         syscall sys_io        ; display AL
0502+  13A4             
0503+  13A4 EA            pop bl
0504+  13A5 E4            pop a
0505+  13A6 09            ret
0506+  13A7             
0507+  13A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  13A7             ; print 8bit decimal unsigned number
0509+  13A7             ; input number in AL
0510+  13A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  13A7             print_u8d:
0512+  13A7 D7            push a
0513+  13A8 D8            push b
0514+  13A9             
0515+  13A9 22 00         mov ah, 0
0516+  13AB 26 64 00      mov b, 100
0517+  13AE AE            div a, b
0518+  13AF D8            push b      ; save remainder
0519+  13B0 B9 00         cmp al, 0
0520+  13B2 C6 BC 13      je skip100
0521+  13B5 6A 30         add al, $30
0522+  13B7 23            mov ah, al
0523+  13B8 19 00         mov al, 0
0524+  13BA 05 03         syscall sys_io  ; print coeff
0525+  13BC             skip100:
0526+  13BC E4            pop a
0527+  13BD 22 00         mov ah, 0
0528+  13BF 26 0A 00      mov b, 10
0529+  13C2 AE            div a, b
0530+  13C3 D8            push b      ; save remainder
0531+  13C4 B9 00         cmp al, 0
0532+  13C6 C6 D0 13      je skip10
0533+  13C9 6A 30         add al, $30
0534+  13CB 23            mov ah, al
0535+  13CC 19 00         mov al, 0
0536+  13CE 05 03         syscall sys_io  ; print coeff
0537+  13D0             skip10:
0538+  13D0 E4            pop a
0539+  13D1 1B            mov al, bl
0540+  13D2 6A 30         add al, $30
0541+  13D4 23            mov ah, al
0542+  13D5 19 00         mov al, 0
0543+  13D7 05 03         syscall sys_io  ; print coeff
0544+  13D9 E5            pop b
0545+  13DA E4            pop a
0546+  13DB 09            ret
0547+  13DC             
0548+  13DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  13DC             ; INPUT 8BIT HEX INTEGER
0550+  13DC             ; read 8bit integer into AL
0551+  13DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  13DC             scan_u8x:
0553+  13DC F8 04 00      enter 4
0554+  13DF D8            push b
0555+  13E0 DA            push d
0556+  13E1             
0557+  13E1 FA FD FF      lea d, [bp + -3]
0558+  13E4 07 B6 11      call _gets        ; get number
0559+  13E7             
0560+  13E7 32            mov bl, [d]
0561+  13E8 37            mov bh, bl
0562+  13E9 33 01 00      mov bl, [d + 1]
0563+  13EC 07 6C 11      call _atoi        ; convert to int in AL
0564+  13EF             
0565+  13EF E7            pop d
0566+  13F0 E5            pop b
0567+  13F1 F9            leave
0568+  13F2 09            ret
0569+  13F3             
0570+  13F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  13F3             ; input decimal number
0572+  13F3             ; result in A
0573+  13F3             ; 655'\0'
0574+  13F3             ; low--------high
0575+  13F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  13F3             scan_u16d:
0577+  13F3 F8 08 00      enter 8
0578+  13F6 E2            push si
0579+  13F7 D8            push b
0580+  13F8 D9            push c
0581+  13F9 DA            push d
0582+  13FA FA F9 FF      lea d, [bp +- 7]
0583+  13FD 07 B6 11      call _gets
0584+  1400 07 0E 11      call _strlen      ; get string length in C
0585+  1403 7E            dec c
0586+  1404 FD 4E         mov si, d
0587+  1406 12            mov a, c
0588+  1407 FD 99         shl a
0589+  1409 3B 45 14      mov d, table_power
0590+  140C 59            add d, a
0591+  140D 38 00 00      mov c, 0
0592+  1410             mul_loop:
0593+  1410 F6            lodsb      ; load ASCII to al
0594+  1411 B9 00         cmp al, 0
0595+  1413 C6 26 14      je mul_exit
0596+  1416 6F 30         sub al, $30    ; make into integer
0597+  1418 22 00         mov ah, 0
0598+  141A 2A            mov b, [d]
0599+  141B AC            mul a, b      ; result in B since it fits in 16bits
0600+  141C 11            mov a, b
0601+  141D 28            mov b, c
0602+  141E 54            add a, b
0603+  141F 39            mov c, a
0604+  1420 63 02 00      sub d, 2
0605+  1423 0A 10 14      jmp mul_loop
0606+  1426             mul_exit:
0607+  1426 12            mov a, c
0608+  1427 E7            pop d
0609+  1428 E6            pop c
0610+  1429 E5            pop b
0611+  142A EF            pop si
0612+  142B F9            leave
0613+  142C 09            ret
0614+  142D             
0615+  142D             
0616+  142D 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1431 34 35 36 37 
0616+  1435 38 39 41 42 
0616+  1439 43 44 45 46 
0617+  143D 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1441 1B 5B 48 00 
0618+  1445             
0619+  1445             table_power:
0620+  1445 01 00         .dw 1
0621+  1447 0A 00         .dw 10
0622+  1449 64 00         .dw 100
0623+  144B E8 03         .dw 1000
0624+  144D 10 27         .dw 100002389   144F             ; --- END INLINE ASM BLOCK
2390   144F             
2391   144F F9            leave
2392   1450 09            ret
2393   1451             
2394   1451             base64_encode:
2395   1451 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2396   1454             ; $i 
2397   1454 10 00 00      mov a, $0
2398   1457 45 FF FF      mov [bp + -1], a
2399   145A             ; $j 
2400   145A 10 00 00      mov a, $0
2401   145D 45 FD FF      mov [bp + -3], a
2402   1460             ; $k 
2403   1460             ; $input_len 
2404   1460             ; $input_buffer 
2405   1460             ; $output_buffer 
2406   1460 52 0F 00      sub sp, 15
2407   1463             ;; input_len = strlen(input); 
2408   1463 FA F9 FF      lea d, [bp + -7] ; $input_len
2409   1466 DA            push d
2410   1467 FA 05 00      lea d, [bp + 5] ; $input
2411   146A 2A            mov b, [d]
2412   146B FD AB         swp b
2413   146D D8            push b
2414   146E 07 D5 05      call strlen
2415   1471 51 02 00      add sp, 2
2416   1474 E7            pop d
2417   1475 FD 43         mov [d], b
2418   1477             ;; while (input_len--) { 
2419   1477             _while33_cond:
2420   1477 FA F9 FF      lea d, [bp + -7] ; $input_len
2421   147A 2A            mov b, [d]
2422   147B D8            push b
2423   147C FD 7D         dec b
2424   147E FA F9 FF      lea d, [bp + -7] ; $input_len
2425   1481 FD 43         mov [d], b
2426   1483 E5            pop b
2427   1484 C0 00 00      cmp b, 0
2428   1487 C6 3D 16      je _while33_exit
2429   148A             _while33_block:
2430   148A             ;; input_buffer[i++] = *(input++); 
2431   148A FA F6 FF      lea d, [bp + -10] ; $input_buffer
2432   148D D7            push a
2433   148E DA            push d
2434   148F FA FF FF      lea d, [bp + -1] ; $i
2435   1492 2A            mov b, [d]
2436   1493 D8            push b
2437   1494 FD 77         inc b
2438   1496 FA FF FF      lea d, [bp + -1] ; $i
2439   1499 FD 43         mov [d], b
2440   149B E5            pop b
2441   149C E7            pop d
2442   149D 5A            add d, b
2443   149E E4            pop a
2444   149F DA            push d
2445   14A0 FA 05 00      lea d, [bp + 5] ; $input
2446   14A3 2A            mov b, [d]
2447   14A4 D8            push b
2448   14A5 FD 77         inc b
2449   14A7 FA 05 00      lea d, [bp + 5] ; $input
2450   14AA FD 43         mov [d], b
2451   14AC E5            pop b
2452   14AD 74            mov d, b
2453   14AE 32            mov bl, [d]
2454   14AF A7 00         mov bh, 0
2455   14B1 E7            pop d
2456   14B2 FD 3E         mov [d], bl
2457   14B4             ;; if (i == 3) { 
2458   14B4             _if34_cond:
2459   14B4 FA FF FF      lea d, [bp + -1] ; $i
2460   14B7 2A            mov b, [d]
2461   14B8             ; START RELATIONAL
2462   14B8 D7            push a
2463   14B9 11            mov a, b
2464   14BA 26 03 00      mov b, $3
2465   14BD B0            cmp a, b
2466   14BE FD 71         seq ; ==
2467   14C0 E4            pop a
2468   14C1             ; END RELATIONAL
2469   14C1 C0 00 00      cmp b, 0
2470   14C4 C6 3A 16      je _if34_exit
2471   14C7             _if34_true:
2472   14C7             ;; output_buffer[0] = (input_buffer[0] & 0xFC) >> 2; 
2473   14C7 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2474   14CA D7            push a
2475   14CB DA            push d
2476   14CC 26 00 00      mov b, $0
2477   14CF E7            pop d
2478   14D0 5A            add d, b
2479   14D1 E4            pop a
2480   14D2 DA            push d
2481   14D3 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2482   14D6 D7            push a
2483   14D7 DA            push d
2484   14D8 26 00 00      mov b, $0
2485   14DB E7            pop d
2486   14DC 5A            add d, b
2487   14DD E4            pop a
2488   14DE 32            mov bl, [d]
2489   14DF A7 00         mov bh, 0
2490   14E1 D7            push a
2491   14E2 11            mov a, b
2492   14E3 26 FC 00      mov b, $fc
2493   14E6 86            and a, b ; &
2494   14E7 27            mov b, a
2495   14E8 E4            pop a
2496   14E9             ; START SHIFT
2497   14E9 D7            push a
2498   14EA 11            mov a, b
2499   14EB 26 02 00      mov b, $2
2500   14EE FD 39         mov c, b
2501   14F0 A5            ashr a, cl
2502   14F1 27            mov b, a
2503   14F2 E4            pop a
2504   14F3             ; END SHIFT
2505   14F3 E7            pop d
2506   14F4 FD 3E         mov [d], bl
2507   14F6             ;; output_buffer[1] = ((input_buffer[0] & 0x03) << 4) + ((input_buffer[1] & 0xF0) >> 4); 
2508   14F6 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2509   14F9 D7            push a
2510   14FA DA            push d
2511   14FB 26 01 00      mov b, $1
2512   14FE E7            pop d
2513   14FF 5A            add d, b
2514   1500 E4            pop a
2515   1501 DA            push d
2516   1502 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2517   1505 D7            push a
2518   1506 DA            push d
2519   1507 26 00 00      mov b, $0
2520   150A E7            pop d
2521   150B 5A            add d, b
2522   150C E4            pop a
2523   150D 32            mov bl, [d]
2524   150E A7 00         mov bh, 0
2525   1510 D7            push a
2526   1511 11            mov a, b
2527   1512 26 03 00      mov b, $3
2528   1515 86            and a, b ; &
2529   1516 27            mov b, a
2530   1517 E4            pop a
2531   1518             ; START SHIFT
2532   1518 D7            push a
2533   1519 11            mov a, b
2534   151A 26 04 00      mov b, $4
2535   151D FD 39         mov c, b
2536   151F 9D            shl a, cl
2537   1520 27            mov b, a
2538   1521 E4            pop a
2539   1522             ; END SHIFT
2540   1522             ; START TERMS
2541   1522 D7            push a
2542   1523 11            mov a, b
2543   1524 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2544   1527 D7            push a
2545   1528 DA            push d
2546   1529 26 01 00      mov b, $1
2547   152C E7            pop d
2548   152D 5A            add d, b
2549   152E E4            pop a
2550   152F 32            mov bl, [d]
2551   1530 A7 00         mov bh, 0
2552   1532 D7            push a
2553   1533 11            mov a, b
2554   1534 26 F0 00      mov b, $f0
2555   1537 86            and a, b ; &
2556   1538 27            mov b, a
2557   1539 E4            pop a
2558   153A             ; START SHIFT
2559   153A D7            push a
2560   153B 11            mov a, b
2561   153C 26 04 00      mov b, $4
2562   153F FD 39         mov c, b
2563   1541 A5            ashr a, cl
2564   1542 27            mov b, a
2565   1543 E4            pop a
2566   1544             ; END SHIFT
2567   1544 54            add a, b
2568   1545 27            mov b, a
2569   1546 E4            pop a
2570   1547             ; END TERMS
2571   1547 E7            pop d
2572   1548 FD 3E         mov [d], bl
2573   154A             ;; output_buffer[2] = ((input_buffer[1] & 0x0F) << 2) + ((input_buffer[2] & 0xC0) >> 6); 
2574   154A FA F2 FF      lea d, [bp + -14] ; $output_buffer
2575   154D D7            push a
2576   154E DA            push d
2577   154F 26 02 00      mov b, $2
2578   1552 E7            pop d
2579   1553 5A            add d, b
2580   1554 E4            pop a
2581   1555 DA            push d
2582   1556 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2583   1559 D7            push a
2584   155A DA            push d
2585   155B 26 01 00      mov b, $1
2586   155E E7            pop d
2587   155F 5A            add d, b
2588   1560 E4            pop a
2589   1561 32            mov bl, [d]
2590   1562 A7 00         mov bh, 0
2591   1564 D7            push a
2592   1565 11            mov a, b
2593   1566 26 0F 00      mov b, $f
2594   1569 86            and a, b ; &
2595   156A 27            mov b, a
2596   156B E4            pop a
2597   156C             ; START SHIFT
2598   156C D7            push a
2599   156D 11            mov a, b
2600   156E 26 02 00      mov b, $2
2601   1571 FD 39         mov c, b
2602   1573 9D            shl a, cl
2603   1574 27            mov b, a
2604   1575 E4            pop a
2605   1576             ; END SHIFT
2606   1576             ; START TERMS
2607   1576 D7            push a
2608   1577 11            mov a, b
2609   1578 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2610   157B D7            push a
2611   157C DA            push d
2612   157D 26 02 00      mov b, $2
2613   1580 E7            pop d
2614   1581 5A            add d, b
2615   1582 E4            pop a
2616   1583 32            mov bl, [d]
2617   1584 A7 00         mov bh, 0
2618   1586 D7            push a
2619   1587 11            mov a, b
2620   1588 26 C0 00      mov b, $c0
2621   158B 86            and a, b ; &
2622   158C 27            mov b, a
2623   158D E4            pop a
2624   158E             ; START SHIFT
2625   158E D7            push a
2626   158F 11            mov a, b
2627   1590 26 06 00      mov b, $6
2628   1593 FD 39         mov c, b
2629   1595 A5            ashr a, cl
2630   1596 27            mov b, a
2631   1597 E4            pop a
2632   1598             ; END SHIFT
2633   1598 54            add a, b
2634   1599 27            mov b, a
2635   159A E4            pop a
2636   159B             ; END TERMS
2637   159B E7            pop d
2638   159C FD 3E         mov [d], bl
2639   159E             ;; output_buffer[3] = input_buffer[2] & 0x3F; 
2640   159E FA F2 FF      lea d, [bp + -14] ; $output_buffer
2641   15A1 D7            push a
2642   15A2 DA            push d
2643   15A3 26 03 00      mov b, $3
2644   15A6 E7            pop d
2645   15A7 5A            add d, b
2646   15A8 E4            pop a
2647   15A9 DA            push d
2648   15AA FA F6 FF      lea d, [bp + -10] ; $input_buffer
2649   15AD D7            push a
2650   15AE DA            push d
2651   15AF 26 02 00      mov b, $2
2652   15B2 E7            pop d
2653   15B3 5A            add d, b
2654   15B4 E4            pop a
2655   15B5 32            mov bl, [d]
2656   15B6 A7 00         mov bh, 0
2657   15B8 D7            push a
2658   15B9 11            mov a, b
2659   15BA 26 3F 00      mov b, $3f
2660   15BD 86            and a, b ; &
2661   15BE 27            mov b, a
2662   15BF E4            pop a
2663   15C0 E7            pop d
2664   15C1 FD 3E         mov [d], bl
2665   15C3             ;; for (i = 0; i < 4; i++) { 
2666   15C3             _for35_init:
2667   15C3 FA FF FF      lea d, [bp + -1] ; $i
2668   15C6 DA            push d
2669   15C7 26 00 00      mov b, $0
2670   15CA E7            pop d
2671   15CB FD 43         mov [d], b
2672   15CD             _for35_cond:
2673   15CD FA FF FF      lea d, [bp + -1] ; $i
2674   15D0 2A            mov b, [d]
2675   15D1             ; START RELATIONAL
2676   15D1 D7            push a
2677   15D2 11            mov a, b
2678   15D3 26 04 00      mov b, $4
2679   15D6 B0            cmp a, b
2680   15D7 FD 73         slt ; < 
2681   15D9 E4            pop a
2682   15DA             ; END RELATIONAL
2683   15DA C0 00 00      cmp b, 0
2684   15DD C6 2D 16      je _for35_exit
2685   15E0             _for35_block:
2686   15E0             ;; output[j++] = base64_table[output_buffer[i]]; 
2687   15E0 FA 07 00      lea d, [bp + 7] ; $output
2688   15E3 FD 2A         mov d, [d]
2689   15E5 D7            push a
2690   15E6 DA            push d
2691   15E7 FA FD FF      lea d, [bp + -3] ; $j
2692   15EA 2A            mov b, [d]
2693   15EB D8            push b
2694   15EC FD 77         inc b
2695   15EE FA FD FF      lea d, [bp + -3] ; $j
2696   15F1 FD 43         mov [d], b
2697   15F3 E5            pop b
2698   15F4 E7            pop d
2699   15F5 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2700   15F9 E4            pop a
2701   15FA DA            push d
2702   15FB 3B 70 18      mov d, _base64_table ; $base64_table
2703   15FE FD 2A         mov d, [d]
2704   1600 D7            push a
2705   1601 DA            push d
2706   1602 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2707   1605 D7            push a
2708   1606 DA            push d
2709   1607 FA FF FF      lea d, [bp + -1] ; $i
2710   160A 2A            mov b, [d]
2711   160B E7            pop d
2712   160C 5A            add d, b
2713   160D E4            pop a
2714   160E 32            mov bl, [d]
2715   160F A7 00         mov bh, 0
2716   1611 E7            pop d
2717   1612 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2718   1616 E4            pop a
2719   1617 32            mov bl, [d]
2720   1618 A7 00         mov bh, 0
2721   161A E7            pop d
2722   161B FD 3E         mov [d], bl
2723   161D             _for35_update:
2724   161D FA FF FF      lea d, [bp + -1] ; $i
2725   1620 2A            mov b, [d]
2726   1621 D8            push b
2727   1622 FD 77         inc b
2728   1624 FA FF FF      lea d, [bp + -1] ; $i
2729   1627 FD 43         mov [d], b
2730   1629 E5            pop b
2731   162A 0A CD 15      jmp _for35_cond
2732   162D             _for35_exit:
2733   162D             ;; i = 0; 
2734   162D FA FF FF      lea d, [bp + -1] ; $i
2735   1630 DA            push d
2736   1631 26 00 00      mov b, $0
2737   1634 E7            pop d
2738   1635 FD 43         mov [d], b
2739   1637 0A 3A 16      jmp _if34_exit
2740   163A             _if34_exit:
2741   163A 0A 77 14      jmp _while33_cond
2742   163D             _while33_exit:
2743   163D             ;; if (i) { 
2744   163D             _if36_cond:
2745   163D FA FF FF      lea d, [bp + -1] ; $i
2746   1640 2A            mov b, [d]
2747   1641 C0 00 00      cmp b, 0
2748   1644 C6 15 18      je _if36_exit
2749   1647             _if36_true:
2750   1647             ;; for (k = i; k < 3; k++) { 
2751   1647             _for37_init:
2752   1647 FA FB FF      lea d, [bp + -5] ; $k
2753   164A DA            push d
2754   164B FA FF FF      lea d, [bp + -1] ; $i
2755   164E 2A            mov b, [d]
2756   164F E7            pop d
2757   1650 FD 43         mov [d], b
2758   1652             _for37_cond:
2759   1652 FA FB FF      lea d, [bp + -5] ; $k
2760   1655 2A            mov b, [d]
2761   1656             ; START RELATIONAL
2762   1656 D7            push a
2763   1657 11            mov a, b
2764   1658 26 03 00      mov b, $3
2765   165B B0            cmp a, b
2766   165C FD 73         slt ; < 
2767   165E E4            pop a
2768   165F             ; END RELATIONAL
2769   165F C0 00 00      cmp b, 0
2770   1662 C6 88 16      je _for37_exit
2771   1665             _for37_block:
2772   1665             ;; input_buffer[k] = '\0'; 
2773   1665 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2774   1668 D7            push a
2775   1669 DA            push d
2776   166A FA FB FF      lea d, [bp + -5] ; $k
2777   166D 2A            mov b, [d]
2778   166E E7            pop d
2779   166F 5A            add d, b
2780   1670 E4            pop a
2781   1671 DA            push d
2782   1672 26 00 00      mov b, $0
2783   1675 E7            pop d
2784   1676 FD 3E         mov [d], bl
2785   1678             _for37_update:
2786   1678 FA FB FF      lea d, [bp + -5] ; $k
2787   167B 2A            mov b, [d]
2788   167C D8            push b
2789   167D FD 77         inc b
2790   167F FA FB FF      lea d, [bp + -5] ; $k
2791   1682 FD 43         mov [d], b
2792   1684 E5            pop b
2793   1685 0A 52 16      jmp _for37_cond
2794   1688             _for37_exit:
2795   1688             ;; output_buffer[0] = (input_buffer[0] & 0xFC) >> 2; 
2796   1688 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2797   168B D7            push a
2798   168C DA            push d
2799   168D 26 00 00      mov b, $0
2800   1690 E7            pop d
2801   1691 5A            add d, b
2802   1692 E4            pop a
2803   1693 DA            push d
2804   1694 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2805   1697 D7            push a
2806   1698 DA            push d
2807   1699 26 00 00      mov b, $0
2808   169C E7            pop d
2809   169D 5A            add d, b
2810   169E E4            pop a
2811   169F 32            mov bl, [d]
2812   16A0 A7 00         mov bh, 0
2813   16A2 D7            push a
2814   16A3 11            mov a, b
2815   16A4 26 FC 00      mov b, $fc
2816   16A7 86            and a, b ; &
2817   16A8 27            mov b, a
2818   16A9 E4            pop a
2819   16AA             ; START SHIFT
2820   16AA D7            push a
2821   16AB 11            mov a, b
2822   16AC 26 02 00      mov b, $2
2823   16AF FD 39         mov c, b
2824   16B1 A5            ashr a, cl
2825   16B2 27            mov b, a
2826   16B3 E4            pop a
2827   16B4             ; END SHIFT
2828   16B4 E7            pop d
2829   16B5 FD 3E         mov [d], bl
2830   16B7             ;; output_buffer[1] = ((input_buffer[0] & 0x03) << 4) + ((input_buffer[1] & 0xF0) >> 4); 
2831   16B7 FA F2 FF      lea d, [bp + -14] ; $output_buffer
2832   16BA D7            push a
2833   16BB DA            push d
2834   16BC 26 01 00      mov b, $1
2835   16BF E7            pop d
2836   16C0 5A            add d, b
2837   16C1 E4            pop a
2838   16C2 DA            push d
2839   16C3 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2840   16C6 D7            push a
2841   16C7 DA            push d
2842   16C8 26 00 00      mov b, $0
2843   16CB E7            pop d
2844   16CC 5A            add d, b
2845   16CD E4            pop a
2846   16CE 32            mov bl, [d]
2847   16CF A7 00         mov bh, 0
2848   16D1 D7            push a
2849   16D2 11            mov a, b
2850   16D3 26 03 00      mov b, $3
2851   16D6 86            and a, b ; &
2852   16D7 27            mov b, a
2853   16D8 E4            pop a
2854   16D9             ; START SHIFT
2855   16D9 D7            push a
2856   16DA 11            mov a, b
2857   16DB 26 04 00      mov b, $4
2858   16DE FD 39         mov c, b
2859   16E0 9D            shl a, cl
2860   16E1 27            mov b, a
2861   16E2 E4            pop a
2862   16E3             ; END SHIFT
2863   16E3             ; START TERMS
2864   16E3 D7            push a
2865   16E4 11            mov a, b
2866   16E5 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2867   16E8 D7            push a
2868   16E9 DA            push d
2869   16EA 26 01 00      mov b, $1
2870   16ED E7            pop d
2871   16EE 5A            add d, b
2872   16EF E4            pop a
2873   16F0 32            mov bl, [d]
2874   16F1 A7 00         mov bh, 0
2875   16F3 D7            push a
2876   16F4 11            mov a, b
2877   16F5 26 F0 00      mov b, $f0
2878   16F8 86            and a, b ; &
2879   16F9 27            mov b, a
2880   16FA E4            pop a
2881   16FB             ; START SHIFT
2882   16FB D7            push a
2883   16FC 11            mov a, b
2884   16FD 26 04 00      mov b, $4
2885   1700 FD 39         mov c, b
2886   1702 A5            ashr a, cl
2887   1703 27            mov b, a
2888   1704 E4            pop a
2889   1705             ; END SHIFT
2890   1705 54            add a, b
2891   1706 27            mov b, a
2892   1707 E4            pop a
2893   1708             ; END TERMS
2894   1708 E7            pop d
2895   1709 FD 3E         mov [d], bl
2896   170B             ;; output_buffer[2] = ((input_buffer[1] & 0x0F) << 2) + ((input_buffer[2] & 0xC0) >> 6); 
2897   170B FA F2 FF      lea d, [bp + -14] ; $output_buffer
2898   170E D7            push a
2899   170F DA            push d
2900   1710 26 02 00      mov b, $2
2901   1713 E7            pop d
2902   1714 5A            add d, b
2903   1715 E4            pop a
2904   1716 DA            push d
2905   1717 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2906   171A D7            push a
2907   171B DA            push d
2908   171C 26 01 00      mov b, $1
2909   171F E7            pop d
2910   1720 5A            add d, b
2911   1721 E4            pop a
2912   1722 32            mov bl, [d]
2913   1723 A7 00         mov bh, 0
2914   1725 D7            push a
2915   1726 11            mov a, b
2916   1727 26 0F 00      mov b, $f
2917   172A 86            and a, b ; &
2918   172B 27            mov b, a
2919   172C E4            pop a
2920   172D             ; START SHIFT
2921   172D D7            push a
2922   172E 11            mov a, b
2923   172F 26 02 00      mov b, $2
2924   1732 FD 39         mov c, b
2925   1734 9D            shl a, cl
2926   1735 27            mov b, a
2927   1736 E4            pop a
2928   1737             ; END SHIFT
2929   1737             ; START TERMS
2930   1737 D7            push a
2931   1738 11            mov a, b
2932   1739 FA F6 FF      lea d, [bp + -10] ; $input_buffer
2933   173C D7            push a
2934   173D DA            push d
2935   173E 26 02 00      mov b, $2
2936   1741 E7            pop d
2937   1742 5A            add d, b
2938   1743 E4            pop a
2939   1744 32            mov bl, [d]
2940   1745 A7 00         mov bh, 0
2941   1747 D7            push a
2942   1748 11            mov a, b
2943   1749 26 C0 00      mov b, $c0
2944   174C 86            and a, b ; &
2945   174D 27            mov b, a
2946   174E E4            pop a
2947   174F             ; START SHIFT
2948   174F D7            push a
2949   1750 11            mov a, b
2950   1751 26 06 00      mov b, $6
2951   1754 FD 39         mov c, b
2952   1756 A5            ashr a, cl
2953   1757 27            mov b, a
2954   1758 E4            pop a
2955   1759             ; END SHIFT
2956   1759 54            add a, b
2957   175A 27            mov b, a
2958   175B E4            pop a
2959   175C             ; END TERMS
2960   175C E7            pop d
2961   175D FD 3E         mov [d], bl
2962   175F             ;; for (k = 0; k < i + 1; k++) { 
2963   175F             _for38_init:
2964   175F FA FB FF      lea d, [bp + -5] ; $k
2965   1762 DA            push d
2966   1763 26 00 00      mov b, $0
2967   1766 E7            pop d
2968   1767 FD 43         mov [d], b
2969   1769             _for38_cond:
2970   1769 FA FB FF      lea d, [bp + -5] ; $k
2971   176C 2A            mov b, [d]
2972   176D             ; START RELATIONAL
2973   176D D7            push a
2974   176E 11            mov a, b
2975   176F FA FF FF      lea d, [bp + -1] ; $i
2976   1772 2A            mov b, [d]
2977   1773             ; START TERMS
2978   1773 D7            push a
2979   1774 11            mov a, b
2980   1775 26 01 00      mov b, $1
2981   1778 54            add a, b
2982   1779 27            mov b, a
2983   177A E4            pop a
2984   177B             ; END TERMS
2985   177B B0            cmp a, b
2986   177C FD 73         slt ; < 
2987   177E E4            pop a
2988   177F             ; END RELATIONAL
2989   177F C0 00 00      cmp b, 0
2990   1782 C6 D2 17      je _for38_exit
2991   1785             _for38_block:
2992   1785             ;; output[j++] = base64_table[output_buffer[k]]; 
2993   1785 FA 07 00      lea d, [bp + 7] ; $output
2994   1788 FD 2A         mov d, [d]
2995   178A D7            push a
2996   178B DA            push d
2997   178C FA FD FF      lea d, [bp + -3] ; $j
2998   178F 2A            mov b, [d]
2999   1790 D8            push b
3000   1791 FD 77         inc b
3001   1793 FA FD FF      lea d, [bp + -3] ; $j
3002   1796 FD 43         mov [d], b
3003   1798 E5            pop b
3004   1799 E7            pop d
3005   179A FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3006   179E E4            pop a
3007   179F DA            push d
3008   17A0 3B 70 18      mov d, _base64_table ; $base64_table
3009   17A3 FD 2A         mov d, [d]
3010   17A5 D7            push a
3011   17A6 DA            push d
3012   17A7 FA F2 FF      lea d, [bp + -14] ; $output_buffer
3013   17AA D7            push a
3014   17AB DA            push d
3015   17AC FA FB FF      lea d, [bp + -5] ; $k
3016   17AF 2A            mov b, [d]
3017   17B0 E7            pop d
3018   17B1 5A            add d, b
3019   17B2 E4            pop a
3020   17B3 32            mov bl, [d]
3021   17B4 A7 00         mov bh, 0
3022   17B6 E7            pop d
3023   17B7 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3024   17BB E4            pop a
3025   17BC 32            mov bl, [d]
3026   17BD A7 00         mov bh, 0
3027   17BF E7            pop d
3028   17C0 FD 3E         mov [d], bl
3029   17C2             _for38_update:
3030   17C2 FA FB FF      lea d, [bp + -5] ; $k
3031   17C5 2A            mov b, [d]
3032   17C6 D8            push b
3033   17C7 FD 77         inc b
3034   17C9 FA FB FF      lea d, [bp + -5] ; $k
3035   17CC FD 43         mov [d], b
3036   17CE E5            pop b
3037   17CF 0A 69 17      jmp _for38_cond
3038   17D2             _for38_exit:
3039   17D2             ;; while (i++ < 3) { 
3040   17D2             _while39_cond:
3041   17D2 FA FF FF      lea d, [bp + -1] ; $i
3042   17D5 2A            mov b, [d]
3043   17D6 D8            push b
3044   17D7 FD 77         inc b
3045   17D9 FA FF FF      lea d, [bp + -1] ; $i
3046   17DC FD 43         mov [d], b
3047   17DE E5            pop b
3048   17DF             ; START RELATIONAL
3049   17DF D7            push a
3050   17E0 11            mov a, b
3051   17E1 26 03 00      mov b, $3
3052   17E4 B0            cmp a, b
3053   17E5 FD 73         slt ; < 
3054   17E7 E4            pop a
3055   17E8             ; END RELATIONAL
3056   17E8 C0 00 00      cmp b, 0
3057   17EB C6 12 18      je _while39_exit
3058   17EE             _while39_block:
3059   17EE             ;; output[j++] = '='; 
3060   17EE FA 07 00      lea d, [bp + 7] ; $output
3061   17F1 FD 2A         mov d, [d]
3062   17F3 D7            push a
3063   17F4 DA            push d
3064   17F5 FA FD FF      lea d, [bp + -3] ; $j
3065   17F8 2A            mov b, [d]
3066   17F9 D8            push b
3067   17FA FD 77         inc b
3068   17FC FA FD FF      lea d, [bp + -3] ; $j
3069   17FF FD 43         mov [d], b
3070   1801 E5            pop b
3071   1802 E7            pop d
3072   1803 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3073   1807 E4            pop a
3074   1808 DA            push d
3075   1809 26 3D 00      mov b, $3d
3076   180C E7            pop d
3077   180D FD 3E         mov [d], bl
3078   180F 0A D2 17      jmp _while39_cond
3079   1812             _while39_exit:
3080   1812 0A 15 18      jmp _if36_exit
3081   1815             _if36_exit:
3082   1815             ;; output[j] = '\0'; 
3083   1815 FA 07 00      lea d, [bp + 7] ; $output
3084   1818 FD 2A         mov d, [d]
3085   181A D7            push a
3086   181B DA            push d
3087   181C FA FD FF      lea d, [bp + -3] ; $j
3088   181F 2A            mov b, [d]
3089   1820 E7            pop d
3090   1821 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3091   1825 E4            pop a
3092   1826 DA            push d
3093   1827 26 00 00      mov b, $0
3094   182A E7            pop d
3095   182B FD 3E         mov [d], bl
3096   182D F9            leave
3097   182E 09            ret
3098   182F             ; --- END TEXT BLOCK
3099   182F             
3100   182F             ; --- BEGIN DATA BLOCK
3101   182F 41 42 43 44 _base64_table_data: .db "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0
3101   1833 45 46 47 48 
3101   1837 49 4A 4B 4C 
3101   183B 4D 4E 4F 50 
3101   183F 51 52 53 54 
3101   1843 55 56 57 58 
3101   1847 59 5A 61 62 
3101   184B 63 64 65 66 
3101   184F 67 68 69 6A 
3101   1853 6B 6C 6D 6E 
3101   1857 6F 70 71 72 
3101   185B 73 74 75 76 
3101   185F 77 78 79 7A 
3101   1863 30 31 32 33 
3101   1867 34 35 36 37 
3101   186B 38 39 2B 2F 
3101   186F 00 
3102   1870 2F 18       _base64_table: .dw _base64_table_data
3103   1872 45 6E 74 65 __s0: .db "Enter a string to encode in base64: ", 0
3103   1876 72 20 61 20 
3103   187A 73 74 72 69 
3103   187E 6E 67 20 74 
3103   1882 6F 20 65 6E 
3103   1886 63 6F 64 65 
3103   188A 20 69 6E 20 
3103   188E 62 61 73 65 
3103   1892 36 34 3A 20 
3103   1896 00 
3104   1897 42 61 73 65 __s1: .db "Base64 encoded string: ", 0
3104   189B 36 34 20 65 
3104   189F 6E 63 6F 64 
3104   18A3 65 64 20 73 
3104   18A7 74 72 69 6E 
3104   18AB 67 3A 20 00 
3105   18AF 0A 00       __s2: .db "\n", 0
3106   18B1 55 6E 65 78 __s3: .db "Unexpected format in printf.", 0
3106   18B5 70 65 63 74 
3106   18B9 65 64 20 66 
3106   18BD 6F 72 6D 61 
3106   18C1 74 20 69 6E 
3106   18C5 20 70 72 69 
3106   18C9 6E 74 66 2E 
3106   18CD 00 
3107   18CE 45 72 72 6F __s4: .db "Error: Unknown argument type.\n", 0
3107   18D2 72 3A 20 55 
3107   18D6 6E 6B 6E 6F 
3107   18DA 77 6E 20 61 
3107   18DE 72 67 75 6D 
3107   18E2 65 6E 74 20 
3107   18E6 74 79 70 65 
3107   18EA 2E 0A 00 
3108   18ED 1B 5B 32 4A __s5: .db "\033[2J\033[H", 0
3108   18F1 1B 5B 48 00 
3109   18F5             
3110   18F5 F7 18       _heap_top: .dw _heap
3111   18F7 00          _heap: .db 0
3112   18F8             ; --- END DATA BLOCK
3113   18F8             
3114   18F8             .end
tasm: Number of errors = 0
