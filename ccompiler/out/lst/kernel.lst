out/kernel.asm line 0069: Duplicate label: (text_org)
out/kernel.asm line 0158: Duplicate label: (sys_rtc)
out/kernel.asm line 0159: Duplicate label: (sys_ide)
out/kernel.asm line 0160: Duplicate label: (sys_io)
out/kernel.asm line 0161: Duplicate label: (sys_filesystem)
out/kernel.asm line 0164: Duplicate label: (sys_datetime)
out/kernel.asm line 0165: Duplicate label: (sys_reboot)
out/kernel.asm line 0166: Duplicate label: (sys_pause_proc)
out/kernel.asm line 0167: Duplicate label: (sys_resume_proc)
out/kernel.asm line 0168: Duplicate label: (sys_terminate_proc)
out/kernel.asm line 0169: Duplicate label: (sys_system)
out/kernel.asm line 0553: Duplicate label: (syscall_reboot)
out/kernel.asm line 0564: Duplicate label: (syscall_resume_proc)
out/kernel.asm line 0606: Duplicate label: (syscall_list_procs)
out/kernel.asm line 0643: Duplicate label: (syscall_break)
0001   0000             ; --- FILENAME: ../solarium/boot/kernel.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             ; --- BEGIN SYSTEM SEGMENT
0005   0000               ; ------------------------------------------------------------------------------------------------------------------;
0006   0000               ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0007   0000               ; ------------------------------------------------------------------------------------------------------------------;
0008   0000               ; Memory Map
0009   0000               ; ------------------------------------------------------------------------------------------------------------------;
0010   0000               ; 0000    ROM BEGIN
0011   0000               ; ....
0012   0000               ; 7FFF    ROM END
0013   0000               ;
0014   0000               ; 8000    RAM begin
0015   0000               ; ....
0016   0000               ; F7FF    Stack root
0017   0000               ; ------------------------------------------------------------------------------------------------------------------;
0018   0000               ; I/O MAP
0019   0000               ; ------------------------------------------------------------------------------------------------------------------;
0020   0000               ; FF80    UART 0    (16550)
0021   0000               ; FF90    UART 1    (16550)
0022   0000               ; FFA0    RTC       (M48T02)
0023   0000               ; FFB0    PIO 0     (8255)
0024   0000               ; FFC0    PIO 1     (8255)
0025   0000               ; FFD0    IDE       (Compact Flash / PATA)
0026   0000               ; FFE0    Timer     (8253)
0027   0000               ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000               ; ------------------------------------------------------------------------------------------------------------------;
0029   0000               ; ------------------------------------------------------------------------------------------------------------------;
0030   0000               ; System Constants
0031   0000               ; ------------------------------------------------------------------------------------------------------------------;
0032   0000             _UART0_DATA       .equ $FF80            ; data
0033   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0034   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0035   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0036   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0037   0000             _UART0_LCR        .equ $FF83            ; line control register
0038   0000             _UART0_LSR        .equ $FF85            ; line status register
0039   0000             _UART1_DATA       .equ $FF90            ; data
0040   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0041   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0042   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0043   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0044   0000             _UART1_LCR        .equ $FF93            ; line control register
0045   0000             _UART1_LSR        .equ $FF95            ; line status register
0046   0000             XON               .equ $11
0047   0000             XOFF              .equ $13
0048   0000             _ide_BASE         .equ $FFD0            ; IDE BASE
0049   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0050   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0051   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0052   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0053   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0054   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0055   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0056   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0057   0000             _7SEG_DISPLAY     .equ $FFB0            ; BIOS POST CODE HEX DISPLAY (2 DIGITS) (CONNECTED TO PIO A)
0058   0000             _BIOS_POST_CTRL   .equ $FFB3            ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0059   0000             _PIO_A            .equ $FFB0    
0060   0000             _PIO_B            .equ $FFB1
0061   0000             _PIO_C            .equ $FFB2
0062   0000             _PIO_CONTROL      .equ $FFB3            ; PIO CONTROL PORT
0063   0000             _TIMER_C_0        .equ $FFE0            ; TIMER COUNTER 0
0064   0000             _TIMER_C_1        .equ $FFE1            ; TIMER COUNTER 1
0065   0000             _TIMER_C_2        .equ $FFE2            ; TIMER COUNTER 2
0066   0000             _TIMER_CTRL       .equ $FFE3            ; TIMER CONTROL REGISTER
0067   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0068   0000             FIFO_SIZE         .equ 1024
0069   0000             text_org          .equ $400
0070   0000               ; ------------------------------------------------------------------------------------------------------------------;
0071   0000             ; For the next iteration:
0072   0000               ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0073   0000             ; inode-table format:
0074   0000               ;  file-type(f, d)
0075   0000               ;  permissons
0076   0000               ;  link-count
0077   0000               ;  filesize
0078   0000               ;  time-stamps
0079   0000               ;  15 data block pointers
0080   0000               ;  single-indirect pointer
0081   0000               ; FILE ENTRY ATTRIBUTES
0082   0000               ; filename (24)
0083   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0084   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0085   0000             ; size (2)             : filesize
0086   0000               ; day (1)           
0087   0000               ; month (1)
0088   0000               ; year (1)
0089   0000             ; packet size = 32 bytes  : total packet size in bytes
0090   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0091   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0092   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0093   0000             FST_NBR_DIRECTORIES     .equ 64
0094   0000               ; 1 sector for header, the rest is for the list of files/dirs
0095   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0096   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0097   0000             FST_LBA_START           .equ 32
0098   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0099   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0100   0000             FS_SECTORS_PER_FILE     .equ 32         ; the first sector is always a header with a  0     parameter (first byte)
0101   0000               ; so that we know which blocks are free or taken
0102   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0103   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0104   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0105   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0106   0000             root_id:                .equ FST_LBA_START
0107   0000               ; ------------------------------------------------------------------------------------------------------------------;
0108   0000               ; GLOBAL SYSTEM VARIABLES
0109   0000               ; ------------------------------------------------------------------------------------------------------------------;
0110   0000               ; ------------------------------------------------------------------------------------------------------------------;
0111   0000               ; IRQ Table
0112   0000               ; Highest priority at lowest address
0113   0000               ; ------------------------------------------------------------------------------------------------------------------;
0114   0000 22 04       .dw int_0
0115   0002 27 04       .dw int_1
0116   0004 2C 04       .dw int_2
0117   0006 31 04       .dw int_3
0118   0008 36 04       .dw int_4
0119   000A 3B 04       .dw int_5
0120   000C 40 04       .dw int_6
0121   000E A1 04       .dw int_7
0122   0010               ; ------------------------------------------------------------------------------------------------------------------;
0123   0010               ; Reset Vector
0124   0010               ; ------------------------------------------------------------------------------------------------------------------;
0125   0010 00 04       .dw main
0126   0012               ; ------------------------------------------------------------------------------------------------------------------;
0127   0012               ; Exception Vector Table
0128   0012               ; Total of 7 entries, starting at address $0012
0129   0012               ; ------------------------------------------------------------------------------------------------------------------;
0130   0012 1C 05       .dw trap_privilege
0131   0014 43 05       .dw trap_div_zero
0132   0016 71 05       .dw trap_undef_opcode
0133   0018 00 00       .dw 0
0134   001A 00 00       .dw 0
0135   001C 00 00       .dw 0
0136   001E 00 00       .dw 0
0137   0020               ; ------------------------------------------------------------------------------------------------------------------;
0138   0020               ; System Call Vector Table
0139   0020               ; Starts at address $0020
0140   0020               ; ------------------------------------------------------------------------------------------------------------------;
0141   0020 DB 04       .dw syscall_break
0142   0022 E0 04       .dw syscall_rtc
0143   0024 E5 04       .dw syscall_ide
0144   0026 EA 04       .dw syscall_io
0145   0028 EF 04       .dw syscall_file_system
0146   002A F4 04       .dw syscall_create_proc
0147   002C F9 04       .dw syscall_list_procs
0148   002E FE 04       .dw syscall_datetime
0149   0030 03 05       .dw syscall_reboot
0150   0032 08 05       .dw syscall_pause_proc
0151   0034 0D 05       .dw syscall_resume_proc
0152   0036 12 05       .dw syscall_terminate_proc
0153   0038 17 05       .dw syscall_system            
0154   003A               ; ------------------------------------------------------------------------------------------------------------------;
0155   003A               ; System Call Aliases
0156   003A               ; ------------------------------------------------------------------------------------------------------------------;
0157   003A             sys_break            .equ 0
0158   003A             sys_rtc              .equ 1
0159   003A             sys_ide              .equ 2
0160   003A             sys_io               .equ 3
0161   003A             sys_filesystem       .equ 4
0162   003A             sys_create_proc      .equ 5
0163   003A             sys_list_proc        .equ 6
0164   003A             sys_datetime         .equ 7
0165   003A             sys_reboot           .equ 8
0166   003A             sys_pause_proc       .equ 9
0167   003A             sys_resume_proc      .equ 10
0168   003A             sys_terminate_proc   .equ 11
0169   003A             sys_system           .equ 12
0170   003A               ; ------------------------------------------------------------------------------------------------------------------
0171   003A               ; Alias Exports
0172   003A               ; ------------------------------------------------------------------------------------------------------------------
0173   003A               .export text_org
0174   003A               .export sys_break
0175   003A               .export sys_rtc
0176   003A               .export sys_ide
0177   003A               .export sys_io
0178   003A               .export sys_filesystem
0179   003A               .export sys_create_proc
0180   003A               .export sys_list_proc
0181   003A               .export sys_datetime
0182   003A               .export sys_reboot
0183   003A               .export sys_pause_proc
0184   003A               .export sys_resume_proc
0185   003A               .export sys_terminate_proc
0186   003A               .export sys_system
0187   003A             ; --- END SYSTEM SEGMENT
0188   003A             
0189   003A             ; --- BEGIN TEXT SEGMENT
0190   0400             .org text_org
0191   0400             main:
0192   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0193   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0194   0408             ; puts("");     
0195   0408             ; --- START FUNCTION CALL
0196   0408 26 DD 10      mov b, _s0 ; ""
0197   040B FD AB         swp b
0198   040D D8            push b
0199   040E 07 B1 07      call puts
0200   0411 51 02 00      add sp, 2
0201   0414             ; --- END FUNCTION CALL
0202   0414             ; printf("Hello World" 
0203   0414             ; --- START FUNCTION CALL
0204   0414 26 DD 10      mov b, _s0 ; "Hello WorldMy name is Sol-1And this is a multi-line string"
0205   0417 FD AB         swp b
0206   0419 D8            push b
0207   041A 07 CF 07      call printf
0208   041D 51 02 00      add sp, 2
0209   0420             ; --- END FUNCTION CALL
0210   0420 05 0B         syscall sys_terminate_proc
0211   0422             
0212   0422             int_0:
0213   0422 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0214   0425 F9            leave
0215   0426 09            ret
0216   0427             
0217   0427             int_1:
0218   0427 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0219   042A F9            leave
0220   042B 09            ret
0221   042C             
0222   042C             int_2:
0223   042C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0224   042F F9            leave
0225   0430 09            ret
0226   0431             
0227   0431             int_3:
0228   0431 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0229   0434 F9            leave
0230   0435 09            ret
0231   0436             
0232   0436             int_4:
0233   0436 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0234   0439 F9            leave
0235   043A 09            ret
0236   043B             
0237   043B             int_5:
0238   043B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0239   043E F9            leave
0240   043F 09            ret
0241   0440             
0242   0440             int_6:
0243   0440 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0244   0443             ; --- BEGIN INLINE ASM SEGMENT
0245   0443 4B            pusha ; save all registers into kernel stack
0246   0444 22 00         mov ah, 0
out/kernel.asm line 0247: Label not found: (active_proc_index)
out/kernel.asm line 0247: Unused data in MS byte of argument. (2)
0247   0446 1D 00 00      mov al, [active_proc_index]
0248   0449 FD 99         shl a              ; x2
0249   044B B7 8F 04      mov a, [proc_table_convert + a]  ; get process state start index
0250   044E 4F            mov di, a
0251   044F 48            mov a, sp
0252   0450 77            inc a
0253   0451 4D            mov si, a
0254   0452 38 14 00      mov c, 20
0255   0455 FD F5         rep movsb          ; save process state!
0256   0457               ; restore kernel stack position to point before interrupt arrived
0257   0457 51 14 00      add sp, 20
0258   045A               ; now load next process in queue
out/kernel.asm line 0259: Label not found: (active_proc_index)
out/kernel.asm line 0259: Unused data in MS byte of argument. (2)
0259   045A 1D 00 00      mov al, [active_proc_index]
out/kernel.asm line 0260: Label not found: (nbr_active_procs)
out/kernel.asm line 0260: Unused data in MS byte of argument. (2)
0260   045D 31 00 00      mov bl, [nbr_active_procs]
0261   0460 BA            cmp al, bl
0262   0461 C6 68 04      je int6_cycle_back
0263   0464 7A            inc al            ; next process is next in the series
0264   0465 0A 6A 04      jmp int6_continue
0265   0468             int6_cycle_back:
0266   0468 19 01         mov al, 1        ; next process = process 1
0267   046A             int6_continue:
out/kernel.asm line 0268: Label not found: (active_proc_index)
out/kernel.asm line 0268: Unused data in MS byte of argument. (2)
0268   046A 3D 00 00      mov [active_proc_index], al    ; set next active proc
0269   046D               ; calculate LUT entry for next process
0270   046D 22 00         mov ah, 0
0271   046F FD 99         shl a              ; x2
0272   0471 B7 8F 04      mov a, [proc_table_convert + a]    ; get process state start index  
0273   0474 4D            mov si, a            ; source is proc state block
0274   0475 48            mov a, sp
0275   0476 5F 13 00      sub a, 19
0276   0479 4F            mov di, a            ; destination is kernel stack
0277   047A               ; restore SP
0278   047A 7D            dec a
0279   047B 47            mov sp, a
0280   047C 38 14 00      mov c, 20
0281   047F FD F5         rep movsb
0282   0481               ; set VM process
out/kernel.asm line 0283: Label not found: (active_proc_index)
out/kernel.asm line 0283: Unused data in MS byte of argument. (2)
0283   0481 1D 00 00      mov al, [active_proc_index]
0284   0484 01            setptb
0285   0485 F2 E0 FF 00   mov byte[_TIMER_C_0], 0        ; load counter 0 low byte
0286   0489 F2 E0 FF 10   mov byte[_TIMER_C_0], $10        ; load counter 0 high byte
0287   048D 4C            popa
0288   048E 06            sysret
0289   048F             proc_table_convert:
out/kernel.asm line 0290: Label not found: (proc_state_table)
out/kernel.asm line 0290: Label not found: (proc_state_table)
0290   048F 00 00       .dw proc_state_table + 0
out/kernel.asm line 0291: Label not found: (proc_state_table)
out/kernel.asm line 0291: Label not found: (proc_state_table)
0291   0491 14 00       .dw proc_state_table + 20
out/kernel.asm line 0292: Label not found: (proc_state_table)
out/kernel.asm line 0292: Label not found: (proc_state_table)
0292   0493 28 00       .dw proc_state_table + 40
out/kernel.asm line 0293: Label not found: (proc_state_table)
out/kernel.asm line 0293: Label not found: (proc_state_table)
0293   0495 3C 00       .dw proc_state_table + 60
out/kernel.asm line 0294: Label not found: (proc_state_table)
out/kernel.asm line 0294: Label not found: (proc_state_table)
0294   0497 50 00       .dw proc_state_table + 80
out/kernel.asm line 0295: Label not found: (proc_state_table)
out/kernel.asm line 0295: Label not found: (proc_state_table)
0295   0499 64 00       .dw proc_state_table + 100
out/kernel.asm line 0296: Label not found: (proc_state_table)
out/kernel.asm line 0296: Label not found: (proc_state_table)
0296   049B 78 00       .dw proc_state_table + 120
out/kernel.asm line 0297: Label not found: (proc_state_table)
out/kernel.asm line 0297: Label not found: (proc_state_table)
0297   049D 8C 00       .dw proc_state_table + 140
0298   049F             ; --- END INLINE ASM SEGMENT
0299   049F F9            leave
0300   04A0 09            ret
0301   04A1             
0302   04A1             int_7:
0303   04A1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0304   04A4             ; --- BEGIN INLINE ASM SEGMENT
0305   04A4 D7            push a
0306   04A5 DA            push d
0307   04A6 E1            pushf
out/kernel.asm line 0308: Label not found: (fifo_in)
out/kernel.asm line 0308: Unused data in MS byte of argument. (2)
0308   04A7 14 00 00      mov a, [fifo_in]
0309   04AA 3C            mov d, a
0310   04AB 1D 80 FF      mov al, [_UART0_DATA]  ; get character
0311   04AE B9 03         cmp al, $03        ; CTRL-C
0312   04B0 C6 CD 04      je CTRLC
0313   04B3 B9 1A         cmp al, $1A        ; CTRL-Z
0314   04B5 C6 D3 04      je CTRLZ
0315   04B8 3E            mov [d], al        ; add to fifo
out/kernel.asm line 0316: Label not found: (fifo_in)
out/kernel.asm line 0316: Unused data in MS byte of argument. (2)
0316   04B9 14 00 00      mov a, [fifo_in]
0317   04BC 77            inc a
out/kernel.asm line 0318: Label not found: (fifo)
out/kernel.asm line 0318: Unused data in MS byte of argument. (2)
0318   04BD AF 00 04      cmp a, fifo + FIFO_SIZE         ; check if pointer reached the end of the fifo
0319   04C0 C7 C6 04      jne int_7_continue
out/kernel.asm line 0320: Label not found: (fifo)
out/kernel.asm line 0320: Unused data in MS byte of argument. (2)
0320   04C3 10 00 00      mov a, fifo  
0321   04C6             int_7_continue:  
out/kernel.asm line 0322: Label not found: (fifo_in)
out/kernel.asm line 0322: Unused data in MS byte of argument. (2)
0322   04C6 42 00 00      mov [fifo_in], a      ; update fifo pointer
0323   04C9 EE            popf
0324   04CA E7            pop d
0325   04CB E4            pop a  
0326   04CC 06            sysret
0327   04CD             CTRLC:
0328   04CD 51 05 00      add sp, 5
0329   04D0 0A 12 05      jmp syscall_terminate_proc
0330   04D3             CTRLZ:
0331   04D3 EE            popf
0332   04D4 E7            pop d
0333   04D5 E4            pop a
0334   04D6 0A 08 05      jmp syscall_pause_proc    ; pause current process and go back to the shell
0335   04D9             ; --- END INLINE ASM SEGMENT
0336   04D9 F9            leave
0337   04DA 09            ret
0338   04DB             
0339   04DB             syscall_break:
0340   04DB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0341   04DE F9            leave
0342   04DF 09            ret
0343   04E0             
0344   04E0             syscall_rtc:
0345   04E0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0346   04E3 F9            leave
0347   04E4 09            ret
0348   04E5             
0349   04E5             syscall_ide:
0350   04E5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0351   04E8 F9            leave
0352   04E9 09            ret
0353   04EA             
0354   04EA             syscall_io:
0355   04EA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0356   04ED F9            leave
0357   04EE 09            ret
0358   04EF             
0359   04EF             syscall_file_system:
0360   04EF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0361   04F2 F9            leave
0362   04F3 09            ret
0363   04F4             
0364   04F4             syscall_create_proc:
0365   04F4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0366   04F7 F9            leave
0367   04F8 09            ret
0368   04F9             
0369   04F9             syscall_list_procs:
0370   04F9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0371   04FC F9            leave
0372   04FD 09            ret
0373   04FE             
0374   04FE             syscall_datetime:
0375   04FE F8 00 00      enter 0 ; (push bp; mov bp, sp)
0376   0501 F9            leave
0377   0502 09            ret
0378   0503             
0379   0503             syscall_reboot:
0380   0503 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0381   0506 F9            leave
0382   0507 09            ret
0383   0508             
0384   0508             syscall_pause_proc:
0385   0508 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0386   050B F9            leave
0387   050C 09            ret
0388   050D             
0389   050D             syscall_resume_proc:
0390   050D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0391   0510 F9            leave
0392   0511 09            ret
0393   0512             
0394   0512             syscall_terminate_proc:
0395   0512 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0396   0515 F9            leave
0397   0516 09            ret
0398   0517             
0399   0517             syscall_system:
0400   0517 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0401   051A F9            leave
0402   051B 09            ret
0403   051C             
0404   051C             trap_privilege:
0405   051C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0406   051F             ; --- BEGIN INLINE ASM SEGMENT
0407   051F 0A 03 05      jmp syscall_reboot
0408   0522 FD D7 2A 05   push word s_priviledge
0409   0526 07 B1 07      call puts
0410   0529 06            sysret
0411   052A 0A 65 78 63 s_priviledge: .db "\nexception: privilege\n", 0
0411   052E 65 70 74 69 
0411   0532 6F 6E 3A 20 
0411   0536 70 72 69 76 
0411   053A 69 6C 65 67 
0411   053E 65 0A 00 
0412   0541             ; --- END INLINE ASM SEGMENT
0413   0541 F9            leave
0414   0542 09            ret
0415   0543             
0416   0543             trap_div_zero:
0417   0543 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0418   0546             ; --- BEGIN INLINE ASM SEGMENT
0419   0546 D7            push a
0420   0547 DA            push d
0421   0548 E1            pushf
0422   0549 FD D7 54 05   push word s_divzero
0423   054D 07 B1 07      call puts
0424   0550 EE            popf
0425   0551 E7            pop d
0426   0552 E4            pop a
0427   0553 06            sysret ; enable interrupts
0428   0554 0A 65 78 63 s_divzero: .db "\nexception: zero division\n", 0
0428   0558 65 70 74 69 
0428   055C 6F 6E 3A 20 
0428   0560 7A 65 72 6F 
0428   0564 20 64 69 76 
0428   0568 69 73 69 6F 
0428   056C 6E 0A 00 
0429   056F             ; --- END INLINE ASM SEGMENT
0430   056F F9            leave
0431   0570 09            ret
0432   0571             
0433   0571             trap_undef_opcode:
0434   0571 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0435   0574 F9            leave
0436   0575 09            ret
0437   0576             
0438   0576             system_jmptbl:
0439   0576 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0440   0579             ; char code; 
0441   0579 52 01 00      sub sp, 1
0442   057C             ; --- BEGIN INLINE ASM SEGMENT
0443   057C FA 00 00      lea d, [bp + 0] ; $code
0444   057F 3E            mov [d], al
0445   0580             ; --- END INLINE ASM SEGMENT
0446   0580             ; switch(code){ 
0447   0580             _switch1_expr:
0448   0580 FA 00 00      lea d, [bp + 0] ; $code
0449   0583 32            mov bl, [d]
0450   0584 A7 00         mov bh, 0
0451   0586 38 00 00      mov c, 0
0452   0589             _switch1_comparisons:
0453   0589 C0 00 00      cmp b, 0
0454   058C C6 AA 05      je _switch1_case0
0455   058F C0 01 00      cmp b, 1
0456   0592 C6 B0 05      je _switch1_case1
0457   0595 C0 02 00      cmp b, 2
0458   0598 C6 B6 05      je _switch1_case2
0459   059B C0 03 00      cmp b, 3
0460   059E C6 BC 05      je _switch1_case3
0461   05A1 C0 04 00      cmp b, 4
0462   05A4 C6 C2 05      je _switch1_case4
0463   05A7 0A C8 05      jmp _switch1_exit
0464   05AA             _switch1_case0:
0465   05AA             ; system_uname(); 
0466   05AA             ; --- START FUNCTION CALL
0467   05AA 07 01 06      call system_uname
0468   05AD             ; break; 
0469   05AD 0A C8 05      jmp _switch1_exit ; case break
0470   05B0             _switch1_case1:
0471   05B0             ; system_whoami(); 
0472   05B0             ; --- START FUNCTION CALL
0473   05B0 07 07 06      call system_whoami
0474   05B3             ; break; 
0475   05B3 0A C8 05      jmp _switch1_exit ; case break
0476   05B6             _switch1_case2:
0477   05B6             ; system_setparam(); 
0478   05B6             ; --- START FUNCTION CALL
0479   05B6 07 F9 05      call system_setparam
0480   05B9             ; break; 
0481   05B9 0A C8 05      jmp _switch1_exit ; case break
0482   05BC             _switch1_case3:
0483   05BC             ; system_bootloader_install(); 
0484   05BC             ; --- START FUNCTION CALL
0485   05BC 07 D1 05      call system_bootloader_install
0486   05BF             ; break; 
0487   05BF 0A C8 05      jmp _switch1_exit ; case break
0488   05C2             _switch1_case4:
0489   05C2             ; system_getparam(); 
0490   05C2             ; --- START FUNCTION CALL
0491   05C2 07 CA 05      call system_getparam
0492   05C5             ; break; 
0493   05C5 0A C8 05      jmp _switch1_exit ; case break
0494   05C8             _switch1_exit:
0495   05C8 F9            leave
0496   05C9 09            ret
0497   05CA             
0498   05CA             system_getparam:
0499   05CA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0500   05CD             ; --- BEGIN INLINE ASM SEGMENT
0501   05CD 32            mov bl, [d]
0502   05CE 06            sysret
0503   05CF             ; --- END INLINE ASM SEGMENT
0504   05CF F9            leave
0505   05D0 09            ret
0506   05D1             
0507   05D1             system_bootloader_install:
0508   05D1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0509   05D4             ; --- BEGIN INLINE ASM SEGMENT
0510   05D4 D8            push b
0511   05D5 26 00 00      mov b, 0
0512   05D8 38 00 00      mov c, 0
0513   05DB 22 01         mov ah, $01                 ; 1 sector
out/kernel.asm line 0514: Label not found: (transient_area)
out/kernel.asm line 0514: Unused data in MS byte of argument. (2)
0514   05DD 3B 00 00      mov d, transient_area
out/kernel.asm line 0515: Label not found: (ide_read_sect)
out/kernel.asm line 0515: Unused data in MS byte of argument. (2)
0515   05E0 07 00 00      call ide_read_sect          ; read sector
0516   05E3 E5            pop b
0517   05E4 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0518   05E8 26 00 00      mov b, 0
0519   05EB 38 00 00      mov c, 0
0520   05EE 22 01         mov ah, $01                 ; 1 sector
out/kernel.asm line 0521: Label not found: (transient_area)
out/kernel.asm line 0521: Unused data in MS byte of argument. (2)
0521   05F0 3B 00 00      mov d, transient_area
out/kernel.asm line 0522: Label not found: (ide_write_sect)
out/kernel.asm line 0522: Unused data in MS byte of argument. (2)
0522   05F3 07 00 00      call ide_write_sect         ; write sector
0523   05F6 06            sysret
0524   05F7             ; --- END INLINE ASM SEGMENT
0525   05F7 F9            leave
0526   05F8 09            ret
0527   05F9             
0528   05F9             system_setparam:
0529   05F9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0530   05FC             ; --- BEGIN INLINE ASM SEGMENT
0531   05FC FD 3E         mov [d], bl
0532   05FE 06            sysret
0533   05FF             ; --- END INLINE ASM SEGMENT
0534   05FF F9            leave
0535   0600 09            ret
0536   0601             
0537   0601             system_uname:
0538   0601 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0539   0604             ; --- BEGIN INLINE ASM SEGMENT
0540   0604 06            sysret
0541   0605             ; --- END INLINE ASM SEGMENT
0542   0605 F9            leave
0543   0606 09            ret
0544   0607             
0545   0607             system_whoami:
0546   0607 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0547   060A             ; --- BEGIN INLINE ASM SEGMENT
0548   060A 06            sysret
0549   060B             ; --- END INLINE ASM SEGMENT
0550   060B F9            leave
0551   060C 09            ret
0552   060D             
0553   060D             syscall_reboot:
out/kernel.asm line 0553: label value misalligned.           (syscall_reboot)
0554   060D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0555   0610             ; --- BEGIN INLINE ASM SEGMENT
0556   0610 FD D7 FF FF   push word $FFFF 
0557   0614 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0558   0617 FD D7 C0 01   push word BIOS_RESET_VECTOR    ; and then push RESET VECTOR of the shell to the stack
0559   061B 06            sysret
0560   061C             ; --- END INLINE ASM SEGMENT
0561   061C F9            leave
0562   061D 09            ret
0563   061E             
0564   061E             syscall_resume_proc:
out/kernel.asm line 0564: label value misalligned.           (syscall_resume_proc)
0565   061E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0566   0621             ; --- BEGIN INLINE ASM SEGMENT
0567   0621 FD 78         mov g, a                            ; save the process number
0568   0623 4B            pusha                               ; save all registers into kernel stack
0569   0624 22 00         mov ah, 0
out/kernel.asm line 0570: Label not found: (active_proc_index)
out/kernel.asm line 0570: Unused data in MS byte of argument. (2)
0570   0626 1D 00 00      mov al, [active_proc_index]
0571   0629 FD 99         shl a              ; x2
0572   062B B7 8F 04      mov a, [proc_table_convert + a]     ; get process state start index
0573   062E 4F            mov di, a
0574   062F 48            mov a, sp
0575   0630 77            inc a
0576   0631 4D            mov si, a
0577   0632 38 14 00      mov c, 20
0578   0635 FD F5         rep movsb                           ; save process state!
0579   0637               ; restore kernel stack position to point before interrupt arrived
0580   0637 51 14 00      add sp, 20
0581   063A               ; now load the new process number!
0582   063A FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
out/kernel.asm line 0583: Label not found: (active_proc_index)
out/kernel.asm line 0583: Unused data in MS byte of argument. (2)
0583   063C 3D 00 00      mov [active_proc_index], al         ; set new active proc
0584   063F               ; calculate LUT entry for next process
0585   063F 22 00         mov ah, 0
0586   0641 FD 99         shl a                               ; x2
0587   0643 B7 8F 04      mov a, [proc_table_convert + a]     ; get process state start index  
0588   0646 4D            mov si, a                           ; source is proc state block
0589   0647 48            mov a, sp
0590   0648 5F 13 00      sub a, 19
0591   064B 4F            mov di, a                           ; destination is kernel stack
0592   064C               ; restore SP
0593   064C 7D            dec a
0594   064D 47            mov sp, a
0595   064E 38 14 00      mov c, 20
0596   0651 FD F5         rep movsb
0597   0653               ; set VM process
out/kernel.asm line 0598: Label not found: (active_proc_index)
out/kernel.asm line 0598: Unused data in MS byte of argument. (2)
0598   0653 1D 00 00      mov al, [active_proc_index]
0599   0656 01            setptb
0600   0657 4C            popa
0601   0658 06            sysret
0602   0659             ; --- END INLINE ASM SEGMENT
0603   0659 F9            leave
0604   065A 09            ret
0605   065B             
0606   065B             syscall_list_procs:
out/kernel.asm line 0606: label value misalligned.           (syscall_list_procs)
0607   065B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0608   065E             ; --- BEGIN INLINE ASM SEGMENT
out/kernel.asm line 0609: Label not found: (s_ps_header)
out/kernel.asm line 0609: Unused data in MS byte of argument. (2)
0609   065E 3B 00 00      mov d, s_ps_header
out/kernel.asm line 0610: Label not found: (_puts)
out/kernel.asm line 0610: Unused data in MS byte of argument. (2)
0610   0661 07 00 00      call _puts
out/kernel.asm line 0611: Label not found: (proc_availab_table)
out/kernel.asm line 0611: Unused data in MS byte of argument. (2)
0611   0664 3B 01 00      mov d, proc_availab_table + 1
0612   0667 38 01 00      mov c, 1
0613   066A             list_procs_L0:  
0614   066A BD 01         cmp byte[d], 1
0615   066C C7 90 06      jne list_procs_next
0616   066F 2D            mov b, d
out/kernel.asm line 0617: Label not found: (proc_availab_table)
out/kernel.asm line 0617: Unused data in MS byte of argument. (2)
0617   0670 61 00 00      sub b, proc_availab_table
0618   0673 FD 9F 05      shl b, 5
0619   0676 DA            push d
0620   0677 D8            push b
0621   0678 28            mov b, c
out/kernel.asm line 0622: Label not found: (print_u8x)
out/kernel.asm line 0622: Unused data in MS byte of argument. (2)
0622   0679 07 00 00      call print_u8x
0623   067C 22 20         mov ah, ' '
out/kernel.asm line 0624: Label not found: (_putchar)
out/kernel.asm line 0624: Unused data in MS byte of argument. (2)
0624   067E 07 00 00      call _putchar
out/kernel.asm line 0625: Label not found: (_putchar)
out/kernel.asm line 0625: Unused data in MS byte of argument. (2)
0625   0681 07 00 00      call _putchar
0626   0684 E5            pop b
0627   0685 74            mov d, b
out/kernel.asm line 0628: Label not found: (proc_names)
out/kernel.asm line 0628: Unused data in MS byte of argument. (2)
0628   0686 58 00 00      add d, proc_names
out/kernel.asm line 0629: Label not found: (_puts)
out/kernel.asm line 0629: Unused data in MS byte of argument. (2)
0629   0689 07 00 00      call _puts
out/kernel.asm line 0630: Label not found: (printnl)
out/kernel.asm line 0630: Unused data in MS byte of argument. (2)
0630   068C 07 00 00      call printnl
0631   068F E7            pop d
0632   0690             list_procs_next:
0633   0690 79            inc d
0634   0691 78            inc c
0635   0692 C2 09 00      cmp c, 9
0636   0695 C7 6A 06      jne list_procs_L0
0637   0698             list_procs_end:
0638   0698 06            sysret
0639   0699             ; --- END INLINE ASM SEGMENT
0640   0699 F9            leave
0641   069A 09            ret
0642   069B             
0643   069B             syscall_break:
out/kernel.asm line 0643: label value misalligned.           (syscall_break)
0644   069B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0645   069E             ; --- BEGIN INLINE ASM SEGMENT
0646   069E 4B            pusha
0647   069F             syscall_break_prompt:
0648   069F 3B 59 07      mov d, s_break1
out/kernel.asm line 0649: Label not found: (_puts)
out/kernel.asm line 0649: Unused data in MS byte of argument. (2)
0649   06A2 07 00 00      call _puts
out/kernel.asm line 0650: Label not found: (printnl)
out/kernel.asm line 0650: Unused data in MS byte of argument. (2)
0650   06A5 07 00 00      call printnl
out/kernel.asm line 0651: Label not found: (scan_u16d)
out/kernel.asm line 0651: Unused data in MS byte of argument. (2)
0651   06A8 07 00 00      call scan_u16d
0652   06AB AF 00 00      cmp a, 0
0653   06AE C6 B9 06      je syscall_break_regs
0654   06B1 AF 01 00      cmp a, 1
0655   06B4 C6 DC 06      je syscall_break_mem
0656   06B7             syscall_break_end:  
0657   06B7 4C            popa
0658   06B8 06            sysret
0659   06B9             syscall_break_regs:
0660   06B9 48            mov a, sp
0661   06BA 53 0E 00      add a, 14               ; back-track 7 registers
0662   06BD 3C            mov d, a
0663   06BE 3A 07         mov cl, 7
0664   06C0             syscall_regs_L0:
0665   06C0 2A            mov b, [d]
0666   06C1 FD AB         swp b
out/kernel.asm line 0667: Label not found: (print_u16x)
out/kernel.asm line 0667: Unused data in MS byte of argument. (2)
0667   06C3 07 00 00      call print_u16x         ; print register value
out/kernel.asm line 0668: Label not found: (printnl)
out/kernel.asm line 0668: Unused data in MS byte of argument. (2)
0668   06C6 07 00 00      call printnl
0669   06C9 63 02 00      sub d, 2
0670   06CC 71 01         sub cl, 1
0671   06CE C3 00         cmp cl, 0
0672   06D0 C7 C0 06      jne syscall_regs_L0
0673   06D3 0A 9F 06      jmp syscall_break_prompt
out/kernel.asm line 0674: Label not found: (printnl)
out/kernel.asm line 0674: Unused data in MS byte of argument. (2)
0674   06D6 07 00 00      call printnl
0675   06D9 0A 9F 06      jmp syscall_break_prompt
0676   06DC             syscall_break_mem:
out/kernel.asm line 0677: Label not found: (printnl)
out/kernel.asm line 0677: Unused data in MS byte of argument. (2)
0677   06DC 07 00 00      call printnl
out/kernel.asm line 0678: Label not found: (scan_u16x)
out/kernel.asm line 0678: Unused data in MS byte of argument. (2)
0678   06DF 07 00 00      call scan_u16x
0679   06E2 4D            mov si, a               ; data source from user space
out/kernel.asm line 0680: Label not found: (scrap_sector)
out/kernel.asm line 0680: Unused data in MS byte of argument. (2)
0680   06E3 FD 4F 00 00   mov di, scrap_sector    ; destination in kernel space
0681   06E7 38 00 02      mov c, 512
0682   06EA 04            load                    ; transfer data to kernel space!
out/kernel.asm line 0683: Label not found: (scrap_sector)
out/kernel.asm line 0683: Unused data in MS byte of argument. (2)
0683   06EB 3B 00 00      mov d, scrap_sector     ; dump pointer in d
0684   06EE 38 00 00      mov c, 0
0685   06F1             dump_loop:
0686   06F1 84            mov al, cl
0687   06F2 87 0F         and al, $0F
0688   06F4 C6 42 07      jz print_base
0689   06F7             back:
0690   06F7 1E            mov al, [d]             ; read byte
0691   06F8 2F            mov bl, al
out/kernel.asm line 0692: Label not found: (print_u8x)
out/kernel.asm line 0692: Unused data in MS byte of argument. (2)
0692   06F9 07 00 00      call print_u8x
0693   06FC 10 00 20      mov a, $2000
0694   06FF 05 03         syscall sys_io          ; space
0695   0701 84            mov al, cl
0696   0702 87 0F         and al, $0F
0697   0704 B9 0F         cmp al, $0F
0698   0706 C6 17 07      je print_ascii
0699   0709             back1:
0700   0709 79            inc d
0701   070A 78            inc c
0702   070B C2 00 02      cmp c, 512
0703   070E C7 F1 06      jne dump_loop
out/kernel.asm line 0704: Label not found: (printnl)
out/kernel.asm line 0704: Unused data in MS byte of argument. (2)
0704   0711 07 00 00      call printnl
0705   0714 0A 9F 06      jmp syscall_break_prompt  ; go to syscall_break return point
0706   0717             print_ascii:
0707   0717 10 00 20      mov a, $2000
0708   071A 05 03         syscall sys_io
0709   071C 63 10 00      sub d, 16
0710   071F 26 10 00      mov b, 16
0711   0722             print_ascii_L:
0712   0722 79            inc d
0713   0723 1E            mov al, [d]               ; read byte
0714   0724 B9 20         cmp al, $20
0715   0726 C8 2E 07      jlu dot
0716   0729 B9 7E         cmp al, $7E
0717   072B D0 36 07      jleu ascii
0718   072E             dot:
0719   072E 10 00 2E      mov a, $2E00
0720   0731 05 03         syscall sys_io
0721   0733 0A 3B 07      jmp ascii_continue
0722   0736             ascii:
0723   0736 23            mov ah, al
0724   0737 19 00         mov al, 0
0725   0739 05 03         syscall sys_io
0726   073B             ascii_continue:
0727   073B FD A9 22 07   loopb print_ascii_L
0728   073F 0A 09 07      jmp back1
0729   0742             print_base:
out/kernel.asm line 0730: Label not found: (printnl)
out/kernel.asm line 0730: Unused data in MS byte of argument. (2)
0730   0742 07 00 00      call printnl
0731   0745 2D            mov b, d
out/kernel.asm line 0732: Label not found: (scrap_sector)
out/kernel.asm line 0732: Unused data in MS byte of argument. (2)
0732   0746 61 00 00      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
out/kernel.asm line 0733: Label not found: (print_u16x)
out/kernel.asm line 0733: Unused data in MS byte of argument. (2)
0733   0749 07 00 00      call print_u16x          ; display row
0734   074C 10 00 3A      mov a, $3A00
0735   074F 05 03         syscall sys_io
0736   0751 10 00 20      mov a, $2000
0737   0754 05 03         syscall sys_io
0738   0756 0A F7 06      jmp back
0739   0759             s_break1:  
0740   0759 0A 44 65 62 .db "\nDebugger entry point.\n"
0740   075D 75 67 67 65 
0740   0761 72 20 65 6E 
0740   0765 74 72 79 20 
0740   0769 70 6F 69 6E 
0740   076D 74 2E 0A 
0741   0770 30 2E 20 53 .db "0. Show Registers\n"
0741   0774 68 6F 77 20 
0741   0778 52 65 67 69 
0741   077C 73 74 65 72 
0741   0780 73 0A 
0742   0782 31 2E 20 53 .db "1. Show 512B RAM block\n"
0742   0786 68 6F 77 20 
0742   078A 35 31 32 42 
0742   078E 20 52 41 4D 
0742   0792 20 62 6C 6F 
0742   0796 63 6B 0A 
0743   0799 32 2E 20 43 .db "2. Continue Execution", 0
0743   079D 6F 6E 74 69 
0743   07A1 6E 75 65 20 
0743   07A5 45 78 65 63 
0743   07A9 75 74 69 6F 
0743   07AD 6E 00 
0744   07AF             ; --- END INLINE ASM SEGMENT
0745   07AF F9            leave
0746   07B0 09            ret
0747   07B1             
0748   07B1             puts:
0749   07B1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0750   07B4             ; --- BEGIN INLINE ASM SEGMENT
0751   07B4 FA 05 00      lea d, [bp + 5] ; $s
0752   07B7 FD 2A         mov d, [d]
0753   07B9             _puts_L1_puts:
0754   07B9 1E            mov al, [d]
0755   07BA B9 00         cmp al, 0
0756   07BC C6 C8 07      jz _puts_END_puts
0757   07BF 23            mov ah, al
0758   07C0 19 00         mov al, 0
0759   07C2 05 03         syscall sys_io
0760   07C4 79            inc d
0761   07C5 0A B9 07      jmp _puts_L1_puts
0762   07C8             _puts_END_puts:
0763   07C8 10 00 0A      mov a, $0A00
0764   07CB 05 03         syscall sys_io
0765   07CD             ; --- END INLINE ASM SEGMENT
0766   07CD F9            leave
0767   07CE 09            ret
0768   07CF             
0769   07CF             printf:
0770   07CF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0771   07D2             ; char *p, *format_p; 
0772   07D2 52 02 00      sub sp, 2
0773   07D5 52 02 00      sub sp, 2
0774   07D8             ; format_p = format; 
0775   07D8 FA FD FF      lea d, [bp + -3] ; $format_p
0776   07DB DA            push d
0777   07DC FA 05 00      lea d, [bp + 5] ; $format
0778   07DF 2A            mov b, [d]
0779   07E0 38 00 00      mov c, 0
0780   07E3 E7            pop d
0781   07E4 FD 43         mov [d], b
0782   07E6             ; p = &format + 2; 
0783   07E6 FA FF FF      lea d, [bp + -1] ; $p
0784   07E9 DA            push d
0785   07EA FA 05 00      lea d, [bp + 5] ; $format
0786   07ED 2D            mov b, d
0787   07EE             ; --- START TERMS
0788   07EE D7            push a
0789   07EF 11            mov a, b
0790   07F0 FD 2E 02 00   mov32 cb, $00000002
0790   07F4 00 00 
0791   07F6 56            add b, a
0792   07F7 E4            pop a
0793   07F8             ; --- END TERMS
0794   07F8 E7            pop d
0795   07F9 FD 43         mov [d], b
0796   07FB             ; for(;;){ 
0797   07FB             _for2_init:
0798   07FB             _for2_cond:
0799   07FB             _for2_block:
0800   07FB             ; if(!*format_p) break; 
0801   07FB             _if3_cond:
0802   07FB FA FD FF      lea d, [bp + -3] ; $format_p
0803   07FE 2A            mov b, [d]
0804   07FF 38 00 00      mov c, 0
0805   0802 74            mov d, b
0806   0803 32            mov bl, [d]
0807   0804 A7 00         mov bh, 0
0808   0806 38 00 00      mov c, 0
0809   0809 C0 00 00      cmp b, 0
0810   080C FD 71         seq ; !
0811   080E C0 00 00      cmp b, 0
0812   0811 C6 1A 08      je _if3_else
0813   0814             _if3_TRUE:
0814   0814             ; break; 
0815   0814 0A CA 0A      jmp _for2_exit ; for break
0816   0817 0A C7 0A      jmp _if3_exit
0817   081A             _if3_else:
0818   081A             ; if(*format_p == '%'){ 
0819   081A             _if4_cond:
0820   081A FA FD FF      lea d, [bp + -3] ; $format_p
0821   081D 2A            mov b, [d]
0822   081E 38 00 00      mov c, 0
0823   0821 74            mov d, b
0824   0822 32            mov bl, [d]
0825   0823 A7 00         mov bh, 0
0826   0825 38 00 00      mov c, 0
0827   0828             ; --- START RELATIONAL
0828   0828 D7            push a
0829   0829 11            mov a, b
0830   082A FD 2E 25 00   mov32 cb, $00000025
0830   082E 00 00 
0831   0830 B0            cmp a, b
0832   0831 FD 71         seq ; ==
0833   0833 E4            pop a
0834   0834             ; --- END RELATIONAL
0835   0834 C0 00 00      cmp b, 0
0836   0837 C6 A2 0A      je _if4_else
0837   083A             _if4_TRUE:
0838   083A             ; format_p++; 
0839   083A FA FD FF      lea d, [bp + -3] ; $format_p
0840   083D 2A            mov b, [d]
0841   083E 38 00 00      mov c, 0
0842   0841 FD 77         inc b
0843   0843 FA FD FF      lea d, [bp + -3] ; $format_p
0844   0846 FD 43         mov [d], b
0845   0848 FD 7D         dec b
0846   084A             ; switch(*format_p){ 
0847   084A             _switch5_expr:
0848   084A FA FD FF      lea d, [bp + -3] ; $format_p
0849   084D 2A            mov b, [d]
0850   084E 38 00 00      mov c, 0
0851   0851 74            mov d, b
0852   0852 32            mov bl, [d]
0853   0853 A7 00         mov bh, 0
0854   0855 38 00 00      mov c, 0
0855   0858             _switch5_comparisons:
0856   0858 C1 6C         cmp bl, $6c
0857   085A C6 86 08      je _switch5_case0
0858   085D C1 4C         cmp bl, $4c
0859   085F C6 86 08      je _switch5_case1
0860   0862 C1 64         cmp bl, $64
0861   0864 C6 96 09      je _switch5_case2
0862   0867 C1 69         cmp bl, $69
0863   0869 C6 96 09      je _switch5_case3
0864   086C C1 75         cmp bl, $75
0865   086E C6 C6 09      je _switch5_case4
0866   0871 C1 78         cmp bl, $78
0867   0873 C6 F6 09      je _switch5_case5
0868   0876 C1 63         cmp bl, $63
0869   0878 C6 26 0A      je _switch5_case6
0870   087B C1 73         cmp bl, $73
0871   087D C6 56 0A      je _switch5_case7
0872   0880 0A 83 0A      jmp _switch5_default
0873   0883 0A 8F 0A      jmp _switch5_exit
0874   0886             _switch5_case0:
0875   0886             _switch5_case1:
0876   0886             ; format_p++; 
0877   0886 FA FD FF      lea d, [bp + -3] ; $format_p
0878   0889 2A            mov b, [d]
0879   088A 38 00 00      mov c, 0
0880   088D FD 77         inc b
0881   088F FA FD FF      lea d, [bp + -3] ; $format_p
0882   0892 FD 43         mov [d], b
0883   0894 FD 7D         dec b
0884   0896             ; if(*format_p == 'd' || *format_p == 'i') 
0885   0896             _if6_cond:
0886   0896 FA FD FF      lea d, [bp + -3] ; $format_p
0887   0899 2A            mov b, [d]
0888   089A 38 00 00      mov c, 0
0889   089D 74            mov d, b
0890   089E 32            mov bl, [d]
0891   089F A7 00         mov bh, 0
0892   08A1 38 00 00      mov c, 0
0893   08A4             ; --- START RELATIONAL
0894   08A4 D7            push a
0895   08A5 11            mov a, b
0896   08A6 FD 2E 64 00   mov32 cb, $00000064
0896   08AA 00 00 
0897   08AC B0            cmp a, b
0898   08AD FD 71         seq ; ==
0899   08AF E4            pop a
0900   08B0             ; --- END RELATIONAL
0901   08B0             ; --- START LOGICAL OR
0902   08B0 D7            push a
0903   08B1 11            mov a, b
0904   08B2 FA FD FF      lea d, [bp + -3] ; $format_p
0905   08B5 2A            mov b, [d]
0906   08B6 38 00 00      mov c, 0
0907   08B9 74            mov d, b
0908   08BA 32            mov bl, [d]
0909   08BB A7 00         mov bh, 0
0910   08BD 38 00 00      mov c, 0
0911   08C0             ; --- START RELATIONAL
0912   08C0 D7            push a
0913   08C1 11            mov a, b
0914   08C2 FD 2E 69 00   mov32 cb, $00000069
0914   08C6 00 00 
0915   08C8 B0            cmp a, b
0916   08C9 FD 71         seq ; ==
0917   08CB E4            pop a
0918   08CC             ; --- END RELATIONAL
0919   08CC FD A8         sor a, b ; ||
0920   08CE E4            pop a
0921   08CF             ; --- END LOGICAL OR
0922   08CF C0 00 00      cmp b, 0
0923   08D2 C6 F3 08      je _if6_else
0924   08D5             _if6_TRUE:
0925   08D5             ; print_signed_long(*(long *)p); 
0926   08D5             ; --- START FUNCTION CALL
0927   08D5 FA FF FF      lea d, [bp + -1] ; $p
0928   08D8 2A            mov b, [d]
0929   08D9 38 00 00      mov c, 0
0930   08DC 74            mov d, b
0931   08DD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0932   08E0 FD 39         mov c, b ; And place it into C
0933   08E2 2A            mov b, [d] ; Lower Word in B
0934   08E3 12            mov a, c
0935   08E4 FD AA         swp a
0936   08E6 D7            push a
0937   08E7 FD AB         swp b
0938   08E9 D8            push b
0939   08EA 07 CC 0A      call print_signed_long
0940   08ED 51 04 00      add sp, 4
0941   08F0             ; --- END FUNCTION CALL
0942   08F0 0A 7B 09      jmp _if6_exit
0943   08F3             _if6_else:
0944   08F3             ; if(*format_p == 'u') 
0945   08F3             _if7_cond:
0946   08F3 FA FD FF      lea d, [bp + -3] ; $format_p
0947   08F6 2A            mov b, [d]
0948   08F7 38 00 00      mov c, 0
0949   08FA 74            mov d, b
0950   08FB 32            mov bl, [d]
0951   08FC A7 00         mov bh, 0
0952   08FE 38 00 00      mov c, 0
0953   0901             ; --- START RELATIONAL
0954   0901 D7            push a
0955   0902 11            mov a, b
0956   0903 FD 2E 75 00   mov32 cb, $00000075
0956   0907 00 00 
0957   0909 B0            cmp a, b
0958   090A FD 71         seq ; ==
0959   090C E4            pop a
0960   090D             ; --- END RELATIONAL
0961   090D C0 00 00      cmp b, 0
0962   0910 C6 31 09      je _if7_else
0963   0913             _if7_TRUE:
0964   0913             ; print_unsigned_long(*(unsigned long *)p); 
0965   0913             ; --- START FUNCTION CALL
0966   0913 FA FF FF      lea d, [bp + -1] ; $p
0967   0916 2A            mov b, [d]
0968   0917 38 00 00      mov c, 0
0969   091A 74            mov d, b
0970   091B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0971   091E FD 39         mov c, b ; And place it into C
0972   0920 2A            mov b, [d] ; Lower Word in B
0973   0921 12            mov a, c
0974   0922 FD AA         swp a
0975   0924 D7            push a
0976   0925 FD AB         swp b
0977   0927 D8            push b
0978   0928 07 5F 0C      call print_unsigned_long
0979   092B 51 04 00      add sp, 4
0980   092E             ; --- END FUNCTION CALL
0981   092E 0A 7B 09      jmp _if7_exit
0982   0931             _if7_else:
0983   0931             ; if(*format_p == 'x') 
0984   0931             _if8_cond:
0985   0931 FA FD FF      lea d, [bp + -3] ; $format_p
0986   0934 2A            mov b, [d]
0987   0935 38 00 00      mov c, 0
0988   0938 74            mov d, b
0989   0939 32            mov bl, [d]
0990   093A A7 00         mov bh, 0
0991   093C 38 00 00      mov c, 0
0992   093F             ; --- START RELATIONAL
0993   093F D7            push a
0994   0940 11            mov a, b
0995   0941 FD 2E 78 00   mov32 cb, $00000078
0995   0945 00 00 
0996   0947 B0            cmp a, b
0997   0948 FD 71         seq ; ==
0998   094A E4            pop a
0999   094B             ; --- END RELATIONAL
1000   094B C0 00 00      cmp b, 0
1001   094E C6 6F 09      je _if8_else
1002   0951             _if8_TRUE:
1003   0951             ; printx32(*(long int *)p); 
1004   0951             ; --- START FUNCTION CALL
1005   0951 FA FF FF      lea d, [bp + -1] ; $p
1006   0954 2A            mov b, [d]
1007   0955 38 00 00      mov c, 0
1008   0958 74            mov d, b
1009   0959 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1010   095C FD 39         mov c, b ; And place it into C
1011   095E 2A            mov b, [d] ; Lower Word in B
1012   095F 12            mov a, c
1013   0960 FD AA         swp a
1014   0962 D7            push a
1015   0963 FD AB         swp b
1016   0965 D8            push b
1017   0966 07 93 0D      call printx32
1018   0969 51 04 00      add sp, 4
1019   096C             ; --- END FUNCTION CALL
1020   096C 0A 7B 09      jmp _if8_exit
1021   096F             _if8_else:
1022   096F             ; err("Unexpected format in printf."); 
1023   096F             ; --- START FUNCTION CALL
1024   096F 26 18 11      mov b, _s1 ; "Unexpected format in printf."
1025   0972 FD AB         swp b
1026   0974 D8            push b
1027   0975 07 F3 0D      call err
1028   0978 51 02 00      add sp, 2
1029   097B             ; --- END FUNCTION CALL
1030   097B             _if8_exit:
1031   097B             _if7_exit:
1032   097B             _if6_exit:
1033   097B             ; p = p + 4; 
1034   097B FA FF FF      lea d, [bp + -1] ; $p
1035   097E DA            push d
1036   097F FA FF FF      lea d, [bp + -1] ; $p
1037   0982 2A            mov b, [d]
1038   0983 38 00 00      mov c, 0
1039   0986             ; --- START TERMS
1040   0986 D7            push a
1041   0987 11            mov a, b
1042   0988 FD 2E 04 00   mov32 cb, $00000004
1042   098C 00 00 
1043   098E 56            add b, a
1044   098F E4            pop a
1045   0990             ; --- END TERMS
1046   0990 E7            pop d
1047   0991 FD 43         mov [d], b
1048   0993             ; break; 
1049   0993 0A 8F 0A      jmp _switch5_exit ; case break
1050   0996             _switch5_case2:
1051   0996             _switch5_case3:
1052   0996             ; print_signed(*(int*)p); 
1053   0996             ; --- START FUNCTION CALL
1054   0996 FA FF FF      lea d, [bp + -1] ; $p
1055   0999 2A            mov b, [d]
1056   099A 38 00 00      mov c, 0
1057   099D 74            mov d, b
1058   099E 2A            mov b, [d]
1059   099F 38 00 00      mov c, 0
1060   09A2 FD AB         swp b
1061   09A4 D8            push b
1062   09A5 07 21 0E      call print_signed
1063   09A8 51 02 00      add sp, 2
1064   09AB             ; --- END FUNCTION CALL
1065   09AB             ; p = p + 2; 
1066   09AB FA FF FF      lea d, [bp + -1] ; $p
1067   09AE DA            push d
1068   09AF FA FF FF      lea d, [bp + -1] ; $p
1069   09B2 2A            mov b, [d]
1070   09B3 38 00 00      mov c, 0
1071   09B6             ; --- START TERMS
1072   09B6 D7            push a
1073   09B7 11            mov a, b
1074   09B8 FD 2E 02 00   mov32 cb, $00000002
1074   09BC 00 00 
1075   09BE 56            add b, a
1076   09BF E4            pop a
1077   09C0             ; --- END TERMS
1078   09C0 E7            pop d
1079   09C1 FD 43         mov [d], b
1080   09C3             ; break; 
1081   09C3 0A 8F 0A      jmp _switch5_exit ; case break
1082   09C6             _switch5_case4:
1083   09C6             ; print_unsigned(*(unsigned int*)p); 
1084   09C6             ; --- START FUNCTION CALL
1085   09C6 FA FF FF      lea d, [bp + -1] ; $p
1086   09C9 2A            mov b, [d]
1087   09CA 38 00 00      mov c, 0
1088   09CD 74            mov d, b
1089   09CE 2A            mov b, [d]
1090   09CF 38 00 00      mov c, 0
1091   09D2 FD AB         swp b
1092   09D4 D8            push b
1093   09D5 07 72 0F      call print_unsigned
1094   09D8 51 02 00      add sp, 2
1095   09DB             ; --- END FUNCTION CALL
1096   09DB             ; p = p + 2; 
1097   09DB FA FF FF      lea d, [bp + -1] ; $p
1098   09DE DA            push d
1099   09DF FA FF FF      lea d, [bp + -1] ; $p
1100   09E2 2A            mov b, [d]
1101   09E3 38 00 00      mov c, 0
1102   09E6             ; --- START TERMS
1103   09E6 D7            push a
1104   09E7 11            mov a, b
1105   09E8 FD 2E 02 00   mov32 cb, $00000002
1105   09EC 00 00 
1106   09EE 56            add b, a
1107   09EF E4            pop a
1108   09F0             ; --- END TERMS
1109   09F0 E7            pop d
1110   09F1 FD 43         mov [d], b
1111   09F3             ; break; 
1112   09F3 0A 8F 0A      jmp _switch5_exit ; case break
1113   09F6             _switch5_case5:
1114   09F6             ; printx16(*(int*)p); 
1115   09F6             ; --- START FUNCTION CALL
1116   09F6 FA FF FF      lea d, [bp + -1] ; $p
1117   09F9 2A            mov b, [d]
1118   09FA 38 00 00      mov c, 0
1119   09FD 74            mov d, b
1120   09FE 2A            mov b, [d]
1121   09FF 38 00 00      mov c, 0
1122   0A02 FD AB         swp b
1123   0A04 D8            push b
1124   0A05 07 8A 10      call printx16
1125   0A08 51 02 00      add sp, 2
1126   0A0B             ; --- END FUNCTION CALL
1127   0A0B             ; p = p + 2; 
1128   0A0B FA FF FF      lea d, [bp + -1] ; $p
1129   0A0E DA            push d
1130   0A0F FA FF FF      lea d, [bp + -1] ; $p
1131   0A12 2A            mov b, [d]
1132   0A13 38 00 00      mov c, 0
1133   0A16             ; --- START TERMS
1134   0A16 D7            push a
1135   0A17 11            mov a, b
1136   0A18 FD 2E 02 00   mov32 cb, $00000002
1136   0A1C 00 00 
1137   0A1E 56            add b, a
1138   0A1F E4            pop a
1139   0A20             ; --- END TERMS
1140   0A20 E7            pop d
1141   0A21 FD 43         mov [d], b
1142   0A23             ; break; 
1143   0A23 0A 8F 0A      jmp _switch5_exit ; case break
1144   0A26             _switch5_case6:
1145   0A26             ; putchar(*(char*)p); 
1146   0A26             ; --- START FUNCTION CALL
1147   0A26 FA FF FF      lea d, [bp + -1] ; $p
1148   0A29 2A            mov b, [d]
1149   0A2A 38 00 00      mov c, 0
1150   0A2D 74            mov d, b
1151   0A2E 32            mov bl, [d]
1152   0A2F A7 00         mov bh, 0
1153   0A31 38 00 00      mov c, 0
1154   0A34 DD            push bl
1155   0A35 07 51 0C      call putchar
1156   0A38 51 01 00      add sp, 1
1157   0A3B             ; --- END FUNCTION CALL
1158   0A3B             ; p = p + 2; 
1159   0A3B FA FF FF      lea d, [bp + -1] ; $p
1160   0A3E DA            push d
1161   0A3F FA FF FF      lea d, [bp + -1] ; $p
1162   0A42 2A            mov b, [d]
1163   0A43 38 00 00      mov c, 0
1164   0A46             ; --- START TERMS
1165   0A46 D7            push a
1166   0A47 11            mov a, b
1167   0A48 FD 2E 02 00   mov32 cb, $00000002
1167   0A4C 00 00 
1168   0A4E 56            add b, a
1169   0A4F E4            pop a
1170   0A50             ; --- END TERMS
1171   0A50 E7            pop d
1172   0A51 FD 43         mov [d], b
1173   0A53             ; break; 
1174   0A53 0A 8F 0A      jmp _switch5_exit ; case break
1175   0A56             _switch5_case7:
1176   0A56             ; print(*(char**)p); 
1177   0A56             ; --- START FUNCTION CALL
1178   0A56 FA FF FF      lea d, [bp + -1] ; $p
1179   0A59 2A            mov b, [d]
1180   0A5A 38 00 00      mov c, 0
1181   0A5D 74            mov d, b
1182   0A5E 2A            mov b, [d]
1183   0A5F FD AB         swp b
1184   0A61 D8            push b
1185   0A62 07 08 0E      call print
1186   0A65 51 02 00      add sp, 2
1187   0A68             ; --- END FUNCTION CALL
1188   0A68             ; p = p + 2; 
1189   0A68 FA FF FF      lea d, [bp + -1] ; $p
1190   0A6B DA            push d
1191   0A6C FA FF FF      lea d, [bp + -1] ; $p
1192   0A6F 2A            mov b, [d]
1193   0A70 38 00 00      mov c, 0
1194   0A73             ; --- START TERMS
1195   0A73 D7            push a
1196   0A74 11            mov a, b
1197   0A75 FD 2E 02 00   mov32 cb, $00000002
1197   0A79 00 00 
1198   0A7B 56            add b, a
1199   0A7C E4            pop a
1200   0A7D             ; --- END TERMS
1201   0A7D E7            pop d
1202   0A7E FD 43         mov [d], b
1203   0A80             ; break; 
1204   0A80 0A 8F 0A      jmp _switch5_exit ; case break
1205   0A83             _switch5_default:
1206   0A83             ; print("Error: Unknown argument type.\n"); 
1207   0A83             ; --- START FUNCTION CALL
1208   0A83 26 35 11      mov b, _s2 ; "Error: Unknown argument type.\n"
1209   0A86 FD AB         swp b
1210   0A88 D8            push b
1211   0A89 07 08 0E      call print
1212   0A8C 51 02 00      add sp, 2
1213   0A8F             ; --- END FUNCTION CALL
1214   0A8F             _switch5_exit:
1215   0A8F             ; format_p++; 
1216   0A8F FA FD FF      lea d, [bp + -3] ; $format_p
1217   0A92 2A            mov b, [d]
1218   0A93 38 00 00      mov c, 0
1219   0A96 FD 77         inc b
1220   0A98 FA FD FF      lea d, [bp + -3] ; $format_p
1221   0A9B FD 43         mov [d], b
1222   0A9D FD 7D         dec b
1223   0A9F 0A C7 0A      jmp _if4_exit
1224   0AA2             _if4_else:
1225   0AA2             ; putchar(*format_p); 
1226   0AA2             ; --- START FUNCTION CALL
1227   0AA2 FA FD FF      lea d, [bp + -3] ; $format_p
1228   0AA5 2A            mov b, [d]
1229   0AA6 38 00 00      mov c, 0
1230   0AA9 74            mov d, b
1231   0AAA 32            mov bl, [d]
1232   0AAB A7 00         mov bh, 0
1233   0AAD 38 00 00      mov c, 0
1234   0AB0 DD            push bl
1235   0AB1 07 51 0C      call putchar
1236   0AB4 51 01 00      add sp, 1
1237   0AB7             ; --- END FUNCTION CALL
1238   0AB7             ; format_p++; 
1239   0AB7 FA FD FF      lea d, [bp + -3] ; $format_p
1240   0ABA 2A            mov b, [d]
1241   0ABB 38 00 00      mov c, 0
1242   0ABE FD 77         inc b
1243   0AC0 FA FD FF      lea d, [bp + -3] ; $format_p
1244   0AC3 FD 43         mov [d], b
1245   0AC5 FD 7D         dec b
1246   0AC7             _if4_exit:
1247   0AC7             _if3_exit:
1248   0AC7             _for2_update:
1249   0AC7 0A FB 07      jmp _for2_cond
1250   0ACA             _for2_exit:
1251   0ACA F9            leave
1252   0ACB 09            ret
1253   0ACC             
1254   0ACC             print_signed_long:
1255   0ACC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1256   0ACF             ; char digits[10]; 
1257   0ACF 52 0A 00      sub sp, 10
1258   0AD2             ; int i = 0; 
1259   0AD2 52 02 00      sub sp, 2
1260   0AD5             ; --- START LOCAL VAR INITIALIZATION
1261   0AD5 FA F5 FF      lea d, [bp + -11] ; $i
1262   0AD8 DA            push d
1263   0AD9 FD 2E 00 00   mov32 cb, $00000000
1263   0ADD 00 00 
1264   0ADF E7            pop d
1265   0AE0 FD 43         mov [d], b
1266   0AE2             ; --- END LOCAL VAR INITIALIZATION
1267   0AE2             ; if (num < 0) { 
1268   0AE2             _if9_cond:
1269   0AE2 FA 05 00      lea d, [bp + 5] ; $num
1270   0AE5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1271   0AE8 FD 39         mov c, b ; And place it into C
1272   0AEA 2A            mov b, [d] ; Lower Word in B
1273   0AEB             ; --- START RELATIONAL
1274   0AEB D7            push a
1275   0AEC FD D8         push g
1276   0AEE 11            mov a, b
1277   0AEF FD 7A         mov g, c
1278   0AF1 FD 2E 00 00   mov32 cb, $00000000
1278   0AF5 00 00 
1279   0AF7 FD AF         cmp32 ga, cb
1280   0AF9 FD 73         slt ; <
1281   0AFB FD F1         pop g
1282   0AFD E4            pop a
1283   0AFE             ; --- END RELATIONAL
1284   0AFE C0 00 00      cmp b, 0
1285   0B01 C6 33 0B      je _if9_else
1286   0B04             _if9_TRUE:
1287   0B04             ; putchar('-'); 
1288   0B04             ; --- START FUNCTION CALL
1289   0B04 FD 2E 2D 00   mov32 cb, $0000002d
1289   0B08 00 00 
1290   0B0A DD            push bl
1291   0B0B 07 51 0C      call putchar
1292   0B0E 51 01 00      add sp, 1
1293   0B11             ; --- END FUNCTION CALL
1294   0B11             ; num = -num; 
1295   0B11 FA 05 00      lea d, [bp + 5] ; $num
1296   0B14 DA            push d
1297   0B15 FA 05 00      lea d, [bp + 5] ; $num
1298   0B18 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1299   0B1B FD 39         mov c, b ; And place it into C
1300   0B1D 2A            mov b, [d] ; Lower Word in B
1301   0B1E 12            mov a, c
1302   0B1F 95            not a
1303   0B20 97            not b
1304   0B21 55 01 00      add b, 1
1305   0B24 5B 00 00      adc a, 0
1306   0B27 39            mov c, a
1307   0B28 E7            pop d
1308   0B29 FD 43         mov [d], b
1309   0B2B 28            mov b, c
1310   0B2C FD 44 02 00   mov [d + 2], b
1311   0B30 0A 67 0B      jmp _if9_exit
1312   0B33             _if9_else:
1313   0B33             ; if (num == 0) { 
1314   0B33             _if10_cond:
1315   0B33 FA 05 00      lea d, [bp + 5] ; $num
1316   0B36 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1317   0B39 FD 39         mov c, b ; And place it into C
1318   0B3B 2A            mov b, [d] ; Lower Word in B
1319   0B3C             ; --- START RELATIONAL
1320   0B3C D7            push a
1321   0B3D FD D8         push g
1322   0B3F 11            mov a, b
1323   0B40 FD 7A         mov g, c
1324   0B42 FD 2E 00 00   mov32 cb, $00000000
1324   0B46 00 00 
1325   0B48 FD AF         cmp32 ga, cb
1326   0B4A FD 71         seq ; ==
1327   0B4C FD F1         pop g
1328   0B4E E4            pop a
1329   0B4F             ; --- END RELATIONAL
1330   0B4F C0 00 00      cmp b, 0
1331   0B52 C6 67 0B      je _if10_exit
1332   0B55             _if10_TRUE:
1333   0B55             ; putchar('0'); 
1334   0B55             ; --- START FUNCTION CALL
1335   0B55 FD 2E 30 00   mov32 cb, $00000030
1335   0B59 00 00 
1336   0B5B DD            push bl
1337   0B5C 07 51 0C      call putchar
1338   0B5F 51 01 00      add sp, 1
1339   0B62             ; --- END FUNCTION CALL
1340   0B62             ; return; 
1341   0B62 F9            leave
1342   0B63 09            ret
1343   0B64 0A 67 0B      jmp _if10_exit
1344   0B67             _if10_exit:
1345   0B67             _if9_exit:
1346   0B67             ; while (num > 0) { 
1347   0B67             _while11_cond:
1348   0B67 FA 05 00      lea d, [bp + 5] ; $num
1349   0B6A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1350   0B6D FD 39         mov c, b ; And place it into C
1351   0B6F 2A            mov b, [d] ; Lower Word in B
1352   0B70             ; --- START RELATIONAL
1353   0B70 D7            push a
1354   0B71 FD D8         push g
1355   0B73 11            mov a, b
1356   0B74 FD 7A         mov g, c
1357   0B76 FD 2E 00 00   mov32 cb, $00000000
1357   0B7A 00 00 
1358   0B7C FD AF         cmp32 ga, cb
1359   0B7E FD 7F         sgt
1360   0B80 FD F1         pop g
1361   0B82 E4            pop a
1362   0B83             ; --- END RELATIONAL
1363   0B83 C0 00 00      cmp b, 0
1364   0B86 C6 07 0C      je _while11_exit
1365   0B89             _while11_block:
1366   0B89             ; digits[i] = '0' + (num % 10); 
1367   0B89 FA F7 FF      lea d, [bp + -9] ; $digits
1368   0B8C D7            push a
1369   0B8D DA            push d
1370   0B8E FA F5 FF      lea d, [bp + -11] ; $i
1371   0B91 2A            mov b, [d]
1372   0B92 38 00 00      mov c, 0
1373   0B95 E7            pop d
1374   0B96 5A            add d, b
1375   0B97 E4            pop a
1376   0B98 DA            push d
1377   0B99 FD 2E 30 00   mov32 cb, $00000030
1377   0B9D 00 00 
1378   0B9F             ; --- START TERMS
1379   0B9F D7            push a
1380   0BA0 11            mov a, b
1381   0BA1 FA 05 00      lea d, [bp + 5] ; $num
1382   0BA4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1383   0BA7 FD 39         mov c, b ; And place it into C
1384   0BA9 2A            mov b, [d] ; Lower Word in B
1385   0BAA             ; --- START FACTORS
1386   0BAA D7            push a
1387   0BAB FD D8         push g
1388   0BAD 11            mov a, b
1389   0BAE FD 7A         mov g, c
1390   0BB0 FD 2E 0A 00   mov32 cb, $0000000a
1390   0BB4 00 00 
1391   0BB6 FD D8         push g ; save 'g' as the div instruction uses it
1392   0BB8 AE            div a, b ; %, a: quotient, b: remainder
1393   0BB9 11            mov a, b
1394   0BBA FD F1         pop g
1395   0BBC FD 38         mov c, g
1396   0BBE 27            mov b, a
1397   0BBF FD F1         pop g
1398   0BC1 E4            pop a
1399   0BC2             ; --- END FACTORS
1400   0BC2 FD 15         add32 cb, ga
1401   0BC4 E4            pop a
1402   0BC5             ; --- END TERMS
1403   0BC5 E7            pop d
1404   0BC6 FD 3E         mov [d], bl
1405   0BC8             ; num = num / 10; 
1406   0BC8 FA 05 00      lea d, [bp + 5] ; $num
1407   0BCB DA            push d
1408   0BCC FA 05 00      lea d, [bp + 5] ; $num
1409   0BCF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1410   0BD2 FD 39         mov c, b ; And place it into C
1411   0BD4 2A            mov b, [d] ; Lower Word in B
1412   0BD5             ; --- START FACTORS
1413   0BD5 D7            push a
1414   0BD6 FD D8         push g
1415   0BD8 11            mov a, b
1416   0BD9 FD 7A         mov g, c
1417   0BDB FD 2E 0A 00   mov32 cb, $0000000a
1417   0BDF 00 00 
1418   0BE1 FD D8         push g ; save 'g' as the div instruction uses it
1419   0BE3 AE            div a, b ; /, a: quotient, b: remainder
1420   0BE4 FD F1         pop g
1421   0BE6 FD 38         mov c, g
1422   0BE8 27            mov b, a
1423   0BE9 FD F1         pop g
1424   0BEB E4            pop a
1425   0BEC             ; --- END FACTORS
1426   0BEC E7            pop d
1427   0BED FD 43         mov [d], b
1428   0BEF 28            mov b, c
1429   0BF0 FD 44 02 00   mov [d + 2], b
1430   0BF4             ; i++; 
1431   0BF4 FA F5 FF      lea d, [bp + -11] ; $i
1432   0BF7 2A            mov b, [d]
1433   0BF8 38 00 00      mov c, 0
1434   0BFB 11            mov a, b
1435   0BFC FD 77         inc b
1436   0BFE FA F5 FF      lea d, [bp + -11] ; $i
1437   0C01 FD 43         mov [d], b
1438   0C03 27            mov b, a
1439   0C04 0A 67 0B      jmp _while11_cond
1440   0C07             _while11_exit:
1441   0C07             ; while (i > 0) { 
1442   0C07             _while18_cond:
1443   0C07 FA F5 FF      lea d, [bp + -11] ; $i
1444   0C0A 2A            mov b, [d]
1445   0C0B 38 00 00      mov c, 0
1446   0C0E             ; --- START RELATIONAL
1447   0C0E D7            push a
1448   0C0F 11            mov a, b
1449   0C10 FD 2E 00 00   mov32 cb, $00000000
1449   0C14 00 00 
1450   0C16 B0            cmp a, b
1451   0C17 FD 7F         sgt ; >
1452   0C19 E4            pop a
1453   0C1A             ; --- END RELATIONAL
1454   0C1A C0 00 00      cmp b, 0
1455   0C1D C6 4F 0C      je _while18_exit
1456   0C20             _while18_block:
1457   0C20             ; i--; 
1458   0C20 FA F5 FF      lea d, [bp + -11] ; $i
1459   0C23 2A            mov b, [d]
1460   0C24 38 00 00      mov c, 0
1461   0C27 11            mov a, b
1462   0C28 FD 7D         dec b
1463   0C2A FA F5 FF      lea d, [bp + -11] ; $i
1464   0C2D FD 43         mov [d], b
1465   0C2F 27            mov b, a
1466   0C30             ; putchar(digits[i]); 
1467   0C30             ; --- START FUNCTION CALL
1468   0C30 FA F7 FF      lea d, [bp + -9] ; $digits
1469   0C33 D7            push a
1470   0C34 DA            push d
1471   0C35 FA F5 FF      lea d, [bp + -11] ; $i
1472   0C38 2A            mov b, [d]
1473   0C39 38 00 00      mov c, 0
1474   0C3C E7            pop d
1475   0C3D 5A            add d, b
1476   0C3E E4            pop a
1477   0C3F 32            mov bl, [d]
1478   0C40 A7 00         mov bh, 0
1479   0C42 38 00 00      mov c, 0
1480   0C45 DD            push bl
1481   0C46 07 51 0C      call putchar
1482   0C49 51 01 00      add sp, 1
1483   0C4C             ; --- END FUNCTION CALL
1484   0C4C 0A 07 0C      jmp _while18_cond
1485   0C4F             _while18_exit:
1486   0C4F F9            leave
1487   0C50 09            ret
1488   0C51             
1489   0C51             putchar:
1490   0C51 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1491   0C54             ; --- BEGIN INLINE ASM SEGMENT
1492   0C54 FA 05 00      lea d, [bp + 5] ; $c
1493   0C57 1E            mov al, [d]
1494   0C58 23            mov ah, al
1495   0C59 19 00         mov al, 0
1496   0C5B 05 03         syscall sys_io      ; char in AH
1497   0C5D             ; --- END INLINE ASM SEGMENT
1498   0C5D F9            leave
1499   0C5E 09            ret
1500   0C5F             
1501   0C5F             print_unsigned_long:
1502   0C5F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1503   0C62             ; char digits[10]; 
1504   0C62 52 0A 00      sub sp, 10
1505   0C65             ; int i; 
1506   0C65 52 02 00      sub sp, 2
1507   0C68             ; i = 0; 
1508   0C68 FA F5 FF      lea d, [bp + -11] ; $i
1509   0C6B DA            push d
1510   0C6C FD 2E 00 00   mov32 cb, $00000000
1510   0C70 00 00 
1511   0C72 E7            pop d
1512   0C73 FD 43         mov [d], b
1513   0C75             ; if(num == 0){ 
1514   0C75             _if19_cond:
1515   0C75 FA 05 00      lea d, [bp + 5] ; $num
1516   0C78 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1517   0C7B FD 39         mov c, b ; And place it into C
1518   0C7D 2A            mov b, [d] ; Lower Word in B
1519   0C7E             ; --- START RELATIONAL
1520   0C7E D7            push a
1521   0C7F FD D8         push g
1522   0C81 11            mov a, b
1523   0C82 FD 7A         mov g, c
1524   0C84 FD 2E 00 00   mov32 cb, $00000000
1524   0C88 00 00 
1525   0C8A FD AF         cmp32 ga, cb
1526   0C8C FD 71         seq ; ==
1527   0C8E FD F1         pop g
1528   0C90 E4            pop a
1529   0C91             ; --- END RELATIONAL
1530   0C91 C0 00 00      cmp b, 0
1531   0C94 C6 A9 0C      je _if19_exit
1532   0C97             _if19_TRUE:
1533   0C97             ; putchar('0'); 
1534   0C97             ; --- START FUNCTION CALL
1535   0C97 FD 2E 30 00   mov32 cb, $00000030
1535   0C9B 00 00 
1536   0C9D DD            push bl
1537   0C9E 07 51 0C      call putchar
1538   0CA1 51 01 00      add sp, 1
1539   0CA4             ; --- END FUNCTION CALL
1540   0CA4             ; return; 
1541   0CA4 F9            leave
1542   0CA5 09            ret
1543   0CA6 0A A9 0C      jmp _if19_exit
1544   0CA9             _if19_exit:
1545   0CA9             ; while (num > 0) { 
1546   0CA9             _while20_cond:
1547   0CA9 FA 05 00      lea d, [bp + 5] ; $num
1548   0CAC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1549   0CAF FD 39         mov c, b ; And place it into C
1550   0CB1 2A            mov b, [d] ; Lower Word in B
1551   0CB2             ; --- START RELATIONAL
1552   0CB2 D7            push a
1553   0CB3 FD D8         push g
1554   0CB5 11            mov a, b
1555   0CB6 FD 7A         mov g, c
1556   0CB8 FD 2E 00 00   mov32 cb, $00000000
1556   0CBC 00 00 
1557   0CBE FD AF         cmp32 ga, cb
1558   0CC0 FD 81         sgu
1559   0CC2 FD F1         pop g
1560   0CC4 E4            pop a
1561   0CC5             ; --- END RELATIONAL
1562   0CC5 C0 00 00      cmp b, 0
1563   0CC8 C6 49 0D      je _while20_exit
1564   0CCB             _while20_block:
1565   0CCB             ; digits[i] = '0' + (num % 10); 
1566   0CCB FA F7 FF      lea d, [bp + -9] ; $digits
1567   0CCE D7            push a
1568   0CCF DA            push d
1569   0CD0 FA F5 FF      lea d, [bp + -11] ; $i
1570   0CD3 2A            mov b, [d]
1571   0CD4 38 00 00      mov c, 0
1572   0CD7 E7            pop d
1573   0CD8 5A            add d, b
1574   0CD9 E4            pop a
1575   0CDA DA            push d
1576   0CDB FD 2E 30 00   mov32 cb, $00000030
1576   0CDF 00 00 
1577   0CE1             ; --- START TERMS
1578   0CE1 D7            push a
1579   0CE2 11            mov a, b
1580   0CE3 FA 05 00      lea d, [bp + 5] ; $num
1581   0CE6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1582   0CE9 FD 39         mov c, b ; And place it into C
1583   0CEB 2A            mov b, [d] ; Lower Word in B
1584   0CEC             ; --- START FACTORS
1585   0CEC D7            push a
1586   0CED FD D8         push g
1587   0CEF 11            mov a, b
1588   0CF0 FD 7A         mov g, c
1589   0CF2 FD 2E 0A 00   mov32 cb, $0000000a
1589   0CF6 00 00 
1590   0CF8 FD D8         push g ; save 'g' as the div instruction uses it
1591   0CFA AE            div a, b ; %, a: quotient, b: remainder
1592   0CFB 11            mov a, b
1593   0CFC FD F1         pop g
1594   0CFE FD 38         mov c, g
1595   0D00 27            mov b, a
1596   0D01 FD F1         pop g
1597   0D03 E4            pop a
1598   0D04             ; --- END FACTORS
1599   0D04 FD 15         add32 cb, ga
1600   0D06 E4            pop a
1601   0D07             ; --- END TERMS
1602   0D07 E7            pop d
1603   0D08 FD 3E         mov [d], bl
1604   0D0A             ; num = num / 10; 
1605   0D0A FA 05 00      lea d, [bp + 5] ; $num
1606   0D0D DA            push d
1607   0D0E FA 05 00      lea d, [bp + 5] ; $num
1608   0D11 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1609   0D14 FD 39         mov c, b ; And place it into C
1610   0D16 2A            mov b, [d] ; Lower Word in B
1611   0D17             ; --- START FACTORS
1612   0D17 D7            push a
1613   0D18 FD D8         push g
1614   0D1A 11            mov a, b
1615   0D1B FD 7A         mov g, c
1616   0D1D FD 2E 0A 00   mov32 cb, $0000000a
1616   0D21 00 00 
1617   0D23 FD D8         push g ; save 'g' as the div instruction uses it
1618   0D25 AE            div a, b ; /, a: quotient, b: remainder
1619   0D26 FD F1         pop g
1620   0D28 FD 38         mov c, g
1621   0D2A 27            mov b, a
1622   0D2B FD F1         pop g
1623   0D2D E4            pop a
1624   0D2E             ; --- END FACTORS
1625   0D2E E7            pop d
1626   0D2F FD 43         mov [d], b
1627   0D31 28            mov b, c
1628   0D32 FD 44 02 00   mov [d + 2], b
1629   0D36             ; i++; 
1630   0D36 FA F5 FF      lea d, [bp + -11] ; $i
1631   0D39 2A            mov b, [d]
1632   0D3A 38 00 00      mov c, 0
1633   0D3D 11            mov a, b
1634   0D3E FD 77         inc b
1635   0D40 FA F5 FF      lea d, [bp + -11] ; $i
1636   0D43 FD 43         mov [d], b
1637   0D45 27            mov b, a
1638   0D46 0A A9 0C      jmp _while20_cond
1639   0D49             _while20_exit:
1640   0D49             ; while (i > 0) { 
1641   0D49             _while27_cond:
1642   0D49 FA F5 FF      lea d, [bp + -11] ; $i
1643   0D4C 2A            mov b, [d]
1644   0D4D 38 00 00      mov c, 0
1645   0D50             ; --- START RELATIONAL
1646   0D50 D7            push a
1647   0D51 11            mov a, b
1648   0D52 FD 2E 00 00   mov32 cb, $00000000
1648   0D56 00 00 
1649   0D58 B0            cmp a, b
1650   0D59 FD 7F         sgt ; >
1651   0D5B E4            pop a
1652   0D5C             ; --- END RELATIONAL
1653   0D5C C0 00 00      cmp b, 0
1654   0D5F C6 91 0D      je _while27_exit
1655   0D62             _while27_block:
1656   0D62             ; i--; 
1657   0D62 FA F5 FF      lea d, [bp + -11] ; $i
1658   0D65 2A            mov b, [d]
1659   0D66 38 00 00      mov c, 0
1660   0D69 11            mov a, b
1661   0D6A FD 7D         dec b
1662   0D6C FA F5 FF      lea d, [bp + -11] ; $i
1663   0D6F FD 43         mov [d], b
1664   0D71 27            mov b, a
1665   0D72             ; putchar(digits[i]); 
1666   0D72             ; --- START FUNCTION CALL
1667   0D72 FA F7 FF      lea d, [bp + -9] ; $digits
1668   0D75 D7            push a
1669   0D76 DA            push d
1670   0D77 FA F5 FF      lea d, [bp + -11] ; $i
1671   0D7A 2A            mov b, [d]
1672   0D7B 38 00 00      mov c, 0
1673   0D7E E7            pop d
1674   0D7F 5A            add d, b
1675   0D80 E4            pop a
1676   0D81 32            mov bl, [d]
1677   0D82 A7 00         mov bh, 0
1678   0D84 38 00 00      mov c, 0
1679   0D87 DD            push bl
1680   0D88 07 51 0C      call putchar
1681   0D8B 51 01 00      add sp, 1
1682   0D8E             ; --- END FUNCTION CALL
1683   0D8E 0A 49 0D      jmp _while27_cond
1684   0D91             _while27_exit:
1685   0D91 F9            leave
1686   0D92 09            ret
1687   0D93             
1688   0D93             printx32:
1689   0D93 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1690   0D96             ; --- BEGIN INLINE ASM SEGMENT
1691   0D96 FA 05 00      lea d, [bp + 5] ; $hex
1692   0D99 2B 02 00      mov b, [d+2]
1693   0D9C 07 A5 0D      call print_u16x_printx32
1694   0D9F 2A            mov b, [d]
1695   0DA0 07 A5 0D      call print_u16x_printx32
1696   0DA3             ; --- END INLINE ASM SEGMENT
1697   0DA3             ; return; 
1698   0DA3 F9            leave
1699   0DA4 09            ret
1700   0DA5             ; --- BEGIN INLINE ASM SEGMENT
1701   0DA5             print_u16x_printx32:
1702   0DA5 D7            push a
1703   0DA6 D8            push b
1704   0DA7 DD            push bl
1705   0DA8 30            mov bl, bh
1706   0DA9 07 C7 0D      call _itoa_printx32        ; convert bh to char in A
1707   0DAC 2F            mov bl, al        ; save al
1708   0DAD 19 00         mov al, 0
1709   0DAF 05 03         syscall sys_io        ; display AH
1710   0DB1 24            mov ah, bl        ; retrieve al
1711   0DB2 19 00         mov al, 0
1712   0DB4 05 03         syscall sys_io        ; display AL
1713   0DB6 EA            pop bl
1714   0DB7 07 C7 0D      call _itoa_printx32        ; convert bh to char in A
1715   0DBA 2F            mov bl, al        ; save al
1716   0DBB 19 00         mov al, 0
1717   0DBD 05 03         syscall sys_io        ; display AH
1718   0DBF 24            mov ah, bl        ; retrieve al
1719   0DC0 19 00         mov al, 0
1720   0DC2 05 03         syscall sys_io        ; display AL
1721   0DC4 E5            pop b
1722   0DC5 E4            pop a
1723   0DC6 09            ret
1724   0DC7             _itoa_printx32:
1725   0DC7 DA            push d
1726   0DC8 D8            push b
1727   0DC9 A7 00         mov bh, 0
1728   0DCB FD A4 04      shr bl, 4  
1729   0DCE 74            mov d, b
1730   0DCF 1F E1 0D      mov al, [d + s_hex_digits_printx32]
1731   0DD2 23            mov ah, al
1732   0DD3 E5            pop b
1733   0DD4 D8            push b
1734   0DD5 A7 00         mov bh, 0
1735   0DD7 FD 87 0F      and bl, $0F
1736   0DDA 74            mov d, b
1737   0DDB 1F E1 0D      mov al, [d + s_hex_digits_printx32]
1738   0DDE E5            pop b
1739   0DDF E7            pop d
1740   0DE0 09            ret
1741   0DE1 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1741   0DE5 34 35 36 37 
1741   0DE9 38 39 41 42 
1741   0DED 43 44 45 46 
1742   0DF1             ; --- END INLINE ASM SEGMENT
1743   0DF1 F9            leave
1744   0DF2 09            ret
1745   0DF3             
1746   0DF3             err:
1747   0DF3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1748   0DF6             ; print(e); 
1749   0DF6             ; --- START FUNCTION CALL
1750   0DF6 FA 05 00      lea d, [bp + 5] ; $e
1751   0DF9 2A            mov b, [d]
1752   0DFA 38 00 00      mov c, 0
1753   0DFD FD AB         swp b
1754   0DFF D8            push b
1755   0E00 07 08 0E      call print
1756   0E03 51 02 00      add sp, 2
1757   0E06             ; --- END FUNCTION CALL
1758   0E06 F9            leave
1759   0E07 09            ret
1760   0E08             
1761   0E08             print:
1762   0E08 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1763   0E0B             ; --- BEGIN INLINE ASM SEGMENT
1764   0E0B FA 05 00      lea d, [bp + 5] ; $s
1765   0E0E FD 2A         mov d, [d]
1766   0E10             _puts_L1_print:
1767   0E10 1E            mov al, [d]
1768   0E11 B9 00         cmp al, 0
1769   0E13 C6 1F 0E      jz _puts_END_print
1770   0E16 23            mov ah, al
1771   0E17 19 00         mov al, 0
1772   0E19 05 03         syscall sys_io
1773   0E1B 79            inc d
1774   0E1C 0A 10 0E      jmp _puts_L1_print
1775   0E1F             _puts_END_print:
1776   0E1F             ; --- END INLINE ASM SEGMENT
1777   0E1F F9            leave
1778   0E20 09            ret
1779   0E21             
1780   0E21             print_signed:
1781   0E21 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1782   0E24             ; char digits[5]; 
1783   0E24 52 05 00      sub sp, 5
1784   0E27             ; int i = 0; 
1785   0E27 52 02 00      sub sp, 2
1786   0E2A             ; --- START LOCAL VAR INITIALIZATION
1787   0E2A FA FA FF      lea d, [bp + -6] ; $i
1788   0E2D DA            push d
1789   0E2E FD 2E 00 00   mov32 cb, $00000000
1789   0E32 00 00 
1790   0E34 E7            pop d
1791   0E35 FD 43         mov [d], b
1792   0E37             ; --- END LOCAL VAR INITIALIZATION
1793   0E37             ; if (num < 0) { 
1794   0E37             _if28_cond:
1795   0E37 FA 05 00      lea d, [bp + 5] ; $num
1796   0E3A 2A            mov b, [d]
1797   0E3B 38 00 00      mov c, 0
1798   0E3E             ; --- START RELATIONAL
1799   0E3E D7            push a
1800   0E3F 11            mov a, b
1801   0E40 FD 2E 00 00   mov32 cb, $00000000
1801   0E44 00 00 
1802   0E46 B0            cmp a, b
1803   0E47 FD 73         slt ; < (signed)
1804   0E49 E4            pop a
1805   0E4A             ; --- END RELATIONAL
1806   0E4A C0 00 00      cmp b, 0
1807   0E4D C6 70 0E      je _if28_else
1808   0E50             _if28_TRUE:
1809   0E50             ; putchar('-'); 
1810   0E50             ; --- START FUNCTION CALL
1811   0E50 FD 2E 2D 00   mov32 cb, $0000002d
1811   0E54 00 00 
1812   0E56 DD            push bl
1813   0E57 07 51 0C      call putchar
1814   0E5A 51 01 00      add sp, 1
1815   0E5D             ; --- END FUNCTION CALL
1816   0E5D             ; num = -num; 
1817   0E5D FA 05 00      lea d, [bp + 5] ; $num
1818   0E60 DA            push d
1819   0E61 FA 05 00      lea d, [bp + 5] ; $num
1820   0E64 2A            mov b, [d]
1821   0E65 38 00 00      mov c, 0
1822   0E68 FD 97         neg b
1823   0E6A E7            pop d
1824   0E6B FD 43         mov [d], b
1825   0E6D 0A 9B 0E      jmp _if28_exit
1826   0E70             _if28_else:
1827   0E70             ; if (num == 0) { 
1828   0E70             _if29_cond:
1829   0E70 FA 05 00      lea d, [bp + 5] ; $num
1830   0E73 2A            mov b, [d]
1831   0E74 38 00 00      mov c, 0
1832   0E77             ; --- START RELATIONAL
1833   0E77 D7            push a
1834   0E78 11            mov a, b
1835   0E79 FD 2E 00 00   mov32 cb, $00000000
1835   0E7D 00 00 
1836   0E7F B0            cmp a, b
1837   0E80 FD 71         seq ; ==
1838   0E82 E4            pop a
1839   0E83             ; --- END RELATIONAL
1840   0E83 C0 00 00      cmp b, 0
1841   0E86 C6 9B 0E      je _if29_exit
1842   0E89             _if29_TRUE:
1843   0E89             ; putchar('0'); 
1844   0E89             ; --- START FUNCTION CALL
1845   0E89 FD 2E 30 00   mov32 cb, $00000030
1845   0E8D 00 00 
1846   0E8F DD            push bl
1847   0E90 07 51 0C      call putchar
1848   0E93 51 01 00      add sp, 1
1849   0E96             ; --- END FUNCTION CALL
1850   0E96             ; return; 
1851   0E96 F9            leave
1852   0E97 09            ret
1853   0E98 0A 9B 0E      jmp _if29_exit
1854   0E9B             _if29_exit:
1855   0E9B             _if28_exit:
1856   0E9B             ; while (num > 0) { 
1857   0E9B             _while30_cond:
1858   0E9B FA 05 00      lea d, [bp + 5] ; $num
1859   0E9E 2A            mov b, [d]
1860   0E9F 38 00 00      mov c, 0
1861   0EA2             ; --- START RELATIONAL
1862   0EA2 D7            push a
1863   0EA3 11            mov a, b
1864   0EA4 FD 2E 00 00   mov32 cb, $00000000
1864   0EA8 00 00 
1865   0EAA B0            cmp a, b
1866   0EAB FD 7F         sgt ; >
1867   0EAD E4            pop a
1868   0EAE             ; --- END RELATIONAL
1869   0EAE C0 00 00      cmp b, 0
1870   0EB1 C6 28 0F      je _while30_exit
1871   0EB4             _while30_block:
1872   0EB4             ; digits[i] = '0' + (num % 10); 
1873   0EB4 FA FC FF      lea d, [bp + -4] ; $digits
1874   0EB7 D7            push a
1875   0EB8 DA            push d
1876   0EB9 FA FA FF      lea d, [bp + -6] ; $i
1877   0EBC 2A            mov b, [d]
1878   0EBD 38 00 00      mov c, 0
1879   0EC0 E7            pop d
1880   0EC1 5A            add d, b
1881   0EC2 E4            pop a
1882   0EC3 DA            push d
1883   0EC4 FD 2E 30 00   mov32 cb, $00000030
1883   0EC8 00 00 
1884   0ECA             ; --- START TERMS
1885   0ECA D7            push a
1886   0ECB 11            mov a, b
1887   0ECC FA 05 00      lea d, [bp + 5] ; $num
1888   0ECF 2A            mov b, [d]
1889   0ED0 38 00 00      mov c, 0
1890   0ED3             ; --- START FACTORS
1891   0ED3 D7            push a
1892   0ED4 FD D8         push g
1893   0ED6 11            mov a, b
1894   0ED7 FD 7A         mov g, c
1895   0ED9 FD 2E 0A 00   mov32 cb, $0000000a
1895   0EDD 00 00 
1896   0EDF FD D8         push g ; save 'g' as the div instruction uses it
1897   0EE1 AE            div a, b ; %, a: quotient, b: remainder
1898   0EE2 11            mov a, b
1899   0EE3 FD F1         pop g
1900   0EE5 FD 38         mov c, g
1901   0EE7 27            mov b, a
1902   0EE8 FD F1         pop g
1903   0EEA E4            pop a
1904   0EEB             ; --- END FACTORS
1905   0EEB 56            add b, a
1906   0EEC E4            pop a
1907   0EED             ; --- END TERMS
1908   0EED E7            pop d
1909   0EEE FD 3E         mov [d], bl
1910   0EF0             ; num = num / 10; 
1911   0EF0 FA 05 00      lea d, [bp + 5] ; $num
1912   0EF3 DA            push d
1913   0EF4 FA 05 00      lea d, [bp + 5] ; $num
1914   0EF7 2A            mov b, [d]
1915   0EF8 38 00 00      mov c, 0
1916   0EFB             ; --- START FACTORS
1917   0EFB D7            push a
1918   0EFC FD D8         push g
1919   0EFE 11            mov a, b
1920   0EFF FD 7A         mov g, c
1921   0F01 FD 2E 0A 00   mov32 cb, $0000000a
1921   0F05 00 00 
1922   0F07 FD D8         push g ; save 'g' as the div instruction uses it
1923   0F09 AE            div a, b ; /, a: quotient, b: remainder
1924   0F0A FD F1         pop g
1925   0F0C FD 38         mov c, g
1926   0F0E 27            mov b, a
1927   0F0F FD F1         pop g
1928   0F11 E4            pop a
1929   0F12             ; --- END FACTORS
1930   0F12 E7            pop d
1931   0F13 FD 43         mov [d], b
1932   0F15             ; i++; 
1933   0F15 FA FA FF      lea d, [bp + -6] ; $i
1934   0F18 2A            mov b, [d]
1935   0F19 38 00 00      mov c, 0
1936   0F1C 11            mov a, b
1937   0F1D FD 77         inc b
1938   0F1F FA FA FF      lea d, [bp + -6] ; $i
1939   0F22 FD 43         mov [d], b
1940   0F24 27            mov b, a
1941   0F25 0A 9B 0E      jmp _while30_cond
1942   0F28             _while30_exit:
1943   0F28             ; while (i > 0) { 
1944   0F28             _while37_cond:
1945   0F28 FA FA FF      lea d, [bp + -6] ; $i
1946   0F2B 2A            mov b, [d]
1947   0F2C 38 00 00      mov c, 0
1948   0F2F             ; --- START RELATIONAL
1949   0F2F D7            push a
1950   0F30 11            mov a, b
1951   0F31 FD 2E 00 00   mov32 cb, $00000000
1951   0F35 00 00 
1952   0F37 B0            cmp a, b
1953   0F38 FD 7F         sgt ; >
1954   0F3A E4            pop a
1955   0F3B             ; --- END RELATIONAL
1956   0F3B C0 00 00      cmp b, 0
1957   0F3E C6 70 0F      je _while37_exit
1958   0F41             _while37_block:
1959   0F41             ; i--; 
1960   0F41 FA FA FF      lea d, [bp + -6] ; $i
1961   0F44 2A            mov b, [d]
1962   0F45 38 00 00      mov c, 0
1963   0F48 11            mov a, b
1964   0F49 FD 7D         dec b
1965   0F4B FA FA FF      lea d, [bp + -6] ; $i
1966   0F4E FD 43         mov [d], b
1967   0F50 27            mov b, a
1968   0F51             ; putchar(digits[i]); 
1969   0F51             ; --- START FUNCTION CALL
1970   0F51 FA FC FF      lea d, [bp + -4] ; $digits
1971   0F54 D7            push a
1972   0F55 DA            push d
1973   0F56 FA FA FF      lea d, [bp + -6] ; $i
1974   0F59 2A            mov b, [d]
1975   0F5A 38 00 00      mov c, 0
1976   0F5D E7            pop d
1977   0F5E 5A            add d, b
1978   0F5F E4            pop a
1979   0F60 32            mov bl, [d]
1980   0F61 A7 00         mov bh, 0
1981   0F63 38 00 00      mov c, 0
1982   0F66 DD            push bl
1983   0F67 07 51 0C      call putchar
1984   0F6A 51 01 00      add sp, 1
1985   0F6D             ; --- END FUNCTION CALL
1986   0F6D 0A 28 0F      jmp _while37_cond
1987   0F70             _while37_exit:
1988   0F70 F9            leave
1989   0F71 09            ret
1990   0F72             
1991   0F72             print_unsigned:
1992   0F72 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1993   0F75             ; char digits[5]; 
1994   0F75 52 05 00      sub sp, 5
1995   0F78             ; int i; 
1996   0F78 52 02 00      sub sp, 2
1997   0F7B             ; i = 0; 
1998   0F7B FA FA FF      lea d, [bp + -6] ; $i
1999   0F7E DA            push d
2000   0F7F FD 2E 00 00   mov32 cb, $00000000
2000   0F83 00 00 
2001   0F85 E7            pop d
2002   0F86 FD 43         mov [d], b
2003   0F88             ; if(num == 0){ 
2004   0F88             _if38_cond:
2005   0F88 FA 05 00      lea d, [bp + 5] ; $num
2006   0F8B 2A            mov b, [d]
2007   0F8C 38 00 00      mov c, 0
2008   0F8F             ; --- START RELATIONAL
2009   0F8F D7            push a
2010   0F90 11            mov a, b
2011   0F91 FD 2E 00 00   mov32 cb, $00000000
2011   0F95 00 00 
2012   0F97 B0            cmp a, b
2013   0F98 FD 71         seq ; ==
2014   0F9A E4            pop a
2015   0F9B             ; --- END RELATIONAL
2016   0F9B C0 00 00      cmp b, 0
2017   0F9E C6 B3 0F      je _if38_exit
2018   0FA1             _if38_TRUE:
2019   0FA1             ; putchar('0'); 
2020   0FA1             ; --- START FUNCTION CALL
2021   0FA1 FD 2E 30 00   mov32 cb, $00000030
2021   0FA5 00 00 
2022   0FA7 DD            push bl
2023   0FA8 07 51 0C      call putchar
2024   0FAB 51 01 00      add sp, 1
2025   0FAE             ; --- END FUNCTION CALL
2026   0FAE             ; return; 
2027   0FAE F9            leave
2028   0FAF 09            ret
2029   0FB0 0A B3 0F      jmp _if38_exit
2030   0FB3             _if38_exit:
2031   0FB3             ; while (num > 0) { 
2032   0FB3             _while39_cond:
2033   0FB3 FA 05 00      lea d, [bp + 5] ; $num
2034   0FB6 2A            mov b, [d]
2035   0FB7 38 00 00      mov c, 0
2036   0FBA             ; --- START RELATIONAL
2037   0FBA D7            push a
2038   0FBB 11            mov a, b
2039   0FBC FD 2E 00 00   mov32 cb, $00000000
2039   0FC0 00 00 
2040   0FC2 B0            cmp a, b
2041   0FC3 FD 81         sgu ; > (unsigned)
2042   0FC5 E4            pop a
2043   0FC6             ; --- END RELATIONAL
2044   0FC6 C0 00 00      cmp b, 0
2045   0FC9 C6 40 10      je _while39_exit
2046   0FCC             _while39_block:
2047   0FCC             ; digits[i] = '0' + (num % 10); 
2048   0FCC FA FC FF      lea d, [bp + -4] ; $digits
2049   0FCF D7            push a
2050   0FD0 DA            push d
2051   0FD1 FA FA FF      lea d, [bp + -6] ; $i
2052   0FD4 2A            mov b, [d]
2053   0FD5 38 00 00      mov c, 0
2054   0FD8 E7            pop d
2055   0FD9 5A            add d, b
2056   0FDA E4            pop a
2057   0FDB DA            push d
2058   0FDC FD 2E 30 00   mov32 cb, $00000030
2058   0FE0 00 00 
2059   0FE2             ; --- START TERMS
2060   0FE2 D7            push a
2061   0FE3 11            mov a, b
2062   0FE4 FA 05 00      lea d, [bp + 5] ; $num
2063   0FE7 2A            mov b, [d]
2064   0FE8 38 00 00      mov c, 0
2065   0FEB             ; --- START FACTORS
2066   0FEB D7            push a
2067   0FEC FD D8         push g
2068   0FEE 11            mov a, b
2069   0FEF FD 7A         mov g, c
2070   0FF1 FD 2E 0A 00   mov32 cb, $0000000a
2070   0FF5 00 00 
2071   0FF7 FD D8         push g ; save 'g' as the div instruction uses it
2072   0FF9 AE            div a, b ; %, a: quotient, b: remainder
2073   0FFA 11            mov a, b
2074   0FFB FD F1         pop g
2075   0FFD FD 38         mov c, g
2076   0FFF 27            mov b, a
2077   1000 FD F1         pop g
2078   1002 E4            pop a
2079   1003             ; --- END FACTORS
2080   1003 56            add b, a
2081   1004 E4            pop a
2082   1005             ; --- END TERMS
2083   1005 E7            pop d
2084   1006 FD 3E         mov [d], bl
2085   1008             ; num = num / 10; 
2086   1008 FA 05 00      lea d, [bp + 5] ; $num
2087   100B DA            push d
2088   100C FA 05 00      lea d, [bp + 5] ; $num
2089   100F 2A            mov b, [d]
2090   1010 38 00 00      mov c, 0
2091   1013             ; --- START FACTORS
2092   1013 D7            push a
2093   1014 FD D8         push g
2094   1016 11            mov a, b
2095   1017 FD 7A         mov g, c
2096   1019 FD 2E 0A 00   mov32 cb, $0000000a
2096   101D 00 00 
2097   101F FD D8         push g ; save 'g' as the div instruction uses it
2098   1021 AE            div a, b ; /, a: quotient, b: remainder
2099   1022 FD F1         pop g
2100   1024 FD 38         mov c, g
2101   1026 27            mov b, a
2102   1027 FD F1         pop g
2103   1029 E4            pop a
2104   102A             ; --- END FACTORS
2105   102A E7            pop d
2106   102B FD 43         mov [d], b
2107   102D             ; i++; 
2108   102D FA FA FF      lea d, [bp + -6] ; $i
2109   1030 2A            mov b, [d]
2110   1031 38 00 00      mov c, 0
2111   1034 11            mov a, b
2112   1035 FD 77         inc b
2113   1037 FA FA FF      lea d, [bp + -6] ; $i
2114   103A FD 43         mov [d], b
2115   103C 27            mov b, a
2116   103D 0A B3 0F      jmp _while39_cond
2117   1040             _while39_exit:
2118   1040             ; while (i > 0) { 
2119   1040             _while46_cond:
2120   1040 FA FA FF      lea d, [bp + -6] ; $i
2121   1043 2A            mov b, [d]
2122   1044 38 00 00      mov c, 0
2123   1047             ; --- START RELATIONAL
2124   1047 D7            push a
2125   1048 11            mov a, b
2126   1049 FD 2E 00 00   mov32 cb, $00000000
2126   104D 00 00 
2127   104F B0            cmp a, b
2128   1050 FD 7F         sgt ; >
2129   1052 E4            pop a
2130   1053             ; --- END RELATIONAL
2131   1053 C0 00 00      cmp b, 0
2132   1056 C6 88 10      je _while46_exit
2133   1059             _while46_block:
2134   1059             ; i--; 
2135   1059 FA FA FF      lea d, [bp + -6] ; $i
2136   105C 2A            mov b, [d]
2137   105D 38 00 00      mov c, 0
2138   1060 11            mov a, b
2139   1061 FD 7D         dec b
2140   1063 FA FA FF      lea d, [bp + -6] ; $i
2141   1066 FD 43         mov [d], b
2142   1068 27            mov b, a
2143   1069             ; putchar(digits[i]); 
2144   1069             ; --- START FUNCTION CALL
2145   1069 FA FC FF      lea d, [bp + -4] ; $digits
2146   106C D7            push a
2147   106D DA            push d
2148   106E FA FA FF      lea d, [bp + -6] ; $i
2149   1071 2A            mov b, [d]
2150   1072 38 00 00      mov c, 0
2151   1075 E7            pop d
2152   1076 5A            add d, b
2153   1077 E4            pop a
2154   1078 32            mov bl, [d]
2155   1079 A7 00         mov bh, 0
2156   107B 38 00 00      mov c, 0
2157   107E DD            push bl
2158   107F 07 51 0C      call putchar
2159   1082 51 01 00      add sp, 1
2160   1085             ; --- END FUNCTION CALL
2161   1085 0A 40 10      jmp _while46_cond
2162   1088             _while46_exit:
2163   1088 F9            leave
2164   1089 09            ret
2165   108A             
2166   108A             printx16:
2167   108A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2168   108D             ; --- BEGIN INLINE ASM SEGMENT
2169   108D FA 05 00      lea d, [bp + 5] ; $hex
2170   1090 2A            mov b, [d]
2171   1091             print_u16x_printx16:
2172   1091 DD            push bl
2173   1092 30            mov bl, bh
2174   1093 07 B0 10      call _itoa_printx16        ; convert bh to char in A
2175   1096 2F            mov bl, al        ; save al
2176   1097 19 00         mov al, 0
2177   1099 05 03         syscall sys_io        ; display AH
2178   109B 24            mov ah, bl        ; retrieve al
2179   109C 19 00         mov al, 0
2180   109E 05 03         syscall sys_io        ; display AL
2181   10A0 EA            pop bl
2182   10A1 07 B0 10      call _itoa_printx16        ; convert bh to char in A
2183   10A4 2F            mov bl, al        ; save al
2184   10A5 19 00         mov al, 0
2185   10A7 05 03         syscall sys_io        ; display AH
2186   10A9 24            mov ah, bl        ; retrieve al
2187   10AA 19 00         mov al, 0
2188   10AC 05 03         syscall sys_io        ; display AL
2189   10AE             ; --- END INLINE ASM SEGMENT
2190   10AE             ; return; 
2191   10AE F9            leave
2192   10AF 09            ret
2193   10B0             ; --- BEGIN INLINE ASM SEGMENT
2194   10B0             _itoa_printx16:
2195   10B0 DA            push d
2196   10B1 D8            push b
2197   10B2 A7 00         mov bh, 0
2198   10B4 FD A4 04      shr bl, 4  
2199   10B7 74            mov d, b
2200   10B8 1F CA 10      mov al, [d + s_hex_digits_printx16]
2201   10BB 23            mov ah, al
2202   10BC E5            pop b
2203   10BD D8            push b
2204   10BE A7 00         mov bh, 0
2205   10C0 FD 87 0F      and bl, $0F
2206   10C3 74            mov d, b
2207   10C4 1F CA 10      mov al, [d + s_hex_digits_printx16]
2208   10C7 E5            pop b
2209   10C8 E7            pop d
2210   10C9 09            ret
2211   10CA 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
2211   10CE 34 35 36 37 
2211   10D2 38 39 41 42 
2211   10D6 43 44 45 46 
2212   10DA             ; --- END INLINE ASM SEGMENT
2213   10DA F9            leave
2214   10DB 09            ret
2215   10DC             ; --- END TEXT SEGMENT
2216   10DC             
2217   10DC             ; --- BEGIN DATA SEGMENT
2218   10DC 00          _active_proc_index: .fill 1, 0
2219   10DD 48 65 6C 6C _s0: .db "Hello WorldMy name is Sol-1And this is a multi-line string", 0
2219   10E1 6F 20 57 6F 
2219   10E5 72 6C 64 4D 
2219   10E9 79 20 6E 61 
2219   10ED 6D 65 20 69 
2219   10F1 73 20 53 6F 
2219   10F5 6C 2D 31 41 
2219   10F9 6E 64 20 74 
2219   10FD 68 69 73 20 
2219   1101 69 73 20 61 
2219   1105 20 6D 75 6C 
2219   1109 74 69 2D 6C 
2219   110D 69 6E 65 20 
2219   1111 73 74 72 69 
2219   1115 6E 67 00 
2220   1118 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
2220   111C 70 65 63 74 
2220   1120 65 64 20 66 
2220   1124 6F 72 6D 61 
2220   1128 74 20 69 6E 
2220   112C 20 70 72 69 
2220   1130 6E 74 66 2E 
2220   1134 00 
2221   1135 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
2221   1139 72 3A 20 55 
2221   113D 6E 6B 6E 6F 
2221   1141 77 6E 20 61 
2221   1145 72 67 75 6D 
2221   1149 65 6E 74 20 
2221   114D 74 79 70 65 
2221   1151 2E 0A 00 
2222   1154             
2223   1154 56 11       _heap_top: .dw _heap
2224   1156 00          _heap: .db 0
2225   1157             ; --- END DATA SEGMENT
2226   1157             
2227   1157             .end
tasm: Number of errors = 119
