0001   0000             ; --- FILENAME: programs/qs
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; printf("Enter a string(256 max): "); 
0011   0408 26 ED 16      mov b, __s0 ; "Enter a string(256 max): "
0012   040B FD AB         swp b
0013   040D D8            push b
0014   040E 07 2C 06      call printf
0015   0411 51 02 00      add sp, 2
0016   0414             ;; gets(mystring); 
0017   0414 3B ED 15      mov d, _mystring_data ; $mystring
0018   0417 2D            mov b, d
0019   0418 FD AB         swp b
0020   041A D8            push b
0021   041B 07 11 0B      call gets
0022   041E 51 02 00      add sp, 2
0023   0421             ;; quick(mystring, strlen(mystring)); 
0024   0421 3B ED 15      mov d, _mystring_data ; $mystring
0025   0424 2D            mov b, d
0026   0425 FD AB         swp b
0027   0427 D8            push b
0028   0428 07 E3 05      call strlen
0029   042B 51 02 00      add sp, 2
0030   042E FD AB         swp b
0031   0430 D8            push b
0032   0431 3B ED 15      mov d, _mystring_data ; $mystring
0033   0434 2D            mov b, d
0034   0435 FD AB         swp b
0035   0437 D8            push b
0036   0438 07 F9 13      call quick
0037   043B 51 04 00      add sp, 4
0038   043E             ;; printf("\n"); 
0039   043E 26 07 17      mov b, __s1 ; "\n"
0040   0441 FD AB         swp b
0041   0443 D8            push b
0042   0444 07 2C 06      call printf
0043   0447 51 02 00      add sp, 2
0044   044A             ;; printf("Sorted string: "); 
0045   044A 26 09 17      mov b, __s2 ; "Sorted string: "
0046   044D FD AB         swp b
0047   044F D8            push b
0048   0450 07 2C 06      call printf
0049   0453 51 02 00      add sp, 2
0050   0456             ;; printf(mystring); 
0051   0456 3B ED 15      mov d, _mystring_data ; $mystring
0052   0459 2D            mov b, d
0053   045A FD AB         swp b
0054   045C D8            push b
0055   045D 07 2C 06      call printf
0056   0460 51 02 00      add sp, 2
0057   0463             ;; printf("\n"); 
0058   0463 26 07 17      mov b, __s1 ; "\n"
0059   0466 FD AB         swp b
0060   0468 D8            push b
0061   0469 07 2C 06      call printf
0062   046C 51 02 00      add sp, 2
0063   046F 05 0B         syscall sys_terminate_proc
0064   0471             
0065   0471             strcpy:
0066   0471 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0067   0474             ; $psrc 
0068   0474             ; $pdest 
0069   0474 52 04 00      sub sp, 4
0070   0477             ;; psrc = src; 
0071   0477 FA FF FF      lea d, [bp + -1] ; $psrc
0072   047A DA            push d
0073   047B FA 07 00      lea d, [bp + 7] ; $src
0074   047E 2A            mov b, [d]
0075   047F E7            pop d
0076   0480 FD 43         mov [d], b
0077   0482             ;; pdest = dest; 
0078   0482 FA FD FF      lea d, [bp + -3] ; $pdest
0079   0485 DA            push d
0080   0486 FA 05 00      lea d, [bp + 5] ; $dest
0081   0489 2A            mov b, [d]
0082   048A E7            pop d
0083   048B FD 43         mov [d], b
0084   048D             ;; while(*psrc) *pdest++ = *psrc++; 
0085   048D             _while1_cond:
0086   048D FA FF FF      lea d, [bp + -1] ; $psrc
0087   0490 2A            mov b, [d]
0088   0491 74            mov d, b
0089   0492 32            mov bl, [d]
0090   0493 A7 00         mov bh, 0
0091   0495 C0 00 00      cmp b, 0
0092   0498 C6 C0 04      je _while1_exit
0093   049B             _while1_block:
0094   049B             ;; *pdest++ = *psrc++; 
0095   049B FA FD FF      lea d, [bp + -3] ; $pdest
0096   049E 2A            mov b, [d]
0097   049F D8            push b
0098   04A0 FD 77         inc b
0099   04A2 FA FD FF      lea d, [bp + -3] ; $pdest
0100   04A5 FD 43         mov [d], b
0101   04A7 E5            pop b
0102   04A8 D8            push b
0103   04A9 FA FF FF      lea d, [bp + -1] ; $psrc
0104   04AC 2A            mov b, [d]
0105   04AD D8            push b
0106   04AE FD 77         inc b
0107   04B0 FA FF FF      lea d, [bp + -1] ; $psrc
0108   04B3 FD 43         mov [d], b
0109   04B5 E5            pop b
0110   04B6 74            mov d, b
0111   04B7 32            mov bl, [d]
0112   04B8 A7 00         mov bh, 0
0113   04BA E7            pop d
0114   04BB FD 3E         mov [d], bl
0115   04BD 0A 8D 04      jmp _while1_cond
0116   04C0             _while1_exit:
0117   04C0             ;; *pdest = '\0'; 
0118   04C0 FA FD FF      lea d, [bp + -3] ; $pdest
0119   04C3 2A            mov b, [d]
0120   04C4 D8            push b
0121   04C5 26 00 00      mov b, $0
0122   04C8 E7            pop d
0123   04C9 FD 3E         mov [d], bl
0124   04CB F9            leave
0125   04CC 09            ret
0126   04CD             
0127   04CD             strcmp:
0128   04CD F8 00 00      enter 0 ; (push bp; mov bp, sp)
0129   04D0             ;; while (*s1 && (*s1 == *s2)) { 
0130   04D0             _while2_cond:
0131   04D0 FA 05 00      lea d, [bp + 5] ; $s1
0132   04D3 2A            mov b, [d]
0133   04D4 74            mov d, b
0134   04D5 32            mov bl, [d]
0135   04D6 A7 00         mov bh, 0
0136   04D8 D7            push a
0137   04D9 11            mov a, b
0138   04DA FA 05 00      lea d, [bp + 5] ; $s1
0139   04DD 2A            mov b, [d]
0140   04DE 74            mov d, b
0141   04DF 32            mov bl, [d]
0142   04E0 A7 00         mov bh, 0
0143   04E2             ; START RELATIONAL
0144   04E2 D7            push a
0145   04E3 11            mov a, b
0146   04E4 FA 07 00      lea d, [bp + 7] ; $s2
0147   04E7 2A            mov b, [d]
0148   04E8 74            mov d, b
0149   04E9 32            mov bl, [d]
0150   04EA A7 00         mov bh, 0
0151   04EC B0            cmp a, b
0152   04ED FD 71         seq ; ==
0153   04EF E4            pop a
0154   04F0             ; END RELATIONAL
0155   04F0 FD A7         sand a, b ; &&
0156   04F2 E4            pop a
0157   04F3 C0 00 00      cmp b, 0
0158   04F6 C6 16 05      je _while2_exit
0159   04F9             _while2_block:
0160   04F9             ;; s1++; 
0161   04F9 FA 05 00      lea d, [bp + 5] ; $s1
0162   04FC 2A            mov b, [d]
0163   04FD D8            push b
0164   04FE FD 77         inc b
0165   0500 FA 05 00      lea d, [bp + 5] ; $s1
0166   0503 FD 43         mov [d], b
0167   0505 E5            pop b
0168   0506             ;; s2++; 
0169   0506 FA 07 00      lea d, [bp + 7] ; $s2
0170   0509 2A            mov b, [d]
0171   050A D8            push b
0172   050B FD 77         inc b
0173   050D FA 07 00      lea d, [bp + 7] ; $s2
0174   0510 FD 43         mov [d], b
0175   0512 E5            pop b
0176   0513 0A D0 04      jmp _while2_cond
0177   0516             _while2_exit:
0178   0516             ;; return *s1 - *s2; 
0179   0516 FA 05 00      lea d, [bp + 5] ; $s1
0180   0519 2A            mov b, [d]
0181   051A 74            mov d, b
0182   051B 32            mov bl, [d]
0183   051C A7 00         mov bh, 0
0184   051E             ; START TERMS
0185   051E D7            push a
0186   051F 11            mov a, b
0187   0520 FA 07 00      lea d, [bp + 7] ; $s2
0188   0523 2A            mov b, [d]
0189   0524 74            mov d, b
0190   0525 32            mov bl, [d]
0191   0526 A7 00         mov bh, 0
0192   0528 60            sub a, b
0193   0529 27            mov b, a
0194   052A E4            pop a
0195   052B             ; END TERMS
0196   052B F9            leave
0197   052C 09            ret
0198   052D             
0199   052D             strcat:
0200   052D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0201   0530             ; $dest_len 
0202   0530             ; $i 
0203   0530 52 04 00      sub sp, 4
0204   0533             ;; dest_len = strlen(dest); 
0205   0533 FA FF FF      lea d, [bp + -1] ; $dest_len
0206   0536 DA            push d
0207   0537 FA 05 00      lea d, [bp + 5] ; $dest
0208   053A 2A            mov b, [d]
0209   053B FD AB         swp b
0210   053D D8            push b
0211   053E 07 E3 05      call strlen
0212   0541 51 02 00      add sp, 2
0213   0544 E7            pop d
0214   0545 FD 43         mov [d], b
0215   0547             ;; for (i = 0; src[i] != 0; i=i+1) { 
0216   0547             _for3_init:
0217   0547 FA FD FF      lea d, [bp + -3] ; $i
0218   054A DA            push d
0219   054B 26 00 00      mov b, $0
0220   054E E7            pop d
0221   054F FD 43         mov [d], b
0222   0551             _for3_cond:
0223   0551 FA 07 00      lea d, [bp + 7] ; $src
0224   0554 FD 2A         mov d, [d]
0225   0556 D7            push a
0226   0557 DA            push d
0227   0558 FA FD FF      lea d, [bp + -3] ; $i
0228   055B 2A            mov b, [d]
0229   055C E7            pop d
0230   055D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0231   0561 E4            pop a
0232   0562 32            mov bl, [d]
0233   0563 A7 00         mov bh, 0
0234   0565             ; START RELATIONAL
0235   0565 D7            push a
0236   0566 11            mov a, b
0237   0567 26 00 00      mov b, $0
0238   056A B0            cmp a, b
0239   056B FD 72         sneq ; !=
0240   056D E4            pop a
0241   056E             ; END RELATIONAL
0242   056E C0 00 00      cmp b, 0
0243   0571 C6 BC 05      je _for3_exit
0244   0574             _for3_block:
0245   0574             ;; dest[dest_len + i] = src[i]; 
0246   0574 FA 05 00      lea d, [bp + 5] ; $dest
0247   0577 FD 2A         mov d, [d]
0248   0579 D7            push a
0249   057A DA            push d
0250   057B FA FF FF      lea d, [bp + -1] ; $dest_len
0251   057E 2A            mov b, [d]
0252   057F             ; START TERMS
0253   057F D7            push a
0254   0580 11            mov a, b
0255   0581 FA FD FF      lea d, [bp + -3] ; $i
0256   0584 2A            mov b, [d]
0257   0585 54            add a, b
0258   0586 27            mov b, a
0259   0587 E4            pop a
0260   0588             ; END TERMS
0261   0588 E7            pop d
0262   0589 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0263   058D E4            pop a
0264   058E DA            push d
0265   058F FA 07 00      lea d, [bp + 7] ; $src
0266   0592 FD 2A         mov d, [d]
0267   0594 D7            push a
0268   0595 DA            push d
0269   0596 FA FD FF      lea d, [bp + -3] ; $i
0270   0599 2A            mov b, [d]
0271   059A E7            pop d
0272   059B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0273   059F E4            pop a
0274   05A0 32            mov bl, [d]
0275   05A1 A7 00         mov bh, 0
0276   05A3 E7            pop d
0277   05A4 FD 3E         mov [d], bl
0278   05A6             _for3_update:
0279   05A6 FA FD FF      lea d, [bp + -3] ; $i
0280   05A9 DA            push d
0281   05AA FA FD FF      lea d, [bp + -3] ; $i
0282   05AD 2A            mov b, [d]
0283   05AE             ; START TERMS
0284   05AE D7            push a
0285   05AF 11            mov a, b
0286   05B0 26 01 00      mov b, $1
0287   05B3 54            add a, b
0288   05B4 27            mov b, a
0289   05B5 E4            pop a
0290   05B6             ; END TERMS
0291   05B6 E7            pop d
0292   05B7 FD 43         mov [d], b
0293   05B9 0A 51 05      jmp _for3_cond
0294   05BC             _for3_exit:
0295   05BC             ;; dest[dest_len + i] = 0; 
0296   05BC FA 05 00      lea d, [bp + 5] ; $dest
0297   05BF FD 2A         mov d, [d]
0298   05C1 D7            push a
0299   05C2 DA            push d
0300   05C3 FA FF FF      lea d, [bp + -1] ; $dest_len
0301   05C6 2A            mov b, [d]
0302   05C7             ; START TERMS
0303   05C7 D7            push a
0304   05C8 11            mov a, b
0305   05C9 FA FD FF      lea d, [bp + -3] ; $i
0306   05CC 2A            mov b, [d]
0307   05CD 54            add a, b
0308   05CE 27            mov b, a
0309   05CF E4            pop a
0310   05D0             ; END TERMS
0311   05D0 E7            pop d
0312   05D1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0313   05D5 E4            pop a
0314   05D6 DA            push d
0315   05D7 26 00 00      mov b, $0
0316   05DA E7            pop d
0317   05DB FD 3E         mov [d], bl
0318   05DD             ;; return dest; 
0319   05DD FA 05 00      lea d, [bp + 5] ; $dest
0320   05E0 2A            mov b, [d]
0321   05E1 F9            leave
0322   05E2 09            ret
0323   05E3             
0324   05E3             strlen:
0325   05E3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0326   05E6             ; $length 
0327   05E6 52 02 00      sub sp, 2
0328   05E9             ;; length = 0; 
0329   05E9 FA FF FF      lea d, [bp + -1] ; $length
0330   05EC DA            push d
0331   05ED 26 00 00      mov b, $0
0332   05F0 E7            pop d
0333   05F1 FD 43         mov [d], b
0334   05F3             ;; while (str[length] != 0) { 
0335   05F3             _while4_cond:
0336   05F3 FA 05 00      lea d, [bp + 5] ; $str
0337   05F6 FD 2A         mov d, [d]
0338   05F8 D7            push a
0339   05F9 DA            push d
0340   05FA FA FF FF      lea d, [bp + -1] ; $length
0341   05FD 2A            mov b, [d]
0342   05FE E7            pop d
0343   05FF FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0344   0603 E4            pop a
0345   0604 32            mov bl, [d]
0346   0605 A7 00         mov bh, 0
0347   0607             ; START RELATIONAL
0348   0607 D7            push a
0349   0608 11            mov a, b
0350   0609 26 00 00      mov b, $0
0351   060C B0            cmp a, b
0352   060D FD 72         sneq ; !=
0353   060F E4            pop a
0354   0610             ; END RELATIONAL
0355   0610 C0 00 00      cmp b, 0
0356   0613 C6 26 06      je _while4_exit
0357   0616             _while4_block:
0358   0616             ;; length++; 
0359   0616 FA FF FF      lea d, [bp + -1] ; $length
0360   0619 2A            mov b, [d]
0361   061A D8            push b
0362   061B FD 77         inc b
0363   061D FA FF FF      lea d, [bp + -1] ; $length
0364   0620 FD 43         mov [d], b
0365   0622 E5            pop b
0366   0623 0A F3 05      jmp _while4_cond
0367   0626             _while4_exit:
0368   0626             ;; return length; 
0369   0626 FA FF FF      lea d, [bp + -1] ; $length
0370   0629 2A            mov b, [d]
0371   062A F9            leave
0372   062B 09            ret
0373   062C             
0374   062C             printf:
0375   062C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0376   062F             ; $p 
0377   062F             ; $fp 
0378   062F             ; $i 
0379   062F 52 06 00      sub sp, 6
0380   0632             ;; fp = format; 
0381   0632 FA FD FF      lea d, [bp + -3] ; $fp
0382   0635 DA            push d
0383   0636 FA 05 00      lea d, [bp + 5] ; $format
0384   0639 2A            mov b, [d]
0385   063A E7            pop d
0386   063B FD 43         mov [d], b
0387   063D             ;; p = &format + 2; 
0388   063D FA FF FF      lea d, [bp + -1] ; $p
0389   0640 DA            push d
0390   0641 FA 05 00      lea d, [bp + 5] ; $format
0391   0644 2D            mov b, d
0392   0645             ; START TERMS
0393   0645 D7            push a
0394   0646 11            mov a, b
0395   0647 26 02 00      mov b, $2
0396   064A 54            add a, b
0397   064B 27            mov b, a
0398   064C E4            pop a
0399   064D             ; END TERMS
0400   064D E7            pop d
0401   064E FD 43         mov [d], b
0402   0650             ;; for(;;){ 
0403   0650             _for5_init:
0404   0650             _for5_cond:
0405   0650             _for5_block:
0406   0650             ;; if(!*fp) break; 
0407   0650             _if6_cond:
0408   0650 FA FD FF      lea d, [bp + -3] ; $fp
0409   0653 2A            mov b, [d]
0410   0654 74            mov d, b
0411   0655 32            mov bl, [d]
0412   0656 A7 00         mov bh, 0
0413   0658 C0 00 00      cmp b, 0
0414   065B FD 71         seq ; !
0415   065D C0 00 00      cmp b, 0
0416   0660 C6 69 06      je _if6_else
0417   0663             _if6_true:
0418   0663             ;; break; 
0419   0663 0A 78 08      jmp _for5_exit ; for break
0420   0666 0A 75 08      jmp _if6_exit
0421   0669             _if6_else:
0422   0669             ;; if(*fp == '%'){ 
0423   0669             _if7_cond:
0424   0669 FA FD FF      lea d, [bp + -3] ; $fp
0425   066C 2A            mov b, [d]
0426   066D 74            mov d, b
0427   066E 32            mov bl, [d]
0428   066F A7 00         mov bh, 0
0429   0671             ; START RELATIONAL
0430   0671 D7            push a
0431   0672 11            mov a, b
0432   0673 26 25 00      mov b, $25
0433   0676 B0            cmp a, b
0434   0677 FD 71         seq ; ==
0435   0679 E4            pop a
0436   067A             ; END RELATIONAL
0437   067A C0 00 00      cmp b, 0
0438   067D C6 59 08      je _if7_else
0439   0680             _if7_true:
0440   0680             ;; fp++; 
0441   0680 FA FD FF      lea d, [bp + -3] ; $fp
0442   0683 2A            mov b, [d]
0443   0684 D8            push b
0444   0685 FD 77         inc b
0445   0687 FA FD FF      lea d, [bp + -3] ; $fp
0446   068A FD 43         mov [d], b
0447   068C E5            pop b
0448   068D             ;; switch(*fp){ 
0449   068D             _switch8_expr:
0450   068D FA FD FF      lea d, [bp + -3] ; $fp
0451   0690 2A            mov b, [d]
0452   0691 74            mov d, b
0453   0692 32            mov bl, [d]
0454   0693 A7 00         mov bh, 0
0455   0695             _switch8_comparisons:
0456   0695 C1 6C         cmp bl, $6c
0457   0697 C6 C3 06      je _switch8_case0
0458   069A C1 4C         cmp bl, $4c
0459   069C C6 C3 06      je _switch8_case1
0460   069F C1 64         cmp bl, $64
0461   06A1 C6 94 07      je _switch8_case2
0462   06A4 C1 69         cmp bl, $69
0463   06A6 C6 94 07      je _switch8_case3
0464   06A9 C1 75         cmp bl, $75
0465   06AB C6 B9 07      je _switch8_case4
0466   06AE C1 78         cmp bl, $78
0467   06B0 C6 DE 07      je _switch8_case5
0468   06B3 C1 63         cmp bl, $63
0469   06B5 C6 FD 07      je _switch8_case6
0470   06B8 C1 73         cmp bl, $73
0471   06BA C6 1D 08      je _switch8_case7
0472   06BD 0A 3D 08      jmp _switch8_default
0473   06C0 0A 49 08      jmp _switch8_exit
0474   06C3             _switch8_case0:
0475   06C3             _switch8_case1:
0476   06C3             ;; fp++; 
0477   06C3 FA FD FF      lea d, [bp + -3] ; $fp
0478   06C6 2A            mov b, [d]
0479   06C7 D8            push b
0480   06C8 FD 77         inc b
0481   06CA FA FD FF      lea d, [bp + -3] ; $fp
0482   06CD FD 43         mov [d], b
0483   06CF E5            pop b
0484   06D0             ;; if(*fp == 'd' || *fp == 'i') 
0485   06D0             _if9_cond:
0486   06D0 FA FD FF      lea d, [bp + -3] ; $fp
0487   06D3 2A            mov b, [d]
0488   06D4 74            mov d, b
0489   06D5 32            mov bl, [d]
0490   06D6 A7 00         mov bh, 0
0491   06D8             ; START RELATIONAL
0492   06D8 D7            push a
0493   06D9 11            mov a, b
0494   06DA 26 64 00      mov b, $64
0495   06DD B0            cmp a, b
0496   06DE FD 71         seq ; ==
0497   06E0 E4            pop a
0498   06E1             ; END RELATIONAL
0499   06E1 D7            push a
0500   06E2 11            mov a, b
0501   06E3 FA FD FF      lea d, [bp + -3] ; $fp
0502   06E6 2A            mov b, [d]
0503   06E7 74            mov d, b
0504   06E8 32            mov bl, [d]
0505   06E9 A7 00         mov bh, 0
0506   06EB             ; START RELATIONAL
0507   06EB D7            push a
0508   06EC 11            mov a, b
0509   06ED 26 69 00      mov b, $69
0510   06F0 B0            cmp a, b
0511   06F1 FD 71         seq ; ==
0512   06F3 E4            pop a
0513   06F4             ; END RELATIONAL
0514   06F4 FD A8         sor a, b ; ||
0515   06F6 E4            pop a
0516   06F7 C0 00 00      cmp b, 0
0517   06FA C6 11 07      je _if9_else
0518   06FD             _if9_true:
0519   06FD             ;; print_signed_long(*(long *)p); 
0520   06FD FD 79         mov g, b
0521   06FF 28            mov b, c
0522   0700 FD AB         swp b
0523   0702 D8            push b
0524   0703 FD 27         mov b, g
0525   0705 FD AB         swp b
0526   0707 D8            push b
0527   0708 07 1C 0C      call print_signed_long
0528   070B 51 04 00      add sp, 4
0529   070E 0A 7E 07      jmp _if9_exit
0530   0711             _if9_else:
0531   0711             ;; if(*fp == 'u') 
0532   0711             _if10_cond:
0533   0711 FA FD FF      lea d, [bp + -3] ; $fp
0534   0714 2A            mov b, [d]
0535   0715 74            mov d, b
0536   0716 32            mov bl, [d]
0537   0717 A7 00         mov bh, 0
0538   0719             ; START RELATIONAL
0539   0719 D7            push a
0540   071A 11            mov a, b
0541   071B 26 75 00      mov b, $75
0542   071E B0            cmp a, b
0543   071F FD 71         seq ; ==
0544   0721 E4            pop a
0545   0722             ; END RELATIONAL
0546   0722 C0 00 00      cmp b, 0
0547   0725 C6 3C 07      je _if10_else
0548   0728             _if10_true:
0549   0728             ;; print_unsigned_long(*(unsigned long *)p); 
0550   0728 FD 79         mov g, b
0551   072A 28            mov b, c
0552   072B FD AB         swp b
0553   072D D8            push b
0554   072E FD 27         mov b, g
0555   0730 FD AB         swp b
0556   0732 D8            push b
0557   0733 07 51 0D      call print_unsigned_long
0558   0736 51 04 00      add sp, 4
0559   0739 0A 7E 07      jmp _if10_exit
0560   073C             _if10_else:
0561   073C             ;; if(*fp == 'x') 
0562   073C             _if11_cond:
0563   073C FA FD FF      lea d, [bp + -3] ; $fp
0564   073F 2A            mov b, [d]
0565   0740 74            mov d, b
0566   0741 32            mov bl, [d]
0567   0742 A7 00         mov bh, 0
0568   0744             ; START RELATIONAL
0569   0744 D7            push a
0570   0745 11            mov a, b
0571   0746 26 78 00      mov b, $78
0572   0749 B0            cmp a, b
0573   074A FD 71         seq ; ==
0574   074C E4            pop a
0575   074D             ; END RELATIONAL
0576   074D C0 00 00      cmp b, 0
0577   0750 C6 72 07      je _if11_else
0578   0753             _if11_true:
0579   0753             ;; printx32(*(long int *)p); 
0580   0753 FA FF FF      lea d, [bp + -1] ; $p
0581   0756 2A            mov b, [d]
0582   0757 74            mov d, b
0583   0758 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0584   075B FD 39         mov c, b ; And place it into C
0585   075D 2A            mov b, [d] ; Lower Word in B
0586   075E FD 79         mov g, b
0587   0760 28            mov b, c
0588   0761 FD AB         swp b
0589   0763 D8            push b
0590   0764 FD 27         mov b, g
0591   0766 FD AB         swp b
0592   0768 D8            push b
0593   0769 07 8F 08      call printx32
0594   076C 51 04 00      add sp, 4
0595   076F 0A 7E 07      jmp _if11_exit
0596   0772             _if11_else:
0597   0772             ;; err("Unexpected format in printf."); 
0598   0772 26 19 17      mov b, __s3 ; "Unexpected format in printf."
0599   0775 FD AB         swp b
0600   0777 D8            push b
0601   0778 07 7A 08      call err
0602   077B 51 02 00      add sp, 2
0603   077E             _if11_exit:
0604   077E             _if10_exit:
0605   077E             _if9_exit:
0606   077E             ;; p = p + 4; 
0607   077E FA FF FF      lea d, [bp + -1] ; $p
0608   0781 DA            push d
0609   0782 FA FF FF      lea d, [bp + -1] ; $p
0610   0785 2A            mov b, [d]
0611   0786             ; START TERMS
0612   0786 D7            push a
0613   0787 11            mov a, b
0614   0788 26 04 00      mov b, $4
0615   078B 54            add a, b
0616   078C 27            mov b, a
0617   078D E4            pop a
0618   078E             ; END TERMS
0619   078E E7            pop d
0620   078F FD 43         mov [d], b
0621   0791             ;; break; 
0622   0791 0A 49 08      jmp _switch8_exit ; case break
0623   0794             _switch8_case2:
0624   0794             _switch8_case3:
0625   0794             ;; print_signed(*(int*)p); 
0626   0794 FA FF FF      lea d, [bp + -1] ; $p
0627   0797 2A            mov b, [d]
0628   0798 74            mov d, b
0629   0799 2A            mov b, [d]
0630   079A FD AB         swp b
0631   079C D8            push b
0632   079D 07 2B 0B      call print_signed
0633   07A0 51 02 00      add sp, 2
0634   07A3             ;; p = p + 2; 
0635   07A3 FA FF FF      lea d, [bp + -1] ; $p
0636   07A6 DA            push d
0637   07A7 FA FF FF      lea d, [bp + -1] ; $p
0638   07AA 2A            mov b, [d]
0639   07AB             ; START TERMS
0640   07AB D7            push a
0641   07AC 11            mov a, b
0642   07AD 26 02 00      mov b, $2
0643   07B0 54            add a, b
0644   07B1 27            mov b, a
0645   07B2 E4            pop a
0646   07B3             ; END TERMS
0647   07B3 E7            pop d
0648   07B4 FD 43         mov [d], b
0649   07B6             ;; break; 
0650   07B6 0A 49 08      jmp _switch8_exit ; case break
0651   07B9             _switch8_case4:
0652   07B9             ;; print_unsigned(*(unsigned int*)p); 
0653   07B9 FA FF FF      lea d, [bp + -1] ; $p
0654   07BC 2A            mov b, [d]
0655   07BD 74            mov d, b
0656   07BE 2A            mov b, [d]
0657   07BF FD AB         swp b
0658   07C1 D8            push b
0659   07C2 07 48 0E      call print_unsigned
0660   07C5 51 02 00      add sp, 2
0661   07C8             ;; p = p + 2; 
0662   07C8 FA FF FF      lea d, [bp + -1] ; $p
0663   07CB DA            push d
0664   07CC FA FF FF      lea d, [bp + -1] ; $p
0665   07CF 2A            mov b, [d]
0666   07D0             ; START TERMS
0667   07D0 D7            push a
0668   07D1 11            mov a, b
0669   07D2 26 02 00      mov b, $2
0670   07D5 54            add a, b
0671   07D6 27            mov b, a
0672   07D7 E4            pop a
0673   07D8             ; END TERMS
0674   07D8 E7            pop d
0675   07D9 FD 43         mov [d], b
0676   07DB             ;; break; 
0677   07DB 0A 49 08      jmp _switch8_exit ; case break
0678   07DE             _switch8_case5:
0679   07DE             
0680   07DE             ; --- BEGIN INLINE ASM BLOCK
0681   07DE FA FF FF      lea d, [bp + -1] ; $p
0682   07E1 FD 2A         mov d, [d]
0683   07E3 2A            mov b, [d]
0684   07E4 07 F9 12      call print_u16x
0685   07E7             ; --- END INLINE ASM BLOCK
0686   07E7             
0687   07E7             ;; p = p + 2; 
0688   07E7 FA FF FF      lea d, [bp + -1] ; $p
0689   07EA DA            push d
0690   07EB FA FF FF      lea d, [bp + -1] ; $p
0691   07EE 2A            mov b, [d]
0692   07EF             ; START TERMS
0693   07EF D7            push a
0694   07F0 11            mov a, b
0695   07F1 26 02 00      mov b, $2
0696   07F4 54            add a, b
0697   07F5 27            mov b, a
0698   07F6 E4            pop a
0699   07F7             ; END TERMS
0700   07F7 E7            pop d
0701   07F8 FD 43         mov [d], b
0702   07FA             ;; break; 
0703   07FA 0A 49 08      jmp _switch8_exit ; case break
0704   07FD             _switch8_case6:
0705   07FD             
0706   07FD             ; --- BEGIN INLINE ASM BLOCK
0707   07FD FA FF FF      lea d, [bp + -1] ; $p
0708   0800 FD 2A         mov d, [d]
0709   0802 1E            mov al, [d]
0710   0803 23            mov ah, al
0711   0804 07 57 11      call _putchar
0712   0807             ; --- END INLINE ASM BLOCK
0713   0807             
0714   0807             ;; p = p + 2; 
0715   0807 FA FF FF      lea d, [bp + -1] ; $p
0716   080A DA            push d
0717   080B FA FF FF      lea d, [bp + -1] ; $p
0718   080E 2A            mov b, [d]
0719   080F             ; START TERMS
0720   080F D7            push a
0721   0810 11            mov a, b
0722   0811 26 02 00      mov b, $2
0723   0814 54            add a, b
0724   0815 27            mov b, a
0725   0816 E4            pop a
0726   0817             ; END TERMS
0727   0817 E7            pop d
0728   0818 FD 43         mov [d], b
0729   081A             ;; break; 
0730   081A 0A 49 08      jmp _switch8_exit ; case break
0731   081D             _switch8_case7:
0732   081D             
0733   081D             ; --- BEGIN INLINE ASM BLOCK
0734   081D FA FF FF      lea d, [bp + -1] ; $p
0735   0820 FD 2A         mov d, [d]
0736   0822 FD 2A         mov d, [d]
0737   0824 07 A1 12      call _puts
0738   0827             ; --- END INLINE ASM BLOCK
0739   0827             
0740   0827             ;; p = p + 2; 
0741   0827 FA FF FF      lea d, [bp + -1] ; $p
0742   082A DA            push d
0743   082B FA FF FF      lea d, [bp + -1] ; $p
0744   082E 2A            mov b, [d]
0745   082F             ; START TERMS
0746   082F D7            push a
0747   0830 11            mov a, b
0748   0831 26 02 00      mov b, $2
0749   0834 54            add a, b
0750   0835 27            mov b, a
0751   0836 E4            pop a
0752   0837             ; END TERMS
0753   0837 E7            pop d
0754   0838 FD 43         mov [d], b
0755   083A             ;; break; 
0756   083A 0A 49 08      jmp _switch8_exit ; case break
0757   083D             _switch8_default:
0758   083D             ;; print("Error: Unknown argument type.\n"); 
0759   083D 26 36 17      mov b, __s4 ; "Error: Unknown argument type.\n"
0760   0840 FD AB         swp b
0761   0842 D8            push b
0762   0843 07 78 0F      call print
0763   0846 51 02 00      add sp, 2
0764   0849             _switch8_exit:
0765   0849             ;; fp++; 
0766   0849 FA FD FF      lea d, [bp + -3] ; $fp
0767   084C 2A            mov b, [d]
0768   084D D8            push b
0769   084E FD 77         inc b
0770   0850 FA FD FF      lea d, [bp + -3] ; $fp
0771   0853 FD 43         mov [d], b
0772   0855 E5            pop b
0773   0856 0A 75 08      jmp _if7_exit
0774   0859             _if7_else:
0775   0859             ;; putchar(*fp); 
0776   0859 FA FD FF      lea d, [bp + -3] ; $fp
0777   085C 2A            mov b, [d]
0778   085D 74            mov d, b
0779   085E 32            mov bl, [d]
0780   085F A7 00         mov bh, 0
0781   0861 DD            push bl
0782   0862 07 30 0F      call putchar
0783   0865 51 01 00      add sp, 1
0784   0868             ;; fp++; 
0785   0868 FA FD FF      lea d, [bp + -3] ; $fp
0786   086B 2A            mov b, [d]
0787   086C D8            push b
0788   086D FD 77         inc b
0789   086F FA FD FF      lea d, [bp + -3] ; $fp
0790   0872 FD 43         mov [d], b
0791   0874 E5            pop b
0792   0875             _if7_exit:
0793   0875             _if6_exit:
0794   0875             _for5_update:
0795   0875 0A 50 06      jmp _for5_cond
0796   0878             _for5_exit:
0797   0878 F9            leave
0798   0879 09            ret
0799   087A             
0800   087A             err:
0801   087A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0802   087D             ;; print(e); 
0803   087D FA 05 00      lea d, [bp + 5] ; $e
0804   0880 2A            mov b, [d]
0805   0881 FD AB         swp b
0806   0883 D8            push b
0807   0884 07 78 0F      call print
0808   0887 51 02 00      add sp, 2
0809   088A             ;; exit(); 
0810   088A 07 F2 0F      call exit
0811   088D F9            leave
0812   088E 09            ret
0813   088F             
0814   088F             printx32:
0815   088F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0816   0892             
0817   0892             ; --- BEGIN INLINE ASM BLOCK
0818   0892 FA 05 00      lea d, [bp + 5] ; $hex
0819   0895 2B 02 00      mov b, [d+2]
0820   0898 07 F9 12      call print_u16x
0821   089B 2A            mov b, [d]
0822   089C 07 F9 12      call print_u16x
0823   089F             ; --- END INLINE ASM BLOCK
0824   089F             
0825   089F F9            leave
0826   08A0 09            ret
0827   08A1             
0828   08A1             printx16:
0829   08A1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0830   08A4             
0831   08A4             ; --- BEGIN INLINE ASM BLOCK
0832   08A4 FA 05 00      lea d, [bp + 5] ; $hex
0833   08A7 2A            mov b, [d]
0834   08A8 07 F9 12      call print_u16x
0835   08AB             ; --- END INLINE ASM BLOCK
0836   08AB             
0837   08AB F9            leave
0838   08AC 09            ret
0839   08AD             
0840   08AD             printx8:
0841   08AD F8 00 00      enter 0 ; (push bp; mov bp, sp)
0842   08B0             
0843   08B0             ; --- BEGIN INLINE ASM BLOCK
0844   08B0 FA 05 00      lea d, [bp + 5] ; $hex
0845   08B3 32            mov bl, [d]
0846   08B4 07 3D 13      call print_u8x
0847   08B7             ; --- END INLINE ASM BLOCK
0848   08B7             
0849   08B7 F9            leave
0850   08B8 09            ret
0851   08B9             
0852   08B9             hex_to_int:
0853   08B9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0854   08BC             ; $value 
0855   08BC 10 00 00      mov a, $0
0856   08BF 45 FF FF      mov [bp + -1], a
0857   08C2             ; $i 
0858   08C2             ; $hex_char 
0859   08C2             ; $len 
0860   08C2 52 07 00      sub sp, 7
0861   08C5             ;; len = strlen(hex_string); 
0862   08C5 FA FA FF      lea d, [bp + -6] ; $len
0863   08C8 DA            push d
0864   08C9 FA 05 00      lea d, [bp + 5] ; $hex_string
0865   08CC 2A            mov b, [d]
0866   08CD FD AB         swp b
0867   08CF D8            push b
0868   08D0 07 E3 05      call strlen
0869   08D3 51 02 00      add sp, 2
0870   08D6 E7            pop d
0871   08D7 FD 43         mov [d], b
0872   08D9             ;; for (i = 0; i < len; i++) { 
0873   08D9             _for12_init:
0874   08D9 FA FD FF      lea d, [bp + -3] ; $i
0875   08DC DA            push d
0876   08DD 26 00 00      mov b, $0
0877   08E0 E7            pop d
0878   08E1 FD 43         mov [d], b
0879   08E3             _for12_cond:
0880   08E3 FA FD FF      lea d, [bp + -3] ; $i
0881   08E6 2A            mov b, [d]
0882   08E7             ; START RELATIONAL
0883   08E7 D7            push a
0884   08E8 11            mov a, b
0885   08E9 FA FA FF      lea d, [bp + -6] ; $len
0886   08EC 2A            mov b, [d]
0887   08ED B0            cmp a, b
0888   08EE FD 73         slt ; < 
0889   08F0 E4            pop a
0890   08F1             ; END RELATIONAL
0891   08F1 C0 00 00      cmp b, 0
0892   08F4 C6 F9 09      je _for12_exit
0893   08F7             _for12_block:
0894   08F7             ;; hex_char = hex_string[i]; 
0895   08F7 FA FC FF      lea d, [bp + -4] ; $hex_char
0896   08FA DA            push d
0897   08FB FA 05 00      lea d, [bp + 5] ; $hex_string
0898   08FE FD 2A         mov d, [d]
0899   0900 D7            push a
0900   0901 DA            push d
0901   0902 FA FD FF      lea d, [bp + -3] ; $i
0902   0905 2A            mov b, [d]
0903   0906 E7            pop d
0904   0907 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0905   090B E4            pop a
0906   090C 32            mov bl, [d]
0907   090D A7 00         mov bh, 0
0908   090F E7            pop d
0909   0910 FD 3E         mov [d], bl
0910   0912             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0911   0912             _if13_cond:
0912   0912 FA FC FF      lea d, [bp + -4] ; $hex_char
0913   0915 32            mov bl, [d]
0914   0916 A7 00         mov bh, 0
0915   0918             ; START RELATIONAL
0916   0918 D7            push a
0917   0919 11            mov a, b
0918   091A 26 61 00      mov b, $61
0919   091D B0            cmp a, b
0920   091E FD 80         sge ; >=
0921   0920 E4            pop a
0922   0921             ; END RELATIONAL
0923   0921 D7            push a
0924   0922 11            mov a, b
0925   0923 FA FC FF      lea d, [bp + -4] ; $hex_char
0926   0926 32            mov bl, [d]
0927   0927 A7 00         mov bh, 0
0928   0929             ; START RELATIONAL
0929   0929 D7            push a
0930   092A 11            mov a, b
0931   092B 26 66 00      mov b, $66
0932   092E B0            cmp a, b
0933   092F FD 74         sle ; <=
0934   0931 E4            pop a
0935   0932             ; END RELATIONAL
0936   0932 FD A7         sand a, b ; &&
0937   0934 E4            pop a
0938   0935 C0 00 00      cmp b, 0
0939   0938 C6 6A 09      je _if13_else
0940   093B             _if13_true:
0941   093B             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0942   093B FA FF FF      lea d, [bp + -1] ; $value
0943   093E DA            push d
0944   093F FA FF FF      lea d, [bp + -1] ; $value
0945   0942 2A            mov b, [d]
0946   0943             ; START FACTORS
0947   0943 D7            push a
0948   0944 11            mov a, b
0949   0945 26 10 00      mov b, $10
0950   0948 AC            mul a, b ; *
0951   0949 11            mov a, b
0952   094A 27            mov b, a
0953   094B E4            pop a
0954   094C             ; END FACTORS
0955   094C             ; START TERMS
0956   094C D7            push a
0957   094D 11            mov a, b
0958   094E FA FC FF      lea d, [bp + -4] ; $hex_char
0959   0951 32            mov bl, [d]
0960   0952 A7 00         mov bh, 0
0961   0954             ; START TERMS
0962   0954 D7            push a
0963   0955 11            mov a, b
0964   0956 26 61 00      mov b, $61
0965   0959 60            sub a, b
0966   095A 11            mov a, b
0967   095B 26 0A 00      mov b, $a
0968   095E 54            add a, b
0969   095F 27            mov b, a
0970   0960 E4            pop a
0971   0961             ; END TERMS
0972   0961 54            add a, b
0973   0962 27            mov b, a
0974   0963 E4            pop a
0975   0964             ; END TERMS
0976   0964 E7            pop d
0977   0965 FD 43         mov [d], b
0978   0967 0A E9 09      jmp _if13_exit
0979   096A             _if13_else:
0980   096A             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0981   096A             _if14_cond:
0982   096A FA FC FF      lea d, [bp + -4] ; $hex_char
0983   096D 32            mov bl, [d]
0984   096E A7 00         mov bh, 0
0985   0970             ; START RELATIONAL
0986   0970 D7            push a
0987   0971 11            mov a, b
0988   0972 26 41 00      mov b, $41
0989   0975 B0            cmp a, b
0990   0976 FD 80         sge ; >=
0991   0978 E4            pop a
0992   0979             ; END RELATIONAL
0993   0979 D7            push a
0994   097A 11            mov a, b
0995   097B FA FC FF      lea d, [bp + -4] ; $hex_char
0996   097E 32            mov bl, [d]
0997   097F A7 00         mov bh, 0
0998   0981             ; START RELATIONAL
0999   0981 D7            push a
1000   0982 11            mov a, b
1001   0983 26 46 00      mov b, $46
1002   0986 B0            cmp a, b
1003   0987 FD 74         sle ; <=
1004   0989 E4            pop a
1005   098A             ; END RELATIONAL
1006   098A FD A7         sand a, b ; &&
1007   098C E4            pop a
1008   098D C0 00 00      cmp b, 0
1009   0990 C6 C2 09      je _if14_else
1010   0993             _if14_true:
1011   0993             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1012   0993 FA FF FF      lea d, [bp + -1] ; $value
1013   0996 DA            push d
1014   0997 FA FF FF      lea d, [bp + -1] ; $value
1015   099A 2A            mov b, [d]
1016   099B             ; START FACTORS
1017   099B D7            push a
1018   099C 11            mov a, b
1019   099D 26 10 00      mov b, $10
1020   09A0 AC            mul a, b ; *
1021   09A1 11            mov a, b
1022   09A2 27            mov b, a
1023   09A3 E4            pop a
1024   09A4             ; END FACTORS
1025   09A4             ; START TERMS
1026   09A4 D7            push a
1027   09A5 11            mov a, b
1028   09A6 FA FC FF      lea d, [bp + -4] ; $hex_char
1029   09A9 32            mov bl, [d]
1030   09AA A7 00         mov bh, 0
1031   09AC             ; START TERMS
1032   09AC D7            push a
1033   09AD 11            mov a, b
1034   09AE 26 41 00      mov b, $41
1035   09B1 60            sub a, b
1036   09B2 11            mov a, b
1037   09B3 26 0A 00      mov b, $a
1038   09B6 54            add a, b
1039   09B7 27            mov b, a
1040   09B8 E4            pop a
1041   09B9             ; END TERMS
1042   09B9 54            add a, b
1043   09BA 27            mov b, a
1044   09BB E4            pop a
1045   09BC             ; END TERMS
1046   09BC E7            pop d
1047   09BD FD 43         mov [d], b
1048   09BF 0A E9 09      jmp _if14_exit
1049   09C2             _if14_else:
1050   09C2             ;; value = (value * 16) + (hex_char - '0'); 
1051   09C2 FA FF FF      lea d, [bp + -1] ; $value
1052   09C5 DA            push d
1053   09C6 FA FF FF      lea d, [bp + -1] ; $value
1054   09C9 2A            mov b, [d]
1055   09CA             ; START FACTORS
1056   09CA D7            push a
1057   09CB 11            mov a, b
1058   09CC 26 10 00      mov b, $10
1059   09CF AC            mul a, b ; *
1060   09D0 11            mov a, b
1061   09D1 27            mov b, a
1062   09D2 E4            pop a
1063   09D3             ; END FACTORS
1064   09D3             ; START TERMS
1065   09D3 D7            push a
1066   09D4 11            mov a, b
1067   09D5 FA FC FF      lea d, [bp + -4] ; $hex_char
1068   09D8 32            mov bl, [d]
1069   09D9 A7 00         mov bh, 0
1070   09DB             ; START TERMS
1071   09DB D7            push a
1072   09DC 11            mov a, b
1073   09DD 26 30 00      mov b, $30
1074   09E0 60            sub a, b
1075   09E1 27            mov b, a
1076   09E2 E4            pop a
1077   09E3             ; END TERMS
1078   09E3 54            add a, b
1079   09E4 27            mov b, a
1080   09E5 E4            pop a
1081   09E6             ; END TERMS
1082   09E6 E7            pop d
1083   09E7 FD 43         mov [d], b
1084   09E9             _if14_exit:
1085   09E9             _if13_exit:
1086   09E9             _for12_update:
1087   09E9 FA FD FF      lea d, [bp + -3] ; $i
1088   09EC 2A            mov b, [d]
1089   09ED D8            push b
1090   09EE FD 77         inc b
1091   09F0 FA FD FF      lea d, [bp + -3] ; $i
1092   09F3 FD 43         mov [d], b
1093   09F5 E5            pop b
1094   09F6 0A E3 08      jmp _for12_cond
1095   09F9             _for12_exit:
1096   09F9             ;; return value; 
1097   09F9 FA FF FF      lea d, [bp + -1] ; $value
1098   09FC 2A            mov b, [d]
1099   09FD F9            leave
1100   09FE 09            ret
1101   09FF             
1102   09FF             atoi:
1103   09FF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1104   0A02             ; $result 
1105   0A02 10 00 00      mov a, $0
1106   0A05 45 FF FF      mov [bp + -1], a
1107   0A08             ; $sign 
1108   0A08 10 01 00      mov a, $1
1109   0A0B 45 FD FF      mov [bp + -3], a
1110   0A0E 52 04 00      sub sp, 4
1111   0A11             ;; while (*str == ' ') str++; 
1112   0A11             _while15_cond:
1113   0A11 FA 05 00      lea d, [bp + 5] ; $str
1114   0A14 2A            mov b, [d]
1115   0A15 74            mov d, b
1116   0A16 32            mov bl, [d]
1117   0A17 A7 00         mov bh, 0
1118   0A19             ; START RELATIONAL
1119   0A19 D7            push a
1120   0A1A 11            mov a, b
1121   0A1B 26 20 00      mov b, $20
1122   0A1E B0            cmp a, b
1123   0A1F FD 71         seq ; ==
1124   0A21 E4            pop a
1125   0A22             ; END RELATIONAL
1126   0A22 C0 00 00      cmp b, 0
1127   0A25 C6 38 0A      je _while15_exit
1128   0A28             _while15_block:
1129   0A28             ;; str++; 
1130   0A28 FA 05 00      lea d, [bp + 5] ; $str
1131   0A2B 2A            mov b, [d]
1132   0A2C D8            push b
1133   0A2D FD 77         inc b
1134   0A2F FA 05 00      lea d, [bp + 5] ; $str
1135   0A32 FD 43         mov [d], b
1136   0A34 E5            pop b
1137   0A35 0A 11 0A      jmp _while15_cond
1138   0A38             _while15_exit:
1139   0A38             ;; if (*str == '-' || *str == '+') { 
1140   0A38             _if16_cond:
1141   0A38 FA 05 00      lea d, [bp + 5] ; $str
1142   0A3B 2A            mov b, [d]
1143   0A3C 74            mov d, b
1144   0A3D 32            mov bl, [d]
1145   0A3E A7 00         mov bh, 0
1146   0A40             ; START RELATIONAL
1147   0A40 D7            push a
1148   0A41 11            mov a, b
1149   0A42 26 2D 00      mov b, $2d
1150   0A45 B0            cmp a, b
1151   0A46 FD 71         seq ; ==
1152   0A48 E4            pop a
1153   0A49             ; END RELATIONAL
1154   0A49 D7            push a
1155   0A4A 11            mov a, b
1156   0A4B FA 05 00      lea d, [bp + 5] ; $str
1157   0A4E 2A            mov b, [d]
1158   0A4F 74            mov d, b
1159   0A50 32            mov bl, [d]
1160   0A51 A7 00         mov bh, 0
1161   0A53             ; START RELATIONAL
1162   0A53 D7            push a
1163   0A54 11            mov a, b
1164   0A55 26 2B 00      mov b, $2b
1165   0A58 B0            cmp a, b
1166   0A59 FD 71         seq ; ==
1167   0A5B E4            pop a
1168   0A5C             ; END RELATIONAL
1169   0A5C FD A8         sor a, b ; ||
1170   0A5E E4            pop a
1171   0A5F C0 00 00      cmp b, 0
1172   0A62 C6 9B 0A      je _if16_exit
1173   0A65             _if16_true:
1174   0A65             ;; if (*str == '-') sign = -1; 
1175   0A65             _if17_cond:
1176   0A65 FA 05 00      lea d, [bp + 5] ; $str
1177   0A68 2A            mov b, [d]
1178   0A69 74            mov d, b
1179   0A6A 32            mov bl, [d]
1180   0A6B A7 00         mov bh, 0
1181   0A6D             ; START RELATIONAL
1182   0A6D D7            push a
1183   0A6E 11            mov a, b
1184   0A6F 26 2D 00      mov b, $2d
1185   0A72 B0            cmp a, b
1186   0A73 FD 71         seq ; ==
1187   0A75 E4            pop a
1188   0A76             ; END RELATIONAL
1189   0A76 C0 00 00      cmp b, 0
1190   0A79 C6 8B 0A      je _if17_exit
1191   0A7C             _if17_true:
1192   0A7C             ;; sign = -1; 
1193   0A7C FA FD FF      lea d, [bp + -3] ; $sign
1194   0A7F DA            push d
1195   0A80 26 01 00      mov b, $1
1196   0A83 FD 97         neg b
1197   0A85 E7            pop d
1198   0A86 FD 43         mov [d], b
1199   0A88 0A 8B 0A      jmp _if17_exit
1200   0A8B             _if17_exit:
1201   0A8B             ;; str++; 
1202   0A8B FA 05 00      lea d, [bp + 5] ; $str
1203   0A8E 2A            mov b, [d]
1204   0A8F D8            push b
1205   0A90 FD 77         inc b
1206   0A92 FA 05 00      lea d, [bp + 5] ; $str
1207   0A95 FD 43         mov [d], b
1208   0A97 E5            pop b
1209   0A98 0A 9B 0A      jmp _if16_exit
1210   0A9B             _if16_exit:
1211   0A9B             ;; while (*str >= '0' && *str <= '9') { 
1212   0A9B             _while18_cond:
1213   0A9B FA 05 00      lea d, [bp + 5] ; $str
1214   0A9E 2A            mov b, [d]
1215   0A9F 74            mov d, b
1216   0AA0 32            mov bl, [d]
1217   0AA1 A7 00         mov bh, 0
1218   0AA3             ; START RELATIONAL
1219   0AA3 D7            push a
1220   0AA4 11            mov a, b
1221   0AA5 26 30 00      mov b, $30
1222   0AA8 B0            cmp a, b
1223   0AA9 FD 82         sgeu ; >= (unsigned)
1224   0AAB E4            pop a
1225   0AAC             ; END RELATIONAL
1226   0AAC D7            push a
1227   0AAD 11            mov a, b
1228   0AAE FA 05 00      lea d, [bp + 5] ; $str
1229   0AB1 2A            mov b, [d]
1230   0AB2 74            mov d, b
1231   0AB3 32            mov bl, [d]
1232   0AB4 A7 00         mov bh, 0
1233   0AB6             ; START RELATIONAL
1234   0AB6 D7            push a
1235   0AB7 11            mov a, b
1236   0AB8 26 39 00      mov b, $39
1237   0ABB B0            cmp a, b
1238   0ABC FD 76         sleu ; <= (unsigned)
1239   0ABE E4            pop a
1240   0ABF             ; END RELATIONAL
1241   0ABF FD A7         sand a, b ; &&
1242   0AC1 E4            pop a
1243   0AC2 C0 00 00      cmp b, 0
1244   0AC5 C6 01 0B      je _while18_exit
1245   0AC8             _while18_block:
1246   0AC8             ;; result = result * 10 + (*str - '0'); 
1247   0AC8 FA FF FF      lea d, [bp + -1] ; $result
1248   0ACB DA            push d
1249   0ACC FA FF FF      lea d, [bp + -1] ; $result
1250   0ACF 2A            mov b, [d]
1251   0AD0             ; START FACTORS
1252   0AD0 D7            push a
1253   0AD1 11            mov a, b
1254   0AD2 26 0A 00      mov b, $a
1255   0AD5 AC            mul a, b ; *
1256   0AD6 11            mov a, b
1257   0AD7 27            mov b, a
1258   0AD8 E4            pop a
1259   0AD9             ; END FACTORS
1260   0AD9             ; START TERMS
1261   0AD9 D7            push a
1262   0ADA 11            mov a, b
1263   0ADB FA 05 00      lea d, [bp + 5] ; $str
1264   0ADE 2A            mov b, [d]
1265   0ADF 74            mov d, b
1266   0AE0 32            mov bl, [d]
1267   0AE1 A7 00         mov bh, 0
1268   0AE3             ; START TERMS
1269   0AE3 D7            push a
1270   0AE4 11            mov a, b
1271   0AE5 26 30 00      mov b, $30
1272   0AE8 60            sub a, b
1273   0AE9 27            mov b, a
1274   0AEA E4            pop a
1275   0AEB             ; END TERMS
1276   0AEB 54            add a, b
1277   0AEC 27            mov b, a
1278   0AED E4            pop a
1279   0AEE             ; END TERMS
1280   0AEE E7            pop d
1281   0AEF FD 43         mov [d], b
1282   0AF1             ;; str++; 
1283   0AF1 FA 05 00      lea d, [bp + 5] ; $str
1284   0AF4 2A            mov b, [d]
1285   0AF5 D8            push b
1286   0AF6 FD 77         inc b
1287   0AF8 FA 05 00      lea d, [bp + 5] ; $str
1288   0AFB FD 43         mov [d], b
1289   0AFD E5            pop b
1290   0AFE 0A 9B 0A      jmp _while18_cond
1291   0B01             _while18_exit:
1292   0B01             ;; return sign * result; 
1293   0B01 FA FD FF      lea d, [bp + -3] ; $sign
1294   0B04 2A            mov b, [d]
1295   0B05             ; START FACTORS
1296   0B05 D7            push a
1297   0B06 11            mov a, b
1298   0B07 FA FF FF      lea d, [bp + -1] ; $result
1299   0B0A 2A            mov b, [d]
1300   0B0B AC            mul a, b ; *
1301   0B0C 11            mov a, b
1302   0B0D 27            mov b, a
1303   0B0E E4            pop a
1304   0B0F             ; END FACTORS
1305   0B0F F9            leave
1306   0B10 09            ret
1307   0B11             
1308   0B11             gets:
1309   0B11 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1310   0B14             
1311   0B14             ; --- BEGIN INLINE ASM BLOCK
1312   0B14 FA 05 00      lea d, [bp + 5] ; $s
1313   0B17 15            mov a, [d]
1314   0B18 3C            mov d, a
1315   0B19 07 5E 11      call _gets
1316   0B1C             ; --- END INLINE ASM BLOCK
1317   0B1C             
1318   0B1C             ;; return strlen(s); 
1319   0B1C FA 05 00      lea d, [bp + 5] ; $s
1320   0B1F 2A            mov b, [d]
1321   0B20 FD AB         swp b
1322   0B22 D8            push b
1323   0B23 07 E3 05      call strlen
1324   0B26 51 02 00      add sp, 2
1325   0B29 F9            leave
1326   0B2A 09            ret
1327   0B2B             
1328   0B2B             print_signed:
1329   0B2B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1330   0B2E             ; $digits 
1331   0B2E             ; $i 
1332   0B2E 10 00 00      mov a, $0
1333   0B31 45 FA FF      mov [bp + -6], a
1334   0B34 52 07 00      sub sp, 7
1335   0B37             ;; if (num < 0) { 
1336   0B37             _if19_cond:
1337   0B37 FA 05 00      lea d, [bp + 5] ; $num
1338   0B3A 2A            mov b, [d]
1339   0B3B             ; START RELATIONAL
1340   0B3B D7            push a
1341   0B3C 11            mov a, b
1342   0B3D 26 00 00      mov b, $0
1343   0B40 B0            cmp a, b
1344   0B41 FD 73         slt ; < 
1345   0B43 E4            pop a
1346   0B44             ; END RELATIONAL
1347   0B44 C0 00 00      cmp b, 0
1348   0B47 C6 64 0B      je _if19_else
1349   0B4A             _if19_true:
1350   0B4A             ;; putchar('-'); 
1351   0B4A 26 2D 00      mov b, $2d
1352   0B4D DD            push bl
1353   0B4E 07 30 0F      call putchar
1354   0B51 51 01 00      add sp, 1
1355   0B54             ;; num = -num; 
1356   0B54 FA 05 00      lea d, [bp + 5] ; $num
1357   0B57 DA            push d
1358   0B58 FA 05 00      lea d, [bp + 5] ; $num
1359   0B5B 2A            mov b, [d]
1360   0B5C FD 97         neg b
1361   0B5E E7            pop d
1362   0B5F FD 43         mov [d], b
1363   0B61 0A 86 0B      jmp _if19_exit
1364   0B64             _if19_else:
1365   0B64             ;; if (num == 0) { 
1366   0B64             _if20_cond:
1367   0B64 FA 05 00      lea d, [bp + 5] ; $num
1368   0B67 2A            mov b, [d]
1369   0B68             ; START RELATIONAL
1370   0B68 D7            push a
1371   0B69 11            mov a, b
1372   0B6A 26 00 00      mov b, $0
1373   0B6D B0            cmp a, b
1374   0B6E FD 71         seq ; ==
1375   0B70 E4            pop a
1376   0B71             ; END RELATIONAL
1377   0B71 C0 00 00      cmp b, 0
1378   0B74 C6 86 0B      je _if20_exit
1379   0B77             _if20_true:
1380   0B77             ;; putchar('0'); 
1381   0B77 26 30 00      mov b, $30
1382   0B7A DD            push bl
1383   0B7B 07 30 0F      call putchar
1384   0B7E 51 01 00      add sp, 1
1385   0B81             ;; return; 
1386   0B81 F9            leave
1387   0B82 09            ret
1388   0B83 0A 86 0B      jmp _if20_exit
1389   0B86             _if20_exit:
1390   0B86             _if19_exit:
1391   0B86             ;; while (num > 0) { 
1392   0B86             _while21_cond:
1393   0B86 FA 05 00      lea d, [bp + 5] ; $num
1394   0B89 2A            mov b, [d]
1395   0B8A             ; START RELATIONAL
1396   0B8A D7            push a
1397   0B8B 11            mov a, b
1398   0B8C 26 00 00      mov b, $0
1399   0B8F B0            cmp a, b
1400   0B90 FD 7F         sgt ; >
1401   0B92 E4            pop a
1402   0B93             ; END RELATIONAL
1403   0B93 C0 00 00      cmp b, 0
1404   0B96 C6 E1 0B      je _while21_exit
1405   0B99             _while21_block:
1406   0B99             ;; digits[i] = '0' + (num % 10); 
1407   0B99 FA FC FF      lea d, [bp + -4] ; $digits
1408   0B9C D7            push a
1409   0B9D DA            push d
1410   0B9E FA FA FF      lea d, [bp + -6] ; $i
1411   0BA1 2A            mov b, [d]
1412   0BA2 E7            pop d
1413   0BA3 5A            add d, b
1414   0BA4 E4            pop a
1415   0BA5 DA            push d
1416   0BA6 26 30 00      mov b, $30
1417   0BA9             ; START TERMS
1418   0BA9 D7            push a
1419   0BAA 11            mov a, b
1420   0BAB FA 05 00      lea d, [bp + 5] ; $num
1421   0BAE 2A            mov b, [d]
1422   0BAF             ; START FACTORS
1423   0BAF D7            push a
1424   0BB0 11            mov a, b
1425   0BB1 26 0A 00      mov b, $a
1426   0BB4 AE            div a, b ; 
1427   0BB5 11            mov a, b
1428   0BB6 27            mov b, a
1429   0BB7 E4            pop a
1430   0BB8             ; END FACTORS
1431   0BB8 54            add a, b
1432   0BB9 27            mov b, a
1433   0BBA E4            pop a
1434   0BBB             ; END TERMS
1435   0BBB E7            pop d
1436   0BBC FD 3E         mov [d], bl
1437   0BBE             ;; num = num / 10; 
1438   0BBE FA 05 00      lea d, [bp + 5] ; $num
1439   0BC1 DA            push d
1440   0BC2 FA 05 00      lea d, [bp + 5] ; $num
1441   0BC5 2A            mov b, [d]
1442   0BC6             ; START FACTORS
1443   0BC6 D7            push a
1444   0BC7 11            mov a, b
1445   0BC8 26 0A 00      mov b, $a
1446   0BCB AE            div a, b
1447   0BCC 27            mov b, a
1448   0BCD E4            pop a
1449   0BCE             ; END FACTORS
1450   0BCE E7            pop d
1451   0BCF FD 43         mov [d], b
1452   0BD1             ;; i++; 
1453   0BD1 FA FA FF      lea d, [bp + -6] ; $i
1454   0BD4 2A            mov b, [d]
1455   0BD5 D8            push b
1456   0BD6 FD 77         inc b
1457   0BD8 FA FA FF      lea d, [bp + -6] ; $i
1458   0BDB FD 43         mov [d], b
1459   0BDD E5            pop b
1460   0BDE 0A 86 0B      jmp _while21_cond
1461   0BE1             _while21_exit:
1462   0BE1             ;; while (i > 0) { 
1463   0BE1             _while22_cond:
1464   0BE1 FA FA FF      lea d, [bp + -6] ; $i
1465   0BE4 2A            mov b, [d]
1466   0BE5             ; START RELATIONAL
1467   0BE5 D7            push a
1468   0BE6 11            mov a, b
1469   0BE7 26 00 00      mov b, $0
1470   0BEA B0            cmp a, b
1471   0BEB FD 7F         sgt ; >
1472   0BED E4            pop a
1473   0BEE             ; END RELATIONAL
1474   0BEE C0 00 00      cmp b, 0
1475   0BF1 C6 1A 0C      je _while22_exit
1476   0BF4             _while22_block:
1477   0BF4             ;; i--; 
1478   0BF4 FA FA FF      lea d, [bp + -6] ; $i
1479   0BF7 2A            mov b, [d]
1480   0BF8 D8            push b
1481   0BF9 FD 7D         dec b
1482   0BFB FA FA FF      lea d, [bp + -6] ; $i
1483   0BFE FD 43         mov [d], b
1484   0C00 E5            pop b
1485   0C01             ;; putchar(digits[i]); 
1486   0C01 FA FC FF      lea d, [bp + -4] ; $digits
1487   0C04 D7            push a
1488   0C05 DA            push d
1489   0C06 FA FA FF      lea d, [bp + -6] ; $i
1490   0C09 2A            mov b, [d]
1491   0C0A E7            pop d
1492   0C0B 5A            add d, b
1493   0C0C E4            pop a
1494   0C0D 32            mov bl, [d]
1495   0C0E A7 00         mov bh, 0
1496   0C10 DD            push bl
1497   0C11 07 30 0F      call putchar
1498   0C14 51 01 00      add sp, 1
1499   0C17 0A E1 0B      jmp _while22_cond
1500   0C1A             _while22_exit:
1501   0C1A F9            leave
1502   0C1B 09            ret
1503   0C1C             
1504   0C1C             print_signed_long:
1505   0C1C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1506   0C1F             ; $digits 
1507   0C1F             ; $i 
1508   0C1F 10 00 00      mov a, $0
1509   0C22 45 F5 FF      mov [bp + -11], a
1510   0C25 52 0C 00      sub sp, 12
1511   0C28             ;; if (num < 0) { 
1512   0C28             _if23_cond:
1513   0C28 FA 05 00      lea d, [bp + 5] ; $num
1514   0C2B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1515   0C2E FD 39         mov c, b ; And place it into C
1516   0C30 2A            mov b, [d] ; Lower Word in B
1517   0C31             ; START RELATIONAL
1518   0C31 D7            push a
1519   0C32 FD D8         push g
1520   0C34 11            mov a, b
1521   0C35 FD 7A         mov g, c
1522   0C37 26 00 00      mov b, $0
1523   0C3A B0            cmp a, b
1524   0C3B FD 73         slt ; < 
1525   0C3D FD F1         pop g
1526   0C3F E4            pop a
1527   0C40             ; END RELATIONAL
1528   0C40 C0 00 00      cmp b, 0
1529   0C43 C6 6A 0C      je _if23_else
1530   0C46             _if23_true:
1531   0C46             ;; putchar('-'); 
1532   0C46 26 2D 00      mov b, $2d
1533   0C49 DD            push bl
1534   0C4A 07 30 0F      call putchar
1535   0C4D 51 01 00      add sp, 1
1536   0C50             ;; num = -num; 
1537   0C50 FA 05 00      lea d, [bp + 5] ; $num
1538   0C53 DA            push d
1539   0C54 FA 05 00      lea d, [bp + 5] ; $num
1540   0C57 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1541   0C5A FD 39         mov c, b ; And place it into C
1542   0C5C 2A            mov b, [d] ; Lower Word in B
1543   0C5D FD 97         neg b
1544   0C5F E7            pop d
1545   0C60 FD 43         mov [d], b
1546   0C62 28            mov b, c
1547   0C63 FD 44 02 00   mov [d + 2], b
1548   0C67 0A A1 0C      jmp _if23_exit
1549   0C6A             _if23_else:
1550   0C6A             ;; if (num == 0) { 
1551   0C6A             _if24_cond:
1552   0C6A FA 05 00      lea d, [bp + 5] ; $num
1553   0C6D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1554   0C70 FD 39         mov c, b ; And place it into C
1555   0C72 2A            mov b, [d] ; Lower Word in B
1556   0C73             ; START RELATIONAL
1557   0C73 D7            push a
1558   0C74 FD D8         push g
1559   0C76 11            mov a, b
1560   0C77 FD 7A         mov g, c
1561   0C79 26 00 00      mov b, $0
1562   0C7C B0            cmp a, b
1563   0C7D FD 71         seq ; ==
1564   0C7F D8            push b
1565   0C80 12            mov a, c
1566   0C81 FD 27         mov b, g
1567   0C83 B0            cmp a, b
1568   0C84 FD 71         seq ; ==
1569   0C86 E4            pop a
1570   0C87 FD A7         sand a, b
1571   0C89 FD F1         pop g
1572   0C8B E4            pop a
1573   0C8C             ; END RELATIONAL
1574   0C8C C0 00 00      cmp b, 0
1575   0C8F C6 A1 0C      je _if24_exit
1576   0C92             _if24_true:
1577   0C92             ;; putchar('0'); 
1578   0C92 26 30 00      mov b, $30
1579   0C95 DD            push bl
1580   0C96 07 30 0F      call putchar
1581   0C99 51 01 00      add sp, 1
1582   0C9C             ;; return; 
1583   0C9C F9            leave
1584   0C9D 09            ret
1585   0C9E 0A A1 0C      jmp _if24_exit
1586   0CA1             _if24_exit:
1587   0CA1             _if23_exit:
1588   0CA1             ;; while (num > 0) { 
1589   0CA1             _while25_cond:
1590   0CA1 FA 05 00      lea d, [bp + 5] ; $num
1591   0CA4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1592   0CA7 FD 39         mov c, b ; And place it into C
1593   0CA9 2A            mov b, [d] ; Lower Word in B
1594   0CAA             ; START RELATIONAL
1595   0CAA D7            push a
1596   0CAB FD D8         push g
1597   0CAD 11            mov a, b
1598   0CAE FD 7A         mov g, c
1599   0CB0 26 00 00      mov b, $0
1600   0CB3 B0            cmp a, b
1601   0CB4 FD 7F         sgt ; >
1602   0CB6 FD F1         pop g
1603   0CB8 E4            pop a
1604   0CB9             ; END RELATIONAL
1605   0CB9 C0 00 00      cmp b, 0
1606   0CBC C6 16 0D      je _while25_exit
1607   0CBF             _while25_block:
1608   0CBF             ;; digits[i] = '0' + (num % 10); 
1609   0CBF FA F7 FF      lea d, [bp + -9] ; $digits
1610   0CC2 D7            push a
1611   0CC3 DA            push d
1612   0CC4 FA F5 FF      lea d, [bp + -11] ; $i
1613   0CC7 2A            mov b, [d]
1614   0CC8 E7            pop d
1615   0CC9 5A            add d, b
1616   0CCA E4            pop a
1617   0CCB DA            push d
1618   0CCC 26 30 00      mov b, $30
1619   0CCF             ; START TERMS
1620   0CCF D7            push a
1621   0CD0 11            mov a, b
1622   0CD1 FA 05 00      lea d, [bp + 5] ; $num
1623   0CD4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1624   0CD7 FD 39         mov c, b ; And place it into C
1625   0CD9 2A            mov b, [d] ; Lower Word in B
1626   0CDA             ; START FACTORS
1627   0CDA D7            push a
1628   0CDB 11            mov a, b
1629   0CDC 26 0A 00      mov b, $a
1630   0CDF AE            div a, b ; 
1631   0CE0 11            mov a, b
1632   0CE1 27            mov b, a
1633   0CE2 E4            pop a
1634   0CE3             ; END FACTORS
1635   0CE3 54            add a, b
1636   0CE4 27            mov b, a
1637   0CE5 E4            pop a
1638   0CE6             ; END TERMS
1639   0CE6 E7            pop d
1640   0CE7 FD 3E         mov [d], bl
1641   0CE9             ;; num = num / 10; 
1642   0CE9 FA 05 00      lea d, [bp + 5] ; $num
1643   0CEC DA            push d
1644   0CED FA 05 00      lea d, [bp + 5] ; $num
1645   0CF0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1646   0CF3 FD 39         mov c, b ; And place it into C
1647   0CF5 2A            mov b, [d] ; Lower Word in B
1648   0CF6             ; START FACTORS
1649   0CF6 D7            push a
1650   0CF7 11            mov a, b
1651   0CF8 26 0A 00      mov b, $a
1652   0CFB AE            div a, b
1653   0CFC 27            mov b, a
1654   0CFD E4            pop a
1655   0CFE             ; END FACTORS
1656   0CFE E7            pop d
1657   0CFF FD 43         mov [d], b
1658   0D01 28            mov b, c
1659   0D02 FD 44 02 00   mov [d + 2], b
1660   0D06             ;; i++; 
1661   0D06 FA F5 FF      lea d, [bp + -11] ; $i
1662   0D09 2A            mov b, [d]
1663   0D0A D8            push b
1664   0D0B FD 77         inc b
1665   0D0D FA F5 FF      lea d, [bp + -11] ; $i
1666   0D10 FD 43         mov [d], b
1667   0D12 E5            pop b
1668   0D13 0A A1 0C      jmp _while25_cond
1669   0D16             _while25_exit:
1670   0D16             ;; while (i > 0) { 
1671   0D16             _while26_cond:
1672   0D16 FA F5 FF      lea d, [bp + -11] ; $i
1673   0D19 2A            mov b, [d]
1674   0D1A             ; START RELATIONAL
1675   0D1A D7            push a
1676   0D1B 11            mov a, b
1677   0D1C 26 00 00      mov b, $0
1678   0D1F B0            cmp a, b
1679   0D20 FD 7F         sgt ; >
1680   0D22 E4            pop a
1681   0D23             ; END RELATIONAL
1682   0D23 C0 00 00      cmp b, 0
1683   0D26 C6 4F 0D      je _while26_exit
1684   0D29             _while26_block:
1685   0D29             ;; i--; 
1686   0D29 FA F5 FF      lea d, [bp + -11] ; $i
1687   0D2C 2A            mov b, [d]
1688   0D2D D8            push b
1689   0D2E FD 7D         dec b
1690   0D30 FA F5 FF      lea d, [bp + -11] ; $i
1691   0D33 FD 43         mov [d], b
1692   0D35 E5            pop b
1693   0D36             ;; putchar(digits[i]); 
1694   0D36 FA F7 FF      lea d, [bp + -9] ; $digits
1695   0D39 D7            push a
1696   0D3A DA            push d
1697   0D3B FA F5 FF      lea d, [bp + -11] ; $i
1698   0D3E 2A            mov b, [d]
1699   0D3F E7            pop d
1700   0D40 5A            add d, b
1701   0D41 E4            pop a
1702   0D42 32            mov bl, [d]
1703   0D43 A7 00         mov bh, 0
1704   0D45 DD            push bl
1705   0D46 07 30 0F      call putchar
1706   0D49 51 01 00      add sp, 1
1707   0D4C 0A 16 0D      jmp _while26_cond
1708   0D4F             _while26_exit:
1709   0D4F F9            leave
1710   0D50 09            ret
1711   0D51             
1712   0D51             print_unsigned_long:
1713   0D51 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1714   0D54             ; $digits 
1715   0D54             ; $i 
1716   0D54 52 0C 00      sub sp, 12
1717   0D57             ;; i = 0; 
1718   0D57 FA F5 FF      lea d, [bp + -11] ; $i
1719   0D5A DA            push d
1720   0D5B 26 00 00      mov b, $0
1721   0D5E E7            pop d
1722   0D5F FD 43         mov [d], b
1723   0D61             ;; if(num == 0){ 
1724   0D61             _if27_cond:
1725   0D61 FA 05 00      lea d, [bp + 5] ; $num
1726   0D64 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1727   0D67 FD 39         mov c, b ; And place it into C
1728   0D69 2A            mov b, [d] ; Lower Word in B
1729   0D6A             ; START RELATIONAL
1730   0D6A D7            push a
1731   0D6B FD D8         push g
1732   0D6D 11            mov a, b
1733   0D6E FD 7A         mov g, c
1734   0D70 26 00 00      mov b, $0
1735   0D73 B0            cmp a, b
1736   0D74 FD 71         seq ; ==
1737   0D76 D8            push b
1738   0D77 12            mov a, c
1739   0D78 FD 27         mov b, g
1740   0D7A B0            cmp a, b
1741   0D7B FD 71         seq ; ==
1742   0D7D E4            pop a
1743   0D7E FD A7         sand a, b
1744   0D80 FD F1         pop g
1745   0D82 E4            pop a
1746   0D83             ; END RELATIONAL
1747   0D83 C0 00 00      cmp b, 0
1748   0D86 C6 98 0D      je _if27_exit
1749   0D89             _if27_true:
1750   0D89             ;; putchar('0'); 
1751   0D89 26 30 00      mov b, $30
1752   0D8C DD            push bl
1753   0D8D 07 30 0F      call putchar
1754   0D90 51 01 00      add sp, 1
1755   0D93             ;; return; 
1756   0D93 F9            leave
1757   0D94 09            ret
1758   0D95 0A 98 0D      jmp _if27_exit
1759   0D98             _if27_exit:
1760   0D98             ;; while (num > 0) { 
1761   0D98             _while28_cond:
1762   0D98 FA 05 00      lea d, [bp + 5] ; $num
1763   0D9B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1764   0D9E FD 39         mov c, b ; And place it into C
1765   0DA0 2A            mov b, [d] ; Lower Word in B
1766   0DA1             ; START RELATIONAL
1767   0DA1 D7            push a
1768   0DA2 FD D8         push g
1769   0DA4 11            mov a, b
1770   0DA5 FD 7A         mov g, c
1771   0DA7 26 00 00      mov b, $0
1772   0DAA B0            cmp a, b
1773   0DAB FD 81         sgu ; > (unsigned)
1774   0DAD FD F1         pop g
1775   0DAF E4            pop a
1776   0DB0             ; END RELATIONAL
1777   0DB0 C0 00 00      cmp b, 0
1778   0DB3 C6 0D 0E      je _while28_exit
1779   0DB6             _while28_block:
1780   0DB6             ;; digits[i] = '0' + (num % 10); 
1781   0DB6 FA F7 FF      lea d, [bp + -9] ; $digits
1782   0DB9 D7            push a
1783   0DBA DA            push d
1784   0DBB FA F5 FF      lea d, [bp + -11] ; $i
1785   0DBE 2A            mov b, [d]
1786   0DBF E7            pop d
1787   0DC0 5A            add d, b
1788   0DC1 E4            pop a
1789   0DC2 DA            push d
1790   0DC3 26 30 00      mov b, $30
1791   0DC6             ; START TERMS
1792   0DC6 D7            push a
1793   0DC7 11            mov a, b
1794   0DC8 FA 05 00      lea d, [bp + 5] ; $num
1795   0DCB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1796   0DCE FD 39         mov c, b ; And place it into C
1797   0DD0 2A            mov b, [d] ; Lower Word in B
1798   0DD1             ; START FACTORS
1799   0DD1 D7            push a
1800   0DD2 11            mov a, b
1801   0DD3 26 0A 00      mov b, $a
1802   0DD6 AE            div a, b ; 
1803   0DD7 11            mov a, b
1804   0DD8 27            mov b, a
1805   0DD9 E4            pop a
1806   0DDA             ; END FACTORS
1807   0DDA 54            add a, b
1808   0DDB 27            mov b, a
1809   0DDC E4            pop a
1810   0DDD             ; END TERMS
1811   0DDD E7            pop d
1812   0DDE FD 3E         mov [d], bl
1813   0DE0             ;; num = num / 10; 
1814   0DE0 FA 05 00      lea d, [bp + 5] ; $num
1815   0DE3 DA            push d
1816   0DE4 FA 05 00      lea d, [bp + 5] ; $num
1817   0DE7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1818   0DEA FD 39         mov c, b ; And place it into C
1819   0DEC 2A            mov b, [d] ; Lower Word in B
1820   0DED             ; START FACTORS
1821   0DED D7            push a
1822   0DEE 11            mov a, b
1823   0DEF 26 0A 00      mov b, $a
1824   0DF2 AE            div a, b
1825   0DF3 27            mov b, a
1826   0DF4 E4            pop a
1827   0DF5             ; END FACTORS
1828   0DF5 E7            pop d
1829   0DF6 FD 43         mov [d], b
1830   0DF8 28            mov b, c
1831   0DF9 FD 44 02 00   mov [d + 2], b
1832   0DFD             ;; i++; 
1833   0DFD FA F5 FF      lea d, [bp + -11] ; $i
1834   0E00 2A            mov b, [d]
1835   0E01 D8            push b
1836   0E02 FD 77         inc b
1837   0E04 FA F5 FF      lea d, [bp + -11] ; $i
1838   0E07 FD 43         mov [d], b
1839   0E09 E5            pop b
1840   0E0A 0A 98 0D      jmp _while28_cond
1841   0E0D             _while28_exit:
1842   0E0D             ;; while (i > 0) { 
1843   0E0D             _while29_cond:
1844   0E0D FA F5 FF      lea d, [bp + -11] ; $i
1845   0E10 2A            mov b, [d]
1846   0E11             ; START RELATIONAL
1847   0E11 D7            push a
1848   0E12 11            mov a, b
1849   0E13 26 00 00      mov b, $0
1850   0E16 B0            cmp a, b
1851   0E17 FD 7F         sgt ; >
1852   0E19 E4            pop a
1853   0E1A             ; END RELATIONAL
1854   0E1A C0 00 00      cmp b, 0
1855   0E1D C6 46 0E      je _while29_exit
1856   0E20             _while29_block:
1857   0E20             ;; i--; 
1858   0E20 FA F5 FF      lea d, [bp + -11] ; $i
1859   0E23 2A            mov b, [d]
1860   0E24 D8            push b
1861   0E25 FD 7D         dec b
1862   0E27 FA F5 FF      lea d, [bp + -11] ; $i
1863   0E2A FD 43         mov [d], b
1864   0E2C E5            pop b
1865   0E2D             ;; putchar(digits[i]); 
1866   0E2D FA F7 FF      lea d, [bp + -9] ; $digits
1867   0E30 D7            push a
1868   0E31 DA            push d
1869   0E32 FA F5 FF      lea d, [bp + -11] ; $i
1870   0E35 2A            mov b, [d]
1871   0E36 E7            pop d
1872   0E37 5A            add d, b
1873   0E38 E4            pop a
1874   0E39 32            mov bl, [d]
1875   0E3A A7 00         mov bh, 0
1876   0E3C DD            push bl
1877   0E3D 07 30 0F      call putchar
1878   0E40 51 01 00      add sp, 1
1879   0E43 0A 0D 0E      jmp _while29_cond
1880   0E46             _while29_exit:
1881   0E46 F9            leave
1882   0E47 09            ret
1883   0E48             
1884   0E48             print_unsigned:
1885   0E48 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1886   0E4B             ; $digits 
1887   0E4B             ; $i 
1888   0E4B 52 07 00      sub sp, 7
1889   0E4E             ;; i = 0; 
1890   0E4E FA FA FF      lea d, [bp + -6] ; $i
1891   0E51 DA            push d
1892   0E52 26 00 00      mov b, $0
1893   0E55 E7            pop d
1894   0E56 FD 43         mov [d], b
1895   0E58             ;; if(num == 0){ 
1896   0E58             _if30_cond:
1897   0E58 FA 05 00      lea d, [bp + 5] ; $num
1898   0E5B 2A            mov b, [d]
1899   0E5C             ; START RELATIONAL
1900   0E5C D7            push a
1901   0E5D 11            mov a, b
1902   0E5E 26 00 00      mov b, $0
1903   0E61 B0            cmp a, b
1904   0E62 FD 71         seq ; ==
1905   0E64 E4            pop a
1906   0E65             ; END RELATIONAL
1907   0E65 C0 00 00      cmp b, 0
1908   0E68 C6 7A 0E      je _if30_exit
1909   0E6B             _if30_true:
1910   0E6B             ;; putchar('0'); 
1911   0E6B 26 30 00      mov b, $30
1912   0E6E DD            push bl
1913   0E6F 07 30 0F      call putchar
1914   0E72 51 01 00      add sp, 1
1915   0E75             ;; return; 
1916   0E75 F9            leave
1917   0E76 09            ret
1918   0E77 0A 7A 0E      jmp _if30_exit
1919   0E7A             _if30_exit:
1920   0E7A             ;; while (num > 0) { 
1921   0E7A             _while31_cond:
1922   0E7A FA 05 00      lea d, [bp + 5] ; $num
1923   0E7D 2A            mov b, [d]
1924   0E7E             ; START RELATIONAL
1925   0E7E D7            push a
1926   0E7F 11            mov a, b
1927   0E80 26 00 00      mov b, $0
1928   0E83 B0            cmp a, b
1929   0E84 FD 81         sgu ; > (unsigned)
1930   0E86 E4            pop a
1931   0E87             ; END RELATIONAL
1932   0E87 C0 00 00      cmp b, 0
1933   0E8A C6 D5 0E      je _while31_exit
1934   0E8D             _while31_block:
1935   0E8D             ;; digits[i] = '0' + (num % 10); 
1936   0E8D FA FC FF      lea d, [bp + -4] ; $digits
1937   0E90 D7            push a
1938   0E91 DA            push d
1939   0E92 FA FA FF      lea d, [bp + -6] ; $i
1940   0E95 2A            mov b, [d]
1941   0E96 E7            pop d
1942   0E97 5A            add d, b
1943   0E98 E4            pop a
1944   0E99 DA            push d
1945   0E9A 26 30 00      mov b, $30
1946   0E9D             ; START TERMS
1947   0E9D D7            push a
1948   0E9E 11            mov a, b
1949   0E9F FA 05 00      lea d, [bp + 5] ; $num
1950   0EA2 2A            mov b, [d]
1951   0EA3             ; START FACTORS
1952   0EA3 D7            push a
1953   0EA4 11            mov a, b
1954   0EA5 26 0A 00      mov b, $a
1955   0EA8 AE            div a, b ; 
1956   0EA9 11            mov a, b
1957   0EAA 27            mov b, a
1958   0EAB E4            pop a
1959   0EAC             ; END FACTORS
1960   0EAC 54            add a, b
1961   0EAD 27            mov b, a
1962   0EAE E4            pop a
1963   0EAF             ; END TERMS
1964   0EAF E7            pop d
1965   0EB0 FD 3E         mov [d], bl
1966   0EB2             ;; num = num / 10; 
1967   0EB2 FA 05 00      lea d, [bp + 5] ; $num
1968   0EB5 DA            push d
1969   0EB6 FA 05 00      lea d, [bp + 5] ; $num
1970   0EB9 2A            mov b, [d]
1971   0EBA             ; START FACTORS
1972   0EBA D7            push a
1973   0EBB 11            mov a, b
1974   0EBC 26 0A 00      mov b, $a
1975   0EBF AE            div a, b
1976   0EC0 27            mov b, a
1977   0EC1 E4            pop a
1978   0EC2             ; END FACTORS
1979   0EC2 E7            pop d
1980   0EC3 FD 43         mov [d], b
1981   0EC5             ;; i++; 
1982   0EC5 FA FA FF      lea d, [bp + -6] ; $i
1983   0EC8 2A            mov b, [d]
1984   0EC9 D8            push b
1985   0ECA FD 77         inc b
1986   0ECC FA FA FF      lea d, [bp + -6] ; $i
1987   0ECF FD 43         mov [d], b
1988   0ED1 E5            pop b
1989   0ED2 0A 7A 0E      jmp _while31_cond
1990   0ED5             _while31_exit:
1991   0ED5             ;; while (i > 0) { 
1992   0ED5             _while32_cond:
1993   0ED5 FA FA FF      lea d, [bp + -6] ; $i
1994   0ED8 2A            mov b, [d]
1995   0ED9             ; START RELATIONAL
1996   0ED9 D7            push a
1997   0EDA 11            mov a, b
1998   0EDB 26 00 00      mov b, $0
1999   0EDE B0            cmp a, b
2000   0EDF FD 7F         sgt ; >
2001   0EE1 E4            pop a
2002   0EE2             ; END RELATIONAL
2003   0EE2 C0 00 00      cmp b, 0
2004   0EE5 C6 0E 0F      je _while32_exit
2005   0EE8             _while32_block:
2006   0EE8             ;; i--; 
2007   0EE8 FA FA FF      lea d, [bp + -6] ; $i
2008   0EEB 2A            mov b, [d]
2009   0EEC D8            push b
2010   0EED FD 7D         dec b
2011   0EEF FA FA FF      lea d, [bp + -6] ; $i
2012   0EF2 FD 43         mov [d], b
2013   0EF4 E5            pop b
2014   0EF5             ;; putchar(digits[i]); 
2015   0EF5 FA FC FF      lea d, [bp + -4] ; $digits
2016   0EF8 D7            push a
2017   0EF9 DA            push d
2018   0EFA FA FA FF      lea d, [bp + -6] ; $i
2019   0EFD 2A            mov b, [d]
2020   0EFE E7            pop d
2021   0EFF 5A            add d, b
2022   0F00 E4            pop a
2023   0F01 32            mov bl, [d]
2024   0F02 A7 00         mov bh, 0
2025   0F04 DD            push bl
2026   0F05 07 30 0F      call putchar
2027   0F08 51 01 00      add sp, 1
2028   0F0B 0A D5 0E      jmp _while32_cond
2029   0F0E             _while32_exit:
2030   0F0E F9            leave
2031   0F0F 09            ret
2032   0F10             
2033   0F10             rand:
2034   0F10 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2035   0F13             ; $sec 
2036   0F13 52 01 00      sub sp, 1
2037   0F16             
2038   0F16             ; --- BEGIN INLINE ASM BLOCK
2039   0F16 19 00         mov al, 0
2040   0F18 05 01         syscall sys_rtc					
2041   0F1A 1A            mov al, ah
2042   0F1B FA 00 00      lea d, [bp + 0] ; $sec
2043   0F1E 1E            mov al, [d]
2044   0F1F             ; --- END INLINE ASM BLOCK
2045   0F1F             
2046   0F1F             ;; return sec; 
2047   0F1F FA 00 00      lea d, [bp + 0] ; $sec
2048   0F22 32            mov bl, [d]
2049   0F23 A7 00         mov bh, 0
2050   0F25 F9            leave
2051   0F26 09            ret
2052   0F27             
2053   0F27             date:
2054   0F27 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2055   0F2A             
2056   0F2A             ; --- BEGIN INLINE ASM BLOCK
2057   0F2A 19 00         mov al, 0 
2058   0F2C 05 07         syscall sys_datetime
2059   0F2E             ; --- END INLINE ASM BLOCK
2060   0F2E             
2061   0F2E F9            leave
2062   0F2F 09            ret
2063   0F30             
2064   0F30             putchar:
2065   0F30 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2066   0F33             
2067   0F33             ; --- BEGIN INLINE ASM BLOCK
2068   0F33 FA 05 00      lea d, [bp + 5] ; $c
2069   0F36 1E            mov al, [d]
2070   0F37 23            mov ah, al
2071   0F38 07 57 11      call _putchar
2072   0F3B             ; --- END INLINE ASM BLOCK
2073   0F3B             
2074   0F3B F9            leave
2075   0F3C 09            ret
2076   0F3D             
2077   0F3D             getchar:
2078   0F3D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2079   0F40             ; $c 
2080   0F40 52 01 00      sub sp, 1
2081   0F43             
2082   0F43             ; --- BEGIN INLINE ASM BLOCK
2083   0F43 07 50 11      call getch
2084   0F46 1A            mov al, ah
2085   0F47 FA 00 00      lea d, [bp + 0] ; $c
2086   0F4A 3E            mov [d], al
2087   0F4B             ; --- END INLINE ASM BLOCK
2088   0F4B             
2089   0F4B             ;; return c; 
2090   0F4B FA 00 00      lea d, [bp + 0] ; $c
2091   0F4E 32            mov bl, [d]
2092   0F4F A7 00         mov bh, 0
2093   0F51 F9            leave
2094   0F52 09            ret
2095   0F53             
2096   0F53             scann:
2097   0F53 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2098   0F56             ; $m 
2099   0F56 52 02 00      sub sp, 2
2100   0F59             
2101   0F59             ; --- BEGIN INLINE ASM BLOCK
2102   0F59 07 9B 13      call scan_u16d
2103   0F5C FA FF FF      lea d, [bp + -1] ; $m
2104   0F5F 43            mov [d], a
2105   0F60             ; --- END INLINE ASM BLOCK
2106   0F60             
2107   0F60             ;; return m; 
2108   0F60 FA FF FF      lea d, [bp + -1] ; $m
2109   0F63 2A            mov b, [d]
2110   0F64 F9            leave
2111   0F65 09            ret
2112   0F66             
2113   0F66             puts:
2114   0F66 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2115   0F69             
2116   0F69             ; --- BEGIN INLINE ASM BLOCK
2117   0F69 FA 05 00      lea d, [bp + 5] ; $s
2118   0F6C 15            mov a, [d]
2119   0F6D 3C            mov d, a
2120   0F6E 07 A1 12      call _puts
2121   0F71 10 00 0A      mov a, $0A00
2122   0F74 05 03         syscall sys_io
2123   0F76             ; --- END INLINE ASM BLOCK
2124   0F76             
2125   0F76 F9            leave
2126   0F77 09            ret
2127   0F78             
2128   0F78             print:
2129   0F78 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2130   0F7B             
2131   0F7B             ; --- BEGIN INLINE ASM BLOCK
2132   0F7B FA 05 00      lea d, [bp + 5] ; $s
2133   0F7E FD 2A         mov d, [d]
2134   0F80 07 A1 12      call _puts
2135   0F83             ; --- END INLINE ASM BLOCK
2136   0F83             
2137   0F83 F9            leave
2138   0F84 09            ret
2139   0F85             
2140   0F85             loadfile:
2141   0F85 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2142   0F88             
2143   0F88             ; --- BEGIN INLINE ASM BLOCK
2144   0F88 FA 07 00      lea d, [bp + 7] ; $destination
2145   0F8B 15            mov a, [d]
2146   0F8C 4F            mov di, a
2147   0F8D FA 05 00      lea d, [bp + 5] ; $filename
2148   0F90 FD 2A         mov d, [d]
2149   0F92 19 14         mov al, 20
2150   0F94 05 04         syscall sys_filesystem
2151   0F96             ; --- END INLINE ASM BLOCK
2152   0F96             
2153   0F96 F9            leave
2154   0F97 09            ret
2155   0F98             
2156   0F98             create_file:
2157   0F98 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2158   0F9B F9            leave
2159   0F9C 09            ret
2160   0F9D             
2161   0F9D             delete_file:
2162   0F9D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2163   0FA0             
2164   0FA0             ; --- BEGIN INLINE ASM BLOCK
2165   0FA0 FA 05 00      lea d, [bp + 5] ; $filename
2166   0FA3 19 0A         mov al, 10
2167   0FA5 05 04         syscall sys_filesystem
2168   0FA7             ; --- END INLINE ASM BLOCK
2169   0FA7             
2170   0FA7 F9            leave
2171   0FA8 09            ret
2172   0FA9             
2173   0FA9             fopen:
2174   0FA9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2175   0FAC F9            leave
2176   0FAD 09            ret
2177   0FAE             
2178   0FAE             fclose:
2179   0FAE F8 00 00      enter 0 ; (push bp; mov bp, sp)
2180   0FB1 F9            leave
2181   0FB2 09            ret
2182   0FB3             
2183   0FB3             alloc:
2184   0FB3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2185   0FB6             ;; heap_top = heap_top + bytes; 
2186   0FB6 3B 5D 17      mov d, _heap_top ; $heap_top
2187   0FB9 DA            push d
2188   0FBA 3B 5D 17      mov d, _heap_top ; $heap_top
2189   0FBD 2A            mov b, [d]
2190   0FBE             ; START TERMS
2191   0FBE D7            push a
2192   0FBF 11            mov a, b
2193   0FC0 FA 05 00      lea d, [bp + 5] ; $bytes
2194   0FC3 2A            mov b, [d]
2195   0FC4 54            add a, b
2196   0FC5 27            mov b, a
2197   0FC6 E4            pop a
2198   0FC7             ; END TERMS
2199   0FC7 E7            pop d
2200   0FC8 FD 43         mov [d], b
2201   0FCA             ;; return heap_top - bytes; 
2202   0FCA 3B 5D 17      mov d, _heap_top ; $heap_top
2203   0FCD 2A            mov b, [d]
2204   0FCE             ; START TERMS
2205   0FCE D7            push a
2206   0FCF 11            mov a, b
2207   0FD0 FA 05 00      lea d, [bp + 5] ; $bytes
2208   0FD3 2A            mov b, [d]
2209   0FD4 60            sub a, b
2210   0FD5 27            mov b, a
2211   0FD6 E4            pop a
2212   0FD7             ; END TERMS
2213   0FD7 F9            leave
2214   0FD8 09            ret
2215   0FD9             
2216   0FD9             free:
2217   0FD9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2218   0FDC             ;; return heap_top = heap_top - bytes; 
2219   0FDC 3B 5D 17      mov d, _heap_top ; $heap_top
2220   0FDF DA            push d
2221   0FE0 3B 5D 17      mov d, _heap_top ; $heap_top
2222   0FE3 2A            mov b, [d]
2223   0FE4             ; START TERMS
2224   0FE4 D7            push a
2225   0FE5 11            mov a, b
2226   0FE6 FA 05 00      lea d, [bp + 5] ; $bytes
2227   0FE9 2A            mov b, [d]
2228   0FEA 60            sub a, b
2229   0FEB 27            mov b, a
2230   0FEC E4            pop a
2231   0FED             ; END TERMS
2232   0FED E7            pop d
2233   0FEE FD 43         mov [d], b
2234   0FF0 F9            leave
2235   0FF1 09            ret
2236   0FF2             
2237   0FF2             exit:
2238   0FF2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2239   0FF5             
2240   0FF5             ; --- BEGIN INLINE ASM BLOCK
2241   0FF5 05 0B         syscall sys_terminate_proc
2242   0FF7             ; --- END INLINE ASM BLOCK
2243   0FF7             
2244   0FF7 F9            leave
2245   0FF8 09            ret
2246   0FF9             
2247   0FF9             load_hex:
2248   0FF9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2249   0FFC             ; $temp 
2250   0FFC 52 02 00      sub sp, 2
2251   0FFF             ;; temp = alloc(32768); 
2252   0FFF FA FF FF      lea d, [bp + -1] ; $temp
2253   1002 DA            push d
2254   1003 26 00 80      mov b, $8000
2255   1006 FD AB         swp b
2256   1008 D8            push b
2257   1009 07 B3 0F      call alloc
2258   100C 51 02 00      add sp, 2
2259   100F E7            pop d
2260   1010 FD 43         mov [d], b
2261   1012             
2262   1012             ; --- BEGIN INLINE ASM BLOCK
2263   1012               
2264   1012               
2265   1012               
2266   1012               
2267   1012               
2268   1012             _load_hex:
2269   1012 D7            push a
2270   1013 D8            push b
2271   1014 DA            push d
2272   1015 E2            push si
2273   1016 E3            push di
2274   1017 52 00 80      sub sp, $8000      
2275   101A 38 00 00      mov c, 0
2276   101D 48            mov a, sp
2277   101E 77            inc a
2278   101F 3C            mov d, a          
2279   1020 07 5E 11      call _gets        
2280   1023 4D            mov si, a
2281   1024             __load_hex_loop:
2282   1024 F6            lodsb             
2283   1025 B9 00         cmp al, 0         
2284   1027 C6 35 10      jz __load_hex_ret
2285   102A 36            mov bh, al
2286   102B F6            lodsb
2287   102C 2F            mov bl, al
2288   102D 07 14 11      call _atoi        
2289   1030 F7            stosb             
2290   1031 78            inc c
2291   1032 0A 24 10      jmp __load_hex_loop
2292   1035             __load_hex_ret:
2293   1035 51 00 80      add sp, $8000
2294   1038 F0            pop di
2295   1039 EF            pop si
2296   103A E7            pop d
2297   103B E5            pop b
2298   103C E4            pop a
2299   103D             ; --- END INLINE ASM BLOCK
2300   103D             
2301   103D F9            leave
2302   103E 09            ret
2303   103F             
2304   103F             getparam:
2305   103F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2306   1042             ; $data 
2307   1042 52 01 00      sub sp, 1
2308   1045             
2309   1045             ; --- BEGIN INLINE ASM BLOCK
2310   1045 19 04         mov al, 4
2311   1047 FA 05 00      lea d, [bp + 5] ; $address
2312   104A FD 2A         mov d, [d]
2313   104C 05 0C         syscall sys_system
2314   104E FA 00 00      lea d, [bp + 0] ; $data
2315   1051 FD 3E         mov [d], bl
2316   1053             ; --- END INLINE ASM BLOCK
2317   1053             
2318   1053             ;; return data; 
2319   1053 FA 00 00      lea d, [bp + 0] ; $data
2320   1056 32            mov bl, [d]
2321   1057 A7 00         mov bh, 0
2322   1059 F9            leave
2323   105A 09            ret
2324   105B             
2325   105B             clear:
2326   105B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2327   105E             ;; print("\033[2J\033[H"); 
2328   105E 26 55 17      mov b, __s5 ; "\033[2J\033[H"
2329   1061 FD AB         swp b
2330   1063 D8            push b
2331   1064 07 78 0F      call print
2332   1067 51 02 00      add sp, 2
2333   106A F9            leave
2334   106B 09            ret
2335   106C             
2336   106C             include_stdio_asm:
2337   106C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2338   106F             
2339   106F             ; --- BEGIN INLINE ASM BLOCK
2340   106F             .include "lib/asm/stdio.asm"
0001+  106F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  106F             ; stdio.s
0003+  106F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  106F             .include "lib/asm/string.asm"
0001++ 106F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 106F             ; string.s
0003++ 106F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 106F             
0005++ 106F             
0006++ 106F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 106F             ; _strrev
0008++ 106F             ; reverse a string
0009++ 106F             ; D = string address
0010++ 106F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 106F             ; 01234
0012++ 106F             _strrev:
0013++ 106F 4B          	pusha
0014++ 1070 07 B6 10    	call _strlen	; length in C
0015++ 1073 12          	mov a, c
0016++ 1074 AF 01 00    	cmp a, 1
0017++ 1077 D0 91 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 107A 7D          	dec a
0019++ 107B FD 4E       	mov si, d	; beginning of string
0020++ 107D FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 107F 59          	add d, a	; end of string
0022++ 1080 12          	mov a, c
0023++ 1081 FD 9B       	shr a		; divide by 2
0024++ 1083 39          	mov c, a	; C now counts the steps
0025++ 1084             _strrev_L0:
0026++ 1084 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1085 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1086 3E          	mov [d], al	; store left char into right side
0029++ 1087 1B          	mov al, bl
0030++ 1088 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1089 7E          	dec c
0032++ 108A 7F          	dec d
0033++ 108B C2 00 00    	cmp c, 0
0034++ 108E C7 84 10    	jne _strrev_L0
0035++ 1091             _strrev_end:
0036++ 1091 4C          	popa
0037++ 1092 09          	ret
0038++ 1093             	
0039++ 1093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1093             ; _strchr
0041++ 1093             ; search string in D for char in AL
0042++ 1093             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1093             _strchr:
0044++ 1093             _strchr_L0:
0045++ 1093 32          	mov bl, [d]
0046++ 1094 C1 00       	cmp bl, 0
0047++ 1096 C6 A1 10    	je _strchr_end
0048++ 1099 BA          	cmp al, bl
0049++ 109A C6 A1 10    	je _strchr_end
0050++ 109D 79          	inc d
0051++ 109E 0A 93 10    	jmp _strchr_L0
0052++ 10A1             _strchr_end:
0053++ 10A1 1B          	mov al, bl
0054++ 10A2 09          	ret
0055++ 10A3             
0056++ 10A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10A3             ; _strstr
0058++ 10A3             ; find sub-string
0059++ 10A3             ; str1 in SI
0060++ 10A3             ; str2 in DI
0061++ 10A3             ; SI points to end of source string
0062++ 10A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10A3             _strstr:
0064++ 10A3 DB          	push al
0065++ 10A4 DA          	push d
0066++ 10A5 E3          	push di
0067++ 10A6             _strstr_loop:
0068++ 10A6 F3          	cmpsb					; compare a byte of the strings
0069++ 10A7 C7 B2 10    	jne _strstr_ret
0070++ 10AA FC 00 00    	lea d, [di + 0]
0071++ 10AD BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 10AF C7 A6 10    	jne _strstr_loop				; equal chars but not at end
0073++ 10B2             _strstr_ret:
0074++ 10B2 F0          	pop di
0075++ 10B3 E7          	pop d
0076++ 10B4 E8          	pop al
0077++ 10B5 09          	ret
0078++ 10B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 10B6             ; length of null terminated string
0080++ 10B6             ; result in C
0081++ 10B6             ; pointer in D
0082++ 10B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 10B6             _strlen:
0084++ 10B6 DA          	push d
0085++ 10B7 38 00 00    	mov c, 0
0086++ 10BA             _strlen_L1:
0087++ 10BA BD 00       	cmp byte [d], 0
0088++ 10BC C6 C4 10    	je _strlen_ret
0089++ 10BF 79          	inc d
0090++ 10C0 78          	inc c
0091++ 10C1 0A BA 10    	jmp _strlen_L1
0092++ 10C4             _strlen_ret:
0093++ 10C4 E7          	pop d
0094++ 10C5 09          	ret
0095++ 10C6             
0096++ 10C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 10C6             ; STRCMP
0098++ 10C6             ; compare two strings
0099++ 10C6             ; str1 in SI
0100++ 10C6             ; str2 in DI
0101++ 10C6             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 10C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 10C6             _strcmp:
0104++ 10C6 DB          	push al
0105++ 10C7 DA          	push d
0106++ 10C8 E3          	push di
0107++ 10C9 E2          	push si
0108++ 10CA             _strcmp_loop:
0109++ 10CA F3          	cmpsb					; compare a byte of the strings
0110++ 10CB C7 D6 10    	jne _strcmp_ret
0111++ 10CE FB FF FF    	lea d, [si +- 1]
0112++ 10D1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 10D3 C7 CA 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 10D6             _strcmp_ret:
0115++ 10D6 EF          	pop si
0116++ 10D7 F0          	pop di
0117++ 10D8 E7          	pop d
0118++ 10D9 E8          	pop al
0119++ 10DA 09          	ret
0120++ 10DB             
0121++ 10DB             
0122++ 10DB             ; STRCPY
0123++ 10DB             ; copy null terminated string from SI to DI
0124++ 10DB             ; source in SI
0125++ 10DB             ; destination in DI
0126++ 10DB             _strcpy:
0127++ 10DB E2          	push si
0128++ 10DC E3          	push di
0129++ 10DD DB          	push al
0130++ 10DE             _strcpy_L1:
0131++ 10DE F6          	lodsb
0132++ 10DF F7          	stosb
0133++ 10E0 B9 00       	cmp al, 0
0134++ 10E2 C7 DE 10    	jne _strcpy_L1
0135++ 10E5             _strcpy_end:
0136++ 10E5 E8          	pop al
0137++ 10E6 F0          	pop di
0138++ 10E7 EF          	pop si
0139++ 10E8 09          	ret
0140++ 10E9             
0141++ 10E9             ; STRCAT
0142++ 10E9             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 10E9             ; source in SI
0144++ 10E9             ; destination in DI
0145++ 10E9             _strcat:
0146++ 10E9 E2          	push si
0147++ 10EA E3          	push di
0148++ 10EB D7          	push a
0149++ 10EC DA          	push d
0150++ 10ED 50          	mov a, di
0151++ 10EE 3C          	mov d, a
0152++ 10EF             _strcat_goto_end_L1:
0153++ 10EF BD 00       	cmp byte[d], 0
0154++ 10F1 C6 F8 10    	je _strcat_start
0155++ 10F4 79          	inc d
0156++ 10F5 0A EF 10    	jmp _strcat_goto_end_L1
0157++ 10F8             _strcat_start:
0158++ 10F8 FD 50       	mov di, d
0159++ 10FA             _strcat_L1:
0160++ 10FA F6          	lodsb
0161++ 10FB F7          	stosb
0162++ 10FC B9 00       	cmp al, 0
0163++ 10FE C7 FA 10    	jne _strcat_L1
0164++ 1101             _strcat_end:
0165++ 1101 E7          	pop d
0166++ 1102 E4          	pop a
0167++ 1103 F0          	pop di
0168++ 1104 EF          	pop si
0169++ 1105 09          	ret
0170++ 1106             
0171++ 1106             
0005+  1106             
0006+  1106             
0007+  1106             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1106             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  1106             ; ASCII in BL
0010+  1106             ; result in AL
0011+  1106             ; ascii for F = 0100 0110
0012+  1106             ; ascii for 9 = 0011 1001
0013+  1106             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1106             hex_ascii_encode:
0015+  1106 1B            mov al, bl
0016+  1107 93 40         test al, $40        ; test if letter or number
0017+  1109 C7 0F 11      jnz hex_letter
0018+  110C 87 0F         and al, $0F        ; get number
0019+  110E 09            ret
0020+  110F             hex_letter:
0021+  110F 87 0F         and al, $0F        ; get letter
0022+  1111 6A 09         add al, 9
0023+  1113 09            ret
0024+  1114             
0025+  1114             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1114             ; ATOI
0027+  1114             ; 2 letter hex string in B
0028+  1114             ; 8bit integer returned in AL
0029+  1114             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1114             _atoi:
0031+  1114 D8            push b
0032+  1115 07 06 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  1118 30            mov bl, bh
0034+  1119 DB            push al          ; save a
0035+  111A 07 06 11      call hex_ascii_encode
0036+  111D EA            pop bl  
0037+  111E FD 9E 04      shl al, 4
0038+  1121 8C            or al, bl
0039+  1122 E5            pop b
0040+  1123 09            ret  
0041+  1124             
0042+  1124             
0043+  1124             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1124             ; scanf
0045+  1124             ; no need for explanations!
0046+  1124             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1124             scanf:
0048+  1124 09            ret
0049+  1125             
0050+  1125             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1125             ; ITOA
0052+  1125             ; 8bit value in BL
0053+  1125             ; 2 byte ASCII result in A
0054+  1125             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1125             _itoa:
0056+  1125 DA            push d
0057+  1126 D8            push b
0058+  1127 A7 00         mov bh, 0
0059+  1129 FD A4 04      shr bl, 4  
0060+  112C 74            mov d, b
0061+  112D 1F D5 13      mov al, [d + s_hex_digits]
0062+  1130 23            mov ah, al
0063+  1131               
0064+  1131 E5            pop b
0065+  1132 D8            push b
0066+  1133 A7 00         mov bh, 0
0067+  1135 FD 87 0F      and bl, $0F
0068+  1138 74            mov d, b
0069+  1139 1F D5 13      mov al, [d + s_hex_digits]
0070+  113C E5            pop b
0071+  113D E7            pop d
0072+  113E 09            ret
0073+  113F             
0074+  113F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  113F             ; HEX STRING TO BINARY
0076+  113F             ; di = destination address
0077+  113F             ; si = source
0078+  113F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  113F             _hex_to_int:
0080+  113F             _hex_to_int_L1:
0081+  113F F6            lodsb          ; load from [SI] to AL
0082+  1140 B9 00         cmp al, 0        ; check if ASCII 0
0083+  1142 C6 4F 11      jz _hex_to_int_ret
0084+  1145 36            mov bh, al
0085+  1146 F6            lodsb
0086+  1147 2F            mov bl, al
0087+  1148 07 14 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  114B F7            stosb          ; store AL to [DI]
0089+  114C 0A 3F 11      jmp _hex_to_int_L1
0090+  114F             _hex_to_int_ret:
0091+  114F 09            ret    
0092+  1150             
0093+  1150             
0094+  1150             
0095+  1150             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1150             ; GETCHAR
0097+  1150             ; char in ah
0098+  1150             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1150             getch:
0100+  1150 DB            push al
0101+  1151             getch_retry:
0102+  1151 19 01         mov al, 1
0103+  1153 05 03         syscall sys_io      ; receive in AH
0104+  1155 E8            pop al
0105+  1156 09            ret
0106+  1157             
0107+  1157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  1157             ; PUTCHAR
0109+  1157             ; char in ah
0110+  1157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  1157             _putchar:
0112+  1157 D7            push a
0113+  1158 19 00         mov al, 0
0114+  115A 05 03         syscall sys_io      ; char in AH
0115+  115C E4            pop a
0116+  115D 09            ret
0117+  115E             
0118+  115E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  115E             ;; INPUT A STRING
0120+  115E             ;; terminates with null
0121+  115E             ;; pointer in D
0122+  115E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  115E             _gets:
0124+  115E D7            push a
0125+  115F DA            push d
0126+  1160             _gets_loop:
0127+  1160 19 01         mov al, 1
0128+  1162 05 03         syscall sys_io      ; receive in AH
0129+  1164 B9 00         cmp al, 0        ; check error code (AL)
0130+  1166 C6 60 11      je _gets_loop      ; if no char received, retry
0131+  1169             
0132+  1169 76 1B         cmp ah, 27
0133+  116B C6 8C 11      je _gets_ansi_esc
0134+  116E 76 0A         cmp ah, $0A        ; LF
0135+  1170 C6 F7 11      je _gets_end
0136+  1173 76 0D         cmp ah, $0D        ; CR
0137+  1175 C6 F7 11      je _gets_end
0138+  1178 76 5C         cmp ah, $5C        ; '\\'
0139+  117A C6 B8 11      je _gets_escape
0140+  117D               
0141+  117D 76 08         cmp ah, $08      ; check for backspace
0142+  117F C6 88 11      je _gets_backspace
0143+  1182             
0144+  1182 1A            mov al, ah
0145+  1183 3E            mov [d], al
0146+  1184 79            inc d
0147+  1185 0A 60 11      jmp _gets_loop
0148+  1188             _gets_backspace:
0149+  1188 7F            dec d
0150+  1189 0A 60 11      jmp _gets_loop
0151+  118C             _gets_ansi_esc:
0152+  118C 19 01         mov al, 1
0153+  118E 05 03         syscall sys_io        ; receive in AH without echo
0154+  1190 B9 00         cmp al, 0          ; check error code (AL)
0155+  1192 C6 8C 11      je _gets_ansi_esc    ; if no char received, retry
0156+  1195 76 5B         cmp ah, '['
0157+  1197 C7 60 11      jne _gets_loop
0158+  119A             _gets_ansi_esc_2:
0159+  119A 19 01         mov al, 1
0160+  119C 05 03         syscall sys_io          ; receive in AH without echo
0161+  119E B9 00         cmp al, 0            ; check error code (AL)
0162+  11A0 C6 9A 11      je _gets_ansi_esc_2  ; if no char received, retry
0163+  11A3 76 44         cmp ah, 'D'
0164+  11A5 C6 B0 11      je _gets_left_arrow
0165+  11A8 76 43         cmp ah, 'C'
0166+  11AA C6 B4 11      je _gets_right_arrow
0167+  11AD 0A 60 11      jmp _gets_loop
0168+  11B0             _gets_left_arrow:
0169+  11B0 7F            dec d
0170+  11B1 0A 60 11      jmp _gets_loop
0171+  11B4             _gets_right_arrow:
0172+  11B4 79            inc d
0173+  11B5 0A 60 11      jmp _gets_loop
0174+  11B8             _gets_escape:
0175+  11B8 19 01         mov al, 1
0176+  11BA 05 03         syscall sys_io      ; receive in AH
0177+  11BC B9 00         cmp al, 0        ; check error code (AL)
0178+  11BE C6 B8 11      je _gets_escape      ; if no char received, retry
0179+  11C1 76 6E         cmp ah, 'n'
0180+  11C3 C6 E2 11      je _gets_LF
0181+  11C6 76 72         cmp ah, 'r'
0182+  11C8 C6 E9 11      je _gets_CR
0183+  11CB 76 30         cmp ah, '0'
0184+  11CD C6 F0 11      je _gets_NULL
0185+  11D0 76 5C         cmp ah, $5C  ; '\'
0186+  11D2 C6 DB 11      je _gets_slash
0187+  11D5 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  11D6 3E            mov [d], al
0189+  11D7 79            inc d
0190+  11D8 0A 60 11      jmp _gets_loop
0191+  11DB             _gets_slash:
0192+  11DB 19 5C         mov al, $5C
0193+  11DD 3E            mov [d], al
0194+  11DE 79            inc d
0195+  11DF 0A 60 11      jmp _gets_loop
0196+  11E2             _gets_LF:
0197+  11E2 19 0A         mov al, $0A
0198+  11E4 3E            mov [d], al
0199+  11E5 79            inc d
0200+  11E6 0A 60 11      jmp _gets_loop
0201+  11E9             _gets_CR:
0202+  11E9 19 0D         mov al, $0D
0203+  11EB 3E            mov [d], al
0204+  11EC 79            inc d
0205+  11ED 0A 60 11      jmp _gets_loop
0206+  11F0             _gets_NULL:
0207+  11F0 19 00         mov al, $00
0208+  11F2 3E            mov [d], al
0209+  11F3 79            inc d
0210+  11F4 0A 60 11      jmp _gets_loop
0211+  11F7             _gets_end:
0212+  11F7 19 00         mov al, 0
0213+  11F9 3E            mov [d], al        ; terminate string
0214+  11FA E7            pop d
0215+  11FB E4            pop a
0216+  11FC 09            ret
0217+  11FD             
0218+  11FD             
0219+  11FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  11FD             ;; INPUT TEXT
0221+  11FD             ;; terminated with CTRL+D
0222+  11FD             ;; pointer in D
0223+  11FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  11FD             _gettxt:
0225+  11FD D7            push a
0226+  11FE DA            push d
0227+  11FF             _gettxt_loop:
0228+  11FF 19 01         mov al, 1
0229+  1201 05 03         syscall sys_io      ; receive in AH
0230+  1203 B9 00         cmp al, 0        ; check error code (AL)
0231+  1205 C6 FF 11      je _gettxt_loop    ; if no char received, retry
0232+  1208 76 04         cmp ah, 4      ; EOT
0233+  120A C6 48 12      je _gettxt_end
0234+  120D 76 08         cmp ah, $08      ; check for backspace
0235+  120F C6 44 12      je _gettxt_backspace
0236+  1212 76 5C         cmp ah, $5C        ; '\'
0237+  1214 C6 1D 12      je _gettxt_escape
0238+  1217 1A            mov al, ah
0239+  1218 3E            mov [d], al
0240+  1219 79            inc d
0241+  121A 0A FF 11      jmp _gettxt_loop
0242+  121D             _gettxt_escape:
0243+  121D 19 01         mov al, 1
0244+  121F 05 03         syscall sys_io      ; receive in AH
0245+  1221 B9 00         cmp al, 0        ; check error code (AL)
0246+  1223 C6 1D 12      je _gettxt_escape    ; if no char received, retry
0247+  1226 76 6E         cmp ah, 'n'
0248+  1228 C6 36 12      je _gettxt_LF
0249+  122B 76 72         cmp ah, 'r'
0250+  122D C6 3D 12      je _gettxt_CR
0251+  1230 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  1231 3E            mov [d], al
0253+  1232 79            inc d
0254+  1233 0A FF 11      jmp _gettxt_loop
0255+  1236             _gettxt_LF:
0256+  1236 19 0A         mov al, $0A
0257+  1238 3E            mov [d], al
0258+  1239 79            inc d
0259+  123A 0A FF 11      jmp _gettxt_loop
0260+  123D             _gettxt_CR:
0261+  123D 19 0D         mov al, $0D
0262+  123F 3E            mov [d], al
0263+  1240 79            inc d
0264+  1241 0A FF 11      jmp _gettxt_loop
0265+  1244             _gettxt_backspace:
0266+  1244 7F            dec d
0267+  1245 0A FF 11      jmp _gettxt_loop
0268+  1248             _gettxt_end:
0269+  1248 19 00         mov al, 0
0270+  124A 3E            mov [d], al        ; terminate string
0271+  124B E7            pop d
0272+  124C E4            pop a
0273+  124D 09            ret
0274+  124E             
0275+  124E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  124E             ; PRINT NEW LINE
0277+  124E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  124E             printnl:
0279+  124E D7            push a
0280+  124F 10 00 0A      mov a, $0A00
0281+  1252 05 03         syscall sys_io
0282+  1254 10 00 0D      mov a, $0D00
0283+  1257 05 03         syscall sys_io
0284+  1259 E4            pop a
0285+  125A 09            ret
0286+  125B             
0287+  125B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  125B             ; _strtoint
0289+  125B             ; 4 digit hex string number in d
0290+  125B             ; integer returned in A
0291+  125B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  125B             _strtointx:
0293+  125B D8            push b
0294+  125C 32            mov bl, [d]
0295+  125D 37            mov bh, bl
0296+  125E 33 01 00      mov bl, [d + 1]
0297+  1261 07 14 11      call _atoi        ; convert to int in AL
0298+  1264 23            mov ah, al        ; move to AH
0299+  1265 33 02 00      mov bl, [d + 2]
0300+  1268 37            mov bh, bl
0301+  1269 33 03 00      mov bl, [d + 3]
0302+  126C 07 14 11      call _atoi        ; convert to int in AL
0303+  126F E5            pop b
0304+  1270 09            ret
0305+  1271             
0306+  1271             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  1271             ; _strtoint
0308+  1271             ; 5 digit base10 string number in d
0309+  1271             ; integer returned in A
0310+  1271             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  1271             _strtoint:
0312+  1271 E2            push si
0313+  1272 D8            push b
0314+  1273 D9            push c
0315+  1274 DA            push d
0316+  1275 07 B6 10      call _strlen      ; get string length in C
0317+  1278 7E            dec c
0318+  1279 FD 4E         mov si, d
0319+  127B 12            mov a, c
0320+  127C FD 99         shl a
0321+  127E 3B ED 13      mov d, table_power
0322+  1281 59            add d, a
0323+  1282 38 00 00      mov c, 0
0324+  1285             _strtoint_L0:
0325+  1285 F6            lodsb      ; load ASCII to al
0326+  1286 B9 00         cmp al, 0
0327+  1288 C6 9B 12      je _strtoint_end
0328+  128B 6F 30         sub al, $30    ; make into integer
0329+  128D 22 00         mov ah, 0
0330+  128F 2A            mov b, [d]
0331+  1290 AC            mul a, b      ; result in B since it fits in 16bits
0332+  1291 11            mov a, b
0333+  1292 28            mov b, c
0334+  1293 54            add a, b
0335+  1294 39            mov c, a
0336+  1295 63 02 00      sub d, 2
0337+  1298 0A 85 12      jmp _strtoint_L0
0338+  129B             _strtoint_end:
0339+  129B 12            mov a, c
0340+  129C E7            pop d
0341+  129D E6            pop c
0342+  129E E5            pop b
0343+  129F EF            pop si
0344+  12A0 09            ret
0345+  12A1             
0346+  12A1             
0347+  12A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  12A1             ; PRINT NULL TERMINATED STRING
0349+  12A1             ; pointer in D
0350+  12A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  12A1             _puts:
0352+  12A1 D7            push a
0353+  12A2 DA            push d
0354+  12A3             _puts_L1:
0355+  12A3 1E            mov al, [d]
0356+  12A4 B9 00         cmp al, 0
0357+  12A6 C6 B2 12      jz _puts_END
0358+  12A9 23            mov ah, al
0359+  12AA 19 00         mov al, 0
0360+  12AC 05 03         syscall sys_io
0361+  12AE 79            inc d
0362+  12AF 0A A3 12      jmp _puts_L1
0363+  12B2             _puts_END:
0364+  12B2 E7            pop d
0365+  12B3 E4            pop a
0366+  12B4 09            ret
0367+  12B5             
0368+  12B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  12B5             ; PRINT N SIZE STRING
0370+  12B5             ; pointer in D
0371+  12B5             ; size in C
0372+  12B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  12B5             _putsn:
0374+  12B5 DB            push al
0375+  12B6 DA            push d
0376+  12B7 D9            push c
0377+  12B8             _putsn_L0:
0378+  12B8 1E            mov al, [d]
0379+  12B9 23            mov ah, al
0380+  12BA 19 00         mov al, 0
0381+  12BC 05 03         syscall sys_io
0382+  12BE 79            inc d
0383+  12BF 7E            dec c  
0384+  12C0 C2 00 00      cmp c, 0
0385+  12C3 C7 B8 12      jne _putsn_L0
0386+  12C6             _putsn_end:
0387+  12C6 E6            pop c
0388+  12C7 E7            pop d
0389+  12C8 E8            pop al
0390+  12C9 09            ret
0391+  12CA             
0392+  12CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  12CA             ; print 16bit decimal number
0394+  12CA             ; input number in A
0395+  12CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  12CA             print_u16d:
0397+  12CA D7            push a
0398+  12CB D8            push b
0399+  12CC 26 10 27      mov b, 10000
0400+  12CF AE            div a, b      ; get 10000's coeff.
0401+  12D0 07 F2 12      call print_number
0402+  12D3 11            mov a, b
0403+  12D4 26 E8 03      mov b, 1000
0404+  12D7 AE            div a, b      ; get 1000's coeff.
0405+  12D8 07 F2 12      call print_number
0406+  12DB 11            mov a, b
0407+  12DC 26 64 00      mov b, 100
0408+  12DF AE            div a, b
0409+  12E0 07 F2 12      call print_number
0410+  12E3 11            mov a, b
0411+  12E4 26 0A 00      mov b, 10
0412+  12E7 AE            div a, b
0413+  12E8 07 F2 12      call print_number
0414+  12EB 1B            mov al, bl      ; 1's coeff in bl
0415+  12EC 07 F2 12      call print_number
0416+  12EF E5            pop b
0417+  12F0 E4            pop a
0418+  12F1 09            ret
0419+  12F2             
0420+  12F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  12F2             ; print AL
0422+  12F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  12F2             print_number:
0424+  12F2 6A 30         add al, $30
0425+  12F4 23            mov ah, al
0426+  12F5 07 57 11      call _putchar
0427+  12F8 09            ret
0428+  12F9             
0429+  12F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  12F9             ; PRINT 16BIT HEX INTEGER
0431+  12F9             ; integer value in reg B
0432+  12F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  12F9             print_u16x:
0434+  12F9 D7            push a
0435+  12FA D8            push b
0436+  12FB DD            push bl
0437+  12FC 30            mov bl, bh
0438+  12FD 07 25 11      call _itoa        ; convert bh to char in A
0439+  1300 2F            mov bl, al        ; save al
0440+  1301 19 00         mov al, 0
0441+  1303 05 03         syscall sys_io        ; display AH
0442+  1305 24            mov ah, bl        ; retrieve al
0443+  1306 19 00         mov al, 0
0444+  1308 05 03         syscall sys_io        ; display AL
0445+  130A             
0446+  130A EA            pop bl
0447+  130B 07 25 11      call _itoa        ; convert bh to char in A
0448+  130E 2F            mov bl, al        ; save al
0449+  130F 19 00         mov al, 0
0450+  1311 05 03         syscall sys_io        ; display AH
0451+  1313 24            mov ah, bl        ; retrieve al
0452+  1314 19 00         mov al, 0
0453+  1316 05 03         syscall sys_io        ; display AL
0454+  1318             
0455+  1318 E5            pop b
0456+  1319 E4            pop a
0457+  131A 09            ret
0458+  131B             
0459+  131B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  131B             ; INPUT 16BIT HEX INTEGER
0461+  131B             ; read 16bit integer into A
0462+  131B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  131B             scan_u16x:
0464+  131B F8 10 00      enter 16
0465+  131E D8            push b
0466+  131F DA            push d
0467+  1320             
0468+  1320 FA F1 FF      lea d, [bp + -15]
0469+  1323 07 5E 11      call _gets        ; get number
0470+  1326             
0471+  1326 32            mov bl, [d]
0472+  1327 37            mov bh, bl
0473+  1328 33 01 00      mov bl, [d + 1]
0474+  132B 07 14 11      call _atoi        ; convert to int in AL
0475+  132E 23            mov ah, al        ; move to AH
0476+  132F             
0477+  132F 33 02 00      mov bl, [d + 2]
0478+  1332 37            mov bh, bl
0479+  1333 33 03 00      mov bl, [d + 3]
0480+  1336 07 14 11      call _atoi        ; convert to int in AL
0481+  1339             
0482+  1339 E7            pop d
0483+  133A E5            pop b
0484+  133B F9            leave
0485+  133C 09            ret
0486+  133D             
0487+  133D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  133D             ; PRINT 8bit HEX INTEGER
0489+  133D             ; integer value in reg bl
0490+  133D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  133D             print_u8x:
0492+  133D D7            push a
0493+  133E DD            push bl
0494+  133F             
0495+  133F 07 25 11      call _itoa        ; convert bl to char in A
0496+  1342 2F            mov bl, al        ; save al
0497+  1343 19 00         mov al, 0
0498+  1345 05 03         syscall sys_io        ; display AH
0499+  1347 24            mov ah, bl        ; retrieve al
0500+  1348 19 00         mov al, 0
0501+  134A 05 03         syscall sys_io        ; display AL
0502+  134C             
0503+  134C EA            pop bl
0504+  134D E4            pop a
0505+  134E 09            ret
0506+  134F             
0507+  134F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  134F             ; print 8bit decimal unsigned number
0509+  134F             ; input number in AL
0510+  134F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  134F             print_u8d:
0512+  134F D7            push a
0513+  1350 D8            push b
0514+  1351             
0515+  1351 22 00         mov ah, 0
0516+  1353 26 64 00      mov b, 100
0517+  1356 AE            div a, b
0518+  1357 D8            push b      ; save remainder
0519+  1358 B9 00         cmp al, 0
0520+  135A C6 64 13      je skip100
0521+  135D 6A 30         add al, $30
0522+  135F 23            mov ah, al
0523+  1360 19 00         mov al, 0
0524+  1362 05 03         syscall sys_io  ; print coeff
0525+  1364             skip100:
0526+  1364 E4            pop a
0527+  1365 22 00         mov ah, 0
0528+  1367 26 0A 00      mov b, 10
0529+  136A AE            div a, b
0530+  136B D8            push b      ; save remainder
0531+  136C B9 00         cmp al, 0
0532+  136E C6 78 13      je skip10
0533+  1371 6A 30         add al, $30
0534+  1373 23            mov ah, al
0535+  1374 19 00         mov al, 0
0536+  1376 05 03         syscall sys_io  ; print coeff
0537+  1378             skip10:
0538+  1378 E4            pop a
0539+  1379 1B            mov al, bl
0540+  137A 6A 30         add al, $30
0541+  137C 23            mov ah, al
0542+  137D 19 00         mov al, 0
0543+  137F 05 03         syscall sys_io  ; print coeff
0544+  1381 E5            pop b
0545+  1382 E4            pop a
0546+  1383 09            ret
0547+  1384             
0548+  1384             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  1384             ; INPUT 8BIT HEX INTEGER
0550+  1384             ; read 8bit integer into AL
0551+  1384             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  1384             scan_u8x:
0553+  1384 F8 04 00      enter 4
0554+  1387 D8            push b
0555+  1388 DA            push d
0556+  1389             
0557+  1389 FA FD FF      lea d, [bp + -3]
0558+  138C 07 5E 11      call _gets        ; get number
0559+  138F             
0560+  138F 32            mov bl, [d]
0561+  1390 37            mov bh, bl
0562+  1391 33 01 00      mov bl, [d + 1]
0563+  1394 07 14 11      call _atoi        ; convert to int in AL
0564+  1397             
0565+  1397 E7            pop d
0566+  1398 E5            pop b
0567+  1399 F9            leave
0568+  139A 09            ret
0569+  139B             
0570+  139B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  139B             ; input decimal number
0572+  139B             ; result in A
0573+  139B             ; 655'\0'
0574+  139B             ; low--------high
0575+  139B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  139B             scan_u16d:
0577+  139B F8 08 00      enter 8
0578+  139E E2            push si
0579+  139F D8            push b
0580+  13A0 D9            push c
0581+  13A1 DA            push d
0582+  13A2 FA F9 FF      lea d, [bp +- 7]
0583+  13A5 07 5E 11      call _gets
0584+  13A8 07 B6 10      call _strlen      ; get string length in C
0585+  13AB 7E            dec c
0586+  13AC FD 4E         mov si, d
0587+  13AE 12            mov a, c
0588+  13AF FD 99         shl a
0589+  13B1 3B ED 13      mov d, table_power
0590+  13B4 59            add d, a
0591+  13B5 38 00 00      mov c, 0
0592+  13B8             mul_loop:
0593+  13B8 F6            lodsb      ; load ASCII to al
0594+  13B9 B9 00         cmp al, 0
0595+  13BB C6 CE 13      je mul_exit
0596+  13BE 6F 30         sub al, $30    ; make into integer
0597+  13C0 22 00         mov ah, 0
0598+  13C2 2A            mov b, [d]
0599+  13C3 AC            mul a, b      ; result in B since it fits in 16bits
0600+  13C4 11            mov a, b
0601+  13C5 28            mov b, c
0602+  13C6 54            add a, b
0603+  13C7 39            mov c, a
0604+  13C8 63 02 00      sub d, 2
0605+  13CB 0A B8 13      jmp mul_loop
0606+  13CE             mul_exit:
0607+  13CE 12            mov a, c
0608+  13CF E7            pop d
0609+  13D0 E6            pop c
0610+  13D1 E5            pop b
0611+  13D2 EF            pop si
0612+  13D3 F9            leave
0613+  13D4 09            ret
0614+  13D5             
0615+  13D5             
0616+  13D5 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  13D9 34 35 36 37 
0616+  13DD 38 39 41 42 
0616+  13E1 43 44 45 46 
0617+  13E5 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  13E9 1B 5B 48 00 
0618+  13ED             
0619+  13ED             table_power:
0620+  13ED 01 00         .dw 1
0621+  13EF 0A 00         .dw 10
0622+  13F1 64 00         .dw 100
0623+  13F3 E8 03         .dw 1000
0624+  13F5 10 27         .dw 100002341   13F7             ; --- END INLINE ASM BLOCK
2342   13F7             
2343   13F7 F9            leave
2344   13F8 09            ret
2345   13F9             
2346   13F9             quick:
2347   13F9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2348   13FC             ;; qs(items, 0, count - 1); 
2349   13FC FA 07 00      lea d, [bp + 7] ; $count
2350   13FF 2A            mov b, [d]
2351   1400             ; START TERMS
2352   1400 D7            push a
2353   1401 11            mov a, b
2354   1402 26 01 00      mov b, $1
2355   1405 60            sub a, b
2356   1406 27            mov b, a
2357   1407 E4            pop a
2358   1408             ; END TERMS
2359   1408 FD AB         swp b
2360   140A D8            push b
2361   140B 26 00 00      mov b, $0
2362   140E FD AB         swp b
2363   1410 D8            push b
2364   1411 FA 05 00      lea d, [bp + 5] ; $items
2365   1414 2A            mov b, [d]
2366   1415 FD AB         swp b
2367   1417 D8            push b
2368   1418 07 20 14      call qs
2369   141B 51 06 00      add sp, 6
2370   141E F9            leave
2371   141F 09            ret
2372   1420             
2373   1420             qs:
2374   1420 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2375   1423             ; $i 
2376   1423             ; $j 
2377   1423             ; $x 
2378   1423             ; $y 
2379   1423 52 06 00      sub sp, 6
2380   1426             ;; i = left; j = right; 
2381   1426 FA FF FF      lea d, [bp + -1] ; $i
2382   1429 DA            push d
2383   142A FA 07 00      lea d, [bp + 7] ; $left
2384   142D 2A            mov b, [d]
2385   142E E7            pop d
2386   142F FD 43         mov [d], b
2387   1431             ;; j = right; 
2388   1431 FA FD FF      lea d, [bp + -3] ; $j
2389   1434 DA            push d
2390   1435 FA 09 00      lea d, [bp + 9] ; $right
2391   1438 2A            mov b, [d]
2392   1439 E7            pop d
2393   143A FD 43         mov [d], b
2394   143C             ;; x = *(items + ( (left + right) / 2) ); 
2395   143C FA FC FF      lea d, [bp + -4] ; $x
2396   143F DA            push d
2397   1440 FA 05 00      lea d, [bp + 5] ; $items
2398   1443 2A            mov b, [d]
2399   1444             ; START TERMS
2400   1444 D7            push a
2401   1445 11            mov a, b
2402   1446 FA 07 00      lea d, [bp + 7] ; $left
2403   1449 2A            mov b, [d]
2404   144A             ; START TERMS
2405   144A D7            push a
2406   144B 11            mov a, b
2407   144C FA 09 00      lea d, [bp + 9] ; $right
2408   144F 2A            mov b, [d]
2409   1450 54            add a, b
2410   1451 27            mov b, a
2411   1452 E4            pop a
2412   1453             ; END TERMS
2413   1453             ; START FACTORS
2414   1453 D7            push a
2415   1454 11            mov a, b
2416   1455 26 02 00      mov b, $2
2417   1458 AE            div a, b
2418   1459 27            mov b, a
2419   145A E4            pop a
2420   145B             ; END FACTORS
2421   145B 54            add a, b
2422   145C 27            mov b, a
2423   145D E4            pop a
2424   145E             ; END TERMS
2425   145E 74            mov d, b
2426   145F 32            mov bl, [d]
2427   1460 A7 00         mov bh, 0
2428   1462 E7            pop d
2429   1463 FD 3E         mov [d], bl
2430   1465             ;; do{ 
2431   1465             _do33_block:
2432   1465             ;; while ( ( *(items + i) < x ) && ( i < right ) ) i++; 
2433   1465             _while34_cond:
2434   1465 FA 05 00      lea d, [bp + 5] ; $items
2435   1468 2A            mov b, [d]
2436   1469             ; START TERMS
2437   1469 D7            push a
2438   146A 11            mov a, b
2439   146B FA FF FF      lea d, [bp + -1] ; $i
2440   146E 2A            mov b, [d]
2441   146F 54            add a, b
2442   1470 27            mov b, a
2443   1471 E4            pop a
2444   1472             ; END TERMS
2445   1472 74            mov d, b
2446   1473 32            mov bl, [d]
2447   1474 A7 00         mov bh, 0
2448   1476             ; START RELATIONAL
2449   1476 D7            push a
2450   1477 11            mov a, b
2451   1478 FA FC FF      lea d, [bp + -4] ; $x
2452   147B 32            mov bl, [d]
2453   147C A7 00         mov bh, 0
2454   147E B0            cmp a, b
2455   147F FD 75         slu ; < (unsigned)
2456   1481 E4            pop a
2457   1482             ; END RELATIONAL
2458   1482 D7            push a
2459   1483 11            mov a, b
2460   1484 FA FF FF      lea d, [bp + -1] ; $i
2461   1487 2A            mov b, [d]
2462   1488             ; START RELATIONAL
2463   1488 D7            push a
2464   1489 11            mov a, b
2465   148A FA 09 00      lea d, [bp + 9] ; $right
2466   148D 2A            mov b, [d]
2467   148E B0            cmp a, b
2468   148F FD 73         slt ; < 
2469   1491 E4            pop a
2470   1492             ; END RELATIONAL
2471   1492 FD A7         sand a, b ; &&
2472   1494 E4            pop a
2473   1495 C0 00 00      cmp b, 0
2474   1498 C6 AB 14      je _while34_exit
2475   149B             _while34_block:
2476   149B             ;; i++; 
2477   149B FA FF FF      lea d, [bp + -1] ; $i
2478   149E 2A            mov b, [d]
2479   149F D8            push b
2480   14A0 FD 77         inc b
2481   14A2 FA FF FF      lea d, [bp + -1] ; $i
2482   14A5 FD 43         mov [d], b
2483   14A7 E5            pop b
2484   14A8 0A 65 14      jmp _while34_cond
2485   14AB             _while34_exit:
2486   14AB             ;; while((x < *(items+j)) && (j > left)) j--; 
2487   14AB             _while35_cond:
2488   14AB FA FC FF      lea d, [bp + -4] ; $x
2489   14AE 32            mov bl, [d]
2490   14AF A7 00         mov bh, 0
2491   14B1             ; START RELATIONAL
2492   14B1 D7            push a
2493   14B2 11            mov a, b
2494   14B3 FA 05 00      lea d, [bp + 5] ; $items
2495   14B6 2A            mov b, [d]
2496   14B7             ; START TERMS
2497   14B7 D7            push a
2498   14B8 11            mov a, b
2499   14B9 FA FD FF      lea d, [bp + -3] ; $j
2500   14BC 2A            mov b, [d]
2501   14BD 54            add a, b
2502   14BE 27            mov b, a
2503   14BF E4            pop a
2504   14C0             ; END TERMS
2505   14C0 74            mov d, b
2506   14C1 32            mov bl, [d]
2507   14C2 A7 00         mov bh, 0
2508   14C4 B0            cmp a, b
2509   14C5 FD 75         slu ; < (unsigned)
2510   14C7 E4            pop a
2511   14C8             ; END RELATIONAL
2512   14C8 D7            push a
2513   14C9 11            mov a, b
2514   14CA FA FD FF      lea d, [bp + -3] ; $j
2515   14CD 2A            mov b, [d]
2516   14CE             ; START RELATIONAL
2517   14CE D7            push a
2518   14CF 11            mov a, b
2519   14D0 FA 07 00      lea d, [bp + 7] ; $left
2520   14D3 2A            mov b, [d]
2521   14D4 B0            cmp a, b
2522   14D5 FD 7F         sgt ; >
2523   14D7 E4            pop a
2524   14D8             ; END RELATIONAL
2525   14D8 FD A7         sand a, b ; &&
2526   14DA E4            pop a
2527   14DB C0 00 00      cmp b, 0
2528   14DE C6 F1 14      je _while35_exit
2529   14E1             _while35_block:
2530   14E1             ;; j--; 
2531   14E1 FA FD FF      lea d, [bp + -3] ; $j
2532   14E4 2A            mov b, [d]
2533   14E5 D8            push b
2534   14E6 FD 7D         dec b
2535   14E8 FA FD FF      lea d, [bp + -3] ; $j
2536   14EB FD 43         mov [d], b
2537   14ED E5            pop b
2538   14EE 0A AB 14      jmp _while35_cond
2539   14F1             _while35_exit:
2540   14F1             ;; if(i <= j){ 
2541   14F1             _if36_cond:
2542   14F1 FA FF FF      lea d, [bp + -1] ; $i
2543   14F4 2A            mov b, [d]
2544   14F5             ; START RELATIONAL
2545   14F5 D7            push a
2546   14F6 11            mov a, b
2547   14F7 FA FD FF      lea d, [bp + -3] ; $j
2548   14FA 2A            mov b, [d]
2549   14FB B0            cmp a, b
2550   14FC FD 74         sle ; <=
2551   14FE E4            pop a
2552   14FF             ; END RELATIONAL
2553   14FF C0 00 00      cmp b, 0
2554   1502 C6 73 15      je _if36_exit
2555   1505             _if36_true:
2556   1505             ;; y = *(items+i); 
2557   1505 FA FB FF      lea d, [bp + -5] ; $y
2558   1508 DA            push d
2559   1509 FA 05 00      lea d, [bp + 5] ; $items
2560   150C 2A            mov b, [d]
2561   150D             ; START TERMS
2562   150D D7            push a
2563   150E 11            mov a, b
2564   150F FA FF FF      lea d, [bp + -1] ; $i
2565   1512 2A            mov b, [d]
2566   1513 54            add a, b
2567   1514 27            mov b, a
2568   1515 E4            pop a
2569   1516             ; END TERMS
2570   1516 74            mov d, b
2571   1517 32            mov bl, [d]
2572   1518 A7 00         mov bh, 0
2573   151A E7            pop d
2574   151B FD 3E         mov [d], bl
2575   151D             ;; *(items+i) = *(items+j); 
2576   151D FA 05 00      lea d, [bp + 5] ; $items
2577   1520 2A            mov b, [d]
2578   1521             ; START TERMS
2579   1521 D7            push a
2580   1522 11            mov a, b
2581   1523 FA FF FF      lea d, [bp + -1] ; $i
2582   1526 2A            mov b, [d]
2583   1527 54            add a, b
2584   1528 27            mov b, a
2585   1529 E4            pop a
2586   152A             ; END TERMS
2587   152A D8            push b
2588   152B FA 05 00      lea d, [bp + 5] ; $items
2589   152E 2A            mov b, [d]
2590   152F             ; START TERMS
2591   152F D7            push a
2592   1530 11            mov a, b
2593   1531 FA FD FF      lea d, [bp + -3] ; $j
2594   1534 2A            mov b, [d]
2595   1535 54            add a, b
2596   1536 27            mov b, a
2597   1537 E4            pop a
2598   1538             ; END TERMS
2599   1538 74            mov d, b
2600   1539 32            mov bl, [d]
2601   153A A7 00         mov bh, 0
2602   153C E7            pop d
2603   153D FD 3E         mov [d], bl
2604   153F             ;; *(items+j) = y; 
2605   153F FA 05 00      lea d, [bp + 5] ; $items
2606   1542 2A            mov b, [d]
2607   1543             ; START TERMS
2608   1543 D7            push a
2609   1544 11            mov a, b
2610   1545 FA FD FF      lea d, [bp + -3] ; $j
2611   1548 2A            mov b, [d]
2612   1549 54            add a, b
2613   154A 27            mov b, a
2614   154B E4            pop a
2615   154C             ; END TERMS
2616   154C D8            push b
2617   154D FA FB FF      lea d, [bp + -5] ; $y
2618   1550 32            mov bl, [d]
2619   1551 A7 00         mov bh, 0
2620   1553 E7            pop d
2621   1554 FD 3E         mov [d], bl
2622   1556             ;; i++; j--; 
2623   1556 FA FF FF      lea d, [bp + -1] ; $i
2624   1559 2A            mov b, [d]
2625   155A D8            push b
2626   155B FD 77         inc b
2627   155D FA FF FF      lea d, [bp + -1] ; $i
2628   1560 FD 43         mov [d], b
2629   1562 E5            pop b
2630   1563             ;; j--; 
2631   1563 FA FD FF      lea d, [bp + -3] ; $j
2632   1566 2A            mov b, [d]
2633   1567 D8            push b
2634   1568 FD 7D         dec b
2635   156A FA FD FF      lea d, [bp + -3] ; $j
2636   156D FD 43         mov [d], b
2637   156F E5            pop b
2638   1570 0A 73 15      jmp _if36_exit
2639   1573             _if36_exit:
2640   1573             ;; } while(i <= j); 
2641   1573             _do33_cond:
2642   1573 FA FF FF      lea d, [bp + -1] ; $i
2643   1576 2A            mov b, [d]
2644   1577             ; START RELATIONAL
2645   1577 D7            push a
2646   1578 11            mov a, b
2647   1579 FA FD FF      lea d, [bp + -3] ; $j
2648   157C 2A            mov b, [d]
2649   157D B0            cmp a, b
2650   157E FD 74         sle ; <=
2651   1580 E4            pop a
2652   1581             ; END RELATIONAL
2653   1581 C0 01 00      cmp b, 1
2654   1584 C6 65 14      je _do33_block
2655   1587             _do33_exit:
2656   1587             ;; if(left < j) qs(items, left, j); 
2657   1587             _if37_cond:
2658   1587 FA 07 00      lea d, [bp + 7] ; $left
2659   158A 2A            mov b, [d]
2660   158B             ; START RELATIONAL
2661   158B D7            push a
2662   158C 11            mov a, b
2663   158D FA FD FF      lea d, [bp + -3] ; $j
2664   1590 2A            mov b, [d]
2665   1591 B0            cmp a, b
2666   1592 FD 73         slt ; < 
2667   1594 E4            pop a
2668   1595             ; END RELATIONAL
2669   1595 C0 00 00      cmp b, 0
2670   1598 C6 B9 15      je _if37_exit
2671   159B             _if37_true:
2672   159B             ;; qs(items, left, j); 
2673   159B FA FD FF      lea d, [bp + -3] ; $j
2674   159E 2A            mov b, [d]
2675   159F FD AB         swp b
2676   15A1 D8            push b
2677   15A2 FA 07 00      lea d, [bp + 7] ; $left
2678   15A5 2A            mov b, [d]
2679   15A6 FD AB         swp b
2680   15A8 D8            push b
2681   15A9 FA 05 00      lea d, [bp + 5] ; $items
2682   15AC 2A            mov b, [d]
2683   15AD FD AB         swp b
2684   15AF D8            push b
2685   15B0 07 20 14      call qs
2686   15B3 51 06 00      add sp, 6
2687   15B6 0A B9 15      jmp _if37_exit
2688   15B9             _if37_exit:
2689   15B9             ;; if(i < right) qs(items, i, right); 
2690   15B9             _if38_cond:
2691   15B9 FA FF FF      lea d, [bp + -1] ; $i
2692   15BC 2A            mov b, [d]
2693   15BD             ; START RELATIONAL
2694   15BD D7            push a
2695   15BE 11            mov a, b
2696   15BF FA 09 00      lea d, [bp + 9] ; $right
2697   15C2 2A            mov b, [d]
2698   15C3 B0            cmp a, b
2699   15C4 FD 73         slt ; < 
2700   15C6 E4            pop a
2701   15C7             ; END RELATIONAL
2702   15C7 C0 00 00      cmp b, 0
2703   15CA C6 EB 15      je _if38_exit
2704   15CD             _if38_true:
2705   15CD             ;; qs(items, i, right); 
2706   15CD FA 09 00      lea d, [bp + 9] ; $right
2707   15D0 2A            mov b, [d]
2708   15D1 FD AB         swp b
2709   15D3 D8            push b
2710   15D4 FA FF FF      lea d, [bp + -1] ; $i
2711   15D7 2A            mov b, [d]
2712   15D8 FD AB         swp b
2713   15DA D8            push b
2714   15DB FA 05 00      lea d, [bp + 5] ; $items
2715   15DE 2A            mov b, [d]
2716   15DF FD AB         swp b
2717   15E1 D8            push b
2718   15E2 07 20 14      call qs
2719   15E5 51 06 00      add sp, 6
2720   15E8 0A EB 15      jmp _if38_exit
2721   15EB             _if38_exit:
2722   15EB F9            leave
2723   15EC 09            ret
2724   15ED             ; --- END TEXT BLOCK
2725   15ED             
2726   15ED             ; --- BEGIN DATA BLOCK
2727   15ED 00 00 00 00 _mystring_data: .fill 256, 0
2727   15F1 00 00 00 00 
2727   15F5 00 00 00 00 
2727   15F9 00 00 00 00 
2727   15FD 00 00 00 00 
2727   1601 00 00 00 00 
2727   1605 00 00 00 00 
2727   1609 00 00 00 00 
2727   160D 00 00 00 00 
2727   1611 00 00 00 00 
2727   1615 00 00 00 00 
2727   1619 00 00 00 00 
2727   161D 00 00 00 00 
2727   1621 00 00 00 00 
2727   1625 00 00 00 00 
2727   1629 00 00 00 00 
2727   162D 00 00 00 00 
2727   1631 00 00 00 00 
2727   1635 00 00 00 00 
2727   1639 00 00 00 00 
2727   163D 00 00 00 00 
2727   1641 00 00 00 00 
2727   1645 00 00 00 00 
2727   1649 00 00 00 00 
2727   164D 00 00 00 00 
2727   1651 00 00 00 00 
2727   1655 00 00 00 00 
2727   1659 00 00 00 00 
2727   165D 00 00 00 00 
2727   1661 00 00 00 00 
2727   1665 00 00 00 00 
2727   1669 00 00 00 00 
2727   166D 00 00 00 00 
2727   1671 00 00 00 00 
2727   1675 00 00 00 00 
2727   1679 00 00 00 00 
2727   167D 00 00 00 00 
2727   1681 00 00 00 00 
2727   1685 00 00 00 00 
2727   1689 00 00 00 00 
2727   168D 00 00 00 00 
2727   1691 00 00 00 00 
2727   1695 00 00 00 00 
2727   1699 00 00 00 00 
2727   169D 00 00 00 00 
2727   16A1 00 00 00 00 
2727   16A5 00 00 00 00 
2727   16A9 00 00 00 00 
2727   16AD 00 00 00 00 
2727   16B1 00 00 00 00 
2727   16B5 00 00 00 00 
2727   16B9 00 00 00 00 
2727   16BD 00 00 00 00 
2727   16C1 00 00 00 00 
2727   16C5 00 00 00 00 
2727   16C9 00 00 00 00 
2727   16CD 00 00 00 00 
2727   16D1 00 00 00 00 
2727   16D5 00 00 00 00 
2727   16D9 00 00 00 00 
2727   16DD 00 00 00 00 
2727   16E1 00 00 00 00 
2727   16E5 00 00 00 00 
2727   16E9 00 00 00 00 
2728   16ED 45 6E 74 65 __s0: .db "Enter a string(256 max): ", 0
2728   16F1 72 20 61 20 
2728   16F5 73 74 72 69 
2728   16F9 6E 67 28 32 
2728   16FD 35 36 20 6D 
2728   1701 61 78 29 3A 
2728   1705 20 00 
2729   1707 0A 00       __s1: .db "\n", 0
2730   1709 53 6F 72 74 __s2: .db "Sorted string: ", 0
2730   170D 65 64 20 73 
2730   1711 74 72 69 6E 
2730   1715 67 3A 20 00 
2731   1719 55 6E 65 78 __s3: .db "Unexpected format in printf.", 0
2731   171D 70 65 63 74 
2731   1721 65 64 20 66 
2731   1725 6F 72 6D 61 
2731   1729 74 20 69 6E 
2731   172D 20 70 72 69 
2731   1731 6E 74 66 2E 
2731   1735 00 
2732   1736 45 72 72 6F __s4: .db "Error: Unknown argument type.\n", 0
2732   173A 72 3A 20 55 
2732   173E 6E 6B 6E 6F 
2732   1742 77 6E 20 61 
2732   1746 72 67 75 6D 
2732   174A 65 6E 74 20 
2732   174E 74 79 70 65 
2732   1752 2E 0A 00 
2733   1755 1B 5B 32 4A __s5: .db "\033[2J\033[H", 0
2733   1759 1B 5B 48 00 
2734   175D             
2735   175D 5F 17       _heap_top: .dw _heap
2736   175F 00          _heap: .db 0
2737   1760             ; --- END DATA BLOCK
2738   1760             
2739   1760             .end
tasm: Number of errors = 0
