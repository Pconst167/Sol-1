0001   0000             ; --- FILENAME: programs/primes
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; unsigned int N, i; 
0011   0408 52 02 00      sub sp, 2 ; N
0012   040B 52 02 00      sub sp, 2 ; i
0013   040E             ;; printf("Enter a number to find all prime numbers up to it: "); 
0014   040E 26 5B 1C      mov b, _s0 ; "Enter a number to find all prime numbers up to it: "
0015   0411 FD AB         swp b
0016   0413 D8            push b
0017   0414 07 33 08      call printf
0018   0417 51 02 00      add sp, 2
0019   041A             ;; N = scann(); 
0020   041A FA FF FF      lea d, [bp + -1] ; $N
0021   041D DA            push d
0022   041E 07 B0 15      call scann
0023   0421 E7            pop d
0024   0422 FD 43         mov [d], b
0025   0424             ;; printf("Prime numbers are: \n"); 
0026   0424 26 8F 1C      mov b, _s1 ; "Prime numbers are: \n"
0027   0427 FD AB         swp b
0028   0429 D8            push b
0029   042A 07 33 08      call printf
0030   042D 51 02 00      add sp, 2
0031   0430             ;; for (i = 2; i <= N; i++) { 
0032   0430             _for1_init:
0033   0430 FA FD FF      lea d, [bp + -3] ; $i
0034   0433 DA            push d
0035   0434 26 02 00      mov b, $2
0036   0437 E7            pop d
0037   0438 FD 43         mov [d], b
0038   043A             _for1_cond:
0039   043A FA FD FF      lea d, [bp + -3] ; $i
0040   043D 2A            mov b, [d]
0041   043E             ; START RELATIONAL
0042   043E D7            push a
0043   043F 11            mov a, b
0044   0440 FA FF FF      lea d, [bp + -1] ; $N
0045   0443 2A            mov b, [d]
0046   0444 B0            cmp a, b
0047   0445 FD 76         sleu ; <= (unsigned)
0048   0447 E4            pop a
0049   0448             ; END RELATIONAL
0050   0448 C0 00 00      cmp b, 0
0051   044B C6 87 04      je _for1_exit
0052   044E             _for1_block:
0053   044E             ;; if (isPrime(i)) { 
0054   044E             _if2_cond:
0055   044E FA FD FF      lea d, [bp + -3] ; $i
0056   0451 2A            mov b, [d]
0057   0452 FD AB         swp b
0058   0454 D8            push b
0059   0455 07 D6 1B      call isPrime
0060   0458 51 02 00      add sp, 2
0061   045B C0 00 00      cmp b, 0
0062   045E C6 77 04      je _if2_exit
0063   0461             _if2_true:
0064   0461             ;; printf("%d\n", i); 
0065   0461 FA FD FF      lea d, [bp + -3] ; $i
0066   0464 2A            mov b, [d]
0067   0465 FD AB         swp b
0068   0467 D8            push b
0069   0468 26 A4 1C      mov b, _s2 ; "%d\n"
0070   046B FD AB         swp b
0071   046D D8            push b
0072   046E 07 33 08      call printf
0073   0471 51 04 00      add sp, 4
0074   0474 0A 77 04      jmp _if2_exit
0075   0477             _if2_exit:
0076   0477             _for1_update:
0077   0477 FA FD FF      lea d, [bp + -3] ; $i
0078   047A 2A            mov b, [d]
0079   047B FD 77         inc b
0080   047D FA FD FF      lea d, [bp + -3] ; $i
0081   0480 FD 43         mov [d], b
0082   0482 FD 7D         dec b
0083   0484 0A 3A 04      jmp _for1_cond
0084   0487             _for1_exit:
0085   0487             ;; return 0; 
0086   0487 26 00 00      mov b, $0
0087   048A F9            leave
0088   048B 05 0B         syscall sys_terminate_proc
0089   048D             
0090   048D             strcpy:
0091   048D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0092   0490             ;; char *psrc; 
0093   0490 52 02 00      sub sp, 2 ; psrc
0094   0493             ;; char *pdest; 
0095   0493 52 02 00      sub sp, 2 ; pdest
0096   0496             ;; psrc = src; 
0097   0496 FA FF FF      lea d, [bp + -1] ; $psrc
0098   0499 DA            push d
0099   049A FA 07 00      lea d, [bp + 7] ; $src
0100   049D 2A            mov b, [d]
0101   049E E7            pop d
0102   049F FD 43         mov [d], b
0103   04A1             ;; pdest = dest; 
0104   04A1 FA FD FF      lea d, [bp + -3] ; $pdest
0105   04A4 DA            push d
0106   04A5 FA 05 00      lea d, [bp + 5] ; $dest
0107   04A8 2A            mov b, [d]
0108   04A9 E7            pop d
0109   04AA FD 43         mov [d], b
0110   04AC             ;; while(*psrc) *pdest++ = *psrc++; 
0111   04AC             _while3_cond:
0112   04AC FA FF FF      lea d, [bp + -1] ; $psrc
0113   04AF 2A            mov b, [d]
0114   04B0 74            mov d, b
0115   04B1 32            mov bl, [d]
0116   04B2 A7 00         mov bh, 0
0117   04B4 C0 00 00      cmp b, 0
0118   04B7 C6 DF 04      je _while3_exit
0119   04BA             _while3_block:
0120   04BA             ;; *pdest++ = *psrc++; 
0121   04BA FA FD FF      lea d, [bp + -3] ; $pdest
0122   04BD 2A            mov b, [d]
0123   04BE FD 77         inc b
0124   04C0 FA FD FF      lea d, [bp + -3] ; $pdest
0125   04C3 FD 43         mov [d], b
0126   04C5 FD 7D         dec b
0127   04C7 D8            push b
0128   04C8 FA FF FF      lea d, [bp + -1] ; $psrc
0129   04CB 2A            mov b, [d]
0130   04CC FD 77         inc b
0131   04CE FA FF FF      lea d, [bp + -1] ; $psrc
0132   04D1 FD 43         mov [d], b
0133   04D3 FD 7D         dec b
0134   04D5 74            mov d, b
0135   04D6 32            mov bl, [d]
0136   04D7 A7 00         mov bh, 0
0137   04D9 E7            pop d
0138   04DA FD 3E         mov [d], bl
0139   04DC 0A AC 04      jmp _while3_cond
0140   04DF             _while3_exit:
0141   04DF             ;; *pdest = '\0'; 
0142   04DF FA FD FF      lea d, [bp + -3] ; $pdest
0143   04E2 2A            mov b, [d]
0144   04E3 D8            push b
0145   04E4 26 00 00      mov b, $0
0146   04E7 E7            pop d
0147   04E8 FD 3E         mov [d], bl
0148   04EA F9            leave
0149   04EB 09            ret
0150   04EC             
0151   04EC             strcmp:
0152   04EC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0153   04EF             ;; while (*s1 && (*s1 == *s2)) { 
0154   04EF             _while4_cond:
0155   04EF FA 05 00      lea d, [bp + 5] ; $s1
0156   04F2 2A            mov b, [d]
0157   04F3 74            mov d, b
0158   04F4 32            mov bl, [d]
0159   04F5 A7 00         mov bh, 0
0160   04F7             ; START LOGICAL AND
0161   04F7 D7            push a
0162   04F8 11            mov a, b
0163   04F9 FA 05 00      lea d, [bp + 5] ; $s1
0164   04FC 2A            mov b, [d]
0165   04FD 74            mov d, b
0166   04FE 32            mov bl, [d]
0167   04FF A7 00         mov bh, 0
0168   0501             ; START RELATIONAL
0169   0501 D7            push a
0170   0502 11            mov a, b
0171   0503 FA 07 00      lea d, [bp + 7] ; $s2
0172   0506 2A            mov b, [d]
0173   0507 74            mov d, b
0174   0508 32            mov bl, [d]
0175   0509 A7 00         mov bh, 0
0176   050B B0            cmp a, b
0177   050C FD 71         seq ; ==
0178   050E E4            pop a
0179   050F             ; END RELATIONAL
0180   050F FD A7         sand a, b
0181   0511 E4            pop a
0182   0512             ; END LOGICAL AND
0183   0512 C0 00 00      cmp b, 0
0184   0515 C6 35 05      je _while4_exit
0185   0518             _while4_block:
0186   0518             ;; s1++; 
0187   0518 FA 05 00      lea d, [bp + 5] ; $s1
0188   051B 2A            mov b, [d]
0189   051C FD 77         inc b
0190   051E FA 05 00      lea d, [bp + 5] ; $s1
0191   0521 FD 43         mov [d], b
0192   0523 FD 7D         dec b
0193   0525             ;; s2++; 
0194   0525 FA 07 00      lea d, [bp + 7] ; $s2
0195   0528 2A            mov b, [d]
0196   0529 FD 77         inc b
0197   052B FA 07 00      lea d, [bp + 7] ; $s2
0198   052E FD 43         mov [d], b
0199   0530 FD 7D         dec b
0200   0532 0A EF 04      jmp _while4_cond
0201   0535             _while4_exit:
0202   0535             ;; return *s1 - *s2; 
0203   0535 FA 05 00      lea d, [bp + 5] ; $s1
0204   0538 2A            mov b, [d]
0205   0539 74            mov d, b
0206   053A 32            mov bl, [d]
0207   053B A7 00         mov bh, 0
0208   053D             ; START TERMS
0209   053D D7            push a
0210   053E 11            mov a, b
0211   053F FA 07 00      lea d, [bp + 7] ; $s2
0212   0542 2A            mov b, [d]
0213   0543 74            mov d, b
0214   0544 32            mov bl, [d]
0215   0545 A7 00         mov bh, 0
0216   0547 60            sub a, b
0217   0548 27            mov b, a
0218   0549 E4            pop a
0219   054A             ; END TERMS
0220   054A F9            leave
0221   054B 09            ret
0222   054C             
0223   054C             strncmp:
0224   054C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0225   054F F9            leave
0226   0550 09            ret
0227   0551             
0228   0551             strcat:
0229   0551 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0230   0554             ;; int dest_len; 
0231   0554 52 02 00      sub sp, 2 ; dest_len
0232   0557             ;; int i; 
0233   0557 52 02 00      sub sp, 2 ; i
0234   055A             ;; dest_len = strlen(dest); 
0235   055A FA FF FF      lea d, [bp + -1] ; $dest_len
0236   055D DA            push d
0237   055E FA 05 00      lea d, [bp + 5] ; $dest
0238   0561 2A            mov b, [d]
0239   0562 FD AB         swp b
0240   0564 D8            push b
0241   0565 07 07 06      call strlen
0242   0568 51 02 00      add sp, 2
0243   056B E7            pop d
0244   056C FD 43         mov [d], b
0245   056E             ;; for (i = 0; src[i] != 0; i=i+1) { 
0246   056E             _for5_init:
0247   056E FA FD FF      lea d, [bp + -3] ; $i
0248   0571 DA            push d
0249   0572 26 00 00      mov b, $0
0250   0575 E7            pop d
0251   0576 FD 43         mov [d], b
0252   0578             _for5_cond:
0253   0578 FA 07 00      lea d, [bp + 7] ; $src
0254   057B FD 2A         mov d, [d]
0255   057D D7            push a
0256   057E DA            push d
0257   057F FA FD FF      lea d, [bp + -3] ; $i
0258   0582 2A            mov b, [d]
0259   0583 E7            pop d
0260   0584 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0261   0588 E4            pop a
0262   0589 32            mov bl, [d]
0263   058A A7 00         mov bh, 0
0264   058C             ; START RELATIONAL
0265   058C D7            push a
0266   058D 11            mov a, b
0267   058E 26 00 00      mov b, $0
0268   0591 B0            cmp a, b
0269   0592 FD 72         sneq ; !=
0270   0594 E4            pop a
0271   0595             ; END RELATIONAL
0272   0595 C0 00 00      cmp b, 0
0273   0598 C6 E1 05      je _for5_exit
0274   059B             _for5_block:
0275   059B             ;; dest[dest_len + i] = src[i]; 
0276   059B FA 05 00      lea d, [bp + 5] ; $dest
0277   059E FD 2A         mov d, [d]
0278   05A0 D7            push a
0279   05A1 DA            push d
0280   05A2 FA FF FF      lea d, [bp + -1] ; $dest_len
0281   05A5 2A            mov b, [d]
0282   05A6             ; START TERMS
0283   05A6 D7            push a
0284   05A7 11            mov a, b
0285   05A8 FA FD FF      lea d, [bp + -3] ; $i
0286   05AB 2A            mov b, [d]
0287   05AC 56            add b, a
0288   05AD E4            pop a
0289   05AE             ; END TERMS
0290   05AE E7            pop d
0291   05AF FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0292   05B3 E4            pop a
0293   05B4 DA            push d
0294   05B5 FA 07 00      lea d, [bp + 7] ; $src
0295   05B8 FD 2A         mov d, [d]
0296   05BA D7            push a
0297   05BB DA            push d
0298   05BC FA FD FF      lea d, [bp + -3] ; $i
0299   05BF 2A            mov b, [d]
0300   05C0 E7            pop d
0301   05C1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0302   05C5 E4            pop a
0303   05C6 32            mov bl, [d]
0304   05C7 A7 00         mov bh, 0
0305   05C9 E7            pop d
0306   05CA FD 3E         mov [d], bl
0307   05CC             _for5_update:
0308   05CC FA FD FF      lea d, [bp + -3] ; $i
0309   05CF DA            push d
0310   05D0 FA FD FF      lea d, [bp + -3] ; $i
0311   05D3 2A            mov b, [d]
0312   05D4             ; START TERMS
0313   05D4 D7            push a
0314   05D5 11            mov a, b
0315   05D6 26 01 00      mov b, $1
0316   05D9 56            add b, a
0317   05DA E4            pop a
0318   05DB             ; END TERMS
0319   05DB E7            pop d
0320   05DC FD 43         mov [d], b
0321   05DE 0A 78 05      jmp _for5_cond
0322   05E1             _for5_exit:
0323   05E1             ;; dest[dest_len + i] = 0; 
0324   05E1 FA 05 00      lea d, [bp + 5] ; $dest
0325   05E4 FD 2A         mov d, [d]
0326   05E6 D7            push a
0327   05E7 DA            push d
0328   05E8 FA FF FF      lea d, [bp + -1] ; $dest_len
0329   05EB 2A            mov b, [d]
0330   05EC             ; START TERMS
0331   05EC D7            push a
0332   05ED 11            mov a, b
0333   05EE FA FD FF      lea d, [bp + -3] ; $i
0334   05F1 2A            mov b, [d]
0335   05F2 56            add b, a
0336   05F3 E4            pop a
0337   05F4             ; END TERMS
0338   05F4 E7            pop d
0339   05F5 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0340   05F9 E4            pop a
0341   05FA DA            push d
0342   05FB 26 00 00      mov b, $0
0343   05FE E7            pop d
0344   05FF FD 3E         mov [d], bl
0345   0601             ;; return dest; 
0346   0601 FA 05 00      lea d, [bp + 5] ; $dest
0347   0604 2A            mov b, [d]
0348   0605 F9            leave
0349   0606 09            ret
0350   0607             
0351   0607             strlen:
0352   0607 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0353   060A             ;; int length; 
0354   060A 52 02 00      sub sp, 2 ; length
0355   060D             ;; length = 0; 
0356   060D FA FF FF      lea d, [bp + -1] ; $length
0357   0610 DA            push d
0358   0611 26 00 00      mov b, $0
0359   0614 E7            pop d
0360   0615 FD 43         mov [d], b
0361   0617             ;; while (str[length] != 0) { 
0362   0617             _while6_cond:
0363   0617 FA 05 00      lea d, [bp + 5] ; $str
0364   061A FD 2A         mov d, [d]
0365   061C D7            push a
0366   061D DA            push d
0367   061E FA FF FF      lea d, [bp + -1] ; $length
0368   0621 2A            mov b, [d]
0369   0622 E7            pop d
0370   0623 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0371   0627 E4            pop a
0372   0628 32            mov bl, [d]
0373   0629 A7 00         mov bh, 0
0374   062B             ; START RELATIONAL
0375   062B D7            push a
0376   062C 11            mov a, b
0377   062D 26 00 00      mov b, $0
0378   0630 B0            cmp a, b
0379   0631 FD 72         sneq ; !=
0380   0633 E4            pop a
0381   0634             ; END RELATIONAL
0382   0634 C0 00 00      cmp b, 0
0383   0637 C6 4A 06      je _while6_exit
0384   063A             _while6_block:
0385   063A             ;; length++; 
0386   063A FA FF FF      lea d, [bp + -1] ; $length
0387   063D 2A            mov b, [d]
0388   063E FD 77         inc b
0389   0640 FA FF FF      lea d, [bp + -1] ; $length
0390   0643 FD 43         mov [d], b
0391   0645 FD 7D         dec b
0392   0647 0A 17 06      jmp _while6_cond
0393   064A             _while6_exit:
0394   064A             ;; return length; 
0395   064A FA FF FF      lea d, [bp + -1] ; $length
0396   064D 2A            mov b, [d]
0397   064E F9            leave
0398   064F 09            ret
0399   0650             
0400   0650             exit:
0401   0650 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0402   0653             
0403   0653             ; --- BEGIN INLINE ASM BLOCK
0404   0653 05 0B         syscall sys_terminate_proc
0405   0655             ; --- END INLINE ASM BLOCK
0406   0655             
0407   0655 F9            leave
0408   0656 09            ret
0409   0657             
0410   0657             memset:
0411   0657 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0412   065A             ;; int i; 
0413   065A 52 02 00      sub sp, 2 ; i
0414   065D             ;; for(i = 0; i < size; i++){ 
0415   065D             _for7_init:
0416   065D FA FF FF      lea d, [bp + -1] ; $i
0417   0660 DA            push d
0418   0661 26 00 00      mov b, $0
0419   0664 E7            pop d
0420   0665 FD 43         mov [d], b
0421   0667             _for7_cond:
0422   0667 FA FF FF      lea d, [bp + -1] ; $i
0423   066A 2A            mov b, [d]
0424   066B             ; START RELATIONAL
0425   066B D7            push a
0426   066C 11            mov a, b
0427   066D FA 08 00      lea d, [bp + 8] ; $size
0428   0670 2A            mov b, [d]
0429   0671 B0            cmp a, b
0430   0672 FD 73         slt ; < (signed)
0431   0674 E4            pop a
0432   0675             ; END RELATIONAL
0433   0675 C0 00 00      cmp b, 0
0434   0678 C6 A1 06      je _for7_exit
0435   067B             _for7_block:
0436   067B             ;; *(s+i) = c; 
0437   067B FA 05 00      lea d, [bp + 5] ; $s
0438   067E 2A            mov b, [d]
0439   067F             ; START TERMS
0440   067F D7            push a
0441   0680 11            mov a, b
0442   0681 FA FF FF      lea d, [bp + -1] ; $i
0443   0684 2A            mov b, [d]
0444   0685 56            add b, a
0445   0686 E4            pop a
0446   0687             ; END TERMS
0447   0687 D8            push b
0448   0688 FA 07 00      lea d, [bp + 7] ; $c
0449   068B 32            mov bl, [d]
0450   068C A7 00         mov bh, 0
0451   068E E7            pop d
0452   068F FD 3E         mov [d], bl
0453   0691             _for7_update:
0454   0691 FA FF FF      lea d, [bp + -1] ; $i
0455   0694 2A            mov b, [d]
0456   0695 FD 77         inc b
0457   0697 FA FF FF      lea d, [bp + -1] ; $i
0458   069A FD 43         mov [d], b
0459   069C FD 7D         dec b
0460   069E 0A 67 06      jmp _for7_cond
0461   06A1             _for7_exit:
0462   06A1             ;; return s; 
0463   06A1 FA 05 00      lea d, [bp + 5] ; $s
0464   06A4 2A            mov b, [d]
0465   06A5 F9            leave
0466   06A6 09            ret
0467   06A7             
0468   06A7             atoi:
0469   06A7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0470   06AA             ;; int result = 0;  // Initialize result 
0471   06AA 52 02 00      sub sp, 2 ; result
0472   06AD             ; --- START LOCAL VAR INITIALIZATION
0473   06AD FA FF FF      lea d, [bp + -1] ; $result
0474   06B0 DA            push d
0475   06B1 26 00 00      mov b, $0
0476   06B4 E7            pop d
0477   06B5 FD 43         mov [d], b
0478   06B7             ; --- END LOCAL VAR INITIALIZATION
0479   06B7             ;; int sign = 1;    // Initialize sign as positive 
0480   06B7 52 02 00      sub sp, 2 ; sign
0481   06BA             ; --- START LOCAL VAR INITIALIZATION
0482   06BA FA FD FF      lea d, [bp + -3] ; $sign
0483   06BD DA            push d
0484   06BE 26 01 00      mov b, $1
0485   06C1 E7            pop d
0486   06C2 FD 43         mov [d], b
0487   06C4             ; --- END LOCAL VAR INITIALIZATION
0488   06C4             ;; while (*str == ' ') str++; 
0489   06C4             _while8_cond:
0490   06C4 FA 05 00      lea d, [bp + 5] ; $str
0491   06C7 2A            mov b, [d]
0492   06C8 74            mov d, b
0493   06C9 32            mov bl, [d]
0494   06CA A7 00         mov bh, 0
0495   06CC             ; START RELATIONAL
0496   06CC D7            push a
0497   06CD 11            mov a, b
0498   06CE 26 20 00      mov b, $20
0499   06D1 B0            cmp a, b
0500   06D2 FD 71         seq ; ==
0501   06D4 E4            pop a
0502   06D5             ; END RELATIONAL
0503   06D5 C0 00 00      cmp b, 0
0504   06D8 C6 EB 06      je _while8_exit
0505   06DB             _while8_block:
0506   06DB             ;; str++; 
0507   06DB FA 05 00      lea d, [bp + 5] ; $str
0508   06DE 2A            mov b, [d]
0509   06DF FD 77         inc b
0510   06E1 FA 05 00      lea d, [bp + 5] ; $str
0511   06E4 FD 43         mov [d], b
0512   06E6 FD 7D         dec b
0513   06E8 0A C4 06      jmp _while8_cond
0514   06EB             _while8_exit:
0515   06EB             ;; if (*str == '-' || *str == '+') { 
0516   06EB             _if9_cond:
0517   06EB FA 05 00      lea d, [bp + 5] ; $str
0518   06EE 2A            mov b, [d]
0519   06EF 74            mov d, b
0520   06F0 32            mov bl, [d]
0521   06F1 A7 00         mov bh, 0
0522   06F3             ; START RELATIONAL
0523   06F3 D7            push a
0524   06F4 11            mov a, b
0525   06F5 26 2D 00      mov b, $2d
0526   06F8 B0            cmp a, b
0527   06F9 FD 71         seq ; ==
0528   06FB E4            pop a
0529   06FC             ; END RELATIONAL
0530   06FC             ; START LOGICAL OR
0531   06FC D7            push a
0532   06FD 11            mov a, b
0533   06FE FA 05 00      lea d, [bp + 5] ; $str
0534   0701 2A            mov b, [d]
0535   0702 74            mov d, b
0536   0703 32            mov bl, [d]
0537   0704 A7 00         mov bh, 0
0538   0706             ; START RELATIONAL
0539   0706 D7            push a
0540   0707 11            mov a, b
0541   0708 26 2B 00      mov b, $2b
0542   070B B0            cmp a, b
0543   070C FD 71         seq ; ==
0544   070E E4            pop a
0545   070F             ; END RELATIONAL
0546   070F FD A8         sor a, b ; ||
0547   0711 E4            pop a
0548   0712             ; END LOGICAL OR
0549   0712 C0 00 00      cmp b, 0
0550   0715 C6 4E 07      je _if9_exit
0551   0718             _if9_true:
0552   0718             ;; if (*str == '-') sign = -1; 
0553   0718             _if10_cond:
0554   0718 FA 05 00      lea d, [bp + 5] ; $str
0555   071B 2A            mov b, [d]
0556   071C 74            mov d, b
0557   071D 32            mov bl, [d]
0558   071E A7 00         mov bh, 0
0559   0720             ; START RELATIONAL
0560   0720 D7            push a
0561   0721 11            mov a, b
0562   0722 26 2D 00      mov b, $2d
0563   0725 B0            cmp a, b
0564   0726 FD 71         seq ; ==
0565   0728 E4            pop a
0566   0729             ; END RELATIONAL
0567   0729 C0 00 00      cmp b, 0
0568   072C C6 3E 07      je _if10_exit
0569   072F             _if10_true:
0570   072F             ;; sign = -1; 
0571   072F FA FD FF      lea d, [bp + -3] ; $sign
0572   0732 DA            push d
0573   0733 26 01 00      mov b, $1
0574   0736 FD 97         neg b
0575   0738 E7            pop d
0576   0739 FD 43         mov [d], b
0577   073B 0A 3E 07      jmp _if10_exit
0578   073E             _if10_exit:
0579   073E             ;; str++; 
0580   073E FA 05 00      lea d, [bp + 5] ; $str
0581   0741 2A            mov b, [d]
0582   0742 FD 77         inc b
0583   0744 FA 05 00      lea d, [bp + 5] ; $str
0584   0747 FD 43         mov [d], b
0585   0749 FD 7D         dec b
0586   074B 0A 4E 07      jmp _if9_exit
0587   074E             _if9_exit:
0588   074E             ;; while (*str >= '0' && *str <= '9') { 
0589   074E             _while11_cond:
0590   074E FA 05 00      lea d, [bp + 5] ; $str
0591   0751 2A            mov b, [d]
0592   0752 74            mov d, b
0593   0753 32            mov bl, [d]
0594   0754 A7 00         mov bh, 0
0595   0756             ; START RELATIONAL
0596   0756 D7            push a
0597   0757 11            mov a, b
0598   0758 26 30 00      mov b, $30
0599   075B B0            cmp a, b
0600   075C FD 82         sgeu ; >= (unsigned)
0601   075E E4            pop a
0602   075F             ; END RELATIONAL
0603   075F             ; START LOGICAL AND
0604   075F D7            push a
0605   0760 11            mov a, b
0606   0761 FA 05 00      lea d, [bp + 5] ; $str
0607   0764 2A            mov b, [d]
0608   0765 74            mov d, b
0609   0766 32            mov bl, [d]
0610   0767 A7 00         mov bh, 0
0611   0769             ; START RELATIONAL
0612   0769 D7            push a
0613   076A 11            mov a, b
0614   076B 26 39 00      mov b, $39
0615   076E B0            cmp a, b
0616   076F FD 76         sleu ; <= (unsigned)
0617   0771 E4            pop a
0618   0772             ; END RELATIONAL
0619   0772 FD A7         sand a, b
0620   0774 E4            pop a
0621   0775             ; END LOGICAL AND
0622   0775 C0 00 00      cmp b, 0
0623   0778 C6 B3 07      je _while11_exit
0624   077B             _while11_block:
0625   077B             ;; result = result * 10 + (*str - '0'); 
0626   077B FA FF FF      lea d, [bp + -1] ; $result
0627   077E DA            push d
0628   077F FA FF FF      lea d, [bp + -1] ; $result
0629   0782 2A            mov b, [d]
0630   0783             ; START FACTORS
0631   0783 D7            push a
0632   0784 11            mov a, b
0633   0785 26 0A 00      mov b, $a
0634   0788 AC            mul a, b ; *
0635   0789 11            mov a, b
0636   078A 27            mov b, a
0637   078B E4            pop a
0638   078C             ; END FACTORS
0639   078C             ; START TERMS
0640   078C D7            push a
0641   078D 11            mov a, b
0642   078E FA 05 00      lea d, [bp + 5] ; $str
0643   0791 2A            mov b, [d]
0644   0792 74            mov d, b
0645   0793 32            mov bl, [d]
0646   0794 A7 00         mov bh, 0
0647   0796             ; START TERMS
0648   0796 D7            push a
0649   0797 11            mov a, b
0650   0798 26 30 00      mov b, $30
0651   079B 60            sub a, b
0652   079C 27            mov b, a
0653   079D E4            pop a
0654   079E             ; END TERMS
0655   079E 56            add b, a
0656   079F E4            pop a
0657   07A0             ; END TERMS
0658   07A0 E7            pop d
0659   07A1 FD 43         mov [d], b
0660   07A3             ;; str++; 
0661   07A3 FA 05 00      lea d, [bp + 5] ; $str
0662   07A6 2A            mov b, [d]
0663   07A7 FD 77         inc b
0664   07A9 FA 05 00      lea d, [bp + 5] ; $str
0665   07AC FD 43         mov [d], b
0666   07AE FD 7D         dec b
0667   07B0 0A 4E 07      jmp _while11_cond
0668   07B3             _while11_exit:
0669   07B3             ;; return sign * result; 
0670   07B3 FA FD FF      lea d, [bp + -3] ; $sign
0671   07B6 2A            mov b, [d]
0672   07B7             ; START FACTORS
0673   07B7 D7            push a
0674   07B8 11            mov a, b
0675   07B9 FA FF FF      lea d, [bp + -1] ; $result
0676   07BC 2A            mov b, [d]
0677   07BD AC            mul a, b ; *
0678   07BE 11            mov a, b
0679   07BF 27            mov b, a
0680   07C0 E4            pop a
0681   07C1             ; END FACTORS
0682   07C1 F9            leave
0683   07C2 09            ret
0684   07C3             
0685   07C3             rand:
0686   07C3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0687   07C6             ;; int  sec; 
0688   07C6 52 02 00      sub sp, 2 ; sec
0689   07C9             
0690   07C9             ; --- BEGIN INLINE ASM BLOCK
0691   07C9 19 00         mov al, 0
0692   07CB 05 01         syscall sys_rtc					
0693   07CD 1A            mov al, ah
0694   07CE FA FF FF      lea d, [bp + -1] ; $sec
0695   07D1 1E            mov al, [d]
0696   07D2 22 00         mov ah, 0
0697   07D4             ; --- END INLINE ASM BLOCK
0698   07D4             
0699   07D4             ;; return sec; 
0700   07D4 FA FF FF      lea d, [bp + -1] ; $sec
0701   07D7 2A            mov b, [d]
0702   07D8 F9            leave
0703   07D9 09            ret
0704   07DA             
0705   07DA             alloc:
0706   07DA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0707   07DD             ;; heap_top = heap_top + bytes; 
0708   07DD 3B EC 1C      mov d, _heap_top ; $heap_top
0709   07E0 DA            push d
0710   07E1 3B EC 1C      mov d, _heap_top ; $heap_top
0711   07E4 2A            mov b, [d]
0712   07E5             ; START TERMS
0713   07E5 D7            push a
0714   07E6 11            mov a, b
0715   07E7 FA 05 00      lea d, [bp + 5] ; $bytes
0716   07EA 2A            mov b, [d]
0717   07EB 56            add b, a
0718   07EC E4            pop a
0719   07ED             ; END TERMS
0720   07ED E7            pop d
0721   07EE FD 43         mov [d], b
0722   07F0             ;; return heap_top - bytes; 
0723   07F0 3B EC 1C      mov d, _heap_top ; $heap_top
0724   07F3 2A            mov b, [d]
0725   07F4             ; START TERMS
0726   07F4 D7            push a
0727   07F5 11            mov a, b
0728   07F6 FA 05 00      lea d, [bp + 5] ; $bytes
0729   07F9 2A            mov b, [d]
0730   07FA 60            sub a, b
0731   07FB 27            mov b, a
0732   07FC E4            pop a
0733   07FD             ; END TERMS
0734   07FD F9            leave
0735   07FE 09            ret
0736   07FF             
0737   07FF             free:
0738   07FF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0739   0802             ;; return heap_top = heap_top - bytes; 
0740   0802 3B EC 1C      mov d, _heap_top ; $heap_top
0741   0805 DA            push d
0742   0806 3B EC 1C      mov d, _heap_top ; $heap_top
0743   0809 2A            mov b, [d]
0744   080A             ; START TERMS
0745   080A D7            push a
0746   080B 11            mov a, b
0747   080C FA 05 00      lea d, [bp + 5] ; $bytes
0748   080F 2A            mov b, [d]
0749   0810 60            sub a, b
0750   0811 27            mov b, a
0751   0812 E4            pop a
0752   0813             ; END TERMS
0753   0813 E7            pop d
0754   0814 FD 43         mov [d], b
0755   0816 F9            leave
0756   0817 09            ret
0757   0818             
0758   0818             fopen:
0759   0818 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0760   081B             ;; FILE *fp; 
0761   081B 52 02 00      sub sp, 2 ; fp
0762   081E             ;; fp = alloc(sizeof(int)); 
0763   081E FA FF FF      lea d, [bp + -1] ; $fp
0764   0821 DA            push d
0765   0822 26 02 00      mov b, 2
0766   0825 FD AB         swp b
0767   0827 D8            push b
0768   0828 07 DA 07      call alloc
0769   082B 51 02 00      add sp, 2
0770   082E E7            pop d
0771   082F FD 43         mov [d], b
0772   0831 F9            leave
0773   0832 09            ret
0774   0833             
0775   0833             printf:
0776   0833 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0777   0836             ;; char *p, *format_p; 
0778   0836 52 02 00      sub sp, 2 ; p
0779   0839 52 02 00      sub sp, 2 ; format_p
0780   083C             ;; format_p = format; 
0781   083C FA FD FF      lea d, [bp + -3] ; $format_p
0782   083F DA            push d
0783   0840 FA 05 00      lea d, [bp + 5] ; $format
0784   0843 2A            mov b, [d]
0785   0844 E7            pop d
0786   0845 FD 43         mov [d], b
0787   0847             ;; p = &format + 2; 
0788   0847 FA FF FF      lea d, [bp + -1] ; $p
0789   084A DA            push d
0790   084B FA 05 00      lea d, [bp + 5] ; $format
0791   084E 2D            mov b, d
0792   084F             ; START TERMS
0793   084F D7            push a
0794   0850 11            mov a, b
0795   0851 26 02 00      mov b, $2
0796   0854 56            add b, a
0797   0855 E4            pop a
0798   0856             ; END TERMS
0799   0856 E7            pop d
0800   0857 FD 43         mov [d], b
0801   0859             ;; for(;;){ 
0802   0859             _for12_init:
0803   0859             _for12_cond:
0804   0859             _for12_block:
0805   0859             ;; if(!*format_p) break; 
0806   0859             _if13_cond:
0807   0859 FA FD FF      lea d, [bp + -3] ; $format_p
0808   085C 2A            mov b, [d]
0809   085D 74            mov d, b
0810   085E 32            mov bl, [d]
0811   085F A7 00         mov bh, 0
0812   0861 C0 00 00      cmp b, 0
0813   0864 FD 71         seq ; !
0814   0866 C0 00 00      cmp b, 0
0815   0869 C6 72 08      je _if13_else
0816   086C             _if13_true:
0817   086C             ;; break; 
0818   086C 0A 99 0A      jmp _for12_exit ; for break
0819   086F 0A 96 0A      jmp _if13_exit
0820   0872             _if13_else:
0821   0872             ;; if(*format_p == '%'){ 
0822   0872             _if14_cond:
0823   0872 FA FD FF      lea d, [bp + -3] ; $format_p
0824   0875 2A            mov b, [d]
0825   0876 74            mov d, b
0826   0877 32            mov bl, [d]
0827   0878 A7 00         mov bh, 0
0828   087A             ; START RELATIONAL
0829   087A D7            push a
0830   087B 11            mov a, b
0831   087C 26 25 00      mov b, $25
0832   087F B0            cmp a, b
0833   0880 FD 71         seq ; ==
0834   0882 E4            pop a
0835   0883             ; END RELATIONAL
0836   0883 C0 00 00      cmp b, 0
0837   0886 C6 7A 0A      je _if14_else
0838   0889             _if14_true:
0839   0889             ;; format_p++; 
0840   0889 FA FD FF      lea d, [bp + -3] ; $format_p
0841   088C 2A            mov b, [d]
0842   088D FD 77         inc b
0843   088F FA FD FF      lea d, [bp + -3] ; $format_p
0844   0892 FD 43         mov [d], b
0845   0894 FD 7D         dec b
0846   0896             ;; switch(*format_p){ 
0847   0896             _switch15_expr:
0848   0896 FA FD FF      lea d, [bp + -3] ; $format_p
0849   0899 2A            mov b, [d]
0850   089A 74            mov d, b
0851   089B 32            mov bl, [d]
0852   089C A7 00         mov bh, 0
0853   089E             _switch15_comparisons:
0854   089E C1 6C         cmp bl, $6c
0855   08A0 C6 CC 08      je _switch15_case0
0856   08A3 C1 4C         cmp bl, $4c
0857   08A5 C6 CC 08      je _switch15_case1
0858   08A8 C1 64         cmp bl, $64
0859   08AA C6 BA 09      je _switch15_case2
0860   08AD C1 69         cmp bl, $69
0861   08AF C6 BA 09      je _switch15_case3
0862   08B2 C1 75         cmp bl, $75
0863   08B4 C6 DE 09      je _switch15_case4
0864   08B7 C1 78         cmp bl, $78
0865   08B9 C6 02 0A      je _switch15_case5
0866   08BC C1 63         cmp bl, $63
0867   08BE C6 20 0A      je _switch15_case6
0868   08C1 C1 73         cmp bl, $73
0869   08C3 C6 3F 0A      je _switch15_case7
0870   08C6 0A 5E 0A      jmp _switch15_default
0871   08C9 0A 6A 0A      jmp _switch15_exit
0872   08CC             _switch15_case0:
0873   08CC             _switch15_case1:
0874   08CC             ;; format_p++; 
0875   08CC FA FD FF      lea d, [bp + -3] ; $format_p
0876   08CF 2A            mov b, [d]
0877   08D0 FD 77         inc b
0878   08D2 FA FD FF      lea d, [bp + -3] ; $format_p
0879   08D5 FD 43         mov [d], b
0880   08D7 FD 7D         dec b
0881   08D9             ;; if(*format_p == 'd' || *format_p == 'i') 
0882   08D9             _if16_cond:
0883   08D9 FA FD FF      lea d, [bp + -3] ; $format_p
0884   08DC 2A            mov b, [d]
0885   08DD 74            mov d, b
0886   08DE 32            mov bl, [d]
0887   08DF A7 00         mov bh, 0
0888   08E1             ; START RELATIONAL
0889   08E1 D7            push a
0890   08E2 11            mov a, b
0891   08E3 26 64 00      mov b, $64
0892   08E6 B0            cmp a, b
0893   08E7 FD 71         seq ; ==
0894   08E9 E4            pop a
0895   08EA             ; END RELATIONAL
0896   08EA             ; START LOGICAL OR
0897   08EA D7            push a
0898   08EB 11            mov a, b
0899   08EC FA FD FF      lea d, [bp + -3] ; $format_p
0900   08EF 2A            mov b, [d]
0901   08F0 74            mov d, b
0902   08F1 32            mov bl, [d]
0903   08F2 A7 00         mov bh, 0
0904   08F4             ; START RELATIONAL
0905   08F4 D7            push a
0906   08F5 11            mov a, b
0907   08F6 26 69 00      mov b, $69
0908   08F9 B0            cmp a, b
0909   08FA FD 71         seq ; ==
0910   08FC E4            pop a
0911   08FD             ; END RELATIONAL
0912   08FD FD A8         sor a, b ; ||
0913   08FF E4            pop a
0914   0900             ; END LOGICAL OR
0915   0900 C0 00 00      cmp b, 0
0916   0903 C6 28 09      je _if16_else
0917   0906             _if16_true:
0918   0906             ;; print_signed_long(*(long *)p); 
0919   0906 FA FF FF      lea d, [bp + -1] ; $p
0920   0909 2A            mov b, [d]
0921   090A AB            snex b
0922   090B FD 39         mov c, b
0923   090D 74            mov d, b
0924   090E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0925   0911 FD 39         mov c, b ; And place it into C
0926   0913 2A            mov b, [d] ; Lower Word in B
0927   0914 FD 79         mov g, b
0928   0916 28            mov b, c
0929   0917 FD AB         swp b
0930   0919 D8            push b
0931   091A FD 27         mov b, g
0932   091C FD AB         swp b
0933   091E D8            push b
0934   091F 07 7F 0F      call print_signed_long
0935   0922 51 04 00      add sp, 4
0936   0925 0A A5 09      jmp _if16_exit
0937   0928             _if16_else:
0938   0928             ;; if(*format_p == 'u') 
0939   0928             _if17_cond:
0940   0928 FA FD FF      lea d, [bp + -3] ; $format_p
0941   092B 2A            mov b, [d]
0942   092C 74            mov d, b
0943   092D 32            mov bl, [d]
0944   092E A7 00         mov bh, 0
0945   0930             ; START RELATIONAL
0946   0930 D7            push a
0947   0931 11            mov a, b
0948   0932 26 75 00      mov b, $75
0949   0935 B0            cmp a, b
0950   0936 FD 71         seq ; ==
0951   0938 E4            pop a
0952   0939             ; END RELATIONAL
0953   0939 C0 00 00      cmp b, 0
0954   093C C6 63 09      je _if17_else
0955   093F             _if17_true:
0956   093F             ;; print_unsigned_long(*(unsigned long *)p); 
0957   093F FA FF FF      lea d, [bp + -1] ; $p
0958   0942 2A            mov b, [d]
0959   0943 A7 00         mov bh, 0
0960   0945 38 00 00      mov c, 0
0961   0948 74            mov d, b
0962   0949 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0963   094C FD 39         mov c, b ; And place it into C
0964   094E 2A            mov b, [d] ; Lower Word in B
0965   094F FD 79         mov g, b
0966   0951 28            mov b, c
0967   0952 FD AB         swp b
0968   0954 D8            push b
0969   0955 FD 27         mov b, g
0970   0957 FD AB         swp b
0971   0959 D8            push b
0972   095A 07 BF 12      call print_unsigned_long
0973   095D 51 04 00      add sp, 4
0974   0960 0A A5 09      jmp _if17_exit
0975   0963             _if17_else:
0976   0963             ;; if(*format_p == 'x') 
0977   0963             _if18_cond:
0978   0963 FA FD FF      lea d, [bp + -3] ; $format_p
0979   0966 2A            mov b, [d]
0980   0967 74            mov d, b
0981   0968 32            mov bl, [d]
0982   0969 A7 00         mov bh, 0
0983   096B             ; START RELATIONAL
0984   096B D7            push a
0985   096C 11            mov a, b
0986   096D 26 78 00      mov b, $78
0987   0970 B0            cmp a, b
0988   0971 FD 71         seq ; ==
0989   0973 E4            pop a
0990   0974             ; END RELATIONAL
0991   0974 C0 00 00      cmp b, 0
0992   0977 C6 99 09      je _if18_else
0993   097A             _if18_true:
0994   097A             ;; printx32(*(long int *)p); 
0995   097A FA FF FF      lea d, [bp + -1] ; $p
0996   097D 2A            mov b, [d]
0997   097E 74            mov d, b
0998   097F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0999   0982 FD 39         mov c, b ; And place it into C
1000   0984 2A            mov b, [d] ; Lower Word in B
1001   0985 FD 79         mov g, b
1002   0987 28            mov b, c
1003   0988 FD AB         swp b
1004   098A D8            push b
1005   098B FD 27         mov b, g
1006   098D FD AB         swp b
1007   098F D8            push b
1008   0990 07 F4 0C      call printx32
1009   0993 51 04 00      add sp, 4
1010   0996 0A A5 09      jmp _if18_exit
1011   0999             _if18_else:
1012   0999             ;; err("Unexpected format in printf."); 
1013   0999 26 A8 1C      mov b, _s3 ; "Unexpected format in printf."
1014   099C FD AB         swp b
1015   099E D8            push b
1016   099F 07 E2 0C      call err
1017   09A2 51 02 00      add sp, 2
1018   09A5             _if18_exit:
1019   09A5             _if17_exit:
1020   09A5             _if16_exit:
1021   09A5             ;; p = p + 4; 
1022   09A5 FA FF FF      lea d, [bp + -1] ; $p
1023   09A8 DA            push d
1024   09A9 FA FF FF      lea d, [bp + -1] ; $p
1025   09AC 2A            mov b, [d]
1026   09AD             ; START TERMS
1027   09AD D7            push a
1028   09AE 11            mov a, b
1029   09AF 26 04 00      mov b, $4
1030   09B2 56            add b, a
1031   09B3 E4            pop a
1032   09B4             ; END TERMS
1033   09B4 E7            pop d
1034   09B5 FD 43         mov [d], b
1035   09B7             ;; break; 
1036   09B7 0A 6A 0A      jmp _switch15_exit ; case break
1037   09BA             _switch15_case2:
1038   09BA             _switch15_case3:
1039   09BA             ;; print_signed(*(int*)p); 
1040   09BA FA FF FF      lea d, [bp + -1] ; $p
1041   09BD 2A            mov b, [d]
1042   09BE 74            mov d, b
1043   09BF 2A            mov b, [d]
1044   09C0 FD AB         swp b
1045   09C2 D8            push b
1046   09C3 07 88 0E      call print_signed
1047   09C6 51 02 00      add sp, 2
1048   09C9             ;; p = p + 2; 
1049   09C9 FA FF FF      lea d, [bp + -1] ; $p
1050   09CC DA            push d
1051   09CD FA FF FF      lea d, [bp + -1] ; $p
1052   09D0 2A            mov b, [d]
1053   09D1             ; START TERMS
1054   09D1 D7            push a
1055   09D2 11            mov a, b
1056   09D3 26 02 00      mov b, $2
1057   09D6 56            add b, a
1058   09D7 E4            pop a
1059   09D8             ; END TERMS
1060   09D8 E7            pop d
1061   09D9 FD 43         mov [d], b
1062   09DB             ;; break; 
1063   09DB 0A 6A 0A      jmp _switch15_exit ; case break
1064   09DE             _switch15_case4:
1065   09DE             ;; print_unsigned(*(unsigned int*)p); 
1066   09DE FA FF FF      lea d, [bp + -1] ; $p
1067   09E1 2A            mov b, [d]
1068   09E2 74            mov d, b
1069   09E3 2A            mov b, [d]
1070   09E4 FD AB         swp b
1071   09E6 D8            push b
1072   09E7 07 BA 14      call print_unsigned
1073   09EA 51 02 00      add sp, 2
1074   09ED             ;; p = p + 2; 
1075   09ED FA FF FF      lea d, [bp + -1] ; $p
1076   09F0 DA            push d
1077   09F1 FA FF FF      lea d, [bp + -1] ; $p
1078   09F4 2A            mov b, [d]
1079   09F5             ; START TERMS
1080   09F5 D7            push a
1081   09F6 11            mov a, b
1082   09F7 26 02 00      mov b, $2
1083   09FA 56            add b, a
1084   09FB E4            pop a
1085   09FC             ; END TERMS
1086   09FC E7            pop d
1087   09FD FD 43         mov [d], b
1088   09FF             ;; break; 
1089   09FF 0A 6A 0A      jmp _switch15_exit ; case break
1090   0A02             _switch15_case5:
1091   0A02             
1092   0A02             ; --- BEGIN INLINE ASM BLOCK
1093   0A02 FA FF FF      lea d, [bp + -1] ; $p
1094   0A05 FD 2A         mov d, [d]
1095   0A07 2A            mov b, [d]
1096   0A08 07 C0 18      call print_u16x
1097   0A0B             ; --- END INLINE ASM BLOCK
1098   0A0B             
1099   0A0B             ;; p = p + 2; 
1100   0A0B FA FF FF      lea d, [bp + -1] ; $p
1101   0A0E DA            push d
1102   0A0F FA FF FF      lea d, [bp + -1] ; $p
1103   0A12 2A            mov b, [d]
1104   0A13             ; START TERMS
1105   0A13 D7            push a
1106   0A14 11            mov a, b
1107   0A15 26 02 00      mov b, $2
1108   0A18 56            add b, a
1109   0A19 E4            pop a
1110   0A1A             ; END TERMS
1111   0A1A E7            pop d
1112   0A1B FD 43         mov [d], b
1113   0A1D             ;; break; 
1114   0A1D 0A 6A 0A      jmp _switch15_exit ; case break
1115   0A20             _switch15_case6:
1116   0A20             
1117   0A20             ; --- BEGIN INLINE ASM BLOCK
1118   0A20 FA FF FF      lea d, [bp + -1] ; $p
1119   0A23 FD 2A         mov d, [d]
1120   0A25 1E            mov al, [d]
1121   0A26 23            mov ah, al
1122   0A27 07 1E 17      call _putchar
1123   0A2A             ; --- END INLINE ASM BLOCK
1124   0A2A             
1125   0A2A             ;; p = p + 2; 
1126   0A2A FA FF FF      lea d, [bp + -1] ; $p
1127   0A2D DA            push d
1128   0A2E FA FF FF      lea d, [bp + -1] ; $p
1129   0A31 2A            mov b, [d]
1130   0A32             ; START TERMS
1131   0A32 D7            push a
1132   0A33 11            mov a, b
1133   0A34 26 02 00      mov b, $2
1134   0A37 56            add b, a
1135   0A38 E4            pop a
1136   0A39             ; END TERMS
1137   0A39 E7            pop d
1138   0A3A FD 43         mov [d], b
1139   0A3C             ;; break; 
1140   0A3C 0A 6A 0A      jmp _switch15_exit ; case break
1141   0A3F             _switch15_case7:
1142   0A3F             
1143   0A3F             ; --- BEGIN INLINE ASM BLOCK
1144   0A3F FA FF FF      lea d, [bp + -1] ; $p
1145   0A42 FD 2A         mov d, [d]
1146   0A44 FD 2A         mov d, [d]
1147   0A46 07 68 18      call _puts
1148   0A49             ; --- END INLINE ASM BLOCK
1149   0A49             
1150   0A49             ;; p = p + 2; 
1151   0A49 FA FF FF      lea d, [bp + -1] ; $p
1152   0A4C DA            push d
1153   0A4D FA FF FF      lea d, [bp + -1] ; $p
1154   0A50 2A            mov b, [d]
1155   0A51             ; START TERMS
1156   0A51 D7            push a
1157   0A52 11            mov a, b
1158   0A53 26 02 00      mov b, $2
1159   0A56 56            add b, a
1160   0A57 E4            pop a
1161   0A58             ; END TERMS
1162   0A58 E7            pop d
1163   0A59 FD 43         mov [d], b
1164   0A5B             ;; break; 
1165   0A5B 0A 6A 0A      jmp _switch15_exit ; case break
1166   0A5E             _switch15_default:
1167   0A5E             ;; print("Error: Unknown argument type.\n"); 
1168   0A5E 26 C5 1C      mov b, _s4 ; "Error: Unknown argument type.\n"
1169   0A61 FD AB         swp b
1170   0A63 D8            push b
1171   0A64 07 D5 15      call print
1172   0A67 51 02 00      add sp, 2
1173   0A6A             _switch15_exit:
1174   0A6A             ;; format_p++; 
1175   0A6A FA FD FF      lea d, [bp + -3] ; $format_p
1176   0A6D 2A            mov b, [d]
1177   0A6E FD 77         inc b
1178   0A70 FA FD FF      lea d, [bp + -3] ; $format_p
1179   0A73 FD 43         mov [d], b
1180   0A75 FD 7D         dec b
1181   0A77 0A 96 0A      jmp _if14_exit
1182   0A7A             _if14_else:
1183   0A7A             ;; putchar(*format_p); 
1184   0A7A FA FD FF      lea d, [bp + -3] ; $format_p
1185   0A7D 2A            mov b, [d]
1186   0A7E 74            mov d, b
1187   0A7F 32            mov bl, [d]
1188   0A80 A7 00         mov bh, 0
1189   0A82 DD            push bl
1190   0A83 07 8D 15      call putchar
1191   0A86 51 01 00      add sp, 1
1192   0A89             ;; format_p++; 
1193   0A89 FA FD FF      lea d, [bp + -3] ; $format_p
1194   0A8C 2A            mov b, [d]
1195   0A8D FD 77         inc b
1196   0A8F FA FD FF      lea d, [bp + -3] ; $format_p
1197   0A92 FD 43         mov [d], b
1198   0A94 FD 7D         dec b
1199   0A96             _if14_exit:
1200   0A96             _if13_exit:
1201   0A96             _for12_update:
1202   0A96 0A 59 08      jmp _for12_cond
1203   0A99             _for12_exit:
1204   0A99 F9            leave
1205   0A9A 09            ret
1206   0A9B             
1207   0A9B             scanf:
1208   0A9B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1209   0A9E             ;; char *p, *format_p; 
1210   0A9E 52 02 00      sub sp, 2 ; p
1211   0AA1 52 02 00      sub sp, 2 ; format_p
1212   0AA4             ;; char c; 
1213   0AA4 52 01 00      sub sp, 1 ; c
1214   0AA7             ;; int i; 
1215   0AA7 52 02 00      sub sp, 2 ; i
1216   0AAA             ;; char input_string[  512                    ]; 
1217   0AAA 52 00 02      sub sp, 512 ; input_string
1218   0AAD             ;; format_p = format; 
1219   0AAD FA FD FF      lea d, [bp + -3] ; $format_p
1220   0AB0 DA            push d
1221   0AB1 FA 05 00      lea d, [bp + 5] ; $format
1222   0AB4 2A            mov b, [d]
1223   0AB5 E7            pop d
1224   0AB6 FD 43         mov [d], b
1225   0AB8             ;; p = &format + 2; 
1226   0AB8 FA FF FF      lea d, [bp + -1] ; $p
1227   0ABB DA            push d
1228   0ABC FA 05 00      lea d, [bp + 5] ; $format
1229   0ABF 2D            mov b, d
1230   0AC0             ; START TERMS
1231   0AC0 D7            push a
1232   0AC1 11            mov a, b
1233   0AC2 26 02 00      mov b, $2
1234   0AC5 56            add b, a
1235   0AC6 E4            pop a
1236   0AC7             ; END TERMS
1237   0AC7 E7            pop d
1238   0AC8 FD 43         mov [d], b
1239   0ACA             ;; for(;;){ 
1240   0ACA             _for19_init:
1241   0ACA             _for19_cond:
1242   0ACA             _for19_block:
1243   0ACA             ;; if(!*format_p) break; 
1244   0ACA             _if20_cond:
1245   0ACA FA FD FF      lea d, [bp + -3] ; $format_p
1246   0ACD 2A            mov b, [d]
1247   0ACE 74            mov d, b
1248   0ACF 32            mov bl, [d]
1249   0AD0 A7 00         mov bh, 0
1250   0AD2 C0 00 00      cmp b, 0
1251   0AD5 FD 71         seq ; !
1252   0AD7 C0 00 00      cmp b, 0
1253   0ADA C6 E3 0A      je _if20_else
1254   0ADD             _if20_true:
1255   0ADD             ;; break; 
1256   0ADD 0A E0 0C      jmp _for19_exit ; for break
1257   0AE0 0A DD 0C      jmp _if20_exit
1258   0AE3             _if20_else:
1259   0AE3             ;; if(*format_p == '%'){ 
1260   0AE3             _if21_cond:
1261   0AE3 FA FD FF      lea d, [bp + -3] ; $format_p
1262   0AE6 2A            mov b, [d]
1263   0AE7 74            mov d, b
1264   0AE8 32            mov bl, [d]
1265   0AE9 A7 00         mov bh, 0
1266   0AEB             ; START RELATIONAL
1267   0AEB D7            push a
1268   0AEC 11            mov a, b
1269   0AED 26 25 00      mov b, $25
1270   0AF0 B0            cmp a, b
1271   0AF1 FD 71         seq ; ==
1272   0AF3 E4            pop a
1273   0AF4             ; END RELATIONAL
1274   0AF4 C0 00 00      cmp b, 0
1275   0AF7 C6 C1 0C      je _if21_else
1276   0AFA             _if21_true:
1277   0AFA             ;; format_p++; 
1278   0AFA FA FD FF      lea d, [bp + -3] ; $format_p
1279   0AFD 2A            mov b, [d]
1280   0AFE FD 77         inc b
1281   0B00 FA FD FF      lea d, [bp + -3] ; $format_p
1282   0B03 FD 43         mov [d], b
1283   0B05 FD 7D         dec b
1284   0B07             ;; switch(*format_p){ 
1285   0B07             _switch22_expr:
1286   0B07 FA FD FF      lea d, [bp + -3] ; $format_p
1287   0B0A 2A            mov b, [d]
1288   0B0B 74            mov d, b
1289   0B0C 32            mov bl, [d]
1290   0B0D A7 00         mov bh, 0
1291   0B0F             _switch22_comparisons:
1292   0B0F C1 6C         cmp bl, $6c
1293   0B11 C6 3D 0B      je _switch22_case0
1294   0B14 C1 4C         cmp bl, $4c
1295   0B16 C6 3D 0B      je _switch22_case1
1296   0B19 C1 64         cmp bl, $64
1297   0B1B C6 CF 0B      je _switch22_case2
1298   0B1E C1 69         cmp bl, $69
1299   0B20 C6 CF 0B      je _switch22_case3
1300   0B23 C1 75         cmp bl, $75
1301   0B25 C6 FC 0B      je _switch22_case4
1302   0B28 C1 78         cmp bl, $78
1303   0B2A C6 29 0C      je _switch22_case5
1304   0B2D C1 63         cmp bl, $63
1305   0B2F C6 3E 0C      je _switch22_case6
1306   0B32 C1 73         cmp bl, $73
1307   0B34 C6 6D 0C      je _switch22_case7
1308   0B37 0A A5 0C      jmp _switch22_default
1309   0B3A 0A B1 0C      jmp _switch22_exit
1310   0B3D             _switch22_case0:
1311   0B3D             _switch22_case1:
1312   0B3D             ;; format_p++; 
1313   0B3D FA FD FF      lea d, [bp + -3] ; $format_p
1314   0B40 2A            mov b, [d]
1315   0B41 FD 77         inc b
1316   0B43 FA FD FF      lea d, [bp + -3] ; $format_p
1317   0B46 FD 43         mov [d], b
1318   0B48 FD 7D         dec b
1319   0B4A             ;; if(*format_p == 'd' || *format_p == 'i'); 
1320   0B4A             _if23_cond:
1321   0B4A FA FD FF      lea d, [bp + -3] ; $format_p
1322   0B4D 2A            mov b, [d]
1323   0B4E 74            mov d, b
1324   0B4F 32            mov bl, [d]
1325   0B50 A7 00         mov bh, 0
1326   0B52             ; START RELATIONAL
1327   0B52 D7            push a
1328   0B53 11            mov a, b
1329   0B54 26 64 00      mov b, $64
1330   0B57 B0            cmp a, b
1331   0B58 FD 71         seq ; ==
1332   0B5A E4            pop a
1333   0B5B             ; END RELATIONAL
1334   0B5B             ; START LOGICAL OR
1335   0B5B D7            push a
1336   0B5C 11            mov a, b
1337   0B5D FA FD FF      lea d, [bp + -3] ; $format_p
1338   0B60 2A            mov b, [d]
1339   0B61 74            mov d, b
1340   0B62 32            mov bl, [d]
1341   0B63 A7 00         mov bh, 0
1342   0B65             ; START RELATIONAL
1343   0B65 D7            push a
1344   0B66 11            mov a, b
1345   0B67 26 69 00      mov b, $69
1346   0B6A B0            cmp a, b
1347   0B6B FD 71         seq ; ==
1348   0B6D E4            pop a
1349   0B6E             ; END RELATIONAL
1350   0B6E FD A8         sor a, b ; ||
1351   0B70 E4            pop a
1352   0B71             ; END LOGICAL OR
1353   0B71 C0 00 00      cmp b, 0
1354   0B74 C6 7A 0B      je _if23_else
1355   0B77             _if23_true:
1356   0B77             ;; ; 
1357   0B77 0A BA 0B      jmp _if23_exit
1358   0B7A             _if23_else:
1359   0B7A             ;; if(*format_p == 'u'); 
1360   0B7A             _if24_cond:
1361   0B7A FA FD FF      lea d, [bp + -3] ; $format_p
1362   0B7D 2A            mov b, [d]
1363   0B7E 74            mov d, b
1364   0B7F 32            mov bl, [d]
1365   0B80 A7 00         mov bh, 0
1366   0B82             ; START RELATIONAL
1367   0B82 D7            push a
1368   0B83 11            mov a, b
1369   0B84 26 75 00      mov b, $75
1370   0B87 B0            cmp a, b
1371   0B88 FD 71         seq ; ==
1372   0B8A E4            pop a
1373   0B8B             ; END RELATIONAL
1374   0B8B C0 00 00      cmp b, 0
1375   0B8E C6 94 0B      je _if24_else
1376   0B91             _if24_true:
1377   0B91             ;; ; 
1378   0B91 0A BA 0B      jmp _if24_exit
1379   0B94             _if24_else:
1380   0B94             ;; if(*format_p == 'x'); 
1381   0B94             _if25_cond:
1382   0B94 FA FD FF      lea d, [bp + -3] ; $format_p
1383   0B97 2A            mov b, [d]
1384   0B98 74            mov d, b
1385   0B99 32            mov bl, [d]
1386   0B9A A7 00         mov bh, 0
1387   0B9C             ; START RELATIONAL
1388   0B9C D7            push a
1389   0B9D 11            mov a, b
1390   0B9E 26 78 00      mov b, $78
1391   0BA1 B0            cmp a, b
1392   0BA2 FD 71         seq ; ==
1393   0BA4 E4            pop a
1394   0BA5             ; END RELATIONAL
1395   0BA5 C0 00 00      cmp b, 0
1396   0BA8 C6 AE 0B      je _if25_else
1397   0BAB             _if25_true:
1398   0BAB             ;; ; 
1399   0BAB 0A BA 0B      jmp _if25_exit
1400   0BAE             _if25_else:
1401   0BAE             ;; err("Unexpected format in printf."); 
1402   0BAE 26 A8 1C      mov b, _s3 ; "Unexpected format in printf."
1403   0BB1 FD AB         swp b
1404   0BB3 D8            push b
1405   0BB4 07 E2 0C      call err
1406   0BB7 51 02 00      add sp, 2
1407   0BBA             _if25_exit:
1408   0BBA             _if24_exit:
1409   0BBA             _if23_exit:
1410   0BBA             ;; p = p + 4; 
1411   0BBA FA FF FF      lea d, [bp + -1] ; $p
1412   0BBD DA            push d
1413   0BBE FA FF FF      lea d, [bp + -1] ; $p
1414   0BC1 2A            mov b, [d]
1415   0BC2             ; START TERMS
1416   0BC2 D7            push a
1417   0BC3 11            mov a, b
1418   0BC4 26 04 00      mov b, $4
1419   0BC7 56            add b, a
1420   0BC8 E4            pop a
1421   0BC9             ; END TERMS
1422   0BC9 E7            pop d
1423   0BCA FD 43         mov [d], b
1424   0BCC             ;; break; 
1425   0BCC 0A B1 0C      jmp _switch22_exit ; case break
1426   0BCF             _switch22_case2:
1427   0BCF             _switch22_case3:
1428   0BCF             ;; i = scann(); 
1429   0BCF FA FA FF      lea d, [bp + -6] ; $i
1430   0BD2 DA            push d
1431   0BD3 07 B0 15      call scann
1432   0BD6 E7            pop d
1433   0BD7 FD 43         mov [d], b
1434   0BD9             ;; **(int **)p = i; 
1435   0BD9 FA FF FF      lea d, [bp + -1] ; $p
1436   0BDC 2A            mov b, [d]
1437   0BDD 74            mov d, b
1438   0BDE 2A            mov b, [d]
1439   0BDF D8            push b
1440   0BE0 FA FA FF      lea d, [bp + -6] ; $i
1441   0BE3 2A            mov b, [d]
1442   0BE4 E7            pop d
1443   0BE5 FD 43         mov [d], b
1444   0BE7             ;; p = p + 2; 
1445   0BE7 FA FF FF      lea d, [bp + -1] ; $p
1446   0BEA DA            push d
1447   0BEB FA FF FF      lea d, [bp + -1] ; $p
1448   0BEE 2A            mov b, [d]
1449   0BEF             ; START TERMS
1450   0BEF D7            push a
1451   0BF0 11            mov a, b
1452   0BF1 26 02 00      mov b, $2
1453   0BF4 56            add b, a
1454   0BF5 E4            pop a
1455   0BF6             ; END TERMS
1456   0BF6 E7            pop d
1457   0BF7 FD 43         mov [d], b
1458   0BF9             ;; break; 
1459   0BF9 0A B1 0C      jmp _switch22_exit ; case break
1460   0BFC             _switch22_case4:
1461   0BFC             ;; i = scann(); 
1462   0BFC FA FA FF      lea d, [bp + -6] ; $i
1463   0BFF DA            push d
1464   0C00 07 B0 15      call scann
1465   0C03 E7            pop d
1466   0C04 FD 43         mov [d], b
1467   0C06             ;; **(int **)p = i; 
1468   0C06 FA FF FF      lea d, [bp + -1] ; $p
1469   0C09 2A            mov b, [d]
1470   0C0A 74            mov d, b
1471   0C0B 2A            mov b, [d]
1472   0C0C D8            push b
1473   0C0D FA FA FF      lea d, [bp + -6] ; $i
1474   0C10 2A            mov b, [d]
1475   0C11 E7            pop d
1476   0C12 FD 43         mov [d], b
1477   0C14             ;; p = p + 2; 
1478   0C14 FA FF FF      lea d, [bp + -1] ; $p
1479   0C17 DA            push d
1480   0C18 FA FF FF      lea d, [bp + -1] ; $p
1481   0C1B 2A            mov b, [d]
1482   0C1C             ; START TERMS
1483   0C1C D7            push a
1484   0C1D 11            mov a, b
1485   0C1E 26 02 00      mov b, $2
1486   0C21 56            add b, a
1487   0C22 E4            pop a
1488   0C23             ; END TERMS
1489   0C23 E7            pop d
1490   0C24 FD 43         mov [d], b
1491   0C26             ;; break; 
1492   0C26 0A B1 0C      jmp _switch22_exit ; case break
1493   0C29             _switch22_case5:
1494   0C29             ;; p = p + 2; 
1495   0C29 FA FF FF      lea d, [bp + -1] ; $p
1496   0C2C DA            push d
1497   0C2D FA FF FF      lea d, [bp + -1] ; $p
1498   0C30 2A            mov b, [d]
1499   0C31             ; START TERMS
1500   0C31 D7            push a
1501   0C32 11            mov a, b
1502   0C33 26 02 00      mov b, $2
1503   0C36 56            add b, a
1504   0C37 E4            pop a
1505   0C38             ; END TERMS
1506   0C38 E7            pop d
1507   0C39 FD 43         mov [d], b
1508   0C3B             ;; break; 
1509   0C3B 0A B1 0C      jmp _switch22_exit ; case break
1510   0C3E             _switch22_case6:
1511   0C3E             ;; c = getchar(); 
1512   0C3E FA FC FF      lea d, [bp + -4] ; $c
1513   0C41 DA            push d
1514   0C42 07 9A 15      call getchar
1515   0C45 E7            pop d
1516   0C46 FD 3E         mov [d], bl
1517   0C48             ;; **(char **)p = c; 
1518   0C48 FA FF FF      lea d, [bp + -1] ; $p
1519   0C4B 2A            mov b, [d]
1520   0C4C 74            mov d, b
1521   0C4D 2A            mov b, [d]
1522   0C4E D8            push b
1523   0C4F FA FC FF      lea d, [bp + -4] ; $c
1524   0C52 32            mov bl, [d]
1525   0C53 A7 00         mov bh, 0
1526   0C55 E7            pop d
1527   0C56 FD 43         mov [d], b
1528   0C58             ;; p = p + 2; 
1529   0C58 FA FF FF      lea d, [bp + -1] ; $p
1530   0C5B DA            push d
1531   0C5C FA FF FF      lea d, [bp + -1] ; $p
1532   0C5F 2A            mov b, [d]
1533   0C60             ; START TERMS
1534   0C60 D7            push a
1535   0C61 11            mov a, b
1536   0C62 26 02 00      mov b, $2
1537   0C65 56            add b, a
1538   0C66 E4            pop a
1539   0C67             ; END TERMS
1540   0C67 E7            pop d
1541   0C68 FD 43         mov [d], b
1542   0C6A             ;; break; 
1543   0C6A 0A B1 0C      jmp _switch22_exit ; case break
1544   0C6D             _switch22_case7:
1545   0C6D             ;; gets(input_string); 
1546   0C6D FA FA FD      lea d, [bp + -518] ; $input_string
1547   0C70 2D            mov b, d
1548   0C71 FD AB         swp b
1549   0C73 D8            push b
1550   0C74 07 6E 0E      call gets
1551   0C77 51 02 00      add sp, 2
1552   0C7A             ;; strcpy(*(char **)p, input_string); 
1553   0C7A FA FA FD      lea d, [bp + -518] ; $input_string
1554   0C7D 2D            mov b, d
1555   0C7E FD AB         swp b
1556   0C80 D8            push b
1557   0C81 FA FF FF      lea d, [bp + -1] ; $p
1558   0C84 2A            mov b, [d]
1559   0C85 74            mov d, b
1560   0C86 2A            mov b, [d]
1561   0C87 FD AB         swp b
1562   0C89 D8            push b
1563   0C8A 07 8D 04      call strcpy
1564   0C8D 51 04 00      add sp, 4
1565   0C90             ;; p = p + 2; 
1566   0C90 FA FF FF      lea d, [bp + -1] ; $p
1567   0C93 DA            push d
1568   0C94 FA FF FF      lea d, [bp + -1] ; $p
1569   0C97 2A            mov b, [d]
1570   0C98             ; START TERMS
1571   0C98 D7            push a
1572   0C99 11            mov a, b
1573   0C9A 26 02 00      mov b, $2
1574   0C9D 56            add b, a
1575   0C9E E4            pop a
1576   0C9F             ; END TERMS
1577   0C9F E7            pop d
1578   0CA0 FD 43         mov [d], b
1579   0CA2             ;; break; 
1580   0CA2 0A B1 0C      jmp _switch22_exit ; case break
1581   0CA5             _switch22_default:
1582   0CA5             ;; print("Error: Unknown argument type.\n"); 
1583   0CA5 26 C5 1C      mov b, _s4 ; "Error: Unknown argument type.\n"
1584   0CA8 FD AB         swp b
1585   0CAA D8            push b
1586   0CAB 07 D5 15      call print
1587   0CAE 51 02 00      add sp, 2
1588   0CB1             _switch22_exit:
1589   0CB1             ;; format_p++; 
1590   0CB1 FA FD FF      lea d, [bp + -3] ; $format_p
1591   0CB4 2A            mov b, [d]
1592   0CB5 FD 77         inc b
1593   0CB7 FA FD FF      lea d, [bp + -3] ; $format_p
1594   0CBA FD 43         mov [d], b
1595   0CBC FD 7D         dec b
1596   0CBE 0A DD 0C      jmp _if21_exit
1597   0CC1             _if21_else:
1598   0CC1             ;; putchar(*format_p); 
1599   0CC1 FA FD FF      lea d, [bp + -3] ; $format_p
1600   0CC4 2A            mov b, [d]
1601   0CC5 74            mov d, b
1602   0CC6 32            mov bl, [d]
1603   0CC7 A7 00         mov bh, 0
1604   0CC9 DD            push bl
1605   0CCA 07 8D 15      call putchar
1606   0CCD 51 01 00      add sp, 1
1607   0CD0             ;; format_p++; 
1608   0CD0 FA FD FF      lea d, [bp + -3] ; $format_p
1609   0CD3 2A            mov b, [d]
1610   0CD4 FD 77         inc b
1611   0CD6 FA FD FF      lea d, [bp + -3] ; $format_p
1612   0CD9 FD 43         mov [d], b
1613   0CDB FD 7D         dec b
1614   0CDD             _if21_exit:
1615   0CDD             _if20_exit:
1616   0CDD             _for19_update:
1617   0CDD 0A CA 0A      jmp _for19_cond
1618   0CE0             _for19_exit:
1619   0CE0 F9            leave
1620   0CE1 09            ret
1621   0CE2             
1622   0CE2             err:
1623   0CE2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1624   0CE5             ;; print(e); 
1625   0CE5 FA 05 00      lea d, [bp + 5] ; $e
1626   0CE8 2A            mov b, [d]
1627   0CE9 FD AB         swp b
1628   0CEB D8            push b
1629   0CEC 07 D5 15      call print
1630   0CEF 51 02 00      add sp, 2
1631   0CF2 F9            leave
1632   0CF3 09            ret
1633   0CF4             
1634   0CF4             printx32:
1635   0CF4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1636   0CF7             
1637   0CF7             ; --- BEGIN INLINE ASM BLOCK
1638   0CF7 FA 05 00      lea d, [bp + 5] ; $hex
1639   0CFA 2B 02 00      mov b, [d+2]
1640   0CFD 07 C0 18      call print_u16x
1641   0D00 2A            mov b, [d]
1642   0D01 07 C0 18      call print_u16x
1643   0D04             ; --- END INLINE ASM BLOCK
1644   0D04             
1645   0D04 F9            leave
1646   0D05 09            ret
1647   0D06             
1648   0D06             printx16:
1649   0D06 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1650   0D09             
1651   0D09             ; --- BEGIN INLINE ASM BLOCK
1652   0D09 FA 05 00      lea d, [bp + 5] ; $hex
1653   0D0C 2A            mov b, [d]
1654   0D0D 07 C0 18      call print_u16x
1655   0D10             ; --- END INLINE ASM BLOCK
1656   0D10             
1657   0D10 F9            leave
1658   0D11 09            ret
1659   0D12             
1660   0D12             printx8:
1661   0D12 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1662   0D15             
1663   0D15             ; --- BEGIN INLINE ASM BLOCK
1664   0D15 FA 05 00      lea d, [bp + 5] ; $hex
1665   0D18 32            mov bl, [d]
1666   0D19 07 04 19      call print_u8x
1667   0D1C             ; --- END INLINE ASM BLOCK
1668   0D1C             
1669   0D1C F9            leave
1670   0D1D 09            ret
1671   0D1E             
1672   0D1E             hex_str_to_int:
1673   0D1E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1674   0D21             ;; int value = 0; 
1675   0D21 52 02 00      sub sp, 2 ; value
1676   0D24             ; --- START LOCAL VAR INITIALIZATION
1677   0D24 FA FF FF      lea d, [bp + -1] ; $value
1678   0D27 DA            push d
1679   0D28 26 00 00      mov b, $0
1680   0D2B E7            pop d
1681   0D2C FD 43         mov [d], b
1682   0D2E             ; --- END LOCAL VAR INITIALIZATION
1683   0D2E             ;; int i; 
1684   0D2E 52 02 00      sub sp, 2 ; i
1685   0D31             ;; char hex_char; 
1686   0D31 52 01 00      sub sp, 1 ; hex_char
1687   0D34             ;; int len; 
1688   0D34 52 02 00      sub sp, 2 ; len
1689   0D37             ;; len = strlen(hex_string); 
1690   0D37 FA FA FF      lea d, [bp + -6] ; $len
1691   0D3A DA            push d
1692   0D3B FA 05 00      lea d, [bp + 5] ; $hex_string
1693   0D3E 2A            mov b, [d]
1694   0D3F FD AB         swp b
1695   0D41 D8            push b
1696   0D42 07 07 06      call strlen
1697   0D45 51 02 00      add sp, 2
1698   0D48 E7            pop d
1699   0D49 FD 43         mov [d], b
1700   0D4B             ;; for (i = 0; i < len; i++) { 
1701   0D4B             _for26_init:
1702   0D4B FA FD FF      lea d, [bp + -3] ; $i
1703   0D4E DA            push d
1704   0D4F 26 00 00      mov b, $0
1705   0D52 E7            pop d
1706   0D53 FD 43         mov [d], b
1707   0D55             _for26_cond:
1708   0D55 FA FD FF      lea d, [bp + -3] ; $i
1709   0D58 2A            mov b, [d]
1710   0D59             ; START RELATIONAL
1711   0D59 D7            push a
1712   0D5A 11            mov a, b
1713   0D5B FA FA FF      lea d, [bp + -6] ; $len
1714   0D5E 2A            mov b, [d]
1715   0D5F B0            cmp a, b
1716   0D60 FD 73         slt ; < (signed)
1717   0D62 E4            pop a
1718   0D63             ; END RELATIONAL
1719   0D63 C0 00 00      cmp b, 0
1720   0D66 C6 68 0E      je _for26_exit
1721   0D69             _for26_block:
1722   0D69             ;; hex_char = hex_string[i]; 
1723   0D69 FA FC FF      lea d, [bp + -4] ; $hex_char
1724   0D6C DA            push d
1725   0D6D FA 05 00      lea d, [bp + 5] ; $hex_string
1726   0D70 FD 2A         mov d, [d]
1727   0D72 D7            push a
1728   0D73 DA            push d
1729   0D74 FA FD FF      lea d, [bp + -3] ; $i
1730   0D77 2A            mov b, [d]
1731   0D78 E7            pop d
1732   0D79 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1733   0D7D E4            pop a
1734   0D7E 32            mov bl, [d]
1735   0D7F A7 00         mov bh, 0
1736   0D81 E7            pop d
1737   0D82 FD 3E         mov [d], bl
1738   0D84             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1739   0D84             _if27_cond:
1740   0D84 FA FC FF      lea d, [bp + -4] ; $hex_char
1741   0D87 32            mov bl, [d]
1742   0D88 A7 00         mov bh, 0
1743   0D8A             ; START RELATIONAL
1744   0D8A D7            push a
1745   0D8B 11            mov a, b
1746   0D8C 26 61 00      mov b, $61
1747   0D8F B0            cmp a, b
1748   0D90 FD 80         sge ; >=
1749   0D92 E4            pop a
1750   0D93             ; END RELATIONAL
1751   0D93             ; START LOGICAL AND
1752   0D93 D7            push a
1753   0D94 11            mov a, b
1754   0D95 FA FC FF      lea d, [bp + -4] ; $hex_char
1755   0D98 32            mov bl, [d]
1756   0D99 A7 00         mov bh, 0
1757   0D9B             ; START RELATIONAL
1758   0D9B D7            push a
1759   0D9C 11            mov a, b
1760   0D9D 26 66 00      mov b, $66
1761   0DA0 B0            cmp a, b
1762   0DA1 FD 74         sle ; <= (signed)
1763   0DA3 E4            pop a
1764   0DA4             ; END RELATIONAL
1765   0DA4 FD A7         sand a, b
1766   0DA6 E4            pop a
1767   0DA7             ; END LOGICAL AND
1768   0DA7 C0 00 00      cmp b, 0
1769   0DAA C6 DB 0D      je _if27_else
1770   0DAD             _if27_true:
1771   0DAD             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1772   0DAD FA FF FF      lea d, [bp + -1] ; $value
1773   0DB0 DA            push d
1774   0DB1 FA FF FF      lea d, [bp + -1] ; $value
1775   0DB4 2A            mov b, [d]
1776   0DB5             ; START FACTORS
1777   0DB5 D7            push a
1778   0DB6 11            mov a, b
1779   0DB7 26 10 00      mov b, $10
1780   0DBA AC            mul a, b ; *
1781   0DBB 11            mov a, b
1782   0DBC 27            mov b, a
1783   0DBD E4            pop a
1784   0DBE             ; END FACTORS
1785   0DBE             ; START TERMS
1786   0DBE D7            push a
1787   0DBF 11            mov a, b
1788   0DC0 FA FC FF      lea d, [bp + -4] ; $hex_char
1789   0DC3 32            mov bl, [d]
1790   0DC4 A7 00         mov bh, 0
1791   0DC6             ; START TERMS
1792   0DC6 D7            push a
1793   0DC7 11            mov a, b
1794   0DC8 26 61 00      mov b, $61
1795   0DCB 60            sub a, b
1796   0DCC 27            mov b, a
1797   0DCD 11            mov a, b
1798   0DCE 26 0A 00      mov b, $a
1799   0DD1 56            add b, a
1800   0DD2 E4            pop a
1801   0DD3             ; END TERMS
1802   0DD3 56            add b, a
1803   0DD4 E4            pop a
1804   0DD5             ; END TERMS
1805   0DD5 E7            pop d
1806   0DD6 FD 43         mov [d], b
1807   0DD8 0A 58 0E      jmp _if27_exit
1808   0DDB             _if27_else:
1809   0DDB             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1810   0DDB             _if28_cond:
1811   0DDB FA FC FF      lea d, [bp + -4] ; $hex_char
1812   0DDE 32            mov bl, [d]
1813   0DDF A7 00         mov bh, 0
1814   0DE1             ; START RELATIONAL
1815   0DE1 D7            push a
1816   0DE2 11            mov a, b
1817   0DE3 26 41 00      mov b, $41
1818   0DE6 B0            cmp a, b
1819   0DE7 FD 80         sge ; >=
1820   0DE9 E4            pop a
1821   0DEA             ; END RELATIONAL
1822   0DEA             ; START LOGICAL AND
1823   0DEA D7            push a
1824   0DEB 11            mov a, b
1825   0DEC FA FC FF      lea d, [bp + -4] ; $hex_char
1826   0DEF 32            mov bl, [d]
1827   0DF0 A7 00         mov bh, 0
1828   0DF2             ; START RELATIONAL
1829   0DF2 D7            push a
1830   0DF3 11            mov a, b
1831   0DF4 26 46 00      mov b, $46
1832   0DF7 B0            cmp a, b
1833   0DF8 FD 74         sle ; <= (signed)
1834   0DFA E4            pop a
1835   0DFB             ; END RELATIONAL
1836   0DFB FD A7         sand a, b
1837   0DFD E4            pop a
1838   0DFE             ; END LOGICAL AND
1839   0DFE C0 00 00      cmp b, 0
1840   0E01 C6 32 0E      je _if28_else
1841   0E04             _if28_true:
1842   0E04             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1843   0E04 FA FF FF      lea d, [bp + -1] ; $value
1844   0E07 DA            push d
1845   0E08 FA FF FF      lea d, [bp + -1] ; $value
1846   0E0B 2A            mov b, [d]
1847   0E0C             ; START FACTORS
1848   0E0C D7            push a
1849   0E0D 11            mov a, b
1850   0E0E 26 10 00      mov b, $10
1851   0E11 AC            mul a, b ; *
1852   0E12 11            mov a, b
1853   0E13 27            mov b, a
1854   0E14 E4            pop a
1855   0E15             ; END FACTORS
1856   0E15             ; START TERMS
1857   0E15 D7            push a
1858   0E16 11            mov a, b
1859   0E17 FA FC FF      lea d, [bp + -4] ; $hex_char
1860   0E1A 32            mov bl, [d]
1861   0E1B A7 00         mov bh, 0
1862   0E1D             ; START TERMS
1863   0E1D D7            push a
1864   0E1E 11            mov a, b
1865   0E1F 26 41 00      mov b, $41
1866   0E22 60            sub a, b
1867   0E23 27            mov b, a
1868   0E24 11            mov a, b
1869   0E25 26 0A 00      mov b, $a
1870   0E28 56            add b, a
1871   0E29 E4            pop a
1872   0E2A             ; END TERMS
1873   0E2A 56            add b, a
1874   0E2B E4            pop a
1875   0E2C             ; END TERMS
1876   0E2C E7            pop d
1877   0E2D FD 43         mov [d], b
1878   0E2F 0A 58 0E      jmp _if28_exit
1879   0E32             _if28_else:
1880   0E32             ;; value = (value * 16) + (hex_char - '0'); 
1881   0E32 FA FF FF      lea d, [bp + -1] ; $value
1882   0E35 DA            push d
1883   0E36 FA FF FF      lea d, [bp + -1] ; $value
1884   0E39 2A            mov b, [d]
1885   0E3A             ; START FACTORS
1886   0E3A D7            push a
1887   0E3B 11            mov a, b
1888   0E3C 26 10 00      mov b, $10
1889   0E3F AC            mul a, b ; *
1890   0E40 11            mov a, b
1891   0E41 27            mov b, a
1892   0E42 E4            pop a
1893   0E43             ; END FACTORS
1894   0E43             ; START TERMS
1895   0E43 D7            push a
1896   0E44 11            mov a, b
1897   0E45 FA FC FF      lea d, [bp + -4] ; $hex_char
1898   0E48 32            mov bl, [d]
1899   0E49 A7 00         mov bh, 0
1900   0E4B             ; START TERMS
1901   0E4B D7            push a
1902   0E4C 11            mov a, b
1903   0E4D 26 30 00      mov b, $30
1904   0E50 60            sub a, b
1905   0E51 27            mov b, a
1906   0E52 E4            pop a
1907   0E53             ; END TERMS
1908   0E53 56            add b, a
1909   0E54 E4            pop a
1910   0E55             ; END TERMS
1911   0E55 E7            pop d
1912   0E56 FD 43         mov [d], b
1913   0E58             _if28_exit:
1914   0E58             _if27_exit:
1915   0E58             _for26_update:
1916   0E58 FA FD FF      lea d, [bp + -3] ; $i
1917   0E5B 2A            mov b, [d]
1918   0E5C FD 77         inc b
1919   0E5E FA FD FF      lea d, [bp + -3] ; $i
1920   0E61 FD 43         mov [d], b
1921   0E63 FD 7D         dec b
1922   0E65 0A 55 0D      jmp _for26_cond
1923   0E68             _for26_exit:
1924   0E68             ;; return value; 
1925   0E68 FA FF FF      lea d, [bp + -1] ; $value
1926   0E6B 2A            mov b, [d]
1927   0E6C F9            leave
1928   0E6D 09            ret
1929   0E6E             
1930   0E6E             gets:
1931   0E6E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1932   0E71             
1933   0E71             ; --- BEGIN INLINE ASM BLOCK
1934   0E71 FA 05 00      lea d, [bp + 5] ; $s
1935   0E74 15            mov a, [d]
1936   0E75 3C            mov d, a
1937   0E76 07 25 17      call _gets
1938   0E79             ; --- END INLINE ASM BLOCK
1939   0E79             
1940   0E79             ;; return strlen(s); 
1941   0E79 FA 05 00      lea d, [bp + 5] ; $s
1942   0E7C 2A            mov b, [d]
1943   0E7D FD AB         swp b
1944   0E7F D8            push b
1945   0E80 07 07 06      call strlen
1946   0E83 51 02 00      add sp, 2
1947   0E86 F9            leave
1948   0E87 09            ret
1949   0E88             
1950   0E88             print_signed:
1951   0E88 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1952   0E8B             ;; char digits[5]; 
1953   0E8B 52 05 00      sub sp, 5 ; digits
1954   0E8E             ;; int i = 0; 
1955   0E8E 52 02 00      sub sp, 2 ; i
1956   0E91             ; --- START LOCAL VAR INITIALIZATION
1957   0E91 FA FA FF      lea d, [bp + -6] ; $i
1958   0E94 DA            push d
1959   0E95 26 00 00      mov b, $0
1960   0E98 E7            pop d
1961   0E99 FD 43         mov [d], b
1962   0E9B             ; --- END LOCAL VAR INITIALIZATION
1963   0E9B             ;; if (num < 0) { 
1964   0E9B             _if29_cond:
1965   0E9B FA 05 00      lea d, [bp + 5] ; $num
1966   0E9E 2A            mov b, [d]
1967   0E9F             ; START RELATIONAL
1968   0E9F D7            push a
1969   0EA0 11            mov a, b
1970   0EA1 26 00 00      mov b, $0
1971   0EA4 B0            cmp a, b
1972   0EA5 FD 73         slt ; < (signed)
1973   0EA7 E4            pop a
1974   0EA8             ; END RELATIONAL
1975   0EA8 C0 00 00      cmp b, 0
1976   0EAB C6 C8 0E      je _if29_else
1977   0EAE             _if29_true:
1978   0EAE             ;; putchar('-'); 
1979   0EAE 26 2D 00      mov b, $2d
1980   0EB1 DD            push bl
1981   0EB2 07 8D 15      call putchar
1982   0EB5 51 01 00      add sp, 1
1983   0EB8             ;; num = -num; 
1984   0EB8 FA 05 00      lea d, [bp + 5] ; $num
1985   0EBB DA            push d
1986   0EBC FA 05 00      lea d, [bp + 5] ; $num
1987   0EBF 2A            mov b, [d]
1988   0EC0 FD 97         neg b
1989   0EC2 E7            pop d
1990   0EC3 FD 43         mov [d], b
1991   0EC5 0A EA 0E      jmp _if29_exit
1992   0EC8             _if29_else:
1993   0EC8             ;; if (num == 0) { 
1994   0EC8             _if30_cond:
1995   0EC8 FA 05 00      lea d, [bp + 5] ; $num
1996   0ECB 2A            mov b, [d]
1997   0ECC             ; START RELATIONAL
1998   0ECC D7            push a
1999   0ECD 11            mov a, b
2000   0ECE 26 00 00      mov b, $0
2001   0ED1 B0            cmp a, b
2002   0ED2 FD 71         seq ; ==
2003   0ED4 E4            pop a
2004   0ED5             ; END RELATIONAL
2005   0ED5 C0 00 00      cmp b, 0
2006   0ED8 C6 EA 0E      je _if30_exit
2007   0EDB             _if30_true:
2008   0EDB             ;; putchar('0'); 
2009   0EDB 26 30 00      mov b, $30
2010   0EDE DD            push bl
2011   0EDF 07 8D 15      call putchar
2012   0EE2 51 01 00      add sp, 1
2013   0EE5             ;; return; 
2014   0EE5 F9            leave
2015   0EE6 09            ret
2016   0EE7 0A EA 0E      jmp _if30_exit
2017   0EEA             _if30_exit:
2018   0EEA             _if29_exit:
2019   0EEA             ;; while (num > 0) { 
2020   0EEA             _while31_cond:
2021   0EEA FA 05 00      lea d, [bp + 5] ; $num
2022   0EED 2A            mov b, [d]
2023   0EEE             ; START RELATIONAL
2024   0EEE D7            push a
2025   0EEF 11            mov a, b
2026   0EF0 26 00 00      mov b, $0
2027   0EF3 B0            cmp a, b
2028   0EF4 FD 7F         sgt ; >
2029   0EF6 E4            pop a
2030   0EF7             ; END RELATIONAL
2031   0EF7 C0 00 00      cmp b, 0
2032   0EFA C6 44 0F      je _while31_exit
2033   0EFD             _while31_block:
2034   0EFD             ;; digits[i] = '0' + (num % 10); 
2035   0EFD FA FC FF      lea d, [bp + -4] ; $digits
2036   0F00 D7            push a
2037   0F01 DA            push d
2038   0F02 FA FA FF      lea d, [bp + -6] ; $i
2039   0F05 2A            mov b, [d]
2040   0F06 E7            pop d
2041   0F07 5A            add d, b
2042   0F08 E4            pop a
2043   0F09 DA            push d
2044   0F0A 26 30 00      mov b, $30
2045   0F0D             ; START TERMS
2046   0F0D D7            push a
2047   0F0E 11            mov a, b
2048   0F0F FA 05 00      lea d, [bp + 5] ; $num
2049   0F12 2A            mov b, [d]
2050   0F13             ; START FACTORS
2051   0F13 D7            push a
2052   0F14 11            mov a, b
2053   0F15 26 0A 00      mov b, $a
2054   0F18 AE            div a, b ; 
2055   0F19 11            mov a, b
2056   0F1A 27            mov b, a
2057   0F1B E4            pop a
2058   0F1C             ; END FACTORS
2059   0F1C 56            add b, a
2060   0F1D E4            pop a
2061   0F1E             ; END TERMS
2062   0F1E E7            pop d
2063   0F1F FD 3E         mov [d], bl
2064   0F21             ;; num = num / 10; 
2065   0F21 FA 05 00      lea d, [bp + 5] ; $num
2066   0F24 DA            push d
2067   0F25 FA 05 00      lea d, [bp + 5] ; $num
2068   0F28 2A            mov b, [d]
2069   0F29             ; START FACTORS
2070   0F29 D7            push a
2071   0F2A 11            mov a, b
2072   0F2B 26 0A 00      mov b, $a
2073   0F2E AE            div a, b
2074   0F2F 27            mov b, a
2075   0F30 E4            pop a
2076   0F31             ; END FACTORS
2077   0F31 E7            pop d
2078   0F32 FD 43         mov [d], b
2079   0F34             ;; i++; 
2080   0F34 FA FA FF      lea d, [bp + -6] ; $i
2081   0F37 2A            mov b, [d]
2082   0F38 FD 77         inc b
2083   0F3A FA FA FF      lea d, [bp + -6] ; $i
2084   0F3D FD 43         mov [d], b
2085   0F3F FD 7D         dec b
2086   0F41 0A EA 0E      jmp _while31_cond
2087   0F44             _while31_exit:
2088   0F44             ;; while (i > 0) { 
2089   0F44             _while32_cond:
2090   0F44 FA FA FF      lea d, [bp + -6] ; $i
2091   0F47 2A            mov b, [d]
2092   0F48             ; START RELATIONAL
2093   0F48 D7            push a
2094   0F49 11            mov a, b
2095   0F4A 26 00 00      mov b, $0
2096   0F4D B0            cmp a, b
2097   0F4E FD 7F         sgt ; >
2098   0F50 E4            pop a
2099   0F51             ; END RELATIONAL
2100   0F51 C0 00 00      cmp b, 0
2101   0F54 C6 7D 0F      je _while32_exit
2102   0F57             _while32_block:
2103   0F57             ;; i--; 
2104   0F57 FA FA FF      lea d, [bp + -6] ; $i
2105   0F5A 2A            mov b, [d]
2106   0F5B FD 7D         dec b
2107   0F5D FA FA FF      lea d, [bp + -6] ; $i
2108   0F60 FD 43         mov [d], b
2109   0F62 FD 77         inc b
2110   0F64             ;; putchar(digits[i]); 
2111   0F64 FA FC FF      lea d, [bp + -4] ; $digits
2112   0F67 D7            push a
2113   0F68 DA            push d
2114   0F69 FA FA FF      lea d, [bp + -6] ; $i
2115   0F6C 2A            mov b, [d]
2116   0F6D E7            pop d
2117   0F6E 5A            add d, b
2118   0F6F E4            pop a
2119   0F70 32            mov bl, [d]
2120   0F71 A7 00         mov bh, 0
2121   0F73 DD            push bl
2122   0F74 07 8D 15      call putchar
2123   0F77 51 01 00      add sp, 1
2124   0F7A 0A 44 0F      jmp _while32_cond
2125   0F7D             _while32_exit:
2126   0F7D F9            leave
2127   0F7E 09            ret
2128   0F7F             
2129   0F7F             print_signed_long:
2130   0F7F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2131   0F82             ;; char digits[10]; 
2132   0F82 52 0A 00      sub sp, 10 ; digits
2133   0F85             ;; int i = 0; 
2134   0F85 52 02 00      sub sp, 2 ; i
2135   0F88             ; --- START LOCAL VAR INITIALIZATION
2136   0F88 FA F5 FF      lea d, [bp + -11] ; $i
2137   0F8B DA            push d
2138   0F8C 26 00 00      mov b, $0
2139   0F8F E7            pop d
2140   0F90 FD 43         mov [d], b
2141   0F92             ; --- END LOCAL VAR INITIALIZATION
2142   0F92             ;; if (num < 0) { 
2143   0F92             _if33_cond:
2144   0F92 FA 05 00      lea d, [bp + 5] ; $num
2145   0F95 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2146   0F98 FD 39         mov c, b ; And place it into C
2147   0F9A 2A            mov b, [d] ; Lower Word in B
2148   0F9B             ; START RELATIONAL
2149   0F9B D7            push a
2150   0F9C FD D8         push g
2151   0F9E 11            mov a, b
2152   0F9F FD 7A         mov g, c
2153   0FA1 26 00 00      mov b, $0
2154   0FA4 38 00 00      mov c, 0
2155   0FA7 FD AF 00 00   cmp32 ga, cb
2155   0FAB 00 00 00 00 
2155   0FAF 00 00 00 00 
2155   0FB3 00 00 00 00 
2155   0FB7 00 00 00 00 
2155   0FBB 00 00 00 00 
2155   0FBF 00 00 00 00 
2155   0FC3 00 00 00 00 
2155   0FC7 00 00 00 00 
2155   0FCB 00 00 00 00 
2155   0FCF 00 00 00 00 
2155   0FD3 00 00 00 00 
2155   0FD7 00 00 00 00 
2155   0FDB 00 00 00 00 
2155   0FDF 00 00 00 00 
2155   0FE3 00 00 00 00 
2155   0FE7 00 00 00 00 
2155   0FEB 00 00 00 00 
2155   0FEF 00 00 00 00 
2155   0FF3 00 00 00 00 
2155   0FF7 00 00 00 00 
2155   0FFB 00 00 00 00 
2155   0FFF 00 00 00 00 
2155   1003 00 00 00 00 
2155   1007 00 00 00 00 
2155   100B 00 00 00 00 
2155   100F 00 00 00 00 
2155   1013 00 00 00 00 
2155   1017 00 00 00 00 
2155   101B 00 00 00 00 
2155   101F 00 00 00 00 
2155   1023 00 00 00 00 
2155   1027 00 00 00 00 
2155   102B 00 00 00 00 
2155   102F 00 00 00 00 
2155   1033 00 00 00 00 
2155   1037 00 00 00 00 
2155   103B 00 00 00 00 
2155   103F 00 00 00 00 
2155   1043 00 00 00 00 
2155   1047 00 00 00 00 
2155   104B 00 00 00 00 
2155   104F 00 00 00 00 
2155   1053 00 00 00 00 
2155   1057 00 00 00 00 
2155   105B 00 00 00 00 
2155   105F 00 00 00 00 
2155   1063 00 00 00 00 
2155   1067 00 00 00 00 
2155   106B 00 00 00 00 
2155   106F 00 00 00 00 
2155   1073 00 00 00 00 
2155   1077 00 00 00 00 
2155   107B 00 00 00 00 
2155   107F 00 00 00 00 
2155   1083 00 00 00 00 
2155   1087 00 00 00 00 
2155   108B 00 00 00 00 
2155   108F 00 00 00 00 
2155   1093 00 00 00 00 
2155   1097 00 00 00 00 
2155   109B 00 00 00 00 
2155   109F 00 00 00 00 
2155   10A3 00 00 00 00 
2155   10A7 00 
2156   10A8 FD 73         slt ; <
2157   10AA FD F1         pop g
2158   10AC E4            pop a
2159   10AD             ; END RELATIONAL
2160   10AD C0 00 00      cmp b, 0
2161   10B0 C6 D7 10      je _if33_else
2162   10B3             _if33_true:
2163   10B3             ;; putchar('-'); 
2164   10B3 26 2D 00      mov b, $2d
2165   10B6 DD            push bl
2166   10B7 07 8D 15      call putchar
2167   10BA 51 01 00      add sp, 1
2168   10BD             ;; num = -num; 
2169   10BD FA 05 00      lea d, [bp + 5] ; $num
2170   10C0 DA            push d
2171   10C1 FA 05 00      lea d, [bp + 5] ; $num
2172   10C4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2173   10C7 FD 39         mov c, b ; And place it into C
2174   10C9 2A            mov b, [d] ; Lower Word in B
2175   10CA FD 97         neg b
2176   10CC E7            pop d
2177   10CD FD 43         mov [d], b
2178   10CF 28            mov b, c
2179   10D0 FD 44 02 00   mov [d + 2], b
2180   10D4 0A 07 12      jmp _if33_exit
2181   10D7             _if33_else:
2182   10D7             ;; if (num == 0) { 
2183   10D7             _if34_cond:
2184   10D7 FA 05 00      lea d, [bp + 5] ; $num
2185   10DA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2186   10DD FD 39         mov c, b ; And place it into C
2187   10DF 2A            mov b, [d] ; Lower Word in B
2188   10E0             ; START RELATIONAL
2189   10E0 D7            push a
2190   10E1 FD D8         push g
2191   10E3 11            mov a, b
2192   10E4 FD 7A         mov g, c
2193   10E6 26 00 00      mov b, $0
2194   10E9 38 00 00      mov c, 0
2195   10EC FD AF 00 00   cmp32 ga, cb
2195   10F0 00 00 00 00 
2195   10F4 00 00 00 00 
2195   10F8 00 00 00 00 
2195   10FC 00 00 00 00 
2195   1100 00 00 00 00 
2195   1104 00 00 00 00 
2195   1108 00 00 00 00 
2195   110C 00 00 00 00 
2195   1110 00 00 00 00 
2195   1114 00 00 00 00 
2195   1118 00 00 00 00 
2195   111C 00 00 00 00 
2195   1120 00 00 00 00 
2195   1124 00 00 00 00 
2195   1128 00 00 00 00 
2195   112C 00 00 00 00 
2195   1130 00 00 00 00 
2195   1134 00 00 00 00 
2195   1138 00 00 00 00 
2195   113C 00 00 00 00 
2195   1140 00 00 00 00 
2195   1144 00 00 00 00 
2195   1148 00 00 00 00 
2195   114C 00 00 00 00 
2195   1150 00 00 00 00 
2195   1154 00 00 00 00 
2195   1158 00 00 00 00 
2195   115C 00 00 00 00 
2195   1160 00 00 00 00 
2195   1164 00 00 00 00 
2195   1168 00 00 00 00 
2195   116C 00 00 00 00 
2195   1170 00 00 00 00 
2195   1174 00 00 00 00 
2195   1178 00 00 00 00 
2195   117C 00 00 00 00 
2195   1180 00 00 00 00 
2195   1184 00 00 00 00 
2195   1188 00 00 00 00 
2195   118C 00 00 00 00 
2195   1190 00 00 00 00 
2195   1194 00 00 00 00 
2195   1198 00 00 00 00 
2195   119C 00 00 00 00 
2195   11A0 00 00 00 00 
2195   11A4 00 00 00 00 
2195   11A8 00 00 00 00 
2195   11AC 00 00 00 00 
2195   11B0 00 00 00 00 
2195   11B4 00 00 00 00 
2195   11B8 00 00 00 00 
2195   11BC 00 00 00 00 
2195   11C0 00 00 00 00 
2195   11C4 00 00 00 00 
2195   11C8 00 00 00 00 
2195   11CC 00 00 00 00 
2195   11D0 00 00 00 00 
2195   11D4 00 00 00 00 
2195   11D8 00 00 00 00 
2195   11DC 00 00 00 00 
2195   11E0 00 00 00 00 
2195   11E4 00 00 00 00 
2195   11E8 00 00 00 00 
2195   11EC 00 
2196   11ED FD 71         seq ; ==
2197   11EF FD F1         pop g
2198   11F1 E4            pop a
2199   11F2             ; END RELATIONAL
2200   11F2 C0 00 00      cmp b, 0
2201   11F5 C6 07 12      je _if34_exit
2202   11F8             _if34_true:
2203   11F8             ;; putchar('0'); 
2204   11F8 26 30 00      mov b, $30
2205   11FB DD            push bl
2206   11FC 07 8D 15      call putchar
2207   11FF 51 01 00      add sp, 1
2208   1202             ;; return; 
2209   1202 F9            leave
2210   1203 09            ret
2211   1204 0A 07 12      jmp _if34_exit
2212   1207             _if34_exit:
2213   1207             _if33_exit:
2214   1207             ;; while (num > 0) { 
2215   1207             _while35_cond:
2216   1207 FA 05 00      lea d, [bp + 5] ; $num
2217   120A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2218   120D FD 39         mov c, b ; And place it into C
2219   120F 2A            mov b, [d] ; Lower Word in B
2220   1210             ; START RELATIONAL
2221   1210 D7            push a
2222   1211 FD D8         push g
2223   1213 11            mov a, b
2224   1214 FD 7A         mov g, c
2225   1216 26 00 00      mov b, $0
2226   1219 38 00 00      mov c, 0
2227   121C FD 7F         sgt
2228   121E FD F1         pop g
2229   1220 E4            pop a
2230   1221             ; END RELATIONAL
2231   1221 C0 00 00      cmp b, 0
2232   1224 C6 84 12      je _while35_exit
2233   1227             _while35_block:
2234   1227             ;; digits[i] = '0' + (num % 10); 
2235   1227 FA F7 FF      lea d, [bp + -9] ; $digits
2236   122A D7            push a
2237   122B DA            push d
2238   122C FA F5 FF      lea d, [bp + -11] ; $i
2239   122F 2A            mov b, [d]
2240   1230 E7            pop d
2241   1231 5A            add d, b
2242   1232 E4            pop a
2243   1233 DA            push d
2244   1234 26 30 00      mov b, $30
2245   1237             ; START TERMS
2246   1237 D7            push a
2247   1238 11            mov a, b
2248   1239 FA 05 00      lea d, [bp + 5] ; $num
2249   123C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2250   123F FD 39         mov c, b ; And place it into C
2251   1241 2A            mov b, [d] ; Lower Word in B
2252   1242             ; START FACTORS
2253   1242 D7            push a
2254   1243 11            mov a, b
2255   1244 26 0A 00      mov b, $a
2256   1247 AE            div a, b ; 
2257   1248 11            mov a, b
2258   1249 27            mov b, a
2259   124A E4            pop a
2260   124B             ; END FACTORS
2261   124B 54            add a, b
2262   124C D7            push a
2263   124D FD 12         mov a, g
2264   124F 28            mov b, c
2265   1250 5C            adc a, b
2266   1251 39            mov c, a
2267   1252 E5            pop b
2268   1253 E4            pop a
2269   1254             ; END TERMS
2270   1254 E7            pop d
2271   1255 FD 3E         mov [d], bl
2272   1257             ;; num = num / 10; 
2273   1257 FA 05 00      lea d, [bp + 5] ; $num
2274   125A DA            push d
2275   125B FA 05 00      lea d, [bp + 5] ; $num
2276   125E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2277   1261 FD 39         mov c, b ; And place it into C
2278   1263 2A            mov b, [d] ; Lower Word in B
2279   1264             ; START FACTORS
2280   1264 D7            push a
2281   1265 11            mov a, b
2282   1266 26 0A 00      mov b, $a
2283   1269 AE            div a, b
2284   126A 27            mov b, a
2285   126B E4            pop a
2286   126C             ; END FACTORS
2287   126C E7            pop d
2288   126D FD 43         mov [d], b
2289   126F 28            mov b, c
2290   1270 FD 44 02 00   mov [d + 2], b
2291   1274             ;; i++; 
2292   1274 FA F5 FF      lea d, [bp + -11] ; $i
2293   1277 2A            mov b, [d]
2294   1278 FD 77         inc b
2295   127A FA F5 FF      lea d, [bp + -11] ; $i
2296   127D FD 43         mov [d], b
2297   127F FD 7D         dec b
2298   1281 0A 07 12      jmp _while35_cond
2299   1284             _while35_exit:
2300   1284             ;; while (i > 0) { 
2301   1284             _while36_cond:
2302   1284 FA F5 FF      lea d, [bp + -11] ; $i
2303   1287 2A            mov b, [d]
2304   1288             ; START RELATIONAL
2305   1288 D7            push a
2306   1289 11            mov a, b
2307   128A 26 00 00      mov b, $0
2308   128D B0            cmp a, b
2309   128E FD 7F         sgt ; >
2310   1290 E4            pop a
2311   1291             ; END RELATIONAL
2312   1291 C0 00 00      cmp b, 0
2313   1294 C6 BD 12      je _while36_exit
2314   1297             _while36_block:
2315   1297             ;; i--; 
2316   1297 FA F5 FF      lea d, [bp + -11] ; $i
2317   129A 2A            mov b, [d]
2318   129B FD 7D         dec b
2319   129D FA F5 FF      lea d, [bp + -11] ; $i
2320   12A0 FD 43         mov [d], b
2321   12A2 FD 77         inc b
2322   12A4             ;; putchar(digits[i]); 
2323   12A4 FA F7 FF      lea d, [bp + -9] ; $digits
2324   12A7 D7            push a
2325   12A8 DA            push d
2326   12A9 FA F5 FF      lea d, [bp + -11] ; $i
2327   12AC 2A            mov b, [d]
2328   12AD E7            pop d
2329   12AE 5A            add d, b
2330   12AF E4            pop a
2331   12B0 32            mov bl, [d]
2332   12B1 A7 00         mov bh, 0
2333   12B3 DD            push bl
2334   12B4 07 8D 15      call putchar
2335   12B7 51 01 00      add sp, 1
2336   12BA 0A 84 12      jmp _while36_cond
2337   12BD             _while36_exit:
2338   12BD F9            leave
2339   12BE 09            ret
2340   12BF             
2341   12BF             print_unsigned_long:
2342   12BF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2343   12C2             ;; char digits[10]; 
2344   12C2 52 0A 00      sub sp, 10 ; digits
2345   12C5             ;; int i; 
2346   12C5 52 02 00      sub sp, 2 ; i
2347   12C8             ;; i = 0; 
2348   12C8 FA F5 FF      lea d, [bp + -11] ; $i
2349   12CB DA            push d
2350   12CC 26 00 00      mov b, $0
2351   12CF E7            pop d
2352   12D0 FD 43         mov [d], b
2353   12D2             ;; if(num == 0){ 
2354   12D2             _if37_cond:
2355   12D2 FA 05 00      lea d, [bp + 5] ; $num
2356   12D5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2357   12D8 FD 39         mov c, b ; And place it into C
2358   12DA 2A            mov b, [d] ; Lower Word in B
2359   12DB             ; START RELATIONAL
2360   12DB D7            push a
2361   12DC FD D8         push g
2362   12DE 11            mov a, b
2363   12DF FD 7A         mov g, c
2364   12E1 26 00 00      mov b, $0
2365   12E4 38 00 00      mov c, 0
2366   12E7 FD AF 00 00   cmp32 ga, cb
2366   12EB 00 00 00 00 
2366   12EF 00 00 00 00 
2366   12F3 00 00 00 00 
2366   12F7 00 00 00 00 
2366   12FB 00 00 00 00 
2366   12FF 00 00 00 00 
2366   1303 00 00 00 00 
2366   1307 00 00 00 00 
2366   130B 00 00 00 00 
2366   130F 00 00 00 00 
2366   1313 00 00 00 00 
2366   1317 00 00 00 00 
2366   131B 00 00 00 00 
2366   131F 00 00 00 00 
2366   1323 00 00 00 00 
2366   1327 00 00 00 00 
2366   132B 00 00 00 00 
2366   132F 00 00 00 00 
2366   1333 00 00 00 00 
2366   1337 00 00 00 00 
2366   133B 00 00 00 00 
2366   133F 00 00 00 00 
2366   1343 00 00 00 00 
2366   1347 00 00 00 00 
2366   134B 00 00 00 00 
2366   134F 00 00 00 00 
2366   1353 00 00 00 00 
2366   1357 00 00 00 00 
2366   135B 00 00 00 00 
2366   135F 00 00 00 00 
2366   1363 00 00 00 00 
2366   1367 00 00 00 00 
2366   136B 00 00 00 00 
2366   136F 00 00 00 00 
2366   1373 00 00 00 00 
2366   1377 00 00 00 00 
2366   137B 00 00 00 00 
2366   137F 00 00 00 00 
2366   1383 00 00 00 00 
2366   1387 00 00 00 00 
2366   138B 00 00 00 00 
2366   138F 00 00 00 00 
2366   1393 00 00 00 00 
2366   1397 00 00 00 00 
2366   139B 00 00 00 00 
2366   139F 00 00 00 00 
2366   13A3 00 00 00 00 
2366   13A7 00 00 00 00 
2366   13AB 00 00 00 00 
2366   13AF 00 00 00 00 
2366   13B3 00 00 00 00 
2366   13B7 00 00 00 00 
2366   13BB 00 00 00 00 
2366   13BF 00 00 00 00 
2366   13C3 00 00 00 00 
2366   13C7 00 00 00 00 
2366   13CB 00 00 00 00 
2366   13CF 00 00 00 00 
2366   13D3 00 00 00 00 
2366   13D7 00 00 00 00 
2366   13DB 00 00 00 00 
2366   13DF 00 00 00 00 
2366   13E3 00 00 00 00 
2366   13E7 00 
2367   13E8 FD 71         seq ; ==
2368   13EA FD F1         pop g
2369   13EC E4            pop a
2370   13ED             ; END RELATIONAL
2371   13ED C0 00 00      cmp b, 0
2372   13F0 C6 02 14      je _if37_exit
2373   13F3             _if37_true:
2374   13F3             ;; putchar('0'); 
2375   13F3 26 30 00      mov b, $30
2376   13F6 DD            push bl
2377   13F7 07 8D 15      call putchar
2378   13FA 51 01 00      add sp, 1
2379   13FD             ;; return; 
2380   13FD F9            leave
2381   13FE 09            ret
2382   13FF 0A 02 14      jmp _if37_exit
2383   1402             _if37_exit:
2384   1402             ;; while (num > 0) { 
2385   1402             _while38_cond:
2386   1402 FA 05 00      lea d, [bp + 5] ; $num
2387   1405 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2388   1408 FD 39         mov c, b ; And place it into C
2389   140A 2A            mov b, [d] ; Lower Word in B
2390   140B             ; START RELATIONAL
2391   140B D7            push a
2392   140C FD D8         push g
2393   140E 11            mov a, b
2394   140F FD 7A         mov g, c
2395   1411 26 00 00      mov b, $0
2396   1414 38 00 00      mov c, 0
2397   1417 FD 81         sgu
2398   1419 FD F1         pop g
2399   141B E4            pop a
2400   141C             ; END RELATIONAL
2401   141C C0 00 00      cmp b, 0
2402   141F C6 7F 14      je _while38_exit
2403   1422             _while38_block:
2404   1422             ;; digits[i] = '0' + (num % 10); 
2405   1422 FA F7 FF      lea d, [bp + -9] ; $digits
2406   1425 D7            push a
2407   1426 DA            push d
2408   1427 FA F5 FF      lea d, [bp + -11] ; $i
2409   142A 2A            mov b, [d]
2410   142B E7            pop d
2411   142C 5A            add d, b
2412   142D E4            pop a
2413   142E DA            push d
2414   142F 26 30 00      mov b, $30
2415   1432             ; START TERMS
2416   1432 D7            push a
2417   1433 11            mov a, b
2418   1434 FA 05 00      lea d, [bp + 5] ; $num
2419   1437 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2420   143A FD 39         mov c, b ; And place it into C
2421   143C 2A            mov b, [d] ; Lower Word in B
2422   143D             ; START FACTORS
2423   143D D7            push a
2424   143E 11            mov a, b
2425   143F 26 0A 00      mov b, $a
2426   1442 AE            div a, b ; 
2427   1443 11            mov a, b
2428   1444 27            mov b, a
2429   1445 E4            pop a
2430   1446             ; END FACTORS
2431   1446 54            add a, b
2432   1447 D7            push a
2433   1448 FD 12         mov a, g
2434   144A 28            mov b, c
2435   144B 5C            adc a, b
2436   144C 39            mov c, a
2437   144D E5            pop b
2438   144E E4            pop a
2439   144F             ; END TERMS
2440   144F E7            pop d
2441   1450 FD 3E         mov [d], bl
2442   1452             ;; num = num / 10; 
2443   1452 FA 05 00      lea d, [bp + 5] ; $num
2444   1455 DA            push d
2445   1456 FA 05 00      lea d, [bp + 5] ; $num
2446   1459 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2447   145C FD 39         mov c, b ; And place it into C
2448   145E 2A            mov b, [d] ; Lower Word in B
2449   145F             ; START FACTORS
2450   145F D7            push a
2451   1460 11            mov a, b
2452   1461 26 0A 00      mov b, $a
2453   1464 AE            div a, b
2454   1465 27            mov b, a
2455   1466 E4            pop a
2456   1467             ; END FACTORS
2457   1467 E7            pop d
2458   1468 FD 43         mov [d], b
2459   146A 28            mov b, c
2460   146B FD 44 02 00   mov [d + 2], b
2461   146F             ;; i++; 
2462   146F FA F5 FF      lea d, [bp + -11] ; $i
2463   1472 2A            mov b, [d]
2464   1473 FD 77         inc b
2465   1475 FA F5 FF      lea d, [bp + -11] ; $i
2466   1478 FD 43         mov [d], b
2467   147A FD 7D         dec b
2468   147C 0A 02 14      jmp _while38_cond
2469   147F             _while38_exit:
2470   147F             ;; while (i > 0) { 
2471   147F             _while39_cond:
2472   147F FA F5 FF      lea d, [bp + -11] ; $i
2473   1482 2A            mov b, [d]
2474   1483             ; START RELATIONAL
2475   1483 D7            push a
2476   1484 11            mov a, b
2477   1485 26 00 00      mov b, $0
2478   1488 B0            cmp a, b
2479   1489 FD 7F         sgt ; >
2480   148B E4            pop a
2481   148C             ; END RELATIONAL
2482   148C C0 00 00      cmp b, 0
2483   148F C6 B8 14      je _while39_exit
2484   1492             _while39_block:
2485   1492             ;; i--; 
2486   1492 FA F5 FF      lea d, [bp + -11] ; $i
2487   1495 2A            mov b, [d]
2488   1496 FD 7D         dec b
2489   1498 FA F5 FF      lea d, [bp + -11] ; $i
2490   149B FD 43         mov [d], b
2491   149D FD 77         inc b
2492   149F             ;; putchar(digits[i]); 
2493   149F FA F7 FF      lea d, [bp + -9] ; $digits
2494   14A2 D7            push a
2495   14A3 DA            push d
2496   14A4 FA F5 FF      lea d, [bp + -11] ; $i
2497   14A7 2A            mov b, [d]
2498   14A8 E7            pop d
2499   14A9 5A            add d, b
2500   14AA E4            pop a
2501   14AB 32            mov bl, [d]
2502   14AC A7 00         mov bh, 0
2503   14AE DD            push bl
2504   14AF 07 8D 15      call putchar
2505   14B2 51 01 00      add sp, 1
2506   14B5 0A 7F 14      jmp _while39_cond
2507   14B8             _while39_exit:
2508   14B8 F9            leave
2509   14B9 09            ret
2510   14BA             
2511   14BA             print_unsigned:
2512   14BA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2513   14BD             ;; char digits[5]; 
2514   14BD 52 05 00      sub sp, 5 ; digits
2515   14C0             ;; int i; 
2516   14C0 52 02 00      sub sp, 2 ; i
2517   14C3             ;; i = 0; 
2518   14C3 FA FA FF      lea d, [bp + -6] ; $i
2519   14C6 DA            push d
2520   14C7 26 00 00      mov b, $0
2521   14CA E7            pop d
2522   14CB FD 43         mov [d], b
2523   14CD             ;; if(num == 0){ 
2524   14CD             _if40_cond:
2525   14CD FA 05 00      lea d, [bp + 5] ; $num
2526   14D0 2A            mov b, [d]
2527   14D1             ; START RELATIONAL
2528   14D1 D7            push a
2529   14D2 11            mov a, b
2530   14D3 26 00 00      mov b, $0
2531   14D6 B0            cmp a, b
2532   14D7 FD 71         seq ; ==
2533   14D9 E4            pop a
2534   14DA             ; END RELATIONAL
2535   14DA C0 00 00      cmp b, 0
2536   14DD C6 EF 14      je _if40_exit
2537   14E0             _if40_true:
2538   14E0             ;; putchar('0'); 
2539   14E0 26 30 00      mov b, $30
2540   14E3 DD            push bl
2541   14E4 07 8D 15      call putchar
2542   14E7 51 01 00      add sp, 1
2543   14EA             ;; return; 
2544   14EA F9            leave
2545   14EB 09            ret
2546   14EC 0A EF 14      jmp _if40_exit
2547   14EF             _if40_exit:
2548   14EF             ;; while (num > 0) { 
2549   14EF             _while41_cond:
2550   14EF FA 05 00      lea d, [bp + 5] ; $num
2551   14F2 2A            mov b, [d]
2552   14F3             ; START RELATIONAL
2553   14F3 D7            push a
2554   14F4 11            mov a, b
2555   14F5 26 00 00      mov b, $0
2556   14F8 B0            cmp a, b
2557   14F9 FD 81         sgu ; > (unsigned)
2558   14FB E4            pop a
2559   14FC             ; END RELATIONAL
2560   14FC C0 00 00      cmp b, 0
2561   14FF C6 49 15      je _while41_exit
2562   1502             _while41_block:
2563   1502             ;; digits[i] = '0' + (num % 10); 
2564   1502 FA FC FF      lea d, [bp + -4] ; $digits
2565   1505 D7            push a
2566   1506 DA            push d
2567   1507 FA FA FF      lea d, [bp + -6] ; $i
2568   150A 2A            mov b, [d]
2569   150B E7            pop d
2570   150C 5A            add d, b
2571   150D E4            pop a
2572   150E DA            push d
2573   150F 26 30 00      mov b, $30
2574   1512             ; START TERMS
2575   1512 D7            push a
2576   1513 11            mov a, b
2577   1514 FA 05 00      lea d, [bp + 5] ; $num
2578   1517 2A            mov b, [d]
2579   1518             ; START FACTORS
2580   1518 D7            push a
2581   1519 11            mov a, b
2582   151A 26 0A 00      mov b, $a
2583   151D AE            div a, b ; 
2584   151E 11            mov a, b
2585   151F 27            mov b, a
2586   1520 E4            pop a
2587   1521             ; END FACTORS
2588   1521 56            add b, a
2589   1522 E4            pop a
2590   1523             ; END TERMS
2591   1523 E7            pop d
2592   1524 FD 3E         mov [d], bl
2593   1526             ;; num = num / 10; 
2594   1526 FA 05 00      lea d, [bp + 5] ; $num
2595   1529 DA            push d
2596   152A FA 05 00      lea d, [bp + 5] ; $num
2597   152D 2A            mov b, [d]
2598   152E             ; START FACTORS
2599   152E D7            push a
2600   152F 11            mov a, b
2601   1530 26 0A 00      mov b, $a
2602   1533 AE            div a, b
2603   1534 27            mov b, a
2604   1535 E4            pop a
2605   1536             ; END FACTORS
2606   1536 E7            pop d
2607   1537 FD 43         mov [d], b
2608   1539             ;; i++; 
2609   1539 FA FA FF      lea d, [bp + -6] ; $i
2610   153C 2A            mov b, [d]
2611   153D FD 77         inc b
2612   153F FA FA FF      lea d, [bp + -6] ; $i
2613   1542 FD 43         mov [d], b
2614   1544 FD 7D         dec b
2615   1546 0A EF 14      jmp _while41_cond
2616   1549             _while41_exit:
2617   1549             ;; while (i > 0) { 
2618   1549             _while42_cond:
2619   1549 FA FA FF      lea d, [bp + -6] ; $i
2620   154C 2A            mov b, [d]
2621   154D             ; START RELATIONAL
2622   154D D7            push a
2623   154E 11            mov a, b
2624   154F 26 00 00      mov b, $0
2625   1552 B0            cmp a, b
2626   1553 FD 7F         sgt ; >
2627   1555 E4            pop a
2628   1556             ; END RELATIONAL
2629   1556 C0 00 00      cmp b, 0
2630   1559 C6 82 15      je _while42_exit
2631   155C             _while42_block:
2632   155C             ;; i--; 
2633   155C FA FA FF      lea d, [bp + -6] ; $i
2634   155F 2A            mov b, [d]
2635   1560 FD 7D         dec b
2636   1562 FA FA FF      lea d, [bp + -6] ; $i
2637   1565 FD 43         mov [d], b
2638   1567 FD 77         inc b
2639   1569             ;; putchar(digits[i]); 
2640   1569 FA FC FF      lea d, [bp + -4] ; $digits
2641   156C D7            push a
2642   156D DA            push d
2643   156E FA FA FF      lea d, [bp + -6] ; $i
2644   1571 2A            mov b, [d]
2645   1572 E7            pop d
2646   1573 5A            add d, b
2647   1574 E4            pop a
2648   1575 32            mov bl, [d]
2649   1576 A7 00         mov bh, 0
2650   1578 DD            push bl
2651   1579 07 8D 15      call putchar
2652   157C 51 01 00      add sp, 1
2653   157F 0A 49 15      jmp _while42_cond
2654   1582             _while42_exit:
2655   1582 F9            leave
2656   1583 09            ret
2657   1584             
2658   1584             date:
2659   1584 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2660   1587             
2661   1587             ; --- BEGIN INLINE ASM BLOCK
2662   1587 19 00         mov al, 0 
2663   1589 05 07         syscall sys_datetime
2664   158B             ; --- END INLINE ASM BLOCK
2665   158B             
2666   158B F9            leave
2667   158C 09            ret
2668   158D             
2669   158D             putchar:
2670   158D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2671   1590             
2672   1590             ; --- BEGIN INLINE ASM BLOCK
2673   1590 FA 05 00      lea d, [bp + 5] ; $c
2674   1593 1E            mov al, [d]
2675   1594 23            mov ah, al
2676   1595 07 1E 17      call _putchar
2677   1598             ; --- END INLINE ASM BLOCK
2678   1598             
2679   1598 F9            leave
2680   1599 09            ret
2681   159A             
2682   159A             getchar:
2683   159A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2684   159D             ;; char c; 
2685   159D 52 01 00      sub sp, 1 ; c
2686   15A0             
2687   15A0             ; --- BEGIN INLINE ASM BLOCK
2688   15A0 07 17 17      call getch
2689   15A3 1A            mov al, ah
2690   15A4 FA 00 00      lea d, [bp + 0] ; $c
2691   15A7 3E            mov [d], al
2692   15A8             ; --- END INLINE ASM BLOCK
2693   15A8             
2694   15A8             ;; return c; 
2695   15A8 FA 00 00      lea d, [bp + 0] ; $c
2696   15AB 32            mov bl, [d]
2697   15AC A7 00         mov bh, 0
2698   15AE F9            leave
2699   15AF 09            ret
2700   15B0             
2701   15B0             scann:
2702   15B0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2703   15B3             ;; int m; 
2704   15B3 52 02 00      sub sp, 2 ; m
2705   15B6             
2706   15B6             ; --- BEGIN INLINE ASM BLOCK
2707   15B6 07 62 19      call scan_u16d
2708   15B9 FA FF FF      lea d, [bp + -1] ; $m
2709   15BC 43            mov [d], a
2710   15BD             ; --- END INLINE ASM BLOCK
2711   15BD             
2712   15BD             ;; return m; 
2713   15BD FA FF FF      lea d, [bp + -1] ; $m
2714   15C0 2A            mov b, [d]
2715   15C1 F9            leave
2716   15C2 09            ret
2717   15C3             
2718   15C3             puts:
2719   15C3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2720   15C6             
2721   15C6             ; --- BEGIN INLINE ASM BLOCK
2722   15C6 FA 05 00      lea d, [bp + 5] ; $s
2723   15C9 15            mov a, [d]
2724   15CA 3C            mov d, a
2725   15CB 07 68 18      call _puts
2726   15CE 10 00 0A      mov a, $0A00
2727   15D1 05 03         syscall sys_io
2728   15D3             ; --- END INLINE ASM BLOCK
2729   15D3             
2730   15D3 F9            leave
2731   15D4 09            ret
2732   15D5             
2733   15D5             print:
2734   15D5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2735   15D8             
2736   15D8             ; --- BEGIN INLINE ASM BLOCK
2737   15D8 FA 05 00      lea d, [bp + 5] ; $s
2738   15DB FD 2A         mov d, [d]
2739   15DD 07 68 18      call _puts
2740   15E0             ; --- END INLINE ASM BLOCK
2741   15E0             
2742   15E0 F9            leave
2743   15E1 09            ret
2744   15E2             
2745   15E2             getparam:
2746   15E2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2747   15E5             ;; char data; 
2748   15E5 52 01 00      sub sp, 1 ; data
2749   15E8             
2750   15E8             ; --- BEGIN INLINE ASM BLOCK
2751   15E8 19 04         mov al, 4
2752   15EA FA 05 00      lea d, [bp + 5] ; $address
2753   15ED FD 2A         mov d, [d]
2754   15EF 05 0C         syscall sys_system
2755   15F1 FA 00 00      lea d, [bp + 0] ; $data
2756   15F4 FD 3E         mov [d], bl
2757   15F6             ; --- END INLINE ASM BLOCK
2758   15F6             
2759   15F6             ;; return data; 
2760   15F6 FA 00 00      lea d, [bp + 0] ; $data
2761   15F9 32            mov bl, [d]
2762   15FA A7 00         mov bh, 0
2763   15FC F9            leave
2764   15FD 09            ret
2765   15FE             
2766   15FE             clear:
2767   15FE F8 00 00      enter 0 ; (push bp; mov bp, sp)
2768   1601             ;; print("\033[2J\033[H"); 
2769   1601 26 E4 1C      mov b, _s5 ; "\033[2J\033[H"
2770   1604 FD AB         swp b
2771   1606 D8            push b
2772   1607 07 D5 15      call print
2773   160A 51 02 00      add sp, 2
2774   160D F9            leave
2775   160E 09            ret
2776   160F             
2777   160F             abs:
2778   160F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2779   1612             ;; return i < 0 ? -i : i; 
2780   1612             _ternary43_cond:
2781   1612 FA 05 00      lea d, [bp + 5] ; $i
2782   1615 2A            mov b, [d]
2783   1616             ; START RELATIONAL
2784   1616 D7            push a
2785   1617 11            mov a, b
2786   1618 26 00 00      mov b, $0
2787   161B B0            cmp a, b
2788   161C FD 73         slt ; < (signed)
2789   161E E4            pop a
2790   161F             ; END RELATIONAL
2791   161F C0 00 00      cmp b, 0
2792   1622 C6 2E 16      je _ternary43_false
2793   1625             _ternary43_true:
2794   1625 FA 05 00      lea d, [bp + 5] ; $i
2795   1628 2A            mov b, [d]
2796   1629 FD 97         neg b
2797   162B 0A 32 16      jmp _ternary43_exit
2798   162E             _ternary43_false:
2799   162E FA 05 00      lea d, [bp + 5] ; $i
2800   1631 2A            mov b, [d]
2801   1632             _ternary43_exit:
2802   1632 F9            leave
2803   1633 09            ret
2804   1634             
2805   1634             include_stdio_asm:
2806   1634 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2807   1637             
2808   1637             ; --- BEGIN INLINE ASM BLOCK
2809   1637             .include "lib/asm/stdio.asm"
0001+  1637             ;-----------------------------------------------------------------------------
0002+  1637             ; stdio.s
0003+  1637             ;-----------------------------------------------------------------------------
0004+  1637             .include "lib/asm/string.asm"
0001++ 1637             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1637             ; string.s
0003++ 1637             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1637             
0005++ 1637             
0006++ 1637             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1637             ; _strrev
0008++ 1637             ; reverse a string
0009++ 1637             ; D = string address
0010++ 1637             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1637             ; 01234
0012++ 1637             _strrev:
0013++ 1637 4B          	pusha
0014++ 1638 07 7E 16    	call _strlen	; length in C
0015++ 163B 12          	mov a, c
0016++ 163C AF 01 00    	cmp a, 1
0017++ 163F D0 59 16    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1642 7D          	dec a
0019++ 1643 FD 4E       	mov si, d	; beginning of string
0020++ 1645 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1647 59          	add d, a	; end of string
0022++ 1648 12          	mov a, c
0023++ 1649 FD 9B       	shr a		; divide by 2
0024++ 164B 39          	mov c, a	; C now counts the steps
0025++ 164C             _strrev_L0:
0026++ 164C 32          	mov bl, [d]	; save load right-side char into BL
0027++ 164D F6          	lodsb		; load left-side char into AL; increase SI
0028++ 164E 3E          	mov [d], al	; store left char into right side
0029++ 164F 1B          	mov al, bl
0030++ 1650 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1651 7E          	dec c
0032++ 1652 7F          	dec d
0033++ 1653 C2 00 00    	cmp c, 0
0034++ 1656 C7 4C 16    	jne _strrev_L0
0035++ 1659             _strrev_end:
0036++ 1659 4C          	popa
0037++ 165A 09          	ret
0038++ 165B             	
0039++ 165B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 165B             ; _strchr
0041++ 165B             ; search string in D for char in AL
0042++ 165B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 165B             _strchr:
0044++ 165B             _strchr_L0:
0045++ 165B 32          	mov bl, [d]
0046++ 165C C1 00       	cmp bl, 0
0047++ 165E C6 69 16    	je _strchr_end
0048++ 1661 BA          	cmp al, bl
0049++ 1662 C6 69 16    	je _strchr_end
0050++ 1665 79          	inc d
0051++ 1666 0A 5B 16    	jmp _strchr_L0
0052++ 1669             _strchr_end:
0053++ 1669 1B          	mov al, bl
0054++ 166A 09          	ret
0055++ 166B             
0056++ 166B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 166B             ; _strstr
0058++ 166B             ; find sub-string
0059++ 166B             ; str1 in SI
0060++ 166B             ; str2 in DI
0061++ 166B             ; SI points to end of source string
0062++ 166B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 166B             _strstr:
0064++ 166B DB          	push al
0065++ 166C DA          	push d
0066++ 166D E3          	push di
0067++ 166E             _strstr_loop:
0068++ 166E F3          	cmpsb					; compare a byte of the strings
0069++ 166F C7 7A 16    	jne _strstr_ret
0070++ 1672 FC 00 00    	lea d, [di + 0]
0071++ 1675 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1677 C7 6E 16    	jne _strstr_loop				; equal chars but not at end
0073++ 167A             _strstr_ret:
0074++ 167A F0          	pop di
0075++ 167B E7          	pop d
0076++ 167C E8          	pop al
0077++ 167D 09          	ret
0078++ 167E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 167E             ; length of null terminated string
0080++ 167E             ; result in C
0081++ 167E             ; pointer in D
0082++ 167E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 167E             _strlen:
0084++ 167E DA          	push d
0085++ 167F 38 00 00    	mov c, 0
0086++ 1682             _strlen_L1:
0087++ 1682 BD 00       	cmp byte [d], 0
0088++ 1684 C6 8C 16    	je _strlen_ret
0089++ 1687 79          	inc d
0090++ 1688 78          	inc c
0091++ 1689 0A 82 16    	jmp _strlen_L1
0092++ 168C             _strlen_ret:
0093++ 168C E7          	pop d
0094++ 168D 09          	ret
0095++ 168E             
0096++ 168E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 168E             ; STRCMP
0098++ 168E             ; compare two strings
0099++ 168E             ; str1 in SI
0100++ 168E             ; str2 in DI
0101++ 168E             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 168E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 168E             _strcmp:
0104++ 168E DB          	push al
0105++ 168F DA          	push d
0106++ 1690 E3          	push di
0107++ 1691 E2          	push si
0108++ 1692             _strcmp_loop:
0109++ 1692 F3          	cmpsb					; compare a byte of the strings
0110++ 1693 C7 9E 16    	jne _strcmp_ret
0111++ 1696 FB FF FF    	lea d, [si +- 1]
0112++ 1699 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 169B C7 92 16    	jne _strcmp_loop				; equal chars but not at end
0114++ 169E             _strcmp_ret:
0115++ 169E EF          	pop si
0116++ 169F F0          	pop di
0117++ 16A0 E7          	pop d
0118++ 16A1 E8          	pop al
0119++ 16A2 09          	ret
0120++ 16A3             
0121++ 16A3             
0122++ 16A3             ; STRCPY
0123++ 16A3             ; copy null terminated string from SI to DI
0124++ 16A3             ; source in SI
0125++ 16A3             ; destination in DI
0126++ 16A3             _strcpy:
0127++ 16A3 E2          	push si
0128++ 16A4 E3          	push di
0129++ 16A5 DB          	push al
0130++ 16A6             _strcpy_L1:
0131++ 16A6 F6          	lodsb
0132++ 16A7 F7          	stosb
0133++ 16A8 B9 00       	cmp al, 0
0134++ 16AA C7 A6 16    	jne _strcpy_L1
0135++ 16AD             _strcpy_end:
0136++ 16AD E8          	pop al
0137++ 16AE F0          	pop di
0138++ 16AF EF          	pop si
0139++ 16B0 09          	ret
0140++ 16B1             
0141++ 16B1             ; STRCAT
0142++ 16B1             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 16B1             ; source in SI
0144++ 16B1             ; destination in DI
0145++ 16B1             _strcat:
0146++ 16B1 E2          	push si
0147++ 16B2 E3          	push di
0148++ 16B3 D7          	push a
0149++ 16B4 DA          	push d
0150++ 16B5 50          	mov a, di
0151++ 16B6 3C          	mov d, a
0152++ 16B7             _strcat_goto_end_L1:
0153++ 16B7 BD 00       	cmp byte[d], 0
0154++ 16B9 C6 C0 16    	je _strcat_start
0155++ 16BC 79          	inc d
0156++ 16BD 0A B7 16    	jmp _strcat_goto_end_L1
0157++ 16C0             _strcat_start:
0158++ 16C0 FD 50       	mov di, d
0159++ 16C2             _strcat_L1:
0160++ 16C2 F6          	lodsb
0161++ 16C3 F7          	stosb
0162++ 16C4 B9 00       	cmp al, 0
0163++ 16C6 C7 C2 16    	jne _strcat_L1
0164++ 16C9             _strcat_end:
0165++ 16C9 E7          	pop d
0166++ 16CA E4          	pop a
0167++ 16CB F0          	pop di
0168++ 16CC EF          	pop si
0169++ 16CD 09          	ret
0170++ 16CE             
0171++ 16CE             
0005+  16CE             
0006+  16CE             ;-----------------------------------------------------------------------------
0007+  16CE             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  16CE             ; ASCII in BL
0009+  16CE             ; result in AL
0010+  16CE             ; ascii for F = 0100 0110
0011+  16CE             ; ascii for 9 = 0011 1001
0012+  16CE             ;-----------------------------------------------------------------------------
0013+  16CE             hex_ascii_encode:
0014+  16CE 1B            mov al, bl
0015+  16CF 93 40         test al, $40        ; test if letter or number
0016+  16D1 C7 D7 16      jnz hex_letter
0017+  16D4 87 0F         and al, $0F        ; get number
0018+  16D6 09            ret
0019+  16D7             hex_letter:
0020+  16D7 87 0F         and al, $0F        ; get letter
0021+  16D9 6A 09         add al, 9
0022+  16DB 09            ret
0023+  16DC             
0024+  16DC             ;-----------------------------------------------------------------------------
0025+  16DC             ; ATOI
0026+  16DC             ; 2 letter hex string in B
0027+  16DC             ; 8bit integer returned in AL
0028+  16DC             ;-----------------------------------------------------------------------------
0029+  16DC             _atoi:
0030+  16DC D8            push b
0031+  16DD 07 CE 16      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  16E0 30            mov bl, bh
0033+  16E1 DB            push al          ; save a
0034+  16E2 07 CE 16      call hex_ascii_encode
0035+  16E5 EA            pop bl  
0036+  16E6 FD 9E 04      shl al, 4
0037+  16E9 8C            or al, bl
0038+  16EA E5            pop b
0039+  16EB 09            ret  
0040+  16EC             
0041+  16EC             
0042+  16EC             ;-----------------------------------------------------------------------------
0043+  16EC             ; ITOA
0044+  16EC             ; 8bit value in BL
0045+  16EC             ; 2 byte ASCII result in A
0046+  16EC             ;-----------------------------------------------------------------------------
0047+  16EC             _itoa:
0048+  16EC DA            push d
0049+  16ED D8            push b
0050+  16EE A7 00         mov bh, 0
0051+  16F0 FD A4 04      shr bl, 4  
0052+  16F3 74            mov d, b
0053+  16F4 1F 9C 19      mov al, [d + s_hex_digits]
0054+  16F7 23            mov ah, al
0055+  16F8               
0056+  16F8 E5            pop b
0057+  16F9 D8            push b
0058+  16FA A7 00         mov bh, 0
0059+  16FC FD 87 0F      and bl, $0F
0060+  16FF 74            mov d, b
0061+  1700 1F 9C 19      mov al, [d + s_hex_digits]
0062+  1703 E5            pop b
0063+  1704 E7            pop d
0064+  1705 09            ret
0065+  1706             
0066+  1706             ;-----------------------------------------------------------------------------
0067+  1706             ; HEX STRING TO BINARY
0068+  1706             ; di = destination address
0069+  1706             ; si = source
0070+  1706             ;-----------------------------------------------------------------------------
0071+  1706             _hex_to_int:
0072+  1706             _hex_to_int_L1:
0073+  1706 F6            lodsb          ; load from [SI] to AL
0074+  1707 B9 00         cmp al, 0        ; check if ASCII 0
0075+  1709 C6 16 17      jz _hex_to_int_ret
0076+  170C 36            mov bh, al
0077+  170D F6            lodsb
0078+  170E 2F            mov bl, al
0079+  170F 07 DC 16      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1712 F7            stosb          ; store AL to [DI]
0081+  1713 0A 06 17      jmp _hex_to_int_L1
0082+  1716             _hex_to_int_ret:
0083+  1716 09            ret    
0084+  1717             
0085+  1717             ;-----------------------------------------------------------------------------
0086+  1717             ; GETCHAR
0087+  1717             ; char in ah
0088+  1717             ;-----------------------------------------------------------------------------
0089+  1717             getch:
0090+  1717 DB            push al
0091+  1718             getch_retry:
0092+  1718 19 01         mov al, 1
0093+  171A 05 03         syscall sys_io      ; receive in AH
0094+  171C E8            pop al
0095+  171D 09            ret
0096+  171E             
0097+  171E             ;-----------------------------------------------------------------------------
0098+  171E             ; PUTCHAR
0099+  171E             ; char in ah
0100+  171E             ;-----------------------------------------------------------------------------
0101+  171E             _putchar:
0102+  171E D7            push a
0103+  171F 19 00         mov al, 0
0104+  1721 05 03         syscall sys_io      ; char in AH
0105+  1723 E4            pop a
0106+  1724 09            ret
0107+  1725             
0108+  1725             ;-----------------------------------------------------------------------------
0109+  1725             ;; INPUT A STRING
0110+  1725             ;; terminates with null
0111+  1725             ;; pointer in D
0112+  1725             ;-----------------------------------------------------------------------------
0113+  1725             _gets:
0114+  1725 D7            push a
0115+  1726 DA            push d
0116+  1727             _gets_loop:
0117+  1727 19 01         mov al, 1
0118+  1729 05 03         syscall sys_io      ; receive in AH
0119+  172B B9 00         cmp al, 0        ; check error code (AL)
0120+  172D C6 27 17      je _gets_loop      ; if no char received, retry
0121+  1730             
0122+  1730 76 1B         cmp ah, 27
0123+  1732 C6 53 17      je _gets_ansi_esc
0124+  1735 76 0A         cmp ah, $0A        ; LF
0125+  1737 C6 BE 17      je _gets_end
0126+  173A 76 0D         cmp ah, $0D        ; CR
0127+  173C C6 BE 17      je _gets_end
0128+  173F 76 5C         cmp ah, $5C        ; '\\'
0129+  1741 C6 7F 17      je _gets_escape
0130+  1744               
0131+  1744 76 08         cmp ah, $08      ; check for backspace
0132+  1746 C6 4F 17      je _gets_backspace
0133+  1749             
0134+  1749 1A            mov al, ah
0135+  174A 3E            mov [d], al
0136+  174B 79            inc d
0137+  174C 0A 27 17      jmp _gets_loop
0138+  174F             _gets_backspace:
0139+  174F 7F            dec d
0140+  1750 0A 27 17      jmp _gets_loop
0141+  1753             _gets_ansi_esc:
0142+  1753 19 01         mov al, 1
0143+  1755 05 03         syscall sys_io        ; receive in AH without echo
0144+  1757 B9 00         cmp al, 0          ; check error code (AL)
0145+  1759 C6 53 17      je _gets_ansi_esc    ; if no char received, retry
0146+  175C 76 5B         cmp ah, '['
0147+  175E C7 27 17      jne _gets_loop
0148+  1761             _gets_ansi_esc_2:
0149+  1761 19 01         mov al, 1
0150+  1763 05 03         syscall sys_io          ; receive in AH without echo
0151+  1765 B9 00         cmp al, 0            ; check error code (AL)
0152+  1767 C6 61 17      je _gets_ansi_esc_2  ; if no char received, retry
0153+  176A 76 44         cmp ah, 'D'
0154+  176C C6 77 17      je _gets_left_arrow
0155+  176F 76 43         cmp ah, 'C'
0156+  1771 C6 7B 17      je _gets_right_arrow
0157+  1774 0A 27 17      jmp _gets_loop
0158+  1777             _gets_left_arrow:
0159+  1777 7F            dec d
0160+  1778 0A 27 17      jmp _gets_loop
0161+  177B             _gets_right_arrow:
0162+  177B 79            inc d
0163+  177C 0A 27 17      jmp _gets_loop
0164+  177F             _gets_escape:
0165+  177F 19 01         mov al, 1
0166+  1781 05 03         syscall sys_io      ; receive in AH
0167+  1783 B9 00         cmp al, 0        ; check error code (AL)
0168+  1785 C6 7F 17      je _gets_escape      ; if no char received, retry
0169+  1788 76 6E         cmp ah, 'n'
0170+  178A C6 A9 17      je _gets_LF
0171+  178D 76 72         cmp ah, 'r'
0172+  178F C6 B0 17      je _gets_CR
0173+  1792 76 30         cmp ah, '0'
0174+  1794 C6 B7 17      je _gets_NULL
0175+  1797 76 5C         cmp ah, $5C  ; '\'
0176+  1799 C6 A2 17      je _gets_slash
0177+  179C 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  179D 3E            mov [d], al
0179+  179E 79            inc d
0180+  179F 0A 27 17      jmp _gets_loop
0181+  17A2             _gets_slash:
0182+  17A2 19 5C         mov al, $5C
0183+  17A4 3E            mov [d], al
0184+  17A5 79            inc d
0185+  17A6 0A 27 17      jmp _gets_loop
0186+  17A9             _gets_LF:
0187+  17A9 19 0A         mov al, $0A
0188+  17AB 3E            mov [d], al
0189+  17AC 79            inc d
0190+  17AD 0A 27 17      jmp _gets_loop
0191+  17B0             _gets_CR:
0192+  17B0 19 0D         mov al, $0D
0193+  17B2 3E            mov [d], al
0194+  17B3 79            inc d
0195+  17B4 0A 27 17      jmp _gets_loop
0196+  17B7             _gets_NULL:
0197+  17B7 19 00         mov al, $00
0198+  17B9 3E            mov [d], al
0199+  17BA 79            inc d
0200+  17BB 0A 27 17      jmp _gets_loop
0201+  17BE             _gets_end:
0202+  17BE 19 00         mov al, 0
0203+  17C0 3E            mov [d], al        ; terminate string
0204+  17C1 E7            pop d
0205+  17C2 E4            pop a
0206+  17C3 09            ret
0207+  17C4             
0208+  17C4             ;-----------------------------------------------------------------------------
0209+  17C4             ;; INPUT TEXT
0210+  17C4             ;; terminated with CTRL+D
0211+  17C4             ;; pointer in D
0212+  17C4             ;-----------------------------------------------------------------------------
0213+  17C4             _gettxt:
0214+  17C4 D7            push a
0215+  17C5 DA            push d
0216+  17C6             _gettxt_loop:
0217+  17C6 19 01         mov al, 1
0218+  17C8 05 03         syscall sys_io      ; receive in AH
0219+  17CA B9 00         cmp al, 0        ; check error code (AL)
0220+  17CC C6 C6 17      je _gettxt_loop    ; if no char received, retry
0221+  17CF 76 04         cmp ah, 4      ; EOT
0222+  17D1 C6 0F 18      je _gettxt_end
0223+  17D4 76 08         cmp ah, $08      ; check for backspace
0224+  17D6 C6 0B 18      je _gettxt_backspace
0225+  17D9 76 5C         cmp ah, $5C        ; '\'
0226+  17DB C6 E4 17      je _gettxt_escape
0227+  17DE 1A            mov al, ah
0228+  17DF 3E            mov [d], al
0229+  17E0 79            inc d
0230+  17E1 0A C6 17      jmp _gettxt_loop
0231+  17E4             _gettxt_escape:
0232+  17E4 19 01         mov al, 1
0233+  17E6 05 03         syscall sys_io      ; receive in AH
0234+  17E8 B9 00         cmp al, 0        ; check error code (AL)
0235+  17EA C6 E4 17      je _gettxt_escape    ; if no char received, retry
0236+  17ED 76 6E         cmp ah, 'n'
0237+  17EF C6 FD 17      je _gettxt_LF
0238+  17F2 76 72         cmp ah, 'r'
0239+  17F4 C6 04 18      je _gettxt_CR
0240+  17F7 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  17F8 3E            mov [d], al
0242+  17F9 79            inc d
0243+  17FA 0A C6 17      jmp _gettxt_loop
0244+  17FD             _gettxt_LF:
0245+  17FD 19 0A         mov al, $0A
0246+  17FF 3E            mov [d], al
0247+  1800 79            inc d
0248+  1801 0A C6 17      jmp _gettxt_loop
0249+  1804             _gettxt_CR:
0250+  1804 19 0D         mov al, $0D
0251+  1806 3E            mov [d], al
0252+  1807 79            inc d
0253+  1808 0A C6 17      jmp _gettxt_loop
0254+  180B             _gettxt_backspace:
0255+  180B 7F            dec d
0256+  180C 0A C6 17      jmp _gettxt_loop
0257+  180F             _gettxt_end:
0258+  180F 19 00         mov al, 0
0259+  1811 3E            mov [d], al        ; terminate string
0260+  1812 E7            pop d
0261+  1813 E4            pop a
0262+  1814 09            ret
0263+  1815             
0264+  1815             ;-----------------------------------------------------------------------------
0265+  1815             ; PRINT NEW LINE
0266+  1815             ;-----------------------------------------------------------------------------
0267+  1815             printnl:
0268+  1815 D7            push a
0269+  1816 10 00 0A      mov a, $0A00
0270+  1819 05 03         syscall sys_io
0271+  181B 10 00 0D      mov a, $0D00
0272+  181E 05 03         syscall sys_io
0273+  1820 E4            pop a
0274+  1821 09            ret
0275+  1822             
0276+  1822             ;-----------------------------------------------------------------------------
0277+  1822             ; _strtoint
0278+  1822             ; 4 digit hex string number in d
0279+  1822             ; integer returned in A
0280+  1822             ;-----------------------------------------------------------------------------
0281+  1822             _strtointx:
0282+  1822 D8            push b
0283+  1823 32            mov bl, [d]
0284+  1824 37            mov bh, bl
0285+  1825 33 01 00      mov bl, [d + 1]
0286+  1828 07 DC 16      call _atoi        ; convert to int in AL
0287+  182B 23            mov ah, al        ; move to AH
0288+  182C 33 02 00      mov bl, [d + 2]
0289+  182F 37            mov bh, bl
0290+  1830 33 03 00      mov bl, [d + 3]
0291+  1833 07 DC 16      call _atoi        ; convert to int in AL
0292+  1836 E5            pop b
0293+  1837 09            ret
0294+  1838             
0295+  1838             ;-----------------------------------------------------------------------------
0296+  1838             ; _strtoint
0297+  1838             ; 5 digit base10 string number in d
0298+  1838             ; integer returned in A
0299+  1838             ;-----------------------------------------------------------------------------
0300+  1838             _strtoint:
0301+  1838 E2            push si
0302+  1839 D8            push b
0303+  183A D9            push c
0304+  183B DA            push d
0305+  183C 07 7E 16      call _strlen      ; get string length in C
0306+  183F 7E            dec c
0307+  1840 FD 4E         mov si, d
0308+  1842 12            mov a, c
0309+  1843 FD 99         shl a
0310+  1845 3B B4 19      mov d, table_power
0311+  1848 59            add d, a
0312+  1849 38 00 00      mov c, 0
0313+  184C             _strtoint_L0:
0314+  184C F6            lodsb      ; load ASCII to al
0315+  184D B9 00         cmp al, 0
0316+  184F C6 62 18      je _strtoint_end
0317+  1852 6F 30         sub al, $30    ; make into integer
0318+  1854 22 00         mov ah, 0
0319+  1856 2A            mov b, [d]
0320+  1857 AC            mul a, b      ; result in B since it fits in 16bits
0321+  1858 11            mov a, b
0322+  1859 28            mov b, c
0323+  185A 54            add a, b
0324+  185B 39            mov c, a
0325+  185C 63 02 00      sub d, 2
0326+  185F 0A 4C 18      jmp _strtoint_L0
0327+  1862             _strtoint_end:
0328+  1862 12            mov a, c
0329+  1863 E7            pop d
0330+  1864 E6            pop c
0331+  1865 E5            pop b
0332+  1866 EF            pop si
0333+  1867 09            ret
0334+  1868             
0335+  1868             ;-----------------------------------------------------------------------------
0336+  1868             ; PRINT NULL TERMINATED STRING
0337+  1868             ; pointer in D
0338+  1868             ;-----------------------------------------------------------------------------
0339+  1868             _puts:
0340+  1868 D7            push a
0341+  1869 DA            push d
0342+  186A             _puts_L1:
0343+  186A 1E            mov al, [d]
0344+  186B B9 00         cmp al, 0
0345+  186D C6 79 18      jz _puts_END
0346+  1870 23            mov ah, al
0347+  1871 19 00         mov al, 0
0348+  1873 05 03         syscall sys_io
0349+  1875 79            inc d
0350+  1876 0A 6A 18      jmp _puts_L1
0351+  1879             _puts_END:
0352+  1879 E7            pop d
0353+  187A E4            pop a
0354+  187B 09            ret
0355+  187C             
0356+  187C             ;-----------------------------------------------------------------------------
0357+  187C             ; PRINT N SIZE STRING
0358+  187C             ; pointer in D
0359+  187C             ; size in C
0360+  187C             ;-----------------------------------------------------------------------------
0361+  187C             _putsn:
0362+  187C DB            push al
0363+  187D DA            push d
0364+  187E D9            push c
0365+  187F             _putsn_L0:
0366+  187F 1E            mov al, [d]
0367+  1880 23            mov ah, al
0368+  1881 19 00         mov al, 0
0369+  1883 05 03         syscall sys_io
0370+  1885 79            inc d
0371+  1886 7E            dec c  
0372+  1887 C2 00 00      cmp c, 0
0373+  188A C7 7F 18      jne _putsn_L0
0374+  188D             _putsn_end:
0375+  188D E6            pop c
0376+  188E E7            pop d
0377+  188F E8            pop al
0378+  1890 09            ret
0379+  1891             
0380+  1891             ;-----------------------------------------------------------------------------
0381+  1891             ; print 16bit decimal number
0382+  1891             ; input number in A
0383+  1891             ;-----------------------------------------------------------------------------
0384+  1891             print_u16d:
0385+  1891 D7            push a
0386+  1892 D8            push b
0387+  1893 26 10 27      mov b, 10000
0388+  1896 AE            div a, b      ; get 10000's coeff.
0389+  1897 07 B9 18      call print_number
0390+  189A 11            mov a, b
0391+  189B 26 E8 03      mov b, 1000
0392+  189E AE            div a, b      ; get 1000's coeff.
0393+  189F 07 B9 18      call print_number
0394+  18A2 11            mov a, b
0395+  18A3 26 64 00      mov b, 100
0396+  18A6 AE            div a, b
0397+  18A7 07 B9 18      call print_number
0398+  18AA 11            mov a, b
0399+  18AB 26 0A 00      mov b, 10
0400+  18AE AE            div a, b
0401+  18AF 07 B9 18      call print_number
0402+  18B2 1B            mov al, bl      ; 1's coeff in bl
0403+  18B3 07 B9 18      call print_number
0404+  18B6 E5            pop b
0405+  18B7 E4            pop a
0406+  18B8 09            ret
0407+  18B9             
0408+  18B9             ;-----------------------------------------------------------------------------
0409+  18B9             ; print AL
0410+  18B9             ;-----------------------------------------------------------------------------
0411+  18B9             print_number:
0412+  18B9 6A 30         add al, $30
0413+  18BB 23            mov ah, al
0414+  18BC 07 1E 17      call _putchar
0415+  18BF 09            ret
0416+  18C0             
0417+  18C0             ;-----------------------------------------------------------------------------
0418+  18C0             ; PRINT 16BIT HEX INTEGER
0419+  18C0             ; integer value in reg B
0420+  18C0             ;-----------------------------------------------------------------------------
0421+  18C0             print_u16x:
0422+  18C0 D7            push a
0423+  18C1 D8            push b
0424+  18C2 DD            push bl
0425+  18C3 30            mov bl, bh
0426+  18C4 07 EC 16      call _itoa        ; convert bh to char in A
0427+  18C7 2F            mov bl, al        ; save al
0428+  18C8 19 00         mov al, 0
0429+  18CA 05 03         syscall sys_io        ; display AH
0430+  18CC 24            mov ah, bl        ; retrieve al
0431+  18CD 19 00         mov al, 0
0432+  18CF 05 03         syscall sys_io        ; display AL
0433+  18D1             
0434+  18D1 EA            pop bl
0435+  18D2 07 EC 16      call _itoa        ; convert bh to char in A
0436+  18D5 2F            mov bl, al        ; save al
0437+  18D6 19 00         mov al, 0
0438+  18D8 05 03         syscall sys_io        ; display AH
0439+  18DA 24            mov ah, bl        ; retrieve al
0440+  18DB 19 00         mov al, 0
0441+  18DD 05 03         syscall sys_io        ; display AL
0442+  18DF             
0443+  18DF E5            pop b
0444+  18E0 E4            pop a
0445+  18E1 09            ret
0446+  18E2             
0447+  18E2             ;-----------------------------------------------------------------------------
0448+  18E2             ; INPUT 16BIT HEX INTEGER
0449+  18E2             ; read 16bit integer into A
0450+  18E2             ;-----------------------------------------------------------------------------
0451+  18E2             scan_u16x:
0452+  18E2 F8 10 00      enter 16
0453+  18E5 D8            push b
0454+  18E6 DA            push d
0455+  18E7             
0456+  18E7 FA F1 FF      lea d, [bp + -15]
0457+  18EA 07 25 17      call _gets        ; get number
0458+  18ED             
0459+  18ED 32            mov bl, [d]
0460+  18EE 37            mov bh, bl
0461+  18EF 33 01 00      mov bl, [d + 1]
0462+  18F2 07 DC 16      call _atoi        ; convert to int in AL
0463+  18F5 23            mov ah, al        ; move to AH
0464+  18F6             
0465+  18F6 33 02 00      mov bl, [d + 2]
0466+  18F9 37            mov bh, bl
0467+  18FA 33 03 00      mov bl, [d + 3]
0468+  18FD 07 DC 16      call _atoi        ; convert to int in AL
0469+  1900             
0470+  1900 E7            pop d
0471+  1901 E5            pop b
0472+  1902 F9            leave
0473+  1903 09            ret
0474+  1904             
0475+  1904             ;-----------------------------------------------------------------------------
0476+  1904             ; PRINT 8bit HEX INTEGER
0477+  1904             ; integer value in reg bl
0478+  1904             ;-----------------------------------------------------------------------------
0479+  1904             print_u8x:
0480+  1904 D7            push a
0481+  1905 DD            push bl
0482+  1906             
0483+  1906 07 EC 16      call _itoa        ; convert bl to char in A
0484+  1909 2F            mov bl, al        ; save al
0485+  190A 19 00         mov al, 0
0486+  190C 05 03         syscall sys_io        ; display AH
0487+  190E 24            mov ah, bl        ; retrieve al
0488+  190F 19 00         mov al, 0
0489+  1911 05 03         syscall sys_io        ; display AL
0490+  1913             
0491+  1913 EA            pop bl
0492+  1914 E4            pop a
0493+  1915 09            ret
0494+  1916             
0495+  1916             ;-----------------------------------------------------------------------------
0496+  1916             ; print 8bit decimal unsigned number
0497+  1916             ; input number in AL
0498+  1916             ;-----------------------------------------------------------------------------
0499+  1916             print_u8d:
0500+  1916 D7            push a
0501+  1917 D8            push b
0502+  1918             
0503+  1918 22 00         mov ah, 0
0504+  191A 26 64 00      mov b, 100
0505+  191D AE            div a, b
0506+  191E D8            push b      ; save remainder
0507+  191F B9 00         cmp al, 0
0508+  1921 C6 2B 19      je skip100
0509+  1924 6A 30         add al, $30
0510+  1926 23            mov ah, al
0511+  1927 19 00         mov al, 0
0512+  1929 05 03         syscall sys_io  ; print coeff
0513+  192B             skip100:
0514+  192B E4            pop a
0515+  192C 22 00         mov ah, 0
0516+  192E 26 0A 00      mov b, 10
0517+  1931 AE            div a, b
0518+  1932 D8            push b      ; save remainder
0519+  1933 B9 00         cmp al, 0
0520+  1935 C6 3F 19      je skip10
0521+  1938 6A 30         add al, $30
0522+  193A 23            mov ah, al
0523+  193B 19 00         mov al, 0
0524+  193D 05 03         syscall sys_io  ; print coeff
0525+  193F             skip10:
0526+  193F E4            pop a
0527+  1940 1B            mov al, bl
0528+  1941 6A 30         add al, $30
0529+  1943 23            mov ah, al
0530+  1944 19 00         mov al, 0
0531+  1946 05 03         syscall sys_io  ; print coeff
0532+  1948 E5            pop b
0533+  1949 E4            pop a
0534+  194A 09            ret
0535+  194B             
0536+  194B             ;-----------------------------------------------------------------------------
0537+  194B             ; INPUT 8BIT HEX INTEGER
0538+  194B             ; read 8bit integer into AL
0539+  194B             ;-----------------------------------------------------------------------------
0540+  194B             scan_u8x:
0541+  194B F8 04 00      enter 4
0542+  194E D8            push b
0543+  194F DA            push d
0544+  1950             
0545+  1950 FA FD FF      lea d, [bp + -3]
0546+  1953 07 25 17      call _gets        ; get number
0547+  1956             
0548+  1956 32            mov bl, [d]
0549+  1957 37            mov bh, bl
0550+  1958 33 01 00      mov bl, [d + 1]
0551+  195B 07 DC 16      call _atoi        ; convert to int in AL
0552+  195E             
0553+  195E E7            pop d
0554+  195F E5            pop b
0555+  1960 F9            leave
0556+  1961 09            ret
0557+  1962             
0558+  1962             ;-----------------------------------------------------------------------------
0559+  1962             ; input decimal number
0560+  1962             ; result in A
0561+  1962             ; 655'\0'
0562+  1962             ; low--------high
0563+  1962             ;-----------------------------------------------------------------------------
0564+  1962             scan_u16d:
0565+  1962 F8 08 00      enter 8
0566+  1965 E2            push si
0567+  1966 D8            push b
0568+  1967 D9            push c
0569+  1968 DA            push d
0570+  1969 FA F9 FF      lea d, [bp +- 7]
0571+  196C 07 25 17      call _gets
0572+  196F 07 7E 16      call _strlen      ; get string length in C
0573+  1972 7E            dec c
0574+  1973 FD 4E         mov si, d
0575+  1975 12            mov a, c
0576+  1976 FD 99         shl a
0577+  1978 3B B4 19      mov d, table_power
0578+  197B 59            add d, a
0579+  197C 38 00 00      mov c, 0
0580+  197F             mul_loop:
0581+  197F F6            lodsb      ; load ASCII to al
0582+  1980 B9 00         cmp al, 0
0583+  1982 C6 95 19      je mul_exit
0584+  1985 6F 30         sub al, $30    ; make into integer
0585+  1987 22 00         mov ah, 0
0586+  1989 2A            mov b, [d]
0587+  198A AC            mul a, b      ; result in B since it fits in 16bits
0588+  198B 11            mov a, b
0589+  198C 28            mov b, c
0590+  198D 54            add a, b
0591+  198E 39            mov c, a
0592+  198F 63 02 00      sub d, 2
0593+  1992 0A 7F 19      jmp mul_loop
0594+  1995             mul_exit:
0595+  1995 12            mov a, c
0596+  1996 E7            pop d
0597+  1997 E6            pop c
0598+  1998 E5            pop b
0599+  1999 EF            pop si
0600+  199A F9            leave
0601+  199B 09            ret
0602+  199C             
0603+  199C 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  19A0 34 35 36 37 
0603+  19A4 38 39 41 42 
0603+  19A8 43 44 45 46 
0604+  19AC 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  19B0 1B 5B 48 00 
0605+  19B4             
0606+  19B4             table_power:
0607+  19B4 01 00         .dw 1
0608+  19B6 0A 00         .dw 10
0609+  19B8 64 00         .dw 100
0610+  19BA E8 03         .dw 1000
0611+  19BC 10 27         .dw 100002810   19BE             ; --- END INLINE ASM BLOCK
2811   19BE             
2812   19BE F9            leave
2813   19BF 09            ret
2814   19C0             
2815   19C0             sqrt:
2816   19C0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2817   19C3             ;; int x; 
2818   19C3 52 02 00      sub sp, 2 ; x
2819   19C6             ;; int y; 
2820   19C6 52 02 00      sub sp, 2 ; y
2821   19C9             ;; if (n <= 1) { 
2822   19C9             _if44_cond:
2823   19C9 FA 05 00      lea d, [bp + 5] ; $n
2824   19CC 2A            mov b, [d]
2825   19CD             ; START RELATIONAL
2826   19CD D7            push a
2827   19CE 11            mov a, b
2828   19CF 26 01 00      mov b, $1
2829   19D2 B0            cmp a, b
2830   19D3 FD 74         sle ; <= (signed)
2831   19D5 E4            pop a
2832   19D6             ; END RELATIONAL
2833   19D6 C0 00 00      cmp b, 0
2834   19D9 C6 E5 19      je _if44_exit
2835   19DC             _if44_true:
2836   19DC             ;; return n; 
2837   19DC FA 05 00      lea d, [bp + 5] ; $n
2838   19DF 2A            mov b, [d]
2839   19E0 F9            leave
2840   19E1 09            ret
2841   19E2 0A E5 19      jmp _if44_exit
2842   19E5             _if44_exit:
2843   19E5             ;; x = n; 
2844   19E5 FA FF FF      lea d, [bp + -1] ; $x
2845   19E8 DA            push d
2846   19E9 FA 05 00      lea d, [bp + 5] ; $n
2847   19EC 2A            mov b, [d]
2848   19ED E7            pop d
2849   19EE FD 43         mov [d], b
2850   19F0             ;; y = (x + n / x) / 2; 
2851   19F0 FA FD FF      lea d, [bp + -3] ; $y
2852   19F3 DA            push d
2853   19F4 FA FF FF      lea d, [bp + -1] ; $x
2854   19F7 2A            mov b, [d]
2855   19F8             ; START TERMS
2856   19F8 D7            push a
2857   19F9 11            mov a, b
2858   19FA FA 05 00      lea d, [bp + 5] ; $n
2859   19FD 2A            mov b, [d]
2860   19FE             ; START FACTORS
2861   19FE D7            push a
2862   19FF 11            mov a, b
2863   1A00 FA FF FF      lea d, [bp + -1] ; $x
2864   1A03 2A            mov b, [d]
2865   1A04 AE            div a, b
2866   1A05 27            mov b, a
2867   1A06 E4            pop a
2868   1A07             ; END FACTORS
2869   1A07 56            add b, a
2870   1A08 E4            pop a
2871   1A09             ; END TERMS
2872   1A09             ; START FACTORS
2873   1A09 D7            push a
2874   1A0A 11            mov a, b
2875   1A0B 26 02 00      mov b, $2
2876   1A0E AE            div a, b
2877   1A0F 27            mov b, a
2878   1A10 E4            pop a
2879   1A11             ; END FACTORS
2880   1A11 E7            pop d
2881   1A12 FD 43         mov [d], b
2882   1A14             ;; while (y < x) { 
2883   1A14             _while45_cond:
2884   1A14 FA FD FF      lea d, [bp + -3] ; $y
2885   1A17 2A            mov b, [d]
2886   1A18             ; START RELATIONAL
2887   1A18 D7            push a
2888   1A19 11            mov a, b
2889   1A1A FA FF FF      lea d, [bp + -1] ; $x
2890   1A1D 2A            mov b, [d]
2891   1A1E B0            cmp a, b
2892   1A1F FD 73         slt ; < (signed)
2893   1A21 E4            pop a
2894   1A22             ; END RELATIONAL
2895   1A22 C0 00 00      cmp b, 0
2896   1A25 C6 5A 1A      je _while45_exit
2897   1A28             _while45_block:
2898   1A28             ;; x = y; 
2899   1A28 FA FF FF      lea d, [bp + -1] ; $x
2900   1A2B DA            push d
2901   1A2C FA FD FF      lea d, [bp + -3] ; $y
2902   1A2F 2A            mov b, [d]
2903   1A30 E7            pop d
2904   1A31 FD 43         mov [d], b
2905   1A33             ;; y = (x + n / x) / 2; 
2906   1A33 FA FD FF      lea d, [bp + -3] ; $y
2907   1A36 DA            push d
2908   1A37 FA FF FF      lea d, [bp + -1] ; $x
2909   1A3A 2A            mov b, [d]
2910   1A3B             ; START TERMS
2911   1A3B D7            push a
2912   1A3C 11            mov a, b
2913   1A3D FA 05 00      lea d, [bp + 5] ; $n
2914   1A40 2A            mov b, [d]
2915   1A41             ; START FACTORS
2916   1A41 D7            push a
2917   1A42 11            mov a, b
2918   1A43 FA FF FF      lea d, [bp + -1] ; $x
2919   1A46 2A            mov b, [d]
2920   1A47 AE            div a, b
2921   1A48 27            mov b, a
2922   1A49 E4            pop a
2923   1A4A             ; END FACTORS
2924   1A4A 56            add b, a
2925   1A4B E4            pop a
2926   1A4C             ; END TERMS
2927   1A4C             ; START FACTORS
2928   1A4C D7            push a
2929   1A4D 11            mov a, b
2930   1A4E 26 02 00      mov b, $2
2931   1A51 AE            div a, b
2932   1A52 27            mov b, a
2933   1A53 E4            pop a
2934   1A54             ; END FACTORS
2935   1A54 E7            pop d
2936   1A55 FD 43         mov [d], b
2937   1A57 0A 14 1A      jmp _while45_cond
2938   1A5A             _while45_exit:
2939   1A5A             ;; return x; 
2940   1A5A FA FF FF      lea d, [bp + -1] ; $x
2941   1A5D 2A            mov b, [d]
2942   1A5E F9            leave
2943   1A5F 09            ret
2944   1A60             
2945   1A60             exp:
2946   1A60 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2947   1A63             ;; int i; 
2948   1A63 52 02 00      sub sp, 2 ; i
2949   1A66             ;; int result = 1; 
2950   1A66 52 02 00      sub sp, 2 ; result
2951   1A69             ; --- START LOCAL VAR INITIALIZATION
2952   1A69 FA FD FF      lea d, [bp + -3] ; $result
2953   1A6C DA            push d
2954   1A6D 26 01 00      mov b, $1
2955   1A70 E7            pop d
2956   1A71 FD 43         mov [d], b
2957   1A73             ; --- END LOCAL VAR INITIALIZATION
2958   1A73             ;; for(i = 0; i < exp; i++){ 
2959   1A73             _for46_init:
2960   1A73 FA FF FF      lea d, [bp + -1] ; $i
2961   1A76 DA            push d
2962   1A77 26 00 00      mov b, $0
2963   1A7A E7            pop d
2964   1A7B FD 43         mov [d], b
2965   1A7D             _for46_cond:
2966   1A7D FA FF FF      lea d, [bp + -1] ; $i
2967   1A80 2A            mov b, [d]
2968   1A81             ; START RELATIONAL
2969   1A81 D7            push a
2970   1A82 11            mov a, b
2971   1A83 FA 07 00      lea d, [bp + 7] ; $exp
2972   1A86 2A            mov b, [d]
2973   1A87 B0            cmp a, b
2974   1A88 FD 73         slt ; < (signed)
2975   1A8A E4            pop a
2976   1A8B             ; END RELATIONAL
2977   1A8B C0 00 00      cmp b, 0
2978   1A8E C6 B6 1A      je _for46_exit
2979   1A91             _for46_block:
2980   1A91             ;; result = result * base; 
2981   1A91 FA FD FF      lea d, [bp + -3] ; $result
2982   1A94 DA            push d
2983   1A95 FA FD FF      lea d, [bp + -3] ; $result
2984   1A98 2A            mov b, [d]
2985   1A99             ; START FACTORS
2986   1A99 D7            push a
2987   1A9A 11            mov a, b
2988   1A9B FA 05 00      lea d, [bp + 5] ; $base
2989   1A9E 2A            mov b, [d]
2990   1A9F AC            mul a, b ; *
2991   1AA0 11            mov a, b
2992   1AA1 27            mov b, a
2993   1AA2 E4            pop a
2994   1AA3             ; END FACTORS
2995   1AA3 E7            pop d
2996   1AA4 FD 43         mov [d], b
2997   1AA6             _for46_update:
2998   1AA6 FA FF FF      lea d, [bp + -1] ; $i
2999   1AA9 2A            mov b, [d]
3000   1AAA FD 77         inc b
3001   1AAC FA FF FF      lea d, [bp + -1] ; $i
3002   1AAF FD 43         mov [d], b
3003   1AB1 FD 7D         dec b
3004   1AB3 0A 7D 1A      jmp _for46_cond
3005   1AB6             _for46_exit:
3006   1AB6             ;; return result; 
3007   1AB6 FA FD FF      lea d, [bp + -3] ; $result
3008   1AB9 2A            mov b, [d]
3009   1ABA F9            leave
3010   1ABB 09            ret
3011   1ABC             
3012   1ABC             primes1:
3013   1ABC F8 00 00      enter 0 ; (push bp; mov bp, sp)
3014   1ABF             ;; unsigned int n, i, s, count, divides; 
3015   1ABF 52 02 00      sub sp, 2 ; n
3016   1AC2 52 02 00      sub sp, 2 ; i
3017   1AC5 52 02 00      sub sp, 2 ; s
3018   1AC8 52 02 00      sub sp, 2 ; count
3019   1ACB 52 02 00      sub sp, 2 ; divides
3020   1ACE             ;; n = 2; 
3021   1ACE FA FF FF      lea d, [bp + -1] ; $n
3022   1AD1 DA            push d
3023   1AD2 26 02 00      mov b, $2
3024   1AD5 E7            pop d
3025   1AD6 FD 43         mov [d], b
3026   1AD8             ;; while(n < top){ 
3027   1AD8             _while47_cond:
3028   1AD8 FA FF FF      lea d, [bp + -1] ; $n
3029   1ADB 2A            mov b, [d]
3030   1ADC             ; START RELATIONAL
3031   1ADC D7            push a
3032   1ADD 11            mov a, b
3033   1ADE 3B 59 1C      mov d, _top ; $top
3034   1AE1 2A            mov b, [d]
3035   1AE2 B0            cmp a, b
3036   1AE3 FD 75         slu ; < (unsigned)
3037   1AE5 E4            pop a
3038   1AE6             ; END RELATIONAL
3039   1AE6 C0 00 00      cmp b, 0
3040   1AE9 C6 D4 1B      je _while47_exit
3041   1AEC             _while47_block:
3042   1AEC             ;; s = sqrt(n); 
3043   1AEC FA FB FF      lea d, [bp + -5] ; $s
3044   1AEF DA            push d
3045   1AF0 FA FF FF      lea d, [bp + -1] ; $n
3046   1AF3 2A            mov b, [d]
3047   1AF4 FD AB         swp b
3048   1AF6 D8            push b
3049   1AF7 07 C0 19      call sqrt
3050   1AFA 51 02 00      add sp, 2
3051   1AFD E7            pop d
3052   1AFE FD 43         mov [d], b
3053   1B00             ;; divides = 0; 
3054   1B00 FA F7 FF      lea d, [bp + -9] ; $divides
3055   1B03 DA            push d
3056   1B04 26 00 00      mov b, $0
3057   1B07 E7            pop d
3058   1B08 FD 43         mov [d], b
3059   1B0A             ;; i = 2; 
3060   1B0A FA FD FF      lea d, [bp + -3] ; $i
3061   1B0D DA            push d
3062   1B0E 26 02 00      mov b, $2
3063   1B11 E7            pop d
3064   1B12 FD 43         mov [d], b
3065   1B14             ;; while(i <= s){ 
3066   1B14             _while48_cond:
3067   1B14 FA FD FF      lea d, [bp + -3] ; $i
3068   1B17 2A            mov b, [d]
3069   1B18             ; START RELATIONAL
3070   1B18 D7            push a
3071   1B19 11            mov a, b
3072   1B1A FA FB FF      lea d, [bp + -5] ; $s
3073   1B1D 2A            mov b, [d]
3074   1B1E B0            cmp a, b
3075   1B1F FD 76         sleu ; <= (unsigned)
3076   1B21 E4            pop a
3077   1B22             ; END RELATIONAL
3078   1B22 C0 00 00      cmp b, 0
3079   1B25 C6 84 1B      je _while48_exit
3080   1B28             _while48_block:
3081   1B28             ;; if(n % i == 0){ 
3082   1B28             _if49_cond:
3083   1B28 FA FF FF      lea d, [bp + -1] ; $n
3084   1B2B 2A            mov b, [d]
3085   1B2C             ; START FACTORS
3086   1B2C D7            push a
3087   1B2D 11            mov a, b
3088   1B2E FA FD FF      lea d, [bp + -3] ; $i
3089   1B31 2A            mov b, [d]
3090   1B32 AE            div a, b ; 
3091   1B33 11            mov a, b
3092   1B34 27            mov b, a
3093   1B35 E4            pop a
3094   1B36             ; END FACTORS
3095   1B36             ; START RELATIONAL
3096   1B36 D7            push a
3097   1B37 11            mov a, b
3098   1B38 26 00 00      mov b, $0
3099   1B3B B0            cmp a, b
3100   1B3C FD 71         seq ; ==
3101   1B3E E4            pop a
3102   1B3F             ; END RELATIONAL
3103   1B3F C0 00 00      cmp b, 0
3104   1B42 C6 55 1B      je _if49_exit
3105   1B45             _if49_true:
3106   1B45             ;; divides = 1; 
3107   1B45 FA F7 FF      lea d, [bp + -9] ; $divides
3108   1B48 DA            push d
3109   1B49 26 01 00      mov b, $1
3110   1B4C E7            pop d
3111   1B4D FD 43         mov [d], b
3112   1B4F             ;; break; 
3113   1B4F 0A 84 1B      jmp _while48_exit ; while break
3114   1B52 0A 55 1B      jmp _if49_exit
3115   1B55             _if49_exit:
3116   1B55             ;; i = i + 1; 
3117   1B55 FA FD FF      lea d, [bp + -3] ; $i
3118   1B58 DA            push d
3119   1B59 FA FD FF      lea d, [bp + -3] ; $i
3120   1B5C 2A            mov b, [d]
3121   1B5D             ; START TERMS
3122   1B5D D7            push a
3123   1B5E 11            mov a, b
3124   1B5F 26 01 00      mov b, $1
3125   1B62 56            add b, a
3126   1B63 E4            pop a
3127   1B64             ; END TERMS
3128   1B64 E7            pop d
3129   1B65 FD 43         mov [d], b
3130   1B67             ;; if(i >= s) break; 
3131   1B67             _if50_cond:
3132   1B67 FA FD FF      lea d, [bp + -3] ; $i
3133   1B6A 2A            mov b, [d]
3134   1B6B             ; START RELATIONAL
3135   1B6B D7            push a
3136   1B6C 11            mov a, b
3137   1B6D FA FB FF      lea d, [bp + -5] ; $s
3138   1B70 2A            mov b, [d]
3139   1B71 B0            cmp a, b
3140   1B72 FD 82         sgeu ; >= (unsigned)
3141   1B74 E4            pop a
3142   1B75             ; END RELATIONAL
3143   1B75 C0 00 00      cmp b, 0
3144   1B78 C6 81 1B      je _if50_exit
3145   1B7B             _if50_true:
3146   1B7B             ;; break; 
3147   1B7B 0A 84 1B      jmp _while48_exit ; while break
3148   1B7E 0A 81 1B      jmp _if50_exit
3149   1B81             _if50_exit:
3150   1B81 0A 14 1B      jmp _while48_cond
3151   1B84             _while48_exit:
3152   1B84             ;; if(divides == 0){ 
3153   1B84             _if51_cond:
3154   1B84 FA F7 FF      lea d, [bp + -9] ; $divides
3155   1B87 2A            mov b, [d]
3156   1B88             ; START RELATIONAL
3157   1B88 D7            push a
3158   1B89 11            mov a, b
3159   1B8A 26 00 00      mov b, $0
3160   1B8D B0            cmp a, b
3161   1B8E FD 71         seq ; ==
3162   1B90 E4            pop a
3163   1B91             ; END RELATIONAL
3164   1B91 C0 00 00      cmp b, 0
3165   1B94 C6 BF 1B      je _if51_exit
3166   1B97             _if51_true:
3167   1B97             ;; count = count + 1;	 
3168   1B97 FA F9 FF      lea d, [bp + -7] ; $count
3169   1B9A DA            push d
3170   1B9B FA F9 FF      lea d, [bp + -7] ; $count
3171   1B9E 2A            mov b, [d]
3172   1B9F             ; START TERMS
3173   1B9F D7            push a
3174   1BA0 11            mov a, b
3175   1BA1 26 01 00      mov b, $1
3176   1BA4 56            add b, a
3177   1BA5 E4            pop a
3178   1BA6             ; END TERMS
3179   1BA6 E7            pop d
3180   1BA7 FD 43         mov [d], b
3181   1BA9             ;; printf("%d\n", n); 
3182   1BA9 FA FF FF      lea d, [bp + -1] ; $n
3183   1BAC 2A            mov b, [d]
3184   1BAD FD AB         swp b
3185   1BAF D8            push b
3186   1BB0 26 A4 1C      mov b, _s2 ; "%d\n"
3187   1BB3 FD AB         swp b
3188   1BB5 D8            push b
3189   1BB6 07 33 08      call printf
3190   1BB9 51 04 00      add sp, 4
3191   1BBC 0A BF 1B      jmp _if51_exit
3192   1BBF             _if51_exit:
3193   1BBF             ;; n = n + 1; 
3194   1BBF FA FF FF      lea d, [bp + -1] ; $n
3195   1BC2 DA            push d
3196   1BC3 FA FF FF      lea d, [bp + -1] ; $n
3197   1BC6 2A            mov b, [d]
3198   1BC7             ; START TERMS
3199   1BC7 D7            push a
3200   1BC8 11            mov a, b
3201   1BC9 26 01 00      mov b, $1
3202   1BCC 56            add b, a
3203   1BCD E4            pop a
3204   1BCE             ; END TERMS
3205   1BCE E7            pop d
3206   1BCF FD 43         mov [d], b
3207   1BD1 0A D8 1A      jmp _while47_cond
3208   1BD4             _while47_exit:
3209   1BD4             ;; return; 
3210   1BD4 F9            leave
3211   1BD5 09            ret
3212   1BD6             
3213   1BD6             isPrime:
3214   1BD6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3215   1BD9             ;; unsigned int i; 
3216   1BD9 52 02 00      sub sp, 2 ; i
3217   1BDC             ;; if (num <= 1) return 0; 
3218   1BDC             _if52_cond:
3219   1BDC FA 05 00      lea d, [bp + 5] ; $num
3220   1BDF 2A            mov b, [d]
3221   1BE0             ; START RELATIONAL
3222   1BE0 D7            push a
3223   1BE1 11            mov a, b
3224   1BE2 26 01 00      mov b, $1
3225   1BE5 B0            cmp a, b
3226   1BE6 FD 76         sleu ; <= (unsigned)
3227   1BE8 E4            pop a
3228   1BE9             ; END RELATIONAL
3229   1BE9 C0 00 00      cmp b, 0
3230   1BEC C6 F7 1B      je _if52_exit
3231   1BEF             _if52_true:
3232   1BEF             ;; return 0; 
3233   1BEF 26 00 00      mov b, $0
3234   1BF2 F9            leave
3235   1BF3 09            ret
3236   1BF4 0A F7 1B      jmp _if52_exit
3237   1BF7             _if52_exit:
3238   1BF7             ;; for (i = 2; i * i <= num; i++) { 
3239   1BF7             _for53_init:
3240   1BF7 FA FF FF      lea d, [bp + -1] ; $i
3241   1BFA DA            push d
3242   1BFB 26 02 00      mov b, $2
3243   1BFE E7            pop d
3244   1BFF FD 43         mov [d], b
3245   1C01             _for53_cond:
3246   1C01 FA FF FF      lea d, [bp + -1] ; $i
3247   1C04 2A            mov b, [d]
3248   1C05             ; START FACTORS
3249   1C05 D7            push a
3250   1C06 11            mov a, b
3251   1C07 FA FF FF      lea d, [bp + -1] ; $i
3252   1C0A 2A            mov b, [d]
3253   1C0B AC            mul a, b ; *
3254   1C0C 11            mov a, b
3255   1C0D 27            mov b, a
3256   1C0E E4            pop a
3257   1C0F             ; END FACTORS
3258   1C0F             ; START RELATIONAL
3259   1C0F D7            push a
3260   1C10 11            mov a, b
3261   1C11 FA 05 00      lea d, [bp + 5] ; $num
3262   1C14 2A            mov b, [d]
3263   1C15 B0            cmp a, b
3264   1C16 FD 76         sleu ; <= (unsigned)
3265   1C18 E4            pop a
3266   1C19             ; END RELATIONAL
3267   1C19 C0 00 00      cmp b, 0
3268   1C1C C6 54 1C      je _for53_exit
3269   1C1F             _for53_block:
3270   1C1F             ;; if (num % i == 0) return 0; 
3271   1C1F             _if54_cond:
3272   1C1F FA 05 00      lea d, [bp + 5] ; $num
3273   1C22 2A            mov b, [d]
3274   1C23             ; START FACTORS
3275   1C23 D7            push a
3276   1C24 11            mov a, b
3277   1C25 FA FF FF      lea d, [bp + -1] ; $i
3278   1C28 2A            mov b, [d]
3279   1C29 AE            div a, b ; 
3280   1C2A 11            mov a, b
3281   1C2B 27            mov b, a
3282   1C2C E4            pop a
3283   1C2D             ; END FACTORS
3284   1C2D             ; START RELATIONAL
3285   1C2D D7            push a
3286   1C2E 11            mov a, b
3287   1C2F 26 00 00      mov b, $0
3288   1C32 B0            cmp a, b
3289   1C33 FD 71         seq ; ==
3290   1C35 E4            pop a
3291   1C36             ; END RELATIONAL
3292   1C36 C0 00 00      cmp b, 0
3293   1C39 C6 44 1C      je _if54_exit
3294   1C3C             _if54_true:
3295   1C3C             ;; return 0; 
3296   1C3C 26 00 00      mov b, $0
3297   1C3F F9            leave
3298   1C40 09            ret
3299   1C41 0A 44 1C      jmp _if54_exit
3300   1C44             _if54_exit:
3301   1C44             _for53_update:
3302   1C44 FA FF FF      lea d, [bp + -1] ; $i
3303   1C47 2A            mov b, [d]
3304   1C48 FD 77         inc b
3305   1C4A FA FF FF      lea d, [bp + -1] ; $i
3306   1C4D FD 43         mov [d], b
3307   1C4F FD 7D         dec b
3308   1C51 0A 01 1C      jmp _for53_cond
3309   1C54             _for53_exit:
3310   1C54             ;; return 1; 
3311   1C54 26 01 00      mov b, $1
3312   1C57 F9            leave
3313   1C58 09            ret
3314   1C59             ; --- END TEXT BLOCK
3315   1C59             
3316   1C59             ; --- BEGIN DATA BLOCK
3317   1C59 00 00       _top: .fill 2, 0
3318   1C5B 45 6E 74 65 _s0: .db "Enter a number to find all prime numbers up to it: ", 0
3318   1C5F 72 20 61 20 
3318   1C63 6E 75 6D 62 
3318   1C67 65 72 20 74 
3318   1C6B 6F 20 66 69 
3318   1C6F 6E 64 20 61 
3318   1C73 6C 6C 20 70 
3318   1C77 72 69 6D 65 
3318   1C7B 20 6E 75 6D 
3318   1C7F 62 65 72 73 
3318   1C83 20 75 70 20 
3318   1C87 74 6F 20 69 
3318   1C8B 74 3A 20 00 
3319   1C8F 50 72 69 6D _s1: .db "Prime numbers are: \n", 0
3319   1C93 65 20 6E 75 
3319   1C97 6D 62 65 72 
3319   1C9B 73 20 61 72 
3319   1C9F 65 3A 20 0A 
3319   1CA3 00 
3320   1CA4 25 64 0A 00 _s2: .db "%d\n", 0
3321   1CA8 55 6E 65 78 _s3: .db "Unexpected format in printf.", 0
3321   1CAC 70 65 63 74 
3321   1CB0 65 64 20 66 
3321   1CB4 6F 72 6D 61 
3321   1CB8 74 20 69 6E 
3321   1CBC 20 70 72 69 
3321   1CC0 6E 74 66 2E 
3321   1CC4 00 
3322   1CC5 45 72 72 6F _s4: .db "Error: Unknown argument type.\n", 0
3322   1CC9 72 3A 20 55 
3322   1CCD 6E 6B 6E 6F 
3322   1CD1 77 6E 20 61 
3322   1CD5 72 67 75 6D 
3322   1CD9 65 6E 74 20 
3322   1CDD 74 79 70 65 
3322   1CE1 2E 0A 00 
3323   1CE4 1B 5B 32 4A _s5: .db "\033[2J\033[H", 0
3323   1CE8 1B 5B 48 00 
3324   1CEC             
3325   1CEC EE 1C       _heap_top: .dw _heap
3326   1CEE 00          _heap: .db 0
3327   1CEF             ; --- END DATA BLOCK
3328   1CEF             
3329   1CEF             .end
tasm: Number of errors = 0
