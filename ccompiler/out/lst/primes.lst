0001   0000             ; --- FILENAME: programs/primes
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $N 
0011   0408             ; $i 
0012   0408 52 04 00      sub sp, 4
0013   040B             ;; printf("Enter a number to find all prime numbers up to it: "); 
0014   040B 26 9C 16      mov b, __s0 ; "Enter a number to find all prime numbers up to it: "
0015   040E FD AB         swp b
0016   0410 D8            push b
0017   0411 07 45 06      call printf
0018   0414 51 02 00      add sp, 2
0019   0417             ;; N = scann(); 
0020   0417 FA FF FF      lea d, [bp + -1] ; $N
0021   041A DA            push d
0022   041B 07 6C 0F      call scann
0023   041E E7            pop d
0024   041F FD 43         mov [d], b
0025   0421             ;; printf("Prime numbers are: \n"); 
0026   0421 26 D0 16      mov b, __s1 ; "Prime numbers are: \n"
0027   0424 FD AB         swp b
0028   0426 D8            push b
0029   0427 07 45 06      call printf
0030   042A 51 02 00      add sp, 2
0031   042D             ;; for (i = 2; i <= N; i++) { 
0032   042D             _for1_init:
0033   042D FA FD FF      lea d, [bp + -3] ; $i
0034   0430 DA            push d
0035   0431 26 02 00      mov b, $2
0036   0434 E7            pop d
0037   0435 FD 43         mov [d], b
0038   0437             _for1_cond:
0039   0437 FA FD FF      lea d, [bp + -3] ; $i
0040   043A 2A            mov b, [d]
0041   043B             ; START RELATIONAL
0042   043B D7            push a
0043   043C 11            mov a, b
0044   043D FA FF FF      lea d, [bp + -1] ; $N
0045   0440 2A            mov b, [d]
0046   0441 B0            cmp a, b
0047   0442 FD 76         sleu ; <= (unsigned)
0048   0444 E4            pop a
0049   0445             ; END RELATIONAL
0050   0445 C0 00 00      cmp b, 0
0051   0448 C6 84 04      je _for1_exit
0052   044B             _for1_block:
0053   044B             ;; if (isPrime(i)) { 
0054   044B             _if2_cond:
0055   044B FA FD FF      lea d, [bp + -3] ; $i
0056   044E 2A            mov b, [d]
0057   044F FD AB         swp b
0058   0451 D8            push b
0059   0452 07 17 16      call isPrime
0060   0455 51 02 00      add sp, 2
0061   0458 C0 00 00      cmp b, 0
0062   045B C6 74 04      je _if2_exit
0063   045E             _if2_true:
0064   045E             ;; printf("%d\n", i); 
0065   045E FA FD FF      lea d, [bp + -3] ; $i
0066   0461 2A            mov b, [d]
0067   0462 FD AB         swp b
0068   0464 D8            push b
0069   0465 26 E5 16      mov b, __s2 ; "%d\n"
0070   0468 FD AB         swp b
0071   046A D8            push b
0072   046B 07 45 06      call printf
0073   046E 51 04 00      add sp, 4
0074   0471 0A 74 04      jmp _if2_exit
0075   0474             _if2_exit:
0076   0474             _for1_update:
0077   0474 FA FD FF      lea d, [bp + -3] ; $i
0078   0477 2A            mov b, [d]
0079   0478 D8            push b
0080   0479 FD 77         inc b
0081   047B FA FD FF      lea d, [bp + -3] ; $i
0082   047E FD 43         mov [d], b
0083   0480 E5            pop b
0084   0481 0A 37 04      jmp _for1_cond
0085   0484             _for1_exit:
0086   0484             ;; return 0; 
0087   0484 26 00 00      mov b, $0
0088   0487 F9            leave
0089   0488 05 0B         syscall sys_terminate_proc
0090   048A             
0091   048A             strcpy:
0092   048A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0093   048D             ; $psrc 
0094   048D             ; $pdest 
0095   048D 52 04 00      sub sp, 4
0096   0490             ;; psrc = src; 
0097   0490 FA FF FF      lea d, [bp + -1] ; $psrc
0098   0493 DA            push d
0099   0494 FA 07 00      lea d, [bp + 7] ; $src
0100   0497 2A            mov b, [d]
0101   0498 E7            pop d
0102   0499 FD 43         mov [d], b
0103   049B             ;; pdest = dest; 
0104   049B FA FD FF      lea d, [bp + -3] ; $pdest
0105   049E DA            push d
0106   049F FA 05 00      lea d, [bp + 5] ; $dest
0107   04A2 2A            mov b, [d]
0108   04A3 E7            pop d
0109   04A4 FD 43         mov [d], b
0110   04A6             ;; while(*psrc) *pdest++ = *psrc++; 
0111   04A6             _while3_cond:
0112   04A6 FA FF FF      lea d, [bp + -1] ; $psrc
0113   04A9 2A            mov b, [d]
0114   04AA 74            mov d, b
0115   04AB 32            mov bl, [d]
0116   04AC A7 00         mov bh, 0
0117   04AE C0 00 00      cmp b, 0
0118   04B1 C6 D9 04      je _while3_exit
0119   04B4             _while3_block:
0120   04B4             ;; *pdest++ = *psrc++; 
0121   04B4 FA FD FF      lea d, [bp + -3] ; $pdest
0122   04B7 2A            mov b, [d]
0123   04B8 D8            push b
0124   04B9 FD 77         inc b
0125   04BB FA FD FF      lea d, [bp + -3] ; $pdest
0126   04BE FD 43         mov [d], b
0127   04C0 E5            pop b
0128   04C1 D8            push b
0129   04C2 FA FF FF      lea d, [bp + -1] ; $psrc
0130   04C5 2A            mov b, [d]
0131   04C6 D8            push b
0132   04C7 FD 77         inc b
0133   04C9 FA FF FF      lea d, [bp + -1] ; $psrc
0134   04CC FD 43         mov [d], b
0135   04CE E5            pop b
0136   04CF 74            mov d, b
0137   04D0 32            mov bl, [d]
0138   04D1 A7 00         mov bh, 0
0139   04D3 E7            pop d
0140   04D4 FD 3E         mov [d], bl
0141   04D6 0A A6 04      jmp _while3_cond
0142   04D9             _while3_exit:
0143   04D9             ;; *pdest = '\0'; 
0144   04D9 FA FD FF      lea d, [bp + -3] ; $pdest
0145   04DC 2A            mov b, [d]
0146   04DD D8            push b
0147   04DE 26 00 00      mov b, $0
0148   04E1 E7            pop d
0149   04E2 FD 3E         mov [d], bl
0150   04E4 F9            leave
0151   04E5 09            ret
0152   04E6             
0153   04E6             strcmp:
0154   04E6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0155   04E9             ;; while (*s1 && (*s1 == *s2)) { 
0156   04E9             _while4_cond:
0157   04E9 FA 05 00      lea d, [bp + 5] ; $s1
0158   04EC 2A            mov b, [d]
0159   04ED 74            mov d, b
0160   04EE 32            mov bl, [d]
0161   04EF A7 00         mov bh, 0
0162   04F1 D7            push a
0163   04F2 11            mov a, b
0164   04F3 FA 05 00      lea d, [bp + 5] ; $s1
0165   04F6 2A            mov b, [d]
0166   04F7 74            mov d, b
0167   04F8 32            mov bl, [d]
0168   04F9 A7 00         mov bh, 0
0169   04FB             ; START RELATIONAL
0170   04FB D7            push a
0171   04FC 11            mov a, b
0172   04FD FA 07 00      lea d, [bp + 7] ; $s2
0173   0500 2A            mov b, [d]
0174   0501 74            mov d, b
0175   0502 32            mov bl, [d]
0176   0503 A7 00         mov bh, 0
0177   0505 B0            cmp a, b
0178   0506 FD 71         seq ; ==
0179   0508 E4            pop a
0180   0509             ; END RELATIONAL
0181   0509 FD A7         sand a, b ; &&
0182   050B E4            pop a
0183   050C C0 00 00      cmp b, 0
0184   050F C6 2F 05      je _while4_exit
0185   0512             _while4_block:
0186   0512             ;; s1++; 
0187   0512 FA 05 00      lea d, [bp + 5] ; $s1
0188   0515 2A            mov b, [d]
0189   0516 D8            push b
0190   0517 FD 77         inc b
0191   0519 FA 05 00      lea d, [bp + 5] ; $s1
0192   051C FD 43         mov [d], b
0193   051E E5            pop b
0194   051F             ;; s2++; 
0195   051F FA 07 00      lea d, [bp + 7] ; $s2
0196   0522 2A            mov b, [d]
0197   0523 D8            push b
0198   0524 FD 77         inc b
0199   0526 FA 07 00      lea d, [bp + 7] ; $s2
0200   0529 FD 43         mov [d], b
0201   052B E5            pop b
0202   052C 0A E9 04      jmp _while4_cond
0203   052F             _while4_exit:
0204   052F             ;; return *s1 - *s2; 
0205   052F FA 05 00      lea d, [bp + 5] ; $s1
0206   0532 2A            mov b, [d]
0207   0533 74            mov d, b
0208   0534 32            mov bl, [d]
0209   0535 A7 00         mov bh, 0
0210   0537             ; START TERMS
0211   0537 D7            push a
0212   0538 11            mov a, b
0213   0539 FA 07 00      lea d, [bp + 7] ; $s2
0214   053C 2A            mov b, [d]
0215   053D 74            mov d, b
0216   053E 32            mov bl, [d]
0217   053F A7 00         mov bh, 0
0218   0541 60            sub a, b
0219   0542 27            mov b, a
0220   0543 E4            pop a
0221   0544             ; END TERMS
0222   0544 F9            leave
0223   0545 09            ret
0224   0546             
0225   0546             strcat:
0226   0546 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0227   0549             ; $dest_len 
0228   0549             ; $i 
0229   0549 52 04 00      sub sp, 4
0230   054C             ;; dest_len = strlen(dest); 
0231   054C FA FF FF      lea d, [bp + -1] ; $dest_len
0232   054F DA            push d
0233   0550 FA 05 00      lea d, [bp + 5] ; $dest
0234   0553 2A            mov b, [d]
0235   0554 FD AB         swp b
0236   0556 D8            push b
0237   0557 07 FC 05      call strlen
0238   055A 51 02 00      add sp, 2
0239   055D E7            pop d
0240   055E FD 43         mov [d], b
0241   0560             ;; for (i = 0; src[i] != 0; i=i+1) { 
0242   0560             _for5_init:
0243   0560 FA FD FF      lea d, [bp + -3] ; $i
0244   0563 DA            push d
0245   0564 26 00 00      mov b, $0
0246   0567 E7            pop d
0247   0568 FD 43         mov [d], b
0248   056A             _for5_cond:
0249   056A FA 07 00      lea d, [bp + 7] ; $src
0250   056D FD 2A         mov d, [d]
0251   056F D7            push a
0252   0570 DA            push d
0253   0571 FA FD FF      lea d, [bp + -3] ; $i
0254   0574 2A            mov b, [d]
0255   0575 E7            pop d
0256   0576 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0257   057A E4            pop a
0258   057B 32            mov bl, [d]
0259   057C A7 00         mov bh, 0
0260   057E             ; START RELATIONAL
0261   057E D7            push a
0262   057F 11            mov a, b
0263   0580 26 00 00      mov b, $0
0264   0583 B0            cmp a, b
0265   0584 FD 72         sneq ; !=
0266   0586 E4            pop a
0267   0587             ; END RELATIONAL
0268   0587 C0 00 00      cmp b, 0
0269   058A C6 D5 05      je _for5_exit
0270   058D             _for5_block:
0271   058D             ;; dest[dest_len + i] = src[i]; 
0272   058D FA 05 00      lea d, [bp + 5] ; $dest
0273   0590 FD 2A         mov d, [d]
0274   0592 D7            push a
0275   0593 DA            push d
0276   0594 FA FF FF      lea d, [bp + -1] ; $dest_len
0277   0597 2A            mov b, [d]
0278   0598             ; START TERMS
0279   0598 D7            push a
0280   0599 11            mov a, b
0281   059A FA FD FF      lea d, [bp + -3] ; $i
0282   059D 2A            mov b, [d]
0283   059E 54            add a, b
0284   059F 27            mov b, a
0285   05A0 E4            pop a
0286   05A1             ; END TERMS
0287   05A1 E7            pop d
0288   05A2 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0289   05A6 E4            pop a
0290   05A7 DA            push d
0291   05A8 FA 07 00      lea d, [bp + 7] ; $src
0292   05AB FD 2A         mov d, [d]
0293   05AD D7            push a
0294   05AE DA            push d
0295   05AF FA FD FF      lea d, [bp + -3] ; $i
0296   05B2 2A            mov b, [d]
0297   05B3 E7            pop d
0298   05B4 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0299   05B8 E4            pop a
0300   05B9 32            mov bl, [d]
0301   05BA A7 00         mov bh, 0
0302   05BC E7            pop d
0303   05BD FD 3E         mov [d], bl
0304   05BF             _for5_update:
0305   05BF FA FD FF      lea d, [bp + -3] ; $i
0306   05C2 DA            push d
0307   05C3 FA FD FF      lea d, [bp + -3] ; $i
0308   05C6 2A            mov b, [d]
0309   05C7             ; START TERMS
0310   05C7 D7            push a
0311   05C8 11            mov a, b
0312   05C9 26 01 00      mov b, $1
0313   05CC 54            add a, b
0314   05CD 27            mov b, a
0315   05CE E4            pop a
0316   05CF             ; END TERMS
0317   05CF E7            pop d
0318   05D0 FD 43         mov [d], b
0319   05D2 0A 6A 05      jmp _for5_cond
0320   05D5             _for5_exit:
0321   05D5             ;; dest[dest_len + i] = 0; 
0322   05D5 FA 05 00      lea d, [bp + 5] ; $dest
0323   05D8 FD 2A         mov d, [d]
0324   05DA D7            push a
0325   05DB DA            push d
0326   05DC FA FF FF      lea d, [bp + -1] ; $dest_len
0327   05DF 2A            mov b, [d]
0328   05E0             ; START TERMS
0329   05E0 D7            push a
0330   05E1 11            mov a, b
0331   05E2 FA FD FF      lea d, [bp + -3] ; $i
0332   05E5 2A            mov b, [d]
0333   05E6 54            add a, b
0334   05E7 27            mov b, a
0335   05E8 E4            pop a
0336   05E9             ; END TERMS
0337   05E9 E7            pop d
0338   05EA FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0339   05EE E4            pop a
0340   05EF DA            push d
0341   05F0 26 00 00      mov b, $0
0342   05F3 E7            pop d
0343   05F4 FD 3E         mov [d], bl
0344   05F6             ;; return dest; 
0345   05F6 FA 05 00      lea d, [bp + 5] ; $dest
0346   05F9 2A            mov b, [d]
0347   05FA F9            leave
0348   05FB 09            ret
0349   05FC             
0350   05FC             strlen:
0351   05FC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0352   05FF             ; $length 
0353   05FF 52 02 00      sub sp, 2
0354   0602             ;; length = 0; 
0355   0602 FA FF FF      lea d, [bp + -1] ; $length
0356   0605 DA            push d
0357   0606 26 00 00      mov b, $0
0358   0609 E7            pop d
0359   060A FD 43         mov [d], b
0360   060C             ;; while (str[length] != 0) { 
0361   060C             _while6_cond:
0362   060C FA 05 00      lea d, [bp + 5] ; $str
0363   060F FD 2A         mov d, [d]
0364   0611 D7            push a
0365   0612 DA            push d
0366   0613 FA FF FF      lea d, [bp + -1] ; $length
0367   0616 2A            mov b, [d]
0368   0617 E7            pop d
0369   0618 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0370   061C E4            pop a
0371   061D 32            mov bl, [d]
0372   061E A7 00         mov bh, 0
0373   0620             ; START RELATIONAL
0374   0620 D7            push a
0375   0621 11            mov a, b
0376   0622 26 00 00      mov b, $0
0377   0625 B0            cmp a, b
0378   0626 FD 72         sneq ; !=
0379   0628 E4            pop a
0380   0629             ; END RELATIONAL
0381   0629 C0 00 00      cmp b, 0
0382   062C C6 3F 06      je _while6_exit
0383   062F             _while6_block:
0384   062F             ;; length++; 
0385   062F FA FF FF      lea d, [bp + -1] ; $length
0386   0632 2A            mov b, [d]
0387   0633 D8            push b
0388   0634 FD 77         inc b
0389   0636 FA FF FF      lea d, [bp + -1] ; $length
0390   0639 FD 43         mov [d], b
0391   063B E5            pop b
0392   063C 0A 0C 06      jmp _while6_cond
0393   063F             _while6_exit:
0394   063F             ;; return length; 
0395   063F FA FF FF      lea d, [bp + -1] ; $length
0396   0642 2A            mov b, [d]
0397   0643 F9            leave
0398   0644 09            ret
0399   0645             
0400   0645             printf:
0401   0645 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0402   0648             ; $p 
0403   0648             ; $fp 
0404   0648             ; $i 
0405   0648 52 06 00      sub sp, 6
0406   064B             ;; fp = format; 
0407   064B FA FD FF      lea d, [bp + -3] ; $fp
0408   064E DA            push d
0409   064F FA 05 00      lea d, [bp + 5] ; $format
0410   0652 2A            mov b, [d]
0411   0653 E7            pop d
0412   0654 FD 43         mov [d], b
0413   0656             ;; p = &format + 2; 
0414   0656 FA FF FF      lea d, [bp + -1] ; $p
0415   0659 DA            push d
0416   065A FA 05 00      lea d, [bp + 5] ; $format
0417   065D 2D            mov b, d
0418   065E             ; START TERMS
0419   065E D7            push a
0420   065F 11            mov a, b
0421   0660 26 02 00      mov b, $2
0422   0663 54            add a, b
0423   0664 27            mov b, a
0424   0665 E4            pop a
0425   0666             ; END TERMS
0426   0666 E7            pop d
0427   0667 FD 43         mov [d], b
0428   0669             ;; for(;;){ 
0429   0669             _for7_init:
0430   0669             _for7_cond:
0431   0669             _for7_block:
0432   0669             ;; if(!*fp) break; 
0433   0669             _if8_cond:
0434   0669 FA FD FF      lea d, [bp + -3] ; $fp
0435   066C 2A            mov b, [d]
0436   066D 74            mov d, b
0437   066E 32            mov bl, [d]
0438   066F A7 00         mov bh, 0
0439   0671 C0 00 00      cmp b, 0
0440   0674 FD 71         seq ; !
0441   0676 C0 00 00      cmp b, 0
0442   0679 C6 82 06      je _if8_else
0443   067C             _if8_true:
0444   067C             ;; break; 
0445   067C 0A 91 08      jmp _for7_exit ; for break
0446   067F 0A 8E 08      jmp _if8_exit
0447   0682             _if8_else:
0448   0682             ;; if(*fp == '%'){ 
0449   0682             _if9_cond:
0450   0682 FA FD FF      lea d, [bp + -3] ; $fp
0451   0685 2A            mov b, [d]
0452   0686 74            mov d, b
0453   0687 32            mov bl, [d]
0454   0688 A7 00         mov bh, 0
0455   068A             ; START RELATIONAL
0456   068A D7            push a
0457   068B 11            mov a, b
0458   068C 26 25 00      mov b, $25
0459   068F B0            cmp a, b
0460   0690 FD 71         seq ; ==
0461   0692 E4            pop a
0462   0693             ; END RELATIONAL
0463   0693 C0 00 00      cmp b, 0
0464   0696 C6 72 08      je _if9_else
0465   0699             _if9_true:
0466   0699             ;; fp++; 
0467   0699 FA FD FF      lea d, [bp + -3] ; $fp
0468   069C 2A            mov b, [d]
0469   069D D8            push b
0470   069E FD 77         inc b
0471   06A0 FA FD FF      lea d, [bp + -3] ; $fp
0472   06A3 FD 43         mov [d], b
0473   06A5 E5            pop b
0474   06A6             ;; switch(*fp){ 
0475   06A6             _switch10_expr:
0476   06A6 FA FD FF      lea d, [bp + -3] ; $fp
0477   06A9 2A            mov b, [d]
0478   06AA 74            mov d, b
0479   06AB 32            mov bl, [d]
0480   06AC A7 00         mov bh, 0
0481   06AE             _switch10_comparisons:
0482   06AE C1 6C         cmp bl, $6c
0483   06B0 C6 DC 06      je _switch10_case0
0484   06B3 C1 4C         cmp bl, $4c
0485   06B5 C6 DC 06      je _switch10_case1
0486   06B8 C1 64         cmp bl, $64
0487   06BA C6 AD 07      je _switch10_case2
0488   06BD C1 69         cmp bl, $69
0489   06BF C6 AD 07      je _switch10_case3
0490   06C2 C1 75         cmp bl, $75
0491   06C4 C6 D2 07      je _switch10_case4
0492   06C7 C1 78         cmp bl, $78
0493   06C9 C6 F7 07      je _switch10_case5
0494   06CC C1 63         cmp bl, $63
0495   06CE C6 16 08      je _switch10_case6
0496   06D1 C1 73         cmp bl, $73
0497   06D3 C6 36 08      je _switch10_case7
0498   06D6 0A 56 08      jmp _switch10_default
0499   06D9 0A 62 08      jmp _switch10_exit
0500   06DC             _switch10_case0:
0501   06DC             _switch10_case1:
0502   06DC             ;; fp++; 
0503   06DC FA FD FF      lea d, [bp + -3] ; $fp
0504   06DF 2A            mov b, [d]
0505   06E0 D8            push b
0506   06E1 FD 77         inc b
0507   06E3 FA FD FF      lea d, [bp + -3] ; $fp
0508   06E6 FD 43         mov [d], b
0509   06E8 E5            pop b
0510   06E9             ;; if(*fp == 'd' || *fp == 'i') 
0511   06E9             _if11_cond:
0512   06E9 FA FD FF      lea d, [bp + -3] ; $fp
0513   06EC 2A            mov b, [d]
0514   06ED 74            mov d, b
0515   06EE 32            mov bl, [d]
0516   06EF A7 00         mov bh, 0
0517   06F1             ; START RELATIONAL
0518   06F1 D7            push a
0519   06F2 11            mov a, b
0520   06F3 26 64 00      mov b, $64
0521   06F6 B0            cmp a, b
0522   06F7 FD 71         seq ; ==
0523   06F9 E4            pop a
0524   06FA             ; END RELATIONAL
0525   06FA D7            push a
0526   06FB 11            mov a, b
0527   06FC FA FD FF      lea d, [bp + -3] ; $fp
0528   06FF 2A            mov b, [d]
0529   0700 74            mov d, b
0530   0701 32            mov bl, [d]
0531   0702 A7 00         mov bh, 0
0532   0704             ; START RELATIONAL
0533   0704 D7            push a
0534   0705 11            mov a, b
0535   0706 26 69 00      mov b, $69
0536   0709 B0            cmp a, b
0537   070A FD 71         seq ; ==
0538   070C E4            pop a
0539   070D             ; END RELATIONAL
0540   070D FD A8         sor a, b ; ||
0541   070F E4            pop a
0542   0710 C0 00 00      cmp b, 0
0543   0713 C6 2A 07      je _if11_else
0544   0716             _if11_true:
0545   0716             ;; print_signed_long(*(long *)p); 
0546   0716 FD 79         mov g, b
0547   0718 28            mov b, c
0548   0719 FD AB         swp b
0549   071B D8            push b
0550   071C FD 27         mov b, g
0551   071E FD AB         swp b
0552   0720 D8            push b
0553   0721 07 35 0C      call print_signed_long
0554   0724 51 04 00      add sp, 4
0555   0727 0A 97 07      jmp _if11_exit
0556   072A             _if11_else:
0557   072A             ;; if(*fp == 'u') 
0558   072A             _if12_cond:
0559   072A FA FD FF      lea d, [bp + -3] ; $fp
0560   072D 2A            mov b, [d]
0561   072E 74            mov d, b
0562   072F 32            mov bl, [d]
0563   0730 A7 00         mov bh, 0
0564   0732             ; START RELATIONAL
0565   0732 D7            push a
0566   0733 11            mov a, b
0567   0734 26 75 00      mov b, $75
0568   0737 B0            cmp a, b
0569   0738 FD 71         seq ; ==
0570   073A E4            pop a
0571   073B             ; END RELATIONAL
0572   073B C0 00 00      cmp b, 0
0573   073E C6 55 07      je _if12_else
0574   0741             _if12_true:
0575   0741             ;; print_unsigned_long(*(unsigned long *)p); 
0576   0741 FD 79         mov g, b
0577   0743 28            mov b, c
0578   0744 FD AB         swp b
0579   0746 D8            push b
0580   0747 FD 27         mov b, g
0581   0749 FD AB         swp b
0582   074B D8            push b
0583   074C 07 6A 0D      call print_unsigned_long
0584   074F 51 04 00      add sp, 4
0585   0752 0A 97 07      jmp _if12_exit
0586   0755             _if12_else:
0587   0755             ;; if(*fp == 'x') 
0588   0755             _if13_cond:
0589   0755 FA FD FF      lea d, [bp + -3] ; $fp
0590   0758 2A            mov b, [d]
0591   0759 74            mov d, b
0592   075A 32            mov bl, [d]
0593   075B A7 00         mov bh, 0
0594   075D             ; START RELATIONAL
0595   075D D7            push a
0596   075E 11            mov a, b
0597   075F 26 78 00      mov b, $78
0598   0762 B0            cmp a, b
0599   0763 FD 71         seq ; ==
0600   0765 E4            pop a
0601   0766             ; END RELATIONAL
0602   0766 C0 00 00      cmp b, 0
0603   0769 C6 8B 07      je _if13_else
0604   076C             _if13_true:
0605   076C             ;; printx32(*(long int *)p); 
0606   076C FA FF FF      lea d, [bp + -1] ; $p
0607   076F 2A            mov b, [d]
0608   0770 74            mov d, b
0609   0771 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0610   0774 FD 39         mov c, b ; And place it into C
0611   0776 2A            mov b, [d] ; Lower Word in B
0612   0777 FD 79         mov g, b
0613   0779 28            mov b, c
0614   077A FD AB         swp b
0615   077C D8            push b
0616   077D FD 27         mov b, g
0617   077F FD AB         swp b
0618   0781 D8            push b
0619   0782 07 A8 08      call printx32
0620   0785 51 04 00      add sp, 4
0621   0788 0A 97 07      jmp _if13_exit
0622   078B             _if13_else:
0623   078B             ;; err("Unexpected format in printf."); 
0624   078B 26 E9 16      mov b, __s3 ; "Unexpected format in printf."
0625   078E FD AB         swp b
0626   0790 D8            push b
0627   0791 07 93 08      call err
0628   0794 51 02 00      add sp, 2
0629   0797             _if13_exit:
0630   0797             _if12_exit:
0631   0797             _if11_exit:
0632   0797             ;; p = p + 4; 
0633   0797 FA FF FF      lea d, [bp + -1] ; $p
0634   079A DA            push d
0635   079B FA FF FF      lea d, [bp + -1] ; $p
0636   079E 2A            mov b, [d]
0637   079F             ; START TERMS
0638   079F D7            push a
0639   07A0 11            mov a, b
0640   07A1 26 04 00      mov b, $4
0641   07A4 54            add a, b
0642   07A5 27            mov b, a
0643   07A6 E4            pop a
0644   07A7             ; END TERMS
0645   07A7 E7            pop d
0646   07A8 FD 43         mov [d], b
0647   07AA             ;; break; 
0648   07AA 0A 62 08      jmp _switch10_exit ; case break
0649   07AD             _switch10_case2:
0650   07AD             _switch10_case3:
0651   07AD             ;; print_signed(*(int*)p); 
0652   07AD FA FF FF      lea d, [bp + -1] ; $p
0653   07B0 2A            mov b, [d]
0654   07B1 74            mov d, b
0655   07B2 2A            mov b, [d]
0656   07B3 FD AB         swp b
0657   07B5 D8            push b
0658   07B6 07 44 0B      call print_signed
0659   07B9 51 02 00      add sp, 2
0660   07BC             ;; p = p + 2; 
0661   07BC FA FF FF      lea d, [bp + -1] ; $p
0662   07BF DA            push d
0663   07C0 FA FF FF      lea d, [bp + -1] ; $p
0664   07C3 2A            mov b, [d]
0665   07C4             ; START TERMS
0666   07C4 D7            push a
0667   07C5 11            mov a, b
0668   07C6 26 02 00      mov b, $2
0669   07C9 54            add a, b
0670   07CA 27            mov b, a
0671   07CB E4            pop a
0672   07CC             ; END TERMS
0673   07CC E7            pop d
0674   07CD FD 43         mov [d], b
0675   07CF             ;; break; 
0676   07CF 0A 62 08      jmp _switch10_exit ; case break
0677   07D2             _switch10_case4:
0678   07D2             ;; print_unsigned(*(unsigned int*)p); 
0679   07D2 FA FF FF      lea d, [bp + -1] ; $p
0680   07D5 2A            mov b, [d]
0681   07D6 74            mov d, b
0682   07D7 2A            mov b, [d]
0683   07D8 FD AB         swp b
0684   07DA D8            push b
0685   07DB 07 61 0E      call print_unsigned
0686   07DE 51 02 00      add sp, 2
0687   07E1             ;; p = p + 2; 
0688   07E1 FA FF FF      lea d, [bp + -1] ; $p
0689   07E4 DA            push d
0690   07E5 FA FF FF      lea d, [bp + -1] ; $p
0691   07E8 2A            mov b, [d]
0692   07E9             ; START TERMS
0693   07E9 D7            push a
0694   07EA 11            mov a, b
0695   07EB 26 02 00      mov b, $2
0696   07EE 54            add a, b
0697   07EF 27            mov b, a
0698   07F0 E4            pop a
0699   07F1             ; END TERMS
0700   07F1 E7            pop d
0701   07F2 FD 43         mov [d], b
0702   07F4             ;; break; 
0703   07F4 0A 62 08      jmp _switch10_exit ; case break
0704   07F7             _switch10_case5:
0705   07F7             
0706   07F7             ; --- BEGIN INLINE ASM BLOCK
0707   07F7 FA FF FF      lea d, [bp + -1] ; $p
0708   07FA FD 2A         mov d, [d]
0709   07FC 2A            mov b, [d]
0710   07FD 07 12 13      call print_u16x
0711   0800             ; --- END INLINE ASM BLOCK
0712   0800             
0713   0800             ;; p = p + 2; 
0714   0800 FA FF FF      lea d, [bp + -1] ; $p
0715   0803 DA            push d
0716   0804 FA FF FF      lea d, [bp + -1] ; $p
0717   0807 2A            mov b, [d]
0718   0808             ; START TERMS
0719   0808 D7            push a
0720   0809 11            mov a, b
0721   080A 26 02 00      mov b, $2
0722   080D 54            add a, b
0723   080E 27            mov b, a
0724   080F E4            pop a
0725   0810             ; END TERMS
0726   0810 E7            pop d
0727   0811 FD 43         mov [d], b
0728   0813             ;; break; 
0729   0813 0A 62 08      jmp _switch10_exit ; case break
0730   0816             _switch10_case6:
0731   0816             
0732   0816             ; --- BEGIN INLINE ASM BLOCK
0733   0816 FA FF FF      lea d, [bp + -1] ; $p
0734   0819 FD 2A         mov d, [d]
0735   081B 1E            mov al, [d]
0736   081C 23            mov ah, al
0737   081D 07 70 11      call _putchar
0738   0820             ; --- END INLINE ASM BLOCK
0739   0820             
0740   0820             ;; p = p + 2; 
0741   0820 FA FF FF      lea d, [bp + -1] ; $p
0742   0823 DA            push d
0743   0824 FA FF FF      lea d, [bp + -1] ; $p
0744   0827 2A            mov b, [d]
0745   0828             ; START TERMS
0746   0828 D7            push a
0747   0829 11            mov a, b
0748   082A 26 02 00      mov b, $2
0749   082D 54            add a, b
0750   082E 27            mov b, a
0751   082F E4            pop a
0752   0830             ; END TERMS
0753   0830 E7            pop d
0754   0831 FD 43         mov [d], b
0755   0833             ;; break; 
0756   0833 0A 62 08      jmp _switch10_exit ; case break
0757   0836             _switch10_case7:
0758   0836             
0759   0836             ; --- BEGIN INLINE ASM BLOCK
0760   0836 FA FF FF      lea d, [bp + -1] ; $p
0761   0839 FD 2A         mov d, [d]
0762   083B FD 2A         mov d, [d]
0763   083D 07 BA 12      call _puts
0764   0840             ; --- END INLINE ASM BLOCK
0765   0840             
0766   0840             ;; p = p + 2; 
0767   0840 FA FF FF      lea d, [bp + -1] ; $p
0768   0843 DA            push d
0769   0844 FA FF FF      lea d, [bp + -1] ; $p
0770   0847 2A            mov b, [d]
0771   0848             ; START TERMS
0772   0848 D7            push a
0773   0849 11            mov a, b
0774   084A 26 02 00      mov b, $2
0775   084D 54            add a, b
0776   084E 27            mov b, a
0777   084F E4            pop a
0778   0850             ; END TERMS
0779   0850 E7            pop d
0780   0851 FD 43         mov [d], b
0781   0853             ;; break; 
0782   0853 0A 62 08      jmp _switch10_exit ; case break
0783   0856             _switch10_default:
0784   0856             ;; print("Error: Unknown argument type.\n"); 
0785   0856 26 06 17      mov b, __s4 ; "Error: Unknown argument type.\n"
0786   0859 FD AB         swp b
0787   085B D8            push b
0788   085C 07 91 0F      call print
0789   085F 51 02 00      add sp, 2
0790   0862             _switch10_exit:
0791   0862             ;; fp++; 
0792   0862 FA FD FF      lea d, [bp + -3] ; $fp
0793   0865 2A            mov b, [d]
0794   0866 D8            push b
0795   0867 FD 77         inc b
0796   0869 FA FD FF      lea d, [bp + -3] ; $fp
0797   086C FD 43         mov [d], b
0798   086E E5            pop b
0799   086F 0A 8E 08      jmp _if9_exit
0800   0872             _if9_else:
0801   0872             ;; putchar(*fp); 
0802   0872 FA FD FF      lea d, [bp + -3] ; $fp
0803   0875 2A            mov b, [d]
0804   0876 74            mov d, b
0805   0877 32            mov bl, [d]
0806   0878 A7 00         mov bh, 0
0807   087A DD            push bl
0808   087B 07 49 0F      call putchar
0809   087E 51 01 00      add sp, 1
0810   0881             ;; fp++; 
0811   0881 FA FD FF      lea d, [bp + -3] ; $fp
0812   0884 2A            mov b, [d]
0813   0885 D8            push b
0814   0886 FD 77         inc b
0815   0888 FA FD FF      lea d, [bp + -3] ; $fp
0816   088B FD 43         mov [d], b
0817   088D E5            pop b
0818   088E             _if9_exit:
0819   088E             _if8_exit:
0820   088E             _for7_update:
0821   088E 0A 69 06      jmp _for7_cond
0822   0891             _for7_exit:
0823   0891 F9            leave
0824   0892 09            ret
0825   0893             
0826   0893             err:
0827   0893 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0828   0896             ;; print(e); 
0829   0896 FA 05 00      lea d, [bp + 5] ; $e
0830   0899 2A            mov b, [d]
0831   089A FD AB         swp b
0832   089C D8            push b
0833   089D 07 91 0F      call print
0834   08A0 51 02 00      add sp, 2
0835   08A3             ;; exit(); 
0836   08A3 07 0B 10      call exit
0837   08A6 F9            leave
0838   08A7 09            ret
0839   08A8             
0840   08A8             printx32:
0841   08A8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0842   08AB             
0843   08AB             ; --- BEGIN INLINE ASM BLOCK
0844   08AB FA 05 00      lea d, [bp + 5] ; $hex
0845   08AE 2B 02 00      mov b, [d+2]
0846   08B1 07 12 13      call print_u16x
0847   08B4 2A            mov b, [d]
0848   08B5 07 12 13      call print_u16x
0849   08B8             ; --- END INLINE ASM BLOCK
0850   08B8             
0851   08B8 F9            leave
0852   08B9 09            ret
0853   08BA             
0854   08BA             printx16:
0855   08BA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0856   08BD             
0857   08BD             ; --- BEGIN INLINE ASM BLOCK
0858   08BD FA 05 00      lea d, [bp + 5] ; $hex
0859   08C0 2A            mov b, [d]
0860   08C1 07 12 13      call print_u16x
0861   08C4             ; --- END INLINE ASM BLOCK
0862   08C4             
0863   08C4 F9            leave
0864   08C5 09            ret
0865   08C6             
0866   08C6             printx8:
0867   08C6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0868   08C9             
0869   08C9             ; --- BEGIN INLINE ASM BLOCK
0870   08C9 FA 05 00      lea d, [bp + 5] ; $hex
0871   08CC 32            mov bl, [d]
0872   08CD 07 56 13      call print_u8x
0873   08D0             ; --- END INLINE ASM BLOCK
0874   08D0             
0875   08D0 F9            leave
0876   08D1 09            ret
0877   08D2             
0878   08D2             hex_to_int:
0879   08D2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0880   08D5             ; $value 
0881   08D5 10 00 00      mov a, $0
0882   08D8 45 FF FF      mov [bp + -1], a
0883   08DB             ; $i 
0884   08DB             ; $hex_char 
0885   08DB             ; $len 
0886   08DB 52 07 00      sub sp, 7
0887   08DE             ;; len = strlen(hex_string); 
0888   08DE FA FA FF      lea d, [bp + -6] ; $len
0889   08E1 DA            push d
0890   08E2 FA 05 00      lea d, [bp + 5] ; $hex_string
0891   08E5 2A            mov b, [d]
0892   08E6 FD AB         swp b
0893   08E8 D8            push b
0894   08E9 07 FC 05      call strlen
0895   08EC 51 02 00      add sp, 2
0896   08EF E7            pop d
0897   08F0 FD 43         mov [d], b
0898   08F2             ;; for (i = 0; i < len; i++) { 
0899   08F2             _for14_init:
0900   08F2 FA FD FF      lea d, [bp + -3] ; $i
0901   08F5 DA            push d
0902   08F6 26 00 00      mov b, $0
0903   08F9 E7            pop d
0904   08FA FD 43         mov [d], b
0905   08FC             _for14_cond:
0906   08FC FA FD FF      lea d, [bp + -3] ; $i
0907   08FF 2A            mov b, [d]
0908   0900             ; START RELATIONAL
0909   0900 D7            push a
0910   0901 11            mov a, b
0911   0902 FA FA FF      lea d, [bp + -6] ; $len
0912   0905 2A            mov b, [d]
0913   0906 B0            cmp a, b
0914   0907 FD 73         slt ; < 
0915   0909 E4            pop a
0916   090A             ; END RELATIONAL
0917   090A C0 00 00      cmp b, 0
0918   090D C6 12 0A      je _for14_exit
0919   0910             _for14_block:
0920   0910             ;; hex_char = hex_string[i]; 
0921   0910 FA FC FF      lea d, [bp + -4] ; $hex_char
0922   0913 DA            push d
0923   0914 FA 05 00      lea d, [bp + 5] ; $hex_string
0924   0917 FD 2A         mov d, [d]
0925   0919 D7            push a
0926   091A DA            push d
0927   091B FA FD FF      lea d, [bp + -3] ; $i
0928   091E 2A            mov b, [d]
0929   091F E7            pop d
0930   0920 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0931   0924 E4            pop a
0932   0925 32            mov bl, [d]
0933   0926 A7 00         mov bh, 0
0934   0928 E7            pop d
0935   0929 FD 3E         mov [d], bl
0936   092B             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0937   092B             _if15_cond:
0938   092B FA FC FF      lea d, [bp + -4] ; $hex_char
0939   092E 32            mov bl, [d]
0940   092F A7 00         mov bh, 0
0941   0931             ; START RELATIONAL
0942   0931 D7            push a
0943   0932 11            mov a, b
0944   0933 26 61 00      mov b, $61
0945   0936 B0            cmp a, b
0946   0937 FD 80         sge ; >=
0947   0939 E4            pop a
0948   093A             ; END RELATIONAL
0949   093A D7            push a
0950   093B 11            mov a, b
0951   093C FA FC FF      lea d, [bp + -4] ; $hex_char
0952   093F 32            mov bl, [d]
0953   0940 A7 00         mov bh, 0
0954   0942             ; START RELATIONAL
0955   0942 D7            push a
0956   0943 11            mov a, b
0957   0944 26 66 00      mov b, $66
0958   0947 B0            cmp a, b
0959   0948 FD 74         sle ; <=
0960   094A E4            pop a
0961   094B             ; END RELATIONAL
0962   094B FD A7         sand a, b ; &&
0963   094D E4            pop a
0964   094E C0 00 00      cmp b, 0
0965   0951 C6 83 09      je _if15_else
0966   0954             _if15_true:
0967   0954             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0968   0954 FA FF FF      lea d, [bp + -1] ; $value
0969   0957 DA            push d
0970   0958 FA FF FF      lea d, [bp + -1] ; $value
0971   095B 2A            mov b, [d]
0972   095C             ; START FACTORS
0973   095C D7            push a
0974   095D 11            mov a, b
0975   095E 26 10 00      mov b, $10
0976   0961 AC            mul a, b ; *
0977   0962 11            mov a, b
0978   0963 27            mov b, a
0979   0964 E4            pop a
0980   0965             ; END FACTORS
0981   0965             ; START TERMS
0982   0965 D7            push a
0983   0966 11            mov a, b
0984   0967 FA FC FF      lea d, [bp + -4] ; $hex_char
0985   096A 32            mov bl, [d]
0986   096B A7 00         mov bh, 0
0987   096D             ; START TERMS
0988   096D D7            push a
0989   096E 11            mov a, b
0990   096F 26 61 00      mov b, $61
0991   0972 60            sub a, b
0992   0973 11            mov a, b
0993   0974 26 0A 00      mov b, $a
0994   0977 54            add a, b
0995   0978 27            mov b, a
0996   0979 E4            pop a
0997   097A             ; END TERMS
0998   097A 54            add a, b
0999   097B 27            mov b, a
1000   097C E4            pop a
1001   097D             ; END TERMS
1002   097D E7            pop d
1003   097E FD 43         mov [d], b
1004   0980 0A 02 0A      jmp _if15_exit
1005   0983             _if15_else:
1006   0983             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1007   0983             _if16_cond:
1008   0983 FA FC FF      lea d, [bp + -4] ; $hex_char
1009   0986 32            mov bl, [d]
1010   0987 A7 00         mov bh, 0
1011   0989             ; START RELATIONAL
1012   0989 D7            push a
1013   098A 11            mov a, b
1014   098B 26 41 00      mov b, $41
1015   098E B0            cmp a, b
1016   098F FD 80         sge ; >=
1017   0991 E4            pop a
1018   0992             ; END RELATIONAL
1019   0992 D7            push a
1020   0993 11            mov a, b
1021   0994 FA FC FF      lea d, [bp + -4] ; $hex_char
1022   0997 32            mov bl, [d]
1023   0998 A7 00         mov bh, 0
1024   099A             ; START RELATIONAL
1025   099A D7            push a
1026   099B 11            mov a, b
1027   099C 26 46 00      mov b, $46
1028   099F B0            cmp a, b
1029   09A0 FD 74         sle ; <=
1030   09A2 E4            pop a
1031   09A3             ; END RELATIONAL
1032   09A3 FD A7         sand a, b ; &&
1033   09A5 E4            pop a
1034   09A6 C0 00 00      cmp b, 0
1035   09A9 C6 DB 09      je _if16_else
1036   09AC             _if16_true:
1037   09AC             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1038   09AC FA FF FF      lea d, [bp + -1] ; $value
1039   09AF DA            push d
1040   09B0 FA FF FF      lea d, [bp + -1] ; $value
1041   09B3 2A            mov b, [d]
1042   09B4             ; START FACTORS
1043   09B4 D7            push a
1044   09B5 11            mov a, b
1045   09B6 26 10 00      mov b, $10
1046   09B9 AC            mul a, b ; *
1047   09BA 11            mov a, b
1048   09BB 27            mov b, a
1049   09BC E4            pop a
1050   09BD             ; END FACTORS
1051   09BD             ; START TERMS
1052   09BD D7            push a
1053   09BE 11            mov a, b
1054   09BF FA FC FF      lea d, [bp + -4] ; $hex_char
1055   09C2 32            mov bl, [d]
1056   09C3 A7 00         mov bh, 0
1057   09C5             ; START TERMS
1058   09C5 D7            push a
1059   09C6 11            mov a, b
1060   09C7 26 41 00      mov b, $41
1061   09CA 60            sub a, b
1062   09CB 11            mov a, b
1063   09CC 26 0A 00      mov b, $a
1064   09CF 54            add a, b
1065   09D0 27            mov b, a
1066   09D1 E4            pop a
1067   09D2             ; END TERMS
1068   09D2 54            add a, b
1069   09D3 27            mov b, a
1070   09D4 E4            pop a
1071   09D5             ; END TERMS
1072   09D5 E7            pop d
1073   09D6 FD 43         mov [d], b
1074   09D8 0A 02 0A      jmp _if16_exit
1075   09DB             _if16_else:
1076   09DB             ;; value = (value * 16) + (hex_char - '0'); 
1077   09DB FA FF FF      lea d, [bp + -1] ; $value
1078   09DE DA            push d
1079   09DF FA FF FF      lea d, [bp + -1] ; $value
1080   09E2 2A            mov b, [d]
1081   09E3             ; START FACTORS
1082   09E3 D7            push a
1083   09E4 11            mov a, b
1084   09E5 26 10 00      mov b, $10
1085   09E8 AC            mul a, b ; *
1086   09E9 11            mov a, b
1087   09EA 27            mov b, a
1088   09EB E4            pop a
1089   09EC             ; END FACTORS
1090   09EC             ; START TERMS
1091   09EC D7            push a
1092   09ED 11            mov a, b
1093   09EE FA FC FF      lea d, [bp + -4] ; $hex_char
1094   09F1 32            mov bl, [d]
1095   09F2 A7 00         mov bh, 0
1096   09F4             ; START TERMS
1097   09F4 D7            push a
1098   09F5 11            mov a, b
1099   09F6 26 30 00      mov b, $30
1100   09F9 60            sub a, b
1101   09FA 27            mov b, a
1102   09FB E4            pop a
1103   09FC             ; END TERMS
1104   09FC 54            add a, b
1105   09FD 27            mov b, a
1106   09FE E4            pop a
1107   09FF             ; END TERMS
1108   09FF E7            pop d
1109   0A00 FD 43         mov [d], b
1110   0A02             _if16_exit:
1111   0A02             _if15_exit:
1112   0A02             _for14_update:
1113   0A02 FA FD FF      lea d, [bp + -3] ; $i
1114   0A05 2A            mov b, [d]
1115   0A06 D8            push b
1116   0A07 FD 77         inc b
1117   0A09 FA FD FF      lea d, [bp + -3] ; $i
1118   0A0C FD 43         mov [d], b
1119   0A0E E5            pop b
1120   0A0F 0A FC 08      jmp _for14_cond
1121   0A12             _for14_exit:
1122   0A12             ;; return value; 
1123   0A12 FA FF FF      lea d, [bp + -1] ; $value
1124   0A15 2A            mov b, [d]
1125   0A16 F9            leave
1126   0A17 09            ret
1127   0A18             
1128   0A18             atoi:
1129   0A18 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1130   0A1B             ; $result 
1131   0A1B 10 00 00      mov a, $0
1132   0A1E 45 FF FF      mov [bp + -1], a
1133   0A21             ; $sign 
1134   0A21 10 01 00      mov a, $1
1135   0A24 45 FD FF      mov [bp + -3], a
1136   0A27 52 04 00      sub sp, 4
1137   0A2A             ;; while (*str == ' ') str++; 
1138   0A2A             _while17_cond:
1139   0A2A FA 05 00      lea d, [bp + 5] ; $str
1140   0A2D 2A            mov b, [d]
1141   0A2E 74            mov d, b
1142   0A2F 32            mov bl, [d]
1143   0A30 A7 00         mov bh, 0
1144   0A32             ; START RELATIONAL
1145   0A32 D7            push a
1146   0A33 11            mov a, b
1147   0A34 26 20 00      mov b, $20
1148   0A37 B0            cmp a, b
1149   0A38 FD 71         seq ; ==
1150   0A3A E4            pop a
1151   0A3B             ; END RELATIONAL
1152   0A3B C0 00 00      cmp b, 0
1153   0A3E C6 51 0A      je _while17_exit
1154   0A41             _while17_block:
1155   0A41             ;; str++; 
1156   0A41 FA 05 00      lea d, [bp + 5] ; $str
1157   0A44 2A            mov b, [d]
1158   0A45 D8            push b
1159   0A46 FD 77         inc b
1160   0A48 FA 05 00      lea d, [bp + 5] ; $str
1161   0A4B FD 43         mov [d], b
1162   0A4D E5            pop b
1163   0A4E 0A 2A 0A      jmp _while17_cond
1164   0A51             _while17_exit:
1165   0A51             ;; if (*str == '-' || *str == '+') { 
1166   0A51             _if18_cond:
1167   0A51 FA 05 00      lea d, [bp + 5] ; $str
1168   0A54 2A            mov b, [d]
1169   0A55 74            mov d, b
1170   0A56 32            mov bl, [d]
1171   0A57 A7 00         mov bh, 0
1172   0A59             ; START RELATIONAL
1173   0A59 D7            push a
1174   0A5A 11            mov a, b
1175   0A5B 26 2D 00      mov b, $2d
1176   0A5E B0            cmp a, b
1177   0A5F FD 71         seq ; ==
1178   0A61 E4            pop a
1179   0A62             ; END RELATIONAL
1180   0A62 D7            push a
1181   0A63 11            mov a, b
1182   0A64 FA 05 00      lea d, [bp + 5] ; $str
1183   0A67 2A            mov b, [d]
1184   0A68 74            mov d, b
1185   0A69 32            mov bl, [d]
1186   0A6A A7 00         mov bh, 0
1187   0A6C             ; START RELATIONAL
1188   0A6C D7            push a
1189   0A6D 11            mov a, b
1190   0A6E 26 2B 00      mov b, $2b
1191   0A71 B0            cmp a, b
1192   0A72 FD 71         seq ; ==
1193   0A74 E4            pop a
1194   0A75             ; END RELATIONAL
1195   0A75 FD A8         sor a, b ; ||
1196   0A77 E4            pop a
1197   0A78 C0 00 00      cmp b, 0
1198   0A7B C6 B4 0A      je _if18_exit
1199   0A7E             _if18_true:
1200   0A7E             ;; if (*str == '-') sign = -1; 
1201   0A7E             _if19_cond:
1202   0A7E FA 05 00      lea d, [bp + 5] ; $str
1203   0A81 2A            mov b, [d]
1204   0A82 74            mov d, b
1205   0A83 32            mov bl, [d]
1206   0A84 A7 00         mov bh, 0
1207   0A86             ; START RELATIONAL
1208   0A86 D7            push a
1209   0A87 11            mov a, b
1210   0A88 26 2D 00      mov b, $2d
1211   0A8B B0            cmp a, b
1212   0A8C FD 71         seq ; ==
1213   0A8E E4            pop a
1214   0A8F             ; END RELATIONAL
1215   0A8F C0 00 00      cmp b, 0
1216   0A92 C6 A4 0A      je _if19_exit
1217   0A95             _if19_true:
1218   0A95             ;; sign = -1; 
1219   0A95 FA FD FF      lea d, [bp + -3] ; $sign
1220   0A98 DA            push d
1221   0A99 26 01 00      mov b, $1
1222   0A9C FD 97         neg b
1223   0A9E E7            pop d
1224   0A9F FD 43         mov [d], b
1225   0AA1 0A A4 0A      jmp _if19_exit
1226   0AA4             _if19_exit:
1227   0AA4             ;; str++; 
1228   0AA4 FA 05 00      lea d, [bp + 5] ; $str
1229   0AA7 2A            mov b, [d]
1230   0AA8 D8            push b
1231   0AA9 FD 77         inc b
1232   0AAB FA 05 00      lea d, [bp + 5] ; $str
1233   0AAE FD 43         mov [d], b
1234   0AB0 E5            pop b
1235   0AB1 0A B4 0A      jmp _if18_exit
1236   0AB4             _if18_exit:
1237   0AB4             ;; while (*str >= '0' && *str <= '9') { 
1238   0AB4             _while20_cond:
1239   0AB4 FA 05 00      lea d, [bp + 5] ; $str
1240   0AB7 2A            mov b, [d]
1241   0AB8 74            mov d, b
1242   0AB9 32            mov bl, [d]
1243   0ABA A7 00         mov bh, 0
1244   0ABC             ; START RELATIONAL
1245   0ABC D7            push a
1246   0ABD 11            mov a, b
1247   0ABE 26 30 00      mov b, $30
1248   0AC1 B0            cmp a, b
1249   0AC2 FD 82         sgeu ; >= (unsigned)
1250   0AC4 E4            pop a
1251   0AC5             ; END RELATIONAL
1252   0AC5 D7            push a
1253   0AC6 11            mov a, b
1254   0AC7 FA 05 00      lea d, [bp + 5] ; $str
1255   0ACA 2A            mov b, [d]
1256   0ACB 74            mov d, b
1257   0ACC 32            mov bl, [d]
1258   0ACD A7 00         mov bh, 0
1259   0ACF             ; START RELATIONAL
1260   0ACF D7            push a
1261   0AD0 11            mov a, b
1262   0AD1 26 39 00      mov b, $39
1263   0AD4 B0            cmp a, b
1264   0AD5 FD 76         sleu ; <= (unsigned)
1265   0AD7 E4            pop a
1266   0AD8             ; END RELATIONAL
1267   0AD8 FD A7         sand a, b ; &&
1268   0ADA E4            pop a
1269   0ADB C0 00 00      cmp b, 0
1270   0ADE C6 1A 0B      je _while20_exit
1271   0AE1             _while20_block:
1272   0AE1             ;; result = result * 10 + (*str - '0'); 
1273   0AE1 FA FF FF      lea d, [bp + -1] ; $result
1274   0AE4 DA            push d
1275   0AE5 FA FF FF      lea d, [bp + -1] ; $result
1276   0AE8 2A            mov b, [d]
1277   0AE9             ; START FACTORS
1278   0AE9 D7            push a
1279   0AEA 11            mov a, b
1280   0AEB 26 0A 00      mov b, $a
1281   0AEE AC            mul a, b ; *
1282   0AEF 11            mov a, b
1283   0AF0 27            mov b, a
1284   0AF1 E4            pop a
1285   0AF2             ; END FACTORS
1286   0AF2             ; START TERMS
1287   0AF2 D7            push a
1288   0AF3 11            mov a, b
1289   0AF4 FA 05 00      lea d, [bp + 5] ; $str
1290   0AF7 2A            mov b, [d]
1291   0AF8 74            mov d, b
1292   0AF9 32            mov bl, [d]
1293   0AFA A7 00         mov bh, 0
1294   0AFC             ; START TERMS
1295   0AFC D7            push a
1296   0AFD 11            mov a, b
1297   0AFE 26 30 00      mov b, $30
1298   0B01 60            sub a, b
1299   0B02 27            mov b, a
1300   0B03 E4            pop a
1301   0B04             ; END TERMS
1302   0B04 54            add a, b
1303   0B05 27            mov b, a
1304   0B06 E4            pop a
1305   0B07             ; END TERMS
1306   0B07 E7            pop d
1307   0B08 FD 43         mov [d], b
1308   0B0A             ;; str++; 
1309   0B0A FA 05 00      lea d, [bp + 5] ; $str
1310   0B0D 2A            mov b, [d]
1311   0B0E D8            push b
1312   0B0F FD 77         inc b
1313   0B11 FA 05 00      lea d, [bp + 5] ; $str
1314   0B14 FD 43         mov [d], b
1315   0B16 E5            pop b
1316   0B17 0A B4 0A      jmp _while20_cond
1317   0B1A             _while20_exit:
1318   0B1A             ;; return sign * result; 
1319   0B1A FA FD FF      lea d, [bp + -3] ; $sign
1320   0B1D 2A            mov b, [d]
1321   0B1E             ; START FACTORS
1322   0B1E D7            push a
1323   0B1F 11            mov a, b
1324   0B20 FA FF FF      lea d, [bp + -1] ; $result
1325   0B23 2A            mov b, [d]
1326   0B24 AC            mul a, b ; *
1327   0B25 11            mov a, b
1328   0B26 27            mov b, a
1329   0B27 E4            pop a
1330   0B28             ; END FACTORS
1331   0B28 F9            leave
1332   0B29 09            ret
1333   0B2A             
1334   0B2A             gets:
1335   0B2A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1336   0B2D             
1337   0B2D             ; --- BEGIN INLINE ASM BLOCK
1338   0B2D FA 05 00      lea d, [bp + 5] ; $s
1339   0B30 15            mov a, [d]
1340   0B31 3C            mov d, a
1341   0B32 07 77 11      call _gets
1342   0B35             ; --- END INLINE ASM BLOCK
1343   0B35             
1344   0B35             ;; return strlen(s); 
1345   0B35 FA 05 00      lea d, [bp + 5] ; $s
1346   0B38 2A            mov b, [d]
1347   0B39 FD AB         swp b
1348   0B3B D8            push b
1349   0B3C 07 FC 05      call strlen
1350   0B3F 51 02 00      add sp, 2
1351   0B42 F9            leave
1352   0B43 09            ret
1353   0B44             
1354   0B44             print_signed:
1355   0B44 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1356   0B47             ; $digits 
1357   0B47             ; $i 
1358   0B47 10 00 00      mov a, $0
1359   0B4A 45 FA FF      mov [bp + -6], a
1360   0B4D 52 07 00      sub sp, 7
1361   0B50             ;; if (num < 0) { 
1362   0B50             _if21_cond:
1363   0B50 FA 05 00      lea d, [bp + 5] ; $num
1364   0B53 2A            mov b, [d]
1365   0B54             ; START RELATIONAL
1366   0B54 D7            push a
1367   0B55 11            mov a, b
1368   0B56 26 00 00      mov b, $0
1369   0B59 B0            cmp a, b
1370   0B5A FD 73         slt ; < 
1371   0B5C E4            pop a
1372   0B5D             ; END RELATIONAL
1373   0B5D C0 00 00      cmp b, 0
1374   0B60 C6 7D 0B      je _if21_else
1375   0B63             _if21_true:
1376   0B63             ;; putchar('-'); 
1377   0B63 26 2D 00      mov b, $2d
1378   0B66 DD            push bl
1379   0B67 07 49 0F      call putchar
1380   0B6A 51 01 00      add sp, 1
1381   0B6D             ;; num = -num; 
1382   0B6D FA 05 00      lea d, [bp + 5] ; $num
1383   0B70 DA            push d
1384   0B71 FA 05 00      lea d, [bp + 5] ; $num
1385   0B74 2A            mov b, [d]
1386   0B75 FD 97         neg b
1387   0B77 E7            pop d
1388   0B78 FD 43         mov [d], b
1389   0B7A 0A 9F 0B      jmp _if21_exit
1390   0B7D             _if21_else:
1391   0B7D             ;; if (num == 0) { 
1392   0B7D             _if22_cond:
1393   0B7D FA 05 00      lea d, [bp + 5] ; $num
1394   0B80 2A            mov b, [d]
1395   0B81             ; START RELATIONAL
1396   0B81 D7            push a
1397   0B82 11            mov a, b
1398   0B83 26 00 00      mov b, $0
1399   0B86 B0            cmp a, b
1400   0B87 FD 71         seq ; ==
1401   0B89 E4            pop a
1402   0B8A             ; END RELATIONAL
1403   0B8A C0 00 00      cmp b, 0
1404   0B8D C6 9F 0B      je _if22_exit
1405   0B90             _if22_true:
1406   0B90             ;; putchar('0'); 
1407   0B90 26 30 00      mov b, $30
1408   0B93 DD            push bl
1409   0B94 07 49 0F      call putchar
1410   0B97 51 01 00      add sp, 1
1411   0B9A             ;; return; 
1412   0B9A F9            leave
1413   0B9B 09            ret
1414   0B9C 0A 9F 0B      jmp _if22_exit
1415   0B9F             _if22_exit:
1416   0B9F             _if21_exit:
1417   0B9F             ;; while (num > 0) { 
1418   0B9F             _while23_cond:
1419   0B9F FA 05 00      lea d, [bp + 5] ; $num
1420   0BA2 2A            mov b, [d]
1421   0BA3             ; START RELATIONAL
1422   0BA3 D7            push a
1423   0BA4 11            mov a, b
1424   0BA5 26 00 00      mov b, $0
1425   0BA8 B0            cmp a, b
1426   0BA9 FD 7F         sgt ; >
1427   0BAB E4            pop a
1428   0BAC             ; END RELATIONAL
1429   0BAC C0 00 00      cmp b, 0
1430   0BAF C6 FA 0B      je _while23_exit
1431   0BB2             _while23_block:
1432   0BB2             ;; digits[i] = '0' + (num % 10); 
1433   0BB2 FA FC FF      lea d, [bp + -4] ; $digits
1434   0BB5 D7            push a
1435   0BB6 DA            push d
1436   0BB7 FA FA FF      lea d, [bp + -6] ; $i
1437   0BBA 2A            mov b, [d]
1438   0BBB E7            pop d
1439   0BBC 5A            add d, b
1440   0BBD E4            pop a
1441   0BBE DA            push d
1442   0BBF 26 30 00      mov b, $30
1443   0BC2             ; START TERMS
1444   0BC2 D7            push a
1445   0BC3 11            mov a, b
1446   0BC4 FA 05 00      lea d, [bp + 5] ; $num
1447   0BC7 2A            mov b, [d]
1448   0BC8             ; START FACTORS
1449   0BC8 D7            push a
1450   0BC9 11            mov a, b
1451   0BCA 26 0A 00      mov b, $a
1452   0BCD AE            div a, b ; 
1453   0BCE 11            mov a, b
1454   0BCF 27            mov b, a
1455   0BD0 E4            pop a
1456   0BD1             ; END FACTORS
1457   0BD1 54            add a, b
1458   0BD2 27            mov b, a
1459   0BD3 E4            pop a
1460   0BD4             ; END TERMS
1461   0BD4 E7            pop d
1462   0BD5 FD 3E         mov [d], bl
1463   0BD7             ;; num = num / 10; 
1464   0BD7 FA 05 00      lea d, [bp + 5] ; $num
1465   0BDA DA            push d
1466   0BDB FA 05 00      lea d, [bp + 5] ; $num
1467   0BDE 2A            mov b, [d]
1468   0BDF             ; START FACTORS
1469   0BDF D7            push a
1470   0BE0 11            mov a, b
1471   0BE1 26 0A 00      mov b, $a
1472   0BE4 AE            div a, b
1473   0BE5 27            mov b, a
1474   0BE6 E4            pop a
1475   0BE7             ; END FACTORS
1476   0BE7 E7            pop d
1477   0BE8 FD 43         mov [d], b
1478   0BEA             ;; i++; 
1479   0BEA FA FA FF      lea d, [bp + -6] ; $i
1480   0BED 2A            mov b, [d]
1481   0BEE D8            push b
1482   0BEF FD 77         inc b
1483   0BF1 FA FA FF      lea d, [bp + -6] ; $i
1484   0BF4 FD 43         mov [d], b
1485   0BF6 E5            pop b
1486   0BF7 0A 9F 0B      jmp _while23_cond
1487   0BFA             _while23_exit:
1488   0BFA             ;; while (i > 0) { 
1489   0BFA             _while24_cond:
1490   0BFA FA FA FF      lea d, [bp + -6] ; $i
1491   0BFD 2A            mov b, [d]
1492   0BFE             ; START RELATIONAL
1493   0BFE D7            push a
1494   0BFF 11            mov a, b
1495   0C00 26 00 00      mov b, $0
1496   0C03 B0            cmp a, b
1497   0C04 FD 7F         sgt ; >
1498   0C06 E4            pop a
1499   0C07             ; END RELATIONAL
1500   0C07 C0 00 00      cmp b, 0
1501   0C0A C6 33 0C      je _while24_exit
1502   0C0D             _while24_block:
1503   0C0D             ;; i--; 
1504   0C0D FA FA FF      lea d, [bp + -6] ; $i
1505   0C10 2A            mov b, [d]
1506   0C11 D8            push b
1507   0C12 FD 7D         dec b
1508   0C14 FA FA FF      lea d, [bp + -6] ; $i
1509   0C17 FD 43         mov [d], b
1510   0C19 E5            pop b
1511   0C1A             ;; putchar(digits[i]); 
1512   0C1A FA FC FF      lea d, [bp + -4] ; $digits
1513   0C1D D7            push a
1514   0C1E DA            push d
1515   0C1F FA FA FF      lea d, [bp + -6] ; $i
1516   0C22 2A            mov b, [d]
1517   0C23 E7            pop d
1518   0C24 5A            add d, b
1519   0C25 E4            pop a
1520   0C26 32            mov bl, [d]
1521   0C27 A7 00         mov bh, 0
1522   0C29 DD            push bl
1523   0C2A 07 49 0F      call putchar
1524   0C2D 51 01 00      add sp, 1
1525   0C30 0A FA 0B      jmp _while24_cond
1526   0C33             _while24_exit:
1527   0C33 F9            leave
1528   0C34 09            ret
1529   0C35             
1530   0C35             print_signed_long:
1531   0C35 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1532   0C38             ; $digits 
1533   0C38             ; $i 
1534   0C38 10 00 00      mov a, $0
1535   0C3B 45 F5 FF      mov [bp + -11], a
1536   0C3E 52 0C 00      sub sp, 12
1537   0C41             ;; if (num < 0) { 
1538   0C41             _if25_cond:
1539   0C41 FA 05 00      lea d, [bp + 5] ; $num
1540   0C44 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1541   0C47 FD 39         mov c, b ; And place it into C
1542   0C49 2A            mov b, [d] ; Lower Word in B
1543   0C4A             ; START RELATIONAL
1544   0C4A D7            push a
1545   0C4B FD D8         push g
1546   0C4D 11            mov a, b
1547   0C4E FD 7A         mov g, c
1548   0C50 26 00 00      mov b, $0
1549   0C53 B0            cmp a, b
1550   0C54 FD 73         slt ; < 
1551   0C56 FD F1         pop g
1552   0C58 E4            pop a
1553   0C59             ; END RELATIONAL
1554   0C59 C0 00 00      cmp b, 0
1555   0C5C C6 83 0C      je _if25_else
1556   0C5F             _if25_true:
1557   0C5F             ;; putchar('-'); 
1558   0C5F 26 2D 00      mov b, $2d
1559   0C62 DD            push bl
1560   0C63 07 49 0F      call putchar
1561   0C66 51 01 00      add sp, 1
1562   0C69             ;; num = -num; 
1563   0C69 FA 05 00      lea d, [bp + 5] ; $num
1564   0C6C DA            push d
1565   0C6D FA 05 00      lea d, [bp + 5] ; $num
1566   0C70 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1567   0C73 FD 39         mov c, b ; And place it into C
1568   0C75 2A            mov b, [d] ; Lower Word in B
1569   0C76 FD 97         neg b
1570   0C78 E7            pop d
1571   0C79 FD 43         mov [d], b
1572   0C7B 28            mov b, c
1573   0C7C FD 44 02 00   mov [d + 2], b
1574   0C80 0A BA 0C      jmp _if25_exit
1575   0C83             _if25_else:
1576   0C83             ;; if (num == 0) { 
1577   0C83             _if26_cond:
1578   0C83 FA 05 00      lea d, [bp + 5] ; $num
1579   0C86 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1580   0C89 FD 39         mov c, b ; And place it into C
1581   0C8B 2A            mov b, [d] ; Lower Word in B
1582   0C8C             ; START RELATIONAL
1583   0C8C D7            push a
1584   0C8D FD D8         push g
1585   0C8F 11            mov a, b
1586   0C90 FD 7A         mov g, c
1587   0C92 26 00 00      mov b, $0
1588   0C95 B0            cmp a, b
1589   0C96 FD 71         seq ; ==
1590   0C98 D8            push b
1591   0C99 12            mov a, c
1592   0C9A FD 27         mov b, g
1593   0C9C B0            cmp a, b
1594   0C9D FD 71         seq ; ==
1595   0C9F E4            pop a
1596   0CA0 FD A7         sand a, b
1597   0CA2 FD F1         pop g
1598   0CA4 E4            pop a
1599   0CA5             ; END RELATIONAL
1600   0CA5 C0 00 00      cmp b, 0
1601   0CA8 C6 BA 0C      je _if26_exit
1602   0CAB             _if26_true:
1603   0CAB             ;; putchar('0'); 
1604   0CAB 26 30 00      mov b, $30
1605   0CAE DD            push bl
1606   0CAF 07 49 0F      call putchar
1607   0CB2 51 01 00      add sp, 1
1608   0CB5             ;; return; 
1609   0CB5 F9            leave
1610   0CB6 09            ret
1611   0CB7 0A BA 0C      jmp _if26_exit
1612   0CBA             _if26_exit:
1613   0CBA             _if25_exit:
1614   0CBA             ;; while (num > 0) { 
1615   0CBA             _while27_cond:
1616   0CBA FA 05 00      lea d, [bp + 5] ; $num
1617   0CBD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1618   0CC0 FD 39         mov c, b ; And place it into C
1619   0CC2 2A            mov b, [d] ; Lower Word in B
1620   0CC3             ; START RELATIONAL
1621   0CC3 D7            push a
1622   0CC4 FD D8         push g
1623   0CC6 11            mov a, b
1624   0CC7 FD 7A         mov g, c
1625   0CC9 26 00 00      mov b, $0
1626   0CCC B0            cmp a, b
1627   0CCD FD 7F         sgt ; >
1628   0CCF FD F1         pop g
1629   0CD1 E4            pop a
1630   0CD2             ; END RELATIONAL
1631   0CD2 C0 00 00      cmp b, 0
1632   0CD5 C6 2F 0D      je _while27_exit
1633   0CD8             _while27_block:
1634   0CD8             ;; digits[i] = '0' + (num % 10); 
1635   0CD8 FA F7 FF      lea d, [bp + -9] ; $digits
1636   0CDB D7            push a
1637   0CDC DA            push d
1638   0CDD FA F5 FF      lea d, [bp + -11] ; $i
1639   0CE0 2A            mov b, [d]
1640   0CE1 E7            pop d
1641   0CE2 5A            add d, b
1642   0CE3 E4            pop a
1643   0CE4 DA            push d
1644   0CE5 26 30 00      mov b, $30
1645   0CE8             ; START TERMS
1646   0CE8 D7            push a
1647   0CE9 11            mov a, b
1648   0CEA FA 05 00      lea d, [bp + 5] ; $num
1649   0CED 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1650   0CF0 FD 39         mov c, b ; And place it into C
1651   0CF2 2A            mov b, [d] ; Lower Word in B
1652   0CF3             ; START FACTORS
1653   0CF3 D7            push a
1654   0CF4 11            mov a, b
1655   0CF5 26 0A 00      mov b, $a
1656   0CF8 AE            div a, b ; 
1657   0CF9 11            mov a, b
1658   0CFA 27            mov b, a
1659   0CFB E4            pop a
1660   0CFC             ; END FACTORS
1661   0CFC 54            add a, b
1662   0CFD 27            mov b, a
1663   0CFE E4            pop a
1664   0CFF             ; END TERMS
1665   0CFF E7            pop d
1666   0D00 FD 3E         mov [d], bl
1667   0D02             ;; num = num / 10; 
1668   0D02 FA 05 00      lea d, [bp + 5] ; $num
1669   0D05 DA            push d
1670   0D06 FA 05 00      lea d, [bp + 5] ; $num
1671   0D09 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1672   0D0C FD 39         mov c, b ; And place it into C
1673   0D0E 2A            mov b, [d] ; Lower Word in B
1674   0D0F             ; START FACTORS
1675   0D0F D7            push a
1676   0D10 11            mov a, b
1677   0D11 26 0A 00      mov b, $a
1678   0D14 AE            div a, b
1679   0D15 27            mov b, a
1680   0D16 E4            pop a
1681   0D17             ; END FACTORS
1682   0D17 E7            pop d
1683   0D18 FD 43         mov [d], b
1684   0D1A 28            mov b, c
1685   0D1B FD 44 02 00   mov [d + 2], b
1686   0D1F             ;; i++; 
1687   0D1F FA F5 FF      lea d, [bp + -11] ; $i
1688   0D22 2A            mov b, [d]
1689   0D23 D8            push b
1690   0D24 FD 77         inc b
1691   0D26 FA F5 FF      lea d, [bp + -11] ; $i
1692   0D29 FD 43         mov [d], b
1693   0D2B E5            pop b
1694   0D2C 0A BA 0C      jmp _while27_cond
1695   0D2F             _while27_exit:
1696   0D2F             ;; while (i > 0) { 
1697   0D2F             _while28_cond:
1698   0D2F FA F5 FF      lea d, [bp + -11] ; $i
1699   0D32 2A            mov b, [d]
1700   0D33             ; START RELATIONAL
1701   0D33 D7            push a
1702   0D34 11            mov a, b
1703   0D35 26 00 00      mov b, $0
1704   0D38 B0            cmp a, b
1705   0D39 FD 7F         sgt ; >
1706   0D3B E4            pop a
1707   0D3C             ; END RELATIONAL
1708   0D3C C0 00 00      cmp b, 0
1709   0D3F C6 68 0D      je _while28_exit
1710   0D42             _while28_block:
1711   0D42             ;; i--; 
1712   0D42 FA F5 FF      lea d, [bp + -11] ; $i
1713   0D45 2A            mov b, [d]
1714   0D46 D8            push b
1715   0D47 FD 7D         dec b
1716   0D49 FA F5 FF      lea d, [bp + -11] ; $i
1717   0D4C FD 43         mov [d], b
1718   0D4E E5            pop b
1719   0D4F             ;; putchar(digits[i]); 
1720   0D4F FA F7 FF      lea d, [bp + -9] ; $digits
1721   0D52 D7            push a
1722   0D53 DA            push d
1723   0D54 FA F5 FF      lea d, [bp + -11] ; $i
1724   0D57 2A            mov b, [d]
1725   0D58 E7            pop d
1726   0D59 5A            add d, b
1727   0D5A E4            pop a
1728   0D5B 32            mov bl, [d]
1729   0D5C A7 00         mov bh, 0
1730   0D5E DD            push bl
1731   0D5F 07 49 0F      call putchar
1732   0D62 51 01 00      add sp, 1
1733   0D65 0A 2F 0D      jmp _while28_cond
1734   0D68             _while28_exit:
1735   0D68 F9            leave
1736   0D69 09            ret
1737   0D6A             
1738   0D6A             print_unsigned_long:
1739   0D6A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1740   0D6D             ; $digits 
1741   0D6D             ; $i 
1742   0D6D 52 0C 00      sub sp, 12
1743   0D70             ;; i = 0; 
1744   0D70 FA F5 FF      lea d, [bp + -11] ; $i
1745   0D73 DA            push d
1746   0D74 26 00 00      mov b, $0
1747   0D77 E7            pop d
1748   0D78 FD 43         mov [d], b
1749   0D7A             ;; if(num == 0){ 
1750   0D7A             _if29_cond:
1751   0D7A FA 05 00      lea d, [bp + 5] ; $num
1752   0D7D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1753   0D80 FD 39         mov c, b ; And place it into C
1754   0D82 2A            mov b, [d] ; Lower Word in B
1755   0D83             ; START RELATIONAL
1756   0D83 D7            push a
1757   0D84 FD D8         push g
1758   0D86 11            mov a, b
1759   0D87 FD 7A         mov g, c
1760   0D89 26 00 00      mov b, $0
1761   0D8C B0            cmp a, b
1762   0D8D FD 71         seq ; ==
1763   0D8F D8            push b
1764   0D90 12            mov a, c
1765   0D91 FD 27         mov b, g
1766   0D93 B0            cmp a, b
1767   0D94 FD 71         seq ; ==
1768   0D96 E4            pop a
1769   0D97 FD A7         sand a, b
1770   0D99 FD F1         pop g
1771   0D9B E4            pop a
1772   0D9C             ; END RELATIONAL
1773   0D9C C0 00 00      cmp b, 0
1774   0D9F C6 B1 0D      je _if29_exit
1775   0DA2             _if29_true:
1776   0DA2             ;; putchar('0'); 
1777   0DA2 26 30 00      mov b, $30
1778   0DA5 DD            push bl
1779   0DA6 07 49 0F      call putchar
1780   0DA9 51 01 00      add sp, 1
1781   0DAC             ;; return; 
1782   0DAC F9            leave
1783   0DAD 09            ret
1784   0DAE 0A B1 0D      jmp _if29_exit
1785   0DB1             _if29_exit:
1786   0DB1             ;; while (num > 0) { 
1787   0DB1             _while30_cond:
1788   0DB1 FA 05 00      lea d, [bp + 5] ; $num
1789   0DB4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1790   0DB7 FD 39         mov c, b ; And place it into C
1791   0DB9 2A            mov b, [d] ; Lower Word in B
1792   0DBA             ; START RELATIONAL
1793   0DBA D7            push a
1794   0DBB FD D8         push g
1795   0DBD 11            mov a, b
1796   0DBE FD 7A         mov g, c
1797   0DC0 26 00 00      mov b, $0
1798   0DC3 B0            cmp a, b
1799   0DC4 FD 81         sgu ; > (unsigned)
1800   0DC6 FD F1         pop g
1801   0DC8 E4            pop a
1802   0DC9             ; END RELATIONAL
1803   0DC9 C0 00 00      cmp b, 0
1804   0DCC C6 26 0E      je _while30_exit
1805   0DCF             _while30_block:
1806   0DCF             ;; digits[i] = '0' + (num % 10); 
1807   0DCF FA F7 FF      lea d, [bp + -9] ; $digits
1808   0DD2 D7            push a
1809   0DD3 DA            push d
1810   0DD4 FA F5 FF      lea d, [bp + -11] ; $i
1811   0DD7 2A            mov b, [d]
1812   0DD8 E7            pop d
1813   0DD9 5A            add d, b
1814   0DDA E4            pop a
1815   0DDB DA            push d
1816   0DDC 26 30 00      mov b, $30
1817   0DDF             ; START TERMS
1818   0DDF D7            push a
1819   0DE0 11            mov a, b
1820   0DE1 FA 05 00      lea d, [bp + 5] ; $num
1821   0DE4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1822   0DE7 FD 39         mov c, b ; And place it into C
1823   0DE9 2A            mov b, [d] ; Lower Word in B
1824   0DEA             ; START FACTORS
1825   0DEA D7            push a
1826   0DEB 11            mov a, b
1827   0DEC 26 0A 00      mov b, $a
1828   0DEF AE            div a, b ; 
1829   0DF0 11            mov a, b
1830   0DF1 27            mov b, a
1831   0DF2 E4            pop a
1832   0DF3             ; END FACTORS
1833   0DF3 54            add a, b
1834   0DF4 27            mov b, a
1835   0DF5 E4            pop a
1836   0DF6             ; END TERMS
1837   0DF6 E7            pop d
1838   0DF7 FD 3E         mov [d], bl
1839   0DF9             ;; num = num / 10; 
1840   0DF9 FA 05 00      lea d, [bp + 5] ; $num
1841   0DFC DA            push d
1842   0DFD FA 05 00      lea d, [bp + 5] ; $num
1843   0E00 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1844   0E03 FD 39         mov c, b ; And place it into C
1845   0E05 2A            mov b, [d] ; Lower Word in B
1846   0E06             ; START FACTORS
1847   0E06 D7            push a
1848   0E07 11            mov a, b
1849   0E08 26 0A 00      mov b, $a
1850   0E0B AE            div a, b
1851   0E0C 27            mov b, a
1852   0E0D E4            pop a
1853   0E0E             ; END FACTORS
1854   0E0E E7            pop d
1855   0E0F FD 43         mov [d], b
1856   0E11 28            mov b, c
1857   0E12 FD 44 02 00   mov [d + 2], b
1858   0E16             ;; i++; 
1859   0E16 FA F5 FF      lea d, [bp + -11] ; $i
1860   0E19 2A            mov b, [d]
1861   0E1A D8            push b
1862   0E1B FD 77         inc b
1863   0E1D FA F5 FF      lea d, [bp + -11] ; $i
1864   0E20 FD 43         mov [d], b
1865   0E22 E5            pop b
1866   0E23 0A B1 0D      jmp _while30_cond
1867   0E26             _while30_exit:
1868   0E26             ;; while (i > 0) { 
1869   0E26             _while31_cond:
1870   0E26 FA F5 FF      lea d, [bp + -11] ; $i
1871   0E29 2A            mov b, [d]
1872   0E2A             ; START RELATIONAL
1873   0E2A D7            push a
1874   0E2B 11            mov a, b
1875   0E2C 26 00 00      mov b, $0
1876   0E2F B0            cmp a, b
1877   0E30 FD 7F         sgt ; >
1878   0E32 E4            pop a
1879   0E33             ; END RELATIONAL
1880   0E33 C0 00 00      cmp b, 0
1881   0E36 C6 5F 0E      je _while31_exit
1882   0E39             _while31_block:
1883   0E39             ;; i--; 
1884   0E39 FA F5 FF      lea d, [bp + -11] ; $i
1885   0E3C 2A            mov b, [d]
1886   0E3D D8            push b
1887   0E3E FD 7D         dec b
1888   0E40 FA F5 FF      lea d, [bp + -11] ; $i
1889   0E43 FD 43         mov [d], b
1890   0E45 E5            pop b
1891   0E46             ;; putchar(digits[i]); 
1892   0E46 FA F7 FF      lea d, [bp + -9] ; $digits
1893   0E49 D7            push a
1894   0E4A DA            push d
1895   0E4B FA F5 FF      lea d, [bp + -11] ; $i
1896   0E4E 2A            mov b, [d]
1897   0E4F E7            pop d
1898   0E50 5A            add d, b
1899   0E51 E4            pop a
1900   0E52 32            mov bl, [d]
1901   0E53 A7 00         mov bh, 0
1902   0E55 DD            push bl
1903   0E56 07 49 0F      call putchar
1904   0E59 51 01 00      add sp, 1
1905   0E5C 0A 26 0E      jmp _while31_cond
1906   0E5F             _while31_exit:
1907   0E5F F9            leave
1908   0E60 09            ret
1909   0E61             
1910   0E61             print_unsigned:
1911   0E61 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1912   0E64             ; $digits 
1913   0E64             ; $i 
1914   0E64 52 07 00      sub sp, 7
1915   0E67             ;; i = 0; 
1916   0E67 FA FA FF      lea d, [bp + -6] ; $i
1917   0E6A DA            push d
1918   0E6B 26 00 00      mov b, $0
1919   0E6E E7            pop d
1920   0E6F FD 43         mov [d], b
1921   0E71             ;; if(num == 0){ 
1922   0E71             _if32_cond:
1923   0E71 FA 05 00      lea d, [bp + 5] ; $num
1924   0E74 2A            mov b, [d]
1925   0E75             ; START RELATIONAL
1926   0E75 D7            push a
1927   0E76 11            mov a, b
1928   0E77 26 00 00      mov b, $0
1929   0E7A B0            cmp a, b
1930   0E7B FD 71         seq ; ==
1931   0E7D E4            pop a
1932   0E7E             ; END RELATIONAL
1933   0E7E C0 00 00      cmp b, 0
1934   0E81 C6 93 0E      je _if32_exit
1935   0E84             _if32_true:
1936   0E84             ;; putchar('0'); 
1937   0E84 26 30 00      mov b, $30
1938   0E87 DD            push bl
1939   0E88 07 49 0F      call putchar
1940   0E8B 51 01 00      add sp, 1
1941   0E8E             ;; return; 
1942   0E8E F9            leave
1943   0E8F 09            ret
1944   0E90 0A 93 0E      jmp _if32_exit
1945   0E93             _if32_exit:
1946   0E93             ;; while (num > 0) { 
1947   0E93             _while33_cond:
1948   0E93 FA 05 00      lea d, [bp + 5] ; $num
1949   0E96 2A            mov b, [d]
1950   0E97             ; START RELATIONAL
1951   0E97 D7            push a
1952   0E98 11            mov a, b
1953   0E99 26 00 00      mov b, $0
1954   0E9C B0            cmp a, b
1955   0E9D FD 81         sgu ; > (unsigned)
1956   0E9F E4            pop a
1957   0EA0             ; END RELATIONAL
1958   0EA0 C0 00 00      cmp b, 0
1959   0EA3 C6 EE 0E      je _while33_exit
1960   0EA6             _while33_block:
1961   0EA6             ;; digits[i] = '0' + (num % 10); 
1962   0EA6 FA FC FF      lea d, [bp + -4] ; $digits
1963   0EA9 D7            push a
1964   0EAA DA            push d
1965   0EAB FA FA FF      lea d, [bp + -6] ; $i
1966   0EAE 2A            mov b, [d]
1967   0EAF E7            pop d
1968   0EB0 5A            add d, b
1969   0EB1 E4            pop a
1970   0EB2 DA            push d
1971   0EB3 26 30 00      mov b, $30
1972   0EB6             ; START TERMS
1973   0EB6 D7            push a
1974   0EB7 11            mov a, b
1975   0EB8 FA 05 00      lea d, [bp + 5] ; $num
1976   0EBB 2A            mov b, [d]
1977   0EBC             ; START FACTORS
1978   0EBC D7            push a
1979   0EBD 11            mov a, b
1980   0EBE 26 0A 00      mov b, $a
1981   0EC1 AE            div a, b ; 
1982   0EC2 11            mov a, b
1983   0EC3 27            mov b, a
1984   0EC4 E4            pop a
1985   0EC5             ; END FACTORS
1986   0EC5 54            add a, b
1987   0EC6 27            mov b, a
1988   0EC7 E4            pop a
1989   0EC8             ; END TERMS
1990   0EC8 E7            pop d
1991   0EC9 FD 3E         mov [d], bl
1992   0ECB             ;; num = num / 10; 
1993   0ECB FA 05 00      lea d, [bp + 5] ; $num
1994   0ECE DA            push d
1995   0ECF FA 05 00      lea d, [bp + 5] ; $num
1996   0ED2 2A            mov b, [d]
1997   0ED3             ; START FACTORS
1998   0ED3 D7            push a
1999   0ED4 11            mov a, b
2000   0ED5 26 0A 00      mov b, $a
2001   0ED8 AE            div a, b
2002   0ED9 27            mov b, a
2003   0EDA E4            pop a
2004   0EDB             ; END FACTORS
2005   0EDB E7            pop d
2006   0EDC FD 43         mov [d], b
2007   0EDE             ;; i++; 
2008   0EDE FA FA FF      lea d, [bp + -6] ; $i
2009   0EE1 2A            mov b, [d]
2010   0EE2 D8            push b
2011   0EE3 FD 77         inc b
2012   0EE5 FA FA FF      lea d, [bp + -6] ; $i
2013   0EE8 FD 43         mov [d], b
2014   0EEA E5            pop b
2015   0EEB 0A 93 0E      jmp _while33_cond
2016   0EEE             _while33_exit:
2017   0EEE             ;; while (i > 0) { 
2018   0EEE             _while34_cond:
2019   0EEE FA FA FF      lea d, [bp + -6] ; $i
2020   0EF1 2A            mov b, [d]
2021   0EF2             ; START RELATIONAL
2022   0EF2 D7            push a
2023   0EF3 11            mov a, b
2024   0EF4 26 00 00      mov b, $0
2025   0EF7 B0            cmp a, b
2026   0EF8 FD 7F         sgt ; >
2027   0EFA E4            pop a
2028   0EFB             ; END RELATIONAL
2029   0EFB C0 00 00      cmp b, 0
2030   0EFE C6 27 0F      je _while34_exit
2031   0F01             _while34_block:
2032   0F01             ;; i--; 
2033   0F01 FA FA FF      lea d, [bp + -6] ; $i
2034   0F04 2A            mov b, [d]
2035   0F05 D8            push b
2036   0F06 FD 7D         dec b
2037   0F08 FA FA FF      lea d, [bp + -6] ; $i
2038   0F0B FD 43         mov [d], b
2039   0F0D E5            pop b
2040   0F0E             ;; putchar(digits[i]); 
2041   0F0E FA FC FF      lea d, [bp + -4] ; $digits
2042   0F11 D7            push a
2043   0F12 DA            push d
2044   0F13 FA FA FF      lea d, [bp + -6] ; $i
2045   0F16 2A            mov b, [d]
2046   0F17 E7            pop d
2047   0F18 5A            add d, b
2048   0F19 E4            pop a
2049   0F1A 32            mov bl, [d]
2050   0F1B A7 00         mov bh, 0
2051   0F1D DD            push bl
2052   0F1E 07 49 0F      call putchar
2053   0F21 51 01 00      add sp, 1
2054   0F24 0A EE 0E      jmp _while34_cond
2055   0F27             _while34_exit:
2056   0F27 F9            leave
2057   0F28 09            ret
2058   0F29             
2059   0F29             rand:
2060   0F29 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2061   0F2C             ; $sec 
2062   0F2C 52 01 00      sub sp, 1
2063   0F2F             
2064   0F2F             ; --- BEGIN INLINE ASM BLOCK
2065   0F2F 19 00         mov al, 0
2066   0F31 05 01         syscall sys_rtc					
2067   0F33 1A            mov al, ah
2068   0F34 FA 00 00      lea d, [bp + 0] ; $sec
2069   0F37 1E            mov al, [d]
2070   0F38             ; --- END INLINE ASM BLOCK
2071   0F38             
2072   0F38             ;; return sec; 
2073   0F38 FA 00 00      lea d, [bp + 0] ; $sec
2074   0F3B 32            mov bl, [d]
2075   0F3C A7 00         mov bh, 0
2076   0F3E F9            leave
2077   0F3F 09            ret
2078   0F40             
2079   0F40             date:
2080   0F40 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2081   0F43             
2082   0F43             ; --- BEGIN INLINE ASM BLOCK
2083   0F43 19 00         mov al, 0 
2084   0F45 05 07         syscall sys_datetime
2085   0F47             ; --- END INLINE ASM BLOCK
2086   0F47             
2087   0F47 F9            leave
2088   0F48 09            ret
2089   0F49             
2090   0F49             putchar:
2091   0F49 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2092   0F4C             
2093   0F4C             ; --- BEGIN INLINE ASM BLOCK
2094   0F4C FA 05 00      lea d, [bp + 5] ; $c
2095   0F4F 1E            mov al, [d]
2096   0F50 23            mov ah, al
2097   0F51 07 70 11      call _putchar
2098   0F54             ; --- END INLINE ASM BLOCK
2099   0F54             
2100   0F54 F9            leave
2101   0F55 09            ret
2102   0F56             
2103   0F56             getchar:
2104   0F56 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2105   0F59             ; $c 
2106   0F59 52 01 00      sub sp, 1
2107   0F5C             
2108   0F5C             ; --- BEGIN INLINE ASM BLOCK
2109   0F5C 07 69 11      call getch
2110   0F5F 1A            mov al, ah
2111   0F60 FA 00 00      lea d, [bp + 0] ; $c
2112   0F63 3E            mov [d], al
2113   0F64             ; --- END INLINE ASM BLOCK
2114   0F64             
2115   0F64             ;; return c; 
2116   0F64 FA 00 00      lea d, [bp + 0] ; $c
2117   0F67 32            mov bl, [d]
2118   0F68 A7 00         mov bh, 0
2119   0F6A F9            leave
2120   0F6B 09            ret
2121   0F6C             
2122   0F6C             scann:
2123   0F6C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2124   0F6F             ; $m 
2125   0F6F 52 02 00      sub sp, 2
2126   0F72             
2127   0F72             ; --- BEGIN INLINE ASM BLOCK
2128   0F72 07 B4 13      call scan_u16d
2129   0F75 FA FF FF      lea d, [bp + -1] ; $m
2130   0F78 43            mov [d], a
2131   0F79             ; --- END INLINE ASM BLOCK
2132   0F79             
2133   0F79             ;; return m; 
2134   0F79 FA FF FF      lea d, [bp + -1] ; $m
2135   0F7C 2A            mov b, [d]
2136   0F7D F9            leave
2137   0F7E 09            ret
2138   0F7F             
2139   0F7F             puts:
2140   0F7F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2141   0F82             
2142   0F82             ; --- BEGIN INLINE ASM BLOCK
2143   0F82 FA 05 00      lea d, [bp + 5] ; $s
2144   0F85 15            mov a, [d]
2145   0F86 3C            mov d, a
2146   0F87 07 BA 12      call _puts
2147   0F8A 10 00 0A      mov a, $0A00
2148   0F8D 05 03         syscall sys_io
2149   0F8F             ; --- END INLINE ASM BLOCK
2150   0F8F             
2151   0F8F F9            leave
2152   0F90 09            ret
2153   0F91             
2154   0F91             print:
2155   0F91 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2156   0F94             
2157   0F94             ; --- BEGIN INLINE ASM BLOCK
2158   0F94 FA 05 00      lea d, [bp + 5] ; $s
2159   0F97 FD 2A         mov d, [d]
2160   0F99 07 BA 12      call _puts
2161   0F9C             ; --- END INLINE ASM BLOCK
2162   0F9C             
2163   0F9C F9            leave
2164   0F9D 09            ret
2165   0F9E             
2166   0F9E             loadfile:
2167   0F9E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2168   0FA1             
2169   0FA1             ; --- BEGIN INLINE ASM BLOCK
2170   0FA1 FA 07 00      lea d, [bp + 7] ; $destination
2171   0FA4 15            mov a, [d]
2172   0FA5 4F            mov di, a
2173   0FA6 FA 05 00      lea d, [bp + 5] ; $filename
2174   0FA9 FD 2A         mov d, [d]
2175   0FAB 19 14         mov al, 20
2176   0FAD 05 04         syscall sys_filesystem
2177   0FAF             ; --- END INLINE ASM BLOCK
2178   0FAF             
2179   0FAF F9            leave
2180   0FB0 09            ret
2181   0FB1             
2182   0FB1             create_file:
2183   0FB1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2184   0FB4 F9            leave
2185   0FB5 09            ret
2186   0FB6             
2187   0FB6             delete_file:
2188   0FB6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2189   0FB9             
2190   0FB9             ; --- BEGIN INLINE ASM BLOCK
2191   0FB9 FA 05 00      lea d, [bp + 5] ; $filename
2192   0FBC 19 0A         mov al, 10
2193   0FBE 05 04         syscall sys_filesystem
2194   0FC0             ; --- END INLINE ASM BLOCK
2195   0FC0             
2196   0FC0 F9            leave
2197   0FC1 09            ret
2198   0FC2             
2199   0FC2             fopen:
2200   0FC2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2201   0FC5 F9            leave
2202   0FC6 09            ret
2203   0FC7             
2204   0FC7             fclose:
2205   0FC7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2206   0FCA F9            leave
2207   0FCB 09            ret
2208   0FCC             
2209   0FCC             alloc:
2210   0FCC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2211   0FCF             ;; heap_top = heap_top + bytes; 
2212   0FCF 3B 2D 17      mov d, _heap_top ; $heap_top
2213   0FD2 DA            push d
2214   0FD3 3B 2D 17      mov d, _heap_top ; $heap_top
2215   0FD6 2A            mov b, [d]
2216   0FD7             ; START TERMS
2217   0FD7 D7            push a
2218   0FD8 11            mov a, b
2219   0FD9 FA 05 00      lea d, [bp + 5] ; $bytes
2220   0FDC 2A            mov b, [d]
2221   0FDD 54            add a, b
2222   0FDE 27            mov b, a
2223   0FDF E4            pop a
2224   0FE0             ; END TERMS
2225   0FE0 E7            pop d
2226   0FE1 FD 43         mov [d], b
2227   0FE3             ;; return heap_top - bytes; 
2228   0FE3 3B 2D 17      mov d, _heap_top ; $heap_top
2229   0FE6 2A            mov b, [d]
2230   0FE7             ; START TERMS
2231   0FE7 D7            push a
2232   0FE8 11            mov a, b
2233   0FE9 FA 05 00      lea d, [bp + 5] ; $bytes
2234   0FEC 2A            mov b, [d]
2235   0FED 60            sub a, b
2236   0FEE 27            mov b, a
2237   0FEF E4            pop a
2238   0FF0             ; END TERMS
2239   0FF0 F9            leave
2240   0FF1 09            ret
2241   0FF2             
2242   0FF2             free:
2243   0FF2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2244   0FF5             ;; return heap_top = heap_top - bytes; 
2245   0FF5 3B 2D 17      mov d, _heap_top ; $heap_top
2246   0FF8 DA            push d
2247   0FF9 3B 2D 17      mov d, _heap_top ; $heap_top
2248   0FFC 2A            mov b, [d]
2249   0FFD             ; START TERMS
2250   0FFD D7            push a
2251   0FFE 11            mov a, b
2252   0FFF FA 05 00      lea d, [bp + 5] ; $bytes
2253   1002 2A            mov b, [d]
2254   1003 60            sub a, b
2255   1004 27            mov b, a
2256   1005 E4            pop a
2257   1006             ; END TERMS
2258   1006 E7            pop d
2259   1007 FD 43         mov [d], b
2260   1009 F9            leave
2261   100A 09            ret
2262   100B             
2263   100B             exit:
2264   100B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2265   100E             
2266   100E             ; --- BEGIN INLINE ASM BLOCK
2267   100E 05 0B         syscall sys_terminate_proc
2268   1010             ; --- END INLINE ASM BLOCK
2269   1010             
2270   1010 F9            leave
2271   1011 09            ret
2272   1012             
2273   1012             load_hex:
2274   1012 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2275   1015             ; $temp 
2276   1015 52 02 00      sub sp, 2
2277   1018             ;; temp = alloc(32768); 
2278   1018 FA FF FF      lea d, [bp + -1] ; $temp
2279   101B DA            push d
2280   101C 26 00 80      mov b, $8000
2281   101F FD AB         swp b
2282   1021 D8            push b
2283   1022 07 CC 0F      call alloc
2284   1025 51 02 00      add sp, 2
2285   1028 E7            pop d
2286   1029 FD 43         mov [d], b
2287   102B             
2288   102B             ; --- BEGIN INLINE ASM BLOCK
2289   102B               
2290   102B               
2291   102B               
2292   102B               
2293   102B               
2294   102B             _load_hex:
2295   102B D7            push a
2296   102C D8            push b
2297   102D DA            push d
2298   102E E2            push si
2299   102F E3            push di
2300   1030 52 00 80      sub sp, $8000      
2301   1033 38 00 00      mov c, 0
2302   1036 48            mov a, sp
2303   1037 77            inc a
2304   1038 3C            mov d, a          
2305   1039 07 77 11      call _gets        
2306   103C 4D            mov si, a
2307   103D             __load_hex_loop:
2308   103D F6            lodsb             
2309   103E B9 00         cmp al, 0         
2310   1040 C6 4E 10      jz __load_hex_ret
2311   1043 36            mov bh, al
2312   1044 F6            lodsb
2313   1045 2F            mov bl, al
2314   1046 07 2D 11      call _atoi        
2315   1049 F7            stosb             
2316   104A 78            inc c
2317   104B 0A 3D 10      jmp __load_hex_loop
2318   104E             __load_hex_ret:
2319   104E 51 00 80      add sp, $8000
2320   1051 F0            pop di
2321   1052 EF            pop si
2322   1053 E7            pop d
2323   1054 E5            pop b
2324   1055 E4            pop a
2325   1056             ; --- END INLINE ASM BLOCK
2326   1056             
2327   1056 F9            leave
2328   1057 09            ret
2329   1058             
2330   1058             getparam:
2331   1058 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2332   105B             ; $data 
2333   105B 52 01 00      sub sp, 1
2334   105E             
2335   105E             ; --- BEGIN INLINE ASM BLOCK
2336   105E 19 04         mov al, 4
2337   1060 FA 05 00      lea d, [bp + 5] ; $address
2338   1063 FD 2A         mov d, [d]
2339   1065 05 0C         syscall sys_system
2340   1067 FA 00 00      lea d, [bp + 0] ; $data
2341   106A FD 3E         mov [d], bl
2342   106C             ; --- END INLINE ASM BLOCK
2343   106C             
2344   106C             ;; return data; 
2345   106C FA 00 00      lea d, [bp + 0] ; $data
2346   106F 32            mov bl, [d]
2347   1070 A7 00         mov bh, 0
2348   1072 F9            leave
2349   1073 09            ret
2350   1074             
2351   1074             clear:
2352   1074 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2353   1077             ;; print("\033[2J\033[H"); 
2354   1077 26 25 17      mov b, __s5 ; "\033[2J\033[H"
2355   107A FD AB         swp b
2356   107C D8            push b
2357   107D 07 91 0F      call print
2358   1080 51 02 00      add sp, 2
2359   1083 F9            leave
2360   1084 09            ret
2361   1085             
2362   1085             include_stdio_asm:
2363   1085 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2364   1088             
2365   1088             ; --- BEGIN INLINE ASM BLOCK
2366   1088             .include "lib/asm/stdio.asm"
0001+  1088             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1088             ; stdio.s
0003+  1088             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1088             .include "lib/asm/string.asm"
0001++ 1088             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1088             ; string.s
0003++ 1088             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1088             
0005++ 1088             
0006++ 1088             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1088             ; _strrev
0008++ 1088             ; reverse a string
0009++ 1088             ; D = string address
0010++ 1088             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1088             ; 01234
0012++ 1088             _strrev:
0013++ 1088 4B          	pusha
0014++ 1089 07 CF 10    	call _strlen	; length in C
0015++ 108C 12          	mov a, c
0016++ 108D AF 01 00    	cmp a, 1
0017++ 1090 D0 AA 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1093 7D          	dec a
0019++ 1094 FD 4E       	mov si, d	; beginning of string
0020++ 1096 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1098 59          	add d, a	; end of string
0022++ 1099 12          	mov a, c
0023++ 109A FD 9B       	shr a		; divide by 2
0024++ 109C 39          	mov c, a	; C now counts the steps
0025++ 109D             _strrev_L0:
0026++ 109D 32          	mov bl, [d]	; save load right-side char into BL
0027++ 109E F6          	lodsb		; load left-side char into AL; increase SI
0028++ 109F 3E          	mov [d], al	; store left char into right side
0029++ 10A0 1B          	mov al, bl
0030++ 10A1 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 10A2 7E          	dec c
0032++ 10A3 7F          	dec d
0033++ 10A4 C2 00 00    	cmp c, 0
0034++ 10A7 C7 9D 10    	jne _strrev_L0
0035++ 10AA             _strrev_end:
0036++ 10AA 4C          	popa
0037++ 10AB 09          	ret
0038++ 10AC             	
0039++ 10AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10AC             ; _strchr
0041++ 10AC             ; search string in D for char in AL
0042++ 10AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10AC             _strchr:
0044++ 10AC             _strchr_L0:
0045++ 10AC 32          	mov bl, [d]
0046++ 10AD C1 00       	cmp bl, 0
0047++ 10AF C6 BA 10    	je _strchr_end
0048++ 10B2 BA          	cmp al, bl
0049++ 10B3 C6 BA 10    	je _strchr_end
0050++ 10B6 79          	inc d
0051++ 10B7 0A AC 10    	jmp _strchr_L0
0052++ 10BA             _strchr_end:
0053++ 10BA 1B          	mov al, bl
0054++ 10BB 09          	ret
0055++ 10BC             
0056++ 10BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10BC             ; _strstr
0058++ 10BC             ; find sub-string
0059++ 10BC             ; str1 in SI
0060++ 10BC             ; str2 in DI
0061++ 10BC             ; SI points to end of source string
0062++ 10BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10BC             _strstr:
0064++ 10BC DB          	push al
0065++ 10BD DA          	push d
0066++ 10BE E3          	push di
0067++ 10BF             _strstr_loop:
0068++ 10BF F3          	cmpsb					; compare a byte of the strings
0069++ 10C0 C7 CB 10    	jne _strstr_ret
0070++ 10C3 FC 00 00    	lea d, [di + 0]
0071++ 10C6 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 10C8 C7 BF 10    	jne _strstr_loop				; equal chars but not at end
0073++ 10CB             _strstr_ret:
0074++ 10CB F0          	pop di
0075++ 10CC E7          	pop d
0076++ 10CD E8          	pop al
0077++ 10CE 09          	ret
0078++ 10CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 10CF             ; length of null terminated string
0080++ 10CF             ; result in C
0081++ 10CF             ; pointer in D
0082++ 10CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 10CF             _strlen:
0084++ 10CF DA          	push d
0085++ 10D0 38 00 00    	mov c, 0
0086++ 10D3             _strlen_L1:
0087++ 10D3 BD 00       	cmp byte [d], 0
0088++ 10D5 C6 DD 10    	je _strlen_ret
0089++ 10D8 79          	inc d
0090++ 10D9 78          	inc c
0091++ 10DA 0A D3 10    	jmp _strlen_L1
0092++ 10DD             _strlen_ret:
0093++ 10DD E7          	pop d
0094++ 10DE 09          	ret
0095++ 10DF             
0096++ 10DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 10DF             ; STRCMP
0098++ 10DF             ; compare two strings
0099++ 10DF             ; str1 in SI
0100++ 10DF             ; str2 in DI
0101++ 10DF             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 10DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 10DF             _strcmp:
0104++ 10DF DB          	push al
0105++ 10E0 DA          	push d
0106++ 10E1 E3          	push di
0107++ 10E2 E2          	push si
0108++ 10E3             _strcmp_loop:
0109++ 10E3 F3          	cmpsb					; compare a byte of the strings
0110++ 10E4 C7 EF 10    	jne _strcmp_ret
0111++ 10E7 FB FF FF    	lea d, [si +- 1]
0112++ 10EA BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 10EC C7 E3 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 10EF             _strcmp_ret:
0115++ 10EF EF          	pop si
0116++ 10F0 F0          	pop di
0117++ 10F1 E7          	pop d
0118++ 10F2 E8          	pop al
0119++ 10F3 09          	ret
0120++ 10F4             
0121++ 10F4             
0122++ 10F4             ; STRCPY
0123++ 10F4             ; copy null terminated string from SI to DI
0124++ 10F4             ; source in SI
0125++ 10F4             ; destination in DI
0126++ 10F4             _strcpy:
0127++ 10F4 E2          	push si
0128++ 10F5 E3          	push di
0129++ 10F6 DB          	push al
0130++ 10F7             _strcpy_L1:
0131++ 10F7 F6          	lodsb
0132++ 10F8 F7          	stosb
0133++ 10F9 B9 00       	cmp al, 0
0134++ 10FB C7 F7 10    	jne _strcpy_L1
0135++ 10FE             _strcpy_end:
0136++ 10FE E8          	pop al
0137++ 10FF F0          	pop di
0138++ 1100 EF          	pop si
0139++ 1101 09          	ret
0140++ 1102             
0141++ 1102             ; STRCAT
0142++ 1102             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1102             ; source in SI
0144++ 1102             ; destination in DI
0145++ 1102             _strcat:
0146++ 1102 E2          	push si
0147++ 1103 E3          	push di
0148++ 1104 D7          	push a
0149++ 1105 DA          	push d
0150++ 1106 50          	mov a, di
0151++ 1107 3C          	mov d, a
0152++ 1108             _strcat_goto_end_L1:
0153++ 1108 BD 00       	cmp byte[d], 0
0154++ 110A C6 11 11    	je _strcat_start
0155++ 110D 79          	inc d
0156++ 110E 0A 08 11    	jmp _strcat_goto_end_L1
0157++ 1111             _strcat_start:
0158++ 1111 FD 50       	mov di, d
0159++ 1113             _strcat_L1:
0160++ 1113 F6          	lodsb
0161++ 1114 F7          	stosb
0162++ 1115 B9 00       	cmp al, 0
0163++ 1117 C7 13 11    	jne _strcat_L1
0164++ 111A             _strcat_end:
0165++ 111A E7          	pop d
0166++ 111B E4          	pop a
0167++ 111C F0          	pop di
0168++ 111D EF          	pop si
0169++ 111E 09          	ret
0170++ 111F             
0171++ 111F             
0005+  111F             
0006+  111F             
0007+  111F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  111F             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  111F             ; ASCII in BL
0010+  111F             ; result in AL
0011+  111F             ; ascii for F = 0100 0110
0012+  111F             ; ascii for 9 = 0011 1001
0013+  111F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  111F             hex_ascii_encode:
0015+  111F 1B            mov al, bl
0016+  1120 93 40         test al, $40        ; test if letter or number
0017+  1122 C7 28 11      jnz hex_letter
0018+  1125 87 0F         and al, $0F        ; get number
0019+  1127 09            ret
0020+  1128             hex_letter:
0021+  1128 87 0F         and al, $0F        ; get letter
0022+  112A 6A 09         add al, 9
0023+  112C 09            ret
0024+  112D             
0025+  112D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  112D             ; ATOI
0027+  112D             ; 2 letter hex string in B
0028+  112D             ; 8bit integer returned in AL
0029+  112D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  112D             _atoi:
0031+  112D D8            push b
0032+  112E 07 1F 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  1131 30            mov bl, bh
0034+  1132 DB            push al          ; save a
0035+  1133 07 1F 11      call hex_ascii_encode
0036+  1136 EA            pop bl  
0037+  1137 FD 9E 04      shl al, 4
0038+  113A 8C            or al, bl
0039+  113B E5            pop b
0040+  113C 09            ret  
0041+  113D             
0042+  113D             
0043+  113D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  113D             ; scanf
0045+  113D             ; no need for explanations!
0046+  113D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  113D             scanf:
0048+  113D 09            ret
0049+  113E             
0050+  113E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  113E             ; ITOA
0052+  113E             ; 8bit value in BL
0053+  113E             ; 2 byte ASCII result in A
0054+  113E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  113E             _itoa:
0056+  113E DA            push d
0057+  113F D8            push b
0058+  1140 A7 00         mov bh, 0
0059+  1142 FD A4 04      shr bl, 4  
0060+  1145 74            mov d, b
0061+  1146 1F EE 13      mov al, [d + s_hex_digits]
0062+  1149 23            mov ah, al
0063+  114A               
0064+  114A E5            pop b
0065+  114B D8            push b
0066+  114C A7 00         mov bh, 0
0067+  114E FD 87 0F      and bl, $0F
0068+  1151 74            mov d, b
0069+  1152 1F EE 13      mov al, [d + s_hex_digits]
0070+  1155 E5            pop b
0071+  1156 E7            pop d
0072+  1157 09            ret
0073+  1158             
0074+  1158             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1158             ; HEX STRING TO BINARY
0076+  1158             ; di = destination address
0077+  1158             ; si = source
0078+  1158             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1158             _hex_to_int:
0080+  1158             _hex_to_int_L1:
0081+  1158 F6            lodsb          ; load from [SI] to AL
0082+  1159 B9 00         cmp al, 0        ; check if ASCII 0
0083+  115B C6 68 11      jz _hex_to_int_ret
0084+  115E 36            mov bh, al
0085+  115F F6            lodsb
0086+  1160 2F            mov bl, al
0087+  1161 07 2D 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  1164 F7            stosb          ; store AL to [DI]
0089+  1165 0A 58 11      jmp _hex_to_int_L1
0090+  1168             _hex_to_int_ret:
0091+  1168 09            ret    
0092+  1169             
0093+  1169             
0094+  1169             
0095+  1169             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1169             ; GETCHAR
0097+  1169             ; char in ah
0098+  1169             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1169             getch:
0100+  1169 DB            push al
0101+  116A             getch_retry:
0102+  116A 19 01         mov al, 1
0103+  116C 05 03         syscall sys_io      ; receive in AH
0104+  116E E8            pop al
0105+  116F 09            ret
0106+  1170             
0107+  1170             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  1170             ; PUTCHAR
0109+  1170             ; char in ah
0110+  1170             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  1170             _putchar:
0112+  1170 D7            push a
0113+  1171 19 00         mov al, 0
0114+  1173 05 03         syscall sys_io      ; char in AH
0115+  1175 E4            pop a
0116+  1176 09            ret
0117+  1177             
0118+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1177             ;; INPUT A STRING
0120+  1177             ;; terminates with null
0121+  1177             ;; pointer in D
0122+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1177             _gets:
0124+  1177 D7            push a
0125+  1178 DA            push d
0126+  1179             _gets_loop:
0127+  1179 19 01         mov al, 1
0128+  117B 05 03         syscall sys_io      ; receive in AH
0129+  117D B9 00         cmp al, 0        ; check error code (AL)
0130+  117F C6 79 11      je _gets_loop      ; if no char received, retry
0131+  1182             
0132+  1182 76 1B         cmp ah, 27
0133+  1184 C6 A5 11      je _gets_ansi_esc
0134+  1187 76 0A         cmp ah, $0A        ; LF
0135+  1189 C6 10 12      je _gets_end
0136+  118C 76 0D         cmp ah, $0D        ; CR
0137+  118E C6 10 12      je _gets_end
0138+  1191 76 5C         cmp ah, $5C        ; '\\'
0139+  1193 C6 D1 11      je _gets_escape
0140+  1196               
0141+  1196 76 08         cmp ah, $08      ; check for backspace
0142+  1198 C6 A1 11      je _gets_backspace
0143+  119B             
0144+  119B 1A            mov al, ah
0145+  119C 3E            mov [d], al
0146+  119D 79            inc d
0147+  119E 0A 79 11      jmp _gets_loop
0148+  11A1             _gets_backspace:
0149+  11A1 7F            dec d
0150+  11A2 0A 79 11      jmp _gets_loop
0151+  11A5             _gets_ansi_esc:
0152+  11A5 19 01         mov al, 1
0153+  11A7 05 03         syscall sys_io        ; receive in AH without echo
0154+  11A9 B9 00         cmp al, 0          ; check error code (AL)
0155+  11AB C6 A5 11      je _gets_ansi_esc    ; if no char received, retry
0156+  11AE 76 5B         cmp ah, '['
0157+  11B0 C7 79 11      jne _gets_loop
0158+  11B3             _gets_ansi_esc_2:
0159+  11B3 19 01         mov al, 1
0160+  11B5 05 03         syscall sys_io          ; receive in AH without echo
0161+  11B7 B9 00         cmp al, 0            ; check error code (AL)
0162+  11B9 C6 B3 11      je _gets_ansi_esc_2  ; if no char received, retry
0163+  11BC 76 44         cmp ah, 'D'
0164+  11BE C6 C9 11      je _gets_left_arrow
0165+  11C1 76 43         cmp ah, 'C'
0166+  11C3 C6 CD 11      je _gets_right_arrow
0167+  11C6 0A 79 11      jmp _gets_loop
0168+  11C9             _gets_left_arrow:
0169+  11C9 7F            dec d
0170+  11CA 0A 79 11      jmp _gets_loop
0171+  11CD             _gets_right_arrow:
0172+  11CD 79            inc d
0173+  11CE 0A 79 11      jmp _gets_loop
0174+  11D1             _gets_escape:
0175+  11D1 19 01         mov al, 1
0176+  11D3 05 03         syscall sys_io      ; receive in AH
0177+  11D5 B9 00         cmp al, 0        ; check error code (AL)
0178+  11D7 C6 D1 11      je _gets_escape      ; if no char received, retry
0179+  11DA 76 6E         cmp ah, 'n'
0180+  11DC C6 FB 11      je _gets_LF
0181+  11DF 76 72         cmp ah, 'r'
0182+  11E1 C6 02 12      je _gets_CR
0183+  11E4 76 30         cmp ah, '0'
0184+  11E6 C6 09 12      je _gets_NULL
0185+  11E9 76 5C         cmp ah, $5C  ; '\'
0186+  11EB C6 F4 11      je _gets_slash
0187+  11EE 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  11EF 3E            mov [d], al
0189+  11F0 79            inc d
0190+  11F1 0A 79 11      jmp _gets_loop
0191+  11F4             _gets_slash:
0192+  11F4 19 5C         mov al, $5C
0193+  11F6 3E            mov [d], al
0194+  11F7 79            inc d
0195+  11F8 0A 79 11      jmp _gets_loop
0196+  11FB             _gets_LF:
0197+  11FB 19 0A         mov al, $0A
0198+  11FD 3E            mov [d], al
0199+  11FE 79            inc d
0200+  11FF 0A 79 11      jmp _gets_loop
0201+  1202             _gets_CR:
0202+  1202 19 0D         mov al, $0D
0203+  1204 3E            mov [d], al
0204+  1205 79            inc d
0205+  1206 0A 79 11      jmp _gets_loop
0206+  1209             _gets_NULL:
0207+  1209 19 00         mov al, $00
0208+  120B 3E            mov [d], al
0209+  120C 79            inc d
0210+  120D 0A 79 11      jmp _gets_loop
0211+  1210             _gets_end:
0212+  1210 19 00         mov al, 0
0213+  1212 3E            mov [d], al        ; terminate string
0214+  1213 E7            pop d
0215+  1214 E4            pop a
0216+  1215 09            ret
0217+  1216             
0218+  1216             
0219+  1216             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  1216             ;; INPUT TEXT
0221+  1216             ;; terminated with CTRL+D
0222+  1216             ;; pointer in D
0223+  1216             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  1216             _gettxt:
0225+  1216 D7            push a
0226+  1217 DA            push d
0227+  1218             _gettxt_loop:
0228+  1218 19 01         mov al, 1
0229+  121A 05 03         syscall sys_io      ; receive in AH
0230+  121C B9 00         cmp al, 0        ; check error code (AL)
0231+  121E C6 18 12      je _gettxt_loop    ; if no char received, retry
0232+  1221 76 04         cmp ah, 4      ; EOT
0233+  1223 C6 61 12      je _gettxt_end
0234+  1226 76 08         cmp ah, $08      ; check for backspace
0235+  1228 C6 5D 12      je _gettxt_backspace
0236+  122B 76 5C         cmp ah, $5C        ; '\'
0237+  122D C6 36 12      je _gettxt_escape
0238+  1230 1A            mov al, ah
0239+  1231 3E            mov [d], al
0240+  1232 79            inc d
0241+  1233 0A 18 12      jmp _gettxt_loop
0242+  1236             _gettxt_escape:
0243+  1236 19 01         mov al, 1
0244+  1238 05 03         syscall sys_io      ; receive in AH
0245+  123A B9 00         cmp al, 0        ; check error code (AL)
0246+  123C C6 36 12      je _gettxt_escape    ; if no char received, retry
0247+  123F 76 6E         cmp ah, 'n'
0248+  1241 C6 4F 12      je _gettxt_LF
0249+  1244 76 72         cmp ah, 'r'
0250+  1246 C6 56 12      je _gettxt_CR
0251+  1249 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  124A 3E            mov [d], al
0253+  124B 79            inc d
0254+  124C 0A 18 12      jmp _gettxt_loop
0255+  124F             _gettxt_LF:
0256+  124F 19 0A         mov al, $0A
0257+  1251 3E            mov [d], al
0258+  1252 79            inc d
0259+  1253 0A 18 12      jmp _gettxt_loop
0260+  1256             _gettxt_CR:
0261+  1256 19 0D         mov al, $0D
0262+  1258 3E            mov [d], al
0263+  1259 79            inc d
0264+  125A 0A 18 12      jmp _gettxt_loop
0265+  125D             _gettxt_backspace:
0266+  125D 7F            dec d
0267+  125E 0A 18 12      jmp _gettxt_loop
0268+  1261             _gettxt_end:
0269+  1261 19 00         mov al, 0
0270+  1263 3E            mov [d], al        ; terminate string
0271+  1264 E7            pop d
0272+  1265 E4            pop a
0273+  1266 09            ret
0274+  1267             
0275+  1267             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1267             ; PRINT NEW LINE
0277+  1267             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  1267             printnl:
0279+  1267 D7            push a
0280+  1268 10 00 0A      mov a, $0A00
0281+  126B 05 03         syscall sys_io
0282+  126D 10 00 0D      mov a, $0D00
0283+  1270 05 03         syscall sys_io
0284+  1272 E4            pop a
0285+  1273 09            ret
0286+  1274             
0287+  1274             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  1274             ; _strtoint
0289+  1274             ; 4 digit hex string number in d
0290+  1274             ; integer returned in A
0291+  1274             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  1274             _strtointx:
0293+  1274 D8            push b
0294+  1275 32            mov bl, [d]
0295+  1276 37            mov bh, bl
0296+  1277 33 01 00      mov bl, [d + 1]
0297+  127A 07 2D 11      call _atoi        ; convert to int in AL
0298+  127D 23            mov ah, al        ; move to AH
0299+  127E 33 02 00      mov bl, [d + 2]
0300+  1281 37            mov bh, bl
0301+  1282 33 03 00      mov bl, [d + 3]
0302+  1285 07 2D 11      call _atoi        ; convert to int in AL
0303+  1288 E5            pop b
0304+  1289 09            ret
0305+  128A             
0306+  128A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  128A             ; _strtoint
0308+  128A             ; 5 digit base10 string number in d
0309+  128A             ; integer returned in A
0310+  128A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  128A             _strtoint:
0312+  128A E2            push si
0313+  128B D8            push b
0314+  128C D9            push c
0315+  128D DA            push d
0316+  128E 07 CF 10      call _strlen      ; get string length in C
0317+  1291 7E            dec c
0318+  1292 FD 4E         mov si, d
0319+  1294 12            mov a, c
0320+  1295 FD 99         shl a
0321+  1297 3B 06 14      mov d, table_power
0322+  129A 59            add d, a
0323+  129B 38 00 00      mov c, 0
0324+  129E             _strtoint_L0:
0325+  129E F6            lodsb      ; load ASCII to al
0326+  129F B9 00         cmp al, 0
0327+  12A1 C6 B4 12      je _strtoint_end
0328+  12A4 6F 30         sub al, $30    ; make into integer
0329+  12A6 22 00         mov ah, 0
0330+  12A8 2A            mov b, [d]
0331+  12A9 AC            mul a, b      ; result in B since it fits in 16bits
0332+  12AA 11            mov a, b
0333+  12AB 28            mov b, c
0334+  12AC 54            add a, b
0335+  12AD 39            mov c, a
0336+  12AE 63 02 00      sub d, 2
0337+  12B1 0A 9E 12      jmp _strtoint_L0
0338+  12B4             _strtoint_end:
0339+  12B4 12            mov a, c
0340+  12B5 E7            pop d
0341+  12B6 E6            pop c
0342+  12B7 E5            pop b
0343+  12B8 EF            pop si
0344+  12B9 09            ret
0345+  12BA             
0346+  12BA             
0347+  12BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  12BA             ; PRINT NULL TERMINATED STRING
0349+  12BA             ; pointer in D
0350+  12BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  12BA             _puts:
0352+  12BA D7            push a
0353+  12BB DA            push d
0354+  12BC             _puts_L1:
0355+  12BC 1E            mov al, [d]
0356+  12BD B9 00         cmp al, 0
0357+  12BF C6 CB 12      jz _puts_END
0358+  12C2 23            mov ah, al
0359+  12C3 19 00         mov al, 0
0360+  12C5 05 03         syscall sys_io
0361+  12C7 79            inc d
0362+  12C8 0A BC 12      jmp _puts_L1
0363+  12CB             _puts_END:
0364+  12CB E7            pop d
0365+  12CC E4            pop a
0366+  12CD 09            ret
0367+  12CE             
0368+  12CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  12CE             ; PRINT N SIZE STRING
0370+  12CE             ; pointer in D
0371+  12CE             ; size in C
0372+  12CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  12CE             _putsn:
0374+  12CE DB            push al
0375+  12CF DA            push d
0376+  12D0 D9            push c
0377+  12D1             _putsn_L0:
0378+  12D1 1E            mov al, [d]
0379+  12D2 23            mov ah, al
0380+  12D3 19 00         mov al, 0
0381+  12D5 05 03         syscall sys_io
0382+  12D7 79            inc d
0383+  12D8 7E            dec c  
0384+  12D9 C2 00 00      cmp c, 0
0385+  12DC C7 D1 12      jne _putsn_L0
0386+  12DF             _putsn_end:
0387+  12DF E6            pop c
0388+  12E0 E7            pop d
0389+  12E1 E8            pop al
0390+  12E2 09            ret
0391+  12E3             
0392+  12E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  12E3             ; print 16bit decimal number
0394+  12E3             ; input number in A
0395+  12E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  12E3             print_u16d:
0397+  12E3 D7            push a
0398+  12E4 D8            push b
0399+  12E5 26 10 27      mov b, 10000
0400+  12E8 AE            div a, b      ; get 10000's coeff.
0401+  12E9 07 0B 13      call print_number
0402+  12EC 11            mov a, b
0403+  12ED 26 E8 03      mov b, 1000
0404+  12F0 AE            div a, b      ; get 1000's coeff.
0405+  12F1 07 0B 13      call print_number
0406+  12F4 11            mov a, b
0407+  12F5 26 64 00      mov b, 100
0408+  12F8 AE            div a, b
0409+  12F9 07 0B 13      call print_number
0410+  12FC 11            mov a, b
0411+  12FD 26 0A 00      mov b, 10
0412+  1300 AE            div a, b
0413+  1301 07 0B 13      call print_number
0414+  1304 1B            mov al, bl      ; 1's coeff in bl
0415+  1305 07 0B 13      call print_number
0416+  1308 E5            pop b
0417+  1309 E4            pop a
0418+  130A 09            ret
0419+  130B             
0420+  130B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  130B             ; print AL
0422+  130B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  130B             print_number:
0424+  130B 6A 30         add al, $30
0425+  130D 23            mov ah, al
0426+  130E 07 70 11      call _putchar
0427+  1311 09            ret
0428+  1312             
0429+  1312             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1312             ; PRINT 16BIT HEX INTEGER
0431+  1312             ; integer value in reg B
0432+  1312             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1312             print_u16x:
0434+  1312 D7            push a
0435+  1313 D8            push b
0436+  1314 DD            push bl
0437+  1315 30            mov bl, bh
0438+  1316 07 3E 11      call _itoa        ; convert bh to char in A
0439+  1319 2F            mov bl, al        ; save al
0440+  131A 19 00         mov al, 0
0441+  131C 05 03         syscall sys_io        ; display AH
0442+  131E 24            mov ah, bl        ; retrieve al
0443+  131F 19 00         mov al, 0
0444+  1321 05 03         syscall sys_io        ; display AL
0445+  1323             
0446+  1323 EA            pop bl
0447+  1324 07 3E 11      call _itoa        ; convert bh to char in A
0448+  1327 2F            mov bl, al        ; save al
0449+  1328 19 00         mov al, 0
0450+  132A 05 03         syscall sys_io        ; display AH
0451+  132C 24            mov ah, bl        ; retrieve al
0452+  132D 19 00         mov al, 0
0453+  132F 05 03         syscall sys_io        ; display AL
0454+  1331             
0455+  1331 E5            pop b
0456+  1332 E4            pop a
0457+  1333 09            ret
0458+  1334             
0459+  1334             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  1334             ; INPUT 16BIT HEX INTEGER
0461+  1334             ; read 16bit integer into A
0462+  1334             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  1334             scan_u16x:
0464+  1334 F8 10 00      enter 16
0465+  1337 D8            push b
0466+  1338 DA            push d
0467+  1339             
0468+  1339 FA F1 FF      lea d, [bp + -15]
0469+  133C 07 77 11      call _gets        ; get number
0470+  133F             
0471+  133F 32            mov bl, [d]
0472+  1340 37            mov bh, bl
0473+  1341 33 01 00      mov bl, [d + 1]
0474+  1344 07 2D 11      call _atoi        ; convert to int in AL
0475+  1347 23            mov ah, al        ; move to AH
0476+  1348             
0477+  1348 33 02 00      mov bl, [d + 2]
0478+  134B 37            mov bh, bl
0479+  134C 33 03 00      mov bl, [d + 3]
0480+  134F 07 2D 11      call _atoi        ; convert to int in AL
0481+  1352             
0482+  1352 E7            pop d
0483+  1353 E5            pop b
0484+  1354 F9            leave
0485+  1355 09            ret
0486+  1356             
0487+  1356             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  1356             ; PRINT 8bit HEX INTEGER
0489+  1356             ; integer value in reg bl
0490+  1356             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  1356             print_u8x:
0492+  1356 D7            push a
0493+  1357 DD            push bl
0494+  1358             
0495+  1358 07 3E 11      call _itoa        ; convert bl to char in A
0496+  135B 2F            mov bl, al        ; save al
0497+  135C 19 00         mov al, 0
0498+  135E 05 03         syscall sys_io        ; display AH
0499+  1360 24            mov ah, bl        ; retrieve al
0500+  1361 19 00         mov al, 0
0501+  1363 05 03         syscall sys_io        ; display AL
0502+  1365             
0503+  1365 EA            pop bl
0504+  1366 E4            pop a
0505+  1367 09            ret
0506+  1368             
0507+  1368             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  1368             ; print 8bit decimal unsigned number
0509+  1368             ; input number in AL
0510+  1368             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  1368             print_u8d:
0512+  1368 D7            push a
0513+  1369 D8            push b
0514+  136A             
0515+  136A 22 00         mov ah, 0
0516+  136C 26 64 00      mov b, 100
0517+  136F AE            div a, b
0518+  1370 D8            push b      ; save remainder
0519+  1371 B9 00         cmp al, 0
0520+  1373 C6 7D 13      je skip100
0521+  1376 6A 30         add al, $30
0522+  1378 23            mov ah, al
0523+  1379 19 00         mov al, 0
0524+  137B 05 03         syscall sys_io  ; print coeff
0525+  137D             skip100:
0526+  137D E4            pop a
0527+  137E 22 00         mov ah, 0
0528+  1380 26 0A 00      mov b, 10
0529+  1383 AE            div a, b
0530+  1384 D8            push b      ; save remainder
0531+  1385 B9 00         cmp al, 0
0532+  1387 C6 91 13      je skip10
0533+  138A 6A 30         add al, $30
0534+  138C 23            mov ah, al
0535+  138D 19 00         mov al, 0
0536+  138F 05 03         syscall sys_io  ; print coeff
0537+  1391             skip10:
0538+  1391 E4            pop a
0539+  1392 1B            mov al, bl
0540+  1393 6A 30         add al, $30
0541+  1395 23            mov ah, al
0542+  1396 19 00         mov al, 0
0543+  1398 05 03         syscall sys_io  ; print coeff
0544+  139A E5            pop b
0545+  139B E4            pop a
0546+  139C 09            ret
0547+  139D             
0548+  139D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  139D             ; INPUT 8BIT HEX INTEGER
0550+  139D             ; read 8bit integer into AL
0551+  139D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  139D             scan_u8x:
0553+  139D F8 04 00      enter 4
0554+  13A0 D8            push b
0555+  13A1 DA            push d
0556+  13A2             
0557+  13A2 FA FD FF      lea d, [bp + -3]
0558+  13A5 07 77 11      call _gets        ; get number
0559+  13A8             
0560+  13A8 32            mov bl, [d]
0561+  13A9 37            mov bh, bl
0562+  13AA 33 01 00      mov bl, [d + 1]
0563+  13AD 07 2D 11      call _atoi        ; convert to int in AL
0564+  13B0             
0565+  13B0 E7            pop d
0566+  13B1 E5            pop b
0567+  13B2 F9            leave
0568+  13B3 09            ret
0569+  13B4             
0570+  13B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  13B4             ; input decimal number
0572+  13B4             ; result in A
0573+  13B4             ; 655'\0'
0574+  13B4             ; low--------high
0575+  13B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  13B4             scan_u16d:
0577+  13B4 F8 08 00      enter 8
0578+  13B7 E2            push si
0579+  13B8 D8            push b
0580+  13B9 D9            push c
0581+  13BA DA            push d
0582+  13BB FA F9 FF      lea d, [bp +- 7]
0583+  13BE 07 77 11      call _gets
0584+  13C1 07 CF 10      call _strlen      ; get string length in C
0585+  13C4 7E            dec c
0586+  13C5 FD 4E         mov si, d
0587+  13C7 12            mov a, c
0588+  13C8 FD 99         shl a
0589+  13CA 3B 06 14      mov d, table_power
0590+  13CD 59            add d, a
0591+  13CE 38 00 00      mov c, 0
0592+  13D1             mul_loop:
0593+  13D1 F6            lodsb      ; load ASCII to al
0594+  13D2 B9 00         cmp al, 0
0595+  13D4 C6 E7 13      je mul_exit
0596+  13D7 6F 30         sub al, $30    ; make into integer
0597+  13D9 22 00         mov ah, 0
0598+  13DB 2A            mov b, [d]
0599+  13DC AC            mul a, b      ; result in B since it fits in 16bits
0600+  13DD 11            mov a, b
0601+  13DE 28            mov b, c
0602+  13DF 54            add a, b
0603+  13E0 39            mov c, a
0604+  13E1 63 02 00      sub d, 2
0605+  13E4 0A D1 13      jmp mul_loop
0606+  13E7             mul_exit:
0607+  13E7 12            mov a, c
0608+  13E8 E7            pop d
0609+  13E9 E6            pop c
0610+  13EA E5            pop b
0611+  13EB EF            pop si
0612+  13EC F9            leave
0613+  13ED 09            ret
0614+  13EE             
0615+  13EE             
0616+  13EE 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  13F2 34 35 36 37 
0616+  13F6 38 39 41 42 
0616+  13FA 43 44 45 46 
0617+  13FE 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1402 1B 5B 48 00 
0618+  1406             
0619+  1406             table_power:
0620+  1406 01 00         .dw 1
0621+  1408 0A 00         .dw 10
0622+  140A 64 00         .dw 100
0623+  140C E8 03         .dw 1000
0624+  140E 10 27         .dw 100002367   1410             ; --- END INLINE ASM BLOCK
2368   1410             
2369   1410 F9            leave
2370   1411 09            ret
2371   1412             
2372   1412             sqrt:
2373   1412 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2374   1415             ; $x 
2375   1415             ; $y 
2376   1415 52 04 00      sub sp, 4
2377   1418             ;; if (n <= 1) { 
2378   1418             _if35_cond:
2379   1418 FA 05 00      lea d, [bp + 5] ; $n
2380   141B 2A            mov b, [d]
2381   141C             ; START RELATIONAL
2382   141C D7            push a
2383   141D 11            mov a, b
2384   141E 26 01 00      mov b, $1
2385   1421 B0            cmp a, b
2386   1422 FD 74         sle ; <=
2387   1424 E4            pop a
2388   1425             ; END RELATIONAL
2389   1425 C0 00 00      cmp b, 0
2390   1428 C6 34 14      je _if35_exit
2391   142B             _if35_true:
2392   142B             ;; return n; 
2393   142B FA 05 00      lea d, [bp + 5] ; $n
2394   142E 2A            mov b, [d]
2395   142F F9            leave
2396   1430 09            ret
2397   1431 0A 34 14      jmp _if35_exit
2398   1434             _if35_exit:
2399   1434             ;; x = n; 
2400   1434 FA FF FF      lea d, [bp + -1] ; $x
2401   1437 DA            push d
2402   1438 FA 05 00      lea d, [bp + 5] ; $n
2403   143B 2A            mov b, [d]
2404   143C E7            pop d
2405   143D FD 43         mov [d], b
2406   143F             ;; y = (x + n / x) / 2; 
2407   143F FA FD FF      lea d, [bp + -3] ; $y
2408   1442 DA            push d
2409   1443 FA FF FF      lea d, [bp + -1] ; $x
2410   1446 2A            mov b, [d]
2411   1447             ; START TERMS
2412   1447 D7            push a
2413   1448 11            mov a, b
2414   1449 FA 05 00      lea d, [bp + 5] ; $n
2415   144C 2A            mov b, [d]
2416   144D             ; START FACTORS
2417   144D D7            push a
2418   144E 11            mov a, b
2419   144F FA FF FF      lea d, [bp + -1] ; $x
2420   1452 2A            mov b, [d]
2421   1453 AE            div a, b
2422   1454 27            mov b, a
2423   1455 E4            pop a
2424   1456             ; END FACTORS
2425   1456 54            add a, b
2426   1457 27            mov b, a
2427   1458 E4            pop a
2428   1459             ; END TERMS
2429   1459             ; START FACTORS
2430   1459 D7            push a
2431   145A 11            mov a, b
2432   145B 26 02 00      mov b, $2
2433   145E AE            div a, b
2434   145F 27            mov b, a
2435   1460 E4            pop a
2436   1461             ; END FACTORS
2437   1461 E7            pop d
2438   1462 FD 43         mov [d], b
2439   1464             ;; while (y < x) { 
2440   1464             _while36_cond:
2441   1464 FA FD FF      lea d, [bp + -3] ; $y
2442   1467 2A            mov b, [d]
2443   1468             ; START RELATIONAL
2444   1468 D7            push a
2445   1469 11            mov a, b
2446   146A FA FF FF      lea d, [bp + -1] ; $x
2447   146D 2A            mov b, [d]
2448   146E B0            cmp a, b
2449   146F FD 73         slt ; < 
2450   1471 E4            pop a
2451   1472             ; END RELATIONAL
2452   1472 C0 00 00      cmp b, 0
2453   1475 C6 AB 14      je _while36_exit
2454   1478             _while36_block:
2455   1478             ;; x = y; 
2456   1478 FA FF FF      lea d, [bp + -1] ; $x
2457   147B DA            push d
2458   147C FA FD FF      lea d, [bp + -3] ; $y
2459   147F 2A            mov b, [d]
2460   1480 E7            pop d
2461   1481 FD 43         mov [d], b
2462   1483             ;; y = (x + n / x) / 2; 
2463   1483 FA FD FF      lea d, [bp + -3] ; $y
2464   1486 DA            push d
2465   1487 FA FF FF      lea d, [bp + -1] ; $x
2466   148A 2A            mov b, [d]
2467   148B             ; START TERMS
2468   148B D7            push a
2469   148C 11            mov a, b
2470   148D FA 05 00      lea d, [bp + 5] ; $n
2471   1490 2A            mov b, [d]
2472   1491             ; START FACTORS
2473   1491 D7            push a
2474   1492 11            mov a, b
2475   1493 FA FF FF      lea d, [bp + -1] ; $x
2476   1496 2A            mov b, [d]
2477   1497 AE            div a, b
2478   1498 27            mov b, a
2479   1499 E4            pop a
2480   149A             ; END FACTORS
2481   149A 54            add a, b
2482   149B 27            mov b, a
2483   149C E4            pop a
2484   149D             ; END TERMS
2485   149D             ; START FACTORS
2486   149D D7            push a
2487   149E 11            mov a, b
2488   149F 26 02 00      mov b, $2
2489   14A2 AE            div a, b
2490   14A3 27            mov b, a
2491   14A4 E4            pop a
2492   14A5             ; END FACTORS
2493   14A5 E7            pop d
2494   14A6 FD 43         mov [d], b
2495   14A8 0A 64 14      jmp _while36_cond
2496   14AB             _while36_exit:
2497   14AB             ;; return x; 
2498   14AB FA FF FF      lea d, [bp + -1] ; $x
2499   14AE 2A            mov b, [d]
2500   14AF F9            leave
2501   14B0 09            ret
2502   14B1             
2503   14B1             exp:
2504   14B1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2505   14B4             ; $i 
2506   14B4             ; $result 
2507   14B4 10 01 00      mov a, $1
2508   14B7 45 FD FF      mov [bp + -3], a
2509   14BA 52 04 00      sub sp, 4
2510   14BD             ;; for(i = 0; i < exp; i++){ 
2511   14BD             _for37_init:
2512   14BD FA FF FF      lea d, [bp + -1] ; $i
2513   14C0 DA            push d
2514   14C1 26 00 00      mov b, $0
2515   14C4 E7            pop d
2516   14C5 FD 43         mov [d], b
2517   14C7             _for37_cond:
2518   14C7 FA FF FF      lea d, [bp + -1] ; $i
2519   14CA 2A            mov b, [d]
2520   14CB             ; START RELATIONAL
2521   14CB D7            push a
2522   14CC 11            mov a, b
2523   14CD FA 07 00      lea d, [bp + 7] ; $exp
2524   14D0 2A            mov b, [d]
2525   14D1 B0            cmp a, b
2526   14D2 FD 73         slt ; < 
2527   14D4 E4            pop a
2528   14D5             ; END RELATIONAL
2529   14D5 C0 00 00      cmp b, 0
2530   14D8 C6 00 15      je _for37_exit
2531   14DB             _for37_block:
2532   14DB             ;; result = result * base; 
2533   14DB FA FD FF      lea d, [bp + -3] ; $result
2534   14DE DA            push d
2535   14DF FA FD FF      lea d, [bp + -3] ; $result
2536   14E2 2A            mov b, [d]
2537   14E3             ; START FACTORS
2538   14E3 D7            push a
2539   14E4 11            mov a, b
2540   14E5 FA 05 00      lea d, [bp + 5] ; $base
2541   14E8 2A            mov b, [d]
2542   14E9 AC            mul a, b ; *
2543   14EA 11            mov a, b
2544   14EB 27            mov b, a
2545   14EC E4            pop a
2546   14ED             ; END FACTORS
2547   14ED E7            pop d
2548   14EE FD 43         mov [d], b
2549   14F0             _for37_update:
2550   14F0 FA FF FF      lea d, [bp + -1] ; $i
2551   14F3 2A            mov b, [d]
2552   14F4 D8            push b
2553   14F5 FD 77         inc b
2554   14F7 FA FF FF      lea d, [bp + -1] ; $i
2555   14FA FD 43         mov [d], b
2556   14FC E5            pop b
2557   14FD 0A C7 14      jmp _for37_cond
2558   1500             _for37_exit:
2559   1500             ;; return result; 
2560   1500 FA FD FF      lea d, [bp + -3] ; $result
2561   1503 2A            mov b, [d]
2562   1504 F9            leave
2563   1505 09            ret
2564   1506             
2565   1506             primes1:
2566   1506 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2567   1509             ; $n 
2568   1509             ; $i 
2569   1509             ; $s 
2570   1509             ; $count 
2571   1509             ; $divides 
2572   1509 52 0A 00      sub sp, 10
2573   150C             ;; n = 2; 
2574   150C FA FF FF      lea d, [bp + -1] ; $n
2575   150F DA            push d
2576   1510 26 02 00      mov b, $2
2577   1513 E7            pop d
2578   1514 FD 43         mov [d], b
2579   1516             ;; while(n < top){ 
2580   1516             _while38_cond:
2581   1516 FA FF FF      lea d, [bp + -1] ; $n
2582   1519 2A            mov b, [d]
2583   151A             ; START RELATIONAL
2584   151A D7            push a
2585   151B 11            mov a, b
2586   151C 3B 9A 16      mov d, _top ; $top
2587   151F 2A            mov b, [d]
2588   1520 B0            cmp a, b
2589   1521 FD 75         slu ; < (unsigned)
2590   1523 E4            pop a
2591   1524             ; END RELATIONAL
2592   1524 C0 00 00      cmp b, 0
2593   1527 C6 15 16      je _while38_exit
2594   152A             _while38_block:
2595   152A             ;; s = sqrt(n); 
2596   152A FA FB FF      lea d, [bp + -5] ; $s
2597   152D DA            push d
2598   152E FA FF FF      lea d, [bp + -1] ; $n
2599   1531 2A            mov b, [d]
2600   1532 FD AB         swp b
2601   1534 D8            push b
2602   1535 07 12 14      call sqrt
2603   1538 51 02 00      add sp, 2
2604   153B E7            pop d
2605   153C FD 43         mov [d], b
2606   153E             ;; divides = 0; 
2607   153E FA F7 FF      lea d, [bp + -9] ; $divides
2608   1541 DA            push d
2609   1542 26 00 00      mov b, $0
2610   1545 E7            pop d
2611   1546 FD 43         mov [d], b
2612   1548             ;; i = 2; 
2613   1548 FA FD FF      lea d, [bp + -3] ; $i
2614   154B DA            push d
2615   154C 26 02 00      mov b, $2
2616   154F E7            pop d
2617   1550 FD 43         mov [d], b
2618   1552             ;; while(i <= s){ 
2619   1552             _while39_cond:
2620   1552 FA FD FF      lea d, [bp + -3] ; $i
2621   1555 2A            mov b, [d]
2622   1556             ; START RELATIONAL
2623   1556 D7            push a
2624   1557 11            mov a, b
2625   1558 FA FB FF      lea d, [bp + -5] ; $s
2626   155B 2A            mov b, [d]
2627   155C B0            cmp a, b
2628   155D FD 76         sleu ; <= (unsigned)
2629   155F E4            pop a
2630   1560             ; END RELATIONAL
2631   1560 C0 00 00      cmp b, 0
2632   1563 C6 C3 15      je _while39_exit
2633   1566             _while39_block:
2634   1566             ;; if(n % i == 0){ 
2635   1566             _if40_cond:
2636   1566 FA FF FF      lea d, [bp + -1] ; $n
2637   1569 2A            mov b, [d]
2638   156A             ; START FACTORS
2639   156A D7            push a
2640   156B 11            mov a, b
2641   156C FA FD FF      lea d, [bp + -3] ; $i
2642   156F 2A            mov b, [d]
2643   1570 AE            div a, b ; 
2644   1571 11            mov a, b
2645   1572 27            mov b, a
2646   1573 E4            pop a
2647   1574             ; END FACTORS
2648   1574             ; START RELATIONAL
2649   1574 D7            push a
2650   1575 11            mov a, b
2651   1576 26 00 00      mov b, $0
2652   1579 B0            cmp a, b
2653   157A FD 71         seq ; ==
2654   157C E4            pop a
2655   157D             ; END RELATIONAL
2656   157D C0 00 00      cmp b, 0
2657   1580 C6 93 15      je _if40_exit
2658   1583             _if40_true:
2659   1583             ;; divides = 1; 
2660   1583 FA F7 FF      lea d, [bp + -9] ; $divides
2661   1586 DA            push d
2662   1587 26 01 00      mov b, $1
2663   158A E7            pop d
2664   158B FD 43         mov [d], b
2665   158D             ;; break; 
2666   158D 0A C3 15      jmp _while39_exit ; while break
2667   1590 0A 93 15      jmp _if40_exit
2668   1593             _if40_exit:
2669   1593             ;; i = i + 1; 
2670   1593 FA FD FF      lea d, [bp + -3] ; $i
2671   1596 DA            push d
2672   1597 FA FD FF      lea d, [bp + -3] ; $i
2673   159A 2A            mov b, [d]
2674   159B             ; START TERMS
2675   159B D7            push a
2676   159C 11            mov a, b
2677   159D 26 01 00      mov b, $1
2678   15A0 54            add a, b
2679   15A1 27            mov b, a
2680   15A2 E4            pop a
2681   15A3             ; END TERMS
2682   15A3 E7            pop d
2683   15A4 FD 43         mov [d], b
2684   15A6             ;; if(i >= s) break; 
2685   15A6             _if41_cond:
2686   15A6 FA FD FF      lea d, [bp + -3] ; $i
2687   15A9 2A            mov b, [d]
2688   15AA             ; START RELATIONAL
2689   15AA D7            push a
2690   15AB 11            mov a, b
2691   15AC FA FB FF      lea d, [bp + -5] ; $s
2692   15AF 2A            mov b, [d]
2693   15B0 B0            cmp a, b
2694   15B1 FD 82         sgeu ; >= (unsigned)
2695   15B3 E4            pop a
2696   15B4             ; END RELATIONAL
2697   15B4 C0 00 00      cmp b, 0
2698   15B7 C6 C0 15      je _if41_exit
2699   15BA             _if41_true:
2700   15BA             ;; break; 
2701   15BA 0A C3 15      jmp _while39_exit ; while break
2702   15BD 0A C0 15      jmp _if41_exit
2703   15C0             _if41_exit:
2704   15C0 0A 52 15      jmp _while39_cond
2705   15C3             _while39_exit:
2706   15C3             ;; if(divides == 0){ 
2707   15C3             _if42_cond:
2708   15C3 FA F7 FF      lea d, [bp + -9] ; $divides
2709   15C6 2A            mov b, [d]
2710   15C7             ; START RELATIONAL
2711   15C7 D7            push a
2712   15C8 11            mov a, b
2713   15C9 26 00 00      mov b, $0
2714   15CC B0            cmp a, b
2715   15CD FD 71         seq ; ==
2716   15CF E4            pop a
2717   15D0             ; END RELATIONAL
2718   15D0 C0 00 00      cmp b, 0
2719   15D3 C6 FF 15      je _if42_exit
2720   15D6             _if42_true:
2721   15D6             ;; count = count + 1;	 
2722   15D6 FA F9 FF      lea d, [bp + -7] ; $count
2723   15D9 DA            push d
2724   15DA FA F9 FF      lea d, [bp + -7] ; $count
2725   15DD 2A            mov b, [d]
2726   15DE             ; START TERMS
2727   15DE D7            push a
2728   15DF 11            mov a, b
2729   15E0 26 01 00      mov b, $1
2730   15E3 54            add a, b
2731   15E4 27            mov b, a
2732   15E5 E4            pop a
2733   15E6             ; END TERMS
2734   15E6 E7            pop d
2735   15E7 FD 43         mov [d], b
2736   15E9             ;; printf("%d\n", n); 
2737   15E9 FA FF FF      lea d, [bp + -1] ; $n
2738   15EC 2A            mov b, [d]
2739   15ED FD AB         swp b
2740   15EF D8            push b
2741   15F0 26 E5 16      mov b, __s2 ; "%d\n"
2742   15F3 FD AB         swp b
2743   15F5 D8            push b
2744   15F6 07 45 06      call printf
2745   15F9 51 04 00      add sp, 4
2746   15FC 0A FF 15      jmp _if42_exit
2747   15FF             _if42_exit:
2748   15FF             ;; n = n + 1; 
2749   15FF FA FF FF      lea d, [bp + -1] ; $n
2750   1602 DA            push d
2751   1603 FA FF FF      lea d, [bp + -1] ; $n
2752   1606 2A            mov b, [d]
2753   1607             ; START TERMS
2754   1607 D7            push a
2755   1608 11            mov a, b
2756   1609 26 01 00      mov b, $1
2757   160C 54            add a, b
2758   160D 27            mov b, a
2759   160E E4            pop a
2760   160F             ; END TERMS
2761   160F E7            pop d
2762   1610 FD 43         mov [d], b
2763   1612 0A 16 15      jmp _while38_cond
2764   1615             _while38_exit:
2765   1615             ;; return; 
2766   1615 F9            leave
2767   1616 09            ret
2768   1617             
2769   1617             isPrime:
2770   1617 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2771   161A             ; $i 
2772   161A 52 02 00      sub sp, 2
2773   161D             ;; if (num <= 1) return 0; 
2774   161D             _if43_cond:
2775   161D FA 05 00      lea d, [bp + 5] ; $num
2776   1620 2A            mov b, [d]
2777   1621             ; START RELATIONAL
2778   1621 D7            push a
2779   1622 11            mov a, b
2780   1623 26 01 00      mov b, $1
2781   1626 B0            cmp a, b
2782   1627 FD 76         sleu ; <= (unsigned)
2783   1629 E4            pop a
2784   162A             ; END RELATIONAL
2785   162A C0 00 00      cmp b, 0
2786   162D C6 38 16      je _if43_exit
2787   1630             _if43_true:
2788   1630             ;; return 0; 
2789   1630 26 00 00      mov b, $0
2790   1633 F9            leave
2791   1634 09            ret
2792   1635 0A 38 16      jmp _if43_exit
2793   1638             _if43_exit:
2794   1638             ;; for (i = 2; i * i <= num; i++) { 
2795   1638             _for44_init:
2796   1638 FA FF FF      lea d, [bp + -1] ; $i
2797   163B DA            push d
2798   163C 26 02 00      mov b, $2
2799   163F E7            pop d
2800   1640 FD 43         mov [d], b
2801   1642             _for44_cond:
2802   1642 FA FF FF      lea d, [bp + -1] ; $i
2803   1645 2A            mov b, [d]
2804   1646             ; START FACTORS
2805   1646 D7            push a
2806   1647 11            mov a, b
2807   1648 FA FF FF      lea d, [bp + -1] ; $i
2808   164B 2A            mov b, [d]
2809   164C AC            mul a, b ; *
2810   164D 11            mov a, b
2811   164E 27            mov b, a
2812   164F E4            pop a
2813   1650             ; END FACTORS
2814   1650             ; START RELATIONAL
2815   1650 D7            push a
2816   1651 11            mov a, b
2817   1652 FA 05 00      lea d, [bp + 5] ; $num
2818   1655 2A            mov b, [d]
2819   1656 B0            cmp a, b
2820   1657 FD 76         sleu ; <= (unsigned)
2821   1659 E4            pop a
2822   165A             ; END RELATIONAL
2823   165A C0 00 00      cmp b, 0
2824   165D C6 95 16      je _for44_exit
2825   1660             _for44_block:
2826   1660             ;; if (num % i == 0) return 0; 
2827   1660             _if45_cond:
2828   1660 FA 05 00      lea d, [bp + 5] ; $num
2829   1663 2A            mov b, [d]
2830   1664             ; START FACTORS
2831   1664 D7            push a
2832   1665 11            mov a, b
2833   1666 FA FF FF      lea d, [bp + -1] ; $i
2834   1669 2A            mov b, [d]
2835   166A AE            div a, b ; 
2836   166B 11            mov a, b
2837   166C 27            mov b, a
2838   166D E4            pop a
2839   166E             ; END FACTORS
2840   166E             ; START RELATIONAL
2841   166E D7            push a
2842   166F 11            mov a, b
2843   1670 26 00 00      mov b, $0
2844   1673 B0            cmp a, b
2845   1674 FD 71         seq ; ==
2846   1676 E4            pop a
2847   1677             ; END RELATIONAL
2848   1677 C0 00 00      cmp b, 0
2849   167A C6 85 16      je _if45_exit
2850   167D             _if45_true:
2851   167D             ;; return 0; 
2852   167D 26 00 00      mov b, $0
2853   1680 F9            leave
2854   1681 09            ret
2855   1682 0A 85 16      jmp _if45_exit
2856   1685             _if45_exit:
2857   1685             _for44_update:
2858   1685 FA FF FF      lea d, [bp + -1] ; $i
2859   1688 2A            mov b, [d]
2860   1689 D8            push b
2861   168A FD 77         inc b
2862   168C FA FF FF      lea d, [bp + -1] ; $i
2863   168F FD 43         mov [d], b
2864   1691 E5            pop b
2865   1692 0A 42 16      jmp _for44_cond
2866   1695             _for44_exit:
2867   1695             ;; return 1; 
2868   1695 26 01 00      mov b, $1
2869   1698 F9            leave
2870   1699 09            ret
2871   169A             ; --- END TEXT BLOCK
2872   169A             
2873   169A             ; --- BEGIN DATA BLOCK
2874   169A 00 00       _top: .fill 2, 0
2875   169C 45 6E 74 65 __s0: .db "Enter a number to find all prime numbers up to it: ", 0
2875   16A0 72 20 61 20 
2875   16A4 6E 75 6D 62 
2875   16A8 65 72 20 74 
2875   16AC 6F 20 66 69 
2875   16B0 6E 64 20 61 
2875   16B4 6C 6C 20 70 
2875   16B8 72 69 6D 65 
2875   16BC 20 6E 75 6D 
2875   16C0 62 65 72 73 
2875   16C4 20 75 70 20 
2875   16C8 74 6F 20 69 
2875   16CC 74 3A 20 00 
2876   16D0 50 72 69 6D __s1: .db "Prime numbers are: \n", 0
2876   16D4 65 20 6E 75 
2876   16D8 6D 62 65 72 
2876   16DC 73 20 61 72 
2876   16E0 65 3A 20 0A 
2876   16E4 00 
2877   16E5 25 64 0A 00 __s2: .db "%d\n", 0
2878   16E9 55 6E 65 78 __s3: .db "Unexpected format in printf.", 0
2878   16ED 70 65 63 74 
2878   16F1 65 64 20 66 
2878   16F5 6F 72 6D 61 
2878   16F9 74 20 69 6E 
2878   16FD 20 70 72 69 
2878   1701 6E 74 66 2E 
2878   1705 00 
2879   1706 45 72 72 6F __s4: .db "Error: Unknown argument type.\n", 0
2879   170A 72 3A 20 55 
2879   170E 6E 6B 6E 6F 
2879   1712 77 6E 20 61 
2879   1716 72 67 75 6D 
2879   171A 65 6E 74 20 
2879   171E 74 79 70 65 
2879   1722 2E 0A 00 
2880   1725 1B 5B 32 4A __s5: .db "\033[2J\033[H", 0
2880   1729 1B 5B 48 00 
2881   172D             
2882   172D 2F 17       _heap_top: .dw _heap
2883   172F 00          _heap: .db 0
2884   1730             ; --- END DATA BLOCK
2885   1730             
2886   1730             .end
tasm: Number of errors = 0
