0001   0000             ; --- FILENAME: programs/primes
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $N 
0011   0408             ; $i 
0012   0408 52 04 00      sub sp, 4
0013   040B             ;; printf("Enter a number to find all prime numbers up to it: "); 
0014   040B 26 36 14      mov b, __s0 ; "Enter a number to find all prime numbers up to it: "
0015   040E FD AB         swp b
0016   0410 D8            push b
0017   0411 07 E7 06      call printf
0018   0414 51 02 00      add sp, 2
0019   0417             ;; N = scann(); 
0020   0417 FA FF FF      lea d, [bp + -1] ; $N
0021   041A DA            push d
0022   041B 07 FC 0C      call scann
0023   041E E7            pop d
0024   041F FD 43         mov [d], b
0025   0421             ;; print("Prime numbers are: \n"); 
0026   0421 26 6A 14      mov b, __s1 ; "Prime numbers are: \n"
0027   0424 FD AB         swp b
0028   0426 D8            push b
0029   0427 07 21 0D      call print
0030   042A 51 02 00      add sp, 2
0031   042D             ;; for (i = 2; i <= N; i++) { 
0032   042D             _for1_init:
0033   042D FA FD FF      lea d, [bp + -3] ; $i
0034   0430 DA            push d
0035   0431 26 02 00      mov b, $2
0036   0434 E7            pop d
0037   0435 FD 43         mov [d], b
0038   0437             _for1_cond:
0039   0437 FA FD FF      lea d, [bp + -3] ; $i
0040   043A 2A            mov b, [d]
0041   043B             ; START RELATIONAL
0042   043B D7            push a
0043   043C 11            mov a, b
0044   043D FA FF FF      lea d, [bp + -1] ; $N
0045   0440 2A            mov b, [d]
0046   0441 B0            cmp a, b
0047   0442 FD 74         sle ; <=
0048   0444 E4            pop a
0049   0445             ; END RELATIONAL
0050   0445 C0 00 00      cmp b, 0
0051   0448 C6 8C 04      je _for1_exit
0052   044B             _for1_block:
0053   044B             ;; if (isPrime(i)) { 
0054   044B             _if2_cond:
0055   044B FA FD FF      lea d, [bp + -3] ; $i
0056   044E 2A            mov b, [d]
0057   044F FD AB         swp b
0058   0451 D8            push b
0059   0452 07 AF 13      call isPrime
0060   0455 51 02 00      add sp, 2
0061   0458 C0 00 00      cmp b, 0
0062   045B C6 7A 04      je _if2_exit
0063   045E             _if2_true:
0064   045E             ;; printu(i); 
0065   045E FA FD FF      lea d, [bp + -3] ; $i
0066   0461 2A            mov b, [d]
0067   0462 FD AB         swp b
0068   0464 D8            push b
0069   0465 07 ED 0B      call printu
0070   0468 51 02 00      add sp, 2
0071   046B             ;; print("\n"); 
0072   046B 26 7F 14      mov b, __s2 ; "\n"
0073   046E FD AB         swp b
0074   0470 D8            push b
0075   0471 07 21 0D      call print
0076   0474 51 02 00      add sp, 2
0077   0477 0A 7A 04      jmp _if2_exit
0078   047A             _if2_exit:
0079   047A             _for1_update:
0080   047A FA FD FF      lea d, [bp + -3] ; $i
0081   047D 2A            mov b, [d]
0082   047E FD 79         mov g, b
0083   0480 FD 77         inc b
0084   0482 FA FD FF      lea d, [bp + -3] ; $i
0085   0485 FD 43         mov [d], b
0086   0487 FD 27         mov b, g
0087   0489 0A 37 04      jmp _for1_cond
0088   048C             _for1_exit:
0089   048C             ;; return 0; 
0090   048C 26 00 00      mov b, $0
0091   048F F9            leave
0092   0490 05 0B         syscall sys_terminate_proc
0093   0492             
0094   0492             strcpy:
0095   0492 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0096   0495             ; $psrc 
0097   0495             ; $pdest 
0098   0495 52 04 00      sub sp, 4
0099   0498             ;; psrc = src; 
0100   0498 FA FF FF      lea d, [bp + -1] ; $psrc
0101   049B DA            push d
0102   049C FA 05 00      lea d, [bp + 5] ; $src
0103   049F 2A            mov b, [d]
0104   04A0 E7            pop d
0105   04A1 FD 43         mov [d], b
0106   04A3             ;; pdest = dest; 
0107   04A3 FA FD FF      lea d, [bp + -3] ; $pdest
0108   04A6 DA            push d
0109   04A7 FA 07 00      lea d, [bp + 7] ; $dest
0110   04AA 2A            mov b, [d]
0111   04AB E7            pop d
0112   04AC FD 43         mov [d], b
0113   04AE             ;; while(*psrc) *pdest++ = *psrc++; 
0114   04AE             _while3_cond:
0115   04AE FA FF FF      lea d, [bp + -1] ; $psrc
0116   04B1 2A            mov b, [d]
0117   04B2 74            mov d, b
0118   04B3 32            mov bl, [d]
0119   04B4 A7 00         mov bh, 0
0120   04B6 C0 00 00      cmp b, 0
0121   04B9 C6 E5 04      je _while3_exit
0122   04BC             _while3_block:
0123   04BC             ;; *pdest++ = *psrc++; 
0124   04BC FA FD FF      lea d, [bp + -3] ; $pdest
0125   04BF 2A            mov b, [d]
0126   04C0 FD 79         mov g, b
0127   04C2 FD 77         inc b
0128   04C4 FA FD FF      lea d, [bp + -3] ; $pdest
0129   04C7 FD 43         mov [d], b
0130   04C9 FD 27         mov b, g
0131   04CB D8            push b
0132   04CC FA FF FF      lea d, [bp + -1] ; $psrc
0133   04CF 2A            mov b, [d]
0134   04D0 FD 79         mov g, b
0135   04D2 FD 77         inc b
0136   04D4 FA FF FF      lea d, [bp + -1] ; $psrc
0137   04D7 FD 43         mov [d], b
0138   04D9 FD 27         mov b, g
0139   04DB 74            mov d, b
0140   04DC 32            mov bl, [d]
0141   04DD A7 00         mov bh, 0
0142   04DF E7            pop d
0143   04E0 FD 3E         mov [d], bl
0144   04E2 0A AE 04      jmp _while3_cond
0145   04E5             _while3_exit:
0146   04E5             ;; *pdest = '\0'; 
0147   04E5 FA FD FF      lea d, [bp + -3] ; $pdest
0148   04E8 2A            mov b, [d]
0149   04E9 D8            push b
0150   04EA 26 00 00      mov b, $0
0151   04ED E7            pop d
0152   04EE FD 3E         mov [d], bl
0153   04F0 F9            leave
0154   04F1 09            ret
0155   04F2             
0156   04F2             strcmp:
0157   04F2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0158   04F5             ;; while (*s1 && (*s1 == *s2)) { 
0159   04F5             _while4_cond:
0160   04F5 FA 07 00      lea d, [bp + 7] ; $s1
0161   04F8 2A            mov b, [d]
0162   04F9 74            mov d, b
0163   04FA 32            mov bl, [d]
0164   04FB A7 00         mov bh, 0
0165   04FD D7            push a
0166   04FE 11            mov a, b
0167   04FF FA 07 00      lea d, [bp + 7] ; $s1
0168   0502 2A            mov b, [d]
0169   0503 74            mov d, b
0170   0504 32            mov bl, [d]
0171   0505 A7 00         mov bh, 0
0172   0507             ; START RELATIONAL
0173   0507 D7            push a
0174   0508 11            mov a, b
0175   0509 FA 05 00      lea d, [bp + 5] ; $s2
0176   050C 2A            mov b, [d]
0177   050D 74            mov d, b
0178   050E 32            mov bl, [d]
0179   050F A7 00         mov bh, 0
0180   0511 B0            cmp a, b
0181   0512 FD 71         seq ; ==
0182   0514 E4            pop a
0183   0515             ; END RELATIONAL
0184   0515 FD A7         sand a, b ; &&
0185   0517 E4            pop a
0186   0518 C0 00 00      cmp b, 0
0187   051B C6 3F 05      je _while4_exit
0188   051E             _while4_block:
0189   051E             ;; s1++; 
0190   051E FA 07 00      lea d, [bp + 7] ; $s1
0191   0521 2A            mov b, [d]
0192   0522 FD 79         mov g, b
0193   0524 FD 77         inc b
0194   0526 FA 07 00      lea d, [bp + 7] ; $s1
0195   0529 FD 43         mov [d], b
0196   052B FD 27         mov b, g
0197   052D             ;; s2++; 
0198   052D FA 05 00      lea d, [bp + 5] ; $s2
0199   0530 2A            mov b, [d]
0200   0531 FD 79         mov g, b
0201   0533 FD 77         inc b
0202   0535 FA 05 00      lea d, [bp + 5] ; $s2
0203   0538 FD 43         mov [d], b
0204   053A FD 27         mov b, g
0205   053C 0A F5 04      jmp _while4_cond
0206   053F             _while4_exit:
0207   053F             ;; return *s1 - *s2; 
0208   053F FA 07 00      lea d, [bp + 7] ; $s1
0209   0542 2A            mov b, [d]
0210   0543 74            mov d, b
0211   0544 32            mov bl, [d]
0212   0545 A7 00         mov bh, 0
0213   0547             ; START TERMS
0214   0547 D7            push a
0215   0548 11            mov a, b
0216   0549 FA 05 00      lea d, [bp + 5] ; $s2
0217   054C 2A            mov b, [d]
0218   054D 74            mov d, b
0219   054E 32            mov bl, [d]
0220   054F A7 00         mov bh, 0
0221   0551 60            sub a, b
0222   0552 27            mov b, a
0223   0553 E4            pop a
0224   0554             ; END TERMS
0225   0554 F9            leave
0226   0555 09            ret
0227   0556             
0228   0556             strcat:
0229   0556 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0230   0559             ; $dest_len 
0231   0559             ; $i 
0232   0559 52 04 00      sub sp, 4
0233   055C             ;; dest_len = strlen(dest); 
0234   055C FA FF FF      lea d, [bp + -1] ; $dest_len
0235   055F DA            push d
0236   0560 FA 07 00      lea d, [bp + 7] ; $dest
0237   0563 2A            mov b, [d]
0238   0564 FD AB         swp b
0239   0566 D8            push b
0240   0567 07 0C 06      call strlen
0241   056A 51 02 00      add sp, 2
0242   056D E7            pop d
0243   056E FD 43         mov [d], b
0244   0570             ;; for (i = 0; src[i] != 0; i=i+1) { 
0245   0570             _for5_init:
0246   0570 FA FD FF      lea d, [bp + -3] ; $i
0247   0573 DA            push d
0248   0574 26 00 00      mov b, $0
0249   0577 E7            pop d
0250   0578 FD 43         mov [d], b
0251   057A             _for5_cond:
0252   057A FA 05 00      lea d, [bp + 5] ; $src
0253   057D FD 2A         mov d, [d]
0254   057F D7            push a
0255   0580 DA            push d
0256   0581 FA FD FF      lea d, [bp + -3] ; $i
0257   0584 2A            mov b, [d]
0258   0585 E7            pop d
0259   0586 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0260   058A E4            pop a
0261   058B 32            mov bl, [d]
0262   058C A7 00         mov bh, 0
0263   058E             ; START RELATIONAL
0264   058E D7            push a
0265   058F 11            mov a, b
0266   0590 26 00 00      mov b, $0
0267   0593 B0            cmp a, b
0268   0594 FD 72         sneq ; !=
0269   0596 E4            pop a
0270   0597             ; END RELATIONAL
0271   0597 C0 00 00      cmp b, 0
0272   059A C6 E5 05      je _for5_exit
0273   059D             _for5_block:
0274   059D             ;; dest[dest_len + i] = src[i]; 
0275   059D FA 07 00      lea d, [bp + 7] ; $dest
0276   05A0 FD 2A         mov d, [d]
0277   05A2 D7            push a
0278   05A3 DA            push d
0279   05A4 FA FF FF      lea d, [bp + -1] ; $dest_len
0280   05A7 2A            mov b, [d]
0281   05A8             ; START TERMS
0282   05A8 D7            push a
0283   05A9 11            mov a, b
0284   05AA FA FD FF      lea d, [bp + -3] ; $i
0285   05AD 2A            mov b, [d]
0286   05AE 54            add a, b
0287   05AF 27            mov b, a
0288   05B0 E4            pop a
0289   05B1             ; END TERMS
0290   05B1 E7            pop d
0291   05B2 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0292   05B6 E4            pop a
0293   05B7 DA            push d
0294   05B8 FA 05 00      lea d, [bp + 5] ; $src
0295   05BB FD 2A         mov d, [d]
0296   05BD D7            push a
0297   05BE DA            push d
0298   05BF FA FD FF      lea d, [bp + -3] ; $i
0299   05C2 2A            mov b, [d]
0300   05C3 E7            pop d
0301   05C4 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0302   05C8 E4            pop a
0303   05C9 32            mov bl, [d]
0304   05CA A7 00         mov bh, 0
0305   05CC E7            pop d
0306   05CD FD 3E         mov [d], bl
0307   05CF             _for5_update:
0308   05CF FA FD FF      lea d, [bp + -3] ; $i
0309   05D2 DA            push d
0310   05D3 FA FD FF      lea d, [bp + -3] ; $i
0311   05D6 2A            mov b, [d]
0312   05D7             ; START TERMS
0313   05D7 D7            push a
0314   05D8 11            mov a, b
0315   05D9 26 01 00      mov b, $1
0316   05DC 54            add a, b
0317   05DD 27            mov b, a
0318   05DE E4            pop a
0319   05DF             ; END TERMS
0320   05DF E7            pop d
0321   05E0 FD 43         mov [d], b
0322   05E2 0A 7A 05      jmp _for5_cond
0323   05E5             _for5_exit:
0324   05E5             ;; dest[dest_len + i] = 0; 
0325   05E5 FA 07 00      lea d, [bp + 7] ; $dest
0326   05E8 FD 2A         mov d, [d]
0327   05EA D7            push a
0328   05EB DA            push d
0329   05EC FA FF FF      lea d, [bp + -1] ; $dest_len
0330   05EF 2A            mov b, [d]
0331   05F0             ; START TERMS
0332   05F0 D7            push a
0333   05F1 11            mov a, b
0334   05F2 FA FD FF      lea d, [bp + -3] ; $i
0335   05F5 2A            mov b, [d]
0336   05F6 54            add a, b
0337   05F7 27            mov b, a
0338   05F8 E4            pop a
0339   05F9             ; END TERMS
0340   05F9 E7            pop d
0341   05FA FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0342   05FE E4            pop a
0343   05FF DA            push d
0344   0600 26 00 00      mov b, $0
0345   0603 E7            pop d
0346   0604 FD 3E         mov [d], bl
0347   0606             ;; return dest; 
0348   0606 FA 07 00      lea d, [bp + 7] ; $dest
0349   0609 2A            mov b, [d]
0350   060A F9            leave
0351   060B 09            ret
0352   060C             
0353   060C             strlen:
0354   060C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0355   060F             ; $length 
0356   060F 52 02 00      sub sp, 2
0357   0612             ;; length = 0; 
0358   0612 FA FF FF      lea d, [bp + -1] ; $length
0359   0615 DA            push d
0360   0616 26 00 00      mov b, $0
0361   0619 E7            pop d
0362   061A FD 43         mov [d], b
0363   061C             ;; while (str[length] != 0) { 
0364   061C             _while6_cond:
0365   061C FA 05 00      lea d, [bp + 5] ; $str
0366   061F FD 2A         mov d, [d]
0367   0621 D7            push a
0368   0622 DA            push d
0369   0623 FA FF FF      lea d, [bp + -1] ; $length
0370   0626 2A            mov b, [d]
0371   0627 E7            pop d
0372   0628 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0373   062C E4            pop a
0374   062D 32            mov bl, [d]
0375   062E A7 00         mov bh, 0
0376   0630             ; START RELATIONAL
0377   0630 D7            push a
0378   0631 11            mov a, b
0379   0632 26 00 00      mov b, $0
0380   0635 B0            cmp a, b
0381   0636 FD 72         sneq ; !=
0382   0638 E4            pop a
0383   0639             ; END RELATIONAL
0384   0639 C0 00 00      cmp b, 0
0385   063C C6 51 06      je _while6_exit
0386   063F             _while6_block:
0387   063F             ;; length++; 
0388   063F FA FF FF      lea d, [bp + -1] ; $length
0389   0642 2A            mov b, [d]
0390   0643 FD 79         mov g, b
0391   0645 FD 77         inc b
0392   0647 FA FF FF      lea d, [bp + -1] ; $length
0393   064A FD 43         mov [d], b
0394   064C FD 27         mov b, g
0395   064E 0A 1C 06      jmp _while6_cond
0396   0651             _while6_exit:
0397   0651             ;; return length; 
0398   0651 FA FF FF      lea d, [bp + -1] ; $length
0399   0654 2A            mov b, [d]
0400   0655 F9            leave
0401   0656 09            ret
0402   0657             
0403   0657             va_arg:
0404   0657 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0405   065A             ; $val 
0406   065A 52 02 00      sub sp, 2
0407   065D             ;; if(size == 1){ 
0408   065D             _if7_cond:
0409   065D FA 05 00      lea d, [bp + 5] ; $size
0410   0660 2A            mov b, [d]
0411   0661             ; START RELATIONAL
0412   0661 D7            push a
0413   0662 11            mov a, b
0414   0663 26 01 00      mov b, $1
0415   0666 B0            cmp a, b
0416   0667 FD 71         seq ; ==
0417   0669 E4            pop a
0418   066A             ; END RELATIONAL
0419   066A C0 00 00      cmp b, 0
0420   066D C6 89 06      je _if7_else
0421   0670             _if7_true:
0422   0670             ;; val = *(char*)arg->p; 
0423   0670 FA FF FF      lea d, [bp + -1] ; $val
0424   0673 DA            push d
0425   0674 FA 07 00      lea d, [bp + 7] ; $arg
0426   0677 FD 2A         mov d, [d]
0427   0679 58 00 00      add d, 0
0428   067C FD 14         clb
0429   067E 2A            mov b, [d]
0430   067F 74            mov d, b
0431   0680 32            mov bl, [d]
0432   0681 A7 00         mov bh, 0
0433   0683 E7            pop d
0434   0684 FD 43         mov [d], b
0435   0686 0A BF 06      jmp _if7_exit
0436   0689             _if7_else:
0437   0689             ;; if(size == 2){ 
0438   0689             _if8_cond:
0439   0689 FA 05 00      lea d, [bp + 5] ; $size
0440   068C 2A            mov b, [d]
0441   068D             ; START RELATIONAL
0442   068D D7            push a
0443   068E 11            mov a, b
0444   068F 26 02 00      mov b, $2
0445   0692 B0            cmp a, b
0446   0693 FD 71         seq ; ==
0447   0695 E4            pop a
0448   0696             ; END RELATIONAL
0449   0696 C0 00 00      cmp b, 0
0450   0699 C6 B3 06      je _if8_else
0451   069C             _if8_true:
0452   069C             ;; val = *(int*)arg->p; 
0453   069C FA FF FF      lea d, [bp + -1] ; $val
0454   069F DA            push d
0455   06A0 FA 07 00      lea d, [bp + 7] ; $arg
0456   06A3 FD 2A         mov d, [d]
0457   06A5 58 00 00      add d, 0
0458   06A8 FD 14         clb
0459   06AA 2A            mov b, [d]
0460   06AB 74            mov d, b
0461   06AC 2A            mov b, [d]
0462   06AD E7            pop d
0463   06AE FD 43         mov [d], b
0464   06B0 0A BF 06      jmp _if8_exit
0465   06B3             _if8_else:
0466   06B3             ;; print("Unknown type size in va_arg() call. Size needs to be either 1 or 2."); 
0467   06B3 26 81 14      mov b, __s3 ; "Unknown type size in va_arg() call. Size needs to be either 1 or 2."
0468   06B6 FD AB         swp b
0469   06B8 D8            push b
0470   06B9 07 21 0D      call print
0471   06BC 51 02 00      add sp, 2
0472   06BF             _if8_exit:
0473   06BF             _if7_exit:
0474   06BF             ;; arg->p = arg->p + size; 
0475   06BF FA 07 00      lea d, [bp + 7] ; $arg
0476   06C2 FD 2A         mov d, [d]
0477   06C4 58 00 00      add d, 0
0478   06C7 FD 14         clb
0479   06C9 DA            push d
0480   06CA FA 07 00      lea d, [bp + 7] ; $arg
0481   06CD FD 2A         mov d, [d]
0482   06CF 58 00 00      add d, 0
0483   06D2 FD 14         clb
0484   06D4 2A            mov b, [d]
0485   06D5             ; START TERMS
0486   06D5 D7            push a
0487   06D6 11            mov a, b
0488   06D7 FA 05 00      lea d, [bp + 5] ; $size
0489   06DA 2A            mov b, [d]
0490   06DB 54            add a, b
0491   06DC 27            mov b, a
0492   06DD E4            pop a
0493   06DE             ; END TERMS
0494   06DE E7            pop d
0495   06DF FD 43         mov [d], b
0496   06E1             ;; return val; 
0497   06E1 FA FF FF      lea d, [bp + -1] ; $val
0498   06E4 2A            mov b, [d]
0499   06E5 F9            leave
0500   06E6 09            ret
0501   06E7             
0502   06E7             printf:
0503   06E7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0504   06EA             ; $p 
0505   06EA             ; $fp 
0506   06EA             ; $i 
0507   06EA 52 06 00      sub sp, 6
0508   06ED             ;; fp = format; 
0509   06ED FA FD FF      lea d, [bp + -3] ; $fp
0510   06F0 DA            push d
0511   06F1 FA 05 00      lea d, [bp + 5] ; $format
0512   06F4 2A            mov b, [d]
0513   06F5 E7            pop d
0514   06F6 FD 43         mov [d], b
0515   06F8             ;; p = &format; 
0516   06F8 FA FF FF      lea d, [bp + -1] ; $p
0517   06FB DA            push d
0518   06FC FA 05 00      lea d, [bp + 5] ; $format
0519   06FF 2D            mov b, d
0520   0700 E7            pop d
0521   0701 FD 43         mov [d], b
0522   0703             ;; for(;;){ 
0523   0703             _for9_init:
0524   0703             _for9_cond:
0525   0703             _for9_block:
0526   0703             ;; if(!*fp) break; 
0527   0703             _if10_cond:
0528   0703 FA FD FF      lea d, [bp + -3] ; $fp
0529   0706 2A            mov b, [d]
0530   0707 74            mov d, b
0531   0708 32            mov bl, [d]
0532   0709 A7 00         mov bh, 0
0533   070B C0 00 00      cmp b, 0
0534   070E FD 71         seq ; !
0535   0710 C0 00 00      cmp b, 0
0536   0713 C6 1C 07      je _if10_exit
0537   0716             _if10_true:
0538   0716             ;; break; 
0539   0716 0A 66 08      jmp _for9_exit ; for break
0540   0719 0A 1C 07      jmp _if10_exit
0541   071C             _if10_exit:
0542   071C             ;; if(*fp == '%'){ 
0543   071C             _if11_cond:
0544   071C FA FD FF      lea d, [bp + -3] ; $fp
0545   071F 2A            mov b, [d]
0546   0720 74            mov d, b
0547   0721 32            mov bl, [d]
0548   0722 A7 00         mov bh, 0
0549   0724             ; START RELATIONAL
0550   0724 D7            push a
0551   0725 11            mov a, b
0552   0726 26 25 00      mov b, $25
0553   0729 B0            cmp a, b
0554   072A FD 71         seq ; ==
0555   072C E4            pop a
0556   072D             ; END RELATIONAL
0557   072D C0 00 00      cmp b, 0
0558   0730 C6 45 08      je _if11_else
0559   0733             _if11_true:
0560   0733             ;; fp++; 
0561   0733 FA FD FF      lea d, [bp + -3] ; $fp
0562   0736 2A            mov b, [d]
0563   0737 FD 79         mov g, b
0564   0739 FD 77         inc b
0565   073B FA FD FF      lea d, [bp + -3] ; $fp
0566   073E FD 43         mov [d], b
0567   0740 FD 27         mov b, g
0568   0742             ;; switch(*fp){ 
0569   0742             _switch12_expr:
0570   0742 FA FD FF      lea d, [bp + -3] ; $fp
0571   0745 2A            mov b, [d]
0572   0746 74            mov d, b
0573   0747 32            mov bl, [d]
0574   0748 A7 00         mov bh, 0
0575   074A             _switch12_comparisons:
0576   074A C1 64         cmp bl, $64
0577   074C C6 6E 07      je _switch12_case0
0578   074F C1 69         cmp bl, $69
0579   0751 C6 6E 07      je _switch12_case1
0580   0754 C1 75         cmp bl, $75
0581   0756 C6 93 07      je _switch12_case2
0582   0759 C1 78         cmp bl, $78
0583   075B C6 B8 07      je _switch12_case3
0584   075E C1 63         cmp bl, $63
0585   0760 C6 DD 07      je _switch12_case4
0586   0763 C1 73         cmp bl, $73
0587   0765 C6 02 08      je _switch12_case5
0588   0768 0A 27 08      jmp _switch12_default
0589   076B 0A 33 08      jmp _switch12_exit
0590   076E             _switch12_case0:
0591   076E             _switch12_case1:
0592   076E             ;; p = p - 2; 
0593   076E FA FF FF      lea d, [bp + -1] ; $p
0594   0771 DA            push d
0595   0772 FA FF FF      lea d, [bp + -1] ; $p
0596   0775 2A            mov b, [d]
0597   0776             ; START TERMS
0598   0776 D7            push a
0599   0777 11            mov a, b
0600   0778 26 02 00      mov b, $2
0601   077B 60            sub a, b
0602   077C 27            mov b, a
0603   077D E4            pop a
0604   077E             ; END TERMS
0605   077E E7            pop d
0606   077F FD 43         mov [d], b
0607   0781             ;; prints(*(int*)p); 
0608   0781 FA FF FF      lea d, [bp + -1] ; $p
0609   0784 2A            mov b, [d]
0610   0785 74            mov d, b
0611   0786 2A            mov b, [d]
0612   0787 FD AB         swp b
0613   0789 D8            push b
0614   078A 07 F8 0A      call prints
0615   078D 51 02 00      add sp, 2
0616   0790             ;; break; 
0617   0790 0A 33 08      jmp _switch12_exit ; case break
0618   0793             _switch12_case2:
0619   0793             ;; p = p - 2; 
0620   0793 FA FF FF      lea d, [bp + -1] ; $p
0621   0796 DA            push d
0622   0797 FA FF FF      lea d, [bp + -1] ; $p
0623   079A 2A            mov b, [d]
0624   079B             ; START TERMS
0625   079B D7            push a
0626   079C 11            mov a, b
0627   079D 26 02 00      mov b, $2
0628   07A0 60            sub a, b
0629   07A1 27            mov b, a
0630   07A2 E4            pop a
0631   07A3             ; END TERMS
0632   07A3 E7            pop d
0633   07A4 FD 43         mov [d], b
0634   07A6             ;; printu(*(unsigned int*)p); 
0635   07A6 FA FF FF      lea d, [bp + -1] ; $p
0636   07A9 2A            mov b, [d]
0637   07AA 74            mov d, b
0638   07AB 2A            mov b, [d]
0639   07AC FD AB         swp b
0640   07AE D8            push b
0641   07AF 07 ED 0B      call printu
0642   07B2 51 02 00      add sp, 2
0643   07B5             ;; break; 
0644   07B5 0A 33 08      jmp _switch12_exit ; case break
0645   07B8             _switch12_case3:
0646   07B8             ;; p = p - 2; 
0647   07B8 FA FF FF      lea d, [bp + -1] ; $p
0648   07BB DA            push d
0649   07BC FA FF FF      lea d, [bp + -1] ; $p
0650   07BF 2A            mov b, [d]
0651   07C0             ; START TERMS
0652   07C0 D7            push a
0653   07C1 11            mov a, b
0654   07C2 26 02 00      mov b, $2
0655   07C5 60            sub a, b
0656   07C6 27            mov b, a
0657   07C7 E4            pop a
0658   07C8             ; END TERMS
0659   07C8 E7            pop d
0660   07C9 FD 43         mov [d], b
0661   07CB             ;; printx16(*(unsigned int*)p); 
0662   07CB FA FF FF      lea d, [bp + -1] ; $p
0663   07CE 2A            mov b, [d]
0664   07CF 74            mov d, b
0665   07D0 2A            mov b, [d]
0666   07D1 FD AB         swp b
0667   07D3 D8            push b
0668   07D4 07 68 08      call printx16
0669   07D7 51 02 00      add sp, 2
0670   07DA             ;; break; 
0671   07DA 0A 33 08      jmp _switch12_exit ; case break
0672   07DD             _switch12_case4:
0673   07DD             ;; p = p - 2; 
0674   07DD FA FF FF      lea d, [bp + -1] ; $p
0675   07E0 DA            push d
0676   07E1 FA FF FF      lea d, [bp + -1] ; $p
0677   07E4 2A            mov b, [d]
0678   07E5             ; START TERMS
0679   07E5 D7            push a
0680   07E6 11            mov a, b
0681   07E7 26 02 00      mov b, $2
0682   07EA 60            sub a, b
0683   07EB 27            mov b, a
0684   07EC E4            pop a
0685   07ED             ; END TERMS
0686   07ED E7            pop d
0687   07EE FD 43         mov [d], b
0688   07F0             ;; putchar(*(char*)p); 
0689   07F0 FA FF FF      lea d, [bp + -1] ; $p
0690   07F3 2A            mov b, [d]
0691   07F4 74            mov d, b
0692   07F5 32            mov bl, [d]
0693   07F6 A7 00         mov bh, 0
0694   07F8 DD            push bl
0695   07F9 07 D9 0C      call putchar
0696   07FC 51 01 00      add sp, 1
0697   07FF             ;; break; 
0698   07FF 0A 33 08      jmp _switch12_exit ; case break
0699   0802             _switch12_case5:
0700   0802             ;; p = p - 2; 
0701   0802 FA FF FF      lea d, [bp + -1] ; $p
0702   0805 DA            push d
0703   0806 FA FF FF      lea d, [bp + -1] ; $p
0704   0809 2A            mov b, [d]
0705   080A             ; START TERMS
0706   080A D7            push a
0707   080B 11            mov a, b
0708   080C 26 02 00      mov b, $2
0709   080F 60            sub a, b
0710   0810 27            mov b, a
0711   0811 E4            pop a
0712   0812             ; END TERMS
0713   0812 E7            pop d
0714   0813 FD 43         mov [d], b
0715   0815             ;; print(*(char**)p); 
0716   0815 FA FF FF      lea d, [bp + -1] ; $p
0717   0818 2A            mov b, [d]
0718   0819 74            mov d, b
0719   081A 2A            mov b, [d]
0720   081B FD AB         swp b
0721   081D D8            push b
0722   081E 07 21 0D      call print
0723   0821 51 02 00      add sp, 2
0724   0824             ;; break; 
0725   0824 0A 33 08      jmp _switch12_exit ; case break
0726   0827             _switch12_default:
0727   0827             ;; print("Error: Unknown argument type.\n"); 
0728   0827 26 C5 14      mov b, __s4 ; "Error: Unknown argument type.\n"
0729   082A FD AB         swp b
0730   082C D8            push b
0731   082D 07 21 0D      call print
0732   0830 51 02 00      add sp, 2
0733   0833             _switch12_exit:
0734   0833             ;; fp++; 
0735   0833 FA FD FF      lea d, [bp + -3] ; $fp
0736   0836 2A            mov b, [d]
0737   0837 FD 79         mov g, b
0738   0839 FD 77         inc b
0739   083B FA FD FF      lea d, [bp + -3] ; $fp
0740   083E FD 43         mov [d], b
0741   0840 FD 27         mov b, g
0742   0842 0A 63 08      jmp _if11_exit
0743   0845             _if11_else:
0744   0845             ;; putchar(*fp); 
0745   0845 FA FD FF      lea d, [bp + -3] ; $fp
0746   0848 2A            mov b, [d]
0747   0849 74            mov d, b
0748   084A 32            mov bl, [d]
0749   084B A7 00         mov bh, 0
0750   084D DD            push bl
0751   084E 07 D9 0C      call putchar
0752   0851 51 01 00      add sp, 1
0753   0854             ;; fp++; 
0754   0854 FA FD FF      lea d, [bp + -3] ; $fp
0755   0857 2A            mov b, [d]
0756   0858 FD 79         mov g, b
0757   085A FD 77         inc b
0758   085C FA FD FF      lea d, [bp + -3] ; $fp
0759   085F FD 43         mov [d], b
0760   0861 FD 27         mov b, g
0761   0863             _if11_exit:
0762   0863             _for9_update:
0763   0863 0A 03 07      jmp _for9_cond
0764   0866             _for9_exit:
0765   0866 F9            leave
0766   0867 09            ret
0767   0868             
0768   0868             printx16:
0769   0868 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0770   086B             
0771   086B             ; --- BEGIN INLINE ASM BLOCK
0772   086B FA 05 00      lea d, [bp + 5] ; $hex
0773   086E 2A            mov b, [d]
0774   086F 07 A2 10      call print_u16x
0775   0872             ; --- END INLINE ASM BLOCK
0776   0872             
0777   0872 F9            leave
0778   0873 09            ret
0779   0874             
0780   0874             printx8:
0781   0874 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0782   0877             
0783   0877             ; --- BEGIN INLINE ASM BLOCK
0784   0877 FA 05 00      lea d, [bp + 5] ; $hex
0785   087A 32            mov bl, [d]
0786   087B 07 E6 10      call print_u8x
0787   087E             ; --- END INLINE ASM BLOCK
0788   087E             
0789   087E F9            leave
0790   087F 09            ret
0791   0880             
0792   0880             hex_to_int:
0793   0880 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0794   0883             ; $value 
0795   0883 10 00 00      mov a, $0
0796   0886 45 FF FF      mov [bp + -1], a
0797   0889             ; $i 
0798   0889             ; $hex_char 
0799   0889             ; $len 
0800   0889 52 07 00      sub sp, 7
0801   088C             ;; len = strlen(hex_string); 
0802   088C FA FA FF      lea d, [bp + -6] ; $len
0803   088F DA            push d
0804   0890 FA 05 00      lea d, [bp + 5] ; $hex_string
0805   0893 2A            mov b, [d]
0806   0894 FD AB         swp b
0807   0896 D8            push b
0808   0897 07 0C 06      call strlen
0809   089A 51 02 00      add sp, 2
0810   089D E7            pop d
0811   089E FD 43         mov [d], b
0812   08A0             ;; for (i = 0; i < len; i++) { 
0813   08A0             _for13_init:
0814   08A0 FA FD FF      lea d, [bp + -3] ; $i
0815   08A3 DA            push d
0816   08A4 26 00 00      mov b, $0
0817   08A7 E7            pop d
0818   08A8 FD 43         mov [d], b
0819   08AA             _for13_cond:
0820   08AA FA FD FF      lea d, [bp + -3] ; $i
0821   08AD 2A            mov b, [d]
0822   08AE             ; START RELATIONAL
0823   08AE D7            push a
0824   08AF 11            mov a, b
0825   08B0 FA FA FF      lea d, [bp + -6] ; $len
0826   08B3 2A            mov b, [d]
0827   08B4 B0            cmp a, b
0828   08B5 FD 73         slt ; < 
0829   08B7 E4            pop a
0830   08B8             ; END RELATIONAL
0831   08B8 C0 00 00      cmp b, 0
0832   08BB C6 C0 09      je _for13_exit
0833   08BE             _for13_block:
0834   08BE             ;; hex_char = hex_string[i]; 
0835   08BE FA FC FF      lea d, [bp + -4] ; $hex_char
0836   08C1 DA            push d
0837   08C2 FA 05 00      lea d, [bp + 5] ; $hex_string
0838   08C5 FD 2A         mov d, [d]
0839   08C7 D7            push a
0840   08C8 DA            push d
0841   08C9 FA FD FF      lea d, [bp + -3] ; $i
0842   08CC 2A            mov b, [d]
0843   08CD E7            pop d
0844   08CE FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0845   08D2 E4            pop a
0846   08D3 32            mov bl, [d]
0847   08D4 A7 00         mov bh, 0
0848   08D6 E7            pop d
0849   08D7 FD 3E         mov [d], bl
0850   08D9             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0851   08D9             _if14_cond:
0852   08D9 FA FC FF      lea d, [bp + -4] ; $hex_char
0853   08DC 32            mov bl, [d]
0854   08DD A7 00         mov bh, 0
0855   08DF             ; START RELATIONAL
0856   08DF D7            push a
0857   08E0 11            mov a, b
0858   08E1 26 61 00      mov b, $61
0859   08E4 B0            cmp a, b
0860   08E5 FD 80         sge ; >=
0861   08E7 E4            pop a
0862   08E8             ; END RELATIONAL
0863   08E8 D7            push a
0864   08E9 11            mov a, b
0865   08EA FA FC FF      lea d, [bp + -4] ; $hex_char
0866   08ED 32            mov bl, [d]
0867   08EE A7 00         mov bh, 0
0868   08F0             ; START RELATIONAL
0869   08F0 D7            push a
0870   08F1 11            mov a, b
0871   08F2 26 66 00      mov b, $66
0872   08F5 B0            cmp a, b
0873   08F6 FD 74         sle ; <=
0874   08F8 E4            pop a
0875   08F9             ; END RELATIONAL
0876   08F9 FD A7         sand a, b ; &&
0877   08FB E4            pop a
0878   08FC C0 00 00      cmp b, 0
0879   08FF C6 30 09      je _if14_else
0880   0902             _if14_true:
0881   0902             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0882   0902 FA FF FF      lea d, [bp + -1] ; $value
0883   0905 DA            push d
0884   0906 FA FF FF      lea d, [bp + -1] ; $value
0885   0909 2A            mov b, [d]
0886   090A             ; START FACTORS
0887   090A D7            push a
0888   090B 11            mov a, b
0889   090C 26 10 00      mov b, $10
0890   090F AC            mul a, b ; *
0891   0910 11            mov a, b
0892   0911 27            mov b, a
0893   0912 E4            pop a
0894   0913             ; END FACTORS
0895   0913             ; START TERMS
0896   0913 D7            push a
0897   0914 11            mov a, b
0898   0915 FA FC FF      lea d, [bp + -4] ; $hex_char
0899   0918 32            mov bl, [d]
0900   0919 A7 00         mov bh, 0
0901   091B             ; START TERMS
0902   091B D7            push a
0903   091C 11            mov a, b
0904   091D 26 61 00      mov b, $61
0905   0920 60            sub a, b
0906   0921 26 0A 00      mov b, $a
0907   0924 54            add a, b
0908   0925 27            mov b, a
0909   0926 E4            pop a
0910   0927             ; END TERMS
0911   0927 54            add a, b
0912   0928 27            mov b, a
0913   0929 E4            pop a
0914   092A             ; END TERMS
0915   092A E7            pop d
0916   092B FD 43         mov [d], b
0917   092D 0A AE 09      jmp _if14_exit
0918   0930             _if14_else:
0919   0930             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0920   0930             _if15_cond:
0921   0930 FA FC FF      lea d, [bp + -4] ; $hex_char
0922   0933 32            mov bl, [d]
0923   0934 A7 00         mov bh, 0
0924   0936             ; START RELATIONAL
0925   0936 D7            push a
0926   0937 11            mov a, b
0927   0938 26 41 00      mov b, $41
0928   093B B0            cmp a, b
0929   093C FD 80         sge ; >=
0930   093E E4            pop a
0931   093F             ; END RELATIONAL
0932   093F D7            push a
0933   0940 11            mov a, b
0934   0941 FA FC FF      lea d, [bp + -4] ; $hex_char
0935   0944 32            mov bl, [d]
0936   0945 A7 00         mov bh, 0
0937   0947             ; START RELATIONAL
0938   0947 D7            push a
0939   0948 11            mov a, b
0940   0949 26 46 00      mov b, $46
0941   094C B0            cmp a, b
0942   094D FD 74         sle ; <=
0943   094F E4            pop a
0944   0950             ; END RELATIONAL
0945   0950 FD A7         sand a, b ; &&
0946   0952 E4            pop a
0947   0953 C0 00 00      cmp b, 0
0948   0956 C6 87 09      je _if15_else
0949   0959             _if15_true:
0950   0959             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0951   0959 FA FF FF      lea d, [bp + -1] ; $value
0952   095C DA            push d
0953   095D FA FF FF      lea d, [bp + -1] ; $value
0954   0960 2A            mov b, [d]
0955   0961             ; START FACTORS
0956   0961 D7            push a
0957   0962 11            mov a, b
0958   0963 26 10 00      mov b, $10
0959   0966 AC            mul a, b ; *
0960   0967 11            mov a, b
0961   0968 27            mov b, a
0962   0969 E4            pop a
0963   096A             ; END FACTORS
0964   096A             ; START TERMS
0965   096A D7            push a
0966   096B 11            mov a, b
0967   096C FA FC FF      lea d, [bp + -4] ; $hex_char
0968   096F 32            mov bl, [d]
0969   0970 A7 00         mov bh, 0
0970   0972             ; START TERMS
0971   0972 D7            push a
0972   0973 11            mov a, b
0973   0974 26 41 00      mov b, $41
0974   0977 60            sub a, b
0975   0978 26 0A 00      mov b, $a
0976   097B 54            add a, b
0977   097C 27            mov b, a
0978   097D E4            pop a
0979   097E             ; END TERMS
0980   097E 54            add a, b
0981   097F 27            mov b, a
0982   0980 E4            pop a
0983   0981             ; END TERMS
0984   0981 E7            pop d
0985   0982 FD 43         mov [d], b
0986   0984 0A AE 09      jmp _if15_exit
0987   0987             _if15_else:
0988   0987             ;; value = (value * 16) + (hex_char - '0'); 
0989   0987 FA FF FF      lea d, [bp + -1] ; $value
0990   098A DA            push d
0991   098B FA FF FF      lea d, [bp + -1] ; $value
0992   098E 2A            mov b, [d]
0993   098F             ; START FACTORS
0994   098F D7            push a
0995   0990 11            mov a, b
0996   0991 26 10 00      mov b, $10
0997   0994 AC            mul a, b ; *
0998   0995 11            mov a, b
0999   0996 27            mov b, a
1000   0997 E4            pop a
1001   0998             ; END FACTORS
1002   0998             ; START TERMS
1003   0998 D7            push a
1004   0999 11            mov a, b
1005   099A FA FC FF      lea d, [bp + -4] ; $hex_char
1006   099D 32            mov bl, [d]
1007   099E A7 00         mov bh, 0
1008   09A0             ; START TERMS
1009   09A0 D7            push a
1010   09A1 11            mov a, b
1011   09A2 26 30 00      mov b, $30
1012   09A5 60            sub a, b
1013   09A6 27            mov b, a
1014   09A7 E4            pop a
1015   09A8             ; END TERMS
1016   09A8 54            add a, b
1017   09A9 27            mov b, a
1018   09AA E4            pop a
1019   09AB             ; END TERMS
1020   09AB E7            pop d
1021   09AC FD 43         mov [d], b
1022   09AE             _if15_exit:
1023   09AE             _if14_exit:
1024   09AE             _for13_update:
1025   09AE FA FD FF      lea d, [bp + -3] ; $i
1026   09B1 2A            mov b, [d]
1027   09B2 FD 79         mov g, b
1028   09B4 FD 77         inc b
1029   09B6 FA FD FF      lea d, [bp + -3] ; $i
1030   09B9 FD 43         mov [d], b
1031   09BB FD 27         mov b, g
1032   09BD 0A AA 08      jmp _for13_cond
1033   09C0             _for13_exit:
1034   09C0             ;; return value; 
1035   09C0 FA FF FF      lea d, [bp + -1] ; $value
1036   09C3 2A            mov b, [d]
1037   09C4 F9            leave
1038   09C5 09            ret
1039   09C6             
1040   09C6             atoi:
1041   09C6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1042   09C9             ; $result 
1043   09C9 10 00 00      mov a, $0
1044   09CC 45 FF FF      mov [bp + -1], a
1045   09CF             ; $sign 
1046   09CF 10 01 00      mov a, $1
1047   09D2 45 FD FF      mov [bp + -3], a
1048   09D5 52 04 00      sub sp, 4
1049   09D8             ;; while (*str == ' ') str++; 
1050   09D8             _while16_cond:
1051   09D8 FA 05 00      lea d, [bp + 5] ; $str
1052   09DB 2A            mov b, [d]
1053   09DC 74            mov d, b
1054   09DD 32            mov bl, [d]
1055   09DE A7 00         mov bh, 0
1056   09E0             ; START RELATIONAL
1057   09E0 D7            push a
1058   09E1 11            mov a, b
1059   09E2 26 20 00      mov b, $20
1060   09E5 B0            cmp a, b
1061   09E6 FD 71         seq ; ==
1062   09E8 E4            pop a
1063   09E9             ; END RELATIONAL
1064   09E9 C0 00 00      cmp b, 0
1065   09EC C6 01 0A      je _while16_exit
1066   09EF             _while16_block:
1067   09EF             ;; str++; 
1068   09EF FA 05 00      lea d, [bp + 5] ; $str
1069   09F2 2A            mov b, [d]
1070   09F3 FD 79         mov g, b
1071   09F5 FD 77         inc b
1072   09F7 FA 05 00      lea d, [bp + 5] ; $str
1073   09FA FD 43         mov [d], b
1074   09FC FD 27         mov b, g
1075   09FE 0A D8 09      jmp _while16_cond
1076   0A01             _while16_exit:
1077   0A01             ;; if (*str == '-' || *str == '+') { 
1078   0A01             _if17_cond:
1079   0A01 FA 05 00      lea d, [bp + 5] ; $str
1080   0A04 2A            mov b, [d]
1081   0A05 74            mov d, b
1082   0A06 32            mov bl, [d]
1083   0A07 A7 00         mov bh, 0
1084   0A09             ; START RELATIONAL
1085   0A09 D7            push a
1086   0A0A 11            mov a, b
1087   0A0B 26 2D 00      mov b, $2d
1088   0A0E B0            cmp a, b
1089   0A0F FD 71         seq ; ==
1090   0A11 E4            pop a
1091   0A12             ; END RELATIONAL
1092   0A12 D7            push a
1093   0A13 11            mov a, b
1094   0A14 FA 05 00      lea d, [bp + 5] ; $str
1095   0A17 2A            mov b, [d]
1096   0A18 74            mov d, b
1097   0A19 32            mov bl, [d]
1098   0A1A A7 00         mov bh, 0
1099   0A1C             ; START RELATIONAL
1100   0A1C D7            push a
1101   0A1D 11            mov a, b
1102   0A1E 26 2B 00      mov b, $2b
1103   0A21 B0            cmp a, b
1104   0A22 FD 71         seq ; ==
1105   0A24 E4            pop a
1106   0A25             ; END RELATIONAL
1107   0A25 FD A8         sor a, b ; ||
1108   0A27 E4            pop a
1109   0A28 C0 00 00      cmp b, 0
1110   0A2B C6 66 0A      je _if17_exit
1111   0A2E             _if17_true:
1112   0A2E             ;; if (*str == '-') sign = -1; 
1113   0A2E             _if18_cond:
1114   0A2E FA 05 00      lea d, [bp + 5] ; $str
1115   0A31 2A            mov b, [d]
1116   0A32 74            mov d, b
1117   0A33 32            mov bl, [d]
1118   0A34 A7 00         mov bh, 0
1119   0A36             ; START RELATIONAL
1120   0A36 D7            push a
1121   0A37 11            mov a, b
1122   0A38 26 2D 00      mov b, $2d
1123   0A3B B0            cmp a, b
1124   0A3C FD 71         seq ; ==
1125   0A3E E4            pop a
1126   0A3F             ; END RELATIONAL
1127   0A3F C0 00 00      cmp b, 0
1128   0A42 C6 54 0A      je _if18_exit
1129   0A45             _if18_true:
1130   0A45             ;; sign = -1; 
1131   0A45 FA FD FF      lea d, [bp + -3] ; $sign
1132   0A48 DA            push d
1133   0A49 26 01 00      mov b, $1
1134   0A4C FD 97         neg b
1135   0A4E E7            pop d
1136   0A4F FD 43         mov [d], b
1137   0A51 0A 54 0A      jmp _if18_exit
1138   0A54             _if18_exit:
1139   0A54             ;; str++; 
1140   0A54 FA 05 00      lea d, [bp + 5] ; $str
1141   0A57 2A            mov b, [d]
1142   0A58 FD 79         mov g, b
1143   0A5A FD 77         inc b
1144   0A5C FA 05 00      lea d, [bp + 5] ; $str
1145   0A5F FD 43         mov [d], b
1146   0A61 FD 27         mov b, g
1147   0A63 0A 66 0A      jmp _if17_exit
1148   0A66             _if17_exit:
1149   0A66             ;; while (*str >= '0' && *str <= '9') { 
1150   0A66             _while19_cond:
1151   0A66 FA 05 00      lea d, [bp + 5] ; $str
1152   0A69 2A            mov b, [d]
1153   0A6A 74            mov d, b
1154   0A6B 32            mov bl, [d]
1155   0A6C A7 00         mov bh, 0
1156   0A6E             ; START RELATIONAL
1157   0A6E D7            push a
1158   0A6F 11            mov a, b
1159   0A70 26 30 00      mov b, $30
1160   0A73 B0            cmp a, b
1161   0A74 FD 80         sge ; >=
1162   0A76 E4            pop a
1163   0A77             ; END RELATIONAL
1164   0A77 D7            push a
1165   0A78 11            mov a, b
1166   0A79 FA 05 00      lea d, [bp + 5] ; $str
1167   0A7C 2A            mov b, [d]
1168   0A7D 74            mov d, b
1169   0A7E 32            mov bl, [d]
1170   0A7F A7 00         mov bh, 0
1171   0A81             ; START RELATIONAL
1172   0A81 D7            push a
1173   0A82 11            mov a, b
1174   0A83 26 39 00      mov b, $39
1175   0A86 B0            cmp a, b
1176   0A87 FD 74         sle ; <=
1177   0A89 E4            pop a
1178   0A8A             ; END RELATIONAL
1179   0A8A FD A7         sand a, b ; &&
1180   0A8C E4            pop a
1181   0A8D C0 00 00      cmp b, 0
1182   0A90 C6 CE 0A      je _while19_exit
1183   0A93             _while19_block:
1184   0A93             ;; result = result * 10 + (*str - '0'); 
1185   0A93 FA FF FF      lea d, [bp + -1] ; $result
1186   0A96 DA            push d
1187   0A97 FA FF FF      lea d, [bp + -1] ; $result
1188   0A9A 2A            mov b, [d]
1189   0A9B             ; START FACTORS
1190   0A9B D7            push a
1191   0A9C 11            mov a, b
1192   0A9D 26 0A 00      mov b, $a
1193   0AA0 AC            mul a, b ; *
1194   0AA1 11            mov a, b
1195   0AA2 27            mov b, a
1196   0AA3 E4            pop a
1197   0AA4             ; END FACTORS
1198   0AA4             ; START TERMS
1199   0AA4 D7            push a
1200   0AA5 11            mov a, b
1201   0AA6 FA 05 00      lea d, [bp + 5] ; $str
1202   0AA9 2A            mov b, [d]
1203   0AAA 74            mov d, b
1204   0AAB 32            mov bl, [d]
1205   0AAC A7 00         mov bh, 0
1206   0AAE             ; START TERMS
1207   0AAE D7            push a
1208   0AAF 11            mov a, b
1209   0AB0 26 30 00      mov b, $30
1210   0AB3 60            sub a, b
1211   0AB4 27            mov b, a
1212   0AB5 E4            pop a
1213   0AB6             ; END TERMS
1214   0AB6 54            add a, b
1215   0AB7 27            mov b, a
1216   0AB8 E4            pop a
1217   0AB9             ; END TERMS
1218   0AB9 E7            pop d
1219   0ABA FD 43         mov [d], b
1220   0ABC             ;; str++; 
1221   0ABC FA 05 00      lea d, [bp + 5] ; $str
1222   0ABF 2A            mov b, [d]
1223   0AC0 FD 79         mov g, b
1224   0AC2 FD 77         inc b
1225   0AC4 FA 05 00      lea d, [bp + 5] ; $str
1226   0AC7 FD 43         mov [d], b
1227   0AC9 FD 27         mov b, g
1228   0ACB 0A 66 0A      jmp _while19_cond
1229   0ACE             _while19_exit:
1230   0ACE             ;; return sign * result; 
1231   0ACE FA FD FF      lea d, [bp + -3] ; $sign
1232   0AD1 2A            mov b, [d]
1233   0AD2             ; START FACTORS
1234   0AD2 D7            push a
1235   0AD3 11            mov a, b
1236   0AD4 FA FF FF      lea d, [bp + -1] ; $result
1237   0AD7 2A            mov b, [d]
1238   0AD8 AC            mul a, b ; *
1239   0AD9 11            mov a, b
1240   0ADA 27            mov b, a
1241   0ADB E4            pop a
1242   0ADC             ; END FACTORS
1243   0ADC F9            leave
1244   0ADD 09            ret
1245   0ADE             
1246   0ADE             gets:
1247   0ADE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1248   0AE1             
1249   0AE1             ; --- BEGIN INLINE ASM BLOCK
1250   0AE1 FA 05 00      lea d, [bp + 5] ; $s
1251   0AE4 15            mov a, [d]
1252   0AE5 3C            mov d, a
1253   0AE6 07 07 0F      call _gets
1254   0AE9             ; --- END INLINE ASM BLOCK
1255   0AE9             
1256   0AE9             ;; return strlen(s); 
1257   0AE9 FA 05 00      lea d, [bp + 5] ; $s
1258   0AEC 2A            mov b, [d]
1259   0AED FD AB         swp b
1260   0AEF D8            push b
1261   0AF0 07 0C 06      call strlen
1262   0AF3 51 02 00      add sp, 2
1263   0AF6 F9            leave
1264   0AF7 09            ret
1265   0AF8             
1266   0AF8             prints:
1267   0AF8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1268   0AFB             ; $digits 
1269   0AFB             ; $i 
1270   0AFB 10 00 00      mov a, $0
1271   0AFE 45 FA FF      mov [bp + -6], a
1272   0B01 52 07 00      sub sp, 7
1273   0B04             ;; if (num < 0) { 
1274   0B04             _if20_cond:
1275   0B04 FA 05 00      lea d, [bp + 5] ; $num
1276   0B07 2A            mov b, [d]
1277   0B08             ; START RELATIONAL
1278   0B08 D7            push a
1279   0B09 11            mov a, b
1280   0B0A 26 00 00      mov b, $0
1281   0B0D B0            cmp a, b
1282   0B0E FD 73         slt ; < 
1283   0B10 E4            pop a
1284   0B11             ; END RELATIONAL
1285   0B11 C0 00 00      cmp b, 0
1286   0B14 C6 31 0B      je _if20_else
1287   0B17             _if20_true:
1288   0B17             ;; putchar('-'); 
1289   0B17 26 2D 00      mov b, $2d
1290   0B1A DD            push bl
1291   0B1B 07 D9 0C      call putchar
1292   0B1E 51 01 00      add sp, 1
1293   0B21             ;; num = -num; 
1294   0B21 FA 05 00      lea d, [bp + 5] ; $num
1295   0B24 DA            push d
1296   0B25 FA 05 00      lea d, [bp + 5] ; $num
1297   0B28 2A            mov b, [d]
1298   0B29 FD 97         neg b
1299   0B2B E7            pop d
1300   0B2C FD 43         mov [d], b
1301   0B2E 0A 53 0B      jmp _if20_exit
1302   0B31             _if20_else:
1303   0B31             ;; if (num == 0) { 
1304   0B31             _if21_cond:
1305   0B31 FA 05 00      lea d, [bp + 5] ; $num
1306   0B34 2A            mov b, [d]
1307   0B35             ; START RELATIONAL
1308   0B35 D7            push a
1309   0B36 11            mov a, b
1310   0B37 26 00 00      mov b, $0
1311   0B3A B0            cmp a, b
1312   0B3B FD 71         seq ; ==
1313   0B3D E4            pop a
1314   0B3E             ; END RELATIONAL
1315   0B3E C0 00 00      cmp b, 0
1316   0B41 C6 53 0B      je _if21_exit
1317   0B44             _if21_true:
1318   0B44             ;; putchar('0'); 
1319   0B44 26 30 00      mov b, $30
1320   0B47 DD            push bl
1321   0B48 07 D9 0C      call putchar
1322   0B4B 51 01 00      add sp, 1
1323   0B4E             ;; return; 
1324   0B4E F9            leave
1325   0B4F 09            ret
1326   0B50 0A 53 0B      jmp _if21_exit
1327   0B53             _if21_exit:
1328   0B53             _if20_exit:
1329   0B53             ;; while (num > 0) { 
1330   0B53             _while22_cond:
1331   0B53 FA 05 00      lea d, [bp + 5] ; $num
1332   0B56 2A            mov b, [d]
1333   0B57             ; START RELATIONAL
1334   0B57 D7            push a
1335   0B58 11            mov a, b
1336   0B59 26 00 00      mov b, $0
1337   0B5C B0            cmp a, b
1338   0B5D FD 7F         sgt ; >
1339   0B5F E4            pop a
1340   0B60             ; END RELATIONAL
1341   0B60 C0 00 00      cmp b, 0
1342   0B63 C6 B0 0B      je _while22_exit
1343   0B66             _while22_block:
1344   0B66             ;; digits[i] = '0' + (num % 10); 
1345   0B66 FA FC FF      lea d, [bp + -4] ; $digits
1346   0B69 D7            push a
1347   0B6A DA            push d
1348   0B6B FA FA FF      lea d, [bp + -6] ; $i
1349   0B6E 2A            mov b, [d]
1350   0B6F E7            pop d
1351   0B70 5A            add d, b
1352   0B71 E4            pop a
1353   0B72 DA            push d
1354   0B73 26 30 00      mov b, $30
1355   0B76             ; START TERMS
1356   0B76 D7            push a
1357   0B77 11            mov a, b
1358   0B78 FA 05 00      lea d, [bp + 5] ; $num
1359   0B7B 2A            mov b, [d]
1360   0B7C             ; START FACTORS
1361   0B7C D7            push a
1362   0B7D 11            mov a, b
1363   0B7E 26 0A 00      mov b, $a
1364   0B81 AE            div a, b ; 
1365   0B82 11            mov a, b
1366   0B83 27            mov b, a
1367   0B84 E4            pop a
1368   0B85             ; END FACTORS
1369   0B85 54            add a, b
1370   0B86 27            mov b, a
1371   0B87 E4            pop a
1372   0B88             ; END TERMS
1373   0B88 E7            pop d
1374   0B89 FD 3E         mov [d], bl
1375   0B8B             ;; num = num / 10; 
1376   0B8B FA 05 00      lea d, [bp + 5] ; $num
1377   0B8E DA            push d
1378   0B8F FA 05 00      lea d, [bp + 5] ; $num
1379   0B92 2A            mov b, [d]
1380   0B93             ; START FACTORS
1381   0B93 D7            push a
1382   0B94 11            mov a, b
1383   0B95 26 0A 00      mov b, $a
1384   0B98 AE            div a, b
1385   0B99 27            mov b, a
1386   0B9A E4            pop a
1387   0B9B             ; END FACTORS
1388   0B9B E7            pop d
1389   0B9C FD 43         mov [d], b
1390   0B9E             ;; i++; 
1391   0B9E FA FA FF      lea d, [bp + -6] ; $i
1392   0BA1 2A            mov b, [d]
1393   0BA2 FD 79         mov g, b
1394   0BA4 FD 77         inc b
1395   0BA6 FA FA FF      lea d, [bp + -6] ; $i
1396   0BA9 FD 43         mov [d], b
1397   0BAB FD 27         mov b, g
1398   0BAD 0A 53 0B      jmp _while22_cond
1399   0BB0             _while22_exit:
1400   0BB0             ;; while (i > 0) { 
1401   0BB0             _while23_cond:
1402   0BB0 FA FA FF      lea d, [bp + -6] ; $i
1403   0BB3 2A            mov b, [d]
1404   0BB4             ; START RELATIONAL
1405   0BB4 D7            push a
1406   0BB5 11            mov a, b
1407   0BB6 26 00 00      mov b, $0
1408   0BB9 B0            cmp a, b
1409   0BBA FD 7F         sgt ; >
1410   0BBC E4            pop a
1411   0BBD             ; END RELATIONAL
1412   0BBD C0 00 00      cmp b, 0
1413   0BC0 C6 EB 0B      je _while23_exit
1414   0BC3             _while23_block:
1415   0BC3             ;; i--; 
1416   0BC3 FA FA FF      lea d, [bp + -6] ; $i
1417   0BC6 2A            mov b, [d]
1418   0BC7 FD 79         mov g, b
1419   0BC9 FD 7D         dec b
1420   0BCB FA FA FF      lea d, [bp + -6] ; $i
1421   0BCE FD 43         mov [d], b
1422   0BD0 FD 27         mov b, g
1423   0BD2             ;; putchar(digits[i]); 
1424   0BD2 FA FC FF      lea d, [bp + -4] ; $digits
1425   0BD5 D7            push a
1426   0BD6 DA            push d
1427   0BD7 FA FA FF      lea d, [bp + -6] ; $i
1428   0BDA 2A            mov b, [d]
1429   0BDB E7            pop d
1430   0BDC 5A            add d, b
1431   0BDD E4            pop a
1432   0BDE 32            mov bl, [d]
1433   0BDF A7 00         mov bh, 0
1434   0BE1 DD            push bl
1435   0BE2 07 D9 0C      call putchar
1436   0BE5 51 01 00      add sp, 1
1437   0BE8 0A B0 0B      jmp _while23_cond
1438   0BEB             _while23_exit:
1439   0BEB F9            leave
1440   0BEC 09            ret
1441   0BED             
1442   0BED             printu:
1443   0BED F8 00 00      enter 0 ; (push bp; mov bp, sp)
1444   0BF0             ; $digits 
1445   0BF0             ; $i 
1446   0BF0 52 07 00      sub sp, 7
1447   0BF3             ;; i = 0; 
1448   0BF3 FA FA FF      lea d, [bp + -6] ; $i
1449   0BF6 DA            push d
1450   0BF7 26 00 00      mov b, $0
1451   0BFA E7            pop d
1452   0BFB FD 43         mov [d], b
1453   0BFD             ;; if(num == 0){ 
1454   0BFD             _if24_cond:
1455   0BFD FA 05 00      lea d, [bp + 5] ; $num
1456   0C00 2A            mov b, [d]
1457   0C01             ; START RELATIONAL
1458   0C01 D7            push a
1459   0C02 11            mov a, b
1460   0C03 26 00 00      mov b, $0
1461   0C06 B0            cmp a, b
1462   0C07 FD 71         seq ; ==
1463   0C09 E4            pop a
1464   0C0A             ; END RELATIONAL
1465   0C0A C0 00 00      cmp b, 0
1466   0C0D C6 1F 0C      je _if24_exit
1467   0C10             _if24_true:
1468   0C10             ;; putchar('0'); 
1469   0C10 26 30 00      mov b, $30
1470   0C13 DD            push bl
1471   0C14 07 D9 0C      call putchar
1472   0C17 51 01 00      add sp, 1
1473   0C1A             ;; return; 
1474   0C1A F9            leave
1475   0C1B 09            ret
1476   0C1C 0A 1F 0C      jmp _if24_exit
1477   0C1F             _if24_exit:
1478   0C1F             ;; while (num > 0) { 
1479   0C1F             _while25_cond:
1480   0C1F FA 05 00      lea d, [bp + 5] ; $num
1481   0C22 2A            mov b, [d]
1482   0C23             ; START RELATIONAL
1483   0C23 D7            push a
1484   0C24 11            mov a, b
1485   0C25 26 00 00      mov b, $0
1486   0C28 B0            cmp a, b
1487   0C29 FD 81         sgu ; > (unsigned)
1488   0C2B E4            pop a
1489   0C2C             ; END RELATIONAL
1490   0C2C C0 00 00      cmp b, 0
1491   0C2F C6 7C 0C      je _while25_exit
1492   0C32             _while25_block:
1493   0C32             ;; digits[i] = '0' + (num % 10); 
1494   0C32 FA FC FF      lea d, [bp + -4] ; $digits
1495   0C35 D7            push a
1496   0C36 DA            push d
1497   0C37 FA FA FF      lea d, [bp + -6] ; $i
1498   0C3A 2A            mov b, [d]
1499   0C3B E7            pop d
1500   0C3C 5A            add d, b
1501   0C3D E4            pop a
1502   0C3E DA            push d
1503   0C3F 26 30 00      mov b, $30
1504   0C42             ; START TERMS
1505   0C42 D7            push a
1506   0C43 11            mov a, b
1507   0C44 FA 05 00      lea d, [bp + 5] ; $num
1508   0C47 2A            mov b, [d]
1509   0C48             ; START FACTORS
1510   0C48 D7            push a
1511   0C49 11            mov a, b
1512   0C4A 26 0A 00      mov b, $a
1513   0C4D AE            div a, b ; 
1514   0C4E 11            mov a, b
1515   0C4F 27            mov b, a
1516   0C50 E4            pop a
1517   0C51             ; END FACTORS
1518   0C51 54            add a, b
1519   0C52 27            mov b, a
1520   0C53 E4            pop a
1521   0C54             ; END TERMS
1522   0C54 E7            pop d
1523   0C55 FD 3E         mov [d], bl
1524   0C57             ;; num = num / 10; 
1525   0C57 FA 05 00      lea d, [bp + 5] ; $num
1526   0C5A DA            push d
1527   0C5B FA 05 00      lea d, [bp + 5] ; $num
1528   0C5E 2A            mov b, [d]
1529   0C5F             ; START FACTORS
1530   0C5F D7            push a
1531   0C60 11            mov a, b
1532   0C61 26 0A 00      mov b, $a
1533   0C64 AE            div a, b
1534   0C65 27            mov b, a
1535   0C66 E4            pop a
1536   0C67             ; END FACTORS
1537   0C67 E7            pop d
1538   0C68 FD 43         mov [d], b
1539   0C6A             ;; i++; 
1540   0C6A FA FA FF      lea d, [bp + -6] ; $i
1541   0C6D 2A            mov b, [d]
1542   0C6E FD 79         mov g, b
1543   0C70 FD 77         inc b
1544   0C72 FA FA FF      lea d, [bp + -6] ; $i
1545   0C75 FD 43         mov [d], b
1546   0C77 FD 27         mov b, g
1547   0C79 0A 1F 0C      jmp _while25_cond
1548   0C7C             _while25_exit:
1549   0C7C             ;; while (i > 0) { 
1550   0C7C             _while26_cond:
1551   0C7C FA FA FF      lea d, [bp + -6] ; $i
1552   0C7F 2A            mov b, [d]
1553   0C80             ; START RELATIONAL
1554   0C80 D7            push a
1555   0C81 11            mov a, b
1556   0C82 26 00 00      mov b, $0
1557   0C85 B0            cmp a, b
1558   0C86 FD 7F         sgt ; >
1559   0C88 E4            pop a
1560   0C89             ; END RELATIONAL
1561   0C89 C0 00 00      cmp b, 0
1562   0C8C C6 B7 0C      je _while26_exit
1563   0C8F             _while26_block:
1564   0C8F             ;; i--; 
1565   0C8F FA FA FF      lea d, [bp + -6] ; $i
1566   0C92 2A            mov b, [d]
1567   0C93 FD 79         mov g, b
1568   0C95 FD 7D         dec b
1569   0C97 FA FA FF      lea d, [bp + -6] ; $i
1570   0C9A FD 43         mov [d], b
1571   0C9C FD 27         mov b, g
1572   0C9E             ;; putchar(digits[i]); 
1573   0C9E FA FC FF      lea d, [bp + -4] ; $digits
1574   0CA1 D7            push a
1575   0CA2 DA            push d
1576   0CA3 FA FA FF      lea d, [bp + -6] ; $i
1577   0CA6 2A            mov b, [d]
1578   0CA7 E7            pop d
1579   0CA8 5A            add d, b
1580   0CA9 E4            pop a
1581   0CAA 32            mov bl, [d]
1582   0CAB A7 00         mov bh, 0
1583   0CAD DD            push bl
1584   0CAE 07 D9 0C      call putchar
1585   0CB1 51 01 00      add sp, 1
1586   0CB4 0A 7C 0C      jmp _while26_cond
1587   0CB7             _while26_exit:
1588   0CB7 F9            leave
1589   0CB8 09            ret
1590   0CB9             
1591   0CB9             rand:
1592   0CB9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1593   0CBC             ; $sec 
1594   0CBC 52 01 00      sub sp, 1
1595   0CBF             
1596   0CBF             ; --- BEGIN INLINE ASM BLOCK
1597   0CBF 19 00         mov al, 0
1598   0CC1 05 01         syscall sys_rtc					
1599   0CC3 1A            mov al, ah
1600   0CC4 FA 00 00      lea d, [bp + 0] ; $sec
1601   0CC7 1E            mov al, [d]
1602   0CC8             ; --- END INLINE ASM BLOCK
1603   0CC8             
1604   0CC8             ;; return sec; 
1605   0CC8 FA 00 00      lea d, [bp + 0] ; $sec
1606   0CCB 32            mov bl, [d]
1607   0CCC A7 00         mov bh, 0
1608   0CCE F9            leave
1609   0CCF 09            ret
1610   0CD0             
1611   0CD0             date:
1612   0CD0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1613   0CD3             
1614   0CD3             ; --- BEGIN INLINE ASM BLOCK
1615   0CD3 19 00         mov al, 0 
1616   0CD5 05 07         syscall sys_datetime
1617   0CD7             ; --- END INLINE ASM BLOCK
1618   0CD7             
1619   0CD7 F9            leave
1620   0CD8 09            ret
1621   0CD9             
1622   0CD9             putchar:
1623   0CD9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1624   0CDC             
1625   0CDC             ; --- BEGIN INLINE ASM BLOCK
1626   0CDC FA 05 00      lea d, [bp + 5] ; $c
1627   0CDF 1E            mov al, [d]
1628   0CE0 23            mov ah, al
1629   0CE1 07 00 0F      call _putchar
1630   0CE4             ; --- END INLINE ASM BLOCK
1631   0CE4             
1632   0CE4 F9            leave
1633   0CE5 09            ret
1634   0CE6             
1635   0CE6             getchar:
1636   0CE6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1637   0CE9             ; $c 
1638   0CE9 52 01 00      sub sp, 1
1639   0CEC             
1640   0CEC             ; --- BEGIN INLINE ASM BLOCK
1641   0CEC 07 F9 0E      call getch
1642   0CEF 1A            mov al, ah
1643   0CF0 FA 00 00      lea d, [bp + 0] ; $c
1644   0CF3 3E            mov [d], al
1645   0CF4             ; --- END INLINE ASM BLOCK
1646   0CF4             
1647   0CF4             ;; return c; 
1648   0CF4 FA 00 00      lea d, [bp + 0] ; $c
1649   0CF7 32            mov bl, [d]
1650   0CF8 A7 00         mov bh, 0
1651   0CFA F9            leave
1652   0CFB 09            ret
1653   0CFC             
1654   0CFC             scann:
1655   0CFC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1656   0CFF             ; $m 
1657   0CFF 52 02 00      sub sp, 2
1658   0D02             
1659   0D02             ; --- BEGIN INLINE ASM BLOCK
1660   0D02 07 44 11      call scan_u16d
1661   0D05 FA FF FF      lea d, [bp + -1] ; $m
1662   0D08 43            mov [d], a
1663   0D09             ; --- END INLINE ASM BLOCK
1664   0D09             
1665   0D09             ;; return m; 
1666   0D09 FA FF FF      lea d, [bp + -1] ; $m
1667   0D0C 2A            mov b, [d]
1668   0D0D F9            leave
1669   0D0E 09            ret
1670   0D0F             
1671   0D0F             puts:
1672   0D0F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1673   0D12             
1674   0D12             ; --- BEGIN INLINE ASM BLOCK
1675   0D12 FA 05 00      lea d, [bp + 5] ; $s
1676   0D15 15            mov a, [d]
1677   0D16 3C            mov d, a
1678   0D17 07 4A 10      call _puts
1679   0D1A 10 00 0A      mov a, $0A00
1680   0D1D 05 03         syscall sys_io
1681   0D1F             ; --- END INLINE ASM BLOCK
1682   0D1F             
1683   0D1F F9            leave
1684   0D20 09            ret
1685   0D21             
1686   0D21             print:
1687   0D21 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1688   0D24             
1689   0D24             ; --- BEGIN INLINE ASM BLOCK
1690   0D24 FA 05 00      lea d, [bp + 5] ; $s
1691   0D27 FD 2A         mov d, [d]
1692   0D29 07 4A 10      call _puts
1693   0D2C             ; --- END INLINE ASM BLOCK
1694   0D2C             
1695   0D2C F9            leave
1696   0D2D 09            ret
1697   0D2E             
1698   0D2E             loadfile:
1699   0D2E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1700   0D31             
1701   0D31             ; --- BEGIN INLINE ASM BLOCK
1702   0D31 FA 05 00      lea d, [bp + 5] ; $destination
1703   0D34 15            mov a, [d]
1704   0D35 4F            mov di, a
1705   0D36 FA 07 00      lea d, [bp + 7] ; $filename
1706   0D39 FD 2A         mov d, [d]
1707   0D3B 19 14         mov al, 20
1708   0D3D 05 04         syscall sys_filesystem
1709   0D3F             ; --- END INLINE ASM BLOCK
1710   0D3F             
1711   0D3F F9            leave
1712   0D40 09            ret
1713   0D41             
1714   0D41             create_file:
1715   0D41 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1716   0D44 F9            leave
1717   0D45 09            ret
1718   0D46             
1719   0D46             delete_file:
1720   0D46 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1721   0D49             
1722   0D49             ; --- BEGIN INLINE ASM BLOCK
1723   0D49 FA 05 00      lea d, [bp + 5] ; $filename
1724   0D4C 19 0A         mov al, 10
1725   0D4E 05 04         syscall sys_filesystem
1726   0D50             ; --- END INLINE ASM BLOCK
1727   0D50             
1728   0D50 F9            leave
1729   0D51 09            ret
1730   0D52             
1731   0D52             fopen:
1732   0D52 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1733   0D55 F9            leave
1734   0D56 09            ret
1735   0D57             
1736   0D57             fclose:
1737   0D57 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1738   0D5A F9            leave
1739   0D5B 09            ret
1740   0D5C             
1741   0D5C             alloc:
1742   0D5C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1743   0D5F             ;; heap_top = heap_top + bytes; 
1744   0D5F 3B EC 14      mov d, _heap_top ; $heap_top
1745   0D62 DA            push d
1746   0D63 3B EC 14      mov d, _heap_top ; $heap_top
1747   0D66 2A            mov b, [d]
1748   0D67             ; START TERMS
1749   0D67 D7            push a
1750   0D68 11            mov a, b
1751   0D69 FA 05 00      lea d, [bp + 5] ; $bytes
1752   0D6C 2A            mov b, [d]
1753   0D6D 54            add a, b
1754   0D6E 27            mov b, a
1755   0D6F E4            pop a
1756   0D70             ; END TERMS
1757   0D70 E7            pop d
1758   0D71 FD 43         mov [d], b
1759   0D73             ;; return heap_top - bytes; 
1760   0D73 3B EC 14      mov d, _heap_top ; $heap_top
1761   0D76 2A            mov b, [d]
1762   0D77             ; START TERMS
1763   0D77 D7            push a
1764   0D78 11            mov a, b
1765   0D79 FA 05 00      lea d, [bp + 5] ; $bytes
1766   0D7C 2A            mov b, [d]
1767   0D7D 60            sub a, b
1768   0D7E 27            mov b, a
1769   0D7F E4            pop a
1770   0D80             ; END TERMS
1771   0D80 F9            leave
1772   0D81 09            ret
1773   0D82             
1774   0D82             free:
1775   0D82 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1776   0D85             ;; return heap_top = heap_top - bytes; 
1777   0D85 3B EC 14      mov d, _heap_top ; $heap_top
1778   0D88 DA            push d
1779   0D89 3B EC 14      mov d, _heap_top ; $heap_top
1780   0D8C 2A            mov b, [d]
1781   0D8D             ; START TERMS
1782   0D8D D7            push a
1783   0D8E 11            mov a, b
1784   0D8F FA 05 00      lea d, [bp + 5] ; $bytes
1785   0D92 2A            mov b, [d]
1786   0D93 60            sub a, b
1787   0D94 27            mov b, a
1788   0D95 E4            pop a
1789   0D96             ; END TERMS
1790   0D96 E7            pop d
1791   0D97 FD 43         mov [d], b
1792   0D99 F9            leave
1793   0D9A 09            ret
1794   0D9B             
1795   0D9B             exit:
1796   0D9B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1797   0D9E             
1798   0D9E             ; --- BEGIN INLINE ASM BLOCK
1799   0D9E 05 0B         syscall sys_terminate_proc
1800   0DA0             ; --- END INLINE ASM BLOCK
1801   0DA0             
1802   0DA0 F9            leave
1803   0DA1 09            ret
1804   0DA2             
1805   0DA2             load_hex:
1806   0DA2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1807   0DA5             ; $temp 
1808   0DA5 52 02 00      sub sp, 2
1809   0DA8             ;; temp = alloc(32768); 
1810   0DA8 FA FF FF      lea d, [bp + -1] ; $temp
1811   0DAB DA            push d
1812   0DAC 26 00 80      mov b, $8000
1813   0DAF FD AB         swp b
1814   0DB1 D8            push b
1815   0DB2 07 5C 0D      call alloc
1816   0DB5 51 02 00      add sp, 2
1817   0DB8 E7            pop d
1818   0DB9 FD 43         mov [d], b
1819   0DBB             
1820   0DBB             ; --- BEGIN INLINE ASM BLOCK
1821   0DBB               
1822   0DBB               
1823   0DBB               
1824   0DBB               
1825   0DBB               
1826   0DBB             _load_hex:
1827   0DBB D7            push a
1828   0DBC D8            push b
1829   0DBD DA            push d
1830   0DBE E2            push si
1831   0DBF E3            push di
1832   0DC0 52 00 80      sub sp, $8000      
1833   0DC3 38 00 00      mov c, 0
1834   0DC6 48            mov a, sp
1835   0DC7 77            inc a
1836   0DC8 3C            mov d, a          
1837   0DC9 07 07 0F      call _gets        
1838   0DCC 4D            mov si, a
1839   0DCD             __load_hex_loop:
1840   0DCD F6            lodsb             
1841   0DCE B9 00         cmp al, 0         
1842   0DD0 C6 DE 0D      jz __load_hex_ret
1843   0DD3 36            mov bh, al
1844   0DD4 F6            lodsb
1845   0DD5 2F            mov bl, al
1846   0DD6 07 BD 0E      call _atoi        
1847   0DD9 F7            stosb             
1848   0DDA 78            inc c
1849   0DDB 0A CD 0D      jmp __load_hex_loop
1850   0DDE             __load_hex_ret:
1851   0DDE 51 00 80      add sp, $8000
1852   0DE1 F0            pop di
1853   0DE2 EF            pop si
1854   0DE3 E7            pop d
1855   0DE4 E5            pop b
1856   0DE5 E4            pop a
1857   0DE6             ; --- END INLINE ASM BLOCK
1858   0DE6             
1859   0DE6 F9            leave
1860   0DE7 09            ret
1861   0DE8             
1862   0DE8             getparam:
1863   0DE8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1864   0DEB             ; $data 
1865   0DEB 52 01 00      sub sp, 1
1866   0DEE             
1867   0DEE             ; --- BEGIN INLINE ASM BLOCK
1868   0DEE 19 04         mov al, 4
1869   0DF0 FA 05 00      lea d, [bp + 5] ; $address
1870   0DF3 FD 2A         mov d, [d]
1871   0DF5 05 0C         syscall sys_system
1872   0DF7 FA 00 00      lea d, [bp + 0] ; $data
1873   0DFA FD 3E         mov [d], bl
1874   0DFC             ; --- END INLINE ASM BLOCK
1875   0DFC             
1876   0DFC             ;; return data; 
1877   0DFC FA 00 00      lea d, [bp + 0] ; $data
1878   0DFF 32            mov bl, [d]
1879   0E00 A7 00         mov bh, 0
1880   0E02 F9            leave
1881   0E03 09            ret
1882   0E04             
1883   0E04             clear:
1884   0E04 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1885   0E07             ;; print("\033[2J\033[H"); 
1886   0E07 26 E4 14      mov b, __s5 ; "\033[2J\033[H"
1887   0E0A FD AB         swp b
1888   0E0C D8            push b
1889   0E0D 07 21 0D      call print
1890   0E10 51 02 00      add sp, 2
1891   0E13 F9            leave
1892   0E14 09            ret
1893   0E15             
1894   0E15             include_stdio_asm:
1895   0E15 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1896   0E18             
1897   0E18             ; --- BEGIN INLINE ASM BLOCK
1898   0E18             .include "lib/stdio.asm"
0001+  0E18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0E18             ; stdio.s
0003+  0E18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0E18             .include "lib/string.asm"
0001++ 0E18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0E18             ; string.s
0003++ 0E18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0E18             
0005++ 0E18             
0006++ 0E18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0E18             ; _strrev
0008++ 0E18             ; reverse a string
0009++ 0E18             ; D = string address
0010++ 0E18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0E18             ; 01234
0012++ 0E18             _strrev:
0013++ 0E18 4B          	pusha
0014++ 0E19 07 5F 0E    	call _strlen	; length in C
0015++ 0E1C 12          	mov a, c
0016++ 0E1D AF 01 00    	cmp a, 1
0017++ 0E20 D0 3A 0E    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0E23 7D          	dec a
0019++ 0E24 FD 4E       	mov si, d	; beginning of string
0020++ 0E26 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0E28 59          	add d, a	; end of string
0022++ 0E29 12          	mov a, c
0023++ 0E2A FD 9B       	shr a		; divide by 2
0024++ 0E2C 39          	mov c, a	; C now counts the steps
0025++ 0E2D             _strrev_L0:
0026++ 0E2D 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0E2E F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0E2F 3E          	mov [d], al	; store left char into right side
0029++ 0E30 1B          	mov al, bl
0030++ 0E31 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0E32 7E          	dec c
0032++ 0E33 7F          	dec d
0033++ 0E34 C2 00 00    	cmp c, 0
0034++ 0E37 C7 2D 0E    	jne _strrev_L0
0035++ 0E3A             _strrev_end:
0036++ 0E3A 4C          	popa
0037++ 0E3B 09          	ret
0038++ 0E3C             	
0039++ 0E3C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0E3C             ; _strchr
0041++ 0E3C             ; search string in D for char in AL
0042++ 0E3C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0E3C             _strchr:
0044++ 0E3C             _strchr_L0:
0045++ 0E3C 32          	mov bl, [d]
0046++ 0E3D C1 00       	cmp bl, 0
0047++ 0E3F C6 4A 0E    	je _strchr_end
0048++ 0E42 BA          	cmp al, bl
0049++ 0E43 C6 4A 0E    	je _strchr_end
0050++ 0E46 79          	inc d
0051++ 0E47 0A 3C 0E    	jmp _strchr_L0
0052++ 0E4A             _strchr_end:
0053++ 0E4A 1B          	mov al, bl
0054++ 0E4B 09          	ret
0055++ 0E4C             
0056++ 0E4C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0E4C             ; _strstr
0058++ 0E4C             ; find sub-string
0059++ 0E4C             ; str1 in SI
0060++ 0E4C             ; str2 in DI
0061++ 0E4C             ; SI points to end of source string
0062++ 0E4C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0E4C             _strstr:
0064++ 0E4C DB          	push al
0065++ 0E4D DA          	push d
0066++ 0E4E E3          	push di
0067++ 0E4F             _strstr_loop:
0068++ 0E4F F3          	cmpsb					; compare a byte of the strings
0069++ 0E50 C7 5B 0E    	jne _strstr_ret
0070++ 0E53 FC 00 00    	lea d, [di + 0]
0071++ 0E56 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0E58 C7 4F 0E    	jne _strstr_loop				; equal chars but not at end
0073++ 0E5B             _strstr_ret:
0074++ 0E5B F0          	pop di
0075++ 0E5C E7          	pop d
0076++ 0E5D E8          	pop al
0077++ 0E5E 09          	ret
0078++ 0E5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0E5F             ; length of null terminated string
0080++ 0E5F             ; result in C
0081++ 0E5F             ; pointer in D
0082++ 0E5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0E5F             _strlen:
0084++ 0E5F DA          	push d
0085++ 0E60 38 00 00    	mov c, 0
0086++ 0E63             _strlen_L1:
0087++ 0E63 BD 00       	cmp byte [d], 0
0088++ 0E65 C6 6D 0E    	je _strlen_ret
0089++ 0E68 79          	inc d
0090++ 0E69 78          	inc c
0091++ 0E6A 0A 63 0E    	jmp _strlen_L1
0092++ 0E6D             _strlen_ret:
0093++ 0E6D E7          	pop d
0094++ 0E6E 09          	ret
0095++ 0E6F             
0096++ 0E6F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0E6F             ; STRCMP
0098++ 0E6F             ; compare two strings
0099++ 0E6F             ; str1 in SI
0100++ 0E6F             ; str2 in DI
0101++ 0E6F             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0E6F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0E6F             _strcmp:
0104++ 0E6F DB          	push al
0105++ 0E70 DA          	push d
0106++ 0E71 E3          	push di
0107++ 0E72 E2          	push si
0108++ 0E73             _strcmp_loop:
0109++ 0E73 F3          	cmpsb					; compare a byte of the strings
0110++ 0E74 C7 7F 0E    	jne _strcmp_ret
0111++ 0E77 FB FF FF    	lea d, [si +- 1]
0112++ 0E7A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0E7C C7 73 0E    	jne _strcmp_loop				; equal chars but not at end
0114++ 0E7F             _strcmp_ret:
0115++ 0E7F EF          	pop si
0116++ 0E80 F0          	pop di
0117++ 0E81 E7          	pop d
0118++ 0E82 E8          	pop al
0119++ 0E83 09          	ret
0120++ 0E84             
0121++ 0E84             
0122++ 0E84             ; STRCPY
0123++ 0E84             ; copy null terminated string from SI to DI
0124++ 0E84             ; source in SI
0125++ 0E84             ; destination in DI
0126++ 0E84             _strcpy:
0127++ 0E84 E2          	push si
0128++ 0E85 E3          	push di
0129++ 0E86 DB          	push al
0130++ 0E87             _strcpy_L1:
0131++ 0E87 F6          	lodsb
0132++ 0E88 F7          	stosb
0133++ 0E89 B9 00       	cmp al, 0
0134++ 0E8B C7 87 0E    	jne _strcpy_L1
0135++ 0E8E             _strcpy_end:
0136++ 0E8E E8          	pop al
0137++ 0E8F F0          	pop di
0138++ 0E90 EF          	pop si
0139++ 0E91 09          	ret
0140++ 0E92             
0141++ 0E92             ; STRCAT
0142++ 0E92             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0E92             ; source in SI
0144++ 0E92             ; destination in DI
0145++ 0E92             _strcat:
0146++ 0E92 E2          	push si
0147++ 0E93 E3          	push di
0148++ 0E94 D7          	push a
0149++ 0E95 DA          	push d
0150++ 0E96 50          	mov a, di
0151++ 0E97 3C          	mov d, a
0152++ 0E98             _strcat_goto_end_L1:
0153++ 0E98 BD 00       	cmp byte[d], 0
0154++ 0E9A C6 A1 0E    	je _strcat_start
0155++ 0E9D 79          	inc d
0156++ 0E9E 0A 98 0E    	jmp _strcat_goto_end_L1
0157++ 0EA1             _strcat_start:
0158++ 0EA1 FD 50       	mov di, d
0159++ 0EA3             _strcat_L1:
0160++ 0EA3 F6          	lodsb
0161++ 0EA4 F7          	stosb
0162++ 0EA5 B9 00       	cmp al, 0
0163++ 0EA7 C7 A3 0E    	jne _strcat_L1
0164++ 0EAA             _strcat_end:
0165++ 0EAA E7          	pop d
0166++ 0EAB E4          	pop a
0167++ 0EAC F0          	pop di
0168++ 0EAD EF          	pop si
0169++ 0EAE 09          	ret
0170++ 0EAF             
0171++ 0EAF             
0005+  0EAF             
0006+  0EAF             
0007+  0EAF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0EAF             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0EAF             ; ASCII in BL
0010+  0EAF             ; result in AL
0011+  0EAF             ; ascii for F = 0100 0110
0012+  0EAF             ; ascii for 9 = 0011 1001
0013+  0EAF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0EAF             hex_ascii_encode:
0015+  0EAF 1B            mov al, bl
0016+  0EB0 93 40         test al, $40        ; test if letter or number
0017+  0EB2 C7 B8 0E      jnz hex_letter
0018+  0EB5 87 0F         and al, $0F        ; get number
0019+  0EB7 09            ret
0020+  0EB8             hex_letter:
0021+  0EB8 87 0F         and al, $0F        ; get letter
0022+  0EBA 6A 09         add al, 9
0023+  0EBC 09            ret
0024+  0EBD             
0025+  0EBD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0EBD             ; ATOI
0027+  0EBD             ; 2 letter hex string in B
0028+  0EBD             ; 8bit integer returned in AL
0029+  0EBD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0EBD             _atoi:
0031+  0EBD D8            push b
0032+  0EBE 07 AF 0E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0EC1 30            mov bl, bh
0034+  0EC2 DB            push al          ; save a
0035+  0EC3 07 AF 0E      call hex_ascii_encode
0036+  0EC6 EA            pop bl  
0037+  0EC7 FD 9E 04      shl al, 4
0038+  0ECA 8C            or al, bl
0039+  0ECB E5            pop b
0040+  0ECC 09            ret  
0041+  0ECD             
0042+  0ECD             
0043+  0ECD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0ECD             ; scanf
0045+  0ECD             ; no need for explanations!
0046+  0ECD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0ECD             scanf:
0048+  0ECD 09            ret
0049+  0ECE             
0050+  0ECE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0ECE             ; ITOA
0052+  0ECE             ; 8bit value in BL
0053+  0ECE             ; 2 byte ASCII result in A
0054+  0ECE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0ECE             _itoa:
0056+  0ECE DA            push d
0057+  0ECF D8            push b
0058+  0ED0 A7 00         mov bh, 0
0059+  0ED2 FD A4 04      shr bl, 4  
0060+  0ED5 74            mov d, b
0061+  0ED6 1F 7E 11      mov al, [d + s_hex_digits]
0062+  0ED9 23            mov ah, al
0063+  0EDA               
0064+  0EDA E5            pop b
0065+  0EDB D8            push b
0066+  0EDC A7 00         mov bh, 0
0067+  0EDE FD 87 0F      and bl, $0F
0068+  0EE1 74            mov d, b
0069+  0EE2 1F 7E 11      mov al, [d + s_hex_digits]
0070+  0EE5 E5            pop b
0071+  0EE6 E7            pop d
0072+  0EE7 09            ret
0073+  0EE8             
0074+  0EE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0EE8             ; HEX STRING TO BINARY
0076+  0EE8             ; di = destination address
0077+  0EE8             ; si = source
0078+  0EE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0EE8             _hex_to_int:
0080+  0EE8             _hex_to_int_L1:
0081+  0EE8 F6            lodsb          ; load from [SI] to AL
0082+  0EE9 B9 00         cmp al, 0        ; check if ASCII 0
0083+  0EEB C6 F8 0E      jz _hex_to_int_ret
0084+  0EEE 36            mov bh, al
0085+  0EEF F6            lodsb
0086+  0EF0 2F            mov bl, al
0087+  0EF1 07 BD 0E      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0EF4 F7            stosb          ; store AL to [DI]
0089+  0EF5 0A E8 0E      jmp _hex_to_int_L1
0090+  0EF8             _hex_to_int_ret:
0091+  0EF8 09            ret    
0092+  0EF9             
0093+  0EF9             
0094+  0EF9             
0095+  0EF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0EF9             ; GETCHAR
0097+  0EF9             ; char in ah
0098+  0EF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0EF9             getch:
0100+  0EF9 DB            push al
0101+  0EFA             getch_retry:
0102+  0EFA 19 01         mov al, 1
0103+  0EFC 05 03         syscall sys_io      ; receive in AH
0104+  0EFE E8            pop al
0105+  0EFF 09            ret
0106+  0F00             
0107+  0F00             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0F00             ; PUTCHAR
0109+  0F00             ; char in ah
0110+  0F00             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0F00             _putchar:
0112+  0F00 D7            push a
0113+  0F01 19 00         mov al, 0
0114+  0F03 05 03         syscall sys_io      ; char in AH
0115+  0F05 E4            pop a
0116+  0F06 09            ret
0117+  0F07             
0118+  0F07             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0F07             ;; INPUT A STRING
0120+  0F07             ;; terminates with null
0121+  0F07             ;; pointer in D
0122+  0F07             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0F07             _gets:
0124+  0F07 D7            push a
0125+  0F08 DA            push d
0126+  0F09             _gets_loop:
0127+  0F09 19 01         mov al, 1
0128+  0F0B 05 03         syscall sys_io      ; receive in AH
0129+  0F0D B9 00         cmp al, 0        ; check error code (AL)
0130+  0F0F C6 09 0F      je _gets_loop      ; if no char received, retry
0131+  0F12             
0132+  0F12 76 1B         cmp ah, 27
0133+  0F14 C6 35 0F      je _gets_ansi_esc
0134+  0F17 76 0A         cmp ah, $0A        ; LF
0135+  0F19 C6 A0 0F      je _gets_end
0136+  0F1C 76 0D         cmp ah, $0D        ; CR
0137+  0F1E C6 A0 0F      je _gets_end
0138+  0F21 76 5C         cmp ah, $5C        ; '\\'
0139+  0F23 C6 61 0F      je _gets_escape
0140+  0F26               
0141+  0F26 76 08         cmp ah, $08      ; check for backspace
0142+  0F28 C6 31 0F      je _gets_backspace
0143+  0F2B             
0144+  0F2B 1A            mov al, ah
0145+  0F2C 3E            mov [d], al
0146+  0F2D 79            inc d
0147+  0F2E 0A 09 0F      jmp _gets_loop
0148+  0F31             _gets_backspace:
0149+  0F31 7F            dec d
0150+  0F32 0A 09 0F      jmp _gets_loop
0151+  0F35             _gets_ansi_esc:
0152+  0F35 19 01         mov al, 1
0153+  0F37 05 03         syscall sys_io        ; receive in AH without echo
0154+  0F39 B9 00         cmp al, 0          ; check error code (AL)
0155+  0F3B C6 35 0F      je _gets_ansi_esc    ; if no char received, retry
0156+  0F3E 76 5B         cmp ah, '['
0157+  0F40 C7 09 0F      jne _gets_loop
0158+  0F43             _gets_ansi_esc_2:
0159+  0F43 19 01         mov al, 1
0160+  0F45 05 03         syscall sys_io          ; receive in AH without echo
0161+  0F47 B9 00         cmp al, 0            ; check error code (AL)
0162+  0F49 C6 43 0F      je _gets_ansi_esc_2  ; if no char received, retry
0163+  0F4C 76 44         cmp ah, 'D'
0164+  0F4E C6 59 0F      je _gets_left_arrow
0165+  0F51 76 43         cmp ah, 'C'
0166+  0F53 C6 5D 0F      je _gets_right_arrow
0167+  0F56 0A 09 0F      jmp _gets_loop
0168+  0F59             _gets_left_arrow:
0169+  0F59 7F            dec d
0170+  0F5A 0A 09 0F      jmp _gets_loop
0171+  0F5D             _gets_right_arrow:
0172+  0F5D 79            inc d
0173+  0F5E 0A 09 0F      jmp _gets_loop
0174+  0F61             _gets_escape:
0175+  0F61 19 01         mov al, 1
0176+  0F63 05 03         syscall sys_io      ; receive in AH
0177+  0F65 B9 00         cmp al, 0        ; check error code (AL)
0178+  0F67 C6 61 0F      je _gets_escape      ; if no char received, retry
0179+  0F6A 76 6E         cmp ah, 'n'
0180+  0F6C C6 8B 0F      je _gets_LF
0181+  0F6F 76 72         cmp ah, 'r'
0182+  0F71 C6 92 0F      je _gets_CR
0183+  0F74 76 30         cmp ah, '0'
0184+  0F76 C6 99 0F      je _gets_NULL
0185+  0F79 76 5C         cmp ah, $5C  ; '\'
0186+  0F7B C6 84 0F      je _gets_slash
0187+  0F7E 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  0F7F 3E            mov [d], al
0189+  0F80 79            inc d
0190+  0F81 0A 09 0F      jmp _gets_loop
0191+  0F84             _gets_slash:
0192+  0F84 19 5C         mov al, $5C
0193+  0F86 3E            mov [d], al
0194+  0F87 79            inc d
0195+  0F88 0A 09 0F      jmp _gets_loop
0196+  0F8B             _gets_LF:
0197+  0F8B 19 0A         mov al, $0A
0198+  0F8D 3E            mov [d], al
0199+  0F8E 79            inc d
0200+  0F8F 0A 09 0F      jmp _gets_loop
0201+  0F92             _gets_CR:
0202+  0F92 19 0D         mov al, $0D
0203+  0F94 3E            mov [d], al
0204+  0F95 79            inc d
0205+  0F96 0A 09 0F      jmp _gets_loop
0206+  0F99             _gets_NULL:
0207+  0F99 19 00         mov al, $00
0208+  0F9B 3E            mov [d], al
0209+  0F9C 79            inc d
0210+  0F9D 0A 09 0F      jmp _gets_loop
0211+  0FA0             _gets_end:
0212+  0FA0 19 00         mov al, 0
0213+  0FA2 3E            mov [d], al        ; terminate string
0214+  0FA3 E7            pop d
0215+  0FA4 E4            pop a
0216+  0FA5 09            ret
0217+  0FA6             
0218+  0FA6             
0219+  0FA6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  0FA6             ;; INPUT TEXT
0221+  0FA6             ;; terminated with CTRL+D
0222+  0FA6             ;; pointer in D
0223+  0FA6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  0FA6             _gettxt:
0225+  0FA6 D7            push a
0226+  0FA7 DA            push d
0227+  0FA8             _gettxt_loop:
0228+  0FA8 19 01         mov al, 1
0229+  0FAA 05 03         syscall sys_io      ; receive in AH
0230+  0FAC B9 00         cmp al, 0        ; check error code (AL)
0231+  0FAE C6 A8 0F      je _gettxt_loop    ; if no char received, retry
0232+  0FB1 76 04         cmp ah, 4      ; EOT
0233+  0FB3 C6 F1 0F      je _gettxt_end
0234+  0FB6 76 08         cmp ah, $08      ; check for backspace
0235+  0FB8 C6 ED 0F      je _gettxt_backspace
0236+  0FBB 76 5C         cmp ah, $5C        ; '\'
0237+  0FBD C6 C6 0F      je _gettxt_escape
0238+  0FC0 1A            mov al, ah
0239+  0FC1 3E            mov [d], al
0240+  0FC2 79            inc d
0241+  0FC3 0A A8 0F      jmp _gettxt_loop
0242+  0FC6             _gettxt_escape:
0243+  0FC6 19 01         mov al, 1
0244+  0FC8 05 03         syscall sys_io      ; receive in AH
0245+  0FCA B9 00         cmp al, 0        ; check error code (AL)
0246+  0FCC C6 C6 0F      je _gettxt_escape    ; if no char received, retry
0247+  0FCF 76 6E         cmp ah, 'n'
0248+  0FD1 C6 DF 0F      je _gettxt_LF
0249+  0FD4 76 72         cmp ah, 'r'
0250+  0FD6 C6 E6 0F      je _gettxt_CR
0251+  0FD9 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0FDA 3E            mov [d], al
0253+  0FDB 79            inc d
0254+  0FDC 0A A8 0F      jmp _gettxt_loop
0255+  0FDF             _gettxt_LF:
0256+  0FDF 19 0A         mov al, $0A
0257+  0FE1 3E            mov [d], al
0258+  0FE2 79            inc d
0259+  0FE3 0A A8 0F      jmp _gettxt_loop
0260+  0FE6             _gettxt_CR:
0261+  0FE6 19 0D         mov al, $0D
0262+  0FE8 3E            mov [d], al
0263+  0FE9 79            inc d
0264+  0FEA 0A A8 0F      jmp _gettxt_loop
0265+  0FED             _gettxt_backspace:
0266+  0FED 7F            dec d
0267+  0FEE 0A A8 0F      jmp _gettxt_loop
0268+  0FF1             _gettxt_end:
0269+  0FF1 19 00         mov al, 0
0270+  0FF3 3E            mov [d], al        ; terminate string
0271+  0FF4 E7            pop d
0272+  0FF5 E4            pop a
0273+  0FF6 09            ret
0274+  0FF7             
0275+  0FF7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0FF7             ; PRINT NEW LINE
0277+  0FF7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  0FF7             printnl:
0279+  0FF7 D7            push a
0280+  0FF8 10 00 0A      mov a, $0A00
0281+  0FFB 05 03         syscall sys_io
0282+  0FFD 10 00 0D      mov a, $0D00
0283+  1000 05 03         syscall sys_io
0284+  1002 E4            pop a
0285+  1003 09            ret
0286+  1004             
0287+  1004             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  1004             ; _strtoint
0289+  1004             ; 4 digit hex string number in d
0290+  1004             ; integer returned in A
0291+  1004             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  1004             _strtointx:
0293+  1004 D8            push b
0294+  1005 32            mov bl, [d]
0295+  1006 37            mov bh, bl
0296+  1007 33 01 00      mov bl, [d + 1]
0297+  100A 07 BD 0E      call _atoi        ; convert to int in AL
0298+  100D 23            mov ah, al        ; move to AH
0299+  100E 33 02 00      mov bl, [d + 2]
0300+  1011 37            mov bh, bl
0301+  1012 33 03 00      mov bl, [d + 3]
0302+  1015 07 BD 0E      call _atoi        ; convert to int in AL
0303+  1018 E5            pop b
0304+  1019 09            ret
0305+  101A             
0306+  101A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  101A             ; _strtoint
0308+  101A             ; 5 digit base10 string number in d
0309+  101A             ; integer returned in A
0310+  101A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  101A             _strtoint:
0312+  101A E2            push si
0313+  101B D8            push b
0314+  101C D9            push c
0315+  101D DA            push d
0316+  101E 07 5F 0E      call _strlen      ; get string length in C
0317+  1021 7E            dec c
0318+  1022 FD 4E         mov si, d
0319+  1024 12            mov a, c
0320+  1025 FD 99         shl a
0321+  1027 3B 96 11      mov d, table_power
0322+  102A 59            add d, a
0323+  102B 38 00 00      mov c, 0
0324+  102E             _strtoint_L0:
0325+  102E F6            lodsb      ; load ASCII to al
0326+  102F B9 00         cmp al, 0
0327+  1031 C6 44 10      je _strtoint_end
0328+  1034 6F 30         sub al, $30    ; make into integer
0329+  1036 22 00         mov ah, 0
0330+  1038 2A            mov b, [d]
0331+  1039 AC            mul a, b      ; result in B since it fits in 16bits
0332+  103A 11            mov a, b
0333+  103B 28            mov b, c
0334+  103C 54            add a, b
0335+  103D 39            mov c, a
0336+  103E 63 02 00      sub d, 2
0337+  1041 0A 2E 10      jmp _strtoint_L0
0338+  1044             _strtoint_end:
0339+  1044 12            mov a, c
0340+  1045 E7            pop d
0341+  1046 E6            pop c
0342+  1047 E5            pop b
0343+  1048 EF            pop si
0344+  1049 09            ret
0345+  104A             
0346+  104A             
0347+  104A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  104A             ; PRINT NULL TERMINATED STRING
0349+  104A             ; pointer in D
0350+  104A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  104A             _puts:
0352+  104A D7            push a
0353+  104B DA            push d
0354+  104C             _puts_L1:
0355+  104C 1E            mov al, [d]
0356+  104D B9 00         cmp al, 0
0357+  104F C6 5B 10      jz _puts_END
0358+  1052 23            mov ah, al
0359+  1053 19 00         mov al, 0
0360+  1055 05 03         syscall sys_io
0361+  1057 79            inc d
0362+  1058 0A 4C 10      jmp _puts_L1
0363+  105B             _puts_END:
0364+  105B E7            pop d
0365+  105C E4            pop a
0366+  105D 09            ret
0367+  105E             
0368+  105E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  105E             ; PRINT N SIZE STRING
0370+  105E             ; pointer in D
0371+  105E             ; size in C
0372+  105E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  105E             _putsn:
0374+  105E DB            push al
0375+  105F DA            push d
0376+  1060 D9            push c
0377+  1061             _putsn_L0:
0378+  1061 1E            mov al, [d]
0379+  1062 23            mov ah, al
0380+  1063 19 00         mov al, 0
0381+  1065 05 03         syscall sys_io
0382+  1067 79            inc d
0383+  1068 7E            dec c  
0384+  1069 C2 00 00      cmp c, 0
0385+  106C C7 61 10      jne _putsn_L0
0386+  106F             _putsn_end:
0387+  106F E6            pop c
0388+  1070 E7            pop d
0389+  1071 E8            pop al
0390+  1072 09            ret
0391+  1073             
0392+  1073             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1073             ; print 16bit decimal number
0394+  1073             ; input number in A
0395+  1073             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1073             print_u16d:
0397+  1073 D7            push a
0398+  1074 D8            push b
0399+  1075 26 10 27      mov b, 10000
0400+  1078 AE            div a, b      ; get 10000's coeff.
0401+  1079 07 9B 10      call print_number
0402+  107C 11            mov a, b
0403+  107D 26 E8 03      mov b, 1000
0404+  1080 AE            div a, b      ; get 1000's coeff.
0405+  1081 07 9B 10      call print_number
0406+  1084 11            mov a, b
0407+  1085 26 64 00      mov b, 100
0408+  1088 AE            div a, b
0409+  1089 07 9B 10      call print_number
0410+  108C 11            mov a, b
0411+  108D 26 0A 00      mov b, 10
0412+  1090 AE            div a, b
0413+  1091 07 9B 10      call print_number
0414+  1094 1B            mov al, bl      ; 1's coeff in bl
0415+  1095 07 9B 10      call print_number
0416+  1098 E5            pop b
0417+  1099 E4            pop a
0418+  109A 09            ret
0419+  109B             
0420+  109B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  109B             ; print AL
0422+  109B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  109B             print_number:
0424+  109B 6A 30         add al, $30
0425+  109D 23            mov ah, al
0426+  109E 07 00 0F      call _putchar
0427+  10A1 09            ret
0428+  10A2             
0429+  10A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  10A2             ; PRINT 16BIT HEX INTEGER
0431+  10A2             ; integer value in reg B
0432+  10A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  10A2             print_u16x:
0434+  10A2 D7            push a
0435+  10A3 D8            push b
0436+  10A4 DD            push bl
0437+  10A5 30            mov bl, bh
0438+  10A6 07 CE 0E      call _itoa        ; convert bh to char in A
0439+  10A9 2F            mov bl, al        ; save al
0440+  10AA 19 00         mov al, 0
0441+  10AC 05 03         syscall sys_io        ; display AH
0442+  10AE 24            mov ah, bl        ; retrieve al
0443+  10AF 19 00         mov al, 0
0444+  10B1 05 03         syscall sys_io        ; display AL
0445+  10B3             
0446+  10B3 EA            pop bl
0447+  10B4 07 CE 0E      call _itoa        ; convert bh to char in A
0448+  10B7 2F            mov bl, al        ; save al
0449+  10B8 19 00         mov al, 0
0450+  10BA 05 03         syscall sys_io        ; display AH
0451+  10BC 24            mov ah, bl        ; retrieve al
0452+  10BD 19 00         mov al, 0
0453+  10BF 05 03         syscall sys_io        ; display AL
0454+  10C1             
0455+  10C1 E5            pop b
0456+  10C2 E4            pop a
0457+  10C3 09            ret
0458+  10C4             
0459+  10C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  10C4             ; INPUT 16BIT HEX INTEGER
0461+  10C4             ; read 16bit integer into A
0462+  10C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  10C4             scan_u16x:
0464+  10C4 F8 10 00      enter 16
0465+  10C7 D8            push b
0466+  10C8 DA            push d
0467+  10C9             
0468+  10C9 FA F1 FF      lea d, [bp + -15]
0469+  10CC 07 07 0F      call _gets        ; get number
0470+  10CF             
0471+  10CF 32            mov bl, [d]
0472+  10D0 37            mov bh, bl
0473+  10D1 33 01 00      mov bl, [d + 1]
0474+  10D4 07 BD 0E      call _atoi        ; convert to int in AL
0475+  10D7 23            mov ah, al        ; move to AH
0476+  10D8             
0477+  10D8 33 02 00      mov bl, [d + 2]
0478+  10DB 37            mov bh, bl
0479+  10DC 33 03 00      mov bl, [d + 3]
0480+  10DF 07 BD 0E      call _atoi        ; convert to int in AL
0481+  10E2             
0482+  10E2 E7            pop d
0483+  10E3 E5            pop b
0484+  10E4 F9            leave
0485+  10E5 09            ret
0486+  10E6             
0487+  10E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  10E6             ; PRINT 8bit HEX INTEGER
0489+  10E6             ; integer value in reg bl
0490+  10E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  10E6             print_u8x:
0492+  10E6 D7            push a
0493+  10E7 DD            push bl
0494+  10E8             
0495+  10E8 07 CE 0E      call _itoa        ; convert bl to char in A
0496+  10EB 2F            mov bl, al        ; save al
0497+  10EC 19 00         mov al, 0
0498+  10EE 05 03         syscall sys_io        ; display AH
0499+  10F0 24            mov ah, bl        ; retrieve al
0500+  10F1 19 00         mov al, 0
0501+  10F3 05 03         syscall sys_io        ; display AL
0502+  10F5             
0503+  10F5 EA            pop bl
0504+  10F6 E4            pop a
0505+  10F7 09            ret
0506+  10F8             
0507+  10F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  10F8             ; print 8bit decimal unsigned number
0509+  10F8             ; input number in AL
0510+  10F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  10F8             print_u8d:
0512+  10F8 D7            push a
0513+  10F9 D8            push b
0514+  10FA             
0515+  10FA 22 00         mov ah, 0
0516+  10FC 26 64 00      mov b, 100
0517+  10FF AE            div a, b
0518+  1100 D8            push b      ; save remainder
0519+  1101 B9 00         cmp al, 0
0520+  1103 C6 0D 11      je skip100
0521+  1106 6A 30         add al, $30
0522+  1108 23            mov ah, al
0523+  1109 19 00         mov al, 0
0524+  110B 05 03         syscall sys_io  ; print coeff
0525+  110D             skip100:
0526+  110D E4            pop a
0527+  110E 22 00         mov ah, 0
0528+  1110 26 0A 00      mov b, 10
0529+  1113 AE            div a, b
0530+  1114 D8            push b      ; save remainder
0531+  1115 B9 00         cmp al, 0
0532+  1117 C6 21 11      je skip10
0533+  111A 6A 30         add al, $30
0534+  111C 23            mov ah, al
0535+  111D 19 00         mov al, 0
0536+  111F 05 03         syscall sys_io  ; print coeff
0537+  1121             skip10:
0538+  1121 E4            pop a
0539+  1122 1B            mov al, bl
0540+  1123 6A 30         add al, $30
0541+  1125 23            mov ah, al
0542+  1126 19 00         mov al, 0
0543+  1128 05 03         syscall sys_io  ; print coeff
0544+  112A E5            pop b
0545+  112B E4            pop a
0546+  112C 09            ret
0547+  112D             
0548+  112D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  112D             ; INPUT 8BIT HEX INTEGER
0550+  112D             ; read 8bit integer into AL
0551+  112D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  112D             scan_u8x:
0553+  112D F8 04 00      enter 4
0554+  1130 D8            push b
0555+  1131 DA            push d
0556+  1132             
0557+  1132 FA FD FF      lea d, [bp + -3]
0558+  1135 07 07 0F      call _gets        ; get number
0559+  1138             
0560+  1138 32            mov bl, [d]
0561+  1139 37            mov bh, bl
0562+  113A 33 01 00      mov bl, [d + 1]
0563+  113D 07 BD 0E      call _atoi        ; convert to int in AL
0564+  1140             
0565+  1140 E7            pop d
0566+  1141 E5            pop b
0567+  1142 F9            leave
0568+  1143 09            ret
0569+  1144             
0570+  1144             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  1144             ; input decimal number
0572+  1144             ; result in A
0573+  1144             ; 655'\0'
0574+  1144             ; low--------high
0575+  1144             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  1144             scan_u16d:
0577+  1144 F8 08 00      enter 8
0578+  1147 E2            push si
0579+  1148 D8            push b
0580+  1149 D9            push c
0581+  114A DA            push d
0582+  114B FA F9 FF      lea d, [bp +- 7]
0583+  114E 07 07 0F      call _gets
0584+  1151 07 5F 0E      call _strlen      ; get string length in C
0585+  1154 7E            dec c
0586+  1155 FD 4E         mov si, d
0587+  1157 12            mov a, c
0588+  1158 FD 99         shl a
0589+  115A 3B 96 11      mov d, table_power
0590+  115D 59            add d, a
0591+  115E 38 00 00      mov c, 0
0592+  1161             mul_loop:
0593+  1161 F6            lodsb      ; load ASCII to al
0594+  1162 B9 00         cmp al, 0
0595+  1164 C6 77 11      je mul_exit
0596+  1167 6F 30         sub al, $30    ; make into integer
0597+  1169 22 00         mov ah, 0
0598+  116B 2A            mov b, [d]
0599+  116C AC            mul a, b      ; result in B since it fits in 16bits
0600+  116D 11            mov a, b
0601+  116E 28            mov b, c
0602+  116F 54            add a, b
0603+  1170 39            mov c, a
0604+  1171 63 02 00      sub d, 2
0605+  1174 0A 61 11      jmp mul_loop
0606+  1177             mul_exit:
0607+  1177 12            mov a, c
0608+  1178 E7            pop d
0609+  1179 E6            pop c
0610+  117A E5            pop b
0611+  117B EF            pop si
0612+  117C F9            leave
0613+  117D 09            ret
0614+  117E             
0615+  117E             
0616+  117E 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1182 34 35 36 37 
0616+  1186 38 39 41 42 
0616+  118A 43 44 45 46 
0617+  118E 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1192 1B 5B 48 00 
0618+  1196             
0619+  1196             table_power:
0620+  1196 01 00         .dw 1
0621+  1198 0A 00         .dw 10
0622+  119A 64 00         .dw 100
0623+  119C E8 03         .dw 1000
0624+  119E 10 27         .dw 100001899   11A0             ; --- END INLINE ASM BLOCK
1900   11A0             
1901   11A0 F9            leave
1902   11A1 09            ret
1903   11A2             
1904   11A2             sqrt:
1905   11A2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1906   11A5             ; $x 
1907   11A5             ; $y 
1908   11A5 52 04 00      sub sp, 4
1909   11A8             ;; if (n <= 1) { 
1910   11A8             _if27_cond:
1911   11A8 FA 05 00      lea d, [bp + 5] ; $n
1912   11AB 2A            mov b, [d]
1913   11AC             ; START RELATIONAL
1914   11AC D7            push a
1915   11AD 11            mov a, b
1916   11AE 26 01 00      mov b, $1
1917   11B1 B0            cmp a, b
1918   11B2 FD 74         sle ; <=
1919   11B4 E4            pop a
1920   11B5             ; END RELATIONAL
1921   11B5 C0 00 00      cmp b, 0
1922   11B8 C6 C4 11      je _if27_exit
1923   11BB             _if27_true:
1924   11BB             ;; return n; 
1925   11BB FA 05 00      lea d, [bp + 5] ; $n
1926   11BE 2A            mov b, [d]
1927   11BF F9            leave
1928   11C0 09            ret
1929   11C1 0A C4 11      jmp _if27_exit
1930   11C4             _if27_exit:
1931   11C4             ;; x = n; 
1932   11C4 FA FF FF      lea d, [bp + -1] ; $x
1933   11C7 DA            push d
1934   11C8 FA 05 00      lea d, [bp + 5] ; $n
1935   11CB 2A            mov b, [d]
1936   11CC E7            pop d
1937   11CD FD 43         mov [d], b
1938   11CF             ;; y = (x + n / x) / 2; 
1939   11CF FA FD FF      lea d, [bp + -3] ; $y
1940   11D2 DA            push d
1941   11D3 FA FF FF      lea d, [bp + -1] ; $x
1942   11D6 2A            mov b, [d]
1943   11D7             ; START TERMS
1944   11D7 D7            push a
1945   11D8 11            mov a, b
1946   11D9 FA 05 00      lea d, [bp + 5] ; $n
1947   11DC 2A            mov b, [d]
1948   11DD             ; START FACTORS
1949   11DD D7            push a
1950   11DE 11            mov a, b
1951   11DF FA FF FF      lea d, [bp + -1] ; $x
1952   11E2 2A            mov b, [d]
1953   11E3 AE            div a, b
1954   11E4 27            mov b, a
1955   11E5 E4            pop a
1956   11E6             ; END FACTORS
1957   11E6 54            add a, b
1958   11E7 27            mov b, a
1959   11E8 E4            pop a
1960   11E9             ; END TERMS
1961   11E9             ; START FACTORS
1962   11E9 D7            push a
1963   11EA 11            mov a, b
1964   11EB 26 02 00      mov b, $2
1965   11EE AE            div a, b
1966   11EF 27            mov b, a
1967   11F0 E4            pop a
1968   11F1             ; END FACTORS
1969   11F1 E7            pop d
1970   11F2 FD 43         mov [d], b
1971   11F4             ;; while (y < x) { 
1972   11F4             _while28_cond:
1973   11F4 FA FD FF      lea d, [bp + -3] ; $y
1974   11F7 2A            mov b, [d]
1975   11F8             ; START RELATIONAL
1976   11F8 D7            push a
1977   11F9 11            mov a, b
1978   11FA FA FF FF      lea d, [bp + -1] ; $x
1979   11FD 2A            mov b, [d]
1980   11FE B0            cmp a, b
1981   11FF FD 73         slt ; < 
1982   1201 E4            pop a
1983   1202             ; END RELATIONAL
1984   1202 C0 00 00      cmp b, 0
1985   1205 C6 3B 12      je _while28_exit
1986   1208             _while28_block:
1987   1208             ;; x = y; 
1988   1208 FA FF FF      lea d, [bp + -1] ; $x
1989   120B DA            push d
1990   120C FA FD FF      lea d, [bp + -3] ; $y
1991   120F 2A            mov b, [d]
1992   1210 E7            pop d
1993   1211 FD 43         mov [d], b
1994   1213             ;; y = (x + n / x) / 2; 
1995   1213 FA FD FF      lea d, [bp + -3] ; $y
1996   1216 DA            push d
1997   1217 FA FF FF      lea d, [bp + -1] ; $x
1998   121A 2A            mov b, [d]
1999   121B             ; START TERMS
2000   121B D7            push a
2001   121C 11            mov a, b
2002   121D FA 05 00      lea d, [bp + 5] ; $n
2003   1220 2A            mov b, [d]
2004   1221             ; START FACTORS
2005   1221 D7            push a
2006   1222 11            mov a, b
2007   1223 FA FF FF      lea d, [bp + -1] ; $x
2008   1226 2A            mov b, [d]
2009   1227 AE            div a, b
2010   1228 27            mov b, a
2011   1229 E4            pop a
2012   122A             ; END FACTORS
2013   122A 54            add a, b
2014   122B 27            mov b, a
2015   122C E4            pop a
2016   122D             ; END TERMS
2017   122D             ; START FACTORS
2018   122D D7            push a
2019   122E 11            mov a, b
2020   122F 26 02 00      mov b, $2
2021   1232 AE            div a, b
2022   1233 27            mov b, a
2023   1234 E4            pop a
2024   1235             ; END FACTORS
2025   1235 E7            pop d
2026   1236 FD 43         mov [d], b
2027   1238 0A F4 11      jmp _while28_cond
2028   123B             _while28_exit:
2029   123B             ;; return x; 
2030   123B FA FF FF      lea d, [bp + -1] ; $x
2031   123E 2A            mov b, [d]
2032   123F F9            leave
2033   1240 09            ret
2034   1241             
2035   1241             exp:
2036   1241 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2037   1244             ; $i 
2038   1244             ; $result 
2039   1244 10 01 00      mov a, $1
2040   1247 45 FD FF      mov [bp + -3], a
2041   124A 52 04 00      sub sp, 4
2042   124D             ;; for(i = 0; i < exp; i++){ 
2043   124D             _for29_init:
2044   124D FA FF FF      lea d, [bp + -1] ; $i
2045   1250 DA            push d
2046   1251 26 00 00      mov b, $0
2047   1254 E7            pop d
2048   1255 FD 43         mov [d], b
2049   1257             _for29_cond:
2050   1257 FA FF FF      lea d, [bp + -1] ; $i
2051   125A 2A            mov b, [d]
2052   125B             ; START RELATIONAL
2053   125B D7            push a
2054   125C 11            mov a, b
2055   125D FA 05 00      lea d, [bp + 5] ; $exp
2056   1260 2A            mov b, [d]
2057   1261 B0            cmp a, b
2058   1262 FD 73         slt ; < 
2059   1264 E4            pop a
2060   1265             ; END RELATIONAL
2061   1265 C0 00 00      cmp b, 0
2062   1268 C6 92 12      je _for29_exit
2063   126B             _for29_block:
2064   126B             ;; result = result * base; 
2065   126B FA FD FF      lea d, [bp + -3] ; $result
2066   126E DA            push d
2067   126F FA FD FF      lea d, [bp + -3] ; $result
2068   1272 2A            mov b, [d]
2069   1273             ; START FACTORS
2070   1273 D7            push a
2071   1274 11            mov a, b
2072   1275 FA 07 00      lea d, [bp + 7] ; $base
2073   1278 2A            mov b, [d]
2074   1279 AC            mul a, b ; *
2075   127A 11            mov a, b
2076   127B 27            mov b, a
2077   127C E4            pop a
2078   127D             ; END FACTORS
2079   127D E7            pop d
2080   127E FD 43         mov [d], b
2081   1280             _for29_update:
2082   1280 FA FF FF      lea d, [bp + -1] ; $i
2083   1283 2A            mov b, [d]
2084   1284 FD 79         mov g, b
2085   1286 FD 77         inc b
2086   1288 FA FF FF      lea d, [bp + -1] ; $i
2087   128B FD 43         mov [d], b
2088   128D FD 27         mov b, g
2089   128F 0A 57 12      jmp _for29_cond
2090   1292             _for29_exit:
2091   1292             ;; return result; 
2092   1292 FA FD FF      lea d, [bp + -3] ; $result
2093   1295 2A            mov b, [d]
2094   1296 F9            leave
2095   1297 09            ret
2096   1298             
2097   1298             primes1:
2098   1298 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2099   129B             ; $n 
2100   129B             ; $i 
2101   129B             ; $s 
2102   129B             ; $count 
2103   129B             ; $divides 
2104   129B 52 0A 00      sub sp, 10
2105   129E             ;; n = 2; 
2106   129E FA FF FF      lea d, [bp + -1] ; $n
2107   12A1 DA            push d
2108   12A2 26 02 00      mov b, $2
2109   12A5 E7            pop d
2110   12A6 FD 43         mov [d], b
2111   12A8             ;; while(n < top){ 
2112   12A8             _while30_cond:
2113   12A8 FA FF FF      lea d, [bp + -1] ; $n
2114   12AB 2A            mov b, [d]
2115   12AC             ; START RELATIONAL
2116   12AC D7            push a
2117   12AD 11            mov a, b
2118   12AE 3B 34 14      mov d, _top ; $top
2119   12B1 2A            mov b, [d]
2120   12B2 B0            cmp a, b
2121   12B3 FD 75         slu ; < (unsigned)
2122   12B5 E4            pop a
2123   12B6             ; END RELATIONAL
2124   12B6 C0 00 00      cmp b, 0
2125   12B9 C6 AD 13      je _while30_exit
2126   12BC             _while30_block:
2127   12BC             ;; s = sqrt(n); 
2128   12BC FA FB FF      lea d, [bp + -5] ; $s
2129   12BF DA            push d
2130   12C0 FA FF FF      lea d, [bp + -1] ; $n
2131   12C3 2A            mov b, [d]
2132   12C4 FD AB         swp b
2133   12C6 D8            push b
2134   12C7 07 A2 11      call sqrt
2135   12CA 51 02 00      add sp, 2
2136   12CD E7            pop d
2137   12CE FD 43         mov [d], b
2138   12D0             ;; divides = 0; 
2139   12D0 FA F7 FF      lea d, [bp + -9] ; $divides
2140   12D3 DA            push d
2141   12D4 26 00 00      mov b, $0
2142   12D7 E7            pop d
2143   12D8 FD 43         mov [d], b
2144   12DA             ;; i = 2; 
2145   12DA FA FD FF      lea d, [bp + -3] ; $i
2146   12DD DA            push d
2147   12DE 26 02 00      mov b, $2
2148   12E1 E7            pop d
2149   12E2 FD 43         mov [d], b
2150   12E4             ;; while(i <= s){ 
2151   12E4             _while31_cond:
2152   12E4 FA FD FF      lea d, [bp + -3] ; $i
2153   12E7 2A            mov b, [d]
2154   12E8             ; START RELATIONAL
2155   12E8 D7            push a
2156   12E9 11            mov a, b
2157   12EA FA FB FF      lea d, [bp + -5] ; $s
2158   12ED 2A            mov b, [d]
2159   12EE B0            cmp a, b
2160   12EF FD 74         sle ; <=
2161   12F1 E4            pop a
2162   12F2             ; END RELATIONAL
2163   12F2 C0 00 00      cmp b, 0
2164   12F5 C6 55 13      je _while31_exit
2165   12F8             _while31_block:
2166   12F8             ;; if(n % i == 0){ 
2167   12F8             _if32_cond:
2168   12F8 FA FF FF      lea d, [bp + -1] ; $n
2169   12FB 2A            mov b, [d]
2170   12FC             ; START FACTORS
2171   12FC D7            push a
2172   12FD 11            mov a, b
2173   12FE FA FD FF      lea d, [bp + -3] ; $i
2174   1301 2A            mov b, [d]
2175   1302 AE            div a, b ; 
2176   1303 11            mov a, b
2177   1304 27            mov b, a
2178   1305 E4            pop a
2179   1306             ; END FACTORS
2180   1306             ; START RELATIONAL
2181   1306 D7            push a
2182   1307 11            mov a, b
2183   1308 26 00 00      mov b, $0
2184   130B B0            cmp a, b
2185   130C FD 71         seq ; ==
2186   130E E4            pop a
2187   130F             ; END RELATIONAL
2188   130F C0 00 00      cmp b, 0
2189   1312 C6 25 13      je _if32_exit
2190   1315             _if32_true:
2191   1315             ;; divides = 1; 
2192   1315 FA F7 FF      lea d, [bp + -9] ; $divides
2193   1318 DA            push d
2194   1319 26 01 00      mov b, $1
2195   131C E7            pop d
2196   131D FD 43         mov [d], b
2197   131F             ;; break; 
2198   131F 0A 55 13      jmp _while31_exit ; while break
2199   1322 0A 25 13      jmp _if32_exit
2200   1325             _if32_exit:
2201   1325             ;; i = i + 1; 
2202   1325 FA FD FF      lea d, [bp + -3] ; $i
2203   1328 DA            push d
2204   1329 FA FD FF      lea d, [bp + -3] ; $i
2205   132C 2A            mov b, [d]
2206   132D             ; START TERMS
2207   132D D7            push a
2208   132E 11            mov a, b
2209   132F 26 01 00      mov b, $1
2210   1332 54            add a, b
2211   1333 27            mov b, a
2212   1334 E4            pop a
2213   1335             ; END TERMS
2214   1335 E7            pop d
2215   1336 FD 43         mov [d], b
2216   1338             ;; if(i >= s) break; 
2217   1338             _if33_cond:
2218   1338 FA FD FF      lea d, [bp + -3] ; $i
2219   133B 2A            mov b, [d]
2220   133C             ; START RELATIONAL
2221   133C D7            push a
2222   133D 11            mov a, b
2223   133E FA FB FF      lea d, [bp + -5] ; $s
2224   1341 2A            mov b, [d]
2225   1342 B0            cmp a, b
2226   1343 FD 80         sge ; >=
2227   1345 E4            pop a
2228   1346             ; END RELATIONAL
2229   1346 C0 00 00      cmp b, 0
2230   1349 C6 52 13      je _if33_exit
2231   134C             _if33_true:
2232   134C             ;; break; 
2233   134C 0A 55 13      jmp _while31_exit ; while break
2234   134F 0A 52 13      jmp _if33_exit
2235   1352             _if33_exit:
2236   1352 0A E4 12      jmp _while31_cond
2237   1355             _while31_exit:
2238   1355             ;; if(divides == 0){ 
2239   1355             _if34_cond:
2240   1355 FA F7 FF      lea d, [bp + -9] ; $divides
2241   1358 2A            mov b, [d]
2242   1359             ; START RELATIONAL
2243   1359 D7            push a
2244   135A 11            mov a, b
2245   135B 26 00 00      mov b, $0
2246   135E B0            cmp a, b
2247   135F FD 71         seq ; ==
2248   1361 E4            pop a
2249   1362             ; END RELATIONAL
2250   1362 C0 00 00      cmp b, 0
2251   1365 C6 97 13      je _if34_exit
2252   1368             _if34_true:
2253   1368             ;; count = count + 1;	 
2254   1368 FA F9 FF      lea d, [bp + -7] ; $count
2255   136B DA            push d
2256   136C FA F9 FF      lea d, [bp + -7] ; $count
2257   136F 2A            mov b, [d]
2258   1370             ; START TERMS
2259   1370 D7            push a
2260   1371 11            mov a, b
2261   1372 26 01 00      mov b, $1
2262   1375 54            add a, b
2263   1376 27            mov b, a
2264   1377 E4            pop a
2265   1378             ; END TERMS
2266   1378 E7            pop d
2267   1379 FD 43         mov [d], b
2268   137B             ;; printu(n); 
2269   137B FA FF FF      lea d, [bp + -1] ; $n
2270   137E 2A            mov b, [d]
2271   137F FD AB         swp b
2272   1381 D8            push b
2273   1382 07 ED 0B      call printu
2274   1385 51 02 00      add sp, 2
2275   1388             ;; print("\n"); 
2276   1388 26 7F 14      mov b, __s2 ; "\n"
2277   138B FD AB         swp b
2278   138D D8            push b
2279   138E 07 21 0D      call print
2280   1391 51 02 00      add sp, 2
2281   1394 0A 97 13      jmp _if34_exit
2282   1397             _if34_exit:
2283   1397             ;; n = n + 1; 
2284   1397 FA FF FF      lea d, [bp + -1] ; $n
2285   139A DA            push d
2286   139B FA FF FF      lea d, [bp + -1] ; $n
2287   139E 2A            mov b, [d]
2288   139F             ; START TERMS
2289   139F D7            push a
2290   13A0 11            mov a, b
2291   13A1 26 01 00      mov b, $1
2292   13A4 54            add a, b
2293   13A5 27            mov b, a
2294   13A6 E4            pop a
2295   13A7             ; END TERMS
2296   13A7 E7            pop d
2297   13A8 FD 43         mov [d], b
2298   13AA 0A A8 12      jmp _while30_cond
2299   13AD             _while30_exit:
2300   13AD             ;; return; 
2301   13AD F9            leave
2302   13AE 09            ret
2303   13AF             
2304   13AF             isPrime:
2305   13AF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2306   13B2             ; $i 
2307   13B2 52 02 00      sub sp, 2
2308   13B5             ;; if (num <= 1) return 0; 
2309   13B5             _if35_cond:
2310   13B5 FA 05 00      lea d, [bp + 5] ; $num
2311   13B8 2A            mov b, [d]
2312   13B9             ; START RELATIONAL
2313   13B9 D7            push a
2314   13BA 11            mov a, b
2315   13BB 26 01 00      mov b, $1
2316   13BE B0            cmp a, b
2317   13BF FD 76         sleu ; <= (unsigned)
2318   13C1 E4            pop a
2319   13C2             ; END RELATIONAL
2320   13C2 C0 00 00      cmp b, 0
2321   13C5 C6 D0 13      je _if35_exit
2322   13C8             _if35_true:
2323   13C8             ;; return 0; 
2324   13C8 26 00 00      mov b, $0
2325   13CB F9            leave
2326   13CC 09            ret
2327   13CD 0A D0 13      jmp _if35_exit
2328   13D0             _if35_exit:
2329   13D0             ;; for (i = 2; i * i <= num; i++) { 
2330   13D0             _for36_init:
2331   13D0 FA FF FF      lea d, [bp + -1] ; $i
2332   13D3 DA            push d
2333   13D4 26 02 00      mov b, $2
2334   13D7 E7            pop d
2335   13D8 FD 43         mov [d], b
2336   13DA             _for36_cond:
2337   13DA FA FF FF      lea d, [bp + -1] ; $i
2338   13DD 2A            mov b, [d]
2339   13DE             ; START FACTORS
2340   13DE D7            push a
2341   13DF 11            mov a, b
2342   13E0 FA FF FF      lea d, [bp + -1] ; $i
2343   13E3 2A            mov b, [d]
2344   13E4 AC            mul a, b ; *
2345   13E5 11            mov a, b
2346   13E6 27            mov b, a
2347   13E7 E4            pop a
2348   13E8             ; END FACTORS
2349   13E8             ; START RELATIONAL
2350   13E8 D7            push a
2351   13E9 11            mov a, b
2352   13EA FA 05 00      lea d, [bp + 5] ; $num
2353   13ED 2A            mov b, [d]
2354   13EE B0            cmp a, b
2355   13EF FD 76         sleu ; <= (unsigned)
2356   13F1 E4            pop a
2357   13F2             ; END RELATIONAL
2358   13F2 C0 00 00      cmp b, 0
2359   13F5 C6 2F 14      je _for36_exit
2360   13F8             _for36_block:
2361   13F8             ;; if (num % i == 0) return 0; 
2362   13F8             _if37_cond:
2363   13F8 FA 05 00      lea d, [bp + 5] ; $num
2364   13FB 2A            mov b, [d]
2365   13FC             ; START FACTORS
2366   13FC D7            push a
2367   13FD 11            mov a, b
2368   13FE FA FF FF      lea d, [bp + -1] ; $i
2369   1401 2A            mov b, [d]
2370   1402 AE            div a, b ; 
2371   1403 11            mov a, b
2372   1404 27            mov b, a
2373   1405 E4            pop a
2374   1406             ; END FACTORS
2375   1406             ; START RELATIONAL
2376   1406 D7            push a
2377   1407 11            mov a, b
2378   1408 26 00 00      mov b, $0
2379   140B B0            cmp a, b
2380   140C FD 71         seq ; ==
2381   140E E4            pop a
2382   140F             ; END RELATIONAL
2383   140F C0 00 00      cmp b, 0
2384   1412 C6 1D 14      je _if37_exit
2385   1415             _if37_true:
2386   1415             ;; return 0; 
2387   1415 26 00 00      mov b, $0
2388   1418 F9            leave
2389   1419 09            ret
2390   141A 0A 1D 14      jmp _if37_exit
2391   141D             _if37_exit:
2392   141D             _for36_update:
2393   141D FA FF FF      lea d, [bp + -1] ; $i
2394   1420 2A            mov b, [d]
2395   1421 FD 79         mov g, b
2396   1423 FD 77         inc b
2397   1425 FA FF FF      lea d, [bp + -1] ; $i
2398   1428 FD 43         mov [d], b
2399   142A FD 27         mov b, g
2400   142C 0A DA 13      jmp _for36_cond
2401   142F             _for36_exit:
2402   142F             ;; return 1; 
2403   142F 26 01 00      mov b, $1
2404   1432 F9            leave
2405   1433 09            ret
2406   1434             ; --- END TEXT BLOCK
2407   1434             
2408   1434             ; --- BEGIN DATA BLOCK
2409   1434 00 00       _top: .fill 2, 0
2410   1436 45 6E 74 65 __s0: .db "Enter a number to find all prime numbers up to it: ", 0
2410   143A 72 20 61 20 
2410   143E 6E 75 6D 62 
2410   1442 65 72 20 74 
2410   1446 6F 20 66 69 
2410   144A 6E 64 20 61 
2410   144E 6C 6C 20 70 
2410   1452 72 69 6D 65 
2410   1456 20 6E 75 6D 
2410   145A 62 65 72 73 
2410   145E 20 75 70 20 
2410   1462 74 6F 20 69 
2410   1466 74 3A 20 00 
2411   146A 50 72 69 6D __s1: .db "Prime numbers are: \n", 0
2411   146E 65 20 6E 75 
2411   1472 6D 62 65 72 
2411   1476 73 20 61 72 
2411   147A 65 3A 20 0A 
2411   147E 00 
2412   147F 0A 00       __s2: .db "\n", 0
2413   1481 55 6E 6B 6E __s3: .db "Unknown type size in va_arg() call. Size needs to be either 1 or 2.", 0
2413   1485 6F 77 6E 20 
2413   1489 74 79 70 65 
2413   148D 20 73 69 7A 
2413   1491 65 20 69 6E 
2413   1495 20 76 61 5F 
2413   1499 61 72 67 28 
2413   149D 29 20 63 61 
2413   14A1 6C 6C 2E 20 
2413   14A5 53 69 7A 65 
2413   14A9 20 6E 65 65 
2413   14AD 64 73 20 74 
2413   14B1 6F 20 62 65 
2413   14B5 20 65 69 74 
2413   14B9 68 65 72 20 
2413   14BD 31 20 6F 72 
2413   14C1 20 32 2E 00 
2414   14C5 45 72 72 6F __s4: .db "Error: Unknown argument type.\n", 0
2414   14C9 72 3A 20 55 
2414   14CD 6E 6B 6E 6F 
2414   14D1 77 6E 20 61 
2414   14D5 72 67 75 6D 
2414   14D9 65 6E 74 20 
2414   14DD 74 79 70 65 
2414   14E1 2E 0A 00 
2415   14E4 1B 5B 32 4A __s5: .db "\033[2J\033[H", 0
2415   14E8 1B 5B 48 00 
2416   14EC             
2417   14EC EE 14       _heap_top: .dw _heap
2418   14EE 00          _heap: .db 0
2419   14EF             ; --- END DATA BLOCK
2420   14EF             
2421   14EF             .end
tasm: Number of errors = 0
