0001   0000             ; --- FILENAME: programs/primes
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $N 
0011   0408             ; $i 
0012   0408 52 04 00      sub sp, 4
0013   040B             ;; printf("Enter a number to find all prime numbers up to it: "); 
0014   040B 26 04 14      mov b, __s0 ; "Enter a number to find all prime numbers up to it: "
0015   040E FD AB         swp b
0016   0410 D8            push b
0017   0411 07 57 06      call printf
0018   0414 51 02 00      add sp, 2
0019   0417             ;; N = scann(); 
0020   0417 FA FF FF      lea d, [bp + -1] ; $N
0021   041A DA            push d
0022   041B 07 74 0C      call scann
0023   041E E7            pop d
0024   041F FD 43         mov [d], b
0025   0421             ;; print("Prime numbers are: \n"); 
0026   0421 26 38 14      mov b, __s1 ; "Prime numbers are: \n"
0027   0424 FD AB         swp b
0028   0426 D8            push b
0029   0427 07 99 0C      call print
0030   042A 51 02 00      add sp, 2
0031   042D             ;; for (i = 2; i <= N; i++) { 
0032   042D             _for1_init:
0033   042D FA FD FF      lea d, [bp + -3] ; $i
0034   0430 DA            push d
0035   0431 26 02 00      mov b, $2
0036   0434 E7            pop d
0037   0435 FD 43         mov [d], b
0038   0437             _for1_cond:
0039   0437 FA FD FF      lea d, [bp + -3] ; $i
0040   043A 2A            mov b, [d]
0041   043B             ; START RELATIONAL
0042   043B D7            push a
0043   043C 11            mov a, b
0044   043D FA FF FF      lea d, [bp + -1] ; $N
0045   0440 2A            mov b, [d]
0046   0441 B0            cmp a, b
0047   0442 FD 76         sleu ; <= (unsigned)
0048   0444 E4            pop a
0049   0445             ; END RELATIONAL
0050   0445 C0 00 00      cmp b, 0
0051   0448 C6 8C 04      je _for1_exit
0052   044B             _for1_block:
0053   044B             ;; if (isPrime(i)) { 
0054   044B             _if2_cond:
0055   044B FA FD FF      lea d, [bp + -3] ; $i
0056   044E 2A            mov b, [d]
0057   044F FD AB         swp b
0058   0451 D8            push b
0059   0452 07 7D 13      call isPrime
0060   0455 51 02 00      add sp, 2
0061   0458 C0 00 00      cmp b, 0
0062   045B C6 7A 04      je _if2_exit
0063   045E             _if2_true:
0064   045E             ;; printu(i); 
0065   045E FA FD FF      lea d, [bp + -3] ; $i
0066   0461 2A            mov b, [d]
0067   0462 FD AB         swp b
0068   0464 D8            push b
0069   0465 07 65 0B      call printu
0070   0468 51 02 00      add sp, 2
0071   046B             ;; print("\n"); 
0072   046B 26 4D 14      mov b, __s2 ; "\n"
0073   046E FD AB         swp b
0074   0470 D8            push b
0075   0471 07 99 0C      call print
0076   0474 51 02 00      add sp, 2
0077   0477 0A 7A 04      jmp _if2_exit
0078   047A             _if2_exit:
0079   047A             _for1_update:
0080   047A FA FD FF      lea d, [bp + -3] ; $i
0081   047D 2A            mov b, [d]
0082   047E FD 79         mov g, b
0083   0480 FD 77         inc b
0084   0482 FA FD FF      lea d, [bp + -3] ; $i
0085   0485 FD 43         mov [d], b
0086   0487 FD 27         mov b, g
0087   0489 0A 37 04      jmp _for1_cond
0088   048C             _for1_exit:
0089   048C             ;; return 0; 
0090   048C 26 00 00      mov b, $0
0091   048F F9            leave
0092   0490 05 0B         syscall sys_terminate_proc
0093   0492             
0094   0492             strcpy:
0095   0492 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0096   0495             ; $psrc 
0097   0495             ; $pdest 
0098   0495 52 04 00      sub sp, 4
0099   0498             ;; psrc = src; 
0100   0498 FA FF FF      lea d, [bp + -1] ; $psrc
0101   049B DA            push d
0102   049C FA 05 00      lea d, [bp + 5] ; $src
0103   049F 2A            mov b, [d]
0104   04A0 E7            pop d
0105   04A1 FD 43         mov [d], b
0106   04A3             ;; pdest = dest; 
0107   04A3 FA FD FF      lea d, [bp + -3] ; $pdest
0108   04A6 DA            push d
0109   04A7 FA 07 00      lea d, [bp + 7] ; $dest
0110   04AA 2A            mov b, [d]
0111   04AB E7            pop d
0112   04AC FD 43         mov [d], b
0113   04AE             ;; while(*psrc) *pdest++ = *psrc++; 
0114   04AE             _while3_cond:
0115   04AE FA FF FF      lea d, [bp + -1] ; $psrc
0116   04B1 2A            mov b, [d]
0117   04B2 74            mov d, b
0118   04B3 32            mov bl, [d]
0119   04B4 A7 00         mov bh, 0
0120   04B6 C0 00 00      cmp b, 0
0121   04B9 C6 E5 04      je _while3_exit
0122   04BC             _while3_block:
0123   04BC             ;; *pdest++ = *psrc++; 
0124   04BC FA FD FF      lea d, [bp + -3] ; $pdest
0125   04BF 2A            mov b, [d]
0126   04C0 FD 79         mov g, b
0127   04C2 FD 77         inc b
0128   04C4 FA FD FF      lea d, [bp + -3] ; $pdest
0129   04C7 FD 43         mov [d], b
0130   04C9 FD 27         mov b, g
0131   04CB D8            push b
0132   04CC FA FF FF      lea d, [bp + -1] ; $psrc
0133   04CF 2A            mov b, [d]
0134   04D0 FD 79         mov g, b
0135   04D2 FD 77         inc b
0136   04D4 FA FF FF      lea d, [bp + -1] ; $psrc
0137   04D7 FD 43         mov [d], b
0138   04D9 FD 27         mov b, g
0139   04DB 74            mov d, b
0140   04DC 32            mov bl, [d]
0141   04DD A7 00         mov bh, 0
0142   04DF E7            pop d
0143   04E0 FD 3E         mov [d], bl
0144   04E2 0A AE 04      jmp _while3_cond
0145   04E5             _while3_exit:
0146   04E5             ;; *pdest = '\0'; 
0147   04E5 FA FD FF      lea d, [bp + -3] ; $pdest
0148   04E8 2A            mov b, [d]
0149   04E9 D8            push b
0150   04EA 26 00 00      mov b, $0
0151   04ED E7            pop d
0152   04EE FD 3E         mov [d], bl
0153   04F0 F9            leave
0154   04F1 09            ret
0155   04F2             
0156   04F2             strcmp:
0157   04F2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0158   04F5             ;; while (*s1 && (*s1 == *s2)) { 
0159   04F5             _while4_cond:
0160   04F5 FA 07 00      lea d, [bp + 7] ; $s1
0161   04F8 2A            mov b, [d]
0162   04F9 74            mov d, b
0163   04FA 32            mov bl, [d]
0164   04FB A7 00         mov bh, 0
0165   04FD D7            push a
0166   04FE 11            mov a, b
0167   04FF FA 07 00      lea d, [bp + 7] ; $s1
0168   0502 2A            mov b, [d]
0169   0503 74            mov d, b
0170   0504 32            mov bl, [d]
0171   0505 A7 00         mov bh, 0
0172   0507             ; START RELATIONAL
0173   0507 D7            push a
0174   0508 11            mov a, b
0175   0509 FA 05 00      lea d, [bp + 5] ; $s2
0176   050C 2A            mov b, [d]
0177   050D 74            mov d, b
0178   050E 32            mov bl, [d]
0179   050F A7 00         mov bh, 0
0180   0511 B0            cmp a, b
0181   0512 FD 71         seq ; ==
0182   0514 E4            pop a
0183   0515             ; END RELATIONAL
0184   0515 FD A7         sand a, b ; &&
0185   0517 E4            pop a
0186   0518 C0 00 00      cmp b, 0
0187   051B C6 3F 05      je _while4_exit
0188   051E             _while4_block:
0189   051E             ;; s1++; 
0190   051E FA 07 00      lea d, [bp + 7] ; $s1
0191   0521 2A            mov b, [d]
0192   0522 FD 79         mov g, b
0193   0524 FD 77         inc b
0194   0526 FA 07 00      lea d, [bp + 7] ; $s1
0195   0529 FD 43         mov [d], b
0196   052B FD 27         mov b, g
0197   052D             ;; s2++; 
0198   052D FA 05 00      lea d, [bp + 5] ; $s2
0199   0530 2A            mov b, [d]
0200   0531 FD 79         mov g, b
0201   0533 FD 77         inc b
0202   0535 FA 05 00      lea d, [bp + 5] ; $s2
0203   0538 FD 43         mov [d], b
0204   053A FD 27         mov b, g
0205   053C 0A F5 04      jmp _while4_cond
0206   053F             _while4_exit:
0207   053F             ;; return *s1 - *s2; 
0208   053F FA 07 00      lea d, [bp + 7] ; $s1
0209   0542 2A            mov b, [d]
0210   0543 74            mov d, b
0211   0544 32            mov bl, [d]
0212   0545 A7 00         mov bh, 0
0213   0547             ; START TERMS
0214   0547 D7            push a
0215   0548 11            mov a, b
0216   0549 FA 05 00      lea d, [bp + 5] ; $s2
0217   054C 2A            mov b, [d]
0218   054D 74            mov d, b
0219   054E 32            mov bl, [d]
0220   054F A7 00         mov bh, 0
0221   0551 60            sub a, b
0222   0552 27            mov b, a
0223   0553 E4            pop a
0224   0554             ; END TERMS
0225   0554 F9            leave
0226   0555 09            ret
0227   0556             
0228   0556             strcat:
0229   0556 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0230   0559             ; $dest_len 
0231   0559             ; $i 
0232   0559 52 04 00      sub sp, 4
0233   055C             ;; dest_len = strlen(dest); 
0234   055C FA FF FF      lea d, [bp + -1] ; $dest_len
0235   055F DA            push d
0236   0560 FA 07 00      lea d, [bp + 7] ; $dest
0237   0563 2A            mov b, [d]
0238   0564 FD AB         swp b
0239   0566 D8            push b
0240   0567 07 0C 06      call strlen
0241   056A 51 02 00      add sp, 2
0242   056D E7            pop d
0243   056E FD 43         mov [d], b
0244   0570             ;; for (i = 0; src[i] != 0; i=i+1) { 
0245   0570             _for5_init:
0246   0570 FA FD FF      lea d, [bp + -3] ; $i
0247   0573 DA            push d
0248   0574 26 00 00      mov b, $0
0249   0577 E7            pop d
0250   0578 FD 43         mov [d], b
0251   057A             _for5_cond:
0252   057A FA 05 00      lea d, [bp + 5] ; $src
0253   057D FD 2A         mov d, [d]
0254   057F D7            push a
0255   0580 DA            push d
0256   0581 FA FD FF      lea d, [bp + -3] ; $i
0257   0584 2A            mov b, [d]
0258   0585 E7            pop d
0259   0586 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0260   058A E4            pop a
0261   058B 32            mov bl, [d]
0262   058C A7 00         mov bh, 0
0263   058E             ; START RELATIONAL
0264   058E D7            push a
0265   058F 11            mov a, b
0266   0590 26 00 00      mov b, $0
0267   0593 B0            cmp a, b
0268   0594 FD 72         sneq ; !=
0269   0596 E4            pop a
0270   0597             ; END RELATIONAL
0271   0597 C0 00 00      cmp b, 0
0272   059A C6 E5 05      je _for5_exit
0273   059D             _for5_block:
0274   059D             ;; dest[dest_len + i] = src[i]; 
0275   059D FA 07 00      lea d, [bp + 7] ; $dest
0276   05A0 FD 2A         mov d, [d]
0277   05A2 D7            push a
0278   05A3 DA            push d
0279   05A4 FA FF FF      lea d, [bp + -1] ; $dest_len
0280   05A7 2A            mov b, [d]
0281   05A8             ; START TERMS
0282   05A8 D7            push a
0283   05A9 11            mov a, b
0284   05AA FA FD FF      lea d, [bp + -3] ; $i
0285   05AD 2A            mov b, [d]
0286   05AE 54            add a, b
0287   05AF 27            mov b, a
0288   05B0 E4            pop a
0289   05B1             ; END TERMS
0290   05B1 E7            pop d
0291   05B2 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0292   05B6 E4            pop a
0293   05B7 DA            push d
0294   05B8 FA 05 00      lea d, [bp + 5] ; $src
0295   05BB FD 2A         mov d, [d]
0296   05BD D7            push a
0297   05BE DA            push d
0298   05BF FA FD FF      lea d, [bp + -3] ; $i
0299   05C2 2A            mov b, [d]
0300   05C3 E7            pop d
0301   05C4 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0302   05C8 E4            pop a
0303   05C9 32            mov bl, [d]
0304   05CA A7 00         mov bh, 0
0305   05CC E7            pop d
0306   05CD FD 3E         mov [d], bl
0307   05CF             _for5_update:
0308   05CF FA FD FF      lea d, [bp + -3] ; $i
0309   05D2 DA            push d
0310   05D3 FA FD FF      lea d, [bp + -3] ; $i
0311   05D6 2A            mov b, [d]
0312   05D7             ; START TERMS
0313   05D7 D7            push a
0314   05D8 11            mov a, b
0315   05D9 26 01 00      mov b, $1
0316   05DC 54            add a, b
0317   05DD 27            mov b, a
0318   05DE E4            pop a
0319   05DF             ; END TERMS
0320   05DF E7            pop d
0321   05E0 FD 43         mov [d], b
0322   05E2 0A 7A 05      jmp _for5_cond
0323   05E5             _for5_exit:
0324   05E5             ;; dest[dest_len + i] = 0; 
0325   05E5 FA 07 00      lea d, [bp + 7] ; $dest
0326   05E8 FD 2A         mov d, [d]
0327   05EA D7            push a
0328   05EB DA            push d
0329   05EC FA FF FF      lea d, [bp + -1] ; $dest_len
0330   05EF 2A            mov b, [d]
0331   05F0             ; START TERMS
0332   05F0 D7            push a
0333   05F1 11            mov a, b
0334   05F2 FA FD FF      lea d, [bp + -3] ; $i
0335   05F5 2A            mov b, [d]
0336   05F6 54            add a, b
0337   05F7 27            mov b, a
0338   05F8 E4            pop a
0339   05F9             ; END TERMS
0340   05F9 E7            pop d
0341   05FA FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0342   05FE E4            pop a
0343   05FF DA            push d
0344   0600 26 00 00      mov b, $0
0345   0603 E7            pop d
0346   0604 FD 3E         mov [d], bl
0347   0606             ;; return dest; 
0348   0606 FA 07 00      lea d, [bp + 7] ; $dest
0349   0609 2A            mov b, [d]
0350   060A F9            leave
0351   060B 09            ret
0352   060C             
0353   060C             strlen:
0354   060C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0355   060F             ; $length 
0356   060F 52 02 00      sub sp, 2
0357   0612             ;; length = 0; 
0358   0612 FA FF FF      lea d, [bp + -1] ; $length
0359   0615 DA            push d
0360   0616 26 00 00      mov b, $0
0361   0619 E7            pop d
0362   061A FD 43         mov [d], b
0363   061C             ;; while (str[length] != 0) { 
0364   061C             _while6_cond:
0365   061C FA 05 00      lea d, [bp + 5] ; $str
0366   061F FD 2A         mov d, [d]
0367   0621 D7            push a
0368   0622 DA            push d
0369   0623 FA FF FF      lea d, [bp + -1] ; $length
0370   0626 2A            mov b, [d]
0371   0627 E7            pop d
0372   0628 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0373   062C E4            pop a
0374   062D 32            mov bl, [d]
0375   062E A7 00         mov bh, 0
0376   0630             ; START RELATIONAL
0377   0630 D7            push a
0378   0631 11            mov a, b
0379   0632 26 00 00      mov b, $0
0380   0635 B0            cmp a, b
0381   0636 FD 72         sneq ; !=
0382   0638 E4            pop a
0383   0639             ; END RELATIONAL
0384   0639 C0 00 00      cmp b, 0
0385   063C C6 51 06      je _while6_exit
0386   063F             _while6_block:
0387   063F             ;; length++; 
0388   063F FA FF FF      lea d, [bp + -1] ; $length
0389   0642 2A            mov b, [d]
0390   0643 FD 79         mov g, b
0391   0645 FD 77         inc b
0392   0647 FA FF FF      lea d, [bp + -1] ; $length
0393   064A FD 43         mov [d], b
0394   064C FD 27         mov b, g
0395   064E 0A 1C 06      jmp _while6_cond
0396   0651             _while6_exit:
0397   0651             ;; return length; 
0398   0651 FA FF FF      lea d, [bp + -1] ; $length
0399   0654 2A            mov b, [d]
0400   0655 F9            leave
0401   0656 09            ret
0402   0657             
0403   0657             printf:
0404   0657 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0405   065A             ; $p 
0406   065A             ; $fp 
0407   065A             ; $i 
0408   065A 52 06 00      sub sp, 6
0409   065D             ;; fp = format; 
0410   065D FA FD FF      lea d, [bp + -3] ; $fp
0411   0660 DA            push d
0412   0661 FA 05 00      lea d, [bp + 5] ; $format
0413   0664 2A            mov b, [d]
0414   0665 E7            pop d
0415   0666 FD 43         mov [d], b
0416   0668             ;; p = &format + 2; 
0417   0668 FA FF FF      lea d, [bp + -1] ; $p
0418   066B DA            push d
0419   066C FA 05 00      lea d, [bp + 5] ; $format
0420   066F 2D            mov b, d
0421   0670             ; START TERMS
0422   0670 D7            push a
0423   0671 11            mov a, b
0424   0672 26 02 00      mov b, $2
0425   0675 54            add a, b
0426   0676 27            mov b, a
0427   0677 E4            pop a
0428   0678             ; END TERMS
0429   0678 E7            pop d
0430   0679 FD 43         mov [d], b
0431   067B             ;; for(;;){ 
0432   067B             _for7_init:
0433   067B             _for7_cond:
0434   067B             _for7_block:
0435   067B             ;; if(!*fp) break; 
0436   067B             _if8_cond:
0437   067B FA FD FF      lea d, [bp + -3] ; $fp
0438   067E 2A            mov b, [d]
0439   067F 74            mov d, b
0440   0680 32            mov bl, [d]
0441   0681 A7 00         mov bh, 0
0442   0683 C0 00 00      cmp b, 0
0443   0686 FD 71         seq ; !
0444   0688 C0 00 00      cmp b, 0
0445   068B C6 94 06      je _if8_else
0446   068E             _if8_true:
0447   068E             ;; break; 
0448   068E 0A DE 07      jmp _for7_exit ; for break
0449   0691 0A DB 07      jmp _if8_exit
0450   0694             _if8_else:
0451   0694             ;; if(*fp == '%'){ 
0452   0694             _if9_cond:
0453   0694 FA FD FF      lea d, [bp + -3] ; $fp
0454   0697 2A            mov b, [d]
0455   0698 74            mov d, b
0456   0699 32            mov bl, [d]
0457   069A A7 00         mov bh, 0
0458   069C             ; START RELATIONAL
0459   069C D7            push a
0460   069D 11            mov a, b
0461   069E 26 25 00      mov b, $25
0462   06A1 B0            cmp a, b
0463   06A2 FD 71         seq ; ==
0464   06A4 E4            pop a
0465   06A5             ; END RELATIONAL
0466   06A5 C0 00 00      cmp b, 0
0467   06A8 C6 BD 07      je _if9_else
0468   06AB             _if9_true:
0469   06AB             ;; fp++; 
0470   06AB FA FD FF      lea d, [bp + -3] ; $fp
0471   06AE 2A            mov b, [d]
0472   06AF FD 79         mov g, b
0473   06B1 FD 77         inc b
0474   06B3 FA FD FF      lea d, [bp + -3] ; $fp
0475   06B6 FD 43         mov [d], b
0476   06B8 FD 27         mov b, g
0477   06BA             ;; switch(*fp){ 
0478   06BA             _switch10_expr:
0479   06BA FA FD FF      lea d, [bp + -3] ; $fp
0480   06BD 2A            mov b, [d]
0481   06BE 74            mov d, b
0482   06BF 32            mov bl, [d]
0483   06C0 A7 00         mov bh, 0
0484   06C2             _switch10_comparisons:
0485   06C2 C1 64         cmp bl, $64
0486   06C4 C6 E6 06      je _switch10_case0
0487   06C7 C1 69         cmp bl, $69
0488   06C9 C6 E6 06      je _switch10_case1
0489   06CC C1 75         cmp bl, $75
0490   06CE C6 0B 07      je _switch10_case2
0491   06D1 C1 78         cmp bl, $78
0492   06D3 C6 30 07      je _switch10_case3
0493   06D6 C1 63         cmp bl, $63
0494   06D8 C6 55 07      je _switch10_case4
0495   06DB C1 73         cmp bl, $73
0496   06DD C6 7A 07      je _switch10_case5
0497   06E0 0A 9F 07      jmp _switch10_default
0498   06E3 0A AB 07      jmp _switch10_exit
0499   06E6             _switch10_case0:
0500   06E6             _switch10_case1:
0501   06E6             ;; prints(*(int*)p); 
0502   06E6 FA FF FF      lea d, [bp + -1] ; $p
0503   06E9 2A            mov b, [d]
0504   06EA 74            mov d, b
0505   06EB 2A            mov b, [d]
0506   06EC FD AB         swp b
0507   06EE D8            push b
0508   06EF 07 70 0A      call prints
0509   06F2 51 02 00      add sp, 2
0510   06F5             ;; p = p + 2; 
0511   06F5 FA FF FF      lea d, [bp + -1] ; $p
0512   06F8 DA            push d
0513   06F9 FA FF FF      lea d, [bp + -1] ; $p
0514   06FC 2A            mov b, [d]
0515   06FD             ; START TERMS
0516   06FD D7            push a
0517   06FE 11            mov a, b
0518   06FF 26 02 00      mov b, $2
0519   0702 54            add a, b
0520   0703 27            mov b, a
0521   0704 E4            pop a
0522   0705             ; END TERMS
0523   0705 E7            pop d
0524   0706 FD 43         mov [d], b
0525   0708             ;; break; 
0526   0708 0A AB 07      jmp _switch10_exit ; case break
0527   070B             _switch10_case2:
0528   070B             ;; printu(*(unsigned int*)p); 
0529   070B FA FF FF      lea d, [bp + -1] ; $p
0530   070E 2A            mov b, [d]
0531   070F 74            mov d, b
0532   0710 2A            mov b, [d]
0533   0711 FD AB         swp b
0534   0713 D8            push b
0535   0714 07 65 0B      call printu
0536   0717 51 02 00      add sp, 2
0537   071A             ;; p = p + 2; 
0538   071A FA FF FF      lea d, [bp + -1] ; $p
0539   071D DA            push d
0540   071E FA FF FF      lea d, [bp + -1] ; $p
0541   0721 2A            mov b, [d]
0542   0722             ; START TERMS
0543   0722 D7            push a
0544   0723 11            mov a, b
0545   0724 26 02 00      mov b, $2
0546   0727 54            add a, b
0547   0728 27            mov b, a
0548   0729 E4            pop a
0549   072A             ; END TERMS
0550   072A E7            pop d
0551   072B FD 43         mov [d], b
0552   072D             ;; break; 
0553   072D 0A AB 07      jmp _switch10_exit ; case break
0554   0730             _switch10_case3:
0555   0730             ;; printx16(*(unsigned int*)p); 
0556   0730 FA FF FF      lea d, [bp + -1] ; $p
0557   0733 2A            mov b, [d]
0558   0734 74            mov d, b
0559   0735 2A            mov b, [d]
0560   0736 FD AB         swp b
0561   0738 D8            push b
0562   0739 07 E0 07      call printx16
0563   073C 51 02 00      add sp, 2
0564   073F             ;; p = p + 2; 
0565   073F FA FF FF      lea d, [bp + -1] ; $p
0566   0742 DA            push d
0567   0743 FA FF FF      lea d, [bp + -1] ; $p
0568   0746 2A            mov b, [d]
0569   0747             ; START TERMS
0570   0747 D7            push a
0571   0748 11            mov a, b
0572   0749 26 02 00      mov b, $2
0573   074C 54            add a, b
0574   074D 27            mov b, a
0575   074E E4            pop a
0576   074F             ; END TERMS
0577   074F E7            pop d
0578   0750 FD 43         mov [d], b
0579   0752             ;; break; 
0580   0752 0A AB 07      jmp _switch10_exit ; case break
0581   0755             _switch10_case4:
0582   0755             ;; putchar(*(char*)p); 
0583   0755 FA FF FF      lea d, [bp + -1] ; $p
0584   0758 2A            mov b, [d]
0585   0759 74            mov d, b
0586   075A 32            mov bl, [d]
0587   075B A7 00         mov bh, 0
0588   075D DD            push bl
0589   075E 07 51 0C      call putchar
0590   0761 51 01 00      add sp, 1
0591   0764             ;; p = p + 2; 
0592   0764 FA FF FF      lea d, [bp + -1] ; $p
0593   0767 DA            push d
0594   0768 FA FF FF      lea d, [bp + -1] ; $p
0595   076B 2A            mov b, [d]
0596   076C             ; START TERMS
0597   076C D7            push a
0598   076D 11            mov a, b
0599   076E 26 02 00      mov b, $2
0600   0771 54            add a, b
0601   0772 27            mov b, a
0602   0773 E4            pop a
0603   0774             ; END TERMS
0604   0774 E7            pop d
0605   0775 FD 43         mov [d], b
0606   0777             ;; break; 
0607   0777 0A AB 07      jmp _switch10_exit ; case break
0608   077A             _switch10_case5:
0609   077A             ;; print(*(char**)p); 
0610   077A FA FF FF      lea d, [bp + -1] ; $p
0611   077D 2A            mov b, [d]
0612   077E 74            mov d, b
0613   077F 2A            mov b, [d]
0614   0780 FD AB         swp b
0615   0782 D8            push b
0616   0783 07 99 0C      call print
0617   0786 51 02 00      add sp, 2
0618   0789             ;; p = p + 2; 
0619   0789 FA FF FF      lea d, [bp + -1] ; $p
0620   078C DA            push d
0621   078D FA FF FF      lea d, [bp + -1] ; $p
0622   0790 2A            mov b, [d]
0623   0791             ; START TERMS
0624   0791 D7            push a
0625   0792 11            mov a, b
0626   0793 26 02 00      mov b, $2
0627   0796 54            add a, b
0628   0797 27            mov b, a
0629   0798 E4            pop a
0630   0799             ; END TERMS
0631   0799 E7            pop d
0632   079A FD 43         mov [d], b
0633   079C             ;; break; 
0634   079C 0A AB 07      jmp _switch10_exit ; case break
0635   079F             _switch10_default:
0636   079F             ;; print("Error: Unknown argument type.\n"); 
0637   079F 26 4F 14      mov b, __s3 ; "Error: Unknown argument type.\n"
0638   07A2 FD AB         swp b
0639   07A4 D8            push b
0640   07A5 07 99 0C      call print
0641   07A8 51 02 00      add sp, 2
0642   07AB             _switch10_exit:
0643   07AB             ;; fp++; 
0644   07AB FA FD FF      lea d, [bp + -3] ; $fp
0645   07AE 2A            mov b, [d]
0646   07AF FD 79         mov g, b
0647   07B1 FD 77         inc b
0648   07B3 FA FD FF      lea d, [bp + -3] ; $fp
0649   07B6 FD 43         mov [d], b
0650   07B8 FD 27         mov b, g
0651   07BA 0A DB 07      jmp _if9_exit
0652   07BD             _if9_else:
0653   07BD             ;; putchar(*fp); 
0654   07BD FA FD FF      lea d, [bp + -3] ; $fp
0655   07C0 2A            mov b, [d]
0656   07C1 74            mov d, b
0657   07C2 32            mov bl, [d]
0658   07C3 A7 00         mov bh, 0
0659   07C5 DD            push bl
0660   07C6 07 51 0C      call putchar
0661   07C9 51 01 00      add sp, 1
0662   07CC             ;; fp++; 
0663   07CC FA FD FF      lea d, [bp + -3] ; $fp
0664   07CF 2A            mov b, [d]
0665   07D0 FD 79         mov g, b
0666   07D2 FD 77         inc b
0667   07D4 FA FD FF      lea d, [bp + -3] ; $fp
0668   07D7 FD 43         mov [d], b
0669   07D9 FD 27         mov b, g
0670   07DB             _if9_exit:
0671   07DB             _if8_exit:
0672   07DB             _for7_update:
0673   07DB 0A 7B 06      jmp _for7_cond
0674   07DE             _for7_exit:
0675   07DE F9            leave
0676   07DF 09            ret
0677   07E0             
0678   07E0             printx16:
0679   07E0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0680   07E3             
0681   07E3             ; --- BEGIN INLINE ASM BLOCK
0682   07E3 FA 05 00      lea d, [bp + 5] ; $hex
0683   07E6 2A            mov b, [d]
0684   07E7 07 70 10      call print_u16x
0685   07EA             ; --- END INLINE ASM BLOCK
0686   07EA             
0687   07EA F9            leave
0688   07EB 09            ret
0689   07EC             
0690   07EC             printx8:
0691   07EC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0692   07EF             
0693   07EF             ; --- BEGIN INLINE ASM BLOCK
0694   07EF FA 05 00      lea d, [bp + 5] ; $hex
0695   07F2 32            mov bl, [d]
0696   07F3 07 B4 10      call print_u8x
0697   07F6             ; --- END INLINE ASM BLOCK
0698   07F6             
0699   07F6 F9            leave
0700   07F7 09            ret
0701   07F8             
0702   07F8             hex_to_int:
0703   07F8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0704   07FB             ; $value 
0705   07FB 10 00 00      mov a, $0
0706   07FE 45 FF FF      mov [bp + -1], a
0707   0801             ; $i 
0708   0801             ; $hex_char 
0709   0801             ; $len 
0710   0801 52 07 00      sub sp, 7
0711   0804             ;; len = strlen(hex_string); 
0712   0804 FA FA FF      lea d, [bp + -6] ; $len
0713   0807 DA            push d
0714   0808 FA 05 00      lea d, [bp + 5] ; $hex_string
0715   080B 2A            mov b, [d]
0716   080C FD AB         swp b
0717   080E D8            push b
0718   080F 07 0C 06      call strlen
0719   0812 51 02 00      add sp, 2
0720   0815 E7            pop d
0721   0816 FD 43         mov [d], b
0722   0818             ;; for (i = 0; i < len; i++) { 
0723   0818             _for11_init:
0724   0818 FA FD FF      lea d, [bp + -3] ; $i
0725   081B DA            push d
0726   081C 26 00 00      mov b, $0
0727   081F E7            pop d
0728   0820 FD 43         mov [d], b
0729   0822             _for11_cond:
0730   0822 FA FD FF      lea d, [bp + -3] ; $i
0731   0825 2A            mov b, [d]
0732   0826             ; START RELATIONAL
0733   0826 D7            push a
0734   0827 11            mov a, b
0735   0828 FA FA FF      lea d, [bp + -6] ; $len
0736   082B 2A            mov b, [d]
0737   082C B0            cmp a, b
0738   082D FD 73         slt ; < 
0739   082F E4            pop a
0740   0830             ; END RELATIONAL
0741   0830 C0 00 00      cmp b, 0
0742   0833 C6 38 09      je _for11_exit
0743   0836             _for11_block:
0744   0836             ;; hex_char = hex_string[i]; 
0745   0836 FA FC FF      lea d, [bp + -4] ; $hex_char
0746   0839 DA            push d
0747   083A FA 05 00      lea d, [bp + 5] ; $hex_string
0748   083D FD 2A         mov d, [d]
0749   083F D7            push a
0750   0840 DA            push d
0751   0841 FA FD FF      lea d, [bp + -3] ; $i
0752   0844 2A            mov b, [d]
0753   0845 E7            pop d
0754   0846 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0755   084A E4            pop a
0756   084B 32            mov bl, [d]
0757   084C A7 00         mov bh, 0
0758   084E E7            pop d
0759   084F FD 3E         mov [d], bl
0760   0851             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0761   0851             _if12_cond:
0762   0851 FA FC FF      lea d, [bp + -4] ; $hex_char
0763   0854 32            mov bl, [d]
0764   0855 A7 00         mov bh, 0
0765   0857             ; START RELATIONAL
0766   0857 D7            push a
0767   0858 11            mov a, b
0768   0859 26 61 00      mov b, $61
0769   085C B0            cmp a, b
0770   085D FD 80         sge ; >=
0771   085F E4            pop a
0772   0860             ; END RELATIONAL
0773   0860 D7            push a
0774   0861 11            mov a, b
0775   0862 FA FC FF      lea d, [bp + -4] ; $hex_char
0776   0865 32            mov bl, [d]
0777   0866 A7 00         mov bh, 0
0778   0868             ; START RELATIONAL
0779   0868 D7            push a
0780   0869 11            mov a, b
0781   086A 26 66 00      mov b, $66
0782   086D B0            cmp a, b
0783   086E FD 74         sle ; <=
0784   0870 E4            pop a
0785   0871             ; END RELATIONAL
0786   0871 FD A7         sand a, b ; &&
0787   0873 E4            pop a
0788   0874 C0 00 00      cmp b, 0
0789   0877 C6 A8 08      je _if12_else
0790   087A             _if12_true:
0791   087A             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0792   087A FA FF FF      lea d, [bp + -1] ; $value
0793   087D DA            push d
0794   087E FA FF FF      lea d, [bp + -1] ; $value
0795   0881 2A            mov b, [d]
0796   0882             ; START FACTORS
0797   0882 D7            push a
0798   0883 11            mov a, b
0799   0884 26 10 00      mov b, $10
0800   0887 AC            mul a, b ; *
0801   0888 11            mov a, b
0802   0889 27            mov b, a
0803   088A E4            pop a
0804   088B             ; END FACTORS
0805   088B             ; START TERMS
0806   088B D7            push a
0807   088C 11            mov a, b
0808   088D FA FC FF      lea d, [bp + -4] ; $hex_char
0809   0890 32            mov bl, [d]
0810   0891 A7 00         mov bh, 0
0811   0893             ; START TERMS
0812   0893 D7            push a
0813   0894 11            mov a, b
0814   0895 26 61 00      mov b, $61
0815   0898 60            sub a, b
0816   0899 26 0A 00      mov b, $a
0817   089C 54            add a, b
0818   089D 27            mov b, a
0819   089E E4            pop a
0820   089F             ; END TERMS
0821   089F 54            add a, b
0822   08A0 27            mov b, a
0823   08A1 E4            pop a
0824   08A2             ; END TERMS
0825   08A2 E7            pop d
0826   08A3 FD 43         mov [d], b
0827   08A5 0A 26 09      jmp _if12_exit
0828   08A8             _if12_else:
0829   08A8             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0830   08A8             _if13_cond:
0831   08A8 FA FC FF      lea d, [bp + -4] ; $hex_char
0832   08AB 32            mov bl, [d]
0833   08AC A7 00         mov bh, 0
0834   08AE             ; START RELATIONAL
0835   08AE D7            push a
0836   08AF 11            mov a, b
0837   08B0 26 41 00      mov b, $41
0838   08B3 B0            cmp a, b
0839   08B4 FD 80         sge ; >=
0840   08B6 E4            pop a
0841   08B7             ; END RELATIONAL
0842   08B7 D7            push a
0843   08B8 11            mov a, b
0844   08B9 FA FC FF      lea d, [bp + -4] ; $hex_char
0845   08BC 32            mov bl, [d]
0846   08BD A7 00         mov bh, 0
0847   08BF             ; START RELATIONAL
0848   08BF D7            push a
0849   08C0 11            mov a, b
0850   08C1 26 46 00      mov b, $46
0851   08C4 B0            cmp a, b
0852   08C5 FD 74         sle ; <=
0853   08C7 E4            pop a
0854   08C8             ; END RELATIONAL
0855   08C8 FD A7         sand a, b ; &&
0856   08CA E4            pop a
0857   08CB C0 00 00      cmp b, 0
0858   08CE C6 FF 08      je _if13_else
0859   08D1             _if13_true:
0860   08D1             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0861   08D1 FA FF FF      lea d, [bp + -1] ; $value
0862   08D4 DA            push d
0863   08D5 FA FF FF      lea d, [bp + -1] ; $value
0864   08D8 2A            mov b, [d]
0865   08D9             ; START FACTORS
0866   08D9 D7            push a
0867   08DA 11            mov a, b
0868   08DB 26 10 00      mov b, $10
0869   08DE AC            mul a, b ; *
0870   08DF 11            mov a, b
0871   08E0 27            mov b, a
0872   08E1 E4            pop a
0873   08E2             ; END FACTORS
0874   08E2             ; START TERMS
0875   08E2 D7            push a
0876   08E3 11            mov a, b
0877   08E4 FA FC FF      lea d, [bp + -4] ; $hex_char
0878   08E7 32            mov bl, [d]
0879   08E8 A7 00         mov bh, 0
0880   08EA             ; START TERMS
0881   08EA D7            push a
0882   08EB 11            mov a, b
0883   08EC 26 41 00      mov b, $41
0884   08EF 60            sub a, b
0885   08F0 26 0A 00      mov b, $a
0886   08F3 54            add a, b
0887   08F4 27            mov b, a
0888   08F5 E4            pop a
0889   08F6             ; END TERMS
0890   08F6 54            add a, b
0891   08F7 27            mov b, a
0892   08F8 E4            pop a
0893   08F9             ; END TERMS
0894   08F9 E7            pop d
0895   08FA FD 43         mov [d], b
0896   08FC 0A 26 09      jmp _if13_exit
0897   08FF             _if13_else:
0898   08FF             ;; value = (value * 16) + (hex_char - '0'); 
0899   08FF FA FF FF      lea d, [bp + -1] ; $value
0900   0902 DA            push d
0901   0903 FA FF FF      lea d, [bp + -1] ; $value
0902   0906 2A            mov b, [d]
0903   0907             ; START FACTORS
0904   0907 D7            push a
0905   0908 11            mov a, b
0906   0909 26 10 00      mov b, $10
0907   090C AC            mul a, b ; *
0908   090D 11            mov a, b
0909   090E 27            mov b, a
0910   090F E4            pop a
0911   0910             ; END FACTORS
0912   0910             ; START TERMS
0913   0910 D7            push a
0914   0911 11            mov a, b
0915   0912 FA FC FF      lea d, [bp + -4] ; $hex_char
0916   0915 32            mov bl, [d]
0917   0916 A7 00         mov bh, 0
0918   0918             ; START TERMS
0919   0918 D7            push a
0920   0919 11            mov a, b
0921   091A 26 30 00      mov b, $30
0922   091D 60            sub a, b
0923   091E 27            mov b, a
0924   091F E4            pop a
0925   0920             ; END TERMS
0926   0920 54            add a, b
0927   0921 27            mov b, a
0928   0922 E4            pop a
0929   0923             ; END TERMS
0930   0923 E7            pop d
0931   0924 FD 43         mov [d], b
0932   0926             _if13_exit:
0933   0926             _if12_exit:
0934   0926             _for11_update:
0935   0926 FA FD FF      lea d, [bp + -3] ; $i
0936   0929 2A            mov b, [d]
0937   092A FD 79         mov g, b
0938   092C FD 77         inc b
0939   092E FA FD FF      lea d, [bp + -3] ; $i
0940   0931 FD 43         mov [d], b
0941   0933 FD 27         mov b, g
0942   0935 0A 22 08      jmp _for11_cond
0943   0938             _for11_exit:
0944   0938             ;; return value; 
0945   0938 FA FF FF      lea d, [bp + -1] ; $value
0946   093B 2A            mov b, [d]
0947   093C F9            leave
0948   093D 09            ret
0949   093E             
0950   093E             atoi:
0951   093E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0952   0941             ; $result 
0953   0941 10 00 00      mov a, $0
0954   0944 45 FF FF      mov [bp + -1], a
0955   0947             ; $sign 
0956   0947 10 01 00      mov a, $1
0957   094A 45 FD FF      mov [bp + -3], a
0958   094D 52 04 00      sub sp, 4
0959   0950             ;; while (*str == ' ') str++; 
0960   0950             _while14_cond:
0961   0950 FA 05 00      lea d, [bp + 5] ; $str
0962   0953 2A            mov b, [d]
0963   0954 74            mov d, b
0964   0955 32            mov bl, [d]
0965   0956 A7 00         mov bh, 0
0966   0958             ; START RELATIONAL
0967   0958 D7            push a
0968   0959 11            mov a, b
0969   095A 26 20 00      mov b, $20
0970   095D B0            cmp a, b
0971   095E FD 71         seq ; ==
0972   0960 E4            pop a
0973   0961             ; END RELATIONAL
0974   0961 C0 00 00      cmp b, 0
0975   0964 C6 79 09      je _while14_exit
0976   0967             _while14_block:
0977   0967             ;; str++; 
0978   0967 FA 05 00      lea d, [bp + 5] ; $str
0979   096A 2A            mov b, [d]
0980   096B FD 79         mov g, b
0981   096D FD 77         inc b
0982   096F FA 05 00      lea d, [bp + 5] ; $str
0983   0972 FD 43         mov [d], b
0984   0974 FD 27         mov b, g
0985   0976 0A 50 09      jmp _while14_cond
0986   0979             _while14_exit:
0987   0979             ;; if (*str == '-' || *str == '+') { 
0988   0979             _if15_cond:
0989   0979 FA 05 00      lea d, [bp + 5] ; $str
0990   097C 2A            mov b, [d]
0991   097D 74            mov d, b
0992   097E 32            mov bl, [d]
0993   097F A7 00         mov bh, 0
0994   0981             ; START RELATIONAL
0995   0981 D7            push a
0996   0982 11            mov a, b
0997   0983 26 2D 00      mov b, $2d
0998   0986 B0            cmp a, b
0999   0987 FD 71         seq ; ==
1000   0989 E4            pop a
1001   098A             ; END RELATIONAL
1002   098A D7            push a
1003   098B 11            mov a, b
1004   098C FA 05 00      lea d, [bp + 5] ; $str
1005   098F 2A            mov b, [d]
1006   0990 74            mov d, b
1007   0991 32            mov bl, [d]
1008   0992 A7 00         mov bh, 0
1009   0994             ; START RELATIONAL
1010   0994 D7            push a
1011   0995 11            mov a, b
1012   0996 26 2B 00      mov b, $2b
1013   0999 B0            cmp a, b
1014   099A FD 71         seq ; ==
1015   099C E4            pop a
1016   099D             ; END RELATIONAL
1017   099D FD A8         sor a, b ; ||
1018   099F E4            pop a
1019   09A0 C0 00 00      cmp b, 0
1020   09A3 C6 DE 09      je _if15_exit
1021   09A6             _if15_true:
1022   09A6             ;; if (*str == '-') sign = -1; 
1023   09A6             _if16_cond:
1024   09A6 FA 05 00      lea d, [bp + 5] ; $str
1025   09A9 2A            mov b, [d]
1026   09AA 74            mov d, b
1027   09AB 32            mov bl, [d]
1028   09AC A7 00         mov bh, 0
1029   09AE             ; START RELATIONAL
1030   09AE D7            push a
1031   09AF 11            mov a, b
1032   09B0 26 2D 00      mov b, $2d
1033   09B3 B0            cmp a, b
1034   09B4 FD 71         seq ; ==
1035   09B6 E4            pop a
1036   09B7             ; END RELATIONAL
1037   09B7 C0 00 00      cmp b, 0
1038   09BA C6 CC 09      je _if16_exit
1039   09BD             _if16_true:
1040   09BD             ;; sign = -1; 
1041   09BD FA FD FF      lea d, [bp + -3] ; $sign
1042   09C0 DA            push d
1043   09C1 26 01 00      mov b, $1
1044   09C4 FD 97         neg b
1045   09C6 E7            pop d
1046   09C7 FD 43         mov [d], b
1047   09C9 0A CC 09      jmp _if16_exit
1048   09CC             _if16_exit:
1049   09CC             ;; str++; 
1050   09CC FA 05 00      lea d, [bp + 5] ; $str
1051   09CF 2A            mov b, [d]
1052   09D0 FD 79         mov g, b
1053   09D2 FD 77         inc b
1054   09D4 FA 05 00      lea d, [bp + 5] ; $str
1055   09D7 FD 43         mov [d], b
1056   09D9 FD 27         mov b, g
1057   09DB 0A DE 09      jmp _if15_exit
1058   09DE             _if15_exit:
1059   09DE             ;; while (*str >= '0' && *str <= '9') { 
1060   09DE             _while17_cond:
1061   09DE FA 05 00      lea d, [bp + 5] ; $str
1062   09E1 2A            mov b, [d]
1063   09E2 74            mov d, b
1064   09E3 32            mov bl, [d]
1065   09E4 A7 00         mov bh, 0
1066   09E6             ; START RELATIONAL
1067   09E6 D7            push a
1068   09E7 11            mov a, b
1069   09E8 26 30 00      mov b, $30
1070   09EB B0            cmp a, b
1071   09EC FD 80         sge ; >=
1072   09EE E4            pop a
1073   09EF             ; END RELATIONAL
1074   09EF D7            push a
1075   09F0 11            mov a, b
1076   09F1 FA 05 00      lea d, [bp + 5] ; $str
1077   09F4 2A            mov b, [d]
1078   09F5 74            mov d, b
1079   09F6 32            mov bl, [d]
1080   09F7 A7 00         mov bh, 0
1081   09F9             ; START RELATIONAL
1082   09F9 D7            push a
1083   09FA 11            mov a, b
1084   09FB 26 39 00      mov b, $39
1085   09FE B0            cmp a, b
1086   09FF FD 74         sle ; <=
1087   0A01 E4            pop a
1088   0A02             ; END RELATIONAL
1089   0A02 FD A7         sand a, b ; &&
1090   0A04 E4            pop a
1091   0A05 C0 00 00      cmp b, 0
1092   0A08 C6 46 0A      je _while17_exit
1093   0A0B             _while17_block:
1094   0A0B             ;; result = result * 10 + (*str - '0'); 
1095   0A0B FA FF FF      lea d, [bp + -1] ; $result
1096   0A0E DA            push d
1097   0A0F FA FF FF      lea d, [bp + -1] ; $result
1098   0A12 2A            mov b, [d]
1099   0A13             ; START FACTORS
1100   0A13 D7            push a
1101   0A14 11            mov a, b
1102   0A15 26 0A 00      mov b, $a
1103   0A18 AC            mul a, b ; *
1104   0A19 11            mov a, b
1105   0A1A 27            mov b, a
1106   0A1B E4            pop a
1107   0A1C             ; END FACTORS
1108   0A1C             ; START TERMS
1109   0A1C D7            push a
1110   0A1D 11            mov a, b
1111   0A1E FA 05 00      lea d, [bp + 5] ; $str
1112   0A21 2A            mov b, [d]
1113   0A22 74            mov d, b
1114   0A23 32            mov bl, [d]
1115   0A24 A7 00         mov bh, 0
1116   0A26             ; START TERMS
1117   0A26 D7            push a
1118   0A27 11            mov a, b
1119   0A28 26 30 00      mov b, $30
1120   0A2B 60            sub a, b
1121   0A2C 27            mov b, a
1122   0A2D E4            pop a
1123   0A2E             ; END TERMS
1124   0A2E 54            add a, b
1125   0A2F 27            mov b, a
1126   0A30 E4            pop a
1127   0A31             ; END TERMS
1128   0A31 E7            pop d
1129   0A32 FD 43         mov [d], b
1130   0A34             ;; str++; 
1131   0A34 FA 05 00      lea d, [bp + 5] ; $str
1132   0A37 2A            mov b, [d]
1133   0A38 FD 79         mov g, b
1134   0A3A FD 77         inc b
1135   0A3C FA 05 00      lea d, [bp + 5] ; $str
1136   0A3F FD 43         mov [d], b
1137   0A41 FD 27         mov b, g
1138   0A43 0A DE 09      jmp _while17_cond
1139   0A46             _while17_exit:
1140   0A46             ;; return sign * result; 
1141   0A46 FA FD FF      lea d, [bp + -3] ; $sign
1142   0A49 2A            mov b, [d]
1143   0A4A             ; START FACTORS
1144   0A4A D7            push a
1145   0A4B 11            mov a, b
1146   0A4C FA FF FF      lea d, [bp + -1] ; $result
1147   0A4F 2A            mov b, [d]
1148   0A50 AC            mul a, b ; *
1149   0A51 11            mov a, b
1150   0A52 27            mov b, a
1151   0A53 E4            pop a
1152   0A54             ; END FACTORS
1153   0A54 F9            leave
1154   0A55 09            ret
1155   0A56             
1156   0A56             gets:
1157   0A56 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1158   0A59             
1159   0A59             ; --- BEGIN INLINE ASM BLOCK
1160   0A59 FA 05 00      lea d, [bp + 5] ; $s
1161   0A5C 15            mov a, [d]
1162   0A5D 3C            mov d, a
1163   0A5E 07 D5 0E      call _gets
1164   0A61             ; --- END INLINE ASM BLOCK
1165   0A61             
1166   0A61             ;; return strlen(s); 
1167   0A61 FA 05 00      lea d, [bp + 5] ; $s
1168   0A64 2A            mov b, [d]
1169   0A65 FD AB         swp b
1170   0A67 D8            push b
1171   0A68 07 0C 06      call strlen
1172   0A6B 51 02 00      add sp, 2
1173   0A6E F9            leave
1174   0A6F 09            ret
1175   0A70             
1176   0A70             prints:
1177   0A70 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1178   0A73             ; $digits 
1179   0A73             ; $i 
1180   0A73 10 00 00      mov a, $0
1181   0A76 45 FA FF      mov [bp + -6], a
1182   0A79 52 07 00      sub sp, 7
1183   0A7C             ;; if (num < 0) { 
1184   0A7C             _if18_cond:
1185   0A7C FA 05 00      lea d, [bp + 5] ; $num
1186   0A7F 2A            mov b, [d]
1187   0A80             ; START RELATIONAL
1188   0A80 D7            push a
1189   0A81 11            mov a, b
1190   0A82 26 00 00      mov b, $0
1191   0A85 B0            cmp a, b
1192   0A86 FD 73         slt ; < 
1193   0A88 E4            pop a
1194   0A89             ; END RELATIONAL
1195   0A89 C0 00 00      cmp b, 0
1196   0A8C C6 A9 0A      je _if18_else
1197   0A8F             _if18_true:
1198   0A8F             ;; putchar('-'); 
1199   0A8F 26 2D 00      mov b, $2d
1200   0A92 DD            push bl
1201   0A93 07 51 0C      call putchar
1202   0A96 51 01 00      add sp, 1
1203   0A99             ;; num = -num; 
1204   0A99 FA 05 00      lea d, [bp + 5] ; $num
1205   0A9C DA            push d
1206   0A9D FA 05 00      lea d, [bp + 5] ; $num
1207   0AA0 2A            mov b, [d]
1208   0AA1 FD 97         neg b
1209   0AA3 E7            pop d
1210   0AA4 FD 43         mov [d], b
1211   0AA6 0A CB 0A      jmp _if18_exit
1212   0AA9             _if18_else:
1213   0AA9             ;; if (num == 0) { 
1214   0AA9             _if19_cond:
1215   0AA9 FA 05 00      lea d, [bp + 5] ; $num
1216   0AAC 2A            mov b, [d]
1217   0AAD             ; START RELATIONAL
1218   0AAD D7            push a
1219   0AAE 11            mov a, b
1220   0AAF 26 00 00      mov b, $0
1221   0AB2 B0            cmp a, b
1222   0AB3 FD 71         seq ; ==
1223   0AB5 E4            pop a
1224   0AB6             ; END RELATIONAL
1225   0AB6 C0 00 00      cmp b, 0
1226   0AB9 C6 CB 0A      je _if19_exit
1227   0ABC             _if19_true:
1228   0ABC             ;; putchar('0'); 
1229   0ABC 26 30 00      mov b, $30
1230   0ABF DD            push bl
1231   0AC0 07 51 0C      call putchar
1232   0AC3 51 01 00      add sp, 1
1233   0AC6             ;; return; 
1234   0AC6 F9            leave
1235   0AC7 09            ret
1236   0AC8 0A CB 0A      jmp _if19_exit
1237   0ACB             _if19_exit:
1238   0ACB             _if18_exit:
1239   0ACB             ;; while (num > 0) { 
1240   0ACB             _while20_cond:
1241   0ACB FA 05 00      lea d, [bp + 5] ; $num
1242   0ACE 2A            mov b, [d]
1243   0ACF             ; START RELATIONAL
1244   0ACF D7            push a
1245   0AD0 11            mov a, b
1246   0AD1 26 00 00      mov b, $0
1247   0AD4 B0            cmp a, b
1248   0AD5 FD 7F         sgt ; >
1249   0AD7 E4            pop a
1250   0AD8             ; END RELATIONAL
1251   0AD8 C0 00 00      cmp b, 0
1252   0ADB C6 28 0B      je _while20_exit
1253   0ADE             _while20_block:
1254   0ADE             ;; digits[i] = '0' + (num % 10); 
1255   0ADE FA FC FF      lea d, [bp + -4] ; $digits
1256   0AE1 D7            push a
1257   0AE2 DA            push d
1258   0AE3 FA FA FF      lea d, [bp + -6] ; $i
1259   0AE6 2A            mov b, [d]
1260   0AE7 E7            pop d
1261   0AE8 5A            add d, b
1262   0AE9 E4            pop a
1263   0AEA DA            push d
1264   0AEB 26 30 00      mov b, $30
1265   0AEE             ; START TERMS
1266   0AEE D7            push a
1267   0AEF 11            mov a, b
1268   0AF0 FA 05 00      lea d, [bp + 5] ; $num
1269   0AF3 2A            mov b, [d]
1270   0AF4             ; START FACTORS
1271   0AF4 D7            push a
1272   0AF5 11            mov a, b
1273   0AF6 26 0A 00      mov b, $a
1274   0AF9 AE            div a, b ; 
1275   0AFA 11            mov a, b
1276   0AFB 27            mov b, a
1277   0AFC E4            pop a
1278   0AFD             ; END FACTORS
1279   0AFD 54            add a, b
1280   0AFE 27            mov b, a
1281   0AFF E4            pop a
1282   0B00             ; END TERMS
1283   0B00 E7            pop d
1284   0B01 FD 3E         mov [d], bl
1285   0B03             ;; num = num / 10; 
1286   0B03 FA 05 00      lea d, [bp + 5] ; $num
1287   0B06 DA            push d
1288   0B07 FA 05 00      lea d, [bp + 5] ; $num
1289   0B0A 2A            mov b, [d]
1290   0B0B             ; START FACTORS
1291   0B0B D7            push a
1292   0B0C 11            mov a, b
1293   0B0D 26 0A 00      mov b, $a
1294   0B10 AE            div a, b
1295   0B11 27            mov b, a
1296   0B12 E4            pop a
1297   0B13             ; END FACTORS
1298   0B13 E7            pop d
1299   0B14 FD 43         mov [d], b
1300   0B16             ;; i++; 
1301   0B16 FA FA FF      lea d, [bp + -6] ; $i
1302   0B19 2A            mov b, [d]
1303   0B1A FD 79         mov g, b
1304   0B1C FD 77         inc b
1305   0B1E FA FA FF      lea d, [bp + -6] ; $i
1306   0B21 FD 43         mov [d], b
1307   0B23 FD 27         mov b, g
1308   0B25 0A CB 0A      jmp _while20_cond
1309   0B28             _while20_exit:
1310   0B28             ;; while (i > 0) { 
1311   0B28             _while21_cond:
1312   0B28 FA FA FF      lea d, [bp + -6] ; $i
1313   0B2B 2A            mov b, [d]
1314   0B2C             ; START RELATIONAL
1315   0B2C D7            push a
1316   0B2D 11            mov a, b
1317   0B2E 26 00 00      mov b, $0
1318   0B31 B0            cmp a, b
1319   0B32 FD 7F         sgt ; >
1320   0B34 E4            pop a
1321   0B35             ; END RELATIONAL
1322   0B35 C0 00 00      cmp b, 0
1323   0B38 C6 63 0B      je _while21_exit
1324   0B3B             _while21_block:
1325   0B3B             ;; i--; 
1326   0B3B FA FA FF      lea d, [bp + -6] ; $i
1327   0B3E 2A            mov b, [d]
1328   0B3F FD 79         mov g, b
1329   0B41 FD 7D         dec b
1330   0B43 FA FA FF      lea d, [bp + -6] ; $i
1331   0B46 FD 43         mov [d], b
1332   0B48 FD 27         mov b, g
1333   0B4A             ;; putchar(digits[i]); 
1334   0B4A FA FC FF      lea d, [bp + -4] ; $digits
1335   0B4D D7            push a
1336   0B4E DA            push d
1337   0B4F FA FA FF      lea d, [bp + -6] ; $i
1338   0B52 2A            mov b, [d]
1339   0B53 E7            pop d
1340   0B54 5A            add d, b
1341   0B55 E4            pop a
1342   0B56 32            mov bl, [d]
1343   0B57 A7 00         mov bh, 0
1344   0B59 DD            push bl
1345   0B5A 07 51 0C      call putchar
1346   0B5D 51 01 00      add sp, 1
1347   0B60 0A 28 0B      jmp _while21_cond
1348   0B63             _while21_exit:
1349   0B63 F9            leave
1350   0B64 09            ret
1351   0B65             
1352   0B65             printu:
1353   0B65 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1354   0B68             ; $digits 
1355   0B68             ; $i 
1356   0B68 52 07 00      sub sp, 7
1357   0B6B             ;; i = 0; 
1358   0B6B FA FA FF      lea d, [bp + -6] ; $i
1359   0B6E DA            push d
1360   0B6F 26 00 00      mov b, $0
1361   0B72 E7            pop d
1362   0B73 FD 43         mov [d], b
1363   0B75             ;; if(num == 0){ 
1364   0B75             _if22_cond:
1365   0B75 FA 05 00      lea d, [bp + 5] ; $num
1366   0B78 2A            mov b, [d]
1367   0B79             ; START RELATIONAL
1368   0B79 D7            push a
1369   0B7A 11            mov a, b
1370   0B7B 26 00 00      mov b, $0
1371   0B7E B0            cmp a, b
1372   0B7F FD 71         seq ; ==
1373   0B81 E4            pop a
1374   0B82             ; END RELATIONAL
1375   0B82 C0 00 00      cmp b, 0
1376   0B85 C6 97 0B      je _if22_exit
1377   0B88             _if22_true:
1378   0B88             ;; putchar('0'); 
1379   0B88 26 30 00      mov b, $30
1380   0B8B DD            push bl
1381   0B8C 07 51 0C      call putchar
1382   0B8F 51 01 00      add sp, 1
1383   0B92             ;; return; 
1384   0B92 F9            leave
1385   0B93 09            ret
1386   0B94 0A 97 0B      jmp _if22_exit
1387   0B97             _if22_exit:
1388   0B97             ;; while (num > 0) { 
1389   0B97             _while23_cond:
1390   0B97 FA 05 00      lea d, [bp + 5] ; $num
1391   0B9A 2A            mov b, [d]
1392   0B9B             ; START RELATIONAL
1393   0B9B D7            push a
1394   0B9C 11            mov a, b
1395   0B9D 26 00 00      mov b, $0
1396   0BA0 B0            cmp a, b
1397   0BA1 FD 81         sgu ; > (unsigned)
1398   0BA3 E4            pop a
1399   0BA4             ; END RELATIONAL
1400   0BA4 C0 00 00      cmp b, 0
1401   0BA7 C6 F4 0B      je _while23_exit
1402   0BAA             _while23_block:
1403   0BAA             ;; digits[i] = '0' + (num % 10); 
1404   0BAA FA FC FF      lea d, [bp + -4] ; $digits
1405   0BAD D7            push a
1406   0BAE DA            push d
1407   0BAF FA FA FF      lea d, [bp + -6] ; $i
1408   0BB2 2A            mov b, [d]
1409   0BB3 E7            pop d
1410   0BB4 5A            add d, b
1411   0BB5 E4            pop a
1412   0BB6 DA            push d
1413   0BB7 26 30 00      mov b, $30
1414   0BBA             ; START TERMS
1415   0BBA D7            push a
1416   0BBB 11            mov a, b
1417   0BBC FA 05 00      lea d, [bp + 5] ; $num
1418   0BBF 2A            mov b, [d]
1419   0BC0             ; START FACTORS
1420   0BC0 D7            push a
1421   0BC1 11            mov a, b
1422   0BC2 26 0A 00      mov b, $a
1423   0BC5 AE            div a, b ; 
1424   0BC6 11            mov a, b
1425   0BC7 27            mov b, a
1426   0BC8 E4            pop a
1427   0BC9             ; END FACTORS
1428   0BC9 54            add a, b
1429   0BCA 27            mov b, a
1430   0BCB E4            pop a
1431   0BCC             ; END TERMS
1432   0BCC E7            pop d
1433   0BCD FD 3E         mov [d], bl
1434   0BCF             ;; num = num / 10; 
1435   0BCF FA 05 00      lea d, [bp + 5] ; $num
1436   0BD2 DA            push d
1437   0BD3 FA 05 00      lea d, [bp + 5] ; $num
1438   0BD6 2A            mov b, [d]
1439   0BD7             ; START FACTORS
1440   0BD7 D7            push a
1441   0BD8 11            mov a, b
1442   0BD9 26 0A 00      mov b, $a
1443   0BDC AE            div a, b
1444   0BDD 27            mov b, a
1445   0BDE E4            pop a
1446   0BDF             ; END FACTORS
1447   0BDF E7            pop d
1448   0BE0 FD 43         mov [d], b
1449   0BE2             ;; i++; 
1450   0BE2 FA FA FF      lea d, [bp + -6] ; $i
1451   0BE5 2A            mov b, [d]
1452   0BE6 FD 79         mov g, b
1453   0BE8 FD 77         inc b
1454   0BEA FA FA FF      lea d, [bp + -6] ; $i
1455   0BED FD 43         mov [d], b
1456   0BEF FD 27         mov b, g
1457   0BF1 0A 97 0B      jmp _while23_cond
1458   0BF4             _while23_exit:
1459   0BF4             ;; while (i > 0) { 
1460   0BF4             _while24_cond:
1461   0BF4 FA FA FF      lea d, [bp + -6] ; $i
1462   0BF7 2A            mov b, [d]
1463   0BF8             ; START RELATIONAL
1464   0BF8 D7            push a
1465   0BF9 11            mov a, b
1466   0BFA 26 00 00      mov b, $0
1467   0BFD B0            cmp a, b
1468   0BFE FD 7F         sgt ; >
1469   0C00 E4            pop a
1470   0C01             ; END RELATIONAL
1471   0C01 C0 00 00      cmp b, 0
1472   0C04 C6 2F 0C      je _while24_exit
1473   0C07             _while24_block:
1474   0C07             ;; i--; 
1475   0C07 FA FA FF      lea d, [bp + -6] ; $i
1476   0C0A 2A            mov b, [d]
1477   0C0B FD 79         mov g, b
1478   0C0D FD 7D         dec b
1479   0C0F FA FA FF      lea d, [bp + -6] ; $i
1480   0C12 FD 43         mov [d], b
1481   0C14 FD 27         mov b, g
1482   0C16             ;; putchar(digits[i]); 
1483   0C16 FA FC FF      lea d, [bp + -4] ; $digits
1484   0C19 D7            push a
1485   0C1A DA            push d
1486   0C1B FA FA FF      lea d, [bp + -6] ; $i
1487   0C1E 2A            mov b, [d]
1488   0C1F E7            pop d
1489   0C20 5A            add d, b
1490   0C21 E4            pop a
1491   0C22 32            mov bl, [d]
1492   0C23 A7 00         mov bh, 0
1493   0C25 DD            push bl
1494   0C26 07 51 0C      call putchar
1495   0C29 51 01 00      add sp, 1
1496   0C2C 0A F4 0B      jmp _while24_cond
1497   0C2F             _while24_exit:
1498   0C2F F9            leave
1499   0C30 09            ret
1500   0C31             
1501   0C31             rand:
1502   0C31 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1503   0C34             ; $sec 
1504   0C34 52 01 00      sub sp, 1
1505   0C37             
1506   0C37             ; --- BEGIN INLINE ASM BLOCK
1507   0C37 19 00         mov al, 0
1508   0C39 05 01         syscall sys_rtc					
1509   0C3B 1A            mov al, ah
1510   0C3C FA 00 00      lea d, [bp + 0] ; $sec
1511   0C3F 1E            mov al, [d]
1512   0C40             ; --- END INLINE ASM BLOCK
1513   0C40             
1514   0C40             ;; return sec; 
1515   0C40 FA 00 00      lea d, [bp + 0] ; $sec
1516   0C43 32            mov bl, [d]
1517   0C44 A7 00         mov bh, 0
1518   0C46 F9            leave
1519   0C47 09            ret
1520   0C48             
1521   0C48             date:
1522   0C48 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1523   0C4B             
1524   0C4B             ; --- BEGIN INLINE ASM BLOCK
1525   0C4B 19 00         mov al, 0 
1526   0C4D 05 07         syscall sys_datetime
1527   0C4F             ; --- END INLINE ASM BLOCK
1528   0C4F             
1529   0C4F F9            leave
1530   0C50 09            ret
1531   0C51             
1532   0C51             putchar:
1533   0C51 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1534   0C54             
1535   0C54             ; --- BEGIN INLINE ASM BLOCK
1536   0C54 FA 05 00      lea d, [bp + 5] ; $c
1537   0C57 1E            mov al, [d]
1538   0C58 23            mov ah, al
1539   0C59 07 CE 0E      call _putchar
1540   0C5C             ; --- END INLINE ASM BLOCK
1541   0C5C             
1542   0C5C F9            leave
1543   0C5D 09            ret
1544   0C5E             
1545   0C5E             getchar:
1546   0C5E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1547   0C61             ; $c 
1548   0C61 52 01 00      sub sp, 1
1549   0C64             
1550   0C64             ; --- BEGIN INLINE ASM BLOCK
1551   0C64 07 C7 0E      call getch
1552   0C67 1A            mov al, ah
1553   0C68 FA 00 00      lea d, [bp + 0] ; $c
1554   0C6B 3E            mov [d], al
1555   0C6C             ; --- END INLINE ASM BLOCK
1556   0C6C             
1557   0C6C             ;; return c; 
1558   0C6C FA 00 00      lea d, [bp + 0] ; $c
1559   0C6F 32            mov bl, [d]
1560   0C70 A7 00         mov bh, 0
1561   0C72 F9            leave
1562   0C73 09            ret
1563   0C74             
1564   0C74             scann:
1565   0C74 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1566   0C77             ; $m 
1567   0C77 52 02 00      sub sp, 2
1568   0C7A             
1569   0C7A             ; --- BEGIN INLINE ASM BLOCK
1570   0C7A 07 12 11      call scan_u16d
1571   0C7D FA FF FF      lea d, [bp + -1] ; $m
1572   0C80 43            mov [d], a
1573   0C81             ; --- END INLINE ASM BLOCK
1574   0C81             
1575   0C81             ;; return m; 
1576   0C81 FA FF FF      lea d, [bp + -1] ; $m
1577   0C84 2A            mov b, [d]
1578   0C85 F9            leave
1579   0C86 09            ret
1580   0C87             
1581   0C87             puts:
1582   0C87 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1583   0C8A             
1584   0C8A             ; --- BEGIN INLINE ASM BLOCK
1585   0C8A FA 05 00      lea d, [bp + 5] ; $s
1586   0C8D 15            mov a, [d]
1587   0C8E 3C            mov d, a
1588   0C8F 07 18 10      call _puts
1589   0C92 10 00 0A      mov a, $0A00
1590   0C95 05 03         syscall sys_io
1591   0C97             ; --- END INLINE ASM BLOCK
1592   0C97             
1593   0C97 F9            leave
1594   0C98 09            ret
1595   0C99             
1596   0C99             print:
1597   0C99 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1598   0C9C             
1599   0C9C             ; --- BEGIN INLINE ASM BLOCK
1600   0C9C FA 05 00      lea d, [bp + 5] ; $s
1601   0C9F FD 2A         mov d, [d]
1602   0CA1 07 18 10      call _puts
1603   0CA4             ; --- END INLINE ASM BLOCK
1604   0CA4             
1605   0CA4 F9            leave
1606   0CA5 09            ret
1607   0CA6             
1608   0CA6             loadfile:
1609   0CA6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1610   0CA9             
1611   0CA9             ; --- BEGIN INLINE ASM BLOCK
1612   0CA9 FA 05 00      lea d, [bp + 5] ; $destination
1613   0CAC 15            mov a, [d]
1614   0CAD 4F            mov di, a
1615   0CAE FA 07 00      lea d, [bp + 7] ; $filename
1616   0CB1 FD 2A         mov d, [d]
1617   0CB3 19 14         mov al, 20
1618   0CB5 05 04         syscall sys_filesystem
1619   0CB7             ; --- END INLINE ASM BLOCK
1620   0CB7             
1621   0CB7 F9            leave
1622   0CB8 09            ret
1623   0CB9             
1624   0CB9             create_file:
1625   0CB9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1626   0CBC F9            leave
1627   0CBD 09            ret
1628   0CBE             
1629   0CBE             delete_file:
1630   0CBE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1631   0CC1             
1632   0CC1             ; --- BEGIN INLINE ASM BLOCK
1633   0CC1 FA 05 00      lea d, [bp + 5] ; $filename
1634   0CC4 19 0A         mov al, 10
1635   0CC6 05 04         syscall sys_filesystem
1636   0CC8             ; --- END INLINE ASM BLOCK
1637   0CC8             
1638   0CC8 F9            leave
1639   0CC9 09            ret
1640   0CCA             
1641   0CCA             fopen:
1642   0CCA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1643   0CCD F9            leave
1644   0CCE 09            ret
1645   0CCF             
1646   0CCF             fclose:
1647   0CCF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1648   0CD2 F9            leave
1649   0CD3 09            ret
1650   0CD4             
1651   0CD4             alloc:
1652   0CD4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1653   0CD7             ;; heap_top = heap_top + bytes; 
1654   0CD7 3B 76 14      mov d, _heap_top ; $heap_top
1655   0CDA DA            push d
1656   0CDB 3B 76 14      mov d, _heap_top ; $heap_top
1657   0CDE 2A            mov b, [d]
1658   0CDF             ; START TERMS
1659   0CDF D7            push a
1660   0CE0 11            mov a, b
1661   0CE1 FA 05 00      lea d, [bp + 5] ; $bytes
1662   0CE4 2A            mov b, [d]
1663   0CE5 54            add a, b
1664   0CE6 27            mov b, a
1665   0CE7 E4            pop a
1666   0CE8             ; END TERMS
1667   0CE8 E7            pop d
1668   0CE9 FD 43         mov [d], b
1669   0CEB             ;; return heap_top - bytes; 
1670   0CEB 3B 76 14      mov d, _heap_top ; $heap_top
1671   0CEE 2A            mov b, [d]
1672   0CEF             ; START TERMS
1673   0CEF D7            push a
1674   0CF0 11            mov a, b
1675   0CF1 FA 05 00      lea d, [bp + 5] ; $bytes
1676   0CF4 2A            mov b, [d]
1677   0CF5 60            sub a, b
1678   0CF6 27            mov b, a
1679   0CF7 E4            pop a
1680   0CF8             ; END TERMS
1681   0CF8 F9            leave
1682   0CF9 09            ret
1683   0CFA             
1684   0CFA             free:
1685   0CFA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1686   0CFD             ;; return heap_top = heap_top - bytes; 
1687   0CFD 3B 76 14      mov d, _heap_top ; $heap_top
1688   0D00 DA            push d
1689   0D01 3B 76 14      mov d, _heap_top ; $heap_top
1690   0D04 2A            mov b, [d]
1691   0D05             ; START TERMS
1692   0D05 D7            push a
1693   0D06 11            mov a, b
1694   0D07 FA 05 00      lea d, [bp + 5] ; $bytes
1695   0D0A 2A            mov b, [d]
1696   0D0B 60            sub a, b
1697   0D0C 27            mov b, a
1698   0D0D E4            pop a
1699   0D0E             ; END TERMS
1700   0D0E E7            pop d
1701   0D0F FD 43         mov [d], b
1702   0D11 F9            leave
1703   0D12 09            ret
1704   0D13             
1705   0D13             exit:
1706   0D13 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1707   0D16             
1708   0D16             ; --- BEGIN INLINE ASM BLOCK
1709   0D16 05 0B         syscall sys_terminate_proc
1710   0D18             ; --- END INLINE ASM BLOCK
1711   0D18             
1712   0D18 F9            leave
1713   0D19 09            ret
1714   0D1A             
1715   0D1A             load_hex:
1716   0D1A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1717   0D1D             ; $temp 
1718   0D1D 52 02 00      sub sp, 2
1719   0D20             ;; temp = alloc(32768); 
1720   0D20 FA FF FF      lea d, [bp + -1] ; $temp
1721   0D23 DA            push d
1722   0D24 26 00 80      mov b, $8000
1723   0D27 FD AB         swp b
1724   0D29 D8            push b
1725   0D2A 07 D4 0C      call alloc
1726   0D2D 51 02 00      add sp, 2
1727   0D30 E7            pop d
1728   0D31 FD 43         mov [d], b
1729   0D33             
1730   0D33             ; --- BEGIN INLINE ASM BLOCK
1731   0D33               
1732   0D33               
1733   0D33               
1734   0D33               
1735   0D33               
1736   0D33             _load_hex:
1737   0D33 D7            push a
1738   0D34 D8            push b
1739   0D35 DA            push d
1740   0D36 E2            push si
1741   0D37 E3            push di
1742   0D38 52 00 80      sub sp, $8000      
1743   0D3B 38 00 00      mov c, 0
1744   0D3E 48            mov a, sp
1745   0D3F 77            inc a
1746   0D40 3C            mov d, a          
1747   0D41 07 D5 0E      call _gets        
1748   0D44 4D            mov si, a
1749   0D45             __load_hex_loop:
1750   0D45 F6            lodsb             
1751   0D46 B9 00         cmp al, 0         
1752   0D48 C6 56 0D      jz __load_hex_ret
1753   0D4B 36            mov bh, al
1754   0D4C F6            lodsb
1755   0D4D 2F            mov bl, al
1756   0D4E 07 8B 0E      call _atoi        
1757   0D51 F7            stosb             
1758   0D52 78            inc c
1759   0D53 0A 45 0D      jmp __load_hex_loop
1760   0D56             __load_hex_ret:
1761   0D56 51 00 80      add sp, $8000
1762   0D59 F0            pop di
1763   0D5A EF            pop si
1764   0D5B E7            pop d
1765   0D5C E5            pop b
1766   0D5D E4            pop a
1767   0D5E             ; --- END INLINE ASM BLOCK
1768   0D5E             
1769   0D5E F9            leave
1770   0D5F 09            ret
1771   0D60             
1772   0D60             getparam:
1773   0D60 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1774   0D63             ; $data 
1775   0D63 52 01 00      sub sp, 1
1776   0D66             
1777   0D66             ; --- BEGIN INLINE ASM BLOCK
1778   0D66 19 04         mov al, 4
1779   0D68 FA 05 00      lea d, [bp + 5] ; $address
1780   0D6B FD 2A         mov d, [d]
1781   0D6D 05 0C         syscall sys_system
1782   0D6F FA 00 00      lea d, [bp + 0] ; $data
1783   0D72 FD 3E         mov [d], bl
1784   0D74             ; --- END INLINE ASM BLOCK
1785   0D74             
1786   0D74             ;; return data; 
1787   0D74 FA 00 00      lea d, [bp + 0] ; $data
1788   0D77 32            mov bl, [d]
1789   0D78 A7 00         mov bh, 0
1790   0D7A F9            leave
1791   0D7B 09            ret
1792   0D7C             
1793   0D7C             clear:
1794   0D7C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1795   0D7F             ;; print("\033[2J\033[H"); 
1796   0D7F 26 6E 14      mov b, __s4 ; "\033[2J\033[H"
1797   0D82 FD AB         swp b
1798   0D84 D8            push b
1799   0D85 07 99 0C      call print
1800   0D88 51 02 00      add sp, 2
1801   0D8B F9            leave
1802   0D8C 09            ret
1803   0D8D             
1804   0D8D             printun:
1805   0D8D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1806   0D90             ;; print(prompt); 
1807   0D90 FA 07 00      lea d, [bp + 7] ; $prompt
1808   0D93 2A            mov b, [d]
1809   0D94 FD AB         swp b
1810   0D96 D8            push b
1811   0D97 07 99 0C      call print
1812   0D9A 51 02 00      add sp, 2
1813   0D9D             ;; printu(n); 
1814   0D9D FA 05 00      lea d, [bp + 5] ; $n
1815   0DA0 2A            mov b, [d]
1816   0DA1 FD AB         swp b
1817   0DA3 D8            push b
1818   0DA4 07 65 0B      call printu
1819   0DA7 51 02 00      add sp, 2
1820   0DAA             ;; print("\n"); 
1821   0DAA 26 4D 14      mov b, __s2 ; "\n"
1822   0DAD FD AB         swp b
1823   0DAF D8            push b
1824   0DB0 07 99 0C      call print
1825   0DB3 51 02 00      add sp, 2
1826   0DB6 F9            leave
1827   0DB7 09            ret
1828   0DB8             
1829   0DB8             printsn:
1830   0DB8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1831   0DBB             ;; print(prompt); 
1832   0DBB FA 07 00      lea d, [bp + 7] ; $prompt
1833   0DBE 2A            mov b, [d]
1834   0DBF FD AB         swp b
1835   0DC1 D8            push b
1836   0DC2 07 99 0C      call print
1837   0DC5 51 02 00      add sp, 2
1838   0DC8             ;; prints(n); 
1839   0DC8 FA 05 00      lea d, [bp + 5] ; $n
1840   0DCB 2A            mov b, [d]
1841   0DCC FD AB         swp b
1842   0DCE D8            push b
1843   0DCF 07 70 0A      call prints
1844   0DD2 51 02 00      add sp, 2
1845   0DD5             ;; print("\n"); 
1846   0DD5 26 4D 14      mov b, __s2 ; "\n"
1847   0DD8 FD AB         swp b
1848   0DDA D8            push b
1849   0DDB 07 99 0C      call print
1850   0DDE 51 02 00      add sp, 2
1851   0DE1 F9            leave
1852   0DE2 09            ret
1853   0DE3             
1854   0DE3             include_stdio_asm:
1855   0DE3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1856   0DE6             
1857   0DE6             ; --- BEGIN INLINE ASM BLOCK
1858   0DE6             .include "lib/stdio.asm"
0001+  0DE6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0DE6             ; stdio.s
0003+  0DE6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0DE6             .include "lib/string.asm"
0001++ 0DE6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0DE6             ; string.s
0003++ 0DE6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0DE6             
0005++ 0DE6             
0006++ 0DE6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0DE6             ; _strrev
0008++ 0DE6             ; reverse a string
0009++ 0DE6             ; D = string address
0010++ 0DE6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0DE6             ; 01234
0012++ 0DE6             _strrev:
0013++ 0DE6 4B          	pusha
0014++ 0DE7 07 2D 0E    	call _strlen	; length in C
0015++ 0DEA 12          	mov a, c
0016++ 0DEB AF 01 00    	cmp a, 1
0017++ 0DEE D0 08 0E    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0DF1 7D          	dec a
0019++ 0DF2 FD 4E       	mov si, d	; beginning of string
0020++ 0DF4 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0DF6 59          	add d, a	; end of string
0022++ 0DF7 12          	mov a, c
0023++ 0DF8 FD 9B       	shr a		; divide by 2
0024++ 0DFA 39          	mov c, a	; C now counts the steps
0025++ 0DFB             _strrev_L0:
0026++ 0DFB 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0DFC F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0DFD 3E          	mov [d], al	; store left char into right side
0029++ 0DFE 1B          	mov al, bl
0030++ 0DFF F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0E00 7E          	dec c
0032++ 0E01 7F          	dec d
0033++ 0E02 C2 00 00    	cmp c, 0
0034++ 0E05 C7 FB 0D    	jne _strrev_L0
0035++ 0E08             _strrev_end:
0036++ 0E08 4C          	popa
0037++ 0E09 09          	ret
0038++ 0E0A             	
0039++ 0E0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0E0A             ; _strchr
0041++ 0E0A             ; search string in D for char in AL
0042++ 0E0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0E0A             _strchr:
0044++ 0E0A             _strchr_L0:
0045++ 0E0A 32          	mov bl, [d]
0046++ 0E0B C1 00       	cmp bl, 0
0047++ 0E0D C6 18 0E    	je _strchr_end
0048++ 0E10 BA          	cmp al, bl
0049++ 0E11 C6 18 0E    	je _strchr_end
0050++ 0E14 79          	inc d
0051++ 0E15 0A 0A 0E    	jmp _strchr_L0
0052++ 0E18             _strchr_end:
0053++ 0E18 1B          	mov al, bl
0054++ 0E19 09          	ret
0055++ 0E1A             
0056++ 0E1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0E1A             ; _strstr
0058++ 0E1A             ; find sub-string
0059++ 0E1A             ; str1 in SI
0060++ 0E1A             ; str2 in DI
0061++ 0E1A             ; SI points to end of source string
0062++ 0E1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0E1A             _strstr:
0064++ 0E1A DB          	push al
0065++ 0E1B DA          	push d
0066++ 0E1C E3          	push di
0067++ 0E1D             _strstr_loop:
0068++ 0E1D F3          	cmpsb					; compare a byte of the strings
0069++ 0E1E C7 29 0E    	jne _strstr_ret
0070++ 0E21 FC 00 00    	lea d, [di + 0]
0071++ 0E24 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0E26 C7 1D 0E    	jne _strstr_loop				; equal chars but not at end
0073++ 0E29             _strstr_ret:
0074++ 0E29 F0          	pop di
0075++ 0E2A E7          	pop d
0076++ 0E2B E8          	pop al
0077++ 0E2C 09          	ret
0078++ 0E2D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0E2D             ; length of null terminated string
0080++ 0E2D             ; result in C
0081++ 0E2D             ; pointer in D
0082++ 0E2D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0E2D             _strlen:
0084++ 0E2D DA          	push d
0085++ 0E2E 38 00 00    	mov c, 0
0086++ 0E31             _strlen_L1:
0087++ 0E31 BD 00       	cmp byte [d], 0
0088++ 0E33 C6 3B 0E    	je _strlen_ret
0089++ 0E36 79          	inc d
0090++ 0E37 78          	inc c
0091++ 0E38 0A 31 0E    	jmp _strlen_L1
0092++ 0E3B             _strlen_ret:
0093++ 0E3B E7          	pop d
0094++ 0E3C 09          	ret
0095++ 0E3D             
0096++ 0E3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0E3D             ; STRCMP
0098++ 0E3D             ; compare two strings
0099++ 0E3D             ; str1 in SI
0100++ 0E3D             ; str2 in DI
0101++ 0E3D             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0E3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0E3D             _strcmp:
0104++ 0E3D DB          	push al
0105++ 0E3E DA          	push d
0106++ 0E3F E3          	push di
0107++ 0E40 E2          	push si
0108++ 0E41             _strcmp_loop:
0109++ 0E41 F3          	cmpsb					; compare a byte of the strings
0110++ 0E42 C7 4D 0E    	jne _strcmp_ret
0111++ 0E45 FB FF FF    	lea d, [si +- 1]
0112++ 0E48 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0E4A C7 41 0E    	jne _strcmp_loop				; equal chars but not at end
0114++ 0E4D             _strcmp_ret:
0115++ 0E4D EF          	pop si
0116++ 0E4E F0          	pop di
0117++ 0E4F E7          	pop d
0118++ 0E50 E8          	pop al
0119++ 0E51 09          	ret
0120++ 0E52             
0121++ 0E52             
0122++ 0E52             ; STRCPY
0123++ 0E52             ; copy null terminated string from SI to DI
0124++ 0E52             ; source in SI
0125++ 0E52             ; destination in DI
0126++ 0E52             _strcpy:
0127++ 0E52 E2          	push si
0128++ 0E53 E3          	push di
0129++ 0E54 DB          	push al
0130++ 0E55             _strcpy_L1:
0131++ 0E55 F6          	lodsb
0132++ 0E56 F7          	stosb
0133++ 0E57 B9 00       	cmp al, 0
0134++ 0E59 C7 55 0E    	jne _strcpy_L1
0135++ 0E5C             _strcpy_end:
0136++ 0E5C E8          	pop al
0137++ 0E5D F0          	pop di
0138++ 0E5E EF          	pop si
0139++ 0E5F 09          	ret
0140++ 0E60             
0141++ 0E60             ; STRCAT
0142++ 0E60             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0E60             ; source in SI
0144++ 0E60             ; destination in DI
0145++ 0E60             _strcat:
0146++ 0E60 E2          	push si
0147++ 0E61 E3          	push di
0148++ 0E62 D7          	push a
0149++ 0E63 DA          	push d
0150++ 0E64 50          	mov a, di
0151++ 0E65 3C          	mov d, a
0152++ 0E66             _strcat_goto_end_L1:
0153++ 0E66 BD 00       	cmp byte[d], 0
0154++ 0E68 C6 6F 0E    	je _strcat_start
0155++ 0E6B 79          	inc d
0156++ 0E6C 0A 66 0E    	jmp _strcat_goto_end_L1
0157++ 0E6F             _strcat_start:
0158++ 0E6F FD 50       	mov di, d
0159++ 0E71             _strcat_L1:
0160++ 0E71 F6          	lodsb
0161++ 0E72 F7          	stosb
0162++ 0E73 B9 00       	cmp al, 0
0163++ 0E75 C7 71 0E    	jne _strcat_L1
0164++ 0E78             _strcat_end:
0165++ 0E78 E7          	pop d
0166++ 0E79 E4          	pop a
0167++ 0E7A F0          	pop di
0168++ 0E7B EF          	pop si
0169++ 0E7C 09          	ret
0170++ 0E7D             
0171++ 0E7D             
0005+  0E7D             
0006+  0E7D             
0007+  0E7D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0E7D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0E7D             ; ASCII in BL
0010+  0E7D             ; result in AL
0011+  0E7D             ; ascii for F = 0100 0110
0012+  0E7D             ; ascii for 9 = 0011 1001
0013+  0E7D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0E7D             hex_ascii_encode:
0015+  0E7D 1B            mov al, bl
0016+  0E7E 93 40         test al, $40        ; test if letter or number
0017+  0E80 C7 86 0E      jnz hex_letter
0018+  0E83 87 0F         and al, $0F        ; get number
0019+  0E85 09            ret
0020+  0E86             hex_letter:
0021+  0E86 87 0F         and al, $0F        ; get letter
0022+  0E88 6A 09         add al, 9
0023+  0E8A 09            ret
0024+  0E8B             
0025+  0E8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0E8B             ; ATOI
0027+  0E8B             ; 2 letter hex string in B
0028+  0E8B             ; 8bit integer returned in AL
0029+  0E8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0E8B             _atoi:
0031+  0E8B D8            push b
0032+  0E8C 07 7D 0E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0E8F 30            mov bl, bh
0034+  0E90 DB            push al          ; save a
0035+  0E91 07 7D 0E      call hex_ascii_encode
0036+  0E94 EA            pop bl  
0037+  0E95 FD 9E 04      shl al, 4
0038+  0E98 8C            or al, bl
0039+  0E99 E5            pop b
0040+  0E9A 09            ret  
0041+  0E9B             
0042+  0E9B             
0043+  0E9B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0E9B             ; scanf
0045+  0E9B             ; no need for explanations!
0046+  0E9B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0E9B             scanf:
0048+  0E9B 09            ret
0049+  0E9C             
0050+  0E9C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0E9C             ; ITOA
0052+  0E9C             ; 8bit value in BL
0053+  0E9C             ; 2 byte ASCII result in A
0054+  0E9C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0E9C             _itoa:
0056+  0E9C DA            push d
0057+  0E9D D8            push b
0058+  0E9E A7 00         mov bh, 0
0059+  0EA0 FD A4 04      shr bl, 4  
0060+  0EA3 74            mov d, b
0061+  0EA4 1F 4C 11      mov al, [d + s_hex_digits]
0062+  0EA7 23            mov ah, al
0063+  0EA8               
0064+  0EA8 E5            pop b
0065+  0EA9 D8            push b
0066+  0EAA A7 00         mov bh, 0
0067+  0EAC FD 87 0F      and bl, $0F
0068+  0EAF 74            mov d, b
0069+  0EB0 1F 4C 11      mov al, [d + s_hex_digits]
0070+  0EB3 E5            pop b
0071+  0EB4 E7            pop d
0072+  0EB5 09            ret
0073+  0EB6             
0074+  0EB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0EB6             ; HEX STRING TO BINARY
0076+  0EB6             ; di = destination address
0077+  0EB6             ; si = source
0078+  0EB6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0EB6             _hex_to_int:
0080+  0EB6             _hex_to_int_L1:
0081+  0EB6 F6            lodsb          ; load from [SI] to AL
0082+  0EB7 B9 00         cmp al, 0        ; check if ASCII 0
0083+  0EB9 C6 C6 0E      jz _hex_to_int_ret
0084+  0EBC 36            mov bh, al
0085+  0EBD F6            lodsb
0086+  0EBE 2F            mov bl, al
0087+  0EBF 07 8B 0E      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0EC2 F7            stosb          ; store AL to [DI]
0089+  0EC3 0A B6 0E      jmp _hex_to_int_L1
0090+  0EC6             _hex_to_int_ret:
0091+  0EC6 09            ret    
0092+  0EC7             
0093+  0EC7             
0094+  0EC7             
0095+  0EC7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0EC7             ; GETCHAR
0097+  0EC7             ; char in ah
0098+  0EC7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0EC7             getch:
0100+  0EC7 DB            push al
0101+  0EC8             getch_retry:
0102+  0EC8 19 01         mov al, 1
0103+  0ECA 05 03         syscall sys_io      ; receive in AH
0104+  0ECC E8            pop al
0105+  0ECD 09            ret
0106+  0ECE             
0107+  0ECE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0ECE             ; PUTCHAR
0109+  0ECE             ; char in ah
0110+  0ECE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0ECE             _putchar:
0112+  0ECE D7            push a
0113+  0ECF 19 00         mov al, 0
0114+  0ED1 05 03         syscall sys_io      ; char in AH
0115+  0ED3 E4            pop a
0116+  0ED4 09            ret
0117+  0ED5             
0118+  0ED5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0ED5             ;; INPUT A STRING
0120+  0ED5             ;; terminates with null
0121+  0ED5             ;; pointer in D
0122+  0ED5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0ED5             _gets:
0124+  0ED5 D7            push a
0125+  0ED6 DA            push d
0126+  0ED7             _gets_loop:
0127+  0ED7 19 01         mov al, 1
0128+  0ED9 05 03         syscall sys_io      ; receive in AH
0129+  0EDB B9 00         cmp al, 0        ; check error code (AL)
0130+  0EDD C6 D7 0E      je _gets_loop      ; if no char received, retry
0131+  0EE0             
0132+  0EE0 76 1B         cmp ah, 27
0133+  0EE2 C6 03 0F      je _gets_ansi_esc
0134+  0EE5 76 0A         cmp ah, $0A        ; LF
0135+  0EE7 C6 6E 0F      je _gets_end
0136+  0EEA 76 0D         cmp ah, $0D        ; CR
0137+  0EEC C6 6E 0F      je _gets_end
0138+  0EEF 76 5C         cmp ah, $5C        ; '\\'
0139+  0EF1 C6 2F 0F      je _gets_escape
0140+  0EF4               
0141+  0EF4 76 08         cmp ah, $08      ; check for backspace
0142+  0EF6 C6 FF 0E      je _gets_backspace
0143+  0EF9             
0144+  0EF9 1A            mov al, ah
0145+  0EFA 3E            mov [d], al
0146+  0EFB 79            inc d
0147+  0EFC 0A D7 0E      jmp _gets_loop
0148+  0EFF             _gets_backspace:
0149+  0EFF 7F            dec d
0150+  0F00 0A D7 0E      jmp _gets_loop
0151+  0F03             _gets_ansi_esc:
0152+  0F03 19 01         mov al, 1
0153+  0F05 05 03         syscall sys_io        ; receive in AH without echo
0154+  0F07 B9 00         cmp al, 0          ; check error code (AL)
0155+  0F09 C6 03 0F      je _gets_ansi_esc    ; if no char received, retry
0156+  0F0C 76 5B         cmp ah, '['
0157+  0F0E C7 D7 0E      jne _gets_loop
0158+  0F11             _gets_ansi_esc_2:
0159+  0F11 19 01         mov al, 1
0160+  0F13 05 03         syscall sys_io          ; receive in AH without echo
0161+  0F15 B9 00         cmp al, 0            ; check error code (AL)
0162+  0F17 C6 11 0F      je _gets_ansi_esc_2  ; if no char received, retry
0163+  0F1A 76 44         cmp ah, 'D'
0164+  0F1C C6 27 0F      je _gets_left_arrow
0165+  0F1F 76 43         cmp ah, 'C'
0166+  0F21 C6 2B 0F      je _gets_right_arrow
0167+  0F24 0A D7 0E      jmp _gets_loop
0168+  0F27             _gets_left_arrow:
0169+  0F27 7F            dec d
0170+  0F28 0A D7 0E      jmp _gets_loop
0171+  0F2B             _gets_right_arrow:
0172+  0F2B 79            inc d
0173+  0F2C 0A D7 0E      jmp _gets_loop
0174+  0F2F             _gets_escape:
0175+  0F2F 19 01         mov al, 1
0176+  0F31 05 03         syscall sys_io      ; receive in AH
0177+  0F33 B9 00         cmp al, 0        ; check error code (AL)
0178+  0F35 C6 2F 0F      je _gets_escape      ; if no char received, retry
0179+  0F38 76 6E         cmp ah, 'n'
0180+  0F3A C6 59 0F      je _gets_LF
0181+  0F3D 76 72         cmp ah, 'r'
0182+  0F3F C6 60 0F      je _gets_CR
0183+  0F42 76 30         cmp ah, '0'
0184+  0F44 C6 67 0F      je _gets_NULL
0185+  0F47 76 5C         cmp ah, $5C  ; '\'
0186+  0F49 C6 52 0F      je _gets_slash
0187+  0F4C 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  0F4D 3E            mov [d], al
0189+  0F4E 79            inc d
0190+  0F4F 0A D7 0E      jmp _gets_loop
0191+  0F52             _gets_slash:
0192+  0F52 19 5C         mov al, $5C
0193+  0F54 3E            mov [d], al
0194+  0F55 79            inc d
0195+  0F56 0A D7 0E      jmp _gets_loop
0196+  0F59             _gets_LF:
0197+  0F59 19 0A         mov al, $0A
0198+  0F5B 3E            mov [d], al
0199+  0F5C 79            inc d
0200+  0F5D 0A D7 0E      jmp _gets_loop
0201+  0F60             _gets_CR:
0202+  0F60 19 0D         mov al, $0D
0203+  0F62 3E            mov [d], al
0204+  0F63 79            inc d
0205+  0F64 0A D7 0E      jmp _gets_loop
0206+  0F67             _gets_NULL:
0207+  0F67 19 00         mov al, $00
0208+  0F69 3E            mov [d], al
0209+  0F6A 79            inc d
0210+  0F6B 0A D7 0E      jmp _gets_loop
0211+  0F6E             _gets_end:
0212+  0F6E 19 00         mov al, 0
0213+  0F70 3E            mov [d], al        ; terminate string
0214+  0F71 E7            pop d
0215+  0F72 E4            pop a
0216+  0F73 09            ret
0217+  0F74             
0218+  0F74             
0219+  0F74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  0F74             ;; INPUT TEXT
0221+  0F74             ;; terminated with CTRL+D
0222+  0F74             ;; pointer in D
0223+  0F74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  0F74             _gettxt:
0225+  0F74 D7            push a
0226+  0F75 DA            push d
0227+  0F76             _gettxt_loop:
0228+  0F76 19 01         mov al, 1
0229+  0F78 05 03         syscall sys_io      ; receive in AH
0230+  0F7A B9 00         cmp al, 0        ; check error code (AL)
0231+  0F7C C6 76 0F      je _gettxt_loop    ; if no char received, retry
0232+  0F7F 76 04         cmp ah, 4      ; EOT
0233+  0F81 C6 BF 0F      je _gettxt_end
0234+  0F84 76 08         cmp ah, $08      ; check for backspace
0235+  0F86 C6 BB 0F      je _gettxt_backspace
0236+  0F89 76 5C         cmp ah, $5C        ; '\'
0237+  0F8B C6 94 0F      je _gettxt_escape
0238+  0F8E 1A            mov al, ah
0239+  0F8F 3E            mov [d], al
0240+  0F90 79            inc d
0241+  0F91 0A 76 0F      jmp _gettxt_loop
0242+  0F94             _gettxt_escape:
0243+  0F94 19 01         mov al, 1
0244+  0F96 05 03         syscall sys_io      ; receive in AH
0245+  0F98 B9 00         cmp al, 0        ; check error code (AL)
0246+  0F9A C6 94 0F      je _gettxt_escape    ; if no char received, retry
0247+  0F9D 76 6E         cmp ah, 'n'
0248+  0F9F C6 AD 0F      je _gettxt_LF
0249+  0FA2 76 72         cmp ah, 'r'
0250+  0FA4 C6 B4 0F      je _gettxt_CR
0251+  0FA7 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0FA8 3E            mov [d], al
0253+  0FA9 79            inc d
0254+  0FAA 0A 76 0F      jmp _gettxt_loop
0255+  0FAD             _gettxt_LF:
0256+  0FAD 19 0A         mov al, $0A
0257+  0FAF 3E            mov [d], al
0258+  0FB0 79            inc d
0259+  0FB1 0A 76 0F      jmp _gettxt_loop
0260+  0FB4             _gettxt_CR:
0261+  0FB4 19 0D         mov al, $0D
0262+  0FB6 3E            mov [d], al
0263+  0FB7 79            inc d
0264+  0FB8 0A 76 0F      jmp _gettxt_loop
0265+  0FBB             _gettxt_backspace:
0266+  0FBB 7F            dec d
0267+  0FBC 0A 76 0F      jmp _gettxt_loop
0268+  0FBF             _gettxt_end:
0269+  0FBF 19 00         mov al, 0
0270+  0FC1 3E            mov [d], al        ; terminate string
0271+  0FC2 E7            pop d
0272+  0FC3 E4            pop a
0273+  0FC4 09            ret
0274+  0FC5             
0275+  0FC5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0FC5             ; PRINT NEW LINE
0277+  0FC5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  0FC5             printnl:
0279+  0FC5 D7            push a
0280+  0FC6 10 00 0A      mov a, $0A00
0281+  0FC9 05 03         syscall sys_io
0282+  0FCB 10 00 0D      mov a, $0D00
0283+  0FCE 05 03         syscall sys_io
0284+  0FD0 E4            pop a
0285+  0FD1 09            ret
0286+  0FD2             
0287+  0FD2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0FD2             ; _strtoint
0289+  0FD2             ; 4 digit hex string number in d
0290+  0FD2             ; integer returned in A
0291+  0FD2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  0FD2             _strtointx:
0293+  0FD2 D8            push b
0294+  0FD3 32            mov bl, [d]
0295+  0FD4 37            mov bh, bl
0296+  0FD5 33 01 00      mov bl, [d + 1]
0297+  0FD8 07 8B 0E      call _atoi        ; convert to int in AL
0298+  0FDB 23            mov ah, al        ; move to AH
0299+  0FDC 33 02 00      mov bl, [d + 2]
0300+  0FDF 37            mov bh, bl
0301+  0FE0 33 03 00      mov bl, [d + 3]
0302+  0FE3 07 8B 0E      call _atoi        ; convert to int in AL
0303+  0FE6 E5            pop b
0304+  0FE7 09            ret
0305+  0FE8             
0306+  0FE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  0FE8             ; _strtoint
0308+  0FE8             ; 5 digit base10 string number in d
0309+  0FE8             ; integer returned in A
0310+  0FE8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  0FE8             _strtoint:
0312+  0FE8 E2            push si
0313+  0FE9 D8            push b
0314+  0FEA D9            push c
0315+  0FEB DA            push d
0316+  0FEC 07 2D 0E      call _strlen      ; get string length in C
0317+  0FEF 7E            dec c
0318+  0FF0 FD 4E         mov si, d
0319+  0FF2 12            mov a, c
0320+  0FF3 FD 99         shl a
0321+  0FF5 3B 64 11      mov d, table_power
0322+  0FF8 59            add d, a
0323+  0FF9 38 00 00      mov c, 0
0324+  0FFC             _strtoint_L0:
0325+  0FFC F6            lodsb      ; load ASCII to al
0326+  0FFD B9 00         cmp al, 0
0327+  0FFF C6 12 10      je _strtoint_end
0328+  1002 6F 30         sub al, $30    ; make into integer
0329+  1004 22 00         mov ah, 0
0330+  1006 2A            mov b, [d]
0331+  1007 AC            mul a, b      ; result in B since it fits in 16bits
0332+  1008 11            mov a, b
0333+  1009 28            mov b, c
0334+  100A 54            add a, b
0335+  100B 39            mov c, a
0336+  100C 63 02 00      sub d, 2
0337+  100F 0A FC 0F      jmp _strtoint_L0
0338+  1012             _strtoint_end:
0339+  1012 12            mov a, c
0340+  1013 E7            pop d
0341+  1014 E6            pop c
0342+  1015 E5            pop b
0343+  1016 EF            pop si
0344+  1017 09            ret
0345+  1018             
0346+  1018             
0347+  1018             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  1018             ; PRINT NULL TERMINATED STRING
0349+  1018             ; pointer in D
0350+  1018             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  1018             _puts:
0352+  1018 D7            push a
0353+  1019 DA            push d
0354+  101A             _puts_L1:
0355+  101A 1E            mov al, [d]
0356+  101B B9 00         cmp al, 0
0357+  101D C6 29 10      jz _puts_END
0358+  1020 23            mov ah, al
0359+  1021 19 00         mov al, 0
0360+  1023 05 03         syscall sys_io
0361+  1025 79            inc d
0362+  1026 0A 1A 10      jmp _puts_L1
0363+  1029             _puts_END:
0364+  1029 E7            pop d
0365+  102A E4            pop a
0366+  102B 09            ret
0367+  102C             
0368+  102C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  102C             ; PRINT N SIZE STRING
0370+  102C             ; pointer in D
0371+  102C             ; size in C
0372+  102C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  102C             _putsn:
0374+  102C DB            push al
0375+  102D DA            push d
0376+  102E D9            push c
0377+  102F             _putsn_L0:
0378+  102F 1E            mov al, [d]
0379+  1030 23            mov ah, al
0380+  1031 19 00         mov al, 0
0381+  1033 05 03         syscall sys_io
0382+  1035 79            inc d
0383+  1036 7E            dec c  
0384+  1037 C2 00 00      cmp c, 0
0385+  103A C7 2F 10      jne _putsn_L0
0386+  103D             _putsn_end:
0387+  103D E6            pop c
0388+  103E E7            pop d
0389+  103F E8            pop al
0390+  1040 09            ret
0391+  1041             
0392+  1041             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1041             ; print 16bit decimal number
0394+  1041             ; input number in A
0395+  1041             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1041             print_u16d:
0397+  1041 D7            push a
0398+  1042 D8            push b
0399+  1043 26 10 27      mov b, 10000
0400+  1046 AE            div a, b      ; get 10000's coeff.
0401+  1047 07 69 10      call print_number
0402+  104A 11            mov a, b
0403+  104B 26 E8 03      mov b, 1000
0404+  104E AE            div a, b      ; get 1000's coeff.
0405+  104F 07 69 10      call print_number
0406+  1052 11            mov a, b
0407+  1053 26 64 00      mov b, 100
0408+  1056 AE            div a, b
0409+  1057 07 69 10      call print_number
0410+  105A 11            mov a, b
0411+  105B 26 0A 00      mov b, 10
0412+  105E AE            div a, b
0413+  105F 07 69 10      call print_number
0414+  1062 1B            mov al, bl      ; 1's coeff in bl
0415+  1063 07 69 10      call print_number
0416+  1066 E5            pop b
0417+  1067 E4            pop a
0418+  1068 09            ret
0419+  1069             
0420+  1069             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  1069             ; print AL
0422+  1069             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  1069             print_number:
0424+  1069 6A 30         add al, $30
0425+  106B 23            mov ah, al
0426+  106C 07 CE 0E      call _putchar
0427+  106F 09            ret
0428+  1070             
0429+  1070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1070             ; PRINT 16BIT HEX INTEGER
0431+  1070             ; integer value in reg B
0432+  1070             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1070             print_u16x:
0434+  1070 D7            push a
0435+  1071 D8            push b
0436+  1072 DD            push bl
0437+  1073 30            mov bl, bh
0438+  1074 07 9C 0E      call _itoa        ; convert bh to char in A
0439+  1077 2F            mov bl, al        ; save al
0440+  1078 19 00         mov al, 0
0441+  107A 05 03         syscall sys_io        ; display AH
0442+  107C 24            mov ah, bl        ; retrieve al
0443+  107D 19 00         mov al, 0
0444+  107F 05 03         syscall sys_io        ; display AL
0445+  1081             
0446+  1081 EA            pop bl
0447+  1082 07 9C 0E      call _itoa        ; convert bh to char in A
0448+  1085 2F            mov bl, al        ; save al
0449+  1086 19 00         mov al, 0
0450+  1088 05 03         syscall sys_io        ; display AH
0451+  108A 24            mov ah, bl        ; retrieve al
0452+  108B 19 00         mov al, 0
0453+  108D 05 03         syscall sys_io        ; display AL
0454+  108F             
0455+  108F E5            pop b
0456+  1090 E4            pop a
0457+  1091 09            ret
0458+  1092             
0459+  1092             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  1092             ; INPUT 16BIT HEX INTEGER
0461+  1092             ; read 16bit integer into A
0462+  1092             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  1092             scan_u16x:
0464+  1092 F8 10 00      enter 16
0465+  1095 D8            push b
0466+  1096 DA            push d
0467+  1097             
0468+  1097 FA F1 FF      lea d, [bp + -15]
0469+  109A 07 D5 0E      call _gets        ; get number
0470+  109D             
0471+  109D 32            mov bl, [d]
0472+  109E 37            mov bh, bl
0473+  109F 33 01 00      mov bl, [d + 1]
0474+  10A2 07 8B 0E      call _atoi        ; convert to int in AL
0475+  10A5 23            mov ah, al        ; move to AH
0476+  10A6             
0477+  10A6 33 02 00      mov bl, [d + 2]
0478+  10A9 37            mov bh, bl
0479+  10AA 33 03 00      mov bl, [d + 3]
0480+  10AD 07 8B 0E      call _atoi        ; convert to int in AL
0481+  10B0             
0482+  10B0 E7            pop d
0483+  10B1 E5            pop b
0484+  10B2 F9            leave
0485+  10B3 09            ret
0486+  10B4             
0487+  10B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  10B4             ; PRINT 8bit HEX INTEGER
0489+  10B4             ; integer value in reg bl
0490+  10B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  10B4             print_u8x:
0492+  10B4 D7            push a
0493+  10B5 DD            push bl
0494+  10B6             
0495+  10B6 07 9C 0E      call _itoa        ; convert bl to char in A
0496+  10B9 2F            mov bl, al        ; save al
0497+  10BA 19 00         mov al, 0
0498+  10BC 05 03         syscall sys_io        ; display AH
0499+  10BE 24            mov ah, bl        ; retrieve al
0500+  10BF 19 00         mov al, 0
0501+  10C1 05 03         syscall sys_io        ; display AL
0502+  10C3             
0503+  10C3 EA            pop bl
0504+  10C4 E4            pop a
0505+  10C5 09            ret
0506+  10C6             
0507+  10C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  10C6             ; print 8bit decimal unsigned number
0509+  10C6             ; input number in AL
0510+  10C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  10C6             print_u8d:
0512+  10C6 D7            push a
0513+  10C7 D8            push b
0514+  10C8             
0515+  10C8 22 00         mov ah, 0
0516+  10CA 26 64 00      mov b, 100
0517+  10CD AE            div a, b
0518+  10CE D8            push b      ; save remainder
0519+  10CF B9 00         cmp al, 0
0520+  10D1 C6 DB 10      je skip100
0521+  10D4 6A 30         add al, $30
0522+  10D6 23            mov ah, al
0523+  10D7 19 00         mov al, 0
0524+  10D9 05 03         syscall sys_io  ; print coeff
0525+  10DB             skip100:
0526+  10DB E4            pop a
0527+  10DC 22 00         mov ah, 0
0528+  10DE 26 0A 00      mov b, 10
0529+  10E1 AE            div a, b
0530+  10E2 D8            push b      ; save remainder
0531+  10E3 B9 00         cmp al, 0
0532+  10E5 C6 EF 10      je skip10
0533+  10E8 6A 30         add al, $30
0534+  10EA 23            mov ah, al
0535+  10EB 19 00         mov al, 0
0536+  10ED 05 03         syscall sys_io  ; print coeff
0537+  10EF             skip10:
0538+  10EF E4            pop a
0539+  10F0 1B            mov al, bl
0540+  10F1 6A 30         add al, $30
0541+  10F3 23            mov ah, al
0542+  10F4 19 00         mov al, 0
0543+  10F6 05 03         syscall sys_io  ; print coeff
0544+  10F8 E5            pop b
0545+  10F9 E4            pop a
0546+  10FA 09            ret
0547+  10FB             
0548+  10FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  10FB             ; INPUT 8BIT HEX INTEGER
0550+  10FB             ; read 8bit integer into AL
0551+  10FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  10FB             scan_u8x:
0553+  10FB F8 04 00      enter 4
0554+  10FE D8            push b
0555+  10FF DA            push d
0556+  1100             
0557+  1100 FA FD FF      lea d, [bp + -3]
0558+  1103 07 D5 0E      call _gets        ; get number
0559+  1106             
0560+  1106 32            mov bl, [d]
0561+  1107 37            mov bh, bl
0562+  1108 33 01 00      mov bl, [d + 1]
0563+  110B 07 8B 0E      call _atoi        ; convert to int in AL
0564+  110E             
0565+  110E E7            pop d
0566+  110F E5            pop b
0567+  1110 F9            leave
0568+  1111 09            ret
0569+  1112             
0570+  1112             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  1112             ; input decimal number
0572+  1112             ; result in A
0573+  1112             ; 655'\0'
0574+  1112             ; low--------high
0575+  1112             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  1112             scan_u16d:
0577+  1112 F8 08 00      enter 8
0578+  1115 E2            push si
0579+  1116 D8            push b
0580+  1117 D9            push c
0581+  1118 DA            push d
0582+  1119 FA F9 FF      lea d, [bp +- 7]
0583+  111C 07 D5 0E      call _gets
0584+  111F 07 2D 0E      call _strlen      ; get string length in C
0585+  1122 7E            dec c
0586+  1123 FD 4E         mov si, d
0587+  1125 12            mov a, c
0588+  1126 FD 99         shl a
0589+  1128 3B 64 11      mov d, table_power
0590+  112B 59            add d, a
0591+  112C 38 00 00      mov c, 0
0592+  112F             mul_loop:
0593+  112F F6            lodsb      ; load ASCII to al
0594+  1130 B9 00         cmp al, 0
0595+  1132 C6 45 11      je mul_exit
0596+  1135 6F 30         sub al, $30    ; make into integer
0597+  1137 22 00         mov ah, 0
0598+  1139 2A            mov b, [d]
0599+  113A AC            mul a, b      ; result in B since it fits in 16bits
0600+  113B 11            mov a, b
0601+  113C 28            mov b, c
0602+  113D 54            add a, b
0603+  113E 39            mov c, a
0604+  113F 63 02 00      sub d, 2
0605+  1142 0A 2F 11      jmp mul_loop
0606+  1145             mul_exit:
0607+  1145 12            mov a, c
0608+  1146 E7            pop d
0609+  1147 E6            pop c
0610+  1148 E5            pop b
0611+  1149 EF            pop si
0612+  114A F9            leave
0613+  114B 09            ret
0614+  114C             
0615+  114C             
0616+  114C 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1150 34 35 36 37 
0616+  1154 38 39 41 42 
0616+  1158 43 44 45 46 
0617+  115C 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1160 1B 5B 48 00 
0618+  1164             
0619+  1164             table_power:
0620+  1164 01 00         .dw 1
0621+  1166 0A 00         .dw 10
0622+  1168 64 00         .dw 100
0623+  116A E8 03         .dw 1000
0624+  116C 10 27         .dw 100001859   116E             ; --- END INLINE ASM BLOCK
1860   116E             
1861   116E F9            leave
1862   116F 09            ret
1863   1170             
1864   1170             sqrt:
1865   1170 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1866   1173             ; $x 
1867   1173             ; $y 
1868   1173 52 04 00      sub sp, 4
1869   1176             ;; if (n <= 1) { 
1870   1176             _if25_cond:
1871   1176 FA 05 00      lea d, [bp + 5] ; $n
1872   1179 2A            mov b, [d]
1873   117A             ; START RELATIONAL
1874   117A D7            push a
1875   117B 11            mov a, b
1876   117C 26 01 00      mov b, $1
1877   117F B0            cmp a, b
1878   1180 FD 74         sle ; <=
1879   1182 E4            pop a
1880   1183             ; END RELATIONAL
1881   1183 C0 00 00      cmp b, 0
1882   1186 C6 92 11      je _if25_exit
1883   1189             _if25_true:
1884   1189             ;; return n; 
1885   1189 FA 05 00      lea d, [bp + 5] ; $n
1886   118C 2A            mov b, [d]
1887   118D F9            leave
1888   118E 09            ret
1889   118F 0A 92 11      jmp _if25_exit
1890   1192             _if25_exit:
1891   1192             ;; x = n; 
1892   1192 FA FF FF      lea d, [bp + -1] ; $x
1893   1195 DA            push d
1894   1196 FA 05 00      lea d, [bp + 5] ; $n
1895   1199 2A            mov b, [d]
1896   119A E7            pop d
1897   119B FD 43         mov [d], b
1898   119D             ;; y = (x + n / x) / 2; 
1899   119D FA FD FF      lea d, [bp + -3] ; $y
1900   11A0 DA            push d
1901   11A1 FA FF FF      lea d, [bp + -1] ; $x
1902   11A4 2A            mov b, [d]
1903   11A5             ; START TERMS
1904   11A5 D7            push a
1905   11A6 11            mov a, b
1906   11A7 FA 05 00      lea d, [bp + 5] ; $n
1907   11AA 2A            mov b, [d]
1908   11AB             ; START FACTORS
1909   11AB D7            push a
1910   11AC 11            mov a, b
1911   11AD FA FF FF      lea d, [bp + -1] ; $x
1912   11B0 2A            mov b, [d]
1913   11B1 AE            div a, b
1914   11B2 27            mov b, a
1915   11B3 E4            pop a
1916   11B4             ; END FACTORS
1917   11B4 54            add a, b
1918   11B5 27            mov b, a
1919   11B6 E4            pop a
1920   11B7             ; END TERMS
1921   11B7             ; START FACTORS
1922   11B7 D7            push a
1923   11B8 11            mov a, b
1924   11B9 26 02 00      mov b, $2
1925   11BC AE            div a, b
1926   11BD 27            mov b, a
1927   11BE E4            pop a
1928   11BF             ; END FACTORS
1929   11BF E7            pop d
1930   11C0 FD 43         mov [d], b
1931   11C2             ;; while (y < x) { 
1932   11C2             _while26_cond:
1933   11C2 FA FD FF      lea d, [bp + -3] ; $y
1934   11C5 2A            mov b, [d]
1935   11C6             ; START RELATIONAL
1936   11C6 D7            push a
1937   11C7 11            mov a, b
1938   11C8 FA FF FF      lea d, [bp + -1] ; $x
1939   11CB 2A            mov b, [d]
1940   11CC B0            cmp a, b
1941   11CD FD 73         slt ; < 
1942   11CF E4            pop a
1943   11D0             ; END RELATIONAL
1944   11D0 C0 00 00      cmp b, 0
1945   11D3 C6 09 12      je _while26_exit
1946   11D6             _while26_block:
1947   11D6             ;; x = y; 
1948   11D6 FA FF FF      lea d, [bp + -1] ; $x
1949   11D9 DA            push d
1950   11DA FA FD FF      lea d, [bp + -3] ; $y
1951   11DD 2A            mov b, [d]
1952   11DE E7            pop d
1953   11DF FD 43         mov [d], b
1954   11E1             ;; y = (x + n / x) / 2; 
1955   11E1 FA FD FF      lea d, [bp + -3] ; $y
1956   11E4 DA            push d
1957   11E5 FA FF FF      lea d, [bp + -1] ; $x
1958   11E8 2A            mov b, [d]
1959   11E9             ; START TERMS
1960   11E9 D7            push a
1961   11EA 11            mov a, b
1962   11EB FA 05 00      lea d, [bp + 5] ; $n
1963   11EE 2A            mov b, [d]
1964   11EF             ; START FACTORS
1965   11EF D7            push a
1966   11F0 11            mov a, b
1967   11F1 FA FF FF      lea d, [bp + -1] ; $x
1968   11F4 2A            mov b, [d]
1969   11F5 AE            div a, b
1970   11F6 27            mov b, a
1971   11F7 E4            pop a
1972   11F8             ; END FACTORS
1973   11F8 54            add a, b
1974   11F9 27            mov b, a
1975   11FA E4            pop a
1976   11FB             ; END TERMS
1977   11FB             ; START FACTORS
1978   11FB D7            push a
1979   11FC 11            mov a, b
1980   11FD 26 02 00      mov b, $2
1981   1200 AE            div a, b
1982   1201 27            mov b, a
1983   1202 E4            pop a
1984   1203             ; END FACTORS
1985   1203 E7            pop d
1986   1204 FD 43         mov [d], b
1987   1206 0A C2 11      jmp _while26_cond
1988   1209             _while26_exit:
1989   1209             ;; return x; 
1990   1209 FA FF FF      lea d, [bp + -1] ; $x
1991   120C 2A            mov b, [d]
1992   120D F9            leave
1993   120E 09            ret
1994   120F             
1995   120F             exp:
1996   120F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1997   1212             ; $i 
1998   1212             ; $result 
1999   1212 10 01 00      mov a, $1
2000   1215 45 FD FF      mov [bp + -3], a
2001   1218 52 04 00      sub sp, 4
2002   121B             ;; for(i = 0; i < exp; i++){ 
2003   121B             _for27_init:
2004   121B FA FF FF      lea d, [bp + -1] ; $i
2005   121E DA            push d
2006   121F 26 00 00      mov b, $0
2007   1222 E7            pop d
2008   1223 FD 43         mov [d], b
2009   1225             _for27_cond:
2010   1225 FA FF FF      lea d, [bp + -1] ; $i
2011   1228 2A            mov b, [d]
2012   1229             ; START RELATIONAL
2013   1229 D7            push a
2014   122A 11            mov a, b
2015   122B FA 05 00      lea d, [bp + 5] ; $exp
2016   122E 2A            mov b, [d]
2017   122F B0            cmp a, b
2018   1230 FD 73         slt ; < 
2019   1232 E4            pop a
2020   1233             ; END RELATIONAL
2021   1233 C0 00 00      cmp b, 0
2022   1236 C6 60 12      je _for27_exit
2023   1239             _for27_block:
2024   1239             ;; result = result * base; 
2025   1239 FA FD FF      lea d, [bp + -3] ; $result
2026   123C DA            push d
2027   123D FA FD FF      lea d, [bp + -3] ; $result
2028   1240 2A            mov b, [d]
2029   1241             ; START FACTORS
2030   1241 D7            push a
2031   1242 11            mov a, b
2032   1243 FA 07 00      lea d, [bp + 7] ; $base
2033   1246 2A            mov b, [d]
2034   1247 AC            mul a, b ; *
2035   1248 11            mov a, b
2036   1249 27            mov b, a
2037   124A E4            pop a
2038   124B             ; END FACTORS
2039   124B E7            pop d
2040   124C FD 43         mov [d], b
2041   124E             _for27_update:
2042   124E FA FF FF      lea d, [bp + -1] ; $i
2043   1251 2A            mov b, [d]
2044   1252 FD 79         mov g, b
2045   1254 FD 77         inc b
2046   1256 FA FF FF      lea d, [bp + -1] ; $i
2047   1259 FD 43         mov [d], b
2048   125B FD 27         mov b, g
2049   125D 0A 25 12      jmp _for27_cond
2050   1260             _for27_exit:
2051   1260             ;; return result; 
2052   1260 FA FD FF      lea d, [bp + -3] ; $result
2053   1263 2A            mov b, [d]
2054   1264 F9            leave
2055   1265 09            ret
2056   1266             
2057   1266             primes1:
2058   1266 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2059   1269             ; $n 
2060   1269             ; $i 
2061   1269             ; $s 
2062   1269             ; $count 
2063   1269             ; $divides 
2064   1269 52 0A 00      sub sp, 10
2065   126C             ;; n = 2; 
2066   126C FA FF FF      lea d, [bp + -1] ; $n
2067   126F DA            push d
2068   1270 26 02 00      mov b, $2
2069   1273 E7            pop d
2070   1274 FD 43         mov [d], b
2071   1276             ;; while(n < top){ 
2072   1276             _while28_cond:
2073   1276 FA FF FF      lea d, [bp + -1] ; $n
2074   1279 2A            mov b, [d]
2075   127A             ; START RELATIONAL
2076   127A D7            push a
2077   127B 11            mov a, b
2078   127C 3B 02 14      mov d, _top ; $top
2079   127F 2A            mov b, [d]
2080   1280 B0            cmp a, b
2081   1281 FD 75         slu ; < (unsigned)
2082   1283 E4            pop a
2083   1284             ; END RELATIONAL
2084   1284 C0 00 00      cmp b, 0
2085   1287 C6 7B 13      je _while28_exit
2086   128A             _while28_block:
2087   128A             ;; s = sqrt(n); 
2088   128A FA FB FF      lea d, [bp + -5] ; $s
2089   128D DA            push d
2090   128E FA FF FF      lea d, [bp + -1] ; $n
2091   1291 2A            mov b, [d]
2092   1292 FD AB         swp b
2093   1294 D8            push b
2094   1295 07 70 11      call sqrt
2095   1298 51 02 00      add sp, 2
2096   129B E7            pop d
2097   129C FD 43         mov [d], b
2098   129E             ;; divides = 0; 
2099   129E FA F7 FF      lea d, [bp + -9] ; $divides
2100   12A1 DA            push d
2101   12A2 26 00 00      mov b, $0
2102   12A5 E7            pop d
2103   12A6 FD 43         mov [d], b
2104   12A8             ;; i = 2; 
2105   12A8 FA FD FF      lea d, [bp + -3] ; $i
2106   12AB DA            push d
2107   12AC 26 02 00      mov b, $2
2108   12AF E7            pop d
2109   12B0 FD 43         mov [d], b
2110   12B2             ;; while(i <= s){ 
2111   12B2             _while29_cond:
2112   12B2 FA FD FF      lea d, [bp + -3] ; $i
2113   12B5 2A            mov b, [d]
2114   12B6             ; START RELATIONAL
2115   12B6 D7            push a
2116   12B7 11            mov a, b
2117   12B8 FA FB FF      lea d, [bp + -5] ; $s
2118   12BB 2A            mov b, [d]
2119   12BC B0            cmp a, b
2120   12BD FD 76         sleu ; <= (unsigned)
2121   12BF E4            pop a
2122   12C0             ; END RELATIONAL
2123   12C0 C0 00 00      cmp b, 0
2124   12C3 C6 23 13      je _while29_exit
2125   12C6             _while29_block:
2126   12C6             ;; if(n % i == 0){ 
2127   12C6             _if30_cond:
2128   12C6 FA FF FF      lea d, [bp + -1] ; $n
2129   12C9 2A            mov b, [d]
2130   12CA             ; START FACTORS
2131   12CA D7            push a
2132   12CB 11            mov a, b
2133   12CC FA FD FF      lea d, [bp + -3] ; $i
2134   12CF 2A            mov b, [d]
2135   12D0 AE            div a, b ; 
2136   12D1 11            mov a, b
2137   12D2 27            mov b, a
2138   12D3 E4            pop a
2139   12D4             ; END FACTORS
2140   12D4             ; START RELATIONAL
2141   12D4 D7            push a
2142   12D5 11            mov a, b
2143   12D6 26 00 00      mov b, $0
2144   12D9 B0            cmp a, b
2145   12DA FD 71         seq ; ==
2146   12DC E4            pop a
2147   12DD             ; END RELATIONAL
2148   12DD C0 00 00      cmp b, 0
2149   12E0 C6 F3 12      je _if30_exit
2150   12E3             _if30_true:
2151   12E3             ;; divides = 1; 
2152   12E3 FA F7 FF      lea d, [bp + -9] ; $divides
2153   12E6 DA            push d
2154   12E7 26 01 00      mov b, $1
2155   12EA E7            pop d
2156   12EB FD 43         mov [d], b
2157   12ED             ;; break; 
2158   12ED 0A 23 13      jmp _while29_exit ; while break
2159   12F0 0A F3 12      jmp _if30_exit
2160   12F3             _if30_exit:
2161   12F3             ;; i = i + 1; 
2162   12F3 FA FD FF      lea d, [bp + -3] ; $i
2163   12F6 DA            push d
2164   12F7 FA FD FF      lea d, [bp + -3] ; $i
2165   12FA 2A            mov b, [d]
2166   12FB             ; START TERMS
2167   12FB D7            push a
2168   12FC 11            mov a, b
2169   12FD 26 01 00      mov b, $1
2170   1300 54            add a, b
2171   1301 27            mov b, a
2172   1302 E4            pop a
2173   1303             ; END TERMS
2174   1303 E7            pop d
2175   1304 FD 43         mov [d], b
2176   1306             ;; if(i >= s) break; 
2177   1306             _if31_cond:
2178   1306 FA FD FF      lea d, [bp + -3] ; $i
2179   1309 2A            mov b, [d]
2180   130A             ; START RELATIONAL
2181   130A D7            push a
2182   130B 11            mov a, b
2183   130C FA FB FF      lea d, [bp + -5] ; $s
2184   130F 2A            mov b, [d]
2185   1310 B0            cmp a, b
2186   1311 FD 82         sgeu ; >= (unsigned)
2187   1313 E4            pop a
2188   1314             ; END RELATIONAL
2189   1314 C0 00 00      cmp b, 0
2190   1317 C6 20 13      je _if31_exit
2191   131A             _if31_true:
2192   131A             ;; break; 
2193   131A 0A 23 13      jmp _while29_exit ; while break
2194   131D 0A 20 13      jmp _if31_exit
2195   1320             _if31_exit:
2196   1320 0A B2 12      jmp _while29_cond
2197   1323             _while29_exit:
2198   1323             ;; if(divides == 0){ 
2199   1323             _if32_cond:
2200   1323 FA F7 FF      lea d, [bp + -9] ; $divides
2201   1326 2A            mov b, [d]
2202   1327             ; START RELATIONAL
2203   1327 D7            push a
2204   1328 11            mov a, b
2205   1329 26 00 00      mov b, $0
2206   132C B0            cmp a, b
2207   132D FD 71         seq ; ==
2208   132F E4            pop a
2209   1330             ; END RELATIONAL
2210   1330 C0 00 00      cmp b, 0
2211   1333 C6 65 13      je _if32_exit
2212   1336             _if32_true:
2213   1336             ;; count = count + 1;	 
2214   1336 FA F9 FF      lea d, [bp + -7] ; $count
2215   1339 DA            push d
2216   133A FA F9 FF      lea d, [bp + -7] ; $count
2217   133D 2A            mov b, [d]
2218   133E             ; START TERMS
2219   133E D7            push a
2220   133F 11            mov a, b
2221   1340 26 01 00      mov b, $1
2222   1343 54            add a, b
2223   1344 27            mov b, a
2224   1345 E4            pop a
2225   1346             ; END TERMS
2226   1346 E7            pop d
2227   1347 FD 43         mov [d], b
2228   1349             ;; printu(n); 
2229   1349 FA FF FF      lea d, [bp + -1] ; $n
2230   134C 2A            mov b, [d]
2231   134D FD AB         swp b
2232   134F D8            push b
2233   1350 07 65 0B      call printu
2234   1353 51 02 00      add sp, 2
2235   1356             ;; print("\n"); 
2236   1356 26 4D 14      mov b, __s2 ; "\n"
2237   1359 FD AB         swp b
2238   135B D8            push b
2239   135C 07 99 0C      call print
2240   135F 51 02 00      add sp, 2
2241   1362 0A 65 13      jmp _if32_exit
2242   1365             _if32_exit:
2243   1365             ;; n = n + 1; 
2244   1365 FA FF FF      lea d, [bp + -1] ; $n
2245   1368 DA            push d
2246   1369 FA FF FF      lea d, [bp + -1] ; $n
2247   136C 2A            mov b, [d]
2248   136D             ; START TERMS
2249   136D D7            push a
2250   136E 11            mov a, b
2251   136F 26 01 00      mov b, $1
2252   1372 54            add a, b
2253   1373 27            mov b, a
2254   1374 E4            pop a
2255   1375             ; END TERMS
2256   1375 E7            pop d
2257   1376 FD 43         mov [d], b
2258   1378 0A 76 12      jmp _while28_cond
2259   137B             _while28_exit:
2260   137B             ;; return; 
2261   137B F9            leave
2262   137C 09            ret
2263   137D             
2264   137D             isPrime:
2265   137D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2266   1380             ; $i 
2267   1380 52 02 00      sub sp, 2
2268   1383             ;; if (num <= 1) return 0; 
2269   1383             _if33_cond:
2270   1383 FA 05 00      lea d, [bp + 5] ; $num
2271   1386 2A            mov b, [d]
2272   1387             ; START RELATIONAL
2273   1387 D7            push a
2274   1388 11            mov a, b
2275   1389 26 01 00      mov b, $1
2276   138C B0            cmp a, b
2277   138D FD 76         sleu ; <= (unsigned)
2278   138F E4            pop a
2279   1390             ; END RELATIONAL
2280   1390 C0 00 00      cmp b, 0
2281   1393 C6 9E 13      je _if33_exit
2282   1396             _if33_true:
2283   1396             ;; return 0; 
2284   1396 26 00 00      mov b, $0
2285   1399 F9            leave
2286   139A 09            ret
2287   139B 0A 9E 13      jmp _if33_exit
2288   139E             _if33_exit:
2289   139E             ;; for (i = 2; i * i <= num; i++) { 
2290   139E             _for34_init:
2291   139E FA FF FF      lea d, [bp + -1] ; $i
2292   13A1 DA            push d
2293   13A2 26 02 00      mov b, $2
2294   13A5 E7            pop d
2295   13A6 FD 43         mov [d], b
2296   13A8             _for34_cond:
2297   13A8 FA FF FF      lea d, [bp + -1] ; $i
2298   13AB 2A            mov b, [d]
2299   13AC             ; START FACTORS
2300   13AC D7            push a
2301   13AD 11            mov a, b
2302   13AE FA FF FF      lea d, [bp + -1] ; $i
2303   13B1 2A            mov b, [d]
2304   13B2 AC            mul a, b ; *
2305   13B3 11            mov a, b
2306   13B4 27            mov b, a
2307   13B5 E4            pop a
2308   13B6             ; END FACTORS
2309   13B6             ; START RELATIONAL
2310   13B6 D7            push a
2311   13B7 11            mov a, b
2312   13B8 FA 05 00      lea d, [bp + 5] ; $num
2313   13BB 2A            mov b, [d]
2314   13BC B0            cmp a, b
2315   13BD FD 76         sleu ; <= (unsigned)
2316   13BF E4            pop a
2317   13C0             ; END RELATIONAL
2318   13C0 C0 00 00      cmp b, 0
2319   13C3 C6 FD 13      je _for34_exit
2320   13C6             _for34_block:
2321   13C6             ;; if (num % i == 0) return 0; 
2322   13C6             _if35_cond:
2323   13C6 FA 05 00      lea d, [bp + 5] ; $num
2324   13C9 2A            mov b, [d]
2325   13CA             ; START FACTORS
2326   13CA D7            push a
2327   13CB 11            mov a, b
2328   13CC FA FF FF      lea d, [bp + -1] ; $i
2329   13CF 2A            mov b, [d]
2330   13D0 AE            div a, b ; 
2331   13D1 11            mov a, b
2332   13D2 27            mov b, a
2333   13D3 E4            pop a
2334   13D4             ; END FACTORS
2335   13D4             ; START RELATIONAL
2336   13D4 D7            push a
2337   13D5 11            mov a, b
2338   13D6 26 00 00      mov b, $0
2339   13D9 B0            cmp a, b
2340   13DA FD 71         seq ; ==
2341   13DC E4            pop a
2342   13DD             ; END RELATIONAL
2343   13DD C0 00 00      cmp b, 0
2344   13E0 C6 EB 13      je _if35_exit
2345   13E3             _if35_true:
2346   13E3             ;; return 0; 
2347   13E3 26 00 00      mov b, $0
2348   13E6 F9            leave
2349   13E7 09            ret
2350   13E8 0A EB 13      jmp _if35_exit
2351   13EB             _if35_exit:
2352   13EB             _for34_update:
2353   13EB FA FF FF      lea d, [bp + -1] ; $i
2354   13EE 2A            mov b, [d]
2355   13EF FD 79         mov g, b
2356   13F1 FD 77         inc b
2357   13F3 FA FF FF      lea d, [bp + -1] ; $i
2358   13F6 FD 43         mov [d], b
2359   13F8 FD 27         mov b, g
2360   13FA 0A A8 13      jmp _for34_cond
2361   13FD             _for34_exit:
2362   13FD             ;; return 1; 
2363   13FD 26 01 00      mov b, $1
2364   1400 F9            leave
2365   1401 09            ret
2366   1402             ; --- END TEXT BLOCK
2367   1402             
2368   1402             ; --- BEGIN DATA BLOCK
2369   1402 00 00       _top: .fill 2, 0
2370   1404 45 6E 74 65 __s0: .db "Enter a number to find all prime numbers up to it: ", 0
2370   1408 72 20 61 20 
2370   140C 6E 75 6D 62 
2370   1410 65 72 20 74 
2370   1414 6F 20 66 69 
2370   1418 6E 64 20 61 
2370   141C 6C 6C 20 70 
2370   1420 72 69 6D 65 
2370   1424 20 6E 75 6D 
2370   1428 62 65 72 73 
2370   142C 20 75 70 20 
2370   1430 74 6F 20 69 
2370   1434 74 3A 20 00 
2371   1438 50 72 69 6D __s1: .db "Prime numbers are: \n", 0
2371   143C 65 20 6E 75 
2371   1440 6D 62 65 72 
2371   1444 73 20 61 72 
2371   1448 65 3A 20 0A 
2371   144C 00 
2372   144D 0A 00       __s2: .db "\n", 0
2373   144F 45 72 72 6F __s3: .db "Error: Unknown argument type.\n", 0
2373   1453 72 3A 20 55 
2373   1457 6E 6B 6E 6F 
2373   145B 77 6E 20 61 
2373   145F 72 67 75 6D 
2373   1463 65 6E 74 20 
2373   1467 74 79 70 65 
2373   146B 2E 0A 00 
2374   146E 1B 5B 32 4A __s4: .db "\033[2J\033[H", 0
2374   1472 1B 5B 48 00 
2375   1476             
2376   1476 78 14       _heap_top: .dw _heap
2377   1478 00          _heap: .db 0
2378   1479             ; --- END DATA BLOCK
2379   1479             
2380   1479             .end
tasm: Number of errors = 0
