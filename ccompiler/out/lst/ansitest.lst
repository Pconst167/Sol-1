0001   0000             ; --- FILENAME: ../solarium/usr/bin/ansitest
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $fg 
0011   0408             ; $bg 
0012   0408             ; $color 
0013   0408 52 06 00      sub sp, 6
0014   040B             ;; printf("\033[2J"); 
0015   040B 26 5B 13      mov b, __s0 ; "\033[2J"
0016   040E FD AB         swp b
0017   0410 D8            push b
0018   0411 07 A0 08      call printf
0019   0414 51 02 00      add sp, 2
0020   0417             ;; printf("\033[H"); 
0021   0417 26 60 13      mov b, __s1 ; "\033[H"
0022   041A FD AB         swp b
0023   041C D8            push b
0024   041D 07 A0 08      call printf
0025   0420 51 02 00      add sp, 2
0026   0423             ;; printf("\033[1m"); 
0027   0423 26 64 13      mov b, __s2 ; "\033[1m"
0028   0426 FD AB         swp b
0029   0428 D8            push b
0030   0429 07 A0 08      call printf
0031   042C 51 02 00      add sp, 2
0032   042F             ;; printf("Bold Text"); 
0033   042F 26 69 13      mov b, __s3 ; "Bold Text"
0034   0432 FD AB         swp b
0035   0434 D8            push b
0036   0435 07 A0 08      call printf
0037   0438 51 02 00      add sp, 2
0038   043B             ;; printf("\033[0m\n"); 
0039   043B 26 73 13      mov b, __s4 ; "\033[0m\n"
0040   043E FD AB         swp b
0041   0440 D8            push b
0042   0441 07 A0 08      call printf
0043   0444 51 02 00      add sp, 2
0044   0447             ;; printf("\033[4m"); 
0045   0447 26 79 13      mov b, __s5 ; "\033[4m"
0046   044A FD AB         swp b
0047   044C D8            push b
0048   044D 07 A0 08      call printf
0049   0450 51 02 00      add sp, 2
0050   0453             ;; printf("Underlined Text"); 
0051   0453 26 7E 13      mov b, __s6 ; "Underlined Text"
0052   0456 FD AB         swp b
0053   0458 D8            push b
0054   0459 07 A0 08      call printf
0055   045C 51 02 00      add sp, 2
0056   045F             ;; printf("\033[0m\n"); 
0057   045F 26 73 13      mov b, __s4 ; "\033[0m\n"
0058   0462 FD AB         swp b
0059   0464 D8            push b
0060   0465 07 A0 08      call printf
0061   0468 51 02 00      add sp, 2
0062   046B             ;; printf("\033[5m"); 
0063   046B 26 8E 13      mov b, __s7 ; "\033[5m"
0064   046E FD AB         swp b
0065   0470 D8            push b
0066   0471 07 A0 08      call printf
0067   0474 51 02 00      add sp, 2
0068   0477             ;; printf("Blinking Text"); 
0069   0477 26 93 13      mov b, __s8 ; "Blinking Text"
0070   047A FD AB         swp b
0071   047C D8            push b
0072   047D 07 A0 08      call printf
0073   0480 51 02 00      add sp, 2
0074   0483             ;; printf("\033[0m\n"); 
0075   0483 26 73 13      mov b, __s4 ; "\033[0m\n"
0076   0486 FD AB         swp b
0077   0488 D8            push b
0078   0489 07 A0 08      call printf
0079   048C 51 02 00      add sp, 2
0080   048F             ;; printf("\033[7m"); 
0081   048F 26 A1 13      mov b, __s9 ; "\033[7m"
0082   0492 FD AB         swp b
0083   0494 D8            push b
0084   0495 07 A0 08      call printf
0085   0498 51 02 00      add sp, 2
0086   049B             ;; printf("Inverted Colors"); 
0087   049B 26 A6 13      mov b, __s10 ; "Inverted Colors"
0088   049E FD AB         swp b
0089   04A0 D8            push b
0090   04A1 07 A0 08      call printf
0091   04A4 51 02 00      add sp, 2
0092   04A7             ;; printf("\033[0m\n"); 
0093   04A7 26 73 13      mov b, __s4 ; "\033[0m\n"
0094   04AA FD AB         swp b
0095   04AC D8            push b
0096   04AD 07 A0 08      call printf
0097   04B0 51 02 00      add sp, 2
0098   04B3             ;; printf("\033[0m"); 
0099   04B3 26 B6 13      mov b, __s11 ; "\033[0m"
0100   04B6 FD AB         swp b
0101   04B8 D8            push b
0102   04B9 07 A0 08      call printf
0103   04BC 51 02 00      add sp, 2
0104   04BF             ;; printf("Reset All\n"); 
0105   04BF 26 BB 13      mov b, __s12 ; "Reset All\n"
0106   04C2 FD AB         swp b
0107   04C4 D8            push b
0108   04C5 07 A0 08      call printf
0109   04C8 51 02 00      add sp, 2
0110   04CB             ;; for (bg = 40; bg <= 47; ++bg) { 
0111   04CB             _for1_init:
0112   04CB FA FD FF      lea d, [bp + -3] ; $bg
0113   04CE DA            push d
0114   04CF 26 28 00      mov b, $28
0115   04D2 E7            pop d
0116   04D3 FD 43         mov [d], b
0117   04D5             _for1_cond:
0118   04D5 FA FD FF      lea d, [bp + -3] ; $bg
0119   04D8 2A            mov b, [d]
0120   04D9             ; START RELATIONAL
0121   04D9 D7            push a
0122   04DA 11            mov a, b
0123   04DB 26 2F 00      mov b, $2f
0124   04DE B0            cmp a, b
0125   04DF FD 74         sle ; <=
0126   04E1 E4            pop a
0127   04E2             ; END RELATIONAL
0128   04E2 C0 00 00      cmp b, 0
0129   04E5 C6 9D 05      je _for1_exit
0130   04E8             _for1_block:
0131   04E8             ;; for (fg = 30; fg <= 37; ++fg) { 
0132   04E8             _for2_init:
0133   04E8 FA FF FF      lea d, [bp + -1] ; $fg
0134   04EB DA            push d
0135   04EC 26 1E 00      mov b, $1e
0136   04EF E7            pop d
0137   04F0 FD 43         mov [d], b
0138   04F2             _for2_cond:
0139   04F2 FA FF FF      lea d, [bp + -1] ; $fg
0140   04F5 2A            mov b, [d]
0141   04F6             ; START RELATIONAL
0142   04F6 D7            push a
0143   04F7 11            mov a, b
0144   04F8 26 25 00      mov b, $25
0145   04FB B0            cmp a, b
0146   04FC FD 74         sle ; <=
0147   04FE E4            pop a
0148   04FF             ; END RELATIONAL
0149   04FF C0 00 00      cmp b, 0
0150   0502 C6 83 05      je _for2_exit
0151   0505             _for2_block:
0152   0505             ;; printf("\033["); 
0153   0505 26 C6 13      mov b, __s13 ; "\033["
0154   0508 FD AB         swp b
0155   050A D8            push b
0156   050B 07 A0 08      call printf
0157   050E 51 02 00      add sp, 2
0158   0511             ;; printu(fg); 
0159   0511 FA FF FF      lea d, [bp + -1] ; $fg
0160   0514 2A            mov b, [d]
0161   0515 FD AB         swp b
0162   0517 D8            push b
0163   0518 07 A6 0D      call printu
0164   051B 51 02 00      add sp, 2
0165   051E             ;; printf("m\033["); 
0166   051E 26 C9 13      mov b, __s14 ; "m\033["
0167   0521 FD AB         swp b
0168   0523 D8            push b
0169   0524 07 A0 08      call printf
0170   0527 51 02 00      add sp, 2
0171   052A             ;; printu(bg); 
0172   052A FA FD FF      lea d, [bp + -3] ; $bg
0173   052D 2A            mov b, [d]
0174   052E FD AB         swp b
0175   0530 D8            push b
0176   0531 07 A6 0D      call printu
0177   0534 51 02 00      add sp, 2
0178   0537             ;; printf("m "); 
0179   0537 26 CD 13      mov b, __s15 ; "m "
0180   053A FD AB         swp b
0181   053C D8            push b
0182   053D 07 A0 08      call printf
0183   0540 51 02 00      add sp, 2
0184   0543             ;; printu(fg); 
0185   0543 FA FF FF      lea d, [bp + -1] ; $fg
0186   0546 2A            mov b, [d]
0187   0547 FD AB         swp b
0188   0549 D8            push b
0189   054A 07 A6 0D      call printu
0190   054D 51 02 00      add sp, 2
0191   0550             ;; printf("/"); 
0192   0550 26 D0 13      mov b, __s16 ; "/"
0193   0553 FD AB         swp b
0194   0555 D8            push b
0195   0556 07 A0 08      call printf
0196   0559 51 02 00      add sp, 2
0197   055C             ;; printu(bg); 
0198   055C FA FD FF      lea d, [bp + -3] ; $bg
0199   055F 2A            mov b, [d]
0200   0560 FD AB         swp b
0201   0562 D8            push b
0202   0563 07 A6 0D      call printu
0203   0566 51 02 00      add sp, 2
0204   0569             ;; printf(" "); 
0205   0569 26 D2 13      mov b, __s17 ; " "
0206   056C FD AB         swp b
0207   056E D8            push b
0208   056F 07 A0 08      call printf
0209   0572 51 02 00      add sp, 2
0210   0575             _for2_update:
0211   0575 FA FF FF      lea d, [bp + -1] ; $fg
0212   0578 2A            mov b, [d]
0213   0579 FD 77         inc b
0214   057B FA FF FF      lea d, [bp + -1] ; $fg
0215   057E FD 43         mov [d], b
0216   0580 0A F2 04      jmp _for2_cond
0217   0583             _for2_exit:
0218   0583             ;; printf("\033[0m\n"); 
0219   0583 26 73 13      mov b, __s4 ; "\033[0m\n"
0220   0586 FD AB         swp b
0221   0588 D8            push b
0222   0589 07 A0 08      call printf
0223   058C 51 02 00      add sp, 2
0224   058F             _for1_update:
0225   058F FA FD FF      lea d, [bp + -3] ; $bg
0226   0592 2A            mov b, [d]
0227   0593 FD 77         inc b
0228   0595 FA FD FF      lea d, [bp + -3] ; $bg
0229   0598 FD 43         mov [d], b
0230   059A 0A D5 04      jmp _for1_cond
0231   059D             _for1_exit:
0232   059D             ;; printf("256-Color Chart:\n"); 
0233   059D 26 D4 13      mov b, __s18 ; "256-Color Chart:\n"
0234   05A0 FD AB         swp b
0235   05A2 D8            push b
0236   05A3 07 A0 08      call printf
0237   05A6 51 02 00      add sp, 2
0238   05A9             ;; for (color = 0; color < 256; ++color) { 
0239   05A9             _for3_init:
0240   05A9 FA FB FF      lea d, [bp + -5] ; $color
0241   05AC DA            push d
0242   05AD 26 00 00      mov b, $0
0243   05B0 E7            pop d
0244   05B1 FD 43         mov [d], b
0245   05B3             _for3_cond:
0246   05B3 FA FB FF      lea d, [bp + -5] ; $color
0247   05B6 2A            mov b, [d]
0248   05B7             ; START RELATIONAL
0249   05B7 D7            push a
0250   05B8 11            mov a, b
0251   05B9 26 00 01      mov b, $100
0252   05BC B0            cmp a, b
0253   05BD FD 73         slt ; < 
0254   05BF E4            pop a
0255   05C0             ; END RELATIONAL
0256   05C0 C0 00 00      cmp b, 0
0257   05C3 C6 45 06      je _for3_exit
0258   05C6             _for3_block:
0259   05C6             ;; printf("\033[48;5;"); 
0260   05C6 26 E6 13      mov b, __s19 ; "\033[48;5;"
0261   05C9 FD AB         swp b
0262   05CB D8            push b
0263   05CC 07 A0 08      call printf
0264   05CF 51 02 00      add sp, 2
0265   05D2             ;; printu(color); 
0266   05D2 FA FB FF      lea d, [bp + -5] ; $color
0267   05D5 2A            mov b, [d]
0268   05D6 FD AB         swp b
0269   05D8 D8            push b
0270   05D9 07 A6 0D      call printu
0271   05DC 51 02 00      add sp, 2
0272   05DF             ;; printf("m  "); 
0273   05DF 26 EE 13      mov b, __s20 ; "m  "
0274   05E2 FD AB         swp b
0275   05E4 D8            push b
0276   05E5 07 A0 08      call printf
0277   05E8 51 02 00      add sp, 2
0278   05EB             ;; printu(color); 
0279   05EB FA FB FF      lea d, [bp + -5] ; $color
0280   05EE 2A            mov b, [d]
0281   05EF FD AB         swp b
0282   05F1 D8            push b
0283   05F2 07 A6 0D      call printu
0284   05F5 51 02 00      add sp, 2
0285   05F8             ;; printf(" \033[0m"); 
0286   05F8 26 F2 13      mov b, __s21 ; " \033[0m"
0287   05FB FD AB         swp b
0288   05FD D8            push b
0289   05FE 07 A0 08      call printf
0290   0601 51 02 00      add sp, 2
0291   0604             ;; if ((color + 1) % 16 == 0) { 
0292   0604             _if4_cond:
0293   0604 FA FB FF      lea d, [bp + -5] ; $color
0294   0607 2A            mov b, [d]
0295   0608             ; START TERMS
0296   0608 D7            push a
0297   0609 11            mov a, b
0298   060A 26 01 00      mov b, $1
0299   060D 54            add a, b
0300   060E 27            mov b, a
0301   060F E4            pop a
0302   0610             ; END TERMS
0303   0610             ; START FACTORS
0304   0610 D7            push a
0305   0611 11            mov a, b
0306   0612 26 10 00      mov b, $10
0307   0615 AE            div a, b ; 
0308   0616 11            mov a, b
0309   0617 27            mov b, a
0310   0618 E4            pop a
0311   0619             ; END FACTORS
0312   0619             ; START RELATIONAL
0313   0619 D7            push a
0314   061A 11            mov a, b
0315   061B 26 00 00      mov b, $0
0316   061E B0            cmp a, b
0317   061F FD 71         seq ; ==
0318   0621 E4            pop a
0319   0622             ; END RELATIONAL
0320   0622 C0 00 00      cmp b, 0
0321   0625 C6 37 06      je _if4_exit
0322   0628             _if4_true:
0323   0628             ;; printf("\n"); 
0324   0628 26 F8 13      mov b, __s22 ; "\n"
0325   062B FD AB         swp b
0326   062D D8            push b
0327   062E 07 A0 08      call printf
0328   0631 51 02 00      add sp, 2
0329   0634 0A 37 06      jmp _if4_exit
0330   0637             _if4_exit:
0331   0637             _for3_update:
0332   0637 FA FB FF      lea d, [bp + -5] ; $color
0333   063A 2A            mov b, [d]
0334   063B FD 77         inc b
0335   063D FA FB FF      lea d, [bp + -5] ; $color
0336   0640 FD 43         mov [d], b
0337   0642 0A B3 05      jmp _for3_cond
0338   0645             _for3_exit:
0339   0645             ;; return 0; 
0340   0645 26 00 00      mov b, $0
0341   0648 F9            leave
0342   0649 05 0B         syscall sys_terminate_proc
0343   064B             
0344   064B             strcpy:
0345   064B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0346   064E             ; $psrc 
0347   064E             ; $pdest 
0348   064E 52 04 00      sub sp, 4
0349   0651             ;; psrc = src; 
0350   0651 FA FF FF      lea d, [bp + -1] ; $psrc
0351   0654 DA            push d
0352   0655 FA 05 00      lea d, [bp + 5] ; $src
0353   0658 2A            mov b, [d]
0354   0659 E7            pop d
0355   065A FD 43         mov [d], b
0356   065C             ;; pdest = dest; 
0357   065C FA FD FF      lea d, [bp + -3] ; $pdest
0358   065F DA            push d
0359   0660 FA 07 00      lea d, [bp + 7] ; $dest
0360   0663 2A            mov b, [d]
0361   0664 E7            pop d
0362   0665 FD 43         mov [d], b
0363   0667             ;; while(*psrc) *pdest++ = *psrc++; 
0364   0667             _while5_cond:
0365   0667 FA FF FF      lea d, [bp + -1] ; $psrc
0366   066A 2A            mov b, [d]
0367   066B 74            mov d, b
0368   066C 32            mov bl, [d]
0369   066D A7 00         mov bh, 0
0370   066F C0 00 00      cmp b, 0
0371   0672 C6 9E 06      je _while5_exit
0372   0675             _while5_block:
0373   0675             ;; *pdest++ = *psrc++; 
0374   0675 FA FD FF      lea d, [bp + -3] ; $pdest
0375   0678 2A            mov b, [d]
0376   0679 FD 79         mov g, b
0377   067B FD 77         inc b
0378   067D FA FD FF      lea d, [bp + -3] ; $pdest
0379   0680 FD 43         mov [d], b
0380   0682 FD 27         mov b, g
0381   0684 D8            push b
0382   0685 FA FF FF      lea d, [bp + -1] ; $psrc
0383   0688 2A            mov b, [d]
0384   0689 FD 79         mov g, b
0385   068B FD 77         inc b
0386   068D FA FF FF      lea d, [bp + -1] ; $psrc
0387   0690 FD 43         mov [d], b
0388   0692 FD 27         mov b, g
0389   0694 74            mov d, b
0390   0695 32            mov bl, [d]
0391   0696 A7 00         mov bh, 0
0392   0698 E7            pop d
0393   0699 FD 3E         mov [d], bl
0394   069B 0A 67 06      jmp _while5_cond
0395   069E             _while5_exit:
0396   069E             ;; *pdest = '\0'; 
0397   069E FA FD FF      lea d, [bp + -3] ; $pdest
0398   06A1 2A            mov b, [d]
0399   06A2 D8            push b
0400   06A3 26 00 00      mov b, $0
0401   06A6 E7            pop d
0402   06A7 FD 3E         mov [d], bl
0403   06A9 F9            leave
0404   06AA 09            ret
0405   06AB             
0406   06AB             strcmp:
0407   06AB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0408   06AE             ;; while (*s1 && (*s1 == *s2)) { 
0409   06AE             _while6_cond:
0410   06AE FA 07 00      lea d, [bp + 7] ; $s1
0411   06B1 2A            mov b, [d]
0412   06B2 74            mov d, b
0413   06B3 32            mov bl, [d]
0414   06B4 A7 00         mov bh, 0
0415   06B6 D7            push a
0416   06B7 11            mov a, b
0417   06B8 FA 07 00      lea d, [bp + 7] ; $s1
0418   06BB 2A            mov b, [d]
0419   06BC 74            mov d, b
0420   06BD 32            mov bl, [d]
0421   06BE A7 00         mov bh, 0
0422   06C0             ; START RELATIONAL
0423   06C0 D7            push a
0424   06C1 11            mov a, b
0425   06C2 FA 05 00      lea d, [bp + 5] ; $s2
0426   06C5 2A            mov b, [d]
0427   06C6 74            mov d, b
0428   06C7 32            mov bl, [d]
0429   06C8 A7 00         mov bh, 0
0430   06CA B0            cmp a, b
0431   06CB FD 71         seq ; ==
0432   06CD E4            pop a
0433   06CE             ; END RELATIONAL
0434   06CE FD A7         sand a, b ; &&
0435   06D0 E4            pop a
0436   06D1 C0 00 00      cmp b, 0
0437   06D4 C6 F8 06      je _while6_exit
0438   06D7             _while6_block:
0439   06D7             ;; s1++; 
0440   06D7 FA 07 00      lea d, [bp + 7] ; $s1
0441   06DA 2A            mov b, [d]
0442   06DB FD 79         mov g, b
0443   06DD FD 77         inc b
0444   06DF FA 07 00      lea d, [bp + 7] ; $s1
0445   06E2 FD 43         mov [d], b
0446   06E4 FD 27         mov b, g
0447   06E6             ;; s2++; 
0448   06E6 FA 05 00      lea d, [bp + 5] ; $s2
0449   06E9 2A            mov b, [d]
0450   06EA FD 79         mov g, b
0451   06EC FD 77         inc b
0452   06EE FA 05 00      lea d, [bp + 5] ; $s2
0453   06F1 FD 43         mov [d], b
0454   06F3 FD 27         mov b, g
0455   06F5 0A AE 06      jmp _while6_cond
0456   06F8             _while6_exit:
0457   06F8             ;; return *s1 - *s2; 
0458   06F8 FA 07 00      lea d, [bp + 7] ; $s1
0459   06FB 2A            mov b, [d]
0460   06FC 74            mov d, b
0461   06FD 32            mov bl, [d]
0462   06FE A7 00         mov bh, 0
0463   0700             ; START TERMS
0464   0700 D7            push a
0465   0701 11            mov a, b
0466   0702 FA 05 00      lea d, [bp + 5] ; $s2
0467   0705 2A            mov b, [d]
0468   0706 74            mov d, b
0469   0707 32            mov bl, [d]
0470   0708 A7 00         mov bh, 0
0471   070A 60            sub a, b
0472   070B 27            mov b, a
0473   070C E4            pop a
0474   070D             ; END TERMS
0475   070D F9            leave
0476   070E 09            ret
0477   070F             
0478   070F             strcat:
0479   070F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0480   0712             ; $dest_len 
0481   0712             ; $i 
0482   0712 52 04 00      sub sp, 4
0483   0715             ;; dest_len = strlen(dest); 
0484   0715 FA FF FF      lea d, [bp + -1] ; $dest_len
0485   0718 DA            push d
0486   0719 FA 07 00      lea d, [bp + 7] ; $dest
0487   071C 2A            mov b, [d]
0488   071D FD AB         swp b
0489   071F D8            push b
0490   0720 07 C5 07      call strlen
0491   0723 51 02 00      add sp, 2
0492   0726 E7            pop d
0493   0727 FD 43         mov [d], b
0494   0729             ;; for (i = 0; src[i] != 0; i=i+1) { 
0495   0729             _for7_init:
0496   0729 FA FD FF      lea d, [bp + -3] ; $i
0497   072C DA            push d
0498   072D 26 00 00      mov b, $0
0499   0730 E7            pop d
0500   0731 FD 43         mov [d], b
0501   0733             _for7_cond:
0502   0733 FA 05 00      lea d, [bp + 5] ; $src
0503   0736 FD 2A         mov d, [d]
0504   0738 D7            push a
0505   0739 DA            push d
0506   073A FA FD FF      lea d, [bp + -3] ; $i
0507   073D 2A            mov b, [d]
0508   073E E7            pop d
0509   073F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0510   0743 E4            pop a
0511   0744 32            mov bl, [d]
0512   0745 A7 00         mov bh, 0
0513   0747             ; START RELATIONAL
0514   0747 D7            push a
0515   0748 11            mov a, b
0516   0749 26 00 00      mov b, $0
0517   074C B0            cmp a, b
0518   074D FD 72         sneq ; !=
0519   074F E4            pop a
0520   0750             ; END RELATIONAL
0521   0750 C0 00 00      cmp b, 0
0522   0753 C6 9E 07      je _for7_exit
0523   0756             _for7_block:
0524   0756             ;; dest[dest_len + i] = src[i]; 
0525   0756 FA 07 00      lea d, [bp + 7] ; $dest
0526   0759 FD 2A         mov d, [d]
0527   075B D7            push a
0528   075C DA            push d
0529   075D FA FF FF      lea d, [bp + -1] ; $dest_len
0530   0760 2A            mov b, [d]
0531   0761             ; START TERMS
0532   0761 D7            push a
0533   0762 11            mov a, b
0534   0763 FA FD FF      lea d, [bp + -3] ; $i
0535   0766 2A            mov b, [d]
0536   0767 54            add a, b
0537   0768 27            mov b, a
0538   0769 E4            pop a
0539   076A             ; END TERMS
0540   076A E7            pop d
0541   076B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0542   076F E4            pop a
0543   0770 DA            push d
0544   0771 FA 05 00      lea d, [bp + 5] ; $src
0545   0774 FD 2A         mov d, [d]
0546   0776 D7            push a
0547   0777 DA            push d
0548   0778 FA FD FF      lea d, [bp + -3] ; $i
0549   077B 2A            mov b, [d]
0550   077C E7            pop d
0551   077D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0552   0781 E4            pop a
0553   0782 32            mov bl, [d]
0554   0783 A7 00         mov bh, 0
0555   0785 E7            pop d
0556   0786 FD 3E         mov [d], bl
0557   0788             _for7_update:
0558   0788 FA FD FF      lea d, [bp + -3] ; $i
0559   078B DA            push d
0560   078C FA FD FF      lea d, [bp + -3] ; $i
0561   078F 2A            mov b, [d]
0562   0790             ; START TERMS
0563   0790 D7            push a
0564   0791 11            mov a, b
0565   0792 26 01 00      mov b, $1
0566   0795 54            add a, b
0567   0796 27            mov b, a
0568   0797 E4            pop a
0569   0798             ; END TERMS
0570   0798 E7            pop d
0571   0799 FD 43         mov [d], b
0572   079B 0A 33 07      jmp _for7_cond
0573   079E             _for7_exit:
0574   079E             ;; dest[dest_len + i] = 0; 
0575   079E FA 07 00      lea d, [bp + 7] ; $dest
0576   07A1 FD 2A         mov d, [d]
0577   07A3 D7            push a
0578   07A4 DA            push d
0579   07A5 FA FF FF      lea d, [bp + -1] ; $dest_len
0580   07A8 2A            mov b, [d]
0581   07A9             ; START TERMS
0582   07A9 D7            push a
0583   07AA 11            mov a, b
0584   07AB FA FD FF      lea d, [bp + -3] ; $i
0585   07AE 2A            mov b, [d]
0586   07AF 54            add a, b
0587   07B0 27            mov b, a
0588   07B1 E4            pop a
0589   07B2             ; END TERMS
0590   07B2 E7            pop d
0591   07B3 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0592   07B7 E4            pop a
0593   07B8 DA            push d
0594   07B9 26 00 00      mov b, $0
0595   07BC E7            pop d
0596   07BD FD 3E         mov [d], bl
0597   07BF             ;; return dest; 
0598   07BF FA 07 00      lea d, [bp + 7] ; $dest
0599   07C2 2A            mov b, [d]
0600   07C3 F9            leave
0601   07C4 09            ret
0602   07C5             
0603   07C5             strlen:
0604   07C5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0605   07C8             ; $length 
0606   07C8 52 02 00      sub sp, 2
0607   07CB             ;; length = 0; 
0608   07CB FA FF FF      lea d, [bp + -1] ; $length
0609   07CE DA            push d
0610   07CF 26 00 00      mov b, $0
0611   07D2 E7            pop d
0612   07D3 FD 43         mov [d], b
0613   07D5             ;; while (str[length] != 0) { 
0614   07D5             _while8_cond:
0615   07D5 FA 05 00      lea d, [bp + 5] ; $str
0616   07D8 FD 2A         mov d, [d]
0617   07DA D7            push a
0618   07DB DA            push d
0619   07DC FA FF FF      lea d, [bp + -1] ; $length
0620   07DF 2A            mov b, [d]
0621   07E0 E7            pop d
0622   07E1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0623   07E5 E4            pop a
0624   07E6 32            mov bl, [d]
0625   07E7 A7 00         mov bh, 0
0626   07E9             ; START RELATIONAL
0627   07E9 D7            push a
0628   07EA 11            mov a, b
0629   07EB 26 00 00      mov b, $0
0630   07EE B0            cmp a, b
0631   07EF FD 72         sneq ; !=
0632   07F1 E4            pop a
0633   07F2             ; END RELATIONAL
0634   07F2 C0 00 00      cmp b, 0
0635   07F5 C6 0A 08      je _while8_exit
0636   07F8             _while8_block:
0637   07F8             ;; length++; 
0638   07F8 FA FF FF      lea d, [bp + -1] ; $length
0639   07FB 2A            mov b, [d]
0640   07FC FD 79         mov g, b
0641   07FE FD 77         inc b
0642   0800 FA FF FF      lea d, [bp + -1] ; $length
0643   0803 FD 43         mov [d], b
0644   0805 FD 27         mov b, g
0645   0807 0A D5 07      jmp _while8_cond
0646   080A             _while8_exit:
0647   080A             ;; return length; 
0648   080A FA FF FF      lea d, [bp + -1] ; $length
0649   080D 2A            mov b, [d]
0650   080E F9            leave
0651   080F 09            ret
0652   0810             
0653   0810             va_arg:
0654   0810 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0655   0813             ; $val 
0656   0813 52 02 00      sub sp, 2
0657   0816             ;; if(size == 1){ 
0658   0816             _if9_cond:
0659   0816 FA 05 00      lea d, [bp + 5] ; $size
0660   0819 2A            mov b, [d]
0661   081A             ; START RELATIONAL
0662   081A D7            push a
0663   081B 11            mov a, b
0664   081C 26 01 00      mov b, $1
0665   081F B0            cmp a, b
0666   0820 FD 71         seq ; ==
0667   0822 E4            pop a
0668   0823             ; END RELATIONAL
0669   0823 C0 00 00      cmp b, 0
0670   0826 C6 42 08      je _if9_else
0671   0829             _if9_true:
0672   0829             ;; val = *(char*)arg->p; 
0673   0829 FA FF FF      lea d, [bp + -1] ; $val
0674   082C DA            push d
0675   082D FA 07 00      lea d, [bp + 7] ; $arg
0676   0830 FD 2A         mov d, [d]
0677   0832 58 00 00      add d, 0
0678   0835 FD 14         clb
0679   0837 2A            mov b, [d]
0680   0838 74            mov d, b
0681   0839 32            mov bl, [d]
0682   083A A7 00         mov bh, 0
0683   083C E7            pop d
0684   083D FD 43         mov [d], b
0685   083F 0A 78 08      jmp _if9_exit
0686   0842             _if9_else:
0687   0842             ;; if(size == 2){ 
0688   0842             _if10_cond:
0689   0842 FA 05 00      lea d, [bp + 5] ; $size
0690   0845 2A            mov b, [d]
0691   0846             ; START RELATIONAL
0692   0846 D7            push a
0693   0847 11            mov a, b
0694   0848 26 02 00      mov b, $2
0695   084B B0            cmp a, b
0696   084C FD 71         seq ; ==
0697   084E E4            pop a
0698   084F             ; END RELATIONAL
0699   084F C0 00 00      cmp b, 0
0700   0852 C6 6C 08      je _if10_else
0701   0855             _if10_true:
0702   0855             ;; val = *(int*)arg->p; 
0703   0855 FA FF FF      lea d, [bp + -1] ; $val
0704   0858 DA            push d
0705   0859 FA 07 00      lea d, [bp + 7] ; $arg
0706   085C FD 2A         mov d, [d]
0707   085E 58 00 00      add d, 0
0708   0861 FD 14         clb
0709   0863 2A            mov b, [d]
0710   0864 74            mov d, b
0711   0865 2A            mov b, [d]
0712   0866 E7            pop d
0713   0867 FD 43         mov [d], b
0714   0869 0A 78 08      jmp _if10_exit
0715   086C             _if10_else:
0716   086C             ;; print("Unknown type size in va_arg() call. Size needs to be either 1 or 2."); 
0717   086C 26 FA 13      mov b, __s23 ; "Unknown type size in va_arg() call. Size needs to be either 1 or 2."
0718   086F FD AB         swp b
0719   0871 D8            push b
0720   0872 07 DA 0E      call print
0721   0875 51 02 00      add sp, 2
0722   0878             _if10_exit:
0723   0878             _if9_exit:
0724   0878             ;; arg->p = arg->p + size; 
0725   0878 FA 07 00      lea d, [bp + 7] ; $arg
0726   087B FD 2A         mov d, [d]
0727   087D 58 00 00      add d, 0
0728   0880 FD 14         clb
0729   0882 DA            push d
0730   0883 FA 07 00      lea d, [bp + 7] ; $arg
0731   0886 FD 2A         mov d, [d]
0732   0888 58 00 00      add d, 0
0733   088B FD 14         clb
0734   088D 2A            mov b, [d]
0735   088E             ; START TERMS
0736   088E D7            push a
0737   088F 11            mov a, b
0738   0890 FA 05 00      lea d, [bp + 5] ; $size
0739   0893 2A            mov b, [d]
0740   0894 54            add a, b
0741   0895 27            mov b, a
0742   0896 E4            pop a
0743   0897             ; END TERMS
0744   0897 E7            pop d
0745   0898 FD 43         mov [d], b
0746   089A             ;; return val; 
0747   089A FA FF FF      lea d, [bp + -1] ; $val
0748   089D 2A            mov b, [d]
0749   089E F9            leave
0750   089F 09            ret
0751   08A0             
0752   08A0             printf:
0753   08A0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0754   08A3             ; $p 
0755   08A3             ; $fp 
0756   08A3             ; $i 
0757   08A3 52 06 00      sub sp, 6
0758   08A6             ;; fp = format; 
0759   08A6 FA FD FF      lea d, [bp + -3] ; $fp
0760   08A9 DA            push d
0761   08AA FA 05 00      lea d, [bp + 5] ; $format
0762   08AD 2A            mov b, [d]
0763   08AE E7            pop d
0764   08AF FD 43         mov [d], b
0765   08B1             ;; p = &format; 
0766   08B1 FA FF FF      lea d, [bp + -1] ; $p
0767   08B4 DA            push d
0768   08B5 FA 05 00      lea d, [bp + 5] ; $format
0769   08B8 2D            mov b, d
0770   08B9 E7            pop d
0771   08BA FD 43         mov [d], b
0772   08BC             ;; for(;;){ 
0773   08BC             _for11_init:
0774   08BC             _for11_cond:
0775   08BC             _for11_block:
0776   08BC             ;; if(!*fp) break; 
0777   08BC             _if12_cond:
0778   08BC FA FD FF      lea d, [bp + -3] ; $fp
0779   08BF 2A            mov b, [d]
0780   08C0 74            mov d, b
0781   08C1 32            mov bl, [d]
0782   08C2 A7 00         mov bh, 0
0783   08C4 C0 00 00      cmp b, 0
0784   08C7 FD 71         seq ; !
0785   08C9 C0 00 00      cmp b, 0
0786   08CC C6 D5 08      je _if12_exit
0787   08CF             _if12_true:
0788   08CF             ;; break; 
0789   08CF 0A 1F 0A      jmp _for11_exit ; for break
0790   08D2 0A D5 08      jmp _if12_exit
0791   08D5             _if12_exit:
0792   08D5             ;; if(*fp == '%'){ 
0793   08D5             _if13_cond:
0794   08D5 FA FD FF      lea d, [bp + -3] ; $fp
0795   08D8 2A            mov b, [d]
0796   08D9 74            mov d, b
0797   08DA 32            mov bl, [d]
0798   08DB A7 00         mov bh, 0
0799   08DD             ; START RELATIONAL
0800   08DD D7            push a
0801   08DE 11            mov a, b
0802   08DF 26 25 00      mov b, $25
0803   08E2 B0            cmp a, b
0804   08E3 FD 71         seq ; ==
0805   08E5 E4            pop a
0806   08E6             ; END RELATIONAL
0807   08E6 C0 00 00      cmp b, 0
0808   08E9 C6 FE 09      je _if13_else
0809   08EC             _if13_true:
0810   08EC             ;; fp++; 
0811   08EC FA FD FF      lea d, [bp + -3] ; $fp
0812   08EF 2A            mov b, [d]
0813   08F0 FD 79         mov g, b
0814   08F2 FD 77         inc b
0815   08F4 FA FD FF      lea d, [bp + -3] ; $fp
0816   08F7 FD 43         mov [d], b
0817   08F9 FD 27         mov b, g
0818   08FB             ;; switch(*fp){ 
0819   08FB             _switch14_expr:
0820   08FB FA FD FF      lea d, [bp + -3] ; $fp
0821   08FE 2A            mov b, [d]
0822   08FF 74            mov d, b
0823   0900 32            mov bl, [d]
0824   0901 A7 00         mov bh, 0
0825   0903             _switch14_comparisons:
0826   0903 C1 64         cmp bl, $64
0827   0905 C6 27 09      je _switch14_case0
0828   0908 C1 69         cmp bl, $69
0829   090A C6 27 09      je _switch14_case1
0830   090D C1 75         cmp bl, $75
0831   090F C6 4C 09      je _switch14_case2
0832   0912 C1 78         cmp bl, $78
0833   0914 C6 71 09      je _switch14_case3
0834   0917 C1 63         cmp bl, $63
0835   0919 C6 96 09      je _switch14_case4
0836   091C C1 73         cmp bl, $73
0837   091E C6 BB 09      je _switch14_case5
0838   0921 0A E0 09      jmp _switch14_default
0839   0924 0A EC 09      jmp _switch14_exit
0840   0927             _switch14_case0:
0841   0927             _switch14_case1:
0842   0927             ;; p = p - 2; 
0843   0927 FA FF FF      lea d, [bp + -1] ; $p
0844   092A DA            push d
0845   092B FA FF FF      lea d, [bp + -1] ; $p
0846   092E 2A            mov b, [d]
0847   092F             ; START TERMS
0848   092F D7            push a
0849   0930 11            mov a, b
0850   0931 26 02 00      mov b, $2
0851   0934 60            sub a, b
0852   0935 27            mov b, a
0853   0936 E4            pop a
0854   0937             ; END TERMS
0855   0937 E7            pop d
0856   0938 FD 43         mov [d], b
0857   093A             ;; prints(*(int*)p); 
0858   093A FA FF FF      lea d, [bp + -1] ; $p
0859   093D 2A            mov b, [d]
0860   093E 74            mov d, b
0861   093F 2A            mov b, [d]
0862   0940 FD AB         swp b
0863   0942 D8            push b
0864   0943 07 B1 0C      call prints
0865   0946 51 02 00      add sp, 2
0866   0949             ;; break; 
0867   0949 0A EC 09      jmp _switch14_exit ; case break
0868   094C             _switch14_case2:
0869   094C             ;; p = p - 2; 
0870   094C FA FF FF      lea d, [bp + -1] ; $p
0871   094F DA            push d
0872   0950 FA FF FF      lea d, [bp + -1] ; $p
0873   0953 2A            mov b, [d]
0874   0954             ; START TERMS
0875   0954 D7            push a
0876   0955 11            mov a, b
0877   0956 26 02 00      mov b, $2
0878   0959 60            sub a, b
0879   095A 27            mov b, a
0880   095B E4            pop a
0881   095C             ; END TERMS
0882   095C E7            pop d
0883   095D FD 43         mov [d], b
0884   095F             ;; printu(*(unsigned int*)p); 
0885   095F FA FF FF      lea d, [bp + -1] ; $p
0886   0962 2A            mov b, [d]
0887   0963 74            mov d, b
0888   0964 2A            mov b, [d]
0889   0965 FD AB         swp b
0890   0967 D8            push b
0891   0968 07 A6 0D      call printu
0892   096B 51 02 00      add sp, 2
0893   096E             ;; break; 
0894   096E 0A EC 09      jmp _switch14_exit ; case break
0895   0971             _switch14_case3:
0896   0971             ;; p = p - 2; 
0897   0971 FA FF FF      lea d, [bp + -1] ; $p
0898   0974 DA            push d
0899   0975 FA FF FF      lea d, [bp + -1] ; $p
0900   0978 2A            mov b, [d]
0901   0979             ; START TERMS
0902   0979 D7            push a
0903   097A 11            mov a, b
0904   097B 26 02 00      mov b, $2
0905   097E 60            sub a, b
0906   097F 27            mov b, a
0907   0980 E4            pop a
0908   0981             ; END TERMS
0909   0981 E7            pop d
0910   0982 FD 43         mov [d], b
0911   0984             ;; printx16(*(unsigned int*)p); 
0912   0984 FA FF FF      lea d, [bp + -1] ; $p
0913   0987 2A            mov b, [d]
0914   0988 74            mov d, b
0915   0989 2A            mov b, [d]
0916   098A FD AB         swp b
0917   098C D8            push b
0918   098D 07 21 0A      call printx16
0919   0990 51 02 00      add sp, 2
0920   0993             ;; break; 
0921   0993 0A EC 09      jmp _switch14_exit ; case break
0922   0996             _switch14_case4:
0923   0996             ;; p = p - 2; 
0924   0996 FA FF FF      lea d, [bp + -1] ; $p
0925   0999 DA            push d
0926   099A FA FF FF      lea d, [bp + -1] ; $p
0927   099D 2A            mov b, [d]
0928   099E             ; START TERMS
0929   099E D7            push a
0930   099F 11            mov a, b
0931   09A0 26 02 00      mov b, $2
0932   09A3 60            sub a, b
0933   09A4 27            mov b, a
0934   09A5 E4            pop a
0935   09A6             ; END TERMS
0936   09A6 E7            pop d
0937   09A7 FD 43         mov [d], b
0938   09A9             ;; putchar(*(char*)p); 
0939   09A9 FA FF FF      lea d, [bp + -1] ; $p
0940   09AC 2A            mov b, [d]
0941   09AD 74            mov d, b
0942   09AE 32            mov bl, [d]
0943   09AF A7 00         mov bh, 0
0944   09B1 DD            push bl
0945   09B2 07 92 0E      call putchar
0946   09B5 51 01 00      add sp, 1
0947   09B8             ;; break; 
0948   09B8 0A EC 09      jmp _switch14_exit ; case break
0949   09BB             _switch14_case5:
0950   09BB             ;; p = p - 2; 
0951   09BB FA FF FF      lea d, [bp + -1] ; $p
0952   09BE DA            push d
0953   09BF FA FF FF      lea d, [bp + -1] ; $p
0954   09C2 2A            mov b, [d]
0955   09C3             ; START TERMS
0956   09C3 D7            push a
0957   09C4 11            mov a, b
0958   09C5 26 02 00      mov b, $2
0959   09C8 60            sub a, b
0960   09C9 27            mov b, a
0961   09CA E4            pop a
0962   09CB             ; END TERMS
0963   09CB E7            pop d
0964   09CC FD 43         mov [d], b
0965   09CE             ;; print(*(char**)p); 
0966   09CE FA FF FF      lea d, [bp + -1] ; $p
0967   09D1 2A            mov b, [d]
0968   09D2 74            mov d, b
0969   09D3 2A            mov b, [d]
0970   09D4 FD AB         swp b
0971   09D6 D8            push b
0972   09D7 07 DA 0E      call print
0973   09DA 51 02 00      add sp, 2
0974   09DD             ;; break; 
0975   09DD 0A EC 09      jmp _switch14_exit ; case break
0976   09E0             _switch14_default:
0977   09E0             ;; print("Error: Unknown argument type.\n"); 
0978   09E0 26 3E 14      mov b, __s24 ; "Error: Unknown argument type.\n"
0979   09E3 FD AB         swp b
0980   09E5 D8            push b
0981   09E6 07 DA 0E      call print
0982   09E9 51 02 00      add sp, 2
0983   09EC             _switch14_exit:
0984   09EC             ;; fp++; 
0985   09EC FA FD FF      lea d, [bp + -3] ; $fp
0986   09EF 2A            mov b, [d]
0987   09F0 FD 79         mov g, b
0988   09F2 FD 77         inc b
0989   09F4 FA FD FF      lea d, [bp + -3] ; $fp
0990   09F7 FD 43         mov [d], b
0991   09F9 FD 27         mov b, g
0992   09FB 0A 1C 0A      jmp _if13_exit
0993   09FE             _if13_else:
0994   09FE             ;; putchar(*fp); 
0995   09FE FA FD FF      lea d, [bp + -3] ; $fp
0996   0A01 2A            mov b, [d]
0997   0A02 74            mov d, b
0998   0A03 32            mov bl, [d]
0999   0A04 A7 00         mov bh, 0
1000   0A06 DD            push bl
1001   0A07 07 92 0E      call putchar
1002   0A0A 51 01 00      add sp, 1
1003   0A0D             ;; fp++; 
1004   0A0D FA FD FF      lea d, [bp + -3] ; $fp
1005   0A10 2A            mov b, [d]
1006   0A11 FD 79         mov g, b
1007   0A13 FD 77         inc b
1008   0A15 FA FD FF      lea d, [bp + -3] ; $fp
1009   0A18 FD 43         mov [d], b
1010   0A1A FD 27         mov b, g
1011   0A1C             _if13_exit:
1012   0A1C             _for11_update:
1013   0A1C 0A BC 08      jmp _for11_cond
1014   0A1F             _for11_exit:
1015   0A1F F9            leave
1016   0A20 09            ret
1017   0A21             
1018   0A21             printx16:
1019   0A21 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1020   0A24             
1021   0A24             ; --- BEGIN INLINE ASM BLOCK
1022   0A24 FA 05 00      lea d, [bp + 5] ; $hex
1023   0A27 2A            mov b, [d]
1024   0A28 07 5B 12      call print_u16x
1025   0A2B             ; --- END INLINE ASM BLOCK
1026   0A2B             
1027   0A2B F9            leave
1028   0A2C 09            ret
1029   0A2D             
1030   0A2D             printx8:
1031   0A2D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1032   0A30             
1033   0A30             ; --- BEGIN INLINE ASM BLOCK
1034   0A30 FA 05 00      lea d, [bp + 5] ; $hex
1035   0A33 32            mov bl, [d]
1036   0A34 07 9F 12      call print_u8x
1037   0A37             ; --- END INLINE ASM BLOCK
1038   0A37             
1039   0A37 F9            leave
1040   0A38 09            ret
1041   0A39             
1042   0A39             hex_to_int:
1043   0A39 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1044   0A3C             ; $value 
1045   0A3C 10 00 00      mov a, $0
1046   0A3F 45 FF FF      mov [bp + -1], a
1047   0A42             ; $i 
1048   0A42             ; $hex_char 
1049   0A42             ; $len 
1050   0A42 52 07 00      sub sp, 7
1051   0A45             ;; len = strlen(hex_string); 
1052   0A45 FA FA FF      lea d, [bp + -6] ; $len
1053   0A48 DA            push d
1054   0A49 FA 05 00      lea d, [bp + 5] ; $hex_string
1055   0A4C 2A            mov b, [d]
1056   0A4D FD AB         swp b
1057   0A4F D8            push b
1058   0A50 07 C5 07      call strlen
1059   0A53 51 02 00      add sp, 2
1060   0A56 E7            pop d
1061   0A57 FD 43         mov [d], b
1062   0A59             ;; for (i = 0; i < len; i++) { 
1063   0A59             _for15_init:
1064   0A59 FA FD FF      lea d, [bp + -3] ; $i
1065   0A5C DA            push d
1066   0A5D 26 00 00      mov b, $0
1067   0A60 E7            pop d
1068   0A61 FD 43         mov [d], b
1069   0A63             _for15_cond:
1070   0A63 FA FD FF      lea d, [bp + -3] ; $i
1071   0A66 2A            mov b, [d]
1072   0A67             ; START RELATIONAL
1073   0A67 D7            push a
1074   0A68 11            mov a, b
1075   0A69 FA FA FF      lea d, [bp + -6] ; $len
1076   0A6C 2A            mov b, [d]
1077   0A6D B0            cmp a, b
1078   0A6E FD 73         slt ; < 
1079   0A70 E4            pop a
1080   0A71             ; END RELATIONAL
1081   0A71 C0 00 00      cmp b, 0
1082   0A74 C6 79 0B      je _for15_exit
1083   0A77             _for15_block:
1084   0A77             ;; hex_char = hex_string[i]; 
1085   0A77 FA FC FF      lea d, [bp + -4] ; $hex_char
1086   0A7A DA            push d
1087   0A7B FA 05 00      lea d, [bp + 5] ; $hex_string
1088   0A7E FD 2A         mov d, [d]
1089   0A80 D7            push a
1090   0A81 DA            push d
1091   0A82 FA FD FF      lea d, [bp + -3] ; $i
1092   0A85 2A            mov b, [d]
1093   0A86 E7            pop d
1094   0A87 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1095   0A8B E4            pop a
1096   0A8C 32            mov bl, [d]
1097   0A8D A7 00         mov bh, 0
1098   0A8F E7            pop d
1099   0A90 FD 3E         mov [d], bl
1100   0A92             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1101   0A92             _if16_cond:
1102   0A92 FA FC FF      lea d, [bp + -4] ; $hex_char
1103   0A95 32            mov bl, [d]
1104   0A96 A7 00         mov bh, 0
1105   0A98             ; START RELATIONAL
1106   0A98 D7            push a
1107   0A99 11            mov a, b
1108   0A9A 26 61 00      mov b, $61
1109   0A9D B0            cmp a, b
1110   0A9E FD 80         sge ; >=
1111   0AA0 E4            pop a
1112   0AA1             ; END RELATIONAL
1113   0AA1 D7            push a
1114   0AA2 11            mov a, b
1115   0AA3 FA FC FF      lea d, [bp + -4] ; $hex_char
1116   0AA6 32            mov bl, [d]
1117   0AA7 A7 00         mov bh, 0
1118   0AA9             ; START RELATIONAL
1119   0AA9 D7            push a
1120   0AAA 11            mov a, b
1121   0AAB 26 66 00      mov b, $66
1122   0AAE B0            cmp a, b
1123   0AAF FD 74         sle ; <=
1124   0AB1 E4            pop a
1125   0AB2             ; END RELATIONAL
1126   0AB2 FD A7         sand a, b ; &&
1127   0AB4 E4            pop a
1128   0AB5 C0 00 00      cmp b, 0
1129   0AB8 C6 E9 0A      je _if16_else
1130   0ABB             _if16_true:
1131   0ABB             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1132   0ABB FA FF FF      lea d, [bp + -1] ; $value
1133   0ABE DA            push d
1134   0ABF FA FF FF      lea d, [bp + -1] ; $value
1135   0AC2 2A            mov b, [d]
1136   0AC3             ; START FACTORS
1137   0AC3 D7            push a
1138   0AC4 11            mov a, b
1139   0AC5 26 10 00      mov b, $10
1140   0AC8 AC            mul a, b ; *
1141   0AC9 11            mov a, b
1142   0ACA 27            mov b, a
1143   0ACB E4            pop a
1144   0ACC             ; END FACTORS
1145   0ACC             ; START TERMS
1146   0ACC D7            push a
1147   0ACD 11            mov a, b
1148   0ACE FA FC FF      lea d, [bp + -4] ; $hex_char
1149   0AD1 32            mov bl, [d]
1150   0AD2 A7 00         mov bh, 0
1151   0AD4             ; START TERMS
1152   0AD4 D7            push a
1153   0AD5 11            mov a, b
1154   0AD6 26 61 00      mov b, $61
1155   0AD9 60            sub a, b
1156   0ADA 26 0A 00      mov b, $a
1157   0ADD 54            add a, b
1158   0ADE 27            mov b, a
1159   0ADF E4            pop a
1160   0AE0             ; END TERMS
1161   0AE0 54            add a, b
1162   0AE1 27            mov b, a
1163   0AE2 E4            pop a
1164   0AE3             ; END TERMS
1165   0AE3 E7            pop d
1166   0AE4 FD 43         mov [d], b
1167   0AE6 0A 67 0B      jmp _if16_exit
1168   0AE9             _if16_else:
1169   0AE9             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1170   0AE9             _if17_cond:
1171   0AE9 FA FC FF      lea d, [bp + -4] ; $hex_char
1172   0AEC 32            mov bl, [d]
1173   0AED A7 00         mov bh, 0
1174   0AEF             ; START RELATIONAL
1175   0AEF D7            push a
1176   0AF0 11            mov a, b
1177   0AF1 26 41 00      mov b, $41
1178   0AF4 B0            cmp a, b
1179   0AF5 FD 80         sge ; >=
1180   0AF7 E4            pop a
1181   0AF8             ; END RELATIONAL
1182   0AF8 D7            push a
1183   0AF9 11            mov a, b
1184   0AFA FA FC FF      lea d, [bp + -4] ; $hex_char
1185   0AFD 32            mov bl, [d]
1186   0AFE A7 00         mov bh, 0
1187   0B00             ; START RELATIONAL
1188   0B00 D7            push a
1189   0B01 11            mov a, b
1190   0B02 26 46 00      mov b, $46
1191   0B05 B0            cmp a, b
1192   0B06 FD 74         sle ; <=
1193   0B08 E4            pop a
1194   0B09             ; END RELATIONAL
1195   0B09 FD A7         sand a, b ; &&
1196   0B0B E4            pop a
1197   0B0C C0 00 00      cmp b, 0
1198   0B0F C6 40 0B      je _if17_else
1199   0B12             _if17_true:
1200   0B12             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1201   0B12 FA FF FF      lea d, [bp + -1] ; $value
1202   0B15 DA            push d
1203   0B16 FA FF FF      lea d, [bp + -1] ; $value
1204   0B19 2A            mov b, [d]
1205   0B1A             ; START FACTORS
1206   0B1A D7            push a
1207   0B1B 11            mov a, b
1208   0B1C 26 10 00      mov b, $10
1209   0B1F AC            mul a, b ; *
1210   0B20 11            mov a, b
1211   0B21 27            mov b, a
1212   0B22 E4            pop a
1213   0B23             ; END FACTORS
1214   0B23             ; START TERMS
1215   0B23 D7            push a
1216   0B24 11            mov a, b
1217   0B25 FA FC FF      lea d, [bp + -4] ; $hex_char
1218   0B28 32            mov bl, [d]
1219   0B29 A7 00         mov bh, 0
1220   0B2B             ; START TERMS
1221   0B2B D7            push a
1222   0B2C 11            mov a, b
1223   0B2D 26 41 00      mov b, $41
1224   0B30 60            sub a, b
1225   0B31 26 0A 00      mov b, $a
1226   0B34 54            add a, b
1227   0B35 27            mov b, a
1228   0B36 E4            pop a
1229   0B37             ; END TERMS
1230   0B37 54            add a, b
1231   0B38 27            mov b, a
1232   0B39 E4            pop a
1233   0B3A             ; END TERMS
1234   0B3A E7            pop d
1235   0B3B FD 43         mov [d], b
1236   0B3D 0A 67 0B      jmp _if17_exit
1237   0B40             _if17_else:
1238   0B40             ;; value = (value * 16) + (hex_char - '0'); 
1239   0B40 FA FF FF      lea d, [bp + -1] ; $value
1240   0B43 DA            push d
1241   0B44 FA FF FF      lea d, [bp + -1] ; $value
1242   0B47 2A            mov b, [d]
1243   0B48             ; START FACTORS
1244   0B48 D7            push a
1245   0B49 11            mov a, b
1246   0B4A 26 10 00      mov b, $10
1247   0B4D AC            mul a, b ; *
1248   0B4E 11            mov a, b
1249   0B4F 27            mov b, a
1250   0B50 E4            pop a
1251   0B51             ; END FACTORS
1252   0B51             ; START TERMS
1253   0B51 D7            push a
1254   0B52 11            mov a, b
1255   0B53 FA FC FF      lea d, [bp + -4] ; $hex_char
1256   0B56 32            mov bl, [d]
1257   0B57 A7 00         mov bh, 0
1258   0B59             ; START TERMS
1259   0B59 D7            push a
1260   0B5A 11            mov a, b
1261   0B5B 26 30 00      mov b, $30
1262   0B5E 60            sub a, b
1263   0B5F 27            mov b, a
1264   0B60 E4            pop a
1265   0B61             ; END TERMS
1266   0B61 54            add a, b
1267   0B62 27            mov b, a
1268   0B63 E4            pop a
1269   0B64             ; END TERMS
1270   0B64 E7            pop d
1271   0B65 FD 43         mov [d], b
1272   0B67             _if17_exit:
1273   0B67             _if16_exit:
1274   0B67             _for15_update:
1275   0B67 FA FD FF      lea d, [bp + -3] ; $i
1276   0B6A 2A            mov b, [d]
1277   0B6B FD 79         mov g, b
1278   0B6D FD 77         inc b
1279   0B6F FA FD FF      lea d, [bp + -3] ; $i
1280   0B72 FD 43         mov [d], b
1281   0B74 FD 27         mov b, g
1282   0B76 0A 63 0A      jmp _for15_cond
1283   0B79             _for15_exit:
1284   0B79             ;; return value; 
1285   0B79 FA FF FF      lea d, [bp + -1] ; $value
1286   0B7C 2A            mov b, [d]
1287   0B7D F9            leave
1288   0B7E 09            ret
1289   0B7F             
1290   0B7F             atoi:
1291   0B7F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1292   0B82             ; $result 
1293   0B82 10 00 00      mov a, $0
1294   0B85 45 FF FF      mov [bp + -1], a
1295   0B88             ; $sign 
1296   0B88 10 01 00      mov a, $1
1297   0B8B 45 FD FF      mov [bp + -3], a
1298   0B8E 52 04 00      sub sp, 4
1299   0B91             ;; while (*str == ' ') str++; 
1300   0B91             _while18_cond:
1301   0B91 FA 05 00      lea d, [bp + 5] ; $str
1302   0B94 2A            mov b, [d]
1303   0B95 74            mov d, b
1304   0B96 32            mov bl, [d]
1305   0B97 A7 00         mov bh, 0
1306   0B99             ; START RELATIONAL
1307   0B99 D7            push a
1308   0B9A 11            mov a, b
1309   0B9B 26 20 00      mov b, $20
1310   0B9E B0            cmp a, b
1311   0B9F FD 71         seq ; ==
1312   0BA1 E4            pop a
1313   0BA2             ; END RELATIONAL
1314   0BA2 C0 00 00      cmp b, 0
1315   0BA5 C6 BA 0B      je _while18_exit
1316   0BA8             _while18_block:
1317   0BA8             ;; str++; 
1318   0BA8 FA 05 00      lea d, [bp + 5] ; $str
1319   0BAB 2A            mov b, [d]
1320   0BAC FD 79         mov g, b
1321   0BAE FD 77         inc b
1322   0BB0 FA 05 00      lea d, [bp + 5] ; $str
1323   0BB3 FD 43         mov [d], b
1324   0BB5 FD 27         mov b, g
1325   0BB7 0A 91 0B      jmp _while18_cond
1326   0BBA             _while18_exit:
1327   0BBA             ;; if (*str == '-' || *str == '+') { 
1328   0BBA             _if19_cond:
1329   0BBA FA 05 00      lea d, [bp + 5] ; $str
1330   0BBD 2A            mov b, [d]
1331   0BBE 74            mov d, b
1332   0BBF 32            mov bl, [d]
1333   0BC0 A7 00         mov bh, 0
1334   0BC2             ; START RELATIONAL
1335   0BC2 D7            push a
1336   0BC3 11            mov a, b
1337   0BC4 26 2D 00      mov b, $2d
1338   0BC7 B0            cmp a, b
1339   0BC8 FD 71         seq ; ==
1340   0BCA E4            pop a
1341   0BCB             ; END RELATIONAL
1342   0BCB D7            push a
1343   0BCC 11            mov a, b
1344   0BCD FA 05 00      lea d, [bp + 5] ; $str
1345   0BD0 2A            mov b, [d]
1346   0BD1 74            mov d, b
1347   0BD2 32            mov bl, [d]
1348   0BD3 A7 00         mov bh, 0
1349   0BD5             ; START RELATIONAL
1350   0BD5 D7            push a
1351   0BD6 11            mov a, b
1352   0BD7 26 2B 00      mov b, $2b
1353   0BDA B0            cmp a, b
1354   0BDB FD 71         seq ; ==
1355   0BDD E4            pop a
1356   0BDE             ; END RELATIONAL
1357   0BDE FD A8         sor a, b ; ||
1358   0BE0 E4            pop a
1359   0BE1 C0 00 00      cmp b, 0
1360   0BE4 C6 1F 0C      je _if19_exit
1361   0BE7             _if19_true:
1362   0BE7             ;; if (*str == '-') sign = -1; 
1363   0BE7             _if20_cond:
1364   0BE7 FA 05 00      lea d, [bp + 5] ; $str
1365   0BEA 2A            mov b, [d]
1366   0BEB 74            mov d, b
1367   0BEC 32            mov bl, [d]
1368   0BED A7 00         mov bh, 0
1369   0BEF             ; START RELATIONAL
1370   0BEF D7            push a
1371   0BF0 11            mov a, b
1372   0BF1 26 2D 00      mov b, $2d
1373   0BF4 B0            cmp a, b
1374   0BF5 FD 71         seq ; ==
1375   0BF7 E4            pop a
1376   0BF8             ; END RELATIONAL
1377   0BF8 C0 00 00      cmp b, 0
1378   0BFB C6 0D 0C      je _if20_exit
1379   0BFE             _if20_true:
1380   0BFE             ;; sign = -1; 
1381   0BFE FA FD FF      lea d, [bp + -3] ; $sign
1382   0C01 DA            push d
1383   0C02 26 01 00      mov b, $1
1384   0C05 FD 97         neg b
1385   0C07 E7            pop d
1386   0C08 FD 43         mov [d], b
1387   0C0A 0A 0D 0C      jmp _if20_exit
1388   0C0D             _if20_exit:
1389   0C0D             ;; str++; 
1390   0C0D FA 05 00      lea d, [bp + 5] ; $str
1391   0C10 2A            mov b, [d]
1392   0C11 FD 79         mov g, b
1393   0C13 FD 77         inc b
1394   0C15 FA 05 00      lea d, [bp + 5] ; $str
1395   0C18 FD 43         mov [d], b
1396   0C1A FD 27         mov b, g
1397   0C1C 0A 1F 0C      jmp _if19_exit
1398   0C1F             _if19_exit:
1399   0C1F             ;; while (*str >= '0' && *str <= '9') { 
1400   0C1F             _while21_cond:
1401   0C1F FA 05 00      lea d, [bp + 5] ; $str
1402   0C22 2A            mov b, [d]
1403   0C23 74            mov d, b
1404   0C24 32            mov bl, [d]
1405   0C25 A7 00         mov bh, 0
1406   0C27             ; START RELATIONAL
1407   0C27 D7            push a
1408   0C28 11            mov a, b
1409   0C29 26 30 00      mov b, $30
1410   0C2C B0            cmp a, b
1411   0C2D FD 80         sge ; >=
1412   0C2F E4            pop a
1413   0C30             ; END RELATIONAL
1414   0C30 D7            push a
1415   0C31 11            mov a, b
1416   0C32 FA 05 00      lea d, [bp + 5] ; $str
1417   0C35 2A            mov b, [d]
1418   0C36 74            mov d, b
1419   0C37 32            mov bl, [d]
1420   0C38 A7 00         mov bh, 0
1421   0C3A             ; START RELATIONAL
1422   0C3A D7            push a
1423   0C3B 11            mov a, b
1424   0C3C 26 39 00      mov b, $39
1425   0C3F B0            cmp a, b
1426   0C40 FD 74         sle ; <=
1427   0C42 E4            pop a
1428   0C43             ; END RELATIONAL
1429   0C43 FD A7         sand a, b ; &&
1430   0C45 E4            pop a
1431   0C46 C0 00 00      cmp b, 0
1432   0C49 C6 87 0C      je _while21_exit
1433   0C4C             _while21_block:
1434   0C4C             ;; result = result * 10 + (*str - '0'); 
1435   0C4C FA FF FF      lea d, [bp + -1] ; $result
1436   0C4F DA            push d
1437   0C50 FA FF FF      lea d, [bp + -1] ; $result
1438   0C53 2A            mov b, [d]
1439   0C54             ; START FACTORS
1440   0C54 D7            push a
1441   0C55 11            mov a, b
1442   0C56 26 0A 00      mov b, $a
1443   0C59 AC            mul a, b ; *
1444   0C5A 11            mov a, b
1445   0C5B 27            mov b, a
1446   0C5C E4            pop a
1447   0C5D             ; END FACTORS
1448   0C5D             ; START TERMS
1449   0C5D D7            push a
1450   0C5E 11            mov a, b
1451   0C5F FA 05 00      lea d, [bp + 5] ; $str
1452   0C62 2A            mov b, [d]
1453   0C63 74            mov d, b
1454   0C64 32            mov bl, [d]
1455   0C65 A7 00         mov bh, 0
1456   0C67             ; START TERMS
1457   0C67 D7            push a
1458   0C68 11            mov a, b
1459   0C69 26 30 00      mov b, $30
1460   0C6C 60            sub a, b
1461   0C6D 27            mov b, a
1462   0C6E E4            pop a
1463   0C6F             ; END TERMS
1464   0C6F 54            add a, b
1465   0C70 27            mov b, a
1466   0C71 E4            pop a
1467   0C72             ; END TERMS
1468   0C72 E7            pop d
1469   0C73 FD 43         mov [d], b
1470   0C75             ;; str++; 
1471   0C75 FA 05 00      lea d, [bp + 5] ; $str
1472   0C78 2A            mov b, [d]
1473   0C79 FD 79         mov g, b
1474   0C7B FD 77         inc b
1475   0C7D FA 05 00      lea d, [bp + 5] ; $str
1476   0C80 FD 43         mov [d], b
1477   0C82 FD 27         mov b, g
1478   0C84 0A 1F 0C      jmp _while21_cond
1479   0C87             _while21_exit:
1480   0C87             ;; return sign * result; 
1481   0C87 FA FD FF      lea d, [bp + -3] ; $sign
1482   0C8A 2A            mov b, [d]
1483   0C8B             ; START FACTORS
1484   0C8B D7            push a
1485   0C8C 11            mov a, b
1486   0C8D FA FF FF      lea d, [bp + -1] ; $result
1487   0C90 2A            mov b, [d]
1488   0C91 AC            mul a, b ; *
1489   0C92 11            mov a, b
1490   0C93 27            mov b, a
1491   0C94 E4            pop a
1492   0C95             ; END FACTORS
1493   0C95 F9            leave
1494   0C96 09            ret
1495   0C97             
1496   0C97             gets:
1497   0C97 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1498   0C9A             
1499   0C9A             ; --- BEGIN INLINE ASM BLOCK
1500   0C9A FA 05 00      lea d, [bp + 5] ; $s
1501   0C9D 15            mov a, [d]
1502   0C9E 3C            mov d, a
1503   0C9F 07 C0 10      call _gets
1504   0CA2             ; --- END INLINE ASM BLOCK
1505   0CA2             
1506   0CA2             ;; return strlen(s); 
1507   0CA2 FA 05 00      lea d, [bp + 5] ; $s
1508   0CA5 2A            mov b, [d]
1509   0CA6 FD AB         swp b
1510   0CA8 D8            push b
1511   0CA9 07 C5 07      call strlen
1512   0CAC 51 02 00      add sp, 2
1513   0CAF F9            leave
1514   0CB0 09            ret
1515   0CB1             
1516   0CB1             prints:
1517   0CB1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1518   0CB4             ; $digits 
1519   0CB4             ; $i 
1520   0CB4 10 00 00      mov a, $0
1521   0CB7 45 FA FF      mov [bp + -6], a
1522   0CBA 52 07 00      sub sp, 7
1523   0CBD             ;; if (num < 0) { 
1524   0CBD             _if22_cond:
1525   0CBD FA 05 00      lea d, [bp + 5] ; $num
1526   0CC0 2A            mov b, [d]
1527   0CC1             ; START RELATIONAL
1528   0CC1 D7            push a
1529   0CC2 11            mov a, b
1530   0CC3 26 00 00      mov b, $0
1531   0CC6 B0            cmp a, b
1532   0CC7 FD 73         slt ; < 
1533   0CC9 E4            pop a
1534   0CCA             ; END RELATIONAL
1535   0CCA C0 00 00      cmp b, 0
1536   0CCD C6 EA 0C      je _if22_else
1537   0CD0             _if22_true:
1538   0CD0             ;; putchar('-'); 
1539   0CD0 26 2D 00      mov b, $2d
1540   0CD3 DD            push bl
1541   0CD4 07 92 0E      call putchar
1542   0CD7 51 01 00      add sp, 1
1543   0CDA             ;; num = -num; 
1544   0CDA FA 05 00      lea d, [bp + 5] ; $num
1545   0CDD DA            push d
1546   0CDE FA 05 00      lea d, [bp + 5] ; $num
1547   0CE1 2A            mov b, [d]
1548   0CE2 FD 97         neg b
1549   0CE4 E7            pop d
1550   0CE5 FD 43         mov [d], b
1551   0CE7 0A 0C 0D      jmp _if22_exit
1552   0CEA             _if22_else:
1553   0CEA             ;; if (num == 0) { 
1554   0CEA             _if23_cond:
1555   0CEA FA 05 00      lea d, [bp + 5] ; $num
1556   0CED 2A            mov b, [d]
1557   0CEE             ; START RELATIONAL
1558   0CEE D7            push a
1559   0CEF 11            mov a, b
1560   0CF0 26 00 00      mov b, $0
1561   0CF3 B0            cmp a, b
1562   0CF4 FD 71         seq ; ==
1563   0CF6 E4            pop a
1564   0CF7             ; END RELATIONAL
1565   0CF7 C0 00 00      cmp b, 0
1566   0CFA C6 0C 0D      je _if23_exit
1567   0CFD             _if23_true:
1568   0CFD             ;; putchar('0'); 
1569   0CFD 26 30 00      mov b, $30
1570   0D00 DD            push bl
1571   0D01 07 92 0E      call putchar
1572   0D04 51 01 00      add sp, 1
1573   0D07             ;; return; 
1574   0D07 F9            leave
1575   0D08 09            ret
1576   0D09 0A 0C 0D      jmp _if23_exit
1577   0D0C             _if23_exit:
1578   0D0C             _if22_exit:
1579   0D0C             ;; while (num > 0) { 
1580   0D0C             _while24_cond:
1581   0D0C FA 05 00      lea d, [bp + 5] ; $num
1582   0D0F 2A            mov b, [d]
1583   0D10             ; START RELATIONAL
1584   0D10 D7            push a
1585   0D11 11            mov a, b
1586   0D12 26 00 00      mov b, $0
1587   0D15 B0            cmp a, b
1588   0D16 FD 7F         sgt ; >
1589   0D18 E4            pop a
1590   0D19             ; END RELATIONAL
1591   0D19 C0 00 00      cmp b, 0
1592   0D1C C6 69 0D      je _while24_exit
1593   0D1F             _while24_block:
1594   0D1F             ;; digits[i] = '0' + (num % 10); 
1595   0D1F FA FC FF      lea d, [bp + -4] ; $digits
1596   0D22 D7            push a
1597   0D23 DA            push d
1598   0D24 FA FA FF      lea d, [bp + -6] ; $i
1599   0D27 2A            mov b, [d]
1600   0D28 E7            pop d
1601   0D29 5A            add d, b
1602   0D2A E4            pop a
1603   0D2B DA            push d
1604   0D2C 26 30 00      mov b, $30
1605   0D2F             ; START TERMS
1606   0D2F D7            push a
1607   0D30 11            mov a, b
1608   0D31 FA 05 00      lea d, [bp + 5] ; $num
1609   0D34 2A            mov b, [d]
1610   0D35             ; START FACTORS
1611   0D35 D7            push a
1612   0D36 11            mov a, b
1613   0D37 26 0A 00      mov b, $a
1614   0D3A AE            div a, b ; 
1615   0D3B 11            mov a, b
1616   0D3C 27            mov b, a
1617   0D3D E4            pop a
1618   0D3E             ; END FACTORS
1619   0D3E 54            add a, b
1620   0D3F 27            mov b, a
1621   0D40 E4            pop a
1622   0D41             ; END TERMS
1623   0D41 E7            pop d
1624   0D42 FD 3E         mov [d], bl
1625   0D44             ;; num = num / 10; 
1626   0D44 FA 05 00      lea d, [bp + 5] ; $num
1627   0D47 DA            push d
1628   0D48 FA 05 00      lea d, [bp + 5] ; $num
1629   0D4B 2A            mov b, [d]
1630   0D4C             ; START FACTORS
1631   0D4C D7            push a
1632   0D4D 11            mov a, b
1633   0D4E 26 0A 00      mov b, $a
1634   0D51 AE            div a, b
1635   0D52 27            mov b, a
1636   0D53 E4            pop a
1637   0D54             ; END FACTORS
1638   0D54 E7            pop d
1639   0D55 FD 43         mov [d], b
1640   0D57             ;; i++; 
1641   0D57 FA FA FF      lea d, [bp + -6] ; $i
1642   0D5A 2A            mov b, [d]
1643   0D5B FD 79         mov g, b
1644   0D5D FD 77         inc b
1645   0D5F FA FA FF      lea d, [bp + -6] ; $i
1646   0D62 FD 43         mov [d], b
1647   0D64 FD 27         mov b, g
1648   0D66 0A 0C 0D      jmp _while24_cond
1649   0D69             _while24_exit:
1650   0D69             ;; while (i > 0) { 
1651   0D69             _while25_cond:
1652   0D69 FA FA FF      lea d, [bp + -6] ; $i
1653   0D6C 2A            mov b, [d]
1654   0D6D             ; START RELATIONAL
1655   0D6D D7            push a
1656   0D6E 11            mov a, b
1657   0D6F 26 00 00      mov b, $0
1658   0D72 B0            cmp a, b
1659   0D73 FD 7F         sgt ; >
1660   0D75 E4            pop a
1661   0D76             ; END RELATIONAL
1662   0D76 C0 00 00      cmp b, 0
1663   0D79 C6 A4 0D      je _while25_exit
1664   0D7C             _while25_block:
1665   0D7C             ;; i--; 
1666   0D7C FA FA FF      lea d, [bp + -6] ; $i
1667   0D7F 2A            mov b, [d]
1668   0D80 FD 79         mov g, b
1669   0D82 FD 7D         dec b
1670   0D84 FA FA FF      lea d, [bp + -6] ; $i
1671   0D87 FD 43         mov [d], b
1672   0D89 FD 27         mov b, g
1673   0D8B             ;; putchar(digits[i]); 
1674   0D8B FA FC FF      lea d, [bp + -4] ; $digits
1675   0D8E D7            push a
1676   0D8F DA            push d
1677   0D90 FA FA FF      lea d, [bp + -6] ; $i
1678   0D93 2A            mov b, [d]
1679   0D94 E7            pop d
1680   0D95 5A            add d, b
1681   0D96 E4            pop a
1682   0D97 32            mov bl, [d]
1683   0D98 A7 00         mov bh, 0
1684   0D9A DD            push bl
1685   0D9B 07 92 0E      call putchar
1686   0D9E 51 01 00      add sp, 1
1687   0DA1 0A 69 0D      jmp _while25_cond
1688   0DA4             _while25_exit:
1689   0DA4 F9            leave
1690   0DA5 09            ret
1691   0DA6             
1692   0DA6             printu:
1693   0DA6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1694   0DA9             ; $digits 
1695   0DA9             ; $i 
1696   0DA9 52 07 00      sub sp, 7
1697   0DAC             ;; i = 0; 
1698   0DAC FA FA FF      lea d, [bp + -6] ; $i
1699   0DAF DA            push d
1700   0DB0 26 00 00      mov b, $0
1701   0DB3 E7            pop d
1702   0DB4 FD 43         mov [d], b
1703   0DB6             ;; if(num == 0){ 
1704   0DB6             _if26_cond:
1705   0DB6 FA 05 00      lea d, [bp + 5] ; $num
1706   0DB9 2A            mov b, [d]
1707   0DBA             ; START RELATIONAL
1708   0DBA D7            push a
1709   0DBB 11            mov a, b
1710   0DBC 26 00 00      mov b, $0
1711   0DBF B0            cmp a, b
1712   0DC0 FD 71         seq ; ==
1713   0DC2 E4            pop a
1714   0DC3             ; END RELATIONAL
1715   0DC3 C0 00 00      cmp b, 0
1716   0DC6 C6 D8 0D      je _if26_exit
1717   0DC9             _if26_true:
1718   0DC9             ;; putchar('0'); 
1719   0DC9 26 30 00      mov b, $30
1720   0DCC DD            push bl
1721   0DCD 07 92 0E      call putchar
1722   0DD0 51 01 00      add sp, 1
1723   0DD3             ;; return; 
1724   0DD3 F9            leave
1725   0DD4 09            ret
1726   0DD5 0A D8 0D      jmp _if26_exit
1727   0DD8             _if26_exit:
1728   0DD8             ;; while (num > 0) { 
1729   0DD8             _while27_cond:
1730   0DD8 FA 05 00      lea d, [bp + 5] ; $num
1731   0DDB 2A            mov b, [d]
1732   0DDC             ; START RELATIONAL
1733   0DDC D7            push a
1734   0DDD 11            mov a, b
1735   0DDE 26 00 00      mov b, $0
1736   0DE1 B0            cmp a, b
1737   0DE2 FD 81         sgu ; > (unsigned)
1738   0DE4 E4            pop a
1739   0DE5             ; END RELATIONAL
1740   0DE5 C0 00 00      cmp b, 0
1741   0DE8 C6 35 0E      je _while27_exit
1742   0DEB             _while27_block:
1743   0DEB             ;; digits[i] = '0' + (num % 10); 
1744   0DEB FA FC FF      lea d, [bp + -4] ; $digits
1745   0DEE D7            push a
1746   0DEF DA            push d
1747   0DF0 FA FA FF      lea d, [bp + -6] ; $i
1748   0DF3 2A            mov b, [d]
1749   0DF4 E7            pop d
1750   0DF5 5A            add d, b
1751   0DF6 E4            pop a
1752   0DF7 DA            push d
1753   0DF8 26 30 00      mov b, $30
1754   0DFB             ; START TERMS
1755   0DFB D7            push a
1756   0DFC 11            mov a, b
1757   0DFD FA 05 00      lea d, [bp + 5] ; $num
1758   0E00 2A            mov b, [d]
1759   0E01             ; START FACTORS
1760   0E01 D7            push a
1761   0E02 11            mov a, b
1762   0E03 26 0A 00      mov b, $a
1763   0E06 AE            div a, b ; 
1764   0E07 11            mov a, b
1765   0E08 27            mov b, a
1766   0E09 E4            pop a
1767   0E0A             ; END FACTORS
1768   0E0A 54            add a, b
1769   0E0B 27            mov b, a
1770   0E0C E4            pop a
1771   0E0D             ; END TERMS
1772   0E0D E7            pop d
1773   0E0E FD 3E         mov [d], bl
1774   0E10             ;; num = num / 10; 
1775   0E10 FA 05 00      lea d, [bp + 5] ; $num
1776   0E13 DA            push d
1777   0E14 FA 05 00      lea d, [bp + 5] ; $num
1778   0E17 2A            mov b, [d]
1779   0E18             ; START FACTORS
1780   0E18 D7            push a
1781   0E19 11            mov a, b
1782   0E1A 26 0A 00      mov b, $a
1783   0E1D AE            div a, b
1784   0E1E 27            mov b, a
1785   0E1F E4            pop a
1786   0E20             ; END FACTORS
1787   0E20 E7            pop d
1788   0E21 FD 43         mov [d], b
1789   0E23             ;; i++; 
1790   0E23 FA FA FF      lea d, [bp + -6] ; $i
1791   0E26 2A            mov b, [d]
1792   0E27 FD 79         mov g, b
1793   0E29 FD 77         inc b
1794   0E2B FA FA FF      lea d, [bp + -6] ; $i
1795   0E2E FD 43         mov [d], b
1796   0E30 FD 27         mov b, g
1797   0E32 0A D8 0D      jmp _while27_cond
1798   0E35             _while27_exit:
1799   0E35             ;; while (i > 0) { 
1800   0E35             _while28_cond:
1801   0E35 FA FA FF      lea d, [bp + -6] ; $i
1802   0E38 2A            mov b, [d]
1803   0E39             ; START RELATIONAL
1804   0E39 D7            push a
1805   0E3A 11            mov a, b
1806   0E3B 26 00 00      mov b, $0
1807   0E3E B0            cmp a, b
1808   0E3F FD 7F         sgt ; >
1809   0E41 E4            pop a
1810   0E42             ; END RELATIONAL
1811   0E42 C0 00 00      cmp b, 0
1812   0E45 C6 70 0E      je _while28_exit
1813   0E48             _while28_block:
1814   0E48             ;; i--; 
1815   0E48 FA FA FF      lea d, [bp + -6] ; $i
1816   0E4B 2A            mov b, [d]
1817   0E4C FD 79         mov g, b
1818   0E4E FD 7D         dec b
1819   0E50 FA FA FF      lea d, [bp + -6] ; $i
1820   0E53 FD 43         mov [d], b
1821   0E55 FD 27         mov b, g
1822   0E57             ;; putchar(digits[i]); 
1823   0E57 FA FC FF      lea d, [bp + -4] ; $digits
1824   0E5A D7            push a
1825   0E5B DA            push d
1826   0E5C FA FA FF      lea d, [bp + -6] ; $i
1827   0E5F 2A            mov b, [d]
1828   0E60 E7            pop d
1829   0E61 5A            add d, b
1830   0E62 E4            pop a
1831   0E63 32            mov bl, [d]
1832   0E64 A7 00         mov bh, 0
1833   0E66 DD            push bl
1834   0E67 07 92 0E      call putchar
1835   0E6A 51 01 00      add sp, 1
1836   0E6D 0A 35 0E      jmp _while28_cond
1837   0E70             _while28_exit:
1838   0E70 F9            leave
1839   0E71 09            ret
1840   0E72             
1841   0E72             rand:
1842   0E72 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1843   0E75             ; $sec 
1844   0E75 52 01 00      sub sp, 1
1845   0E78             
1846   0E78             ; --- BEGIN INLINE ASM BLOCK
1847   0E78 19 00         mov al, 0
1848   0E7A 05 01         syscall sys_rtc					
1849   0E7C 1A            mov al, ah
1850   0E7D FA 00 00      lea d, [bp + 0] ; $sec
1851   0E80 1E            mov al, [d]
1852   0E81             ; --- END INLINE ASM BLOCK
1853   0E81             
1854   0E81             ;; return sec; 
1855   0E81 FA 00 00      lea d, [bp + 0] ; $sec
1856   0E84 32            mov bl, [d]
1857   0E85 A7 00         mov bh, 0
1858   0E87 F9            leave
1859   0E88 09            ret
1860   0E89             
1861   0E89             date:
1862   0E89 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1863   0E8C             
1864   0E8C             ; --- BEGIN INLINE ASM BLOCK
1865   0E8C 19 00         mov al, 0 
1866   0E8E 05 07         syscall sys_datetime
1867   0E90             ; --- END INLINE ASM BLOCK
1868   0E90             
1869   0E90 F9            leave
1870   0E91 09            ret
1871   0E92             
1872   0E92             putchar:
1873   0E92 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1874   0E95             
1875   0E95             ; --- BEGIN INLINE ASM BLOCK
1876   0E95 FA 05 00      lea d, [bp + 5] ; $c
1877   0E98 1E            mov al, [d]
1878   0E99 23            mov ah, al
1879   0E9A 07 B9 10      call _putchar
1880   0E9D             ; --- END INLINE ASM BLOCK
1881   0E9D             
1882   0E9D F9            leave
1883   0E9E 09            ret
1884   0E9F             
1885   0E9F             getchar:
1886   0E9F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1887   0EA2             ; $c 
1888   0EA2 52 01 00      sub sp, 1
1889   0EA5             
1890   0EA5             ; --- BEGIN INLINE ASM BLOCK
1891   0EA5 07 B2 10      call getch
1892   0EA8 1A            mov al, ah
1893   0EA9 FA 00 00      lea d, [bp + 0] ; $c
1894   0EAC 3E            mov [d], al
1895   0EAD             ; --- END INLINE ASM BLOCK
1896   0EAD             
1897   0EAD             ;; return c; 
1898   0EAD FA 00 00      lea d, [bp + 0] ; $c
1899   0EB0 32            mov bl, [d]
1900   0EB1 A7 00         mov bh, 0
1901   0EB3 F9            leave
1902   0EB4 09            ret
1903   0EB5             
1904   0EB5             scann:
1905   0EB5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1906   0EB8             ; $m 
1907   0EB8 52 02 00      sub sp, 2
1908   0EBB             
1909   0EBB             ; --- BEGIN INLINE ASM BLOCK
1910   0EBB 07 FD 12      call scan_u16d
1911   0EBE FA FF FF      lea d, [bp + -1] ; $m
1912   0EC1 43            mov [d], a
1913   0EC2             ; --- END INLINE ASM BLOCK
1914   0EC2             
1915   0EC2             ;; return m; 
1916   0EC2 FA FF FF      lea d, [bp + -1] ; $m
1917   0EC5 2A            mov b, [d]
1918   0EC6 F9            leave
1919   0EC7 09            ret
1920   0EC8             
1921   0EC8             puts:
1922   0EC8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1923   0ECB             
1924   0ECB             ; --- BEGIN INLINE ASM BLOCK
1925   0ECB FA 05 00      lea d, [bp + 5] ; $s
1926   0ECE 15            mov a, [d]
1927   0ECF 3C            mov d, a
1928   0ED0 07 03 12      call _puts
1929   0ED3 10 00 0A      mov a, $0A00
1930   0ED6 05 03         syscall sys_io
1931   0ED8             ; --- END INLINE ASM BLOCK
1932   0ED8             
1933   0ED8 F9            leave
1934   0ED9 09            ret
1935   0EDA             
1936   0EDA             print:
1937   0EDA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1938   0EDD             
1939   0EDD             ; --- BEGIN INLINE ASM BLOCK
1940   0EDD FA 05 00      lea d, [bp + 5] ; $s
1941   0EE0 FD 2A         mov d, [d]
1942   0EE2 07 03 12      call _puts
1943   0EE5             ; --- END INLINE ASM BLOCK
1944   0EE5             
1945   0EE5 F9            leave
1946   0EE6 09            ret
1947   0EE7             
1948   0EE7             loadfile:
1949   0EE7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1950   0EEA             
1951   0EEA             ; --- BEGIN INLINE ASM BLOCK
1952   0EEA FA 05 00      lea d, [bp + 5] ; $destination
1953   0EED 15            mov a, [d]
1954   0EEE 4F            mov di, a
1955   0EEF FA 07 00      lea d, [bp + 7] ; $filename
1956   0EF2 FD 2A         mov d, [d]
1957   0EF4 19 14         mov al, 20
1958   0EF6 05 04         syscall sys_filesystem
1959   0EF8             ; --- END INLINE ASM BLOCK
1960   0EF8             
1961   0EF8 F9            leave
1962   0EF9 09            ret
1963   0EFA             
1964   0EFA             create_file:
1965   0EFA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1966   0EFD F9            leave
1967   0EFE 09            ret
1968   0EFF             
1969   0EFF             delete_file:
1970   0EFF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1971   0F02             
1972   0F02             ; --- BEGIN INLINE ASM BLOCK
1973   0F02 FA 05 00      lea d, [bp + 5] ; $filename
1974   0F05 19 0A         mov al, 10
1975   0F07 05 04         syscall sys_filesystem
1976   0F09             ; --- END INLINE ASM BLOCK
1977   0F09             
1978   0F09 F9            leave
1979   0F0A 09            ret
1980   0F0B             
1981   0F0B             fopen:
1982   0F0B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1983   0F0E F9            leave
1984   0F0F 09            ret
1985   0F10             
1986   0F10             fclose:
1987   0F10 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1988   0F13 F9            leave
1989   0F14 09            ret
1990   0F15             
1991   0F15             alloc:
1992   0F15 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1993   0F18             ;; heap_top = heap_top + bytes; 
1994   0F18 3B 65 14      mov d, _heap_top ; $heap_top
1995   0F1B DA            push d
1996   0F1C 3B 65 14      mov d, _heap_top ; $heap_top
1997   0F1F 2A            mov b, [d]
1998   0F20             ; START TERMS
1999   0F20 D7            push a
2000   0F21 11            mov a, b
2001   0F22 FA 05 00      lea d, [bp + 5] ; $bytes
2002   0F25 2A            mov b, [d]
2003   0F26 54            add a, b
2004   0F27 27            mov b, a
2005   0F28 E4            pop a
2006   0F29             ; END TERMS
2007   0F29 E7            pop d
2008   0F2A FD 43         mov [d], b
2009   0F2C             ;; return heap_top - bytes; 
2010   0F2C 3B 65 14      mov d, _heap_top ; $heap_top
2011   0F2F 2A            mov b, [d]
2012   0F30             ; START TERMS
2013   0F30 D7            push a
2014   0F31 11            mov a, b
2015   0F32 FA 05 00      lea d, [bp + 5] ; $bytes
2016   0F35 2A            mov b, [d]
2017   0F36 60            sub a, b
2018   0F37 27            mov b, a
2019   0F38 E4            pop a
2020   0F39             ; END TERMS
2021   0F39 F9            leave
2022   0F3A 09            ret
2023   0F3B             
2024   0F3B             free:
2025   0F3B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2026   0F3E             ;; return heap_top = heap_top - bytes; 
2027   0F3E 3B 65 14      mov d, _heap_top ; $heap_top
2028   0F41 DA            push d
2029   0F42 3B 65 14      mov d, _heap_top ; $heap_top
2030   0F45 2A            mov b, [d]
2031   0F46             ; START TERMS
2032   0F46 D7            push a
2033   0F47 11            mov a, b
2034   0F48 FA 05 00      lea d, [bp + 5] ; $bytes
2035   0F4B 2A            mov b, [d]
2036   0F4C 60            sub a, b
2037   0F4D 27            mov b, a
2038   0F4E E4            pop a
2039   0F4F             ; END TERMS
2040   0F4F E7            pop d
2041   0F50 FD 43         mov [d], b
2042   0F52 F9            leave
2043   0F53 09            ret
2044   0F54             
2045   0F54             exit:
2046   0F54 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2047   0F57             
2048   0F57             ; --- BEGIN INLINE ASM BLOCK
2049   0F57 05 0B         syscall sys_terminate_proc
2050   0F59             ; --- END INLINE ASM BLOCK
2051   0F59             
2052   0F59 F9            leave
2053   0F5A 09            ret
2054   0F5B             
2055   0F5B             load_hex:
2056   0F5B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2057   0F5E             ; $temp 
2058   0F5E 52 02 00      sub sp, 2
2059   0F61             ;; temp = alloc(32768); 
2060   0F61 FA FF FF      lea d, [bp + -1] ; $temp
2061   0F64 DA            push d
2062   0F65 26 00 80      mov b, $8000
2063   0F68 FD AB         swp b
2064   0F6A D8            push b
2065   0F6B 07 15 0F      call alloc
2066   0F6E 51 02 00      add sp, 2
2067   0F71 E7            pop d
2068   0F72 FD 43         mov [d], b
2069   0F74             
2070   0F74             ; --- BEGIN INLINE ASM BLOCK
2071   0F74               
2072   0F74               
2073   0F74               
2074   0F74               
2075   0F74               
2076   0F74             _load_hex:
2077   0F74 D7            push a
2078   0F75 D8            push b
2079   0F76 DA            push d
2080   0F77 E2            push si
2081   0F78 E3            push di
2082   0F79 52 00 80      sub sp, $8000      
2083   0F7C 38 00 00      mov c, 0
2084   0F7F 48            mov a, sp
2085   0F80 77            inc a
2086   0F81 3C            mov d, a          
2087   0F82 07 C0 10      call _gets        
2088   0F85 4D            mov si, a
2089   0F86             __load_hex_loop:
2090   0F86 F6            lodsb             
2091   0F87 B9 00         cmp al, 0         
2092   0F89 C6 97 0F      jz __load_hex_ret
2093   0F8C 36            mov bh, al
2094   0F8D F6            lodsb
2095   0F8E 2F            mov bl, al
2096   0F8F 07 76 10      call _atoi        
2097   0F92 F7            stosb             
2098   0F93 78            inc c
2099   0F94 0A 86 0F      jmp __load_hex_loop
2100   0F97             __load_hex_ret:
2101   0F97 51 00 80      add sp, $8000
2102   0F9A F0            pop di
2103   0F9B EF            pop si
2104   0F9C E7            pop d
2105   0F9D E5            pop b
2106   0F9E E4            pop a
2107   0F9F             ; --- END INLINE ASM BLOCK
2108   0F9F             
2109   0F9F F9            leave
2110   0FA0 09            ret
2111   0FA1             
2112   0FA1             getparam:
2113   0FA1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2114   0FA4             ; $data 
2115   0FA4 52 01 00      sub sp, 1
2116   0FA7             
2117   0FA7             ; --- BEGIN INLINE ASM BLOCK
2118   0FA7 19 04         mov al, 4
2119   0FA9 FA 05 00      lea d, [bp + 5] ; $address
2120   0FAC FD 2A         mov d, [d]
2121   0FAE 05 0C         syscall sys_system
2122   0FB0 FA 00 00      lea d, [bp + 0] ; $data
2123   0FB3 FD 3E         mov [d], bl
2124   0FB5             ; --- END INLINE ASM BLOCK
2125   0FB5             
2126   0FB5             ;; return data; 
2127   0FB5 FA 00 00      lea d, [bp + 0] ; $data
2128   0FB8 32            mov bl, [d]
2129   0FB9 A7 00         mov bh, 0
2130   0FBB F9            leave
2131   0FBC 09            ret
2132   0FBD             
2133   0FBD             clear:
2134   0FBD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2135   0FC0             ;; print("\033[2J\033[H"); 
2136   0FC0 26 5D 14      mov b, __s25 ; "\033[2J\033[H"
2137   0FC3 FD AB         swp b
2138   0FC5 D8            push b
2139   0FC6 07 DA 0E      call print
2140   0FC9 51 02 00      add sp, 2
2141   0FCC F9            leave
2142   0FCD 09            ret
2143   0FCE             
2144   0FCE             include_stdio_asm:
2145   0FCE F8 00 00      enter 0 ; (push bp; mov bp, sp)
2146   0FD1             
2147   0FD1             ; --- BEGIN INLINE ASM BLOCK
2148   0FD1             .include "lib/stdio.asm"
0001+  0FD1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0FD1             ; stdio.s
0003+  0FD1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0FD1             .include "lib/string.asm"
0001++ 0FD1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0FD1             ; string.s
0003++ 0FD1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0FD1             
0005++ 0FD1             
0006++ 0FD1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0FD1             ; _strrev
0008++ 0FD1             ; reverse a string
0009++ 0FD1             ; D = string address
0010++ 0FD1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0FD1             ; 01234
0012++ 0FD1             _strrev:
0013++ 0FD1 4B          	pusha
0014++ 0FD2 07 18 10    	call _strlen	; length in C
0015++ 0FD5 12          	mov a, c
0016++ 0FD6 AF 01 00    	cmp a, 1
0017++ 0FD9 D0 F3 0F    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0FDC 7D          	dec a
0019++ 0FDD FD 4E       	mov si, d	; beginning of string
0020++ 0FDF FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0FE1 59          	add d, a	; end of string
0022++ 0FE2 12          	mov a, c
0023++ 0FE3 FD 9B       	shr a		; divide by 2
0024++ 0FE5 39          	mov c, a	; C now counts the steps
0025++ 0FE6             _strrev_L0:
0026++ 0FE6 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0FE7 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0FE8 3E          	mov [d], al	; store left char into right side
0029++ 0FE9 1B          	mov al, bl
0030++ 0FEA F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0FEB 7E          	dec c
0032++ 0FEC 7F          	dec d
0033++ 0FED C2 00 00    	cmp c, 0
0034++ 0FF0 C7 E6 0F    	jne _strrev_L0
0035++ 0FF3             _strrev_end:
0036++ 0FF3 4C          	popa
0037++ 0FF4 09          	ret
0038++ 0FF5             	
0039++ 0FF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0FF5             ; _strchr
0041++ 0FF5             ; search string in D for char in AL
0042++ 0FF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0FF5             _strchr:
0044++ 0FF5             _strchr_L0:
0045++ 0FF5 32          	mov bl, [d]
0046++ 0FF6 C1 00       	cmp bl, 0
0047++ 0FF8 C6 03 10    	je _strchr_end
0048++ 0FFB BA          	cmp al, bl
0049++ 0FFC C6 03 10    	je _strchr_end
0050++ 0FFF 79          	inc d
0051++ 1000 0A F5 0F    	jmp _strchr_L0
0052++ 1003             _strchr_end:
0053++ 1003 1B          	mov al, bl
0054++ 1004 09          	ret
0055++ 1005             
0056++ 1005             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1005             ; _strstr
0058++ 1005             ; find sub-string
0059++ 1005             ; str1 in SI
0060++ 1005             ; str2 in DI
0061++ 1005             ; SI points to end of source string
0062++ 1005             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1005             _strstr:
0064++ 1005 DB          	push al
0065++ 1006 DA          	push d
0066++ 1007 E3          	push di
0067++ 1008             _strstr_loop:
0068++ 1008 F3          	cmpsb					; compare a byte of the strings
0069++ 1009 C7 14 10    	jne _strstr_ret
0070++ 100C FC 00 00    	lea d, [di + 0]
0071++ 100F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1011 C7 08 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1014             _strstr_ret:
0074++ 1014 F0          	pop di
0075++ 1015 E7          	pop d
0076++ 1016 E8          	pop al
0077++ 1017 09          	ret
0078++ 1018             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1018             ; length of null terminated string
0080++ 1018             ; result in C
0081++ 1018             ; pointer in D
0082++ 1018             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1018             _strlen:
0084++ 1018 DA          	push d
0085++ 1019 38 00 00    	mov c, 0
0086++ 101C             _strlen_L1:
0087++ 101C BD 00       	cmp byte [d], 0
0088++ 101E C6 26 10    	je _strlen_ret
0089++ 1021 79          	inc d
0090++ 1022 78          	inc c
0091++ 1023 0A 1C 10    	jmp _strlen_L1
0092++ 1026             _strlen_ret:
0093++ 1026 E7          	pop d
0094++ 1027 09          	ret
0095++ 1028             
0096++ 1028             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1028             ; STRCMP
0098++ 1028             ; compare two strings
0099++ 1028             ; str1 in SI
0100++ 1028             ; str2 in DI
0101++ 1028             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1028             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1028             _strcmp:
0104++ 1028 DB          	push al
0105++ 1029 DA          	push d
0106++ 102A E3          	push di
0107++ 102B E2          	push si
0108++ 102C             _strcmp_loop:
0109++ 102C F3          	cmpsb					; compare a byte of the strings
0110++ 102D C7 38 10    	jne _strcmp_ret
0111++ 1030 FB FF FF    	lea d, [si +- 1]
0112++ 1033 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1035 C7 2C 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1038             _strcmp_ret:
0115++ 1038 EF          	pop si
0116++ 1039 F0          	pop di
0117++ 103A E7          	pop d
0118++ 103B E8          	pop al
0119++ 103C 09          	ret
0120++ 103D             
0121++ 103D             
0122++ 103D             ; STRCPY
0123++ 103D             ; copy null terminated string from SI to DI
0124++ 103D             ; source in SI
0125++ 103D             ; destination in DI
0126++ 103D             _strcpy:
0127++ 103D E2          	push si
0128++ 103E E3          	push di
0129++ 103F DB          	push al
0130++ 1040             _strcpy_L1:
0131++ 1040 F6          	lodsb
0132++ 1041 F7          	stosb
0133++ 1042 B9 00       	cmp al, 0
0134++ 1044 C7 40 10    	jne _strcpy_L1
0135++ 1047             _strcpy_end:
0136++ 1047 E8          	pop al
0137++ 1048 F0          	pop di
0138++ 1049 EF          	pop si
0139++ 104A 09          	ret
0140++ 104B             
0141++ 104B             ; STRCAT
0142++ 104B             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 104B             ; source in SI
0144++ 104B             ; destination in DI
0145++ 104B             _strcat:
0146++ 104B E2          	push si
0147++ 104C E3          	push di
0148++ 104D D7          	push a
0149++ 104E DA          	push d
0150++ 104F 50          	mov a, di
0151++ 1050 3C          	mov d, a
0152++ 1051             _strcat_goto_end_L1:
0153++ 1051 BD 00       	cmp byte[d], 0
0154++ 1053 C6 5A 10    	je _strcat_start
0155++ 1056 79          	inc d
0156++ 1057 0A 51 10    	jmp _strcat_goto_end_L1
0157++ 105A             _strcat_start:
0158++ 105A FD 50       	mov di, d
0159++ 105C             _strcat_L1:
0160++ 105C F6          	lodsb
0161++ 105D F7          	stosb
0162++ 105E B9 00       	cmp al, 0
0163++ 1060 C7 5C 10    	jne _strcat_L1
0164++ 1063             _strcat_end:
0165++ 1063 E7          	pop d
0166++ 1064 E4          	pop a
0167++ 1065 F0          	pop di
0168++ 1066 EF          	pop si
0169++ 1067 09          	ret
0170++ 1068             
0171++ 1068             
0005+  1068             
0006+  1068             
0007+  1068             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1068             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  1068             ; ASCII in BL
0010+  1068             ; result in AL
0011+  1068             ; ascii for F = 0100 0110
0012+  1068             ; ascii for 9 = 0011 1001
0013+  1068             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1068             hex_ascii_encode:
0015+  1068 1B            mov al, bl
0016+  1069 93 40         test al, $40        ; test if letter or number
0017+  106B C7 71 10      jnz hex_letter
0018+  106E 87 0F         and al, $0F        ; get number
0019+  1070 09            ret
0020+  1071             hex_letter:
0021+  1071 87 0F         and al, $0F        ; get letter
0022+  1073 6A 09         add al, 9
0023+  1075 09            ret
0024+  1076             
0025+  1076             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1076             ; ATOI
0027+  1076             ; 2 letter hex string in B
0028+  1076             ; 8bit integer returned in AL
0029+  1076             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1076             _atoi:
0031+  1076 D8            push b
0032+  1077 07 68 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  107A 30            mov bl, bh
0034+  107B DB            push al          ; save a
0035+  107C 07 68 10      call hex_ascii_encode
0036+  107F EA            pop bl  
0037+  1080 FD 9E 04      shl al, 4
0038+  1083 8C            or al, bl
0039+  1084 E5            pop b
0040+  1085 09            ret  
0041+  1086             
0042+  1086             
0043+  1086             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1086             ; scanf
0045+  1086             ; no need for explanations!
0046+  1086             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1086             scanf:
0048+  1086 09            ret
0049+  1087             
0050+  1087             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1087             ; ITOA
0052+  1087             ; 8bit value in BL
0053+  1087             ; 2 byte ASCII result in A
0054+  1087             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1087             _itoa:
0056+  1087 DA            push d
0057+  1088 D8            push b
0058+  1089 A7 00         mov bh, 0
0059+  108B FD A4 04      shr bl, 4  
0060+  108E 74            mov d, b
0061+  108F 1F 37 13      mov al, [d + s_hex_digits]
0062+  1092 23            mov ah, al
0063+  1093               
0064+  1093 E5            pop b
0065+  1094 D8            push b
0066+  1095 A7 00         mov bh, 0
0067+  1097 FD 87 0F      and bl, $0F
0068+  109A 74            mov d, b
0069+  109B 1F 37 13      mov al, [d + s_hex_digits]
0070+  109E E5            pop b
0071+  109F E7            pop d
0072+  10A0 09            ret
0073+  10A1             
0074+  10A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  10A1             ; HEX STRING TO BINARY
0076+  10A1             ; di = destination address
0077+  10A1             ; si = source
0078+  10A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  10A1             _hex_to_int:
0080+  10A1             _hex_to_int_L1:
0081+  10A1 F6            lodsb          ; load from [SI] to AL
0082+  10A2 B9 00         cmp al, 0        ; check if ASCII 0
0083+  10A4 C6 B1 10      jz _hex_to_int_ret
0084+  10A7 36            mov bh, al
0085+  10A8 F6            lodsb
0086+  10A9 2F            mov bl, al
0087+  10AA 07 76 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  10AD F7            stosb          ; store AL to [DI]
0089+  10AE 0A A1 10      jmp _hex_to_int_L1
0090+  10B1             _hex_to_int_ret:
0091+  10B1 09            ret    
0092+  10B2             
0093+  10B2             
0094+  10B2             
0095+  10B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  10B2             ; GETCHAR
0097+  10B2             ; char in ah
0098+  10B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  10B2             getch:
0100+  10B2 DB            push al
0101+  10B3             getch_retry:
0102+  10B3 19 01         mov al, 1
0103+  10B5 05 03         syscall sys_io      ; receive in AH
0104+  10B7 E8            pop al
0105+  10B8 09            ret
0106+  10B9             
0107+  10B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  10B9             ; PUTCHAR
0109+  10B9             ; char in ah
0110+  10B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  10B9             _putchar:
0112+  10B9 D7            push a
0113+  10BA 19 00         mov al, 0
0114+  10BC 05 03         syscall sys_io      ; char in AH
0115+  10BE E4            pop a
0116+  10BF 09            ret
0117+  10C0             
0118+  10C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  10C0             ;; INPUT A STRING
0120+  10C0             ;; terminates with null
0121+  10C0             ;; pointer in D
0122+  10C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  10C0             _gets:
0124+  10C0 D7            push a
0125+  10C1 DA            push d
0126+  10C2             _gets_loop:
0127+  10C2 19 01         mov al, 1
0128+  10C4 05 03         syscall sys_io      ; receive in AH
0129+  10C6 B9 00         cmp al, 0        ; check error code (AL)
0130+  10C8 C6 C2 10      je _gets_loop      ; if no char received, retry
0131+  10CB             
0132+  10CB 76 1B         cmp ah, 27
0133+  10CD C6 EE 10      je _gets_ansi_esc
0134+  10D0 76 0A         cmp ah, $0A        ; LF
0135+  10D2 C6 59 11      je _gets_end
0136+  10D5 76 0D         cmp ah, $0D        ; CR
0137+  10D7 C6 59 11      je _gets_end
0138+  10DA 76 5C         cmp ah, $5C        ; '\\'
0139+  10DC C6 1A 11      je _gets_escape
0140+  10DF               
0141+  10DF 76 08         cmp ah, $08      ; check for backspace
0142+  10E1 C6 EA 10      je _gets_backspace
0143+  10E4             
0144+  10E4 1A            mov al, ah
0145+  10E5 3E            mov [d], al
0146+  10E6 79            inc d
0147+  10E7 0A C2 10      jmp _gets_loop
0148+  10EA             _gets_backspace:
0149+  10EA 7F            dec d
0150+  10EB 0A C2 10      jmp _gets_loop
0151+  10EE             _gets_ansi_esc:
0152+  10EE 19 01         mov al, 1
0153+  10F0 05 03         syscall sys_io        ; receive in AH without echo
0154+  10F2 B9 00         cmp al, 0          ; check error code (AL)
0155+  10F4 C6 EE 10      je _gets_ansi_esc    ; if no char received, retry
0156+  10F7 76 5B         cmp ah, '['
0157+  10F9 C7 C2 10      jne _gets_loop
0158+  10FC             _gets_ansi_esc_2:
0159+  10FC 19 01         mov al, 1
0160+  10FE 05 03         syscall sys_io          ; receive in AH without echo
0161+  1100 B9 00         cmp al, 0            ; check error code (AL)
0162+  1102 C6 FC 10      je _gets_ansi_esc_2  ; if no char received, retry
0163+  1105 76 44         cmp ah, 'D'
0164+  1107 C6 12 11      je _gets_left_arrow
0165+  110A 76 43         cmp ah, 'C'
0166+  110C C6 16 11      je _gets_right_arrow
0167+  110F 0A C2 10      jmp _gets_loop
0168+  1112             _gets_left_arrow:
0169+  1112 7F            dec d
0170+  1113 0A C2 10      jmp _gets_loop
0171+  1116             _gets_right_arrow:
0172+  1116 79            inc d
0173+  1117 0A C2 10      jmp _gets_loop
0174+  111A             _gets_escape:
0175+  111A 19 01         mov al, 1
0176+  111C 05 03         syscall sys_io      ; receive in AH
0177+  111E B9 00         cmp al, 0        ; check error code (AL)
0178+  1120 C6 1A 11      je _gets_escape      ; if no char received, retry
0179+  1123 76 6E         cmp ah, 'n'
0180+  1125 C6 44 11      je _gets_LF
0181+  1128 76 72         cmp ah, 'r'
0182+  112A C6 4B 11      je _gets_CR
0183+  112D 76 30         cmp ah, '0'
0184+  112F C6 52 11      je _gets_NULL
0185+  1132 76 5C         cmp ah, $5C  ; '\'
0186+  1134 C6 3D 11      je _gets_slash
0187+  1137 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  1138 3E            mov [d], al
0189+  1139 79            inc d
0190+  113A 0A C2 10      jmp _gets_loop
0191+  113D             _gets_slash:
0192+  113D 19 5C         mov al, $5C
0193+  113F 3E            mov [d], al
0194+  1140 79            inc d
0195+  1141 0A C2 10      jmp _gets_loop
0196+  1144             _gets_LF:
0197+  1144 19 0A         mov al, $0A
0198+  1146 3E            mov [d], al
0199+  1147 79            inc d
0200+  1148 0A C2 10      jmp _gets_loop
0201+  114B             _gets_CR:
0202+  114B 19 0D         mov al, $0D
0203+  114D 3E            mov [d], al
0204+  114E 79            inc d
0205+  114F 0A C2 10      jmp _gets_loop
0206+  1152             _gets_NULL:
0207+  1152 19 00         mov al, $00
0208+  1154 3E            mov [d], al
0209+  1155 79            inc d
0210+  1156 0A C2 10      jmp _gets_loop
0211+  1159             _gets_end:
0212+  1159 19 00         mov al, 0
0213+  115B 3E            mov [d], al        ; terminate string
0214+  115C E7            pop d
0215+  115D E4            pop a
0216+  115E 09            ret
0217+  115F             
0218+  115F             
0219+  115F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  115F             ;; INPUT TEXT
0221+  115F             ;; terminated with CTRL+D
0222+  115F             ;; pointer in D
0223+  115F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  115F             _gettxt:
0225+  115F D7            push a
0226+  1160 DA            push d
0227+  1161             _gettxt_loop:
0228+  1161 19 01         mov al, 1
0229+  1163 05 03         syscall sys_io      ; receive in AH
0230+  1165 B9 00         cmp al, 0        ; check error code (AL)
0231+  1167 C6 61 11      je _gettxt_loop    ; if no char received, retry
0232+  116A 76 04         cmp ah, 4      ; EOT
0233+  116C C6 AA 11      je _gettxt_end
0234+  116F 76 08         cmp ah, $08      ; check for backspace
0235+  1171 C6 A6 11      je _gettxt_backspace
0236+  1174 76 5C         cmp ah, $5C        ; '\'
0237+  1176 C6 7F 11      je _gettxt_escape
0238+  1179 1A            mov al, ah
0239+  117A 3E            mov [d], al
0240+  117B 79            inc d
0241+  117C 0A 61 11      jmp _gettxt_loop
0242+  117F             _gettxt_escape:
0243+  117F 19 01         mov al, 1
0244+  1181 05 03         syscall sys_io      ; receive in AH
0245+  1183 B9 00         cmp al, 0        ; check error code (AL)
0246+  1185 C6 7F 11      je _gettxt_escape    ; if no char received, retry
0247+  1188 76 6E         cmp ah, 'n'
0248+  118A C6 98 11      je _gettxt_LF
0249+  118D 76 72         cmp ah, 'r'
0250+  118F C6 9F 11      je _gettxt_CR
0251+  1192 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  1193 3E            mov [d], al
0253+  1194 79            inc d
0254+  1195 0A 61 11      jmp _gettxt_loop
0255+  1198             _gettxt_LF:
0256+  1198 19 0A         mov al, $0A
0257+  119A 3E            mov [d], al
0258+  119B 79            inc d
0259+  119C 0A 61 11      jmp _gettxt_loop
0260+  119F             _gettxt_CR:
0261+  119F 19 0D         mov al, $0D
0262+  11A1 3E            mov [d], al
0263+  11A2 79            inc d
0264+  11A3 0A 61 11      jmp _gettxt_loop
0265+  11A6             _gettxt_backspace:
0266+  11A6 7F            dec d
0267+  11A7 0A 61 11      jmp _gettxt_loop
0268+  11AA             _gettxt_end:
0269+  11AA 19 00         mov al, 0
0270+  11AC 3E            mov [d], al        ; terminate string
0271+  11AD E7            pop d
0272+  11AE E4            pop a
0273+  11AF 09            ret
0274+  11B0             
0275+  11B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  11B0             ; PRINT NEW LINE
0277+  11B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  11B0             printnl:
0279+  11B0 D7            push a
0280+  11B1 10 00 0A      mov a, $0A00
0281+  11B4 05 03         syscall sys_io
0282+  11B6 10 00 0D      mov a, $0D00
0283+  11B9 05 03         syscall sys_io
0284+  11BB E4            pop a
0285+  11BC 09            ret
0286+  11BD             
0287+  11BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  11BD             ; _strtoint
0289+  11BD             ; 4 digit hex string number in d
0290+  11BD             ; integer returned in A
0291+  11BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  11BD             _strtointx:
0293+  11BD D8            push b
0294+  11BE 32            mov bl, [d]
0295+  11BF 37            mov bh, bl
0296+  11C0 33 01 00      mov bl, [d + 1]
0297+  11C3 07 76 10      call _atoi        ; convert to int in AL
0298+  11C6 23            mov ah, al        ; move to AH
0299+  11C7 33 02 00      mov bl, [d + 2]
0300+  11CA 37            mov bh, bl
0301+  11CB 33 03 00      mov bl, [d + 3]
0302+  11CE 07 76 10      call _atoi        ; convert to int in AL
0303+  11D1 E5            pop b
0304+  11D2 09            ret
0305+  11D3             
0306+  11D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  11D3             ; _strtoint
0308+  11D3             ; 5 digit base10 string number in d
0309+  11D3             ; integer returned in A
0310+  11D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  11D3             _strtoint:
0312+  11D3 E2            push si
0313+  11D4 D8            push b
0314+  11D5 D9            push c
0315+  11D6 DA            push d
0316+  11D7 07 18 10      call _strlen      ; get string length in C
0317+  11DA 7E            dec c
0318+  11DB FD 4E         mov si, d
0319+  11DD 12            mov a, c
0320+  11DE FD 99         shl a
0321+  11E0 3B 4F 13      mov d, table_power
0322+  11E3 59            add d, a
0323+  11E4 38 00 00      mov c, 0
0324+  11E7             _strtoint_L0:
0325+  11E7 F6            lodsb      ; load ASCII to al
0326+  11E8 B9 00         cmp al, 0
0327+  11EA C6 FD 11      je _strtoint_end
0328+  11ED 6F 30         sub al, $30    ; make into integer
0329+  11EF 22 00         mov ah, 0
0330+  11F1 2A            mov b, [d]
0331+  11F2 AC            mul a, b      ; result in B since it fits in 16bits
0332+  11F3 11            mov a, b
0333+  11F4 28            mov b, c
0334+  11F5 54            add a, b
0335+  11F6 39            mov c, a
0336+  11F7 63 02 00      sub d, 2
0337+  11FA 0A E7 11      jmp _strtoint_L0
0338+  11FD             _strtoint_end:
0339+  11FD 12            mov a, c
0340+  11FE E7            pop d
0341+  11FF E6            pop c
0342+  1200 E5            pop b
0343+  1201 EF            pop si
0344+  1202 09            ret
0345+  1203             
0346+  1203             
0347+  1203             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  1203             ; PRINT NULL TERMINATED STRING
0349+  1203             ; pointer in D
0350+  1203             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  1203             _puts:
0352+  1203 D7            push a
0353+  1204 DA            push d
0354+  1205             _puts_L1:
0355+  1205 1E            mov al, [d]
0356+  1206 B9 00         cmp al, 0
0357+  1208 C6 14 12      jz _puts_END
0358+  120B 23            mov ah, al
0359+  120C 19 00         mov al, 0
0360+  120E 05 03         syscall sys_io
0361+  1210 79            inc d
0362+  1211 0A 05 12      jmp _puts_L1
0363+  1214             _puts_END:
0364+  1214 E7            pop d
0365+  1215 E4            pop a
0366+  1216 09            ret
0367+  1217             
0368+  1217             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  1217             ; PRINT N SIZE STRING
0370+  1217             ; pointer in D
0371+  1217             ; size in C
0372+  1217             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  1217             _putsn:
0374+  1217 DB            push al
0375+  1218 DA            push d
0376+  1219 D9            push c
0377+  121A             _putsn_L0:
0378+  121A 1E            mov al, [d]
0379+  121B 23            mov ah, al
0380+  121C 19 00         mov al, 0
0381+  121E 05 03         syscall sys_io
0382+  1220 79            inc d
0383+  1221 7E            dec c  
0384+  1222 C2 00 00      cmp c, 0
0385+  1225 C7 1A 12      jne _putsn_L0
0386+  1228             _putsn_end:
0387+  1228 E6            pop c
0388+  1229 E7            pop d
0389+  122A E8            pop al
0390+  122B 09            ret
0391+  122C             
0392+  122C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  122C             ; print 16bit decimal number
0394+  122C             ; input number in A
0395+  122C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  122C             print_u16d:
0397+  122C D7            push a
0398+  122D D8            push b
0399+  122E 26 10 27      mov b, 10000
0400+  1231 AE            div a, b      ; get 10000's coeff.
0401+  1232 07 54 12      call print_number
0402+  1235 11            mov a, b
0403+  1236 26 E8 03      mov b, 1000
0404+  1239 AE            div a, b      ; get 1000's coeff.
0405+  123A 07 54 12      call print_number
0406+  123D 11            mov a, b
0407+  123E 26 64 00      mov b, 100
0408+  1241 AE            div a, b
0409+  1242 07 54 12      call print_number
0410+  1245 11            mov a, b
0411+  1246 26 0A 00      mov b, 10
0412+  1249 AE            div a, b
0413+  124A 07 54 12      call print_number
0414+  124D 1B            mov al, bl      ; 1's coeff in bl
0415+  124E 07 54 12      call print_number
0416+  1251 E5            pop b
0417+  1252 E4            pop a
0418+  1253 09            ret
0419+  1254             
0420+  1254             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  1254             ; print AL
0422+  1254             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  1254             print_number:
0424+  1254 6A 30         add al, $30
0425+  1256 23            mov ah, al
0426+  1257 07 B9 10      call _putchar
0427+  125A 09            ret
0428+  125B             
0429+  125B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  125B             ; PRINT 16BIT HEX INTEGER
0431+  125B             ; integer value in reg B
0432+  125B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  125B             print_u16x:
0434+  125B D7            push a
0435+  125C D8            push b
0436+  125D DD            push bl
0437+  125E 30            mov bl, bh
0438+  125F 07 87 10      call _itoa        ; convert bh to char in A
0439+  1262 2F            mov bl, al        ; save al
0440+  1263 19 00         mov al, 0
0441+  1265 05 03         syscall sys_io        ; display AH
0442+  1267 24            mov ah, bl        ; retrieve al
0443+  1268 19 00         mov al, 0
0444+  126A 05 03         syscall sys_io        ; display AL
0445+  126C             
0446+  126C EA            pop bl
0447+  126D 07 87 10      call _itoa        ; convert bh to char in A
0448+  1270 2F            mov bl, al        ; save al
0449+  1271 19 00         mov al, 0
0450+  1273 05 03         syscall sys_io        ; display AH
0451+  1275 24            mov ah, bl        ; retrieve al
0452+  1276 19 00         mov al, 0
0453+  1278 05 03         syscall sys_io        ; display AL
0454+  127A             
0455+  127A E5            pop b
0456+  127B E4            pop a
0457+  127C 09            ret
0458+  127D             
0459+  127D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  127D             ; INPUT 16BIT HEX INTEGER
0461+  127D             ; read 16bit integer into A
0462+  127D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  127D             scan_u16x:
0464+  127D F8 10 00      enter 16
0465+  1280 D8            push b
0466+  1281 DA            push d
0467+  1282             
0468+  1282 FA F1 FF      lea d, [bp + -15]
0469+  1285 07 C0 10      call _gets        ; get number
0470+  1288             
0471+  1288 32            mov bl, [d]
0472+  1289 37            mov bh, bl
0473+  128A 33 01 00      mov bl, [d + 1]
0474+  128D 07 76 10      call _atoi        ; convert to int in AL
0475+  1290 23            mov ah, al        ; move to AH
0476+  1291             
0477+  1291 33 02 00      mov bl, [d + 2]
0478+  1294 37            mov bh, bl
0479+  1295 33 03 00      mov bl, [d + 3]
0480+  1298 07 76 10      call _atoi        ; convert to int in AL
0481+  129B             
0482+  129B E7            pop d
0483+  129C E5            pop b
0484+  129D F9            leave
0485+  129E 09            ret
0486+  129F             
0487+  129F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  129F             ; PRINT 8bit HEX INTEGER
0489+  129F             ; integer value in reg bl
0490+  129F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  129F             print_u8x:
0492+  129F D7            push a
0493+  12A0 DD            push bl
0494+  12A1             
0495+  12A1 07 87 10      call _itoa        ; convert bl to char in A
0496+  12A4 2F            mov bl, al        ; save al
0497+  12A5 19 00         mov al, 0
0498+  12A7 05 03         syscall sys_io        ; display AH
0499+  12A9 24            mov ah, bl        ; retrieve al
0500+  12AA 19 00         mov al, 0
0501+  12AC 05 03         syscall sys_io        ; display AL
0502+  12AE             
0503+  12AE EA            pop bl
0504+  12AF E4            pop a
0505+  12B0 09            ret
0506+  12B1             
0507+  12B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  12B1             ; print 8bit decimal unsigned number
0509+  12B1             ; input number in AL
0510+  12B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  12B1             print_u8d:
0512+  12B1 D7            push a
0513+  12B2 D8            push b
0514+  12B3             
0515+  12B3 22 00         mov ah, 0
0516+  12B5 26 64 00      mov b, 100
0517+  12B8 AE            div a, b
0518+  12B9 D8            push b      ; save remainder
0519+  12BA B9 00         cmp al, 0
0520+  12BC C6 C6 12      je skip100
0521+  12BF 6A 30         add al, $30
0522+  12C1 23            mov ah, al
0523+  12C2 19 00         mov al, 0
0524+  12C4 05 03         syscall sys_io  ; print coeff
0525+  12C6             skip100:
0526+  12C6 E4            pop a
0527+  12C7 22 00         mov ah, 0
0528+  12C9 26 0A 00      mov b, 10
0529+  12CC AE            div a, b
0530+  12CD D8            push b      ; save remainder
0531+  12CE B9 00         cmp al, 0
0532+  12D0 C6 DA 12      je skip10
0533+  12D3 6A 30         add al, $30
0534+  12D5 23            mov ah, al
0535+  12D6 19 00         mov al, 0
0536+  12D8 05 03         syscall sys_io  ; print coeff
0537+  12DA             skip10:
0538+  12DA E4            pop a
0539+  12DB 1B            mov al, bl
0540+  12DC 6A 30         add al, $30
0541+  12DE 23            mov ah, al
0542+  12DF 19 00         mov al, 0
0543+  12E1 05 03         syscall sys_io  ; print coeff
0544+  12E3 E5            pop b
0545+  12E4 E4            pop a
0546+  12E5 09            ret
0547+  12E6             
0548+  12E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  12E6             ; INPUT 8BIT HEX INTEGER
0550+  12E6             ; read 8bit integer into AL
0551+  12E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  12E6             scan_u8x:
0553+  12E6 F8 04 00      enter 4
0554+  12E9 D8            push b
0555+  12EA DA            push d
0556+  12EB             
0557+  12EB FA FD FF      lea d, [bp + -3]
0558+  12EE 07 C0 10      call _gets        ; get number
0559+  12F1             
0560+  12F1 32            mov bl, [d]
0561+  12F2 37            mov bh, bl
0562+  12F3 33 01 00      mov bl, [d + 1]
0563+  12F6 07 76 10      call _atoi        ; convert to int in AL
0564+  12F9             
0565+  12F9 E7            pop d
0566+  12FA E5            pop b
0567+  12FB F9            leave
0568+  12FC 09            ret
0569+  12FD             
0570+  12FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  12FD             ; input decimal number
0572+  12FD             ; result in A
0573+  12FD             ; 655'\0'
0574+  12FD             ; low--------high
0575+  12FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  12FD             scan_u16d:
0577+  12FD F8 08 00      enter 8
0578+  1300 E2            push si
0579+  1301 D8            push b
0580+  1302 D9            push c
0581+  1303 DA            push d
0582+  1304 FA F9 FF      lea d, [bp +- 7]
0583+  1307 07 C0 10      call _gets
0584+  130A 07 18 10      call _strlen      ; get string length in C
0585+  130D 7E            dec c
0586+  130E FD 4E         mov si, d
0587+  1310 12            mov a, c
0588+  1311 FD 99         shl a
0589+  1313 3B 4F 13      mov d, table_power
0590+  1316 59            add d, a
0591+  1317 38 00 00      mov c, 0
0592+  131A             mul_loop:
0593+  131A F6            lodsb      ; load ASCII to al
0594+  131B B9 00         cmp al, 0
0595+  131D C6 30 13      je mul_exit
0596+  1320 6F 30         sub al, $30    ; make into integer
0597+  1322 22 00         mov ah, 0
0598+  1324 2A            mov b, [d]
0599+  1325 AC            mul a, b      ; result in B since it fits in 16bits
0600+  1326 11            mov a, b
0601+  1327 28            mov b, c
0602+  1328 54            add a, b
0603+  1329 39            mov c, a
0604+  132A 63 02 00      sub d, 2
0605+  132D 0A 1A 13      jmp mul_loop
0606+  1330             mul_exit:
0607+  1330 12            mov a, c
0608+  1331 E7            pop d
0609+  1332 E6            pop c
0610+  1333 E5            pop b
0611+  1334 EF            pop si
0612+  1335 F9            leave
0613+  1336 09            ret
0614+  1337             
0615+  1337             
0616+  1337 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  133B 34 35 36 37 
0616+  133F 38 39 41 42 
0616+  1343 43 44 45 46 
0617+  1347 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  134B 1B 5B 48 00 
0618+  134F             
0619+  134F             table_power:
0620+  134F 01 00         .dw 1
0621+  1351 0A 00         .dw 10
0622+  1353 64 00         .dw 100
0623+  1355 E8 03         .dw 1000
0624+  1357 10 27         .dw 100002149   1359             ; --- END INLINE ASM BLOCK
2150   1359             
2151   1359 F9            leave
2152   135A 09            ret
2153   135B             ; --- END TEXT BLOCK
2154   135B             
2155   135B             ; --- BEGIN DATA BLOCK
2156   135B 1B 5B 32 4A __s0: .db "\033[2J", 0
2156   135F 00 
2157   1360 1B 5B 48 00 __s1: .db "\033[H", 0
2158   1364 1B 5B 31 6D __s2: .db "\033[1m", 0
2158   1368 00 
2159   1369 42 6F 6C 64 __s3: .db "Bold Text", 0
2159   136D 20 54 65 78 
2159   1371 74 00 
2160   1373 1B 5B 30 6D __s4: .db "\033[0m\n", 0
2160   1377 0A 00 
2161   1379 1B 5B 34 6D __s5: .db "\033[4m", 0
2161   137D 00 
2162   137E 55 6E 64 65 __s6: .db "Underlined Text", 0
2162   1382 72 6C 69 6E 
2162   1386 65 64 20 54 
2162   138A 65 78 74 00 
2163   138E 1B 5B 35 6D __s7: .db "\033[5m", 0
2163   1392 00 
2164   1393 42 6C 69 6E __s8: .db "Blinking Text", 0
2164   1397 6B 69 6E 67 
2164   139B 20 54 65 78 
2164   139F 74 00 
2165   13A1 1B 5B 37 6D __s9: .db "\033[7m", 0
2165   13A5 00 
2166   13A6 49 6E 76 65 __s10: .db "Inverted Colors", 0
2166   13AA 72 74 65 64 
2166   13AE 20 43 6F 6C 
2166   13B2 6F 72 73 00 
2167   13B6 1B 5B 30 6D __s11: .db "\033[0m", 0
2167   13BA 00 
2168   13BB 52 65 73 65 __s12: .db "Reset All\n", 0
2168   13BF 74 20 41 6C 
2168   13C3 6C 0A 00 
2169   13C6 1B 5B 00    __s13: .db "\033[", 0
2170   13C9 6D 1B 5B 00 __s14: .db "m\033[", 0
2171   13CD 6D 20 00    __s15: .db "m ", 0
2172   13D0 2F 00       __s16: .db "/", 0
2173   13D2 20 00       __s17: .db " ", 0
2174   13D4 32 35 36 2D __s18: .db "256-Color Chart:\n", 0
2174   13D8 43 6F 6C 6F 
2174   13DC 72 20 43 68 
2174   13E0 61 72 74 3A 
2174   13E4 0A 00 
2175   13E6 1B 5B 34 38 __s19: .db "\033[48;5;", 0
2175   13EA 3B 35 3B 00 
2176   13EE 6D 20 20 00 __s20: .db "m  ", 0
2177   13F2 20 1B 5B 30 __s21: .db " \033[0m", 0
2177   13F6 6D 00 
2178   13F8 0A 00       __s22: .db "\n", 0
2179   13FA 55 6E 6B 6E __s23: .db "Unknown type size in va_arg() call. Size needs to be either 1 or 2.", 0
2179   13FE 6F 77 6E 20 
2179   1402 74 79 70 65 
2179   1406 20 73 69 7A 
2179   140A 65 20 69 6E 
2179   140E 20 76 61 5F 
2179   1412 61 72 67 28 
2179   1416 29 20 63 61 
2179   141A 6C 6C 2E 20 
2179   141E 53 69 7A 65 
2179   1422 20 6E 65 65 
2179   1426 64 73 20 74 
2179   142A 6F 20 62 65 
2179   142E 20 65 69 74 
2179   1432 68 65 72 20 
2179   1436 31 20 6F 72 
2179   143A 20 32 2E 00 
2180   143E 45 72 72 6F __s24: .db "Error: Unknown argument type.\n", 0
2180   1442 72 3A 20 55 
2180   1446 6E 6B 6E 6F 
2180   144A 77 6E 20 61 
2180   144E 72 67 75 6D 
2180   1452 65 6E 74 20 
2180   1456 74 79 70 65 
2180   145A 2E 0A 00 
2181   145D 1B 5B 32 4A __s25: .db "\033[2J\033[H", 0
2181   1461 1B 5B 48 00 
2182   1465             
2183   1465 67 14       _heap_top: .dw _heap
2184   1467 00          _heap: .db 0
2185   1468             ; --- END DATA BLOCK
2186   1468             
2187   1468             .end
tasm: Number of errors = 0
