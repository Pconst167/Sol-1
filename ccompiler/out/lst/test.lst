0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; int i, j; 
0011   0408 52 02 00      sub sp, 2
0012   040B 52 02 00      sub sp, 2
0013   040E             ; for(i=0;i<80;i++){ 
0014   040E             _for1_init:
0015   040E FA FF FF      lea d, [bp + -1] ; $i
0016   0411 DA            push d
0017   0412 FD 2E 00 00   mov32 cb, $00000000
0017   0416 00 00 
0018   0418 E7            pop d
0019   0419 FD 43         mov [d], b
0020   041B             _for1_cond:
0021   041B FA FF FF      lea d, [bp + -1] ; $i
0022   041E 2A            mov b, [d]
0023   041F 38 00 00      mov c, 0
0024   0422             ; --- START RELATIONAL
0025   0422 D7            push a
0026   0423 11            mov a, b
0027   0424 FD 2E 50 00   mov32 cb, $00000050
0027   0428 00 00 
0028   042A B0            cmp a, b
0029   042B FD 73         slt ; < (signed)
0030   042D E4            pop a
0031   042E             ; --- END RELATIONAL
0032   042E C0 00 00      cmp b, 0
0033   0431 C6 9A 04      je _for1_exit
0034   0434             _for1_block:
0035   0434             ; for(j=0;j<80;j++){ 
0036   0434             _for2_init:
0037   0434 FA FD FF      lea d, [bp + -3] ; $j
0038   0437 DA            push d
0039   0438 FD 2E 00 00   mov32 cb, $00000000
0039   043C 00 00 
0040   043E E7            pop d
0041   043F FD 43         mov [d], b
0042   0441             _for2_cond:
0043   0441 FA FD FF      lea d, [bp + -3] ; $j
0044   0444 2A            mov b, [d]
0045   0445 38 00 00      mov c, 0
0046   0448             ; --- START RELATIONAL
0047   0448 D7            push a
0048   0449 11            mov a, b
0049   044A FD 2E 50 00   mov32 cb, $00000050
0049   044E 00 00 
0050   0450 B0            cmp a, b
0051   0451 FD 73         slt ; < (signed)
0052   0453 E4            pop a
0053   0454             ; --- END RELATIONAL
0054   0454 C0 00 00      cmp b, 0
0055   0457 C6 7A 04      je _for2_exit
0056   045A             _for2_block:
0057   045A             ; putchar('#'); 
0058   045A             ; --- START FUNCTION CALL
0059   045A FD 2E 23 00   mov32 cb, $00000023
0059   045E 00 00 
0060   0460 DD            push bl
0061   0461 07 9C 04      call putchar
0062   0464 51 01 00      add sp, 1
0063   0467             ; --- END FUNCTION CALL
0064   0467             _for2_update:
0065   0467 FA FD FF      lea d, [bp + -3] ; $j
0066   046A 2A            mov b, [d]
0067   046B 38 00 00      mov c, 0
0068   046E 11            mov a, b
0069   046F FD 77         inc b
0070   0471 FA FD FF      lea d, [bp + -3] ; $j
0071   0474 FD 43         mov [d], b
0072   0476 27            mov b, a
0073   0477 0A 41 04      jmp _for2_cond
0074   047A             _for2_exit:
0075   047A             ; putchar('\n'); 
0076   047A             ; --- START FUNCTION CALL
0077   047A FD 2E 0A 00   mov32 cb, $0000000a
0077   047E 00 00 
0078   0480 DD            push bl
0079   0481 07 9C 04      call putchar
0080   0484 51 01 00      add sp, 1
0081   0487             ; --- END FUNCTION CALL
0082   0487             _for1_update:
0083   0487 FA FF FF      lea d, [bp + -1] ; $i
0084   048A 2A            mov b, [d]
0085   048B 38 00 00      mov c, 0
0086   048E 11            mov a, b
0087   048F FD 77         inc b
0088   0491 FA FF FF      lea d, [bp + -1] ; $i
0089   0494 FD 43         mov [d], b
0090   0496 27            mov b, a
0091   0497 0A 1B 04      jmp _for1_cond
0092   049A             _for1_exit:
0093   049A 05 0B         syscall sys_terminate_proc
0094   049C             
0095   049C             putchar:
0096   049C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0097   049F             ; --- BEGIN INLINE ASM SEGMENT
0098   049F FA 05 00      lea d, [bp + 5] ; $c
0099   04A2 1E            mov al, [d]
0100   04A3 23            mov ah, al
0101   04A4 19 00         mov al, 0
0102   04A6 05 03         syscall sys_io      
0103   04A8             ; --- END INLINE ASM SEGMENT
0104   04A8 F9            leave
0105   04A9 09            ret
0106   04AA             ; --- END TEXT SEGMENT
0107   04AA             
0108   04AA             ; --- BEGIN DATA SEGMENT
0109   04AA             
0110   04AA AC 04       _heap_top: .dw _heap
0111   04AC 00          _heap: .db 0
0112   04AD             ; --- END DATA SEGMENT
0113   04AD             
0114   04AD             .end
tasm: Number of errors = 0
