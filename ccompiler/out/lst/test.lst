0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; ++p; 
0011   0408 3B 54 21      mov d, _p ; $p
0012   040B 2B 02 00      mov b, [d+2]
0013   040E FD 39         mov c, b
0014   0410 2A            mov b, [d]
0015   0411 FD 77         inc b
0016   0413 3B 54 21      mov d, _p ; $p
0017   0416 FD 43         mov [d], b
0018   0418 28            mov b, c
0019   0419 FD 44 02 00   mov [d+2], b
0020   041D 05 0B         syscall sys_terminate_proc
0021   041F             
0022   041F             strcpy:
0023   041F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0024   0422             ; char *psrc; 
0025   0422 52 02 00      sub sp, 2
0026   0425             ; char *pdest; 
0027   0425 52 02 00      sub sp, 2
0028   0428             ; psrc = src; 
0029   0428 FA FF FF      lea d, [bp + -1] ; $psrc
0030   042B DA            push d
0031   042C FA 07 00      lea d, [bp + 7] ; $src
0032   042F 2A            mov b, [d]
0033   0430 38 00 00      mov c, 0
0034   0433 E7            pop d
0035   0434 FD 43         mov [d], b
0036   0436             ; pdest = dest; 
0037   0436 FA FD FF      lea d, [bp + -3] ; $pdest
0038   0439 DA            push d
0039   043A FA 05 00      lea d, [bp + 5] ; $dest
0040   043D 2A            mov b, [d]
0041   043E 38 00 00      mov c, 0
0042   0441 E7            pop d
0043   0442 FD 43         mov [d], b
0044   0444             ; while(*psrc) *pdest++ = *psrc++; 
0045   0444             _while1_cond:
0046   0444 FA FF FF      lea d, [bp + -1] ; $psrc
0047   0447 2A            mov b, [d]
0048   0448 38 00 00      mov c, 0
0049   044B 74            mov d, b
0050   044C 32            mov bl, [d]
0051   044D A7 00         mov bh, 0
0052   044F 38 00 00      mov c, 0
0053   0452 C0 00 00      cmp b, 0
0054   0455 C6 86 04      je _while1_exit
0055   0458             _while1_block:
0056   0458             ; *pdest++ = *psrc++; 
0057   0458 FA FD FF      lea d, [bp + -3] ; $pdest
0058   045B 2A            mov b, [d]
0059   045C 38 00 00      mov c, 0
0060   045F FD 77         inc b
0061   0461 FA FD FF      lea d, [bp + -3] ; $pdest
0062   0464 FD 43         mov [d], b
0063   0466 FD 7D         dec b
0064   0468 D8            push b
0065   0469 FA FF FF      lea d, [bp + -1] ; $psrc
0066   046C 2A            mov b, [d]
0067   046D 38 00 00      mov c, 0
0068   0470 FD 77         inc b
0069   0472 FA FF FF      lea d, [bp + -1] ; $psrc
0070   0475 FD 43         mov [d], b
0071   0477 FD 7D         dec b
0072   0479 74            mov d, b
0073   047A 32            mov bl, [d]
0074   047B A7 00         mov bh, 0
0075   047D 38 00 00      mov c, 0
0076   0480 E7            pop d
0077   0481 FD 3E         mov [d], bl
0078   0483 0A 44 04      jmp _while1_cond
0079   0486             _while1_exit:
0080   0486             ; *pdest = '\0'; 
0081   0486 FA FD FF      lea d, [bp + -3] ; $pdest
0082   0489 2A            mov b, [d]
0083   048A 38 00 00      mov c, 0
0084   048D D8            push b
0085   048E FD 2E 00 00   mov32 cb, $00000000
0085   0492 00 00 
0086   0494 E7            pop d
0087   0495 FD 3E         mov [d], bl
0088   0497 F9            leave
0089   0498 09            ret
0090   0499             
0091   0499             strcmp:
0092   0499 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0093   049C             ; while (*s1 && (*s1 == *s2)) { 
0094   049C             _while2_cond:
0095   049C FA 05 00      lea d, [bp + 5] ; $s1
0096   049F 2A            mov b, [d]
0097   04A0 38 00 00      mov c, 0
0098   04A3 74            mov d, b
0099   04A4 32            mov bl, [d]
0100   04A5 A7 00         mov bh, 0
0101   04A7 38 00 00      mov c, 0
0102   04AA             ; --- START LOGICAL AND
0103   04AA D7            push a
0104   04AB 11            mov a, b
0105   04AC FA 05 00      lea d, [bp + 5] ; $s1
0106   04AF 2A            mov b, [d]
0107   04B0 38 00 00      mov c, 0
0108   04B3 74            mov d, b
0109   04B4 32            mov bl, [d]
0110   04B5 A7 00         mov bh, 0
0111   04B7 38 00 00      mov c, 0
0112   04BA             ; --- START RELATIONAL
0113   04BA D7            push a
0114   04BB 11            mov a, b
0115   04BC FA 07 00      lea d, [bp + 7] ; $s2
0116   04BF 2A            mov b, [d]
0117   04C0 38 00 00      mov c, 0
0118   04C3 74            mov d, b
0119   04C4 32            mov bl, [d]
0120   04C5 A7 00         mov bh, 0
0121   04C7 38 00 00      mov c, 0
0122   04CA B0            cmp a, b
0123   04CB FD 71         seq ; ==
0124   04CD E4            pop a
0125   04CE             ; --- END RELATIONAL
0126   04CE FD A7         sand a, b
0127   04D0 E4            pop a
0128   04D1             ; --- END LOGICAL AND
0129   04D1 C0 00 00      cmp b, 0
0130   04D4 C6 FA 04      je _while2_exit
0131   04D7             _while2_block:
0132   04D7             ; s1++; 
0133   04D7 FA 05 00      lea d, [bp + 5] ; $s1
0134   04DA 2A            mov b, [d]
0135   04DB 38 00 00      mov c, 0
0136   04DE FD 77         inc b
0137   04E0 FA 05 00      lea d, [bp + 5] ; $s1
0138   04E3 FD 43         mov [d], b
0139   04E5 FD 7D         dec b
0140   04E7             ; s2++; 
0141   04E7 FA 07 00      lea d, [bp + 7] ; $s2
0142   04EA 2A            mov b, [d]
0143   04EB 38 00 00      mov c, 0
0144   04EE FD 77         inc b
0145   04F0 FA 07 00      lea d, [bp + 7] ; $s2
0146   04F3 FD 43         mov [d], b
0147   04F5 FD 7D         dec b
0148   04F7 0A 9C 04      jmp _while2_cond
0149   04FA             _while2_exit:
0150   04FA             ; return *s1 - *s2; 
0151   04FA FA 05 00      lea d, [bp + 5] ; $s1
0152   04FD 2A            mov b, [d]
0153   04FE 38 00 00      mov c, 0
0154   0501 74            mov d, b
0155   0502 32            mov bl, [d]
0156   0503 A7 00         mov bh, 0
0157   0505 38 00 00      mov c, 0
0158   0508             ; --- START TERMS
0159   0508 D7            push a
0160   0509 11            mov a, b
0161   050A FA 07 00      lea d, [bp + 7] ; $s2
0162   050D 2A            mov b, [d]
0163   050E 38 00 00      mov c, 0
0164   0511 74            mov d, b
0165   0512 32            mov bl, [d]
0166   0513 A7 00         mov bh, 0
0167   0515 38 00 00      mov c, 0
0168   0518 60            sub a, b
0169   0519 27            mov b, a
0170   051A E4            pop a
0171   051B             ; --- END TERMS
0172   051B F9            leave
0173   051C 09            ret
0174   051D             
0175   051D             strncmp:
0176   051D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0177   0520 F9            leave
0178   0521 09            ret
0179   0522             
0180   0522             strcat:
0181   0522 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0182   0525             ; int dest_len; 
0183   0525 52 02 00      sub sp, 2
0184   0528             ; int i; 
0185   0528 52 02 00      sub sp, 2
0186   052B             ; dest_len = strlen(dest); 
0187   052B FA FF FF      lea d, [bp + -1] ; $dest_len
0188   052E DA            push d
0189   052F             ; --- START FUNCTION CALL
0190   052F FA 05 00      lea d, [bp + 5] ; $dest
0191   0532 2A            mov b, [d]
0192   0533 38 00 00      mov c, 0
0193   0536 FD AB         swp b
0194   0538 D8            push b
0195   0539 07 05 06      call strlen
0196   053C 51 02 00      add sp, 2
0197   053F             ; --- END FUNCTION CALL
0198   053F E7            pop d
0199   0540 FD 43         mov [d], b
0200   0542             ; for (i = 0; src[i] != 0; i=i+1) { 
0201   0542             _for3_init:
0202   0542 FA FD FF      lea d, [bp + -3] ; $i
0203   0545 DA            push d
0204   0546 FD 2E 00 00   mov32 cb, $00000000
0204   054A 00 00 
0205   054C E7            pop d
0206   054D FD 43         mov [d], b
0207   054F             _for3_cond:
0208   054F FA 07 00      lea d, [bp + 7] ; $src
0209   0552 FD 2A         mov d, [d]
0210   0554 D7            push a
0211   0555 DA            push d
0212   0556 FA FD FF      lea d, [bp + -3] ; $i
0213   0559 2A            mov b, [d]
0214   055A 38 00 00      mov c, 0
0215   055D E7            pop d
0216   055E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0217   0562 E4            pop a
0218   0563 32            mov bl, [d]
0219   0564 A7 00         mov bh, 0
0220   0566 38 00 00      mov c, 0
0221   0569             ; --- START RELATIONAL
0222   0569 D7            push a
0223   056A 11            mov a, b
0224   056B FD 2E 00 00   mov32 cb, $00000000
0224   056F 00 00 
0225   0571 B0            cmp a, b
0226   0572 FD 72         sneq ; !=
0227   0574 E4            pop a
0228   0575             ; --- END RELATIONAL
0229   0575 C0 00 00      cmp b, 0
0230   0578 C6 D3 05      je _for3_exit
0231   057B             _for3_block:
0232   057B             ; dest[dest_len + i] = src[i]; 
0233   057B FA 05 00      lea d, [bp + 5] ; $dest
0234   057E FD 2A         mov d, [d]
0235   0580 D7            push a
0236   0581 DA            push d
0237   0582 FA FF FF      lea d, [bp + -1] ; $dest_len
0238   0585 2A            mov b, [d]
0239   0586 38 00 00      mov c, 0
0240   0589             ; --- START TERMS
0241   0589 D7            push a
0242   058A 11            mov a, b
0243   058B FA FD FF      lea d, [bp + -3] ; $i
0244   058E 2A            mov b, [d]
0245   058F 38 00 00      mov c, 0
0246   0592 56            add b, a
0247   0593 E4            pop a
0248   0594             ; --- END TERMS
0249   0594 E7            pop d
0250   0595 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0251   0599 E4            pop a
0252   059A DA            push d
0253   059B FA 07 00      lea d, [bp + 7] ; $src
0254   059E FD 2A         mov d, [d]
0255   05A0 D7            push a
0256   05A1 DA            push d
0257   05A2 FA FD FF      lea d, [bp + -3] ; $i
0258   05A5 2A            mov b, [d]
0259   05A6 38 00 00      mov c, 0
0260   05A9 E7            pop d
0261   05AA FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0262   05AE E4            pop a
0263   05AF 32            mov bl, [d]
0264   05B0 A7 00         mov bh, 0
0265   05B2 38 00 00      mov c, 0
0266   05B5 E7            pop d
0267   05B6 FD 3E         mov [d], bl
0268   05B8             _for3_update:
0269   05B8 FA FD FF      lea d, [bp + -3] ; $i
0270   05BB DA            push d
0271   05BC FA FD FF      lea d, [bp + -3] ; $i
0272   05BF 2A            mov b, [d]
0273   05C0 38 00 00      mov c, 0
0274   05C3             ; --- START TERMS
0275   05C3 D7            push a
0276   05C4 11            mov a, b
0277   05C5 FD 2E 01 00   mov32 cb, $00000001
0277   05C9 00 00 
0278   05CB 56            add b, a
0279   05CC E4            pop a
0280   05CD             ; --- END TERMS
0281   05CD E7            pop d
0282   05CE FD 43         mov [d], b
0283   05D0 0A 4F 05      jmp _for3_cond
0284   05D3             _for3_exit:
0285   05D3             ; dest[dest_len + i] = 0; 
0286   05D3 FA 05 00      lea d, [bp + 5] ; $dest
0287   05D6 FD 2A         mov d, [d]
0288   05D8 D7            push a
0289   05D9 DA            push d
0290   05DA FA FF FF      lea d, [bp + -1] ; $dest_len
0291   05DD 2A            mov b, [d]
0292   05DE 38 00 00      mov c, 0
0293   05E1             ; --- START TERMS
0294   05E1 D7            push a
0295   05E2 11            mov a, b
0296   05E3 FA FD FF      lea d, [bp + -3] ; $i
0297   05E6 2A            mov b, [d]
0298   05E7 38 00 00      mov c, 0
0299   05EA 56            add b, a
0300   05EB E4            pop a
0301   05EC             ; --- END TERMS
0302   05EC E7            pop d
0303   05ED FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0304   05F1 E4            pop a
0305   05F2 DA            push d
0306   05F3 FD 2E 00 00   mov32 cb, $00000000
0306   05F7 00 00 
0307   05F9 E7            pop d
0308   05FA FD 3E         mov [d], bl
0309   05FC             ; return dest; 
0310   05FC FA 05 00      lea d, [bp + 5] ; $dest
0311   05FF 2A            mov b, [d]
0312   0600 38 00 00      mov c, 0
0313   0603 F9            leave
0314   0604 09            ret
0315   0605             
0316   0605             strlen:
0317   0605 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0318   0608             ; int length; 
0319   0608 52 02 00      sub sp, 2
0320   060B             ; length = 0; 
0321   060B FA FF FF      lea d, [bp + -1] ; $length
0322   060E DA            push d
0323   060F FD 2E 00 00   mov32 cb, $00000000
0323   0613 00 00 
0324   0615 E7            pop d
0325   0616 FD 43         mov [d], b
0326   0618             ; while (str[length] != 0) { 
0327   0618             _while4_cond:
0328   0618 FA 05 00      lea d, [bp + 5] ; $str
0329   061B FD 2A         mov d, [d]
0330   061D D7            push a
0331   061E DA            push d
0332   061F FA FF FF      lea d, [bp + -1] ; $length
0333   0622 2A            mov b, [d]
0334   0623 38 00 00      mov c, 0
0335   0626 E7            pop d
0336   0627 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0337   062B E4            pop a
0338   062C 32            mov bl, [d]
0339   062D A7 00         mov bh, 0
0340   062F 38 00 00      mov c, 0
0341   0632             ; --- START RELATIONAL
0342   0632 D7            push a
0343   0633 11            mov a, b
0344   0634 FD 2E 00 00   mov32 cb, $00000000
0344   0638 00 00 
0345   063A B0            cmp a, b
0346   063B FD 72         sneq ; !=
0347   063D E4            pop a
0348   063E             ; --- END RELATIONAL
0349   063E C0 00 00      cmp b, 0
0350   0641 C6 57 06      je _while4_exit
0351   0644             _while4_block:
0352   0644             ; length++; 
0353   0644 FA FF FF      lea d, [bp + -1] ; $length
0354   0647 2A            mov b, [d]
0355   0648 38 00 00      mov c, 0
0356   064B FD 77         inc b
0357   064D FA FF FF      lea d, [bp + -1] ; $length
0358   0650 FD 43         mov [d], b
0359   0652 FD 7D         dec b
0360   0654 0A 18 06      jmp _while4_cond
0361   0657             _while4_exit:
0362   0657             ; return length; 
0363   0657 FA FF FF      lea d, [bp + -1] ; $length
0364   065A 2A            mov b, [d]
0365   065B 38 00 00      mov c, 0
0366   065E F9            leave
0367   065F 09            ret
0368   0660             
0369   0660             exit:
0370   0660 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0371   0663             
0372   0663             ; --- BEGIN INLINE ASM SEGMENT
0373   0663 05 0B         syscall sys_terminate_proc
0374   0665             ; --- END INLINE ASM SEGMENT
0375   0665             
0376   0665 F9            leave
0377   0666 09            ret
0378   0667             
0379   0667             memset:
0380   0667 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0381   066A             ; int i; 
0382   066A 52 02 00      sub sp, 2
0383   066D             ; for(i = 0; i < size; i++){ 
0384   066D             _for5_init:
0385   066D FA FF FF      lea d, [bp + -1] ; $i
0386   0670 DA            push d
0387   0671 FD 2E 00 00   mov32 cb, $00000000
0387   0675 00 00 
0388   0677 E7            pop d
0389   0678 FD 43         mov [d], b
0390   067A             _for5_cond:
0391   067A FA FF FF      lea d, [bp + -1] ; $i
0392   067D 2A            mov b, [d]
0393   067E 38 00 00      mov c, 0
0394   0681             ; --- START RELATIONAL
0395   0681 D7            push a
0396   0682 11            mov a, b
0397   0683 FA 08 00      lea d, [bp + 8] ; $size
0398   0686 2A            mov b, [d]
0399   0687 38 00 00      mov c, 0
0400   068A B0            cmp a, b
0401   068B FD 73         slt ; < (signed)
0402   068D E4            pop a
0403   068E             ; --- END RELATIONAL
0404   068E C0 00 00      cmp b, 0
0405   0691 C6 C6 06      je _for5_exit
0406   0694             _for5_block:
0407   0694             ; *(s+i) = c; 
0408   0694 FA 05 00      lea d, [bp + 5] ; $s
0409   0697 2A            mov b, [d]
0410   0698 38 00 00      mov c, 0
0411   069B             ; --- START TERMS
0412   069B D7            push a
0413   069C 11            mov a, b
0414   069D FA FF FF      lea d, [bp + -1] ; $i
0415   06A0 2A            mov b, [d]
0416   06A1 38 00 00      mov c, 0
0417   06A4 56            add b, a
0418   06A5 E4            pop a
0419   06A6             ; --- END TERMS
0420   06A6 D8            push b
0421   06A7 FA 07 00      lea d, [bp + 7] ; $c
0422   06AA 32            mov bl, [d]
0423   06AB A7 00         mov bh, 0
0424   06AD 38 00 00      mov c, 0
0425   06B0 E7            pop d
0426   06B1 FD 3E         mov [d], bl
0427   06B3             _for5_update:
0428   06B3 FA FF FF      lea d, [bp + -1] ; $i
0429   06B6 2A            mov b, [d]
0430   06B7 38 00 00      mov c, 0
0431   06BA FD 77         inc b
0432   06BC FA FF FF      lea d, [bp + -1] ; $i
0433   06BF FD 43         mov [d], b
0434   06C1 FD 7D         dec b
0435   06C3 0A 7A 06      jmp _for5_cond
0436   06C6             _for5_exit:
0437   06C6             ; return s; 
0438   06C6 FA 05 00      lea d, [bp + 5] ; $s
0439   06C9 2A            mov b, [d]
0440   06CA 38 00 00      mov c, 0
0441   06CD F9            leave
0442   06CE 09            ret
0443   06CF             
0444   06CF             atoi:
0445   06CF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0446   06D2             ; int result = 0;  // Initialize result 
0447   06D2 52 02 00      sub sp, 2
0448   06D5             ; --- START LOCAL VAR INITIALIZATION
0449   06D5 FA FF FF      lea d, [bp + -1] ; $result
0450   06D8 DA            push d
0451   06D9 FD 2E 00 00   mov32 cb, $00000000
0451   06DD 00 00 
0452   06DF E7            pop d
0453   06E0 FD 43         mov [d], b
0454   06E2             ; --- END LOCAL VAR INITIALIZATION
0455   06E2             ; int sign = 1;    // Initialize sign as positive 
0456   06E2 52 02 00      sub sp, 2
0457   06E5             ; --- START LOCAL VAR INITIALIZATION
0458   06E5 FA FD FF      lea d, [bp + -3] ; $sign
0459   06E8 DA            push d
0460   06E9 FD 2E 01 00   mov32 cb, $00000001
0460   06ED 00 00 
0461   06EF E7            pop d
0462   06F0 FD 43         mov [d], b
0463   06F2             ; --- END LOCAL VAR INITIALIZATION
0464   06F2             ; while (*str == ' ') str++; 
0465   06F2             _while6_cond:
0466   06F2 FA 05 00      lea d, [bp + 5] ; $str
0467   06F5 2A            mov b, [d]
0468   06F6 38 00 00      mov c, 0
0469   06F9 74            mov d, b
0470   06FA 32            mov bl, [d]
0471   06FB A7 00         mov bh, 0
0472   06FD 38 00 00      mov c, 0
0473   0700             ; --- START RELATIONAL
0474   0700 D7            push a
0475   0701 11            mov a, b
0476   0702 FD 2E 20 00   mov32 cb, $00000020
0476   0706 00 00 
0477   0708 B0            cmp a, b
0478   0709 FD 71         seq ; ==
0479   070B E4            pop a
0480   070C             ; --- END RELATIONAL
0481   070C C0 00 00      cmp b, 0
0482   070F C6 25 07      je _while6_exit
0483   0712             _while6_block:
0484   0712             ; str++; 
0485   0712 FA 05 00      lea d, [bp + 5] ; $str
0486   0715 2A            mov b, [d]
0487   0716 38 00 00      mov c, 0
0488   0719 FD 77         inc b
0489   071B FA 05 00      lea d, [bp + 5] ; $str
0490   071E FD 43         mov [d], b
0491   0720 FD 7D         dec b
0492   0722 0A F2 06      jmp _while6_cond
0493   0725             _while6_exit:
0494   0725             ; if (*str == '-' || *str == '+') { 
0495   0725             _if7_cond:
0496   0725 FA 05 00      lea d, [bp + 5] ; $str
0497   0728 2A            mov b, [d]
0498   0729 38 00 00      mov c, 0
0499   072C 74            mov d, b
0500   072D 32            mov bl, [d]
0501   072E A7 00         mov bh, 0
0502   0730 38 00 00      mov c, 0
0503   0733             ; --- START RELATIONAL
0504   0733 D7            push a
0505   0734 11            mov a, b
0506   0735 FD 2E 2D 00   mov32 cb, $0000002d
0506   0739 00 00 
0507   073B B0            cmp a, b
0508   073C FD 71         seq ; ==
0509   073E E4            pop a
0510   073F             ; --- END RELATIONAL
0511   073F             ; --- START LOGICAL OR
0512   073F D7            push a
0513   0740 11            mov a, b
0514   0741 FA 05 00      lea d, [bp + 5] ; $str
0515   0744 2A            mov b, [d]
0516   0745 38 00 00      mov c, 0
0517   0748 74            mov d, b
0518   0749 32            mov bl, [d]
0519   074A A7 00         mov bh, 0
0520   074C 38 00 00      mov c, 0
0521   074F             ; --- START RELATIONAL
0522   074F D7            push a
0523   0750 11            mov a, b
0524   0751 FD 2E 2B 00   mov32 cb, $0000002b
0524   0755 00 00 
0525   0757 B0            cmp a, b
0526   0758 FD 71         seq ; ==
0527   075A E4            pop a
0528   075B             ; --- END RELATIONAL
0529   075B FD A8         sor a, b ; ||
0530   075D E4            pop a
0531   075E             ; --- END LOGICAL OR
0532   075E C0 00 00      cmp b, 0
0533   0761 C6 A9 07      je _if7_exit
0534   0764             _if7_true:
0535   0764             ; if (*str == '-') sign = -1; 
0536   0764             _if8_cond:
0537   0764 FA 05 00      lea d, [bp + 5] ; $str
0538   0767 2A            mov b, [d]
0539   0768 38 00 00      mov c, 0
0540   076B 74            mov d, b
0541   076C 32            mov bl, [d]
0542   076D A7 00         mov bh, 0
0543   076F 38 00 00      mov c, 0
0544   0772             ; --- START RELATIONAL
0545   0772 D7            push a
0546   0773 11            mov a, b
0547   0774 FD 2E 2D 00   mov32 cb, $0000002d
0547   0778 00 00 
0548   077A B0            cmp a, b
0549   077B FD 71         seq ; ==
0550   077D E4            pop a
0551   077E             ; --- END RELATIONAL
0552   077E C0 00 00      cmp b, 0
0553   0781 C6 96 07      je _if8_exit
0554   0784             _if8_true:
0555   0784             ; sign = -1; 
0556   0784 FA FD FF      lea d, [bp + -3] ; $sign
0557   0787 DA            push d
0558   0788 FD 2E 01 00   mov32 cb, $00000001
0558   078C 00 00 
0559   078E FD 97         neg b
0560   0790 E7            pop d
0561   0791 FD 43         mov [d], b
0562   0793 0A 96 07      jmp _if8_exit
0563   0796             _if8_exit:
0564   0796             ; str++; 
0565   0796 FA 05 00      lea d, [bp + 5] ; $str
0566   0799 2A            mov b, [d]
0567   079A 38 00 00      mov c, 0
0568   079D FD 77         inc b
0569   079F FA 05 00      lea d, [bp + 5] ; $str
0570   07A2 FD 43         mov [d], b
0571   07A4 FD 7D         dec b
0572   07A6 0A A9 07      jmp _if7_exit
0573   07A9             _if7_exit:
0574   07A9             ; while (*str >= '0' && *str <= '9') { 
0575   07A9             _while9_cond:
0576   07A9 FA 05 00      lea d, [bp + 5] ; $str
0577   07AC 2A            mov b, [d]
0578   07AD 38 00 00      mov c, 0
0579   07B0 74            mov d, b
0580   07B1 32            mov bl, [d]
0581   07B2 A7 00         mov bh, 0
0582   07B4 38 00 00      mov c, 0
0583   07B7             ; --- START RELATIONAL
0584   07B7 D7            push a
0585   07B8 11            mov a, b
0586   07B9 FD 2E 30 00   mov32 cb, $00000030
0586   07BD 00 00 
0587   07BF B0            cmp a, b
0588   07C0 FD 82         sgeu ; >= (unsigned)
0589   07C2 E4            pop a
0590   07C3             ; --- END RELATIONAL
0591   07C3             ; --- START LOGICAL AND
0592   07C3 D7            push a
0593   07C4 11            mov a, b
0594   07C5 FA 05 00      lea d, [bp + 5] ; $str
0595   07C8 2A            mov b, [d]
0596   07C9 38 00 00      mov c, 0
0597   07CC 74            mov d, b
0598   07CD 32            mov bl, [d]
0599   07CE A7 00         mov bh, 0
0600   07D0 38 00 00      mov c, 0
0601   07D3             ; --- START RELATIONAL
0602   07D3 D7            push a
0603   07D4 11            mov a, b
0604   07D5 FD 2E 39 00   mov32 cb, $00000039
0604   07D9 00 00 
0605   07DB B0            cmp a, b
0606   07DC FD 76         sleu ; <= (unsigned)
0607   07DE E4            pop a
0608   07DF             ; --- END RELATIONAL
0609   07DF FD A7         sand a, b
0610   07E1 E4            pop a
0611   07E2             ; --- END LOGICAL AND
0612   07E2 C0 00 00      cmp b, 0
0613   07E5 C6 32 08      je _while9_exit
0614   07E8             _while9_block:
0615   07E8             ; result = result * 10 + (*str - '0'); 
0616   07E8 FA FF FF      lea d, [bp + -1] ; $result
0617   07EB DA            push d
0618   07EC FA FF FF      lea d, [bp + -1] ; $result
0619   07EF 2A            mov b, [d]
0620   07F0 38 00 00      mov c, 0
0621   07F3             ; --- START FACTORS
0622   07F3 D7            push a
0623   07F4 11            mov a, b
0624   07F5 FD 2E 0A 00   mov32 cb, $0000000a
0624   07F9 00 00 
0625   07FB AC            mul a, b ; *
0626   07FC 11            mov a, b
0627   07FD 27            mov b, a
0628   07FE E4            pop a
0629   07FF             ; --- END FACTORS
0630   07FF             ; --- START TERMS
0631   07FF D7            push a
0632   0800 11            mov a, b
0633   0801 FA 05 00      lea d, [bp + 5] ; $str
0634   0804 2A            mov b, [d]
0635   0805 38 00 00      mov c, 0
0636   0808 74            mov d, b
0637   0809 32            mov bl, [d]
0638   080A A7 00         mov bh, 0
0639   080C 38 00 00      mov c, 0
0640   080F             ; --- START TERMS
0641   080F D7            push a
0642   0810 11            mov a, b
0643   0811 FD 2E 30 00   mov32 cb, $00000030
0643   0815 00 00 
0644   0817 60            sub a, b
0645   0818 27            mov b, a
0646   0819 E4            pop a
0647   081A             ; --- END TERMS
0648   081A 56            add b, a
0649   081B E4            pop a
0650   081C             ; --- END TERMS
0651   081C E7            pop d
0652   081D FD 43         mov [d], b
0653   081F             ; str++; 
0654   081F FA 05 00      lea d, [bp + 5] ; $str
0655   0822 2A            mov b, [d]
0656   0823 38 00 00      mov c, 0
0657   0826 FD 77         inc b
0658   0828 FA 05 00      lea d, [bp + 5] ; $str
0659   082B FD 43         mov [d], b
0660   082D FD 7D         dec b
0661   082F 0A A9 07      jmp _while9_cond
0662   0832             _while9_exit:
0663   0832             ; return sign * result; 
0664   0832 FA FD FF      lea d, [bp + -3] ; $sign
0665   0835 2A            mov b, [d]
0666   0836 38 00 00      mov c, 0
0667   0839             ; --- START FACTORS
0668   0839 D7            push a
0669   083A 11            mov a, b
0670   083B FA FF FF      lea d, [bp + -1] ; $result
0671   083E 2A            mov b, [d]
0672   083F 38 00 00      mov c, 0
0673   0842 AC            mul a, b ; *
0674   0843 11            mov a, b
0675   0844 27            mov b, a
0676   0845 E4            pop a
0677   0846             ; --- END FACTORS
0678   0846 F9            leave
0679   0847 09            ret
0680   0848             
0681   0848             rand:
0682   0848 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0683   084B             ; int  sec; 
0684   084B 52 02 00      sub sp, 2
0685   084E             
0686   084E             ; --- BEGIN INLINE ASM SEGMENT
0687   084E 19 00         mov al, 0
0688   0850 05 01         syscall sys_rtc					
0689   0852 1A            mov al, ah
0690   0853 FA FF FF      lea d, [bp + -1] ; $sec
0691   0856 1E            mov al, [d]
0692   0857 22 00         mov ah, 0
0693   0859             ; --- END INLINE ASM SEGMENT
0694   0859             
0695   0859             ; return sec; 
0696   0859 FA FF FF      lea d, [bp + -1] ; $sec
0697   085C 2A            mov b, [d]
0698   085D 38 00 00      mov c, 0
0699   0860 F9            leave
0700   0861 09            ret
0701   0862             
0702   0862             alloc:
0703   0862 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0704   0865             ; heap_top = heap_top + bytes; 
0705   0865 3B 9E 21      mov d, _heap_top ; $heap_top
0706   0868 DA            push d
0707   0869 3B 9E 21      mov d, _heap_top ; $heap_top
0708   086C 2A            mov b, [d]
0709   086D 38 00 00      mov c, 0
0710   0870             ; --- START TERMS
0711   0870 D7            push a
0712   0871 11            mov a, b
0713   0872 FA 05 00      lea d, [bp + 5] ; $bytes
0714   0875 2A            mov b, [d]
0715   0876 38 00 00      mov c, 0
0716   0879 56            add b, a
0717   087A E4            pop a
0718   087B             ; --- END TERMS
0719   087B E7            pop d
0720   087C FD 43         mov [d], b
0721   087E             ; return heap_top - bytes; 
0722   087E 3B 9E 21      mov d, _heap_top ; $heap_top
0723   0881 2A            mov b, [d]
0724   0882 38 00 00      mov c, 0
0725   0885             ; --- START TERMS
0726   0885 D7            push a
0727   0886 11            mov a, b
0728   0887 FA 05 00      lea d, [bp + 5] ; $bytes
0729   088A 2A            mov b, [d]
0730   088B 38 00 00      mov c, 0
0731   088E 60            sub a, b
0732   088F 27            mov b, a
0733   0890 E4            pop a
0734   0891             ; --- END TERMS
0735   0891 F9            leave
0736   0892 09            ret
0737   0893             
0738   0893             free:
0739   0893 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0740   0896             ; return heap_top = heap_top - bytes; 
0741   0896 3B 9E 21      mov d, _heap_top ; $heap_top
0742   0899 DA            push d
0743   089A 3B 9E 21      mov d, _heap_top ; $heap_top
0744   089D 2A            mov b, [d]
0745   089E 38 00 00      mov c, 0
0746   08A1             ; --- START TERMS
0747   08A1 D7            push a
0748   08A2 11            mov a, b
0749   08A3 FA 05 00      lea d, [bp + 5] ; $bytes
0750   08A6 2A            mov b, [d]
0751   08A7 38 00 00      mov c, 0
0752   08AA 60            sub a, b
0753   08AB 27            mov b, a
0754   08AC E4            pop a
0755   08AD             ; --- END TERMS
0756   08AD E7            pop d
0757   08AE FD 43         mov [d], b
0758   08B0 F9            leave
0759   08B1 09            ret
0760   08B2             
0761   08B2             fopen:
0762   08B2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0763   08B5             ; FILE *fp; 
0764   08B5 52 02 00      sub sp, 2
0765   08B8             ; static int max_handle = 0; 
0766   08B8 52 02 00      sub sp, 2
0767   08BB             ; fp = alloc(sizeof(FILE)); 
0768   08BB FA FF FF      lea d, [bp + -1] ; $fp
0769   08BE DA            push d
0770   08BF             ; --- START FUNCTION CALL
0771   08BF 26 04 01      mov b, 260
0772   08C2 FD AB         swp b
0773   08C4 D8            push b
0774   08C5 07 62 08      call alloc
0775   08C8 51 02 00      add sp, 2
0776   08CB             ; --- END FUNCTION CALL
0777   08CB E7            pop d
0778   08CC FD 43         mov [d], b
0779   08CE             ; strcpy(fp->filename, filename); 
0780   08CE             ; --- START FUNCTION CALL
0781   08CE FA 05 00      lea d, [bp + 5] ; $filename
0782   08D1 2A            mov b, [d]
0783   08D2 38 00 00      mov c, 0
0784   08D5 FD AB         swp b
0785   08D7 D8            push b
0786   08D8 FA FF FF      lea d, [bp + -1] ; $fp
0787   08DB FD 2A         mov d, [d]
0788   08DD 58 02 00      add d, 2
0789   08E0 2D            mov b, d
0790   08E1 38 00 00      mov c, 0
0791   08E4 FD AB         swp b
0792   08E6 D8            push b
0793   08E7 07 1F 04      call strcpy
0794   08EA 51 04 00      add sp, 4
0795   08ED             ; --- END FUNCTION CALL
0796   08ED             ; fp->handle = max_handle; 
0797   08ED FA FF FF      lea d, [bp + -1] ; $fp
0798   08F0 FD 2A         mov d, [d]
0799   08F2 58 00 00      add d, 0
0800   08F5 DA            push d
0801   08F6 3B 58 21      mov d, st_fopen_max_handle ; static max_handle
0802   08F9 2A            mov b, [d]
0803   08FA 38 00 00      mov c, 0
0804   08FD E7            pop d
0805   08FE FD 43         mov [d], b
0806   0900             ; fp->mode = mode; 
0807   0900 FA FF FF      lea d, [bp + -1] ; $fp
0808   0903 FD 2A         mov d, [d]
0809   0905 58 02 01      add d, 258
0810   0908 DA            push d
0811   0909 FA 07 00      lea d, [bp + 7] ; $mode
0812   090C 32            mov bl, [d]
0813   090D A7 00         mov bh, 0
0814   090F 38 00 00      mov c, 0
0815   0912 E7            pop d
0816   0913 FD 3E         mov [d], bl
0817   0915             ; fp->loc = 0; 
0818   0915 FA FF FF      lea d, [bp + -1] ; $fp
0819   0918 FD 2A         mov d, [d]
0820   091A 58 03 01      add d, 259
0821   091D DA            push d
0822   091E FD 2E 00 00   mov32 cb, $00000000
0822   0922 00 00 
0823   0924 E7            pop d
0824   0925 FD 3E         mov [d], bl
0825   0927             ; max_handle++; 
0826   0927 3B 58 21      mov d, st_fopen_max_handle ; static max_handle
0827   092A 2A            mov b, [d]
0828   092B 38 00 00      mov c, 0
0829   092E FD 77         inc b
0830   0930 3B 58 21      mov d, st_fopen_max_handle ; static max_handle
0831   0933 FD 43         mov [d], b
0832   0935 FD 7D         dec b
0833   0937 F9            leave
0834   0938 09            ret
0835   0939             
0836   0939             fclose:
0837   0939 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0838   093C             ; free(sizeof(FILE)); 
0839   093C             ; --- START FUNCTION CALL
0840   093C 26 04 01      mov b, 260
0841   093F FD AB         swp b
0842   0941 D8            push b
0843   0942 07 93 08      call free
0844   0945 51 02 00      add sp, 2
0845   0948             ; --- END FUNCTION CALL
0846   0948 F9            leave
0847   0949 09            ret
0848   094A             
0849   094A             printf:
0850   094A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0851   094D             ; char *p, *format_p; 
0852   094D 52 02 00      sub sp, 2
0853   0950 52 02 00      sub sp, 2
0854   0953             ; format_p = format; 
0855   0953 FA FD FF      lea d, [bp + -3] ; $format_p
0856   0956 DA            push d
0857   0957 FA 05 00      lea d, [bp + 5] ; $format
0858   095A 2A            mov b, [d]
0859   095B 38 00 00      mov c, 0
0860   095E E7            pop d
0861   095F FD 43         mov [d], b
0862   0961             ; p = &format + 2; 
0863   0961 FA FF FF      lea d, [bp + -1] ; $p
0864   0964 DA            push d
0865   0965 FA 05 00      lea d, [bp + 5] ; $format
0866   0968 2D            mov b, d
0867   0969             ; --- START TERMS
0868   0969 D7            push a
0869   096A 11            mov a, b
0870   096B FD 2E 02 00   mov32 cb, $00000002
0870   096F 00 00 
0871   0971 56            add b, a
0872   0972 E4            pop a
0873   0973             ; --- END TERMS
0874   0973 E7            pop d
0875   0974 FD 43         mov [d], b
0876   0976             ; for(;;){ 
0877   0976             _for10_init:
0878   0976             _for10_cond:
0879   0976             _for10_block:
0880   0976             ; if(!*format_p) break; 
0881   0976             _if11_cond:
0882   0976 FA FD FF      lea d, [bp + -3] ; $format_p
0883   0979 2A            mov b, [d]
0884   097A 38 00 00      mov c, 0
0885   097D 74            mov d, b
0886   097E 32            mov bl, [d]
0887   097F A7 00         mov bh, 0
0888   0981 38 00 00      mov c, 0
0889   0984 C0 00 00      cmp b, 0
0890   0987 FD 71         seq ; !
0891   0989 C0 00 00      cmp b, 0
0892   098C C6 95 09      je _if11_else
0893   098F             _if11_true:
0894   098F             ; break; 
0895   098F 0A 26 0C      jmp _for10_exit ; for break
0896   0992 0A 23 0C      jmp _if11_exit
0897   0995             _if11_else:
0898   0995             ; if(*format_p == '%'){ 
0899   0995             _if12_cond:
0900   0995 FA FD FF      lea d, [bp + -3] ; $format_p
0901   0998 2A            mov b, [d]
0902   0999 38 00 00      mov c, 0
0903   099C 74            mov d, b
0904   099D 32            mov bl, [d]
0905   099E A7 00         mov bh, 0
0906   09A0 38 00 00      mov c, 0
0907   09A3             ; --- START RELATIONAL
0908   09A3 D7            push a
0909   09A4 11            mov a, b
0910   09A5 FD 2E 25 00   mov32 cb, $00000025
0910   09A9 00 00 
0911   09AB B0            cmp a, b
0912   09AC FD 71         seq ; ==
0913   09AE E4            pop a
0914   09AF             ; --- END RELATIONAL
0915   09AF C0 00 00      cmp b, 0
0916   09B2 C6 FE 0B      je _if12_else
0917   09B5             _if12_true:
0918   09B5             ; format_p++; 
0919   09B5 FA FD FF      lea d, [bp + -3] ; $format_p
0920   09B8 2A            mov b, [d]
0921   09B9 38 00 00      mov c, 0
0922   09BC FD 77         inc b
0923   09BE FA FD FF      lea d, [bp + -3] ; $format_p
0924   09C1 FD 43         mov [d], b
0925   09C3 FD 7D         dec b
0926   09C5             ; switch(*format_p){ 
0927   09C5             _switch13_expr:
0928   09C5 FA FD FF      lea d, [bp + -3] ; $format_p
0929   09C8 2A            mov b, [d]
0930   09C9 38 00 00      mov c, 0
0931   09CC 74            mov d, b
0932   09CD 32            mov bl, [d]
0933   09CE A7 00         mov bh, 0
0934   09D0 38 00 00      mov c, 0
0935   09D3             _switch13_comparisons:
0936   09D3 C1 6C         cmp bl, $6c
0937   09D5 C6 01 0A      je _switch13_case0
0938   09D8 C1 4C         cmp bl, $4c
0939   09DA C6 01 0A      je _switch13_case1
0940   09DD C1 64         cmp bl, $64
0941   09DF C6 11 0B      je _switch13_case2
0942   09E2 C1 69         cmp bl, $69
0943   09E4 C6 11 0B      je _switch13_case3
0944   09E7 C1 75         cmp bl, $75
0945   09E9 C6 41 0B      je _switch13_case4
0946   09EC C1 78         cmp bl, $78
0947   09EE C6 71 0B      je _switch13_case5
0948   09F1 C1 63         cmp bl, $63
0949   09F3 C6 95 0B      je _switch13_case6
0950   09F6 C1 73         cmp bl, $73
0951   09F8 C6 BA 0B      je _switch13_case7
0952   09FB 0A DF 0B      jmp _switch13_default
0953   09FE 0A EB 0B      jmp _switch13_exit
0954   0A01             _switch13_case0:
0955   0A01             _switch13_case1:
0956   0A01             ; format_p++; 
0957   0A01 FA FD FF      lea d, [bp + -3] ; $format_p
0958   0A04 2A            mov b, [d]
0959   0A05 38 00 00      mov c, 0
0960   0A08 FD 77         inc b
0961   0A0A FA FD FF      lea d, [bp + -3] ; $format_p
0962   0A0D FD 43         mov [d], b
0963   0A0F FD 7D         dec b
0964   0A11             ; if(*format_p == 'd' || *format_p == 'i') 
0965   0A11             _if14_cond:
0966   0A11 FA FD FF      lea d, [bp + -3] ; $format_p
0967   0A14 2A            mov b, [d]
0968   0A15 38 00 00      mov c, 0
0969   0A18 74            mov d, b
0970   0A19 32            mov bl, [d]
0971   0A1A A7 00         mov bh, 0
0972   0A1C 38 00 00      mov c, 0
0973   0A1F             ; --- START RELATIONAL
0974   0A1F D7            push a
0975   0A20 11            mov a, b
0976   0A21 FD 2E 64 00   mov32 cb, $00000064
0976   0A25 00 00 
0977   0A27 B0            cmp a, b
0978   0A28 FD 71         seq ; ==
0979   0A2A E4            pop a
0980   0A2B             ; --- END RELATIONAL
0981   0A2B             ; --- START LOGICAL OR
0982   0A2B D7            push a
0983   0A2C 11            mov a, b
0984   0A2D FA FD FF      lea d, [bp + -3] ; $format_p
0985   0A30 2A            mov b, [d]
0986   0A31 38 00 00      mov c, 0
0987   0A34 74            mov d, b
0988   0A35 32            mov bl, [d]
0989   0A36 A7 00         mov bh, 0
0990   0A38 38 00 00      mov c, 0
0991   0A3B             ; --- START RELATIONAL
0992   0A3B D7            push a
0993   0A3C 11            mov a, b
0994   0A3D FD 2E 69 00   mov32 cb, $00000069
0994   0A41 00 00 
0995   0A43 B0            cmp a, b
0996   0A44 FD 71         seq ; ==
0997   0A46 E4            pop a
0998   0A47             ; --- END RELATIONAL
0999   0A47 FD A8         sor a, b ; ||
1000   0A49 E4            pop a
1001   0A4A             ; --- END LOGICAL OR
1002   0A4A C0 00 00      cmp b, 0
1003   0A4D C6 6E 0A      je _if14_else
1004   0A50             _if14_true:
1005   0A50             ; print_signed_long(*(long *)p); 
1006   0A50             ; --- START FUNCTION CALL
1007   0A50 FA FF FF      lea d, [bp + -1] ; $p
1008   0A53 2A            mov b, [d]
1009   0A54 38 00 00      mov c, 0
1010   0A57 74            mov d, b
1011   0A58 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1012   0A5B FD 39         mov c, b ; And place it into C
1013   0A5D 2A            mov b, [d] ; Lower Word in B
1014   0A5E 12            mov a, c
1015   0A5F FD AA         swp a
1016   0A61 D7            push a
1017   0A62 FD AB         swp b
1018   0A64 D8            push b
1019   0A65 07 F8 15      call print_signed_long
1020   0A68 51 04 00      add sp, 4
1021   0A6B             ; --- END FUNCTION CALL
1022   0A6B 0A F6 0A      jmp _if14_exit
1023   0A6E             _if14_else:
1024   0A6E             ; if(*format_p == 'u') 
1025   0A6E             _if15_cond:
1026   0A6E FA FD FF      lea d, [bp + -3] ; $format_p
1027   0A71 2A            mov b, [d]
1028   0A72 38 00 00      mov c, 0
1029   0A75 74            mov d, b
1030   0A76 32            mov bl, [d]
1031   0A77 A7 00         mov bh, 0
1032   0A79 38 00 00      mov c, 0
1033   0A7C             ; --- START RELATIONAL
1034   0A7C D7            push a
1035   0A7D 11            mov a, b
1036   0A7E FD 2E 75 00   mov32 cb, $00000075
1036   0A82 00 00 
1037   0A84 B0            cmp a, b
1038   0A85 FD 71         seq ; ==
1039   0A87 E4            pop a
1040   0A88             ; --- END RELATIONAL
1041   0A88 C0 00 00      cmp b, 0
1042   0A8B C6 AC 0A      je _if15_else
1043   0A8E             _if15_true:
1044   0A8E             ; print_unsigned_long(*(unsigned long *)p); 
1045   0A8E             ; --- START FUNCTION CALL
1046   0A8E FA FF FF      lea d, [bp + -1] ; $p
1047   0A91 2A            mov b, [d]
1048   0A92 38 00 00      mov c, 0
1049   0A95 74            mov d, b
1050   0A96 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1051   0A99 FD 39         mov c, b ; And place it into C
1052   0A9B 2A            mov b, [d] ; Lower Word in B
1053   0A9C 12            mov a, c
1054   0A9D FD AA         swp a
1055   0A9F D7            push a
1056   0AA0 FD AB         swp b
1057   0AA2 D8            push b
1058   0AA3 07 67 17      call print_unsigned_long
1059   0AA6 51 04 00      add sp, 4
1060   0AA9             ; --- END FUNCTION CALL
1061   0AA9 0A F6 0A      jmp _if15_exit
1062   0AAC             _if15_else:
1063   0AAC             ; if(*format_p == 'x') 
1064   0AAC             _if16_cond:
1065   0AAC FA FD FF      lea d, [bp + -3] ; $format_p
1066   0AAF 2A            mov b, [d]
1067   0AB0 38 00 00      mov c, 0
1068   0AB3 74            mov d, b
1069   0AB4 32            mov bl, [d]
1070   0AB5 A7 00         mov bh, 0
1071   0AB7 38 00 00      mov c, 0
1072   0ABA             ; --- START RELATIONAL
1073   0ABA D7            push a
1074   0ABB 11            mov a, b
1075   0ABC FD 2E 78 00   mov32 cb, $00000078
1075   0AC0 00 00 
1076   0AC2 B0            cmp a, b
1077   0AC3 FD 71         seq ; ==
1078   0AC5 E4            pop a
1079   0AC6             ; --- END RELATIONAL
1080   0AC6 C0 00 00      cmp b, 0
1081   0AC9 C6 EA 0A      je _if16_else
1082   0ACC             _if16_true:
1083   0ACC             ; printx32(*(long int *)p); 
1084   0ACC             ; --- START FUNCTION CALL
1085   0ACC FA FF FF      lea d, [bp + -1] ; $p
1086   0ACF 2A            mov b, [d]
1087   0AD0 38 00 00      mov c, 0
1088   0AD3 74            mov d, b
1089   0AD4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1090   0AD7 FD 39         mov c, b ; And place it into C
1091   0AD9 2A            mov b, [d] ; Lower Word in B
1092   0ADA 12            mov a, c
1093   0ADB FD AA         swp a
1094   0ADD D7            push a
1095   0ADE FD AB         swp b
1096   0AE0 D8            push b
1097   0AE1 07 CB 12      call printx32
1098   0AE4 51 04 00      add sp, 4
1099   0AE7             ; --- END FUNCTION CALL
1100   0AE7 0A F6 0A      jmp _if16_exit
1101   0AEA             _if16_else:
1102   0AEA             ; err("Unexpected format in printf."); 
1103   0AEA             ; --- START FUNCTION CALL
1104   0AEA 26 5A 21      mov b, _s0 ; "Unexpected format in printf."
1105   0AED FD AB         swp b
1106   0AEF D8            push b
1107   0AF0 07 B6 12      call err
1108   0AF3 51 02 00      add sp, 2
1109   0AF6             ; --- END FUNCTION CALL
1110   0AF6             _if16_exit:
1111   0AF6             _if15_exit:
1112   0AF6             _if14_exit:
1113   0AF6             ; p = p + 4; 
1114   0AF6 FA FF FF      lea d, [bp + -1] ; $p
1115   0AF9 DA            push d
1116   0AFA FA FF FF      lea d, [bp + -1] ; $p
1117   0AFD 2A            mov b, [d]
1118   0AFE 38 00 00      mov c, 0
1119   0B01             ; --- START TERMS
1120   0B01 D7            push a
1121   0B02 11            mov a, b
1122   0B03 FD 2E 04 00   mov32 cb, $00000004
1122   0B07 00 00 
1123   0B09 56            add b, a
1124   0B0A E4            pop a
1125   0B0B             ; --- END TERMS
1126   0B0B E7            pop d
1127   0B0C FD 43         mov [d], b
1128   0B0E             ; break; 
1129   0B0E 0A EB 0B      jmp _switch13_exit ; case break
1130   0B11             _switch13_case2:
1131   0B11             _switch13_case3:
1132   0B11             ; print_signed(*(int*)p); 
1133   0B11             ; --- START FUNCTION CALL
1134   0B11 FA FF FF      lea d, [bp + -1] ; $p
1135   0B14 2A            mov b, [d]
1136   0B15 38 00 00      mov c, 0
1137   0B18 74            mov d, b
1138   0B19 2A            mov b, [d]
1139   0B1A 38 00 00      mov c, 0
1140   0B1D FD AB         swp b
1141   0B1F D8            push b
1142   0B20 07 BF 14      call print_signed
1143   0B23 51 02 00      add sp, 2
1144   0B26             ; --- END FUNCTION CALL
1145   0B26             ; p = p + 2; 
1146   0B26 FA FF FF      lea d, [bp + -1] ; $p
1147   0B29 DA            push d
1148   0B2A FA FF FF      lea d, [bp + -1] ; $p
1149   0B2D 2A            mov b, [d]
1150   0B2E 38 00 00      mov c, 0
1151   0B31             ; --- START TERMS
1152   0B31 D7            push a
1153   0B32 11            mov a, b
1154   0B33 FD 2E 02 00   mov32 cb, $00000002
1154   0B37 00 00 
1155   0B39 56            add b, a
1156   0B3A E4            pop a
1157   0B3B             ; --- END TERMS
1158   0B3B E7            pop d
1159   0B3C FD 43         mov [d], b
1160   0B3E             ; break; 
1161   0B3E 0A EB 0B      jmp _switch13_exit ; case break
1162   0B41             _switch13_case4:
1163   0B41             ; print_unsigned(*(unsigned int*)p); 
1164   0B41             ; --- START FUNCTION CALL
1165   0B41 FA FF FF      lea d, [bp + -1] ; $p
1166   0B44 2A            mov b, [d]
1167   0B45 38 00 00      mov c, 0
1168   0B48 74            mov d, b
1169   0B49 2A            mov b, [d]
1170   0B4A 38 00 00      mov c, 0
1171   0B4D FD AB         swp b
1172   0B4F D8            push b
1173   0B50 07 DB 19      call print_unsigned
1174   0B53 51 02 00      add sp, 2
1175   0B56             ; --- END FUNCTION CALL
1176   0B56             ; p = p + 2; 
1177   0B56 FA FF FF      lea d, [bp + -1] ; $p
1178   0B59 DA            push d
1179   0B5A FA FF FF      lea d, [bp + -1] ; $p
1180   0B5D 2A            mov b, [d]
1181   0B5E 38 00 00      mov c, 0
1182   0B61             ; --- START TERMS
1183   0B61 D7            push a
1184   0B62 11            mov a, b
1185   0B63 FD 2E 02 00   mov32 cb, $00000002
1185   0B67 00 00 
1186   0B69 56            add b, a
1187   0B6A E4            pop a
1188   0B6B             ; --- END TERMS
1189   0B6B E7            pop d
1190   0B6C FD 43         mov [d], b
1191   0B6E             ; break; 
1192   0B6E 0A EB 0B      jmp _switch13_exit ; case break
1193   0B71             _switch13_case5:
1194   0B71             
1195   0B71             ; --- BEGIN INLINE ASM SEGMENT
1196   0B71 FA FF FF      lea d, [bp + -1] ; $p
1197   0B74 FD 2A         mov d, [d]
1198   0B76 2A            mov b, [d]
1199   0B77 07 54 20      call print_u16x
1200   0B7A             ; --- END INLINE ASM SEGMENT
1201   0B7A             
1202   0B7A             ; p = p + 2; 
1203   0B7A FA FF FF      lea d, [bp + -1] ; $p
1204   0B7D DA            push d
1205   0B7E FA FF FF      lea d, [bp + -1] ; $p
1206   0B81 2A            mov b, [d]
1207   0B82 38 00 00      mov c, 0
1208   0B85             ; --- START TERMS
1209   0B85 D7            push a
1210   0B86 11            mov a, b
1211   0B87 FD 2E 02 00   mov32 cb, $00000002
1211   0B8B 00 00 
1212   0B8D 56            add b, a
1213   0B8E E4            pop a
1214   0B8F             ; --- END TERMS
1215   0B8F E7            pop d
1216   0B90 FD 43         mov [d], b
1217   0B92             ; break; 
1218   0B92 0A EB 0B      jmp _switch13_exit ; case break
1219   0B95             _switch13_case6:
1220   0B95             
1221   0B95             ; --- BEGIN INLINE ASM SEGMENT
1222   0B95 FA FF FF      lea d, [bp + -1] ; $p
1223   0B98 FD 2A         mov d, [d]
1224   0B9A 1E            mov al, [d]
1225   0B9B 23            mov ah, al
1226   0B9C 07 B2 1E      call _putchar
1227   0B9F             ; --- END INLINE ASM SEGMENT
1228   0B9F             
1229   0B9F             ; p = p + 1; 
1230   0B9F FA FF FF      lea d, [bp + -1] ; $p
1231   0BA2 DA            push d
1232   0BA3 FA FF FF      lea d, [bp + -1] ; $p
1233   0BA6 2A            mov b, [d]
1234   0BA7 38 00 00      mov c, 0
1235   0BAA             ; --- START TERMS
1236   0BAA D7            push a
1237   0BAB 11            mov a, b
1238   0BAC FD 2E 01 00   mov32 cb, $00000001
1238   0BB0 00 00 
1239   0BB2 56            add b, a
1240   0BB3 E4            pop a
1241   0BB4             ; --- END TERMS
1242   0BB4 E7            pop d
1243   0BB5 FD 43         mov [d], b
1244   0BB7             ; break; 
1245   0BB7 0A EB 0B      jmp _switch13_exit ; case break
1246   0BBA             _switch13_case7:
1247   0BBA             
1248   0BBA             ; --- BEGIN INLINE ASM SEGMENT
1249   0BBA FA FF FF      lea d, [bp + -1] ; $p
1250   0BBD FD 2A         mov d, [d]
1251   0BBF FD 2A         mov d, [d]
1252   0BC1 07 FC 1F      call _puts
1253   0BC4             ; --- END INLINE ASM SEGMENT
1254   0BC4             
1255   0BC4             ; p = p + 2; 
1256   0BC4 FA FF FF      lea d, [bp + -1] ; $p
1257   0BC7 DA            push d
1258   0BC8 FA FF FF      lea d, [bp + -1] ; $p
1259   0BCB 2A            mov b, [d]
1260   0BCC 38 00 00      mov c, 0
1261   0BCF             ; --- START TERMS
1262   0BCF D7            push a
1263   0BD0 11            mov a, b
1264   0BD1 FD 2E 02 00   mov32 cb, $00000002
1264   0BD5 00 00 
1265   0BD7 56            add b, a
1266   0BD8 E4            pop a
1267   0BD9             ; --- END TERMS
1268   0BD9 E7            pop d
1269   0BDA FD 43         mov [d], b
1270   0BDC             ; break; 
1271   0BDC 0A EB 0B      jmp _switch13_exit ; case break
1272   0BDF             _switch13_default:
1273   0BDF             ; print("Error: Unknown argument type.\n"); 
1274   0BDF             ; --- START FUNCTION CALL
1275   0BDF 26 77 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1276   0BE2 FD AB         swp b
1277   0BE4 D8            push b
1278   0BE5 07 F1 1C      call print
1279   0BE8 51 02 00      add sp, 2
1280   0BEB             ; --- END FUNCTION CALL
1281   0BEB             _switch13_exit:
1282   0BEB             ; format_p++; 
1283   0BEB FA FD FF      lea d, [bp + -3] ; $format_p
1284   0BEE 2A            mov b, [d]
1285   0BEF 38 00 00      mov c, 0
1286   0BF2 FD 77         inc b
1287   0BF4 FA FD FF      lea d, [bp + -3] ; $format_p
1288   0BF7 FD 43         mov [d], b
1289   0BF9 FD 7D         dec b
1290   0BFB 0A 23 0C      jmp _if12_exit
1291   0BFE             _if12_else:
1292   0BFE             ; putchar(*format_p); 
1293   0BFE             ; --- START FUNCTION CALL
1294   0BFE FA FD FF      lea d, [bp + -3] ; $format_p
1295   0C01 2A            mov b, [d]
1296   0C02 38 00 00      mov c, 0
1297   0C05 74            mov d, b
1298   0C06 32            mov bl, [d]
1299   0C07 A7 00         mov bh, 0
1300   0C09 38 00 00      mov c, 0
1301   0C0C DD            push bl
1302   0C0D 07 A3 1C      call putchar
1303   0C10 51 01 00      add sp, 1
1304   0C13             ; --- END FUNCTION CALL
1305   0C13             ; format_p++; 
1306   0C13 FA FD FF      lea d, [bp + -3] ; $format_p
1307   0C16 2A            mov b, [d]
1308   0C17 38 00 00      mov c, 0
1309   0C1A FD 77         inc b
1310   0C1C FA FD FF      lea d, [bp + -3] ; $format_p
1311   0C1F FD 43         mov [d], b
1312   0C21 FD 7D         dec b
1313   0C23             _if12_exit:
1314   0C23             _if11_exit:
1315   0C23             _for10_update:
1316   0C23 0A 76 09      jmp _for10_cond
1317   0C26             _for10_exit:
1318   0C26 F9            leave
1319   0C27 09            ret
1320   0C28             
1321   0C28             scanf:
1322   0C28 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1323   0C2B             ; char *p, *format_p; 
1324   0C2B 52 02 00      sub sp, 2
1325   0C2E 52 02 00      sub sp, 2
1326   0C31             ; char c; 
1327   0C31 52 01 00      sub sp, 1
1328   0C34             ; int i; 
1329   0C34 52 02 00      sub sp, 2
1330   0C37             ; char input_string[  512                    ]; 
1331   0C37 52 00 02      sub sp, 512
1332   0C3A             ; format_p = format; 
1333   0C3A FA FD FF      lea d, [bp + -3] ; $format_p
1334   0C3D DA            push d
1335   0C3E FA 05 00      lea d, [bp + 5] ; $format
1336   0C41 2A            mov b, [d]
1337   0C42 38 00 00      mov c, 0
1338   0C45 E7            pop d
1339   0C46 FD 43         mov [d], b
1340   0C48             ; p = &format + 2; 
1341   0C48 FA FF FF      lea d, [bp + -1] ; $p
1342   0C4B DA            push d
1343   0C4C FA 05 00      lea d, [bp + 5] ; $format
1344   0C4F 2D            mov b, d
1345   0C50             ; --- START TERMS
1346   0C50 D7            push a
1347   0C51 11            mov a, b
1348   0C52 FD 2E 02 00   mov32 cb, $00000002
1348   0C56 00 00 
1349   0C58 56            add b, a
1350   0C59 E4            pop a
1351   0C5A             ; --- END TERMS
1352   0C5A E7            pop d
1353   0C5B FD 43         mov [d], b
1354   0C5D             ; for(;;){ 
1355   0C5D             _for17_init:
1356   0C5D             _for17_cond:
1357   0C5D             _for17_block:
1358   0C5D             ; if(!*format_p) break; 
1359   0C5D             _if18_cond:
1360   0C5D FA FD FF      lea d, [bp + -3] ; $format_p
1361   0C60 2A            mov b, [d]
1362   0C61 38 00 00      mov c, 0
1363   0C64 74            mov d, b
1364   0C65 32            mov bl, [d]
1365   0C66 A7 00         mov bh, 0
1366   0C68 38 00 00      mov c, 0
1367   0C6B C0 00 00      cmp b, 0
1368   0C6E FD 71         seq ; !
1369   0C70 C0 00 00      cmp b, 0
1370   0C73 C6 7C 0C      je _if18_else
1371   0C76             _if18_true:
1372   0C76             ; break; 
1373   0C76 0A 04 0F      jmp _for17_exit ; for break
1374   0C79 0A 01 0F      jmp _if18_exit
1375   0C7C             _if18_else:
1376   0C7C             ; if(*format_p == '%'){ 
1377   0C7C             _if19_cond:
1378   0C7C FA FD FF      lea d, [bp + -3] ; $format_p
1379   0C7F 2A            mov b, [d]
1380   0C80 38 00 00      mov c, 0
1381   0C83 74            mov d, b
1382   0C84 32            mov bl, [d]
1383   0C85 A7 00         mov bh, 0
1384   0C87 38 00 00      mov c, 0
1385   0C8A             ; --- START RELATIONAL
1386   0C8A D7            push a
1387   0C8B 11            mov a, b
1388   0C8C FD 2E 25 00   mov32 cb, $00000025
1388   0C90 00 00 
1389   0C92 B0            cmp a, b
1390   0C93 FD 71         seq ; ==
1391   0C95 E4            pop a
1392   0C96             ; --- END RELATIONAL
1393   0C96 C0 00 00      cmp b, 0
1394   0C99 C6 DC 0E      je _if19_else
1395   0C9C             _if19_true:
1396   0C9C             ; format_p++; 
1397   0C9C FA FD FF      lea d, [bp + -3] ; $format_p
1398   0C9F 2A            mov b, [d]
1399   0CA0 38 00 00      mov c, 0
1400   0CA3 FD 77         inc b
1401   0CA5 FA FD FF      lea d, [bp + -3] ; $format_p
1402   0CA8 FD 43         mov [d], b
1403   0CAA FD 7D         dec b
1404   0CAC             ; switch(*format_p){ 
1405   0CAC             _switch20_expr:
1406   0CAC FA FD FF      lea d, [bp + -3] ; $format_p
1407   0CAF 2A            mov b, [d]
1408   0CB0 38 00 00      mov c, 0
1409   0CB3 74            mov d, b
1410   0CB4 32            mov bl, [d]
1411   0CB5 A7 00         mov bh, 0
1412   0CB7 38 00 00      mov c, 0
1413   0CBA             _switch20_comparisons:
1414   0CBA C1 6C         cmp bl, $6c
1415   0CBC C6 E8 0C      je _switch20_case0
1416   0CBF C1 4C         cmp bl, $4c
1417   0CC1 C6 E8 0C      je _switch20_case1
1418   0CC4 C1 64         cmp bl, $64
1419   0CC6 C6 A7 0D      je _switch20_case2
1420   0CC9 C1 69         cmp bl, $69
1421   0CCB C6 A7 0D      je _switch20_case3
1422   0CCE C1 75         cmp bl, $75
1423   0CD0 C6 E0 0D      je _switch20_case4
1424   0CD3 C1 78         cmp bl, $78
1425   0CD5 C6 19 0E      je _switch20_case5
1426   0CD8 C1 63         cmp bl, $63
1427   0CDA C6 34 0E      je _switch20_case6
1428   0CDD C1 73         cmp bl, $73
1429   0CDF C6 76 0E      je _switch20_case7
1430   0CE2 0A BD 0E      jmp _switch20_default
1431   0CE5 0A C9 0E      jmp _switch20_exit
1432   0CE8             _switch20_case0:
1433   0CE8             _switch20_case1:
1434   0CE8             ; format_p++; 
1435   0CE8 FA FD FF      lea d, [bp + -3] ; $format_p
1436   0CEB 2A            mov b, [d]
1437   0CEC 38 00 00      mov c, 0
1438   0CEF FD 77         inc b
1439   0CF1 FA FD FF      lea d, [bp + -3] ; $format_p
1440   0CF4 FD 43         mov [d], b
1441   0CF6 FD 7D         dec b
1442   0CF8             ; if(*format_p == 'd' || *format_p == 'i'); 
1443   0CF8             _if21_cond:
1444   0CF8 FA FD FF      lea d, [bp + -3] ; $format_p
1445   0CFB 2A            mov b, [d]
1446   0CFC 38 00 00      mov c, 0
1447   0CFF 74            mov d, b
1448   0D00 32            mov bl, [d]
1449   0D01 A7 00         mov bh, 0
1450   0D03 38 00 00      mov c, 0
1451   0D06             ; --- START RELATIONAL
1452   0D06 D7            push a
1453   0D07 11            mov a, b
1454   0D08 FD 2E 64 00   mov32 cb, $00000064
1454   0D0C 00 00 
1455   0D0E B0            cmp a, b
1456   0D0F FD 71         seq ; ==
1457   0D11 E4            pop a
1458   0D12             ; --- END RELATIONAL
1459   0D12             ; --- START LOGICAL OR
1460   0D12 D7            push a
1461   0D13 11            mov a, b
1462   0D14 FA FD FF      lea d, [bp + -3] ; $format_p
1463   0D17 2A            mov b, [d]
1464   0D18 38 00 00      mov c, 0
1465   0D1B 74            mov d, b
1466   0D1C 32            mov bl, [d]
1467   0D1D A7 00         mov bh, 0
1468   0D1F 38 00 00      mov c, 0
1469   0D22             ; --- START RELATIONAL
1470   0D22 D7            push a
1471   0D23 11            mov a, b
1472   0D24 FD 2E 69 00   mov32 cb, $00000069
1472   0D28 00 00 
1473   0D2A B0            cmp a, b
1474   0D2B FD 71         seq ; ==
1475   0D2D E4            pop a
1476   0D2E             ; --- END RELATIONAL
1477   0D2E FD A8         sor a, b ; ||
1478   0D30 E4            pop a
1479   0D31             ; --- END LOGICAL OR
1480   0D31 C0 00 00      cmp b, 0
1481   0D34 C6 3A 0D      je _if21_else
1482   0D37             _if21_true:
1483   0D37             ; ; 
1484   0D37 0A 8C 0D      jmp _if21_exit
1485   0D3A             _if21_else:
1486   0D3A             ; if(*format_p == 'u'); 
1487   0D3A             _if22_cond:
1488   0D3A FA FD FF      lea d, [bp + -3] ; $format_p
1489   0D3D 2A            mov b, [d]
1490   0D3E 38 00 00      mov c, 0
1491   0D41 74            mov d, b
1492   0D42 32            mov bl, [d]
1493   0D43 A7 00         mov bh, 0
1494   0D45 38 00 00      mov c, 0
1495   0D48             ; --- START RELATIONAL
1496   0D48 D7            push a
1497   0D49 11            mov a, b
1498   0D4A FD 2E 75 00   mov32 cb, $00000075
1498   0D4E 00 00 
1499   0D50 B0            cmp a, b
1500   0D51 FD 71         seq ; ==
1501   0D53 E4            pop a
1502   0D54             ; --- END RELATIONAL
1503   0D54 C0 00 00      cmp b, 0
1504   0D57 C6 5D 0D      je _if22_else
1505   0D5A             _if22_true:
1506   0D5A             ; ; 
1507   0D5A 0A 8C 0D      jmp _if22_exit
1508   0D5D             _if22_else:
1509   0D5D             ; if(*format_p == 'x'); 
1510   0D5D             _if23_cond:
1511   0D5D FA FD FF      lea d, [bp + -3] ; $format_p
1512   0D60 2A            mov b, [d]
1513   0D61 38 00 00      mov c, 0
1514   0D64 74            mov d, b
1515   0D65 32            mov bl, [d]
1516   0D66 A7 00         mov bh, 0
1517   0D68 38 00 00      mov c, 0
1518   0D6B             ; --- START RELATIONAL
1519   0D6B D7            push a
1520   0D6C 11            mov a, b
1521   0D6D FD 2E 78 00   mov32 cb, $00000078
1521   0D71 00 00 
1522   0D73 B0            cmp a, b
1523   0D74 FD 71         seq ; ==
1524   0D76 E4            pop a
1525   0D77             ; --- END RELATIONAL
1526   0D77 C0 00 00      cmp b, 0
1527   0D7A C6 80 0D      je _if23_else
1528   0D7D             _if23_true:
1529   0D7D             ; ; 
1530   0D7D 0A 8C 0D      jmp _if23_exit
1531   0D80             _if23_else:
1532   0D80             ; err("Unexpected format in printf."); 
1533   0D80             ; --- START FUNCTION CALL
1534   0D80 26 5A 21      mov b, _s0 ; "Unexpected format in printf."
1535   0D83 FD AB         swp b
1536   0D85 D8            push b
1537   0D86 07 B6 12      call err
1538   0D89 51 02 00      add sp, 2
1539   0D8C             ; --- END FUNCTION CALL
1540   0D8C             _if23_exit:
1541   0D8C             _if22_exit:
1542   0D8C             _if21_exit:
1543   0D8C             ; p = p + 4; 
1544   0D8C FA FF FF      lea d, [bp + -1] ; $p
1545   0D8F DA            push d
1546   0D90 FA FF FF      lea d, [bp + -1] ; $p
1547   0D93 2A            mov b, [d]
1548   0D94 38 00 00      mov c, 0
1549   0D97             ; --- START TERMS
1550   0D97 D7            push a
1551   0D98 11            mov a, b
1552   0D99 FD 2E 04 00   mov32 cb, $00000004
1552   0D9D 00 00 
1553   0D9F 56            add b, a
1554   0DA0 E4            pop a
1555   0DA1             ; --- END TERMS
1556   0DA1 E7            pop d
1557   0DA2 FD 43         mov [d], b
1558   0DA4             ; break; 
1559   0DA4 0A C9 0E      jmp _switch20_exit ; case break
1560   0DA7             _switch20_case2:
1561   0DA7             _switch20_case3:
1562   0DA7             ; i = scann(); 
1563   0DA7 FA FA FF      lea d, [bp + -6] ; $i
1564   0DAA DA            push d
1565   0DAB             ; --- START FUNCTION CALL
1566   0DAB 07 C9 1C      call scann
1567   0DAE E7            pop d
1568   0DAF FD 43         mov [d], b
1569   0DB1             ; **(int **)p = i; 
1570   0DB1 FA FF FF      lea d, [bp + -1] ; $p
1571   0DB4 2A            mov b, [d]
1572   0DB5 38 00 00      mov c, 0
1573   0DB8 74            mov d, b
1574   0DB9 2A            mov b, [d]
1575   0DBA D8            push b
1576   0DBB FA FA FF      lea d, [bp + -6] ; $i
1577   0DBE 2A            mov b, [d]
1578   0DBF 38 00 00      mov c, 0
1579   0DC2 E7            pop d
1580   0DC3 FD 43         mov [d], b
1581   0DC5             ; p = p + 2; 
1582   0DC5 FA FF FF      lea d, [bp + -1] ; $p
1583   0DC8 DA            push d
1584   0DC9 FA FF FF      lea d, [bp + -1] ; $p
1585   0DCC 2A            mov b, [d]
1586   0DCD 38 00 00      mov c, 0
1587   0DD0             ; --- START TERMS
1588   0DD0 D7            push a
1589   0DD1 11            mov a, b
1590   0DD2 FD 2E 02 00   mov32 cb, $00000002
1590   0DD6 00 00 
1591   0DD8 56            add b, a
1592   0DD9 E4            pop a
1593   0DDA             ; --- END TERMS
1594   0DDA E7            pop d
1595   0DDB FD 43         mov [d], b
1596   0DDD             ; break; 
1597   0DDD 0A C9 0E      jmp _switch20_exit ; case break
1598   0DE0             _switch20_case4:
1599   0DE0             ; i = scann(); 
1600   0DE0 FA FA FF      lea d, [bp + -6] ; $i
1601   0DE3 DA            push d
1602   0DE4             ; --- START FUNCTION CALL
1603   0DE4 07 C9 1C      call scann
1604   0DE7 E7            pop d
1605   0DE8 FD 43         mov [d], b
1606   0DEA             ; **(int **)p = i; 
1607   0DEA FA FF FF      lea d, [bp + -1] ; $p
1608   0DED 2A            mov b, [d]
1609   0DEE 38 00 00      mov c, 0
1610   0DF1 74            mov d, b
1611   0DF2 2A            mov b, [d]
1612   0DF3 D8            push b
1613   0DF4 FA FA FF      lea d, [bp + -6] ; $i
1614   0DF7 2A            mov b, [d]
1615   0DF8 38 00 00      mov c, 0
1616   0DFB E7            pop d
1617   0DFC FD 43         mov [d], b
1618   0DFE             ; p = p + 2; 
1619   0DFE FA FF FF      lea d, [bp + -1] ; $p
1620   0E01 DA            push d
1621   0E02 FA FF FF      lea d, [bp + -1] ; $p
1622   0E05 2A            mov b, [d]
1623   0E06 38 00 00      mov c, 0
1624   0E09             ; --- START TERMS
1625   0E09 D7            push a
1626   0E0A 11            mov a, b
1627   0E0B FD 2E 02 00   mov32 cb, $00000002
1627   0E0F 00 00 
1628   0E11 56            add b, a
1629   0E12 E4            pop a
1630   0E13             ; --- END TERMS
1631   0E13 E7            pop d
1632   0E14 FD 43         mov [d], b
1633   0E16             ; break; 
1634   0E16 0A C9 0E      jmp _switch20_exit ; case break
1635   0E19             _switch20_case5:
1636   0E19             ; p = p + 2; 
1637   0E19 FA FF FF      lea d, [bp + -1] ; $p
1638   0E1C DA            push d
1639   0E1D FA FF FF      lea d, [bp + -1] ; $p
1640   0E20 2A            mov b, [d]
1641   0E21 38 00 00      mov c, 0
1642   0E24             ; --- START TERMS
1643   0E24 D7            push a
1644   0E25 11            mov a, b
1645   0E26 FD 2E 02 00   mov32 cb, $00000002
1645   0E2A 00 00 
1646   0E2C 56            add b, a
1647   0E2D E4            pop a
1648   0E2E             ; --- END TERMS
1649   0E2E E7            pop d
1650   0E2F FD 43         mov [d], b
1651   0E31             ; break; 
1652   0E31 0A C9 0E      jmp _switch20_exit ; case break
1653   0E34             _switch20_case6:
1654   0E34             ; c = getchar(); 
1655   0E34 FA FC FF      lea d, [bp + -4] ; $c
1656   0E37 DA            push d
1657   0E38             ; --- START FUNCTION CALL
1658   0E38 07 B0 1C      call getchar
1659   0E3B E7            pop d
1660   0E3C FD 3E         mov [d], bl
1661   0E3E             ; **(char **)p = *(char *)c; 
1662   0E3E FA FF FF      lea d, [bp + -1] ; $p
1663   0E41 2A            mov b, [d]
1664   0E42 38 00 00      mov c, 0
1665   0E45 74            mov d, b
1666   0E46 2A            mov b, [d]
1667   0E47 D8            push b
1668   0E48 FA FC FF      lea d, [bp + -4] ; $c
1669   0E4B 32            mov bl, [d]
1670   0E4C A7 00         mov bh, 0
1671   0E4E 38 00 00      mov c, 0
1672   0E51 74            mov d, b
1673   0E52 32            mov bl, [d]
1674   0E53 A7 00         mov bh, 0
1675   0E55 38 00 00      mov c, 0
1676   0E58 E7            pop d
1677   0E59 FD 43         mov [d], b
1678   0E5B             ; p = p + 1; 
1679   0E5B FA FF FF      lea d, [bp + -1] ; $p
1680   0E5E DA            push d
1681   0E5F FA FF FF      lea d, [bp + -1] ; $p
1682   0E62 2A            mov b, [d]
1683   0E63 38 00 00      mov c, 0
1684   0E66             ; --- START TERMS
1685   0E66 D7            push a
1686   0E67 11            mov a, b
1687   0E68 FD 2E 01 00   mov32 cb, $00000001
1687   0E6C 00 00 
1688   0E6E 56            add b, a
1689   0E6F E4            pop a
1690   0E70             ; --- END TERMS
1691   0E70 E7            pop d
1692   0E71 FD 43         mov [d], b
1693   0E73             ; break; 
1694   0E73 0A C9 0E      jmp _switch20_exit ; case break
1695   0E76             _switch20_case7:
1696   0E76             ; gets(input_string); 
1697   0E76             ; --- START FUNCTION CALL
1698   0E76 FA FA FD      lea d, [bp + -518] ; $input_string
1699   0E79 2D            mov b, d
1700   0E7A 38 00 00      mov c, 0
1701   0E7D FD AB         swp b
1702   0E7F D8            push b
1703   0E80 07 A2 14      call gets
1704   0E83 51 02 00      add sp, 2
1705   0E86             ; --- END FUNCTION CALL
1706   0E86             ; strcpy(*(char **)p, input_string); 
1707   0E86             ; --- START FUNCTION CALL
1708   0E86 FA FA FD      lea d, [bp + -518] ; $input_string
1709   0E89 2D            mov b, d
1710   0E8A 38 00 00      mov c, 0
1711   0E8D FD AB         swp b
1712   0E8F D8            push b
1713   0E90 FA FF FF      lea d, [bp + -1] ; $p
1714   0E93 2A            mov b, [d]
1715   0E94 38 00 00      mov c, 0
1716   0E97 74            mov d, b
1717   0E98 2A            mov b, [d]
1718   0E99 FD AB         swp b
1719   0E9B D8            push b
1720   0E9C 07 1F 04      call strcpy
1721   0E9F 51 04 00      add sp, 4
1722   0EA2             ; --- END FUNCTION CALL
1723   0EA2             ; p = p + 2; 
1724   0EA2 FA FF FF      lea d, [bp + -1] ; $p
1725   0EA5 DA            push d
1726   0EA6 FA FF FF      lea d, [bp + -1] ; $p
1727   0EA9 2A            mov b, [d]
1728   0EAA 38 00 00      mov c, 0
1729   0EAD             ; --- START TERMS
1730   0EAD D7            push a
1731   0EAE 11            mov a, b
1732   0EAF FD 2E 02 00   mov32 cb, $00000002
1732   0EB3 00 00 
1733   0EB5 56            add b, a
1734   0EB6 E4            pop a
1735   0EB7             ; --- END TERMS
1736   0EB7 E7            pop d
1737   0EB8 FD 43         mov [d], b
1738   0EBA             ; break; 
1739   0EBA 0A C9 0E      jmp _switch20_exit ; case break
1740   0EBD             _switch20_default:
1741   0EBD             ; print("Error: Unknown argument type.\n"); 
1742   0EBD             ; --- START FUNCTION CALL
1743   0EBD 26 77 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1744   0EC0 FD AB         swp b
1745   0EC2 D8            push b
1746   0EC3 07 F1 1C      call print
1747   0EC6 51 02 00      add sp, 2
1748   0EC9             ; --- END FUNCTION CALL
1749   0EC9             _switch20_exit:
1750   0EC9             ; format_p++; 
1751   0EC9 FA FD FF      lea d, [bp + -3] ; $format_p
1752   0ECC 2A            mov b, [d]
1753   0ECD 38 00 00      mov c, 0
1754   0ED0 FD 77         inc b
1755   0ED2 FA FD FF      lea d, [bp + -3] ; $format_p
1756   0ED5 FD 43         mov [d], b
1757   0ED7 FD 7D         dec b
1758   0ED9 0A 01 0F      jmp _if19_exit
1759   0EDC             _if19_else:
1760   0EDC             ; putchar(*format_p); 
1761   0EDC             ; --- START FUNCTION CALL
1762   0EDC FA FD FF      lea d, [bp + -3] ; $format_p
1763   0EDF 2A            mov b, [d]
1764   0EE0 38 00 00      mov c, 0
1765   0EE3 74            mov d, b
1766   0EE4 32            mov bl, [d]
1767   0EE5 A7 00         mov bh, 0
1768   0EE7 38 00 00      mov c, 0
1769   0EEA DD            push bl
1770   0EEB 07 A3 1C      call putchar
1771   0EEE 51 01 00      add sp, 1
1772   0EF1             ; --- END FUNCTION CALL
1773   0EF1             ; format_p++; 
1774   0EF1 FA FD FF      lea d, [bp + -3] ; $format_p
1775   0EF4 2A            mov b, [d]
1776   0EF5 38 00 00      mov c, 0
1777   0EF8 FD 77         inc b
1778   0EFA FA FD FF      lea d, [bp + -3] ; $format_p
1779   0EFD FD 43         mov [d], b
1780   0EFF FD 7D         dec b
1781   0F01             _if19_exit:
1782   0F01             _if18_exit:
1783   0F01             _for17_update:
1784   0F01 0A 5D 0C      jmp _for17_cond
1785   0F04             _for17_exit:
1786   0F04 F9            leave
1787   0F05 09            ret
1788   0F06             
1789   0F06             sprintf:
1790   0F06 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1791   0F09             ; char *p, *format_p; 
1792   0F09 52 02 00      sub sp, 2
1793   0F0C 52 02 00      sub sp, 2
1794   0F0F             ; char *sp; 
1795   0F0F 52 02 00      sub sp, 2
1796   0F12             ; sp = dest; 
1797   0F12 FA FB FF      lea d, [bp + -5] ; $sp
1798   0F15 DA            push d
1799   0F16 FA 05 00      lea d, [bp + 5] ; $dest
1800   0F19 2A            mov b, [d]
1801   0F1A 38 00 00      mov c, 0
1802   0F1D E7            pop d
1803   0F1E FD 43         mov [d], b
1804   0F20             ; format_p = format; 
1805   0F20 FA FD FF      lea d, [bp + -3] ; $format_p
1806   0F23 DA            push d
1807   0F24 FA 07 00      lea d, [bp + 7] ; $format
1808   0F27 2A            mov b, [d]
1809   0F28 38 00 00      mov c, 0
1810   0F2B E7            pop d
1811   0F2C FD 43         mov [d], b
1812   0F2E             ; p = &format + 2; 
1813   0F2E FA FF FF      lea d, [bp + -1] ; $p
1814   0F31 DA            push d
1815   0F32 FA 07 00      lea d, [bp + 7] ; $format
1816   0F35 2D            mov b, d
1817   0F36             ; --- START TERMS
1818   0F36 D7            push a
1819   0F37 11            mov a, b
1820   0F38 FD 2E 02 00   mov32 cb, $00000002
1820   0F3C 00 00 
1821   0F3E 56            add b, a
1822   0F3F E4            pop a
1823   0F40             ; --- END TERMS
1824   0F40 E7            pop d
1825   0F41 FD 43         mov [d], b
1826   0F43             ; for(;;){ 
1827   0F43             _for24_init:
1828   0F43             _for24_cond:
1829   0F43             _for24_block:
1830   0F43             ; if(!*format_p) break; 
1831   0F43             _if25_cond:
1832   0F43 FA FD FF      lea d, [bp + -3] ; $format_p
1833   0F46 2A            mov b, [d]
1834   0F47 38 00 00      mov c, 0
1835   0F4A 74            mov d, b
1836   0F4B 32            mov bl, [d]
1837   0F4C A7 00         mov bh, 0
1838   0F4E 38 00 00      mov c, 0
1839   0F51 C0 00 00      cmp b, 0
1840   0F54 FD 71         seq ; !
1841   0F56 C0 00 00      cmp b, 0
1842   0F59 C6 62 0F      je _if25_else
1843   0F5C             _if25_true:
1844   0F5C             ; break; 
1845   0F5C 0A 90 12      jmp _for24_exit ; for break
1846   0F5F 0A 8D 12      jmp _if25_exit
1847   0F62             _if25_else:
1848   0F62             ; if(*format_p == '%'){ 
1849   0F62             _if26_cond:
1850   0F62 FA FD FF      lea d, [bp + -3] ; $format_p
1851   0F65 2A            mov b, [d]
1852   0F66 38 00 00      mov c, 0
1853   0F69 74            mov d, b
1854   0F6A 32            mov bl, [d]
1855   0F6B A7 00         mov bh, 0
1856   0F6D 38 00 00      mov c, 0
1857   0F70             ; --- START RELATIONAL
1858   0F70 D7            push a
1859   0F71 11            mov a, b
1860   0F72 FD 2E 25 00   mov32 cb, $00000025
1860   0F76 00 00 
1861   0F78 B0            cmp a, b
1862   0F79 FD 71         seq ; ==
1863   0F7B E4            pop a
1864   0F7C             ; --- END RELATIONAL
1865   0F7C C0 00 00      cmp b, 0
1866   0F7F C6 62 12      je _if26_else
1867   0F82             _if26_true:
1868   0F82             ; format_p++; 
1869   0F82 FA FD FF      lea d, [bp + -3] ; $format_p
1870   0F85 2A            mov b, [d]
1871   0F86 38 00 00      mov c, 0
1872   0F89 FD 77         inc b
1873   0F8B FA FD FF      lea d, [bp + -3] ; $format_p
1874   0F8E FD 43         mov [d], b
1875   0F90 FD 7D         dec b
1876   0F92             ; switch(*format_p){ 
1877   0F92             _switch27_expr:
1878   0F92 FA FD FF      lea d, [bp + -3] ; $format_p
1879   0F95 2A            mov b, [d]
1880   0F96 38 00 00      mov c, 0
1881   0F99 74            mov d, b
1882   0F9A 32            mov bl, [d]
1883   0F9B A7 00         mov bh, 0
1884   0F9D 38 00 00      mov c, 0
1885   0FA0             _switch27_comparisons:
1886   0FA0 C1 6C         cmp bl, $6c
1887   0FA2 C6 CE 0F      je _switch27_case0
1888   0FA5 C1 4C         cmp bl, $4c
1889   0FA7 C6 CE 0F      je _switch27_case1
1890   0FAA C1 64         cmp bl, $64
1891   0FAC C6 DE 10      je _switch27_case2
1892   0FAF C1 69         cmp bl, $69
1893   0FB1 C6 DE 10      je _switch27_case3
1894   0FB4 C1 75         cmp bl, $75
1895   0FB6 C6 2A 11      je _switch27_case4
1896   0FB9 C1 78         cmp bl, $78
1897   0FBB C6 76 11      je _switch27_case5
1898   0FBE C1 63         cmp bl, $63
1899   0FC0 C6 9A 11      je _switch27_case6
1900   0FC3 C1 73         cmp bl, $73
1901   0FC5 C6 D7 11      je _switch27_case7
1902   0FC8 0A 43 12      jmp _switch27_default
1903   0FCB 0A 4F 12      jmp _switch27_exit
1904   0FCE             _switch27_case0:
1905   0FCE             _switch27_case1:
1906   0FCE             ; format_p++; 
1907   0FCE FA FD FF      lea d, [bp + -3] ; $format_p
1908   0FD1 2A            mov b, [d]
1909   0FD2 38 00 00      mov c, 0
1910   0FD5 FD 77         inc b
1911   0FD7 FA FD FF      lea d, [bp + -3] ; $format_p
1912   0FDA FD 43         mov [d], b
1913   0FDC FD 7D         dec b
1914   0FDE             ; if(*format_p == 'd' || *format_p == 'i') 
1915   0FDE             _if28_cond:
1916   0FDE FA FD FF      lea d, [bp + -3] ; $format_p
1917   0FE1 2A            mov b, [d]
1918   0FE2 38 00 00      mov c, 0
1919   0FE5 74            mov d, b
1920   0FE6 32            mov bl, [d]
1921   0FE7 A7 00         mov bh, 0
1922   0FE9 38 00 00      mov c, 0
1923   0FEC             ; --- START RELATIONAL
1924   0FEC D7            push a
1925   0FED 11            mov a, b
1926   0FEE FD 2E 64 00   mov32 cb, $00000064
1926   0FF2 00 00 
1927   0FF4 B0            cmp a, b
1928   0FF5 FD 71         seq ; ==
1929   0FF7 E4            pop a
1930   0FF8             ; --- END RELATIONAL
1931   0FF8             ; --- START LOGICAL OR
1932   0FF8 D7            push a
1933   0FF9 11            mov a, b
1934   0FFA FA FD FF      lea d, [bp + -3] ; $format_p
1935   0FFD 2A            mov b, [d]
1936   0FFE 38 00 00      mov c, 0
1937   1001 74            mov d, b
1938   1002 32            mov bl, [d]
1939   1003 A7 00         mov bh, 0
1940   1005 38 00 00      mov c, 0
1941   1008             ; --- START RELATIONAL
1942   1008 D7            push a
1943   1009 11            mov a, b
1944   100A FD 2E 69 00   mov32 cb, $00000069
1944   100E 00 00 
1945   1010 B0            cmp a, b
1946   1011 FD 71         seq ; ==
1947   1013 E4            pop a
1948   1014             ; --- END RELATIONAL
1949   1014 FD A8         sor a, b ; ||
1950   1016 E4            pop a
1951   1017             ; --- END LOGICAL OR
1952   1017 C0 00 00      cmp b, 0
1953   101A C6 3B 10      je _if28_else
1954   101D             _if28_true:
1955   101D             ; print_signed_long(*(long *)p); 
1956   101D             ; --- START FUNCTION CALL
1957   101D FA FF FF      lea d, [bp + -1] ; $p
1958   1020 2A            mov b, [d]
1959   1021 38 00 00      mov c, 0
1960   1024 74            mov d, b
1961   1025 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1962   1028 FD 39         mov c, b ; And place it into C
1963   102A 2A            mov b, [d] ; Lower Word in B
1964   102B 12            mov a, c
1965   102C FD AA         swp a
1966   102E D7            push a
1967   102F FD AB         swp b
1968   1031 D8            push b
1969   1032 07 F8 15      call print_signed_long
1970   1035 51 04 00      add sp, 4
1971   1038             ; --- END FUNCTION CALL
1972   1038 0A C3 10      jmp _if28_exit
1973   103B             _if28_else:
1974   103B             ; if(*format_p == 'u') 
1975   103B             _if29_cond:
1976   103B FA FD FF      lea d, [bp + -3] ; $format_p
1977   103E 2A            mov b, [d]
1978   103F 38 00 00      mov c, 0
1979   1042 74            mov d, b
1980   1043 32            mov bl, [d]
1981   1044 A7 00         mov bh, 0
1982   1046 38 00 00      mov c, 0
1983   1049             ; --- START RELATIONAL
1984   1049 D7            push a
1985   104A 11            mov a, b
1986   104B FD 2E 75 00   mov32 cb, $00000075
1986   104F 00 00 
1987   1051 B0            cmp a, b
1988   1052 FD 71         seq ; ==
1989   1054 E4            pop a
1990   1055             ; --- END RELATIONAL
1991   1055 C0 00 00      cmp b, 0
1992   1058 C6 79 10      je _if29_else
1993   105B             _if29_true:
1994   105B             ; print_unsigned_long(*(unsigned long *)p); 
1995   105B             ; --- START FUNCTION CALL
1996   105B FA FF FF      lea d, [bp + -1] ; $p
1997   105E 2A            mov b, [d]
1998   105F 38 00 00      mov c, 0
1999   1062 74            mov d, b
2000   1063 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2001   1066 FD 39         mov c, b ; And place it into C
2002   1068 2A            mov b, [d] ; Lower Word in B
2003   1069 12            mov a, c
2004   106A FD AA         swp a
2005   106C D7            push a
2006   106D FD AB         swp b
2007   106F D8            push b
2008   1070 07 67 17      call print_unsigned_long
2009   1073 51 04 00      add sp, 4
2010   1076             ; --- END FUNCTION CALL
2011   1076 0A C3 10      jmp _if29_exit
2012   1079             _if29_else:
2013   1079             ; if(*format_p == 'x') 
2014   1079             _if30_cond:
2015   1079 FA FD FF      lea d, [bp + -3] ; $format_p
2016   107C 2A            mov b, [d]
2017   107D 38 00 00      mov c, 0
2018   1080 74            mov d, b
2019   1081 32            mov bl, [d]
2020   1082 A7 00         mov bh, 0
2021   1084 38 00 00      mov c, 0
2022   1087             ; --- START RELATIONAL
2023   1087 D7            push a
2024   1088 11            mov a, b
2025   1089 FD 2E 78 00   mov32 cb, $00000078
2025   108D 00 00 
2026   108F B0            cmp a, b
2027   1090 FD 71         seq ; ==
2028   1092 E4            pop a
2029   1093             ; --- END RELATIONAL
2030   1093 C0 00 00      cmp b, 0
2031   1096 C6 B7 10      je _if30_else
2032   1099             _if30_true:
2033   1099             ; printx32(*(long int *)p); 
2034   1099             ; --- START FUNCTION CALL
2035   1099 FA FF FF      lea d, [bp + -1] ; $p
2036   109C 2A            mov b, [d]
2037   109D 38 00 00      mov c, 0
2038   10A0 74            mov d, b
2039   10A1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2040   10A4 FD 39         mov c, b ; And place it into C
2041   10A6 2A            mov b, [d] ; Lower Word in B
2042   10A7 12            mov a, c
2043   10A8 FD AA         swp a
2044   10AA D7            push a
2045   10AB FD AB         swp b
2046   10AD D8            push b
2047   10AE 07 CB 12      call printx32
2048   10B1 51 04 00      add sp, 4
2049   10B4             ; --- END FUNCTION CALL
2050   10B4 0A C3 10      jmp _if30_exit
2051   10B7             _if30_else:
2052   10B7             ; err("Unexpected format in printf."); 
2053   10B7             ; --- START FUNCTION CALL
2054   10B7 26 5A 21      mov b, _s0 ; "Unexpected format in printf."
2055   10BA FD AB         swp b
2056   10BC D8            push b
2057   10BD 07 B6 12      call err
2058   10C0 51 02 00      add sp, 2
2059   10C3             ; --- END FUNCTION CALL
2060   10C3             _if30_exit:
2061   10C3             _if29_exit:
2062   10C3             _if28_exit:
2063   10C3             ; p = p + 4; 
2064   10C3 FA FF FF      lea d, [bp + -1] ; $p
2065   10C6 DA            push d
2066   10C7 FA FF FF      lea d, [bp + -1] ; $p
2067   10CA 2A            mov b, [d]
2068   10CB 38 00 00      mov c, 0
2069   10CE             ; --- START TERMS
2070   10CE D7            push a
2071   10CF 11            mov a, b
2072   10D0 FD 2E 04 00   mov32 cb, $00000004
2072   10D4 00 00 
2073   10D6 56            add b, a
2074   10D7 E4            pop a
2075   10D8             ; --- END TERMS
2076   10D8 E7            pop d
2077   10D9 FD 43         mov [d], b
2078   10DB             ; break; 
2079   10DB 0A 4F 12      jmp _switch27_exit ; case break
2080   10DE             _switch27_case2:
2081   10DE             _switch27_case3:
2082   10DE             ; sp = sp + sprint_signed(sp, *(int*)p); 
2083   10DE FA FB FF      lea d, [bp + -5] ; $sp
2084   10E1 DA            push d
2085   10E2 FA FB FF      lea d, [bp + -5] ; $sp
2086   10E5 2A            mov b, [d]
2087   10E6 38 00 00      mov c, 0
2088   10E9             ; --- START TERMS
2089   10E9 D7            push a
2090   10EA 11            mov a, b
2091   10EB             ; --- START FUNCTION CALL
2092   10EB FA FF FF      lea d, [bp + -1] ; $p
2093   10EE 2A            mov b, [d]
2094   10EF 38 00 00      mov c, 0
2095   10F2 74            mov d, b
2096   10F3 2A            mov b, [d]
2097   10F4 38 00 00      mov c, 0
2098   10F7 FD AB         swp b
2099   10F9 D8            push b
2100   10FA FA FB FF      lea d, [bp + -5] ; $sp
2101   10FD 2A            mov b, [d]
2102   10FE 38 00 00      mov c, 0
2103   1101 FD AB         swp b
2104   1103 D8            push b
2105   1104 07 DB 1A      call sprint_signed
2106   1107 51 04 00      add sp, 4
2107   110A             ; --- END FUNCTION CALL
2108   110A 56            add b, a
2109   110B E4            pop a
2110   110C             ; --- END TERMS
2111   110C E7            pop d
2112   110D FD 43         mov [d], b
2113   110F             ; p = p + 2; 
2114   110F FA FF FF      lea d, [bp + -1] ; $p
2115   1112 DA            push d
2116   1113 FA FF FF      lea d, [bp + -1] ; $p
2117   1116 2A            mov b, [d]
2118   1117 38 00 00      mov c, 0
2119   111A             ; --- START TERMS
2120   111A D7            push a
2121   111B 11            mov a, b
2122   111C FD 2E 02 00   mov32 cb, $00000002
2122   1120 00 00 
2123   1122 56            add b, a
2124   1123 E4            pop a
2125   1124             ; --- END TERMS
2126   1124 E7            pop d
2127   1125 FD 43         mov [d], b
2128   1127             ; break; 
2129   1127 0A 4F 12      jmp _switch27_exit ; case break
2130   112A             _switch27_case4:
2131   112A             ; sp = sp + sprint_unsigned(sp, *(unsigned int*)p); 
2132   112A FA FB FF      lea d, [bp + -5] ; $sp
2133   112D DA            push d
2134   112E FA FB FF      lea d, [bp + -5] ; $sp
2135   1131 2A            mov b, [d]
2136   1132 38 00 00      mov c, 0
2137   1135             ; --- START TERMS
2138   1135 D7            push a
2139   1136 11            mov a, b
2140   1137             ; --- START FUNCTION CALL
2141   1137 FA FF FF      lea d, [bp + -1] ; $p
2142   113A 2A            mov b, [d]
2143   113B 38 00 00      mov c, 0
2144   113E 74            mov d, b
2145   113F 2A            mov b, [d]
2146   1140 38 00 00      mov c, 0
2147   1143 FD AB         swp b
2148   1145 D8            push b
2149   1146 FA FB FF      lea d, [bp + -5] ; $sp
2150   1149 2A            mov b, [d]
2151   114A 38 00 00      mov c, 0
2152   114D FD AB         swp b
2153   114F D8            push b
2154   1150 07 83 18      call sprint_unsigned
2155   1153 51 04 00      add sp, 4
2156   1156             ; --- END FUNCTION CALL
2157   1156 56            add b, a
2158   1157 E4            pop a
2159   1158             ; --- END TERMS
2160   1158 E7            pop d
2161   1159 FD 43         mov [d], b
2162   115B             ; p = p + 2; 
2163   115B FA FF FF      lea d, [bp + -1] ; $p
2164   115E DA            push d
2165   115F FA FF FF      lea d, [bp + -1] ; $p
2166   1162 2A            mov b, [d]
2167   1163 38 00 00      mov c, 0
2168   1166             ; --- START TERMS
2169   1166 D7            push a
2170   1167 11            mov a, b
2171   1168 FD 2E 02 00   mov32 cb, $00000002
2171   116C 00 00 
2172   116E 56            add b, a
2173   116F E4            pop a
2174   1170             ; --- END TERMS
2175   1170 E7            pop d
2176   1171 FD 43         mov [d], b
2177   1173             ; break; 
2178   1173 0A 4F 12      jmp _switch27_exit ; case break
2179   1176             _switch27_case5:
2180   1176             
2181   1176             ; --- BEGIN INLINE ASM SEGMENT
2182   1176 FA FF FF      lea d, [bp + -1] ; $p
2183   1179 FD 2A         mov d, [d]
2184   117B 2A            mov b, [d]
2185   117C 07 54 20      call print_u16x
2186   117F             ; --- END INLINE ASM SEGMENT
2187   117F             
2188   117F             ; p = p + 2; 
2189   117F FA FF FF      lea d, [bp + -1] ; $p
2190   1182 DA            push d
2191   1183 FA FF FF      lea d, [bp + -1] ; $p
2192   1186 2A            mov b, [d]
2193   1187 38 00 00      mov c, 0
2194   118A             ; --- START TERMS
2195   118A D7            push a
2196   118B 11            mov a, b
2197   118C FD 2E 02 00   mov32 cb, $00000002
2197   1190 00 00 
2198   1192 56            add b, a
2199   1193 E4            pop a
2200   1194             ; --- END TERMS
2201   1194 E7            pop d
2202   1195 FD 43         mov [d], b
2203   1197             ; break; 
2204   1197 0A 4F 12      jmp _switch27_exit ; case break
2205   119A             _switch27_case6:
2206   119A             ; *sp++ = *(char *)p; 
2207   119A FA FB FF      lea d, [bp + -5] ; $sp
2208   119D 2A            mov b, [d]
2209   119E 38 00 00      mov c, 0
2210   11A1 FD 77         inc b
2211   11A3 FA FB FF      lea d, [bp + -5] ; $sp
2212   11A6 FD 43         mov [d], b
2213   11A8 FD 7D         dec b
2214   11AA D8            push b
2215   11AB FA FF FF      lea d, [bp + -1] ; $p
2216   11AE 2A            mov b, [d]
2217   11AF 38 00 00      mov c, 0
2218   11B2 74            mov d, b
2219   11B3 32            mov bl, [d]
2220   11B4 A7 00         mov bh, 0
2221   11B6 38 00 00      mov c, 0
2222   11B9 E7            pop d
2223   11BA FD 3E         mov [d], bl
2224   11BC             ; p = p + 1; 
2225   11BC FA FF FF      lea d, [bp + -1] ; $p
2226   11BF DA            push d
2227   11C0 FA FF FF      lea d, [bp + -1] ; $p
2228   11C3 2A            mov b, [d]
2229   11C4 38 00 00      mov c, 0
2230   11C7             ; --- START TERMS
2231   11C7 D7            push a
2232   11C8 11            mov a, b
2233   11C9 FD 2E 01 00   mov32 cb, $00000001
2233   11CD 00 00 
2234   11CF 56            add b, a
2235   11D0 E4            pop a
2236   11D1             ; --- END TERMS
2237   11D1 E7            pop d
2238   11D2 FD 43         mov [d], b
2239   11D4             ; break; 
2240   11D4 0A 4F 12      jmp _switch27_exit ; case break
2241   11D7             _switch27_case7:
2242   11D7             ; int len = strlen(*(char **)p); 
2243   11D7 52 02 00      sub sp, 2
2244   11DA             ; --- START LOCAL VAR INITIALIZATION
2245   11DA FA F9 FF      lea d, [bp + -7] ; $len
2246   11DD DA            push d
2247   11DE             ; --- START FUNCTION CALL
2248   11DE FA FF FF      lea d, [bp + -1] ; $p
2249   11E1 2A            mov b, [d]
2250   11E2 38 00 00      mov c, 0
2251   11E5 74            mov d, b
2252   11E6 2A            mov b, [d]
2253   11E7 FD AB         swp b
2254   11E9 D8            push b
2255   11EA 07 05 06      call strlen
2256   11ED 51 02 00      add sp, 2
2257   11F0             ; --- END FUNCTION CALL
2258   11F0 E7            pop d
2259   11F1 FD 43         mov [d], b
2260   11F3             ; --- END LOCAL VAR INITIALIZATION
2261   11F3             ; strcpy(sp, *(char **)p); 
2262   11F3             ; --- START FUNCTION CALL
2263   11F3 FA FF FF      lea d, [bp + -1] ; $p
2264   11F6 2A            mov b, [d]
2265   11F7 38 00 00      mov c, 0
2266   11FA 74            mov d, b
2267   11FB 2A            mov b, [d]
2268   11FC FD AB         swp b
2269   11FE D8            push b
2270   11FF FA FB FF      lea d, [bp + -5] ; $sp
2271   1202 2A            mov b, [d]
2272   1203 38 00 00      mov c, 0
2273   1206 FD AB         swp b
2274   1208 D8            push b
2275   1209 07 1F 04      call strcpy
2276   120C 51 04 00      add sp, 4
2277   120F             ; --- END FUNCTION CALL
2278   120F             ; sp = sp + len; 
2279   120F FA FB FF      lea d, [bp + -5] ; $sp
2280   1212 DA            push d
2281   1213 FA FB FF      lea d, [bp + -5] ; $sp
2282   1216 2A            mov b, [d]
2283   1217 38 00 00      mov c, 0
2284   121A             ; --- START TERMS
2285   121A D7            push a
2286   121B 11            mov a, b
2287   121C FA F9 FF      lea d, [bp + -7] ; $len
2288   121F 2A            mov b, [d]
2289   1220 38 00 00      mov c, 0
2290   1223 56            add b, a
2291   1224 E4            pop a
2292   1225             ; --- END TERMS
2293   1225 E7            pop d
2294   1226 FD 43         mov [d], b
2295   1228             ; p = p + 2; 
2296   1228 FA FF FF      lea d, [bp + -1] ; $p
2297   122B DA            push d
2298   122C FA FF FF      lea d, [bp + -1] ; $p
2299   122F 2A            mov b, [d]
2300   1230 38 00 00      mov c, 0
2301   1233             ; --- START TERMS
2302   1233 D7            push a
2303   1234 11            mov a, b
2304   1235 FD 2E 02 00   mov32 cb, $00000002
2304   1239 00 00 
2305   123B 56            add b, a
2306   123C E4            pop a
2307   123D             ; --- END TERMS
2308   123D E7            pop d
2309   123E FD 43         mov [d], b
2310   1240             ; break; 
2311   1240 0A 4F 12      jmp _switch27_exit ; case break
2312   1243             _switch27_default:
2313   1243             ; print("Error: Unknown argument type.\n"); 
2314   1243             ; --- START FUNCTION CALL
2315   1243 26 77 21      mov b, _s1 ; "Error: Unknown argument type.\n"
2316   1246 FD AB         swp b
2317   1248 D8            push b
2318   1249 07 F1 1C      call print
2319   124C 51 02 00      add sp, 2
2320   124F             ; --- END FUNCTION CALL
2321   124F             _switch27_exit:
2322   124F             ; format_p++; 
2323   124F FA FD FF      lea d, [bp + -3] ; $format_p
2324   1252 2A            mov b, [d]
2325   1253 38 00 00      mov c, 0
2326   1256 FD 77         inc b
2327   1258 FA FD FF      lea d, [bp + -3] ; $format_p
2328   125B FD 43         mov [d], b
2329   125D FD 7D         dec b
2330   125F 0A 8D 12      jmp _if26_exit
2331   1262             _if26_else:
2332   1262             ; *sp++ = *format_p++; 
2333   1262 FA FB FF      lea d, [bp + -5] ; $sp
2334   1265 2A            mov b, [d]
2335   1266 38 00 00      mov c, 0
2336   1269 FD 77         inc b
2337   126B FA FB FF      lea d, [bp + -5] ; $sp
2338   126E FD 43         mov [d], b
2339   1270 FD 7D         dec b
2340   1272 D8            push b
2341   1273 FA FD FF      lea d, [bp + -3] ; $format_p
2342   1276 2A            mov b, [d]
2343   1277 38 00 00      mov c, 0
2344   127A FD 77         inc b
2345   127C FA FD FF      lea d, [bp + -3] ; $format_p
2346   127F FD 43         mov [d], b
2347   1281 FD 7D         dec b
2348   1283 74            mov d, b
2349   1284 32            mov bl, [d]
2350   1285 A7 00         mov bh, 0
2351   1287 38 00 00      mov c, 0
2352   128A E7            pop d
2353   128B FD 3E         mov [d], bl
2354   128D             _if26_exit:
2355   128D             _if25_exit:
2356   128D             _for24_update:
2357   128D 0A 43 0F      jmp _for24_cond
2358   1290             _for24_exit:
2359   1290             ; *sp = '\0'; 
2360   1290 FA FB FF      lea d, [bp + -5] ; $sp
2361   1293 2A            mov b, [d]
2362   1294 38 00 00      mov c, 0
2363   1297 D8            push b
2364   1298 FD 2E 00 00   mov32 cb, $00000000
2364   129C 00 00 
2365   129E E7            pop d
2366   129F FD 3E         mov [d], bl
2367   12A1             ; return sp - dest; // return total number of chars written 
2368   12A1 FA FB FF      lea d, [bp + -5] ; $sp
2369   12A4 2A            mov b, [d]
2370   12A5 38 00 00      mov c, 0
2371   12A8             ; --- START TERMS
2372   12A8 D7            push a
2373   12A9 11            mov a, b
2374   12AA FA 05 00      lea d, [bp + 5] ; $dest
2375   12AD 2A            mov b, [d]
2376   12AE 38 00 00      mov c, 0
2377   12B1 60            sub a, b
2378   12B2 27            mov b, a
2379   12B3 E4            pop a
2380   12B4             ; --- END TERMS
2381   12B4 F9            leave
2382   12B5 09            ret
2383   12B6             
2384   12B6             err:
2385   12B6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2386   12B9             ; print(e); 
2387   12B9             ; --- START FUNCTION CALL
2388   12B9 FA 05 00      lea d, [bp + 5] ; $e
2389   12BC 2A            mov b, [d]
2390   12BD 38 00 00      mov c, 0
2391   12C0 FD AB         swp b
2392   12C2 D8            push b
2393   12C3 07 F1 1C      call print
2394   12C6 51 02 00      add sp, 2
2395   12C9             ; --- END FUNCTION CALL
2396   12C9 F9            leave
2397   12CA 09            ret
2398   12CB             
2399   12CB             printx32:
2400   12CB F8 00 00      enter 0 ; (push bp; mov bp, sp)
2401   12CE             
2402   12CE             ; --- BEGIN INLINE ASM SEGMENT
2403   12CE FA 05 00      lea d, [bp + 5] ; $hex
2404   12D1 2B 02 00      mov b, [d+2]
2405   12D4 07 54 20      call print_u16x
2406   12D7 2A            mov b, [d]
2407   12D8 07 54 20      call print_u16x
2408   12DB             ; --- END INLINE ASM SEGMENT
2409   12DB             
2410   12DB F9            leave
2411   12DC 09            ret
2412   12DD             
2413   12DD             printx16:
2414   12DD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2415   12E0             
2416   12E0             ; --- BEGIN INLINE ASM SEGMENT
2417   12E0 FA 05 00      lea d, [bp + 5] ; $hex
2418   12E3 2A            mov b, [d]
2419   12E4 07 54 20      call print_u16x
2420   12E7             ; --- END INLINE ASM SEGMENT
2421   12E7             
2422   12E7 F9            leave
2423   12E8 09            ret
2424   12E9             
2425   12E9             printx8:
2426   12E9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2427   12EC             
2428   12EC             ; --- BEGIN INLINE ASM SEGMENT
2429   12EC FA 05 00      lea d, [bp + 5] ; $hex
2430   12EF 32            mov bl, [d]
2431   12F0 07 98 20      call print_u8x
2432   12F3             ; --- END INLINE ASM SEGMENT
2433   12F3             
2434   12F3 F9            leave
2435   12F4 09            ret
2436   12F5             
2437   12F5             hex_str_to_int:
2438   12F5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2439   12F8             ; int value = 0; 
2440   12F8 52 02 00      sub sp, 2
2441   12FB             ; --- START LOCAL VAR INITIALIZATION
2442   12FB FA FF FF      lea d, [bp + -1] ; $value
2443   12FE DA            push d
2444   12FF FD 2E 00 00   mov32 cb, $00000000
2444   1303 00 00 
2445   1305 E7            pop d
2446   1306 FD 43         mov [d], b
2447   1308             ; --- END LOCAL VAR INITIALIZATION
2448   1308             ; int i; 
2449   1308 52 02 00      sub sp, 2
2450   130B             ; char hex_char; 
2451   130B 52 01 00      sub sp, 1
2452   130E             ; int len; 
2453   130E 52 02 00      sub sp, 2
2454   1311             ; len = strlen(hex_string); 
2455   1311 FA FA FF      lea d, [bp + -6] ; $len
2456   1314 DA            push d
2457   1315             ; --- START FUNCTION CALL
2458   1315 FA 05 00      lea d, [bp + 5] ; $hex_string
2459   1318 2A            mov b, [d]
2460   1319 38 00 00      mov c, 0
2461   131C FD AB         swp b
2462   131E D8            push b
2463   131F 07 05 06      call strlen
2464   1322 51 02 00      add sp, 2
2465   1325             ; --- END FUNCTION CALL
2466   1325 E7            pop d
2467   1326 FD 43         mov [d], b
2468   1328             ; for (i = 0; i < len; i++) { 
2469   1328             _for31_init:
2470   1328 FA FD FF      lea d, [bp + -3] ; $i
2471   132B DA            push d
2472   132C FD 2E 00 00   mov32 cb, $00000000
2472   1330 00 00 
2473   1332 E7            pop d
2474   1333 FD 43         mov [d], b
2475   1335             _for31_cond:
2476   1335 FA FD FF      lea d, [bp + -3] ; $i
2477   1338 2A            mov b, [d]
2478   1339 38 00 00      mov c, 0
2479   133C             ; --- START RELATIONAL
2480   133C D7            push a
2481   133D 11            mov a, b
2482   133E FA FA FF      lea d, [bp + -6] ; $len
2483   1341 2A            mov b, [d]
2484   1342 38 00 00      mov c, 0
2485   1345 B0            cmp a, b
2486   1346 FD 73         slt ; < (signed)
2487   1348 E4            pop a
2488   1349             ; --- END RELATIONAL
2489   1349 C0 00 00      cmp b, 0
2490   134C C6 99 14      je _for31_exit
2491   134F             _for31_block:
2492   134F             ; hex_char = hex_string[i]; 
2493   134F FA FC FF      lea d, [bp + -4] ; $hex_char
2494   1352 DA            push d
2495   1353 FA 05 00      lea d, [bp + 5] ; $hex_string
2496   1356 FD 2A         mov d, [d]
2497   1358 D7            push a
2498   1359 DA            push d
2499   135A FA FD FF      lea d, [bp + -3] ; $i
2500   135D 2A            mov b, [d]
2501   135E 38 00 00      mov c, 0
2502   1361 E7            pop d
2503   1362 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2504   1366 E4            pop a
2505   1367 32            mov bl, [d]
2506   1368 A7 00         mov bh, 0
2507   136A 38 00 00      mov c, 0
2508   136D E7            pop d
2509   136E FD 3E         mov [d], bl
2510   1370             ; if (hex_char >= 'a' && hex_char <= 'f')  
2511   1370             _if32_cond:
2512   1370 FA FC FF      lea d, [bp + -4] ; $hex_char
2513   1373 32            mov bl, [d]
2514   1374 A7 00         mov bh, 0
2515   1376 38 00 00      mov c, 0
2516   1379             ; --- START RELATIONAL
2517   1379 D7            push a
2518   137A 11            mov a, b
2519   137B FD 2E 61 00   mov32 cb, $00000061
2519   137F 00 00 
2520   1381 B0            cmp a, b
2521   1382 FD 80         sge ; >=
2522   1384 E4            pop a
2523   1385             ; --- END RELATIONAL
2524   1385             ; --- START LOGICAL AND
2525   1385 D7            push a
2526   1386 11            mov a, b
2527   1387 FA FC FF      lea d, [bp + -4] ; $hex_char
2528   138A 32            mov bl, [d]
2529   138B A7 00         mov bh, 0
2530   138D 38 00 00      mov c, 0
2531   1390             ; --- START RELATIONAL
2532   1390 D7            push a
2533   1391 11            mov a, b
2534   1392 FD 2E 66 00   mov32 cb, $00000066
2534   1396 00 00 
2535   1398 B0            cmp a, b
2536   1399 FD 74         sle ; <= (signed)
2537   139B E4            pop a
2538   139C             ; --- END RELATIONAL
2539   139C FD A7         sand a, b
2540   139E E4            pop a
2541   139F             ; --- END LOGICAL AND
2542   139F C0 00 00      cmp b, 0
2543   13A2 C6 E2 13      je _if32_else
2544   13A5             _if32_true:
2545   13A5             ; value = (value * 16) + (hex_char - 'a' + 10); 
2546   13A5 FA FF FF      lea d, [bp + -1] ; $value
2547   13A8 DA            push d
2548   13A9 FA FF FF      lea d, [bp + -1] ; $value
2549   13AC 2A            mov b, [d]
2550   13AD 38 00 00      mov c, 0
2551   13B0             ; --- START FACTORS
2552   13B0 D7            push a
2553   13B1 11            mov a, b
2554   13B2 FD 2E 10 00   mov32 cb, $00000010
2554   13B6 00 00 
2555   13B8 AC            mul a, b ; *
2556   13B9 11            mov a, b
2557   13BA 27            mov b, a
2558   13BB E4            pop a
2559   13BC             ; --- END FACTORS
2560   13BC             ; --- START TERMS
2561   13BC D7            push a
2562   13BD 11            mov a, b
2563   13BE FA FC FF      lea d, [bp + -4] ; $hex_char
2564   13C1 32            mov bl, [d]
2565   13C2 A7 00         mov bh, 0
2566   13C4 38 00 00      mov c, 0
2567   13C7             ; --- START TERMS
2568   13C7 D7            push a
2569   13C8 11            mov a, b
2570   13C9 FD 2E 61 00   mov32 cb, $00000061
2570   13CD 00 00 
2571   13CF 60            sub a, b
2572   13D0 27            mov b, a
2573   13D1 11            mov a, b
2574   13D2 FD 2E 0A 00   mov32 cb, $0000000a
2574   13D6 00 00 
2575   13D8 56            add b, a
2576   13D9 E4            pop a
2577   13DA             ; --- END TERMS
2578   13DA 56            add b, a
2579   13DB E4            pop a
2580   13DC             ; --- END TERMS
2581   13DC E7            pop d
2582   13DD FD 43         mov [d], b
2583   13DF 0A 86 14      jmp _if32_exit
2584   13E2             _if32_else:
2585   13E2             ; if (hex_char >= 'A' && hex_char <= 'F')  
2586   13E2             _if33_cond:
2587   13E2 FA FC FF      lea d, [bp + -4] ; $hex_char
2588   13E5 32            mov bl, [d]
2589   13E6 A7 00         mov bh, 0
2590   13E8 38 00 00      mov c, 0
2591   13EB             ; --- START RELATIONAL
2592   13EB D7            push a
2593   13EC 11            mov a, b
2594   13ED FD 2E 41 00   mov32 cb, $00000041
2594   13F1 00 00 
2595   13F3 B0            cmp a, b
2596   13F4 FD 80         sge ; >=
2597   13F6 E4            pop a
2598   13F7             ; --- END RELATIONAL
2599   13F7             ; --- START LOGICAL AND
2600   13F7 D7            push a
2601   13F8 11            mov a, b
2602   13F9 FA FC FF      lea d, [bp + -4] ; $hex_char
2603   13FC 32            mov bl, [d]
2604   13FD A7 00         mov bh, 0
2605   13FF 38 00 00      mov c, 0
2606   1402             ; --- START RELATIONAL
2607   1402 D7            push a
2608   1403 11            mov a, b
2609   1404 FD 2E 46 00   mov32 cb, $00000046
2609   1408 00 00 
2610   140A B0            cmp a, b
2611   140B FD 74         sle ; <= (signed)
2612   140D E4            pop a
2613   140E             ; --- END RELATIONAL
2614   140E FD A7         sand a, b
2615   1410 E4            pop a
2616   1411             ; --- END LOGICAL AND
2617   1411 C0 00 00      cmp b, 0
2618   1414 C6 54 14      je _if33_else
2619   1417             _if33_true:
2620   1417             ; value = (value * 16) + (hex_char - 'A' + 10); 
2621   1417 FA FF FF      lea d, [bp + -1] ; $value
2622   141A DA            push d
2623   141B FA FF FF      lea d, [bp + -1] ; $value
2624   141E 2A            mov b, [d]
2625   141F 38 00 00      mov c, 0
2626   1422             ; --- START FACTORS
2627   1422 D7            push a
2628   1423 11            mov a, b
2629   1424 FD 2E 10 00   mov32 cb, $00000010
2629   1428 00 00 
2630   142A AC            mul a, b ; *
2631   142B 11            mov a, b
2632   142C 27            mov b, a
2633   142D E4            pop a
2634   142E             ; --- END FACTORS
2635   142E             ; --- START TERMS
2636   142E D7            push a
2637   142F 11            mov a, b
2638   1430 FA FC FF      lea d, [bp + -4] ; $hex_char
2639   1433 32            mov bl, [d]
2640   1434 A7 00         mov bh, 0
2641   1436 38 00 00      mov c, 0
2642   1439             ; --- START TERMS
2643   1439 D7            push a
2644   143A 11            mov a, b
2645   143B FD 2E 41 00   mov32 cb, $00000041
2645   143F 00 00 
2646   1441 60            sub a, b
2647   1442 27            mov b, a
2648   1443 11            mov a, b
2649   1444 FD 2E 0A 00   mov32 cb, $0000000a
2649   1448 00 00 
2650   144A 56            add b, a
2651   144B E4            pop a
2652   144C             ; --- END TERMS
2653   144C 56            add b, a
2654   144D E4            pop a
2655   144E             ; --- END TERMS
2656   144E E7            pop d
2657   144F FD 43         mov [d], b
2658   1451 0A 86 14      jmp _if33_exit
2659   1454             _if33_else:
2660   1454             ; value = (value * 16) + (hex_char - '0'); 
2661   1454 FA FF FF      lea d, [bp + -1] ; $value
2662   1457 DA            push d
2663   1458 FA FF FF      lea d, [bp + -1] ; $value
2664   145B 2A            mov b, [d]
2665   145C 38 00 00      mov c, 0
2666   145F             ; --- START FACTORS
2667   145F D7            push a
2668   1460 11            mov a, b
2669   1461 FD 2E 10 00   mov32 cb, $00000010
2669   1465 00 00 
2670   1467 AC            mul a, b ; *
2671   1468 11            mov a, b
2672   1469 27            mov b, a
2673   146A E4            pop a
2674   146B             ; --- END FACTORS
2675   146B             ; --- START TERMS
2676   146B D7            push a
2677   146C 11            mov a, b
2678   146D FA FC FF      lea d, [bp + -4] ; $hex_char
2679   1470 32            mov bl, [d]
2680   1471 A7 00         mov bh, 0
2681   1473 38 00 00      mov c, 0
2682   1476             ; --- START TERMS
2683   1476 D7            push a
2684   1477 11            mov a, b
2685   1478 FD 2E 30 00   mov32 cb, $00000030
2685   147C 00 00 
2686   147E 60            sub a, b
2687   147F 27            mov b, a
2688   1480 E4            pop a
2689   1481             ; --- END TERMS
2690   1481 56            add b, a
2691   1482 E4            pop a
2692   1483             ; --- END TERMS
2693   1483 E7            pop d
2694   1484 FD 43         mov [d], b
2695   1486             _if33_exit:
2696   1486             _if32_exit:
2697   1486             _for31_update:
2698   1486 FA FD FF      lea d, [bp + -3] ; $i
2699   1489 2A            mov b, [d]
2700   148A 38 00 00      mov c, 0
2701   148D FD 77         inc b
2702   148F FA FD FF      lea d, [bp + -3] ; $i
2703   1492 FD 43         mov [d], b
2704   1494 FD 7D         dec b
2705   1496 0A 35 13      jmp _for31_cond
2706   1499             _for31_exit:
2707   1499             ; return value; 
2708   1499 FA FF FF      lea d, [bp + -1] ; $value
2709   149C 2A            mov b, [d]
2710   149D 38 00 00      mov c, 0
2711   14A0 F9            leave
2712   14A1 09            ret
2713   14A2             
2714   14A2             gets:
2715   14A2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2716   14A5             
2717   14A5             ; --- BEGIN INLINE ASM SEGMENT
2718   14A5 FA 05 00      lea d, [bp + 5] ; $s
2719   14A8 15            mov a, [d]
2720   14A9 3C            mov d, a
2721   14AA 07 B9 1E      call _gets
2722   14AD             ; --- END INLINE ASM SEGMENT
2723   14AD             
2724   14AD             ; return strlen(s); 
2725   14AD             ; --- START FUNCTION CALL
2726   14AD FA 05 00      lea d, [bp + 5] ; $s
2727   14B0 2A            mov b, [d]
2728   14B1 38 00 00      mov c, 0
2729   14B4 FD AB         swp b
2730   14B6 D8            push b
2731   14B7 07 05 06      call strlen
2732   14BA 51 02 00      add sp, 2
2733   14BD             ; --- END FUNCTION CALL
2734   14BD F9            leave
2735   14BE 09            ret
2736   14BF             
2737   14BF             print_signed:
2738   14BF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2739   14C2             ; char digits[5]; 
2740   14C2 52 05 00      sub sp, 5
2741   14C5             ; int i = 0; 
2742   14C5 52 02 00      sub sp, 2
2743   14C8             ; --- START LOCAL VAR INITIALIZATION
2744   14C8 FA FA FF      lea d, [bp + -6] ; $i
2745   14CB DA            push d
2746   14CC FD 2E 00 00   mov32 cb, $00000000
2746   14D0 00 00 
2747   14D2 E7            pop d
2748   14D3 FD 43         mov [d], b
2749   14D5             ; --- END LOCAL VAR INITIALIZATION
2750   14D5             ; if (num < 0) { 
2751   14D5             _if34_cond:
2752   14D5 FA 05 00      lea d, [bp + 5] ; $num
2753   14D8 2A            mov b, [d]
2754   14D9 38 00 00      mov c, 0
2755   14DC             ; --- START RELATIONAL
2756   14DC D7            push a
2757   14DD 11            mov a, b
2758   14DE FD 2E 00 00   mov32 cb, $00000000
2758   14E2 00 00 
2759   14E4 B0            cmp a, b
2760   14E5 FD 73         slt ; < (signed)
2761   14E7 E4            pop a
2762   14E8             ; --- END RELATIONAL
2763   14E8 C0 00 00      cmp b, 0
2764   14EB C6 0E 15      je _if34_else
2765   14EE             _if34_true:
2766   14EE             ; putchar('-'); 
2767   14EE             ; --- START FUNCTION CALL
2768   14EE FD 2E 2D 00   mov32 cb, $0000002d
2768   14F2 00 00 
2769   14F4 DD            push bl
2770   14F5 07 A3 1C      call putchar
2771   14F8 51 01 00      add sp, 1
2772   14FB             ; --- END FUNCTION CALL
2773   14FB             ; num = -num; 
2774   14FB FA 05 00      lea d, [bp + 5] ; $num
2775   14FE DA            push d
2776   14FF FA 05 00      lea d, [bp + 5] ; $num
2777   1502 2A            mov b, [d]
2778   1503 38 00 00      mov c, 0
2779   1506 FD 97         neg b
2780   1508 E7            pop d
2781   1509 FD 43         mov [d], b
2782   150B 0A 39 15      jmp _if34_exit
2783   150E             _if34_else:
2784   150E             ; if (num == 0) { 
2785   150E             _if35_cond:
2786   150E FA 05 00      lea d, [bp + 5] ; $num
2787   1511 2A            mov b, [d]
2788   1512 38 00 00      mov c, 0
2789   1515             ; --- START RELATIONAL
2790   1515 D7            push a
2791   1516 11            mov a, b
2792   1517 FD 2E 00 00   mov32 cb, $00000000
2792   151B 00 00 
2793   151D B0            cmp a, b
2794   151E FD 71         seq ; ==
2795   1520 E4            pop a
2796   1521             ; --- END RELATIONAL
2797   1521 C0 00 00      cmp b, 0
2798   1524 C6 39 15      je _if35_exit
2799   1527             _if35_true:
2800   1527             ; putchar('0'); 
2801   1527             ; --- START FUNCTION CALL
2802   1527 FD 2E 30 00   mov32 cb, $00000030
2802   152B 00 00 
2803   152D DD            push bl
2804   152E 07 A3 1C      call putchar
2805   1531 51 01 00      add sp, 1
2806   1534             ; --- END FUNCTION CALL
2807   1534             ; return; 
2808   1534 F9            leave
2809   1535 09            ret
2810   1536 0A 39 15      jmp _if35_exit
2811   1539             _if35_exit:
2812   1539             _if34_exit:
2813   1539             ; while (num > 0) { 
2814   1539             _while36_cond:
2815   1539 FA 05 00      lea d, [bp + 5] ; $num
2816   153C 2A            mov b, [d]
2817   153D 38 00 00      mov c, 0
2818   1540             ; --- START RELATIONAL
2819   1540 D7            push a
2820   1541 11            mov a, b
2821   1542 FD 2E 00 00   mov32 cb, $00000000
2821   1546 00 00 
2822   1548 B0            cmp a, b
2823   1549 FD 7F         sgt ; >
2824   154B E4            pop a
2825   154C             ; --- END RELATIONAL
2826   154C C0 00 00      cmp b, 0
2827   154F C6 AE 15      je _while36_exit
2828   1552             _while36_block:
2829   1552             ; digits[i] = '0' + (num % 10); 
2830   1552 FA FC FF      lea d, [bp + -4] ; $digits
2831   1555 D7            push a
2832   1556 DA            push d
2833   1557 FA FA FF      lea d, [bp + -6] ; $i
2834   155A 2A            mov b, [d]
2835   155B 38 00 00      mov c, 0
2836   155E E7            pop d
2837   155F 5A            add d, b
2838   1560 E4            pop a
2839   1561 DA            push d
2840   1562 FD 2E 30 00   mov32 cb, $00000030
2840   1566 00 00 
2841   1568             ; --- START TERMS
2842   1568 D7            push a
2843   1569 11            mov a, b
2844   156A FA 05 00      lea d, [bp + 5] ; $num
2845   156D 2A            mov b, [d]
2846   156E 38 00 00      mov c, 0
2847   1571             ; --- START FACTORS
2848   1571 D7            push a
2849   1572 11            mov a, b
2850   1573 FD 2E 0A 00   mov32 cb, $0000000a
2850   1577 00 00 
2851   1579 AE            div a, b ; 
2852   157A 11            mov a, b
2853   157B 27            mov b, a
2854   157C E4            pop a
2855   157D             ; --- END FACTORS
2856   157D 56            add b, a
2857   157E E4            pop a
2858   157F             ; --- END TERMS
2859   157F E7            pop d
2860   1580 FD 3E         mov [d], bl
2861   1582             ; num = num / 10; 
2862   1582 FA 05 00      lea d, [bp + 5] ; $num
2863   1585 DA            push d
2864   1586 FA 05 00      lea d, [bp + 5] ; $num
2865   1589 2A            mov b, [d]
2866   158A 38 00 00      mov c, 0
2867   158D             ; --- START FACTORS
2868   158D D7            push a
2869   158E 11            mov a, b
2870   158F FD 2E 0A 00   mov32 cb, $0000000a
2870   1593 00 00 
2871   1595 AE            div a, b
2872   1596 27            mov b, a
2873   1597 E4            pop a
2874   1598             ; --- END FACTORS
2875   1598 E7            pop d
2876   1599 FD 43         mov [d], b
2877   159B             ; i++; 
2878   159B FA FA FF      lea d, [bp + -6] ; $i
2879   159E 2A            mov b, [d]
2880   159F 38 00 00      mov c, 0
2881   15A2 FD 77         inc b
2882   15A4 FA FA FF      lea d, [bp + -6] ; $i
2883   15A7 FD 43         mov [d], b
2884   15A9 FD 7D         dec b
2885   15AB 0A 39 15      jmp _while36_cond
2886   15AE             _while36_exit:
2887   15AE             ; while (i > 0) { 
2888   15AE             _while37_cond:
2889   15AE FA FA FF      lea d, [bp + -6] ; $i
2890   15B1 2A            mov b, [d]
2891   15B2 38 00 00      mov c, 0
2892   15B5             ; --- START RELATIONAL
2893   15B5 D7            push a
2894   15B6 11            mov a, b
2895   15B7 FD 2E 00 00   mov32 cb, $00000000
2895   15BB 00 00 
2896   15BD B0            cmp a, b
2897   15BE FD 7F         sgt ; >
2898   15C0 E4            pop a
2899   15C1             ; --- END RELATIONAL
2900   15C1 C0 00 00      cmp b, 0
2901   15C4 C6 F6 15      je _while37_exit
2902   15C7             _while37_block:
2903   15C7             ; i--; 
2904   15C7 FA FA FF      lea d, [bp + -6] ; $i
2905   15CA 2A            mov b, [d]
2906   15CB 38 00 00      mov c, 0
2907   15CE FD 7D         dec b
2908   15D0 FA FA FF      lea d, [bp + -6] ; $i
2909   15D3 FD 43         mov [d], b
2910   15D5 FD 77         inc b
2911   15D7             ; putchar(digits[i]); 
2912   15D7             ; --- START FUNCTION CALL
2913   15D7 FA FC FF      lea d, [bp + -4] ; $digits
2914   15DA D7            push a
2915   15DB DA            push d
2916   15DC FA FA FF      lea d, [bp + -6] ; $i
2917   15DF 2A            mov b, [d]
2918   15E0 38 00 00      mov c, 0
2919   15E3 E7            pop d
2920   15E4 5A            add d, b
2921   15E5 E4            pop a
2922   15E6 32            mov bl, [d]
2923   15E7 A7 00         mov bh, 0
2924   15E9 38 00 00      mov c, 0
2925   15EC DD            push bl
2926   15ED 07 A3 1C      call putchar
2927   15F0 51 01 00      add sp, 1
2928   15F3             ; --- END FUNCTION CALL
2929   15F3 0A AE 15      jmp _while37_cond
2930   15F6             _while37_exit:
2931   15F6 F9            leave
2932   15F7 09            ret
2933   15F8             
2934   15F8             print_signed_long:
2935   15F8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2936   15FB             ; char digits[10]; 
2937   15FB 52 0A 00      sub sp, 10
2938   15FE             ; int i = 0; 
2939   15FE 52 02 00      sub sp, 2
2940   1601             ; --- START LOCAL VAR INITIALIZATION
2941   1601 FA F5 FF      lea d, [bp + -11] ; $i
2942   1604 DA            push d
2943   1605 FD 2E 00 00   mov32 cb, $00000000
2943   1609 00 00 
2944   160B E7            pop d
2945   160C FD 43         mov [d], b
2946   160E             ; --- END LOCAL VAR INITIALIZATION
2947   160E             ; if (num < 0) { 
2948   160E             _if38_cond:
2949   160E FA 05 00      lea d, [bp + 5] ; $num
2950   1611 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2951   1614 FD 39         mov c, b ; And place it into C
2952   1616 2A            mov b, [d] ; Lower Word in B
2953   1617             ; --- START RELATIONAL
2954   1617 D7            push a
2955   1618 FD D8         push g
2956   161A 11            mov a, b
2957   161B FD 7A         mov g, c
2958   161D FD 2E 00 00   mov32 cb, $00000000
2958   1621 00 00 
2959   1623 FD AF         cmp32 ga, cb
2960   1625 FD 73         slt ; <
2961   1627 FD F1         pop g
2962   1629 E4            pop a
2963   162A             ; --- END RELATIONAL
2964   162A C0 00 00      cmp b, 0
2965   162D C6 61 16      je _if38_else
2966   1630             _if38_true:
2967   1630             ; putchar('-'); 
2968   1630             ; --- START FUNCTION CALL
2969   1630 FD 2E 2D 00   mov32 cb, $0000002d
2969   1634 00 00 
2970   1636 DD            push bl
2971   1637 07 A3 1C      call putchar
2972   163A 51 01 00      add sp, 1
2973   163D             ; --- END FUNCTION CALL
2974   163D             ; num = -num; 
2975   163D FA 05 00      lea d, [bp + 5] ; $num
2976   1640 DA            push d
2977   1641 FA 05 00      lea d, [bp + 5] ; $num
2978   1644 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2979   1647 FD 39         mov c, b ; And place it into C
2980   1649 2A            mov b, [d] ; Lower Word in B
2981   164A 12            mov a, c
2982   164B 95            not a
2983   164C 97            not b
2984   164D 55 01 00      add b, 1
2985   1650 5B 00 00      adc a, 0
2986   1653 39            mov c, a
2987   1654 E7            pop d
2988   1655 FD 43         mov [d], b
2989   1657 26 00 00      mov b, 0
2990   165A FD 44 02 00   mov [d + 2], b
2991   165E 0A 95 16      jmp _if38_exit
2992   1661             _if38_else:
2993   1661             ; if (num == 0) { 
2994   1661             _if39_cond:
2995   1661 FA 05 00      lea d, [bp + 5] ; $num
2996   1664 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2997   1667 FD 39         mov c, b ; And place it into C
2998   1669 2A            mov b, [d] ; Lower Word in B
2999   166A             ; --- START RELATIONAL
3000   166A D7            push a
3001   166B FD D8         push g
3002   166D 11            mov a, b
3003   166E FD 7A         mov g, c
3004   1670 FD 2E 00 00   mov32 cb, $00000000
3004   1674 00 00 
3005   1676 FD AF         cmp32 ga, cb
3006   1678 FD 71         seq ; ==
3007   167A FD F1         pop g
3008   167C E4            pop a
3009   167D             ; --- END RELATIONAL
3010   167D C0 00 00      cmp b, 0
3011   1680 C6 95 16      je _if39_exit
3012   1683             _if39_true:
3013   1683             ; putchar('0'); 
3014   1683             ; --- START FUNCTION CALL
3015   1683 FD 2E 30 00   mov32 cb, $00000030
3015   1687 00 00 
3016   1689 DD            push bl
3017   168A 07 A3 1C      call putchar
3018   168D 51 01 00      add sp, 1
3019   1690             ; --- END FUNCTION CALL
3020   1690             ; return; 
3021   1690 F9            leave
3022   1691 09            ret
3023   1692 0A 95 16      jmp _if39_exit
3024   1695             _if39_exit:
3025   1695             _if38_exit:
3026   1695             ; while (num > 0) { 
3027   1695             _while40_cond:
3028   1695 FA 05 00      lea d, [bp + 5] ; $num
3029   1698 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3030   169B FD 39         mov c, b ; And place it into C
3031   169D 2A            mov b, [d] ; Lower Word in B
3032   169E             ; --- START RELATIONAL
3033   169E D7            push a
3034   169F FD D8         push g
3035   16A1 11            mov a, b
3036   16A2 FD 7A         mov g, c
3037   16A4 FD 2E 00 00   mov32 cb, $00000000
3037   16A8 00 00 
3038   16AA FD AF         cmp32 ga, cb
3039   16AC FD 7F         sgt
3040   16AE FD F1         pop g
3041   16B0 E4            pop a
3042   16B1             ; --- END RELATIONAL
3043   16B1 C0 00 00      cmp b, 0
3044   16B4 C6 1D 17      je _while40_exit
3045   16B7             _while40_block:
3046   16B7             ; digits[i] = '0' + (num % 10); 
3047   16B7 FA F7 FF      lea d, [bp + -9] ; $digits
3048   16BA D7            push a
3049   16BB DA            push d
3050   16BC FA F5 FF      lea d, [bp + -11] ; $i
3051   16BF 2A            mov b, [d]
3052   16C0 38 00 00      mov c, 0
3053   16C3 E7            pop d
3054   16C4 5A            add d, b
3055   16C5 E4            pop a
3056   16C6 DA            push d
3057   16C7 FD 2E 30 00   mov32 cb, $00000030
3057   16CB 00 00 
3058   16CD             ; --- START TERMS
3059   16CD D7            push a
3060   16CE 11            mov a, b
3061   16CF FA 05 00      lea d, [bp + 5] ; $num
3062   16D2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3063   16D5 FD 39         mov c, b ; And place it into C
3064   16D7 2A            mov b, [d] ; Lower Word in B
3065   16D8             ; --- START FACTORS
3066   16D8 D7            push a
3067   16D9 11            mov a, b
3068   16DA FD 2E 0A 00   mov32 cb, $0000000a
3068   16DE 00 00 
3069   16E0 AE            div a, b ; 
3070   16E1 11            mov a, b
3071   16E2 27            mov b, a
3072   16E3 E4            pop a
3073   16E4             ; --- END FACTORS
3074   16E4 FD 15         add32 cb, ga
3075   16E6 E4            pop a
3076   16E7             ; --- END TERMS
3077   16E7 E7            pop d
3078   16E8 FD 3E         mov [d], bl
3079   16EA             ; num = num / 10; 
3080   16EA FA 05 00      lea d, [bp + 5] ; $num
3081   16ED DA            push d
3082   16EE FA 05 00      lea d, [bp + 5] ; $num
3083   16F1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3084   16F4 FD 39         mov c, b ; And place it into C
3085   16F6 2A            mov b, [d] ; Lower Word in B
3086   16F7             ; --- START FACTORS
3087   16F7 D7            push a
3088   16F8 11            mov a, b
3089   16F9 FD 2E 0A 00   mov32 cb, $0000000a
3089   16FD 00 00 
3090   16FF AE            div a, b
3091   1700 27            mov b, a
3092   1701 E4            pop a
3093   1702             ; --- END FACTORS
3094   1702 E7            pop d
3095   1703 FD 43         mov [d], b
3096   1705 28            mov b, c
3097   1706 FD 44 02 00   mov [d + 2], b
3098   170A             ; i++; 
3099   170A FA F5 FF      lea d, [bp + -11] ; $i
3100   170D 2A            mov b, [d]
3101   170E 38 00 00      mov c, 0
3102   1711 FD 77         inc b
3103   1713 FA F5 FF      lea d, [bp + -11] ; $i
3104   1716 FD 43         mov [d], b
3105   1718 FD 7D         dec b
3106   171A 0A 95 16      jmp _while40_cond
3107   171D             _while40_exit:
3108   171D             ; while (i > 0) { 
3109   171D             _while41_cond:
3110   171D FA F5 FF      lea d, [bp + -11] ; $i
3111   1720 2A            mov b, [d]
3112   1721 38 00 00      mov c, 0
3113   1724             ; --- START RELATIONAL
3114   1724 D7            push a
3115   1725 11            mov a, b
3116   1726 FD 2E 00 00   mov32 cb, $00000000
3116   172A 00 00 
3117   172C B0            cmp a, b
3118   172D FD 7F         sgt ; >
3119   172F E4            pop a
3120   1730             ; --- END RELATIONAL
3121   1730 C0 00 00      cmp b, 0
3122   1733 C6 65 17      je _while41_exit
3123   1736             _while41_block:
3124   1736             ; i--; 
3125   1736 FA F5 FF      lea d, [bp + -11] ; $i
3126   1739 2A            mov b, [d]
3127   173A 38 00 00      mov c, 0
3128   173D FD 7D         dec b
3129   173F FA F5 FF      lea d, [bp + -11] ; $i
3130   1742 FD 43         mov [d], b
3131   1744 FD 77         inc b
3132   1746             ; putchar(digits[i]); 
3133   1746             ; --- START FUNCTION CALL
3134   1746 FA F7 FF      lea d, [bp + -9] ; $digits
3135   1749 D7            push a
3136   174A DA            push d
3137   174B FA F5 FF      lea d, [bp + -11] ; $i
3138   174E 2A            mov b, [d]
3139   174F 38 00 00      mov c, 0
3140   1752 E7            pop d
3141   1753 5A            add d, b
3142   1754 E4            pop a
3143   1755 32            mov bl, [d]
3144   1756 A7 00         mov bh, 0
3145   1758 38 00 00      mov c, 0
3146   175B DD            push bl
3147   175C 07 A3 1C      call putchar
3148   175F 51 01 00      add sp, 1
3149   1762             ; --- END FUNCTION CALL
3150   1762 0A 1D 17      jmp _while41_cond
3151   1765             _while41_exit:
3152   1765 F9            leave
3153   1766 09            ret
3154   1767             
3155   1767             print_unsigned_long:
3156   1767 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3157   176A             ; char digits[10]; 
3158   176A 52 0A 00      sub sp, 10
3159   176D             ; int i; 
3160   176D 52 02 00      sub sp, 2
3161   1770             ; i = 0; 
3162   1770 FA F5 FF      lea d, [bp + -11] ; $i
3163   1773 DA            push d
3164   1774 FD 2E 00 00   mov32 cb, $00000000
3164   1778 00 00 
3165   177A E7            pop d
3166   177B FD 43         mov [d], b
3167   177D             ; if(num == 0){ 
3168   177D             _if42_cond:
3169   177D FA 05 00      lea d, [bp + 5] ; $num
3170   1780 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3171   1783 FD 39         mov c, b ; And place it into C
3172   1785 2A            mov b, [d] ; Lower Word in B
3173   1786             ; --- START RELATIONAL
3174   1786 D7            push a
3175   1787 FD D8         push g
3176   1789 11            mov a, b
3177   178A FD 7A         mov g, c
3178   178C FD 2E 00 00   mov32 cb, $00000000
3178   1790 00 00 
3179   1792 FD AF         cmp32 ga, cb
3180   1794 FD 71         seq ; ==
3181   1796 FD F1         pop g
3182   1798 E4            pop a
3183   1799             ; --- END RELATIONAL
3184   1799 C0 00 00      cmp b, 0
3185   179C C6 B1 17      je _if42_exit
3186   179F             _if42_true:
3187   179F             ; putchar('0'); 
3188   179F             ; --- START FUNCTION CALL
3189   179F FD 2E 30 00   mov32 cb, $00000030
3189   17A3 00 00 
3190   17A5 DD            push bl
3191   17A6 07 A3 1C      call putchar
3192   17A9 51 01 00      add sp, 1
3193   17AC             ; --- END FUNCTION CALL
3194   17AC             ; return; 
3195   17AC F9            leave
3196   17AD 09            ret
3197   17AE 0A B1 17      jmp _if42_exit
3198   17B1             _if42_exit:
3199   17B1             ; while (num > 0) { 
3200   17B1             _while43_cond:
3201   17B1 FA 05 00      lea d, [bp + 5] ; $num
3202   17B4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3203   17B7 FD 39         mov c, b ; And place it into C
3204   17B9 2A            mov b, [d] ; Lower Word in B
3205   17BA             ; --- START RELATIONAL
3206   17BA D7            push a
3207   17BB FD D8         push g
3208   17BD 11            mov a, b
3209   17BE FD 7A         mov g, c
3210   17C0 FD 2E 00 00   mov32 cb, $00000000
3210   17C4 00 00 
3211   17C6 FD AF         cmp32 ga, cb
3212   17C8 FD 81         sgu
3213   17CA FD F1         pop g
3214   17CC E4            pop a
3215   17CD             ; --- END RELATIONAL
3216   17CD C0 00 00      cmp b, 0
3217   17D0 C6 39 18      je _while43_exit
3218   17D3             _while43_block:
3219   17D3             ; digits[i] = '0' + (num % 10); 
3220   17D3 FA F7 FF      lea d, [bp + -9] ; $digits
3221   17D6 D7            push a
3222   17D7 DA            push d
3223   17D8 FA F5 FF      lea d, [bp + -11] ; $i
3224   17DB 2A            mov b, [d]
3225   17DC 38 00 00      mov c, 0
3226   17DF E7            pop d
3227   17E0 5A            add d, b
3228   17E1 E4            pop a
3229   17E2 DA            push d
3230   17E3 FD 2E 30 00   mov32 cb, $00000030
3230   17E7 00 00 
3231   17E9             ; --- START TERMS
3232   17E9 D7            push a
3233   17EA 11            mov a, b
3234   17EB FA 05 00      lea d, [bp + 5] ; $num
3235   17EE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3236   17F1 FD 39         mov c, b ; And place it into C
3237   17F3 2A            mov b, [d] ; Lower Word in B
3238   17F4             ; --- START FACTORS
3239   17F4 D7            push a
3240   17F5 11            mov a, b
3241   17F6 FD 2E 0A 00   mov32 cb, $0000000a
3241   17FA 00 00 
3242   17FC AE            div a, b ; 
3243   17FD 11            mov a, b
3244   17FE 27            mov b, a
3245   17FF E4            pop a
3246   1800             ; --- END FACTORS
3247   1800 FD 15         add32 cb, ga
3248   1802 E4            pop a
3249   1803             ; --- END TERMS
3250   1803 E7            pop d
3251   1804 FD 3E         mov [d], bl
3252   1806             ; num = num / 10; 
3253   1806 FA 05 00      lea d, [bp + 5] ; $num
3254   1809 DA            push d
3255   180A FA 05 00      lea d, [bp + 5] ; $num
3256   180D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3257   1810 FD 39         mov c, b ; And place it into C
3258   1812 2A            mov b, [d] ; Lower Word in B
3259   1813             ; --- START FACTORS
3260   1813 D7            push a
3261   1814 11            mov a, b
3262   1815 FD 2E 0A 00   mov32 cb, $0000000a
3262   1819 00 00 
3263   181B AE            div a, b
3264   181C 27            mov b, a
3265   181D E4            pop a
3266   181E             ; --- END FACTORS
3267   181E E7            pop d
3268   181F FD 43         mov [d], b
3269   1821 28            mov b, c
3270   1822 FD 44 02 00   mov [d + 2], b
3271   1826             ; i++; 
3272   1826 FA F5 FF      lea d, [bp + -11] ; $i
3273   1829 2A            mov b, [d]
3274   182A 38 00 00      mov c, 0
3275   182D FD 77         inc b
3276   182F FA F5 FF      lea d, [bp + -11] ; $i
3277   1832 FD 43         mov [d], b
3278   1834 FD 7D         dec b
3279   1836 0A B1 17      jmp _while43_cond
3280   1839             _while43_exit:
3281   1839             ; while (i > 0) { 
3282   1839             _while44_cond:
3283   1839 FA F5 FF      lea d, [bp + -11] ; $i
3284   183C 2A            mov b, [d]
3285   183D 38 00 00      mov c, 0
3286   1840             ; --- START RELATIONAL
3287   1840 D7            push a
3288   1841 11            mov a, b
3289   1842 FD 2E 00 00   mov32 cb, $00000000
3289   1846 00 00 
3290   1848 B0            cmp a, b
3291   1849 FD 7F         sgt ; >
3292   184B E4            pop a
3293   184C             ; --- END RELATIONAL
3294   184C C0 00 00      cmp b, 0
3295   184F C6 81 18      je _while44_exit
3296   1852             _while44_block:
3297   1852             ; i--; 
3298   1852 FA F5 FF      lea d, [bp + -11] ; $i
3299   1855 2A            mov b, [d]
3300   1856 38 00 00      mov c, 0
3301   1859 FD 7D         dec b
3302   185B FA F5 FF      lea d, [bp + -11] ; $i
3303   185E FD 43         mov [d], b
3304   1860 FD 77         inc b
3305   1862             ; putchar(digits[i]); 
3306   1862             ; --- START FUNCTION CALL
3307   1862 FA F7 FF      lea d, [bp + -9] ; $digits
3308   1865 D7            push a
3309   1866 DA            push d
3310   1867 FA F5 FF      lea d, [bp + -11] ; $i
3311   186A 2A            mov b, [d]
3312   186B 38 00 00      mov c, 0
3313   186E E7            pop d
3314   186F 5A            add d, b
3315   1870 E4            pop a
3316   1871 32            mov bl, [d]
3317   1872 A7 00         mov bh, 0
3318   1874 38 00 00      mov c, 0
3319   1877 DD            push bl
3320   1878 07 A3 1C      call putchar
3321   187B 51 01 00      add sp, 1
3322   187E             ; --- END FUNCTION CALL
3323   187E 0A 39 18      jmp _while44_cond
3324   1881             _while44_exit:
3325   1881 F9            leave
3326   1882 09            ret
3327   1883             
3328   1883             sprint_unsigned:
3329   1883 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3330   1886             ; char digits[5]; 
3331   1886 52 05 00      sub sp, 5
3332   1889             ; int i; 
3333   1889 52 02 00      sub sp, 2
3334   188C             ; int len = 0; 
3335   188C 52 02 00      sub sp, 2
3336   188F             ; --- START LOCAL VAR INITIALIZATION
3337   188F FA F8 FF      lea d, [bp + -8] ; $len
3338   1892 DA            push d
3339   1893 FD 2E 00 00   mov32 cb, $00000000
3339   1897 00 00 
3340   1899 E7            pop d
3341   189A FD 43         mov [d], b
3342   189C             ; --- END LOCAL VAR INITIALIZATION
3343   189C             ; i = 0; 
3344   189C FA FA FF      lea d, [bp + -6] ; $i
3345   189F DA            push d
3346   18A0 FD 2E 00 00   mov32 cb, $00000000
3346   18A4 00 00 
3347   18A6 E7            pop d
3348   18A7 FD 43         mov [d], b
3349   18A9             ; if(num == 0){ 
3350   18A9             _if45_cond:
3351   18A9 FA 07 00      lea d, [bp + 7] ; $num
3352   18AC 2A            mov b, [d]
3353   18AD 38 00 00      mov c, 0
3354   18B0             ; --- START RELATIONAL
3355   18B0 D7            push a
3356   18B1 11            mov a, b
3357   18B2 FD 2E 00 00   mov32 cb, $00000000
3357   18B6 00 00 
3358   18B8 B0            cmp a, b
3359   18B9 FD 71         seq ; ==
3360   18BB E4            pop a
3361   18BC             ; --- END RELATIONAL
3362   18BC C0 00 00      cmp b, 0
3363   18BF C6 E7 18      je _if45_exit
3364   18C2             _if45_true:
3365   18C2             ; *dest++ = '0'; 
3366   18C2 FA 05 00      lea d, [bp + 5] ; $dest
3367   18C5 2A            mov b, [d]
3368   18C6 38 00 00      mov c, 0
3369   18C9 FD 77         inc b
3370   18CB FA 05 00      lea d, [bp + 5] ; $dest
3371   18CE FD 43         mov [d], b
3372   18D0 FD 7D         dec b
3373   18D2 D8            push b
3374   18D3 FD 2E 30 00   mov32 cb, $00000030
3374   18D7 00 00 
3375   18D9 E7            pop d
3376   18DA FD 3E         mov [d], bl
3377   18DC             ; return 1; 
3378   18DC FD 2E 01 00   mov32 cb, $00000001
3378   18E0 00 00 
3379   18E2 F9            leave
3380   18E3 09            ret
3381   18E4 0A E7 18      jmp _if45_exit
3382   18E7             _if45_exit:
3383   18E7             ; while (num > 0) { 
3384   18E7             _while46_cond:
3385   18E7 FA 07 00      lea d, [bp + 7] ; $num
3386   18EA 2A            mov b, [d]
3387   18EB 38 00 00      mov c, 0
3388   18EE             ; --- START RELATIONAL
3389   18EE D7            push a
3390   18EF 11            mov a, b
3391   18F0 FD 2E 00 00   mov32 cb, $00000000
3391   18F4 00 00 
3392   18F6 B0            cmp a, b
3393   18F7 FD 81         sgu ; > (unsigned)
3394   18F9 E4            pop a
3395   18FA             ; --- END RELATIONAL
3396   18FA C0 00 00      cmp b, 0
3397   18FD C6 5C 19      je _while46_exit
3398   1900             _while46_block:
3399   1900             ; digits[i] = '0' + (num % 10); 
3400   1900 FA FC FF      lea d, [bp + -4] ; $digits
3401   1903 D7            push a
3402   1904 DA            push d
3403   1905 FA FA FF      lea d, [bp + -6] ; $i
3404   1908 2A            mov b, [d]
3405   1909 38 00 00      mov c, 0
3406   190C E7            pop d
3407   190D 5A            add d, b
3408   190E E4            pop a
3409   190F DA            push d
3410   1910 FD 2E 30 00   mov32 cb, $00000030
3410   1914 00 00 
3411   1916             ; --- START TERMS
3412   1916 D7            push a
3413   1917 11            mov a, b
3414   1918 FA 07 00      lea d, [bp + 7] ; $num
3415   191B 2A            mov b, [d]
3416   191C 38 00 00      mov c, 0
3417   191F             ; --- START FACTORS
3418   191F D7            push a
3419   1920 11            mov a, b
3420   1921 FD 2E 0A 00   mov32 cb, $0000000a
3420   1925 00 00 
3421   1927 AE            div a, b ; 
3422   1928 11            mov a, b
3423   1929 27            mov b, a
3424   192A E4            pop a
3425   192B             ; --- END FACTORS
3426   192B 56            add b, a
3427   192C E4            pop a
3428   192D             ; --- END TERMS
3429   192D E7            pop d
3430   192E FD 3E         mov [d], bl
3431   1930             ; num = num / 10; 
3432   1930 FA 07 00      lea d, [bp + 7] ; $num
3433   1933 DA            push d
3434   1934 FA 07 00      lea d, [bp + 7] ; $num
3435   1937 2A            mov b, [d]
3436   1938 38 00 00      mov c, 0
3437   193B             ; --- START FACTORS
3438   193B D7            push a
3439   193C 11            mov a, b
3440   193D FD 2E 0A 00   mov32 cb, $0000000a
3440   1941 00 00 
3441   1943 AE            div a, b
3442   1944 27            mov b, a
3443   1945 E4            pop a
3444   1946             ; --- END FACTORS
3445   1946 E7            pop d
3446   1947 FD 43         mov [d], b
3447   1949             ; i++; 
3448   1949 FA FA FF      lea d, [bp + -6] ; $i
3449   194C 2A            mov b, [d]
3450   194D 38 00 00      mov c, 0
3451   1950 FD 77         inc b
3452   1952 FA FA FF      lea d, [bp + -6] ; $i
3453   1955 FD 43         mov [d], b
3454   1957 FD 7D         dec b
3455   1959 0A E7 18      jmp _while46_cond
3456   195C             _while46_exit:
3457   195C             ; while (i > 0) { 
3458   195C             _while47_cond:
3459   195C FA FA FF      lea d, [bp + -6] ; $i
3460   195F 2A            mov b, [d]
3461   1960 38 00 00      mov c, 0
3462   1963             ; --- START RELATIONAL
3463   1963 D7            push a
3464   1964 11            mov a, b
3465   1965 FD 2E 00 00   mov32 cb, $00000000
3465   1969 00 00 
3466   196B B0            cmp a, b
3467   196C FD 7F         sgt ; >
3468   196E E4            pop a
3469   196F             ; --- END RELATIONAL
3470   196F C0 00 00      cmp b, 0
3471   1972 C6 C1 19      je _while47_exit
3472   1975             _while47_block:
3473   1975             ; i--; 
3474   1975 FA FA FF      lea d, [bp + -6] ; $i
3475   1978 2A            mov b, [d]
3476   1979 38 00 00      mov c, 0
3477   197C FD 7D         dec b
3478   197E FA FA FF      lea d, [bp + -6] ; $i
3479   1981 FD 43         mov [d], b
3480   1983 FD 77         inc b
3481   1985             ; *dest++ = digits[i]; 
3482   1985 FA 05 00      lea d, [bp + 5] ; $dest
3483   1988 2A            mov b, [d]
3484   1989 38 00 00      mov c, 0
3485   198C FD 77         inc b
3486   198E FA 05 00      lea d, [bp + 5] ; $dest
3487   1991 FD 43         mov [d], b
3488   1993 FD 7D         dec b
3489   1995 D8            push b
3490   1996 FA FC FF      lea d, [bp + -4] ; $digits
3491   1999 D7            push a
3492   199A DA            push d
3493   199B FA FA FF      lea d, [bp + -6] ; $i
3494   199E 2A            mov b, [d]
3495   199F 38 00 00      mov c, 0
3496   19A2 E7            pop d
3497   19A3 5A            add d, b
3498   19A4 E4            pop a
3499   19A5 32            mov bl, [d]
3500   19A6 A7 00         mov bh, 0
3501   19A8 38 00 00      mov c, 0
3502   19AB E7            pop d
3503   19AC FD 3E         mov [d], bl
3504   19AE             ; len++; 
3505   19AE FA F8 FF      lea d, [bp + -8] ; $len
3506   19B1 2A            mov b, [d]
3507   19B2 38 00 00      mov c, 0
3508   19B5 FD 77         inc b
3509   19B7 FA F8 FF      lea d, [bp + -8] ; $len
3510   19BA FD 43         mov [d], b
3511   19BC FD 7D         dec b
3512   19BE 0A 5C 19      jmp _while47_cond
3513   19C1             _while47_exit:
3514   19C1             ; *dest = '\0'; 
3515   19C1 FA 05 00      lea d, [bp + 5] ; $dest
3516   19C4 2A            mov b, [d]
3517   19C5 38 00 00      mov c, 0
3518   19C8 D8            push b
3519   19C9 FD 2E 00 00   mov32 cb, $00000000
3519   19CD 00 00 
3520   19CF E7            pop d
3521   19D0 FD 3E         mov [d], bl
3522   19D2             ; return len; 
3523   19D2 FA F8 FF      lea d, [bp + -8] ; $len
3524   19D5 2A            mov b, [d]
3525   19D6 38 00 00      mov c, 0
3526   19D9 F9            leave
3527   19DA 09            ret
3528   19DB             
3529   19DB             print_unsigned:
3530   19DB F8 00 00      enter 0 ; (push bp; mov bp, sp)
3531   19DE             ; char digits[5]; 
3532   19DE 52 05 00      sub sp, 5
3533   19E1             ; int i; 
3534   19E1 52 02 00      sub sp, 2
3535   19E4             ; i = 0; 
3536   19E4 FA FA FF      lea d, [bp + -6] ; $i
3537   19E7 DA            push d
3538   19E8 FD 2E 00 00   mov32 cb, $00000000
3538   19EC 00 00 
3539   19EE E7            pop d
3540   19EF FD 43         mov [d], b
3541   19F1             ; if(num == 0){ 
3542   19F1             _if48_cond:
3543   19F1 FA 05 00      lea d, [bp + 5] ; $num
3544   19F4 2A            mov b, [d]
3545   19F5 38 00 00      mov c, 0
3546   19F8             ; --- START RELATIONAL
3547   19F8 D7            push a
3548   19F9 11            mov a, b
3549   19FA FD 2E 00 00   mov32 cb, $00000000
3549   19FE 00 00 
3550   1A00 B0            cmp a, b
3551   1A01 FD 71         seq ; ==
3552   1A03 E4            pop a
3553   1A04             ; --- END RELATIONAL
3554   1A04 C0 00 00      cmp b, 0
3555   1A07 C6 1C 1A      je _if48_exit
3556   1A0A             _if48_true:
3557   1A0A             ; putchar('0'); 
3558   1A0A             ; --- START FUNCTION CALL
3559   1A0A FD 2E 30 00   mov32 cb, $00000030
3559   1A0E 00 00 
3560   1A10 DD            push bl
3561   1A11 07 A3 1C      call putchar
3562   1A14 51 01 00      add sp, 1
3563   1A17             ; --- END FUNCTION CALL
3564   1A17             ; return; 
3565   1A17 F9            leave
3566   1A18 09            ret
3567   1A19 0A 1C 1A      jmp _if48_exit
3568   1A1C             _if48_exit:
3569   1A1C             ; while (num > 0) { 
3570   1A1C             _while49_cond:
3571   1A1C FA 05 00      lea d, [bp + 5] ; $num
3572   1A1F 2A            mov b, [d]
3573   1A20 38 00 00      mov c, 0
3574   1A23             ; --- START RELATIONAL
3575   1A23 D7            push a
3576   1A24 11            mov a, b
3577   1A25 FD 2E 00 00   mov32 cb, $00000000
3577   1A29 00 00 
3578   1A2B B0            cmp a, b
3579   1A2C FD 81         sgu ; > (unsigned)
3580   1A2E E4            pop a
3581   1A2F             ; --- END RELATIONAL
3582   1A2F C0 00 00      cmp b, 0
3583   1A32 C6 91 1A      je _while49_exit
3584   1A35             _while49_block:
3585   1A35             ; digits[i] = '0' + (num % 10); 
3586   1A35 FA FC FF      lea d, [bp + -4] ; $digits
3587   1A38 D7            push a
3588   1A39 DA            push d
3589   1A3A FA FA FF      lea d, [bp + -6] ; $i
3590   1A3D 2A            mov b, [d]
3591   1A3E 38 00 00      mov c, 0
3592   1A41 E7            pop d
3593   1A42 5A            add d, b
3594   1A43 E4            pop a
3595   1A44 DA            push d
3596   1A45 FD 2E 30 00   mov32 cb, $00000030
3596   1A49 00 00 
3597   1A4B             ; --- START TERMS
3598   1A4B D7            push a
3599   1A4C 11            mov a, b
3600   1A4D FA 05 00      lea d, [bp + 5] ; $num
3601   1A50 2A            mov b, [d]
3602   1A51 38 00 00      mov c, 0
3603   1A54             ; --- START FACTORS
3604   1A54 D7            push a
3605   1A55 11            mov a, b
3606   1A56 FD 2E 0A 00   mov32 cb, $0000000a
3606   1A5A 00 00 
3607   1A5C AE            div a, b ; 
3608   1A5D 11            mov a, b
3609   1A5E 27            mov b, a
3610   1A5F E4            pop a
3611   1A60             ; --- END FACTORS
3612   1A60 56            add b, a
3613   1A61 E4            pop a
3614   1A62             ; --- END TERMS
3615   1A62 E7            pop d
3616   1A63 FD 3E         mov [d], bl
3617   1A65             ; num = num / 10; 
3618   1A65 FA 05 00      lea d, [bp + 5] ; $num
3619   1A68 DA            push d
3620   1A69 FA 05 00      lea d, [bp + 5] ; $num
3621   1A6C 2A            mov b, [d]
3622   1A6D 38 00 00      mov c, 0
3623   1A70             ; --- START FACTORS
3624   1A70 D7            push a
3625   1A71 11            mov a, b
3626   1A72 FD 2E 0A 00   mov32 cb, $0000000a
3626   1A76 00 00 
3627   1A78 AE            div a, b
3628   1A79 27            mov b, a
3629   1A7A E4            pop a
3630   1A7B             ; --- END FACTORS
3631   1A7B E7            pop d
3632   1A7C FD 43         mov [d], b
3633   1A7E             ; i++; 
3634   1A7E FA FA FF      lea d, [bp + -6] ; $i
3635   1A81 2A            mov b, [d]
3636   1A82 38 00 00      mov c, 0
3637   1A85 FD 77         inc b
3638   1A87 FA FA FF      lea d, [bp + -6] ; $i
3639   1A8A FD 43         mov [d], b
3640   1A8C FD 7D         dec b
3641   1A8E 0A 1C 1A      jmp _while49_cond
3642   1A91             _while49_exit:
3643   1A91             ; while (i > 0) { 
3644   1A91             _while50_cond:
3645   1A91 FA FA FF      lea d, [bp + -6] ; $i
3646   1A94 2A            mov b, [d]
3647   1A95 38 00 00      mov c, 0
3648   1A98             ; --- START RELATIONAL
3649   1A98 D7            push a
3650   1A99 11            mov a, b
3651   1A9A FD 2E 00 00   mov32 cb, $00000000
3651   1A9E 00 00 
3652   1AA0 B0            cmp a, b
3653   1AA1 FD 7F         sgt ; >
3654   1AA3 E4            pop a
3655   1AA4             ; --- END RELATIONAL
3656   1AA4 C0 00 00      cmp b, 0
3657   1AA7 C6 D9 1A      je _while50_exit
3658   1AAA             _while50_block:
3659   1AAA             ; i--; 
3660   1AAA FA FA FF      lea d, [bp + -6] ; $i
3661   1AAD 2A            mov b, [d]
3662   1AAE 38 00 00      mov c, 0
3663   1AB1 FD 7D         dec b
3664   1AB3 FA FA FF      lea d, [bp + -6] ; $i
3665   1AB6 FD 43         mov [d], b
3666   1AB8 FD 77         inc b
3667   1ABA             ; putchar(digits[i]); 
3668   1ABA             ; --- START FUNCTION CALL
3669   1ABA FA FC FF      lea d, [bp + -4] ; $digits
3670   1ABD D7            push a
3671   1ABE DA            push d
3672   1ABF FA FA FF      lea d, [bp + -6] ; $i
3673   1AC2 2A            mov b, [d]
3674   1AC3 38 00 00      mov c, 0
3675   1AC6 E7            pop d
3676   1AC7 5A            add d, b
3677   1AC8 E4            pop a
3678   1AC9 32            mov bl, [d]
3679   1ACA A7 00         mov bh, 0
3680   1ACC 38 00 00      mov c, 0
3681   1ACF DD            push bl
3682   1AD0 07 A3 1C      call putchar
3683   1AD3 51 01 00      add sp, 1
3684   1AD6             ; --- END FUNCTION CALL
3685   1AD6 0A 91 1A      jmp _while50_cond
3686   1AD9             _while50_exit:
3687   1AD9 F9            leave
3688   1ADA 09            ret
3689   1ADB             
3690   1ADB             sprint_signed:
3691   1ADB F8 00 00      enter 0 ; (push bp; mov bp, sp)
3692   1ADE             ; char digits[5]; 
3693   1ADE 52 05 00      sub sp, 5
3694   1AE1             ; int i = 0; 
3695   1AE1 52 02 00      sub sp, 2
3696   1AE4             ; --- START LOCAL VAR INITIALIZATION
3697   1AE4 FA FA FF      lea d, [bp + -6] ; $i
3698   1AE7 DA            push d
3699   1AE8 FD 2E 00 00   mov32 cb, $00000000
3699   1AEC 00 00 
3700   1AEE E7            pop d
3701   1AEF FD 43         mov [d], b
3702   1AF1             ; --- END LOCAL VAR INITIALIZATION
3703   1AF1             ; int len = 0; 
3704   1AF1 52 02 00      sub sp, 2
3705   1AF4             ; --- START LOCAL VAR INITIALIZATION
3706   1AF4 FA F8 FF      lea d, [bp + -8] ; $len
3707   1AF7 DA            push d
3708   1AF8 FD 2E 00 00   mov32 cb, $00000000
3708   1AFC 00 00 
3709   1AFE E7            pop d
3710   1AFF FD 43         mov [d], b
3711   1B01             ; --- END LOCAL VAR INITIALIZATION
3712   1B01             ; if (num < 0) { 
3713   1B01             _if51_cond:
3714   1B01 FA 07 00      lea d, [bp + 7] ; $num
3715   1B04 2A            mov b, [d]
3716   1B05 38 00 00      mov c, 0
3717   1B08             ; --- START RELATIONAL
3718   1B08 D7            push a
3719   1B09 11            mov a, b
3720   1B0A FD 2E 00 00   mov32 cb, $00000000
3720   1B0E 00 00 
3721   1B10 B0            cmp a, b
3722   1B11 FD 73         slt ; < (signed)
3723   1B13 E4            pop a
3724   1B14             ; --- END RELATIONAL
3725   1B14 C0 00 00      cmp b, 0
3726   1B17 C6 57 1B      je _if51_else
3727   1B1A             _if51_true:
3728   1B1A             ; *dest++ = '-'; 
3729   1B1A FA 05 00      lea d, [bp + 5] ; $dest
3730   1B1D 2A            mov b, [d]
3731   1B1E 38 00 00      mov c, 0
3732   1B21 FD 77         inc b
3733   1B23 FA 05 00      lea d, [bp + 5] ; $dest
3734   1B26 FD 43         mov [d], b
3735   1B28 FD 7D         dec b
3736   1B2A D8            push b
3737   1B2B FD 2E 2D 00   mov32 cb, $0000002d
3737   1B2F 00 00 
3738   1B31 E7            pop d
3739   1B32 FD 3E         mov [d], bl
3740   1B34             ; num = -num; 
3741   1B34 FA 07 00      lea d, [bp + 7] ; $num
3742   1B37 DA            push d
3743   1B38 FA 07 00      lea d, [bp + 7] ; $num
3744   1B3B 2A            mov b, [d]
3745   1B3C 38 00 00      mov c, 0
3746   1B3F FD 97         neg b
3747   1B41 E7            pop d
3748   1B42 FD 43         mov [d], b
3749   1B44             ; len++; 
3750   1B44 FA F8 FF      lea d, [bp + -8] ; $len
3751   1B47 2A            mov b, [d]
3752   1B48 38 00 00      mov c, 0
3753   1B4B FD 77         inc b
3754   1B4D FA F8 FF      lea d, [bp + -8] ; $len
3755   1B50 FD 43         mov [d], b
3756   1B52 FD 7D         dec b
3757   1B54 0A A6 1B      jmp _if51_exit
3758   1B57             _if51_else:
3759   1B57             ; if (num == 0) { 
3760   1B57             _if52_cond:
3761   1B57 FA 07 00      lea d, [bp + 7] ; $num
3762   1B5A 2A            mov b, [d]
3763   1B5B 38 00 00      mov c, 0
3764   1B5E             ; --- START RELATIONAL
3765   1B5E D7            push a
3766   1B5F 11            mov a, b
3767   1B60 FD 2E 00 00   mov32 cb, $00000000
3767   1B64 00 00 
3768   1B66 B0            cmp a, b
3769   1B67 FD 71         seq ; ==
3770   1B69 E4            pop a
3771   1B6A             ; --- END RELATIONAL
3772   1B6A C0 00 00      cmp b, 0
3773   1B6D C6 A6 1B      je _if52_exit
3774   1B70             _if52_true:
3775   1B70             ; *dest++ = '0'; 
3776   1B70 FA 05 00      lea d, [bp + 5] ; $dest
3777   1B73 2A            mov b, [d]
3778   1B74 38 00 00      mov c, 0
3779   1B77 FD 77         inc b
3780   1B79 FA 05 00      lea d, [bp + 5] ; $dest
3781   1B7C FD 43         mov [d], b
3782   1B7E FD 7D         dec b
3783   1B80 D8            push b
3784   1B81 FD 2E 30 00   mov32 cb, $00000030
3784   1B85 00 00 
3785   1B87 E7            pop d
3786   1B88 FD 3E         mov [d], bl
3787   1B8A             ; *dest = '\0'; 
3788   1B8A FA 05 00      lea d, [bp + 5] ; $dest
3789   1B8D 2A            mov b, [d]
3790   1B8E 38 00 00      mov c, 0
3791   1B91 D8            push b
3792   1B92 FD 2E 00 00   mov32 cb, $00000000
3792   1B96 00 00 
3793   1B98 E7            pop d
3794   1B99 FD 3E         mov [d], bl
3795   1B9B             ; return 1; 
3796   1B9B FD 2E 01 00   mov32 cb, $00000001
3796   1B9F 00 00 
3797   1BA1 F9            leave
3798   1BA2 09            ret
3799   1BA3 0A A6 1B      jmp _if52_exit
3800   1BA6             _if52_exit:
3801   1BA6             _if51_exit:
3802   1BA6             ; while (num > 0) { 
3803   1BA6             _while53_cond:
3804   1BA6 FA 07 00      lea d, [bp + 7] ; $num
3805   1BA9 2A            mov b, [d]
3806   1BAA 38 00 00      mov c, 0
3807   1BAD             ; --- START RELATIONAL
3808   1BAD D7            push a
3809   1BAE 11            mov a, b
3810   1BAF FD 2E 00 00   mov32 cb, $00000000
3810   1BB3 00 00 
3811   1BB5 B0            cmp a, b
3812   1BB6 FD 7F         sgt ; >
3813   1BB8 E4            pop a
3814   1BB9             ; --- END RELATIONAL
3815   1BB9 C0 00 00      cmp b, 0
3816   1BBC C6 1B 1C      je _while53_exit
3817   1BBF             _while53_block:
3818   1BBF             ; digits[i] = '0' + (num % 10); 
3819   1BBF FA FC FF      lea d, [bp + -4] ; $digits
3820   1BC2 D7            push a
3821   1BC3 DA            push d
3822   1BC4 FA FA FF      lea d, [bp + -6] ; $i
3823   1BC7 2A            mov b, [d]
3824   1BC8 38 00 00      mov c, 0
3825   1BCB E7            pop d
3826   1BCC 5A            add d, b
3827   1BCD E4            pop a
3828   1BCE DA            push d
3829   1BCF FD 2E 30 00   mov32 cb, $00000030
3829   1BD3 00 00 
3830   1BD5             ; --- START TERMS
3831   1BD5 D7            push a
3832   1BD6 11            mov a, b
3833   1BD7 FA 07 00      lea d, [bp + 7] ; $num
3834   1BDA 2A            mov b, [d]
3835   1BDB 38 00 00      mov c, 0
3836   1BDE             ; --- START FACTORS
3837   1BDE D7            push a
3838   1BDF 11            mov a, b
3839   1BE0 FD 2E 0A 00   mov32 cb, $0000000a
3839   1BE4 00 00 
3840   1BE6 AE            div a, b ; 
3841   1BE7 11            mov a, b
3842   1BE8 27            mov b, a
3843   1BE9 E4            pop a
3844   1BEA             ; --- END FACTORS
3845   1BEA 56            add b, a
3846   1BEB E4            pop a
3847   1BEC             ; --- END TERMS
3848   1BEC E7            pop d
3849   1BED FD 3E         mov [d], bl
3850   1BEF             ; num = num / 10; 
3851   1BEF FA 07 00      lea d, [bp + 7] ; $num
3852   1BF2 DA            push d
3853   1BF3 FA 07 00      lea d, [bp + 7] ; $num
3854   1BF6 2A            mov b, [d]
3855   1BF7 38 00 00      mov c, 0
3856   1BFA             ; --- START FACTORS
3857   1BFA D7            push a
3858   1BFB 11            mov a, b
3859   1BFC FD 2E 0A 00   mov32 cb, $0000000a
3859   1C00 00 00 
3860   1C02 AE            div a, b
3861   1C03 27            mov b, a
3862   1C04 E4            pop a
3863   1C05             ; --- END FACTORS
3864   1C05 E7            pop d
3865   1C06 FD 43         mov [d], b
3866   1C08             ; i++; 
3867   1C08 FA FA FF      lea d, [bp + -6] ; $i
3868   1C0B 2A            mov b, [d]
3869   1C0C 38 00 00      mov c, 0
3870   1C0F FD 77         inc b
3871   1C11 FA FA FF      lea d, [bp + -6] ; $i
3872   1C14 FD 43         mov [d], b
3873   1C16 FD 7D         dec b
3874   1C18 0A A6 1B      jmp _while53_cond
3875   1C1B             _while53_exit:
3876   1C1B             ; while (i > 0) { 
3877   1C1B             _while54_cond:
3878   1C1B FA FA FF      lea d, [bp + -6] ; $i
3879   1C1E 2A            mov b, [d]
3880   1C1F 38 00 00      mov c, 0
3881   1C22             ; --- START RELATIONAL
3882   1C22 D7            push a
3883   1C23 11            mov a, b
3884   1C24 FD 2E 00 00   mov32 cb, $00000000
3884   1C28 00 00 
3885   1C2A B0            cmp a, b
3886   1C2B FD 7F         sgt ; >
3887   1C2D E4            pop a
3888   1C2E             ; --- END RELATIONAL
3889   1C2E C0 00 00      cmp b, 0
3890   1C31 C6 80 1C      je _while54_exit
3891   1C34             _while54_block:
3892   1C34             ; i--; 
3893   1C34 FA FA FF      lea d, [bp + -6] ; $i
3894   1C37 2A            mov b, [d]
3895   1C38 38 00 00      mov c, 0
3896   1C3B FD 7D         dec b
3897   1C3D FA FA FF      lea d, [bp + -6] ; $i
3898   1C40 FD 43         mov [d], b
3899   1C42 FD 77         inc b
3900   1C44             ; *dest++ = digits[i]; 
3901   1C44 FA 05 00      lea d, [bp + 5] ; $dest
3902   1C47 2A            mov b, [d]
3903   1C48 38 00 00      mov c, 0
3904   1C4B FD 77         inc b
3905   1C4D FA 05 00      lea d, [bp + 5] ; $dest
3906   1C50 FD 43         mov [d], b
3907   1C52 FD 7D         dec b
3908   1C54 D8            push b
3909   1C55 FA FC FF      lea d, [bp + -4] ; $digits
3910   1C58 D7            push a
3911   1C59 DA            push d
3912   1C5A FA FA FF      lea d, [bp + -6] ; $i
3913   1C5D 2A            mov b, [d]
3914   1C5E 38 00 00      mov c, 0
3915   1C61 E7            pop d
3916   1C62 5A            add d, b
3917   1C63 E4            pop a
3918   1C64 32            mov bl, [d]
3919   1C65 A7 00         mov bh, 0
3920   1C67 38 00 00      mov c, 0
3921   1C6A E7            pop d
3922   1C6B FD 3E         mov [d], bl
3923   1C6D             ; len++; 
3924   1C6D FA F8 FF      lea d, [bp + -8] ; $len
3925   1C70 2A            mov b, [d]
3926   1C71 38 00 00      mov c, 0
3927   1C74 FD 77         inc b
3928   1C76 FA F8 FF      lea d, [bp + -8] ; $len
3929   1C79 FD 43         mov [d], b
3930   1C7B FD 7D         dec b
3931   1C7D 0A 1B 1C      jmp _while54_cond
3932   1C80             _while54_exit:
3933   1C80             ; *dest = '\0'; 
3934   1C80 FA 05 00      lea d, [bp + 5] ; $dest
3935   1C83 2A            mov b, [d]
3936   1C84 38 00 00      mov c, 0
3937   1C87 D8            push b
3938   1C88 FD 2E 00 00   mov32 cb, $00000000
3938   1C8C 00 00 
3939   1C8E E7            pop d
3940   1C8F FD 3E         mov [d], bl
3941   1C91             ; return len; 
3942   1C91 FA F8 FF      lea d, [bp + -8] ; $len
3943   1C94 2A            mov b, [d]
3944   1C95 38 00 00      mov c, 0
3945   1C98 F9            leave
3946   1C99 09            ret
3947   1C9A             
3948   1C9A             date:
3949   1C9A F8 00 00      enter 0 ; (push bp; mov bp, sp)
3950   1C9D             
3951   1C9D             ; --- BEGIN INLINE ASM SEGMENT
3952   1C9D 19 00         mov al, 0 
3953   1C9F 05 07         syscall sys_datetime
3954   1CA1             ; --- END INLINE ASM SEGMENT
3955   1CA1             
3956   1CA1 F9            leave
3957   1CA2 09            ret
3958   1CA3             
3959   1CA3             putchar:
3960   1CA3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3961   1CA6             
3962   1CA6             ; --- BEGIN INLINE ASM SEGMENT
3963   1CA6 FA 05 00      lea d, [bp + 5] ; $c
3964   1CA9 1E            mov al, [d]
3965   1CAA 23            mov ah, al
3966   1CAB 07 B2 1E      call _putchar
3967   1CAE             ; --- END INLINE ASM SEGMENT
3968   1CAE             
3969   1CAE F9            leave
3970   1CAF 09            ret
3971   1CB0             
3972   1CB0             getchar:
3973   1CB0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3974   1CB3             ; char c; 
3975   1CB3 52 01 00      sub sp, 1
3976   1CB6             
3977   1CB6             ; --- BEGIN INLINE ASM SEGMENT
3978   1CB6 07 AB 1E      call getch
3979   1CB9 1A            mov al, ah
3980   1CBA FA 00 00      lea d, [bp + 0] ; $c
3981   1CBD 3E            mov [d], al
3982   1CBE             ; --- END INLINE ASM SEGMENT
3983   1CBE             
3984   1CBE             ; return c; 
3985   1CBE FA 00 00      lea d, [bp + 0] ; $c
3986   1CC1 32            mov bl, [d]
3987   1CC2 A7 00         mov bh, 0
3988   1CC4 38 00 00      mov c, 0
3989   1CC7 F9            leave
3990   1CC8 09            ret
3991   1CC9             
3992   1CC9             scann:
3993   1CC9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3994   1CCC             ; int m; 
3995   1CCC 52 02 00      sub sp, 2
3996   1CCF             
3997   1CCF             ; --- BEGIN INLINE ASM SEGMENT
3998   1CCF 07 F6 20      call scan_u16d
3999   1CD2 FA FF FF      lea d, [bp + -1] ; $m
4000   1CD5 43            mov [d], a
4001   1CD6             ; --- END INLINE ASM SEGMENT
4002   1CD6             
4003   1CD6             ; return m; 
4004   1CD6 FA FF FF      lea d, [bp + -1] ; $m
4005   1CD9 2A            mov b, [d]
4006   1CDA 38 00 00      mov c, 0
4007   1CDD F9            leave
4008   1CDE 09            ret
4009   1CDF             
4010   1CDF             puts:
4011   1CDF F8 00 00      enter 0 ; (push bp; mov bp, sp)
4012   1CE2             
4013   1CE2             ; --- BEGIN INLINE ASM SEGMENT
4014   1CE2 FA 05 00      lea d, [bp + 5] ; $s
4015   1CE5 15            mov a, [d]
4016   1CE6 3C            mov d, a
4017   1CE7 07 FC 1F      call _puts
4018   1CEA 10 00 0A      mov a, $0A00
4019   1CED 05 03         syscall sys_io
4020   1CEF             ; --- END INLINE ASM SEGMENT
4021   1CEF             
4022   1CEF F9            leave
4023   1CF0 09            ret
4024   1CF1             
4025   1CF1             print:
4026   1CF1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4027   1CF4             
4028   1CF4             ; --- BEGIN INLINE ASM SEGMENT
4029   1CF4 FA 05 00      lea d, [bp + 5] ; $s
4030   1CF7 FD 2A         mov d, [d]
4031   1CF9 07 FC 1F      call _puts
4032   1CFC             ; --- END INLINE ASM SEGMENT
4033   1CFC             
4034   1CFC F9            leave
4035   1CFD 09            ret
4036   1CFE             
4037   1CFE             getparam:
4038   1CFE F8 00 00      enter 0 ; (push bp; mov bp, sp)
4039   1D01             ; char data; 
4040   1D01 52 01 00      sub sp, 1
4041   1D04             
4042   1D04             ; --- BEGIN INLINE ASM SEGMENT
4043   1D04 19 04         mov al, 4
4044   1D06 FA 05 00      lea d, [bp + 5] ; $address
4045   1D09 FD 2A         mov d, [d]
4046   1D0B 05 0C         syscall sys_system
4047   1D0D FA 00 00      lea d, [bp + 0] ; $data
4048   1D10 FD 3E         mov [d], bl
4049   1D12             ; --- END INLINE ASM SEGMENT
4050   1D12             
4051   1D12             ; return data; 
4052   1D12 FA 00 00      lea d, [bp + 0] ; $data
4053   1D15 32            mov bl, [d]
4054   1D16 A7 00         mov bh, 0
4055   1D18 38 00 00      mov c, 0
4056   1D1B F9            leave
4057   1D1C 09            ret
4058   1D1D             
4059   1D1D             clear:
4060   1D1D F8 00 00      enter 0 ; (push bp; mov bp, sp)
4061   1D20             ; print("\033[2J\033[H"); 
4062   1D20             ; --- START FUNCTION CALL
4063   1D20 26 96 21      mov b, _s2 ; "\033[2J\033[H"
4064   1D23 FD AB         swp b
4065   1D25 D8            push b
4066   1D26 07 F1 1C      call print
4067   1D29 51 02 00      add sp, 2
4068   1D2C             ; --- END FUNCTION CALL
4069   1D2C F9            leave
4070   1D2D 09            ret
4071   1D2E             
4072   1D2E             abs:
4073   1D2E F8 00 00      enter 0 ; (push bp; mov bp, sp)
4074   1D31             ; return i < 0 ? -i : i; 
4075   1D31             _ternary55_cond:
4076   1D31 FA 05 00      lea d, [bp + 5] ; $i
4077   1D34 2A            mov b, [d]
4078   1D35 38 00 00      mov c, 0
4079   1D38             ; --- START RELATIONAL
4080   1D38 D7            push a
4081   1D39 11            mov a, b
4082   1D3A FD 2E 00 00   mov32 cb, $00000000
4082   1D3E 00 00 
4083   1D40 B0            cmp a, b
4084   1D41 FD 73         slt ; < (signed)
4085   1D43 E4            pop a
4086   1D44             ; --- END RELATIONAL
4087   1D44 C0 00 00      cmp b, 0
4088   1D47 C6 56 1D      je _ternary55_false
4089   1D4A             _ternary55_true:
4090   1D4A FA 05 00      lea d, [bp + 5] ; $i
4091   1D4D 2A            mov b, [d]
4092   1D4E 38 00 00      mov c, 0
4093   1D51 FD 97         neg b
4094   1D53 0A 5D 1D      jmp _ternary55_exit
4095   1D56             _ternary55_false:
4096   1D56 FA 05 00      lea d, [bp + 5] ; $i
4097   1D59 2A            mov b, [d]
4098   1D5A 38 00 00      mov c, 0
4099   1D5D             _ternary55_exit:
4100   1D5D F9            leave
4101   1D5E 09            ret
4102   1D5F             
4103   1D5F             loadfile:
4104   1D5F F8 00 00      enter 0 ; (push bp; mov bp, sp)
4105   1D62             
4106   1D62             ; --- BEGIN INLINE ASM SEGMENT
4107   1D62 FA 07 00      lea d, [bp + 7] ; $destination
4108   1D65 15            mov a, [d]
4109   1D66 4F            mov di, a
4110   1D67 FA 05 00      lea d, [bp + 5] ; $filename
4111   1D6A FD 2A         mov d, [d]
4112   1D6C 19 14         mov al, 20
4113   1D6E 05 04         syscall sys_filesystem
4114   1D70             ; --- END INLINE ASM SEGMENT
4115   1D70             
4116   1D70 F9            leave
4117   1D71 09            ret
4118   1D72             
4119   1D72             create_file:
4120   1D72 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4121   1D75 F9            leave
4122   1D76 09            ret
4123   1D77             
4124   1D77             delete_file:
4125   1D77 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4126   1D7A             
4127   1D7A             ; --- BEGIN INLINE ASM SEGMENT
4128   1D7A FA 05 00      lea d, [bp + 5] ; $filename
4129   1D7D 19 0A         mov al, 10
4130   1D7F 05 04         syscall sys_filesystem
4131   1D81             ; --- END INLINE ASM SEGMENT
4132   1D81             
4133   1D81 F9            leave
4134   1D82 09            ret
4135   1D83             
4136   1D83             load_hex:
4137   1D83 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4138   1D86             ; char *temp; 
4139   1D86 52 02 00      sub sp, 2
4140   1D89             ; temp = alloc(32768); 
4141   1D89 FA FF FF      lea d, [bp + -1] ; $temp
4142   1D8C DA            push d
4143   1D8D             ; --- START FUNCTION CALL
4144   1D8D FD 2E 00 80   mov32 cb, $00008000
4144   1D91 00 00 
4145   1D93 FD AB         swp b
4146   1D95 D8            push b
4147   1D96 07 62 08      call alloc
4148   1D99 51 02 00      add sp, 2
4149   1D9C             ; --- END FUNCTION CALL
4150   1D9C E7            pop d
4151   1D9D FD 43         mov [d], b
4152   1D9F             
4153   1D9F             ; --- BEGIN INLINE ASM SEGMENT
4154   1D9F               
4155   1D9F               
4156   1D9F               
4157   1D9F             _load_hex:
4158   1D9F FA 05 00      lea d, [bp + 5] ; $destination
4159   1DA2 FD 2A         mov d, [d]
4160   1DA4 FD 50         mov di, d
4161   1DA6 FA FF FF      lea d, [bp + -1] ; $temp
4162   1DA9 FD 2A         mov d, [d]
4163   1DAB 38 00 00      mov c, 0
4164   1DAE 48            mov a, sp
4165   1DAF 77            inc a
4166   1DB0 3C            mov d, a          
4167   1DB1 07 B9 1E      call _gets        
4168   1DB4 4D            mov si, a
4169   1DB5             __load_hex_loop:
4170   1DB5 F6            lodsb             
4171   1DB6 B9 00         cmp al, 0         
4172   1DB8 C6 C6 1D      jz __load_hex_ret
4173   1DBB 36            mov bh, al
4174   1DBC F6            lodsb
4175   1DBD 2F            mov bl, al
4176   1DBE 07 70 1E      call _atoi        
4177   1DC1 F7            stosb             
4178   1DC2 78            inc c
4179   1DC3 0A B5 1D      jmp __load_hex_loop
4180   1DC6             __load_hex_ret:
4181   1DC6             ; --- END INLINE ASM SEGMENT
4182   1DC6             
4183   1DC6 F9            leave
4184   1DC7 09            ret
4185   1DC8             
4186   1DC8             include_stdio_asm:
4187   1DC8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4188   1DCB             
4189   1DCB             ; --- BEGIN INLINE ASM SEGMENT
4190   1DCB             .include "lib/asm/stdio.asm"
0001+  1DCB             ;-----------------------------------------------------------------------------
0002+  1DCB             ; stdio.s
0003+  1DCB             ;-----------------------------------------------------------------------------
0004+  1DCB             .include "lib/asm/string.asm"
0001++ 1DCB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1DCB             ; string.s
0003++ 1DCB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1DCB             
0005++ 1DCB             
0006++ 1DCB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1DCB             ; _strrev
0008++ 1DCB             ; reverse a string
0009++ 1DCB             ; D = string address
0010++ 1DCB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1DCB             ; 01234
0012++ 1DCB             _strrev:
0013++ 1DCB 4B          	pusha
0014++ 1DCC 07 12 1E    	call _strlen	; length in C
0015++ 1DCF 12          	mov a, c
0016++ 1DD0 AF 01 00    	cmp a, 1
0017++ 1DD3 D0 ED 1D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1DD6 7D          	dec a
0019++ 1DD7 FD 4E       	mov si, d	; beginning of string
0020++ 1DD9 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1DDB 59          	add d, a	; end of string
0022++ 1DDC 12          	mov a, c
0023++ 1DDD FD 9B       	shr a		; divide by 2
0024++ 1DDF 39          	mov c, a	; C now counts the steps
0025++ 1DE0             _strrev_L0:
0026++ 1DE0 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1DE1 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1DE2 3E          	mov [d], al	; store left char into right side
0029++ 1DE3 1B          	mov al, bl
0030++ 1DE4 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1DE5 7E          	dec c
0032++ 1DE6 7F          	dec d
0033++ 1DE7 C2 00 00    	cmp c, 0
0034++ 1DEA C7 E0 1D    	jne _strrev_L0
0035++ 1DED             _strrev_end:
0036++ 1DED 4C          	popa
0037++ 1DEE 09          	ret
0038++ 1DEF             	
0039++ 1DEF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1DEF             ; _strchr
0041++ 1DEF             ; search string in D for char in AL
0042++ 1DEF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1DEF             _strchr:
0044++ 1DEF             _strchr_L0:
0045++ 1DEF 32          	mov bl, [d]
0046++ 1DF0 C1 00       	cmp bl, 0
0047++ 1DF2 C6 FD 1D    	je _strchr_end
0048++ 1DF5 BA          	cmp al, bl
0049++ 1DF6 C6 FD 1D    	je _strchr_end
0050++ 1DF9 79          	inc d
0051++ 1DFA 0A EF 1D    	jmp _strchr_L0
0052++ 1DFD             _strchr_end:
0053++ 1DFD 1B          	mov al, bl
0054++ 1DFE 09          	ret
0055++ 1DFF             
0056++ 1DFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1DFF             ; _strstr
0058++ 1DFF             ; find sub-string
0059++ 1DFF             ; str1 in SI
0060++ 1DFF             ; str2 in DI
0061++ 1DFF             ; SI points to end of source string
0062++ 1DFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1DFF             _strstr:
0064++ 1DFF DB          	push al
0065++ 1E00 DA          	push d
0066++ 1E01 E3          	push di
0067++ 1E02             _strstr_loop:
0068++ 1E02 F3          	cmpsb					; compare a byte of the strings
0069++ 1E03 C7 0E 1E    	jne _strstr_ret
0070++ 1E06 FC 00 00    	lea d, [di + 0]
0071++ 1E09 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1E0B C7 02 1E    	jne _strstr_loop				; equal chars but not at end
0073++ 1E0E             _strstr_ret:
0074++ 1E0E F0          	pop di
0075++ 1E0F E7          	pop d
0076++ 1E10 E8          	pop al
0077++ 1E11 09          	ret
0078++ 1E12             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1E12             ; length of null terminated string
0080++ 1E12             ; result in C
0081++ 1E12             ; pointer in D
0082++ 1E12             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1E12             _strlen:
0084++ 1E12 DA          	push d
0085++ 1E13 38 00 00    	mov c, 0
0086++ 1E16             _strlen_L1:
0087++ 1E16 BD 00       	cmp byte [d], 0
0088++ 1E18 C6 20 1E    	je _strlen_ret
0089++ 1E1B 79          	inc d
0090++ 1E1C 78          	inc c
0091++ 1E1D 0A 16 1E    	jmp _strlen_L1
0092++ 1E20             _strlen_ret:
0093++ 1E20 E7          	pop d
0094++ 1E21 09          	ret
0095++ 1E22             
0096++ 1E22             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1E22             ; STRCMP
0098++ 1E22             ; compare two strings
0099++ 1E22             ; str1 in SI
0100++ 1E22             ; str2 in DI
0101++ 1E22             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1E22             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1E22             _strcmp:
0104++ 1E22 DB          	push al
0105++ 1E23 DA          	push d
0106++ 1E24 E3          	push di
0107++ 1E25 E2          	push si
0108++ 1E26             _strcmp_loop:
0109++ 1E26 F3          	cmpsb					; compare a byte of the strings
0110++ 1E27 C7 32 1E    	jne _strcmp_ret
0111++ 1E2A FB FF FF    	lea d, [si +- 1]
0112++ 1E2D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1E2F C7 26 1E    	jne _strcmp_loop				; equal chars but not at end
0114++ 1E32             _strcmp_ret:
0115++ 1E32 EF          	pop si
0116++ 1E33 F0          	pop di
0117++ 1E34 E7          	pop d
0118++ 1E35 E8          	pop al
0119++ 1E36 09          	ret
0120++ 1E37             
0121++ 1E37             
0122++ 1E37             ; STRCPY
0123++ 1E37             ; copy null terminated string from SI to DI
0124++ 1E37             ; source in SI
0125++ 1E37             ; destination in DI
0126++ 1E37             _strcpy:
0127++ 1E37 E2          	push si
0128++ 1E38 E3          	push di
0129++ 1E39 DB          	push al
0130++ 1E3A             _strcpy_L1:
0131++ 1E3A F6          	lodsb
0132++ 1E3B F7          	stosb
0133++ 1E3C B9 00       	cmp al, 0
0134++ 1E3E C7 3A 1E    	jne _strcpy_L1
0135++ 1E41             _strcpy_end:
0136++ 1E41 E8          	pop al
0137++ 1E42 F0          	pop di
0138++ 1E43 EF          	pop si
0139++ 1E44 09          	ret
0140++ 1E45             
0141++ 1E45             ; STRCAT
0142++ 1E45             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1E45             ; source in SI
0144++ 1E45             ; destination in DI
0145++ 1E45             _strcat:
0146++ 1E45 E2          	push si
0147++ 1E46 E3          	push di
0148++ 1E47 D7          	push a
0149++ 1E48 DA          	push d
0150++ 1E49 50          	mov a, di
0151++ 1E4A 3C          	mov d, a
0152++ 1E4B             _strcat_goto_end_L1:
0153++ 1E4B BD 00       	cmp byte[d], 0
0154++ 1E4D C6 54 1E    	je _strcat_start
0155++ 1E50 79          	inc d
0156++ 1E51 0A 4B 1E    	jmp _strcat_goto_end_L1
0157++ 1E54             _strcat_start:
0158++ 1E54 FD 50       	mov di, d
0159++ 1E56             _strcat_L1:
0160++ 1E56 F6          	lodsb
0161++ 1E57 F7          	stosb
0162++ 1E58 B9 00       	cmp al, 0
0163++ 1E5A C7 56 1E    	jne _strcat_L1
0164++ 1E5D             _strcat_end:
0165++ 1E5D E7          	pop d
0166++ 1E5E E4          	pop a
0167++ 1E5F F0          	pop di
0168++ 1E60 EF          	pop si
0169++ 1E61 09          	ret
0170++ 1E62             
0171++ 1E62             
0005+  1E62             
0006+  1E62             ;-----------------------------------------------------------------------------
0007+  1E62             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1E62             ; ASCII in BL
0009+  1E62             ; result in AL
0010+  1E62             ; ascii for F = 0100 0110
0011+  1E62             ; ascii for 9 = 0011 1001
0012+  1E62             ;-----------------------------------------------------------------------------
0013+  1E62             hex_ascii_encode:
0014+  1E62 1B            mov al, bl
0015+  1E63 93 40         test al, $40        ; test if letter or number
0016+  1E65 C7 6B 1E      jnz hex_letter
0017+  1E68 87 0F         and al, $0F        ; get number
0018+  1E6A 09            ret
0019+  1E6B             hex_letter:
0020+  1E6B 87 0F         and al, $0F        ; get letter
0021+  1E6D 6A 09         add al, 9
0022+  1E6F 09            ret
0023+  1E70             
0024+  1E70             ;-----------------------------------------------------------------------------
0025+  1E70             ; ATOI
0026+  1E70             ; 2 letter hex string in B
0027+  1E70             ; 8bit integer returned in AL
0028+  1E70             ;-----------------------------------------------------------------------------
0029+  1E70             _atoi:
0030+  1E70 D8            push b
0031+  1E71 07 62 1E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1E74 30            mov bl, bh
0033+  1E75 DB            push al          ; save a
0034+  1E76 07 62 1E      call hex_ascii_encode
0035+  1E79 EA            pop bl  
0036+  1E7A FD 9E 04      shl al, 4
0037+  1E7D 8C            or al, bl
0038+  1E7E E5            pop b
0039+  1E7F 09            ret  
0040+  1E80             
0041+  1E80             
0042+  1E80             ;-----------------------------------------------------------------------------
0043+  1E80             ; ITOA
0044+  1E80             ; 8bit value in BL
0045+  1E80             ; 2 byte ASCII result in A
0046+  1E80             ;-----------------------------------------------------------------------------
0047+  1E80             _itoa:
0048+  1E80 DA            push d
0049+  1E81 D8            push b
0050+  1E82 A7 00         mov bh, 0
0051+  1E84 FD A4 04      shr bl, 4  
0052+  1E87 74            mov d, b
0053+  1E88 1F 30 21      mov al, [d + s_hex_digits]
0054+  1E8B 23            mov ah, al
0055+  1E8C               
0056+  1E8C E5            pop b
0057+  1E8D D8            push b
0058+  1E8E A7 00         mov bh, 0
0059+  1E90 FD 87 0F      and bl, $0F
0060+  1E93 74            mov d, b
0061+  1E94 1F 30 21      mov al, [d + s_hex_digits]
0062+  1E97 E5            pop b
0063+  1E98 E7            pop d
0064+  1E99 09            ret
0065+  1E9A             
0066+  1E9A             ;-----------------------------------------------------------------------------
0067+  1E9A             ; HEX STRING TO BINARY
0068+  1E9A             ; di = destination address
0069+  1E9A             ; si = source
0070+  1E9A             ;-----------------------------------------------------------------------------
0071+  1E9A             _hex_to_int:
0072+  1E9A             _hex_to_int_L1:
0073+  1E9A F6            lodsb          ; load from [SI] to AL
0074+  1E9B B9 00         cmp al, 0        ; check if ASCII 0
0075+  1E9D C6 AA 1E      jz _hex_to_int_ret
0076+  1EA0 36            mov bh, al
0077+  1EA1 F6            lodsb
0078+  1EA2 2F            mov bl, al
0079+  1EA3 07 70 1E      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1EA6 F7            stosb          ; store AL to [DI]
0081+  1EA7 0A 9A 1E      jmp _hex_to_int_L1
0082+  1EAA             _hex_to_int_ret:
0083+  1EAA 09            ret    
0084+  1EAB             
0085+  1EAB             ;-----------------------------------------------------------------------------
0086+  1EAB             ; GETCHAR
0087+  1EAB             ; char in ah
0088+  1EAB             ;-----------------------------------------------------------------------------
0089+  1EAB             getch:
0090+  1EAB DB            push al
0091+  1EAC             getch_retry:
0092+  1EAC 19 01         mov al, 1
0093+  1EAE 05 03         syscall sys_io      ; receive in AH
0094+  1EB0 E8            pop al
0095+  1EB1 09            ret
0096+  1EB2             
0097+  1EB2             ;-----------------------------------------------------------------------------
0098+  1EB2             ; PUTCHAR
0099+  1EB2             ; char in ah
0100+  1EB2             ;-----------------------------------------------------------------------------
0101+  1EB2             _putchar:
0102+  1EB2 D7            push a
0103+  1EB3 19 00         mov al, 0
0104+  1EB5 05 03         syscall sys_io      ; char in AH
0105+  1EB7 E4            pop a
0106+  1EB8 09            ret
0107+  1EB9             
0108+  1EB9             ;-----------------------------------------------------------------------------
0109+  1EB9             ;; INPUT A STRING
0110+  1EB9             ;; terminates with null
0111+  1EB9             ;; pointer in D
0112+  1EB9             ;-----------------------------------------------------------------------------
0113+  1EB9             _gets:
0114+  1EB9 D7            push a
0115+  1EBA DA            push d
0116+  1EBB             _gets_loop:
0117+  1EBB 19 01         mov al, 1
0118+  1EBD 05 03         syscall sys_io      ; receive in AH
0119+  1EBF B9 00         cmp al, 0        ; check error code (AL)
0120+  1EC1 C6 BB 1E      je _gets_loop      ; if no char received, retry
0121+  1EC4             
0122+  1EC4 76 1B         cmp ah, 27
0123+  1EC6 C6 E7 1E      je _gets_ansi_esc
0124+  1EC9 76 0A         cmp ah, $0A        ; LF
0125+  1ECB C6 52 1F      je _gets_end
0126+  1ECE 76 0D         cmp ah, $0D        ; CR
0127+  1ED0 C6 52 1F      je _gets_end
0128+  1ED3 76 5C         cmp ah, $5C        ; '\\'
0129+  1ED5 C6 13 1F      je _gets_escape
0130+  1ED8               
0131+  1ED8 76 08         cmp ah, $08      ; check for backspace
0132+  1EDA C6 E3 1E      je _gets_backspace
0133+  1EDD             
0134+  1EDD 1A            mov al, ah
0135+  1EDE 3E            mov [d], al
0136+  1EDF 79            inc d
0137+  1EE0 0A BB 1E      jmp _gets_loop
0138+  1EE3             _gets_backspace:
0139+  1EE3 7F            dec d
0140+  1EE4 0A BB 1E      jmp _gets_loop
0141+  1EE7             _gets_ansi_esc:
0142+  1EE7 19 01         mov al, 1
0143+  1EE9 05 03         syscall sys_io        ; receive in AH without echo
0144+  1EEB B9 00         cmp al, 0          ; check error code (AL)
0145+  1EED C6 E7 1E      je _gets_ansi_esc    ; if no char received, retry
0146+  1EF0 76 5B         cmp ah, '['
0147+  1EF2 C7 BB 1E      jne _gets_loop
0148+  1EF5             _gets_ansi_esc_2:
0149+  1EF5 19 01         mov al, 1
0150+  1EF7 05 03         syscall sys_io          ; receive in AH without echo
0151+  1EF9 B9 00         cmp al, 0            ; check error code (AL)
0152+  1EFB C6 F5 1E      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1EFE 76 44         cmp ah, 'D'
0154+  1F00 C6 0B 1F      je _gets_left_arrow
0155+  1F03 76 43         cmp ah, 'C'
0156+  1F05 C6 0F 1F      je _gets_right_arrow
0157+  1F08 0A BB 1E      jmp _gets_loop
0158+  1F0B             _gets_left_arrow:
0159+  1F0B 7F            dec d
0160+  1F0C 0A BB 1E      jmp _gets_loop
0161+  1F0F             _gets_right_arrow:
0162+  1F0F 79            inc d
0163+  1F10 0A BB 1E      jmp _gets_loop
0164+  1F13             _gets_escape:
0165+  1F13 19 01         mov al, 1
0166+  1F15 05 03         syscall sys_io      ; receive in AH
0167+  1F17 B9 00         cmp al, 0        ; check error code (AL)
0168+  1F19 C6 13 1F      je _gets_escape      ; if no char received, retry
0169+  1F1C 76 6E         cmp ah, 'n'
0170+  1F1E C6 3D 1F      je _gets_LF
0171+  1F21 76 72         cmp ah, 'r'
0172+  1F23 C6 44 1F      je _gets_CR
0173+  1F26 76 30         cmp ah, '0'
0174+  1F28 C6 4B 1F      je _gets_NULL
0175+  1F2B 76 5C         cmp ah, $5C  ; '\'
0176+  1F2D C6 36 1F      je _gets_slash
0177+  1F30 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1F31 3E            mov [d], al
0179+  1F32 79            inc d
0180+  1F33 0A BB 1E      jmp _gets_loop
0181+  1F36             _gets_slash:
0182+  1F36 19 5C         mov al, $5C
0183+  1F38 3E            mov [d], al
0184+  1F39 79            inc d
0185+  1F3A 0A BB 1E      jmp _gets_loop
0186+  1F3D             _gets_LF:
0187+  1F3D 19 0A         mov al, $0A
0188+  1F3F 3E            mov [d], al
0189+  1F40 79            inc d
0190+  1F41 0A BB 1E      jmp _gets_loop
0191+  1F44             _gets_CR:
0192+  1F44 19 0D         mov al, $0D
0193+  1F46 3E            mov [d], al
0194+  1F47 79            inc d
0195+  1F48 0A BB 1E      jmp _gets_loop
0196+  1F4B             _gets_NULL:
0197+  1F4B 19 00         mov al, $00
0198+  1F4D 3E            mov [d], al
0199+  1F4E 79            inc d
0200+  1F4F 0A BB 1E      jmp _gets_loop
0201+  1F52             _gets_end:
0202+  1F52 19 00         mov al, 0
0203+  1F54 3E            mov [d], al        ; terminate string
0204+  1F55 E7            pop d
0205+  1F56 E4            pop a
0206+  1F57 09            ret
0207+  1F58             
0208+  1F58             ;-----------------------------------------------------------------------------
0209+  1F58             ;; INPUT TEXT
0210+  1F58             ;; terminated with CTRL+D
0211+  1F58             ;; pointer in D
0212+  1F58             ;-----------------------------------------------------------------------------
0213+  1F58             _gettxt:
0214+  1F58 D7            push a
0215+  1F59 DA            push d
0216+  1F5A             _gettxt_loop:
0217+  1F5A 19 01         mov al, 1
0218+  1F5C 05 03         syscall sys_io      ; receive in AH
0219+  1F5E B9 00         cmp al, 0        ; check error code (AL)
0220+  1F60 C6 5A 1F      je _gettxt_loop    ; if no char received, retry
0221+  1F63 76 04         cmp ah, 4      ; EOT
0222+  1F65 C6 A3 1F      je _gettxt_end
0223+  1F68 76 08         cmp ah, $08      ; check for backspace
0224+  1F6A C6 9F 1F      je _gettxt_backspace
0225+  1F6D 76 5C         cmp ah, $5C        ; '\'
0226+  1F6F C6 78 1F      je _gettxt_escape
0227+  1F72 1A            mov al, ah
0228+  1F73 3E            mov [d], al
0229+  1F74 79            inc d
0230+  1F75 0A 5A 1F      jmp _gettxt_loop
0231+  1F78             _gettxt_escape:
0232+  1F78 19 01         mov al, 1
0233+  1F7A 05 03         syscall sys_io      ; receive in AH
0234+  1F7C B9 00         cmp al, 0        ; check error code (AL)
0235+  1F7E C6 78 1F      je _gettxt_escape    ; if no char received, retry
0236+  1F81 76 6E         cmp ah, 'n'
0237+  1F83 C6 91 1F      je _gettxt_LF
0238+  1F86 76 72         cmp ah, 'r'
0239+  1F88 C6 98 1F      je _gettxt_CR
0240+  1F8B 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1F8C 3E            mov [d], al
0242+  1F8D 79            inc d
0243+  1F8E 0A 5A 1F      jmp _gettxt_loop
0244+  1F91             _gettxt_LF:
0245+  1F91 19 0A         mov al, $0A
0246+  1F93 3E            mov [d], al
0247+  1F94 79            inc d
0248+  1F95 0A 5A 1F      jmp _gettxt_loop
0249+  1F98             _gettxt_CR:
0250+  1F98 19 0D         mov al, $0D
0251+  1F9A 3E            mov [d], al
0252+  1F9B 79            inc d
0253+  1F9C 0A 5A 1F      jmp _gettxt_loop
0254+  1F9F             _gettxt_backspace:
0255+  1F9F 7F            dec d
0256+  1FA0 0A 5A 1F      jmp _gettxt_loop
0257+  1FA3             _gettxt_end:
0258+  1FA3 19 00         mov al, 0
0259+  1FA5 3E            mov [d], al        ; terminate string
0260+  1FA6 E7            pop d
0261+  1FA7 E4            pop a
0262+  1FA8 09            ret
0263+  1FA9             
0264+  1FA9             ;-----------------------------------------------------------------------------
0265+  1FA9             ; PRINT NEW LINE
0266+  1FA9             ;-----------------------------------------------------------------------------
0267+  1FA9             printnl:
0268+  1FA9 D7            push a
0269+  1FAA 10 00 0A      mov a, $0A00
0270+  1FAD 05 03         syscall sys_io
0271+  1FAF 10 00 0D      mov a, $0D00
0272+  1FB2 05 03         syscall sys_io
0273+  1FB4 E4            pop a
0274+  1FB5 09            ret
0275+  1FB6             
0276+  1FB6             ;-----------------------------------------------------------------------------
0277+  1FB6             ; _strtoint
0278+  1FB6             ; 4 digit hex string number in d
0279+  1FB6             ; integer returned in A
0280+  1FB6             ;-----------------------------------------------------------------------------
0281+  1FB6             _strtointx:
0282+  1FB6 D8            push b
0283+  1FB7 32            mov bl, [d]
0284+  1FB8 37            mov bh, bl
0285+  1FB9 33 01 00      mov bl, [d + 1]
0286+  1FBC 07 70 1E      call _atoi        ; convert to int in AL
0287+  1FBF 23            mov ah, al        ; move to AH
0288+  1FC0 33 02 00      mov bl, [d + 2]
0289+  1FC3 37            mov bh, bl
0290+  1FC4 33 03 00      mov bl, [d + 3]
0291+  1FC7 07 70 1E      call _atoi        ; convert to int in AL
0292+  1FCA E5            pop b
0293+  1FCB 09            ret
0294+  1FCC             
0295+  1FCC             ;-----------------------------------------------------------------------------
0296+  1FCC             ; _strtoint
0297+  1FCC             ; 5 digit base10 string number in d
0298+  1FCC             ; integer returned in A
0299+  1FCC             ;-----------------------------------------------------------------------------
0300+  1FCC             _strtoint:
0301+  1FCC E2            push si
0302+  1FCD D8            push b
0303+  1FCE D9            push c
0304+  1FCF DA            push d
0305+  1FD0 07 12 1E      call _strlen      ; get string length in C
0306+  1FD3 7E            dec c
0307+  1FD4 FD 4E         mov si, d
0308+  1FD6 12            mov a, c
0309+  1FD7 FD 99         shl a
0310+  1FD9 3B 48 21      mov d, table_power
0311+  1FDC 59            add d, a
0312+  1FDD 38 00 00      mov c, 0
0313+  1FE0             _strtoint_L0:
0314+  1FE0 F6            lodsb      ; load ASCII to al
0315+  1FE1 B9 00         cmp al, 0
0316+  1FE3 C6 F6 1F      je _strtoint_end
0317+  1FE6 6F 30         sub al, $30    ; make into integer
0318+  1FE8 22 00         mov ah, 0
0319+  1FEA 2A            mov b, [d]
0320+  1FEB AC            mul a, b      ; result in B since it fits in 16bits
0321+  1FEC 11            mov a, b
0322+  1FED 28            mov b, c
0323+  1FEE 54            add a, b
0324+  1FEF 39            mov c, a
0325+  1FF0 63 02 00      sub d, 2
0326+  1FF3 0A E0 1F      jmp _strtoint_L0
0327+  1FF6             _strtoint_end:
0328+  1FF6 12            mov a, c
0329+  1FF7 E7            pop d
0330+  1FF8 E6            pop c
0331+  1FF9 E5            pop b
0332+  1FFA EF            pop si
0333+  1FFB 09            ret
0334+  1FFC             
0335+  1FFC             ;-----------------------------------------------------------------------------
0336+  1FFC             ; PRINT NULL TERMINATED STRING
0337+  1FFC             ; pointer in D
0338+  1FFC             ;-----------------------------------------------------------------------------
0339+  1FFC             _puts:
0340+  1FFC D7            push a
0341+  1FFD DA            push d
0342+  1FFE             _puts_L1:
0343+  1FFE 1E            mov al, [d]
0344+  1FFF B9 00         cmp al, 0
0345+  2001 C6 0D 20      jz _puts_END
0346+  2004 23            mov ah, al
0347+  2005 19 00         mov al, 0
0348+  2007 05 03         syscall sys_io
0349+  2009 79            inc d
0350+  200A 0A FE 1F      jmp _puts_L1
0351+  200D             _puts_END:
0352+  200D E7            pop d
0353+  200E E4            pop a
0354+  200F 09            ret
0355+  2010             
0356+  2010             ;-----------------------------------------------------------------------------
0357+  2010             ; PRINT N SIZE STRING
0358+  2010             ; pointer in D
0359+  2010             ; size in C
0360+  2010             ;-----------------------------------------------------------------------------
0361+  2010             _putsn:
0362+  2010 DB            push al
0363+  2011 DA            push d
0364+  2012 D9            push c
0365+  2013             _putsn_L0:
0366+  2013 1E            mov al, [d]
0367+  2014 23            mov ah, al
0368+  2015 19 00         mov al, 0
0369+  2017 05 03         syscall sys_io
0370+  2019 79            inc d
0371+  201A 7E            dec c  
0372+  201B C2 00 00      cmp c, 0
0373+  201E C7 13 20      jne _putsn_L0
0374+  2021             _putsn_end:
0375+  2021 E6            pop c
0376+  2022 E7            pop d
0377+  2023 E8            pop al
0378+  2024 09            ret
0379+  2025             
0380+  2025             ;-----------------------------------------------------------------------------
0381+  2025             ; print 16bit decimal number
0382+  2025             ; input number in A
0383+  2025             ;-----------------------------------------------------------------------------
0384+  2025             print_u16d:
0385+  2025 D7            push a
0386+  2026 D8            push b
0387+  2027 26 10 27      mov b, 10000
0388+  202A AE            div a, b      ; get 10000's coeff.
0389+  202B 07 4D 20      call print_number
0390+  202E 11            mov a, b
0391+  202F 26 E8 03      mov b, 1000
0392+  2032 AE            div a, b      ; get 1000's coeff.
0393+  2033 07 4D 20      call print_number
0394+  2036 11            mov a, b
0395+  2037 26 64 00      mov b, 100
0396+  203A AE            div a, b
0397+  203B 07 4D 20      call print_number
0398+  203E 11            mov a, b
0399+  203F 26 0A 00      mov b, 10
0400+  2042 AE            div a, b
0401+  2043 07 4D 20      call print_number
0402+  2046 1B            mov al, bl      ; 1's coeff in bl
0403+  2047 07 4D 20      call print_number
0404+  204A E5            pop b
0405+  204B E4            pop a
0406+  204C 09            ret
0407+  204D             
0408+  204D             ;-----------------------------------------------------------------------------
0409+  204D             ; print AL
0410+  204D             ;-----------------------------------------------------------------------------
0411+  204D             print_number:
0412+  204D 6A 30         add al, $30
0413+  204F 23            mov ah, al
0414+  2050 07 B2 1E      call _putchar
0415+  2053 09            ret
0416+  2054             
0417+  2054             ;-----------------------------------------------------------------------------
0418+  2054             ; PRINT 16BIT HEX INTEGER
0419+  2054             ; integer value in reg B
0420+  2054             ;-----------------------------------------------------------------------------
0421+  2054             print_u16x:
0422+  2054 D7            push a
0423+  2055 D8            push b
0424+  2056 DD            push bl
0425+  2057 30            mov bl, bh
0426+  2058 07 80 1E      call _itoa        ; convert bh to char in A
0427+  205B 2F            mov bl, al        ; save al
0428+  205C 19 00         mov al, 0
0429+  205E 05 03         syscall sys_io        ; display AH
0430+  2060 24            mov ah, bl        ; retrieve al
0431+  2061 19 00         mov al, 0
0432+  2063 05 03         syscall sys_io        ; display AL
0433+  2065             
0434+  2065 EA            pop bl
0435+  2066 07 80 1E      call _itoa        ; convert bh to char in A
0436+  2069 2F            mov bl, al        ; save al
0437+  206A 19 00         mov al, 0
0438+  206C 05 03         syscall sys_io        ; display AH
0439+  206E 24            mov ah, bl        ; retrieve al
0440+  206F 19 00         mov al, 0
0441+  2071 05 03         syscall sys_io        ; display AL
0442+  2073             
0443+  2073 E5            pop b
0444+  2074 E4            pop a
0445+  2075 09            ret
0446+  2076             
0447+  2076             ;-----------------------------------------------------------------------------
0448+  2076             ; INPUT 16BIT HEX INTEGER
0449+  2076             ; read 16bit integer into A
0450+  2076             ;-----------------------------------------------------------------------------
0451+  2076             scan_u16x:
0452+  2076 F8 10 00      enter 16
0453+  2079 D8            push b
0454+  207A DA            push d
0455+  207B             
0456+  207B FA F1 FF      lea d, [bp + -15]
0457+  207E 07 B9 1E      call _gets        ; get number
0458+  2081             
0459+  2081 32            mov bl, [d]
0460+  2082 37            mov bh, bl
0461+  2083 33 01 00      mov bl, [d + 1]
0462+  2086 07 70 1E      call _atoi        ; convert to int in AL
0463+  2089 23            mov ah, al        ; move to AH
0464+  208A             
0465+  208A 33 02 00      mov bl, [d + 2]
0466+  208D 37            mov bh, bl
0467+  208E 33 03 00      mov bl, [d + 3]
0468+  2091 07 70 1E      call _atoi        ; convert to int in AL
0469+  2094             
0470+  2094 E7            pop d
0471+  2095 E5            pop b
0472+  2096 F9            leave
0473+  2097 09            ret
0474+  2098             
0475+  2098             ;-----------------------------------------------------------------------------
0476+  2098             ; PRINT 8bit HEX INTEGER
0477+  2098             ; integer value in reg bl
0478+  2098             ;-----------------------------------------------------------------------------
0479+  2098             print_u8x:
0480+  2098 D7            push a
0481+  2099 DD            push bl
0482+  209A             
0483+  209A 07 80 1E      call _itoa        ; convert bl to char in A
0484+  209D 2F            mov bl, al        ; save al
0485+  209E 19 00         mov al, 0
0486+  20A0 05 03         syscall sys_io        ; display AH
0487+  20A2 24            mov ah, bl        ; retrieve al
0488+  20A3 19 00         mov al, 0
0489+  20A5 05 03         syscall sys_io        ; display AL
0490+  20A7             
0491+  20A7 EA            pop bl
0492+  20A8 E4            pop a
0493+  20A9 09            ret
0494+  20AA             
0495+  20AA             ;-----------------------------------------------------------------------------
0496+  20AA             ; print 8bit decimal unsigned number
0497+  20AA             ; input number in AL
0498+  20AA             ;-----------------------------------------------------------------------------
0499+  20AA             print_u8d:
0500+  20AA D7            push a
0501+  20AB D8            push b
0502+  20AC             
0503+  20AC 22 00         mov ah, 0
0504+  20AE 26 64 00      mov b, 100
0505+  20B1 AE            div a, b
0506+  20B2 D8            push b      ; save remainder
0507+  20B3 B9 00         cmp al, 0
0508+  20B5 C6 BF 20      je skip100
0509+  20B8 6A 30         add al, $30
0510+  20BA 23            mov ah, al
0511+  20BB 19 00         mov al, 0
0512+  20BD 05 03         syscall sys_io  ; print coeff
0513+  20BF             skip100:
0514+  20BF E4            pop a
0515+  20C0 22 00         mov ah, 0
0516+  20C2 26 0A 00      mov b, 10
0517+  20C5 AE            div a, b
0518+  20C6 D8            push b      ; save remainder
0519+  20C7 B9 00         cmp al, 0
0520+  20C9 C6 D3 20      je skip10
0521+  20CC 6A 30         add al, $30
0522+  20CE 23            mov ah, al
0523+  20CF 19 00         mov al, 0
0524+  20D1 05 03         syscall sys_io  ; print coeff
0525+  20D3             skip10:
0526+  20D3 E4            pop a
0527+  20D4 1B            mov al, bl
0528+  20D5 6A 30         add al, $30
0529+  20D7 23            mov ah, al
0530+  20D8 19 00         mov al, 0
0531+  20DA 05 03         syscall sys_io  ; print coeff
0532+  20DC E5            pop b
0533+  20DD E4            pop a
0534+  20DE 09            ret
0535+  20DF             
0536+  20DF             ;-----------------------------------------------------------------------------
0537+  20DF             ; INPUT 8BIT HEX INTEGER
0538+  20DF             ; read 8bit integer into AL
0539+  20DF             ;-----------------------------------------------------------------------------
0540+  20DF             scan_u8x:
0541+  20DF F8 04 00      enter 4
0542+  20E2 D8            push b
0543+  20E3 DA            push d
0544+  20E4             
0545+  20E4 FA FD FF      lea d, [bp + -3]
0546+  20E7 07 B9 1E      call _gets        ; get number
0547+  20EA             
0548+  20EA 32            mov bl, [d]
0549+  20EB 37            mov bh, bl
0550+  20EC 33 01 00      mov bl, [d + 1]
0551+  20EF 07 70 1E      call _atoi        ; convert to int in AL
0552+  20F2             
0553+  20F2 E7            pop d
0554+  20F3 E5            pop b
0555+  20F4 F9            leave
0556+  20F5 09            ret
0557+  20F6             
0558+  20F6             ;-----------------------------------------------------------------------------
0559+  20F6             ; input decimal number
0560+  20F6             ; result in A
0561+  20F6             ; 655'\0'
0562+  20F6             ; low--------high
0563+  20F6             ;-----------------------------------------------------------------------------
0564+  20F6             scan_u16d:
0565+  20F6 F8 08 00      enter 8
0566+  20F9 E2            push si
0567+  20FA D8            push b
0568+  20FB D9            push c
0569+  20FC DA            push d
0570+  20FD FA F9 FF      lea d, [bp +- 7]
0571+  2100 07 B9 1E      call _gets
0572+  2103 07 12 1E      call _strlen      ; get string length in C
0573+  2106 7E            dec c
0574+  2107 FD 4E         mov si, d
0575+  2109 12            mov a, c
0576+  210A FD 99         shl a
0577+  210C 3B 48 21      mov d, table_power
0578+  210F 59            add d, a
0579+  2110 38 00 00      mov c, 0
0580+  2113             mul_loop:
0581+  2113 F6            lodsb      ; load ASCII to al
0582+  2114 B9 00         cmp al, 0
0583+  2116 C6 29 21      je mul_exit
0584+  2119 6F 30         sub al, $30    ; make into integer
0585+  211B 22 00         mov ah, 0
0586+  211D 2A            mov b, [d]
0587+  211E AC            mul a, b      ; result in B since it fits in 16bits
0588+  211F 11            mov a, b
0589+  2120 28            mov b, c
0590+  2121 54            add a, b
0591+  2122 39            mov c, a
0592+  2123 63 02 00      sub d, 2
0593+  2126 0A 13 21      jmp mul_loop
0594+  2129             mul_exit:
0595+  2129 12            mov a, c
0596+  212A E7            pop d
0597+  212B E6            pop c
0598+  212C E5            pop b
0599+  212D EF            pop si
0600+  212E F9            leave
0601+  212F 09            ret
0602+  2130             
0603+  2130 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  2134 34 35 36 37 
0603+  2138 38 39 41 42 
0603+  213C 43 44 45 46 
0604+  2140 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  2144 1B 5B 48 00 
0605+  2148             
0606+  2148             table_power:
0607+  2148 01 00         .dw 1
0608+  214A 0A 00         .dw 10
0609+  214C 64 00         .dw 100
0610+  214E E8 03         .dw 1000
0611+  2150 10 27         .dw 100004191   2152             ; --- END INLINE ASM SEGMENT
4192   2152             
4193   2152 F9            leave
4194   2153 09            ret
4195   2154             ; --- END TEXT SEGMENT
4196   2154             
4197   2154             ; --- BEGIN DATA SEGMENT
4198   2154 00 00 00 00 _p: .fill 4, 0
4199   2158 00 00       st_fopen_max_handle: .dw 0
4200   215A 55 6E 65 78 _s0: .db "Unexpected format in printf.", 0
4200   215E 70 65 63 74 
4200   2162 65 64 20 66 
4200   2166 6F 72 6D 61 
4200   216A 74 20 69 6E 
4200   216E 20 70 72 69 
4200   2172 6E 74 66 2E 
4200   2176 00 
4201   2177 45 72 72 6F _s1: .db "Error: Unknown argument type.\n", 0
4201   217B 72 3A 20 55 
4201   217F 6E 6B 6E 6F 
4201   2183 77 6E 20 61 
4201   2187 72 67 75 6D 
4201   218B 65 6E 74 20 
4201   218F 74 79 70 65 
4201   2193 2E 0A 00 
4202   2196 1B 5B 32 4A _s2: .db "\033[2J\033[H", 0
4202   219A 1B 5B 48 00 
4203   219E             
4204   219E A0 21       _heap_top: .dw _heap
4205   21A0 00          _heap: .db 0
4206   21A1             ; --- END DATA SEGMENT
4207   21A1             
4208   21A1             .end
tasm: Number of errors = 0
