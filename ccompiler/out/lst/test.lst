0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             ; --- BEGIN SYSTEM SEGMENT
0005   0000             ; --- END SYSTEM SEGMENT
0006   0000             
0007   0000             ; --- BEGIN TEXT SEGMENT
0008   0400             .org text_org
0009   0400             main:
0010   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0011   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0012   0408             ; printf("Hello World" 
0013   0408             ; --- START FUNCTION CALL
0014   0408 26 25 0D      mov b, _s0 ; "Hello WorldMy name is Sol-1And this is a multi-line string"
0015   040B FD AB         swp b
0016   040D D8            push b
0017   040E 07 16 04      call printf
0018   0411 51 02 00      add sp, 2
0019   0414             ; --- END FUNCTION CALL
0020   0414 05 0B         syscall sys_terminate_proc
0021   0416             
0022   0416             printf:
0023   0416 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0024   0419             ; char *p, *format_p; 
0025   0419 52 02 00      sub sp, 2
0026   041C 52 02 00      sub sp, 2
0027   041F             ; format_p = format; 
0028   041F FA FD FF      lea d, [bp + -3] ; $format_p
0029   0422 DA            push d
0030   0423 FA 05 00      lea d, [bp + 5] ; $format
0031   0426 2A            mov b, [d]
0032   0427 38 00 00      mov c, 0
0033   042A E7            pop d
0034   042B FD 43         mov [d], b
0035   042D             ; p = &format + 2; 
0036   042D FA FF FF      lea d, [bp + -1] ; $p
0037   0430 DA            push d
0038   0431 FA 05 00      lea d, [bp + 5] ; $format
0039   0434 2D            mov b, d
0040   0435             ; --- START TERMS
0041   0435 D7            push a
0042   0436 11            mov a, b
0043   0437 FD 2E 02 00   mov32 cb, $00000002
0043   043B 00 00 
0044   043D 56            add b, a
0045   043E E4            pop a
0046   043F             ; --- END TERMS
0047   043F E7            pop d
0048   0440 FD 43         mov [d], b
0049   0442             ; for(;;){ 
0050   0442             _for1_init:
0051   0442             _for1_cond:
0052   0442             _for1_block:
0053   0442             ; if(!*format_p) break; 
0054   0442             _if2_cond:
0055   0442 FA FD FF      lea d, [bp + -3] ; $format_p
0056   0445 2A            mov b, [d]
0057   0446 38 00 00      mov c, 0
0058   0449 74            mov d, b
0059   044A 32            mov bl, [d]
0060   044B A7 00         mov bh, 0
0061   044D 38 00 00      mov c, 0
0062   0450 C0 00 00      cmp b, 0
0063   0453 FD 71         seq ; !
0064   0455 C0 00 00      cmp b, 0
0065   0458 C6 61 04      je _if2_else
0066   045B             _if2_TRUE:
0067   045B             ; break; 
0068   045B 0A 11 07      jmp _for1_exit ; for break
0069   045E 0A 0E 07      jmp _if2_exit
0070   0461             _if2_else:
0071   0461             ; if(*format_p == '%'){ 
0072   0461             _if3_cond:
0073   0461 FA FD FF      lea d, [bp + -3] ; $format_p
0074   0464 2A            mov b, [d]
0075   0465 38 00 00      mov c, 0
0076   0468 74            mov d, b
0077   0469 32            mov bl, [d]
0078   046A A7 00         mov bh, 0
0079   046C 38 00 00      mov c, 0
0080   046F             ; --- START RELATIONAL
0081   046F D7            push a
0082   0470 11            mov a, b
0083   0471 FD 2E 25 00   mov32 cb, $00000025
0083   0475 00 00 
0084   0477 B0            cmp a, b
0085   0478 FD 71         seq ; ==
0086   047A E4            pop a
0087   047B             ; --- END RELATIONAL
0088   047B C0 00 00      cmp b, 0
0089   047E C6 E9 06      je _if3_else
0090   0481             _if3_TRUE:
0091   0481             ; format_p++; 
0092   0481 FA FD FF      lea d, [bp + -3] ; $format_p
0093   0484 2A            mov b, [d]
0094   0485 38 00 00      mov c, 0
0095   0488 FD 77         inc b
0096   048A FA FD FF      lea d, [bp + -3] ; $format_p
0097   048D FD 43         mov [d], b
0098   048F FD 7D         dec b
0099   0491             ; switch(*format_p){ 
0100   0491             _switch4_expr:
0101   0491 FA FD FF      lea d, [bp + -3] ; $format_p
0102   0494 2A            mov b, [d]
0103   0495 38 00 00      mov c, 0
0104   0498 74            mov d, b
0105   0499 32            mov bl, [d]
0106   049A A7 00         mov bh, 0
0107   049C 38 00 00      mov c, 0
0108   049F             _switch4_comparisons:
0109   049F C1 6C         cmp bl, $6c
0110   04A1 C6 CD 04      je _switch4_case0
0111   04A4 C1 4C         cmp bl, $4c
0112   04A6 C6 CD 04      je _switch4_case1
0113   04A9 C1 64         cmp bl, $64
0114   04AB C6 DD 05      je _switch4_case2
0115   04AE C1 69         cmp bl, $69
0116   04B0 C6 DD 05      je _switch4_case3
0117   04B3 C1 75         cmp bl, $75
0118   04B5 C6 0D 06      je _switch4_case4
0119   04B8 C1 78         cmp bl, $78
0120   04BA C6 3D 06      je _switch4_case5
0121   04BD C1 63         cmp bl, $63
0122   04BF C6 6D 06      je _switch4_case6
0123   04C2 C1 73         cmp bl, $73
0124   04C4 C6 9D 06      je _switch4_case7
0125   04C7 0A CA 06      jmp _switch4_default
0126   04CA 0A D6 06      jmp _switch4_exit
0127   04CD             _switch4_case0:
0128   04CD             _switch4_case1:
0129   04CD             ; format_p++; 
0130   04CD FA FD FF      lea d, [bp + -3] ; $format_p
0131   04D0 2A            mov b, [d]
0132   04D1 38 00 00      mov c, 0
0133   04D4 FD 77         inc b
0134   04D6 FA FD FF      lea d, [bp + -3] ; $format_p
0135   04D9 FD 43         mov [d], b
0136   04DB FD 7D         dec b
0137   04DD             ; if(*format_p == 'd' || *format_p == 'i') 
0138   04DD             _if5_cond:
0139   04DD FA FD FF      lea d, [bp + -3] ; $format_p
0140   04E0 2A            mov b, [d]
0141   04E1 38 00 00      mov c, 0
0142   04E4 74            mov d, b
0143   04E5 32            mov bl, [d]
0144   04E6 A7 00         mov bh, 0
0145   04E8 38 00 00      mov c, 0
0146   04EB             ; --- START RELATIONAL
0147   04EB D7            push a
0148   04EC 11            mov a, b
0149   04ED FD 2E 64 00   mov32 cb, $00000064
0149   04F1 00 00 
0150   04F3 B0            cmp a, b
0151   04F4 FD 71         seq ; ==
0152   04F6 E4            pop a
0153   04F7             ; --- END RELATIONAL
0154   04F7             ; --- START LOGICAL OR
0155   04F7 D7            push a
0156   04F8 11            mov a, b
0157   04F9 FA FD FF      lea d, [bp + -3] ; $format_p
0158   04FC 2A            mov b, [d]
0159   04FD 38 00 00      mov c, 0
0160   0500 74            mov d, b
0161   0501 32            mov bl, [d]
0162   0502 A7 00         mov bh, 0
0163   0504 38 00 00      mov c, 0
0164   0507             ; --- START RELATIONAL
0165   0507 D7            push a
0166   0508 11            mov a, b
0167   0509 FD 2E 69 00   mov32 cb, $00000069
0167   050D 00 00 
0168   050F B0            cmp a, b
0169   0510 FD 71         seq ; ==
0170   0512 E4            pop a
0171   0513             ; --- END RELATIONAL
0172   0513 FD A8         sor a, b ; ||
0173   0515 E4            pop a
0174   0516             ; --- END LOGICAL OR
0175   0516 C0 00 00      cmp b, 0
0176   0519 C6 3A 05      je _if5_else
0177   051C             _if5_TRUE:
0178   051C             ; print_signed_long(*(long *)p); 
0179   051C             ; --- START FUNCTION CALL
0180   051C FA FF FF      lea d, [bp + -1] ; $p
0181   051F 2A            mov b, [d]
0182   0520 38 00 00      mov c, 0
0183   0523 74            mov d, b
0184   0524 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0185   0527 FD 39         mov c, b ; And place it into C
0186   0529 2A            mov b, [d] ; Lower Word in B
0187   052A 12            mov a, c
0188   052B FD AA         swp a
0189   052D D7            push a
0190   052E FD AB         swp b
0191   0530 D8            push b
0192   0531 07 13 07      call print_signed_long
0193   0534 51 04 00      add sp, 4
0194   0537             ; --- END FUNCTION CALL
0195   0537 0A C2 05      jmp _if5_exit
0196   053A             _if5_else:
0197   053A             ; if(*format_p == 'u') 
0198   053A             _if6_cond:
0199   053A FA FD FF      lea d, [bp + -3] ; $format_p
0200   053D 2A            mov b, [d]
0201   053E 38 00 00      mov c, 0
0202   0541 74            mov d, b
0203   0542 32            mov bl, [d]
0204   0543 A7 00         mov bh, 0
0205   0545 38 00 00      mov c, 0
0206   0548             ; --- START RELATIONAL
0207   0548 D7            push a
0208   0549 11            mov a, b
0209   054A FD 2E 75 00   mov32 cb, $00000075
0209   054E 00 00 
0210   0550 B0            cmp a, b
0211   0551 FD 71         seq ; ==
0212   0553 E4            pop a
0213   0554             ; --- END RELATIONAL
0214   0554 C0 00 00      cmp b, 0
0215   0557 C6 78 05      je _if6_else
0216   055A             _if6_TRUE:
0217   055A             ; print_unsigned_long(*(unsigned long *)p); 
0218   055A             ; --- START FUNCTION CALL
0219   055A FA FF FF      lea d, [bp + -1] ; $p
0220   055D 2A            mov b, [d]
0221   055E 38 00 00      mov c, 0
0222   0561 74            mov d, b
0223   0562 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0224   0565 FD 39         mov c, b ; And place it into C
0225   0567 2A            mov b, [d] ; Lower Word in B
0226   0568 12            mov a, c
0227   0569 FD AA         swp a
0228   056B D7            push a
0229   056C FD AB         swp b
0230   056E D8            push b
0231   056F 07 A6 08      call print_unsigned_long
0232   0572 51 04 00      add sp, 4
0233   0575             ; --- END FUNCTION CALL
0234   0575 0A C2 05      jmp _if6_exit
0235   0578             _if6_else:
0236   0578             ; if(*format_p == 'x') 
0237   0578             _if7_cond:
0238   0578 FA FD FF      lea d, [bp + -3] ; $format_p
0239   057B 2A            mov b, [d]
0240   057C 38 00 00      mov c, 0
0241   057F 74            mov d, b
0242   0580 32            mov bl, [d]
0243   0581 A7 00         mov bh, 0
0244   0583 38 00 00      mov c, 0
0245   0586             ; --- START RELATIONAL
0246   0586 D7            push a
0247   0587 11            mov a, b
0248   0588 FD 2E 78 00   mov32 cb, $00000078
0248   058C 00 00 
0249   058E B0            cmp a, b
0250   058F FD 71         seq ; ==
0251   0591 E4            pop a
0252   0592             ; --- END RELATIONAL
0253   0592 C0 00 00      cmp b, 0
0254   0595 C6 B6 05      je _if7_else
0255   0598             _if7_TRUE:
0256   0598             ; printx32(*(long int *)p); 
0257   0598             ; --- START FUNCTION CALL
0258   0598 FA FF FF      lea d, [bp + -1] ; $p
0259   059B 2A            mov b, [d]
0260   059C 38 00 00      mov c, 0
0261   059F 74            mov d, b
0262   05A0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0263   05A3 FD 39         mov c, b ; And place it into C
0264   05A5 2A            mov b, [d] ; Lower Word in B
0265   05A6 12            mov a, c
0266   05A7 FD AA         swp a
0267   05A9 D7            push a
0268   05AA FD AB         swp b
0269   05AC D8            push b
0270   05AD 07 DA 09      call printx32
0271   05B0 51 04 00      add sp, 4
0272   05B3             ; --- END FUNCTION CALL
0273   05B3 0A C2 05      jmp _if7_exit
0274   05B6             _if7_else:
0275   05B6             ; err("Unexpected format in printf."); 
0276   05B6             ; --- START FUNCTION CALL
0277   05B6 26 60 0D      mov b, _s1 ; "Unexpected format in printf."
0278   05B9 FD AB         swp b
0279   05BB D8            push b
0280   05BC 07 3A 0A      call err
0281   05BF 51 02 00      add sp, 2
0282   05C2             ; --- END FUNCTION CALL
0283   05C2             _if7_exit:
0284   05C2             _if6_exit:
0285   05C2             _if5_exit:
0286   05C2             ; p = p + 4; 
0287   05C2 FA FF FF      lea d, [bp + -1] ; $p
0288   05C5 DA            push d
0289   05C6 FA FF FF      lea d, [bp + -1] ; $p
0290   05C9 2A            mov b, [d]
0291   05CA 38 00 00      mov c, 0
0292   05CD             ; --- START TERMS
0293   05CD D7            push a
0294   05CE 11            mov a, b
0295   05CF FD 2E 04 00   mov32 cb, $00000004
0295   05D3 00 00 
0296   05D5 56            add b, a
0297   05D6 E4            pop a
0298   05D7             ; --- END TERMS
0299   05D7 E7            pop d
0300   05D8 FD 43         mov [d], b
0301   05DA             ; break; 
0302   05DA 0A D6 06      jmp _switch4_exit ; case break
0303   05DD             _switch4_case2:
0304   05DD             _switch4_case3:
0305   05DD             ; print_signed(*(int*)p); 
0306   05DD             ; --- START FUNCTION CALL
0307   05DD FA FF FF      lea d, [bp + -1] ; $p
0308   05E0 2A            mov b, [d]
0309   05E1 38 00 00      mov c, 0
0310   05E4 74            mov d, b
0311   05E5 2A            mov b, [d]
0312   05E6 38 00 00      mov c, 0
0313   05E9 FD AB         swp b
0314   05EB D8            push b
0315   05EC 07 68 0A      call print_signed
0316   05EF 51 02 00      add sp, 2
0317   05F2             ; --- END FUNCTION CALL
0318   05F2             ; p = p + 2; 
0319   05F2 FA FF FF      lea d, [bp + -1] ; $p
0320   05F5 DA            push d
0321   05F6 FA FF FF      lea d, [bp + -1] ; $p
0322   05F9 2A            mov b, [d]
0323   05FA 38 00 00      mov c, 0
0324   05FD             ; --- START TERMS
0325   05FD D7            push a
0326   05FE 11            mov a, b
0327   05FF FD 2E 02 00   mov32 cb, $00000002
0327   0603 00 00 
0328   0605 56            add b, a
0329   0606 E4            pop a
0330   0607             ; --- END TERMS
0331   0607 E7            pop d
0332   0608 FD 43         mov [d], b
0333   060A             ; break; 
0334   060A 0A D6 06      jmp _switch4_exit ; case break
0335   060D             _switch4_case4:
0336   060D             ; print_unsigned(*(unsigned int*)p); 
0337   060D             ; --- START FUNCTION CALL
0338   060D FA FF FF      lea d, [bp + -1] ; $p
0339   0610 2A            mov b, [d]
0340   0611 38 00 00      mov c, 0
0341   0614 74            mov d, b
0342   0615 2A            mov b, [d]
0343   0616 38 00 00      mov c, 0
0344   0619 FD AB         swp b
0345   061B D8            push b
0346   061C 07 B9 0B      call print_unsigned
0347   061F 51 02 00      add sp, 2
0348   0622             ; --- END FUNCTION CALL
0349   0622             ; p = p + 2; 
0350   0622 FA FF FF      lea d, [bp + -1] ; $p
0351   0625 DA            push d
0352   0626 FA FF FF      lea d, [bp + -1] ; $p
0353   0629 2A            mov b, [d]
0354   062A 38 00 00      mov c, 0
0355   062D             ; --- START TERMS
0356   062D D7            push a
0357   062E 11            mov a, b
0358   062F FD 2E 02 00   mov32 cb, $00000002
0358   0633 00 00 
0359   0635 56            add b, a
0360   0636 E4            pop a
0361   0637             ; --- END TERMS
0362   0637 E7            pop d
0363   0638 FD 43         mov [d], b
0364   063A             ; break; 
0365   063A 0A D6 06      jmp _switch4_exit ; case break
0366   063D             _switch4_case5:
0367   063D             ; printx16(*(int*)p); 
0368   063D             ; --- START FUNCTION CALL
0369   063D FA FF FF      lea d, [bp + -1] ; $p
0370   0640 2A            mov b, [d]
0371   0641 38 00 00      mov c, 0
0372   0644 74            mov d, b
0373   0645 2A            mov b, [d]
0374   0646 38 00 00      mov c, 0
0375   0649 FD AB         swp b
0376   064B D8            push b
0377   064C 07 D1 0C      call printx16
0378   064F 51 02 00      add sp, 2
0379   0652             ; --- END FUNCTION CALL
0380   0652             ; p = p + 2; 
0381   0652 FA FF FF      lea d, [bp + -1] ; $p
0382   0655 DA            push d
0383   0656 FA FF FF      lea d, [bp + -1] ; $p
0384   0659 2A            mov b, [d]
0385   065A 38 00 00      mov c, 0
0386   065D             ; --- START TERMS
0387   065D D7            push a
0388   065E 11            mov a, b
0389   065F FD 2E 02 00   mov32 cb, $00000002
0389   0663 00 00 
0390   0665 56            add b, a
0391   0666 E4            pop a
0392   0667             ; --- END TERMS
0393   0667 E7            pop d
0394   0668 FD 43         mov [d], b
0395   066A             ; break; 
0396   066A 0A D6 06      jmp _switch4_exit ; case break
0397   066D             _switch4_case6:
0398   066D             ; putchar(*(char*)p); 
0399   066D             ; --- START FUNCTION CALL
0400   066D FA FF FF      lea d, [bp + -1] ; $p
0401   0670 2A            mov b, [d]
0402   0671 38 00 00      mov c, 0
0403   0674 74            mov d, b
0404   0675 32            mov bl, [d]
0405   0676 A7 00         mov bh, 0
0406   0678 38 00 00      mov c, 0
0407   067B DD            push bl
0408   067C 07 98 08      call putchar
0409   067F 51 01 00      add sp, 1
0410   0682             ; --- END FUNCTION CALL
0411   0682             ; p = p + 2; 
0412   0682 FA FF FF      lea d, [bp + -1] ; $p
0413   0685 DA            push d
0414   0686 FA FF FF      lea d, [bp + -1] ; $p
0415   0689 2A            mov b, [d]
0416   068A 38 00 00      mov c, 0
0417   068D             ; --- START TERMS
0418   068D D7            push a
0419   068E 11            mov a, b
0420   068F FD 2E 02 00   mov32 cb, $00000002
0420   0693 00 00 
0421   0695 56            add b, a
0422   0696 E4            pop a
0423   0697             ; --- END TERMS
0424   0697 E7            pop d
0425   0698 FD 43         mov [d], b
0426   069A             ; break; 
0427   069A 0A D6 06      jmp _switch4_exit ; case break
0428   069D             _switch4_case7:
0429   069D             ; print(*(char**)p); 
0430   069D             ; --- START FUNCTION CALL
0431   069D FA FF FF      lea d, [bp + -1] ; $p
0432   06A0 2A            mov b, [d]
0433   06A1 38 00 00      mov c, 0
0434   06A4 74            mov d, b
0435   06A5 2A            mov b, [d]
0436   06A6 FD AB         swp b
0437   06A8 D8            push b
0438   06A9 07 4F 0A      call print
0439   06AC 51 02 00      add sp, 2
0440   06AF             ; --- END FUNCTION CALL
0441   06AF             ; p = p + 2; 
0442   06AF FA FF FF      lea d, [bp + -1] ; $p
0443   06B2 DA            push d
0444   06B3 FA FF FF      lea d, [bp + -1] ; $p
0445   06B6 2A            mov b, [d]
0446   06B7 38 00 00      mov c, 0
0447   06BA             ; --- START TERMS
0448   06BA D7            push a
0449   06BB 11            mov a, b
0450   06BC FD 2E 02 00   mov32 cb, $00000002
0450   06C0 00 00 
0451   06C2 56            add b, a
0452   06C3 E4            pop a
0453   06C4             ; --- END TERMS
0454   06C4 E7            pop d
0455   06C5 FD 43         mov [d], b
0456   06C7             ; break; 
0457   06C7 0A D6 06      jmp _switch4_exit ; case break
0458   06CA             _switch4_default:
0459   06CA             ; print("Error: Unknown argument type.\n"); 
0460   06CA             ; --- START FUNCTION CALL
0461   06CA 26 7D 0D      mov b, _s2 ; "Error: Unknown argument type.\n"
0462   06CD FD AB         swp b
0463   06CF D8            push b
0464   06D0 07 4F 0A      call print
0465   06D3 51 02 00      add sp, 2
0466   06D6             ; --- END FUNCTION CALL
0467   06D6             _switch4_exit:
0468   06D6             ; format_p++; 
0469   06D6 FA FD FF      lea d, [bp + -3] ; $format_p
0470   06D9 2A            mov b, [d]
0471   06DA 38 00 00      mov c, 0
0472   06DD FD 77         inc b
0473   06DF FA FD FF      lea d, [bp + -3] ; $format_p
0474   06E2 FD 43         mov [d], b
0475   06E4 FD 7D         dec b
0476   06E6 0A 0E 07      jmp _if3_exit
0477   06E9             _if3_else:
0478   06E9             ; putchar(*format_p); 
0479   06E9             ; --- START FUNCTION CALL
0480   06E9 FA FD FF      lea d, [bp + -3] ; $format_p
0481   06EC 2A            mov b, [d]
0482   06ED 38 00 00      mov c, 0
0483   06F0 74            mov d, b
0484   06F1 32            mov bl, [d]
0485   06F2 A7 00         mov bh, 0
0486   06F4 38 00 00      mov c, 0
0487   06F7 DD            push bl
0488   06F8 07 98 08      call putchar
0489   06FB 51 01 00      add sp, 1
0490   06FE             ; --- END FUNCTION CALL
0491   06FE             ; format_p++; 
0492   06FE FA FD FF      lea d, [bp + -3] ; $format_p
0493   0701 2A            mov b, [d]
0494   0702 38 00 00      mov c, 0
0495   0705 FD 77         inc b
0496   0707 FA FD FF      lea d, [bp + -3] ; $format_p
0497   070A FD 43         mov [d], b
0498   070C FD 7D         dec b
0499   070E             _if3_exit:
0500   070E             _if2_exit:
0501   070E             _for1_update:
0502   070E 0A 42 04      jmp _for1_cond
0503   0711             _for1_exit:
0504   0711 F9            leave
0505   0712 09            ret
0506   0713             
0507   0713             print_signed_long:
0508   0713 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0509   0716             ; char digits[10]; 
0510   0716 52 0A 00      sub sp, 10
0511   0719             ; int i = 0; 
0512   0719 52 02 00      sub sp, 2
0513   071C             ; --- START LOCAL VAR INITIALIZATION
0514   071C FA F5 FF      lea d, [bp + -11] ; $i
0515   071F DA            push d
0516   0720 FD 2E 00 00   mov32 cb, $00000000
0516   0724 00 00 
0517   0726 E7            pop d
0518   0727 FD 43         mov [d], b
0519   0729             ; --- END LOCAL VAR INITIALIZATION
0520   0729             ; if (num < 0) { 
0521   0729             _if8_cond:
0522   0729 FA 05 00      lea d, [bp + 5] ; $num
0523   072C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0524   072F FD 39         mov c, b ; And place it into C
0525   0731 2A            mov b, [d] ; Lower Word in B
0526   0732             ; --- START RELATIONAL
0527   0732 D7            push a
0528   0733 FD D8         push g
0529   0735 11            mov a, b
0530   0736 FD 7A         mov g, c
0531   0738 FD 2E 00 00   mov32 cb, $00000000
0531   073C 00 00 
0532   073E FD AF         cmp32 ga, cb
0533   0740 FD 73         slt ; <
0534   0742 FD F1         pop g
0535   0744 E4            pop a
0536   0745             ; --- END RELATIONAL
0537   0745 C0 00 00      cmp b, 0
0538   0748 C6 7A 07      je _if8_else
0539   074B             _if8_TRUE:
0540   074B             ; putchar('-'); 
0541   074B             ; --- START FUNCTION CALL
0542   074B FD 2E 2D 00   mov32 cb, $0000002d
0542   074F 00 00 
0543   0751 DD            push bl
0544   0752 07 98 08      call putchar
0545   0755 51 01 00      add sp, 1
0546   0758             ; --- END FUNCTION CALL
0547   0758             ; num = -num; 
0548   0758 FA 05 00      lea d, [bp + 5] ; $num
0549   075B DA            push d
0550   075C FA 05 00      lea d, [bp + 5] ; $num
0551   075F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0552   0762 FD 39         mov c, b ; And place it into C
0553   0764 2A            mov b, [d] ; Lower Word in B
0554   0765 12            mov a, c
0555   0766 95            not a
0556   0767 97            not b
0557   0768 55 01 00      add b, 1
0558   076B 5B 00 00      adc a, 0
0559   076E 39            mov c, a
0560   076F E7            pop d
0561   0770 FD 43         mov [d], b
0562   0772 28            mov b, c
0563   0773 FD 44 02 00   mov [d + 2], b
0564   0777 0A AE 07      jmp _if8_exit
0565   077A             _if8_else:
0566   077A             ; if (num == 0) { 
0567   077A             _if9_cond:
0568   077A FA 05 00      lea d, [bp + 5] ; $num
0569   077D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0570   0780 FD 39         mov c, b ; And place it into C
0571   0782 2A            mov b, [d] ; Lower Word in B
0572   0783             ; --- START RELATIONAL
0573   0783 D7            push a
0574   0784 FD D8         push g
0575   0786 11            mov a, b
0576   0787 FD 7A         mov g, c
0577   0789 FD 2E 00 00   mov32 cb, $00000000
0577   078D 00 00 
0578   078F FD AF         cmp32 ga, cb
0579   0791 FD 71         seq ; ==
0580   0793 FD F1         pop g
0581   0795 E4            pop a
0582   0796             ; --- END RELATIONAL
0583   0796 C0 00 00      cmp b, 0
0584   0799 C6 AE 07      je _if9_exit
0585   079C             _if9_TRUE:
0586   079C             ; putchar('0'); 
0587   079C             ; --- START FUNCTION CALL
0588   079C FD 2E 30 00   mov32 cb, $00000030
0588   07A0 00 00 
0589   07A2 DD            push bl
0590   07A3 07 98 08      call putchar
0591   07A6 51 01 00      add sp, 1
0592   07A9             ; --- END FUNCTION CALL
0593   07A9             ; return; 
0594   07A9 F9            leave
0595   07AA 09            ret
0596   07AB 0A AE 07      jmp _if9_exit
0597   07AE             _if9_exit:
0598   07AE             _if8_exit:
0599   07AE             ; while (num > 0) { 
0600   07AE             _while10_cond:
0601   07AE FA 05 00      lea d, [bp + 5] ; $num
0602   07B1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0603   07B4 FD 39         mov c, b ; And place it into C
0604   07B6 2A            mov b, [d] ; Lower Word in B
0605   07B7             ; --- START RELATIONAL
0606   07B7 D7            push a
0607   07B8 FD D8         push g
0608   07BA 11            mov a, b
0609   07BB FD 7A         mov g, c
0610   07BD FD 2E 00 00   mov32 cb, $00000000
0610   07C1 00 00 
0611   07C3 FD AF         cmp32 ga, cb
0612   07C5 FD 7F         sgt
0613   07C7 FD F1         pop g
0614   07C9 E4            pop a
0615   07CA             ; --- END RELATIONAL
0616   07CA C0 00 00      cmp b, 0
0617   07CD C6 4E 08      je _while10_exit
0618   07D0             _while10_block:
0619   07D0             ; digits[i] = '0' + (num % 10); 
0620   07D0 FA F7 FF      lea d, [bp + -9] ; $digits
0621   07D3 D7            push a
0622   07D4 DA            push d
0623   07D5 FA F5 FF      lea d, [bp + -11] ; $i
0624   07D8 2A            mov b, [d]
0625   07D9 38 00 00      mov c, 0
0626   07DC E7            pop d
0627   07DD 5A            add d, b
0628   07DE E4            pop a
0629   07DF DA            push d
0630   07E0 FD 2E 30 00   mov32 cb, $00000030
0630   07E4 00 00 
0631   07E6             ; --- START TERMS
0632   07E6 D7            push a
0633   07E7 11            mov a, b
0634   07E8 FA 05 00      lea d, [bp + 5] ; $num
0635   07EB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0636   07EE FD 39         mov c, b ; And place it into C
0637   07F0 2A            mov b, [d] ; Lower Word in B
0638   07F1             ; --- START FACTORS
0639   07F1 D7            push a
0640   07F2 FD D8         push g
0641   07F4 11            mov a, b
0642   07F5 FD 7A         mov g, c
0643   07F7 FD 2E 0A 00   mov32 cb, $0000000a
0643   07FB 00 00 
0644   07FD FD D8         push g ; save 'g' as the div instruction uses it
0645   07FF AE            div a, b ; %, a: quotient, b: remainder
0646   0800 11            mov a, b
0647   0801 FD F1         pop g
0648   0803 FD 38         mov c, g
0649   0805 27            mov b, a
0650   0806 FD F1         pop g
0651   0808 E4            pop a
0652   0809             ; --- END FACTORS
0653   0809 FD 15         add32 cb, ga
0654   080B E4            pop a
0655   080C             ; --- END TERMS
0656   080C E7            pop d
0657   080D FD 3E         mov [d], bl
0658   080F             ; num = num / 10; 
0659   080F FA 05 00      lea d, [bp + 5] ; $num
0660   0812 DA            push d
0661   0813 FA 05 00      lea d, [bp + 5] ; $num
0662   0816 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0663   0819 FD 39         mov c, b ; And place it into C
0664   081B 2A            mov b, [d] ; Lower Word in B
0665   081C             ; --- START FACTORS
0666   081C D7            push a
0667   081D FD D8         push g
0668   081F 11            mov a, b
0669   0820 FD 7A         mov g, c
0670   0822 FD 2E 0A 00   mov32 cb, $0000000a
0670   0826 00 00 
0671   0828 FD D8         push g ; save 'g' as the div instruction uses it
0672   082A AE            div a, b ; /, a: quotient, b: remainder
0673   082B FD F1         pop g
0674   082D FD 38         mov c, g
0675   082F 27            mov b, a
0676   0830 FD F1         pop g
0677   0832 E4            pop a
0678   0833             ; --- END FACTORS
0679   0833 E7            pop d
0680   0834 FD 43         mov [d], b
0681   0836 28            mov b, c
0682   0837 FD 44 02 00   mov [d + 2], b
0683   083B             ; i++; 
0684   083B FA F5 FF      lea d, [bp + -11] ; $i
0685   083E 2A            mov b, [d]
0686   083F 38 00 00      mov c, 0
0687   0842 11            mov a, b
0688   0843 FD 77         inc b
0689   0845 FA F5 FF      lea d, [bp + -11] ; $i
0690   0848 FD 43         mov [d], b
0691   084A 27            mov b, a
0692   084B 0A AE 07      jmp _while10_cond
0693   084E             _while10_exit:
0694   084E             ; while (i > 0) { 
0695   084E             _while17_cond:
0696   084E FA F5 FF      lea d, [bp + -11] ; $i
0697   0851 2A            mov b, [d]
0698   0852 38 00 00      mov c, 0
0699   0855             ; --- START RELATIONAL
0700   0855 D7            push a
0701   0856 11            mov a, b
0702   0857 FD 2E 00 00   mov32 cb, $00000000
0702   085B 00 00 
0703   085D B0            cmp a, b
0704   085E FD 7F         sgt ; >
0705   0860 E4            pop a
0706   0861             ; --- END RELATIONAL
0707   0861 C0 00 00      cmp b, 0
0708   0864 C6 96 08      je _while17_exit
0709   0867             _while17_block:
0710   0867             ; i--; 
0711   0867 FA F5 FF      lea d, [bp + -11] ; $i
0712   086A 2A            mov b, [d]
0713   086B 38 00 00      mov c, 0
0714   086E 11            mov a, b
0715   086F FD 7D         dec b
0716   0871 FA F5 FF      lea d, [bp + -11] ; $i
0717   0874 FD 43         mov [d], b
0718   0876 27            mov b, a
0719   0877             ; putchar(digits[i]); 
0720   0877             ; --- START FUNCTION CALL
0721   0877 FA F7 FF      lea d, [bp + -9] ; $digits
0722   087A D7            push a
0723   087B DA            push d
0724   087C FA F5 FF      lea d, [bp + -11] ; $i
0725   087F 2A            mov b, [d]
0726   0880 38 00 00      mov c, 0
0727   0883 E7            pop d
0728   0884 5A            add d, b
0729   0885 E4            pop a
0730   0886 32            mov bl, [d]
0731   0887 A7 00         mov bh, 0
0732   0889 38 00 00      mov c, 0
0733   088C DD            push bl
0734   088D 07 98 08      call putchar
0735   0890 51 01 00      add sp, 1
0736   0893             ; --- END FUNCTION CALL
0737   0893 0A 4E 08      jmp _while17_cond
0738   0896             _while17_exit:
0739   0896 F9            leave
0740   0897 09            ret
0741   0898             
0742   0898             putchar:
0743   0898 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0744   089B             ; --- BEGIN INLINE ASM SEGMENT
0745   089B FA 05 00      lea d, [bp + 5] ; $c
0746   089E 1E            mov al, [d]
0747   089F 23            mov ah, al
0748   08A0 19 00         mov al, 0
0749   08A2 05 03         syscall sys_io      ; char in AH
0750   08A4             ; --- END INLINE ASM SEGMENT
0751   08A4 F9            leave
0752   08A5 09            ret
0753   08A6             
0754   08A6             print_unsigned_long:
0755   08A6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0756   08A9             ; char digits[10]; 
0757   08A9 52 0A 00      sub sp, 10
0758   08AC             ; int i; 
0759   08AC 52 02 00      sub sp, 2
0760   08AF             ; i = 0; 
0761   08AF FA F5 FF      lea d, [bp + -11] ; $i
0762   08B2 DA            push d
0763   08B3 FD 2E 00 00   mov32 cb, $00000000
0763   08B7 00 00 
0764   08B9 E7            pop d
0765   08BA FD 43         mov [d], b
0766   08BC             ; if(num == 0){ 
0767   08BC             _if18_cond:
0768   08BC FA 05 00      lea d, [bp + 5] ; $num
0769   08BF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0770   08C2 FD 39         mov c, b ; And place it into C
0771   08C4 2A            mov b, [d] ; Lower Word in B
0772   08C5             ; --- START RELATIONAL
0773   08C5 D7            push a
0774   08C6 FD D8         push g
0775   08C8 11            mov a, b
0776   08C9 FD 7A         mov g, c
0777   08CB FD 2E 00 00   mov32 cb, $00000000
0777   08CF 00 00 
0778   08D1 FD AF         cmp32 ga, cb
0779   08D3 FD 71         seq ; ==
0780   08D5 FD F1         pop g
0781   08D7 E4            pop a
0782   08D8             ; --- END RELATIONAL
0783   08D8 C0 00 00      cmp b, 0
0784   08DB C6 F0 08      je _if18_exit
0785   08DE             _if18_TRUE:
0786   08DE             ; putchar('0'); 
0787   08DE             ; --- START FUNCTION CALL
0788   08DE FD 2E 30 00   mov32 cb, $00000030
0788   08E2 00 00 
0789   08E4 DD            push bl
0790   08E5 07 98 08      call putchar
0791   08E8 51 01 00      add sp, 1
0792   08EB             ; --- END FUNCTION CALL
0793   08EB             ; return; 
0794   08EB F9            leave
0795   08EC 09            ret
0796   08ED 0A F0 08      jmp _if18_exit
0797   08F0             _if18_exit:
0798   08F0             ; while (num > 0) { 
0799   08F0             _while19_cond:
0800   08F0 FA 05 00      lea d, [bp + 5] ; $num
0801   08F3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0802   08F6 FD 39         mov c, b ; And place it into C
0803   08F8 2A            mov b, [d] ; Lower Word in B
0804   08F9             ; --- START RELATIONAL
0805   08F9 D7            push a
0806   08FA FD D8         push g
0807   08FC 11            mov a, b
0808   08FD FD 7A         mov g, c
0809   08FF FD 2E 00 00   mov32 cb, $00000000
0809   0903 00 00 
0810   0905 FD AF         cmp32 ga, cb
0811   0907 FD 81         sgu
0812   0909 FD F1         pop g
0813   090B E4            pop a
0814   090C             ; --- END RELATIONAL
0815   090C C0 00 00      cmp b, 0
0816   090F C6 90 09      je _while19_exit
0817   0912             _while19_block:
0818   0912             ; digits[i] = '0' + (num % 10); 
0819   0912 FA F7 FF      lea d, [bp + -9] ; $digits
0820   0915 D7            push a
0821   0916 DA            push d
0822   0917 FA F5 FF      lea d, [bp + -11] ; $i
0823   091A 2A            mov b, [d]
0824   091B 38 00 00      mov c, 0
0825   091E E7            pop d
0826   091F 5A            add d, b
0827   0920 E4            pop a
0828   0921 DA            push d
0829   0922 FD 2E 30 00   mov32 cb, $00000030
0829   0926 00 00 
0830   0928             ; --- START TERMS
0831   0928 D7            push a
0832   0929 11            mov a, b
0833   092A FA 05 00      lea d, [bp + 5] ; $num
0834   092D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0835   0930 FD 39         mov c, b ; And place it into C
0836   0932 2A            mov b, [d] ; Lower Word in B
0837   0933             ; --- START FACTORS
0838   0933 D7            push a
0839   0934 FD D8         push g
0840   0936 11            mov a, b
0841   0937 FD 7A         mov g, c
0842   0939 FD 2E 0A 00   mov32 cb, $0000000a
0842   093D 00 00 
0843   093F FD D8         push g ; save 'g' as the div instruction uses it
0844   0941 AE            div a, b ; %, a: quotient, b: remainder
0845   0942 11            mov a, b
0846   0943 FD F1         pop g
0847   0945 FD 38         mov c, g
0848   0947 27            mov b, a
0849   0948 FD F1         pop g
0850   094A E4            pop a
0851   094B             ; --- END FACTORS
0852   094B FD 15         add32 cb, ga
0853   094D E4            pop a
0854   094E             ; --- END TERMS
0855   094E E7            pop d
0856   094F FD 3E         mov [d], bl
0857   0951             ; num = num / 10; 
0858   0951 FA 05 00      lea d, [bp + 5] ; $num
0859   0954 DA            push d
0860   0955 FA 05 00      lea d, [bp + 5] ; $num
0861   0958 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0862   095B FD 39         mov c, b ; And place it into C
0863   095D 2A            mov b, [d] ; Lower Word in B
0864   095E             ; --- START FACTORS
0865   095E D7            push a
0866   095F FD D8         push g
0867   0961 11            mov a, b
0868   0962 FD 7A         mov g, c
0869   0964 FD 2E 0A 00   mov32 cb, $0000000a
0869   0968 00 00 
0870   096A FD D8         push g ; save 'g' as the div instruction uses it
0871   096C AE            div a, b ; /, a: quotient, b: remainder
0872   096D FD F1         pop g
0873   096F FD 38         mov c, g
0874   0971 27            mov b, a
0875   0972 FD F1         pop g
0876   0974 E4            pop a
0877   0975             ; --- END FACTORS
0878   0975 E7            pop d
0879   0976 FD 43         mov [d], b
0880   0978 28            mov b, c
0881   0979 FD 44 02 00   mov [d + 2], b
0882   097D             ; i++; 
0883   097D FA F5 FF      lea d, [bp + -11] ; $i
0884   0980 2A            mov b, [d]
0885   0981 38 00 00      mov c, 0
0886   0984 11            mov a, b
0887   0985 FD 77         inc b
0888   0987 FA F5 FF      lea d, [bp + -11] ; $i
0889   098A FD 43         mov [d], b
0890   098C 27            mov b, a
0891   098D 0A F0 08      jmp _while19_cond
0892   0990             _while19_exit:
0893   0990             ; while (i > 0) { 
0894   0990             _while26_cond:
0895   0990 FA F5 FF      lea d, [bp + -11] ; $i
0896   0993 2A            mov b, [d]
0897   0994 38 00 00      mov c, 0
0898   0997             ; --- START RELATIONAL
0899   0997 D7            push a
0900   0998 11            mov a, b
0901   0999 FD 2E 00 00   mov32 cb, $00000000
0901   099D 00 00 
0902   099F B0            cmp a, b
0903   09A0 FD 7F         sgt ; >
0904   09A2 E4            pop a
0905   09A3             ; --- END RELATIONAL
0906   09A3 C0 00 00      cmp b, 0
0907   09A6 C6 D8 09      je _while26_exit
0908   09A9             _while26_block:
0909   09A9             ; i--; 
0910   09A9 FA F5 FF      lea d, [bp + -11] ; $i
0911   09AC 2A            mov b, [d]
0912   09AD 38 00 00      mov c, 0
0913   09B0 11            mov a, b
0914   09B1 FD 7D         dec b
0915   09B3 FA F5 FF      lea d, [bp + -11] ; $i
0916   09B6 FD 43         mov [d], b
0917   09B8 27            mov b, a
0918   09B9             ; putchar(digits[i]); 
0919   09B9             ; --- START FUNCTION CALL
0920   09B9 FA F7 FF      lea d, [bp + -9] ; $digits
0921   09BC D7            push a
0922   09BD DA            push d
0923   09BE FA F5 FF      lea d, [bp + -11] ; $i
0924   09C1 2A            mov b, [d]
0925   09C2 38 00 00      mov c, 0
0926   09C5 E7            pop d
0927   09C6 5A            add d, b
0928   09C7 E4            pop a
0929   09C8 32            mov bl, [d]
0930   09C9 A7 00         mov bh, 0
0931   09CB 38 00 00      mov c, 0
0932   09CE DD            push bl
0933   09CF 07 98 08      call putchar
0934   09D2 51 01 00      add sp, 1
0935   09D5             ; --- END FUNCTION CALL
0936   09D5 0A 90 09      jmp _while26_cond
0937   09D8             _while26_exit:
0938   09D8 F9            leave
0939   09D9 09            ret
0940   09DA             
0941   09DA             printx32:
0942   09DA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0943   09DD             ; --- BEGIN INLINE ASM SEGMENT
0944   09DD FA 05 00      lea d, [bp + 5] ; $hex
0945   09E0 2B 02 00      mov b, [d+2]
0946   09E3 07 EC 09      call print_u16x_printx32
0947   09E6 2A            mov b, [d]
0948   09E7 07 EC 09      call print_u16x_printx32
0949   09EA             ; --- END INLINE ASM SEGMENT
0950   09EA             ; return; 
0951   09EA F9            leave
0952   09EB 09            ret
0953   09EC             ; --- BEGIN INLINE ASM SEGMENT
0954   09EC             print_u16x_printx32:
0955   09EC D7            push a
0956   09ED D8            push b
0957   09EE DD            push bl
0958   09EF 30            mov bl, bh
0959   09F0 07 0E 0A      call _itoa_printx32        ; convert bh to char in A
0960   09F3 2F            mov bl, al        ; save al
0961   09F4 19 00         mov al, 0
0962   09F6 05 03         syscall sys_io        ; display AH
0963   09F8 24            mov ah, bl        ; retrieve al
0964   09F9 19 00         mov al, 0
0965   09FB 05 03         syscall sys_io        ; display AL
0966   09FD EA            pop bl
0967   09FE 07 0E 0A      call _itoa_printx32        ; convert bh to char in A
0968   0A01 2F            mov bl, al        ; save al
0969   0A02 19 00         mov al, 0
0970   0A04 05 03         syscall sys_io        ; display AH
0971   0A06 24            mov ah, bl        ; retrieve al
0972   0A07 19 00         mov al, 0
0973   0A09 05 03         syscall sys_io        ; display AL
0974   0A0B E5            pop b
0975   0A0C E4            pop a
0976   0A0D 09            ret
0977   0A0E             _itoa_printx32:
0978   0A0E DA            push d
0979   0A0F D8            push b
0980   0A10 A7 00         mov bh, 0
0981   0A12 FD A4 04      shr bl, 4  
0982   0A15 74            mov d, b
0983   0A16 1F 28 0A      mov al, [d + s_hex_digits_printx32]
0984   0A19 23            mov ah, al
0985   0A1A E5            pop b
0986   0A1B D8            push b
0987   0A1C A7 00         mov bh, 0
0988   0A1E FD 87 0F      and bl, $0F
0989   0A21 74            mov d, b
0990   0A22 1F 28 0A      mov al, [d + s_hex_digits_printx32]
0991   0A25 E5            pop b
0992   0A26 E7            pop d
0993   0A27 09            ret
0994   0A28 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
0994   0A2C 34 35 36 37 
0994   0A30 38 39 41 42 
0994   0A34 43 44 45 46 
0995   0A38             ; --- END INLINE ASM SEGMENT
0996   0A38 F9            leave
0997   0A39 09            ret
0998   0A3A             
0999   0A3A             err:
1000   0A3A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1001   0A3D             ; print(e); 
1002   0A3D             ; --- START FUNCTION CALL
1003   0A3D FA 05 00      lea d, [bp + 5] ; $e
1004   0A40 2A            mov b, [d]
1005   0A41 38 00 00      mov c, 0
1006   0A44 FD AB         swp b
1007   0A46 D8            push b
1008   0A47 07 4F 0A      call print
1009   0A4A 51 02 00      add sp, 2
1010   0A4D             ; --- END FUNCTION CALL
1011   0A4D F9            leave
1012   0A4E 09            ret
1013   0A4F             
1014   0A4F             print:
1015   0A4F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1016   0A52             ; --- BEGIN INLINE ASM SEGMENT
1017   0A52 FA 05 00      lea d, [bp + 5] ; $s
1018   0A55 FD 2A         mov d, [d]
1019   0A57             _puts_L1_print:
1020   0A57 1E            mov al, [d]
1021   0A58 B9 00         cmp al, 0
1022   0A5A C6 66 0A      jz _puts_END_print
1023   0A5D 23            mov ah, al
1024   0A5E 19 00         mov al, 0
1025   0A60 05 03         syscall sys_io
1026   0A62 79            inc d
1027   0A63 0A 57 0A      jmp _puts_L1_print
1028   0A66             _puts_END_print:
1029   0A66             ; --- END INLINE ASM SEGMENT
1030   0A66 F9            leave
1031   0A67 09            ret
1032   0A68             
1033   0A68             print_signed:
1034   0A68 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1035   0A6B             ; char digits[5]; 
1036   0A6B 52 05 00      sub sp, 5
1037   0A6E             ; int i = 0; 
1038   0A6E 52 02 00      sub sp, 2
1039   0A71             ; --- START LOCAL VAR INITIALIZATION
1040   0A71 FA FA FF      lea d, [bp + -6] ; $i
1041   0A74 DA            push d
1042   0A75 FD 2E 00 00   mov32 cb, $00000000
1042   0A79 00 00 
1043   0A7B E7            pop d
1044   0A7C FD 43         mov [d], b
1045   0A7E             ; --- END LOCAL VAR INITIALIZATION
1046   0A7E             ; if (num < 0) { 
1047   0A7E             _if27_cond:
1048   0A7E FA 05 00      lea d, [bp + 5] ; $num
1049   0A81 2A            mov b, [d]
1050   0A82 38 00 00      mov c, 0
1051   0A85             ; --- START RELATIONAL
1052   0A85 D7            push a
1053   0A86 11            mov a, b
1054   0A87 FD 2E 00 00   mov32 cb, $00000000
1054   0A8B 00 00 
1055   0A8D B0            cmp a, b
1056   0A8E FD 73         slt ; < (signed)
1057   0A90 E4            pop a
1058   0A91             ; --- END RELATIONAL
1059   0A91 C0 00 00      cmp b, 0
1060   0A94 C6 B7 0A      je _if27_else
1061   0A97             _if27_TRUE:
1062   0A97             ; putchar('-'); 
1063   0A97             ; --- START FUNCTION CALL
1064   0A97 FD 2E 2D 00   mov32 cb, $0000002d
1064   0A9B 00 00 
1065   0A9D DD            push bl
1066   0A9E 07 98 08      call putchar
1067   0AA1 51 01 00      add sp, 1
1068   0AA4             ; --- END FUNCTION CALL
1069   0AA4             ; num = -num; 
1070   0AA4 FA 05 00      lea d, [bp + 5] ; $num
1071   0AA7 DA            push d
1072   0AA8 FA 05 00      lea d, [bp + 5] ; $num
1073   0AAB 2A            mov b, [d]
1074   0AAC 38 00 00      mov c, 0
1075   0AAF FD 97         neg b
1076   0AB1 E7            pop d
1077   0AB2 FD 43         mov [d], b
1078   0AB4 0A E2 0A      jmp _if27_exit
1079   0AB7             _if27_else:
1080   0AB7             ; if (num == 0) { 
1081   0AB7             _if28_cond:
1082   0AB7 FA 05 00      lea d, [bp + 5] ; $num
1083   0ABA 2A            mov b, [d]
1084   0ABB 38 00 00      mov c, 0
1085   0ABE             ; --- START RELATIONAL
1086   0ABE D7            push a
1087   0ABF 11            mov a, b
1088   0AC0 FD 2E 00 00   mov32 cb, $00000000
1088   0AC4 00 00 
1089   0AC6 B0            cmp a, b
1090   0AC7 FD 71         seq ; ==
1091   0AC9 E4            pop a
1092   0ACA             ; --- END RELATIONAL
1093   0ACA C0 00 00      cmp b, 0
1094   0ACD C6 E2 0A      je _if28_exit
1095   0AD0             _if28_TRUE:
1096   0AD0             ; putchar('0'); 
1097   0AD0             ; --- START FUNCTION CALL
1098   0AD0 FD 2E 30 00   mov32 cb, $00000030
1098   0AD4 00 00 
1099   0AD6 DD            push bl
1100   0AD7 07 98 08      call putchar
1101   0ADA 51 01 00      add sp, 1
1102   0ADD             ; --- END FUNCTION CALL
1103   0ADD             ; return; 
1104   0ADD F9            leave
1105   0ADE 09            ret
1106   0ADF 0A E2 0A      jmp _if28_exit
1107   0AE2             _if28_exit:
1108   0AE2             _if27_exit:
1109   0AE2             ; while (num > 0) { 
1110   0AE2             _while29_cond:
1111   0AE2 FA 05 00      lea d, [bp + 5] ; $num
1112   0AE5 2A            mov b, [d]
1113   0AE6 38 00 00      mov c, 0
1114   0AE9             ; --- START RELATIONAL
1115   0AE9 D7            push a
1116   0AEA 11            mov a, b
1117   0AEB FD 2E 00 00   mov32 cb, $00000000
1117   0AEF 00 00 
1118   0AF1 B0            cmp a, b
1119   0AF2 FD 7F         sgt ; >
1120   0AF4 E4            pop a
1121   0AF5             ; --- END RELATIONAL
1122   0AF5 C0 00 00      cmp b, 0
1123   0AF8 C6 6F 0B      je _while29_exit
1124   0AFB             _while29_block:
1125   0AFB             ; digits[i] = '0' + (num % 10); 
1126   0AFB FA FC FF      lea d, [bp + -4] ; $digits
1127   0AFE D7            push a
1128   0AFF DA            push d
1129   0B00 FA FA FF      lea d, [bp + -6] ; $i
1130   0B03 2A            mov b, [d]
1131   0B04 38 00 00      mov c, 0
1132   0B07 E7            pop d
1133   0B08 5A            add d, b
1134   0B09 E4            pop a
1135   0B0A DA            push d
1136   0B0B FD 2E 30 00   mov32 cb, $00000030
1136   0B0F 00 00 
1137   0B11             ; --- START TERMS
1138   0B11 D7            push a
1139   0B12 11            mov a, b
1140   0B13 FA 05 00      lea d, [bp + 5] ; $num
1141   0B16 2A            mov b, [d]
1142   0B17 38 00 00      mov c, 0
1143   0B1A             ; --- START FACTORS
1144   0B1A D7            push a
1145   0B1B FD D8         push g
1146   0B1D 11            mov a, b
1147   0B1E FD 7A         mov g, c
1148   0B20 FD 2E 0A 00   mov32 cb, $0000000a
1148   0B24 00 00 
1149   0B26 FD D8         push g ; save 'g' as the div instruction uses it
1150   0B28 AE            div a, b ; %, a: quotient, b: remainder
1151   0B29 11            mov a, b
1152   0B2A FD F1         pop g
1153   0B2C FD 38         mov c, g
1154   0B2E 27            mov b, a
1155   0B2F FD F1         pop g
1156   0B31 E4            pop a
1157   0B32             ; --- END FACTORS
1158   0B32 56            add b, a
1159   0B33 E4            pop a
1160   0B34             ; --- END TERMS
1161   0B34 E7            pop d
1162   0B35 FD 3E         mov [d], bl
1163   0B37             ; num = num / 10; 
1164   0B37 FA 05 00      lea d, [bp + 5] ; $num
1165   0B3A DA            push d
1166   0B3B FA 05 00      lea d, [bp + 5] ; $num
1167   0B3E 2A            mov b, [d]
1168   0B3F 38 00 00      mov c, 0
1169   0B42             ; --- START FACTORS
1170   0B42 D7            push a
1171   0B43 FD D8         push g
1172   0B45 11            mov a, b
1173   0B46 FD 7A         mov g, c
1174   0B48 FD 2E 0A 00   mov32 cb, $0000000a
1174   0B4C 00 00 
1175   0B4E FD D8         push g ; save 'g' as the div instruction uses it
1176   0B50 AE            div a, b ; /, a: quotient, b: remainder
1177   0B51 FD F1         pop g
1178   0B53 FD 38         mov c, g
1179   0B55 27            mov b, a
1180   0B56 FD F1         pop g
1181   0B58 E4            pop a
1182   0B59             ; --- END FACTORS
1183   0B59 E7            pop d
1184   0B5A FD 43         mov [d], b
1185   0B5C             ; i++; 
1186   0B5C FA FA FF      lea d, [bp + -6] ; $i
1187   0B5F 2A            mov b, [d]
1188   0B60 38 00 00      mov c, 0
1189   0B63 11            mov a, b
1190   0B64 FD 77         inc b
1191   0B66 FA FA FF      lea d, [bp + -6] ; $i
1192   0B69 FD 43         mov [d], b
1193   0B6B 27            mov b, a
1194   0B6C 0A E2 0A      jmp _while29_cond
1195   0B6F             _while29_exit:
1196   0B6F             ; while (i > 0) { 
1197   0B6F             _while36_cond:
1198   0B6F FA FA FF      lea d, [bp + -6] ; $i
1199   0B72 2A            mov b, [d]
1200   0B73 38 00 00      mov c, 0
1201   0B76             ; --- START RELATIONAL
1202   0B76 D7            push a
1203   0B77 11            mov a, b
1204   0B78 FD 2E 00 00   mov32 cb, $00000000
1204   0B7C 00 00 
1205   0B7E B0            cmp a, b
1206   0B7F FD 7F         sgt ; >
1207   0B81 E4            pop a
1208   0B82             ; --- END RELATIONAL
1209   0B82 C0 00 00      cmp b, 0
1210   0B85 C6 B7 0B      je _while36_exit
1211   0B88             _while36_block:
1212   0B88             ; i--; 
1213   0B88 FA FA FF      lea d, [bp + -6] ; $i
1214   0B8B 2A            mov b, [d]
1215   0B8C 38 00 00      mov c, 0
1216   0B8F 11            mov a, b
1217   0B90 FD 7D         dec b
1218   0B92 FA FA FF      lea d, [bp + -6] ; $i
1219   0B95 FD 43         mov [d], b
1220   0B97 27            mov b, a
1221   0B98             ; putchar(digits[i]); 
1222   0B98             ; --- START FUNCTION CALL
1223   0B98 FA FC FF      lea d, [bp + -4] ; $digits
1224   0B9B D7            push a
1225   0B9C DA            push d
1226   0B9D FA FA FF      lea d, [bp + -6] ; $i
1227   0BA0 2A            mov b, [d]
1228   0BA1 38 00 00      mov c, 0
1229   0BA4 E7            pop d
1230   0BA5 5A            add d, b
1231   0BA6 E4            pop a
1232   0BA7 32            mov bl, [d]
1233   0BA8 A7 00         mov bh, 0
1234   0BAA 38 00 00      mov c, 0
1235   0BAD DD            push bl
1236   0BAE 07 98 08      call putchar
1237   0BB1 51 01 00      add sp, 1
1238   0BB4             ; --- END FUNCTION CALL
1239   0BB4 0A 6F 0B      jmp _while36_cond
1240   0BB7             _while36_exit:
1241   0BB7 F9            leave
1242   0BB8 09            ret
1243   0BB9             
1244   0BB9             print_unsigned:
1245   0BB9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1246   0BBC             ; char digits[5]; 
1247   0BBC 52 05 00      sub sp, 5
1248   0BBF             ; int i; 
1249   0BBF 52 02 00      sub sp, 2
1250   0BC2             ; i = 0; 
1251   0BC2 FA FA FF      lea d, [bp + -6] ; $i
1252   0BC5 DA            push d
1253   0BC6 FD 2E 00 00   mov32 cb, $00000000
1253   0BCA 00 00 
1254   0BCC E7            pop d
1255   0BCD FD 43         mov [d], b
1256   0BCF             ; if(num == 0){ 
1257   0BCF             _if37_cond:
1258   0BCF FA 05 00      lea d, [bp + 5] ; $num
1259   0BD2 2A            mov b, [d]
1260   0BD3 38 00 00      mov c, 0
1261   0BD6             ; --- START RELATIONAL
1262   0BD6 D7            push a
1263   0BD7 11            mov a, b
1264   0BD8 FD 2E 00 00   mov32 cb, $00000000
1264   0BDC 00 00 
1265   0BDE B0            cmp a, b
1266   0BDF FD 71         seq ; ==
1267   0BE1 E4            pop a
1268   0BE2             ; --- END RELATIONAL
1269   0BE2 C0 00 00      cmp b, 0
1270   0BE5 C6 FA 0B      je _if37_exit
1271   0BE8             _if37_TRUE:
1272   0BE8             ; putchar('0'); 
1273   0BE8             ; --- START FUNCTION CALL
1274   0BE8 FD 2E 30 00   mov32 cb, $00000030
1274   0BEC 00 00 
1275   0BEE DD            push bl
1276   0BEF 07 98 08      call putchar
1277   0BF2 51 01 00      add sp, 1
1278   0BF5             ; --- END FUNCTION CALL
1279   0BF5             ; return; 
1280   0BF5 F9            leave
1281   0BF6 09            ret
1282   0BF7 0A FA 0B      jmp _if37_exit
1283   0BFA             _if37_exit:
1284   0BFA             ; while (num > 0) { 
1285   0BFA             _while38_cond:
1286   0BFA FA 05 00      lea d, [bp + 5] ; $num
1287   0BFD 2A            mov b, [d]
1288   0BFE 38 00 00      mov c, 0
1289   0C01             ; --- START RELATIONAL
1290   0C01 D7            push a
1291   0C02 11            mov a, b
1292   0C03 FD 2E 00 00   mov32 cb, $00000000
1292   0C07 00 00 
1293   0C09 B0            cmp a, b
1294   0C0A FD 81         sgu ; > (unsigned)
1295   0C0C E4            pop a
1296   0C0D             ; --- END RELATIONAL
1297   0C0D C0 00 00      cmp b, 0
1298   0C10 C6 87 0C      je _while38_exit
1299   0C13             _while38_block:
1300   0C13             ; digits[i] = '0' + (num % 10); 
1301   0C13 FA FC FF      lea d, [bp + -4] ; $digits
1302   0C16 D7            push a
1303   0C17 DA            push d
1304   0C18 FA FA FF      lea d, [bp + -6] ; $i
1305   0C1B 2A            mov b, [d]
1306   0C1C 38 00 00      mov c, 0
1307   0C1F E7            pop d
1308   0C20 5A            add d, b
1309   0C21 E4            pop a
1310   0C22 DA            push d
1311   0C23 FD 2E 30 00   mov32 cb, $00000030
1311   0C27 00 00 
1312   0C29             ; --- START TERMS
1313   0C29 D7            push a
1314   0C2A 11            mov a, b
1315   0C2B FA 05 00      lea d, [bp + 5] ; $num
1316   0C2E 2A            mov b, [d]
1317   0C2F 38 00 00      mov c, 0
1318   0C32             ; --- START FACTORS
1319   0C32 D7            push a
1320   0C33 FD D8         push g
1321   0C35 11            mov a, b
1322   0C36 FD 7A         mov g, c
1323   0C38 FD 2E 0A 00   mov32 cb, $0000000a
1323   0C3C 00 00 
1324   0C3E FD D8         push g ; save 'g' as the div instruction uses it
1325   0C40 AE            div a, b ; %, a: quotient, b: remainder
1326   0C41 11            mov a, b
1327   0C42 FD F1         pop g
1328   0C44 FD 38         mov c, g
1329   0C46 27            mov b, a
1330   0C47 FD F1         pop g
1331   0C49 E4            pop a
1332   0C4A             ; --- END FACTORS
1333   0C4A 56            add b, a
1334   0C4B E4            pop a
1335   0C4C             ; --- END TERMS
1336   0C4C E7            pop d
1337   0C4D FD 3E         mov [d], bl
1338   0C4F             ; num = num / 10; 
1339   0C4F FA 05 00      lea d, [bp + 5] ; $num
1340   0C52 DA            push d
1341   0C53 FA 05 00      lea d, [bp + 5] ; $num
1342   0C56 2A            mov b, [d]
1343   0C57 38 00 00      mov c, 0
1344   0C5A             ; --- START FACTORS
1345   0C5A D7            push a
1346   0C5B FD D8         push g
1347   0C5D 11            mov a, b
1348   0C5E FD 7A         mov g, c
1349   0C60 FD 2E 0A 00   mov32 cb, $0000000a
1349   0C64 00 00 
1350   0C66 FD D8         push g ; save 'g' as the div instruction uses it
1351   0C68 AE            div a, b ; /, a: quotient, b: remainder
1352   0C69 FD F1         pop g
1353   0C6B FD 38         mov c, g
1354   0C6D 27            mov b, a
1355   0C6E FD F1         pop g
1356   0C70 E4            pop a
1357   0C71             ; --- END FACTORS
1358   0C71 E7            pop d
1359   0C72 FD 43         mov [d], b
1360   0C74             ; i++; 
1361   0C74 FA FA FF      lea d, [bp + -6] ; $i
1362   0C77 2A            mov b, [d]
1363   0C78 38 00 00      mov c, 0
1364   0C7B 11            mov a, b
1365   0C7C FD 77         inc b
1366   0C7E FA FA FF      lea d, [bp + -6] ; $i
1367   0C81 FD 43         mov [d], b
1368   0C83 27            mov b, a
1369   0C84 0A FA 0B      jmp _while38_cond
1370   0C87             _while38_exit:
1371   0C87             ; while (i > 0) { 
1372   0C87             _while45_cond:
1373   0C87 FA FA FF      lea d, [bp + -6] ; $i
1374   0C8A 2A            mov b, [d]
1375   0C8B 38 00 00      mov c, 0
1376   0C8E             ; --- START RELATIONAL
1377   0C8E D7            push a
1378   0C8F 11            mov a, b
1379   0C90 FD 2E 00 00   mov32 cb, $00000000
1379   0C94 00 00 
1380   0C96 B0            cmp a, b
1381   0C97 FD 7F         sgt ; >
1382   0C99 E4            pop a
1383   0C9A             ; --- END RELATIONAL
1384   0C9A C0 00 00      cmp b, 0
1385   0C9D C6 CF 0C      je _while45_exit
1386   0CA0             _while45_block:
1387   0CA0             ; i--; 
1388   0CA0 FA FA FF      lea d, [bp + -6] ; $i
1389   0CA3 2A            mov b, [d]
1390   0CA4 38 00 00      mov c, 0
1391   0CA7 11            mov a, b
1392   0CA8 FD 7D         dec b
1393   0CAA FA FA FF      lea d, [bp + -6] ; $i
1394   0CAD FD 43         mov [d], b
1395   0CAF 27            mov b, a
1396   0CB0             ; putchar(digits[i]); 
1397   0CB0             ; --- START FUNCTION CALL
1398   0CB0 FA FC FF      lea d, [bp + -4] ; $digits
1399   0CB3 D7            push a
1400   0CB4 DA            push d
1401   0CB5 FA FA FF      lea d, [bp + -6] ; $i
1402   0CB8 2A            mov b, [d]
1403   0CB9 38 00 00      mov c, 0
1404   0CBC E7            pop d
1405   0CBD 5A            add d, b
1406   0CBE E4            pop a
1407   0CBF 32            mov bl, [d]
1408   0CC0 A7 00         mov bh, 0
1409   0CC2 38 00 00      mov c, 0
1410   0CC5 DD            push bl
1411   0CC6 07 98 08      call putchar
1412   0CC9 51 01 00      add sp, 1
1413   0CCC             ; --- END FUNCTION CALL
1414   0CCC 0A 87 0C      jmp _while45_cond
1415   0CCF             _while45_exit:
1416   0CCF F9            leave
1417   0CD0 09            ret
1418   0CD1             
1419   0CD1             printx16:
1420   0CD1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1421   0CD4             ; --- BEGIN INLINE ASM SEGMENT
1422   0CD4 FA 05 00      lea d, [bp + 5] ; $hex
1423   0CD7 2A            mov b, [d]
1424   0CD8             print_u16x_printx16:
1425   0CD8 DD            push bl
1426   0CD9 30            mov bl, bh
1427   0CDA 07 F7 0C      call _itoa_printx16        ; convert bh to char in A
1428   0CDD 2F            mov bl, al        ; save al
1429   0CDE 19 00         mov al, 0
1430   0CE0 05 03         syscall sys_io        ; display AH
1431   0CE2 24            mov ah, bl        ; retrieve al
1432   0CE3 19 00         mov al, 0
1433   0CE5 05 03         syscall sys_io        ; display AL
1434   0CE7 EA            pop bl
1435   0CE8 07 F7 0C      call _itoa_printx16        ; convert bh to char in A
1436   0CEB 2F            mov bl, al        ; save al
1437   0CEC 19 00         mov al, 0
1438   0CEE 05 03         syscall sys_io        ; display AH
1439   0CF0 24            mov ah, bl        ; retrieve al
1440   0CF1 19 00         mov al, 0
1441   0CF3 05 03         syscall sys_io        ; display AL
1442   0CF5             ; --- END INLINE ASM SEGMENT
1443   0CF5             ; return; 
1444   0CF5 F9            leave
1445   0CF6 09            ret
1446   0CF7             ; --- BEGIN INLINE ASM SEGMENT
1447   0CF7             _itoa_printx16:
1448   0CF7 DA            push d
1449   0CF8 D8            push b
1450   0CF9 A7 00         mov bh, 0
1451   0CFB FD A4 04      shr bl, 4  
1452   0CFE 74            mov d, b
1453   0CFF 1F 11 0D      mov al, [d + s_hex_digits_printx16]
1454   0D02 23            mov ah, al
1455   0D03 E5            pop b
1456   0D04 D8            push b
1457   0D05 A7 00         mov bh, 0
1458   0D07 FD 87 0F      and bl, $0F
1459   0D0A 74            mov d, b
1460   0D0B 1F 11 0D      mov al, [d + s_hex_digits_printx16]
1461   0D0E E5            pop b
1462   0D0F E7            pop d
1463   0D10 09            ret
1464   0D11 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1464   0D15 34 35 36 37 
1464   0D19 38 39 41 42 
1464   0D1D 43 44 45 46 
1465   0D21             ; --- END INLINE ASM SEGMENT
1466   0D21 F9            leave
1467   0D22 09            ret
1468   0D23             ; --- END TEXT SEGMENT
1469   0D23             
1470   0D23             ; --- BEGIN DATA SEGMENT
1471   0D23 02 00       _a: .dw $0002
1472   0D25 48 65 6C 6C _s0: .db "Hello WorldMy name is Sol-1And this is a multi-line string", 0
1472   0D29 6F 20 57 6F 
1472   0D2D 72 6C 64 4D 
1472   0D31 79 20 6E 61 
1472   0D35 6D 65 20 69 
1472   0D39 73 20 53 6F 
1472   0D3D 6C 2D 31 41 
1472   0D41 6E 64 20 74 
1472   0D45 68 69 73 20 
1472   0D49 69 73 20 61 
1472   0D4D 20 6D 75 6C 
1472   0D51 74 69 2D 6C 
1472   0D55 69 6E 65 20 
1472   0D59 73 74 72 69 
1472   0D5D 6E 67 00 
1473   0D60 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1473   0D64 70 65 63 74 
1473   0D68 65 64 20 66 
1473   0D6C 6F 72 6D 61 
1473   0D70 74 20 69 6E 
1473   0D74 20 70 72 69 
1473   0D78 6E 74 66 2E 
1473   0D7C 00 
1474   0D7D 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1474   0D81 72 3A 20 55 
1474   0D85 6E 6B 6E 6F 
1474   0D89 77 6E 20 61 
1474   0D8D 72 67 75 6D 
1474   0D91 65 6E 74 20 
1474   0D95 74 79 70 65 
1474   0D99 2E 0A 00 
1475   0D9C             
1476   0D9C 9E 0D       _heap_top: .dw _heap
1477   0D9E 00          _heap: .db 0
1478   0D9F             ; --- END DATA SEGMENT
1479   0D9F             
1480   0D9F             .end
tasm: Number of errors = 0
