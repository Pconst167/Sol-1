0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $s 
0011   0408 52 A6 04      sub sp, 1190
0012   040B             ;; s[0].a[0] = 'A'; 
0013   040B FA 5B FB      lea d, [bp + -1189] ; $s
0014   040E D7            push a
0015   040F DA            push d
0016   0410 26 00 00      mov b, $0
0017   0413 E7            pop d
0018   0414 FD 13 EE 00   mma 238 ; mov a, 238; mul a, b; add d, b
0019   0418 E4            pop a
0020   0419 58 00 00      add d, 0
0021   041C FD 14         clb
0022   041E D7            push a
0023   041F DA            push d
0024   0420 26 00 00      mov b, $0
0025   0423 E7            pop d
0026   0424 5A            add d, b
0027   0425 E4            pop a
0028   0426 DA            push d
0029   0427 26 41 00      mov b, $41
0030   042A E7            pop d
0031   042B FD 3E         mov [d], bl
0032   042D             ;; s[1].a[1] = 'B'; 
0033   042D FA 5B FB      lea d, [bp + -1189] ; $s
0034   0430 D7            push a
0035   0431 DA            push d
0036   0432 26 01 00      mov b, $1
0037   0435 E7            pop d
0038   0436 FD 13 EE 00   mma 238 ; mov a, 238; mul a, b; add d, b
0039   043A E4            pop a
0040   043B 58 00 00      add d, 0
0041   043E FD 14         clb
0042   0440 D7            push a
0043   0441 DA            push d
0044   0442 26 01 00      mov b, $1
0045   0445 E7            pop d
0046   0446 5A            add d, b
0047   0447 E4            pop a
0048   0448 DA            push d
0049   0449 26 42 00      mov b, $42
0050   044C E7            pop d
0051   044D FD 3E         mov [d], bl
0052   044F             ;; s[2].ss[1].a[1] = 'Z'; 
0053   044F FA 5B FB      lea d, [bp + -1189] ; $s
0054   0452 D7            push a
0055   0453 DA            push d
0056   0454 26 02 00      mov b, $2
0057   0457 E7            pop d
0058   0458 FD 13 EE 00   mma 238 ; mov a, 238; mul a, b; add d, b
0059   045C E4            pop a
0060   045D 58 0A 00      add d, 10
0061   0460 FD 14         clb
0062   0462 D7            push a
0063   0463 DA            push d
0064   0464 26 01 00      mov b, $1
0065   0467 E7            pop d
0066   0468 FD 13 25 00   mma 37 ; mov a, 37; mul a, b; add d, b
0067   046C E4            pop a
0068   046D 58 00 00      add d, 0
0069   0470 FD 14         clb
0070   0472 D7            push a
0071   0473 DA            push d
0072   0474 26 01 00      mov b, $1
0073   0477 E7            pop d
0074   0478 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0075   047C E4            pop a
0076   047D DA            push d
0077   047E 26 5A 00      mov b, $5a
0078   0481 E7            pop d
0079   0482 FD 43         mov [d], b
0080   0484             ;; s[3].sss[1].c[2]='H'; 
0081   0484 FA 5B FB      lea d, [bp + -1189] ; $s
0082   0487 D7            push a
0083   0488 DA            push d
0084   0489 26 03 00      mov b, $3
0085   048C E7            pop d
0086   048D FD 13 EE 00   mma 238 ; mov a, 238; mul a, b; add d, b
0087   0491 E4            pop a
0088   0492 58 79 00      add d, 121
0089   0495 FD 14         clb
0090   0497 D7            push a
0091   0498 DA            push d
0092   0499 26 01 00      mov b, $1
0093   049C E7            pop d
0094   049D FD 13 25 00   mma 37 ; mov a, 37; mul a, b; add d, b
0095   04A1 E4            pop a
0096   04A2 58 04 00      add d, 4
0097   04A5 FD 14         clb
0098   04A7 D7            push a
0099   04A8 DA            push d
0100   04A9 26 02 00      mov b, $2
0101   04AC E7            pop d
0102   04AD 5A            add d, b
0103   04AE E4            pop a
0104   04AF DA            push d
0105   04B0 26 48 00      mov b, $48
0106   04B3 E7            pop d
0107   04B4 FD 3E         mov [d], bl
0108   04B6             ;; s[0].b[2]=123; 
0109   04B6 FA 5B FB      lea d, [bp + -1189] ; $s
0110   04B9 D7            push a
0111   04BA DA            push d
0112   04BB 26 00 00      mov b, $0
0113   04BE E7            pop d
0114   04BF FD 13 EE 00   mma 238 ; mov a, 238; mul a, b; add d, b
0115   04C3 E4            pop a
0116   04C4 58 E8 00      add d, 232
0117   04C7 FD 14         clb
0118   04C9 D7            push a
0119   04CA DA            push d
0120   04CB 26 02 00      mov b, $2
0121   04CE E7            pop d
0122   04CF FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0123   04D3 E4            pop a
0124   04D4 DA            push d
0125   04D5 26 7B 00      mov b, $7b
0126   04D8 E7            pop d
0127   04D9 FD 43         mov [d], b
0128   04DB             ;; printf("%c\n", s[0].a[0]); 
0129   04DB FA 5B FB      lea d, [bp + -1189] ; $s
0130   04DE D7            push a
0131   04DF DA            push d
0132   04E0 26 00 00      mov b, $0
0133   04E3 E7            pop d
0134   04E4 FD 13 EE 00   mma 238 ; mov a, 238; mul a, b; add d, b
0135   04E8 E4            pop a
0136   04E9 58 00 00      add d, 0
0137   04EC FD 14         clb
0138   04EE D7            push a
0139   04EF DA            push d
0140   04F0 26 00 00      mov b, $0
0141   04F3 E7            pop d
0142   04F4 5A            add d, b
0143   04F5 E4            pop a
0144   04F6 32            mov bl, [d]
0145   04F7 A7 00         mov bh, 0
0146   04F9 FD AB         swp b
0147   04FB D8            push b
0148   04FC 26 BE 12      mov b, __s0 ; "%c\n"
0149   04FF FD AB         swp b
0150   0501 D8            push b
0151   0502 07 A5 07      call printf
0152   0505 51 04 00      add sp, 4
0153   0508             ;; printf("%c\n", s[1].a[1]); 
0154   0508 FA 5B FB      lea d, [bp + -1189] ; $s
0155   050B D7            push a
0156   050C DA            push d
0157   050D 26 01 00      mov b, $1
0158   0510 E7            pop d
0159   0511 FD 13 EE 00   mma 238 ; mov a, 238; mul a, b; add d, b
0160   0515 E4            pop a
0161   0516 58 00 00      add d, 0
0162   0519 FD 14         clb
0163   051B D7            push a
0164   051C DA            push d
0165   051D 26 01 00      mov b, $1
0166   0520 E7            pop d
0167   0521 5A            add d, b
0168   0522 E4            pop a
0169   0523 32            mov bl, [d]
0170   0524 A7 00         mov bh, 0
0171   0526 FD AB         swp b
0172   0528 D8            push b
0173   0529 26 BE 12      mov b, __s0 ; "%c\n"
0174   052C FD AB         swp b
0175   052E D8            push b
0176   052F 07 A5 07      call printf
0177   0532 51 04 00      add sp, 4
0178   0535             ;; printf("%c\n", s[2].ss[1].a[1]); 
0179   0535 FA 5B FB      lea d, [bp + -1189] ; $s
0180   0538 D7            push a
0181   0539 DA            push d
0182   053A 26 02 00      mov b, $2
0183   053D E7            pop d
0184   053E FD 13 EE 00   mma 238 ; mov a, 238; mul a, b; add d, b
0185   0542 E4            pop a
0186   0543 58 0A 00      add d, 10
0187   0546 FD 14         clb
0188   0548 D7            push a
0189   0549 DA            push d
0190   054A 26 01 00      mov b, $1
0191   054D E7            pop d
0192   054E FD 13 25 00   mma 37 ; mov a, 37; mul a, b; add d, b
0193   0552 E4            pop a
0194   0553 58 00 00      add d, 0
0195   0556 FD 14         clb
0196   0558 D7            push a
0197   0559 DA            push d
0198   055A 26 01 00      mov b, $1
0199   055D E7            pop d
0200   055E FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0201   0562 E4            pop a
0202   0563 2A            mov b, [d]
0203   0564 FD AB         swp b
0204   0566 D8            push b
0205   0567 26 BE 12      mov b, __s0 ; "%c\n"
0206   056A FD AB         swp b
0207   056C D8            push b
0208   056D 07 A5 07      call printf
0209   0570 51 04 00      add sp, 4
0210   0573             ;; printf("%c\n", s[3].sss[1].c[2]); 
0211   0573 FA 5B FB      lea d, [bp + -1189] ; $s
0212   0576 D7            push a
0213   0577 DA            push d
0214   0578 26 03 00      mov b, $3
0215   057B E7            pop d
0216   057C FD 13 EE 00   mma 238 ; mov a, 238; mul a, b; add d, b
0217   0580 E4            pop a
0218   0581 58 79 00      add d, 121
0219   0584 FD 14         clb
0220   0586 D7            push a
0221   0587 DA            push d
0222   0588 26 01 00      mov b, $1
0223   058B E7            pop d
0224   058C FD 13 25 00   mma 37 ; mov a, 37; mul a, b; add d, b
0225   0590 E4            pop a
0226   0591 58 04 00      add d, 4
0227   0594 FD 14         clb
0228   0596 D7            push a
0229   0597 DA            push d
0230   0598 26 02 00      mov b, $2
0231   059B E7            pop d
0232   059C 5A            add d, b
0233   059D E4            pop a
0234   059E 32            mov bl, [d]
0235   059F A7 00         mov bh, 0
0236   05A1 FD AB         swp b
0237   05A3 D8            push b
0238   05A4 26 BE 12      mov b, __s0 ; "%c\n"
0239   05A7 FD AB         swp b
0240   05A9 D8            push b
0241   05AA 07 A5 07      call printf
0242   05AD 51 04 00      add sp, 4
0243   05B0             ;; printf("%d\n", s[0].b[2]); 
0244   05B0 FA 5B FB      lea d, [bp + -1189] ; $s
0245   05B3 D7            push a
0246   05B4 DA            push d
0247   05B5 26 00 00      mov b, $0
0248   05B8 E7            pop d
0249   05B9 FD 13 EE 00   mma 238 ; mov a, 238; mul a, b; add d, b
0250   05BD E4            pop a
0251   05BE 58 E8 00      add d, 232
0252   05C1 FD 14         clb
0253   05C3 D7            push a
0254   05C4 DA            push d
0255   05C5 26 02 00      mov b, $2
0256   05C8 E7            pop d
0257   05C9 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0258   05CD E4            pop a
0259   05CE 2A            mov b, [d]
0260   05CF FD AB         swp b
0261   05D1 D8            push b
0262   05D2 26 C2 12      mov b, __s1 ; "%d\n"
0263   05D5 FD AB         swp b
0264   05D7 D8            push b
0265   05D8 07 A5 07      call printf
0266   05DB 51 04 00      add sp, 4
0267   05DE 05 0B         syscall sys_terminate_proc
0268   05E0             
0269   05E0             strcpy:
0270   05E0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0271   05E3             ; $psrc 
0272   05E3             ; $pdest 
0273   05E3 52 04 00      sub sp, 4
0274   05E6             ;; psrc = src; 
0275   05E6 FA FF FF      lea d, [bp + -1] ; $psrc
0276   05E9 DA            push d
0277   05EA FA 07 00      lea d, [bp + 7] ; $src
0278   05ED 2A            mov b, [d]
0279   05EE E7            pop d
0280   05EF FD 43         mov [d], b
0281   05F1             ;; pdest = dest; 
0282   05F1 FA FD FF      lea d, [bp + -3] ; $pdest
0283   05F4 DA            push d
0284   05F5 FA 05 00      lea d, [bp + 5] ; $dest
0285   05F8 2A            mov b, [d]
0286   05F9 E7            pop d
0287   05FA FD 43         mov [d], b
0288   05FC             ;; while(*psrc) *pdest++ = *psrc++; 
0289   05FC             _while1_cond:
0290   05FC FA FF FF      lea d, [bp + -1] ; $psrc
0291   05FF 2A            mov b, [d]
0292   0600 74            mov d, b
0293   0601 32            mov bl, [d]
0294   0602 A7 00         mov bh, 0
0295   0604 C0 00 00      cmp b, 0
0296   0607 C6 33 06      je _while1_exit
0297   060A             _while1_block:
0298   060A             ;; *pdest++ = *psrc++; 
0299   060A FA FD FF      lea d, [bp + -3] ; $pdest
0300   060D 2A            mov b, [d]
0301   060E FD 79         mov g, b
0302   0610 FD 77         inc b
0303   0612 FA FD FF      lea d, [bp + -3] ; $pdest
0304   0615 FD 43         mov [d], b
0305   0617 FD 27         mov b, g
0306   0619 D8            push b
0307   061A FA FF FF      lea d, [bp + -1] ; $psrc
0308   061D 2A            mov b, [d]
0309   061E FD 79         mov g, b
0310   0620 FD 77         inc b
0311   0622 FA FF FF      lea d, [bp + -1] ; $psrc
0312   0625 FD 43         mov [d], b
0313   0627 FD 27         mov b, g
0314   0629 74            mov d, b
0315   062A 32            mov bl, [d]
0316   062B A7 00         mov bh, 0
0317   062D E7            pop d
0318   062E FD 3E         mov [d], bl
0319   0630 0A FC 05      jmp _while1_cond
0320   0633             _while1_exit:
0321   0633             ;; *pdest = '\0'; 
0322   0633 FA FD FF      lea d, [bp + -3] ; $pdest
0323   0636 2A            mov b, [d]
0324   0637 D8            push b
0325   0638 26 00 00      mov b, $0
0326   063B E7            pop d
0327   063C FD 3E         mov [d], bl
0328   063E F9            leave
0329   063F 09            ret
0330   0640             
0331   0640             strcmp:
0332   0640 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0333   0643             ;; while (*s1 && (*s1 == *s2)) { 
0334   0643             _while2_cond:
0335   0643 FA 05 00      lea d, [bp + 5] ; $s1
0336   0646 2A            mov b, [d]
0337   0647 74            mov d, b
0338   0648 32            mov bl, [d]
0339   0649 A7 00         mov bh, 0
0340   064B D7            push a
0341   064C 11            mov a, b
0342   064D FA 05 00      lea d, [bp + 5] ; $s1
0343   0650 2A            mov b, [d]
0344   0651 74            mov d, b
0345   0652 32            mov bl, [d]
0346   0653 A7 00         mov bh, 0
0347   0655             ; START RELATIONAL
0348   0655 D7            push a
0349   0656 11            mov a, b
0350   0657 FA 07 00      lea d, [bp + 7] ; $s2
0351   065A 2A            mov b, [d]
0352   065B 74            mov d, b
0353   065C 32            mov bl, [d]
0354   065D A7 00         mov bh, 0
0355   065F B0            cmp a, b
0356   0660 FD 71         seq ; ==
0357   0662 E4            pop a
0358   0663             ; END RELATIONAL
0359   0663 FD A7         sand a, b ; &&
0360   0665 E4            pop a
0361   0666 C0 00 00      cmp b, 0
0362   0669 C6 8D 06      je _while2_exit
0363   066C             _while2_block:
0364   066C             ;; s1++; 
0365   066C FA 05 00      lea d, [bp + 5] ; $s1
0366   066F 2A            mov b, [d]
0367   0670 FD 79         mov g, b
0368   0672 FD 77         inc b
0369   0674 FA 05 00      lea d, [bp + 5] ; $s1
0370   0677 FD 43         mov [d], b
0371   0679 FD 27         mov b, g
0372   067B             ;; s2++; 
0373   067B FA 07 00      lea d, [bp + 7] ; $s2
0374   067E 2A            mov b, [d]
0375   067F FD 79         mov g, b
0376   0681 FD 77         inc b
0377   0683 FA 07 00      lea d, [bp + 7] ; $s2
0378   0686 FD 43         mov [d], b
0379   0688 FD 27         mov b, g
0380   068A 0A 43 06      jmp _while2_cond
0381   068D             _while2_exit:
0382   068D             ;; return *s1 - *s2; 
0383   068D FA 05 00      lea d, [bp + 5] ; $s1
0384   0690 2A            mov b, [d]
0385   0691 74            mov d, b
0386   0692 32            mov bl, [d]
0387   0693 A7 00         mov bh, 0
0388   0695             ; START TERMS
0389   0695 D7            push a
0390   0696 11            mov a, b
0391   0697 FA 07 00      lea d, [bp + 7] ; $s2
0392   069A 2A            mov b, [d]
0393   069B 74            mov d, b
0394   069C 32            mov bl, [d]
0395   069D A7 00         mov bh, 0
0396   069F 60            sub a, b
0397   06A0 27            mov b, a
0398   06A1 E4            pop a
0399   06A2             ; END TERMS
0400   06A2 F9            leave
0401   06A3 09            ret
0402   06A4             
0403   06A4             strcat:
0404   06A4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0405   06A7             ; $dest_len 
0406   06A7             ; $i 
0407   06A7 52 04 00      sub sp, 4
0408   06AA             ;; dest_len = strlen(dest); 
0409   06AA FA FF FF      lea d, [bp + -1] ; $dest_len
0410   06AD DA            push d
0411   06AE FA 05 00      lea d, [bp + 5] ; $dest
0412   06B1 2A            mov b, [d]
0413   06B2 FD AB         swp b
0414   06B4 D8            push b
0415   06B5 07 5A 07      call strlen
0416   06B8 51 02 00      add sp, 2
0417   06BB E7            pop d
0418   06BC FD 43         mov [d], b
0419   06BE             ;; for (i = 0; src[i] != 0; i=i+1) { 
0420   06BE             _for3_init:
0421   06BE FA FD FF      lea d, [bp + -3] ; $i
0422   06C1 DA            push d
0423   06C2 26 00 00      mov b, $0
0424   06C5 E7            pop d
0425   06C6 FD 43         mov [d], b
0426   06C8             _for3_cond:
0427   06C8 FA 07 00      lea d, [bp + 7] ; $src
0428   06CB FD 2A         mov d, [d]
0429   06CD D7            push a
0430   06CE DA            push d
0431   06CF FA FD FF      lea d, [bp + -3] ; $i
0432   06D2 2A            mov b, [d]
0433   06D3 E7            pop d
0434   06D4 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0435   06D8 E4            pop a
0436   06D9 32            mov bl, [d]
0437   06DA A7 00         mov bh, 0
0438   06DC             ; START RELATIONAL
0439   06DC D7            push a
0440   06DD 11            mov a, b
0441   06DE 26 00 00      mov b, $0
0442   06E1 B0            cmp a, b
0443   06E2 FD 72         sneq ; !=
0444   06E4 E4            pop a
0445   06E5             ; END RELATIONAL
0446   06E5 C0 00 00      cmp b, 0
0447   06E8 C6 33 07      je _for3_exit
0448   06EB             _for3_block:
0449   06EB             ;; dest[dest_len + i] = src[i]; 
0450   06EB FA 05 00      lea d, [bp + 5] ; $dest
0451   06EE FD 2A         mov d, [d]
0452   06F0 D7            push a
0453   06F1 DA            push d
0454   06F2 FA FF FF      lea d, [bp + -1] ; $dest_len
0455   06F5 2A            mov b, [d]
0456   06F6             ; START TERMS
0457   06F6 D7            push a
0458   06F7 11            mov a, b
0459   06F8 FA FD FF      lea d, [bp + -3] ; $i
0460   06FB 2A            mov b, [d]
0461   06FC 54            add a, b
0462   06FD 27            mov b, a
0463   06FE E4            pop a
0464   06FF             ; END TERMS
0465   06FF E7            pop d
0466   0700 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0467   0704 E4            pop a
0468   0705 DA            push d
0469   0706 FA 07 00      lea d, [bp + 7] ; $src
0470   0709 FD 2A         mov d, [d]
0471   070B D7            push a
0472   070C DA            push d
0473   070D FA FD FF      lea d, [bp + -3] ; $i
0474   0710 2A            mov b, [d]
0475   0711 E7            pop d
0476   0712 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0477   0716 E4            pop a
0478   0717 32            mov bl, [d]
0479   0718 A7 00         mov bh, 0
0480   071A E7            pop d
0481   071B FD 3E         mov [d], bl
0482   071D             _for3_update:
0483   071D FA FD FF      lea d, [bp + -3] ; $i
0484   0720 DA            push d
0485   0721 FA FD FF      lea d, [bp + -3] ; $i
0486   0724 2A            mov b, [d]
0487   0725             ; START TERMS
0488   0725 D7            push a
0489   0726 11            mov a, b
0490   0727 26 01 00      mov b, $1
0491   072A 54            add a, b
0492   072B 27            mov b, a
0493   072C E4            pop a
0494   072D             ; END TERMS
0495   072D E7            pop d
0496   072E FD 43         mov [d], b
0497   0730 0A C8 06      jmp _for3_cond
0498   0733             _for3_exit:
0499   0733             ;; dest[dest_len + i] = 0; 
0500   0733 FA 05 00      lea d, [bp + 5] ; $dest
0501   0736 FD 2A         mov d, [d]
0502   0738 D7            push a
0503   0739 DA            push d
0504   073A FA FF FF      lea d, [bp + -1] ; $dest_len
0505   073D 2A            mov b, [d]
0506   073E             ; START TERMS
0507   073E D7            push a
0508   073F 11            mov a, b
0509   0740 FA FD FF      lea d, [bp + -3] ; $i
0510   0743 2A            mov b, [d]
0511   0744 54            add a, b
0512   0745 27            mov b, a
0513   0746 E4            pop a
0514   0747             ; END TERMS
0515   0747 E7            pop d
0516   0748 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0517   074C E4            pop a
0518   074D DA            push d
0519   074E 26 00 00      mov b, $0
0520   0751 E7            pop d
0521   0752 FD 3E         mov [d], bl
0522   0754             ;; return dest; 
0523   0754 FA 05 00      lea d, [bp + 5] ; $dest
0524   0757 2A            mov b, [d]
0525   0758 F9            leave
0526   0759 09            ret
0527   075A             
0528   075A             strlen:
0529   075A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0530   075D             ; $length 
0531   075D 52 02 00      sub sp, 2
0532   0760             ;; length = 0; 
0533   0760 FA FF FF      lea d, [bp + -1] ; $length
0534   0763 DA            push d
0535   0764 26 00 00      mov b, $0
0536   0767 E7            pop d
0537   0768 FD 43         mov [d], b
0538   076A             ;; while (str[length] != 0) { 
0539   076A             _while4_cond:
0540   076A FA 05 00      lea d, [bp + 5] ; $str
0541   076D FD 2A         mov d, [d]
0542   076F D7            push a
0543   0770 DA            push d
0544   0771 FA FF FF      lea d, [bp + -1] ; $length
0545   0774 2A            mov b, [d]
0546   0775 E7            pop d
0547   0776 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0548   077A E4            pop a
0549   077B 32            mov bl, [d]
0550   077C A7 00         mov bh, 0
0551   077E             ; START RELATIONAL
0552   077E D7            push a
0553   077F 11            mov a, b
0554   0780 26 00 00      mov b, $0
0555   0783 B0            cmp a, b
0556   0784 FD 72         sneq ; !=
0557   0786 E4            pop a
0558   0787             ; END RELATIONAL
0559   0787 C0 00 00      cmp b, 0
0560   078A C6 9F 07      je _while4_exit
0561   078D             _while4_block:
0562   078D             ;; length++; 
0563   078D FA FF FF      lea d, [bp + -1] ; $length
0564   0790 2A            mov b, [d]
0565   0791 FD 79         mov g, b
0566   0793 FD 77         inc b
0567   0795 FA FF FF      lea d, [bp + -1] ; $length
0568   0798 FD 43         mov [d], b
0569   079A FD 27         mov b, g
0570   079C 0A 6A 07      jmp _while4_cond
0571   079F             _while4_exit:
0572   079F             ;; return length; 
0573   079F FA FF FF      lea d, [bp + -1] ; $length
0574   07A2 2A            mov b, [d]
0575   07A3 F9            leave
0576   07A4 09            ret
0577   07A5             
0578   07A5             printf:
0579   07A5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0580   07A8             ; $p 
0581   07A8             ; $fp 
0582   07A8             ; $i 
0583   07A8 52 06 00      sub sp, 6
0584   07AB             ;; fp = format; 
0585   07AB FA FD FF      lea d, [bp + -3] ; $fp
0586   07AE DA            push d
0587   07AF FA 05 00      lea d, [bp + 5] ; $format
0588   07B2 2A            mov b, [d]
0589   07B3 E7            pop d
0590   07B4 FD 43         mov [d], b
0591   07B6             ;; p = &format + 2; 
0592   07B6 FA FF FF      lea d, [bp + -1] ; $p
0593   07B9 DA            push d
0594   07BA FA 05 00      lea d, [bp + 5] ; $format
0595   07BD 2D            mov b, d
0596   07BE             ; START TERMS
0597   07BE D7            push a
0598   07BF 11            mov a, b
0599   07C0 26 02 00      mov b, $2
0600   07C3 54            add a, b
0601   07C4 27            mov b, a
0602   07C5 E4            pop a
0603   07C6             ; END TERMS
0604   07C6 E7            pop d
0605   07C7 FD 43         mov [d], b
0606   07C9             ;; for(;;){ 
0607   07C9             _for5_init:
0608   07C9             _for5_cond:
0609   07C9             _for5_block:
0610   07C9             ;; if(!*fp) break; 
0611   07C9             _if6_cond:
0612   07C9 FA FD FF      lea d, [bp + -3] ; $fp
0613   07CC 2A            mov b, [d]
0614   07CD 74            mov d, b
0615   07CE 32            mov bl, [d]
0616   07CF A7 00         mov bh, 0
0617   07D1 C0 00 00      cmp b, 0
0618   07D4 FD 71         seq ; !
0619   07D6 C0 00 00      cmp b, 0
0620   07D9 C6 E2 07      je _if6_else
0621   07DC             _if6_true:
0622   07DC             ;; break; 
0623   07DC 0A 2C 09      jmp _for5_exit ; for break
0624   07DF 0A 29 09      jmp _if6_exit
0625   07E2             _if6_else:
0626   07E2             ;; if(*fp == '%'){ 
0627   07E2             _if7_cond:
0628   07E2 FA FD FF      lea d, [bp + -3] ; $fp
0629   07E5 2A            mov b, [d]
0630   07E6 74            mov d, b
0631   07E7 32            mov bl, [d]
0632   07E8 A7 00         mov bh, 0
0633   07EA             ; START RELATIONAL
0634   07EA D7            push a
0635   07EB 11            mov a, b
0636   07EC 26 25 00      mov b, $25
0637   07EF B0            cmp a, b
0638   07F0 FD 71         seq ; ==
0639   07F2 E4            pop a
0640   07F3             ; END RELATIONAL
0641   07F3 C0 00 00      cmp b, 0
0642   07F6 C6 0B 09      je _if7_else
0643   07F9             _if7_true:
0644   07F9             ;; fp++; 
0645   07F9 FA FD FF      lea d, [bp + -3] ; $fp
0646   07FC 2A            mov b, [d]
0647   07FD FD 79         mov g, b
0648   07FF FD 77         inc b
0649   0801 FA FD FF      lea d, [bp + -3] ; $fp
0650   0804 FD 43         mov [d], b
0651   0806 FD 27         mov b, g
0652   0808             ;; switch(*fp){ 
0653   0808             _switch8_expr:
0654   0808 FA FD FF      lea d, [bp + -3] ; $fp
0655   080B 2A            mov b, [d]
0656   080C 74            mov d, b
0657   080D 32            mov bl, [d]
0658   080E A7 00         mov bh, 0
0659   0810             _switch8_comparisons:
0660   0810 C1 64         cmp bl, $64
0661   0812 C6 34 08      je _switch8_case0
0662   0815 C1 69         cmp bl, $69
0663   0817 C6 34 08      je _switch8_case1
0664   081A C1 75         cmp bl, $75
0665   081C C6 59 08      je _switch8_case2
0666   081F C1 78         cmp bl, $78
0667   0821 C6 7E 08      je _switch8_case3
0668   0824 C1 63         cmp bl, $63
0669   0826 C6 A3 08      je _switch8_case4
0670   0829 C1 73         cmp bl, $73
0671   082B C6 C8 08      je _switch8_case5
0672   082E 0A ED 08      jmp _switch8_default
0673   0831 0A F9 08      jmp _switch8_exit
0674   0834             _switch8_case0:
0675   0834             _switch8_case1:
0676   0834             ;; prints(*(int*)p); 
0677   0834 FA FF FF      lea d, [bp + -1] ; $p
0678   0837 2A            mov b, [d]
0679   0838 74            mov d, b
0680   0839 2A            mov b, [d]
0681   083A FD AB         swp b
0682   083C D8            push b
0683   083D 07 BE 0B      call prints
0684   0840 51 02 00      add sp, 2
0685   0843             ;; p = p + 2; 
0686   0843 FA FF FF      lea d, [bp + -1] ; $p
0687   0846 DA            push d
0688   0847 FA FF FF      lea d, [bp + -1] ; $p
0689   084A 2A            mov b, [d]
0690   084B             ; START TERMS
0691   084B D7            push a
0692   084C 11            mov a, b
0693   084D 26 02 00      mov b, $2
0694   0850 54            add a, b
0695   0851 27            mov b, a
0696   0852 E4            pop a
0697   0853             ; END TERMS
0698   0853 E7            pop d
0699   0854 FD 43         mov [d], b
0700   0856             ;; break; 
0701   0856 0A F9 08      jmp _switch8_exit ; case break
0702   0859             _switch8_case2:
0703   0859             ;; printu(*(unsigned int*)p); 
0704   0859 FA FF FF      lea d, [bp + -1] ; $p
0705   085C 2A            mov b, [d]
0706   085D 74            mov d, b
0707   085E 2A            mov b, [d]
0708   085F FD AB         swp b
0709   0861 D8            push b
0710   0862 07 B3 0C      call printu
0711   0865 51 02 00      add sp, 2
0712   0868             ;; p = p + 2; 
0713   0868 FA FF FF      lea d, [bp + -1] ; $p
0714   086B DA            push d
0715   086C FA FF FF      lea d, [bp + -1] ; $p
0716   086F 2A            mov b, [d]
0717   0870             ; START TERMS
0718   0870 D7            push a
0719   0871 11            mov a, b
0720   0872 26 02 00      mov b, $2
0721   0875 54            add a, b
0722   0876 27            mov b, a
0723   0877 E4            pop a
0724   0878             ; END TERMS
0725   0878 E7            pop d
0726   0879 FD 43         mov [d], b
0727   087B             ;; break; 
0728   087B 0A F9 08      jmp _switch8_exit ; case break
0729   087E             _switch8_case3:
0730   087E             ;; printx16(*(unsigned int*)p); 
0731   087E FA FF FF      lea d, [bp + -1] ; $p
0732   0881 2A            mov b, [d]
0733   0882 74            mov d, b
0734   0883 2A            mov b, [d]
0735   0884 FD AB         swp b
0736   0886 D8            push b
0737   0887 07 2E 09      call printx16
0738   088A 51 02 00      add sp, 2
0739   088D             ;; p = p + 2; 
0740   088D FA FF FF      lea d, [bp + -1] ; $p
0741   0890 DA            push d
0742   0891 FA FF FF      lea d, [bp + -1] ; $p
0743   0894 2A            mov b, [d]
0744   0895             ; START TERMS
0745   0895 D7            push a
0746   0896 11            mov a, b
0747   0897 26 02 00      mov b, $2
0748   089A 54            add a, b
0749   089B 27            mov b, a
0750   089C E4            pop a
0751   089D             ; END TERMS
0752   089D E7            pop d
0753   089E FD 43         mov [d], b
0754   08A0             ;; break; 
0755   08A0 0A F9 08      jmp _switch8_exit ; case break
0756   08A3             _switch8_case4:
0757   08A3             ;; putchar(*(char*)p); 
0758   08A3 FA FF FF      lea d, [bp + -1] ; $p
0759   08A6 2A            mov b, [d]
0760   08A7 74            mov d, b
0761   08A8 32            mov bl, [d]
0762   08A9 A7 00         mov bh, 0
0763   08AB DD            push bl
0764   08AC 07 9F 0D      call putchar
0765   08AF 51 01 00      add sp, 1
0766   08B2             ;; p = p + 2; 
0767   08B2 FA FF FF      lea d, [bp + -1] ; $p
0768   08B5 DA            push d
0769   08B6 FA FF FF      lea d, [bp + -1] ; $p
0770   08B9 2A            mov b, [d]
0771   08BA             ; START TERMS
0772   08BA D7            push a
0773   08BB 11            mov a, b
0774   08BC 26 02 00      mov b, $2
0775   08BF 54            add a, b
0776   08C0 27            mov b, a
0777   08C1 E4            pop a
0778   08C2             ; END TERMS
0779   08C2 E7            pop d
0780   08C3 FD 43         mov [d], b
0781   08C5             ;; break; 
0782   08C5 0A F9 08      jmp _switch8_exit ; case break
0783   08C8             _switch8_case5:
0784   08C8             ;; print(*(char**)p); 
0785   08C8 FA FF FF      lea d, [bp + -1] ; $p
0786   08CB 2A            mov b, [d]
0787   08CC 74            mov d, b
0788   08CD 2A            mov b, [d]
0789   08CE FD AB         swp b
0790   08D0 D8            push b
0791   08D1 07 E7 0D      call print
0792   08D4 51 02 00      add sp, 2
0793   08D7             ;; p = p + 2; 
0794   08D7 FA FF FF      lea d, [bp + -1] ; $p
0795   08DA DA            push d
0796   08DB FA FF FF      lea d, [bp + -1] ; $p
0797   08DE 2A            mov b, [d]
0798   08DF             ; START TERMS
0799   08DF D7            push a
0800   08E0 11            mov a, b
0801   08E1 26 02 00      mov b, $2
0802   08E4 54            add a, b
0803   08E5 27            mov b, a
0804   08E6 E4            pop a
0805   08E7             ; END TERMS
0806   08E7 E7            pop d
0807   08E8 FD 43         mov [d], b
0808   08EA             ;; break; 
0809   08EA 0A F9 08      jmp _switch8_exit ; case break
0810   08ED             _switch8_default:
0811   08ED             ;; print("Error: Unknown argument type.\n"); 
0812   08ED 26 C6 12      mov b, __s2 ; "Error: Unknown argument type.\n"
0813   08F0 FD AB         swp b
0814   08F2 D8            push b
0815   08F3 07 E7 0D      call print
0816   08F6 51 02 00      add sp, 2
0817   08F9             _switch8_exit:
0818   08F9             ;; fp++; 
0819   08F9 FA FD FF      lea d, [bp + -3] ; $fp
0820   08FC 2A            mov b, [d]
0821   08FD FD 79         mov g, b
0822   08FF FD 77         inc b
0823   0901 FA FD FF      lea d, [bp + -3] ; $fp
0824   0904 FD 43         mov [d], b
0825   0906 FD 27         mov b, g
0826   0908 0A 29 09      jmp _if7_exit
0827   090B             _if7_else:
0828   090B             ;; putchar(*fp); 
0829   090B FA FD FF      lea d, [bp + -3] ; $fp
0830   090E 2A            mov b, [d]
0831   090F 74            mov d, b
0832   0910 32            mov bl, [d]
0833   0911 A7 00         mov bh, 0
0834   0913 DD            push bl
0835   0914 07 9F 0D      call putchar
0836   0917 51 01 00      add sp, 1
0837   091A             ;; fp++; 
0838   091A FA FD FF      lea d, [bp + -3] ; $fp
0839   091D 2A            mov b, [d]
0840   091E FD 79         mov g, b
0841   0920 FD 77         inc b
0842   0922 FA FD FF      lea d, [bp + -3] ; $fp
0843   0925 FD 43         mov [d], b
0844   0927 FD 27         mov b, g
0845   0929             _if7_exit:
0846   0929             _if6_exit:
0847   0929             _for5_update:
0848   0929 0A C9 07      jmp _for5_cond
0849   092C             _for5_exit:
0850   092C F9            leave
0851   092D 09            ret
0852   092E             
0853   092E             printx16:
0854   092E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0855   0931             
0856   0931             ; --- BEGIN INLINE ASM BLOCK
0857   0931 FA 05 00      lea d, [bp + 5] ; $hex
0858   0934 2A            mov b, [d]
0859   0935 07 BE 11      call print_u16x
0860   0938             ; --- END INLINE ASM BLOCK
0861   0938             
0862   0938 F9            leave
0863   0939 09            ret
0864   093A             
0865   093A             printx8:
0866   093A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0867   093D             
0868   093D             ; --- BEGIN INLINE ASM BLOCK
0869   093D FA 05 00      lea d, [bp + 5] ; $hex
0870   0940 32            mov bl, [d]
0871   0941 07 02 12      call print_u8x
0872   0944             ; --- END INLINE ASM BLOCK
0873   0944             
0874   0944 F9            leave
0875   0945 09            ret
0876   0946             
0877   0946             hex_to_int:
0878   0946 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0879   0949             ; $value 
0880   0949 10 00 00      mov a, $0
0881   094C 45 FF FF      mov [bp + -1], a
0882   094F             ; $i 
0883   094F             ; $hex_char 
0884   094F             ; $len 
0885   094F 52 07 00      sub sp, 7
0886   0952             ;; len = strlen(hex_string); 
0887   0952 FA FA FF      lea d, [bp + -6] ; $len
0888   0955 DA            push d
0889   0956 FA 05 00      lea d, [bp + 5] ; $hex_string
0890   0959 2A            mov b, [d]
0891   095A FD AB         swp b
0892   095C D8            push b
0893   095D 07 5A 07      call strlen
0894   0960 51 02 00      add sp, 2
0895   0963 E7            pop d
0896   0964 FD 43         mov [d], b
0897   0966             ;; for (i = 0; i < len; i++) { 
0898   0966             _for9_init:
0899   0966 FA FD FF      lea d, [bp + -3] ; $i
0900   0969 DA            push d
0901   096A 26 00 00      mov b, $0
0902   096D E7            pop d
0903   096E FD 43         mov [d], b
0904   0970             _for9_cond:
0905   0970 FA FD FF      lea d, [bp + -3] ; $i
0906   0973 2A            mov b, [d]
0907   0974             ; START RELATIONAL
0908   0974 D7            push a
0909   0975 11            mov a, b
0910   0976 FA FA FF      lea d, [bp + -6] ; $len
0911   0979 2A            mov b, [d]
0912   097A B0            cmp a, b
0913   097B FD 73         slt ; < 
0914   097D E4            pop a
0915   097E             ; END RELATIONAL
0916   097E C0 00 00      cmp b, 0
0917   0981 C6 86 0A      je _for9_exit
0918   0984             _for9_block:
0919   0984             ;; hex_char = hex_string[i]; 
0920   0984 FA FC FF      lea d, [bp + -4] ; $hex_char
0921   0987 DA            push d
0922   0988 FA 05 00      lea d, [bp + 5] ; $hex_string
0923   098B FD 2A         mov d, [d]
0924   098D D7            push a
0925   098E DA            push d
0926   098F FA FD FF      lea d, [bp + -3] ; $i
0927   0992 2A            mov b, [d]
0928   0993 E7            pop d
0929   0994 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0930   0998 E4            pop a
0931   0999 32            mov bl, [d]
0932   099A A7 00         mov bh, 0
0933   099C E7            pop d
0934   099D FD 3E         mov [d], bl
0935   099F             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0936   099F             _if10_cond:
0937   099F FA FC FF      lea d, [bp + -4] ; $hex_char
0938   09A2 32            mov bl, [d]
0939   09A3 A7 00         mov bh, 0
0940   09A5             ; START RELATIONAL
0941   09A5 D7            push a
0942   09A6 11            mov a, b
0943   09A7 26 61 00      mov b, $61
0944   09AA B0            cmp a, b
0945   09AB FD 80         sge ; >=
0946   09AD E4            pop a
0947   09AE             ; END RELATIONAL
0948   09AE D7            push a
0949   09AF 11            mov a, b
0950   09B0 FA FC FF      lea d, [bp + -4] ; $hex_char
0951   09B3 32            mov bl, [d]
0952   09B4 A7 00         mov bh, 0
0953   09B6             ; START RELATIONAL
0954   09B6 D7            push a
0955   09B7 11            mov a, b
0956   09B8 26 66 00      mov b, $66
0957   09BB B0            cmp a, b
0958   09BC FD 74         sle ; <=
0959   09BE E4            pop a
0960   09BF             ; END RELATIONAL
0961   09BF FD A7         sand a, b ; &&
0962   09C1 E4            pop a
0963   09C2 C0 00 00      cmp b, 0
0964   09C5 C6 F6 09      je _if10_else
0965   09C8             _if10_true:
0966   09C8             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0967   09C8 FA FF FF      lea d, [bp + -1] ; $value
0968   09CB DA            push d
0969   09CC FA FF FF      lea d, [bp + -1] ; $value
0970   09CF 2A            mov b, [d]
0971   09D0             ; START FACTORS
0972   09D0 D7            push a
0973   09D1 11            mov a, b
0974   09D2 26 10 00      mov b, $10
0975   09D5 AC            mul a, b ; *
0976   09D6 11            mov a, b
0977   09D7 27            mov b, a
0978   09D8 E4            pop a
0979   09D9             ; END FACTORS
0980   09D9             ; START TERMS
0981   09D9 D7            push a
0982   09DA 11            mov a, b
0983   09DB FA FC FF      lea d, [bp + -4] ; $hex_char
0984   09DE 32            mov bl, [d]
0985   09DF A7 00         mov bh, 0
0986   09E1             ; START TERMS
0987   09E1 D7            push a
0988   09E2 11            mov a, b
0989   09E3 26 61 00      mov b, $61
0990   09E6 60            sub a, b
0991   09E7 26 0A 00      mov b, $a
0992   09EA 54            add a, b
0993   09EB 27            mov b, a
0994   09EC E4            pop a
0995   09ED             ; END TERMS
0996   09ED 54            add a, b
0997   09EE 27            mov b, a
0998   09EF E4            pop a
0999   09F0             ; END TERMS
1000   09F0 E7            pop d
1001   09F1 FD 43         mov [d], b
1002   09F3 0A 74 0A      jmp _if10_exit
1003   09F6             _if10_else:
1004   09F6             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1005   09F6             _if11_cond:
1006   09F6 FA FC FF      lea d, [bp + -4] ; $hex_char
1007   09F9 32            mov bl, [d]
1008   09FA A7 00         mov bh, 0
1009   09FC             ; START RELATIONAL
1010   09FC D7            push a
1011   09FD 11            mov a, b
1012   09FE 26 41 00      mov b, $41
1013   0A01 B0            cmp a, b
1014   0A02 FD 80         sge ; >=
1015   0A04 E4            pop a
1016   0A05             ; END RELATIONAL
1017   0A05 D7            push a
1018   0A06 11            mov a, b
1019   0A07 FA FC FF      lea d, [bp + -4] ; $hex_char
1020   0A0A 32            mov bl, [d]
1021   0A0B A7 00         mov bh, 0
1022   0A0D             ; START RELATIONAL
1023   0A0D D7            push a
1024   0A0E 11            mov a, b
1025   0A0F 26 46 00      mov b, $46
1026   0A12 B0            cmp a, b
1027   0A13 FD 74         sle ; <=
1028   0A15 E4            pop a
1029   0A16             ; END RELATIONAL
1030   0A16 FD A7         sand a, b ; &&
1031   0A18 E4            pop a
1032   0A19 C0 00 00      cmp b, 0
1033   0A1C C6 4D 0A      je _if11_else
1034   0A1F             _if11_true:
1035   0A1F             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1036   0A1F FA FF FF      lea d, [bp + -1] ; $value
1037   0A22 DA            push d
1038   0A23 FA FF FF      lea d, [bp + -1] ; $value
1039   0A26 2A            mov b, [d]
1040   0A27             ; START FACTORS
1041   0A27 D7            push a
1042   0A28 11            mov a, b
1043   0A29 26 10 00      mov b, $10
1044   0A2C AC            mul a, b ; *
1045   0A2D 11            mov a, b
1046   0A2E 27            mov b, a
1047   0A2F E4            pop a
1048   0A30             ; END FACTORS
1049   0A30             ; START TERMS
1050   0A30 D7            push a
1051   0A31 11            mov a, b
1052   0A32 FA FC FF      lea d, [bp + -4] ; $hex_char
1053   0A35 32            mov bl, [d]
1054   0A36 A7 00         mov bh, 0
1055   0A38             ; START TERMS
1056   0A38 D7            push a
1057   0A39 11            mov a, b
1058   0A3A 26 41 00      mov b, $41
1059   0A3D 60            sub a, b
1060   0A3E 26 0A 00      mov b, $a
1061   0A41 54            add a, b
1062   0A42 27            mov b, a
1063   0A43 E4            pop a
1064   0A44             ; END TERMS
1065   0A44 54            add a, b
1066   0A45 27            mov b, a
1067   0A46 E4            pop a
1068   0A47             ; END TERMS
1069   0A47 E7            pop d
1070   0A48 FD 43         mov [d], b
1071   0A4A 0A 74 0A      jmp _if11_exit
1072   0A4D             _if11_else:
1073   0A4D             ;; value = (value * 16) + (hex_char - '0'); 
1074   0A4D FA FF FF      lea d, [bp + -1] ; $value
1075   0A50 DA            push d
1076   0A51 FA FF FF      lea d, [bp + -1] ; $value
1077   0A54 2A            mov b, [d]
1078   0A55             ; START FACTORS
1079   0A55 D7            push a
1080   0A56 11            mov a, b
1081   0A57 26 10 00      mov b, $10
1082   0A5A AC            mul a, b ; *
1083   0A5B 11            mov a, b
1084   0A5C 27            mov b, a
1085   0A5D E4            pop a
1086   0A5E             ; END FACTORS
1087   0A5E             ; START TERMS
1088   0A5E D7            push a
1089   0A5F 11            mov a, b
1090   0A60 FA FC FF      lea d, [bp + -4] ; $hex_char
1091   0A63 32            mov bl, [d]
1092   0A64 A7 00         mov bh, 0
1093   0A66             ; START TERMS
1094   0A66 D7            push a
1095   0A67 11            mov a, b
1096   0A68 26 30 00      mov b, $30
1097   0A6B 60            sub a, b
1098   0A6C 27            mov b, a
1099   0A6D E4            pop a
1100   0A6E             ; END TERMS
1101   0A6E 54            add a, b
1102   0A6F 27            mov b, a
1103   0A70 E4            pop a
1104   0A71             ; END TERMS
1105   0A71 E7            pop d
1106   0A72 FD 43         mov [d], b
1107   0A74             _if11_exit:
1108   0A74             _if10_exit:
1109   0A74             _for9_update:
1110   0A74 FA FD FF      lea d, [bp + -3] ; $i
1111   0A77 2A            mov b, [d]
1112   0A78 FD 79         mov g, b
1113   0A7A FD 77         inc b
1114   0A7C FA FD FF      lea d, [bp + -3] ; $i
1115   0A7F FD 43         mov [d], b
1116   0A81 FD 27         mov b, g
1117   0A83 0A 70 09      jmp _for9_cond
1118   0A86             _for9_exit:
1119   0A86             ;; return value; 
1120   0A86 FA FF FF      lea d, [bp + -1] ; $value
1121   0A89 2A            mov b, [d]
1122   0A8A F9            leave
1123   0A8B 09            ret
1124   0A8C             
1125   0A8C             atoi:
1126   0A8C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1127   0A8F             ; $result 
1128   0A8F 10 00 00      mov a, $0
1129   0A92 45 FF FF      mov [bp + -1], a
1130   0A95             ; $sign 
1131   0A95 10 01 00      mov a, $1
1132   0A98 45 FD FF      mov [bp + -3], a
1133   0A9B 52 04 00      sub sp, 4
1134   0A9E             ;; while (*str == ' ') str++; 
1135   0A9E             _while12_cond:
1136   0A9E FA 05 00      lea d, [bp + 5] ; $str
1137   0AA1 2A            mov b, [d]
1138   0AA2 74            mov d, b
1139   0AA3 32            mov bl, [d]
1140   0AA4 A7 00         mov bh, 0
1141   0AA6             ; START RELATIONAL
1142   0AA6 D7            push a
1143   0AA7 11            mov a, b
1144   0AA8 26 20 00      mov b, $20
1145   0AAB B0            cmp a, b
1146   0AAC FD 71         seq ; ==
1147   0AAE E4            pop a
1148   0AAF             ; END RELATIONAL
1149   0AAF C0 00 00      cmp b, 0
1150   0AB2 C6 C7 0A      je _while12_exit
1151   0AB5             _while12_block:
1152   0AB5             ;; str++; 
1153   0AB5 FA 05 00      lea d, [bp + 5] ; $str
1154   0AB8 2A            mov b, [d]
1155   0AB9 FD 79         mov g, b
1156   0ABB FD 77         inc b
1157   0ABD FA 05 00      lea d, [bp + 5] ; $str
1158   0AC0 FD 43         mov [d], b
1159   0AC2 FD 27         mov b, g
1160   0AC4 0A 9E 0A      jmp _while12_cond
1161   0AC7             _while12_exit:
1162   0AC7             ;; if (*str == '-' || *str == '+') { 
1163   0AC7             _if13_cond:
1164   0AC7 FA 05 00      lea d, [bp + 5] ; $str
1165   0ACA 2A            mov b, [d]
1166   0ACB 74            mov d, b
1167   0ACC 32            mov bl, [d]
1168   0ACD A7 00         mov bh, 0
1169   0ACF             ; START RELATIONAL
1170   0ACF D7            push a
1171   0AD0 11            mov a, b
1172   0AD1 26 2D 00      mov b, $2d
1173   0AD4 B0            cmp a, b
1174   0AD5 FD 71         seq ; ==
1175   0AD7 E4            pop a
1176   0AD8             ; END RELATIONAL
1177   0AD8 D7            push a
1178   0AD9 11            mov a, b
1179   0ADA FA 05 00      lea d, [bp + 5] ; $str
1180   0ADD 2A            mov b, [d]
1181   0ADE 74            mov d, b
1182   0ADF 32            mov bl, [d]
1183   0AE0 A7 00         mov bh, 0
1184   0AE2             ; START RELATIONAL
1185   0AE2 D7            push a
1186   0AE3 11            mov a, b
1187   0AE4 26 2B 00      mov b, $2b
1188   0AE7 B0            cmp a, b
1189   0AE8 FD 71         seq ; ==
1190   0AEA E4            pop a
1191   0AEB             ; END RELATIONAL
1192   0AEB FD A8         sor a, b ; ||
1193   0AED E4            pop a
1194   0AEE C0 00 00      cmp b, 0
1195   0AF1 C6 2C 0B      je _if13_exit
1196   0AF4             _if13_true:
1197   0AF4             ;; if (*str == '-') sign = -1; 
1198   0AF4             _if14_cond:
1199   0AF4 FA 05 00      lea d, [bp + 5] ; $str
1200   0AF7 2A            mov b, [d]
1201   0AF8 74            mov d, b
1202   0AF9 32            mov bl, [d]
1203   0AFA A7 00         mov bh, 0
1204   0AFC             ; START RELATIONAL
1205   0AFC D7            push a
1206   0AFD 11            mov a, b
1207   0AFE 26 2D 00      mov b, $2d
1208   0B01 B0            cmp a, b
1209   0B02 FD 71         seq ; ==
1210   0B04 E4            pop a
1211   0B05             ; END RELATIONAL
1212   0B05 C0 00 00      cmp b, 0
1213   0B08 C6 1A 0B      je _if14_exit
1214   0B0B             _if14_true:
1215   0B0B             ;; sign = -1; 
1216   0B0B FA FD FF      lea d, [bp + -3] ; $sign
1217   0B0E DA            push d
1218   0B0F 26 01 00      mov b, $1
1219   0B12 FD 97         neg b
1220   0B14 E7            pop d
1221   0B15 FD 43         mov [d], b
1222   0B17 0A 1A 0B      jmp _if14_exit
1223   0B1A             _if14_exit:
1224   0B1A             ;; str++; 
1225   0B1A FA 05 00      lea d, [bp + 5] ; $str
1226   0B1D 2A            mov b, [d]
1227   0B1E FD 79         mov g, b
1228   0B20 FD 77         inc b
1229   0B22 FA 05 00      lea d, [bp + 5] ; $str
1230   0B25 FD 43         mov [d], b
1231   0B27 FD 27         mov b, g
1232   0B29 0A 2C 0B      jmp _if13_exit
1233   0B2C             _if13_exit:
1234   0B2C             ;; while (*str >= '0' && *str <= '9') { 
1235   0B2C             _while15_cond:
1236   0B2C FA 05 00      lea d, [bp + 5] ; $str
1237   0B2F 2A            mov b, [d]
1238   0B30 74            mov d, b
1239   0B31 32            mov bl, [d]
1240   0B32 A7 00         mov bh, 0
1241   0B34             ; START RELATIONAL
1242   0B34 D7            push a
1243   0B35 11            mov a, b
1244   0B36 26 30 00      mov b, $30
1245   0B39 B0            cmp a, b
1246   0B3A FD 80         sge ; >=
1247   0B3C E4            pop a
1248   0B3D             ; END RELATIONAL
1249   0B3D D7            push a
1250   0B3E 11            mov a, b
1251   0B3F FA 05 00      lea d, [bp + 5] ; $str
1252   0B42 2A            mov b, [d]
1253   0B43 74            mov d, b
1254   0B44 32            mov bl, [d]
1255   0B45 A7 00         mov bh, 0
1256   0B47             ; START RELATIONAL
1257   0B47 D7            push a
1258   0B48 11            mov a, b
1259   0B49 26 39 00      mov b, $39
1260   0B4C B0            cmp a, b
1261   0B4D FD 74         sle ; <=
1262   0B4F E4            pop a
1263   0B50             ; END RELATIONAL
1264   0B50 FD A7         sand a, b ; &&
1265   0B52 E4            pop a
1266   0B53 C0 00 00      cmp b, 0
1267   0B56 C6 94 0B      je _while15_exit
1268   0B59             _while15_block:
1269   0B59             ;; result = result * 10 + (*str - '0'); 
1270   0B59 FA FF FF      lea d, [bp + -1] ; $result
1271   0B5C DA            push d
1272   0B5D FA FF FF      lea d, [bp + -1] ; $result
1273   0B60 2A            mov b, [d]
1274   0B61             ; START FACTORS
1275   0B61 D7            push a
1276   0B62 11            mov a, b
1277   0B63 26 0A 00      mov b, $a
1278   0B66 AC            mul a, b ; *
1279   0B67 11            mov a, b
1280   0B68 27            mov b, a
1281   0B69 E4            pop a
1282   0B6A             ; END FACTORS
1283   0B6A             ; START TERMS
1284   0B6A D7            push a
1285   0B6B 11            mov a, b
1286   0B6C FA 05 00      lea d, [bp + 5] ; $str
1287   0B6F 2A            mov b, [d]
1288   0B70 74            mov d, b
1289   0B71 32            mov bl, [d]
1290   0B72 A7 00         mov bh, 0
1291   0B74             ; START TERMS
1292   0B74 D7            push a
1293   0B75 11            mov a, b
1294   0B76 26 30 00      mov b, $30
1295   0B79 60            sub a, b
1296   0B7A 27            mov b, a
1297   0B7B E4            pop a
1298   0B7C             ; END TERMS
1299   0B7C 54            add a, b
1300   0B7D 27            mov b, a
1301   0B7E E4            pop a
1302   0B7F             ; END TERMS
1303   0B7F E7            pop d
1304   0B80 FD 43         mov [d], b
1305   0B82             ;; str++; 
1306   0B82 FA 05 00      lea d, [bp + 5] ; $str
1307   0B85 2A            mov b, [d]
1308   0B86 FD 79         mov g, b
1309   0B88 FD 77         inc b
1310   0B8A FA 05 00      lea d, [bp + 5] ; $str
1311   0B8D FD 43         mov [d], b
1312   0B8F FD 27         mov b, g
1313   0B91 0A 2C 0B      jmp _while15_cond
1314   0B94             _while15_exit:
1315   0B94             ;; return sign * result; 
1316   0B94 FA FD FF      lea d, [bp + -3] ; $sign
1317   0B97 2A            mov b, [d]
1318   0B98             ; START FACTORS
1319   0B98 D7            push a
1320   0B99 11            mov a, b
1321   0B9A FA FF FF      lea d, [bp + -1] ; $result
1322   0B9D 2A            mov b, [d]
1323   0B9E AC            mul a, b ; *
1324   0B9F 11            mov a, b
1325   0BA0 27            mov b, a
1326   0BA1 E4            pop a
1327   0BA2             ; END FACTORS
1328   0BA2 F9            leave
1329   0BA3 09            ret
1330   0BA4             
1331   0BA4             gets:
1332   0BA4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1333   0BA7             
1334   0BA7             ; --- BEGIN INLINE ASM BLOCK
1335   0BA7 FA 05 00      lea d, [bp + 5] ; $s
1336   0BAA 15            mov a, [d]
1337   0BAB 3C            mov d, a
1338   0BAC 07 23 10      call _gets
1339   0BAF             ; --- END INLINE ASM BLOCK
1340   0BAF             
1341   0BAF             ;; return strlen(s); 
1342   0BAF FA 05 00      lea d, [bp + 5] ; $s
1343   0BB2 2A            mov b, [d]
1344   0BB3 FD AB         swp b
1345   0BB5 D8            push b
1346   0BB6 07 5A 07      call strlen
1347   0BB9 51 02 00      add sp, 2
1348   0BBC F9            leave
1349   0BBD 09            ret
1350   0BBE             
1351   0BBE             prints:
1352   0BBE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1353   0BC1             ; $digits 
1354   0BC1             ; $i 
1355   0BC1 10 00 00      mov a, $0
1356   0BC4 45 FA FF      mov [bp + -6], a
1357   0BC7 52 07 00      sub sp, 7
1358   0BCA             ;; if (num < 0) { 
1359   0BCA             _if16_cond:
1360   0BCA FA 05 00      lea d, [bp + 5] ; $num
1361   0BCD 2A            mov b, [d]
1362   0BCE             ; START RELATIONAL
1363   0BCE D7            push a
1364   0BCF 11            mov a, b
1365   0BD0 26 00 00      mov b, $0
1366   0BD3 B0            cmp a, b
1367   0BD4 FD 73         slt ; < 
1368   0BD6 E4            pop a
1369   0BD7             ; END RELATIONAL
1370   0BD7 C0 00 00      cmp b, 0
1371   0BDA C6 F7 0B      je _if16_else
1372   0BDD             _if16_true:
1373   0BDD             ;; putchar('-'); 
1374   0BDD 26 2D 00      mov b, $2d
1375   0BE0 DD            push bl
1376   0BE1 07 9F 0D      call putchar
1377   0BE4 51 01 00      add sp, 1
1378   0BE7             ;; num = -num; 
1379   0BE7 FA 05 00      lea d, [bp + 5] ; $num
1380   0BEA DA            push d
1381   0BEB FA 05 00      lea d, [bp + 5] ; $num
1382   0BEE 2A            mov b, [d]
1383   0BEF FD 97         neg b
1384   0BF1 E7            pop d
1385   0BF2 FD 43         mov [d], b
1386   0BF4 0A 19 0C      jmp _if16_exit
1387   0BF7             _if16_else:
1388   0BF7             ;; if (num == 0) { 
1389   0BF7             _if17_cond:
1390   0BF7 FA 05 00      lea d, [bp + 5] ; $num
1391   0BFA 2A            mov b, [d]
1392   0BFB             ; START RELATIONAL
1393   0BFB D7            push a
1394   0BFC 11            mov a, b
1395   0BFD 26 00 00      mov b, $0
1396   0C00 B0            cmp a, b
1397   0C01 FD 71         seq ; ==
1398   0C03 E4            pop a
1399   0C04             ; END RELATIONAL
1400   0C04 C0 00 00      cmp b, 0
1401   0C07 C6 19 0C      je _if17_exit
1402   0C0A             _if17_true:
1403   0C0A             ;; putchar('0'); 
1404   0C0A 26 30 00      mov b, $30
1405   0C0D DD            push bl
1406   0C0E 07 9F 0D      call putchar
1407   0C11 51 01 00      add sp, 1
1408   0C14             ;; return; 
1409   0C14 F9            leave
1410   0C15 09            ret
1411   0C16 0A 19 0C      jmp _if17_exit
1412   0C19             _if17_exit:
1413   0C19             _if16_exit:
1414   0C19             ;; while (num > 0) { 
1415   0C19             _while18_cond:
1416   0C19 FA 05 00      lea d, [bp + 5] ; $num
1417   0C1C 2A            mov b, [d]
1418   0C1D             ; START RELATIONAL
1419   0C1D D7            push a
1420   0C1E 11            mov a, b
1421   0C1F 26 00 00      mov b, $0
1422   0C22 B0            cmp a, b
1423   0C23 FD 7F         sgt ; >
1424   0C25 E4            pop a
1425   0C26             ; END RELATIONAL
1426   0C26 C0 00 00      cmp b, 0
1427   0C29 C6 76 0C      je _while18_exit
1428   0C2C             _while18_block:
1429   0C2C             ;; digits[i] = '0' + (num % 10); 
1430   0C2C FA FC FF      lea d, [bp + -4] ; $digits
1431   0C2F D7            push a
1432   0C30 DA            push d
1433   0C31 FA FA FF      lea d, [bp + -6] ; $i
1434   0C34 2A            mov b, [d]
1435   0C35 E7            pop d
1436   0C36 5A            add d, b
1437   0C37 E4            pop a
1438   0C38 DA            push d
1439   0C39 26 30 00      mov b, $30
1440   0C3C             ; START TERMS
1441   0C3C D7            push a
1442   0C3D 11            mov a, b
1443   0C3E FA 05 00      lea d, [bp + 5] ; $num
1444   0C41 2A            mov b, [d]
1445   0C42             ; START FACTORS
1446   0C42 D7            push a
1447   0C43 11            mov a, b
1448   0C44 26 0A 00      mov b, $a
1449   0C47 AE            div a, b ; 
1450   0C48 11            mov a, b
1451   0C49 27            mov b, a
1452   0C4A E4            pop a
1453   0C4B             ; END FACTORS
1454   0C4B 54            add a, b
1455   0C4C 27            mov b, a
1456   0C4D E4            pop a
1457   0C4E             ; END TERMS
1458   0C4E E7            pop d
1459   0C4F FD 3E         mov [d], bl
1460   0C51             ;; num = num / 10; 
1461   0C51 FA 05 00      lea d, [bp + 5] ; $num
1462   0C54 DA            push d
1463   0C55 FA 05 00      lea d, [bp + 5] ; $num
1464   0C58 2A            mov b, [d]
1465   0C59             ; START FACTORS
1466   0C59 D7            push a
1467   0C5A 11            mov a, b
1468   0C5B 26 0A 00      mov b, $a
1469   0C5E AE            div a, b
1470   0C5F 27            mov b, a
1471   0C60 E4            pop a
1472   0C61             ; END FACTORS
1473   0C61 E7            pop d
1474   0C62 FD 43         mov [d], b
1475   0C64             ;; i++; 
1476   0C64 FA FA FF      lea d, [bp + -6] ; $i
1477   0C67 2A            mov b, [d]
1478   0C68 FD 79         mov g, b
1479   0C6A FD 77         inc b
1480   0C6C FA FA FF      lea d, [bp + -6] ; $i
1481   0C6F FD 43         mov [d], b
1482   0C71 FD 27         mov b, g
1483   0C73 0A 19 0C      jmp _while18_cond
1484   0C76             _while18_exit:
1485   0C76             ;; while (i > 0) { 
1486   0C76             _while19_cond:
1487   0C76 FA FA FF      lea d, [bp + -6] ; $i
1488   0C79 2A            mov b, [d]
1489   0C7A             ; START RELATIONAL
1490   0C7A D7            push a
1491   0C7B 11            mov a, b
1492   0C7C 26 00 00      mov b, $0
1493   0C7F B0            cmp a, b
1494   0C80 FD 7F         sgt ; >
1495   0C82 E4            pop a
1496   0C83             ; END RELATIONAL
1497   0C83 C0 00 00      cmp b, 0
1498   0C86 C6 B1 0C      je _while19_exit
1499   0C89             _while19_block:
1500   0C89             ;; i--; 
1501   0C89 FA FA FF      lea d, [bp + -6] ; $i
1502   0C8C 2A            mov b, [d]
1503   0C8D FD 79         mov g, b
1504   0C8F FD 7D         dec b
1505   0C91 FA FA FF      lea d, [bp + -6] ; $i
1506   0C94 FD 43         mov [d], b
1507   0C96 FD 27         mov b, g
1508   0C98             ;; putchar(digits[i]); 
1509   0C98 FA FC FF      lea d, [bp + -4] ; $digits
1510   0C9B D7            push a
1511   0C9C DA            push d
1512   0C9D FA FA FF      lea d, [bp + -6] ; $i
1513   0CA0 2A            mov b, [d]
1514   0CA1 E7            pop d
1515   0CA2 5A            add d, b
1516   0CA3 E4            pop a
1517   0CA4 32            mov bl, [d]
1518   0CA5 A7 00         mov bh, 0
1519   0CA7 DD            push bl
1520   0CA8 07 9F 0D      call putchar
1521   0CAB 51 01 00      add sp, 1
1522   0CAE 0A 76 0C      jmp _while19_cond
1523   0CB1             _while19_exit:
1524   0CB1 F9            leave
1525   0CB2 09            ret
1526   0CB3             
1527   0CB3             printu:
1528   0CB3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1529   0CB6             ; $digits 
1530   0CB6             ; $i 
1531   0CB6 52 07 00      sub sp, 7
1532   0CB9             ;; i = 0; 
1533   0CB9 FA FA FF      lea d, [bp + -6] ; $i
1534   0CBC DA            push d
1535   0CBD 26 00 00      mov b, $0
1536   0CC0 E7            pop d
1537   0CC1 FD 43         mov [d], b
1538   0CC3             ;; if(num == 0){ 
1539   0CC3             _if20_cond:
1540   0CC3 FA 05 00      lea d, [bp + 5] ; $num
1541   0CC6 2A            mov b, [d]
1542   0CC7             ; START RELATIONAL
1543   0CC7 D7            push a
1544   0CC8 11            mov a, b
1545   0CC9 26 00 00      mov b, $0
1546   0CCC B0            cmp a, b
1547   0CCD FD 71         seq ; ==
1548   0CCF E4            pop a
1549   0CD0             ; END RELATIONAL
1550   0CD0 C0 00 00      cmp b, 0
1551   0CD3 C6 E5 0C      je _if20_exit
1552   0CD6             _if20_true:
1553   0CD6             ;; putchar('0'); 
1554   0CD6 26 30 00      mov b, $30
1555   0CD9 DD            push bl
1556   0CDA 07 9F 0D      call putchar
1557   0CDD 51 01 00      add sp, 1
1558   0CE0             ;; return; 
1559   0CE0 F9            leave
1560   0CE1 09            ret
1561   0CE2 0A E5 0C      jmp _if20_exit
1562   0CE5             _if20_exit:
1563   0CE5             ;; while (num > 0) { 
1564   0CE5             _while21_cond:
1565   0CE5 FA 05 00      lea d, [bp + 5] ; $num
1566   0CE8 2A            mov b, [d]
1567   0CE9             ; START RELATIONAL
1568   0CE9 D7            push a
1569   0CEA 11            mov a, b
1570   0CEB 26 00 00      mov b, $0
1571   0CEE B0            cmp a, b
1572   0CEF FD 81         sgu ; > (unsigned)
1573   0CF1 E4            pop a
1574   0CF2             ; END RELATIONAL
1575   0CF2 C0 00 00      cmp b, 0
1576   0CF5 C6 42 0D      je _while21_exit
1577   0CF8             _while21_block:
1578   0CF8             ;; digits[i] = '0' + (num % 10); 
1579   0CF8 FA FC FF      lea d, [bp + -4] ; $digits
1580   0CFB D7            push a
1581   0CFC DA            push d
1582   0CFD FA FA FF      lea d, [bp + -6] ; $i
1583   0D00 2A            mov b, [d]
1584   0D01 E7            pop d
1585   0D02 5A            add d, b
1586   0D03 E4            pop a
1587   0D04 DA            push d
1588   0D05 26 30 00      mov b, $30
1589   0D08             ; START TERMS
1590   0D08 D7            push a
1591   0D09 11            mov a, b
1592   0D0A FA 05 00      lea d, [bp + 5] ; $num
1593   0D0D 2A            mov b, [d]
1594   0D0E             ; START FACTORS
1595   0D0E D7            push a
1596   0D0F 11            mov a, b
1597   0D10 26 0A 00      mov b, $a
1598   0D13 AE            div a, b ; 
1599   0D14 11            mov a, b
1600   0D15 27            mov b, a
1601   0D16 E4            pop a
1602   0D17             ; END FACTORS
1603   0D17 54            add a, b
1604   0D18 27            mov b, a
1605   0D19 E4            pop a
1606   0D1A             ; END TERMS
1607   0D1A E7            pop d
1608   0D1B FD 3E         mov [d], bl
1609   0D1D             ;; num = num / 10; 
1610   0D1D FA 05 00      lea d, [bp + 5] ; $num
1611   0D20 DA            push d
1612   0D21 FA 05 00      lea d, [bp + 5] ; $num
1613   0D24 2A            mov b, [d]
1614   0D25             ; START FACTORS
1615   0D25 D7            push a
1616   0D26 11            mov a, b
1617   0D27 26 0A 00      mov b, $a
1618   0D2A AE            div a, b
1619   0D2B 27            mov b, a
1620   0D2C E4            pop a
1621   0D2D             ; END FACTORS
1622   0D2D E7            pop d
1623   0D2E FD 43         mov [d], b
1624   0D30             ;; i++; 
1625   0D30 FA FA FF      lea d, [bp + -6] ; $i
1626   0D33 2A            mov b, [d]
1627   0D34 FD 79         mov g, b
1628   0D36 FD 77         inc b
1629   0D38 FA FA FF      lea d, [bp + -6] ; $i
1630   0D3B FD 43         mov [d], b
1631   0D3D FD 27         mov b, g
1632   0D3F 0A E5 0C      jmp _while21_cond
1633   0D42             _while21_exit:
1634   0D42             ;; while (i > 0) { 
1635   0D42             _while22_cond:
1636   0D42 FA FA FF      lea d, [bp + -6] ; $i
1637   0D45 2A            mov b, [d]
1638   0D46             ; START RELATIONAL
1639   0D46 D7            push a
1640   0D47 11            mov a, b
1641   0D48 26 00 00      mov b, $0
1642   0D4B B0            cmp a, b
1643   0D4C FD 7F         sgt ; >
1644   0D4E E4            pop a
1645   0D4F             ; END RELATIONAL
1646   0D4F C0 00 00      cmp b, 0
1647   0D52 C6 7D 0D      je _while22_exit
1648   0D55             _while22_block:
1649   0D55             ;; i--; 
1650   0D55 FA FA FF      lea d, [bp + -6] ; $i
1651   0D58 2A            mov b, [d]
1652   0D59 FD 79         mov g, b
1653   0D5B FD 7D         dec b
1654   0D5D FA FA FF      lea d, [bp + -6] ; $i
1655   0D60 FD 43         mov [d], b
1656   0D62 FD 27         mov b, g
1657   0D64             ;; putchar(digits[i]); 
1658   0D64 FA FC FF      lea d, [bp + -4] ; $digits
1659   0D67 D7            push a
1660   0D68 DA            push d
1661   0D69 FA FA FF      lea d, [bp + -6] ; $i
1662   0D6C 2A            mov b, [d]
1663   0D6D E7            pop d
1664   0D6E 5A            add d, b
1665   0D6F E4            pop a
1666   0D70 32            mov bl, [d]
1667   0D71 A7 00         mov bh, 0
1668   0D73 DD            push bl
1669   0D74 07 9F 0D      call putchar
1670   0D77 51 01 00      add sp, 1
1671   0D7A 0A 42 0D      jmp _while22_cond
1672   0D7D             _while22_exit:
1673   0D7D F9            leave
1674   0D7E 09            ret
1675   0D7F             
1676   0D7F             rand:
1677   0D7F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1678   0D82             ; $sec 
1679   0D82 52 01 00      sub sp, 1
1680   0D85             
1681   0D85             ; --- BEGIN INLINE ASM BLOCK
1682   0D85 19 00         mov al, 0
1683   0D87 05 01         syscall sys_rtc					
1684   0D89 1A            mov al, ah
1685   0D8A FA 00 00      lea d, [bp + 0] ; $sec
1686   0D8D 1E            mov al, [d]
1687   0D8E             ; --- END INLINE ASM BLOCK
1688   0D8E             
1689   0D8E             ;; return sec; 
1690   0D8E FA 00 00      lea d, [bp + 0] ; $sec
1691   0D91 32            mov bl, [d]
1692   0D92 A7 00         mov bh, 0
1693   0D94 F9            leave
1694   0D95 09            ret
1695   0D96             
1696   0D96             date:
1697   0D96 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1698   0D99             
1699   0D99             ; --- BEGIN INLINE ASM BLOCK
1700   0D99 19 00         mov al, 0 
1701   0D9B 05 07         syscall sys_datetime
1702   0D9D             ; --- END INLINE ASM BLOCK
1703   0D9D             
1704   0D9D F9            leave
1705   0D9E 09            ret
1706   0D9F             
1707   0D9F             putchar:
1708   0D9F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1709   0DA2             
1710   0DA2             ; --- BEGIN INLINE ASM BLOCK
1711   0DA2 FA 05 00      lea d, [bp + 5] ; $c
1712   0DA5 1E            mov al, [d]
1713   0DA6 23            mov ah, al
1714   0DA7 07 1C 10      call _putchar
1715   0DAA             ; --- END INLINE ASM BLOCK
1716   0DAA             
1717   0DAA F9            leave
1718   0DAB 09            ret
1719   0DAC             
1720   0DAC             getchar:
1721   0DAC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1722   0DAF             ; $c 
1723   0DAF 52 01 00      sub sp, 1
1724   0DB2             
1725   0DB2             ; --- BEGIN INLINE ASM BLOCK
1726   0DB2 07 15 10      call getch
1727   0DB5 1A            mov al, ah
1728   0DB6 FA 00 00      lea d, [bp + 0] ; $c
1729   0DB9 3E            mov [d], al
1730   0DBA             ; --- END INLINE ASM BLOCK
1731   0DBA             
1732   0DBA             ;; return c; 
1733   0DBA FA 00 00      lea d, [bp + 0] ; $c
1734   0DBD 32            mov bl, [d]
1735   0DBE A7 00         mov bh, 0
1736   0DC0 F9            leave
1737   0DC1 09            ret
1738   0DC2             
1739   0DC2             scann:
1740   0DC2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1741   0DC5             ; $m 
1742   0DC5 52 02 00      sub sp, 2
1743   0DC8             
1744   0DC8             ; --- BEGIN INLINE ASM BLOCK
1745   0DC8 07 60 12      call scan_u16d
1746   0DCB FA FF FF      lea d, [bp + -1] ; $m
1747   0DCE 43            mov [d], a
1748   0DCF             ; --- END INLINE ASM BLOCK
1749   0DCF             
1750   0DCF             ;; return m; 
1751   0DCF FA FF FF      lea d, [bp + -1] ; $m
1752   0DD2 2A            mov b, [d]
1753   0DD3 F9            leave
1754   0DD4 09            ret
1755   0DD5             
1756   0DD5             puts:
1757   0DD5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1758   0DD8             
1759   0DD8             ; --- BEGIN INLINE ASM BLOCK
1760   0DD8 FA 05 00      lea d, [bp + 5] ; $s
1761   0DDB 15            mov a, [d]
1762   0DDC 3C            mov d, a
1763   0DDD 07 66 11      call _puts
1764   0DE0 10 00 0A      mov a, $0A00
1765   0DE3 05 03         syscall sys_io
1766   0DE5             ; --- END INLINE ASM BLOCK
1767   0DE5             
1768   0DE5 F9            leave
1769   0DE6 09            ret
1770   0DE7             
1771   0DE7             print:
1772   0DE7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1773   0DEA             
1774   0DEA             ; --- BEGIN INLINE ASM BLOCK
1775   0DEA FA 05 00      lea d, [bp + 5] ; $s
1776   0DED FD 2A         mov d, [d]
1777   0DEF 07 66 11      call _puts
1778   0DF2             ; --- END INLINE ASM BLOCK
1779   0DF2             
1780   0DF2 F9            leave
1781   0DF3 09            ret
1782   0DF4             
1783   0DF4             loadfile:
1784   0DF4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1785   0DF7             
1786   0DF7             ; --- BEGIN INLINE ASM BLOCK
1787   0DF7 FA 07 00      lea d, [bp + 7] ; $destination
1788   0DFA 15            mov a, [d]
1789   0DFB 4F            mov di, a
1790   0DFC FA 05 00      lea d, [bp + 5] ; $filename
1791   0DFF FD 2A         mov d, [d]
1792   0E01 19 14         mov al, 20
1793   0E03 05 04         syscall sys_filesystem
1794   0E05             ; --- END INLINE ASM BLOCK
1795   0E05             
1796   0E05 F9            leave
1797   0E06 09            ret
1798   0E07             
1799   0E07             create_file:
1800   0E07 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1801   0E0A F9            leave
1802   0E0B 09            ret
1803   0E0C             
1804   0E0C             delete_file:
1805   0E0C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1806   0E0F             
1807   0E0F             ; --- BEGIN INLINE ASM BLOCK
1808   0E0F FA 05 00      lea d, [bp + 5] ; $filename
1809   0E12 19 0A         mov al, 10
1810   0E14 05 04         syscall sys_filesystem
1811   0E16             ; --- END INLINE ASM BLOCK
1812   0E16             
1813   0E16 F9            leave
1814   0E17 09            ret
1815   0E18             
1816   0E18             fopen:
1817   0E18 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1818   0E1B F9            leave
1819   0E1C 09            ret
1820   0E1D             
1821   0E1D             fclose:
1822   0E1D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1823   0E20 F9            leave
1824   0E21 09            ret
1825   0E22             
1826   0E22             alloc:
1827   0E22 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1828   0E25             ;; heap_top = heap_top + bytes; 
1829   0E25 3B EF 12      mov d, _heap_top ; $heap_top
1830   0E28 DA            push d
1831   0E29 3B EF 12      mov d, _heap_top ; $heap_top
1832   0E2C 2A            mov b, [d]
1833   0E2D             ; START TERMS
1834   0E2D D7            push a
1835   0E2E 11            mov a, b
1836   0E2F FA 05 00      lea d, [bp + 5] ; $bytes
1837   0E32 2A            mov b, [d]
1838   0E33 54            add a, b
1839   0E34 27            mov b, a
1840   0E35 E4            pop a
1841   0E36             ; END TERMS
1842   0E36 E7            pop d
1843   0E37 FD 43         mov [d], b
1844   0E39             ;; return heap_top - bytes; 
1845   0E39 3B EF 12      mov d, _heap_top ; $heap_top
1846   0E3C 2A            mov b, [d]
1847   0E3D             ; START TERMS
1848   0E3D D7            push a
1849   0E3E 11            mov a, b
1850   0E3F FA 05 00      lea d, [bp + 5] ; $bytes
1851   0E42 2A            mov b, [d]
1852   0E43 60            sub a, b
1853   0E44 27            mov b, a
1854   0E45 E4            pop a
1855   0E46             ; END TERMS
1856   0E46 F9            leave
1857   0E47 09            ret
1858   0E48             
1859   0E48             free:
1860   0E48 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1861   0E4B             ;; return heap_top = heap_top - bytes; 
1862   0E4B 3B EF 12      mov d, _heap_top ; $heap_top
1863   0E4E DA            push d
1864   0E4F 3B EF 12      mov d, _heap_top ; $heap_top
1865   0E52 2A            mov b, [d]
1866   0E53             ; START TERMS
1867   0E53 D7            push a
1868   0E54 11            mov a, b
1869   0E55 FA 05 00      lea d, [bp + 5] ; $bytes
1870   0E58 2A            mov b, [d]
1871   0E59 60            sub a, b
1872   0E5A 27            mov b, a
1873   0E5B E4            pop a
1874   0E5C             ; END TERMS
1875   0E5C E7            pop d
1876   0E5D FD 43         mov [d], b
1877   0E5F F9            leave
1878   0E60 09            ret
1879   0E61             
1880   0E61             exit:
1881   0E61 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1882   0E64             
1883   0E64             ; --- BEGIN INLINE ASM BLOCK
1884   0E64 05 0B         syscall sys_terminate_proc
1885   0E66             ; --- END INLINE ASM BLOCK
1886   0E66             
1887   0E66 F9            leave
1888   0E67 09            ret
1889   0E68             
1890   0E68             load_hex:
1891   0E68 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1892   0E6B             ; $temp 
1893   0E6B 52 02 00      sub sp, 2
1894   0E6E             ;; temp = alloc(32768); 
1895   0E6E FA FF FF      lea d, [bp + -1] ; $temp
1896   0E71 DA            push d
1897   0E72 26 00 80      mov b, $8000
1898   0E75 FD AB         swp b
1899   0E77 D8            push b
1900   0E78 07 22 0E      call alloc
1901   0E7B 51 02 00      add sp, 2
1902   0E7E E7            pop d
1903   0E7F FD 43         mov [d], b
1904   0E81             
1905   0E81             ; --- BEGIN INLINE ASM BLOCK
1906   0E81               
1907   0E81               
1908   0E81               
1909   0E81               
1910   0E81               
1911   0E81             _load_hex:
1912   0E81 D7            push a
1913   0E82 D8            push b
1914   0E83 DA            push d
1915   0E84 E2            push si
1916   0E85 E3            push di
1917   0E86 52 00 80      sub sp, $8000      
1918   0E89 38 00 00      mov c, 0
1919   0E8C 48            mov a, sp
1920   0E8D 77            inc a
1921   0E8E 3C            mov d, a          
1922   0E8F 07 23 10      call _gets        
1923   0E92 4D            mov si, a
1924   0E93             __load_hex_loop:
1925   0E93 F6            lodsb             
1926   0E94 B9 00         cmp al, 0         
1927   0E96 C6 A4 0E      jz __load_hex_ret
1928   0E99 36            mov bh, al
1929   0E9A F6            lodsb
1930   0E9B 2F            mov bl, al
1931   0E9C 07 D9 0F      call _atoi        
1932   0E9F F7            stosb             
1933   0EA0 78            inc c
1934   0EA1 0A 93 0E      jmp __load_hex_loop
1935   0EA4             __load_hex_ret:
1936   0EA4 51 00 80      add sp, $8000
1937   0EA7 F0            pop di
1938   0EA8 EF            pop si
1939   0EA9 E7            pop d
1940   0EAA E5            pop b
1941   0EAB E4            pop a
1942   0EAC             ; --- END INLINE ASM BLOCK
1943   0EAC             
1944   0EAC F9            leave
1945   0EAD 09            ret
1946   0EAE             
1947   0EAE             getparam:
1948   0EAE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1949   0EB1             ; $data 
1950   0EB1 52 01 00      sub sp, 1
1951   0EB4             
1952   0EB4             ; --- BEGIN INLINE ASM BLOCK
1953   0EB4 19 04         mov al, 4
1954   0EB6 FA 05 00      lea d, [bp + 5] ; $address
1955   0EB9 FD 2A         mov d, [d]
1956   0EBB 05 0C         syscall sys_system
1957   0EBD FA 00 00      lea d, [bp + 0] ; $data
1958   0EC0 FD 3E         mov [d], bl
1959   0EC2             ; --- END INLINE ASM BLOCK
1960   0EC2             
1961   0EC2             ;; return data; 
1962   0EC2 FA 00 00      lea d, [bp + 0] ; $data
1963   0EC5 32            mov bl, [d]
1964   0EC6 A7 00         mov bh, 0
1965   0EC8 F9            leave
1966   0EC9 09            ret
1967   0ECA             
1968   0ECA             clear:
1969   0ECA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1970   0ECD             ;; print("\033[2J\033[H"); 
1971   0ECD 26 E5 12      mov b, __s3 ; "\033[2J\033[H"
1972   0ED0 FD AB         swp b
1973   0ED2 D8            push b
1974   0ED3 07 E7 0D      call print
1975   0ED6 51 02 00      add sp, 2
1976   0ED9 F9            leave
1977   0EDA 09            ret
1978   0EDB             
1979   0EDB             printun:
1980   0EDB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1981   0EDE             ;; print(prompt); 
1982   0EDE FA 05 00      lea d, [bp + 5] ; $prompt
1983   0EE1 2A            mov b, [d]
1984   0EE2 FD AB         swp b
1985   0EE4 D8            push b
1986   0EE5 07 E7 0D      call print
1987   0EE8 51 02 00      add sp, 2
1988   0EEB             ;; printu(n); 
1989   0EEB FA 07 00      lea d, [bp + 7] ; $n
1990   0EEE 2A            mov b, [d]
1991   0EEF FD AB         swp b
1992   0EF1 D8            push b
1993   0EF2 07 B3 0C      call printu
1994   0EF5 51 02 00      add sp, 2
1995   0EF8             ;; print("\n"); 
1996   0EF8 26 ED 12      mov b, __s4 ; "\n"
1997   0EFB FD AB         swp b
1998   0EFD D8            push b
1999   0EFE 07 E7 0D      call print
2000   0F01 51 02 00      add sp, 2
2001   0F04 F9            leave
2002   0F05 09            ret
2003   0F06             
2004   0F06             printsn:
2005   0F06 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2006   0F09             ;; print(prompt); 
2007   0F09 FA 05 00      lea d, [bp + 5] ; $prompt
2008   0F0C 2A            mov b, [d]
2009   0F0D FD AB         swp b
2010   0F0F D8            push b
2011   0F10 07 E7 0D      call print
2012   0F13 51 02 00      add sp, 2
2013   0F16             ;; prints(n); 
2014   0F16 FA 07 00      lea d, [bp + 7] ; $n
2015   0F19 2A            mov b, [d]
2016   0F1A FD AB         swp b
2017   0F1C D8            push b
2018   0F1D 07 BE 0B      call prints
2019   0F20 51 02 00      add sp, 2
2020   0F23             ;; print("\n"); 
2021   0F23 26 ED 12      mov b, __s4 ; "\n"
2022   0F26 FD AB         swp b
2023   0F28 D8            push b
2024   0F29 07 E7 0D      call print
2025   0F2C 51 02 00      add sp, 2
2026   0F2F F9            leave
2027   0F30 09            ret
2028   0F31             
2029   0F31             include_stdio_asm:
2030   0F31 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2031   0F34             
2032   0F34             ; --- BEGIN INLINE ASM BLOCK
2033   0F34             .include "lib/stdio.asm"
0001+  0F34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0F34             ; stdio.s
0003+  0F34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0F34             .include "lib/string.asm"
0001++ 0F34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0F34             ; string.s
0003++ 0F34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0F34             
0005++ 0F34             
0006++ 0F34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0F34             ; _strrev
0008++ 0F34             ; reverse a string
0009++ 0F34             ; D = string address
0010++ 0F34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0F34             ; 01234
0012++ 0F34             _strrev:
0013++ 0F34 4B          	pusha
0014++ 0F35 07 7B 0F    	call _strlen	; length in C
0015++ 0F38 12          	mov a, c
0016++ 0F39 AF 01 00    	cmp a, 1
0017++ 0F3C D0 56 0F    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0F3F 7D          	dec a
0019++ 0F40 FD 4E       	mov si, d	; beginning of string
0020++ 0F42 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0F44 59          	add d, a	; end of string
0022++ 0F45 12          	mov a, c
0023++ 0F46 FD 9B       	shr a		; divide by 2
0024++ 0F48 39          	mov c, a	; C now counts the steps
0025++ 0F49             _strrev_L0:
0026++ 0F49 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0F4A F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0F4B 3E          	mov [d], al	; store left char into right side
0029++ 0F4C 1B          	mov al, bl
0030++ 0F4D F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0F4E 7E          	dec c
0032++ 0F4F 7F          	dec d
0033++ 0F50 C2 00 00    	cmp c, 0
0034++ 0F53 C7 49 0F    	jne _strrev_L0
0035++ 0F56             _strrev_end:
0036++ 0F56 4C          	popa
0037++ 0F57 09          	ret
0038++ 0F58             	
0039++ 0F58             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0F58             ; _strchr
0041++ 0F58             ; search string in D for char in AL
0042++ 0F58             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0F58             _strchr:
0044++ 0F58             _strchr_L0:
0045++ 0F58 32          	mov bl, [d]
0046++ 0F59 C1 00       	cmp bl, 0
0047++ 0F5B C6 66 0F    	je _strchr_end
0048++ 0F5E BA          	cmp al, bl
0049++ 0F5F C6 66 0F    	je _strchr_end
0050++ 0F62 79          	inc d
0051++ 0F63 0A 58 0F    	jmp _strchr_L0
0052++ 0F66             _strchr_end:
0053++ 0F66 1B          	mov al, bl
0054++ 0F67 09          	ret
0055++ 0F68             
0056++ 0F68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0F68             ; _strstr
0058++ 0F68             ; find sub-string
0059++ 0F68             ; str1 in SI
0060++ 0F68             ; str2 in DI
0061++ 0F68             ; SI points to end of source string
0062++ 0F68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0F68             _strstr:
0064++ 0F68 DB          	push al
0065++ 0F69 DA          	push d
0066++ 0F6A E3          	push di
0067++ 0F6B             _strstr_loop:
0068++ 0F6B F3          	cmpsb					; compare a byte of the strings
0069++ 0F6C C7 77 0F    	jne _strstr_ret
0070++ 0F6F FC 00 00    	lea d, [di + 0]
0071++ 0F72 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0F74 C7 6B 0F    	jne _strstr_loop				; equal chars but not at end
0073++ 0F77             _strstr_ret:
0074++ 0F77 F0          	pop di
0075++ 0F78 E7          	pop d
0076++ 0F79 E8          	pop al
0077++ 0F7A 09          	ret
0078++ 0F7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0F7B             ; length of null terminated string
0080++ 0F7B             ; result in C
0081++ 0F7B             ; pointer in D
0082++ 0F7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0F7B             _strlen:
0084++ 0F7B DA          	push d
0085++ 0F7C 38 00 00    	mov c, 0
0086++ 0F7F             _strlen_L1:
0087++ 0F7F BD 00       	cmp byte [d], 0
0088++ 0F81 C6 89 0F    	je _strlen_ret
0089++ 0F84 79          	inc d
0090++ 0F85 78          	inc c
0091++ 0F86 0A 7F 0F    	jmp _strlen_L1
0092++ 0F89             _strlen_ret:
0093++ 0F89 E7          	pop d
0094++ 0F8A 09          	ret
0095++ 0F8B             
0096++ 0F8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0F8B             ; STRCMP
0098++ 0F8B             ; compare two strings
0099++ 0F8B             ; str1 in SI
0100++ 0F8B             ; str2 in DI
0101++ 0F8B             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0F8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0F8B             _strcmp:
0104++ 0F8B DB          	push al
0105++ 0F8C DA          	push d
0106++ 0F8D E3          	push di
0107++ 0F8E E2          	push si
0108++ 0F8F             _strcmp_loop:
0109++ 0F8F F3          	cmpsb					; compare a byte of the strings
0110++ 0F90 C7 9B 0F    	jne _strcmp_ret
0111++ 0F93 FB FF FF    	lea d, [si +- 1]
0112++ 0F96 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0F98 C7 8F 0F    	jne _strcmp_loop				; equal chars but not at end
0114++ 0F9B             _strcmp_ret:
0115++ 0F9B EF          	pop si
0116++ 0F9C F0          	pop di
0117++ 0F9D E7          	pop d
0118++ 0F9E E8          	pop al
0119++ 0F9F 09          	ret
0120++ 0FA0             
0121++ 0FA0             
0122++ 0FA0             ; STRCPY
0123++ 0FA0             ; copy null terminated string from SI to DI
0124++ 0FA0             ; source in SI
0125++ 0FA0             ; destination in DI
0126++ 0FA0             _strcpy:
0127++ 0FA0 E2          	push si
0128++ 0FA1 E3          	push di
0129++ 0FA2 DB          	push al
0130++ 0FA3             _strcpy_L1:
0131++ 0FA3 F6          	lodsb
0132++ 0FA4 F7          	stosb
0133++ 0FA5 B9 00       	cmp al, 0
0134++ 0FA7 C7 A3 0F    	jne _strcpy_L1
0135++ 0FAA             _strcpy_end:
0136++ 0FAA E8          	pop al
0137++ 0FAB F0          	pop di
0138++ 0FAC EF          	pop si
0139++ 0FAD 09          	ret
0140++ 0FAE             
0141++ 0FAE             ; STRCAT
0142++ 0FAE             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0FAE             ; source in SI
0144++ 0FAE             ; destination in DI
0145++ 0FAE             _strcat:
0146++ 0FAE E2          	push si
0147++ 0FAF E3          	push di
0148++ 0FB0 D7          	push a
0149++ 0FB1 DA          	push d
0150++ 0FB2 50          	mov a, di
0151++ 0FB3 3C          	mov d, a
0152++ 0FB4             _strcat_goto_end_L1:
0153++ 0FB4 BD 00       	cmp byte[d], 0
0154++ 0FB6 C6 BD 0F    	je _strcat_start
0155++ 0FB9 79          	inc d
0156++ 0FBA 0A B4 0F    	jmp _strcat_goto_end_L1
0157++ 0FBD             _strcat_start:
0158++ 0FBD FD 50       	mov di, d
0159++ 0FBF             _strcat_L1:
0160++ 0FBF F6          	lodsb
0161++ 0FC0 F7          	stosb
0162++ 0FC1 B9 00       	cmp al, 0
0163++ 0FC3 C7 BF 0F    	jne _strcat_L1
0164++ 0FC6             _strcat_end:
0165++ 0FC6 E7          	pop d
0166++ 0FC7 E4          	pop a
0167++ 0FC8 F0          	pop di
0168++ 0FC9 EF          	pop si
0169++ 0FCA 09          	ret
0170++ 0FCB             
0171++ 0FCB             
0005+  0FCB             
0006+  0FCB             
0007+  0FCB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0FCB             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0FCB             ; ASCII in BL
0010+  0FCB             ; result in AL
0011+  0FCB             ; ascii for F = 0100 0110
0012+  0FCB             ; ascii for 9 = 0011 1001
0013+  0FCB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0FCB             hex_ascii_encode:
0015+  0FCB 1B            mov al, bl
0016+  0FCC 93 40         test al, $40        ; test if letter or number
0017+  0FCE C7 D4 0F      jnz hex_letter
0018+  0FD1 87 0F         and al, $0F        ; get number
0019+  0FD3 09            ret
0020+  0FD4             hex_letter:
0021+  0FD4 87 0F         and al, $0F        ; get letter
0022+  0FD6 6A 09         add al, 9
0023+  0FD8 09            ret
0024+  0FD9             
0025+  0FD9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0FD9             ; ATOI
0027+  0FD9             ; 2 letter hex string in B
0028+  0FD9             ; 8bit integer returned in AL
0029+  0FD9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0FD9             _atoi:
0031+  0FD9 D8            push b
0032+  0FDA 07 CB 0F      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0FDD 30            mov bl, bh
0034+  0FDE DB            push al          ; save a
0035+  0FDF 07 CB 0F      call hex_ascii_encode
0036+  0FE2 EA            pop bl  
0037+  0FE3 FD 9E 04      shl al, 4
0038+  0FE6 8C            or al, bl
0039+  0FE7 E5            pop b
0040+  0FE8 09            ret  
0041+  0FE9             
0042+  0FE9             
0043+  0FE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0FE9             ; scanf
0045+  0FE9             ; no need for explanations!
0046+  0FE9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0FE9             scanf:
0048+  0FE9 09            ret
0049+  0FEA             
0050+  0FEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0FEA             ; ITOA
0052+  0FEA             ; 8bit value in BL
0053+  0FEA             ; 2 byte ASCII result in A
0054+  0FEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0FEA             _itoa:
0056+  0FEA DA            push d
0057+  0FEB D8            push b
0058+  0FEC A7 00         mov bh, 0
0059+  0FEE FD A4 04      shr bl, 4  
0060+  0FF1 74            mov d, b
0061+  0FF2 1F 9A 12      mov al, [d + s_hex_digits]
0062+  0FF5 23            mov ah, al
0063+  0FF6               
0064+  0FF6 E5            pop b
0065+  0FF7 D8            push b
0066+  0FF8 A7 00         mov bh, 0
0067+  0FFA FD 87 0F      and bl, $0F
0068+  0FFD 74            mov d, b
0069+  0FFE 1F 9A 12      mov al, [d + s_hex_digits]
0070+  1001 E5            pop b
0071+  1002 E7            pop d
0072+  1003 09            ret
0073+  1004             
0074+  1004             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1004             ; HEX STRING TO BINARY
0076+  1004             ; di = destination address
0077+  1004             ; si = source
0078+  1004             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1004             _hex_to_int:
0080+  1004             _hex_to_int_L1:
0081+  1004 F6            lodsb          ; load from [SI] to AL
0082+  1005 B9 00         cmp al, 0        ; check if ASCII 0
0083+  1007 C6 14 10      jz _hex_to_int_ret
0084+  100A 36            mov bh, al
0085+  100B F6            lodsb
0086+  100C 2F            mov bl, al
0087+  100D 07 D9 0F      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  1010 F7            stosb          ; store AL to [DI]
0089+  1011 0A 04 10      jmp _hex_to_int_L1
0090+  1014             _hex_to_int_ret:
0091+  1014 09            ret    
0092+  1015             
0093+  1015             
0094+  1015             
0095+  1015             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1015             ; GETCHAR
0097+  1015             ; char in ah
0098+  1015             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1015             getch:
0100+  1015 DB            push al
0101+  1016             getch_retry:
0102+  1016 19 01         mov al, 1
0103+  1018 05 03         syscall sys_io      ; receive in AH
0104+  101A E8            pop al
0105+  101B 09            ret
0106+  101C             
0107+  101C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  101C             ; PUTCHAR
0109+  101C             ; char in ah
0110+  101C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  101C             _putchar:
0112+  101C D7            push a
0113+  101D 19 00         mov al, 0
0114+  101F 05 03         syscall sys_io      ; char in AH
0115+  1021 E4            pop a
0116+  1022 09            ret
0117+  1023             
0118+  1023             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1023             ;; INPUT A STRING
0120+  1023             ;; terminates with null
0121+  1023             ;; pointer in D
0122+  1023             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1023             _gets:
0124+  1023 D7            push a
0125+  1024 DA            push d
0126+  1025             _gets_loop:
0127+  1025 19 01         mov al, 1
0128+  1027 05 03         syscall sys_io      ; receive in AH
0129+  1029 B9 00         cmp al, 0        ; check error code (AL)
0130+  102B C6 25 10      je _gets_loop      ; if no char received, retry
0131+  102E             
0132+  102E 76 1B         cmp ah, 27
0133+  1030 C6 51 10      je _gets_ansi_esc
0134+  1033 76 0A         cmp ah, $0A        ; LF
0135+  1035 C6 BC 10      je _gets_end
0136+  1038 76 0D         cmp ah, $0D        ; CR
0137+  103A C6 BC 10      je _gets_end
0138+  103D 76 5C         cmp ah, $5C        ; '\\'
0139+  103F C6 7D 10      je _gets_escape
0140+  1042               
0141+  1042 76 08         cmp ah, $08      ; check for backspace
0142+  1044 C6 4D 10      je _gets_backspace
0143+  1047             
0144+  1047 1A            mov al, ah
0145+  1048 3E            mov [d], al
0146+  1049 79            inc d
0147+  104A 0A 25 10      jmp _gets_loop
0148+  104D             _gets_backspace:
0149+  104D 7F            dec d
0150+  104E 0A 25 10      jmp _gets_loop
0151+  1051             _gets_ansi_esc:
0152+  1051 19 01         mov al, 1
0153+  1053 05 03         syscall sys_io        ; receive in AH without echo
0154+  1055 B9 00         cmp al, 0          ; check error code (AL)
0155+  1057 C6 51 10      je _gets_ansi_esc    ; if no char received, retry
0156+  105A 76 5B         cmp ah, '['
0157+  105C C7 25 10      jne _gets_loop
0158+  105F             _gets_ansi_esc_2:
0159+  105F 19 01         mov al, 1
0160+  1061 05 03         syscall sys_io          ; receive in AH without echo
0161+  1063 B9 00         cmp al, 0            ; check error code (AL)
0162+  1065 C6 5F 10      je _gets_ansi_esc_2  ; if no char received, retry
0163+  1068 76 44         cmp ah, 'D'
0164+  106A C6 75 10      je _gets_left_arrow
0165+  106D 76 43         cmp ah, 'C'
0166+  106F C6 79 10      je _gets_right_arrow
0167+  1072 0A 25 10      jmp _gets_loop
0168+  1075             _gets_left_arrow:
0169+  1075 7F            dec d
0170+  1076 0A 25 10      jmp _gets_loop
0171+  1079             _gets_right_arrow:
0172+  1079 79            inc d
0173+  107A 0A 25 10      jmp _gets_loop
0174+  107D             _gets_escape:
0175+  107D 19 01         mov al, 1
0176+  107F 05 03         syscall sys_io      ; receive in AH
0177+  1081 B9 00         cmp al, 0        ; check error code (AL)
0178+  1083 C6 7D 10      je _gets_escape      ; if no char received, retry
0179+  1086 76 6E         cmp ah, 'n'
0180+  1088 C6 A7 10      je _gets_LF
0181+  108B 76 72         cmp ah, 'r'
0182+  108D C6 AE 10      je _gets_CR
0183+  1090 76 30         cmp ah, '0'
0184+  1092 C6 B5 10      je _gets_NULL
0185+  1095 76 5C         cmp ah, $5C  ; '\'
0186+  1097 C6 A0 10      je _gets_slash
0187+  109A 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  109B 3E            mov [d], al
0189+  109C 79            inc d
0190+  109D 0A 25 10      jmp _gets_loop
0191+  10A0             _gets_slash:
0192+  10A0 19 5C         mov al, $5C
0193+  10A2 3E            mov [d], al
0194+  10A3 79            inc d
0195+  10A4 0A 25 10      jmp _gets_loop
0196+  10A7             _gets_LF:
0197+  10A7 19 0A         mov al, $0A
0198+  10A9 3E            mov [d], al
0199+  10AA 79            inc d
0200+  10AB 0A 25 10      jmp _gets_loop
0201+  10AE             _gets_CR:
0202+  10AE 19 0D         mov al, $0D
0203+  10B0 3E            mov [d], al
0204+  10B1 79            inc d
0205+  10B2 0A 25 10      jmp _gets_loop
0206+  10B5             _gets_NULL:
0207+  10B5 19 00         mov al, $00
0208+  10B7 3E            mov [d], al
0209+  10B8 79            inc d
0210+  10B9 0A 25 10      jmp _gets_loop
0211+  10BC             _gets_end:
0212+  10BC 19 00         mov al, 0
0213+  10BE 3E            mov [d], al        ; terminate string
0214+  10BF E7            pop d
0215+  10C0 E4            pop a
0216+  10C1 09            ret
0217+  10C2             
0218+  10C2             
0219+  10C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  10C2             ;; INPUT TEXT
0221+  10C2             ;; terminated with CTRL+D
0222+  10C2             ;; pointer in D
0223+  10C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  10C2             _gettxt:
0225+  10C2 D7            push a
0226+  10C3 DA            push d
0227+  10C4             _gettxt_loop:
0228+  10C4 19 01         mov al, 1
0229+  10C6 05 03         syscall sys_io      ; receive in AH
0230+  10C8 B9 00         cmp al, 0        ; check error code (AL)
0231+  10CA C6 C4 10      je _gettxt_loop    ; if no char received, retry
0232+  10CD 76 04         cmp ah, 4      ; EOT
0233+  10CF C6 0D 11      je _gettxt_end
0234+  10D2 76 08         cmp ah, $08      ; check for backspace
0235+  10D4 C6 09 11      je _gettxt_backspace
0236+  10D7 76 5C         cmp ah, $5C        ; '\'
0237+  10D9 C6 E2 10      je _gettxt_escape
0238+  10DC 1A            mov al, ah
0239+  10DD 3E            mov [d], al
0240+  10DE 79            inc d
0241+  10DF 0A C4 10      jmp _gettxt_loop
0242+  10E2             _gettxt_escape:
0243+  10E2 19 01         mov al, 1
0244+  10E4 05 03         syscall sys_io      ; receive in AH
0245+  10E6 B9 00         cmp al, 0        ; check error code (AL)
0246+  10E8 C6 E2 10      je _gettxt_escape    ; if no char received, retry
0247+  10EB 76 6E         cmp ah, 'n'
0248+  10ED C6 FB 10      je _gettxt_LF
0249+  10F0 76 72         cmp ah, 'r'
0250+  10F2 C6 02 11      je _gettxt_CR
0251+  10F5 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  10F6 3E            mov [d], al
0253+  10F7 79            inc d
0254+  10F8 0A C4 10      jmp _gettxt_loop
0255+  10FB             _gettxt_LF:
0256+  10FB 19 0A         mov al, $0A
0257+  10FD 3E            mov [d], al
0258+  10FE 79            inc d
0259+  10FF 0A C4 10      jmp _gettxt_loop
0260+  1102             _gettxt_CR:
0261+  1102 19 0D         mov al, $0D
0262+  1104 3E            mov [d], al
0263+  1105 79            inc d
0264+  1106 0A C4 10      jmp _gettxt_loop
0265+  1109             _gettxt_backspace:
0266+  1109 7F            dec d
0267+  110A 0A C4 10      jmp _gettxt_loop
0268+  110D             _gettxt_end:
0269+  110D 19 00         mov al, 0
0270+  110F 3E            mov [d], al        ; terminate string
0271+  1110 E7            pop d
0272+  1111 E4            pop a
0273+  1112 09            ret
0274+  1113             
0275+  1113             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1113             ; PRINT NEW LINE
0277+  1113             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  1113             printnl:
0279+  1113 D7            push a
0280+  1114 10 00 0A      mov a, $0A00
0281+  1117 05 03         syscall sys_io
0282+  1119 10 00 0D      mov a, $0D00
0283+  111C 05 03         syscall sys_io
0284+  111E E4            pop a
0285+  111F 09            ret
0286+  1120             
0287+  1120             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  1120             ; _strtoint
0289+  1120             ; 4 digit hex string number in d
0290+  1120             ; integer returned in A
0291+  1120             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  1120             _strtointx:
0293+  1120 D8            push b
0294+  1121 32            mov bl, [d]
0295+  1122 37            mov bh, bl
0296+  1123 33 01 00      mov bl, [d + 1]
0297+  1126 07 D9 0F      call _atoi        ; convert to int in AL
0298+  1129 23            mov ah, al        ; move to AH
0299+  112A 33 02 00      mov bl, [d + 2]
0300+  112D 37            mov bh, bl
0301+  112E 33 03 00      mov bl, [d + 3]
0302+  1131 07 D9 0F      call _atoi        ; convert to int in AL
0303+  1134 E5            pop b
0304+  1135 09            ret
0305+  1136             
0306+  1136             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  1136             ; _strtoint
0308+  1136             ; 5 digit base10 string number in d
0309+  1136             ; integer returned in A
0310+  1136             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  1136             _strtoint:
0312+  1136 E2            push si
0313+  1137 D8            push b
0314+  1138 D9            push c
0315+  1139 DA            push d
0316+  113A 07 7B 0F      call _strlen      ; get string length in C
0317+  113D 7E            dec c
0318+  113E FD 4E         mov si, d
0319+  1140 12            mov a, c
0320+  1141 FD 99         shl a
0321+  1143 3B B2 12      mov d, table_power
0322+  1146 59            add d, a
0323+  1147 38 00 00      mov c, 0
0324+  114A             _strtoint_L0:
0325+  114A F6            lodsb      ; load ASCII to al
0326+  114B B9 00         cmp al, 0
0327+  114D C6 60 11      je _strtoint_end
0328+  1150 6F 30         sub al, $30    ; make into integer
0329+  1152 22 00         mov ah, 0
0330+  1154 2A            mov b, [d]
0331+  1155 AC            mul a, b      ; result in B since it fits in 16bits
0332+  1156 11            mov a, b
0333+  1157 28            mov b, c
0334+  1158 54            add a, b
0335+  1159 39            mov c, a
0336+  115A 63 02 00      sub d, 2
0337+  115D 0A 4A 11      jmp _strtoint_L0
0338+  1160             _strtoint_end:
0339+  1160 12            mov a, c
0340+  1161 E7            pop d
0341+  1162 E6            pop c
0342+  1163 E5            pop b
0343+  1164 EF            pop si
0344+  1165 09            ret
0345+  1166             
0346+  1166             
0347+  1166             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  1166             ; PRINT NULL TERMINATED STRING
0349+  1166             ; pointer in D
0350+  1166             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  1166             _puts:
0352+  1166 D7            push a
0353+  1167 DA            push d
0354+  1168             _puts_L1:
0355+  1168 1E            mov al, [d]
0356+  1169 B9 00         cmp al, 0
0357+  116B C6 77 11      jz _puts_END
0358+  116E 23            mov ah, al
0359+  116F 19 00         mov al, 0
0360+  1171 05 03         syscall sys_io
0361+  1173 79            inc d
0362+  1174 0A 68 11      jmp _puts_L1
0363+  1177             _puts_END:
0364+  1177 E7            pop d
0365+  1178 E4            pop a
0366+  1179 09            ret
0367+  117A             
0368+  117A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  117A             ; PRINT N SIZE STRING
0370+  117A             ; pointer in D
0371+  117A             ; size in C
0372+  117A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  117A             _putsn:
0374+  117A DB            push al
0375+  117B DA            push d
0376+  117C D9            push c
0377+  117D             _putsn_L0:
0378+  117D 1E            mov al, [d]
0379+  117E 23            mov ah, al
0380+  117F 19 00         mov al, 0
0381+  1181 05 03         syscall sys_io
0382+  1183 79            inc d
0383+  1184 7E            dec c  
0384+  1185 C2 00 00      cmp c, 0
0385+  1188 C7 7D 11      jne _putsn_L0
0386+  118B             _putsn_end:
0387+  118B E6            pop c
0388+  118C E7            pop d
0389+  118D E8            pop al
0390+  118E 09            ret
0391+  118F             
0392+  118F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  118F             ; print 16bit decimal number
0394+  118F             ; input number in A
0395+  118F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  118F             print_u16d:
0397+  118F D7            push a
0398+  1190 D8            push b
0399+  1191 26 10 27      mov b, 10000
0400+  1194 AE            div a, b      ; get 10000's coeff.
0401+  1195 07 B7 11      call print_number
0402+  1198 11            mov a, b
0403+  1199 26 E8 03      mov b, 1000
0404+  119C AE            div a, b      ; get 1000's coeff.
0405+  119D 07 B7 11      call print_number
0406+  11A0 11            mov a, b
0407+  11A1 26 64 00      mov b, 100
0408+  11A4 AE            div a, b
0409+  11A5 07 B7 11      call print_number
0410+  11A8 11            mov a, b
0411+  11A9 26 0A 00      mov b, 10
0412+  11AC AE            div a, b
0413+  11AD 07 B7 11      call print_number
0414+  11B0 1B            mov al, bl      ; 1's coeff in bl
0415+  11B1 07 B7 11      call print_number
0416+  11B4 E5            pop b
0417+  11B5 E4            pop a
0418+  11B6 09            ret
0419+  11B7             
0420+  11B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  11B7             ; print AL
0422+  11B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  11B7             print_number:
0424+  11B7 6A 30         add al, $30
0425+  11B9 23            mov ah, al
0426+  11BA 07 1C 10      call _putchar
0427+  11BD 09            ret
0428+  11BE             
0429+  11BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  11BE             ; PRINT 16BIT HEX INTEGER
0431+  11BE             ; integer value in reg B
0432+  11BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  11BE             print_u16x:
0434+  11BE D7            push a
0435+  11BF D8            push b
0436+  11C0 DD            push bl
0437+  11C1 30            mov bl, bh
0438+  11C2 07 EA 0F      call _itoa        ; convert bh to char in A
0439+  11C5 2F            mov bl, al        ; save al
0440+  11C6 19 00         mov al, 0
0441+  11C8 05 03         syscall sys_io        ; display AH
0442+  11CA 24            mov ah, bl        ; retrieve al
0443+  11CB 19 00         mov al, 0
0444+  11CD 05 03         syscall sys_io        ; display AL
0445+  11CF             
0446+  11CF EA            pop bl
0447+  11D0 07 EA 0F      call _itoa        ; convert bh to char in A
0448+  11D3 2F            mov bl, al        ; save al
0449+  11D4 19 00         mov al, 0
0450+  11D6 05 03         syscall sys_io        ; display AH
0451+  11D8 24            mov ah, bl        ; retrieve al
0452+  11D9 19 00         mov al, 0
0453+  11DB 05 03         syscall sys_io        ; display AL
0454+  11DD             
0455+  11DD E5            pop b
0456+  11DE E4            pop a
0457+  11DF 09            ret
0458+  11E0             
0459+  11E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  11E0             ; INPUT 16BIT HEX INTEGER
0461+  11E0             ; read 16bit integer into A
0462+  11E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  11E0             scan_u16x:
0464+  11E0 F8 10 00      enter 16
0465+  11E3 D8            push b
0466+  11E4 DA            push d
0467+  11E5             
0468+  11E5 FA F1 FF      lea d, [bp + -15]
0469+  11E8 07 23 10      call _gets        ; get number
0470+  11EB             
0471+  11EB 32            mov bl, [d]
0472+  11EC 37            mov bh, bl
0473+  11ED 33 01 00      mov bl, [d + 1]
0474+  11F0 07 D9 0F      call _atoi        ; convert to int in AL
0475+  11F3 23            mov ah, al        ; move to AH
0476+  11F4             
0477+  11F4 33 02 00      mov bl, [d + 2]
0478+  11F7 37            mov bh, bl
0479+  11F8 33 03 00      mov bl, [d + 3]
0480+  11FB 07 D9 0F      call _atoi        ; convert to int in AL
0481+  11FE             
0482+  11FE E7            pop d
0483+  11FF E5            pop b
0484+  1200 F9            leave
0485+  1201 09            ret
0486+  1202             
0487+  1202             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  1202             ; PRINT 8bit HEX INTEGER
0489+  1202             ; integer value in reg bl
0490+  1202             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  1202             print_u8x:
0492+  1202 D7            push a
0493+  1203 DD            push bl
0494+  1204             
0495+  1204 07 EA 0F      call _itoa        ; convert bl to char in A
0496+  1207 2F            mov bl, al        ; save al
0497+  1208 19 00         mov al, 0
0498+  120A 05 03         syscall sys_io        ; display AH
0499+  120C 24            mov ah, bl        ; retrieve al
0500+  120D 19 00         mov al, 0
0501+  120F 05 03         syscall sys_io        ; display AL
0502+  1211             
0503+  1211 EA            pop bl
0504+  1212 E4            pop a
0505+  1213 09            ret
0506+  1214             
0507+  1214             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  1214             ; print 8bit decimal unsigned number
0509+  1214             ; input number in AL
0510+  1214             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  1214             print_u8d:
0512+  1214 D7            push a
0513+  1215 D8            push b
0514+  1216             
0515+  1216 22 00         mov ah, 0
0516+  1218 26 64 00      mov b, 100
0517+  121B AE            div a, b
0518+  121C D8            push b      ; save remainder
0519+  121D B9 00         cmp al, 0
0520+  121F C6 29 12      je skip100
0521+  1222 6A 30         add al, $30
0522+  1224 23            mov ah, al
0523+  1225 19 00         mov al, 0
0524+  1227 05 03         syscall sys_io  ; print coeff
0525+  1229             skip100:
0526+  1229 E4            pop a
0527+  122A 22 00         mov ah, 0
0528+  122C 26 0A 00      mov b, 10
0529+  122F AE            div a, b
0530+  1230 D8            push b      ; save remainder
0531+  1231 B9 00         cmp al, 0
0532+  1233 C6 3D 12      je skip10
0533+  1236 6A 30         add al, $30
0534+  1238 23            mov ah, al
0535+  1239 19 00         mov al, 0
0536+  123B 05 03         syscall sys_io  ; print coeff
0537+  123D             skip10:
0538+  123D E4            pop a
0539+  123E 1B            mov al, bl
0540+  123F 6A 30         add al, $30
0541+  1241 23            mov ah, al
0542+  1242 19 00         mov al, 0
0543+  1244 05 03         syscall sys_io  ; print coeff
0544+  1246 E5            pop b
0545+  1247 E4            pop a
0546+  1248 09            ret
0547+  1249             
0548+  1249             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  1249             ; INPUT 8BIT HEX INTEGER
0550+  1249             ; read 8bit integer into AL
0551+  1249             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  1249             scan_u8x:
0553+  1249 F8 04 00      enter 4
0554+  124C D8            push b
0555+  124D DA            push d
0556+  124E             
0557+  124E FA FD FF      lea d, [bp + -3]
0558+  1251 07 23 10      call _gets        ; get number
0559+  1254             
0560+  1254 32            mov bl, [d]
0561+  1255 37            mov bh, bl
0562+  1256 33 01 00      mov bl, [d + 1]
0563+  1259 07 D9 0F      call _atoi        ; convert to int in AL
0564+  125C             
0565+  125C E7            pop d
0566+  125D E5            pop b
0567+  125E F9            leave
0568+  125F 09            ret
0569+  1260             
0570+  1260             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  1260             ; input decimal number
0572+  1260             ; result in A
0573+  1260             ; 655'\0'
0574+  1260             ; low--------high
0575+  1260             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  1260             scan_u16d:
0577+  1260 F8 08 00      enter 8
0578+  1263 E2            push si
0579+  1264 D8            push b
0580+  1265 D9            push c
0581+  1266 DA            push d
0582+  1267 FA F9 FF      lea d, [bp +- 7]
0583+  126A 07 23 10      call _gets
0584+  126D 07 7B 0F      call _strlen      ; get string length in C
0585+  1270 7E            dec c
0586+  1271 FD 4E         mov si, d
0587+  1273 12            mov a, c
0588+  1274 FD 99         shl a
0589+  1276 3B B2 12      mov d, table_power
0590+  1279 59            add d, a
0591+  127A 38 00 00      mov c, 0
0592+  127D             mul_loop:
0593+  127D F6            lodsb      ; load ASCII to al
0594+  127E B9 00         cmp al, 0
0595+  1280 C6 93 12      je mul_exit
0596+  1283 6F 30         sub al, $30    ; make into integer
0597+  1285 22 00         mov ah, 0
0598+  1287 2A            mov b, [d]
0599+  1288 AC            mul a, b      ; result in B since it fits in 16bits
0600+  1289 11            mov a, b
0601+  128A 28            mov b, c
0602+  128B 54            add a, b
0603+  128C 39            mov c, a
0604+  128D 63 02 00      sub d, 2
0605+  1290 0A 7D 12      jmp mul_loop
0606+  1293             mul_exit:
0607+  1293 12            mov a, c
0608+  1294 E7            pop d
0609+  1295 E6            pop c
0610+  1296 E5            pop b
0611+  1297 EF            pop si
0612+  1298 F9            leave
0613+  1299 09            ret
0614+  129A             
0615+  129A             
0616+  129A 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  129E 34 35 36 37 
0616+  12A2 38 39 41 42 
0616+  12A6 43 44 45 46 
0617+  12AA 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  12AE 1B 5B 48 00 
0618+  12B2             
0619+  12B2             table_power:
0620+  12B2 01 00         .dw 1
0621+  12B4 0A 00         .dw 10
0622+  12B6 64 00         .dw 100
0623+  12B8 E8 03         .dw 1000
0624+  12BA 10 27         .dw 100002034   12BC             ; --- END INLINE ASM BLOCK
2035   12BC             
2036   12BC F9            leave
2037   12BD 09            ret
2038   12BE             ; --- END TEXT BLOCK
2039   12BE             
2040   12BE             ; --- BEGIN DATA BLOCK
2041   12BE 25 63 0A 00 __s0: .db "%c\n", 0
2042   12C2 25 64 0A 00 __s1: .db "%d\n", 0
2043   12C6 45 72 72 6F __s2: .db "Error: Unknown argument type.\n", 0
2043   12CA 72 3A 20 55 
2043   12CE 6E 6B 6E 6F 
2043   12D2 77 6E 20 61 
2043   12D6 72 67 75 6D 
2043   12DA 65 6E 74 20 
2043   12DE 74 79 70 65 
2043   12E2 2E 0A 00 
2044   12E5 1B 5B 32 4A __s3: .db "\033[2J\033[H", 0
2044   12E9 1B 5B 48 00 
2045   12ED 0A 00       __s4: .db "\n", 0
2046   12EF             
2047   12EF F1 12       _heap_top: .dw _heap
2048   12F1 00          _heap: .db 0
2049   12F2             ; --- END DATA BLOCK
2050   12F2             
2051   12F2             .end
tasm: Number of errors = 0
