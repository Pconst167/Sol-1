0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; p++; 
0011   0408 3B 68 21      mov d, _p ; $p
0012   040B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0013   040E FD 39         mov c, b ; And place it into C
0014   0410 2A            mov b, [d] ; Lower Word in B
0015   0411 FD 2D 01 00   mov32 ga, 1
0015   0415 00 00 
0016   0417 FD 15         add32 cb, ga
0017   0419 3B 68 21      mov d, _p ; $p
0018   041C 28            mov b, c
0019   041D FD 44 02 00   mov [d+2], b
0020   0421 FD 43         mov [d], b
0021   0423 FD 7A         mov g, c
0022   0425 11            mov a, b
0023   0426 FD 2E 01 00   mov32 cb, 1
0023   042A 00 00 
0024   042C FD 1C         sub32 ga, cb
0025   042E FD 38         mov c, g
0026   0430 27            mov b, a
0027   0431 05 0B         syscall sys_terminate_proc
0028   0433             
0029   0433             strcpy:
0030   0433 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0031   0436             ; char *psrc; 
0032   0436 52 02 00      sub sp, 2
0033   0439             ; char *pdest; 
0034   0439 52 02 00      sub sp, 2
0035   043C             ; psrc = src; 
0036   043C FA FF FF      lea d, [bp + -1] ; $psrc
0037   043F DA            push d
0038   0440 FA 07 00      lea d, [bp + 7] ; $src
0039   0443 2A            mov b, [d]
0040   0444 38 00 00      mov c, 0
0041   0447 E7            pop d
0042   0448 FD 43         mov [d], b
0043   044A             ; pdest = dest; 
0044   044A FA FD FF      lea d, [bp + -3] ; $pdest
0045   044D DA            push d
0046   044E FA 05 00      lea d, [bp + 5] ; $dest
0047   0451 2A            mov b, [d]
0048   0452 38 00 00      mov c, 0
0049   0455 E7            pop d
0050   0456 FD 43         mov [d], b
0051   0458             ; while(*psrc) *pdest++ = *psrc++; 
0052   0458             _while1_cond:
0053   0458 FA FF FF      lea d, [bp + -1] ; $psrc
0054   045B 2A            mov b, [d]
0055   045C 38 00 00      mov c, 0
0056   045F 74            mov d, b
0057   0460 32            mov bl, [d]
0058   0461 A7 00         mov bh, 0
0059   0463 38 00 00      mov c, 0
0060   0466 C0 00 00      cmp b, 0
0061   0469 C6 9A 04      je _while1_exit
0062   046C             _while1_block:
0063   046C             ; *pdest++ = *psrc++; 
0064   046C FA FD FF      lea d, [bp + -3] ; $pdest
0065   046F 2A            mov b, [d]
0066   0470 38 00 00      mov c, 0
0067   0473 FD 77         inc b
0068   0475 FA FD FF      lea d, [bp + -3] ; $pdest
0069   0478 FD 3E         mov [d], bl
0070   047A FD 7D         dec b
0071   047C D8            push b
0072   047D FA FF FF      lea d, [bp + -1] ; $psrc
0073   0480 2A            mov b, [d]
0074   0481 38 00 00      mov c, 0
0075   0484 FD 77         inc b
0076   0486 FA FF FF      lea d, [bp + -1] ; $psrc
0077   0489 FD 3E         mov [d], bl
0078   048B FD 7D         dec b
0079   048D 74            mov d, b
0080   048E 32            mov bl, [d]
0081   048F A7 00         mov bh, 0
0082   0491 38 00 00      mov c, 0
0083   0494 E7            pop d
0084   0495 FD 3E         mov [d], bl
0085   0497 0A 58 04      jmp _while1_cond
0086   049A             _while1_exit:
0087   049A             ; *pdest = '\0'; 
0088   049A FA FD FF      lea d, [bp + -3] ; $pdest
0089   049D 2A            mov b, [d]
0090   049E 38 00 00      mov c, 0
0091   04A1 D8            push b
0092   04A2 FD 2E 00 00   mov32 cb, $00000000
0092   04A6 00 00 
0093   04A8 E7            pop d
0094   04A9 FD 3E         mov [d], bl
0095   04AB F9            leave
0096   04AC 09            ret
0097   04AD             
0098   04AD             strcmp:
0099   04AD F8 00 00      enter 0 ; (push bp; mov bp, sp)
0100   04B0             ; while (*s1 && (*s1 == *s2)) { 
0101   04B0             _while2_cond:
0102   04B0 FA 05 00      lea d, [bp + 5] ; $s1
0103   04B3 2A            mov b, [d]
0104   04B4 38 00 00      mov c, 0
0105   04B7 74            mov d, b
0106   04B8 32            mov bl, [d]
0107   04B9 A7 00         mov bh, 0
0108   04BB 38 00 00      mov c, 0
0109   04BE             ; --- START LOGICAL AND
0110   04BE D7            push a
0111   04BF 11            mov a, b
0112   04C0 FA 05 00      lea d, [bp + 5] ; $s1
0113   04C3 2A            mov b, [d]
0114   04C4 38 00 00      mov c, 0
0115   04C7 74            mov d, b
0116   04C8 32            mov bl, [d]
0117   04C9 A7 00         mov bh, 0
0118   04CB 38 00 00      mov c, 0
0119   04CE             ; --- START RELATIONAL
0120   04CE D7            push a
0121   04CF 11            mov a, b
0122   04D0 FA 07 00      lea d, [bp + 7] ; $s2
0123   04D3 2A            mov b, [d]
0124   04D4 38 00 00      mov c, 0
0125   04D7 74            mov d, b
0126   04D8 32            mov bl, [d]
0127   04D9 A7 00         mov bh, 0
0128   04DB 38 00 00      mov c, 0
0129   04DE B0            cmp a, b
0130   04DF FD 71         seq ; ==
0131   04E1 E4            pop a
0132   04E2             ; --- END RELATIONAL
0133   04E2 FD A7         sand a, b
0134   04E4 E4            pop a
0135   04E5             ; --- END LOGICAL AND
0136   04E5 C0 00 00      cmp b, 0
0137   04E8 C6 0E 05      je _while2_exit
0138   04EB             _while2_block:
0139   04EB             ; s1++; 
0140   04EB FA 05 00      lea d, [bp + 5] ; $s1
0141   04EE 2A            mov b, [d]
0142   04EF 38 00 00      mov c, 0
0143   04F2 FD 77         inc b
0144   04F4 FA 05 00      lea d, [bp + 5] ; $s1
0145   04F7 FD 3E         mov [d], bl
0146   04F9 FD 7D         dec b
0147   04FB             ; s2++; 
0148   04FB FA 07 00      lea d, [bp + 7] ; $s2
0149   04FE 2A            mov b, [d]
0150   04FF 38 00 00      mov c, 0
0151   0502 FD 77         inc b
0152   0504 FA 07 00      lea d, [bp + 7] ; $s2
0153   0507 FD 3E         mov [d], bl
0154   0509 FD 7D         dec b
0155   050B 0A B0 04      jmp _while2_cond
0156   050E             _while2_exit:
0157   050E             ; return *s1 - *s2; 
0158   050E FA 05 00      lea d, [bp + 5] ; $s1
0159   0511 2A            mov b, [d]
0160   0512 38 00 00      mov c, 0
0161   0515 74            mov d, b
0162   0516 32            mov bl, [d]
0163   0517 A7 00         mov bh, 0
0164   0519 38 00 00      mov c, 0
0165   051C             ; --- START TERMS
0166   051C D7            push a
0167   051D 11            mov a, b
0168   051E FA 07 00      lea d, [bp + 7] ; $s2
0169   0521 2A            mov b, [d]
0170   0522 38 00 00      mov c, 0
0171   0525 74            mov d, b
0172   0526 32            mov bl, [d]
0173   0527 A7 00         mov bh, 0
0174   0529 38 00 00      mov c, 0
0175   052C 60            sub a, b
0176   052D 27            mov b, a
0177   052E E4            pop a
0178   052F             ; --- END TERMS
0179   052F F9            leave
0180   0530 09            ret
0181   0531             
0182   0531             strncmp:
0183   0531 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0184   0534 F9            leave
0185   0535 09            ret
0186   0536             
0187   0536             strcat:
0188   0536 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0189   0539             ; int dest_len; 
0190   0539 52 02 00      sub sp, 2
0191   053C             ; int i; 
0192   053C 52 02 00      sub sp, 2
0193   053F             ; dest_len = strlen(dest); 
0194   053F FA FF FF      lea d, [bp + -1] ; $dest_len
0195   0542 DA            push d
0196   0543             ; --- START FUNCTION CALL
0197   0543 FA 05 00      lea d, [bp + 5] ; $dest
0198   0546 2A            mov b, [d]
0199   0547 38 00 00      mov c, 0
0200   054A FD AB         swp b
0201   054C D8            push b
0202   054D 07 19 06      call strlen
0203   0550 51 02 00      add sp, 2
0204   0553             ; --- END FUNCTION CALL
0205   0553 E7            pop d
0206   0554 FD 43         mov [d], b
0207   0556             ; for (i = 0; src[i] != 0; i=i+1) { 
0208   0556             _for3_init:
0209   0556 FA FD FF      lea d, [bp + -3] ; $i
0210   0559 DA            push d
0211   055A FD 2E 00 00   mov32 cb, $00000000
0211   055E 00 00 
0212   0560 E7            pop d
0213   0561 FD 43         mov [d], b
0214   0563             _for3_cond:
0215   0563 FA 07 00      lea d, [bp + 7] ; $src
0216   0566 FD 2A         mov d, [d]
0217   0568 D7            push a
0218   0569 DA            push d
0219   056A FA FD FF      lea d, [bp + -3] ; $i
0220   056D 2A            mov b, [d]
0221   056E 38 00 00      mov c, 0
0222   0571 E7            pop d
0223   0572 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0224   0576 E4            pop a
0225   0577 32            mov bl, [d]
0226   0578 A7 00         mov bh, 0
0227   057A 38 00 00      mov c, 0
0228   057D             ; --- START RELATIONAL
0229   057D D7            push a
0230   057E 11            mov a, b
0231   057F FD 2E 00 00   mov32 cb, $00000000
0231   0583 00 00 
0232   0585 B0            cmp a, b
0233   0586 FD 72         sneq ; !=
0234   0588 E4            pop a
0235   0589             ; --- END RELATIONAL
0236   0589 C0 00 00      cmp b, 0
0237   058C C6 E7 05      je _for3_exit
0238   058F             _for3_block:
0239   058F             ; dest[dest_len + i] = src[i]; 
0240   058F FA 05 00      lea d, [bp + 5] ; $dest
0241   0592 FD 2A         mov d, [d]
0242   0594 D7            push a
0243   0595 DA            push d
0244   0596 FA FF FF      lea d, [bp + -1] ; $dest_len
0245   0599 2A            mov b, [d]
0246   059A 38 00 00      mov c, 0
0247   059D             ; --- START TERMS
0248   059D D7            push a
0249   059E 11            mov a, b
0250   059F FA FD FF      lea d, [bp + -3] ; $i
0251   05A2 2A            mov b, [d]
0252   05A3 38 00 00      mov c, 0
0253   05A6 56            add b, a
0254   05A7 E4            pop a
0255   05A8             ; --- END TERMS
0256   05A8 E7            pop d
0257   05A9 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0258   05AD E4            pop a
0259   05AE DA            push d
0260   05AF FA 07 00      lea d, [bp + 7] ; $src
0261   05B2 FD 2A         mov d, [d]
0262   05B4 D7            push a
0263   05B5 DA            push d
0264   05B6 FA FD FF      lea d, [bp + -3] ; $i
0265   05B9 2A            mov b, [d]
0266   05BA 38 00 00      mov c, 0
0267   05BD E7            pop d
0268   05BE FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0269   05C2 E4            pop a
0270   05C3 32            mov bl, [d]
0271   05C4 A7 00         mov bh, 0
0272   05C6 38 00 00      mov c, 0
0273   05C9 E7            pop d
0274   05CA FD 3E         mov [d], bl
0275   05CC             _for3_update:
0276   05CC FA FD FF      lea d, [bp + -3] ; $i
0277   05CF DA            push d
0278   05D0 FA FD FF      lea d, [bp + -3] ; $i
0279   05D3 2A            mov b, [d]
0280   05D4 38 00 00      mov c, 0
0281   05D7             ; --- START TERMS
0282   05D7 D7            push a
0283   05D8 11            mov a, b
0284   05D9 FD 2E 01 00   mov32 cb, $00000001
0284   05DD 00 00 
0285   05DF 56            add b, a
0286   05E0 E4            pop a
0287   05E1             ; --- END TERMS
0288   05E1 E7            pop d
0289   05E2 FD 43         mov [d], b
0290   05E4 0A 63 05      jmp _for3_cond
0291   05E7             _for3_exit:
0292   05E7             ; dest[dest_len + i] = 0; 
0293   05E7 FA 05 00      lea d, [bp + 5] ; $dest
0294   05EA FD 2A         mov d, [d]
0295   05EC D7            push a
0296   05ED DA            push d
0297   05EE FA FF FF      lea d, [bp + -1] ; $dest_len
0298   05F1 2A            mov b, [d]
0299   05F2 38 00 00      mov c, 0
0300   05F5             ; --- START TERMS
0301   05F5 D7            push a
0302   05F6 11            mov a, b
0303   05F7 FA FD FF      lea d, [bp + -3] ; $i
0304   05FA 2A            mov b, [d]
0305   05FB 38 00 00      mov c, 0
0306   05FE 56            add b, a
0307   05FF E4            pop a
0308   0600             ; --- END TERMS
0309   0600 E7            pop d
0310   0601 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0311   0605 E4            pop a
0312   0606 DA            push d
0313   0607 FD 2E 00 00   mov32 cb, $00000000
0313   060B 00 00 
0314   060D E7            pop d
0315   060E FD 3E         mov [d], bl
0316   0610             ; return dest; 
0317   0610 FA 05 00      lea d, [bp + 5] ; $dest
0318   0613 2A            mov b, [d]
0319   0614 38 00 00      mov c, 0
0320   0617 F9            leave
0321   0618 09            ret
0322   0619             
0323   0619             strlen:
0324   0619 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0325   061C             ; int length; 
0326   061C 52 02 00      sub sp, 2
0327   061F             ; length = 0; 
0328   061F FA FF FF      lea d, [bp + -1] ; $length
0329   0622 DA            push d
0330   0623 FD 2E 00 00   mov32 cb, $00000000
0330   0627 00 00 
0331   0629 E7            pop d
0332   062A FD 43         mov [d], b
0333   062C             ; while (str[length] != 0) { 
0334   062C             _while4_cond:
0335   062C FA 05 00      lea d, [bp + 5] ; $str
0336   062F FD 2A         mov d, [d]
0337   0631 D7            push a
0338   0632 DA            push d
0339   0633 FA FF FF      lea d, [bp + -1] ; $length
0340   0636 2A            mov b, [d]
0341   0637 38 00 00      mov c, 0
0342   063A E7            pop d
0343   063B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0344   063F E4            pop a
0345   0640 32            mov bl, [d]
0346   0641 A7 00         mov bh, 0
0347   0643 38 00 00      mov c, 0
0348   0646             ; --- START RELATIONAL
0349   0646 D7            push a
0350   0647 11            mov a, b
0351   0648 FD 2E 00 00   mov32 cb, $00000000
0351   064C 00 00 
0352   064E B0            cmp a, b
0353   064F FD 72         sneq ; !=
0354   0651 E4            pop a
0355   0652             ; --- END RELATIONAL
0356   0652 C0 00 00      cmp b, 0
0357   0655 C6 6B 06      je _while4_exit
0358   0658             _while4_block:
0359   0658             ; length++; 
0360   0658 FA FF FF      lea d, [bp + -1] ; $length
0361   065B 2A            mov b, [d]
0362   065C 38 00 00      mov c, 0
0363   065F 11            mov a, b
0364   0660 FD 77         inc b
0365   0662 FA FF FF      lea d, [bp + -1] ; $length
0366   0665 FD 43         mov [d], b
0367   0667 27            mov b, a
0368   0668 0A 2C 06      jmp _while4_cond
0369   066B             _while4_exit:
0370   066B             ; return length; 
0371   066B FA FF FF      lea d, [bp + -1] ; $length
0372   066E 2A            mov b, [d]
0373   066F 38 00 00      mov c, 0
0374   0672 F9            leave
0375   0673 09            ret
0376   0674             
0377   0674             exit:
0378   0674 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0379   0677             
0380   0677             ; --- BEGIN INLINE ASM SEGMENT
0381   0677 05 0B         syscall sys_terminate_proc
0382   0679             ; --- END INLINE ASM SEGMENT
0383   0679             
0384   0679 F9            leave
0385   067A 09            ret
0386   067B             
0387   067B             memset:
0388   067B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0389   067E             ; int i; 
0390   067E 52 02 00      sub sp, 2
0391   0681             ; for(i = 0; i < size; i++){ 
0392   0681             _for5_init:
0393   0681 FA FF FF      lea d, [bp + -1] ; $i
0394   0684 DA            push d
0395   0685 FD 2E 00 00   mov32 cb, $00000000
0395   0689 00 00 
0396   068B E7            pop d
0397   068C FD 43         mov [d], b
0398   068E             _for5_cond:
0399   068E FA FF FF      lea d, [bp + -1] ; $i
0400   0691 2A            mov b, [d]
0401   0692 38 00 00      mov c, 0
0402   0695             ; --- START RELATIONAL
0403   0695 D7            push a
0404   0696 11            mov a, b
0405   0697 FA 08 00      lea d, [bp + 8] ; $size
0406   069A 2A            mov b, [d]
0407   069B 38 00 00      mov c, 0
0408   069E B0            cmp a, b
0409   069F FD 73         slt ; < (signed)
0410   06A1 E4            pop a
0411   06A2             ; --- END RELATIONAL
0412   06A2 C0 00 00      cmp b, 0
0413   06A5 C6 DA 06      je _for5_exit
0414   06A8             _for5_block:
0415   06A8             ; *(s+i) = c; 
0416   06A8 FA 05 00      lea d, [bp + 5] ; $s
0417   06AB 2A            mov b, [d]
0418   06AC 38 00 00      mov c, 0
0419   06AF             ; --- START TERMS
0420   06AF D7            push a
0421   06B0 11            mov a, b
0422   06B1 FA FF FF      lea d, [bp + -1] ; $i
0423   06B4 2A            mov b, [d]
0424   06B5 38 00 00      mov c, 0
0425   06B8 56            add b, a
0426   06B9 E4            pop a
0427   06BA             ; --- END TERMS
0428   06BA D8            push b
0429   06BB FA 07 00      lea d, [bp + 7] ; $c
0430   06BE 32            mov bl, [d]
0431   06BF A7 00         mov bh, 0
0432   06C1 38 00 00      mov c, 0
0433   06C4 E7            pop d
0434   06C5 FD 3E         mov [d], bl
0435   06C7             _for5_update:
0436   06C7 FA FF FF      lea d, [bp + -1] ; $i
0437   06CA 2A            mov b, [d]
0438   06CB 38 00 00      mov c, 0
0439   06CE 11            mov a, b
0440   06CF FD 77         inc b
0441   06D1 FA FF FF      lea d, [bp + -1] ; $i
0442   06D4 FD 43         mov [d], b
0443   06D6 27            mov b, a
0444   06D7 0A 8E 06      jmp _for5_cond
0445   06DA             _for5_exit:
0446   06DA             ; return s; 
0447   06DA FA 05 00      lea d, [bp + 5] ; $s
0448   06DD 2A            mov b, [d]
0449   06DE 38 00 00      mov c, 0
0450   06E1 F9            leave
0451   06E2 09            ret
0452   06E3             
0453   06E3             atoi:
0454   06E3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0455   06E6             ; int result = 0;  // Initialize result 
0456   06E6 52 02 00      sub sp, 2
0457   06E9             ; --- START LOCAL VAR INITIALIZATION
0458   06E9 FA FF FF      lea d, [bp + -1] ; $result
0459   06EC DA            push d
0460   06ED FD 2E 00 00   mov32 cb, $00000000
0460   06F1 00 00 
0461   06F3 E7            pop d
0462   06F4 FD 43         mov [d], b
0463   06F6             ; --- END LOCAL VAR INITIALIZATION
0464   06F6             ; int sign = 1;    // Initialize sign as positive 
0465   06F6 52 02 00      sub sp, 2
0466   06F9             ; --- START LOCAL VAR INITIALIZATION
0467   06F9 FA FD FF      lea d, [bp + -3] ; $sign
0468   06FC DA            push d
0469   06FD FD 2E 01 00   mov32 cb, $00000001
0469   0701 00 00 
0470   0703 E7            pop d
0471   0704 FD 43         mov [d], b
0472   0706             ; --- END LOCAL VAR INITIALIZATION
0473   0706             ; while (*str == ' ') str++; 
0474   0706             _while6_cond:
0475   0706 FA 05 00      lea d, [bp + 5] ; $str
0476   0709 2A            mov b, [d]
0477   070A 38 00 00      mov c, 0
0478   070D 74            mov d, b
0479   070E 32            mov bl, [d]
0480   070F A7 00         mov bh, 0
0481   0711 38 00 00      mov c, 0
0482   0714             ; --- START RELATIONAL
0483   0714 D7            push a
0484   0715 11            mov a, b
0485   0716 FD 2E 20 00   mov32 cb, $00000020
0485   071A 00 00 
0486   071C B0            cmp a, b
0487   071D FD 71         seq ; ==
0488   071F E4            pop a
0489   0720             ; --- END RELATIONAL
0490   0720 C0 00 00      cmp b, 0
0491   0723 C6 39 07      je _while6_exit
0492   0726             _while6_block:
0493   0726             ; str++; 
0494   0726 FA 05 00      lea d, [bp + 5] ; $str
0495   0729 2A            mov b, [d]
0496   072A 38 00 00      mov c, 0
0497   072D FD 77         inc b
0498   072F FA 05 00      lea d, [bp + 5] ; $str
0499   0732 FD 3E         mov [d], bl
0500   0734 FD 7D         dec b
0501   0736 0A 06 07      jmp _while6_cond
0502   0739             _while6_exit:
0503   0739             ; if (*str == '-' || *str == '+') { 
0504   0739             _if7_cond:
0505   0739 FA 05 00      lea d, [bp + 5] ; $str
0506   073C 2A            mov b, [d]
0507   073D 38 00 00      mov c, 0
0508   0740 74            mov d, b
0509   0741 32            mov bl, [d]
0510   0742 A7 00         mov bh, 0
0511   0744 38 00 00      mov c, 0
0512   0747             ; --- START RELATIONAL
0513   0747 D7            push a
0514   0748 11            mov a, b
0515   0749 FD 2E 2D 00   mov32 cb, $0000002d
0515   074D 00 00 
0516   074F B0            cmp a, b
0517   0750 FD 71         seq ; ==
0518   0752 E4            pop a
0519   0753             ; --- END RELATIONAL
0520   0753             ; --- START LOGICAL OR
0521   0753 D7            push a
0522   0754 11            mov a, b
0523   0755 FA 05 00      lea d, [bp + 5] ; $str
0524   0758 2A            mov b, [d]
0525   0759 38 00 00      mov c, 0
0526   075C 74            mov d, b
0527   075D 32            mov bl, [d]
0528   075E A7 00         mov bh, 0
0529   0760 38 00 00      mov c, 0
0530   0763             ; --- START RELATIONAL
0531   0763 D7            push a
0532   0764 11            mov a, b
0533   0765 FD 2E 2B 00   mov32 cb, $0000002b
0533   0769 00 00 
0534   076B B0            cmp a, b
0535   076C FD 71         seq ; ==
0536   076E E4            pop a
0537   076F             ; --- END RELATIONAL
0538   076F FD A8         sor a, b ; ||
0539   0771 E4            pop a
0540   0772             ; --- END LOGICAL OR
0541   0772 C0 00 00      cmp b, 0
0542   0775 C6 BD 07      je _if7_exit
0543   0778             _if7_true:
0544   0778             ; if (*str == '-') sign = -1; 
0545   0778             _if8_cond:
0546   0778 FA 05 00      lea d, [bp + 5] ; $str
0547   077B 2A            mov b, [d]
0548   077C 38 00 00      mov c, 0
0549   077F 74            mov d, b
0550   0780 32            mov bl, [d]
0551   0781 A7 00         mov bh, 0
0552   0783 38 00 00      mov c, 0
0553   0786             ; --- START RELATIONAL
0554   0786 D7            push a
0555   0787 11            mov a, b
0556   0788 FD 2E 2D 00   mov32 cb, $0000002d
0556   078C 00 00 
0557   078E B0            cmp a, b
0558   078F FD 71         seq ; ==
0559   0791 E4            pop a
0560   0792             ; --- END RELATIONAL
0561   0792 C0 00 00      cmp b, 0
0562   0795 C6 AA 07      je _if8_exit
0563   0798             _if8_true:
0564   0798             ; sign = -1; 
0565   0798 FA FD FF      lea d, [bp + -3] ; $sign
0566   079B DA            push d
0567   079C FD 2E 01 00   mov32 cb, $00000001
0567   07A0 00 00 
0568   07A2 FD 97         neg b
0569   07A4 E7            pop d
0570   07A5 FD 43         mov [d], b
0571   07A7 0A AA 07      jmp _if8_exit
0572   07AA             _if8_exit:
0573   07AA             ; str++; 
0574   07AA FA 05 00      lea d, [bp + 5] ; $str
0575   07AD 2A            mov b, [d]
0576   07AE 38 00 00      mov c, 0
0577   07B1 FD 77         inc b
0578   07B3 FA 05 00      lea d, [bp + 5] ; $str
0579   07B6 FD 3E         mov [d], bl
0580   07B8 FD 7D         dec b
0581   07BA 0A BD 07      jmp _if7_exit
0582   07BD             _if7_exit:
0583   07BD             ; while (*str >= '0' && *str <= '9') { 
0584   07BD             _while9_cond:
0585   07BD FA 05 00      lea d, [bp + 5] ; $str
0586   07C0 2A            mov b, [d]
0587   07C1 38 00 00      mov c, 0
0588   07C4 74            mov d, b
0589   07C5 32            mov bl, [d]
0590   07C6 A7 00         mov bh, 0
0591   07C8 38 00 00      mov c, 0
0592   07CB             ; --- START RELATIONAL
0593   07CB D7            push a
0594   07CC 11            mov a, b
0595   07CD FD 2E 30 00   mov32 cb, $00000030
0595   07D1 00 00 
0596   07D3 B0            cmp a, b
0597   07D4 FD 82         sgeu ; >= (unsigned)
0598   07D6 E4            pop a
0599   07D7             ; --- END RELATIONAL
0600   07D7             ; --- START LOGICAL AND
0601   07D7 D7            push a
0602   07D8 11            mov a, b
0603   07D9 FA 05 00      lea d, [bp + 5] ; $str
0604   07DC 2A            mov b, [d]
0605   07DD 38 00 00      mov c, 0
0606   07E0 74            mov d, b
0607   07E1 32            mov bl, [d]
0608   07E2 A7 00         mov bh, 0
0609   07E4 38 00 00      mov c, 0
0610   07E7             ; --- START RELATIONAL
0611   07E7 D7            push a
0612   07E8 11            mov a, b
0613   07E9 FD 2E 39 00   mov32 cb, $00000039
0613   07ED 00 00 
0614   07EF B0            cmp a, b
0615   07F0 FD 76         sleu ; <= (unsigned)
0616   07F2 E4            pop a
0617   07F3             ; --- END RELATIONAL
0618   07F3 FD A7         sand a, b
0619   07F5 E4            pop a
0620   07F6             ; --- END LOGICAL AND
0621   07F6 C0 00 00      cmp b, 0
0622   07F9 C6 46 08      je _while9_exit
0623   07FC             _while9_block:
0624   07FC             ; result = result * 10 + (*str - '0'); 
0625   07FC FA FF FF      lea d, [bp + -1] ; $result
0626   07FF DA            push d
0627   0800 FA FF FF      lea d, [bp + -1] ; $result
0628   0803 2A            mov b, [d]
0629   0804 38 00 00      mov c, 0
0630   0807             ; --- START FACTORS
0631   0807 D7            push a
0632   0808 11            mov a, b
0633   0809 FD 2E 0A 00   mov32 cb, $0000000a
0633   080D 00 00 
0634   080F AC            mul a, b ; *
0635   0810 11            mov a, b
0636   0811 27            mov b, a
0637   0812 E4            pop a
0638   0813             ; --- END FACTORS
0639   0813             ; --- START TERMS
0640   0813 D7            push a
0641   0814 11            mov a, b
0642   0815 FA 05 00      lea d, [bp + 5] ; $str
0643   0818 2A            mov b, [d]
0644   0819 38 00 00      mov c, 0
0645   081C 74            mov d, b
0646   081D 32            mov bl, [d]
0647   081E A7 00         mov bh, 0
0648   0820 38 00 00      mov c, 0
0649   0823             ; --- START TERMS
0650   0823 D7            push a
0651   0824 11            mov a, b
0652   0825 FD 2E 30 00   mov32 cb, $00000030
0652   0829 00 00 
0653   082B 60            sub a, b
0654   082C 27            mov b, a
0655   082D E4            pop a
0656   082E             ; --- END TERMS
0657   082E 56            add b, a
0658   082F E4            pop a
0659   0830             ; --- END TERMS
0660   0830 E7            pop d
0661   0831 FD 43         mov [d], b
0662   0833             ; str++; 
0663   0833 FA 05 00      lea d, [bp + 5] ; $str
0664   0836 2A            mov b, [d]
0665   0837 38 00 00      mov c, 0
0666   083A FD 77         inc b
0667   083C FA 05 00      lea d, [bp + 5] ; $str
0668   083F FD 3E         mov [d], bl
0669   0841 FD 7D         dec b
0670   0843 0A BD 07      jmp _while9_cond
0671   0846             _while9_exit:
0672   0846             ; return sign * result; 
0673   0846 FA FD FF      lea d, [bp + -3] ; $sign
0674   0849 2A            mov b, [d]
0675   084A 38 00 00      mov c, 0
0676   084D             ; --- START FACTORS
0677   084D D7            push a
0678   084E 11            mov a, b
0679   084F FA FF FF      lea d, [bp + -1] ; $result
0680   0852 2A            mov b, [d]
0681   0853 38 00 00      mov c, 0
0682   0856 AC            mul a, b ; *
0683   0857 11            mov a, b
0684   0858 27            mov b, a
0685   0859 E4            pop a
0686   085A             ; --- END FACTORS
0687   085A F9            leave
0688   085B 09            ret
0689   085C             
0690   085C             rand:
0691   085C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0692   085F             ; int  sec; 
0693   085F 52 02 00      sub sp, 2
0694   0862             
0695   0862             ; --- BEGIN INLINE ASM SEGMENT
0696   0862 19 00         mov al, 0
0697   0864 05 01         syscall sys_rtc					
0698   0866 1A            mov al, ah
0699   0867 FA FF FF      lea d, [bp + -1] ; $sec
0700   086A 1E            mov al, [d]
0701   086B 22 00         mov ah, 0
0702   086D             ; --- END INLINE ASM SEGMENT
0703   086D             
0704   086D             ; return sec; 
0705   086D FA FF FF      lea d, [bp + -1] ; $sec
0706   0870 2A            mov b, [d]
0707   0871 38 00 00      mov c, 0
0708   0874 F9            leave
0709   0875 09            ret
0710   0876             
0711   0876             alloc:
0712   0876 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0713   0879             ; heap_top = heap_top + bytes; 
0714   0879 3B B2 21      mov d, _heap_top ; $heap_top
0715   087C DA            push d
0716   087D 3B B2 21      mov d, _heap_top ; $heap_top
0717   0880 2A            mov b, [d]
0718   0881 38 00 00      mov c, 0
0719   0884             ; --- START TERMS
0720   0884 D7            push a
0721   0885 11            mov a, b
0722   0886 FA 05 00      lea d, [bp + 5] ; $bytes
0723   0889 2A            mov b, [d]
0724   088A 38 00 00      mov c, 0
0725   088D 56            add b, a
0726   088E E4            pop a
0727   088F             ; --- END TERMS
0728   088F E7            pop d
0729   0890 FD 43         mov [d], b
0730   0892             ; return heap_top - bytes; 
0731   0892 3B B2 21      mov d, _heap_top ; $heap_top
0732   0895 2A            mov b, [d]
0733   0896 38 00 00      mov c, 0
0734   0899             ; --- START TERMS
0735   0899 D7            push a
0736   089A 11            mov a, b
0737   089B FA 05 00      lea d, [bp + 5] ; $bytes
0738   089E 2A            mov b, [d]
0739   089F 38 00 00      mov c, 0
0740   08A2 60            sub a, b
0741   08A3 27            mov b, a
0742   08A4 E4            pop a
0743   08A5             ; --- END TERMS
0744   08A5 F9            leave
0745   08A6 09            ret
0746   08A7             
0747   08A7             free:
0748   08A7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0749   08AA             ; return heap_top = heap_top - bytes; 
0750   08AA 3B B2 21      mov d, _heap_top ; $heap_top
0751   08AD DA            push d
0752   08AE 3B B2 21      mov d, _heap_top ; $heap_top
0753   08B1 2A            mov b, [d]
0754   08B2 38 00 00      mov c, 0
0755   08B5             ; --- START TERMS
0756   08B5 D7            push a
0757   08B6 11            mov a, b
0758   08B7 FA 05 00      lea d, [bp + 5] ; $bytes
0759   08BA 2A            mov b, [d]
0760   08BB 38 00 00      mov c, 0
0761   08BE 60            sub a, b
0762   08BF 27            mov b, a
0763   08C0 E4            pop a
0764   08C1             ; --- END TERMS
0765   08C1 E7            pop d
0766   08C2 FD 43         mov [d], b
0767   08C4 F9            leave
0768   08C5 09            ret
0769   08C6             
0770   08C6             fopen:
0771   08C6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0772   08C9             ; FILE *fp; 
0773   08C9 52 02 00      sub sp, 2
0774   08CC             ; static int max_handle = 0; 
0775   08CC 52 02 00      sub sp, 2
0776   08CF             ; fp = alloc(sizeof(FILE)); 
0777   08CF FA FF FF      lea d, [bp + -1] ; $fp
0778   08D2 DA            push d
0779   08D3             ; --- START FUNCTION CALL
0780   08D3 26 04 01      mov b, 260
0781   08D6 FD AB         swp b
0782   08D8 D8            push b
0783   08D9 07 76 08      call alloc
0784   08DC 51 02 00      add sp, 2
0785   08DF             ; --- END FUNCTION CALL
0786   08DF E7            pop d
0787   08E0 FD 43         mov [d], b
0788   08E2             ; strcpy(fp->filename, filename); 
0789   08E2             ; --- START FUNCTION CALL
0790   08E2 FA 05 00      lea d, [bp + 5] ; $filename
0791   08E5 2A            mov b, [d]
0792   08E6 38 00 00      mov c, 0
0793   08E9 FD AB         swp b
0794   08EB D8            push b
0795   08EC FA FF FF      lea d, [bp + -1] ; $fp
0796   08EF FD 2A         mov d, [d]
0797   08F1 58 02 00      add d, 2
0798   08F4 2D            mov b, d
0799   08F5 38 00 00      mov c, 0
0800   08F8 FD AB         swp b
0801   08FA D8            push b
0802   08FB 07 33 04      call strcpy
0803   08FE 51 04 00      add sp, 4
0804   0901             ; --- END FUNCTION CALL
0805   0901             ; fp->handle = max_handle; 
0806   0901 FA FF FF      lea d, [bp + -1] ; $fp
0807   0904 FD 2A         mov d, [d]
0808   0906 58 00 00      add d, 0
0809   0909 DA            push d
0810   090A 3B 6C 21      mov d, st_fopen_max_handle ; static max_handle
0811   090D 2A            mov b, [d]
0812   090E 38 00 00      mov c, 0
0813   0911 E7            pop d
0814   0912 FD 43         mov [d], b
0815   0914             ; fp->mode = mode; 
0816   0914 FA FF FF      lea d, [bp + -1] ; $fp
0817   0917 FD 2A         mov d, [d]
0818   0919 58 02 01      add d, 258
0819   091C DA            push d
0820   091D FA 07 00      lea d, [bp + 7] ; $mode
0821   0920 32            mov bl, [d]
0822   0921 A7 00         mov bh, 0
0823   0923 38 00 00      mov c, 0
0824   0926 E7            pop d
0825   0927 FD 3E         mov [d], bl
0826   0929             ; fp->loc = 0; 
0827   0929 FA FF FF      lea d, [bp + -1] ; $fp
0828   092C FD 2A         mov d, [d]
0829   092E 58 03 01      add d, 259
0830   0931 DA            push d
0831   0932 FD 2E 00 00   mov32 cb, $00000000
0831   0936 00 00 
0832   0938 E7            pop d
0833   0939 FD 3E         mov [d], bl
0834   093B             ; max_handle++; 
0835   093B 3B 6C 21      mov d, st_fopen_max_handle ; static max_handle
0836   093E 2A            mov b, [d]
0837   093F 38 00 00      mov c, 0
0838   0942 11            mov a, b
0839   0943 FD 77         inc b
0840   0945 3B 6C 21      mov d, st_fopen_max_handle ; static max_handle
0841   0948 FD 43         mov [d], b
0842   094A 27            mov b, a
0843   094B F9            leave
0844   094C 09            ret
0845   094D             
0846   094D             fclose:
0847   094D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0848   0950             ; free(sizeof(FILE)); 
0849   0950             ; --- START FUNCTION CALL
0850   0950 26 04 01      mov b, 260
0851   0953 FD AB         swp b
0852   0955 D8            push b
0853   0956 07 A7 08      call free
0854   0959 51 02 00      add sp, 2
0855   095C             ; --- END FUNCTION CALL
0856   095C F9            leave
0857   095D 09            ret
0858   095E             
0859   095E             printf:
0860   095E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0861   0961             ; char *p, *format_p; 
0862   0961 52 02 00      sub sp, 2
0863   0964 52 02 00      sub sp, 2
0864   0967             ; format_p = format; 
0865   0967 FA FD FF      lea d, [bp + -3] ; $format_p
0866   096A DA            push d
0867   096B FA 05 00      lea d, [bp + 5] ; $format
0868   096E 2A            mov b, [d]
0869   096F 38 00 00      mov c, 0
0870   0972 E7            pop d
0871   0973 FD 43         mov [d], b
0872   0975             ; p = &format + 2; 
0873   0975 FA FF FF      lea d, [bp + -1] ; $p
0874   0978 DA            push d
0875   0979 FA 05 00      lea d, [bp + 5] ; $format
0876   097C 2D            mov b, d
0877   097D             ; --- START TERMS
0878   097D D7            push a
0879   097E 11            mov a, b
0880   097F FD 2E 02 00   mov32 cb, $00000002
0880   0983 00 00 
0881   0985 56            add b, a
0882   0986 E4            pop a
0883   0987             ; --- END TERMS
0884   0987 E7            pop d
0885   0988 FD 43         mov [d], b
0886   098A             ; for(;;){ 
0887   098A             _for10_init:
0888   098A             _for10_cond:
0889   098A             _for10_block:
0890   098A             ; if(!*format_p) break; 
0891   098A             _if11_cond:
0892   098A FA FD FF      lea d, [bp + -3] ; $format_p
0893   098D 2A            mov b, [d]
0894   098E 38 00 00      mov c, 0
0895   0991 74            mov d, b
0896   0992 32            mov bl, [d]
0897   0993 A7 00         mov bh, 0
0898   0995 38 00 00      mov c, 0
0899   0998 C0 00 00      cmp b, 0
0900   099B FD 71         seq ; !
0901   099D C0 00 00      cmp b, 0
0902   09A0 C6 A9 09      je _if11_else
0903   09A3             _if11_true:
0904   09A3             ; break; 
0905   09A3 0A 3A 0C      jmp _for10_exit ; for break
0906   09A6 0A 37 0C      jmp _if11_exit
0907   09A9             _if11_else:
0908   09A9             ; if(*format_p == '%'){ 
0909   09A9             _if12_cond:
0910   09A9 FA FD FF      lea d, [bp + -3] ; $format_p
0911   09AC 2A            mov b, [d]
0912   09AD 38 00 00      mov c, 0
0913   09B0 74            mov d, b
0914   09B1 32            mov bl, [d]
0915   09B2 A7 00         mov bh, 0
0916   09B4 38 00 00      mov c, 0
0917   09B7             ; --- START RELATIONAL
0918   09B7 D7            push a
0919   09B8 11            mov a, b
0920   09B9 FD 2E 25 00   mov32 cb, $00000025
0920   09BD 00 00 
0921   09BF B0            cmp a, b
0922   09C0 FD 71         seq ; ==
0923   09C2 E4            pop a
0924   09C3             ; --- END RELATIONAL
0925   09C3 C0 00 00      cmp b, 0
0926   09C6 C6 12 0C      je _if12_else
0927   09C9             _if12_true:
0928   09C9             ; format_p++; 
0929   09C9 FA FD FF      lea d, [bp + -3] ; $format_p
0930   09CC 2A            mov b, [d]
0931   09CD 38 00 00      mov c, 0
0932   09D0 FD 77         inc b
0933   09D2 FA FD FF      lea d, [bp + -3] ; $format_p
0934   09D5 FD 3E         mov [d], bl
0935   09D7 FD 7D         dec b
0936   09D9             ; switch(*format_p){ 
0937   09D9             _switch13_expr:
0938   09D9 FA FD FF      lea d, [bp + -3] ; $format_p
0939   09DC 2A            mov b, [d]
0940   09DD 38 00 00      mov c, 0
0941   09E0 74            mov d, b
0942   09E1 32            mov bl, [d]
0943   09E2 A7 00         mov bh, 0
0944   09E4 38 00 00      mov c, 0
0945   09E7             _switch13_comparisons:
0946   09E7 C1 6C         cmp bl, $6c
0947   09E9 C6 15 0A      je _switch13_case0
0948   09EC C1 4C         cmp bl, $4c
0949   09EE C6 15 0A      je _switch13_case1
0950   09F1 C1 64         cmp bl, $64
0951   09F3 C6 25 0B      je _switch13_case2
0952   09F6 C1 69         cmp bl, $69
0953   09F8 C6 25 0B      je _switch13_case3
0954   09FB C1 75         cmp bl, $75
0955   09FD C6 55 0B      je _switch13_case4
0956   0A00 C1 78         cmp bl, $78
0957   0A02 C6 85 0B      je _switch13_case5
0958   0A05 C1 63         cmp bl, $63
0959   0A07 C6 A9 0B      je _switch13_case6
0960   0A0A C1 73         cmp bl, $73
0961   0A0C C6 CE 0B      je _switch13_case7
0962   0A0F 0A F3 0B      jmp _switch13_default
0963   0A12 0A FF 0B      jmp _switch13_exit
0964   0A15             _switch13_case0:
0965   0A15             _switch13_case1:
0966   0A15             ; format_p++; 
0967   0A15 FA FD FF      lea d, [bp + -3] ; $format_p
0968   0A18 2A            mov b, [d]
0969   0A19 38 00 00      mov c, 0
0970   0A1C FD 77         inc b
0971   0A1E FA FD FF      lea d, [bp + -3] ; $format_p
0972   0A21 FD 3E         mov [d], bl
0973   0A23 FD 7D         dec b
0974   0A25             ; if(*format_p == 'd' || *format_p == 'i') 
0975   0A25             _if14_cond:
0976   0A25 FA FD FF      lea d, [bp + -3] ; $format_p
0977   0A28 2A            mov b, [d]
0978   0A29 38 00 00      mov c, 0
0979   0A2C 74            mov d, b
0980   0A2D 32            mov bl, [d]
0981   0A2E A7 00         mov bh, 0
0982   0A30 38 00 00      mov c, 0
0983   0A33             ; --- START RELATIONAL
0984   0A33 D7            push a
0985   0A34 11            mov a, b
0986   0A35 FD 2E 64 00   mov32 cb, $00000064
0986   0A39 00 00 
0987   0A3B B0            cmp a, b
0988   0A3C FD 71         seq ; ==
0989   0A3E E4            pop a
0990   0A3F             ; --- END RELATIONAL
0991   0A3F             ; --- START LOGICAL OR
0992   0A3F D7            push a
0993   0A40 11            mov a, b
0994   0A41 FA FD FF      lea d, [bp + -3] ; $format_p
0995   0A44 2A            mov b, [d]
0996   0A45 38 00 00      mov c, 0
0997   0A48 74            mov d, b
0998   0A49 32            mov bl, [d]
0999   0A4A A7 00         mov bh, 0
1000   0A4C 38 00 00      mov c, 0
1001   0A4F             ; --- START RELATIONAL
1002   0A4F D7            push a
1003   0A50 11            mov a, b
1004   0A51 FD 2E 69 00   mov32 cb, $00000069
1004   0A55 00 00 
1005   0A57 B0            cmp a, b
1006   0A58 FD 71         seq ; ==
1007   0A5A E4            pop a
1008   0A5B             ; --- END RELATIONAL
1009   0A5B FD A8         sor a, b ; ||
1010   0A5D E4            pop a
1011   0A5E             ; --- END LOGICAL OR
1012   0A5E C0 00 00      cmp b, 0
1013   0A61 C6 82 0A      je _if14_else
1014   0A64             _if14_true:
1015   0A64             ; print_signed_long(*(long *)p); 
1016   0A64             ; --- START FUNCTION CALL
1017   0A64 FA FF FF      lea d, [bp + -1] ; $p
1018   0A67 2A            mov b, [d]
1019   0A68 38 00 00      mov c, 0
1020   0A6B 74            mov d, b
1021   0A6C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1022   0A6F FD 39         mov c, b ; And place it into C
1023   0A71 2A            mov b, [d] ; Lower Word in B
1024   0A72 12            mov a, c
1025   0A73 FD AA         swp a
1026   0A75 D7            push a
1027   0A76 FD AB         swp b
1028   0A78 D8            push b
1029   0A79 07 0C 16      call print_signed_long
1030   0A7C 51 04 00      add sp, 4
1031   0A7F             ; --- END FUNCTION CALL
1032   0A7F 0A 0A 0B      jmp _if14_exit
1033   0A82             _if14_else:
1034   0A82             ; if(*format_p == 'u') 
1035   0A82             _if15_cond:
1036   0A82 FA FD FF      lea d, [bp + -3] ; $format_p
1037   0A85 2A            mov b, [d]
1038   0A86 38 00 00      mov c, 0
1039   0A89 74            mov d, b
1040   0A8A 32            mov bl, [d]
1041   0A8B A7 00         mov bh, 0
1042   0A8D 38 00 00      mov c, 0
1043   0A90             ; --- START RELATIONAL
1044   0A90 D7            push a
1045   0A91 11            mov a, b
1046   0A92 FD 2E 75 00   mov32 cb, $00000075
1046   0A96 00 00 
1047   0A98 B0            cmp a, b
1048   0A99 FD 71         seq ; ==
1049   0A9B E4            pop a
1050   0A9C             ; --- END RELATIONAL
1051   0A9C C0 00 00      cmp b, 0
1052   0A9F C6 C0 0A      je _if15_else
1053   0AA2             _if15_true:
1054   0AA2             ; print_unsigned_long(*(unsigned long *)p); 
1055   0AA2             ; --- START FUNCTION CALL
1056   0AA2 FA FF FF      lea d, [bp + -1] ; $p
1057   0AA5 2A            mov b, [d]
1058   0AA6 38 00 00      mov c, 0
1059   0AA9 74            mov d, b
1060   0AAA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1061   0AAD FD 39         mov c, b ; And place it into C
1062   0AAF 2A            mov b, [d] ; Lower Word in B
1063   0AB0 12            mov a, c
1064   0AB1 FD AA         swp a
1065   0AB3 D7            push a
1066   0AB4 FD AB         swp b
1067   0AB6 D8            push b
1068   0AB7 07 7B 17      call print_unsigned_long
1069   0ABA 51 04 00      add sp, 4
1070   0ABD             ; --- END FUNCTION CALL
1071   0ABD 0A 0A 0B      jmp _if15_exit
1072   0AC0             _if15_else:
1073   0AC0             ; if(*format_p == 'x') 
1074   0AC0             _if16_cond:
1075   0AC0 FA FD FF      lea d, [bp + -3] ; $format_p
1076   0AC3 2A            mov b, [d]
1077   0AC4 38 00 00      mov c, 0
1078   0AC7 74            mov d, b
1079   0AC8 32            mov bl, [d]
1080   0AC9 A7 00         mov bh, 0
1081   0ACB 38 00 00      mov c, 0
1082   0ACE             ; --- START RELATIONAL
1083   0ACE D7            push a
1084   0ACF 11            mov a, b
1085   0AD0 FD 2E 78 00   mov32 cb, $00000078
1085   0AD4 00 00 
1086   0AD6 B0            cmp a, b
1087   0AD7 FD 71         seq ; ==
1088   0AD9 E4            pop a
1089   0ADA             ; --- END RELATIONAL
1090   0ADA C0 00 00      cmp b, 0
1091   0ADD C6 FE 0A      je _if16_else
1092   0AE0             _if16_true:
1093   0AE0             ; printx32(*(long int *)p); 
1094   0AE0             ; --- START FUNCTION CALL
1095   0AE0 FA FF FF      lea d, [bp + -1] ; $p
1096   0AE3 2A            mov b, [d]
1097   0AE4 38 00 00      mov c, 0
1098   0AE7 74            mov d, b
1099   0AE8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1100   0AEB FD 39         mov c, b ; And place it into C
1101   0AED 2A            mov b, [d] ; Lower Word in B
1102   0AEE 12            mov a, c
1103   0AEF FD AA         swp a
1104   0AF1 D7            push a
1105   0AF2 FD AB         swp b
1106   0AF4 D8            push b
1107   0AF5 07 DF 12      call printx32
1108   0AF8 51 04 00      add sp, 4
1109   0AFB             ; --- END FUNCTION CALL
1110   0AFB 0A 0A 0B      jmp _if16_exit
1111   0AFE             _if16_else:
1112   0AFE             ; err("Unexpected format in printf."); 
1113   0AFE             ; --- START FUNCTION CALL
1114   0AFE 26 6E 21      mov b, _s0 ; "Unexpected format in printf."
1115   0B01 FD AB         swp b
1116   0B03 D8            push b
1117   0B04 07 CA 12      call err
1118   0B07 51 02 00      add sp, 2
1119   0B0A             ; --- END FUNCTION CALL
1120   0B0A             _if16_exit:
1121   0B0A             _if15_exit:
1122   0B0A             _if14_exit:
1123   0B0A             ; p = p + 4; 
1124   0B0A FA FF FF      lea d, [bp + -1] ; $p
1125   0B0D DA            push d
1126   0B0E FA FF FF      lea d, [bp + -1] ; $p
1127   0B11 2A            mov b, [d]
1128   0B12 38 00 00      mov c, 0
1129   0B15             ; --- START TERMS
1130   0B15 D7            push a
1131   0B16 11            mov a, b
1132   0B17 FD 2E 04 00   mov32 cb, $00000004
1132   0B1B 00 00 
1133   0B1D 56            add b, a
1134   0B1E E4            pop a
1135   0B1F             ; --- END TERMS
1136   0B1F E7            pop d
1137   0B20 FD 43         mov [d], b
1138   0B22             ; break; 
1139   0B22 0A FF 0B      jmp _switch13_exit ; case break
1140   0B25             _switch13_case2:
1141   0B25             _switch13_case3:
1142   0B25             ; print_signed(*(int*)p); 
1143   0B25             ; --- START FUNCTION CALL
1144   0B25 FA FF FF      lea d, [bp + -1] ; $p
1145   0B28 2A            mov b, [d]
1146   0B29 38 00 00      mov c, 0
1147   0B2C 74            mov d, b
1148   0B2D 2A            mov b, [d]
1149   0B2E 38 00 00      mov c, 0
1150   0B31 FD AB         swp b
1151   0B33 D8            push b
1152   0B34 07 D3 14      call print_signed
1153   0B37 51 02 00      add sp, 2
1154   0B3A             ; --- END FUNCTION CALL
1155   0B3A             ; p = p + 2; 
1156   0B3A FA FF FF      lea d, [bp + -1] ; $p
1157   0B3D DA            push d
1158   0B3E FA FF FF      lea d, [bp + -1] ; $p
1159   0B41 2A            mov b, [d]
1160   0B42 38 00 00      mov c, 0
1161   0B45             ; --- START TERMS
1162   0B45 D7            push a
1163   0B46 11            mov a, b
1164   0B47 FD 2E 02 00   mov32 cb, $00000002
1164   0B4B 00 00 
1165   0B4D 56            add b, a
1166   0B4E E4            pop a
1167   0B4F             ; --- END TERMS
1168   0B4F E7            pop d
1169   0B50 FD 43         mov [d], b
1170   0B52             ; break; 
1171   0B52 0A FF 0B      jmp _switch13_exit ; case break
1172   0B55             _switch13_case4:
1173   0B55             ; print_unsigned(*(unsigned int*)p); 
1174   0B55             ; --- START FUNCTION CALL
1175   0B55 FA FF FF      lea d, [bp + -1] ; $p
1176   0B58 2A            mov b, [d]
1177   0B59 38 00 00      mov c, 0
1178   0B5C 74            mov d, b
1179   0B5D 2A            mov b, [d]
1180   0B5E 38 00 00      mov c, 0
1181   0B61 FD AB         swp b
1182   0B63 D8            push b
1183   0B64 07 EF 19      call print_unsigned
1184   0B67 51 02 00      add sp, 2
1185   0B6A             ; --- END FUNCTION CALL
1186   0B6A             ; p = p + 2; 
1187   0B6A FA FF FF      lea d, [bp + -1] ; $p
1188   0B6D DA            push d
1189   0B6E FA FF FF      lea d, [bp + -1] ; $p
1190   0B71 2A            mov b, [d]
1191   0B72 38 00 00      mov c, 0
1192   0B75             ; --- START TERMS
1193   0B75 D7            push a
1194   0B76 11            mov a, b
1195   0B77 FD 2E 02 00   mov32 cb, $00000002
1195   0B7B 00 00 
1196   0B7D 56            add b, a
1197   0B7E E4            pop a
1198   0B7F             ; --- END TERMS
1199   0B7F E7            pop d
1200   0B80 FD 43         mov [d], b
1201   0B82             ; break; 
1202   0B82 0A FF 0B      jmp _switch13_exit ; case break
1203   0B85             _switch13_case5:
1204   0B85             
1205   0B85             ; --- BEGIN INLINE ASM SEGMENT
1206   0B85 FA FF FF      lea d, [bp + -1] ; $p
1207   0B88 FD 2A         mov d, [d]
1208   0B8A 2A            mov b, [d]
1209   0B8B 07 68 20      call print_u16x
1210   0B8E             ; --- END INLINE ASM SEGMENT
1211   0B8E             
1212   0B8E             ; p = p + 2; 
1213   0B8E FA FF FF      lea d, [bp + -1] ; $p
1214   0B91 DA            push d
1215   0B92 FA FF FF      lea d, [bp + -1] ; $p
1216   0B95 2A            mov b, [d]
1217   0B96 38 00 00      mov c, 0
1218   0B99             ; --- START TERMS
1219   0B99 D7            push a
1220   0B9A 11            mov a, b
1221   0B9B FD 2E 02 00   mov32 cb, $00000002
1221   0B9F 00 00 
1222   0BA1 56            add b, a
1223   0BA2 E4            pop a
1224   0BA3             ; --- END TERMS
1225   0BA3 E7            pop d
1226   0BA4 FD 43         mov [d], b
1227   0BA6             ; break; 
1228   0BA6 0A FF 0B      jmp _switch13_exit ; case break
1229   0BA9             _switch13_case6:
1230   0BA9             
1231   0BA9             ; --- BEGIN INLINE ASM SEGMENT
1232   0BA9 FA FF FF      lea d, [bp + -1] ; $p
1233   0BAC FD 2A         mov d, [d]
1234   0BAE 1E            mov al, [d]
1235   0BAF 23            mov ah, al
1236   0BB0 07 C6 1E      call _putchar
1237   0BB3             ; --- END INLINE ASM SEGMENT
1238   0BB3             
1239   0BB3             ; p = p + 1; 
1240   0BB3 FA FF FF      lea d, [bp + -1] ; $p
1241   0BB6 DA            push d
1242   0BB7 FA FF FF      lea d, [bp + -1] ; $p
1243   0BBA 2A            mov b, [d]
1244   0BBB 38 00 00      mov c, 0
1245   0BBE             ; --- START TERMS
1246   0BBE D7            push a
1247   0BBF 11            mov a, b
1248   0BC0 FD 2E 01 00   mov32 cb, $00000001
1248   0BC4 00 00 
1249   0BC6 56            add b, a
1250   0BC7 E4            pop a
1251   0BC8             ; --- END TERMS
1252   0BC8 E7            pop d
1253   0BC9 FD 43         mov [d], b
1254   0BCB             ; break; 
1255   0BCB 0A FF 0B      jmp _switch13_exit ; case break
1256   0BCE             _switch13_case7:
1257   0BCE             
1258   0BCE             ; --- BEGIN INLINE ASM SEGMENT
1259   0BCE FA FF FF      lea d, [bp + -1] ; $p
1260   0BD1 FD 2A         mov d, [d]
1261   0BD3 FD 2A         mov d, [d]
1262   0BD5 07 10 20      call _puts
1263   0BD8             ; --- END INLINE ASM SEGMENT
1264   0BD8             
1265   0BD8             ; p = p + 2; 
1266   0BD8 FA FF FF      lea d, [bp + -1] ; $p
1267   0BDB DA            push d
1268   0BDC FA FF FF      lea d, [bp + -1] ; $p
1269   0BDF 2A            mov b, [d]
1270   0BE0 38 00 00      mov c, 0
1271   0BE3             ; --- START TERMS
1272   0BE3 D7            push a
1273   0BE4 11            mov a, b
1274   0BE5 FD 2E 02 00   mov32 cb, $00000002
1274   0BE9 00 00 
1275   0BEB 56            add b, a
1276   0BEC E4            pop a
1277   0BED             ; --- END TERMS
1278   0BED E7            pop d
1279   0BEE FD 43         mov [d], b
1280   0BF0             ; break; 
1281   0BF0 0A FF 0B      jmp _switch13_exit ; case break
1282   0BF3             _switch13_default:
1283   0BF3             ; print("Error: Unknown argument type.\n"); 
1284   0BF3             ; --- START FUNCTION CALL
1285   0BF3 26 8B 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1286   0BF6 FD AB         swp b
1287   0BF8 D8            push b
1288   0BF9 07 05 1D      call print
1289   0BFC 51 02 00      add sp, 2
1290   0BFF             ; --- END FUNCTION CALL
1291   0BFF             _switch13_exit:
1292   0BFF             ; format_p++; 
1293   0BFF FA FD FF      lea d, [bp + -3] ; $format_p
1294   0C02 2A            mov b, [d]
1295   0C03 38 00 00      mov c, 0
1296   0C06 FD 77         inc b
1297   0C08 FA FD FF      lea d, [bp + -3] ; $format_p
1298   0C0B FD 3E         mov [d], bl
1299   0C0D FD 7D         dec b
1300   0C0F 0A 37 0C      jmp _if12_exit
1301   0C12             _if12_else:
1302   0C12             ; putchar(*format_p); 
1303   0C12             ; --- START FUNCTION CALL
1304   0C12 FA FD FF      lea d, [bp + -3] ; $format_p
1305   0C15 2A            mov b, [d]
1306   0C16 38 00 00      mov c, 0
1307   0C19 74            mov d, b
1308   0C1A 32            mov bl, [d]
1309   0C1B A7 00         mov bh, 0
1310   0C1D 38 00 00      mov c, 0
1311   0C20 DD            push bl
1312   0C21 07 B7 1C      call putchar
1313   0C24 51 01 00      add sp, 1
1314   0C27             ; --- END FUNCTION CALL
1315   0C27             ; format_p++; 
1316   0C27 FA FD FF      lea d, [bp + -3] ; $format_p
1317   0C2A 2A            mov b, [d]
1318   0C2B 38 00 00      mov c, 0
1319   0C2E FD 77         inc b
1320   0C30 FA FD FF      lea d, [bp + -3] ; $format_p
1321   0C33 FD 3E         mov [d], bl
1322   0C35 FD 7D         dec b
1323   0C37             _if12_exit:
1324   0C37             _if11_exit:
1325   0C37             _for10_update:
1326   0C37 0A 8A 09      jmp _for10_cond
1327   0C3A             _for10_exit:
1328   0C3A F9            leave
1329   0C3B 09            ret
1330   0C3C             
1331   0C3C             scanf:
1332   0C3C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1333   0C3F             ; char *p, *format_p; 
1334   0C3F 52 02 00      sub sp, 2
1335   0C42 52 02 00      sub sp, 2
1336   0C45             ; char c; 
1337   0C45 52 01 00      sub sp, 1
1338   0C48             ; int i; 
1339   0C48 52 02 00      sub sp, 2
1340   0C4B             ; char input_string[  512                    ]; 
1341   0C4B 52 00 02      sub sp, 512
1342   0C4E             ; format_p = format; 
1343   0C4E FA FD FF      lea d, [bp + -3] ; $format_p
1344   0C51 DA            push d
1345   0C52 FA 05 00      lea d, [bp + 5] ; $format
1346   0C55 2A            mov b, [d]
1347   0C56 38 00 00      mov c, 0
1348   0C59 E7            pop d
1349   0C5A FD 43         mov [d], b
1350   0C5C             ; p = &format + 2; 
1351   0C5C FA FF FF      lea d, [bp + -1] ; $p
1352   0C5F DA            push d
1353   0C60 FA 05 00      lea d, [bp + 5] ; $format
1354   0C63 2D            mov b, d
1355   0C64             ; --- START TERMS
1356   0C64 D7            push a
1357   0C65 11            mov a, b
1358   0C66 FD 2E 02 00   mov32 cb, $00000002
1358   0C6A 00 00 
1359   0C6C 56            add b, a
1360   0C6D E4            pop a
1361   0C6E             ; --- END TERMS
1362   0C6E E7            pop d
1363   0C6F FD 43         mov [d], b
1364   0C71             ; for(;;){ 
1365   0C71             _for17_init:
1366   0C71             _for17_cond:
1367   0C71             _for17_block:
1368   0C71             ; if(!*format_p) break; 
1369   0C71             _if18_cond:
1370   0C71 FA FD FF      lea d, [bp + -3] ; $format_p
1371   0C74 2A            mov b, [d]
1372   0C75 38 00 00      mov c, 0
1373   0C78 74            mov d, b
1374   0C79 32            mov bl, [d]
1375   0C7A A7 00         mov bh, 0
1376   0C7C 38 00 00      mov c, 0
1377   0C7F C0 00 00      cmp b, 0
1378   0C82 FD 71         seq ; !
1379   0C84 C0 00 00      cmp b, 0
1380   0C87 C6 90 0C      je _if18_else
1381   0C8A             _if18_true:
1382   0C8A             ; break; 
1383   0C8A 0A 18 0F      jmp _for17_exit ; for break
1384   0C8D 0A 15 0F      jmp _if18_exit
1385   0C90             _if18_else:
1386   0C90             ; if(*format_p == '%'){ 
1387   0C90             _if19_cond:
1388   0C90 FA FD FF      lea d, [bp + -3] ; $format_p
1389   0C93 2A            mov b, [d]
1390   0C94 38 00 00      mov c, 0
1391   0C97 74            mov d, b
1392   0C98 32            mov bl, [d]
1393   0C99 A7 00         mov bh, 0
1394   0C9B 38 00 00      mov c, 0
1395   0C9E             ; --- START RELATIONAL
1396   0C9E D7            push a
1397   0C9F 11            mov a, b
1398   0CA0 FD 2E 25 00   mov32 cb, $00000025
1398   0CA4 00 00 
1399   0CA6 B0            cmp a, b
1400   0CA7 FD 71         seq ; ==
1401   0CA9 E4            pop a
1402   0CAA             ; --- END RELATIONAL
1403   0CAA C0 00 00      cmp b, 0
1404   0CAD C6 F0 0E      je _if19_else
1405   0CB0             _if19_true:
1406   0CB0             ; format_p++; 
1407   0CB0 FA FD FF      lea d, [bp + -3] ; $format_p
1408   0CB3 2A            mov b, [d]
1409   0CB4 38 00 00      mov c, 0
1410   0CB7 FD 77         inc b
1411   0CB9 FA FD FF      lea d, [bp + -3] ; $format_p
1412   0CBC FD 3E         mov [d], bl
1413   0CBE FD 7D         dec b
1414   0CC0             ; switch(*format_p){ 
1415   0CC0             _switch20_expr:
1416   0CC0 FA FD FF      lea d, [bp + -3] ; $format_p
1417   0CC3 2A            mov b, [d]
1418   0CC4 38 00 00      mov c, 0
1419   0CC7 74            mov d, b
1420   0CC8 32            mov bl, [d]
1421   0CC9 A7 00         mov bh, 0
1422   0CCB 38 00 00      mov c, 0
1423   0CCE             _switch20_comparisons:
1424   0CCE C1 6C         cmp bl, $6c
1425   0CD0 C6 FC 0C      je _switch20_case0
1426   0CD3 C1 4C         cmp bl, $4c
1427   0CD5 C6 FC 0C      je _switch20_case1
1428   0CD8 C1 64         cmp bl, $64
1429   0CDA C6 BB 0D      je _switch20_case2
1430   0CDD C1 69         cmp bl, $69
1431   0CDF C6 BB 0D      je _switch20_case3
1432   0CE2 C1 75         cmp bl, $75
1433   0CE4 C6 F4 0D      je _switch20_case4
1434   0CE7 C1 78         cmp bl, $78
1435   0CE9 C6 2D 0E      je _switch20_case5
1436   0CEC C1 63         cmp bl, $63
1437   0CEE C6 48 0E      je _switch20_case6
1438   0CF1 C1 73         cmp bl, $73
1439   0CF3 C6 8A 0E      je _switch20_case7
1440   0CF6 0A D1 0E      jmp _switch20_default
1441   0CF9 0A DD 0E      jmp _switch20_exit
1442   0CFC             _switch20_case0:
1443   0CFC             _switch20_case1:
1444   0CFC             ; format_p++; 
1445   0CFC FA FD FF      lea d, [bp + -3] ; $format_p
1446   0CFF 2A            mov b, [d]
1447   0D00 38 00 00      mov c, 0
1448   0D03 FD 77         inc b
1449   0D05 FA FD FF      lea d, [bp + -3] ; $format_p
1450   0D08 FD 3E         mov [d], bl
1451   0D0A FD 7D         dec b
1452   0D0C             ; if(*format_p == 'd' || *format_p == 'i'); 
1453   0D0C             _if21_cond:
1454   0D0C FA FD FF      lea d, [bp + -3] ; $format_p
1455   0D0F 2A            mov b, [d]
1456   0D10 38 00 00      mov c, 0
1457   0D13 74            mov d, b
1458   0D14 32            mov bl, [d]
1459   0D15 A7 00         mov bh, 0
1460   0D17 38 00 00      mov c, 0
1461   0D1A             ; --- START RELATIONAL
1462   0D1A D7            push a
1463   0D1B 11            mov a, b
1464   0D1C FD 2E 64 00   mov32 cb, $00000064
1464   0D20 00 00 
1465   0D22 B0            cmp a, b
1466   0D23 FD 71         seq ; ==
1467   0D25 E4            pop a
1468   0D26             ; --- END RELATIONAL
1469   0D26             ; --- START LOGICAL OR
1470   0D26 D7            push a
1471   0D27 11            mov a, b
1472   0D28 FA FD FF      lea d, [bp + -3] ; $format_p
1473   0D2B 2A            mov b, [d]
1474   0D2C 38 00 00      mov c, 0
1475   0D2F 74            mov d, b
1476   0D30 32            mov bl, [d]
1477   0D31 A7 00         mov bh, 0
1478   0D33 38 00 00      mov c, 0
1479   0D36             ; --- START RELATIONAL
1480   0D36 D7            push a
1481   0D37 11            mov a, b
1482   0D38 FD 2E 69 00   mov32 cb, $00000069
1482   0D3C 00 00 
1483   0D3E B0            cmp a, b
1484   0D3F FD 71         seq ; ==
1485   0D41 E4            pop a
1486   0D42             ; --- END RELATIONAL
1487   0D42 FD A8         sor a, b ; ||
1488   0D44 E4            pop a
1489   0D45             ; --- END LOGICAL OR
1490   0D45 C0 00 00      cmp b, 0
1491   0D48 C6 4E 0D      je _if21_else
1492   0D4B             _if21_true:
1493   0D4B             ; ; 
1494   0D4B 0A A0 0D      jmp _if21_exit
1495   0D4E             _if21_else:
1496   0D4E             ; if(*format_p == 'u'); 
1497   0D4E             _if22_cond:
1498   0D4E FA FD FF      lea d, [bp + -3] ; $format_p
1499   0D51 2A            mov b, [d]
1500   0D52 38 00 00      mov c, 0
1501   0D55 74            mov d, b
1502   0D56 32            mov bl, [d]
1503   0D57 A7 00         mov bh, 0
1504   0D59 38 00 00      mov c, 0
1505   0D5C             ; --- START RELATIONAL
1506   0D5C D7            push a
1507   0D5D 11            mov a, b
1508   0D5E FD 2E 75 00   mov32 cb, $00000075
1508   0D62 00 00 
1509   0D64 B0            cmp a, b
1510   0D65 FD 71         seq ; ==
1511   0D67 E4            pop a
1512   0D68             ; --- END RELATIONAL
1513   0D68 C0 00 00      cmp b, 0
1514   0D6B C6 71 0D      je _if22_else
1515   0D6E             _if22_true:
1516   0D6E             ; ; 
1517   0D6E 0A A0 0D      jmp _if22_exit
1518   0D71             _if22_else:
1519   0D71             ; if(*format_p == 'x'); 
1520   0D71             _if23_cond:
1521   0D71 FA FD FF      lea d, [bp + -3] ; $format_p
1522   0D74 2A            mov b, [d]
1523   0D75 38 00 00      mov c, 0
1524   0D78 74            mov d, b
1525   0D79 32            mov bl, [d]
1526   0D7A A7 00         mov bh, 0
1527   0D7C 38 00 00      mov c, 0
1528   0D7F             ; --- START RELATIONAL
1529   0D7F D7            push a
1530   0D80 11            mov a, b
1531   0D81 FD 2E 78 00   mov32 cb, $00000078
1531   0D85 00 00 
1532   0D87 B0            cmp a, b
1533   0D88 FD 71         seq ; ==
1534   0D8A E4            pop a
1535   0D8B             ; --- END RELATIONAL
1536   0D8B C0 00 00      cmp b, 0
1537   0D8E C6 94 0D      je _if23_else
1538   0D91             _if23_true:
1539   0D91             ; ; 
1540   0D91 0A A0 0D      jmp _if23_exit
1541   0D94             _if23_else:
1542   0D94             ; err("Unexpected format in printf."); 
1543   0D94             ; --- START FUNCTION CALL
1544   0D94 26 6E 21      mov b, _s0 ; "Unexpected format in printf."
1545   0D97 FD AB         swp b
1546   0D99 D8            push b
1547   0D9A 07 CA 12      call err
1548   0D9D 51 02 00      add sp, 2
1549   0DA0             ; --- END FUNCTION CALL
1550   0DA0             _if23_exit:
1551   0DA0             _if22_exit:
1552   0DA0             _if21_exit:
1553   0DA0             ; p = p + 4; 
1554   0DA0 FA FF FF      lea d, [bp + -1] ; $p
1555   0DA3 DA            push d
1556   0DA4 FA FF FF      lea d, [bp + -1] ; $p
1557   0DA7 2A            mov b, [d]
1558   0DA8 38 00 00      mov c, 0
1559   0DAB             ; --- START TERMS
1560   0DAB D7            push a
1561   0DAC 11            mov a, b
1562   0DAD FD 2E 04 00   mov32 cb, $00000004
1562   0DB1 00 00 
1563   0DB3 56            add b, a
1564   0DB4 E4            pop a
1565   0DB5             ; --- END TERMS
1566   0DB5 E7            pop d
1567   0DB6 FD 43         mov [d], b
1568   0DB8             ; break; 
1569   0DB8 0A DD 0E      jmp _switch20_exit ; case break
1570   0DBB             _switch20_case2:
1571   0DBB             _switch20_case3:
1572   0DBB             ; i = scann(); 
1573   0DBB FA FA FF      lea d, [bp + -6] ; $i
1574   0DBE DA            push d
1575   0DBF             ; --- START FUNCTION CALL
1576   0DBF 07 DD 1C      call scann
1577   0DC2 E7            pop d
1578   0DC3 FD 43         mov [d], b
1579   0DC5             ; **(int **)p = i; 
1580   0DC5 FA FF FF      lea d, [bp + -1] ; $p
1581   0DC8 2A            mov b, [d]
1582   0DC9 38 00 00      mov c, 0
1583   0DCC 74            mov d, b
1584   0DCD 2A            mov b, [d]
1585   0DCE D8            push b
1586   0DCF FA FA FF      lea d, [bp + -6] ; $i
1587   0DD2 2A            mov b, [d]
1588   0DD3 38 00 00      mov c, 0
1589   0DD6 E7            pop d
1590   0DD7 FD 43         mov [d], b
1591   0DD9             ; p = p + 2; 
1592   0DD9 FA FF FF      lea d, [bp + -1] ; $p
1593   0DDC DA            push d
1594   0DDD FA FF FF      lea d, [bp + -1] ; $p
1595   0DE0 2A            mov b, [d]
1596   0DE1 38 00 00      mov c, 0
1597   0DE4             ; --- START TERMS
1598   0DE4 D7            push a
1599   0DE5 11            mov a, b
1600   0DE6 FD 2E 02 00   mov32 cb, $00000002
1600   0DEA 00 00 
1601   0DEC 56            add b, a
1602   0DED E4            pop a
1603   0DEE             ; --- END TERMS
1604   0DEE E7            pop d
1605   0DEF FD 43         mov [d], b
1606   0DF1             ; break; 
1607   0DF1 0A DD 0E      jmp _switch20_exit ; case break
1608   0DF4             _switch20_case4:
1609   0DF4             ; i = scann(); 
1610   0DF4 FA FA FF      lea d, [bp + -6] ; $i
1611   0DF7 DA            push d
1612   0DF8             ; --- START FUNCTION CALL
1613   0DF8 07 DD 1C      call scann
1614   0DFB E7            pop d
1615   0DFC FD 43         mov [d], b
1616   0DFE             ; **(int **)p = i; 
1617   0DFE FA FF FF      lea d, [bp + -1] ; $p
1618   0E01 2A            mov b, [d]
1619   0E02 38 00 00      mov c, 0
1620   0E05 74            mov d, b
1621   0E06 2A            mov b, [d]
1622   0E07 D8            push b
1623   0E08 FA FA FF      lea d, [bp + -6] ; $i
1624   0E0B 2A            mov b, [d]
1625   0E0C 38 00 00      mov c, 0
1626   0E0F E7            pop d
1627   0E10 FD 43         mov [d], b
1628   0E12             ; p = p + 2; 
1629   0E12 FA FF FF      lea d, [bp + -1] ; $p
1630   0E15 DA            push d
1631   0E16 FA FF FF      lea d, [bp + -1] ; $p
1632   0E19 2A            mov b, [d]
1633   0E1A 38 00 00      mov c, 0
1634   0E1D             ; --- START TERMS
1635   0E1D D7            push a
1636   0E1E 11            mov a, b
1637   0E1F FD 2E 02 00   mov32 cb, $00000002
1637   0E23 00 00 
1638   0E25 56            add b, a
1639   0E26 E4            pop a
1640   0E27             ; --- END TERMS
1641   0E27 E7            pop d
1642   0E28 FD 43         mov [d], b
1643   0E2A             ; break; 
1644   0E2A 0A DD 0E      jmp _switch20_exit ; case break
1645   0E2D             _switch20_case5:
1646   0E2D             ; p = p + 2; 
1647   0E2D FA FF FF      lea d, [bp + -1] ; $p
1648   0E30 DA            push d
1649   0E31 FA FF FF      lea d, [bp + -1] ; $p
1650   0E34 2A            mov b, [d]
1651   0E35 38 00 00      mov c, 0
1652   0E38             ; --- START TERMS
1653   0E38 D7            push a
1654   0E39 11            mov a, b
1655   0E3A FD 2E 02 00   mov32 cb, $00000002
1655   0E3E 00 00 
1656   0E40 56            add b, a
1657   0E41 E4            pop a
1658   0E42             ; --- END TERMS
1659   0E42 E7            pop d
1660   0E43 FD 43         mov [d], b
1661   0E45             ; break; 
1662   0E45 0A DD 0E      jmp _switch20_exit ; case break
1663   0E48             _switch20_case6:
1664   0E48             ; c = getchar(); 
1665   0E48 FA FC FF      lea d, [bp + -4] ; $c
1666   0E4B DA            push d
1667   0E4C             ; --- START FUNCTION CALL
1668   0E4C 07 C4 1C      call getchar
1669   0E4F E7            pop d
1670   0E50 FD 3E         mov [d], bl
1671   0E52             ; **(char **)p = *(char *)c; 
1672   0E52 FA FF FF      lea d, [bp + -1] ; $p
1673   0E55 2A            mov b, [d]
1674   0E56 38 00 00      mov c, 0
1675   0E59 74            mov d, b
1676   0E5A 2A            mov b, [d]
1677   0E5B D8            push b
1678   0E5C FA FC FF      lea d, [bp + -4] ; $c
1679   0E5F 32            mov bl, [d]
1680   0E60 A7 00         mov bh, 0
1681   0E62 38 00 00      mov c, 0
1682   0E65 74            mov d, b
1683   0E66 32            mov bl, [d]
1684   0E67 A7 00         mov bh, 0
1685   0E69 38 00 00      mov c, 0
1686   0E6C E7            pop d
1687   0E6D FD 43         mov [d], b
1688   0E6F             ; p = p + 1; 
1689   0E6F FA FF FF      lea d, [bp + -1] ; $p
1690   0E72 DA            push d
1691   0E73 FA FF FF      lea d, [bp + -1] ; $p
1692   0E76 2A            mov b, [d]
1693   0E77 38 00 00      mov c, 0
1694   0E7A             ; --- START TERMS
1695   0E7A D7            push a
1696   0E7B 11            mov a, b
1697   0E7C FD 2E 01 00   mov32 cb, $00000001
1697   0E80 00 00 
1698   0E82 56            add b, a
1699   0E83 E4            pop a
1700   0E84             ; --- END TERMS
1701   0E84 E7            pop d
1702   0E85 FD 43         mov [d], b
1703   0E87             ; break; 
1704   0E87 0A DD 0E      jmp _switch20_exit ; case break
1705   0E8A             _switch20_case7:
1706   0E8A             ; gets(input_string); 
1707   0E8A             ; --- START FUNCTION CALL
1708   0E8A FA FA FD      lea d, [bp + -518] ; $input_string
1709   0E8D 2D            mov b, d
1710   0E8E 38 00 00      mov c, 0
1711   0E91 FD AB         swp b
1712   0E93 D8            push b
1713   0E94 07 B6 14      call gets
1714   0E97 51 02 00      add sp, 2
1715   0E9A             ; --- END FUNCTION CALL
1716   0E9A             ; strcpy(*(char **)p, input_string); 
1717   0E9A             ; --- START FUNCTION CALL
1718   0E9A FA FA FD      lea d, [bp + -518] ; $input_string
1719   0E9D 2D            mov b, d
1720   0E9E 38 00 00      mov c, 0
1721   0EA1 FD AB         swp b
1722   0EA3 D8            push b
1723   0EA4 FA FF FF      lea d, [bp + -1] ; $p
1724   0EA7 2A            mov b, [d]
1725   0EA8 38 00 00      mov c, 0
1726   0EAB 74            mov d, b
1727   0EAC 2A            mov b, [d]
1728   0EAD FD AB         swp b
1729   0EAF D8            push b
1730   0EB0 07 33 04      call strcpy
1731   0EB3 51 04 00      add sp, 4
1732   0EB6             ; --- END FUNCTION CALL
1733   0EB6             ; p = p + 2; 
1734   0EB6 FA FF FF      lea d, [bp + -1] ; $p
1735   0EB9 DA            push d
1736   0EBA FA FF FF      lea d, [bp + -1] ; $p
1737   0EBD 2A            mov b, [d]
1738   0EBE 38 00 00      mov c, 0
1739   0EC1             ; --- START TERMS
1740   0EC1 D7            push a
1741   0EC2 11            mov a, b
1742   0EC3 FD 2E 02 00   mov32 cb, $00000002
1742   0EC7 00 00 
1743   0EC9 56            add b, a
1744   0ECA E4            pop a
1745   0ECB             ; --- END TERMS
1746   0ECB E7            pop d
1747   0ECC FD 43         mov [d], b
1748   0ECE             ; break; 
1749   0ECE 0A DD 0E      jmp _switch20_exit ; case break
1750   0ED1             _switch20_default:
1751   0ED1             ; print("Error: Unknown argument type.\n"); 
1752   0ED1             ; --- START FUNCTION CALL
1753   0ED1 26 8B 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1754   0ED4 FD AB         swp b
1755   0ED6 D8            push b
1756   0ED7 07 05 1D      call print
1757   0EDA 51 02 00      add sp, 2
1758   0EDD             ; --- END FUNCTION CALL
1759   0EDD             _switch20_exit:
1760   0EDD             ; format_p++; 
1761   0EDD FA FD FF      lea d, [bp + -3] ; $format_p
1762   0EE0 2A            mov b, [d]
1763   0EE1 38 00 00      mov c, 0
1764   0EE4 FD 77         inc b
1765   0EE6 FA FD FF      lea d, [bp + -3] ; $format_p
1766   0EE9 FD 3E         mov [d], bl
1767   0EEB FD 7D         dec b
1768   0EED 0A 15 0F      jmp _if19_exit
1769   0EF0             _if19_else:
1770   0EF0             ; putchar(*format_p); 
1771   0EF0             ; --- START FUNCTION CALL
1772   0EF0 FA FD FF      lea d, [bp + -3] ; $format_p
1773   0EF3 2A            mov b, [d]
1774   0EF4 38 00 00      mov c, 0
1775   0EF7 74            mov d, b
1776   0EF8 32            mov bl, [d]
1777   0EF9 A7 00         mov bh, 0
1778   0EFB 38 00 00      mov c, 0
1779   0EFE DD            push bl
1780   0EFF 07 B7 1C      call putchar
1781   0F02 51 01 00      add sp, 1
1782   0F05             ; --- END FUNCTION CALL
1783   0F05             ; format_p++; 
1784   0F05 FA FD FF      lea d, [bp + -3] ; $format_p
1785   0F08 2A            mov b, [d]
1786   0F09 38 00 00      mov c, 0
1787   0F0C FD 77         inc b
1788   0F0E FA FD FF      lea d, [bp + -3] ; $format_p
1789   0F11 FD 3E         mov [d], bl
1790   0F13 FD 7D         dec b
1791   0F15             _if19_exit:
1792   0F15             _if18_exit:
1793   0F15             _for17_update:
1794   0F15 0A 71 0C      jmp _for17_cond
1795   0F18             _for17_exit:
1796   0F18 F9            leave
1797   0F19 09            ret
1798   0F1A             
1799   0F1A             sprintf:
1800   0F1A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1801   0F1D             ; char *p, *format_p; 
1802   0F1D 52 02 00      sub sp, 2
1803   0F20 52 02 00      sub sp, 2
1804   0F23             ; char *sp; 
1805   0F23 52 02 00      sub sp, 2
1806   0F26             ; sp = dest; 
1807   0F26 FA FB FF      lea d, [bp + -5] ; $sp
1808   0F29 DA            push d
1809   0F2A FA 05 00      lea d, [bp + 5] ; $dest
1810   0F2D 2A            mov b, [d]
1811   0F2E 38 00 00      mov c, 0
1812   0F31 E7            pop d
1813   0F32 FD 43         mov [d], b
1814   0F34             ; format_p = format; 
1815   0F34 FA FD FF      lea d, [bp + -3] ; $format_p
1816   0F37 DA            push d
1817   0F38 FA 07 00      lea d, [bp + 7] ; $format
1818   0F3B 2A            mov b, [d]
1819   0F3C 38 00 00      mov c, 0
1820   0F3F E7            pop d
1821   0F40 FD 43         mov [d], b
1822   0F42             ; p = &format + 2; 
1823   0F42 FA FF FF      lea d, [bp + -1] ; $p
1824   0F45 DA            push d
1825   0F46 FA 07 00      lea d, [bp + 7] ; $format
1826   0F49 2D            mov b, d
1827   0F4A             ; --- START TERMS
1828   0F4A D7            push a
1829   0F4B 11            mov a, b
1830   0F4C FD 2E 02 00   mov32 cb, $00000002
1830   0F50 00 00 
1831   0F52 56            add b, a
1832   0F53 E4            pop a
1833   0F54             ; --- END TERMS
1834   0F54 E7            pop d
1835   0F55 FD 43         mov [d], b
1836   0F57             ; for(;;){ 
1837   0F57             _for24_init:
1838   0F57             _for24_cond:
1839   0F57             _for24_block:
1840   0F57             ; if(!*format_p) break; 
1841   0F57             _if25_cond:
1842   0F57 FA FD FF      lea d, [bp + -3] ; $format_p
1843   0F5A 2A            mov b, [d]
1844   0F5B 38 00 00      mov c, 0
1845   0F5E 74            mov d, b
1846   0F5F 32            mov bl, [d]
1847   0F60 A7 00         mov bh, 0
1848   0F62 38 00 00      mov c, 0
1849   0F65 C0 00 00      cmp b, 0
1850   0F68 FD 71         seq ; !
1851   0F6A C0 00 00      cmp b, 0
1852   0F6D C6 76 0F      je _if25_else
1853   0F70             _if25_true:
1854   0F70             ; break; 
1855   0F70 0A A4 12      jmp _for24_exit ; for break
1856   0F73 0A A1 12      jmp _if25_exit
1857   0F76             _if25_else:
1858   0F76             ; if(*format_p == '%'){ 
1859   0F76             _if26_cond:
1860   0F76 FA FD FF      lea d, [bp + -3] ; $format_p
1861   0F79 2A            mov b, [d]
1862   0F7A 38 00 00      mov c, 0
1863   0F7D 74            mov d, b
1864   0F7E 32            mov bl, [d]
1865   0F7F A7 00         mov bh, 0
1866   0F81 38 00 00      mov c, 0
1867   0F84             ; --- START RELATIONAL
1868   0F84 D7            push a
1869   0F85 11            mov a, b
1870   0F86 FD 2E 25 00   mov32 cb, $00000025
1870   0F8A 00 00 
1871   0F8C B0            cmp a, b
1872   0F8D FD 71         seq ; ==
1873   0F8F E4            pop a
1874   0F90             ; --- END RELATIONAL
1875   0F90 C0 00 00      cmp b, 0
1876   0F93 C6 76 12      je _if26_else
1877   0F96             _if26_true:
1878   0F96             ; format_p++; 
1879   0F96 FA FD FF      lea d, [bp + -3] ; $format_p
1880   0F99 2A            mov b, [d]
1881   0F9A 38 00 00      mov c, 0
1882   0F9D FD 77         inc b
1883   0F9F FA FD FF      lea d, [bp + -3] ; $format_p
1884   0FA2 FD 3E         mov [d], bl
1885   0FA4 FD 7D         dec b
1886   0FA6             ; switch(*format_p){ 
1887   0FA6             _switch27_expr:
1888   0FA6 FA FD FF      lea d, [bp + -3] ; $format_p
1889   0FA9 2A            mov b, [d]
1890   0FAA 38 00 00      mov c, 0
1891   0FAD 74            mov d, b
1892   0FAE 32            mov bl, [d]
1893   0FAF A7 00         mov bh, 0
1894   0FB1 38 00 00      mov c, 0
1895   0FB4             _switch27_comparisons:
1896   0FB4 C1 6C         cmp bl, $6c
1897   0FB6 C6 E2 0F      je _switch27_case0
1898   0FB9 C1 4C         cmp bl, $4c
1899   0FBB C6 E2 0F      je _switch27_case1
1900   0FBE C1 64         cmp bl, $64
1901   0FC0 C6 F2 10      je _switch27_case2
1902   0FC3 C1 69         cmp bl, $69
1903   0FC5 C6 F2 10      je _switch27_case3
1904   0FC8 C1 75         cmp bl, $75
1905   0FCA C6 3E 11      je _switch27_case4
1906   0FCD C1 78         cmp bl, $78
1907   0FCF C6 8A 11      je _switch27_case5
1908   0FD2 C1 63         cmp bl, $63
1909   0FD4 C6 AE 11      je _switch27_case6
1910   0FD7 C1 73         cmp bl, $73
1911   0FD9 C6 EB 11      je _switch27_case7
1912   0FDC 0A 57 12      jmp _switch27_default
1913   0FDF 0A 63 12      jmp _switch27_exit
1914   0FE2             _switch27_case0:
1915   0FE2             _switch27_case1:
1916   0FE2             ; format_p++; 
1917   0FE2 FA FD FF      lea d, [bp + -3] ; $format_p
1918   0FE5 2A            mov b, [d]
1919   0FE6 38 00 00      mov c, 0
1920   0FE9 FD 77         inc b
1921   0FEB FA FD FF      lea d, [bp + -3] ; $format_p
1922   0FEE FD 3E         mov [d], bl
1923   0FF0 FD 7D         dec b
1924   0FF2             ; if(*format_p == 'd' || *format_p == 'i') 
1925   0FF2             _if28_cond:
1926   0FF2 FA FD FF      lea d, [bp + -3] ; $format_p
1927   0FF5 2A            mov b, [d]
1928   0FF6 38 00 00      mov c, 0
1929   0FF9 74            mov d, b
1930   0FFA 32            mov bl, [d]
1931   0FFB A7 00         mov bh, 0
1932   0FFD 38 00 00      mov c, 0
1933   1000             ; --- START RELATIONAL
1934   1000 D7            push a
1935   1001 11            mov a, b
1936   1002 FD 2E 64 00   mov32 cb, $00000064
1936   1006 00 00 
1937   1008 B0            cmp a, b
1938   1009 FD 71         seq ; ==
1939   100B E4            pop a
1940   100C             ; --- END RELATIONAL
1941   100C             ; --- START LOGICAL OR
1942   100C D7            push a
1943   100D 11            mov a, b
1944   100E FA FD FF      lea d, [bp + -3] ; $format_p
1945   1011 2A            mov b, [d]
1946   1012 38 00 00      mov c, 0
1947   1015 74            mov d, b
1948   1016 32            mov bl, [d]
1949   1017 A7 00         mov bh, 0
1950   1019 38 00 00      mov c, 0
1951   101C             ; --- START RELATIONAL
1952   101C D7            push a
1953   101D 11            mov a, b
1954   101E FD 2E 69 00   mov32 cb, $00000069
1954   1022 00 00 
1955   1024 B0            cmp a, b
1956   1025 FD 71         seq ; ==
1957   1027 E4            pop a
1958   1028             ; --- END RELATIONAL
1959   1028 FD A8         sor a, b ; ||
1960   102A E4            pop a
1961   102B             ; --- END LOGICAL OR
1962   102B C0 00 00      cmp b, 0
1963   102E C6 4F 10      je _if28_else
1964   1031             _if28_true:
1965   1031             ; print_signed_long(*(long *)p); 
1966   1031             ; --- START FUNCTION CALL
1967   1031 FA FF FF      lea d, [bp + -1] ; $p
1968   1034 2A            mov b, [d]
1969   1035 38 00 00      mov c, 0
1970   1038 74            mov d, b
1971   1039 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1972   103C FD 39         mov c, b ; And place it into C
1973   103E 2A            mov b, [d] ; Lower Word in B
1974   103F 12            mov a, c
1975   1040 FD AA         swp a
1976   1042 D7            push a
1977   1043 FD AB         swp b
1978   1045 D8            push b
1979   1046 07 0C 16      call print_signed_long
1980   1049 51 04 00      add sp, 4
1981   104C             ; --- END FUNCTION CALL
1982   104C 0A D7 10      jmp _if28_exit
1983   104F             _if28_else:
1984   104F             ; if(*format_p == 'u') 
1985   104F             _if29_cond:
1986   104F FA FD FF      lea d, [bp + -3] ; $format_p
1987   1052 2A            mov b, [d]
1988   1053 38 00 00      mov c, 0
1989   1056 74            mov d, b
1990   1057 32            mov bl, [d]
1991   1058 A7 00         mov bh, 0
1992   105A 38 00 00      mov c, 0
1993   105D             ; --- START RELATIONAL
1994   105D D7            push a
1995   105E 11            mov a, b
1996   105F FD 2E 75 00   mov32 cb, $00000075
1996   1063 00 00 
1997   1065 B0            cmp a, b
1998   1066 FD 71         seq ; ==
1999   1068 E4            pop a
2000   1069             ; --- END RELATIONAL
2001   1069 C0 00 00      cmp b, 0
2002   106C C6 8D 10      je _if29_else
2003   106F             _if29_true:
2004   106F             ; print_unsigned_long(*(unsigned long *)p); 
2005   106F             ; --- START FUNCTION CALL
2006   106F FA FF FF      lea d, [bp + -1] ; $p
2007   1072 2A            mov b, [d]
2008   1073 38 00 00      mov c, 0
2009   1076 74            mov d, b
2010   1077 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2011   107A FD 39         mov c, b ; And place it into C
2012   107C 2A            mov b, [d] ; Lower Word in B
2013   107D 12            mov a, c
2014   107E FD AA         swp a
2015   1080 D7            push a
2016   1081 FD AB         swp b
2017   1083 D8            push b
2018   1084 07 7B 17      call print_unsigned_long
2019   1087 51 04 00      add sp, 4
2020   108A             ; --- END FUNCTION CALL
2021   108A 0A D7 10      jmp _if29_exit
2022   108D             _if29_else:
2023   108D             ; if(*format_p == 'x') 
2024   108D             _if30_cond:
2025   108D FA FD FF      lea d, [bp + -3] ; $format_p
2026   1090 2A            mov b, [d]
2027   1091 38 00 00      mov c, 0
2028   1094 74            mov d, b
2029   1095 32            mov bl, [d]
2030   1096 A7 00         mov bh, 0
2031   1098 38 00 00      mov c, 0
2032   109B             ; --- START RELATIONAL
2033   109B D7            push a
2034   109C 11            mov a, b
2035   109D FD 2E 78 00   mov32 cb, $00000078
2035   10A1 00 00 
2036   10A3 B0            cmp a, b
2037   10A4 FD 71         seq ; ==
2038   10A6 E4            pop a
2039   10A7             ; --- END RELATIONAL
2040   10A7 C0 00 00      cmp b, 0
2041   10AA C6 CB 10      je _if30_else
2042   10AD             _if30_true:
2043   10AD             ; printx32(*(long int *)p); 
2044   10AD             ; --- START FUNCTION CALL
2045   10AD FA FF FF      lea d, [bp + -1] ; $p
2046   10B0 2A            mov b, [d]
2047   10B1 38 00 00      mov c, 0
2048   10B4 74            mov d, b
2049   10B5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2050   10B8 FD 39         mov c, b ; And place it into C
2051   10BA 2A            mov b, [d] ; Lower Word in B
2052   10BB 12            mov a, c
2053   10BC FD AA         swp a
2054   10BE D7            push a
2055   10BF FD AB         swp b
2056   10C1 D8            push b
2057   10C2 07 DF 12      call printx32
2058   10C5 51 04 00      add sp, 4
2059   10C8             ; --- END FUNCTION CALL
2060   10C8 0A D7 10      jmp _if30_exit
2061   10CB             _if30_else:
2062   10CB             ; err("Unexpected format in printf."); 
2063   10CB             ; --- START FUNCTION CALL
2064   10CB 26 6E 21      mov b, _s0 ; "Unexpected format in printf."
2065   10CE FD AB         swp b
2066   10D0 D8            push b
2067   10D1 07 CA 12      call err
2068   10D4 51 02 00      add sp, 2
2069   10D7             ; --- END FUNCTION CALL
2070   10D7             _if30_exit:
2071   10D7             _if29_exit:
2072   10D7             _if28_exit:
2073   10D7             ; p = p + 4; 
2074   10D7 FA FF FF      lea d, [bp + -1] ; $p
2075   10DA DA            push d
2076   10DB FA FF FF      lea d, [bp + -1] ; $p
2077   10DE 2A            mov b, [d]
2078   10DF 38 00 00      mov c, 0
2079   10E2             ; --- START TERMS
2080   10E2 D7            push a
2081   10E3 11            mov a, b
2082   10E4 FD 2E 04 00   mov32 cb, $00000004
2082   10E8 00 00 
2083   10EA 56            add b, a
2084   10EB E4            pop a
2085   10EC             ; --- END TERMS
2086   10EC E7            pop d
2087   10ED FD 43         mov [d], b
2088   10EF             ; break; 
2089   10EF 0A 63 12      jmp _switch27_exit ; case break
2090   10F2             _switch27_case2:
2091   10F2             _switch27_case3:
2092   10F2             ; sp = sp + sprint_signed(sp, *(int*)p); 
2093   10F2 FA FB FF      lea d, [bp + -5] ; $sp
2094   10F5 DA            push d
2095   10F6 FA FB FF      lea d, [bp + -5] ; $sp
2096   10F9 2A            mov b, [d]
2097   10FA 38 00 00      mov c, 0
2098   10FD             ; --- START TERMS
2099   10FD D7            push a
2100   10FE 11            mov a, b
2101   10FF             ; --- START FUNCTION CALL
2102   10FF FA FF FF      lea d, [bp + -1] ; $p
2103   1102 2A            mov b, [d]
2104   1103 38 00 00      mov c, 0
2105   1106 74            mov d, b
2106   1107 2A            mov b, [d]
2107   1108 38 00 00      mov c, 0
2108   110B FD AB         swp b
2109   110D D8            push b
2110   110E FA FB FF      lea d, [bp + -5] ; $sp
2111   1111 2A            mov b, [d]
2112   1112 38 00 00      mov c, 0
2113   1115 FD AB         swp b
2114   1117 D8            push b
2115   1118 07 EF 1A      call sprint_signed
2116   111B 51 04 00      add sp, 4
2117   111E             ; --- END FUNCTION CALL
2118   111E 56            add b, a
2119   111F E4            pop a
2120   1120             ; --- END TERMS
2121   1120 E7            pop d
2122   1121 FD 43         mov [d], b
2123   1123             ; p = p + 2; 
2124   1123 FA FF FF      lea d, [bp + -1] ; $p
2125   1126 DA            push d
2126   1127 FA FF FF      lea d, [bp + -1] ; $p
2127   112A 2A            mov b, [d]
2128   112B 38 00 00      mov c, 0
2129   112E             ; --- START TERMS
2130   112E D7            push a
2131   112F 11            mov a, b
2132   1130 FD 2E 02 00   mov32 cb, $00000002
2132   1134 00 00 
2133   1136 56            add b, a
2134   1137 E4            pop a
2135   1138             ; --- END TERMS
2136   1138 E7            pop d
2137   1139 FD 43         mov [d], b
2138   113B             ; break; 
2139   113B 0A 63 12      jmp _switch27_exit ; case break
2140   113E             _switch27_case4:
2141   113E             ; sp = sp + sprint_unsigned(sp, *(unsigned int*)p); 
2142   113E FA FB FF      lea d, [bp + -5] ; $sp
2143   1141 DA            push d
2144   1142 FA FB FF      lea d, [bp + -5] ; $sp
2145   1145 2A            mov b, [d]
2146   1146 38 00 00      mov c, 0
2147   1149             ; --- START TERMS
2148   1149 D7            push a
2149   114A 11            mov a, b
2150   114B             ; --- START FUNCTION CALL
2151   114B FA FF FF      lea d, [bp + -1] ; $p
2152   114E 2A            mov b, [d]
2153   114F 38 00 00      mov c, 0
2154   1152 74            mov d, b
2155   1153 2A            mov b, [d]
2156   1154 38 00 00      mov c, 0
2157   1157 FD AB         swp b
2158   1159 D8            push b
2159   115A FA FB FF      lea d, [bp + -5] ; $sp
2160   115D 2A            mov b, [d]
2161   115E 38 00 00      mov c, 0
2162   1161 FD AB         swp b
2163   1163 D8            push b
2164   1164 07 97 18      call sprint_unsigned
2165   1167 51 04 00      add sp, 4
2166   116A             ; --- END FUNCTION CALL
2167   116A 56            add b, a
2168   116B E4            pop a
2169   116C             ; --- END TERMS
2170   116C E7            pop d
2171   116D FD 43         mov [d], b
2172   116F             ; p = p + 2; 
2173   116F FA FF FF      lea d, [bp + -1] ; $p
2174   1172 DA            push d
2175   1173 FA FF FF      lea d, [bp + -1] ; $p
2176   1176 2A            mov b, [d]
2177   1177 38 00 00      mov c, 0
2178   117A             ; --- START TERMS
2179   117A D7            push a
2180   117B 11            mov a, b
2181   117C FD 2E 02 00   mov32 cb, $00000002
2181   1180 00 00 
2182   1182 56            add b, a
2183   1183 E4            pop a
2184   1184             ; --- END TERMS
2185   1184 E7            pop d
2186   1185 FD 43         mov [d], b
2187   1187             ; break; 
2188   1187 0A 63 12      jmp _switch27_exit ; case break
2189   118A             _switch27_case5:
2190   118A             
2191   118A             ; --- BEGIN INLINE ASM SEGMENT
2192   118A FA FF FF      lea d, [bp + -1] ; $p
2193   118D FD 2A         mov d, [d]
2194   118F 2A            mov b, [d]
2195   1190 07 68 20      call print_u16x
2196   1193             ; --- END INLINE ASM SEGMENT
2197   1193             
2198   1193             ; p = p + 2; 
2199   1193 FA FF FF      lea d, [bp + -1] ; $p
2200   1196 DA            push d
2201   1197 FA FF FF      lea d, [bp + -1] ; $p
2202   119A 2A            mov b, [d]
2203   119B 38 00 00      mov c, 0
2204   119E             ; --- START TERMS
2205   119E D7            push a
2206   119F 11            mov a, b
2207   11A0 FD 2E 02 00   mov32 cb, $00000002
2207   11A4 00 00 
2208   11A6 56            add b, a
2209   11A7 E4            pop a
2210   11A8             ; --- END TERMS
2211   11A8 E7            pop d
2212   11A9 FD 43         mov [d], b
2213   11AB             ; break; 
2214   11AB 0A 63 12      jmp _switch27_exit ; case break
2215   11AE             _switch27_case6:
2216   11AE             ; *sp++ = *(char *)p; 
2217   11AE FA FB FF      lea d, [bp + -5] ; $sp
2218   11B1 2A            mov b, [d]
2219   11B2 38 00 00      mov c, 0
2220   11B5 FD 77         inc b
2221   11B7 FA FB FF      lea d, [bp + -5] ; $sp
2222   11BA FD 3E         mov [d], bl
2223   11BC FD 7D         dec b
2224   11BE D8            push b
2225   11BF FA FF FF      lea d, [bp + -1] ; $p
2226   11C2 2A            mov b, [d]
2227   11C3 38 00 00      mov c, 0
2228   11C6 74            mov d, b
2229   11C7 32            mov bl, [d]
2230   11C8 A7 00         mov bh, 0
2231   11CA 38 00 00      mov c, 0
2232   11CD E7            pop d
2233   11CE FD 3E         mov [d], bl
2234   11D0             ; p = p + 1; 
2235   11D0 FA FF FF      lea d, [bp + -1] ; $p
2236   11D3 DA            push d
2237   11D4 FA FF FF      lea d, [bp + -1] ; $p
2238   11D7 2A            mov b, [d]
2239   11D8 38 00 00      mov c, 0
2240   11DB             ; --- START TERMS
2241   11DB D7            push a
2242   11DC 11            mov a, b
2243   11DD FD 2E 01 00   mov32 cb, $00000001
2243   11E1 00 00 
2244   11E3 56            add b, a
2245   11E4 E4            pop a
2246   11E5             ; --- END TERMS
2247   11E5 E7            pop d
2248   11E6 FD 43         mov [d], b
2249   11E8             ; break; 
2250   11E8 0A 63 12      jmp _switch27_exit ; case break
2251   11EB             _switch27_case7:
2252   11EB             ; int len = strlen(*(char **)p); 
2253   11EB 52 02 00      sub sp, 2
2254   11EE             ; --- START LOCAL VAR INITIALIZATION
2255   11EE FA F9 FF      lea d, [bp + -7] ; $len
2256   11F1 DA            push d
2257   11F2             ; --- START FUNCTION CALL
2258   11F2 FA FF FF      lea d, [bp + -1] ; $p
2259   11F5 2A            mov b, [d]
2260   11F6 38 00 00      mov c, 0
2261   11F9 74            mov d, b
2262   11FA 2A            mov b, [d]
2263   11FB FD AB         swp b
2264   11FD D8            push b
2265   11FE 07 19 06      call strlen
2266   1201 51 02 00      add sp, 2
2267   1204             ; --- END FUNCTION CALL
2268   1204 E7            pop d
2269   1205 FD 43         mov [d], b
2270   1207             ; --- END LOCAL VAR INITIALIZATION
2271   1207             ; strcpy(sp, *(char **)p); 
2272   1207             ; --- START FUNCTION CALL
2273   1207 FA FF FF      lea d, [bp + -1] ; $p
2274   120A 2A            mov b, [d]
2275   120B 38 00 00      mov c, 0
2276   120E 74            mov d, b
2277   120F 2A            mov b, [d]
2278   1210 FD AB         swp b
2279   1212 D8            push b
2280   1213 FA FB FF      lea d, [bp + -5] ; $sp
2281   1216 2A            mov b, [d]
2282   1217 38 00 00      mov c, 0
2283   121A FD AB         swp b
2284   121C D8            push b
2285   121D 07 33 04      call strcpy
2286   1220 51 04 00      add sp, 4
2287   1223             ; --- END FUNCTION CALL
2288   1223             ; sp = sp + len; 
2289   1223 FA FB FF      lea d, [bp + -5] ; $sp
2290   1226 DA            push d
2291   1227 FA FB FF      lea d, [bp + -5] ; $sp
2292   122A 2A            mov b, [d]
2293   122B 38 00 00      mov c, 0
2294   122E             ; --- START TERMS
2295   122E D7            push a
2296   122F 11            mov a, b
2297   1230 FA F9 FF      lea d, [bp + -7] ; $len
2298   1233 2A            mov b, [d]
2299   1234 38 00 00      mov c, 0
2300   1237 56            add b, a
2301   1238 E4            pop a
2302   1239             ; --- END TERMS
2303   1239 E7            pop d
2304   123A FD 43         mov [d], b
2305   123C             ; p = p + 2; 
2306   123C FA FF FF      lea d, [bp + -1] ; $p
2307   123F DA            push d
2308   1240 FA FF FF      lea d, [bp + -1] ; $p
2309   1243 2A            mov b, [d]
2310   1244 38 00 00      mov c, 0
2311   1247             ; --- START TERMS
2312   1247 D7            push a
2313   1248 11            mov a, b
2314   1249 FD 2E 02 00   mov32 cb, $00000002
2314   124D 00 00 
2315   124F 56            add b, a
2316   1250 E4            pop a
2317   1251             ; --- END TERMS
2318   1251 E7            pop d
2319   1252 FD 43         mov [d], b
2320   1254             ; break; 
2321   1254 0A 63 12      jmp _switch27_exit ; case break
2322   1257             _switch27_default:
2323   1257             ; print("Error: Unknown argument type.\n"); 
2324   1257             ; --- START FUNCTION CALL
2325   1257 26 8B 21      mov b, _s1 ; "Error: Unknown argument type.\n"
2326   125A FD AB         swp b
2327   125C D8            push b
2328   125D 07 05 1D      call print
2329   1260 51 02 00      add sp, 2
2330   1263             ; --- END FUNCTION CALL
2331   1263             _switch27_exit:
2332   1263             ; format_p++; 
2333   1263 FA FD FF      lea d, [bp + -3] ; $format_p
2334   1266 2A            mov b, [d]
2335   1267 38 00 00      mov c, 0
2336   126A FD 77         inc b
2337   126C FA FD FF      lea d, [bp + -3] ; $format_p
2338   126F FD 3E         mov [d], bl
2339   1271 FD 7D         dec b
2340   1273 0A A1 12      jmp _if26_exit
2341   1276             _if26_else:
2342   1276             ; *sp++ = *format_p++; 
2343   1276 FA FB FF      lea d, [bp + -5] ; $sp
2344   1279 2A            mov b, [d]
2345   127A 38 00 00      mov c, 0
2346   127D FD 77         inc b
2347   127F FA FB FF      lea d, [bp + -5] ; $sp
2348   1282 FD 3E         mov [d], bl
2349   1284 FD 7D         dec b
2350   1286 D8            push b
2351   1287 FA FD FF      lea d, [bp + -3] ; $format_p
2352   128A 2A            mov b, [d]
2353   128B 38 00 00      mov c, 0
2354   128E FD 77         inc b
2355   1290 FA FD FF      lea d, [bp + -3] ; $format_p
2356   1293 FD 3E         mov [d], bl
2357   1295 FD 7D         dec b
2358   1297 74            mov d, b
2359   1298 32            mov bl, [d]
2360   1299 A7 00         mov bh, 0
2361   129B 38 00 00      mov c, 0
2362   129E E7            pop d
2363   129F FD 3E         mov [d], bl
2364   12A1             _if26_exit:
2365   12A1             _if25_exit:
2366   12A1             _for24_update:
2367   12A1 0A 57 0F      jmp _for24_cond
2368   12A4             _for24_exit:
2369   12A4             ; *sp = '\0'; 
2370   12A4 FA FB FF      lea d, [bp + -5] ; $sp
2371   12A7 2A            mov b, [d]
2372   12A8 38 00 00      mov c, 0
2373   12AB D8            push b
2374   12AC FD 2E 00 00   mov32 cb, $00000000
2374   12B0 00 00 
2375   12B2 E7            pop d
2376   12B3 FD 3E         mov [d], bl
2377   12B5             ; return sp - dest; // return total number of chars written 
2378   12B5 FA FB FF      lea d, [bp + -5] ; $sp
2379   12B8 2A            mov b, [d]
2380   12B9 38 00 00      mov c, 0
2381   12BC             ; --- START TERMS
2382   12BC D7            push a
2383   12BD 11            mov a, b
2384   12BE FA 05 00      lea d, [bp + 5] ; $dest
2385   12C1 2A            mov b, [d]
2386   12C2 38 00 00      mov c, 0
2387   12C5 60            sub a, b
2388   12C6 27            mov b, a
2389   12C7 E4            pop a
2390   12C8             ; --- END TERMS
2391   12C8 F9            leave
2392   12C9 09            ret
2393   12CA             
2394   12CA             err:
2395   12CA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2396   12CD             ; print(e); 
2397   12CD             ; --- START FUNCTION CALL
2398   12CD FA 05 00      lea d, [bp + 5] ; $e
2399   12D0 2A            mov b, [d]
2400   12D1 38 00 00      mov c, 0
2401   12D4 FD AB         swp b
2402   12D6 D8            push b
2403   12D7 07 05 1D      call print
2404   12DA 51 02 00      add sp, 2
2405   12DD             ; --- END FUNCTION CALL
2406   12DD F9            leave
2407   12DE 09            ret
2408   12DF             
2409   12DF             printx32:
2410   12DF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2411   12E2             
2412   12E2             ; --- BEGIN INLINE ASM SEGMENT
2413   12E2 FA 05 00      lea d, [bp + 5] ; $hex
2414   12E5 2B 02 00      mov b, [d+2]
2415   12E8 07 68 20      call print_u16x
2416   12EB 2A            mov b, [d]
2417   12EC 07 68 20      call print_u16x
2418   12EF             ; --- END INLINE ASM SEGMENT
2419   12EF             
2420   12EF F9            leave
2421   12F0 09            ret
2422   12F1             
2423   12F1             printx16:
2424   12F1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2425   12F4             
2426   12F4             ; --- BEGIN INLINE ASM SEGMENT
2427   12F4 FA 05 00      lea d, [bp + 5] ; $hex
2428   12F7 2A            mov b, [d]
2429   12F8 07 68 20      call print_u16x
2430   12FB             ; --- END INLINE ASM SEGMENT
2431   12FB             
2432   12FB F9            leave
2433   12FC 09            ret
2434   12FD             
2435   12FD             printx8:
2436   12FD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2437   1300             
2438   1300             ; --- BEGIN INLINE ASM SEGMENT
2439   1300 FA 05 00      lea d, [bp + 5] ; $hex
2440   1303 32            mov bl, [d]
2441   1304 07 AC 20      call print_u8x
2442   1307             ; --- END INLINE ASM SEGMENT
2443   1307             
2444   1307 F9            leave
2445   1308 09            ret
2446   1309             
2447   1309             hex_str_to_int:
2448   1309 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2449   130C             ; int value = 0; 
2450   130C 52 02 00      sub sp, 2
2451   130F             ; --- START LOCAL VAR INITIALIZATION
2452   130F FA FF FF      lea d, [bp + -1] ; $value
2453   1312 DA            push d
2454   1313 FD 2E 00 00   mov32 cb, $00000000
2454   1317 00 00 
2455   1319 E7            pop d
2456   131A FD 43         mov [d], b
2457   131C             ; --- END LOCAL VAR INITIALIZATION
2458   131C             ; int i; 
2459   131C 52 02 00      sub sp, 2
2460   131F             ; char hex_char; 
2461   131F 52 01 00      sub sp, 1
2462   1322             ; int len; 
2463   1322 52 02 00      sub sp, 2
2464   1325             ; len = strlen(hex_string); 
2465   1325 FA FA FF      lea d, [bp + -6] ; $len
2466   1328 DA            push d
2467   1329             ; --- START FUNCTION CALL
2468   1329 FA 05 00      lea d, [bp + 5] ; $hex_string
2469   132C 2A            mov b, [d]
2470   132D 38 00 00      mov c, 0
2471   1330 FD AB         swp b
2472   1332 D8            push b
2473   1333 07 19 06      call strlen
2474   1336 51 02 00      add sp, 2
2475   1339             ; --- END FUNCTION CALL
2476   1339 E7            pop d
2477   133A FD 43         mov [d], b
2478   133C             ; for (i = 0; i < len; i++) { 
2479   133C             _for31_init:
2480   133C FA FD FF      lea d, [bp + -3] ; $i
2481   133F DA            push d
2482   1340 FD 2E 00 00   mov32 cb, $00000000
2482   1344 00 00 
2483   1346 E7            pop d
2484   1347 FD 43         mov [d], b
2485   1349             _for31_cond:
2486   1349 FA FD FF      lea d, [bp + -3] ; $i
2487   134C 2A            mov b, [d]
2488   134D 38 00 00      mov c, 0
2489   1350             ; --- START RELATIONAL
2490   1350 D7            push a
2491   1351 11            mov a, b
2492   1352 FA FA FF      lea d, [bp + -6] ; $len
2493   1355 2A            mov b, [d]
2494   1356 38 00 00      mov c, 0
2495   1359 B0            cmp a, b
2496   135A FD 73         slt ; < (signed)
2497   135C E4            pop a
2498   135D             ; --- END RELATIONAL
2499   135D C0 00 00      cmp b, 0
2500   1360 C6 AD 14      je _for31_exit
2501   1363             _for31_block:
2502   1363             ; hex_char = hex_string[i]; 
2503   1363 FA FC FF      lea d, [bp + -4] ; $hex_char
2504   1366 DA            push d
2505   1367 FA 05 00      lea d, [bp + 5] ; $hex_string
2506   136A FD 2A         mov d, [d]
2507   136C D7            push a
2508   136D DA            push d
2509   136E FA FD FF      lea d, [bp + -3] ; $i
2510   1371 2A            mov b, [d]
2511   1372 38 00 00      mov c, 0
2512   1375 E7            pop d
2513   1376 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2514   137A E4            pop a
2515   137B 32            mov bl, [d]
2516   137C A7 00         mov bh, 0
2517   137E 38 00 00      mov c, 0
2518   1381 E7            pop d
2519   1382 FD 3E         mov [d], bl
2520   1384             ; if (hex_char >= 'a' && hex_char <= 'f')  
2521   1384             _if32_cond:
2522   1384 FA FC FF      lea d, [bp + -4] ; $hex_char
2523   1387 32            mov bl, [d]
2524   1388 A7 00         mov bh, 0
2525   138A 38 00 00      mov c, 0
2526   138D             ; --- START RELATIONAL
2527   138D D7            push a
2528   138E 11            mov a, b
2529   138F FD 2E 61 00   mov32 cb, $00000061
2529   1393 00 00 
2530   1395 B0            cmp a, b
2531   1396 FD 80         sge ; >=
2532   1398 E4            pop a
2533   1399             ; --- END RELATIONAL
2534   1399             ; --- START LOGICAL AND
2535   1399 D7            push a
2536   139A 11            mov a, b
2537   139B FA FC FF      lea d, [bp + -4] ; $hex_char
2538   139E 32            mov bl, [d]
2539   139F A7 00         mov bh, 0
2540   13A1 38 00 00      mov c, 0
2541   13A4             ; --- START RELATIONAL
2542   13A4 D7            push a
2543   13A5 11            mov a, b
2544   13A6 FD 2E 66 00   mov32 cb, $00000066
2544   13AA 00 00 
2545   13AC B0            cmp a, b
2546   13AD FD 74         sle ; <= (signed)
2547   13AF E4            pop a
2548   13B0             ; --- END RELATIONAL
2549   13B0 FD A7         sand a, b
2550   13B2 E4            pop a
2551   13B3             ; --- END LOGICAL AND
2552   13B3 C0 00 00      cmp b, 0
2553   13B6 C6 F6 13      je _if32_else
2554   13B9             _if32_true:
2555   13B9             ; value = (value * 16) + (hex_char - 'a' + 10); 
2556   13B9 FA FF FF      lea d, [bp + -1] ; $value
2557   13BC DA            push d
2558   13BD FA FF FF      lea d, [bp + -1] ; $value
2559   13C0 2A            mov b, [d]
2560   13C1 38 00 00      mov c, 0
2561   13C4             ; --- START FACTORS
2562   13C4 D7            push a
2563   13C5 11            mov a, b
2564   13C6 FD 2E 10 00   mov32 cb, $00000010
2564   13CA 00 00 
2565   13CC AC            mul a, b ; *
2566   13CD 11            mov a, b
2567   13CE 27            mov b, a
2568   13CF E4            pop a
2569   13D0             ; --- END FACTORS
2570   13D0             ; --- START TERMS
2571   13D0 D7            push a
2572   13D1 11            mov a, b
2573   13D2 FA FC FF      lea d, [bp + -4] ; $hex_char
2574   13D5 32            mov bl, [d]
2575   13D6 A7 00         mov bh, 0
2576   13D8 38 00 00      mov c, 0
2577   13DB             ; --- START TERMS
2578   13DB D7            push a
2579   13DC 11            mov a, b
2580   13DD FD 2E 61 00   mov32 cb, $00000061
2580   13E1 00 00 
2581   13E3 60            sub a, b
2582   13E4 27            mov b, a
2583   13E5 11            mov a, b
2584   13E6 FD 2E 0A 00   mov32 cb, $0000000a
2584   13EA 00 00 
2585   13EC 56            add b, a
2586   13ED E4            pop a
2587   13EE             ; --- END TERMS
2588   13EE 56            add b, a
2589   13EF E4            pop a
2590   13F0             ; --- END TERMS
2591   13F0 E7            pop d
2592   13F1 FD 43         mov [d], b
2593   13F3 0A 9A 14      jmp _if32_exit
2594   13F6             _if32_else:
2595   13F6             ; if (hex_char >= 'A' && hex_char <= 'F')  
2596   13F6             _if33_cond:
2597   13F6 FA FC FF      lea d, [bp + -4] ; $hex_char
2598   13F9 32            mov bl, [d]
2599   13FA A7 00         mov bh, 0
2600   13FC 38 00 00      mov c, 0
2601   13FF             ; --- START RELATIONAL
2602   13FF D7            push a
2603   1400 11            mov a, b
2604   1401 FD 2E 41 00   mov32 cb, $00000041
2604   1405 00 00 
2605   1407 B0            cmp a, b
2606   1408 FD 80         sge ; >=
2607   140A E4            pop a
2608   140B             ; --- END RELATIONAL
2609   140B             ; --- START LOGICAL AND
2610   140B D7            push a
2611   140C 11            mov a, b
2612   140D FA FC FF      lea d, [bp + -4] ; $hex_char
2613   1410 32            mov bl, [d]
2614   1411 A7 00         mov bh, 0
2615   1413 38 00 00      mov c, 0
2616   1416             ; --- START RELATIONAL
2617   1416 D7            push a
2618   1417 11            mov a, b
2619   1418 FD 2E 46 00   mov32 cb, $00000046
2619   141C 00 00 
2620   141E B0            cmp a, b
2621   141F FD 74         sle ; <= (signed)
2622   1421 E4            pop a
2623   1422             ; --- END RELATIONAL
2624   1422 FD A7         sand a, b
2625   1424 E4            pop a
2626   1425             ; --- END LOGICAL AND
2627   1425 C0 00 00      cmp b, 0
2628   1428 C6 68 14      je _if33_else
2629   142B             _if33_true:
2630   142B             ; value = (value * 16) + (hex_char - 'A' + 10); 
2631   142B FA FF FF      lea d, [bp + -1] ; $value
2632   142E DA            push d
2633   142F FA FF FF      lea d, [bp + -1] ; $value
2634   1432 2A            mov b, [d]
2635   1433 38 00 00      mov c, 0
2636   1436             ; --- START FACTORS
2637   1436 D7            push a
2638   1437 11            mov a, b
2639   1438 FD 2E 10 00   mov32 cb, $00000010
2639   143C 00 00 
2640   143E AC            mul a, b ; *
2641   143F 11            mov a, b
2642   1440 27            mov b, a
2643   1441 E4            pop a
2644   1442             ; --- END FACTORS
2645   1442             ; --- START TERMS
2646   1442 D7            push a
2647   1443 11            mov a, b
2648   1444 FA FC FF      lea d, [bp + -4] ; $hex_char
2649   1447 32            mov bl, [d]
2650   1448 A7 00         mov bh, 0
2651   144A 38 00 00      mov c, 0
2652   144D             ; --- START TERMS
2653   144D D7            push a
2654   144E 11            mov a, b
2655   144F FD 2E 41 00   mov32 cb, $00000041
2655   1453 00 00 
2656   1455 60            sub a, b
2657   1456 27            mov b, a
2658   1457 11            mov a, b
2659   1458 FD 2E 0A 00   mov32 cb, $0000000a
2659   145C 00 00 
2660   145E 56            add b, a
2661   145F E4            pop a
2662   1460             ; --- END TERMS
2663   1460 56            add b, a
2664   1461 E4            pop a
2665   1462             ; --- END TERMS
2666   1462 E7            pop d
2667   1463 FD 43         mov [d], b
2668   1465 0A 9A 14      jmp _if33_exit
2669   1468             _if33_else:
2670   1468             ; value = (value * 16) + (hex_char - '0'); 
2671   1468 FA FF FF      lea d, [bp + -1] ; $value
2672   146B DA            push d
2673   146C FA FF FF      lea d, [bp + -1] ; $value
2674   146F 2A            mov b, [d]
2675   1470 38 00 00      mov c, 0
2676   1473             ; --- START FACTORS
2677   1473 D7            push a
2678   1474 11            mov a, b
2679   1475 FD 2E 10 00   mov32 cb, $00000010
2679   1479 00 00 
2680   147B AC            mul a, b ; *
2681   147C 11            mov a, b
2682   147D 27            mov b, a
2683   147E E4            pop a
2684   147F             ; --- END FACTORS
2685   147F             ; --- START TERMS
2686   147F D7            push a
2687   1480 11            mov a, b
2688   1481 FA FC FF      lea d, [bp + -4] ; $hex_char
2689   1484 32            mov bl, [d]
2690   1485 A7 00         mov bh, 0
2691   1487 38 00 00      mov c, 0
2692   148A             ; --- START TERMS
2693   148A D7            push a
2694   148B 11            mov a, b
2695   148C FD 2E 30 00   mov32 cb, $00000030
2695   1490 00 00 
2696   1492 60            sub a, b
2697   1493 27            mov b, a
2698   1494 E4            pop a
2699   1495             ; --- END TERMS
2700   1495 56            add b, a
2701   1496 E4            pop a
2702   1497             ; --- END TERMS
2703   1497 E7            pop d
2704   1498 FD 43         mov [d], b
2705   149A             _if33_exit:
2706   149A             _if32_exit:
2707   149A             _for31_update:
2708   149A FA FD FF      lea d, [bp + -3] ; $i
2709   149D 2A            mov b, [d]
2710   149E 38 00 00      mov c, 0
2711   14A1 11            mov a, b
2712   14A2 FD 77         inc b
2713   14A4 FA FD FF      lea d, [bp + -3] ; $i
2714   14A7 FD 43         mov [d], b
2715   14A9 27            mov b, a
2716   14AA 0A 49 13      jmp _for31_cond
2717   14AD             _for31_exit:
2718   14AD             ; return value; 
2719   14AD FA FF FF      lea d, [bp + -1] ; $value
2720   14B0 2A            mov b, [d]
2721   14B1 38 00 00      mov c, 0
2722   14B4 F9            leave
2723   14B5 09            ret
2724   14B6             
2725   14B6             gets:
2726   14B6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2727   14B9             
2728   14B9             ; --- BEGIN INLINE ASM SEGMENT
2729   14B9 FA 05 00      lea d, [bp + 5] ; $s
2730   14BC 15            mov a, [d]
2731   14BD 3C            mov d, a
2732   14BE 07 CD 1E      call _gets
2733   14C1             ; --- END INLINE ASM SEGMENT
2734   14C1             
2735   14C1             ; return strlen(s); 
2736   14C1             ; --- START FUNCTION CALL
2737   14C1 FA 05 00      lea d, [bp + 5] ; $s
2738   14C4 2A            mov b, [d]
2739   14C5 38 00 00      mov c, 0
2740   14C8 FD AB         swp b
2741   14CA D8            push b
2742   14CB 07 19 06      call strlen
2743   14CE 51 02 00      add sp, 2
2744   14D1             ; --- END FUNCTION CALL
2745   14D1 F9            leave
2746   14D2 09            ret
2747   14D3             
2748   14D3             print_signed:
2749   14D3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2750   14D6             ; char digits[5]; 
2751   14D6 52 05 00      sub sp, 5
2752   14D9             ; int i = 0; 
2753   14D9 52 02 00      sub sp, 2
2754   14DC             ; --- START LOCAL VAR INITIALIZATION
2755   14DC FA FA FF      lea d, [bp + -6] ; $i
2756   14DF DA            push d
2757   14E0 FD 2E 00 00   mov32 cb, $00000000
2757   14E4 00 00 
2758   14E6 E7            pop d
2759   14E7 FD 43         mov [d], b
2760   14E9             ; --- END LOCAL VAR INITIALIZATION
2761   14E9             ; if (num < 0) { 
2762   14E9             _if34_cond:
2763   14E9 FA 05 00      lea d, [bp + 5] ; $num
2764   14EC 2A            mov b, [d]
2765   14ED 38 00 00      mov c, 0
2766   14F0             ; --- START RELATIONAL
2767   14F0 D7            push a
2768   14F1 11            mov a, b
2769   14F2 FD 2E 00 00   mov32 cb, $00000000
2769   14F6 00 00 
2770   14F8 B0            cmp a, b
2771   14F9 FD 73         slt ; < (signed)
2772   14FB E4            pop a
2773   14FC             ; --- END RELATIONAL
2774   14FC C0 00 00      cmp b, 0
2775   14FF C6 22 15      je _if34_else
2776   1502             _if34_true:
2777   1502             ; putchar('-'); 
2778   1502             ; --- START FUNCTION CALL
2779   1502 FD 2E 2D 00   mov32 cb, $0000002d
2779   1506 00 00 
2780   1508 DD            push bl
2781   1509 07 B7 1C      call putchar
2782   150C 51 01 00      add sp, 1
2783   150F             ; --- END FUNCTION CALL
2784   150F             ; num = -num; 
2785   150F FA 05 00      lea d, [bp + 5] ; $num
2786   1512 DA            push d
2787   1513 FA 05 00      lea d, [bp + 5] ; $num
2788   1516 2A            mov b, [d]
2789   1517 38 00 00      mov c, 0
2790   151A FD 97         neg b
2791   151C E7            pop d
2792   151D FD 43         mov [d], b
2793   151F 0A 4D 15      jmp _if34_exit
2794   1522             _if34_else:
2795   1522             ; if (num == 0) { 
2796   1522             _if35_cond:
2797   1522 FA 05 00      lea d, [bp + 5] ; $num
2798   1525 2A            mov b, [d]
2799   1526 38 00 00      mov c, 0
2800   1529             ; --- START RELATIONAL
2801   1529 D7            push a
2802   152A 11            mov a, b
2803   152B FD 2E 00 00   mov32 cb, $00000000
2803   152F 00 00 
2804   1531 B0            cmp a, b
2805   1532 FD 71         seq ; ==
2806   1534 E4            pop a
2807   1535             ; --- END RELATIONAL
2808   1535 C0 00 00      cmp b, 0
2809   1538 C6 4D 15      je _if35_exit
2810   153B             _if35_true:
2811   153B             ; putchar('0'); 
2812   153B             ; --- START FUNCTION CALL
2813   153B FD 2E 30 00   mov32 cb, $00000030
2813   153F 00 00 
2814   1541 DD            push bl
2815   1542 07 B7 1C      call putchar
2816   1545 51 01 00      add sp, 1
2817   1548             ; --- END FUNCTION CALL
2818   1548             ; return; 
2819   1548 F9            leave
2820   1549 09            ret
2821   154A 0A 4D 15      jmp _if35_exit
2822   154D             _if35_exit:
2823   154D             _if34_exit:
2824   154D             ; while (num > 0) { 
2825   154D             _while36_cond:
2826   154D FA 05 00      lea d, [bp + 5] ; $num
2827   1550 2A            mov b, [d]
2828   1551 38 00 00      mov c, 0
2829   1554             ; --- START RELATIONAL
2830   1554 D7            push a
2831   1555 11            mov a, b
2832   1556 FD 2E 00 00   mov32 cb, $00000000
2832   155A 00 00 
2833   155C B0            cmp a, b
2834   155D FD 7F         sgt ; >
2835   155F E4            pop a
2836   1560             ; --- END RELATIONAL
2837   1560 C0 00 00      cmp b, 0
2838   1563 C6 C2 15      je _while36_exit
2839   1566             _while36_block:
2840   1566             ; digits[i] = '0' + (num % 10); 
2841   1566 FA FC FF      lea d, [bp + -4] ; $digits
2842   1569 D7            push a
2843   156A DA            push d
2844   156B FA FA FF      lea d, [bp + -6] ; $i
2845   156E 2A            mov b, [d]
2846   156F 38 00 00      mov c, 0
2847   1572 E7            pop d
2848   1573 5A            add d, b
2849   1574 E4            pop a
2850   1575 DA            push d
2851   1576 FD 2E 30 00   mov32 cb, $00000030
2851   157A 00 00 
2852   157C             ; --- START TERMS
2853   157C D7            push a
2854   157D 11            mov a, b
2855   157E FA 05 00      lea d, [bp + 5] ; $num
2856   1581 2A            mov b, [d]
2857   1582 38 00 00      mov c, 0
2858   1585             ; --- START FACTORS
2859   1585 D7            push a
2860   1586 11            mov a, b
2861   1587 FD 2E 0A 00   mov32 cb, $0000000a
2861   158B 00 00 
2862   158D AE            div a, b ; 
2863   158E 11            mov a, b
2864   158F 27            mov b, a
2865   1590 E4            pop a
2866   1591             ; --- END FACTORS
2867   1591 56            add b, a
2868   1592 E4            pop a
2869   1593             ; --- END TERMS
2870   1593 E7            pop d
2871   1594 FD 3E         mov [d], bl
2872   1596             ; num = num / 10; 
2873   1596 FA 05 00      lea d, [bp + 5] ; $num
2874   1599 DA            push d
2875   159A FA 05 00      lea d, [bp + 5] ; $num
2876   159D 2A            mov b, [d]
2877   159E 38 00 00      mov c, 0
2878   15A1             ; --- START FACTORS
2879   15A1 D7            push a
2880   15A2 11            mov a, b
2881   15A3 FD 2E 0A 00   mov32 cb, $0000000a
2881   15A7 00 00 
2882   15A9 AE            div a, b
2883   15AA 27            mov b, a
2884   15AB E4            pop a
2885   15AC             ; --- END FACTORS
2886   15AC E7            pop d
2887   15AD FD 43         mov [d], b
2888   15AF             ; i++; 
2889   15AF FA FA FF      lea d, [bp + -6] ; $i
2890   15B2 2A            mov b, [d]
2891   15B3 38 00 00      mov c, 0
2892   15B6 11            mov a, b
2893   15B7 FD 77         inc b
2894   15B9 FA FA FF      lea d, [bp + -6] ; $i
2895   15BC FD 43         mov [d], b
2896   15BE 27            mov b, a
2897   15BF 0A 4D 15      jmp _while36_cond
2898   15C2             _while36_exit:
2899   15C2             ; while (i > 0) { 
2900   15C2             _while37_cond:
2901   15C2 FA FA FF      lea d, [bp + -6] ; $i
2902   15C5 2A            mov b, [d]
2903   15C6 38 00 00      mov c, 0
2904   15C9             ; --- START RELATIONAL
2905   15C9 D7            push a
2906   15CA 11            mov a, b
2907   15CB FD 2E 00 00   mov32 cb, $00000000
2907   15CF 00 00 
2908   15D1 B0            cmp a, b
2909   15D2 FD 7F         sgt ; >
2910   15D4 E4            pop a
2911   15D5             ; --- END RELATIONAL
2912   15D5 C0 00 00      cmp b, 0
2913   15D8 C6 0A 16      je _while37_exit
2914   15DB             _while37_block:
2915   15DB             ; i--; 
2916   15DB FA FA FF      lea d, [bp + -6] ; $i
2917   15DE 2A            mov b, [d]
2918   15DF 38 00 00      mov c, 0
2919   15E2 11            mov a, b
2920   15E3 FD 7D         dec b
2921   15E5 FA FA FF      lea d, [bp + -6] ; $i
2922   15E8 FD 43         mov [d], b
2923   15EA 27            mov b, a
2924   15EB             ; putchar(digits[i]); 
2925   15EB             ; --- START FUNCTION CALL
2926   15EB FA FC FF      lea d, [bp + -4] ; $digits
2927   15EE D7            push a
2928   15EF DA            push d
2929   15F0 FA FA FF      lea d, [bp + -6] ; $i
2930   15F3 2A            mov b, [d]
2931   15F4 38 00 00      mov c, 0
2932   15F7 E7            pop d
2933   15F8 5A            add d, b
2934   15F9 E4            pop a
2935   15FA 32            mov bl, [d]
2936   15FB A7 00         mov bh, 0
2937   15FD 38 00 00      mov c, 0
2938   1600 DD            push bl
2939   1601 07 B7 1C      call putchar
2940   1604 51 01 00      add sp, 1
2941   1607             ; --- END FUNCTION CALL
2942   1607 0A C2 15      jmp _while37_cond
2943   160A             _while37_exit:
2944   160A F9            leave
2945   160B 09            ret
2946   160C             
2947   160C             print_signed_long:
2948   160C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2949   160F             ; char digits[10]; 
2950   160F 52 0A 00      sub sp, 10
2951   1612             ; int i = 0; 
2952   1612 52 02 00      sub sp, 2
2953   1615             ; --- START LOCAL VAR INITIALIZATION
2954   1615 FA F5 FF      lea d, [bp + -11] ; $i
2955   1618 DA            push d
2956   1619 FD 2E 00 00   mov32 cb, $00000000
2956   161D 00 00 
2957   161F E7            pop d
2958   1620 FD 43         mov [d], b
2959   1622             ; --- END LOCAL VAR INITIALIZATION
2960   1622             ; if (num < 0) { 
2961   1622             _if38_cond:
2962   1622 FA 05 00      lea d, [bp + 5] ; $num
2963   1625 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2964   1628 FD 39         mov c, b ; And place it into C
2965   162A 2A            mov b, [d] ; Lower Word in B
2966   162B             ; --- START RELATIONAL
2967   162B D7            push a
2968   162C FD D8         push g
2969   162E 11            mov a, b
2970   162F FD 7A         mov g, c
2971   1631 FD 2E 00 00   mov32 cb, $00000000
2971   1635 00 00 
2972   1637 FD AF         cmp32 ga, cb
2973   1639 FD 73         slt ; <
2974   163B FD F1         pop g
2975   163D E4            pop a
2976   163E             ; --- END RELATIONAL
2977   163E C0 00 00      cmp b, 0
2978   1641 C6 75 16      je _if38_else
2979   1644             _if38_true:
2980   1644             ; putchar('-'); 
2981   1644             ; --- START FUNCTION CALL
2982   1644 FD 2E 2D 00   mov32 cb, $0000002d
2982   1648 00 00 
2983   164A DD            push bl
2984   164B 07 B7 1C      call putchar
2985   164E 51 01 00      add sp, 1
2986   1651             ; --- END FUNCTION CALL
2987   1651             ; num = -num; 
2988   1651 FA 05 00      lea d, [bp + 5] ; $num
2989   1654 DA            push d
2990   1655 FA 05 00      lea d, [bp + 5] ; $num
2991   1658 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2992   165B FD 39         mov c, b ; And place it into C
2993   165D 2A            mov b, [d] ; Lower Word in B
2994   165E 12            mov a, c
2995   165F 95            not a
2996   1660 97            not b
2997   1661 55 01 00      add b, 1
2998   1664 5B 00 00      adc a, 0
2999   1667 39            mov c, a
3000   1668 E7            pop d
3001   1669 FD 43         mov [d], b
3002   166B 26 00 00      mov b, 0
3003   166E FD 44 02 00   mov [d + 2], b
3004   1672 0A A9 16      jmp _if38_exit
3005   1675             _if38_else:
3006   1675             ; if (num == 0) { 
3007   1675             _if39_cond:
3008   1675 FA 05 00      lea d, [bp + 5] ; $num
3009   1678 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3010   167B FD 39         mov c, b ; And place it into C
3011   167D 2A            mov b, [d] ; Lower Word in B
3012   167E             ; --- START RELATIONAL
3013   167E D7            push a
3014   167F FD D8         push g
3015   1681 11            mov a, b
3016   1682 FD 7A         mov g, c
3017   1684 FD 2E 00 00   mov32 cb, $00000000
3017   1688 00 00 
3018   168A FD AF         cmp32 ga, cb
3019   168C FD 71         seq ; ==
3020   168E FD F1         pop g
3021   1690 E4            pop a
3022   1691             ; --- END RELATIONAL
3023   1691 C0 00 00      cmp b, 0
3024   1694 C6 A9 16      je _if39_exit
3025   1697             _if39_true:
3026   1697             ; putchar('0'); 
3027   1697             ; --- START FUNCTION CALL
3028   1697 FD 2E 30 00   mov32 cb, $00000030
3028   169B 00 00 
3029   169D DD            push bl
3030   169E 07 B7 1C      call putchar
3031   16A1 51 01 00      add sp, 1
3032   16A4             ; --- END FUNCTION CALL
3033   16A4             ; return; 
3034   16A4 F9            leave
3035   16A5 09            ret
3036   16A6 0A A9 16      jmp _if39_exit
3037   16A9             _if39_exit:
3038   16A9             _if38_exit:
3039   16A9             ; while (num > 0) { 
3040   16A9             _while40_cond:
3041   16A9 FA 05 00      lea d, [bp + 5] ; $num
3042   16AC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3043   16AF FD 39         mov c, b ; And place it into C
3044   16B1 2A            mov b, [d] ; Lower Word in B
3045   16B2             ; --- START RELATIONAL
3046   16B2 D7            push a
3047   16B3 FD D8         push g
3048   16B5 11            mov a, b
3049   16B6 FD 7A         mov g, c
3050   16B8 FD 2E 00 00   mov32 cb, $00000000
3050   16BC 00 00 
3051   16BE FD AF         cmp32 ga, cb
3052   16C0 FD 7F         sgt
3053   16C2 FD F1         pop g
3054   16C4 E4            pop a
3055   16C5             ; --- END RELATIONAL
3056   16C5 C0 00 00      cmp b, 0
3057   16C8 C6 31 17      je _while40_exit
3058   16CB             _while40_block:
3059   16CB             ; digits[i] = '0' + (num % 10); 
3060   16CB FA F7 FF      lea d, [bp + -9] ; $digits
3061   16CE D7            push a
3062   16CF DA            push d
3063   16D0 FA F5 FF      lea d, [bp + -11] ; $i
3064   16D3 2A            mov b, [d]
3065   16D4 38 00 00      mov c, 0
3066   16D7 E7            pop d
3067   16D8 5A            add d, b
3068   16D9 E4            pop a
3069   16DA DA            push d
3070   16DB FD 2E 30 00   mov32 cb, $00000030
3070   16DF 00 00 
3071   16E1             ; --- START TERMS
3072   16E1 D7            push a
3073   16E2 11            mov a, b
3074   16E3 FA 05 00      lea d, [bp + 5] ; $num
3075   16E6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3076   16E9 FD 39         mov c, b ; And place it into C
3077   16EB 2A            mov b, [d] ; Lower Word in B
3078   16EC             ; --- START FACTORS
3079   16EC D7            push a
3080   16ED 11            mov a, b
3081   16EE FD 2E 0A 00   mov32 cb, $0000000a
3081   16F2 00 00 
3082   16F4 AE            div a, b ; 
3083   16F5 11            mov a, b
3084   16F6 27            mov b, a
3085   16F7 E4            pop a
3086   16F8             ; --- END FACTORS
3087   16F8 FD 15         add32 cb, ga
3088   16FA E4            pop a
3089   16FB             ; --- END TERMS
3090   16FB E7            pop d
3091   16FC FD 3E         mov [d], bl
3092   16FE             ; num = num / 10; 
3093   16FE FA 05 00      lea d, [bp + 5] ; $num
3094   1701 DA            push d
3095   1702 FA 05 00      lea d, [bp + 5] ; $num
3096   1705 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3097   1708 FD 39         mov c, b ; And place it into C
3098   170A 2A            mov b, [d] ; Lower Word in B
3099   170B             ; --- START FACTORS
3100   170B D7            push a
3101   170C 11            mov a, b
3102   170D FD 2E 0A 00   mov32 cb, $0000000a
3102   1711 00 00 
3103   1713 AE            div a, b
3104   1714 27            mov b, a
3105   1715 E4            pop a
3106   1716             ; --- END FACTORS
3107   1716 E7            pop d
3108   1717 FD 43         mov [d], b
3109   1719 28            mov b, c
3110   171A FD 44 02 00   mov [d + 2], b
3111   171E             ; i++; 
3112   171E FA F5 FF      lea d, [bp + -11] ; $i
3113   1721 2A            mov b, [d]
3114   1722 38 00 00      mov c, 0
3115   1725 11            mov a, b
3116   1726 FD 77         inc b
3117   1728 FA F5 FF      lea d, [bp + -11] ; $i
3118   172B FD 43         mov [d], b
3119   172D 27            mov b, a
3120   172E 0A A9 16      jmp _while40_cond
3121   1731             _while40_exit:
3122   1731             ; while (i > 0) { 
3123   1731             _while41_cond:
3124   1731 FA F5 FF      lea d, [bp + -11] ; $i
3125   1734 2A            mov b, [d]
3126   1735 38 00 00      mov c, 0
3127   1738             ; --- START RELATIONAL
3128   1738 D7            push a
3129   1739 11            mov a, b
3130   173A FD 2E 00 00   mov32 cb, $00000000
3130   173E 00 00 
3131   1740 B0            cmp a, b
3132   1741 FD 7F         sgt ; >
3133   1743 E4            pop a
3134   1744             ; --- END RELATIONAL
3135   1744 C0 00 00      cmp b, 0
3136   1747 C6 79 17      je _while41_exit
3137   174A             _while41_block:
3138   174A             ; i--; 
3139   174A FA F5 FF      lea d, [bp + -11] ; $i
3140   174D 2A            mov b, [d]
3141   174E 38 00 00      mov c, 0
3142   1751 11            mov a, b
3143   1752 FD 7D         dec b
3144   1754 FA F5 FF      lea d, [bp + -11] ; $i
3145   1757 FD 43         mov [d], b
3146   1759 27            mov b, a
3147   175A             ; putchar(digits[i]); 
3148   175A             ; --- START FUNCTION CALL
3149   175A FA F7 FF      lea d, [bp + -9] ; $digits
3150   175D D7            push a
3151   175E DA            push d
3152   175F FA F5 FF      lea d, [bp + -11] ; $i
3153   1762 2A            mov b, [d]
3154   1763 38 00 00      mov c, 0
3155   1766 E7            pop d
3156   1767 5A            add d, b
3157   1768 E4            pop a
3158   1769 32            mov bl, [d]
3159   176A A7 00         mov bh, 0
3160   176C 38 00 00      mov c, 0
3161   176F DD            push bl
3162   1770 07 B7 1C      call putchar
3163   1773 51 01 00      add sp, 1
3164   1776             ; --- END FUNCTION CALL
3165   1776 0A 31 17      jmp _while41_cond
3166   1779             _while41_exit:
3167   1779 F9            leave
3168   177A 09            ret
3169   177B             
3170   177B             print_unsigned_long:
3171   177B F8 00 00      enter 0 ; (push bp; mov bp, sp)
3172   177E             ; char digits[10]; 
3173   177E 52 0A 00      sub sp, 10
3174   1781             ; int i; 
3175   1781 52 02 00      sub sp, 2
3176   1784             ; i = 0; 
3177   1784 FA F5 FF      lea d, [bp + -11] ; $i
3178   1787 DA            push d
3179   1788 FD 2E 00 00   mov32 cb, $00000000
3179   178C 00 00 
3180   178E E7            pop d
3181   178F FD 43         mov [d], b
3182   1791             ; if(num == 0){ 
3183   1791             _if42_cond:
3184   1791 FA 05 00      lea d, [bp + 5] ; $num
3185   1794 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3186   1797 FD 39         mov c, b ; And place it into C
3187   1799 2A            mov b, [d] ; Lower Word in B
3188   179A             ; --- START RELATIONAL
3189   179A D7            push a
3190   179B FD D8         push g
3191   179D 11            mov a, b
3192   179E FD 7A         mov g, c
3193   17A0 FD 2E 00 00   mov32 cb, $00000000
3193   17A4 00 00 
3194   17A6 FD AF         cmp32 ga, cb
3195   17A8 FD 71         seq ; ==
3196   17AA FD F1         pop g
3197   17AC E4            pop a
3198   17AD             ; --- END RELATIONAL
3199   17AD C0 00 00      cmp b, 0
3200   17B0 C6 C5 17      je _if42_exit
3201   17B3             _if42_true:
3202   17B3             ; putchar('0'); 
3203   17B3             ; --- START FUNCTION CALL
3204   17B3 FD 2E 30 00   mov32 cb, $00000030
3204   17B7 00 00 
3205   17B9 DD            push bl
3206   17BA 07 B7 1C      call putchar
3207   17BD 51 01 00      add sp, 1
3208   17C0             ; --- END FUNCTION CALL
3209   17C0             ; return; 
3210   17C0 F9            leave
3211   17C1 09            ret
3212   17C2 0A C5 17      jmp _if42_exit
3213   17C5             _if42_exit:
3214   17C5             ; while (num > 0) { 
3215   17C5             _while43_cond:
3216   17C5 FA 05 00      lea d, [bp + 5] ; $num
3217   17C8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3218   17CB FD 39         mov c, b ; And place it into C
3219   17CD 2A            mov b, [d] ; Lower Word in B
3220   17CE             ; --- START RELATIONAL
3221   17CE D7            push a
3222   17CF FD D8         push g
3223   17D1 11            mov a, b
3224   17D2 FD 7A         mov g, c
3225   17D4 FD 2E 00 00   mov32 cb, $00000000
3225   17D8 00 00 
3226   17DA FD AF         cmp32 ga, cb
3227   17DC FD 81         sgu
3228   17DE FD F1         pop g
3229   17E0 E4            pop a
3230   17E1             ; --- END RELATIONAL
3231   17E1 C0 00 00      cmp b, 0
3232   17E4 C6 4D 18      je _while43_exit
3233   17E7             _while43_block:
3234   17E7             ; digits[i] = '0' + (num % 10); 
3235   17E7 FA F7 FF      lea d, [bp + -9] ; $digits
3236   17EA D7            push a
3237   17EB DA            push d
3238   17EC FA F5 FF      lea d, [bp + -11] ; $i
3239   17EF 2A            mov b, [d]
3240   17F0 38 00 00      mov c, 0
3241   17F3 E7            pop d
3242   17F4 5A            add d, b
3243   17F5 E4            pop a
3244   17F6 DA            push d
3245   17F7 FD 2E 30 00   mov32 cb, $00000030
3245   17FB 00 00 
3246   17FD             ; --- START TERMS
3247   17FD D7            push a
3248   17FE 11            mov a, b
3249   17FF FA 05 00      lea d, [bp + 5] ; $num
3250   1802 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3251   1805 FD 39         mov c, b ; And place it into C
3252   1807 2A            mov b, [d] ; Lower Word in B
3253   1808             ; --- START FACTORS
3254   1808 D7            push a
3255   1809 11            mov a, b
3256   180A FD 2E 0A 00   mov32 cb, $0000000a
3256   180E 00 00 
3257   1810 AE            div a, b ; 
3258   1811 11            mov a, b
3259   1812 27            mov b, a
3260   1813 E4            pop a
3261   1814             ; --- END FACTORS
3262   1814 FD 15         add32 cb, ga
3263   1816 E4            pop a
3264   1817             ; --- END TERMS
3265   1817 E7            pop d
3266   1818 FD 3E         mov [d], bl
3267   181A             ; num = num / 10; 
3268   181A FA 05 00      lea d, [bp + 5] ; $num
3269   181D DA            push d
3270   181E FA 05 00      lea d, [bp + 5] ; $num
3271   1821 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3272   1824 FD 39         mov c, b ; And place it into C
3273   1826 2A            mov b, [d] ; Lower Word in B
3274   1827             ; --- START FACTORS
3275   1827 D7            push a
3276   1828 11            mov a, b
3277   1829 FD 2E 0A 00   mov32 cb, $0000000a
3277   182D 00 00 
3278   182F AE            div a, b
3279   1830 27            mov b, a
3280   1831 E4            pop a
3281   1832             ; --- END FACTORS
3282   1832 E7            pop d
3283   1833 FD 43         mov [d], b
3284   1835 28            mov b, c
3285   1836 FD 44 02 00   mov [d + 2], b
3286   183A             ; i++; 
3287   183A FA F5 FF      lea d, [bp + -11] ; $i
3288   183D 2A            mov b, [d]
3289   183E 38 00 00      mov c, 0
3290   1841 11            mov a, b
3291   1842 FD 77         inc b
3292   1844 FA F5 FF      lea d, [bp + -11] ; $i
3293   1847 FD 43         mov [d], b
3294   1849 27            mov b, a
3295   184A 0A C5 17      jmp _while43_cond
3296   184D             _while43_exit:
3297   184D             ; while (i > 0) { 
3298   184D             _while44_cond:
3299   184D FA F5 FF      lea d, [bp + -11] ; $i
3300   1850 2A            mov b, [d]
3301   1851 38 00 00      mov c, 0
3302   1854             ; --- START RELATIONAL
3303   1854 D7            push a
3304   1855 11            mov a, b
3305   1856 FD 2E 00 00   mov32 cb, $00000000
3305   185A 00 00 
3306   185C B0            cmp a, b
3307   185D FD 7F         sgt ; >
3308   185F E4            pop a
3309   1860             ; --- END RELATIONAL
3310   1860 C0 00 00      cmp b, 0
3311   1863 C6 95 18      je _while44_exit
3312   1866             _while44_block:
3313   1866             ; i--; 
3314   1866 FA F5 FF      lea d, [bp + -11] ; $i
3315   1869 2A            mov b, [d]
3316   186A 38 00 00      mov c, 0
3317   186D 11            mov a, b
3318   186E FD 7D         dec b
3319   1870 FA F5 FF      lea d, [bp + -11] ; $i
3320   1873 FD 43         mov [d], b
3321   1875 27            mov b, a
3322   1876             ; putchar(digits[i]); 
3323   1876             ; --- START FUNCTION CALL
3324   1876 FA F7 FF      lea d, [bp + -9] ; $digits
3325   1879 D7            push a
3326   187A DA            push d
3327   187B FA F5 FF      lea d, [bp + -11] ; $i
3328   187E 2A            mov b, [d]
3329   187F 38 00 00      mov c, 0
3330   1882 E7            pop d
3331   1883 5A            add d, b
3332   1884 E4            pop a
3333   1885 32            mov bl, [d]
3334   1886 A7 00         mov bh, 0
3335   1888 38 00 00      mov c, 0
3336   188B DD            push bl
3337   188C 07 B7 1C      call putchar
3338   188F 51 01 00      add sp, 1
3339   1892             ; --- END FUNCTION CALL
3340   1892 0A 4D 18      jmp _while44_cond
3341   1895             _while44_exit:
3342   1895 F9            leave
3343   1896 09            ret
3344   1897             
3345   1897             sprint_unsigned:
3346   1897 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3347   189A             ; char digits[5]; 
3348   189A 52 05 00      sub sp, 5
3349   189D             ; int i; 
3350   189D 52 02 00      sub sp, 2
3351   18A0             ; int len = 0; 
3352   18A0 52 02 00      sub sp, 2
3353   18A3             ; --- START LOCAL VAR INITIALIZATION
3354   18A3 FA F8 FF      lea d, [bp + -8] ; $len
3355   18A6 DA            push d
3356   18A7 FD 2E 00 00   mov32 cb, $00000000
3356   18AB 00 00 
3357   18AD E7            pop d
3358   18AE FD 43         mov [d], b
3359   18B0             ; --- END LOCAL VAR INITIALIZATION
3360   18B0             ; i = 0; 
3361   18B0 FA FA FF      lea d, [bp + -6] ; $i
3362   18B3 DA            push d
3363   18B4 FD 2E 00 00   mov32 cb, $00000000
3363   18B8 00 00 
3364   18BA E7            pop d
3365   18BB FD 43         mov [d], b
3366   18BD             ; if(num == 0){ 
3367   18BD             _if45_cond:
3368   18BD FA 07 00      lea d, [bp + 7] ; $num
3369   18C0 2A            mov b, [d]
3370   18C1 38 00 00      mov c, 0
3371   18C4             ; --- START RELATIONAL
3372   18C4 D7            push a
3373   18C5 11            mov a, b
3374   18C6 FD 2E 00 00   mov32 cb, $00000000
3374   18CA 00 00 
3375   18CC B0            cmp a, b
3376   18CD FD 71         seq ; ==
3377   18CF E4            pop a
3378   18D0             ; --- END RELATIONAL
3379   18D0 C0 00 00      cmp b, 0
3380   18D3 C6 FB 18      je _if45_exit
3381   18D6             _if45_true:
3382   18D6             ; *dest++ = '0'; 
3383   18D6 FA 05 00      lea d, [bp + 5] ; $dest
3384   18D9 2A            mov b, [d]
3385   18DA 38 00 00      mov c, 0
3386   18DD FD 77         inc b
3387   18DF FA 05 00      lea d, [bp + 5] ; $dest
3388   18E2 FD 3E         mov [d], bl
3389   18E4 FD 7D         dec b
3390   18E6 D8            push b
3391   18E7 FD 2E 30 00   mov32 cb, $00000030
3391   18EB 00 00 
3392   18ED E7            pop d
3393   18EE FD 3E         mov [d], bl
3394   18F0             ; return 1; 
3395   18F0 FD 2E 01 00   mov32 cb, $00000001
3395   18F4 00 00 
3396   18F6 F9            leave
3397   18F7 09            ret
3398   18F8 0A FB 18      jmp _if45_exit
3399   18FB             _if45_exit:
3400   18FB             ; while (num > 0) { 
3401   18FB             _while46_cond:
3402   18FB FA 07 00      lea d, [bp + 7] ; $num
3403   18FE 2A            mov b, [d]
3404   18FF 38 00 00      mov c, 0
3405   1902             ; --- START RELATIONAL
3406   1902 D7            push a
3407   1903 11            mov a, b
3408   1904 FD 2E 00 00   mov32 cb, $00000000
3408   1908 00 00 
3409   190A B0            cmp a, b
3410   190B FD 81         sgu ; > (unsigned)
3411   190D E4            pop a
3412   190E             ; --- END RELATIONAL
3413   190E C0 00 00      cmp b, 0
3414   1911 C6 70 19      je _while46_exit
3415   1914             _while46_block:
3416   1914             ; digits[i] = '0' + (num % 10); 
3417   1914 FA FC FF      lea d, [bp + -4] ; $digits
3418   1917 D7            push a
3419   1918 DA            push d
3420   1919 FA FA FF      lea d, [bp + -6] ; $i
3421   191C 2A            mov b, [d]
3422   191D 38 00 00      mov c, 0
3423   1920 E7            pop d
3424   1921 5A            add d, b
3425   1922 E4            pop a
3426   1923 DA            push d
3427   1924 FD 2E 30 00   mov32 cb, $00000030
3427   1928 00 00 
3428   192A             ; --- START TERMS
3429   192A D7            push a
3430   192B 11            mov a, b
3431   192C FA 07 00      lea d, [bp + 7] ; $num
3432   192F 2A            mov b, [d]
3433   1930 38 00 00      mov c, 0
3434   1933             ; --- START FACTORS
3435   1933 D7            push a
3436   1934 11            mov a, b
3437   1935 FD 2E 0A 00   mov32 cb, $0000000a
3437   1939 00 00 
3438   193B AE            div a, b ; 
3439   193C 11            mov a, b
3440   193D 27            mov b, a
3441   193E E4            pop a
3442   193F             ; --- END FACTORS
3443   193F 56            add b, a
3444   1940 E4            pop a
3445   1941             ; --- END TERMS
3446   1941 E7            pop d
3447   1942 FD 3E         mov [d], bl
3448   1944             ; num = num / 10; 
3449   1944 FA 07 00      lea d, [bp + 7] ; $num
3450   1947 DA            push d
3451   1948 FA 07 00      lea d, [bp + 7] ; $num
3452   194B 2A            mov b, [d]
3453   194C 38 00 00      mov c, 0
3454   194F             ; --- START FACTORS
3455   194F D7            push a
3456   1950 11            mov a, b
3457   1951 FD 2E 0A 00   mov32 cb, $0000000a
3457   1955 00 00 
3458   1957 AE            div a, b
3459   1958 27            mov b, a
3460   1959 E4            pop a
3461   195A             ; --- END FACTORS
3462   195A E7            pop d
3463   195B FD 43         mov [d], b
3464   195D             ; i++; 
3465   195D FA FA FF      lea d, [bp + -6] ; $i
3466   1960 2A            mov b, [d]
3467   1961 38 00 00      mov c, 0
3468   1964 11            mov a, b
3469   1965 FD 77         inc b
3470   1967 FA FA FF      lea d, [bp + -6] ; $i
3471   196A FD 43         mov [d], b
3472   196C 27            mov b, a
3473   196D 0A FB 18      jmp _while46_cond
3474   1970             _while46_exit:
3475   1970             ; while (i > 0) { 
3476   1970             _while47_cond:
3477   1970 FA FA FF      lea d, [bp + -6] ; $i
3478   1973 2A            mov b, [d]
3479   1974 38 00 00      mov c, 0
3480   1977             ; --- START RELATIONAL
3481   1977 D7            push a
3482   1978 11            mov a, b
3483   1979 FD 2E 00 00   mov32 cb, $00000000
3483   197D 00 00 
3484   197F B0            cmp a, b
3485   1980 FD 7F         sgt ; >
3486   1982 E4            pop a
3487   1983             ; --- END RELATIONAL
3488   1983 C0 00 00      cmp b, 0
3489   1986 C6 D5 19      je _while47_exit
3490   1989             _while47_block:
3491   1989             ; i--; 
3492   1989 FA FA FF      lea d, [bp + -6] ; $i
3493   198C 2A            mov b, [d]
3494   198D 38 00 00      mov c, 0
3495   1990 11            mov a, b
3496   1991 FD 7D         dec b
3497   1993 FA FA FF      lea d, [bp + -6] ; $i
3498   1996 FD 43         mov [d], b
3499   1998 27            mov b, a
3500   1999             ; *dest++ = digits[i]; 
3501   1999 FA 05 00      lea d, [bp + 5] ; $dest
3502   199C 2A            mov b, [d]
3503   199D 38 00 00      mov c, 0
3504   19A0 FD 77         inc b
3505   19A2 FA 05 00      lea d, [bp + 5] ; $dest
3506   19A5 FD 3E         mov [d], bl
3507   19A7 FD 7D         dec b
3508   19A9 D8            push b
3509   19AA FA FC FF      lea d, [bp + -4] ; $digits
3510   19AD D7            push a
3511   19AE DA            push d
3512   19AF FA FA FF      lea d, [bp + -6] ; $i
3513   19B2 2A            mov b, [d]
3514   19B3 38 00 00      mov c, 0
3515   19B6 E7            pop d
3516   19B7 5A            add d, b
3517   19B8 E4            pop a
3518   19B9 32            mov bl, [d]
3519   19BA A7 00         mov bh, 0
3520   19BC 38 00 00      mov c, 0
3521   19BF E7            pop d
3522   19C0 FD 3E         mov [d], bl
3523   19C2             ; len++; 
3524   19C2 FA F8 FF      lea d, [bp + -8] ; $len
3525   19C5 2A            mov b, [d]
3526   19C6 38 00 00      mov c, 0
3527   19C9 11            mov a, b
3528   19CA FD 77         inc b
3529   19CC FA F8 FF      lea d, [bp + -8] ; $len
3530   19CF FD 43         mov [d], b
3531   19D1 27            mov b, a
3532   19D2 0A 70 19      jmp _while47_cond
3533   19D5             _while47_exit:
3534   19D5             ; *dest = '\0'; 
3535   19D5 FA 05 00      lea d, [bp + 5] ; $dest
3536   19D8 2A            mov b, [d]
3537   19D9 38 00 00      mov c, 0
3538   19DC D8            push b
3539   19DD FD 2E 00 00   mov32 cb, $00000000
3539   19E1 00 00 
3540   19E3 E7            pop d
3541   19E4 FD 3E         mov [d], bl
3542   19E6             ; return len; 
3543   19E6 FA F8 FF      lea d, [bp + -8] ; $len
3544   19E9 2A            mov b, [d]
3545   19EA 38 00 00      mov c, 0
3546   19ED F9            leave
3547   19EE 09            ret
3548   19EF             
3549   19EF             print_unsigned:
3550   19EF F8 00 00      enter 0 ; (push bp; mov bp, sp)
3551   19F2             ; char digits[5]; 
3552   19F2 52 05 00      sub sp, 5
3553   19F5             ; int i; 
3554   19F5 52 02 00      sub sp, 2
3555   19F8             ; i = 0; 
3556   19F8 FA FA FF      lea d, [bp + -6] ; $i
3557   19FB DA            push d
3558   19FC FD 2E 00 00   mov32 cb, $00000000
3558   1A00 00 00 
3559   1A02 E7            pop d
3560   1A03 FD 43         mov [d], b
3561   1A05             ; if(num == 0){ 
3562   1A05             _if48_cond:
3563   1A05 FA 05 00      lea d, [bp + 5] ; $num
3564   1A08 2A            mov b, [d]
3565   1A09 38 00 00      mov c, 0
3566   1A0C             ; --- START RELATIONAL
3567   1A0C D7            push a
3568   1A0D 11            mov a, b
3569   1A0E FD 2E 00 00   mov32 cb, $00000000
3569   1A12 00 00 
3570   1A14 B0            cmp a, b
3571   1A15 FD 71         seq ; ==
3572   1A17 E4            pop a
3573   1A18             ; --- END RELATIONAL
3574   1A18 C0 00 00      cmp b, 0
3575   1A1B C6 30 1A      je _if48_exit
3576   1A1E             _if48_true:
3577   1A1E             ; putchar('0'); 
3578   1A1E             ; --- START FUNCTION CALL
3579   1A1E FD 2E 30 00   mov32 cb, $00000030
3579   1A22 00 00 
3580   1A24 DD            push bl
3581   1A25 07 B7 1C      call putchar
3582   1A28 51 01 00      add sp, 1
3583   1A2B             ; --- END FUNCTION CALL
3584   1A2B             ; return; 
3585   1A2B F9            leave
3586   1A2C 09            ret
3587   1A2D 0A 30 1A      jmp _if48_exit
3588   1A30             _if48_exit:
3589   1A30             ; while (num > 0) { 
3590   1A30             _while49_cond:
3591   1A30 FA 05 00      lea d, [bp + 5] ; $num
3592   1A33 2A            mov b, [d]
3593   1A34 38 00 00      mov c, 0
3594   1A37             ; --- START RELATIONAL
3595   1A37 D7            push a
3596   1A38 11            mov a, b
3597   1A39 FD 2E 00 00   mov32 cb, $00000000
3597   1A3D 00 00 
3598   1A3F B0            cmp a, b
3599   1A40 FD 81         sgu ; > (unsigned)
3600   1A42 E4            pop a
3601   1A43             ; --- END RELATIONAL
3602   1A43 C0 00 00      cmp b, 0
3603   1A46 C6 A5 1A      je _while49_exit
3604   1A49             _while49_block:
3605   1A49             ; digits[i] = '0' + (num % 10); 
3606   1A49 FA FC FF      lea d, [bp + -4] ; $digits
3607   1A4C D7            push a
3608   1A4D DA            push d
3609   1A4E FA FA FF      lea d, [bp + -6] ; $i
3610   1A51 2A            mov b, [d]
3611   1A52 38 00 00      mov c, 0
3612   1A55 E7            pop d
3613   1A56 5A            add d, b
3614   1A57 E4            pop a
3615   1A58 DA            push d
3616   1A59 FD 2E 30 00   mov32 cb, $00000030
3616   1A5D 00 00 
3617   1A5F             ; --- START TERMS
3618   1A5F D7            push a
3619   1A60 11            mov a, b
3620   1A61 FA 05 00      lea d, [bp + 5] ; $num
3621   1A64 2A            mov b, [d]
3622   1A65 38 00 00      mov c, 0
3623   1A68             ; --- START FACTORS
3624   1A68 D7            push a
3625   1A69 11            mov a, b
3626   1A6A FD 2E 0A 00   mov32 cb, $0000000a
3626   1A6E 00 00 
3627   1A70 AE            div a, b ; 
3628   1A71 11            mov a, b
3629   1A72 27            mov b, a
3630   1A73 E4            pop a
3631   1A74             ; --- END FACTORS
3632   1A74 56            add b, a
3633   1A75 E4            pop a
3634   1A76             ; --- END TERMS
3635   1A76 E7            pop d
3636   1A77 FD 3E         mov [d], bl
3637   1A79             ; num = num / 10; 
3638   1A79 FA 05 00      lea d, [bp + 5] ; $num
3639   1A7C DA            push d
3640   1A7D FA 05 00      lea d, [bp + 5] ; $num
3641   1A80 2A            mov b, [d]
3642   1A81 38 00 00      mov c, 0
3643   1A84             ; --- START FACTORS
3644   1A84 D7            push a
3645   1A85 11            mov a, b
3646   1A86 FD 2E 0A 00   mov32 cb, $0000000a
3646   1A8A 00 00 
3647   1A8C AE            div a, b
3648   1A8D 27            mov b, a
3649   1A8E E4            pop a
3650   1A8F             ; --- END FACTORS
3651   1A8F E7            pop d
3652   1A90 FD 43         mov [d], b
3653   1A92             ; i++; 
3654   1A92 FA FA FF      lea d, [bp + -6] ; $i
3655   1A95 2A            mov b, [d]
3656   1A96 38 00 00      mov c, 0
3657   1A99 11            mov a, b
3658   1A9A FD 77         inc b
3659   1A9C FA FA FF      lea d, [bp + -6] ; $i
3660   1A9F FD 43         mov [d], b
3661   1AA1 27            mov b, a
3662   1AA2 0A 30 1A      jmp _while49_cond
3663   1AA5             _while49_exit:
3664   1AA5             ; while (i > 0) { 
3665   1AA5             _while50_cond:
3666   1AA5 FA FA FF      lea d, [bp + -6] ; $i
3667   1AA8 2A            mov b, [d]
3668   1AA9 38 00 00      mov c, 0
3669   1AAC             ; --- START RELATIONAL
3670   1AAC D7            push a
3671   1AAD 11            mov a, b
3672   1AAE FD 2E 00 00   mov32 cb, $00000000
3672   1AB2 00 00 
3673   1AB4 B0            cmp a, b
3674   1AB5 FD 7F         sgt ; >
3675   1AB7 E4            pop a
3676   1AB8             ; --- END RELATIONAL
3677   1AB8 C0 00 00      cmp b, 0
3678   1ABB C6 ED 1A      je _while50_exit
3679   1ABE             _while50_block:
3680   1ABE             ; i--; 
3681   1ABE FA FA FF      lea d, [bp + -6] ; $i
3682   1AC1 2A            mov b, [d]
3683   1AC2 38 00 00      mov c, 0
3684   1AC5 11            mov a, b
3685   1AC6 FD 7D         dec b
3686   1AC8 FA FA FF      lea d, [bp + -6] ; $i
3687   1ACB FD 43         mov [d], b
3688   1ACD 27            mov b, a
3689   1ACE             ; putchar(digits[i]); 
3690   1ACE             ; --- START FUNCTION CALL
3691   1ACE FA FC FF      lea d, [bp + -4] ; $digits
3692   1AD1 D7            push a
3693   1AD2 DA            push d
3694   1AD3 FA FA FF      lea d, [bp + -6] ; $i
3695   1AD6 2A            mov b, [d]
3696   1AD7 38 00 00      mov c, 0
3697   1ADA E7            pop d
3698   1ADB 5A            add d, b
3699   1ADC E4            pop a
3700   1ADD 32            mov bl, [d]
3701   1ADE A7 00         mov bh, 0
3702   1AE0 38 00 00      mov c, 0
3703   1AE3 DD            push bl
3704   1AE4 07 B7 1C      call putchar
3705   1AE7 51 01 00      add sp, 1
3706   1AEA             ; --- END FUNCTION CALL
3707   1AEA 0A A5 1A      jmp _while50_cond
3708   1AED             _while50_exit:
3709   1AED F9            leave
3710   1AEE 09            ret
3711   1AEF             
3712   1AEF             sprint_signed:
3713   1AEF F8 00 00      enter 0 ; (push bp; mov bp, sp)
3714   1AF2             ; char digits[5]; 
3715   1AF2 52 05 00      sub sp, 5
3716   1AF5             ; int i = 0; 
3717   1AF5 52 02 00      sub sp, 2
3718   1AF8             ; --- START LOCAL VAR INITIALIZATION
3719   1AF8 FA FA FF      lea d, [bp + -6] ; $i
3720   1AFB DA            push d
3721   1AFC FD 2E 00 00   mov32 cb, $00000000
3721   1B00 00 00 
3722   1B02 E7            pop d
3723   1B03 FD 43         mov [d], b
3724   1B05             ; --- END LOCAL VAR INITIALIZATION
3725   1B05             ; int len = 0; 
3726   1B05 52 02 00      sub sp, 2
3727   1B08             ; --- START LOCAL VAR INITIALIZATION
3728   1B08 FA F8 FF      lea d, [bp + -8] ; $len
3729   1B0B DA            push d
3730   1B0C FD 2E 00 00   mov32 cb, $00000000
3730   1B10 00 00 
3731   1B12 E7            pop d
3732   1B13 FD 43         mov [d], b
3733   1B15             ; --- END LOCAL VAR INITIALIZATION
3734   1B15             ; if (num < 0) { 
3735   1B15             _if51_cond:
3736   1B15 FA 07 00      lea d, [bp + 7] ; $num
3737   1B18 2A            mov b, [d]
3738   1B19 38 00 00      mov c, 0
3739   1B1C             ; --- START RELATIONAL
3740   1B1C D7            push a
3741   1B1D 11            mov a, b
3742   1B1E FD 2E 00 00   mov32 cb, $00000000
3742   1B22 00 00 
3743   1B24 B0            cmp a, b
3744   1B25 FD 73         slt ; < (signed)
3745   1B27 E4            pop a
3746   1B28             ; --- END RELATIONAL
3747   1B28 C0 00 00      cmp b, 0
3748   1B2B C6 6B 1B      je _if51_else
3749   1B2E             _if51_true:
3750   1B2E             ; *dest++ = '-'; 
3751   1B2E FA 05 00      lea d, [bp + 5] ; $dest
3752   1B31 2A            mov b, [d]
3753   1B32 38 00 00      mov c, 0
3754   1B35 FD 77         inc b
3755   1B37 FA 05 00      lea d, [bp + 5] ; $dest
3756   1B3A FD 3E         mov [d], bl
3757   1B3C FD 7D         dec b
3758   1B3E D8            push b
3759   1B3F FD 2E 2D 00   mov32 cb, $0000002d
3759   1B43 00 00 
3760   1B45 E7            pop d
3761   1B46 FD 3E         mov [d], bl
3762   1B48             ; num = -num; 
3763   1B48 FA 07 00      lea d, [bp + 7] ; $num
3764   1B4B DA            push d
3765   1B4C FA 07 00      lea d, [bp + 7] ; $num
3766   1B4F 2A            mov b, [d]
3767   1B50 38 00 00      mov c, 0
3768   1B53 FD 97         neg b
3769   1B55 E7            pop d
3770   1B56 FD 43         mov [d], b
3771   1B58             ; len++; 
3772   1B58 FA F8 FF      lea d, [bp + -8] ; $len
3773   1B5B 2A            mov b, [d]
3774   1B5C 38 00 00      mov c, 0
3775   1B5F 11            mov a, b
3776   1B60 FD 77         inc b
3777   1B62 FA F8 FF      lea d, [bp + -8] ; $len
3778   1B65 FD 43         mov [d], b
3779   1B67 27            mov b, a
3780   1B68 0A BA 1B      jmp _if51_exit
3781   1B6B             _if51_else:
3782   1B6B             ; if (num == 0) { 
3783   1B6B             _if52_cond:
3784   1B6B FA 07 00      lea d, [bp + 7] ; $num
3785   1B6E 2A            mov b, [d]
3786   1B6F 38 00 00      mov c, 0
3787   1B72             ; --- START RELATIONAL
3788   1B72 D7            push a
3789   1B73 11            mov a, b
3790   1B74 FD 2E 00 00   mov32 cb, $00000000
3790   1B78 00 00 
3791   1B7A B0            cmp a, b
3792   1B7B FD 71         seq ; ==
3793   1B7D E4            pop a
3794   1B7E             ; --- END RELATIONAL
3795   1B7E C0 00 00      cmp b, 0
3796   1B81 C6 BA 1B      je _if52_exit
3797   1B84             _if52_true:
3798   1B84             ; *dest++ = '0'; 
3799   1B84 FA 05 00      lea d, [bp + 5] ; $dest
3800   1B87 2A            mov b, [d]
3801   1B88 38 00 00      mov c, 0
3802   1B8B FD 77         inc b
3803   1B8D FA 05 00      lea d, [bp + 5] ; $dest
3804   1B90 FD 3E         mov [d], bl
3805   1B92 FD 7D         dec b
3806   1B94 D8            push b
3807   1B95 FD 2E 30 00   mov32 cb, $00000030
3807   1B99 00 00 
3808   1B9B E7            pop d
3809   1B9C FD 3E         mov [d], bl
3810   1B9E             ; *dest = '\0'; 
3811   1B9E FA 05 00      lea d, [bp + 5] ; $dest
3812   1BA1 2A            mov b, [d]
3813   1BA2 38 00 00      mov c, 0
3814   1BA5 D8            push b
3815   1BA6 FD 2E 00 00   mov32 cb, $00000000
3815   1BAA 00 00 
3816   1BAC E7            pop d
3817   1BAD FD 3E         mov [d], bl
3818   1BAF             ; return 1; 
3819   1BAF FD 2E 01 00   mov32 cb, $00000001
3819   1BB3 00 00 
3820   1BB5 F9            leave
3821   1BB6 09            ret
3822   1BB7 0A BA 1B      jmp _if52_exit
3823   1BBA             _if52_exit:
3824   1BBA             _if51_exit:
3825   1BBA             ; while (num > 0) { 
3826   1BBA             _while53_cond:
3827   1BBA FA 07 00      lea d, [bp + 7] ; $num
3828   1BBD 2A            mov b, [d]
3829   1BBE 38 00 00      mov c, 0
3830   1BC1             ; --- START RELATIONAL
3831   1BC1 D7            push a
3832   1BC2 11            mov a, b
3833   1BC3 FD 2E 00 00   mov32 cb, $00000000
3833   1BC7 00 00 
3834   1BC9 B0            cmp a, b
3835   1BCA FD 7F         sgt ; >
3836   1BCC E4            pop a
3837   1BCD             ; --- END RELATIONAL
3838   1BCD C0 00 00      cmp b, 0
3839   1BD0 C6 2F 1C      je _while53_exit
3840   1BD3             _while53_block:
3841   1BD3             ; digits[i] = '0' + (num % 10); 
3842   1BD3 FA FC FF      lea d, [bp + -4] ; $digits
3843   1BD6 D7            push a
3844   1BD7 DA            push d
3845   1BD8 FA FA FF      lea d, [bp + -6] ; $i
3846   1BDB 2A            mov b, [d]
3847   1BDC 38 00 00      mov c, 0
3848   1BDF E7            pop d
3849   1BE0 5A            add d, b
3850   1BE1 E4            pop a
3851   1BE2 DA            push d
3852   1BE3 FD 2E 30 00   mov32 cb, $00000030
3852   1BE7 00 00 
3853   1BE9             ; --- START TERMS
3854   1BE9 D7            push a
3855   1BEA 11            mov a, b
3856   1BEB FA 07 00      lea d, [bp + 7] ; $num
3857   1BEE 2A            mov b, [d]
3858   1BEF 38 00 00      mov c, 0
3859   1BF2             ; --- START FACTORS
3860   1BF2 D7            push a
3861   1BF3 11            mov a, b
3862   1BF4 FD 2E 0A 00   mov32 cb, $0000000a
3862   1BF8 00 00 
3863   1BFA AE            div a, b ; 
3864   1BFB 11            mov a, b
3865   1BFC 27            mov b, a
3866   1BFD E4            pop a
3867   1BFE             ; --- END FACTORS
3868   1BFE 56            add b, a
3869   1BFF E4            pop a
3870   1C00             ; --- END TERMS
3871   1C00 E7            pop d
3872   1C01 FD 3E         mov [d], bl
3873   1C03             ; num = num / 10; 
3874   1C03 FA 07 00      lea d, [bp + 7] ; $num
3875   1C06 DA            push d
3876   1C07 FA 07 00      lea d, [bp + 7] ; $num
3877   1C0A 2A            mov b, [d]
3878   1C0B 38 00 00      mov c, 0
3879   1C0E             ; --- START FACTORS
3880   1C0E D7            push a
3881   1C0F 11            mov a, b
3882   1C10 FD 2E 0A 00   mov32 cb, $0000000a
3882   1C14 00 00 
3883   1C16 AE            div a, b
3884   1C17 27            mov b, a
3885   1C18 E4            pop a
3886   1C19             ; --- END FACTORS
3887   1C19 E7            pop d
3888   1C1A FD 43         mov [d], b
3889   1C1C             ; i++; 
3890   1C1C FA FA FF      lea d, [bp + -6] ; $i
3891   1C1F 2A            mov b, [d]
3892   1C20 38 00 00      mov c, 0
3893   1C23 11            mov a, b
3894   1C24 FD 77         inc b
3895   1C26 FA FA FF      lea d, [bp + -6] ; $i
3896   1C29 FD 43         mov [d], b
3897   1C2B 27            mov b, a
3898   1C2C 0A BA 1B      jmp _while53_cond
3899   1C2F             _while53_exit:
3900   1C2F             ; while (i > 0) { 
3901   1C2F             _while54_cond:
3902   1C2F FA FA FF      lea d, [bp + -6] ; $i
3903   1C32 2A            mov b, [d]
3904   1C33 38 00 00      mov c, 0
3905   1C36             ; --- START RELATIONAL
3906   1C36 D7            push a
3907   1C37 11            mov a, b
3908   1C38 FD 2E 00 00   mov32 cb, $00000000
3908   1C3C 00 00 
3909   1C3E B0            cmp a, b
3910   1C3F FD 7F         sgt ; >
3911   1C41 E4            pop a
3912   1C42             ; --- END RELATIONAL
3913   1C42 C0 00 00      cmp b, 0
3914   1C45 C6 94 1C      je _while54_exit
3915   1C48             _while54_block:
3916   1C48             ; i--; 
3917   1C48 FA FA FF      lea d, [bp + -6] ; $i
3918   1C4B 2A            mov b, [d]
3919   1C4C 38 00 00      mov c, 0
3920   1C4F 11            mov a, b
3921   1C50 FD 7D         dec b
3922   1C52 FA FA FF      lea d, [bp + -6] ; $i
3923   1C55 FD 43         mov [d], b
3924   1C57 27            mov b, a
3925   1C58             ; *dest++ = digits[i]; 
3926   1C58 FA 05 00      lea d, [bp + 5] ; $dest
3927   1C5B 2A            mov b, [d]
3928   1C5C 38 00 00      mov c, 0
3929   1C5F FD 77         inc b
3930   1C61 FA 05 00      lea d, [bp + 5] ; $dest
3931   1C64 FD 3E         mov [d], bl
3932   1C66 FD 7D         dec b
3933   1C68 D8            push b
3934   1C69 FA FC FF      lea d, [bp + -4] ; $digits
3935   1C6C D7            push a
3936   1C6D DA            push d
3937   1C6E FA FA FF      lea d, [bp + -6] ; $i
3938   1C71 2A            mov b, [d]
3939   1C72 38 00 00      mov c, 0
3940   1C75 E7            pop d
3941   1C76 5A            add d, b
3942   1C77 E4            pop a
3943   1C78 32            mov bl, [d]
3944   1C79 A7 00         mov bh, 0
3945   1C7B 38 00 00      mov c, 0
3946   1C7E E7            pop d
3947   1C7F FD 3E         mov [d], bl
3948   1C81             ; len++; 
3949   1C81 FA F8 FF      lea d, [bp + -8] ; $len
3950   1C84 2A            mov b, [d]
3951   1C85 38 00 00      mov c, 0
3952   1C88 11            mov a, b
3953   1C89 FD 77         inc b
3954   1C8B FA F8 FF      lea d, [bp + -8] ; $len
3955   1C8E FD 43         mov [d], b
3956   1C90 27            mov b, a
3957   1C91 0A 2F 1C      jmp _while54_cond
3958   1C94             _while54_exit:
3959   1C94             ; *dest = '\0'; 
3960   1C94 FA 05 00      lea d, [bp + 5] ; $dest
3961   1C97 2A            mov b, [d]
3962   1C98 38 00 00      mov c, 0
3963   1C9B D8            push b
3964   1C9C FD 2E 00 00   mov32 cb, $00000000
3964   1CA0 00 00 
3965   1CA2 E7            pop d
3966   1CA3 FD 3E         mov [d], bl
3967   1CA5             ; return len; 
3968   1CA5 FA F8 FF      lea d, [bp + -8] ; $len
3969   1CA8 2A            mov b, [d]
3970   1CA9 38 00 00      mov c, 0
3971   1CAC F9            leave
3972   1CAD 09            ret
3973   1CAE             
3974   1CAE             date:
3975   1CAE F8 00 00      enter 0 ; (push bp; mov bp, sp)
3976   1CB1             
3977   1CB1             ; --- BEGIN INLINE ASM SEGMENT
3978   1CB1 19 00         mov al, 0 
3979   1CB3 05 07         syscall sys_datetime
3980   1CB5             ; --- END INLINE ASM SEGMENT
3981   1CB5             
3982   1CB5 F9            leave
3983   1CB6 09            ret
3984   1CB7             
3985   1CB7             putchar:
3986   1CB7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3987   1CBA             
3988   1CBA             ; --- BEGIN INLINE ASM SEGMENT
3989   1CBA FA 05 00      lea d, [bp + 5] ; $c
3990   1CBD 1E            mov al, [d]
3991   1CBE 23            mov ah, al
3992   1CBF 07 C6 1E      call _putchar
3993   1CC2             ; --- END INLINE ASM SEGMENT
3994   1CC2             
3995   1CC2 F9            leave
3996   1CC3 09            ret
3997   1CC4             
3998   1CC4             getchar:
3999   1CC4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4000   1CC7             ; char c; 
4001   1CC7 52 01 00      sub sp, 1
4002   1CCA             
4003   1CCA             ; --- BEGIN INLINE ASM SEGMENT
4004   1CCA 07 BF 1E      call getch
4005   1CCD 1A            mov al, ah
4006   1CCE FA 00 00      lea d, [bp + 0] ; $c
4007   1CD1 3E            mov [d], al
4008   1CD2             ; --- END INLINE ASM SEGMENT
4009   1CD2             
4010   1CD2             ; return c; 
4011   1CD2 FA 00 00      lea d, [bp + 0] ; $c
4012   1CD5 32            mov bl, [d]
4013   1CD6 A7 00         mov bh, 0
4014   1CD8 38 00 00      mov c, 0
4015   1CDB F9            leave
4016   1CDC 09            ret
4017   1CDD             
4018   1CDD             scann:
4019   1CDD F8 00 00      enter 0 ; (push bp; mov bp, sp)
4020   1CE0             ; int m; 
4021   1CE0 52 02 00      sub sp, 2
4022   1CE3             
4023   1CE3             ; --- BEGIN INLINE ASM SEGMENT
4024   1CE3 07 0A 21      call scan_u16d
4025   1CE6 FA FF FF      lea d, [bp + -1] ; $m
4026   1CE9 43            mov [d], a
4027   1CEA             ; --- END INLINE ASM SEGMENT
4028   1CEA             
4029   1CEA             ; return m; 
4030   1CEA FA FF FF      lea d, [bp + -1] ; $m
4031   1CED 2A            mov b, [d]
4032   1CEE 38 00 00      mov c, 0
4033   1CF1 F9            leave
4034   1CF2 09            ret
4035   1CF3             
4036   1CF3             puts:
4037   1CF3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4038   1CF6             
4039   1CF6             ; --- BEGIN INLINE ASM SEGMENT
4040   1CF6 FA 05 00      lea d, [bp + 5] ; $s
4041   1CF9 15            mov a, [d]
4042   1CFA 3C            mov d, a
4043   1CFB 07 10 20      call _puts
4044   1CFE 10 00 0A      mov a, $0A00
4045   1D01 05 03         syscall sys_io
4046   1D03             ; --- END INLINE ASM SEGMENT
4047   1D03             
4048   1D03 F9            leave
4049   1D04 09            ret
4050   1D05             
4051   1D05             print:
4052   1D05 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4053   1D08             
4054   1D08             ; --- BEGIN INLINE ASM SEGMENT
4055   1D08 FA 05 00      lea d, [bp + 5] ; $s
4056   1D0B FD 2A         mov d, [d]
4057   1D0D 07 10 20      call _puts
4058   1D10             ; --- END INLINE ASM SEGMENT
4059   1D10             
4060   1D10 F9            leave
4061   1D11 09            ret
4062   1D12             
4063   1D12             getparam:
4064   1D12 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4065   1D15             ; char data; 
4066   1D15 52 01 00      sub sp, 1
4067   1D18             
4068   1D18             ; --- BEGIN INLINE ASM SEGMENT
4069   1D18 19 04         mov al, 4
4070   1D1A FA 05 00      lea d, [bp + 5] ; $address
4071   1D1D FD 2A         mov d, [d]
4072   1D1F 05 0C         syscall sys_system
4073   1D21 FA 00 00      lea d, [bp + 0] ; $data
4074   1D24 FD 3E         mov [d], bl
4075   1D26             ; --- END INLINE ASM SEGMENT
4076   1D26             
4077   1D26             ; return data; 
4078   1D26 FA 00 00      lea d, [bp + 0] ; $data
4079   1D29 32            mov bl, [d]
4080   1D2A A7 00         mov bh, 0
4081   1D2C 38 00 00      mov c, 0
4082   1D2F F9            leave
4083   1D30 09            ret
4084   1D31             
4085   1D31             clear:
4086   1D31 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4087   1D34             ; print("\033[2J\033[H"); 
4088   1D34             ; --- START FUNCTION CALL
4089   1D34 26 AA 21      mov b, _s2 ; "\033[2J\033[H"
4090   1D37 FD AB         swp b
4091   1D39 D8            push b
4092   1D3A 07 05 1D      call print
4093   1D3D 51 02 00      add sp, 2
4094   1D40             ; --- END FUNCTION CALL
4095   1D40 F9            leave
4096   1D41 09            ret
4097   1D42             
4098   1D42             abs:
4099   1D42 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4100   1D45             ; return i < 0 ? -i : i; 
4101   1D45             _ternary55_cond:
4102   1D45 FA 05 00      lea d, [bp + 5] ; $i
4103   1D48 2A            mov b, [d]
4104   1D49 38 00 00      mov c, 0
4105   1D4C             ; --- START RELATIONAL
4106   1D4C D7            push a
4107   1D4D 11            mov a, b
4108   1D4E FD 2E 00 00   mov32 cb, $00000000
4108   1D52 00 00 
4109   1D54 B0            cmp a, b
4110   1D55 FD 73         slt ; < (signed)
4111   1D57 E4            pop a
4112   1D58             ; --- END RELATIONAL
4113   1D58 C0 00 00      cmp b, 0
4114   1D5B C6 6A 1D      je _ternary55_false
4115   1D5E             _ternary55_true:
4116   1D5E FA 05 00      lea d, [bp + 5] ; $i
4117   1D61 2A            mov b, [d]
4118   1D62 38 00 00      mov c, 0
4119   1D65 FD 97         neg b
4120   1D67 0A 71 1D      jmp _ternary55_exit
4121   1D6A             _ternary55_false:
4122   1D6A FA 05 00      lea d, [bp + 5] ; $i
4123   1D6D 2A            mov b, [d]
4124   1D6E 38 00 00      mov c, 0
4125   1D71             _ternary55_exit:
4126   1D71 F9            leave
4127   1D72 09            ret
4128   1D73             
4129   1D73             loadfile:
4130   1D73 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4131   1D76             
4132   1D76             ; --- BEGIN INLINE ASM SEGMENT
4133   1D76 FA 07 00      lea d, [bp + 7] ; $destination
4134   1D79 15            mov a, [d]
4135   1D7A 4F            mov di, a
4136   1D7B FA 05 00      lea d, [bp + 5] ; $filename
4137   1D7E FD 2A         mov d, [d]
4138   1D80 19 14         mov al, 20
4139   1D82 05 04         syscall sys_filesystem
4140   1D84             ; --- END INLINE ASM SEGMENT
4141   1D84             
4142   1D84 F9            leave
4143   1D85 09            ret
4144   1D86             
4145   1D86             create_file:
4146   1D86 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4147   1D89 F9            leave
4148   1D8A 09            ret
4149   1D8B             
4150   1D8B             delete_file:
4151   1D8B F8 00 00      enter 0 ; (push bp; mov bp, sp)
4152   1D8E             
4153   1D8E             ; --- BEGIN INLINE ASM SEGMENT
4154   1D8E FA 05 00      lea d, [bp + 5] ; $filename
4155   1D91 19 0A         mov al, 10
4156   1D93 05 04         syscall sys_filesystem
4157   1D95             ; --- END INLINE ASM SEGMENT
4158   1D95             
4159   1D95 F9            leave
4160   1D96 09            ret
4161   1D97             
4162   1D97             load_hex:
4163   1D97 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4164   1D9A             ; char *temp; 
4165   1D9A 52 02 00      sub sp, 2
4166   1D9D             ; temp = alloc(32768); 
4167   1D9D FA FF FF      lea d, [bp + -1] ; $temp
4168   1DA0 DA            push d
4169   1DA1             ; --- START FUNCTION CALL
4170   1DA1 FD 2E 00 80   mov32 cb, $00008000
4170   1DA5 00 00 
4171   1DA7 FD AB         swp b
4172   1DA9 D8            push b
4173   1DAA 07 76 08      call alloc
4174   1DAD 51 02 00      add sp, 2
4175   1DB0             ; --- END FUNCTION CALL
4176   1DB0 E7            pop d
4177   1DB1 FD 43         mov [d], b
4178   1DB3             
4179   1DB3             ; --- BEGIN INLINE ASM SEGMENT
4180   1DB3               
4181   1DB3               
4182   1DB3               
4183   1DB3             _load_hex:
4184   1DB3 FA 05 00      lea d, [bp + 5] ; $destination
4185   1DB6 FD 2A         mov d, [d]
4186   1DB8 FD 50         mov di, d
4187   1DBA FA FF FF      lea d, [bp + -1] ; $temp
4188   1DBD FD 2A         mov d, [d]
4189   1DBF 38 00 00      mov c, 0
4190   1DC2 48            mov a, sp
4191   1DC3 77            inc a
4192   1DC4 3C            mov d, a          
4193   1DC5 07 CD 1E      call _gets        
4194   1DC8 4D            mov si, a
4195   1DC9             __load_hex_loop:
4196   1DC9 F6            lodsb             
4197   1DCA B9 00         cmp al, 0         
4198   1DCC C6 DA 1D      jz __load_hex_ret
4199   1DCF 36            mov bh, al
4200   1DD0 F6            lodsb
4201   1DD1 2F            mov bl, al
4202   1DD2 07 84 1E      call _atoi        
4203   1DD5 F7            stosb             
4204   1DD6 78            inc c
4205   1DD7 0A C9 1D      jmp __load_hex_loop
4206   1DDA             __load_hex_ret:
4207   1DDA             ; --- END INLINE ASM SEGMENT
4208   1DDA             
4209   1DDA F9            leave
4210   1DDB 09            ret
4211   1DDC             
4212   1DDC             include_stdio_asm:
4213   1DDC F8 00 00      enter 0 ; (push bp; mov bp, sp)
4214   1DDF             
4215   1DDF             ; --- BEGIN INLINE ASM SEGMENT
4216   1DDF             .include "lib/asm/stdio.asm"
0001+  1DDF             ;-----------------------------------------------------------------------------
0002+  1DDF             ; stdio.s
0003+  1DDF             ;-----------------------------------------------------------------------------
0004+  1DDF             .include "lib/asm/string.asm"
0001++ 1DDF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1DDF             ; string.s
0003++ 1DDF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1DDF             
0005++ 1DDF             
0006++ 1DDF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1DDF             ; _strrev
0008++ 1DDF             ; reverse a string
0009++ 1DDF             ; D = string address
0010++ 1DDF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1DDF             ; 01234
0012++ 1DDF             _strrev:
0013++ 1DDF 4B          	pusha
0014++ 1DE0 07 26 1E    	call _strlen	; length in C
0015++ 1DE3 12          	mov a, c
0016++ 1DE4 AF 01 00    	cmp a, 1
0017++ 1DE7 D0 01 1E    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1DEA 7D          	dec a
0019++ 1DEB FD 4E       	mov si, d	; beginning of string
0020++ 1DED FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1DEF 59          	add d, a	; end of string
0022++ 1DF0 12          	mov a, c
0023++ 1DF1 FD 9B       	shr a		; divide by 2
0024++ 1DF3 39          	mov c, a	; C now counts the steps
0025++ 1DF4             _strrev_L0:
0026++ 1DF4 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1DF5 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1DF6 3E          	mov [d], al	; store left char into right side
0029++ 1DF7 1B          	mov al, bl
0030++ 1DF8 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1DF9 7E          	dec c
0032++ 1DFA 7F          	dec d
0033++ 1DFB C2 00 00    	cmp c, 0
0034++ 1DFE C7 F4 1D    	jne _strrev_L0
0035++ 1E01             _strrev_end:
0036++ 1E01 4C          	popa
0037++ 1E02 09          	ret
0038++ 1E03             	
0039++ 1E03             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1E03             ; _strchr
0041++ 1E03             ; search string in D for char in AL
0042++ 1E03             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1E03             _strchr:
0044++ 1E03             _strchr_L0:
0045++ 1E03 32          	mov bl, [d]
0046++ 1E04 C1 00       	cmp bl, 0
0047++ 1E06 C6 11 1E    	je _strchr_end
0048++ 1E09 BA          	cmp al, bl
0049++ 1E0A C6 11 1E    	je _strchr_end
0050++ 1E0D 79          	inc d
0051++ 1E0E 0A 03 1E    	jmp _strchr_L0
0052++ 1E11             _strchr_end:
0053++ 1E11 1B          	mov al, bl
0054++ 1E12 09          	ret
0055++ 1E13             
0056++ 1E13             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1E13             ; _strstr
0058++ 1E13             ; find sub-string
0059++ 1E13             ; str1 in SI
0060++ 1E13             ; str2 in DI
0061++ 1E13             ; SI points to end of source string
0062++ 1E13             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1E13             _strstr:
0064++ 1E13 DB          	push al
0065++ 1E14 DA          	push d
0066++ 1E15 E3          	push di
0067++ 1E16             _strstr_loop:
0068++ 1E16 F3          	cmpsb					; compare a byte of the strings
0069++ 1E17 C7 22 1E    	jne _strstr_ret
0070++ 1E1A FC 00 00    	lea d, [di + 0]
0071++ 1E1D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1E1F C7 16 1E    	jne _strstr_loop				; equal chars but not at end
0073++ 1E22             _strstr_ret:
0074++ 1E22 F0          	pop di
0075++ 1E23 E7          	pop d
0076++ 1E24 E8          	pop al
0077++ 1E25 09          	ret
0078++ 1E26             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1E26             ; length of null terminated string
0080++ 1E26             ; result in C
0081++ 1E26             ; pointer in D
0082++ 1E26             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1E26             _strlen:
0084++ 1E26 DA          	push d
0085++ 1E27 38 00 00    	mov c, 0
0086++ 1E2A             _strlen_L1:
0087++ 1E2A BD 00       	cmp byte [d], 0
0088++ 1E2C C6 34 1E    	je _strlen_ret
0089++ 1E2F 79          	inc d
0090++ 1E30 78          	inc c
0091++ 1E31 0A 2A 1E    	jmp _strlen_L1
0092++ 1E34             _strlen_ret:
0093++ 1E34 E7          	pop d
0094++ 1E35 09          	ret
0095++ 1E36             
0096++ 1E36             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1E36             ; STRCMP
0098++ 1E36             ; compare two strings
0099++ 1E36             ; str1 in SI
0100++ 1E36             ; str2 in DI
0101++ 1E36             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1E36             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1E36             _strcmp:
0104++ 1E36 DB          	push al
0105++ 1E37 DA          	push d
0106++ 1E38 E3          	push di
0107++ 1E39 E2          	push si
0108++ 1E3A             _strcmp_loop:
0109++ 1E3A F3          	cmpsb					; compare a byte of the strings
0110++ 1E3B C7 46 1E    	jne _strcmp_ret
0111++ 1E3E FB FF FF    	lea d, [si +- 1]
0112++ 1E41 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1E43 C7 3A 1E    	jne _strcmp_loop				; equal chars but not at end
0114++ 1E46             _strcmp_ret:
0115++ 1E46 EF          	pop si
0116++ 1E47 F0          	pop di
0117++ 1E48 E7          	pop d
0118++ 1E49 E8          	pop al
0119++ 1E4A 09          	ret
0120++ 1E4B             
0121++ 1E4B             
0122++ 1E4B             ; STRCPY
0123++ 1E4B             ; copy null terminated string from SI to DI
0124++ 1E4B             ; source in SI
0125++ 1E4B             ; destination in DI
0126++ 1E4B             _strcpy:
0127++ 1E4B E2          	push si
0128++ 1E4C E3          	push di
0129++ 1E4D DB          	push al
0130++ 1E4E             _strcpy_L1:
0131++ 1E4E F6          	lodsb
0132++ 1E4F F7          	stosb
0133++ 1E50 B9 00       	cmp al, 0
0134++ 1E52 C7 4E 1E    	jne _strcpy_L1
0135++ 1E55             _strcpy_end:
0136++ 1E55 E8          	pop al
0137++ 1E56 F0          	pop di
0138++ 1E57 EF          	pop si
0139++ 1E58 09          	ret
0140++ 1E59             
0141++ 1E59             ; STRCAT
0142++ 1E59             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1E59             ; source in SI
0144++ 1E59             ; destination in DI
0145++ 1E59             _strcat:
0146++ 1E59 E2          	push si
0147++ 1E5A E3          	push di
0148++ 1E5B D7          	push a
0149++ 1E5C DA          	push d
0150++ 1E5D 50          	mov a, di
0151++ 1E5E 3C          	mov d, a
0152++ 1E5F             _strcat_goto_end_L1:
0153++ 1E5F BD 00       	cmp byte[d], 0
0154++ 1E61 C6 68 1E    	je _strcat_start
0155++ 1E64 79          	inc d
0156++ 1E65 0A 5F 1E    	jmp _strcat_goto_end_L1
0157++ 1E68             _strcat_start:
0158++ 1E68 FD 50       	mov di, d
0159++ 1E6A             _strcat_L1:
0160++ 1E6A F6          	lodsb
0161++ 1E6B F7          	stosb
0162++ 1E6C B9 00       	cmp al, 0
0163++ 1E6E C7 6A 1E    	jne _strcat_L1
0164++ 1E71             _strcat_end:
0165++ 1E71 E7          	pop d
0166++ 1E72 E4          	pop a
0167++ 1E73 F0          	pop di
0168++ 1E74 EF          	pop si
0169++ 1E75 09          	ret
0170++ 1E76             
0171++ 1E76             
0005+  1E76             
0006+  1E76             ;-----------------------------------------------------------------------------
0007+  1E76             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1E76             ; ASCII in BL
0009+  1E76             ; result in AL
0010+  1E76             ; ascii for F = 0100 0110
0011+  1E76             ; ascii for 9 = 0011 1001
0012+  1E76             ;-----------------------------------------------------------------------------
0013+  1E76             hex_ascii_encode:
0014+  1E76 1B            mov al, bl
0015+  1E77 93 40         test al, $40        ; test if letter or number
0016+  1E79 C7 7F 1E      jnz hex_letter
0017+  1E7C 87 0F         and al, $0F        ; get number
0018+  1E7E 09            ret
0019+  1E7F             hex_letter:
0020+  1E7F 87 0F         and al, $0F        ; get letter
0021+  1E81 6A 09         add al, 9
0022+  1E83 09            ret
0023+  1E84             
0024+  1E84             ;-----------------------------------------------------------------------------
0025+  1E84             ; ATOI
0026+  1E84             ; 2 letter hex string in B
0027+  1E84             ; 8bit integer returned in AL
0028+  1E84             ;-----------------------------------------------------------------------------
0029+  1E84             _atoi:
0030+  1E84 D8            push b
0031+  1E85 07 76 1E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1E88 30            mov bl, bh
0033+  1E89 DB            push al          ; save a
0034+  1E8A 07 76 1E      call hex_ascii_encode
0035+  1E8D EA            pop bl  
0036+  1E8E FD 9E 04      shl al, 4
0037+  1E91 8C            or al, bl
0038+  1E92 E5            pop b
0039+  1E93 09            ret  
0040+  1E94             
0041+  1E94             
0042+  1E94             ;-----------------------------------------------------------------------------
0043+  1E94             ; ITOA
0044+  1E94             ; 8bit value in BL
0045+  1E94             ; 2 byte ASCII result in A
0046+  1E94             ;-----------------------------------------------------------------------------
0047+  1E94             _itoa:
0048+  1E94 DA            push d
0049+  1E95 D8            push b
0050+  1E96 A7 00         mov bh, 0
0051+  1E98 FD A4 04      shr bl, 4  
0052+  1E9B 74            mov d, b
0053+  1E9C 1F 44 21      mov al, [d + s_hex_digits]
0054+  1E9F 23            mov ah, al
0055+  1EA0               
0056+  1EA0 E5            pop b
0057+  1EA1 D8            push b
0058+  1EA2 A7 00         mov bh, 0
0059+  1EA4 FD 87 0F      and bl, $0F
0060+  1EA7 74            mov d, b
0061+  1EA8 1F 44 21      mov al, [d + s_hex_digits]
0062+  1EAB E5            pop b
0063+  1EAC E7            pop d
0064+  1EAD 09            ret
0065+  1EAE             
0066+  1EAE             ;-----------------------------------------------------------------------------
0067+  1EAE             ; HEX STRING TO BINARY
0068+  1EAE             ; di = destination address
0069+  1EAE             ; si = source
0070+  1EAE             ;-----------------------------------------------------------------------------
0071+  1EAE             _hex_to_int:
0072+  1EAE             _hex_to_int_L1:
0073+  1EAE F6            lodsb          ; load from [SI] to AL
0074+  1EAF B9 00         cmp al, 0        ; check if ASCII 0
0075+  1EB1 C6 BE 1E      jz _hex_to_int_ret
0076+  1EB4 36            mov bh, al
0077+  1EB5 F6            lodsb
0078+  1EB6 2F            mov bl, al
0079+  1EB7 07 84 1E      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1EBA F7            stosb          ; store AL to [DI]
0081+  1EBB 0A AE 1E      jmp _hex_to_int_L1
0082+  1EBE             _hex_to_int_ret:
0083+  1EBE 09            ret    
0084+  1EBF             
0085+  1EBF             ;-----------------------------------------------------------------------------
0086+  1EBF             ; GETCHAR
0087+  1EBF             ; char in ah
0088+  1EBF             ;-----------------------------------------------------------------------------
0089+  1EBF             getch:
0090+  1EBF DB            push al
0091+  1EC0             getch_retry:
0092+  1EC0 19 01         mov al, 1
0093+  1EC2 05 03         syscall sys_io      ; receive in AH
0094+  1EC4 E8            pop al
0095+  1EC5 09            ret
0096+  1EC6             
0097+  1EC6             ;-----------------------------------------------------------------------------
0098+  1EC6             ; PUTCHAR
0099+  1EC6             ; char in ah
0100+  1EC6             ;-----------------------------------------------------------------------------
0101+  1EC6             _putchar:
0102+  1EC6 D7            push a
0103+  1EC7 19 00         mov al, 0
0104+  1EC9 05 03         syscall sys_io      ; char in AH
0105+  1ECB E4            pop a
0106+  1ECC 09            ret
0107+  1ECD             
0108+  1ECD             ;-----------------------------------------------------------------------------
0109+  1ECD             ;; INPUT A STRING
0110+  1ECD             ;; terminates with null
0111+  1ECD             ;; pointer in D
0112+  1ECD             ;-----------------------------------------------------------------------------
0113+  1ECD             _gets:
0114+  1ECD D7            push a
0115+  1ECE DA            push d
0116+  1ECF             _gets_loop:
0117+  1ECF 19 01         mov al, 1
0118+  1ED1 05 03         syscall sys_io      ; receive in AH
0119+  1ED3 B9 00         cmp al, 0        ; check error code (AL)
0120+  1ED5 C6 CF 1E      je _gets_loop      ; if no char received, retry
0121+  1ED8             
0122+  1ED8 76 1B         cmp ah, 27
0123+  1EDA C6 FB 1E      je _gets_ansi_esc
0124+  1EDD 76 0A         cmp ah, $0A        ; LF
0125+  1EDF C6 66 1F      je _gets_end
0126+  1EE2 76 0D         cmp ah, $0D        ; CR
0127+  1EE4 C6 66 1F      je _gets_end
0128+  1EE7 76 5C         cmp ah, $5C        ; '\\'
0129+  1EE9 C6 27 1F      je _gets_escape
0130+  1EEC               
0131+  1EEC 76 08         cmp ah, $08      ; check for backspace
0132+  1EEE C6 F7 1E      je _gets_backspace
0133+  1EF1             
0134+  1EF1 1A            mov al, ah
0135+  1EF2 3E            mov [d], al
0136+  1EF3 79            inc d
0137+  1EF4 0A CF 1E      jmp _gets_loop
0138+  1EF7             _gets_backspace:
0139+  1EF7 7F            dec d
0140+  1EF8 0A CF 1E      jmp _gets_loop
0141+  1EFB             _gets_ansi_esc:
0142+  1EFB 19 01         mov al, 1
0143+  1EFD 05 03         syscall sys_io        ; receive in AH without echo
0144+  1EFF B9 00         cmp al, 0          ; check error code (AL)
0145+  1F01 C6 FB 1E      je _gets_ansi_esc    ; if no char received, retry
0146+  1F04 76 5B         cmp ah, '['
0147+  1F06 C7 CF 1E      jne _gets_loop
0148+  1F09             _gets_ansi_esc_2:
0149+  1F09 19 01         mov al, 1
0150+  1F0B 05 03         syscall sys_io          ; receive in AH without echo
0151+  1F0D B9 00         cmp al, 0            ; check error code (AL)
0152+  1F0F C6 09 1F      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1F12 76 44         cmp ah, 'D'
0154+  1F14 C6 1F 1F      je _gets_left_arrow
0155+  1F17 76 43         cmp ah, 'C'
0156+  1F19 C6 23 1F      je _gets_right_arrow
0157+  1F1C 0A CF 1E      jmp _gets_loop
0158+  1F1F             _gets_left_arrow:
0159+  1F1F 7F            dec d
0160+  1F20 0A CF 1E      jmp _gets_loop
0161+  1F23             _gets_right_arrow:
0162+  1F23 79            inc d
0163+  1F24 0A CF 1E      jmp _gets_loop
0164+  1F27             _gets_escape:
0165+  1F27 19 01         mov al, 1
0166+  1F29 05 03         syscall sys_io      ; receive in AH
0167+  1F2B B9 00         cmp al, 0        ; check error code (AL)
0168+  1F2D C6 27 1F      je _gets_escape      ; if no char received, retry
0169+  1F30 76 6E         cmp ah, 'n'
0170+  1F32 C6 51 1F      je _gets_LF
0171+  1F35 76 72         cmp ah, 'r'
0172+  1F37 C6 58 1F      je _gets_CR
0173+  1F3A 76 30         cmp ah, '0'
0174+  1F3C C6 5F 1F      je _gets_NULL
0175+  1F3F 76 5C         cmp ah, $5C  ; '\'
0176+  1F41 C6 4A 1F      je _gets_slash
0177+  1F44 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1F45 3E            mov [d], al
0179+  1F46 79            inc d
0180+  1F47 0A CF 1E      jmp _gets_loop
0181+  1F4A             _gets_slash:
0182+  1F4A 19 5C         mov al, $5C
0183+  1F4C 3E            mov [d], al
0184+  1F4D 79            inc d
0185+  1F4E 0A CF 1E      jmp _gets_loop
0186+  1F51             _gets_LF:
0187+  1F51 19 0A         mov al, $0A
0188+  1F53 3E            mov [d], al
0189+  1F54 79            inc d
0190+  1F55 0A CF 1E      jmp _gets_loop
0191+  1F58             _gets_CR:
0192+  1F58 19 0D         mov al, $0D
0193+  1F5A 3E            mov [d], al
0194+  1F5B 79            inc d
0195+  1F5C 0A CF 1E      jmp _gets_loop
0196+  1F5F             _gets_NULL:
0197+  1F5F 19 00         mov al, $00
0198+  1F61 3E            mov [d], al
0199+  1F62 79            inc d
0200+  1F63 0A CF 1E      jmp _gets_loop
0201+  1F66             _gets_end:
0202+  1F66 19 00         mov al, 0
0203+  1F68 3E            mov [d], al        ; terminate string
0204+  1F69 E7            pop d
0205+  1F6A E4            pop a
0206+  1F6B 09            ret
0207+  1F6C             
0208+  1F6C             ;-----------------------------------------------------------------------------
0209+  1F6C             ;; INPUT TEXT
0210+  1F6C             ;; terminated with CTRL+D
0211+  1F6C             ;; pointer in D
0212+  1F6C             ;-----------------------------------------------------------------------------
0213+  1F6C             _gettxt:
0214+  1F6C D7            push a
0215+  1F6D DA            push d
0216+  1F6E             _gettxt_loop:
0217+  1F6E 19 01         mov al, 1
0218+  1F70 05 03         syscall sys_io      ; receive in AH
0219+  1F72 B9 00         cmp al, 0        ; check error code (AL)
0220+  1F74 C6 6E 1F      je _gettxt_loop    ; if no char received, retry
0221+  1F77 76 04         cmp ah, 4      ; EOT
0222+  1F79 C6 B7 1F      je _gettxt_end
0223+  1F7C 76 08         cmp ah, $08      ; check for backspace
0224+  1F7E C6 B3 1F      je _gettxt_backspace
0225+  1F81 76 5C         cmp ah, $5C        ; '\'
0226+  1F83 C6 8C 1F      je _gettxt_escape
0227+  1F86 1A            mov al, ah
0228+  1F87 3E            mov [d], al
0229+  1F88 79            inc d
0230+  1F89 0A 6E 1F      jmp _gettxt_loop
0231+  1F8C             _gettxt_escape:
0232+  1F8C 19 01         mov al, 1
0233+  1F8E 05 03         syscall sys_io      ; receive in AH
0234+  1F90 B9 00         cmp al, 0        ; check error code (AL)
0235+  1F92 C6 8C 1F      je _gettxt_escape    ; if no char received, retry
0236+  1F95 76 6E         cmp ah, 'n'
0237+  1F97 C6 A5 1F      je _gettxt_LF
0238+  1F9A 76 72         cmp ah, 'r'
0239+  1F9C C6 AC 1F      je _gettxt_CR
0240+  1F9F 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1FA0 3E            mov [d], al
0242+  1FA1 79            inc d
0243+  1FA2 0A 6E 1F      jmp _gettxt_loop
0244+  1FA5             _gettxt_LF:
0245+  1FA5 19 0A         mov al, $0A
0246+  1FA7 3E            mov [d], al
0247+  1FA8 79            inc d
0248+  1FA9 0A 6E 1F      jmp _gettxt_loop
0249+  1FAC             _gettxt_CR:
0250+  1FAC 19 0D         mov al, $0D
0251+  1FAE 3E            mov [d], al
0252+  1FAF 79            inc d
0253+  1FB0 0A 6E 1F      jmp _gettxt_loop
0254+  1FB3             _gettxt_backspace:
0255+  1FB3 7F            dec d
0256+  1FB4 0A 6E 1F      jmp _gettxt_loop
0257+  1FB7             _gettxt_end:
0258+  1FB7 19 00         mov al, 0
0259+  1FB9 3E            mov [d], al        ; terminate string
0260+  1FBA E7            pop d
0261+  1FBB E4            pop a
0262+  1FBC 09            ret
0263+  1FBD             
0264+  1FBD             ;-----------------------------------------------------------------------------
0265+  1FBD             ; PRINT NEW LINE
0266+  1FBD             ;-----------------------------------------------------------------------------
0267+  1FBD             printnl:
0268+  1FBD D7            push a
0269+  1FBE 10 00 0A      mov a, $0A00
0270+  1FC1 05 03         syscall sys_io
0271+  1FC3 10 00 0D      mov a, $0D00
0272+  1FC6 05 03         syscall sys_io
0273+  1FC8 E4            pop a
0274+  1FC9 09            ret
0275+  1FCA             
0276+  1FCA             ;-----------------------------------------------------------------------------
0277+  1FCA             ; _strtoint
0278+  1FCA             ; 4 digit hex string number in d
0279+  1FCA             ; integer returned in A
0280+  1FCA             ;-----------------------------------------------------------------------------
0281+  1FCA             _strtointx:
0282+  1FCA D8            push b
0283+  1FCB 32            mov bl, [d]
0284+  1FCC 37            mov bh, bl
0285+  1FCD 33 01 00      mov bl, [d + 1]
0286+  1FD0 07 84 1E      call _atoi        ; convert to int in AL
0287+  1FD3 23            mov ah, al        ; move to AH
0288+  1FD4 33 02 00      mov bl, [d + 2]
0289+  1FD7 37            mov bh, bl
0290+  1FD8 33 03 00      mov bl, [d + 3]
0291+  1FDB 07 84 1E      call _atoi        ; convert to int in AL
0292+  1FDE E5            pop b
0293+  1FDF 09            ret
0294+  1FE0             
0295+  1FE0             ;-----------------------------------------------------------------------------
0296+  1FE0             ; _strtoint
0297+  1FE0             ; 5 digit base10 string number in d
0298+  1FE0             ; integer returned in A
0299+  1FE0             ;-----------------------------------------------------------------------------
0300+  1FE0             _strtoint:
0301+  1FE0 E2            push si
0302+  1FE1 D8            push b
0303+  1FE2 D9            push c
0304+  1FE3 DA            push d
0305+  1FE4 07 26 1E      call _strlen      ; get string length in C
0306+  1FE7 7E            dec c
0307+  1FE8 FD 4E         mov si, d
0308+  1FEA 12            mov a, c
0309+  1FEB FD 99         shl a
0310+  1FED 3B 5C 21      mov d, table_power
0311+  1FF0 59            add d, a
0312+  1FF1 38 00 00      mov c, 0
0313+  1FF4             _strtoint_L0:
0314+  1FF4 F6            lodsb      ; load ASCII to al
0315+  1FF5 B9 00         cmp al, 0
0316+  1FF7 C6 0A 20      je _strtoint_end
0317+  1FFA 6F 30         sub al, $30    ; make into integer
0318+  1FFC 22 00         mov ah, 0
0319+  1FFE 2A            mov b, [d]
0320+  1FFF AC            mul a, b      ; result in B since it fits in 16bits
0321+  2000 11            mov a, b
0322+  2001 28            mov b, c
0323+  2002 54            add a, b
0324+  2003 39            mov c, a
0325+  2004 63 02 00      sub d, 2
0326+  2007 0A F4 1F      jmp _strtoint_L0
0327+  200A             _strtoint_end:
0328+  200A 12            mov a, c
0329+  200B E7            pop d
0330+  200C E6            pop c
0331+  200D E5            pop b
0332+  200E EF            pop si
0333+  200F 09            ret
0334+  2010             
0335+  2010             ;-----------------------------------------------------------------------------
0336+  2010             ; PRINT NULL TERMINATED STRING
0337+  2010             ; pointer in D
0338+  2010             ;-----------------------------------------------------------------------------
0339+  2010             _puts:
0340+  2010 D7            push a
0341+  2011 DA            push d
0342+  2012             _puts_L1:
0343+  2012 1E            mov al, [d]
0344+  2013 B9 00         cmp al, 0
0345+  2015 C6 21 20      jz _puts_END
0346+  2018 23            mov ah, al
0347+  2019 19 00         mov al, 0
0348+  201B 05 03         syscall sys_io
0349+  201D 79            inc d
0350+  201E 0A 12 20      jmp _puts_L1
0351+  2021             _puts_END:
0352+  2021 E7            pop d
0353+  2022 E4            pop a
0354+  2023 09            ret
0355+  2024             
0356+  2024             ;-----------------------------------------------------------------------------
0357+  2024             ; PRINT N SIZE STRING
0358+  2024             ; pointer in D
0359+  2024             ; size in C
0360+  2024             ;-----------------------------------------------------------------------------
0361+  2024             _putsn:
0362+  2024 DB            push al
0363+  2025 DA            push d
0364+  2026 D9            push c
0365+  2027             _putsn_L0:
0366+  2027 1E            mov al, [d]
0367+  2028 23            mov ah, al
0368+  2029 19 00         mov al, 0
0369+  202B 05 03         syscall sys_io
0370+  202D 79            inc d
0371+  202E 7E            dec c  
0372+  202F C2 00 00      cmp c, 0
0373+  2032 C7 27 20      jne _putsn_L0
0374+  2035             _putsn_end:
0375+  2035 E6            pop c
0376+  2036 E7            pop d
0377+  2037 E8            pop al
0378+  2038 09            ret
0379+  2039             
0380+  2039             ;-----------------------------------------------------------------------------
0381+  2039             ; print 16bit decimal number
0382+  2039             ; input number in A
0383+  2039             ;-----------------------------------------------------------------------------
0384+  2039             print_u16d:
0385+  2039 D7            push a
0386+  203A D8            push b
0387+  203B 26 10 27      mov b, 10000
0388+  203E AE            div a, b      ; get 10000's coeff.
0389+  203F 07 61 20      call print_number
0390+  2042 11            mov a, b
0391+  2043 26 E8 03      mov b, 1000
0392+  2046 AE            div a, b      ; get 1000's coeff.
0393+  2047 07 61 20      call print_number
0394+  204A 11            mov a, b
0395+  204B 26 64 00      mov b, 100
0396+  204E AE            div a, b
0397+  204F 07 61 20      call print_number
0398+  2052 11            mov a, b
0399+  2053 26 0A 00      mov b, 10
0400+  2056 AE            div a, b
0401+  2057 07 61 20      call print_number
0402+  205A 1B            mov al, bl      ; 1's coeff in bl
0403+  205B 07 61 20      call print_number
0404+  205E E5            pop b
0405+  205F E4            pop a
0406+  2060 09            ret
0407+  2061             
0408+  2061             ;-----------------------------------------------------------------------------
0409+  2061             ; print AL
0410+  2061             ;-----------------------------------------------------------------------------
0411+  2061             print_number:
0412+  2061 6A 30         add al, $30
0413+  2063 23            mov ah, al
0414+  2064 07 C6 1E      call _putchar
0415+  2067 09            ret
0416+  2068             
0417+  2068             ;-----------------------------------------------------------------------------
0418+  2068             ; PRINT 16BIT HEX INTEGER
0419+  2068             ; integer value in reg B
0420+  2068             ;-----------------------------------------------------------------------------
0421+  2068             print_u16x:
0422+  2068 D7            push a
0423+  2069 D8            push b
0424+  206A DD            push bl
0425+  206B 30            mov bl, bh
0426+  206C 07 94 1E      call _itoa        ; convert bh to char in A
0427+  206F 2F            mov bl, al        ; save al
0428+  2070 19 00         mov al, 0
0429+  2072 05 03         syscall sys_io        ; display AH
0430+  2074 24            mov ah, bl        ; retrieve al
0431+  2075 19 00         mov al, 0
0432+  2077 05 03         syscall sys_io        ; display AL
0433+  2079             
0434+  2079 EA            pop bl
0435+  207A 07 94 1E      call _itoa        ; convert bh to char in A
0436+  207D 2F            mov bl, al        ; save al
0437+  207E 19 00         mov al, 0
0438+  2080 05 03         syscall sys_io        ; display AH
0439+  2082 24            mov ah, bl        ; retrieve al
0440+  2083 19 00         mov al, 0
0441+  2085 05 03         syscall sys_io        ; display AL
0442+  2087             
0443+  2087 E5            pop b
0444+  2088 E4            pop a
0445+  2089 09            ret
0446+  208A             
0447+  208A             ;-----------------------------------------------------------------------------
0448+  208A             ; INPUT 16BIT HEX INTEGER
0449+  208A             ; read 16bit integer into A
0450+  208A             ;-----------------------------------------------------------------------------
0451+  208A             scan_u16x:
0452+  208A F8 10 00      enter 16
0453+  208D D8            push b
0454+  208E DA            push d
0455+  208F             
0456+  208F FA F1 FF      lea d, [bp + -15]
0457+  2092 07 CD 1E      call _gets        ; get number
0458+  2095             
0459+  2095 32            mov bl, [d]
0460+  2096 37            mov bh, bl
0461+  2097 33 01 00      mov bl, [d + 1]
0462+  209A 07 84 1E      call _atoi        ; convert to int in AL
0463+  209D 23            mov ah, al        ; move to AH
0464+  209E             
0465+  209E 33 02 00      mov bl, [d + 2]
0466+  20A1 37            mov bh, bl
0467+  20A2 33 03 00      mov bl, [d + 3]
0468+  20A5 07 84 1E      call _atoi        ; convert to int in AL
0469+  20A8             
0470+  20A8 E7            pop d
0471+  20A9 E5            pop b
0472+  20AA F9            leave
0473+  20AB 09            ret
0474+  20AC             
0475+  20AC             ;-----------------------------------------------------------------------------
0476+  20AC             ; PRINT 8bit HEX INTEGER
0477+  20AC             ; integer value in reg bl
0478+  20AC             ;-----------------------------------------------------------------------------
0479+  20AC             print_u8x:
0480+  20AC D7            push a
0481+  20AD DD            push bl
0482+  20AE             
0483+  20AE 07 94 1E      call _itoa        ; convert bl to char in A
0484+  20B1 2F            mov bl, al        ; save al
0485+  20B2 19 00         mov al, 0
0486+  20B4 05 03         syscall sys_io        ; display AH
0487+  20B6 24            mov ah, bl        ; retrieve al
0488+  20B7 19 00         mov al, 0
0489+  20B9 05 03         syscall sys_io        ; display AL
0490+  20BB             
0491+  20BB EA            pop bl
0492+  20BC E4            pop a
0493+  20BD 09            ret
0494+  20BE             
0495+  20BE             ;-----------------------------------------------------------------------------
0496+  20BE             ; print 8bit decimal unsigned number
0497+  20BE             ; input number in AL
0498+  20BE             ;-----------------------------------------------------------------------------
0499+  20BE             print_u8d:
0500+  20BE D7            push a
0501+  20BF D8            push b
0502+  20C0             
0503+  20C0 22 00         mov ah, 0
0504+  20C2 26 64 00      mov b, 100
0505+  20C5 AE            div a, b
0506+  20C6 D8            push b      ; save remainder
0507+  20C7 B9 00         cmp al, 0
0508+  20C9 C6 D3 20      je skip100
0509+  20CC 6A 30         add al, $30
0510+  20CE 23            mov ah, al
0511+  20CF 19 00         mov al, 0
0512+  20D1 05 03         syscall sys_io  ; print coeff
0513+  20D3             skip100:
0514+  20D3 E4            pop a
0515+  20D4 22 00         mov ah, 0
0516+  20D6 26 0A 00      mov b, 10
0517+  20D9 AE            div a, b
0518+  20DA D8            push b      ; save remainder
0519+  20DB B9 00         cmp al, 0
0520+  20DD C6 E7 20      je skip10
0521+  20E0 6A 30         add al, $30
0522+  20E2 23            mov ah, al
0523+  20E3 19 00         mov al, 0
0524+  20E5 05 03         syscall sys_io  ; print coeff
0525+  20E7             skip10:
0526+  20E7 E4            pop a
0527+  20E8 1B            mov al, bl
0528+  20E9 6A 30         add al, $30
0529+  20EB 23            mov ah, al
0530+  20EC 19 00         mov al, 0
0531+  20EE 05 03         syscall sys_io  ; print coeff
0532+  20F0 E5            pop b
0533+  20F1 E4            pop a
0534+  20F2 09            ret
0535+  20F3             
0536+  20F3             ;-----------------------------------------------------------------------------
0537+  20F3             ; INPUT 8BIT HEX INTEGER
0538+  20F3             ; read 8bit integer into AL
0539+  20F3             ;-----------------------------------------------------------------------------
0540+  20F3             scan_u8x:
0541+  20F3 F8 04 00      enter 4
0542+  20F6 D8            push b
0543+  20F7 DA            push d
0544+  20F8             
0545+  20F8 FA FD FF      lea d, [bp + -3]
0546+  20FB 07 CD 1E      call _gets        ; get number
0547+  20FE             
0548+  20FE 32            mov bl, [d]
0549+  20FF 37            mov bh, bl
0550+  2100 33 01 00      mov bl, [d + 1]
0551+  2103 07 84 1E      call _atoi        ; convert to int in AL
0552+  2106             
0553+  2106 E7            pop d
0554+  2107 E5            pop b
0555+  2108 F9            leave
0556+  2109 09            ret
0557+  210A             
0558+  210A             ;-----------------------------------------------------------------------------
0559+  210A             ; input decimal number
0560+  210A             ; result in A
0561+  210A             ; 655'\0'
0562+  210A             ; low--------high
0563+  210A             ;-----------------------------------------------------------------------------
0564+  210A             scan_u16d:
0565+  210A F8 08 00      enter 8
0566+  210D E2            push si
0567+  210E D8            push b
0568+  210F D9            push c
0569+  2110 DA            push d
0570+  2111 FA F9 FF      lea d, [bp +- 7]
0571+  2114 07 CD 1E      call _gets
0572+  2117 07 26 1E      call _strlen      ; get string length in C
0573+  211A 7E            dec c
0574+  211B FD 4E         mov si, d
0575+  211D 12            mov a, c
0576+  211E FD 99         shl a
0577+  2120 3B 5C 21      mov d, table_power
0578+  2123 59            add d, a
0579+  2124 38 00 00      mov c, 0
0580+  2127             mul_loop:
0581+  2127 F6            lodsb      ; load ASCII to al
0582+  2128 B9 00         cmp al, 0
0583+  212A C6 3D 21      je mul_exit
0584+  212D 6F 30         sub al, $30    ; make into integer
0585+  212F 22 00         mov ah, 0
0586+  2131 2A            mov b, [d]
0587+  2132 AC            mul a, b      ; result in B since it fits in 16bits
0588+  2133 11            mov a, b
0589+  2134 28            mov b, c
0590+  2135 54            add a, b
0591+  2136 39            mov c, a
0592+  2137 63 02 00      sub d, 2
0593+  213A 0A 27 21      jmp mul_loop
0594+  213D             mul_exit:
0595+  213D 12            mov a, c
0596+  213E E7            pop d
0597+  213F E6            pop c
0598+  2140 E5            pop b
0599+  2141 EF            pop si
0600+  2142 F9            leave
0601+  2143 09            ret
0602+  2144             
0603+  2144 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  2148 34 35 36 37 
0603+  214C 38 39 41 42 
0603+  2150 43 44 45 46 
0604+  2154 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  2158 1B 5B 48 00 
0605+  215C             
0606+  215C             table_power:
0607+  215C 01 00         .dw 1
0608+  215E 0A 00         .dw 10
0609+  2160 64 00         .dw 100
0610+  2162 E8 03         .dw 1000
0611+  2164 10 27         .dw 100004217   2166             ; --- END INLINE ASM SEGMENT
4218   2166             
4219   2166 F9            leave
4220   2167 09            ret
4221   2168             ; --- END TEXT SEGMENT
4222   2168             
4223   2168             ; --- BEGIN DATA SEGMENT
4224   2168 00 00 00 00 _p: .fill 4, 0
4225   216C 00 00       st_fopen_max_handle: .dw 0
4226   216E 55 6E 65 78 _s0: .db "Unexpected format in printf.", 0
4226   2172 70 65 63 74 
4226   2176 65 64 20 66 
4226   217A 6F 72 6D 61 
4226   217E 74 20 69 6E 
4226   2182 20 70 72 69 
4226   2186 6E 74 66 2E 
4226   218A 00 
4227   218B 45 72 72 6F _s1: .db "Error: Unknown argument type.\n", 0
4227   218F 72 3A 20 55 
4227   2193 6E 6B 6E 6F 
4227   2197 77 6E 20 61 
4227   219B 72 67 75 6D 
4227   219F 65 6E 74 20 
4227   21A3 74 79 70 65 
4227   21A7 2E 0A 00 
4228   21AA 1B 5B 32 4A _s2: .db "\033[2J\033[H", 0
4228   21AE 1B 5B 48 00 
4229   21B2             
4230   21B2 B4 21       _heap_top: .dw _heap
4231   21B4 00          _heap: .db 0
4232   21B5             ; --- END DATA SEGMENT
4233   21B5             
4234   21B5             .end
tasm: Number of errors = 0
