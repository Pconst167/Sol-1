0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; printf("Hello: %c %d %s", 'A', 64, "Paulo");   
0011   0408 26 0A 11      mov b, __s0 ; "Paulo"
0012   040B FD AB         swp b
0013   040D D8            push b
0014   040E 26 40 00      mov b, $40
0015   0411 FD AB         swp b
0016   0413 D8            push b
0017   0414 26 41 00      mov b, $41
0018   0417 FD AB         swp b
0019   0419 D8            push b
0020   041A 26 10 11      mov b, __s1 ; "Hello: %c %d %s"
0021   041D FD AB         swp b
0022   041F D8            push b
0023   0420 07 F1 05      call printf
0024   0423 51 08 00      add sp, 8
0025   0426             ;; return 0; 
0026   0426 26 00 00      mov b, $0
0027   0429 F9            leave
0028   042A 05 0B         syscall sys_terminate_proc
0029   042C             
0030   042C             strcpy:
0031   042C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0032   042F             ; $psrc 
0033   042F             ; $pdest 
0034   042F 52 04 00      sub sp, 4
0035   0432             ;; psrc = src; 
0036   0432 FA FF FF      lea d, [bp + -1] ; $psrc
0037   0435 DA            push d
0038   0436 FA 05 00      lea d, [bp + 5] ; $src
0039   0439 2A            mov b, [d]
0040   043A E7            pop d
0041   043B FD 43         mov [d], b
0042   043D             ;; pdest = dest; 
0043   043D FA FD FF      lea d, [bp + -3] ; $pdest
0044   0440 DA            push d
0045   0441 FA 07 00      lea d, [bp + 7] ; $dest
0046   0444 2A            mov b, [d]
0047   0445 E7            pop d
0048   0446 FD 43         mov [d], b
0049   0448             ;; while(*psrc) *pdest++ = *psrc++; 
0050   0448             _while1_cond:
0051   0448 FA FF FF      lea d, [bp + -1] ; $psrc
0052   044B 2A            mov b, [d]
0053   044C 74            mov d, b
0054   044D 32            mov bl, [d]
0055   044E A7 00         mov bh, 0
0056   0450 C0 00 00      cmp b, 0
0057   0453 C6 7F 04      je _while1_exit
0058   0456             _while1_block:
0059   0456             ;; *pdest++ = *psrc++; 
0060   0456 FA FD FF      lea d, [bp + -3] ; $pdest
0061   0459 2A            mov b, [d]
0062   045A FD 79         mov g, b
0063   045C FD 77         inc b
0064   045E FA FD FF      lea d, [bp + -3] ; $pdest
0065   0461 FD 43         mov [d], b
0066   0463 FD 27         mov b, g
0067   0465 D8            push b
0068   0466 FA FF FF      lea d, [bp + -1] ; $psrc
0069   0469 2A            mov b, [d]
0070   046A FD 79         mov g, b
0071   046C FD 77         inc b
0072   046E FA FF FF      lea d, [bp + -1] ; $psrc
0073   0471 FD 43         mov [d], b
0074   0473 FD 27         mov b, g
0075   0475 74            mov d, b
0076   0476 32            mov bl, [d]
0077   0477 A7 00         mov bh, 0
0078   0479 E7            pop d
0079   047A FD 3E         mov [d], bl
0080   047C 0A 48 04      jmp _while1_cond
0081   047F             _while1_exit:
0082   047F             ;; *pdest = '\0'; 
0083   047F FA FD FF      lea d, [bp + -3] ; $pdest
0084   0482 2A            mov b, [d]
0085   0483 D8            push b
0086   0484 26 00 00      mov b, $0
0087   0487 E7            pop d
0088   0488 FD 3E         mov [d], bl
0089   048A F9            leave
0090   048B 09            ret
0091   048C             
0092   048C             strcmp:
0093   048C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0094   048F             ;; while (*s1 && (*s1 == *s2)) { 
0095   048F             _while2_cond:
0096   048F FA 07 00      lea d, [bp + 7] ; $s1
0097   0492 2A            mov b, [d]
0098   0493 74            mov d, b
0099   0494 32            mov bl, [d]
0100   0495 A7 00         mov bh, 0
0101   0497 D7            push a
0102   0498 11            mov a, b
0103   0499 FA 07 00      lea d, [bp + 7] ; $s1
0104   049C 2A            mov b, [d]
0105   049D 74            mov d, b
0106   049E 32            mov bl, [d]
0107   049F A7 00         mov bh, 0
0108   04A1             ; START RELATIONAL
0109   04A1 D7            push a
0110   04A2 11            mov a, b
0111   04A3 FA 05 00      lea d, [bp + 5] ; $s2
0112   04A6 2A            mov b, [d]
0113   04A7 74            mov d, b
0114   04A8 32            mov bl, [d]
0115   04A9 A7 00         mov bh, 0
0116   04AB B0            cmp a, b
0117   04AC FD 71         seq ; ==
0118   04AE E4            pop a
0119   04AF             ; END RELATIONAL
0120   04AF FD A7         sand a, b ; &&
0121   04B1 E4            pop a
0122   04B2 C0 00 00      cmp b, 0
0123   04B5 C6 D9 04      je _while2_exit
0124   04B8             _while2_block:
0125   04B8             ;; s1++; 
0126   04B8 FA 07 00      lea d, [bp + 7] ; $s1
0127   04BB 2A            mov b, [d]
0128   04BC FD 79         mov g, b
0129   04BE FD 77         inc b
0130   04C0 FA 07 00      lea d, [bp + 7] ; $s1
0131   04C3 FD 43         mov [d], b
0132   04C5 FD 27         mov b, g
0133   04C7             ;; s2++; 
0134   04C7 FA 05 00      lea d, [bp + 5] ; $s2
0135   04CA 2A            mov b, [d]
0136   04CB FD 79         mov g, b
0137   04CD FD 77         inc b
0138   04CF FA 05 00      lea d, [bp + 5] ; $s2
0139   04D2 FD 43         mov [d], b
0140   04D4 FD 27         mov b, g
0141   04D6 0A 8F 04      jmp _while2_cond
0142   04D9             _while2_exit:
0143   04D9             ;; return *s1 - *s2; 
0144   04D9 FA 07 00      lea d, [bp + 7] ; $s1
0145   04DC 2A            mov b, [d]
0146   04DD 74            mov d, b
0147   04DE 32            mov bl, [d]
0148   04DF A7 00         mov bh, 0
0149   04E1             ; START TERMS
0150   04E1 D7            push a
0151   04E2 11            mov a, b
0152   04E3 FA 05 00      lea d, [bp + 5] ; $s2
0153   04E6 2A            mov b, [d]
0154   04E7 74            mov d, b
0155   04E8 32            mov bl, [d]
0156   04E9 A7 00         mov bh, 0
0157   04EB 60            sub a, b
0158   04EC 27            mov b, a
0159   04ED E4            pop a
0160   04EE             ; END TERMS
0161   04EE F9            leave
0162   04EF 09            ret
0163   04F0             
0164   04F0             strcat:
0165   04F0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0166   04F3             ; $dest_len 
0167   04F3             ; $i 
0168   04F3 52 04 00      sub sp, 4
0169   04F6             ;; dest_len = strlen(dest); 
0170   04F6 FA FF FF      lea d, [bp + -1] ; $dest_len
0171   04F9 DA            push d
0172   04FA FA 07 00      lea d, [bp + 7] ; $dest
0173   04FD 2A            mov b, [d]
0174   04FE FD AB         swp b
0175   0500 D8            push b
0176   0501 07 A6 05      call strlen
0177   0504 51 02 00      add sp, 2
0178   0507 E7            pop d
0179   0508 FD 43         mov [d], b
0180   050A             ;; for (i = 0; src[i] != 0; i=i+1) { 
0181   050A             _for3_init:
0182   050A FA FD FF      lea d, [bp + -3] ; $i
0183   050D DA            push d
0184   050E 26 00 00      mov b, $0
0185   0511 E7            pop d
0186   0512 FD 43         mov [d], b
0187   0514             _for3_cond:
0188   0514 FA 05 00      lea d, [bp + 5] ; $src
0189   0517 FD 2A         mov d, [d]
0190   0519 D7            push a
0191   051A DA            push d
0192   051B FA FD FF      lea d, [bp + -3] ; $i
0193   051E 2A            mov b, [d]
0194   051F E7            pop d
0195   0520 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0196   0524 E4            pop a
0197   0525 32            mov bl, [d]
0198   0526 A7 00         mov bh, 0
0199   0528             ; START RELATIONAL
0200   0528 D7            push a
0201   0529 11            mov a, b
0202   052A 26 00 00      mov b, $0
0203   052D B0            cmp a, b
0204   052E FD 72         sneq ; !=
0205   0530 E4            pop a
0206   0531             ; END RELATIONAL
0207   0531 C0 00 00      cmp b, 0
0208   0534 C6 7F 05      je _for3_exit
0209   0537             _for3_block:
0210   0537             ;; dest[dest_len + i] = src[i]; 
0211   0537 FA 07 00      lea d, [bp + 7] ; $dest
0212   053A FD 2A         mov d, [d]
0213   053C D7            push a
0214   053D DA            push d
0215   053E FA FF FF      lea d, [bp + -1] ; $dest_len
0216   0541 2A            mov b, [d]
0217   0542             ; START TERMS
0218   0542 D7            push a
0219   0543 11            mov a, b
0220   0544 FA FD FF      lea d, [bp + -3] ; $i
0221   0547 2A            mov b, [d]
0222   0548 54            add a, b
0223   0549 27            mov b, a
0224   054A E4            pop a
0225   054B             ; END TERMS
0226   054B E7            pop d
0227   054C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0228   0550 E4            pop a
0229   0551 DA            push d
0230   0552 FA 05 00      lea d, [bp + 5] ; $src
0231   0555 FD 2A         mov d, [d]
0232   0557 D7            push a
0233   0558 DA            push d
0234   0559 FA FD FF      lea d, [bp + -3] ; $i
0235   055C 2A            mov b, [d]
0236   055D E7            pop d
0237   055E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0238   0562 E4            pop a
0239   0563 32            mov bl, [d]
0240   0564 A7 00         mov bh, 0
0241   0566 E7            pop d
0242   0567 FD 3E         mov [d], bl
0243   0569             _for3_update:
0244   0569 FA FD FF      lea d, [bp + -3] ; $i
0245   056C DA            push d
0246   056D FA FD FF      lea d, [bp + -3] ; $i
0247   0570 2A            mov b, [d]
0248   0571             ; START TERMS
0249   0571 D7            push a
0250   0572 11            mov a, b
0251   0573 26 01 00      mov b, $1
0252   0576 54            add a, b
0253   0577 27            mov b, a
0254   0578 E4            pop a
0255   0579             ; END TERMS
0256   0579 E7            pop d
0257   057A FD 43         mov [d], b
0258   057C 0A 14 05      jmp _for3_cond
0259   057F             _for3_exit:
0260   057F             ;; dest[dest_len + i] = 0; 
0261   057F FA 07 00      lea d, [bp + 7] ; $dest
0262   0582 FD 2A         mov d, [d]
0263   0584 D7            push a
0264   0585 DA            push d
0265   0586 FA FF FF      lea d, [bp + -1] ; $dest_len
0266   0589 2A            mov b, [d]
0267   058A             ; START TERMS
0268   058A D7            push a
0269   058B 11            mov a, b
0270   058C FA FD FF      lea d, [bp + -3] ; $i
0271   058F 2A            mov b, [d]
0272   0590 54            add a, b
0273   0591 27            mov b, a
0274   0592 E4            pop a
0275   0593             ; END TERMS
0276   0593 E7            pop d
0277   0594 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0278   0598 E4            pop a
0279   0599 DA            push d
0280   059A 26 00 00      mov b, $0
0281   059D E7            pop d
0282   059E FD 3E         mov [d], bl
0283   05A0             ;; return dest; 
0284   05A0 FA 07 00      lea d, [bp + 7] ; $dest
0285   05A3 2A            mov b, [d]
0286   05A4 F9            leave
0287   05A5 09            ret
0288   05A6             
0289   05A6             strlen:
0290   05A6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0291   05A9             ; $length 
0292   05A9 52 02 00      sub sp, 2
0293   05AC             ;; length = 0; 
0294   05AC FA FF FF      lea d, [bp + -1] ; $length
0295   05AF DA            push d
0296   05B0 26 00 00      mov b, $0
0297   05B3 E7            pop d
0298   05B4 FD 43         mov [d], b
0299   05B6             ;; while (str[length] != 0) { 
0300   05B6             _while4_cond:
0301   05B6 FA 05 00      lea d, [bp + 5] ; $str
0302   05B9 FD 2A         mov d, [d]
0303   05BB D7            push a
0304   05BC DA            push d
0305   05BD FA FF FF      lea d, [bp + -1] ; $length
0306   05C0 2A            mov b, [d]
0307   05C1 E7            pop d
0308   05C2 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0309   05C6 E4            pop a
0310   05C7 32            mov bl, [d]
0311   05C8 A7 00         mov bh, 0
0312   05CA             ; START RELATIONAL
0313   05CA D7            push a
0314   05CB 11            mov a, b
0315   05CC 26 00 00      mov b, $0
0316   05CF B0            cmp a, b
0317   05D0 FD 72         sneq ; !=
0318   05D2 E4            pop a
0319   05D3             ; END RELATIONAL
0320   05D3 C0 00 00      cmp b, 0
0321   05D6 C6 EB 05      je _while4_exit
0322   05D9             _while4_block:
0323   05D9             ;; length++; 
0324   05D9 FA FF FF      lea d, [bp + -1] ; $length
0325   05DC 2A            mov b, [d]
0326   05DD FD 79         mov g, b
0327   05DF FD 77         inc b
0328   05E1 FA FF FF      lea d, [bp + -1] ; $length
0329   05E4 FD 43         mov [d], b
0330   05E6 FD 27         mov b, g
0331   05E8 0A B6 05      jmp _while4_cond
0332   05EB             _while4_exit:
0333   05EB             ;; return length; 
0334   05EB FA FF FF      lea d, [bp + -1] ; $length
0335   05EE 2A            mov b, [d]
0336   05EF F9            leave
0337   05F0 09            ret
0338   05F1             
0339   05F1             printf:
0340   05F1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0341   05F4             ; $p 
0342   05F4             ; $fp 
0343   05F4             ; $i 
0344   05F4 52 06 00      sub sp, 6
0345   05F7             ;; fp = format; 
0346   05F7 FA FD FF      lea d, [bp + -3] ; $fp
0347   05FA DA            push d
0348   05FB FA 05 00      lea d, [bp + 5] ; $format
0349   05FE 2A            mov b, [d]
0350   05FF E7            pop d
0351   0600 FD 43         mov [d], b
0352   0602             ;; p = &format + 2; 
0353   0602 FA FF FF      lea d, [bp + -1] ; $p
0354   0605 DA            push d
0355   0606 FA 05 00      lea d, [bp + 5] ; $format
0356   0609 2D            mov b, d
0357   060A             ; START TERMS
0358   060A D7            push a
0359   060B 11            mov a, b
0360   060C 26 02 00      mov b, $2
0361   060F 54            add a, b
0362   0610 27            mov b, a
0363   0611 E4            pop a
0364   0612             ; END TERMS
0365   0612 E7            pop d
0366   0613 FD 43         mov [d], b
0367   0615             ;; for(;;){ 
0368   0615             _for5_init:
0369   0615             _for5_cond:
0370   0615             _for5_block:
0371   0615             ;; if(!*fp) break; 
0372   0615             _if6_cond:
0373   0615 FA FD FF      lea d, [bp + -3] ; $fp
0374   0618 2A            mov b, [d]
0375   0619 74            mov d, b
0376   061A 32            mov bl, [d]
0377   061B A7 00         mov bh, 0
0378   061D C0 00 00      cmp b, 0
0379   0620 FD 71         seq ; !
0380   0622 C0 00 00      cmp b, 0
0381   0625 C6 2E 06      je _if6_else
0382   0628             _if6_true:
0383   0628             ;; break; 
0384   0628 0A 78 07      jmp _for5_exit ; for break
0385   062B 0A 75 07      jmp _if6_exit
0386   062E             _if6_else:
0387   062E             ;; if(*fp == '%'){ 
0388   062E             _if7_cond:
0389   062E FA FD FF      lea d, [bp + -3] ; $fp
0390   0631 2A            mov b, [d]
0391   0632 74            mov d, b
0392   0633 32            mov bl, [d]
0393   0634 A7 00         mov bh, 0
0394   0636             ; START RELATIONAL
0395   0636 D7            push a
0396   0637 11            mov a, b
0397   0638 26 25 00      mov b, $25
0398   063B B0            cmp a, b
0399   063C FD 71         seq ; ==
0400   063E E4            pop a
0401   063F             ; END RELATIONAL
0402   063F C0 00 00      cmp b, 0
0403   0642 C6 57 07      je _if7_else
0404   0645             _if7_true:
0405   0645             ;; fp++; 
0406   0645 FA FD FF      lea d, [bp + -3] ; $fp
0407   0648 2A            mov b, [d]
0408   0649 FD 79         mov g, b
0409   064B FD 77         inc b
0410   064D FA FD FF      lea d, [bp + -3] ; $fp
0411   0650 FD 43         mov [d], b
0412   0652 FD 27         mov b, g
0413   0654             ;; switch(*fp){ 
0414   0654             _switch8_expr:
0415   0654 FA FD FF      lea d, [bp + -3] ; $fp
0416   0657 2A            mov b, [d]
0417   0658 74            mov d, b
0418   0659 32            mov bl, [d]
0419   065A A7 00         mov bh, 0
0420   065C             _switch8_comparisons:
0421   065C C1 64         cmp bl, $64
0422   065E C6 80 06      je _switch8_case0
0423   0661 C1 69         cmp bl, $69
0424   0663 C6 80 06      je _switch8_case1
0425   0666 C1 75         cmp bl, $75
0426   0668 C6 A5 06      je _switch8_case2
0427   066B C1 78         cmp bl, $78
0428   066D C6 CA 06      je _switch8_case3
0429   0670 C1 63         cmp bl, $63
0430   0672 C6 EF 06      je _switch8_case4
0431   0675 C1 73         cmp bl, $73
0432   0677 C6 14 07      je _switch8_case5
0433   067A 0A 39 07      jmp _switch8_default
0434   067D 0A 45 07      jmp _switch8_exit
0435   0680             _switch8_case0:
0436   0680             _switch8_case1:
0437   0680             ;; prints(*(int*)p); 
0438   0680 FA FF FF      lea d, [bp + -1] ; $p
0439   0683 2A            mov b, [d]
0440   0684 74            mov d, b
0441   0685 2A            mov b, [d]
0442   0686 FD AB         swp b
0443   0688 D8            push b
0444   0689 07 0A 0A      call prints
0445   068C 51 02 00      add sp, 2
0446   068F             ;; p = p + 2; 
0447   068F FA FF FF      lea d, [bp + -1] ; $p
0448   0692 DA            push d
0449   0693 FA FF FF      lea d, [bp + -1] ; $p
0450   0696 2A            mov b, [d]
0451   0697             ; START TERMS
0452   0697 D7            push a
0453   0698 11            mov a, b
0454   0699 26 02 00      mov b, $2
0455   069C 54            add a, b
0456   069D 27            mov b, a
0457   069E E4            pop a
0458   069F             ; END TERMS
0459   069F E7            pop d
0460   06A0 FD 43         mov [d], b
0461   06A2             ;; break; 
0462   06A2 0A 45 07      jmp _switch8_exit ; case break
0463   06A5             _switch8_case2:
0464   06A5             ;; printu(*(unsigned int*)p); 
0465   06A5 FA FF FF      lea d, [bp + -1] ; $p
0466   06A8 2A            mov b, [d]
0467   06A9 74            mov d, b
0468   06AA 2A            mov b, [d]
0469   06AB FD AB         swp b
0470   06AD D8            push b
0471   06AE 07 FF 0A      call printu
0472   06B1 51 02 00      add sp, 2
0473   06B4             ;; p = p + 2; 
0474   06B4 FA FF FF      lea d, [bp + -1] ; $p
0475   06B7 DA            push d
0476   06B8 FA FF FF      lea d, [bp + -1] ; $p
0477   06BB 2A            mov b, [d]
0478   06BC             ; START TERMS
0479   06BC D7            push a
0480   06BD 11            mov a, b
0481   06BE 26 02 00      mov b, $2
0482   06C1 54            add a, b
0483   06C2 27            mov b, a
0484   06C3 E4            pop a
0485   06C4             ; END TERMS
0486   06C4 E7            pop d
0487   06C5 FD 43         mov [d], b
0488   06C7             ;; break; 
0489   06C7 0A 45 07      jmp _switch8_exit ; case break
0490   06CA             _switch8_case3:
0491   06CA             ;; printx16(*(unsigned int*)p); 
0492   06CA FA FF FF      lea d, [bp + -1] ; $p
0493   06CD 2A            mov b, [d]
0494   06CE 74            mov d, b
0495   06CF 2A            mov b, [d]
0496   06D0 FD AB         swp b
0497   06D2 D8            push b
0498   06D3 07 7A 07      call printx16
0499   06D6 51 02 00      add sp, 2
0500   06D9             ;; p = p + 2; 
0501   06D9 FA FF FF      lea d, [bp + -1] ; $p
0502   06DC DA            push d
0503   06DD FA FF FF      lea d, [bp + -1] ; $p
0504   06E0 2A            mov b, [d]
0505   06E1             ; START TERMS
0506   06E1 D7            push a
0507   06E2 11            mov a, b
0508   06E3 26 02 00      mov b, $2
0509   06E6 54            add a, b
0510   06E7 27            mov b, a
0511   06E8 E4            pop a
0512   06E9             ; END TERMS
0513   06E9 E7            pop d
0514   06EA FD 43         mov [d], b
0515   06EC             ;; break; 
0516   06EC 0A 45 07      jmp _switch8_exit ; case break
0517   06EF             _switch8_case4:
0518   06EF             ;; putchar(*(char*)p); 
0519   06EF FA FF FF      lea d, [bp + -1] ; $p
0520   06F2 2A            mov b, [d]
0521   06F3 74            mov d, b
0522   06F4 32            mov bl, [d]
0523   06F5 A7 00         mov bh, 0
0524   06F7 DD            push bl
0525   06F8 07 EB 0B      call putchar
0526   06FB 51 01 00      add sp, 1
0527   06FE             ;; p = p + 2; 
0528   06FE FA FF FF      lea d, [bp + -1] ; $p
0529   0701 DA            push d
0530   0702 FA FF FF      lea d, [bp + -1] ; $p
0531   0705 2A            mov b, [d]
0532   0706             ; START TERMS
0533   0706 D7            push a
0534   0707 11            mov a, b
0535   0708 26 02 00      mov b, $2
0536   070B 54            add a, b
0537   070C 27            mov b, a
0538   070D E4            pop a
0539   070E             ; END TERMS
0540   070E E7            pop d
0541   070F FD 43         mov [d], b
0542   0711             ;; break; 
0543   0711 0A 45 07      jmp _switch8_exit ; case break
0544   0714             _switch8_case5:
0545   0714             ;; print(*(char**)p); 
0546   0714 FA FF FF      lea d, [bp + -1] ; $p
0547   0717 2A            mov b, [d]
0548   0718 74            mov d, b
0549   0719 2A            mov b, [d]
0550   071A FD AB         swp b
0551   071C D8            push b
0552   071D 07 33 0C      call print
0553   0720 51 02 00      add sp, 2
0554   0723             ;; p = p + 2; 
0555   0723 FA FF FF      lea d, [bp + -1] ; $p
0556   0726 DA            push d
0557   0727 FA FF FF      lea d, [bp + -1] ; $p
0558   072A 2A            mov b, [d]
0559   072B             ; START TERMS
0560   072B D7            push a
0561   072C 11            mov a, b
0562   072D 26 02 00      mov b, $2
0563   0730 54            add a, b
0564   0731 27            mov b, a
0565   0732 E4            pop a
0566   0733             ; END TERMS
0567   0733 E7            pop d
0568   0734 FD 43         mov [d], b
0569   0736             ;; break; 
0570   0736 0A 45 07      jmp _switch8_exit ; case break
0571   0739             _switch8_default:
0572   0739             ;; print("Error: Unknown argument type.\n"); 
0573   0739 26 20 11      mov b, __s2 ; "Error: Unknown argument type.\n"
0574   073C FD AB         swp b
0575   073E D8            push b
0576   073F 07 33 0C      call print
0577   0742 51 02 00      add sp, 2
0578   0745             _switch8_exit:
0579   0745             ;; fp++; 
0580   0745 FA FD FF      lea d, [bp + -3] ; $fp
0581   0748 2A            mov b, [d]
0582   0749 FD 79         mov g, b
0583   074B FD 77         inc b
0584   074D FA FD FF      lea d, [bp + -3] ; $fp
0585   0750 FD 43         mov [d], b
0586   0752 FD 27         mov b, g
0587   0754 0A 75 07      jmp _if7_exit
0588   0757             _if7_else:
0589   0757             ;; putchar(*fp); 
0590   0757 FA FD FF      lea d, [bp + -3] ; $fp
0591   075A 2A            mov b, [d]
0592   075B 74            mov d, b
0593   075C 32            mov bl, [d]
0594   075D A7 00         mov bh, 0
0595   075F DD            push bl
0596   0760 07 EB 0B      call putchar
0597   0763 51 01 00      add sp, 1
0598   0766             ;; fp++; 
0599   0766 FA FD FF      lea d, [bp + -3] ; $fp
0600   0769 2A            mov b, [d]
0601   076A FD 79         mov g, b
0602   076C FD 77         inc b
0603   076E FA FD FF      lea d, [bp + -3] ; $fp
0604   0771 FD 43         mov [d], b
0605   0773 FD 27         mov b, g
0606   0775             _if7_exit:
0607   0775             _if6_exit:
0608   0775             _for5_update:
0609   0775 0A 15 06      jmp _for5_cond
0610   0778             _for5_exit:
0611   0778 F9            leave
0612   0779 09            ret
0613   077A             
0614   077A             printx16:
0615   077A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0616   077D             
0617   077D             ; --- BEGIN INLINE ASM BLOCK
0618   077D FA 05 00      lea d, [bp + 5] ; $hex
0619   0780 2A            mov b, [d]
0620   0781 07 0A 10      call print_u16x
0621   0784             ; --- END INLINE ASM BLOCK
0622   0784             
0623   0784 F9            leave
0624   0785 09            ret
0625   0786             
0626   0786             printx8:
0627   0786 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0628   0789             
0629   0789             ; --- BEGIN INLINE ASM BLOCK
0630   0789 FA 05 00      lea d, [bp + 5] ; $hex
0631   078C 32            mov bl, [d]
0632   078D 07 4E 10      call print_u8x
0633   0790             ; --- END INLINE ASM BLOCK
0634   0790             
0635   0790 F9            leave
0636   0791 09            ret
0637   0792             
0638   0792             hex_to_int:
0639   0792 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0640   0795             ; $value 
0641   0795 10 00 00      mov a, $0
0642   0798 45 FF FF      mov [bp + -1], a
0643   079B             ; $i 
0644   079B             ; $hex_char 
0645   079B             ; $len 
0646   079B 52 07 00      sub sp, 7
0647   079E             ;; len = strlen(hex_string); 
0648   079E FA FA FF      lea d, [bp + -6] ; $len
0649   07A1 DA            push d
0650   07A2 FA 05 00      lea d, [bp + 5] ; $hex_string
0651   07A5 2A            mov b, [d]
0652   07A6 FD AB         swp b
0653   07A8 D8            push b
0654   07A9 07 A6 05      call strlen
0655   07AC 51 02 00      add sp, 2
0656   07AF E7            pop d
0657   07B0 FD 43         mov [d], b
0658   07B2             ;; for (i = 0; i < len; i++) { 
0659   07B2             _for9_init:
0660   07B2 FA FD FF      lea d, [bp + -3] ; $i
0661   07B5 DA            push d
0662   07B6 26 00 00      mov b, $0
0663   07B9 E7            pop d
0664   07BA FD 43         mov [d], b
0665   07BC             _for9_cond:
0666   07BC FA FD FF      lea d, [bp + -3] ; $i
0667   07BF 2A            mov b, [d]
0668   07C0             ; START RELATIONAL
0669   07C0 D7            push a
0670   07C1 11            mov a, b
0671   07C2 FA FA FF      lea d, [bp + -6] ; $len
0672   07C5 2A            mov b, [d]
0673   07C6 B0            cmp a, b
0674   07C7 FD 73         slt ; < 
0675   07C9 E4            pop a
0676   07CA             ; END RELATIONAL
0677   07CA C0 00 00      cmp b, 0
0678   07CD C6 D2 08      je _for9_exit
0679   07D0             _for9_block:
0680   07D0             ;; hex_char = hex_string[i]; 
0681   07D0 FA FC FF      lea d, [bp + -4] ; $hex_char
0682   07D3 DA            push d
0683   07D4 FA 05 00      lea d, [bp + 5] ; $hex_string
0684   07D7 FD 2A         mov d, [d]
0685   07D9 D7            push a
0686   07DA DA            push d
0687   07DB FA FD FF      lea d, [bp + -3] ; $i
0688   07DE 2A            mov b, [d]
0689   07DF E7            pop d
0690   07E0 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0691   07E4 E4            pop a
0692   07E5 32            mov bl, [d]
0693   07E6 A7 00         mov bh, 0
0694   07E8 E7            pop d
0695   07E9 FD 3E         mov [d], bl
0696   07EB             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0697   07EB             _if10_cond:
0698   07EB FA FC FF      lea d, [bp + -4] ; $hex_char
0699   07EE 32            mov bl, [d]
0700   07EF A7 00         mov bh, 0
0701   07F1             ; START RELATIONAL
0702   07F1 D7            push a
0703   07F2 11            mov a, b
0704   07F3 26 61 00      mov b, $61
0705   07F6 B0            cmp a, b
0706   07F7 FD 80         sge ; >=
0707   07F9 E4            pop a
0708   07FA             ; END RELATIONAL
0709   07FA D7            push a
0710   07FB 11            mov a, b
0711   07FC FA FC FF      lea d, [bp + -4] ; $hex_char
0712   07FF 32            mov bl, [d]
0713   0800 A7 00         mov bh, 0
0714   0802             ; START RELATIONAL
0715   0802 D7            push a
0716   0803 11            mov a, b
0717   0804 26 66 00      mov b, $66
0718   0807 B0            cmp a, b
0719   0808 FD 74         sle ; <=
0720   080A E4            pop a
0721   080B             ; END RELATIONAL
0722   080B FD A7         sand a, b ; &&
0723   080D E4            pop a
0724   080E C0 00 00      cmp b, 0
0725   0811 C6 42 08      je _if10_else
0726   0814             _if10_true:
0727   0814             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0728   0814 FA FF FF      lea d, [bp + -1] ; $value
0729   0817 DA            push d
0730   0818 FA FF FF      lea d, [bp + -1] ; $value
0731   081B 2A            mov b, [d]
0732   081C             ; START FACTORS
0733   081C D7            push a
0734   081D 11            mov a, b
0735   081E 26 10 00      mov b, $10
0736   0821 AC            mul a, b ; *
0737   0822 11            mov a, b
0738   0823 27            mov b, a
0739   0824 E4            pop a
0740   0825             ; END FACTORS
0741   0825             ; START TERMS
0742   0825 D7            push a
0743   0826 11            mov a, b
0744   0827 FA FC FF      lea d, [bp + -4] ; $hex_char
0745   082A 32            mov bl, [d]
0746   082B A7 00         mov bh, 0
0747   082D             ; START TERMS
0748   082D D7            push a
0749   082E 11            mov a, b
0750   082F 26 61 00      mov b, $61
0751   0832 60            sub a, b
0752   0833 26 0A 00      mov b, $a
0753   0836 54            add a, b
0754   0837 27            mov b, a
0755   0838 E4            pop a
0756   0839             ; END TERMS
0757   0839 54            add a, b
0758   083A 27            mov b, a
0759   083B E4            pop a
0760   083C             ; END TERMS
0761   083C E7            pop d
0762   083D FD 43         mov [d], b
0763   083F 0A C0 08      jmp _if10_exit
0764   0842             _if10_else:
0765   0842             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0766   0842             _if11_cond:
0767   0842 FA FC FF      lea d, [bp + -4] ; $hex_char
0768   0845 32            mov bl, [d]
0769   0846 A7 00         mov bh, 0
0770   0848             ; START RELATIONAL
0771   0848 D7            push a
0772   0849 11            mov a, b
0773   084A 26 41 00      mov b, $41
0774   084D B0            cmp a, b
0775   084E FD 80         sge ; >=
0776   0850 E4            pop a
0777   0851             ; END RELATIONAL
0778   0851 D7            push a
0779   0852 11            mov a, b
0780   0853 FA FC FF      lea d, [bp + -4] ; $hex_char
0781   0856 32            mov bl, [d]
0782   0857 A7 00         mov bh, 0
0783   0859             ; START RELATIONAL
0784   0859 D7            push a
0785   085A 11            mov a, b
0786   085B 26 46 00      mov b, $46
0787   085E B0            cmp a, b
0788   085F FD 74         sle ; <=
0789   0861 E4            pop a
0790   0862             ; END RELATIONAL
0791   0862 FD A7         sand a, b ; &&
0792   0864 E4            pop a
0793   0865 C0 00 00      cmp b, 0
0794   0868 C6 99 08      je _if11_else
0795   086B             _if11_true:
0796   086B             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0797   086B FA FF FF      lea d, [bp + -1] ; $value
0798   086E DA            push d
0799   086F FA FF FF      lea d, [bp + -1] ; $value
0800   0872 2A            mov b, [d]
0801   0873             ; START FACTORS
0802   0873 D7            push a
0803   0874 11            mov a, b
0804   0875 26 10 00      mov b, $10
0805   0878 AC            mul a, b ; *
0806   0879 11            mov a, b
0807   087A 27            mov b, a
0808   087B E4            pop a
0809   087C             ; END FACTORS
0810   087C             ; START TERMS
0811   087C D7            push a
0812   087D 11            mov a, b
0813   087E FA FC FF      lea d, [bp + -4] ; $hex_char
0814   0881 32            mov bl, [d]
0815   0882 A7 00         mov bh, 0
0816   0884             ; START TERMS
0817   0884 D7            push a
0818   0885 11            mov a, b
0819   0886 26 41 00      mov b, $41
0820   0889 60            sub a, b
0821   088A 26 0A 00      mov b, $a
0822   088D 54            add a, b
0823   088E 27            mov b, a
0824   088F E4            pop a
0825   0890             ; END TERMS
0826   0890 54            add a, b
0827   0891 27            mov b, a
0828   0892 E4            pop a
0829   0893             ; END TERMS
0830   0893 E7            pop d
0831   0894 FD 43         mov [d], b
0832   0896 0A C0 08      jmp _if11_exit
0833   0899             _if11_else:
0834   0899             ;; value = (value * 16) + (hex_char - '0'); 
0835   0899 FA FF FF      lea d, [bp + -1] ; $value
0836   089C DA            push d
0837   089D FA FF FF      lea d, [bp + -1] ; $value
0838   08A0 2A            mov b, [d]
0839   08A1             ; START FACTORS
0840   08A1 D7            push a
0841   08A2 11            mov a, b
0842   08A3 26 10 00      mov b, $10
0843   08A6 AC            mul a, b ; *
0844   08A7 11            mov a, b
0845   08A8 27            mov b, a
0846   08A9 E4            pop a
0847   08AA             ; END FACTORS
0848   08AA             ; START TERMS
0849   08AA D7            push a
0850   08AB 11            mov a, b
0851   08AC FA FC FF      lea d, [bp + -4] ; $hex_char
0852   08AF 32            mov bl, [d]
0853   08B0 A7 00         mov bh, 0
0854   08B2             ; START TERMS
0855   08B2 D7            push a
0856   08B3 11            mov a, b
0857   08B4 26 30 00      mov b, $30
0858   08B7 60            sub a, b
0859   08B8 27            mov b, a
0860   08B9 E4            pop a
0861   08BA             ; END TERMS
0862   08BA 54            add a, b
0863   08BB 27            mov b, a
0864   08BC E4            pop a
0865   08BD             ; END TERMS
0866   08BD E7            pop d
0867   08BE FD 43         mov [d], b
0868   08C0             _if11_exit:
0869   08C0             _if10_exit:
0870   08C0             _for9_update:
0871   08C0 FA FD FF      lea d, [bp + -3] ; $i
0872   08C3 2A            mov b, [d]
0873   08C4 FD 79         mov g, b
0874   08C6 FD 77         inc b
0875   08C8 FA FD FF      lea d, [bp + -3] ; $i
0876   08CB FD 43         mov [d], b
0877   08CD FD 27         mov b, g
0878   08CF 0A BC 07      jmp _for9_cond
0879   08D2             _for9_exit:
0880   08D2             ;; return value; 
0881   08D2 FA FF FF      lea d, [bp + -1] ; $value
0882   08D5 2A            mov b, [d]
0883   08D6 F9            leave
0884   08D7 09            ret
0885   08D8             
0886   08D8             atoi:
0887   08D8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0888   08DB             ; $result 
0889   08DB 10 00 00      mov a, $0
0890   08DE 45 FF FF      mov [bp + -1], a
0891   08E1             ; $sign 
0892   08E1 10 01 00      mov a, $1
0893   08E4 45 FD FF      mov [bp + -3], a
0894   08E7 52 04 00      sub sp, 4
0895   08EA             ;; while (*str == ' ') str++; 
0896   08EA             _while12_cond:
0897   08EA FA 05 00      lea d, [bp + 5] ; $str
0898   08ED 2A            mov b, [d]
0899   08EE 74            mov d, b
0900   08EF 32            mov bl, [d]
0901   08F0 A7 00         mov bh, 0
0902   08F2             ; START RELATIONAL
0903   08F2 D7            push a
0904   08F3 11            mov a, b
0905   08F4 26 20 00      mov b, $20
0906   08F7 B0            cmp a, b
0907   08F8 FD 71         seq ; ==
0908   08FA E4            pop a
0909   08FB             ; END RELATIONAL
0910   08FB C0 00 00      cmp b, 0
0911   08FE C6 13 09      je _while12_exit
0912   0901             _while12_block:
0913   0901             ;; str++; 
0914   0901 FA 05 00      lea d, [bp + 5] ; $str
0915   0904 2A            mov b, [d]
0916   0905 FD 79         mov g, b
0917   0907 FD 77         inc b
0918   0909 FA 05 00      lea d, [bp + 5] ; $str
0919   090C FD 43         mov [d], b
0920   090E FD 27         mov b, g
0921   0910 0A EA 08      jmp _while12_cond
0922   0913             _while12_exit:
0923   0913             ;; if (*str == '-' || *str == '+') { 
0924   0913             _if13_cond:
0925   0913 FA 05 00      lea d, [bp + 5] ; $str
0926   0916 2A            mov b, [d]
0927   0917 74            mov d, b
0928   0918 32            mov bl, [d]
0929   0919 A7 00         mov bh, 0
0930   091B             ; START RELATIONAL
0931   091B D7            push a
0932   091C 11            mov a, b
0933   091D 26 2D 00      mov b, $2d
0934   0920 B0            cmp a, b
0935   0921 FD 71         seq ; ==
0936   0923 E4            pop a
0937   0924             ; END RELATIONAL
0938   0924 D7            push a
0939   0925 11            mov a, b
0940   0926 FA 05 00      lea d, [bp + 5] ; $str
0941   0929 2A            mov b, [d]
0942   092A 74            mov d, b
0943   092B 32            mov bl, [d]
0944   092C A7 00         mov bh, 0
0945   092E             ; START RELATIONAL
0946   092E D7            push a
0947   092F 11            mov a, b
0948   0930 26 2B 00      mov b, $2b
0949   0933 B0            cmp a, b
0950   0934 FD 71         seq ; ==
0951   0936 E4            pop a
0952   0937             ; END RELATIONAL
0953   0937 FD A8         sor a, b ; ||
0954   0939 E4            pop a
0955   093A C0 00 00      cmp b, 0
0956   093D C6 78 09      je _if13_exit
0957   0940             _if13_true:
0958   0940             ;; if (*str == '-') sign = -1; 
0959   0940             _if14_cond:
0960   0940 FA 05 00      lea d, [bp + 5] ; $str
0961   0943 2A            mov b, [d]
0962   0944 74            mov d, b
0963   0945 32            mov bl, [d]
0964   0946 A7 00         mov bh, 0
0965   0948             ; START RELATIONAL
0966   0948 D7            push a
0967   0949 11            mov a, b
0968   094A 26 2D 00      mov b, $2d
0969   094D B0            cmp a, b
0970   094E FD 71         seq ; ==
0971   0950 E4            pop a
0972   0951             ; END RELATIONAL
0973   0951 C0 00 00      cmp b, 0
0974   0954 C6 66 09      je _if14_exit
0975   0957             _if14_true:
0976   0957             ;; sign = -1; 
0977   0957 FA FD FF      lea d, [bp + -3] ; $sign
0978   095A DA            push d
0979   095B 26 01 00      mov b, $1
0980   095E FD 97         neg b
0981   0960 E7            pop d
0982   0961 FD 43         mov [d], b
0983   0963 0A 66 09      jmp _if14_exit
0984   0966             _if14_exit:
0985   0966             ;; str++; 
0986   0966 FA 05 00      lea d, [bp + 5] ; $str
0987   0969 2A            mov b, [d]
0988   096A FD 79         mov g, b
0989   096C FD 77         inc b
0990   096E FA 05 00      lea d, [bp + 5] ; $str
0991   0971 FD 43         mov [d], b
0992   0973 FD 27         mov b, g
0993   0975 0A 78 09      jmp _if13_exit
0994   0978             _if13_exit:
0995   0978             ;; while (*str >= '0' && *str <= '9') { 
0996   0978             _while15_cond:
0997   0978 FA 05 00      lea d, [bp + 5] ; $str
0998   097B 2A            mov b, [d]
0999   097C 74            mov d, b
1000   097D 32            mov bl, [d]
1001   097E A7 00         mov bh, 0
1002   0980             ; START RELATIONAL
1003   0980 D7            push a
1004   0981 11            mov a, b
1005   0982 26 30 00      mov b, $30
1006   0985 B0            cmp a, b
1007   0986 FD 80         sge ; >=
1008   0988 E4            pop a
1009   0989             ; END RELATIONAL
1010   0989 D7            push a
1011   098A 11            mov a, b
1012   098B FA 05 00      lea d, [bp + 5] ; $str
1013   098E 2A            mov b, [d]
1014   098F 74            mov d, b
1015   0990 32            mov bl, [d]
1016   0991 A7 00         mov bh, 0
1017   0993             ; START RELATIONAL
1018   0993 D7            push a
1019   0994 11            mov a, b
1020   0995 26 39 00      mov b, $39
1021   0998 B0            cmp a, b
1022   0999 FD 74         sle ; <=
1023   099B E4            pop a
1024   099C             ; END RELATIONAL
1025   099C FD A7         sand a, b ; &&
1026   099E E4            pop a
1027   099F C0 00 00      cmp b, 0
1028   09A2 C6 E0 09      je _while15_exit
1029   09A5             _while15_block:
1030   09A5             ;; result = result * 10 + (*str - '0'); 
1031   09A5 FA FF FF      lea d, [bp + -1] ; $result
1032   09A8 DA            push d
1033   09A9 FA FF FF      lea d, [bp + -1] ; $result
1034   09AC 2A            mov b, [d]
1035   09AD             ; START FACTORS
1036   09AD D7            push a
1037   09AE 11            mov a, b
1038   09AF 26 0A 00      mov b, $a
1039   09B2 AC            mul a, b ; *
1040   09B3 11            mov a, b
1041   09B4 27            mov b, a
1042   09B5 E4            pop a
1043   09B6             ; END FACTORS
1044   09B6             ; START TERMS
1045   09B6 D7            push a
1046   09B7 11            mov a, b
1047   09B8 FA 05 00      lea d, [bp + 5] ; $str
1048   09BB 2A            mov b, [d]
1049   09BC 74            mov d, b
1050   09BD 32            mov bl, [d]
1051   09BE A7 00         mov bh, 0
1052   09C0             ; START TERMS
1053   09C0 D7            push a
1054   09C1 11            mov a, b
1055   09C2 26 30 00      mov b, $30
1056   09C5 60            sub a, b
1057   09C6 27            mov b, a
1058   09C7 E4            pop a
1059   09C8             ; END TERMS
1060   09C8 54            add a, b
1061   09C9 27            mov b, a
1062   09CA E4            pop a
1063   09CB             ; END TERMS
1064   09CB E7            pop d
1065   09CC FD 43         mov [d], b
1066   09CE             ;; str++; 
1067   09CE FA 05 00      lea d, [bp + 5] ; $str
1068   09D1 2A            mov b, [d]
1069   09D2 FD 79         mov g, b
1070   09D4 FD 77         inc b
1071   09D6 FA 05 00      lea d, [bp + 5] ; $str
1072   09D9 FD 43         mov [d], b
1073   09DB FD 27         mov b, g
1074   09DD 0A 78 09      jmp _while15_cond
1075   09E0             _while15_exit:
1076   09E0             ;; return sign * result; 
1077   09E0 FA FD FF      lea d, [bp + -3] ; $sign
1078   09E3 2A            mov b, [d]
1079   09E4             ; START FACTORS
1080   09E4 D7            push a
1081   09E5 11            mov a, b
1082   09E6 FA FF FF      lea d, [bp + -1] ; $result
1083   09E9 2A            mov b, [d]
1084   09EA AC            mul a, b ; *
1085   09EB 11            mov a, b
1086   09EC 27            mov b, a
1087   09ED E4            pop a
1088   09EE             ; END FACTORS
1089   09EE F9            leave
1090   09EF 09            ret
1091   09F0             
1092   09F0             gets:
1093   09F0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1094   09F3             
1095   09F3             ; --- BEGIN INLINE ASM BLOCK
1096   09F3 FA 05 00      lea d, [bp + 5] ; $s
1097   09F6 15            mov a, [d]
1098   09F7 3C            mov d, a
1099   09F8 07 6F 0E      call _gets
1100   09FB             ; --- END INLINE ASM BLOCK
1101   09FB             
1102   09FB             ;; return strlen(s); 
1103   09FB FA 05 00      lea d, [bp + 5] ; $s
1104   09FE 2A            mov b, [d]
1105   09FF FD AB         swp b
1106   0A01 D8            push b
1107   0A02 07 A6 05      call strlen
1108   0A05 51 02 00      add sp, 2
1109   0A08 F9            leave
1110   0A09 09            ret
1111   0A0A             
1112   0A0A             prints:
1113   0A0A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1114   0A0D             ; $digits 
1115   0A0D             ; $i 
1116   0A0D 10 00 00      mov a, $0
1117   0A10 45 FA FF      mov [bp + -6], a
1118   0A13 52 07 00      sub sp, 7
1119   0A16             ;; if (num < 0) { 
1120   0A16             _if16_cond:
1121   0A16 FA 05 00      lea d, [bp + 5] ; $num
1122   0A19 2A            mov b, [d]
1123   0A1A             ; START RELATIONAL
1124   0A1A D7            push a
1125   0A1B 11            mov a, b
1126   0A1C 26 00 00      mov b, $0
1127   0A1F B0            cmp a, b
1128   0A20 FD 73         slt ; < 
1129   0A22 E4            pop a
1130   0A23             ; END RELATIONAL
1131   0A23 C0 00 00      cmp b, 0
1132   0A26 C6 43 0A      je _if16_else
1133   0A29             _if16_true:
1134   0A29             ;; putchar('-'); 
1135   0A29 26 2D 00      mov b, $2d
1136   0A2C DD            push bl
1137   0A2D 07 EB 0B      call putchar
1138   0A30 51 01 00      add sp, 1
1139   0A33             ;; num = -num; 
1140   0A33 FA 05 00      lea d, [bp + 5] ; $num
1141   0A36 DA            push d
1142   0A37 FA 05 00      lea d, [bp + 5] ; $num
1143   0A3A 2A            mov b, [d]
1144   0A3B FD 97         neg b
1145   0A3D E7            pop d
1146   0A3E FD 43         mov [d], b
1147   0A40 0A 65 0A      jmp _if16_exit
1148   0A43             _if16_else:
1149   0A43             ;; if (num == 0) { 
1150   0A43             _if17_cond:
1151   0A43 FA 05 00      lea d, [bp + 5] ; $num
1152   0A46 2A            mov b, [d]
1153   0A47             ; START RELATIONAL
1154   0A47 D7            push a
1155   0A48 11            mov a, b
1156   0A49 26 00 00      mov b, $0
1157   0A4C B0            cmp a, b
1158   0A4D FD 71         seq ; ==
1159   0A4F E4            pop a
1160   0A50             ; END RELATIONAL
1161   0A50 C0 00 00      cmp b, 0
1162   0A53 C6 65 0A      je _if17_exit
1163   0A56             _if17_true:
1164   0A56             ;; putchar('0'); 
1165   0A56 26 30 00      mov b, $30
1166   0A59 DD            push bl
1167   0A5A 07 EB 0B      call putchar
1168   0A5D 51 01 00      add sp, 1
1169   0A60             ;; return; 
1170   0A60 F9            leave
1171   0A61 09            ret
1172   0A62 0A 65 0A      jmp _if17_exit
1173   0A65             _if17_exit:
1174   0A65             _if16_exit:
1175   0A65             ;; while (num > 0) { 
1176   0A65             _while18_cond:
1177   0A65 FA 05 00      lea d, [bp + 5] ; $num
1178   0A68 2A            mov b, [d]
1179   0A69             ; START RELATIONAL
1180   0A69 D7            push a
1181   0A6A 11            mov a, b
1182   0A6B 26 00 00      mov b, $0
1183   0A6E B0            cmp a, b
1184   0A6F FD 7F         sgt ; >
1185   0A71 E4            pop a
1186   0A72             ; END RELATIONAL
1187   0A72 C0 00 00      cmp b, 0
1188   0A75 C6 C2 0A      je _while18_exit
1189   0A78             _while18_block:
1190   0A78             ;; digits[i] = '0' + (num % 10); 
1191   0A78 FA FC FF      lea d, [bp + -4] ; $digits
1192   0A7B D7            push a
1193   0A7C DA            push d
1194   0A7D FA FA FF      lea d, [bp + -6] ; $i
1195   0A80 2A            mov b, [d]
1196   0A81 E7            pop d
1197   0A82 5A            add d, b
1198   0A83 E4            pop a
1199   0A84 DA            push d
1200   0A85 26 30 00      mov b, $30
1201   0A88             ; START TERMS
1202   0A88 D7            push a
1203   0A89 11            mov a, b
1204   0A8A FA 05 00      lea d, [bp + 5] ; $num
1205   0A8D 2A            mov b, [d]
1206   0A8E             ; START FACTORS
1207   0A8E D7            push a
1208   0A8F 11            mov a, b
1209   0A90 26 0A 00      mov b, $a
1210   0A93 AE            div a, b ; 
1211   0A94 11            mov a, b
1212   0A95 27            mov b, a
1213   0A96 E4            pop a
1214   0A97             ; END FACTORS
1215   0A97 54            add a, b
1216   0A98 27            mov b, a
1217   0A99 E4            pop a
1218   0A9A             ; END TERMS
1219   0A9A E7            pop d
1220   0A9B FD 3E         mov [d], bl
1221   0A9D             ;; num = num / 10; 
1222   0A9D FA 05 00      lea d, [bp + 5] ; $num
1223   0AA0 DA            push d
1224   0AA1 FA 05 00      lea d, [bp + 5] ; $num
1225   0AA4 2A            mov b, [d]
1226   0AA5             ; START FACTORS
1227   0AA5 D7            push a
1228   0AA6 11            mov a, b
1229   0AA7 26 0A 00      mov b, $a
1230   0AAA AE            div a, b
1231   0AAB 27            mov b, a
1232   0AAC E4            pop a
1233   0AAD             ; END FACTORS
1234   0AAD E7            pop d
1235   0AAE FD 43         mov [d], b
1236   0AB0             ;; i++; 
1237   0AB0 FA FA FF      lea d, [bp + -6] ; $i
1238   0AB3 2A            mov b, [d]
1239   0AB4 FD 79         mov g, b
1240   0AB6 FD 77         inc b
1241   0AB8 FA FA FF      lea d, [bp + -6] ; $i
1242   0ABB FD 43         mov [d], b
1243   0ABD FD 27         mov b, g
1244   0ABF 0A 65 0A      jmp _while18_cond
1245   0AC2             _while18_exit:
1246   0AC2             ;; while (i > 0) { 
1247   0AC2             _while19_cond:
1248   0AC2 FA FA FF      lea d, [bp + -6] ; $i
1249   0AC5 2A            mov b, [d]
1250   0AC6             ; START RELATIONAL
1251   0AC6 D7            push a
1252   0AC7 11            mov a, b
1253   0AC8 26 00 00      mov b, $0
1254   0ACB B0            cmp a, b
1255   0ACC FD 7F         sgt ; >
1256   0ACE E4            pop a
1257   0ACF             ; END RELATIONAL
1258   0ACF C0 00 00      cmp b, 0
1259   0AD2 C6 FD 0A      je _while19_exit
1260   0AD5             _while19_block:
1261   0AD5             ;; i--; 
1262   0AD5 FA FA FF      lea d, [bp + -6] ; $i
1263   0AD8 2A            mov b, [d]
1264   0AD9 FD 79         mov g, b
1265   0ADB FD 7D         dec b
1266   0ADD FA FA FF      lea d, [bp + -6] ; $i
1267   0AE0 FD 43         mov [d], b
1268   0AE2 FD 27         mov b, g
1269   0AE4             ;; putchar(digits[i]); 
1270   0AE4 FA FC FF      lea d, [bp + -4] ; $digits
1271   0AE7 D7            push a
1272   0AE8 DA            push d
1273   0AE9 FA FA FF      lea d, [bp + -6] ; $i
1274   0AEC 2A            mov b, [d]
1275   0AED E7            pop d
1276   0AEE 5A            add d, b
1277   0AEF E4            pop a
1278   0AF0 32            mov bl, [d]
1279   0AF1 A7 00         mov bh, 0
1280   0AF3 DD            push bl
1281   0AF4 07 EB 0B      call putchar
1282   0AF7 51 01 00      add sp, 1
1283   0AFA 0A C2 0A      jmp _while19_cond
1284   0AFD             _while19_exit:
1285   0AFD F9            leave
1286   0AFE 09            ret
1287   0AFF             
1288   0AFF             printu:
1289   0AFF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1290   0B02             ; $digits 
1291   0B02             ; $i 
1292   0B02 52 07 00      sub sp, 7
1293   0B05             ;; i = 0; 
1294   0B05 FA FA FF      lea d, [bp + -6] ; $i
1295   0B08 DA            push d
1296   0B09 26 00 00      mov b, $0
1297   0B0C E7            pop d
1298   0B0D FD 43         mov [d], b
1299   0B0F             ;; if(num == 0){ 
1300   0B0F             _if20_cond:
1301   0B0F FA 05 00      lea d, [bp + 5] ; $num
1302   0B12 2A            mov b, [d]
1303   0B13             ; START RELATIONAL
1304   0B13 D7            push a
1305   0B14 11            mov a, b
1306   0B15 26 00 00      mov b, $0
1307   0B18 B0            cmp a, b
1308   0B19 FD 71         seq ; ==
1309   0B1B E4            pop a
1310   0B1C             ; END RELATIONAL
1311   0B1C C0 00 00      cmp b, 0
1312   0B1F C6 31 0B      je _if20_exit
1313   0B22             _if20_true:
1314   0B22             ;; putchar('0'); 
1315   0B22 26 30 00      mov b, $30
1316   0B25 DD            push bl
1317   0B26 07 EB 0B      call putchar
1318   0B29 51 01 00      add sp, 1
1319   0B2C             ;; return; 
1320   0B2C F9            leave
1321   0B2D 09            ret
1322   0B2E 0A 31 0B      jmp _if20_exit
1323   0B31             _if20_exit:
1324   0B31             ;; while (num > 0) { 
1325   0B31             _while21_cond:
1326   0B31 FA 05 00      lea d, [bp + 5] ; $num
1327   0B34 2A            mov b, [d]
1328   0B35             ; START RELATIONAL
1329   0B35 D7            push a
1330   0B36 11            mov a, b
1331   0B37 26 00 00      mov b, $0
1332   0B3A B0            cmp a, b
1333   0B3B FD 81         sgu ; > (unsigned)
1334   0B3D E4            pop a
1335   0B3E             ; END RELATIONAL
1336   0B3E C0 00 00      cmp b, 0
1337   0B41 C6 8E 0B      je _while21_exit
1338   0B44             _while21_block:
1339   0B44             ;; digits[i] = '0' + (num % 10); 
1340   0B44 FA FC FF      lea d, [bp + -4] ; $digits
1341   0B47 D7            push a
1342   0B48 DA            push d
1343   0B49 FA FA FF      lea d, [bp + -6] ; $i
1344   0B4C 2A            mov b, [d]
1345   0B4D E7            pop d
1346   0B4E 5A            add d, b
1347   0B4F E4            pop a
1348   0B50 DA            push d
1349   0B51 26 30 00      mov b, $30
1350   0B54             ; START TERMS
1351   0B54 D7            push a
1352   0B55 11            mov a, b
1353   0B56 FA 05 00      lea d, [bp + 5] ; $num
1354   0B59 2A            mov b, [d]
1355   0B5A             ; START FACTORS
1356   0B5A D7            push a
1357   0B5B 11            mov a, b
1358   0B5C 26 0A 00      mov b, $a
1359   0B5F AE            div a, b ; 
1360   0B60 11            mov a, b
1361   0B61 27            mov b, a
1362   0B62 E4            pop a
1363   0B63             ; END FACTORS
1364   0B63 54            add a, b
1365   0B64 27            mov b, a
1366   0B65 E4            pop a
1367   0B66             ; END TERMS
1368   0B66 E7            pop d
1369   0B67 FD 3E         mov [d], bl
1370   0B69             ;; num = num / 10; 
1371   0B69 FA 05 00      lea d, [bp + 5] ; $num
1372   0B6C DA            push d
1373   0B6D FA 05 00      lea d, [bp + 5] ; $num
1374   0B70 2A            mov b, [d]
1375   0B71             ; START FACTORS
1376   0B71 D7            push a
1377   0B72 11            mov a, b
1378   0B73 26 0A 00      mov b, $a
1379   0B76 AE            div a, b
1380   0B77 27            mov b, a
1381   0B78 E4            pop a
1382   0B79             ; END FACTORS
1383   0B79 E7            pop d
1384   0B7A FD 43         mov [d], b
1385   0B7C             ;; i++; 
1386   0B7C FA FA FF      lea d, [bp + -6] ; $i
1387   0B7F 2A            mov b, [d]
1388   0B80 FD 79         mov g, b
1389   0B82 FD 77         inc b
1390   0B84 FA FA FF      lea d, [bp + -6] ; $i
1391   0B87 FD 43         mov [d], b
1392   0B89 FD 27         mov b, g
1393   0B8B 0A 31 0B      jmp _while21_cond
1394   0B8E             _while21_exit:
1395   0B8E             ;; while (i > 0) { 
1396   0B8E             _while22_cond:
1397   0B8E FA FA FF      lea d, [bp + -6] ; $i
1398   0B91 2A            mov b, [d]
1399   0B92             ; START RELATIONAL
1400   0B92 D7            push a
1401   0B93 11            mov a, b
1402   0B94 26 00 00      mov b, $0
1403   0B97 B0            cmp a, b
1404   0B98 FD 7F         sgt ; >
1405   0B9A E4            pop a
1406   0B9B             ; END RELATIONAL
1407   0B9B C0 00 00      cmp b, 0
1408   0B9E C6 C9 0B      je _while22_exit
1409   0BA1             _while22_block:
1410   0BA1             ;; i--; 
1411   0BA1 FA FA FF      lea d, [bp + -6] ; $i
1412   0BA4 2A            mov b, [d]
1413   0BA5 FD 79         mov g, b
1414   0BA7 FD 7D         dec b
1415   0BA9 FA FA FF      lea d, [bp + -6] ; $i
1416   0BAC FD 43         mov [d], b
1417   0BAE FD 27         mov b, g
1418   0BB0             ;; putchar(digits[i]); 
1419   0BB0 FA FC FF      lea d, [bp + -4] ; $digits
1420   0BB3 D7            push a
1421   0BB4 DA            push d
1422   0BB5 FA FA FF      lea d, [bp + -6] ; $i
1423   0BB8 2A            mov b, [d]
1424   0BB9 E7            pop d
1425   0BBA 5A            add d, b
1426   0BBB E4            pop a
1427   0BBC 32            mov bl, [d]
1428   0BBD A7 00         mov bh, 0
1429   0BBF DD            push bl
1430   0BC0 07 EB 0B      call putchar
1431   0BC3 51 01 00      add sp, 1
1432   0BC6 0A 8E 0B      jmp _while22_cond
1433   0BC9             _while22_exit:
1434   0BC9 F9            leave
1435   0BCA 09            ret
1436   0BCB             
1437   0BCB             rand:
1438   0BCB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1439   0BCE             ; $sec 
1440   0BCE 52 01 00      sub sp, 1
1441   0BD1             
1442   0BD1             ; --- BEGIN INLINE ASM BLOCK
1443   0BD1 19 00         mov al, 0
1444   0BD3 05 01         syscall sys_rtc					
1445   0BD5 1A            mov al, ah
1446   0BD6 FA 00 00      lea d, [bp + 0] ; $sec
1447   0BD9 1E            mov al, [d]
1448   0BDA             ; --- END INLINE ASM BLOCK
1449   0BDA             
1450   0BDA             ;; return sec; 
1451   0BDA FA 00 00      lea d, [bp + 0] ; $sec
1452   0BDD 32            mov bl, [d]
1453   0BDE A7 00         mov bh, 0
1454   0BE0 F9            leave
1455   0BE1 09            ret
1456   0BE2             
1457   0BE2             date:
1458   0BE2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1459   0BE5             
1460   0BE5             ; --- BEGIN INLINE ASM BLOCK
1461   0BE5 19 00         mov al, 0 
1462   0BE7 05 07         syscall sys_datetime
1463   0BE9             ; --- END INLINE ASM BLOCK
1464   0BE9             
1465   0BE9 F9            leave
1466   0BEA 09            ret
1467   0BEB             
1468   0BEB             putchar:
1469   0BEB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1470   0BEE             
1471   0BEE             ; --- BEGIN INLINE ASM BLOCK
1472   0BEE FA 05 00      lea d, [bp + 5] ; $c
1473   0BF1 1E            mov al, [d]
1474   0BF2 23            mov ah, al
1475   0BF3 07 68 0E      call _putchar
1476   0BF6             ; --- END INLINE ASM BLOCK
1477   0BF6             
1478   0BF6 F9            leave
1479   0BF7 09            ret
1480   0BF8             
1481   0BF8             getchar:
1482   0BF8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1483   0BFB             ; $c 
1484   0BFB 52 01 00      sub sp, 1
1485   0BFE             
1486   0BFE             ; --- BEGIN INLINE ASM BLOCK
1487   0BFE 07 61 0E      call getch
1488   0C01 1A            mov al, ah
1489   0C02 FA 00 00      lea d, [bp + 0] ; $c
1490   0C05 3E            mov [d], al
1491   0C06             ; --- END INLINE ASM BLOCK
1492   0C06             
1493   0C06             ;; return c; 
1494   0C06 FA 00 00      lea d, [bp + 0] ; $c
1495   0C09 32            mov bl, [d]
1496   0C0A A7 00         mov bh, 0
1497   0C0C F9            leave
1498   0C0D 09            ret
1499   0C0E             
1500   0C0E             scann:
1501   0C0E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1502   0C11             ; $m 
1503   0C11 52 02 00      sub sp, 2
1504   0C14             
1505   0C14             ; --- BEGIN INLINE ASM BLOCK
1506   0C14 07 AC 10      call scan_u16d
1507   0C17 FA FF FF      lea d, [bp + -1] ; $m
1508   0C1A 43            mov [d], a
1509   0C1B             ; --- END INLINE ASM BLOCK
1510   0C1B             
1511   0C1B             ;; return m; 
1512   0C1B FA FF FF      lea d, [bp + -1] ; $m
1513   0C1E 2A            mov b, [d]
1514   0C1F F9            leave
1515   0C20 09            ret
1516   0C21             
1517   0C21             puts:
1518   0C21 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1519   0C24             
1520   0C24             ; --- BEGIN INLINE ASM BLOCK
1521   0C24 FA 05 00      lea d, [bp + 5] ; $s
1522   0C27 15            mov a, [d]
1523   0C28 3C            mov d, a
1524   0C29 07 B2 0F      call _puts
1525   0C2C 10 00 0A      mov a, $0A00
1526   0C2F 05 03         syscall sys_io
1527   0C31             ; --- END INLINE ASM BLOCK
1528   0C31             
1529   0C31 F9            leave
1530   0C32 09            ret
1531   0C33             
1532   0C33             print:
1533   0C33 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1534   0C36             
1535   0C36             ; --- BEGIN INLINE ASM BLOCK
1536   0C36 FA 05 00      lea d, [bp + 5] ; $s
1537   0C39 FD 2A         mov d, [d]
1538   0C3B 07 B2 0F      call _puts
1539   0C3E             ; --- END INLINE ASM BLOCK
1540   0C3E             
1541   0C3E F9            leave
1542   0C3F 09            ret
1543   0C40             
1544   0C40             loadfile:
1545   0C40 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1546   0C43             
1547   0C43             ; --- BEGIN INLINE ASM BLOCK
1548   0C43 FA 05 00      lea d, [bp + 5] ; $destination
1549   0C46 15            mov a, [d]
1550   0C47 4F            mov di, a
1551   0C48 FA 07 00      lea d, [bp + 7] ; $filename
1552   0C4B FD 2A         mov d, [d]
1553   0C4D 19 14         mov al, 20
1554   0C4F 05 04         syscall sys_filesystem
1555   0C51             ; --- END INLINE ASM BLOCK
1556   0C51             
1557   0C51 F9            leave
1558   0C52 09            ret
1559   0C53             
1560   0C53             create_file:
1561   0C53 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1562   0C56 F9            leave
1563   0C57 09            ret
1564   0C58             
1565   0C58             delete_file:
1566   0C58 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1567   0C5B             
1568   0C5B             ; --- BEGIN INLINE ASM BLOCK
1569   0C5B FA 05 00      lea d, [bp + 5] ; $filename
1570   0C5E 19 0A         mov al, 10
1571   0C60 05 04         syscall sys_filesystem
1572   0C62             ; --- END INLINE ASM BLOCK
1573   0C62             
1574   0C62 F9            leave
1575   0C63 09            ret
1576   0C64             
1577   0C64             fopen:
1578   0C64 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1579   0C67 F9            leave
1580   0C68 09            ret
1581   0C69             
1582   0C69             fclose:
1583   0C69 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1584   0C6C F9            leave
1585   0C6D 09            ret
1586   0C6E             
1587   0C6E             alloc:
1588   0C6E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1589   0C71             ;; heap_top = heap_top + bytes; 
1590   0C71 3B 49 11      mov d, _heap_top ; $heap_top
1591   0C74 DA            push d
1592   0C75 3B 49 11      mov d, _heap_top ; $heap_top
1593   0C78 2A            mov b, [d]
1594   0C79             ; START TERMS
1595   0C79 D7            push a
1596   0C7A 11            mov a, b
1597   0C7B FA 05 00      lea d, [bp + 5] ; $bytes
1598   0C7E 2A            mov b, [d]
1599   0C7F 54            add a, b
1600   0C80 27            mov b, a
1601   0C81 E4            pop a
1602   0C82             ; END TERMS
1603   0C82 E7            pop d
1604   0C83 FD 43         mov [d], b
1605   0C85             ;; return heap_top - bytes; 
1606   0C85 3B 49 11      mov d, _heap_top ; $heap_top
1607   0C88 2A            mov b, [d]
1608   0C89             ; START TERMS
1609   0C89 D7            push a
1610   0C8A 11            mov a, b
1611   0C8B FA 05 00      lea d, [bp + 5] ; $bytes
1612   0C8E 2A            mov b, [d]
1613   0C8F 60            sub a, b
1614   0C90 27            mov b, a
1615   0C91 E4            pop a
1616   0C92             ; END TERMS
1617   0C92 F9            leave
1618   0C93 09            ret
1619   0C94             
1620   0C94             free:
1621   0C94 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1622   0C97             ;; return heap_top = heap_top - bytes; 
1623   0C97 3B 49 11      mov d, _heap_top ; $heap_top
1624   0C9A DA            push d
1625   0C9B 3B 49 11      mov d, _heap_top ; $heap_top
1626   0C9E 2A            mov b, [d]
1627   0C9F             ; START TERMS
1628   0C9F D7            push a
1629   0CA0 11            mov a, b
1630   0CA1 FA 05 00      lea d, [bp + 5] ; $bytes
1631   0CA4 2A            mov b, [d]
1632   0CA5 60            sub a, b
1633   0CA6 27            mov b, a
1634   0CA7 E4            pop a
1635   0CA8             ; END TERMS
1636   0CA8 E7            pop d
1637   0CA9 FD 43         mov [d], b
1638   0CAB F9            leave
1639   0CAC 09            ret
1640   0CAD             
1641   0CAD             exit:
1642   0CAD F8 00 00      enter 0 ; (push bp; mov bp, sp)
1643   0CB0             
1644   0CB0             ; --- BEGIN INLINE ASM BLOCK
1645   0CB0 05 0B         syscall sys_terminate_proc
1646   0CB2             ; --- END INLINE ASM BLOCK
1647   0CB2             
1648   0CB2 F9            leave
1649   0CB3 09            ret
1650   0CB4             
1651   0CB4             load_hex:
1652   0CB4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1653   0CB7             ; $temp 
1654   0CB7 52 02 00      sub sp, 2
1655   0CBA             ;; temp = alloc(32768); 
1656   0CBA FA FF FF      lea d, [bp + -1] ; $temp
1657   0CBD DA            push d
1658   0CBE 26 00 80      mov b, $8000
1659   0CC1 FD AB         swp b
1660   0CC3 D8            push b
1661   0CC4 07 6E 0C      call alloc
1662   0CC7 51 02 00      add sp, 2
1663   0CCA E7            pop d
1664   0CCB FD 43         mov [d], b
1665   0CCD             
1666   0CCD             ; --- BEGIN INLINE ASM BLOCK
1667   0CCD               
1668   0CCD               
1669   0CCD               
1670   0CCD               
1671   0CCD               
1672   0CCD             _load_hex:
1673   0CCD D7            push a
1674   0CCE D8            push b
1675   0CCF DA            push d
1676   0CD0 E2            push si
1677   0CD1 E3            push di
1678   0CD2 52 00 80      sub sp, $8000      
1679   0CD5 38 00 00      mov c, 0
1680   0CD8 48            mov a, sp
1681   0CD9 77            inc a
1682   0CDA 3C            mov d, a          
1683   0CDB 07 6F 0E      call _gets        
1684   0CDE 4D            mov si, a
1685   0CDF             __load_hex_loop:
1686   0CDF F6            lodsb             
1687   0CE0 B9 00         cmp al, 0         
1688   0CE2 C6 F0 0C      jz __load_hex_ret
1689   0CE5 36            mov bh, al
1690   0CE6 F6            lodsb
1691   0CE7 2F            mov bl, al
1692   0CE8 07 25 0E      call _atoi        
1693   0CEB F7            stosb             
1694   0CEC 78            inc c
1695   0CED 0A DF 0C      jmp __load_hex_loop
1696   0CF0             __load_hex_ret:
1697   0CF0 51 00 80      add sp, $8000
1698   0CF3 F0            pop di
1699   0CF4 EF            pop si
1700   0CF5 E7            pop d
1701   0CF6 E5            pop b
1702   0CF7 E4            pop a
1703   0CF8             ; --- END INLINE ASM BLOCK
1704   0CF8             
1705   0CF8 F9            leave
1706   0CF9 09            ret
1707   0CFA             
1708   0CFA             getparam:
1709   0CFA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1710   0CFD             ; $data 
1711   0CFD 52 01 00      sub sp, 1
1712   0D00             
1713   0D00             ; --- BEGIN INLINE ASM BLOCK
1714   0D00 19 04         mov al, 4
1715   0D02 FA 05 00      lea d, [bp + 5] ; $address
1716   0D05 FD 2A         mov d, [d]
1717   0D07 05 0C         syscall sys_system
1718   0D09 FA 00 00      lea d, [bp + 0] ; $data
1719   0D0C FD 3E         mov [d], bl
1720   0D0E             ; --- END INLINE ASM BLOCK
1721   0D0E             
1722   0D0E             ;; return data; 
1723   0D0E FA 00 00      lea d, [bp + 0] ; $data
1724   0D11 32            mov bl, [d]
1725   0D12 A7 00         mov bh, 0
1726   0D14 F9            leave
1727   0D15 09            ret
1728   0D16             
1729   0D16             clear:
1730   0D16 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1731   0D19             ;; print("\033[2J\033[H"); 
1732   0D19 26 3F 11      mov b, __s3 ; "\033[2J\033[H"
1733   0D1C FD AB         swp b
1734   0D1E D8            push b
1735   0D1F 07 33 0C      call print
1736   0D22 51 02 00      add sp, 2
1737   0D25 F9            leave
1738   0D26 09            ret
1739   0D27             
1740   0D27             printun:
1741   0D27 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1742   0D2A             ;; print(prompt); 
1743   0D2A FA 07 00      lea d, [bp + 7] ; $prompt
1744   0D2D 2A            mov b, [d]
1745   0D2E FD AB         swp b
1746   0D30 D8            push b
1747   0D31 07 33 0C      call print
1748   0D34 51 02 00      add sp, 2
1749   0D37             ;; printu(n); 
1750   0D37 FA 05 00      lea d, [bp + 5] ; $n
1751   0D3A 2A            mov b, [d]
1752   0D3B FD AB         swp b
1753   0D3D D8            push b
1754   0D3E 07 FF 0A      call printu
1755   0D41 51 02 00      add sp, 2
1756   0D44             ;; print("\n"); 
1757   0D44 26 47 11      mov b, __s4 ; "\n"
1758   0D47 FD AB         swp b
1759   0D49 D8            push b
1760   0D4A 07 33 0C      call print
1761   0D4D 51 02 00      add sp, 2
1762   0D50 F9            leave
1763   0D51 09            ret
1764   0D52             
1765   0D52             printsn:
1766   0D52 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1767   0D55             ;; print(prompt); 
1768   0D55 FA 07 00      lea d, [bp + 7] ; $prompt
1769   0D58 2A            mov b, [d]
1770   0D59 FD AB         swp b
1771   0D5B D8            push b
1772   0D5C 07 33 0C      call print
1773   0D5F 51 02 00      add sp, 2
1774   0D62             ;; prints(n); 
1775   0D62 FA 05 00      lea d, [bp + 5] ; $n
1776   0D65 2A            mov b, [d]
1777   0D66 FD AB         swp b
1778   0D68 D8            push b
1779   0D69 07 0A 0A      call prints
1780   0D6C 51 02 00      add sp, 2
1781   0D6F             ;; print("\n"); 
1782   0D6F 26 47 11      mov b, __s4 ; "\n"
1783   0D72 FD AB         swp b
1784   0D74 D8            push b
1785   0D75 07 33 0C      call print
1786   0D78 51 02 00      add sp, 2
1787   0D7B F9            leave
1788   0D7C 09            ret
1789   0D7D             
1790   0D7D             include_stdio_asm:
1791   0D7D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1792   0D80             
1793   0D80             ; --- BEGIN INLINE ASM BLOCK
1794   0D80             .include "lib/stdio.asm"
0001+  0D80             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0D80             ; stdio.s
0003+  0D80             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0D80             .include "lib/string.asm"
0001++ 0D80             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0D80             ; string.s
0003++ 0D80             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0D80             
0005++ 0D80             
0006++ 0D80             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0D80             ; _strrev
0008++ 0D80             ; reverse a string
0009++ 0D80             ; D = string address
0010++ 0D80             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0D80             ; 01234
0012++ 0D80             _strrev:
0013++ 0D80 4B          	pusha
0014++ 0D81 07 C7 0D    	call _strlen	; length in C
0015++ 0D84 12          	mov a, c
0016++ 0D85 AF 01 00    	cmp a, 1
0017++ 0D88 D0 A2 0D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0D8B 7D          	dec a
0019++ 0D8C FD 4E       	mov si, d	; beginning of string
0020++ 0D8E FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0D90 59          	add d, a	; end of string
0022++ 0D91 12          	mov a, c
0023++ 0D92 FD 9B       	shr a		; divide by 2
0024++ 0D94 39          	mov c, a	; C now counts the steps
0025++ 0D95             _strrev_L0:
0026++ 0D95 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0D96 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0D97 3E          	mov [d], al	; store left char into right side
0029++ 0D98 1B          	mov al, bl
0030++ 0D99 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0D9A 7E          	dec c
0032++ 0D9B 7F          	dec d
0033++ 0D9C C2 00 00    	cmp c, 0
0034++ 0D9F C7 95 0D    	jne _strrev_L0
0035++ 0DA2             _strrev_end:
0036++ 0DA2 4C          	popa
0037++ 0DA3 09          	ret
0038++ 0DA4             	
0039++ 0DA4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0DA4             ; _strchr
0041++ 0DA4             ; search string in D for char in AL
0042++ 0DA4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0DA4             _strchr:
0044++ 0DA4             _strchr_L0:
0045++ 0DA4 32          	mov bl, [d]
0046++ 0DA5 C1 00       	cmp bl, 0
0047++ 0DA7 C6 B2 0D    	je _strchr_end
0048++ 0DAA BA          	cmp al, bl
0049++ 0DAB C6 B2 0D    	je _strchr_end
0050++ 0DAE 79          	inc d
0051++ 0DAF 0A A4 0D    	jmp _strchr_L0
0052++ 0DB2             _strchr_end:
0053++ 0DB2 1B          	mov al, bl
0054++ 0DB3 09          	ret
0055++ 0DB4             
0056++ 0DB4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0DB4             ; _strstr
0058++ 0DB4             ; find sub-string
0059++ 0DB4             ; str1 in SI
0060++ 0DB4             ; str2 in DI
0061++ 0DB4             ; SI points to end of source string
0062++ 0DB4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0DB4             _strstr:
0064++ 0DB4 DB          	push al
0065++ 0DB5 DA          	push d
0066++ 0DB6 E3          	push di
0067++ 0DB7             _strstr_loop:
0068++ 0DB7 F3          	cmpsb					; compare a byte of the strings
0069++ 0DB8 C7 C3 0D    	jne _strstr_ret
0070++ 0DBB FC 00 00    	lea d, [di + 0]
0071++ 0DBE BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0DC0 C7 B7 0D    	jne _strstr_loop				; equal chars but not at end
0073++ 0DC3             _strstr_ret:
0074++ 0DC3 F0          	pop di
0075++ 0DC4 E7          	pop d
0076++ 0DC5 E8          	pop al
0077++ 0DC6 09          	ret
0078++ 0DC7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0DC7             ; length of null terminated string
0080++ 0DC7             ; result in C
0081++ 0DC7             ; pointer in D
0082++ 0DC7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0DC7             _strlen:
0084++ 0DC7 DA          	push d
0085++ 0DC8 38 00 00    	mov c, 0
0086++ 0DCB             _strlen_L1:
0087++ 0DCB BD 00       	cmp byte [d], 0
0088++ 0DCD C6 D5 0D    	je _strlen_ret
0089++ 0DD0 79          	inc d
0090++ 0DD1 78          	inc c
0091++ 0DD2 0A CB 0D    	jmp _strlen_L1
0092++ 0DD5             _strlen_ret:
0093++ 0DD5 E7          	pop d
0094++ 0DD6 09          	ret
0095++ 0DD7             
0096++ 0DD7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0DD7             ; STRCMP
0098++ 0DD7             ; compare two strings
0099++ 0DD7             ; str1 in SI
0100++ 0DD7             ; str2 in DI
0101++ 0DD7             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0DD7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0DD7             _strcmp:
0104++ 0DD7 DB          	push al
0105++ 0DD8 DA          	push d
0106++ 0DD9 E3          	push di
0107++ 0DDA E2          	push si
0108++ 0DDB             _strcmp_loop:
0109++ 0DDB F3          	cmpsb					; compare a byte of the strings
0110++ 0DDC C7 E7 0D    	jne _strcmp_ret
0111++ 0DDF FB FF FF    	lea d, [si +- 1]
0112++ 0DE2 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0DE4 C7 DB 0D    	jne _strcmp_loop				; equal chars but not at end
0114++ 0DE7             _strcmp_ret:
0115++ 0DE7 EF          	pop si
0116++ 0DE8 F0          	pop di
0117++ 0DE9 E7          	pop d
0118++ 0DEA E8          	pop al
0119++ 0DEB 09          	ret
0120++ 0DEC             
0121++ 0DEC             
0122++ 0DEC             ; STRCPY
0123++ 0DEC             ; copy null terminated string from SI to DI
0124++ 0DEC             ; source in SI
0125++ 0DEC             ; destination in DI
0126++ 0DEC             _strcpy:
0127++ 0DEC E2          	push si
0128++ 0DED E3          	push di
0129++ 0DEE DB          	push al
0130++ 0DEF             _strcpy_L1:
0131++ 0DEF F6          	lodsb
0132++ 0DF0 F7          	stosb
0133++ 0DF1 B9 00       	cmp al, 0
0134++ 0DF3 C7 EF 0D    	jne _strcpy_L1
0135++ 0DF6             _strcpy_end:
0136++ 0DF6 E8          	pop al
0137++ 0DF7 F0          	pop di
0138++ 0DF8 EF          	pop si
0139++ 0DF9 09          	ret
0140++ 0DFA             
0141++ 0DFA             ; STRCAT
0142++ 0DFA             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0DFA             ; source in SI
0144++ 0DFA             ; destination in DI
0145++ 0DFA             _strcat:
0146++ 0DFA E2          	push si
0147++ 0DFB E3          	push di
0148++ 0DFC D7          	push a
0149++ 0DFD DA          	push d
0150++ 0DFE 50          	mov a, di
0151++ 0DFF 3C          	mov d, a
0152++ 0E00             _strcat_goto_end_L1:
0153++ 0E00 BD 00       	cmp byte[d], 0
0154++ 0E02 C6 09 0E    	je _strcat_start
0155++ 0E05 79          	inc d
0156++ 0E06 0A 00 0E    	jmp _strcat_goto_end_L1
0157++ 0E09             _strcat_start:
0158++ 0E09 FD 50       	mov di, d
0159++ 0E0B             _strcat_L1:
0160++ 0E0B F6          	lodsb
0161++ 0E0C F7          	stosb
0162++ 0E0D B9 00       	cmp al, 0
0163++ 0E0F C7 0B 0E    	jne _strcat_L1
0164++ 0E12             _strcat_end:
0165++ 0E12 E7          	pop d
0166++ 0E13 E4          	pop a
0167++ 0E14 F0          	pop di
0168++ 0E15 EF          	pop si
0169++ 0E16 09          	ret
0170++ 0E17             
0171++ 0E17             
0005+  0E17             
0006+  0E17             
0007+  0E17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0E17             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0E17             ; ASCII in BL
0010+  0E17             ; result in AL
0011+  0E17             ; ascii for F = 0100 0110
0012+  0E17             ; ascii for 9 = 0011 1001
0013+  0E17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0E17             hex_ascii_encode:
0015+  0E17 1B            mov al, bl
0016+  0E18 93 40         test al, $40        ; test if letter or number
0017+  0E1A C7 20 0E      jnz hex_letter
0018+  0E1D 87 0F         and al, $0F        ; get number
0019+  0E1F 09            ret
0020+  0E20             hex_letter:
0021+  0E20 87 0F         and al, $0F        ; get letter
0022+  0E22 6A 09         add al, 9
0023+  0E24 09            ret
0024+  0E25             
0025+  0E25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0E25             ; ATOI
0027+  0E25             ; 2 letter hex string in B
0028+  0E25             ; 8bit integer returned in AL
0029+  0E25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0E25             _atoi:
0031+  0E25 D8            push b
0032+  0E26 07 17 0E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0E29 30            mov bl, bh
0034+  0E2A DB            push al          ; save a
0035+  0E2B 07 17 0E      call hex_ascii_encode
0036+  0E2E EA            pop bl  
0037+  0E2F FD 9E 04      shl al, 4
0038+  0E32 8C            or al, bl
0039+  0E33 E5            pop b
0040+  0E34 09            ret  
0041+  0E35             
0042+  0E35             
0043+  0E35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0E35             ; scanf
0045+  0E35             ; no need for explanations!
0046+  0E35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0E35             scanf:
0048+  0E35 09            ret
0049+  0E36             
0050+  0E36             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0E36             ; ITOA
0052+  0E36             ; 8bit value in BL
0053+  0E36             ; 2 byte ASCII result in A
0054+  0E36             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0E36             _itoa:
0056+  0E36 DA            push d
0057+  0E37 D8            push b
0058+  0E38 A7 00         mov bh, 0
0059+  0E3A FD A4 04      shr bl, 4  
0060+  0E3D 74            mov d, b
0061+  0E3E 1F E6 10      mov al, [d + s_hex_digits]
0062+  0E41 23            mov ah, al
0063+  0E42               
0064+  0E42 E5            pop b
0065+  0E43 D8            push b
0066+  0E44 A7 00         mov bh, 0
0067+  0E46 FD 87 0F      and bl, $0F
0068+  0E49 74            mov d, b
0069+  0E4A 1F E6 10      mov al, [d + s_hex_digits]
0070+  0E4D E5            pop b
0071+  0E4E E7            pop d
0072+  0E4F 09            ret
0073+  0E50             
0074+  0E50             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0E50             ; HEX STRING TO BINARY
0076+  0E50             ; di = destination address
0077+  0E50             ; si = source
0078+  0E50             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0E50             _hex_to_int:
0080+  0E50             _hex_to_int_L1:
0081+  0E50 F6            lodsb          ; load from [SI] to AL
0082+  0E51 B9 00         cmp al, 0        ; check if ASCII 0
0083+  0E53 C6 60 0E      jz _hex_to_int_ret
0084+  0E56 36            mov bh, al
0085+  0E57 F6            lodsb
0086+  0E58 2F            mov bl, al
0087+  0E59 07 25 0E      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0E5C F7            stosb          ; store AL to [DI]
0089+  0E5D 0A 50 0E      jmp _hex_to_int_L1
0090+  0E60             _hex_to_int_ret:
0091+  0E60 09            ret    
0092+  0E61             
0093+  0E61             
0094+  0E61             
0095+  0E61             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0E61             ; GETCHAR
0097+  0E61             ; char in ah
0098+  0E61             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0E61             getch:
0100+  0E61 DB            push al
0101+  0E62             getch_retry:
0102+  0E62 19 01         mov al, 1
0103+  0E64 05 03         syscall sys_io      ; receive in AH
0104+  0E66 E8            pop al
0105+  0E67 09            ret
0106+  0E68             
0107+  0E68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0E68             ; PUTCHAR
0109+  0E68             ; char in ah
0110+  0E68             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0E68             _putchar:
0112+  0E68 D7            push a
0113+  0E69 19 00         mov al, 0
0114+  0E6B 05 03         syscall sys_io      ; char in AH
0115+  0E6D E4            pop a
0116+  0E6E 09            ret
0117+  0E6F             
0118+  0E6F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0E6F             ;; INPUT A STRING
0120+  0E6F             ;; terminates with null
0121+  0E6F             ;; pointer in D
0122+  0E6F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0E6F             _gets:
0124+  0E6F D7            push a
0125+  0E70 DA            push d
0126+  0E71             _gets_loop:
0127+  0E71 19 01         mov al, 1
0128+  0E73 05 03         syscall sys_io      ; receive in AH
0129+  0E75 B9 00         cmp al, 0        ; check error code (AL)
0130+  0E77 C6 71 0E      je _gets_loop      ; if no char received, retry
0131+  0E7A             
0132+  0E7A 76 1B         cmp ah, 27
0133+  0E7C C6 9D 0E      je _gets_ansi_esc
0134+  0E7F 76 0A         cmp ah, $0A        ; LF
0135+  0E81 C6 08 0F      je _gets_end
0136+  0E84 76 0D         cmp ah, $0D        ; CR
0137+  0E86 C6 08 0F      je _gets_end
0138+  0E89 76 5C         cmp ah, $5C        ; '\\'
0139+  0E8B C6 C9 0E      je _gets_escape
0140+  0E8E               
0141+  0E8E 76 08         cmp ah, $08      ; check for backspace
0142+  0E90 C6 99 0E      je _gets_backspace
0143+  0E93             
0144+  0E93 1A            mov al, ah
0145+  0E94 3E            mov [d], al
0146+  0E95 79            inc d
0147+  0E96 0A 71 0E      jmp _gets_loop
0148+  0E99             _gets_backspace:
0149+  0E99 7F            dec d
0150+  0E9A 0A 71 0E      jmp _gets_loop
0151+  0E9D             _gets_ansi_esc:
0152+  0E9D 19 01         mov al, 1
0153+  0E9F 05 03         syscall sys_io        ; receive in AH without echo
0154+  0EA1 B9 00         cmp al, 0          ; check error code (AL)
0155+  0EA3 C6 9D 0E      je _gets_ansi_esc    ; if no char received, retry
0156+  0EA6 76 5B         cmp ah, '['
0157+  0EA8 C7 71 0E      jne _gets_loop
0158+  0EAB             _gets_ansi_esc_2:
0159+  0EAB 19 01         mov al, 1
0160+  0EAD 05 03         syscall sys_io          ; receive in AH without echo
0161+  0EAF B9 00         cmp al, 0            ; check error code (AL)
0162+  0EB1 C6 AB 0E      je _gets_ansi_esc_2  ; if no char received, retry
0163+  0EB4 76 44         cmp ah, 'D'
0164+  0EB6 C6 C1 0E      je _gets_left_arrow
0165+  0EB9 76 43         cmp ah, 'C'
0166+  0EBB C6 C5 0E      je _gets_right_arrow
0167+  0EBE 0A 71 0E      jmp _gets_loop
0168+  0EC1             _gets_left_arrow:
0169+  0EC1 7F            dec d
0170+  0EC2 0A 71 0E      jmp _gets_loop
0171+  0EC5             _gets_right_arrow:
0172+  0EC5 79            inc d
0173+  0EC6 0A 71 0E      jmp _gets_loop
0174+  0EC9             _gets_escape:
0175+  0EC9 19 01         mov al, 1
0176+  0ECB 05 03         syscall sys_io      ; receive in AH
0177+  0ECD B9 00         cmp al, 0        ; check error code (AL)
0178+  0ECF C6 C9 0E      je _gets_escape      ; if no char received, retry
0179+  0ED2 76 6E         cmp ah, 'n'
0180+  0ED4 C6 F3 0E      je _gets_LF
0181+  0ED7 76 72         cmp ah, 'r'
0182+  0ED9 C6 FA 0E      je _gets_CR
0183+  0EDC 76 30         cmp ah, '0'
0184+  0EDE C6 01 0F      je _gets_NULL
0185+  0EE1 76 5C         cmp ah, $5C  ; '\'
0186+  0EE3 C6 EC 0E      je _gets_slash
0187+  0EE6 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  0EE7 3E            mov [d], al
0189+  0EE8 79            inc d
0190+  0EE9 0A 71 0E      jmp _gets_loop
0191+  0EEC             _gets_slash:
0192+  0EEC 19 5C         mov al, $5C
0193+  0EEE 3E            mov [d], al
0194+  0EEF 79            inc d
0195+  0EF0 0A 71 0E      jmp _gets_loop
0196+  0EF3             _gets_LF:
0197+  0EF3 19 0A         mov al, $0A
0198+  0EF5 3E            mov [d], al
0199+  0EF6 79            inc d
0200+  0EF7 0A 71 0E      jmp _gets_loop
0201+  0EFA             _gets_CR:
0202+  0EFA 19 0D         mov al, $0D
0203+  0EFC 3E            mov [d], al
0204+  0EFD 79            inc d
0205+  0EFE 0A 71 0E      jmp _gets_loop
0206+  0F01             _gets_NULL:
0207+  0F01 19 00         mov al, $00
0208+  0F03 3E            mov [d], al
0209+  0F04 79            inc d
0210+  0F05 0A 71 0E      jmp _gets_loop
0211+  0F08             _gets_end:
0212+  0F08 19 00         mov al, 0
0213+  0F0A 3E            mov [d], al        ; terminate string
0214+  0F0B E7            pop d
0215+  0F0C E4            pop a
0216+  0F0D 09            ret
0217+  0F0E             
0218+  0F0E             
0219+  0F0E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  0F0E             ;; INPUT TEXT
0221+  0F0E             ;; terminated with CTRL+D
0222+  0F0E             ;; pointer in D
0223+  0F0E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  0F0E             _gettxt:
0225+  0F0E D7            push a
0226+  0F0F DA            push d
0227+  0F10             _gettxt_loop:
0228+  0F10 19 01         mov al, 1
0229+  0F12 05 03         syscall sys_io      ; receive in AH
0230+  0F14 B9 00         cmp al, 0        ; check error code (AL)
0231+  0F16 C6 10 0F      je _gettxt_loop    ; if no char received, retry
0232+  0F19 76 04         cmp ah, 4      ; EOT
0233+  0F1B C6 59 0F      je _gettxt_end
0234+  0F1E 76 08         cmp ah, $08      ; check for backspace
0235+  0F20 C6 55 0F      je _gettxt_backspace
0236+  0F23 76 5C         cmp ah, $5C        ; '\'
0237+  0F25 C6 2E 0F      je _gettxt_escape
0238+  0F28 1A            mov al, ah
0239+  0F29 3E            mov [d], al
0240+  0F2A 79            inc d
0241+  0F2B 0A 10 0F      jmp _gettxt_loop
0242+  0F2E             _gettxt_escape:
0243+  0F2E 19 01         mov al, 1
0244+  0F30 05 03         syscall sys_io      ; receive in AH
0245+  0F32 B9 00         cmp al, 0        ; check error code (AL)
0246+  0F34 C6 2E 0F      je _gettxt_escape    ; if no char received, retry
0247+  0F37 76 6E         cmp ah, 'n'
0248+  0F39 C6 47 0F      je _gettxt_LF
0249+  0F3C 76 72         cmp ah, 'r'
0250+  0F3E C6 4E 0F      je _gettxt_CR
0251+  0F41 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0F42 3E            mov [d], al
0253+  0F43 79            inc d
0254+  0F44 0A 10 0F      jmp _gettxt_loop
0255+  0F47             _gettxt_LF:
0256+  0F47 19 0A         mov al, $0A
0257+  0F49 3E            mov [d], al
0258+  0F4A 79            inc d
0259+  0F4B 0A 10 0F      jmp _gettxt_loop
0260+  0F4E             _gettxt_CR:
0261+  0F4E 19 0D         mov al, $0D
0262+  0F50 3E            mov [d], al
0263+  0F51 79            inc d
0264+  0F52 0A 10 0F      jmp _gettxt_loop
0265+  0F55             _gettxt_backspace:
0266+  0F55 7F            dec d
0267+  0F56 0A 10 0F      jmp _gettxt_loop
0268+  0F59             _gettxt_end:
0269+  0F59 19 00         mov al, 0
0270+  0F5B 3E            mov [d], al        ; terminate string
0271+  0F5C E7            pop d
0272+  0F5D E4            pop a
0273+  0F5E 09            ret
0274+  0F5F             
0275+  0F5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0F5F             ; PRINT NEW LINE
0277+  0F5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  0F5F             printnl:
0279+  0F5F D7            push a
0280+  0F60 10 00 0A      mov a, $0A00
0281+  0F63 05 03         syscall sys_io
0282+  0F65 10 00 0D      mov a, $0D00
0283+  0F68 05 03         syscall sys_io
0284+  0F6A E4            pop a
0285+  0F6B 09            ret
0286+  0F6C             
0287+  0F6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0F6C             ; _strtoint
0289+  0F6C             ; 4 digit hex string number in d
0290+  0F6C             ; integer returned in A
0291+  0F6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  0F6C             _strtointx:
0293+  0F6C D8            push b
0294+  0F6D 32            mov bl, [d]
0295+  0F6E 37            mov bh, bl
0296+  0F6F 33 01 00      mov bl, [d + 1]
0297+  0F72 07 25 0E      call _atoi        ; convert to int in AL
0298+  0F75 23            mov ah, al        ; move to AH
0299+  0F76 33 02 00      mov bl, [d + 2]
0300+  0F79 37            mov bh, bl
0301+  0F7A 33 03 00      mov bl, [d + 3]
0302+  0F7D 07 25 0E      call _atoi        ; convert to int in AL
0303+  0F80 E5            pop b
0304+  0F81 09            ret
0305+  0F82             
0306+  0F82             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  0F82             ; _strtoint
0308+  0F82             ; 5 digit base10 string number in d
0309+  0F82             ; integer returned in A
0310+  0F82             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  0F82             _strtoint:
0312+  0F82 E2            push si
0313+  0F83 D8            push b
0314+  0F84 D9            push c
0315+  0F85 DA            push d
0316+  0F86 07 C7 0D      call _strlen      ; get string length in C
0317+  0F89 7E            dec c
0318+  0F8A FD 4E         mov si, d
0319+  0F8C 12            mov a, c
0320+  0F8D FD 99         shl a
0321+  0F8F 3B FE 10      mov d, table_power
0322+  0F92 59            add d, a
0323+  0F93 38 00 00      mov c, 0
0324+  0F96             _strtoint_L0:
0325+  0F96 F6            lodsb      ; load ASCII to al
0326+  0F97 B9 00         cmp al, 0
0327+  0F99 C6 AC 0F      je _strtoint_end
0328+  0F9C 6F 30         sub al, $30    ; make into integer
0329+  0F9E 22 00         mov ah, 0
0330+  0FA0 2A            mov b, [d]
0331+  0FA1 AC            mul a, b      ; result in B since it fits in 16bits
0332+  0FA2 11            mov a, b
0333+  0FA3 28            mov b, c
0334+  0FA4 54            add a, b
0335+  0FA5 39            mov c, a
0336+  0FA6 63 02 00      sub d, 2
0337+  0FA9 0A 96 0F      jmp _strtoint_L0
0338+  0FAC             _strtoint_end:
0339+  0FAC 12            mov a, c
0340+  0FAD E7            pop d
0341+  0FAE E6            pop c
0342+  0FAF E5            pop b
0343+  0FB0 EF            pop si
0344+  0FB1 09            ret
0345+  0FB2             
0346+  0FB2             
0347+  0FB2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  0FB2             ; PRINT NULL TERMINATED STRING
0349+  0FB2             ; pointer in D
0350+  0FB2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  0FB2             _puts:
0352+  0FB2 D7            push a
0353+  0FB3 DA            push d
0354+  0FB4             _puts_L1:
0355+  0FB4 1E            mov al, [d]
0356+  0FB5 B9 00         cmp al, 0
0357+  0FB7 C6 C3 0F      jz _puts_END
0358+  0FBA 23            mov ah, al
0359+  0FBB 19 00         mov al, 0
0360+  0FBD 05 03         syscall sys_io
0361+  0FBF 79            inc d
0362+  0FC0 0A B4 0F      jmp _puts_L1
0363+  0FC3             _puts_END:
0364+  0FC3 E7            pop d
0365+  0FC4 E4            pop a
0366+  0FC5 09            ret
0367+  0FC6             
0368+  0FC6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  0FC6             ; PRINT N SIZE STRING
0370+  0FC6             ; pointer in D
0371+  0FC6             ; size in C
0372+  0FC6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  0FC6             _putsn:
0374+  0FC6 DB            push al
0375+  0FC7 DA            push d
0376+  0FC8 D9            push c
0377+  0FC9             _putsn_L0:
0378+  0FC9 1E            mov al, [d]
0379+  0FCA 23            mov ah, al
0380+  0FCB 19 00         mov al, 0
0381+  0FCD 05 03         syscall sys_io
0382+  0FCF 79            inc d
0383+  0FD0 7E            dec c  
0384+  0FD1 C2 00 00      cmp c, 0
0385+  0FD4 C7 C9 0F      jne _putsn_L0
0386+  0FD7             _putsn_end:
0387+  0FD7 E6            pop c
0388+  0FD8 E7            pop d
0389+  0FD9 E8            pop al
0390+  0FDA 09            ret
0391+  0FDB             
0392+  0FDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  0FDB             ; print 16bit decimal number
0394+  0FDB             ; input number in A
0395+  0FDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  0FDB             print_u16d:
0397+  0FDB D7            push a
0398+  0FDC D8            push b
0399+  0FDD 26 10 27      mov b, 10000
0400+  0FE0 AE            div a, b      ; get 10000's coeff.
0401+  0FE1 07 03 10      call print_number
0402+  0FE4 11            mov a, b
0403+  0FE5 26 E8 03      mov b, 1000
0404+  0FE8 AE            div a, b      ; get 1000's coeff.
0405+  0FE9 07 03 10      call print_number
0406+  0FEC 11            mov a, b
0407+  0FED 26 64 00      mov b, 100
0408+  0FF0 AE            div a, b
0409+  0FF1 07 03 10      call print_number
0410+  0FF4 11            mov a, b
0411+  0FF5 26 0A 00      mov b, 10
0412+  0FF8 AE            div a, b
0413+  0FF9 07 03 10      call print_number
0414+  0FFC 1B            mov al, bl      ; 1's coeff in bl
0415+  0FFD 07 03 10      call print_number
0416+  1000 E5            pop b
0417+  1001 E4            pop a
0418+  1002 09            ret
0419+  1003             
0420+  1003             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  1003             ; print AL
0422+  1003             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  1003             print_number:
0424+  1003 6A 30         add al, $30
0425+  1005 23            mov ah, al
0426+  1006 07 68 0E      call _putchar
0427+  1009 09            ret
0428+  100A             
0429+  100A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  100A             ; PRINT 16BIT HEX INTEGER
0431+  100A             ; integer value in reg B
0432+  100A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  100A             print_u16x:
0434+  100A D7            push a
0435+  100B D8            push b
0436+  100C DD            push bl
0437+  100D 30            mov bl, bh
0438+  100E 07 36 0E      call _itoa        ; convert bh to char in A
0439+  1011 2F            mov bl, al        ; save al
0440+  1012 19 00         mov al, 0
0441+  1014 05 03         syscall sys_io        ; display AH
0442+  1016 24            mov ah, bl        ; retrieve al
0443+  1017 19 00         mov al, 0
0444+  1019 05 03         syscall sys_io        ; display AL
0445+  101B             
0446+  101B EA            pop bl
0447+  101C 07 36 0E      call _itoa        ; convert bh to char in A
0448+  101F 2F            mov bl, al        ; save al
0449+  1020 19 00         mov al, 0
0450+  1022 05 03         syscall sys_io        ; display AH
0451+  1024 24            mov ah, bl        ; retrieve al
0452+  1025 19 00         mov al, 0
0453+  1027 05 03         syscall sys_io        ; display AL
0454+  1029             
0455+  1029 E5            pop b
0456+  102A E4            pop a
0457+  102B 09            ret
0458+  102C             
0459+  102C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  102C             ; INPUT 16BIT HEX INTEGER
0461+  102C             ; read 16bit integer into A
0462+  102C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  102C             scan_u16x:
0464+  102C F8 10 00      enter 16
0465+  102F D8            push b
0466+  1030 DA            push d
0467+  1031             
0468+  1031 FA F1 FF      lea d, [bp + -15]
0469+  1034 07 6F 0E      call _gets        ; get number
0470+  1037             
0471+  1037 32            mov bl, [d]
0472+  1038 37            mov bh, bl
0473+  1039 33 01 00      mov bl, [d + 1]
0474+  103C 07 25 0E      call _atoi        ; convert to int in AL
0475+  103F 23            mov ah, al        ; move to AH
0476+  1040             
0477+  1040 33 02 00      mov bl, [d + 2]
0478+  1043 37            mov bh, bl
0479+  1044 33 03 00      mov bl, [d + 3]
0480+  1047 07 25 0E      call _atoi        ; convert to int in AL
0481+  104A             
0482+  104A E7            pop d
0483+  104B E5            pop b
0484+  104C F9            leave
0485+  104D 09            ret
0486+  104E             
0487+  104E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  104E             ; PRINT 8bit HEX INTEGER
0489+  104E             ; integer value in reg bl
0490+  104E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  104E             print_u8x:
0492+  104E D7            push a
0493+  104F DD            push bl
0494+  1050             
0495+  1050 07 36 0E      call _itoa        ; convert bl to char in A
0496+  1053 2F            mov bl, al        ; save al
0497+  1054 19 00         mov al, 0
0498+  1056 05 03         syscall sys_io        ; display AH
0499+  1058 24            mov ah, bl        ; retrieve al
0500+  1059 19 00         mov al, 0
0501+  105B 05 03         syscall sys_io        ; display AL
0502+  105D             
0503+  105D EA            pop bl
0504+  105E E4            pop a
0505+  105F 09            ret
0506+  1060             
0507+  1060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  1060             ; print 8bit decimal unsigned number
0509+  1060             ; input number in AL
0510+  1060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  1060             print_u8d:
0512+  1060 D7            push a
0513+  1061 D8            push b
0514+  1062             
0515+  1062 22 00         mov ah, 0
0516+  1064 26 64 00      mov b, 100
0517+  1067 AE            div a, b
0518+  1068 D8            push b      ; save remainder
0519+  1069 B9 00         cmp al, 0
0520+  106B C6 75 10      je skip100
0521+  106E 6A 30         add al, $30
0522+  1070 23            mov ah, al
0523+  1071 19 00         mov al, 0
0524+  1073 05 03         syscall sys_io  ; print coeff
0525+  1075             skip100:
0526+  1075 E4            pop a
0527+  1076 22 00         mov ah, 0
0528+  1078 26 0A 00      mov b, 10
0529+  107B AE            div a, b
0530+  107C D8            push b      ; save remainder
0531+  107D B9 00         cmp al, 0
0532+  107F C6 89 10      je skip10
0533+  1082 6A 30         add al, $30
0534+  1084 23            mov ah, al
0535+  1085 19 00         mov al, 0
0536+  1087 05 03         syscall sys_io  ; print coeff
0537+  1089             skip10:
0538+  1089 E4            pop a
0539+  108A 1B            mov al, bl
0540+  108B 6A 30         add al, $30
0541+  108D 23            mov ah, al
0542+  108E 19 00         mov al, 0
0543+  1090 05 03         syscall sys_io  ; print coeff
0544+  1092 E5            pop b
0545+  1093 E4            pop a
0546+  1094 09            ret
0547+  1095             
0548+  1095             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  1095             ; INPUT 8BIT HEX INTEGER
0550+  1095             ; read 8bit integer into AL
0551+  1095             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  1095             scan_u8x:
0553+  1095 F8 04 00      enter 4
0554+  1098 D8            push b
0555+  1099 DA            push d
0556+  109A             
0557+  109A FA FD FF      lea d, [bp + -3]
0558+  109D 07 6F 0E      call _gets        ; get number
0559+  10A0             
0560+  10A0 32            mov bl, [d]
0561+  10A1 37            mov bh, bl
0562+  10A2 33 01 00      mov bl, [d + 1]
0563+  10A5 07 25 0E      call _atoi        ; convert to int in AL
0564+  10A8             
0565+  10A8 E7            pop d
0566+  10A9 E5            pop b
0567+  10AA F9            leave
0568+  10AB 09            ret
0569+  10AC             
0570+  10AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  10AC             ; input decimal number
0572+  10AC             ; result in A
0573+  10AC             ; 655'\0'
0574+  10AC             ; low--------high
0575+  10AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  10AC             scan_u16d:
0577+  10AC F8 08 00      enter 8
0578+  10AF E2            push si
0579+  10B0 D8            push b
0580+  10B1 D9            push c
0581+  10B2 DA            push d
0582+  10B3 FA F9 FF      lea d, [bp +- 7]
0583+  10B6 07 6F 0E      call _gets
0584+  10B9 07 C7 0D      call _strlen      ; get string length in C
0585+  10BC 7E            dec c
0586+  10BD FD 4E         mov si, d
0587+  10BF 12            mov a, c
0588+  10C0 FD 99         shl a
0589+  10C2 3B FE 10      mov d, table_power
0590+  10C5 59            add d, a
0591+  10C6 38 00 00      mov c, 0
0592+  10C9             mul_loop:
0593+  10C9 F6            lodsb      ; load ASCII to al
0594+  10CA B9 00         cmp al, 0
0595+  10CC C6 DF 10      je mul_exit
0596+  10CF 6F 30         sub al, $30    ; make into integer
0597+  10D1 22 00         mov ah, 0
0598+  10D3 2A            mov b, [d]
0599+  10D4 AC            mul a, b      ; result in B since it fits in 16bits
0600+  10D5 11            mov a, b
0601+  10D6 28            mov b, c
0602+  10D7 54            add a, b
0603+  10D8 39            mov c, a
0604+  10D9 63 02 00      sub d, 2
0605+  10DC 0A C9 10      jmp mul_loop
0606+  10DF             mul_exit:
0607+  10DF 12            mov a, c
0608+  10E0 E7            pop d
0609+  10E1 E6            pop c
0610+  10E2 E5            pop b
0611+  10E3 EF            pop si
0612+  10E4 F9            leave
0613+  10E5 09            ret
0614+  10E6             
0615+  10E6             
0616+  10E6 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  10EA 34 35 36 37 
0616+  10EE 38 39 41 42 
0616+  10F2 43 44 45 46 
0617+  10F6 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  10FA 1B 5B 48 00 
0618+  10FE             
0619+  10FE             table_power:
0620+  10FE 01 00         .dw 1
0621+  1100 0A 00         .dw 10
0622+  1102 64 00         .dw 100
0623+  1104 E8 03         .dw 1000
0624+  1106 10 27         .dw 100001795   1108             ; --- END INLINE ASM BLOCK
1796   1108             
1797   1108 F9            leave
1798   1109 09            ret
1799   110A             ; --- END TEXT BLOCK
1800   110A             
1801   110A             ; --- BEGIN DATA BLOCK
1802   110A 50 61 75 6C __s0: .db "Paulo", 0
1802   110E 6F 00 
1803   1110 48 65 6C 6C __s1: .db "Hello: %c %d %s", 0
1803   1114 6F 3A 20 25 
1803   1118 63 20 25 64 
1803   111C 20 25 73 00 
1804   1120 45 72 72 6F __s2: .db "Error: Unknown argument type.\n", 0
1804   1124 72 3A 20 55 
1804   1128 6E 6B 6E 6F 
1804   112C 77 6E 20 61 
1804   1130 72 67 75 6D 
1804   1134 65 6E 74 20 
1804   1138 74 79 70 65 
1804   113C 2E 0A 00 
1805   113F 1B 5B 32 4A __s3: .db "\033[2J\033[H", 0
1805   1143 1B 5B 48 00 
1806   1147 0A 00       __s4: .db "\n", 0
1807   1149             
1808   1149 4B 11       _heap_top: .dw _heap
1809   114B 00          _heap: .db 0
1810   114C             ; --- END DATA BLOCK
1811   114C             
1812   114C             .end
tasm: Number of errors = 0
