0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; printf("String: %s, %c, %x", "Hello World, this Works!", 'A', 0xABCD); 
0011   0408 26 CD AB      mov b, $abcd
0012   040B FD AB         swp b
0013   040D D8            push b
0014   040E 26 41 00      mov b, $41
0015   0411 FD AB         swp b
0016   0413 D8            push b
0017   0414 26 D7 17      mov b, __s0 ; "Hello World, this Works!"
0018   0417 FD AB         swp b
0019   0419 D8            push b
0020   041A 26 F0 17      mov b, __s1 ; "String: %s, %c, %x"
0021   041D FD AB         swp b
0022   041F D8            push b
0023   0420 07 E4 05      call printf
0024   0423 51 08 00      add sp, 8
0025   0426             ;; return; 
0026   0426 F9            leave
0027   0427 05 0B         syscall sys_terminate_proc
0028   0429             
0029   0429             strcpy:
0030   0429 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0031   042C             ; $psrc 
0032   042C             ; $pdest 
0033   042C 52 04 00      sub sp, 4
0034   042F             ;; psrc = src; 
0035   042F FA FF FF      lea d, [bp + -1] ; $psrc
0036   0432 DA            push d
0037   0433 FA 07 00      lea d, [bp + 7] ; $src
0038   0436 2A            mov b, [d]
0039   0437 E7            pop d
0040   0438 FD 43         mov [d], b
0041   043A             ;; pdest = dest; 
0042   043A FA FD FF      lea d, [bp + -3] ; $pdest
0043   043D DA            push d
0044   043E FA 05 00      lea d, [bp + 5] ; $dest
0045   0441 2A            mov b, [d]
0046   0442 E7            pop d
0047   0443 FD 43         mov [d], b
0048   0445             ;; while(*psrc) *pdest++ = *psrc++; 
0049   0445             _while1_cond:
0050   0445 FA FF FF      lea d, [bp + -1] ; $psrc
0051   0448 2A            mov b, [d]
0052   0449 74            mov d, b
0053   044A 32            mov bl, [d]
0054   044B A7 00         mov bh, 0
0055   044D C0 00 00      cmp b, 0
0056   0450 C6 78 04      je _while1_exit
0057   0453             _while1_block:
0058   0453             ;; *pdest++ = *psrc++; 
0059   0453 FA FD FF      lea d, [bp + -3] ; $pdest
0060   0456 2A            mov b, [d]
0061   0457 D8            push b
0062   0458 FD 77         inc b
0063   045A FA FD FF      lea d, [bp + -3] ; $pdest
0064   045D FD 43         mov [d], b
0065   045F E5            pop b
0066   0460 D8            push b
0067   0461 FA FF FF      lea d, [bp + -1] ; $psrc
0068   0464 2A            mov b, [d]
0069   0465 D8            push b
0070   0466 FD 77         inc b
0071   0468 FA FF FF      lea d, [bp + -1] ; $psrc
0072   046B FD 43         mov [d], b
0073   046D E5            pop b
0074   046E 74            mov d, b
0075   046F 32            mov bl, [d]
0076   0470 A7 00         mov bh, 0
0077   0472 E7            pop d
0078   0473 FD 3E         mov [d], bl
0079   0475 0A 45 04      jmp _while1_cond
0080   0478             _while1_exit:
0081   0478             ;; *pdest = '\0'; 
0082   0478 FA FD FF      lea d, [bp + -3] ; $pdest
0083   047B 2A            mov b, [d]
0084   047C D8            push b
0085   047D 26 00 00      mov b, $0
0086   0480 E7            pop d
0087   0481 FD 3E         mov [d], bl
0088   0483 F9            leave
0089   0484 09            ret
0090   0485             
0091   0485             strcmp:
0092   0485 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0093   0488             ;; while (*s1 && (*s1 == *s2)) { 
0094   0488             _while2_cond:
0095   0488 FA 05 00      lea d, [bp + 5] ; $s1
0096   048B 2A            mov b, [d]
0097   048C 74            mov d, b
0098   048D 32            mov bl, [d]
0099   048E A7 00         mov bh, 0
0100   0490 D7            push a
0101   0491 11            mov a, b
0102   0492 FA 05 00      lea d, [bp + 5] ; $s1
0103   0495 2A            mov b, [d]
0104   0496 74            mov d, b
0105   0497 32            mov bl, [d]
0106   0498 A7 00         mov bh, 0
0107   049A             ; START RELATIONAL
0108   049A D7            push a
0109   049B 11            mov a, b
0110   049C FA 07 00      lea d, [bp + 7] ; $s2
0111   049F 2A            mov b, [d]
0112   04A0 74            mov d, b
0113   04A1 32            mov bl, [d]
0114   04A2 A7 00         mov bh, 0
0115   04A4 B0            cmp a, b
0116   04A5 FD 71         seq ; ==
0117   04A7 E4            pop a
0118   04A8             ; END RELATIONAL
0119   04A8 FD A7         sand a, b ; &&
0120   04AA E4            pop a
0121   04AB C0 00 00      cmp b, 0
0122   04AE C6 CE 04      je _while2_exit
0123   04B1             _while2_block:
0124   04B1             ;; s1++; 
0125   04B1 FA 05 00      lea d, [bp + 5] ; $s1
0126   04B4 2A            mov b, [d]
0127   04B5 D8            push b
0128   04B6 FD 77         inc b
0129   04B8 FA 05 00      lea d, [bp + 5] ; $s1
0130   04BB FD 43         mov [d], b
0131   04BD E5            pop b
0132   04BE             ;; s2++; 
0133   04BE FA 07 00      lea d, [bp + 7] ; $s2
0134   04C1 2A            mov b, [d]
0135   04C2 D8            push b
0136   04C3 FD 77         inc b
0137   04C5 FA 07 00      lea d, [bp + 7] ; $s2
0138   04C8 FD 43         mov [d], b
0139   04CA E5            pop b
0140   04CB 0A 88 04      jmp _while2_cond
0141   04CE             _while2_exit:
0142   04CE             ;; return *s1 - *s2; 
0143   04CE FA 05 00      lea d, [bp + 5] ; $s1
0144   04D1 2A            mov b, [d]
0145   04D2 74            mov d, b
0146   04D3 32            mov bl, [d]
0147   04D4 A7 00         mov bh, 0
0148   04D6             ; START TERMS
0149   04D6 D7            push a
0150   04D7 11            mov a, b
0151   04D8 FA 07 00      lea d, [bp + 7] ; $s2
0152   04DB 2A            mov b, [d]
0153   04DC 74            mov d, b
0154   04DD 32            mov bl, [d]
0155   04DE A7 00         mov bh, 0
0156   04E0 60            sub a, b
0157   04E1 27            mov b, a
0158   04E2 E4            pop a
0159   04E3             ; END TERMS
0160   04E3 F9            leave
0161   04E4 09            ret
0162   04E5             
0163   04E5             strcat:
0164   04E5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0165   04E8             ; $dest_len 
0166   04E8             ; $i 
0167   04E8 52 04 00      sub sp, 4
0168   04EB             ;; dest_len = strlen(dest); 
0169   04EB FA FF FF      lea d, [bp + -1] ; $dest_len
0170   04EE DA            push d
0171   04EF FA 05 00      lea d, [bp + 5] ; $dest
0172   04F2 2A            mov b, [d]
0173   04F3 FD AB         swp b
0174   04F5 D8            push b
0175   04F6 07 9B 05      call strlen
0176   04F9 51 02 00      add sp, 2
0177   04FC E7            pop d
0178   04FD FD 43         mov [d], b
0179   04FF             ;; for (i = 0; src[i] != 0; i=i+1) { 
0180   04FF             _for3_init:
0181   04FF FA FD FF      lea d, [bp + -3] ; $i
0182   0502 DA            push d
0183   0503 26 00 00      mov b, $0
0184   0506 E7            pop d
0185   0507 FD 43         mov [d], b
0186   0509             _for3_cond:
0187   0509 FA 07 00      lea d, [bp + 7] ; $src
0188   050C FD 2A         mov d, [d]
0189   050E D7            push a
0190   050F DA            push d
0191   0510 FA FD FF      lea d, [bp + -3] ; $i
0192   0513 2A            mov b, [d]
0193   0514 E7            pop d
0194   0515 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0195   0519 E4            pop a
0196   051A 32            mov bl, [d]
0197   051B A7 00         mov bh, 0
0198   051D             ; START RELATIONAL
0199   051D D7            push a
0200   051E 11            mov a, b
0201   051F 26 00 00      mov b, $0
0202   0522 B0            cmp a, b
0203   0523 FD 72         sneq ; !=
0204   0525 E4            pop a
0205   0526             ; END RELATIONAL
0206   0526 C0 00 00      cmp b, 0
0207   0529 C6 74 05      je _for3_exit
0208   052C             _for3_block:
0209   052C             ;; dest[dest_len + i] = src[i]; 
0210   052C FA 05 00      lea d, [bp + 5] ; $dest
0211   052F FD 2A         mov d, [d]
0212   0531 D7            push a
0213   0532 DA            push d
0214   0533 FA FF FF      lea d, [bp + -1] ; $dest_len
0215   0536 2A            mov b, [d]
0216   0537             ; START TERMS
0217   0537 D7            push a
0218   0538 11            mov a, b
0219   0539 FA FD FF      lea d, [bp + -3] ; $i
0220   053C 2A            mov b, [d]
0221   053D 54            add a, b
0222   053E 27            mov b, a
0223   053F E4            pop a
0224   0540             ; END TERMS
0225   0540 E7            pop d
0226   0541 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0227   0545 E4            pop a
0228   0546 DA            push d
0229   0547 FA 07 00      lea d, [bp + 7] ; $src
0230   054A FD 2A         mov d, [d]
0231   054C D7            push a
0232   054D DA            push d
0233   054E FA FD FF      lea d, [bp + -3] ; $i
0234   0551 2A            mov b, [d]
0235   0552 E7            pop d
0236   0553 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0237   0557 E4            pop a
0238   0558 32            mov bl, [d]
0239   0559 A7 00         mov bh, 0
0240   055B E7            pop d
0241   055C FD 3E         mov [d], bl
0242   055E             _for3_update:
0243   055E FA FD FF      lea d, [bp + -3] ; $i
0244   0561 DA            push d
0245   0562 FA FD FF      lea d, [bp + -3] ; $i
0246   0565 2A            mov b, [d]
0247   0566             ; START TERMS
0248   0566 D7            push a
0249   0567 11            mov a, b
0250   0568 26 01 00      mov b, $1
0251   056B 54            add a, b
0252   056C 27            mov b, a
0253   056D E4            pop a
0254   056E             ; END TERMS
0255   056E E7            pop d
0256   056F FD 43         mov [d], b
0257   0571 0A 09 05      jmp _for3_cond
0258   0574             _for3_exit:
0259   0574             ;; dest[dest_len + i] = 0; 
0260   0574 FA 05 00      lea d, [bp + 5] ; $dest
0261   0577 FD 2A         mov d, [d]
0262   0579 D7            push a
0263   057A DA            push d
0264   057B FA FF FF      lea d, [bp + -1] ; $dest_len
0265   057E 2A            mov b, [d]
0266   057F             ; START TERMS
0267   057F D7            push a
0268   0580 11            mov a, b
0269   0581 FA FD FF      lea d, [bp + -3] ; $i
0270   0584 2A            mov b, [d]
0271   0585 54            add a, b
0272   0586 27            mov b, a
0273   0587 E4            pop a
0274   0588             ; END TERMS
0275   0588 E7            pop d
0276   0589 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0277   058D E4            pop a
0278   058E DA            push d
0279   058F 26 00 00      mov b, $0
0280   0592 E7            pop d
0281   0593 FD 3E         mov [d], bl
0282   0595             ;; return dest; 
0283   0595 FA 05 00      lea d, [bp + 5] ; $dest
0284   0598 2A            mov b, [d]
0285   0599 F9            leave
0286   059A 09            ret
0287   059B             
0288   059B             strlen:
0289   059B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0290   059E             ; $length 
0291   059E 52 02 00      sub sp, 2
0292   05A1             ;; length = 0; 
0293   05A1 FA FF FF      lea d, [bp + -1] ; $length
0294   05A4 DA            push d
0295   05A5 26 00 00      mov b, $0
0296   05A8 E7            pop d
0297   05A9 FD 43         mov [d], b
0298   05AB             ;; while (str[length] != 0) { 
0299   05AB             _while4_cond:
0300   05AB FA 05 00      lea d, [bp + 5] ; $str
0301   05AE FD 2A         mov d, [d]
0302   05B0 D7            push a
0303   05B1 DA            push d
0304   05B2 FA FF FF      lea d, [bp + -1] ; $length
0305   05B5 2A            mov b, [d]
0306   05B6 E7            pop d
0307   05B7 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0308   05BB E4            pop a
0309   05BC 32            mov bl, [d]
0310   05BD A7 00         mov bh, 0
0311   05BF             ; START RELATIONAL
0312   05BF D7            push a
0313   05C0 11            mov a, b
0314   05C1 26 00 00      mov b, $0
0315   05C4 B0            cmp a, b
0316   05C5 FD 72         sneq ; !=
0317   05C7 E4            pop a
0318   05C8             ; END RELATIONAL
0319   05C8 C0 00 00      cmp b, 0
0320   05CB C6 DE 05      je _while4_exit
0321   05CE             _while4_block:
0322   05CE             ;; length++; 
0323   05CE FA FF FF      lea d, [bp + -1] ; $length
0324   05D1 2A            mov b, [d]
0325   05D2 D8            push b
0326   05D3 FD 77         inc b
0327   05D5 FA FF FF      lea d, [bp + -1] ; $length
0328   05D8 FD 43         mov [d], b
0329   05DA E5            pop b
0330   05DB 0A AB 05      jmp _while4_cond
0331   05DE             _while4_exit:
0332   05DE             ;; return length; 
0333   05DE FA FF FF      lea d, [bp + -1] ; $length
0334   05E1 2A            mov b, [d]
0335   05E2 F9            leave
0336   05E3 09            ret
0337   05E4             
0338   05E4             printf:
0339   05E4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0340   05E7             ; $p 
0341   05E7             ; $fp 
0342   05E7             ; $i 
0343   05E7 52 06 00      sub sp, 6
0344   05EA             ;; fp = format; 
0345   05EA FA FD FF      lea d, [bp + -3] ; $fp
0346   05ED DA            push d
0347   05EE FA 05 00      lea d, [bp + 5] ; $format
0348   05F1 2A            mov b, [d]
0349   05F2 E7            pop d
0350   05F3 FD 43         mov [d], b
0351   05F5             ;; p = &format + 2; 
0352   05F5 FA FF FF      lea d, [bp + -1] ; $p
0353   05F8 DA            push d
0354   05F9 FA 05 00      lea d, [bp + 5] ; $format
0355   05FC 2D            mov b, d
0356   05FD             ; START TERMS
0357   05FD D7            push a
0358   05FE 11            mov a, b
0359   05FF 26 02 00      mov b, $2
0360   0602 54            add a, b
0361   0603 27            mov b, a
0362   0604 E4            pop a
0363   0605             ; END TERMS
0364   0605 E7            pop d
0365   0606 FD 43         mov [d], b
0366   0608             ;; for(;;){ 
0367   0608             _for5_init:
0368   0608             _for5_cond:
0369   0608             _for5_block:
0370   0608             ;; if(!*fp) break; 
0371   0608             _if6_cond:
0372   0608 FA FD FF      lea d, [bp + -3] ; $fp
0373   060B 2A            mov b, [d]
0374   060C 74            mov d, b
0375   060D 32            mov bl, [d]
0376   060E A7 00         mov bh, 0
0377   0610 C0 00 00      cmp b, 0
0378   0613 FD 71         seq ; !
0379   0615 C0 00 00      cmp b, 0
0380   0618 C6 21 06      je _if6_else
0381   061B             _if6_true:
0382   061B             ;; break; 
0383   061B 0A 30 08      jmp _for5_exit ; for break
0384   061E 0A 2D 08      jmp _if6_exit
0385   0621             _if6_else:
0386   0621             ;; if(*fp == '%'){ 
0387   0621             _if7_cond:
0388   0621 FA FD FF      lea d, [bp + -3] ; $fp
0389   0624 2A            mov b, [d]
0390   0625 74            mov d, b
0391   0626 32            mov bl, [d]
0392   0627 A7 00         mov bh, 0
0393   0629             ; START RELATIONAL
0394   0629 D7            push a
0395   062A 11            mov a, b
0396   062B 26 25 00      mov b, $25
0397   062E B0            cmp a, b
0398   062F FD 71         seq ; ==
0399   0631 E4            pop a
0400   0632             ; END RELATIONAL
0401   0632 C0 00 00      cmp b, 0
0402   0635 C6 11 08      je _if7_else
0403   0638             _if7_true:
0404   0638             ;; fp++; 
0405   0638 FA FD FF      lea d, [bp + -3] ; $fp
0406   063B 2A            mov b, [d]
0407   063C D8            push b
0408   063D FD 77         inc b
0409   063F FA FD FF      lea d, [bp + -3] ; $fp
0410   0642 FD 43         mov [d], b
0411   0644 E5            pop b
0412   0645             ;; switch(*fp){ 
0413   0645             _switch8_expr:
0414   0645 FA FD FF      lea d, [bp + -3] ; $fp
0415   0648 2A            mov b, [d]
0416   0649 74            mov d, b
0417   064A 32            mov bl, [d]
0418   064B A7 00         mov bh, 0
0419   064D             _switch8_comparisons:
0420   064D C1 6C         cmp bl, $6c
0421   064F C6 7B 06      je _switch8_case0
0422   0652 C1 4C         cmp bl, $4c
0423   0654 C6 7B 06      je _switch8_case1
0424   0657 C1 64         cmp bl, $64
0425   0659 C6 4C 07      je _switch8_case2
0426   065C C1 69         cmp bl, $69
0427   065E C6 4C 07      je _switch8_case3
0428   0661 C1 75         cmp bl, $75
0429   0663 C6 71 07      je _switch8_case4
0430   0666 C1 78         cmp bl, $78
0431   0668 C6 96 07      je _switch8_case5
0432   066B C1 63         cmp bl, $63
0433   066D C6 B5 07      je _switch8_case6
0434   0670 C1 73         cmp bl, $73
0435   0672 C6 D5 07      je _switch8_case7
0436   0675 0A F5 07      jmp _switch8_default
0437   0678 0A 01 08      jmp _switch8_exit
0438   067B             _switch8_case0:
0439   067B             _switch8_case1:
0440   067B             ;; fp++; 
0441   067B FA FD FF      lea d, [bp + -3] ; $fp
0442   067E 2A            mov b, [d]
0443   067F D8            push b
0444   0680 FD 77         inc b
0445   0682 FA FD FF      lea d, [bp + -3] ; $fp
0446   0685 FD 43         mov [d], b
0447   0687 E5            pop b
0448   0688             ;; if(*fp == 'd' || *fp == 'i') 
0449   0688             _if9_cond:
0450   0688 FA FD FF      lea d, [bp + -3] ; $fp
0451   068B 2A            mov b, [d]
0452   068C 74            mov d, b
0453   068D 32            mov bl, [d]
0454   068E A7 00         mov bh, 0
0455   0690             ; START RELATIONAL
0456   0690 D7            push a
0457   0691 11            mov a, b
0458   0692 26 64 00      mov b, $64
0459   0695 B0            cmp a, b
0460   0696 FD 71         seq ; ==
0461   0698 E4            pop a
0462   0699             ; END RELATIONAL
0463   0699 D7            push a
0464   069A 11            mov a, b
0465   069B FA FD FF      lea d, [bp + -3] ; $fp
0466   069E 2A            mov b, [d]
0467   069F 74            mov d, b
0468   06A0 32            mov bl, [d]
0469   06A1 A7 00         mov bh, 0
0470   06A3             ; START RELATIONAL
0471   06A3 D7            push a
0472   06A4 11            mov a, b
0473   06A5 26 69 00      mov b, $69
0474   06A8 B0            cmp a, b
0475   06A9 FD 71         seq ; ==
0476   06AB E4            pop a
0477   06AC             ; END RELATIONAL
0478   06AC FD A8         sor a, b ; ||
0479   06AE E4            pop a
0480   06AF C0 00 00      cmp b, 0
0481   06B2 C6 C9 06      je _if9_else
0482   06B5             _if9_true:
0483   06B5             ;; print_signed_long(*(long *)p); 
0484   06B5 FD 79         mov g, b
0485   06B7 28            mov b, c
0486   06B8 FD AB         swp b
0487   06BA D8            push b
0488   06BB FD 27         mov b, g
0489   06BD FD AB         swp b
0490   06BF D8            push b
0491   06C0 07 D4 0B      call print_signed_long
0492   06C3 51 04 00      add sp, 4
0493   06C6 0A 36 07      jmp _if9_exit
0494   06C9             _if9_else:
0495   06C9             ;; if(*fp == 'u') 
0496   06C9             _if10_cond:
0497   06C9 FA FD FF      lea d, [bp + -3] ; $fp
0498   06CC 2A            mov b, [d]
0499   06CD 74            mov d, b
0500   06CE 32            mov bl, [d]
0501   06CF A7 00         mov bh, 0
0502   06D1             ; START RELATIONAL
0503   06D1 D7            push a
0504   06D2 11            mov a, b
0505   06D3 26 75 00      mov b, $75
0506   06D6 B0            cmp a, b
0507   06D7 FD 71         seq ; ==
0508   06D9 E4            pop a
0509   06DA             ; END RELATIONAL
0510   06DA C0 00 00      cmp b, 0
0511   06DD C6 F4 06      je _if10_else
0512   06E0             _if10_true:
0513   06E0             ;; print_unsigned_long(*(unsigned long *)p); 
0514   06E0 FD 79         mov g, b
0515   06E2 28            mov b, c
0516   06E3 FD AB         swp b
0517   06E5 D8            push b
0518   06E6 FD 27         mov b, g
0519   06E8 FD AB         swp b
0520   06EA D8            push b
0521   06EB 07 09 0D      call print_unsigned_long
0522   06EE 51 04 00      add sp, 4
0523   06F1 0A 36 07      jmp _if10_exit
0524   06F4             _if10_else:
0525   06F4             ;; if(*fp == 'x') 
0526   06F4             _if11_cond:
0527   06F4 FA FD FF      lea d, [bp + -3] ; $fp
0528   06F7 2A            mov b, [d]
0529   06F8 74            mov d, b
0530   06F9 32            mov bl, [d]
0531   06FA A7 00         mov bh, 0
0532   06FC             ; START RELATIONAL
0533   06FC D7            push a
0534   06FD 11            mov a, b
0535   06FE 26 78 00      mov b, $78
0536   0701 B0            cmp a, b
0537   0702 FD 71         seq ; ==
0538   0704 E4            pop a
0539   0705             ; END RELATIONAL
0540   0705 C0 00 00      cmp b, 0
0541   0708 C6 2A 07      je _if11_else
0542   070B             _if11_true:
0543   070B             ;; printx32(*(long int *)p); 
0544   070B FA FF FF      lea d, [bp + -1] ; $p
0545   070E 2A            mov b, [d]
0546   070F 74            mov d, b
0547   0710 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0548   0713 FD 39         mov c, b ; And place it into C
0549   0715 2A            mov b, [d] ; Lower Word in B
0550   0716 FD 79         mov g, b
0551   0718 28            mov b, c
0552   0719 FD AB         swp b
0553   071B D8            push b
0554   071C FD 27         mov b, g
0555   071E FD AB         swp b
0556   0720 D8            push b
0557   0721 07 47 08      call printx32
0558   0724 51 04 00      add sp, 4
0559   0727 0A 36 07      jmp _if11_exit
0560   072A             _if11_else:
0561   072A             ;; err("Unexpected format in printf."); 
0562   072A 26 03 18      mov b, __s2 ; "Unexpected format in printf."
0563   072D FD AB         swp b
0564   072F D8            push b
0565   0730 07 32 08      call err
0566   0733 51 02 00      add sp, 2
0567   0736             _if11_exit:
0568   0736             _if10_exit:
0569   0736             _if9_exit:
0570   0736             ;; p = p + 4; 
0571   0736 FA FF FF      lea d, [bp + -1] ; $p
0572   0739 DA            push d
0573   073A FA FF FF      lea d, [bp + -1] ; $p
0574   073D 2A            mov b, [d]
0575   073E             ; START TERMS
0576   073E D7            push a
0577   073F 11            mov a, b
0578   0740 26 04 00      mov b, $4
0579   0743 54            add a, b
0580   0744 27            mov b, a
0581   0745 E4            pop a
0582   0746             ; END TERMS
0583   0746 E7            pop d
0584   0747 FD 43         mov [d], b
0585   0749             ;; break; 
0586   0749 0A 01 08      jmp _switch8_exit ; case break
0587   074C             _switch8_case2:
0588   074C             _switch8_case3:
0589   074C             ;; print_signed(*(int*)p); 
0590   074C FA FF FF      lea d, [bp + -1] ; $p
0591   074F 2A            mov b, [d]
0592   0750 74            mov d, b
0593   0751 2A            mov b, [d]
0594   0752 FD AB         swp b
0595   0754 D8            push b
0596   0755 07 E3 0A      call print_signed
0597   0758 51 02 00      add sp, 2
0598   075B             ;; p = p + 2; 
0599   075B FA FF FF      lea d, [bp + -1] ; $p
0600   075E DA            push d
0601   075F FA FF FF      lea d, [bp + -1] ; $p
0602   0762 2A            mov b, [d]
0603   0763             ; START TERMS
0604   0763 D7            push a
0605   0764 11            mov a, b
0606   0765 26 02 00      mov b, $2
0607   0768 54            add a, b
0608   0769 27            mov b, a
0609   076A E4            pop a
0610   076B             ; END TERMS
0611   076B E7            pop d
0612   076C FD 43         mov [d], b
0613   076E             ;; break; 
0614   076E 0A 01 08      jmp _switch8_exit ; case break
0615   0771             _switch8_case4:
0616   0771             ;; print_unsigned(*(unsigned int*)p); 
0617   0771 FA FF FF      lea d, [bp + -1] ; $p
0618   0774 2A            mov b, [d]
0619   0775 74            mov d, b
0620   0776 2A            mov b, [d]
0621   0777 FD AB         swp b
0622   0779 D8            push b
0623   077A 07 00 0E      call print_unsigned
0624   077D 51 02 00      add sp, 2
0625   0780             ;; p = p + 2; 
0626   0780 FA FF FF      lea d, [bp + -1] ; $p
0627   0783 DA            push d
0628   0784 FA FF FF      lea d, [bp + -1] ; $p
0629   0787 2A            mov b, [d]
0630   0788             ; START TERMS
0631   0788 D7            push a
0632   0789 11            mov a, b
0633   078A 26 02 00      mov b, $2
0634   078D 54            add a, b
0635   078E 27            mov b, a
0636   078F E4            pop a
0637   0790             ; END TERMS
0638   0790 E7            pop d
0639   0791 FD 43         mov [d], b
0640   0793             ;; break; 
0641   0793 0A 01 08      jmp _switch8_exit ; case break
0642   0796             _switch8_case5:
0643   0796             
0644   0796             ; --- BEGIN INLINE ASM BLOCK
0645   0796 FA FF FF      lea d, [bp + -1] ; $p
0646   0799 FD 2A         mov d, [d]
0647   079B 2A            mov b, [d]
0648   079C 07 B1 12      call print_u16x
0649   079F             ; --- END INLINE ASM BLOCK
0650   079F             
0651   079F             ;; p = p + 2; 
0652   079F FA FF FF      lea d, [bp + -1] ; $p
0653   07A2 DA            push d
0654   07A3 FA FF FF      lea d, [bp + -1] ; $p
0655   07A6 2A            mov b, [d]
0656   07A7             ; START TERMS
0657   07A7 D7            push a
0658   07A8 11            mov a, b
0659   07A9 26 02 00      mov b, $2
0660   07AC 54            add a, b
0661   07AD 27            mov b, a
0662   07AE E4            pop a
0663   07AF             ; END TERMS
0664   07AF E7            pop d
0665   07B0 FD 43         mov [d], b
0666   07B2             ;; break; 
0667   07B2 0A 01 08      jmp _switch8_exit ; case break
0668   07B5             _switch8_case6:
0669   07B5             
0670   07B5             ; --- BEGIN INLINE ASM BLOCK
0671   07B5 FA FF FF      lea d, [bp + -1] ; $p
0672   07B8 FD 2A         mov d, [d]
0673   07BA 1E            mov al, [d]
0674   07BB 23            mov ah, al
0675   07BC 07 0F 11      call _putchar
0676   07BF             ; --- END INLINE ASM BLOCK
0677   07BF             
0678   07BF             ;; p = p + 2; 
0679   07BF FA FF FF      lea d, [bp + -1] ; $p
0680   07C2 DA            push d
0681   07C3 FA FF FF      lea d, [bp + -1] ; $p
0682   07C6 2A            mov b, [d]
0683   07C7             ; START TERMS
0684   07C7 D7            push a
0685   07C8 11            mov a, b
0686   07C9 26 02 00      mov b, $2
0687   07CC 54            add a, b
0688   07CD 27            mov b, a
0689   07CE E4            pop a
0690   07CF             ; END TERMS
0691   07CF E7            pop d
0692   07D0 FD 43         mov [d], b
0693   07D2             ;; break; 
0694   07D2 0A 01 08      jmp _switch8_exit ; case break
0695   07D5             _switch8_case7:
0696   07D5             
0697   07D5             ; --- BEGIN INLINE ASM BLOCK
0698   07D5 FA FF FF      lea d, [bp + -1] ; $p
0699   07D8 FD 2A         mov d, [d]
0700   07DA FD 2A         mov d, [d]
0701   07DC 07 59 12      call _puts
0702   07DF             ; --- END INLINE ASM BLOCK
0703   07DF             
0704   07DF             ;; p = p + 2; 
0705   07DF FA FF FF      lea d, [bp + -1] ; $p
0706   07E2 DA            push d
0707   07E3 FA FF FF      lea d, [bp + -1] ; $p
0708   07E6 2A            mov b, [d]
0709   07E7             ; START TERMS
0710   07E7 D7            push a
0711   07E8 11            mov a, b
0712   07E9 26 02 00      mov b, $2
0713   07EC 54            add a, b
0714   07ED 27            mov b, a
0715   07EE E4            pop a
0716   07EF             ; END TERMS
0717   07EF E7            pop d
0718   07F0 FD 43         mov [d], b
0719   07F2             ;; break; 
0720   07F2 0A 01 08      jmp _switch8_exit ; case break
0721   07F5             _switch8_default:
0722   07F5             ;; print("Error: Unknown argument type.\n"); 
0723   07F5 26 20 18      mov b, __s3 ; "Error: Unknown argument type.\n"
0724   07F8 FD AB         swp b
0725   07FA D8            push b
0726   07FB 07 30 0F      call print
0727   07FE 51 02 00      add sp, 2
0728   0801             _switch8_exit:
0729   0801             ;; fp++; 
0730   0801 FA FD FF      lea d, [bp + -3] ; $fp
0731   0804 2A            mov b, [d]
0732   0805 D8            push b
0733   0806 FD 77         inc b
0734   0808 FA FD FF      lea d, [bp + -3] ; $fp
0735   080B FD 43         mov [d], b
0736   080D E5            pop b
0737   080E 0A 2D 08      jmp _if7_exit
0738   0811             _if7_else:
0739   0811             ;; putchar(*fp); 
0740   0811 FA FD FF      lea d, [bp + -3] ; $fp
0741   0814 2A            mov b, [d]
0742   0815 74            mov d, b
0743   0816 32            mov bl, [d]
0744   0817 A7 00         mov bh, 0
0745   0819 DD            push bl
0746   081A 07 E8 0E      call putchar
0747   081D 51 01 00      add sp, 1
0748   0820             ;; fp++; 
0749   0820 FA FD FF      lea d, [bp + -3] ; $fp
0750   0823 2A            mov b, [d]
0751   0824 D8            push b
0752   0825 FD 77         inc b
0753   0827 FA FD FF      lea d, [bp + -3] ; $fp
0754   082A FD 43         mov [d], b
0755   082C E5            pop b
0756   082D             _if7_exit:
0757   082D             _if6_exit:
0758   082D             _for5_update:
0759   082D 0A 08 06      jmp _for5_cond
0760   0830             _for5_exit:
0761   0830 F9            leave
0762   0831 09            ret
0763   0832             
0764   0832             err:
0765   0832 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0766   0835             ;; print(e); 
0767   0835 FA 05 00      lea d, [bp + 5] ; $e
0768   0838 2A            mov b, [d]
0769   0839 FD AB         swp b
0770   083B D8            push b
0771   083C 07 30 0F      call print
0772   083F 51 02 00      add sp, 2
0773   0842             ;; exit(); 
0774   0842 07 AA 0F      call exit
0775   0845 F9            leave
0776   0846 09            ret
0777   0847             
0778   0847             printx32:
0779   0847 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0780   084A             
0781   084A             ; --- BEGIN INLINE ASM BLOCK
0782   084A FA 05 00      lea d, [bp + 5] ; $hex
0783   084D 2B 02 00      mov b, [d+2]
0784   0850 07 B1 12      call print_u16x
0785   0853 2A            mov b, [d]
0786   0854 07 B1 12      call print_u16x
0787   0857             ; --- END INLINE ASM BLOCK
0788   0857             
0789   0857 F9            leave
0790   0858 09            ret
0791   0859             
0792   0859             printx16:
0793   0859 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0794   085C             
0795   085C             ; --- BEGIN INLINE ASM BLOCK
0796   085C FA 05 00      lea d, [bp + 5] ; $hex
0797   085F 2A            mov b, [d]
0798   0860 07 B1 12      call print_u16x
0799   0863             ; --- END INLINE ASM BLOCK
0800   0863             
0801   0863 F9            leave
0802   0864 09            ret
0803   0865             
0804   0865             printx8:
0805   0865 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0806   0868             
0807   0868             ; --- BEGIN INLINE ASM BLOCK
0808   0868 FA 05 00      lea d, [bp + 5] ; $hex
0809   086B 32            mov bl, [d]
0810   086C 07 F5 12      call print_u8x
0811   086F             ; --- END INLINE ASM BLOCK
0812   086F             
0813   086F F9            leave
0814   0870 09            ret
0815   0871             
0816   0871             hex_to_int:
0817   0871 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0818   0874             ; $value 
0819   0874 10 00 00      mov a, $0
0820   0877 45 FF FF      mov [bp + -1], a
0821   087A             ; $i 
0822   087A             ; $hex_char 
0823   087A             ; $len 
0824   087A 52 07 00      sub sp, 7
0825   087D             ;; len = strlen(hex_string); 
0826   087D FA FA FF      lea d, [bp + -6] ; $len
0827   0880 DA            push d
0828   0881 FA 05 00      lea d, [bp + 5] ; $hex_string
0829   0884 2A            mov b, [d]
0830   0885 FD AB         swp b
0831   0887 D8            push b
0832   0888 07 9B 05      call strlen
0833   088B 51 02 00      add sp, 2
0834   088E E7            pop d
0835   088F FD 43         mov [d], b
0836   0891             ;; for (i = 0; i < len; i++) { 
0837   0891             _for12_init:
0838   0891 FA FD FF      lea d, [bp + -3] ; $i
0839   0894 DA            push d
0840   0895 26 00 00      mov b, $0
0841   0898 E7            pop d
0842   0899 FD 43         mov [d], b
0843   089B             _for12_cond:
0844   089B FA FD FF      lea d, [bp + -3] ; $i
0845   089E 2A            mov b, [d]
0846   089F             ; START RELATIONAL
0847   089F D7            push a
0848   08A0 11            mov a, b
0849   08A1 FA FA FF      lea d, [bp + -6] ; $len
0850   08A4 2A            mov b, [d]
0851   08A5 B0            cmp a, b
0852   08A6 FD 73         slt ; < 
0853   08A8 E4            pop a
0854   08A9             ; END RELATIONAL
0855   08A9 C0 00 00      cmp b, 0
0856   08AC C6 B1 09      je _for12_exit
0857   08AF             _for12_block:
0858   08AF             ;; hex_char = hex_string[i]; 
0859   08AF FA FC FF      lea d, [bp + -4] ; $hex_char
0860   08B2 DA            push d
0861   08B3 FA 05 00      lea d, [bp + 5] ; $hex_string
0862   08B6 FD 2A         mov d, [d]
0863   08B8 D7            push a
0864   08B9 DA            push d
0865   08BA FA FD FF      lea d, [bp + -3] ; $i
0866   08BD 2A            mov b, [d]
0867   08BE E7            pop d
0868   08BF FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0869   08C3 E4            pop a
0870   08C4 32            mov bl, [d]
0871   08C5 A7 00         mov bh, 0
0872   08C7 E7            pop d
0873   08C8 FD 3E         mov [d], bl
0874   08CA             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0875   08CA             _if13_cond:
0876   08CA FA FC FF      lea d, [bp + -4] ; $hex_char
0877   08CD 32            mov bl, [d]
0878   08CE A7 00         mov bh, 0
0879   08D0             ; START RELATIONAL
0880   08D0 D7            push a
0881   08D1 11            mov a, b
0882   08D2 26 61 00      mov b, $61
0883   08D5 B0            cmp a, b
0884   08D6 FD 80         sge ; >=
0885   08D8 E4            pop a
0886   08D9             ; END RELATIONAL
0887   08D9 D7            push a
0888   08DA 11            mov a, b
0889   08DB FA FC FF      lea d, [bp + -4] ; $hex_char
0890   08DE 32            mov bl, [d]
0891   08DF A7 00         mov bh, 0
0892   08E1             ; START RELATIONAL
0893   08E1 D7            push a
0894   08E2 11            mov a, b
0895   08E3 26 66 00      mov b, $66
0896   08E6 B0            cmp a, b
0897   08E7 FD 74         sle ; <=
0898   08E9 E4            pop a
0899   08EA             ; END RELATIONAL
0900   08EA FD A7         sand a, b ; &&
0901   08EC E4            pop a
0902   08ED C0 00 00      cmp b, 0
0903   08F0 C6 22 09      je _if13_else
0904   08F3             _if13_true:
0905   08F3             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0906   08F3 FA FF FF      lea d, [bp + -1] ; $value
0907   08F6 DA            push d
0908   08F7 FA FF FF      lea d, [bp + -1] ; $value
0909   08FA 2A            mov b, [d]
0910   08FB             ; START FACTORS
0911   08FB D7            push a
0912   08FC 11            mov a, b
0913   08FD 26 10 00      mov b, $10
0914   0900 AC            mul a, b ; *
0915   0901 11            mov a, b
0916   0902 27            mov b, a
0917   0903 E4            pop a
0918   0904             ; END FACTORS
0919   0904             ; START TERMS
0920   0904 D7            push a
0921   0905 11            mov a, b
0922   0906 FA FC FF      lea d, [bp + -4] ; $hex_char
0923   0909 32            mov bl, [d]
0924   090A A7 00         mov bh, 0
0925   090C             ; START TERMS
0926   090C D7            push a
0927   090D 11            mov a, b
0928   090E 26 61 00      mov b, $61
0929   0911 60            sub a, b
0930   0912 11            mov a, b
0931   0913 26 0A 00      mov b, $a
0932   0916 54            add a, b
0933   0917 27            mov b, a
0934   0918 E4            pop a
0935   0919             ; END TERMS
0936   0919 54            add a, b
0937   091A 27            mov b, a
0938   091B E4            pop a
0939   091C             ; END TERMS
0940   091C E7            pop d
0941   091D FD 43         mov [d], b
0942   091F 0A A1 09      jmp _if13_exit
0943   0922             _if13_else:
0944   0922             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0945   0922             _if14_cond:
0946   0922 FA FC FF      lea d, [bp + -4] ; $hex_char
0947   0925 32            mov bl, [d]
0948   0926 A7 00         mov bh, 0
0949   0928             ; START RELATIONAL
0950   0928 D7            push a
0951   0929 11            mov a, b
0952   092A 26 41 00      mov b, $41
0953   092D B0            cmp a, b
0954   092E FD 80         sge ; >=
0955   0930 E4            pop a
0956   0931             ; END RELATIONAL
0957   0931 D7            push a
0958   0932 11            mov a, b
0959   0933 FA FC FF      lea d, [bp + -4] ; $hex_char
0960   0936 32            mov bl, [d]
0961   0937 A7 00         mov bh, 0
0962   0939             ; START RELATIONAL
0963   0939 D7            push a
0964   093A 11            mov a, b
0965   093B 26 46 00      mov b, $46
0966   093E B0            cmp a, b
0967   093F FD 74         sle ; <=
0968   0941 E4            pop a
0969   0942             ; END RELATIONAL
0970   0942 FD A7         sand a, b ; &&
0971   0944 E4            pop a
0972   0945 C0 00 00      cmp b, 0
0973   0948 C6 7A 09      je _if14_else
0974   094B             _if14_true:
0975   094B             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0976   094B FA FF FF      lea d, [bp + -1] ; $value
0977   094E DA            push d
0978   094F FA FF FF      lea d, [bp + -1] ; $value
0979   0952 2A            mov b, [d]
0980   0953             ; START FACTORS
0981   0953 D7            push a
0982   0954 11            mov a, b
0983   0955 26 10 00      mov b, $10
0984   0958 AC            mul a, b ; *
0985   0959 11            mov a, b
0986   095A 27            mov b, a
0987   095B E4            pop a
0988   095C             ; END FACTORS
0989   095C             ; START TERMS
0990   095C D7            push a
0991   095D 11            mov a, b
0992   095E FA FC FF      lea d, [bp + -4] ; $hex_char
0993   0961 32            mov bl, [d]
0994   0962 A7 00         mov bh, 0
0995   0964             ; START TERMS
0996   0964 D7            push a
0997   0965 11            mov a, b
0998   0966 26 41 00      mov b, $41
0999   0969 60            sub a, b
1000   096A 11            mov a, b
1001   096B 26 0A 00      mov b, $a
1002   096E 54            add a, b
1003   096F 27            mov b, a
1004   0970 E4            pop a
1005   0971             ; END TERMS
1006   0971 54            add a, b
1007   0972 27            mov b, a
1008   0973 E4            pop a
1009   0974             ; END TERMS
1010   0974 E7            pop d
1011   0975 FD 43         mov [d], b
1012   0977 0A A1 09      jmp _if14_exit
1013   097A             _if14_else:
1014   097A             ;; value = (value * 16) + (hex_char - '0'); 
1015   097A FA FF FF      lea d, [bp + -1] ; $value
1016   097D DA            push d
1017   097E FA FF FF      lea d, [bp + -1] ; $value
1018   0981 2A            mov b, [d]
1019   0982             ; START FACTORS
1020   0982 D7            push a
1021   0983 11            mov a, b
1022   0984 26 10 00      mov b, $10
1023   0987 AC            mul a, b ; *
1024   0988 11            mov a, b
1025   0989 27            mov b, a
1026   098A E4            pop a
1027   098B             ; END FACTORS
1028   098B             ; START TERMS
1029   098B D7            push a
1030   098C 11            mov a, b
1031   098D FA FC FF      lea d, [bp + -4] ; $hex_char
1032   0990 32            mov bl, [d]
1033   0991 A7 00         mov bh, 0
1034   0993             ; START TERMS
1035   0993 D7            push a
1036   0994 11            mov a, b
1037   0995 26 30 00      mov b, $30
1038   0998 60            sub a, b
1039   0999 27            mov b, a
1040   099A E4            pop a
1041   099B             ; END TERMS
1042   099B 54            add a, b
1043   099C 27            mov b, a
1044   099D E4            pop a
1045   099E             ; END TERMS
1046   099E E7            pop d
1047   099F FD 43         mov [d], b
1048   09A1             _if14_exit:
1049   09A1             _if13_exit:
1050   09A1             _for12_update:
1051   09A1 FA FD FF      lea d, [bp + -3] ; $i
1052   09A4 2A            mov b, [d]
1053   09A5 D8            push b
1054   09A6 FD 77         inc b
1055   09A8 FA FD FF      lea d, [bp + -3] ; $i
1056   09AB FD 43         mov [d], b
1057   09AD E5            pop b
1058   09AE 0A 9B 08      jmp _for12_cond
1059   09B1             _for12_exit:
1060   09B1             ;; return value; 
1061   09B1 FA FF FF      lea d, [bp + -1] ; $value
1062   09B4 2A            mov b, [d]
1063   09B5 F9            leave
1064   09B6 09            ret
1065   09B7             
1066   09B7             atoi:
1067   09B7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1068   09BA             ; $result 
1069   09BA 10 00 00      mov a, $0
1070   09BD 45 FF FF      mov [bp + -1], a
1071   09C0             ; $sign 
1072   09C0 10 01 00      mov a, $1
1073   09C3 45 FD FF      mov [bp + -3], a
1074   09C6 52 04 00      sub sp, 4
1075   09C9             ;; while (*str == ' ') str++; 
1076   09C9             _while15_cond:
1077   09C9 FA 05 00      lea d, [bp + 5] ; $str
1078   09CC 2A            mov b, [d]
1079   09CD 74            mov d, b
1080   09CE 32            mov bl, [d]
1081   09CF A7 00         mov bh, 0
1082   09D1             ; START RELATIONAL
1083   09D1 D7            push a
1084   09D2 11            mov a, b
1085   09D3 26 20 00      mov b, $20
1086   09D6 B0            cmp a, b
1087   09D7 FD 71         seq ; ==
1088   09D9 E4            pop a
1089   09DA             ; END RELATIONAL
1090   09DA C0 00 00      cmp b, 0
1091   09DD C6 F0 09      je _while15_exit
1092   09E0             _while15_block:
1093   09E0             ;; str++; 
1094   09E0 FA 05 00      lea d, [bp + 5] ; $str
1095   09E3 2A            mov b, [d]
1096   09E4 D8            push b
1097   09E5 FD 77         inc b
1098   09E7 FA 05 00      lea d, [bp + 5] ; $str
1099   09EA FD 43         mov [d], b
1100   09EC E5            pop b
1101   09ED 0A C9 09      jmp _while15_cond
1102   09F0             _while15_exit:
1103   09F0             ;; if (*str == '-' || *str == '+') { 
1104   09F0             _if16_cond:
1105   09F0 FA 05 00      lea d, [bp + 5] ; $str
1106   09F3 2A            mov b, [d]
1107   09F4 74            mov d, b
1108   09F5 32            mov bl, [d]
1109   09F6 A7 00         mov bh, 0
1110   09F8             ; START RELATIONAL
1111   09F8 D7            push a
1112   09F9 11            mov a, b
1113   09FA 26 2D 00      mov b, $2d
1114   09FD B0            cmp a, b
1115   09FE FD 71         seq ; ==
1116   0A00 E4            pop a
1117   0A01             ; END RELATIONAL
1118   0A01 D7            push a
1119   0A02 11            mov a, b
1120   0A03 FA 05 00      lea d, [bp + 5] ; $str
1121   0A06 2A            mov b, [d]
1122   0A07 74            mov d, b
1123   0A08 32            mov bl, [d]
1124   0A09 A7 00         mov bh, 0
1125   0A0B             ; START RELATIONAL
1126   0A0B D7            push a
1127   0A0C 11            mov a, b
1128   0A0D 26 2B 00      mov b, $2b
1129   0A10 B0            cmp a, b
1130   0A11 FD 71         seq ; ==
1131   0A13 E4            pop a
1132   0A14             ; END RELATIONAL
1133   0A14 FD A8         sor a, b ; ||
1134   0A16 E4            pop a
1135   0A17 C0 00 00      cmp b, 0
1136   0A1A C6 53 0A      je _if16_exit
1137   0A1D             _if16_true:
1138   0A1D             ;; if (*str == '-') sign = -1; 
1139   0A1D             _if17_cond:
1140   0A1D FA 05 00      lea d, [bp + 5] ; $str
1141   0A20 2A            mov b, [d]
1142   0A21 74            mov d, b
1143   0A22 32            mov bl, [d]
1144   0A23 A7 00         mov bh, 0
1145   0A25             ; START RELATIONAL
1146   0A25 D7            push a
1147   0A26 11            mov a, b
1148   0A27 26 2D 00      mov b, $2d
1149   0A2A B0            cmp a, b
1150   0A2B FD 71         seq ; ==
1151   0A2D E4            pop a
1152   0A2E             ; END RELATIONAL
1153   0A2E C0 00 00      cmp b, 0
1154   0A31 C6 43 0A      je _if17_exit
1155   0A34             _if17_true:
1156   0A34             ;; sign = -1; 
1157   0A34 FA FD FF      lea d, [bp + -3] ; $sign
1158   0A37 DA            push d
1159   0A38 26 01 00      mov b, $1
1160   0A3B FD 97         neg b
1161   0A3D E7            pop d
1162   0A3E FD 43         mov [d], b
1163   0A40 0A 43 0A      jmp _if17_exit
1164   0A43             _if17_exit:
1165   0A43             ;; str++; 
1166   0A43 FA 05 00      lea d, [bp + 5] ; $str
1167   0A46 2A            mov b, [d]
1168   0A47 D8            push b
1169   0A48 FD 77         inc b
1170   0A4A FA 05 00      lea d, [bp + 5] ; $str
1171   0A4D FD 43         mov [d], b
1172   0A4F E5            pop b
1173   0A50 0A 53 0A      jmp _if16_exit
1174   0A53             _if16_exit:
1175   0A53             ;; while (*str >= '0' && *str <= '9') { 
1176   0A53             _while18_cond:
1177   0A53 FA 05 00      lea d, [bp + 5] ; $str
1178   0A56 2A            mov b, [d]
1179   0A57 74            mov d, b
1180   0A58 32            mov bl, [d]
1181   0A59 A7 00         mov bh, 0
1182   0A5B             ; START RELATIONAL
1183   0A5B D7            push a
1184   0A5C 11            mov a, b
1185   0A5D 26 30 00      mov b, $30
1186   0A60 B0            cmp a, b
1187   0A61 FD 82         sgeu ; >= (unsigned)
1188   0A63 E4            pop a
1189   0A64             ; END RELATIONAL
1190   0A64 D7            push a
1191   0A65 11            mov a, b
1192   0A66 FA 05 00      lea d, [bp + 5] ; $str
1193   0A69 2A            mov b, [d]
1194   0A6A 74            mov d, b
1195   0A6B 32            mov bl, [d]
1196   0A6C A7 00         mov bh, 0
1197   0A6E             ; START RELATIONAL
1198   0A6E D7            push a
1199   0A6F 11            mov a, b
1200   0A70 26 39 00      mov b, $39
1201   0A73 B0            cmp a, b
1202   0A74 FD 76         sleu ; <= (unsigned)
1203   0A76 E4            pop a
1204   0A77             ; END RELATIONAL
1205   0A77 FD A7         sand a, b ; &&
1206   0A79 E4            pop a
1207   0A7A C0 00 00      cmp b, 0
1208   0A7D C6 B9 0A      je _while18_exit
1209   0A80             _while18_block:
1210   0A80             ;; result = result * 10 + (*str - '0'); 
1211   0A80 FA FF FF      lea d, [bp + -1] ; $result
1212   0A83 DA            push d
1213   0A84 FA FF FF      lea d, [bp + -1] ; $result
1214   0A87 2A            mov b, [d]
1215   0A88             ; START FACTORS
1216   0A88 D7            push a
1217   0A89 11            mov a, b
1218   0A8A 26 0A 00      mov b, $a
1219   0A8D AC            mul a, b ; *
1220   0A8E 11            mov a, b
1221   0A8F 27            mov b, a
1222   0A90 E4            pop a
1223   0A91             ; END FACTORS
1224   0A91             ; START TERMS
1225   0A91 D7            push a
1226   0A92 11            mov a, b
1227   0A93 FA 05 00      lea d, [bp + 5] ; $str
1228   0A96 2A            mov b, [d]
1229   0A97 74            mov d, b
1230   0A98 32            mov bl, [d]
1231   0A99 A7 00         mov bh, 0
1232   0A9B             ; START TERMS
1233   0A9B D7            push a
1234   0A9C 11            mov a, b
1235   0A9D 26 30 00      mov b, $30
1236   0AA0 60            sub a, b
1237   0AA1 27            mov b, a
1238   0AA2 E4            pop a
1239   0AA3             ; END TERMS
1240   0AA3 54            add a, b
1241   0AA4 27            mov b, a
1242   0AA5 E4            pop a
1243   0AA6             ; END TERMS
1244   0AA6 E7            pop d
1245   0AA7 FD 43         mov [d], b
1246   0AA9             ;; str++; 
1247   0AA9 FA 05 00      lea d, [bp + 5] ; $str
1248   0AAC 2A            mov b, [d]
1249   0AAD D8            push b
1250   0AAE FD 77         inc b
1251   0AB0 FA 05 00      lea d, [bp + 5] ; $str
1252   0AB3 FD 43         mov [d], b
1253   0AB5 E5            pop b
1254   0AB6 0A 53 0A      jmp _while18_cond
1255   0AB9             _while18_exit:
1256   0AB9             ;; return sign * result; 
1257   0AB9 FA FD FF      lea d, [bp + -3] ; $sign
1258   0ABC 2A            mov b, [d]
1259   0ABD             ; START FACTORS
1260   0ABD D7            push a
1261   0ABE 11            mov a, b
1262   0ABF FA FF FF      lea d, [bp + -1] ; $result
1263   0AC2 2A            mov b, [d]
1264   0AC3 AC            mul a, b ; *
1265   0AC4 11            mov a, b
1266   0AC5 27            mov b, a
1267   0AC6 E4            pop a
1268   0AC7             ; END FACTORS
1269   0AC7 F9            leave
1270   0AC8 09            ret
1271   0AC9             
1272   0AC9             gets:
1273   0AC9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1274   0ACC             
1275   0ACC             ; --- BEGIN INLINE ASM BLOCK
1276   0ACC FA 05 00      lea d, [bp + 5] ; $s
1277   0ACF 15            mov a, [d]
1278   0AD0 3C            mov d, a
1279   0AD1 07 16 11      call _gets
1280   0AD4             ; --- END INLINE ASM BLOCK
1281   0AD4             
1282   0AD4             ;; return strlen(s); 
1283   0AD4 FA 05 00      lea d, [bp + 5] ; $s
1284   0AD7 2A            mov b, [d]
1285   0AD8 FD AB         swp b
1286   0ADA D8            push b
1287   0ADB 07 9B 05      call strlen
1288   0ADE 51 02 00      add sp, 2
1289   0AE1 F9            leave
1290   0AE2 09            ret
1291   0AE3             
1292   0AE3             print_signed:
1293   0AE3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1294   0AE6             ; $digits 
1295   0AE6             ; $i 
1296   0AE6 10 00 00      mov a, $0
1297   0AE9 45 FA FF      mov [bp + -6], a
1298   0AEC 52 07 00      sub sp, 7
1299   0AEF             ;; if (num < 0) { 
1300   0AEF             _if19_cond:
1301   0AEF FA 05 00      lea d, [bp + 5] ; $num
1302   0AF2 2A            mov b, [d]
1303   0AF3             ; START RELATIONAL
1304   0AF3 D7            push a
1305   0AF4 11            mov a, b
1306   0AF5 26 00 00      mov b, $0
1307   0AF8 B0            cmp a, b
1308   0AF9 FD 73         slt ; < 
1309   0AFB E4            pop a
1310   0AFC             ; END RELATIONAL
1311   0AFC C0 00 00      cmp b, 0
1312   0AFF C6 1C 0B      je _if19_else
1313   0B02             _if19_true:
1314   0B02             ;; putchar('-'); 
1315   0B02 26 2D 00      mov b, $2d
1316   0B05 DD            push bl
1317   0B06 07 E8 0E      call putchar
1318   0B09 51 01 00      add sp, 1
1319   0B0C             ;; num = -num; 
1320   0B0C FA 05 00      lea d, [bp + 5] ; $num
1321   0B0F DA            push d
1322   0B10 FA 05 00      lea d, [bp + 5] ; $num
1323   0B13 2A            mov b, [d]
1324   0B14 FD 97         neg b
1325   0B16 E7            pop d
1326   0B17 FD 43         mov [d], b
1327   0B19 0A 3E 0B      jmp _if19_exit
1328   0B1C             _if19_else:
1329   0B1C             ;; if (num == 0) { 
1330   0B1C             _if20_cond:
1331   0B1C FA 05 00      lea d, [bp + 5] ; $num
1332   0B1F 2A            mov b, [d]
1333   0B20             ; START RELATIONAL
1334   0B20 D7            push a
1335   0B21 11            mov a, b
1336   0B22 26 00 00      mov b, $0
1337   0B25 B0            cmp a, b
1338   0B26 FD 71         seq ; ==
1339   0B28 E4            pop a
1340   0B29             ; END RELATIONAL
1341   0B29 C0 00 00      cmp b, 0
1342   0B2C C6 3E 0B      je _if20_exit
1343   0B2F             _if20_true:
1344   0B2F             ;; putchar('0'); 
1345   0B2F 26 30 00      mov b, $30
1346   0B32 DD            push bl
1347   0B33 07 E8 0E      call putchar
1348   0B36 51 01 00      add sp, 1
1349   0B39             ;; return; 
1350   0B39 F9            leave
1351   0B3A 09            ret
1352   0B3B 0A 3E 0B      jmp _if20_exit
1353   0B3E             _if20_exit:
1354   0B3E             _if19_exit:
1355   0B3E             ;; while (num > 0) { 
1356   0B3E             _while21_cond:
1357   0B3E FA 05 00      lea d, [bp + 5] ; $num
1358   0B41 2A            mov b, [d]
1359   0B42             ; START RELATIONAL
1360   0B42 D7            push a
1361   0B43 11            mov a, b
1362   0B44 26 00 00      mov b, $0
1363   0B47 B0            cmp a, b
1364   0B48 FD 7F         sgt ; >
1365   0B4A E4            pop a
1366   0B4B             ; END RELATIONAL
1367   0B4B C0 00 00      cmp b, 0
1368   0B4E C6 99 0B      je _while21_exit
1369   0B51             _while21_block:
1370   0B51             ;; digits[i] = '0' + (num % 10); 
1371   0B51 FA FC FF      lea d, [bp + -4] ; $digits
1372   0B54 D7            push a
1373   0B55 DA            push d
1374   0B56 FA FA FF      lea d, [bp + -6] ; $i
1375   0B59 2A            mov b, [d]
1376   0B5A E7            pop d
1377   0B5B 5A            add d, b
1378   0B5C E4            pop a
1379   0B5D DA            push d
1380   0B5E 26 30 00      mov b, $30
1381   0B61             ; START TERMS
1382   0B61 D7            push a
1383   0B62 11            mov a, b
1384   0B63 FA 05 00      lea d, [bp + 5] ; $num
1385   0B66 2A            mov b, [d]
1386   0B67             ; START FACTORS
1387   0B67 D7            push a
1388   0B68 11            mov a, b
1389   0B69 26 0A 00      mov b, $a
1390   0B6C AE            div a, b ; 
1391   0B6D 11            mov a, b
1392   0B6E 27            mov b, a
1393   0B6F E4            pop a
1394   0B70             ; END FACTORS
1395   0B70 54            add a, b
1396   0B71 27            mov b, a
1397   0B72 E4            pop a
1398   0B73             ; END TERMS
1399   0B73 E7            pop d
1400   0B74 FD 3E         mov [d], bl
1401   0B76             ;; num = num / 10; 
1402   0B76 FA 05 00      lea d, [bp + 5] ; $num
1403   0B79 DA            push d
1404   0B7A FA 05 00      lea d, [bp + 5] ; $num
1405   0B7D 2A            mov b, [d]
1406   0B7E             ; START FACTORS
1407   0B7E D7            push a
1408   0B7F 11            mov a, b
1409   0B80 26 0A 00      mov b, $a
1410   0B83 AE            div a, b
1411   0B84 27            mov b, a
1412   0B85 E4            pop a
1413   0B86             ; END FACTORS
1414   0B86 E7            pop d
1415   0B87 FD 43         mov [d], b
1416   0B89             ;; i++; 
1417   0B89 FA FA FF      lea d, [bp + -6] ; $i
1418   0B8C 2A            mov b, [d]
1419   0B8D D8            push b
1420   0B8E FD 77         inc b
1421   0B90 FA FA FF      lea d, [bp + -6] ; $i
1422   0B93 FD 43         mov [d], b
1423   0B95 E5            pop b
1424   0B96 0A 3E 0B      jmp _while21_cond
1425   0B99             _while21_exit:
1426   0B99             ;; while (i > 0) { 
1427   0B99             _while22_cond:
1428   0B99 FA FA FF      lea d, [bp + -6] ; $i
1429   0B9C 2A            mov b, [d]
1430   0B9D             ; START RELATIONAL
1431   0B9D D7            push a
1432   0B9E 11            mov a, b
1433   0B9F 26 00 00      mov b, $0
1434   0BA2 B0            cmp a, b
1435   0BA3 FD 7F         sgt ; >
1436   0BA5 E4            pop a
1437   0BA6             ; END RELATIONAL
1438   0BA6 C0 00 00      cmp b, 0
1439   0BA9 C6 D2 0B      je _while22_exit
1440   0BAC             _while22_block:
1441   0BAC             ;; i--; 
1442   0BAC FA FA FF      lea d, [bp + -6] ; $i
1443   0BAF 2A            mov b, [d]
1444   0BB0 D8            push b
1445   0BB1 FD 7D         dec b
1446   0BB3 FA FA FF      lea d, [bp + -6] ; $i
1447   0BB6 FD 43         mov [d], b
1448   0BB8 E5            pop b
1449   0BB9             ;; putchar(digits[i]); 
1450   0BB9 FA FC FF      lea d, [bp + -4] ; $digits
1451   0BBC D7            push a
1452   0BBD DA            push d
1453   0BBE FA FA FF      lea d, [bp + -6] ; $i
1454   0BC1 2A            mov b, [d]
1455   0BC2 E7            pop d
1456   0BC3 5A            add d, b
1457   0BC4 E4            pop a
1458   0BC5 32            mov bl, [d]
1459   0BC6 A7 00         mov bh, 0
1460   0BC8 DD            push bl
1461   0BC9 07 E8 0E      call putchar
1462   0BCC 51 01 00      add sp, 1
1463   0BCF 0A 99 0B      jmp _while22_cond
1464   0BD2             _while22_exit:
1465   0BD2 F9            leave
1466   0BD3 09            ret
1467   0BD4             
1468   0BD4             print_signed_long:
1469   0BD4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1470   0BD7             ; $digits 
1471   0BD7             ; $i 
1472   0BD7 10 00 00      mov a, $0
1473   0BDA 45 F5 FF      mov [bp + -11], a
1474   0BDD 52 0C 00      sub sp, 12
1475   0BE0             ;; if (num < 0) { 
1476   0BE0             _if23_cond:
1477   0BE0 FA 05 00      lea d, [bp + 5] ; $num
1478   0BE3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1479   0BE6 FD 39         mov c, b ; And place it into C
1480   0BE8 2A            mov b, [d] ; Lower Word in B
1481   0BE9             ; START RELATIONAL
1482   0BE9 D7            push a
1483   0BEA FD D8         push g
1484   0BEC 11            mov a, b
1485   0BED FD 7A         mov g, c
1486   0BEF 26 00 00      mov b, $0
1487   0BF2 B0            cmp a, b
1488   0BF3 FD 73         slt ; < 
1489   0BF5 FD F1         pop g
1490   0BF7 E4            pop a
1491   0BF8             ; END RELATIONAL
1492   0BF8 C0 00 00      cmp b, 0
1493   0BFB C6 22 0C      je _if23_else
1494   0BFE             _if23_true:
1495   0BFE             ;; putchar('-'); 
1496   0BFE 26 2D 00      mov b, $2d
1497   0C01 DD            push bl
1498   0C02 07 E8 0E      call putchar
1499   0C05 51 01 00      add sp, 1
1500   0C08             ;; num = -num; 
1501   0C08 FA 05 00      lea d, [bp + 5] ; $num
1502   0C0B DA            push d
1503   0C0C FA 05 00      lea d, [bp + 5] ; $num
1504   0C0F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1505   0C12 FD 39         mov c, b ; And place it into C
1506   0C14 2A            mov b, [d] ; Lower Word in B
1507   0C15 FD 97         neg b
1508   0C17 E7            pop d
1509   0C18 FD 43         mov [d], b
1510   0C1A 28            mov b, c
1511   0C1B FD 44 02 00   mov [d + 2], b
1512   0C1F 0A 59 0C      jmp _if23_exit
1513   0C22             _if23_else:
1514   0C22             ;; if (num == 0) { 
1515   0C22             _if24_cond:
1516   0C22 FA 05 00      lea d, [bp + 5] ; $num
1517   0C25 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1518   0C28 FD 39         mov c, b ; And place it into C
1519   0C2A 2A            mov b, [d] ; Lower Word in B
1520   0C2B             ; START RELATIONAL
1521   0C2B D7            push a
1522   0C2C FD D8         push g
1523   0C2E 11            mov a, b
1524   0C2F FD 7A         mov g, c
1525   0C31 26 00 00      mov b, $0
1526   0C34 B0            cmp a, b
1527   0C35 FD 71         seq ; ==
1528   0C37 D8            push b
1529   0C38 12            mov a, c
1530   0C39 FD 27         mov b, g
1531   0C3B B0            cmp a, b
1532   0C3C FD 71         seq ; ==
1533   0C3E E4            pop a
1534   0C3F FD A7         sand a, b
1535   0C41 FD F1         pop g
1536   0C43 E4            pop a
1537   0C44             ; END RELATIONAL
1538   0C44 C0 00 00      cmp b, 0
1539   0C47 C6 59 0C      je _if24_exit
1540   0C4A             _if24_true:
1541   0C4A             ;; putchar('0'); 
1542   0C4A 26 30 00      mov b, $30
1543   0C4D DD            push bl
1544   0C4E 07 E8 0E      call putchar
1545   0C51 51 01 00      add sp, 1
1546   0C54             ;; return; 
1547   0C54 F9            leave
1548   0C55 09            ret
1549   0C56 0A 59 0C      jmp _if24_exit
1550   0C59             _if24_exit:
1551   0C59             _if23_exit:
1552   0C59             ;; while (num > 0) { 
1553   0C59             _while25_cond:
1554   0C59 FA 05 00      lea d, [bp + 5] ; $num
1555   0C5C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1556   0C5F FD 39         mov c, b ; And place it into C
1557   0C61 2A            mov b, [d] ; Lower Word in B
1558   0C62             ; START RELATIONAL
1559   0C62 D7            push a
1560   0C63 FD D8         push g
1561   0C65 11            mov a, b
1562   0C66 FD 7A         mov g, c
1563   0C68 26 00 00      mov b, $0
1564   0C6B B0            cmp a, b
1565   0C6C FD 7F         sgt ; >
1566   0C6E FD F1         pop g
1567   0C70 E4            pop a
1568   0C71             ; END RELATIONAL
1569   0C71 C0 00 00      cmp b, 0
1570   0C74 C6 CE 0C      je _while25_exit
1571   0C77             _while25_block:
1572   0C77             ;; digits[i] = '0' + (num % 10); 
1573   0C77 FA F7 FF      lea d, [bp + -9] ; $digits
1574   0C7A D7            push a
1575   0C7B DA            push d
1576   0C7C FA F5 FF      lea d, [bp + -11] ; $i
1577   0C7F 2A            mov b, [d]
1578   0C80 E7            pop d
1579   0C81 5A            add d, b
1580   0C82 E4            pop a
1581   0C83 DA            push d
1582   0C84 26 30 00      mov b, $30
1583   0C87             ; START TERMS
1584   0C87 D7            push a
1585   0C88 11            mov a, b
1586   0C89 FA 05 00      lea d, [bp + 5] ; $num
1587   0C8C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1588   0C8F FD 39         mov c, b ; And place it into C
1589   0C91 2A            mov b, [d] ; Lower Word in B
1590   0C92             ; START FACTORS
1591   0C92 D7            push a
1592   0C93 11            mov a, b
1593   0C94 26 0A 00      mov b, $a
1594   0C97 AE            div a, b ; 
1595   0C98 11            mov a, b
1596   0C99 27            mov b, a
1597   0C9A E4            pop a
1598   0C9B             ; END FACTORS
1599   0C9B 54            add a, b
1600   0C9C 27            mov b, a
1601   0C9D E4            pop a
1602   0C9E             ; END TERMS
1603   0C9E E7            pop d
1604   0C9F FD 3E         mov [d], bl
1605   0CA1             ;; num = num / 10; 
1606   0CA1 FA 05 00      lea d, [bp + 5] ; $num
1607   0CA4 DA            push d
1608   0CA5 FA 05 00      lea d, [bp + 5] ; $num
1609   0CA8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1610   0CAB FD 39         mov c, b ; And place it into C
1611   0CAD 2A            mov b, [d] ; Lower Word in B
1612   0CAE             ; START FACTORS
1613   0CAE D7            push a
1614   0CAF 11            mov a, b
1615   0CB0 26 0A 00      mov b, $a
1616   0CB3 AE            div a, b
1617   0CB4 27            mov b, a
1618   0CB5 E4            pop a
1619   0CB6             ; END FACTORS
1620   0CB6 E7            pop d
1621   0CB7 FD 43         mov [d], b
1622   0CB9 28            mov b, c
1623   0CBA FD 44 02 00   mov [d + 2], b
1624   0CBE             ;; i++; 
1625   0CBE FA F5 FF      lea d, [bp + -11] ; $i
1626   0CC1 2A            mov b, [d]
1627   0CC2 D8            push b
1628   0CC3 FD 77         inc b
1629   0CC5 FA F5 FF      lea d, [bp + -11] ; $i
1630   0CC8 FD 43         mov [d], b
1631   0CCA E5            pop b
1632   0CCB 0A 59 0C      jmp _while25_cond
1633   0CCE             _while25_exit:
1634   0CCE             ;; while (i > 0) { 
1635   0CCE             _while26_cond:
1636   0CCE FA F5 FF      lea d, [bp + -11] ; $i
1637   0CD1 2A            mov b, [d]
1638   0CD2             ; START RELATIONAL
1639   0CD2 D7            push a
1640   0CD3 11            mov a, b
1641   0CD4 26 00 00      mov b, $0
1642   0CD7 B0            cmp a, b
1643   0CD8 FD 7F         sgt ; >
1644   0CDA E4            pop a
1645   0CDB             ; END RELATIONAL
1646   0CDB C0 00 00      cmp b, 0
1647   0CDE C6 07 0D      je _while26_exit
1648   0CE1             _while26_block:
1649   0CE1             ;; i--; 
1650   0CE1 FA F5 FF      lea d, [bp + -11] ; $i
1651   0CE4 2A            mov b, [d]
1652   0CE5 D8            push b
1653   0CE6 FD 7D         dec b
1654   0CE8 FA F5 FF      lea d, [bp + -11] ; $i
1655   0CEB FD 43         mov [d], b
1656   0CED E5            pop b
1657   0CEE             ;; putchar(digits[i]); 
1658   0CEE FA F7 FF      lea d, [bp + -9] ; $digits
1659   0CF1 D7            push a
1660   0CF2 DA            push d
1661   0CF3 FA F5 FF      lea d, [bp + -11] ; $i
1662   0CF6 2A            mov b, [d]
1663   0CF7 E7            pop d
1664   0CF8 5A            add d, b
1665   0CF9 E4            pop a
1666   0CFA 32            mov bl, [d]
1667   0CFB A7 00         mov bh, 0
1668   0CFD DD            push bl
1669   0CFE 07 E8 0E      call putchar
1670   0D01 51 01 00      add sp, 1
1671   0D04 0A CE 0C      jmp _while26_cond
1672   0D07             _while26_exit:
1673   0D07 F9            leave
1674   0D08 09            ret
1675   0D09             
1676   0D09             print_unsigned_long:
1677   0D09 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1678   0D0C             ; $digits 
1679   0D0C             ; $i 
1680   0D0C 52 0C 00      sub sp, 12
1681   0D0F             ;; i = 0; 
1682   0D0F FA F5 FF      lea d, [bp + -11] ; $i
1683   0D12 DA            push d
1684   0D13 26 00 00      mov b, $0
1685   0D16 E7            pop d
1686   0D17 FD 43         mov [d], b
1687   0D19             ;; if(num == 0){ 
1688   0D19             _if27_cond:
1689   0D19 FA 05 00      lea d, [bp + 5] ; $num
1690   0D1C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1691   0D1F FD 39         mov c, b ; And place it into C
1692   0D21 2A            mov b, [d] ; Lower Word in B
1693   0D22             ; START RELATIONAL
1694   0D22 D7            push a
1695   0D23 FD D8         push g
1696   0D25 11            mov a, b
1697   0D26 FD 7A         mov g, c
1698   0D28 26 00 00      mov b, $0
1699   0D2B B0            cmp a, b
1700   0D2C FD 71         seq ; ==
1701   0D2E D8            push b
1702   0D2F 12            mov a, c
1703   0D30 FD 27         mov b, g
1704   0D32 B0            cmp a, b
1705   0D33 FD 71         seq ; ==
1706   0D35 E4            pop a
1707   0D36 FD A7         sand a, b
1708   0D38 FD F1         pop g
1709   0D3A E4            pop a
1710   0D3B             ; END RELATIONAL
1711   0D3B C0 00 00      cmp b, 0
1712   0D3E C6 50 0D      je _if27_exit
1713   0D41             _if27_true:
1714   0D41             ;; putchar('0'); 
1715   0D41 26 30 00      mov b, $30
1716   0D44 DD            push bl
1717   0D45 07 E8 0E      call putchar
1718   0D48 51 01 00      add sp, 1
1719   0D4B             ;; return; 
1720   0D4B F9            leave
1721   0D4C 09            ret
1722   0D4D 0A 50 0D      jmp _if27_exit
1723   0D50             _if27_exit:
1724   0D50             ;; while (num > 0) { 
1725   0D50             _while28_cond:
1726   0D50 FA 05 00      lea d, [bp + 5] ; $num
1727   0D53 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1728   0D56 FD 39         mov c, b ; And place it into C
1729   0D58 2A            mov b, [d] ; Lower Word in B
1730   0D59             ; START RELATIONAL
1731   0D59 D7            push a
1732   0D5A FD D8         push g
1733   0D5C 11            mov a, b
1734   0D5D FD 7A         mov g, c
1735   0D5F 26 00 00      mov b, $0
1736   0D62 B0            cmp a, b
1737   0D63 FD 81         sgu ; > (unsigned)
1738   0D65 FD F1         pop g
1739   0D67 E4            pop a
1740   0D68             ; END RELATIONAL
1741   0D68 C0 00 00      cmp b, 0
1742   0D6B C6 C5 0D      je _while28_exit
1743   0D6E             _while28_block:
1744   0D6E             ;; digits[i] = '0' + (num % 10); 
1745   0D6E FA F7 FF      lea d, [bp + -9] ; $digits
1746   0D71 D7            push a
1747   0D72 DA            push d
1748   0D73 FA F5 FF      lea d, [bp + -11] ; $i
1749   0D76 2A            mov b, [d]
1750   0D77 E7            pop d
1751   0D78 5A            add d, b
1752   0D79 E4            pop a
1753   0D7A DA            push d
1754   0D7B 26 30 00      mov b, $30
1755   0D7E             ; START TERMS
1756   0D7E D7            push a
1757   0D7F 11            mov a, b
1758   0D80 FA 05 00      lea d, [bp + 5] ; $num
1759   0D83 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1760   0D86 FD 39         mov c, b ; And place it into C
1761   0D88 2A            mov b, [d] ; Lower Word in B
1762   0D89             ; START FACTORS
1763   0D89 D7            push a
1764   0D8A 11            mov a, b
1765   0D8B 26 0A 00      mov b, $a
1766   0D8E AE            div a, b ; 
1767   0D8F 11            mov a, b
1768   0D90 27            mov b, a
1769   0D91 E4            pop a
1770   0D92             ; END FACTORS
1771   0D92 54            add a, b
1772   0D93 27            mov b, a
1773   0D94 E4            pop a
1774   0D95             ; END TERMS
1775   0D95 E7            pop d
1776   0D96 FD 3E         mov [d], bl
1777   0D98             ;; num = num / 10; 
1778   0D98 FA 05 00      lea d, [bp + 5] ; $num
1779   0D9B DA            push d
1780   0D9C FA 05 00      lea d, [bp + 5] ; $num
1781   0D9F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1782   0DA2 FD 39         mov c, b ; And place it into C
1783   0DA4 2A            mov b, [d] ; Lower Word in B
1784   0DA5             ; START FACTORS
1785   0DA5 D7            push a
1786   0DA6 11            mov a, b
1787   0DA7 26 0A 00      mov b, $a
1788   0DAA AE            div a, b
1789   0DAB 27            mov b, a
1790   0DAC E4            pop a
1791   0DAD             ; END FACTORS
1792   0DAD E7            pop d
1793   0DAE FD 43         mov [d], b
1794   0DB0 28            mov b, c
1795   0DB1 FD 44 02 00   mov [d + 2], b
1796   0DB5             ;; i++; 
1797   0DB5 FA F5 FF      lea d, [bp + -11] ; $i
1798   0DB8 2A            mov b, [d]
1799   0DB9 D8            push b
1800   0DBA FD 77         inc b
1801   0DBC FA F5 FF      lea d, [bp + -11] ; $i
1802   0DBF FD 43         mov [d], b
1803   0DC1 E5            pop b
1804   0DC2 0A 50 0D      jmp _while28_cond
1805   0DC5             _while28_exit:
1806   0DC5             ;; while (i > 0) { 
1807   0DC5             _while29_cond:
1808   0DC5 FA F5 FF      lea d, [bp + -11] ; $i
1809   0DC8 2A            mov b, [d]
1810   0DC9             ; START RELATIONAL
1811   0DC9 D7            push a
1812   0DCA 11            mov a, b
1813   0DCB 26 00 00      mov b, $0
1814   0DCE B0            cmp a, b
1815   0DCF FD 7F         sgt ; >
1816   0DD1 E4            pop a
1817   0DD2             ; END RELATIONAL
1818   0DD2 C0 00 00      cmp b, 0
1819   0DD5 C6 FE 0D      je _while29_exit
1820   0DD8             _while29_block:
1821   0DD8             ;; i--; 
1822   0DD8 FA F5 FF      lea d, [bp + -11] ; $i
1823   0DDB 2A            mov b, [d]
1824   0DDC D8            push b
1825   0DDD FD 7D         dec b
1826   0DDF FA F5 FF      lea d, [bp + -11] ; $i
1827   0DE2 FD 43         mov [d], b
1828   0DE4 E5            pop b
1829   0DE5             ;; putchar(digits[i]); 
1830   0DE5 FA F7 FF      lea d, [bp + -9] ; $digits
1831   0DE8 D7            push a
1832   0DE9 DA            push d
1833   0DEA FA F5 FF      lea d, [bp + -11] ; $i
1834   0DED 2A            mov b, [d]
1835   0DEE E7            pop d
1836   0DEF 5A            add d, b
1837   0DF0 E4            pop a
1838   0DF1 32            mov bl, [d]
1839   0DF2 A7 00         mov bh, 0
1840   0DF4 DD            push bl
1841   0DF5 07 E8 0E      call putchar
1842   0DF8 51 01 00      add sp, 1
1843   0DFB 0A C5 0D      jmp _while29_cond
1844   0DFE             _while29_exit:
1845   0DFE F9            leave
1846   0DFF 09            ret
1847   0E00             
1848   0E00             print_unsigned:
1849   0E00 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1850   0E03             ; $digits 
1851   0E03             ; $i 
1852   0E03 52 07 00      sub sp, 7
1853   0E06             ;; i = 0; 
1854   0E06 FA FA FF      lea d, [bp + -6] ; $i
1855   0E09 DA            push d
1856   0E0A 26 00 00      mov b, $0
1857   0E0D E7            pop d
1858   0E0E FD 43         mov [d], b
1859   0E10             ;; if(num == 0){ 
1860   0E10             _if30_cond:
1861   0E10 FA 05 00      lea d, [bp + 5] ; $num
1862   0E13 2A            mov b, [d]
1863   0E14             ; START RELATIONAL
1864   0E14 D7            push a
1865   0E15 11            mov a, b
1866   0E16 26 00 00      mov b, $0
1867   0E19 B0            cmp a, b
1868   0E1A FD 71         seq ; ==
1869   0E1C E4            pop a
1870   0E1D             ; END RELATIONAL
1871   0E1D C0 00 00      cmp b, 0
1872   0E20 C6 32 0E      je _if30_exit
1873   0E23             _if30_true:
1874   0E23             ;; putchar('0'); 
1875   0E23 26 30 00      mov b, $30
1876   0E26 DD            push bl
1877   0E27 07 E8 0E      call putchar
1878   0E2A 51 01 00      add sp, 1
1879   0E2D             ;; return; 
1880   0E2D F9            leave
1881   0E2E 09            ret
1882   0E2F 0A 32 0E      jmp _if30_exit
1883   0E32             _if30_exit:
1884   0E32             ;; while (num > 0) { 
1885   0E32             _while31_cond:
1886   0E32 FA 05 00      lea d, [bp + 5] ; $num
1887   0E35 2A            mov b, [d]
1888   0E36             ; START RELATIONAL
1889   0E36 D7            push a
1890   0E37 11            mov a, b
1891   0E38 26 00 00      mov b, $0
1892   0E3B B0            cmp a, b
1893   0E3C FD 81         sgu ; > (unsigned)
1894   0E3E E4            pop a
1895   0E3F             ; END RELATIONAL
1896   0E3F C0 00 00      cmp b, 0
1897   0E42 C6 8D 0E      je _while31_exit
1898   0E45             _while31_block:
1899   0E45             ;; digits[i] = '0' + (num % 10); 
1900   0E45 FA FC FF      lea d, [bp + -4] ; $digits
1901   0E48 D7            push a
1902   0E49 DA            push d
1903   0E4A FA FA FF      lea d, [bp + -6] ; $i
1904   0E4D 2A            mov b, [d]
1905   0E4E E7            pop d
1906   0E4F 5A            add d, b
1907   0E50 E4            pop a
1908   0E51 DA            push d
1909   0E52 26 30 00      mov b, $30
1910   0E55             ; START TERMS
1911   0E55 D7            push a
1912   0E56 11            mov a, b
1913   0E57 FA 05 00      lea d, [bp + 5] ; $num
1914   0E5A 2A            mov b, [d]
1915   0E5B             ; START FACTORS
1916   0E5B D7            push a
1917   0E5C 11            mov a, b
1918   0E5D 26 0A 00      mov b, $a
1919   0E60 AE            div a, b ; 
1920   0E61 11            mov a, b
1921   0E62 27            mov b, a
1922   0E63 E4            pop a
1923   0E64             ; END FACTORS
1924   0E64 54            add a, b
1925   0E65 27            mov b, a
1926   0E66 E4            pop a
1927   0E67             ; END TERMS
1928   0E67 E7            pop d
1929   0E68 FD 3E         mov [d], bl
1930   0E6A             ;; num = num / 10; 
1931   0E6A FA 05 00      lea d, [bp + 5] ; $num
1932   0E6D DA            push d
1933   0E6E FA 05 00      lea d, [bp + 5] ; $num
1934   0E71 2A            mov b, [d]
1935   0E72             ; START FACTORS
1936   0E72 D7            push a
1937   0E73 11            mov a, b
1938   0E74 26 0A 00      mov b, $a
1939   0E77 AE            div a, b
1940   0E78 27            mov b, a
1941   0E79 E4            pop a
1942   0E7A             ; END FACTORS
1943   0E7A E7            pop d
1944   0E7B FD 43         mov [d], b
1945   0E7D             ;; i++; 
1946   0E7D FA FA FF      lea d, [bp + -6] ; $i
1947   0E80 2A            mov b, [d]
1948   0E81 D8            push b
1949   0E82 FD 77         inc b
1950   0E84 FA FA FF      lea d, [bp + -6] ; $i
1951   0E87 FD 43         mov [d], b
1952   0E89 E5            pop b
1953   0E8A 0A 32 0E      jmp _while31_cond
1954   0E8D             _while31_exit:
1955   0E8D             ;; while (i > 0) { 
1956   0E8D             _while32_cond:
1957   0E8D FA FA FF      lea d, [bp + -6] ; $i
1958   0E90 2A            mov b, [d]
1959   0E91             ; START RELATIONAL
1960   0E91 D7            push a
1961   0E92 11            mov a, b
1962   0E93 26 00 00      mov b, $0
1963   0E96 B0            cmp a, b
1964   0E97 FD 7F         sgt ; >
1965   0E99 E4            pop a
1966   0E9A             ; END RELATIONAL
1967   0E9A C0 00 00      cmp b, 0
1968   0E9D C6 C6 0E      je _while32_exit
1969   0EA0             _while32_block:
1970   0EA0             ;; i--; 
1971   0EA0 FA FA FF      lea d, [bp + -6] ; $i
1972   0EA3 2A            mov b, [d]
1973   0EA4 D8            push b
1974   0EA5 FD 7D         dec b
1975   0EA7 FA FA FF      lea d, [bp + -6] ; $i
1976   0EAA FD 43         mov [d], b
1977   0EAC E5            pop b
1978   0EAD             ;; putchar(digits[i]); 
1979   0EAD FA FC FF      lea d, [bp + -4] ; $digits
1980   0EB0 D7            push a
1981   0EB1 DA            push d
1982   0EB2 FA FA FF      lea d, [bp + -6] ; $i
1983   0EB5 2A            mov b, [d]
1984   0EB6 E7            pop d
1985   0EB7 5A            add d, b
1986   0EB8 E4            pop a
1987   0EB9 32            mov bl, [d]
1988   0EBA A7 00         mov bh, 0
1989   0EBC DD            push bl
1990   0EBD 07 E8 0E      call putchar
1991   0EC0 51 01 00      add sp, 1
1992   0EC3 0A 8D 0E      jmp _while32_cond
1993   0EC6             _while32_exit:
1994   0EC6 F9            leave
1995   0EC7 09            ret
1996   0EC8             
1997   0EC8             rand:
1998   0EC8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1999   0ECB             ; $sec 
2000   0ECB 52 01 00      sub sp, 1
2001   0ECE             
2002   0ECE             ; --- BEGIN INLINE ASM BLOCK
2003   0ECE 19 00         mov al, 0
2004   0ED0 05 01         syscall sys_rtc					
2005   0ED2 1A            mov al, ah
2006   0ED3 FA 00 00      lea d, [bp + 0] ; $sec
2007   0ED6 1E            mov al, [d]
2008   0ED7             ; --- END INLINE ASM BLOCK
2009   0ED7             
2010   0ED7             ;; return sec; 
2011   0ED7 FA 00 00      lea d, [bp + 0] ; $sec
2012   0EDA 32            mov bl, [d]
2013   0EDB A7 00         mov bh, 0
2014   0EDD F9            leave
2015   0EDE 09            ret
2016   0EDF             
2017   0EDF             date:
2018   0EDF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2019   0EE2             
2020   0EE2             ; --- BEGIN INLINE ASM BLOCK
2021   0EE2 19 00         mov al, 0 
2022   0EE4 05 07         syscall sys_datetime
2023   0EE6             ; --- END INLINE ASM BLOCK
2024   0EE6             
2025   0EE6 F9            leave
2026   0EE7 09            ret
2027   0EE8             
2028   0EE8             putchar:
2029   0EE8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2030   0EEB             
2031   0EEB             ; --- BEGIN INLINE ASM BLOCK
2032   0EEB FA 05 00      lea d, [bp + 5] ; $c
2033   0EEE 1E            mov al, [d]
2034   0EEF 23            mov ah, al
2035   0EF0 07 0F 11      call _putchar
2036   0EF3             ; --- END INLINE ASM BLOCK
2037   0EF3             
2038   0EF3 F9            leave
2039   0EF4 09            ret
2040   0EF5             
2041   0EF5             getchar:
2042   0EF5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2043   0EF8             ; $c 
2044   0EF8 52 01 00      sub sp, 1
2045   0EFB             
2046   0EFB             ; --- BEGIN INLINE ASM BLOCK
2047   0EFB 07 08 11      call getch
2048   0EFE 1A            mov al, ah
2049   0EFF FA 00 00      lea d, [bp + 0] ; $c
2050   0F02 3E            mov [d], al
2051   0F03             ; --- END INLINE ASM BLOCK
2052   0F03             
2053   0F03             ;; return c; 
2054   0F03 FA 00 00      lea d, [bp + 0] ; $c
2055   0F06 32            mov bl, [d]
2056   0F07 A7 00         mov bh, 0
2057   0F09 F9            leave
2058   0F0A 09            ret
2059   0F0B             
2060   0F0B             scann:
2061   0F0B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2062   0F0E             ; $m 
2063   0F0E 52 02 00      sub sp, 2
2064   0F11             
2065   0F11             ; --- BEGIN INLINE ASM BLOCK
2066   0F11 07 53 13      call scan_u16d
2067   0F14 FA FF FF      lea d, [bp + -1] ; $m
2068   0F17 43            mov [d], a
2069   0F18             ; --- END INLINE ASM BLOCK
2070   0F18             
2071   0F18             ;; return m; 
2072   0F18 FA FF FF      lea d, [bp + -1] ; $m
2073   0F1B 2A            mov b, [d]
2074   0F1C F9            leave
2075   0F1D 09            ret
2076   0F1E             
2077   0F1E             puts:
2078   0F1E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2079   0F21             
2080   0F21             ; --- BEGIN INLINE ASM BLOCK
2081   0F21 FA 05 00      lea d, [bp + 5] ; $s
2082   0F24 15            mov a, [d]
2083   0F25 3C            mov d, a
2084   0F26 07 59 12      call _puts
2085   0F29 10 00 0A      mov a, $0A00
2086   0F2C 05 03         syscall sys_io
2087   0F2E             ; --- END INLINE ASM BLOCK
2088   0F2E             
2089   0F2E F9            leave
2090   0F2F 09            ret
2091   0F30             
2092   0F30             print:
2093   0F30 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2094   0F33             
2095   0F33             ; --- BEGIN INLINE ASM BLOCK
2096   0F33 FA 05 00      lea d, [bp + 5] ; $s
2097   0F36 FD 2A         mov d, [d]
2098   0F38 07 59 12      call _puts
2099   0F3B             ; --- END INLINE ASM BLOCK
2100   0F3B             
2101   0F3B F9            leave
2102   0F3C 09            ret
2103   0F3D             
2104   0F3D             loadfile:
2105   0F3D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2106   0F40             
2107   0F40             ; --- BEGIN INLINE ASM BLOCK
2108   0F40 FA 07 00      lea d, [bp + 7] ; $destination
2109   0F43 15            mov a, [d]
2110   0F44 4F            mov di, a
2111   0F45 FA 05 00      lea d, [bp + 5] ; $filename
2112   0F48 FD 2A         mov d, [d]
2113   0F4A 19 14         mov al, 20
2114   0F4C 05 04         syscall sys_filesystem
2115   0F4E             ; --- END INLINE ASM BLOCK
2116   0F4E             
2117   0F4E F9            leave
2118   0F4F 09            ret
2119   0F50             
2120   0F50             create_file:
2121   0F50 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2122   0F53 F9            leave
2123   0F54 09            ret
2124   0F55             
2125   0F55             delete_file:
2126   0F55 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2127   0F58             
2128   0F58             ; --- BEGIN INLINE ASM BLOCK
2129   0F58 FA 05 00      lea d, [bp + 5] ; $filename
2130   0F5B 19 0A         mov al, 10
2131   0F5D 05 04         syscall sys_filesystem
2132   0F5F             ; --- END INLINE ASM BLOCK
2133   0F5F             
2134   0F5F F9            leave
2135   0F60 09            ret
2136   0F61             
2137   0F61             fopen:
2138   0F61 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2139   0F64 F9            leave
2140   0F65 09            ret
2141   0F66             
2142   0F66             fclose:
2143   0F66 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2144   0F69 F9            leave
2145   0F6A 09            ret
2146   0F6B             
2147   0F6B             alloc:
2148   0F6B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2149   0F6E             ;; heap_top = heap_top + bytes; 
2150   0F6E 3B 47 18      mov d, _heap_top ; $heap_top
2151   0F71 DA            push d
2152   0F72 3B 47 18      mov d, _heap_top ; $heap_top
2153   0F75 2A            mov b, [d]
2154   0F76             ; START TERMS
2155   0F76 D7            push a
2156   0F77 11            mov a, b
2157   0F78 FA 05 00      lea d, [bp + 5] ; $bytes
2158   0F7B 2A            mov b, [d]
2159   0F7C 54            add a, b
2160   0F7D 27            mov b, a
2161   0F7E E4            pop a
2162   0F7F             ; END TERMS
2163   0F7F E7            pop d
2164   0F80 FD 43         mov [d], b
2165   0F82             ;; return heap_top - bytes; 
2166   0F82 3B 47 18      mov d, _heap_top ; $heap_top
2167   0F85 2A            mov b, [d]
2168   0F86             ; START TERMS
2169   0F86 D7            push a
2170   0F87 11            mov a, b
2171   0F88 FA 05 00      lea d, [bp + 5] ; $bytes
2172   0F8B 2A            mov b, [d]
2173   0F8C 60            sub a, b
2174   0F8D 27            mov b, a
2175   0F8E E4            pop a
2176   0F8F             ; END TERMS
2177   0F8F F9            leave
2178   0F90 09            ret
2179   0F91             
2180   0F91             free:
2181   0F91 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2182   0F94             ;; return heap_top = heap_top - bytes; 
2183   0F94 3B 47 18      mov d, _heap_top ; $heap_top
2184   0F97 DA            push d
2185   0F98 3B 47 18      mov d, _heap_top ; $heap_top
2186   0F9B 2A            mov b, [d]
2187   0F9C             ; START TERMS
2188   0F9C D7            push a
2189   0F9D 11            mov a, b
2190   0F9E FA 05 00      lea d, [bp + 5] ; $bytes
2191   0FA1 2A            mov b, [d]
2192   0FA2 60            sub a, b
2193   0FA3 27            mov b, a
2194   0FA4 E4            pop a
2195   0FA5             ; END TERMS
2196   0FA5 E7            pop d
2197   0FA6 FD 43         mov [d], b
2198   0FA8 F9            leave
2199   0FA9 09            ret
2200   0FAA             
2201   0FAA             exit:
2202   0FAA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2203   0FAD             
2204   0FAD             ; --- BEGIN INLINE ASM BLOCK
2205   0FAD 05 0B         syscall sys_terminate_proc
2206   0FAF             ; --- END INLINE ASM BLOCK
2207   0FAF             
2208   0FAF F9            leave
2209   0FB0 09            ret
2210   0FB1             
2211   0FB1             load_hex:
2212   0FB1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2213   0FB4             ; $temp 
2214   0FB4 52 02 00      sub sp, 2
2215   0FB7             ;; temp = alloc(32768); 
2216   0FB7 FA FF FF      lea d, [bp + -1] ; $temp
2217   0FBA DA            push d
2218   0FBB 26 00 80      mov b, $8000
2219   0FBE FD AB         swp b
2220   0FC0 D8            push b
2221   0FC1 07 6B 0F      call alloc
2222   0FC4 51 02 00      add sp, 2
2223   0FC7 E7            pop d
2224   0FC8 FD 43         mov [d], b
2225   0FCA             
2226   0FCA             ; --- BEGIN INLINE ASM BLOCK
2227   0FCA               
2228   0FCA               
2229   0FCA               
2230   0FCA               
2231   0FCA               
2232   0FCA             _load_hex:
2233   0FCA D7            push a
2234   0FCB D8            push b
2235   0FCC DA            push d
2236   0FCD E2            push si
2237   0FCE E3            push di
2238   0FCF 52 00 80      sub sp, $8000      
2239   0FD2 38 00 00      mov c, 0
2240   0FD5 48            mov a, sp
2241   0FD6 77            inc a
2242   0FD7 3C            mov d, a          
2243   0FD8 07 16 11      call _gets        
2244   0FDB 4D            mov si, a
2245   0FDC             __load_hex_loop:
2246   0FDC F6            lodsb             
2247   0FDD B9 00         cmp al, 0         
2248   0FDF C6 ED 0F      jz __load_hex_ret
2249   0FE2 36            mov bh, al
2250   0FE3 F6            lodsb
2251   0FE4 2F            mov bl, al
2252   0FE5 07 CC 10      call _atoi        
2253   0FE8 F7            stosb             
2254   0FE9 78            inc c
2255   0FEA 0A DC 0F      jmp __load_hex_loop
2256   0FED             __load_hex_ret:
2257   0FED 51 00 80      add sp, $8000
2258   0FF0 F0            pop di
2259   0FF1 EF            pop si
2260   0FF2 E7            pop d
2261   0FF3 E5            pop b
2262   0FF4 E4            pop a
2263   0FF5             ; --- END INLINE ASM BLOCK
2264   0FF5             
2265   0FF5 F9            leave
2266   0FF6 09            ret
2267   0FF7             
2268   0FF7             getparam:
2269   0FF7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2270   0FFA             ; $data 
2271   0FFA 52 01 00      sub sp, 1
2272   0FFD             
2273   0FFD             ; --- BEGIN INLINE ASM BLOCK
2274   0FFD 19 04         mov al, 4
2275   0FFF FA 05 00      lea d, [bp + 5] ; $address
2276   1002 FD 2A         mov d, [d]
2277   1004 05 0C         syscall sys_system
2278   1006 FA 00 00      lea d, [bp + 0] ; $data
2279   1009 FD 3E         mov [d], bl
2280   100B             ; --- END INLINE ASM BLOCK
2281   100B             
2282   100B             ;; return data; 
2283   100B FA 00 00      lea d, [bp + 0] ; $data
2284   100E 32            mov bl, [d]
2285   100F A7 00         mov bh, 0
2286   1011 F9            leave
2287   1012 09            ret
2288   1013             
2289   1013             clear:
2290   1013 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2291   1016             ;; print("\033[2J\033[H"); 
2292   1016 26 3F 18      mov b, __s4 ; "\033[2J\033[H"
2293   1019 FD AB         swp b
2294   101B D8            push b
2295   101C 07 30 0F      call print
2296   101F 51 02 00      add sp, 2
2297   1022 F9            leave
2298   1023 09            ret
2299   1024             
2300   1024             include_stdio_asm:
2301   1024 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2302   1027             
2303   1027             ; --- BEGIN INLINE ASM BLOCK
2304   1027             .include "lib/asm/stdio.asm"
0001+  1027             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1027             ; stdio.s
0003+  1027             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1027             .include "lib/asm/string.asm"
0001++ 1027             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1027             ; string.s
0003++ 1027             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1027             
0005++ 1027             
0006++ 1027             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1027             ; _strrev
0008++ 1027             ; reverse a string
0009++ 1027             ; D = string address
0010++ 1027             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1027             ; 01234
0012++ 1027             _strrev:
0013++ 1027 4B          	pusha
0014++ 1028 07 6E 10    	call _strlen	; length in C
0015++ 102B 12          	mov a, c
0016++ 102C AF 01 00    	cmp a, 1
0017++ 102F D0 49 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1032 7D          	dec a
0019++ 1033 FD 4E       	mov si, d	; beginning of string
0020++ 1035 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1037 59          	add d, a	; end of string
0022++ 1038 12          	mov a, c
0023++ 1039 FD 9B       	shr a		; divide by 2
0024++ 103B 39          	mov c, a	; C now counts the steps
0025++ 103C             _strrev_L0:
0026++ 103C 32          	mov bl, [d]	; save load right-side char into BL
0027++ 103D F6          	lodsb		; load left-side char into AL; increase SI
0028++ 103E 3E          	mov [d], al	; store left char into right side
0029++ 103F 1B          	mov al, bl
0030++ 1040 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1041 7E          	dec c
0032++ 1042 7F          	dec d
0033++ 1043 C2 00 00    	cmp c, 0
0034++ 1046 C7 3C 10    	jne _strrev_L0
0035++ 1049             _strrev_end:
0036++ 1049 4C          	popa
0037++ 104A 09          	ret
0038++ 104B             	
0039++ 104B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 104B             ; _strchr
0041++ 104B             ; search string in D for char in AL
0042++ 104B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 104B             _strchr:
0044++ 104B             _strchr_L0:
0045++ 104B 32          	mov bl, [d]
0046++ 104C C1 00       	cmp bl, 0
0047++ 104E C6 59 10    	je _strchr_end
0048++ 1051 BA          	cmp al, bl
0049++ 1052 C6 59 10    	je _strchr_end
0050++ 1055 79          	inc d
0051++ 1056 0A 4B 10    	jmp _strchr_L0
0052++ 1059             _strchr_end:
0053++ 1059 1B          	mov al, bl
0054++ 105A 09          	ret
0055++ 105B             
0056++ 105B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 105B             ; _strstr
0058++ 105B             ; find sub-string
0059++ 105B             ; str1 in SI
0060++ 105B             ; str2 in DI
0061++ 105B             ; SI points to end of source string
0062++ 105B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 105B             _strstr:
0064++ 105B DB          	push al
0065++ 105C DA          	push d
0066++ 105D E3          	push di
0067++ 105E             _strstr_loop:
0068++ 105E F3          	cmpsb					; compare a byte of the strings
0069++ 105F C7 6A 10    	jne _strstr_ret
0070++ 1062 FC 00 00    	lea d, [di + 0]
0071++ 1065 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1067 C7 5E 10    	jne _strstr_loop				; equal chars but not at end
0073++ 106A             _strstr_ret:
0074++ 106A F0          	pop di
0075++ 106B E7          	pop d
0076++ 106C E8          	pop al
0077++ 106D 09          	ret
0078++ 106E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 106E             ; length of null terminated string
0080++ 106E             ; result in C
0081++ 106E             ; pointer in D
0082++ 106E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 106E             _strlen:
0084++ 106E DA          	push d
0085++ 106F 38 00 00    	mov c, 0
0086++ 1072             _strlen_L1:
0087++ 1072 BD 00       	cmp byte [d], 0
0088++ 1074 C6 7C 10    	je _strlen_ret
0089++ 1077 79          	inc d
0090++ 1078 78          	inc c
0091++ 1079 0A 72 10    	jmp _strlen_L1
0092++ 107C             _strlen_ret:
0093++ 107C E7          	pop d
0094++ 107D 09          	ret
0095++ 107E             
0096++ 107E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 107E             ; STRCMP
0098++ 107E             ; compare two strings
0099++ 107E             ; str1 in SI
0100++ 107E             ; str2 in DI
0101++ 107E             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 107E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 107E             _strcmp:
0104++ 107E DB          	push al
0105++ 107F DA          	push d
0106++ 1080 E3          	push di
0107++ 1081 E2          	push si
0108++ 1082             _strcmp_loop:
0109++ 1082 F3          	cmpsb					; compare a byte of the strings
0110++ 1083 C7 8E 10    	jne _strcmp_ret
0111++ 1086 FB FF FF    	lea d, [si +- 1]
0112++ 1089 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 108B C7 82 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 108E             _strcmp_ret:
0115++ 108E EF          	pop si
0116++ 108F F0          	pop di
0117++ 1090 E7          	pop d
0118++ 1091 E8          	pop al
0119++ 1092 09          	ret
0120++ 1093             
0121++ 1093             
0122++ 1093             ; STRCPY
0123++ 1093             ; copy null terminated string from SI to DI
0124++ 1093             ; source in SI
0125++ 1093             ; destination in DI
0126++ 1093             _strcpy:
0127++ 1093 E2          	push si
0128++ 1094 E3          	push di
0129++ 1095 DB          	push al
0130++ 1096             _strcpy_L1:
0131++ 1096 F6          	lodsb
0132++ 1097 F7          	stosb
0133++ 1098 B9 00       	cmp al, 0
0134++ 109A C7 96 10    	jne _strcpy_L1
0135++ 109D             _strcpy_end:
0136++ 109D E8          	pop al
0137++ 109E F0          	pop di
0138++ 109F EF          	pop si
0139++ 10A0 09          	ret
0140++ 10A1             
0141++ 10A1             ; STRCAT
0142++ 10A1             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 10A1             ; source in SI
0144++ 10A1             ; destination in DI
0145++ 10A1             _strcat:
0146++ 10A1 E2          	push si
0147++ 10A2 E3          	push di
0148++ 10A3 D7          	push a
0149++ 10A4 DA          	push d
0150++ 10A5 50          	mov a, di
0151++ 10A6 3C          	mov d, a
0152++ 10A7             _strcat_goto_end_L1:
0153++ 10A7 BD 00       	cmp byte[d], 0
0154++ 10A9 C6 B0 10    	je _strcat_start
0155++ 10AC 79          	inc d
0156++ 10AD 0A A7 10    	jmp _strcat_goto_end_L1
0157++ 10B0             _strcat_start:
0158++ 10B0 FD 50       	mov di, d
0159++ 10B2             _strcat_L1:
0160++ 10B2 F6          	lodsb
0161++ 10B3 F7          	stosb
0162++ 10B4 B9 00       	cmp al, 0
0163++ 10B6 C7 B2 10    	jne _strcat_L1
0164++ 10B9             _strcat_end:
0165++ 10B9 E7          	pop d
0166++ 10BA E4          	pop a
0167++ 10BB F0          	pop di
0168++ 10BC EF          	pop si
0169++ 10BD 09          	ret
0170++ 10BE             
0171++ 10BE             
0005+  10BE             
0006+  10BE             
0007+  10BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  10BE             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  10BE             ; ASCII in BL
0010+  10BE             ; result in AL
0011+  10BE             ; ascii for F = 0100 0110
0012+  10BE             ; ascii for 9 = 0011 1001
0013+  10BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  10BE             hex_ascii_encode:
0015+  10BE 1B            mov al, bl
0016+  10BF 93 40         test al, $40        ; test if letter or number
0017+  10C1 C7 C7 10      jnz hex_letter
0018+  10C4 87 0F         and al, $0F        ; get number
0019+  10C6 09            ret
0020+  10C7             hex_letter:
0021+  10C7 87 0F         and al, $0F        ; get letter
0022+  10C9 6A 09         add al, 9
0023+  10CB 09            ret
0024+  10CC             
0025+  10CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  10CC             ; ATOI
0027+  10CC             ; 2 letter hex string in B
0028+  10CC             ; 8bit integer returned in AL
0029+  10CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  10CC             _atoi:
0031+  10CC D8            push b
0032+  10CD 07 BE 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  10D0 30            mov bl, bh
0034+  10D1 DB            push al          ; save a
0035+  10D2 07 BE 10      call hex_ascii_encode
0036+  10D5 EA            pop bl  
0037+  10D6 FD 9E 04      shl al, 4
0038+  10D9 8C            or al, bl
0039+  10DA E5            pop b
0040+  10DB 09            ret  
0041+  10DC             
0042+  10DC             
0043+  10DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  10DC             ; scanf
0045+  10DC             ; no need for explanations!
0046+  10DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  10DC             scanf:
0048+  10DC 09            ret
0049+  10DD             
0050+  10DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  10DD             ; ITOA
0052+  10DD             ; 8bit value in BL
0053+  10DD             ; 2 byte ASCII result in A
0054+  10DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  10DD             _itoa:
0056+  10DD DA            push d
0057+  10DE D8            push b
0058+  10DF A7 00         mov bh, 0
0059+  10E1 FD A4 04      shr bl, 4  
0060+  10E4 74            mov d, b
0061+  10E5 1F 8D 13      mov al, [d + s_hex_digits]
0062+  10E8 23            mov ah, al
0063+  10E9               
0064+  10E9 E5            pop b
0065+  10EA D8            push b
0066+  10EB A7 00         mov bh, 0
0067+  10ED FD 87 0F      and bl, $0F
0068+  10F0 74            mov d, b
0069+  10F1 1F 8D 13      mov al, [d + s_hex_digits]
0070+  10F4 E5            pop b
0071+  10F5 E7            pop d
0072+  10F6 09            ret
0073+  10F7             
0074+  10F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  10F7             ; HEX STRING TO BINARY
0076+  10F7             ; di = destination address
0077+  10F7             ; si = source
0078+  10F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  10F7             _hex_to_int:
0080+  10F7             _hex_to_int_L1:
0081+  10F7 F6            lodsb          ; load from [SI] to AL
0082+  10F8 B9 00         cmp al, 0        ; check if ASCII 0
0083+  10FA C6 07 11      jz _hex_to_int_ret
0084+  10FD 36            mov bh, al
0085+  10FE F6            lodsb
0086+  10FF 2F            mov bl, al
0087+  1100 07 CC 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  1103 F7            stosb          ; store AL to [DI]
0089+  1104 0A F7 10      jmp _hex_to_int_L1
0090+  1107             _hex_to_int_ret:
0091+  1107 09            ret    
0092+  1108             
0093+  1108             
0094+  1108             
0095+  1108             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1108             ; GETCHAR
0097+  1108             ; char in ah
0098+  1108             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1108             getch:
0100+  1108 DB            push al
0101+  1109             getch_retry:
0102+  1109 19 01         mov al, 1
0103+  110B 05 03         syscall sys_io      ; receive in AH
0104+  110D E8            pop al
0105+  110E 09            ret
0106+  110F             
0107+  110F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  110F             ; PUTCHAR
0109+  110F             ; char in ah
0110+  110F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  110F             _putchar:
0112+  110F D7            push a
0113+  1110 19 00         mov al, 0
0114+  1112 05 03         syscall sys_io      ; char in AH
0115+  1114 E4            pop a
0116+  1115 09            ret
0117+  1116             
0118+  1116             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1116             ;; INPUT A STRING
0120+  1116             ;; terminates with null
0121+  1116             ;; pointer in D
0122+  1116             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1116             _gets:
0124+  1116 D7            push a
0125+  1117 DA            push d
0126+  1118             _gets_loop:
0127+  1118 19 01         mov al, 1
0128+  111A 05 03         syscall sys_io      ; receive in AH
0129+  111C B9 00         cmp al, 0        ; check error code (AL)
0130+  111E C6 18 11      je _gets_loop      ; if no char received, retry
0131+  1121             
0132+  1121 76 1B         cmp ah, 27
0133+  1123 C6 44 11      je _gets_ansi_esc
0134+  1126 76 0A         cmp ah, $0A        ; LF
0135+  1128 C6 AF 11      je _gets_end
0136+  112B 76 0D         cmp ah, $0D        ; CR
0137+  112D C6 AF 11      je _gets_end
0138+  1130 76 5C         cmp ah, $5C        ; '\\'
0139+  1132 C6 70 11      je _gets_escape
0140+  1135               
0141+  1135 76 08         cmp ah, $08      ; check for backspace
0142+  1137 C6 40 11      je _gets_backspace
0143+  113A             
0144+  113A 1A            mov al, ah
0145+  113B 3E            mov [d], al
0146+  113C 79            inc d
0147+  113D 0A 18 11      jmp _gets_loop
0148+  1140             _gets_backspace:
0149+  1140 7F            dec d
0150+  1141 0A 18 11      jmp _gets_loop
0151+  1144             _gets_ansi_esc:
0152+  1144 19 01         mov al, 1
0153+  1146 05 03         syscall sys_io        ; receive in AH without echo
0154+  1148 B9 00         cmp al, 0          ; check error code (AL)
0155+  114A C6 44 11      je _gets_ansi_esc    ; if no char received, retry
0156+  114D 76 5B         cmp ah, '['
0157+  114F C7 18 11      jne _gets_loop
0158+  1152             _gets_ansi_esc_2:
0159+  1152 19 01         mov al, 1
0160+  1154 05 03         syscall sys_io          ; receive in AH without echo
0161+  1156 B9 00         cmp al, 0            ; check error code (AL)
0162+  1158 C6 52 11      je _gets_ansi_esc_2  ; if no char received, retry
0163+  115B 76 44         cmp ah, 'D'
0164+  115D C6 68 11      je _gets_left_arrow
0165+  1160 76 43         cmp ah, 'C'
0166+  1162 C6 6C 11      je _gets_right_arrow
0167+  1165 0A 18 11      jmp _gets_loop
0168+  1168             _gets_left_arrow:
0169+  1168 7F            dec d
0170+  1169 0A 18 11      jmp _gets_loop
0171+  116C             _gets_right_arrow:
0172+  116C 79            inc d
0173+  116D 0A 18 11      jmp _gets_loop
0174+  1170             _gets_escape:
0175+  1170 19 01         mov al, 1
0176+  1172 05 03         syscall sys_io      ; receive in AH
0177+  1174 B9 00         cmp al, 0        ; check error code (AL)
0178+  1176 C6 70 11      je _gets_escape      ; if no char received, retry
0179+  1179 76 6E         cmp ah, 'n'
0180+  117B C6 9A 11      je _gets_LF
0181+  117E 76 72         cmp ah, 'r'
0182+  1180 C6 A1 11      je _gets_CR
0183+  1183 76 30         cmp ah, '0'
0184+  1185 C6 A8 11      je _gets_NULL
0185+  1188 76 5C         cmp ah, $5C  ; '\'
0186+  118A C6 93 11      je _gets_slash
0187+  118D 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  118E 3E            mov [d], al
0189+  118F 79            inc d
0190+  1190 0A 18 11      jmp _gets_loop
0191+  1193             _gets_slash:
0192+  1193 19 5C         mov al, $5C
0193+  1195 3E            mov [d], al
0194+  1196 79            inc d
0195+  1197 0A 18 11      jmp _gets_loop
0196+  119A             _gets_LF:
0197+  119A 19 0A         mov al, $0A
0198+  119C 3E            mov [d], al
0199+  119D 79            inc d
0200+  119E 0A 18 11      jmp _gets_loop
0201+  11A1             _gets_CR:
0202+  11A1 19 0D         mov al, $0D
0203+  11A3 3E            mov [d], al
0204+  11A4 79            inc d
0205+  11A5 0A 18 11      jmp _gets_loop
0206+  11A8             _gets_NULL:
0207+  11A8 19 00         mov al, $00
0208+  11AA 3E            mov [d], al
0209+  11AB 79            inc d
0210+  11AC 0A 18 11      jmp _gets_loop
0211+  11AF             _gets_end:
0212+  11AF 19 00         mov al, 0
0213+  11B1 3E            mov [d], al        ; terminate string
0214+  11B2 E7            pop d
0215+  11B3 E4            pop a
0216+  11B4 09            ret
0217+  11B5             
0218+  11B5             
0219+  11B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  11B5             ;; INPUT TEXT
0221+  11B5             ;; terminated with CTRL+D
0222+  11B5             ;; pointer in D
0223+  11B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  11B5             _gettxt:
0225+  11B5 D7            push a
0226+  11B6 DA            push d
0227+  11B7             _gettxt_loop:
0228+  11B7 19 01         mov al, 1
0229+  11B9 05 03         syscall sys_io      ; receive in AH
0230+  11BB B9 00         cmp al, 0        ; check error code (AL)
0231+  11BD C6 B7 11      je _gettxt_loop    ; if no char received, retry
0232+  11C0 76 04         cmp ah, 4      ; EOT
0233+  11C2 C6 00 12      je _gettxt_end
0234+  11C5 76 08         cmp ah, $08      ; check for backspace
0235+  11C7 C6 FC 11      je _gettxt_backspace
0236+  11CA 76 5C         cmp ah, $5C        ; '\'
0237+  11CC C6 D5 11      je _gettxt_escape
0238+  11CF 1A            mov al, ah
0239+  11D0 3E            mov [d], al
0240+  11D1 79            inc d
0241+  11D2 0A B7 11      jmp _gettxt_loop
0242+  11D5             _gettxt_escape:
0243+  11D5 19 01         mov al, 1
0244+  11D7 05 03         syscall sys_io      ; receive in AH
0245+  11D9 B9 00         cmp al, 0        ; check error code (AL)
0246+  11DB C6 D5 11      je _gettxt_escape    ; if no char received, retry
0247+  11DE 76 6E         cmp ah, 'n'
0248+  11E0 C6 EE 11      je _gettxt_LF
0249+  11E3 76 72         cmp ah, 'r'
0250+  11E5 C6 F5 11      je _gettxt_CR
0251+  11E8 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  11E9 3E            mov [d], al
0253+  11EA 79            inc d
0254+  11EB 0A B7 11      jmp _gettxt_loop
0255+  11EE             _gettxt_LF:
0256+  11EE 19 0A         mov al, $0A
0257+  11F0 3E            mov [d], al
0258+  11F1 79            inc d
0259+  11F2 0A B7 11      jmp _gettxt_loop
0260+  11F5             _gettxt_CR:
0261+  11F5 19 0D         mov al, $0D
0262+  11F7 3E            mov [d], al
0263+  11F8 79            inc d
0264+  11F9 0A B7 11      jmp _gettxt_loop
0265+  11FC             _gettxt_backspace:
0266+  11FC 7F            dec d
0267+  11FD 0A B7 11      jmp _gettxt_loop
0268+  1200             _gettxt_end:
0269+  1200 19 00         mov al, 0
0270+  1202 3E            mov [d], al        ; terminate string
0271+  1203 E7            pop d
0272+  1204 E4            pop a
0273+  1205 09            ret
0274+  1206             
0275+  1206             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1206             ; PRINT NEW LINE
0277+  1206             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  1206             printnl:
0279+  1206 D7            push a
0280+  1207 10 00 0A      mov a, $0A00
0281+  120A 05 03         syscall sys_io
0282+  120C 10 00 0D      mov a, $0D00
0283+  120F 05 03         syscall sys_io
0284+  1211 E4            pop a
0285+  1212 09            ret
0286+  1213             
0287+  1213             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  1213             ; _strtoint
0289+  1213             ; 4 digit hex string number in d
0290+  1213             ; integer returned in A
0291+  1213             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  1213             _strtointx:
0293+  1213 D8            push b
0294+  1214 32            mov bl, [d]
0295+  1215 37            mov bh, bl
0296+  1216 33 01 00      mov bl, [d + 1]
0297+  1219 07 CC 10      call _atoi        ; convert to int in AL
0298+  121C 23            mov ah, al        ; move to AH
0299+  121D 33 02 00      mov bl, [d + 2]
0300+  1220 37            mov bh, bl
0301+  1221 33 03 00      mov bl, [d + 3]
0302+  1224 07 CC 10      call _atoi        ; convert to int in AL
0303+  1227 E5            pop b
0304+  1228 09            ret
0305+  1229             
0306+  1229             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  1229             ; _strtoint
0308+  1229             ; 5 digit base10 string number in d
0309+  1229             ; integer returned in A
0310+  1229             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  1229             _strtoint:
0312+  1229 E2            push si
0313+  122A D8            push b
0314+  122B D9            push c
0315+  122C DA            push d
0316+  122D 07 6E 10      call _strlen      ; get string length in C
0317+  1230 7E            dec c
0318+  1231 FD 4E         mov si, d
0319+  1233 12            mov a, c
0320+  1234 FD 99         shl a
0321+  1236 3B A5 13      mov d, table_power
0322+  1239 59            add d, a
0323+  123A 38 00 00      mov c, 0
0324+  123D             _strtoint_L0:
0325+  123D F6            lodsb      ; load ASCII to al
0326+  123E B9 00         cmp al, 0
0327+  1240 C6 53 12      je _strtoint_end
0328+  1243 6F 30         sub al, $30    ; make into integer
0329+  1245 22 00         mov ah, 0
0330+  1247 2A            mov b, [d]
0331+  1248 AC            mul a, b      ; result in B since it fits in 16bits
0332+  1249 11            mov a, b
0333+  124A 28            mov b, c
0334+  124B 54            add a, b
0335+  124C 39            mov c, a
0336+  124D 63 02 00      sub d, 2
0337+  1250 0A 3D 12      jmp _strtoint_L0
0338+  1253             _strtoint_end:
0339+  1253 12            mov a, c
0340+  1254 E7            pop d
0341+  1255 E6            pop c
0342+  1256 E5            pop b
0343+  1257 EF            pop si
0344+  1258 09            ret
0345+  1259             
0346+  1259             
0347+  1259             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  1259             ; PRINT NULL TERMINATED STRING
0349+  1259             ; pointer in D
0350+  1259             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  1259             _puts:
0352+  1259 D7            push a
0353+  125A DA            push d
0354+  125B             _puts_L1:
0355+  125B 1E            mov al, [d]
0356+  125C B9 00         cmp al, 0
0357+  125E C6 6A 12      jz _puts_END
0358+  1261 23            mov ah, al
0359+  1262 19 00         mov al, 0
0360+  1264 05 03         syscall sys_io
0361+  1266 79            inc d
0362+  1267 0A 5B 12      jmp _puts_L1
0363+  126A             _puts_END:
0364+  126A E7            pop d
0365+  126B E4            pop a
0366+  126C 09            ret
0367+  126D             
0368+  126D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  126D             ; PRINT N SIZE STRING
0370+  126D             ; pointer in D
0371+  126D             ; size in C
0372+  126D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  126D             _putsn:
0374+  126D DB            push al
0375+  126E DA            push d
0376+  126F D9            push c
0377+  1270             _putsn_L0:
0378+  1270 1E            mov al, [d]
0379+  1271 23            mov ah, al
0380+  1272 19 00         mov al, 0
0381+  1274 05 03         syscall sys_io
0382+  1276 79            inc d
0383+  1277 7E            dec c  
0384+  1278 C2 00 00      cmp c, 0
0385+  127B C7 70 12      jne _putsn_L0
0386+  127E             _putsn_end:
0387+  127E E6            pop c
0388+  127F E7            pop d
0389+  1280 E8            pop al
0390+  1281 09            ret
0391+  1282             
0392+  1282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1282             ; print 16bit decimal number
0394+  1282             ; input number in A
0395+  1282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1282             print_u16d:
0397+  1282 D7            push a
0398+  1283 D8            push b
0399+  1284 26 10 27      mov b, 10000
0400+  1287 AE            div a, b      ; get 10000's coeff.
0401+  1288 07 AA 12      call print_number
0402+  128B 11            mov a, b
0403+  128C 26 E8 03      mov b, 1000
0404+  128F AE            div a, b      ; get 1000's coeff.
0405+  1290 07 AA 12      call print_number
0406+  1293 11            mov a, b
0407+  1294 26 64 00      mov b, 100
0408+  1297 AE            div a, b
0409+  1298 07 AA 12      call print_number
0410+  129B 11            mov a, b
0411+  129C 26 0A 00      mov b, 10
0412+  129F AE            div a, b
0413+  12A0 07 AA 12      call print_number
0414+  12A3 1B            mov al, bl      ; 1's coeff in bl
0415+  12A4 07 AA 12      call print_number
0416+  12A7 E5            pop b
0417+  12A8 E4            pop a
0418+  12A9 09            ret
0419+  12AA             
0420+  12AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  12AA             ; print AL
0422+  12AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  12AA             print_number:
0424+  12AA 6A 30         add al, $30
0425+  12AC 23            mov ah, al
0426+  12AD 07 0F 11      call _putchar
0427+  12B0 09            ret
0428+  12B1             
0429+  12B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  12B1             ; PRINT 16BIT HEX INTEGER
0431+  12B1             ; integer value in reg B
0432+  12B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  12B1             print_u16x:
0434+  12B1 D7            push a
0435+  12B2 D8            push b
0436+  12B3 DD            push bl
0437+  12B4 30            mov bl, bh
0438+  12B5 07 DD 10      call _itoa        ; convert bh to char in A
0439+  12B8 2F            mov bl, al        ; save al
0440+  12B9 19 00         mov al, 0
0441+  12BB 05 03         syscall sys_io        ; display AH
0442+  12BD 24            mov ah, bl        ; retrieve al
0443+  12BE 19 00         mov al, 0
0444+  12C0 05 03         syscall sys_io        ; display AL
0445+  12C2             
0446+  12C2 EA            pop bl
0447+  12C3 07 DD 10      call _itoa        ; convert bh to char in A
0448+  12C6 2F            mov bl, al        ; save al
0449+  12C7 19 00         mov al, 0
0450+  12C9 05 03         syscall sys_io        ; display AH
0451+  12CB 24            mov ah, bl        ; retrieve al
0452+  12CC 19 00         mov al, 0
0453+  12CE 05 03         syscall sys_io        ; display AL
0454+  12D0             
0455+  12D0 E5            pop b
0456+  12D1 E4            pop a
0457+  12D2 09            ret
0458+  12D3             
0459+  12D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  12D3             ; INPUT 16BIT HEX INTEGER
0461+  12D3             ; read 16bit integer into A
0462+  12D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  12D3             scan_u16x:
0464+  12D3 F8 10 00      enter 16
0465+  12D6 D8            push b
0466+  12D7 DA            push d
0467+  12D8             
0468+  12D8 FA F1 FF      lea d, [bp + -15]
0469+  12DB 07 16 11      call _gets        ; get number
0470+  12DE             
0471+  12DE 32            mov bl, [d]
0472+  12DF 37            mov bh, bl
0473+  12E0 33 01 00      mov bl, [d + 1]
0474+  12E3 07 CC 10      call _atoi        ; convert to int in AL
0475+  12E6 23            mov ah, al        ; move to AH
0476+  12E7             
0477+  12E7 33 02 00      mov bl, [d + 2]
0478+  12EA 37            mov bh, bl
0479+  12EB 33 03 00      mov bl, [d + 3]
0480+  12EE 07 CC 10      call _atoi        ; convert to int in AL
0481+  12F1             
0482+  12F1 E7            pop d
0483+  12F2 E5            pop b
0484+  12F3 F9            leave
0485+  12F4 09            ret
0486+  12F5             
0487+  12F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  12F5             ; PRINT 8bit HEX INTEGER
0489+  12F5             ; integer value in reg bl
0490+  12F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  12F5             print_u8x:
0492+  12F5 D7            push a
0493+  12F6 DD            push bl
0494+  12F7             
0495+  12F7 07 DD 10      call _itoa        ; convert bl to char in A
0496+  12FA 2F            mov bl, al        ; save al
0497+  12FB 19 00         mov al, 0
0498+  12FD 05 03         syscall sys_io        ; display AH
0499+  12FF 24            mov ah, bl        ; retrieve al
0500+  1300 19 00         mov al, 0
0501+  1302 05 03         syscall sys_io        ; display AL
0502+  1304             
0503+  1304 EA            pop bl
0504+  1305 E4            pop a
0505+  1306 09            ret
0506+  1307             
0507+  1307             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  1307             ; print 8bit decimal unsigned number
0509+  1307             ; input number in AL
0510+  1307             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  1307             print_u8d:
0512+  1307 D7            push a
0513+  1308 D8            push b
0514+  1309             
0515+  1309 22 00         mov ah, 0
0516+  130B 26 64 00      mov b, 100
0517+  130E AE            div a, b
0518+  130F D8            push b      ; save remainder
0519+  1310 B9 00         cmp al, 0
0520+  1312 C6 1C 13      je skip100
0521+  1315 6A 30         add al, $30
0522+  1317 23            mov ah, al
0523+  1318 19 00         mov al, 0
0524+  131A 05 03         syscall sys_io  ; print coeff
0525+  131C             skip100:
0526+  131C E4            pop a
0527+  131D 22 00         mov ah, 0
0528+  131F 26 0A 00      mov b, 10
0529+  1322 AE            div a, b
0530+  1323 D8            push b      ; save remainder
0531+  1324 B9 00         cmp al, 0
0532+  1326 C6 30 13      je skip10
0533+  1329 6A 30         add al, $30
0534+  132B 23            mov ah, al
0535+  132C 19 00         mov al, 0
0536+  132E 05 03         syscall sys_io  ; print coeff
0537+  1330             skip10:
0538+  1330 E4            pop a
0539+  1331 1B            mov al, bl
0540+  1332 6A 30         add al, $30
0541+  1334 23            mov ah, al
0542+  1335 19 00         mov al, 0
0543+  1337 05 03         syscall sys_io  ; print coeff
0544+  1339 E5            pop b
0545+  133A E4            pop a
0546+  133B 09            ret
0547+  133C             
0548+  133C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  133C             ; INPUT 8BIT HEX INTEGER
0550+  133C             ; read 8bit integer into AL
0551+  133C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  133C             scan_u8x:
0553+  133C F8 04 00      enter 4
0554+  133F D8            push b
0555+  1340 DA            push d
0556+  1341             
0557+  1341 FA FD FF      lea d, [bp + -3]
0558+  1344 07 16 11      call _gets        ; get number
0559+  1347             
0560+  1347 32            mov bl, [d]
0561+  1348 37            mov bh, bl
0562+  1349 33 01 00      mov bl, [d + 1]
0563+  134C 07 CC 10      call _atoi        ; convert to int in AL
0564+  134F             
0565+  134F E7            pop d
0566+  1350 E5            pop b
0567+  1351 F9            leave
0568+  1352 09            ret
0569+  1353             
0570+  1353             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  1353             ; input decimal number
0572+  1353             ; result in A
0573+  1353             ; 655'\0'
0574+  1353             ; low--------high
0575+  1353             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  1353             scan_u16d:
0577+  1353 F8 08 00      enter 8
0578+  1356 E2            push si
0579+  1357 D8            push b
0580+  1358 D9            push c
0581+  1359 DA            push d
0582+  135A FA F9 FF      lea d, [bp +- 7]
0583+  135D 07 16 11      call _gets
0584+  1360 07 6E 10      call _strlen      ; get string length in C
0585+  1363 7E            dec c
0586+  1364 FD 4E         mov si, d
0587+  1366 12            mov a, c
0588+  1367 FD 99         shl a
0589+  1369 3B A5 13      mov d, table_power
0590+  136C 59            add d, a
0591+  136D 38 00 00      mov c, 0
0592+  1370             mul_loop:
0593+  1370 F6            lodsb      ; load ASCII to al
0594+  1371 B9 00         cmp al, 0
0595+  1373 C6 86 13      je mul_exit
0596+  1376 6F 30         sub al, $30    ; make into integer
0597+  1378 22 00         mov ah, 0
0598+  137A 2A            mov b, [d]
0599+  137B AC            mul a, b      ; result in B since it fits in 16bits
0600+  137C 11            mov a, b
0601+  137D 28            mov b, c
0602+  137E 54            add a, b
0603+  137F 39            mov c, a
0604+  1380 63 02 00      sub d, 2
0605+  1383 0A 70 13      jmp mul_loop
0606+  1386             mul_exit:
0607+  1386 12            mov a, c
0608+  1387 E7            pop d
0609+  1388 E6            pop c
0610+  1389 E5            pop b
0611+  138A EF            pop si
0612+  138B F9            leave
0613+  138C 09            ret
0614+  138D             
0615+  138D             
0616+  138D 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1391 34 35 36 37 
0616+  1395 38 39 41 42 
0616+  1399 43 44 45 46 
0617+  139D 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  13A1 1B 5B 48 00 
0618+  13A5             
0619+  13A5             table_power:
0620+  13A5 01 00         .dw 1
0621+  13A7 0A 00         .dw 10
0622+  13A9 64 00         .dw 100
0623+  13AB E8 03         .dw 1000
0624+  13AD 10 27         .dw 100002305   13AF             ; --- END INLINE ASM BLOCK
2306   13AF             
2307   13AF F9            leave
2308   13B0 09            ret
2309   13B1             ; --- END TEXT BLOCK
2310   13B1             
2311   13B1             ; --- BEGIN DATA BLOCK
2312   13B1 00 00 00 00 _l_data: .fill 1060, 0
2312   13B5 00 00 00 00 
2312   13B9 00 00 00 00 
2312   13BD 00 00 00 00 
2312   13C1 00 00 00 00 
2312   13C5 00 00 00 00 
2312   13C9 00 00 00 00 
2312   13CD 00 00 00 00 
2312   13D1 00 00 00 00 
2312   13D5 00 00 00 00 
2312   13D9 00 00 00 00 
2312   13DD 00 00 00 00 
2312   13E1 00 00 00 00 
2312   13E5 00 00 00 00 
2312   13E9 00 00 00 00 
2312   13ED 00 00 00 00 
2312   13F1 00 00 00 00 
2312   13F5 00 00 00 00 
2312   13F9 00 00 00 00 
2312   13FD 00 00 00 00 
2312   1401 00 00 00 00 
2312   1405 00 00 00 00 
2312   1409 00 00 00 00 
2312   140D 00 00 00 00 
2312   1411 00 00 00 00 
2312   1415 00 00 00 00 
2312   1419 00 00 00 00 
2312   141D 00 00 00 00 
2312   1421 00 00 00 00 
2312   1425 00 00 00 00 
2312   1429 00 00 00 00 
2312   142D 00 00 00 00 
2312   1431 00 00 00 00 
2312   1435 00 00 00 00 
2312   1439 00 00 00 00 
2312   143D 00 00 00 00 
2312   1441 00 00 00 00 
2312   1445 00 00 00 00 
2312   1449 00 00 00 00 
2312   144D 00 00 00 00 
2312   1451 00 00 00 00 
2312   1455 00 00 00 00 
2312   1459 00 00 00 00 
2312   145D 00 00 00 00 
2312   1461 00 00 00 00 
2312   1465 00 00 00 00 
2312   1469 00 00 00 00 
2312   146D 00 00 00 00 
2312   1471 00 00 00 00 
2312   1475 00 00 00 00 
2312   1479 00 00 00 00 
2312   147D 00 00 00 00 
2312   1481 00 00 00 00 
2312   1485 00 00 00 00 
2312   1489 00 00 00 00 
2312   148D 00 00 00 00 
2312   1491 00 00 00 00 
2312   1495 00 00 00 00 
2312   1499 00 00 00 00 
2312   149D 00 00 00 00 
2312   14A1 00 00 00 00 
2312   14A5 00 00 00 00 
2312   14A9 00 00 00 00 
2312   14AD 00 00 00 00 
2312   14B1 00 00 00 00 
2312   14B5 00 00 00 00 
2312   14B9 00 00 00 00 
2312   14BD 00 00 00 00 
2312   14C1 00 00 00 00 
2312   14C5 00 00 00 00 
2312   14C9 00 00 00 00 
2312   14CD 00 00 00 00 
2312   14D1 00 00 00 00 
2312   14D5 00 00 00 00 
2312   14D9 00 00 00 00 
2312   14DD 00 00 00 00 
2312   14E1 00 00 00 00 
2312   14E5 00 00 00 00 
2312   14E9 00 00 00 00 
2312   14ED 00 00 00 00 
2312   14F1 00 00 00 00 
2312   14F5 00 00 00 00 
2312   14F9 00 00 00 00 
2312   14FD 00 00 00 00 
2312   1501 00 00 00 00 
2312   1505 00 00 00 00 
2312   1509 00 00 00 00 
2312   150D 00 00 00 00 
2312   1511 00 00 00 00 
2312   1515 00 00 00 00 
2312   1519 00 00 00 00 
2312   151D 00 00 00 00 
2312   1521 00 00 00 00 
2312   1525 00 00 00 00 
2312   1529 00 00 00 00 
2312   152D 00 00 00 00 
2312   1531 00 00 00 00 
2312   1535 00 00 00 00 
2312   1539 00 00 00 00 
2312   153D 00 00 00 00 
2312   1541 00 00 00 00 
2312   1545 00 00 00 00 
2312   1549 00 00 00 00 
2312   154D 00 00 00 00 
2312   1551 00 00 00 00 
2312   1555 00 00 00 00 
2312   1559 00 00 00 00 
2312   155D 00 00 00 00 
2312   1561 00 00 00 00 
2312   1565 00 00 00 00 
2312   1569 00 00 00 00 
2312   156D 00 00 00 00 
2312   1571 00 00 00 00 
2312   1575 00 00 00 00 
2312   1579 00 00 00 00 
2312   157D 00 00 00 00 
2312   1581 00 00 00 00 
2312   1585 00 00 00 00 
2312   1589 00 00 00 00 
2312   158D 00 00 00 00 
2312   1591 00 00 00 00 
2312   1595 00 00 00 00 
2312   1599 00 00 00 00 
2312   159D 00 00 00 00 
2312   15A1 00 00 00 00 
2312   15A5 00 00 00 00 
2312   15A9 00 00 00 00 
2312   15AD 00 00 00 00 
2312   15B1 00 00 00 00 
2312   15B5 00 00 00 00 
2312   15B9 00 00 00 00 
2312   15BD 00 00 00 00 
2312   15C1 00 00 00 00 
2312   15C5 00 00 00 00 
2312   15C9 00 00 00 00 
2312   15CD 00 00 00 00 
2312   15D1 00 00 00 00 
2312   15D5 00 00 00 00 
2312   15D9 00 00 00 00 
2312   15DD 00 00 00 00 
2312   15E1 00 00 00 00 
2312   15E5 00 00 00 00 
2312   15E9 00 00 00 00 
2312   15ED 00 00 00 00 
2312   15F1 00 00 00 00 
2312   15F5 00 00 00 00 
2312   15F9 00 00 00 00 
2312   15FD 00 00 00 00 
2312   1601 00 00 00 00 
2312   1605 00 00 00 00 
2312   1609 00 00 00 00 
2312   160D 00 00 00 00 
2312   1611 00 00 00 00 
2312   1615 00 00 00 00 
2312   1619 00 00 00 00 
2312   161D 00 00 00 00 
2312   1621 00 00 00 00 
2312   1625 00 00 00 00 
2312   1629 00 00 00 00 
2312   162D 00 00 00 00 
2312   1631 00 00 00 00 
2312   1635 00 00 00 00 
2312   1639 00 00 00 00 
2312   163D 00 00 00 00 
2312   1641 00 00 00 00 
2312   1645 00 00 00 00 
2312   1649 00 00 00 00 
2312   164D 00 00 00 00 
2312   1651 00 00 00 00 
2312   1655 00 00 00 00 
2312   1659 00 00 00 00 
2312   165D 00 00 00 00 
2312   1661 00 00 00 00 
2312   1665 00 00 00 00 
2312   1669 00 00 00 00 
2312   166D 00 00 00 00 
2312   1671 00 00 00 00 
2312   1675 00 00 00 00 
2312   1679 00 00 00 00 
2312   167D 00 00 00 00 
2312   1681 00 00 00 00 
2312   1685 00 00 00 00 
2312   1689 00 00 00 00 
2312   168D 00 00 00 00 
2312   1691 00 00 00 00 
2312   1695 00 00 00 00 
2312   1699 00 00 00 00 
2312   169D 00 00 00 00 
2312   16A1 00 00 00 00 
2312   16A5 00 00 00 00 
2312   16A9 00 00 00 00 
2312   16AD 00 00 00 00 
2312   16B1 00 00 00 00 
2312   16B5 00 00 00 00 
2312   16B9 00 00 00 00 
2312   16BD 00 00 00 00 
2312   16C1 00 00 00 00 
2312   16C5 00 00 00 00 
2312   16C9 00 00 00 00 
2312   16CD 00 00 00 00 
2312   16D1 00 00 00 00 
2312   16D5 00 00 00 00 
2312   16D9 00 00 00 00 
2312   16DD 00 00 00 00 
2312   16E1 00 00 00 00 
2312   16E5 00 00 00 00 
2312   16E9 00 00 00 00 
2312   16ED 00 00 00 00 
2312   16F1 00 00 00 00 
2312   16F5 00 00 00 00 
2312   16F9 00 00 00 00 
2312   16FD 00 00 00 00 
2312   1701 00 00 00 00 
2312   1705 00 00 00 00 
2312   1709 00 00 00 00 
2312   170D 00 00 00 00 
2312   1711 00 00 00 00 
2312   1715 00 00 00 00 
2312   1719 00 00 00 00 
2312   171D 00 00 00 00 
2312   1721 00 00 00 00 
2312   1725 00 00 00 00 
2312   1729 00 00 00 00 
2312   172D 00 00 00 00 
2312   1731 00 00 00 00 
2312   1735 00 00 00 00 
2312   1739 00 00 00 00 
2312   173D 00 00 00 00 
2312   1741 00 00 00 00 
2312   1745 00 00 00 00 
2312   1749 00 00 00 00 
2312   174D 00 00 00 00 
2312   1751 00 00 00 00 
2312   1755 00 00 00 00 
2312   1759 00 00 00 00 
2312   175D 00 00 00 00 
2312   1761 00 00 00 00 
2312   1765 00 00 00 00 
2312   1769 00 00 00 00 
2312   176D 00 00 00 00 
2312   1771 00 00 00 00 
2312   1775 00 00 00 00 
2312   1779 00 00 00 00 
2312   177D 00 00 00 00 
2312   1781 00 00 00 00 
2312   1785 00 00 00 00 
2312   1789 00 00 00 00 
2312   178D 00 00 00 00 
2312   1791 00 00 00 00 
2312   1795 00 00 00 00 
2312   1799 00 00 00 00 
2312   179D 00 00 00 00 
2312   17A1 00 00 00 00 
2312   17A5 00 00 00 00 
2312   17A9 00 00 00 00 
2312   17AD 00 00 00 00 
2312   17B1 00 00 00 00 
2312   17B5 00 00 00 00 
2312   17B9 00 00 00 00 
2312   17BD 00 00 00 00 
2312   17C1 00 00 00 00 
2312   17C5 00 00 00 00 
2312   17C9 00 00 00 00 
2312   17CD 00 00 00 00 
2312   17D1 00 00 00 00 
2313   17D5 00 00       _p: .fill 2, 0
2314   17D7 48 65 6C 6C __s0: .db "Hello World, this Works!", 0
2314   17DB 6F 20 57 6F 
2314   17DF 72 6C 64 2C 
2314   17E3 20 74 68 69 
2314   17E7 73 20 57 6F 
2314   17EB 72 6B 73 21 
2314   17EF 00 
2315   17F0 53 74 72 69 __s1: .db "String: %s, %c, %x", 0
2315   17F4 6E 67 3A 20 
2315   17F8 25 73 2C 20 
2315   17FC 25 63 2C 20 
2315   1800 25 78 00 
2316   1803 55 6E 65 78 __s2: .db "Unexpected format in printf.", 0
2316   1807 70 65 63 74 
2316   180B 65 64 20 66 
2316   180F 6F 72 6D 61 
2316   1813 74 20 69 6E 
2316   1817 20 70 72 69 
2316   181B 6E 74 66 2E 
2316   181F 00 
2317   1820 45 72 72 6F __s3: .db "Error: Unknown argument type.\n", 0
2317   1824 72 3A 20 55 
2317   1828 6E 6B 6E 6F 
2317   182C 77 6E 20 61 
2317   1830 72 67 75 6D 
2317   1834 65 6E 74 20 
2317   1838 74 79 70 65 
2317   183C 2E 0A 00 
2318   183F 1B 5B 32 4A __s4: .db "\033[2J\033[H", 0
2318   1843 1B 5B 48 00 
2319   1847             
2320   1847 49 18       _heap_top: .dw _heap
2321   1849 00          _heap: .db 0
2322   184A             ; --- END DATA BLOCK
2323   184A             
2324   184A             .end
tasm: Number of errors = 0
