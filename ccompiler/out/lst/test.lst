0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $i 
0011   0408             ; $c 
0012   0408             ; $j 
0013   0408 52 07 00      sub sp, 7
0014   040B             ;; i = 0xAABBCCDDL; 
0015   040B FA FD FF      lea d, [bp + -3] ; $i
0016   040E DA            push d
0017   040F 26 DD CC      mov b, $ccdd
0018   0412 38 BB AA      mov c, $aabb
0019   0415 E7            pop d
0020   0416 FD 43         mov [d], b
0021   0418 28            mov b, c
0022   0419 FD 44 02 00   mov [d + 2], b
0023   041D             ;; c = 0xAE; 
0024   041D FA FC FF      lea d, [bp + -4] ; $c
0025   0420 DA            push d
0026   0421 26 AE 00      mov b, $ae
0027   0424 E7            pop d
0028   0425 FD 3E         mov [d], bl
0029   0427             ;; j = 0x1234; 
0030   0427 FA FA FF      lea d, [bp + -6] ; $j
0031   042A DA            push d
0032   042B 26 34 12      mov b, $1234
0033   042E E7            pop d
0034   042F FD 43         mov [d], b
0035   0431             ;; printx32(0x1234); 
0036   0431 26 34 12      mov b, $1234
0037   0434 FD 79         mov g, b
0038   0436 28            mov b, c
0039   0437 FD AB         swp b
0040   0439 D8            push b
0041   043A FD 27         mov b, g
0042   043C D8            push b
0043   043D 07 9A 08      call printx32
0044   0440 51 04 00      add sp, 4
0045   0443             ;; printf("Value: %lx", (char)i); 
0046   0443 FA FD FF      lea d, [bp + -3] ; $i
0047   0446 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0048   0449 FD 39         mov c, b ; And place it into C
0049   044B 2A            mov b, [d] ; Lower Word in B
0050   044C A7 00         mov bh, 0
0051   044E 38 00 00      mov c, 0
0052   0451 FD AB         swp b
0053   0453 D8            push b
0054   0454 26 5A 14      mov b, __s0 ; "Value: %lx"
0055   0457 FD AB         swp b
0056   0459 D8            push b
0057   045A 07 1D 06      call printf
0058   045D 51 04 00      add sp, 4
0059   0460 05 0B         syscall sys_terminate_proc
0060   0462             
0061   0462             strcpy:
0062   0462 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0063   0465             ; $psrc 
0064   0465             ; $pdest 
0065   0465 52 04 00      sub sp, 4
0066   0468             ;; psrc = src; 
0067   0468 FA FF FF      lea d, [bp + -1] ; $psrc
0068   046B DA            push d
0069   046C FA 07 00      lea d, [bp + 7] ; $src
0070   046F 2A            mov b, [d]
0071   0470 E7            pop d
0072   0471 FD 43         mov [d], b
0073   0473             ;; pdest = dest; 
0074   0473 FA FD FF      lea d, [bp + -3] ; $pdest
0075   0476 DA            push d
0076   0477 FA 05 00      lea d, [bp + 5] ; $dest
0077   047A 2A            mov b, [d]
0078   047B E7            pop d
0079   047C FD 43         mov [d], b
0080   047E             ;; while(*psrc) *pdest++ = *psrc++; 
0081   047E             _while1_cond:
0082   047E FA FF FF      lea d, [bp + -1] ; $psrc
0083   0481 2A            mov b, [d]
0084   0482 74            mov d, b
0085   0483 32            mov bl, [d]
0086   0484 A7 00         mov bh, 0
0087   0486 C0 00 00      cmp b, 0
0088   0489 C6 B1 04      je _while1_exit
0089   048C             _while1_block:
0090   048C             ;; *pdest++ = *psrc++; 
0091   048C FA FD FF      lea d, [bp + -3] ; $pdest
0092   048F 2A            mov b, [d]
0093   0490 D8            push b
0094   0491 FD 77         inc b
0095   0493 FA FD FF      lea d, [bp + -3] ; $pdest
0096   0496 FD 43         mov [d], b
0097   0498 E5            pop b
0098   0499 D8            push b
0099   049A FA FF FF      lea d, [bp + -1] ; $psrc
0100   049D 2A            mov b, [d]
0101   049E D8            push b
0102   049F FD 77         inc b
0103   04A1 FA FF FF      lea d, [bp + -1] ; $psrc
0104   04A4 FD 43         mov [d], b
0105   04A6 E5            pop b
0106   04A7 74            mov d, b
0107   04A8 32            mov bl, [d]
0108   04A9 A7 00         mov bh, 0
0109   04AB E7            pop d
0110   04AC FD 3E         mov [d], bl
0111   04AE 0A 7E 04      jmp _while1_cond
0112   04B1             _while1_exit:
0113   04B1             ;; *pdest = '\0'; 
0114   04B1 FA FD FF      lea d, [bp + -3] ; $pdest
0115   04B4 2A            mov b, [d]
0116   04B5 D8            push b
0117   04B6 26 00 00      mov b, $0
0118   04B9 E7            pop d
0119   04BA FD 3E         mov [d], bl
0120   04BC F9            leave
0121   04BD 09            ret
0122   04BE             
0123   04BE             strcmp:
0124   04BE F8 00 00      enter 0 ; (push bp; mov bp, sp)
0125   04C1             ;; while (*s1 && (*s1 == *s2)) { 
0126   04C1             _while2_cond:
0127   04C1 FA 05 00      lea d, [bp + 5] ; $s1
0128   04C4 2A            mov b, [d]
0129   04C5 74            mov d, b
0130   04C6 32            mov bl, [d]
0131   04C7 A7 00         mov bh, 0
0132   04C9 D7            push a
0133   04CA 11            mov a, b
0134   04CB FA 05 00      lea d, [bp + 5] ; $s1
0135   04CE 2A            mov b, [d]
0136   04CF 74            mov d, b
0137   04D0 32            mov bl, [d]
0138   04D1 A7 00         mov bh, 0
0139   04D3             ; START RELATIONAL
0140   04D3 D7            push a
0141   04D4 11            mov a, b
0142   04D5 FA 07 00      lea d, [bp + 7] ; $s2
0143   04D8 2A            mov b, [d]
0144   04D9 74            mov d, b
0145   04DA 32            mov bl, [d]
0146   04DB A7 00         mov bh, 0
0147   04DD B0            cmp a, b
0148   04DE FD 71         seq ; ==
0149   04E0 E4            pop a
0150   04E1             ; END RELATIONAL
0151   04E1 FD A7         sand a, b ; &&
0152   04E3 E4            pop a
0153   04E4 C0 00 00      cmp b, 0
0154   04E7 C6 07 05      je _while2_exit
0155   04EA             _while2_block:
0156   04EA             ;; s1++; 
0157   04EA FA 05 00      lea d, [bp + 5] ; $s1
0158   04ED 2A            mov b, [d]
0159   04EE D8            push b
0160   04EF FD 77         inc b
0161   04F1 FA 05 00      lea d, [bp + 5] ; $s1
0162   04F4 FD 43         mov [d], b
0163   04F6 E5            pop b
0164   04F7             ;; s2++; 
0165   04F7 FA 07 00      lea d, [bp + 7] ; $s2
0166   04FA 2A            mov b, [d]
0167   04FB D8            push b
0168   04FC FD 77         inc b
0169   04FE FA 07 00      lea d, [bp + 7] ; $s2
0170   0501 FD 43         mov [d], b
0171   0503 E5            pop b
0172   0504 0A C1 04      jmp _while2_cond
0173   0507             _while2_exit:
0174   0507             ;; return *s1 - *s2; 
0175   0507 FA 05 00      lea d, [bp + 5] ; $s1
0176   050A 2A            mov b, [d]
0177   050B 74            mov d, b
0178   050C 32            mov bl, [d]
0179   050D A7 00         mov bh, 0
0180   050F             ; START TERMS
0181   050F D7            push a
0182   0510 11            mov a, b
0183   0511 FA 07 00      lea d, [bp + 7] ; $s2
0184   0514 2A            mov b, [d]
0185   0515 74            mov d, b
0186   0516 32            mov bl, [d]
0187   0517 A7 00         mov bh, 0
0188   0519 60            sub a, b
0189   051A 27            mov b, a
0190   051B E4            pop a
0191   051C             ; END TERMS
0192   051C F9            leave
0193   051D 09            ret
0194   051E             
0195   051E             strcat:
0196   051E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0197   0521             ; $dest_len 
0198   0521             ; $i 
0199   0521 52 04 00      sub sp, 4
0200   0524             ;; dest_len = strlen(dest); 
0201   0524 FA FF FF      lea d, [bp + -1] ; $dest_len
0202   0527 DA            push d
0203   0528 FA 05 00      lea d, [bp + 5] ; $dest
0204   052B 2A            mov b, [d]
0205   052C FD AB         swp b
0206   052E D8            push b
0207   052F 07 D4 05      call strlen
0208   0532 51 02 00      add sp, 2
0209   0535 E7            pop d
0210   0536 FD 43         mov [d], b
0211   0538             ;; for (i = 0; src[i] != 0; i=i+1) { 
0212   0538             _for3_init:
0213   0538 FA FD FF      lea d, [bp + -3] ; $i
0214   053B DA            push d
0215   053C 26 00 00      mov b, $0
0216   053F E7            pop d
0217   0540 FD 43         mov [d], b
0218   0542             _for3_cond:
0219   0542 FA 07 00      lea d, [bp + 7] ; $src
0220   0545 FD 2A         mov d, [d]
0221   0547 D7            push a
0222   0548 DA            push d
0223   0549 FA FD FF      lea d, [bp + -3] ; $i
0224   054C 2A            mov b, [d]
0225   054D E7            pop d
0226   054E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0227   0552 E4            pop a
0228   0553 32            mov bl, [d]
0229   0554 A7 00         mov bh, 0
0230   0556             ; START RELATIONAL
0231   0556 D7            push a
0232   0557 11            mov a, b
0233   0558 26 00 00      mov b, $0
0234   055B B0            cmp a, b
0235   055C FD 72         sneq ; !=
0236   055E E4            pop a
0237   055F             ; END RELATIONAL
0238   055F C0 00 00      cmp b, 0
0239   0562 C6 AD 05      je _for3_exit
0240   0565             _for3_block:
0241   0565             ;; dest[dest_len + i] = src[i]; 
0242   0565 FA 05 00      lea d, [bp + 5] ; $dest
0243   0568 FD 2A         mov d, [d]
0244   056A D7            push a
0245   056B DA            push d
0246   056C FA FF FF      lea d, [bp + -1] ; $dest_len
0247   056F 2A            mov b, [d]
0248   0570             ; START TERMS
0249   0570 D7            push a
0250   0571 11            mov a, b
0251   0572 FA FD FF      lea d, [bp + -3] ; $i
0252   0575 2A            mov b, [d]
0253   0576 54            add a, b
0254   0577 27            mov b, a
0255   0578 E4            pop a
0256   0579             ; END TERMS
0257   0579 E7            pop d
0258   057A FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0259   057E E4            pop a
0260   057F DA            push d
0261   0580 FA 07 00      lea d, [bp + 7] ; $src
0262   0583 FD 2A         mov d, [d]
0263   0585 D7            push a
0264   0586 DA            push d
0265   0587 FA FD FF      lea d, [bp + -3] ; $i
0266   058A 2A            mov b, [d]
0267   058B E7            pop d
0268   058C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0269   0590 E4            pop a
0270   0591 32            mov bl, [d]
0271   0592 A7 00         mov bh, 0
0272   0594 E7            pop d
0273   0595 FD 3E         mov [d], bl
0274   0597             _for3_update:
0275   0597 FA FD FF      lea d, [bp + -3] ; $i
0276   059A DA            push d
0277   059B FA FD FF      lea d, [bp + -3] ; $i
0278   059E 2A            mov b, [d]
0279   059F             ; START TERMS
0280   059F D7            push a
0281   05A0 11            mov a, b
0282   05A1 26 01 00      mov b, $1
0283   05A4 54            add a, b
0284   05A5 27            mov b, a
0285   05A6 E4            pop a
0286   05A7             ; END TERMS
0287   05A7 E7            pop d
0288   05A8 FD 43         mov [d], b
0289   05AA 0A 42 05      jmp _for3_cond
0290   05AD             _for3_exit:
0291   05AD             ;; dest[dest_len + i] = 0; 
0292   05AD FA 05 00      lea d, [bp + 5] ; $dest
0293   05B0 FD 2A         mov d, [d]
0294   05B2 D7            push a
0295   05B3 DA            push d
0296   05B4 FA FF FF      lea d, [bp + -1] ; $dest_len
0297   05B7 2A            mov b, [d]
0298   05B8             ; START TERMS
0299   05B8 D7            push a
0300   05B9 11            mov a, b
0301   05BA FA FD FF      lea d, [bp + -3] ; $i
0302   05BD 2A            mov b, [d]
0303   05BE 54            add a, b
0304   05BF 27            mov b, a
0305   05C0 E4            pop a
0306   05C1             ; END TERMS
0307   05C1 E7            pop d
0308   05C2 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0309   05C6 E4            pop a
0310   05C7 DA            push d
0311   05C8 26 00 00      mov b, $0
0312   05CB E7            pop d
0313   05CC FD 3E         mov [d], bl
0314   05CE             ;; return dest; 
0315   05CE FA 05 00      lea d, [bp + 5] ; $dest
0316   05D1 2A            mov b, [d]
0317   05D2 F9            leave
0318   05D3 09            ret
0319   05D4             
0320   05D4             strlen:
0321   05D4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0322   05D7             ; $length 
0323   05D7 52 02 00      sub sp, 2
0324   05DA             ;; length = 0; 
0325   05DA FA FF FF      lea d, [bp + -1] ; $length
0326   05DD DA            push d
0327   05DE 26 00 00      mov b, $0
0328   05E1 E7            pop d
0329   05E2 FD 43         mov [d], b
0330   05E4             ;; while (str[length] != 0) { 
0331   05E4             _while4_cond:
0332   05E4 FA 05 00      lea d, [bp + 5] ; $str
0333   05E7 FD 2A         mov d, [d]
0334   05E9 D7            push a
0335   05EA DA            push d
0336   05EB FA FF FF      lea d, [bp + -1] ; $length
0337   05EE 2A            mov b, [d]
0338   05EF E7            pop d
0339   05F0 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0340   05F4 E4            pop a
0341   05F5 32            mov bl, [d]
0342   05F6 A7 00         mov bh, 0
0343   05F8             ; START RELATIONAL
0344   05F8 D7            push a
0345   05F9 11            mov a, b
0346   05FA 26 00 00      mov b, $0
0347   05FD B0            cmp a, b
0348   05FE FD 72         sneq ; !=
0349   0600 E4            pop a
0350   0601             ; END RELATIONAL
0351   0601 C0 00 00      cmp b, 0
0352   0604 C6 17 06      je _while4_exit
0353   0607             _while4_block:
0354   0607             ;; length++; 
0355   0607 FA FF FF      lea d, [bp + -1] ; $length
0356   060A 2A            mov b, [d]
0357   060B D8            push b
0358   060C FD 77         inc b
0359   060E FA FF FF      lea d, [bp + -1] ; $length
0360   0611 FD 43         mov [d], b
0361   0613 E5            pop b
0362   0614 0A E4 05      jmp _while4_cond
0363   0617             _while4_exit:
0364   0617             ;; return length; 
0365   0617 FA FF FF      lea d, [bp + -1] ; $length
0366   061A 2A            mov b, [d]
0367   061B F9            leave
0368   061C 09            ret
0369   061D             
0370   061D             printf:
0371   061D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0372   0620             ; $p 
0373   0620             ; $fp 
0374   0620             ; $i 
0375   0620 52 06 00      sub sp, 6
0376   0623             ;; fp = format; 
0377   0623 FA FD FF      lea d, [bp + -3] ; $fp
0378   0626 DA            push d
0379   0627 FA 05 00      lea d, [bp + 5] ; $format
0380   062A 2A            mov b, [d]
0381   062B E7            pop d
0382   062C FD 43         mov [d], b
0383   062E             ;; p = &format + 2; 
0384   062E FA FF FF      lea d, [bp + -1] ; $p
0385   0631 DA            push d
0386   0632 FA 05 00      lea d, [bp + 5] ; $format
0387   0635 2D            mov b, d
0388   0636             ; START TERMS
0389   0636 D7            push a
0390   0637 11            mov a, b
0391   0638 26 02 00      mov b, $2
0392   063B 54            add a, b
0393   063C 27            mov b, a
0394   063D E4            pop a
0395   063E             ; END TERMS
0396   063E E7            pop d
0397   063F FD 43         mov [d], b
0398   0641             ;; for(;;){ 
0399   0641             _for5_init:
0400   0641             _for5_cond:
0401   0641             _for5_block:
0402   0641             ;; if(!*fp) break; 
0403   0641             _if6_cond:
0404   0641 FA FD FF      lea d, [bp + -3] ; $fp
0405   0644 2A            mov b, [d]
0406   0645 74            mov d, b
0407   0646 32            mov bl, [d]
0408   0647 A7 00         mov bh, 0
0409   0649 C0 00 00      cmp b, 0
0410   064C FD 71         seq ; !
0411   064E C0 00 00      cmp b, 0
0412   0651 C6 5A 06      je _if6_else
0413   0654             _if6_true:
0414   0654             ;; break; 
0415   0654 0A 83 08      jmp _for5_exit ; for break
0416   0657 0A 80 08      jmp _if6_exit
0417   065A             _if6_else:
0418   065A             ;; if(*fp == '%'){ 
0419   065A             _if7_cond:
0420   065A FA FD FF      lea d, [bp + -3] ; $fp
0421   065D 2A            mov b, [d]
0422   065E 74            mov d, b
0423   065F 32            mov bl, [d]
0424   0660 A7 00         mov bh, 0
0425   0662             ; START RELATIONAL
0426   0662 D7            push a
0427   0663 11            mov a, b
0428   0664 26 25 00      mov b, $25
0429   0667 B0            cmp a, b
0430   0668 FD 71         seq ; ==
0431   066A E4            pop a
0432   066B             ; END RELATIONAL
0433   066B C0 00 00      cmp b, 0
0434   066E C6 64 08      je _if7_else
0435   0671             _if7_true:
0436   0671             ;; fp++; 
0437   0671 FA FD FF      lea d, [bp + -3] ; $fp
0438   0674 2A            mov b, [d]
0439   0675 D8            push b
0440   0676 FD 77         inc b
0441   0678 FA FD FF      lea d, [bp + -3] ; $fp
0442   067B FD 43         mov [d], b
0443   067D E5            pop b
0444   067E             ;; switch(*fp){ 
0445   067E             _switch8_expr:
0446   067E FA FD FF      lea d, [bp + -3] ; $fp
0447   0681 2A            mov b, [d]
0448   0682 74            mov d, b
0449   0683 32            mov bl, [d]
0450   0684 A7 00         mov bh, 0
0451   0686             _switch8_comparisons:
0452   0686 C1 6C         cmp bl, $6c
0453   0688 C6 B4 06      je _switch8_case0
0454   068B C1 4C         cmp bl, $4c
0455   068D C6 B4 06      je _switch8_case1
0456   0690 C1 64         cmp bl, $64
0457   0692 C6 84 07      je _switch8_case2
0458   0695 C1 69         cmp bl, $69
0459   0697 C6 84 07      je _switch8_case3
0460   069A C1 75         cmp bl, $75
0461   069C C6 AA 07      je _switch8_case4
0462   069F C1 78         cmp bl, $78
0463   06A1 C6 D1 07      je _switch8_case5
0464   06A4 C1 63         cmp bl, $63
0465   06A6 C6 F8 07      je _switch8_case6
0466   06A9 C1 73         cmp bl, $73
0467   06AB C6 1F 08      je _switch8_case7
0468   06AE 0A 48 08      jmp _switch8_default
0469   06B1 0A 54 08      jmp _switch8_exit
0470   06B4             _switch8_case0:
0471   06B4             _switch8_case1:
0472   06B4             ;; fp++; 
0473   06B4 FA FD FF      lea d, [bp + -3] ; $fp
0474   06B7 2A            mov b, [d]
0475   06B8 D8            push b
0476   06B9 FD 77         inc b
0477   06BB FA FD FF      lea d, [bp + -3] ; $fp
0478   06BE FD 43         mov [d], b
0479   06C0 E5            pop b
0480   06C1             ;; if(*fp == 'd' || *fp == 'i') 
0481   06C1             _if9_cond:
0482   06C1 FA FD FF      lea d, [bp + -3] ; $fp
0483   06C4 2A            mov b, [d]
0484   06C5 74            mov d, b
0485   06C6 32            mov bl, [d]
0486   06C7 A7 00         mov bh, 0
0487   06C9             ; START RELATIONAL
0488   06C9 D7            push a
0489   06CA 11            mov a, b
0490   06CB 26 64 00      mov b, $64
0491   06CE B0            cmp a, b
0492   06CF FD 71         seq ; ==
0493   06D1 E4            pop a
0494   06D2             ; END RELATIONAL
0495   06D2 D7            push a
0496   06D3 11            mov a, b
0497   06D4 FA FD FF      lea d, [bp + -3] ; $fp
0498   06D7 2A            mov b, [d]
0499   06D8 74            mov d, b
0500   06D9 32            mov bl, [d]
0501   06DA A7 00         mov bh, 0
0502   06DC             ; START RELATIONAL
0503   06DC D7            push a
0504   06DD 11            mov a, b
0505   06DE 26 69 00      mov b, $69
0506   06E1 B0            cmp a, b
0507   06E2 FD 71         seq ; ==
0508   06E4 E4            pop a
0509   06E5             ; END RELATIONAL
0510   06E5 FD A8         sor a, b ; ||
0511   06E7 E4            pop a
0512   06E8 C0 00 00      cmp b, 0
0513   06EB C6 01 07      je _if9_else
0514   06EE             _if9_true:
0515   06EE             ;; print_signed_long(*(long *)p); 
0516   06EE 74            mov d, b
0517   06EF FD 79         mov g, b
0518   06F1 28            mov b, c
0519   06F2 FD AB         swp b
0520   06F4 D8            push b
0521   06F5 FD 27         mov b, g
0522   06F7 D8            push b
0523   06F8 07 27 0C      call print_signed_long
0524   06FB 51 04 00      add sp, 4
0525   06FE 0A 6E 07      jmp _if9_exit
0526   0701             _if9_else:
0527   0701             ;; if(*fp == 'u') 
0528   0701             _if10_cond:
0529   0701 FA FD FF      lea d, [bp + -3] ; $fp
0530   0704 2A            mov b, [d]
0531   0705 74            mov d, b
0532   0706 32            mov bl, [d]
0533   0707 A7 00         mov bh, 0
0534   0709             ; START RELATIONAL
0535   0709 D7            push a
0536   070A 11            mov a, b
0537   070B 26 75 00      mov b, $75
0538   070E B0            cmp a, b
0539   070F FD 71         seq ; ==
0540   0711 E4            pop a
0541   0712             ; END RELATIONAL
0542   0712 C0 00 00      cmp b, 0
0543   0715 C6 2B 07      je _if10_else
0544   0718             _if10_true:
0545   0718             ;; print_unsigned_long(*(unsigned long *)p); 
0546   0718 74            mov d, b
0547   0719 FD 79         mov g, b
0548   071B 28            mov b, c
0549   071C FD AB         swp b
0550   071E D8            push b
0551   071F FD 27         mov b, g
0552   0721 D8            push b
0553   0722 07 5C 0D      call print_unsigned_long
0554   0725 51 04 00      add sp, 4
0555   0728 0A 6E 07      jmp _if10_exit
0556   072B             _if10_else:
0557   072B             ;; if(*fp == 'x') 
0558   072B             _if11_cond:
0559   072B FA FD FF      lea d, [bp + -3] ; $fp
0560   072E 2A            mov b, [d]
0561   072F 74            mov d, b
0562   0730 32            mov bl, [d]
0563   0731 A7 00         mov bh, 0
0564   0733             ; START RELATIONAL
0565   0733 D7            push a
0566   0734 11            mov a, b
0567   0735 26 78 00      mov b, $78
0568   0738 B0            cmp a, b
0569   0739 FD 71         seq ; ==
0570   073B E4            pop a
0571   073C             ; END RELATIONAL
0572   073C C0 00 00      cmp b, 0
0573   073F C6 62 07      je _if11_else
0574   0742             _if11_true:
0575   0742             ;; printx32(*(long int *)p); 
0576   0742 FA FF FF      lea d, [bp + -1] ; $p
0577   0745 2A            mov b, [d]
0578   0746 AB            snex b
0579   0747 FD 39         mov c, b
0580   0749 74            mov d, b
0581   074A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0582   074D FD 39         mov c, b ; And place it into C
0583   074F 2A            mov b, [d] ; Lower Word in B
0584   0750 FD 79         mov g, b
0585   0752 28            mov b, c
0586   0753 FD AB         swp b
0587   0755 D8            push b
0588   0756 FD 27         mov b, g
0589   0758 D8            push b
0590   0759 07 9A 08      call printx32
0591   075C 51 04 00      add sp, 4
0592   075F 0A 6E 07      jmp _if11_exit
0593   0762             _if11_else:
0594   0762             ;; err("Unexpected format in printf."); 
0595   0762 26 65 14      mov b, __s1 ; "Unexpected format in printf."
0596   0765 FD AB         swp b
0597   0767 D8            push b
0598   0768 07 85 08      call err
0599   076B 51 02 00      add sp, 2
0600   076E             _if11_exit:
0601   076E             _if10_exit:
0602   076E             _if9_exit:
0603   076E             ;; p = p + 4; 
0604   076E FA FF FF      lea d, [bp + -1] ; $p
0605   0771 DA            push d
0606   0772 FA FF FF      lea d, [bp + -1] ; $p
0607   0775 2A            mov b, [d]
0608   0776             ; START TERMS
0609   0776 D7            push a
0610   0777 11            mov a, b
0611   0778 26 04 00      mov b, $4
0612   077B 54            add a, b
0613   077C 27            mov b, a
0614   077D E4            pop a
0615   077E             ; END TERMS
0616   077E E7            pop d
0617   077F FD 43         mov [d], b
0618   0781             ;; break; 
0619   0781 0A 54 08      jmp _switch8_exit ; case break
0620   0784             _switch8_case2:
0621   0784             _switch8_case3:
0622   0784             ;; print_signed(*(int*)p); 
0623   0784 FA FF FF      lea d, [bp + -1] ; $p
0624   0787 2A            mov b, [d]
0625   0788 AB            snex b
0626   0789 74            mov d, b
0627   078A 2A            mov b, [d]
0628   078B FD AB         swp b
0629   078D D8            push b
0630   078E 07 36 0B      call print_signed
0631   0791 51 02 00      add sp, 2
0632   0794             ;; p = p + 2; 
0633   0794 FA FF FF      lea d, [bp + -1] ; $p
0634   0797 DA            push d
0635   0798 FA FF FF      lea d, [bp + -1] ; $p
0636   079B 2A            mov b, [d]
0637   079C             ; START TERMS
0638   079C D7            push a
0639   079D 11            mov a, b
0640   079E 26 02 00      mov b, $2
0641   07A1 54            add a, b
0642   07A2 27            mov b, a
0643   07A3 E4            pop a
0644   07A4             ; END TERMS
0645   07A4 E7            pop d
0646   07A5 FD 43         mov [d], b
0647   07A7             ;; break; 
0648   07A7 0A 54 08      jmp _switch8_exit ; case break
0649   07AA             _switch8_case4:
0650   07AA             ;; print_unsigned(*(unsigned int*)p); 
0651   07AA FA FF FF      lea d, [bp + -1] ; $p
0652   07AD 2A            mov b, [d]
0653   07AE A7 00         mov bh, 0
0654   07B0 74            mov d, b
0655   07B1 2A            mov b, [d]
0656   07B2 FD AB         swp b
0657   07B4 D8            push b
0658   07B5 07 53 0E      call print_unsigned
0659   07B8 51 02 00      add sp, 2
0660   07BB             ;; p = p + 2; 
0661   07BB FA FF FF      lea d, [bp + -1] ; $p
0662   07BE DA            push d
0663   07BF FA FF FF      lea d, [bp + -1] ; $p
0664   07C2 2A            mov b, [d]
0665   07C3             ; START TERMS
0666   07C3 D7            push a
0667   07C4 11            mov a, b
0668   07C5 26 02 00      mov b, $2
0669   07C8 54            add a, b
0670   07C9 27            mov b, a
0671   07CA E4            pop a
0672   07CB             ; END TERMS
0673   07CB E7            pop d
0674   07CC FD 43         mov [d], b
0675   07CE             ;; break; 
0676   07CE 0A 54 08      jmp _switch8_exit ; case break
0677   07D1             _switch8_case5:
0678   07D1             ;; printx16(*(unsigned int*)p); 
0679   07D1 FA FF FF      lea d, [bp + -1] ; $p
0680   07D4 2A            mov b, [d]
0681   07D5 A7 00         mov bh, 0
0682   07D7 74            mov d, b
0683   07D8 2A            mov b, [d]
0684   07D9 FD AB         swp b
0685   07DB D8            push b
0686   07DC 07 AC 08      call printx16
0687   07DF 51 02 00      add sp, 2
0688   07E2             ;; p = p + 2; 
0689   07E2 FA FF FF      lea d, [bp + -1] ; $p
0690   07E5 DA            push d
0691   07E6 FA FF FF      lea d, [bp + -1] ; $p
0692   07E9 2A            mov b, [d]
0693   07EA             ; START TERMS
0694   07EA D7            push a
0695   07EB 11            mov a, b
0696   07EC 26 02 00      mov b, $2
0697   07EF 54            add a, b
0698   07F0 27            mov b, a
0699   07F1 E4            pop a
0700   07F2             ; END TERMS
0701   07F2 E7            pop d
0702   07F3 FD 43         mov [d], b
0703   07F5             ;; break; 
0704   07F5 0A 54 08      jmp _switch8_exit ; case break
0705   07F8             _switch8_case6:
0706   07F8             ;; putchar(*(char*)p); 
0707   07F8 FA FF FF      lea d, [bp + -1] ; $p
0708   07FB 2A            mov b, [d]
0709   07FC A7 00         mov bh, 0
0710   07FE 74            mov d, b
0711   07FF 32            mov bl, [d]
0712   0800 A7 00         mov bh, 0
0713   0802 DD            push bl
0714   0803 07 3B 0F      call putchar
0715   0806 51 01 00      add sp, 1
0716   0809             ;; p = p + 2; 
0717   0809 FA FF FF      lea d, [bp + -1] ; $p
0718   080C DA            push d
0719   080D FA FF FF      lea d, [bp + -1] ; $p
0720   0810 2A            mov b, [d]
0721   0811             ; START TERMS
0722   0811 D7            push a
0723   0812 11            mov a, b
0724   0813 26 02 00      mov b, $2
0725   0816 54            add a, b
0726   0817 27            mov b, a
0727   0818 E4            pop a
0728   0819             ; END TERMS
0729   0819 E7            pop d
0730   081A FD 43         mov [d], b
0731   081C             ;; break; 
0732   081C 0A 54 08      jmp _switch8_exit ; case break
0733   081F             _switch8_case7:
0734   081F             ;; print(*(char**)p); 
0735   081F FA FF FF      lea d, [bp + -1] ; $p
0736   0822 2A            mov b, [d]
0737   0823 A7 00         mov bh, 0
0738   0825 74            mov d, b
0739   0826 32            mov bl, [d]
0740   0827 A7 00         mov bh, 0
0741   0829 FD AB         swp b
0742   082B D8            push b
0743   082C 07 83 0F      call print
0744   082F 51 02 00      add sp, 2
0745   0832             ;; p = p + 2; 
0746   0832 FA FF FF      lea d, [bp + -1] ; $p
0747   0835 DA            push d
0748   0836 FA FF FF      lea d, [bp + -1] ; $p
0749   0839 2A            mov b, [d]
0750   083A             ; START TERMS
0751   083A D7            push a
0752   083B 11            mov a, b
0753   083C 26 02 00      mov b, $2
0754   083F 54            add a, b
0755   0840 27            mov b, a
0756   0841 E4            pop a
0757   0842             ; END TERMS
0758   0842 E7            pop d
0759   0843 FD 43         mov [d], b
0760   0845             ;; break; 
0761   0845 0A 54 08      jmp _switch8_exit ; case break
0762   0848             _switch8_default:
0763   0848             ;; print("Error: Unknown argument type.\n"); 
0764   0848 26 82 14      mov b, __s2 ; "Error: Unknown argument type.\n"
0765   084B FD AB         swp b
0766   084D D8            push b
0767   084E 07 83 0F      call print
0768   0851 51 02 00      add sp, 2
0769   0854             _switch8_exit:
0770   0854             ;; fp++; 
0771   0854 FA FD FF      lea d, [bp + -3] ; $fp
0772   0857 2A            mov b, [d]
0773   0858 D8            push b
0774   0859 FD 77         inc b
0775   085B FA FD FF      lea d, [bp + -3] ; $fp
0776   085E FD 43         mov [d], b
0777   0860 E5            pop b
0778   0861 0A 80 08      jmp _if7_exit
0779   0864             _if7_else:
0780   0864             ;; putchar(*fp); 
0781   0864 FA FD FF      lea d, [bp + -3] ; $fp
0782   0867 2A            mov b, [d]
0783   0868 74            mov d, b
0784   0869 32            mov bl, [d]
0785   086A A7 00         mov bh, 0
0786   086C DD            push bl
0787   086D 07 3B 0F      call putchar
0788   0870 51 01 00      add sp, 1
0789   0873             ;; fp++; 
0790   0873 FA FD FF      lea d, [bp + -3] ; $fp
0791   0876 2A            mov b, [d]
0792   0877 D8            push b
0793   0878 FD 77         inc b
0794   087A FA FD FF      lea d, [bp + -3] ; $fp
0795   087D FD 43         mov [d], b
0796   087F E5            pop b
0797   0880             _if7_exit:
0798   0880             _if6_exit:
0799   0880             _for5_update:
0800   0880 0A 41 06      jmp _for5_cond
0801   0883             _for5_exit:
0802   0883 F9            leave
0803   0884 09            ret
0804   0885             
0805   0885             err:
0806   0885 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0807   0888             ;; print(e); 
0808   0888 FA 05 00      lea d, [bp + 5] ; $e
0809   088B 2A            mov b, [d]
0810   088C FD AB         swp b
0811   088E D8            push b
0812   088F 07 83 0F      call print
0813   0892 51 02 00      add sp, 2
0814   0895             ;; exit(); 
0815   0895 07 FD 0F      call exit
0816   0898 F9            leave
0817   0899 09            ret
0818   089A             
0819   089A             printx32:
0820   089A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0821   089D             
0822   089D             ; --- BEGIN INLINE ASM BLOCK
0823   089D FA 05 00      lea d, [bp + 5] ; $hex
0824   08A0 2B 02 00      mov b, [d+2]
0825   08A3 07 5A 13      call print_u16x
0826   08A6 2A            mov b, [d]
0827   08A7 07 5A 13      call print_u16x
0828   08AA             ; --- END INLINE ASM BLOCK
0829   08AA             
0830   08AA F9            leave
0831   08AB 09            ret
0832   08AC             
0833   08AC             printx16:
0834   08AC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0835   08AF             
0836   08AF             ; --- BEGIN INLINE ASM BLOCK
0837   08AF FA 05 00      lea d, [bp + 5] ; $hex
0838   08B2 2A            mov b, [d]
0839   08B3 07 5A 13      call print_u16x
0840   08B6             ; --- END INLINE ASM BLOCK
0841   08B6             
0842   08B6 F9            leave
0843   08B7 09            ret
0844   08B8             
0845   08B8             printx8:
0846   08B8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0847   08BB             
0848   08BB             ; --- BEGIN INLINE ASM BLOCK
0849   08BB FA 05 00      lea d, [bp + 5] ; $hex
0850   08BE 32            mov bl, [d]
0851   08BF 07 9E 13      call print_u8x
0852   08C2             ; --- END INLINE ASM BLOCK
0853   08C2             
0854   08C2 F9            leave
0855   08C3 09            ret
0856   08C4             
0857   08C4             hex_to_int:
0858   08C4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0859   08C7             ; $value 
0860   08C7 10 00 00      mov a, $0
0861   08CA 45 FF FF      mov [bp + -1], a
0862   08CD             ; $i 
0863   08CD             ; $hex_char 
0864   08CD             ; $len 
0865   08CD 52 07 00      sub sp, 7
0866   08D0             ;; len = strlen(hex_string); 
0867   08D0 FA FA FF      lea d, [bp + -6] ; $len
0868   08D3 DA            push d
0869   08D4 FA 05 00      lea d, [bp + 5] ; $hex_string
0870   08D7 2A            mov b, [d]
0871   08D8 FD AB         swp b
0872   08DA D8            push b
0873   08DB 07 D4 05      call strlen
0874   08DE 51 02 00      add sp, 2
0875   08E1 E7            pop d
0876   08E2 FD 43         mov [d], b
0877   08E4             ;; for (i = 0; i < len; i++) { 
0878   08E4             _for12_init:
0879   08E4 FA FD FF      lea d, [bp + -3] ; $i
0880   08E7 DA            push d
0881   08E8 26 00 00      mov b, $0
0882   08EB E7            pop d
0883   08EC FD 43         mov [d], b
0884   08EE             _for12_cond:
0885   08EE FA FD FF      lea d, [bp + -3] ; $i
0886   08F1 2A            mov b, [d]
0887   08F2             ; START RELATIONAL
0888   08F2 D7            push a
0889   08F3 11            mov a, b
0890   08F4 FA FA FF      lea d, [bp + -6] ; $len
0891   08F7 2A            mov b, [d]
0892   08F8 B0            cmp a, b
0893   08F9 FD 73         slt ; < 
0894   08FB E4            pop a
0895   08FC             ; END RELATIONAL
0896   08FC C0 00 00      cmp b, 0
0897   08FF C6 04 0A      je _for12_exit
0898   0902             _for12_block:
0899   0902             ;; hex_char = hex_string[i]; 
0900   0902 FA FC FF      lea d, [bp + -4] ; $hex_char
0901   0905 DA            push d
0902   0906 FA 05 00      lea d, [bp + 5] ; $hex_string
0903   0909 FD 2A         mov d, [d]
0904   090B D7            push a
0905   090C DA            push d
0906   090D FA FD FF      lea d, [bp + -3] ; $i
0907   0910 2A            mov b, [d]
0908   0911 E7            pop d
0909   0912 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0910   0916 E4            pop a
0911   0917 32            mov bl, [d]
0912   0918 A7 00         mov bh, 0
0913   091A E7            pop d
0914   091B FD 3E         mov [d], bl
0915   091D             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0916   091D             _if13_cond:
0917   091D FA FC FF      lea d, [bp + -4] ; $hex_char
0918   0920 32            mov bl, [d]
0919   0921 A7 00         mov bh, 0
0920   0923             ; START RELATIONAL
0921   0923 D7            push a
0922   0924 11            mov a, b
0923   0925 26 61 00      mov b, $61
0924   0928 B0            cmp a, b
0925   0929 FD 80         sge ; >=
0926   092B E4            pop a
0927   092C             ; END RELATIONAL
0928   092C D7            push a
0929   092D 11            mov a, b
0930   092E FA FC FF      lea d, [bp + -4] ; $hex_char
0931   0931 32            mov bl, [d]
0932   0932 A7 00         mov bh, 0
0933   0934             ; START RELATIONAL
0934   0934 D7            push a
0935   0935 11            mov a, b
0936   0936 26 66 00      mov b, $66
0937   0939 B0            cmp a, b
0938   093A FD 74         sle ; <=
0939   093C E4            pop a
0940   093D             ; END RELATIONAL
0941   093D FD A7         sand a, b ; &&
0942   093F E4            pop a
0943   0940 C0 00 00      cmp b, 0
0944   0943 C6 75 09      je _if13_else
0945   0946             _if13_true:
0946   0946             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0947   0946 FA FF FF      lea d, [bp + -1] ; $value
0948   0949 DA            push d
0949   094A FA FF FF      lea d, [bp + -1] ; $value
0950   094D 2A            mov b, [d]
0951   094E             ; START FACTORS
0952   094E D7            push a
0953   094F 11            mov a, b
0954   0950 26 10 00      mov b, $10
0955   0953 AC            mul a, b ; *
0956   0954 11            mov a, b
0957   0955 27            mov b, a
0958   0956 E4            pop a
0959   0957             ; END FACTORS
0960   0957             ; START TERMS
0961   0957 D7            push a
0962   0958 11            mov a, b
0963   0959 FA FC FF      lea d, [bp + -4] ; $hex_char
0964   095C 32            mov bl, [d]
0965   095D A7 00         mov bh, 0
0966   095F             ; START TERMS
0967   095F D7            push a
0968   0960 11            mov a, b
0969   0961 26 61 00      mov b, $61
0970   0964 60            sub a, b
0971   0965 11            mov a, b
0972   0966 26 0A 00      mov b, $a
0973   0969 54            add a, b
0974   096A 27            mov b, a
0975   096B E4            pop a
0976   096C             ; END TERMS
0977   096C 54            add a, b
0978   096D 27            mov b, a
0979   096E E4            pop a
0980   096F             ; END TERMS
0981   096F E7            pop d
0982   0970 FD 43         mov [d], b
0983   0972 0A F4 09      jmp _if13_exit
0984   0975             _if13_else:
0985   0975             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0986   0975             _if14_cond:
0987   0975 FA FC FF      lea d, [bp + -4] ; $hex_char
0988   0978 32            mov bl, [d]
0989   0979 A7 00         mov bh, 0
0990   097B             ; START RELATIONAL
0991   097B D7            push a
0992   097C 11            mov a, b
0993   097D 26 41 00      mov b, $41
0994   0980 B0            cmp a, b
0995   0981 FD 80         sge ; >=
0996   0983 E4            pop a
0997   0984             ; END RELATIONAL
0998   0984 D7            push a
0999   0985 11            mov a, b
1000   0986 FA FC FF      lea d, [bp + -4] ; $hex_char
1001   0989 32            mov bl, [d]
1002   098A A7 00         mov bh, 0
1003   098C             ; START RELATIONAL
1004   098C D7            push a
1005   098D 11            mov a, b
1006   098E 26 46 00      mov b, $46
1007   0991 B0            cmp a, b
1008   0992 FD 74         sle ; <=
1009   0994 E4            pop a
1010   0995             ; END RELATIONAL
1011   0995 FD A7         sand a, b ; &&
1012   0997 E4            pop a
1013   0998 C0 00 00      cmp b, 0
1014   099B C6 CD 09      je _if14_else
1015   099E             _if14_true:
1016   099E             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1017   099E FA FF FF      lea d, [bp + -1] ; $value
1018   09A1 DA            push d
1019   09A2 FA FF FF      lea d, [bp + -1] ; $value
1020   09A5 2A            mov b, [d]
1021   09A6             ; START FACTORS
1022   09A6 D7            push a
1023   09A7 11            mov a, b
1024   09A8 26 10 00      mov b, $10
1025   09AB AC            mul a, b ; *
1026   09AC 11            mov a, b
1027   09AD 27            mov b, a
1028   09AE E4            pop a
1029   09AF             ; END FACTORS
1030   09AF             ; START TERMS
1031   09AF D7            push a
1032   09B0 11            mov a, b
1033   09B1 FA FC FF      lea d, [bp + -4] ; $hex_char
1034   09B4 32            mov bl, [d]
1035   09B5 A7 00         mov bh, 0
1036   09B7             ; START TERMS
1037   09B7 D7            push a
1038   09B8 11            mov a, b
1039   09B9 26 41 00      mov b, $41
1040   09BC 60            sub a, b
1041   09BD 11            mov a, b
1042   09BE 26 0A 00      mov b, $a
1043   09C1 54            add a, b
1044   09C2 27            mov b, a
1045   09C3 E4            pop a
1046   09C4             ; END TERMS
1047   09C4 54            add a, b
1048   09C5 27            mov b, a
1049   09C6 E4            pop a
1050   09C7             ; END TERMS
1051   09C7 E7            pop d
1052   09C8 FD 43         mov [d], b
1053   09CA 0A F4 09      jmp _if14_exit
1054   09CD             _if14_else:
1055   09CD             ;; value = (value * 16) + (hex_char - '0'); 
1056   09CD FA FF FF      lea d, [bp + -1] ; $value
1057   09D0 DA            push d
1058   09D1 FA FF FF      lea d, [bp + -1] ; $value
1059   09D4 2A            mov b, [d]
1060   09D5             ; START FACTORS
1061   09D5 D7            push a
1062   09D6 11            mov a, b
1063   09D7 26 10 00      mov b, $10
1064   09DA AC            mul a, b ; *
1065   09DB 11            mov a, b
1066   09DC 27            mov b, a
1067   09DD E4            pop a
1068   09DE             ; END FACTORS
1069   09DE             ; START TERMS
1070   09DE D7            push a
1071   09DF 11            mov a, b
1072   09E0 FA FC FF      lea d, [bp + -4] ; $hex_char
1073   09E3 32            mov bl, [d]
1074   09E4 A7 00         mov bh, 0
1075   09E6             ; START TERMS
1076   09E6 D7            push a
1077   09E7 11            mov a, b
1078   09E8 26 30 00      mov b, $30
1079   09EB 60            sub a, b
1080   09EC 27            mov b, a
1081   09ED E4            pop a
1082   09EE             ; END TERMS
1083   09EE 54            add a, b
1084   09EF 27            mov b, a
1085   09F0 E4            pop a
1086   09F1             ; END TERMS
1087   09F1 E7            pop d
1088   09F2 FD 43         mov [d], b
1089   09F4             _if14_exit:
1090   09F4             _if13_exit:
1091   09F4             _for12_update:
1092   09F4 FA FD FF      lea d, [bp + -3] ; $i
1093   09F7 2A            mov b, [d]
1094   09F8 D8            push b
1095   09F9 FD 77         inc b
1096   09FB FA FD FF      lea d, [bp + -3] ; $i
1097   09FE FD 43         mov [d], b
1098   0A00 E5            pop b
1099   0A01 0A EE 08      jmp _for12_cond
1100   0A04             _for12_exit:
1101   0A04             ;; return value; 
1102   0A04 FA FF FF      lea d, [bp + -1] ; $value
1103   0A07 2A            mov b, [d]
1104   0A08 F9            leave
1105   0A09 09            ret
1106   0A0A             
1107   0A0A             atoi:
1108   0A0A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1109   0A0D             ; $result 
1110   0A0D 10 00 00      mov a, $0
1111   0A10 45 FF FF      mov [bp + -1], a
1112   0A13             ; $sign 
1113   0A13 10 01 00      mov a, $1
1114   0A16 45 FD FF      mov [bp + -3], a
1115   0A19 52 04 00      sub sp, 4
1116   0A1C             ;; while (*str == ' ') str++; 
1117   0A1C             _while15_cond:
1118   0A1C FA 05 00      lea d, [bp + 5] ; $str
1119   0A1F 2A            mov b, [d]
1120   0A20 74            mov d, b
1121   0A21 32            mov bl, [d]
1122   0A22 A7 00         mov bh, 0
1123   0A24             ; START RELATIONAL
1124   0A24 D7            push a
1125   0A25 11            mov a, b
1126   0A26 26 20 00      mov b, $20
1127   0A29 B0            cmp a, b
1128   0A2A FD 71         seq ; ==
1129   0A2C E4            pop a
1130   0A2D             ; END RELATIONAL
1131   0A2D C0 00 00      cmp b, 0
1132   0A30 C6 43 0A      je _while15_exit
1133   0A33             _while15_block:
1134   0A33             ;; str++; 
1135   0A33 FA 05 00      lea d, [bp + 5] ; $str
1136   0A36 2A            mov b, [d]
1137   0A37 D8            push b
1138   0A38 FD 77         inc b
1139   0A3A FA 05 00      lea d, [bp + 5] ; $str
1140   0A3D FD 43         mov [d], b
1141   0A3F E5            pop b
1142   0A40 0A 1C 0A      jmp _while15_cond
1143   0A43             _while15_exit:
1144   0A43             ;; if (*str == '-' || *str == '+') { 
1145   0A43             _if16_cond:
1146   0A43 FA 05 00      lea d, [bp + 5] ; $str
1147   0A46 2A            mov b, [d]
1148   0A47 74            mov d, b
1149   0A48 32            mov bl, [d]
1150   0A49 A7 00         mov bh, 0
1151   0A4B             ; START RELATIONAL
1152   0A4B D7            push a
1153   0A4C 11            mov a, b
1154   0A4D 26 2D 00      mov b, $2d
1155   0A50 B0            cmp a, b
1156   0A51 FD 71         seq ; ==
1157   0A53 E4            pop a
1158   0A54             ; END RELATIONAL
1159   0A54 D7            push a
1160   0A55 11            mov a, b
1161   0A56 FA 05 00      lea d, [bp + 5] ; $str
1162   0A59 2A            mov b, [d]
1163   0A5A 74            mov d, b
1164   0A5B 32            mov bl, [d]
1165   0A5C A7 00         mov bh, 0
1166   0A5E             ; START RELATIONAL
1167   0A5E D7            push a
1168   0A5F 11            mov a, b
1169   0A60 26 2B 00      mov b, $2b
1170   0A63 B0            cmp a, b
1171   0A64 FD 71         seq ; ==
1172   0A66 E4            pop a
1173   0A67             ; END RELATIONAL
1174   0A67 FD A8         sor a, b ; ||
1175   0A69 E4            pop a
1176   0A6A C0 00 00      cmp b, 0
1177   0A6D C6 A6 0A      je _if16_exit
1178   0A70             _if16_true:
1179   0A70             ;; if (*str == '-') sign = -1; 
1180   0A70             _if17_cond:
1181   0A70 FA 05 00      lea d, [bp + 5] ; $str
1182   0A73 2A            mov b, [d]
1183   0A74 74            mov d, b
1184   0A75 32            mov bl, [d]
1185   0A76 A7 00         mov bh, 0
1186   0A78             ; START RELATIONAL
1187   0A78 D7            push a
1188   0A79 11            mov a, b
1189   0A7A 26 2D 00      mov b, $2d
1190   0A7D B0            cmp a, b
1191   0A7E FD 71         seq ; ==
1192   0A80 E4            pop a
1193   0A81             ; END RELATIONAL
1194   0A81 C0 00 00      cmp b, 0
1195   0A84 C6 96 0A      je _if17_exit
1196   0A87             _if17_true:
1197   0A87             ;; sign = -1; 
1198   0A87 FA FD FF      lea d, [bp + -3] ; $sign
1199   0A8A DA            push d
1200   0A8B 26 01 00      mov b, $1
1201   0A8E FD 97         neg b
1202   0A90 E7            pop d
1203   0A91 FD 43         mov [d], b
1204   0A93 0A 96 0A      jmp _if17_exit
1205   0A96             _if17_exit:
1206   0A96             ;; str++; 
1207   0A96 FA 05 00      lea d, [bp + 5] ; $str
1208   0A99 2A            mov b, [d]
1209   0A9A D8            push b
1210   0A9B FD 77         inc b
1211   0A9D FA 05 00      lea d, [bp + 5] ; $str
1212   0AA0 FD 43         mov [d], b
1213   0AA2 E5            pop b
1214   0AA3 0A A6 0A      jmp _if16_exit
1215   0AA6             _if16_exit:
1216   0AA6             ;; while (*str >= '0' && *str <= '9') { 
1217   0AA6             _while18_cond:
1218   0AA6 FA 05 00      lea d, [bp + 5] ; $str
1219   0AA9 2A            mov b, [d]
1220   0AAA 74            mov d, b
1221   0AAB 32            mov bl, [d]
1222   0AAC A7 00         mov bh, 0
1223   0AAE             ; START RELATIONAL
1224   0AAE D7            push a
1225   0AAF 11            mov a, b
1226   0AB0 26 30 00      mov b, $30
1227   0AB3 B0            cmp a, b
1228   0AB4 FD 82         sgeu ; >= (unsigned)
1229   0AB6 E4            pop a
1230   0AB7             ; END RELATIONAL
1231   0AB7 D7            push a
1232   0AB8 11            mov a, b
1233   0AB9 FA 05 00      lea d, [bp + 5] ; $str
1234   0ABC 2A            mov b, [d]
1235   0ABD 74            mov d, b
1236   0ABE 32            mov bl, [d]
1237   0ABF A7 00         mov bh, 0
1238   0AC1             ; START RELATIONAL
1239   0AC1 D7            push a
1240   0AC2 11            mov a, b
1241   0AC3 26 39 00      mov b, $39
1242   0AC6 B0            cmp a, b
1243   0AC7 FD 76         sleu ; <= (unsigned)
1244   0AC9 E4            pop a
1245   0ACA             ; END RELATIONAL
1246   0ACA FD A7         sand a, b ; &&
1247   0ACC E4            pop a
1248   0ACD C0 00 00      cmp b, 0
1249   0AD0 C6 0C 0B      je _while18_exit
1250   0AD3             _while18_block:
1251   0AD3             ;; result = result * 10 + (*str - '0'); 
1252   0AD3 FA FF FF      lea d, [bp + -1] ; $result
1253   0AD6 DA            push d
1254   0AD7 FA FF FF      lea d, [bp + -1] ; $result
1255   0ADA 2A            mov b, [d]
1256   0ADB             ; START FACTORS
1257   0ADB D7            push a
1258   0ADC 11            mov a, b
1259   0ADD 26 0A 00      mov b, $a
1260   0AE0 AC            mul a, b ; *
1261   0AE1 11            mov a, b
1262   0AE2 27            mov b, a
1263   0AE3 E4            pop a
1264   0AE4             ; END FACTORS
1265   0AE4             ; START TERMS
1266   0AE4 D7            push a
1267   0AE5 11            mov a, b
1268   0AE6 FA 05 00      lea d, [bp + 5] ; $str
1269   0AE9 2A            mov b, [d]
1270   0AEA 74            mov d, b
1271   0AEB 32            mov bl, [d]
1272   0AEC A7 00         mov bh, 0
1273   0AEE             ; START TERMS
1274   0AEE D7            push a
1275   0AEF 11            mov a, b
1276   0AF0 26 30 00      mov b, $30
1277   0AF3 60            sub a, b
1278   0AF4 27            mov b, a
1279   0AF5 E4            pop a
1280   0AF6             ; END TERMS
1281   0AF6 54            add a, b
1282   0AF7 27            mov b, a
1283   0AF8 E4            pop a
1284   0AF9             ; END TERMS
1285   0AF9 E7            pop d
1286   0AFA FD 43         mov [d], b
1287   0AFC             ;; str++; 
1288   0AFC FA 05 00      lea d, [bp + 5] ; $str
1289   0AFF 2A            mov b, [d]
1290   0B00 D8            push b
1291   0B01 FD 77         inc b
1292   0B03 FA 05 00      lea d, [bp + 5] ; $str
1293   0B06 FD 43         mov [d], b
1294   0B08 E5            pop b
1295   0B09 0A A6 0A      jmp _while18_cond
1296   0B0C             _while18_exit:
1297   0B0C             ;; return sign * result; 
1298   0B0C FA FD FF      lea d, [bp + -3] ; $sign
1299   0B0F 2A            mov b, [d]
1300   0B10             ; START FACTORS
1301   0B10 D7            push a
1302   0B11 11            mov a, b
1303   0B12 FA FF FF      lea d, [bp + -1] ; $result
1304   0B15 2A            mov b, [d]
1305   0B16 AC            mul a, b ; *
1306   0B17 11            mov a, b
1307   0B18 27            mov b, a
1308   0B19 E4            pop a
1309   0B1A             ; END FACTORS
1310   0B1A F9            leave
1311   0B1B 09            ret
1312   0B1C             
1313   0B1C             gets:
1314   0B1C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1315   0B1F             
1316   0B1F             ; --- BEGIN INLINE ASM BLOCK
1317   0B1F FA 05 00      lea d, [bp + 5] ; $s
1318   0B22 15            mov a, [d]
1319   0B23 3C            mov d, a
1320   0B24 07 BF 11      call _gets
1321   0B27             ; --- END INLINE ASM BLOCK
1322   0B27             
1323   0B27             ;; return strlen(s); 
1324   0B27 FA 05 00      lea d, [bp + 5] ; $s
1325   0B2A 2A            mov b, [d]
1326   0B2B FD AB         swp b
1327   0B2D D8            push b
1328   0B2E 07 D4 05      call strlen
1329   0B31 51 02 00      add sp, 2
1330   0B34 F9            leave
1331   0B35 09            ret
1332   0B36             
1333   0B36             print_signed:
1334   0B36 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1335   0B39             ; $digits 
1336   0B39             ; $i 
1337   0B39 10 00 00      mov a, $0
1338   0B3C 45 FA FF      mov [bp + -6], a
1339   0B3F 52 07 00      sub sp, 7
1340   0B42             ;; if (num < 0) { 
1341   0B42             _if19_cond:
1342   0B42 FA 05 00      lea d, [bp + 5] ; $num
1343   0B45 2A            mov b, [d]
1344   0B46             ; START RELATIONAL
1345   0B46 D7            push a
1346   0B47 11            mov a, b
1347   0B48 26 00 00      mov b, $0
1348   0B4B B0            cmp a, b
1349   0B4C FD 73         slt ; < 
1350   0B4E E4            pop a
1351   0B4F             ; END RELATIONAL
1352   0B4F C0 00 00      cmp b, 0
1353   0B52 C6 6F 0B      je _if19_else
1354   0B55             _if19_true:
1355   0B55             ;; putchar('-'); 
1356   0B55 26 2D 00      mov b, $2d
1357   0B58 DD            push bl
1358   0B59 07 3B 0F      call putchar
1359   0B5C 51 01 00      add sp, 1
1360   0B5F             ;; num = -num; 
1361   0B5F FA 05 00      lea d, [bp + 5] ; $num
1362   0B62 DA            push d
1363   0B63 FA 05 00      lea d, [bp + 5] ; $num
1364   0B66 2A            mov b, [d]
1365   0B67 FD 97         neg b
1366   0B69 E7            pop d
1367   0B6A FD 43         mov [d], b
1368   0B6C 0A 91 0B      jmp _if19_exit
1369   0B6F             _if19_else:
1370   0B6F             ;; if (num == 0) { 
1371   0B6F             _if20_cond:
1372   0B6F FA 05 00      lea d, [bp + 5] ; $num
1373   0B72 2A            mov b, [d]
1374   0B73             ; START RELATIONAL
1375   0B73 D7            push a
1376   0B74 11            mov a, b
1377   0B75 26 00 00      mov b, $0
1378   0B78 B0            cmp a, b
1379   0B79 FD 71         seq ; ==
1380   0B7B E4            pop a
1381   0B7C             ; END RELATIONAL
1382   0B7C C0 00 00      cmp b, 0
1383   0B7F C6 91 0B      je _if20_exit
1384   0B82             _if20_true:
1385   0B82             ;; putchar('0'); 
1386   0B82 26 30 00      mov b, $30
1387   0B85 DD            push bl
1388   0B86 07 3B 0F      call putchar
1389   0B89 51 01 00      add sp, 1
1390   0B8C             ;; return; 
1391   0B8C F9            leave
1392   0B8D 09            ret
1393   0B8E 0A 91 0B      jmp _if20_exit
1394   0B91             _if20_exit:
1395   0B91             _if19_exit:
1396   0B91             ;; while (num > 0) { 
1397   0B91             _while21_cond:
1398   0B91 FA 05 00      lea d, [bp + 5] ; $num
1399   0B94 2A            mov b, [d]
1400   0B95             ; START RELATIONAL
1401   0B95 D7            push a
1402   0B96 11            mov a, b
1403   0B97 26 00 00      mov b, $0
1404   0B9A B0            cmp a, b
1405   0B9B FD 7F         sgt ; >
1406   0B9D E4            pop a
1407   0B9E             ; END RELATIONAL
1408   0B9E C0 00 00      cmp b, 0
1409   0BA1 C6 EC 0B      je _while21_exit
1410   0BA4             _while21_block:
1411   0BA4             ;; digits[i] = '0' + (num % 10); 
1412   0BA4 FA FC FF      lea d, [bp + -4] ; $digits
1413   0BA7 D7            push a
1414   0BA8 DA            push d
1415   0BA9 FA FA FF      lea d, [bp + -6] ; $i
1416   0BAC 2A            mov b, [d]
1417   0BAD E7            pop d
1418   0BAE 5A            add d, b
1419   0BAF E4            pop a
1420   0BB0 DA            push d
1421   0BB1 26 30 00      mov b, $30
1422   0BB4             ; START TERMS
1423   0BB4 D7            push a
1424   0BB5 11            mov a, b
1425   0BB6 FA 05 00      lea d, [bp + 5] ; $num
1426   0BB9 2A            mov b, [d]
1427   0BBA             ; START FACTORS
1428   0BBA D7            push a
1429   0BBB 11            mov a, b
1430   0BBC 26 0A 00      mov b, $a
1431   0BBF AE            div a, b ; 
1432   0BC0 11            mov a, b
1433   0BC1 27            mov b, a
1434   0BC2 E4            pop a
1435   0BC3             ; END FACTORS
1436   0BC3 54            add a, b
1437   0BC4 27            mov b, a
1438   0BC5 E4            pop a
1439   0BC6             ; END TERMS
1440   0BC6 E7            pop d
1441   0BC7 FD 3E         mov [d], bl
1442   0BC9             ;; num = num / 10; 
1443   0BC9 FA 05 00      lea d, [bp + 5] ; $num
1444   0BCC DA            push d
1445   0BCD FA 05 00      lea d, [bp + 5] ; $num
1446   0BD0 2A            mov b, [d]
1447   0BD1             ; START FACTORS
1448   0BD1 D7            push a
1449   0BD2 11            mov a, b
1450   0BD3 26 0A 00      mov b, $a
1451   0BD6 AE            div a, b
1452   0BD7 27            mov b, a
1453   0BD8 E4            pop a
1454   0BD9             ; END FACTORS
1455   0BD9 E7            pop d
1456   0BDA FD 43         mov [d], b
1457   0BDC             ;; i++; 
1458   0BDC FA FA FF      lea d, [bp + -6] ; $i
1459   0BDF 2A            mov b, [d]
1460   0BE0 D8            push b
1461   0BE1 FD 77         inc b
1462   0BE3 FA FA FF      lea d, [bp + -6] ; $i
1463   0BE6 FD 43         mov [d], b
1464   0BE8 E5            pop b
1465   0BE9 0A 91 0B      jmp _while21_cond
1466   0BEC             _while21_exit:
1467   0BEC             ;; while (i > 0) { 
1468   0BEC             _while22_cond:
1469   0BEC FA FA FF      lea d, [bp + -6] ; $i
1470   0BEF 2A            mov b, [d]
1471   0BF0             ; START RELATIONAL
1472   0BF0 D7            push a
1473   0BF1 11            mov a, b
1474   0BF2 26 00 00      mov b, $0
1475   0BF5 B0            cmp a, b
1476   0BF6 FD 7F         sgt ; >
1477   0BF8 E4            pop a
1478   0BF9             ; END RELATIONAL
1479   0BF9 C0 00 00      cmp b, 0
1480   0BFC C6 25 0C      je _while22_exit
1481   0BFF             _while22_block:
1482   0BFF             ;; i--; 
1483   0BFF FA FA FF      lea d, [bp + -6] ; $i
1484   0C02 2A            mov b, [d]
1485   0C03 D8            push b
1486   0C04 FD 7D         dec b
1487   0C06 FA FA FF      lea d, [bp + -6] ; $i
1488   0C09 FD 43         mov [d], b
1489   0C0B E5            pop b
1490   0C0C             ;; putchar(digits[i]); 
1491   0C0C FA FC FF      lea d, [bp + -4] ; $digits
1492   0C0F D7            push a
1493   0C10 DA            push d
1494   0C11 FA FA FF      lea d, [bp + -6] ; $i
1495   0C14 2A            mov b, [d]
1496   0C15 E7            pop d
1497   0C16 5A            add d, b
1498   0C17 E4            pop a
1499   0C18 32            mov bl, [d]
1500   0C19 A7 00         mov bh, 0
1501   0C1B DD            push bl
1502   0C1C 07 3B 0F      call putchar
1503   0C1F 51 01 00      add sp, 1
1504   0C22 0A EC 0B      jmp _while22_cond
1505   0C25             _while22_exit:
1506   0C25 F9            leave
1507   0C26 09            ret
1508   0C27             
1509   0C27             print_signed_long:
1510   0C27 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1511   0C2A             ; $digits 
1512   0C2A             ; $i 
1513   0C2A 10 00 00      mov a, $0
1514   0C2D 45 F5 FF      mov [bp + -11], a
1515   0C30 52 0C 00      sub sp, 12
1516   0C33             ;; if (num < 0) { 
1517   0C33             _if23_cond:
1518   0C33 FA 05 00      lea d, [bp + 5] ; $num
1519   0C36 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1520   0C39 FD 39         mov c, b ; And place it into C
1521   0C3B 2A            mov b, [d] ; Lower Word in B
1522   0C3C             ; START RELATIONAL
1523   0C3C D7            push a
1524   0C3D FD D8         push g
1525   0C3F 11            mov a, b
1526   0C40 FD 7A         mov g, c
1527   0C42 26 00 00      mov b, $0
1528   0C45 B0            cmp a, b
1529   0C46 FD 73         slt ; < 
1530   0C48 FD F1         pop g
1531   0C4A E4            pop a
1532   0C4B             ; END RELATIONAL
1533   0C4B C0 00 00      cmp b, 0
1534   0C4E C6 75 0C      je _if23_else
1535   0C51             _if23_true:
1536   0C51             ;; putchar('-'); 
1537   0C51 26 2D 00      mov b, $2d
1538   0C54 DD            push bl
1539   0C55 07 3B 0F      call putchar
1540   0C58 51 01 00      add sp, 1
1541   0C5B             ;; num = -num; 
1542   0C5B FA 05 00      lea d, [bp + 5] ; $num
1543   0C5E DA            push d
1544   0C5F FA 05 00      lea d, [bp + 5] ; $num
1545   0C62 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1546   0C65 FD 39         mov c, b ; And place it into C
1547   0C67 2A            mov b, [d] ; Lower Word in B
1548   0C68 FD 97         neg b
1549   0C6A E7            pop d
1550   0C6B FD 43         mov [d], b
1551   0C6D 28            mov b, c
1552   0C6E FD 44 02 00   mov [d + 2], b
1553   0C72 0A AC 0C      jmp _if23_exit
1554   0C75             _if23_else:
1555   0C75             ;; if (num == 0) { 
1556   0C75             _if24_cond:
1557   0C75 FA 05 00      lea d, [bp + 5] ; $num
1558   0C78 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1559   0C7B FD 39         mov c, b ; And place it into C
1560   0C7D 2A            mov b, [d] ; Lower Word in B
1561   0C7E             ; START RELATIONAL
1562   0C7E D7            push a
1563   0C7F FD D8         push g
1564   0C81 11            mov a, b
1565   0C82 FD 7A         mov g, c
1566   0C84 26 00 00      mov b, $0
1567   0C87 B0            cmp a, b
1568   0C88 FD 71         seq ; ==
1569   0C8A D8            push b
1570   0C8B 12            mov a, c
1571   0C8C FD 27         mov b, g
1572   0C8E B0            cmp a, b
1573   0C8F FD 71         seq ; ==
1574   0C91 E4            pop a
1575   0C92 FD A7         sand a, b
1576   0C94 FD F1         pop g
1577   0C96 E4            pop a
1578   0C97             ; END RELATIONAL
1579   0C97 C0 00 00      cmp b, 0
1580   0C9A C6 AC 0C      je _if24_exit
1581   0C9D             _if24_true:
1582   0C9D             ;; putchar('0'); 
1583   0C9D 26 30 00      mov b, $30
1584   0CA0 DD            push bl
1585   0CA1 07 3B 0F      call putchar
1586   0CA4 51 01 00      add sp, 1
1587   0CA7             ;; return; 
1588   0CA7 F9            leave
1589   0CA8 09            ret
1590   0CA9 0A AC 0C      jmp _if24_exit
1591   0CAC             _if24_exit:
1592   0CAC             _if23_exit:
1593   0CAC             ;; while (num > 0) { 
1594   0CAC             _while25_cond:
1595   0CAC FA 05 00      lea d, [bp + 5] ; $num
1596   0CAF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1597   0CB2 FD 39         mov c, b ; And place it into C
1598   0CB4 2A            mov b, [d] ; Lower Word in B
1599   0CB5             ; START RELATIONAL
1600   0CB5 D7            push a
1601   0CB6 FD D8         push g
1602   0CB8 11            mov a, b
1603   0CB9 FD 7A         mov g, c
1604   0CBB 26 00 00      mov b, $0
1605   0CBE B0            cmp a, b
1606   0CBF FD 7F         sgt ; >
1607   0CC1 FD F1         pop g
1608   0CC3 E4            pop a
1609   0CC4             ; END RELATIONAL
1610   0CC4 C0 00 00      cmp b, 0
1611   0CC7 C6 21 0D      je _while25_exit
1612   0CCA             _while25_block:
1613   0CCA             ;; digits[i] = '0' + (num % 10); 
1614   0CCA FA F7 FF      lea d, [bp + -9] ; $digits
1615   0CCD D7            push a
1616   0CCE DA            push d
1617   0CCF FA F5 FF      lea d, [bp + -11] ; $i
1618   0CD2 2A            mov b, [d]
1619   0CD3 E7            pop d
1620   0CD4 5A            add d, b
1621   0CD5 E4            pop a
1622   0CD6 DA            push d
1623   0CD7 26 30 00      mov b, $30
1624   0CDA             ; START TERMS
1625   0CDA D7            push a
1626   0CDB 11            mov a, b
1627   0CDC FA 05 00      lea d, [bp + 5] ; $num
1628   0CDF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1629   0CE2 FD 39         mov c, b ; And place it into C
1630   0CE4 2A            mov b, [d] ; Lower Word in B
1631   0CE5             ; START FACTORS
1632   0CE5 D7            push a
1633   0CE6 11            mov a, b
1634   0CE7 26 0A 00      mov b, $a
1635   0CEA AE            div a, b ; 
1636   0CEB 11            mov a, b
1637   0CEC 27            mov b, a
1638   0CED E4            pop a
1639   0CEE             ; END FACTORS
1640   0CEE 54            add a, b
1641   0CEF 27            mov b, a
1642   0CF0 E4            pop a
1643   0CF1             ; END TERMS
1644   0CF1 E7            pop d
1645   0CF2 FD 3E         mov [d], bl
1646   0CF4             ;; num = num / 10; 
1647   0CF4 FA 05 00      lea d, [bp + 5] ; $num
1648   0CF7 DA            push d
1649   0CF8 FA 05 00      lea d, [bp + 5] ; $num
1650   0CFB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1651   0CFE FD 39         mov c, b ; And place it into C
1652   0D00 2A            mov b, [d] ; Lower Word in B
1653   0D01             ; START FACTORS
1654   0D01 D7            push a
1655   0D02 11            mov a, b
1656   0D03 26 0A 00      mov b, $a
1657   0D06 AE            div a, b
1658   0D07 27            mov b, a
1659   0D08 E4            pop a
1660   0D09             ; END FACTORS
1661   0D09 E7            pop d
1662   0D0A FD 43         mov [d], b
1663   0D0C 28            mov b, c
1664   0D0D FD 44 02 00   mov [d + 2], b
1665   0D11             ;; i++; 
1666   0D11 FA F5 FF      lea d, [bp + -11] ; $i
1667   0D14 2A            mov b, [d]
1668   0D15 D8            push b
1669   0D16 FD 77         inc b
1670   0D18 FA F5 FF      lea d, [bp + -11] ; $i
1671   0D1B FD 43         mov [d], b
1672   0D1D E5            pop b
1673   0D1E 0A AC 0C      jmp _while25_cond
1674   0D21             _while25_exit:
1675   0D21             ;; while (i > 0) { 
1676   0D21             _while26_cond:
1677   0D21 FA F5 FF      lea d, [bp + -11] ; $i
1678   0D24 2A            mov b, [d]
1679   0D25             ; START RELATIONAL
1680   0D25 D7            push a
1681   0D26 11            mov a, b
1682   0D27 26 00 00      mov b, $0
1683   0D2A B0            cmp a, b
1684   0D2B FD 7F         sgt ; >
1685   0D2D E4            pop a
1686   0D2E             ; END RELATIONAL
1687   0D2E C0 00 00      cmp b, 0
1688   0D31 C6 5A 0D      je _while26_exit
1689   0D34             _while26_block:
1690   0D34             ;; i--; 
1691   0D34 FA F5 FF      lea d, [bp + -11] ; $i
1692   0D37 2A            mov b, [d]
1693   0D38 D8            push b
1694   0D39 FD 7D         dec b
1695   0D3B FA F5 FF      lea d, [bp + -11] ; $i
1696   0D3E FD 43         mov [d], b
1697   0D40 E5            pop b
1698   0D41             ;; putchar(digits[i]); 
1699   0D41 FA F7 FF      lea d, [bp + -9] ; $digits
1700   0D44 D7            push a
1701   0D45 DA            push d
1702   0D46 FA F5 FF      lea d, [bp + -11] ; $i
1703   0D49 2A            mov b, [d]
1704   0D4A E7            pop d
1705   0D4B 5A            add d, b
1706   0D4C E4            pop a
1707   0D4D 32            mov bl, [d]
1708   0D4E A7 00         mov bh, 0
1709   0D50 DD            push bl
1710   0D51 07 3B 0F      call putchar
1711   0D54 51 01 00      add sp, 1
1712   0D57 0A 21 0D      jmp _while26_cond
1713   0D5A             _while26_exit:
1714   0D5A F9            leave
1715   0D5B 09            ret
1716   0D5C             
1717   0D5C             print_unsigned_long:
1718   0D5C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1719   0D5F             ; $digits 
1720   0D5F             ; $i 
1721   0D5F 52 0C 00      sub sp, 12
1722   0D62             ;; i = 0; 
1723   0D62 FA F5 FF      lea d, [bp + -11] ; $i
1724   0D65 DA            push d
1725   0D66 26 00 00      mov b, $0
1726   0D69 E7            pop d
1727   0D6A FD 43         mov [d], b
1728   0D6C             ;; if(num == 0){ 
1729   0D6C             _if27_cond:
1730   0D6C FA 05 00      lea d, [bp + 5] ; $num
1731   0D6F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1732   0D72 FD 39         mov c, b ; And place it into C
1733   0D74 2A            mov b, [d] ; Lower Word in B
1734   0D75             ; START RELATIONAL
1735   0D75 D7            push a
1736   0D76 FD D8         push g
1737   0D78 11            mov a, b
1738   0D79 FD 7A         mov g, c
1739   0D7B 26 00 00      mov b, $0
1740   0D7E B0            cmp a, b
1741   0D7F FD 71         seq ; ==
1742   0D81 D8            push b
1743   0D82 12            mov a, c
1744   0D83 FD 27         mov b, g
1745   0D85 B0            cmp a, b
1746   0D86 FD 71         seq ; ==
1747   0D88 E4            pop a
1748   0D89 FD A7         sand a, b
1749   0D8B FD F1         pop g
1750   0D8D E4            pop a
1751   0D8E             ; END RELATIONAL
1752   0D8E C0 00 00      cmp b, 0
1753   0D91 C6 A3 0D      je _if27_exit
1754   0D94             _if27_true:
1755   0D94             ;; putchar('0'); 
1756   0D94 26 30 00      mov b, $30
1757   0D97 DD            push bl
1758   0D98 07 3B 0F      call putchar
1759   0D9B 51 01 00      add sp, 1
1760   0D9E             ;; return; 
1761   0D9E F9            leave
1762   0D9F 09            ret
1763   0DA0 0A A3 0D      jmp _if27_exit
1764   0DA3             _if27_exit:
1765   0DA3             ;; while (num > 0) { 
1766   0DA3             _while28_cond:
1767   0DA3 FA 05 00      lea d, [bp + 5] ; $num
1768   0DA6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1769   0DA9 FD 39         mov c, b ; And place it into C
1770   0DAB 2A            mov b, [d] ; Lower Word in B
1771   0DAC             ; START RELATIONAL
1772   0DAC D7            push a
1773   0DAD FD D8         push g
1774   0DAF 11            mov a, b
1775   0DB0 FD 7A         mov g, c
1776   0DB2 26 00 00      mov b, $0
1777   0DB5 B0            cmp a, b
1778   0DB6 FD 81         sgu ; > (unsigned)
1779   0DB8 FD F1         pop g
1780   0DBA E4            pop a
1781   0DBB             ; END RELATIONAL
1782   0DBB C0 00 00      cmp b, 0
1783   0DBE C6 18 0E      je _while28_exit
1784   0DC1             _while28_block:
1785   0DC1             ;; digits[i] = '0' + (num % 10); 
1786   0DC1 FA F7 FF      lea d, [bp + -9] ; $digits
1787   0DC4 D7            push a
1788   0DC5 DA            push d
1789   0DC6 FA F5 FF      lea d, [bp + -11] ; $i
1790   0DC9 2A            mov b, [d]
1791   0DCA E7            pop d
1792   0DCB 5A            add d, b
1793   0DCC E4            pop a
1794   0DCD DA            push d
1795   0DCE 26 30 00      mov b, $30
1796   0DD1             ; START TERMS
1797   0DD1 D7            push a
1798   0DD2 11            mov a, b
1799   0DD3 FA 05 00      lea d, [bp + 5] ; $num
1800   0DD6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1801   0DD9 FD 39         mov c, b ; And place it into C
1802   0DDB 2A            mov b, [d] ; Lower Word in B
1803   0DDC             ; START FACTORS
1804   0DDC D7            push a
1805   0DDD 11            mov a, b
1806   0DDE 26 0A 00      mov b, $a
1807   0DE1 AE            div a, b ; 
1808   0DE2 11            mov a, b
1809   0DE3 27            mov b, a
1810   0DE4 E4            pop a
1811   0DE5             ; END FACTORS
1812   0DE5 54            add a, b
1813   0DE6 27            mov b, a
1814   0DE7 E4            pop a
1815   0DE8             ; END TERMS
1816   0DE8 E7            pop d
1817   0DE9 FD 3E         mov [d], bl
1818   0DEB             ;; num = num / 10; 
1819   0DEB FA 05 00      lea d, [bp + 5] ; $num
1820   0DEE DA            push d
1821   0DEF FA 05 00      lea d, [bp + 5] ; $num
1822   0DF2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1823   0DF5 FD 39         mov c, b ; And place it into C
1824   0DF7 2A            mov b, [d] ; Lower Word in B
1825   0DF8             ; START FACTORS
1826   0DF8 D7            push a
1827   0DF9 11            mov a, b
1828   0DFA 26 0A 00      mov b, $a
1829   0DFD AE            div a, b
1830   0DFE 27            mov b, a
1831   0DFF E4            pop a
1832   0E00             ; END FACTORS
1833   0E00 E7            pop d
1834   0E01 FD 43         mov [d], b
1835   0E03 28            mov b, c
1836   0E04 FD 44 02 00   mov [d + 2], b
1837   0E08             ;; i++; 
1838   0E08 FA F5 FF      lea d, [bp + -11] ; $i
1839   0E0B 2A            mov b, [d]
1840   0E0C D8            push b
1841   0E0D FD 77         inc b
1842   0E0F FA F5 FF      lea d, [bp + -11] ; $i
1843   0E12 FD 43         mov [d], b
1844   0E14 E5            pop b
1845   0E15 0A A3 0D      jmp _while28_cond
1846   0E18             _while28_exit:
1847   0E18             ;; while (i > 0) { 
1848   0E18             _while29_cond:
1849   0E18 FA F5 FF      lea d, [bp + -11] ; $i
1850   0E1B 2A            mov b, [d]
1851   0E1C             ; START RELATIONAL
1852   0E1C D7            push a
1853   0E1D 11            mov a, b
1854   0E1E 26 00 00      mov b, $0
1855   0E21 B0            cmp a, b
1856   0E22 FD 7F         sgt ; >
1857   0E24 E4            pop a
1858   0E25             ; END RELATIONAL
1859   0E25 C0 00 00      cmp b, 0
1860   0E28 C6 51 0E      je _while29_exit
1861   0E2B             _while29_block:
1862   0E2B             ;; i--; 
1863   0E2B FA F5 FF      lea d, [bp + -11] ; $i
1864   0E2E 2A            mov b, [d]
1865   0E2F D8            push b
1866   0E30 FD 7D         dec b
1867   0E32 FA F5 FF      lea d, [bp + -11] ; $i
1868   0E35 FD 43         mov [d], b
1869   0E37 E5            pop b
1870   0E38             ;; putchar(digits[i]); 
1871   0E38 FA F7 FF      lea d, [bp + -9] ; $digits
1872   0E3B D7            push a
1873   0E3C DA            push d
1874   0E3D FA F5 FF      lea d, [bp + -11] ; $i
1875   0E40 2A            mov b, [d]
1876   0E41 E7            pop d
1877   0E42 5A            add d, b
1878   0E43 E4            pop a
1879   0E44 32            mov bl, [d]
1880   0E45 A7 00         mov bh, 0
1881   0E47 DD            push bl
1882   0E48 07 3B 0F      call putchar
1883   0E4B 51 01 00      add sp, 1
1884   0E4E 0A 18 0E      jmp _while29_cond
1885   0E51             _while29_exit:
1886   0E51 F9            leave
1887   0E52 09            ret
1888   0E53             
1889   0E53             print_unsigned:
1890   0E53 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1891   0E56             ; $digits 
1892   0E56             ; $i 
1893   0E56 52 07 00      sub sp, 7
1894   0E59             ;; i = 0; 
1895   0E59 FA FA FF      lea d, [bp + -6] ; $i
1896   0E5C DA            push d
1897   0E5D 26 00 00      mov b, $0
1898   0E60 E7            pop d
1899   0E61 FD 43         mov [d], b
1900   0E63             ;; if(num == 0){ 
1901   0E63             _if30_cond:
1902   0E63 FA 05 00      lea d, [bp + 5] ; $num
1903   0E66 2A            mov b, [d]
1904   0E67             ; START RELATIONAL
1905   0E67 D7            push a
1906   0E68 11            mov a, b
1907   0E69 26 00 00      mov b, $0
1908   0E6C B0            cmp a, b
1909   0E6D FD 71         seq ; ==
1910   0E6F E4            pop a
1911   0E70             ; END RELATIONAL
1912   0E70 C0 00 00      cmp b, 0
1913   0E73 C6 85 0E      je _if30_exit
1914   0E76             _if30_true:
1915   0E76             ;; putchar('0'); 
1916   0E76 26 30 00      mov b, $30
1917   0E79 DD            push bl
1918   0E7A 07 3B 0F      call putchar
1919   0E7D 51 01 00      add sp, 1
1920   0E80             ;; return; 
1921   0E80 F9            leave
1922   0E81 09            ret
1923   0E82 0A 85 0E      jmp _if30_exit
1924   0E85             _if30_exit:
1925   0E85             ;; while (num > 0) { 
1926   0E85             _while31_cond:
1927   0E85 FA 05 00      lea d, [bp + 5] ; $num
1928   0E88 2A            mov b, [d]
1929   0E89             ; START RELATIONAL
1930   0E89 D7            push a
1931   0E8A 11            mov a, b
1932   0E8B 26 00 00      mov b, $0
1933   0E8E B0            cmp a, b
1934   0E8F FD 81         sgu ; > (unsigned)
1935   0E91 E4            pop a
1936   0E92             ; END RELATIONAL
1937   0E92 C0 00 00      cmp b, 0
1938   0E95 C6 E0 0E      je _while31_exit
1939   0E98             _while31_block:
1940   0E98             ;; digits[i] = '0' + (num % 10); 
1941   0E98 FA FC FF      lea d, [bp + -4] ; $digits
1942   0E9B D7            push a
1943   0E9C DA            push d
1944   0E9D FA FA FF      lea d, [bp + -6] ; $i
1945   0EA0 2A            mov b, [d]
1946   0EA1 E7            pop d
1947   0EA2 5A            add d, b
1948   0EA3 E4            pop a
1949   0EA4 DA            push d
1950   0EA5 26 30 00      mov b, $30
1951   0EA8             ; START TERMS
1952   0EA8 D7            push a
1953   0EA9 11            mov a, b
1954   0EAA FA 05 00      lea d, [bp + 5] ; $num
1955   0EAD 2A            mov b, [d]
1956   0EAE             ; START FACTORS
1957   0EAE D7            push a
1958   0EAF 11            mov a, b
1959   0EB0 26 0A 00      mov b, $a
1960   0EB3 AE            div a, b ; 
1961   0EB4 11            mov a, b
1962   0EB5 27            mov b, a
1963   0EB6 E4            pop a
1964   0EB7             ; END FACTORS
1965   0EB7 54            add a, b
1966   0EB8 27            mov b, a
1967   0EB9 E4            pop a
1968   0EBA             ; END TERMS
1969   0EBA E7            pop d
1970   0EBB FD 3E         mov [d], bl
1971   0EBD             ;; num = num / 10; 
1972   0EBD FA 05 00      lea d, [bp + 5] ; $num
1973   0EC0 DA            push d
1974   0EC1 FA 05 00      lea d, [bp + 5] ; $num
1975   0EC4 2A            mov b, [d]
1976   0EC5             ; START FACTORS
1977   0EC5 D7            push a
1978   0EC6 11            mov a, b
1979   0EC7 26 0A 00      mov b, $a
1980   0ECA AE            div a, b
1981   0ECB 27            mov b, a
1982   0ECC E4            pop a
1983   0ECD             ; END FACTORS
1984   0ECD E7            pop d
1985   0ECE FD 43         mov [d], b
1986   0ED0             ;; i++; 
1987   0ED0 FA FA FF      lea d, [bp + -6] ; $i
1988   0ED3 2A            mov b, [d]
1989   0ED4 D8            push b
1990   0ED5 FD 77         inc b
1991   0ED7 FA FA FF      lea d, [bp + -6] ; $i
1992   0EDA FD 43         mov [d], b
1993   0EDC E5            pop b
1994   0EDD 0A 85 0E      jmp _while31_cond
1995   0EE0             _while31_exit:
1996   0EE0             ;; while (i > 0) { 
1997   0EE0             _while32_cond:
1998   0EE0 FA FA FF      lea d, [bp + -6] ; $i
1999   0EE3 2A            mov b, [d]
2000   0EE4             ; START RELATIONAL
2001   0EE4 D7            push a
2002   0EE5 11            mov a, b
2003   0EE6 26 00 00      mov b, $0
2004   0EE9 B0            cmp a, b
2005   0EEA FD 7F         sgt ; >
2006   0EEC E4            pop a
2007   0EED             ; END RELATIONAL
2008   0EED C0 00 00      cmp b, 0
2009   0EF0 C6 19 0F      je _while32_exit
2010   0EF3             _while32_block:
2011   0EF3             ;; i--; 
2012   0EF3 FA FA FF      lea d, [bp + -6] ; $i
2013   0EF6 2A            mov b, [d]
2014   0EF7 D8            push b
2015   0EF8 FD 7D         dec b
2016   0EFA FA FA FF      lea d, [bp + -6] ; $i
2017   0EFD FD 43         mov [d], b
2018   0EFF E5            pop b
2019   0F00             ;; putchar(digits[i]); 
2020   0F00 FA FC FF      lea d, [bp + -4] ; $digits
2021   0F03 D7            push a
2022   0F04 DA            push d
2023   0F05 FA FA FF      lea d, [bp + -6] ; $i
2024   0F08 2A            mov b, [d]
2025   0F09 E7            pop d
2026   0F0A 5A            add d, b
2027   0F0B E4            pop a
2028   0F0C 32            mov bl, [d]
2029   0F0D A7 00         mov bh, 0
2030   0F0F DD            push bl
2031   0F10 07 3B 0F      call putchar
2032   0F13 51 01 00      add sp, 1
2033   0F16 0A E0 0E      jmp _while32_cond
2034   0F19             _while32_exit:
2035   0F19 F9            leave
2036   0F1A 09            ret
2037   0F1B             
2038   0F1B             rand:
2039   0F1B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2040   0F1E             ; $sec 
2041   0F1E 52 01 00      sub sp, 1
2042   0F21             
2043   0F21             ; --- BEGIN INLINE ASM BLOCK
2044   0F21 19 00         mov al, 0
2045   0F23 05 01         syscall sys_rtc					
2046   0F25 1A            mov al, ah
2047   0F26 FA 00 00      lea d, [bp + 0] ; $sec
2048   0F29 1E            mov al, [d]
2049   0F2A             ; --- END INLINE ASM BLOCK
2050   0F2A             
2051   0F2A             ;; return sec; 
2052   0F2A FA 00 00      lea d, [bp + 0] ; $sec
2053   0F2D 32            mov bl, [d]
2054   0F2E A7 00         mov bh, 0
2055   0F30 F9            leave
2056   0F31 09            ret
2057   0F32             
2058   0F32             date:
2059   0F32 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2060   0F35             
2061   0F35             ; --- BEGIN INLINE ASM BLOCK
2062   0F35 19 00         mov al, 0 
2063   0F37 05 07         syscall sys_datetime
2064   0F39             ; --- END INLINE ASM BLOCK
2065   0F39             
2066   0F39 F9            leave
2067   0F3A 09            ret
2068   0F3B             
2069   0F3B             putchar:
2070   0F3B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2071   0F3E             
2072   0F3E             ; --- BEGIN INLINE ASM BLOCK
2073   0F3E FA 05 00      lea d, [bp + 5] ; $c
2074   0F41 1E            mov al, [d]
2075   0F42 23            mov ah, al
2076   0F43 07 B8 11      call _putchar
2077   0F46             ; --- END INLINE ASM BLOCK
2078   0F46             
2079   0F46 F9            leave
2080   0F47 09            ret
2081   0F48             
2082   0F48             getchar:
2083   0F48 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2084   0F4B             ; $c 
2085   0F4B 52 01 00      sub sp, 1
2086   0F4E             
2087   0F4E             ; --- BEGIN INLINE ASM BLOCK
2088   0F4E 07 B1 11      call getch
2089   0F51 1A            mov al, ah
2090   0F52 FA 00 00      lea d, [bp + 0] ; $c
2091   0F55 3E            mov [d], al
2092   0F56             ; --- END INLINE ASM BLOCK
2093   0F56             
2094   0F56             ;; return c; 
2095   0F56 FA 00 00      lea d, [bp + 0] ; $c
2096   0F59 32            mov bl, [d]
2097   0F5A A7 00         mov bh, 0
2098   0F5C F9            leave
2099   0F5D 09            ret
2100   0F5E             
2101   0F5E             scann:
2102   0F5E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2103   0F61             ; $m 
2104   0F61 52 02 00      sub sp, 2
2105   0F64             
2106   0F64             ; --- BEGIN INLINE ASM BLOCK
2107   0F64 07 FC 13      call scan_u16d
2108   0F67 FA FF FF      lea d, [bp + -1] ; $m
2109   0F6A 43            mov [d], a
2110   0F6B             ; --- END INLINE ASM BLOCK
2111   0F6B             
2112   0F6B             ;; return m; 
2113   0F6B FA FF FF      lea d, [bp + -1] ; $m
2114   0F6E 2A            mov b, [d]
2115   0F6F F9            leave
2116   0F70 09            ret
2117   0F71             
2118   0F71             puts:
2119   0F71 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2120   0F74             
2121   0F74             ; --- BEGIN INLINE ASM BLOCK
2122   0F74 FA 05 00      lea d, [bp + 5] ; $s
2123   0F77 15            mov a, [d]
2124   0F78 3C            mov d, a
2125   0F79 07 02 13      call _puts
2126   0F7C 10 00 0A      mov a, $0A00
2127   0F7F 05 03         syscall sys_io
2128   0F81             ; --- END INLINE ASM BLOCK
2129   0F81             
2130   0F81 F9            leave
2131   0F82 09            ret
2132   0F83             
2133   0F83             print:
2134   0F83 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2135   0F86             
2136   0F86             ; --- BEGIN INLINE ASM BLOCK
2137   0F86 FA 05 00      lea d, [bp + 5] ; $s
2138   0F89 FD 2A         mov d, [d]
2139   0F8B 07 02 13      call _puts
2140   0F8E             ; --- END INLINE ASM BLOCK
2141   0F8E             
2142   0F8E F9            leave
2143   0F8F 09            ret
2144   0F90             
2145   0F90             loadfile:
2146   0F90 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2147   0F93             
2148   0F93             ; --- BEGIN INLINE ASM BLOCK
2149   0F93 FA 07 00      lea d, [bp + 7] ; $destination
2150   0F96 15            mov a, [d]
2151   0F97 4F            mov di, a
2152   0F98 FA 05 00      lea d, [bp + 5] ; $filename
2153   0F9B FD 2A         mov d, [d]
2154   0F9D 19 14         mov al, 20
2155   0F9F 05 04         syscall sys_filesystem
2156   0FA1             ; --- END INLINE ASM BLOCK
2157   0FA1             
2158   0FA1 F9            leave
2159   0FA2 09            ret
2160   0FA3             
2161   0FA3             create_file:
2162   0FA3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2163   0FA6 F9            leave
2164   0FA7 09            ret
2165   0FA8             
2166   0FA8             delete_file:
2167   0FA8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2168   0FAB             
2169   0FAB             ; --- BEGIN INLINE ASM BLOCK
2170   0FAB FA 05 00      lea d, [bp + 5] ; $filename
2171   0FAE 19 0A         mov al, 10
2172   0FB0 05 04         syscall sys_filesystem
2173   0FB2             ; --- END INLINE ASM BLOCK
2174   0FB2             
2175   0FB2 F9            leave
2176   0FB3 09            ret
2177   0FB4             
2178   0FB4             fopen:
2179   0FB4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2180   0FB7 F9            leave
2181   0FB8 09            ret
2182   0FB9             
2183   0FB9             fclose:
2184   0FB9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2185   0FBC F9            leave
2186   0FBD 09            ret
2187   0FBE             
2188   0FBE             alloc:
2189   0FBE F8 00 00      enter 0 ; (push bp; mov bp, sp)
2190   0FC1             ;; heap_top = heap_top + bytes; 
2191   0FC1 3B AB 14      mov d, _heap_top ; $heap_top
2192   0FC4 DA            push d
2193   0FC5 3B AB 14      mov d, _heap_top ; $heap_top
2194   0FC8 2A            mov b, [d]
2195   0FC9             ; START TERMS
2196   0FC9 D7            push a
2197   0FCA 11            mov a, b
2198   0FCB FA 05 00      lea d, [bp + 5] ; $bytes
2199   0FCE 2A            mov b, [d]
2200   0FCF 54            add a, b
2201   0FD0 27            mov b, a
2202   0FD1 E4            pop a
2203   0FD2             ; END TERMS
2204   0FD2 E7            pop d
2205   0FD3 FD 43         mov [d], b
2206   0FD5             ;; return heap_top - bytes; 
2207   0FD5 3B AB 14      mov d, _heap_top ; $heap_top
2208   0FD8 2A            mov b, [d]
2209   0FD9             ; START TERMS
2210   0FD9 D7            push a
2211   0FDA 11            mov a, b
2212   0FDB FA 05 00      lea d, [bp + 5] ; $bytes
2213   0FDE 2A            mov b, [d]
2214   0FDF 60            sub a, b
2215   0FE0 27            mov b, a
2216   0FE1 E4            pop a
2217   0FE2             ; END TERMS
2218   0FE2 F9            leave
2219   0FE3 09            ret
2220   0FE4             
2221   0FE4             free:
2222   0FE4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2223   0FE7             ;; return heap_top = heap_top - bytes; 
2224   0FE7 3B AB 14      mov d, _heap_top ; $heap_top
2225   0FEA DA            push d
2226   0FEB 3B AB 14      mov d, _heap_top ; $heap_top
2227   0FEE 2A            mov b, [d]
2228   0FEF             ; START TERMS
2229   0FEF D7            push a
2230   0FF0 11            mov a, b
2231   0FF1 FA 05 00      lea d, [bp + 5] ; $bytes
2232   0FF4 2A            mov b, [d]
2233   0FF5 60            sub a, b
2234   0FF6 27            mov b, a
2235   0FF7 E4            pop a
2236   0FF8             ; END TERMS
2237   0FF8 E7            pop d
2238   0FF9 FD 43         mov [d], b
2239   0FFB F9            leave
2240   0FFC 09            ret
2241   0FFD             
2242   0FFD             exit:
2243   0FFD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2244   1000             
2245   1000             ; --- BEGIN INLINE ASM BLOCK
2246   1000 05 0B         syscall sys_terminate_proc
2247   1002             ; --- END INLINE ASM BLOCK
2248   1002             
2249   1002 F9            leave
2250   1003 09            ret
2251   1004             
2252   1004             load_hex:
2253   1004 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2254   1007             ; $temp 
2255   1007 52 02 00      sub sp, 2
2256   100A             ;; temp = alloc(32768); 
2257   100A FA FF FF      lea d, [bp + -1] ; $temp
2258   100D DA            push d
2259   100E 26 00 80      mov b, $8000
2260   1011 FD AB         swp b
2261   1013 D8            push b
2262   1014 07 BE 0F      call alloc
2263   1017 51 02 00      add sp, 2
2264   101A E7            pop d
2265   101B FD 43         mov [d], b
2266   101D             
2267   101D             ; --- BEGIN INLINE ASM BLOCK
2268   101D               
2269   101D               
2270   101D               
2271   101D               
2272   101D               
2273   101D             _load_hex:
2274   101D D7            push a
2275   101E D8            push b
2276   101F DA            push d
2277   1020 E2            push si
2278   1021 E3            push di
2279   1022 52 00 80      sub sp, $8000      
2280   1025 38 00 00      mov c, 0
2281   1028 48            mov a, sp
2282   1029 77            inc a
2283   102A 3C            mov d, a          
2284   102B 07 BF 11      call _gets        
2285   102E 4D            mov si, a
2286   102F             __load_hex_loop:
2287   102F F6            lodsb             
2288   1030 B9 00         cmp al, 0         
2289   1032 C6 40 10      jz __load_hex_ret
2290   1035 36            mov bh, al
2291   1036 F6            lodsb
2292   1037 2F            mov bl, al
2293   1038 07 75 11      call _atoi        
2294   103B F7            stosb             
2295   103C 78            inc c
2296   103D 0A 2F 10      jmp __load_hex_loop
2297   1040             __load_hex_ret:
2298   1040 51 00 80      add sp, $8000
2299   1043 F0            pop di
2300   1044 EF            pop si
2301   1045 E7            pop d
2302   1046 E5            pop b
2303   1047 E4            pop a
2304   1048             ; --- END INLINE ASM BLOCK
2305   1048             
2306   1048 F9            leave
2307   1049 09            ret
2308   104A             
2309   104A             getparam:
2310   104A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2311   104D             ; $data 
2312   104D 52 01 00      sub sp, 1
2313   1050             
2314   1050             ; --- BEGIN INLINE ASM BLOCK
2315   1050 19 04         mov al, 4
2316   1052 FA 05 00      lea d, [bp + 5] ; $address
2317   1055 FD 2A         mov d, [d]
2318   1057 05 0C         syscall sys_system
2319   1059 FA 00 00      lea d, [bp + 0] ; $data
2320   105C FD 3E         mov [d], bl
2321   105E             ; --- END INLINE ASM BLOCK
2322   105E             
2323   105E             ;; return data; 
2324   105E FA 00 00      lea d, [bp + 0] ; $data
2325   1061 32            mov bl, [d]
2326   1062 A7 00         mov bh, 0
2327   1064 F9            leave
2328   1065 09            ret
2329   1066             
2330   1066             clear:
2331   1066 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2332   1069             ;; print("\033[2J\033[H"); 
2333   1069 26 A1 14      mov b, __s3 ; "\033[2J\033[H"
2334   106C FD AB         swp b
2335   106E D8            push b
2336   106F 07 83 0F      call print
2337   1072 51 02 00      add sp, 2
2338   1075 F9            leave
2339   1076 09            ret
2340   1077             
2341   1077             printun:
2342   1077 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2343   107A             ;; print(prompt); 
2344   107A FA 05 00      lea d, [bp + 5] ; $prompt
2345   107D 2A            mov b, [d]
2346   107E FD AB         swp b
2347   1080 D8            push b
2348   1081 07 83 0F      call print
2349   1084 51 02 00      add sp, 2
2350   1087             ;; print_unsigned(n); 
2351   1087 FA 07 00      lea d, [bp + 7] ; $n
2352   108A 2A            mov b, [d]
2353   108B FD AB         swp b
2354   108D D8            push b
2355   108E 07 53 0E      call print_unsigned
2356   1091 51 02 00      add sp, 2
2357   1094             ;; print("\n"); 
2358   1094 26 A9 14      mov b, __s4 ; "\n"
2359   1097 FD AB         swp b
2360   1099 D8            push b
2361   109A 07 83 0F      call print
2362   109D 51 02 00      add sp, 2
2363   10A0 F9            leave
2364   10A1 09            ret
2365   10A2             
2366   10A2             printsn:
2367   10A2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2368   10A5             ;; print(prompt); 
2369   10A5 FA 05 00      lea d, [bp + 5] ; $prompt
2370   10A8 2A            mov b, [d]
2371   10A9 FD AB         swp b
2372   10AB D8            push b
2373   10AC 07 83 0F      call print
2374   10AF 51 02 00      add sp, 2
2375   10B2             ;; print_signed(n); 
2376   10B2 FA 07 00      lea d, [bp + 7] ; $n
2377   10B5 2A            mov b, [d]
2378   10B6 FD AB         swp b
2379   10B8 D8            push b
2380   10B9 07 36 0B      call print_signed
2381   10BC 51 02 00      add sp, 2
2382   10BF             ;; print("\n"); 
2383   10BF 26 A9 14      mov b, __s4 ; "\n"
2384   10C2 FD AB         swp b
2385   10C4 D8            push b
2386   10C5 07 83 0F      call print
2387   10C8 51 02 00      add sp, 2
2388   10CB F9            leave
2389   10CC 09            ret
2390   10CD             
2391   10CD             include_stdio_asm:
2392   10CD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2393   10D0             
2394   10D0             ; --- BEGIN INLINE ASM BLOCK
2395   10D0             .include "lib/asm/stdio.asm"
0001+  10D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  10D0             ; stdio.s
0003+  10D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  10D0             .include "lib/asm/string.asm"
0001++ 10D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 10D0             ; string.s
0003++ 10D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 10D0             
0005++ 10D0             
0006++ 10D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 10D0             ; _strrev
0008++ 10D0             ; reverse a string
0009++ 10D0             ; D = string address
0010++ 10D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 10D0             ; 01234
0012++ 10D0             _strrev:
0013++ 10D0 4B          	pusha
0014++ 10D1 07 17 11    	call _strlen	; length in C
0015++ 10D4 12          	mov a, c
0016++ 10D5 AF 01 00    	cmp a, 1
0017++ 10D8 D0 F2 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 10DB 7D          	dec a
0019++ 10DC FD 4E       	mov si, d	; beginning of string
0020++ 10DE FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 10E0 59          	add d, a	; end of string
0022++ 10E1 12          	mov a, c
0023++ 10E2 FD 9B       	shr a		; divide by 2
0024++ 10E4 39          	mov c, a	; C now counts the steps
0025++ 10E5             _strrev_L0:
0026++ 10E5 32          	mov bl, [d]	; save load right-side char into BL
0027++ 10E6 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 10E7 3E          	mov [d], al	; store left char into right side
0029++ 10E8 1B          	mov al, bl
0030++ 10E9 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 10EA 7E          	dec c
0032++ 10EB 7F          	dec d
0033++ 10EC C2 00 00    	cmp c, 0
0034++ 10EF C7 E5 10    	jne _strrev_L0
0035++ 10F2             _strrev_end:
0036++ 10F2 4C          	popa
0037++ 10F3 09          	ret
0038++ 10F4             	
0039++ 10F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10F4             ; _strchr
0041++ 10F4             ; search string in D for char in AL
0042++ 10F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10F4             _strchr:
0044++ 10F4             _strchr_L0:
0045++ 10F4 32          	mov bl, [d]
0046++ 10F5 C1 00       	cmp bl, 0
0047++ 10F7 C6 02 11    	je _strchr_end
0048++ 10FA BA          	cmp al, bl
0049++ 10FB C6 02 11    	je _strchr_end
0050++ 10FE 79          	inc d
0051++ 10FF 0A F4 10    	jmp _strchr_L0
0052++ 1102             _strchr_end:
0053++ 1102 1B          	mov al, bl
0054++ 1103 09          	ret
0055++ 1104             
0056++ 1104             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1104             ; _strstr
0058++ 1104             ; find sub-string
0059++ 1104             ; str1 in SI
0060++ 1104             ; str2 in DI
0061++ 1104             ; SI points to end of source string
0062++ 1104             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1104             _strstr:
0064++ 1104 DB          	push al
0065++ 1105 DA          	push d
0066++ 1106 E3          	push di
0067++ 1107             _strstr_loop:
0068++ 1107 F3          	cmpsb					; compare a byte of the strings
0069++ 1108 C7 13 11    	jne _strstr_ret
0070++ 110B FC 00 00    	lea d, [di + 0]
0071++ 110E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1110 C7 07 11    	jne _strstr_loop				; equal chars but not at end
0073++ 1113             _strstr_ret:
0074++ 1113 F0          	pop di
0075++ 1114 E7          	pop d
0076++ 1115 E8          	pop al
0077++ 1116 09          	ret
0078++ 1117             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1117             ; length of null terminated string
0080++ 1117             ; result in C
0081++ 1117             ; pointer in D
0082++ 1117             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1117             _strlen:
0084++ 1117 DA          	push d
0085++ 1118 38 00 00    	mov c, 0
0086++ 111B             _strlen_L1:
0087++ 111B BD 00       	cmp byte [d], 0
0088++ 111D C6 25 11    	je _strlen_ret
0089++ 1120 79          	inc d
0090++ 1121 78          	inc c
0091++ 1122 0A 1B 11    	jmp _strlen_L1
0092++ 1125             _strlen_ret:
0093++ 1125 E7          	pop d
0094++ 1126 09          	ret
0095++ 1127             
0096++ 1127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1127             ; STRCMP
0098++ 1127             ; compare two strings
0099++ 1127             ; str1 in SI
0100++ 1127             ; str2 in DI
0101++ 1127             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1127             _strcmp:
0104++ 1127 DB          	push al
0105++ 1128 DA          	push d
0106++ 1129 E3          	push di
0107++ 112A E2          	push si
0108++ 112B             _strcmp_loop:
0109++ 112B F3          	cmpsb					; compare a byte of the strings
0110++ 112C C7 37 11    	jne _strcmp_ret
0111++ 112F FB FF FF    	lea d, [si +- 1]
0112++ 1132 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1134 C7 2B 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 1137             _strcmp_ret:
0115++ 1137 EF          	pop si
0116++ 1138 F0          	pop di
0117++ 1139 E7          	pop d
0118++ 113A E8          	pop al
0119++ 113B 09          	ret
0120++ 113C             
0121++ 113C             
0122++ 113C             ; STRCPY
0123++ 113C             ; copy null terminated string from SI to DI
0124++ 113C             ; source in SI
0125++ 113C             ; destination in DI
0126++ 113C             _strcpy:
0127++ 113C E2          	push si
0128++ 113D E3          	push di
0129++ 113E DB          	push al
0130++ 113F             _strcpy_L1:
0131++ 113F F6          	lodsb
0132++ 1140 F7          	stosb
0133++ 1141 B9 00       	cmp al, 0
0134++ 1143 C7 3F 11    	jne _strcpy_L1
0135++ 1146             _strcpy_end:
0136++ 1146 E8          	pop al
0137++ 1147 F0          	pop di
0138++ 1148 EF          	pop si
0139++ 1149 09          	ret
0140++ 114A             
0141++ 114A             ; STRCAT
0142++ 114A             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 114A             ; source in SI
0144++ 114A             ; destination in DI
0145++ 114A             _strcat:
0146++ 114A E2          	push si
0147++ 114B E3          	push di
0148++ 114C D7          	push a
0149++ 114D DA          	push d
0150++ 114E 50          	mov a, di
0151++ 114F 3C          	mov d, a
0152++ 1150             _strcat_goto_end_L1:
0153++ 1150 BD 00       	cmp byte[d], 0
0154++ 1152 C6 59 11    	je _strcat_start
0155++ 1155 79          	inc d
0156++ 1156 0A 50 11    	jmp _strcat_goto_end_L1
0157++ 1159             _strcat_start:
0158++ 1159 FD 50       	mov di, d
0159++ 115B             _strcat_L1:
0160++ 115B F6          	lodsb
0161++ 115C F7          	stosb
0162++ 115D B9 00       	cmp al, 0
0163++ 115F C7 5B 11    	jne _strcat_L1
0164++ 1162             _strcat_end:
0165++ 1162 E7          	pop d
0166++ 1163 E4          	pop a
0167++ 1164 F0          	pop di
0168++ 1165 EF          	pop si
0169++ 1166 09          	ret
0170++ 1167             
0171++ 1167             
0005+  1167             
0006+  1167             
0007+  1167             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1167             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  1167             ; ASCII in BL
0010+  1167             ; result in AL
0011+  1167             ; ascii for F = 0100 0110
0012+  1167             ; ascii for 9 = 0011 1001
0013+  1167             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1167             hex_ascii_encode:
0015+  1167 1B            mov al, bl
0016+  1168 93 40         test al, $40        ; test if letter or number
0017+  116A C7 70 11      jnz hex_letter
0018+  116D 87 0F         and al, $0F        ; get number
0019+  116F 09            ret
0020+  1170             hex_letter:
0021+  1170 87 0F         and al, $0F        ; get letter
0022+  1172 6A 09         add al, 9
0023+  1174 09            ret
0024+  1175             
0025+  1175             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1175             ; ATOI
0027+  1175             ; 2 letter hex string in B
0028+  1175             ; 8bit integer returned in AL
0029+  1175             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1175             _atoi:
0031+  1175 D8            push b
0032+  1176 07 67 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  1179 30            mov bl, bh
0034+  117A DB            push al          ; save a
0035+  117B 07 67 11      call hex_ascii_encode
0036+  117E EA            pop bl  
0037+  117F FD 9E 04      shl al, 4
0038+  1182 8C            or al, bl
0039+  1183 E5            pop b
0040+  1184 09            ret  
0041+  1185             
0042+  1185             
0043+  1185             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1185             ; scanf
0045+  1185             ; no need for explanations!
0046+  1185             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1185             scanf:
0048+  1185 09            ret
0049+  1186             
0050+  1186             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1186             ; ITOA
0052+  1186             ; 8bit value in BL
0053+  1186             ; 2 byte ASCII result in A
0054+  1186             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1186             _itoa:
0056+  1186 DA            push d
0057+  1187 D8            push b
0058+  1188 A7 00         mov bh, 0
0059+  118A FD A4 04      shr bl, 4  
0060+  118D 74            mov d, b
0061+  118E 1F 36 14      mov al, [d + s_hex_digits]
0062+  1191 23            mov ah, al
0063+  1192               
0064+  1192 E5            pop b
0065+  1193 D8            push b
0066+  1194 A7 00         mov bh, 0
0067+  1196 FD 87 0F      and bl, $0F
0068+  1199 74            mov d, b
0069+  119A 1F 36 14      mov al, [d + s_hex_digits]
0070+  119D E5            pop b
0071+  119E E7            pop d
0072+  119F 09            ret
0073+  11A0             
0074+  11A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  11A0             ; HEX STRING TO BINARY
0076+  11A0             ; di = destination address
0077+  11A0             ; si = source
0078+  11A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  11A0             _hex_to_int:
0080+  11A0             _hex_to_int_L1:
0081+  11A0 F6            lodsb          ; load from [SI] to AL
0082+  11A1 B9 00         cmp al, 0        ; check if ASCII 0
0083+  11A3 C6 B0 11      jz _hex_to_int_ret
0084+  11A6 36            mov bh, al
0085+  11A7 F6            lodsb
0086+  11A8 2F            mov bl, al
0087+  11A9 07 75 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  11AC F7            stosb          ; store AL to [DI]
0089+  11AD 0A A0 11      jmp _hex_to_int_L1
0090+  11B0             _hex_to_int_ret:
0091+  11B0 09            ret    
0092+  11B1             
0093+  11B1             
0094+  11B1             
0095+  11B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  11B1             ; GETCHAR
0097+  11B1             ; char in ah
0098+  11B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  11B1             getch:
0100+  11B1 DB            push al
0101+  11B2             getch_retry:
0102+  11B2 19 01         mov al, 1
0103+  11B4 05 03         syscall sys_io      ; receive in AH
0104+  11B6 E8            pop al
0105+  11B7 09            ret
0106+  11B8             
0107+  11B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  11B8             ; PUTCHAR
0109+  11B8             ; char in ah
0110+  11B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  11B8             _putchar:
0112+  11B8 D7            push a
0113+  11B9 19 00         mov al, 0
0114+  11BB 05 03         syscall sys_io      ; char in AH
0115+  11BD E4            pop a
0116+  11BE 09            ret
0117+  11BF             
0118+  11BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  11BF             ;; INPUT A STRING
0120+  11BF             ;; terminates with null
0121+  11BF             ;; pointer in D
0122+  11BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  11BF             _gets:
0124+  11BF D7            push a
0125+  11C0 DA            push d
0126+  11C1             _gets_loop:
0127+  11C1 19 01         mov al, 1
0128+  11C3 05 03         syscall sys_io      ; receive in AH
0129+  11C5 B9 00         cmp al, 0        ; check error code (AL)
0130+  11C7 C6 C1 11      je _gets_loop      ; if no char received, retry
0131+  11CA             
0132+  11CA 76 1B         cmp ah, 27
0133+  11CC C6 ED 11      je _gets_ansi_esc
0134+  11CF 76 0A         cmp ah, $0A        ; LF
0135+  11D1 C6 58 12      je _gets_end
0136+  11D4 76 0D         cmp ah, $0D        ; CR
0137+  11D6 C6 58 12      je _gets_end
0138+  11D9 76 5C         cmp ah, $5C        ; '\\'
0139+  11DB C6 19 12      je _gets_escape
0140+  11DE               
0141+  11DE 76 08         cmp ah, $08      ; check for backspace
0142+  11E0 C6 E9 11      je _gets_backspace
0143+  11E3             
0144+  11E3 1A            mov al, ah
0145+  11E4 3E            mov [d], al
0146+  11E5 79            inc d
0147+  11E6 0A C1 11      jmp _gets_loop
0148+  11E9             _gets_backspace:
0149+  11E9 7F            dec d
0150+  11EA 0A C1 11      jmp _gets_loop
0151+  11ED             _gets_ansi_esc:
0152+  11ED 19 01         mov al, 1
0153+  11EF 05 03         syscall sys_io        ; receive in AH without echo
0154+  11F1 B9 00         cmp al, 0          ; check error code (AL)
0155+  11F3 C6 ED 11      je _gets_ansi_esc    ; if no char received, retry
0156+  11F6 76 5B         cmp ah, '['
0157+  11F8 C7 C1 11      jne _gets_loop
0158+  11FB             _gets_ansi_esc_2:
0159+  11FB 19 01         mov al, 1
0160+  11FD 05 03         syscall sys_io          ; receive in AH without echo
0161+  11FF B9 00         cmp al, 0            ; check error code (AL)
0162+  1201 C6 FB 11      je _gets_ansi_esc_2  ; if no char received, retry
0163+  1204 76 44         cmp ah, 'D'
0164+  1206 C6 11 12      je _gets_left_arrow
0165+  1209 76 43         cmp ah, 'C'
0166+  120B C6 15 12      je _gets_right_arrow
0167+  120E 0A C1 11      jmp _gets_loop
0168+  1211             _gets_left_arrow:
0169+  1211 7F            dec d
0170+  1212 0A C1 11      jmp _gets_loop
0171+  1215             _gets_right_arrow:
0172+  1215 79            inc d
0173+  1216 0A C1 11      jmp _gets_loop
0174+  1219             _gets_escape:
0175+  1219 19 01         mov al, 1
0176+  121B 05 03         syscall sys_io      ; receive in AH
0177+  121D B9 00         cmp al, 0        ; check error code (AL)
0178+  121F C6 19 12      je _gets_escape      ; if no char received, retry
0179+  1222 76 6E         cmp ah, 'n'
0180+  1224 C6 43 12      je _gets_LF
0181+  1227 76 72         cmp ah, 'r'
0182+  1229 C6 4A 12      je _gets_CR
0183+  122C 76 30         cmp ah, '0'
0184+  122E C6 51 12      je _gets_NULL
0185+  1231 76 5C         cmp ah, $5C  ; '\'
0186+  1233 C6 3C 12      je _gets_slash
0187+  1236 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  1237 3E            mov [d], al
0189+  1238 79            inc d
0190+  1239 0A C1 11      jmp _gets_loop
0191+  123C             _gets_slash:
0192+  123C 19 5C         mov al, $5C
0193+  123E 3E            mov [d], al
0194+  123F 79            inc d
0195+  1240 0A C1 11      jmp _gets_loop
0196+  1243             _gets_LF:
0197+  1243 19 0A         mov al, $0A
0198+  1245 3E            mov [d], al
0199+  1246 79            inc d
0200+  1247 0A C1 11      jmp _gets_loop
0201+  124A             _gets_CR:
0202+  124A 19 0D         mov al, $0D
0203+  124C 3E            mov [d], al
0204+  124D 79            inc d
0205+  124E 0A C1 11      jmp _gets_loop
0206+  1251             _gets_NULL:
0207+  1251 19 00         mov al, $00
0208+  1253 3E            mov [d], al
0209+  1254 79            inc d
0210+  1255 0A C1 11      jmp _gets_loop
0211+  1258             _gets_end:
0212+  1258 19 00         mov al, 0
0213+  125A 3E            mov [d], al        ; terminate string
0214+  125B E7            pop d
0215+  125C E4            pop a
0216+  125D 09            ret
0217+  125E             
0218+  125E             
0219+  125E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  125E             ;; INPUT TEXT
0221+  125E             ;; terminated with CTRL+D
0222+  125E             ;; pointer in D
0223+  125E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  125E             _gettxt:
0225+  125E D7            push a
0226+  125F DA            push d
0227+  1260             _gettxt_loop:
0228+  1260 19 01         mov al, 1
0229+  1262 05 03         syscall sys_io      ; receive in AH
0230+  1264 B9 00         cmp al, 0        ; check error code (AL)
0231+  1266 C6 60 12      je _gettxt_loop    ; if no char received, retry
0232+  1269 76 04         cmp ah, 4      ; EOT
0233+  126B C6 A9 12      je _gettxt_end
0234+  126E 76 08         cmp ah, $08      ; check for backspace
0235+  1270 C6 A5 12      je _gettxt_backspace
0236+  1273 76 5C         cmp ah, $5C        ; '\'
0237+  1275 C6 7E 12      je _gettxt_escape
0238+  1278 1A            mov al, ah
0239+  1279 3E            mov [d], al
0240+  127A 79            inc d
0241+  127B 0A 60 12      jmp _gettxt_loop
0242+  127E             _gettxt_escape:
0243+  127E 19 01         mov al, 1
0244+  1280 05 03         syscall sys_io      ; receive in AH
0245+  1282 B9 00         cmp al, 0        ; check error code (AL)
0246+  1284 C6 7E 12      je _gettxt_escape    ; if no char received, retry
0247+  1287 76 6E         cmp ah, 'n'
0248+  1289 C6 97 12      je _gettxt_LF
0249+  128C 76 72         cmp ah, 'r'
0250+  128E C6 9E 12      je _gettxt_CR
0251+  1291 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  1292 3E            mov [d], al
0253+  1293 79            inc d
0254+  1294 0A 60 12      jmp _gettxt_loop
0255+  1297             _gettxt_LF:
0256+  1297 19 0A         mov al, $0A
0257+  1299 3E            mov [d], al
0258+  129A 79            inc d
0259+  129B 0A 60 12      jmp _gettxt_loop
0260+  129E             _gettxt_CR:
0261+  129E 19 0D         mov al, $0D
0262+  12A0 3E            mov [d], al
0263+  12A1 79            inc d
0264+  12A2 0A 60 12      jmp _gettxt_loop
0265+  12A5             _gettxt_backspace:
0266+  12A5 7F            dec d
0267+  12A6 0A 60 12      jmp _gettxt_loop
0268+  12A9             _gettxt_end:
0269+  12A9 19 00         mov al, 0
0270+  12AB 3E            mov [d], al        ; terminate string
0271+  12AC E7            pop d
0272+  12AD E4            pop a
0273+  12AE 09            ret
0274+  12AF             
0275+  12AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  12AF             ; PRINT NEW LINE
0277+  12AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  12AF             printnl:
0279+  12AF D7            push a
0280+  12B0 10 00 0A      mov a, $0A00
0281+  12B3 05 03         syscall sys_io
0282+  12B5 10 00 0D      mov a, $0D00
0283+  12B8 05 03         syscall sys_io
0284+  12BA E4            pop a
0285+  12BB 09            ret
0286+  12BC             
0287+  12BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  12BC             ; _strtoint
0289+  12BC             ; 4 digit hex string number in d
0290+  12BC             ; integer returned in A
0291+  12BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  12BC             _strtointx:
0293+  12BC D8            push b
0294+  12BD 32            mov bl, [d]
0295+  12BE 37            mov bh, bl
0296+  12BF 33 01 00      mov bl, [d + 1]
0297+  12C2 07 75 11      call _atoi        ; convert to int in AL
0298+  12C5 23            mov ah, al        ; move to AH
0299+  12C6 33 02 00      mov bl, [d + 2]
0300+  12C9 37            mov bh, bl
0301+  12CA 33 03 00      mov bl, [d + 3]
0302+  12CD 07 75 11      call _atoi        ; convert to int in AL
0303+  12D0 E5            pop b
0304+  12D1 09            ret
0305+  12D2             
0306+  12D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  12D2             ; _strtoint
0308+  12D2             ; 5 digit base10 string number in d
0309+  12D2             ; integer returned in A
0310+  12D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  12D2             _strtoint:
0312+  12D2 E2            push si
0313+  12D3 D8            push b
0314+  12D4 D9            push c
0315+  12D5 DA            push d
0316+  12D6 07 17 11      call _strlen      ; get string length in C
0317+  12D9 7E            dec c
0318+  12DA FD 4E         mov si, d
0319+  12DC 12            mov a, c
0320+  12DD FD 99         shl a
0321+  12DF 3B 4E 14      mov d, table_power
0322+  12E2 59            add d, a
0323+  12E3 38 00 00      mov c, 0
0324+  12E6             _strtoint_L0:
0325+  12E6 F6            lodsb      ; load ASCII to al
0326+  12E7 B9 00         cmp al, 0
0327+  12E9 C6 FC 12      je _strtoint_end
0328+  12EC 6F 30         sub al, $30    ; make into integer
0329+  12EE 22 00         mov ah, 0
0330+  12F0 2A            mov b, [d]
0331+  12F1 AC            mul a, b      ; result in B since it fits in 16bits
0332+  12F2 11            mov a, b
0333+  12F3 28            mov b, c
0334+  12F4 54            add a, b
0335+  12F5 39            mov c, a
0336+  12F6 63 02 00      sub d, 2
0337+  12F9 0A E6 12      jmp _strtoint_L0
0338+  12FC             _strtoint_end:
0339+  12FC 12            mov a, c
0340+  12FD E7            pop d
0341+  12FE E6            pop c
0342+  12FF E5            pop b
0343+  1300 EF            pop si
0344+  1301 09            ret
0345+  1302             
0346+  1302             
0347+  1302             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  1302             ; PRINT NULL TERMINATED STRING
0349+  1302             ; pointer in D
0350+  1302             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  1302             _puts:
0352+  1302 D7            push a
0353+  1303 DA            push d
0354+  1304             _puts_L1:
0355+  1304 1E            mov al, [d]
0356+  1305 B9 00         cmp al, 0
0357+  1307 C6 13 13      jz _puts_END
0358+  130A 23            mov ah, al
0359+  130B 19 00         mov al, 0
0360+  130D 05 03         syscall sys_io
0361+  130F 79            inc d
0362+  1310 0A 04 13      jmp _puts_L1
0363+  1313             _puts_END:
0364+  1313 E7            pop d
0365+  1314 E4            pop a
0366+  1315 09            ret
0367+  1316             
0368+  1316             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  1316             ; PRINT N SIZE STRING
0370+  1316             ; pointer in D
0371+  1316             ; size in C
0372+  1316             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  1316             _putsn:
0374+  1316 DB            push al
0375+  1317 DA            push d
0376+  1318 D9            push c
0377+  1319             _putsn_L0:
0378+  1319 1E            mov al, [d]
0379+  131A 23            mov ah, al
0380+  131B 19 00         mov al, 0
0381+  131D 05 03         syscall sys_io
0382+  131F 79            inc d
0383+  1320 7E            dec c  
0384+  1321 C2 00 00      cmp c, 0
0385+  1324 C7 19 13      jne _putsn_L0
0386+  1327             _putsn_end:
0387+  1327 E6            pop c
0388+  1328 E7            pop d
0389+  1329 E8            pop al
0390+  132A 09            ret
0391+  132B             
0392+  132B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  132B             ; print 16bit decimal number
0394+  132B             ; input number in A
0395+  132B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  132B             print_u16d:
0397+  132B D7            push a
0398+  132C D8            push b
0399+  132D 26 10 27      mov b, 10000
0400+  1330 AE            div a, b      ; get 10000's coeff.
0401+  1331 07 53 13      call print_number
0402+  1334 11            mov a, b
0403+  1335 26 E8 03      mov b, 1000
0404+  1338 AE            div a, b      ; get 1000's coeff.
0405+  1339 07 53 13      call print_number
0406+  133C 11            mov a, b
0407+  133D 26 64 00      mov b, 100
0408+  1340 AE            div a, b
0409+  1341 07 53 13      call print_number
0410+  1344 11            mov a, b
0411+  1345 26 0A 00      mov b, 10
0412+  1348 AE            div a, b
0413+  1349 07 53 13      call print_number
0414+  134C 1B            mov al, bl      ; 1's coeff in bl
0415+  134D 07 53 13      call print_number
0416+  1350 E5            pop b
0417+  1351 E4            pop a
0418+  1352 09            ret
0419+  1353             
0420+  1353             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  1353             ; print AL
0422+  1353             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  1353             print_number:
0424+  1353 6A 30         add al, $30
0425+  1355 23            mov ah, al
0426+  1356 07 B8 11      call _putchar
0427+  1359 09            ret
0428+  135A             
0429+  135A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  135A             ; PRINT 16BIT HEX INTEGER
0431+  135A             ; integer value in reg B
0432+  135A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  135A             print_u16x:
0434+  135A D7            push a
0435+  135B D8            push b
0436+  135C DD            push bl
0437+  135D 30            mov bl, bh
0438+  135E 07 86 11      call _itoa        ; convert bh to char in A
0439+  1361 2F            mov bl, al        ; save al
0440+  1362 19 00         mov al, 0
0441+  1364 05 03         syscall sys_io        ; display AH
0442+  1366 24            mov ah, bl        ; retrieve al
0443+  1367 19 00         mov al, 0
0444+  1369 05 03         syscall sys_io        ; display AL
0445+  136B             
0446+  136B EA            pop bl
0447+  136C 07 86 11      call _itoa        ; convert bh to char in A
0448+  136F 2F            mov bl, al        ; save al
0449+  1370 19 00         mov al, 0
0450+  1372 05 03         syscall sys_io        ; display AH
0451+  1374 24            mov ah, bl        ; retrieve al
0452+  1375 19 00         mov al, 0
0453+  1377 05 03         syscall sys_io        ; display AL
0454+  1379             
0455+  1379 E5            pop b
0456+  137A E4            pop a
0457+  137B 09            ret
0458+  137C             
0459+  137C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  137C             ; INPUT 16BIT HEX INTEGER
0461+  137C             ; read 16bit integer into A
0462+  137C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  137C             scan_u16x:
0464+  137C F8 10 00      enter 16
0465+  137F D8            push b
0466+  1380 DA            push d
0467+  1381             
0468+  1381 FA F1 FF      lea d, [bp + -15]
0469+  1384 07 BF 11      call _gets        ; get number
0470+  1387             
0471+  1387 32            mov bl, [d]
0472+  1388 37            mov bh, bl
0473+  1389 33 01 00      mov bl, [d + 1]
0474+  138C 07 75 11      call _atoi        ; convert to int in AL
0475+  138F 23            mov ah, al        ; move to AH
0476+  1390             
0477+  1390 33 02 00      mov bl, [d + 2]
0478+  1393 37            mov bh, bl
0479+  1394 33 03 00      mov bl, [d + 3]
0480+  1397 07 75 11      call _atoi        ; convert to int in AL
0481+  139A             
0482+  139A E7            pop d
0483+  139B E5            pop b
0484+  139C F9            leave
0485+  139D 09            ret
0486+  139E             
0487+  139E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  139E             ; PRINT 8bit HEX INTEGER
0489+  139E             ; integer value in reg bl
0490+  139E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  139E             print_u8x:
0492+  139E D7            push a
0493+  139F DD            push bl
0494+  13A0             
0495+  13A0 07 86 11      call _itoa        ; convert bl to char in A
0496+  13A3 2F            mov bl, al        ; save al
0497+  13A4 19 00         mov al, 0
0498+  13A6 05 03         syscall sys_io        ; display AH
0499+  13A8 24            mov ah, bl        ; retrieve al
0500+  13A9 19 00         mov al, 0
0501+  13AB 05 03         syscall sys_io        ; display AL
0502+  13AD             
0503+  13AD EA            pop bl
0504+  13AE E4            pop a
0505+  13AF 09            ret
0506+  13B0             
0507+  13B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  13B0             ; print 8bit decimal unsigned number
0509+  13B0             ; input number in AL
0510+  13B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  13B0             print_u8d:
0512+  13B0 D7            push a
0513+  13B1 D8            push b
0514+  13B2             
0515+  13B2 22 00         mov ah, 0
0516+  13B4 26 64 00      mov b, 100
0517+  13B7 AE            div a, b
0518+  13B8 D8            push b      ; save remainder
0519+  13B9 B9 00         cmp al, 0
0520+  13BB C6 C5 13      je skip100
0521+  13BE 6A 30         add al, $30
0522+  13C0 23            mov ah, al
0523+  13C1 19 00         mov al, 0
0524+  13C3 05 03         syscall sys_io  ; print coeff
0525+  13C5             skip100:
0526+  13C5 E4            pop a
0527+  13C6 22 00         mov ah, 0
0528+  13C8 26 0A 00      mov b, 10
0529+  13CB AE            div a, b
0530+  13CC D8            push b      ; save remainder
0531+  13CD B9 00         cmp al, 0
0532+  13CF C6 D9 13      je skip10
0533+  13D2 6A 30         add al, $30
0534+  13D4 23            mov ah, al
0535+  13D5 19 00         mov al, 0
0536+  13D7 05 03         syscall sys_io  ; print coeff
0537+  13D9             skip10:
0538+  13D9 E4            pop a
0539+  13DA 1B            mov al, bl
0540+  13DB 6A 30         add al, $30
0541+  13DD 23            mov ah, al
0542+  13DE 19 00         mov al, 0
0543+  13E0 05 03         syscall sys_io  ; print coeff
0544+  13E2 E5            pop b
0545+  13E3 E4            pop a
0546+  13E4 09            ret
0547+  13E5             
0548+  13E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  13E5             ; INPUT 8BIT HEX INTEGER
0550+  13E5             ; read 8bit integer into AL
0551+  13E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  13E5             scan_u8x:
0553+  13E5 F8 04 00      enter 4
0554+  13E8 D8            push b
0555+  13E9 DA            push d
0556+  13EA             
0557+  13EA FA FD FF      lea d, [bp + -3]
0558+  13ED 07 BF 11      call _gets        ; get number
0559+  13F0             
0560+  13F0 32            mov bl, [d]
0561+  13F1 37            mov bh, bl
0562+  13F2 33 01 00      mov bl, [d + 1]
0563+  13F5 07 75 11      call _atoi        ; convert to int in AL
0564+  13F8             
0565+  13F8 E7            pop d
0566+  13F9 E5            pop b
0567+  13FA F9            leave
0568+  13FB 09            ret
0569+  13FC             
0570+  13FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  13FC             ; input decimal number
0572+  13FC             ; result in A
0573+  13FC             ; 655'\0'
0574+  13FC             ; low--------high
0575+  13FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  13FC             scan_u16d:
0577+  13FC F8 08 00      enter 8
0578+  13FF E2            push si
0579+  1400 D8            push b
0580+  1401 D9            push c
0581+  1402 DA            push d
0582+  1403 FA F9 FF      lea d, [bp +- 7]
0583+  1406 07 BF 11      call _gets
0584+  1409 07 17 11      call _strlen      ; get string length in C
0585+  140C 7E            dec c
0586+  140D FD 4E         mov si, d
0587+  140F 12            mov a, c
0588+  1410 FD 99         shl a
0589+  1412 3B 4E 14      mov d, table_power
0590+  1415 59            add d, a
0591+  1416 38 00 00      mov c, 0
0592+  1419             mul_loop:
0593+  1419 F6            lodsb      ; load ASCII to al
0594+  141A B9 00         cmp al, 0
0595+  141C C6 2F 14      je mul_exit
0596+  141F 6F 30         sub al, $30    ; make into integer
0597+  1421 22 00         mov ah, 0
0598+  1423 2A            mov b, [d]
0599+  1424 AC            mul a, b      ; result in B since it fits in 16bits
0600+  1425 11            mov a, b
0601+  1426 28            mov b, c
0602+  1427 54            add a, b
0603+  1428 39            mov c, a
0604+  1429 63 02 00      sub d, 2
0605+  142C 0A 19 14      jmp mul_loop
0606+  142F             mul_exit:
0607+  142F 12            mov a, c
0608+  1430 E7            pop d
0609+  1431 E6            pop c
0610+  1432 E5            pop b
0611+  1433 EF            pop si
0612+  1434 F9            leave
0613+  1435 09            ret
0614+  1436             
0615+  1436             
0616+  1436 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  143A 34 35 36 37 
0616+  143E 38 39 41 42 
0616+  1442 43 44 45 46 
0617+  1446 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  144A 1B 5B 48 00 
0618+  144E             
0619+  144E             table_power:
0620+  144E 01 00         .dw 1
0621+  1450 0A 00         .dw 10
0622+  1452 64 00         .dw 100
0623+  1454 E8 03         .dw 1000
0624+  1456 10 27         .dw 100002396   1458             ; --- END INLINE ASM BLOCK
2397   1458             
2398   1458 F9            leave
2399   1459 09            ret
2400   145A             ; --- END TEXT BLOCK
2401   145A             
2402   145A             ; --- BEGIN DATA BLOCK
2403   145A 56 61 6C 75 __s0: .db "Value: %lx", 0
2403   145E 65 3A 20 25 
2403   1462 6C 78 00 
2404   1465 55 6E 65 78 __s1: .db "Unexpected format in printf.", 0
2404   1469 70 65 63 74 
2404   146D 65 64 20 66 
2404   1471 6F 72 6D 61 
2404   1475 74 20 69 6E 
2404   1479 20 70 72 69 
2404   147D 6E 74 66 2E 
2404   1481 00 
2405   1482 45 72 72 6F __s2: .db "Error: Unknown argument type.\n", 0
2405   1486 72 3A 20 55 
2405   148A 6E 6B 6E 6F 
2405   148E 77 6E 20 61 
2405   1492 72 67 75 6D 
2405   1496 65 6E 74 20 
2405   149A 74 79 70 65 
2405   149E 2E 0A 00 
2406   14A1 1B 5B 32 4A __s3: .db "\033[2J\033[H", 0
2406   14A5 1B 5B 48 00 
2407   14A9 0A 00       __s4: .db "\n", 0
2408   14AB             
2409   14AB AD 14       _heap_top: .dw _heap
2410   14AD 00          _heap: .db 0
2411   14AE             ; --- END DATA BLOCK
2412   14AE             
2413   14AE             .end
tasm: Number of errors = 0
