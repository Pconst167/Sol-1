0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $i1 
0011   0408             ; $i2 
0012   0408 52 08 00      sub sp, 8
0013   040B             ;; i1 = 123; 
0014   040B FA FD FF      lea d, [bp + -3] ; $i1
0015   040E DA            push d
0016   040F 26 7B 00      mov b, $7b
0017   0412 E7            pop d
0018   0413 FD 43         mov [d], b
0019   0415 28            mov b, c
0020   0416 FD 44 02 00   mov [d + 2], b
0021   041A             ;; i2 = 1234; 
0022   041A FA F9 FF      lea d, [bp + -7] ; $i2
0023   041D DA            push d
0024   041E 26 D2 04      mov b, $4d2
0025   0421 E7            pop d
0026   0422 FD 43         mov [d], b
0027   0424 28            mov b, c
0028   0425 FD 44 02 00   mov [d + 2], b
0029   0429             ;; -2147483648; 
0030   0429 26 00 00      mov b, $0
0031   042C 38 00 80      mov c, $8000
0032   042F FD 97         neg b
0033   0431             ;; printf("Result: %d, %d", i1 < i2, i2 < i1); 
0034   0431 FA F9 FF      lea d, [bp + -7] ; $i2
0035   0434 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0036   0437 FD 39         mov c, b ; And place it into C
0037   0439 2A            mov b, [d] ; Lower Word in B
0038   043A             ; START RELATIONAL
0039   043A D7            push a
0040   043B FD D8         push g
0041   043D 11            mov a, b
0042   043E FD 7A         mov g, c
0043   0440 FA FD FF      lea d, [bp + -3] ; $i1
0044   0443 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0045   0446 FD 39         mov c, b ; And place it into C
0046   0448 2A            mov b, [d] ; Lower Word in B
0047   0449 4D            mov si, a
0048   044A 11            mov a, b
0049   044B 4F            mov di, a
0050   044C FD 12         mov a, g
0051   044E 28            mov b, c
0052   044F B0            cmp a, b
0053   0450 FD 75         slu ; <
0054   0452 D8            push b
0055   0453 28            mov b, c
0056   0454 FD 71         seq ; ==
0057   0456 D8            push b
0058   0457 50            mov a, di
0059   0458 27            mov b, a
0060   0459 4E            mov a, si
0061   045A B0            cmp a, b
0062   045B FD 75         slu ; <
0063   045D E4            pop a
0064   045E FD 92         and b, a
0065   0460 E4            pop a
0066   0461 FD 70         or b, a
0067   0463               
0068   0463 FD F1         pop g
0069   0465 E4            pop a
0070   0466             ; END RELATIONAL
0071   0466 FD AB         swp b
0072   0468 D8            push b
0073   0469 FA FD FF      lea d, [bp + -3] ; $i1
0074   046C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0075   046F FD 39         mov c, b ; And place it into C
0076   0471 2A            mov b, [d] ; Lower Word in B
0077   0472             ; START RELATIONAL
0078   0472 D7            push a
0079   0473 FD D8         push g
0080   0475 11            mov a, b
0081   0476 FD 7A         mov g, c
0082   0478 FA F9 FF      lea d, [bp + -7] ; $i2
0083   047B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0084   047E FD 39         mov c, b ; And place it into C
0085   0480 2A            mov b, [d] ; Lower Word in B
0086   0481 4D            mov si, a
0087   0482 11            mov a, b
0088   0483 4F            mov di, a
0089   0484 FD 12         mov a, g
0090   0486 28            mov b, c
0091   0487 B0            cmp a, b
0092   0488 FD 75         slu ; <
0093   048A D8            push b
0094   048B 28            mov b, c
0095   048C FD 71         seq ; ==
0096   048E D8            push b
0097   048F 50            mov a, di
0098   0490 27            mov b, a
0099   0491 4E            mov a, si
0100   0492 B0            cmp a, b
0101   0493 FD 75         slu ; <
0102   0495 E4            pop a
0103   0496 FD 92         and b, a
0104   0498 E4            pop a
0105   0499 FD 70         or b, a
0106   049B               
0107   049B FD F1         pop g
0108   049D E4            pop a
0109   049E             ; END RELATIONAL
0110   049E FD AB         swp b
0111   04A0 D8            push b
0112   04A1 26 7D 14      mov b, __s0 ; "Result: %d, %d"
0113   04A4 FD AB         swp b
0114   04A6 D8            push b
0115   04A7 07 6B 06      call printf
0116   04AA 51 06 00      add sp, 6
0117   04AD             ;; return; 
0118   04AD F9            leave
0119   04AE 05 0B         syscall sys_terminate_proc
0120   04B0             
0121   04B0             strcpy:
0122   04B0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0123   04B3             ; $psrc 
0124   04B3             ; $pdest 
0125   04B3 52 04 00      sub sp, 4
0126   04B6             ;; psrc = src; 
0127   04B6 FA FF FF      lea d, [bp + -1] ; $psrc
0128   04B9 DA            push d
0129   04BA FA 07 00      lea d, [bp + 7] ; $src
0130   04BD 2A            mov b, [d]
0131   04BE E7            pop d
0132   04BF FD 43         mov [d], b
0133   04C1             ;; pdest = dest; 
0134   04C1 FA FD FF      lea d, [bp + -3] ; $pdest
0135   04C4 DA            push d
0136   04C5 FA 05 00      lea d, [bp + 5] ; $dest
0137   04C8 2A            mov b, [d]
0138   04C9 E7            pop d
0139   04CA FD 43         mov [d], b
0140   04CC             ;; while(*psrc) *pdest++ = *psrc++; 
0141   04CC             _while1_cond:
0142   04CC FA FF FF      lea d, [bp + -1] ; $psrc
0143   04CF 2A            mov b, [d]
0144   04D0 74            mov d, b
0145   04D1 32            mov bl, [d]
0146   04D2 A7 00         mov bh, 0
0147   04D4 C0 00 00      cmp b, 0
0148   04D7 C6 FF 04      je _while1_exit
0149   04DA             _while1_block:
0150   04DA             ;; *pdest++ = *psrc++; 
0151   04DA FA FD FF      lea d, [bp + -3] ; $pdest
0152   04DD 2A            mov b, [d]
0153   04DE D8            push b
0154   04DF FD 77         inc b
0155   04E1 FA FD FF      lea d, [bp + -3] ; $pdest
0156   04E4 FD 43         mov [d], b
0157   04E6 E5            pop b
0158   04E7 D8            push b
0159   04E8 FA FF FF      lea d, [bp + -1] ; $psrc
0160   04EB 2A            mov b, [d]
0161   04EC D8            push b
0162   04ED FD 77         inc b
0163   04EF FA FF FF      lea d, [bp + -1] ; $psrc
0164   04F2 FD 43         mov [d], b
0165   04F4 E5            pop b
0166   04F5 74            mov d, b
0167   04F6 32            mov bl, [d]
0168   04F7 A7 00         mov bh, 0
0169   04F9 E7            pop d
0170   04FA FD 3E         mov [d], bl
0171   04FC 0A CC 04      jmp _while1_cond
0172   04FF             _while1_exit:
0173   04FF             ;; *pdest = '\0'; 
0174   04FF FA FD FF      lea d, [bp + -3] ; $pdest
0175   0502 2A            mov b, [d]
0176   0503 D8            push b
0177   0504 26 00 00      mov b, $0
0178   0507 E7            pop d
0179   0508 FD 3E         mov [d], bl
0180   050A F9            leave
0181   050B 09            ret
0182   050C             
0183   050C             strcmp:
0184   050C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0185   050F             ;; while (*s1 && (*s1 == *s2)) { 
0186   050F             _while2_cond:
0187   050F FA 05 00      lea d, [bp + 5] ; $s1
0188   0512 2A            mov b, [d]
0189   0513 74            mov d, b
0190   0514 32            mov bl, [d]
0191   0515 A7 00         mov bh, 0
0192   0517 D7            push a
0193   0518 11            mov a, b
0194   0519 FA 05 00      lea d, [bp + 5] ; $s1
0195   051C 2A            mov b, [d]
0196   051D 74            mov d, b
0197   051E 32            mov bl, [d]
0198   051F A7 00         mov bh, 0
0199   0521             ; START RELATIONAL
0200   0521 D7            push a
0201   0522 11            mov a, b
0202   0523 FA 07 00      lea d, [bp + 7] ; $s2
0203   0526 2A            mov b, [d]
0204   0527 74            mov d, b
0205   0528 32            mov bl, [d]
0206   0529 A7 00         mov bh, 0
0207   052B B0            cmp a, b
0208   052C FD 71         seq ; ==
0209   052E E4            pop a
0210   052F             ; END RELATIONAL
0211   052F FD A7         sand a, b ; &&
0212   0531 E4            pop a
0213   0532 C0 00 00      cmp b, 0
0214   0535 C6 55 05      je _while2_exit
0215   0538             _while2_block:
0216   0538             ;; s1++; 
0217   0538 FA 05 00      lea d, [bp + 5] ; $s1
0218   053B 2A            mov b, [d]
0219   053C D8            push b
0220   053D FD 77         inc b
0221   053F FA 05 00      lea d, [bp + 5] ; $s1
0222   0542 FD 43         mov [d], b
0223   0544 E5            pop b
0224   0545             ;; s2++; 
0225   0545 FA 07 00      lea d, [bp + 7] ; $s2
0226   0548 2A            mov b, [d]
0227   0549 D8            push b
0228   054A FD 77         inc b
0229   054C FA 07 00      lea d, [bp + 7] ; $s2
0230   054F FD 43         mov [d], b
0231   0551 E5            pop b
0232   0552 0A 0F 05      jmp _while2_cond
0233   0555             _while2_exit:
0234   0555             ;; return *s1 - *s2; 
0235   0555 FA 05 00      lea d, [bp + 5] ; $s1
0236   0558 2A            mov b, [d]
0237   0559 74            mov d, b
0238   055A 32            mov bl, [d]
0239   055B A7 00         mov bh, 0
0240   055D             ; START TERMS
0241   055D D7            push a
0242   055E 11            mov a, b
0243   055F FA 07 00      lea d, [bp + 7] ; $s2
0244   0562 2A            mov b, [d]
0245   0563 74            mov d, b
0246   0564 32            mov bl, [d]
0247   0565 A7 00         mov bh, 0
0248   0567 60            sub a, b
0249   0568 27            mov b, a
0250   0569 E4            pop a
0251   056A             ; END TERMS
0252   056A F9            leave
0253   056B 09            ret
0254   056C             
0255   056C             strcat:
0256   056C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0257   056F             ; $dest_len 
0258   056F             ; $i 
0259   056F 52 04 00      sub sp, 4
0260   0572             ;; dest_len = strlen(dest); 
0261   0572 FA FF FF      lea d, [bp + -1] ; $dest_len
0262   0575 DA            push d
0263   0576 FA 05 00      lea d, [bp + 5] ; $dest
0264   0579 2A            mov b, [d]
0265   057A FD AB         swp b
0266   057C D8            push b
0267   057D 07 22 06      call strlen
0268   0580 51 02 00      add sp, 2
0269   0583 E7            pop d
0270   0584 FD 43         mov [d], b
0271   0586             ;; for (i = 0; src[i] != 0; i=i+1) { 
0272   0586             _for3_init:
0273   0586 FA FD FF      lea d, [bp + -3] ; $i
0274   0589 DA            push d
0275   058A 26 00 00      mov b, $0
0276   058D E7            pop d
0277   058E FD 43         mov [d], b
0278   0590             _for3_cond:
0279   0590 FA 07 00      lea d, [bp + 7] ; $src
0280   0593 FD 2A         mov d, [d]
0281   0595 D7            push a
0282   0596 DA            push d
0283   0597 FA FD FF      lea d, [bp + -3] ; $i
0284   059A 2A            mov b, [d]
0285   059B E7            pop d
0286   059C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0287   05A0 E4            pop a
0288   05A1 32            mov bl, [d]
0289   05A2 A7 00         mov bh, 0
0290   05A4             ; START RELATIONAL
0291   05A4 D7            push a
0292   05A5 11            mov a, b
0293   05A6 26 00 00      mov b, $0
0294   05A9 B0            cmp a, b
0295   05AA FD 72         sneq ; !=
0296   05AC E4            pop a
0297   05AD             ; END RELATIONAL
0298   05AD C0 00 00      cmp b, 0
0299   05B0 C6 FB 05      je _for3_exit
0300   05B3             _for3_block:
0301   05B3             ;; dest[dest_len + i] = src[i]; 
0302   05B3 FA 05 00      lea d, [bp + 5] ; $dest
0303   05B6 FD 2A         mov d, [d]
0304   05B8 D7            push a
0305   05B9 DA            push d
0306   05BA FA FF FF      lea d, [bp + -1] ; $dest_len
0307   05BD 2A            mov b, [d]
0308   05BE             ; START TERMS
0309   05BE D7            push a
0310   05BF 11            mov a, b
0311   05C0 FA FD FF      lea d, [bp + -3] ; $i
0312   05C3 2A            mov b, [d]
0313   05C4 54            add a, b
0314   05C5 27            mov b, a
0315   05C6 E4            pop a
0316   05C7             ; END TERMS
0317   05C7 E7            pop d
0318   05C8 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0319   05CC E4            pop a
0320   05CD DA            push d
0321   05CE FA 07 00      lea d, [bp + 7] ; $src
0322   05D1 FD 2A         mov d, [d]
0323   05D3 D7            push a
0324   05D4 DA            push d
0325   05D5 FA FD FF      lea d, [bp + -3] ; $i
0326   05D8 2A            mov b, [d]
0327   05D9 E7            pop d
0328   05DA FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0329   05DE E4            pop a
0330   05DF 32            mov bl, [d]
0331   05E0 A7 00         mov bh, 0
0332   05E2 E7            pop d
0333   05E3 FD 3E         mov [d], bl
0334   05E5             _for3_update:
0335   05E5 FA FD FF      lea d, [bp + -3] ; $i
0336   05E8 DA            push d
0337   05E9 FA FD FF      lea d, [bp + -3] ; $i
0338   05EC 2A            mov b, [d]
0339   05ED             ; START TERMS
0340   05ED D7            push a
0341   05EE 11            mov a, b
0342   05EF 26 01 00      mov b, $1
0343   05F2 54            add a, b
0344   05F3 27            mov b, a
0345   05F4 E4            pop a
0346   05F5             ; END TERMS
0347   05F5 E7            pop d
0348   05F6 FD 43         mov [d], b
0349   05F8 0A 90 05      jmp _for3_cond
0350   05FB             _for3_exit:
0351   05FB             ;; dest[dest_len + i] = 0; 
0352   05FB FA 05 00      lea d, [bp + 5] ; $dest
0353   05FE FD 2A         mov d, [d]
0354   0600 D7            push a
0355   0601 DA            push d
0356   0602 FA FF FF      lea d, [bp + -1] ; $dest_len
0357   0605 2A            mov b, [d]
0358   0606             ; START TERMS
0359   0606 D7            push a
0360   0607 11            mov a, b
0361   0608 FA FD FF      lea d, [bp + -3] ; $i
0362   060B 2A            mov b, [d]
0363   060C 54            add a, b
0364   060D 27            mov b, a
0365   060E E4            pop a
0366   060F             ; END TERMS
0367   060F E7            pop d
0368   0610 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0369   0614 E4            pop a
0370   0615 DA            push d
0371   0616 26 00 00      mov b, $0
0372   0619 E7            pop d
0373   061A FD 3E         mov [d], bl
0374   061C             ;; return dest; 
0375   061C FA 05 00      lea d, [bp + 5] ; $dest
0376   061F 2A            mov b, [d]
0377   0620 F9            leave
0378   0621 09            ret
0379   0622             
0380   0622             strlen:
0381   0622 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0382   0625             ; $length 
0383   0625 52 02 00      sub sp, 2
0384   0628             ;; length = 0; 
0385   0628 FA FF FF      lea d, [bp + -1] ; $length
0386   062B DA            push d
0387   062C 26 00 00      mov b, $0
0388   062F E7            pop d
0389   0630 FD 43         mov [d], b
0390   0632             ;; while (str[length] != 0) { 
0391   0632             _while4_cond:
0392   0632 FA 05 00      lea d, [bp + 5] ; $str
0393   0635 FD 2A         mov d, [d]
0394   0637 D7            push a
0395   0638 DA            push d
0396   0639 FA FF FF      lea d, [bp + -1] ; $length
0397   063C 2A            mov b, [d]
0398   063D E7            pop d
0399   063E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0400   0642 E4            pop a
0401   0643 32            mov bl, [d]
0402   0644 A7 00         mov bh, 0
0403   0646             ; START RELATIONAL
0404   0646 D7            push a
0405   0647 11            mov a, b
0406   0648 26 00 00      mov b, $0
0407   064B B0            cmp a, b
0408   064C FD 72         sneq ; !=
0409   064E E4            pop a
0410   064F             ; END RELATIONAL
0411   064F C0 00 00      cmp b, 0
0412   0652 C6 65 06      je _while4_exit
0413   0655             _while4_block:
0414   0655             ;; length++; 
0415   0655 FA FF FF      lea d, [bp + -1] ; $length
0416   0658 2A            mov b, [d]
0417   0659 D8            push b
0418   065A FD 77         inc b
0419   065C FA FF FF      lea d, [bp + -1] ; $length
0420   065F FD 43         mov [d], b
0421   0661 E5            pop b
0422   0662 0A 32 06      jmp _while4_cond
0423   0665             _while4_exit:
0424   0665             ;; return length; 
0425   0665 FA FF FF      lea d, [bp + -1] ; $length
0426   0668 2A            mov b, [d]
0427   0669 F9            leave
0428   066A 09            ret
0429   066B             
0430   066B             printf:
0431   066B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0432   066E             ; $p 
0433   066E             ; $fp 
0434   066E             ; $i 
0435   066E 52 06 00      sub sp, 6
0436   0671             ;; fp = format; 
0437   0671 FA FD FF      lea d, [bp + -3] ; $fp
0438   0674 DA            push d
0439   0675 FA 05 00      lea d, [bp + 5] ; $format
0440   0678 2A            mov b, [d]
0441   0679 E7            pop d
0442   067A FD 43         mov [d], b
0443   067C             ;; p = &format + 2; 
0444   067C FA FF FF      lea d, [bp + -1] ; $p
0445   067F DA            push d
0446   0680 FA 05 00      lea d, [bp + 5] ; $format
0447   0683 2D            mov b, d
0448   0684             ; START TERMS
0449   0684 D7            push a
0450   0685 11            mov a, b
0451   0686 26 02 00      mov b, $2
0452   0689 54            add a, b
0453   068A 27            mov b, a
0454   068B E4            pop a
0455   068C             ; END TERMS
0456   068C E7            pop d
0457   068D FD 43         mov [d], b
0458   068F             ;; for(;;){ 
0459   068F             _for5_init:
0460   068F             _for5_cond:
0461   068F             _for5_block:
0462   068F             ;; if(!*fp) break; 
0463   068F             _if6_cond:
0464   068F FA FD FF      lea d, [bp + -3] ; $fp
0465   0692 2A            mov b, [d]
0466   0693 74            mov d, b
0467   0694 32            mov bl, [d]
0468   0695 A7 00         mov bh, 0
0469   0697 C0 00 00      cmp b, 0
0470   069A FD 71         seq ; !
0471   069C C0 00 00      cmp b, 0
0472   069F C6 A8 06      je _if6_else
0473   06A2             _if6_true:
0474   06A2             ;; break; 
0475   06A2 0A B7 08      jmp _for5_exit ; for break
0476   06A5 0A B4 08      jmp _if6_exit
0477   06A8             _if6_else:
0478   06A8             ;; if(*fp == '%'){ 
0479   06A8             _if7_cond:
0480   06A8 FA FD FF      lea d, [bp + -3] ; $fp
0481   06AB 2A            mov b, [d]
0482   06AC 74            mov d, b
0483   06AD 32            mov bl, [d]
0484   06AE A7 00         mov bh, 0
0485   06B0             ; START RELATIONAL
0486   06B0 D7            push a
0487   06B1 11            mov a, b
0488   06B2 26 25 00      mov b, $25
0489   06B5 B0            cmp a, b
0490   06B6 FD 71         seq ; ==
0491   06B8 E4            pop a
0492   06B9             ; END RELATIONAL
0493   06B9 C0 00 00      cmp b, 0
0494   06BC C6 98 08      je _if7_else
0495   06BF             _if7_true:
0496   06BF             ;; fp++; 
0497   06BF FA FD FF      lea d, [bp + -3] ; $fp
0498   06C2 2A            mov b, [d]
0499   06C3 D8            push b
0500   06C4 FD 77         inc b
0501   06C6 FA FD FF      lea d, [bp + -3] ; $fp
0502   06C9 FD 43         mov [d], b
0503   06CB E5            pop b
0504   06CC             ;; switch(*fp){ 
0505   06CC             _switch8_expr:
0506   06CC FA FD FF      lea d, [bp + -3] ; $fp
0507   06CF 2A            mov b, [d]
0508   06D0 74            mov d, b
0509   06D1 32            mov bl, [d]
0510   06D2 A7 00         mov bh, 0
0511   06D4             _switch8_comparisons:
0512   06D4 C1 6C         cmp bl, $6c
0513   06D6 C6 02 07      je _switch8_case0
0514   06D9 C1 4C         cmp bl, $4c
0515   06DB C6 02 07      je _switch8_case1
0516   06DE C1 64         cmp bl, $64
0517   06E0 C6 D3 07      je _switch8_case2
0518   06E3 C1 69         cmp bl, $69
0519   06E5 C6 D3 07      je _switch8_case3
0520   06E8 C1 75         cmp bl, $75
0521   06EA C6 F8 07      je _switch8_case4
0522   06ED C1 78         cmp bl, $78
0523   06EF C6 1D 08      je _switch8_case5
0524   06F2 C1 63         cmp bl, $63
0525   06F4 C6 3C 08      je _switch8_case6
0526   06F7 C1 73         cmp bl, $73
0527   06F9 C6 5C 08      je _switch8_case7
0528   06FC 0A 7C 08      jmp _switch8_default
0529   06FF 0A 88 08      jmp _switch8_exit
0530   0702             _switch8_case0:
0531   0702             _switch8_case1:
0532   0702             ;; fp++; 
0533   0702 FA FD FF      lea d, [bp + -3] ; $fp
0534   0705 2A            mov b, [d]
0535   0706 D8            push b
0536   0707 FD 77         inc b
0537   0709 FA FD FF      lea d, [bp + -3] ; $fp
0538   070C FD 43         mov [d], b
0539   070E E5            pop b
0540   070F             ;; if(*fp == 'd' || *fp == 'i') 
0541   070F             _if9_cond:
0542   070F FA FD FF      lea d, [bp + -3] ; $fp
0543   0712 2A            mov b, [d]
0544   0713 74            mov d, b
0545   0714 32            mov bl, [d]
0546   0715 A7 00         mov bh, 0
0547   0717             ; START RELATIONAL
0548   0717 D7            push a
0549   0718 11            mov a, b
0550   0719 26 64 00      mov b, $64
0551   071C B0            cmp a, b
0552   071D FD 71         seq ; ==
0553   071F E4            pop a
0554   0720             ; END RELATIONAL
0555   0720 D7            push a
0556   0721 11            mov a, b
0557   0722 FA FD FF      lea d, [bp + -3] ; $fp
0558   0725 2A            mov b, [d]
0559   0726 74            mov d, b
0560   0727 32            mov bl, [d]
0561   0728 A7 00         mov bh, 0
0562   072A             ; START RELATIONAL
0563   072A D7            push a
0564   072B 11            mov a, b
0565   072C 26 69 00      mov b, $69
0566   072F B0            cmp a, b
0567   0730 FD 71         seq ; ==
0568   0732 E4            pop a
0569   0733             ; END RELATIONAL
0570   0733 FD A8         sor a, b ; ||
0571   0735 E4            pop a
0572   0736 C0 00 00      cmp b, 0
0573   0739 C6 50 07      je _if9_else
0574   073C             _if9_true:
0575   073C             ;; print_signed_long(*(long *)p); 
0576   073C FD 79         mov g, b
0577   073E 28            mov b, c
0578   073F FD AB         swp b
0579   0741 D8            push b
0580   0742 FD 27         mov b, g
0581   0744 FD AB         swp b
0582   0746 D8            push b
0583   0747 07 89 0C      call print_signed_long
0584   074A 51 04 00      add sp, 4
0585   074D 0A BD 07      jmp _if9_exit
0586   0750             _if9_else:
0587   0750             ;; if(*fp == 'u') 
0588   0750             _if10_cond:
0589   0750 FA FD FF      lea d, [bp + -3] ; $fp
0590   0753 2A            mov b, [d]
0591   0754 74            mov d, b
0592   0755 32            mov bl, [d]
0593   0756 A7 00         mov bh, 0
0594   0758             ; START RELATIONAL
0595   0758 D7            push a
0596   0759 11            mov a, b
0597   075A 26 75 00      mov b, $75
0598   075D B0            cmp a, b
0599   075E FD 71         seq ; ==
0600   0760 E4            pop a
0601   0761             ; END RELATIONAL
0602   0761 C0 00 00      cmp b, 0
0603   0764 C6 7B 07      je _if10_else
0604   0767             _if10_true:
0605   0767             ;; print_unsigned_long(*(unsigned long *)p); 
0606   0767 FD 79         mov g, b
0607   0769 28            mov b, c
0608   076A FD AB         swp b
0609   076C D8            push b
0610   076D FD 27         mov b, g
0611   076F FD AB         swp b
0612   0771 D8            push b
0613   0772 07 D5 0D      call print_unsigned_long
0614   0775 51 04 00      add sp, 4
0615   0778 0A BD 07      jmp _if10_exit
0616   077B             _if10_else:
0617   077B             ;; if(*fp == 'x') 
0618   077B             _if11_cond:
0619   077B FA FD FF      lea d, [bp + -3] ; $fp
0620   077E 2A            mov b, [d]
0621   077F 74            mov d, b
0622   0780 32            mov bl, [d]
0623   0781 A7 00         mov bh, 0
0624   0783             ; START RELATIONAL
0625   0783 D7            push a
0626   0784 11            mov a, b
0627   0785 26 78 00      mov b, $78
0628   0788 B0            cmp a, b
0629   0789 FD 71         seq ; ==
0630   078B E4            pop a
0631   078C             ; END RELATIONAL
0632   078C C0 00 00      cmp b, 0
0633   078F C6 B1 07      je _if11_else
0634   0792             _if11_true:
0635   0792             ;; printx32(*(long int *)p); 
0636   0792 FA FF FF      lea d, [bp + -1] ; $p
0637   0795 2A            mov b, [d]
0638   0796 74            mov d, b
0639   0797 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0640   079A FD 39         mov c, b ; And place it into C
0641   079C 2A            mov b, [d] ; Lower Word in B
0642   079D FD 79         mov g, b
0643   079F 28            mov b, c
0644   07A0 FD AB         swp b
0645   07A2 D8            push b
0646   07A3 FD 27         mov b, g
0647   07A5 FD AB         swp b
0648   07A7 D8            push b
0649   07A8 07 CE 08      call printx32
0650   07AB 51 04 00      add sp, 4
0651   07AE 0A BD 07      jmp _if11_exit
0652   07B1             _if11_else:
0653   07B1             ;; err("Unexpected format in printf."); 
0654   07B1 26 8C 14      mov b, __s1 ; "Unexpected format in printf."
0655   07B4 FD AB         swp b
0656   07B6 D8            push b
0657   07B7 07 B9 08      call err
0658   07BA 51 02 00      add sp, 2
0659   07BD             _if11_exit:
0660   07BD             _if10_exit:
0661   07BD             _if9_exit:
0662   07BD             ;; p = p + 4; 
0663   07BD FA FF FF      lea d, [bp + -1] ; $p
0664   07C0 DA            push d
0665   07C1 FA FF FF      lea d, [bp + -1] ; $p
0666   07C4 2A            mov b, [d]
0667   07C5             ; START TERMS
0668   07C5 D7            push a
0669   07C6 11            mov a, b
0670   07C7 26 04 00      mov b, $4
0671   07CA 54            add a, b
0672   07CB 27            mov b, a
0673   07CC E4            pop a
0674   07CD             ; END TERMS
0675   07CD E7            pop d
0676   07CE FD 43         mov [d], b
0677   07D0             ;; break; 
0678   07D0 0A 88 08      jmp _switch8_exit ; case break
0679   07D3             _switch8_case2:
0680   07D3             _switch8_case3:
0681   07D3             ;; print_signed(*(int*)p); 
0682   07D3 FA FF FF      lea d, [bp + -1] ; $p
0683   07D6 2A            mov b, [d]
0684   07D7 74            mov d, b
0685   07D8 2A            mov b, [d]
0686   07D9 FD AB         swp b
0687   07DB D8            push b
0688   07DC 07 81 0B      call print_signed
0689   07DF 51 02 00      add sp, 2
0690   07E2             ;; p = p + 2; 
0691   07E2 FA FF FF      lea d, [bp + -1] ; $p
0692   07E5 DA            push d
0693   07E6 FA FF FF      lea d, [bp + -1] ; $p
0694   07E9 2A            mov b, [d]
0695   07EA             ; START TERMS
0696   07EA D7            push a
0697   07EB 11            mov a, b
0698   07EC 26 02 00      mov b, $2
0699   07EF 54            add a, b
0700   07F0 27            mov b, a
0701   07F1 E4            pop a
0702   07F2             ; END TERMS
0703   07F2 E7            pop d
0704   07F3 FD 43         mov [d], b
0705   07F5             ;; break; 
0706   07F5 0A 88 08      jmp _switch8_exit ; case break
0707   07F8             _switch8_case4:
0708   07F8             ;; print_unsigned(*(unsigned int*)p); 
0709   07F8 FA FF FF      lea d, [bp + -1] ; $p
0710   07FB 2A            mov b, [d]
0711   07FC 74            mov d, b
0712   07FD 2A            mov b, [d]
0713   07FE FD AB         swp b
0714   0800 D8            push b
0715   0801 07 CC 0E      call print_unsigned
0716   0804 51 02 00      add sp, 2
0717   0807             ;; p = p + 2; 
0718   0807 FA FF FF      lea d, [bp + -1] ; $p
0719   080A DA            push d
0720   080B FA FF FF      lea d, [bp + -1] ; $p
0721   080E 2A            mov b, [d]
0722   080F             ; START TERMS
0723   080F D7            push a
0724   0810 11            mov a, b
0725   0811 26 02 00      mov b, $2
0726   0814 54            add a, b
0727   0815 27            mov b, a
0728   0816 E4            pop a
0729   0817             ; END TERMS
0730   0817 E7            pop d
0731   0818 FD 43         mov [d], b
0732   081A             ;; break; 
0733   081A 0A 88 08      jmp _switch8_exit ; case break
0734   081D             _switch8_case5:
0735   081D             
0736   081D             ; --- BEGIN INLINE ASM BLOCK
0737   081D FA FF FF      lea d, [bp + -1] ; $p
0738   0820 FD 2A         mov d, [d]
0739   0822 2A            mov b, [d]
0740   0823 07 7D 13      call print_u16x
0741   0826             ; --- END INLINE ASM BLOCK
0742   0826             
0743   0826             ;; p = p + 2; 
0744   0826 FA FF FF      lea d, [bp + -1] ; $p
0745   0829 DA            push d
0746   082A FA FF FF      lea d, [bp + -1] ; $p
0747   082D 2A            mov b, [d]
0748   082E             ; START TERMS
0749   082E D7            push a
0750   082F 11            mov a, b
0751   0830 26 02 00      mov b, $2
0752   0833 54            add a, b
0753   0834 27            mov b, a
0754   0835 E4            pop a
0755   0836             ; END TERMS
0756   0836 E7            pop d
0757   0837 FD 43         mov [d], b
0758   0839             ;; break; 
0759   0839 0A 88 08      jmp _switch8_exit ; case break
0760   083C             _switch8_case6:
0761   083C             
0762   083C             ; --- BEGIN INLINE ASM BLOCK
0763   083C FA FF FF      lea d, [bp + -1] ; $p
0764   083F FD 2A         mov d, [d]
0765   0841 1E            mov al, [d]
0766   0842 23            mov ah, al
0767   0843 07 DB 11      call _putchar
0768   0846             ; --- END INLINE ASM BLOCK
0769   0846             
0770   0846             ;; p = p + 2; 
0771   0846 FA FF FF      lea d, [bp + -1] ; $p
0772   0849 DA            push d
0773   084A FA FF FF      lea d, [bp + -1] ; $p
0774   084D 2A            mov b, [d]
0775   084E             ; START TERMS
0776   084E D7            push a
0777   084F 11            mov a, b
0778   0850 26 02 00      mov b, $2
0779   0853 54            add a, b
0780   0854 27            mov b, a
0781   0855 E4            pop a
0782   0856             ; END TERMS
0783   0856 E7            pop d
0784   0857 FD 43         mov [d], b
0785   0859             ;; break; 
0786   0859 0A 88 08      jmp _switch8_exit ; case break
0787   085C             _switch8_case7:
0788   085C             
0789   085C             ; --- BEGIN INLINE ASM BLOCK
0790   085C FA FF FF      lea d, [bp + -1] ; $p
0791   085F FD 2A         mov d, [d]
0792   0861 FD 2A         mov d, [d]
0793   0863 07 25 13      call _puts
0794   0866             ; --- END INLINE ASM BLOCK
0795   0866             
0796   0866             ;; p = p + 2; 
0797   0866 FA FF FF      lea d, [bp + -1] ; $p
0798   0869 DA            push d
0799   086A FA FF FF      lea d, [bp + -1] ; $p
0800   086D 2A            mov b, [d]
0801   086E             ; START TERMS
0802   086E D7            push a
0803   086F 11            mov a, b
0804   0870 26 02 00      mov b, $2
0805   0873 54            add a, b
0806   0874 27            mov b, a
0807   0875 E4            pop a
0808   0876             ; END TERMS
0809   0876 E7            pop d
0810   0877 FD 43         mov [d], b
0811   0879             ;; break; 
0812   0879 0A 88 08      jmp _switch8_exit ; case break
0813   087C             _switch8_default:
0814   087C             ;; print("Error: Unknown argument type.\n"); 
0815   087C 26 A9 14      mov b, __s2 ; "Error: Unknown argument type.\n"
0816   087F FD AB         swp b
0817   0881 D8            push b
0818   0882 07 FC 0F      call print
0819   0885 51 02 00      add sp, 2
0820   0888             _switch8_exit:
0821   0888             ;; fp++; 
0822   0888 FA FD FF      lea d, [bp + -3] ; $fp
0823   088B 2A            mov b, [d]
0824   088C D8            push b
0825   088D FD 77         inc b
0826   088F FA FD FF      lea d, [bp + -3] ; $fp
0827   0892 FD 43         mov [d], b
0828   0894 E5            pop b
0829   0895 0A B4 08      jmp _if7_exit
0830   0898             _if7_else:
0831   0898             ;; putchar(*fp); 
0832   0898 FA FD FF      lea d, [bp + -3] ; $fp
0833   089B 2A            mov b, [d]
0834   089C 74            mov d, b
0835   089D 32            mov bl, [d]
0836   089E A7 00         mov bh, 0
0837   08A0 DD            push bl
0838   08A1 07 B4 0F      call putchar
0839   08A4 51 01 00      add sp, 1
0840   08A7             ;; fp++; 
0841   08A7 FA FD FF      lea d, [bp + -3] ; $fp
0842   08AA 2A            mov b, [d]
0843   08AB D8            push b
0844   08AC FD 77         inc b
0845   08AE FA FD FF      lea d, [bp + -3] ; $fp
0846   08B1 FD 43         mov [d], b
0847   08B3 E5            pop b
0848   08B4             _if7_exit:
0849   08B4             _if6_exit:
0850   08B4             _for5_update:
0851   08B4 0A 8F 06      jmp _for5_cond
0852   08B7             _for5_exit:
0853   08B7 F9            leave
0854   08B8 09            ret
0855   08B9             
0856   08B9             err:
0857   08B9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0858   08BC             ;; print(e); 
0859   08BC FA 05 00      lea d, [bp + 5] ; $e
0860   08BF 2A            mov b, [d]
0861   08C0 FD AB         swp b
0862   08C2 D8            push b
0863   08C3 07 FC 0F      call print
0864   08C6 51 02 00      add sp, 2
0865   08C9             ;; exit(); 
0866   08C9 07 76 10      call exit
0867   08CC F9            leave
0868   08CD 09            ret
0869   08CE             
0870   08CE             printx32:
0871   08CE F8 00 00      enter 0 ; (push bp; mov bp, sp)
0872   08D1             
0873   08D1             ; --- BEGIN INLINE ASM BLOCK
0874   08D1 FA 05 00      lea d, [bp + 5] ; $hex
0875   08D4 2B 02 00      mov b, [d+2]
0876   08D7 07 7D 13      call print_u16x
0877   08DA 2A            mov b, [d]
0878   08DB 07 7D 13      call print_u16x
0879   08DE             ; --- END INLINE ASM BLOCK
0880   08DE             
0881   08DE F9            leave
0882   08DF 09            ret
0883   08E0             
0884   08E0             printx16:
0885   08E0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0886   08E3             
0887   08E3             ; --- BEGIN INLINE ASM BLOCK
0888   08E3 FA 05 00      lea d, [bp + 5] ; $hex
0889   08E6 2A            mov b, [d]
0890   08E7 07 7D 13      call print_u16x
0891   08EA             ; --- END INLINE ASM BLOCK
0892   08EA             
0893   08EA F9            leave
0894   08EB 09            ret
0895   08EC             
0896   08EC             printx8:
0897   08EC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0898   08EF             
0899   08EF             ; --- BEGIN INLINE ASM BLOCK
0900   08EF FA 05 00      lea d, [bp + 5] ; $hex
0901   08F2 32            mov bl, [d]
0902   08F3 07 C1 13      call print_u8x
0903   08F6             ; --- END INLINE ASM BLOCK
0904   08F6             
0905   08F6 F9            leave
0906   08F7 09            ret
0907   08F8             
0908   08F8             hex_to_int:
0909   08F8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0910   08FB             ; $value 
0911   08FB 10 00 00      mov a, $0
0912   08FE 45 FF FF      mov [bp + -1], a
0913   0901             ; $i 
0914   0901             ; $hex_char 
0915   0901             ; $len 
0916   0901 52 07 00      sub sp, 7
0917   0904             ;; len = strlen(hex_string); 
0918   0904 FA FA FF      lea d, [bp + -6] ; $len
0919   0907 DA            push d
0920   0908 FA 05 00      lea d, [bp + 5] ; $hex_string
0921   090B 2A            mov b, [d]
0922   090C FD AB         swp b
0923   090E D8            push b
0924   090F 07 22 06      call strlen
0925   0912 51 02 00      add sp, 2
0926   0915 E7            pop d
0927   0916 FD 43         mov [d], b
0928   0918             ;; for (i = 0; i < len; i++) { 
0929   0918             _for12_init:
0930   0918 FA FD FF      lea d, [bp + -3] ; $i
0931   091B DA            push d
0932   091C 26 00 00      mov b, $0
0933   091F E7            pop d
0934   0920 FD 43         mov [d], b
0935   0922             _for12_cond:
0936   0922 FA FD FF      lea d, [bp + -3] ; $i
0937   0925 2A            mov b, [d]
0938   0926             ; START RELATIONAL
0939   0926 D7            push a
0940   0927 11            mov a, b
0941   0928 FA FA FF      lea d, [bp + -6] ; $len
0942   092B 2A            mov b, [d]
0943   092C 4D            mov si, a
0944   092D 11            mov a, b
0945   092E 4F            mov di, a
0946   092F FD 12         mov a, g
0947   0931 28            mov b, c
0948   0932 B0            cmp a, b
0949   0933 FD 75         slu ; <
0950   0935 D8            push b
0951   0936 28            mov b, c
0952   0937 FD 71         seq ; ==
0953   0939 D8            push b
0954   093A 50            mov a, di
0955   093B 27            mov b, a
0956   093C 4E            mov a, si
0957   093D B0            cmp a, b
0958   093E FD 75         slu ; <
0959   0940 E4            pop a
0960   0941 FD 92         and b, a
0961   0943 E4            pop a
0962   0944 FD 70         or b, a
0963   0946               
0964   0946 E4            pop a
0965   0947             ; END RELATIONAL
0966   0947 C0 00 00      cmp b, 0
0967   094A C6 4F 0A      je _for12_exit
0968   094D             _for12_block:
0969   094D             ;; hex_char = hex_string[i]; 
0970   094D FA FC FF      lea d, [bp + -4] ; $hex_char
0971   0950 DA            push d
0972   0951 FA 05 00      lea d, [bp + 5] ; $hex_string
0973   0954 FD 2A         mov d, [d]
0974   0956 D7            push a
0975   0957 DA            push d
0976   0958 FA FD FF      lea d, [bp + -3] ; $i
0977   095B 2A            mov b, [d]
0978   095C E7            pop d
0979   095D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0980   0961 E4            pop a
0981   0962 32            mov bl, [d]
0982   0963 A7 00         mov bh, 0
0983   0965 E7            pop d
0984   0966 FD 3E         mov [d], bl
0985   0968             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0986   0968             _if13_cond:
0987   0968 FA FC FF      lea d, [bp + -4] ; $hex_char
0988   096B 32            mov bl, [d]
0989   096C A7 00         mov bh, 0
0990   096E             ; START RELATIONAL
0991   096E D7            push a
0992   096F 11            mov a, b
0993   0970 26 61 00      mov b, $61
0994   0973 B0            cmp a, b
0995   0974 FD 80         sge ; >=
0996   0976 E4            pop a
0997   0977             ; END RELATIONAL
0998   0977 D7            push a
0999   0978 11            mov a, b
1000   0979 FA FC FF      lea d, [bp + -4] ; $hex_char
1001   097C 32            mov bl, [d]
1002   097D A7 00         mov bh, 0
1003   097F             ; START RELATIONAL
1004   097F D7            push a
1005   0980 11            mov a, b
1006   0981 26 66 00      mov b, $66
1007   0984 B0            cmp a, b
1008   0985 FD 74         sle ; <=
1009   0987 E4            pop a
1010   0988             ; END RELATIONAL
1011   0988 FD A7         sand a, b ; &&
1012   098A E4            pop a
1013   098B C0 00 00      cmp b, 0
1014   098E C6 C0 09      je _if13_else
1015   0991             _if13_true:
1016   0991             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1017   0991 FA FF FF      lea d, [bp + -1] ; $value
1018   0994 DA            push d
1019   0995 FA FF FF      lea d, [bp + -1] ; $value
1020   0998 2A            mov b, [d]
1021   0999             ; START FACTORS
1022   0999 D7            push a
1023   099A 11            mov a, b
1024   099B 26 10 00      mov b, $10
1025   099E AC            mul a, b ; *
1026   099F 11            mov a, b
1027   09A0 27            mov b, a
1028   09A1 E4            pop a
1029   09A2             ; END FACTORS
1030   09A2             ; START TERMS
1031   09A2 D7            push a
1032   09A3 11            mov a, b
1033   09A4 FA FC FF      lea d, [bp + -4] ; $hex_char
1034   09A7 32            mov bl, [d]
1035   09A8 A7 00         mov bh, 0
1036   09AA             ; START TERMS
1037   09AA D7            push a
1038   09AB 11            mov a, b
1039   09AC 26 61 00      mov b, $61
1040   09AF 60            sub a, b
1041   09B0 11            mov a, b
1042   09B1 26 0A 00      mov b, $a
1043   09B4 54            add a, b
1044   09B5 27            mov b, a
1045   09B6 E4            pop a
1046   09B7             ; END TERMS
1047   09B7 54            add a, b
1048   09B8 27            mov b, a
1049   09B9 E4            pop a
1050   09BA             ; END TERMS
1051   09BA E7            pop d
1052   09BB FD 43         mov [d], b
1053   09BD 0A 3F 0A      jmp _if13_exit
1054   09C0             _if13_else:
1055   09C0             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1056   09C0             _if14_cond:
1057   09C0 FA FC FF      lea d, [bp + -4] ; $hex_char
1058   09C3 32            mov bl, [d]
1059   09C4 A7 00         mov bh, 0
1060   09C6             ; START RELATIONAL
1061   09C6 D7            push a
1062   09C7 11            mov a, b
1063   09C8 26 41 00      mov b, $41
1064   09CB B0            cmp a, b
1065   09CC FD 80         sge ; >=
1066   09CE E4            pop a
1067   09CF             ; END RELATIONAL
1068   09CF D7            push a
1069   09D0 11            mov a, b
1070   09D1 FA FC FF      lea d, [bp + -4] ; $hex_char
1071   09D4 32            mov bl, [d]
1072   09D5 A7 00         mov bh, 0
1073   09D7             ; START RELATIONAL
1074   09D7 D7            push a
1075   09D8 11            mov a, b
1076   09D9 26 46 00      mov b, $46
1077   09DC B0            cmp a, b
1078   09DD FD 74         sle ; <=
1079   09DF E4            pop a
1080   09E0             ; END RELATIONAL
1081   09E0 FD A7         sand a, b ; &&
1082   09E2 E4            pop a
1083   09E3 C0 00 00      cmp b, 0
1084   09E6 C6 18 0A      je _if14_else
1085   09E9             _if14_true:
1086   09E9             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1087   09E9 FA FF FF      lea d, [bp + -1] ; $value
1088   09EC DA            push d
1089   09ED FA FF FF      lea d, [bp + -1] ; $value
1090   09F0 2A            mov b, [d]
1091   09F1             ; START FACTORS
1092   09F1 D7            push a
1093   09F2 11            mov a, b
1094   09F3 26 10 00      mov b, $10
1095   09F6 AC            mul a, b ; *
1096   09F7 11            mov a, b
1097   09F8 27            mov b, a
1098   09F9 E4            pop a
1099   09FA             ; END FACTORS
1100   09FA             ; START TERMS
1101   09FA D7            push a
1102   09FB 11            mov a, b
1103   09FC FA FC FF      lea d, [bp + -4] ; $hex_char
1104   09FF 32            mov bl, [d]
1105   0A00 A7 00         mov bh, 0
1106   0A02             ; START TERMS
1107   0A02 D7            push a
1108   0A03 11            mov a, b
1109   0A04 26 41 00      mov b, $41
1110   0A07 60            sub a, b
1111   0A08 11            mov a, b
1112   0A09 26 0A 00      mov b, $a
1113   0A0C 54            add a, b
1114   0A0D 27            mov b, a
1115   0A0E E4            pop a
1116   0A0F             ; END TERMS
1117   0A0F 54            add a, b
1118   0A10 27            mov b, a
1119   0A11 E4            pop a
1120   0A12             ; END TERMS
1121   0A12 E7            pop d
1122   0A13 FD 43         mov [d], b
1123   0A15 0A 3F 0A      jmp _if14_exit
1124   0A18             _if14_else:
1125   0A18             ;; value = (value * 16) + (hex_char - '0'); 
1126   0A18 FA FF FF      lea d, [bp + -1] ; $value
1127   0A1B DA            push d
1128   0A1C FA FF FF      lea d, [bp + -1] ; $value
1129   0A1F 2A            mov b, [d]
1130   0A20             ; START FACTORS
1131   0A20 D7            push a
1132   0A21 11            mov a, b
1133   0A22 26 10 00      mov b, $10
1134   0A25 AC            mul a, b ; *
1135   0A26 11            mov a, b
1136   0A27 27            mov b, a
1137   0A28 E4            pop a
1138   0A29             ; END FACTORS
1139   0A29             ; START TERMS
1140   0A29 D7            push a
1141   0A2A 11            mov a, b
1142   0A2B FA FC FF      lea d, [bp + -4] ; $hex_char
1143   0A2E 32            mov bl, [d]
1144   0A2F A7 00         mov bh, 0
1145   0A31             ; START TERMS
1146   0A31 D7            push a
1147   0A32 11            mov a, b
1148   0A33 26 30 00      mov b, $30
1149   0A36 60            sub a, b
1150   0A37 27            mov b, a
1151   0A38 E4            pop a
1152   0A39             ; END TERMS
1153   0A39 54            add a, b
1154   0A3A 27            mov b, a
1155   0A3B E4            pop a
1156   0A3C             ; END TERMS
1157   0A3C E7            pop d
1158   0A3D FD 43         mov [d], b
1159   0A3F             _if14_exit:
1160   0A3F             _if13_exit:
1161   0A3F             _for12_update:
1162   0A3F FA FD FF      lea d, [bp + -3] ; $i
1163   0A42 2A            mov b, [d]
1164   0A43 D8            push b
1165   0A44 FD 77         inc b
1166   0A46 FA FD FF      lea d, [bp + -3] ; $i
1167   0A49 FD 43         mov [d], b
1168   0A4B E5            pop b
1169   0A4C 0A 22 09      jmp _for12_cond
1170   0A4F             _for12_exit:
1171   0A4F             ;; return value; 
1172   0A4F FA FF FF      lea d, [bp + -1] ; $value
1173   0A52 2A            mov b, [d]
1174   0A53 F9            leave
1175   0A54 09            ret
1176   0A55             
1177   0A55             atoi:
1178   0A55 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1179   0A58             ; $result 
1180   0A58 10 00 00      mov a, $0
1181   0A5B 45 FF FF      mov [bp + -1], a
1182   0A5E             ; $sign 
1183   0A5E 10 01 00      mov a, $1
1184   0A61 45 FD FF      mov [bp + -3], a
1185   0A64 52 04 00      sub sp, 4
1186   0A67             ;; while (*str == ' ') str++; 
1187   0A67             _while15_cond:
1188   0A67 FA 05 00      lea d, [bp + 5] ; $str
1189   0A6A 2A            mov b, [d]
1190   0A6B 74            mov d, b
1191   0A6C 32            mov bl, [d]
1192   0A6D A7 00         mov bh, 0
1193   0A6F             ; START RELATIONAL
1194   0A6F D7            push a
1195   0A70 11            mov a, b
1196   0A71 26 20 00      mov b, $20
1197   0A74 B0            cmp a, b
1198   0A75 FD 71         seq ; ==
1199   0A77 E4            pop a
1200   0A78             ; END RELATIONAL
1201   0A78 C0 00 00      cmp b, 0
1202   0A7B C6 8E 0A      je _while15_exit
1203   0A7E             _while15_block:
1204   0A7E             ;; str++; 
1205   0A7E FA 05 00      lea d, [bp + 5] ; $str
1206   0A81 2A            mov b, [d]
1207   0A82 D8            push b
1208   0A83 FD 77         inc b
1209   0A85 FA 05 00      lea d, [bp + 5] ; $str
1210   0A88 FD 43         mov [d], b
1211   0A8A E5            pop b
1212   0A8B 0A 67 0A      jmp _while15_cond
1213   0A8E             _while15_exit:
1214   0A8E             ;; if (*str == '-' || *str == '+') { 
1215   0A8E             _if16_cond:
1216   0A8E FA 05 00      lea d, [bp + 5] ; $str
1217   0A91 2A            mov b, [d]
1218   0A92 74            mov d, b
1219   0A93 32            mov bl, [d]
1220   0A94 A7 00         mov bh, 0
1221   0A96             ; START RELATIONAL
1222   0A96 D7            push a
1223   0A97 11            mov a, b
1224   0A98 26 2D 00      mov b, $2d
1225   0A9B B0            cmp a, b
1226   0A9C FD 71         seq ; ==
1227   0A9E E4            pop a
1228   0A9F             ; END RELATIONAL
1229   0A9F D7            push a
1230   0AA0 11            mov a, b
1231   0AA1 FA 05 00      lea d, [bp + 5] ; $str
1232   0AA4 2A            mov b, [d]
1233   0AA5 74            mov d, b
1234   0AA6 32            mov bl, [d]
1235   0AA7 A7 00         mov bh, 0
1236   0AA9             ; START RELATIONAL
1237   0AA9 D7            push a
1238   0AAA 11            mov a, b
1239   0AAB 26 2B 00      mov b, $2b
1240   0AAE B0            cmp a, b
1241   0AAF FD 71         seq ; ==
1242   0AB1 E4            pop a
1243   0AB2             ; END RELATIONAL
1244   0AB2 FD A8         sor a, b ; ||
1245   0AB4 E4            pop a
1246   0AB5 C0 00 00      cmp b, 0
1247   0AB8 C6 F1 0A      je _if16_exit
1248   0ABB             _if16_true:
1249   0ABB             ;; if (*str == '-') sign = -1; 
1250   0ABB             _if17_cond:
1251   0ABB FA 05 00      lea d, [bp + 5] ; $str
1252   0ABE 2A            mov b, [d]
1253   0ABF 74            mov d, b
1254   0AC0 32            mov bl, [d]
1255   0AC1 A7 00         mov bh, 0
1256   0AC3             ; START RELATIONAL
1257   0AC3 D7            push a
1258   0AC4 11            mov a, b
1259   0AC5 26 2D 00      mov b, $2d
1260   0AC8 B0            cmp a, b
1261   0AC9 FD 71         seq ; ==
1262   0ACB E4            pop a
1263   0ACC             ; END RELATIONAL
1264   0ACC C0 00 00      cmp b, 0
1265   0ACF C6 E1 0A      je _if17_exit
1266   0AD2             _if17_true:
1267   0AD2             ;; sign = -1; 
1268   0AD2 FA FD FF      lea d, [bp + -3] ; $sign
1269   0AD5 DA            push d
1270   0AD6 26 01 00      mov b, $1
1271   0AD9 FD 97         neg b
1272   0ADB E7            pop d
1273   0ADC FD 43         mov [d], b
1274   0ADE 0A E1 0A      jmp _if17_exit
1275   0AE1             _if17_exit:
1276   0AE1             ;; str++; 
1277   0AE1 FA 05 00      lea d, [bp + 5] ; $str
1278   0AE4 2A            mov b, [d]
1279   0AE5 D8            push b
1280   0AE6 FD 77         inc b
1281   0AE8 FA 05 00      lea d, [bp + 5] ; $str
1282   0AEB FD 43         mov [d], b
1283   0AED E5            pop b
1284   0AEE 0A F1 0A      jmp _if16_exit
1285   0AF1             _if16_exit:
1286   0AF1             ;; while (*str >= '0' && *str <= '9') { 
1287   0AF1             _while18_cond:
1288   0AF1 FA 05 00      lea d, [bp + 5] ; $str
1289   0AF4 2A            mov b, [d]
1290   0AF5 74            mov d, b
1291   0AF6 32            mov bl, [d]
1292   0AF7 A7 00         mov bh, 0
1293   0AF9             ; START RELATIONAL
1294   0AF9 D7            push a
1295   0AFA 11            mov a, b
1296   0AFB 26 30 00      mov b, $30
1297   0AFE B0            cmp a, b
1298   0AFF FD 82         sgeu ; >= (unsigned)
1299   0B01 E4            pop a
1300   0B02             ; END RELATIONAL
1301   0B02 D7            push a
1302   0B03 11            mov a, b
1303   0B04 FA 05 00      lea d, [bp + 5] ; $str
1304   0B07 2A            mov b, [d]
1305   0B08 74            mov d, b
1306   0B09 32            mov bl, [d]
1307   0B0A A7 00         mov bh, 0
1308   0B0C             ; START RELATIONAL
1309   0B0C D7            push a
1310   0B0D 11            mov a, b
1311   0B0E 26 39 00      mov b, $39
1312   0B11 B0            cmp a, b
1313   0B12 FD 76         sleu ; <= (unsigned)
1314   0B14 E4            pop a
1315   0B15             ; END RELATIONAL
1316   0B15 FD A7         sand a, b ; &&
1317   0B17 E4            pop a
1318   0B18 C0 00 00      cmp b, 0
1319   0B1B C6 57 0B      je _while18_exit
1320   0B1E             _while18_block:
1321   0B1E             ;; result = result * 10 + (*str - '0'); 
1322   0B1E FA FF FF      lea d, [bp + -1] ; $result
1323   0B21 DA            push d
1324   0B22 FA FF FF      lea d, [bp + -1] ; $result
1325   0B25 2A            mov b, [d]
1326   0B26             ; START FACTORS
1327   0B26 D7            push a
1328   0B27 11            mov a, b
1329   0B28 26 0A 00      mov b, $a
1330   0B2B AC            mul a, b ; *
1331   0B2C 11            mov a, b
1332   0B2D 27            mov b, a
1333   0B2E E4            pop a
1334   0B2F             ; END FACTORS
1335   0B2F             ; START TERMS
1336   0B2F D7            push a
1337   0B30 11            mov a, b
1338   0B31 FA 05 00      lea d, [bp + 5] ; $str
1339   0B34 2A            mov b, [d]
1340   0B35 74            mov d, b
1341   0B36 32            mov bl, [d]
1342   0B37 A7 00         mov bh, 0
1343   0B39             ; START TERMS
1344   0B39 D7            push a
1345   0B3A 11            mov a, b
1346   0B3B 26 30 00      mov b, $30
1347   0B3E 60            sub a, b
1348   0B3F 27            mov b, a
1349   0B40 E4            pop a
1350   0B41             ; END TERMS
1351   0B41 54            add a, b
1352   0B42 27            mov b, a
1353   0B43 E4            pop a
1354   0B44             ; END TERMS
1355   0B44 E7            pop d
1356   0B45 FD 43         mov [d], b
1357   0B47             ;; str++; 
1358   0B47 FA 05 00      lea d, [bp + 5] ; $str
1359   0B4A 2A            mov b, [d]
1360   0B4B D8            push b
1361   0B4C FD 77         inc b
1362   0B4E FA 05 00      lea d, [bp + 5] ; $str
1363   0B51 FD 43         mov [d], b
1364   0B53 E5            pop b
1365   0B54 0A F1 0A      jmp _while18_cond
1366   0B57             _while18_exit:
1367   0B57             ;; return sign * result; 
1368   0B57 FA FD FF      lea d, [bp + -3] ; $sign
1369   0B5A 2A            mov b, [d]
1370   0B5B             ; START FACTORS
1371   0B5B D7            push a
1372   0B5C 11            mov a, b
1373   0B5D FA FF FF      lea d, [bp + -1] ; $result
1374   0B60 2A            mov b, [d]
1375   0B61 AC            mul a, b ; *
1376   0B62 11            mov a, b
1377   0B63 27            mov b, a
1378   0B64 E4            pop a
1379   0B65             ; END FACTORS
1380   0B65 F9            leave
1381   0B66 09            ret
1382   0B67             
1383   0B67             gets:
1384   0B67 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1385   0B6A             
1386   0B6A             ; --- BEGIN INLINE ASM BLOCK
1387   0B6A FA 05 00      lea d, [bp + 5] ; $s
1388   0B6D 15            mov a, [d]
1389   0B6E 3C            mov d, a
1390   0B6F 07 E2 11      call _gets
1391   0B72             ; --- END INLINE ASM BLOCK
1392   0B72             
1393   0B72             ;; return strlen(s); 
1394   0B72 FA 05 00      lea d, [bp + 5] ; $s
1395   0B75 2A            mov b, [d]
1396   0B76 FD AB         swp b
1397   0B78 D8            push b
1398   0B79 07 22 06      call strlen
1399   0B7C 51 02 00      add sp, 2
1400   0B7F F9            leave
1401   0B80 09            ret
1402   0B81             
1403   0B81             print_signed:
1404   0B81 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1405   0B84             ; $digits 
1406   0B84             ; $i 
1407   0B84 10 00 00      mov a, $0
1408   0B87 45 FA FF      mov [bp + -6], a
1409   0B8A 52 07 00      sub sp, 7
1410   0B8D             ;; if (num < 0) { 
1411   0B8D             _if19_cond:
1412   0B8D FA 05 00      lea d, [bp + 5] ; $num
1413   0B90 2A            mov b, [d]
1414   0B91             ; START RELATIONAL
1415   0B91 D7            push a
1416   0B92 11            mov a, b
1417   0B93 26 00 00      mov b, $0
1418   0B96 4D            mov si, a
1419   0B97 11            mov a, b
1420   0B98 4F            mov di, a
1421   0B99 FD 12         mov a, g
1422   0B9B 28            mov b, c
1423   0B9C B0            cmp a, b
1424   0B9D FD 75         slu ; <
1425   0B9F D8            push b
1426   0BA0 28            mov b, c
1427   0BA1 FD 71         seq ; ==
1428   0BA3 D8            push b
1429   0BA4 50            mov a, di
1430   0BA5 27            mov b, a
1431   0BA6 4E            mov a, si
1432   0BA7 B0            cmp a, b
1433   0BA8 FD 75         slu ; <
1434   0BAA E4            pop a
1435   0BAB FD 92         and b, a
1436   0BAD E4            pop a
1437   0BAE FD 70         or b, a
1438   0BB0               
1439   0BB0 E4            pop a
1440   0BB1             ; END RELATIONAL
1441   0BB1 C0 00 00      cmp b, 0
1442   0BB4 C6 D1 0B      je _if19_else
1443   0BB7             _if19_true:
1444   0BB7             ;; putchar('-'); 
1445   0BB7 26 2D 00      mov b, $2d
1446   0BBA DD            push bl
1447   0BBB 07 B4 0F      call putchar
1448   0BBE 51 01 00      add sp, 1
1449   0BC1             ;; num = -num; 
1450   0BC1 FA 05 00      lea d, [bp + 5] ; $num
1451   0BC4 DA            push d
1452   0BC5 FA 05 00      lea d, [bp + 5] ; $num
1453   0BC8 2A            mov b, [d]
1454   0BC9 FD 97         neg b
1455   0BCB E7            pop d
1456   0BCC FD 43         mov [d], b
1457   0BCE 0A F3 0B      jmp _if19_exit
1458   0BD1             _if19_else:
1459   0BD1             ;; if (num == 0) { 
1460   0BD1             _if20_cond:
1461   0BD1 FA 05 00      lea d, [bp + 5] ; $num
1462   0BD4 2A            mov b, [d]
1463   0BD5             ; START RELATIONAL
1464   0BD5 D7            push a
1465   0BD6 11            mov a, b
1466   0BD7 26 00 00      mov b, $0
1467   0BDA B0            cmp a, b
1468   0BDB FD 71         seq ; ==
1469   0BDD E4            pop a
1470   0BDE             ; END RELATIONAL
1471   0BDE C0 00 00      cmp b, 0
1472   0BE1 C6 F3 0B      je _if20_exit
1473   0BE4             _if20_true:
1474   0BE4             ;; putchar('0'); 
1475   0BE4 26 30 00      mov b, $30
1476   0BE7 DD            push bl
1477   0BE8 07 B4 0F      call putchar
1478   0BEB 51 01 00      add sp, 1
1479   0BEE             ;; return; 
1480   0BEE F9            leave
1481   0BEF 09            ret
1482   0BF0 0A F3 0B      jmp _if20_exit
1483   0BF3             _if20_exit:
1484   0BF3             _if19_exit:
1485   0BF3             ;; while (num > 0) { 
1486   0BF3             _while21_cond:
1487   0BF3 FA 05 00      lea d, [bp + 5] ; $num
1488   0BF6 2A            mov b, [d]
1489   0BF7             ; START RELATIONAL
1490   0BF7 D7            push a
1491   0BF8 11            mov a, b
1492   0BF9 26 00 00      mov b, $0
1493   0BFC B0            cmp a, b
1494   0BFD FD 7F         sgt ; >
1495   0BFF E4            pop a
1496   0C00             ; END RELATIONAL
1497   0C00 C0 00 00      cmp b, 0
1498   0C03 C6 4E 0C      je _while21_exit
1499   0C06             _while21_block:
1500   0C06             ;; digits[i] = '0' + (num % 10); 
1501   0C06 FA FC FF      lea d, [bp + -4] ; $digits
1502   0C09 D7            push a
1503   0C0A DA            push d
1504   0C0B FA FA FF      lea d, [bp + -6] ; $i
1505   0C0E 2A            mov b, [d]
1506   0C0F E7            pop d
1507   0C10 5A            add d, b
1508   0C11 E4            pop a
1509   0C12 DA            push d
1510   0C13 26 30 00      mov b, $30
1511   0C16             ; START TERMS
1512   0C16 D7            push a
1513   0C17 11            mov a, b
1514   0C18 FA 05 00      lea d, [bp + 5] ; $num
1515   0C1B 2A            mov b, [d]
1516   0C1C             ; START FACTORS
1517   0C1C D7            push a
1518   0C1D 11            mov a, b
1519   0C1E 26 0A 00      mov b, $a
1520   0C21 AE            div a, b ; 
1521   0C22 11            mov a, b
1522   0C23 27            mov b, a
1523   0C24 E4            pop a
1524   0C25             ; END FACTORS
1525   0C25 54            add a, b
1526   0C26 27            mov b, a
1527   0C27 E4            pop a
1528   0C28             ; END TERMS
1529   0C28 E7            pop d
1530   0C29 FD 3E         mov [d], bl
1531   0C2B             ;; num = num / 10; 
1532   0C2B FA 05 00      lea d, [bp + 5] ; $num
1533   0C2E DA            push d
1534   0C2F FA 05 00      lea d, [bp + 5] ; $num
1535   0C32 2A            mov b, [d]
1536   0C33             ; START FACTORS
1537   0C33 D7            push a
1538   0C34 11            mov a, b
1539   0C35 26 0A 00      mov b, $a
1540   0C38 AE            div a, b
1541   0C39 27            mov b, a
1542   0C3A E4            pop a
1543   0C3B             ; END FACTORS
1544   0C3B E7            pop d
1545   0C3C FD 43         mov [d], b
1546   0C3E             ;; i++; 
1547   0C3E FA FA FF      lea d, [bp + -6] ; $i
1548   0C41 2A            mov b, [d]
1549   0C42 D8            push b
1550   0C43 FD 77         inc b
1551   0C45 FA FA FF      lea d, [bp + -6] ; $i
1552   0C48 FD 43         mov [d], b
1553   0C4A E5            pop b
1554   0C4B 0A F3 0B      jmp _while21_cond
1555   0C4E             _while21_exit:
1556   0C4E             ;; while (i > 0) { 
1557   0C4E             _while22_cond:
1558   0C4E FA FA FF      lea d, [bp + -6] ; $i
1559   0C51 2A            mov b, [d]
1560   0C52             ; START RELATIONAL
1561   0C52 D7            push a
1562   0C53 11            mov a, b
1563   0C54 26 00 00      mov b, $0
1564   0C57 B0            cmp a, b
1565   0C58 FD 7F         sgt ; >
1566   0C5A E4            pop a
1567   0C5B             ; END RELATIONAL
1568   0C5B C0 00 00      cmp b, 0
1569   0C5E C6 87 0C      je _while22_exit
1570   0C61             _while22_block:
1571   0C61             ;; i--; 
1572   0C61 FA FA FF      lea d, [bp + -6] ; $i
1573   0C64 2A            mov b, [d]
1574   0C65 D8            push b
1575   0C66 FD 7D         dec b
1576   0C68 FA FA FF      lea d, [bp + -6] ; $i
1577   0C6B FD 43         mov [d], b
1578   0C6D E5            pop b
1579   0C6E             ;; putchar(digits[i]); 
1580   0C6E FA FC FF      lea d, [bp + -4] ; $digits
1581   0C71 D7            push a
1582   0C72 DA            push d
1583   0C73 FA FA FF      lea d, [bp + -6] ; $i
1584   0C76 2A            mov b, [d]
1585   0C77 E7            pop d
1586   0C78 5A            add d, b
1587   0C79 E4            pop a
1588   0C7A 32            mov bl, [d]
1589   0C7B A7 00         mov bh, 0
1590   0C7D DD            push bl
1591   0C7E 07 B4 0F      call putchar
1592   0C81 51 01 00      add sp, 1
1593   0C84 0A 4E 0C      jmp _while22_cond
1594   0C87             _while22_exit:
1595   0C87 F9            leave
1596   0C88 09            ret
1597   0C89             
1598   0C89             print_signed_long:
1599   0C89 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1600   0C8C             ; $digits 
1601   0C8C             ; $i 
1602   0C8C 10 00 00      mov a, $0
1603   0C8F 45 F5 FF      mov [bp + -11], a
1604   0C92 52 0C 00      sub sp, 12
1605   0C95             ;; if (num < 0) { 
1606   0C95             _if23_cond:
1607   0C95 FA 05 00      lea d, [bp + 5] ; $num
1608   0C98 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1609   0C9B FD 39         mov c, b ; And place it into C
1610   0C9D 2A            mov b, [d] ; Lower Word in B
1611   0C9E             ; START RELATIONAL
1612   0C9E D7            push a
1613   0C9F FD D8         push g
1614   0CA1 11            mov a, b
1615   0CA2 FD 7A         mov g, c
1616   0CA4 26 00 00      mov b, $0
1617   0CA7 4D            mov si, a
1618   0CA8 11            mov a, b
1619   0CA9 4F            mov di, a
1620   0CAA FD 12         mov a, g
1621   0CAC 28            mov b, c
1622   0CAD B0            cmp a, b
1623   0CAE FD 75         slu ; <
1624   0CB0 D8            push b
1625   0CB1 28            mov b, c
1626   0CB2 FD 71         seq ; ==
1627   0CB4 D8            push b
1628   0CB5 50            mov a, di
1629   0CB6 27            mov b, a
1630   0CB7 4E            mov a, si
1631   0CB8 B0            cmp a, b
1632   0CB9 FD 75         slu ; <
1633   0CBB E4            pop a
1634   0CBC FD 92         and b, a
1635   0CBE E4            pop a
1636   0CBF FD 70         or b, a
1637   0CC1               
1638   0CC1 FD F1         pop g
1639   0CC3 E4            pop a
1640   0CC4             ; END RELATIONAL
1641   0CC4 C0 00 00      cmp b, 0
1642   0CC7 C6 EE 0C      je _if23_else
1643   0CCA             _if23_true:
1644   0CCA             ;; putchar('-'); 
1645   0CCA 26 2D 00      mov b, $2d
1646   0CCD DD            push bl
1647   0CCE 07 B4 0F      call putchar
1648   0CD1 51 01 00      add sp, 1
1649   0CD4             ;; num = -num; 
1650   0CD4 FA 05 00      lea d, [bp + 5] ; $num
1651   0CD7 DA            push d
1652   0CD8 FA 05 00      lea d, [bp + 5] ; $num
1653   0CDB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1654   0CDE FD 39         mov c, b ; And place it into C
1655   0CE0 2A            mov b, [d] ; Lower Word in B
1656   0CE1 FD 97         neg b
1657   0CE3 E7            pop d
1658   0CE4 FD 43         mov [d], b
1659   0CE6 28            mov b, c
1660   0CE7 FD 44 02 00   mov [d + 2], b
1661   0CEB 0A 25 0D      jmp _if23_exit
1662   0CEE             _if23_else:
1663   0CEE             ;; if (num == 0) { 
1664   0CEE             _if24_cond:
1665   0CEE FA 05 00      lea d, [bp + 5] ; $num
1666   0CF1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1667   0CF4 FD 39         mov c, b ; And place it into C
1668   0CF6 2A            mov b, [d] ; Lower Word in B
1669   0CF7             ; START RELATIONAL
1670   0CF7 D7            push a
1671   0CF8 FD D8         push g
1672   0CFA 11            mov a, b
1673   0CFB FD 7A         mov g, c
1674   0CFD 26 00 00      mov b, $0
1675   0D00 B0            cmp a, b
1676   0D01 FD 71         seq ; ==
1677   0D03 D8            push b
1678   0D04 12            mov a, c
1679   0D05 FD 27         mov b, g
1680   0D07 B0            cmp a, b
1681   0D08 FD 71         seq ; ==
1682   0D0A E4            pop a
1683   0D0B FD A7         sand a, b
1684   0D0D FD F1         pop g
1685   0D0F E4            pop a
1686   0D10             ; END RELATIONAL
1687   0D10 C0 00 00      cmp b, 0
1688   0D13 C6 25 0D      je _if24_exit
1689   0D16             _if24_true:
1690   0D16             ;; putchar('0'); 
1691   0D16 26 30 00      mov b, $30
1692   0D19 DD            push bl
1693   0D1A 07 B4 0F      call putchar
1694   0D1D 51 01 00      add sp, 1
1695   0D20             ;; return; 
1696   0D20 F9            leave
1697   0D21 09            ret
1698   0D22 0A 25 0D      jmp _if24_exit
1699   0D25             _if24_exit:
1700   0D25             _if23_exit:
1701   0D25             ;; while (num > 0) { 
1702   0D25             _while25_cond:
1703   0D25 FA 05 00      lea d, [bp + 5] ; $num
1704   0D28 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1705   0D2B FD 39         mov c, b ; And place it into C
1706   0D2D 2A            mov b, [d] ; Lower Word in B
1707   0D2E             ; START RELATIONAL
1708   0D2E D7            push a
1709   0D2F FD D8         push g
1710   0D31 11            mov a, b
1711   0D32 FD 7A         mov g, c
1712   0D34 26 00 00      mov b, $0
1713   0D37 B0            cmp a, b
1714   0D38 FD 7F         sgt ; >
1715   0D3A FD F1         pop g
1716   0D3C E4            pop a
1717   0D3D             ; END RELATIONAL
1718   0D3D C0 00 00      cmp b, 0
1719   0D40 C6 9A 0D      je _while25_exit
1720   0D43             _while25_block:
1721   0D43             ;; digits[i] = '0' + (num % 10); 
1722   0D43 FA F7 FF      lea d, [bp + -9] ; $digits
1723   0D46 D7            push a
1724   0D47 DA            push d
1725   0D48 FA F5 FF      lea d, [bp + -11] ; $i
1726   0D4B 2A            mov b, [d]
1727   0D4C E7            pop d
1728   0D4D 5A            add d, b
1729   0D4E E4            pop a
1730   0D4F DA            push d
1731   0D50 26 30 00      mov b, $30
1732   0D53             ; START TERMS
1733   0D53 D7            push a
1734   0D54 11            mov a, b
1735   0D55 FA 05 00      lea d, [bp + 5] ; $num
1736   0D58 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1737   0D5B FD 39         mov c, b ; And place it into C
1738   0D5D 2A            mov b, [d] ; Lower Word in B
1739   0D5E             ; START FACTORS
1740   0D5E D7            push a
1741   0D5F 11            mov a, b
1742   0D60 26 0A 00      mov b, $a
1743   0D63 AE            div a, b ; 
1744   0D64 11            mov a, b
1745   0D65 27            mov b, a
1746   0D66 E4            pop a
1747   0D67             ; END FACTORS
1748   0D67 54            add a, b
1749   0D68 27            mov b, a
1750   0D69 E4            pop a
1751   0D6A             ; END TERMS
1752   0D6A E7            pop d
1753   0D6B FD 3E         mov [d], bl
1754   0D6D             ;; num = num / 10; 
1755   0D6D FA 05 00      lea d, [bp + 5] ; $num
1756   0D70 DA            push d
1757   0D71 FA 05 00      lea d, [bp + 5] ; $num
1758   0D74 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1759   0D77 FD 39         mov c, b ; And place it into C
1760   0D79 2A            mov b, [d] ; Lower Word in B
1761   0D7A             ; START FACTORS
1762   0D7A D7            push a
1763   0D7B 11            mov a, b
1764   0D7C 26 0A 00      mov b, $a
1765   0D7F AE            div a, b
1766   0D80 27            mov b, a
1767   0D81 E4            pop a
1768   0D82             ; END FACTORS
1769   0D82 E7            pop d
1770   0D83 FD 43         mov [d], b
1771   0D85 28            mov b, c
1772   0D86 FD 44 02 00   mov [d + 2], b
1773   0D8A             ;; i++; 
1774   0D8A FA F5 FF      lea d, [bp + -11] ; $i
1775   0D8D 2A            mov b, [d]
1776   0D8E D8            push b
1777   0D8F FD 77         inc b
1778   0D91 FA F5 FF      lea d, [bp + -11] ; $i
1779   0D94 FD 43         mov [d], b
1780   0D96 E5            pop b
1781   0D97 0A 25 0D      jmp _while25_cond
1782   0D9A             _while25_exit:
1783   0D9A             ;; while (i > 0) { 
1784   0D9A             _while26_cond:
1785   0D9A FA F5 FF      lea d, [bp + -11] ; $i
1786   0D9D 2A            mov b, [d]
1787   0D9E             ; START RELATIONAL
1788   0D9E D7            push a
1789   0D9F 11            mov a, b
1790   0DA0 26 00 00      mov b, $0
1791   0DA3 B0            cmp a, b
1792   0DA4 FD 7F         sgt ; >
1793   0DA6 E4            pop a
1794   0DA7             ; END RELATIONAL
1795   0DA7 C0 00 00      cmp b, 0
1796   0DAA C6 D3 0D      je _while26_exit
1797   0DAD             _while26_block:
1798   0DAD             ;; i--; 
1799   0DAD FA F5 FF      lea d, [bp + -11] ; $i
1800   0DB0 2A            mov b, [d]
1801   0DB1 D8            push b
1802   0DB2 FD 7D         dec b
1803   0DB4 FA F5 FF      lea d, [bp + -11] ; $i
1804   0DB7 FD 43         mov [d], b
1805   0DB9 E5            pop b
1806   0DBA             ;; putchar(digits[i]); 
1807   0DBA FA F7 FF      lea d, [bp + -9] ; $digits
1808   0DBD D7            push a
1809   0DBE DA            push d
1810   0DBF FA F5 FF      lea d, [bp + -11] ; $i
1811   0DC2 2A            mov b, [d]
1812   0DC3 E7            pop d
1813   0DC4 5A            add d, b
1814   0DC5 E4            pop a
1815   0DC6 32            mov bl, [d]
1816   0DC7 A7 00         mov bh, 0
1817   0DC9 DD            push bl
1818   0DCA 07 B4 0F      call putchar
1819   0DCD 51 01 00      add sp, 1
1820   0DD0 0A 9A 0D      jmp _while26_cond
1821   0DD3             _while26_exit:
1822   0DD3 F9            leave
1823   0DD4 09            ret
1824   0DD5             
1825   0DD5             print_unsigned_long:
1826   0DD5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1827   0DD8             ; $digits 
1828   0DD8             ; $i 
1829   0DD8 52 0C 00      sub sp, 12
1830   0DDB             ;; i = 0; 
1831   0DDB FA F5 FF      lea d, [bp + -11] ; $i
1832   0DDE DA            push d
1833   0DDF 26 00 00      mov b, $0
1834   0DE2 E7            pop d
1835   0DE3 FD 43         mov [d], b
1836   0DE5             ;; if(num == 0){ 
1837   0DE5             _if27_cond:
1838   0DE5 FA 05 00      lea d, [bp + 5] ; $num
1839   0DE8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1840   0DEB FD 39         mov c, b ; And place it into C
1841   0DED 2A            mov b, [d] ; Lower Word in B
1842   0DEE             ; START RELATIONAL
1843   0DEE D7            push a
1844   0DEF FD D8         push g
1845   0DF1 11            mov a, b
1846   0DF2 FD 7A         mov g, c
1847   0DF4 26 00 00      mov b, $0
1848   0DF7 B0            cmp a, b
1849   0DF8 FD 71         seq ; ==
1850   0DFA D8            push b
1851   0DFB 12            mov a, c
1852   0DFC FD 27         mov b, g
1853   0DFE B0            cmp a, b
1854   0DFF FD 71         seq ; ==
1855   0E01 E4            pop a
1856   0E02 FD A7         sand a, b
1857   0E04 FD F1         pop g
1858   0E06 E4            pop a
1859   0E07             ; END RELATIONAL
1860   0E07 C0 00 00      cmp b, 0
1861   0E0A C6 1C 0E      je _if27_exit
1862   0E0D             _if27_true:
1863   0E0D             ;; putchar('0'); 
1864   0E0D 26 30 00      mov b, $30
1865   0E10 DD            push bl
1866   0E11 07 B4 0F      call putchar
1867   0E14 51 01 00      add sp, 1
1868   0E17             ;; return; 
1869   0E17 F9            leave
1870   0E18 09            ret
1871   0E19 0A 1C 0E      jmp _if27_exit
1872   0E1C             _if27_exit:
1873   0E1C             ;; while (num > 0) { 
1874   0E1C             _while28_cond:
1875   0E1C FA 05 00      lea d, [bp + 5] ; $num
1876   0E1F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1877   0E22 FD 39         mov c, b ; And place it into C
1878   0E24 2A            mov b, [d] ; Lower Word in B
1879   0E25             ; START RELATIONAL
1880   0E25 D7            push a
1881   0E26 FD D8         push g
1882   0E28 11            mov a, b
1883   0E29 FD 7A         mov g, c
1884   0E2B 26 00 00      mov b, $0
1885   0E2E B0            cmp a, b
1886   0E2F FD 81         sgu ; > (unsigned)
1887   0E31 FD F1         pop g
1888   0E33 E4            pop a
1889   0E34             ; END RELATIONAL
1890   0E34 C0 00 00      cmp b, 0
1891   0E37 C6 91 0E      je _while28_exit
1892   0E3A             _while28_block:
1893   0E3A             ;; digits[i] = '0' + (num % 10); 
1894   0E3A FA F7 FF      lea d, [bp + -9] ; $digits
1895   0E3D D7            push a
1896   0E3E DA            push d
1897   0E3F FA F5 FF      lea d, [bp + -11] ; $i
1898   0E42 2A            mov b, [d]
1899   0E43 E7            pop d
1900   0E44 5A            add d, b
1901   0E45 E4            pop a
1902   0E46 DA            push d
1903   0E47 26 30 00      mov b, $30
1904   0E4A             ; START TERMS
1905   0E4A D7            push a
1906   0E4B 11            mov a, b
1907   0E4C FA 05 00      lea d, [bp + 5] ; $num
1908   0E4F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1909   0E52 FD 39         mov c, b ; And place it into C
1910   0E54 2A            mov b, [d] ; Lower Word in B
1911   0E55             ; START FACTORS
1912   0E55 D7            push a
1913   0E56 11            mov a, b
1914   0E57 26 0A 00      mov b, $a
1915   0E5A AE            div a, b ; 
1916   0E5B 11            mov a, b
1917   0E5C 27            mov b, a
1918   0E5D E4            pop a
1919   0E5E             ; END FACTORS
1920   0E5E 54            add a, b
1921   0E5F 27            mov b, a
1922   0E60 E4            pop a
1923   0E61             ; END TERMS
1924   0E61 E7            pop d
1925   0E62 FD 3E         mov [d], bl
1926   0E64             ;; num = num / 10; 
1927   0E64 FA 05 00      lea d, [bp + 5] ; $num
1928   0E67 DA            push d
1929   0E68 FA 05 00      lea d, [bp + 5] ; $num
1930   0E6B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1931   0E6E FD 39         mov c, b ; And place it into C
1932   0E70 2A            mov b, [d] ; Lower Word in B
1933   0E71             ; START FACTORS
1934   0E71 D7            push a
1935   0E72 11            mov a, b
1936   0E73 26 0A 00      mov b, $a
1937   0E76 AE            div a, b
1938   0E77 27            mov b, a
1939   0E78 E4            pop a
1940   0E79             ; END FACTORS
1941   0E79 E7            pop d
1942   0E7A FD 43         mov [d], b
1943   0E7C 28            mov b, c
1944   0E7D FD 44 02 00   mov [d + 2], b
1945   0E81             ;; i++; 
1946   0E81 FA F5 FF      lea d, [bp + -11] ; $i
1947   0E84 2A            mov b, [d]
1948   0E85 D8            push b
1949   0E86 FD 77         inc b
1950   0E88 FA F5 FF      lea d, [bp + -11] ; $i
1951   0E8B FD 43         mov [d], b
1952   0E8D E5            pop b
1953   0E8E 0A 1C 0E      jmp _while28_cond
1954   0E91             _while28_exit:
1955   0E91             ;; while (i > 0) { 
1956   0E91             _while29_cond:
1957   0E91 FA F5 FF      lea d, [bp + -11] ; $i
1958   0E94 2A            mov b, [d]
1959   0E95             ; START RELATIONAL
1960   0E95 D7            push a
1961   0E96 11            mov a, b
1962   0E97 26 00 00      mov b, $0
1963   0E9A B0            cmp a, b
1964   0E9B FD 7F         sgt ; >
1965   0E9D E4            pop a
1966   0E9E             ; END RELATIONAL
1967   0E9E C0 00 00      cmp b, 0
1968   0EA1 C6 CA 0E      je _while29_exit
1969   0EA4             _while29_block:
1970   0EA4             ;; i--; 
1971   0EA4 FA F5 FF      lea d, [bp + -11] ; $i
1972   0EA7 2A            mov b, [d]
1973   0EA8 D8            push b
1974   0EA9 FD 7D         dec b
1975   0EAB FA F5 FF      lea d, [bp + -11] ; $i
1976   0EAE FD 43         mov [d], b
1977   0EB0 E5            pop b
1978   0EB1             ;; putchar(digits[i]); 
1979   0EB1 FA F7 FF      lea d, [bp + -9] ; $digits
1980   0EB4 D7            push a
1981   0EB5 DA            push d
1982   0EB6 FA F5 FF      lea d, [bp + -11] ; $i
1983   0EB9 2A            mov b, [d]
1984   0EBA E7            pop d
1985   0EBB 5A            add d, b
1986   0EBC E4            pop a
1987   0EBD 32            mov bl, [d]
1988   0EBE A7 00         mov bh, 0
1989   0EC0 DD            push bl
1990   0EC1 07 B4 0F      call putchar
1991   0EC4 51 01 00      add sp, 1
1992   0EC7 0A 91 0E      jmp _while29_cond
1993   0ECA             _while29_exit:
1994   0ECA F9            leave
1995   0ECB 09            ret
1996   0ECC             
1997   0ECC             print_unsigned:
1998   0ECC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1999   0ECF             ; $digits 
2000   0ECF             ; $i 
2001   0ECF 52 07 00      sub sp, 7
2002   0ED2             ;; i = 0; 
2003   0ED2 FA FA FF      lea d, [bp + -6] ; $i
2004   0ED5 DA            push d
2005   0ED6 26 00 00      mov b, $0
2006   0ED9 E7            pop d
2007   0EDA FD 43         mov [d], b
2008   0EDC             ;; if(num == 0){ 
2009   0EDC             _if30_cond:
2010   0EDC FA 05 00      lea d, [bp + 5] ; $num
2011   0EDF 2A            mov b, [d]
2012   0EE0             ; START RELATIONAL
2013   0EE0 D7            push a
2014   0EE1 11            mov a, b
2015   0EE2 26 00 00      mov b, $0
2016   0EE5 B0            cmp a, b
2017   0EE6 FD 71         seq ; ==
2018   0EE8 E4            pop a
2019   0EE9             ; END RELATIONAL
2020   0EE9 C0 00 00      cmp b, 0
2021   0EEC C6 FE 0E      je _if30_exit
2022   0EEF             _if30_true:
2023   0EEF             ;; putchar('0'); 
2024   0EEF 26 30 00      mov b, $30
2025   0EF2 DD            push bl
2026   0EF3 07 B4 0F      call putchar
2027   0EF6 51 01 00      add sp, 1
2028   0EF9             ;; return; 
2029   0EF9 F9            leave
2030   0EFA 09            ret
2031   0EFB 0A FE 0E      jmp _if30_exit
2032   0EFE             _if30_exit:
2033   0EFE             ;; while (num > 0) { 
2034   0EFE             _while31_cond:
2035   0EFE FA 05 00      lea d, [bp + 5] ; $num
2036   0F01 2A            mov b, [d]
2037   0F02             ; START RELATIONAL
2038   0F02 D7            push a
2039   0F03 11            mov a, b
2040   0F04 26 00 00      mov b, $0
2041   0F07 B0            cmp a, b
2042   0F08 FD 81         sgu ; > (unsigned)
2043   0F0A E4            pop a
2044   0F0B             ; END RELATIONAL
2045   0F0B C0 00 00      cmp b, 0
2046   0F0E C6 59 0F      je _while31_exit
2047   0F11             _while31_block:
2048   0F11             ;; digits[i] = '0' + (num % 10); 
2049   0F11 FA FC FF      lea d, [bp + -4] ; $digits
2050   0F14 D7            push a
2051   0F15 DA            push d
2052   0F16 FA FA FF      lea d, [bp + -6] ; $i
2053   0F19 2A            mov b, [d]
2054   0F1A E7            pop d
2055   0F1B 5A            add d, b
2056   0F1C E4            pop a
2057   0F1D DA            push d
2058   0F1E 26 30 00      mov b, $30
2059   0F21             ; START TERMS
2060   0F21 D7            push a
2061   0F22 11            mov a, b
2062   0F23 FA 05 00      lea d, [bp + 5] ; $num
2063   0F26 2A            mov b, [d]
2064   0F27             ; START FACTORS
2065   0F27 D7            push a
2066   0F28 11            mov a, b
2067   0F29 26 0A 00      mov b, $a
2068   0F2C AE            div a, b ; 
2069   0F2D 11            mov a, b
2070   0F2E 27            mov b, a
2071   0F2F E4            pop a
2072   0F30             ; END FACTORS
2073   0F30 54            add a, b
2074   0F31 27            mov b, a
2075   0F32 E4            pop a
2076   0F33             ; END TERMS
2077   0F33 E7            pop d
2078   0F34 FD 3E         mov [d], bl
2079   0F36             ;; num = num / 10; 
2080   0F36 FA 05 00      lea d, [bp + 5] ; $num
2081   0F39 DA            push d
2082   0F3A FA 05 00      lea d, [bp + 5] ; $num
2083   0F3D 2A            mov b, [d]
2084   0F3E             ; START FACTORS
2085   0F3E D7            push a
2086   0F3F 11            mov a, b
2087   0F40 26 0A 00      mov b, $a
2088   0F43 AE            div a, b
2089   0F44 27            mov b, a
2090   0F45 E4            pop a
2091   0F46             ; END FACTORS
2092   0F46 E7            pop d
2093   0F47 FD 43         mov [d], b
2094   0F49             ;; i++; 
2095   0F49 FA FA FF      lea d, [bp + -6] ; $i
2096   0F4C 2A            mov b, [d]
2097   0F4D D8            push b
2098   0F4E FD 77         inc b
2099   0F50 FA FA FF      lea d, [bp + -6] ; $i
2100   0F53 FD 43         mov [d], b
2101   0F55 E5            pop b
2102   0F56 0A FE 0E      jmp _while31_cond
2103   0F59             _while31_exit:
2104   0F59             ;; while (i > 0) { 
2105   0F59             _while32_cond:
2106   0F59 FA FA FF      lea d, [bp + -6] ; $i
2107   0F5C 2A            mov b, [d]
2108   0F5D             ; START RELATIONAL
2109   0F5D D7            push a
2110   0F5E 11            mov a, b
2111   0F5F 26 00 00      mov b, $0
2112   0F62 B0            cmp a, b
2113   0F63 FD 7F         sgt ; >
2114   0F65 E4            pop a
2115   0F66             ; END RELATIONAL
2116   0F66 C0 00 00      cmp b, 0
2117   0F69 C6 92 0F      je _while32_exit
2118   0F6C             _while32_block:
2119   0F6C             ;; i--; 
2120   0F6C FA FA FF      lea d, [bp + -6] ; $i
2121   0F6F 2A            mov b, [d]
2122   0F70 D8            push b
2123   0F71 FD 7D         dec b
2124   0F73 FA FA FF      lea d, [bp + -6] ; $i
2125   0F76 FD 43         mov [d], b
2126   0F78 E5            pop b
2127   0F79             ;; putchar(digits[i]); 
2128   0F79 FA FC FF      lea d, [bp + -4] ; $digits
2129   0F7C D7            push a
2130   0F7D DA            push d
2131   0F7E FA FA FF      lea d, [bp + -6] ; $i
2132   0F81 2A            mov b, [d]
2133   0F82 E7            pop d
2134   0F83 5A            add d, b
2135   0F84 E4            pop a
2136   0F85 32            mov bl, [d]
2137   0F86 A7 00         mov bh, 0
2138   0F88 DD            push bl
2139   0F89 07 B4 0F      call putchar
2140   0F8C 51 01 00      add sp, 1
2141   0F8F 0A 59 0F      jmp _while32_cond
2142   0F92             _while32_exit:
2143   0F92 F9            leave
2144   0F93 09            ret
2145   0F94             
2146   0F94             rand:
2147   0F94 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2148   0F97             ; $sec 
2149   0F97 52 01 00      sub sp, 1
2150   0F9A             
2151   0F9A             ; --- BEGIN INLINE ASM BLOCK
2152   0F9A 19 00         mov al, 0
2153   0F9C 05 01         syscall sys_rtc					
2154   0F9E 1A            mov al, ah
2155   0F9F FA 00 00      lea d, [bp + 0] ; $sec
2156   0FA2 1E            mov al, [d]
2157   0FA3             ; --- END INLINE ASM BLOCK
2158   0FA3             
2159   0FA3             ;; return sec; 
2160   0FA3 FA 00 00      lea d, [bp + 0] ; $sec
2161   0FA6 32            mov bl, [d]
2162   0FA7 A7 00         mov bh, 0
2163   0FA9 F9            leave
2164   0FAA 09            ret
2165   0FAB             
2166   0FAB             date:
2167   0FAB F8 00 00      enter 0 ; (push bp; mov bp, sp)
2168   0FAE             
2169   0FAE             ; --- BEGIN INLINE ASM BLOCK
2170   0FAE 19 00         mov al, 0 
2171   0FB0 05 07         syscall sys_datetime
2172   0FB2             ; --- END INLINE ASM BLOCK
2173   0FB2             
2174   0FB2 F9            leave
2175   0FB3 09            ret
2176   0FB4             
2177   0FB4             putchar:
2178   0FB4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2179   0FB7             
2180   0FB7             ; --- BEGIN INLINE ASM BLOCK
2181   0FB7 FA 05 00      lea d, [bp + 5] ; $c
2182   0FBA 1E            mov al, [d]
2183   0FBB 23            mov ah, al
2184   0FBC 07 DB 11      call _putchar
2185   0FBF             ; --- END INLINE ASM BLOCK
2186   0FBF             
2187   0FBF F9            leave
2188   0FC0 09            ret
2189   0FC1             
2190   0FC1             getchar:
2191   0FC1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2192   0FC4             ; $c 
2193   0FC4 52 01 00      sub sp, 1
2194   0FC7             
2195   0FC7             ; --- BEGIN INLINE ASM BLOCK
2196   0FC7 07 D4 11      call getch
2197   0FCA 1A            mov al, ah
2198   0FCB FA 00 00      lea d, [bp + 0] ; $c
2199   0FCE 3E            mov [d], al
2200   0FCF             ; --- END INLINE ASM BLOCK
2201   0FCF             
2202   0FCF             ;; return c; 
2203   0FCF FA 00 00      lea d, [bp + 0] ; $c
2204   0FD2 32            mov bl, [d]
2205   0FD3 A7 00         mov bh, 0
2206   0FD5 F9            leave
2207   0FD6 09            ret
2208   0FD7             
2209   0FD7             scann:
2210   0FD7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2211   0FDA             ; $m 
2212   0FDA 52 02 00      sub sp, 2
2213   0FDD             
2214   0FDD             ; --- BEGIN INLINE ASM BLOCK
2215   0FDD 07 1F 14      call scan_u16d
2216   0FE0 FA FF FF      lea d, [bp + -1] ; $m
2217   0FE3 43            mov [d], a
2218   0FE4             ; --- END INLINE ASM BLOCK
2219   0FE4             
2220   0FE4             ;; return m; 
2221   0FE4 FA FF FF      lea d, [bp + -1] ; $m
2222   0FE7 2A            mov b, [d]
2223   0FE8 F9            leave
2224   0FE9 09            ret
2225   0FEA             
2226   0FEA             puts:
2227   0FEA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2228   0FED             
2229   0FED             ; --- BEGIN INLINE ASM BLOCK
2230   0FED FA 05 00      lea d, [bp + 5] ; $s
2231   0FF0 15            mov a, [d]
2232   0FF1 3C            mov d, a
2233   0FF2 07 25 13      call _puts
2234   0FF5 10 00 0A      mov a, $0A00
2235   0FF8 05 03         syscall sys_io
2236   0FFA             ; --- END INLINE ASM BLOCK
2237   0FFA             
2238   0FFA F9            leave
2239   0FFB 09            ret
2240   0FFC             
2241   0FFC             print:
2242   0FFC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2243   0FFF             
2244   0FFF             ; --- BEGIN INLINE ASM BLOCK
2245   0FFF FA 05 00      lea d, [bp + 5] ; $s
2246   1002 FD 2A         mov d, [d]
2247   1004 07 25 13      call _puts
2248   1007             ; --- END INLINE ASM BLOCK
2249   1007             
2250   1007 F9            leave
2251   1008 09            ret
2252   1009             
2253   1009             loadfile:
2254   1009 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2255   100C             
2256   100C             ; --- BEGIN INLINE ASM BLOCK
2257   100C FA 07 00      lea d, [bp + 7] ; $destination
2258   100F 15            mov a, [d]
2259   1010 4F            mov di, a
2260   1011 FA 05 00      lea d, [bp + 5] ; $filename
2261   1014 FD 2A         mov d, [d]
2262   1016 19 14         mov al, 20
2263   1018 05 04         syscall sys_filesystem
2264   101A             ; --- END INLINE ASM BLOCK
2265   101A             
2266   101A F9            leave
2267   101B 09            ret
2268   101C             
2269   101C             create_file:
2270   101C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2271   101F F9            leave
2272   1020 09            ret
2273   1021             
2274   1021             delete_file:
2275   1021 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2276   1024             
2277   1024             ; --- BEGIN INLINE ASM BLOCK
2278   1024 FA 05 00      lea d, [bp + 5] ; $filename
2279   1027 19 0A         mov al, 10
2280   1029 05 04         syscall sys_filesystem
2281   102B             ; --- END INLINE ASM BLOCK
2282   102B             
2283   102B F9            leave
2284   102C 09            ret
2285   102D             
2286   102D             fopen:
2287   102D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2288   1030 F9            leave
2289   1031 09            ret
2290   1032             
2291   1032             fclose:
2292   1032 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2293   1035 F9            leave
2294   1036 09            ret
2295   1037             
2296   1037             alloc:
2297   1037 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2298   103A             ;; heap_top = heap_top + bytes; 
2299   103A 3B D0 14      mov d, _heap_top ; $heap_top
2300   103D DA            push d
2301   103E 3B D0 14      mov d, _heap_top ; $heap_top
2302   1041 2A            mov b, [d]
2303   1042             ; START TERMS
2304   1042 D7            push a
2305   1043 11            mov a, b
2306   1044 FA 05 00      lea d, [bp + 5] ; $bytes
2307   1047 2A            mov b, [d]
2308   1048 54            add a, b
2309   1049 27            mov b, a
2310   104A E4            pop a
2311   104B             ; END TERMS
2312   104B E7            pop d
2313   104C FD 43         mov [d], b
2314   104E             ;; return heap_top - bytes; 
2315   104E 3B D0 14      mov d, _heap_top ; $heap_top
2316   1051 2A            mov b, [d]
2317   1052             ; START TERMS
2318   1052 D7            push a
2319   1053 11            mov a, b
2320   1054 FA 05 00      lea d, [bp + 5] ; $bytes
2321   1057 2A            mov b, [d]
2322   1058 60            sub a, b
2323   1059 27            mov b, a
2324   105A E4            pop a
2325   105B             ; END TERMS
2326   105B F9            leave
2327   105C 09            ret
2328   105D             
2329   105D             free:
2330   105D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2331   1060             ;; return heap_top = heap_top - bytes; 
2332   1060 3B D0 14      mov d, _heap_top ; $heap_top
2333   1063 DA            push d
2334   1064 3B D0 14      mov d, _heap_top ; $heap_top
2335   1067 2A            mov b, [d]
2336   1068             ; START TERMS
2337   1068 D7            push a
2338   1069 11            mov a, b
2339   106A FA 05 00      lea d, [bp + 5] ; $bytes
2340   106D 2A            mov b, [d]
2341   106E 60            sub a, b
2342   106F 27            mov b, a
2343   1070 E4            pop a
2344   1071             ; END TERMS
2345   1071 E7            pop d
2346   1072 FD 43         mov [d], b
2347   1074 F9            leave
2348   1075 09            ret
2349   1076             
2350   1076             exit:
2351   1076 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2352   1079             
2353   1079             ; --- BEGIN INLINE ASM BLOCK
2354   1079 05 0B         syscall sys_terminate_proc
2355   107B             ; --- END INLINE ASM BLOCK
2356   107B             
2357   107B F9            leave
2358   107C 09            ret
2359   107D             
2360   107D             load_hex:
2361   107D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2362   1080             ; $temp 
2363   1080 52 02 00      sub sp, 2
2364   1083             ;; temp = alloc(32768); 
2365   1083 FA FF FF      lea d, [bp + -1] ; $temp
2366   1086 DA            push d
2367   1087 26 00 80      mov b, $8000
2368   108A FD AB         swp b
2369   108C D8            push b
2370   108D 07 37 10      call alloc
2371   1090 51 02 00      add sp, 2
2372   1093 E7            pop d
2373   1094 FD 43         mov [d], b
2374   1096             
2375   1096             ; --- BEGIN INLINE ASM BLOCK
2376   1096               
2377   1096               
2378   1096               
2379   1096               
2380   1096               
2381   1096             _load_hex:
2382   1096 D7            push a
2383   1097 D8            push b
2384   1098 DA            push d
2385   1099 E2            push si
2386   109A E3            push di
2387   109B 52 00 80      sub sp, $8000      
2388   109E 38 00 00      mov c, 0
2389   10A1 48            mov a, sp
2390   10A2 77            inc a
2391   10A3 3C            mov d, a          
2392   10A4 07 E2 11      call _gets        
2393   10A7 4D            mov si, a
2394   10A8             __load_hex_loop:
2395   10A8 F6            lodsb             
2396   10A9 B9 00         cmp al, 0         
2397   10AB C6 B9 10      jz __load_hex_ret
2398   10AE 36            mov bh, al
2399   10AF F6            lodsb
2400   10B0 2F            mov bl, al
2401   10B1 07 98 11      call _atoi        
2402   10B4 F7            stosb             
2403   10B5 78            inc c
2404   10B6 0A A8 10      jmp __load_hex_loop
2405   10B9             __load_hex_ret:
2406   10B9 51 00 80      add sp, $8000
2407   10BC F0            pop di
2408   10BD EF            pop si
2409   10BE E7            pop d
2410   10BF E5            pop b
2411   10C0 E4            pop a
2412   10C1             ; --- END INLINE ASM BLOCK
2413   10C1             
2414   10C1 F9            leave
2415   10C2 09            ret
2416   10C3             
2417   10C3             getparam:
2418   10C3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2419   10C6             ; $data 
2420   10C6 52 01 00      sub sp, 1
2421   10C9             
2422   10C9             ; --- BEGIN INLINE ASM BLOCK
2423   10C9 19 04         mov al, 4
2424   10CB FA 05 00      lea d, [bp + 5] ; $address
2425   10CE FD 2A         mov d, [d]
2426   10D0 05 0C         syscall sys_system
2427   10D2 FA 00 00      lea d, [bp + 0] ; $data
2428   10D5 FD 3E         mov [d], bl
2429   10D7             ; --- END INLINE ASM BLOCK
2430   10D7             
2431   10D7             ;; return data; 
2432   10D7 FA 00 00      lea d, [bp + 0] ; $data
2433   10DA 32            mov bl, [d]
2434   10DB A7 00         mov bh, 0
2435   10DD F9            leave
2436   10DE 09            ret
2437   10DF             
2438   10DF             clear:
2439   10DF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2440   10E2             ;; print("\033[2J\033[H"); 
2441   10E2 26 C8 14      mov b, __s3 ; "\033[2J\033[H"
2442   10E5 FD AB         swp b
2443   10E7 D8            push b
2444   10E8 07 FC 0F      call print
2445   10EB 51 02 00      add sp, 2
2446   10EE F9            leave
2447   10EF 09            ret
2448   10F0             
2449   10F0             include_stdio_asm:
2450   10F0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2451   10F3             
2452   10F3             ; --- BEGIN INLINE ASM BLOCK
2453   10F3             .include "lib/asm/stdio.asm"
0001+  10F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  10F3             ; stdio.s
0003+  10F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  10F3             .include "lib/asm/string.asm"
0001++ 10F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 10F3             ; string.s
0003++ 10F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 10F3             
0005++ 10F3             
0006++ 10F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 10F3             ; _strrev
0008++ 10F3             ; reverse a string
0009++ 10F3             ; D = string address
0010++ 10F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 10F3             ; 01234
0012++ 10F3             _strrev:
0013++ 10F3 4B          	pusha
0014++ 10F4 07 3A 11    	call _strlen	; length in C
0015++ 10F7 12          	mov a, c
0016++ 10F8 AF 01 00    	cmp a, 1
0017++ 10FB D0 15 11    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 10FE 7D          	dec a
0019++ 10FF FD 4E       	mov si, d	; beginning of string
0020++ 1101 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1103 59          	add d, a	; end of string
0022++ 1104 12          	mov a, c
0023++ 1105 FD 9B       	shr a		; divide by 2
0024++ 1107 39          	mov c, a	; C now counts the steps
0025++ 1108             _strrev_L0:
0026++ 1108 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1109 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 110A 3E          	mov [d], al	; store left char into right side
0029++ 110B 1B          	mov al, bl
0030++ 110C F7          	stosb		; store right-side char into left-side; increase DI
0031++ 110D 7E          	dec c
0032++ 110E 7F          	dec d
0033++ 110F C2 00 00    	cmp c, 0
0034++ 1112 C7 08 11    	jne _strrev_L0
0035++ 1115             _strrev_end:
0036++ 1115 4C          	popa
0037++ 1116 09          	ret
0038++ 1117             	
0039++ 1117             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1117             ; _strchr
0041++ 1117             ; search string in D for char in AL
0042++ 1117             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1117             _strchr:
0044++ 1117             _strchr_L0:
0045++ 1117 32          	mov bl, [d]
0046++ 1118 C1 00       	cmp bl, 0
0047++ 111A C6 25 11    	je _strchr_end
0048++ 111D BA          	cmp al, bl
0049++ 111E C6 25 11    	je _strchr_end
0050++ 1121 79          	inc d
0051++ 1122 0A 17 11    	jmp _strchr_L0
0052++ 1125             _strchr_end:
0053++ 1125 1B          	mov al, bl
0054++ 1126 09          	ret
0055++ 1127             
0056++ 1127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1127             ; _strstr
0058++ 1127             ; find sub-string
0059++ 1127             ; str1 in SI
0060++ 1127             ; str2 in DI
0061++ 1127             ; SI points to end of source string
0062++ 1127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1127             _strstr:
0064++ 1127 DB          	push al
0065++ 1128 DA          	push d
0066++ 1129 E3          	push di
0067++ 112A             _strstr_loop:
0068++ 112A F3          	cmpsb					; compare a byte of the strings
0069++ 112B C7 36 11    	jne _strstr_ret
0070++ 112E FC 00 00    	lea d, [di + 0]
0071++ 1131 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1133 C7 2A 11    	jne _strstr_loop				; equal chars but not at end
0073++ 1136             _strstr_ret:
0074++ 1136 F0          	pop di
0075++ 1137 E7          	pop d
0076++ 1138 E8          	pop al
0077++ 1139 09          	ret
0078++ 113A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 113A             ; length of null terminated string
0080++ 113A             ; result in C
0081++ 113A             ; pointer in D
0082++ 113A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 113A             _strlen:
0084++ 113A DA          	push d
0085++ 113B 38 00 00    	mov c, 0
0086++ 113E             _strlen_L1:
0087++ 113E BD 00       	cmp byte [d], 0
0088++ 1140 C6 48 11    	je _strlen_ret
0089++ 1143 79          	inc d
0090++ 1144 78          	inc c
0091++ 1145 0A 3E 11    	jmp _strlen_L1
0092++ 1148             _strlen_ret:
0093++ 1148 E7          	pop d
0094++ 1149 09          	ret
0095++ 114A             
0096++ 114A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 114A             ; STRCMP
0098++ 114A             ; compare two strings
0099++ 114A             ; str1 in SI
0100++ 114A             ; str2 in DI
0101++ 114A             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 114A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 114A             _strcmp:
0104++ 114A DB          	push al
0105++ 114B DA          	push d
0106++ 114C E3          	push di
0107++ 114D E2          	push si
0108++ 114E             _strcmp_loop:
0109++ 114E F3          	cmpsb					; compare a byte of the strings
0110++ 114F C7 5A 11    	jne _strcmp_ret
0111++ 1152 FB FF FF    	lea d, [si +- 1]
0112++ 1155 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1157 C7 4E 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 115A             _strcmp_ret:
0115++ 115A EF          	pop si
0116++ 115B F0          	pop di
0117++ 115C E7          	pop d
0118++ 115D E8          	pop al
0119++ 115E 09          	ret
0120++ 115F             
0121++ 115F             
0122++ 115F             ; STRCPY
0123++ 115F             ; copy null terminated string from SI to DI
0124++ 115F             ; source in SI
0125++ 115F             ; destination in DI
0126++ 115F             _strcpy:
0127++ 115F E2          	push si
0128++ 1160 E3          	push di
0129++ 1161 DB          	push al
0130++ 1162             _strcpy_L1:
0131++ 1162 F6          	lodsb
0132++ 1163 F7          	stosb
0133++ 1164 B9 00       	cmp al, 0
0134++ 1166 C7 62 11    	jne _strcpy_L1
0135++ 1169             _strcpy_end:
0136++ 1169 E8          	pop al
0137++ 116A F0          	pop di
0138++ 116B EF          	pop si
0139++ 116C 09          	ret
0140++ 116D             
0141++ 116D             ; STRCAT
0142++ 116D             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 116D             ; source in SI
0144++ 116D             ; destination in DI
0145++ 116D             _strcat:
0146++ 116D E2          	push si
0147++ 116E E3          	push di
0148++ 116F D7          	push a
0149++ 1170 DA          	push d
0150++ 1171 50          	mov a, di
0151++ 1172 3C          	mov d, a
0152++ 1173             _strcat_goto_end_L1:
0153++ 1173 BD 00       	cmp byte[d], 0
0154++ 1175 C6 7C 11    	je _strcat_start
0155++ 1178 79          	inc d
0156++ 1179 0A 73 11    	jmp _strcat_goto_end_L1
0157++ 117C             _strcat_start:
0158++ 117C FD 50       	mov di, d
0159++ 117E             _strcat_L1:
0160++ 117E F6          	lodsb
0161++ 117F F7          	stosb
0162++ 1180 B9 00       	cmp al, 0
0163++ 1182 C7 7E 11    	jne _strcat_L1
0164++ 1185             _strcat_end:
0165++ 1185 E7          	pop d
0166++ 1186 E4          	pop a
0167++ 1187 F0          	pop di
0168++ 1188 EF          	pop si
0169++ 1189 09          	ret
0170++ 118A             
0171++ 118A             
0005+  118A             
0006+  118A             
0007+  118A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  118A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  118A             ; ASCII in BL
0010+  118A             ; result in AL
0011+  118A             ; ascii for F = 0100 0110
0012+  118A             ; ascii for 9 = 0011 1001
0013+  118A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  118A             hex_ascii_encode:
0015+  118A 1B            mov al, bl
0016+  118B 93 40         test al, $40        ; test if letter or number
0017+  118D C7 93 11      jnz hex_letter
0018+  1190 87 0F         and al, $0F        ; get number
0019+  1192 09            ret
0020+  1193             hex_letter:
0021+  1193 87 0F         and al, $0F        ; get letter
0022+  1195 6A 09         add al, 9
0023+  1197 09            ret
0024+  1198             
0025+  1198             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1198             ; ATOI
0027+  1198             ; 2 letter hex string in B
0028+  1198             ; 8bit integer returned in AL
0029+  1198             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1198             _atoi:
0031+  1198 D8            push b
0032+  1199 07 8A 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  119C 30            mov bl, bh
0034+  119D DB            push al          ; save a
0035+  119E 07 8A 11      call hex_ascii_encode
0036+  11A1 EA            pop bl  
0037+  11A2 FD 9E 04      shl al, 4
0038+  11A5 8C            or al, bl
0039+  11A6 E5            pop b
0040+  11A7 09            ret  
0041+  11A8             
0042+  11A8             
0043+  11A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  11A8             ; scanf
0045+  11A8             ; no need for explanations!
0046+  11A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  11A8             scanf:
0048+  11A8 09            ret
0049+  11A9             
0050+  11A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  11A9             ; ITOA
0052+  11A9             ; 8bit value in BL
0053+  11A9             ; 2 byte ASCII result in A
0054+  11A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  11A9             _itoa:
0056+  11A9 DA            push d
0057+  11AA D8            push b
0058+  11AB A7 00         mov bh, 0
0059+  11AD FD A4 04      shr bl, 4  
0060+  11B0 74            mov d, b
0061+  11B1 1F 59 14      mov al, [d + s_hex_digits]
0062+  11B4 23            mov ah, al
0063+  11B5               
0064+  11B5 E5            pop b
0065+  11B6 D8            push b
0066+  11B7 A7 00         mov bh, 0
0067+  11B9 FD 87 0F      and bl, $0F
0068+  11BC 74            mov d, b
0069+  11BD 1F 59 14      mov al, [d + s_hex_digits]
0070+  11C0 E5            pop b
0071+  11C1 E7            pop d
0072+  11C2 09            ret
0073+  11C3             
0074+  11C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  11C3             ; HEX STRING TO BINARY
0076+  11C3             ; di = destination address
0077+  11C3             ; si = source
0078+  11C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  11C3             _hex_to_int:
0080+  11C3             _hex_to_int_L1:
0081+  11C3 F6            lodsb          ; load from [SI] to AL
0082+  11C4 B9 00         cmp al, 0        ; check if ASCII 0
0083+  11C6 C6 D3 11      jz _hex_to_int_ret
0084+  11C9 36            mov bh, al
0085+  11CA F6            lodsb
0086+  11CB 2F            mov bl, al
0087+  11CC 07 98 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  11CF F7            stosb          ; store AL to [DI]
0089+  11D0 0A C3 11      jmp _hex_to_int_L1
0090+  11D3             _hex_to_int_ret:
0091+  11D3 09            ret    
0092+  11D4             
0093+  11D4             
0094+  11D4             
0095+  11D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  11D4             ; GETCHAR
0097+  11D4             ; char in ah
0098+  11D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  11D4             getch:
0100+  11D4 DB            push al
0101+  11D5             getch_retry:
0102+  11D5 19 01         mov al, 1
0103+  11D7 05 03         syscall sys_io      ; receive in AH
0104+  11D9 E8            pop al
0105+  11DA 09            ret
0106+  11DB             
0107+  11DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  11DB             ; PUTCHAR
0109+  11DB             ; char in ah
0110+  11DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  11DB             _putchar:
0112+  11DB D7            push a
0113+  11DC 19 00         mov al, 0
0114+  11DE 05 03         syscall sys_io      ; char in AH
0115+  11E0 E4            pop a
0116+  11E1 09            ret
0117+  11E2             
0118+  11E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  11E2             ;; INPUT A STRING
0120+  11E2             ;; terminates with null
0121+  11E2             ;; pointer in D
0122+  11E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  11E2             _gets:
0124+  11E2 D7            push a
0125+  11E3 DA            push d
0126+  11E4             _gets_loop:
0127+  11E4 19 01         mov al, 1
0128+  11E6 05 03         syscall sys_io      ; receive in AH
0129+  11E8 B9 00         cmp al, 0        ; check error code (AL)
0130+  11EA C6 E4 11      je _gets_loop      ; if no char received, retry
0131+  11ED             
0132+  11ED 76 1B         cmp ah, 27
0133+  11EF C6 10 12      je _gets_ansi_esc
0134+  11F2 76 0A         cmp ah, $0A        ; LF
0135+  11F4 C6 7B 12      je _gets_end
0136+  11F7 76 0D         cmp ah, $0D        ; CR
0137+  11F9 C6 7B 12      je _gets_end
0138+  11FC 76 5C         cmp ah, $5C        ; '\\'
0139+  11FE C6 3C 12      je _gets_escape
0140+  1201               
0141+  1201 76 08         cmp ah, $08      ; check for backspace
0142+  1203 C6 0C 12      je _gets_backspace
0143+  1206             
0144+  1206 1A            mov al, ah
0145+  1207 3E            mov [d], al
0146+  1208 79            inc d
0147+  1209 0A E4 11      jmp _gets_loop
0148+  120C             _gets_backspace:
0149+  120C 7F            dec d
0150+  120D 0A E4 11      jmp _gets_loop
0151+  1210             _gets_ansi_esc:
0152+  1210 19 01         mov al, 1
0153+  1212 05 03         syscall sys_io        ; receive in AH without echo
0154+  1214 B9 00         cmp al, 0          ; check error code (AL)
0155+  1216 C6 10 12      je _gets_ansi_esc    ; if no char received, retry
0156+  1219 76 5B         cmp ah, '['
0157+  121B C7 E4 11      jne _gets_loop
0158+  121E             _gets_ansi_esc_2:
0159+  121E 19 01         mov al, 1
0160+  1220 05 03         syscall sys_io          ; receive in AH without echo
0161+  1222 B9 00         cmp al, 0            ; check error code (AL)
0162+  1224 C6 1E 12      je _gets_ansi_esc_2  ; if no char received, retry
0163+  1227 76 44         cmp ah, 'D'
0164+  1229 C6 34 12      je _gets_left_arrow
0165+  122C 76 43         cmp ah, 'C'
0166+  122E C6 38 12      je _gets_right_arrow
0167+  1231 0A E4 11      jmp _gets_loop
0168+  1234             _gets_left_arrow:
0169+  1234 7F            dec d
0170+  1235 0A E4 11      jmp _gets_loop
0171+  1238             _gets_right_arrow:
0172+  1238 79            inc d
0173+  1239 0A E4 11      jmp _gets_loop
0174+  123C             _gets_escape:
0175+  123C 19 01         mov al, 1
0176+  123E 05 03         syscall sys_io      ; receive in AH
0177+  1240 B9 00         cmp al, 0        ; check error code (AL)
0178+  1242 C6 3C 12      je _gets_escape      ; if no char received, retry
0179+  1245 76 6E         cmp ah, 'n'
0180+  1247 C6 66 12      je _gets_LF
0181+  124A 76 72         cmp ah, 'r'
0182+  124C C6 6D 12      je _gets_CR
0183+  124F 76 30         cmp ah, '0'
0184+  1251 C6 74 12      je _gets_NULL
0185+  1254 76 5C         cmp ah, $5C  ; '\'
0186+  1256 C6 5F 12      je _gets_slash
0187+  1259 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  125A 3E            mov [d], al
0189+  125B 79            inc d
0190+  125C 0A E4 11      jmp _gets_loop
0191+  125F             _gets_slash:
0192+  125F 19 5C         mov al, $5C
0193+  1261 3E            mov [d], al
0194+  1262 79            inc d
0195+  1263 0A E4 11      jmp _gets_loop
0196+  1266             _gets_LF:
0197+  1266 19 0A         mov al, $0A
0198+  1268 3E            mov [d], al
0199+  1269 79            inc d
0200+  126A 0A E4 11      jmp _gets_loop
0201+  126D             _gets_CR:
0202+  126D 19 0D         mov al, $0D
0203+  126F 3E            mov [d], al
0204+  1270 79            inc d
0205+  1271 0A E4 11      jmp _gets_loop
0206+  1274             _gets_NULL:
0207+  1274 19 00         mov al, $00
0208+  1276 3E            mov [d], al
0209+  1277 79            inc d
0210+  1278 0A E4 11      jmp _gets_loop
0211+  127B             _gets_end:
0212+  127B 19 00         mov al, 0
0213+  127D 3E            mov [d], al        ; terminate string
0214+  127E E7            pop d
0215+  127F E4            pop a
0216+  1280 09            ret
0217+  1281             
0218+  1281             
0219+  1281             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  1281             ;; INPUT TEXT
0221+  1281             ;; terminated with CTRL+D
0222+  1281             ;; pointer in D
0223+  1281             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  1281             _gettxt:
0225+  1281 D7            push a
0226+  1282 DA            push d
0227+  1283             _gettxt_loop:
0228+  1283 19 01         mov al, 1
0229+  1285 05 03         syscall sys_io      ; receive in AH
0230+  1287 B9 00         cmp al, 0        ; check error code (AL)
0231+  1289 C6 83 12      je _gettxt_loop    ; if no char received, retry
0232+  128C 76 04         cmp ah, 4      ; EOT
0233+  128E C6 CC 12      je _gettxt_end
0234+  1291 76 08         cmp ah, $08      ; check for backspace
0235+  1293 C6 C8 12      je _gettxt_backspace
0236+  1296 76 5C         cmp ah, $5C        ; '\'
0237+  1298 C6 A1 12      je _gettxt_escape
0238+  129B 1A            mov al, ah
0239+  129C 3E            mov [d], al
0240+  129D 79            inc d
0241+  129E 0A 83 12      jmp _gettxt_loop
0242+  12A1             _gettxt_escape:
0243+  12A1 19 01         mov al, 1
0244+  12A3 05 03         syscall sys_io      ; receive in AH
0245+  12A5 B9 00         cmp al, 0        ; check error code (AL)
0246+  12A7 C6 A1 12      je _gettxt_escape    ; if no char received, retry
0247+  12AA 76 6E         cmp ah, 'n'
0248+  12AC C6 BA 12      je _gettxt_LF
0249+  12AF 76 72         cmp ah, 'r'
0250+  12B1 C6 C1 12      je _gettxt_CR
0251+  12B4 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  12B5 3E            mov [d], al
0253+  12B6 79            inc d
0254+  12B7 0A 83 12      jmp _gettxt_loop
0255+  12BA             _gettxt_LF:
0256+  12BA 19 0A         mov al, $0A
0257+  12BC 3E            mov [d], al
0258+  12BD 79            inc d
0259+  12BE 0A 83 12      jmp _gettxt_loop
0260+  12C1             _gettxt_CR:
0261+  12C1 19 0D         mov al, $0D
0262+  12C3 3E            mov [d], al
0263+  12C4 79            inc d
0264+  12C5 0A 83 12      jmp _gettxt_loop
0265+  12C8             _gettxt_backspace:
0266+  12C8 7F            dec d
0267+  12C9 0A 83 12      jmp _gettxt_loop
0268+  12CC             _gettxt_end:
0269+  12CC 19 00         mov al, 0
0270+  12CE 3E            mov [d], al        ; terminate string
0271+  12CF E7            pop d
0272+  12D0 E4            pop a
0273+  12D1 09            ret
0274+  12D2             
0275+  12D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  12D2             ; PRINT NEW LINE
0277+  12D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  12D2             printnl:
0279+  12D2 D7            push a
0280+  12D3 10 00 0A      mov a, $0A00
0281+  12D6 05 03         syscall sys_io
0282+  12D8 10 00 0D      mov a, $0D00
0283+  12DB 05 03         syscall sys_io
0284+  12DD E4            pop a
0285+  12DE 09            ret
0286+  12DF             
0287+  12DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  12DF             ; _strtoint
0289+  12DF             ; 4 digit hex string number in d
0290+  12DF             ; integer returned in A
0291+  12DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  12DF             _strtointx:
0293+  12DF D8            push b
0294+  12E0 32            mov bl, [d]
0295+  12E1 37            mov bh, bl
0296+  12E2 33 01 00      mov bl, [d + 1]
0297+  12E5 07 98 11      call _atoi        ; convert to int in AL
0298+  12E8 23            mov ah, al        ; move to AH
0299+  12E9 33 02 00      mov bl, [d + 2]
0300+  12EC 37            mov bh, bl
0301+  12ED 33 03 00      mov bl, [d + 3]
0302+  12F0 07 98 11      call _atoi        ; convert to int in AL
0303+  12F3 E5            pop b
0304+  12F4 09            ret
0305+  12F5             
0306+  12F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  12F5             ; _strtoint
0308+  12F5             ; 5 digit base10 string number in d
0309+  12F5             ; integer returned in A
0310+  12F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  12F5             _strtoint:
0312+  12F5 E2            push si
0313+  12F6 D8            push b
0314+  12F7 D9            push c
0315+  12F8 DA            push d
0316+  12F9 07 3A 11      call _strlen      ; get string length in C
0317+  12FC 7E            dec c
0318+  12FD FD 4E         mov si, d
0319+  12FF 12            mov a, c
0320+  1300 FD 99         shl a
0321+  1302 3B 71 14      mov d, table_power
0322+  1305 59            add d, a
0323+  1306 38 00 00      mov c, 0
0324+  1309             _strtoint_L0:
0325+  1309 F6            lodsb      ; load ASCII to al
0326+  130A B9 00         cmp al, 0
0327+  130C C6 1F 13      je _strtoint_end
0328+  130F 6F 30         sub al, $30    ; make into integer
0329+  1311 22 00         mov ah, 0
0330+  1313 2A            mov b, [d]
0331+  1314 AC            mul a, b      ; result in B since it fits in 16bits
0332+  1315 11            mov a, b
0333+  1316 28            mov b, c
0334+  1317 54            add a, b
0335+  1318 39            mov c, a
0336+  1319 63 02 00      sub d, 2
0337+  131C 0A 09 13      jmp _strtoint_L0
0338+  131F             _strtoint_end:
0339+  131F 12            mov a, c
0340+  1320 E7            pop d
0341+  1321 E6            pop c
0342+  1322 E5            pop b
0343+  1323 EF            pop si
0344+  1324 09            ret
0345+  1325             
0346+  1325             
0347+  1325             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  1325             ; PRINT NULL TERMINATED STRING
0349+  1325             ; pointer in D
0350+  1325             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  1325             _puts:
0352+  1325 D7            push a
0353+  1326 DA            push d
0354+  1327             _puts_L1:
0355+  1327 1E            mov al, [d]
0356+  1328 B9 00         cmp al, 0
0357+  132A C6 36 13      jz _puts_END
0358+  132D 23            mov ah, al
0359+  132E 19 00         mov al, 0
0360+  1330 05 03         syscall sys_io
0361+  1332 79            inc d
0362+  1333 0A 27 13      jmp _puts_L1
0363+  1336             _puts_END:
0364+  1336 E7            pop d
0365+  1337 E4            pop a
0366+  1338 09            ret
0367+  1339             
0368+  1339             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  1339             ; PRINT N SIZE STRING
0370+  1339             ; pointer in D
0371+  1339             ; size in C
0372+  1339             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  1339             _putsn:
0374+  1339 DB            push al
0375+  133A DA            push d
0376+  133B D9            push c
0377+  133C             _putsn_L0:
0378+  133C 1E            mov al, [d]
0379+  133D 23            mov ah, al
0380+  133E 19 00         mov al, 0
0381+  1340 05 03         syscall sys_io
0382+  1342 79            inc d
0383+  1343 7E            dec c  
0384+  1344 C2 00 00      cmp c, 0
0385+  1347 C7 3C 13      jne _putsn_L0
0386+  134A             _putsn_end:
0387+  134A E6            pop c
0388+  134B E7            pop d
0389+  134C E8            pop al
0390+  134D 09            ret
0391+  134E             
0392+  134E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  134E             ; print 16bit decimal number
0394+  134E             ; input number in A
0395+  134E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  134E             print_u16d:
0397+  134E D7            push a
0398+  134F D8            push b
0399+  1350 26 10 27      mov b, 10000
0400+  1353 AE            div a, b      ; get 10000's coeff.
0401+  1354 07 76 13      call print_number
0402+  1357 11            mov a, b
0403+  1358 26 E8 03      mov b, 1000
0404+  135B AE            div a, b      ; get 1000's coeff.
0405+  135C 07 76 13      call print_number
0406+  135F 11            mov a, b
0407+  1360 26 64 00      mov b, 100
0408+  1363 AE            div a, b
0409+  1364 07 76 13      call print_number
0410+  1367 11            mov a, b
0411+  1368 26 0A 00      mov b, 10
0412+  136B AE            div a, b
0413+  136C 07 76 13      call print_number
0414+  136F 1B            mov al, bl      ; 1's coeff in bl
0415+  1370 07 76 13      call print_number
0416+  1373 E5            pop b
0417+  1374 E4            pop a
0418+  1375 09            ret
0419+  1376             
0420+  1376             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  1376             ; print AL
0422+  1376             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  1376             print_number:
0424+  1376 6A 30         add al, $30
0425+  1378 23            mov ah, al
0426+  1379 07 DB 11      call _putchar
0427+  137C 09            ret
0428+  137D             
0429+  137D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  137D             ; PRINT 16BIT HEX INTEGER
0431+  137D             ; integer value in reg B
0432+  137D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  137D             print_u16x:
0434+  137D D7            push a
0435+  137E D8            push b
0436+  137F DD            push bl
0437+  1380 30            mov bl, bh
0438+  1381 07 A9 11      call _itoa        ; convert bh to char in A
0439+  1384 2F            mov bl, al        ; save al
0440+  1385 19 00         mov al, 0
0441+  1387 05 03         syscall sys_io        ; display AH
0442+  1389 24            mov ah, bl        ; retrieve al
0443+  138A 19 00         mov al, 0
0444+  138C 05 03         syscall sys_io        ; display AL
0445+  138E             
0446+  138E EA            pop bl
0447+  138F 07 A9 11      call _itoa        ; convert bh to char in A
0448+  1392 2F            mov bl, al        ; save al
0449+  1393 19 00         mov al, 0
0450+  1395 05 03         syscall sys_io        ; display AH
0451+  1397 24            mov ah, bl        ; retrieve al
0452+  1398 19 00         mov al, 0
0453+  139A 05 03         syscall sys_io        ; display AL
0454+  139C             
0455+  139C E5            pop b
0456+  139D E4            pop a
0457+  139E 09            ret
0458+  139F             
0459+  139F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  139F             ; INPUT 16BIT HEX INTEGER
0461+  139F             ; read 16bit integer into A
0462+  139F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  139F             scan_u16x:
0464+  139F F8 10 00      enter 16
0465+  13A2 D8            push b
0466+  13A3 DA            push d
0467+  13A4             
0468+  13A4 FA F1 FF      lea d, [bp + -15]
0469+  13A7 07 E2 11      call _gets        ; get number
0470+  13AA             
0471+  13AA 32            mov bl, [d]
0472+  13AB 37            mov bh, bl
0473+  13AC 33 01 00      mov bl, [d + 1]
0474+  13AF 07 98 11      call _atoi        ; convert to int in AL
0475+  13B2 23            mov ah, al        ; move to AH
0476+  13B3             
0477+  13B3 33 02 00      mov bl, [d + 2]
0478+  13B6 37            mov bh, bl
0479+  13B7 33 03 00      mov bl, [d + 3]
0480+  13BA 07 98 11      call _atoi        ; convert to int in AL
0481+  13BD             
0482+  13BD E7            pop d
0483+  13BE E5            pop b
0484+  13BF F9            leave
0485+  13C0 09            ret
0486+  13C1             
0487+  13C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  13C1             ; PRINT 8bit HEX INTEGER
0489+  13C1             ; integer value in reg bl
0490+  13C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  13C1             print_u8x:
0492+  13C1 D7            push a
0493+  13C2 DD            push bl
0494+  13C3             
0495+  13C3 07 A9 11      call _itoa        ; convert bl to char in A
0496+  13C6 2F            mov bl, al        ; save al
0497+  13C7 19 00         mov al, 0
0498+  13C9 05 03         syscall sys_io        ; display AH
0499+  13CB 24            mov ah, bl        ; retrieve al
0500+  13CC 19 00         mov al, 0
0501+  13CE 05 03         syscall sys_io        ; display AL
0502+  13D0             
0503+  13D0 EA            pop bl
0504+  13D1 E4            pop a
0505+  13D2 09            ret
0506+  13D3             
0507+  13D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  13D3             ; print 8bit decimal unsigned number
0509+  13D3             ; input number in AL
0510+  13D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  13D3             print_u8d:
0512+  13D3 D7            push a
0513+  13D4 D8            push b
0514+  13D5             
0515+  13D5 22 00         mov ah, 0
0516+  13D7 26 64 00      mov b, 100
0517+  13DA AE            div a, b
0518+  13DB D8            push b      ; save remainder
0519+  13DC B9 00         cmp al, 0
0520+  13DE C6 E8 13      je skip100
0521+  13E1 6A 30         add al, $30
0522+  13E3 23            mov ah, al
0523+  13E4 19 00         mov al, 0
0524+  13E6 05 03         syscall sys_io  ; print coeff
0525+  13E8             skip100:
0526+  13E8 E4            pop a
0527+  13E9 22 00         mov ah, 0
0528+  13EB 26 0A 00      mov b, 10
0529+  13EE AE            div a, b
0530+  13EF D8            push b      ; save remainder
0531+  13F0 B9 00         cmp al, 0
0532+  13F2 C6 FC 13      je skip10
0533+  13F5 6A 30         add al, $30
0534+  13F7 23            mov ah, al
0535+  13F8 19 00         mov al, 0
0536+  13FA 05 03         syscall sys_io  ; print coeff
0537+  13FC             skip10:
0538+  13FC E4            pop a
0539+  13FD 1B            mov al, bl
0540+  13FE 6A 30         add al, $30
0541+  1400 23            mov ah, al
0542+  1401 19 00         mov al, 0
0543+  1403 05 03         syscall sys_io  ; print coeff
0544+  1405 E5            pop b
0545+  1406 E4            pop a
0546+  1407 09            ret
0547+  1408             
0548+  1408             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  1408             ; INPUT 8BIT HEX INTEGER
0550+  1408             ; read 8bit integer into AL
0551+  1408             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  1408             scan_u8x:
0553+  1408 F8 04 00      enter 4
0554+  140B D8            push b
0555+  140C DA            push d
0556+  140D             
0557+  140D FA FD FF      lea d, [bp + -3]
0558+  1410 07 E2 11      call _gets        ; get number
0559+  1413             
0560+  1413 32            mov bl, [d]
0561+  1414 37            mov bh, bl
0562+  1415 33 01 00      mov bl, [d + 1]
0563+  1418 07 98 11      call _atoi        ; convert to int in AL
0564+  141B             
0565+  141B E7            pop d
0566+  141C E5            pop b
0567+  141D F9            leave
0568+  141E 09            ret
0569+  141F             
0570+  141F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  141F             ; input decimal number
0572+  141F             ; result in A
0573+  141F             ; 655'\0'
0574+  141F             ; low--------high
0575+  141F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  141F             scan_u16d:
0577+  141F F8 08 00      enter 8
0578+  1422 E2            push si
0579+  1423 D8            push b
0580+  1424 D9            push c
0581+  1425 DA            push d
0582+  1426 FA F9 FF      lea d, [bp +- 7]
0583+  1429 07 E2 11      call _gets
0584+  142C 07 3A 11      call _strlen      ; get string length in C
0585+  142F 7E            dec c
0586+  1430 FD 4E         mov si, d
0587+  1432 12            mov a, c
0588+  1433 FD 99         shl a
0589+  1435 3B 71 14      mov d, table_power
0590+  1438 59            add d, a
0591+  1439 38 00 00      mov c, 0
0592+  143C             mul_loop:
0593+  143C F6            lodsb      ; load ASCII to al
0594+  143D B9 00         cmp al, 0
0595+  143F C6 52 14      je mul_exit
0596+  1442 6F 30         sub al, $30    ; make into integer
0597+  1444 22 00         mov ah, 0
0598+  1446 2A            mov b, [d]
0599+  1447 AC            mul a, b      ; result in B since it fits in 16bits
0600+  1448 11            mov a, b
0601+  1449 28            mov b, c
0602+  144A 54            add a, b
0603+  144B 39            mov c, a
0604+  144C 63 02 00      sub d, 2
0605+  144F 0A 3C 14      jmp mul_loop
0606+  1452             mul_exit:
0607+  1452 12            mov a, c
0608+  1453 E7            pop d
0609+  1454 E6            pop c
0610+  1455 E5            pop b
0611+  1456 EF            pop si
0612+  1457 F9            leave
0613+  1458 09            ret
0614+  1459             
0615+  1459             
0616+  1459 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  145D 34 35 36 37 
0616+  1461 38 39 41 42 
0616+  1465 43 44 45 46 
0617+  1469 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  146D 1B 5B 48 00 
0618+  1471             
0619+  1471             table_power:
0620+  1471 01 00         .dw 1
0621+  1473 0A 00         .dw 10
0622+  1475 64 00         .dw 100
0623+  1477 E8 03         .dw 1000
0624+  1479 10 27         .dw 100002454   147B             ; --- END INLINE ASM BLOCK
2455   147B             
2456   147B F9            leave
2457   147C 09            ret
2458   147D             ; --- END TEXT BLOCK
2459   147D             
2460   147D             ; --- BEGIN DATA BLOCK
2461   147D 52 65 73 75 __s0: .db "Result: %d, %d", 0
2461   1481 6C 74 3A 20 
2461   1485 25 64 2C 20 
2461   1489 25 64 00 
2462   148C 55 6E 65 78 __s1: .db "Unexpected format in printf.", 0
2462   1490 70 65 63 74 
2462   1494 65 64 20 66 
2462   1498 6F 72 6D 61 
2462   149C 74 20 69 6E 
2462   14A0 20 70 72 69 
2462   14A4 6E 74 66 2E 
2462   14A8 00 
2463   14A9 45 72 72 6F __s2: .db "Error: Unknown argument type.\n", 0
2463   14AD 72 3A 20 55 
2463   14B1 6E 6B 6E 6F 
2463   14B5 77 6E 20 61 
2463   14B9 72 67 75 6D 
2463   14BD 65 6E 74 20 
2463   14C1 74 79 70 65 
2463   14C5 2E 0A 00 
2464   14C8 1B 5B 32 4A __s3: .db "\033[2J\033[H", 0
2464   14CC 1B 5B 48 00 
2465   14D0             
2466   14D0 D2 14       _heap_top: .dw _heap
2467   14D2 00          _heap: .db 0
2468   14D3             ; --- END DATA BLOCK
2469   14D3             
2470   14D3             .end
tasm: Number of errors = 0
