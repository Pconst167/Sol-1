0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; move_cursor(10, 10); 
0011   0408             ; --- START FUNCTION CALL
0012   0408 FD 2E 0A 00   mov32 cb, $0000000a
0012   040C 00 00 
0013   040E FD AB         swp b
0014   0410 D8            push b
0015   0411 FD 2E 0A 00   mov32 cb, $0000000a
0015   0415 00 00 
0016   0417 FD AB         swp b
0017   0419 D8            push b
0018   041A 07 52 04      call move_cursor
0019   041D 51 04 00      add sp, 4
0020   0420             ; --- END FUNCTION CALL
0021   0420             ; printf("hello World"); 
0022   0420             ; --- START FUNCTION CALL
0023   0420 26 84 0D      mov b, _s0 ; "hello World"
0024   0423 FD AB         swp b
0025   0425 D8            push b
0026   0426 07 77 04      call printf
0027   0429 51 02 00      add sp, 2
0028   042C             ; --- END FUNCTION CALL
0029   042C             ; move_cursor(20, 20); 
0030   042C             ; --- START FUNCTION CALL
0031   042C FD 2E 14 00   mov32 cb, $00000014
0031   0430 00 00 
0032   0432 FD AB         swp b
0033   0434 D8            push b
0034   0435 FD 2E 14 00   mov32 cb, $00000014
0034   0439 00 00 
0035   043B FD AB         swp b
0036   043D D8            push b
0037   043E 07 52 04      call move_cursor
0038   0441 51 04 00      add sp, 4
0039   0444             ; --- END FUNCTION CALL
0040   0444             ; printf("hello World"); 
0041   0444             ; --- START FUNCTION CALL
0042   0444 26 84 0D      mov b, _s0 ; "hello World"
0043   0447 FD AB         swp b
0044   0449 D8            push b
0045   044A 07 77 04      call printf
0046   044D 51 02 00      add sp, 2
0047   0450             ; --- END FUNCTION CALL
0048   0450 05 0B         syscall sys_terminate_proc
0049   0452             
0050   0452             move_cursor:
0051   0452 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0052   0455             ; printf("\033[%d;%dH", y, x); 
0053   0455             ; --- START FUNCTION CALL
0054   0455 FA 05 00      lea d, [bp + 5] ; $x
0055   0458 2A            mov b, [d]
0056   0459 38 00 00      mov c, 0
0057   045C FD AB         swp b
0058   045E D8            push b
0059   045F FA 07 00      lea d, [bp + 7] ; $y
0060   0462 2A            mov b, [d]
0061   0463 38 00 00      mov c, 0
0062   0466 FD AB         swp b
0063   0468 D8            push b
0064   0469 26 90 0D      mov b, _s1 ; "\033[%d;%dH"
0065   046C FD AB         swp b
0066   046E D8            push b
0067   046F 07 77 04      call printf
0068   0472 51 06 00      add sp, 6
0069   0475             ; --- END FUNCTION CALL
0070   0475 F9            leave
0071   0476 09            ret
0072   0477             
0073   0477             printf:
0074   0477 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0075   047A             ; char *p, *format_p; 
0076   047A 52 02 00      sub sp, 2
0077   047D 52 02 00      sub sp, 2
0078   0480             ; format_p = format; 
0079   0480 FA FD FF      lea d, [bp + -3] ; $format_p
0080   0483 DA            push d
0081   0484 FA 05 00      lea d, [bp + 5] ; $format
0082   0487 2A            mov b, [d]
0083   0488 38 00 00      mov c, 0
0084   048B E7            pop d
0085   048C FD 43         mov [d], b
0086   048E             ; p = &format + 2; 
0087   048E FA FF FF      lea d, [bp + -1] ; $p
0088   0491 DA            push d
0089   0492 FA 05 00      lea d, [bp + 5] ; $format
0090   0495 2D            mov b, d
0091   0496             ; --- START TERMS
0092   0496 D7            push a
0093   0497 11            mov a, b
0094   0498 FD 2E 02 00   mov32 cb, $00000002
0094   049C 00 00 
0095   049E 56            add b, a
0096   049F E4            pop a
0097   04A0             ; --- END TERMS
0098   04A0 E7            pop d
0099   04A1 FD 43         mov [d], b
0100   04A3             ; for(;;){ 
0101   04A3             _for1_init:
0102   04A3             _for1_cond:
0103   04A3             _for1_block:
0104   04A3             ; if(!*format_p) break; 
0105   04A3             _if2_cond:
0106   04A3 FA FD FF      lea d, [bp + -3] ; $format_p
0107   04A6 2A            mov b, [d]
0108   04A7 38 00 00      mov c, 0
0109   04AA 74            mov d, b
0110   04AB 32            mov bl, [d]
0111   04AC A7 00         mov bh, 0
0112   04AE 38 00 00      mov c, 0
0113   04B1 C0 00 00      cmp b, 0
0114   04B4 FD 71         seq ; !
0115   04B6 C0 00 00      cmp b, 0
0116   04B9 C6 C2 04      je _if2_else
0117   04BC             _if2_TRUE:
0118   04BC             ; break; 
0119   04BC 0A 72 07      jmp _for1_exit ; for break
0120   04BF 0A 6F 07      jmp _if2_exit
0121   04C2             _if2_else:
0122   04C2             ; if(*format_p == '%'){ 
0123   04C2             _if3_cond:
0124   04C2 FA FD FF      lea d, [bp + -3] ; $format_p
0125   04C5 2A            mov b, [d]
0126   04C6 38 00 00      mov c, 0
0127   04C9 74            mov d, b
0128   04CA 32            mov bl, [d]
0129   04CB A7 00         mov bh, 0
0130   04CD 38 00 00      mov c, 0
0131   04D0             ; --- START RELATIONAL
0132   04D0 D7            push a
0133   04D1 11            mov a, b
0134   04D2 FD 2E 25 00   mov32 cb, $00000025
0134   04D6 00 00 
0135   04D8 B0            cmp a, b
0136   04D9 FD 71         seq ; ==
0137   04DB E4            pop a
0138   04DC             ; --- END RELATIONAL
0139   04DC C0 00 00      cmp b, 0
0140   04DF C6 4A 07      je _if3_else
0141   04E2             _if3_TRUE:
0142   04E2             ; format_p++; 
0143   04E2 FA FD FF      lea d, [bp + -3] ; $format_p
0144   04E5 2A            mov b, [d]
0145   04E6 38 00 00      mov c, 0
0146   04E9 FD 77         inc b
0147   04EB FA FD FF      lea d, [bp + -3] ; $format_p
0148   04EE FD 43         mov [d], b
0149   04F0 FD 7D         dec b
0150   04F2             ; switch(*format_p){ 
0151   04F2             _switch4_expr:
0152   04F2 FA FD FF      lea d, [bp + -3] ; $format_p
0153   04F5 2A            mov b, [d]
0154   04F6 38 00 00      mov c, 0
0155   04F9 74            mov d, b
0156   04FA 32            mov bl, [d]
0157   04FB A7 00         mov bh, 0
0158   04FD 38 00 00      mov c, 0
0159   0500             _switch4_comparisons:
0160   0500 C1 6C         cmp bl, $6c
0161   0502 C6 2E 05      je _switch4_case0
0162   0505 C1 4C         cmp bl, $4c
0163   0507 C6 2E 05      je _switch4_case1
0164   050A C1 64         cmp bl, $64
0165   050C C6 3E 06      je _switch4_case2
0166   050F C1 69         cmp bl, $69
0167   0511 C6 3E 06      je _switch4_case3
0168   0514 C1 75         cmp bl, $75
0169   0516 C6 6E 06      je _switch4_case4
0170   0519 C1 78         cmp bl, $78
0171   051B C6 9E 06      je _switch4_case5
0172   051E C1 63         cmp bl, $63
0173   0520 C6 CE 06      je _switch4_case6
0174   0523 C1 73         cmp bl, $73
0175   0525 C6 FE 06      je _switch4_case7
0176   0528 0A 2B 07      jmp _switch4_default
0177   052B 0A 37 07      jmp _switch4_exit
0178   052E             _switch4_case0:
0179   052E             _switch4_case1:
0180   052E             ; format_p++; 
0181   052E FA FD FF      lea d, [bp + -3] ; $format_p
0182   0531 2A            mov b, [d]
0183   0532 38 00 00      mov c, 0
0184   0535 FD 77         inc b
0185   0537 FA FD FF      lea d, [bp + -3] ; $format_p
0186   053A FD 43         mov [d], b
0187   053C FD 7D         dec b
0188   053E             ; if(*format_p == 'd' || *format_p == 'i') 
0189   053E             _if5_cond:
0190   053E FA FD FF      lea d, [bp + -3] ; $format_p
0191   0541 2A            mov b, [d]
0192   0542 38 00 00      mov c, 0
0193   0545 74            mov d, b
0194   0546 32            mov bl, [d]
0195   0547 A7 00         mov bh, 0
0196   0549 38 00 00      mov c, 0
0197   054C             ; --- START RELATIONAL
0198   054C D7            push a
0199   054D 11            mov a, b
0200   054E FD 2E 64 00   mov32 cb, $00000064
0200   0552 00 00 
0201   0554 B0            cmp a, b
0202   0555 FD 71         seq ; ==
0203   0557 E4            pop a
0204   0558             ; --- END RELATIONAL
0205   0558             ; --- START LOGICAL OR
0206   0558 D7            push a
0207   0559 11            mov a, b
0208   055A FA FD FF      lea d, [bp + -3] ; $format_p
0209   055D 2A            mov b, [d]
0210   055E 38 00 00      mov c, 0
0211   0561 74            mov d, b
0212   0562 32            mov bl, [d]
0213   0563 A7 00         mov bh, 0
0214   0565 38 00 00      mov c, 0
0215   0568             ; --- START RELATIONAL
0216   0568 D7            push a
0217   0569 11            mov a, b
0218   056A FD 2E 69 00   mov32 cb, $00000069
0218   056E 00 00 
0219   0570 B0            cmp a, b
0220   0571 FD 71         seq ; ==
0221   0573 E4            pop a
0222   0574             ; --- END RELATIONAL
0223   0574 FD A8         sor a, b ; ||
0224   0576 E4            pop a
0225   0577             ; --- END LOGICAL OR
0226   0577 C0 00 00      cmp b, 0
0227   057A C6 9B 05      je _if5_else
0228   057D             _if5_TRUE:
0229   057D             ; print_signed_long(*(long *)p); 
0230   057D             ; --- START FUNCTION CALL
0231   057D FA FF FF      lea d, [bp + -1] ; $p
0232   0580 2A            mov b, [d]
0233   0581 38 00 00      mov c, 0
0234   0584 74            mov d, b
0235   0585 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0236   0588 FD 39         mov c, b ; And place it into C
0237   058A 2A            mov b, [d] ; Lower Word in B
0238   058B 12            mov a, c
0239   058C FD AA         swp a
0240   058E D7            push a
0241   058F FD AB         swp b
0242   0591 D8            push b
0243   0592 07 74 07      call print_signed_long
0244   0595 51 04 00      add sp, 4
0245   0598             ; --- END FUNCTION CALL
0246   0598 0A 23 06      jmp _if5_exit
0247   059B             _if5_else:
0248   059B             ; if(*format_p == 'u') 
0249   059B             _if6_cond:
0250   059B FA FD FF      lea d, [bp + -3] ; $format_p
0251   059E 2A            mov b, [d]
0252   059F 38 00 00      mov c, 0
0253   05A2 74            mov d, b
0254   05A3 32            mov bl, [d]
0255   05A4 A7 00         mov bh, 0
0256   05A6 38 00 00      mov c, 0
0257   05A9             ; --- START RELATIONAL
0258   05A9 D7            push a
0259   05AA 11            mov a, b
0260   05AB FD 2E 75 00   mov32 cb, $00000075
0260   05AF 00 00 
0261   05B1 B0            cmp a, b
0262   05B2 FD 71         seq ; ==
0263   05B4 E4            pop a
0264   05B5             ; --- END RELATIONAL
0265   05B5 C0 00 00      cmp b, 0
0266   05B8 C6 D9 05      je _if6_else
0267   05BB             _if6_TRUE:
0268   05BB             ; print_unsigned_long(*(unsigned long *)p); 
0269   05BB             ; --- START FUNCTION CALL
0270   05BB FA FF FF      lea d, [bp + -1] ; $p
0271   05BE 2A            mov b, [d]
0272   05BF 38 00 00      mov c, 0
0273   05C2 74            mov d, b
0274   05C3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0275   05C6 FD 39         mov c, b ; And place it into C
0276   05C8 2A            mov b, [d] ; Lower Word in B
0277   05C9 12            mov a, c
0278   05CA FD AA         swp a
0279   05CC D7            push a
0280   05CD FD AB         swp b
0281   05CF D8            push b
0282   05D0 07 07 09      call print_unsigned_long
0283   05D3 51 04 00      add sp, 4
0284   05D6             ; --- END FUNCTION CALL
0285   05D6 0A 23 06      jmp _if6_exit
0286   05D9             _if6_else:
0287   05D9             ; if(*format_p == 'x') 
0288   05D9             _if7_cond:
0289   05D9 FA FD FF      lea d, [bp + -3] ; $format_p
0290   05DC 2A            mov b, [d]
0291   05DD 38 00 00      mov c, 0
0292   05E0 74            mov d, b
0293   05E1 32            mov bl, [d]
0294   05E2 A7 00         mov bh, 0
0295   05E4 38 00 00      mov c, 0
0296   05E7             ; --- START RELATIONAL
0297   05E7 D7            push a
0298   05E8 11            mov a, b
0299   05E9 FD 2E 78 00   mov32 cb, $00000078
0299   05ED 00 00 
0300   05EF B0            cmp a, b
0301   05F0 FD 71         seq ; ==
0302   05F2 E4            pop a
0303   05F3             ; --- END RELATIONAL
0304   05F3 C0 00 00      cmp b, 0
0305   05F6 C6 17 06      je _if7_else
0306   05F9             _if7_TRUE:
0307   05F9             ; printx32(*(long int *)p); 
0308   05F9             ; --- START FUNCTION CALL
0309   05F9 FA FF FF      lea d, [bp + -1] ; $p
0310   05FC 2A            mov b, [d]
0311   05FD 38 00 00      mov c, 0
0312   0600 74            mov d, b
0313   0601 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0314   0604 FD 39         mov c, b ; And place it into C
0315   0606 2A            mov b, [d] ; Lower Word in B
0316   0607 12            mov a, c
0317   0608 FD AA         swp a
0318   060A D7            push a
0319   060B FD AB         swp b
0320   060D D8            push b
0321   060E 07 3B 0A      call printx32
0322   0611 51 04 00      add sp, 4
0323   0614             ; --- END FUNCTION CALL
0324   0614 0A 23 06      jmp _if7_exit
0325   0617             _if7_else:
0326   0617             ; err("Unexpected format in printf."); 
0327   0617             ; --- START FUNCTION CALL
0328   0617 26 99 0D      mov b, _s2 ; "Unexpected format in printf."
0329   061A FD AB         swp b
0330   061C D8            push b
0331   061D 07 9B 0A      call err
0332   0620 51 02 00      add sp, 2
0333   0623             ; --- END FUNCTION CALL
0334   0623             _if7_exit:
0335   0623             _if6_exit:
0336   0623             _if5_exit:
0337   0623             ; p = p + 4; 
0338   0623 FA FF FF      lea d, [bp + -1] ; $p
0339   0626 DA            push d
0340   0627 FA FF FF      lea d, [bp + -1] ; $p
0341   062A 2A            mov b, [d]
0342   062B 38 00 00      mov c, 0
0343   062E             ; --- START TERMS
0344   062E D7            push a
0345   062F 11            mov a, b
0346   0630 FD 2E 04 00   mov32 cb, $00000004
0346   0634 00 00 
0347   0636 56            add b, a
0348   0637 E4            pop a
0349   0638             ; --- END TERMS
0350   0638 E7            pop d
0351   0639 FD 43         mov [d], b
0352   063B             ; break; 
0353   063B 0A 37 07      jmp _switch4_exit ; case break
0354   063E             _switch4_case2:
0355   063E             _switch4_case3:
0356   063E             ; print_signed(*(int*)p); 
0357   063E             ; --- START FUNCTION CALL
0358   063E FA FF FF      lea d, [bp + -1] ; $p
0359   0641 2A            mov b, [d]
0360   0642 38 00 00      mov c, 0
0361   0645 74            mov d, b
0362   0646 2A            mov b, [d]
0363   0647 38 00 00      mov c, 0
0364   064A FD AB         swp b
0365   064C D8            push b
0366   064D 07 C9 0A      call print_signed
0367   0650 51 02 00      add sp, 2
0368   0653             ; --- END FUNCTION CALL
0369   0653             ; p = p + 2; 
0370   0653 FA FF FF      lea d, [bp + -1] ; $p
0371   0656 DA            push d
0372   0657 FA FF FF      lea d, [bp + -1] ; $p
0373   065A 2A            mov b, [d]
0374   065B 38 00 00      mov c, 0
0375   065E             ; --- START TERMS
0376   065E D7            push a
0377   065F 11            mov a, b
0378   0660 FD 2E 02 00   mov32 cb, $00000002
0378   0664 00 00 
0379   0666 56            add b, a
0380   0667 E4            pop a
0381   0668             ; --- END TERMS
0382   0668 E7            pop d
0383   0669 FD 43         mov [d], b
0384   066B             ; break; 
0385   066B 0A 37 07      jmp _switch4_exit ; case break
0386   066E             _switch4_case4:
0387   066E             ; print_unsigned(*(unsigned int*)p); 
0388   066E             ; --- START FUNCTION CALL
0389   066E FA FF FF      lea d, [bp + -1] ; $p
0390   0671 2A            mov b, [d]
0391   0672 38 00 00      mov c, 0
0392   0675 74            mov d, b
0393   0676 2A            mov b, [d]
0394   0677 38 00 00      mov c, 0
0395   067A FD AB         swp b
0396   067C D8            push b
0397   067D 07 1A 0C      call print_unsigned
0398   0680 51 02 00      add sp, 2
0399   0683             ; --- END FUNCTION CALL
0400   0683             ; p = p + 2; 
0401   0683 FA FF FF      lea d, [bp + -1] ; $p
0402   0686 DA            push d
0403   0687 FA FF FF      lea d, [bp + -1] ; $p
0404   068A 2A            mov b, [d]
0405   068B 38 00 00      mov c, 0
0406   068E             ; --- START TERMS
0407   068E D7            push a
0408   068F 11            mov a, b
0409   0690 FD 2E 02 00   mov32 cb, $00000002
0409   0694 00 00 
0410   0696 56            add b, a
0411   0697 E4            pop a
0412   0698             ; --- END TERMS
0413   0698 E7            pop d
0414   0699 FD 43         mov [d], b
0415   069B             ; break; 
0416   069B 0A 37 07      jmp _switch4_exit ; case break
0417   069E             _switch4_case5:
0418   069E             ; printx16(*(int*)p); 
0419   069E             ; --- START FUNCTION CALL
0420   069E FA FF FF      lea d, [bp + -1] ; $p
0421   06A1 2A            mov b, [d]
0422   06A2 38 00 00      mov c, 0
0423   06A5 74            mov d, b
0424   06A6 2A            mov b, [d]
0425   06A7 38 00 00      mov c, 0
0426   06AA FD AB         swp b
0427   06AC D8            push b
0428   06AD 07 32 0D      call printx16
0429   06B0 51 02 00      add sp, 2
0430   06B3             ; --- END FUNCTION CALL
0431   06B3             ; p = p + 2; 
0432   06B3 FA FF FF      lea d, [bp + -1] ; $p
0433   06B6 DA            push d
0434   06B7 FA FF FF      lea d, [bp + -1] ; $p
0435   06BA 2A            mov b, [d]
0436   06BB 38 00 00      mov c, 0
0437   06BE             ; --- START TERMS
0438   06BE D7            push a
0439   06BF 11            mov a, b
0440   06C0 FD 2E 02 00   mov32 cb, $00000002
0440   06C4 00 00 
0441   06C6 56            add b, a
0442   06C7 E4            pop a
0443   06C8             ; --- END TERMS
0444   06C8 E7            pop d
0445   06C9 FD 43         mov [d], b
0446   06CB             ; break; 
0447   06CB 0A 37 07      jmp _switch4_exit ; case break
0448   06CE             _switch4_case6:
0449   06CE             ; putchar(*(char*)p); 
0450   06CE             ; --- START FUNCTION CALL
0451   06CE FA FF FF      lea d, [bp + -1] ; $p
0452   06D1 2A            mov b, [d]
0453   06D2 38 00 00      mov c, 0
0454   06D5 74            mov d, b
0455   06D6 32            mov bl, [d]
0456   06D7 A7 00         mov bh, 0
0457   06D9 38 00 00      mov c, 0
0458   06DC DD            push bl
0459   06DD 07 F9 08      call putchar
0460   06E0 51 01 00      add sp, 1
0461   06E3             ; --- END FUNCTION CALL
0462   06E3             ; p = p + 1; 
0463   06E3 FA FF FF      lea d, [bp + -1] ; $p
0464   06E6 DA            push d
0465   06E7 FA FF FF      lea d, [bp + -1] ; $p
0466   06EA 2A            mov b, [d]
0467   06EB 38 00 00      mov c, 0
0468   06EE             ; --- START TERMS
0469   06EE D7            push a
0470   06EF 11            mov a, b
0471   06F0 FD 2E 01 00   mov32 cb, $00000001
0471   06F4 00 00 
0472   06F6 56            add b, a
0473   06F7 E4            pop a
0474   06F8             ; --- END TERMS
0475   06F8 E7            pop d
0476   06F9 FD 43         mov [d], b
0477   06FB             ; break; 
0478   06FB 0A 37 07      jmp _switch4_exit ; case break
0479   06FE             _switch4_case7:
0480   06FE             ; print(*(char**)p); 
0481   06FE             ; --- START FUNCTION CALL
0482   06FE FA FF FF      lea d, [bp + -1] ; $p
0483   0701 2A            mov b, [d]
0484   0702 38 00 00      mov c, 0
0485   0705 74            mov d, b
0486   0706 2A            mov b, [d]
0487   0707 FD AB         swp b
0488   0709 D8            push b
0489   070A 07 B0 0A      call print
0490   070D 51 02 00      add sp, 2
0491   0710             ; --- END FUNCTION CALL
0492   0710             ; p = p + 2; 
0493   0710 FA FF FF      lea d, [bp + -1] ; $p
0494   0713 DA            push d
0495   0714 FA FF FF      lea d, [bp + -1] ; $p
0496   0717 2A            mov b, [d]
0497   0718 38 00 00      mov c, 0
0498   071B             ; --- START TERMS
0499   071B D7            push a
0500   071C 11            mov a, b
0501   071D FD 2E 02 00   mov32 cb, $00000002
0501   0721 00 00 
0502   0723 56            add b, a
0503   0724 E4            pop a
0504   0725             ; --- END TERMS
0505   0725 E7            pop d
0506   0726 FD 43         mov [d], b
0507   0728             ; break; 
0508   0728 0A 37 07      jmp _switch4_exit ; case break
0509   072B             _switch4_default:
0510   072B             ; print("Error: Unknown argument type.\n"); 
0511   072B             ; --- START FUNCTION CALL
0512   072B 26 B6 0D      mov b, _s3 ; "Error: Unknown argument type.\n"
0513   072E FD AB         swp b
0514   0730 D8            push b
0515   0731 07 B0 0A      call print
0516   0734 51 02 00      add sp, 2
0517   0737             ; --- END FUNCTION CALL
0518   0737             _switch4_exit:
0519   0737             ; format_p++; 
0520   0737 FA FD FF      lea d, [bp + -3] ; $format_p
0521   073A 2A            mov b, [d]
0522   073B 38 00 00      mov c, 0
0523   073E FD 77         inc b
0524   0740 FA FD FF      lea d, [bp + -3] ; $format_p
0525   0743 FD 43         mov [d], b
0526   0745 FD 7D         dec b
0527   0747 0A 6F 07      jmp _if3_exit
0528   074A             _if3_else:
0529   074A             ; putchar(*format_p); 
0530   074A             ; --- START FUNCTION CALL
0531   074A FA FD FF      lea d, [bp + -3] ; $format_p
0532   074D 2A            mov b, [d]
0533   074E 38 00 00      mov c, 0
0534   0751 74            mov d, b
0535   0752 32            mov bl, [d]
0536   0753 A7 00         mov bh, 0
0537   0755 38 00 00      mov c, 0
0538   0758 DD            push bl
0539   0759 07 F9 08      call putchar
0540   075C 51 01 00      add sp, 1
0541   075F             ; --- END FUNCTION CALL
0542   075F             ; format_p++; 
0543   075F FA FD FF      lea d, [bp + -3] ; $format_p
0544   0762 2A            mov b, [d]
0545   0763 38 00 00      mov c, 0
0546   0766 FD 77         inc b
0547   0768 FA FD FF      lea d, [bp + -3] ; $format_p
0548   076B FD 43         mov [d], b
0549   076D FD 7D         dec b
0550   076F             _if3_exit:
0551   076F             _if2_exit:
0552   076F             _for1_update:
0553   076F 0A A3 04      jmp _for1_cond
0554   0772             _for1_exit:
0555   0772 F9            leave
0556   0773 09            ret
0557   0774             
0558   0774             print_signed_long:
0559   0774 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0560   0777             ; char digits[10]; 
0561   0777 52 0A 00      sub sp, 10
0562   077A             ; int i = 0; 
0563   077A 52 02 00      sub sp, 2
0564   077D             ; --- START LOCAL VAR INITIALIZATION
0565   077D FA F5 FF      lea d, [bp + -11] ; $i
0566   0780 DA            push d
0567   0781 FD 2E 00 00   mov32 cb, $00000000
0567   0785 00 00 
0568   0787 E7            pop d
0569   0788 FD 43         mov [d], b
0570   078A             ; --- END LOCAL VAR INITIALIZATION
0571   078A             ; if (num < 0) { 
0572   078A             _if8_cond:
0573   078A FA 05 00      lea d, [bp + 5] ; $num
0574   078D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0575   0790 FD 39         mov c, b ; And place it into C
0576   0792 2A            mov b, [d] ; Lower Word in B
0577   0793             ; --- START RELATIONAL
0578   0793 D7            push a
0579   0794 FD D8         push g
0580   0796 11            mov a, b
0581   0797 FD 7A         mov g, c
0582   0799 FD 2E 00 00   mov32 cb, $00000000
0582   079D 00 00 
0583   079F FD AF         cmp32 ga, cb
0584   07A1 FD 73         slt ; <
0585   07A3 FD F1         pop g
0586   07A5 E4            pop a
0587   07A6             ; --- END RELATIONAL
0588   07A6 C0 00 00      cmp b, 0
0589   07A9 C6 DB 07      je _if8_else
0590   07AC             _if8_TRUE:
0591   07AC             ; putchar('-'); 
0592   07AC             ; --- START FUNCTION CALL
0593   07AC FD 2E 2D 00   mov32 cb, $0000002d
0593   07B0 00 00 
0594   07B2 DD            push bl
0595   07B3 07 F9 08      call putchar
0596   07B6 51 01 00      add sp, 1
0597   07B9             ; --- END FUNCTION CALL
0598   07B9             ; num = -num; 
0599   07B9 FA 05 00      lea d, [bp + 5] ; $num
0600   07BC DA            push d
0601   07BD FA 05 00      lea d, [bp + 5] ; $num
0602   07C0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0603   07C3 FD 39         mov c, b ; And place it into C
0604   07C5 2A            mov b, [d] ; Lower Word in B
0605   07C6 12            mov a, c
0606   07C7 95            not a
0607   07C8 97            not b
0608   07C9 55 01 00      add b, 1
0609   07CC 5B 00 00      adc a, 0
0610   07CF 39            mov c, a
0611   07D0 E7            pop d
0612   07D1 FD 43         mov [d], b
0613   07D3 28            mov b, c
0614   07D4 FD 44 02 00   mov [d + 2], b
0615   07D8 0A 0F 08      jmp _if8_exit
0616   07DB             _if8_else:
0617   07DB             ; if (num == 0) { 
0618   07DB             _if9_cond:
0619   07DB FA 05 00      lea d, [bp + 5] ; $num
0620   07DE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0621   07E1 FD 39         mov c, b ; And place it into C
0622   07E3 2A            mov b, [d] ; Lower Word in B
0623   07E4             ; --- START RELATIONAL
0624   07E4 D7            push a
0625   07E5 FD D8         push g
0626   07E7 11            mov a, b
0627   07E8 FD 7A         mov g, c
0628   07EA FD 2E 00 00   mov32 cb, $00000000
0628   07EE 00 00 
0629   07F0 FD AF         cmp32 ga, cb
0630   07F2 FD 71         seq ; ==
0631   07F4 FD F1         pop g
0632   07F6 E4            pop a
0633   07F7             ; --- END RELATIONAL
0634   07F7 C0 00 00      cmp b, 0
0635   07FA C6 0F 08      je _if9_exit
0636   07FD             _if9_TRUE:
0637   07FD             ; putchar('0'); 
0638   07FD             ; --- START FUNCTION CALL
0639   07FD FD 2E 30 00   mov32 cb, $00000030
0639   0801 00 00 
0640   0803 DD            push bl
0641   0804 07 F9 08      call putchar
0642   0807 51 01 00      add sp, 1
0643   080A             ; --- END FUNCTION CALL
0644   080A             ; return; 
0645   080A F9            leave
0646   080B 09            ret
0647   080C 0A 0F 08      jmp _if9_exit
0648   080F             _if9_exit:
0649   080F             _if8_exit:
0650   080F             ; while (num > 0) { 
0651   080F             _while10_cond:
0652   080F FA 05 00      lea d, [bp + 5] ; $num
0653   0812 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0654   0815 FD 39         mov c, b ; And place it into C
0655   0817 2A            mov b, [d] ; Lower Word in B
0656   0818             ; --- START RELATIONAL
0657   0818 D7            push a
0658   0819 FD D8         push g
0659   081B 11            mov a, b
0660   081C FD 7A         mov g, c
0661   081E FD 2E 00 00   mov32 cb, $00000000
0661   0822 00 00 
0662   0824 FD AF         cmp32 ga, cb
0663   0826 FD 7F         sgt
0664   0828 FD F1         pop g
0665   082A E4            pop a
0666   082B             ; --- END RELATIONAL
0667   082B C0 00 00      cmp b, 0
0668   082E C6 AF 08      je _while10_exit
0669   0831             _while10_block:
0670   0831             ; digits[i] = '0' + (num % 10); 
0671   0831 FA F7 FF      lea d, [bp + -9] ; $digits
0672   0834 D7            push a
0673   0835 DA            push d
0674   0836 FA F5 FF      lea d, [bp + -11] ; $i
0675   0839 2A            mov b, [d]
0676   083A 38 00 00      mov c, 0
0677   083D E7            pop d
0678   083E 5A            add d, b
0679   083F E4            pop a
0680   0840 DA            push d
0681   0841 FD 2E 30 00   mov32 cb, $00000030
0681   0845 00 00 
0682   0847             ; --- START TERMS
0683   0847 D7            push a
0684   0848 11            mov a, b
0685   0849 FA 05 00      lea d, [bp + 5] ; $num
0686   084C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0687   084F FD 39         mov c, b ; And place it into C
0688   0851 2A            mov b, [d] ; Lower Word in B
0689   0852             ; --- START FACTORS
0690   0852 D7            push a
0691   0853 FD D8         push g
0692   0855 11            mov a, b
0693   0856 FD 7A         mov g, c
0694   0858 FD 2E 0A 00   mov32 cb, $0000000a
0694   085C 00 00 
0695   085E FD D8         push g ; save 'g' as the div instruction uses it
0696   0860 AE            div a, b ; %, a: quotient, b: remainder
0697   0861 11            mov a, b
0698   0862 FD F1         pop g
0699   0864 FD 38         mov c, g
0700   0866 27            mov b, a
0701   0867 FD F1         pop g
0702   0869 E4            pop a
0703   086A             ; --- END FACTORS
0704   086A FD 15         add32 cb, ga
0705   086C E4            pop a
0706   086D             ; --- END TERMS
0707   086D E7            pop d
0708   086E FD 3E         mov [d], bl
0709   0870             ; num = num / 10; 
0710   0870 FA 05 00      lea d, [bp + 5] ; $num
0711   0873 DA            push d
0712   0874 FA 05 00      lea d, [bp + 5] ; $num
0713   0877 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0714   087A FD 39         mov c, b ; And place it into C
0715   087C 2A            mov b, [d] ; Lower Word in B
0716   087D             ; --- START FACTORS
0717   087D D7            push a
0718   087E FD D8         push g
0719   0880 11            mov a, b
0720   0881 FD 7A         mov g, c
0721   0883 FD 2E 0A 00   mov32 cb, $0000000a
0721   0887 00 00 
0722   0889 FD D8         push g ; save 'g' as the div instruction uses it
0723   088B AE            div a, b ; /, a: quotient, b: remainder
0724   088C FD F1         pop g
0725   088E FD 38         mov c, g
0726   0890 27            mov b, a
0727   0891 FD F1         pop g
0728   0893 E4            pop a
0729   0894             ; --- END FACTORS
0730   0894 E7            pop d
0731   0895 FD 43         mov [d], b
0732   0897 28            mov b, c
0733   0898 FD 44 02 00   mov [d + 2], b
0734   089C             ; i++; 
0735   089C FA F5 FF      lea d, [bp + -11] ; $i
0736   089F 2A            mov b, [d]
0737   08A0 38 00 00      mov c, 0
0738   08A3 11            mov a, b
0739   08A4 FD 77         inc b
0740   08A6 FA F5 FF      lea d, [bp + -11] ; $i
0741   08A9 FD 43         mov [d], b
0742   08AB 27            mov b, a
0743   08AC 0A 0F 08      jmp _while10_cond
0744   08AF             _while10_exit:
0745   08AF             ; while (i > 0) { 
0746   08AF             _while17_cond:
0747   08AF FA F5 FF      lea d, [bp + -11] ; $i
0748   08B2 2A            mov b, [d]
0749   08B3 38 00 00      mov c, 0
0750   08B6             ; --- START RELATIONAL
0751   08B6 D7            push a
0752   08B7 11            mov a, b
0753   08B8 FD 2E 00 00   mov32 cb, $00000000
0753   08BC 00 00 
0754   08BE B0            cmp a, b
0755   08BF FD 7F         sgt ; >
0756   08C1 E4            pop a
0757   08C2             ; --- END RELATIONAL
0758   08C2 C0 00 00      cmp b, 0
0759   08C5 C6 F7 08      je _while17_exit
0760   08C8             _while17_block:
0761   08C8             ; i--; 
0762   08C8 FA F5 FF      lea d, [bp + -11] ; $i
0763   08CB 2A            mov b, [d]
0764   08CC 38 00 00      mov c, 0
0765   08CF 11            mov a, b
0766   08D0 FD 7D         dec b
0767   08D2 FA F5 FF      lea d, [bp + -11] ; $i
0768   08D5 FD 43         mov [d], b
0769   08D7 27            mov b, a
0770   08D8             ; putchar(digits[i]); 
0771   08D8             ; --- START FUNCTION CALL
0772   08D8 FA F7 FF      lea d, [bp + -9] ; $digits
0773   08DB D7            push a
0774   08DC DA            push d
0775   08DD FA F5 FF      lea d, [bp + -11] ; $i
0776   08E0 2A            mov b, [d]
0777   08E1 38 00 00      mov c, 0
0778   08E4 E7            pop d
0779   08E5 5A            add d, b
0780   08E6 E4            pop a
0781   08E7 32            mov bl, [d]
0782   08E8 A7 00         mov bh, 0
0783   08EA 38 00 00      mov c, 0
0784   08ED DD            push bl
0785   08EE 07 F9 08      call putchar
0786   08F1 51 01 00      add sp, 1
0787   08F4             ; --- END FUNCTION CALL
0788   08F4 0A AF 08      jmp _while17_cond
0789   08F7             _while17_exit:
0790   08F7 F9            leave
0791   08F8 09            ret
0792   08F9             
0793   08F9             putchar:
0794   08F9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0795   08FC             ; --- BEGIN INLINE ASM SEGMENT
0796   08FC FA 05 00      lea d, [bp + 5] ; $c
0797   08FF 1E            mov al, [d]
0798   0900 23            mov ah, al
0799   0901 19 00         mov al, 0
0800   0903 05 03         syscall sys_io      ; char in AH
0801   0905             ; --- END INLINE ASM SEGMENT
0802   0905 F9            leave
0803   0906 09            ret
0804   0907             
0805   0907             print_unsigned_long:
0806   0907 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0807   090A             ; char digits[10]; 
0808   090A 52 0A 00      sub sp, 10
0809   090D             ; int i; 
0810   090D 52 02 00      sub sp, 2
0811   0910             ; i = 0; 
0812   0910 FA F5 FF      lea d, [bp + -11] ; $i
0813   0913 DA            push d
0814   0914 FD 2E 00 00   mov32 cb, $00000000
0814   0918 00 00 
0815   091A E7            pop d
0816   091B FD 43         mov [d], b
0817   091D             ; if(num == 0){ 
0818   091D             _if18_cond:
0819   091D FA 05 00      lea d, [bp + 5] ; $num
0820   0920 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0821   0923 FD 39         mov c, b ; And place it into C
0822   0925 2A            mov b, [d] ; Lower Word in B
0823   0926             ; --- START RELATIONAL
0824   0926 D7            push a
0825   0927 FD D8         push g
0826   0929 11            mov a, b
0827   092A FD 7A         mov g, c
0828   092C FD 2E 00 00   mov32 cb, $00000000
0828   0930 00 00 
0829   0932 FD AF         cmp32 ga, cb
0830   0934 FD 71         seq ; ==
0831   0936 FD F1         pop g
0832   0938 E4            pop a
0833   0939             ; --- END RELATIONAL
0834   0939 C0 00 00      cmp b, 0
0835   093C C6 51 09      je _if18_exit
0836   093F             _if18_TRUE:
0837   093F             ; putchar('0'); 
0838   093F             ; --- START FUNCTION CALL
0839   093F FD 2E 30 00   mov32 cb, $00000030
0839   0943 00 00 
0840   0945 DD            push bl
0841   0946 07 F9 08      call putchar
0842   0949 51 01 00      add sp, 1
0843   094C             ; --- END FUNCTION CALL
0844   094C             ; return; 
0845   094C F9            leave
0846   094D 09            ret
0847   094E 0A 51 09      jmp _if18_exit
0848   0951             _if18_exit:
0849   0951             ; while (num > 0) { 
0850   0951             _while19_cond:
0851   0951 FA 05 00      lea d, [bp + 5] ; $num
0852   0954 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0853   0957 FD 39         mov c, b ; And place it into C
0854   0959 2A            mov b, [d] ; Lower Word in B
0855   095A             ; --- START RELATIONAL
0856   095A D7            push a
0857   095B FD D8         push g
0858   095D 11            mov a, b
0859   095E FD 7A         mov g, c
0860   0960 FD 2E 00 00   mov32 cb, $00000000
0860   0964 00 00 
0861   0966 FD AF         cmp32 ga, cb
0862   0968 FD 81         sgu
0863   096A FD F1         pop g
0864   096C E4            pop a
0865   096D             ; --- END RELATIONAL
0866   096D C0 00 00      cmp b, 0
0867   0970 C6 F1 09      je _while19_exit
0868   0973             _while19_block:
0869   0973             ; digits[i] = '0' + (num % 10); 
0870   0973 FA F7 FF      lea d, [bp + -9] ; $digits
0871   0976 D7            push a
0872   0977 DA            push d
0873   0978 FA F5 FF      lea d, [bp + -11] ; $i
0874   097B 2A            mov b, [d]
0875   097C 38 00 00      mov c, 0
0876   097F E7            pop d
0877   0980 5A            add d, b
0878   0981 E4            pop a
0879   0982 DA            push d
0880   0983 FD 2E 30 00   mov32 cb, $00000030
0880   0987 00 00 
0881   0989             ; --- START TERMS
0882   0989 D7            push a
0883   098A 11            mov a, b
0884   098B FA 05 00      lea d, [bp + 5] ; $num
0885   098E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0886   0991 FD 39         mov c, b ; And place it into C
0887   0993 2A            mov b, [d] ; Lower Word in B
0888   0994             ; --- START FACTORS
0889   0994 D7            push a
0890   0995 FD D8         push g
0891   0997 11            mov a, b
0892   0998 FD 7A         mov g, c
0893   099A FD 2E 0A 00   mov32 cb, $0000000a
0893   099E 00 00 
0894   09A0 FD D8         push g ; save 'g' as the div instruction uses it
0895   09A2 AE            div a, b ; %, a: quotient, b: remainder
0896   09A3 11            mov a, b
0897   09A4 FD F1         pop g
0898   09A6 FD 38         mov c, g
0899   09A8 27            mov b, a
0900   09A9 FD F1         pop g
0901   09AB E4            pop a
0902   09AC             ; --- END FACTORS
0903   09AC FD 15         add32 cb, ga
0904   09AE E4            pop a
0905   09AF             ; --- END TERMS
0906   09AF E7            pop d
0907   09B0 FD 3E         mov [d], bl
0908   09B2             ; num = num / 10; 
0909   09B2 FA 05 00      lea d, [bp + 5] ; $num
0910   09B5 DA            push d
0911   09B6 FA 05 00      lea d, [bp + 5] ; $num
0912   09B9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0913   09BC FD 39         mov c, b ; And place it into C
0914   09BE 2A            mov b, [d] ; Lower Word in B
0915   09BF             ; --- START FACTORS
0916   09BF D7            push a
0917   09C0 FD D8         push g
0918   09C2 11            mov a, b
0919   09C3 FD 7A         mov g, c
0920   09C5 FD 2E 0A 00   mov32 cb, $0000000a
0920   09C9 00 00 
0921   09CB FD D8         push g ; save 'g' as the div instruction uses it
0922   09CD AE            div a, b ; /, a: quotient, b: remainder
0923   09CE FD F1         pop g
0924   09D0 FD 38         mov c, g
0925   09D2 27            mov b, a
0926   09D3 FD F1         pop g
0927   09D5 E4            pop a
0928   09D6             ; --- END FACTORS
0929   09D6 E7            pop d
0930   09D7 FD 43         mov [d], b
0931   09D9 28            mov b, c
0932   09DA FD 44 02 00   mov [d + 2], b
0933   09DE             ; i++; 
0934   09DE FA F5 FF      lea d, [bp + -11] ; $i
0935   09E1 2A            mov b, [d]
0936   09E2 38 00 00      mov c, 0
0937   09E5 11            mov a, b
0938   09E6 FD 77         inc b
0939   09E8 FA F5 FF      lea d, [bp + -11] ; $i
0940   09EB FD 43         mov [d], b
0941   09ED 27            mov b, a
0942   09EE 0A 51 09      jmp _while19_cond
0943   09F1             _while19_exit:
0944   09F1             ; while (i > 0) { 
0945   09F1             _while26_cond:
0946   09F1 FA F5 FF      lea d, [bp + -11] ; $i
0947   09F4 2A            mov b, [d]
0948   09F5 38 00 00      mov c, 0
0949   09F8             ; --- START RELATIONAL
0950   09F8 D7            push a
0951   09F9 11            mov a, b
0952   09FA FD 2E 00 00   mov32 cb, $00000000
0952   09FE 00 00 
0953   0A00 B0            cmp a, b
0954   0A01 FD 7F         sgt ; >
0955   0A03 E4            pop a
0956   0A04             ; --- END RELATIONAL
0957   0A04 C0 00 00      cmp b, 0
0958   0A07 C6 39 0A      je _while26_exit
0959   0A0A             _while26_block:
0960   0A0A             ; i--; 
0961   0A0A FA F5 FF      lea d, [bp + -11] ; $i
0962   0A0D 2A            mov b, [d]
0963   0A0E 38 00 00      mov c, 0
0964   0A11 11            mov a, b
0965   0A12 FD 7D         dec b
0966   0A14 FA F5 FF      lea d, [bp + -11] ; $i
0967   0A17 FD 43         mov [d], b
0968   0A19 27            mov b, a
0969   0A1A             ; putchar(digits[i]); 
0970   0A1A             ; --- START FUNCTION CALL
0971   0A1A FA F7 FF      lea d, [bp + -9] ; $digits
0972   0A1D D7            push a
0973   0A1E DA            push d
0974   0A1F FA F5 FF      lea d, [bp + -11] ; $i
0975   0A22 2A            mov b, [d]
0976   0A23 38 00 00      mov c, 0
0977   0A26 E7            pop d
0978   0A27 5A            add d, b
0979   0A28 E4            pop a
0980   0A29 32            mov bl, [d]
0981   0A2A A7 00         mov bh, 0
0982   0A2C 38 00 00      mov c, 0
0983   0A2F DD            push bl
0984   0A30 07 F9 08      call putchar
0985   0A33 51 01 00      add sp, 1
0986   0A36             ; --- END FUNCTION CALL
0987   0A36 0A F1 09      jmp _while26_cond
0988   0A39             _while26_exit:
0989   0A39 F9            leave
0990   0A3A 09            ret
0991   0A3B             
0992   0A3B             printx32:
0993   0A3B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0994   0A3E             ; --- BEGIN INLINE ASM SEGMENT
0995   0A3E FA 05 00      lea d, [bp + 5] ; $hex
0996   0A41 2B 02 00      mov b, [d+2]
0997   0A44 07 4D 0A      call print_u16x_printx32
0998   0A47 2A            mov b, [d]
0999   0A48 07 4D 0A      call print_u16x_printx32
1000   0A4B             ; --- END INLINE ASM SEGMENT
1001   0A4B             ; return; 
1002   0A4B F9            leave
1003   0A4C 09            ret
1004   0A4D             ; --- BEGIN INLINE ASM SEGMENT
1005   0A4D             print_u16x_printx32:
1006   0A4D D7            push a
1007   0A4E D8            push b
1008   0A4F DD            push bl
1009   0A50 30            mov bl, bh
1010   0A51 07 6F 0A      call _itoa_printx32        ; convert bh to char in A
1011   0A54 2F            mov bl, al        ; save al
1012   0A55 19 00         mov al, 0
1013   0A57 05 03         syscall sys_io        ; display AH
1014   0A59 24            mov ah, bl        ; retrieve al
1015   0A5A 19 00         mov al, 0
1016   0A5C 05 03         syscall sys_io        ; display AL
1017   0A5E EA            pop bl
1018   0A5F 07 6F 0A      call _itoa_printx32        ; convert bh to char in A
1019   0A62 2F            mov bl, al        ; save al
1020   0A63 19 00         mov al, 0
1021   0A65 05 03         syscall sys_io        ; display AH
1022   0A67 24            mov ah, bl        ; retrieve al
1023   0A68 19 00         mov al, 0
1024   0A6A 05 03         syscall sys_io        ; display AL
1025   0A6C E5            pop b
1026   0A6D E4            pop a
1027   0A6E 09            ret
1028   0A6F             _itoa_printx32:
1029   0A6F DA            push d
1030   0A70 D8            push b
1031   0A71 A7 00         mov bh, 0
1032   0A73 FD A4 04      shr bl, 4  
1033   0A76 74            mov d, b
1034   0A77 1F 89 0A      mov al, [d + s_hex_digits_printx32]
1035   0A7A 23            mov ah, al
1036   0A7B E5            pop b
1037   0A7C D8            push b
1038   0A7D A7 00         mov bh, 0
1039   0A7F FD 87 0F      and bl, $0F
1040   0A82 74            mov d, b
1041   0A83 1F 89 0A      mov al, [d + s_hex_digits_printx32]
1042   0A86 E5            pop b
1043   0A87 E7            pop d
1044   0A88 09            ret
1045   0A89 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1045   0A8D 34 35 36 37 
1045   0A91 38 39 41 42 
1045   0A95 43 44 45 46 
1046   0A99             ; --- END INLINE ASM SEGMENT
1047   0A99 F9            leave
1048   0A9A 09            ret
1049   0A9B             
1050   0A9B             err:
1051   0A9B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1052   0A9E             ; print(e); 
1053   0A9E             ; --- START FUNCTION CALL
1054   0A9E FA 05 00      lea d, [bp + 5] ; $e
1055   0AA1 2A            mov b, [d]
1056   0AA2 38 00 00      mov c, 0
1057   0AA5 FD AB         swp b
1058   0AA7 D8            push b
1059   0AA8 07 B0 0A      call print
1060   0AAB 51 02 00      add sp, 2
1061   0AAE             ; --- END FUNCTION CALL
1062   0AAE F9            leave
1063   0AAF 09            ret
1064   0AB0             
1065   0AB0             print:
1066   0AB0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1067   0AB3             ; --- BEGIN INLINE ASM SEGMENT
1068   0AB3 FA 05 00      lea d, [bp + 5] ; $s
1069   0AB6 FD 2A         mov d, [d]
1070   0AB8             _puts_L1_print:
1071   0AB8 1E            mov al, [d]
1072   0AB9 B9 00         cmp al, 0
1073   0ABB C6 C7 0A      jz _puts_END_print
1074   0ABE 23            mov ah, al
1075   0ABF 19 00         mov al, 0
1076   0AC1 05 03         syscall sys_io
1077   0AC3 79            inc d
1078   0AC4 0A B8 0A      jmp _puts_L1_print
1079   0AC7             _puts_END_print:
1080   0AC7             ; --- END INLINE ASM SEGMENT
1081   0AC7 F9            leave
1082   0AC8 09            ret
1083   0AC9             
1084   0AC9             print_signed:
1085   0AC9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1086   0ACC             ; char digits[5]; 
1087   0ACC 52 05 00      sub sp, 5
1088   0ACF             ; int i = 0; 
1089   0ACF 52 02 00      sub sp, 2
1090   0AD2             ; --- START LOCAL VAR INITIALIZATION
1091   0AD2 FA FA FF      lea d, [bp + -6] ; $i
1092   0AD5 DA            push d
1093   0AD6 FD 2E 00 00   mov32 cb, $00000000
1093   0ADA 00 00 
1094   0ADC E7            pop d
1095   0ADD FD 43         mov [d], b
1096   0ADF             ; --- END LOCAL VAR INITIALIZATION
1097   0ADF             ; if (num < 0) { 
1098   0ADF             _if27_cond:
1099   0ADF FA 05 00      lea d, [bp + 5] ; $num
1100   0AE2 2A            mov b, [d]
1101   0AE3 38 00 00      mov c, 0
1102   0AE6             ; --- START RELATIONAL
1103   0AE6 D7            push a
1104   0AE7 11            mov a, b
1105   0AE8 FD 2E 00 00   mov32 cb, $00000000
1105   0AEC 00 00 
1106   0AEE B0            cmp a, b
1107   0AEF FD 73         slt ; < (signed)
1108   0AF1 E4            pop a
1109   0AF2             ; --- END RELATIONAL
1110   0AF2 C0 00 00      cmp b, 0
1111   0AF5 C6 18 0B      je _if27_else
1112   0AF8             _if27_TRUE:
1113   0AF8             ; putchar('-'); 
1114   0AF8             ; --- START FUNCTION CALL
1115   0AF8 FD 2E 2D 00   mov32 cb, $0000002d
1115   0AFC 00 00 
1116   0AFE DD            push bl
1117   0AFF 07 F9 08      call putchar
1118   0B02 51 01 00      add sp, 1
1119   0B05             ; --- END FUNCTION CALL
1120   0B05             ; num = -num; 
1121   0B05 FA 05 00      lea d, [bp + 5] ; $num
1122   0B08 DA            push d
1123   0B09 FA 05 00      lea d, [bp + 5] ; $num
1124   0B0C 2A            mov b, [d]
1125   0B0D 38 00 00      mov c, 0
1126   0B10 FD 97         neg b
1127   0B12 E7            pop d
1128   0B13 FD 43         mov [d], b
1129   0B15 0A 43 0B      jmp _if27_exit
1130   0B18             _if27_else:
1131   0B18             ; if (num == 0) { 
1132   0B18             _if28_cond:
1133   0B18 FA 05 00      lea d, [bp + 5] ; $num
1134   0B1B 2A            mov b, [d]
1135   0B1C 38 00 00      mov c, 0
1136   0B1F             ; --- START RELATIONAL
1137   0B1F D7            push a
1138   0B20 11            mov a, b
1139   0B21 FD 2E 00 00   mov32 cb, $00000000
1139   0B25 00 00 
1140   0B27 B0            cmp a, b
1141   0B28 FD 71         seq ; ==
1142   0B2A E4            pop a
1143   0B2B             ; --- END RELATIONAL
1144   0B2B C0 00 00      cmp b, 0
1145   0B2E C6 43 0B      je _if28_exit
1146   0B31             _if28_TRUE:
1147   0B31             ; putchar('0'); 
1148   0B31             ; --- START FUNCTION CALL
1149   0B31 FD 2E 30 00   mov32 cb, $00000030
1149   0B35 00 00 
1150   0B37 DD            push bl
1151   0B38 07 F9 08      call putchar
1152   0B3B 51 01 00      add sp, 1
1153   0B3E             ; --- END FUNCTION CALL
1154   0B3E             ; return; 
1155   0B3E F9            leave
1156   0B3F 09            ret
1157   0B40 0A 43 0B      jmp _if28_exit
1158   0B43             _if28_exit:
1159   0B43             _if27_exit:
1160   0B43             ; while (num > 0) { 
1161   0B43             _while29_cond:
1162   0B43 FA 05 00      lea d, [bp + 5] ; $num
1163   0B46 2A            mov b, [d]
1164   0B47 38 00 00      mov c, 0
1165   0B4A             ; --- START RELATIONAL
1166   0B4A D7            push a
1167   0B4B 11            mov a, b
1168   0B4C FD 2E 00 00   mov32 cb, $00000000
1168   0B50 00 00 
1169   0B52 B0            cmp a, b
1170   0B53 FD 7F         sgt ; >
1171   0B55 E4            pop a
1172   0B56             ; --- END RELATIONAL
1173   0B56 C0 00 00      cmp b, 0
1174   0B59 C6 D0 0B      je _while29_exit
1175   0B5C             _while29_block:
1176   0B5C             ; digits[i] = '0' + (num % 10); 
1177   0B5C FA FC FF      lea d, [bp + -4] ; $digits
1178   0B5F D7            push a
1179   0B60 DA            push d
1180   0B61 FA FA FF      lea d, [bp + -6] ; $i
1181   0B64 2A            mov b, [d]
1182   0B65 38 00 00      mov c, 0
1183   0B68 E7            pop d
1184   0B69 5A            add d, b
1185   0B6A E4            pop a
1186   0B6B DA            push d
1187   0B6C FD 2E 30 00   mov32 cb, $00000030
1187   0B70 00 00 
1188   0B72             ; --- START TERMS
1189   0B72 D7            push a
1190   0B73 11            mov a, b
1191   0B74 FA 05 00      lea d, [bp + 5] ; $num
1192   0B77 2A            mov b, [d]
1193   0B78 38 00 00      mov c, 0
1194   0B7B             ; --- START FACTORS
1195   0B7B D7            push a
1196   0B7C FD D8         push g
1197   0B7E 11            mov a, b
1198   0B7F FD 7A         mov g, c
1199   0B81 FD 2E 0A 00   mov32 cb, $0000000a
1199   0B85 00 00 
1200   0B87 FD D8         push g ; save 'g' as the div instruction uses it
1201   0B89 AE            div a, b ; %, a: quotient, b: remainder
1202   0B8A 11            mov a, b
1203   0B8B FD F1         pop g
1204   0B8D FD 38         mov c, g
1205   0B8F 27            mov b, a
1206   0B90 FD F1         pop g
1207   0B92 E4            pop a
1208   0B93             ; --- END FACTORS
1209   0B93 56            add b, a
1210   0B94 E4            pop a
1211   0B95             ; --- END TERMS
1212   0B95 E7            pop d
1213   0B96 FD 3E         mov [d], bl
1214   0B98             ; num = num / 10; 
1215   0B98 FA 05 00      lea d, [bp + 5] ; $num
1216   0B9B DA            push d
1217   0B9C FA 05 00      lea d, [bp + 5] ; $num
1218   0B9F 2A            mov b, [d]
1219   0BA0 38 00 00      mov c, 0
1220   0BA3             ; --- START FACTORS
1221   0BA3 D7            push a
1222   0BA4 FD D8         push g
1223   0BA6 11            mov a, b
1224   0BA7 FD 7A         mov g, c
1225   0BA9 FD 2E 0A 00   mov32 cb, $0000000a
1225   0BAD 00 00 
1226   0BAF FD D8         push g ; save 'g' as the div instruction uses it
1227   0BB1 AE            div a, b ; /, a: quotient, b: remainder
1228   0BB2 FD F1         pop g
1229   0BB4 FD 38         mov c, g
1230   0BB6 27            mov b, a
1231   0BB7 FD F1         pop g
1232   0BB9 E4            pop a
1233   0BBA             ; --- END FACTORS
1234   0BBA E7            pop d
1235   0BBB FD 43         mov [d], b
1236   0BBD             ; i++; 
1237   0BBD FA FA FF      lea d, [bp + -6] ; $i
1238   0BC0 2A            mov b, [d]
1239   0BC1 38 00 00      mov c, 0
1240   0BC4 11            mov a, b
1241   0BC5 FD 77         inc b
1242   0BC7 FA FA FF      lea d, [bp + -6] ; $i
1243   0BCA FD 43         mov [d], b
1244   0BCC 27            mov b, a
1245   0BCD 0A 43 0B      jmp _while29_cond
1246   0BD0             _while29_exit:
1247   0BD0             ; while (i > 0) { 
1248   0BD0             _while36_cond:
1249   0BD0 FA FA FF      lea d, [bp + -6] ; $i
1250   0BD3 2A            mov b, [d]
1251   0BD4 38 00 00      mov c, 0
1252   0BD7             ; --- START RELATIONAL
1253   0BD7 D7            push a
1254   0BD8 11            mov a, b
1255   0BD9 FD 2E 00 00   mov32 cb, $00000000
1255   0BDD 00 00 
1256   0BDF B0            cmp a, b
1257   0BE0 FD 7F         sgt ; >
1258   0BE2 E4            pop a
1259   0BE3             ; --- END RELATIONAL
1260   0BE3 C0 00 00      cmp b, 0
1261   0BE6 C6 18 0C      je _while36_exit
1262   0BE9             _while36_block:
1263   0BE9             ; i--; 
1264   0BE9 FA FA FF      lea d, [bp + -6] ; $i
1265   0BEC 2A            mov b, [d]
1266   0BED 38 00 00      mov c, 0
1267   0BF0 11            mov a, b
1268   0BF1 FD 7D         dec b
1269   0BF3 FA FA FF      lea d, [bp + -6] ; $i
1270   0BF6 FD 43         mov [d], b
1271   0BF8 27            mov b, a
1272   0BF9             ; putchar(digits[i]); 
1273   0BF9             ; --- START FUNCTION CALL
1274   0BF9 FA FC FF      lea d, [bp + -4] ; $digits
1275   0BFC D7            push a
1276   0BFD DA            push d
1277   0BFE FA FA FF      lea d, [bp + -6] ; $i
1278   0C01 2A            mov b, [d]
1279   0C02 38 00 00      mov c, 0
1280   0C05 E7            pop d
1281   0C06 5A            add d, b
1282   0C07 E4            pop a
1283   0C08 32            mov bl, [d]
1284   0C09 A7 00         mov bh, 0
1285   0C0B 38 00 00      mov c, 0
1286   0C0E DD            push bl
1287   0C0F 07 F9 08      call putchar
1288   0C12 51 01 00      add sp, 1
1289   0C15             ; --- END FUNCTION CALL
1290   0C15 0A D0 0B      jmp _while36_cond
1291   0C18             _while36_exit:
1292   0C18 F9            leave
1293   0C19 09            ret
1294   0C1A             
1295   0C1A             print_unsigned:
1296   0C1A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1297   0C1D             ; char digits[5]; 
1298   0C1D 52 05 00      sub sp, 5
1299   0C20             ; int i; 
1300   0C20 52 02 00      sub sp, 2
1301   0C23             ; i = 0; 
1302   0C23 FA FA FF      lea d, [bp + -6] ; $i
1303   0C26 DA            push d
1304   0C27 FD 2E 00 00   mov32 cb, $00000000
1304   0C2B 00 00 
1305   0C2D E7            pop d
1306   0C2E FD 43         mov [d], b
1307   0C30             ; if(num == 0){ 
1308   0C30             _if37_cond:
1309   0C30 FA 05 00      lea d, [bp + 5] ; $num
1310   0C33 2A            mov b, [d]
1311   0C34 38 00 00      mov c, 0
1312   0C37             ; --- START RELATIONAL
1313   0C37 D7            push a
1314   0C38 11            mov a, b
1315   0C39 FD 2E 00 00   mov32 cb, $00000000
1315   0C3D 00 00 
1316   0C3F B0            cmp a, b
1317   0C40 FD 71         seq ; ==
1318   0C42 E4            pop a
1319   0C43             ; --- END RELATIONAL
1320   0C43 C0 00 00      cmp b, 0
1321   0C46 C6 5B 0C      je _if37_exit
1322   0C49             _if37_TRUE:
1323   0C49             ; putchar('0'); 
1324   0C49             ; --- START FUNCTION CALL
1325   0C49 FD 2E 30 00   mov32 cb, $00000030
1325   0C4D 00 00 
1326   0C4F DD            push bl
1327   0C50 07 F9 08      call putchar
1328   0C53 51 01 00      add sp, 1
1329   0C56             ; --- END FUNCTION CALL
1330   0C56             ; return; 
1331   0C56 F9            leave
1332   0C57 09            ret
1333   0C58 0A 5B 0C      jmp _if37_exit
1334   0C5B             _if37_exit:
1335   0C5B             ; while (num > 0) { 
1336   0C5B             _while38_cond:
1337   0C5B FA 05 00      lea d, [bp + 5] ; $num
1338   0C5E 2A            mov b, [d]
1339   0C5F 38 00 00      mov c, 0
1340   0C62             ; --- START RELATIONAL
1341   0C62 D7            push a
1342   0C63 11            mov a, b
1343   0C64 FD 2E 00 00   mov32 cb, $00000000
1343   0C68 00 00 
1344   0C6A B0            cmp a, b
1345   0C6B FD 81         sgu ; > (unsigned)
1346   0C6D E4            pop a
1347   0C6E             ; --- END RELATIONAL
1348   0C6E C0 00 00      cmp b, 0
1349   0C71 C6 E8 0C      je _while38_exit
1350   0C74             _while38_block:
1351   0C74             ; digits[i] = '0' + (num % 10); 
1352   0C74 FA FC FF      lea d, [bp + -4] ; $digits
1353   0C77 D7            push a
1354   0C78 DA            push d
1355   0C79 FA FA FF      lea d, [bp + -6] ; $i
1356   0C7C 2A            mov b, [d]
1357   0C7D 38 00 00      mov c, 0
1358   0C80 E7            pop d
1359   0C81 5A            add d, b
1360   0C82 E4            pop a
1361   0C83 DA            push d
1362   0C84 FD 2E 30 00   mov32 cb, $00000030
1362   0C88 00 00 
1363   0C8A             ; --- START TERMS
1364   0C8A D7            push a
1365   0C8B 11            mov a, b
1366   0C8C FA 05 00      lea d, [bp + 5] ; $num
1367   0C8F 2A            mov b, [d]
1368   0C90 38 00 00      mov c, 0
1369   0C93             ; --- START FACTORS
1370   0C93 D7            push a
1371   0C94 FD D8         push g
1372   0C96 11            mov a, b
1373   0C97 FD 7A         mov g, c
1374   0C99 FD 2E 0A 00   mov32 cb, $0000000a
1374   0C9D 00 00 
1375   0C9F FD D8         push g ; save 'g' as the div instruction uses it
1376   0CA1 AE            div a, b ; %, a: quotient, b: remainder
1377   0CA2 11            mov a, b
1378   0CA3 FD F1         pop g
1379   0CA5 FD 38         mov c, g
1380   0CA7 27            mov b, a
1381   0CA8 FD F1         pop g
1382   0CAA E4            pop a
1383   0CAB             ; --- END FACTORS
1384   0CAB 56            add b, a
1385   0CAC E4            pop a
1386   0CAD             ; --- END TERMS
1387   0CAD E7            pop d
1388   0CAE FD 3E         mov [d], bl
1389   0CB0             ; num = num / 10; 
1390   0CB0 FA 05 00      lea d, [bp + 5] ; $num
1391   0CB3 DA            push d
1392   0CB4 FA 05 00      lea d, [bp + 5] ; $num
1393   0CB7 2A            mov b, [d]
1394   0CB8 38 00 00      mov c, 0
1395   0CBB             ; --- START FACTORS
1396   0CBB D7            push a
1397   0CBC FD D8         push g
1398   0CBE 11            mov a, b
1399   0CBF FD 7A         mov g, c
1400   0CC1 FD 2E 0A 00   mov32 cb, $0000000a
1400   0CC5 00 00 
1401   0CC7 FD D8         push g ; save 'g' as the div instruction uses it
1402   0CC9 AE            div a, b ; /, a: quotient, b: remainder
1403   0CCA FD F1         pop g
1404   0CCC FD 38         mov c, g
1405   0CCE 27            mov b, a
1406   0CCF FD F1         pop g
1407   0CD1 E4            pop a
1408   0CD2             ; --- END FACTORS
1409   0CD2 E7            pop d
1410   0CD3 FD 43         mov [d], b
1411   0CD5             ; i++; 
1412   0CD5 FA FA FF      lea d, [bp + -6] ; $i
1413   0CD8 2A            mov b, [d]
1414   0CD9 38 00 00      mov c, 0
1415   0CDC 11            mov a, b
1416   0CDD FD 77         inc b
1417   0CDF FA FA FF      lea d, [bp + -6] ; $i
1418   0CE2 FD 43         mov [d], b
1419   0CE4 27            mov b, a
1420   0CE5 0A 5B 0C      jmp _while38_cond
1421   0CE8             _while38_exit:
1422   0CE8             ; while (i > 0) { 
1423   0CE8             _while45_cond:
1424   0CE8 FA FA FF      lea d, [bp + -6] ; $i
1425   0CEB 2A            mov b, [d]
1426   0CEC 38 00 00      mov c, 0
1427   0CEF             ; --- START RELATIONAL
1428   0CEF D7            push a
1429   0CF0 11            mov a, b
1430   0CF1 FD 2E 00 00   mov32 cb, $00000000
1430   0CF5 00 00 
1431   0CF7 B0            cmp a, b
1432   0CF8 FD 7F         sgt ; >
1433   0CFA E4            pop a
1434   0CFB             ; --- END RELATIONAL
1435   0CFB C0 00 00      cmp b, 0
1436   0CFE C6 30 0D      je _while45_exit
1437   0D01             _while45_block:
1438   0D01             ; i--; 
1439   0D01 FA FA FF      lea d, [bp + -6] ; $i
1440   0D04 2A            mov b, [d]
1441   0D05 38 00 00      mov c, 0
1442   0D08 11            mov a, b
1443   0D09 FD 7D         dec b
1444   0D0B FA FA FF      lea d, [bp + -6] ; $i
1445   0D0E FD 43         mov [d], b
1446   0D10 27            mov b, a
1447   0D11             ; putchar(digits[i]); 
1448   0D11             ; --- START FUNCTION CALL
1449   0D11 FA FC FF      lea d, [bp + -4] ; $digits
1450   0D14 D7            push a
1451   0D15 DA            push d
1452   0D16 FA FA FF      lea d, [bp + -6] ; $i
1453   0D19 2A            mov b, [d]
1454   0D1A 38 00 00      mov c, 0
1455   0D1D E7            pop d
1456   0D1E 5A            add d, b
1457   0D1F E4            pop a
1458   0D20 32            mov bl, [d]
1459   0D21 A7 00         mov bh, 0
1460   0D23 38 00 00      mov c, 0
1461   0D26 DD            push bl
1462   0D27 07 F9 08      call putchar
1463   0D2A 51 01 00      add sp, 1
1464   0D2D             ; --- END FUNCTION CALL
1465   0D2D 0A E8 0C      jmp _while45_cond
1466   0D30             _while45_exit:
1467   0D30 F9            leave
1468   0D31 09            ret
1469   0D32             
1470   0D32             printx16:
1471   0D32 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1472   0D35             ; --- BEGIN INLINE ASM SEGMENT
1473   0D35 FA 05 00      lea d, [bp + 5] ; $hex
1474   0D38 2A            mov b, [d]
1475   0D39             print_u16x_printx16:
1476   0D39 DD            push bl
1477   0D3A 30            mov bl, bh
1478   0D3B 07 58 0D      call _itoa_printx16        ; convert bh to char in A
1479   0D3E 2F            mov bl, al        ; save al
1480   0D3F 19 00         mov al, 0
1481   0D41 05 03         syscall sys_io        ; display AH
1482   0D43 24            mov ah, bl        ; retrieve al
1483   0D44 19 00         mov al, 0
1484   0D46 05 03         syscall sys_io        ; display AL
1485   0D48 EA            pop bl
1486   0D49 07 58 0D      call _itoa_printx16        ; convert bh to char in A
1487   0D4C 2F            mov bl, al        ; save al
1488   0D4D 19 00         mov al, 0
1489   0D4F 05 03         syscall sys_io        ; display AH
1490   0D51 24            mov ah, bl        ; retrieve al
1491   0D52 19 00         mov al, 0
1492   0D54 05 03         syscall sys_io        ; display AL
1493   0D56             ; --- END INLINE ASM SEGMENT
1494   0D56             ; return; 
1495   0D56 F9            leave
1496   0D57 09            ret
1497   0D58             ; --- BEGIN INLINE ASM SEGMENT
1498   0D58             _itoa_printx16:
1499   0D58 DA            push d
1500   0D59 D8            push b
1501   0D5A A7 00         mov bh, 0
1502   0D5C FD A4 04      shr bl, 4  
1503   0D5F 74            mov d, b
1504   0D60 1F 72 0D      mov al, [d + s_hex_digits_printx16]
1505   0D63 23            mov ah, al
1506   0D64 E5            pop b
1507   0D65 D8            push b
1508   0D66 A7 00         mov bh, 0
1509   0D68 FD 87 0F      and bl, $0F
1510   0D6B 74            mov d, b
1511   0D6C 1F 72 0D      mov al, [d + s_hex_digits_printx16]
1512   0D6F E5            pop b
1513   0D70 E7            pop d
1514   0D71 09            ret
1515   0D72 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1515   0D76 34 35 36 37 
1515   0D7A 38 39 41 42 
1515   0D7E 43 44 45 46 
1516   0D82             ; --- END INLINE ASM SEGMENT
1517   0D82 F9            leave
1518   0D83 09            ret
1519   0D84             ; --- END TEXT SEGMENT
1520   0D84             
1521   0D84             ; --- BEGIN DATA SEGMENT
1522   0D84 68 65 6C 6C _s0: .db "hello World", 0
1522   0D88 6F 20 57 6F 
1522   0D8C 72 6C 64 00 
1523   0D90 1B 5B 25 64 _s1: .db "\033[%d;%dH", 0
1523   0D94 3B 25 64 48 
1523   0D98 00 
1524   0D99 55 6E 65 78 _s2: .db "Unexpected format in printf.", 0
1524   0D9D 70 65 63 74 
1524   0DA1 65 64 20 66 
1524   0DA5 6F 72 6D 61 
1524   0DA9 74 20 69 6E 
1524   0DAD 20 70 72 69 
1524   0DB1 6E 74 66 2E 
1524   0DB5 00 
1525   0DB6 45 72 72 6F _s3: .db "Error: Unknown argument type.\n", 0
1525   0DBA 72 3A 20 55 
1525   0DBE 6E 6B 6E 6F 
1525   0DC2 77 6E 20 61 
1525   0DC6 72 67 75 6D 
1525   0DCA 65 6E 74 20 
1525   0DCE 74 79 70 65 
1525   0DD2 2E 0A 00 
1526   0DD5             
1527   0DD5 D7 0D       _heap_top: .dw _heap
1528   0DD7 00          _heap: .db 0
1529   0DD8             ; --- END DATA SEGMENT
1530   0DD8             
1531   0DD8             .end
tasm: Number of errors = 0
